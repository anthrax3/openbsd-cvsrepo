head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.10
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.20
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.18
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.16
	OPENBSD_5_0:1.6.0.14
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.12
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.10
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.6
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.03.14.23.08.05;	author krw;	state Exp;
branches;
next	1.9;
commitid	kCz5QgxnxRMKOzNf;

1.9
date	2015.09.14.17.34.03;	author semarie;	state Exp;
branches;
next	1.8;
commitid	5oNXDpLwnQIFT86m;

1.8
date	2014.02.23.06.16.45;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.21.21.51.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.25.16.55.31;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.28.22.17.21;	author pyr;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.15.20.42.33;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.16.04.30.09;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.39.02;	author drahn;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@/*	$OpenBSD: alloc.c,v 1.9 2015/09/14 17:34:03 semarie Exp $	*/
/*	$NetBSD: alloc.c,v 1.1 1997/04/16 20:29:16 thorpej Exp $	*/

/*
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1997 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1996
 *	Matthias Drochner.  All rights reserved.
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Dynamic memory allocator suitable for use with OpenFirmware.
 *
 * Compile options:
 *
 *	ALLOC_TRACE	enable tracing of allocations/deallocations
 *
 *	ALLOC_FIRST_FIT	use a first-fit allocation algorithm, rather than
 *			the default best-fit algorithm.
 *
 *	DEBUG		enable debugging sanity checks.
 */

#include <sys/param.h>
#include <sys/queue.h>

#include <lib/libsa/stand.h>

#include <macppc/stand/openfirm.h>

/*
 * Each block actually has ALIGN(struct ml) + ALIGN(size) bytes allocated
 * to it, as follows:
 *
 * 0 ... (sizeof(struct ml) - 1)
 *	allocated or unallocated: holds size of user-data part of block.
 *
 * sizeof(struct ml) ... (ALIGN(sizeof(struct ml)) - 1)
 *	allocated: unused
 *	unallocated: depends on packing of struct fl
 *
 * ALIGN(sizeof(struct ml)) ... (ALIGN(sizeof(struct ml)) +
 *   ALIGN(data size) - 1)
 *	allocated: user data
 *	unallocated: depends on packing of struct fl
 *
 * 'next' is only used when the block is unallocated (i.e. on the free list).
 * However, note that ALIGN(sizeof(struct ml)) + ALIGN(data size) must
 * be at least 'sizeof(struct fl)', so that blocks can be used as structures
 * when on the free list.
 */

/*
 * Memory lists.
 */
struct ml {
	unsigned	size;
	LIST_ENTRY(ml)	list;
};

LIST_HEAD(, ml) freelist = LIST_HEAD_INITIALIZER(freelist);
LIST_HEAD(, ml) allocatedlist = LIST_HEAD_INITIALIZER(allocatedlist);

#define	OVERHEAD	ALIGN(sizeof (struct ml))	/* shorthand */

void *
alloc(unsigned size)
{
	struct ml *f, *bestf = NULL;
	unsigned bestsize = 0xffffffff;	/* greater than any real size */
	char *help;
	int failed;

#ifdef ALLOC_TRACE
	printf("alloc(%u)", size);
#endif

	/*
	 * Account for overhead now, so that we don't get an
	 * "exact fit" which doesn't have enough space.
	 */
	size = ALIGN(size) + OVERHEAD;

#ifdef ALLOC_FIRST_FIT
	/* scan freelist */
	LIST_FOREACH(f, &freelist, list)
		if (f->size >= size)
			break;
	bestf = f;
	failed = (bestf == NULL);
#else
	/* scan freelist */
	LIST_FOREACH(f, &freelist, list) {
		if (f->size >= size) {
			if (f->size == size)	/* exact match */
				goto found;

			if (f->size < bestsize) {
				/* keep best fit */
				bestf = f;
				bestsize = f->size;
			}
		}
	}

	/* no match in freelist if bestsize unchanged */
	failed = (bestsize == 0xffffffff);
#endif

	if (failed) {	/* nothing found */
		/*
		 * Allocate memory from the OpenFirmware, rounded
		 * to page size, and record the chunk size.
		 */
		size = roundup(size, PAGE_SIZE);
		help = OF_claim(0, size, PAGE_SIZE);
		if (help == (char *)-1)
			panic("alloc: out of memory");

		f = (struct ml *)help;
		f->size = size;
#ifdef ALLOC_TRACE
		printf("=%lx (new chunk size %u)\n",
		    (u_long)(help + OVERHEAD), f->size);
#endif
		goto out;
	}

	/* we take the best fit */
	f = bestf;

found:
	/* remove from freelist */
	LIST_REMOVE(f, list);
	help = (char *)f;
#ifdef ALLOC_TRACE
	printf("=%lx (origsize %u)\n", (u_long)(help + OVERHEAD), f->size);
#endif
out:
	/* place on allocated list */
	LIST_INSERT_HEAD(&allocatedlist, f, list);
	return (help + OVERHEAD);
}

void
free(void *ptr, unsigned size)
{
	register struct ml *a;

	if (ptr == NULL)
		return;

	a = (struct ml *)((char *)ptr - OVERHEAD);

#ifdef ALLOC_TRACE
	printf("free(%lx, %u) (origsize %u)\n", (u_long)ptr, size, a->size);
#endif
#ifdef DEBUG
	if (size > a->size)
		printf("free %u bytes @@%lx, should be <=%u\n",
		    size, (u_long)ptr, a->size);
#endif

	/* Remove from allocated list, place on freelist. */
	LIST_REMOVE(a, list);
	LIST_INSERT_HEAD(&freelist, a, list);
}

void
freeall()
{
#ifdef __notyet__		/* Firmware bug ?! */
	struct ml *m;

	/* Release chunks on freelist... */
	while ((m = LIST_FIRST(&freelist)) != NULL) {
		LIST_REMOVE(m, list);
		OF_release(m, m->size);
	}

	/* ...and allocated list. */
	while ((m = LIST_FIRST(&allocated)) != NULL) {
		LIST_REMOVE(m, list);
		OF_release(m, m->size);
	}
#endif /* __notyet__ */
}
@


1.9
log
@unify free(NULL,size) behaviour by allowing passing NULL

ok millert@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.8 2014/02/23 06:16:45 jsg Exp $	*/
d118 1
a118 1
	failed = (bestf == (struct fl *)0);
@


1.8
log
@remove a surplus ')' in disabled code
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.7 2013/03/21 21:51:00 deraadt Exp $	*/
d176 6
a181 1
	register struct ml *a = (struct ml *)((char *)ptr - OVERHEAD);
@


1.7
log
@NBPG -> PAGE_SIZE, PGSHIFT -> PAGE_SHIFT, PGOFSET -> PAGE_MASK
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.6 2008/05/25 16:55:31 miod Exp $	*/
d205 1
a205 1
	while ((m = LIST_FIRST(&allocated)) != NULL)) {
@


1.6
log
@Don't forget to actually return a value in ttyname(), and fix a bunch of
warnings while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.5 2007/05/28 22:17:21 pyr Exp $	*/
d143 2
a144 2
		size = roundup(size, NBPG);
		help = OF_claim(0, size, NBPG);
@


1.5
log
@avoid bypassing sys/queue.h in many places in the kernel.
many assumptions were made about the way the various list types are
implemented.

lots of suggestions and help from otto and miod.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.4 2005/09/15 20:42:33 kettenis Exp $	*/
a88 3
/* XXX - this is from NetBSD  */
#define LIST_HEAD_INITIALIZER(head) { NULL }

d97 1
a97 1
	struct ml *f, *bestf;
@


1.4
log
@Fix typo.
ok miod@@, drahn@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.3 2003/10/16 04:30:09 drahn Exp $	*/
d117 3
a119 3
	for (f = freelist.lh_first; f != NULL && f->size < size;
	    f = f->list.le_next)
		/* noop */ ;
d124 1
a124 2
	f = freelist.lh_first;
	while (f != NULL) {
a134 1
		f = f->list.le_next;
d202 1
a202 1
	while ((m = freelist.lh_first) != NULL) {
d208 1
a208 1
	while ((m = allocatedlist.lh_first) != NULL) {
@


1.3
log
@There is no end to the ANSI/KNF journey.
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.3 2003/10/16 04:26:36 drahn Exp $	*/
d157 1
a157 1
		    (u_long)(help + OVERHEAD), f->f_size);
@


1.2
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.1 2001/09/01 15:39:02 drahn Exp $	*/
d98 1
a98 2
alloc(size)
	unsigned size;
d165 1
a165 1
 found:
d172 1
a172 1
 out:
d179 1
a179 3
free(ptr, size)
	void *ptr;
	unsigned size;	/* only for consistenct check */
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/stand to macppc/stand
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.6 1999/11/09 06:30:15 rahnds Exp $	*/
d184 1
a184 1
	register struct ml *a = (struct ml *)((char*)ptr - OVERHEAD);
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.1 2001/09/01 15:39:02 drahn Exp $	*/
d184 1
a184 1
	register struct ml *a = (struct ml *)((char *)ptr - OVERHEAD);
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current from about a week ago
@
text
@d184 1
a184 1
	register struct ml *a = (struct ml *)((char *)ptr - OVERHEAD);
@


1.1.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d98 2
a99 1
alloc(unsigned size)
d166 1
a166 1
found:
d173 1
a173 1
out:
d180 3
a182 1
free(void *ptr, unsigned size)
@


