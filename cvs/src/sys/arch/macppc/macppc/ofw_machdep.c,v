head	1.56;
access;
symbols
	OPENBSD_6_2_BASE:1.56
	OPENBSD_6_1:1.55.0.10
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.6
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.37.0.4
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.8
	OPENBSD_5_0:1.35.0.6
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.4
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.34.0.4
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.8
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.6
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.4
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.17
	UBC:1.5.0.2
	UBC_BASE:1.5
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.56
date	2017.07.22.18.33.38;	author anton;	state Exp;
branches;
next	1.55;
commitid	nCBKX4sXOCD6tg16;

1.55
date	2015.07.21.05.58.34;	author jsg;	state Exp;
branches;
next	1.54;
commitid	vQBudHYirl6cK9Yx;

1.54
date	2015.06.26.10.17.21;	author mpi;	state Exp;
branches;
next	1.53;
commitid	0xkV7Ilt72yZq8mU;

1.53
date	2015.06.24.14.09.32;	author mpi;	state Exp;
branches;
next	1.52;
commitid	I8mB8QH9AKZeZaoL;

1.52
date	2015.06.05.10.24.23;	author mpi;	state Exp;
branches;
next	1.51;
commitid	g3kKTxxRbuxYdVVJ;

1.51
date	2015.04.07.14.36.34;	author mpi;	state Exp;
branches;
next	1.50;
commitid	gPSqrQuekAvjvfCt;

1.50
date	2015.03.31.10.36.52;	author mpi;	state Exp;
branches;
next	1.49;
commitid	rxWnYYKHwQIW0yI8;

1.49
date	2015.03.11.07.55.40;	author mpi;	state Exp;
branches;
next	1.48;
commitid	SannFFt8AJWEYtaG;

1.48
date	2015.02.11.06.19.20;	author mpi;	state Exp;
branches;
next	1.47;
commitid	xpYqWy8W4F33P4nV;

1.47
date	2015.02.10.08.56.28;	author mpi;	state Exp;
branches;
next	1.46;
commitid	BJ8dQZJUxE7INcwX;

1.46
date	2014.04.01.20.27.14;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2014.02.08.13.17.38;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2014.01.04.20.28.24;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2013.08.28.20.47.10;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2013.08.28.07.03.02;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2013.08.27.21.00.52;	author mpi;	state Exp;
branches;
next	1.40;

1.40
date	2013.08.23.08.52.24;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2013.08.12.08.03.56;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2013.08.07.07.29.19;	author mpi;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.21.11.43.41;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2012.06.21.10.08.16;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.30.22.42.55;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2008.09.23.20.45.26;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.15.07.37.05;	author todd;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.17.16.27.55;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.12.16.50.13;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.18.23.21.17;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.01.11.59.39;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.08.19.08.23;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.24.22.35.56;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.17.15.47.59;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.30.03.17.54;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.22.20.56.10;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.16.05.03.22;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.02.21.30.13;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.16.00.37.35;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.11.22.35.01;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.06.13.56.51;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.20.02.50.43;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.09.04.13.13;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.22.21.00.00;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.29.01.34.58;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.09.21.46.05;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.02.17.13.25;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.01.22.47.48;	author drahn;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.09.11.06.47.00;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.10.52;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.01.31.22.55.14;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Initialize the brightness to a valid value if found.

ok deraadt@@
@
text
@/*	$OpenBSD: ofw_machdep.c,v 1.55 2015/07/21 05:58:34 jsg Exp $	*/
/*	$NetBSD: ofw_machdep.c,v 1.1 1996/09/30 16:34:50 ws Exp $	*/

/*
 * Copyright (C) 1996 Wolfgang Solfrank.
 * Copyright (C) 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "akbd.h"
#include "ukbd.h"
#include "wsdisplay.h"
#include "zstty.h"

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <powerpc/powerpc.h>
#include <machine/autoconf.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_pci.h>

#include <macppc/macppc/ofw_machdep.h>

#if NAKBD > 0
#include <dev/adb/akbdvar.h>
#endif

#if NUKBD > 0
#include <dev/usb/ukbdvar.h>
#endif

#if NWSDISPLAY > 0
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#endif

struct mem_region64 {
	uint64_t start;
	uint32_t size;
} __packed;

#define	OFMEM_REGIONS	32
static struct mem_region   OFmem[OFMEM_REGIONS + 1], OFavail[OFMEM_REGIONS + 3];
static struct mem_region64 OFmem64[OFMEM_REGIONS + 1];

/*
 * Section 5.1.7. Memory Management Unit properties.
 */
struct ofw_map {
	uint32_t	om_virt;
	uint32_t	om_size;
	uint32_t	om_phys;
	uint32_t	om_mode;
} __packed;

struct ofw_map64 {
	uint32_t	om_virt;
	uint32_t	om_size;
	uint64_t	om_phys;
	uint32_t	om_mode;
} __packed;

static struct ofw_map	ofw_maps[OFMEM_REGIONS];
static struct ofw_map64	ofw_maps64[OFMEM_REGIONS];

#if NWSDISPLAY > 0
struct ofwfb {
	struct rasops_info	ofw_ri;
	struct wsscreen_descr	ofw_wsd;
};

/* Early boot framebuffer */
static struct ofwfb ofwfb;
#endif

int	save_ofw_mapping(void);
void	ofw_consinit(int);
void	ofw_read_mem_regions(int, int, int);

/*
 * This is called during initppc, before the system is really initialized.
 * It shall provide the total and the available regions of RAM.
 * Both lists must have a zero-size entry as terminator.
 * The available regions need not take the kernel into account, but needs
 * to provide space for two additional entry beyond the terminating one.
 */
void
ppc_mem_regions(struct mem_region **memp, struct mem_region **availp)
{
	*memp = OFmem;

	/* HACK */
	if (OFmem[0].size == 0) {
		*memp = OFavail;
	}

	*availp = OFavail;
}

void
ofw_read_mem_regions(int phandle, int address_cells, int size_cells)
{
	int nreg, navail;
	int i, j;
	uint physpages;

	switch (address_cells) {
	default:
	case 1:
		nreg = OF_getprop(phandle, "reg", OFmem,
		    sizeof(OFmem[0]) * OFMEM_REGIONS) / sizeof(OFmem[0]);
		break;
	case 2:
		nreg = OF_getprop(phandle, "reg", OFmem64,
		    sizeof(OFmem64[0]) * OFMEM_REGIONS) / sizeof(OFmem64[0]);
		break;
	}

	navail = OF_getprop(phandle, "available", OFavail,
	    sizeof(OFavail[0]) * OFMEM_REGIONS) / sizeof(OFavail[0]);
	if (nreg <= 0 || navail <= 0)
		panic("no memory?");

	/* Eliminate empty or unreachable regions. */
	switch (address_cells) {
	default:
	case 1:
		for (i = 0, j = 0; i < nreg; i++) {
			if (OFmem[i].size == 0)
				continue;
			if (i != j) {
				OFmem[j].start = OFmem[i].start;
				OFmem[j].size = OFmem[i].size;
				OFmem[i].start = 0;
				OFmem[i].size = 0;
			}
			j++;
		}
		break;
	case 2:
		physpages = 0;
		for (i = 0, j = 0; i < nreg; i++) {
			if (OFmem64[i].size == 0)
				continue;
			physpages += atop(OFmem64[i].size);
			if (OFmem64[i].start >= 1ULL << 32)
				continue;
			OFmem[j].start = OFmem64[i].start;
			if (OFmem64[i].start + OFmem64[i].size >= 1ULL << 32)
				OFmem[j].size = (1ULL << 32) - OFmem64[i].start;
			else
				OFmem[j].size = OFmem64[i].size;
			j++;
		}
		physmem = physpages;
		break;
	}
}

typedef void (fwcall_f)(int, int);
extern fwcall_f *fwcall;
fwcall_f fwentry;

int OF_stdout;
int OF_stdin;

/*
 * Called early in the boot process, we are still running on the stack
 * provided by the bootloader using the firmware's page table.
 */
int
save_ofw_mapping(void)
{
	int chosen, memory, root, mmui, mmu = -1;
	int acells, scells;
	int i, len;

	if ((chosen = OF_finddevice("/chosen")) == -1)
		return (0);

	ofw_consinit(chosen);

	/* Get memory node. */
	memory = OF_finddevice("/memory");
	if (memory == -1)
		panic("no memory?");

	/* Are physical addresses encoded in 32 or 64 bits? */
	root = OF_parent(memory);
	if (OF_getprop(root, "#address-cells", &acells, 4) <= 0)
		acells = 1;
	if (OF_getprop(root, "#size-cells", &scells, 4) <= 0)
		scells = 1;

	if (scells != 1)
		panic("unexpected memory layout %d:%d", acells, scells);

	ofw_read_mem_regions(memory, acells, scells);

	/* Get firmware mappings. */
	if (OF_getprop(chosen, "mmu", &mmui, sizeof(int)) != -1)
		mmu = OF_instance_to_package(mmui);
	if (mmu != -1) {
		len = OF_getproplen(mmu, "translations");
		if (len <= 0)
			return (0);
	}

	switch (acells) {
	case 2:
		OF_getprop(mmu, "translations", ofw_maps64, sizeof(ofw_maps64));

		for (i = 0; i < nitems(ofw_maps64); i++) {
			if (ofw_maps64[i].om_phys >= 1ULL << 32)
				continue;

			ofw_maps[i].om_virt = ofw_maps64[i].om_virt;
			ofw_maps[i].om_size = ofw_maps64[i].om_size;
			ofw_maps[i].om_phys = (uint32_t)ofw_maps64[i].om_phys;
			ofw_maps[i].om_mode = ofw_maps64[i].om_mode;
		}
		break;
	case 1:
	default:
		OF_getprop(mmu, "translations", ofw_maps, sizeof(ofw_maps));
		break;
	}

	/*
	 * Next time we'll call the firmware make sure we save and
	 * restore our MMU settings.
	 */
	fwcall = &fwentry;

	return (0);
}

static int display_ofh;
int cons_brightness;
int cons_backlight_available;
int fbnode;

void of_display_console(void);

void
ofwconprobe()
{
	char type[32];
	int stdout_node;

	stdout_node = OF_instance_to_package(OF_stdout);

	/* handle different types of console */

	bzero(type, sizeof(type));
	if (OF_getprop(stdout_node,  "device_type", type, sizeof(type)) == -1) {
		return; /* XXX */
	}
	if (strcmp(type, "display") == 0) {
		of_display_console();
		return;
	}
	if (strcmp(type, "serial") == 0) {
#if NZSTTY > 0
		/* zscnprobe/zscninit do all the required initialization */
		return;
#endif
	}

	OF_stdout = OF_open("screen");
	OF_stdin = OF_open("keyboard");

	/* cross fingers that this works. */
	of_display_console();

	return;
}

#define DEVTREE_UNKNOWN 0
#define DEVTREE_USB	1
#define DEVTREE_ADB	2
int ofw_devtree = DEVTREE_UNKNOWN;

#define OFW_HAVE_USBKBD 1
#define OFW_HAVE_ADBKBD 2
int ofw_have_kbd = 0;

void ofw_recurse_keyboard(int pnode);
void ofw_find_keyboard(void);

void
ofw_recurse_keyboard(int pnode)
{
	char name[32];
	int old_devtree;
	int len;
	int node;

	for (node = OF_child(pnode); node != 0; node = OF_peer(node)) {

		len = OF_getprop(node, "name", name, 20);
		if (len == 0)
			continue;
		name[len] = 0;
		if (strcmp(name, "keyboard") == 0) {
			/* found a keyboard node, where is it? */
			if (ofw_devtree == DEVTREE_USB) {
				ofw_have_kbd |= OFW_HAVE_USBKBD;
			} else if (ofw_devtree == DEVTREE_ADB) {
				ofw_have_kbd |= OFW_HAVE_ADBKBD;
			} else {
				/* hid or some other keyboard? igore */
			}
			continue;
		}

		old_devtree = ofw_devtree;

		if (strcmp(name, "adb") == 0) {
			ofw_devtree = DEVTREE_ADB;
		}
		if (strcmp(name, "usb") == 0) {
			ofw_devtree = DEVTREE_USB;
		}

		ofw_recurse_keyboard(node);

		ofw_devtree = old_devtree; /* nest? */
	}
}

void
ofw_find_keyboard()
{
	int stdin_node;
	char iname[32];
	int len, attach = 0;

	stdin_node = OF_instance_to_package(OF_stdin);
	len = OF_getprop(stdin_node, "name", iname, 20);
	iname[len] = 0;
	printf(" console in [%s]", iname);

	/* GRR, apple removed the interface once used for keyboard
	 * detection walk the OFW tree to find keyboards and what type.
	 */

	ofw_recurse_keyboard(OF_peer(0));

	len = OF_getprop(OF_peer(0), "model", iname, sizeof(iname));
	iname[len] = 0;

	if (ofw_have_kbd == (OFW_HAVE_USBKBD | OFW_HAVE_ADBKBD)) {
		/*
		 * If a PowerBook reports having ABD and USB keyboards,
		 * use the builtin ADB one for console, the USB one is
		 * certainly a HID device.
		 */
		 if (strncmp(iname, "PowerBook", 9) == 0)
			ofw_have_kbd = OFW_HAVE_ADBKBD;
		else
			ofw_have_kbd = OFW_HAVE_USBKBD;
		printf("USB and ADB found");
	}
	if (ofw_have_kbd == OFW_HAVE_USBKBD) {
#if NUKBD > 0
		printf(", using USB\n");
		ukbd_cnattach();
		attach = 1;
#endif
	} else if (ofw_have_kbd == OFW_HAVE_ADBKBD) {
#if NAKBD >0
		printf(", using ADB\n");
		akbd_cnattach();
		attach = 1;
#endif
	} 
	if (attach == 0) {
#if NUKBD > 0
		printf(", no keyboard attached, trying usb anyway\n");
		ukbd_cnattach();
#else
		printf(", no keyboard found!\n");
#endif
	}
}

void
of_display_console(void)
{
	struct ofw_pci_register addr[8];
	int cons_height, cons_width, cons_linebytes, cons_depth;
	uint32_t cons_addr;
	char name[32];
	int len, err;
	int stdout_node;

	stdout_node = OF_instance_to_package(OF_stdout);
	len = OF_getprop(stdout_node, "name", name, 20);
	name[len] = 0;
	printf("console out [%s]", name);
	display_ofh = OF_stdout;
	err = OF_getprop(stdout_node, "width", &cons_width, 4);
	if ( err != 4) {
		cons_width = 0;
	}
	err = OF_getprop(stdout_node, "linebytes", &cons_linebytes, 4);
	if ( err != 4) {
		cons_linebytes = cons_width;
	}
	err = OF_getprop(stdout_node, "height", &cons_height, 4);
	if ( err != 4) {
		cons_height = 0;
	}
	err = OF_getprop(stdout_node, "depth", &cons_depth, 4);
	if ( err != 4) {
		cons_depth = 0;
	}
	err = OF_getprop(stdout_node, "address", &cons_addr, 4);
	if ( err != 4) {
		OF_interpret("frame-buffer-adr", 1, &cons_addr);
	}

	ofw_find_keyboard();

	fbnode = stdout_node;
	len = OF_getprop(stdout_node, "assigned-addresses", addr, sizeof(addr));
	if (len == -1) {
		fbnode = OF_parent(stdout_node);
		len = OF_getprop(fbnode, "name", name, 20);
		name[len] = 0;

		printf("using parent %s:", name);
		len = OF_getprop(fbnode, "assigned-addresses",
			addr, sizeof(addr));
		if (len < sizeof(addr[0])) {
			panic(": no address");
		}
	}

	if (OF_getnodebyname(0, "backlight") != 0) {
		cons_backlight_available = 1;
		cons_brightness = MAX_BRIGHTNESS;
	}

#if 1
	printf(": memaddr %x, size %x ", addr[0].phys_lo, addr[0].size_lo);
	printf(": consaddr %x ", cons_addr);
	printf(": ioaddr %x, size %x", addr[1].phys_lo, addr[1].size_lo);
	printf(": width %d linebytes %d height %d depth %d\n",
		cons_width, cons_linebytes, cons_height, cons_depth);
#endif

#if NWSDISPLAY > 0
{
	struct ofwfb *fb = &ofwfb;
	struct rasops_info *ri = &fb->ofw_ri;
	long defattr;

	ri->ri_width = cons_width;
	ri->ri_height = cons_height;
	ri->ri_depth = cons_depth;
	ri->ri_stride = cons_linebytes;
	ri->ri_flg = RI_CENTER | RI_FULLCLEAR | RI_CLEAR;
	ri->ri_bits = (void *)mapiodev(cons_addr, cons_linebytes * cons_height);
	ri->ri_hw = fb;

	if (cons_depth == 8)
		of_setcolors(rasops_cmap, 0, 256);

	rasops_init(ri, 160, 160);

	strlcpy(fb->ofw_wsd.name, "std", sizeof(fb->ofw_wsd.name));
	fb->ofw_wsd.capabilities = ri->ri_caps;
	fb->ofw_wsd.ncols = ri->ri_cols;
	fb->ofw_wsd.nrows = ri->ri_rows;
	fb->ofw_wsd.textops = &ri->ri_ops;
#if 0
	fb->ofw_wsd.fontwidth = ri->ri_font->fontwidth;
	fb->ofw_wsd.fontheight = ri->ri_font->fontheight;
#endif

	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&fb->ofw_wsd, ri, 0, 0, defattr);
}
#endif
}

void
ofwconsswitch(struct rasops_info *ri)
{
#if NWSDISPLAY > 0
	ri->ri_width = ofwfb.ofw_ri.ri_width;
	ri->ri_height = ofwfb.ofw_ri.ri_height;
	ri->ri_depth = ofwfb.ofw_ri.ri_depth;
	ri->ri_stride = ofwfb.ofw_ri.ri_stride;

	ri->ri_bits = ofwfb.ofw_ri.ri_bits /* XXX */;
#endif
}

void
of_setbacklight(int on)
{
	if (cons_backlight_available == 0)
		return;

	if (on)
		OF_call_method_1("backlight-on", display_ofh, 0);
	else
		OF_call_method_1("backlight-off", display_ofh, 0);
}

void
of_setbrightness(int brightness)
{
	if (cons_backlight_available == 0)
		return;

	if (brightness < MIN_BRIGHTNESS)
		brightness = MIN_BRIGHTNESS;
	else if (brightness > MAX_BRIGHTNESS)
		brightness = MAX_BRIGHTNESS;

	cons_brightness = brightness;

	/*
	 * The OF method is called "set-contrast" but affects brightness.
	 * Don't ask.
	 */
	OF_call_method_1("set-contrast", display_ofh, 1, cons_brightness);

	/* XXX this routine should also save the brightness settings in the nvram */
}

uint8_t of_cmap[256 * 3];

void
of_setcolors(const uint8_t *cmap, unsigned int index, unsigned int count)
{
	bcopy(cmap, of_cmap, sizeof(of_cmap));
	OF_call_method_1("set-colors", display_ofh, 3, &of_cmap, index, count);
}

#include <dev/cons.h>

cons_decl(ofw);

/*
 * Console support functions
 */
void
ofwcnprobe(struct consdev *cd)
{
}

void
ofwcninit(struct consdev *cd)
{
}
void
ofwcnputc(dev_t dev, int c)
{
	char ch = c;

	OF_write(OF_stdout, &ch, 1);
}
int
ofwcngetc(dev_t dev)
{
        unsigned char ch = '\0';
        int l;

        while ((l = OF_read(OF_stdin, &ch, 1)) != 1)
                if (l != -2 && l != 0)
                        return -1;
        return ch;
}

void
ofwcnpollc(dev_t dev, int on)
{
}

struct consdev consdev_ofw = {
        ofwcnprobe,
        ofwcninit,
        ofwcngetc,
        ofwcnputc,
        ofwcnpollc,
        NULL,
};

void
ofw_consinit(int chosen)
{
	struct consdev *cp = &consdev_ofw;

	OF_getprop(chosen, "stdin", &OF_stdin, sizeof(OF_stdin));
	OF_getprop(chosen, "stdout", &OF_stdout, sizeof(OF_stdout));

	/* If the screen is to be console, but not active, open it */
	if (OF_stdout == 0)
		OF_stdout = OF_open("screen");

	cn_tab = cp;
}

@


1.55
log
@add braces to avoid an uninitialised variable use
ok mpi@@ looks correct miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.54 2015/06/26 10:17:21 mpi Exp $	*/
d472 1
a472 1
	if (OF_getnodebyname(0, "backlight") != 0)
d474 2
@


1.54
log
@Do not compare against a null string.  When ofw_find_keyboard() is run
hw_prod is not initialized.

While here simply use "PowerBook" as model name, there's no "iBook"
model in Apple device-trees.

ok miod@@ (who's cleaning one of his forests after 3 years)
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.53 2015/06/24 14:09:32 mpi Exp $	*/
d234 1
a234 1
	if (mmu != -1)
d236 3
a238 2
	if (len <= 0)
		return (0);
@


1.53
log
@Do not quiesce the firmware on Quad G5 to let it manage the fans.

This also unbreak "bsd -cd" on such machine since we use OpenFirmware's
input at this stage of the boot process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.52 2015/06/05 10:24:23 mpi Exp $	*/
a67 2
extern char *hw_prod;

d380 2
d385 3
a387 5
		 * On some machines, such as PowerBook6,8,
		 * the built-in USB Bluetooth device
		 * appears as an USB device.  Prefer
		 * ADB (builtin) keyboard for console
		 * for PowerBook systems.
d389 1
a389 2
		if (strncmp(hw_prod, "PowerBook", 9) ||
		    strncmp(hw_prod, "iBook", 5)) {
d391 1
a391 1
		} else {
a392 1
		}
@


1.52
log
@Put spaces and commas where they belong.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.51 2015/04/07 14:36:34 mpi Exp $	*/
a208 1
	char model[32];
a259 11

	/*
	 * Tell the firmware to stop pending DMAs, and on the machines
	 * listed below it is necessary to shut down the fan management
	 * thread.
	 */
	len = OF_getprop(root, "model", model, sizeof(model));
	model[len] = 0;
	if (strcmp(model, "PowerMac11,2") == 0 ||
	    strcmp(model, "PowerMac12,1") == 0)
		OF_quiesce();
@


1.51
log
@Remove a lie, the early boot console does not need any mapping.

In fact we even use the firmware interface for "bsd -c" and "bsd -d".
So do the necessary firmware calls before calling initppc() to be able
to use printf() really early in the boot sequence.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.50 2015/03/31 10:36:52 mpi Exp $	*/
d386 1
a386 1
	printf("console in [%s] ", iname);
d491 2
a492 2
	printf(": memaddr %x size %x, ", addr[0].phys_lo, addr[0].size_lo);
	printf(": consaddr %x, ", cons_addr);
@


1.50
log
@Tell the firmware to shut down the fan management thread on the last
generation of G5s.  Without this my PowerMac11,2 hang when smu(4)
attaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.49 2015/03/11 07:55:40 mpi Exp $	*/
d110 1
a110 1
void	ofw_open_inputs(int);
d215 1
a215 1
	ofw_open_inputs(chosen);
d273 6
a281 21
void
ofw_open_inputs(int chosen)
{
	int stdout, stdin;

	if (OF_getprop(chosen, "stdin", &stdin, sizeof(int)) != sizeof(int)) 
		return;

	OF_stdin = stdin;
	if (OF_getprop(chosen, "stdout", &stdout, sizeof(int)) != sizeof(int))
		return;

	if (stdout == 0) {
		/* If the screen is to be console, but not active, open it */
		stdout = OF_open("screen");
	}
	OF_stdout = stdout;

	fwcall = &fwentry;
}

d639 1
a639 1
ofwconsinit()
d641 9
a649 2
	struct consdev *cp;
	cp = &consdev_ofw;
d652 1
@


1.49
log
@Remove unused type definitions.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.48 2015/02/11 06:19:20 mpi Exp $	*/
d209 1
d261 11
@


1.48
log
@Save OpenFirmware mappings in save_ofw_mapping(), currently unused
but required for upcoming firmware callback improvement.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.47 2015/02/10 08:56:28 mpi Exp $	*/
a284 1
bus_space_handle_t cons_display_mem_h;
a288 5

struct usb_kbd_ihandles {
        struct usb_kbd_ihandles *next;
	int ihandle;
};
@


1.47
log
@Correctly parse memory regions from the firmware on 64bit machines.

With miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.46 2014/04/01 20:27:14 mpi Exp $	*/
a67 3
/* XXX, called from asm */
int save_ofw_mapping(void);

a69 3
#define	OFMEM_REGIONS	32
static struct mem_region OFmem[OFMEM_REGIONS + 1], OFavail[OFMEM_REGIONS + 3];

d75 2
d79 20
d109 4
d123 13
a135 1
	int phandle, rhandle;
a137 1
	uint32_t address_cells, size_cells;
a139 17
	/*
	 * Get memory.
	 */
	phandle = OF_finddevice("/memory");
	if (phandle == -1)
		panic("no memory?");
	rhandle = OF_parent(phandle);

	if (OF_getprop(rhandle, "#address-cells", &address_cells, 4) <= 0)
		address_cells = 1;
	if (OF_getprop(rhandle, "#size-cells", &size_cells, 4) <= 0)
		size_cells = 1;

	if (size_cells != 1)
		panic("unexpected memory layout %d:%d",
		    address_cells, size_cells);

a190 9

	*memp = OFmem;

	/* HACK */
	if (OFmem[0].size == 0) {
		*memp = OFavail;
	}

	*availp = OFavail;
a195 1
extern u_int32_t ofmsr;
d200 3
a202 2
/* code to save and create the necessary mappings for BSD to handle
 * the vm-setup for OpenFirmware
a203 1

d205 1
a205 1
save_ofw_mapping()
d207 41
a247 2
	int chosen;
	int stdout, stdin;
d249 10
a258 2
	if ((chosen = OF_finddevice("/chosen")) == -1) {
		return 0;
d261 10
a270 3
	if (OF_getprop(chosen, "stdin", &stdin, sizeof stdin) != sizeof stdin) {
		return 0;
	}
d273 2
a274 4
	if (OF_getprop(chosen, "stdout", &stdout, sizeof stdout)
	    != sizeof stdout) {
		return 0;
	}
a282 1
	return 0;
@


1.46
log
@Remove the almost unused abstraction around "struct firmware" and use
instead a single function ppc_mem_regions() required by the ppc pmap.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.45 2014/02/08 13:17:38 miod Exp $	*/
d79 1
a79 1
};
d117 1
a117 1
	if (OF_getprop(phandle, "#address-cells", &address_cells, 4) <= 0)
d119 1
a119 1
	if (OF_getprop(phandle, "#size-cells", &size_cells, 4) <= 0)
d133 1
a133 1
		nreg = OF_getprop(phandle, "reg", OFmem,
@


1.45
log
@Some (if not all) G5 systems use a different layout for the physical memory
information (property `reg' of the `/memory' node). Fortunately the available
physical memory information still uses the same format, so this only affects
the computation of physmem.

Detect this case and parse the information correctly, converting to the format
expected by pmap, ignoring physical memory beyond 4GB.

Compute physmem from all the physical memory information, even memory not
usable by the kernel. Let pmap not recompute physmem in pmap_bootstrap() if
physmem is != 0 upon entry.

This should allow G5 systems fitted with more than 2GB of physical memory to
report the correct amount of memory, even though the kernel will only use
the lower 2GB.

Prompted by a dmesg@@ submission by Greg Marsh, owner of a 3.5GB G5

help and tweaks kettenis@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.44 2014/01/04 20:28:24 miod Exp $	*/
d47 1
a47 1
#include <machine/powerpc.h>
a70 5
void OF_exit(void) __attribute__((__noreturn__));
void OF_boot(char *bootspec) __attribute__((__noreturn__));
void ofw_mem_regions(struct mem_region **memp, struct mem_region **availp);
void ofw_vmon(void);

a72 10
struct firmware ofw_firmware = {
	ofw_mem_regions,
	OF_exit,
	OF_boot,
	ofw_vmon
#ifdef FW_HAS_PUTC
	ofwcnputc;
#endif
};

d101 1
a101 1
ofw_mem_regions(struct mem_region **memp, struct mem_region **availp)
a192 6
void
ofw_vmon()
{
	fwcall = &fwentry;
}

a225 1
	fw = &ofw_firmware;
@


1.44
log
@Fix of_cmap[] size. Makes the textmode cursor reappear on vgafb (i.e.
non-radeon) systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.43 2013/08/28 20:47:10 mpi Exp $	*/
d91 7
d118 1
a118 1
	int phandle;
d121 2
d130 22
a152 2
	nreg = OF_getprop(phandle, "reg", OFmem,
	    sizeof(OFmem[0]) * OFMEM_REGIONS) / sizeof(OFmem[0]);
d158 30
a187 9
	/* Eliminate empty regions. */
	for (i = 0, j = 0; i < nreg; i++) {
		if (OFmem[i].size == 0)
			continue;
		if (i != j) {
			OFmem[j].start = OFmem[i].start;
			OFmem[j].size = OFmem[i].size;
			OFmem[i].start = 0;
			OFmem[i].size = 0;
d189 2
a190 1
		j++;
@


1.43
log
@Move the early framebuffer initialization code outside of vgafb(4)
and introduce a function to get the cursor position an unmap the
stolen memory region when switching to the real framebuffer.

For the moment we still reuse the original region but this allows
me to move forward and it buys us the posibility to have an early
framebuffer without vgafb (i.e. radeondrm(4) only).
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.42 2013/08/28 07:03:02 mpi Exp $	*/
d505 1
a505 1
uint8_t of_cmap[256];
@


1.42
log
@Fix build, reported by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.41 2013/08/27 21:00:52 mpi Exp $	*/
d34 6
a40 1
#include <sys/buf.h>
a42 6
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/stat.h>
a43 1
#include <sys/timeout.h>
d55 5
a59 3
#include "ukbd.h"
#include "akbd.h"
#include "zstty.h"
d61 6
a66 2
#include <dev/adb/akbdvar.h>
#include <dev/usb/usbdevs.h>
d91 10
a200 2
struct ppc_bus_space ppc_membus;
bus_space_tag_t cons_membus = &ppc_membus;
a201 1
int cons_height, cons_width, cons_linebytes, cons_depth;
a202 1
u_int32_t cons_addr;
a206 2
#include "vgafb.h"

d360 1
a360 1
of_display_console()
d363 2
d366 1
a366 1
	int len;
a367 1
	int err;
d423 27
a449 3
	cons_membus->bus_base = 0x80000000;
#if NVGAFB > 0
	vgafb_cnattach(cons_membus, cons_membus, -1, 0);
d452 17
a468 2
	if (cons_backlight_available == 1)
		of_setbrightness(DEFAULT_BRIGHTNESS);
d505 1
a505 3
struct {
	uint8_t r, g, b;
} of_colors[256];
d508 1
a508 2
of_setcolors(unsigned int idx, unsigned int cnt, uint8_t *r, uint8_t *g,
    uint8_t *b)
d510 2
a511 10
	int i;

	for (i = 0; i < cnt; i++) {
		of_colors[i].r = *r;
		of_colors[i].g = *g;
		of_colors[i].b = *b;
		r++, g++, b++;
	}

	OF_call_method_1("set-colors", display_ofh, 3, &of_colors, idx, cnt);
@


1.41
log
@Since we are no longer attaching radeondrm(4) to this driver there is
no reason to pretend being compatible with the MI vga layer.  So stop
using the vga_pci_bar interface and reduce the differences with the
sparc64 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.40 2013/08/23 08:52:24 mpi Exp $	*/
d197 1
a197 1
#include "vgafb_pci.h"
d415 1
a415 1
#if NVGAFB_PCI > 0
@


1.40
log
@Move the openfirmware color selection code outside of vgafb(4) to
be able to configure an early console framebuffer without depending
on this driver
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.39 2013/08/12 08:03:56 mpi Exp $	*/
a185 2

#include <arch/macppc/pci/vgafb_pcivar.h>
@


1.39
log
@Match the framebuffer device against its OpenFirmware node in order
to share the console detection logic with sparc64 in radeondrm(4).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.38 2013/08/07 07:29:19 mpi Exp $	*/
d193 1
a193 1
int cons_display_ofh;
a355 1
#if NVGAFB_PCI > 0
d366 1
a366 1
	cons_display_ofh = OF_stdout;
d417 1
d419 1
d423 12
a434 1
#endif
a439 2

#if NVGAFB_PCI > 0
d454 1
a454 1
	OF_call_method_1("set-contrast", cons_display_ofh, 1, cons_brightness);
d457 20
a476 1
#endif
@


1.38
log
@Mimic what's done on sparc64 and parse the OpenFirmware device tree to
enumerate the pci devices.  This allow us to not store the interrupt
vector in the interrupt line register and to not try to attach pci
devices disabled by firmware.

With inputs from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.37 2013/01/21 11:43:41 mpi Exp $	*/
a186 1
#include <dev/pci/pcivar.h>
d197 1
a360 1
	int display_node;
d391 1
a391 1
	display_node = stdout_node;
d394 2
a395 2
		display_node = OF_parent(stdout_node);
		len = OF_getprop(display_node, "name", name, 20);
d399 1
a399 1
		len = OF_getprop(display_node, "assigned-addresses",
a407 5

	vgafb_pci_console_tag = PCITAG_CREATE(display_node,
	    OFW_PCI_PHYS_HI_BUS(addr[1].phys_hi),
	    OFW_PCI_PHYS_HI_DEVICE(addr[1].phys_hi),
	    OFW_PCI_PHYS_HI_FUNCTION(addr[1].phys_hi));
@


1.37
log
@Remove unused variable, leftover from rev 1.36.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.36 2012/06/21 10:08:16 mpi Exp $	*/
d53 1
a188 23
static pcitag_t ofw_make_tag( void *cpv, int bus, int dev, int fnc);

/* ARGSUSED */
static pcitag_t
ofw_make_tag(void *cpv, int bus, int dev, int fnc)
{
        return (bus << 16) | (dev << 11) | (fnc << 8);
}

#define       OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define       OFW_PCI_PHYS_HI_BUSSHIFT        16
#define       OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define       OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define       OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define       OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8

#define pcibus(x) \
	(((x) & OFW_PCI_PHYS_HI_BUSMASK) >> OFW_PCI_PHYS_HI_BUSSHIFT)
#define pcidev(x) \
	(((x) & OFW_PCI_PHYS_HI_DEVICEMASK) >> OFW_PCI_PHYS_HI_DEVICESHIFT)
#define pcifunc(x) \
	(((x) & OFW_PCI_PHYS_HI_FUNCTIONMASK) >> OFW_PCI_PHYS_HI_FUNCTIONSHIFT)

d357 1
a362 5
	u_int32_t memtag, iotag;
	struct {
		u_int32_t phys_hi, phys_mid, phys_lo;
		u_int32_t size_hi, size_lo;
	} addr [8];
d410 4
a413 6
	memtag = ofw_make_tag(NULL, pcibus(addr[0].phys_hi),
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
	iotag = ofw_make_tag(NULL, pcibus(addr[1].phys_hi),
		pcidev(addr[1].phys_hi),
		pcifunc(addr[1].phys_hi));
a418 1
	printf(": memtag %x, iotag %x", memtag, iotag);
a423 2
	vgafb_pci_console_tag = iotag;

@


1.36
log
@Only allow the memory and mmio regions to be mmap()'ed at their real
addresses, remove the magic value to uniformize access to the mmio and
doesn't map the unused pseudo-vga registers.

While here simplify the console attachement logic and removed some
unused global variables. Tested by matthieu@@ and myself on various
different G3 and G4 models.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.35 2010/04/21 03:03:26 deraadt Exp $	*/
a384 1
	struct ppc_pci_chipset pa;
a388 2

	pa.pc_make_tag = &ofw_make_tag;
@


1.35
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.34 2008/09/30 22:42:55 kettenis Exp $	*/
a212 1
int cons_displaytype=0;
a214 1
bus_space_handle_t cons_display_ctl_h;
a396 1
	cons_displaytype=1;
d455 2
a456 2
	{
		int i;
d458 1
a458 24
		cons_membus->bus_base = 0x80000000;
#if 0
		err = bus_space_map( cons_membus, cons_addr, addr[0].size_lo,
			0, &cons_display_mem_h);
		printf("mem map err %x",err);
		bus_space_map( cons_membus, addr[1].phys_lo, addr[1].size_lo,
			0, &cons_display_ctl_h);
#endif

		vgafb_pci_console(cons_membus,
			addr[1].phys_lo, addr[1].size_lo,
			cons_membus,
			cons_addr, addr[0].size_lo,
			&pa, pcibus(addr[1].phys_hi), pcidev(addr[1].phys_hi),
			pcifunc(addr[1].phys_hi));

#if 1
		for (i = 0; i < cons_linebytes * cons_height; i++) {
			bus_space_write_1(cons_membus,
				cons_display_mem_h, i, 0);

		}
#endif
	}
@


1.34
log
@Properly count memory on machines where Open Firmware reports zero sized
entries in between filled banks.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.33 2008/09/23 20:45:26 miod Exp $	*/
d45 1
@


1.33
log
@Plug more uninitialized variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.32 2008/06/15 07:37:05 todd Exp $	*/
d96 2
d102 2
a103 5
	if ((phandle = OF_finddevice("/memory")) == -1
	    || OF_getprop(phandle, "reg",
	    OFmem, sizeof OFmem[0] * OFMEM_REGIONS) <= 0
	    || OF_getprop(phandle, "available",
	    OFavail, sizeof OFavail[0] * OFMEM_REGIONS) <= 0)
d105 20
@


1.32
log
@with powerbooks and ibooks, default to adb keyboard for console (and ddb>)
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.31 2006/06/17 16:27:55 miod Exp $	*/
d304 1
a304 1
	int len, attach;
d338 1
a338 1
		attach=1;
d344 1
a344 1
		attach=1;
@


1.31
log
@Recent Powerbook systems have their on-board keyboard and mouse devices
also showing up as usb devices, but both devices are tied.
To make things less confusing, do not attach the usb phantoms at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.30 2006/02/12 16:50:13 miod Exp $	*/
d70 2
a264 1
	int vendor, product;
d275 1
a275 17
				/*
				 * On some machines, such as PowerBook6,8,
				 * the built-in ADB keyboard and mouse also
				 * appears as an USB device, which we will
				 * ignore.
				 * We need to tell these shadow devices apart
				 * from regular external USB keyboards.
				 */
				if (OF_getprop(pnode, "vendor-id", &vendor,
				    sizeof vendor) != sizeof vendor)
					vendor = 0;
				if (OF_getprop(pnode, "product-id", &product,
				    sizeof product) != sizeof product)
					product = 0;
				if (vendor != USB_VENDOR_APPLE ||
				    product != USB_PRODUCT_APPLE_ADB)
					ofw_have_kbd |= OFW_HAVE_USBKBD;
d304 1
a304 1
	int len;
a316 6
	if (ofw_have_kbd == 0) {
		printf("no keyboard found, hoping USB will be present\n");
#if NUKBD > 0
		ukbd_cnattach();
#endif
	}
d319 14
a332 6
#if NUKBD > 0
		printf("USB and ADB found, using USB\n");
		ukbd_cnattach();
#else
		ofw_have_kbd = OFW_HAVE_ADBKBD;
#endif
d336 1
a336 1
		printf("USB found\n");
d338 1
d342 1
a342 1
		printf("ADB found\n");
d344 9
@


1.30
log
@Remove unused openfirmware code; ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.29 2006/01/18 23:21:17 miod Exp $	*/
d60 1
a246 1
#define DEVTREE_HID	3
d263 1
d274 17
a290 1
				ofw_have_kbd |= OFW_HAVE_USBKBD;
d339 1
a339 1
	if (ofw_have_kbd == (OFW_HAVE_USBKBD|OFW_HAVE_ADBKBD)) {
d344 1
a344 1
		ofw_have_kbd = OFW_HAVE_ADBKBD; /* ??? */
@


1.29
log
@Factorize akbd and ams drivers between mac68k and macppc; while there, start
moving out common adb code as well, and merge adb_direct.c into adb.c to
simplify external header files.

No functional change; more cleanups to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.28 2006/01/01 11:59:39 miod Exp $	*/
a62 1
int restore_ofw_mapping(void);
a130 7
static int N_mapping;
static struct {
	vaddr_t va;
	int len;
	paddr_t pa;
	int mode;
} ofw_mapping[256];
a134 1
	int mmui, mmu;
d137 1
a157 10
	chosen = OF_finddevice("/chosen");

	OF_getprop(chosen, "mmu", &mmui, 4);
	mmu = OF_instance_to_package(mmui);
	bzero(ofw_mapping, sizeof(ofw_mapping));

	N_mapping = OF_getprop(mmu, "translations", ofw_mapping,
	    sizeof(ofw_mapping));
	N_mapping /= sizeof(ofw_mapping[0]);

a160 126
}

struct pmap ofw_pmap;
int
restore_ofw_mapping()
{
	int i;

	pmap_pinit(&ofw_pmap);

	ofw_pmap.pm_sr[PPC_KERNEL_SR] = PPC_KERNEL_SEGMENT;

	for (i = 0; i < N_mapping; i++) {
		paddr_t pa = ofw_mapping[i].pa;
		vaddr_t va = ofw_mapping[i].va;
		int size = ofw_mapping[i].len;

		if (va < 0xf8000000)			/* XXX */
			continue;

		while (size > 0) {
			pmap_enter(&ofw_pmap, va, pa, VM_PROT_ALL, PMAP_WIRED);
			pa += NBPG;
			va += NBPG;
			size -= NBPG;
		}
	}
	pmap_update(pmap_kernel());

	return 0;
}

typedef void  (void_f) (void);
extern void_f *pending_int_f;
void ofw_do_pending_int(void);
extern int system_type;

void ofw_intr_init(void);

void
ofrootfound()
{
	int node;
	struct ofprobe probe;

	if (!(node = OF_peer(0)))
		panic("No PROM root");
	probe.phandle = node;
	if (!config_rootfound("ofroot", &probe))
		panic("ofroot not configured");
	if (system_type == OFWMACH) {
		pending_int_f = ofw_do_pending_int;
		ofw_intr_init();
	}
}

void
ofw_intr_establish()
{
	if (system_type == OFWMACH) {
		pending_int_f = ofw_do_pending_int;
		ofw_intr_init();
	}
}

void
ofw_intr_init()
{
	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so imp > (tty | net | bio).
	 */
	/* with openfirmware drivers all levels block clock
	 * (have to block polling)
	 */
	imask[IPL_IMP] = SPL_CLOCK;
	imask[IPL_TTY] = SPL_CLOCK | SINT_TTY;
	imask[IPL_NET] = SPL_CLOCK | SINT_NET;
	imask[IPL_BIO] = SPL_CLOCK;
	imask[IPL_IMP] |= imask[IPL_TTY] | imask[IPL_NET] | imask[IPL_BIO];

	/*
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	imask[IPL_TTY] |= imask[IPL_NET] | imask[IPL_BIO];
	imask[IPL_NET] |= imask[IPL_BIO];

	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;

}

void
ofw_do_pending_int()
{
	int pcpl;
	int s;

	static int processing;

	if(processing)
		return;

	processing = 1;
	s = ppc_intr_disable();

	pcpl = splhigh();		/* Turn off all */
	if((ipending & SINT_CLOCK) && ((pcpl & imask[IPL_CLOCK]) == 0)) {
		ipending &= ~SINT_CLOCK;
		softclock();
	}
	if((ipending & SINT_NET) && ((pcpl & imask[IPL_NET]) == 0) ) {
		extern int netisr;
		int pisr = netisr;
		netisr = 0;
		ipending &= ~SINT_NET;
		softnet(pisr);
	}
	ipending &= pcpl;
	cpl = pcpl;	/* Don't use splx... we are here already! */
	ppc_intr_enable(s);
	processing = 0;
@


1.28
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.27 2005/12/17 07:31:26 miod Exp $	*/
d55 3
a57 3
#include <ukbd.h>
#include <akbd.h>
#include <zstty.h>
d59 1
a59 1
#include <macppc/dev/akbdvar.h>
@


1.27
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.26 2005/06/08 19:08:23 drahn Exp $	*/
a635 1
	cd->cn_pri = CN_DEAD;
@


1.26
log
@Remove the bus_reverse field out of the powerpc bus structure, originally
it was there so that big endian and little endian devices could both be
present, however that is not the case on the macppc machines.
Cleans up code, shrinks the kernel. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.25 2004/06/24 22:35:56 drahn Exp $	*/
d134 1
a134 1
	vm_offset_t va;
d136 1
a136 1
	vm_offset_t pa;
d192 2
a193 2
		vm_offset_t pa = ofw_mapping[i].pa;
		vm_offset_t va = ofw_mapping[i].va;
@


1.25
log
@Do a better job at containing powerpc specific #defines to PPC_...
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.24 2004/03/17 15:47:59 drahn Exp $	*/
a571 1
		cons_membus->bus_reverse = 1;
@


1.24
log
@Better backlight detection on macppc, ok miod@@ krw@@ (a bit ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.23 2003/10/30 03:17:54 itojun Exp $	*/
d189 1
a189 1
	ofw_pmap.pm_sr[KERNEL_SR] = KERNEL_SEGMENT;
@


1.23
log
@fix NULL/0 mixup.  drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.22 2003/10/22 20:56:10 drahn Exp $	*/
d549 1
a549 1
	if (OF_finddevice("/backlight") != 0)
d597 2
a598 1
	of_setbrightness(DEFAULT_BRIGHTNESS);
@


1.22
log
@Search for the '/backlight' node to determine if backlight control is
available instead of looking for the backlight-control attribute.
Fixes backlight control on some apple laptops.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.20 2003/10/15 17:50:16 drahn Exp $	*/
d549 1
a549 1
	if (OF_finddevice("/backlight") != NULL)
@


1.21
log
@more white
@
text
@a495 1
	int backlight_control[2];
d548 2
a549 3
	len = OF_getprop(stdout_node, "backlight-control",
	    backlight_control, sizeof(backlight_control));
	if (len > 0)
@


1.20
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.19 2003/07/02 21:30:13 drahn Exp $	*/
d94 1
a94 1
	
d223 1
a223 1
		
d312 1
a312 1
static pcitag_t 
d324 1
a324 1
   
d386 1
a386 1
	
d470 1
a470 1
#else 		
d483 1
a483 1
#endif 
d585 1
a585 1
			cons_membus, 
d632 1
a632 1
/*   
d649 1
a649 1
 
@


1.19
log
@Reduce the amount of asm code in powerpc/macppc by replacing it with
inlined functions, helps improve readability and fix a couple of bugs.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.18 2003/06/16 00:37:35 drahn Exp $	*/
d91 1
a91 2
ofw_mem_regions(memp, availp)
	struct mem_region **memp, **availp;
d100 1
a100 2
			  OFmem, sizeof OFmem[0] * OFMEM_REGIONS)
	       <= 0
d102 1
a102 2
			  OFavail, sizeof OFavail[0] * OFMEM_REGIONS)
	       <= 0)
d104 1
d106 1
d111 1
d139 1
d153 1
d159 1
d313 1
a313 3
ofw_make_tag(cpv, bus, dev, fnc)
        void *cpv;
        int bus, dev, fnc;
d604 1
a604 2
of_setbrightness(brightness)
	int brightness;
d618 4
a621 1
	/* The OF method is called "set-contrast" but affects brightness. Don't ask. */
d636 1
a636 2
ofwcnprobe(cd)
        struct consdev *cd;
d642 1
a642 2
ofwcninit(cd)
        struct consdev *cd;
d646 1
a646 3
ofwcnputc(dev, c)
	dev_t dev;
	int c;
d653 1
a653 2
ofwcngetc(dev)
	dev_t dev;
d665 1
a665 3
ofwcnpollc(dev, on)
	dev_t dev;
	int on;
@


1.18
log
@Check for the backlight control on the stdout_node (the LCD) rather than
possibly the parent, which does not have the backlight-control property.
Fixes brightness control on 'dual' node OFW diplays.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.17 2002/10/12 01:09:43 krw Exp $	*/
d276 2
a277 1
	int emsr, dmsr;
d284 1
a284 4
	__asm__ volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	__asm__ volatile("mtmsr %0" :: "r"(dmsr));

d300 1
a300 1
	__asm__ volatile("mtmsr %0" :: "r"(emsr));
@


1.17
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.16 2002/09/15 09:01:58 deraadt Exp $	*/
d550 1
a550 1
	len = OF_getprop(display_node, "backlight-control",
@


1.16
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.14 2002/09/11 22:35:01 drahn Exp $	*/
d547 1
a547 1
			panic(": no address\n");
@


1.15
log
@KNF
@
text
@d95 1
a95 1

d99 7
a105 5
	if ((phandle = OF_finddevice("/memory")) == -1 ||
	    OF_getprop(phandle, "reg", OFmem,
	    sizeof OFmem[0] * OFMEM_REGIONS) <= 0 ||
	    OF_getprop(phandle, "available", OFavail,
	    sizeof OFavail[0] * OFMEM_REGIONS) <= 0)
d153 2
a154 2
	if (OF_getprop(chosen, "stdout", &stdout, sizeof stdout) !=
	    sizeof stdout) {
d220 1
a220 1

d279 1
a279 1
	if (processing)
d289 1
a289 1
	if ((ipending & SINT_CLOCK) && ((pcpl & imask[IPL_CLOCK]) == 0)) {
d293 1
a293 1
	if ((ipending & SINT_NET) && ((pcpl & imask[IPL_NET]) == 0) ) {
d311 1
a311 1
static pcitag_t
d313 2
a314 2
	void *cpv;
	int bus, dev, fnc;
d316 1
a316 1
	return (bus << 16) | (dev << 11) | (fnc << 8);
d319 7
a325 7
#define OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define OFW_PCI_PHYS_HI_BUSSHIFT        16
#define OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8

d348 1
a348 1
	struct usb_kbd_ihandles *next;
d365 1
a365 1
	if (OF_getprop(stdout_node, "device_type", type, sizeof(type)) == -1) {
d387 1
a387 1

d471 1
a471 1
#else
d484 1
a484 1
#endif
d586 1
a586 1
			cons_membus,
d631 1
a631 1
/*
d636 1
a636 1
	struct consdev *cd;
d643 1
a643 1
	struct consdev *cd;
a645 1

d652 1
a652 1

d659 2
a660 2
	unsigned char ch = '\0';
	int l;
d662 4
a665 4
	while ((l = OF_read(OF_stdin, &ch, 1)) != 1)
		if (l != -2 && l != 0)
		return -1;
	return ch;
d676 6
a681 6
	ofwcnprobe,
	ofwcninit,
	ofwcngetc,
	ofwcnputc,
	ofwcnpollc,
	NULL,
@


1.14
log
@Include zstty.h, so that the NZSTTY check will be correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.13 2002/09/06 13:56:51 drahn Exp $	*/
d95 1
a95 1
	
d99 5
a103 7
	if ((phandle = OF_finddevice("/memory")) == -1
	    || OF_getprop(phandle, "reg",
			  OFmem, sizeof OFmem[0] * OFMEM_REGIONS)
	       <= 0
	    || OF_getprop(phandle, "available",
			  OFavail, sizeof OFavail[0] * OFMEM_REGIONS)
	       <= 0)
d151 2
a152 2
	if (OF_getprop(chosen, "stdout", &stdout, sizeof stdout)
	    != sizeof stdout) {
d218 1
a218 1
		
d277 1
a277 1
	if(processing)
d287 1
a287 1
	if((ipending & SINT_CLOCK) && ((pcpl & imask[IPL_CLOCK]) == 0)) {
d291 1
a291 1
	if((ipending & SINT_NET) && ((pcpl & imask[IPL_NET]) == 0) ) {
d309 1
a309 1
static pcitag_t 
d311 2
a312 2
        void *cpv;
        int bus, dev, fnc;
d314 1
a314 1
        return (bus << 16) | (dev << 11) | (fnc << 8);
d317 7
a323 7
#define       OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define       OFW_PCI_PHYS_HI_BUSSHIFT        16
#define       OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define       OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define       OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define       OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8
   
d346 1
a346 1
        struct usb_kbd_ihandles *next;
d363 1
a363 1
	if (OF_getprop(stdout_node,  "device_type", type, sizeof(type)) == -1) {
d385 1
a385 1
	
d469 1
a469 1
#else 		
d482 1
a482 1
#endif 
d584 1
a584 1
			cons_membus, 
d629 1
a629 1
/*   
d634 1
a634 1
        struct consdev *cd;
d641 1
a641 1
        struct consdev *cd;
d644 1
d651 1
a651 1
 
d658 2
a659 2
        unsigned char ch = '\0';
        int l;
d661 4
a664 4
        while ((l = OF_read(OF_stdin, &ch, 1)) != 1)
                if (l != -2 && l != 0)
                        return -1;
        return ch;
d675 6
a680 6
        ofwcnprobe,
        ofwcninit,
        ofwcngetc,
        ofwcnputc,
        ofwcnpollc,
        NULL,
@


1.13
log
@Serial console support for macppc. Serial console will work if the modem
has been replaced with a serial port adapter on any machine that has
a real serial port internally. This will also power on the internal modem
for keylargo based machines (tested on original PBG4) when the serial port
is open. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.12 2002/08/20 02:50:43 drahn Exp $	*/
d57 1
@


1.12
log
@Add a pseudo openfirmware console device for early debugging purposes
and to allow UKC to work properly. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.11 2002/06/09 04:13:13 drahn Exp $	*/
d372 2
a373 6
		/* serial console not supported, forcing to screen for now */
		OF_stdout = OF_open("screen");
		OF_stdin = OF_open("keyboard");

		/* cross fingers that this works. */
		of_display_console();
d375 1
d377 6
@


1.11
log
@knf/cleanup/dead code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.10 2002/05/22 21:00:00 miod Exp $	*/
d621 65
@


1.10
log
@- in the OpenFirmware console initialisation, check if the console device
has support for backlight control (laptops do, and probably machines with
a built-in monitor do as well).
- provide a function to set the screen brightness as well.
- use both changes above to add a screen blanker to the vgafb driver
- let the screen brightness and backlight be controlled via wsconsctl
- clean dust, KNF, and more symbolic names in the vgafb driver to make it
better readable

Initial code by myself, with some hacks from drahn@@ later.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.9 2002/04/29 01:34:58 drahn Exp $	*/
d125 3
a137 4

int OF_stdout;
int OF_stdin;

d147 2
a148 2
	if (OF_getprop(chosen, "stdin", &stdin, sizeof stdin) != sizeof stdin)
	{
d152 2
a153 2
	if (OF_getprop(chosen, "stdout", &stdout, sizeof stdout) != sizeof stdout)
	{
d167 3
a169 2
	N_mapping =
	    OF_getprop(mmu, "translations", ofw_mapping, sizeof(ofw_mapping));
d213 1
d230 1
d239 1
d270 1
d276 1
a276 1
static int processing;
a443 1
	int node;
d454 1
a454 2
	node = OF_peer(0);
	ofw_recurse_keyboard(node);
@


1.9
log
@Change macppc vgafb from rcons to rasops, a faster color supporting virtual
terminal emulator for gfx console. tested by mattheiu, miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.8 2002/03/14 01:26:36 millert Exp $	*/
d53 2
d337 2
d489 1
d491 1
d530 1
d533 2
a534 3
		int node;
		node = OF_parent(stdout_node);
		len = OF_getprop(node, "name", name, 20);
d538 1
a538 1
		len = OF_getprop(node, "assigned-addresses",
d544 5
d593 25
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.7 2002/03/09 21:46:05 drahn Exp $	*/
d550 2
a551 2
	printf(": cons_width %d cons_linebytes %d cons_height %d\n",
		cons_width, cons_linebytes, cons_height);
@


1.7
log
@Completely rewritten keyboard detection mechanism. Instead of using the
openfirmware commands (which apple seems to have removed), walk the device
tree attempting to detect what type of keyboard(s) are present. Give
preference to USB if USB and ADB both found. If none found hope for USB.
This does have a problem on RevC iMacs booting without USB keyboard,
it seems apple left the adb device tree information which indicates
an ADB kebyoard is present. This fixes newer ibook and PBG4 keyboard
detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.6 2002/01/02 17:13:25 drahn Exp $	*/
d62 4
a65 4
void OF_exit __P((void)) __attribute__((__noreturn__));
void OF_boot __P((char *bootspec)) __attribute__((__noreturn__));
void ofw_mem_regions __P((struct mem_region **memp, struct mem_region **availp));
void ofw_vmon __P((void));
d112 1
a112 1
typedef void (fwcall_f) __P((int, int));
@


1.6
log
@On the road to serial console support. stage one, if of console is serial
force to display, zs(macppc) doesn't support console yet...
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.5 2001/12/08 02:24:06 art Exp $	*/
d376 9
d386 91
a482 1
	char iname[32];
d484 1
a484 1
	int stdout_node, stdin_node;
d522 1
a522 35
	stdin_node = OF_instance_to_package(OF_stdin);
	len = OF_getprop(stdin_node, "name", iname, 20);
	iname[len] = 0;
	printf("console in [%s] ", iname);
	/* what to do about serial console? */
	if (strcmp ("keyboard", iname) == 0) {
		struct usb_kbd_ihandles *ukbds;
#if NAKBD > 0
		int akbd;
#endif
		/* if there is a usb keyboard, we want it, do not 
		 * dereference the pointer that is returned
		 */
		if (OF_call_method("`usb-kbd-ihandles", OF_stdin, 0, 1, &ukbds)
			!= -1 && ukbds != NULL)
		{
			printf("USB");
			ukbd_cnattach();
			goto kbd_found;
		}
#if NAKBD > 0
		if (OF_call_method("`adb-kbd-ihandle", OF_stdin, 0, 1, &akbd)
			!= -1 &&
		   akbd != 0 &&
		   OF_instance_to_package(akbd) != -1)
		{
			printf("ADB");
			akbd_cnattach();
			goto kbd_found;
		}
#endif
		panic("no console keyboard");
kbd_found:
	}
	printf("\n");
@


1.5
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.4 2001/11/06 19:53:15 miod Exp $	*/
a297 37
#if 0
u_int32_t ppc_console_iomem=0;
u_int32_t ppc_console_addr=0;
u_int32_t ppc_console_qhandle=0;
u_int32_t ppc_console_serfreq;

void
ofwtrysercon(char *name, int qhandle)
{
/* for serial we want regs field */
	int regs[4];
	int freq;
	int regn;
	if ((regn = OF_getprop(qhandle, "reg", &regs[0], sizeof regs)) >= 0) {

		if (regs[1] == 0x3f8) {
			/* found preferred console */
			ppc_console_addr = regs[1];
			ppc_console_qhandle = qhandle;
			ppc_console_iomem=0; /* 0 means io, 1 means mem */
		}
		if ((regs[1] == 0x2e8) && (ppc_console_addr == 0)) {
			/* found nonpreferred console */
			ppc_console_addr = regs[1];
			ppc_console_qhandle = qhandle;
			ppc_console_iomem=0; /* 0 means io, 1 means mem */
		}
	}
	if ((OF_getprop(qhandle, "clock-frequency", &freq, sizeof regs)) >= 0) {
		/* MCG value for this does not agree with PC value,
		 * but works correctly (while PC value does not),
		 * does VI set this correctly???
		 */
		ppc_console_serfreq=freq;
	}
}
#endif
a311 11
#if 0
/* XXX */
void
ofwenablepcimemio(char *name, int qhandle)
{
	/* THIS PROBABLY IS A MAJOR HACK
	 * AND IT WOULD PREVENT ofdisk and ofnet from working 
	 * on MCG, VI machines.
	 */
}
#endif
d343 1
d347 33
@


1.5.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.6 2002/01/02 17:13:25 drahn Exp $	*/
d298 37
d349 11
a390 1
void of_display_console(void);
a393 33
{
	char type[32];
	int stdout_node;

	stdout_node = OF_instance_to_package(OF_stdout);

	/* handle different types of console */

	bzero(type, sizeof(type));
	if (OF_getprop(stdout_node,  "device_type", type, sizeof(type)) == -1) {
		return; /* XXX */
	}
	if (strcmp(type, "display") == 0) {
		of_display_console();
		return;
	}
	if (strcmp(type, "serial") == 0) {
		/* serial console not supported, forcing to screen for now */
		OF_stdout = OF_open("screen");
		OF_stdin = OF_open("keyboard");

		/* cross fingers that this works. */
		of_display_console();
		return;
	}

	return;
}
	


void
of_display_console()
@


1.5.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.5.2.1 2002/01/31 22:55:14 niklas Exp $	*/
a52 2
#include <macppc/macppc/ofw_machdep.h>

d62 4
a65 4
void OF_exit(void) __attribute__((__noreturn__));
void OF_boot(char *bootspec) __attribute__((__noreturn__));
void ofw_mem_regions(struct mem_region **memp, struct mem_region **availp);
void ofw_vmon(void);
d112 1
a112 1
typedef void (fwcall_f)(int, int);
a122 3
int OF_stdout;
int OF_stdin;

d133 4
d146 2
a147 2

	if (OF_getprop(chosen, "stdin", &stdin, sizeof stdin) != sizeof stdin) {
d151 2
a152 2
	if (OF_getprop(chosen, "stdout", &stdout, sizeof stdout)
	    != sizeof stdout) {
d166 2
a167 3

	N_mapping = OF_getprop(mmu, "translations", ofw_mapping,
	    sizeof(ofw_mapping));
a210 1

a226 1

a234 1

a264 1

d270 1
a270 1
	static int processing;
a334 2
int cons_brightness;
int cons_backlight_available;
a375 9
#define DEVTREE_UNKNOWN 0
#define DEVTREE_USB	1
#define DEVTREE_ADB	2
#define DEVTREE_HID	3
int ofw_devtree = DEVTREE_UNKNOWN;

#define OFW_HAVE_USBKBD 1
#define OFW_HAVE_ADBKBD 2
int ofw_have_kbd = 0;
a376 89
void ofw_recurse_keyboard(int pnode);
void ofw_find_keyboard(void);

void
ofw_recurse_keyboard(int pnode)
{
	char name[32];
	int old_devtree;
	int len;
	int node;

	for (node = OF_child(pnode); node != 0; node = OF_peer(node)) {

		len = OF_getprop(node, "name", name, 20);
		if (len == 0)
			continue;
		name[len] = 0;
		if (strcmp(name, "keyboard") == 0) {
			/* found a keyboard node, where is it? */
			if (ofw_devtree == DEVTREE_USB) {
				ofw_have_kbd |= OFW_HAVE_USBKBD;
			} else if (ofw_devtree == DEVTREE_ADB) {
				ofw_have_kbd |= OFW_HAVE_ADBKBD;
			} else {
				/* hid or some other keyboard? igore */
			}
			continue;
		}

		old_devtree = ofw_devtree;

		if (strcmp(name, "adb") == 0) {
			ofw_devtree = DEVTREE_ADB;
		}
		if (strcmp(name, "usb") == 0) {
			ofw_devtree = DEVTREE_USB;
		}

		ofw_recurse_keyboard(node);

		ofw_devtree = old_devtree; /* nest? */
	}
}

void
ofw_find_keyboard()
{
	int stdin_node;
	char iname[32];
	int len;

	stdin_node = OF_instance_to_package(OF_stdin);
	len = OF_getprop(stdin_node, "name", iname, 20);
	iname[len] = 0;
	printf("console in [%s] ", iname);

	/* GRR, apple removed the interface once used for keyboard
	 * detection walk the OFW tree to find keyboards and what type.
	 */

	ofw_recurse_keyboard(OF_peer(0));

	if (ofw_have_kbd == 0) {
		printf("no keyboard found, hoping USB will be present\n");
#if NUKBD > 0
		ukbd_cnattach();
#endif
	}

	if (ofw_have_kbd == (OFW_HAVE_USBKBD|OFW_HAVE_ADBKBD)) {
#if NUKBD > 0
		printf("USB and ADB found, using USB\n");
		ukbd_cnattach();
#else 		
		ofw_have_kbd = OFW_HAVE_ADBKBD; /* ??? */
#endif
	}
	if (ofw_have_kbd == OFW_HAVE_USBKBD) {
#if NUKBD > 0
		printf("USB found\n");
		ukbd_cnattach();
#endif
	} else if (ofw_have_kbd == OFW_HAVE_ADBKBD) {
#if NAKBD >0
		printf("ADB found\n");
		akbd_cnattach();
#endif 
	}
}
d383 1
d385 1
a385 2
	int stdout_node;
	int display_node;
a386 1
	int backlight_control[2];
d423 35
a457 1
	ofw_find_keyboard();
a458 1
	display_node = stdout_node;
d461 3
a463 2
		display_node = OF_parent(stdout_node);
		len = OF_getprop(display_node, "name", name, 20);
d467 1
a467 1
		len = OF_getprop(display_node, "assigned-addresses",
a472 5
	len = OF_getprop(display_node, "backlight-control",
	    backlight_control, sizeof(backlight_control));
	if (len > 0)
		cons_backlight_available = 1;

d485 2
a486 2
	printf(": width %d linebytes %d height %d depth %d\n",
		cons_width, cons_linebytes, cons_height, cons_depth);
a516 25

	of_setbrightness(DEFAULT_BRIGHTNESS);
#endif
}

void
of_setbrightness(brightness)
	int brightness;
{

#if NVGAFB_PCI > 0
	if (cons_backlight_available == 0)
		return;

	if (brightness < MIN_BRIGHTNESS)
		brightness = MIN_BRIGHTNESS;
	else if (brightness > MAX_BRIGHTNESS)
		brightness = MAX_BRIGHTNESS;

	cons_brightness = brightness;

	/* The OF method is called "set-contrast" but affects brightness. Don't ask. */
	OF_call_method_1("set-contrast", cons_display_ofh, 1, cons_brightness);

	/* XXX this routine should also save the brightness settings in the nvram */
@


1.5.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.5.2.2 2002/06/11 03:36:34 art Exp $	*/
a56 1
#include <zstty.h>
d372 6
a377 2
#if NZSTTY > 0
		/* zscnprobe/zscninit do all the required initialization */
a378 1
#endif
a380 6
	OF_stdout = OF_open("screen");
	OF_stdin = OF_open("keyboard");

	/* cross fingers that this works. */
	of_display_console();

d543 1
a543 1
			panic(": no address");
a620 65
}

#include <dev/cons.h>

cons_decl(ofw);

/*   
 * Console support functions
 */
void
ofwcnprobe(cd)
        struct consdev *cd;
{
	cd->cn_pri = CN_DEAD;
}

void
ofwcninit(cd)
        struct consdev *cd;
{
}
void
ofwcnputc(dev, c)
	dev_t dev;
	int c;
{
	char ch = c;
 
	OF_write(OF_stdout, &ch, 1);
}
int
ofwcngetc(dev)
	dev_t dev;
{
        unsigned char ch = '\0';
        int l;

        while ((l = OF_read(OF_stdin, &ch, 1)) != 1)
                if (l != -2 && l != 0)
                        return -1;
        return ch;
}

void
ofwcnpollc(dev, on)
	dev_t dev;
	int on;
{
}

struct consdev consdev_ofw = {
        ofwcnprobe,
        ofwcninit,
        ofwcngetc,
        ofwcnputc,
        ofwcnpollc,
        NULL,
};

void
ofwconsinit()
{
	struct consdev *cp;
	cp = &consdev_ofw;
	cn_tab = cp;
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.3 2001/10/01 22:47:48 drahn Exp $	*/
d200 1
@


1.3
log
@Change the kernel so that is the openfirmware stdout is not provided,
it will force the screen open and use that as console.
Fixes auto-boot? true booting. Does have issue on some cards
that the screen does not enable quickly, thus the screen may scroll
before it is visable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.2 2001/09/11 06:47:00 mickey Exp $	*/
d46 1
a46 1
#include <vm/vm.h>
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d46 1
a46 1
#include <uvm/uvm_extern.h>
@


1.3.4.3
log
@Merge in trunk
@
text
@a199 1
	pmap_update(pmap_kernel());
d297 37
d348 11
a389 1
void of_display_console(void);
a392 33
{
	char type[32];
	int stdout_node;

	stdout_node = OF_instance_to_package(OF_stdout);

	/* handle different types of console */

	bzero(type, sizeof(type));
	if (OF_getprop(stdout_node,  "device_type", type, sizeof(type)) == -1) {
		return; /* XXX */
	}
	if (strcmp(type, "display") == 0) {
		of_display_console();
		return;
	}
	if (strcmp(type, "serial") == 0) {
		/* serial console not supported, forcing to screen for now */
		OF_stdout = OF_open("screen");
		OF_stdin = OF_open("keyboard");

		/* cross fingers that this works. */
		of_display_console();
		return;
	}

	return;
}
	


void
of_display_console()
@


1.3.4.4
log
@Merge in -current from about a week ago
@
text
@d62 4
a65 4
void OF_exit(void) __attribute__((__noreturn__));
void OF_boot(char *bootspec) __attribute__((__noreturn__));
void ofw_mem_regions(struct mem_region **memp, struct mem_region **availp);
void ofw_vmon(void);
d112 1
a112 1
typedef void (fwcall_f)(int, int);
a375 9
#define DEVTREE_UNKNOWN 0
#define DEVTREE_USB	1
#define DEVTREE_ADB	2
#define DEVTREE_HID	3
int ofw_devtree = DEVTREE_UNKNOWN;

#define OFW_HAVE_USBKBD 1
#define OFW_HAVE_ADBKBD 2
int ofw_have_kbd = 0;
a376 91
void ofw_recurse_keyboard(int pnode);
void ofw_find_keyboard(void);

void
ofw_recurse_keyboard(int pnode)
{
	char name[32];
	int old_devtree;
	int len;
	int node;

	for (node = OF_child(pnode); node != 0; node = OF_peer(node)) {

		len = OF_getprop(node, "name", name, 20);
		if (len == 0)
			continue;
		name[len] = 0;
		if (strcmp(name, "keyboard") == 0) {
			/* found a keyboard node, where is it? */
			if (ofw_devtree == DEVTREE_USB) {
				ofw_have_kbd |= OFW_HAVE_USBKBD;
			} else if (ofw_devtree == DEVTREE_ADB) {
				ofw_have_kbd |= OFW_HAVE_ADBKBD;
			} else {
				/* hid or some other keyboard? igore */
			}
			continue;
		}

		old_devtree = ofw_devtree;

		if (strcmp(name, "adb") == 0) {
			ofw_devtree = DEVTREE_ADB;
		}
		if (strcmp(name, "usb") == 0) {
			ofw_devtree = DEVTREE_USB;
		}

		ofw_recurse_keyboard(node);

		ofw_devtree = old_devtree; /* nest? */
	}
}

void
ofw_find_keyboard()
{
	int stdin_node;
	char iname[32];
	int len;
	int node;

	stdin_node = OF_instance_to_package(OF_stdin);
	len = OF_getprop(stdin_node, "name", iname, 20);
	iname[len] = 0;
	printf("console in [%s] ", iname);

	/* GRR, apple removed the interface once used for keyboard
	 * detection walk the OFW tree to find keyboards and what type.
	 */

	node = OF_peer(0);
	ofw_recurse_keyboard(node);

	if (ofw_have_kbd == 0) {
		printf("no keyboard found, hoping USB will be present\n");
#if NUKBD > 0
		ukbd_cnattach();
#endif
	}

	if (ofw_have_kbd == (OFW_HAVE_USBKBD|OFW_HAVE_ADBKBD)) {
#if NUKBD > 0
		printf("USB and ADB found, using USB\n");
		ukbd_cnattach();
#else 		
		ofw_have_kbd = OFW_HAVE_ADBKBD; /* ??? */
#endif
	}
	if (ofw_have_kbd == OFW_HAVE_USBKBD) {
#if NUKBD > 0
		printf("USB found\n");
		ukbd_cnattach();
#endif
	} else if (ofw_have_kbd == OFW_HAVE_ADBKBD) {
#if NAKBD >0
		printf("ADB found\n");
		akbd_cnattach();
#endif 
	}
}
d383 1
d385 1
a385 1
	int stdout_node;
d423 35
a457 1
	ofw_find_keyboard();
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@a52 2
#include <macppc/macppc/ofw_machdep.h>

a54 1
#include <zstty.h>
a122 3
int OF_stdout;
int OF_stdin;

d133 4
d146 2
a147 2

	if (OF_getprop(chosen, "stdin", &stdin, sizeof stdin) != sizeof stdin) {
d151 2
a152 2
	if (OF_getprop(chosen, "stdout", &stdout, sizeof stdout)
	    != sizeof stdout) {
d166 2
a167 3

	N_mapping = OF_getprop(mmu, "translations", ofw_mapping,
	    sizeof(ofw_mapping));
a210 1

a226 1

a234 1

a264 1

d270 1
a270 1
	static int processing;
a334 2
int cons_brightness;
int cons_backlight_available;
d364 6
a369 2
#if NZSTTY > 0
		/* zscnprobe/zscninit do all the required initialization */
a370 1
#endif
a372 6
	OF_stdout = OF_open("screen");
	OF_stdin = OF_open("keyboard");

	/* cross fingers that this works. */
	of_display_console();

d436 1
d447 2
a448 1
	ofw_recurse_keyboard(OF_peer(0));
a484 1
	int display_node;
a485 1
	int backlight_control[2];
a523 1
	display_node = stdout_node;
d526 3
a528 2
		display_node = OF_parent(stdout_node);
		len = OF_getprop(display_node, "name", name, 20);
d532 1
a532 1
		len = OF_getprop(display_node, "assigned-addresses",
d535 1
a535 1
			panic(": no address");
a537 5
	len = OF_getprop(display_node, "backlight-control",
	    backlight_control, sizeof(backlight_control));
	if (len > 0)
		cons_backlight_available = 1;

d550 2
a551 2
	printf(": width %d linebytes %d height %d depth %d\n",
		cons_width, cons_linebytes, cons_height, cons_depth);
a581 25

	of_setbrightness(DEFAULT_BRIGHTNESS);
#endif
}

void
of_setbrightness(brightness)
	int brightness;
{

#if NVGAFB_PCI > 0
	if (cons_backlight_available == 0)
		return;

	if (brightness < MIN_BRIGHTNESS)
		brightness = MIN_BRIGHTNESS;
	else if (brightness > MAX_BRIGHTNESS)
		brightness = MAX_BRIGHTNESS;

	cons_brightness = brightness;

	/* The OF method is called "set-contrast" but affects brightness. Don't ask. */
	OF_call_method_1("set-contrast", cons_display_ofh, 1, cons_brightness);

	/* XXX this routine should also save the brightness settings in the nvram */
a582 65
}

#include <dev/cons.h>

cons_decl(ofw);

/*   
 * Console support functions
 */
void
ofwcnprobe(cd)
        struct consdev *cd;
{
	cd->cn_pri = CN_DEAD;
}

void
ofwcninit(cd)
        struct consdev *cd;
{
}
void
ofwcnputc(dev, c)
	dev_t dev;
	int c;
{
	char ch = c;
 
	OF_write(OF_stdout, &ch, 1);
}
int
ofwcngetc(dev)
	dev_t dev;
{
        unsigned char ch = '\0';
        int l;

        while ((l = OF_read(OF_stdin, &ch, 1)) != 1)
                if (l != -2 && l != 0)
                        return -1;
        return ch;
}

void
ofwcnpollc(dev, on)
	dev_t dev;
	int on;
{
}

struct consdev consdev_ofw = {
        ofwcnprobe,
        ofwcninit,
        ofwcngetc,
        ofwcnputc,
        ofwcnpollc,
        NULL,
};

void
ofwconsinit()
{
	struct consdev *cp;
	cp = &consdev_ofw;
	cn_tab = cp;
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d91 2
a92 1
ofw_mem_regions(struct mem_region **memp, struct mem_region **availp)
d95 1
a95 1

d101 2
a102 1
	    OFmem, sizeof OFmem[0] * OFMEM_REGIONS) <= 0
d104 2
a105 1
	    OFavail, sizeof OFavail[0] * OFMEM_REGIONS) <= 0)
a106 1

a107 1

a111 1

a138 1

a151 1

a156 1

d220 1
a220 1

d276 1
a276 2
	int s;

d283 4
a286 1
	s = ppc_intr_disable();
d302 1
a302 1
	ppc_intr_enable(s);
d311 4
a314 2
static pcitag_t
ofw_make_tag(void *cpv, int bus, int dev, int fnc)
d325 1
a325 1

d387 1
a387 1

d471 1
a471 1
#else
d484 1
a484 1
#endif
d497 1
d550 3
a552 2

	if (OF_finddevice("/backlight") != 0)
d586 1
a586 1
			cons_membus,
d605 2
a606 1
of_setbrightness(int brightness)
d620 1
a620 4
	/*
	 * The OF method is called "set-contrast" but affects brightness.
	 * Don't ask.
	 */
d631 1
a631 1
/*
d635 2
a636 1
ofwcnprobe(struct consdev *cd)
d642 2
a643 1
ofwcninit(struct consdev *cd)
d647 3
a649 1
ofwcnputc(dev_t dev, int c)
d652 1
a652 1

d656 2
a657 1
ofwcngetc(dev_t dev)
d669 3
a671 1
ofwcnpollc(dev_t dev, int on)
@


1.3.4.7
log
@Merge with the trunk
@
text
@d549 1
a549 1
	if (OF_getnodebyname(0, "backlight") != 0)
d597 1
a597 2
	if (cons_backlight_available == 1)
		of_setbrightness(DEFAULT_BRIGHTNESS);
@


1.2
log
@vm/vm_kern.h is not needed hereand it compiles (;
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d154 4
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.25 2001/08/18 05:39:03 drahn Exp $	*/
a46 1
#include <vm/vm_kern.h>
@

