head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.26
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.30
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.28
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.24
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.22
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.20
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.18
	OPENBSD_5_0:1.10.0.16
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.14
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.12
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.8
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.8.0.16
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.4
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.03.31.10.36.52;	author mpi;	state Exp;
branches;
next	1.10;
commitid	rxWnYYKHwQIW0yI8;

1.10
date	2007.11.12.19.23.26;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.14.17.26.59;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.16.04.57.50;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.11.16.22.30;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.07.22.45.59;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.06.05.23.10.52;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Tell the firmware to shut down the fan management thread on the last
generation of G5s.  Without this my PowerMac11,2 hang when smu(4)
attaches.
@
text
@/*	$OpenBSD: openfirm.c,v 1.10 2007/11/12 19:23:26 kettenis Exp $	*/
/*	$NetBSD: openfirm.c,v 1.1 1996/09/30 16:34:52 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/stdarg.h>
#include <machine/psl.h>

#include <dev/ofw/openfirm.h>

extern void ofw_stack(void);
extern void ofbcopy(const void *, void *, size_t);

int
OF_peer(int phandle)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		int sibling;
	} args = {
		"peer",
		1,
		1,
	};

	ofw_stack();
	args.phandle = phandle;
	if (openfirmware(&args) == -1)
		return 0;
	return args.sibling;
}

int
OF_child(int phandle)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		int child;
	} args = {
		"child",
		1,
		1,
	};

	ofw_stack();
	args.phandle = phandle;
	if (openfirmware(&args) == -1)
		return 0;
	return args.child;
}

int
OF_parent(int phandle)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		int parent;
	} args = {
		"parent",
		1,
		1,
	};

	ofw_stack();
	args.phandle = phandle;
	if (openfirmware(&args) == -1)
		return 0;
	return args.parent;
}

int
OF_getproplen(int handle, char *prop)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		char *prop;
		int size;
	} args = {
		"getproplen",
		2,
		1,
	};

	ofw_stack();
	args.phandle = handle;
	args.prop = prop;
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}

int
OF_getprop(int handle, char *prop, void *buf, int buflen)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		char *prop;
		void *buf;
		int buflen;
		int size;
	} args = {
		"getprop",
		4,
		1,
	};

	ofw_stack();
	if (buflen > NBPG)
		return -1;
	args.phandle = handle;
	args.prop = prop;
	args.buf = OF_buf;
	args.buflen = buflen;
	if (openfirmware(&args) == -1)
		return -1;
	if (args.size > 0)
		ofbcopy(OF_buf, buf, args.size);
	return args.size;
}

int
OF_setprop(int handle, char *prop, const void *buf, int buflen)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		char *prop;
		void *buf;
		int buflen;
		int size;
	} args = {
		"setprop",
		4,
		1,
	};
	
	ofw_stack();
	if (buflen > NBPG)
		return -1;
	args.phandle = handle;
	args.prop = prop;
	ofbcopy(buf, OF_buf, buflen);
	args.buf = OF_buf;
	args.buflen = buflen;
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}

int
OF_nextprop(int handle, char *prop, void *nextprop)
{
	static struct {
		const char *name;
		int nargs;
		int nreturns;
		int phandle;
		const char *prop;
		char *buf;
		int flag;
	} args = {
		"nextprop",
		3,
		1,
	};

	ofw_stack();
	args.phandle = handle;
	args.prop = prop;
	args.buf = OF_buf;
	if (openfirmware(&args) == -1)
		return -1;
	strlcpy(nextprop, OF_buf, 32);
	return args.flag;
}

int
OF_interpret(char *cmd, int nreturns, ...)
{
	va_list ap;
	int i;
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *cmd;
		int status;
		int results[8];
	} args = {
		"interpret",
		1,
		2,
	};

	ofw_stack();
	if (nreturns > 8)
		return -1;
	if ((i = strlen(cmd)) >= NBPG)
		return -1;
	ofbcopy(cmd, OF_buf, i + 1);
	args.cmd = OF_buf;
	args.nargs = 1;
	args.nreturns = nreturns + 1;
	if (openfirmware(&args) == -1)
		return -1;
	va_start(ap, nreturns);
	for (i = 0; i < nreturns; i++)
		*va_arg(ap, int *) = args.results[i];
	va_end(ap);
	return args.status;
}


int
OF_finddevice(char *name)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *device;
		int phandle;
	} args = {
		"finddevice",
		1,
		1,
	};

	ofw_stack();
	args.device = name;
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}
static void OF_rboot(char *bootspec);

static void
OF_rboot(char *bootspec)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
	} args = {
		"reset-all",
		0,
		0,
	};
	int l;

	if ((l = strlen(bootspec)) >= NBPG)
		panic("OF_boot");
	ofw_stack();
	openfirmware(&args);
	/* will attempt exit in OF_boot */
}


void
OF_boot(char *bootspec)
{
	OF_rboot(bootspec);
	printf ("OF_boot returned!");		/* just in case */
	OF_exit();
	while(1);
}

void
OF_exit()
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
	} args = {
		"exit",
		0,
		0,
	};

	ofw_stack();
	openfirmware(&args);
	panic ("OF_exit returned!");		/* just in case */
	while (1);
}

void
OF_quiesce(void)
{
	static struct {
		const char *name;
		int nargs;
		int nreturns;
	} args = {
		"quiesce",
		0,
		0,
	};

	ofw_stack();
	openfirmware(&args);
}

/* XXX What is the reason to have this instead of bcopy/memcpy? */
void
ofbcopy(const void *src, void *dst, size_t len)
{
        const char *sp = src;
        char *dp = dst;

        if (src == dst)
                return;

        while (len-- > 0)
                *dp++ = *sp++;
}

int
OF_getnodebyname(int start, const char *name)
{
	char nname[32];
	int len;
	int node = 0;
	int next;

	if (start == 0)
		start = OF_peer(0);

	for (node = start; node; node = next) {
		len = OF_getprop(node, "name", nname, sizeof(nname));
		nname[len] = 0;
		if (strcmp(nname, name) == 0) {
			return node;
		}
		if ((next = OF_child(node)) != 0)
			continue;
		while (node) {
			if ((next = OF_peer(node)) != 0)
				break;
			node = OF_parent(node);
		}
	}
	return node;
}
@


1.10
log
@/dev/openprom

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.9 2007/10/14 17:26:59 kettenis Exp $	*/
d332 17
@


1.9
log
@Implement OF_getproplen().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.8 2004/02/16 04:57:50 drahn Exp $	*/
d164 58
@


1.8
log
@Fix the recently added OF_getnodebyname(), if 0 is passed in for start
that indicates that start should be assigned OF_peer(0) "head of device tree",
not node which is then overwritten.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.7 2004/01/11 16:22:30 drahn Exp $	*/
d108 24
@


1.7
log
@Add OF_getnodebyname interface to openfirmware, from netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.6 2004/01/07 22:45:59 brad Exp $	*/
d274 2
a275 2
	if (node == 0)
		node = OF_peer(0);
@


1.6
log
@machine/stdarg.h -> sys/stdarg.h

ok drahn@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.5 2003/10/15 17:50:16 drahn Exp $	*/
d266 27
@


1.5
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.4 2002/09/15 09:01:58 deraadt Exp $	*/
d36 1
a36 1

a37 1
#include <machine/stdarg.h>
@


1.4
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.2 2002/03/14 01:26:36 millert Exp $	*/
d46 1
a46 2
OF_peer(phandle)
	int phandle;
d59 1
a59 1
	
d68 1
a68 2
OF_child(phandle)
	int phandle;
d81 1
a81 1
	
d90 1
a90 2
OF_parent(phandle)
	int phandle;
d103 1
a103 1
	
d112 1
a112 5
OF_getprop(handle, prop, buf, buflen)
	int handle;
	char *prop;
	void *buf;
	int buflen;
d149 1
a149 1
		char *name;  
d152 1
a152 1
		char *cmd; 
d181 1
a181 2
OF_finddevice(name)
	char *name;
d193 1
a193 1
	};	
d204 1
a204 2
OF_rboot(bootspec)
	char *bootspec;
d216 1
a216 1
	
d226 1
a226 2
OF_boot(bootspec)
	char *bootspec;
d255 1
a255 4
ofbcopy(src, dst, len)
        const void *src;    
        void *dst;         
        size_t len;
d261 3
a263 3
                return; 
                
        while (len-- > 0)                     
@


1.3
log
@KNF
@
text
@d239 1
a239 1
	printf("OF_boot returned!");		/* just in case */
d241 1
a241 2
	while (1)
		;
d259 2
a260 3
	panic("OF_exit returned!");		/* just in case */
	while (1)
		;
d266 3
a268 3
	const void *src;    
	void *dst;
	size_t len;
d270 2
a271 2
	const char *sp = src;
	char *dp = dst;
d273 5
a277 5
	if (src == dst)
		return; 
		
	while (len-- > 0)
		*dp++ = *sp++;
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d239 1
a239 1
	printf ("OF_boot returned!");		/* just in case */
d241 2
a242 1
	while(1);
d260 3
a262 2
	panic ("OF_exit returned!");		/* just in case */
	while (1);
d268 3
a270 3
        const void *src;    
        void *dst;         
        size_t len;
d272 2
a273 2
        const char *sp = src;
        char *dp = dst;
d275 5
a279 5
        if (src == dst)
                return; 
                
        while (len-- > 0)                     
                *dp++ = *sp++;
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.8 2001/06/24 23:29:36 drahn Exp $	*/
d42 2
a43 2
extern void ofw_stack __P((void));
extern void ofbcopy __P((const void *, void *, size_t));
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d42 2
a43 2
extern void ofw_stack(void);
extern void ofbcopy(const void *, void *, size_t);
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.1.6.1 2002/06/11 03:36:34 art Exp $	*/
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current from about a week ago
@
text
@d42 2
a43 2
extern void ofw_stack(void);
extern void ofbcopy(const void *, void *, size_t);
@


1.1.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d36 1
a36 1
#include <sys/stdarg.h>
d38 1
d46 2
a47 1
OF_peer(int phandle)
d60 1
a60 1

d69 2
a70 1
OF_child(int phandle)
d83 1
a83 1

d92 2
a93 1
OF_parent(int phandle)
d106 1
a106 1

d115 5
a119 1
OF_getprop(int handle, char *prop, void *buf, int buflen)
d156 1
a156 1
		char *name;
d159 1
a159 1
		char *cmd;
d188 2
a189 1
OF_finddevice(char *name)
d201 1
a201 1
	};
d212 2
a213 1
OF_rboot(char *bootspec)
d225 1
a225 1

d235 2
a236 1
OF_boot(char *bootspec)
d265 4
a268 1
ofbcopy(const void *src, void *dst, size_t len)
d274 3
a276 3
                return;

        while (len-- > 0)
a279 27
int
OF_getnodebyname(int start, const char *name)
{
	char nname[32];
	int len;
	int node = 0;
	int next;

	if (node == 0)
		node = OF_peer(0);

	for (node = start; node; node = next) {
		len = OF_getprop(node, "name", nname, sizeof(nname));
		nname[len] = 0;
		if (strcmp(nname, name) == 0) {
			return node;
		}
		if ((next = OF_child(node)) != 0)
			continue;
		while (node) {
			if ((next = OF_peer(node)) != 0)
				break;
			node = OF_parent(node);
		}
	}
	return node;
}
@


1.1.4.4
log
@Merge with the trunk
@
text
@d274 2
a275 2
	if (start == 0)
		start = OF_peer(0);
@


