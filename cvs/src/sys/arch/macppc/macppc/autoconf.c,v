head	1.44;
access;
symbols
	OPENBSD_6_0:1.44.0.2
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.43.0.6
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.8
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.39.0.10
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.8
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.6
	OPENBSD_5_0:1.39.0.4
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.38.0.4
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.36.0.8
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.22.0.6
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.8
	UBC:1.2.0.2
	UBC_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.06.08.17.24.44;	author tedu;	state Exp;
branches;
next	1.43;
commitid	oK6mhkiIMNMJ6OsK;

1.43
date	2014.04.04.01.50.25;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.01.20.27.14;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2013.09.13.07.29.01;	author mpi;	state Exp;
branches;
next	1.40;

1.40
date	2013.06.03.19.16.43;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2010.11.11.17.58.21;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.01.20.19.18;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2009.08.29.11.41.32;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.30.22.19.33;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.09.15.24.53;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.01.23.14.06;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.26.15.24.21;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.15.01.56.47;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.08.02.17.35;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.08.02.16.29;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.16.12.00.25;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.28.06.17.37;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.27.07.23.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.27.18.31.09;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.25.02.42.25;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.17.23.23.36;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.16.22.31.53;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.12.06.52.43;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.09.14.01.11;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.21.00.15.42;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.21.17.05.55;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.16.05.03.22;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.06.17.13.17;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.00.55.56;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.14.18.47.30;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.09.04.13.13;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.05.23.58.41;	author tdeval;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@remove obsolete raid from namtoblk tables. from Artturi Alm
@
text
@/*	$OpenBSD: autoconf.c,v 1.43 2014/04/04 01:50:25 dlg Exp $	*/
/*
 * Copyright (c) 1996, 1997 Per Fogelstrom
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: autoconf.c 1.31 91/01/21
 *
 *	from: @@(#)autoconf.c	8.1 (Berkeley) 6/10/93
 *      $Id: autoconf.c,v 1.43 2014/04/04 01:50:25 dlg Exp $
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include "sd.h"
#include "mpath.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <dev/cons.h>
#include <uvm/uvm_extern.h>
#include <machine/autoconf.h>

#include <sys/disk.h>
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <dev/ata/atavar.h>

#if NMPATH > 0
#include <scsi/mpathvar.h>
#endif

void	dumpconf(void);
static	struct devmap *findtype(char **);
void	parseofwbp(char *);
int	getpno(char **);

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
int	cold = 1;	/* if 1, still working on cold-start */
char	bootdev[16];	/* to hold boot dev name */
struct device *bootdv = NULL;
enum devclass bootdev_class = DV_DULL;
int	bootdev_type = 0;
int	bootdev_unit = 0;

/*
 *  Configure all devices found that we know about.
 *  This is done at boot time.
 */
void
cpu_configure()
{
	(void)splhigh();	/* To be really sure.. */

	softintr_init();

	if (config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");
	(void)spl0();
	cold = 0;
}

struct devmap {
	char *att;
	char *dev;
	int   type;
};
#define	T_IFACE	0x10

#define	T_BUS	0x00
#define	T_SCSI	0x11
#define	T_IDE	0x12
#define	T_DISK	0x21

static struct devmap *
findtype(char **s)
{
	static struct devmap devmap[] = {
		{ "/ht",		NULL, T_BUS },
		{ "/ht@@",		NULL, T_BUS },
		{ "/pci@@",		NULL, T_BUS },
		{ "/pci",		NULL, T_BUS },
		{ "/AppleKiwi@@",	NULL, T_BUS },
		{ "/AppleKiwi",		NULL, T_BUS },
		{ "/mac-io@@",		NULL, T_BUS },
		{ "/mac-io",		NULL, T_BUS },
		{ "/@@",			NULL, T_BUS },
		{ "/LSILogic,sas@@",	"sd", T_SCSI },
		{ "/scsi@@",		"sd", T_SCSI },
		{ "/ide",		"wd", T_IDE },
		{ "/ata",		"wd", T_IDE },
		{ "/k2-sata-root",	NULL, T_BUS },
		{ "/k2-sata",		"wd", T_IDE },
		{ "/disk@@",		"sd", T_DISK },
		{ "/disk",		"wd", T_DISK },
		{ "/usb@@",		"sd", T_SCSI },
		{ "/ADPT,2940U2B@@",	"sd", T_SCSI },
		{ "/bcom5704@@4",	"bge0", T_IFACE },
		{ "/bcom5704@@4,1",	"bge1", T_IFACE },
		{ "/ethernet",		"gem0", T_IFACE },
		{ "/enet",		"mc0", T_IFACE },
		{ NULL, NULL }
	};
	struct devmap *dp = &devmap[0];

	while (dp->att) {
		if (strncmp(*s, dp->att, strlen(dp->att)) == 0) {
			*s += strlen(dp->att);
			break;
		}
		dp++;
	}
	if (dp->att == NULL)
		printf("string [%s] not found\n", *s);

	return(dp);
}

/*
 * Look at the string 'bp' and decode the boot device.
 * Boot names look like: '/pci/scsi@@c/disk@@0,0/bsd'
 *                       '/pci/mac-io/ide@@20000/disk@@0,0/bsd
 *                       '/pci/mac-io/ide/disk/bsd
 *			 '/ht@@0,f2000000/pci@@2/bcom5704@@4/bsd'
 */
void
parseofwbp(char *bp)
{
	int	ptype;
	char   *dev, *cp;
	struct devmap *dp;

	cp = bp;
	do {
		while(*cp && *cp != '/')
			cp++;

		dp = findtype(&cp);
		if (!dp->att) {
			printf("Warning: bootpath unrecognized: %s\n", bp);
			return;
		}
	} while((dp->type & T_IFACE) == 0);

	if (dp->att && dp->type == T_IFACE) {
		bootdev_class = DV_IFNET;
		bootdev_type = dp->type;
		strlcpy(bootdev, dp->dev, sizeof bootdev);
		return;
	}
	dev = dp->dev;
	while(*cp && *cp != '/')
		cp++;
	ptype = dp->type;
	dp = findtype(&cp);
	if (dp->att && dp->type == T_DISK) {
		bootdev_class = DV_DISK;
		bootdev_type = ptype;
		bootdev_unit = getpno(&cp);
		return;
	}
	printf("Warning: boot device unrecognized: %s\n", bp);
}

int
getpno(char **cp)
{
	int val = 0, digit;
	char *cx = *cp;

	while (*cx) {
		if (*cx >= '0' && *cx <= '9')
			digit = *cx - '0';
		else if (*cx >= 'a' && *cx <= 'f')
			digit = *cx - 'a' + 0x0a;
		else
			break;
		val = val * 16 + digit;
		cx++;
	}
	*cp = cx;
	return (val);
}

void
device_register(struct device *dev, void *aux)
{
#if NSD > 0
	extern struct cfdriver scsibus_cd;
#endif
	const char *drvrname = dev->dv_cfdata->cf_driver->cd_name;
	const char *name = dev->dv_xname;

	if (bootdv != NULL || dev->dv_class != bootdev_class)
		return;

	switch (bootdev_type) {
#if NSD > 0
	case T_SCSI:
		if (dev->dv_parent->dv_cfdata->cf_driver == &scsibus_cd) {
			struct scsi_attach_args *sa = aux;

			if (sa->sa_sc_link->target == bootdev_unit)
				bootdv = dev;
		}
#endif
	case T_IDE:
		if (strcmp(drvrname, "wd") == 0) {
			struct ata_atapi_attach *aa = aux;

	    		if (aa->aa_drv_data->drive == bootdev_unit)
				bootdv = dev;
		}
		break;
	case T_IFACE:
		if (strcmp(name, bootdev) == 0)
			bootdv = dev;
		break;
	default:
		break;
	}
}

void
diskconf(void)
{
	printf("bootpath: %s\n", bootpath);

#if NMPATH > 0
	if (bootdv != NULL)
		bootdv = mpath_bootdv(bootdv);
#endif

	setroot(bootdv, 0, RB_USERREQ);
	dumpconf();
}

struct nam2blk nam2blk[] = {
	{ "wd",		0 },
	{ "sd",		2 },
	{ "rd",		17 },
	{ "vnd",	14 },
	{ NULL,		-1 }
};
@


1.43
log
@let device_register match scsi devices to anything hanging off a
scsibus. this lets path drivers get matched instead of just sd(4).

ask mpath to maybe swap a path with a disk via mpath.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2014/04/01 20:27:14 mpi Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.42 2014/04/01 20:27:14 mpi Exp $
a286 1
	{ "raid",	19 },
@


1.42
log
@Remove the almost unused abstraction around "struct firmware" and use
instead a single function ppc_mem_regions() required by the ppc pmap.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2013/09/13 07:29:01 mpi Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.41 2013/09/13 07:29:01 mpi Exp $
d51 3
d70 4
d233 3
d243 1
d245 1
a245 1
		if (strcmp(drvrname, "sd") == 0) {
d251 1
d273 5
@


1.41
log
@Initialize the variable guarding the clock interrupt routine after
calling initclocks().  This prevents hardclock() from trying to
schedule a softclock interrupt before its cookie has been allocated,
leading to a panic.

While here grab the ticks/second value from the OpenFirmware at the
same time we read the clock frequency, no need to look twice for the
same node.

Looks ok to kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2013/06/03 19:16:43 mpi Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.40 2013/06/03 19:16:43 mpi Exp $
a60 1
#include <machine/powerpc.h>
a82 3

struct dumpmem dumpmem[VM_PHYSSEG_MAX];
u_int ndumpmem;
@


1.40
log
@Rework the logic for matching the boot device to allow for root on
any drive attached to the first controller. Fix an issue reported
by Jan Stary, hans at stare dot cz.

Note that this new logic still doesn't allow for root on any drive
attached to a secondary controller.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2010/11/11 17:58:21 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.39 2010/11/11 17:58:21 miod Exp $
a95 1
	calc_delayconst();
@


1.39
log
@Replace snprintf(foo, sizeof foo, "%s", ...) with strlcpy. ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2009/10/01 20:19:18 kettenis Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.38 2009/10/01 20:19:18 kettenis Exp $
a64 1
#include <scsi/scsi_disk.h>
d66 1
a66 1
#include <scsi/sdvar.h>
d70 1
a70 1
void	makebootdev(char *cp);
d81 3
d170 1
a170 1
makebootdev(char *bp)
d172 1
a172 1
	int	unit, ptype;
d189 2
d200 3
a202 18
		unit = getpno(&cp);
		if (ptype == T_SCSI) {
			struct device *dv;
			struct sd_softc *sd;

			TAILQ_FOREACH(dv, &alldevs, dv_list) {
				if (dv->dv_class != DV_DISK ||
				    strcmp(dv->dv_cfdata->cf_driver->cd_name, "sd"))
					continue;
				sd = (struct sd_softc *)dv;
				if (sd->sc_link->target != unit)
					continue;
				snprintf(bootdev, sizeof bootdev,
				    "%s%c", dv->dv_xname, 'a');
				return;
			}
		}
		snprintf(bootdev, sizeof bootdev, "%s%d%c", dev, unit, 'a');
d231 29
a261 5
/*
 * Now that we are fully operational, we can checksum the
 * disks, and using some heuristics, hopefully are able to
 * always determine the correct root disk.
 */
a264 3
	dev_t temp;
	int part = 0;

a265 1
	makebootdev(bootpath);
d267 1
a267 3
	/* Lookup boot device from boot if not set by configuration */
	bootdv = parsedisk(bootdev, strlen(bootdev), 0, &temp);
	setroot(bootdv, part, RB_USERREQ);
@


1.38
log
@Generic soft interrupts for macppc.  Tested by mk@@, deraadt@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2009/08/29 11:41:32 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.37 2009/08/29 11:41:32 miod Exp $
d187 1
a187 1
		snprintf(bootdev, sizeof bootdev, "%s", dp->dev);
@


1.37
log
@Remove unused getdevunit(), only sparc and sparc64 have a need for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2008/07/21 04:35:54 todd Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.36 2008/07/21 04:35:54 todd Exp $
d95 2
@


1.36
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2008/03/30 22:19:33 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.35 2008/03/30 22:19:33 deraadt Exp $
a69 1
struct	device *getdevunit(char *, int);
a239 26
}

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(char *name, int unit)
{
	struct device *dev = TAILQ_FIRST(&alldevs);
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0)
		if ((dev = TAILQ_NEXT(dev, dv_list)) == NULL)
			return NULL;

	return dev;
@


1.35
log
@nam2blk[] clearly must contain "rd" ... found by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2007/09/09 15:24:53 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.34 2007/09/09 15:24:53 deraadt Exp $
d294 1
@


1.34
log
@/enet apparently maps to mc0; gwk ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2007/06/01 23:14:06 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.33 2007/06/01 23:14:06 deraadt Exp $
d292 1
@


1.33
log
@remove ofw devices which we don't use; that way of mixing devices is crazy
(means i also don not have to fix the daddr_t problems)
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2007/06/01 19:25:10 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.32 2007/06/01 19:25:10 deraadt Exp $
d141 1
@


1.32
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2007/06/01 19:20:46 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.32 2007/06/01 19:20:46 deraadt Exp $
a290 1
	{ "ofdisk",	4 },
@


1.31
log
@If booted from ADPT,2940U2B, root is on scsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2007/05/15 01:56:47 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.30 2007/05/15 01:56:47 deraadt Exp $
a73 1
void	diskconf(void);
a99 6

	/*
	 * We can not know which is our root disk, defer
	 * until we can checksum blocks to figure it out.
	 */
	md_diskconf = diskconf;
@


1.30
log
@kill __HAVE_DEVICE_REGISTER by requiring all architectures to have a
device_register() function -- even if it does nothing.  reduces the
cpp-based blather different between architectures
idea ok'd by miod; tested on all architectures (except a few miod will
need to cleanup because he has them)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2007/05/08 02:17:35 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.29 2007/05/08 02:17:35 deraadt Exp $
d144 1
@


1.29
log
@no need to print boot device name twice
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2007/05/08 02:16:29 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.28 2007/05/08 02:16:29 deraadt Exp $
d243 4
@


1.28
log
@uninitialized variable passed to setroot()
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2007/05/04 19:30:55 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.27 2007/05/04 19:30:55 deraadt Exp $
a285 6
	if (bootdv == NULL) {
		printf("boot device: lookup '%s' failed.\n", bootdev);
		boothowto |= RB_ASKNAME;	/* Don't Panic :-) */
	} else
		printf("boot device: %s\n", bootdv->dv_xname);

@


1.27
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2007/05/04 03:44:44 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.26 2007/05/04 03:44:44 deraadt Exp $
d279 1
a279 1
	int part;
@


1.26
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2007/04/16 12:00:25 dlg Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.25 2007/04/16 12:00:25 dlg Exp $
d296 1
a296 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d301 1
a302 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.25
log
@macppcs can boot off usb disks, so treat "/usb" controllers in the ofw tree
as storage controllers.

this lets ottos macppc root off the usb disk he booted off.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2007/03/28 06:17:37 dlg Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.24 2007/03/28 06:17:37 dlg Exp $
a68 2
struct  device *parsedisk(char *, int, int, dev_t *);
void    setroot(void);
d70 2
a71 5
int	findblkmajor(struct device *);
char	*findblkname(int);
static	struct device * getdisk(char *, int, int, dev_t *);
struct	device * getdevunit(char *, int);
static	struct devmap * findtype(char **);
d98 1
a98 1
	if(config_rootfound("mainbus", "mainbus") == 0)
a108 364
/*
 * Now that we are fully operational, we can checksum the
 * disks, and using some heuristics, hopefully are able to
 * always determine the correct root disk.
 */
void
diskconf()
{
	/*
	 * Configure root, swap, and dump area.  This is
	 * currently done by running the same checksum
	 * algorithm over all known disks, as was done in
	 * /boot.  Then we basically fixup the *dev vars
	 * from the info we gleaned from this.
	dkcsumattach();
	 * - XXX
	 */

#if 0
	rootconf();
#endif
	setroot();
	dumpconf();
}

/*
 * Crash dump handling.
 */

static	struct nam2blk {
	char *name;
	int  maj;
} nam2blk[] = {
	{ "wd",		0 },	/* 0 = wd */
	{ "sd",		2 },	/* 2 = sd */
	{ "ofdisk",	4 },	/* 4 = ofdisk */
	{ "raid",	19 },	/* 19 = raid */
};

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) ==
		    0)
			return (nam2blk[i].maj);
	 return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	 return (NULL);
}

static struct device *
getdisk(char *str, int len, int defpart, dev_t *devp)
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(char *str, int len, int defpart, dev_t *devp)
{
	struct device *dv;
	char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
setroot()
{
	int  majdev, mindev, unit, part, len;
	dev_t temp;
	struct swdevt *swp;
	struct device *dv;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	int s;

#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	printf("bootpath: '%s'\n", bootpath);

	makebootdev(bootpath);
	if(boothowto & RB_DFLTROOT)
		return;		/* Boot compiled in */

	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
		if (len == -1 || len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}

	/* Lookup boot device from boot if not set by configuration */
	if (bootdv == NULL) {
		bootdv = parsedisk(bootdev, strlen(bootdev), 0, &temp);
	}
	if (bootdv == NULL) {
		printf("boot device: lookup '%s' failed.\n", bootdev);
		boothowto |= RB_ASKNAME; /* Don't Panic :-) */
		/* boothowto |= RB_SINGLE; */
	} else
		printf("boot device: %s.\n", bootdv->dv_xname);

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				 printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? 'a' : ' ');
			printf(": ");
			s = splhigh();
			cnpollc(TRUE);
			len = getsn(buf, sizeof(buf));

			cnpollc(FALSE);
			splx(s);
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}
		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET)
			goto gotswap;

		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
			printf(": ");
			s = splhigh();
			cnpollc(TRUE);
			len = getsn(buf, sizeof(buf));
			cnpollc(FALSE);
			splx(s);
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}

gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	}
	else if(mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);

		if (majdev >= 0) {
			/*
			 * Root and Swap are on disk.
			 * Boot is always from partition 0.
			 */
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit, 0);
			nswapdev = MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
			dumpdev = nswapdev;
		} else {
			/*
			 *  Root and Swap are on net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		mindev = minor(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname, part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * XXX: What is this doing?
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(char *name, int unit)
{
	struct device *dev = TAILQ_FIRST(&alldevs);
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0)
		if ((dev = TAILQ_NEXT(dev, dv_list)) == NULL)
			return NULL;

	return dev;
}
a220 1
	return;
d241 86
@


1.24
log
@disk addresses are in hex, not decimal. makes my LSILogic,sas@@3/disk@@13
correctly match target 19.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2005/12/27 18:31:09 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.23 2007/03/27 07:23:33 deraadt Exp $
d512 1
@


1.23
log
@grok LSILogic,sas controllers in bootpath; as well, become aware that (at
least) "scsi" controllers give a target/port number, not a kernel sd#.
So, translate.  We might later want to do the same translation for IDE as
well, but perhaps not until after people test a bit more; ok dlg
@
text
@d40 1
a40 1
 *      $Id: autoconf.c,v 1.22 2005/12/27 18:31:09 miod Exp $
d595 1
a595 1
	int val = 0;
d598 8
a605 2
	while(*cx && *cx >= '0' && *cx <= '9') {
		val = val * 10 + *cx - '0';
d609 1
a609 1
	return val;
@


1.22
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2005/11/25 02:42:25 brad Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.21 2005/11/25 02:42:25 brad Exp $
d63 6
d280 1
a280 1
	if(bootdv == NULL) {
d283 1
a283 1
	if(bootdv == NULL) {
d504 1
d542 1
a542 1
	int	unit;
d565 1
d569 16
@


1.21
log
@splimp -> splhigh in setroot()/rootconf().

ok miod@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2005/10/17 23:23:36 brad Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.20 2005/10/17 23:23:36 brad Exp $
a64 1
void	swapconf(void);
a129 1
	swapconf();
a130 21
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
@


1.20
log
@remove /bcom5421 from the OF device map table, this is actually a PHY.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2005/10/16 22:31:53 kettenis Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.19 2005/10/16 22:31:53 kettenis Exp $
d316 1
a316 1
			s = splimp();
d355 1
a355 1
			s = splimp();
@


1.19
log
@Turn /k2-sata-root into T_BUS; makes us recognize the bootpath of internal
disks on G5 systems with K2 SATA.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2005/10/12 06:52:43 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.18 2005/10/12 06:52:43 deraadt Exp $
a529 1
		{ "/bcom5421",		"bge0", T_IFACE },
@


1.18
log
@also handle network device bootpaths.  also tested by drahn and kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2005/10/09 14:01:11 drahn Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.17 2005/10/09 14:01:11 drahn Exp $
d524 1
a524 1
		{ "/k2-sata-root",	"wd", T_IDE },
@


1.17
log
@Nearly functional crashdump support for macppc. Because savecore
does not recognize the resulting crashdumps, the writing has been disabled.
Better here than in my forest of trees.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2005/04/21 00:15:42 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.16 2005/04/21 00:15:42 deraadt Exp $
d512 20
a531 12
		{ "/pci@@",	NULL, T_BUS },
		{ "/pci",	NULL, T_BUS },
		{ "/AppleKiwi@@",NULL, T_BUS },
		{ "/AppleKiwi",	NULL, T_BUS },
		{ "/mac-io@@",	NULL, T_BUS },
		{ "/mac-io",	NULL, T_BUS },
		{ "/@@",		NULL, T_BUS },
		{ "/scsi@@",	"sd", T_SCSI },
		{ "/ide",	"wd", T_IDE },
		{ "/ata",	"wd", T_IDE },
		{ "/disk@@",	"sd", T_DISK },
		{ "/disk",	"wd", T_DISK },
d537 1
a537 1
		if (strncmp (*s, dp->att, strlen(dp->att)) == 0) {
d554 1
d570 1
a570 1
			printf("Warning: boot device unrecognized: %s\n", bp);
d575 4
d583 3
a585 2
	if (!dp->att || dp->type != T_DISK) {
		printf("Warning: boot device unrecognized: %s\n", bp);
d588 2
a589 2
	unit = getpno(&cp);
	snprintf(bootdev, sizeof bootdev, "%s%d%c", dev, unit, 'a');
@


1.16
log
@correct idiom for snprintf failure handling; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2004/12/25 23:02:24 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.15 2004/12/25 23:02:24 miod Exp $
d61 1
d66 1
a66 1
extern void	dumpconf(void);
d85 3
a131 1
#if 0
a132 1
#endif
a153 3
#if 0
	dumpconf();
#endif
a158 42
u_long dumpmag = 0x8fca0101;		/* magic number */
int dumpsize = 0;			/* size of dump in pages */
long dumplo = -1;			/* blocks */

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first CLBYTES of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
#if 0
void
dumpconf()
{
	int nblks;	/* size of dump area */
	int maj;

	if (dumpdev == NODEV)
		return;
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
	if (nblks <= ctod(1))
		return;

	dumpsize = btoc(IOM_END + ctob(dumpmem_high));

	/* Always skip the first CLBYTES, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
}
#endif
@


1.15
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2003/10/21 17:05:55 drahn Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.14 2003/10/21 17:05:55 drahn Exp $
d333 1
a333 1
		if (len >= sizeof(buf))
@


1.14
log
@Missed ANSI.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2003/10/16 05:03:22 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.13 2003/10/16 05:03:22 deraadt Exp $
d244 1
a244 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d274 1
a274 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d519 1
a519 1
	struct device *dev = alldevs.tqh_first;
d533 1
a533 1
		if ((dev = dev->dv_list.tqe_next) == NULL)
@


1.13
log
@more white
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2003/10/15 17:50:16 drahn Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.12 2003/10/15 17:50:16 drahn Exp $
d259 1
a259 4
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
@


1.12
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2003/09/06 17:13:17 drahn Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.11 2003/09/06 17:13:17 drahn Exp $
d250 1
a250 1
				printf(" %s", dv->dv_xname); 
d458 1
a458 1
			 */	
@


1.11
log
@Fix boot -a, add protected cnpollc(). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2003/06/02 23:27:50 millert Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.10 2003/06/02 23:27:50 millert Exp $
d139 2
a140 2
	register struct swdevt *swp;
	register int nblks;
d214 1
a214 2
findblkmajor(dv)
	struct device *dv;
d220 2
a221 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
d227 1
a227 2
findblkname(maj)
	int maj;
d238 1
a238 4
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
d240 1
a240 1
	register struct device *dv;
d264 2
a265 2
	register struct device *dv;
	register char *cp, c;
d351 1
a351 2
	}
	else {
a352 1
	}
d392 1
a392 1
		if (bootdv->dv_class == DV_IFNET) {
d394 1
a394 1
		}
d455 1
a455 2
		}
		else {
d521 1
a521 3
getdevunit(name, unit)
	char *name;
	int unit;
d536 1
a536 1
	while (strcmp(dev->dv_xname, fullname) != 0) {
d539 1
a539 1
	}
d556 1
a556 2
findtype(s)
	char **s;
d582 1
a582 1
	if (dp->att == NULL) {
d584 1
a584 1
	}
d595 1
a595 2
makebootdev(bp)
	char *bp;
d603 1
a603 1
		while(*cp && *cp != '/') {
d605 1
a605 1
		}
d626 1
a626 2
getpno(cp)
	char **cp;
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2003/04/06 18:54:19 ho Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.9 2003/04/06 18:54:19 ho Exp $
d58 2
a59 1

d318 1
d369 2
d372 3
d408 2
d411 2
@


1.9
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2002/09/15 09:01:58 deraadt Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
 *      $Id: autoconf.c,v 1.8 2002/09/15 09:01:58 deraadt Exp $
@


1.8
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 2002/09/15 00:55:56 deraadt Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.6 2002/09/15 00:55:56 deraadt Exp $
d341 2
a342 1
		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
d373 1
a373 1
				strcpy(buf, bootdv->dv_xname);
d530 1
a530 1
	sprintf(num, "%d", unit);
d535 2
a536 2
	strcpy(fullname, name);
	strcat(fullname, num);
d626 1
a626 1
	sprintf(bootdev, "%s%d%c", dev, unit, 'a');
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2002/06/09 04:13:13 drahn Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.4 2002/06/09 04:13:13 drahn Exp $
d71 1
a71 1
static	struct device *getdisk(char *, int, int, dev_t *);
d73 1
a73 1
static	struct devmap *findtype(char **);
d92 1
a92 1
cpu_configure(void)
d97 1
a97 1
	if (config_rootfound("mainbus", "mainbus") == 0)
a107 1

d114 1
a114 1
diskconf(void)
d140 1
a140 1
swapconf(void)
d148 1
a148 1
			    (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
d176 1
a176 1
dumpconf(void)
d217 2
a218 1
findblkmajor(struct device *dv)
d226 1
a226 1
	return (-1);
d230 2
a231 1
findblkname(int maj)
d238 1
a238 1
	return (NULL);
d242 4
a245 1
getdisk(char *str, int len, int defpart, dev_t *devp)
d257 1
a257 1
				printf(" %s", dv->dv_xname);
d266 4
a269 1
parsedisk(char *str, int len, int defpart, dev_t *devp)
d313 1
a313 1
setroot(void)
d329 1
a329 1
	if (boothowto & RB_DFLTROOT)
d349 1
a349 1
	if (bootdv == NULL)
d351 2
a352 1
	if (bootdv == NULL) {
d356 2
a357 1
	} else {
d365 4
a368 2
				printf("(default %s%c)", bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
d394 1
a394 1
		if (bootdv->dv_class == DV_IFNET)
d396 1
a396 1

d435 2
a436 1
	} else if (mountroot == NULL) {
d453 2
a454 1
		} else {
d457 1
a457 1
			 */
d520 3
a522 1
getdevunit(char *name, int unit)
d557 2
a558 1
findtype(char **s)
d578 1
a578 1
		if (strncmp(*s, dp->att, strlen(dp->att)) == 0) {
d584 1
a584 2
#if 0
	if (dp->att == NULL)
d586 1
a586 1
#endif
d597 2
a598 1
makebootdev(char *bp)
d606 1
a606 1
		while (*cp && *cp != '/')
d608 1
d614 1
a614 1
	} while ((dp->type & T_IFACE) == 0);
d617 1
a617 1
	while (*cp && *cp != '/')
d629 2
a630 1
getpno(char **cp)
d635 1
a635 1
	while (*cx && *cx >= '0' && *cx <= '9') {
@


1.6
log
@nice printing
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 2002/09/14 18:47:30 deraadt Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.5 2002/09/14 18:47:30 deraadt Exp $
d71 1
a71 1
static	struct device * getdisk(char *, int, int, dev_t *);
d73 1
a73 1
static	struct devmap * findtype(char **);
d92 1
a92 1
cpu_configure()
d97 1
a97 1
	if(config_rootfound("mainbus", "mainbus") == 0)
d108 1
d115 1
a115 1
diskconf()
d141 1
a141 1
swapconf()
d149 1
a149 1
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
d177 1
a177 1
dumpconf()
d218 1
a218 2
findblkmajor(dv)
	struct device *dv;
d226 1
a226 1
	 return (-1);
d230 1
a230 2
findblkname(maj)
	int maj;
d237 1
a237 1
	 return (NULL);
d241 1
a241 4
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
d253 1
a253 1
				printf(" %s", dv->dv_xname); 
d262 1
a262 4
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
d306 1
a306 1
setroot()
d322 1
a322 1
	if(boothowto & RB_DFLTROOT)
d342 1
a342 1
	if(bootdv == NULL) {
d344 1
a344 2
	}
	if(bootdv == NULL) {
d348 1
a348 2
	}
	else {
d356 2
a357 4
				 printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? 'a' : ' ');
d383 1
a383 1
		if (bootdv->dv_class == DV_IFNET) {
d385 1
a385 1
		}
d424 1
a424 2
	}
	else if(mountroot == NULL) {
d441 1
a441 2
		}
		else {
d444 1
a444 1
			 */	
d507 1
a507 3
getdevunit(name, unit)
	char *name;
	int unit;
d542 1
a542 2
findtype(s)
	char **s;
d562 1
a562 1
		if (strncmp (*s, dp->att, strlen(dp->att)) == 0) {
d568 2
a569 1
	if (dp->att == NULL) {
d571 1
a571 1
	}
d582 1
a582 2
makebootdev(bp)
	char *bp;
d590 1
a590 1
		while(*cp && *cp != '/') {
a591 1
		}
d597 1
a597 1
	} while((dp->type & T_IFACE) == 0);
d600 1
a600 1
	while(*cp && *cp != '/')
d612 1
a612 2
getpno(cp)
	char **cp;
d617 1
a617 1
	while(*cx && *cx >= '0' && *cx <= '9') {
@


1.5
log
@recognize AppleKiwi
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2002/06/09 04:13:13 drahn Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.4 2002/06/09 04:13:13 drahn Exp $
d585 1
a585 1
		printf("string [%s]not found\n", *s);
@


1.4
log
@knf/cleanup/dead code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2002/03/14 01:26:36 millert Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.3 2002/03/14 01:26:36 millert Exp $
d563 2
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 2001/12/05 23:58:41 tdeval Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.2 2001/12/05 23:58:41 tdeval Exp $
d69 8
a76 8
int findblkmajor(struct device *);
char *findblkname(int);
static struct device * getdisk(char *, int, int, dev_t *);
struct device * getdevunit(char *, int);
static struct devmap * findtype(char **);
void makebootdev(char *cp);
int getpno(char **);
void diskconf(void);
a96 5
	/*
	if(system_type == OFWMACH) {
		ofrootfound();
	}
	*/
d326 2
a327 1
printf("bootpath: '%s'\n", bootpath);
@


1.2
log
@Enable rootdev auto-configuration by device drivers during boot.
Add support for "raid" devices (prepare future raidframe changes).

OK deraadt@@, Reviewed by drahn@@, jason@@, mickey@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.1 2001/09/01 15:44:20 drahn Exp $
d65 11
a75 11
struct  device *parsedisk __P((char *, int, int, dev_t *));
void    setroot __P((void));
void	swapconf __P((void));
extern void	dumpconf __P((void));
int findblkmajor __P((struct device *));
char *findblkname __P((int));
static struct device * getdisk __P((char *, int, int, dev_t *));
struct device * getdevunit __P((char *, int));
static struct devmap * findtype __P((char **));
void makebootdev __P((char *cp));
int getpno __P((char **));
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 2001/12/05 23:58:41 tdeval Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.2 2001/12/05 23:58:41 tdeval Exp $
d65 12
a76 12
struct  device *parsedisk(char *, int, int, dev_t *);
void    setroot(void);
void	swapconf(void);
extern void	dumpconf(void);
int	findblkmajor(struct device *);
char	*findblkname(int);
static	struct device * getdisk(char *, int, int, dev_t *);
struct	device * getdevunit(char *, int);
static	struct devmap * findtype(char **);
void	makebootdev(char *cp);
int	getpno(char **);
void	diskconf(void);
d97 5
d331 1
a331 2
	printf("bootpath: '%s'\n", bootpath);

@


1.2.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2.2.1 2002/06/11 03:36:34 art Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.2.2.1 2002/06/11 03:36:34 art Exp $
a562 2
		{ "/AppleKiwi@@",NULL, T_BUS },
		{ "/AppleKiwi",	NULL, T_BUS },
d583 1
a583 1
		printf("string [%s] not found\n", *s);
@


1.2.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
 *      $Id$
d341 1
a341 2
		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
d372 1
a372 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d529 1
a529 1
	snprintf(num, sizeof num, "%d", unit);
d534 2
a535 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
d625 1
a625 1
	snprintf(bootdev, sizeof bootdev, "%s%d%c", dev, unit, 'a');
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/06/24 04:49:27 drahn Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.12 2001/06/24 04:49:27 drahn Exp $
d69 2
a70 1
static int findblkmajor __P((struct device *));
d218 1
d221 1
a221 1
static int
d226 1
a226 1
	register int i;
d229 1
a229 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
d234 12
d335 16
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
 *      $Id$
@


1.1.4.2
log
@Merge in trunk
@
text
@d69 1
a69 2
int findblkmajor __P((struct device *));
char *findblkname __P((int));
a216 1
	{ "raid",	19 },	/* 19 = raid */
d219 1
a219 1
int
d224 1
a224 1
	int i;
d227 1
a227 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
a231 12
char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	 return (NULL);
}

a320 16

	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
		if (len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d65 11
a75 11
struct  device *parsedisk(char *, int, int, dev_t *);
void    setroot(void);
void	swapconf(void);
extern void	dumpconf(void);
int findblkmajor(struct device *);
char *findblkname(int);
static struct device * getdisk(char *, int, int, dev_t *);
struct device * getdevunit(char *, int);
static struct devmap * findtype(char **);
void makebootdev(char *cp);
int getpno(char **);
@


1.1.4.4
log
@Sync the SMP branch with 3.3
@
text
@d69 8
a76 8
int	findblkmajor(struct device *);
char	*findblkname(int);
static	struct device * getdisk(char *, int, int, dev_t *);
struct	device * getdevunit(char *, int);
static	struct devmap * findtype(char **);
void	makebootdev(char *cp);
int	getpno(char **);
void	diskconf(void);
d97 5
d331 1
a331 2
	printf("bootpath: '%s'\n", bootpath);

a566 2
		{ "/AppleKiwi@@",NULL, T_BUS },
		{ "/AppleKiwi",	NULL, T_BUS },
d587 1
a587 1
		printf("string [%s] not found\n", *s);
@


1.1.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1.4.4 2003/03/27 23:29:46 niklas Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.1.4.4 2003/03/27 23:29:46 niklas Exp $
d341 1
a341 2
		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
d372 1
a372 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d529 1
a529 1
	snprintf(num, sizeof num, "%d", unit);
d534 2
a535 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
d625 1
a625 1
	snprintf(bootdev, sizeof bootdev, "%s%d%c", dev, unit, 'a');
@


1.1.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1.4.5 2003/05/13 19:41:05 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
d44 1
a44 1
 *      $Id: autoconf.c,v 1.1.4.5 2003/05/13 19:41:05 ho Exp $
@


1.1.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
 *      $Id$
d58 1
a58 2
#include <dev/cons.h>
#include <uvm/uvm_extern.h>
d138 2
a139 2
	struct swdevt *swp;
	int nblks;
d213 2
a214 1
findblkmajor(struct device *dv)
d220 1
a220 2
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) ==
		    0)
d226 2
a227 1
findblkname(int maj)
d238 4
a241 1
getdisk(char *str, int len, int defpart, dev_t *devp)
d243 1
a243 1
	struct device *dv;
d253 1
a253 1
				printf(" %s", dv->dv_xname);
d262 4
a265 1
parsedisk(char *str, int len, int defpart, dev_t *devp)
d267 2
a268 2
	struct device *dv;
	char *cp, c;
a316 1
	int s;
d353 2
a354 1
	} else
d356 1
a366 2
			s = splimp();
			cnpollc(TRUE);
a367 3

			cnpollc(FALSE);
			splx(s);
d391 1
a391 1
		if (bootdv->dv_class == DV_IFNET)
d393 1
a393 1

a400 2
			s = splimp();
			cnpollc(TRUE);
a401 2
			cnpollc(FALSE);
			splx(s);
d450 2
a451 1
		} else {
d454 1
a454 1
			 */
d517 3
a519 1
getdevunit(char *name, int unit)
d534 1
a534 1
	while (strcmp(dev->dv_xname, fullname) != 0)
d537 1
a537 1

d554 2
a555 1
findtype(char **s)
d581 1
a581 1
	if (dp->att == NULL)
d583 1
a583 1

d594 2
a595 1
makebootdev(char *bp)
d603 1
a603 1
		while(*cp && *cp != '/')
d605 1
a605 1

d626 2
a627 1
getpno(char **cp)
@


