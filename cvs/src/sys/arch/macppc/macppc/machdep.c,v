head	1.181;
access;
symbols
	OPENBSD_6_2:1.181.0.4
	OPENBSD_6_2_BASE:1.181
	OPENBSD_6_1:1.179.0.4
	OPENBSD_6_1_BASE:1.179
	OPENBSD_6_0:1.176.0.2
	OPENBSD_6_0_BASE:1.176
	OPENBSD_5_9:1.172.0.2
	OPENBSD_5_9_BASE:1.172
	OPENBSD_5_8:1.171.0.4
	OPENBSD_5_8_BASE:1.171
	OPENBSD_5_7:1.168.0.2
	OPENBSD_5_7_BASE:1.168
	OPENBSD_5_6:1.160.0.4
	OPENBSD_5_6_BASE:1.160
	OPENBSD_5_5:1.144.0.4
	OPENBSD_5_5_BASE:1.144
	OPENBSD_5_4:1.138.0.2
	OPENBSD_5_4_BASE:1.138
	OPENBSD_5_3:1.135.0.2
	OPENBSD_5_3_BASE:1.135
	OPENBSD_5_2:1.131.0.4
	OPENBSD_5_2_BASE:1.131
	OPENBSD_5_1_BASE:1.131
	OPENBSD_5_1:1.131.0.2
	OPENBSD_5_0:1.130.0.2
	OPENBSD_5_0_BASE:1.130
	OPENBSD_4_9:1.123.0.2
	OPENBSD_4_9_BASE:1.123
	OPENBSD_4_8:1.121.0.2
	OPENBSD_4_8_BASE:1.121
	OPENBSD_4_7:1.116.0.2
	OPENBSD_4_7_BASE:1.116
	OPENBSD_4_6:1.108.0.4
	OPENBSD_4_6_BASE:1.108
	OPENBSD_4_5:1.104.0.2
	OPENBSD_4_5_BASE:1.104
	OPENBSD_4_4:1.99.0.2
	OPENBSD_4_4_BASE:1.99
	OPENBSD_4_3:1.94.0.2
	OPENBSD_4_3_BASE:1.94
	OPENBSD_4_2:1.93.0.2
	OPENBSD_4_2_BASE:1.93
	OPENBSD_4_1:1.87.0.2
	OPENBSD_4_1_BASE:1.87
	OPENBSD_4_0:1.85.0.2
	OPENBSD_4_0_BASE:1.85
	OPENBSD_3_9:1.83.0.2
	OPENBSD_3_9_BASE:1.83
	OPENBSD_3_8:1.72.0.2
	OPENBSD_3_8_BASE:1.72
	OPENBSD_3_7:1.68.0.4
	OPENBSD_3_7_BASE:1.68
	OPENBSD_3_6:1.68.0.2
	OPENBSD_3_6_BASE:1.68
	SMP_SYNC_A:1.66
	SMP_SYNC_B:1.66
	OPENBSD_3_5:1.66.0.2
	OPENBSD_3_5_BASE:1.66
	OPENBSD_3_4:1.54.0.2
	OPENBSD_3_4_BASE:1.54
	UBC_SYNC_A:1.49
	OPENBSD_3_3:1.48.0.2
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.44.0.2
	OPENBSD_3_2_BASE:1.44
	OPENBSD_3_1:1.34.0.2
	OPENBSD_3_1_BASE:1.34
	UBC_SYNC_B:1.46
	UBC:1.18.0.2
	UBC_BASE:1.18
	SMP:1.9.0.4
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9;
locks; strict;
comment	@ * @;


1.181
date	2017.06.13.01.42.12;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	vqrKRi1J15EGWyf9;

1.180
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.179;
commitid	2Gtqjzrin9LL2yHk;

1.179
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.178;
commitid	DfYvEDcFmu1LY9q1;

1.178
date	2016.09.18.14.28.25;	author deraadt;	state Exp;
branches;
next	1.177;
commitid	BJaYTqaJQ1246GGO;

1.177
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.176;
commitid	RlO92XR575sygHqm;

1.176
date	2016.05.21.00.56.43;	author deraadt;	state Exp;
branches;
next	1.175;
commitid	oWpLaBOdDMvIxei3;

1.175
date	2016.05.11.20.19.00;	author deraadt;	state Exp;
branches;
next	1.174;
commitid	lxwoX5l3JOpuLQVg;

1.174
date	2016.05.10.18.39.46;	author deraadt;	state Exp;
branches;
next	1.173;
commitid	qfOifNidEGDB2jL1;

1.173
date	2016.04.20.23.52.04;	author dlg;	state Exp;
branches;
next	1.172;
commitid	hfeQvhMJUSqav4QG;

1.172
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.171;
commitid	XglPgGQ8qaiL0M4l;

1.171
date	2015.04.08.15.58.25;	author mpi;	state Exp;
branches;
next	1.170;
commitid	ER074ar2eYGjzZ9y;

1.170
date	2015.04.07.14.36.34;	author mpi;	state Exp;
branches;
next	1.169;
commitid	gPSqrQuekAvjvfCt;

1.169
date	2015.03.31.16.00.38;	author mpi;	state Exp;
branches;
next	1.168;
commitid	MMWnK4Mn4W58afQM;

1.168
date	2015.02.06.09.27.17;	author mpi;	state Exp;
branches;
next	1.167;
commitid	Tc9RtQjCoTwF9PCZ;

1.167
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.166;
commitid	Fn841MmVYz2JHvBP;

1.166
date	2015.01.20.18.34.00;	author mpi;	state Exp;
branches;
next	1.165;
commitid	EdxyRml3kMx5DGKk;

1.165
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.164;
commitid	qHQiR2HLROzvZr7B;

1.164
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.163;
commitid	yv0ECmCdICvq576h;

1.163
date	2014.10.27.21.56.57;	author kettenis;	state Exp;
branches;
next	1.162;
commitid	FoIIoP29J2IYw7zk;

1.162
date	2014.09.19.17.34.05;	author kettenis;	state Exp;
branches;
next	1.161;
commitid	UWk0PUhhImBEkXW7;

1.161
date	2014.08.18.17.56.45;	author miod;	state Exp;
branches;
next	1.160;
commitid	fXTg0ZycJiavkN0e;

1.160
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.159;
commitid	7QO4UJr3EKVAMc8t;

1.159
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.158;
commitid	wsdp3qtXGjMj98oD;

1.158
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.157;
commitid	qYPOd6Qi4aRBKldK;

1.157
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.156;
commitid	iYq3Z1ZWDKR3sS9G;

1.156
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.155;
commitid	YzvTa4t6mddz7Mh4;

1.155
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.154;
commitid	xpsLTYRIkonFtkr1;

1.154
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.153;
commitid	aofvn6ceiucgjg4N;

1.153
date	2014.07.09.08.34.01;	author deraadt;	state Exp;
branches;
next	1.152;
commitid	KcIGzHT0CMaQMwrI;

1.152
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.151;
commitid	eA4Y0YE1IUzj6hpW;

1.151
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.150;

1.150
date	2014.05.09.18.16.15;	author miod;	state Exp;
branches;
next	1.149;

1.149
date	2014.04.01.20.27.14;	author mpi;	state Exp;
branches;
next	1.148;

1.148
date	2014.03.31.18.58.41;	author mpi;	state Exp;
branches;
next	1.147;

1.147
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.146;

1.146
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.145;

1.145
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.144;

1.144
date	2014.02.08.13.17.38;	author miod;	state Exp;
branches;
next	1.143;

1.143
date	2014.01.06.16.17.33;	author uebayasi;	state Exp;
branches;
next	1.142;

1.142
date	2013.11.18.08.20.22;	author uebayasi;	state Exp;
branches;
next	1.141;

1.141
date	2013.09.28.12.40.31;	author miod;	state Exp;
branches;
next	1.140;

1.140
date	2013.08.17.08.33.11;	author mpi;	state Exp;
branches;
next	1.139;

1.139
date	2013.08.07.08.21.17;	author kettenis;	state Exp;
branches;
next	1.138;

1.138
date	2013.06.11.16.42.09;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2013.06.03.19.43.28;	author mpi;	state Exp;
branches;
next	1.136;

1.136
date	2013.06.03.19.16.44;	author mpi;	state Exp;
branches;
next	1.135;

1.135
date	2012.12.06.12.35.22;	author mpi;	state Exp;
branches;
next	1.134;

1.134
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2012.08.21.09.24.52;	author kettenis;	state Exp;
branches;
next	1.131;

1.131
date	2011.08.29.20.21.44;	author drahn;	state Exp;
branches;
next	1.130;

1.130
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.129;

1.129
date	2011.06.27.04.12.11;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.125;

1.125
date	2011.04.15.20.52.57;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.123;

1.123
date	2011.01.08.18.10.23;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2010.11.22.21.07.18;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.120;

1.120
date	2010.07.31.21.15.05;	author kettenis;	state Exp;
branches;
next	1.119;

1.119
date	2010.06.27.13.28.46;	author miod;	state Exp;
branches;
next	1.118;

1.118
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.117;

1.117
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2009.12.10.16.45.59;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2009.10.01.20.19.19;	author kettenis;	state Exp;
branches;
next	1.114;

1.114
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.113;

1.113
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.110;

1.110
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.109;

1.109
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.107;

1.107
date	2009.06.09.01.12.38;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.105;

1.105
date	2009.06.02.21.38.09;	author drahn;	state Exp;
branches;
next	1.104;

1.104
date	2009.01.22.22.41.42;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2008.11.22.14.42.29;	author art;	state Exp;
branches;
next	1.102;

1.102
date	2008.11.21.17.35.52;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2008.09.18.03.56.25;	author drahn;	state Exp;
branches;
next	1.100;

1.100
date	2008.09.16.04.20.42;	author drahn;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2008.05.01.08.25.32;	author kettenis;	state Exp;
branches;
next	1.97;

1.97
date	2008.04.26.22.37.41;	author drahn;	state Exp;
branches;
next	1.96;

1.96
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.23.17.05.41;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.04.13.43.38;	author martin;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.23.20.33.46;	author pvalchev;	state Exp;
branches;
next	1.89;

1.89
date	2007.03.20.20.59.54;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2007.03.17.21.11.58;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.27.01.04.03;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.26.21.30.17;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2006.06.30.16.14.30;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2006.03.15.21.03.38;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2005.11.12.00.23.43;	author drahn;	state Exp;
branches;
next	1.81;

1.81
date	2005.10.30.22.29.02;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2005.10.22.21.14.28;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.15.21.45.00;	author kettenis;	state Exp;
branches;
next	1.78;

1.78
date	2005.10.15.15.01.23;	author martin;	state Exp;
branches;
next	1.77;

1.77
date	2005.10.09.14.52.12;	author drahn;	state Exp;
branches;
next	1.76;

1.76
date	2005.10.09.14.17.32;	author drahn;	state Exp;
branches;
next	1.75;

1.75
date	2005.10.09.14.01.11;	author drahn;	state Exp;
branches;
next	1.74;

1.74
date	2005.10.03.04.47.30;	author drahn;	state Exp;
branches;
next	1.73;

1.73
date	2005.10.03.02.16.10;	author drahn;	state Exp;
branches;
next	1.72;

1.72
date	2005.07.04.01.02.10;	author mickey;	state Exp;
branches;
next	1.71;

1.71
date	2005.07.04.00.59.56;	author mickey;	state Exp;
branches;
next	1.70;

1.70
date	2005.06.27.14.32.20;	author mickey;	state Exp;
branches;
next	1.69;

1.69
date	2005.06.08.19.08.23;	author drahn;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.28.02.49.10;	author aaron;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.24.22.35.56;	author drahn;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.03.00.57.06;	author pvalchev;	state Exp;
branches;
next	1.65;

1.65
date	2003.12.20.22.40.27;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2003.11.06.21.09.35;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	2003.10.31.03.06.17;	author drahn;	state Exp;
branches;
next	1.62;

1.62
date	2003.10.30.03.17.54;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.24.19.56.44;	author drahn;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.21.20.53.34;	author drahn;	state Exp;
branches;
next	1.59;

1.59
date	2003.10.21.17.05.16;	author drahn;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.16.05.03.22;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.56;

1.56
date	2003.10.08.21.52.46;	author drahn;	state Exp;
branches;
next	1.55;

1.55
date	2003.09.22.21.39.38;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2003.07.14.18.56.12;	author drahn;	state Exp;
branches;
next	1.53;

1.53
date	2003.07.02.21.30.13;	author drahn;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.02.21.23.35;	author drahn;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.23.21.48.24;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.01.20.19.33;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.26.21.54.44;	author drahn;	state Exp;
branches;
next	1.47;

1.47
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.10.18.03.39.35;	author drahn;	state Exp;
branches;
next	1.45;

1.45
date	2002.10.13.18.26.12;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.23.04.25.52;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2002.09.16.16.06.33;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.09.11.22.29.47;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2002.09.06.13.42.17;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.20.02.50.43;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.23.17.53.24;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.07.21.54.25;	author drahn;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.27.15.09.24;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.21.03.02.32;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.23.51.47;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.13.18.27.36;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.08.02.52.36;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.23.16.59.36;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.17.22.59.52;	author maja;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.14.01.56.50;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.07.05.31.27;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.19.00.48.01;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.13.14.31.52;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.05.22.26.57;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.28.04.13.12;	author drahn;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2001.09.20.13.02.30;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.18.13.59.24;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.15.21.23.52;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.12.05.28.42;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.12.00.23.33;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.11.20.10.00;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches;
next	;

1.9.2.1
date	2001.11.13.17.45.26;	author jason;	state Exp;
branches;
next	;

1.9.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.9.4.8;

1.9.4.8
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.9.4.9;

1.9.4.9
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.14;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.181
log
@Prepare install_extint() for the vector being relative-negative (ie
lower in the address space).  Previously it could only be higher
than... uhm locore.o
Discussed with drahn and tom
@
text
@/*	$OpenBSD: machdep.c,v 1.180 2017/04/30 16:45:45 mpi Exp $	*/
/*	$NetBSD: machdep.c,v 1.4 1996/10/16 19:33:11 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/timeout.h>
#include <sys/exec.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/pool.h>
#include <sys/sysctl.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/reboot.h>
#include <sys/syscallargs.h>
#include <sys/syslog.h>
#include <sys/extent.h>
#include <sys/systm.h>
#include <sys/user.h>
#include <sys/conf.h>
#include <sys/core.h>
#include <sys/kcore.h>

#include <net/if.h>
#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <machine/pmap.h>
#include <powerpc/powerpc.h>
#include <machine/trap.h>
#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/pio.h>
#include <machine/intr.h>

#include <dev/pci/pcivar.h>

#include <arch/macppc/macppc/ofw_machdep.h>
#include <dev/ofw/openfirm.h>

#include "adb.h"
#if NADB > 0
#include <arch/macppc/dev/adbvar.h>
#endif

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_interface.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif

#include <powerpc/reg.h>
#include <powerpc/fpu.h>

/*
 * Global variables used here and there
 */
extern struct user *proc0paddr;
struct pool ppc_vecpl;

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

int ppc_malloc_ok = 0;

char *bootpath;
char bootpathbuf[512];

/* from autoconf.c */
extern void parseofwbp(char *);

struct firmware *fw = NULL;

#ifdef DDB
void * startsym, *endsym;
#endif

#ifdef APERTURE
int allowaperture = 0;
#endif

void dumpsys(void);
int lcsplx(int ipl);	/* called from LCore */
void *ppc_intr_establish(void *lcv, pci_intr_handle_t ih, int type,
    int level, int (*func)(void *), void *arg, const char *name);


/*
 * Extent maps to manage I/O. Allocate storage for 8 regions in each.
 */
static long devio_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof (long)];
struct extent *devio_ex;

/* XXX, called from asm */
void initppc(u_int startkernel, u_int endkernel, char *args);

void
initppc(startkernel, endkernel, args)
	u_int startkernel, endkernel;
	char *args;
{
	extern void *trapcode; extern int trapsize;
	extern void *dsitrap; extern int dsisize;
	extern void *isitrap; extern int isisize;
	extern void *alitrap; extern int alisize;
	extern void *decrint; extern int decrsize;
	extern void *tlbimiss; extern int tlbimsize;
	extern void *tlbdlmiss; extern int tlbdlmsize;
	extern void *tlbdsmiss; extern int tlbdsmsize;
#ifdef DDB
	extern void *ddblow; extern int ddbsize;
#endif
	extern void callback(void *);
	extern void *msgbuf_addr;
	int exc;

	proc0.p_cpu = &cpu_info[0];
	proc0.p_addr = proc0paddr;
	bzero(proc0.p_addr, sizeof *proc0.p_addr);

	curpcb = &proc0paddr->u_pcb;

	curpm = curpcb->pcb_pmreal = curpcb->pcb_pm = pmap_kernel();

	cpu_bootstrap();

	/*
	 * Initialize pmap module.
	 */
	pmap_bootstrap(startkernel, endkernel);

	/*
	 * Set up trap vectors
	 */
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100) {
		switch (exc) {
		default:
			bcopy(&trapcode, (void *)exc, (size_t)&trapsize);
			break;
		case EXC_EXI:
			/*
			 * This one is (potentially) installed during autoconf
			 */
			break;

		case EXC_DSI:
			bcopy(&dsitrap, (void *)EXC_DSI, (size_t)&dsisize);
			break;
		case EXC_ISI:
			bcopy(&isitrap, (void *)EXC_ISI, (size_t)&isisize);
			break;
		case EXC_ALI:
			bcopy(&alitrap, (void *)EXC_ALI, (size_t)&alisize);
			break;
		case EXC_DECR:
			bcopy(&decrint, (void *)EXC_DECR, (size_t)&decrsize);
			break;
		case EXC_IMISS:
			bcopy(&tlbimiss, (void *)EXC_IMISS, (size_t)&tlbimsize);
			break;
		case EXC_DLMISS:
			bcopy(&tlbdlmiss, (void *)EXC_DLMISS, (size_t)&tlbdlmsize);
			break;
		case EXC_DSMISS:
			bcopy(&tlbdsmiss, (void *)EXC_DSMISS, (size_t)&tlbdsmsize);
			break;
		case EXC_PGM:
		case EXC_TRC:
		case EXC_BPT:
#if defined(DDB)
			bcopy(&ddblow, (void *)exc, (size_t)&ddbsize);
#endif
			break;
		}
	}

	/* Grr, ALTIVEC_UNAVAIL is a vector not ~0xff aligned: 0x0f20 */
	bcopy(&trapcode, (void *)0xf20, (size_t)&trapsize);

	/*
	 * since trapsize is > 0x20, we just overwrote the EXC_PERF handler
	 * since we do not use it, we will "share" it with the EXC_VEC,
	 * we dont support EXC_VEC either.
	 * should be a 'ba 0xf20 written' at address 0xf00, but we
	 * do not generate EXC_PERF exceptions...
	 */

	syncicache((void *)EXC_RST, EXC_LAST - EXC_RST + 0x100);

	/*
	 * Now enable translation (and machine checks/recoverable interrupts).
	 */
	pmap_enable_mmu();

	/*
	 * use the memory provided by pmap_bootstrap for message buffer
	 */
	initmsgbuf(msgbuf_addr, MSGBUFSIZE);

	/*
	 * Look at arguments passed to us and compute boothowto.
	 */
	boothowto = RB_AUTOBOOT;

	/*
	 * Parse arg string.
	 */

	/* make a copy of the args! */
	strncpy(bootpathbuf, args, 512);
	bootpath= &bootpathbuf[0];
	while ( *++bootpath && *bootpath != ' ');
	if (*bootpath) {
		*bootpath++ = 0;
		while (*bootpath) {
			switch (*bootpath++) {
			case 'a':
				boothowto |= RB_ASKNAME;
				break;
			case 's':
				boothowto |= RB_SINGLE;
				break;
			case 'd':
				boothowto |= RB_KDB;
				break;
			case 'c':
				boothowto |= RB_CONFIG;
				break;
			default:
				break;
			}
		}
	}
	bootpath = &bootpathbuf[0];
	parseofwbp(bootpath);

#ifdef DDB
	ddb_init();
	db_machine_init();
#endif

	/*
	 * Set up extents for pci mappings
	 * Is this too late?
	 *
	 * what are good start and end values here??
	 * 0x0 - 0x80000000 mcu bus
	 * MAP A				MAP B
	 * 0x80000000 - 0xbfffffff io		0x80000000 - 0xefffffff mem
	 * 0xc0000000 - 0xffffffff mem		0xf0000000 - 0xffffffff io
	 *
	 * of course bsd uses 0xe and 0xf
	 * So the BSD PPC memory map will look like this
	 * 0x0 - 0x80000000 memory (whatever is filled)
	 * 0x80000000 - 0xdfffffff (pci space, memory or io)
	 * 0xe0000000 - kernel vm segment
	 * 0xf0000000 - kernel map segment (user space mapped here)
	 */

	devio_ex = extent_create("devio", 0x80000000, 0xffffffff, M_DEVBUF,
		(caddr_t)devio_ex_storage, sizeof(devio_ex_storage),
		EX_NOCOALESCE|EX_NOWAIT);

	/* while using openfirmware, run userconfig */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}

#ifdef DDB
	if (boothowto & RB_KDB)
		db_enter();
#endif

	/*
	 * Replace with real console.
	 */
	ofwconprobe();
	consinit();

        pool_init(&ppc_vecpl, sizeof(struct vreg), 16, IPL_NONE, 0, "ppcvec",
	    NULL);

}

void
install_extint(void (*handler)(void))
{
	void extint(void);
	void extsize(void);
	extern u_long extint_call;
	long offset = (u_long)handler - (u_long)&extint_call;
	int omsr, msr;

#ifdef DIAGNOSTIC
	if (offset > 0x1ffffff || offset < -0x1ffffff)
		panic("install_extint: too far away");
#endif
	omsr = ppc_mfmsr();
	msr = omsr & ~PSL_EE;
	ppc_mtmsr(msr);
	offset &= 0x3ffffff;
	extint_call = (extint_call & 0xfc000003) | offset;
	bcopy(&extint, (void *)EXC_EXI, (size_t)&extsize);
	syncicache((void *)&extint_call, sizeof extint_call);
	syncicache((void *)EXC_EXI, (int)&extsize);
	ppc_mtmsr(omsr);
}

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

/*
 * Machine dependent startup code.
 */
void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;

	proc0.p_addr = proc0paddr;

	printf("%s", version);

	printf("real mem = %llu (%lluMB)\n",
	    (unsigned long long)ptoa((psize_t)physmem),
	    (unsigned long long)ptoa((psize_t)physmem)/1024U/1024U);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
	    VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);
	ppc_malloc_ok = 1;

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Set up the buffers.
	 */
	bufinit();
}

/*
 * consinit
 * Initialize system console.
 */
void
consinit()
{
	static int cons_initted = 0;

	if (cons_initted)
		return;
	cninit();
	cons_initted = 1;
}

/*
 * Clear registers on exec
 */
void
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t *retval)
{
	u_int32_t newstack;
	u_int32_t pargs;
	u_int32_t args[4];

	struct trapframe *tf = trapframe(p);
	pargs = -roundup(-stack + 8, 16);
	newstack = (u_int32_t)(pargs - 32);

	copyin ((void *)p->p_p->ps_strings, &args, 0x10);

	bzero(tf, sizeof *tf);
	tf->fixreg[1] = newstack;
	tf->fixreg[3] = retval[0] = args[1];	/* XXX */
	tf->fixreg[4] = retval[1] = args[0];	/* XXX */
	tf->fixreg[5] = args[2];		/* XXX */
	tf->fixreg[6] = args[3];		/* XXX */
	tf->srr0 = pack->ep_entry;
	tf->srr1 = PSL_MBO | PSL_USERSET | PSL_FE_DFLT;
	p->p_addr->u_pcb.pcb_flags = 0;
}

/*
 * Send a signal to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigframe *fp, frame;
	struct sigacts *psp = p->p_p->ps_sigacts;

	bzero(&frame, sizeof(frame));
	frame.sf_signum = sig;

	tf = trapframe(p);

	/*
	 * Allocate stack space for signal handler.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(tf->fixreg[1]) &&
	    (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)(p->p_sigstk.ss_sp
					 + p->p_sigstk.ss_size);
	else
		fp = (struct sigframe *)tf->fixreg[1];

	fp = (struct sigframe *)((int)(fp - 1) & ~0xf);

	/*
	 * Generate signal context for SYS_sigreturn.
	 */
	frame.sf_sc.sc_mask = mask;
	frame.sf_sip = NULL;
	bcopy(tf, &frame.sf_sc.sc_frame, sizeof *tf);
	if (psp->ps_siginfo & sigmask(sig)) {
		frame.sf_sip = &fp->sf_si;
		initsiginfo(&frame.sf_si, sig, code, type, val);
	}
	frame.sf_sc.sc_cookie = (long)&fp->sf_sc ^ p->p_p->ps_sigcookie;
	if (copyout(&frame, fp, sizeof frame) != 0)
		sigexit(p, SIGILL);

	tf->fixreg[1] = (int)fp;
	tf->lr = (int)catcher;
	tf->fixreg[3] = (int)sig;
	tf->fixreg[4] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : 0;
	tf->fixreg[5] = (int)&fp->sf_sc;
	tf->srr0 = p->p_p->ps_sigcode;

#if WHEN_WE_ONLY_FLUSH_DATA_WHEN_DOING_PMAP_ENTER
	pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),tf->srr0, &pa);
	syncicache(pa, (p->p_p->ps_emul->e_esigcode -
	    p->p_p->ps_emul->e_sigcode));
#endif
}

/*
 * System call to cleanup state after a signal handler returns.
 */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *tf;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	if ((error = copyin(scp, &ksc, sizeof ksc)))
		return error;

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	tf = trapframe(p);
	ksc.sc_frame.srr1 &= ~PSL_VEC;
	ksc.sc_frame.srr1 |= (tf->srr1 & PSL_VEC);
	if ((ksc.sc_frame.srr1 & PSL_USERSTATIC) != (tf->srr1 & PSL_USERSTATIC))
		return EINVAL;
	bcopy(&ksc.sc_frame, tf, sizeof *tf);
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;
	return EJUSTRETURN;
}

/*
 * Machine dependent system variables.
 * None for now.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return ENOTDIR;
	switch (name[0]) {
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_int_lower(oldp, oldlenp, newp, newlen,
			    &allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case CPU_ALTIVEC:
		return (sysctl_rdint(oldp, oldlenp, newp, ppc_altivec));
	default:
		return EOPNOTSUPP;
	}
}


u_long dumpmag = 0x04959fca;			/* magic number */
int dumpsize = 0;			/* size of dump in pages */
long dumplo = -1;			/* blocks */

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first CLBYTES of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void dumpconf(void);

void
dumpconf(void)
{
	int nblks;	/* size of dump area */
	int i;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	/* Always skip the first block, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

        for (i = 0; i < ndumpmem; i++)
		dumpsize = max(dumpsize, dumpmem[i].end);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo - 1))
		dumpsize = dtoc(nblks - dumplo - 1);
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;

}

#define BYTES_PER_DUMP  (PAGE_SIZE)  /* must be a multiple of pagesize */
static vaddr_t dumpspace;

int
reserve_dumppages(caddr_t p)
{
	dumpspace = (vaddr_t)p;
	return BYTES_PER_DUMP;
}

/*
 * cpu_dump: dump machine-dependent kernel core dump headers.
 */
int cpu_dump(void);
int
cpu_dump()
{
	int (*dump) (dev_t, daddr_t, caddr_t, size_t);
	long buf[dbtob(1) / sizeof (long)];
	kcore_seg_t	*segp;

	dump = bdevsw[major(dumpdev)].d_dump;

	segp = (kcore_seg_t *)buf;

	/*
	 * Generate a segment header.
	 */
	CORE_SETMAGIC(*segp, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	segp->c_size = dbtob(1) - ALIGN(sizeof(*segp));

	return (dump(dumpdev, dumplo, (caddr_t)buf, dbtob(1)));
}

void
dumpsys()
{
#if 0
	u_int npg;
	u_int i, j;
	daddr_t blkno;
	int (*dump) (dev_t, daddr_t, caddr_t, size_t);
	char *str;
	int maddr;
	extern int msgbufmapped;
	int error;

	/* save registers */

	msgbufmapped = 0;	/* don't record dump msgs in msgbuf */
	if (dumpdev == NODEV)
		return;
	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo < 0)
		return;
	printf("dumping to dev %x, offset %ld\n", dumpdev, dumplo);

	error = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
	if (error == -1) {
		printf("area unavailable\n");
		delay (10000000);
		return;
	}

	dump = bdevsw[major(dumpdev)].d_dump;
	error = cpu_dump();
	for (i = 0; !error && i < ndumpmem; i++) {
		npg = dumpmem[i].end - dumpmem[i].start;
		maddr = ptoa(dumpmem[i].start);
		blkno = dumplo + btodb(maddr) + 1;

		for (j = npg; j;
			j--, maddr += PAGE_SIZE, blkno+= btodb(PAGE_SIZE))
		{
			/* Print out how many MBs we have to go. */
                        if (dbtob(blkno - dumplo) % (1024 * 1024) < NBPG)
                                printf("%d ",
                                    (ptoa(dumpsize) - maddr) / (1024 * 1024));

			pmap_enter(pmap_kernel(), dumpspace, maddr,
				PROT_READ, PMAP_WIRED);
			if ((error = (*dump)(dumpdev, blkno,
			    (caddr_t)dumpspace, PAGE_SIZE)) != 0)
				break;
		}
	}

	switch (error) {

	case 0:         str = "succeeded\n\n";                  break;
	case ENXIO:     str = "device bad\n\n";                 break;
	case EFAULT:    str = "device not ready\n\n";           break;
	case EINVAL:    str = "area improper\n\n";              break;
	case EIO:       str = "i/o error\n\n";                  break;
	case EINTR:     str = "aborted from console\n\n";       break;
	default:        str = "error %d\n\n";                   break;
	}
	printf(str, error);

#else
	printf("dumpsys() - no yet supported\n");
	
#endif
	delay(5000000);         /* 5 seconds */

}

int
lcsplx(int ipl)
{
	return spllower(ipl);
}

/*
 * Halt or reboot the machine after syncing/dumping according to howto.
 */
__dead void
boot(int howto)
{
	static int syncing;

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && !syncing) {
		syncing = 1;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0) {
#if NADB > 0
			delay(1000000);
			adb_poweroff();
			printf("WARNING: adb powerdown failed!\n");
#endif
			OF_interpret("shut-down", 0);
		}

		printf("halted\n\n");
		OF_exit();
	}
	printf("rebooting\n\n");

#if NADB > 0
	adb_restart();  /* not return */
#endif

	OF_interpret("reset-all", 0);
	OF_exit();
	printf("boot failed, spinning\n");
	for (;;)
		continue;
	/* NOTREACHED */
}

typedef void  (void_f) (void);
void_f *pending_int_f = NULL;

/* call the bus/interrupt controller specific pending interrupt handler
 * would be nice if the offlevel interrupt code was handled here
 * instead of being in each of the specific handler code
 */
void
do_pending_int()
{
	if (pending_int_f != NULL) {
		(*pending_int_f)();
	}
}

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
void
signotify(struct proc *p)
{
	aston(p);
	cpu_unidle(p->p_cpu);
}

#ifdef MULTIPROCESSOR
void
cpu_unidle(struct cpu_info *ci)
{
	if (ci != curcpu())
		ppc_send_ipi(ci, PPC_IPI_NOP);
}
#endif

int ppc_configed_intr_cnt = 0;
struct intrhand ppc_configed_intr[MAX_PRECONF_INTR];

/*
 * True if the system has any non-level interrupts which are shared
 * on the same pin.
 */
int	intr_shared_edge;

void *
ppc_intr_establish(void *lcv, pci_intr_handle_t ih, int type, int level,
    int (*func)(void *), void *arg, const char *name)
{
	if (ppc_configed_intr_cnt < MAX_PRECONF_INTR) {
		ppc_configed_intr[ppc_configed_intr_cnt].ih_fun = func;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_arg = arg;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_type = type;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_level = level;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_irq = ih;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_what = name;
		ppc_configed_intr_cnt++;
	} else {
		panic("ppc_intr_establish called before interrupt controller"
			" configured: driver %s too many interrupts", name);
	}
	/* disestablish is going to be tricky to supported for these :-) */
	return (void *)ppc_configed_intr_cnt;
}

intr_establish_t *intr_establish_func = (intr_establish_t *)ppc_intr_establish;
intr_disestablish_t *intr_disestablish_func;

intr_send_ipi_t ppc_no_send_ipi;
intr_send_ipi_t *intr_send_ipi_func = ppc_no_send_ipi;

void
ppc_no_send_ipi(struct cpu_info *ci, int id)
{
	panic("ppc_send_ipi called: no ipi function");
}

void
ppc_send_ipi(struct cpu_info *ci, int id)
{
	(*intr_send_ipi_func)(ci, id);
}

/* bcopy(), error on fault */
int
kcopy(const void *from, void *to, size_t size)
{
	faultbuf env;
	void *oldh = curproc->p_addr->u_pcb.pcb_onfault;

	if (setfault(&env)) {
		curproc->p_addr->u_pcb.pcb_onfault = oldh;
		return EFAULT;
	}
	bcopy(from, to, size);
	curproc->p_addr->u_pcb.pcb_onfault = oldh;

	return 0;
}

/* prototype for locore function */
void cpu_switchto_asm(struct proc *oldproc, struct proc *newproc);

void
cpu_switchto(struct proc *oldproc, struct proc *newproc)
{
	/*
	 * if this CPU is running a new process, flush the
	 * FPU/Altivec context to avoid an IPI.
	 */
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	if (ci->ci_fpuproc)
		save_fpu();
	if (ci->ci_vecproc)
		save_vec(ci->ci_vecproc);
#endif

	cpu_switchto_asm(oldproc, newproc);
}
@


1.180
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.179 2016/10/09 11:25:40 tom Exp $	*/
d334 1
a334 1
	u_long offset = (u_long)handler - (u_long)&extint_call;
d337 2
a338 2
#ifdef	DIAGNOSTIC
	if (offset > 0x1ffffff)
d344 1
@


1.179
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.178 2016/09/18 14:28:25 deraadt Exp $	*/
d314 1
a314 1
		Debugger();
@


1.178
log
@option INSECURE is obsolete
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.177 2016/09/15 02:00:17 dlg Exp $	*/
d787 2
a788 1
	for (;;) ;
@


1.177
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.176 2016/05/21 00:56:43 deraadt Exp $	*/
a117 3
#ifdef INSECURE
int allowaperture = 1;
#else
a118 1
#endif
@


1.176
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.175 2016/05/11 20:19:00 deraadt Exp $	*/
d327 2
a328 2
        pool_init(&ppc_vecpl, sizeof(struct vreg), 16, 0, 0, "ppcvec", NULL);
	pool_setipl(&ppc_vecpl, IPL_NONE);
@


1.175
log
@fix sigcookie value, address was off due to trapframe nesting
notice by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.174 2016/05/10 18:39:46 deraadt Exp $	*/
d511 1
a511 1
	struct sigcontext sc, *scp = SCARG(uap, sigcntxp);
a515 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%x 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
d520 1
a520 1
	if ((error = copyin(scp, &sc, sizeof sc)))
d523 1
a523 4
	if (sc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, sc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d529 3
a531 4
	sc.sc_cookie = 0;
	(void)copyout(&sc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (sc.sc_cookie));
d534 3
a536 3
	sc.sc_frame.srr1 &= ~PSL_VEC;
	sc.sc_frame.srr1 |= (tf->srr1 & PSL_VEC);
	if ((sc.sc_frame.srr1 & PSL_USERSTATIC) != (tf->srr1 & PSL_USERSTATIC))
d538 2
a539 2
	bcopy(&sc.sc_frame, tf, sizeof *tf);
	p->p_sigmask = sc.sc_mask & ~sigcantmask;
@


1.174
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.173 2016/04/20 23:52:04 dlg Exp $	*/
d484 1
a484 1
	frame.sf_sc.sc_cookie = (long)fp ^ p->p_p->ps_sigcookie;
a486 1

@


1.173
log
@pool_setipl for floating point context things

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.172 2015/10/21 07:59:18 mpi Exp $	*/
d484 1
d512 1
a512 1
	struct sigcontext sc;
d516 8
a523 1
	if ((error = copyin(SCARG(uap, sigcntxp), &sc, sizeof sc)))
d525 15
@


1.172
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.171 2015/04/08 15:58:25 mpi Exp $	*/
d328 1
@


1.171
log
@Kill unused function.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.170 2015/04/07 14:36:34 mpi Exp $	*/
a657 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.170
log
@Remove a lie, the early boot console does not need any mapping.

In fact we even use the firmware interface for "bsd -c" and "bsd -d".
So do the necessary firmware calls before calling initppc() to be able
to use printf() really early in the boot sequence.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.169 2015/03/31 16:00:38 mpi Exp $	*/
a126 2
void ppc_intr_setup(intr_establish_t *establish,
    intr_disestablish_t *disestablish);
a816 6
/*
 * one attempt at interrupt stuff..
 *
 */
#include <dev/pci/pcivar.h>

a847 7

void
ppc_intr_setup(intr_establish_t *establish, intr_disestablish_t *disestablish)
{
	intr_establish_func = establish;
	intr_disestablish_func = disestablish;
}
@


1.169
log
@Make it possisble to disable block address translation mechanism on
processors that support it.

Due to the way trap code is patched it is currently not possible to
enabled/disable BAT at runtime.

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.168 2015/02/06 09:27:17 mpi Exp $	*/
a308 4
	/*
	 * Now we can set up the console as mapping is enabled.
	 */
	ofwconsinit();
@


1.168
log
@Call the debugger (bsd -d) before replacing the firmware console just like
we do for config (bsd -c) to be able to use ddb with USB keyboards.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.167 2015/01/20 19:43:21 kettenis Exp $	*/
a61 1
#include <machine/bat.h>
a99 2
struct bat battable[16];

d160 1
a160 1
	int exc, scratch;
d170 1
a170 1
	ppc_check_procid();
d173 1
a173 2
	 * Initialize BAT registers to unmapped to not generate
	 * overlapping mappings below.
d175 1
a175 28
	ppc_mtibat0u(0);
	ppc_mtibat1u(0);
	ppc_mtibat2u(0);
	ppc_mtibat3u(0);
	ppc_mtdbat0u(0);
	ppc_mtdbat1u(0);
	ppc_mtdbat2u(0);
	ppc_mtdbat3u(0);

	/*
	 * Set up initial BAT table to only map the lowest 256 MB area
	 */
	battable[0].batl = BATL(0x00000000, BAT_M);
	battable[0].batu = BATU(0x00000000, BAT_BL_256M);

	/*
	 * Now setup fixed bat registers
	 *
	 * Note that we still run in real mode, and the BAT
	 * registers were cleared above.
	 */
	/* DBAT0 used for initial 256 MB segment */
	ppc_mtdbat0l(battable[0].batl);
	ppc_mtdbat0u(battable[0].batu);

	/* IBAT0 only covering the kernel .text */
	ppc_mtibat0l(battable[0].batl);
	ppc_mtibat0u(BATU(0x00000000, BAT_BL_8M));
a234 39

	uvmexp.pagesize = 4096;
	uvm_setpagesize();

	/*
	 * Initialize pmap module.
	 */
	pmap_bootstrap(startkernel, endkernel);

	/* now that we know physmem size, map physical memory with BATs */
	if (physmem > atop(0x10000000)) {
		battable[0x1].batl = BATL(0x10000000, BAT_M);
		battable[0x1].batu = BATU(0x10000000, BAT_BL_256M);
	}
	if (physmem > atop(0x20000000)) {
		battable[0x2].batl = BATL(0x20000000, BAT_M);
		battable[0x2].batu = BATU(0x20000000, BAT_BL_256M);
	}
	if (physmem > atop(0x30000000)) {
		battable[0x3].batl = BATL(0x30000000, BAT_M);
		battable[0x3].batu = BATU(0x30000000, BAT_BL_256M);
	}
	if (physmem > atop(0x40000000)) {
		battable[0x4].batl = BATL(0x40000000, BAT_M);
		battable[0x4].batu = BATU(0x40000000, BAT_BL_256M);
	}
	if (physmem > atop(0x50000000)) {
		battable[0x5].batl = BATL(0x50000000, BAT_M);
		battable[0x5].batu = BATU(0x50000000, BAT_BL_256M);
	}
	if (physmem > atop(0x60000000)) {
		battable[0x6].batl = BATL(0x60000000, BAT_M);
		battable[0x6].batu = BATU(0x60000000, BAT_BL_256M);
	}
	if (physmem > atop(0x70000000)) {
		battable[0x7].batl = BATL(0x70000000, BAT_M);
		battable[0x7].batu = BATU(0x70000000, BAT_BL_256M);
	}

d238 1
a238 2
	__asm__ volatile ("eieio; mfmsr %0; ori %0,%0,%1; mtmsr %0; sync;isync"
		      : "=r"(scratch) : "K"(PSL_IR|PSL_DR|PSL_ME|PSL_RI));
@


1.167
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.166 2015/01/20 18:34:00 mpi Exp $	*/
d392 6
a402 5

#ifdef DDB
	if (boothowto & RB_KDB)
		Debugger();
#endif
@


1.166
log
@Merge two copies of the (almost) identical bus space code into one file.

This brings bus_space_mmap(9) to socppc and change its bus_space_map(9)
implementation to use kernel_map instead of phys_map like macppc and
everybody else.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.165 2014/12/10 15:29:53 mikeb Exp $	*/
d506 1
a506 1
	copyin ((void *)(VM_MAX_ADDRESS-0x10), &args, 0x10);
@


1.165
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.164 2014/11/16 12:30:58 deraadt Exp $	*/
a133 6
int bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp);
bus_addr_t bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t size);
void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t size);
a950 325
}


/* BUS functions */
int
bus_space_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	int error;

	if  (POWERPC_BUS_TAG_BASE(t) == 0) {
		/* if bus has base of 0 fail. */
		return EINVAL;
	}
	bpa |= POWERPC_BUS_TAG_BASE(t);
	if ((error = extent_alloc_region(devio_ex, bpa, size, EX_NOWAIT |
	    (ppc_malloc_ok ? EX_MALLOCOK : 0))))
		return error;

	if ((error = bus_mem_add_mapping(bpa, size, flags, bshp))) {
		if (extent_free(devio_ex, bpa, size, EX_NOWAIT |
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}
	return error;
}
bus_addr_t
bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
	bus_addr_t paddr;

	pmap_extract(pmap_kernel(), bsh, &paddr);
	bus_space_unmap((t), (bsh), (size));
	return paddr ;
}
void
bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
	bus_addr_t sva;
	bus_size_t off, len;
	bus_addr_t bpa;

	/* should this verify that the proper size is freed? */
	sva = trunc_page(bsh);
	off = bsh - sva;
	len = size+off;

	if (pmap_extract(pmap_kernel(), sva, &bpa) == TRUE) {
		if (extent_free(devio_ex, bpa | (bsh & PAGE_MASK), size, EX_NOWAIT |
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}
	/* do not free memory which was stolen from the vm system */
	if (ppc_malloc_ok &&
	    ((sva >= VM_MIN_KERNEL_ADDRESS) && (sva < VM_MAX_KERNEL_ADDRESS)))
		uvm_km_free(kernel_map, sva, len);
	else {
		pmap_remove(pmap_kernel(), sva, sva + len);
		pmap_update(pmap_kernel());
	}
}

paddr_t
bus_space_mmap(bus_space_tag_t t, bus_addr_t bpa, off_t off, int prot,
    int flags)
{
	int pmapflags = PMAP_NOCACHE;

	if (POWERPC_BUS_TAG_BASE(t) == 0)
		return (-1);

	bpa |= POWERPC_BUS_TAG_BASE(t);

	if (flags & BUS_SPACE_MAP_CACHEABLE)
		pmapflags &= ~PMAP_NOCACHE;

	return ((bpa + off) | pmapflags);
}

vaddr_t ppc_kvm_stolen = VM_KERN_ADDRESS_SIZE;

int
bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	bus_addr_t vaddr;
	bus_addr_t spa, epa;
	bus_size_t off;
	int len;

	spa = trunc_page(bpa);
	epa = bpa + size;
	off = bpa - spa;
	len = size+off;

#if 0
	if (epa <= spa) {
		panic("bus_mem_add_mapping: overflow");
	}
#endif
	if (ppc_malloc_ok == 0) {
		bus_size_t alloc_size;

		/* need to steal vm space before kernel vm is initialized */
		alloc_size = round_page(len);

		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += alloc_size;
		if (ppc_kvm_stolen > PPC_SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
	} else {
		vaddr = uvm_km_valloc(kernel_map, len);
		if (vaddr == 0)
			return (ENOMEM);
	}
	*bshp = vaddr + off;
#ifdef DEBUG_BUS_MEM_ADD_MAPPING
	printf("mapping %x size %x to %x vbase %x\n",
		bpa, size, *bshp, spa);
#endif
	for (; len > 0; len -= PAGE_SIZE) {
		pmap_kenter_cache(vaddr, spa, PROT_READ | PROT_WRITE,
		    (flags & BUS_SPACE_MAP_CACHEABLE) ?
		      PMAP_CACHE_WT : PMAP_CACHE_CI);
		spa += PAGE_SIZE;
		vaddr += PAGE_SIZE;
	}
	return 0;
}

int
bus_space_alloc(bus_space_tag_t tag, bus_addr_t rstart, bus_addr_t rend,
    bus_size_t size, bus_size_t alignment, bus_size_t boundary, int flags,
    bus_addr_t *addrp, bus_space_handle_t *handlep)
{

	panic("bus_space_alloc: unimplemented");
}

void
bus_space_free(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t size)
{

	panic("bus_space_free: unimplemented");
}

void *
mapiodev(paddr_t pa, psize_t len)
{
	paddr_t spa;
	vaddr_t vaddr, va;
	int off;
	int size;

	spa = trunc_page(pa);
	off = pa - spa;
	size = round_page(off+len);
	if (ppc_malloc_ok == 0) {
		/* need to steal vm space before kernel vm is initialized */
		va = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += size;
		if (ppc_kvm_stolen > PPC_SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
	} else {
		va = uvm_km_valloc(kernel_map, size);
	}

	if (va == 0)
		return NULL;

	for (vaddr = va; size > 0; size -= PAGE_SIZE) {
		pmap_kenter_cache(vaddr, spa,
		    PROT_READ | PROT_WRITE, PMAP_CACHE_DEFAULT);
		spa += PAGE_SIZE;
		vaddr += PAGE_SIZE;
	}
	return (void *) (va+off);
}
void
unmapiodev(void *kva, psize_t p_size)
{
	vaddr_t vaddr;
	int size;

	size = p_size;

	vaddr = trunc_page((vaddr_t)kva);

	uvm_km_free(kernel_map, vaddr, size);

	for (; size > 0; size -= PAGE_SIZE) {
		pmap_remove(pmap_kernel(), vaddr, vaddr + PAGE_SIZE - 1);
		vaddr += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}



/*
 * probably should be ppc_space_copy
 */

#define _CONCAT(A,B) A ## B
#define __C(A,B)	_CONCAT(A,B)

#define BUS_SPACE_COPY_N(BYTES,TYPE)					\
void									\
__C(bus_space_copy_,BYTES)(void *v, bus_space_handle_t h1,		\
    bus_size_t o1, bus_space_handle_t h2, bus_size_t o2,		\
    bus_size_t c)							\
{									\
	TYPE *src, *dst;						\
	int i;								\
									\
	src = (TYPE *) (h1+o1);						\
	dst = (TYPE *) (h2+o2);						\
									\
	if (h1 == h2 && o2 > o1)					\
		for (i = c-1; i >= 0; i--)				\
			dst[i] = src[i];				\
	else								\
		for (i = 0; i < c; i++)					\
			dst[i] = src[i];				\
}
BUS_SPACE_COPY_N(1,u_int8_t)
BUS_SPACE_COPY_N(2,u_int16_t)
BUS_SPACE_COPY_N(4,u_int32_t)

void
bus_space_set_region_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int8_t val, bus_size_t c)
{
	u_int8_t *dst;
	int i;

	dst = (u_int8_t *) (h+o);

	for (i = 0; i < c; i++)
		dst[i] = val;
}

void
bus_space_set_region_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int16_t val, bus_size_t c)
{
	u_int16_t *dst;
	int i;

	dst = (u_int16_t *) (h+o);
	val = swap16(val);

	for (i = 0; i < c; i++)
		dst[i] = val;
}
void
bus_space_set_region_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int32_t val, bus_size_t c)
{
	u_int32_t *dst;
	int i;

	dst = (u_int32_t *) (h+o);
	val = swap32(val);

	for (i = 0; i < c; i++)
		dst[i] = val;
}

#define BUS_SPACE_READ_RAW_MULTI_N(BYTES,SHIFT,TYPE)			\
void									\
__C(bus_space_read_raw_multi_,BYTES)(bus_space_tag_t bst,		\
    bus_space_handle_t h, bus_addr_t o, u_int8_t *dst, bus_size_t size)	\
{									\
	TYPE *src;							\
	TYPE *rdst = (TYPE *)dst;					\
	int i;								\
	int count = size >> SHIFT;					\
									\
	src = (TYPE *)(h+o);						\
	for (i = 0; i < count; i++) {					\
		rdst[i] = *src;						\
		__asm__("eieio");					\
	}								\
}
BUS_SPACE_READ_RAW_MULTI_N(2,1,u_int16_t)
BUS_SPACE_READ_RAW_MULTI_N(4,2,u_int32_t)

#define BUS_SPACE_WRITE_RAW_MULTI_N(BYTES,SHIFT,TYPE)			\
void									\
__C(bus_space_write_raw_multi_,BYTES)( bus_space_tag_t bst,		\
    bus_space_handle_t h, bus_addr_t o, const u_int8_t *src,		\
    bus_size_t size)							\
{									\
	int i;								\
	TYPE *dst;							\
	TYPE *rsrc = (TYPE *)src;					\
	int count = size >> SHIFT;					\
									\
	dst = (TYPE *)(h+o);						\
	for (i = 0; i < count; i++) {					\
		*dst = rsrc[i];						\
		__asm__("eieio");					\
	}								\
}

BUS_SPACE_WRITE_RAW_MULTI_N(2,1,u_int16_t)
BUS_SPACE_WRITE_RAW_MULTI_N(4,2,u_int32_t)

int
bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
{
	*nbshp = bsh + offset;
	return (0);
@


1.164
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.163 2014/10/27 21:56:57 kettenis Exp $	*/
a835 1
	doshutdownhooks();
@


1.163
log
@Remove the spilling code for IBAT register and set up the first IBAT register
to cover the first 8 MB of memory such that it covers kernel .text and not
much else.  This is a first step towards W^X in the kernel for machines
with G4 and older processors.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.162 2014/09/19 17:34:05 kettenis Exp $	*/
d768 1
a768 1
				VM_PROT_READ, PMAP_WIRED);
d1088 1
a1088 1
		pmap_kenter_cache(vaddr, spa, VM_PROT_READ | VM_PROT_WRITE,
d1140 1
a1140 1
			VM_PROT_READ | VM_PROT_WRITE, PMAP_CACHE_DEFAULT);
@


1.162
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.161 2014/08/18 17:56:45 miod Exp $	*/
d198 1
a198 1
	battable[0].batu = BATU(0x00000000);
d206 1
a206 5
	/* IBAT0 used for initial 256 MB segment */
	ppc_mtibat0l(battable[0].batl);
	ppc_mtibat0u(battable[0].batu);

	/* DBAT0 used similar */
d210 4
d284 1
a284 1
		battable[0x1].batu = BATU(0x10000000);
d288 1
a288 1
		battable[0x2].batu = BATU(0x20000000);
d292 1
a292 1
		battable[0x3].batu = BATU(0x30000000);
d296 1
a296 1
		battable[0x4].batu = BATU(0x40000000);
d300 1
a300 1
		battable[0x5].batu = BATU(0x50000000);
d304 1
a304 1
		battable[0x6].batu = BATU(0x60000000);
d308 1
a308 1
		battable[0x7].batu = BATU(0x70000000);
@


1.161
log
@Explicitely need <sys/pool.h> now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.160 2014/07/21 17:25:47 uebayasi Exp $	*/
a806 1
	struct device *mainbus;
d837 1
a837 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.160
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
@


1.159
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d832 1
a832 1
	if (howto & RB_DUMP)
d841 2
a842 2
	if (howto & RB_HALT) {
		if ((howto & RB_POWERDOWN) == RB_POWERDOWN) {
@


1.158
log
@Cosmetic changes to reduce diffs.
@
text
@d816 1
a816 1
	if (!(howto & RB_NOSYNC) && !syncing) {
d863 2
a864 1
	while(1) /* forever */;
@


1.157
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.156 2014/07/10 20:15:27 uebayasi Exp $	*/
d818 1
a818 1
		vfs_shutdown();		/* sync */
@


1.156
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d830 1
@


1.155
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a809 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
@


1.154
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a823 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
@


1.153
log
@if you use sysctl, you need sysctl.h
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.152 2014/05/31 15:49:28 mpi Exp $	*/
d803 1
a803 1
void
@


1.152
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.151 2014/05/30 13:46:16 mpi Exp $	*/
d43 1
@


1.151
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.150 2014/05/09 18:16:15 miod Exp $	*/
a837 1
	cold = 1;
@


1.150
log
@Format string fixes and removal of -Wno-format for *ppc kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.149 2014/04/01 20:27:14 mpi Exp $	*/
d838 1
@


1.149
log
@Remove the almost unused abstraction around "struct firmware" and use
instead a single function ppc_mem_regions() required by the ppc pmap.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.148 2014/03/31 18:58:41 mpi Exp $	*/
d989 1
a989 1
			printf("bus_space_map: pa 0x%lx, size 0x%x\n",
d1021 1
a1021 1
			printf("bus_space_map: pa 0x%lx, size 0x%x\n",
@


1.148
log
@Including <uvm/uvm_extern.h> is enough, no need for <uvm/uvm.h> or more.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.147 2014/03/26 05:23:42 guenther Exp $	*/
d62 1
a62 1
#include <machine/powerpc.h>
a311 2
	(fw->vmon)();

d678 1
a678 1
vaddr_t dumpspace;
d859 1
a859 1
		(fw->exit)();
@


1.147
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.146 2014/03/22 06:05:45 guenther Exp $	*/
d56 1
a56 1
#include <uvm/uvm.h>
@


1.146
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.145 2014/03/13 03:52:55 dlg Exp $	*/
d574 1
a574 1
	tf->srr0 = p->p_sigcode;
d578 2
a579 1
	syncicache(pa, (p->p_emul->e_esigcode - p->p_emul->e_sigcode));
@


1.145
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.144 2014/02/08 13:17:38 miod Exp $	*/
d535 1
a535 1
	struct sigacts *psp = p->p_sigacts;
@


1.144
log
@Some (if not all) G5 systems use a different layout for the physical memory
information (property `reg' of the `/memory' node). Fortunately the available
physical memory information still uses the same format, so this only affects
the computation of physmem.

Detect this case and parse the information correctly, converting to the format
expected by pmap, ignoring physical memory beyond 4GB.

Compute physmem from all the physical memory information, even memory not
usable by the kernel. Let pmap not recompute physmem in pmap_bootstrap() if
physmem is != 0 upon entry.

This should allow G5 systems fitted with more than 2GB of physical memory to
report the correct amount of memory, even though the kernel will only use
the lower 2GB.

Prompted by a dmesg@@ submission by Greg Marsh, owner of a 3.5GB G5

help and tweaks kettenis@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.143 2014/01/06 16:17:33 uebayasi Exp $	*/
d806 1
d845 3
a847 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.143
log
@Make macppc/socppc boot() code path more similar to others.

This changes calling boot() during (cold != 0) to not call if_downall() and
uvm_shutdown().  Both of which must not be specific to PowerPC.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d454 3
a456 2
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);
@


1.142
log
@Normalize code sequence around dumpsys(), doshutdownhooks(), and
config_suspend() in ppc boot() functions.  Always go through them regardless
of (howto & RB_HALT).

OK deraadt@@ mpi@@
@
text
@d807 10
d818 1
a818 1
	if (!cold && !(howto & RB_NOSYNC) && !syncing) {
d838 1
a838 1
	if (!cold && (howto & RB_DUMP))
d840 2
@


1.141
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.140 2013/08/17 08:33:11 mpi Exp $	*/
d827 7
a834 3
		doshutdownhooks();
		if (!TAILQ_EMPTY(&alldevs))
			config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
a846 5
	if (!cold && (howto & RB_DUMP))
		dumpsys();
	doshutdownhooks();
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.140
log
@Remove a bunch of unused variables and functions aging from the pre
powerpc -> macppc area.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2013/08/07 08:21:17 kettenis Exp $	*/
d829 2
a830 1
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
d846 2
a847 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.139
log
@Using phys_map for bus_space_map(9) is retarded.  Use kernel_map just like
everybody else.

ok mpi@@, beck@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2013/06/11 16:42:09 deraadt Exp $	*/
a105 8
#ifndef SYS_TYPE
/* XXX Hardwire it for now */
#define SYS_TYPE POWER4e
#endif

int system_type = SYS_TYPE;	/* XXX Hardwire it for now */

char ofw_eth_addr[6];		/* Save address of first network ifc found */
a125 2
void ofw_dbg(char *str);

a126 1
void systype(char *name);
a127 1
int power4e_get_eth_addr(void);
d141 1
a141 3
 * Extent maps to manage I/O. Allocate storage for 8 regions in each,
 * initially. Later devio_malloc_safe will indicate that it's safe to
 * use malloc() to dynamically allocate region descriptors.
a144 3
static int devio_malloc_safe = 0;

extern int OF_stdout;
a408 5
	/*
	 * Figure out ethernet address.
	 */
	(void)power4e_get_eth_addr();

a411 6
void ofw_dbg(char *str)
{
	int i = strlen (str);
	OF_write(OF_stdout, str, i);
}

a478 2

	devio_malloc_safe = 1;
a857 27
/*
 *  Get Ethernet address for the onboard ethernet chip.
 */
int
power4e_get_eth_addr()
{
	int qhandle, phandle;
	char name[32];

	for (qhandle = OF_peer(0); qhandle; qhandle = phandle) {
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
		    && !strcmp(name, "network")
		    && OF_getprop(qhandle, "local-mac-address",
				  &ofw_eth_addr, sizeof ofw_eth_addr) >= 0) {
			return(0);
		}
		if ((phandle = OF_child(qhandle)))
			continue;
		while (qhandle) {
			if ((phandle = OF_peer(qhandle)))
				break;
			qhandle = OF_parent(qhandle);
		}
	}
	return(-1);
}

a893 38
 * set system type from string
 */
void
systype(char *name)
{
	/* this table may be order specific if substrings match several
	 * computers but a longer string matches a specific
	 */
	int i;
	struct systyp {
		char *name;
		char *systypename;
		int type;
	} systypes[] = {
		{ "MOT",	"(PWRSTK) MCG powerstack family", PWRSTK },
		{ "V-I Power",	"(POWER4e) V-I ppc vme boards ",  POWER4e},
		{ "iMac",	"(APPL) Apple iMac ",  APPL},
		{ "PowerMac",	"(APPL) Apple PowerMac ",  APPL},
		{ "PowerBook",	"(APPL) Apple Powerbook ",  APPL},
		{ NULL,"",0}
	};
	for (i = 0; systypes[i].name != NULL; i++) {
		if (strncmp( name , systypes[i].name,
			strlen (systypes[i].name)) == 0)
		{
			system_type = systypes[i].type;
			printf("recognized system type of %s as %s\n",
				name, systypes[i].systypename);
			break;
		}
	}
	if (system_type == OFWMACH) {
		printf("System type %snot recognized, good luck\n",
			name);
	}
}

/*
a1275 25
}

int
ppc_open_pci_bridge()
{
	char *
	pci_bridges[] = {
		"/pci",
		NULL
	};
	int handle;
	int i;

	for (i = 0; pci_bridges[i] != NULL; i++) {
		handle = OF_open(pci_bridges[i]);
		if ( handle != -1) {
			return handle;
		}
	}
	return 0;
}
void
ppc_close_pci_bridge(int handle)
{
	OF_close(handle);
@


1.138
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2013/06/03 19:43:28 mpi Exp $	*/
d1109 1
a1109 1
		uvm_km_free(phys_map, sva, len);
d1111 1
a1111 1
		pmap_remove(vm_map_pmap(phys_map), sva, sva+len);
d1166 1
a1166 2
		vaddr = uvm_km_kmemalloc(phys_map, NULL, len,
		    UVM_KMF_NOWAIT|UVM_KMF_VALLOC);
d1220 1
a1220 2
		va = uvm_km_kmemalloc(phys_map, NULL, size,
		    UVM_KMF_NOWAIT|UVM_KMF_VALLOC);
d1244 1
a1244 1
	uvm_km_free_wakeup(phys_map, vaddr, size);
d1247 1
a1247 5
#if 0
		pmap_remove(vm_map_pmap(phys_map), vaddr, vaddr+PAGE_SIZE-1);
#else
		pmap_remove(pmap_kernel(), vaddr,  vaddr+PAGE_SIZE-1);
#endif
@


1.137
log
@Correctly return the error code if uvm_km_kmemalloc() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2013/06/03 19:16:44 mpi Exp $	*/
d724 1
a724 1
	int (*dump) (dev_t, daddr64_t, caddr_t, size_t);
d747 2
a748 2
	daddr64_t blkno;
	int (*dump) (dev_t, daddr64_t, caddr_t, size_t);
@


1.136
log
@Rework the logic for matching the boot device to allow for root on
any drive attached to the first controller. Fix an issue reported
by Jan Stary, hans at stare dot cz.

Note that this new logic still doesn't allow for root on any drive
attached to a secondary controller.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2012/12/06 12:35:22 mpi Exp $	*/
d1074 1
a1074 1
	return 0;
@


1.135
log
@Implement bus_space_mmap(9).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2012/12/02 07:03:31 guenther Exp $	*/
d117 3
d373 2
a374 1
	bootpath= &bootpathbuf[0];
@


1.134
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.133 2012/10/08 21:47:48 deraadt Exp $	*/
d1110 17
@


1.133
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2012/08/21 09:24:52 kettenis Exp $	*/
a560 1
	int oldonstack;
d562 1
a565 1
	oldonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d570 3
a572 3
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0
	    && !oldonstack
	    && (psp->ps_sigonstack & sigmask(sig))) {
d575 1
a575 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
a582 1
	frame.sf_sc.sc_onstack = oldonstack;
a627 4
	if (sc.sc_onstack & 1)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.132
log
@For interrupts that get established before we attach the interrupt controller,
store the type of the interrupt (level, edge).

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2011/08/29 20:21:44 drahn Exp $	*/
d862 1
d878 1
@


1.131
log
@Return of the long missing powerpc interrupt rewrite.  Was working for
several weeks before release on macppc, socppc bugs just fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2011/07/05 04:48:01 guenther Exp $	*/
d1011 1
@


1.130
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2011/06/27 04:12:11 deraadt Exp $	*/
a824 2

int cpu_imask[IPL_NUM];
@


1.129
log
@repair after last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2011/06/05 19:41:07 deraadt Exp $	*/
d566 1
a566 1
	oldonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d571 1
a571 1
	if ((psp->ps_flags & SAS_ALTSTACK)
d574 3
a576 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp
					 + psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d632 1
a632 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d634 1
a634 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.128
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@a35 5
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/sched.h>
a36 4
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
d38 1
d41 1
d43 7
a49 2
#include <sys/ioctl.h>
#include <sys/tty.h>
d51 1
a51 3
#include <sys/exec.h>
#include <sys/exec_ecoff.h>
#include <sys/sysctl.h>
@


1.127
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2011/04/18 21:44:55 guenther Exp $	*/
d36 5
d42 4
a46 1
#include <sys/exec.h>
a48 1
#include <sys/mount.h>
d50 2
a51 7
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/reboot.h>
#include <sys/syscallargs.h>
#include <sys/syslog.h>
#include <sys/extent.h>
#include <sys/systm.h>
d53 3
a55 1
#include <sys/conf.h>
d59 1
d862 1
@


1.126
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2011/04/15 20:52:57 deraadt Exp $	*/
a93 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.125
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2011/04/15 04:52:39 guenther Exp $	*/
d579 1
a579 1
	oldonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d584 1
a584 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0
d587 3
a589 3
		fp = (struct sigframe *)(p->p_sigstk.ss_sp
					 + p->p_sigstk.ss_size);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d645 1
a645 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d647 1
a647 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.124
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2011/01/08 18:10:23 deraadt Exp $	*/
d1011 6
@


1.123
log
@rename imask[] to cpu_imask[] to because imask is too loud as far as
kernel namespace
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2010/11/22 21:07:18 miod Exp $	*/
d579 1
a579 1
	oldonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d584 1
a584 1
	if ((psp->ps_flags & SAS_ALTSTACK)
d587 3
a589 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp
					 + psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d645 1
a645 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d647 1
a647 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.122
log
@Remove prototypes for missing (removed) functions or already found in a
MI header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2010/08/07 03:50:01 krw Exp $	*/
d839 1
a839 1
int imask[IPL_NUM];
@


1.121
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2010/07/31 21:15:05 kettenis Exp $	*/
a191 1
	extern void consinit(void);
@


1.120
log
@Ignore the PSL_VEC bit in the sigcontext and always copy the bit out from
the trap frame.  The Altivec unit might have been stolen away from us while
we were running the signal handler, so it is ok that the two don't agree.
Fixes the X server mysteriously exiting (and seemingly freeze).

ok miod@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2010/06/27 13:28:46 miod Exp $	*/
d1048 1
a1048 1
	panic("ppc_send_ipi called: no ipi function\n");
@


1.119
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2010/06/27 03:03:48 thib Exp $	*/
d640 2
@


1.118
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2009/12/10 16:45:59 deraadt Exp $	*/
a55 1
#include <uvm/uvm_extern.h>
@


1.117
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d55 1
d109 3
@


1.116
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2009/10/01 20:19:19 kettenis Exp $	*/
d470 6
@


1.115
log
@Generic soft interrupts for macppc.  Tested by mk@@, deraadt@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2009/08/22 02:54:50 mk Exp $	*/
d1405 2
a1406 1
void cpu_switchto( struct proc *oldproc, struct proc *newproc)
@


1.114
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2009/08/11 19:17:16 miod Exp $	*/
a56 2
#include <net/netisr.h>

a829 31

/*
 * this is a hack interface to allow zs to work better until
 * a true soft interrupt mechanism is created.
 */
#include "zstty.h"
#if NZSTTY > 0
	extern void zssoft(void *);
#endif
void
softtty()
{
#if NZSTTY > 0
	zssoft(0);
#endif
}

int netisr;

/*
 * Soft networking interrupts.
 */
void
softnet(int isr)
{
#define DONETISR(flag, func) \
	if (isr & (1 << flag))\
		func();

#include <net/netisr_dispatch.h>
}
@


1.113
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2009/08/11 18:46:32 miod Exp $	*/
d152 1
a152 1
    int level, int (*func)(void *), void *arg, char *name);
d1037 1
a1037 1
    int (*func)(void *), void *arg, char *name)
@


1.112
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2009/08/09 10:40:17 blambert Exp $	*/
a486 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.111
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2009/08/02 16:28:39 beck Exp $	*/
a144 1
caddr_t allocsys(caddr_t);
a478 2
	int sz;
	caddr_t v;
a480 1
	v = (caddr_t)proc0paddr + USPACE;
a488 10
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
a518 12
}

/*
 * Allocate space for system data structures.
 */
caddr_t
allocsys(caddr_t v)
{
#define	valloc(name, type, num) \
	v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
@


1.110
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2009/07/26 18:48:55 miod Exp $	*/
a56 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a542 7

#ifdef	SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.109
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2009/06/15 17:01:26 beck Exp $	*/
a510 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.108
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2009/06/09 01:12:38 deraadt Exp $	*/
d157 1
a157 1
int bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
d1132 1
a1132 1
    int cacheable, bus_space_handle_t *bshp)
d1138 1
a1138 1
		return 1;
d1145 1
a1145 1
	if ((error  = bus_mem_add_mapping(bpa, size, cacheable, bshp))) {
d1199 1
a1199 1
bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
d1240 3
a1242 3
		pmap_kenter_cache(vaddr, spa,
			VM_PROT_READ | VM_PROT_WRITE,
			cacheable ? PMAP_CACHE_WT : PMAP_CACHE_CI);
d1251 1
a1251 1
    bus_size_t size, bus_size_t alignment, bus_size_t boundary, int cacheable,
@


1.107
log
@backout interrupt diff until it the next round of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2009/01/22 22:41:42 kettenis Exp $	*/
d511 6
@


1.106
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2009/06/02 21:38:09 drahn Exp $	*/
d873 2
@


1.105
log
@Reintroduce the macppc interrupt subsystem rewrite. Several bugs have
been found and corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2008/09/18 03:56:25 drahn Exp $	*/
a510 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.104
log
@Make bus_mem_add_mapping() return ENOMEM if we fail to allocate kva instead
of panicing.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.103 2008/11/22 14:42:29 art Exp $	*/
a878 2

int imask[IPL_NUM];
@


1.103
log
@cpu_unidle for macppc
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2008/11/21 17:35:52 deraadt Exp $	*/
d1232 1
a1232 2
			panic("bus_mem_add_mapping: kvm alloc of 0x%x failed",
			    len);
@


1.102
log
@back out the new interrupt subsystem because some little bug still lurks in there
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2008/09/16 04:20:42 drahn Exp $	*/
d1025 3
d1029 6
a1034 2
	if (p->p_cpu != curcpu() && p->p_cpu != NULL)
		ppc_send_ipi(p->p_cpu, PPC_IPI_NOP);
a1035 1
}
@


1.101
log
@Redesign of the powerpc interrupt architecture, use true levels intead of
blocking specific interrupts. Needs signficant testing to prove that
one remaining elusive bug has been squashed.
@
text
@d880 2
@


1.100
log
@SMP ddb support, with some feedback from kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2008/06/27 17:22:14 miod Exp $	*/
a878 2

int imask[IPL_NUM];
@


1.99
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2008/05/01 08:25:32 kettenis Exp $	*/
d85 1
d391 1
d1027 1
a1027 1
		openpic_send_ipi(p->p_cpu->ci_cpuid);
d1106 16
@


1.98
log
@Implement a nop IPI to signal other CPUs.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2008/04/26 22:37:41 drahn Exp $	*/
d823 4
@


1.97
log
@Changes to get closer to SMP.
add biglock before interrupt calls into the kernel.
switch the clock to using cpuinfo variables instead of globals
move cpu_switchto into C code so that on multiprocessor the FPU
and Altivec can be saved before switching CPUs.
add a lock into pmap when modifying the hash table.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2008/04/09 16:58:10 deraadt Exp $	*/
d1009 14
@


1.96
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2008/04/09 16:50:28 deraadt Exp $	*/
d90 3
d1441 20
@


1.95
log
@setroot() is supposed to be safe in all cases, so kill the special cases
for RB_DFLTROOT; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2007/11/04 13:43:38 martin Exp $	*/
d934 2
@


1.94
log
@replace even more ctob/btoc with ptoa/atop
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2007/06/06 17:15:12 deraadt Exp $	*/
a350 2
	 * Default to SINGLE and ASKNAME if no args or
	 * SINGLE and DFLTROOT if this is a ramdisk kernel.
a351 3
#ifdef RAMDISK_HOOKS
	boothowto = RB_SINGLE | RB_DFLTROOT;
#else
a352 1
#endif /* RAMDISK_HOOKS */
@


1.93
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2007/05/29 20:36:47 deraadt Exp $	*/
d307 1
a307 1
	if (physmem > btoc(0x10000000)) {
d311 1
a311 1
	if (physmem > btoc(0x20000000)) {
d315 1
a315 1
	if (physmem > btoc(0x30000000)) {
d319 1
a319 1
	if (physmem > btoc(0x40000000)) {
d323 1
a323 1
	if (physmem > btoc(0x50000000)) {
d327 1
a327 1
	if (physmem > btoc(0x60000000)) {
d331 1
a331 1
	if (physmem > btoc(0x70000000)) {
d493 2
a494 2
	printf("real mem = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
d838 1
a838 1
		maddr = ctob(dumpmem[i].start);
d847 1
a847 1
                                    (ctob(dumpsize) - maddr) / (1024 * 1024));
@


1.92
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2007/05/26 20:26:51 pedro Exp $	*/
d782 1
a782 1
	int (*dump) (dev_t, daddr_t, caddr_t, size_t);
d805 2
a806 2
	daddr_t blkno;
	int (*dump) (dev_t, daddr_t, caddr_t, size_t);
@


1.91
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2007/05/23 20:33:46 pvalchev Exp $	*/
d737 1
d739 1
a739 1
dumpconf()
a741 1
	int maj;
d744 2
a745 2

	if (dumpdev == NODEV)
a746 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
a750 1

@


1.90
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2007/03/20 20:59:54 kettenis Exp $	*/
a98 6
#ifdef NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

d484 1
a484 1
	int sz, i;
d487 1
a487 1
	int base, residual;
a488 1

d507 2
a508 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d510 8
a517 34
	sz = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(sz),
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	/*
	addr = (vaddr_t)buffers;
	*/
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	if (base >= MAXBSIZE) {
		/* Don't want to alloc more physical mem than ever needed */
		base = MAXBSIZE;
		residual = 0;
	}
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		curbuf = (vaddr_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base + 1 : base);
		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for"
					" buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
					VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a535 2
	printf("using %u buffers containing %u bytes (%uK) of memory\n",
	    nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
a559 22

	/*
	 * Decide on buffer space to use.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 35% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 35 / 100;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.89
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2007/03/17 21:11:58 kettenis Exp $	*/
d500 2
a501 1
	printf("real mem = %d (%dK)\n", ctob(physmem), ctob(physmem)/1024);
d567 2
a568 2
	printf("avail mem = %ld (%ldK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
@


1.88
log
@Make lcsplx() call spllower() instead of duplicating its code.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2007/02/27 01:04:03 deraadt Exp $	*/
a92 3
struct pcb *curpcb;
struct pmap *curpm;

d202 1
a939 1
volatile int cpl, ipending, astpending;
@


1.87
log
@previous commit ppc machines.  has miod been reading tech-kern too much,
and is he trying to emulate them?
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2006/06/30 16:14:30 miod Exp $	*/
d979 1
a979 5
	int oldcpl;

	oldcpl = cpl;
	splx(ipl);
	return oldcpl;
@


1.86
log
@Zero rval[1] in setregs.
@
text
@a662 2

	retval[1] = 0;
@


1.85
log
@Old typos bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2006/03/15 21:03:38 deraadt Exp $	*/
d663 2
@


1.84
log
@use sysctl_int_lower() for the aperture variable.  This lets root close
the aperture without having to reboot, but does not allow re-opening;
ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2005/12/17 07:31:26 miod Exp $	*/
d172 1
a172 1
 * initially. Later devio_malloc_safe will indicate that it's save to
@


1.83
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2005/11/12 00:23:43 drahn Exp $	*/
d767 2
a768 2
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
@


1.82
log
@print memory the same way as it is done on i386/amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2005/10/30 22:29:02 kettenis Exp $	*/
d494 1
a494 1
	vm_offset_t minaddr, maxaddr;
d534 2
a535 2
		vm_size_t curbufsize;
		vm_offset_t curbuf;
d538 1
a538 1
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
d1225 1
a1225 1
vm_offset_t ppc_kvm_stolen = VM_KERN_ADDRESS_SIZE;
@


1.81
log
@Update RTC on reboot.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2005/10/22 21:14:28 kettenis Exp $	*/
d570 2
a571 2
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * PAGE_SIZE);
@


1.80
log
@Initialize ddb again.
ok drahn@@, "yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2005/10/15 21:45:00 kettenis Exp $	*/
d998 1
a998 4
#if 0
		/* resettodr does not currently do anything, address
		 * this later
		 */
a1008 1
#endif
@


1.79
log
@Fall back on OF to reboot/power down.
commit drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2005/10/15 15:01:23 martin Exp $	*/
d399 1
a399 1
#ifdef notyet_DDB
@


1.78
log
@- merge adb_direct.h bits into adbvar.h
- rename ADB_HW_PB to ADB_HW_PMU

from NetBSD

ok brad@@; additonal testing krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2005/10/09 14:52:12 drahn Exp $	*/
a992 1
	static char str[256];
d1021 1
a1021 1
			printf("WARNING: powerdown failed!\n");
d1023 1
d1038 1
a1039 1
	(fw->boot)(str);
@


1.77
log
@Subtle changes to the powerpc fpu handling, basically fpuproc is handled
in a non-raceable manner inside save_fpu and enable_fpu so that the
eventual SMP case will not grab a half loaded fpu context.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2005/10/09 14:17:32 drahn Exp $	*/
a80 1
#include <arch/macppc/dev/adb_direct.h>
@


1.76
log
@Provide a machdep sysctl to determine if altivec is avaliable on macppc
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2005/10/09 14:01:11 drahn Exp $	*/
a95 1
struct proc *fpuproc;
@


1.75
log
@Nearly functional crashdump support for macppc. Because savecore
does not recognize the resulting crashdumps, the writing has been disabled.
Better here than in my forest of trees.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2005/10/03 04:47:30 drahn Exp $	*/
d777 2
@


1.74
log
@Handle segment register restore at context enter/exit instead of
deep in the kernel. Based on code from two years ago, now necessary
for G5. removes the 1GB ram limit on 32bit processors, temporarily
sets a 256MB limit on G5.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2005/10/03 02:16:10 drahn Exp $	*/
d51 3
d782 82
d867 73
a939 1
	printf("dumpsys: TBD\n");
@


1.73
log
@First part of locore G5 support, this is one step of many.
Get this in and tested before the rest hits the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2005/07/04 01:02:10 mickey Exp $	*/
a312 14
	/* use BATs to map 1GB memory, no pageable BATs now */
	if (physmem > btoc(0x10000000)) {
		ppc_mtdbat1l(BATL(0x10000000, BAT_M));
		ppc_mtdbat1u(BATU(0x10000000));
	}
	if (physmem > btoc(0x20000000)) {
		ppc_mtdbat2l(BATL(0x20000000, BAT_M));
		ppc_mtdbat2u(BATU(0x20000000));
	}
	if (physmem > btoc(0x30000000)) {
		ppc_mtdbat3l(BATL(0x30000000, BAT_M));
		ppc_mtdbat3u(BATU(0x30000000));
	}
#if 0
a341 1
#endif
d398 1
a398 1
#ifdef DDB
@


1.72
log
@do not allocate any PA allocating VA for mapping devices; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2005/07/04 00:59:56 mickey Exp $	*/
d210 2
@


1.71
log
@always enforce cache-inhibit if bus_space_map()ping uncachable; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2005/06/27 14:32:20 mickey Exp $	*/
d1118 2
a1119 1
		vaddr = uvm_km_valloc_wait(phys_map, len);
d1174 2
a1175 1
		va = uvm_km_valloc_wait(phys_map, size);
@


1.70
log
@remove dead code; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2005/06/08 19:08:23 drahn Exp $	*/
d1131 1
a1131 1
			cacheable ? PMAP_CACHE_WT : PMAP_CACHE_DEFAULT);
@


1.69
log
@Remove the bus_reverse field out of the powerpc bus structure, originally
it was there so that big endian and little endian devices could both be
present, however that is not the case on the macppc machines.
Cleans up code, shrinks the kernel. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2004/06/28 02:49:10 aaron Exp $	*/
a177 3
/* HACK - XXX */
int segment8_a_mapped = 0;

a1033 6
	if ((bpa >= 0x80000000) && ((bpa+size) < 0xb0000000)) {
		if (segment8_a_mapped) {
			*bshp = bpa;
			return 0;
		}
	}
a1164 5
	if ((pa >= 0x80000000) && ((pa+len) < 0xb0000000)) {
		if (segment8_a_mapped) {
			return (void *)pa;
		}
	}
@


1.68
log
@Use new event counter API for interrupt counting on macppc.  drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2004/06/24 22:35:56 drahn Exp $	*/
d1277 1
a1277 2
	if (t->bus_reverse)
		val = swap16(val);
d1290 1
a1290 2
	if (t->bus_reverse)
		val = swap32(val);
@


1.67
log
@Do a better job at containing powerpc specific #defines to PPC_...
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2004/01/03 00:57:06 pvalchev Exp $	*/
a156 1
void nameinterrupt(int replace, char *newstr);
a1385 30
}

void
nameinterrupt(int replace, char *newstr)
{
#define NENTRIES 66
	char intrname[NENTRIES][30];
	char *p, *src;
	int i;
	extern char intrnames[];
	extern char eintrnames[];

	if (replace >= NENTRIES) {
		return;
	}
	src = intrnames;

	for (i = 0; i < NENTRIES; i++) {
		src += strlcpy(intrname[i], src, 30);
		src+=1; /* skip the NUL */
	}

	strlcat(intrname[replace], "/", sizeof intrname[replace]);
	strlcat(intrname[replace], newstr, sizeof intrname[replace]);

	p = intrnames;
	for (i = 0; i < NENTRIES; i++) {
		p += strlcpy(p, intrname[i], eintrnames - p);
		p += 1; /* skip the NUL */
	}
@


1.66
log
@backout segment register restore diff which causes reproducible hangs; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2003/12/20 22:40:27 miod Exp $	*/
d1124 1
a1124 1
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
d1184 1
a1184 1
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
@


1.65
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2003/11/06 21:09:35 mickey Exp $	*/
d315 14
d358 1
@


1.64
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2003/10/31 03:06:17 drahn Exp $	*/
d569 2
a570 2
	printf("avail mem = %d (%dK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
d1033 1
a1033 1
			printf("bus_space_map: pa 0x%x, size 0x%x\n",
d1065 1
a1065 1
			printf("bus_space_map: pa 0x%x, size 0x%x\n",
@


1.63
log
@Fix ppc segment register restores, this fixes the 1GB ram limit and
cleans up pieces in the pmap code.
tested otto, brad, miod, pval.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2003/10/30 03:17:54 itojun Exp $	*/
d805 2
@


1.62
log
@fix NULL/0 mixup.  drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2003/10/24 19:56:44 drahn Exp $	*/
a314 14
	/* use BATs to map 1GB memory, no pageable BATs now */
	if (physmem > btoc(0x10000000)) {
		ppc_mtdbat1l(BATL(0x10000000, BAT_M));
		ppc_mtdbat1u(BATU(0x10000000));
	}
	if (physmem > btoc(0x20000000)) {
		ppc_mtdbat2l(BATL(0x20000000, BAT_M));
		ppc_mtdbat2u(BATU(0x20000000));
	}
	if (physmem > btoc(0x30000000)) {
		ppc_mtdbat3l(BATL(0x30000000, BAT_M));
		ppc_mtdbat3u(BATU(0x30000000));
	}
#if 0
a343 1
#endif
@


1.61
log
@IPKDB has never been supported in OpenBSD/powerpc/macppc delete this
old unused code.
Remove very old 'where' debugging references.
ANSI a previously missed function.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2003/10/21 20:53:34 drahn Exp $	*/
d731 1
a731 1
	tf->fixreg[4] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
@


1.60
log
@Fix copy bounds, however did this work??? Well it didn't.
Confirmed by nate@@ and tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2003/10/21 17:05:16 drahn Exp $	*/
a33 3
/*
#include "machine/ipkdb.h"
*/
a182 1
extern int where;
a202 3
#if NIPKDB > 0
	extern ipkdblow, ipkdbsize;
#endif
a210 1
where = 3;
a287 4
#else
#if NIPKDB > 0
			bcopy(&ipkdblow, (void *)exc, (size_t)&ipkdbsize);
#endif
a458 8
#if NIPKDB > 0
	/*
	 * Now trap to IPKDB
	 */
	ipkdb_init();
	if (boothowto & RB_KDB)
		ipkdb_connect(0);
#else
a462 1
#endif
d1372 1
a1372 4
kcopy(from, to, size)
	const void *from;
	void *to;
	size_t size;
@


1.59
log
@This was changed from a magic number to a define in the header file,
but this one was missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2003/10/16 05:03:22 deraadt Exp $	*/
d1266 1
a1266 1
		for (i = c; i > 0; i--)					\
@


1.58
log
@more white
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2003/10/15 17:50:16 drahn Exp $	*/
d824 1
a824 1
int imask[7];
@


1.57
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2003/10/08 21:52:46 drahn Exp $	*/
d803 2
a804 2
		if (securelevel > 0) 
			return (sysctl_rdint(oldp, oldlenp, newp, 
d807 1
a807 1
			return (sysctl_int(oldp, oldlenp, newp, newlen, 
d826 1
a826 1
/* 
d1282 1
a1282 1
	
d1295 1
a1295 1
	
d1309 1
a1309 1
	
@


1.56
log
@Fix endian bug in macppc bus_space_set_region_N(). ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2003/09/22 21:39:38 miod Exp $	*/
d167 5
d501 1
a501 2
install_extint(handler)
	void (*handler)(void);
d557 2
a558 3
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
d622 1
a622 2
allocsys(v)
	caddr_t v;
d678 2
a679 5
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
d706 2
a707 6
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d731 1
d766 1
a766 4
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d794 2
a795 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d846 1
a846 2
softnet(isr)
	int isr;
d856 1
a856 2
lcsplx(ipl)
	int ipl;
d869 1
a869 2
boot(howto)
	int howto;
d1013 2
a1014 8
ppc_intr_establish(lcv, ih, type, level, func, arg, name)
	void *lcv;
	pci_intr_handle_t ih;
	int type;
	int level;
	int (*func)(void *);
	void *arg;
	char *name;
d1043 2
a1044 6
bus_space_map(t, bpa, size, cacheable, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
d1054 1
a1054 2
		(ppc_malloc_ok ? EX_MALLOCOK : 0))))
	{
d1056 1
a1056 1
	}
a1073 4
bus_addr_t bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
d1075 1
a1075 4
bus_space_unmap_p(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
d1084 1
a1084 4
bus_space_unmap(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
d1106 1
a1106 2
	  ((sva >= VM_MIN_KERNEL_ADDRESS) && (sva < VM_MAX_KERNEL_ADDRESS)) )
	{
d1108 1
a1108 1
	} else {
d1117 2
a1118 5
bus_mem_add_mapping(bpa, size, cacheable, bshp)
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
d1168 3
a1170 7
bus_space_alloc(tag, rstart, rend, size, alignment, boundary, cacheable, addrp, handlep)
	bus_space_tag_t tag;
	bus_addr_t rstart, rend;
	bus_size_t size, alignment, boundary;
	int cacheable;
	bus_addr_t *addrp;
	bus_space_handle_t *handlep;
d1177 1
a1177 4
bus_space_free(tag, handle, size)
	bus_space_tag_t tag;
	bus_space_handle_t handle;
	bus_size_t size;
d1184 1
a1184 3
mapiodev(pa, len)
	paddr_t pa;
	psize_t len;
d1222 1
a1222 3
unmapiodev(kva, p_size)
	void *kva;
	psize_t p_size;
d1255 3
a1257 4
__C(bus_space_copy_,BYTES)(v, h1, o1, h2, o2, c)			\
	void *v;							\
	bus_space_handle_t h1, h2;					\
	bus_size_t o1, o2, c;						\
d1265 2
a1266 2
	if (h1 == h2 && o2 > o1) {					\
		for (i = c; i > 0; i--) {				\
d1268 2
a1269 3
		}							\
	} else {							\
		for (i = 0; i < c; i++) {				\
a1270 2
		}							\
	}								\
d1277 2
a1278 5
bus_space_set_region_1(t, h, o, val, c)
	bus_space_tag_t t;
	bus_space_handle_t h;
	u_int8_t val;
	bus_size_t o, c;
d1285 1
a1285 1
	for (i = 0; i < c; i++) {
a1286 1
	}
d1290 2
a1291 5
bus_space_set_region_2(t, h, o, val, c)
	bus_space_tag_t t;
	bus_space_handle_t h;
	u_int16_t val;
	bus_size_t o, c;
d1300 1
a1300 1
	for (i = 0; i < c; i++) {
a1301 1
	}
d1304 2
a1305 5
bus_space_set_region_4(t, h, o, val, c)
	bus_space_tag_t t;
	bus_space_handle_t h;
	u_int32_t val;
	bus_size_t o, c;
d1314 1
a1314 1
	for (i = 0; i < c; i++) {
a1315 1
	}
d1320 2
a1321 6
__C(bus_space_read_raw_multi_,BYTES)(bst, h, o, dst, size)		\
	bus_space_tag_t bst;						\
	bus_space_handle_t h;						\
	bus_addr_t o;							\
	u_int8_t *dst;							\
	bus_size_t size;						\
d1339 3
a1341 6
__C(bus_space_write_raw_multi_,BYTES)(bst, h, o, src, size)		\
	bus_space_tag_t bst;						\
	bus_space_handle_t h;						\
	bus_addr_t o;							\
	const u_int8_t *src;						\
	bus_size_t size;						\
d1359 2
a1360 5
bus_space_subregion(t, bsh, offset, size, nbshp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset, size;
	bus_space_handle_t *nbshp;
d1399 1
a1399 1
	register void *oldh = curproc->p_addr->u_pcb.pcb_onfault;
d1412 1
a1412 3
nameinterrupt(replace, newstr)
	int replace;
	char *newstr;
@


1.55
log
@Off-by-ones, from aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2003/07/14 18:56:12 drahn Exp $	*/
d1332 34
a1365 15
#define BUS_SPACE_SET_REGION_N(BYTES,TYPE)				\
void									\
__C(bus_space_set_region_,BYTES)(v, h, o, val, c)			\
	void *v;							\
	bus_space_handle_t h;						\
	TYPE val;							\
	bus_size_t o, c;						\
{									\
	TYPE *dst;							\
	int i;								\
									\
	dst = (TYPE *) (h+o);						\
	for (i = 0; i < c; i++) {					\
		dst[i] = val;						\
	}								\
d1367 13
d1381 4
a1384 3
BUS_SPACE_SET_REGION_N(1,u_int8_t)
BUS_SPACE_SET_REGION_N(2,u_int16_t)
BUS_SPACE_SET_REGION_N(4,u_int32_t)
@


1.54
log
@'dual' clock support for macppc, this allows the stat clock to run
at a rate independant of the HZ clock. when profiling is enabled
stat clock now runs at 1000/s instead of the normal 100/s. Other
improvements to the ppc clock handling and KNF/ansi.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2003/07/02 21:30:13 drahn Exp $	*/
d1468 1
a1468 1
	if (replace > NENTRIES) {
@


1.53
log
@Reduce the amount of asm code in powerpc/macppc by replacing it with
inlined functions, helps improve readability and fix a couple of bugs.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2003/07/02 21:23:35 drahn Exp $	*/
d836 1
a836 1
volatile int cpl, ipending, astpending, tickspending;
@


1.52
log
@make ppc_intr_(enable|disable)() inlined functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2003/06/23 21:48:24 mickey Exp $	*/
d222 8
a229 8
	__asm__ volatile ("mtibatu 0,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 1,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 2,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 3,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 0,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 1,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 2,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 3,%0" :: "r"(0));
d244 3
a246 2
	__asm__ volatile ("mtibatl 0,%0; mtibatu 0,%1"
		      :: "r"(battable[0].batl), "r"(battable[0].batu));
d248 2
a249 4
	__asm__ volatile ("mtdbatl 0,%0; mtdbatu 0,%1"
		      :: "r"(battable[0].batl), "r"(battable[0].batu));


d324 2
a325 3
		__asm__ volatile ("mtdbatl 1,%0; mtdbatu 1,%1"
			      :: "r"(BATL(0x10000000, BAT_M)),
			      "r"(BATU(0x10000000)));
d328 2
a329 3
		__asm__ volatile ("mtdbatl 2,%0; mtdbatu 2,%1"
			      :: "r"(BATL(0x20000000, BAT_M)),
			      "r"(BATU(0x20000000)));
d332 2
a333 3
		__asm__ volatile ("mtdbatl 3,%0; mtdbatu 3,%1"
			      :: "r"(BATL(0x30000000, BAT_M)),
			      "r"(BATU(0x30000000)));
d509 3
a511 2
	__asm__ volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
		      : "=r"(omsr), "=r"(msr) : "K"((u_short)~PSL_EE));
d516 1
a516 1
	__asm__ volatile ("mtmsr %0" :: "r"(omsr));
@


1.51
log
@bus_space_*_raw*_1() do not exist; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2003/06/01 20:19:33 drahn Exp $	*/
a1063 27
}

/*
 * General functions to enable and disable interrupts
 * without having inlined assembly code in many functions,
 * should be moved into a header file for inlining the function
 * so it is faster
 */
void
ppc_intr_enable(int enable)
{
	u_int32_t emsr, dmsr;
	if (enable != 0)  {
		__asm__ volatile("mfmsr %0" : "=r"(emsr));
		dmsr = emsr | PSL_EE;
		__asm__ volatile("mtmsr %0" :: "r"(dmsr));
	}
}

int
ppc_intr_disable(void)
{
	u_int32_t emsr, dmsr;
	__asm__ volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	__asm__ volatile("mtmsr %0" :: "r"(dmsr));
	return (emsr & PSL_EE);
@


1.50
log
@Initialize minaddr to a sane value. at request of art.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2003/04/06 18:54:19 ho Exp $	*/
a1402 1
BUS_SPACE_READ_RAW_MULTI_N(1,0,u_int8_t)
a1426 1
BUS_SPACE_WRITE_RAW_MULTI_N(1,0,u_int8_t)
@


1.49
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2003/02/26 21:54:44 drahn Exp $	*/
d594 1
@


1.48
log
@Remove an unnecessary structure copy from useage of setfault(), call
by reference, not by value, ok matthieu#, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2002/12/17 23:11:32 millert Exp $	*/
d1509 2
a1510 2
	strcat(intrname[replace], "/");
	strcat(intrname[replace], newstr);
@


1.47
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2002/10/18 03:39:35 drahn Exp $	*/
d1477 1
a1477 1
	if (setfault(env)) {
@


1.46
log
@Do not define astpending twice, once non-volatile and one volatile.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2002/10/13 18:26:12 krw Exp $	*/
a56 6
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
a626 11
#ifdef	SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef	SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.45
log
@Remove more '\n's from panic() statements.  From Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2002/09/23 04:25:52 drahn Exp $	*/
a131 1
int astpending;
@


1.44
log
@panic if out of kvm when mapping devices. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2002/09/16 16:06:33 art Exp $	*/
d1067 1
a1067 1
			" configured: driver %s too many interrupts\n", name);
@


1.43
log
@Limit buffer cache size to 35% kvm, not 70.

drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2002/09/15 09:01:58 deraadt Exp $	*/
d1236 3
@


1.42
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2002/09/11 22:29:47 drahn Exp $	*/
d662 3
a664 3
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
d666 1
a666 1
		    MAXBSIZE * 7 / 10;
@


1.41
log
@KNF
@
text
@d252 1
a252 1
	    :: "r"(battable[0].batl), "r"(battable[0].batu));
d255 3
a257 1
	    :: "r"(battable[0].batl), "r"(battable[0].batu));
d318 1
d321 1
d333 2
a334 2
		    :: "r"(BATL(0x10000000, BAT_M)),
		    "r"(BATU(0x10000000)));
d338 2
a339 2
		    :: "r"(BATL(0x20000000, BAT_M)),
		    "r"(BATU(0x20000000)));
d343 2
a344 2
		    :: "r"(BATL(0x30000000, BAT_M)),
		    "r"(BATU(0x30000000)));
d384 1
a384 1
	    : "=r"(scratch) : "K"(PSL_IR|PSL_DR|PSL_ME|PSL_RI));
d407 3
a409 4
	strncpy(bootpathbuf, args, sizeof bootpathbuf);
	bootpath = &bootpathbuf[0];
	while (*++bootpath && *bootpath != ' ')
		;
d456 2
a457 2
	    (caddr_t)devio_ex_storage, sizeof(devio_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
d496 1
a496 1
	pool_init(&ppc_vecpl, sizeof(struct vreg), 16, 0, 0, "ppcvec", NULL);
d499 1
a499 3

void
ofw_dbg(char *str)
d505 1
d521 1
a521 1
	    : "=r"(omsr), "=r"(msr) : "K"((u_short)~PSL_EE));
d563 3
a565 3
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	    UVM_ADV_NORMAL, 0)))
d588 1
a588 1
				    " buffer cache");
d590 1
a590 1
			    VM_PROT_READ|VM_PROT_WRITE);
d748 5
a752 4
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    !oldonstack && (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size);
d836 2
a837 2
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
d840 1
a840 1
			return (sysctl_int(oldp, oldlenp, newp, newlen,
d859 1
a859 1
/*
d956 1
a956 2
	while (1)
		/* forever */;
d969 4
a972 4
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0 &&
		    !strcmp(name, "network") &&
		    OF_getprop(qhandle, "local-mac-address",
		    &ofw_eth_addr, sizeof ofw_eth_addr) >= 0) {
d1024 3
a1026 2
		if (strncmp(name, systypes[i].name,
		    strlen(systypes[i].name)) == 0) {
d1029 1
a1029 1
			    name, systypes[i].systypename);
d1034 2
a1035 2
		printf("System type %s not recognized, good luck\n",
		    name);
d1067 1
a1067 1
		    " configured: driver %s too many interrupts\n", name);
d1127 2
a1128 1
	    (ppc_malloc_ok ? EX_MALLOCOK : 0)))) {
d1139 2
a1140 1
		    (ppc_malloc_ok ? EX_MALLOCOK : 0))) {
d1142 1
a1142 1
			    bpa, size);
d1149 1
a1149 1
    bus_size_t size);
d1151 1
a1151 2
    bus_size_t size);

d1181 2
a1182 1
		    (ppc_malloc_ok ? EX_MALLOCOK : 0))) {
d1184 1
a1184 1
			    bpa, size);
d1190 2
a1191 1
	    ((sva >= VM_MIN_KERNEL_ADDRESS) && (sva < VM_MAX_KERNEL_ADDRESS))) {
d1244 2
a1245 2
		    VM_PROT_READ | VM_PROT_WRITE,
		    cacheable ? PMAP_CACHE_WT : PMAP_CACHE_DEFAULT);
@


1.40
log
@When freeing the extent, include the page offset, not just the page
base. This is important when allocating/freeing sub page size mappings.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2002/09/06 13:42:17 drahn Exp $	*/
d252 1
a252 1
		      :: "r"(battable[0].batl), "r"(battable[0].batu));
d255 1
a255 3
		      :: "r"(battable[0].batl), "r"(battable[0].batu));


a315 1

a317 1

d329 2
a330 2
			      :: "r"(BATL(0x10000000, BAT_M)),
			      "r"(BATU(0x10000000)));
d334 2
a335 2
			      :: "r"(BATL(0x20000000, BAT_M)),
			      "r"(BATU(0x20000000)));
d339 2
a340 2
			      :: "r"(BATL(0x30000000, BAT_M)),
			      "r"(BATU(0x30000000)));
d380 1
a380 1
		      : "=r"(scratch) : "K"(PSL_IR|PSL_DR|PSL_ME|PSL_RI));
d403 4
a406 3
	strncpy(bootpathbuf, args, 512);
	bootpath= &bootpathbuf[0];
	while ( *++bootpath && *bootpath != ' ');
d453 2
a454 2
		(caddr_t)devio_ex_storage, sizeof(devio_ex_storage),
		EX_NOCOALESCE|EX_NOWAIT);
d493 1
a493 1
        pool_init(&ppc_vecpl, sizeof(struct vreg), 16, 0, 0, "ppcvec", NULL);
d496 3
a498 1
void ofw_dbg(char *str)
a503 1

d519 1
a519 1
		      : "=r"(omsr), "=r"(msr) : "K"((u_short)~PSL_EE));
d561 3
a563 3
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
d586 1
a586 1
					" buffer cache");
d588 1
a588 1
					VM_PROT_READ|VM_PROT_WRITE);
d746 4
a749 5
	if ((psp->ps_flags & SAS_ALTSTACK)
	    && !oldonstack
	    && (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp
					 + psp->ps_sigstk.ss_size);
d833 2
a834 2
		if (securelevel > 0) 
			return (sysctl_rdint(oldp, oldlenp, newp, 
d837 1
a837 1
			return (sysctl_int(oldp, oldlenp, newp, newlen, 
d856 1
a856 1
/* 
d953 2
a954 1
	while(1) /* forever */;
d967 4
a970 4
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
		    && !strcmp(name, "network")
		    && OF_getprop(qhandle, "local-mac-address",
				  &ofw_eth_addr, sizeof ofw_eth_addr) >= 0) {
d1022 2
a1023 3
		if (strncmp( name , systypes[i].name,
			strlen (systypes[i].name)) == 0)
		{
d1026 1
a1026 1
				name, systypes[i].systypename);
d1031 2
a1032 2
		printf("System type %snot recognized, good luck\n",
			name);
d1064 1
a1064 1
			" configured: driver %s too many interrupts\n", name);
d1124 1
a1124 2
		(ppc_malloc_ok ? EX_MALLOCOK : 0))))
	{
d1135 1
a1135 2
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
d1137 1
a1137 1
				bpa, size);
d1144 1
a1144 1
			  bus_size_t size);
d1146 2
a1147 1
			  bus_size_t size);
d1177 1
a1177 2
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
d1179 1
a1179 1
				bpa, size);
d1185 1
a1185 2
	  ((sva >= VM_MIN_KERNEL_ADDRESS) && (sva < VM_MAX_KERNEL_ADDRESS)) )
	{
d1238 2
a1239 2
			VM_PROT_READ | VM_PROT_WRITE,
			cacheable ? PMAP_CACHE_WT : PMAP_CACHE_DEFAULT);
@


1.39
log
@allow mapiodev to steal KVM addresses for early mappings like
bus_mem_add_mappings. Fix calculation error in bus_mem_add_mappings
where it used the size instead of the size + offset, could
cause the allocation to be one page short in some situations.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2002/08/20 02:50:43 drahn Exp $	*/
d1180 1
a1180 1
		if (extent_free(devio_ex, bpa, size, EX_NOWAIT |
@


1.38
log
@Add a pseudo openfirmware console device for early debugging purposes
and to allow UKC to work properly. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2002/07/23 17:53:24 drahn Exp $	*/
d1227 1
a1227 1
		alloc_size = round_page(size);
d1293 10
a1302 1
	va = vaddr = uvm_km_valloc(phys_map, size);
d1307 1
a1307 1
	for (; size > 0; size -= PAGE_SIZE) {
@


1.37
log
@Cardbus/pcmcia support for macppc. parts borrowed from NetBSD, and other
portions of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2002/07/20 19:24:56 art Exp $	*/
a69 4
#include <dev/ofw/openfirm.h>

#include <dev/pci/pcivar.h>

d79 5
d462 1
a462 1
	consinit();
a473 1
	cninit();
d475 1
@


1.36
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2002/06/07 21:54:25 drahn Exp $	*/
d1171 1
d1178 9
d1192 3
a1195 12
#if 0
	pmap_extract(pmap_kernel(), sva, &bpa);
	if (extent_free(devio_ex, bpa, size, EX_NOWAIT |
		(ppc_malloc_ok ? EX_MALLOCOK : 0)))
	{
		printf("bus_space_map: pa 0x%x, size 0x%x\n",
			bpa, size);
		printf("bus_space_map: can't free region\n");
	}
#endif
	pmap_remove(vm_map_pmap(phys_map), sva, sva+len);
	pmap_update(pmap_kernel());
@


1.35
log
@Fix DDB build problem, minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2002/03/27 15:09:24 jason Exp $	*/
d777 1
a777 2
	tf->srr0 = (int)(((char *)PS_STRINGS)
			 - (p->p_emul->e_esigcode - p->p_emul->e_sigcode));
@


1.34
log
@knf (case labels align with switch)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2002/03/23 13:28:34 espie Exp $	*/
d205 1
d207 1
a430 5
#if 0
	bcopy(args +strlen(args) + 1, &startsym, sizeof(startsym));
	bcopy(args +strlen(args) + 5, &endsym, sizeof(endsym));
	ddb_init((int)((u_int)endsym - (u_int)startsym), startsym, endsym);
#endif
a905 3
#if 0
	char *what;
#endif
@


1.33
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2002/03/21 03:02:32 drahn Exp $	*/
d837 1
a837 1
		case CPU_ALLOWAPERTURE:
@


1.32
log
@Map up to 1G 1-1 using dbats, this disables dynamically swapped bats for now,
until the issue with SR invalidation/loading is corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2002/03/14 23:51:47 drahn Exp $	*/
d637 3
@


1.31
log
@Improved altivec support for powerpc/macppc.
Fix bug where altivec context was not freed on process exit.
Fix bug where vscr was not correctly saved/restored.
replace asm statement was macros which expand to the same
asm code or to .long XXX which evaluates to the same instruction
since in-tree gas does not support altivec.
Enable ALTIVEC support by default on macppc, still conditional
for other powerpc ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2002/03/14 03:15:56 millert Exp $	*/
d254 2
d327 17
d373 1
@


1.30
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2002/03/14 01:26:36 millert Exp $	*/
a103 1
#ifdef PPC_VECTOR_SUPPORTED
a104 1
#endif /* PPC_VECTOR_SUPPORTED */
a477 1
#ifdef PPC_VECTOR_SUPPORTED
a478 1
#endif /* PPC_VECTOR_SUPPORTED */
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2002/03/13 18:27:36 drahn Exp $	*/
d171 2
a172 2
void *ppc_intr_establish __P((void *lcv, pci_intr_handle_t ih, int type,
    int level, int (*func)(void *), void *arg, char *name));
d693 1
a693 1
	copyin ((void*)(VM_MAX_ADDRESS-0x10), &args, 0x10);
d1290 1
a1290 1
	return (void*) (va+off);
@


1.28
log
@Complete rewrite of the powerpc pmap handling, Instead of keeping
the spill list for each PTEG, the V->P translations are stored in
trees for each pmap. All valid kernel mappings are preallocated
in 1-1 memory so that tlb spill/loads for kernel accesses can be
looked up while physical, user mappings are not guaranteed to
be 1-1 mapped, thus the kernel must go virtual to look up user
mappings. While this is more expensive, the tree search is much
lower cost than the long linked list search. Also on each pmap_remove()
it was necessary to search the linked lists for each possible mapping,
now it just looks up the entry in the tree.
This change gives a 25-36% speedup in 'make build' time. What was
around 2:50 is now around 1:55 on a 733MHz G4.

This change causes a likely existing bug to appear quite often,
it deals with the segment register invalidation in kernel mode.
Because of that problem, currently this change limits the physical
memory used to 256MB. This limitation will be fixed soon, it is not
an error in the pmap code.

 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2002/03/08 02:52:36 drahn Exp $	*/
d163 8
a170 8
caddr_t allocsys __P((caddr_t));
void dumpsys __P((void));
void systype __P((char *name));
int lcsplx __P((int ipl));	/* called from LCore */
int power4e_get_eth_addr __P((void));
void nameinterrupt __P((int replace, char *newstr));
void ppc_intr_setup __P((intr_establish_t *establish,
    intr_disestablish_t *disestablish));
d172 3
a174 3
    int level, int (*func) __P((void *)), void *arg, char *name));
int bus_mem_add_mapping __P((bus_addr_t bpa, bus_size_t size, int cacheable,
    bus_space_handle_t *bshp));
d211 2
a212 2
	extern void consinit __P((void));
	extern void callback __P((void *));
d494 1
a494 1
	void (*handler) __P((void));
d496 2
a497 2
	void extint __P((void));
	void extsize __P((void));
d1041 1
a1041 1
	int (*func) __P((void *));
d1135 4
a1138 4
bus_addr_t bus_space_unmap_p __P((bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size));
void bus_space_unmap __P((bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size));
@


1.27
log
@Move the message buffer out of low memory, Openfirmware clears the area
on reboot. perhaps OF uses it at other times?
Since OF always use the same memory addresses, this should always allocate
the same ram to the msgbuf, and allow it to be preserved across reboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2002/02/23 16:59:36 matthieu Exp $	*/
a242 10
#if 0
	battable[0x8].batl = BATL(0x80000000, BAT_I);
	battable[0x8].batu = BATU(0x80000000);
	battable[0x9].batl = BATL(0x90000000, BAT_I);
	battable[0x9].batu = BATU(0x90000000);
	battable[0xa].batl = BATL(0xa0000000, BAT_I);
	battable[0xa].batu = BATU(0xa0000000);
	segment8_a_mapped = 1;
#endif

a255 6
#if 0
	__asm__ volatile ("mtdbatl 1,%0; mtdbatu 1,%1"
		      :: "r"(battable[1].batl), "r"(battable[1].batu));
	__asm__ volatile ("sync;isync");
#endif

d269 1
a269 1
#if 1
a278 1
#endif
d307 1
@


1.26
log
@Add aperture driver support for macppc, and also place writing to /dev/pci
under the control of machdep.allowaperture.
This allows to run the X server on macppc with securelevel=1, given that
machdep.allowaperture is != 0.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2002/02/17 22:59:52 maja Exp $	*/
d213 1
a218 6
	/*
	 * XXX We use the page just above the interrupt vector as
	 * message buffer
	 */
	initmsgbuf((void *)0x3000, MSGBUFSIZE);

d380 5
@


1.25
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2002/01/23 17:51:52 art Exp $	*/
d153 8
d834 11
@


1.24
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2002/01/23 17:35:56 art Exp $	*/
d116 5
d126 1
a642 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
d647 1
a647 1
		bufpages = physmem * BUFCACHEPERCENT / 100;
@


1.23
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2002/01/23 00:39:47 art Exp $	*/
a597 3

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.22
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2002/01/16 20:50:16 miod Exp $	*/
a124 1
struct vm_map *mb_map = NULL;
@


1.21
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2002/01/14 01:56:50 drahn Exp $	*/
d484 1
a484 2
        pool_init(&ppc_vecpl, sizeof(struct vreg), 16, 0, 0, "ppcvec",
		    0, NULL, NULL, M_SUBPROC);
@


1.20
log
@The return value of lcsplx is used in locore. however at some point
the function was changed to be void. return the cpl value at the
time the function is called as locore.S expects.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2002/01/07 05:31:27 drahn Exp $	*/
a42 1
#include <sys/map.h>
@


1.19
log
@Paranoia on my part, do not let the condition exist where kvm space could
be claimed by the pre kvm init stealing process and kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2001/12/08 02:24:06 art Exp $	*/
d154 1
a154 1
void lcsplx __P((int ipl));	/* called from LCore */
d873 1
a873 1
void
d877 3
d881 1
@


1.18
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2001/11/28 16:13:28 art Exp $	*/
d1161 1
a1164 1
		/* do not free memory which was stolen from the vm system */
d1181 2
a1209 1
		ppc_kvm_size -= alloc_size;
d1211 5
a1215 1
		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_size;
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2002/01/23 17:51:52 art Exp $	*/
d43 1
d126 1
d154 1
a154 1
int lcsplx __P((int ipl));	/* called from LCore */
d485 2
a486 1
        pool_init(&ppc_vecpl, sizeof(struct vreg), 16, 0, 0, "ppcvec", NULL);
d602 3
d873 1
a873 1
int
a876 3
	int oldcpl;

	oldcpl = cpl;
a877 1
	return oldcpl;
a1160 1
	/* do not free memory which was stolen from the vm system */
d1164 1
a1180 2
vm_offset_t ppc_kvm_stolen = VM_KERN_ADDRESS_SIZE;

d1208 1
d1210 1
a1210 5
		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += alloc_size;
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
@


1.18.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18.2.1 2002/01/31 22:55:14 niklas Exp $	*/
d104 1
d106 1
a115 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a120 1
int bufcachepercent = BUFCACHEPERCENT;
a146 8
#ifdef APERTURE
#ifdef INSECURE
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif

d149 12
a160 12
caddr_t allocsys(caddr_t);
void dumpsys(void);
void systype(char *name);
int lcsplx(int ipl);	/* called from LCore */
int power4e_get_eth_addr(void);
void nameinterrupt(int replace, char *newstr);
void ppc_intr_setup(intr_establish_t *establish,
    intr_disestablish_t *disestablish);
void *ppc_intr_establish(void *lcv, pci_intr_handle_t ih, int type,
    int level, int (*func)(void *), void *arg, char *name);
int bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
    bus_space_handle_t *bshp);
a192 1
#ifdef DDB
a193 1
#endif
d197 2
a198 3
	extern void consinit(void);
	extern void callback(void *);
	extern void *msgbuf_addr;
d204 6
d234 10
d257 5
a261 1

d276 1
a276 1

d286 1
a314 1

a333 17
	/* use BATs to map 1GB memory, no pageable BATs now */
	if (physmem > btoc(0x10000000)) {
		__asm__ volatile ("mtdbatl 1,%0; mtdbatu 1,%1"
			      :: "r"(BATL(0x10000000, BAT_M)),
			      "r"(BATU(0x10000000)));
	}
	if (physmem > btoc(0x20000000)) {
		__asm__ volatile ("mtdbatl 2,%0; mtdbatu 2,%1"
			      :: "r"(BATL(0x20000000, BAT_M)),
			      "r"(BATU(0x20000000)));
	}
	if (physmem > btoc(0x30000000)) {
		__asm__ volatile ("mtdbatl 3,%0; mtdbatu 3,%1"
			      :: "r"(BATL(0x30000000, BAT_M)),
			      "r"(BATU(0x30000000)));
	}
#if 0
a362 1
#endif
a372 5
	 * use the memory provided by pmap_bootstrap for message buffer
	 */
	initmsgbuf(msgbuf_addr, MSGBUFSIZE);

	/*
d413 5
d482 1
d484 1
d496 1
a496 1
	void (*handler)(void);
d498 2
a499 2
	void extint(void);
	void extsize(void);
a622 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d637 3
d644 1
a644 1
		bufpages = physmem * bufcachepercent / 100;
d698 1
a698 1
	copyin ((void *)(VM_MAX_ADDRESS-0x10), &args, 0x10);
a822 11
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0) 
			return (sysctl_rdint(oldp, oldlenp, newp, 
			    allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen, 
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
d884 3
d1035 1
a1035 1
	int (*func)(void *);
d1129 4
a1132 4
bus_addr_t bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
d1284 1
a1284 1
	return (void *) (va+off);
@


1.18.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18.2.2 2002/06/11 03:36:34 art Exp $	*/
d70 4
a82 5
#include <dev/pci/pcivar.h>

#include <arch/macppc/macppc/ofw_machdep.h>
#include <dev/ofw/openfirm.h>

d131 1
d461 1
a461 1
	ofwconsinit();
d473 1
a474 1
	consinit();
d661 3
a663 3
	/* Restrict to at most 35% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100)
d665 1
a665 1
		    MAXBSIZE * 35 / 100;
d777 2
a778 1
	tf->srr0 = p->p_sigcode;
d1067 1
a1067 1
			" configured: driver %s too many interrupts", name);
a1171 1
	bus_addr_t bpa;
a1177 9
	if (pmap_extract(pmap_kernel(), sva, &bpa) == TRUE) {
		if (extent_free(devio_ex, bpa | (bsh & PAGE_MASK), size, EX_NOWAIT |
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
			printf("bus_space_map: pa 0x%x, size 0x%x\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}
a1182 3
	} else {
		pmap_remove(vm_map_pmap(phys_map), sva, sva+len);
		pmap_update(pmap_kernel());
d1184 12
d1226 1
a1226 1
		alloc_size = round_page(len);
a1234 3
		if (vaddr == 0)
			panic("bus_mem_add_mapping: kvm alloc of 0x%x failed",
			    len);
d1292 1
a1292 10
	if (ppc_malloc_ok == 0) {
		/* need to steal vm space before kernel vm is initialized */
		va = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += size;
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
	} else {
		va = uvm_km_valloc_wait(phys_map, size);
	}
d1297 1
a1297 1
	for (vaddr = va; size > 0; size -= PAGE_SIZE) {
@


1.18.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 6
d633 11
d1494 1
a1494 1
	if (setfault(&env)) {
d1526 2
a1527 2
	strlcat(intrname[replace], "/", sizeof intrname[replace]);
	strlcat(intrname[replace], newstr, sizeof intrname[replace]);
@


1.17
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2001/11/28 13:47:38 art Exp $	*/
d586 1
d1178 1
d1305 1
a1305 1
	return;
@


1.16
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2001/11/19 00:48:01 drahn Exp $	*/
d125 3
a127 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.15
log
@Use netisr_dispatch instead of handcoded list.
In this instance it actually is completely identical,
but had ATM been added, or something else added to netisr_dispatch,
this would have been incorrect. Currently generated asm code is identical.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2001/11/13 14:31:52 drahn Exp $	*/
d556 1
a556 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.14
log
@Add AltiVec support to powerpc/macppc. This is not currently enabled because
the 'as' in openbsd source tree does not yet support altivec instructions.
The pieces to enable it have been put in macppc/conf/GENERIC and
macppc/conf/Makefile.macppc in comments.
Once 'as' is updated the kernel option should be removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2001/11/09 15:25:55 art Exp $	*/
d865 5
a869 43
#ifdef	INET
#include "ether.h"
#if NETHER > 0
	if (isr & (1 << NETISR_ARP))
		arpintr();
#endif
	if (isr & (1 << NETISR_IP))
		ipintr();
#endif
#ifdef INET6
	if (isr & (1 << NETISR_IPV6))
		ip6intr();
#endif
#ifdef NETATALK
	if (isr & (1 << NETISR_ATALK))
		atintr();
#endif
#ifdef	IMP
	if (isr & (1 << NETISR_IMP))
		impintr();
#endif
#ifdef	NS
	if (isr & (1 << NETISR_NS))
		nsintr();
#endif
#ifdef	ISO
	if (isr & (1 << NETISR_ISO))
		clnlintr();
#endif
#ifdef	CCITT
	if (isr & (1 << NETISR_CCITT))
		ccittintr();
#endif
#include "ppp.h"
#if NPPP > 0
	if (isr & (1 << NETISR_PPP))
		pppintr();
#endif
#include "bridge.h"
#if NBRIDGE > 0
	if (isr & (1 << NETISR_BRIDGE))
		bridgeintr();
#endif
@


1.13
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2001/11/07 01:18:00 art Exp $	*/
d105 3
d483 5
@


1.12
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2001/11/06 19:53:15 miod Exp $	*/
a108 1
int	nswbuf = 0;
a656 5
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) & ~1;
		if (nswbuf > 256)
			nswbuf = 256;
	}
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2001/11/05 22:26:57 drahn Exp $	*/
d547 1
a547 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.10
log
@Workaround to prevent Altivec Unavilable problem.
Why did Motorola put this exception misaligned with respect to all other
exceptions?
Altivec is not supported. This will cause any process executing altivec
instructions to recieve an illegal instruction signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2001/09/28 04:13:12 drahn Exp $	*/
a55 1
#include <vm/vm.h>
@


1.9
log
@Commit a ugly, widespread change.
Problem: no MI soft interrupts.
Bad solution: use old hack that was never fully implemented
to hook in zs soft interrupts.
This allows zs to work almost reasonably.
Still has issues with getty (carrier detect)
and modems on newer machines (power control).

Post 3.0 this must be cleaned up with real soft interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2001/09/20 13:02:30 drahn Exp $	*/
d267 1
a267 1
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100)
d312 11
@


1.9.2.1
log
@Pull in patch from current:
Workaround to prevent Altivec Unavilable problem.
Why did Motorola put this exception misaligned with respect to all other
exceptions?
Altivec is not supported. This will cause any process executing altivec
instructions to recieve an illegal instruction signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2001/09/28 04:13:12 drahn Exp $	*/
d267 1
a267 1
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100) {
a311 11
	}

	/* Grr, ALTIVEC_UNAVAIL is a vector not ~0xff aligned: 0x0f20 */
	bcopy(&trapcode, (void *)0xf20, (size_t)&trapsize);
	/*
	 * since trapsize is > 0x20, we just overwrote the EXC_PERF handler
	 * since we do not use it, we will "share" it with the EXC_VEC,
	 * we dont support EXC_VEC either.
	 * should be a 'ba 0xf20 written' at address 0xf00, but we
	 * do not generate EXC_PERF exceptions...
	 */
@


1.9.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.9.4.2
log
@Merge in -current
@
text
@d56 1
d110 1
d267 1
a267 1
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100) {
a311 11
	}

	/* Grr, ALTIVEC_UNAVAIL is a vector not ~0xff aligned: 0x0f20 */
	bcopy(&trapcode, (void *)0xf20, (size_t)&trapsize);
	/*
	 * since trapsize is > 0x20, we just overwrote the EXC_PERF handler
	 * since we do not use it, we will "share" it with the EXC_VEC,
	 * we dont support EXC_VEC either.
	 * should be a 'ba 0xf20 written' at address 0xf00, but we
	 * do not generate EXC_PERF exceptions...
	 */
d537 1
a537 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
d648 5
@


1.9.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9.4.2 2001/11/13 21:00:53 niklas Exp $	*/
a104 3
#ifdef PPC_VECTOR_SUPPORTED
struct pool ppc_vecpl;
#endif /* PPC_VECTOR_SUPPORTED */
d122 3
a124 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
a480 5
#ifdef PPC_VECTOR_SUPPORTED
        pool_init(&ppc_vecpl, sizeof(struct vreg), 16, 0, 0, "ppcvec",
		    0, NULL, NULL, M_SUBPROC);
#endif /* PPC_VECTOR_SUPPORTED */

d548 1
a548 1
				UVM_ADV_NORMAL, 0)))
d857 43
a899 5
#define DONETISR(flag, func) \
	if (isr & (1 << flag))\
		func();

#include <net/netisr_dispatch.h>
@


1.9.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a116 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a121 1
int bufcachepercent = BUFCACHEPERCENT;
d126 1
a148 8
#ifdef APERTURE
#ifdef INSECURE
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif

d154 1
a154 1
int lcsplx __P((int ipl));	/* called from LCore */
d485 2
a486 1
        pool_init(&ppc_vecpl, sizeof(struct vreg), 16, 0, 0, "ppcvec", NULL);
a585 1
	pmap_update(pmap_kernel());
d601 3
d642 3
d649 1
a649 1
		bufpages = physmem * bufcachepercent / 100;
a827 11
		case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0) 
			return (sysctl_rdint(oldp, oldlenp, newp, 
			    allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen, 
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
d872 1
a872 1
int
a875 3
	int oldcpl;

	oldcpl = cpl;
a876 1
	return oldcpl;
a1159 1
	/* do not free memory which was stolen from the vm system */
d1163 1
a1176 1
	pmap_update(pmap_kernel());
a1178 2
vm_offset_t ppc_kvm_stolen = VM_KERN_ADDRESS_SIZE;

d1206 1
d1208 1
a1208 5
		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += alloc_size;
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
d1303 1
a1303 1
	pmap_update(pmap_kernel());
@


1.9.4.5
log
@Merge in -current from about a week ago
@
text
@d104 1
d106 1
d163 12
a174 12
caddr_t allocsys(caddr_t);
void dumpsys(void);
void systype(char *name);
int lcsplx(int ipl);	/* called from LCore */
int power4e_get_eth_addr(void);
void nameinterrupt(int replace, char *newstr);
void ppc_intr_setup(intr_establish_t *establish,
    intr_disestablish_t *disestablish);
void *ppc_intr_establish(void *lcv, pci_intr_handle_t ih, int type,
    int level, int (*func)(void *), void *arg, char *name);
int bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
    bus_space_handle_t *bshp);
d211 2
a212 3
	extern void consinit(void);
	extern void callback(void *);
	extern void *msgbuf_addr;
d218 6
d248 10
d271 5
a275 1

d290 1
a290 1

d300 1
a328 1

a347 17
	/* use BATs to map 1GB memory, no pageable BATs now */
	if (physmem > btoc(0x10000000)) {
		__asm__ volatile ("mtdbatl 1,%0; mtdbatu 1,%1"
			      :: "r"(BATL(0x10000000, BAT_M)),
			      "r"(BATU(0x10000000)));
	}
	if (physmem > btoc(0x20000000)) {
		__asm__ volatile ("mtdbatl 2,%0; mtdbatu 2,%1"
			      :: "r"(BATL(0x20000000, BAT_M)),
			      "r"(BATU(0x20000000)));
	}
	if (physmem > btoc(0x30000000)) {
		__asm__ volatile ("mtdbatl 3,%0; mtdbatu 3,%1"
			      :: "r"(BATL(0x30000000, BAT_M)),
			      "r"(BATU(0x30000000)));
	}
#if 0
a376 1
#endif
a386 5
	 * use the memory provided by pmap_bootstrap for message buffer
	 */
	initmsgbuf(msgbuf_addr, MSGBUFSIZE);

	/*
d496 1
d498 1
d510 1
a510 1
	void (*handler)(void);
d512 2
a513 2
	void extint(void);
	void extsize(void);
d709 1
a709 1
	copyin ((void *)(VM_MAX_ADDRESS-0x10), &args, 0x10);
d1057 1
a1057 1
	int (*func)(void *);
d1151 4
a1154 4
bus_addr_t bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
d1306 1
a1306 1
	return (void *) (va+off);
@


1.9.4.6
log
@Sync the SMP branch with 3.3
@
text
@d57 6
d70 4
a82 5
#include <dev/pci/pcivar.h>

#include <arch/macppc/macppc/ofw_machdep.h>
#include <dev/ofw/openfirm.h>

d131 1
a204 1
#ifdef DDB
a205 1
#endif
d429 5
d464 1
a464 1
	ofwconsinit();
d476 1
a477 1
	consinit();
d636 8
d661 3
a663 3
	/* Restrict to at most 35% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100)
d665 1
a665 1
		    MAXBSIZE * 35 / 100;
d777 2
a778 1
	tf->srr0 = p->p_sigcode;
d834 1
a834 1
	case CPU_ALLOWAPERTURE:
d906 3
d1070 1
a1070 1
			" configured: driver %s too many interrupts", name);
a1174 1
	bus_addr_t bpa;
a1180 9
	if (pmap_extract(pmap_kernel(), sva, &bpa) == TRUE) {
		if (extent_free(devio_ex, bpa | (bsh & PAGE_MASK), size, EX_NOWAIT |
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
			printf("bus_space_map: pa 0x%x, size 0x%x\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}
a1185 3
	} else {
		pmap_remove(vm_map_pmap(phys_map), sva, sva+len);
		pmap_update(pmap_kernel());
d1187 12
d1229 1
a1229 1
		alloc_size = round_page(len);
a1237 3
		if (vaddr == 0)
			panic("bus_mem_add_mapping: kvm alloc of 0x%x failed",
			    len);
d1295 1
a1295 10
	if (ppc_malloc_ok == 0) {
		/* need to steal vm space before kernel vm is initialized */
		va = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += size;
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
	} else {
		va = uvm_km_valloc_wait(phys_map, size);
	}
d1300 1
a1300 1
	for (vaddr = va; size > 0; size -= PAGE_SIZE) {
d1485 1
a1485 1
	if (setfault(&env)) {
@


1.9.4.7
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9.4.6 2003/03/27 23:29:46 niklas Exp $	*/
d1509 2
a1510 2
	strlcat(intrname[replace], "/", sizeof intrname[replace]);
	strlcat(intrname[replace], newstr, sizeof intrname[replace]);
@


1.9.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9.4.7 2003/05/13 19:41:05 ho Exp $	*/
a593 1
	minaddr = vm_map_min(kernel_map);
@


1.9.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 3
a166 5
bus_addr_t bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t size);
void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t size);

d181 1
d202 3
d213 1
d222 8
a229 8
	ppc_mtibat0u(0);
	ppc_mtibat1u(0);
	ppc_mtibat2u(0);
	ppc_mtibat3u(0);
	ppc_mtdbat0u(0);
	ppc_mtdbat1u(0);
	ppc_mtdbat2u(0);
	ppc_mtdbat3u(0);
d244 6
a249 2
	ppc_mtibat0l(battable[0].batl);
	ppc_mtibat0u(battable[0].batu);
a250 3
	/* DBAT0 used similar */
	ppc_mtdbat0l(battable[0].batl);
	ppc_mtdbat0u(battable[0].batu);
d292 4
d325 3
a327 2
		ppc_mtdbat1l(BATL(0x10000000, BAT_M));
		ppc_mtdbat1u(BATU(0x10000000));
d330 3
a332 2
		ppc_mtdbat2l(BATL(0x20000000, BAT_M));
		ppc_mtdbat2u(BATU(0x20000000));
d335 3
a337 2
		ppc_mtdbat3l(BATL(0x30000000, BAT_M));
		ppc_mtdbat3u(BATU(0x30000000));
d470 8
d482 1
d500 2
a501 1
install_extint(void (*handler)(void))
d513 2
a514 3
	omsr = ppc_mfmsr();
	msr = omsr & ~PSL_EE;
	ppc_mtmsr(msr);
d519 1
a519 1
	ppc_mtmsr(omsr);
d556 3
a558 2
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
d605 2
a606 2
	printf("avail mem = %ld (%ldK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
d622 2
a623 1
allocsys(caddr_t v)
d679 5
a683 2
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t *retval)
d710 6
a715 2
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
a738 1

d759 1
a759 1
	tf->fixreg[4] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : 0;
d773 4
a776 1
sys_sigreturn(struct proc *p, void *v, register_t *retval)
d804 8
a811 2
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
d819 2
a820 2
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
d823 1
a823 1
			return (sysctl_int(oldp, oldlenp, newp, newlen,
d839 2
a840 2
volatile int cpl, ipending, astpending;
int imask[IPL_NUM];
d842 1
a842 1
/*
a857 2
int netisr;

d862 2
a863 1
softnet(int isr)
d873 2
a874 1
lcsplx(int ipl)
d887 2
a888 1
boot(int howto)
d1032 8
a1039 2
ppc_intr_establish(void *lcv, pci_intr_handle_t ih, int type, int level,
    int (*func)(void *), void *arg, char *name)
d1066 27
d1095 6
a1100 2
bus_space_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size,
    int cacheable, bus_space_handle_t *bshp)
d1110 2
a1111 1
	    (ppc_malloc_ok ? EX_MALLOCOK : 0))))
d1113 1
a1113 1

d1124 1
a1124 1
			printf("bus_space_map: pa 0x%lx, size 0x%x\n",
d1131 4
d1136 4
a1139 1
bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
d1148 4
a1151 1
bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
d1166 1
a1166 1
			printf("bus_space_map: pa 0x%lx, size 0x%x\n",
d1173 2
a1174 1
	    ((sva >= VM_MIN_KERNEL_ADDRESS) && (sva < VM_MAX_KERNEL_ADDRESS)))
d1176 1
a1176 1
	else {
d1185 5
a1189 2
bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
    bus_space_handle_t *bshp)
d1239 7
a1245 3
bus_space_alloc(bus_space_tag_t tag, bus_addr_t rstart, bus_addr_t rend,
    bus_size_t size, bus_size_t alignment, bus_size_t boundary, int cacheable,
    bus_addr_t *addrp, bus_space_handle_t *handlep)
d1252 4
a1255 1
bus_space_free(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t size)
d1262 3
a1264 1
mapiodev(paddr_t pa, psize_t len)
d1302 3
a1304 1
unmapiodev(void *kva, psize_t p_size)
d1337 4
a1340 3
__C(bus_space_copy_,BYTES)(void *v, bus_space_handle_t h1,		\
    bus_size_t o1, bus_space_handle_t h2, bus_size_t o2,		\
    bus_size_t c)							\
d1348 2
a1349 2
	if (h1 == h2 && o2 > o1)					\
		for (i = c-1; i >= 0; i--)				\
d1351 3
a1353 2
	else								\
		for (i = 0; i < c; i++)					\
d1355 2
d1362 15
a1376 11
void
bus_space_set_region_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int8_t val, bus_size_t c)
{
	u_int8_t *dst;
	int i;

	dst = (u_int8_t *) (h+o);

	for (i = 0; i < c; i++)
		dst[i] = val;
d1379 3
a1381 28
void
bus_space_set_region_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int16_t val, bus_size_t c)
{
	u_int16_t *dst;
	int i;

	dst = (u_int16_t *) (h+o);
	if (t->bus_reverse)
		val = swap16(val);

	for (i = 0; i < c; i++)
		dst[i] = val;
}
void
bus_space_set_region_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int32_t val, bus_size_t c)
{
	u_int32_t *dst;
	int i;

	dst = (u_int32_t *) (h+o);
	if (t->bus_reverse)
		val = swap32(val);

	for (i = 0; i < c; i++)
		dst[i] = val;
}
d1385 6
a1390 2
__C(bus_space_read_raw_multi_,BYTES)(bus_space_tag_t bst,		\
    bus_space_handle_t h, bus_addr_t o, u_int8_t *dst, bus_size_t size)	\
d1403 1
d1409 6
a1414 3
__C(bus_space_write_raw_multi_,BYTES)( bus_space_tag_t bst,		\
    bus_space_handle_t h, bus_addr_t o, const u_int8_t *src,		\
    bus_size_t size)							\
d1428 1
d1433 5
a1437 2
bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
d1470 4
a1473 1
kcopy(const void *from, void *to, size_t size)
d1476 1
a1476 1
	void *oldh = curproc->p_addr->u_pcb.pcb_onfault;
d1489 3
a1491 1
nameinterrupt(int replace, char *newstr)
d1500 1
a1500 1
	if (replace >= NENTRIES) {
@


1.8
log
@On a fault the onfault condition should be set to the old handler, not
cleared. This code restored the old handler on normal completion but
not on fault.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2001/09/19 20:50:57 mickey Exp $	*/
d83 1
d829 16
@


1.7
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2001/09/18 13:59:24 drahn Exp $	*/
d1468 1
a1468 1
		curpcb->pcb_onfault = 0;
@


1.6
log
@Changing the way the pmap code works again.
Changes to the pmap_enter code so that the pmap_kenter/pmap_kremove
has a method to create mappings without adding them to the _pv lists
(part of the point of pmap_k* functions). Also adds an interface
so that device mappings can be created with cacheable attributes.
So that devices such as display memory can be mapped writethru
greatly increasing their speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2001/09/15 21:23:52 drahn Exp $	*/
d57 1
a57 1
#include <vm/vm_kern.h>
@


1.5
log
@Two changes here.
Verify that regions which were allocated by stealing are not returned
to phys_map, perhaps before phys_map is initialized. Not seen
to be a problem, but is potentially.

Also, the system can deal with not having the devices mapped with BATs.
In fact after some testing the systems seem more stable when BATs are
not used for devices. Stop using them, at least for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2001/09/12 05:28:42 pvalchev Exp $	*/
d1227 3
a1229 6
#if 0
		pmap_enter(vm_map_pmap(phys_map), vaddr, spa,
#else
		pmap_enter(pmap_kernel(), vaddr, spa,
#endif
			VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED /* XXX */);
d1283 2
a1284 6
#if 0
		pmap_enter(vm_map_pmap(phys_map), vaddr, spa,
#else
		pmap_enter(pmap_kernel(), vaddr, spa,
#endif
			VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED/* XXX */);
@


1.4
log
@Print avail/real memory sizes in KB in addition to bytes as in i386 land. ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2001/09/12 00:23:33 art Exp $	*/
d234 1
d242 1
d1169 6
a1174 1
	uvm_km_free_wakeup(phys_map, sva, len);
@


1.3
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2001/09/11 20:10:00 miod Exp $	*/
d516 1
a516 1
	printf("real mem = %d\n", ctob(physmem));
d584 2
a585 1
	printf("avail mem = %d\n", ptoa(uvmexp.free));
@


1.2
log
@Fix uvm_km_suballoc() usage flags. ok art@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d581 1
a581 1
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2001/08/23 14:01:03 art Exp $	*/
d572 1
a572 1
	    TRUE, FALSE, NULL);
d578 1
a578 1
	    VM_PHYS_SIZE, TRUE, FALSE, NULL);
d582 1
a582 1
	    VM_MBUF_SIZE, FALSE, FALSE, NULL);
@

