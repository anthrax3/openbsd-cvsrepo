head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.12
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.8
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.10
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.3.0.10
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	SMP:1.3.0.8
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	UBC:1.3.0.4
	UBC_SYNC_B:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2013.08.07.07.29.19;	author mpi;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.21.11.45.43;	author mpi;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.22.02.28.37;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.13.09.10.33;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.03.21.30.09;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.09.17.02.56;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.23.03.25.46;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.25.12.35.32;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches
	1.3.4.1
	1.3.8.1;
next	1.2;

1.2
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.23.17.53.24;	author drahn;	state Exp;
branches;
next	;

1.3.4.1
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;

1.3.8.1
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2004.06.05.23.10.52;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Mimic what's done on sparc64 and parse the OpenFirmware device tree to
enumerate the pci devices.  This allow us to not store the interrupt
vector in the interrupt line register and to not try to attach pci
devices disabled by firmware.

With inputs from and ok kettenis@@
@
text
@/*	$OpenBSD: rbus_machdep.c,v 1.12 2013/01/21 11:45:43 mpi Exp $ */
/*	$NetBSD: rbus_machdep.c,v 1.2 1999/10/15 06:43:06 haya Exp $	*/

/*
 * Copyright (c) 1999
 *     HAYAKAWA Koichi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/bus.h>
#include <dev/cardbus/rbus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ofw/openfirm.h>

void macppc_cardbus_init(pci_chipset_tag_t pc, pcitag_t tag);

rbus_tag_t
rbus_pccbb_parent_mem(struct device *self, struct pci_attach_args *pa)
{
	macppc_cardbus_init(pa->pa_pc, pa->pa_tag);

	return (rbus_new_root_share(pa->pa_memt, pa->pa_memex,
	    0x00000000, 0xffffffff));
}

rbus_tag_t
rbus_pccbb_parent_io(struct device *self, struct pci_attach_args *pa)
{
	return (rbus_new_root_share(pa->pa_iot, pa->pa_ioex,
	    0x0000, 0xffff));
}

/*
 * Big ugly hack to enable bridge/fix interrupts
 */
void
macppc_cardbus_init(pci_chipset_tag_t pc, pcitag_t tag)
{
	u_int x;
	static int initted = 0;

	if (initted)
		return;
	initted = 1;

	/* XXX What about other bridges? */

	x = pci_conf_read(pc, tag, PCI_ID_REG);
	if (PCI_VENDOR(x) == PCI_VENDOR_TI &&
	    PCI_PRODUCT(x) == PCI_PRODUCT_TI_PCI1211) {
		/* For CardBus card. */
		pci_conf_write(pc, tag, 0x18, 0x10010100);

		/* Route INTA to MFUNC0 */
		x = pci_conf_read(pc, tag, 0x8c);
		x |= 0x02;
		pci_conf_write(pc, tag, 0x8c, x);

		tag = pci_make_tag(pc, 0, 0, 0);
		x = pci_conf_read(pc, tag, PCI_ID_REG);
		if (PCI_VENDOR(x) == PCI_VENDOR_MOT &&
		    PCI_PRODUCT(x) == PCI_PRODUCT_MOT_MPC106) {
			/* Set subordinate bus number to 1. */
			x = pci_conf_read(pc, tag, 0x40);
			x |= 1 << 8;
			pci_conf_write(pc, tag, 0x40, x);
		}
	}

	if (PCI_VENDOR(x) == PCI_VENDOR_TI &&
	    (PCI_PRODUCT(x) == PCI_PRODUCT_TI_PCI1410 ||
	    PCI_PRODUCT(x) == PCI_PRODUCT_TI_PCI1510)) {
		/* dont mess with the bus numbers or latency timer */

		/* Route INTA to MFUNC0 */
		x = pci_conf_read(pc, tag, 0x8c);
		x |= 0x02;
		pci_conf_write(pc, tag, 0x8c, x);
	}
}

void
pccbb_attach_hook(struct device *parent, struct device *self,
    struct pci_attach_args *pa)
{
	pci_chipset_tag_t pc = pa->pa_pc;
	int node = PCITAG_NODE(pa->pa_tag);
	int bus, busrange[2];

	if (OF_getprop(OF_parent(node), "bus-range", &busrange,
	    sizeof(busrange)) != sizeof(busrange))
		return;

	bus = busrange[0] + 1;
	while (bus < 256 && pc->busnode[bus])
		bus++;
	if (bus == 256)
		return;
	pc->busnode[bus] = node;
}
@


1.12
log
@No need to include pcibrvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.11 2010/09/22 02:28:37 jsg Exp $ */
a30 6
#include <sys/extent.h>
#include <sys/proc.h>
#include <sys/sysctl.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>
a34 1
#include <dev/pci/pcireg.h>
d38 2
d111 14
@


1.11
log
@remove unused offset argument to rbus functions
ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.10 2010/04/21 03:03:26 deraadt Exp $ */
d41 1
d43 1
a43 1
#include <arch/macppc/pci/pcibrvar.h>
@


1.10
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.9 2010/01/13 09:10:33 jsg Exp $ */
d52 1
a52 1
	    0x00000000, 0xffffffff, 0));
d59 1
a59 1
	    0x0000, 0xffff, 0));
@


1.9
log
@As per NetBSD move HAYAKAWA Koichi's licenses to two clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.8 2009/05/03 21:30:09 kettenis Exp $ */
d32 3
a36 4

#include <sys/sysctl.h>

#include <sys/device.h>
@


1.8
log
@Get rid of pci_addr_fixup machinery; set up the appropriate extents and pass
them along when we attach pci(4).  Simplify the rbus code by using extents
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.7 2007/12/09 17:02:56 kettenis Exp $ */
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by HAYAKAWA Koichi.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@Add an empty pccbb_attach_hook.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.6 2004/03/23 03:25:46 drahn Exp $ */
a51 8
/**********************************************************************
 * rbus_tag_t rbus_fakeparent_mem(struct pci_attach_args *pa)
 *
 *   This function makes an rbus tag for memory space.  This rbus tag
 *   shares the all memory region of ex_iomem.
 **********************************************************************/
#define RBUS_MEM_SIZE	0x10000000

a54 4
	bus_addr_t start;
	bus_size_t size;
	struct extent *ex;

d57 2
a58 9
	size = RBUS_MEM_SIZE;
	if ((ex = pciaddr_search(PCIADDR_SEARCH_MEM, self, &start, size)) ==
	    NULL)
	{
		/* XXX */
		printf("failed\n");
	}

	return rbus_new_root_share(pa->pa_memt, ex, start, size, 0);
a60 6

/**********************************************************************
 * rbus_tag_t rbus_pccbb_parent_io(struct pci_attach_args *pa)
 **********************************************************************/
#define RBUS_IO_SIZE	0x1000

d64 2
a65 14
	struct extent *ex;
	bus_addr_t start;
	bus_size_t size;


	size = RBUS_IO_SIZE;
	if ((ex = pciaddr_search(PCIADDR_SEARCH_IO, self, &start, size)) ==
	    NULL)
	{
		/* XXX */
		printf("failed\n");
	}

	return rbus_new_root_share(pa->pa_iot, ex, start, size, 0);
a66 1

@


1.6
log
@Add TI 1510 to recognized list of chips to configure. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.5 2003/10/25 12:35:32 drahn Exp $ */
d153 6
@


1.5
log
@Support the TI1410 Cardbus bridge found in some apple laptops. ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.4 2003/10/15 17:50:16 drahn Exp $ */
d144 2
a145 1
	    PCI_PRODUCT(x) == PCI_PRODUCT_TI_PCI1410) {
@


1.4
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.3 2002/09/15 09:01:58 deraadt Exp $ */
d141 10
@


1.3
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.1 2002/07/23 17:53:24 drahn Exp $ */
d61 1
a61 3
rbus_pccbb_parent_mem(self, pa)
     struct device *self;
     struct pci_attach_args *pa;
d70 2
a71 1
	if ((ex = pciaddr_search(PCIADDR_SEARCH_MEM, self, &start, size)) == NULL)
d87 1
a87 3
rbus_pccbb_parent_io(self, pa)
	struct device *self;
	struct pci_attach_args *pa;
d95 2
a96 1
	if ((ex = pciaddr_search(PCIADDR_SEARCH_IO, self, &start, size)) == NULL)
d110 1
a110 3
macppc_cardbus_init(pc, tag)
	pci_chipset_tag_t pc;
	pcitag_t tag;
@


1.3.8.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d61 3
a63 1
rbus_pccbb_parent_mem(struct device *self, struct pci_attach_args *pa)
d72 1
a72 2
	if ((ex = pciaddr_search(PCIADDR_SEARCH_MEM, self, &start, size)) ==
	    NULL)
d88 3
a90 1
rbus_pccbb_parent_io(struct device *self, struct pci_attach_args *pa)
d98 1
a98 2
	if ((ex = pciaddr_search(PCIADDR_SEARCH_IO, self, &start, size)) ==
	    NULL)
d112 3
a114 1
macppc_cardbus_init(pci_chipset_tag_t pc, pcitag_t tag)
a144 10
	}

	if (PCI_VENDOR(x) == PCI_VENDOR_TI &&
	    PCI_PRODUCT(x) == PCI_PRODUCT_TI_PCI1410) {
		/* dont mess with the bus numbers or latency timer */

		/* Route INTA to MFUNC0 */
		x = pci_conf_read(pc, tag, 0x8c);
		x |= 0x02;
		pci_conf_write(pc, tag, 0x8c, x);
@


1.3.8.2
log
@Merge with the trunk
@
text
@d144 1
a144 2
	    (PCI_PRODUCT(x) == PCI_PRODUCT_TI_PCI1410 ||
	    PCI_PRODUCT(x) == PCI_PRODUCT_TI_PCI1510)) {
@


1.3.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.2
log
@KNF
@
text
@d62 2
a63 2
	struct device *self;
	struct pci_attach_args *pa;
d72 2
a73 2
	if ((ex = pciaddr_search(PCIADDR_SEARCH_MEM, self, &start,
	    size)) == NULL) {
d98 2
a99 2
	if ((ex = pciaddr_search(PCIADDR_SEARCH_IO, self, &start,
	    size)) == NULL) {
d106 1
@


1.1
log
@Cardbus/pcmcia support for macppc. parts borrowed from NetBSD, and other
portions of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.13 2001/11/06 01:43:48 art Exp $ */
d62 2
a63 2
     struct device *self;
     struct pci_attach_args *pa;
d72 2
a73 2
	if ((ex = pciaddr_search(PCIADDR_SEARCH_MEM, self, &start, size)) == NULL)
	{
d98 2
a99 2
	if ((ex = pciaddr_search(PCIADDR_SEARCH_IO, self, &start, size)) == NULL)
	{
a105 1

@

