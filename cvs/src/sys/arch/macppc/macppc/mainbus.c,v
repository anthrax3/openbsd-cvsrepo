head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.21.0.22
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.18
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.16
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.14
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.12
	OPENBSD_5_0:1.21.0.10
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.8
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.6
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2015.09.06.16.46.53;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	75QU6M4QzWmy3G5r;

1.24
date	2015.05.06.02.36.01;	author jsg;	state Exp;
branches;
next	1.23;
commitid	OhKsTS3mq4Ki4434;

1.23
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.22;
commitid	uKVPYMN2MLxdZxzH;

1.22
date	2014.07.02.15.34.43;	author tobiasu;	state Exp;
branches;
next	1.21;
commitid	xhmhuYMz3y3e6cTy;

1.21
date	2009.04.19.17.53.39;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.14.17.29.04;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.03.14.48.53;	author gwk;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.31.08.31.02;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.25.04.13.48;	author gwk;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.12.22.22.39;	author gwk;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.11.06.33.48;	author gwk;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.31.06.14.53;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.19.14.46.00;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.03.19.35.46;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.29.20.17.34;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.30.03.17.32;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.16.05.03.22;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.09.04.13.13;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.21.17.55.39;	author miod;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@seperate a variable into two, so that the size of a free() is remembered.
ok semarie
@
text
@/*	$OpenBSD: mainbus.c,v 1.24 2015/05/06 02:36:01 jsg Exp $	*/

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#include <dev/ofw/openfirm.h>

/* Definition of the mainbus driver. */
static int	mbmatch(struct device *, void *, void *);
static void	mbattach(struct device *, struct device *, void *);
static int	mbprint(void *, const char *);

struct cfattach mainbus_ca = {
	sizeof(struct device), mbmatch, mbattach
};
struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

/* hw.product sysctl see sys/kern/kern_sysctl.c */
extern char *hw_prod, *hw_ver, *hw_vendor;

#define HH_REG_CONF 	0x90

/*ARGSUSED*/
static int
mbmatch(struct device *parent, void *cfdata, void *aux)
{

	/*
	 * That one mainbus is always here.
	 */
	return(1);
}

static void
mbattach(struct device *parent, struct device *self, void *aux)
{
	struct confargs nca;
	char name[64], *t = NULL;
	int reg[4], cpucnt;
	int node, len, tlen;

	node = OF_peer(0);
	len = OF_getprop(node, "model", name, sizeof(name));
	if (len > 1) {
		name[len] = '\0';
		tlen = strlen(name)+1;
		if ((t = malloc(tlen, M_DEVBUF, M_NOWAIT)) != NULL)
			strlcpy(t, name, tlen);

	}

	len = OF_getprop(node, "compatible", name, sizeof(name));
	if (len > 1) {
		name[len] = '\0';
		/* Old World Macintosh */
		if ((strncmp(name, "AAPL", 4)) == 0) {
			size_t plen;

			hw_vendor = "Apple Computer, Inc.";
			plen = strlen(t) + strlen(name) - 3;
			if ((hw_prod = malloc(plen, M_DEVBUF, M_NOWAIT)) != NULL) {
				snprintf(hw_prod, plen, "%s %s", t, name + 5);
				free(t, M_DEVBUF, tlen);
			}
		} else {
			/* New World Macintosh or Unknown */
			hw_vendor = "Apple Computer, Inc.";
			hw_prod = t;
		}
	}
	printf(": model %s\n", hw_prod);

	/*
	 * Try to find and attach all of the CPUs in the machine.
	 */

	cpucnt = 0;
	ncpusfound = 0;
	node = OF_finddevice("/cpus");
	if (node != -1) {
		for (node = OF_child(node); node != 0; node = OF_peer(node)) {
			u_int32_t cpunum;
			int len;
			len = OF_getprop(node, "reg", &cpunum, sizeof cpunum);
			if (len == 4 && cpucnt == cpunum) {
				nca.ca_name = "cpu";
				nca.ca_reg = reg;
				reg[0] = cpucnt;
				config_found(self, &nca, mbprint);
				ncpusfound++;
				cpucnt++;
			}
		}
	}
	if (cpucnt == 0) {
		nca.ca_name = "cpu";
		nca.ca_reg = reg;
		reg[0] = 0;
		ncpusfound++;
		config_found(self, &nca, mbprint);
	}

	/*
	 * Special hack for SMP old world macs which lack /cpus and only have
	 * one cpu node.
	 */
	node = OF_finddevice("/hammerhead");
	if (node != -1) {
		len = OF_getprop(node, "reg", reg, sizeof(reg));
		if (len >= 2) {
			u_char *hh_base;
			int twoway = 0;

			if ((hh_base = mapiodev(reg[0], reg[1])) != NULL) {
				twoway = in32rb(hh_base + HH_REG_CONF) & 0x02;
				unmapiodev(hh_base, reg[1]);
			}
			if (twoway) {
				nca.ca_name = "cpu";
				nca.ca_reg = reg;
				reg[0] = 1;
				ncpusfound++;
				config_found(self, &nca, mbprint);
			}
		}
	}

	for (node = OF_child(OF_peer(0)); node; node=OF_peer(node)) {
		bzero (name, sizeof(name));
		if (OF_getprop(node, "device_type", name, sizeof(name)) <= 0) {
			if (OF_getprop(node, "name", name, sizeof(name)) <= 0) {
				printf ("name not found on node %x\n", node);
				continue;
			}
		}
		if (strcmp(name, "memory") == 0) {
			nca.ca_name = "mem";
			nca.ca_node = node;
			config_found(self, &nca, mbprint);
		}
		if (strcmp(name, "memory-controller") == 0) {
			nca.ca_name = "memc";
			nca.ca_node = node;
			config_found(self, &nca, mbprint);
		}
		if (strcmp(name, "pci") == 0) {
			nca.ca_name = "mpcpcibr";
			nca.ca_node = node;
			config_found(self, &nca, mbprint);
		}
		if (strcmp(name, "ht") == 0) {
			nca.ca_name = "ht";
			nca.ca_node = node;
			config_found(self, &nca, mbprint);
		}
		if (strcmp(name, "smu") == 0) {
			nca.ca_name = "smu";
			nca.ca_node = node;
			config_found(self, &nca, mbprint);
		}
	}
}

static int
mbprint(void *aux, const char *pnp)
{
	struct confargs *ca = aux;
	if (pnp)
		printf("%s at %s", ca->ca_name, pnp);

	return (UNCONF);
}
@


1.24
log
@Add missing braces so this will correctly fall back to the "name"
property of a node if "device_type" is not present.

ok mpi@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.23 2014/07/12 18:44:42 tedu Exp $	*/
d72 1
a72 1
	int node, len, slen;
d78 3
a80 3
		slen = strlen(name)+1;
		if ((t = malloc(slen, M_DEVBUF, M_NOWAIT)) != NULL)
			strlcpy(t, name, slen);
d89 2
d92 4
a95 4
			slen = strlen(t) + strlen(name) - 3;
			if ((hw_prod = malloc(slen, M_DEVBUF, M_NOWAIT)) != NULL) {
				snprintf(hw_prod, slen, "%s %s", t, name + 5);
				free(t, M_DEVBUF, 0);
@


1.23
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.22 2014/07/02 15:34:43 tobiasu Exp $	*/
d160 3
a162 6
		if (OF_getprop(node, "device_type", name,
		    sizeof(name)) <= 0) {
			if (OF_getprop(node, "name", name,
			    sizeof(name)) <= 0)
				printf ("name not found on node %x\n",
				    node);
d164 1
@


1.22
log
@Remove unused mainbus intr hook abstraction.

Theo approves, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.21 2009/04/19 17:53:39 deraadt Exp $	*/
d93 1
a93 1
				free(t, M_DEVBUF);
@


1.21
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.20 2007/10/14 17:29:04 kettenis Exp $	*/
a33 1
#include <sys/reboot.h>
a37 5
struct mainbus_softc {
	struct	device sc_dv;
	struct	bushook sc_bus;
};

d44 1
a44 1
	sizeof(struct mainbus_softc), mbmatch, mbattach
a54 5
void	mb_intr_establish(struct confargs *, int (*)(void *), void *);
void	mb_intr_disestablish(struct confargs *);
caddr_t	mb_cvtaddr(struct confargs *);
int	mb_matchname(struct confargs *, char *);

a68 1
	struct mainbus_softc *sc = (struct mainbus_softc *)self;
a102 6
	sc->sc_bus.bh_dv = (struct device *)sc;
	sc->sc_bus.bh_type = BUS_MAIN;
	sc->sc_bus.bh_intr_establish = mb_intr_establish;
	sc->sc_bus.bh_intr_disestablish = mb_intr_disestablish;
	sc->sc_bus.bh_matchname = mb_matchname;

a116 1
				nca.ca_bus = &sc->sc_bus;
a126 1
		nca.ca_bus = &sc->sc_bus;
a149 1
				nca.ca_bus = &sc->sc_bus;
a170 1
			nca.ca_bus = &sc->sc_bus;
a175 1
			nca.ca_bus = &sc->sc_bus;
a180 1
			nca.ca_bus = &sc->sc_bus;
a185 1
			nca.ca_bus = &sc->sc_bus;
a190 1
			nca.ca_bus = &sc->sc_bus;
a203 24
}

void
mb_intr_establish(struct confargs *ca, int (*handler)(void *), void *val)
{
	panic("can never mb_intr_establish");
}

void
mb_intr_disestablish(struct confargs *ca)
{
	panic("can never mb_intr_disestablish");
}

caddr_t
mb_cvtaddr(struct confargs *ca)
{
	return (NULL);
}

int
mb_matchname(struct confargs *ca, char *name)
{
	return (strcmp(name, ca->ca_name) == 0);
@


1.20
log
@Provide a way to attach spdmem(4) by faking an I2C bus with EEPROMs with
contents from OpenFirmware.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.19 2007/04/03 14:48:53 gwk Exp $	*/
d126 1
d139 1
d149 1
d173 1
@


1.19
log
@A fix for smp old world macs such as the 9500MP and 9600MP which lack the
/cpus openfirmware node of the new world macs, and only have one cpu node.
We look at a register of the memory controller called hammerhead for the
arbitration bit being set indicating a two way machine. Quad processor
old worlds made by e.g. Daystar Digital would require a different heurisitic.
This heuristic comes from linux/netbsd.

ok kettenis@@ and drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.18 2007/03/31 08:31:02 kettenis Exp $	*/
d184 6
@


1.18
log
@Detect secondary cpu's.  Get rid of legacy ofroot code.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.17 2007/02/25 04:13:48 gwk Exp $	*/
d59 2
d148 25
@


1.17
log
@Change how we determin if were running on a new world versus old world
machine for the purposes of printing model information durring boot and
the hw.vendor/product sysctls. Turns out the apple didnt use the same
format in the early imacs as they did in the latter new world machines
resulting in NULL strings as found by drahn@@.  In this case and all future
cases where we dont understand the format the default is to print whats
found in the name property without interpertation.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.16 2007/02/12 22:22:39 gwk Exp $	*/
d81 1
a120 1
	 * ( Right now only one CPU so code is simple )
d123 19
a141 7
	nca.ca_name = "cpu";
	nca.ca_bus = &sc->sc_bus;
	config_found(self, &nca, mbprint);

	/* Set up Openfirmware.*/
	{ /* legacy? */
		nca.ca_name = "ofroot";
d143 2
d188 1
d190 2
a191 1
		return (QUIET);
@


1.16
log
@Cope with the different format of the name property of the root device in
the openfirmware tree as found in old world macs. Also utilize the
compatible property to print nice model information in the dmesg
and the sysctl hw.vendor/product fields.

mainbus0 (root): model Power Macintosh 9500
hw.vendor=Apple Computer, Inc.
hw.product=Power Macintosh 9500
Note this is from a 9600, this information will reflect the architecture in
this case both the 9500 and 9600 are from tsunami architecture and differ
only in the processor daughtercard.

Tested by myself and martin@@ on old world machines, and by martin@@ on
a new world.

ok martin@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.15 2006/07/11 06:33:48 gwk Exp $	*/
d96 10
a105 2
		if ((strncmp(t, name, strlen(t))) == 0) {
			/* New World Macintosh */
a107 13
		} else {
			/* Old World Macintosh */
			if ((strncmp(name, "AAPL", 4)) == 0) {
				hw_vendor = "Apple Computer, Inc.";
				slen = strlen(t) + strlen(name) - 3;
				if ((hw_prod = malloc(slen, M_DEVBUF,
				    M_NOWAIT)) != NULL) {
					snprintf(hw_prod, slen, "%s %s", t,
					    name + 5);
					free(t, M_DEVBUF);
				}
			}

@


1.15
log
@Hook up the hw.product sysctl on macppc,
requested by deraadt@@, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14 2005/10/31 06:14:53 drahn Exp $	*/
d57 1
a57 1
extern char *hw_prod;
d80 2
a81 2
	char name[64];
	int node, len;
d87 4
a90 4
		printf(": model %s", name);
		len = strlen(name)+1;
		if ((hw_prod = malloc(len, M_DEVBUF, M_NOWAIT)) != NULL)
			strlcpy(hw_prod, name, len);	
d93 23
a115 1
	printf("\n");
@


1.14
log
@print something useful about mainbus, system model as reported by Openfirmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.13 2005/10/19 14:46:00 kettenis Exp $	*/
d33 1
d56 3
d88 3
@


1.13
log
@Add smu(4).
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.12 2005/10/03 19:35:46 drahn Exp $	*/
d76 9
a84 2
	char name[32];
	int node;
@


1.12
log
@system_type is apple, dont act like it is any other, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.11 2005/09/29 20:17:34 kettenis Exp $	*/
d127 6
@


1.11
log
@Configure ht if found.
"there is some stuff here that needs no ok's!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.10 2003/10/30 03:17:32 itojun Exp $	*/
d76 2
a77 1
	extern int system_type;
d97 1
a97 1
	if (system_type != POWER4e) { /* for now */
d103 27
a129 40
	/* The following machines have an ISA bus */
	/* Do ISA first so the interrupt controller is set up! */
	if (system_type == POWER4e) {
		nca.ca_name = "isabr";
		nca.ca_bus = &sc->sc_bus;
		config_found(self, &nca, mbprint);
	}

	/* The following machines have a PCI bus */
	if (system_type == APPL) {
		char name[32];
		int node;
		for (node = OF_child(OF_peer(0)); node; node=OF_peer(node)) {
			bzero (name, sizeof(name));
			if (OF_getprop(node, "device_type", name,
			    sizeof(name)) <= 0) {
				if (OF_getprop(node, "name", name,
				    sizeof(name)) <= 0)
					printf ("name not found on node %x\n",
					    node);
					continue;
			}
			if (strcmp(name, "memory-controller") == 0) {
				nca.ca_name = "memc";
				nca.ca_node = node;
				nca.ca_bus = &sc->sc_bus;
				config_found(self, &nca, mbprint);
			}
			if (strcmp(name, "pci") == 0) {
				nca.ca_name = "mpcpcibr";
				nca.ca_node = node;
				nca.ca_bus = &sc->sc_bus;
				config_found(self, &nca, mbprint);
			}
			if (strcmp(name, "ht") == 0) {
				nca.ca_name = "ht";
				nca.ca_node = node;
				nca.ca_bus = &sc->sc_bus;
				config_found(self, &nca, mbprint);
			}
a130 5
	} else if (system_type != OFWMACH) {
		nca.ca_name = "mpcpcibr";
		nca.ca_bus = &sc->sc_bus;
		nca.ca_node = OF_finddevice("/pci");
		config_found(self, &nca, mbprint);
@


1.10
log
@simplify cfdriver initialization.  drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.9 2003/10/16 05:03:22 deraadt Exp $	*/
d132 6
@


1.9
log
@more white
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.8 2003/10/15 17:50:16 drahn Exp $	*/
d52 1
a52 1
	NULL, "mainbus", DV_DULL, NULL, 0
@


1.8
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.7 2002/09/15 09:01:58 deraadt Exp $	*/
d8 1
a8 1
 * 
d14 3
a16 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d18 1
a18 1
 * 
d100 1
a100 2
	} 

d135 1
a135 2
			} 

@


1.7
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.5 2002/06/09 04:13:13 drahn Exp $	*/
d62 1
a62 4
mbmatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
d72 1
a72 4
mbattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d148 1
a148 3
mbprint(aux, pnp)
	void *aux;
	const char *pnp;
d156 1
a156 4
mb_intr_establish(ca, handler, val)
	struct confargs *ca;
	int (*handler)(void *);
	void *val;
d162 1
a162 2
mb_intr_disestablish(ca)
	struct confargs *ca;
d168 1
a168 2
mb_cvtaddr(ca)
	struct confargs *ca;
a169 1

d174 1
a174 3
mb_matchname(ca, name)
	struct confargs *ca;
	char *name;
@


1.6
log
@KNF
@
text
@d127 1
a127 1
					printf("name not found on node %x\n",
@


1.5
log
@knf/cleanup/dead code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.4 2002/03/14 03:15:56 millert Exp $	*/
d127 1
a127 1
					printf ("name not found on node %x\n",
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.3 2002/03/14 01:26:36 millert Exp $	*/
d123 4
a126 3
			if (OF_getprop(node, "device_type", name, sizeof(name)) <= 0)
			{
				if (OF_getprop(node, "name", name, sizeof(name)) <= 0)
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 2001/09/21 17:55:39 miod Exp $	*/
d55 1
a55 1
void	mb_intr_establish __P((struct confargs *, int (*)(void *), void *));
@


1.2
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d44 3
a46 3
static int	mbmatch __P((struct device *, void *, void *));
static void	mbattach __P((struct device *, struct device *, void *));
static int	mbprint __P((void *, const char *));
d56 3
a58 3
void	mb_intr_disestablish __P((struct confargs *));
caddr_t	mb_cvtaddr __P((struct confargs *));
int	mb_matchname __P((struct confargs *, char *));
d165 1
a165 1
	int (*handler) __P((void *));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 2001/09/21 17:55:39 miod Exp $	*/
d44 3
a46 3
static int	mbmatch(struct device *, void *, void *);
static void	mbattach(struct device *, struct device *, void *);
static int	mbprint(void *, const char *);
d55 4
a58 4
void	mb_intr_establish(struct confargs *, int (*)(void *), void *);
void	mb_intr_disestablish(struct confargs *);
caddr_t	mb_cvtaddr(struct confargs *);
int	mb_matchname(struct confargs *, char *);
d123 3
a125 4
			if (OF_getprop(node, "device_type", name,
			    sizeof(name)) <= 0) {
				if (OF_getprop(node, "name", name,
				    sizeof(name)) <= 0)
d165 1
a165 1
	int (*handler)(void *);
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2.6.1 2002/06/11 03:36:34 art Exp $	*/
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d44 3
a46 3
static int	mbmatch(struct device *, void *, void *);
static void	mbattach(struct device *, struct device *, void *);
static int	mbprint(void *, const char *);
d55 4
a58 4
void	mb_intr_establish(struct confargs *, int (*)(void *), void *);
void	mb_intr_disestablish(struct confargs *);
caddr_t	mb_cvtaddr(struct confargs *);
int	mb_matchname(struct confargs *, char *);
d165 1
a165 1
	int (*handler)(void *);
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d123 3
a125 4
			if (OF_getprop(node, "device_type", name,
			    sizeof(name)) <= 0) {
				if (OF_getprop(node, "name", name,
				    sizeof(name)) <= 0)
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d8 1
a8 1
 *
d14 3
a16 3
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
d18 1
a18 1
 *
d52 1
a52 1
	NULL, "mainbus", DV_DULL
d62 4
a65 1
mbmatch(struct device *parent, void *cfdata, void *aux)
d75 4
a78 1
mbattach(struct device *parent, struct device *self, void *aux)
d106 2
a107 1
	}
d142 2
a143 1
			}
d154 3
a156 1
mbprint(void *aux, const char *pnp)
d164 4
a167 1
mb_intr_establish(struct confargs *ca, int (*handler)(void *), void *val)
d173 2
a174 1
mb_intr_disestablish(struct confargs *ca)
d180 2
a181 1
mb_cvtaddr(struct confargs *ca)
d183 1
d188 3
a190 1
mb_matchname(struct confargs *ca, char *name)
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.8 2001/07/09 04:41:28 mickey Exp $	*/
d126 2
a127 1
					printf ("name not found on node %x\n");
@

