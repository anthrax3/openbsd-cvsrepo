head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.12
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.8
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.12
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.10
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.8
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.13.0.8
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.6
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.8
	UBC:1.3.0.2
	UBC_BASE:1.3
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.09.25.15.23.37;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	YxqfPf79WCjoxCH9;

1.23
date	2016.08.15.22.01.59;	author tedu;	state Exp;
branches;
next	1.22;
commitid	hzJmUc5FH2irhNvz;

1.22
date	2015.09.06.16.24.19;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	dtwOHoD9OFv0UYKv;

1.21
date	2015.05.28.20.53.05;	author jcs;	state Exp;
branches;
next	1.20;
commitid	mm0ThjDof6ifWCwA;

1.20
date	2015.02.10.22.44.35;	author miod;	state Exp;
branches;
next	1.19;
commitid	lsrmQ0A4gY4UmdnD;

1.19
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.18;
commitid	C5iGb36LQxjM60Q3;

1.18
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.17;
commitid	uKVPYMN2MLxdZxzH;

1.17
date	2011.11.10.17.30.32;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.05.06.32.47;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.14.17.29.04;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.22.16.21.32;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.16.05.03.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.15.20.32.13;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.09.04.13.13;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.23.17.17.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.23.16.59.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Make a move towards ending 4 decades of kernel snooping.

Add sysctl kern.allowkmem (default 0) which controls the ability to open
/dev/mem or /dev/kmem at securelevel > 0.  Over 15 years we converted 99%
of utilities in the tree to operate on sysctl-nodes (either by themselves
or via code hiding in the guts of -lkvm).

pstat -d and -v & procmap are affected and continued use of them will
require kern.allowkmem=1 in /etc/sysctl.conf.  acpidump (and it's
buddy sendbug) are affected, but we'll work out a solution soon.

There will be some impact in ports.

ok kettenis guenther
@
text
@/*	$OpenBSD: mem.c,v 1.23 2016/08/15 22:01:59 tedu Exp $	*/
/*	$NetBSD: mem.c,v 1.1 1996/09/30 16:34:50 ws Exp $ */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mem.c	8.3 (Berkeley) 1/12/94
 */

/*
 * Memory special file
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/systm.h>
#include <sys/ioccom.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/types.h>

#include <machine/cpu.h>

#include <uvm/uvm_extern.h>

#include <machine/conf.h>

/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
extern int allowaperture;
#endif

#ifndef SMALL_KERNEL

/* 
 * The EEPROMs for Serial Presence Detect don't show up in the
 * OpenFirmware tree, but their contents are available through the
 * "dimm-info" property of the "/memory" node.  To make the
 * information available, we fake up an I2C bus with EEPROMs
 * containing the appropriate slices of the "dimm-info" property.
 */

#include <machine/autoconf.h>

#include <dev/i2c/i2cvar.h>
#include <dev/ofw/openfirm.h>

struct mem_softc {
	struct device sc_dev;

	uint8_t *sc_buf;
	int sc_len;
};

/* Size of a single SPD entry in "dimm-info" property. */
#define SPD_SIZE	128

int	mem_match(struct device *, void *, void *);
void	mem_attach(struct device *, struct device *, void *);

struct cfdriver mem_cd = {
	NULL, "mem", DV_DULL
};

struct cfattach mem_ca = {
	sizeof(struct mem_softc), mem_match, mem_attach
};

int	mem_i2c_acquire_bus(void *, int);
void	mem_i2c_release_bus(void *, int);
int	mem_i2c_exec(void *, i2c_op_t, i2c_addr_t,
	    const void *, size_t, void *, size_t, int);

int
mem_match(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;

	if (strcmp(ca->ca_name, "mem") == 0)
		return (1);
	return (0);
}

void
mem_attach(struct device *parent, struct device *self, void *aux)
{
	struct mem_softc *sc = (struct mem_softc *)self;
	struct confargs *ca = aux;
	struct i2c_controller ic;
	struct i2c_attach_args ia;

	sc->sc_len = OF_getproplen(ca->ca_node, "dimm-info");
	if (sc->sc_len > 0) {
		sc->sc_buf = malloc(sc->sc_len, M_DEVBUF, M_NOWAIT);
		if (sc->sc_buf == NULL) {
			printf(": can't allocate memory\n");
			return;
		}
	}

	printf("\n");

	if (sc->sc_len > 0) {
		OF_getprop(ca->ca_node, "dimm-info", sc->sc_buf, sc->sc_len);

		memset(&ic, 0, sizeof ic);
		ic.ic_cookie = sc;
		ic.ic_acquire_bus = mem_i2c_acquire_bus;
		ic.ic_release_bus = mem_i2c_release_bus;
		ic.ic_exec = mem_i2c_exec;

		memset(&ia, 0, sizeof ia);
		ia.ia_tag = &ic;
		ia.ia_name = "spd";
		ia.ia_addr = 0;
		while (ia.ia_addr * SPD_SIZE < sc->sc_len) {
			/* Skip entries that have not been filled in. */
			if (sc->sc_buf[ia.ia_addr * SPD_SIZE] != 0)
				config_found(self, &ia, NULL);
			ia.ia_addr++;
		}

		/* No need to keep the "dimm-info" contents around. */
		free(sc->sc_buf, M_DEVBUF, sc->sc_len);
		sc->sc_len = -1;
	}
}

int
mem_i2c_acquire_bus(void *cookie, int flags)
{
	return (0);
}

void
mem_i2c_release_bus(void *cookie, int flags)
{
}

int
mem_i2c_exec(void *cookie, i2c_op_t op, i2c_addr_t addr,
    const void *cmdbuf, size_t cmdlen, void *buf, size_t len, int flags)
{
	struct mem_softc *sc = cookie;
	size_t off;

	if (op != I2C_OP_READ_WITH_STOP || cmdlen != 1)
		return (EINVAL);

	off = addr * SPD_SIZE + *(const uint8_t *)cmdbuf;
	if (off + len > sc->sc_len)
		return (EIO);

	memcpy(buf, &sc->sc_buf[off], len);
	return (0);
}

#endif /* SMALL_KERNEL */

int
mmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	extern int allowkmem;

	switch (minor(dev)) {
	case 0:
	case 1:
		if (securelevel <= 0 || allowkmem)
			break;
		return (EPERM);
	case 2:
	case 12:
		break;
#ifdef APERTURE
	case 4:
	        if (suser(p, 0) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() unless
		 * allowaperture=3 */
		if (ap_open_count > 0 && allowaperture < 3)
			return (EPERM);
		ap_open_count++;
		break;
#endif
	default:
		return (ENXIO);
	}
	return (0);
}

int
mmclose(dev_t dev, int flag, int mode, struct proc *p)
{
#ifdef APERTURE
	if (minor(dev) == 4)
		ap_open_count = 0;
#endif
	return 0;
}

int
mmrw(dev_t dev, struct uio *uio, int flags)
{
	vaddr_t v;
	vsize_t c;
	struct iovec *iov;
	int error = 0;
	static caddr_t zeropage;

	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("mmrw");
			continue;
		}
		switch (minor(dev)) {

		/* minor device 0 is physical memory */
		case 0:
			v = uio->uio_offset;
			c = uio->uio_resid;
			/* This doesn't allow device mapping!	XXX */
			pmap_real_memory(&v, &c);
			error = uiomove((caddr_t)v, c, uio);
			continue;

		/* minor device 1 is kernel memory */
		case 1:
			v = uio->uio_offset;
			c = ulmin(iov->iov_len, MAXPHYS);
			error = uiomove((caddr_t)v, c, uio);
			continue;

		/* minor device 2 is /dev/null */
		case 2:
			if (uio->uio_rw == UIO_WRITE)
				uio->uio_resid = 0;
			return 0;

		/* minor device 12 is /dev/zero */
		case 12:
			if (uio->uio_rw == UIO_WRITE) {
				c = iov->iov_len;
				break;
			}
			if (zeropage == NULL)
				zeropage = malloc(PAGE_SIZE, M_TEMP,
				    M_WAITOK | M_ZERO);
			c = ulmin(iov->iov_len, PAGE_SIZE);
			error = uiomove(zeropage, c, uio);
			continue;

		default:
			return ENXIO;
		}
		if (error)
			break;
		iov->iov_base += c;
		iov->iov_len -= c;
		uio->uio_offset += c;
		uio->uio_resid -= c;
	}
	return error;
}

paddr_t
mmmmap(dev_t dev, off_t off, int prot)
{
	return (-1);
}

int
mmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	return (EOPNOTSUPP);
}
@


1.23
log
@normalize some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.22 2015/09/06 16:24:19 deraadt Exp $	*/
d194 1
d197 3
a199 4
		case 0:
		case 1:
		case 2:
		case 12:
d201 4
d217 2
a218 2
		default:
			return (ENXIO);
@


1.22
log
@pretty simple size for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.21 2015/05/28 20:53:05 jcs Exp $	*/
a190 1
/*ARGSUSED*/
d209 1
a209 1
			return(EPERM);
a218 1
/*ARGSUSED*/
a228 1
/*ARGSUSED*/
d265 1
a265 1
		/* minor device 2 is EOF/RATHOLE */
d271 1
a271 3
		/* minor device 12 (/dev/zero) is source of nulls on read,
		 * rathole on write
		 */
a302 1
/*ARGSUSED*/
@


1.21
log
@when machdep.allowaperture sysctl is set to 3, allow concurrent access
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.20 2015/02/10 22:44:35 miod Exp $	*/
d155 1
a155 1
		free(sc->sc_buf, M_DEVBUF, 0);
@


1.20
log
@Convert to uiomove().
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.18 2014/07/12 18:44:42 tedu Exp $	*/
d207 3
a209 2
		/* authorize only one simultaneous open() */
		if (ap_open_count > 0)
@


1.19
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d257 1
a257 1
			error = uiomovei((caddr_t)v, c, uio);
d263 2
a264 2
			c = min(iov->iov_len, MAXPHYS);
			error = uiomovei((caddr_t)v, c, uio);
d284 2
a285 2
			c = min(iov->iov_len, PAGE_SIZE);
			error = uiomovei(zeropage, c, uio);
@


1.18
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.17 2011/11/10 17:30:32 krw Exp $	*/
d257 1
a257 1
			error = uiomove((caddr_t)v, c, uio);
d264 1
a264 1
			error = uiomove((caddr_t)v, c, uio);
d285 1
a285 1
			error = uiomove(zeropage, c, uio);
@


1.17
log
@Remove unused %s from a printf(), properly cast const void* to const
int*. From Marco Trillo via tech@@ long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.16 2008/11/05 06:32:47 matthieu Exp $	*/
d155 1
a155 1
		free(sc->sc_buf, M_DEVBUF);
@


1.16
log
@since mmclose() is only called once for the final close,
set ap_open_count = 0 in mmclose() instread of decrementing it.
ok miod@@, oga@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.15 2007/10/14 17:29:04 kettenis Exp $	*/
d127 1
a127 1
			printf("%s: can't allocate memory\n");
d181 1
a181 1
	off = addr * SPD_SIZE + *(uint8_t *)cmdbuf;
@


1.15
log
@Provide a way to attach spdmem(4) by faking an I2C bus with EEPROMs with
contents from OpenFirmware.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.14 2007/09/22 16:21:32 krw Exp $	*/
d225 1
a225 1
		ap_open_count--;
@


1.14
log
@M_ZERO -> bzero.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.13 2005/12/17 07:31:26 miod Exp $	*/
d63 127
@


1.13
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.12 2003/10/16 05:03:22 deraadt Exp $	*/
d154 3
a156 5
			if (zeropage == NULL) {
				zeropage = (caddr_t)malloc(PAGE_SIZE, M_TEMP,
				    M_WAITOK);
				bzero(zeropage, PAGE_SIZE);
			}
@


1.12
log
@more white
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.11 2003/10/15 17:50:16 drahn Exp $	*/
d107 2
a108 2
	vm_offset_t v;
	vm_size_t c;
@


1.11
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.10 2003/08/15 20:32:13 tedu Exp $	*/
d112 1
a112 1
	
@


1.10
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.9 2003/06/02 23:27:50 millert Exp $	*/
d66 1
a66 4
mmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d94 1
a94 4
mmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d105 1
a105 4
mmrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d177 1
a177 4
mmmmap(dev, off, prot)
        dev_t dev;
        off_t off;
	int prot;
d184 1
a184 6
mmioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8 2002/09/15 09:01:58 deraadt Exp $	*/
d80 1
a80 1
	        if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
@


1.8
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.6 2002/06/09 04:13:13 drahn Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@KNF
@
text
@d77 5
a81 5
	case 0:
	case 1:
	case 2:
	case 12:
		break;
d84 1
a84 1
		if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
d191 2
a192 2
	dev_t dev;
	off_t off;
@


1.6
log
@knf/cleanup/dead code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.5 2002/02/23 17:17:04 matthieu Exp $	*/
d77 5
a81 5
		case 0:
		case 1:
		case 2:
		case 12:
			break;
d84 1
a84 1
	        if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
d191 2
a192 2
        dev_t dev;
        off_t off;
@


1.5
log
@remove a commented-out debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.4 2002/02/23 16:59:36 matthieu Exp $	*/
d137 1
a137 1
/* minor device 0 is physical memory */
d146 1
a146 1
/* minor device 1 is kernel memory */
d153 1
a153 1
/* minor device 2 is EOF/RATHOLE */
d159 3
a161 1
/* minor device 12 (/dev/zero) is source of nulls on read, rathole on write */
d168 2
a169 1
				zeropage = (caddr_t)malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
@


1.4
log
@Add aperture driver support for macppc, and also place writing to /dev/pci
under the control of machdep.allowaperture.
This allows to run the X server on macppc with securelevel=1, given that
machdep.allowaperture is != 0.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.3 2001/11/06 19:53:15 miod Exp $	*/
a83 2
		/* printf("open aperture allow %d count %d\n", 
			allowaperture, ap_open_count); */
@


1.3
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.2 2001/11/01 12:13:46 art Exp $	*/
d62 6
d81 14
a94 1
			return (0);
d98 1
d108 4
a111 1

@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.3 2001/11/06 19:53:15 miod Exp $	*/
a61 6
/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
extern int allowaperture;
#endif

d75 1
a75 12
			break;
#ifdef APERTURE
	case 4:
	        if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() */
		if (ap_open_count > 0)
			return(EPERM);
		ap_open_count++;
		break;
#endif
a78 1
	return (0);
d88 1
a88 4
#ifdef APERTURE
	if (minor(dev) == 4)
		ap_open_count--;
#endif
d116 1
a116 1
		/* minor device 0 is physical memory */
d125 1
a125 1
		/* minor device 1 is kernel memory */
d132 1
a132 1
		/* minor device 2 is EOF/RATHOLE */
d138 1
a138 3
		/* minor device 12 (/dev/zero) is source of nulls on read,
		 * rathole on write
		 */
d145 1
a145 2
				zeropage = (caddr_t)malloc(PAGE_SIZE, M_TEMP,
				    M_WAITOK);
@


1.3.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.3.2.1 2002/06/11 03:36:34 art Exp $	*/
@


1.2
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
a57 1
#include <vm/vm.h>
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8 2001/06/24 23:29:35 drahn Exp $	*/
d166 1
a166 1
int
d169 2
a170 1
        int off, prot;
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current
@
text
@d58 1
d166 1
a166 1
paddr_t
d169 1
a169 2
        off_t off;
	int prot;
@


1.1.4.3
log
@Merge in trunk
@
text
@a61 6
/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
extern int allowaperture;
#endif

d75 1
a75 12
			break;
#ifdef APERTURE
	case 4:
	        if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() */
		if (ap_open_count > 0)
			return(EPERM);
		ap_open_count++;
		break;
#endif
a78 1
	return (0);
d88 1
a88 4
#ifdef APERTURE
	if (minor(dev) == 4)
		ap_open_count--;
#endif
@


1.1.4.4
log
@Sync the SMP branch with 3.3
@
text
@d137 1
a137 1
		/* minor device 0 is physical memory */
d146 1
a146 1
		/* minor device 1 is kernel memory */
d153 1
a153 1
		/* minor device 2 is EOF/RATHOLE */
d159 1
a159 3
		/* minor device 12 (/dev/zero) is source of nulls on read,
		 * rathole on write
		 */
d166 1
a166 2
				zeropage = (caddr_t)malloc(PAGE_SIZE, M_TEMP,
				    M_WAITOK);
@


1.1.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.1.4.4 2003/03/27 23:29:46 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 4
a69 1
mmopen(dev_t dev, int flag, int mode, struct proc *p)
d80 1
a80 1
	        if (suser(p, 0) != 0 || !allowaperture)
d97 4
a100 1
mmclose(dev_t dev, int flag, int mode, struct proc *p)
d111 4
a114 1
mmrw(dev_t dev, struct uio *uio, int flags)
d121 1
a121 1

d186 4
a189 1
mmmmap(dev_t dev, off_t off, int prot)
d196 6
a201 1
mmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
@


