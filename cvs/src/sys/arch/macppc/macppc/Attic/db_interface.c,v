head	1.13;
access;
symbols
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.26
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.24
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.20
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.18
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.16
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.6
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.03.05.17.41.55;	author mpi;	state dead;
branches;
next	1.12;
commitid	5025CzLISD0jU2OS;

1.12
date	2016.03.05.17.24.27;	author mpi;	state Exp;
branches;
next	1.11;
commitid	oo3LXu9V3TFs8Av3;

1.11
date	2016.02.28.11.56.40;	author mpi;	state Exp;
branches;
next	1.10;
commitid	dxE8ORgWtxpg3ns1;

1.10
date	2015.02.06.10.54.08;	author mpi;	state Exp;
branches;
next	1.9;
commitid	szW6OU9OmYEMTniU;

1.9
date	2008.09.16.04.20.42;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.19.08.26.20;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.09.04.13.13;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.55.02;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@One ddb interface is enough for ppc.
@
text
@/*	$OpenBSD: db_interface.c,v 1.12 2016/03/05 17:24:27 mpi Exp $	*/
/*      $NetBSD: db_interface.c,v 1.12 2001/07/22 11:29:46 wiz Exp $ */

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 *
 *      db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <dev/cons.h>

#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#include <ddb/db_command.h>
#include <ddb/db_output.h>
#include <ddb/db_run.h>

#ifdef MULTIPROCESSOR
struct mutex ddb_mp_mutex = MUTEX_INITIALIZER(IPL_HIGH);
volatile int ddb_state = DDB_STATE_NOT_RUNNING;
volatile cpuid_t ddb_active_cpu;
boolean_t        db_switch_cpu;
long             db_switch_to_cpu;
#endif

int db_active;
extern db_regs_t ddb_regs;

#ifdef MULTIPROCESSOR
void db_cpuinfo_cmd(db_expr_t, int, db_expr_t, char *);
void db_startproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_stopproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ddbproc_cmd(db_expr_t, int, db_expr_t, char *);
#endif

int db_active = 0;

int db_trap_glue(struct trapframe *frame); /* called from locore */

void
Debugger()
{
	ddb_trap();
}

int
db_trap_glue(struct trapframe *frame)
{
	int s;

	if (!(frame->srr1 & PSL_PR)
	    && (frame->exc == EXC_TRC
		|| (frame->exc == EXC_PGM && (frame->srr1 & 0x20000))
		|| frame->exc == EXC_BPT)) {

#ifdef MULTIPROCESSOR
		mtx_enter(&ddb_mp_mutex);
		if (ddb_state == DDB_STATE_EXITING)
			ddb_state = DDB_STATE_NOT_RUNNING;
		mtx_leave(&ddb_mp_mutex);

		while (db_enter_ddb()) {
#endif
			bcopy(frame->fixreg, DDB_REGS->fixreg,
				32 * sizeof(u_int32_t));
			DDB_REGS->srr0 = frame->srr0;
			DDB_REGS->srr1 = frame->srr1;

			s = splhigh();
			db_active++;
			cnpollc(TRUE);
			db_trap(T_BREAKPOINT, 0);
			cnpollc(FALSE);
			db_active--;
			splx(s);

			bcopy(DDB_REGS->fixreg, frame->fixreg,
				32 * sizeof(u_int32_t));
#ifdef MULTIPROCESSOR
			if (!db_switch_cpu)
				ddb_state = DDB_STATE_EXITING;
		}
#endif
		return 1;
	}
	return 0;
}

int
db_enter_ddb(void)
{
#ifdef MULTIPROCESSOR
	int i;
	struct cpu_info *ci = curcpu();

	mtx_enter(&ddb_mp_mutex);

	/* If we are first in, grab ddb and stop all other CPUs */
	if (ddb_state == DDB_STATE_NOT_RUNNING) {
		ddb_active_cpu = cpu_number();
		ddb_state = DDB_STATE_RUNNING;
		ci->ci_ddb_paused = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		for (i = 0; i < ncpus; i++) {
			if (i != cpu_number() &&
			    cpu_info[i].ci_ddb_paused != CI_DDB_STOPPED) {
				cpu_info[i].ci_ddb_paused = CI_DDB_SHOULDSTOP;
				ppc_send_ipi(&cpu_info[i], PPC_IPI_DDB);
			}
		}
		return (1);
	}

	/* Leaving ddb completely.  Start all other CPUs and return 0 */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_EXITING) {
		for (i = 0; i < ncpus; i++) {
			cpu_info[i].ci_ddb_paused = CI_DDB_RUNNING;
		}
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}

	/* We are switching to another CPU. ddb_ddbproc_cmd() has made sure
	 * it is waiting for ddb, we just have to set ddb_active_cpu. */
	if (ddb_active_cpu == cpu_number() && db_switch_cpu) {
		ci->ci_ddb_paused = CI_DDB_SHOULDSTOP;
		db_switch_cpu = 0;
		ddb_active_cpu = db_switch_to_cpu;
		cpu_info[db_switch_to_cpu].ci_ddb_paused = CI_DDB_ENTERDDB;
	}

	/* Wait until we should enter ddb or resume */
	while (ddb_active_cpu != cpu_number() &&
	    ci->ci_ddb_paused != CI_DDB_RUNNING) {
		if (ci->ci_ddb_paused == CI_DDB_SHOULDSTOP)
			ci->ci_ddb_paused = CI_DDB_STOPPED;
		mtx_leave(&ddb_mp_mutex);

		/* Busy wait without locking, we will confirm with lock later */
		while (ddb_active_cpu != cpu_number() &&
		    ci->ci_ddb_paused != CI_DDB_RUNNING)
			;	/* Do nothing */

		mtx_enter(&ddb_mp_mutex);
	}

	/* Either enter ddb or exit */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_RUNNING) {
		ci->ci_ddb_paused = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		return (1);
	} else {
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}
#else
	return (1);
#endif
}

#ifdef MULTIPROCESSOR
void
ppc_ipi_db(struct cpu_info *ci)
{
	Debugger();
}

void
db_cpuinfo_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;

	for (i = 0; i < ncpus; i++) {
		db_printf("%c%4d: ", (i == cpu_number()) ? '*' : ' ',
		    cpu_info[i].ci_cpuid);
		switch(cpu_info[i].ci_ddb_paused) {
		case CI_DDB_RUNNING:
			db_printf("running\n");
			break;
		case CI_DDB_SHOULDSTOP:
			db_printf("stopping\n");
			break;
		case CI_DDB_STOPPED:
			db_printf("stopped\n");
			break;
		case CI_DDB_ENTERDDB:
			db_printf("entering ddb\n");
			break;
		case CI_DDB_INDDB:
			db_printf("ddb\n");
			break;
		default:
			db_printf("? (%d)\n",
			    cpu_info[i].ci_ddb_paused);
			break;
		}
	}
}
#endif

struct db_command db_machine_command_table[] = {
#ifdef MULTIPROCESSOR
	{ "cpuinfo",    db_cpuinfo_cmd,         0,      NULL },
	{ "startcpu",   db_startproc_cmd,       0,      NULL },
	{ "stopcpu",    db_stopproc_cmd,        0,      NULL },
	{ "ddbcpu",     db_ddbproc_cmd,         0,      NULL },
#endif   
	{ (char *)NULL }
};

void
db_machine_init(void)   
{
#ifdef MULTIPROCESSOR
	int i;
#endif
		    
	db_machine_commands_install(db_machine_command_table);
#ifdef MULTIPROCESSOR
	for (i = 0; i < ncpus; i++) {
		cpu_info[i].ci_ddb_paused = CI_DDB_RUNNING;
	}
#endif
}

#ifdef MULTIPROCESSOR
void
db_ddbproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int cpu_n;

	if (have_addr) {
		cpu_n = addr;
		if (cpu_n >= 0 && cpu_n < ncpus &&
		    cpu_n != cpu_number()) {
			db_switch_to_cpu = cpu_n;
			db_switch_cpu = 1;
			db_cmd_loop_done = 1;
		} else {
			db_printf("Invalid cpu %d\n", (int)addr);
		}
	} else {
		db_printf("CPU not specified\n");
	}
}

void
db_startproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int cpu_n;

	if (have_addr) {
		cpu_n = addr;
		if (cpu_n >= 0 && cpu_n < ncpus &&
		    cpu_n != cpu_number())
			db_startcpu(cpu_n);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (cpu_n = 0; cpu_n < ncpus; cpu_n++) {
			if (cpu_n != cpu_number()) {
				db_startcpu(cpu_n);
			}
		}
	}
}

void
db_stopproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int cpu_n;
	
	if (have_addr) {
		cpu_n = addr;
		if (cpu_n >= 0 && cpu_n < ncpus &&
		    cpu_n != cpu_number())
			db_stopcpu(cpu_n);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (cpu_n = 0; cpu_n < ncpus; cpu_n++) {
			if (cpu_n != cpu_number()) {
				db_stopcpu(cpu_n);
			}
		}
	}
}

void
db_startcpu(int cpu)
{
	if (cpu != cpu_number() && cpu < ncpus) {
		mtx_enter(&ddb_mp_mutex);
		cpu_info[cpu].ci_ddb_paused = CI_DDB_RUNNING;
		mtx_leave(&ddb_mp_mutex);
	}
}   

void
db_stopcpu(int cpu)
{
	mtx_enter(&ddb_mp_mutex);
	if (cpu != cpu_number() && cpu < ncpus &&
	    cpu_info[cpu].ci_ddb_paused != CI_DDB_STOPPED) {
		cpu_info[cpu].ci_ddb_paused = CI_DDB_SHOULDSTOP;  
		mtx_leave(&ddb_mp_mutex);
		ppc_send_ipi(&cpu_info[cpu], PPC_IPI_DDB);
	} else {
		mtx_leave(&ddb_mp_mutex);
	}
}
#endif
@


1.12
log
@Define db_reg_t like the other archs by typedef'ing "struct trapframe".

This will allow us to use some of the DDB macros on trapframe which are
not DDB_REGS.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.11 2016/02/28 11:56:40 mpi Exp $	*/
@


1.11
log
@Rename ddb_trap_glue() to db_trap_glue().

Let's keep the 'db_' prefix for all ddb(4) functions that should not be
instrumented.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.10 2015/02/06 10:54:08 mpi Exp $	*/
d91 1
a91 1
			bcopy(frame->fixreg, DDB_REGS->tf.fixreg,
d93 2
a94 2
			DDB_REGS->tf.srr0 = frame->srr0;
			DDB_REGS->tf.srr1 = frame->srr1;
d104 1
a104 1
			bcopy(DDB_REGS->tf.fixreg, frame->fixreg,
@


1.10
log
@Give "machine ddbcpu" a chance to work, now we can try to see what's wrong
on MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2008/09/16 04:20:42 drahn Exp $	*/
d65 1
a65 1
int ddb_trap_glue(struct trapframe *frame); /* called from locore */
d74 1
a74 1
ddb_trap_glue(struct trapframe *frame)
@


1.9
log
@SMP ddb support, with some feedback from kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2008/08/19 08:26:20 kettenis Exp $	*/
d8 1
a8 1
 *                      
d16 1
a16 1
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR 
d43 1
a124 4
#if 0
	printf("db_enter_ddb %d: state %x pause %x\n", ci->ci_cpuid,
	    ddb_state, ci->ci_ddb_paused);
#endif
d130 1
a137 1
		mtx_leave(&ddb_mp_mutex);
d265 1
a265 1
/*			db_cmd_loop_done = 1; */
@


1.8
log
@Make it possible to enter ddb from the serial console.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 2003/10/15 17:50:16 drahn Exp $	*/
d4 28
d40 21
d75 2
d82 215
a296 10
		bcopy(frame->fixreg, DDB_REGS->tf.fixreg,
			32 * sizeof(u_int32_t));
		DDB_REGS->tf.srr0 = frame->srr0;
		DDB_REGS->tf.srr1 = frame->srr1;

		db_active++;
		cnpollc(TRUE);
		db_trap(T_BREAKPOINT, 0);
		cnpollc(FALSE);
		db_active--;
d298 20
a317 2
		bcopy(DDB_REGS->tf.fixreg, frame->fixreg,
			32 * sizeof(u_int32_t));
d319 21
a339 1
		return 1;
a340 1
	return 0;
d342 1
@


1.7
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 2002/09/15 09:01:58 deraadt Exp $	*/
d13 2
d36 1
d40 1
@


1.6
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4 2002/06/09 04:13:13 drahn Exp $	*/
d22 1
a22 2
ddb_trap_glue(frame)
	struct trapframe *frame;
@


1.5
log
@KNF
@
text
@d2 1
a2 1
/*	$NetBSD: db_interface.c,v 1.12 2001/07/22 11:29:46 wiz Exp $ */
d25 4
a28 4
	if (!(frame->srr1 & PSL_PR) &&
	    (frame->exc == EXC_TRC ||
	    (frame->exc == EXC_PGM && (frame->srr1 & 0x20000)) ||
	    frame->exc == EXC_BPT)) {
d31 1
a31 1
		    32 * sizeof(u_int32_t));
d40 1
a40 1
		    32 * sizeof(u_int32_t));
@


1.4
log
@knf/cleanup/dead code removal.
@
text
@d1 2
a2 2
/*	$OpenBSD: db_interface.c,v 1.3 2002/05/13 17:55:02 drahn Exp $	*/
/*      $NetBSD: db_interface.c,v 1.12 2001/07/22 11:29:46 wiz Exp $ */
d25 4
a28 4
	if (!(frame->srr1 & PSL_PR)
	    && (frame->exc == EXC_TRC
		|| (frame->exc == EXC_PGM && (frame->srr1 & 0x20000))
		|| frame->exc == EXC_BPT)) {
d31 1
a31 1
			32 * sizeof(u_int32_t));
d40 1
a40 1
			32 * sizeof(u_int32_t));
@


1.3
log
@Add missing cnpollc() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.2 2002/03/14 01:26:36 millert Exp $	*/
d27 1
a27 2
		|| (frame->exc == EXC_PGM
		    && (frame->srr1 & 0x20000))
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d8 2
d36 1
d38 1
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 2001/08/21 02:58:35 drahn Exp $	*/
d11 1
a11 1
int ddb_trap_glue __P((struct trapframe *frame)); /* called from locore */
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
a7 2
#include <dev/cons.h>

d11 1
a11 1
int ddb_trap_glue(struct trapframe *frame); /* called from locore */
d25 2
a26 1
		|| (frame->exc == EXC_PGM && (frame->srr1 & 0x20000))
a33 1
		cnpollc(TRUE);
a34 1
		cnpollc(FALSE);
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1.6.1 2002/06/11 03:36:34 art Exp $	*/
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current from about a week ago
@
text
@d11 1
a11 1
int ddb_trap_glue(struct trapframe *frame); /* called from locore */
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@a7 2
#include <dev/cons.h>

d25 2
a26 1
		|| (frame->exc == EXC_PGM && (frame->srr1 & 0x20000))
a33 1
		cnpollc(TRUE);
a34 1
		cnpollc(FALSE);
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d22 2
a23 1
ddb_trap_glue(struct trapframe *frame)
@


