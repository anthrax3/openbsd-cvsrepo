head	1.56;
access;
symbols
	OPENBSD_6_2:1.56.0.2
	OPENBSD_6_2_BASE:1.56
	OPENBSD_6_1:1.55.0.6
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.42.0.6
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.41.0.22
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.20
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.18
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.16
	OPENBSD_5_0:1.41.0.14
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.12
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.10
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.6
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.8
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.4
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.2
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.7
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@# @;


1.56
date	2017.06.13.01.44.29;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	2Ye0ToBJHNraUu5K;

1.55
date	2016.05.23.20.11.49;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	0oWSDXhpPUnuLpPD;

1.54
date	2016.05.10.18.39.46;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	qfOifNidEGDB2jL1;

1.53
date	2016.04.25.07.58.14;	author mpi;	state Exp;
branches;
next	1.52;
commitid	fFlfjZ3dc0QNWFPV;

1.52
date	2016.02.28.11.56.40;	author mpi;	state Exp;
branches;
next	1.51;
commitid	dxE8ORgWtxpg3ns1;

1.51
date	2015.11.15.17.10.53;	author miod;	state Exp;
branches;
next	1.50;
commitid	u4uGPXYURqyAdysx;

1.50
date	2015.07.29.18.52.44;	author miod;	state Exp;
branches;
next	1.49;
commitid	f8evG97O4V8Sypqs;

1.49
date	2015.03.31.16.00.38;	author mpi;	state Exp;
branches;
next	1.48;
commitid	MMWnK4Mn4W58afQM;

1.48
date	2014.10.27.21.56.57;	author kettenis;	state Exp;
branches;
next	1.47;
commitid	FoIIoP29J2IYw7zk;

1.47
date	2014.10.18.22.36.36;	author kettenis;	state Exp;
branches;
next	1.46;
commitid	1TGlmjX1M7hbN9MP;

1.46
date	2014.10.09.09.44.20;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	vZyhYEPThdrshrCU;

1.45
date	2014.09.06.10.45.29;	author mpi;	state Exp;
branches;
next	1.44;
commitid	psPuYzRRUiGpyp76;

1.44
date	2014.09.06.10.15.52;	author mpi;	state Exp;
branches;
next	1.43;
commitid	RzNS2F7j0UQHdMTX;

1.43
date	2014.09.06.09.42.22;	author mpi;	state Exp;
branches;
next	1.42;
commitid	4fHo5VOQyKp2KbTB;

1.42
date	2013.12.29.21.06.37;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.28.19.08.46;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.10.18.38.59;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2008.04.29.00.26.11;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2008.04.27.15.59.49;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.26.22.37.41;	author drahn;	state Exp;
branches;
next	1.36;

1.36
date	2008.02.15.17.33.51;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.04.22.36.39;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.10.15.56.20;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.20.20.59.54;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.21.23.01.45;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.17.20.43.39;	author gwk;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.31.05.23.14;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.24.12.08.16;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.20.12.52.13;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.14.03.10.32;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.03.04.47.30;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.03.04.40.09;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.03.02.16.10;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.19.04.16.24;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.02.21.02.48;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.17.20.09.50;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.28.02.49.10;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.24.22.35.56;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.13.21.49.18;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.03.00.57.06;	author pvalchev;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.31.03.06.16;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.24.19.56.44;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.20.02.45.10;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.16.05.03.22;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.15.20.52.44;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.14.18.56.12;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.17.20.36.53;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.06.14.24.35;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.24.02.19.28;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.21.03.02.32;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.13.18.27.36;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.57.06;	author drahn;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.06.07.01.57.15;	author tedu;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Split early startup code out of locore.S into locore0.S.  Adjust link
run so that this locore0.o is always at the start of the executable.
But randomize the link order of all other .o files in the kernel, so
that their exec/rodata/data/bss segments land all over the place.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.  The only known offsets are in the startup code
(which will be gone when it is smashed).

The bootstrap code unmapping or smashing isn't done yet, and there is
some potential for more bits from locore.S to move to locore0.S
@
text
@/*	$OpenBSD: locore.S,v 1.55 2016/05/23 20:11:49 deraadt Exp $	*/
/*	$NetBSD: locore.S,v 1.2 1996/10/16 19:33:09 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "assym.h"

#include <sys/syscall.h>

#include <machine/asm.h>
#include <machine/param.h>
#include <machine/pmap.h>
#include <machine/psl.h>
#include <machine/trap.h>

#define GET_CPUINFO(r)	mfsprg r,0

#define	INTSTK		(8*1024)	/* 8K interrupt stack */
#define	SPILLSTK	(1*1024)
#define	DDBSTK		(7*1024)

	.text

#ifdef MULTIPROCESSOR
_ENTRY(_C_LABEL(cpu_spinup_trampoline))
	lis	%r3,_C_LABEL(cpu_hatch_stack)@@ha
	lwz	%r1,_C_LABEL(cpu_hatch_stack)@@l(%r3)

	b	_C_LABEL(cpu_hatch)
	/* NOTREACHED */
#endif

/*
 * void cpu_switchto(struct proc *old, struct proc *new)
 * Switch from "old" proc to "new".
 */
_ENTRY(_C_LABEL(cpu_switchto_asm))
	mflr	%r0			/* save lr */
	stw	%r0,4(%r1)
	stwu	%r1,-16(%r1)
	stw	%r31,12(%r1)
	stw	%r30,8(%r1)

/*
 * r3 - old proc
 * r4 -	new proc
 * r5 - cpuinfo
 */
	GET_CPUINFO(%r5)

	li	%r31,SONPROC
	stb	%r31,P_STAT(%r4)

	or.	%r3,%r3,%r3		/* old process was exiting? */
	beq	switch_exited

	mfsr	%r10,PPC_USER_SR	/* save PPC_USER_SR for copyin/copyout*/
	mfcr	%r11			/* save cr */
	mr	%r12,%r2		/* save r2 */
	stwu	%r1,-SFRAMELEN(%r1)	/* still running on old stack */
	stmw	%r10,8(%r1)
	lwz	%r31,P_ADDR(%r3)
	stw	%r1,PCB_SP(%r31)	/* save SP */

switch_exited:
	/* disable interrupts while actually switching */
	mfmsr	%r30
	andi.	%r30,%r30,~PSL_EE@@l
	mtmsr	%r30
	isync

	stw	%r4,CI_CURPROC(%r5)	/* record new process */

#ifdef MULTIPROCESSOR
	stw	%r5,P_CPU(%r4)
#endif

	lwz	%r31,P_ADDR(%r4)
	stw	%r31,CI_CURPCB(%r5)	/* indicate new pcb */

	lwz	%r6,PCB_PMR(%r31)

	/* save real pmap pointer for spill fill */
	stwu	%r6,CI_CURPM(%r5)
	stwcx.	%r6,%r0,%r5		/* clear possible reservation */

	addic.	%r6,%r6,64
	li	%r5,0

	lwz	%r1,PCB_SP(%r31)	/* get new procs SP */

	ori	%r30,%r30,PSL_EE	/* interrupts are okay again */
	mtmsr	%r30

	lmw	%r10,8(%r1)		/* get other regs */
	lwz	%r1,0(%r1)		/* get saved SP */
	mr	%r2,%r12		/* get saved r2 */
	mtcr	%r11			/* get saved cr */
	isync
	mtsr	PPC_USER_SR,%r10	/* get saved PPC_USER_SR */
	isync

	lwz	%r31,12(%r1)
	lwz	%r30,8(%r1)
	addi	%r1,%r1,16
	lwz	%r0,4(%r1)
	mtlr	%r0
	blr

_ENTRY(_C_LABEL(cpu_idle_enter))
	lis	%r4, _C_LABEL(ppc_cpuidle)@@ha
	lwz	%r4, _C_LABEL(ppc_cpuidle)@@l(%r4)
	cmpwi	%r4, 0
	beq	1f
	/* must disable external interrupts during idle queue checking */
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3
	isync
1:
	blr

_ENTRY(_C_LABEL(cpu_idle_cycle))
	lis	%r4, _C_LABEL(ppc_cpuidle)@@ha
	lwz	%r4, _C_LABEL(ppc_cpuidle)@@l(%r4)
	cmpwi	%r4, 0
	beq	idledone

	/*
	 * Interrupts were disabled in cpu_idle_enter, but must be
	 * enabled for sleeping, but before that indicate that we
	 * are entering sleep mode.
	 */
	GET_CPUINFO(%r4)
	lwz	%r6,CI_FLAGS(%r4)
	ori	%r6,%r6,CI_FLAGS_SLEEPING@@l
	stw	%r6,CI_FLAGS(%r4)

	/* enable interrupts, required before setting POW */
	mfmsr	%r3
	ori	%r5,%r3,PSL_EE@@l
	mtmsr	%r5
	oris	%r5, %r5, PSL_POW@@h
	sync
	/* low power mode */
	mtmsr	%r5
	sync
	isync

	/*
	 * restore interrupts to disabled, so CI_FLAGS is only modified
	 * with interrupts disabled.
	 */
	mtmsr %r3
	isync

	/* clear CI_FLAGS_SLEEPING since sleeping is over */
	andi.	%r6,%r6,~CI_FLAGS_SLEEPING@@l
	stw	%r6,CI_FLAGS(%r4)
idledone:
	blr

_ENTRY(_C_LABEL(cpu_idle_leave))
	lis	%r4, _C_LABEL(ppc_cpuidle)@@ha
	lwz	%r4, _C_LABEL(ppc_cpuidle)@@l(%r4)
	cmpwi	%r4, 0
	beq	1f
	/* enable interrupts disabled in cpu_idle_enter. */
	mfmsr	%r3
	ori	%r3,%r3,PSL_EE@@l
	mtmsr	%r3
1:
	blr

/*
 * This code gets copied to all the trap vectors
 * except ISI/DSI, ALI, and the interrupts
 */
	.text
	.globl	_C_LABEL(trapcode),_C_LABEL(trapsize)
	.type	_C_LABEL(trapcode),@@function
	.type	_C_LABEL(trapsize),@@object
_C_LABEL(trapcode):
	mtsprg	1,%r1			/* save SP */
nop32_1s:
	mfmsr	%r1
	clrldi	%r1,%r1,1
	mtmsrd	%r1
nop32_1e:
	GET_CPUINFO(%r1)
	stmw	%r28,CI_TEMPSAVE(%r1)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfsprg	%r1,1			/* restore SP */

	/* Test whether we already had PR set */
	mfsrr1	%r31
	mtcr	%r31
	bc	4,17,1f			/* branch if PSL_PR is clear */
	GET_CPUINFO(%r1)
	lwz	%r1,CI_CURPCB(%r1)
	addi	%r1,%r1,USPACE		/* stack is top of user struct */
1:
	bla	s_trap
_C_LABEL(trapsize) =	.-_C_LABEL(trapcode)

/*
 * For ALI: has to save DSISR and DAR
 */
	.globl	_C_LABEL(alitrap),_C_LABEL(alisize)
_C_LABEL(alitrap):
	mtsprg	1,%r1			/* save SP */
nop32_2s:
	mfmsr	%r1
	clrldi	%r1,%r1,1
	mtmsrd	%r1
nop32_2e:
	GET_CPUINFO(%r1)
	stmw	%r28,CI_TEMPSAVE(%r1)	/* free r28-r31 */
	mfdar	%r30
	mfdsisr	%r31
	stmw	%r30,CI_TEMPSAVE+16(%r1)
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfsprg	%r1,1			/* restore SP */

	/* Test whether we already had PR set */
	mfsrr1	%r31
	mtcr	%r31
	bc	4,17,1f			/* branch if PSL_PR is clear */
	GET_CPUINFO(%r1)
	lwz	%r1,CI_CURPCB(%r1)
	addi	%r1,%r1,USPACE		/* stack is top of user struct */
1:
	bla	s_trap
_C_LABEL(alisize) =	.-_C_LABEL(alitrap)

/*
 * Similar to the above for DSI
 * Has to handle BAT spills
 * and standard pagetable spills
 */
	.globl	_C_LABEL(dsitrap),_C_LABEL(dsisize)
	.type	_C_LABEL(dsitrap),@@function
	.type	_C_LABEL(dsisize),@@object
_C_LABEL(dsitrap):
	mtsprg	1,%r1
	GET_CPUINFO(%r1)
	stmw	%r28,CI_DISISAVE(%r1)	/* free r28-r31 */
nop32_3s:
	mfmsr	%r28
	clrldi	%r28,%r28,1
	mtmsrd	%r28
nop32_3e:
	mfsprg	%r1,1
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30			/* in SPRG2 */
	mfsrr1	%r31			/* test kernel mode */
nopbat_1s:
	mtcr	%r31
	bc	12,17,1f		/* branch if PSL_PR is set */
	mfdar	%r31			/* get fault address */
	rlwinm	%r31,%r31,7,25,28	/* get segment * 8 */
	addis	%r31,%r31,_C_LABEL(battable)@@ha
	lwz	%r30,_C_LABEL(battable)@@l(%r31)	/* get batu */
	mtcr	%r30
	bc	4,30,1f			/* branch if supervisor valid is false */
	lwz	%r31,_C_LABEL(battable)+4@@l(%r31)	/* get batl */
/* We randomly use the highest two bat registers here */
	mftb	%r28
	andi.	%r28,%r28,1
	bne	2f
	mtdbatu	2,%r30
	mtdbatl	2,%r31
	b	3f
2:
	mtdbatu	3,%r30
	mtdbatl	3,%r31
3:
	mfsprg	%r30,2			/* restore XER */
	mtxer	%r30
	mtcr	%r29			/* restore CR */
	mtsprg	1,%r1
	GET_CPUINFO(%r1)
	lmw	%r28,CI_DISISAVE(%r1)	/* restore r28-r31 */
	mfsprg	1,%r1
	rfi				/* return to trapped code */
1:
nopbat_1e:
	mflr	%r28			/* save LR */
	bla	s_dsitrap
_C_LABEL(dsisize) =	.-_C_LABEL(dsitrap)

/*
 * Similar to the above for ISI
 */
	.globl	_C_LABEL(isitrap),_C_LABEL(isisize)
	.type	_C_LABEL(isitrap),@@function
	.type	_C_LABEL(isisize),@@object
_C_LABEL(isitrap):
	mtsprg	1,%r1                   /* save SP */
nop32_4s:
	mfmsr	%r1
	clrldi	%r1,%r1,1
	mtmsrd	%r1
nop32_4e:
	GET_CPUINFO(%r1)
	stmw	%r28,CI_DISISAVE(%r1)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfsrr1	%r31			/* test kernel mode */
	mfsprg	%r1,1                   /* restore SP */
	bla	s_isitrap
_C_LABEL(isisize) =	.-_C_LABEL(isitrap)

/*
 * This one for the external interrupt handler.
 */
	.globl	_C_LABEL(extint),_C_LABEL(extsize)
	.type	_C_LABEL(extint),@@function
	.type	_C_LABEL(extsize),@@object
_C_LABEL(extint):
	mtsprg	1,%r1			/* save SP */
nop32_5s:
	mfmsr	%r1
	clrldi	%r1,%r1,1
	mtmsrd	%r1
nop32_5e:
	GET_CPUINFO(%r1)
	stmw	%r28,CI_TEMPSAVE(%r1)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	lwz	%r31,CI_INTRDEPTH(%r1)	/* were we already running on intstk? */
	addic.	%r31,%r31,1
	stw	%r31,CI_INTRDEPTH(%r1)
	lwz	%r1,CI_INTSTK(%r1)	/* get interrupt stack */
	beq	1f
	mfsprg	%r1,1			/* yes, get old SP */
1:
	ba	extintr
_C_LABEL(extsize) =	.-_C_LABEL(extint)

/*
 * And this one for the decrementer interrupt handler.
 */
	.globl	_C_LABEL(decrint),_C_LABEL(decrsize)
	.type	_C_LABEL(decrint),@@function
	.type	_C_LABEL(decrsize),@@object
_C_LABEL(decrint):
	mtsprg	1,%r1			/* save SP */
nop32_6s:
	mfmsr	%r1
	clrldi	%r1,%r1,1
	mtmsrd	%r1
nop32_6e:
	GET_CPUINFO(%r1)
	stmw	%r28,CI_TEMPSAVE(%r1)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	lwz	%r31,CI_INTRDEPTH(%r1)	/* were we already running on intstk? */
	addic.	%r31,%r31,1
	stw	%r31,CI_INTRDEPTH(%r1)
	lwz	%r1,CI_INTSTK(%r1)	/* get interrupt stack */
	beq	1f
	mfsprg	%r1,1			/* yes, get old SP */
1:
	ba	decrintr
_C_LABEL(decrsize) =	.-_C_LABEL(decrint)

/*
 * Now the tlb software load for 603 processors:
 * (Code essentially from the 603e User Manual, Chapter 5)
 */
#define	DMISS	976
#define	DCMP	977
#define	HASH1	978
#define	HASH2	979
#define	IMISS	980
#define	ICMP	981
#define	RPA	982

#define	bdneq	bdnzf 2,
#define	tlbli	.long	0x7c0007e4+0x800*
#define	tlbld	.long	0x7c0007a4+0x800*

	.globl	_C_LABEL(tlbimiss),_C_LABEL(tlbimsize)
	.type	_C_LABEL(tlbimiss),@@function
	.type	_C_LABEL(tlbimsize),@@object
_C_LABEL(tlbimiss):
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,ICMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
1:
	mtctr	%r1			/* load counter */
2:
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
	bdneq	2b			/* loop if not eq */
	bne	3f			/* not found */
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	andi.	%r3,%r1,8		/* check G-bit */
	bne	4f			/* if guarded, take ISI */
	mtctr	%r0			/* restore counter */
	mfspr	%r0,IMISS		/* get the miss address for the tlbli */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	ori	%r1,%r1,0x100		/* set the reference bit */
	mtspr	RPA,%r1			/* set the pte */
	srwi	%r1,%r1,8		/* get byte 7 of pte */
	tlbli	0			/* load the itlb */
	stb	%r1,6(%r2)		/* update page table */
	rfi

3:	/* not found in pteg */
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
	bne	5f
	mfspr	%r2,HASH2		/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8		/* predec pointer */
	b	1b
4:	/* guarded */
	mfsrr1	%r3
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	addis	%r2,%r2,0x800		/* set srr<4> to flag prot violation */
	b	6f
5:	/* not found anywhere */
	mfsrr1	%r3
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	addis	%r2,%r2,0x4000		/* set srr1<1> to flag pte not found */
6:
	mtctr	%r0			/* restore counter */
	mtsrr1	%r2
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
	isync
	ba	EXC_ISI
_C_LABEL(tlbimsize) =	.-_C_LABEL(tlbimiss)

	.globl	_C_LABEL(tlbdlmiss),_C_LABEL(tlbdlmsize)
	.type	_C_LABEL(tlbdlmiss),@@function
	.type	_C_LABEL(tlbdlmsize),@@object
_C_LABEL(tlbdlmiss):
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,DCMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
1:
	mtctr	%r1			/* load counter */
2:
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
	bdneq	2b			/* loop if not eq */
	bne	3f			/* not found */
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	mtctr	%r0			/* restore counter */
	mfspr	%r0,DMISS		/* get the miss address for the tlbld */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	ori	%r1,%r1,0x100		/* set the reference bit */
	mtspr	RPA,%r1			/* set the pte */
	srwi	%r1,%r1,8		/* get byte 7 of pte */
	tlbld	0			/* load the dtlb */
	stb	%r1,6(%r2)		/* update page table */
	rfi

3:	/* not found in pteg */
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
	bne	5f
	mfspr	%r2,HASH2		/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8		/* predec pointer */
	b	1b
5:	/* not found anywhere */
	mfsrr1	%r3
	lis	%r1,0x4000		/* set dsisr<1> to flag pte not found */
	mtctr	%r0			/* restore counter */
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	mtsrr1	%r2
	mtdsisr	%r1			/* load the dsisr */
	mfspr	%r1,DMISS		/* get the miss address */
	mtdar	%r1			/* put in dar */
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
	isync
	ba	EXC_DSI
_C_LABEL(tlbdlmsize) =	.-_C_LABEL(tlbdlmiss)

	.globl	_C_LABEL(tlbdsmiss),_C_LABEL(tlbdsmsize)
	.type	_C_LABEL(tlbdsmiss),@@function
	.type	_C_LABEL(tlbdsmsize),@@object
_C_LABEL(tlbdsmiss):
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,DCMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
1:
	mtctr	%r1			/* load counter */
2:
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
	bdneq	2b			/* loop if not eq */
	bne	3f			/* not found */
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	andi.	%r3,%r1,0x80		/* check the C-bit */
	beq	4f
5:
	mtctr	%r0			/* restore counter */
	mfspr	%r0,DMISS		/* get the miss address for the tlbld */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	mtspr	RPA,%r1			/* set the pte */
	tlbld	0			/* load the dtlb */
	rfi

3:	/* not found in pteg */
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
	bne	5f
	mfspr	%r2,HASH2		/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8		/* predec pointer */
	b	1b
4:	/* found, but C-bit = 0 */
	rlwinm.	%r3,%r1,30,0,1		/* test PP */
	bge-	7f
	andi.	%r3,%r1,1
	beq+	8f
9:	/* found, but protection violation (PP==00)*/
	mfsrr1	%r3
	lis	%r1,0xa00	/* indicate protection violation on store */
	b	1f
7:	/* found, PP=1x */
	mfspr	%r3,DMISS		/* get the miss address */
	mfsrin	%r1,%r3			/* get the segment register */
	mfsrr1	%r3
	rlwinm	%r3,%r3,18,31,31	/* get PR-bit */
	rlwnm.	%r1,%r1,%r3,1,1		/* get the key */
	bne-	9b			/* protection violation */
8:	/* found, set reference/change bits */
	lwz	%r1,4(%r2)		/* reload tlb entry */
	ori	%r1,%r1,0x180
	sth	%r1,6(%r2)
	b	5b
5:	/* not found anywhere */
	mfsrr1	%r3
	lis	%r1,0x4200		/* set dsisr<1> to flag pte not found */
					/* dsisr<6> to flag store */
1:
	mtctr	%r0			/* restore counter */
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	mtsrr1	%r2
	mtdsisr	%r1			/* load the dsisr */
	mfspr	%r1,DMISS		/* get the miss address */
	mtdar	%r1			/* put in dar */
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
	isync
	ba	EXC_DSI
_C_LABEL(tlbdsmsize) =	.-_C_LABEL(tlbdsmiss)

#ifdef DDB
/*
 * In case of DDB we want a separate trap catcher for it
 */
	.globl	_C_LABEL(ddblow),_C_LABEL(ddbsize)
_C_LABEL(ddblow):
	mtsprg	1,%r1			/* save SP */
nop32_7s:
	mfmsr	%r1
	clrldi	%r1,%r1,1
	mtmsrd	%r1
nop32_7e:
	GET_CPUINFO(%r1)
	stmw	%r28,CI_DDBSAVE(%r1)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	GET_CPUINFO(%r30)
	lwz	%r30,CI_INTSTK(%r30)	/* get interrupt stack */
	addi	%r1,%r30,(SPILLSTK+DDBSTK)
	bla	ddbtrap
_C_LABEL(ddbsize) =	.-_C_LABEL(ddblow)
#endif  /* DDB */

/*
 * If this interrupt occured between the runqueue check and the setting
 * of the POW bit, do no enter to sleep.  We do that in order to process
 * the result of this interrupt directly and not when coming back from
 * sleep, when the next clock tick or interrupt will fire.
 */
#define CPU_IDLE_CHECK(sr1,sr2,sr3,rSRR0,flag)				\
	GET_CPUINFO(sr1);						\
	lwz	sr2,CI_FLAGS(sr1);					\
	andi.	sr3,sr2,flag@@l;						\
	beq	1f;							\
	andi.	sr2,sr2,~flag@@l;					\
	stw	sr2,CI_FLAGS(sr1);					\
	lis	rSRR0,_C_LABEL(idledone)@@ha;				\
	addi	rSRR0,rSRR0,_C_LABEL(idledone)@@l;			\
1:

/*
 * FRAME_SETUP assumes:
 *	SPRG1		SP (1)
 *	savearea	r28-r31,DAR,DSISR	(DAR & DSISR only for DSI traps)
 *	28		LR
 *	29		CR
 *	1		kernel stack
 *	LR		trap type
 *	SRR0/1		as at start of trap
 */
#define FRAME_SETUP(savearea)	FRAME_SETUP_FLAG(savearea, CI_FLAGS_SLEEPING)

#define	FRAME_SETUP_FLAG(savearea, flag)				\
/* Have to enable translation to allow access of kernel stack: */	\
	GET_CPUINFO(%r31);						\
	mfsrr0	%r30;							\
	stw	%r30,savearea+24(%r31);					\
	mfsrr1	%r30;							\
	stw	%r30,savearea+28(%r31);					\
	/* load all kernel segment registers. */			\
	lis	%r31,_C_LABEL(kernel_pmap_)@@ha;				\
	addi	%r31,%r31,_C_LABEL(kernel_pmap_)@@l;			\
	lwz	%r30,0(%r31);	mtsr	0,%r30;				\
	lwz	%r30,4(%r31);	mtsr	1,%r30;				\
	lwz	%r30,8(%r31);	mtsr	2,%r30;				\
	lwz	%r30,12(%r31);	mtsr	3,%r30;				\
	lwz	%r30,16(%r31);	mtsr	4,%r30;				\
	lwz	%r30,20(%r31);	mtsr	5,%r30;				\
	lwz	%r30,24(%r31);	mtsr	6,%r30;				\
	lwz	%r30,28(%r31);	mtsr	7,%r30;				\
	lwz	%r30,32(%r31);	mtsr	8,%r30;				\
	lwz	%r30,36(%r31);	mtsr	9,%r30;				\
	lwz	%r30,40(%r31);	mtsr	10,%r30;			\
	lwz	%r30,44(%r31);	mtsr	11,%r30;			\
	lwz	%r30,48(%r31);	mtsr	12,%r30;			\
/*	lwz	%r30,52(%r31);	mtsr 13,%r30; - dont load user SR - XXX? */ \
	lwz	%r30,56(%r31);	mtsr	14,%r30;			\
	lwz	%r30,60(%r31);	mtsr	15,%r30;			\
	mfmsr	%r30;							\
	ori	%r30,%r30,(PSL_DR|PSL_IR);				\
	mtmsr	%r30;							\
	isync;								\
	mfsprg	%r31,1;							\
	stwu	%r31,-FRAMELEN(%r1);					\
	stw	%r0,FRAME_0+8(%r1);					\
	stw	%r31,FRAME_1+8(%r1);					\
	stw	%r2,FRAME_2+8(%r1);					\
	stw	%r28,FRAME_LR+8(%r1);					\
	stw	%r29,FRAME_CR+8(%r1);					\
	GET_CPUINFO(%r2);						\
	lmw	%r28,savearea(%r2);					\
	stmw	%r3,FRAME_3+8(%r1);					\
	lmw	%r28,savearea+16(%r2);					\
	mfxer	%r3;							\
	mfctr	%r4;							\
	mflr	%r5;							\
	andi.	%r5,%r5,0xff00;						\
	stw	%r3,FRAME_XER+8(%r1);					\
	stw	%r4,FRAME_CTR+8(%r1);					\
	stw	%r5,FRAME_EXC+8(%r1);					\
	stw	%r28,FRAME_DAR+8(%r1);					\
	stw	%r29,FRAME_DSISR+8(%r1);				\
	CPU_IDLE_CHECK(%r5,%r6,%r0,%r30,flag)				\
	stw	%r30,FRAME_SRR0+8(%r1);					\
	stw	%r31,FRAME_SRR1+8(%r1)

#define	FRAME_LEAVE(savearea)						\
/* Now restore regs: */							\
	lwz	%r2,FRAME_SRR0+8(%r1);					\
	lwz	%r3,FRAME_SRR1+8(%r1);					\
	lwz	%r4,FRAME_CTR+8(%r1);					\
	lwz	%r5,FRAME_XER+8(%r1);					\
	lwz	%r6,FRAME_LR+8(%r1);					\
	GET_CPUINFO(%r7);						\
	stw	%r2,savearea(%r7);					\
	stw	%r3,savearea+4(%r7);					\
	lwz	%r7,FRAME_CR+8(%r1);					\
	mtctr	%r4;							\
	mtxer	%r5;							\
	mtlr	%r6;							\
	mtsprg	1,%r7;			/* save cr */			\
	lmw	%r2,FRAME_2+8(%r1);					\
	lwz	%r0,FRAME_0+8(%r1);					\
	lwz	%r1,FRAME_1+8(%r1);					\
	mtsprg	2,%r2;			/* save r2 & r3 */		\
	mtsprg	3,%r3;							\
/* Disable translation, machine check and recoverability: */		\
	mfmsr	%r2;							\
	lis	%r3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@ha;			\
	addi	%r3,%r3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@l;		\
	andc	%r2,%r2,%r3;						\
	mtmsr	%r2;							\
	isync;								\
/* Decide whether we return to user mode: */				\
	GET_CPUINFO(%r2);						\
	lwz	%r3,savearea+4(%r2);					\
	mtcr	%r3;							\
	bc	4,17,1f;		/* branch if PSL_PR is false */	\
/* Restore user & kernel access SR: */					\
	lwz	%r2,CI_CURPM(%r2);	/* get real address of pmap */	\
	lwz	%r3,0(%r2);	mtsr	0,%r3;				\
	lwz	%r3,4(%r2);	mtsr	1,%r3;				\
	lwz	%r3,8(%r2);	mtsr	2,%r3;				\
	lwz	%r3,12(%r2);	mtsr	3,%r3;				\
	lwz	%r3,16(%r2);	mtsr	4,%r3;				\
	lwz	%r3,20(%r2);	mtsr	5,%r3;				\
	lwz	%r3,24(%r2);	mtsr	6,%r3;				\
	lwz	%r3,28(%r2);	mtsr	7,%r3;				\
	lwz	%r3,32(%r2);	mtsr	8,%r3;				\
	lwz	%r3,36(%r2);	mtsr	9,%r3;				\
	lwz	%r3,40(%r2);	mtsr	10,%r3;				\
	lwz	%r3,44(%r2);	mtsr	11,%r3;				\
	lwz	%r3,48(%r2);	mtsr	12,%r3;				\
	lwz	%r3,52(%r2);	mtsr	13,%r3;				\
	lwz	%r3,56(%r2);	mtsr	14,%r3;				\
	lwz	%r3,60(%r2);	mtsr	15,%r3;				\
1:	mfsprg	%r2,1;			/* restore cr */		\
	mtcr	%r2;							\
	GET_CPUINFO(%r2);						\
	lwz	%r3,savearea(%r2);					\
	mtsrr0	%r3;							\
	lwz	%r3,savearea+4(%r2);					\
	mtsrr1	%r3;							\
	mfsprg	%r2,2;			/* restore r2 & r3 */		\
	mfsprg	%r3,3

/*
 * Preamble code for DSI/ISI traps
 */
disitrap:
	GET_CPUINFO(%r1)
	lmw	%r30,CI_DISISAVE(%r1)
	stmw	%r30,CI_TEMPSAVE(%r1)
	lmw	%r30,CI_DISISAVE+8(%r1)
	stmw	%r30,CI_TEMPSAVE+8(%r1)
	mfdar	%r30
	mfdsisr	%r31
	stmw	%r30,CI_TEMPSAVE+16(%r1)
realtrap:
	/* Test whether we already had PR set */
	mfsrr1	%r1
	mtcr	%r1
	/* restore SP (might have been overwritten) */
	mfsprg	%r1,1
	bc	4,17,s_trap		/* branch if PSL_PR is false */
	GET_CPUINFO(%r1)
	lwz	%r1,CI_CURPCB(%r1)
	addi	%r1,%r1,USPACE		/* stack is top of user struct */
/*
 * Now the common trap catching code.
 */
	.globl	s_trap
s_trap:
	FRAME_SETUP(CI_TEMPSAVE)
/* Now we can recover interrupts again: */
	mfmsr	%r7
	mfsrr1	%r31
	andi.	%r31,%r31,PSL_EE	/* restore EE from previous context */
	or	%r7,%r7,%r31
	ori	%r7,%r7,(PSL_ME|PSL_RI)
	mtmsr	%r7
	isync
/* Call C trap code: */
trapagain:
	addi	%r3,%r1,8
	bl	_C_LABEL(trap)

	.globl	trapexit
trapexit:
/* Disable interrupts: */
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3
	isync
/* Test AST pending: */
	lwz	%r5,FRAME_SRR1+8(%r1)
	mtcr	%r5
	bc	4,17,1f			/* branch if PSL_PR is false */
	GET_CPUINFO(%r3)
	lwz	%r4,CI_CURPROC(%r3)
	lwz	%r4,P_MD_ASTPENDING(%r4)
	andi.	%r4,%r4,1
	beq	1f
	li	%r6,EXC_AST
	stw	%r6,FRAME_EXC+8(%r1)
	b	trapagain
1:
	FRAME_LEAVE(CI_TEMPSAVE)
rfi1:	rfi

/*
 * Child comes here at the end of a fork.
 * Mostly similar to the above.
 */
	.globl	_C_LABEL(fork_trampoline)
	.type	_C_LABEL(fork_trampoline),@@function
_C_LABEL(fork_trampoline):
#ifdef MULTIPROCESSOR
	bl	_C_LABEL(proc_trampoline_mp)
#endif
	li	%r3,0
	bl	_C_LABEL(lcsplx)
	mtlr	%r31
	mr	%r3,%r30
	blrl				/* jump indirect to r31 */
	b	trapexit

/*
 * DSI second stage fault handler
 */
s_dsitrap:
	mfdsisr	%r31			/* test if this is spill fault */
	mtcr	%r31
	mtsprg	1,%r1			/* save SP */
	bc	4,1,disitrap		/* branch if table miss is false */
	GET_CPUINFO(%r30)
	lwz	%r30,CI_INTSTK(%r30)	/* get interrupt stack */
	addi	%r1,%r30,SPILLSTK
	stwu	%r1,-52(%r1)
	stw	%r0,48(%r1)		/* save non-volatile registers */
	stw	%r3,44(%r1)
	stw	%r4,40(%r1)
	stw	%r5,36(%r1)
	stw	%r6,32(%r1)
	stw	%r7,28(%r1)
	stw	%r8,24(%r1)
	stw	%r9,20(%r1)
	stw	%r10,16(%r1)
	stw	%r11,12(%r1)
	stw	%r12,8(%r1)
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30
	mflr	%r30			/* save trap type */
	mfctr	%r31			/* & CTR */
	mfdar	%r7
	mfsrr1	%r4
	mfdsisr	%r5
	li	%r6, 0
s_pte_spill:
	andi.	%r0,%r4,PSL_PR
	li	%r3,0
	bne	1f
	mr	%r3,%r7
	bl	_C_LABEL(pte_spill_r)	/* try a spill */
1:
	cmpwi	0,%r3,0
	mtctr	%r31			/* restore CTR */
	mtlr	%r30			/* and trap type */
	mfsprg	%r31,2			/* get saved XER */
	mtxer	%r31			/* restore XER */
	lwz	%r12,8(%r1)		/* restore non-volatile registers */
	lwz	%r11,12(%r1)
	lwz	%r10,16(%r1)
	lwz	%r9,20(%r1)
	lwz	%r8,24(%r1)
	lwz	%r7,28(%r1)
	lwz	%r6,32(%r1)
	lwz	%r5,36(%r1)
	lwz	%r4,40(%r1)
	lwz	%r3,44(%r1)
	lwz	%r0,48(%r1)
	beq	disitrap
	mtcr	%r29			/* restore CR */
	mtlr	%r28			/* restore LR */
	GET_CPUINFO(%r1)
	lmw	%r28,CI_DISISAVE(%r1)	/* restore r28-r31 */
	mfsprg	%r1,1			/* restore SP */
rfi2:	rfi				/* return to trapped code */

/*
 * ISI second stage fault handler
 */
s_isitrap:
	mfsrr1	%r31			/* test if this may be a spill fault */
	mtcr	%r31
	mtsprg	1,%r1			/* save SP */
	bc	4,1,disitrap		/* branch if table miss is false */
	GET_CPUINFO(%r30)
	lwz	%r30,CI_INTSTK(%r30)	/* get interrupt stack */
	addi	%r1,%r30,SPILLSTK
	stwu	%r1,-52(%r1)
	stw	%r0,48(%r1)		/* save non-volatile registers */
	stw	%r3,44(%r1)
	stw	%r4,40(%r1)
	stw	%r5,36(%r1)
	stw	%r6,32(%r1)
	stw	%r7,28(%r1)
	stw	%r8,24(%r1)
	stw	%r9,20(%r1)
	stw	%r10,16(%r1)
	stw	%r11,12(%r1)
	stw	%r12,8(%r1)
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30
	mflr	%r30			/* save trap type */
	mfctr	%r31			/* & ctr */
	mfsrr0	%r7
	mfsrr1	%r4
	li	%r5, 0
	li	%r6, 1
	b	s_pte_spill		/* above */

/*
 * External interrupt second level handler
 */
#define	INTRENTER							\
/* Save non-volatile registers: */					\
	stwu	%r1,-88(%r1);		/* temporarily */		\
	stw	%r0,84(%r1);						\
	mfsprg	%r0,1;			/* get original SP */		\
	stw	%r0,0(%r1);		/* and store it */		\
	stw	%r3,80(%r1);						\
	stw	%r4,76(%r1);						\
	stw	%r5,72(%r1);						\
	stw	%r6,68(%r1);						\
	stw	%r7,64(%r1);						\
	stw	%r8,60(%r1);						\
	stw	%r9,56(%r1);						\
	stw	%r10,52(%r1);						\
	stw	%r11,48(%r1);						\
	stw	%r12,44(%r1);						\
	stw	%r28,40(%r1);		/* saved LR */			\
	stw	%r29,36(%r1);		/* saved CR */			\
	stw	%r30,32(%r1);		/* saved XER */			\
	GET_CPUINFO(%r4);						\
	lmw	%r28,CI_TEMPSAVE(%r4);	/* restore r28-r31 */		\
	mfctr	%r6;							\
	lwz	%r5,CI_INTRDEPTH(%r4);			\
	mfsrr0	%r4;							\
	mfsrr1	%r3;							\
	stw	%r6,28(%r1);						\
	stw	%r5,20(%r1);						\
	stw	%r4,12(%r1);						\
	stw	%r3,8(%r1);						\
/* load all kernel segment registers. */				\
	lis	3,_C_LABEL(kernel_pmap_)@@ha;                            \
	addi	3,3,_C_LABEL(kernel_pmap_)@@l;                           \
	lwz	%r5,0(%r3);	mtsr 0,%r5;				\
	lwz	%r5,4(%r3);	mtsr 1,%r5;				\
	lwz	%r5,8(%r3);	mtsr 2,%r5;				\
	lwz	%r5,12(%r3);	mtsr 3,%r5;				\
	lwz	%r5,16(%r3);	mtsr 4,%r5;				\
	lwz	%r5,20(%r3);	mtsr 5,%r5;				\
	lwz	%r5,24(%r3);	mtsr 6,%r5;				\
	lwz	%r5,28(%r3);	mtsr 7,%r5;				\
	lwz	%r5,32(%r3);	mtsr 8,%r5;				\
	lwz	%r5,36(%r3);	mtsr 9,%r5;				\
	lwz	%r5,40(%r3);	mtsr 10,%r5;				\
	lwz	%r5,44(%r3);	mtsr 11,%r5;				\
	lwz	%r5,48(%r3);	mtsr 12,%r5;				\
/*	lwz	%r5,52(%r3);	mtsr 13,%r5;	- dont load user SR - XXX? */ \
	lwz	%r5,56(%r3);	mtsr 14,%r5;				\
	lwz	%r5,60(%r3);	mtsr 15,%r5;				\
/* interrupts are recoverable here, and enable translation */		\
	mfmsr	%r5;							\
	ori	%r5,%r5,(PSL_IR|PSL_DR|PSL_RI);				\
	mtmsr	%r5;							\
	isync

	.globl	_C_LABEL(extint_call)
	.type	_C_LABEL(extint_call),@@function
extintr:
	INTRENTER
_C_LABEL(extint_call):
	bl	_C_LABEL(extint_call)		/* to be filled in later */
intr_exit:
/* Disable interrupts (should already be disabled) and MMU here: */
	mfmsr	%r3
	andi.	%r3,%r3,~(PSL_EE|PSL_ME|PSL_RI|PSL_DR|PSL_IR)@@l
	mtmsr	%r3
	isync
/* restore possibly overwritten registers: */
	lwz	%r12,44(%r1)
	lwz	%r11,48(%r1)
	lwz	%r10,52(%r1)
	lwz	%r9,56(%r1)
	lwz	%r8,60(%r1)
	lwz	%r7,64(%r1)
	lwz	%r6,8(%r1)
	lwz	%r5,12(%r1)
	lwz	%r4,28(%r1)
	lwz	%r3,32(%r1)
	mtsrr1	%r6
	mtsrr0	%r5
	mtctr	%r4
	mtxer	%r3

	GET_CPUINFO(%r5)
	lwz	%r4,CI_INTRDEPTH(%r5)
	addi	%r4,%r4,-1		/* adjust reentrancy count */
	stw	%r4,CI_INTRDEPTH(%r5)

/* Returning to user mode? */
	mtcr	%r6			/* saved SRR1 */
	bc	4,17,1f			/* branch if PSL_PR is false */
	lwz	%r3,CI_CURPM(%r5)	/* get current pmap real address */
	/* reload all segment registers. */
	lwz	%r4,0(3);	mtsr 0,%r4;
	lwz	%r4,4(3);	mtsr 1,%r4;
	lwz	%r4,8(3);	mtsr 2,%r4;
	lwz	%r4,12(3);	mtsr 3,%r4;
	lwz	%r4,16(3);	mtsr 4,%r4;
	lwz	%r4,20(3);	mtsr 5,%r4;
	lwz	%r4,24(3);	mtsr 6,%r4;
	lwz	%r4,28(3);	mtsr 7,%r4;
	lwz	%r4,32(3);	mtsr 8,%r4;
	lwz	%r4,36(3);	mtsr 9,%r4;
	lwz	%r4,40(3);	mtsr 10,%r4;
	lwz	%r4,44(3);	mtsr 11,%r4;
	lwz	%r4,48(3);	mtsr 12,%r4;
	lwz	%r4,52(3);	mtsr 13,%r4;
	lwz	%r4,56(3);	mtsr 14,%r4;
	lwz	%r4,60(3);	mtsr 15,%r4;
	lwz	%r4,CI_CURPROC(%r5)
	lwz	%r4,P_MD_ASTPENDING(%r4)	/* Test AST pending */
	andi.	%r4,%r4,1
	beq	1f
/* Setup for entry to realtrap: */
	lwz	%r3,0(%r1)		/* get saved SP */
	mtsprg	1,%r3
	li	%r6,EXC_AST
	stmw	%r28,CI_TEMPSAVE(%r5)	/* establish tempsave again */
	mtlr	%r6
	lwz	%r28,40(%r1)		/* saved LR */
	lwz	%r29,36(%r1)		/* saved CR */
	lwz	%r6,68(%r1)
	lwz	%r5,72(%r1)
	lwz	%r4,76(%r1)
	lwz	%r3,80(%r1)
	lwz	%r0,84(%r1)
	b	realtrap
1:
/* Here is the normal exit of extintr: */
	lwz	%r5,36(%r1)
	lwz	%r6,40(%r1)
	mtcr	%r5
	mtlr	%r6
	lwz	%r6,68(%r1)
	lwz	%r5,72(%r1)
	lwz	%r4,76(%r1)
	lwz	%r3,80(%r1)
	lwz	%r0,84(%r1)
	lwz	%r1,0(%r1)
rfi3:	rfi

/*
 * Decrementer interrupt second level handler
 */
	.globl	decrintr
decrintr:
	INTRENTER
	addi	%r3,%r1,8			/* intr frame */
	bl	_C_LABEL(decr_intr)
	b	intr_exit


/*
 * int setfault()
 *
 * Similar to setjmp to setup for handling faults on accesses to user memory.
 * Any routine using this may only call bcopy, either the form below,
 * or the (currently used) C code optimized, so it doesn't use any non-volatile
 * registers.
 */
	.globl	_C_LABEL(setfault)
	.type	_C_LABEL(setfault),@@function
_C_LABEL(setfault):
	mflr	%r0
	mfcr	%r12
	GET_CPUINFO(%r4)
	lwz	%r4,CI_CURPCB(%r4)
	stw	%r3,PCB_FAULT(%r4)
	stw	%r0,0(%r3)
	stw	%r1,4(%r3)
	stmw	%r12,8(%r3)
	li	%r3,0
	blr

/*
 * The following code gets copied to the top of the user stack on process
 * execution.  It does signal trampolining on signal delivery.
 *
 * On entry r1 points to a struct sigframe at bottom of current stack.
 * All other registers are unchanged.
 */
	.section .rodata
	.globl	_C_LABEL(sigcode),_C_LABEL(esigcode)
	.type	_C_LABEL(sigcode),@@function
	.type	_C_LABEL(esigcode),@@function
_C_LABEL(sigcode):
	addi	%r1,%r1,-((16+FPSIG_SIZEOF+15)& ~0xf)		/* reserved space for callee */
	addi	%r6,%r1,8
	stfd	%f0,0(%r6)
	stfd	%f1,8(%r6)
	stfd	%f2,16(%r6)
	stfd	%f3,24(%r6)
	stfd	%f4,32(%r6)
	stfd	%f5,40(%r6)
	stfd	%f6,48(%r6)
	stfd	%f7,56(%r6)
	stfd	%f8,64(%r6)
	stfd	%f9,72(%r6)
	stfd	%f10,80(%r6)
	stfd	%f11,88(%r6)
	stfd	%f12,96(%r6)
	stfd	%f13,104(%r6)
	mffs	%f0
	stfd	%f0,112(%r6)
	lfd	%f0,0(%r6)	/* restore the clobbered register */
	blrl
	addi	%r6,%r1,8
	lfd	%f0,112(%r6)
	mtfsf	0xff,%f0
	lfd	%f0,0(%r6)
	lfd	%f1,8(%r6)
	lfd	%f2,16(%r6)
	lfd	%f3,24(%r6)
	lfd	%f4,32(%r6)
	lfd	%f5,40(%r6)
	lfd	%f6,48(%r6)
	lfd	%f7,56(%r6)
	lfd	%f8,64(%r6)
	lfd	%f9,72(%r6)
	lfd	%f10,80(%r6)
	lfd	%f11,88(%r6)
	lfd	%f12,96(%r6)
	lfd	%f13,104(%r6)
	addi	%r3,%r1,((16+FPSIG_SIZEOF+15)&~0xf)+SF_SC	/* compute &sf_sc */
	li	%r0,SYS_sigreturn
	sc				/* sigreturn(scp) */
	.globl  _C_LABEL(sigcoderet)
_C_LABEL(sigcoderet):
	li	%r0,SYS_exit
	sc				/* exit(errno) */
_C_LABEL(esigcode):

	.globl  _C_LABEL(sigfill)
_C_LABEL(sigfill):
	.long	0		# illegal
_C_LABEL(esigfill):
	.align	4
	.globl	_C_LABEL(sigfillsiz)
_C_LABEL(sigfillsiz):
	.long	_C_LABEL(esigfill) - _C_LABEL(sigfill)

	.text

#ifdef DDB
/*
 * Deliberate entry to ddbtrap
 */
	.globl	_C_LABEL(ddb_trap)
_C_LABEL(ddb_trap):
	mtsprg	1,%r1
	mfmsr	%r3
	mtsrr1	%r3
	andi.	%r3,%r3,~(PSL_EE|PSL_ME)@@l
	mtmsr	%r3				/* disable interrupts */
	isync
	GET_CPUINFO(%r3)
	stmw	%r28,CI_DDBSAVE(%r3)

	mflr	%r28
	li	%r29,EXC_BPT
	mtlr	%r29
	mfcr	%r29
	mtsrr0	%r28

/*
 * Now the ddb trap catching code.
 */
ddbtrap:
	/*
	 * Do not let FRAME_SETUP() change the return address of, and
	 * corrupt, this frame.
	 */
	FRAME_SETUP_FLAG(CI_DDBSAVE, 0)
/* Call C trap code: */
	addi	%r3,%r1,8
	bl	_C_LABEL(db_trap_glue)
	or.	%r3,%r3,%r3
	bne	ddbleave
/* This wasn't for DDB, so switch to real trap: */
	lwz	%r3,FRAME_EXC+8(%r1)	/* save exception */
	GET_CPUINFO(%r4)
	stw	%r3,CI_DDBSAVE+8(%r4)
	FRAME_LEAVE(CI_DDBSAVE)
	mtsprg	1,%r1			/* prepare for entrance to realtrap */
	GET_CPUINFO(%r1)
	stmw	%r28,CI_TEMPSAVE(%r1)
	mflr	%r28
	mfcr	%r29
	lwz	%r31,CI_DDBSAVE+8(%r1)
	mtlr	%r31
	b	realtrap
ddbleave:
	FRAME_LEAVE(CI_DDBSAVE)
rfi4:	rfi
#endif /* DDB */

	.globl  _C_LABEL(rfi_inst)
_C_LABEL(rfi_inst):
	rfi
	.globl  _C_LABEL(rfid_inst)
_C_LABEL(rfid_inst):
	rfid
	.globl  _C_LABEL(nop_inst)
 _C_LABEL(nop_inst):
	nop

	.globl  _C_LABEL(rfi_start)
_C_LABEL(rfi_start):
	.long	rfi1, rfi1 + 4
	.long	rfi2, rfi2 + 4
	.long	rfi3, rfi3 + 4
#ifdef DDB
	.long	rfi4, rfi4 + 4
#endif
	.long	0, 0


	.globl  _C_LABEL(nopbat_start)
_C_LABEL(nopbat_start):
	.long	nopbat_1s, nopbat_1e
	.long	0, 0

	.globl  _C_LABEL(nop32_start)
_C_LABEL(nop32_start):
	.long	nop32_1s, nop32_1e
	.long	nop32_2s, nop32_2e
	.long	nop32_3s, nop32_3e
	.long	nop32_4s, nop32_4e
	.long	nop32_5s, nop32_5e
	.long	nop32_6s, nop32_6e
#ifdef DDB
	.long	nop32_7s, nop32_7e
#endif
	.long	0, 0
@


1.55
log
@Place a cpu-dependent trap/illegal instruction over the remainder of the
sigtramp page, so that it will generate a nice kernel fault if touched.
While here, move most of the sigtramps to the .rodata segment, because
they are not executed in the kernel.
Also some preparation for sliding the actual sigtramp forward (will need
some gdb changes)
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.54 2016/05/10 18:39:46 deraadt Exp $	*/
d51 1
a51 13
/*
 * Globals
 */
	.globl	_C_LABEL(esym),_C_LABEL(proc0paddr)
	.type	_C_LABEL(esym),@@object
	.type	_C_LABEL(proc0paddr),@@object
	.data
_C_LABEL(esym):		.long	0	/* end of symbol table */
_C_LABEL(proc0paddr):	.long	0	/* proc0 p_addr */

fwargsave:
			.long 0
			.long 0
a52 67
/*
 * Startup entry
 */
_ENTRY(_C_LABEL(kernel_text))
_ENTRY(_ASM_LABEL(start))
/* arguments to start
 * r1 - stack provided by firmware/bootloader
 * r3 - unused
 * r4 - unused
 * r5 - firmware pointer (NULL for PPC1bug)
 * r6 - arg list
 * r7 - length
 */
	.globl	start
	.type start,@@function
start:
	lis	%r3, fwargsave@@ha
	stw	%r6, fwargsave@@l(%r3)
	stw	%r7, fwargsave@@l+4(%r3)
	bl	ofw_init
	li	%r0,0
	mtmsr	%r0			/* Disable FPU/MMU/exceptions */
	isync

/* compute end of kernel memory */
	lis	%r8,_end@@ha
	addi	%r8,%r8,_end@@l
	lis	%r3, fwargsave@@ha
	lwz	%r6, fwargsave@@l(%r3)
	lwz	%r7, fwargsave@@l+4(%r3)
#if defined(DDB)
	cmpwi	%r6, 0
	beq	1f
	add	%r9,%r6,%r7
	lwz	%r9, -4(%r9)
	cmpwi   %r9,0
	beq	1f
	lis	%r8,_C_LABEL(esym)@@ha
	stw	%r9,_C_LABEL(esym)@@l(%r8)
	mr	%r8, %r9
1:
#endif
	li	%r9,PGOFSET
	add	%r8,%r8,%r9
	andc	%r8,%r8,%r9
	lis	%r9,_C_LABEL(cpu_info)@@ha
	addi	%r9,%r9,_C_LABEL(cpu_info)@@l
	mtsprg	0,%r9
	addi	%r8,%r8,INTSTK
	stw	%r8,CI_INTSTK(%r9)
	li	%r0,-1
	stw	%r0,CI_INTRDEPTH(%r9)
	addi	%r8,%r8,SPILLSTK+DDBSTK	/* leave room for spillstk and ddbstk */
	lis	%r9,_C_LABEL(proc0paddr)@@ha
	stw	%r8,_C_LABEL(proc0paddr)@@l(%r9)
	addi	%r1,%r8,USPACE-FRAMELEN	/* stackpointer for proc0 */
	mr	%r4,%r1			/* end of mem reserved for kernel */
	li	%r0,0
	stwu	%r0,-16(%r1)		/* end of stack chain */

	lis	%r3,start@@ha
	addi	%r3,%r3,start@@l
	mr	%r5,%r6			/* args string */
	bl	_C_LABEL(initppc)
	bl	_C_LABEL(main)
	b	_C_LABEL(OF_exit)

@


1.54
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.53 2016/04/25 07:58:14 mpi Exp $	*/
d1209 1
d1260 10
@


1.53
log
@Do not check if the CPU is inside the idle loop when enterting ddb(4).

This check only makes sense when a frame is saved for interrupts, not
for a (simulated) breakpoint.

This allows us to put breakpoints in interrupt context and have them
work if an interrupt fires while the CPU is idle.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.52 2016/02/28 11:56:40 mpi Exp $	*/
d1253 2
@


1.52
log
@Rename ddb_trap_glue() to db_trap_glue().

Let's keep the 'db_' prefix for all ddb(4) functions that should not be
instrumented.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.51 2015/11/15 17:10:53 miod Exp $	*/
d713 1
a713 1
#define CPU_IDLE_CHECK(sr1,sr2,sr3,rSRR0)				\
d716 1
a716 1
	andi.	sr3,sr2,CI_FLAGS_SLEEPING@@l;				\
d718 1
a718 1
	andi.	sr2,sr2,~CI_FLAGS_SLEEPING@@l;				\
d734 3
a736 1
#define	FRAME_SETUP(savearea)						\
d786 1
a786 1
	CPU_IDLE_CHECK(%r5,%r6,%r0,%r30)				\
a1272 10
	/*
	 * If we are already running in interrupt context, the CPU
	 * problably got interrupted while idle.  But since we are
	 * about to enter to ddb(8), do not let FRAME_SETUP() below
	 * change the return address of, and corrupt, this frame.
	 */
	lwz	%r28,CI_FLAGS(%r3)
	andi.	%r28,%r28,~CI_FLAGS_SLEEPING@@l
	stw	%r28,CI_FLAGS(%r3)

d1283 5
a1287 1
	FRAME_SETUP(CI_DDBSAVE)
@


1.51
log
@Make sure every mtmsr instruction disabling external interrupts is immediately
followed by an isync.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.50 2015/07/29 18:52:44 miod Exp $	*/
d1294 1
a1294 1
	bl	_C_LABEL(ddb_trap_glue)
@


1.50
log
@17 years ago, setfault() was modified to save the status register in the
faultbuf. But 1/ sr was only restored for machine check exceptions, and 2/ the
way it was saved was unsafe if interrupts were enabled, and could cause %r2
to be lost.

Discussing this with deraadt@@ at the end of c2k15, this was probably needed
for the old VI boards which were the target of the original powerpc port,
came with a worse-than-Genesi openfirmware. Since then, machine check
exceptions have been unheard of; or, if they happen, they do not need the
status register to be restored.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.49 2015/03/31 16:00:38 mpi Exp $	*/
d178 1
d227 1
d895 1
@


1.49
log
@Make it possisble to disable block address translation mechanism on
processors that support it.

Due to the way trap code is patched it is currently not possible to
enabled/disable BAT at runtime.

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.48 2014/10/27 21:56:57 kettenis Exp $	*/
a1187 1
	mfmsr	%r2
d1192 2
a1193 3
	stw	%r2,4(%r3)
	stw	%r1,8(%r3)
	stmw	%r12,12(%r3)
@


1.48
log
@Remove the spilling code for IBAT register and set up the first IBAT register
to cover the first 8 MB of memory such that it covers kernel .text and not
much else.  This is a first step towards W^X in the kernel for machines
with G4 and older processors.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.47 2014/10/18 22:36:36 kettenis Exp $	*/
d366 1
a366 1
nop64_1s:
d396 1
a396 1
nop64_1e:
d1335 3
a1337 3
	.globl  _C_LABEL(nop64_start)
_C_LABEL(nop64_start):
	.long	nop64_1s, nop64_1e
@


1.47
log
@Don't use %r1 to refer to bit 1.  No binary difference.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.46 2014/10/09 09:44:20 deraadt Exp $	*/
a419 20
nop64_2s:
	mtcr	%r31
	bc	12,17,1f		/* branch if PSL_PR is set */
	mfsrr0	%r31			/* get fault address */
	rlwinm	%r31,%r31,7,25,28		/* get segment * 8 */
	addis	%r31,%r31,_C_LABEL(battable)@@ha
	lwz	%r30,_C_LABEL(battable)@@l(%r31)	/* get batu */
	mtcr	%r30
	bc	4,30,1f			/* branch if supervisor valid is false */
	mtibatu	3,%r30
	lwz	%r30,_C_LABEL(battable)+4@@l(%r31)	/* get batl */
	mtibatl	3,%r30
	mtcr	%r29			/* restore CR */
	mtsprg	1,%r1
	GET_CPUINFO(%r1)
	lmw	%r28,CI_DISISAVE(%r1)	/* restore r28-r31 */
	mfsprg	%r1,1
	rfi				/* return to trapped code */
1:
nop64_2e:
a1337 1
	.long	nop64_2s, nop64_2e
@


1.46
log
@allow building a kernel without ddb
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.45 2014/09/06 10:45:29 mpi Exp $	*/
d1015 1
a1015 1
	bc	4,%r1,disitrap		/* branch if table miss is false */
@


1.45
log
@Rename ci_iactive into ci_flags, this field now holds the going-to-
sleep bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.44 2014/09/06 10:15:52 mpi Exp $	*/
d1349 1
d1351 1
d1369 1
d1371 1
@


1.44
log
@Rewrite cpu_idle & friends to not check and update the hid0 register
in the idle loop, in preparation for G5 support.

Only do a disable/enable interrupt dance if the running CPU supports a
sleep mode.

Fix entering ddb(8) from interrupt context by not modifying the return
address of the 'forced' trap frame.

While here, modify the existing logic to terminate prefetching of all
data streams if AltiVec is supported before setting the POW bit.

With inputs/explanations from drahn, looks ok to miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.43 2014/09/06 09:42:22 mpi Exp $	*/
d241 3
a243 3
	lwz	%r6,CI_IACTIVE(%r4)
	ori	%r6,%r6,CI_IACTIVE_SLEEPING@@l
	stw	%r6,CI_IACTIVE(%r4)
d257 1
a257 1
	 * restore interrupts to disabled, so CI_IACTIVE is only modified
d263 3
a265 3
	/* clear CI_IACTIVE_SLEEPING since sleeping is over */
	andi.	%r6,%r6,~CI_IACTIVE_SLEEPING@@l
	stw	%r6,CI_IACTIVE(%r4)
d733 2
a734 2
	lwz	sr2,CI_IACTIVE(sr1);					\
	andi.	sr3,sr2,CI_IACTIVE_SLEEPING@@l;				\
d736 2
a737 2
	andi.	sr2,sr2,~CI_IACTIVE_SLEEPING@@l;				\
	stw	sr2,CI_IACTIVE(sr1);					\
d1296 3
a1298 3
	lwz	%r28,CI_IACTIVE(%r3)
	andi.	%r28,%r28,~CI_IACTIVE_SLEEPING@@l
	stw	%r28,CI_IACTIVE(%r3)
@


1.43
log
@Rewrite the PowerPC stack dump routine to delimit the trap & interrupt
contexts with markers (---like on x86---) and print the associated type
or number when available.

While here, gyp' the support for process tracing (tr /p).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.42 2013/12/29 21:06:37 miod Exp $	*/
a64 3
       .globl  _C_LABEL(hid0_idle),
       .type   _C_LABEL(hid0_idle),@@object
_C_LABEL(hid0_idle):   .long   0       /* hid0 bits to set on idle, DOZE/NAP *
d218 4
d226 1
d230 5
d236 3
a238 2
	 * interrupts were disabled in cpu_idle_enter, but must be enabled
	 * for sleeping
d240 6
a245 2
	lis	%r4, _C_LABEL(hid0_idle)@@ha
	lwz	%r4, _C_LABEL(hid0_idle)@@l(%r4)
a246 9
	//* if hid0_idle is 0, no low power */
	cmpwi	%r4, 0
	beq	idledone
	/* set HID0_(HID|NAP|DOZ) as appropriate in hid0 */
	mfspr	%r5, 1008
	or	%r5, %r5, %r4
	mtspr	1008,	%r5
	isync
	/* enable interrupts, required before setting POW */
d257 2
a258 2
	 * restore interrupts to disabled, so hid0 is only modified with
	 * interrupts disabled.
d263 3
a265 4
	/* clear HID0_(HID|NAP|DOZ) since sleeping is over */
	mfspr	%r5, 1008
	andc	%r5, %r5, %r4
	mtspr	1008, %r5
a266 8
	/*
	 * enable interrupts for a small window here to catch machines
	 * that do not have any sleep mode
	 */
	ori     %r5,%r3,PSL_EE@@l
	mtmsr	%r5
	isync
	mtmsr	%r3
a268 1

d270 4
d278 1
a280 1

d725 13
a737 9
#define HID_IDLE_CHECK(sr1,sr2,sr3,rSRR0)				\
	/* detect if interrupt occurred from idle */			\
	mfspr	sr1, 1008;						\
	lis	sr2,_C_LABEL(hid0_idle)@@ha;				\
	lwz	sr2,_C_LABEL(hid0_idle)@@l(sr2);				\
	and.	sr3,sr1,sr2;						\
	andc	sr1,sr1,sr2;						\
	beq+	1f;							\
	mtspr	1008, sr1;						\
d802 1
a802 1
	HID_IDLE_CHECK(%r5,%r6,%r0,%r30)				\
d1289 11
@


1.42
log
@In tlbdsmiss, do not trash the tlb pointer by mistake. From NetBSD (PR #39257)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.41 2008/07/28 19:08:46 miod Exp $	*/
d890 1
d905 2
d1186 1
@


1.41
log
@No longer clear ci_want_resched within cpu_switchto(), now that it's done
in the MI code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.40 2008/06/10 18:38:59 drahn Exp $	*/
d679 1
a679 1
	rlwnm.	%r2,%r2,3,1,1		/* get the key */
@


1.40
log
@use the defines, not magic constants. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.39 2008/04/29 00:26:11 drahn Exp $	*/
a160 3
	li	%r31,0
	/* just did this resched thing, clear resched */
	stw	%r31,CI_WANT_RESCHED(%r5)
@


1.39
log
@spillstk and ddbstk need to be per cpu. Found by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.38 2008/04/27 15:59:49 drahn Exp $	*/
d726 1
a726 1
	addi	%r1,%r30,8192	 /* 7k for ddb */
d955 1
a955 1
	addi	%r1,%r30,1024
d1017 1
a1017 1
	addi	%r1,%r30,1024
@


1.38
log
@Switch to proc based ast pending for SMP. ok kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.37 2008/04/26 22:37:41 drahn Exp $	*/
d47 3
a49 1
#define	INTSTK	(8*1024)		/* 8K interrupt stack */
d120 1
a284 4

/*
 * Data used during primary/secondary traps/interrupts
 */
a285 3
	.data
#define	SPILLSTK 1024			/* 1K spill stack */
.lcomm	spillstk,SPILLSTK,8
a711 3
	.local	ddbstk
	.comm	ddbstk,INTSTK,8	/* ddb stack */

d724 3
a726 2
	lis	%r1,ddbstk+INTSTK@@ha	/* get new SP */
	addi	%r1,%r1,ddbstk+INTSTK@@l
d953 3
a955 2
	lis	%r1,spillstk+SPILLSTK@@ha
	addi	%r1,%r1,spillstk+SPILLSTK@@l	/* get spill stack */
d1015 3
a1017 2
	lis	%r1,spillstk+SPILLSTK@@ha
	addi	%r1,%r1,spillstk+SPILLSTK@@l	/* get spill stack */
@


1.37
log
@Changes to get closer to SMP.
add biglock before interrupt calls into the kernel.
switch the clock to using cpuinfo variables instead of globals
move cpu_switchto into C code so that on multiprocessor the FPU
and Altivec can be saved before switching CPUs.
add a lock into pmap when modifying the hash table.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.36 2008/02/15 17:33:51 drahn Exp $	*/
d923 2
a924 1
	lwz	%r4,CI_ASTPENDING(%r3)
d1155 2
a1156 1
	lwz	%r4,CI_ASTPENDING(%r5)	/* Test AST pending */
@


1.36
log
@Reenable idle modes on powerpc. Tested by kettenis and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.35 2007/12/04 22:36:39 kettenis Exp $	*/
d145 1
a145 1
_ENTRY(_C_LABEL(cpu_switchto))
a161 6
#ifdef MULTIPROCESSOR
	stw	%r5,P_CPU(%r4)
#endif

	stw	%r4,CI_CURPROC(%r5)	/* record new process */

d181 6
@


1.35
log
@Remove remains of the idle pcb/stack.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.34 2007/10/10 15:56:20 deraadt Exp $	*/
d63 3
d221 4
d228 20
a247 1
#if 0
d249 23
a271 2
	mfmsr	%r3
	oris	%r3, %r3, PSL_POW@@h
a272 2
	isync
#endif
d275 1
d277 4
d737 12
d810 1
@


1.34
log
@Disable PSL_POW code for now in cpu_idle_cycle, because it does not yet
do the cache flush / instruction cache disable / tlb invalidate dance.
For some reason in a switchto world this suddenly matters or machines
become really slow running NFS... huh? figured out with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.33 2007/10/10 15:53:52 art Exp $	*/
a112 2
	stw	%r8,CI_IDLE_PCB(%r9)
	addi	%r8,%r8,USPACE		/* space for idle_u */
@


1.33
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.32 2007/03/20 20:59:54 kettenis Exp $	*/
d223 1
d229 1
@


1.32
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.31 2007/01/21 23:01:45 kettenis Exp $	*/
d136 2
a137 25
	bl	_C_LABEL(cpu_hatch)
	bl	_C_LABEL(sched_lock_idle)
	li	%r30,0
	b	_C_LABEL(idle)
#endif
/*
 * No processes are runnable, so loop waiting for one.
 * Separate label here for accounting purposes.
 */
	.globl	_C_LABEL(idle)
	.type	_C_LABEL(idle),@@function
_C_LABEL(idle):
	mfmsr	%r3
	/* disable interrupts while manipulating runque */
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3

	lis	%r8,_C_LABEL(whichqs)@@ha
	lwz	%r9,_C_LABEL(whichqs)@@l(%r8)

	or.	%r9,%r9,%r9
	bne-	_C_LABEL(sw1)			/* at least one queue non-empty */

#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	bl	_C_LABEL(sched_unlock_idle)
a139 38
	ori	%r3,%r3,PSL_EE		/* reenable ints again */
	mtmsr	%r3
	isync
	sync
	/* low power mode */
	mfmsr	%r3
	oris	%r3, %r3, PSL_POW@@h
	mtmsr	%r3
	isync

/* May do some power saving here? */

#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	bl	_C_LABEL(sched_lock_idle)
#endif
	b	_C_LABEL(idle)

/*
 * switchexit gets called from cpu_exit to free the user structure
 * and kernel stack of the current process.
 */
_ENTRY(_C_LABEL(switchexit))
/* First switch to the idle pcb/kernel stack */
	GET_CPUINFO(%r7)
	lwz	%r6,CI_IDLE_PCB(%r7)
	stw	%r6,CI_CURPCB(%r7)
	addi	%r1,%r6,USPACE-16	/* 16 bytes are reserved at stack top */
	/*
	 * Schedule the vmspace and stack to be freed (the proc arg is
	 * already in r3).
	 */
	bl	_C_LABEL(exit2)

	/* Fall through to cpu_switch to actually select another proc */
	li	%r3,0			/* indicate exited process */

/* Fall through to cpu_switch to actually select another proc */

d141 2
a142 2
 * void cpu_switch(struct proc *p)
 * Find a runnable process and switch to it.
d144 1
a144 1
_ENTRY(_C_LABEL(cpu_switch))
d151 6
a156 2
	mr	%r30,%r3
	GET_CPUINFO(%r3)
a157 41
	/* Zero to not accumulate cpu time */
	stw	%r31,CI_CURPROC(%r3)
	lwz	%r31,CI_CURPCB(%r3)

	li	%r3,0
	bl	_C_LABEL(lcsplx)
	stw	%r3,PCB_SPL(%r31)	/* save spl */

/* Find a new process */
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l	/* disable interrupts while
					   manipulating runque */
	mtmsr	%r3
	isync

	lis	%r8,_C_LABEL(whichqs)@@ha
	lwz	%r9,_C_LABEL(whichqs)@@l(%r8)

	or.	%r9,%r9,%r9
	beq-	_C_LABEL(idle)		/* all queues empty */
_C_LABEL(sw1):
	cntlzw	%r10,%r9
	lis	%r4,_C_LABEL(qs)@@ha
	addi	%r4,%r4,_C_LABEL(qs)@@l
	slwi	%r3,%r10,3
	add	%r3,%r3,%r4		/* select queue */

	lwz	%r31,P_FORW(%r3)	/* unlink first proc from queue */
	lwz	%r4,P_FORW(%r31)
	stw	%r4,P_FORW(%r3)
	stw	%r3,P_BACK(%r4)

	cmpl	0,%r3,%r4			/* queue empty? */
	bne	1f

	lis	%r3,0x80000000@@ha
	srw	%r3,%r3,%r10
	andc	%r9,%r9,%r3
	stw	%r9,_C_LABEL(whichqs)@@l(%r8)	/* mark it empty */

1:
d159 1
a159 5
	li	%r3,0
	GET_CPUINFO(%r4)
	stw	%r3,CI_WANT_RESCHED(%r4)

	stw	%r3,P_BACK(%r31)		/* probably superfluous */
d162 1
a162 1
	stw	%r4,P_CPU(%r31)
d165 1
a165 1
	stw	%r31,CI_CURPROC(%r4)		/* record new process */
d167 2
a168 2
	li	%r3,SONPROC
	stb	%r3,P_STAT(%r31)
d170 1
a170 8
	mfmsr	%r3
	ori	%r3,%r3,PSL_EE		/* Now we can interrupt again */
	mtmsr	%r3

	cmpl	0,%r31,%r30		/* is it the same process? */
	beq	switch_return

	or.	%r30,%r30,%r30		/* old process was exiting? */
d178 2
a179 2
	lwz	%r3,P_ADDR(%r30)
	stw	%r1,PCB_SP(%r3)		/* save SP */
d183 3
a185 3
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3
d187 2
a188 3
	lwz	%r4,P_ADDR(%r31)
	GET_CPUINFO(%r5)
	stw	%r4,CI_CURPCB(%r5)	/* indicate new pcb */
d190 1
a190 1
	lwz	%r5,PCB_PMR(%r4)
d193 2
a194 3
	GET_CPUINFO(%r6)
	stwu	%r5,CI_CURPM(%r6)
	stwcx.	%r5,%r0,%r6		/* clear possible reservation */
d196 2
a197 2
	addic.	%r5,%r5,64
	li	%r6,0
d199 1
a199 1
	lwz	%r1,PCB_SP(%r4)		/* get new procs SP */
d201 2
a202 2
	ori	%r3,%r3,PSL_EE		/* interrupts are okay again */
	mtmsr	%r3
a211 11
switch_return:
	mr	%r30,%r7		/* save proc pointer */
	lwz	%r3,PCB_SPL(%r4)
	bl	_C_LABEL(lcsplx)

#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
        bl      _C_LABEL(sched_unlock_idle)
#endif

	mr	%r3,%r30		/* curproc for special fork returns */

d219 13
@


1.31
log
@Use addic. %r31,%r31,1 instead of addic. %r31,%r31,%r1.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.30 2007/01/17 20:43:39 gwk Exp $	*/
d45 4
a57 1
idle_u:			.long	0	/* fake uarea during idle after exit */
d108 6
a113 2
	lis	%r9,idle_u@@ha
	stw	%r8,idle_u@@l(%r9)
d115 2
d131 10
d159 4
d175 3
d186 3
a188 4
	lis	%r6,idle_u@@ha
	lwz	%r6,idle_u@@l(%r6)
	lis	%r7,_C_LABEL(curpcb)@@ha
	stw	%r6,_C_LABEL(curpcb)@@l(%r7)
d213 1
a213 1
	lis	%r3,_C_LABEL(curproc)@@ha
d216 2
a217 3
	stw	%r31,_C_LABEL(curproc)@@l(%r3)
	lis	%r3,_C_LABEL(curpcb)@@ha
	lwz	%r31,_C_LABEL(curpcb)@@l(%r3)
d258 2
a259 2
	lis	%r4,_C_LABEL(want_resched)@@ha
	stw	%r3,_C_LABEL(want_resched)@@l(%r4)
d263 5
a267 2
	lis	%r4,_C_LABEL(curproc)@@ha
	stw	%r31,_C_LABEL(curproc)@@l(%r4)	/* record new process */
d297 2
a298 2
	lis	%r5,_C_LABEL(curpcb)@@ha
	stw	%r4,_C_LABEL(curpcb)@@l(%r5)	/* indicate new pcb */
d303 2
a304 2
	lis	%r6,_C_LABEL(curpm)@@ha
	stwu	%r5,_C_LABEL(curpm)@@l(%r6)
d328 4
d345 1
a345 3
#define	tempsave	0x2e0		/* primary save area for trap handling */
#define	disisave	0x3e0		/* primary save area for dsi/isi traps */
#define	INTSTK	(8*1024)		/* 8K interrupt stack */
a346 5
intstk:	.space	INTSTK			/* interrupt stack */
	.global _C_LABEL(intr_depth)
	.type  _C_LABEL(intr_depth),@@object
_C_LABEL(intr_depth):
	.long	-1			/* in-use marker */
d365 2
a366 1
	stmw	%r28,tempsave(%r0)	/* free r28-r31 */
d369 1
d375 2
a376 2
	lis	%r1,_C_LABEL(curpcb)@@ha
	lwz	%r1,_C_LABEL(curpcb)@@l(%r1)
a391 1
	mfsprg	%r1,1			/* restore SP */
d393 2
a394 1
	stmw	%r28,tempsave(0)	/* free r28-r31 */
d397 1
a397 1
	stmw	%r30,tempsave+16(0)
d400 1
d406 2
a407 2
	lis	%r1,_C_LABEL(curpcb)@@ha
	lwz	%r1,_C_LABEL(curpcb)@@l(%r1)
d422 3
a424 1
	stmw	%r28,disisave(0)	/* free r28-r31 */
d430 1
d459 4
a462 1
	lmw	%r28,disisave(0)	/* restore r28-r31 */
d477 1
a478 1
	mtsprg	1,%r1			/* save SP */
a481 1
	mfsprg	%r1,1			/* restore SP */
d483 2
a484 1
	stmw	%r28,disisave(0)	/* free r28-r31 */
d488 1
d502 4
a505 1
	lmw	%r28,disisave(0)	/* restore r28-r31 */
d525 2
a526 1
	stmw	%r28,tempsave(0)	/* free r28-r31 */
d530 1
a530 3
	lis	%r1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	%r1,%r1,intstk+INTSTK@@l
	lwz	%r31,0(%r1)		/* were we already running on intstk? */
d532 2
a533 1
	stw	%r31,0(%r1)
d553 2
a554 1
	stmw	%r28,tempsave(0)	/* free r28-r31 */
d558 1
a558 3
	lis	%r1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	%r1,%r1,intstk+INTSTK@@l
	lwz	%r31,0(%r1)		/* were we already running on intstk? */
d560 2
a561 1
	stw	%r31,0(%r1)
a771 1
#define ddbsave	0xde0		/* primary save area for DDB */
d786 2
a787 1
	stmw	%r28,ddbsave(0)		/* free r28-r31 */
d809 1
d811 3
a813 2
	mfsrr1	%r31;							\
	stmw	%r30,savearea+24(0);					\
d841 1
d844 4
a847 3
	lmw	%r28,savearea(0);					\
	stmw	%r2,FRAME_2+8(%r1);					\
	lmw	%r28,savearea+16(0);					\
d867 3
a870 2
	stw	%r2,savearea(0);					\
	stw	%r3,savearea+4(0);					\
d888 2
a889 1
	lwz	%r3,savearea+4(0);					\
d893 1
a893 2
	lis	%r2,_C_LABEL(curpm)@@ha;	/* get real address of pmap */	\
	lwz	%r2,_C_LABEL(curpm)@@l(2);				\
d912 4
a915 3
	lwz	%r2,savearea(0);					\
	lwz	%r3,savearea+4(0);					\
	mtsrr0	%r2;							\
d924 5
a928 4
	lmw	%r30,disisave(0)
	stmw	%r30,tempsave(0)
	lmw	%r30,disisave+8(0)
	stmw	%r30,tempsave+8(0)
d931 1
a931 1
	stmw	%r30,tempsave+16(0)
d939 2
a940 2
	lis	%r1,_C_LABEL(curpcb)@@ha
	lwz	%r1,_C_LABEL(curpcb)@@l(%r1)
d946 1
a946 1
	FRAME_SETUP(tempsave)
d968 2
a969 2
	lis	%r3,_C_LABEL(astpending)@@ha
	lwz	%r4,_C_LABEL(astpending)@@l(%r3)
d976 1
a976 1
	FRAME_LEAVE(tempsave)
d986 3
a1049 1
	mfsprg	%r1,1			/* restore SP */
d1052 3
a1054 1
	lmw	%r28,disisave(0)	/* restore r28-r31 */
d1111 2
a1112 1
	lmw	%r28,tempsave(0);	/* restore r28-r31 */		\
d1114 1
a1114 2
	lis	%r5,_C_LABEL(intr_depth)@@ha;				\
	lwz	%r5,_C_LABEL(intr_depth)@@l(%r5);			\
d1173 6
d1182 1
a1182 2
	lis	%r3,_C_LABEL(curpm)@@ha	/* get current pmap real address */
	lwz	%r3,_C_LABEL(curpm)@@l(%r3)
d1200 1
a1200 2
	lis	%r3,_C_LABEL(astpending)@@ha	/* Test AST pending */
	lwz	%r4,_C_LABEL(astpending)@@l(%r3)
d1207 1
a1207 1
	stmw	%r28,tempsave(0)	/* establish tempsave again */
a1215 4
	lis	%r30,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	%r31,_C_LABEL(intr_depth)@@l(%r30)
	addi	%r31,%r31,-1
	stw	%r31,_C_LABEL(intr_depth)@@l(%r30)
a1224 4
	lis	%r3,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	%r4,_C_LABEL(intr_depth)@@l(%r3)
	addi	%r4,%r4,-1
	stw	%r4,_C_LABEL(intr_depth)@@l(%r3)
d1255 2
a1256 2
	lis	%r4,_C_LABEL(curpcb)@@ha
	lwz	%r4,_C_LABEL(curpcb)@@l(%r4)
d1333 2
a1334 1
	stmw	%r28,ddbsave(0)
d1345 1
a1345 1
	FRAME_SETUP(ddbsave)
d1353 3
a1355 2
	stw	%r3,ddbsave+8(0)
	FRAME_LEAVE(ddbsave)
d1357 2
a1358 1
	stmw	%r28,tempsave(0)
d1361 1
a1361 1
	lwz	%r31,ddbsave+8(0)
d1365 1
a1365 1
	FRAME_LEAVE(ddbsave)
@


1.30
log
@Remove some cruft, SUPPORT_PPC1BUG isnt defined or needed. While here fix
some whitespace nits. No binary change.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.29 2006/03/31 05:23:14 drahn Exp $	*/
d495 1
a495 1
	addic.	%r31,%r31,%r1
d523 1
a523 1
	addic.	%r31,%r31,%r1
@


1.29
log
@No point in calling pte_spill_r() 90% of the time, when the first thing
it is going to do is test user/kernel and return, do it before the call.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.28 2005/11/24 12:08:16 pedro Exp $	*/
a78 9
#ifdef SUPPORT_PPC1BUG
	mr	%r0,%r5
	cmpwi	0,%r0,0
	bne	1f
	/* need additional tests for other systems??? */
	bl	ppc1bug_init
	b	2f
#endif /* SUPPORT_PPC1BUG
1:	/* support openfirmware for Apple and PowerStack w/OFW, ... */
a79 1
2:
d366 1
a366 1
	mfsprg	%r1,1                   /* restore SP */
d445 1
a445 1
	mtsprg	1,%r1                   /* save SP */
d449 1
a449 1
	mfsprg	%r1,1                   /* restore SP */
d980 1
a980 1
	andi.	%r0,%r4,PSL_PR 
@


1.28
log
@Remove kernfs, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.27 2005/10/20 12:52:13 kettenis Exp $	*/
d985 1
a985 1
	mfdar	%r3
d990 4
d995 1
d1045 1
a1045 1
	mfsrr0	%r3
@


1.27
log
@s/mtrspr/mtsprg in ddblow
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.26 2005/10/14 03:10:32 drahn Exp $	*/
d100 1
a100 1
#if defined(DDB) || defined(KERNFS)
@


1.26
log
@Fixup some mnemonics, code was correct, stupid assembler doesn't type
check closely...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.25 2005/10/03 04:47:30 drahn Exp $	*/
d754 1
a754 1
	mtspr	1,%r1			/* save SP */
@


1.25
log
@Handle segment register restore at context enter/exit instead of
deep in the kernel. Based on code from two years ago, now necessary
for G5. removes the 1GB ram limit on 32bit processors, temporarily
sets a 256MB limit on G5.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.24 2005/10/03 04:40:09 deraadt Exp $	*/
d1158 1
a1158 1
	mtsprg	%r1,3
d1288 1
a1288 1
	mtsprg	%r1,1
d1315 1
a1315 1
	mtsprg	%r1,1			/* prepare for entrance to realtrap */
@


1.24
log
@pretty up the instruction whacker code; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.23 2005/10/03 02:16:10 drahn Exp $	*/
a291 11
	mfsr	%r8,PPC_KERNEL_SR	/* save kernel SR */
nop64_1s:
1:
	addis	%r6,%r6,-0x10000000@@ha	/* set new procs segment registers */
	or.	%r6,%r6,%r6		/* This is done from the real address pmap */
	lwzu	%r7,-4(%r5)		/* so we don't have to worry */
	mtsrin	%r7,%r6			/* about accessibility */
	bne	1b
nop64_1e:
	mtsr	PPC_KERNEL_SR,%r8	/* restore kernel SR */
	isync
d415 1
a415 1
#if 0
d440 1
a440 1
rfi1:	rfi				/* return to trapped code */
d442 1
a442 1
#endif
d465 1
a465 1
#if 0
d479 1
a479 1
rfi2:	rfi				/* return to trapped code */
d481 1
a481 1
#endif
d785 19
d861 17
a877 5
	lwz	%r2,_C_LABEL(curpm)@@l(%r2);				\
	lwz	%r3,PM_USRSR(%r2);					\
	mtsr	PPC_USER_SR,%r3;					\
	lwz	%r3,PM_KERNELSR(%r2);					\
	mtsr	PPC_KERNEL_SR,%r3;					\
a911 4
/* First have to enable KERNEL mapping */
	lis	%r31,PPC_KERNEL_SEGMENT@@ha
	addi	%r31,%r31,PPC_KERNEL_SEGMENT@@l
	mtsr	PPC_KERNEL_SR,%r31
d943 1
a943 1
rfi3:	rfi
d1012 1
a1012 1
rfi4:	rfi				/* return to trapped code */
d1078 19
a1097 3
	lis	%r3,(PPC_KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@ha;		\
	addi	%r3,%r3,(PPC_KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@l;	\
	mtsr	PPC_KERNEL_SR,%r3;					\
d1135 17
a1151 2
	lwz	%r3,PM_KERNELSR(%r3)
	mtsr	PPC_KERNEL_SR,%r3		/* Restore kernel SR */
d1190 1
a1190 1
rfi5:	rfi
a1255 1
		
d1324 1
a1324 1
rfi6:	rfi
a1338 2
#if 0
	/* rfi1 and rfi2 are currently inside if 0ed code */
a1340 1
#endif
a1342 2
	.long	rfi5, rfi5 + 4
	.long	rfi6, rfi6 + 4
d1349 1
@


1.23
log
@First part of locore G5 support, this is one step of many.
Get this in and tested before the rest hits the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.22 2005/09/19 04:16:24 drahn Exp $	*/
d1287 6
a1292 2
	.globl  _C_LABEL(rfi_whack)
_C_LABEL(rfi_whack):
d1295 2
a1296 2
	.long	rfi1
	.long	rfi2
d1298 5
a1302 6
	.long	rfi3
	.long	rfi4
	.long	rfi5
	.long	rfi6
	.globl  _C_LABEL(rfi_whackend)
_C_LABEL(rfi_whackend):
a1303 3
	.globl  _C_LABEL(nop_inst)
 _C_LABEL(nop_inst):
	nop
a1305 1
	.globl	_C_LABEL(nop64_end)
d1307 2
a1308 2
	.long nop64_1s, nop64_1e
_C_LABEL(nop64_end):
a1310 1
	.globl	_C_LABEL(nop32_end)
d1319 1
a1319 1
_C_LABEL(nop32_end):
@


1.22
log
@Make idle a global variable so that gprof can see it and the time can
be attributed more correctly for kgmon output.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.21 2005/08/02 21:02:48 drahn Exp $	*/
d293 1
d300 1
d357 5
d383 6
d417 5
d451 1
a451 1
	rfi				/* return to trapped code */
d465 7
d490 1
a490 1
	rfi				/* return to trapped code */
d504 5
d532 5
d765 6
a770 1
	mtsprg	1,%r1			/* save SP */
d927 1
a927 1
	rfi
d996 1
a996 1
	rfi				/* return to trapped code */
d1143 1
a1143 1
	rfi
d1278 1
a1278 1
	rfi
d1281 41
@


1.21
log
@Save floating point context on signals, looked at miod@@ is it in yet? deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.20 2004/12/24 22:50:30 miod Exp $	*/
d136 2
@


1.20
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.19 2004/11/17 20:09:50 miod Exp $	*/
d1148 20
a1167 1
	addi	%r1,%r1,-16		/* reserved space for callee */
d1169 18
a1186 1
	addi	%r3,%r1,16+8		/* compute &sf_sc */
@


1.19
log
@A few more register prefixes, as well as more tab vs space police. No
change in .o file.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.18 2004/06/28 02:49:10 aaron Exp $	*/
a1155 13



	.data
/* Some bogus data, to keep vmstat happy, for now. */
	.globl	_C_LABEL(intrnames), _C_LABEL(eintrnames)
	.globl	_C_LABEL(intrcnt), _C_LABEL(eintrcnt)
_C_LABEL(intrnames):
	.long	0
_C_LABEL(eintrnames):
_C_LABEL(intrcnt):
	.long	0
_C_LABEL(eintrcnt):
@


1.18
log
@Use new event counter API for interrupt counting on macppc.  drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.17 2004/06/24 22:35:56 drahn Exp $	*/
d177 1
a177 1
	bl      _C_LABEL(exit2)
d180 1
a180 1
	li      %r3,0                     /* indicate exited process */
d231 1
a231 1
	cmpl	0,%r3,%r4		/* queue empty? */
d371 1
a371 1
	.globl  _C_LABEL(alitrap),_C_LABEL(alisize)
d373 7
a379 7
	mtsprg  1,%r1			/* save SP */
	stmw    %r28,tempsave(0)	/* free r28-r31 */
	mfdar   %r30
	mfdsisr %r31
	stmw    %r30,tempsave+16(0)
	mflr    %r28			/* save LR */
	mfcr    %r29			/* save CR */
d382 6
a387 6
	mfsrr1  %r31
	mtcr    %r31
	bc      4,17,1f			/* branch if PSL_PR is clear */
	lis     %r1,_C_LABEL(curpcb)@@ha
	lwz     %r1,_C_LABEL(curpcb)@@l(%r1)
	addi    %r1,%r1,USPACE              /* stack is top of user struct */
d389 2
a390 2
	bla     s_trap
_C_LABEL(alisize) = .-_C_LABEL(alitrap)
d412 1
a412 1
	lwz	%r30,_C_LABEL(battable)@@l(31)	/* get batu */
d455 1
a455 1
	lwz	%r30,_C_LABEL(battable)@@l(31)	/* get batu */
d459 1
a459 1
	lwz	%r30,_C_LABEL(battable)+4@@l(31)	/* get batl */
d564 1
a564 1
	mfspr	%r2,HASH2			/* get the second pointer */
d567 1
a567 1
	addi	%r2,%r2,-8			/* predec pointer */
d719 1
a719 1
#define ddbsave 0xde0           /* primary save area for DDB */
d726 1
a726 1
	.globl  _C_LABEL(ddblow),_C_LABEL(ddbsize)
d735 1
a735 1
_C_LABEL(ddbsize) = .-_C_LABEL(ddblow)
d811 1
a811 1
	lwz	%r2,_C_LABEL(curpm)@@l(2);					\
d921 2
a922 2
	stw	%r11,12(1)
	stw	%r12,8(1)
d928 1
a928 1
	mfsrr1  %r4
d932 1
a932 1
	bl	_C_LABEL(pte_spill_r)		/* try a spill */
d953 1
a953 1
	lmw	%r28,disisave(0)		/* restore r28-r31 */
d983 1
a983 1
	mfsrr1  %r4
d1071 1
a1071 1
	stmw	%r28,tempsave(0)		/* establish tempsave again */
d1175 1
a1175 1
	.globl  _C_LABEL(ddb_trap)
d1177 5
a1181 5
	mtsprg  %r1,1
	mfmsr   %r3
	mtsrr1  %r3
	andi.   %r3,%r3,~(PSL_EE|PSL_ME)@@l
	mtmsr   %r3                       /* disable interrupts */
d1183 6
a1188 6
	stmw    %r28,ddbsave(0)
	mflr    %r28
	li      %r29,EXC_BPT
	mtlr    %r29
	mfcr    %r29
	mtsrr0  %r28
d1196 4
a1199 4
	addi    %r3,%r1,8
	bl      _C_LABEL(ddb_trap_glue)
	or.     %r3,%r3,%r3
	bne     ddbleave
d1201 2
a1202 2
	lwz     %r3,FRAME_EXC+8(%r1)        /* save exception */
	stw     %r3,ddbsave+8(0)
d1204 7
a1210 7
	mtsprg  %r1,1                     /* prepare for entrance to realtrap */
	stmw    %r28,tempsave(0)
	mflr    %r28
	mfcr    %r29
	lwz     %r31,ddbsave+8(0)
	mtlr    %r31
	b       realtrap
@


1.17
log
@Do a better job at containing powerpc specific #defines to PPC_...
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.16 2004/06/13 21:49:18 niklas Exp $	*/
d1160 3
a1162 4
	.globl   _C_LABEL(intrnames)
	.type   _C_LABEL(intrnames),@@object
	.globl   _C_LABEL(eintrnames)
	.type   _C_LABEL(eintrnames),@@object
d1164 1
a1164 19
	.string "irq0" "irq1" "irq2" "irq3"
	.string "irq4" "irq5" "irq6" "irq7"
	.string "irq8" "irq9" "irq10" "irq11"
	.string "irq12" "irq13" "irq14" "irq15"
	.string "irq16" "irq17" "irq18" "irq19"
	.string "irq20" "irq21" "irq22" "irq23"
	.string "irq24" "irq25" "irq26" "irq27"
	.string "irq28" "irq29" "irq30" "irq31"
	.string "irq32" "irq33" "irq34" "irq35"
	.string "irq36" "irq37" "irq38" "irq39"
	.string "irq40" "irq41" "irq42" "irq43"
	.string "irq44" "irq45" "irq46" "irq47"
	.string "irq48" "irq49" "irq50" "irq51"
	.string "irq52" "irq53" "irq54" "irq55"
	.string "irq56" "irq57" "irq58" "irq59"
	.string "irq60" "irq61" "irq62" "irq63"
	.string "clock"
	.string "stat"
	.space 512
a1165 5
	.align 4
	.globl   _C_LABEL(intrcnt)
	.type   _C_LABEL(intrcnt),@@object
	.globl   _C_LABEL(eintrcnt)
	.type   _C_LABEL(eintrcnt),@@object
d1167 1
a1167 18
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0
	.long 0
d1169 1
@


1.16
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d263 1
a263 1
	mfsr	%r10,USER_SR		/* save USER_SR for copyin/copyout */
d290 1
a290 1
	mfsr	%r8,KERNEL_SR		/* save kernel SR */
d297 1
a297 1
	mtsr	KERNEL_SR,%r8		/* restore kernel SR */
d310 1
a310 1
	mtsr	USER_SR,%r10		/* get saved USER_SR */
d813 1
a813 1
	mtsr	USER_SR,%r3;						\
d815 1
a815 1
	mtsr	KERNEL_SR,%r3;						\
d851 3
a853 3
	lis	%r31,KERNEL_SEGMENT@@ha
	addi	%r31,%r31,KERNEL_SEGMENT@@l
	mtsr	KERNEL_SR,%r31
d1021 3
a1023 3
	lis	%r3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@ha;		\
	addi	%r3,%r3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@l;		\
	mtsr	KERNEL_SR,%r3;						\
d1062 1
a1062 1
	mtsr	KERNEL_SR,%r3		/* Restore kernel SR */
@


1.15
log
@backout segment register restore diff which causes reproducible hangs; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.13 2003/10/24 19:56:44 drahn Exp $	*/
d249 3
@


1.14
log
@Fix ppc segment register restores, this fixes the 1GB ram limit and
cleans up pieces in the pmap code.
tested otto, brad, miod, pval.
@
text
@d287 9
d403 1
d430 1
d446 1
d462 1
a750 19
	/* load all kernel segment registers. */			\
	lis	%r31,_C_LABEL(kernel_pmap_)@@ha;				\
	addi	%r31,%r31,_C_LABEL(kernel_pmap_)@@l;			\
	lwz	%r30,0(%r31);	mtsr 0,%r30;				\
	lwz	%r30,4(%r31);	mtsr 1,%r30;				\
	lwz	%r30,8(%r31);	mtsr 2,%r30;				\
	lwz	%r30,12(%r31);	mtsr 3,%r30;				\
	lwz	%r30,16(%r31);	mtsr 4,%r30;				\
	lwz	%r30,20(%r31);	mtsr 5,%r30;				\
	lwz	%r30,24(%r31);	mtsr 6,%r30;				\
	lwz	%r30,28(%r31);	mtsr 7,%r30;				\
	lwz	%r30,32(%r31);	mtsr 8,%r30;				\
	lwz	%r30,36(%r31);	mtsr 9,%r30;				\
	lwz	%r30,40(%r31);	mtsr 10,%r30;			\
	lwz	%r30,44(%r31);	mtsr 11,%r30;			\
	lwz	%r30,48(%r31);	mtsr 12,%r30;			\
/*	lwz	%r30,52(%r31);	mtsr 13,%r30; - dont load user SR - XXX? */ \
	lwz	%r30,56(%r31);	mtsr 14,%r30;			\
	lwz	%r30,60(%r31);	mtsr 15,%r30;			\
d808 5
a812 17
	lwz	%r2,_C_LABEL(curpm)@@l(2);				\
	lwz	%r3,0(%r2);	mtsr 0,%r3;				\
	lwz	%r3,4(%r2);	mtsr 1,%r3;				\
	lwz	%r3,8(%r2);	mtsr 2,%r3;				\
	lwz	%r3,12(%r2);	mtsr 3,%r3;				\
	lwz	%r3,16(%r2);	mtsr 4,%r3;				\
	lwz	%r3,20(%r2);	mtsr 5,%r3;				\
	lwz	%r3,24(%r2);	mtsr 6,%r3;				\
	lwz	%r3,28(%r2);	mtsr 7,%r3;				\
	lwz	%r3,32(%r2);	mtsr 8,%r3;				\
	lwz	%r3,36(%r2);	mtsr 9,%r3;				\
	lwz	%r3,40(%r2);	mtsr 10,%r3;				\
	lwz	%r3,44(%r2);	mtsr 11,%r3;				\
	lwz	%r3,48(%r2);	mtsr 12,%r3;				\
	lwz	%r3,52(%r2);	mtsr 13,%r3; 			\
	lwz	%r3,56(%r2);	mtsr 14,%r3; 			\
	lwz	%r3,60(%r2);	mtsr 15,%r3;				\
d847 4
d957 1
a957 1
	mfsrr1	%r31			/* test if this is a spill fault */
a1016 19
/* load all kernel segment registers. */				\
	lis	3,_C_LABEL(kernel_pmap_)@@ha;				\
	addi	3,3,_C_LABEL(kernel_pmap_)@@l;				\
	lwz	%r5,0(%r3);	mtsr 0,%r5;				\
	lwz	%r5,4(%r3);	mtsr 1,%r5;				\
	lwz	%r5,8(%r3);	mtsr 2,%r5;				\
	lwz	%r5,12(%r3);	mtsr 3,%r5;				\
	lwz	%r5,16(%r3);	mtsr 4,%r5;				\
	lwz	%r5,20(%r3);	mtsr 5,%r5;				\
	lwz	%r5,24(%r3);	mtsr 6,%r5;				\
	lwz	%r5,28(%r3);	mtsr 7,%r5;				\
	lwz	%r5,32(%r3);	mtsr 8,%r5;				\
	lwz	%r5,36(%r3);	mtsr 9,%r5;				\
	lwz	%r5,40(%r3);	mtsr 10,%r5;				\
	lwz	%r5,44(%r3);	mtsr 11,%r5;				\
	lwz	%r5,48(%r3);	mtsr 12,%r5;				\
/*	lwz	%r5,52(%r3);	mtsr 13,%r5; - dont load user SR - XXX? */ \
	lwz	%r5,56(%r3);	mtsr 14,%r5;				\
	lwz	%r5,60(%r3);	mtsr 15,%r5;				\
d1018 3
d1058 2
a1059 17
	/* reload all segment registers. */
	lwz	%r4,0(3);	mtsr 0,%r4;
	lwz	%r4,4(3);	mtsr 1,%r4;
	lwz	%r4,8(3);	mtsr 2,%r4;
	lwz	%r4,12(3);	mtsr 3,%r4;
	lwz	%r4,16(3);	mtsr 4,%r4;
	lwz	%r4,20(3);	mtsr 5,%r4;
	lwz	%r4,24(3);	mtsr 6,%r4;
	lwz	%r4,28(3);	mtsr 7,%r4;
	lwz	%r4,32(3);	mtsr 8,%r4;
	lwz	%r4,36(3);	mtsr 9,%r4;
	lwz	%r4,40(3);	mtsr 10,%r4;
	lwz	%r4,44(3);	mtsr 11,%r4;
	lwz	%r4,48(3);	mtsr 12,%r4;
	lwz	%r4,52(3);	mtsr 13,%r4;
	lwz	%r4,56(3);	mtsr 14,%r4;
	lwz	%r4,60(3);	mtsr 15,%r4;
@


1.13
log
@IPKDB has never been supported in OpenBSD/powerpc/macppc delete this
old unused code.
Remove very old 'where' debugging references.
ANSI a previously missed function.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.12 2003/10/20 02:45:10 drahn Exp $	*/
a286 9
	mfsr	%r8,KERNEL_SR		/* save kernel SR */
1:
	addis	%r6,%r6,-0x10000000@@ha	/* set new procs segment registers */
	or.	%r6,%r6,%r6		/* This is done from the real address pmap */
	lwzu	%r7,-4(%r5)		/* so we don't have to worry */
	mtsrin	%r7,%r6			/* about accessibility */
	bne	1b
	mtsr	KERNEL_SR,%r8		/* restore kernel SR */
	isync
a393 1
#if 0
a419 1
#endif
a434 1
#if 0
a449 1
#endif
d738 19
d814 17
a830 5
	lwz	%r2,_C_LABEL(curpm)@@l(2);					\
	lwz	%r3,PM_USRSR(%r2);					\
	mtsr	USER_SR,%r3;						\
	lwz	%r3,PM_KERNELSR(%r2);					\
	mtsr	KERNEL_SR,%r3;						\
a864 4
/* First have to enable KERNEL mapping */
	lis	%r31,KERNEL_SEGMENT@@ha
	addi	%r31,%r31,KERNEL_SEGMENT@@l
	mtsr	KERNEL_SR,%r31
d971 1
a971 1
	mfsrr1	%r31			/* test if this may be a spill fault */
d1031 19
a1050 3
	lis	%r3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@ha;		\
	addi	%r3,%r3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@l;		\
	mtsr	KERNEL_SR,%r3;						\
d1088 17
a1104 2
	lwz	%r3,PM_KERNELSR(%r3)
	mtsr	KERNEL_SR,%r3		/* Restore kernel SR */
@


1.12
log
@Instead of using xor to clear a register , use li <REG>,0 (load immediate)
Easier to read and suppose to be slightly faster on some ppc processors.
A bit of comment cleanup while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.11 2003/10/16 05:03:22 deraadt Exp $	*/
a34 2
#include "machine/ipkdb.h"

a58 3
	.globl _C_LABEL(where)
	.type  _C_LABEL(where),@@object
_C_LABEL(where):	.long	0
a124 4
	li	%r0, 2
	lis	%r9,_C_LABEL(where)@@ha
	stw	%r0,_C_LABEL(where)@@l(%r9)

d342 1
a342 2
 * (except ISI/DSI, ALI, the interrupts, and possibly the debugging traps
 * when using IPKDB).
a735 21
#if NIPKDB > 0
#define	ipkdbsave	0xde0		/* primary save area for IPKDB */
/*
 * In case of IPKDB we want a separate trap catcher for it
 */
.lcomm	ipkdbstk,INTSTK			/* ipkdb stack */

	.globl	_C_LABEL(ipkdblow),_C_LABEL(ipkdbsize)
	.type	_C_LABEL(ipkdblow),@@function
	.type	_C_LABEL(ipkdbsize),@@object
_C_LABEL(ipkdblow):
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,ipkdbsave(0)	/* free r28-r31 */
	lis	%r1,ipkdbstk+INTSTK@@ha	/* get new SP */
	addi	%r1,%r1,ipkdbstk+INTSTK@@l
	mflr	%r28
	mfcr	%r29
	bla	ipkdbtrap
_C_LABEL(ipkdbsize) =	.-_C_LABEL(ipkdblow)
#endif	/* NIPKDB > 0 */

a1108 114
#if NIPKDB > 0
/*
 * Deliberate entry to ipkdbtrap
 */
	.globl	_C_LABEL(ipkdb_trap)
	.type	_C_LABEL(ipkdb_trap),@@function
_C_LABEL(ipkdb_trap):

	mtsprg	%r2,2
	mfmsr	%r3
	mtsrr1	%r3
	andi.	%r3,%r3,~(PSL_EE|PSL_ME)@@l
	mtmsr	%r3			/* disable interrupts */
	isync
	stmw	%r28,ipkdbsave(0)
	mflr	%r28
	li	%r29,EXC_BPT
	mtlr	%r29
	mfcr	%r29
	mtsrr0	%r28

/*
 * Now the ipkdb trap catching code.
 */
ipkdbtrap:
	FRAME_SETUP(ipkdbsave)
/* Call C trap code: */
	addi	%r3,%r1,8
	bl	_C_LABEL(ipkdb_trap_glue)
	or.	%r3,%r3,%r3
	bne	ipkdbleave
/* This wasn't for IPKDB, so switch to real trap: */
	lwz	%r3,FRAME_EXC+8(%r1)	/* save exception */
	stw	%r3,ipkdbsave+8(0)
	FRAME_LEAVE(ipkdbsave)
	mtsprg	%r1,1			/* prepare for entrance to realtrap */
	stmw	%r28,tempsave(0)
	mflr	%r28
	mfcr	%r29
	lwz	%r31,ipkdbsave+8(0)
	mtlr	%r31
	b	realtrap
ipkdbleave:
	FRAME_LEAVE(ipkdbsave)
	rfi

ipkdbfault:
	ba	_C_LABEL(ipkdbfault)
_C_LABEL(ipkdbfault):
	mfsrr0	%r3
	addi	%r3,%r3,4
	mtsrr0	%r3
	li	%r3,-1
	rfi

/*
 * int ipkdbfbyte(unsigned char *p)
 */
	.globl	_C_LABEL(ipkdbfbyte)
	.type	_C_LABEL(ipkdbfbyte),@@function
_C_LABEL(ipkdbfbyte):
	li	%r9,EXC_DSI		/* establish new fault routine */
	lwz	%r5,0(%r9)
	lis	%r6,ipkdbfault@@ha
	lwz	%r6,ipkdbfault@@l(%r6)
	stw	%r6,0(%r9)
#ifdef	IPKDBUSERHACK
	lis	%r8,_C_LABEL(ipkdbsr)@@ha
	lwz	%r8,_C_LABEL(ipkdbsr)@@l(%r8)
	mtsr	USER_SR,%r8
	isync
#endif
	dcbst	0,%r9			/* flush data... */
	sync
	icbi	0,%r9			/* and instruction caches */
	lbz	%r3,0(%r3)		/* fetch data */
	stw	%r5,0(%r9)		/* restore previous fault handler */
	dcbst	0,%r9			/* and flush data... */
	sync
	icbi	0,%r9			/* and instruction caches */
	blr

/*
 * int ipkdbsbyte(unsigned char *p, int c)
 */
	.globl	_C_LABEL(ipkdbsbyte)
	.type	_C_LABEL(ipkdbsbyte),@@function
_C_LABEL(ipkdbsbyte):
	li	%r9,EXC_DSI		/* establish new fault routine */
	lwz	%r5,0(%r9)
	lis	%r6,ipkdbfault@@ha
	lwz	%r6,ipkdbfault@@l(%r6)
	stw	%r6,0(%r9)
#ifdef	IPKDBUSERHACK
	lis	%r8,_C_LABEL(ipkdbsr)@@ha
	lwz	%r8,_C_LABEL(ipkdbsr)@@l(%r8)
	mtsr	USER_SR,8
	isync
#endif
	dcbst	0,%r9			/* flush data... */
	sync
	icbi	0,%r9			/* and instruction caches */
	mr	%r6,%r3
	li	%r3,0
	stb	4,0(%r6)
	dcbst	0,%r6			/* Now do appropriate flushes to data... */
	sync
	icbi	%r0,%r6			/* and instruction caches */
	stw	%r5,0(%r9)		/* restore previous fault handler */
	dcbst	0,%r9			/* and flush data... */
	sync
	icbi	0,%r9			/* and instruction caches */
	blr
#endif	/* NIPKDB > 0 */
@


1.11
log
@more white
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.10 2003/10/15 20:52:44 drahn Exp $	*/
d127 1
a127 1
	xor	%r0,%r0,%r0
d206 1
a206 1
	xor	%r31,%r31,%r31
d212 1
a212 1
	xor	%r3,%r3,%r3
d235 1
a235 1
	lwz	%r31,P_FORW(%r3)		/* unlink first proc from queue */
d240 1
a240 1
	cmpl	0,%r3,%r4			/* queue empty? */
d250 1
a250 1
	xor	%r3,%r3,%r3
d324 1
a324 1
	mr	%r3,%r30		/* get curproc for special fork returns */
d363 2
a364 1
/* Test whether we already had PR set */
d387 2
a388 1
/* Test whether we already had PR set */
d692 1
a692 1
	lis	%r1,0xa00		/* indicate protection violation on store */
d865 1
a865 1
/* Test whether we already had PR set */
d922 1
a922 1
	xor	%r3,%r3,%r3
d988 1
a988 1
	mfsrr1	%r31			/* test whether this may be a spill fault */
d995 1
a995 1
	stw	%r0,48(%r1)			/* save non-volatile registers */
d1243 1
a1243 1
	xor	%r3,%r3,%r3
d1276 1
a1276 1
	xor	%r3,%r3,%r3
@


1.10
log
@asm readability register names are %r0 instead of 0. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9 2003/07/14 18:56:12 drahn Exp $	*/
d70 1
a70 1
/* arguments to start 
d85 1
a85 1
	mr 	%r0,%r5
d129 1
a129 1
	
d156 1
a156 1
	
d166 1
a166 1
	
a190 1
	
d234 1
a234 1
	
d730 1
a730 1
 
d736 1
a736 1
	mfcr	%r29			/* save CR */ 
d867 1
a867 1
	mfsprg	%r1,1		
d1145 1
a1145 1
	
d1249 1
a1249 1
	icbi	0,%r9			/* and instruction caches */	
d1252 1
a1252 1
	
d1321 2
a1322 2
	.string "clock" 
	.string "stat" 
d1351 1
a1351 1
#ifdef DDB   
@


1.9
log
@'dual' clock support for macppc, this allows the stat clock to run
at a rate independant of the HZ clock. when profiling is enabled
stat clock now runs at 1000/s instead of the normal 100/s. Other
improvements to the ppc clock handling and KNF/ansi.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 2002/11/17 20:36:53 drahn Exp $	*/
d81 3
a83 3
	lis	3, fwargsave@@ha
	stw	6, fwargsave@@l(3)
	stw	7, fwargsave@@l+4(3)
d85 2
a86 2
	mr 	0,5
	cmpwi	0,0,0
d95 2
a96 2
	li	0,0
	mtmsr	0			/* Disable FPU/MMU/exceptions */
d100 5
a104 5
	lis	8,_end@@ha
	addi	8,8,_end@@l
	lis	3, fwargsave@@ha
	lwz	6, fwargsave@@l(3)
	lwz	7, fwargsave@@l+4(3)
d106 1
a106 1
	cmpwi	6, 0
d108 3
a110 3
	add	9,6,7
	lwz	9, -4(9)
	cmpwi   9,0
d112 3
a114 3
	lis	8,_C_LABEL(esym)@@ha
	stw	9,_C_LABEL(esym)@@l(8)
	mr	8, 9
d117 12
a128 12
	li	9,PGOFSET
	add	8,8,9
	andc	8,8,9
	lis	9,idle_u@@ha
	stw	8,idle_u@@l(9)
	addi	8,8,USPACE		/* space for idle_u */
	lis	9,_C_LABEL(proc0paddr)@@ha
	stw	8,_C_LABEL(proc0paddr)@@l(9)
	addi	1,8,USPACE-FRAMELEN	/* stackpointer for proc0 */
	mr	4,1			/* end of mem reserved for kernel */
	xor	0,0,0
	stwu	0,-16(1)		/* end of stack chain */
d130 7
a136 7
	li	0, 2
	lis	9,_C_LABEL(where)@@ha
	stw	0,_C_LABEL(where)@@l(9)

	lis	3,start@@ha
	addi	3,3,start@@l
	mr	5,6			/* args string */
d146 4
a149 3
	mfmsr	3
	andi.	3,3,~PSL_EE@@l		/* disable interrupts while manipulating runque */
	mtmsr	3
d151 2
a152 2
	lis	8,_C_LABEL(whichqs)@@ha
	lwz	9,_C_LABEL(whichqs)@@l(8)
d154 1
a154 1
	or.	9,9,9
d157 2
a158 2
	ori	3,3,PSL_EE		/* reenable ints again */
	mtmsr	3
d162 3
a164 3
	mfmsr	3
	oris	3, 3, PSL_POW@@h
	mtmsr	3
d177 5
a181 5
	lis	6,idle_u@@ha
	lwz	6,idle_u@@l(6)
	lis	7,_C_LABEL(curpcb)@@ha
	stw	6,_C_LABEL(curpcb)@@l(7)
	addi	1,6,USPACE-16		/* 16 bytes are reserved at stack top */
d189 1
a189 1
	li      3,0                     /* indicate exited process */
d199 13
a211 12
	mflr	0			/* save lr */
	stw	0,4(1)
	stwu	1,-16(1)
	stw	31,12(1)
	stw	30,8(1)

	mr	30,3
	lis	3,_C_LABEL(curproc)@@ha
	xor	31,31,31
	stw	31,_C_LABEL(curproc)@@l(3) /* Zero to not accumulate cpu time */
	lis	3,_C_LABEL(curpcb)@@ha
	lwz	31,_C_LABEL(curpcb)@@l(3)
d213 1
a213 1
	xor	3,3,3
d215 1
a215 1
	stw	3,PCB_SPL(31)		/* save spl */
d218 2
a219 2
	mfmsr	3
	andi.	3,3,~PSL_EE@@l		/* disable interrupts while
d221 1
a221 1
	mtmsr	3
d224 2
a225 2
	lis	8,_C_LABEL(whichqs)@@ha
	lwz	9,_C_LABEL(whichqs)@@l(8)
d227 2
a228 2
	or.	9,9,9
	beq-	_C_LABEL(idle)			/* all queues empty */
d230 5
a234 5
	cntlzw	10,9
	lis	4,_C_LABEL(qs)@@ha
	addi	4,4,_C_LABEL(qs)@@l
	slwi	3,10,3
	add	3,3,4			/* select queue */
d236 4
a239 4
	lwz	31,P_FORW(3)		/* unlink first proc from queue */
	lwz	4,P_FORW(31)
	stw	4,P_FORW(3)
	stw	3,P_BACK(4)
d241 1
a241 1
	cmpl	0,3,4			/* queue empty? */
d244 4
a247 4
	lis	3,0x80000000@@ha
	srw	3,3,10
	andc	9,9,3
	stw	9,_C_LABEL(whichqs)@@l(8)		/* mark it empty */
d250 4
a253 3
	xor	3,3,3
	lis	4,_C_LABEL(want_resched)@@ha
	stw	3,_C_LABEL(want_resched)@@l(4)	/* just did this resched thing */
d255 1
a255 1
	stw	3,P_BACK(31)		/* probably superfluous */
d257 2
a258 2
	lis	4,_C_LABEL(curproc)@@ha
	stw	31,_C_LABEL(curproc)@@l(4)	/* record new process */
d260 3
a262 3
	mfmsr	3
	ori	3,3,PSL_EE		/* Now we can interrupt again */
	mtmsr	3
d264 1
a264 1
	cmpl	0,31,30			/* is it the same process? */
d267 1
a267 1
	or.	30,30,30		/* old process was exiting? */
d270 7
a276 7
	mfsr	10,USER_SR		/* save USER_SR for copyin/copyout */
	mfcr	11			/* save cr */
	mr	12,2			/* save r2 */
	stwu	1,-SFRAMELEN(1)		/* still running on old stack */
	stmw	10,8(1)
	lwz	3,P_ADDR(30)
	stw	1,PCB_SP(3)		/* save SP */
d279 19
a297 16
	mfmsr	3
	andi.	3,3,~PSL_EE@@l		/* disable interrupts while actually switching */
	mtmsr	3

	lwz	4,P_ADDR(31)
	lis	5,_C_LABEL(curpcb)@@ha
	stw	4,_C_LABEL(curpcb)@@l(5)		/* indicate new pcb */

	lwz	5,PCB_PMR(4)
	lis	6,_C_LABEL(curpm)@@ha
	stwu	5,_C_LABEL(curpm)@@l(6)		/* save real pmap pointer for spill fill */
	stwcx.	5,0,6			/* clear possible reservation */

	addic.	5,5,64
	li	6,0
	mfsr	8,KERNEL_SR		/* save kernel SR */
d299 4
a302 4
	addis	6,6,-0x10000000@@ha	/* set new procs segment registers */
	or.	6,6,6			/* This is done from the real address pmap */
	lwzu	7,-4(5)			/* so we don't have to worry */
	mtsrin	7,6			/* about accessibility */
d304 1
a304 1
	mtsr	KERNEL_SR,8		/* restore kernel SR */
d307 1
a307 1
	lwz	1,PCB_SP(4)		/* get new procs SP */
d309 2
a310 2
	ori	3,3,PSL_EE		/* interrupts are okay again */
	mtmsr	3
d312 4
a315 4
	lmw	10,8(1)			/* get other regs */
	lwz	1,0(1)			/* get saved SP */
	mr	2,12			/* get saved r2 */
	mtcr	11			/* get saved cr */
d317 1
a317 1
	mtsr	USER_SR,10		/* get saved USER_SR */
d321 2
a322 2
	mr	30,7			/* save proc pointer */
	lwz	3,PCB_SPL(4)
d325 1
a325 1
	mr	3,30			/* get curproc for special fork returns */
d327 5
a331 5
	lwz	31,12(1)
	lwz	30,8(1)
	addi	1,1,16
	lwz	0,4(1)
	mtlr	0
d360 4
a363 4
	mtsprg	1,1			/* save SP */
	stmw	28,tempsave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
d365 2
a366 2
	mfsrr1	31
	mtcr	31
d368 3
a370 3
	lis	1,_C_LABEL(curpcb)@@ha
	lwz	1,_C_LABEL(curpcb)@@l(1)
	addi	1,1,USPACE		/* stack is top of user struct */
d380 7
a386 7
	mtsprg  1,1                     /* save SP */
	stmw    28,tempsave(0)          /* free r28-r31 */
	mfdar   30
	mfdsisr 31
	stmw    30,tempsave+16(0)
	mflr    28                      /* save LR */
	mfcr    29                      /* save CR */
d388 6
a393 6
	mfsrr1  31
	mtcr    31
	bc      4,17,1f                 /* branch if PSL_PR is clear */
	lis     1,_C_LABEL(curpcb)@@ha
	lwz     1,_C_LABEL(curpcb)@@l(1)
	addi    1,1,USPACE              /* stack is top of user struct */
d407 5
a411 5
	stmw	28,disisave(0)		/* free r28-r31 */
	mfcr	29			/* save CR */
	mfxer	30			/* save XER */
	mtsprg	2,30			/* in SPRG2 */
	mfsrr1	31			/* test kernel mode */
d413 1
a413 1
	mtcr	31
d415 5
a419 5
	mfdar	31			/* get fault address */
	rlwinm	31,31,7,25,28		/* get segment * 8 */
	addis	31,31,_C_LABEL(battable)@@ha
	lwz	30,_C_LABEL(battable)@@l(31)	/* get batu */
	mtcr	30
d421 1
a421 1
	lwz	31,_C_LABEL(battable)+4@@l(31)	/* get batl */
d423 2
a424 2
	mftb	28
	andi.	28,28,1
d426 2
a427 2
	mtdbatu	2,30
	mtdbatl	2,31
d430 2
a431 2
	mtdbatu	3,30
	mtdbatl	3,31
d433 4
a436 4
	mfsprg	30,2			/* restore XER */
	mtxer	30
	mtcr	29			/* restore CR */
	lmw	28,disisave(0)		/* restore r28-r31 */
d440 1
a440 1
	mflr	28			/* save LR */
d451 4
a454 4
	stmw	28,disisave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
	mfsrr1	31			/* test kernel mode */
d456 1
a456 1
	mtcr	31
d458 5
a462 5
	mfsrr0	31			/* get fault address */
	rlwinm	31,31,7,25,28		/* get segment * 8 */
	addis	31,31,_C_LABEL(battable)@@ha
	lwz	30,_C_LABEL(battable)@@l(31)	/* get batu */
	mtcr	30
d464 5
a468 5
	mtibatu	3,30
	lwz	30,_C_LABEL(battable)+4@@l(31)	/* get batl */
	mtibatl	3,30
	mtcr	29			/* restore CR */
	lmw	28,disisave(0)		/* restore r28-r31 */
d482 10
a491 10
	mtsprg	1,1			/* save SP */
	stmw	28,tempsave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
	mfxer	30			/* save XER */
	lis	1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	1,1,intstk+INTSTK@@l
	lwz	31,0(1)			/* were we already running on intstk? */
	addic.	31,31,1
	stw	31,0(1)
d493 1
a493 1
	mfsprg	1,1			/* yes, get old SP */
d505 10
a514 10
	mtsprg	1,1			/* save SP */
	stmw	28,tempsave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
	mfxer	30			/* save XER */
	lis	1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	1,1,intstk+INTSTK@@l
	lwz	31,0(1)			/* were we already running on intstk? */
	addic.	31,31,1
	stw	31,0(1)
d516 1
a516 1
	mfsprg	1,1			/* yes, get old SP */
d541 5
a545 5
	mfspr	2,HASH1			/* get first pointer */
	li	1,8
	mfctr	0			/* save counter */
	mfspr	3,ICMP			/* get first compare value */
	addi	2,2,-8			/* predec pointer */
d547 1
a547 1
	mtctr	1			/* load counter */
d549 2
a550 2
	lwzu	1,8(2)			/* get next pte */
	cmpl	0,1,3			/* see if found pte */
d553 2
a554 2
	lwz	1,4(2)			/* load tlb entry lower word */
	andi.	3,1,8			/* check G-bit */
d556 7
a562 7
	mtctr	0			/* restore counter */
	mfspr	0,IMISS			/* get the miss address for the tlbli */
	mfsrr1	3			/* get the saved cr0 bits */
	mtcrf	0x80,3			/* and restore */
	ori	1,1,0x100		/* set the reference bit */
	mtspr	RPA,1			/* set the pte */
	srwi	1,1,8			/* get byte 7 of pte */
d564 1
a564 1
	stb	1,6(2)			/* update page table */
d568 1
a568 1
	andi.	1,3,0x40		/* have we already done second hash? */
d570 4
a573 4
	mfspr	2,HASH2			/* get the second pointer */
	ori	3,3,0x40		/* change the compare value */
	li	1,8
	addi	2,2,-8			/* predec pointer */
d576 3
a578 3
	mfsrr1	3
	andi.	2,3,0xffff		/* clean upper srr1 */
	addis	2,2,0x800		/* set srr<4> to flag prot violation */
d581 3
a583 3
	mfsrr1	3
	andi.	2,3,0xffff		/* clean upper srr1 */
	addis	2,2,0x4000		/* set srr1<1> to flag pte not found */
d585 6
a590 6
	mtctr	0			/* restore counter */
	mtsrr1	2
	mfmsr	0
	xoris	0,0,2			/* flip the msr<tgpr> bit */
	mtcrf	0x80,3			/* restore cr0 */
	mtmsr	0			/* now with native gprs */
d599 5
a603 5
	mfspr	2,HASH1			/* get first pointer */
	li	1,8
	mfctr	0			/* save counter */
	mfspr	3,DCMP			/* get first compare value */
	addi	2,2,-8			/* predec pointer */
d605 1
a605 1
	mtctr	1			/* load counter */
d607 2
a608 2
	lwzu	1,8(2)			/* get next pte */
	cmpl	0,1,3			/* see if found pte */
d611 8
a618 8
	lwz	1,4(2)			/* load tlb entry lower word */
	mtctr	0			/* restore counter */
	mfspr	0,DMISS			/* get the miss address for the tlbld */
	mfsrr1	3			/* get the saved cr0 bits */
	mtcrf	0x80,3			/* and restore */
	ori	1,1,0x100		/* set the reference bit */
	mtspr	RPA,1			/* set the pte */
	srwi	1,1,8			/* get byte 7 of pte */
d620 1
a620 1
	stb	1,6(2)			/* update page table */
d624 1
a624 1
	andi.	1,3,0x40		/* have we already done second hash? */
d626 4
a629 4
	mfspr	2,HASH2			/* get the second pointer */
	ori	3,3,0x40		/* change the compare value */
	li	1,8
	addi	2,2,-8			/* predec pointer */
d632 12
a643 12
	mfsrr1	3
	lis	1,0x4000		/* set dsisr<1> to flag pte not found */
	mtctr	0			/* restore counter */
	andi.	2,3,0xffff		/* clean upper srr1 */
	mtsrr1	2
	mtdsisr	1			/* load the dsisr */
	mfspr	1,DMISS			/* get the miss address */
	mtdar	1			/* put in dar */
	mfmsr	0
	xoris	0,0,2			/* flip the msr<tgpr> bit */
	mtcrf	0x80,3			/* restore cr0 */
	mtmsr	0			/* now with native gprs */
d652 5
a656 5
	mfspr	2,HASH1			/* get first pointer */
	li	1,8
	mfctr	0			/* save counter */
	mfspr	3,DCMP			/* get first compare value */
	addi	2,2,-8			/* predec pointer */
d658 1
a658 1
	mtctr	1			/* load counter */
d660 2
a661 2
	lwzu	1,8(2)			/* get next pte */
	cmpl	0,1,3			/* see if found pte */
d664 2
a665 2
	lwz	1,4(2)			/* load tlb entry lower word */
	andi.	3,1,0x80		/* check the C-bit */
d668 5
a672 5
	mtctr	0			/* restore counter */
	mfspr	0,DMISS			/* get the miss address for the tlbld */
	mfsrr1	3			/* get the saved cr0 bits */
	mtcrf	0x80,3			/* and restore */
	mtspr	RPA,1			/* set the pte */
d677 1
a677 1
	andi.	1,3,0x40		/* have we already done second hash? */
d679 4
a682 4
	mfspr	2,HASH2			/* get the second pointer */
	ori	3,3,0x40		/* change the compare value */
	li	1,8
	addi	2,2,-8			/* predec pointer */
d685 1
a685 1
	rlwinm.	3,1,30,0,1		/* test PP */
d687 1
a687 1
	andi.	3,1,1
d690 2
a691 2
	mfsrr1	3
	lis	1,0xa00			/* indicate protection violation on store */
d694 5
a698 5
	mfspr	3,DMISS			/* get the miss address */
	mfsrin	1,3			/* get the segment register */
	mfsrr1	3
	rlwinm	3,3,18,31,31		/* get PR-bit */
	rlwnm.	2,2,3,1,1		/* get the key */
d701 3
a703 3
	lwz	1,4(2)			/* reload tlb entry */
	ori	1,1,0x180
	sth	1,6(2)
d706 2
a707 2
	mfsrr1	3
	lis	1,0x4200		/* set dsisr<1> to flag pte not found */
d710 10
a719 10
	mtctr	0			/* restore counter */
	andi.	2,3,0xffff		/* clean upper srr1 */
	mtsrr1	2
	mtdsisr	1			/* load the dsisr */
	mfspr	1,DMISS			/* get the miss address */
	mtdar	1			/* put in dar */
	mfmsr	0
	xoris	0,0,2			/* flip the msr<tgpr> bit */
	mtcrf	0x80,3			/* restore cr0 */
	mtmsr	0			/* now with native gprs */
d729 2
a730 2
	.local  ddbstk
	.comm   ddbstk,INTSTK,8         /* ddb stack */
d734 7
a740 7
	mtsprg  1,1                     /* save SP */
	stmw    28,ddbsave(0)           /* free r28-r31 */
	mflr    28                      /* save LR */
	mfcr    29                      /* save CR */ 
	lis     1,ddbstk+INTSTK@@ha      /* get new SP */
	addi    1,1,ddbstk+INTSTK@@l
	bla     ddbtrap
d756 6
a761 6
	mtsprg	1,1			/* save SP */
	stmw	28,ipkdbsave(0)		/* free r28-r31 */
	lis	1,ipkdbstk+INTSTK@@ha	/* get new SP */
	addi	1,1,ipkdbstk+INTSTK@@l
	mflr	28
	mfcr	29
d778 6
a783 6
	mfsrr0	30;							\
	mfsrr1	31;							\
	stmw	30,savearea+24(0);					\
	mfmsr	30;							\
	ori	30,30,(PSL_DR|PSL_IR);					\
	mtmsr	30;							\
d785 20
a804 20
	mfsprg	31,1;							\
	stwu	31,-FRAMELEN(1);					\
	stw	0,FRAME_0+8(1);						\
	stw	31,FRAME_1+8(1);					\
	stw	28,FRAME_LR+8(1);					\
	stw	29,FRAME_CR+8(1);					\
	lmw	28,savearea(0);						\
	stmw	2,FRAME_2+8(1);						\
	lmw	28,savearea+16(0);					\
	mfxer	3;							\
	mfctr	4;							\
	mflr	5;							\
	andi.	5,5,0xff00;						\
	stw	3,FRAME_XER+8(1);					\
	stw	4,FRAME_CTR+8(1);					\
	stw	5,FRAME_EXC+8(1);					\
	stw	28,FRAME_DAR+8(1);					\
	stw	29,FRAME_DSISR+8(1);					\
	stw	30,FRAME_SRR0+8(1);					\
	stw	31,FRAME_SRR1+8(1)
d808 17
a824 17
	lwz	2,FRAME_SRR0+8(1);					\
	lwz	3,FRAME_SRR1+8(1);					\
	lwz	4,FRAME_CTR+8(1);					\
	lwz	5,FRAME_XER+8(1);					\
	lwz	6,FRAME_LR+8(1);					\
	lwz	7,FRAME_CR+8(1);					\
	stw	2,savearea(0);						\
	stw	3,savearea+4(0);					\
	mtctr	4;							\
	mtxer	5;							\
	mtlr	6;							\
	mtsprg	1,7;			/* save cr */			\
	lmw	2,FRAME_2+8(1);						\
	lwz	0,FRAME_0+8(1);						\
	lwz	1,FRAME_1+8(1);						\
	mtsprg	2,2;			/* save r2 & r3 */		\
	mtsprg	3,3;							\
d826 5
a830 5
	mfmsr	2;							\
	lis	3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@ha;			\
	addi	3,3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@l;			\
	andc	2,2,3;							\
	mtmsr	2;							\
d833 2
a834 2
	lwz	3,savearea+4(0);					\
	mtcr	3;							\
d837 14
a850 14
	lis	2,_C_LABEL(curpm)@@ha;	/* get real address of pmap */	\
	lwz	2,_C_LABEL(curpm)@@l(2);					\
	lwz	3,PM_USRSR(2);						\
	mtsr	USER_SR,3;						\
	lwz	3,PM_KERNELSR(2);					\
	mtsr	KERNEL_SR,3;						\
1:	mfsprg	2,1;			/* restore cr */		\
	mtcr	2;							\
	lwz	2,savearea(0);						\
	lwz	3,savearea+4(0);					\
	mtsrr0	2;							\
	mtsrr1	3;							\
	mfsprg	2,2;			/* restore r2 & r3 */		\
	mfsprg	3,3
d856 7
a862 7
	lmw	30,disisave(0)
	stmw	30,tempsave(0)
	lmw	30,disisave+8(0)
	stmw	30,tempsave+8(0)
	mfdar	30
	mfdsisr	31
	stmw	30,tempsave+16(0)
d865 4
a868 3
	mfsrr1	1
	mtcr	1
	mfsprg	1,1			/* restore SP (might have been overwritten) */
d870 3
a872 3
	lis	1,_C_LABEL(curpcb)@@ha
	lwz	1,_C_LABEL(curpcb)@@l(1)
	addi	1,1,USPACE		/* stack is top of user struct */
d878 3
a880 3
	lis	31,KERNEL_SEGMENT@@ha
	addi	31,31,KERNEL_SEGMENT@@l
	mtsr	KERNEL_SR,31
d883 6
a888 6
	mfmsr	7
	mfsrr1	31
	andi.	31,31,PSL_EE	/* restore EE from previous context */
	or	7,7,31
	ori	7,7,(PSL_ME|PSL_RI)
	mtmsr	7
d892 1
a892 1
	addi	3,1,8
d896 3
a898 3
	mfmsr	3
	andi.	3,3,~PSL_EE@@l
	mtmsr	3
d900 2
a901 2
	lwz	5,FRAME_SRR1+8(1)
	mtcr	5
d903 3
a905 3
	lis	3,_C_LABEL(astpending)@@ha
	lwz	4,_C_LABEL(astpending)@@l(3)
	andi.	4,4,1
d907 2
a908 2
	li	6,EXC_AST
	stw	6,FRAME_EXC+8(1)
d921 1
a921 1
	xor	3,3,3
d923 2
a924 2
	mtlr	31
	mr	3,30
d932 3
a934 3
	mfdsisr	31			/* test whether this may be a spill fault */
	mtcr	31
	mtsprg	1,1			/* save SP */
d936 22
a957 22
	lis	1,spillstk+SPILLSTK@@ha
	addi	1,1,spillstk+SPILLSTK@@l	/* get spill stack */
	stwu	1,-52(1)
	stw	0,48(1)			/* save non-volatile registers */
	stw	3,44(1)
	stw	4,40(1)
	stw	5,36(1)
	stw	6,32(1)
	stw	7,28(1)
	stw	8,24(1)
	stw	9,20(1)
	stw	10,16(1)
	stw	11,12(1)
	stw	12,8(1)
	mfxer	30			/* save XER */
	mtsprg	2,30
	mflr	30			/* save trap type */
	mfctr	31			/* & CTR */
	mfdar	3
	mfsrr1  4
	mfdsisr	5
	li	6, 0
d960 16
a975 16
	cmpwi	0,3,0
	mtctr	31			/* restore CTR */
	mtlr	30			/* and trap type */
	mfsprg	31,2			/* get saved XER */
	mtxer	31			/* restore XER */
	lwz	12,8(1)			/* restore non-volatile registers */
	lwz	11,12(1)
	lwz	10,16(1)
	lwz	9,20(1)
	lwz	8,24(1)
	lwz	7,28(1)
	lwz	6,32(1)
	lwz	5,36(1)
	lwz	4,40(1)
	lwz	3,44(1)
	lwz	0,48(1)
d977 4
a980 4
	mfsprg	1,1			/* restore SP */
	mtcr	29			/* restore CR */
	mtlr	28			/* restore LR */
	lmw	28,disisave(0)		/* restore r28-r31 */
d987 26
a1012 26
	mfsrr1	31			/* test whether this may be a spill fault */
	mtcr	31
	mtsprg	1,1			/* save SP */
	bc	4,1,disitrap		/* branch if table miss is false */
	lis	1,spillstk+SPILLSTK@@ha
	addi	1,1,spillstk+SPILLSTK@@l	/* get spill stack */
	stwu	1,-52(1)
	stw	0,48(1)			/* save non-volatile registers */
	stw	3,44(1)
	stw	4,40(1)
	stw	5,36(1)
	stw	6,32(1)
	stw	7,28(1)
	stw	8,24(1)
	stw	9,20(1)
	stw	10,16(1)
	stw	11,12(1)
	stw	12,8(1)
	mfxer	30			/* save XER */
	mtsprg	2,30
	mflr	30			/* save trap type */
	mfctr	31			/* & ctr */
	mfsrr0	3
	mfsrr1  4
	li	5, 0
	li	6, 1
d1020 27
a1046 27
	stwu	1,-88(1);		/* temporarily */		\
	stw	0,84(1);						\
	mfsprg	0,1;			/* get original SP */		\
	stw	0,0(1);			/* and store it */		\
	stw	3,80(1);						\
	stw	4,76(1);						\
	stw	5,72(1);						\
	stw	6,68(1);						\
	stw	7,64(1);						\
	stw	8,60(1);						\
	stw	9,56(1);						\
	stw	10,52(1);						\
	stw	11,48(1);						\
	stw	12,44(1);						\
	stw	28,40(1);		/* saved LR */			\
	stw	29,36(1);		/* saved CR */			\
	stw	30,32(1);		/* saved XER */			\
	lmw	28,tempsave(0);		/* restore r28-r31 */		\
	mfctr	6;							\
	lis	5,_C_LABEL(intr_depth)@@ha;				\
	lwz	5,_C_LABEL(intr_depth)@@l(5);				\
	mfsrr0	4;							\
	mfsrr1	3;							\
	stw	6,28(1);						\
	stw	5,20(1);						\
	stw	4,12(1);						\
	stw	3,8(1);							\
d1048 6
a1053 6
	lis	3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@ha;		\
	addi	3,3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@l;		\
	mtsr	KERNEL_SR,3;						\
	mfmsr	5;							\
	ori	5,5,(PSL_IR|PSL_DR|PSL_RI);				\
	mtmsr	5;							\
d1064 3
a1066 3
	mfmsr	3
	andi.	3,3,~(PSL_EE|PSL_ME|PSL_RI|PSL_DR|PSL_IR)@@l
	mtmsr	3
d1069 14
a1082 14
	lwz	12,44(1)
	lwz	11,48(1)
	lwz	10,52(1)
	lwz	9,56(1)
	lwz	8,60(1)
	lwz	7,64(1)
	lwz	6,8(1)
	lwz	5,12(1)
	lwz	4,28(1)
	lwz	3,32(1)
	mtsrr1	6
	mtsrr0	5
	mtctr	4
	mtxer	3
d1084 1
a1084 1
	mtcr	6			/* saved SRR1 */
d1086 7
a1092 7
	lis	3,_C_LABEL(curpm)@@ha	/* get current pmap real address */
	lwz	3,_C_LABEL(curpm)@@l(3)
	lwz	3,PM_KERNELSR(3)
	mtsr	KERNEL_SR,3		/* Restore kernel SR */
	lis	3,_C_LABEL(astpending)@@ha	/* Test AST pending */
	lwz	4,_C_LABEL(astpending)@@l(3)
	andi.	4,4,1
d1095 16
a1110 16
	lwz	3,0(1)			/* get saved SP */
	mtsprg	1,3
	li	6,EXC_AST
	stmw	28,tempsave(0)		/* establish tempsave again */
	mtlr	6
	lwz	28,40(1)		/* saved LR */
	lwz	29,36(1)		/* saved CR */
	lwz	6,68(1)
	lwz	5,72(1)
	lwz	4,76(1)
	lwz	3,80(1)
	lwz	0,84(1)
	lis	30,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	31,_C_LABEL(intr_depth)@@l(30)
	addi	31,31,-1
	stw	31,_C_LABEL(intr_depth)@@l(30)
d1114 14
a1127 14
	lwz	5,36(1)
	lwz	6,40(1)
	mtcr	5
	mtlr	6
	lwz	6,68(1)
	lwz	5,72(1)
	lis	3,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	4,_C_LABEL(intr_depth)@@l(3)
	addi	4,4,-1
	stw	4,_C_LABEL(intr_depth)@@l(3)
	lwz	4,76(1)
	lwz	3,80(1)
	lwz	0,84(1)
	lwz	1,0(1)
d1135 1
a1135 1
	addi	3,1,8			/* intr frame */
d1147 5
a1151 5
	mtsprg	2,2
	mfmsr	3
	mtsrr1	3
	andi.	3,3,~(PSL_EE|PSL_ME)@@l
	mtmsr	3			/* disable interrupts */
d1153 6
a1158 6
	stmw	28,ipkdbsave(0)
	mflr	28
	li	29,EXC_BPT
	mtlr	29
	mfcr	29
	mtsrr0	28
d1166 1
a1166 1
	addi	3,1,8
d1168 1
a1168 1
	or.	3,3,3
d1171 2
a1172 2
	lwz	3,FRAME_EXC+8(1)	/* save exception */
	stw	3,ipkdbsave+8(0)
d1174 6
a1179 6
	mtsprg	1,1			/* prepare for entrance to realtrap */
	stmw	28,tempsave(0)
	mflr	28
	mfcr	29
	lwz	31,ipkdbsave+8(0)
	mtlr	31
d1188 4
a1191 4
	mfsrr0	3
	addi	3,3,4
	mtsrr0	3
	li	3,-1
d1200 5
a1204 5
	li	9,EXC_DSI		/* establish new fault routine */
	lwz	5,0(9)
	lis	6,ipkdbfault@@ha
	lwz	6,ipkdbfault@@l(6)
	stw	6,0(9)
d1206 3
a1208 3
	lis	8,_C_LABEL(ipkdbsr)@@ha
	lwz	8,_C_LABEL(ipkdbsr)@@l(8)
	mtsr	USER_SR,8
d1211 1
a1211 1
	dcbst	0,9			/* flush data... */
d1213 4
a1216 4
	icbi	0,9			/* and instruction caches */
	lbz	3,0(3)			/* fetch data */
	stw	5,0(9)			/* restore previous fault handler */
	dcbst	0,9			/* and flush data... */
d1218 1
a1218 1
	icbi	0,9			/* and instruction caches */
d1227 5
a1231 5
	li	9,EXC_DSI		/* establish new fault routine */
	lwz	5,0(9)
	lis	6,ipkdbfault@@ha
	lwz	6,ipkdbfault@@l(6)
	stw	6,0(9)
d1233 2
a1234 2
	lis	8,_C_LABEL(ipkdbsr)@@ha
	lwz	8,_C_LABEL(ipkdbsr)@@l(8)
d1238 1
a1238 1
	dcbst	0,9			/* flush data... */
d1240 5
a1244 5
	icbi	0,9			/* and instruction caches */
	mr	6,3
	xor	3,3,3
	stb	4,0(6)
	dcbst	0,6			/* Now do appropriate flushes to data... */
d1246 3
a1248 3
	icbi	0,6			/* and instruction caches */
	stw	5,0(9)			/* restore previous fault handler */
	dcbst	0,9			/* and flush data... */
d1250 1
a1250 1
	icbi	0,9			/* and instruction caches */	
d1265 11
a1275 11
	mflr	0
	mfcr	12
	mfmsr	2
	lis	4,_C_LABEL(curpcb)@@ha
	lwz	4,_C_LABEL(curpcb)@@l(4)
	stw	3,PCB_FAULT(4)
	stw	0,0(3)
	stw	2,4(3)
	stw	1,8(3)
	stmw	12,12(3)
	xor	3,3,3
d1289 1
a1289 1
	addi	1,1,-16			/* reserved space for callee */
d1291 2
a1292 2
	addi	3,1,16+8		/* compute &sf_sc */
	li	0,SYS_sigreturn
d1294 1
a1294 1
	li	0,SYS_exit
d1358 5
a1362 5
	mtsprg  1,1
	mfmsr   3
	mtsrr1  3
	andi.   3,3,~(PSL_EE|PSL_ME)@@l
	mtmsr   3                       /* disable interrupts */
d1364 6
a1369 6
	stmw    28,ddbsave(0)
	mflr    28
	li      29,EXC_BPT
	mtlr    29
	mfcr    29
	mtsrr0  28
d1377 1
a1377 1
	addi    3,1,8
d1379 1
a1379 1
	or.     3,3,3
d1382 2
a1383 2
	lwz     3,FRAME_EXC+8(1)        /* save exception */
	stw     3,ddbsave+8(0)
d1385 6
a1390 6
	mtsprg  1,1                     /* prepare for entrance to realtrap */
	stmw    28,tempsave(0)
	mflr    28
	mfcr    29
	lwz     31,ddbsave+8(0)
	mtlr    31
@


1.8
log
@Remove old unused debugging code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 2002/09/15 09:01:58 deraadt Exp $	*/
d1316 1
d1341 1
@


1.7
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.5 2002/09/06 14:24:35 drahn Exp $	*/
a139 37

#define LED_ADDR 0x800008c0
_ENTRY(_C_LABEL(led_dbg))
	stwu	1,-32(1)
	mflr	0
	stw	0,36(1)

	stw	4,8(1)
	stw	5,12(1)
	stw	6,16(1)
	stw	7,20(1)
	mfmsr	5

	mr	6,5
	ori	6,6,(PSL_IR|PSL_DR)@@l	/* turn on MMU */
	mtmsr	6
	sync
	isync

	lis	4,LED_ADDR@@ha
	addi	4,4,LED_ADDR@@l
	li	7,0
	ori	3,3,0x2000
	sthbrx	3,7,4

	sync
	mtmsr	5
	isync
	lwz	4,8(1)
	lwz	5,12(1)
	lwz	6,16(1)
	lwz	7,20(1)

	lwz	0,36(1)
	mtlr	0
	addi	1,1,32
	blr
@


1.6
log
@KNF
@
text
@d62 1
a62 1
	.type	_C_LABEL(where),@@object
d70 1
a70 1
/* arguments to start
d85 1
a85 1
	mr	0,5
d110 1
a110 1
	cmpwi	9,0
d129 1
a129 1

d192 1
a192 1

d202 1
a202 1

d222 1
a222 1
	bl	_C_LABEL(exit2)
d225 1
a225 2
	li	3,0			/* indicate exited process */

d227 1
d270 1
a270 1

d375 1
a375 1
	.type	_C_LABEL(intr_depth),@@object
d409 1
a409 1
	.globl	_C_LABEL(alitrap),_C_LABEL(alisize)
d411 7
a417 7
	mtsprg	1,1			/* save SP */
	stmw	28,tempsave(0)		/* free r28-r31 */
	mfdar	30
	mfdsisr	31
	stmw	30,tempsave+16(0)
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
d419 6
a424 6
	mfsrr1	31
	mtcr	31
	bc	4,17,1f			/* branch if PSL_PR is clear */
	lis	1,_C_LABEL(curpcb)@@ha
	lwz	1,_C_LABEL(curpcb)@@l(1)
	addi	1,1,USPACE		/* stack is top of user struct */
d426 1
a426 1
	bla	s_trap
d756 1
a756 1
#define ddbsave 0xde0			/* primary save area for DDB */
d760 4
a763 4
	.local	ddbstk
	.comm	ddbstk,INTSTK,8		/* ddb stack */

	.globl	_C_LABEL(ddblow),_C_LABEL(ddbsize)
d765 7
a771 7
	mtsprg	1,1			/* save SP */
	stmw	28,ddbsave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
	lis	1,ddbstk+INTSTK@@ha	/* get new SP */
	addi	1,1,ddbstk+INTSTK@@l
	bla	ddbtrap
d773 1
a773 1
#endif	/* DDB */
d985 1
a985 1
	mfsrr1	4
d1040 1
a1040 1
	mfsrr1	4
d1176 1
a1176 1

d1280 1
a1280 1
	icbi	0,9			/* and instruction caches */
d1283 1
a1283 1

d1331 4
a1334 4
	.globl	_C_LABEL(intrnames)
	.type	_C_LABEL(intrnames),@@object
	.globl	_C_LABEL(eintrnames)
	.type	_C_LABEL(eintrnames),@@object
d1352 1
a1352 1
	.string "clock"
d1356 4
a1359 4
	.globl	_C_LABEL(intrcnt)
	.type	_C_LABEL(intrcnt),@@object
	.globl	_C_LABEL(eintrcnt)
	.type	_C_LABEL(eintrcnt),@@object
d1380 1
a1380 1
#ifdef DDB
d1384 1
a1384 1
	.globl	_C_LABEL(ddb_trap)
d1386 5
a1390 5
	mtsprg	1,1
	mfmsr	3
	mtsrr1	3
	andi.	3,3,~(PSL_EE|PSL_ME)@@l
	mtmsr	3			/* disable interrupts */
d1392 6
a1397 6
	stmw	28,ddbsave(0)
	mflr	28
	li	29,EXC_BPT
	mtlr	29
	mfcr	29
	mtsrr0	28
d1405 4
a1408 4
	addi	3,1,8
	bl	_C_LABEL(ddb_trap_glue)
	or.	3,3,3
	bne	ddbleave
d1410 2
a1411 2
	lwz	3,FRAME_EXC+8(1)	/* save exception */
	stw	3,ddbsave+8(0)
d1413 7
a1419 7
	mtsprg	1,1			/* prepare for entrance to realtrap */
	stmw	28,tempsave(0)
	mflr	28
	mfcr	29
	lwz	31,ddbsave+8(0)
	mtlr	31
	b	realtrap
@


1.5
log
@Restore EE bit of MSR on return from exception, rather than blindly
enabling it. pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.4 2002/07/24 02:19:28 drahn Exp $	*/
d62 1
a62 1
	.type  _C_LABEL(where),@@object
d70 1
a70 1
/* arguments to start 
d85 1
a85 1
	mr 	0,5
d110 1
a110 1
	cmpwi   9,0
d129 1
a129 1
	
d192 1
a192 1
	
d202 1
a202 1
	
d222 1
a222 1
	bl      _C_LABEL(exit2)
d225 2
a226 1
	li      3,0                     /* indicate exited process */
a227 1
	
d270 1
a270 1
	
d375 1
a375 1
	.type  _C_LABEL(intr_depth),@@object
d409 1
a409 1
	.globl  _C_LABEL(alitrap),_C_LABEL(alisize)
d411 7
a417 7
	mtsprg  1,1                     /* save SP */
	stmw    28,tempsave(0)          /* free r28-r31 */
	mfdar   30
	mfdsisr 31
	stmw    30,tempsave+16(0)
	mflr    28                      /* save LR */
	mfcr    29                      /* save CR */
d419 6
a424 6
	mfsrr1  31
	mtcr    31
	bc      4,17,1f                 /* branch if PSL_PR is clear */
	lis     1,_C_LABEL(curpcb)@@ha
	lwz     1,_C_LABEL(curpcb)@@l(1)
	addi    1,1,USPACE              /* stack is top of user struct */
d426 1
a426 1
	bla     s_trap
d756 1
a756 1
#define ddbsave 0xde0           /* primary save area for DDB */
d760 4
a763 4
	.local  ddbstk
	.comm   ddbstk,INTSTK,8         /* ddb stack */
 
	.globl  _C_LABEL(ddblow),_C_LABEL(ddbsize)
d765 7
a771 7
	mtsprg  1,1                     /* save SP */
	stmw    28,ddbsave(0)           /* free r28-r31 */
	mflr    28                      /* save LR */
	mfcr    29                      /* save CR */ 
	lis     1,ddbstk+INTSTK@@ha      /* get new SP */
	addi    1,1,ddbstk+INTSTK@@l
	bla     ddbtrap
d773 1
a773 1
#endif  /* DDB */
d985 1
a985 1
	mfsrr1  4
d1040 1
a1040 1
	mfsrr1  4
d1176 1
a1176 1
	
d1280 1
a1280 1
	icbi	0,9			/* and instruction caches */	
d1283 1
a1283 1
	
d1331 4
a1334 4
	.globl   _C_LABEL(intrnames)
	.type   _C_LABEL(intrnames),@@object
	.globl   _C_LABEL(eintrnames)
	.type   _C_LABEL(eintrnames),@@object
d1352 1
a1352 1
	.string "clock" 
d1356 4
a1359 4
	.globl   _C_LABEL(intrcnt)
	.type   _C_LABEL(intrcnt),@@object
	.globl   _C_LABEL(eintrcnt)
	.type   _C_LABEL(eintrcnt),@@object
d1380 1
a1380 1
#ifdef DDB   
d1384 1
a1384 1
	.globl  _C_LABEL(ddb_trap)
d1386 5
a1390 5
	mtsprg  1,1
	mfmsr   3
	mtsrr1  3
	andi.   3,3,~(PSL_EE|PSL_ME)@@l
	mtmsr   3                       /* disable interrupts */
d1392 6
a1397 6
	stmw    28,ddbsave(0)
	mflr    28
	li      29,EXC_BPT
	mtlr    29
	mfcr    29
	mtsrr0  28
d1405 4
a1408 4
	addi    3,1,8
	bl      _C_LABEL(ddb_trap_glue)
	or.     3,3,3
	bne     ddbleave
d1410 2
a1411 2
	lwz     3,FRAME_EXC+8(1)        /* save exception */
	stw     3,ddbsave+8(0)
d1413 7
a1419 7
	mtsprg  1,1                     /* prepare for entrance to realtrap */
	stmw    28,tempsave(0)
	mflr    28
	mfcr    29
	lwz     31,ddbsave+8(0)
	mtlr    31
	b       realtrap
@


1.4
log
@- change pte_spill_X() to take an extra parameter to determine if
  the fault is a EXE fault or R/W fault.

- mask/or the SR_NOEXEC bit into the segment register value
  when the number of executable pages becomes 0/non-zero.

- create segments with SR_NOEXEC set, will be cleared when first
  exec mapping in the segment is created.

- allow pte_spill_X() to deal with a new type of fault, page mapped
  but non executable, when execute was requested.

Adds up to - non-exec stack support for powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.3 2002/03/21 03:02:32 drahn Exp $	*/
d914 4
a917 1
	ori	7,7,(PSL_EE|PSL_ME|PSL_RI)
@


1.3
log
@Map up to 1G 1-1 using dbats, this disables dynamically swapped bats for now,
until the issue with SR invalidation/loading is corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2002/03/13 18:27:36 drahn Exp $	*/
d984 1
d1039 1
@


1.2
log
@Complete rewrite of the powerpc pmap handling, Instead of keeping
the spill list for each PTEG, the V->P translations are stored in
trees for each pmap. All valid kernel mappings are preallocated
in 1-1 memory so that tlb spill/loads for kernel accesses can be
looked up while physical, user mappings are not guaranteed to
be 1-1 mapped, thus the kernel must go virtual to look up user
mappings. While this is more expensive, the tree search is much
lower cost than the long linked list search. Also on each pmap_remove()
it was necessary to search the linked lists for each possible mapping,
now it just looks up the entry in the tree.
This change gives a 25-36% speedup in 'make build' time. What was
around 2:50 is now around 1:55 on a 733MHz G4.

This change causes a likely existing bug to appear quite often,
it deals with the segment register invalidation in kernel mode.
Because of that problem, currently this change limits the physical
memory used to 256MB. This limitation will be fixed soon, it is not
an error in the pmap code.

 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1 2001/09/01 15:57:06 drahn Exp $	*/
d443 1
d470 1
d486 1
d502 1
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc.
These files were missed in the original move of this directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.18 2001/06/24 22:00:12 drahn Exp $	*/
d973 2
d978 2
d981 2
a982 2
	bl	_C_LABEL(pte_spill)		/* try a spill */
	or.	3,3,3
d1032 2
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1 2001/09/01 15:57:06 drahn Exp $	*/
a442 1
#if 0
a468 1
#endif
a483 1
#if 0
a498 1
#endif
a972 2
	mfxer	30			/* save XER */
	mtsprg	2,30
a975 2
	mfsrr1  4
	mfdsisr	5
d977 2
a978 2
	bl	_C_LABEL(pte_spill_r)		/* try a spill */
	cmpwi	0,3,0
a1027 2
	mfsrr1  4
	li	5, 0
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1.6.1 2002/06/11 03:36:34 art Exp $	*/
d914 1
a914 4
	mfsrr1	31
	andi.	31,31,PSL_EE	/* restore EE from previous context */
	or	7,7,31
	ori	7,7,(PSL_ME|PSL_RI)
a983 1
	li	6, 0
a1037 1
	li	6, 1
@


1.1.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d140 37
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current from about a week ago
@
text
@a442 1
#if 0
a468 1
#endif
a483 1
#if 0
a498 1
#endif
a972 2
	mfxer	30			/* save XER */
	mtsprg	2,30
a975 2
	mfsrr1  4
	mfdsisr	5
d977 2
a978 2
	bl	_C_LABEL(pte_spill_r)		/* try a spill */
	cmpwi	0,3,0
a1027 2
	mfsrr1  4
	li	5, 0
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d141 37
d914 1
a914 4
	mfsrr1	31
	andi.	31,31,PSL_EE	/* restore EE from previous context */
	or	7,7,31
	ori	7,7,(PSL_ME|PSL_RI)
a983 1
	li	6, 0
a1037 1
	li	6, 1
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d35 2
d61 3
d70 1
a70 1
/* arguments to start
d81 3
a83 3
	lis	%r3, fwargsave@@ha
	stw	%r6, fwargsave@@l(%r3)
	stw	%r7, fwargsave@@l+4(%r3)
d85 2
a86 2
	mr	%r0,%r5
	cmpwi	0,%r0,0
d95 2
a96 2
	li	%r0,0
	mtmsr	%r0			/* Disable FPU/MMU/exceptions */
d100 5
a104 5
	lis	%r8,_end@@ha
	addi	%r8,%r8,_end@@l
	lis	%r3, fwargsave@@ha
	lwz	%r6, fwargsave@@l(%r3)
	lwz	%r7, fwargsave@@l+4(%r3)
d106 1
a106 1
	cmpwi	%r6, 0
d108 3
a110 3
	add	%r9,%r6,%r7
	lwz	%r9, -4(%r9)
	cmpwi   %r9,0
d112 3
a114 3
	lis	%r8,_C_LABEL(esym)@@ha
	stw	%r9,_C_LABEL(esym)@@l(%r8)
	mr	%r8, %r9
d117 20
a136 16
	li	%r9,PGOFSET
	add	%r8,%r8,%r9
	andc	%r8,%r8,%r9
	lis	%r9,idle_u@@ha
	stw	%r8,idle_u@@l(%r9)
	addi	%r8,%r8,USPACE		/* space for idle_u */
	lis	%r9,_C_LABEL(proc0paddr)@@ha
	stw	%r8,_C_LABEL(proc0paddr)@@l(%r9)
	addi	%r1,%r8,USPACE-FRAMELEN	/* stackpointer for proc0 */
	mr	%r4,%r1			/* end of mem reserved for kernel */
	li	%r0,0
	stwu	%r0,-16(%r1)		/* end of stack chain */

	lis	%r3,start@@ha
	addi	%r3,%r3,start@@l
	mr	%r5,%r6			/* args string */
d146 3
a148 4
	mfmsr	%r3
	/* disable interrupts while manipulating runque */
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3
d150 2
a151 2
	lis	%r8,_C_LABEL(whichqs)@@ha
	lwz	%r9,_C_LABEL(whichqs)@@l(%r8)
d153 1
a153 1
	or.	%r9,%r9,%r9
d155 3
a157 3

	ori	%r3,%r3,PSL_EE		/* reenable ints again */
	mtmsr	%r3
d161 3
a163 3
	mfmsr	%r3
	oris	%r3, %r3, PSL_POW@@h
	mtmsr	%r3
d165 1
a165 1

d176 5
a180 5
	lis	%r6,idle_u@@ha
	lwz	%r6,idle_u@@l(%r6)
	lis	%r7,_C_LABEL(curpcb)@@ha
	stw	%r6,_C_LABEL(curpcb)@@l(%r7)
	addi	%r1,%r6,USPACE-16	/* 16 bytes are reserved at stack top */
d188 1
a188 1
	li      %r3,0                     /* indicate exited process */
d190 1
d198 12
a209 13
	mflr	%r0			/* save lr */
	stw	%r0,4(%r1)
	stwu	%r1,-16(%r1)
	stw	%r31,12(%r1)
	stw	%r30,8(%r1)

	mr	%r30,%r3
	lis	%r3,_C_LABEL(curproc)@@ha
	li	%r31,0
	/* Zero to not accumulate cpu time */
	stw	%r31,_C_LABEL(curproc)@@l(%r3)
	lis	%r3,_C_LABEL(curpcb)@@ha
	lwz	%r31,_C_LABEL(curpcb)@@l(%r3)
d211 1
a211 1
	li	%r3,0
d213 1
a213 1
	stw	%r3,PCB_SPL(%r31)	/* save spl */
d216 2
a217 2
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l	/* disable interrupts while
d219 1
a219 1
	mtmsr	%r3
d222 2
a223 2
	lis	%r8,_C_LABEL(whichqs)@@ha
	lwz	%r9,_C_LABEL(whichqs)@@l(%r8)
d225 2
a226 2
	or.	%r9,%r9,%r9
	beq-	_C_LABEL(idle)		/* all queues empty */
d228 10
a237 10
	cntlzw	%r10,%r9
	lis	%r4,_C_LABEL(qs)@@ha
	addi	%r4,%r4,_C_LABEL(qs)@@l
	slwi	%r3,%r10,3
	add	%r3,%r3,%r4		/* select queue */

	lwz	%r31,P_FORW(%r3)	/* unlink first proc from queue */
	lwz	%r4,P_FORW(%r31)
	stw	%r4,P_FORW(%r3)
	stw	%r3,P_BACK(%r4)
d239 1
a239 1
	cmpl	0,%r3,%r4		/* queue empty? */
d242 4
a245 4
	lis	%r3,0x80000000@@ha
	srw	%r3,%r3,%r10
	andc	%r9,%r9,%r3
	stw	%r9,_C_LABEL(whichqs)@@l(%r8)	/* mark it empty */
d248 3
a250 4
	/* just did this resched thing, clear resched */
	li	%r3,0
	lis	%r4,_C_LABEL(want_resched)@@ha
	stw	%r3,_C_LABEL(want_resched)@@l(%r4)
d252 1
a252 1
	stw	%r3,P_BACK(%r31)		/* probably superfluous */
d254 2
a255 2
	lis	%r4,_C_LABEL(curproc)@@ha
	stw	%r31,_C_LABEL(curproc)@@l(%r4)	/* record new process */
d257 3
a259 3
	mfmsr	%r3
	ori	%r3,%r3,PSL_EE		/* Now we can interrupt again */
	mtmsr	%r3
d261 1
a261 1
	cmpl	0,%r31,%r30		/* is it the same process? */
d264 1
a264 1
	or.	%r30,%r30,%r30		/* old process was exiting? */
d267 7
a273 7
	mfsr	%r10,USER_SR		/* save USER_SR for copyin/copyout */
	mfcr	%r11			/* save cr */
	mr	%r12,%r2		/* save r2 */
	stwu	%r1,-SFRAMELEN(%r1)	/* still running on old stack */
	stmw	%r10,8(%r1)
	lwz	%r3,P_ADDR(%r30)
	stw	%r1,PCB_SP(%r3)		/* save SP */
d276 16
a291 19
	/* disable interrupts while actually switching */
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3

	lwz	%r4,P_ADDR(%r31)
	lis	%r5,_C_LABEL(curpcb)@@ha
	stw	%r4,_C_LABEL(curpcb)@@l(%r5)	/* indicate new pcb */

	lwz	%r5,PCB_PMR(%r4)

	/* save real pmap pointer for spill fill */
	lis	%r6,_C_LABEL(curpm)@@ha
	stwu	%r5,_C_LABEL(curpm)@@l(%r6)
	stwcx.	%r5,%r0,%r6		/* clear possible reservation */

	addic.	%r5,%r5,64
	li	%r6,0
	mfsr	%r8,KERNEL_SR		/* save kernel SR */
d293 4
a296 4
	addis	%r6,%r6,-0x10000000@@ha	/* set new procs segment registers */
	or.	%r6,%r6,%r6		/* This is done from the real address pmap */
	lwzu	%r7,-4(%r5)		/* so we don't have to worry */
	mtsrin	%r7,%r6			/* about accessibility */
d298 1
a298 1
	mtsr	KERNEL_SR,%r8		/* restore kernel SR */
d301 1
a301 1
	lwz	%r1,PCB_SP(%r4)		/* get new procs SP */
d303 2
a304 2
	ori	%r3,%r3,PSL_EE		/* interrupts are okay again */
	mtmsr	%r3
d306 4
a309 4
	lmw	%r10,8(%r1)		/* get other regs */
	lwz	%r1,0(%r1)		/* get saved SP */
	mr	%r2,%r12		/* get saved r2 */
	mtcr	%r11			/* get saved cr */
d311 1
a311 1
	mtsr	USER_SR,%r10		/* get saved USER_SR */
d315 2
a316 2
	mr	%r30,%r7		/* save proc pointer */
	lwz	%r3,PCB_SPL(%r4)
d319 1
a319 1
	mr	%r3,%r30		/* curproc for special fork returns */
d321 5
a325 5
	lwz	%r31,12(%r1)
	lwz	%r30,8(%r1)
	addi	%r1,%r1,16
	lwz	%r0,4(%r1)
	mtlr	%r0
d346 2
a347 1
 * except ISI/DSI, ALI, and the interrupts
d354 7
a360 8
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,tempsave(%r0)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */

	/* Test whether we already had PR set */
	mfsrr1	%r31
	mtcr	%r31
d362 3
a364 3
	lis	%r1,_C_LABEL(curpcb)@@ha
	lwz	%r1,_C_LABEL(curpcb)@@l(%r1)
	addi	%r1,%r1,USPACE		/* stack is top of user struct */
d374 14
a387 15
	mtsprg  1,%r1			/* save SP */
	stmw    %r28,tempsave(0)	/* free r28-r31 */
	mfdar   %r30
	mfdsisr %r31
	stmw    %r30,tempsave+16(0)
	mflr    %r28			/* save LR */
	mfcr    %r29			/* save CR */

	/* Test whether we already had PR set */
	mfsrr1  %r31
	mtcr    %r31
	bc      4,17,1f			/* branch if PSL_PR is clear */
	lis     %r1,_C_LABEL(curpcb)@@ha
	lwz     %r1,_C_LABEL(curpcb)@@l(%r1)
	addi    %r1,%r1,USPACE              /* stack is top of user struct */
d401 5
a405 5
	stmw	%r28,disisave(0)	/* free r28-r31 */
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30			/* in SPRG2 */
	mfsrr1	%r31			/* test kernel mode */
d407 1
a407 1
	mtcr	%r31
d409 5
a413 5
	mfdar	%r31			/* get fault address */
	rlwinm	%r31,%r31,7,25,28	/* get segment * 8 */
	addis	%r31,%r31,_C_LABEL(battable)@@ha
	lwz	%r30,_C_LABEL(battable)@@l(31)	/* get batu */
	mtcr	%r30
d415 1
a415 1
	lwz	%r31,_C_LABEL(battable)+4@@l(%r31)	/* get batl */
d417 2
a418 2
	mftb	%r28
	andi.	%r28,%r28,1
d420 2
a421 2
	mtdbatu	2,%r30
	mtdbatl	2,%r31
d424 2
a425 2
	mtdbatu	3,%r30
	mtdbatl	3,%r31
d427 4
a430 4
	mfsprg	%r30,2			/* restore XER */
	mtxer	%r30
	mtcr	%r29			/* restore CR */
	lmw	%r28,disisave(0)	/* restore r28-r31 */
d434 1
a434 1
	mflr	%r28			/* save LR */
d445 4
a448 4
	stmw	%r28,disisave(0)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfsrr1	%r31			/* test kernel mode */
d450 1
a450 1
	mtcr	%r31
d452 5
a456 5
	mfsrr0	%r31			/* get fault address */
	rlwinm	%r31,%r31,7,25,28		/* get segment * 8 */
	addis	%r31,%r31,_C_LABEL(battable)@@ha
	lwz	%r30,_C_LABEL(battable)@@l(31)	/* get batu */
	mtcr	%r30
d458 5
a462 5
	mtibatu	3,%r30
	lwz	%r30,_C_LABEL(battable)+4@@l(31)	/* get batl */
	mtibatl	3,%r30
	mtcr	%r29			/* restore CR */
	lmw	%r28,disisave(0)	/* restore r28-r31 */
d476 10
a485 10
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,tempsave(0)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	lis	%r1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	%r1,%r1,intstk+INTSTK@@l
	lwz	%r31,0(%r1)		/* were we already running on intstk? */
	addic.	%r31,%r31,%r1
	stw	%r31,0(%r1)
d487 1
a487 1
	mfsprg	%r1,1			/* yes, get old SP */
d499 10
a508 10
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,tempsave(0)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	lis	%r1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	%r1,%r1,intstk+INTSTK@@l
	lwz	%r31,0(%r1)		/* were we already running on intstk? */
	addic.	%r31,%r31,%r1
	stw	%r31,0(%r1)
d510 1
a510 1
	mfsprg	%r1,1			/* yes, get old SP */
d535 5
a539 5
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,ICMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
d541 1
a541 1
	mtctr	%r1			/* load counter */
d543 2
a544 2
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
d547 2
a548 2
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	andi.	%r3,%r1,8		/* check G-bit */
d550 7
a556 7
	mtctr	%r0			/* restore counter */
	mfspr	%r0,IMISS		/* get the miss address for the tlbli */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	ori	%r1,%r1,0x100		/* set the reference bit */
	mtspr	RPA,%r1			/* set the pte */
	srwi	%r1,%r1,8		/* get byte 7 of pte */
d558 1
a558 1
	stb	%r1,6(%r2)		/* update page table */
d562 1
a562 1
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
d564 4
a567 4
	mfspr	%r2,HASH2			/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8			/* predec pointer */
d570 3
a572 3
	mfsrr1	%r3
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	addis	%r2,%r2,0x800		/* set srr<4> to flag prot violation */
d575 3
a577 3
	mfsrr1	%r3
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	addis	%r2,%r2,0x4000		/* set srr1<1> to flag pte not found */
d579 6
a584 6
	mtctr	%r0			/* restore counter */
	mtsrr1	%r2
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
d593 5
a597 5
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,DCMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
d599 1
a599 1
	mtctr	%r1			/* load counter */
d601 2
a602 2
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
d605 8
a612 8
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	mtctr	%r0			/* restore counter */
	mfspr	%r0,DMISS		/* get the miss address for the tlbld */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	ori	%r1,%r1,0x100		/* set the reference bit */
	mtspr	RPA,%r1			/* set the pte */
	srwi	%r1,%r1,8		/* get byte 7 of pte */
d614 1
a614 1
	stb	%r1,6(%r2)		/* update page table */
d618 1
a618 1
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
d620 4
a623 4
	mfspr	%r2,HASH2		/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8		/* predec pointer */
d626 12
a637 12
	mfsrr1	%r3
	lis	%r1,0x4000		/* set dsisr<1> to flag pte not found */
	mtctr	%r0			/* restore counter */
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	mtsrr1	%r2
	mtdsisr	%r1			/* load the dsisr */
	mfspr	%r1,DMISS		/* get the miss address */
	mtdar	%r1			/* put in dar */
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
d646 5
a650 5
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,DCMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
d652 1
a652 1
	mtctr	%r1			/* load counter */
d654 2
a655 2
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
d658 2
a659 2
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	andi.	%r3,%r1,0x80		/* check the C-bit */
d662 5
a666 5
	mtctr	%r0			/* restore counter */
	mfspr	%r0,DMISS		/* get the miss address for the tlbld */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	mtspr	RPA,%r1			/* set the pte */
d671 1
a671 1
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
d673 4
a676 4
	mfspr	%r2,HASH2		/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8		/* predec pointer */
d679 1
a679 1
	rlwinm.	%r3,%r1,30,0,1		/* test PP */
d681 1
a681 1
	andi.	%r3,%r1,1
d684 2
a685 2
	mfsrr1	%r3
	lis	%r1,0xa00	/* indicate protection violation on store */
d688 5
a692 5
	mfspr	%r3,DMISS		/* get the miss address */
	mfsrin	%r1,%r3			/* get the segment register */
	mfsrr1	%r3
	rlwinm	%r3,%r3,18,31,31	/* get PR-bit */
	rlwnm.	%r2,%r2,3,1,1		/* get the key */
d695 3
a697 3
	lwz	%r1,4(%r2)		/* reload tlb entry */
	ori	%r1,%r1,0x180
	sth	%r1,6(%r2)
d700 2
a701 2
	mfsrr1	%r3
	lis	%r1,0x4200		/* set dsisr<1> to flag pte not found */
d704 10
a713 10
	mtctr	%r0			/* restore counter */
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	mtsrr1	%r2
	mtdsisr	%r1			/* load the dsisr */
	mfspr	%r1,DMISS		/* get the miss address */
	mtdar	%r1			/* put in dar */
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
d723 3
a725 3
	.local	ddbstk
	.comm	ddbstk,INTSTK,8	/* ddb stack */

d728 7
a734 7
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,ddbsave(0)		/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	lis	%r1,ddbstk+INTSTK@@ha	/* get new SP */
	addi	%r1,%r1,ddbstk+INTSTK@@l
	bla	ddbtrap
d739 21
d772 6
a777 6
	mfsrr0	%r30;							\
	mfsrr1	%r31;							\
	stmw	%r30,savearea+24(0);					\
	mfmsr	%r30;							\
	ori	%r30,%r30,(PSL_DR|PSL_IR);				\
	mtmsr	%r30;							\
d779 20
a798 20
	mfsprg	%r31,1;							\
	stwu	%r31,-FRAMELEN(%r1);					\
	stw	%r0,FRAME_0+8(%r1);					\
	stw	%r31,FRAME_1+8(%r1);					\
	stw	%r28,FRAME_LR+8(%r1);					\
	stw	%r29,FRAME_CR+8(%r1);					\
	lmw	%r28,savearea(0);					\
	stmw	%r2,FRAME_2+8(%r1);					\
	lmw	%r28,savearea+16(0);					\
	mfxer	%r3;							\
	mfctr	%r4;							\
	mflr	%r5;							\
	andi.	%r5,%r5,0xff00;						\
	stw	%r3,FRAME_XER+8(%r1);					\
	stw	%r4,FRAME_CTR+8(%r1);					\
	stw	%r5,FRAME_EXC+8(%r1);					\
	stw	%r28,FRAME_DAR+8(%r1);					\
	stw	%r29,FRAME_DSISR+8(%r1);				\
	stw	%r30,FRAME_SRR0+8(%r1);					\
	stw	%r31,FRAME_SRR1+8(%r1)
d802 17
a818 17
	lwz	%r2,FRAME_SRR0+8(%r1);					\
	lwz	%r3,FRAME_SRR1+8(%r1);					\
	lwz	%r4,FRAME_CTR+8(%r1);					\
	lwz	%r5,FRAME_XER+8(%r1);					\
	lwz	%r6,FRAME_LR+8(%r1);					\
	lwz	%r7,FRAME_CR+8(%r1);					\
	stw	%r2,savearea(0);					\
	stw	%r3,savearea+4(0);					\
	mtctr	%r4;							\
	mtxer	%r5;							\
	mtlr	%r6;							\
	mtsprg	1,%r7;			/* save cr */			\
	lmw	%r2,FRAME_2+8(%r1);					\
	lwz	%r0,FRAME_0+8(%r1);					\
	lwz	%r1,FRAME_1+8(%r1);					\
	mtsprg	2,%r2;			/* save r2 & r3 */		\
	mtsprg	3,%r3;							\
d820 5
a824 5
	mfmsr	%r2;							\
	lis	%r3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@ha;			\
	addi	%r3,%r3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@l;		\
	andc	%r2,%r2,%r3;						\
	mtmsr	%r2;							\
d827 2
a828 2
	lwz	%r3,savearea+4(0);					\
	mtcr	%r3;							\
d831 14
a844 14
	lis	%r2,_C_LABEL(curpm)@@ha;	/* get real address of pmap */	\
	lwz	%r2,_C_LABEL(curpm)@@l(2);					\
	lwz	%r3,PM_USRSR(%r2);					\
	mtsr	USER_SR,%r3;						\
	lwz	%r3,PM_KERNELSR(%r2);					\
	mtsr	KERNEL_SR,%r3;						\
1:	mfsprg	%r2,1;			/* restore cr */		\
	mtcr	%r2;							\
	lwz	%r2,savearea(0);					\
	lwz	%r3,savearea+4(0);					\
	mtsrr0	%r2;							\
	mtsrr1	%r3;							\
	mfsprg	%r2,2;			/* restore r2 & r3 */		\
	mfsprg	%r3,3
d850 7
a856 7
	lmw	%r30,disisave(0)
	stmw	%r30,tempsave(0)
	lmw	%r30,disisave+8(0)
	stmw	%r30,tempsave+8(0)
	mfdar	%r30
	mfdsisr	%r31
	stmw	%r30,tempsave+16(0)
d858 4
a861 5
	/* Test whether we already had PR set */
	mfsrr1	%r1
	mtcr	%r1
	/* restore SP (might have been overwritten) */
	mfsprg	%r1,1
d863 3
a865 3
	lis	%r1,_C_LABEL(curpcb)@@ha
	lwz	%r1,_C_LABEL(curpcb)@@l(%r1)
	addi	%r1,%r1,USPACE		/* stack is top of user struct */
d871 3
a873 3
	lis	%r31,KERNEL_SEGMENT@@ha
	addi	%r31,%r31,KERNEL_SEGMENT@@l
	mtsr	KERNEL_SR,%r31
d876 6
a881 6
	mfmsr	%r7
	mfsrr1	%r31
	andi.	%r31,%r31,PSL_EE	/* restore EE from previous context */
	or	%r7,%r7,%r31
	ori	%r7,%r7,(PSL_ME|PSL_RI)
	mtmsr	%r7
d885 1
a885 1
	addi	%r3,%r1,8
d889 3
a891 3
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3
d893 2
a894 2
	lwz	%r5,FRAME_SRR1+8(%r1)
	mtcr	%r5
d896 3
a898 3
	lis	%r3,_C_LABEL(astpending)@@ha
	lwz	%r4,_C_LABEL(astpending)@@l(%r3)
	andi.	%r4,%r4,1
d900 2
a901 2
	li	%r6,EXC_AST
	stw	%r6,FRAME_EXC+8(%r1)
d914 1
a914 1
	li	%r3,0
d916 2
a917 2
	mtlr	%r31
	mr	%r3,%r30
d925 3
a927 3
	mfdsisr	%r31			/* test if this is spill fault */
	mtcr	%r31
	mtsprg	1,%r1			/* save SP */
d929 22
a950 22
	lis	%r1,spillstk+SPILLSTK@@ha
	addi	%r1,%r1,spillstk+SPILLSTK@@l	/* get spill stack */
	stwu	%r1,-52(%r1)
	stw	%r0,48(%r1)		/* save non-volatile registers */
	stw	%r3,44(%r1)
	stw	%r4,40(%r1)
	stw	%r5,36(%r1)
	stw	%r6,32(%r1)
	stw	%r7,28(%r1)
	stw	%r8,24(%r1)
	stw	%r9,20(%r1)
	stw	%r10,16(%r1)
	stw	%r11,12(1)
	stw	%r12,8(1)
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30
	mflr	%r30			/* save trap type */
	mfctr	%r31			/* & CTR */
	mfdar	%r3
	mfsrr1  %r4
	mfdsisr	%r5
	li	%r6, 0
d953 16
a968 16
	cmpwi	0,%r3,0
	mtctr	%r31			/* restore CTR */
	mtlr	%r30			/* and trap type */
	mfsprg	%r31,2			/* get saved XER */
	mtxer	%r31			/* restore XER */
	lwz	%r12,8(%r1)		/* restore non-volatile registers */
	lwz	%r11,12(%r1)
	lwz	%r10,16(%r1)
	lwz	%r9,20(%r1)
	lwz	%r8,24(%r1)
	lwz	%r7,28(%r1)
	lwz	%r6,32(%r1)
	lwz	%r5,36(%r1)
	lwz	%r4,40(%r1)
	lwz	%r3,44(%r1)
	lwz	%r0,48(%r1)
d970 4
a973 4
	mfsprg	%r1,1			/* restore SP */
	mtcr	%r29			/* restore CR */
	mtlr	%r28			/* restore LR */
	lmw	%r28,disisave(0)		/* restore r28-r31 */
d980 26
a1005 26
	mfsrr1	%r31			/* test if this may be a spill fault */
	mtcr	%r31
	mtsprg	1,%r1			/* save SP */
	bc	4,%r1,disitrap		/* branch if table miss is false */
	lis	%r1,spillstk+SPILLSTK@@ha
	addi	%r1,%r1,spillstk+SPILLSTK@@l	/* get spill stack */
	stwu	%r1,-52(%r1)
	stw	%r0,48(%r1)		/* save non-volatile registers */
	stw	%r3,44(%r1)
	stw	%r4,40(%r1)
	stw	%r5,36(%r1)
	stw	%r6,32(%r1)
	stw	%r7,28(%r1)
	stw	%r8,24(%r1)
	stw	%r9,20(%r1)
	stw	%r10,16(%r1)
	stw	%r11,12(%r1)
	stw	%r12,8(%r1)
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30
	mflr	%r30			/* save trap type */
	mfctr	%r31			/* & ctr */
	mfsrr0	%r3
	mfsrr1  %r4
	li	%r5, 0
	li	%r6, 1
d1013 27
a1039 27
	stwu	%r1,-88(%r1);		/* temporarily */		\
	stw	%r0,84(%r1);						\
	mfsprg	%r0,1;			/* get original SP */		\
	stw	%r0,0(%r1);		/* and store it */		\
	stw	%r3,80(%r1);						\
	stw	%r4,76(%r1);						\
	stw	%r5,72(%r1);						\
	stw	%r6,68(%r1);						\
	stw	%r7,64(%r1);						\
	stw	%r8,60(%r1);						\
	stw	%r9,56(%r1);						\
	stw	%r10,52(%r1);						\
	stw	%r11,48(%r1);						\
	stw	%r12,44(%r1);						\
	stw	%r28,40(%r1);		/* saved LR */			\
	stw	%r29,36(%r1);		/* saved CR */			\
	stw	%r30,32(%r1);		/* saved XER */			\
	lmw	%r28,tempsave(0);	/* restore r28-r31 */		\
	mfctr	%r6;							\
	lis	%r5,_C_LABEL(intr_depth)@@ha;				\
	lwz	%r5,_C_LABEL(intr_depth)@@l(%r5);			\
	mfsrr0	%r4;							\
	mfsrr1	%r3;							\
	stw	%r6,28(%r1);						\
	stw	%r5,20(%r1);						\
	stw	%r4,12(%r1);						\
	stw	%r3,8(%r1);						\
d1041 6
a1046 6
	lis	%r3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@ha;		\
	addi	%r3,%r3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@l;		\
	mtsr	KERNEL_SR,%r3;						\
	mfmsr	%r5;							\
	ori	%r5,%r5,(PSL_IR|PSL_DR|PSL_RI);				\
	mtmsr	%r5;							\
d1057 3
a1059 3
	mfmsr	%r3
	andi.	%r3,%r3,~(PSL_EE|PSL_ME|PSL_RI|PSL_DR|PSL_IR)@@l
	mtmsr	%r3
d1062 14
a1075 14
	lwz	%r12,44(%r1)
	lwz	%r11,48(%r1)
	lwz	%r10,52(%r1)
	lwz	%r9,56(%r1)
	lwz	%r8,60(%r1)
	lwz	%r7,64(%r1)
	lwz	%r6,8(%r1)
	lwz	%r5,12(%r1)
	lwz	%r4,28(%r1)
	lwz	%r3,32(%r1)
	mtsrr1	%r6
	mtsrr0	%r5
	mtctr	%r4
	mtxer	%r3
d1077 1
a1077 1
	mtcr	%r6			/* saved SRR1 */
d1079 7
a1085 7
	lis	%r3,_C_LABEL(curpm)@@ha	/* get current pmap real address */
	lwz	%r3,_C_LABEL(curpm)@@l(%r3)
	lwz	%r3,PM_KERNELSR(%r3)
	mtsr	KERNEL_SR,%r3		/* Restore kernel SR */
	lis	%r3,_C_LABEL(astpending)@@ha	/* Test AST pending */
	lwz	%r4,_C_LABEL(astpending)@@l(%r3)
	andi.	%r4,%r4,1
d1088 16
a1103 16
	lwz	%r3,0(%r1)		/* get saved SP */
	mtsprg	%r1,3
	li	%r6,EXC_AST
	stmw	%r28,tempsave(0)		/* establish tempsave again */
	mtlr	%r6
	lwz	%r28,40(%r1)		/* saved LR */
	lwz	%r29,36(%r1)		/* saved CR */
	lwz	%r6,68(%r1)
	lwz	%r5,72(%r1)
	lwz	%r4,76(%r1)
	lwz	%r3,80(%r1)
	lwz	%r0,84(%r1)
	lis	%r30,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	%r31,_C_LABEL(intr_depth)@@l(%r30)
	addi	%r31,%r31,-1
	stw	%r31,_C_LABEL(intr_depth)@@l(%r30)
d1107 14
a1120 14
	lwz	%r5,36(%r1)
	lwz	%r6,40(%r1)
	mtcr	%r5
	mtlr	%r6
	lwz	%r6,68(%r1)
	lwz	%r5,72(%r1)
	lis	%r3,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	%r4,_C_LABEL(intr_depth)@@l(%r3)
	addi	%r4,%r4,-1
	stw	%r4,_C_LABEL(intr_depth)@@l(%r3)
	lwz	%r4,76(%r1)
	lwz	%r3,80(%r1)
	lwz	%r0,84(%r1)
	lwz	%r1,0(%r1)
d1128 1
a1128 1
	addi	%r3,%r1,8			/* intr frame */
d1132 81
d1215 33
d1258 11
a1268 11
	mflr	%r0
	mfcr	%r12
	mfmsr	%r2
	lis	%r4,_C_LABEL(curpcb)@@ha
	lwz	%r4,_C_LABEL(curpcb)@@l(%r4)
	stw	%r3,PCB_FAULT(%r4)
	stw	%r0,0(%r3)
	stw	%r2,4(%r3)
	stw	%r1,8(%r3)
	stmw	%r12,12(%r3)
	li	%r3,0
d1282 1
a1282 1
	addi	%r1,%r1,-16		/* reserved space for callee */
d1284 2
a1285 2
	addi	%r3,%r1,16+8		/* compute &sf_sc */
	li	%r0,SYS_sigreturn
d1287 1
a1287 1
	li	%r0,SYS_exit
d1315 1
a1315 2
	.string "clock"
	.string "stat"
a1340 1
	.long 0
d1343 1
a1343 1
#ifdef DDB
d1349 5
a1353 5
	mtsprg  %r1,1
	mfmsr   %r3
	mtsrr1  %r3
	andi.   %r3,%r3,~(PSL_EE|PSL_ME)@@l
	mtmsr   %r3                       /* disable interrupts */
d1355 6
a1360 6
	stmw    %r28,ddbsave(0)
	mflr    %r28
	li      %r29,EXC_BPT
	mtlr    %r29
	mfcr    %r29
	mtsrr0  %r28
d1368 1
a1368 1
	addi    %r3,%r1,8
d1370 1
a1370 1
	or.     %r3,%r3,%r3
d1373 2
a1374 2
	lwz     %r3,FRAME_EXC+8(%r1)        /* save exception */
	stw     %r3,ddbsave+8(0)
d1376 6
a1381 6
	mtsprg  %r1,1                     /* prepare for entrance to realtrap */
	stmw    %r28,tempsave(0)
	mflr    %r28
	mfcr    %r29
	lwz     %r31,ddbsave+8(0)
	mtlr    %r31
@


1.1.4.5
log
@p_stat = SONPROC
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1.4.4 2004/02/19 10:49:03 niklas Exp $	*/
a248 3

	li	%r3,SONPROC
	stb	%r3,P_STAT(%r31)
@


