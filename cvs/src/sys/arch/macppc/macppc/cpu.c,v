head	1.82;
access;
symbols
	OPENBSD_6_2:1.82.0.8
	OPENBSD_6_2_BASE:1.82
	OPENBSD_6_1:1.82.0.10
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.82.0.6
	OPENBSD_6_0_BASE:1.82
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.82.0.4
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.75.0.6
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.71.0.2
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.67.0.6
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.4
	OPENBSD_5_0:1.67.0.2
	OPENBSD_5_0_BASE:1.67
	OPENBSD_4_9:1.66.0.4
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.66.0.2
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.64.0.2
	OPENBSD_4_7_BASE:1.64
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.36.0.4
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.36.0.2
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.10
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.82
date	2015.06.04.18.01.44;	author kettenis;	state Exp;
branches;
next	1.81;
commitid	1H8s2HmAwVCuiEvR;

1.81
date	2015.03.31.16.00.38;	author mpi;	state Exp;
branches;
next	1.80;
commitid	MMWnK4Mn4W58afQM;

1.80
date	2015.03.31.15.51.05;	author mpi;	state Exp;
branches;
next	1.79;
commitid	V6LJj7jikqpWX3RD;

1.79
date	2014.10.09.13.58.40;	author mpi;	state Exp;
branches;
next	1.78;
commitid	IjrYui5GT2zL2J9b;

1.78
date	2014.10.08.10.12.41;	author mpi;	state Exp;
branches;
next	1.77;
commitid	744ecbjJTf8RMATb;

1.77
date	2014.09.22.10.45.06;	author mpi;	state Exp;
branches;
next	1.76;
commitid	JMZSKK84Whvn9Hex;

1.76
date	2014.09.06.10.15.52;	author mpi;	state Exp;
branches;
next	1.75;
commitid	RzNS2F7j0UQHdMTX;

1.75
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2013.10.31.08.26.12;	author mpi;	state Exp;
branches;
next	1.73;

1.73
date	2013.10.09.17.43.50;	author mpi;	state Exp;
branches;
next	1.72;

1.72
date	2013.09.13.07.29.02;	author mpi;	state Exp;
branches;
next	1.71;

1.71
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.70;

1.70
date	2013.03.07.03.19.38;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2012.12.09.22.32.29;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2012.12.08.12.49.00;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2011.05.25.07.42.15;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.65;

1.65
date	2010.03.31.19.46.27;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.27.20.42.01;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.09.01.12.38;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.02.21.38.09;	author drahn;	state Exp;
branches;
next	1.61;

1.61
date	2009.04.14.16.01.04;	author oga;	state Exp;
branches;
next	1.60;

1.60
date	2008.11.21.17.35.52;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2008.10.15.23.23.49;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2008.09.18.03.56.25;	author drahn;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.02.19.10.01;	author drahn;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.02.06.46.07;	author drahn;	state Exp;
branches;
next	1.55;

1.55
date	2008.05.01.08.25.32;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2008.04.30.17.21.31;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2008.04.30.17.19.36;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2008.04.29.04.12.19;	author drahn;	state Exp;
branches;
next	1.51;

1.51
date	2008.04.29.04.08.25;	author drahn;	state Exp;
branches;
next	1.50;

1.50
date	2008.04.29.03.49.03;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2008.04.29.00.26.11;	author drahn;	state Exp;
branches;
next	1.48;

1.48
date	2008.04.26.22.37.41;	author drahn;	state Exp;
branches;
next	1.47;

1.47
date	2008.04.23.15.34.18;	author drahn;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.15.17.33.51;	author drahn;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.04.22.36.39;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.23.23.40.21;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.14.20.59.17;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.03.21.03.06;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.31.09.44.21;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.20.20.59.54;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.27.18.43.30;	author gwk;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.10.21.31.04;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.09.22.54.15;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.26.22.40.31;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.13.21.46.03;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.08.20.32.41;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.22.09.19.18;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.20.20.33.02;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.09.14.17.32;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.03.19.34.46;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.03.04.40.09;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.03.02.57.07;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.03.02.54.30;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.03.02.16.10;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.01.19.55.25;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.29.20.40.24;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.10.19.24.30;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.18.16.10.10;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.24.05.44.37;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.24.00.25.42;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.30.03.17.32;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.16.05.03.22;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.15.17.50.16;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.02.21.30.13;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.23.01.38.05;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.26.19.12.08;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.21.06.26.50;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.21.00.00.05;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.09.04.13.13;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.29.00.00.02;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.21.17.37.57;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.21.17.37.11;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.06.05.23.10.52;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.82
log
@The (no quite so) new kernel perfpolicy code calls cpu_setperf() from a
timeout.  Unfortunately the smu(4) CPU voltage slewing code sleeps, which
causes a kernel panic.  Prevent this by delegating the CPU frequency switching
and voltage slewing to a task.

ok mpi@@
@
text
@/*	$OpenBSD: cpu.c,v 1.81 2015/03/31 16:00:38 mpi Exp $ */

/*
 * Copyright (c) 1997 Per Fogelstrom
 * Copyright (c) 1997 RTMX Inc
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD for RTMX Inc
 *	North Carolina, USA, by Per Fogelstrom, Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/sysctl.h>
#include <sys/task.h>
#include <sys/device.h>
#include <dev/rndvar.h>

#include <uvm/uvm_extern.h>

#include <dev/ofw/openfirm.h>

#include <machine/autoconf.h>
#include <powerpc/bat.h>
#include <machine/cpu.h>
#include <machine/trap.h>
#include <powerpc/hid.h>

/* SCOM addresses (24-bit) */
#define SCOM_PCR	0x0aa001 /* Power Control Register */
#define SCOM_PSR	0x408001 /* Power Tuning Status Register */

/* SCOMC format */
#define SCOMC_ADDR_SHIFT	8
#define SCOMC_ADDR_MASK		0xffff0000
#define SCOMC_READ		0x00008000

/* Power (Tuning) Status Register */
#define PSR_CMD_RECEIVED	0x2000000000000000LL
#define PSR_CMD_COMPLETED	0x1000000000000000LL
#define PSR_FREQ_MASK		0x0300000000000000LL
#define PSR_FREQ_HALF		0x0100000000000000LL

struct cpu_info cpu_info[PPC_MAXPROCS];

char cpu_model[80];
char machine[] = MACHINE;	/* cpu architecture */

/* Definition of the driver for autoconfig. */
int	cpumatch(struct device *, void *, void *);
void	cpuattach(struct device *, struct device *, void *);

struct cfattach cpu_ca = {
	sizeof(struct device), cpumatch, cpuattach
};

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL
};

void ppc64_scale_frequency(u_int);
void (*ppc64_slew_voltage)(u_int);
void ppc64_setperf(int);

void config_l2cr(int);

int
cpumatch(struct device *parent, void *cfdata, void *aux)
{
	struct confargs *ca = aux;
	int *reg = ca->ca_reg;

	/* make sure that we're looking for a CPU. */
	if (strcmp(ca->ca_name, cpu_cd.cd_name) != 0)
		return (0);

	if (reg[0] >= PPC_MAXPROCS)
		return (0);

	return (1);
}

u_int32_t ppc_curfreq;
u_int32_t ppc_maxfreq;

int
ppc_cpuspeed(int *freq)
{
	*freq = ppc_curfreq;

	return (0);
}

static u_int32_t ppc_power_mode_data[2];

void
ppc64_scale_frequency(u_int freq_scale)
{
	u_int64_t psr;
	int s;

	s = ppc_intr_disable();

	/* Clear PCRH and PCR. */
	ppc_mtscomd(0x00000000);
	ppc_mtscomc(SCOM_PCR << SCOMC_ADDR_SHIFT);
	ppc_mtscomd(0x80000000);
	ppc_mtscomc(SCOM_PCR << SCOMC_ADDR_SHIFT);

	/* Set PCR. */
	ppc_mtscomd(ppc_power_mode_data[freq_scale] | 0x80000000);
	ppc_mtscomc(SCOM_PCR << SCOMC_ADDR_SHIFT);

	/* Wait until frequency change is completed. */
	do {
		ppc64_mtscomc((SCOM_PSR << SCOMC_ADDR_SHIFT) | SCOMC_READ);
		psr = ppc64_mfscomd();
		ppc64_mfscomc();
		if (psr & PSR_CMD_COMPLETED)
			break;
		DELAY(100);
	} while (psr & PSR_CMD_RECEIVED);

	if ((psr & PSR_FREQ_MASK) == PSR_FREQ_HALF)
		ppc_curfreq = ppc_maxfreq / 2;
	else
		ppc_curfreq = ppc_maxfreq;

	ppc_intr_enable(s);
}

extern int perflevel;

struct task ppc64_setperf_task;
int ppc64_perflevel;

void
ppc64_do_setperf(void *arg)
{
	if (ppc64_perflevel <= 50) {
		if (ppc_curfreq == ppc_maxfreq / 2)
			return;

		ppc64_scale_frequency(FREQ_HALF);
		if (ppc64_slew_voltage)
			ppc64_slew_voltage(FREQ_HALF);
	} else {
		if (ppc_curfreq == ppc_maxfreq)
			return;

		if (ppc64_slew_voltage)
			ppc64_slew_voltage(FREQ_FULL);
		ppc64_scale_frequency(FREQ_FULL);
	}
}

void
ppc64_setperf(int level)
{
	ppc64_perflevel = level;
	task_add(systq, &ppc64_setperf_task);
}

void
cpuattach(struct device *parent, struct device *dev, void *aux)
{
	struct confargs *ca = aux;
	int *reg = ca->ca_reg;
	u_int32_t cpu, pvr, hid0;
	char name[32];
	int qhandle, phandle, len;
	u_int32_t clock_freq = 0, timebase = 0;
	struct cpu_info *ci;

	ci = &cpu_info[reg[0]];
	ci->ci_cpuid = reg[0];
	ci->ci_intrdepth = -1;
	ci->ci_dev = dev;

	pvr = ppc_mfpvr();
	cpu = pvr >> 16;
	switch (cpu) {
	case PPC_CPU_MPC601:
		snprintf(cpu_model, sizeof(cpu_model), "601");
		break;
	case PPC_CPU_MPC603:
		snprintf(cpu_model, sizeof(cpu_model), "603");
		break;
	case PPC_CPU_MPC604:
		snprintf(cpu_model, sizeof(cpu_model), "604");
		break;
	case PPC_CPU_MPC603e:
		snprintf(cpu_model, sizeof(cpu_model), "603e");
		break;
	case PPC_CPU_MPC603ev:
		snprintf(cpu_model, sizeof(cpu_model), "603ev");
		break;
	case PPC_CPU_MPC750:
		snprintf(cpu_model, sizeof(cpu_model), "750");
		break;
	case PPC_CPU_MPC604ev:
		snprintf(cpu_model, sizeof(cpu_model), "604ev");
		break;
	case PPC_CPU_MPC7400:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "7400");
		break;
	case PPC_CPU_MPC7447A:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "7447A");
		break;
	case PPC_CPU_MPC7448:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "7448");
		break;
	case PPC_CPU_IBM970:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "970");
		break;
	case PPC_CPU_IBM970FX:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "970FX");
		break;
	case PPC_CPU_IBM970MP:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "970MP");
		break;
	case PPC_CPU_IBM750FX:
		snprintf(cpu_model, sizeof(cpu_model), "750FX");
		break;
	case PPC_CPU_MPC7410:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "7410");
		break;
	case PPC_CPU_MPC7450:
		ppc_altivec = 1;
		if ((pvr & 0xf) < 3)
			snprintf(cpu_model, sizeof(cpu_model), "7450");
		 else
			snprintf(cpu_model, sizeof(cpu_model), "7451");
		break;
	case PPC_CPU_MPC7455:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "7455");
		break;
	case PPC_CPU_MPC7457:
		ppc_altivec = 1;
		snprintf(cpu_model, sizeof(cpu_model), "7457");
		break;
	default:
		snprintf(cpu_model, sizeof(cpu_model), "Version %x", cpu);
		break;
	}
	snprintf(cpu_model + strlen(cpu_model),
	    sizeof(cpu_model) - strlen(cpu_model),
	    " (Revision 0x%x)", pvr & 0xffff);
	printf(": %s", cpu_model);

	for (qhandle = OF_peer(0); qhandle; qhandle = phandle) {
                len = OF_getprop(qhandle, "device_type", name, sizeof(name));
                if (len >= 0 && strcmp(name, "cpu") == 0) {
			OF_getprop(qhandle, "clock-frequency", &clock_freq,
			    sizeof(clock_freq));
			OF_getprop(qhandle, "timebase-frequency", &timebase,
			    sizeof(timebase));
			break;
		}
                if ((phandle = OF_child(qhandle)))
                        continue;
                while (qhandle) {
                        if ((phandle = OF_peer(qhandle)))
                                break;
                        qhandle = OF_parent(qhandle);
                }
	}

	if (timebase != 0) {
		ticks_per_sec = timebase;
		ns_per_tick = 1000000000 / ticks_per_sec;
	}


	if (clock_freq != 0) {
		/* Openfirmware stores clock in Hz, not MHz */
		clock_freq /= 1000000;
		printf(": %d MHz", clock_freq);
		ppc_curfreq = ppc_maxfreq = clock_freq;
		cpu_cpuspeed = ppc_cpuspeed;
	}

	if (cpu == PPC_CPU_IBM970FX) {
		u_int64_t psr;
		int s;

		s = ppc_intr_disable();
		ppc64_mtscomc((SCOM_PSR << SCOMC_ADDR_SHIFT) | SCOMC_READ);
		psr = ppc64_mfscomd();
		ppc64_mfscomc();
		ppc_intr_enable(s);

		if ((psr & PSR_FREQ_MASK) == PSR_FREQ_HALF) {
			ppc_curfreq = ppc_maxfreq / 2;
			perflevel = 50;
		}

		if (OF_getprop(qhandle, "power-mode-data",
		    &ppc_power_mode_data, sizeof ppc_power_mode_data) >= 8) {
			task_set(&ppc64_setperf_task, ppc64_do_setperf, NULL);
			cpu_setperf = ppc64_setperf;
		}
	}

	/* power savings mode */
	hid0 = ppc_mfhid0();

	switch (cpu) {
	case PPC_CPU_MPC603:
	case PPC_CPU_MPC603e:
	case PPC_CPU_MPC750:
	case PPC_CPU_MPC7400:
	case PPC_CPU_IBM750FX:
	case PPC_CPU_MPC7410:
		/* select DOZE mode */
		hid0 &= ~(HID0_NAP | HID0_SLEEP);
		hid0 |= HID0_DOZE | HID0_DPM;
		ppc_cpuidle = 1;
		break;
	case PPC_CPU_MPC7447A:
	case PPC_CPU_MPC7448:
	case PPC_CPU_MPC7450:
	case PPC_CPU_MPC7455:
	case PPC_CPU_MPC7457:
		/* select NAP mode */
		hid0 &= ~(HID0_DOZE | HID0_SLEEP);
		hid0 |= HID0_NAP | HID0_DPM;
		/* try some other flags */
		hid0 |= HID0_SGE | HID0_BTIC;
		hid0 |= HID0_LRSTK | HID0_FOLD | HID0_BHT;
		/* Disable BTIC on 7450 Rev 2.0 or earlier */
		if (cpu == PPC_CPU_MPC7450 && (pvr & 0xffff) < 0x0200)
			hid0 &= ~HID0_BTIC;
		ppc_cpuidle = 1;
		break;
	case PPC_CPU_IBM970:
	case PPC_CPU_IBM970FX:
		/* select NAP mode */
		hid0 &= ~(HID0_DOZE | HID0_DEEPNAP);
		hid0 |= HID0_NAP | HID0_DPM;
		ppc_cpuidle = 1;
		break;
	case PPC_CPU_IBM970MP:
		/* select DEEPNAP mode, which requires NAP */
		hid0 &= ~HID0_DOZE;
		hid0 |= HID0_DEEPNAP | HID0_NAP | HID0_DPM;
		ppc_cpuidle = 1;
		break;
	}
	ppc_mthid0(hid0);

	/* if processor is G3 or G4, configure L2 cache */
	switch (cpu) {
	case PPC_CPU_MPC750:
	case PPC_CPU_MPC7400:
	case PPC_CPU_IBM750FX:
	case PPC_CPU_MPC7410:
	case PPC_CPU_MPC7447A:
	case PPC_CPU_MPC7448:
	case PPC_CPU_MPC7450:
	case PPC_CPU_MPC7455:
	case PPC_CPU_MPC7457:
		config_l2cr(cpu);
		break;
	}
	printf("\n");
}

/* L2CR bit definitions */
#define L2CR_L2E        0x80000000 /* 0: L2 enable */
#define L2CR_L2PE       0x40000000 /* 1: L2 data parity enable */
#define L2CR_L2SIZ      0x30000000 /* 2-3: L2 size */
#define  L2SIZ_RESERVED         0x00000000
#define  L2SIZ_256K             0x10000000
#define  L2SIZ_512K             0x20000000
#define  L2SIZ_1M       0x30000000
#define L2CR_L2CLK      0x0e000000 /* 4-6: L2 clock ratio */
#define  L2CLK_DIS              0x00000000 /* disable L2 clock */
#define  L2CLK_10               0x02000000 /* core clock / 1   */
#define  L2CLK_15               0x04000000 /*            / 1.5 */
#define  L2CLK_20               0x08000000 /*            / 2   */
#define  L2CLK_25               0x0a000000 /*            / 2.5 */
#define  L2CLK_30               0x0c000000 /*            / 3   */
#define L2CR_L2RAM      0x01800000 /* 7-8: L2 RAM type */
#define  L2RAM_FLOWTHRU_BURST   0x00000000
#define  L2RAM_PIPELINE_BURST   0x01000000
#define  L2RAM_PIPELINE_LATE    0x01800000
#define L2CR_L2DO       0x00400000 /* 9: L2 data-only.
                                      Setting this bit disables instruction
                                      caching. */
#define L2CR_L2I        0x00200000 /* 10: L2 global invalidate. */
#define L2CR_L2CTL      0x00100000 /* 11: L2 RAM control (ZZ enable).
                                      Enables automatic operation of the
                                      L2ZZ (low-power mode) signal. */
#define L2CR_L2WT       0x00080000 /* 12: L2 write-through. */
#define L2CR_L2TS       0x00040000 /* 13: L2 test support. */
#define L2CR_L2OH       0x00030000 /* 14-15: L2 output hold. */
#define L2CR_L2SL       0x00008000 /* 16: L2 DLL slow. */
#define L2CR_L2DF       0x00004000 /* 17: L2 differential clock. */
#define L2CR_L2BYP      0x00002000 /* 18: L2 DLL bypass. */
#define L2CR_L2IP       0x00000001 /* 31: L2 global invalidate in progress
				       (read only). */
#ifdef L2CR_CONFIG
u_int l2cr_config = L2CR_CONFIG;
#else
u_int l2cr_config = 0;
#endif

/* L3CR bit definitions */
#define   L3CR_L3E                0x80000000 /*  0: L3 enable */
#define   L3CR_L3SIZ              0x10000000 /*  3: L3 size (0=1MB, 1=2MB) */

void
config_l2cr(int cpu)
{
	u_int l2cr, x;

	l2cr = ppc_mfl2cr();

	/*
	 * Configure L2 cache if not enabled.
	 */
	if ((l2cr & L2CR_L2E) == 0 && l2cr_config != 0) {
		l2cr = l2cr_config;
		ppc_mtl2cr(l2cr);

		/* Wait for L2 clock to be stable (640 L2 clocks). */
		delay(100);

		/* Invalidate all L2 contents. */
		l2cr |= L2CR_L2I;
		ppc_mtl2cr(l2cr);
		do {
			x = ppc_mfl2cr();
		} while (x & L2CR_L2IP);

		/* Enable L2 cache. */
		l2cr &= ~L2CR_L2I;
		l2cr |= L2CR_L2E;
		ppc_mtl2cr(l2cr);
	}

	if (l2cr & L2CR_L2E) {
		if (cpu == PPC_CPU_MPC7450 || cpu == PPC_CPU_MPC7455) {
			u_int l3cr;

			printf(": 256KB L2 cache");

			l3cr = ppc_mfl3cr();
			if (l3cr & L3CR_L3E)
				printf(", %cMB L3 cache",
				    l3cr & L3CR_L3SIZ ? '2' : '1');
		} else if (cpu == PPC_CPU_IBM750FX ||
			   cpu == PPC_CPU_MPC7447A || cpu == PPC_CPU_MPC7457)
			printf(": 512KB L2 cache");
		else if (cpu == PPC_CPU_MPC7448)                                                                                                 
			printf(": 1MB L2 cache");
		else {
			switch (l2cr & L2CR_L2SIZ) {
			case L2SIZ_256K:
				printf(": 256KB");
				break;
			case L2SIZ_512K:
				printf(": 512KB");
				break;
			case L2SIZ_1M:
				printf(": 1MB");
				break;
			default:
				printf(": unknown size");
			}
			printf(" backside cache");
		}
#if 0
		switch (l2cr & L2CR_L2RAM) {
		case L2RAM_FLOWTHRU_BURST:
			printf(" Flow-through synchronous burst SRAM");
			break;
		case L2RAM_PIPELINE_BURST:
			printf(" Pipelined synchronous burst SRAM");
			break;
		case L2RAM_PIPELINE_LATE:
			printf(" Pipelined synchronous late-write SRAM");
			break;
		default:
			printf(" unknown type");
		}

		if (l2cr & L2CR_L2PE)
			printf(" with parity");
#endif
	} else
		printf(": L2 cache not enabled");
}

#ifdef MULTIPROCESSOR

#define	INTSTK	(8*1024)		/* 8K interrupt stack */

int cpu_spinup(struct device *, struct cpu_info *);
void cpu_hatch(void);
void cpu_spinup_trampoline(void);

struct cpu_hatch_data {
	uint64_t tb;
	struct cpu_info *ci;
	uint32_t hid0;
	uint64_t hid1;
	uint64_t hid4;
	uint64_t hid5;
	int l2cr;
	int running;
};

volatile struct cpu_hatch_data *cpu_hatch_data;
volatile void *cpu_hatch_stack;

/*
 * XXX Due to a bug in our OpenFirmware interface/memory mapping,
 * machines with 64bit CPUs hang in the OF_finddevice() call below
 * if this array is stored on the stack.
 */
char cpuname[64];

int
cpu_spinup(struct device *self, struct cpu_info *ci)
{
	volatile struct cpu_hatch_data hatch_data, *h = &hatch_data;
	int i;
	struct pglist mlist;
	struct vm_page *m;
	int error;
	int size = 0;
	char *cp;
	u_char *reset_cpu;
	u_int node;

        /*
         * Allocate some contiguous pages for the interrupt stack
         * from the lowest 256MB (because bat0 always maps it va == pa).
         */
        size += INTSTK;
        size += 8192;   /* SPILLSTK(1k) + DDBSTK(7k) */

	TAILQ_INIT(&mlist);
	error = uvm_pglistalloc(size, 0x0, 0x10000000 - 1, 0, 0,
	    &mlist, 1, UVM_PLA_WAITOK);
	if (error) {
		printf(": unable to allocate idle stack\n");
		return -1;
	}

	m = TAILQ_FIRST(&mlist);
	cp = (char *)VM_PAGE_TO_PHYS(m);
	bzero(cp, size);

	ci->ci_intstk = cp + INTSTK;
	cpu_hatch_stack = ci->ci_intstk - sizeof(struct trapframe);

	h->ci = ci;
	h->running = 0;
	h->hid0 = ppc_mfhid0();
	if (ppc_proc_is_64b) {
		h->hid1 = ppc64_mfhid1();
		h->hid4 = ppc64_mfhid4();
		h->hid5 = ppc64_mfhid5();
	} else {
		h->l2cr = ppc_mfl2cr();
	}
	cpu_hatch_data = h;

	__asm volatile ("sync; isync");

	/* XXX OpenPIC */
	{
		int off;

		*(u_int *)EXC_RST = 0x48000002 | (u_int)cpu_spinup_trampoline;
		syncicache((void *)EXC_RST, 0x100);

		h->running = -1;

		snprintf(cpuname, sizeof(cpuname), "/cpus/@@%x", ci->ci_cpuid);
		node = OF_finddevice(cpuname);
		if (node == -1) {
			printf(": unable to locate OF node %s\n", cpuname);
			return  -1;
		}
		if (OF_getprop(node, "soft-reset", &off, 4) == 4) {
			reset_cpu = mapiodev(0x80000000 + off, 1);
			*reset_cpu = 0x4;
			__asm volatile ("eieio" ::: "memory");
			*reset_cpu = 0x0;
			__asm volatile ("eieio" ::: "memory");
		} else {
			/* Start secondary CPU. */
			reset_cpu = mapiodev(0x80000000 + 0x5c, 1);
			*reset_cpu = 0x4;
			__asm volatile ("eieio" ::: "memory");
			*reset_cpu = 0x0;
			__asm volatile ("eieio" ::: "memory");
		}

		/* Sync timebase. */
		h->tb = ppc_mftb() + 100000;	/* 3ms @@ 33MHz  */

		while (h->tb > ppc_mftb())
			;
                __asm volatile ("sync; isync");
                h->running = 0;

                delay(500000);
	}


	for (i = 0; i < 0x3fffffff; i++)
		if (h->running) {
			break;
		}

	return 0;
}

volatile static int start_secondary_cpu;

void
cpu_boot_secondary_processors(void)
{
	struct cpu_info *ci;
	int i;

	for (i = 0; i < PPC_MAXPROCS; i++) {
		ci = &cpu_info[i];
		if (ci->ci_cpuid == 0)
			continue;
		ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;

		sched_init_cpu(ci);

		cpu_spinup(NULL, ci);
	}

	start_secondary_cpu = 1;
	__asm volatile ("sync");
}

void cpu_startclock(void);

void
cpu_hatch(void)
{
	volatile struct cpu_hatch_data *h = cpu_hatch_data;
	int intrstate, s;

        /* Initialize timebase. */
	ppc_mttb(0);

	/* Initialize curcpu(). */
	ppc_mtsprg0((u_int)h->ci);

	ppc_mtibat0u(0);
	ppc_mtibat1u(0);
	ppc_mtibat2u(0);
	ppc_mtibat3u(0);
	ppc_mtdbat0u(0);
	ppc_mtdbat1u(0);
	ppc_mtdbat2u(0);
	ppc_mtdbat3u(0);

	if (ppc_proc_is_64b) {
		/*
		 * The Hardware Interrupt Offset Register should be
		 * cleared after initialization.
		 */
		ppc_mthior(0);
		__asm volatile ("sync");

		ppc_mthid0(h->hid0);
		ppc64_mthid1(h->hid1);
		ppc64_mthid4(h->hid4);
		ppc64_mthid5(h->hid5);
	} else if (h->l2cr != 0) {
		u_int x;

		ppc_mthid0(h->hid0);
		ppc_mtl2cr(h->l2cr & ~L2CR_L2E);

		/* Wait for L2 clock to be stable (640 L2 clocks). */
		delay(100);

		/* Invalidate all L2 contents. */
		ppc_mtl2cr((h->l2cr & ~L2CR_L2E)|L2CR_L2I);
		do {
			x = ppc_mfl2cr();
		} while (x & L2CR_L2IP);

		ppc_mtl2cr(h->l2cr);
	}

	/*
	 * Now enable translation (and machine checks/recoverable interrupts).
	 */
	pmap_enable_mmu();

	/* XXX OpenPIC */
	{
		/* Sync timebase. */
		while (h->running == -1)
			;
                __asm volatile ("sync; isync");
                ppc_mttb(h->tb);
	}

	ncpus++;
	h->running = 1;
	__asm volatile ("eieio" ::: "memory");

	while (start_secondary_cpu == 0)
		;

	__asm volatile ("sync; isync");

	curcpu()->ci_ipending = 0;
	curcpu()->ci_cpl = 0;

	s = splhigh();
	nanouptime(&curcpu()->ci_schedstate.spc_runtime);
	splx(s);

	intrstate = ppc_intr_disable();
	cpu_startclock();
	ppc_intr_enable(intrstate);

	/* Enable inter-processor interrupts. */
	openpic_set_priority(curcpu()->ci_cpuid, 14);

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}
#endif
@


1.81
log
@Make it possisble to disable block address translation mechanism on
processors that support it.

Due to the way trap code is patched it is currently not possible to
enabled/disable BAT at runtime.

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.80 2015/03/31 15:51:05 mpi Exp $ */
d40 1
d159 3
d163 1
a163 1
ppc64_setperf(int speed)
d165 1
a165 1
	if (speed <= 50) {
d183 7
d332 2
a333 1
		    &ppc_power_mode_data, sizeof ppc_power_mode_data) >= 8)
d335 1
@


1.80
log
@Merge two versions of ppc_check_procid().

ok miod@@, kettenis@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.79 2014/10/09 13:58:40 mpi Exp $ */
d48 1
a48 1
#include <machine/bat.h>
a531 1
	int sdr1;
a582 1
	h->sdr1 = ppc_mfsdr1();
d673 1
a673 2
	int intrstate;
	int scratch, i, s;
a680 4
	/*
	 * Initialize BAT registers to unmapped to not generate
	 * overlapping mappings below.
	 */
a689 20
	/*
	 * Now setup fixed bat registers
	 *
	 * Note that we still run in real mode, and the BAT
	 * registers were cleared above.
	 */
	/* IBAT0 used for initial 256 MB segment */
	ppc_mtibat0l(battable[0].batl);
	ppc_mtibat0u(battable[0].batu);

	/* DBAT0 used similar */
	ppc_mtdbat0l(battable[0].batl);
	ppc_mtdbat0u(battable[0].batu);

	/*
	 * Initialize segment registers.
	 */
	for (i = 0; i < 16; i++)
		ppc_mtsrin(PPC_KERNEL_SEG0 + i, i << ADDR_SR_SHIFT);

a718 1
	ppc_mtsdr1(h->sdr1);
d723 1
a723 2
	__asm__ volatile ("eieio; mfmsr %0; ori %0,%0,%1; mtmsr %0; sync;isync"
		      : "=r"(scratch) : "K"(PSL_IR|PSL_DR|PSL_ME|PSL_RI));
@


1.79
log
@Properly initialize secondary CPUs on 64bit machines.

Due to a bug in our Openfirmware client interface on G5, the call to
OF_finddevice() in cpu_spinup() will never return if the given argument
is on the stack.  Use a workaround for the moment and put it in the bss.

Yes, this is ugly, but it makes GENERIC.MP ``usable'' on Powermac7,2 and
7,3 and does not freeze your machine during the first boot.

Issue also reported by "The Mouse" on ppc@@, tested by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.78 2014/10/08 10:12:41 mpi Exp $ */
a174 48
	}
}

int ppc_proc_is_64b;
extern u_int32_t rfi_inst, rfid_inst, nop_inst;
struct patch {
	u_int32_t *s;
	u_int32_t *e;
};
extern struct patch rfi_start;
extern struct patch nop32_start;
extern struct patch nop64_start;


void
ppc_check_procid()
{
	u_int32_t cpu, pvr;
	u_int32_t *inst;
	struct patch *p;

	pvr = ppc_mfpvr();
	cpu = pvr >> 16;

	switch (cpu) {
	case PPC_CPU_IBM970:
	case PPC_CPU_IBM970FX:
	case PPC_CPU_IBM970MP:
		ppc_proc_is_64b = 1;
		for (p = &rfi_start; p->s; p++) {
			for (inst = p->s; inst < p->e; inst++)
				*inst = rfid_inst;
			syncicache(p->s, (p->e - p->s) * sizeof(*p->e));
		}
		for (p = &nop64_start; p->s; p++) {
			for (inst = p->s; inst < p->e; inst++)
				*inst = nop_inst;
			syncicache(p->s, (p->e - p->s) * sizeof(*p->e));
		}

		break;
	default:
		ppc_proc_is_64b = 0;
		for (p = &nop32_start; p->s; p++) {
			for (inst = p->s; inst < p->e; inst++)
				*inst = nop_inst;
			syncicache(p->s, (p->e - p->s) * sizeof(*p->e));
		}
@


1.78
log
@Introduce ppc_mttb() and use it instead of rerolling the move to time
base dance in inline assembly in various places.

tweak and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.77 2014/09/22 10:45:06 mpi Exp $ */
d575 4
a578 2
	int running;
	int hid0;
d581 1
d587 7
a604 1
	char cpuname[64];
a631 1
	h->l2cr = ppc_mfl2cr();
d633 7
d765 13
a777 2
	ppc_mthid0(h->hid0);
	if (h->l2cr != 0) {
d779 2
d791 1
a791 1
		
@


1.77
log
@Enable power saving modes for IBM PowerPC 970 CPUs.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.76 2014/09/06 10:15:52 mpi Exp $ */
d573 1
a578 1
	int tbu, tbl;
a630 1
		uint64_t tb;
d660 1
a660 2
		tb = ppc_mftb();
		tb += 100000;	/* 3ms @@ 33MHz  */
d662 1
a662 4
		h->tbu = tb >> 32;
		h->tbl = tb & 0xffffffff;

		while (tb > ppc_mftb())
d712 1
a712 1
        __asm ("mttbl %0; mttbu %0; mttbl %0" :: "r"(0));
a776 2
		u_int tbu = h->tbu;
		u_int tbl = h->tbl;
d780 1
a780 3
                __asm volatile ("mttbl %0" :: "r"(0));
                __asm volatile ("mttbu %0" :: "r"(tbu));
                __asm volatile ("mttbl %0" :: "r"(tbl));
@


1.76
log
@Rewrite cpu_idle & friends to not check and update the hid0 register
in the idle loop, in preparation for G5 support.

Only do a disable/enable interrupt dance if the running CPU supports a
sleep mode.

Fix entering ddb(8) from interrupt context by not modifying the return
address of the 'forced' trap frame.

While here, modify the existing logic to terminate prefetching of all
data streams if AltiVec is supported before setting the POW bit.

With inputs/explanations from drahn, looks ok to miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.75 2014/01/19 12:45:35 deraadt Exp $ */
d374 2
a375 2
	if (ppc_proc_is_64b == 0)
		hid0 = ppc_mfhid0();
d406 5
d412 4
a415 3
		/* select NAP mode */
		hid0 &= ~(HID0_NAP | HID0_DOZE | HID0_SLEEP);
		hid0 |= HID0_DPM;
d418 1
a418 2
	if (ppc_proc_is_64b == 0)
		ppc_mthid0(hid0);
@


1.75
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.74 2013/10/31 08:26:12 mpi Exp $ */
a52 2
extern u_int32_t	hid0_idle;

a108 2
int ppc_altivec;

d384 3
a386 3
		hid0 &= ~(HID0_NAP | HID0_DOZE | HID0_SLEEP);
		hid0_idle = HID0_DOZE;
		hid0 |= HID0_DPM;
d394 2
a395 3
		hid0 &= ~(HID0_NAP | HID0_DOZE | HID0_SLEEP);
		hid0_idle = HID0_NAP;
		hid0 |= HID0_DPM;
d402 1
@


1.74
log
@Add a header for various hardware implementation dependent register
(HID) definitions, from FreeBSD with tweaks, instead of defining
them in different places.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.73 2013/10/09 17:43:50 mpi Exp $ */
d41 1
a243 1
	ci->ci_randseed = 1;
d695 1
a695 1
		ci->ci_randseed = random();
@


1.73
log
@Initialize ns_per_tick as soon as we have read the timebase from the
device-tree to restore the behaviour present before my last change.

This fixes a regression seen on some Powerbooks where one of the two
kiic(4) would always timeout when trying to configure the audio chip.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.72 2013/09/13 07:29:02 mpi Exp $ */
d50 1
a51 10
/* only valid on 603(e,ev) and G3, G4 */
#define HID0_DOZE	(1 << (31-8))
#define HID0_NAP	(1 << (31-9))
#define HID0_SLEEP	(1 << (31-10))
#define HID0_DPM	(1 << (31-11))
#define HID0_SGE	(1 << (31-24))
#define HID0_BTIC	(1 << (31-26))
#define HID0_LRSTK	(1 << (31-27))
#define HID0_FOLD	(1 << (31-28))
#define HID0_BHT	(1 << (31-29))
@


1.72
log
@Initialize the variable guarding the clock interrupt routine after
calling initclocks().  This prevents hardclock() from trying to
schedule a softclock interrupt before its cookie has been allocated,
leading to a panic.

While here grab the ticks/second value from the OpenFirmware at the
same time we read the clock frequency, no need to look twice for the
same node.

Looks ok to kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.71 2013/06/03 16:55:22 guenther Exp $ */
d352 1
a352 1
	if (timebase != 0)
d354 3
@


1.71
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.70 2013/03/07 03:19:38 brad Exp $ */
d48 1
d245 2
a246 2
	int qhandle, phandle;
	u_int32_t clock_freq = 0;
a333 2
	/* This should only be executed on openfirmware systems... */

d335 6
a340 5
                if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
                    && !strcmp(name, "cpu")
                    && OF_getprop(qhandle, "clock-frequency",
                        &clock_freq, sizeof clock_freq) >= 0)
		{
d351 3
@


1.70
log
@Use switch statement for determining when to configure the L2 cache.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.69 2012/12/09 22:32:29 brad Exp $ */
d807 1
a807 1
	microuptime(&curcpu()->ci_schedstate.spc_runtime);
@


1.69
log
@Recognize 7448 and 970MP processors.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.68 2012/12/08 12:49:00 mpi Exp $ */
d422 11
a432 6
	/* if processor is G3 or G4, configure l2 cache */
	if (cpu == PPC_CPU_MPC750 || cpu == PPC_CPU_MPC7400 ||
	    cpu == PPC_CPU_IBM750FX || cpu == PPC_CPU_MPC7410 ||
	    cpu == PPC_CPU_MPC7447A || cpu == PPC_CPU_MPC7448 ||
	    cpu == PPC_CPU_MPC7450 || cpu == PPC_CPU_MPC7455 ||
	    cpu == PPC_CPU_MPC7457)
d434 2
@


1.68
log
@Recognize PowerPC 970 CPUs present in early PowerMac G5 from 2003 (7,2 and
7,3) and let OpenBSD boot on these machines, yay! The 970 are similar to
the 970FX except that they are manufactured in 130nm.

Fix an issue reported by Andrew Fresh and kirby@@ on misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.67 2011/05/25 07:42:15 mpi Exp $ */
d286 4
d298 4
d396 1
d413 1
d425 3
a427 2
	    cpu == PPC_CPU_MPC7447A || cpu == PPC_CPU_MPC7450 ||
	    cpu == PPC_CPU_MPC7455 || cpu == PPC_CPU_MPC7457) {
a428 1
	}
d519 2
@


1.67
log
@Add dfs(4), a driver to support the Dynamic Frequency Switching feature
found on some G4 PowerBook.

Tested by many, thanks.

ok sthen@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.66 2010/06/26 23:24:43 guenther Exp $ */
d211 1
d286 4
d402 1
@


1.66
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.65 2010/03/31 19:46:27 miod Exp $ */
a70 5
/* Frequency scaling */
#define FREQ_FULL	0
#define FREQ_HALF	1
#define FREQ_QUARTER	2	/* Not supported on IBM 970FX */

d116 2
a117 2
static u_int32_t ppc_curfreq;
static u_int32_t ppc_maxfreq;
@


1.65
log
@Make sure the boundaries of uvm_pglistalloc() calls are set up with low
being page-aligned, and high being end of page (i.e.
high & PAGE_MASK == PAGE_MASK) everywhere, for consistency. Future code
will depend on this.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.64 2009/08/27 20:42:01 miod Exp $ */
d39 1
a39 1
#include <sys/user.h>
d41 2
@


1.64
log
@Harmless sizeof ptr bug in ppc_check_procid(); ok drahn@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.63 2009/06/09 01:12:38 deraadt Exp $ */
d586 1
a586 1
	error = uvm_pglistalloc(size, 0x0, 0x10000000, 0, 0,
@


1.63
log
@backout interrupt diff until it the next round of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.61 2009/04/14 16:01:04 oga Exp $ */
d234 1
a234 1
			syncicache(p->s, (p->e - p->s) * sizeof(p->e));
@


1.62
log
@Reintroduce the macppc interrupt subsystem rewrite. Several bugs have
been found and corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.59 2008/10/15 23:23:49 deraadt Exp $ */
d793 1
a793 1
	openpic_set_priority(14);
@


1.61
log
@Convert the waitok field of uvm_pglistalloc to "flags", more will be added soon.

For the possibility of sleeping, the first two flags are UVM_PLA_WAITOK
and UVM_PLA_NOWAIT. It is an error not to show intention, so assert that
one of the two is provided. Switch over every caller in the tree to
using the appropriate flag.

ok art@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.60 2008/11/21 17:35:52 deraadt Exp $ */
d793 1
a793 1
	openpic_set_priority(curcpu()->ci_cpuid, 14);
@


1.60
log
@back out the new interrupt subsystem because some little bug still lurks in there
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.57 2008/05/02 19:10:01 drahn Exp $ */
d586 2
a587 1
	error = uvm_pglistalloc(size, 0x0, 0x10000000, 0, 0, &mlist, 1, 1);
@


1.59
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.58 2008/09/18 03:56:25 drahn Exp $ */
d792 1
a792 1
	openpic_set_priority(14);
@


1.58
log
@Redesign of the powerpc interrupt architecture, use true levels intead of
blocking specific interrupts. Needs signficant testing to prove that
one remaining elusive bug has been squashed.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.57 2008/05/02 19:10:01 drahn Exp $ */
d675 1
@


1.57
log
@Invalidate and initialize the l2 on secondary processors, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.56 2008/05/02 06:46:07 drahn Exp $ */
d791 1
a791 1
	openpic_set_priority(curcpu()->ci_cpuid, 14);
@


1.56
log
@Remove debug prints.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.55 2008/05/01 08:25:32 kettenis Exp $ */
d556 1
d602 1
d734 15
@


1.55
log
@Implement a nop IPI to signal other CPUs.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.54 2008/04/30 17:21:31 kettenis Exp $ */
a651 1
	printf("cpu%d: timebase %llx\n", cpu_number(), ppc_mftb());
a654 1
			printf("running\n");
a760 3

	printf("cpu%d: running\n", cpu_number());
	printf("cpu%d: timebase %llx\n", cpu_number(), ppc_mftb());
@


1.54
log
@Fix typo in last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.53 2008/04/30 17:19:36 kettenis Exp $ */
d686 1
a765 3
#ifdef notyet
	ppc_mtdec(ticks_per_intr);
#endif
d777 3
@


1.53
log
@Initialize randseed to 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.52 2008/04/29 04:12:19 drahn Exp $ */
d253 1
a253 1
	co->ci_randseed = 1;
@


1.52
log
@remove noise, (debug print).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.51 2008/04/29 04:08:25 drahn Exp $ */
d253 1
@


1.51
log
@PIR is not defined to be a writable register, do not use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.50 2008/04/29 03:49:03 drahn Exp $ */
a621 1
			printf(" soft-reset at %x:", off);
a627 1
			printf(" soft-reset not found:");
@


1.50
log
@Spin up secondary CPUs on more systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.49 2008/04/29 00:26:11 drahn Exp $ */
a698 3

	/* Set PIR . */
	ppc_mtpir(curcpu()->ci_cpuid);
@


1.49
log
@spillstk and ddbstk need to be per cpu. Found by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.48 2008/04/26 22:37:41 drahn Exp $ */
d573 2
d608 1
d615 22
a636 6
		/* Start secondary CPU. */
		reset_cpu = mapiodev(0x80000000 + 0x5c, 1);
		*reset_cpu = 0x4;
		__asm volatile ("eieio" ::: "memory");
		*reset_cpu = 0x5;
		__asm volatile ("eieio" ::: "memory");
@


1.48
log
@Changes to get closer to SMP.
add biglock before interrupt calls into the kernel.
switch the clock to using cpuinfo variables instead of globals
move cpu_switchto into C code so that on multiprocessor the FPU
and Altivec can be saved before switching CPUs.
add a lock into pmap when modifying the hash table.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.47 2008/04/23 15:34:18 drahn Exp $ */
d579 1
a579 1
        size += 4096;   /* SPILLSTK */
@


1.47
log
@Call sched_init_cpu() for all but boot processor. ok kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.46 2008/02/15 17:33:51 drahn Exp $ */
a600 4
#ifdef notyet
	ci->ci_lasttb = curcpu()->ci_lasttb;
#endif

d667 1
d672 1
d760 4
@


1.46
log
@Reenable idle modes on powerpc. Tested by kettenis and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.45 2007/12/04 22:36:39 kettenis Exp $ */
d661 3
@


1.45
log
@Remove remains of the idle pcb/stack.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.44 2007/10/10 15:53:52 art Exp $ */
d58 1
d380 3
a382 2
		hid0 &= ~(HID0_NAP | HID0_SLEEP);
		hid0 |= HID0_DOZE | HID0_DPM;
d389 3
a391 2
		hid0 &= ~(HID0_DOZE | HID0_SLEEP);
		hid0 |= HID0_NAP | HID0_DPM;
d401 2
a402 2
		hid0 &= ~(HID0_DOZE | HID0_SLEEP);
		hid0 |= HID0_NAP | HID0_DPM;
@


1.44
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.43 2007/05/23 23:40:21 kettenis Exp $ */
d557 1
a557 1
volatile int cpu_hatch_stack;
a563 1
	struct pcb *pcb;
d572 1
a572 1
         * Allocate some contiguous pages for the idle PCB and stack
a574 1
        size += USPACE;
d589 2
a590 10
        pcb = (struct pcb *)cp;
        ci->ci_idle_pcb = pcb;
        ci->ci_intstk = cp + USPACE + INTSTK;

        /*
         * Initialize the idle stack pointer, reserving space for an
         * (empty) trapframe (XXX is the trapframe really necessary?)
         */
        pcb->pcb_sp = (paddr_t)pcb + USPACE - sizeof(struct trapframe);
	cpu_hatch_stack = ci->ci_idle_pcb->pcb_sp;
@


1.43
log
@Add code to spin up secondary cpu's; still work in progress.

prompted by deraadt@@ a few times already.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.42 2007/05/14 20:59:17 kettenis Exp $ */
d679 1
a679 1
	int scratch, i;
d762 7
@


1.42
log
@Use value passed as in ca_reg as cpuid instead of unit number.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.41 2007/05/03 21:03:06 kettenis Exp $ */
d45 2
d542 3
d548 9
d559 99
d661 12
d678 84
a762 1

@


1.41
log
@Add dummy functions to make MULTIPROCESSOR kernels compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.40 2007/03/31 09:44:21 kettenis Exp $ */
d239 2
d247 2
a248 2
	ci = &cpu_info[dev->dv_unit];
	ci->ci_cpuid = dev->dv_unit;
@


1.40
log
@Make sure we not to match secondary cpu's on non-MP kernel.  I accidentally
didn't commit this bit, so it is still ok drahn@@, gwk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.39 2007/03/20 20:59:54 kettenis Exp $ */
d535 19
@


1.39
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.38 2006/12/12 23:14:27 dim Exp $ */
d104 1
d108 3
@


1.38
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.37 2006/11/27 18:43:30 gwk Exp $ */
d77 2
d239 6
@


1.37
log
@For the G5 processor setperf function, don't force perflevel to 50 or 100
perserve the illusion of a much finer granularity of performance control.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.36 2006/02/10 21:31:04 kettenis Exp $ */
d94 1
a94 1
int ppc64_setperf(int);
d163 1
a163 1
int
d168 1
a168 1
			return (0);
d175 1
a175 1
			return (0);
a180 2

	return (0);
@


1.36
log
@Recognize 7447/7457.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.35 2005/12/09 22:54:15 kettenis Exp $ */
d99 1
a99 4
cpumatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
a172 1
		perflevel = 50;
a179 1
		perflevel = 100;
@


1.35
log
@Add hook for voltage slewing the G5.
"figure you should just commit" drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.34 2005/11/26 22:40:31 kettenis Exp $ */
d299 4
d376 1
d400 1
a400 1
	    cpu == PPC_CPU_MPC7455) {
d490 2
a491 1
		} else if (cpu == PPC_CPU_IBM750FX || cpu == PPC_CPU_MPC7447A)
@


1.34
log
@Frequency scaling for IBM 970FX.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.33 2005/11/13 21:46:03 drahn Exp $ */
d66 5
d93 1
d173 3
a175 1
		ppc64_scale_frequency(1);
d181 3
a183 1
		ppc64_scale_frequency(0);
@


1.33
log
@Recognized 970MP processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.32 2005/11/08 20:32:41 kettenis Exp $ */
d58 1
a58 1
#define SCOM_PCR	0x400801 /* Power Management Control Register */
d67 4
a70 2
#define PSR_FREQ_MASK	0x0300000000000000LL
#define PSR_FREQ_HALF	0x0100000000000000LL
d87 4
a90 1
void config_l2cr(int cpu);
d120 60
d233 1
a233 1
	unsigned int clock_freq = 0;
d304 1
a304 1
                        &clock_freq , sizeof clock_freq ) >= 0)
d335 1
a335 1
		if ((psr & PSR_FREQ_MASK) == PSR_FREQ_HALF)
d337 6
@


1.32
log
@Frequency scaling detection for IBM 970FX.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.31 2005/10/22 09:19:18 kettenis Exp $ */
d138 1
@


1.31
log
@s/970/970FX/g
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.30 2005/10/20 20:33:02 deraadt Exp $ */
d57 13
d103 1
d164 1
a164 1
	unsigned int cpu, pvr, hid0;
d255 1
a255 1
		ppc_curfreq = clock_freq;
d259 14
a316 2


@


1.30
log
@cannot manipulate hid0 register yet in 64 bit mode (because we are running
in 32 bit mode, and ibm moves the bits....) ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.29 2005/10/09 14:17:32 drahn Exp $ */
d123 1
a123 1
	case PPC_CPU_IBM970:
d187 1
a187 1
	case PPC_CPU_IBM970:
d189 1
a189 1
		snprintf(cpu_model, sizeof(cpu_model), "970");
d272 1
a272 1
	case PPC_CPU_IBM970:
@


1.29
log
@Provide a machdep sysctl to determine if altivec is avaliable on macppc
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.28 2005/10/03 19:34:46 drahn Exp $ */
d244 1
d246 2
a247 1
	hid0 = ppc_mfhid0();
d278 2
a279 1
	ppc_mthid0(hid0);
@


1.28
log
@Put the 970 in correct sleep mode, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.27 2005/10/03 04:40:09 deraadt Exp $ */
d90 1
d180 1
d184 1
d188 1
d195 1
d199 1
d206 1
@


1.27
log
@pretty up the instruction whacker code; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2005/10/03 02:54:30 drahn Exp $ */
d262 5
@


1.26
log
@flush correctly
@
text
@d102 1
a102 2
extern u_int32_t *rfi_whack[], *rfi_whackend[];
struct noppatch{
d106 3
a108 4
extern struct noppatch nop32_start;
extern struct noppatch nop32_end;
extern struct noppatch nop64_start;
extern struct noppatch nop64_end;
d116 1
a116 2
	int i;
	struct noppatch *pnop;
d124 4
a127 4
		for (i = 0; &rfi_whack[i] < &rfi_whackend[0]; i++) {
			inst = rfi_whack[i];
			*inst = rfid_inst;
			syncicache(inst, 4);
d129 2
a130 2
		for (pnop = &nop64_start; pnop <  &nop64_end; pnop++) {
			for (inst = pnop->s; inst < pnop->e; inst++) {
d132 1
a132 2
				syncicache(inst, 4);
			}
d138 2
a139 2
		for (pnop = &nop32_start; pnop <  &nop32_end; pnop++) {
			for (inst = pnop->s; inst < pnop->e; inst++) {
d141 1
a141 2
				syncicache(inst, 4);
			}
@


1.25
log
@Add the syncs which were in a 'later' version. pointed out deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.24 2005/10/03 02:16:10 drahn Exp $ */
d133 1
a133 1
			for (inst = pnop->s; inst < pnop->e; inst++)
d136 1
@


1.24
log
@First part of locore G5 support, this is one step of many.
Get this in and tested before the rest hits the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.23 2005/10/01 19:55:25 drahn Exp $ */
d130 1
d135 1
d142 1
a142 1
			for (inst = pnop->s; inst < pnop->e; inst++)
d144 2
@


1.23
log
@Recognize 970 processor and provide a function/variable to determine if
the current processor is 64bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22 2005/09/29 20:40:24 kettenis Exp $ */
d101 11
d117 4
d127 9
d139 4
@


1.22
log
@Improve PowerPC 7447A support.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.21 2005/03/10 19:24:30 otto Exp $ */
d100 17
d155 3
@


1.21
log
@Recognize 7447A processor, as found in the Mac mini; print
rev number in hex explicitly. ok deraadt@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.20 2004/11/18 16:10:10 miod Exp $ */
d202 1
d221 2
a222 1
	    cpu == PPC_CPU_MPC7450 || cpu == PPC_CPU_MPC7455) {
d314 1
a314 1
		} else if (cpu == PPC_CPU_IBM750FX)
@


1.20
log
@Move PowerPC cpu type constants to <machine/cpu.h>

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.19 2004/02/14 15:09:22 grange Exp $ */
d136 3
d160 1
a160 1
	    " (Revision %x)", pvr & 0xffff);
@


1.19
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.18 2003/12/24 05:44:37 drahn Exp $ */
a45 13
#define MPC601          1
#define MPC603          3
#define MPC604          4
#define MPC603e         6
#define MPC603ev        7
#define MPC750          8
#define MPC604ev        9
#define MPC7400         12
#define	IBM750FX	0x7000
#define MPC7410         0x800c
#define MPC7450         0x8000
#define MPC7455         0x8001

d112 1
a112 1
	case MPC601:
d115 1
a115 1
	case MPC603:
d118 1
a118 1
	case MPC604:
d121 1
a121 1
	case MPC603e:
d124 1
a124 1
	case MPC603ev:
d127 1
a127 1
	case MPC750:
d130 1
a130 1
	case MPC604ev:
d133 1
a133 1
	case MPC7400:
d136 1
a136 1
	case IBM750FX:
d139 1
a139 1
	case MPC7410:
d142 1
a142 1
	case MPC7450:
d148 1
a148 1
	case MPC7455:
d189 6
a194 6
	case MPC603:
	case MPC603e:
	case MPC750:
	case MPC7400:
	case IBM750FX:
	case MPC7410:
d199 2
a200 2
	case MPC7450:
	case MPC7455:
d208 1
a208 1
		if (cpu == MPC7450 && (pvr & 0xffff) < 0x0200)
d215 3
a217 2
	if ( (cpu == MPC750) || (cpu == MPC7400) || (cpu == IBM750FX)
	    || (cpu == MPC7410) || (cpu == MPC7450) || (cpu == MPC7455)) {
d300 1
a300 1
		if (cpu == MPC7450 || cpu == MPC7455) {
d309 1
a309 1
		} else if (cpu == IBM750FX)
@


1.18
log
@cpu_cpuspeed has a proper external def, remove this one, suggested by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.17 2003/12/24 00:25:42 drahn Exp $ */
d106 1
a106 1
ppc_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d108 3
a110 1
	return (sysctl_rdint(oldp, oldlenp, newp, ppc_curfreq));
@


1.17
log
@support cpu_cpuspeed on macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.16 2003/10/30 03:17:32 itojun Exp $ */
a101 1
extern int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
@


1.16
log
@simplify cfdriver initialization.  drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 2003/10/16 05:03:22 deraadt Exp $ */
d102 11
d195 2
a196 1

@


1.15
log
@more white
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.14 2003/10/15 17:50:16 drahn Exp $ */
d82 1
a82 1
	NULL, "cpu", DV_DULL, NULL, 0
@


1.14
log
@The ANSI/KNF trail continues. No binary differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.13 2003/07/02 21:30:13 drahn Exp $ */
d6 1
a6 1
 * 
d197 1
a197 1
		hid0 |= HID0_DOZE | HID0_DPM; 
d203 1
a203 1
		hid0 |= HID0_NAP | HID0_DPM; 
d214 1
a214 1
	/* if processor is G3 or G4, configure l2 cache */ 
d291 1
a291 1
				      
d318 1
a318 1
			case L2SIZ_1M:  
d340 1
a340 1
		
d342 1
a342 1
			printf(" with parity");  
a345 1
		
@


1.13
log
@Reduce the amount of asm code in powerpc/macppc by replacing it with
inlined functions, helps improve readability and fix a couple of bugs.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2003/06/23 01:38:05 drahn Exp $ */
d103 1
a103 4
cpuattach(parent, dev, aux)
	struct device *parent;
	struct device *dev;
	void *aux;
d167 1
a167 1
                                  &clock_freq , sizeof clock_freq ) >= 0)
d210 1
@


1.12
log
@Fix NAP/DOZE sleeping on powerpc. also on newer 745x machines use NAP not
DOZE, DOZE is not valid on these processors. Improves battery life on
12" PBG4 from 3 hours to 4 hours. tested by tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.11 2003/02/26 19:12:08 drahn Exp $ */
d113 1
a113 1
	__asm__ ("mfpvr %0" : "=r"(pvr));
d190 1
a190 1
	__asm __volatile ("mfspr %0,1008" : "=r" (hid0));
d214 1
a214 1
	__asm __volatile ("mtspr 1008,%0" :: "r" (hid0));
d226 1
a226 2
#define L2CR 1017

d259 1
a259 1
                                      (read only). */
d266 1
a266 1
#define SPR_L3CR                0x3fa   /* .6. L3 Control Register */
d275 1
a275 1
	__asm __volatile ("mfspr %0, 1017" : "=r"(l2cr));
d282 1
a282 1
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));
d289 1
a289 1
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));
d291 1
a291 1
			asm volatile ("mfspr %0, 1017" : "=r"(x));
d297 1
a297 1
		asm volatile ("mtspr 1017,%0" :: "r"(l2cr));
d306 1
a306 2
			__asm__ volatile("mfspr %0, %1" : "=r"(l3cr) :
			    "n"(SPR_L3CR) );
@


1.11
log
@Volatile to prevent the optimizer from eliminating these, and fix the
argument order for mtspr.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2002/09/15 09:01:58 deraadt Exp $ */
d64 5
a197 2
	case MPC7450:
	case MPC7455:
d201 12
d214 1
a214 1
	__asm __volatile ("mtspr 1008,%0" : "=r" (hid0));
@


1.10
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2002/06/21 06:26:50 itojun Exp $ */
d185 1
a185 1
	asm ("mfspr %0,1008" : "=r" (hid0));
d199 1
a199 1
	asm ("mtspr %0,1008" : "=r" (hid0));
@


1.9
log
@KNF
@
text
@d144 1
a144 1
		else
d162 5
a166 4
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0 &&
		    !strcmp(name, "cpu") &&
		    OF_getprop(qhandle, "clock-frequency", &clock_freq,
		    sizeof clock_freq ) >= 0)
a167 6
		if ((phandle = OF_child(qhandle)))
			continue;
		while (qhandle) {
			if ((phandle = OF_peer(qhandle)))
				break;
			qhandle = OF_parent(qhandle);
d169 7
d197 1
a197 1
		hid0 |= HID0_DOZE | HID0_DPM;
d201 3
a203 3
	/* if processor is G3 or G4, configure l2 cache */
	if ((cpu == MPC750) || (cpu == MPC7400) || (cpu == IBM750FX) ||
	    (cpu == MPC7410) || (cpu == MPC7450) || (cpu == MPC7455)) {
d207 2
d279 1
a279 1

d307 1
a307 1
			case L2SIZ_1M:
d329 1
a329 1

d331 1
a331 1
			printf(" with parity");
d335 1
@


1.8
log
@configure HID0, and show cache status for IBM750FX.  from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.7 2002/06/21 00:00:05 itojun Exp $ */
d144 1
a144 1
		 else
d162 4
a165 5
                if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
                    && !strcmp(name, "cpu")
                    && OF_getprop(qhandle, "clock-frequency",
                                  &clock_freq , sizeof clock_freq ) >= 0)
		{
d167 6
a173 7
                if ((phandle = OF_child(qhandle)))
                        continue;
                while (qhandle) {
                        if ((phandle = OF_peer(qhandle)))
                                break;
                        qhandle = OF_parent(qhandle);
                }
d195 1
a195 1
		hid0 |= HID0_DOZE | HID0_DPM; 
d199 3
a201 3
	/* if processor is G3 or G4, configure l2 cache */ 
	if ( (cpu == MPC750) || (cpu == MPC7400) || (cpu == IBM750FX)
	    || (cpu == MPC7410) || (cpu == MPC7450) || (cpu == MPC7455)) {
a204 2


d275 1
a275 1
				      
d303 1
a303 1
			case L2SIZ_1M:  
d325 1
a325 1
		
d327 1
a327 1
			printf(" with parity");  
a330 1
		
@


1.7
log
@identify 0x7000 (IBM750FX).  snprintf.
do we need "IBM" or "Motorola" in cpu_model?
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 2002/06/09 04:13:13 drahn Exp $ */
d191 1
d202 1
a202 1
	if ( (cpu == MPC750) || (cpu == MPC7400)
d297 3
a299 1
		} else {
@


1.6
log
@knf/cleanup/dead code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5 2002/04/29 00:00:02 drahn Exp $ */
d54 1
d112 1
a112 1
		sprintf(cpu_model, "601");
d115 1
a115 1
		sprintf(cpu_model, "603");
d118 1
a118 1
		sprintf(cpu_model, "604");
d121 1
a121 1
		sprintf(cpu_model, "603e");
d124 1
a124 1
		sprintf(cpu_model, "603ev");
d127 1
a127 1
		sprintf(cpu_model, "750");
d130 1
a130 1
		sprintf(cpu_model, "604ev");
d133 4
a136 1
		sprintf(cpu_model, "7400");
d139 1
a139 1
		sprintf(cpu_model, "7410");
d143 1
a143 1
			sprintf(cpu_model, "7450");
d145 1
a145 1
			sprintf(cpu_model, "7451");
d148 1
a148 1
		sprintf(cpu_model, "7455");
d151 1
a151 1
		sprintf(cpu_model, "Version %x", cpu);
d154 3
a156 1
	sprintf(cpu_model + strlen(cpu_model), " (Revision %x)", pvr & 0xffff);
@


1.5
log
@Print out cache sizes on newer G4 processors. Partially from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 2002/03/21 17:37:57 drahn Exp $ */
d138 1
a138 1
		if ((pvr & 0xf) < 3) {
d140 1
a140 1
		} else {
a141 1
		}
@


1.4
log
@dont forget the break.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 2002/03/21 17:37:11 drahn Exp $ */
d79 1
a79 1
void config_l2cr(void);
d196 3
a198 4
	if  ( (cpu == MPC750) || (cpu == MPC7400) 
		|| (cpu == MPC7410))
	{
		config_l2cr();
d246 4
d251 1
a251 1
config_l2cr()
d281 25
a305 12
		switch (l2cr & L2CR_L2SIZ) {
		case L2SIZ_256K:
			printf(": 256KB");
			break;
		case L2SIZ_512K:
			printf(": 512KB");
			break;
		case L2SIZ_1M:  
			printf(": 1MB");
			break;
		default:
			printf(": unknown size");
a324 1
		printf(" backside cache");
@


1.3
log
@Recognize 7455 processor, distinguish between 7450/7451.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2 2002/03/14 01:26:36 millert Exp $ */
d143 1
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1 2001/09/01 15:44:20 drahn Exp $ */
d56 1
d138 7
a144 1
		sprintf(cpu_model, "7450");
d187 1
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2001/07/09 04:41:28 mickey Exp $ */
d78 1
a78 1
void config_l2cr __P((void));
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1 2001/09/01 15:44:20 drahn Exp $ */
a55 1
#define MPC7455         0x8001
d78 1
a78 1
void config_l2cr(int cpu);
d137 1
a137 7
		if ((pvr & 0xf) < 3)
			sprintf(cpu_model, "7450");
		 else
			sprintf(cpu_model, "7451");
		break;
	case MPC7455:
		sprintf(cpu_model, "7455");
a179 1
	case MPC7455:
d187 4
a190 3
	if ( (cpu == MPC750) || (cpu == MPC7400)
	    || (cpu == MPC7410) || (cpu == MPC7450) || (cpu == MPC7455)) {
		config_l2cr(cpu);
a237 4
#define SPR_L3CR                0x3fa   /* .6. L3 Control Register */
#define   L3CR_L3E                0x80000000 /*  0: L3 enable */
#define   L3CR_L3SIZ              0x10000000 /*  3: L3 size (0=1MB, 1=2MB) */

d239 1
a239 1
config_l2cr(int cpu)
d269 12
a280 25
		if (cpu == MPC7450 || cpu == MPC7455) {
			u_int l3cr;

			printf(": 256KB L2 cache");

			__asm__ volatile("mfspr %0, %1" : "=r"(l3cr) :
			    "n"(SPR_L3CR) );
			if (l3cr & L3CR_L3E)
				printf(", %cMB L3 cache",
				    l3cr & L3CR_L3SIZ ? '2' : '1');
		} else {
			switch (l2cr & L2CR_L2SIZ) {
			case L2SIZ_256K:
				printf(": 256KB");
				break;
			case L2SIZ_512K:
				printf(": 512KB");
				break;
			case L2SIZ_1M:  
				printf(": 1MB");
				break;
			default:
				printf(": unknown size");
			}
			printf(" backside cache");
d300 1
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.6.1 2002/06/11 03:36:34 art Exp $ */
a53 1
#define	IBM750FX	0x7000
d111 1
a111 1
		snprintf(cpu_model, sizeof(cpu_model), "601");
d114 1
a114 1
		snprintf(cpu_model, sizeof(cpu_model), "603");
d117 1
a117 1
		snprintf(cpu_model, sizeof(cpu_model), "604");
d120 1
a120 1
		snprintf(cpu_model, sizeof(cpu_model), "603e");
d123 1
a123 1
		snprintf(cpu_model, sizeof(cpu_model), "603ev");
d126 1
a126 1
		snprintf(cpu_model, sizeof(cpu_model), "750");
d129 1
a129 1
		snprintf(cpu_model, sizeof(cpu_model), "604ev");
d132 1
a132 4
		snprintf(cpu_model, sizeof(cpu_model), "7400");
		break;
	case IBM750FX:
		snprintf(cpu_model, sizeof(cpu_model), "750FX");
d135 1
a135 1
		snprintf(cpu_model, sizeof(cpu_model), "7410");
d139 1
a139 1
			snprintf(cpu_model, sizeof(cpu_model), "7450");
d141 1
a141 1
			snprintf(cpu_model, sizeof(cpu_model), "7451");
d144 1
a144 1
		snprintf(cpu_model, sizeof(cpu_model), "7455");
d147 1
a147 1
		snprintf(cpu_model, sizeof(cpu_model), "Version %x", cpu);
d150 1
a150 3
	snprintf(cpu_model + strlen(cpu_model),
	    sizeof(cpu_model) - strlen(cpu_model),
	    " (Revision %x)", pvr & 0xffff);
a184 1
	case IBM750FX:
d195 1
a195 1
	if ( (cpu == MPC750) || (cpu == MPC7400) || (cpu == IBM750FX)
d290 1
a290 3
		} else if (cpu == IBM750FX)
			printf(": 512KB L2 cache");
		else {
@


1.1.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d185 1
a185 1
	__asm __volatile ("mfspr %0,1008" : "=r" (hid0));
d199 1
a199 1
	__asm __volatile ("mtspr 1008,%0" : "=r" (hid0));
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.1.4.2
log
@Merge in -current from about a week ago
@
text
@a55 1
#define MPC7455         0x8001
d78 1
a78 1
void config_l2cr(void);
d137 1
a137 8
		if ((pvr & 0xf) < 3) {
			sprintf(cpu_model, "7450");
		} else {
			sprintf(cpu_model, "7451");
		}
		break;
	case MPC7455:
		sprintf(cpu_model, "7455");
a179 1
	case MPC7455:
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@a53 1
#define	IBM750FX	0x7000
d79 1
a79 1
void config_l2cr(int cpu);
d111 1
a111 1
		snprintf(cpu_model, sizeof(cpu_model), "601");
d114 1
a114 1
		snprintf(cpu_model, sizeof(cpu_model), "603");
d117 1
a117 1
		snprintf(cpu_model, sizeof(cpu_model), "604");
d120 1
a120 1
		snprintf(cpu_model, sizeof(cpu_model), "603e");
d123 1
a123 1
		snprintf(cpu_model, sizeof(cpu_model), "603ev");
d126 1
a126 1
		snprintf(cpu_model, sizeof(cpu_model), "750");
d129 1
a129 1
		snprintf(cpu_model, sizeof(cpu_model), "604ev");
d132 1
a132 4
		snprintf(cpu_model, sizeof(cpu_model), "7400");
		break;
	case IBM750FX:
		snprintf(cpu_model, sizeof(cpu_model), "750FX");
d135 1
a135 1
		snprintf(cpu_model, sizeof(cpu_model), "7410");
d138 5
a142 4
		if ((pvr & 0xf) < 3)
			snprintf(cpu_model, sizeof(cpu_model), "7450");
		 else
			snprintf(cpu_model, sizeof(cpu_model), "7451");
d145 1
a145 1
		snprintf(cpu_model, sizeof(cpu_model), "7455");
d148 1
a148 1
		snprintf(cpu_model, sizeof(cpu_model), "Version %x", cpu);
d151 1
a151 3
	snprintf(cpu_model + strlen(cpu_model),
	    sizeof(cpu_model) - strlen(cpu_model),
	    " (Revision %x)", pvr & 0xffff);
d180 1
a180 1
	__asm __volatile ("mfspr %0,1008" : "=r" (hid0));
a185 1
	case IBM750FX:
d193 1
a193 1
	__asm __volatile ("mtspr 1008,%0" : "=r" (hid0));
d196 4
a199 3
	if ( (cpu == MPC750) || (cpu == MPC7400) || (cpu == IBM750FX)
	    || (cpu == MPC7410) || (cpu == MPC7450) || (cpu == MPC7455)) {
		config_l2cr(cpu);
a246 4
#define SPR_L3CR                0x3fa   /* .6. L3 Control Register */
#define   L3CR_L3E                0x80000000 /*  0: L3 enable */
#define   L3CR_L3SIZ              0x10000000 /*  3: L3 size (0=1MB, 1=2MB) */

d248 1
a248 1
config_l2cr(int cpu)
d278 12
a289 27
		if (cpu == MPC7450 || cpu == MPC7455) {
			u_int l3cr;

			printf(": 256KB L2 cache");

			__asm__ volatile("mfspr %0, %1" : "=r"(l3cr) :
			    "n"(SPR_L3CR) );
			if (l3cr & L3CR_L3E)
				printf(", %cMB L3 cache",
				    l3cr & L3CR_L3SIZ ? '2' : '1');
		} else if (cpu == IBM750FX)
			printf(": 512KB L2 cache");
		else {
			switch (l2cr & L2CR_L2SIZ) {
			case L2SIZ_256K:
				printf(": 256KB");
				break;
			case L2SIZ_512K:
				printf(": 512KB");
				break;
			case L2SIZ_1M:  
				printf(": 1MB");
				break;
			default:
				printf(": unknown size");
			}
			printf(" backside cache");
d309 1
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d6 1
a6 1
 *
a63 5
#define HID0_SGE	(1 << (31-24))
#define HID0_BTIC	(1 << (31-26))
#define HID0_LRSTK	(1 << (31-27))
#define HID0_FOLD	(1 << (31-28))
#define HID0_BHT	(1 << (31-29))
d77 1
a77 1
	NULL, "cpu", DV_DULL
a96 10
static u_int32_t ppc_curfreq;


int
ppc_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	return (sysctl_rdint(oldp, oldlenp, newp, ppc_curfreq));
}


d98 4
a101 1
cpuattach(struct device *parent, struct device *dev, void *aux)
d108 1
a108 1
	pvr = ppc_mfpvr();
d165 1
a165 1
                        &clock_freq , sizeof clock_freq ) >= 0)
d182 1
a182 2
		ppc_curfreq = clock_freq;
		cpu_cpuspeed = ppc_cpuspeed;
d185 1
a185 1
	hid0 = ppc_mfhid0();
d193 2
d197 1
a197 14
		hid0 |= HID0_DOZE | HID0_DPM;
		break;
	case MPC7450:
	case MPC7455:
		/* select NAP mode */
		hid0 &= ~(HID0_DOZE | HID0_SLEEP);
		hid0 |= HID0_NAP | HID0_DPM;
		/* try some other flags */
		hid0 |= HID0_SGE | HID0_BTIC;
		hid0 |= HID0_LRSTK | HID0_FOLD | HID0_BHT;
		/* Disable BTIC on 7450 Rev 2.0 or earlier */
		if (cpu == MPC7450 && (pvr & 0xffff) < 0x0200)
			hid0 &= ~HID0_BTIC;
		break;
d199 1
a199 1
	ppc_mthid0(hid0);
d201 1
a201 1
	/* if processor is G3 or G4, configure l2 cache */
d211 2
a212 1
/* L2CR bit definitions */
d245 1
a245 1
				       (read only). */
d252 1
a252 1
/* L3CR bit definitions */
d261 1
a261 1
	l2cr = ppc_mfl2cr();
d268 1
a268 1
		ppc_mtl2cr(l2cr);
d275 1
a275 1
		ppc_mtl2cr(l2cr);
d277 1
a277 1
			x = ppc_mfl2cr();
d279 1
a279 1

d283 1
a283 1
		ppc_mtl2cr(l2cr);
d292 2
a293 1
			l3cr = ppc_mfl3cr();
d307 1
a307 1
			case L2SIZ_1M:
d329 1
a329 1

d331 1
a331 1
			printf(" with parity");
d335 1
@


1.1.4.5
log
@Merge with the trunk
@
text
@d106 1
a106 1
ppc_cpuspeed(int *freq)
d108 1
a108 3
	*freq = ppc_curfreq;

	return (0);
@


