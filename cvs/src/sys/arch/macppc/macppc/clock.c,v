head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.12
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.10
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.6
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.6
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.4
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.2
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.5
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.40
date	2015.06.13.07.16.36;	author jsg;	state Exp;
branches;
next	1.39;
commitid	h4MBZBV4zyNpGQH3;

1.39
date	2014.11.11.21.02.06;	author mpi;	state Exp;
branches;
next	1.38;
commitid	NjORiW9XLjhMI3Xj;

1.38
date	2014.10.08.10.12.41;	author mpi;	state Exp;
branches;
next	1.37;
commitid	744ecbjJTf8RMATb;

1.37
date	2014.05.09.18.16.15;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.01.20.27.14;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2013.10.09.17.43.50;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2013.09.13.07.29.01;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.23.07.38.05;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2011.08.29.20.21.44;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.01.20.19.18;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.09.01.12.38;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.02.21.38.09;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.02.21.23.55;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.01.22.28.30;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.21.17.35.52;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.09.23.20.45.26;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.18.03.56.25;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.30.17.59.33;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.26.22.37.41;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.24.15.24.54;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.13.18.48.38;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.20.20.59.54;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.19.15.13.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.21.22.07.45;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.09.14.01.11;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.28.02.49.10;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.04.21.07.43;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.18.20.06.15;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.16.05.03.22;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.29.12.13.32;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.14.18.56.12;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.08.23.05.20;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.08.21.46.19;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.02.21.30.13;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.09.04.13.13;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.11.15.30.33;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.44.20;	author drahn;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.40
log
@When investigating an uninitialised variable in the armv7 resettodr()
miod pointed out that time_second should be compared to 1 not 0 in the
md resettodr() functions as it is initialised to 1.

ok miod@@ deraadt@@
@
text
@/*	$OpenBSD: clock.c,v 1.39 2014/11/11 21:02:06 mpi Exp $	*/
/*	$NetBSD: clock.c,v 1.1 1996/09/30 16:34:40 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/evcount.h>
#include <sys/timetc.h>

#include <machine/autoconf.h>
#include <machine/pio.h>
#include <machine/intr.h>
#include <machine/vmparam.h>
#include <dev/ofw/openfirm.h>

void decr_intr(struct clockframe *frame);
u_int tb_get_timecount(struct timecounter *);

/*
 * Initially we assume a processor with a bus frequency of 12.5 MHz.
 */
u_int32_t ticks_per_sec = 3125000;
u_int32_t ns_per_tick = 320;
static int32_t ticks_per_intr;

static struct timecounter tb_timecounter = {
	tb_get_timecount, NULL, 0x7fffffff, 0, "tb", 0, NULL
};

/* calibrate the timecounter frequency for the listed models */
static const char *calibrate_tc_models[] = {
	"PowerMac10,1"
};
extern char *hw_prod;

time_read_t  *time_read;
time_write_t *time_write;

/* vars for stats */
int statint;
u_int32_t statvar;
u_int32_t statmin;

static struct evcount clk_count;
static struct evcount stat_count;
static int clk_irq = PPC_CLK_IRQ;
static int stat_irq = PPC_STAT_IRQ;


/*
 * Set up the system's time, given a `reasonable' time value.
 */
void
inittodr(time_t base)
{
	int badbase = 0, waszero = base == 0;
	char *bad = NULL;
	struct timeval tv;
	struct timespec ts;

        if (base < 5 * SECYR) {
                /*
                 * If base is 0, assume filesystem time is just unknown
                 * instead of preposterous. Don't bark.
                 */
                if (base != 0)
                        printf("WARNING: preposterous time in file system\n");
                /* not going to use it anyway, if the chip is readable */
                base = 21*SECYR + 186*SECDAY + SECDAY/2;
                badbase = 1;
        }

	if (time_read != NULL) {
		time_t cursec;
		(*time_read)(&cursec);
		tv.tv_sec = cursec;
		tv.tv_usec = 0;
	} else {
		/* force failure */
		tv.tv_sec = tv.tv_usec = 0;
	}

	if (tv.tv_sec == 0) {
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the clock.
		 */
		bad = "WARNING: unable to get date/time";
		tv.tv_sec = base;
		tv.tv_usec = 0;
		if (!badbase)
			resettodr();
	} else {
		int deltat;

		tv.tv_sec += tz.tz_minuteswest * 60;
		if (tz.tz_dsttime)
			tv.tv_sec -= 3600;

		deltat = tv.tv_sec - base;

		if (deltat < 0)
			deltat = -deltat;
		if (!(waszero || deltat < 2 * SECDAY)) {
			printf("WARNING: clock %s %ld days",
			    tv.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
			bad = "";

			if (tv.tv_sec < base && deltat > 1000 * SECDAY) {
				printf(", using FS time");
				tv.tv_sec = base;
			}
		}
	}

	ts.tv_sec = tv.tv_sec;
	ts.tv_nsec = tv.tv_usec * 1000;
	tc_setclock(&ts);

	if (bad) {
		printf("%s", bad);
		printf(" -- CHECK AND RESET THE DATE!\n");
	}
}

/*
 * Similar to the above
 */
void
resettodr(void)
{
	struct timeval tv;

	if (time_second == 1)
		return;

	microtime(&tv);

	if (time_write != NULL) {
		tv.tv_sec -= tz.tz_minuteswest * 60;
		if (tz.tz_dsttime) {
			tv.tv_sec += 3600;
		}
		(*time_write)(tv.tv_sec);
	}
}

void
decr_intr(struct clockframe *frame)
{
	u_int64_t tb;
	u_int64_t nextevent;
	struct cpu_info *ci = curcpu();
	int nstats;
	int s;

	/*
	 * Check whether we are initialized.
	 */
	if (!ticks_per_intr)
		return;

	/*
	 * Based on the actual time delay since the last decrementer reload,
	 * we arrange for earlier interrupt next time.
	 */

	tb = ppc_mftb();
	while (ci->ci_nexttimerevent <= tb)
		ci->ci_nexttimerevent += ticks_per_intr;

	ci->ci_prevtb = ci->ci_nexttimerevent - ticks_per_intr;

	for (nstats = 0; ci->ci_nextstatevent <= tb; nstats++) {
		int r;
		do {
			r = random() & (statvar -1);
		} while (r == 0); /* random == 0 not allowed */
		ci->ci_nextstatevent += statmin + r;
	}

	/* only count timer ticks for CLK_IRQ */
	stat_count.ec_count += nstats;

	if (ci->ci_nexttimerevent < ci->ci_nextstatevent)
		nextevent = ci->ci_nexttimerevent;
	else
		nextevent = ci->ci_nextstatevent;

	/*
	 * Need to work about the near constant skew this introduces???
	 * reloading tb here could cause a missed tick.
	 */
	ppc_mtdec(nextevent - tb);

	if (ci->ci_cpl >= IPL_CLOCK) {
		ci->ci_statspending += nstats;
	} else {
		nstats += ci->ci_statspending;
		ci->ci_statspending = 0;

		s = splclock();

		/*
		 * Reenable interrupts
		 */
		ppc_intr_enable(1);

		/*
		 * Do standard timer interrupt stuff.
		 */
		while (ci->ci_lasttb < ci->ci_prevtb) {
			/* sync lasttb with hardclock */
			ci->ci_lasttb += ticks_per_intr;
			clk_count.ec_count++;
			hardclock(frame);
		}

		while (nstats-- > 0)
			statclock(frame);

		splx(s);
		(void) ppc_intr_disable();

		/* if a tick has occurred while dealing with these,
		 * dont service it now, delay until the next tick.
		 */
	}
}

void cpu_startclock(void);

void
cpu_initclocks()
{
	int intrstate;
	int minint;
	u_int32_t first_tb, second_tb;
	time_t first_sec, sec;
	int calibrate = 0, n;

	/* check if we should calibrate the timecounter frequency */
	for (n = 0; n < sizeof(calibrate_tc_models) /
	    sizeof(calibrate_tc_models[0]); n++) {
		if (!strcmp(calibrate_tc_models[n], hw_prod)) {
			calibrate = 1;
			break;
		}
	}

	/* if a RTC is available, calibrate the timecounter frequency */
	if (calibrate && time_read != NULL) {
		time_read(&first_sec);
		do {
			first_tb = ppc_mftbl();
			time_read(&sec);
		} while (sec == first_sec);
		first_sec = sec;
		do {
			second_tb = ppc_mftbl();
			time_read(&sec);
		} while (sec == first_sec);
		ticks_per_sec = second_tb - first_tb;
#ifdef DEBUG
		printf("tb: using measured timecounter frequency of %ld Hz\n",
		    ticks_per_sec);
#endif
	}

	intrstate = ppc_intr_disable();

	ticks_per_intr = ticks_per_sec / hz;

	stathz = 100;
	profhz = 1000; /* must be a multiple of stathz */

	/* init secondary clock to stathz */
	statint = ticks_per_sec / stathz;
	statvar = 0x40000000; /* really big power of two */
	/* find largest 2^n which is nearly smaller than statint/2  */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
	statmin = statint - (statvar >> 1);

	evcount_attach(&clk_count, "clock", &clk_irq);
	evcount_attach(&stat_count, "stat", &stat_irq);

	cpu_startclock();

	tb_timecounter.tc_frequency = ticks_per_sec;
	tc_init(&tb_timecounter);
	ppc_intr_enable(intrstate);
}

void
cpu_startclock()
{
	struct cpu_info *ci = curcpu();
	u_int64_t nextevent;

	ci->ci_lasttb = ppc_mftb();

	/*
	 * no point in having random on the first tick, 
	 * it just complicates the code.
	 */
	ci->ci_nexttimerevent = ci->ci_lasttb + ticks_per_intr;
	nextevent = ci->ci_nextstatevent = ci->ci_nexttimerevent;

	ci->ci_statspending = 0;

	ppc_mtdec(nextevent - ci->ci_lasttb);
}

/*
 * Wait for about n microseconds (us) (at least!).
 */
void
delay(unsigned n)
{
	u_int64_t tb;

	tb = ppc_mftb();
	tb += (n * 1000 + ns_per_tick - 1) / ns_per_tick;
	while (tb > ppc_mftb())
		;
}

/*
 * Nothing to do.
 */
void
setstatclockrate(int newhz)
{
	int minint;
	int intrstate;

	intrstate = ppc_intr_disable();

	statint = ticks_per_sec / newhz;
	statvar = 0x40000000; /* really big power of two */
	/* find largest 2^n which is nearly smaller than statint/2 */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	statmin = statint - (statvar >> 1);
	ppc_intr_enable(intrstate);

	/*
	 * XXX this allows the next stat timer to occur then it switches
	 * to the new frequency. Rather than switching instantly.
	 */
}

u_int
tb_get_timecount(struct timecounter *tc)
{
	return ppc_mftbl();
}
@


1.39
log
@Do not held the kernel lock when calling hardclock() and statclock().
This is not necessary, as confirmed by tedu@@ and kettenis@@.

Solve the major contention problem seen on my Dual G5.  Reduce the
build time of a kernel with two jobs from 5h+ to 18min and expose more
easily pmap/memroy corruptions 8)

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.38 2014/10/08 10:12:41 mpi Exp $	*/
d165 1
a165 1
	if (time_second == 0)
@


1.38
log
@Introduce ppc_mttb() and use it instead of rerolling the move to time
base dance in inline assembly in various places.

tweak and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.37 2014/05/09 18:16:15 miod Exp $	*/
a229 2
		KERNEL_LOCK();

a258 1
		KERNEL_UNLOCK();
@


1.37
log
@Format string fixes and removal of -Wno-format for *ppc kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.36 2014/04/01 20:27:14 mpi Exp $	*/
a356 1
	u_int32_t tbh, tbl, scratch;
d360 2
a361 5
	tbh = tb >> 32;
	tbl = (u_int32_t)tb;
	asm ("1: mftbu %0; cmplw %0,%1; blt 1b; bgt 2f;"
	     " mftb %0; cmplw %0,%2; blt 1b; 2:"
	     :: "r"(scratch), "r"(tbh), "r"(tbl));
@


1.36
log
@Remove the almost unused abstraction around "struct firmware" and use
instead a single function ppc_mem_regions() required by the ppc pmap.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.35 2013/10/09 17:43:50 mpi Exp $	*/
d136 1
a136 1
			printf("WARNING: clock %s %d days",
@


1.35
log
@Initialize ns_per_tick as soon as we have read the timebase from the
device-tree to restore the behaviour present before my last change.

This fixes a regression seen on some Powerbooks where one of the two
kiic(4) would always timeout when trying to configure the audio chip.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.34 2013/09/13 07:29:01 mpi Exp $	*/
a44 1
#include <machine/powerpc.h>
@


1.34
log
@Initialize the variable guarding the clock interrupt routine after
calling initclocks().  This prevents hardclock() from trying to
schedule a softclock interrupt before its cookie has been allocated,
leading to a panic.

While here grab the ticks/second value from the OpenFirmware at the
same time we read the clock frequency, no need to look twice for the
same node.

Looks ok to kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.33 2013/04/23 07:38:05 mpi Exp $	*/
d55 1
a55 1
static u_int32_t ns_per_tick = 320;
a306 1
	ns_per_tick = 1000000000 / ticks_per_sec;
@


1.33
log
@Don't assume time_t is an uint32_t.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.32 2011/08/29 20:21:44 drahn Exp $	*/
d54 1
a54 1
static u_int32_t ticks_per_sec = 3125000;
d307 3
a349 37
}

void
calc_delayconst(void)
{
	int qhandle, phandle = 0;
	char name[32];
	int s;

	/*
	 * Get this info during autoconf?				XXX
	 */
	for (qhandle = OF_peer(0); qhandle; qhandle = phandle) {
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
		    && !strcmp(name, "cpu")
		    && OF_getprop(qhandle, "timebase-frequency",
		    &ticks_per_sec, sizeof ticks_per_sec) >= 0) {
			/*
			 * Should check for correct CPU here?		XXX
			 */
			s = ppc_intr_disable();
			ns_per_tick = 1000000000 / ticks_per_sec;
			ticks_per_intr = ticks_per_sec / hz;
			ppc_intr_enable(s);
			break;
		}
		if ((phandle = OF_child(qhandle)))
			continue;
		while (qhandle) {
			if ((phandle = OF_peer(qhandle)))
				break;
			qhandle = OF_parent(qhandle);
		}
	}

	if (!phandle)
		panic("no cpu node");
@


1.32
log
@Return of the long missing powerpc interrupt rewrite.  Was working for
several weeks before release on macppc, socppc bugs just fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.31 2010/09/20 06:33:47 matthew Exp $	*/
d106 1
a106 1
		u_int32_t cursec;
@


1.31
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.30 2009/10/01 20:19:18 kettenis Exp $	*/
d228 1
a228 1
	if (ci->ci_cpl & SPL_CLOCKMASK) {
@


1.30
log
@Generic soft interrupts for macppc.  Tested by mk@@, deraadt@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.29 2009/06/09 01:12:38 deraadt Exp $	*/
d319 2
a320 2
	evcount_attach(&clk_count, "clock", (void *)&clk_irq, &evcount_intr);
	evcount_attach(&stat_count, "stat", (void *)&stat_irq, &evcount_intr);
@


1.29
log
@backout interrupt diff until it the next round of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.27 2009/06/02 21:23:55 drahn Exp $	*/
d228 1
a228 1
	if (ci->ci_cpl & SPL_CLOCK) {
@


1.28
log
@Reintroduce the macppc interrupt subsystem rewrite. Several bugs have
been found and corrected.
@
text
@d228 1
a228 1
	if (ci->ci_cpl >= IPL_CLOCK) {
@


1.27
log
@A piece of an upcoming diff was on the same line, revert that portion
of the previous diff so macppc is stable again. found/ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.26 2009/06/01 22:28:30 drahn Exp $	*/
d228 1
a228 1
	if (ci->ci_cpl & SPL_CLOCK) {
@


1.26
log
@no point in calling curcpu() when ci is already set. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.25 2008/11/21 17:35:52 deraadt Exp $	*/
d228 1
a228 1
	if (ci->ci_cpl >= IPL_CLOCK) {
@


1.25
log
@back out the new interrupt subsystem because some little bug still lurks in there
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2008/04/30 17:59:33 kettenis Exp $	*/
d228 1
a228 1
	if (curcpu()->ci_cpl & SPL_CLOCK) {
@


1.24
log
@Plug more uninitialized variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.23 2008/09/18 03:56:25 drahn Exp $	*/
d228 1
a228 1
	if (ci->ci_cpl >= IPL_CLOCK) {
@


1.23
log
@Redesign of the powerpc interrupt architecture, use true levels intead of
blocking specific interrupts. Needs signficant testing to prove that
one remaining elusive bug has been squashed.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2008/04/30 17:59:33 kettenis Exp $	*/
d352 1
a352 1
	int qhandle, phandle;
@


1.22
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.21 2008/04/26 22:37:41 drahn Exp $	*/
d228 1
a228 1
	if (curcpu()->ci_cpl & SPL_CLOCK) {
@


1.21
log
@Changes to get closer to SMP.
add biglock before interrupt calls into the kernel.
switch the clock to using cpuinfo variables instead of globals
move cpu_switchto into C code so that on multiprocessor the FPU
and Altivec can be saved before switching CPUs.
add a lock into pmap when modifying the hash table.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2007/11/24 15:24:54 mbalmer Exp $	*/
a179 1

d328 1
@


1.20
log
@Some macppc models (e.g. the 1.5 GHz G4 MacMini) have a large clock drift
which is due to the timecounter running at a different frequency than what
OpenFirmware tells us.  On such machines, measure the actual timecounter
frequency (triggered by a table of affected models) and use this measured
value instead.  This brings down the drift to values where adjtime()/adjfreq()
triggered by ntpd(8) can tame the clock.

feedback many, ok miod, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2007/04/13 18:48:38 kettenis Exp $	*/
a56 1
static volatile u_int64_t lasttb;
a70 3
/* event tracking variables, when the next events of each time should occur */
u_int64_t nexttimerevent, prevtb, nextstatevent;

d81 1
a179 1
volatile int statspending;
d186 1
a195 1

d202 2
a203 2
	while (nexttimerevent <= tb)
		nexttimerevent += ticks_per_intr;
d205 1
a205 1
	prevtb = nexttimerevent - ticks_per_intr;
d207 1
a207 1
	for (nstats = 0; nextstatevent <= tb; nstats++) {
d212 1
a212 1
		nextstatevent += statmin + r;
d218 2
a219 2
	if (nexttimerevent < nextstatevent)
		nextevent = nexttimerevent;
d221 1
a221 1
		nextevent = nextstatevent;
d230 1
a230 1
		statspending += nstats;
d232 4
a235 2
		nstats += statspending;
		statspending = 0;
a245 1
		 * Do softclock stuff only on the last iteration.
d247 1
a247 10
		frame->pri = s | SINT_CLOCK;
		while (lasttb < prevtb - ticks_per_intr) {
			/* sync lasttb with hardclock */
			lasttb += ticks_per_intr;
			clk_count.ec_count++;
			hardclock(frame);
		}

		frame->pri = s;
		while (lasttb < prevtb) {
d249 1
a249 1
			lasttb += ticks_per_intr;
d263 1
d267 2
a272 1
	int r;
a273 1
	u_int64_t nextevent;
a317 1

a319 12
	lasttb = ppc_mftb();
	nexttimerevent = lasttb + ticks_per_intr;
	do {
		r = random() & (statvar -1);
	} while (r == 0); /* random == 0 not allowed */
	nextstatevent = lasttb + statmin + r;

	if (nexttimerevent < nextstatevent)
		nextevent = nexttimerevent;
	else
		nextevent = nextstatevent;

d323 2
d327 7
d335 12
a346 2
	ppc_mtdec(nextevent-lasttb);
	ppc_intr_enable(intrstate);
@


1.19
log
@Timecounters for macppc.  As clean and simple as sparc64.  Uses the %tb
special register.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2007/03/20 20:59:54 kettenis Exp $	*/
d63 6
d285 31
a330 1

@


1.18
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2006/06/19 15:13:35 deraadt Exp $	*/
d39 1
a47 3
void resettodr(void);

/* XXX, called from asm code */
d49 1
d59 3
a61 1
#define SECYR           (SECDAY * 365)
d80 1
a80 5
 * For now we let the machine run with boot time, not changing the clock
 * at inittodr at all.
 *
 * We might continue to do this due to setting up the real wall clock with
 * a user level utility in the future.
a81 2

/* ARGSUSED */
d86 3
d105 2
a106 1
		time.tv_sec = cursec;
d109 1
a109 1
		time.tv_sec = 0;
d112 1
a112 2
	if (time.tv_sec == 0) {
		printf("WARNING: unable to get date/time");
d117 3
a119 1
		time.tv_sec = base;
d125 1
a125 1
		time.tv_sec += tz.tz_minuteswest * 60;
d127 1
a127 1
			time.tv_sec -= 3600;
d129 1
a129 1
		deltat = time.tv_sec - base;
d133 9
a141 8
		if (waszero || deltat < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %d days",
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);

		if (time.tv_sec < base && deltat > 1000 * SECDAY) {
			printf(", using FS time");
			time.tv_sec = base;
d144 9
a152 1
	printf(" -- CHECK AND RESET THE DATE!\n");
d161 7
a167 1
	struct timeval curtime = time;
d169 1
a169 1
		curtime.tv_sec -= tz.tz_minuteswest * 60;
d171 1
a171 1
			curtime.tv_sec += 3600;
d173 1
a173 1
		(*time_write)(curtime.tv_sec);
d311 3
a355 22
 * Fill in *tvp with current time with microsecond resolution.
 */
void
microtime(struct timeval *tvp)
{
	u_int64_t tb;
	u_int32_t ticks;
	int s;

	s = ppc_intr_disable();
	tb = ppc_mftb();
	ticks = ((tb - lasttb) * ns_per_tick) / 1000;
	*tvp = time;
	ppc_intr_enable(s);
	tvp->tv_usec += ticks;
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_usec -= 1000000;
		tvp->tv_sec++;
	}
}

/*
d398 6
@


1.17
log
@move clock_subr.c to a better place, and now it is always in the kernel
so that things can use it; tested on all architectures; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2005/10/21 22:07:45 kettenis Exp $	*/
d212 1
a212 1
	if (cpl & SPL_CLOCK) {
@


1.16
log
@Clean up RTC code.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2005/10/09 14:01:11 drahn Exp $	*/
a59 1
#define SECDAY          (24 * 60 * 60)
@


1.15
log
@Nearly functional crashdump support for macppc. Because savecore
does not recognize the resulting crashdumps, the writing has been disabled.
Better here than in my forest of trees.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2004/06/28 02:49:10 aaron Exp $	*/
a59 6
/*
 * BCD to decimal and decimal to BCD.
 */
#define FROMBCD(x)      (((x) >> 4) * 10 + ((x) & 0xf))
#define TOBCD(x)        (((x) / 10 * 16) + ((x) % 10))

a61 11
#define LEAPYEAR(y)     (((y) & 3) == 0)
#define YEAR0		1900

typedef int (clock_read_t)(int *sec, int *min, int *hour, int *day,
    int *mon, int *yr);
typedef int (time_read_t)(u_int32_t *sec);
typedef int (time_write_t)(u_int32_t sec);

clock_read_t *clock_read = NULL;
time_read_t  *time_read  = NULL;
time_write_t *time_write  = NULL;
d63 2
a64 2
static u_int32_t chiptotime(int sec, int min, int hour, int day, int mon,
    int year);
a90 2
	int sec, min, hour, day, mon, year;

d105 1
a105 4
	if (clock_read != NULL ) {
		(*clock_read)( &sec, &min, &hour, &day, &mon, &year);
		time.tv_sec = chiptotime(sec, min, hour, day, mon, year);
	} else if (time_read != NULL) {
a145 33

/*
 * This code is defunct after 2068.
 * Will Unix still be here then??
 */
const short dayyr[12] =
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };

static u_int32_t
chiptotime(int sec, int min, int hour, int day, int mon, int year)
{
	int days, yr;

	sec = FROMBCD(sec);
	min = FROMBCD(min);
	hour = FROMBCD(hour);
	day = FROMBCD(day);
	mon = FROMBCD(mon);
	year = FROMBCD(year) + YEAR0;

	/* simple sanity checks */
	if (year < 1970 || mon < 1 || mon > 12 || day < 1 || day > 31)
		return (0);
	days = 0;
	for (yr = 1970; yr < year; yr++)
		days += LEAPYEAR(yr) ? 366 : 365;
	days += dayyr[mon - 1] + day - 1;
	if (LEAPYEAR(yr) && mon > 2)
		days++;
	/* now have days since Jan 1, 1970; the rest is easy... */
	return (days * SECDAY + hour * 3600 + min * 60 + sec);
}

@


1.14
log
@Use new event counter API for interrupt counting on macppc.  drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2004/01/04 21:07:43 drahn Exp $	*/
d43 1
@


1.13
log
@Previous monotomic clock fix had major issues, this improves the matter.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2003/12/18 20:06:15 drahn Exp $	*/
d38 1
d90 5
d254 1
a254 1
	intrcnt[PPC_STAT_IRQ] += nstats;
d288 1
a288 1
			intrcnt[PPC_CLK_IRQ] ++;
d296 1
a296 1
			intrcnt[PPC_CLK_IRQ] ++;
d347 3
@


1.12
log
@Fix for monotomic time, lasttb is now in sync with 'time'. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2003/10/16 05:03:22 deraadt Exp $	*/
d82 1
a82 1
u_int64_t nexttimerevent, nextstatevent;
d211 1
a211 1
volatile int tickspending, statspending;
a217 1
	int nticks;
d234 1
a234 1
	for (nticks = 0; nexttimerevent <= tb; nticks++)
d237 2
a247 1
	intrcnt[PPC_CLK_IRQ] += nticks;
a261 1
		tickspending += nticks;
d264 39
a302 44
		do {
			nticks += tickspending;
			nstats += statspending;
			tickspending = 0;
			statspending = 0;

			s = splclock();

			/*
			 * Reenable interrupts
			 */
			ppc_intr_enable(1);

			/*
			 * Do standard timer interrupt stuff.
			 * Do softclock stuff only on the last iteration.
			 */
			frame->pri = s | SINT_CLOCK;
			while (nticks > 1) {
				/* sync lasttb with hardclock */
				lasttb += ticks_per_intr;
				hardclock(frame);
				nticks--;
			}

			frame->pri = s;
			if (nticks) {
				/* sync lasttb with hardclock */
				lasttb += ticks_per_intr;
				hardclock(frame);
			}

			while (nstats-- > 0)
				statclock(frame);

			splx(s);
			(void) ppc_intr_disable();

			/* if a tick has occurred while dealing with these,
			 * service it now, do not delay until the next tick.
			 */
			nstats = 0;
			nticks = 0;
		} while (tickspending != 0 || statspending != 0);
@


1.11
log
@more white
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2003/07/29 12:13:32 drahn Exp $	*/
a260 6
	/*
	 * lasttb is used during microtime. Set it to the virtual
	 * start of this tick interval.
	 */
	lasttb = nexttimerevent - ticks_per_intr;

d283 6
a288 3
			if (nticks > 1)
				while (--nticks > 1)
					hardclock(frame);
d291 3
a293 1
			if (nticks)
d295 1
d401 1
a401 1
	ticks = (tb - lasttb) * ns_per_tick;
a403 1
	ticks /= 1000;
@


1.10
log
@Remove a diagnostic print which was left in the code to determine how
bad integer division is for calculation of the tick timer.
Turns out that the typical error on most machines is < .005% just
a few seconds per week. Not enough to bother with at this time.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2003/07/14 18:56:12 drahn Exp $	*/
d173 1
a173 1
		
d180 1
a180 1
		
d283 1
a283 1
			
d358 1
a358 1
	
d398 1
a398 1
	
d420 1
a420 1
	
@


1.9
log
@'dual' clock support for macppc, this allows the stat clock to run
at a rate independant of the HZ clock. when profiling is enabled
stat clock now runs at 1000/s instead of the normal 100/s. Other
improvements to the ppc clock handling and KNF/ansi.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2003/07/08 23:05:20 drahn Exp $	*/
a373 4
			printf("clock error tick %x tick/sec %x hz %x err %x\n",
				ticks_per_intr, ticks_per_sec, hz,
				ticks_per_sec - ticks_per_intr * hz);
			
@


1.8
log
@The best read code of mice and men, ... (reviewed by /dev/null)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2003/07/08 21:46:19 drahn Exp $	*/
a73 2
int power4e_getclock(int *, int *, int *, int *, int *, int *);

d81 8
d99 1
a99 2
inittodr(base)
	time_t base;
d127 1
a127 1
	} 
d170 1
a170 2
chiptotime(sec, min, hour, day, mon, year)
        int sec, min, hour, day, mon, year;
d199 1
a199 1
resettodr()
d211 1
d214 1
a214 2
decr_intr(frame)
	struct clockframe *frame;
a215 1
	int msr;
d217 1
a217 1
	int32_t tick;
d219 2
a220 1
	int pri;
a227 1
	intrcnt[PPC_CLK_IRQ]++;
d233 1
d235 25
a259 3
	tick = ppc_mfdec();  
	for (nticks = 0; tick < 0; nticks++)
		tick += ticks_per_intr;
a260 1
	ppc_mtdec(tick);
d265 1
a265 3
	lasttb = tb + tick - ticks_per_intr;

	pri = splclock();
d267 1
a267 1
	if (pri & SPL_CLOCK) {
d269 1
d271 38
a308 17
		nticks += tickspending;
		tickspending = 0;
		/*
		 * Reenable interrupts
		 */
		asm volatile ("mfmsr %0; ori %0, %0, %1; mtmsr %0"
			      : "=r"(msr) : "K"(PSL_EE));
		
		/*
		 * Do standard timer interrupt stuff.
		 * Do softclock stuff only on the last iteration.
		 */
		frame->pri = pri | SINT_CLOCK;
		while (--nticks > 0)
			hardclock(frame);
		frame->pri = pri;
		hardclock(frame);
a309 1
	splx(pri);
d315 21
a335 2
	int s;
	s = ppc_intr_disable();
d337 13
a349 2
	ppc_mtdec(ticks_per_intr);
	ppc_intr_enable(s);
d353 1
a353 1
calc_delayconst()
d366 1
a366 1
		    & ticks_per_sec, sizeof ticks_per_sec) >= 0) {
d374 4
d388 1
d397 1
a397 2
microtime(tvp)
	struct timeval *tvp;
d420 1
a420 2
delay(n)
	unsigned n;
d428 1
a428 1
	tbl = tb;
a431 2

	tb = ppc_mftb();
d438 1
a438 2
setstatclockrate(arg)
	int arg;
d440 19
a458 1
	/* Do nothing */
@


1.7
log
@Improved timebase register handling. use all 64 bits, instead of the
lower 32 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 2003/07/02 21:30:13 drahn Exp $	*/
d321 1
a321 1
	u_int32_t tb;
@


1.6
log
@Reduce the amount of asm code in powerpc/macppc by replacing it with
inlined functions, helps improve readability and fix a couple of bugs.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 2002/09/15 09:01:58 deraadt Exp $	*/
a45 1
static inline u_quad_t mftb(void);
d53 4
a56 4
static u_long ticks_per_sec = 3125000;
static u_long ns_per_tick = 320;
static long ticks_per_intr;
static volatile u_long lasttb;
d71 2
a72 2
typedef int (time_read_t)(u_long *sec);
typedef int (time_write_t)(u_long sec);
d80 1
a80 1
static u_long chiptotime(int sec, int min, int hour, int day, int mon,
d116 1
a116 1
		u_long cursec;
d164 1
a164 1
static u_long
d213 2
a214 2
	u_long tb;
	long tick;
d230 2
a231 1
	asm ("mftb %0; mfdec %1" : "=r"(tb), "=r"(tick));
d273 1
a273 1
	lasttb = ppc_mftbl();
a313 11
static inline u_quad_t
mftb()
{
	u_long scratch;
	u_quad_t tb;
	
	asm ("1: mftbu %0; mftb %0+1; mftbu %1; cmpw 0,%0,%1; bne 1b"
	     : "=r"(tb), "=r"(scratch));
	return tb;
}

d321 2
a322 2
	u_long tb;
	u_long ticks;
d326 1
a326 1
	tb = ppc_mftbl();
d345 2
a346 2
	u_quad_t tb;
	u_long tbh, tbl, scratch;
d348 1
a348 1
	tb = mftb();
d356 1
a356 1
	tb = mftb();
@


1.5
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 2002/06/09 04:13:13 drahn Exp $	*/
d42 1
d235 1
a235 1
	asm volatile ("mtdec %0" :: "r"(tick));
d271 5
a275 6
	int msr, scratch;
	asm volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
		      : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
	asm volatile ("mftb %0" : "=r"(lasttb));
	asm volatile ("mtdec %0" :: "r"(ticks_per_intr));
	asm volatile ("mtmsr %0" :: "r"(msr));
d283 1
a283 1
	int msr, scratch;
d296 1
a296 3
			asm volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
			    : "=r"(msr), "=r"(scratch)
			    : "K"((u_short)~PSL_EE));
d299 1
a299 1
			asm volatile ("mtmsr %0" :: "r"(msr));
d334 1
a334 1
	int msr, scratch;
d336 2
a337 3
	asm volatile ("mfmsr %0; andi. %1,%0,%2; mtmsr %1"
		      : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
	asm ("mftb %0" : "=r"(tb));
d340 1
a340 1
	asm volatile ("mtmsr %0" :: "r"(msr));
@


1.4
log
@KNF
@
text
@d61 2
a62 2
#define FROMBCD(x)	(((x) >> 4) * 10 + ((x) & 0xf))
#define TOBCD(x)	(((x) / 10 * 16) + ((x) % 10))
d64 3
a66 3
#define SECDAY		(24 * 60 * 60)
#define SECYR		(SECDAY * 365)
#define LEAPYEAR(y)	(((y) & 3) == 0)
d100 11
a110 11
	if (base < 5 * SECYR) {
		/*
		 * If base is 0, assume filesystem time is just unknown
		 * instead of preposterous. Don't bark.
		 */
		if (base != 0)
			printf("WARNING: preposterous time in file system\n");
		/* not going to use it anyway, if the chip is readable */
		base = 21*SECYR + 186*SECDAY + SECDAY/2;
		badbase = 1;
	}
d166 1
a166 1
	int sec, min, hour, day, mon, year;
d252 1
a252 1
		    : "=r"(msr) : "K"(PSL_EE));
d272 1
a272 1
	    : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
d289 4
a292 4
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0 &&
		    !strcmp(name, "cpu") &&
		    OF_getprop(qhandle, "timebase-frequency",
		    &ticks_per_sec, sizeof ticks_per_sec) >= 0) {
d323 1
a323 1
	    : "=r"(tb), "=r"(scratch));
d339 1
a339 1
	    : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
d367 2
a368 2
	    " mftb %0; cmplw %0,%2; blt 1b; 2:"
	    :: "r"(scratch), "r"(tbh), "r"(tbl));
@


1.3
log
@knf/cleanup/dead code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.2 2002/03/11 15:30:33 drahn Exp $	*/
d61 2
a62 2
#define FROMBCD(x)      (((x) >> 4) * 10 + ((x) & 0xf))
#define TOBCD(x)        (((x) / 10 * 16) + ((x) % 10))
d64 3
a66 3
#define SECDAY          (24 * 60 * 60)
#define SECYR           (SECDAY * 365)
#define LEAPYEAR(y)     (((y) & 3) == 0)
d100 11
a110 11
        if (base < 5 * SECYR) {
                /*
                 * If base is 0, assume filesystem time is just unknown
                 * instead of preposterous. Don't bark.
                 */
                if (base != 0)
                        printf("WARNING: preposterous time in file system\n");
                /* not going to use it anyway, if the chip is readable */
                base = 21*SECYR + 186*SECDAY + SECDAY/2;
                badbase = 1;
        }
d166 1
a166 1
        int sec, min, hour, day, mon, year;
d252 1
a252 1
			      : "=r"(msr) : "K"(PSL_EE));
d272 1
a272 1
		      : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
d289 4
a292 4
		if (OF_getprop(qhandle, "device_type", name, sizeof name) >= 0
		    && !strcmp(name, "cpu")
		    && OF_getprop(qhandle, "timebase-frequency",
		    & ticks_per_sec, sizeof ticks_per_sec) >= 0) {
d323 1
a323 1
	     : "=r"(tb), "=r"(scratch));
d339 1
a339 1
		      : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
d367 2
a368 2
	     " mftb %0; cmplw %0,%2; blt 1b; 2:"
	     :: "r"(scratch), "r"(tbh), "r"(tbl));
@


1.2
log
@If the clock has lost over 1000 days, use the filesystem time instead
of the hardware clock. Prevent clock screwage due to lost battery on laptops
where the hardware clock goes back to 0. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d70 1
a70 1
         int *mon, int *yr);
d78 1
a78 1
time_write_t  *time_write  = NULL;
d80 2
a81 2
static u_long
chiptotime(int sec, int min, int hour, int day, int mon, int year);
d123 1
d148 1
d233 1
d292 1
a292 1
				  &ticks_per_sec, sizeof ticks_per_sec) >= 0) {
d297 2
a298 1
				      : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/powerpc to macppc/macppc

This moves hardware specific files from the common directory to the
platform specific directory. This leaves common files.
With this change all of the debugger (db_) files have been moved to
the platform specific directory. The debugger should be reconsidered
and commonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2001/06/24 04:59:26 drahn Exp $	*/
d147 4
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.1 2001/09/01 15:44:20 drahn Exp $	*/
d70 1
a70 1
    int *mon, int *yr);
d78 1
a78 1
time_write_t *time_write  = NULL;
d80 2
a81 2
static u_long chiptotime(int sec, int min, int hour, int day, int mon,
    int year);
a122 1

a146 5

		if (time.tv_sec < base && deltat > 1000 * SECDAY) {
			printf(", using FS time");
			time.tv_sec = base;
		}
a226 1

d285 1
a285 1
		    & ticks_per_sec, sizeof ticks_per_sec) >= 0) {
d290 1
a290 2
			    : "=r"(msr), "=r"(scratch)
			    : "K"((u_short)~PSL_EE));
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.1.6.1 2002/06/11 03:36:34 art Exp $	*/
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current from about a week ago
@
text
@a146 4
		if (time.tv_sec < base && deltat > 1000 * SECDAY) {
			printf(", using FS time");
			time.tv_sec = base;
		}
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d70 1
a70 1
    int *mon, int *yr);
d78 1
a78 1
time_write_t *time_write  = NULL;
d80 2
a81 2
static u_long chiptotime(int sec, int min, int hour, int day, int mon,
    int year);
a122 1

a146 1

a230 1

d289 1
a289 1
		    & ticks_per_sec, sizeof ticks_per_sec) >= 0) {
d294 1
a294 2
			    : "=r"(msr), "=r"(scratch)
			    : "K"((u_short)~PSL_EE));
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a41 1
#include <machine/powerpc.h>
d45 1
d53 4
a56 4
static u_int32_t ticks_per_sec = 3125000;
static u_int32_t ns_per_tick = 320;
static int32_t ticks_per_intr;
static volatile u_int64_t lasttb;
d71 4
a74 2
typedef int (time_read_t)(u_int32_t *sec);
typedef int (time_write_t)(u_int32_t sec);
d80 1
a80 1
static u_int32_t chiptotime(int sec, int min, int hour, int day, int mon,
a82 8
/* event tracking variables, when the next events of each time should occur */
u_int64_t nexttimerevent, prevtb, nextstatevent;

/* vars for stats */
int statint;
u_int32_t statvar;
u_int32_t statmin;

d93 2
a94 1
inittodr(time_t base)
d116 1
a116 1
		u_int32_t cursec;
d122 1
a122 1
	}
d164 3
a166 2
static u_int32_t
chiptotime(int sec, int min, int hour, int day, int mon, int year)
d169 1
a169 1

d176 1
a176 1

d195 1
a195 1
resettodr(void)
a206 1
volatile int statspending;
d209 2
a210 1
decr_intr(struct clockframe *frame)
d212 5
a216 4
	u_int64_t tb;
	u_int64_t nextevent;
	int nstats;
	int s;
d224 1
d230 3
d234 1
a234 22
	tb = ppc_mftb();
	while (nexttimerevent <= tb)
		nexttimerevent += ticks_per_intr;

	prevtb = nexttimerevent - ticks_per_intr;

	for (nstats = 0; nextstatevent <= tb; nstats++) {
		int r;
		do {
			r = random() & (statvar -1);
		} while (r == 0); /* random == 0 not allowed */
		nextstatevent += statmin + r;
	}

	/* only count timer ticks for CLK_IRQ */
	intrcnt[PPC_STAT_IRQ] += nstats;

	if (nexttimerevent < nextstatevent)
		nextevent = nexttimerevent;
	else
		nextevent = nextstatevent;

d236 2
a237 2
	 * Need to work about the near constant skew this introduces???
	 * reloading tb here could cause a missed tick.
d239 3
a241 1
	ppc_mtdec(nextevent - tb);
d243 2
a244 2
	if (cpl & SPL_CLOCK) {
		statspending += nstats;
d246 2
a247 5
		nstats += statspending;
		statspending = 0;

		s = splclock();

d251 3
a253 2
		ppc_intr_enable(1);

d258 2
a259 5
		frame->pri = s | SINT_CLOCK;
		while (lasttb < prevtb - ticks_per_intr) {
			/* sync lasttb with hardclock */
			lasttb += ticks_per_intr;
			intrcnt[PPC_CLK_IRQ] ++;
d261 2
a262 19
		}

		frame->pri = s;
		while (lasttb < prevtb) {
			/* sync lasttb with hardclock */
			lasttb += ticks_per_intr;
			intrcnt[PPC_CLK_IRQ] ++;
			hardclock(frame);
		}

		while (nstats-- > 0)
			statclock(frame);

		splx(s);
		(void) ppc_intr_disable();

		/* if a tick has occurred while dealing with these,
		 * dont service it now, delay until the next tick.
		 */
d264 1
d270 6
a275 35
	int intrstate;
	int r;
	int minint;
	u_int64_t nextevent;

	intrstate = ppc_intr_disable();

	stathz = 100;
	profhz = 1000; /* must be a multiple of stathz */

	/* init secondary clock to stathz */
	statint = ticks_per_sec / stathz;
	statvar = 0x40000000; /* really big power of two */
	/* find largest 2^n which is nearly smaller than statint/2  */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	statmin = statint - (statvar >> 1);


	lasttb = ppc_mftb();
	nexttimerevent = lasttb + ticks_per_intr;
	do {
		r = random() & (statvar -1);
	} while (r == 0); /* random == 0 not allowed */
	nextstatevent = lasttb + statmin + r;

	if (nexttimerevent < nextstatevent)
		nextevent = nexttimerevent;
	else
		nextevent = nextstatevent;

	ppc_mtdec(nextevent-lasttb);
	ppc_intr_enable(intrstate);
d279 1
a279 1
calc_delayconst(void)
d283 2
a284 2
	int s;

d292 1
a292 1
		    &ticks_per_sec, sizeof ticks_per_sec) >= 0) {
d296 3
a298 1
			s = ppc_intr_disable();
d301 1
a301 1
			ppc_intr_enable(s);
a311 1

d316 11
d331 2
a332 1
microtime(struct timeval *tvp)
d334 8
a341 7
	u_int64_t tb;
	u_int32_t ticks;
	int s;

	s = ppc_intr_disable();
	tb = ppc_mftb();
	ticks = ((tb - lasttb) * ns_per_tick) / 1000;
d343 2
a344 1
	ppc_intr_enable(s);
d356 2
a357 1
delay(unsigned n)
d359 4
a362 4
	u_int64_t tb;
	u_int32_t tbh, tbl, scratch;

	tb = ppc_mftb();
d365 1
a365 1
	tbl = (u_int32_t)tb;
d369 2
d377 2
a378 1
setstatclockrate(int newhz)
d380 1
a380 19
	int minint;
	int intrstate;

	intrstate = ppc_intr_disable();

	statint = ticks_per_sec / newhz;
	statvar = 0x40000000; /* really big power of two */
	/* find largest 2^n which is nearly smaller than statint/2 */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	statmin = statint - (statvar >> 1);
	ppc_intr_enable(intrstate);

	/*
	 * XXX this allows the next stat timer to occur then it switches
	 * to the new frequency. Rather than switching instantly.
	 */
@


