head	1.15;
access;
symbols
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.6
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.15
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.14;

1.14
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.12;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.09.17.30.55;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.29.21.24.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.29.18.10.42;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.20.17.22.51;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.13.19.39.52;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.01.13.16.01;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.03.21.37.14;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.02.22.00.31;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.26.21.21.28;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.25.18.32.10;	author miod;	state Exp;
branches;
next	;


desc
@@


1.15
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: intr.c,v 1.14 2010/09/20 06:33:47 matthew Exp $	*/
/*	$NetBSD: intr.c,v 1.2 1998/08/25 04:03:56 scottr Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass, Gordon W. Ross, and Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Link and dispatch interrupts.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/vmmeter.h>
#include <sys/evcount.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/intr.h>

#define	NISR	8
#define	ISRLOC	0x18

void	intr_init(void);
void	netintr(void);

#ifdef DEBUG
int	intr_debug = 0;
#endif

/*
 * Some of the below are not used yet, but might be used someday on the
 * Q700/900/950 where the interrupt controller may be reprogrammed to
 * interrupt on different levels as listed in locore.s
 */
u_short	mac68k_ttyipl;
u_short	mac68k_netipl;
u_short	mac68k_vmipl;
u_short	mac68k_clockipl;
u_short	mac68k_statclockipl;

struct	intrhand intrs[NISR];

void	intr_computeipl(void);

void
intr_init()
{
	/* Standard spl(9) interrupt priorities */
	mac68k_ttyipl = (PSL_S | PSL_IPL1);

	if (mac68k_machine.aux_interrupts) {
		mac68k_netipl = (PSL_S | PSL_IPL3);
		mac68k_vmipl = (PSL_S | PSL_IPL6);
	} else {
		if (current_mac_model->class == MACH_CLASSAV)
			mac68k_netipl = (PSL_S | PSL_IPL4);
		else if (mac68k_machine.sonic)
			mac68k_netipl = (PSL_S | PSL_IPL3);
		else
			mac68k_netipl = (PSL_S | PSL_IPL2);

		mac68k_vmipl = (PSL_S | PSL_IPL2);
	}
	
	mac68k_clockipl = mac68k_statclockipl = mac68k_vmipl;
	intr_computeipl();
}

/*
 * Compute the interrupt levels for the spl*()
 * calls.  This doesn't have to be fast.
 */
void
intr_computeipl()
{
	/*
	 * Enforce `bio <= net <= tty <= imp <= statclock <= clock'
	 * as defined in spl(9)
	 */
	if ((PSL_S | PSL_IPL2) > mac68k_netipl)
		mac68k_netipl = (PSL_S | PSL_IPL2);
	
	if (mac68k_netipl > mac68k_ttyipl)
		mac68k_ttyipl = mac68k_netipl;

	if (mac68k_ttyipl > mac68k_vmipl)
		mac68k_vmipl = mac68k_ttyipl;

	if (mac68k_vmipl > mac68k_statclockipl)
		mac68k_statclockipl = mac68k_vmipl;

	if (mac68k_statclockipl > mac68k_clockipl)
		mac68k_clockipl = mac68k_statclockipl;
}

/*
 * Establish an autovectored interrupt handler.
 * Called by driver attach functions.
 */
void
intr_establish(int (*func)(void *), void *arg, int ipl, const char *name)
{
	struct intrhand *ih;

#ifdef DIAGNOSTIC
	if (ipl < 0 || ipl >= NISR)
		panic("intr_establish: bad ipl %d", ipl);
#endif

	ih = &intrs[ipl];

#ifdef DIAGNOSTIC
	if (ih->ih_fn != NULL)
		panic("intr_establish: attempt to share ipl %d", ipl);
#endif

	ih->ih_fn = func;
	ih->ih_arg = arg;
	ih->ih_ipl = ipl;
	evcount_attach(&ih->ih_count, name, &ih->ih_ipl);
}

/*
 * Disestablish an interrupt handler.
 */
void
intr_disestablish(int ipl)
{
	struct intrhand *ih;

#ifdef DIAGNOSTIC
	if (ipl < 0 || ipl >= NISR)
		panic("intr_disestablish: bad ipl %d", ipl);
#endif

	ih = &intrs[ipl];

#ifdef DIAGNOSTIC
	if (ih->ih_fn == NULL)
		panic("intr_disestablish: no vector on ipl %d", ipl);
#endif

	ih->ih_fn = NULL;
	evcount_detach(&ih->ih_count);
}

/*
 * This is the dispatcher called by the low-level
 * assembly language interrupt routine.
 */
void
intr_dispatch(int evec)	/* format | vector offset */
{
	struct intrhand *ih;
	int ipl, vec;

	vec = (evec & 0x0fff) >> 2;
	ipl = vec - ISRLOC;
#ifdef DIAGNOSTIC
	if (ipl < 0 || ipl >= NISR)
		panic("intr_dispatch: bad vec 0x%x", vec);
#endif

	uvmexp.intrs++;
	ih = &intrs[ipl];
	if (ih->ih_fn != NULL) {
		if ((*ih->ih_fn)(ih->ih_arg) != 0)
			ih->ih_count.ec_count++;
	} else {
#if 0
		printf("spurious interrupt, ipl %d\n", ipl);
#endif
	}
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	__asm __volatile ("movew sr,%0" : "=&d" (oldipl));

	oldipl = PSLTOIPL(oldipl);

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		_spl(PSL_S | IPLTOPSL(wantipl));
	}
}
#endif
@


1.14
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.13 2009/03/15 20:40:25 miod Exp $	*/
@


1.13
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.12 2008/06/26 05:42:12 ray Exp $	*/
d148 1
a148 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_ipl, &evcount_intr);
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.11 2007/11/09 17:30:55 miod Exp $	*/
a44 3
#include <net/netisr.h>

#include <machine/atomic.h>
a200 22
	}
}

int netisr;

void
netintr()
{
	int isr;

	while ((isr = netisr) != 0) {
		atomic_clearbits_int(&netisr, isr);
		
#define DONETISR(bit, fn)						\
		do {							\
			if (isr & (1 << bit))				\
				(fn)();					\
		} while (0)

#include <net/netisr_dispatch.h>

#undef  DONETISR
@


1.11
log
@Move splassert_check() from common m68k code to each m68k-based architecture,
as its implementation may vary accross platforms (and will very soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.10 2007/07/29 21:24:05 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@It turns out that VIA2 always interrupts at level 2, and IPL_BIO is always 2
too, so we can make these constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.9 2007/05/29 18:10:42 miod Exp $	*/
d235 21
@


1.9
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.8 2007/05/20 17:22:51 miod Exp $	*/
a73 1
u_short	mac68k_bioipl;
a87 1
	mac68k_bioipl = (PSL_S | PSL_IPL2);
a91 2
		mac68k_clockipl = (PSL_S | PSL_IPL6);
		mac68k_statclockipl = (PSL_S | PSL_IPL6);
a92 5
		mac68k_netipl = (PSL_S | PSL_IPL2);
		mac68k_vmipl = (PSL_S | PSL_IPL2);
		mac68k_clockipl = (PSL_S | PSL_IPL2);
		mac68k_statclockipl = (PSL_S | PSL_IPL2);

d95 6
d103 1
d118 2
a119 2
	if (mac68k_bioipl > mac68k_netipl)
		mac68k_netipl = mac68k_bioipl;
a136 5
 *
 * XXX Warning!  DO NOT use Macintosh ROM traps from an interrupt handler
 * established by this routine, either directly or indirectly, without
 * properly saving and restoring all registers.  If not, chaos _will_
 * ensue!  (sar 19980806)
a187 2
 *
 * XXX Note: see the warning in intr_establish()
@


1.8
log
@On AV-class machines, SCSI interrupts still come from VIA2, not PSC, so
IPL_BIO should not be modified.
Found the hard way by martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.7 2006/03/13 19:39:52 brad Exp $	*/
d54 1
d228 1
a228 1
	int s, isr;
d230 2
a231 5
	for (;;) {
		s = splhigh();
		isr = netisr;
		netisr = 0;
		splx(s);
d233 5
a237 7
		if (isr == 0)
			return;

#define DONETISR(bit, fn) do {		\
	if (isr & (1 << bit))		\
		(fn)();			\
} while (0)
@


1.7
log
@remove splimp.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6 2006/01/01 13:16:01 miod Exp $	*/
d102 1
a102 1
			mac68k_bioipl = mac68k_netipl = (PSL_S | PSL_IPL4);
@


1.6
log
@Enable A/UX style interrupt routing on non-AV Centrises and Quadras, gives us
smarter spl levels and the clock drift is reduced; adapted from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.5 2005/12/03 21:37:14 brad Exp $	*/
d75 1
a75 1
u_short	mac68k_impipl;
d92 1
a92 1
		mac68k_impipl = (PSL_S | PSL_IPL6);
d97 1
a97 1
		mac68k_impipl = (PSL_S | PSL_IPL2);
d125 2
a126 2
	if (mac68k_ttyipl > mac68k_impipl)
		mac68k_impipl = mac68k_ttyipl;
d128 2
a129 2
	if (mac68k_impipl > mac68k_statclockipl)
		mac68k_statclockipl = mac68k_impipl;
@


1.5
log
@splimp -> splhigh

From NetBSD

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.4 2004/12/24 22:50:30 miod Exp $	*/
d89 15
a103 4
	mac68k_netipl = (PSL_S | PSL_IPL2);
	mac68k_impipl = (PSL_S | PSL_IPL2);
	mac68k_clockipl = (PSL_S | PSL_IPL2);
	mac68k_statclockipl = (PSL_S | PSL_IPL2);
a104 3
	if (current_mac_model->class == MACH_CLASSAV)
		mac68k_bioipl = mac68k_netipl = (PSL_S | PSL_IPL4);

@


1.4
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.3 2004/12/02 22:00:31 martin Exp $	*/
d222 1
a222 1
		s = splimp();
@


1.3
log
@move IPL setup to intr.c

ok miod@@

>From: NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.2 2004/11/26 21:21:28 miod Exp $	*/
a79 1
extern	int intrcnt[];		/* from locore.s */
@


1.2
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.1 2004/11/25 18:32:10 miod Exp $	*/
d67 13
a79 1
struct intrhand intrs[NISR];
d81 46
@


1.1
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
d60 2
a61 23
static int intr_noint (void *);
void netintr (void);

static int ((*intr_func[NISR]) (void *)) = {
	intr_noint,
	intr_noint,
	intr_noint,
	intr_noint,
	intr_noint,
	intr_noint,
	intr_noint,
	intr_noint
};
static void *intr_arg[NISR] = {
	(void *)0,
	(void *)1,
	(void *)2,
	(void *)3,
	(void *)4,
	(void *)5,
	(void *)6,
	(void *)7
};
d67 1
d80 1
a80 4
intr_establish(func, arg, ipl)
	int (*func) (void *);
	void *arg;
	int ipl;
d82 4
a85 1
	if ((ipl < 0) || (ipl >= NISR))
d87 3
d92 2
a93 2
	if (intr_func[ipl] != intr_noint)
		printf("intr_establish: attempt to share ipl %d\n", ipl);
d96 4
a99 2
	intr_func[ipl] = func;
	intr_arg[ipl] = arg;
d106 1
a106 2
intr_disestablish(ipl)
	int ipl;
d108 4
a111 1
	if ((ipl < 0) || (ipl >= NISR))
d113 3
d117 7
a123 2
	intr_func[ipl] = intr_noint;
	intr_arg[ipl] = (void *)ipl;
d133 1
a133 2
intr_dispatch(evec)
	int evec;		/* format | vector offset */
d135 1
d138 2
a139 1
	vec = (evec & 0xfff) >> 2;
d141 2
a142 2
	if ((vec < ISRLOC) || (vec >= (ISRLOC + NISR)))
		panic("intr_dispatch: bad vec 0x%x\n", vec);
a143 1
	ipl = vec - ISRLOC;
a144 1
	intrcnt[ipl]++;
d146 7
a152 14

	(void)(*intr_func[ipl])(intr_arg[ipl]);
}

/*
 * Default interrupt handler:  do nothing.
 */
static int
intr_noint(arg)
	void *arg;
{
#ifdef DEBUG
	if (intr_debug)
		printf("intr_noint: ipl %d\n", (int)arg);
d154 1
a154 1
	return 0;
@

