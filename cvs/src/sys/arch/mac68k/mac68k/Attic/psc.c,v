head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.2.0.12
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.10
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.20
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.18
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.16
	OPENBSD_2_9_BASE:1.1
	NIKLAS_UNDEAD:1.1.0.14
	OPENBSD_2_8:1.1.0.12
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.10
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.8
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.6
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.6;

1.6
date	2004.12.14.14.50.55;	author martin;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.08.20.35.03;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.26.21.21.28;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.25.18.32.11;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.05.08.22.13.02;	author gene;	state Exp;
branches
	1.1.8.1
	1.1.20.1;
next	;

1.1.8.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	;

1.1.20.1
date	2002.06.11.03.36.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.7
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: psc.c,v 1.6 2004/12/14 14:50:55 martin Exp $	*/
/*	$NetBSD: psc.c,v 1.8 2004/03/26 12:15:46 wiz Exp $	*/


/*-
 * Copyright (c) 1997 David Huang <khym@@azeotrope.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * This handles registration/unregistration of PSC (Peripheral
 * Subsystem Controller) interrupts. The PSC is used only on the
 * Centris/Quadra 660av and the Quadra 840av.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/psc.h>

static void	psc_kill_dma(void);
int		psc_lev3_intr(void *);
static void	psc_lev3_noint(void *);
int		psc_lev4_intr(void *);
static int	psc_lev4_noint(void *);
int		psc_lev5_intr(void *);
static void	psc_lev5_noint(void *);
int		psc_lev6_intr(void *);
static void	psc_lev6_noint(void *);

void	(*psc3_ihandler)(void *) = psc_lev3_noint;
void	*psc3_iarg;

int (*psc4_itab[4])(void *) = {
	psc_lev4_noint,	/* 0 */
	psc_lev4_noint,	/* 1 */
	psc_lev4_noint,	/* 2 */
	psc_lev4_noint  /* 3 */
};

void *psc4_iarg[4] = {
	(void *)0, (void *)1, (void *)2, (void *)3
};

void (*psc5_itab[2])(void *) = {
	psc_lev5_noint, /* 0 */
	psc_lev5_noint  /* 1 */
};

void *psc5_iarg[2] = {
	(void *)0, (void *)1
};

void (*psc6_itab[3])(void *) = {
	psc_lev6_noint, /* 0 */
	psc_lev6_noint, /* 1 */
	psc_lev6_noint  /* 2 */
};

void *psc6_iarg[3] = {
	(void *)0, (void *)1, (void *)2
};

/*
 * Make excessively sure that all PSC DMA is shut down.
 */
void
psc_kill_dma()
{
	int	i;

	for (i = 0; i < 9; i++) {
		psc_reg2(PSC_CTLBASE + (i << 4)) = 0x8800;
		psc_reg2(PSC_CTLBASE + (i << 4)) = 0x1000;
		psc_reg2(PSC_CMDBASE + (i << 5)) = 0x1100;
		psc_reg2(PSC_CMDBASE + (i << 5) + PSC_SET1) = 0x1100;
	}
}

/*
 * Setup the interrupt vectors and disable most of the PSC interrupts
 */
void
psc_init()
{
	int	s, i;

	/*
	 * Only Quadra AVs have a PSC.
	 */
	if (current_mac_model->class == MACH_CLASSAV) {
		s = splhigh();
		psc_kill_dma();
		intr_establish(psc_lev3_intr, NULL, 3, "psc");
		intr_establish(psc_lev4_intr, NULL, 4, "psc");
		intr_establish(psc_lev5_intr, NULL, 5, "psc");
		intr_establish(psc_lev6_intr, NULL, 6, "psc");
		for (i = 3; i < 7; i++) {
			/* Clear any flags */
			psc_reg1(PSC_ISR_BASE + 0x10 * i) = 0x0F;
			/* Clear any interrupt enable */
			psc_reg1(PSC_IER_BASE + 0x10 * i) = 0x0F;
		}
		psc_reg1(PSC_LEV4_IER) = 0x86; /* enable SCC */
		splx(s);
	}
}

int
add_psc_lev3_intr(handler, arg)
	void (*handler)(void *);
	void *arg;
{
	int s;

	s = splhigh();

	psc3_ihandler = handler;
	psc3_iarg = arg;

	splx(s);

	return 1;
}

int
remove_psc_lev3_intr()
{
	return add_psc_lev3_intr(psc_lev3_noint, (void *)0);
}

int
psc_lev3_intr(arg)
	void *arg;
{
	u_int8_t intbits;

	while ((intbits = psc_reg1(PSC_LEV3_ISR)) != psc_reg1(PSC_LEV3_ISR))
		;
	intbits &= 0x1 & psc_reg1(PSC_LEV3_IER);

	if (intbits)
		psc3_ihandler(psc3_iarg);

	return 0;
}

static void
psc_lev3_noint(arg)
	void *arg;
{
#ifdef DEBUG
	printf("psc_lev3_noint\n");
#endif
}

int
psc_lev4_intr(arg)
	void * arg;
{
	u_int8_t intbits, bitnum;
	u_int mask;

	while ((intbits = psc_reg1(PSC_LEV4_ISR)) != psc_reg1(PSC_LEV4_ISR))
		;
	intbits &= 0xf & psc_reg1(PSC_LEV4_IER);

	mask = 1;
	bitnum = 0;
	do {
		if (intbits & mask)
			psc4_itab[bitnum](psc4_iarg[bitnum]);
		mask <<= 1;
	} while (intbits >= mask && ++bitnum);

	return 0;
}

int
add_psc_lev4_intr(dev, handler, arg)
	int dev;
	int (*handler)(void *);
	void *arg;
{
	int s;

	if ((dev < 0) || (dev > 3))
		return 0;

	s = splhigh();

	psc4_itab[dev] = handler;
	psc4_iarg[dev] = arg;

	splx(s);

	return 1;
}

int
remove_psc_lev4_intr(dev)
	int dev;
{
	return add_psc_lev4_intr(dev, psc_lev4_noint, (void *)dev);
}

int
psc_lev4_noint(arg)
	void *arg;
{
#ifdef DEBUG
	printf("psc_lev4_noint: device %d\n", (int)arg);
#endif
	return 0;
}

int
psc_lev5_intr(arg)
	void *arg;
{
	u_int8_t intbits, bitnum;
	u_int mask;

	while ((intbits = psc_reg1(PSC_LEV5_ISR)) != psc_reg1(PSC_LEV5_ISR))
		;
	intbits &= 0x3 & psc_reg1(PSC_LEV5_IER);

	mask = 1;
	bitnum = 0;
	do {
		if (intbits & mask)
			psc5_itab[bitnum](psc5_iarg[bitnum]);
		mask <<= 1;
	} while (intbits >= mask && ++bitnum);

	return 0;
}

int
add_psc_lev5_intr(dev, handler, arg)
	int dev;
	void (*handler)(void *);
	void *arg;
{
	int s;

	if ((dev < 0) || (dev > 1))
		return 0;

	s = splhigh();

	psc5_itab[dev] = handler;
	psc5_iarg[dev] = arg;

	splx(s);

	return 1;
}

int
remove_psc_lev5_intr(dev)
	int dev;
{
	return add_psc_lev5_intr(dev, psc_lev5_noint, (void *)dev);
}

void
psc_lev5_noint(arg)
	void *arg;
{
#ifdef DEBUG
	printf("psc_lev5_noint: device %d\n", (int)arg);
#endif
}

int
psc_lev6_intr(arg)
	void *arg;
{
	u_int8_t intbits, bitnum;
	u_int mask;

	while ((intbits = psc_reg1(PSC_LEV6_ISR)) != psc_reg1(PSC_LEV6_ISR))
		;
	intbits &= 0x7 & psc_reg1(PSC_LEV6_IER);

	mask = 1;
	bitnum = 0;
	do {
		if (intbits & mask)
			psc6_itab[bitnum](psc6_iarg[bitnum]);
		mask <<= 1;
	} while (intbits >= mask && ++bitnum);

	return 0;
}

int
add_psc_lev6_intr(dev, handler, arg)
	int dev;
	void (*handler)(void *);
	void *arg;
{
	int s;

	if ((dev < 0) || (dev > 2))
		return 0;

	s = splhigh();

	psc6_itab[dev] = handler;
	psc6_iarg[dev] = arg;

	splx(s);

	return 1;
}

int
remove_psc_lev6_intr(dev)
	int dev;
{
	return add_psc_lev6_intr(dev, psc_lev6_noint, (void *)dev);
}

void
psc_lev6_noint(arg)
	void *arg;
{
#ifdef DEBUG
	printf("psc_lev6_noint: device %d\n", (int)arg);
#endif
}
@


1.6
log
@sync with NetBSD, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psc.c,v 1.5 2004/12/08 20:35:03 miod Exp $	*/
@


1.5
log
@Silence spurious interrupts unless option DEBUG
@
text
@d1 2
a2 2
/*	$OpenBSD: psc.c,v 1.4 2004/11/26 21:21:28 miod Exp $	*/
/*	$NetBSD: psc.c,v 1.5 1998/08/12 05:42:46 scottr Exp $	*/
d6 1
a6 1
 * Copyright (c) 1997 David Huang <khym@@bga.com>
d43 1
d87 16
d108 2
d114 2
d120 8
a127 5
		psc_reg1(PSC_LEV3_IER) = 0x01; /* disable level 3 interrupts */
		psc_reg1(PSC_LEV4_IER) = 0x09; /* disable level 4 interrupts */
		psc_reg1(PSC_LEV4_IER) = 0x86; /* except for SCC */
		psc_reg1(PSC_LEV5_IER) = 0x03; /* disable level 5 interrupts */
		psc_reg1(PSC_LEV6_IER) = 0x07; /* disable level 6 interrupts */
@


1.4
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: psc.c,v 1.3 2004/11/25 18:32:11 miod Exp $	*/
d150 1
d152 1
d209 1
d211 1
d269 1
d271 1
d328 1
d330 1
@


1.3
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 1
a1 1
/*	$OpenBSD: psc.c,v 1.2 2002/03/14 01:26:36 millert Exp $	*/
d95 4
a98 4
		intr_establish(psc_lev3_intr, NULL, 3);
		intr_establish(psc_lev4_intr, NULL, 4);
		intr_establish(psc_lev5_intr, NULL, 5);
		intr_establish(psc_lev6_intr, NULL, 6);
@


1.2
log
@First round of __P removal in sys
@
text
@d1 3
a3 2
/*	$OpenBSD: psc.c,v 1.1 1998/05/08 22:13:02 gene Exp $	*/
/*	$NetBSD: psc.c,v 1.4 1998/04/24 05:27:26 scottr Exp $	*/
d43 1
a43 1
void		psc_lev3_intr(struct frame *);
d45 1
a45 1
int		psc_lev4_intr(struct frame *);
d47 1
a47 1
void		psc_lev5_intr(struct frame *);
d49 1
a49 1
void		psc_lev6_intr(struct frame *);
a50 8
void		psc_spurintr(struct frame *);

void	(*lev3_intrvec)(struct frame *);
int	(*lev4_intrvec)(struct frame *);
void	(*lev5_intrvec)(struct frame *);
void	(*lev6_intrvec)(struct frame *);

extern int	zshard(void *);			/* from zs.c */
d56 3
a58 3
	psc_lev4_noint, /* 0 */
	zshard,         /* 1 */
	zshard,         /* 2 */
d92 1
a92 3
	 * Only Quadra AVs have a PSC. On other machines, point the
	 * level 4 interrupt to zshard(), and levels 3, 5, and 6 to
	 * psc_spurintr().
d95 4
a98 4
		lev3_intrvec = psc_lev3_intr;
		lev4_intrvec = psc_lev4_intr;
		lev5_intrvec = psc_lev5_intr;
		lev6_intrvec = psc_lev6_intr;
a103 3
	} else {
		lev3_intrvec = lev5_intrvec = lev6_intrvec = psc_spurintr;
		lev4_intrvec = (int (*)(struct frame *))zshard;
a106 6
void
psc_spurintr(fp)
	struct frame *fp;
{
}

d130 3
a132 3
void
psc_lev3_intr(fp)
	struct frame *fp;
d142 2
d154 2
a155 2
psc_lev4_intr(fp)
	struct frame *fp;
d211 3
a213 3
void
psc_lev5_intr(fp)
	struct frame *fp;
d229 2
d268 3
a270 3
void
psc_lev6_intr(fp)
	struct frame *fp;
d286 2
@


1.1
log
@New and much smarter handling of the PSC chip.
Based on briggs' work with some by me.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 14
a55 14
void		psc_lev3_intr __P((struct frame *));
static void	psc_lev3_noint __P((void *));
int		psc_lev4_intr __P((struct frame *));
static int	psc_lev4_noint __P((void *));
void		psc_lev5_intr __P((struct frame *));
static void	psc_lev5_noint __P((void *));
void		psc_lev6_intr __P((struct frame *));
static void	psc_lev6_noint __P((void *));
void		psc_spurintr __P((struct frame *));

void	(*lev3_intrvec) __P((struct frame *));
int	(*lev4_intrvec) __P((struct frame *));
void	(*lev5_intrvec) __P((struct frame *));
void	(*lev6_intrvec) __P((struct frame *));
d57 1
a57 1
extern int	zshard __P((void *));			/* from zs.c */
d59 1
a59 1
void	(*psc3_ihandler) __P((void *)) = psc_lev3_noint;
d62 1
a62 1
int (*psc4_itab[4]) __P((void *)) = {
d73 1
a73 1
void (*psc5_itab[2]) __P((void *)) = {
d82 1
a82 1
void (*psc6_itab[3]) __P((void *)) = {
@


1.1.20.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psc.c,v 1.1 1998/05/08 22:13:02 gene Exp $	*/
d42 14
a55 14
void		psc_lev3_intr(struct frame *);
static void	psc_lev3_noint(void *);
int		psc_lev4_intr(struct frame *);
static int	psc_lev4_noint(void *);
void		psc_lev5_intr(struct frame *);
static void	psc_lev5_noint(void *);
void		psc_lev6_intr(struct frame *);
static void	psc_lev6_noint(void *);
void		psc_spurintr(struct frame *);

void	(*lev3_intrvec)(struct frame *);
int	(*lev4_intrvec)(struct frame *);
void	(*lev5_intrvec)(struct frame *);
void	(*lev6_intrvec)(struct frame *);
d57 1
a57 1
extern int	zshard(void *);			/* from zs.c */
d59 1
a59 1
void	(*psc3_ihandler)(void *) = psc_lev3_noint;
d62 1
a62 1
int (*psc4_itab[4])(void *) = {
d73 1
a73 1
void (*psc5_itab[2])(void *) = {
d82 1
a82 1
void (*psc6_itab[3])(void *) = {
@


1.1.8.1
log
@Merge in -current from about a week ago
@
text
@d42 14
a55 14
void		psc_lev3_intr(struct frame *);
static void	psc_lev3_noint(void *);
int		psc_lev4_intr(struct frame *);
static int	psc_lev4_noint(void *);
void		psc_lev5_intr(struct frame *);
static void	psc_lev5_noint(void *);
void		psc_lev6_intr(struct frame *);
static void	psc_lev6_noint(void *);
void		psc_spurintr(struct frame *);

void	(*lev3_intrvec)(struct frame *);
int	(*lev4_intrvec)(struct frame *);
void	(*lev5_intrvec)(struct frame *);
void	(*lev6_intrvec)(struct frame *);
d57 1
a57 1
extern int	zshard(void *);			/* from zs.c */
d59 1
a59 1
void	(*psc3_ihandler)(void *) = psc_lev3_noint;
d62 1
a62 1
int (*psc4_itab[4])(void *) = {
d73 1
a73 1
void (*psc5_itab[2])(void *) = {
d82 1
a82 1
void (*psc6_itab[3])(void *) = {
@


