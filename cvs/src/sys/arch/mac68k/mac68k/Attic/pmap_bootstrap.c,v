head	1.44;
access;
symbols
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.6
	OPENBSD_5_0:1.43.0.4
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.41.0.4
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.6
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.2
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.38.0.6
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.4
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.24
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.8
	OPENBSD_2_9_BASE:1.13
	NIKLAS_UNDEAD:1.13.0.6
	OPENBSD_2_8:1.13.0.4
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.43;

1.43
date	2010.11.20.20.33.24;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.28.04.20.28;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.10.22.12.20;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2008.01.04.19.05.32;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.06.17.49.45;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.13.19.36.46;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.09.22.59.36;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.23.19.00.26;	author martin;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.15.18.52.44;	author martin;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.06.19.51.44;	author martin;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.01.12.10.23;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.26.21.12.27;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.30.21.22.20;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.27.14.26.32;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.25.18.32.11;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.27.01.52.13;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.16.20.54.47;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.03.15.55;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.10.22.25.40;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.20.19.02.28;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.14.21.44.05;	author miod;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.11.30.20.58.18;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.08.17.30.41;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.22.19.27.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.04.24.06.39.41;	author downsj;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	99.04.23.05.15.28;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	99.01.11.05.11.37;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.05.03.07.16.52;	author gene;	state Exp;
branches;
next	1.8;

1.8
date	97.01.27.13.27.17;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.01.35.52;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.10.28.14.55.34;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.06.08.16.02.23;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.18.36.29;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.14.34;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.02.50.50;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.08;	author deraadt;	state Exp;
branches;
next	;

1.12.4.1
date	2000.03.02.07.04.30;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2001.07.04.10.18.41;	author niklas;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.12.4.5;

1.12.4.5
date	2002.03.06.01.05.36;	author niklas;	state Exp;
branches;
next	1.12.4.6;

1.12.4.6
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.12.4.7;

1.12.4.7
date	2003.03.27.23.28.44;	author niklas;	state Exp;
branches;
next	1.12.4.8;

1.12.4.8
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.14;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.36.20;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.10.29.00.28.05;	author art;	state Exp;
branches;
next	;


desc
@@


1.44
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: pmap_bootstrap.c,v 1.43 2010/11/20 20:33:24 miod Exp $	*/
/*	$NetBSD: pmap_bootstrap.c,v 1.50 1999/04/07 06:14:33 scottr Exp $	*/

/* 
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap_bootstrap.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/msgbuf.h>
#include <sys/reboot.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_km.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/pmap.h>
#include <machine/pte.h>
#include <machine/vmparam.h>

#include "zsc.h"

#if NZSC > 0
extern int	zsinited;
#endif

/*
 * These are used to map the RAM:
 */
int	numranges;	/* = 0 == don't use the ranges */
u_long	low[8];
u_long	high[8];
u_long	maxaddr;	/* PA of the last physical page */
int	vidlen;
#define VIDMAPSIZE	atop(vidlen)
extern u_int32_t	mac68k_vidphys;
extern u_int32_t	videoaddr;
extern u_int32_t	videorowbytes;
extern u_int32_t	videosize;
static u_int32_t	newvideoaddr;

void	bootstrap_mac68k(int);

/*
 * pmap_bootstrap() is very tricky on mac68k because it can be called
 * with the MMU either on or off.  If it's on, we assume that it's mapped
 * with the same PA <=> LA mapping that we eventually want.
 * The page sizes and the protections will be wrong, anyway.
 *
 * nextpa is the first address following the loaded kernel.  On a IIsi
 * on 12 May 1996, that was 0xf9000 beyond firstpa.
 */

#define	RELOC(v, t)	*((t*)((u_int)&(v)))
#define PA2VA(v, t)	*((t*)((u_int)&(v) - firstpa))

/*
 * Present a totally tricky view of the world here...
 * - count video mappings in the internal IO space (which will
 *   require some contortion later on)
 * - no external IO space
 */
#define	MACHINE_IIOMAPSIZE	(IIOMAPSIZE + VIDMAPSIZE)
#define	MACHINE_INTIOBASE	IOBase
#define	MACHINE_EIOMAPSIZE	0
	 
	/*	vidpa		internal video space for some machines
	 *			PT pages		VIDMAPSIZE pages
	 *
	 * XXX note that VIDMAPSIZE, hence vidlen, is needed very early
	 *     in pmap_bootstrap(), so slightly abuse the purpose of
	 *     PMAP_MD_LOCALS here...
	 */
#define	PMAP_MD_LOCALS \
	paddr_t vidpa; \
	int i; \
	\
	vidlen = round_page(((videosize >> 16) & 0xffff) * videorowbytes + \
	    m68k_page_offset(mac68k_vidphys));

#define PMAP_MD_RELOC1() \
do { \
	vidpa = eiopa - VIDMAPSIZE * sizeof(pt_entry_t); \
} while (0)

	/*
	 * Validate the internal IO space, ROM space, and
	 * framebuffer PTEs (RW+CI).
	 *
	 * Note that this is done after the fake IIO space has been
	 * validated, hence the rom and video pte were already written to
	 * with incorrect values.
	 */
#define	PMAP_MD_MAPIOSPACE() \
do { \
	if (vidlen != 0) { \
		pte = PA2VA(vidpa, u_int *); \
		epte = pte + VIDMAPSIZE; \
		protopte = trunc_page(mac68k_vidphys) | \
		    PG_RW | PG_V | PG_CI; \
		while (pte < epte) { \
			*pte++ = protopte; \
			protopte += NBPG; \
		} \
	} \
} while (0)

#define	PMAP_MD_RELOC2() \
do { \
	IOBase = iiobase; \
	if (vidlen != 0) { \
		newvideoaddr = iiobase + ptoa(IIOMAPSIZE) \
				+ m68k_page_offset(mac68k_vidphys); \
	} \
} while (0)

/*
 * Compute memory size from the memory segment information.
 */
#define	PMAP_MD_MEMSIZE() \
do { \
	physmem = 0; \
	for (i = 0; i < numranges; i++) \
		physmem += atop(high[i] - low[i]); \
	/* reserve one page for the message buffer */ \
	maxaddr = high[numranges - 1] - PAGE_SIZE; \
	high[numranges - 1] -= round_page(MSGBUFSIZE); \
} while (0)

#define PMAP_MD_RELOC3()	/* nothing */

#include <m68k/m68k/pmap_bootstrap.c>

void
bootstrap_mac68k(tc)
	int	tc;
{
#if NZSC > 0
	extern void	zs_init(void);
#endif
	extern caddr_t	esym;
	paddr_t		nextpa;

	if (mac68k_machine.do_graybars)
		printf("Bootstrapping OpenBSD/mac68k.\n");

	mac68k_vidphys = videoaddr;

	if (((tc & 0x80000000) && (mmutype == MMU_68030)) ||
	    ((tc & 0x8000) && (mmutype == MMU_68040))) {

		if (mac68k_machine.do_graybars)
			printf("Getting mapping from MMU.\n");
		(void) get_mapping();
		if (mac68k_machine.do_graybars)
			printf("Done.\n");
	} else {
		/* MMU not enabled.  Fake up ranges. */
		numranges = 1;
		low[0] = 0;
		high[0] = mac68k_machine.mach_memsize * (1024 * 1024);
		if (mac68k_machine.do_graybars)
			printf("Faked range to byte 0x%lx.\n", high[0]);
	}
	nextpa = load_addr + round_page((vaddr_t)esym);

	if (mac68k_machine.do_graybars)
		printf("Bootstrapping the pmap system.\n");

	pmap_bootstrap(nextpa, load_addr);

	if (mac68k_machine.do_graybars)
		printf("Pmap bootstrapped.\n");

	if (!vidlen)
		panic("Don't know how to relocate video!");

	if (mac68k_machine.do_graybars)
		printf("Video address 0x%lx -> 0x%lx.\n",
		    (unsigned long)videoaddr, (unsigned long)newvideoaddr);

	mac68k_set_io_offsets(IOBase);

	/*
	 * If the serial ports are going (for console or 'echo'), then
	 * we need to make sure the IO change gets propagated properly.
	 * This resets the base addresses for the 8530 (serial) driver.
	 *
	 * WARNING!!! No printfs() (etc) BETWEEN zs_init() and the end
	 * of this function (where we start using the MMU, so the new
	 * address is correct).
	 */
#if NZSC > 0
	if (zsinited != 0)
		zs_init();
#endif

	videoaddr = newvideoaddr;
}

void
pmap_init_md()
{
	vaddr_t addr;

	/*
	 * Mark as unavailable the regions which we have mapped in
	 * pmap_bootstrap().
	 */
	addr = (vaddr_t)MACHINE_INTIOBASE;
	if (uvm_map(kernel_map, &addr,
		    ptoa(MACHINE_IIOMAPSIZE),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
				UVM_INH_NONE, UVM_ADV_RANDOM,
				UVM_FLAG_FIXED)))
		panic("pmap_init: bogons in the VM system!");
}
@


1.43
log
@This is a first step towards getting rid of avail_start and avail_end in the
kernel, currently limited to low-hanging fruit: these variables were used
by bus_dma to specify the range in which to allocate memory, back when
uvm_pglistalloc() was stupid and would not walk the vm_physseg[].

Nowadays, except on some platforms for early initialization, these variables
are not used, or do not need to be global variables. Therefore:
- remove `extern' declarations of avail_start and avail_end (or close cousins,
  such as arm physical_start and physical_end) from files which no longer need
  to use them.
- make them local variables whenever possible.
- remove them when they are assigned to but no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.42 2010/06/28 04:20:28 miod Exp $	*/
@


1.42
log
@Move uvm_km_pages struct declaration and watermark bounds to uvm_km.h, so
that md code can peek at it, and update m68k !__HAVE_PMAP_DIRECT setup code
to the recent uvm_km changes.
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.41 2009/01/10 22:12:20 thib Exp $	*/
a108 1
	paddr_t avail_next; \
a154 1
	avail_next = avail_start; \
d158 1
a160 1
	avail_end = high[numranges - 1]; \
@


1.41
log
@dont include mfs_extern.h here

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.40 2008/01/04 19:05:32 miod Exp $	*/
d45 1
a45 1
#include <uvm/uvm_pmap.h>
@


1.40
log
@Do not leave a page unused after the kernel message buffer on m68k platforms.
While there, compute the physical memory size in a much simpler way on mac68k.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.39 2007/11/02 19:18:54 martin Exp $	*/
a52 2

#include <ufs/mfs/mfs_extern.h>
@


1.39
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.38 2006/07/06 17:49:45 miod Exp $	*/
a111 2
	int avail_remaining; \
	int avail_range; \
d154 1
a154 2
 * If the MMU was disabled, compute available memory size from the memory
 * segment information.
d159 5
a163 15
	avail_remaining = 0; \
	avail_range = -1; \
	for (i = 0; i < numranges; i++) { \
		if (low[i] <= avail_next && avail_next < high[i]) { \
			avail_range = i; \
			avail_remaining = high[i] - avail_next; \
		} else if (avail_range != -1) { \
			avail_remaining += (high[i] - low[i]); \
		} \
	} \
	physmem = atop(avail_remaining + nextpa - firstpa); \
 \
	maxaddr = high[numranges - 1] - ptoa(1); \
	high[numranges - 1] -= \
	    (round_page(MSGBUFSIZE) + ptoa(1)); \
@


1.38
log
@Insert an empty page at the beginning of the kernel, so that we can map it
invalid and have NULL pointer dereferences in the kernel fault now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.37 2006/01/13 19:36:46 miod Exp $	*/
d70 1
a70 1
#define VIDMAPSIZE	btoc(vidlen)
@


1.37
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.36 2006/01/09 22:59:36 miod Exp $	*/
a90 3

extern caddr_t kernel_start;
#define	PMAP_MD_RWLOW	atop(round_page((vaddr_t)&kernel_start))
@


1.36
log
@Spank the clock: remove relics of old GPROF code, compute tickfix for
better clock adjustment, consider clocks past year 2010 as possible, and
do not display the PRAM clock if it consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.35 2006/01/04 20:39:05 miod Exp $	*/
a55 2
#include <mac68k/mac68k/macrom.h>

a76 2
extern caddr_t	ROMBase;

d97 1
a97 1
 * - count rom and video mappings in the internal IO space (which will
d101 1
a101 1
#define	MACHINE_IIOMAPSIZE	(IIOMAPSIZE + ROMMAPSIZE + VIDMAPSIZE)
a107 3
	 *	rompa 		ROM space
	 *			PT pages		ROMMAPSIZE pages
	 *
d113 1
a113 1
	paddr_t vidpa, rompa; \
a124 1
	rompa = vidpa - ROMMAPSIZE * sizeof(pt_entry_t); \
a136 7
	pte = PA2VA(rompa, u_int *); \
	epte = pte + ROMMAPSIZE; \
	protopte = ((u_int)ROMBase) | PG_RO | PG_V; \
	while (pte < epte) { \
		*pte++ = protopte; \
		protopte += NBPG; \
	} \
a151 1
	ROMBase = (char *)(iiobase + ptoa(IIOMAPSIZE)); \
d153 1
a153 1
		newvideoaddr = iiobase + ptoa(IIOMAPSIZE + ROMMAPSIZE) \
a195 1
	caddr_t		oldROMBase;
a199 1
	oldROMBase = ROMBase;
a229 5

	if (mac68k_machine.do_graybars)
		printf("Moving ROMBase from %p to %p.\n", oldROMBase, ROMBase);

	mrg_fixupROMBase(oldROMBase, ROMBase);
@


1.35
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.34 2005/10/23 19:00:26 martin Exp $	*/
a55 1
#include <mac68k/mac68k/clockreg.h>
@


1.34
log
@m68k_btop() and m68k_ptob() were mostly used by mac68k only and can
be replaced by the MI versions atop() and ptoa()
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.33 2005/09/15 18:52:44 martin Exp $	*/
d59 3
d63 1
d208 1
d210 1
d270 1
d273 1
@


1.33
log
@get rid of MD m68k_trunc_page and m68k_round_page and replace by MI
trunc_page and round_page

go go go! miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.32 2005/09/12 10:07:29 martin Exp $	*/
d94 1
a94 1
#define	PMAP_MD_RWLOW	m68k_btop(round_page((vaddr_t)&kernel_start))
d164 1
a164 1
	ROMBase = (char *)(iiobase + m68k_ptob(IIOMAPSIZE)); \
d166 1
a166 1
		newvideoaddr = iiobase + m68k_ptob(IIOMAPSIZE + ROMMAPSIZE) \
d188 1
a188 1
	physmem = m68k_btop(avail_remaining + nextpa - firstpa); \
d190 1
a190 1
	maxaddr = high[numranges - 1] - m68k_ptob(1); \
d192 1
a192 1
	    (round_page(MSGBUFSIZE) + m68k_ptob(1)); \
d281 1
a281 1
		    m68k_ptob(MACHINE_IIOMAPSIZE),
@


1.32
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.31 2005/08/06 19:51:44 martin Exp $	*/
d94 1
a94 1
#define	PMAP_MD_RWLOW	m68k_btop(m68k_round_page((vaddr_t)&kernel_start))
d152 1
a152 1
		protopte = m68k_trunc_page(mac68k_vidphys) | \
@


1.31
log
@overhaul the grf driver:

- Simplify grfmv_phys() to work like grfiv_phys(), and eliminate the
  second argument to both, as we don't use it anyway.
- Handle fbbase and fboff consistently throughout.
- Eliminate grfaddr() by pulling it into grfmmap(), which is the
  only place it was used, previously.
- grfmap() now gets the physical address of the framebuffer from
  the appropriate driver, rather than try to compute it by itself.
  Be careful with aligning the base to a page address and increase
  the length of the mapped region appropriately.
- Store the PA of the framebuffer in the softc.  This eliminates the need
  for the sc_phys callback; we can just store the PA in the grfbus attach
  args, rather than a function pointer, which simplifies the code nicely.
- Disable Valkyrie interrupts on the Quadra 630
- New and improved console framebuffer initialization and autoconfig.  This
  resolves a great many issues, including Performa 58x interrupt handling
  and offset displays on some models.
- Remove unused grf ioctls
- Some KNF and other minor things

help and ok miod@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.30 2005/08/01 12:10:23 miod Exp $	*/
d124 1
a124 1
	    (mac68k_vidphys & PGOFSET));
d152 1
a152 1
		protopte = (mac68k_vidphys & ~PGOFSET) | \
d167 1
a167 1
				+ (mac68k_vidphys & PGOFSET); \
@


1.30
log
@I'm Positive these are Type-O.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.29 2005/04/26 21:12:27 martin Exp $	*/
a69 1
extern u_int32_t	mac68k_vidlog;
a167 2
		if (mac68k_vidlog) \
			mac68k_vidlog = newvideoaddr; \
@


1.29
log
@remove now obsolete mac68k_set_pte

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.28 2004/12/30 21:22:20 miod Exp $	*/
d265 1
a265 1
	 * address is correct.
@


1.28
log
@Rework pmap_bootstrap() computations of I/O maps. Makes the MD part of
this much simpler.

Also, make sure an userland process can fill its UPT as expected.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.27 2004/11/27 14:26:32 miod Exp $	*/
a76 2
extern vm_offset_t	tmp_vpages[1];	/* nubus.c */

d199 1
a199 5
#define	PMAP_MD_RELOC3() \
do { \
	tmp_vpages[0] = va; \
	va += NBPG; \
} while (0)
@


1.27
log
@In pmap_bootstrap(), replace PMAP_MD_RWZERO, which would leave the lowest
page writeable, with PMAP_MD_RWLOW, which tells how many pages have to be
left writeable on low addresses, since the mac rom needs more than one.
This lets non-DDB mac68k kernels run.
No change on non-mac68k platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.26 2004/11/25 18:32:11 miod Exp $	*/
d166 2
a167 3
	IOBase = (u_long)m68k_ptob(nptpages * NPTEPG - MACHINE_IIOMAPSIZE); \
	ROMBase = (char *)m68k_ptob(nptpages * NPTEPG - \
	    (ROMMAPSIZE + VIDMAPSIZE)); \
d169 1
a169 2
		newvideoaddr = (u_int32_t) \
				m68k_ptob(nptpages * NPTEPG - VIDMAPSIZE) \
@


1.26
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.25 2003/06/02 23:27:49 millert Exp $	*/
d96 2
a97 1
#define	PMAP_MD_RWZERO
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.24 2002/10/12 01:09:43 krw Exp $	*/
d59 2
d274 1
a274 2
	if (   (mac68k_machine.serial_boot_echo)
	    || (mac68k_machine.serial_console))
@


1.24
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.23 2002/04/27 01:52:13 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@Lots of cleanup to catch up with other m68k-based ports and modern code,
including:
- use netisr_dispatch
- extract an allocsys() function from cpu_startup()
- updated cachectl()
- a few fixes in trap()
and more...
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.22 2002/04/16 20:54:47 miod Exp $	*/
d299 1
a299 1
		panic("pmap_init: bogons in the VM system!\n");
@


1.22
log
@Use the common m68k pmap_bootstrap code here.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.21 2002/03/14 03:15:55 millert Exp $	*/
a244 13
#if MFS
	if (boothowto & RB_MINIROOT) {
		int	v;
		boothowto |= RB_DFLTROOT;
		nextpa = round_page(nextpa);
		if ((v = mfs_initminiroot((caddr_t) nextpa-load_addr)) == 0) {
			printf("Error loading miniroot.\n");
		}
		printf("Loaded %d byte miniroot.\n", v);
		nextpa += v;
	}
#endif

d292 1
a292 1
	addr = (vaddr_t)IOBase;
d294 1
a294 1
		    m68k_ptob(IIOMAPSIZE + ROMMAPSIZE + VIDMAPSIZE),
@


1.21
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.20 2002/03/14 01:26:36 millert Exp $	*/
a43 1
#include <sys/systm.h>
d46 1
d49 1
d51 4
a55 1
#include <mac68k/mac68k/clockreg.h>
a56 3
#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/autoconf.h>
d60 1
a62 14
#define PA2VA(v, t)	(t)((u_int)(v) - firstpa)

extern char *etext;
extern int Sysptsize;
extern char *extiobase, *proc0paddr;
extern st_entry_t *Sysseg;
extern pt_entry_t *Sysptmap, *Sysmap;

extern int physmem;
extern paddr_t avail_start;
extern paddr_t avail_end;
extern vaddr_t virtual_avail, virtual_end;
extern vsize_t mem_size;

d79 2
a82 11
/*
 * Special purpose kernel virtual addresses, used for mapping
 * physical pages for a variety of temporary or permanent purposes:
 *
 *	CADDR1, CADDR2:	pmap zero/copy operations
 *	vmmap:		/dev/mem, crash dumps, parity error checking
 *	msgbufp:	kernel message buffer
 */
caddr_t		CADDR1, CADDR2, vmmap;

void	pmap_bootstrap(paddr_t, paddr_t);
d86 4
a89 5
 * Bootstrap the VM system.
 *
 * This is called with the MMU either on or off.  If it's on, we assume
 * that it's mapped with the same PA <=> LA mapping that we eventually
 * want.  The page sizes and the protections will be wrong, anyway.
a93 13
void
pmap_bootstrap(nextpa, firstpa)
	paddr_t nextpa;
	paddr_t firstpa;
{
	paddr_t kstpa, kptpa, vidpa, iiopa, rompa, kptmpa, lkptpa, p0upa;
	u_int nptpages, kstsize;
	paddr_t avail_next;
	int avail_remaining;
	int avail_range;
	int i;
	st_entry_t protoste, *ste;
	pt_entry_t protopte, *pte, *epte;
d95 4
a98 2
	vidlen = m68k_round_page(((videosize >> 16) & 0xffff) * videorowbytes +
	    (mac68k_vidphys & PGOFSET));
d100 11
a110 10
	/*
	 * Calculate important physical addresses:
	 *
	 *	kstpa		kernel segment table	1 page (!040)
	 *						N pages (040)
	 *
	 *	kptpa		statically allocated
	 *			kernel PT pages		Sysptsize+ pages
	 *
	 *	vidpa		internal video space for some machines
d116 13
a128 44
	 *	iiopa		internal IO space
	 *			PT pages		IIOMAPSIZE pages
	 *
	 * [ Sysptsize is the number of pages of PT, IIOMAPSIZE and
	 *   NBMAPSIZE are the number of PTEs, hence we need to round
	 *   the total to a page boundary with IO maps at the end. ]
	 *
	 *	kptmpa		kernel PT map		1 page
	 *
	 *	lkptpa		last kernel PT page	1 page
	 *
	 *	p0upa		proc 0 u-area		UPAGES pages
	 *
	 */
	if (mmutype == MMU_68040)
		kstsize = MAXKL2SIZE / (NPTEPG/SG4_LEV2SIZE);
	else
		kstsize = 1;
	kstpa = nextpa;
	nextpa += kstsize * NBPG;
	kptpa = nextpa;
	nptpages = Sysptsize +
		(IIOMAPSIZE + ROMMAPSIZE + VIDMAPSIZE + NPTEPG - 1) / NPTEPG;
	nextpa += nptpages * NBPG;
	vidpa = nextpa - VIDMAPSIZE * sizeof(pt_entry_t);
	rompa = vidpa  - ROMMAPSIZE * sizeof(pt_entry_t);
	iiopa = rompa  - IIOMAPSIZE * sizeof(pt_entry_t);
	kptmpa = nextpa;
	nextpa += NBPG;
	lkptpa = nextpa;
	nextpa += NBPG;
	p0upa = nextpa;
	nextpa += USPACE;

#if 0
	if (nextpa > high[0]) {
		printf("Failure in BSD boot.  nextpa=0x%lx, high[0]=0x%lx.\n",
			nextpa, high[0]);
		printf("You're hosed!  Try booting with 32-bit addressing ");
		printf("enabled in the memory control panel.\n");
		printf("Older machines may need Mode32 to get that option.\n");
		panic("Cannot work with the current memory mappings.");
	}
#endif
d130 5
a134 148
	/*
	 * Initialize segment table and kernel page table map.
	 *
	 * On 68030s and earlier MMUs the two are identical except for
	 * the valid bits so both are initialized with essentially the
	 * same values.  On the 68040, which has a mandatory 3-level
	 * structure, the segment table holds the level 1 table and part
	 * (or all) of the level 2 table and hence is considerably
	 * different.  Here the first level consists of 128 descriptors
	 * (512 bytes) each mapping 32mb of address space.  Each of these
	 * points to blocks of 128 second level descriptors (512 bytes)
	 * each mapping 256kb.  Note that there may be additional "segment
	 * table" pages depending on how large MAXKL2SIZE is.
	 *
	 * XXX cramming two levels of mapping into the single "segment"
	 * table on the 68040 is intended as a temporary hack to get things
	 * working.  The 224mb of address space that this allows will most
	 * likely be insufficient in the future (at least for the kernel).
	 */
	if (mmutype == MMU_68040) {
		int num;

		/*
		 * First invalidate the entire "segment table" pages
		 * (levels 1 and 2 have the same "invalid" value).
		 */
		pte = PA2VA(kstpa, u_int *);
		epte = &pte[kstsize * NPTEPG];
		while (pte < epte)
			*pte++ = SG_NV;
		/*
		 * Initialize level 2 descriptors (which immediately
		 * follow the level 1 table).  We need:
		 *	NPTEPG / SG4_LEV3SIZE
		 * level 2 descriptors to map each of the nptpages+1
		 * pages of PTEs.  Note that we set the "used" bit
		 * now to save the HW the expense of doing it.
		 */
		num = (nptpages + 1) * (NPTEPG / SG4_LEV3SIZE);
		pte = &(PA2VA(kstpa, u_int *))[SG4_LEV1SIZE];
		epte = &pte[num];
		protoste = kptpa | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV3SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize level 1 descriptors.  We need:
		 *	roundup(num, SG4_LEV2SIZE) / SG4_LEV2SIZE
		 * level 1 descriptors to map the `num' level 2's.
		 */
		pte = PA2VA(kstpa, u_int *);
		epte = &pte[roundup(num, SG4_LEV2SIZE) / SG4_LEV2SIZE];
		protoste = (u_int)&pte[SG4_LEV1SIZE] | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV2SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize the final level 1 descriptor to map the last
		 * block of level 2 descriptors.
		 */
		ste = &(PA2VA(kstpa, u_int *))[SG4_LEV1SIZE-1];
		pte = &(PA2VA(kstpa, u_int *))[kstsize*NPTEPG - SG4_LEV2SIZE];
		*ste = (u_int)pte | SG_U | SG_RW | SG_V;
		/*
		 * Now initialize the final portion of that block of
		 * descriptors to map the "last PT page".
		 */
		pte = &(PA2VA(kstpa, u_int *))
				[kstsize*NPTEPG - NPTEPG/SG4_LEV3SIZE];
		epte = &pte[NPTEPG/SG4_LEV3SIZE];
		protoste = lkptpa | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV3SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize Sysptmap
		 */
		pte = PA2VA(kptmpa, u_int *);
		epte = &pte[nptpages+1];
		protopte = kptpa | PG_RW | PG_CI | PG_V;
		while (pte < epte) {
			*pte++ = protopte;
			protopte += NBPG;
		}
		/*
		 * Invalidate all but the last remaining entries in both.
		 */
		epte = &(PA2VA(kptmpa, u_int *))[NPTEPG-1];
		while (pte < epte) {
			*pte++ = PG_NV;
		}
		/*
		 * Initialize the last to point to the page
		 * table page allocated earlier.
		 */
		*pte = lkptpa | PG_RW | PG_CI | PG_V;
	} else {
		/*
		 * Map the page table pages in both the HW segment table
		 * and the software Sysptmap.  Note that Sysptmap is also
		 * considered a PT page hence the +1.
		 */
		ste = PA2VA(kstpa, u_int *);
		pte = PA2VA(kptmpa, u_int *);
		epte = &pte[nptpages+1];
		protoste = kptpa | SG_RW | SG_V;
		protopte = kptpa | PG_RW | PG_CI | PG_V;
		while (pte < epte) {
			*ste++ = protoste;
			*pte++ = protopte;
			protoste += NBPG;
			protopte += NBPG;
		}
		/*
		 * Invalidate all but the last remaining entries in both.
		 */
		epte = &(PA2VA(kptmpa, u_int *))[NPTEPG-1];
		while (pte < epte) {
			*ste++ = SG_NV;
			*pte++ = PG_NV;
		}
		/*
		 * Initialize the last to point to point to the page
		 * table page allocated earlier.
		 */
		*ste = lkptpa | SG_RW | SG_V;
		*pte = lkptpa | PG_RW | PG_CI | PG_V;
	}
	/*
	 * Invalidate all entries in the last kernel PT page
	 * (u-area PTEs will be validated later).
	 */
	pte = PA2VA(lkptpa, u_int *);
	epte = &pte[NPTEPG];
	while (pte < epte)
		*pte++ = PG_NV;

	/*
	 * Initialize kernel page table.
	 * Start by invalidating the `nptpages' that we have allocated.
	 */
	pte = PA2VA(kptpa, u_int *);
	epte = &pte[nptpages * NPTEPG];
	while (pte < epte)
		*pte++ = PG_NV;
d137 1
a137 31
	 * Validate PTEs for kernel text (RO)
	 */
	pte = &(PA2VA(kptpa, u_int *))[m68k_btop(KERNBASE)];
	epte = &pte[m68k_btop(m68k_trunc_page(&etext))];
#if defined(KGDB) || defined(DDB)
	protopte = firstpa | PG_RW | PG_V;	/* XXX RW for now */
#else
	protopte = firstpa | PG_RO | PG_V;
#endif
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}
	/*
	 * Validate PTEs for kernel data/bss, dynamic data allocated
	 * by us so far (nextpa - firstpa bytes), and pages for proc0
	 * u-area and page table allocated below (RW).
	 */
	epte = &(PA2VA(kptpa, u_int *))[m68k_btop(nextpa - firstpa)];
	protopte = (protopte & ~PG_PROT) | PG_RW;
	/*
	 * Enable copy-back caching of data pages
	 */
	if (mmutype == MMU_68040)
		protopte |= PG_CCB;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}
	/*
	 * Finally, validate the internal IO space, ROM space, and
a138 78
	 */
	pte = PA2VA(iiopa, u_int *);
	epte = PA2VA(rompa, u_int *);
	protopte = IOBase | PG_RW | PG_CI | PG_V;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}

	pte = PA2VA(rompa, u_int *);
	epte = PA2VA(vidpa, u_int *);
	protopte = ((u_int) ROMBase) | PG_RO | PG_V;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}

	if (vidlen) {
		pte = PA2VA(vidpa, u_int *);
		epte = pte + VIDMAPSIZE;
		protopte = (mac68k_vidphys & ~PGOFSET) | PG_RW | PG_V | PG_CI;
		while (pte < epte) {
			*pte++ = protopte;
			protopte += NBPG;
		}
	}

	/*
	 * Calculate important exported kernel virtual addresses
	 */
	/*
	 * Sysseg: base of kernel segment table
	 */
	Sysseg = PA2VA(kstpa, st_entry_t *);
	/*
	 * Sysptmap: base of kernel page table map
	 */
	Sysptmap = PA2VA(kptmpa, pt_entry_t *);
	/*
	 * Sysmap: kernel page table (as mapped through Sysptmap)
	 * Immediately follows `nptpages' of static kernel page table.
	 */
	Sysmap = (pt_entry_t *)m68k_ptob(nptpages * NPTEPG);

	IOBase = (u_long)m68k_ptob(nptpages*NPTEPG -
			(IIOMAPSIZE + ROMMAPSIZE + VIDMAPSIZE));

	ROMBase = (char *)m68k_ptob(nptpages*NPTEPG -
					(ROMMAPSIZE + VIDMAPSIZE));

	if (vidlen) {
		newvideoaddr = (u_int32_t)
				m68k_ptob(nptpages*NPTEPG - VIDMAPSIZE)
				+ (mac68k_vidphys & PGOFSET);
		if (mac68k_vidlog)
			mac68k_vidlog = newvideoaddr;
	}

	/*
	 * Setup u-area for process 0.
	 */
	/*
	 * Zero the u-area.
	 * NOTE: `pte' and `epte' aren't PTEs here.
	 */
	pte = PA2VA(p0upa, u_int *);
	epte = (u_int *)(PA2VA(p0upa, u_int) + USPACE);
	while (pte < epte)
		*pte++ = 0;
	/*
	 * Remember the u-area address so it can be loaded in the
	 * proc struct p_addr field later.
	 */
	proc0paddr = PA2VA(p0upa, char *);

	/*
	 * VM data structures are now initialized, set up data for
	 * the pmap module.
d140 38
a177 21
	 * Note about avail_end: msgbuf is initialized just after
	 * avail_end in machdep.c.  Since the last page is used
	 * for rebooting the system (code is copied there and
	 * excution continues from copied code before the MMU
	 * is disabled), the msgbuf will get trounced between
	 * reboots if it's placed in the last physical page.
	 * To work around this, we move avail_end back one more
	 * page so the msgbuf can be preserved.
	 */
	avail_next = avail_start = m68k_round_page(nextpa);
	avail_remaining = 0;
	avail_range = -1;
	for (i = 0; i < numranges; i++) {
		if (low[i] <= avail_next && avail_next < high[i]) {
			avail_range = i;
			avail_remaining = high[i] - avail_next;
		} else if (avail_range != -1) {
			avail_remaining += (high[i] - low[i]);
		}
	}
	physmem = m68k_btop(avail_remaining + nextpa - firstpa);
d179 30
a208 44
	maxaddr = high[numranges - 1] - m68k_ptob(1);
	high[numranges - 1] -= (round_page(MSGBUFSIZE) + m68k_ptob(1));
	avail_remaining -= (round_page(MSGBUFSIZE) + m68k_ptob(1));
	avail_end = high[numranges - 1];
	avail_remaining = m68k_btop(trunc_page(avail_remaining));

	mem_size = m68k_ptob(physmem);
	virtual_avail = VM_MIN_KERNEL_ADDRESS + (nextpa - firstpa);
	virtual_end = VM_MAX_KERNEL_ADDRESS;

	/*
	 * Kernel page/segment table allocated in locore,
	 * just initialize pointers.
	 */
	{
		struct pmap *kpm = (struct pmap *)&kernel_pmap_store;

		kpm->pm_stab = Sysseg;
		kpm->pm_ptab = Sysmap;
		simple_lock_init(&kpm->pm_lock);
		kpm->pm_count = 1;
		kpm->pm_stpa = (st_entry_t *)kstpa;
		/*
		 * For the 040 we also initialize the free level 2
		 * descriptor mask noting that we have used:
		 *	0:		level 1 table
		 *	1 to `num':	map page tables
		 *	MAXKL2SIZE-1:	maps last-page page table
		 */
		if (mmutype == MMU_68040) {
			int num;
			
			kpm->pm_stfree = ~l2tobm(0);
			num = roundup((nptpages + 1) * (NPTEPG / SG4_LEV3SIZE),
				      SG4_LEV2SIZE) / SG4_LEV2SIZE;
			while (num)
				kpm->pm_stfree &= ~l2tobm(num--);
			kpm->pm_stfree &= ~l2tobm(MAXKL2SIZE-1);
			for (num = MAXKL2SIZE;
			     num < sizeof(kpm->pm_stfree)*NBBY;
			     num++)
				kpm->pm_stfree &= ~l2tobm(num);
		}
	}
d210 1
a210 20
	/*
	 * Allocate some fixed, special purpose kernel virtual addresses
	 */
	{
		extern vaddr_t		tmp_vpages[];
		vaddr_t va = virtual_avail;

		CADDR1 = (caddr_t)va;
		va += NBPG;
		CADDR2 = (caddr_t)va;
		va += NBPG;
		vmmap = (caddr_t)va;
		va += NBPG;
		tmp_vpages[0] = va;
		va += NBPG;
		msgbufp = (struct msgbuf *)va;
		va += MSGBUFSIZE;
		virtual_avail = va;
	}
}
d249 1
a249 1
		nextpa = m68k_round_page(nextpa);
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.19 2002/01/10 22:25:40 miod Exp $	*/
d255 2
a256 2
		ste = &(PA2VA(kstpa, u_int*))[SG4_LEV1SIZE-1];
		pte = &(PA2VA(kstpa, u_int*))[kstsize*NPTEPG - SG4_LEV2SIZE];
d262 1
a262 1
		pte = &(PA2VA(kstpa, u_int*))
d298 2
a299 2
		ste = PA2VA(kstpa, u_int*);
		pte = PA2VA(kptmpa, u_int*);
@


1.19
log
@Bring back pmap_motorola for mac68k.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.18 2001/12/20 19:02:28 miod Exp $	*/
d103 2
a104 2
void	pmap_bootstrap __P((paddr_t, paddr_t));
void	bootstrap_mac68k __P((int));
d546 1
a546 1
	extern void	zs_init __P((void));
@


1.18
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.17 2001/12/14 21:44:05 miod Exp $	*/
a73 1
extern int protection_codes[];
a486 19
	 * Initialize protection array.
	 * XXX don't use a switch statement, it might produce an
	 * absolute "jmp" table.
	 */
	{
		int *kp;

		kp = (int *) &protection_codes;
		kp[VM_PROT_NONE|VM_PROT_NONE|VM_PROT_NONE] = 0;
		kp[VM_PROT_READ|VM_PROT_NONE|VM_PROT_NONE] = PG_RO;
		kp[VM_PROT_READ|VM_PROT_NONE|VM_PROT_EXECUTE] = PG_RO;
		kp[VM_PROT_NONE|VM_PROT_NONE|VM_PROT_EXECUTE] = PG_RO;
		kp[VM_PROT_NONE|VM_PROT_WRITE|VM_PROT_NONE] = PG_RW;
		kp[VM_PROT_NONE|VM_PROT_WRITE|VM_PROT_EXECUTE] = PG_RW;
		kp[VM_PROT_READ|VM_PROT_WRITE|VM_PROT_NONE] = PG_RW;
		kp[VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE] = PG_RW;
	}

	/*
d624 19
@


1.17
log
@Remove the ugly protection_codes[] array, only used by the pte_prot()
macro, by a different version of the aforementioned macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.16 2001/11/30 20:58:18 miod Exp $	*/
d74 1
d488 19
a643 19
}

void
pmap_init_md()
{
	vaddr_t addr;

	/*
	 * Mark as unavailable the regions which we have mapped in
	 * pmap_bootstrap().
	 */
	addr = (vaddr_t)IOBase;
	if (uvm_map(kernel_map, &addr,
		    m68k_ptob(IIOMAPSIZE + ROMMAPSIZE + VIDMAPSIZE),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
				UVM_INH_NONE, UVM_ADV_RANDOM,
				UVM_FLAG_FIXED)))
		panic("pmap_init: bogons in the VM system!\n");
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.19 2002/01/10 22:25:40 miod Exp $	*/
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.17.2.1 2002/01/31 22:55:14 niklas Exp $	*/
d44 1
a46 1
#include <sys/systm.h>
a48 1
#include <uvm/uvm_pmap.h>
d50 3
a52 1
#include <machine/autoconf.h>
a53 1
#include <machine/frame.h>
d55 1
a55 2
#include <machine/pte.h>
#include <machine/vmparam.h>
a58 1
#include <mac68k/mac68k/clockreg.h>
d61 14
d91 1
a91 1
extern vm_offset_t	tmp_vpages[1];	/* nubus.c */
d93 9
a101 1
extern caddr_t	ROMBase;
d103 2
a104 1
void	bootstrap_mac68k(int);
d107 5
a111 4
 * pmap_bootstrap() is very tricky on mac68k because it can be called
 * with the MMU either on or off.  If it's on, we assume that it's mapped
 * with the same PA <=> LA mapping that we eventually want.
 * The page sizes and the protections will be wrong, anyway.
d116 13
d130 2
a131 2
#define	RELOC(v, t)	*((t*)((u_int)&(v)))
#define PA2VA(v, t)	*((t*)((u_int)&(v) - firstpa))
d133 10
a142 13
#define	PMAP_MD_RWZERO

/*
 * Present a totally tricky view of the world here...
 * - count rom and video mappings in the internal IO space (which will
 *   require some contortion later on)
 * - no external IO space
 */
#define	MACHINE_IIOMAPSIZE	(IIOMAPSIZE + ROMMAPSIZE + VIDMAPSIZE)
#define	MACHINE_INTIOBASE	IOBase
#define	MACHINE_EIOMAPSIZE	0
	 
	/*	vidpa		internal video space for some machines
d148 184
a331 13
	 * XXX note that VIDMAPSIZE, hence vidlen, is needed very early
	 *     in pmap_bootstrap(), so slightly abuse the purpose of
	 *     PMAP_MD_LOCALS here...
	 */
#define	PMAP_MD_LOCALS \
	paddr_t vidpa, rompa; \
	paddr_t avail_next; \
	int avail_remaining; \
	int avail_range; \
	int i; \
	\
	vidlen = round_page(((videosize >> 16) & 0xffff) * videorowbytes + \
	    (mac68k_vidphys & PGOFSET));
d333 8
a340 5
#define PMAP_MD_RELOC1() \
do { \
	vidpa = eiopa - VIDMAPSIZE * sizeof(pt_entry_t); \
	rompa = vidpa - ROMMAPSIZE * sizeof(pt_entry_t); \
} while (0)
d343 31
a373 1
	 * Validate the internal IO space, ROM space, and
d375 78
d454 31
a484 38
	 * Note that this is done after the fake IIO space has been
	 * validated, hence the rom and video pte were already written to
	 * with incorrect values.
	 */
#define	PMAP_MD_MAPIOSPACE() \
do { \
	pte = PA2VA(rompa, u_int *); \
	epte = pte + ROMMAPSIZE; \
	protopte = ((u_int)ROMBase) | PG_RO | PG_V; \
	while (pte < epte) { \
		*pte++ = protopte; \
		protopte += NBPG; \
	} \
	if (vidlen != 0) { \
		pte = PA2VA(vidpa, u_int *); \
		epte = pte + VIDMAPSIZE; \
		protopte = (mac68k_vidphys & ~PGOFSET) | \
		    PG_RW | PG_V | PG_CI; \
		while (pte < epte) { \
			*pte++ = protopte; \
			protopte += NBPG; \
		} \
	} \
} while (0)

#define	PMAP_MD_RELOC2() \
do { \
	IOBase = (u_long)m68k_ptob(nptpages * NPTEPG - MACHINE_IIOMAPSIZE); \
	ROMBase = (char *)m68k_ptob(nptpages * NPTEPG - \
	    (ROMMAPSIZE + VIDMAPSIZE)); \
	if (vidlen != 0) { \
		newvideoaddr = (u_int32_t) \
				m68k_ptob(nptpages * NPTEPG - VIDMAPSIZE) \
				+ (mac68k_vidphys & PGOFSET); \
		if (mac68k_vidlog) \
			mac68k_vidlog = newvideoaddr; \
	} \
} while (0)
d486 34
a519 30
/*
 * If the MMU was disabled, compute available memory size from the memory
 * segment information.
 */
#define	PMAP_MD_MEMSIZE() \
do { \
	avail_next = avail_start; \
	avail_remaining = 0; \
	avail_range = -1; \
	for (i = 0; i < numranges; i++) { \
		if (low[i] <= avail_next && avail_next < high[i]) { \
			avail_range = i; \
			avail_remaining = high[i] - avail_next; \
		} else if (avail_range != -1) { \
			avail_remaining += (high[i] - low[i]); \
		} \
	} \
	physmem = m68k_btop(avail_remaining + nextpa - firstpa); \
 \
	maxaddr = high[numranges - 1] - m68k_ptob(1); \
	high[numranges - 1] -= \
	    (round_page(MSGBUFSIZE) + m68k_ptob(1)); \
	avail_end = high[numranges - 1]; \
} while (0)

#define	PMAP_MD_RELOC3() \
do { \
	tmp_vpages[0] = va; \
	va += NBPG; \
} while (0)
d521 20
a540 1
#include <m68k/m68k/pmap_bootstrap.c>
d546 1
a546 1
	extern void	zs_init(void);
d575 13
d635 1
a635 1
	addr = (vaddr_t)MACHINE_INTIOBASE;
d637 1
a637 1
		    m68k_ptob(MACHINE_IIOMAPSIZE),
@


1.17.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.17.2.2 2002/06/11 03:36:20 art Exp $	*/
d299 1
a299 1
		panic("pmap_init: bogons in the VM system!");
@


1.16
log
@Switch to pmap_motorola.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.15 2001/11/06 19:53:15 miod Exp $	*/
a73 1
extern int protection_codes[];
a484 19

	/*
	 * Initialize protection array.
	 * XXX don't use a switch statement, it might produce an
	 * absolute "jmp" table.
	 */
	{
		int *kp;

		kp = (int *) &protection_codes;
		kp[VM_PROT_NONE|VM_PROT_NONE|VM_PROT_NONE] = 0;
		kp[VM_PROT_READ|VM_PROT_NONE|VM_PROT_NONE] = PG_RO;
		kp[VM_PROT_READ|VM_PROT_NONE|VM_PROT_EXECUTE] = PG_RO;
		kp[VM_PROT_NONE|VM_PROT_NONE|VM_PROT_EXECUTE] = PG_RO;
		kp[VM_PROT_NONE|VM_PROT_WRITE|VM_PROT_NONE] = PG_RW;
		kp[VM_PROT_NONE|VM_PROT_WRITE|VM_PROT_EXECUTE] = PG_RW;
		kp[VM_PROT_READ|VM_PROT_WRITE|VM_PROT_NONE] = PG_RW;
		kp[VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE] = PG_RW;
	}
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.14 2001/05/08 17:30:41 aaron Exp $	*/
d644 19
@


1.14
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.13 2000/02/22 19:27:52 deraadt Exp $	*/
d48 1
a48 1
#include <vm/vm.h>
@


1.13
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 2
a2 2
/*	$OpenBSD: pmap_bootstrap.c,v 1.12 1999/04/24 06:39:41 downsj Exp $	*/
/*	$NetBSD: pmap_bootstrap.c,v 1.30 1997/01/07 07:44:01 scottr Exp $	*/
d59 1
a59 1
#include "macrom.h"
d69 5
a73 5
extern int maxmem, physmem;
extern int avail_remaining, avail_range, avail_end;
extern vm_offset_t avail_start, avail_next;
extern vm_offset_t virtual_avail, virtual_end;
extern vm_size_t mem_size;
d79 1
a79 1
int		numranges; /* = 0 == don't use the ranges */
d82 3
a84 5
extern int		nbnumranges;
extern u_long	nbphys[];
extern u_long	nblog[];
extern   signed long	nblen[];
#define VIDMAPSIZE	btoc(m68k_round_page(vidlen))
a89 1
static int		vidlen;
d104 3
d119 2
a120 2
	vm_offset_t nextpa;
	register vm_offset_t firstpa;
d122 1
a122 2
	vm_offset_t kstpa, kptpa, vidpa, iiopa, rompa;
	vm_offset_t kptmpa, lkptpa, p0upa;
d124 3
d128 2
a129 2
	register st_entry_t protoste, *ste;
	register pt_entry_t protopte, *pte, *epte;
d131 2
a132 1
	vidlen = ((videosize >> 16) & 0xffff) * videorowbytes + PGOFSET;
d183 1
d192 1
d214 1
a214 1
		register int num;
d288 4
a291 1
		pte = &(PA2VA(kptmpa, u_int *))[NPTEPG-1];
d326 2
a327 3
	 * Invalidate all but the final entry in the last kernel PT page
	 * (u-area PTEs will be validated later).  The final entry maps
	 * the last page of physical memory.
d330 1
a330 1
	epte = &pte[NPTEPG-1];
a332 1
	*pte = (0xFFFFF000) | PG_RW | PG_CI | PG_V; /* XXX */
d374 2
a375 5
	 * Finally, validate the internal IO space PTEs (RW+CI).
	 * We do this here since the 320/350 MMU registers (also
	 * used, but to a lesser extent, on other models) are mapped
	 * in this range and it would be nice to be able to access
	 * them after the MMU is turned on.
d442 1
a442 1
	epte = (u_int *) (PA2VA(p0upa, u_int) + USPACE);
d454 9
d468 1
a468 1
		if (avail_next >= low[i] && avail_next < high[i]) {
a475 8
	avail_remaining -= m68k_round_page(MSGBUFSIZE);
	high[numranges - 1] -= m68k_round_page(MSGBUFSIZE);

	/* XXX -- this doesn't look correct to me. */
	while (high[numranges - 1] < low[numranges - 1]) {
		numranges--;
		high[numranges - 1] -= low[numranges] - high[numranges];
	}
d477 5
a481 3
	avail_remaining = m68k_trunc_page(avail_remaining);
	avail_end = avail_start + avail_remaining;
	avail_remaining = m68k_btop(avail_remaining);
d493 1
a493 1
		register int *kp;
d526 1
a526 1
			register int num;
d545 2
a546 2
		extern vm_offset_t	tmp_vpages[];
		vm_offset_t	va = virtual_avail;
d568 1
a568 1
	vm_offset_t	nextpa;
a586 1
		nbnumranges = 0;
d593 1
a593 1
	nextpa = load_addr + (((int)esym + NBPG - 1) & PG_FRAME);
d620 1
a620 2
		printf("Moving ROMBase from %p to %p.\n",
			oldROMBase, ROMBase);
d626 1
a626 2
			(unsigned long) videoaddr,
			(unsigned long) newvideoaddr);
@


1.12
log
@Use the generic m68k param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.11 1999/04/23 05:15:28 downsj Exp $	*/
a105 1
struct msgbuf	*msgbufp;
d464 2
a465 2
	avail_remaining -= m68k_round_page(sizeof(struct msgbuf));
	high[numranges - 1] -= m68k_round_page(sizeof(struct msgbuf));
d551 1
a551 1
		va += NBPG;
@


1.12.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 1
d465 2
a466 2
	avail_remaining -= m68k_round_page(MSGBUFSIZE);
	high[numranges - 1] -= m68k_round_page(MSGBUFSIZE);
d552 1
a552 1
		va += MSGBUFSIZE;
@


1.12.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d2 1
a2 1
/*	$NetBSD: pmap_bootstrap.c,v 1.50 1999/04/07 06:14:33 scottr Exp $	*/
d59 1
a59 1
#include <mac68k/mac68k/macrom.h>
d69 5
a73 5
extern int physmem;
extern paddr_t avail_start;
extern paddr_t avail_end;
extern vaddr_t virtual_avail, virtual_end;
extern vsize_t mem_size;
d79 1
a79 1
int	numranges;	/* = 0 == don't use the ranges */
d82 5
a86 3
u_long	maxaddr;	/* PA of the last physical page */
int	vidlen;
#define VIDMAPSIZE	btoc(vidlen)
d92 1
a106 3
void	pmap_bootstrap __P((paddr_t, paddr_t));
void	bootstrap_mac68k __P((int));

d119 2
a120 2
	paddr_t nextpa;
	paddr_t firstpa;
d122 2
a123 1
	paddr_t kstpa, kptpa, vidpa, iiopa, rompa, kptmpa, lkptpa, p0upa;
a124 3
	paddr_t avail_next;
	int avail_remaining;
	int avail_range;
d126 2
a127 2
	st_entry_t protoste, *ste;
	pt_entry_t protopte, *pte, *epte;
d129 1
a129 2
	vidlen = m68k_round_page(((videosize >> 16) & 0xffff) * videorowbytes +
	    (mac68k_vidphys & PGOFSET));
a179 1
#if 0
a187 1
#endif
d209 1
a209 1
		int num;
d283 1
a283 4
		/*
		 * Initialize the last to point to the page
		 * table page allocated earlier.
		 */
d318 3
a320 2
	 * Invalidate all entries in the last kernel PT page
	 * (u-area PTEs will be validated later).
d323 1
a323 1
	epte = &pte[NPTEPG];
d326 1
d368 5
a372 2
	 * Finally, validate the internal IO space, ROM space, and
	 * framebuffer PTEs (RW+CI).
d439 1
a439 1
	epte = (u_int *)(PA2VA(p0upa, u_int) + USPACE);
a450 9
	 *
	 * Note about avail_end: msgbuf is initialized just after
	 * avail_end in machdep.c.  Since the last page is used
	 * for rebooting the system (code is copied there and
	 * excution continues from copied code before the MMU
	 * is disabled), the msgbuf will get trounced between
	 * reboots if it's placed in the last physical page.
	 * To work around this, we move avail_end back one more
	 * page so the msgbuf can be preserved.
d456 1
a456 1
		if (low[i] <= avail_next && avail_next < high[i]) {
d464 8
d473 3
a475 5
	maxaddr = high[numranges - 1] - m68k_ptob(1);
	high[numranges - 1] -= (round_page(MSGBUFSIZE) + m68k_ptob(1));
	avail_remaining -= (round_page(MSGBUFSIZE) + m68k_ptob(1));
	avail_end = high[numranges - 1];
	avail_remaining = m68k_btop(trunc_page(avail_remaining));
d487 1
a487 1
		int *kp;
d520 1
a520 1
			int num;
d539 2
a540 2
		extern vaddr_t		tmp_vpages[];
		vaddr_t va = virtual_avail;
d562 1
a562 1
	paddr_t		nextpa;
d581 1
d588 1
a588 1
	nextpa = load_addr + round_page((vaddr_t)esym);
d615 2
a616 1
		printf("Moving ROMBase from %p to %p.\n", oldROMBase, ROMBase);
d622 2
a623 1
		    (unsigned long)videoaddr, (unsigned long)newvideoaddr);
@


1.12.4.3
log
@Merge in -current
@
text
@d48 1
a48 1
#include <uvm/uvm_extern.h>
@


1.12.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.12.4.3 2001/11/13 21:00:53 niklas Exp $	*/
a643 19
}

void
pmap_init_md()
{
	vaddr_t addr;

	/*
	 * Mark as unavailable the regions which we have mapped in
	 * pmap_bootstrap().
	 */
	addr = (vaddr_t)IOBase;
	if (uvm_map(kernel_map, &addr,
		    m68k_ptob(IIOMAPSIZE + ROMMAPSIZE + VIDMAPSIZE),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
				UVM_INH_NONE, UVM_ADV_RANDOM,
				UVM_FLAG_FIXED)))
		panic("pmap_init: bogons in the VM system!\n");
@


1.12.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
d486 19
@


1.12.4.6
log
@Merge in -current from about a week ago
@
text
@d103 2
a104 2
void	pmap_bootstrap(paddr_t, paddr_t);
void	bootstrap_mac68k(int);
d255 2
a256 2
		ste = &(PA2VA(kstpa, u_int *))[SG4_LEV1SIZE-1];
		pte = &(PA2VA(kstpa, u_int *))[kstsize*NPTEPG - SG4_LEV2SIZE];
d262 1
a262 1
		pte = &(PA2VA(kstpa, u_int *))
d298 2
a299 2
		ste = PA2VA(kstpa, u_int *);
		pte = PA2VA(kptmpa, u_int *);
d546 1
a546 1
	extern void	zs_init(void);
@


1.12.4.7
log
@Sync the SMP branch with 3.3
@
text
@d44 1
a46 1
#include <sys/systm.h>
a48 1
#include <uvm/uvm_pmap.h>
d50 3
a52 1
#include <machine/autoconf.h>
a53 1
#include <machine/frame.h>
d55 1
a55 2
#include <machine/pte.h>
#include <machine/vmparam.h>
a58 1
#include <mac68k/mac68k/clockreg.h>
d61 14
d91 1
a91 1
extern vm_offset_t	tmp_vpages[1];	/* nubus.c */
d93 9
a101 1
extern caddr_t	ROMBase;
d103 1
d107 5
a111 4
 * pmap_bootstrap() is very tricky on mac68k because it can be called
 * with the MMU either on or off.  If it's on, we assume that it's mapped
 * with the same PA <=> LA mapping that we eventually want.
 * The page sizes and the protections will be wrong, anyway.
d116 13
d130 2
a131 2
#define	RELOC(v, t)	*((t*)((u_int)&(v)))
#define PA2VA(v, t)	*((t*)((u_int)&(v) - firstpa))
d133 10
a142 13
#define	PMAP_MD_RWZERO

/*
 * Present a totally tricky view of the world here...
 * - count rom and video mappings in the internal IO space (which will
 *   require some contortion later on)
 * - no external IO space
 */
#define	MACHINE_IIOMAPSIZE	(IIOMAPSIZE + ROMMAPSIZE + VIDMAPSIZE)
#define	MACHINE_INTIOBASE	IOBase
#define	MACHINE_EIOMAPSIZE	0
	 
	/*	vidpa		internal video space for some machines
d148 184
a331 13
	 * XXX note that VIDMAPSIZE, hence vidlen, is needed very early
	 *     in pmap_bootstrap(), so slightly abuse the purpose of
	 *     PMAP_MD_LOCALS here...
	 */
#define	PMAP_MD_LOCALS \
	paddr_t vidpa, rompa; \
	paddr_t avail_next; \
	int avail_remaining; \
	int avail_range; \
	int i; \
	\
	vidlen = round_page(((videosize >> 16) & 0xffff) * videorowbytes + \
	    (mac68k_vidphys & PGOFSET));
d333 8
a340 5
#define PMAP_MD_RELOC1() \
do { \
	vidpa = eiopa - VIDMAPSIZE * sizeof(pt_entry_t); \
	rompa = vidpa - ROMMAPSIZE * sizeof(pt_entry_t); \
} while (0)
d343 31
a373 1
	 * Validate the internal IO space, ROM space, and
d375 78
d454 31
a484 38
	 * Note that this is done after the fake IIO space has been
	 * validated, hence the rom and video pte were already written to
	 * with incorrect values.
	 */
#define	PMAP_MD_MAPIOSPACE() \
do { \
	pte = PA2VA(rompa, u_int *); \
	epte = pte + ROMMAPSIZE; \
	protopte = ((u_int)ROMBase) | PG_RO | PG_V; \
	while (pte < epte) { \
		*pte++ = protopte; \
		protopte += NBPG; \
	} \
	if (vidlen != 0) { \
		pte = PA2VA(vidpa, u_int *); \
		epte = pte + VIDMAPSIZE; \
		protopte = (mac68k_vidphys & ~PGOFSET) | \
		    PG_RW | PG_V | PG_CI; \
		while (pte < epte) { \
			*pte++ = protopte; \
			protopte += NBPG; \
		} \
	} \
} while (0)

#define	PMAP_MD_RELOC2() \
do { \
	IOBase = (u_long)m68k_ptob(nptpages * NPTEPG - MACHINE_IIOMAPSIZE); \
	ROMBase = (char *)m68k_ptob(nptpages * NPTEPG - \
	    (ROMMAPSIZE + VIDMAPSIZE)); \
	if (vidlen != 0) { \
		newvideoaddr = (u_int32_t) \
				m68k_ptob(nptpages * NPTEPG - VIDMAPSIZE) \
				+ (mac68k_vidphys & PGOFSET); \
		if (mac68k_vidlog) \
			mac68k_vidlog = newvideoaddr; \
	} \
} while (0)
d486 34
a519 30
/*
 * If the MMU was disabled, compute available memory size from the memory
 * segment information.
 */
#define	PMAP_MD_MEMSIZE() \
do { \
	avail_next = avail_start; \
	avail_remaining = 0; \
	avail_range = -1; \
	for (i = 0; i < numranges; i++) { \
		if (low[i] <= avail_next && avail_next < high[i]) { \
			avail_range = i; \
			avail_remaining = high[i] - avail_next; \
		} else if (avail_range != -1) { \
			avail_remaining += (high[i] - low[i]); \
		} \
	} \
	physmem = m68k_btop(avail_remaining + nextpa - firstpa); \
 \
	maxaddr = high[numranges - 1] - m68k_ptob(1); \
	high[numranges - 1] -= \
	    (round_page(MSGBUFSIZE) + m68k_ptob(1)); \
	avail_end = high[numranges - 1]; \
} while (0)

#define	PMAP_MD_RELOC3() \
do { \
	tmp_vpages[0] = va; \
	va += NBPG; \
} while (0)
d521 20
a540 1
#include <m68k/m68k/pmap_bootstrap.c>
d575 13
d635 1
a635 1
	addr = (vaddr_t)MACHINE_INTIOBASE;
d637 1
a637 1
		    m68k_ptob(MACHINE_IIOMAPSIZE),
d642 1
a642 1
		panic("pmap_init: bogons in the VM system!");
@


1.12.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.12.4.7 2003/03/27 23:28:44 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11
log
@Kcore dump, from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.10 1999/01/11 05:11:37 millert Exp $	*/
d86 1
a86 1
#define VIDMAPSIZE	btoc(mac68k_round_page(vidlen))
d341 2
a342 2
	pte = &(PA2VA(kptpa, u_int *))[mac68k_btop(KERNBASE)];
	epte = &pte[mac68k_btop(mac68k_trunc_page(&etext))];
d357 1
a357 1
	epte = &(PA2VA(kptpa, u_int *))[mac68k_btop(nextpa - firstpa)];
d416 1
a416 1
	Sysmap = (pt_entry_t *)mac68k_ptob(nptpages * NPTEPG);
d418 1
a418 1
	IOBase = (u_long)mac68k_ptob(nptpages*NPTEPG -
d421 1
a421 1
	ROMBase = (char *)mac68k_ptob(nptpages*NPTEPG -
d426 1
a426 1
				mac68k_ptob(nptpages*NPTEPG - VIDMAPSIZE)
d453 1
a453 1
	avail_next = avail_start = mac68k_round_page(nextpa);
d464 3
a466 3
	physmem = mac68k_btop(avail_remaining + nextpa - firstpa);
	avail_remaining -= mac68k_round_page(sizeof(struct msgbuf));
	high[numranges - 1] -= mac68k_round_page(sizeof(struct msgbuf));
d474 1
a474 1
	avail_remaining = mac68k_trunc_page(avail_remaining);
d476 1
a476 1
	avail_remaining = mac68k_btop(avail_remaining);
d478 1
a478 1
	mem_size = mac68k_ptob(physmem);
d595 1
a595 1
		nextpa = mac68k_round_page(nextpa);
@


1.10
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.9 1998/05/03 07:16:52 gene Exp $	*/
a75 2
extern vm_offset_t reserve_dumppages __P((vm_offset_t));

d553 1
a553 1
		virtual_avail = reserve_dumppages(va);
@


1.9
log
@Fallout from recent merge of macinfo.h to cpu.h.
Also, fallout from interrupt glue structure becoming mroe dynamic using
locore-changeable variables to store ipl levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.8 1997/01/27 13:27:17 briggs Exp $	*/
d189 1
a189 1
		panic("Cannot work with the current memory mappings.\n");
d615 1
a615 1
		panic("Don't know how to relocate video!\n");
@


1.8
log
@NetBSD PR#3147.  From Walter Ruetten--walter@@ghpc8.ihf.rwth-aachen.de.
- Truncate video address in PTE.  Apparently some cards use wierd offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.7 1997/01/24 01:35:52 briggs Exp $	*/
a53 1
#include <machine/macinfo.h>
@


1.7
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.6 1996/10/28 14:55:34 briggs Exp $	*/
d397 1
a397 1
		protopte = mac68k_vidphys | PG_RW | PG_V | PG_CI;
@


1.6
log
@Include macinfo.h.
@
text
@d1 2
a2 2
/*	$OpenBSD: pmap_bootstrap.c,v 1.5 1996/06/08 16:02:23 briggs Exp $	*/
/*	$NetBSD: pmap_bootstrap.c,v 1.26 1996/05/18 18:54:52 briggs Exp $	*/
d575 2
a576 1
	if ((tc & 0x80000000) && (mmutype == MMU_68030)) {
@


1.5
log
@NetBSD -> OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.4 1996/05/26 18:36:29 briggs Exp $	*/
d54 1
@


1.4
log
@Add OpenBSD Id string.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d569 1
a569 1
		printf("Bootstrapping NetBSD/mac68k.\n");
@


1.3
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.2
log
@Sync. w/ NetBSD:
- Make a message more verbose for folks who try to boot in 24-bit mode.
@
text
@d1 1
a1 1
/*	$NetBSD: pmap_bootstrap.c,v 1.18 1996/02/10 23:12:46 briggs Exp $	*/
d43 1
d46 3
d53 2
d56 3
a58 1
#include <vm/vm.h>
d87 1
a87 2
#define VIDMAPSIZE	btoc(mac68k_round_page(mac68k_vidlen))
extern u_int32_t	mac68k_vidlen;
d90 5
d115 3
d124 1
a124 1
	vm_offset_t kstpa, kptpa, vidpa, iiopa, nbpa, rompa;
d131 2
a144 3
	 *	nbpa 		NuBus IO space
	 *			PT pages		NBMAPSIZE pages
	 *
d170 1
a170 2
		(IIOMAPSIZE + NBMAPSIZE + ROMMAPSIZE + VIDMAPSIZE
		 + NPTEPG - 1) / NPTEPG;
d173 1
a173 2
	nbpa  = vidpa  - NBMAPSIZE  * sizeof(pt_entry_t);
	rompa = nbpa   - ROMMAPSIZE * sizeof(pt_entry_t);
d183 1
a183 1
		printf("Failure in BSD boot.  nextpa=0x%x, high[0]=0x%x.\n",
d378 1
a378 1
	protopte = INTIOBASE | PG_RW | PG_CI | PG_V;
d385 1
a385 1
	epte = PA2VA(nbpa, u_int *);
d392 1
a392 9
	pte = PA2VA(nbpa, u_int *);
	epte = pte + NBMAPSIZE;
	protopte = NBBASE | PG_RW | PG_V | PG_CI;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}

	if (mac68k_vidlog) {
d420 1
a420 1
			(IIOMAPSIZE + ROMMAPSIZE + NBMAPSIZE + VIDMAPSIZE));
d423 1
a423 1
					(ROMMAPSIZE + NBMAPSIZE + VIDMAPSIZE));
d425 2
a426 5
	NuBusBase = (u_long)mac68k_ptob(nptpages*NPTEPG -
						(NBMAPSIZE + VIDMAPSIZE));

	if (mac68k_vidlog)
		mac68k_vidlog = (u_int32_t)
d429 3
d541 2
a542 1
		vm_offset_t va = virtual_avail;
d550 2
d562 1
a563 2
	extern u_long	videoaddr, boothowto;
	u_long		newvideoaddr = 0;
d571 1
d577 1
a577 1
		get_mapping();
d587 1
a587 1
			printf("Faked range to byte 0x%x.\n", high[0]);
d589 1
a589 1
	nextpa = load_addr + ((int)esym + NBPG - 1) & PG_FRAME;
d596 1
a596 1
		if ((v = mfs_initminiroot(nextpa-load_addr)) == 0) {
d612 2
a613 8
	if (mac68k_vidlog)
		newvideoaddr = mac68k_vidlog;
	else {
		if (NBBASE <= videoaddr && videoaddr <= NBTOP)
			newvideoaddr = videoaddr - NBBASE + NuBusBase;
		else
			panic("Don't know how to relocate video!\n");
	}
d616 1
a616 1
		printf("Moving ROMBase from 0x%x to 0x%x.\n",
d622 3
a624 2
		printf("Video address 0x%x -> 0x%x.\n",
			videoaddr, newvideoaddr);
d627 14
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pmap_bootstrap.c,v 1.17 1995/10/02 09:41:06 briggs Exp $	*/
d173 4
a176 1
		panic("You're hosed!\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
