head	1.34;
access;
symbols
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.6
	OPENBSD_5_0:1.33.0.4
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.6
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.6
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.17.0.12
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.10
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.8
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.16.0.4
	UBC_BASE:1.16
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.15.0.16
	OPENBSD_2_9_BASE:1.15
	NIKLAS_UNDEAD:1.15.0.14
	OPENBSD_2_8:1.15.0.12
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.10
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.8
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.6
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.4
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.14.0.6
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.4
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.33;

1.33
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.10.20.29.50;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.07.29.21.25.23;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.29.21.24.05;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.30.15.12.47;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.16.21.48.22;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.13.21.02.04;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.13.19.36.47;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.01.13.16.01;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.06.19.51.35;	author martin;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.11.21.07.19;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.08.06.59.45;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.26.21.21.28;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.25.18.32.11;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.08.17.30.41;	author aaron;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	98.05.03.07.16.53;	author gene;	state Exp;
branches
	1.15.8.1;
next	1.14;

1.14
date	97.03.27.14.58.53;	author briggs;	state Exp;
branches;
next	1.13;

1.13
date	97.03.08.16.17.06;	author briggs;	state Exp;
branches;
next	1.12;

1.12
date	97.01.24.01.35.54;	author briggs;	state Exp;
branches;
next	1.11;

1.11
date	96.10.30.05.36.21;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	96.10.28.14.51.52;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	96.10.21.01.50.45;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	96.06.23.15.43.22;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.06.08.16.21.17;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.05.26.18.36.37;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.05.26.18.14.41;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.45.56;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.02.04.16.40.15;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.01.24.04.38.43;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.09;	author deraadt;	state Exp;
branches;
next	;

1.15.8.1
date	2001.07.04.10.18.43;	author niklas;	state Exp;
branches;
next	1.15.8.2;

1.15.8.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	;

1.16.4.1
date	2002.06.11.03.36.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.34
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: via.c,v 1.33 2010/09/20 06:33:47 matthew Exp $	*/
/*	$NetBSD: via.c,v 1.62 1997/09/10 04:38:48 scottr Exp $	*/

/*-
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 *	This code handles both the VIA, RBV and OSS functionality.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/evcount.h>

#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/intr.h>
#include <machine/viareg.h>

int	rtclock_intr(void *);

int	via1_intr(void *);
int	via2_intr(void *);
int	rbv_intr(void *);
int	oss_intr(void *);
int	via2_nubus_intr(void *);
int	rbv_nubus_intr(void *);

static	int slot_ignore(void *);

int	VIA2 = VIA2OFF;		/* default for II, IIx, IIcx, SE/30. */

struct intrhand via1intrs[7];
via2hand_t via2intrs[7];

/*
 * Nubus slot interrupt routines and parameters for slots 9-15.  Note
 * that for simplicity of code, "v2IRQ0" for internal video is treated
 * as a slot 15 interrupt; this slot is quite fictitious in real-world
 * Macs.  See also GMFH, pp. 165-167, and "Monster, Loch Ness."
 */
struct intrhand slotintrs[7];

static struct via2hand nubus_intr;

void
via_init()
{
	unsigned int i;

	/* Initialize VIA1 */
	/* set all timers to 0 */
	via_reg(VIA1, vT1L) = 0;
	via_reg(VIA1, vT1LH) = 0;
	via_reg(VIA1, vT1C) = 0;
	via_reg(VIA1, vT1CH) = 0;
	via_reg(VIA1, vT2C) = 0;
	via_reg(VIA1, vT2CH) = 0;

	/* turn off timer latch */
	via_reg(VIA1, vACR) &= 0x3f;

	intr_establish(via1_intr, NULL, mac68k_machine.via1_ipl, "via1");

	/* register default VIA1 interrupts */
	via1_register_irq(VIA1_T1, rtclock_intr, NULL, "clock");

	for (i = 0; i < 7; i++)
		SLIST_INIT(&via2intrs[i]);

	if (VIA2 == VIA2OFF) {
		/* Initialize VIA2 */
		via2_reg(vT1L) = 0;
		via2_reg(vT1LH) = 0;
		via2_reg(vT1C) = 0;
		via2_reg(vT1CH) = 0;
		via2_reg(vT2C) = 0;
		via2_reg(vT2CH) = 0;

		/* turn off timer latch */
		via2_reg(vACR) &= 0x3f;

		/* register default VIA2 interrupts */
		nubus_intr.vh_ipl = 1;
		nubus_intr.vh_fn = via2_nubus_intr;
		via2_register_irq(&nubus_intr, NULL);
		/* 4 snd_intr, 5 via2t2_intr */

		/*
		 * Turn off SE/30 video interrupts.
		 */
		if (mac68k_machine.machineid == MACH_MACSE30) {
			via_reg(VIA1, vBufB) |= (0x40);
			via_reg(VIA1, vDirB) |= (0x40);
		}

		/*
		 * Set vPCR for SCSI interrupts.
		 */
		via2_reg(vPCR)   = 0x66;
		switch(mac68k_machine.machineid) {
		case MACH_MACPB140:
		case MACH_MACPB145:
		case MACH_MACPB150:
		case MACH_MACPB160:
		case MACH_MACPB165:
		case MACH_MACPB165C:
		case MACH_MACPB170:
		case MACH_MACPB180:
		case MACH_MACPB180C:
			break;
		default:
			via2_reg(vBufB) |= 0x02;	/* Unlock NuBus */
			via2_reg(vDirB) |= 0x02;
			break;
		}

		intr_establish(via2_intr, NULL, 2, "via2");
	} else if (current_mac_model->class == MACH_CLASSIIfx) { /* OSS */
		volatile u_char *ossintr;
		ossintr = (volatile u_char *)Via2Base + 6;
		*ossintr = 0;
		intr_establish(oss_intr, NULL, 2, "via2");
	} else {	/* RBV */
		if (current_mac_model->class == MACH_CLASSIIci) {
			/*
			 * Disable cache card. (p. 174--GtMFH)
			 */
			via2_reg(rBufB) |= DB2O_CEnable;
		}
		intr_establish(rbv_intr, NULL, 2, "via2");

		nubus_intr.vh_ipl = 1;
		nubus_intr.vh_fn = rbv_nubus_intr;
		via2_register_irq(&nubus_intr, NULL);
		/* XXX necessary? */
		add_nubus_intr(0, IPL_NONE, slot_ignore, (void *)0, "dummy");
	}
}

/*
 * Set the state of the modem serial port's clock source.
 */
void
via_set_modem(int onoff)
{
	via_reg(VIA1, vDirA) |= DA1O_vSync;
	if (onoff)
		via_reg(VIA1, vBufA) |= DA1O_vSync;
	else
		via_reg(VIA1, vBufA) &= ~DA1O_vSync;
}

int
via1_intr(void *arg)
{
	struct intrhand *ih;
	u_int8_t intbits, bitnum;
	u_int mask;

	intbits = via_reg(VIA1, vIFR);		/* get interrupts pending */
	intbits &= via_reg(VIA1, vIER);		/* only care about enabled */

	if (intbits == 0)
		return (0);

	/*
	 * Unflag interrupts here.
	 */
	via_reg(VIA1, vIFR) = intbits;

	intbits &= 0x7f;
	mask = 1;
	for (bitnum = 0, ih = via1intrs; ; bitnum++, ih++) {
		if ((intbits & mask) != 0 && ih->ih_fn != NULL)
			if ((*ih->ih_fn)(ih->ih_arg) != 0)
				ih->ih_count.ec_count++;
		mask <<= 1;
		if (intbits < mask)
			break;
	}

	return (1);
}

int
via2_intr(void *arg)
{
	struct via2hand *v2h;
	via2hand_t *anchor;
	u_int8_t intbits, bitnum;
	u_int mask;
	int handled, rc;

	intbits = via2_reg(vIFR);		/* get interrupts pending */
	intbits &= via2_reg(vIER);		/* only care about enabled */

	if (intbits == 0)
		return (0);

	via2_reg(vIFR) = intbits;

	intbits &= 0x7f;
	mask = 1;
	for (bitnum = 0, anchor = via2intrs; ; bitnum++, anchor++) {
		if ((intbits & mask) != 0) {
			handled = 0;
			SLIST_FOREACH(v2h, anchor, v2h_link) {
				struct intrhand *ih = &v2h->v2h_ih;
				rc = (*ih->ih_fn)(ih->ih_arg);
				if (rc != 0) {
					ih->ih_count.ec_count++;
					handled |= rc;
				}
			}
		}
		mask <<= 1;
		if (intbits < mask)
			break;
	}

	return (1);
}

int
rbv_intr(void *arg)
{
	struct via2hand *v2h;
	via2hand_t *anchor;
	u_int8_t intbits, bitnum;
	u_int mask;
	int handled, rc;

	intbits = via2_reg(vIFR + rIFR);
	intbits &= via2_reg(vIER + rIER);

	if (intbits == 0)
		return (0);

	via2_reg(rIFR) = intbits;

	intbits &= 0x7f;
	mask = 1;
	for (bitnum = 0, anchor = via2intrs; ; bitnum++, anchor++) {
		if ((intbits & mask) != 0) {
			handled = 0;
			SLIST_FOREACH(v2h, anchor, v2h_link) {
				struct intrhand *ih = &v2h->v2h_ih;
				rc = (*ih->ih_fn)(ih->ih_arg);
				if (rc != 0) {
					ih->ih_count.ec_count++;
					handled |= rc;
				}
			}
		}
		mask <<= 1;
		if (intbits < mask)
			break;
	}

	return (1);
}

int nubus_intr_mask = 0;

void
add_nubus_intr(int slot, int ipl, int (*func)(void *), void *client_data,
    const char *name)
{
	struct intrhand *ih;
	int s;

	/*
	 * Map Nubus slot 0 to "slot" 15; see note on Nubus slot
	 * interrupt tables.
	 */
#ifdef DIAGNOSTIC
	if (slot != 0 && (slot < 9 || slot > 14))
		panic("add_nubus_intr: wrong slot %d", slot + 9);
#endif
	if (slot == 0)
		slot = 15 - 9;
	else
		slot -= 9;

	s = splhigh();

	ih = &slotintrs[slot];

#ifdef DIAGNOSTIC
	if (ih->ih_fn != NULL)
		panic("add_nubus_intr: attempt to share slot %d", slot + 9);
#endif

	ih->ih_fn = func;
	ih->ih_arg = client_data;
	ih->ih_ipl = ipl;
	evcount_attach(&ih->ih_count, name, &ih->ih_ipl);

	nubus_intr_mask |= 1 << slot;

	splx(s);
}

void
enable_nubus_intr()
{
	if ((nubus_intr_mask & 0x3f) == 0)
		return;

	if (VIA2 == VIA2OFF)
		via2_reg(vIER) = 0x80 | V2IF_SLOTINT;
	else
		via2_reg(rIER) = 0x80 | V2IF_SLOTINT;
}

int
oss_intr(void *arg)
{
	struct intrhand *ih;
	u_int8_t intbits, bitnum;
	u_int mask;
	int s;

	intbits = via2_reg(vIFR + rIFR);

	if (intbits == 0)
		return (0);

	intbits &= 0x7f;
	mask = 1;
	for (bitnum = 0, ih = slotintrs; ; bitnum++, ih++) {
		if (intbits & mask) {
			if (ih->ih_fn != NULL) {
				s = _splraise(IPLTOPSL(ih->ih_ipl));
				if ((*ih->ih_fn)(ih->ih_arg) != 0)
					ih->ih_count.ec_count++;
				splx(s);
			}
			via2_reg(rIFR) = mask;
		}
		mask <<= 1;
		if (intbits < mask)
			break;
	}

	return (1);
}

/*ARGSUSED*/
int
via2_nubus_intr(void *bitarg)
{
	struct intrhand *ih;
	u_int8_t i, intbits, mask;
	int s, rv = 0;

	via2_reg(vIFR) = V2IF_SLOTINT;
	while ((intbits = (~via2_reg(vBufA)) & nubus_intr_mask)) {
		for (i = 6, ih = &slotintrs[i], mask = 1 << i; mask != 0;
		    i--, ih--, mask >>= 1) {
			if (intbits & mask) {
				if (ih->ih_fn != NULL) {
					s = _splraise(IPLTOPSL(ih->ih_ipl));
					if ((*ih->ih_fn)(ih->ih_arg) != 0) {
						ih->ih_count.ec_count++;
						rv = 1;
					}
					splx(s);
				}
			}
		}
		via2_reg(vIFR) = V2IF_SLOTINT;
	}
	return (rv);
}

/*ARGSUSED*/
int
rbv_nubus_intr(void *bitarg)
{
	struct intrhand *ih;
	u_int8_t i, intbits, mask;
	int s, rv = 0;

	via2_reg(rIFR) = 0x80 | V2IF_SLOTINT;
	while ((intbits = (~via2_reg(rBufA)) & via2_reg(rSlotInt))) {
		for (i = 6, ih = &slotintrs[i], mask = 1 << i; mask != 0;
		    i--, ih--, mask >>= 1) {
			if (intbits & mask) {
				if (ih->ih_fn != NULL) {
					s = _splraise(IPLTOPSL(ih->ih_ipl));
					if ((*ih->ih_fn)(ih->ih_arg) != 0) {
						ih->ih_count.ec_count++;
						rv = 1;
					}
					splx(s);
				}
			}
		}
		via2_reg(rIFR) = 0x80 | V2IF_SLOTINT;
	}
	return (rv);
}

static int
slot_ignore(void *client_data)
{
	int mask = (1 << (int)client_data);

	if (VIA2 == VIA2OFF) {
		via2_reg(vDirA) |= mask;
		via2_reg(vBufA) = mask;
		via2_reg(vDirA) &= ~mask;
	} else
		via2_reg(rBufA) = mask;

	return (1);
}

void
via_powerdown()
{
	if (VIA2 == VIA2OFF) {
		via2_reg(vDirB) |= 0x04;  /* Set write for bit 2 */
		via2_reg(vBufB) &= ~0x04; /* Shut down */
	} else if (VIA2 == RBVOFF) {
		via2_reg(rBufB) &= ~0x04;
	} else if (VIA2 == OSSOFF) {
		/*
		 * Thanks to Brad Boyer <flar@@cegt201.bradley.edu> for the
		 * Linux/mac68k code that I derived this from.
		 */
		via2_reg(OSS_oRCR) |= OSS_POWEROFF;
	}
}

void
via1_register_irq(int irq, int (*irq_func)(void *), void *client_data,
    const char *name)
{
	struct intrhand *ih;

#ifdef DIAGNOSTIC
	if (irq < 0 || irq > 7)
		panic("via1_register_irq: bad irq %d", irq);
#endif

	ih = &via1intrs[irq];

	/*
	 * VIA1 interrupts are special, since we start with temporary handlers,
	 * and later switch to better routines whenever possible.
	 * To avoid a loop in evcount lists, only invoke evcount_attach() if
	 * name is non-NULL, and have the replacements calls in adb_direct.c,
	 * clock.c and pm_direct.c pass a NULL pointer.
	 */
#ifdef DIAGNOSTIC
	if (ih->ih_fn != NULL && name != NULL)
		panic("via1_register_irq: improper invocation");
#endif

	ih->ih_fn = irq_func;
	ih->ih_arg = client_data;
	ih->ih_ipl = irq;
	if (name != NULL)
		evcount_attach(&ih->ih_count, name, &ih->ih_ipl);
}

int
via2_register_irq(struct via2hand *vh, const char *name)
{
	int irq = vh->vh_ipl;

#ifdef DIAGNOSTIC
	if (irq < 0 || irq > 7)
		panic("via2_register_irq: bad irq %d", irq);
#endif

	if (name != NULL)
		evcount_attach(&vh->vh_count, name, &vh->vh_ipl);
	SLIST_INSERT_HEAD(&via2intrs[irq], vh, v2h_link);
	return (0);
}
@


1.33
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.32 2009/03/15 20:40:25 miod Exp $	*/
@


1.32
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.31 2007/09/10 20:29:50 miod Exp $	*/
d331 1
a331 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_ipl, &evcount_intr);
d500 1
a500 2
		evcount_attach(&ih->ih_count, name, (void *)&ih->ih_ipl,
		    &evcount_intr);
d514 1
a514 2
		evcount_attach(&vh->vh_count, name, (void *)&vh->vh_ipl,
		    &evcount_intr);
@


1.31
log
@Pass a real ipl level to add_nubus_intr(), and make sure the interrupt
handler is invoked with spl raised to the given level, otherwise all nubus
interrupts are processed at level 2.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.30 2007/07/29 21:25:23 miod Exp $	*/
d201 1
a201 2
	 * Unflag interrupts here.  If we do it after each interrupt,
	 * the MRG ADB hangs up.
@


1.30
log
@slot range check in add_nubus_intr() is wrong by one.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.29 2007/07/29 21:24:05 miod Exp $	*/
d170 1
a170 1
		add_nubus_intr(0, slot_ignore, (void *)0, "dummy");
d301 1
a301 1
add_nubus_intr(int slot, int (*func)(void *), void *client_data,
d331 1
a331 1
	ih->ih_ipl = slot + 9;
d334 1
a334 1
	nubus_intr_mask |= (1 << slot);
d357 1
d369 1
d372 1
d390 1
a390 1
	int rv = 0;
d398 1
d403 1
d418 1
a418 1
	int rv = 0;
d426 1
d431 1
@


1.29
log
@It turns out that VIA2 always interrupts at level 2, and IPL_BIO is always 2
too, so we can make these constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.28 2006/06/30 15:12:47 miod Exp $	*/
d298 1
a298 1
static int nubus_intr_mask = 0;
a310 3
	if (slot == 0)
		slot = 15;
	slot -= 9;
d312 1
a312 1
	if (slot < 0 || slot > 7)
d315 4
@


1.28
log
@On OSS systems (IIfx), compute addresses relative to VIA2 rather than VIA1,
it's simpler.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.27 2006/01/16 21:48:22 miod Exp $	*/
d151 1
a151 2
		intr_establish(via2_intr, NULL, mac68k_machine.via2_ipl,
		    "via2");
d156 1
a156 2
		intr_establish(oss_intr, NULL, mac68k_machine.via2_ipl,
		    "via2");
d164 1
a164 2
		intr_establish(rbv_intr, NULL, mac68k_machine.via2_ipl,
		    "via2");
@


1.27
log
@Do not register adb and pm interrupts until the related devices initialize.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.26 2006/01/13 21:02:04 miod Exp $	*/
d155 1
a155 1
		ossintr = (volatile u_char *)IOBase + 0x1a006;
@


1.26
log
@Sync OSS code with NetBSD; supports poweroff now.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.25 2006/01/13 19:36:47 miod Exp $	*/
a52 2
int	adb_intr(void *);
int	pm_intr(void *);
a53 1
void	profclock(void *);
a98 2
	via1_register_irq(2, adb_intr, NULL, "adb");
	via1_register_irq(4, pm_intr, NULL, "pm");
@


1.25
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.24 2006/01/04 20:39:05 miod Exp $	*/
d159 3
d461 1
a461 1
	} else if (VIA2 == RBVOFF)
d463 7
@


1.24
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.23 2006/01/01 13:16:01 miod Exp $	*/
d53 2
a54 2
int	mrg_adbintr(void *);
int	mrg_pmintr(void *);
d102 2
a103 2
	via1_register_irq(2, mrg_adbintr, NULL, "adb");
	via1_register_irq(4, mrg_pmintr, NULL, "pm");
@


1.23
log
@Enable A/UX style interrupt routing on non-AV Centrises and Quadras, gives us
smarter spl levels and the clock drift is reduced; adapted from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.22 2005/02/06 19:51:35 martin Exp $	*/
d476 5
a480 6
	 * VIA1_T1 is special, since we need to temporary replace
	 * the callback during bootstrap, to compute the delay
	 * values.
	 * To avoid a loop in evcount lists, only invoke
	 * evcount_attach() if name is non-NULL, and have the two
	 * replacements calls in clock.c pass a NULL pointer.
d483 2
a484 2
	if (ih->ih_fn != NULL && irq != VIA1_T1)
		panic("via1_register_irq: attempt to share irq %d", irq);
d490 1
a490 1
	if (name != NULL || irq != VIA1_T1)
@


1.22
log
@- get rid of unused code
- KNF
- typos
- sync some parts with NetBSD

input and review by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.21 2005/01/11 21:07:19 martin Exp $	*/
d58 4
a61 4
void	via1_intr(struct frame *);
void	via2_intr(struct frame *);
void	rbv_intr(struct frame *);
void	oss_intr(struct frame *);
a66 2
void	(*real_via2_intr)(struct frame *);

d99 2
d156 2
a157 1
		real_via2_intr = via2_intr;
d159 2
a160 1
		real_via2_intr = oss_intr;
d168 2
a169 1
		real_via2_intr = rbv_intr;
d192 2
a193 2
void
via1_intr(struct frame *fp)
d203 1
a203 1
		return;
d221 2
d225 2
a226 2
void
via2_intr(struct frame *fp)
d238 1
a238 1
		return;
d246 8
a253 7
		handled = 0;
		SLIST_FOREACH(v2h, anchor, v2h_link) {
			struct intrhand *ih = &v2h->v2h_ih;
			rc = (*ih->ih_fn)(ih->ih_arg);
			if (rc != 0) {
				ih->ih_count.ec_count++;
				handled |= rc;
d256 3
d260 2
a261 4
	mask <<= 1;
	if (intbits < mask)
		break;
	}
d264 2
a265 2
void
rbv_intr(struct frame *fp)
d277 1
a277 1
		return;
d299 2
d355 2
a356 2
void
oss_intr(struct frame *fp)
d365 1
a365 1
		return;
d381 2
@


1.21
log
@rename via_shutdown() to via_powerdown() and remove unused prototype to
shrink diff to NetBSD

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.20 2004/12/08 06:59:45 miod Exp $	*/
d39 1
a39 1
 *	This code handles both the VIA and RBV functionality.
d55 1
d57 1
a57 3
int	rbv_nubus_intr(void *);
static int rbv_slot_ignore(void *);
int	rtclock_intr(void *);
d59 3
d63 5
d69 1
a69 1
int	VIA2 = 1;		/* default for II, IIx, IIcx, SE/30. */
a73 6
void	oss_intr(struct frame *);
void	rbv_intr(struct frame *);
void	via2_intr(struct frame *);

void	(*real_via2_intr)(struct frame *);

d172 1
a172 1
		add_nubus_intr(0, rbv_slot_ignore, NULL, "dummy");
d196 2
a197 1
	intbits = via_reg(VIA1, vIFR) & via_reg(VIA1, vIER);
d211 1
a211 1
		if ((intbits & mask) != 0 && ih->ih_fn != NULL) {
a213 5
		} else {
#if 0
			printf("spurious VIA1 interrupt, source %d\n", bitnum);
#endif
		}
d229 2
a230 1
	intbits = via2_reg(vIFR) & via2_reg(vIER);
d241 7
a247 8
			handled = 0;
			SLIST_FOREACH(v2h, anchor, v2h_link) {
				struct intrhand *ih = &v2h->v2h_ih;
				rc = (*ih->ih_fn)(ih->ih_arg);
				if (rc != 0) {
					ih->ih_count.ec_count++;
					handled |= rc;
				}
a248 5
#if 0
			if (handled == 0)
				printf("spurious VIA2 interrupt, source %d\n",
				    bitnum);
#endif
d250 4
a253 3
		mask <<= 1;
		if (intbits < mask)
			break;
d266 2
a267 1
	intbits = (via2_reg(vIFR + rIFR) & via2_reg(vIER + rIER));
a286 5
#if 0
			if (handled == 0)
				printf("spurious VIA2 interrupt, source %d\n",
				    bitnum);
#endif
d359 1
a359 1
	mask =1 ;
a364 3
			} else {
				printf("spurious nubus interrupt, slot %d\n",
				    bitnum);
d382 1
a382 1
	via2_reg(vIFR) = 0x80 | V2IF_SLOTINT;
a391 5
				} else {
#if 0
					printf("spurious nubus interrupt, slot %d\n",
					    i);
#endif
a417 5
				} else {
#if 0
					printf("spurious nubus interrupt, slot %d\n",
					    i);
#endif
d427 1
a427 1
rbv_slot_ignore(void *client_data)
d429 1
a429 2
	int slot = 0 + 9;
	int mask = (1 << (slot - 9));
a448 13
}

int
rbv_vidstatus()
{
/*
	int montype;

	montype = via2_reg(rMonitor) & RBVMonitorMask;
	if(montype == RBVMonIDNone)
		montype = RBVMonIDOff;
*/
	return(0);
@


1.20
log
@Tweak interrupt handling code to allow shared interrupts for VIA2 sources.
This will be necessary shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.19 2004/11/26 21:21:28 miod Exp $	*/
d467 1
a467 1
via_shutdown()
@


1.19
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.18 2004/11/25 18:32:11 miod Exp $	*/
d65 1
a65 1
struct intrhand via2intrs[7];
d81 2
d86 2
d105 3
d121 3
a123 1
		via2_register_irq(1, via2_nubus_intr, NULL, NULL);
d166 4
a169 1
		via2_register_irq(1, rbv_nubus_intr, NULL, NULL);
d226 2
a227 1
	struct intrhand *ih;
d230 1
d241 11
a251 5
	for (bitnum = 0, ih = via2intrs; ; bitnum++, ih++) {
		if ((intbits & mask) != 0 && ih->ih_fn != NULL) {
			if ((*ih->ih_fn)(ih->ih_arg) != 0)
				ih->ih_count.ec_count++;
		} else {
d253 3
a255 1
			printf("spurious VIA2 interrupt, source %d\n", bitnum);
a264 31
oss_intr(struct frame *fp)
{
	struct intrhand *ih;
	u_int8_t intbits, bitnum;
	u_int mask;

	intbits = via2_reg(vIFR + rIFR);

	if (intbits == 0)
		return;

	intbits &= 0x7f;
	mask =1 ;
	for (bitnum = 0, ih = slotintrs; ; bitnum++, ih++) {
		if (intbits & mask) {
			if (ih->ih_fn != NULL) {
				if ((*ih->ih_fn)(ih->ih_arg) != 0)
					ih->ih_count.ec_count++;
			} else {
				printf("spurious nubus interrupt, slot %d\n",
				    bitnum);
			}
			via2_reg(rIFR) = mask;
		}
		mask <<= 1;
		if (intbits < mask)
			break;
	}
}

void
d267 2
a268 1
	struct intrhand *ih;
d271 1
d282 11
a292 5
	for (bitnum = 0, ih = via2intrs; ; bitnum++, ih++) {
		if ((intbits & mask) != 0 && ih->ih_fn != NULL) {
			if ((*ih->ih_fn)(ih->ih_arg) != 0)
				ih->ih_count.ec_count++;
		} else {
d294 3
a296 1
			printf("spurious VIA2 interrupt, source %d\n", bitnum);
d357 31
d523 2
a524 3
void
via2_register_irq(int irq, int (*irq_func)(void *), void *client_data,
    const char *name)
d526 1
a526 1
	struct intrhand *ih;
a532 10
	ih = &via2intrs[irq];

#ifdef DIAGNOSTIC
	if (ih->ih_fn != NULL)
		panic("via2_register_irq: attempt to share irq %d", irq);
#endif

	ih->ih_fn = irq_func;
	ih->ih_arg = client_data;
	ih->ih_ipl = irq;
d534 1
a534 1
		evcount_attach(&ih->ih_count, name, (void *)&ih->ih_ipl,
d536 2
@


1.18
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.17 2002/03/14 01:26:36 millert Exp $	*/
d46 2
d50 1
d53 2
a54 7
static void	via1_noint(void *);
static void	via2_noint(void *);
static void	slot_ignore(void *, int);
static void	slot_noint(void *, int);
void	mrg_adbintr(void *);
void	mrg_pmintr(void *);
void	rtclock_intr(void *);
d56 3
d60 2
a61 2
void	via2_nubus_intr(void *);
void	rbv_nubus_intr(void *);
d64 2
a65 28
void (*via1itab[7])(void *)={
	via1_noint,
	via1_noint,
	mrg_adbintr,
	via1_noint,
	mrg_pmintr,
	via1_noint,
	rtclock_intr,
};	/* VIA1 interrupt handler table */

void (*via2itab[7])(void *)={
	via2_noint,
	via2_nubus_intr,
	via2_noint,
	via2_noint,
	via2_noint,	/* snd_intr */
	via2_noint,	/* via2t2_intr */
	via2_noint,
};	/* VIA2 interrupt handler table */

void *via2iarg[7] = {
	(void *) 0, (void *) 1, (void *) 2, (void *) 3,
	(void *) 4, (void *) 5, (void *) 6
};	/* Arg array for VIA2 interrupts. */

void		via2_intr(struct frame *);
void		rbv_intr(struct frame *);
void		oss_intr(struct frame *);
d67 5
a71 1
void		(*real_via2_intr)(struct frame *);
d79 1
a79 14
void (*slotitab[7])(void *, int) = {
	slot_noint,
	slot_noint,
	slot_noint,
	slot_noint,
	slot_noint,
	slot_noint,
	slot_noint	/* int_video_intr */
};

void *slotptab[7] = {
	(void *) 0, (void *) 1, (void *) 2, (void *) 3,
	(void *) 4, (void *) 5, (void *) 6
};
d96 5
d113 4
a146 1
		via2itab[1] = via2_nubus_intr;
d157 3
a159 2
		via2itab[1] = rbv_nubus_intr;
		add_nubus_intr(0, slot_ignore, NULL);
d167 1
a167 2
via_set_modem(onoff)
	int	onoff;
d177 1
a177 2
via1_intr(fp)
	struct frame *fp;
d179 3
a181 2
	u_int8_t	intbits, bitnum;
	u_int		mask;
d196 8
a203 4
	bitnum = 0;
	do {
		if (intbits & mask) {
			via1itab[bitnum]((void *)((int) bitnum));
d206 3
a208 1
	} while (intbits >= mask && ++bitnum);
d212 1
a212 2
via2_intr(fp)
	struct frame *fp;
d214 3
a216 2
	u_int8_t	intbits, bitnum;
	u_int		mask;
d227 9
a235 4
	bitnum = 0;
	do {
		if (intbits & mask)
			via2itab[bitnum](via2iarg[bitnum]);
d237 3
a239 1
	} while (intbits >= mask && ++bitnum);
d243 1
a243 2
oss_intr(fp)
	struct frame *fp;
d245 1
d256 1
a256 2
	bitnum = 0;
	do {
d258 7
a264 1
			(*slotitab[bitnum])(slotptab[bitnum], bitnum+9);
d268 3
a270 1
	} while (intbits >= mask && ++bitnum);
d274 1
a274 2
rbv_intr(fp)
	struct frame *fp;
d276 3
a278 2
	u_int8_t	intbits, bitnum;
	u_int		mask;
d289 9
a297 4
	bitnum = 0;
	do {
		if (intbits & mask)
			via2itab[bitnum](via2iarg[bitnum]);
d299 3
a301 1
	} while (intbits >= mask && ++bitnum);
d304 1
a304 6
static void
via1_noint(bitnum)
	void *bitnum;
{
	printf("via1_noint(%d)\n", (int) bitnum);
}
d306 3
a308 3
static void
via2_noint(bitnum)
	void *bitnum;
d310 2
a311 12
	printf("via2_noint(%d)\n", (int)bitnum);
}

static int	nubus_intr_mask = 0;

int
add_nubus_intr(slot, func, client_data)
	int slot;
	void (*func)(void *, int);
	void *client_data;
{
	int	s;
d319 5
a323 2
	if (slot < 9 || slot > 15)
		return 0;
d327 11
a337 2
	slotitab[slot-9] = func;
	slotptab[slot-9] = client_data;
d339 1
a339 1
	nubus_intr_mask |= (1 << (slot-9));
a341 2

	return 1;
d357 2
a358 3
void
via2_nubus_intr(bitarg)
	void *bitarg;
d360 3
a362 1
	u_int8_t	i, intbits, mask;
d366 16
a381 8
		i = 6;
		mask = (1 << i);
		do {
			if (intbits & mask)
				(*slotitab[i])(slotptab[i], i+9);
			i--;
			mask >>= 1;
		} while (mask);
d384 1
d388 2
a389 3
void
rbv_nubus_intr(bitarg)
	void *bitarg;
d391 1
d393 1
d397 16
a412 8
		i = 6;
		mask = (1 << i);
		do {
			if (intbits & mask)
				(*slotitab[i])(slotptab[i], i+9);
			i--;
			mask >>= 1;
		} while (mask);
d415 1
d418 2
a419 4
static void
slot_ignore(client_data, slot)
	void *client_data;
	int slot;
d421 2
a422 1
	register int mask = (1 << (slot-9));
a429 1
}
d431 1
a431 6
static void
slot_noint(client_data, slot)
	void *client_data;
	int slot;
{
	printf("slot_noint() slot %x\n", slot);
d458 2
a459 4
via1_register_irq(irq, irq_func, client_data)
	int irq;
	void (*irq_func)(void *);
	void *client_data;
d461 28
a488 4
	if (irq_func)
 		via1itab[irq] = irq_func;
	else
 		via1itab[irq] = via1_noint;
d492 23
a514 12
via2_register_irq(irq, irq_func, client_data)
	int irq;
	void (*irq_func)(void *);
	void *client_data;
{
	if (irq_func) {
 		via2itab[irq] = irq_func;
		via2iarg[irq] = client_data;
	} else {
 		via2itab[irq] = via2_noint;
		via2iarg[irq] = (void *) 0;
	}
@


1.17
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: via.c,v 1.16 2001/05/08 17:30:41 aaron Exp $	*/
/*	$NetBSD: via.c,v 1.58 1997/03/04 04:11:52 scottr Exp $	*/
d90 1
d173 2
d251 24
@


1.16
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.15 1998/05/03 07:16:53 gene Exp $	*/
d50 11
a60 11
static void	via1_noint __P((void *));
static void	via2_noint __P((void *));
static void	slot_ignore __P((void *, int));
static void	slot_noint __P((void *, int));
void	mrg_adbintr __P((void *));
void	mrg_pmintr __P((void *));
void	rtclock_intr __P((void *));
void	profclock __P((void *));
void	via1_intr __P((struct frame *));
void	via2_nubus_intr __P((void *));
void	rbv_nubus_intr __P((void *));
d63 1
a63 1
void (*via1itab[7]) __P((void *))={
d73 1
a73 1
void (*via2itab[7]) __P((void *))={
d88 2
a89 2
void		via2_intr __P((struct frame *));
void		rbv_intr __P((struct frame *));
d91 1
a91 1
void		(*real_via2_intr) __P((struct frame *));
d99 1
a99 1
void (*slotitab[7]) __P((void *, int)) = {
d295 1
a295 1
	void (*func) __P((void *, int));
@


1.16.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.16 2001/05/08 17:30:41 aaron Exp $	*/
d50 11
a60 11
static void	via1_noint(void *);
static void	via2_noint(void *);
static void	slot_ignore(void *, int);
static void	slot_noint(void *, int);
void	mrg_adbintr(void *);
void	mrg_pmintr(void *);
void	rtclock_intr(void *);
void	profclock(void *);
void	via1_intr(struct frame *);
void	via2_nubus_intr(void *);
void	rbv_nubus_intr(void *);
d63 1
a63 1
void (*via1itab[7])(void *)={
d73 1
a73 1
void (*via2itab[7])(void *)={
d88 2
a89 2
void		via2_intr(struct frame *);
void		rbv_intr(struct frame *);
d91 1
a91 1
void		(*real_via2_intr)(struct frame *);
d99 1
a99 1
void (*slotitab[7])(void *, int) = {
d295 1
a295 1
	void (*func)(void *, int);
@


1.15
log
@Fallout from recent merge of macinfo.h to cpu.h.
Also, fallout from interrupt glue structure becoming mroe dynamic using
locore-changeable variables to store ipl levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.14 1997/03/27 14:58:53 briggs Exp $	*/
d115 1
a115 1
VIA_initialize()
@


1.15.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.15 1998/05/03 07:16:53 gene Exp $	*/
d115 1
a115 1
via_init()
@


1.15.8.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 11
a60 11
static void	via1_noint(void *);
static void	via2_noint(void *);
static void	slot_ignore(void *, int);
static void	slot_noint(void *, int);
void	mrg_adbintr(void *);
void	mrg_pmintr(void *);
void	rtclock_intr(void *);
void	profclock(void *);
void	via1_intr(struct frame *);
void	via2_nubus_intr(void *);
void	rbv_nubus_intr(void *);
d63 1
a63 1
void (*via1itab[7])(void *)={
d73 1
a73 1
void (*via2itab[7])(void *)={
d88 2
a89 2
void		via2_intr(struct frame *);
void		rbv_intr(struct frame *);
d91 1
a91 1
void		(*real_via2_intr)(struct frame *);
d99 1
a99 1
void (*slotitab[7])(void *, int) = {
d295 1
a295 1
	void (*func)(void *, int);
@


1.14
log
@Be more careful about enabling nubus interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.13 1997/03/08 16:17:06 briggs Exp $	*/
a46 1
#include <machine/macinfo.h>
@


1.13
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.12 1997/01/24 01:35:54 briggs Exp $	*/
d325 1
a325 1
	if (!nubus_intr_mask)
@


1.12
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: via.c,v 1.11 1996/10/30 05:36:21 briggs Exp $	*/
/*	$NetBSD: via.c,v 1.55 1997/01/07 07:45:45 scottr Exp $	*/
d204 2
a205 3
	register unsigned char intbits;
	register unsigned char mask;
	register unsigned char bitnum;
d218 2
a219 2
	mask = (unsigned char) 1;

a223 1
			/* via_reg(VIA1, vIFR) = mask; */
d226 1
a226 1
	} while (intbits >= mask && ++bitnum < 7);
d233 2
a234 3
	register unsigned char intbits;
	register unsigned char mask;
	register unsigned char bitnum;
d243 2
a244 2
	mask = (unsigned char) 1;

d250 1
a250 1
	} while (intbits >= mask && ++bitnum < 7);
d257 2
a258 3
	register unsigned char intbits;
	register unsigned char mask;
	register unsigned char bitnum;
d267 2
a268 2
	mask = (unsigned char) 1;

d274 1
a274 1
	} while (intbits >= mask && ++bitnum < 7);
d288 1
a288 1
	printf("via2_noint(%d)\n", (int) bitnum);
a316 7
	/*
	 * The following should be uncommented and the call in if_ae.c
	 * removed when we can reliably handle interrupts from the video
	 * cards.
	 */
/*	enable_nubus_intr();	*/

d325 3
d329 1
a329 1
		via2_reg(vIER) = V2IF_SLOTINT | 0x80;
d331 1
a331 1
		via2_reg(rIER) = V2IF_SLOTINT | 0x80;
d339 1
a339 1
	register int	i, mask, ints;
d342 1
a342 1
	while ((ints = (~via2_reg(vBufA)) & nubus_intr_mask)) {
d345 2
a346 2
		while (mask) {
			if (ints & mask)
d350 1
a350 1
		}
d360 1
a360 1
	register int	i, mask, ints;
d363 1
a363 1
	while ((ints = (~via2_reg(rBufA)) & via2_reg(rSlotInt))) {
d366 2
a367 2
		while (mask) {
			if (ints & mask)
d371 1
a371 1
		}
d423 4
a426 17
mac68k_register_scsi_drq(drq_func, client_data)
	void	(*drq_func)(void *);
	void	*client_data;
{
	if (drq_func) {
		via2itab[0] = drq_func;
		via2iarg[0] = client_data;
	} else {
 		via2itab[0] = via2_noint;
		via2iarg[0] = (void *) 0;
	}
}

void
mac68k_register_scsi_irq(irq_func, client_data)
	void	(*irq_func)(void *);
	void	*client_data;
d428 4
a431 7
	if (irq_func) {
 		via2itab[3] = irq_func;
		via2iarg[3] = client_data;
	} else {
 		via2itab[3] = via2_noint;
		via2iarg[3] = (void *) 3;
	}
d435 4
a438 3
mac68k_register_scsi_b_irq(irq_func, client_data)
	void	(*irq_func)(void *);
	void	*client_data;
d441 2
a442 2
 		via2itab[0] = irq_func;
		via2iarg[0] = client_data;
d444 2
a445 2
 		via2itab[0] = via2_noint;
		via2iarg[0] = (void *) 0;
a446 10
}

void
mac68k_register_via1_t1_irq(irq_func)
	void	(*irq_func)(void *);
{
	if (irq_func)
 		via1itab[6] = irq_func;
	else
 		via1itab[6] = rtclock_intr;
@


1.11
log
@Make a guess that scsi-b's IRQ is on bit 0 of via2.
@
text
@d1 2
a2 2
/*	$OpenBSD: via.c,v 1.10 1996/10/28 14:51:52 briggs Exp $	*/
/*	$NetBSD: via.c,v 1.48 1996/06/21 06:12:45 scottr Exp $	*/
d151 1
a151 1
		 * unlock nubus and set vPCR for SCSI interrupts.
d154 16
a169 2
		via2_reg(vBufB) |= 0x02;
		via2_reg(vDirB) |= 0x02;
a172 1

@


1.10
log
@Add a stub for mac68k_register_scsi_b_irq() to be filled in when we figure out
which interrupt Apple decided to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.9 1996/10/21 01:50:45 briggs Exp $	*/
a449 1
#if 0
d451 2
a452 2
 		via2itab[3] = irq_func;
		via2iarg[3] = client_data;
d454 2
a455 2
 		via2itab[3] = via2_noint;
		via2iarg[3] = (void *) 3;
a456 1
#endif
@


1.9
log
@Fix two bugs noticed by Taras Ivanenko <ivanenko@@ctpa03.mit.edu>
via.c: don't allow spl to remain at splhigh on error.
mainbus.c: Make sure that variable is initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.8 1996/06/23 15:43:22 briggs Exp $	*/
d47 1
a50 3
#include "ncrscsi.h"
#include "ncr96scsi.h"

d443 16
@


1.8
log
@From scottr/NetBSD.
Minor style cleanup (avoid goto); no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.7 1996/06/08 16:21:17 briggs Exp $	*/
d292 1
a292 1
	int	s = splhigh();
d303 2
d318 1
@


1.7
log
@Sync up with latest NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: via.c,v 1.6 1996/05/26 18:36:37 briggs Exp $	*/
/*	$NetBSD: via.c,v 1.47 1996/06/07 13:04:46 briggs Exp $	*/
d94 1
a94 1
void		(*real_via2_intr)(struct frame *);
d99 2
a100 2
 * as a slot 15 interrupt; this slot is quite ficticious in real-world
 * Macs.  See also GMGH, pp. 165-167, and "Monster, Loch Ness."
d112 1
a112 1
void	*slotptab[7] = {
a334 1
try_again:
d336 4
a339 4
	if ((ints = ((~via2_reg(vBufA)) & nubus_intr_mask)) != 0) {
		mask = (1 << 6);
		i = 7;
		while (i--) {
d342 1
d345 2
a346 3
	} else
		return;
	goto try_again;
a355 1
try_again:
d357 4
a360 4
	if ((ints = ((~via2_reg(rBufA)) & via2_reg(rSlotInt))) != 0) {
		mask = (1 << 6);
		i = 7;
		while (i--) {
d363 1
d366 2
a367 3
	} else
		return;
	goto try_again;
@


1.6
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: via.c,v 1.44 1996/05/25 16:31:04 briggs Exp $	*/
d175 14
d239 1
a239 1
		if (intbits & mask) {
a240 1
		}
d264 1
a264 1
		if (intbits & mask) {
a265 1
		}
@


1.5
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.4
log
@Move VIA_Initialize() back to where it works.
@
text
@d1 1
a1 1
/*	$NetBSD: via.c,v 1.36 1996/02/03 22:50:19 briggs Exp $	*/
d44 1
d47 1
a47 1
#include "via.h"
d52 1
a52 1
static void	via1_noint __P((int));
d54 9
a62 4
void	mrg_adbintr(), mrg_pmintr(), rtclock_intr(), profclock();
void	via2_nubus_intr();
void	rbv_nubus_intr();
void	slot_noint(void *, int);
d65 1
a65 1
void (*via1itab[7])()={
d75 1
a75 1
void (*via2itab[7])()={
d90 2
a91 2
void		via2_intr(struct frame *);
void		rbv_intr(struct frame *);
d95 8
a102 2
/* nubus slot interrupt routines */
void (*slotitab[6])(void *, int) = {
d108 1
a108 1
	slot_noint
d111 4
a114 1
void	*slotptab[6];
d170 1
d175 2
a176 1
via1_intr(struct frame *fp)
d179 1
d182 1
a182 2
	intbits = via_reg(VIA1, vIFR);	/* get interrupts pending */
	intbits &= via_reg(VIA1, vIER);	/* only care about enabled ones */
d187 4
d193 2
d197 3
a199 2
		if (intbits & 0x1) {
			via1itab[bitnum](bitnum); /* run interrupt handler */
d201 2
a202 2
		intbits >>= 1;
	} while (++bitnum != 7 && intbits);
d206 2
a207 1
via2_intr(struct frame *fp)
d209 3
a211 2
	register unsigned char	intbits;
	register char		bitnum;
d213 1
a213 2
	intbits = via2_reg(vIFR);	/* get interrupts pending */
	intbits &= via2_reg(vIER);	/* only care about enabled */
d215 2
a216 1
	if (intbits == 0) return;
a217 3
	/*
	 * Unflag interrupts we're about to process.
	 */
d220 2
d224 1
a224 1
		if (intbits & 0x1)
d226 3
a228 2
		intbits >>= 1;
	} while (++bitnum != 7 && intbits);
d232 2
a233 1
rbv_intr(struct frame *fp)
d235 3
a237 2
	register unsigned char	intbits;
	register char		bitnum, bitmsk;
d241 2
a242 1
	if (intbits == 0) return;
a243 3
	/*
	 * Unflag interrupts we're about to process.
	 */
d246 2
d250 1
a250 1
		if (intbits & 0x1)
d252 3
a254 2
		intbits >>= 1;
	} while (++bitnum != 7 && intbits);
d258 2
a259 1
via1_noint(int bitnum)
d261 1
a261 1
  printf("via1_noint(%d)\n", bitnum);
d265 2
a266 1
via2_noint(void *bitnum)
d268 1
a268 1
  printf("via2_noint(%d)\n", (int) bitnum);
d275 3
a277 3
int	slot;
void	(*func)();
void	*client_data;
d281 8
a288 1
	if (slot < 9 || slot > 15) return 0;
d307 1
a307 1
enable_nubus_intr(void)
d309 1
a309 1
	if (VIA2 == VIA2OFF) {
d311 1
a311 1
	} else {
a312 1
	}
d315 1
d317 2
a318 1
via2_nubus_intr(int bit)
d323 4
a326 4
	via2_reg(vIFR) = V2IF_SLOTINT;
	if (ints = ((~via2_reg(vBufA)) & nubus_intr_mask)) {
		mask = (1 << 5);
		i = 6;
d328 1
a328 1
			if (ints & mask) {
a329 1
			}
d332 1
a332 1
	} else {
a333 1
	}
d337 1
d339 2
a340 1
rbv_nubus_intr(int bit)
d345 4
a348 4
	via2_reg(rIFR) = V2IF_SLOTINT;
	if (ints = ((~via2_reg(rBufA)) & via2_reg(rSlotInt))) {
		mask = (1 << 5);
		i = 6;
d350 1
a350 1
			if (ints & mask) {
a351 1
			}
d354 1
a354 1
	} else {
a355 1
	}
d359 19
a377 2
void
slot_noint(void *client_data, int slot)
a381 1

d385 1
a385 1
	if(VIA2 == VIA2OFF){
d388 1
a388 1
	}else if(VIA2 == RBVOFF){
a389 1
	}
d405 1
a405 1
extern void
d419 1
a419 1
extern void
d433 1
a433 1
extern void
@


1.3
log
@New self-calibrating spin-wait delay() from Scott Reynolds <scottr@@edsi.org>.
@
text
@a86 1
static int	via_inited=0;
a155 1
	via_inited = 1;
@


1.2
log
@Change &= to & in this case.  gcc 2.7.2 vs. 2.4.5 difference?  I hope not.
@
text
@d1 1
a1 1
/*	$NetBSD: via.c,v 1.34 1995/09/28 04:11:18 briggs Exp $	*/
a104 3
	/* Sanity. */
	if(via_inited){printf("WARNING: Initializing VIA's again.\n");return;}

a116 1
	Via2Base = Via1Base + VIA2 * 0x2000;
d381 10
@


1.1
log
@Initial revision
@
text
@d217 1
a217 1
	intbits = (via2_reg(vIFR + rIFR) &= via2_reg(vIER + rIER));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
