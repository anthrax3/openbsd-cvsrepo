head	1.8;
access;
symbols
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.20
	OPENBSD_5_0:1.7.0.18
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.16
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.14
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.10
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.14
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.12
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.10
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.28
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.4.0.26
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.24
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.22
	OPENBSD_2_9_BASE:1.4
	NIKLAS_UNDEAD:1.4.0.20
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.14
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.8
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.7;

1.7
date	2007.04.10.17.14.42;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.13.19.36.47;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.10.20.30.14;	author jsyn;	state Exp;
branches;
next	1.4;

1.4
date	97.04.14.18.48.08;	author gene;	state Exp;
branches
	1.4.14.1
	1.4.26.1;
next	1.3;

1.3
date	97.02.23.06.05.05;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.18.36.32;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.08;	author deraadt;	state Exp;
branches;
next	;

1.4.14.1
date	2003.03.27.23.28.44;	author niklas;	state Exp;
branches;
next	;

1.4.26.1
date	2002.10.29.00.28.05;	author art;	state Exp;
branches;
next	;


desc
@@


1.8
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: pramasm.s,v 1.7 2007/04/10 17:14:42 miod Exp $	*/
/*	$NetBSD: pramasm.s,v 1.4 1995/09/28 03:15:54 briggs Exp $	*/

/*
 * RTC toolkit version 1.08b, copyright 1995, erik vogan
 *
 * All rights and privileges to this code hereby donated
 * to the ALICE group for use in NetBSD.  see the copyright
 * below for more info...
 */
/*
 * Copyright (c) 1995 Erik Vogan
 * All rights reserved.
 *
 * This code is derived from software contributed to the Alice Group
 * by Erik Vogan.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  The following are the C interface functions to RTC access functions
 * that are defined later in this file.
 */

				/* The following routines are the hardware
				 * specific routines for the machines that
				 * use the II-like method to access the PRAM. */

/*
 *  The following are the C interface functions to RTC access functions
 * that are defined later in this file.
 */

	.text

	.even

.globl _getPramTimeII
_getPramTimeII:
	link	a6,#-4		|  create a little home for ourselves
	jbsr	_readClock	|  call the routine to read the time
	unlk	a6		|  clean up after ourselves
	rts			|  and return to caller

.globl _setPramTimeII
_setPramTimeII:
	link	a6,#-4		|  create a little home for ourselves
	movel	a6@@(8),d0	|  get the passed in long (seconds since 1904)
	jbsr	_writeClock	|  call the routine to write the time
	unlk	a6		|  clean up after ourselves
	rts			|  and return to caller

/*
 *  The following are the RTC access functions used by the interface
 * routines, above.
 */

_readClock:
	moveml	#0x7cc0, sp@@-	| store off the regs we need
	moveq	#00,d0		| zero out our result reg
readagan:
	moveq	#00,d5		| and our temp result reg
	moveq	#03,d4		| set our count down reg to 4
	movel	#0x00000081,d1	| read sec byte 0 first
getSecb:
	bsr	_Transfer	| get that byte
	rorl	#8,d5		| shift our time to the right
	swap	d1		| we want to access our new data
	moveb	d1,d5		| move that byte to the spot we vacated
	swap	d1		| return our PRAM command to orig. config
	addqb	#4,d1		| increment to the next sec byte
	dbf	d4,getSecb	| any more bytes to get ?
	cmpl	d5,d0		| same secs value we as we just got ?
	beq	gotTime		| we got a good time value
	movel	d5,d0		| copy our current time to the compare reg
	bra	readagan	| read the time again
gotTime:
	rorl	#8,d0		| make that last shift to correctly order
				|  time bytes!!!
	movel	#0x00d50035,d1	| we have to set the write protect bit
				| so the clock doesn't run down !
	bsr	_Transfer	| (so says Apple...)
	moveml	sp@@+, #0x033e	| restore our regs
	rts			| and return to caller

_writeClock:
	moveml	#0x78c0, sp@@-	| store off the regs we need
	moveq	#03,d4		| set our count down reg to 4
	movel	#0x00550035,d1	| de-write-protect the PRAM
	bsr	_Transfer	| so we can set our value
	moveq	#1,d1		| write sec byte 0 first
putSecb:
	swap	d1		| we want access to data byte of command
	moveb	d0,d1		| set our first secs byte
	swap	d1		| and return command to orig. config
	bsr	_Transfer	| write that byte
	rorl	#8,d0		| shift our time to the right 
	addqb	#4,d1		| increment to the next sec byte
	dbf	d4,putSecb	| any more bytes to put ?
	movel	#0x00d50035,d1	| we have to set the write protect bit
				| so the clock doesn't run down !
	bsr	_Transfer	| (so says Apple...)
	moveml	sp@@+, #0x031e	| restore our regs
	rts			| and return to caller

_Transfer:
	movew	sr,sp@@-		| store the SR (we'll change it!)
	oriw	#0x0700,sr	| disable all interrupts
	moveal	_Via1Base,a1	| move VIA1 addr in reference reg
	moveq	#0,d2		| zero out d2 (it'll hold VIA1 reg B contents)
	moveb	a1@@,d2		| and get VIA1 reg B contents
	andib	#0xF8,d2	| don't touch any but RTC bits
				| (and zero all those)
	movew	d1,d3		| we want to manipulate our command
	andiw	#0xFF00,d3	| zero the LSB
	beq	oldPRAMc	| do an old PRAM style command
xPRAMc:
	rorw	#8,d1		| swap the command bytes (1st byte of 2)
	bsr	writebyte	| and write the command byte
	rorw	#8,d1		| swap the command bytes again (2nd byte of 2)
	bsr	writebyte	| write that byte to RTC too
	moveq	#0x1F,d3	| r/w bit is $F for an extended command
				| (but command is swapped to MSW!! so add $10)
	bra	Rwbrnch		| go figure out if it's a read or a write cmd
oldPRAMc:
	bsr	writebyte	| only one byte for an old PRAM command
	moveq	#0x17,d3	| r/w bit is $7 for and old PRAM command
				| ( command is swapped to MSW, add $10)
Rwbrnch:
	swap	d1		| better get that (data/dummy) byte ready
	btst	d3,d1		| test bit no. d3 of reg d1 (read or write ?)
	beq	Wtrue		| 0 = write, 1 = read (branch on write)
Rtrue:
	bsr	readbyte	| read a byte from the RTC
	bra	Cleanup		| and call mom to clean up after us
Wtrue:
	bsr	writebyte	| write the data to the RTC
Cleanup:
	swap	d1		| move command to LSW again
	bset	#2,a1@@		| bring the RTC enable line high (end of xfer)
	movew	sp@@+,sr		| restore prior interrupt status
	rts			| and return to caller

writebyte:
	moveq	#7,d3		| set our bit counter to 8
wagain:	
	lsrb	#1,d2		| ditch the old data channel value
	roxlb	#1,d1		| and move a new value to X
	roxlb	#1,d2		| now move value from X to data channel
	moveb	d2,a1@@		| set our VIA1 reg B contents to match
	bset	#1,a1@@		| and finish strobing the clock line
	dbf	d3,wagain	| do this until we've sent a whole byte
	lsrb	#1,d2		| ditch the data channel value one last time
	roxlb	#1,d1		| get rid of the extra X bit we've carried
	lslb	#1,d2		| and restore d2 to prior status
	rts			| return to caller

readbyte:
	moveq	#7,d3		| set our bit counter to 8
	bclr	#0,a1@@(0x0400)	| set VIA1 reg B data line to input
ragain:
	bclr	#1,a1@@		| strobe the clock line to make
	bset	#1,a1@@		| the data valid
	moveb	a1@@,d2		| and get out data byte	
	lsrb	#1,d2		| get the data channel value to X
	roxlb	#1,d1		| and move X to data byte
	dbf	d3,ragain	| do this until we've received a whole byte
	bset	#0,a1@@(0x0400)	| and return RTC data line to output
	rts			| return to caller
@


1.7
log
@privledges -> privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: pramasm.s,v 1.6 2006/01/13 19:36:47 miod Exp $	*/
@


1.6
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: pramasm.s,v 1.5 2002/07/10 20:30:14 jsyn Exp $	*/
d7 1
a7 1
 * All rights and privledges to this code hereby donated
@


1.5
log
@'sez' is not an english word; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pramasm.s,v 1.4 1997/04/14 18:48:08 gene Exp $	*/
d50 1
a50 98
#ifdef MRG_ADB		/* These routines are defined at all
                         * if using the MRG_ADB method for accessing
                         * the ADB/PRAM/RTC. */

	.text

	.even
.globl _readPram
_readPram:
	link	a6,#-4		|  create a little home for ourselves
	.word	0xa03f		|  _InitUtil to read PRam
	moveml	d1/a1,sp@@-
	moveq	#0,d0		|  zero out length register
	moveb	a6@@(19),d0	|  move the length byte in
	moveq	#0,d1		|  zero out location 
	moveb	a6@@(15),d1	|  now get out PRam location
	lea	_SysParam,a1	|  start of PRam data
	movel	a6@@(8),a0	|  get our data address
_readPramAgain:
	subql	#1,d0
	bcs	_readPramDone	|  see if we are through
	moveb	a1@@(d1),a0@@+	|  transfer byte
	addql	#1,d1		|  next byte
	jmp	_readPramAgain	|  do it again 
_readPramDone:
	clrw	d0
	moveml	sp@@+,d1/a1
	unlk a6 		|  clean up after ourselves
	rts			|  and return to caller


.globl _writePram
_writePram:
	link	a6,#-4		|  create a little home for ourselves
	.word	0xa03f		|  _InitUtil to read PRam in the case it hasn't been read yet
	moveml	d1/a1,sp@@-
	moveq	#0,d0		|  zero out length register
	moveb	a6@@(19),d0	|  move the length byte in
	moveq	#0,d1		|  zero out location 
	moveb	a6@@(15),d1	|  now get out PRam location
	lea	_SysParam,a1	|  start of PRam data
	movel	a6@@(8),a0	|  get our data address
_writePramAgain:
	subql	#1,d0
	bcs	_writePramDone	|  see if we are through
	cmpil	#0x14,d1	|  check for end of _SysParam
	bcc	_writePramDone	|  do not write if beyond end
	moveb	a0@@+,a1@@(d1)	|  transfer byte
	addql	#1,d1		|  next byte
	jmp	_writePramAgain |  do it again 
_writePramDone:
	.word	0xa038		|  writeParam
	moveml	sp@@+,d1/a1
	unlk a6 		|  clean up after ourselves
	rts			|  and return to caller


.globl _readExtPram
_readExtPram:
	link	a6,#-4		|  create a little home for ourselves
	moveq	#0,d0		|  zero out our future command register
	moveb	a6@@(19),d0	|  move the length byte in
	swap	d0		|  and make that the MSW
	moveb	a6@@(15),d0	|  now get out PRAM location
	movel	a6@@(8),a0	|  get our data address
	.word	0xa051		|  and go read the data
	unlk a6 		|  clean up after ourselves
	rts			|  and return to caller

.globl _writeExtPram
_writeExtPram:
	link	a6,#-4		|  create a little home for ourselves
	moveq	#0,d0		|  zero out our future command register
	moveb	a6@@(19),d0	|  move the length byte in
	swap	d0		|  and make that the MSW
	moveb	a6@@(15),d0	|  now get out PRAM location
	movel	a6@@(8),a0	|  get our data address
	.word	0xa052		|  and go write the data
	unlk a6 		|  clean up after ourselves
	rts			|  and return to caller

.globl _getPramTime
_getPramTime:
	link	a6,#-4		|  create a little home for ourselves
	.word	0xa03f		|  call the routine to read the time (_InitUtil)
	movel	_Time,d0
	unlk	a6		|  clean up after ourselves
	rts			|  and return to caller

.globl _setPramTime
_setPramTime:
	link	a6,#-4		|  create a little home for ourselves
	movel	a6@@(8),d0	|  get the passed in long (seconds since 1904)
	.word	0xa03a		|  call the routine to write the time
	unlk	a6		|  clean up after ourselves
	rts			|  and return to caller

#else				/* The following routines are the hardware
d52 1
a52 3
				 * use the II-like method to access the PRAM,
				 * and are only defined when the MRG_ADB method
				 * isn't used to access the PRAM. */
a61 51
.globl _readPramII
_readPramII:
	link	a6,#-4		|  create a little home for ourselves
	moveq	#0,d0		|  zero out our future command register
	moveb	a6@@(19),d0	|  move the length byte in
	swap	d0		|  and make that the MSW
	moveb	a6@@(15),d0	|  now get out PRAM location
	oriw	#0x0100,d0	|  and set up for non-extended read
	movel	a6@@(8),a0	|  get our data address
	jbsr	_PRAMacc	|  and go read the data
	unlk a6			|  clean up after ourselves
	rts			|  and return to caller

.globl _writePramII
_writePramII:
	link	a6,#-4		|  create a little home for ourselves
	moveq	#0,d0		|  zero out our future command register
	moveb	a6@@(19),d0	|  move the length byte in
	swap	d0		|  and make that the MSW
	moveb	a6@@(15),d0	|  now get out PRAM location
	nop			|  and set up for non-extended write 
	movel	a6@@(8),a0	|  get our data address
	jbsr	_PRAMacc	|  and go write the data
	unlk a6			|  clean up after ourselves
	rts			|  and return to caller

.globl _readExtPramII
_readExtPramII:
	link	a6,#-4		|  create a little home for ourselves
	moveq	#0,d0		|  zero out our future command register
	moveb	a6@@(19),d0	|  move the length byte in
	swap	d0		|  and make that the MSW
	moveb	a6@@(15),d0	|  now get out PRAM location
	oriw	#0x0300,d0	|  and set up for extended read
	movel	a6@@(8),a0	|  get our data address
	jbsr	_PRAMacc	|  and go read the data
	unlk a6			|  clean up after ourselves
	rts			|  and return to caller

.globl _writeExtPramII
_writeExtPramII:
	link	a6,#-4		|  create a little home for ourselves
	moveq	#0,d0		|  zero out our future command register
	moveb	a6@@(19),d0	|  move the length byte in
	swap	d0		|  and make that the MSW
	moveb	a6@@(15),d0	|  now get out PRAM location
	oriw	#0x0200,d0	|  and set up for extended write
	movel	a6@@(8),a0	|  get our data address
	jbsr	_PRAMacc	|  and go write the data
	unlk a6			|  clean up after ourselves
	rts			|  and return to caller
a130 77
_PRAMacc:
	moveml	#0xf8c0, sp@@-	| store off the regs we'll use
	moveq	#00,d3		| zero out our command reg
	moveq	#00,d4		| zero out our count reg too
	swap	d0		| we want the length byte
	movew	d0,d4		| copy length byte to our counter reg
	swap	d0		| and return command reg to prior state
	subqb	#1,d4		| predecrement counter for use w/ DBF
	movew	d0,d2		| copy command to d2
	rorw	#8,d2		| rotate copy to examine flags
	roxrw	#1,d2		| read/write bit out of param.
	roxlb	#1,d3		| and into command reg
	tstb	d3		| was it read (1) or write (0) ?
	bne	NoWrit		| go around de-write protect logic
	movel	#0x00550035,d1	| clear write protect bit of PRAM
				| (we really only need to zero the high
				|  bit, but other patterns don't work! )
	moveml	#0x3000, sp@@-	| store off the regs that'll change
	bsr	_Transfer	| and go de-write protect RTC
	moveml	sp@@+, #0x000c	| reclaim our reg values
NoWrit:
	andib	#1,d2		| isolate the extended command bit
	beq	oldPRAM		| it's zero, so do old PRAM style access
NuPRAM:
	moveb	d0,d2		| reget our PRAM location
	lslw	#4,d3		| insert our template blanks
	moveq	#2,d1		| set bit counter for 3 cycles
threebit:
	roxlb	#1,d2		| rotate address bit from d2
	roxlw	#1,d3		| and into command in d3
	dbf	d1,threebit	| until we've done bits 7-5
	lslw	#1,d3		| and add a bit spacer
	moveq	#4,d1		| ok, 5 bits to go...
fivebit:
	roxlb	#1,d2		| another addr bit out of d2
	roxlw	#1,d3		| and into command template in d3
	dbf	d1,fivebit	| til we've done bit 4-0
	lslw	#2,d3		| more bit magic
	oriw	#0x3880,d3	| set extended command bits
	bra	Loaddata	| go load the rest of command for xfer rtn
oldPRAM:
	moveb	d0,d2		| reget our PRAM location
	lslb	#1,d3		| add a template blank (bit)
	rolb	#4,d2		| get low nibble of PRAM loc ready
	moveq	#3,d1		| set our bit counter for 4 cycles
fourbit:
	roxlb	#1,d2		| bit out of PRAM loc
	roxlb	#1,d3		| and bit into PRAM command
	dbf	d1,fourbit	| until we've done the low nibble
	lslb	#2,d3		| bump bits to type of command byte
	orib	#0x41,d3	| set command bits (for access to $0-F!)
	btst	#4,d2		| change to access $10-13 ?
	beq	Loaddata	| nope, should stay the way it is
	andib	#0x8F,d3	| clear bits 4-6 of current command
	orib	#0x20,d3	| and set bit 5 (now accesses $10-13)
Loaddata:
	moveb	a0@@,d1		| get our (data/dummy) byte into d1
	swap	d1		| move (data/dummy) byte to MSW
	movew	d3,d1		| now move command into d1
tagain:	
	bsr	_Transfer	| now execute that command
	swap	d1		| we want access to (data/dummy) byte
	moveb	d1,a0@@+		| move (data/dummy) byte back to a0,
	moveb	a0@@,d1		| NEXT VICTIM!!
	swap	d1		| now we want to tweak the command
	addqw	#4,d1		| increment our memory addr by 1 (this even 
				| works if we want to dump across 32 byte
				| boundries for an extended command!!!
				| thanks to the oriw #$3880 above !!!)
	dbf	d4,tagain	| repeat until we've got all we want
	movel	#0x00d50035,d1	| remember that command to write the wp byte ?
				| set the high bit in the wp reg (Apple says
				| this way the battery won't wear down !! )
	bsr	_Transfer	| so we'll play by the rules
	moveml	sp@@+, #0x031f	| restore all our registers
	rts			| and return to our gracious caller

a194 3

#endif 				/* ifndef MRG_ADB */

@


1.4
log
@Bring our incarnation of John Wittowski's direct adb driver into compatible
state with NetBSD's.  The direct-to-ADB code is now enabled by default.
Using 'options MRG_ADB' will cause the kernel to revert to the 'old standby'
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pramasm.s,v 1.3 1997/02/23 06:05:05 briggs Exp $	*/
d257 1
a257 1
	bsr	_Transfer	| (so sezs Apple...)
d277 1
a277 1
	bsr	_Transfer	| (so sezs Apple...)
d352 1
a352 1
				| set the high bit in the wp reg (Apple sezs
@


1.4.14.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d257 1
a257 1
	bsr	_Transfer	| (so says Apple...)
d277 1
a277 1
	bsr	_Transfer	| (so says Apple...)
d352 1
a352 1
				| set the high bit in the wp reg (Apple says
@


1.4.26.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pramasm.s,v 1.4 1997/04/14 18:48:08 gene Exp $	*/
d257 1
a257 1
	bsr	_Transfer	| (so says Apple...)
d277 1
a277 1
	bsr	_Transfer	| (so says Apple...)
d352 1
a352 1
				| set the high bit in the wp reg (Apple says
@


1.3
log
@Integrate code from John P. Wittkoski <jpw@@netwizards.net> and
Takashi Hamada <hamada@@next.etron.kanazawa-it.ac.jp>.  This code
interfaces directly to the hardware to support the ADB on many
macs.  It is enabled by "options HWDIRECT" in the configuration
file.  At some point, this should probably become the default method
as interfacing to the ADB through the ROMs has been painful and sometimes
problematic.

This code should have functioning ADB support for:
	II series (II, SE/30, IIx, IIcx)
	IIsi series (IIsi, IIci, IIvx, IIvi)
	LC II, LC III
	Performa 400, 405, 430, 460, 465, 467, 600
	Classic II, Color Classic, Color Classic II
	PB 5XX series
	Duo series
	PB 140,145,145b,160,(160c?),165,165c,170,180,180c
	Quadra 700,900,950
There is an off-chance that it will work on:
	PB 150, PB 190
	Quadra/Centris 605,610,630,650,660AV,800,840AV
	LC 475,550,575,630
	Performa 475,476,575,577,578,630
Note that functioning ADB support does not mean that everything else
will work.  I obviously do not own all of the above machines (does
anyone?  ;-)...  Any reports are welcome.

Many thanks to John Wittkoski and Takashi Hamada!
@
text
@d1 1
a1 1
/*	$OpenBSD: pramasm.s,v 1.2 1996/05/26 18:36:32 briggs Exp $	*/
d50 2
a51 2
#ifndef HWDIRECT	/* These routines are NOT defined at all
                         * if using the HWDIRECT method for accessing
d150 2
a151 2
				 * and are only defined when the HWDIRECT method
				 * is used to access the PRAM. */
d423 1
a423 1
#endif 				/* ifdef HWDIRECT */
@


1.2
log
@Add OpenBSD Id string.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 4
d146 278
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
