head	1.62;
access;
symbols
	OPENBSD_5_1_BASE:1.61
	OPENBSD_5_1:1.61.0.2
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.57.0.4
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.57.0.2
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.56.0.4
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.55.0.4
	OPENBSD_4_5_BASE:1.55
	OPENBSD_4_4:1.55.0.2
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.54.0.4
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.51.0.2
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.50.0.4
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.41.0.6
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	OPENBSD_3_5:1.41.0.4
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.41.0.2
	OPENBSD_3_4_BASE:1.41
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.40.0.2
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	UBC_SYNC_B:1.39
	UBC:1.34.0.2
	UBC_BASE:1.34
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_9_BASE:1.18
	NIKLAS_UNDEAD:1.18.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.16.0.6
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.4
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.14.0.4
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.12.0.4
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.62
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.61;

1.61
date	2011.11.16.20.50.18;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.02.19.57.14;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.08.20.57.19;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.15.13.46.22;	author martin;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.01.09.29.27;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.28.16.38.48;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.30.21.26.17;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.30.21.23.24;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.16.21.46.25;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.13.19.36.47;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.31.15.37.51;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.08.20.35.34;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.06.20.12.24;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.23.03.03.15;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.16.21.11.15;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2002.04.27.01.52.13;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.25.17.15.20;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.14.08.57.05;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.25.15.43.28;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.25.11.37.26;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.27.04.22.38;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.10.01.36.32;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.08.08.09.02;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.08.17.30.41;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.05.21.26.38;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.05.20.56.42;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.10.18.15.39;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.08.10.23.49;	author art;	state Exp;
branches;
next	1.16;

1.16
date	99.09.03.18.01.15;	author art;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	99.01.11.05.11.37;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.03.05.05.06.09;	author gene;	state Exp;
branches;
next	1.13;

1.13
date	98.03.05.05.00.47;	author gene;	state Exp;
branches;
next	1.12;

1.12
date	97.04.23.00.29.17;	author gene;	state Exp;
branches;
next	1.11;

1.11
date	97.04.08.13.55.59;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.04.08.02.53.27;	author gene;	state Exp;
branches;
next	1.9;

1.9
date	97.03.30.21.53.27;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.02.21.05.49.30;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.01.35.53;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	97.01.19.03.58.09;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.10.23.04.49.49;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.18.36.35;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.14.40;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.01.12.16.45.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.09;	author deraadt;	state Exp;
branches;
next	;

1.16.4.1
date	2001.04.18.16.10.11;	author niklas;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2001.07.04.10.18.41;	author niklas;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.16.4.4;

1.16.4.4
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.16.4.5;

1.16.4.5
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.16.4.6;

1.16.4.6
date	2002.03.06.01.05.36;	author niklas;	state Exp;
branches;
next	1.16.4.7;

1.16.4.7
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.16.4.8;

1.16.4.8
date	2003.03.27.23.28.44;	author niklas;	state Exp;
branches;
next	1.16.4.9;

1.16.4.9
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	;

1.34.2.1
date	2002.06.11.03.36.20;	author art;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.10.29.00.28.05;	author art;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.62
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: trap.c,v 1.61 2011/11/16 20:50:18 deraadt Exp $	*/
/*	$NetBSD: trap.c,v 1.68 1998/12/22 08:47:07 scottr Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: trap.c 1.37 92/12/20$
 *
 *	@@(#)trap.c	8.5 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/acct.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/resourcevar.h>
#include <sys/syscall.h>
#include <sys/syslog.h>
#include <sys/user.h>
#ifdef KGDB
#include <sys/kgdb.h>
#endif
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
#ifdef DEBUG
#include <dev/cons.h>
#endif

#include <machine/db_machdep.h>
#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/cpu.h>
#include <machine/reg.h>

#include <m68k/fpe/fpu_emulate.h>

#include "systrace.h"
#include <dev/systrace.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>

int	astpending;

char	*trap_type[] = {
	"Bus error",
	"Address error",
	"Illegal instruction",
	"Zero divide",
	"CHK instruction",
	"TRAPV instruction",
	"Privilege violation",
	"Trace trap",
	"MMU fault",
	"SSIR trap",
	"Format error",
	"68881 exception",
	"Coprocessor violation",
	"Async system trap"
};
int	trap_types = sizeof trap_type / sizeof trap_type[0];

/*
 * Size of various exception stack frames (minus the standard 8 bytes)
 */
short	exframesize[] = {
	FMT0SIZE,	/* type 0 - normal (68020/030/040) */
	FMT1SIZE,	/* type 1 - throwaway (68020/030/040) */
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040) */
	FMT3SIZE,	/* type 3 - FP post-instruction (68040) */
	FMT4SIZE,	/* type 4 - LC040 FP exception (68LC040) */
	-1, -1,		/* type 5-6 - undefined */
	FMT7SIZE,	/* type 7 - access error (68040) */
	58,		/* type 8 - bus fault (68010) */
	FMT9SIZE,	/* type 9 - coprocessor mid-instruction (68020/030) */
	FMTASIZE,	/* type A - short bus fault (68020/030) */
	FMTBSIZE,	/* type B - long bus fault (68020/030) */
	-1, -1, -1, -1	/* type C-F - undefined */
};

#ifdef M68040
#define KDFAULT(c)	(mmutype == MMU_68040 ?			\
			  ((c) & SSW4_TMMASK) == SSW4_TMKD : 	\
			  ((c) & (SSW_DF|SSW_FCMASK)) == (SSW_DF|FC_SUPERD))
#define WRFAULT(c)	(mmutype == MMU_68040 ?		\
			  ((c) & SSW4_RW) == 0 : 	\
			  ((c) & (SSW_DF|SSW_RW)) == SSW_DF)
#else
#define KDFAULT(c)	(((c) & (SSW_DF|SSW_FCMASK)) == (SSW_DF|FC_SUPERD))
#define WRFAULT(c)	(((c) & (SSW_DF|SSW_RW)) == SSW_DF)
#endif

#ifdef DEBUG
int mmudebug = 0;
int mmupid = -1;
#define MDB_FOLLOW	1
#define MDB_WBFOLLOW	2
#define MDB_WBFAILED	4
#define MDB_ISPID(pid)	((pid) == mmupid)
#endif

/* trap() and syscall() only called from locore */
void	trap(int, u_int, u_int, struct frame);
void	syscall(register_t, struct frame);

#if defined(M68040)
int	writeback(struct frame *);
void	wb_userret(struct proc *, struct frame *);
#if DEBUG
static void dumpssw(u_short);
static void dumpwb(int, u_short, u_int, u_int);
#endif
#endif

#ifdef M68040
/*
 * Handle writeback completion on 68040.
 */
void
wb_userret(struct proc *p, struct frame *fp)
{
	/*
	 * Deal with user mode writebacks (from trap, or from sigreturn).
	 * If any writeback fails, go back and attempt signal delivery
	 * unless we have already been here and attempted the writeback
	 * (e.g. bad address with user ignoring SIGSEGV).  In that case,
	 * we just return to the user without successfully completing
	 * the writebacks.  Maybe we should just drop the sucker?
	 */
	if (mmutype == MMU_68040 && fp->f_format == FMT7) {
		int sig;
		union sigval sv;

		if ((sig = writeback(fp)) != 0) {
			sv.sival_ptr = (void *)fp->f_fmt7.f_fa;
			trapsignal(p, sig, T_MMUFLT, SEGV_MAPERR, sv);

			userret(p);
		}
	}
}
#endif

/*
 * Trap is called from locore to handle most types of processor traps,
 * including events such as simulated software interrupts/AST's.
 * System calls are broken out for efficiency.
 */
/*ARGSUSED*/
void
trap(type, code, v, frame)
	int type;
	u_int code;
	u_int v;
	struct frame frame;
{
	struct proc *p;
	int i, s;
	u_int ucode;
	int typ = 0;
	union sigval sv;

	uvmexp.traps++;
	p = curproc;
	ucode = 0;

	/* I have verified that this DOES happen! -gwr */
	if (p == NULL)
		p = &proc0;
#ifdef DIAGNOSTIC
	if (p->p_addr == NULL)
		panic("trap: type 0x%x, code 0x%x, v 0x%x -- no pcb",
			type, code, v);
#endif

	if (USERMODE(frame.f_sr)) {
		type |= T_USER;
		p->p_md.md_regs = frame.f_regs;
	}

	switch (type) {
	default:
dopanic:
		printf("trap type %d, code = 0x%x, v = 0x%x\n", type, code, v);
		printf("%s program counter = 0x%x\n",
		    (type & T_USER) ? "user" : "kernel", frame.f_pc);
		/*
		 * Let the kernel debugger see the trap frame that
		 * caused us to panic.  This is a convenience so
		 * one can see registers at the point of failure.
		 */
		s = splhigh();
#ifdef KGDB
		/* If connected, step or cont returns 1 */
		if (kgdb_trap(type, (db_regs_t *)&frame))
			goto kgdb_cont;
#endif
#ifdef DDB
		(void)kdb_trap(type, (db_regs_t *)&frame);
#endif
#ifdef KGDB
kgdb_cont:
#endif
		splx(s);
		if (panicstr) {
			printf("trap during panic!\n");
#ifdef DEBUG
			/* XXX should be a machine-dependent hook */
			printf("(press a key)\n");
			cnpollc(1); (void)cngetc(); cnpollc(0);
#endif
		}
		regdump(&(frame.F_t), 128);
		type &= ~T_USER;
		if ((u_int)type < trap_types)
			panic(trap_type[type]);
		panic("trap");

	case T_BUSERR:		/* Kernel bus error */
		if (!p->p_addr->u_pcb.pcb_onfault)
			goto dopanic;
		/*
		 * If we have arranged to catch this fault in any of the
		 * copy to/from user space routines, set PC to return to
		 * indicated location and set flag informing buserror code
		 * that it may need to clean up stack frame.
		 */
copyfault:
		frame.f_stackadj = exframesize[frame.f_format];
		frame.f_format = frame.f_vector = 0;
		frame.f_pc = (int)p->p_addr->u_pcb.pcb_onfault;
		return;

	case T_BUSERR|T_USER:	/* Bus error */
		typ = BUS_OBJERR;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;
	case T_ADDRERR|T_USER:	/* Address error */
		typ = BUS_ADRALN;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;

	case T_ILLINST|T_USER:	/* Illegal instruction fault */
		ucode = frame.f_format; /* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_ILLOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;

	case T_PRIVINST|T_USER:	/* Privileged instruction fault */
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_PRVOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;
	/*
	 * divde by zero, CHK/TRAPV inst 
	 */
	case T_ZERODIV|T_USER:		/* Divide by zero trap */
		ucode = frame.f_format;
		typ = FPE_INTDIV;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	case T_CHKINST|T_USER:		/* CHK instruction trap */
		ucode = frame.f_format;
		type = FPE_FLTSUB;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	case T_TRAPVINST|T_USER:	/* TRAPV instruction trap */
		ucode = frame.f_format;
		typ = ILL_ILLTRP;
		i = SIGILL;
		v = frame.f_pc;
                break;
	/* 
	 * User coprocessor violation
	 */
	case T_COPERR|T_USER:
		typ = ILL_COPROC;
		ucode = 0;
		i = SIGILL;
		break;
	/* 
	 * 6888x exceptions 
	 */
	case T_FPERR|T_USER:
		typ = FPE_FLTRES;
		ucode = code;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	/*
	 * FPU faults in supervisor mode.
	 */
	case T_ILLINST:	/* fnop generates this, apparently. */
	case T_FPEMULI:
	case T_FPEMULD: {
		extern label_t *nofault;

		if (nofault)	/* If we're probing. */
			longjmp(nofault);
		if (type == T_ILLINST)
			printf("Kernel Illegal Instruction trap.\n");
		else
			printf("Kernel FPU trap.\n");
		goto dopanic;
	}

	/*
	 * Unimplemented FPU instructions/datatypes.
	 */
	case T_FPEMULI|T_USER:
	case T_FPEMULD|T_USER:
#ifdef FPU_EMULATE
		i = fpu_emulate(&frame, &p->p_addr->u_pcb.pcb_fpregs,
		    &typ);
		/* XXX -- deal with tracing? (frame.f_sr & PSL_T) */
		if (i == 0)
			goto out;
#else
		uprintf("pid %d killed: no floating point support.\n",
			p->p_pid);
		i = SIGILL;
		typ = ILL_COPROC;
#endif
		ucode = frame.f_format;
		v = frame.f_pc;
		break;

	case T_COPERR:		/* Kernel coprocessor violation */
	case T_FMTERR:		/* Kernel format error */
	case T_FMTERR|T_USER:	/* User format error */
		/*
		 * The user has most likely trashed the RTE or FP state info
		 * in the stack frame of a signal handler.
		 */
		printf("pid %d: kernel %s exception\n", p->p_pid,
		    type==T_COPERR ? "coprocessor" : "format");
		type |= T_USER;
		p->p_sigacts->ps_sigact[SIGILL] = SIG_DFL;
		i = sigmask(SIGILL);
		p->p_sigacts->ps_sigignore &= ~i;
		p->p_sigacts->ps_sigcatch &= ~i;
		p->p_sigmask &= ~i;
		i = SIGILL;
		ucode = frame.f_format;	/* XXX was ILL_RESAD_FAULT */
		typ = ILL_COPROC;
		v = frame.f_pc;
		break;

	/*
	 * XXX: Trace traps are a nightmare.
	 *
	 *	HP-UX uses trap #1 for breakpoints,
	 *	OpenBSD/m68k uses trap #2,
	 *	SUN 3.x uses trap #15,
	 *	DDB and KGDB uses trap #15 (for kernel breakpoints;
	 *	handled elsewhere).
	 *
	 * OpenBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
	 * SUN 3.x traps get passed through as T_TRAP15 and are not really
	 * supported yet.
	 *
	 * XXX: We should never get kernel-mode T_TRACE or T_TRAP15
	 * XXX: because locore.s now gives them special treatment.
	 */
	case T_TRAP15:		/* kernel breakpoint */
		frame.f_sr &= ~PSL_T;
		return;

	case T_TRACE|T_USER:	/* user trace trap */
	case T_TRACE:		/* Kernel trace trap */
	case T_TRAP15|T_USER:	/* Sun user trace trap */
		frame.f_sr &= ~PSL_T;
		i = SIGTRAP;
		typ = TRAP_TRACE;
		break;

	case T_ASTFLT:		/* System async trap, cannot happen */
		goto dopanic;

	case T_ASTFLT|T_USER:	/* User async trap. */
		astpending = 0;
		/*
		 * We check for software interrupts first.  This is because
		 * they are at a higher level than ASTs, and on a VAX would
		 * interrupt the AST.  We assume that if we are processing
		 * an AST that we must be at IPL0 so we don't bother to
		 * check.  Note that we ensure that we are at least at SIR
		 * IPL while processing the SIR.
		 */
		splsoft();
		/* FALLTHROUGH */

	case T_SSIR:		/* Software interrupt */
	case T_SSIR|T_USER:
	    {
		int sir, q, mask;

		while ((sir = softpending) != 0) {
			atomic_clearbits_int(&softpending, sir);

			for (q = SI_NQUEUES - 1, mask = 1 << (SI_NQUEUES - 1);
			    mask != 0; q--, mask >>= 1)
				if (mask & sir)
					softintr_dispatch(q);
		}
	    }

		/*
		 * If this was not an AST trap, we are all done.
		 */
		if (type != (T_ASTFLT|T_USER)) {
			uvmexp.traps--;
			return;
		}
		spl0();
		if (p->p_flag & P_OWEUPC) {
			ADDUPROF(p);
		}
		if (type == (T_ASTFLT | T_USER) && want_resched) {
			preempt(NULL);
		}
		goto out;

	case T_MMUFLT:		/* Kernel mode page fault */
	case T_MMUFLT|T_USER:	/* page fault */
	    {
		vaddr_t va;
		struct vmspace *vm = p->p_vmspace;
		struct vm_map *map;
		int rv;
		vm_prot_t ftype, vftype;
		extern struct vm_map *kernel_map;

#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
		printf("trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n",
			p->p_pid, code, v, frame.f_pc, frame.f_sr);
#endif
		/*
		 * It is only a kernel address space fault iff:
		 *	1. (type & T_USER) == 0 and
		 *	2. pcb_onfault not set or
		 *	3. pcb_onfault set but supervisor data fault
		 * The last can occur during an exec() copyin where the
		 * argument space is lazy-allocated.
		 */
		if ((type & T_USER) == 0 &&
		    (!p->p_addr->u_pcb.pcb_onfault || KDFAULT(code)))
			map = kernel_map;
		else
			map = vm ? &vm->vm_map : kernel_map;

		if (WRFAULT(code)) {
			vftype = VM_PROT_WRITE;
			ftype = VM_PROT_READ | VM_PROT_WRITE;
		}
		else
			vftype = ftype = VM_PROT_READ;

		va = trunc_page((vaddr_t)v);

		if (map == kernel_map && va == 0) {
			printf("trap: bad kernel %s access at 0x%x\n",
			    (ftype & VM_PROT_WRITE) ? "read/write" : "read", v);
			goto dopanic;
		}
		rv = uvm_fault(map, va, 0, ftype);
#ifdef DEBUG
		if (rv && MDB_ISPID(p->p_pid))
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x) -> 0x%x\n",
			    map, va, ftype, rv);
#endif
		/*
		 * If this was a stack access, we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure, it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if ((vm != NULL && (caddr_t)va >= vm->vm_maxsaddr)
		    && map != kernel_map) {
			if (rv == 0)
				uvm_grow(p, va);
			else if (rv == EACCES)
				rv = EFAULT;
		}
		if (rv == 0) {
			if (type == T_MMUFLT) {
#if defined(M68040)
				if (mmutype == MMU_68040)
					(void)writeback(&frame);
#endif
				return;
			}
			goto out;
		}
		if (type == T_MMUFLT) {
			if (p->p_addr->u_pcb.pcb_onfault)
				goto copyfault;
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x) -> 0x%x\n",
			    map, va, ftype, rv);
			printf("  type %x, code [mmu,,ssw]: %x\n",
				type, code);
			goto dopanic;
		}
		frame.f_pad = code & 0xffff;
		ucode = vftype;
		typ = SEGV_MAPERR;
		i = SIGSEGV;
		break;
	    }
	}
	sv.sival_ptr = (void *)v;
	trapsignal(p, i, ucode, typ, sv);
out:
	if ((type & T_USER) == 0)
		return;
	userret(p);
#ifdef M68040
	wb_userret(p, &frame);
#endif
}

#if defined(M68040)
#ifdef DEBUG
struct writebackstats {
	int calls;
	int cpushes;
	int move16s;
	int wb1s, wb2s, wb3s;
	int wbsize[4];
} wbstats;

char *f7sz[] = { "longword", "byte", "word", "line" };
char *f7tt[] = { "normal", "MOVE16", "AFC", "ACK" };
char *f7tm[] = { "d-push", "u-data", "u-code", "M-data",
		 "M-code", "k-data", "k-code", "RES" };
char wberrstr[] =
    "WARNING: pid %d(%s) writeback [%s] failed, pc=%x fa=%x wba=%x wbd=%x\n";
#endif

int
writeback(struct frame *fp)
{
	struct fmt7 *f = &fp->f_fmt7;
	struct proc *p = curproc;
	int err = 0;
	u_int fa;
	paddr_t pa;
	caddr_t oonfault = p->p_addr->u_pcb.pcb_onfault;

#ifdef DEBUG
	if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid)) {
		printf(" pid=%d, fa=%x,", p->p_pid, f->f_fa);
		dumpssw(f->f_ssw);
	}
	wbstats.calls++;
#endif
	/*
	 * Deal with special cases first.
	 */
	if ((f->f_ssw & SSW4_TMMASK) == SSW4_TMDCP) {
		/*
		 * Dcache push fault.
		 * Line-align the address and write out the push data to
		 * the indicated physical address.
		 */
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid)) {
			printf(" pushing %s to PA %x, data %x",
				f7sz[(f->f_ssw & SSW4_SZMASK) >> 5],
				f->f_fa, f->f_pd0);
			if ((f->f_ssw & SSW4_SZMASK) == SSW4_SZLN)
				printf("/%x/%x/%x",
					f->f_pd1, f->f_pd2, f->f_pd3);
			printf("\n");
		}
		if (f->f_wb1s & SSW4_WBSV)
			panic("writeback: cache push with WB1S valid");
		wbstats.cpushes++;
#endif
		/*
		 * XXX there are security problems if we attempt to do a
		 * cache push after a signal handler has been called.
		 */
		pmap_kenter_pa((vaddr_t)vmmap,
		    trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE);
		pmap_update(pmap_kernel());
		fa = (u_int)&vmmap[m68k_page_offset(f->f_fa) & ~0x000f];
		bcopy((caddr_t)&f->f_pd0, (caddr_t)fa, 16);
		pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa);
		DCFL(pa);
		pmap_kremove((vaddr_t)vmmap, PAGE_SIZE);
		pmap_update(pmap_kernel());
	} else if ((f->f_ssw & (SSW4_RW|SSW4_TTMASK)) == SSW4_TTM16) {
		/*
		 * MOVE16 fault.
		 * Line-align the address and write out the push data to
		 * the indicated virtual address.
		 */
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			printf(" MOVE16 to VA %x(%x), data %x/%x/%x/%x\n",
			       f->f_fa, f->f_fa & ~0xF, f->f_pd0, f->f_pd1,
			       f->f_pd2, f->f_pd3);
		if (f->f_wb1s & SSW4_WBSV)
			panic("writeback: MOVE16 with WB1S valid");
		wbstats.move16s++;
#endif
		if (KDFAULT(f->f_wb1s))
			bcopy((caddr_t)&f->f_pd0, (caddr_t)(f->f_fa & ~0xF), 16);
		else
			err = suline((caddr_t)(f->f_fa & ~0xF), (caddr_t)&f->f_pd0);
		if (err) {
			fa = f->f_fa & ~0xF;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
				       "MOVE16", fp->f_pc, f->f_fa,
				       f->f_fa & ~0xF, f->f_pd0);
#endif
		}
	} else if (f->f_wb1s & SSW4_WBSV) {
		/*
		 * Writeback #1.
		 * Position the "memory-aligned" data and write it out.
		 */
		u_int wb1d = f->f_wb1d;
		int off;

#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(1, f->f_wb1s, f->f_wb1a, f->f_wb1d);
		wbstats.wb1s++;
		wbstats.wbsize[(f->f_wb2s&SSW4_SZMASK)>>5]++;
#endif
		off = (f->f_wb1a & 3) * 8;
		switch (f->f_wb1s & SSW4_SZMASK) {
		case SSW4_SZLW:
			if (off)
				wb1d = (wb1d >> (32 - off)) | (wb1d << off);
			if (KDFAULT(f->f_wb1s))
				*(long *)f->f_wb1a = wb1d;
			else
				err = copyout(&wb1d, (caddr_t)f->f_wb1a,
						sizeof(int));
			break;
		case SSW4_SZB:
			off = 24 - off;
			if (off)
				wb1d >>= off;
			if (KDFAULT(f->f_wb1s))
				*(char *)f->f_wb1a = wb1d;
			else {
				char tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(char));
			}
			break;
		case SSW4_SZW:
			off = (off + 16) % 32;
			if (off)
				wb1d = (wb1d >> (32 - off)) | (wb1d << off);
			if (KDFAULT(f->f_wb1s))
				*(short *)f->f_wb1a = wb1d;
			else {
				short tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(short));
			}
			break;
		}
		if (err) {
			fa = f->f_wb1a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
				       "#1", fp->f_pc, f->f_fa,
				       f->f_wb1a, f->f_wb1d);
#endif
		}
	}
	/*
	 * Deal with the "normal" writebacks.
	 *
	 * XXX writeback2 is known to reflect a LINE size writeback after
	 * a MOVE16 was already dealt with above.  Ignore it.
	 */
	if (err == 0 && (f->f_wb2s & SSW4_WBSV) &&
	    (f->f_wb2s & SSW4_SZMASK) != SSW4_SZLN) {
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(2, f->f_wb2s, f->f_wb2a, f->f_wb2d);
		wbstats.wb2s++;
		wbstats.wbsize[(f->f_wb2s&SSW4_SZMASK)>>5]++;
#endif
		switch (f->f_wb2s & SSW4_SZMASK) {
		case SSW4_SZLW:
			if (KDFAULT(f->f_wb2s))
				*(long *)f->f_wb2a = f->f_wb2d;
			else
				err = copyout(&f->f_wb2d, (caddr_t)f->f_wb2a,
						sizeof(int));
			break;
		case SSW4_SZB:
			if (KDFAULT(f->f_wb2s))
				*(char *)f->f_wb2a = f->f_wb2d;
			else {
				char tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(char));
			}
			break;
		case SSW4_SZW:
			if (KDFAULT(f->f_wb2s))
				*(short *)f->f_wb2a = f->f_wb2d;
			else {
				short tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(short));
			}
			break;
		}
		if (err) {
			fa = f->f_wb2a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED) {
				printf(wberrstr, p->p_pid, p->p_comm,
				       "#2", fp->f_pc, f->f_fa,
				       f->f_wb2a, f->f_wb2d);
				dumpssw(f->f_ssw);
				dumpwb(2, f->f_wb2s, f->f_wb2a, f->f_wb2d);
			}
#endif
		}
	}
	if (err == 0 && (f->f_wb3s & SSW4_WBSV)) {
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(3, f->f_wb3s, f->f_wb3a, f->f_wb3d);
		wbstats.wb3s++;
		wbstats.wbsize[(f->f_wb3s&SSW4_SZMASK)>>5]++;
#endif
		switch (f->f_wb3s & SSW4_SZMASK) {
		case SSW4_SZLW:
			if (KDFAULT(f->f_wb3s))
				*(long *)f->f_wb3a = f->f_wb3d;
			else
				err = copyout(&f->f_wb3d, (caddr_t)f->f_wb3a,
						sizeof(int));
			break;
		case SSW4_SZB:
			if (KDFAULT(f->f_wb3s))
				*(char *)f->f_wb3a = f->f_wb3d;
			else {
				char tmp = f->f_wb3d;
				
				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(char));
			}
			break;
		case SSW4_SZW:
			if (KDFAULT(f->f_wb3s))
				*(short *)f->f_wb3a = f->f_wb3d;
			else {
				short tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(short));
			}
			break;
#ifdef DEBUG
		case SSW4_SZLN:
			panic("writeback: wb3s indicates LINE write");
#endif
		}
		if (err) {
			fa = f->f_wb3a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
				       "#3", fp->f_pc, f->f_fa,
				       f->f_wb3a, f->f_wb3d);
#endif
		}
	}
	p->p_addr->u_pcb.pcb_onfault = oonfault;
	/*
	 * Any problems are SIGSEGV's
	 */
	if (err)
		err = SIGSEGV;
	return (err);
}

#ifdef DEBUG
void
dumpssw(ssw)
	u_short ssw;
{
	printf(" SSW: %x: ", ssw);
	if (ssw & SSW4_CP)
		printf("CP,");
	if (ssw & SSW4_CU)
		printf("CU,");
	if (ssw & SSW4_CT)
		printf("CT,");
	if (ssw & SSW4_CM)
		printf("CM,");
	if (ssw & SSW4_MA)
		printf("MA,");
	if (ssw & SSW4_ATC)
		printf("ATC,");
	if (ssw & SSW4_LK)
		printf("LK,");
	if (ssw & SSW4_RW)
		printf("RW,");
	printf(" SZ=%s, TT=%s, TM=%s\n",
	       f7sz[(ssw & SSW4_SZMASK) >> 5],
	       f7tt[(ssw & SSW4_TTMASK) >> 3],
	       f7tm[ssw & SSW4_TMMASK]);
}

void
dumpwb(num, s, a, d)
	int num;
	u_short s;
	u_int a, d;
{
	struct proc *p = curproc;
	paddr_t pa;
	int tmp;

	printf(" writeback #%d: VA %x, data %x, SZ=%s, TT=%s, TM=%s\n",
	       num, a, d, f7sz[(s & SSW4_SZMASK) >> 5],
	       f7tt[(s & SSW4_TTMASK) >> 3], f7tm[s & SSW4_TMMASK]);
	printf("               PA ");
	if (pmap_extract(p->p_vmspace->vm_map.pmap, (vaddr_t)a, &pa) == FALSE)
		printf("<invalid address>");
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
	printf("\n");
}
#endif
#endif

/*
 * Process a system call.
 */
void
syscall(code, frame)
	register_t code;
	struct frame frame;
{
	caddr_t params;
	struct sysent *callp;
	struct proc *p;
	int error, opc, nsys;
	size_t argsize;
	register_t args[8], rval[2];

	uvmexp.syscalls++;
	if (!USERMODE(frame.f_sr))
		panic("syscall");
	p = curproc;
	p->p_md.md_regs = frame.f_regs;
	opc = frame.f_pc;

	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;

	params = (caddr_t)frame.f_regs[SP] + sizeof(int);

	switch (code) {
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
		params += sizeof(int);
		/*
		 * XXX sigreturn requires special stack manipulation
		 * that is only done if entered via the sigreturn
		 * trap.  Cannot allow here, so make sure we fail.
		 */
		if (code == SYS_sigreturn)
			code = nsys;
		break;
	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
			break;
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
		params += sizeof(quad_t);
		break;
	default:
		break;
	}
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;		/* illegal */
	else
		callp += code;
	argsize = callp->sy_argsize;
	if (argsize)
		error = copyin(params, (caddr_t)args, argsize);
	else
		error = 0;
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, argsize, args);
#endif
	if (error)
		goto bad;
	rval[0] = 0;
	rval[1] = frame.f_regs[D1];
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
	switch (error) {
	case 0:
		frame.f_regs[D0] = rval[0];
		frame.f_regs[D1] = rval[1];
		frame.f_sr &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/*
		 * We always enter through a `trap' instruction, which is 2
		 * bytes, so adjust the pc by that amount.
		 */
		frame.f_pc = opc - 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
bad:
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		frame.f_regs[D0] = error;
		frame.f_sr |= PSL_C;	/* carry bit */
		break;	
	}

#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
}
@


1.61
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2011/07/05 04:48:01 guenther Exp $	*/
@


1.60
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2011/04/18 21:44:55 guenther Exp $	*/
a147 15
/*
 * Trap and syscall both need the following work done before returning
 * to user mode.
 */
void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	curcpu()->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}

d150 1
a150 1
 * Same as above, but also handles writeback completion on 68040.
a154 8
	int sig;
	union sigval sv;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;

d164 3
d171 1
a171 3
			while ((sig = CURSIG(p)) != 0)
				postsig(sig);
			p->p_priority = p->p_usrpri;
a173 1
	curcpu()->ci_schedstate.spc_curpriority = p->p_priority;
d560 1
a562 2
#else
	userret(p);
@


1.59
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2010/07/02 19:57:14 tedu Exp $	*/
d405 2
a406 2
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
@


1.58
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d405 2
a406 2
		p->p_sigacts->ps_sigignore &= ~i;
		p->p_sigacts->ps_sigcatch &= ~i;
@


1.57
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2009/03/15 20:40:25 miod Exp $	*/
d405 2
a406 2
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
@


1.56
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2008/06/08 20:57:19 miod Exp $	*/
a75 5
#ifdef COMPAT_SUNOS
#include <compat/sunos/sunos_syscall.h>
extern struct emul emul_sunos;
#endif

a434 14
#ifdef COMPAT_SUNOS
		/*
		 * SunOS uses Trap #2 for a "CPU cache flush"
		 * Just flush the on-chip caches and return.
		 * XXX - Too bad OpenBSD uses trap 2...
		 */
		if (p->p_emul == &emul_sunos) {
			ICIA();
			DCIU();
			/* get out fast */
			return;
		}
#endif
		/* FALLTHROUGH */
a945 32
#ifdef COMPAT_SUNOS
	if (p->p_emul == &emul_sunos) {
		/*
		 * SunOS passes the syscall-number on the stack, whereas
		 * BSD passes it in D0. So, we have to get the real "code"
		 * from the stack, and clean up the stack, as SunOS glue
		 * code assumes the kernel pops the syscall argument the
		 * glue pushed on the stack. Sigh...
		 */
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		   sizeof(register_t)) != 0)
			code = -1;

		/*
		 * XXX
		 * Don't do this for sunos_sigreturn, as there's no stored pc
		 * on the stack to skip, the argument follows the syscall
		 * number without a gap.
		 */
		if (code != SUNOS_SYS_sigreturn) {
			frame.f_regs[SP] += sizeof (int);
			/*
			 * remember that we adjusted the SP, 
			 * might have to undo this if the system call
			 * returns ERESTART.
			 */
			p->p_md.md_flags |= MDP_STACKADJ;
		} else
			p->p_md.md_flags &= ~MDP_STACKADJ;
	}
#endif

a1031 5
#endif
#ifdef COMPAT_SUNOS
	/* need new p-value for this */
	if (error == ERESTART && (p->p_md.md_flags & MDP_STACKADJ))
		frame.f_regs[SP] -= sizeof (int);
@


1.55
log
@Make sure to cnpollc(1)/cnpollc(0) around cngetc() or getsn() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2007/05/15 13:46:22 martin Exp $	*/
d479 10
a488 23
		if (ssir & SIR_SERIAL) {
			void zssoft(int);
			siroff(SIR_SERIAL);
			uvmexp.softs++;
			zssoft(0);
		}
		if (ssir & SIR_NET) {
			void netintr(void);
			siroff(SIR_NET);
			uvmexp.softs++;
			netintr();
		}
		if (ssir & SIR_CLOCK) {
			void softclock(void);
			siroff(SIR_CLOCK);
			uvmexp.softs++;
			softclock();
		}
		if (ssir & SIR_ADB) {
			void adb_soft_intr(void);
			siroff(SIR_ADB);
			uvmexp.softs++;
			adb_soft_intr();
d490 2
@


1.54
log
@switch m68k to __HAVE_CPUINFO

help miod@@, art@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2007/04/01 09:29:27 art Exp $	*/
d270 2
a271 1
			printf("(press a key)\n"); (void)cngetc();
@


1.53
log
@Remove some leftovers from the userret cleanups.
No need to save sticks anymore.
miod@@ ok and test
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2007/03/15 10:22:29 art Exp $	*/
d165 1
a165 1
	curpriority = p->p_priority = p->p_usrpri;
d201 1
a201 1
	curpriority = p->p_priority;
@


1.52
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2007/01/28 16:38:48 miod Exp $	*/
a221 1
	u_quad_t sticks;
a238 1
		sticks = p->p_sticks;
d240 1
a240 2
	} else
		sticks = 0;
a963 1
	u_quad_t sticks;
a968 1
	sticks = p->p_sticks;
@


1.51
log
@optimize m68k writeback():
- it can really only be invoked from trap(), not from other userret() callers,
  so it is safe to hardcode its docachepush parameter to 1.
- use pmap_kenter_pa()/pmap_kremove() for the temporary mapping instead of
  pmap_enter()/pmap_remove().

optimize m68k userret():
- define PROC_PC for m68k systems.
- only check want_resched when processing T_ASTFLT traps.
- provide two version of userret(), one which will also invoke writeback()
  on 68040 if required, which is only invoked from trap(), and regular
  userret(). This speeds up system call returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2006/01/30 21:26:17 miod Exp $	*/
a513 1
			p->p_flag &= ~P_OWEUPC;
@


1.50
log
@When delivering SIGFOO, make sure the siginfo code is a FOO_xxx constant;
also deliver SIGILL/ILL_COPROC rather than SIGFPE/FPE_FLTINV for disabled
or missing floating point support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2006/01/30 21:23:24 miod Exp $	*/
d145 2
a146 1
static int	writeback(struct frame *, int);
d158 16
a173 6
userret(p, fp, oticks, faultaddr, fromtrap)
	struct proc *p;
	struct frame *fp;
	u_quad_t oticks;
	u_int faultaddr;
	int fromtrap;
a175 2
#if defined(M68040)
	int beenhere = 0;
a177 2
again:
#endif
a180 1

a182 19
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;
		
		addupc_task(p, fp->f_pc,
		    (int)(p->p_sticks - oticks) * psratio);
	}
#if defined(M68040)
d192 7
a198 14
		if (beenhere) {
#if DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(fromtrap ?
		"pid %d(%s): writeback aborted, pc=%x, fa=%x\n" :
		"pid %d(%s): writeback aborted in sigreturn, pc=%x\n",
				    p->p_pid, p->p_comm, fp->f_pc, faultaddr);
#endif
		} else if ((sig = writeback(fp, fromtrap))) {
			beenhere = 1;
			oticks = p->p_sticks;
			sv.sival_ptr = (void *)faultaddr;
			trapsignal(p, sig, VM_PROT_WRITE, SEGV_MAPERR, sv);
			goto again;
a200 1
#endif
d203 1
d517 3
d589 1
a589 1
					(void)writeback(&frame, 1);
d616 5
a620 1
	userret(p, &frame, sticks, v, 1); 
d642 1
a642 3
writeback(fp, docachepush)
	struct frame *fp;
	int docachepush;
d648 1
d685 9
a693 17
		if (docachepush) {
			paddr_t pa;

			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
				   trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE,
				   VM_PROT_WRITE|PMAP_WIRED);
			pmap_update(pmap_kernel());
			fa = (u_int)&vmmap[m68k_page_offset(f->f_fa) & ~0xF];
			bcopy((caddr_t)&f->f_pd0, (caddr_t)fa, 16);
			pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa);
			DCFL(pa);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
				    (vaddr_t)&vmmap[NBPG]);
			pmap_update(pmap_kernel());
		} else
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
			       p->p_pid, p->p_comm, p->p_ucred->cr_uid);
d1105 1
a1105 1
	userret(p, &frame, sticks, 0, 0);
@


1.49
log
@Better siginfo field values for fpe failures.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2006/01/16 21:46:25 miod Exp $	*/
d368 1
a368 1
		typ = FPE_FLTINV;
d370 1
a370 1
		i = SIGFPE;	/* XXX What is a proper response here? */
a375 10
		/*
		 * We pass along the 68881 status register which locore
		 * stashed in code for us.  Note that there is a
		 * possibility that the bit pattern of this register
		 * will conflict with one of the FPE_* codes defined
		 * in signal.h.  Fortunately for us, the only such
		 * codes we use are all in the range 1-7 and the low
		 * 3 bits of the status register are defined as 0 so
		 * there is no clash.
		 */
@


1.48
log
@Correctly handle successfull FP emulation (doh!)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2006/01/13 19:36:47 miod Exp $	*/
d415 2
a416 1
		i = fpu_emulate(&frame, &p->p_addr->u_pcb.pcb_fpregs);
a419 1
		typ = i == SIGSEGV ? SEGV_MAPERR : ILL_COPROC;
@


1.47
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2006/01/04 20:39:05 miod Exp $	*/
d417 3
d424 2
a426 1
		typ = ILL_COPROC;
a427 1
#endif
@


1.46
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2005/09/12 10:07:29 martin Exp $	*/
a524 6
		}
		if (ssir & SIR_DTMGR) {
			void mrg_execute_deferred(void);
			siroff(SIR_DTMGR);
			uvmexp.softs++;
			mrg_execute_deferred();
@


1.45
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2005/07/31 15:37:51 miod Exp $	*/
d531 6
@


1.44
log
@Fix KDFAULT() in the 68040 & non-68040 compilation case.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2004/12/08 20:35:34 miod Exp $	*/
d713 1
a713 1
			fa = (u_int)&vmmap[(f->f_fa & PGOFSET) & ~0xF];
@


1.43
log
@spl1() -> splsoft(), and minor sync with other m68k trap.c; barely any
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2004/12/06 20:12:24 miod Exp $	*/
d122 1
a122 1
			  ((c) & (SSW_DF|FC_SUPERD)) == (SSW_DF|FC_SUPERD))
@


1.42
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2003/06/02 23:27:49 millert Exp $	*/
d421 3
d503 1
a503 1
		spl1();
d569 1
a569 1
		if (type == T_MMUFLT &&
d574 1
d581 1
d583 1
a583 1
#ifdef DEBUG
d585 2
a586 1
			printf("trap: bad kernel access at %x\n", v);
a588 1
#endif
@


1.41
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2003/01/09 22:27:09 miod Exp $	*/
d599 3
a601 7
			if (rv == 0) {
				u_int nss;

				nss = btoc(USRSTACK-(unsigned)va);
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (rv == EACCES)
d632 1
a634 1
out:
@


1.40
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2002/10/12 01:09:43 krw Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.39
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2002/06/23 03:03:15 deraadt Exp $	*/
a241 1
	extern char fubail[], subail[];
a547 9
		/*
		 * If we were doing profiling ticks or other user mode
		 * stuff from interrupt code, Just Say No.
		 */
		if (p->p_addr->u_pcb.pcb_onfault == fubail ||
		    p->p_addr->u_pcb.pcb_onfault == subail)
			goto copyfault;
		/* fall into... */

d776 2
a777 1
				err = suword((caddr_t)f->f_wb1a, wb1d);
d785 6
a790 2
			else
				err = subyte((caddr_t)f->f_wb1a, wb1d);
d798 6
a803 2
			else
				err = susword((caddr_t)f->f_wb1a, wb1d);
d835 2
a836 1
				err = suword((caddr_t)f->f_wb2a, f->f_wb2d);
d841 6
a846 2
			else
				err = subyte((caddr_t)f->f_wb2a, f->f_wb2d);
d851 6
a856 2
			else
				err = susword((caddr_t)f->f_wb2a, f->f_wb2d);
d884 2
a885 1
				err = suword((caddr_t)f->f_wb3a, f->f_wb3d);
d890 6
a895 2
			else
				err = subyte((caddr_t)f->f_wb3a, f->f_wb3d);
d900 6
a905 2
			else
				err = susword((caddr_t)f->f_wb3a, f->f_wb3d);
d967 1
d975 6
a980 2
	else
		printf("%lx, current value %lx", pa, fuword((caddr_t)a));
d1022 3
a1024 1
		code = fuword((caddr_t)frame.f_regs[SP]);
d1052 2
a1053 1
		code = fuword(params);
d1070 3
a1072 1
		code = fuword(params + _QUAD_LOWWORD * sizeof(int));
@


1.38
log
@uid_t is unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2002/05/16 21:11:15 miod Exp $	*/
d259 1
a259 1
		panic("trap: type 0x%x, code 0x%x, v 0x%x -- no pcb\n",
@


1.37
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2002/04/27 01:52:13 miod Exp $	*/
d734 1
a734 1
			printf("WARNING: pid %d(%s) uid %d: CPUSH not done\n",
@


1.36
log
@Lots of cleanup to catch up with other m68k-based ports and modern code,
including:
- use netisr_dispatch
- extract an allocsys() function from cpu_startup()
- updated cachectl()
- a few fixes in trap()
and more...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2002/03/14 01:26:36 millert Exp $	*/
d74 3
d1071 6
a1076 1
	error = (*callp->sy_call)(p, args, rval);
@


1.35
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2001/12/08 02:24:06 art Exp $	*/
a239 3
#ifdef DDB
	extern char trap0[], trap1[], trap2[], trap12[], trap15[], illinst[];
#endif
a250 7
	if (USERMODE(frame.f_sr)) {
		type |= T_USER;
		sticks = p->p_sticks;
		p->p_md.md_regs = frame.f_regs;
	} else
		sticks = 0;

d260 7
d269 1
a269 1
	dopanic:
d288 1
a288 1
	kgdb_cont;
d355 1
d357 1
d463 1
a463 14
	case T_TRACE:		/* Kernel trace trap */
	case T_TRAP15:		/* SUN trace trap */
#ifdef DDB
		if (type == T_TRAP15 ||
		    ((caddr_t) frame.f_pc != trap0 &&
		     (caddr_t) frame.f_pc != trap1 &&
		     (caddr_t) frame.f_pc != trap2 &&
		     (caddr_t) frame.f_pc != trap12 &&
		     (caddr_t) frame.f_pc != trap15 &&
		     (caddr_t) frame.f_pc != illinst)) {
			if (kdb_trap(type, (db_regs_t *) &frame))
				return;
		}
#endif
d465 1
a465 3
		i = SIGTRAP;
		typ = TRAP_TRACE;
		break;
a467 1
	case T_TRAP15|T_USER:	/* Sun user trace trap */
d481 3
d503 1
a503 1
		/* fall into... */
d645 2
a646 4
	if (i) {
		sv.sival_ptr = (void *)v;
		trapsignal(p, i, ucode, typ, sv);
	}
d671 1
a671 1
static int
d912 1
a912 1
static void
a938 1
static
d1086 1
a1086 1
	bad:
@


1.34
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/11/28 16:13:28 art Exp $	*/
d142 2
a143 2
void	trap __P((int, u_int, u_int, struct frame));
void	syscall __P((register_t, struct frame));
d146 1
a146 1
static int	writeback __P((struct frame *, int));
d148 2
a149 2
static void dumpssw __P((u_short));
static void dumpwb __P((int, u_short, u_int, u_int));
d522 1
a522 1
			void zssoft __P((int));
d528 1
a528 1
			void netintr __P((void));
d534 1
a534 1
			void softclock __P((void));
d540 1
a540 1
			void mrg_execute_deferred __P((void));
@


1.34.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2001/12/08 02:24:06 art Exp $	*/
a73 3
#include "systrace.h"
#include <dev/systrace.h>

d142 2
a143 2
void	trap(int, u_int, u_int, struct frame);
void	syscall(register_t, struct frame);
d146 1
a146 1
static int	writeback(struct frame *, int);
d148 2
a149 2
static void dumpssw(u_short);
static void dumpwb(int, u_short, u_int, u_int);
d240 3
d254 7
a269 7
	if (USERMODE(frame.f_sr)) {
		type |= T_USER;
		sticks = p->p_sticks;
		p->p_md.md_regs = frame.f_regs;
	} else
		sticks = 0;

d272 1
a272 1
dopanic:
d291 1
a291 1
kgdb_cont:
a357 1
		type = FPE_FLTSUB;
a358 1
		v = frame.f_pc;
d464 14
a477 1
	case T_TRAP15:		/* kernel breakpoint */
d479 3
a481 1
		return;
d484 1
a497 3
		/* FALLTHROUGH */
	case T_TRACE:		/* Kernel trace trap */
	case T_TRAP15|T_USER:	/* Sun user trace trap */
d517 1
a517 1
		/* FALLTHROUGH */
d522 1
a522 1
			void zssoft(int);
d528 1
a528 1
			void netintr(void);
d534 1
a534 1
			void softclock(void);
d540 1
a540 1
			void mrg_execute_deferred(void);
d659 4
a662 2
	sv.sival_ptr = (void *)v;
	trapsignal(p, i, ucode, typ, sv);
d687 1
a687 1
int
d928 1
a928 1
void
d955 1
d1085 1
a1085 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
d1103 1
a1103 1
bad:
@


1.34.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34.2.1 2002/06/11 03:36:20 art Exp $	*/
d259 1
a259 1
		panic("trap: type 0x%x, code 0x%x, v 0x%x -- no pcb",
d734 1
a734 1
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
@


1.34.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d242 1
d549 9
d786 1
a786 2
				err = copyout(&wb1d, (caddr_t)f->f_wb1a,
						sizeof(int));
d794 2
a795 6
			else {
				char tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(char));
			}
d803 2
a804 6
			else {
				short tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(short));
			}
d836 1
a836 2
				err = copyout(&f->f_wb2d, (caddr_t)f->f_wb2a,
						sizeof(int));
d841 2
a842 6
			else {
				char tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(char));
			}
d847 2
a848 6
			else {
				short tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(short));
			}
d876 1
a876 2
				err = copyout(&f->f_wb3d, (caddr_t)f->f_wb3a,
						sizeof(int));
d881 2
a882 6
			else {
				char tmp = f->f_wb3d;
				
				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(char));
			}
d887 2
a888 6
			else {
				short tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(short));
			}
a949 1
	int tmp;
d957 2
a958 6
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
d1000 1
a1000 3
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		   sizeof(register_t)) != 0)
			code = -1;
d1028 1
a1028 2
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
d1045 1
a1045 3
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
@


1.33
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2001/11/28 13:47:38 art Exp $	*/
d738 1
d745 1
@


1.32
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/11/25 17:15:20 miod Exp $	*/
d573 1
a573 1
		vm_map_t map;
d576 1
a576 1
		extern vm_map_t kernel_map;
@


1.31
log
@Harmonize userret() prototypes across m68k arches.
XXX The userret() code is not factorized out yet, as this will require
XXX insane amiga cleaning work.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/11/06 19:53:15 miod Exp $	*/
d624 1
a624 1
			if (rv == KERN_SUCCESS) {
d630 2
a631 2
			} else if (rv == KERN_PROTECTION_FAILURE)
				rv = KERN_INVALID_ADDRESS;
d633 1
a633 1
		if (rv == KERN_SUCCESS) {
@


1.30
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/11/06 18:41:10 art Exp $	*/
a144 3
void userret __P((struct proc *p, struct frame *fp, u_quad_t oticks,
	u_int faultaddr, int fromtrap));

d1117 1
a1117 1
	userret(p, &frame, sticks, (u_int)0, 0);
@


1.29
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2001/09/14 08:57:05 art Exp $	*/
a73 3
#include <vm/vm.h>
#include <vm/pmap.h>

d75 1
@


1.28
log
@Simplify userret.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/08/25 15:43:28 miod Exp $	*/
d147 2
a148 2
static inline void userret __P((struct proc *p, struct frame *fp,
	    u_quad_t oticks, u_int faultaddr, int fromtrap));
d162 1
a162 1
static __inline void
a1125 22
#endif
}

void	child_return __P((struct proc *, struct frame));

/*
 * Process the tail end of a fork() for the child.
 */
void
child_return(p, frame)
	struct proc	*p;
	struct frame	frame;
{

	frame.f_regs[D0] = 0;	/* Return value. */
	frame.f_sr &= ~PSL_C;	/* carry bit indicates error */
	frame.f_format = FMT0;

	userret(p, &frame, 0, (u_int)0, 0);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
@


1.27
log
@Post-regdump cleanup.
Gotta run, Beck is behind me with a large axe.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2001/08/25 11:37:26 espie Exp $	*/
d170 1
a170 1
	int sig, s;
d185 1
a185 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we setrunqueue ourselves but before
		 * we switch'ed, we might not be on the queue indicated by
		 * our priority.
d187 1
a187 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.26
log
@One regdump to dump them all...

(moid@@ wants that commit, because it interferes with stuff he's cleaning,
and he's prepared to clean up stuff I may have forgotten, even though this
was tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2001/07/25 13:25:32 art Exp $	*/
d315 1
a315 1
		regdump(&(frame->F_t), 128);
@


1.25
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2001/06/27 04:22:38 art Exp $	*/
d315 1
a315 1
		regdump(&frame, 128);
@


1.24
log
@old vm no more
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2001/06/10 01:36:32 beck Exp $	*/
d751 1
a751 1
				   TRUE, VM_PROT_WRITE);
@


1.23
log
@Semicolons are better added in canada to save cross atlantic bandwith.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2001/06/08 08:09:02 art Exp $	*/
a76 1
#if defined(UVM)
a77 1
#endif
a263 1
#if defined(UVM)
a264 3
#else
	cnt.v_trap++;
#endif
a537 1
#if defined(UVM)
a538 3
#else
			cnt.v_soft++;
#endif
a543 1
#if defined(UVM)
a544 3
#else
			cnt.v_soft++;
#endif
a549 1
#if defined(UVM)
a550 3
#else
			cnt.v_soft++;
#endif
a555 1
#if defined(UVM)
a556 3
#else
			cnt.v_soft++;
#endif
a562 1
#if defined(UVM)
a563 3
#else
			cnt.v_trap--;
#endif
a622 1
#if defined(UVM)
a628 8
#else /* ! UVM */
		rv = vm_fault(map, va, ftype, FALSE);
#ifdef DEBUG
		if (rv && MDB_ISPID(p->p_pid))
			printf("vm_fault(%p, %lx, %x, 0) -> %x\n",
				map, va, ftype, rv);
#endif
#endif /* UVM */
a659 1
#if defined(UVM)
a661 4
#else
			printf("vm_fault(%p, %lx, %x, 0) -> %x\n",
			    map, va, ftype, rv);
#endif
a1005 1
#if defined(UVM)
a1006 3
#else
	cnt.v_syscall++;
#endif
@


1.22
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2001/05/08 17:30:41 aaron Exp $	*/
d794 1
a794 1
			pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa)
@


1.21
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2001/05/05 21:26:38 art Exp $	*/
d787 2
d794 2
a795 1
			DCFL(pmap_extract(pmap_kernel(), (vaddr_t)fa));
d1021 1
a1021 2
	pa = pmap_extract(p->p_vmspace->vm_map.pmap, (vaddr_t)a);
	if (pa == 0)
@


1.20
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.19 2001/05/05 20:56:42 art Exp $	*/
/*	$NetBSD: trap.c,v 1.46 1997/04/07 22:54:44 scottr Exp $	*/
d56 3
d62 3
d77 4
d86 2
d114 2
a115 1
	-1, -1, -1,	/* type 4-6 - undefined */
d146 1
a146 1
void	trap __P((int, unsigned, unsigned, struct frame));
d251 2
a252 2
	unsigned code;
	unsigned v;
d260 1
a260 1
	int i;
d266 3
d270 1
d286 1
a286 1
		panic("trap: type 0x%x, code 0x%x, v 0x%x--no pcb",
d292 15
a306 2
dopanic:
		printf("trap type %d, code = %x, v= %x\n", type, code, v);
d308 11
a318 2
		if (kdb_trap(type, (db_regs_t *) &frame))
			return;
d320 1
d323 1
a323 1
		if ((unsigned)type < trap_types)
d339 1
a339 1
		frame.f_pc = (int) p->p_addr->u_pcb.pcb_onfault;
d354 1
a354 1
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
d371 1
a371 1
		type = FPE_INTDIV;
a377 1
		type = FPE_FLTSUB;
a378 1
		v = frame.f_pc;
d383 1
a383 1
		type = ILL_ILLTRP;
d386 1
a386 2
		break;

d421 1
a421 1
		extern int	*nofault;
d424 1
a424 1
			longjmp((label_t *) nofault);
a444 2
		typ = FPE_FLTINV;
		v = frame.f_pc;
d469 1
a469 1
	 * Trace traps.
d471 5
a475 3
	 * M68k *BSD uses trap #2,
	 * SUN 3.x uses trap #15,
	 * KGDB uses trap #15 (for kernel breakpoints; handled elsewhere).
d477 1
a477 1
	 * M68k *BSD traps get mapped by locore.s into T_TRACE.
d480 3
d509 1
a509 1
		 * XXX - Too bad m68k BSD uses trap 2...
d544 3
d548 1
d554 3
d558 1
d564 3
d568 1
d574 3
d578 1
d585 3
d589 1
d611 1
a611 1
		vm_offset_t va;
d639 2
a640 1
		} else
d642 1
a642 1
		va = trunc_page((vm_offset_t) v);
d649 8
d663 1
d674 1
a674 1
				unsigned nss;
d686 1
a686 1
					(void) writeback(&frame, 1);
d695 7
a701 2
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
				(unsigned) map, (unsigned) va, ftype, rv);
d787 3
a789 3
			pmap_enter(pmap_kernel(), (vm_offset_t)vmmap,
				   trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE, TRUE,
				   VM_PROT_WRITE);
d792 3
a794 3
			DCFL(pmap_extract(pmap_kernel(), (vm_offset_t)fa));
			pmap_remove(pmap_kernel(), (vm_offset_t)vmmap,
				    (vm_offset_t)&vmmap[NBPG]);
d973 1
a973 1
	return(err);
d1012 1
a1012 1
	vm_offset_t pa;
d1018 1
a1018 1
	pa = pmap_extract(p->p_vmspace->vm_map.pmap, (vm_offset_t)a);
d1044 3
d1048 1
@


1.19
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2000/11/10 18:15:39 art Exp $	*/
d713 1
a713 1
				   trunc_page(f->f_fa), VM_PROT_WRITE, TRUE,
@


1.18
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2000/06/08 10:23:49 art Exp $	*/
d606 1
a606 1
				nss = clrnd(btoc(USRSTACK-(unsigned)va));
@


1.17
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 1999/09/03 18:01:15 art Exp $	*/
d1054 1
a1054 1
		ktrsyscall(p->p_tracep, code, argsize, args);
d1097 1
a1097 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d1119 1
a1119 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.16
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1999/01/11 05:11:37 millert Exp $	*/
d943 1
a943 1
	pa = pmap_extract(&p->p_vmspace->vm_pmap, (vm_offset_t)a);
@


1.16.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2000/11/10 18:15:39 art Exp $	*/
d943 1
a943 1
	pa = pmap_extract(p->p_vmspace->vm_map.pmap, (vm_offset_t)a);
d1054 1
a1054 1
		ktrsyscall(p, code, argsize, args);
d1097 1
a1097 1
		ktrsysret(p, code, error, rval[0]);
d1119 1
a1119 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.16.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: trap.c,v 1.68 1998/12/22 08:47:07 scottr Exp $	*/
a55 3
#ifdef KGDB
#include <sys/kgdb.h>
#endif
a58 3
#ifdef DEBUG
#include <dev/cons.h>
#endif
a70 2
#include <uvm/uvm_extern.h>

a75 2
int	astpending;

d102 1
a102 2
	FMT4SIZE,	/* type 4 - LC040 FP exception (68LC040) */
	-1, -1,		/* type 5-6 - undefined */
d133 1
a133 1
void	trap __P((int, u_int, u_int, struct frame));
d238 2
a239 2
	u_int code;
	u_int v;
d247 1
a247 1
	int i, s;
d253 1
a253 1
	uvmexp.traps++;
d269 1
a269 1
		panic("trap: type 0x%x, code 0x%x, v 0x%x -- no pcb\n",
d275 2
a276 15
	dopanic:
		printf("trap type %d, code = 0x%x, v = 0x%x\n", type, code, v);
		printf("%s program counter = 0x%x\n",
		    (type & T_USER) ? "user" : "kernel", frame.f_pc);
		/*
		 * Let the kernel debugger see the trap frame that
		 * caused us to panic.  This is a convenience so
		 * one can see registers at the point of failure.
		 */
		s = splhigh();
#ifdef KGDB
		/* If connected, step or cont returns 1 */
		if (kgdb_trap(type, (db_regs_t *)&frame))
			goto kgdb_cont;
#endif
d278 2
a279 11
		(void)kdb_trap(type, (db_regs_t *)&frame);
#endif
#ifdef KGDB
	kgdb_cont;
#endif
		splx(s);
		if (panicstr) {
			printf("trap during panic!\n");
#ifdef DEBUG
			/* XXX should be a machine-dependent hook */
			printf("(press a key)\n"); (void)cngetc();
a280 1
		}
d283 1
a283 1
		if ((u_int)type < trap_types)
d299 1
a299 1
		frame.f_pc = (int)p->p_addr->u_pcb.pcb_onfault;
d314 1
a314 1
		ucode = frame.f_format; /* XXX was ILL_PRIVIN_FAULT */
d331 1
a331 1
		typ = FPE_INTDIV;
d338 1
d340 1
d345 1
a345 1
		typ = ILL_ILLTRP;
d348 2
a349 1
                break;
d384 1
a384 1
		extern label_t *nofault;
d387 1
a387 1
			longjmp(nofault);
d408 2
d434 1
a434 1
	 * XXX: Trace traps are a nightmare.
d436 3
a438 5
	 *	HP-UX uses trap #1 for breakpoints,
	 *	OpenBSD/m68k uses trap #2,
	 *	SUN 3.x uses trap #15,
	 *	DDB and KGDB uses trap #15 (for kernel breakpoints;
	 *	handled elsewhere).
d440 1
a440 1
	 * OpenBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
a442 3
	 *
	 * XXX: We should never get kernel-mode T_TRACE or T_TRAP15
	 * XXX: because locore.s now gives them special treatment.
d469 1
a469 1
		 * XXX - Too bad OpenBSD uses trap 2...
d504 1
a504 1
			uvmexp.softs++;
d510 1
a510 1
			uvmexp.softs++;
d516 1
a516 1
			uvmexp.softs++;
d522 1
a522 1
			uvmexp.softs++;
d529 1
a529 1
			uvmexp.traps--;
d551 1
a551 1
		vaddr_t va;
d579 1
a579 2
		}
		else
d581 1
a581 1
		va = trunc_page((vaddr_t)v);
d588 1
a588 1
		rv = uvm_fault(map, va, 0, ftype);
d591 2
a592 2
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x) -> 0x%x\n",
			    map, va, ftype, rv);
d604 1
a604 1
				u_int nss;
d606 1
a606 1
				nss = btoc(USRSTACK-(unsigned)va);
d616 1
a616 1
					(void)writeback(&frame, 1);
d625 2
a626 2
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x) -> 0x%x\n",
			    map, va, ftype, rv);
d712 3
a714 5
			paddr_t pa;

			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
				   trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE,
				   TRUE, VM_PROT_WRITE);
d717 3
a719 4
			pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa);
			DCFL(pa);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
				    (vaddr_t)&vmmap[NBPG]);
d898 1
a898 1
	return (err);
d937 1
a937 1
	paddr_t pa;
d943 2
a944 1
	if (pmap_extract(p->p_vmspace->vm_map.pmap, (vaddr_t)a, &pa) == FALSE)
d969 1
a969 1
	uvmexp.syscalls++;
@


1.16.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.4.2 2001/07/04 10:18:41 niklas Exp $	*/
d170 1
a170 1
	int sig;
d185 12
a196 3
		 * We're being preempted.
		 */
		preempt(NULL);
d315 1
a315 1
		regdump(&(frame.F_t), 128);
d751 1
a751 1
				   VM_PROT_WRITE|PMAP_WIRED);
@


1.16.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 3
a77 1
#include <uvm/uvm_pmap.h>
d147 2
a148 2
void userret __P((struct proc *p, struct frame *fp, u_quad_t oticks,
	u_int faultaddr, int fromtrap));
d162 1
a162 1
void
d1126 22
@


1.16.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.4.4 2001/11/13 21:00:53 niklas Exp $	*/
d145 3
d576 1
a576 1
		struct vm_map *map;
d579 1
a579 1
		extern struct vm_map *kernel_map;
d627 1
a627 1
			if (rv == 0) {
d633 2
a634 2
			} else if (rv == EACCES)
				rv = EFAULT;
d636 1
a636 1
		if (rv == 0) {
d1120 1
a1120 1
	userret(p, &frame, sticks, 0, 0);
@


1.16.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a737 1
			pmap_update(pmap_kernel());
a743 1
			pmap_update(pmap_kernel());
@


1.16.4.7
log
@Merge in -current from about a week ago
@
text
@d142 2
a143 2
void	trap(int, u_int, u_int, struct frame);
void	syscall(register_t, struct frame);
d146 1
a146 1
static int	writeback(struct frame *, int);
d148 2
a149 2
static void dumpssw(u_short);
static void dumpwb(int, u_short, u_int, u_int);
d522 1
a522 1
			void zssoft(int);
d528 1
a528 1
			void netintr(void);
d534 1
a534 1
			void softclock(void);
d540 1
a540 1
			void mrg_execute_deferred(void);
@


1.16.4.8
log
@Sync the SMP branch with 3.3
@
text
@a73 3
#include "systrace.h"
#include <dev/systrace.h>

d239 4
d254 7
d266 1
a266 1
		panic("trap: type 0x%x, code 0x%x, v 0x%x -- no pcb",
a269 7
	if (USERMODE(frame.f_sr)) {
		type |= T_USER;
		sticks = p->p_sticks;
		p->p_md.md_regs = frame.f_regs;
	} else
		sticks = 0;

d272 1
a272 1
dopanic:
d291 1
a291 1
kgdb_cont:
a357 1
		type = FPE_FLTSUB;
a358 1
		v = frame.f_pc;
d464 14
a477 1
	case T_TRAP15:		/* kernel breakpoint */
d479 3
a481 1
		return;
d484 1
a497 3
		/* FALLTHROUGH */
	case T_TRACE:		/* Kernel trace trap */
	case T_TRAP15|T_USER:	/* Sun user trace trap */
d517 1
a517 1
		/* FALLTHROUGH */
d560 9
d659 4
a662 2
	sv.sival_ptr = (void *)v;
	trapsignal(p, i, ucode, typ, sv);
d687 1
a687 1
int
d747 1
a747 1
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
d799 1
a799 2
				err = copyout(&wb1d, (caddr_t)f->f_wb1a,
						sizeof(int));
d807 2
a808 6
			else {
				char tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(char));
			}
d816 2
a817 6
			else {
				short tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(short));
			}
d849 1
a849 2
				err = copyout(&f->f_wb2d, (caddr_t)f->f_wb2a,
						sizeof(int));
d854 2
a855 6
			else {
				char tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(char));
			}
d860 2
a861 6
			else {
				short tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(short));
			}
d889 1
a889 2
				err = copyout(&f->f_wb3d, (caddr_t)f->f_wb3a,
						sizeof(int));
d894 2
a895 6
			else {
				char tmp = f->f_wb3d;
				
				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(char));
			}
d900 2
a901 6
			else {
				short tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(short));
			}
d928 1
a928 1
void
d955 1
a963 1
	int tmp;
d971 2
a972 6
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
d1014 1
a1014 3
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		   sizeof(register_t)) != 0)
			code = -1;
d1042 1
a1042 2
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
d1059 1
a1059 3
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
d1085 1
a1085 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
d1103 1
a1103 1
bad:
@


1.16.4.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.4.8 2003/03/27 23:28:44 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.15
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1998/03/05 05:06:09 gene Exp $	*/
d713 2
a714 1
				   trunc_page(f->f_fa), VM_PROT_WRITE, TRUE);
@


1.14
log
@Completely deprecate register.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1998/03/05 05:00:47 gene Exp $	*/
d269 1
a269 1
		panic("trap: type 0x%x, code 0x%x, v 0x%x--no pcb\n",
@


1.13
log
@Fix fallout from gcc 2.8 - use trapsignal() correctly with a real union.
As long as I'm here, deprecate some register's and do some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1997/04/23 00:29:17 gene Exp $	*/
d133 1
a133 1
void	trap __P((int, unsigned, register unsigned, struct frame));
d142 1
a142 1
static void dumpssw __P((register u_short));
d671 2
a672 2
	register struct fmt7 *f = &fp->f_fmt7;
	register struct proc *p = curproc;
d755 2
a756 2
		register u_int wb1d = f->f_wb1d;
		register int off;
d903 1
a903 1
	register u_short ssw;
d935 1
a935 1
	register struct proc *p = curproc;
d960 3
a962 3
	register caddr_t params;
	register struct sysent *callp;
	register struct proc *p;
@


1.12
log
@NetBSD -> OpenBSD where relevant and appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1997/04/08 13:55:59 briggs Exp $	*/
d153 2
a154 2
	register struct proc *p;
	register struct frame *fp;
d162 1
d220 2
a221 2
			trapsignal(p, sig, VM_PROT_WRITE, SEGV_MAPERR,
					(caddr_t)faultaddr);
d239 1
a239 1
	register unsigned v;
d246 2
a247 2
	register struct proc *p;
	register int i;
d251 1
d436 1
a436 1
	 * M68k OpenBSD uses trap #2,
d440 1
a440 1
	 * M68k OpenBSD traps get mapped by locore.s into T_TRACE.
d551 3
a553 3
		register vm_offset_t va;
		register struct vmspace *vm = p->p_vmspace;
		register vm_map_t map;
d638 4
a641 2
	if (i)
		trapsignal(p, i, ucode, typ, (caddr_t) v);
@


1.11
log
@Clarify comment a bit and skip userret when flushing CPU caches in SunOS emul.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1997/04/08 02:53:27 gene Exp $	*/
d434 1
a434 1
	 * M68k NetBSD uses trap #2,
d438 1
a438 1
	 * M68k NetBSD traps get mapped by locore.s into T_TRACE.
@


1.10
log
@From scottr@@netbsd.org:
>Fix SunOS user trace trap handling, from Gordon.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1997/03/30 21:53:27 briggs Exp $	*/
d467 1
a467 1
		 * XXX - Too bad NetBSD uses trap 2...
d473 1
a473 1
			goto done;
@


1.9
log
@An implementation of pieces of the Deferred Task Manager--required by
some video cards.  Provided by Paul Goyette <paul@@pgoyette.bdt.com>.
This introduces another simulated software interrupt.
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.8 1997/02/21 05:49:30 briggs Exp $	*/
/*	$NetBSD: trap.c,v 1.45 1997/01/20 04:30:05 scottr Exp $	*/
d465 3
a467 4
		 * XXX This comment/code is not consistent XXX
		 * SunOS seems to use Trap #2 for some obscure 
		 * fpu operations.  So far, just ignore it, but
		 * DONT trap on it.. 
d469 6
a474 2
		if (p->p_emul == &emul_sunos)
			goto out;
@


1.8
log
@Bring in siginfo changes from mvme68k port & Theo.  Compiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1997/01/24 01:35:53 briggs Exp $	*/
d513 6
@


1.7
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1997/01/19 03:58:09 briggs Exp $	*/
d219 2
a220 1
			trapsignal(p, sig, faultaddr);
d248 1
d301 4
d306 2
a307 1
		ucode = v;
d312 6
d320 1
d322 1
d328 6
d335 6
d343 3
a345 1
		i = SIGFPE;
d352 1
d370 1
d373 1
d406 2
d427 2
d458 1
d475 1
d544 1
a544 1
		vm_prot_t ftype;
d565 2
a566 1
		if (WRFAULT(code))
d568 2
a569 2
		else
			ftype = VM_PROT_READ;
d620 3
a622 1
		ucode = v;
d628 1
a628 1
		trapsignal(p, i, ucode);
@


1.6
log
@asm -> __asm, inline -> __inline
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.5 1996/10/23 04:49:49 briggs Exp $	*/
/*	$NetBSD: trap.c,v 1.41 1996/10/17 06:42:44 scottr Exp $	*/
d136 2
a137 3
static __inline void userret __P((register struct proc *,
				register struct frame *,
				u_quad_t, u_int, int));
d142 2
a143 1
static int	dumpssw __P((register u_short));
d196 1
a196 1
				(int)(p->p_sticks - oticks) * psratio);
d257 2
a258 1
	}
d265 2
a266 1
		panic("trap: no pcb");
d433 2
a434 4
		if (p->p_emul == &emul_sunos) {
			userret(p, &frame, sticks, v, 1); 
			return;
		}
d541 1
a541 1
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
d586 2
a587 1
	if (i) trapsignal(p, i, ucode);
d847 1
a847 1
static int
d874 2
a875 1
int
d892 1
a892 1
		printf("%x, current value %x", pa, fuword((caddr_t)a));
@


1.5
log
@Sync up with NetBSD and include patch from Dave Huang <khym@@bga.com>
that puts AV I/O in the right place.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 1996/05/26 18:36:35 briggs Exp $	*/
d136 1
a136 1
static inline void userret __P((register struct proc *,
d151 1
a151 1
static inline void
@


1.4
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: trap.c,v 1.37 1996/05/05 06:54:23 briggs Exp $	*/
d129 1
a129 1
#define MDB_ISPID(p)	(p) == mmupid
d259 8
d526 1
a526 1
			map = &vm->vm_map;
d551 2
a552 1
		if ((caddr_t)va >= vm->vm_maxsaddr && map != kernel_map) {
@


1.3
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.2
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.32.2.2 1995/10/15 03:49:49 briggs Exp $	*/
d59 1
d65 2
d131 15
d215 1
a215 1
		} else if (sig = writeback(fp, fromtrap)) {
d232 1
d245 1
a245 1
	u_int ncode, ucode;
a246 1
	int s;
d263 1
a263 1
		if (kdb_trap(type, &frame))
d405 1
a405 1
			if (kdb_trap(type, &frame))
d450 1
d456 1
d462 1
d566 1
a566 1
				map, va, ftype, rv);
d601 1
d836 1
d863 1
d889 1
d1033 2
@


1.1
log
@Initial revision
@
text
@d551 1
a551 1
		i = (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV;
d806 1
a806 4
	 * Determine the cause of the failure if any translating to
	 * a signal.  If the corresponding VA is valid and RO it is
	 * a protection fault (SIGBUS) otherwise consider it an
	 * illegal reference (SIGSEGV).
d808 2
a809 11
	if (err) {
		if (vm_map_check_protection(&p->p_vmspace->vm_map,	
					    trunc_page(fa), round_page(fa),
					    VM_PROT_READ) &&
		    !vm_map_check_protection(&p->p_vmspace->vm_map,
					     trunc_page(fa), round_page(fa),
					     VM_PROT_WRITE))
			err = SIGBUS;
		else
			err = SIGSEGV;
	}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

