head	1.160;
access;
symbols
	OPENBSD_5_1_BASE:1.159
	OPENBSD_5_1:1.159.0.4
	OPENBSD_5_0:1.159.0.2
	OPENBSD_5_0_BASE:1.159
	OPENBSD_4_9:1.156.0.2
	OPENBSD_4_9_BASE:1.156
	OPENBSD_4_8:1.155.0.2
	OPENBSD_4_8_BASE:1.155
	OPENBSD_4_7:1.153.0.2
	OPENBSD_4_7_BASE:1.153
	OPENBSD_4_6:1.149.0.4
	OPENBSD_4_6_BASE:1.149
	OPENBSD_4_5:1.147.0.2
	OPENBSD_4_5_BASE:1.147
	OPENBSD_4_4:1.146.0.2
	OPENBSD_4_4_BASE:1.146
	OPENBSD_4_3:1.143.0.2
	OPENBSD_4_3_BASE:1.143
	OPENBSD_4_2:1.142.0.2
	OPENBSD_4_2_BASE:1.142
	OPENBSD_4_1:1.135.0.2
	OPENBSD_4_1_BASE:1.135
	OPENBSD_4_0:1.133.0.2
	OPENBSD_4_0_BASE:1.133
	OPENBSD_3_9:1.130.0.2
	OPENBSD_3_9_BASE:1.130
	OPENBSD_3_8:1.118.0.2
	OPENBSD_3_8_BASE:1.118
	OPENBSD_3_7:1.116.0.2
	OPENBSD_3_7_BASE:1.116
	OPENBSD_3_6:1.112.0.4
	OPENBSD_3_6_BASE:1.112
	SMP_SYNC_A:1.112
	SMP_SYNC_B:1.112
	OPENBSD_3_5:1.112.0.2
	OPENBSD_3_5_BASE:1.112
	OPENBSD_3_4:1.107.0.2
	OPENBSD_3_4_BASE:1.107
	UBC_SYNC_A:1.106
	OPENBSD_3_3:1.104.0.2
	OPENBSD_3_3_BASE:1.104
	OPENBSD_3_2:1.100.0.2
	OPENBSD_3_2_BASE:1.100
	OPENBSD_3_1:1.97.0.2
	OPENBSD_3_1_BASE:1.97
	UBC_SYNC_B:1.100
	UBC:1.91.0.2
	UBC_BASE:1.91
	OPENBSD_3_0:1.83.0.2
	OPENBSD_3_0_BASE:1.83
	OPENBSD_2_9:1.67.0.8
	OPENBSD_2_9_BASE:1.67
	NIKLAS_UNDEAD:1.67.0.6
	OPENBSD_2_8:1.67.0.4
	OPENBSD_2_8_BASE:1.67
	OPENBSD_2_7:1.67.0.2
	OPENBSD_2_7_BASE:1.67
	SMP:1.64.0.2
	SMP_BASE:1.64
	kame_19991208:1.64
	OPENBSD_2_6:1.63.0.2
	OPENBSD_2_6_BASE:1.63
	OPENBSD_2_5:1.56.0.2
	OPENBSD_2_5_BASE:1.56
	OPENBSD_2_4:1.53.0.2
	OPENBSD_2_4_BASE:1.53
	OPENBSD_2_3:1.50.0.2
	OPENBSD_2_3_BASE:1.50
	OPENBSD_2_2:1.45.0.2
	OPENBSD_2_2_BASE:1.45
	OPENBSD_2_1:1.42.0.2
	OPENBSD_2_1_BASE:1.42
	OPENBSD_2_0:1.19.0.2
	OPENBSD_2_0_BASE:1.19
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.160
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.159;

1.159
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.158;

1.158
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.157;

1.157
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.156;

1.156
date	2010.11.20.20.29.09;	author miod;	state Exp;
branches;
next	1.155;

1.155
date	2010.07.02.19.57.14;	author tedu;	state Exp;
branches;
next	1.154;

1.154
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.153;

1.153
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.152;

1.152
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.151;

1.151
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.150;

1.150
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.149;

1.149
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.148;

1.148
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.147;

1.147
date	2008.11.09.12.34.47;	author tobias;	state Exp;
branches;
next	1.146;

1.146
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.145;

1.145
date	2008.06.08.20.57.18;	author miod;	state Exp;
branches;
next	1.144;

1.144
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.143;

1.143
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.142;

1.142
date	2007.07.29.21.24.05;	author miod;	state Exp;
branches;
next	1.141;

1.141
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.140;

1.140
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2007.05.27.17.31.56;	author miod;	state Exp;
branches;
next	1.138;

1.138
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.137;

1.137
date	2007.05.23.20.33.46;	author pvalchev;	state Exp;
branches;
next	1.136;

1.136
date	2007.03.17.20.05.22;	author miod;	state Exp;
branches;
next	1.135;

1.135
date	2007.03.03.21.21.25;	author miod;	state Exp;
branches;
next	1.134;

1.134
date	2006.09.22.22.15.19;	author miod;	state Exp;
branches;
next	1.133;

1.133
date	2006.06.11.20.49.27;	author miod;	state Exp;
branches;
next	1.132;

1.132
date	2006.06.11.20.48.13;	author miod;	state Exp;
branches;
next	1.131;

1.131
date	2006.05.19.22.51.09;	author miod;	state Exp;
branches;
next	1.130;

1.130
date	2006.01.24.06.50.13;	author miod;	state Exp;
branches;
next	1.129;

1.129
date	2006.01.22.15.24.29;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2006.01.22.13.53.16;	author miod;	state Exp;
branches;
next	1.127;

1.127
date	2006.01.13.21.04.36;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2006.01.13.21.01.31;	author miod;	state Exp;
branches;
next	1.125;

1.125
date	2006.01.13.19.36.46;	author miod;	state Exp;
branches;
next	1.124;

1.124
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	1.123;

1.123
date	2006.01.01.13.16.01;	author miod;	state Exp;
branches;
next	1.122;

1.122
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2005.11.15.07.02.36;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2005.11.06.17.59.57;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2005.09.27.21.50.39;	author miod;	state Exp;
branches;
next	1.118;

1.118
date	2005.08.06.19.51.44;	author martin;	state Exp;
branches;
next	1.117;

1.117
date	2005.07.23.23.30.56;	author martin;	state Exp;
branches;
next	1.116;

1.116
date	2005.01.11.21.07.19;	author martin;	state Exp;
branches;
next	1.115;

1.115
date	2004.12.02.22.00.31;	author martin;	state Exp;
branches;
next	1.114;

1.114
date	2004.12.02.19.37.25;	author miod;	state Exp;
branches;
next	1.113;

1.113
date	2004.11.25.18.32.11;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2004.03.10.23.02.53;	author tom;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.19.18.46.18;	author miod;	state Exp;
branches;
next	1.110;

1.110
date	2004.01.27.16.16.27;	author miod;	state Exp;
branches;
next	1.109;

1.109
date	2003.12.20.20.08.17;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2003.11.06.21.09.34;	author mickey;	state Exp;
branches;
next	1.107;

1.107
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.106;

1.106
date	2003.05.09.23.10.21;	author art;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.104;

1.104
date	2003.02.26.22.59.32;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2003.02.24.17.37.59;	author miod;	state Exp;
branches;
next	1.102;

1.102
date	2003.01.04.22.11.47;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.100;

1.100
date	2002.04.29.23.43.03;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2002.04.27.01.52.13;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2002.04.16.15.32.59;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2002.03.14.03.15.55;	author millert;	state Exp;
branches;
next	1.95;

1.95
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.94;

1.94
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.93;

1.93
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.92;

1.92
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.89;

1.89
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.88;

1.88
date	2001.11.24.17.53.41;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2001.11.23.00.47.45;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.85;

1.85
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.84;

1.84
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.82;

1.82
date	2001.09.12.00.23.33;	author art;	state Exp;
branches;
next	1.81;

1.81
date	2001.09.11.20.10.00;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2001.08.25.15.43.28;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2001.08.25.11.37.26;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.77;

1.77
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2001.08.11.23.09.03;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.74;

1.74
date	2001.07.05.10.12.10;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2001.07.05.07.18.40;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.27.04.22.37;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2001.05.17.18.41.48;	author provos;	state Exp;
branches;
next	1.70;

1.70
date	2001.05.08.17.30.41;	author aaron;	state Exp;
branches;
next	1.69;

1.69
date	2001.05.05.22.33.54;	author art;	state Exp;
branches;
next	1.68;

1.68
date	2001.05.05.20.56.41;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2000.04.11.02.44.28;	author pjanzen;	state Exp;
branches;
next	1.66;

1.66
date	2000.03.23.09.59.54;	author art;	state Exp;
branches;
next	1.65;

1.65
date	2000.02.22.19.27.52;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	99.12.08.06.50.16;	author itojun;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	99.09.03.18.01.12;	author art;	state Exp;
branches;
next	1.62;

1.62
date	99.06.11.06.19.08;	author downsj;	state Exp;
branches;
next	1.61;

1.61
date	99.05.24.23.09.03;	author jason;	state Exp;
branches;
next	1.60;

1.60
date	99.05.23.06.55.06;	author downsj;	state Exp;
branches;
next	1.59;

1.59
date	99.05.22.21.22.25;	author weingart;	state Exp;
branches;
next	1.58;

1.58
date	99.04.23.05.15.28;	author downsj;	state Exp;
branches;
next	1.57;

1.57
date	99.04.22.00.35.04;	author downsj;	state Exp;
branches;
next	1.56;

1.56
date	99.02.15.08.56.05;	author todd;	state Exp;
branches;
next	1.55;

1.55
date	99.02.04.23.00.25;	author niklas;	state Exp;
branches;
next	1.54;

1.54
date	99.01.07.23.16.00;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	98.05.03.07.19.54;	author gene;	state Exp;
branches;
next	1.52;

1.52
date	98.05.03.07.15.15;	author gene;	state Exp;
branches;
next	1.51;

1.51
date	98.04.27.02.01.46;	author gene;	state Exp;
branches;
next	1.50;

1.50
date	98.03.03.21.24.12;	author ryker;	state Exp;
branches;
next	1.49;

1.49
date	98.03.03.04.54.22;	author ryker;	state Exp;
branches;
next	1.48;

1.48
date	98.03.03.04.30.09;	author ryker;	state Exp;
branches;
next	1.47;

1.47
date	98.02.26.15.45.10;	author gene;	state Exp;
branches;
next	1.46;

1.46
date	98.02.26.07.03.09;	author gene;	state Exp;
branches;
next	1.45;

1.45
date	97.08.04.21.45.47;	author gene;	state Exp;
branches;
next	1.44;

1.44
date	97.07.23.04.31.59;	author denny;	state Exp;
branches;
next	1.43;

1.43
date	97.07.11.20.46.50;	author gene;	state Exp;
branches;
next	1.42;

1.42
date	97.05.14.04.41.49;	author gene;	state Exp;
branches;
next	1.41;

1.41
date	97.05.12.19.59.05;	author gene;	state Exp;
branches;
next	1.40;

1.40
date	97.04.25.18.34.17;	author gene;	state Exp;
branches;
next	1.39;

1.39
date	97.04.24.00.54.34;	author gene;	state Exp;
branches;
next	1.38;

1.38
date	97.04.14.18.47.59;	author gene;	state Exp;
branches;
next	1.37;

1.37
date	97.04.07.03.23.35;	author briggs;	state Exp;
branches;
next	1.36;

1.36
date	97.04.05.16.22.07;	author briggs;	state Exp;
branches;
next	1.35;

1.35
date	97.04.05.15.29.10;	author briggs;	state Exp;
branches;
next	1.34;

1.34
date	97.03.28.12.38.59;	author briggs;	state Exp;
branches;
next	1.33;

1.33
date	97.03.15.05.51.15;	author briggs;	state Exp;
branches;
next	1.32;

1.32
date	97.03.12.13.37.00;	author briggs;	state Exp;
branches;
next	1.31;

1.31
date	97.03.08.16.17.04;	author briggs;	state Exp;
branches;
next	1.30;

1.30
date	97.02.26.06.17.02;	author gene;	state Exp;
branches;
next	1.29;

1.29
date	97.02.23.06.04.59;	author briggs;	state Exp;
branches;
next	1.28;

1.28
date	97.02.21.05.49.29;	author briggs;	state Exp;
branches;
next	1.27;

1.27
date	97.01.24.01.35.48;	author briggs;	state Exp;
branches;
next	1.26;

1.26
date	97.01.19.03.58.06;	author briggs;	state Exp;
branches;
next	1.25;

1.25
date	97.01.16.20.43.36;	author kstailey;	state Exp;
branches;
next	1.24;

1.24
date	96.11.05.01.40.29;	author briggs;	state Exp;
branches;
next	1.23;

1.23
date	96.10.28.14.55.31;	author briggs;	state Exp;
branches;
next	1.22;

1.22
date	96.10.28.03.48.53;	author briggs;	state Exp;
branches;
next	1.21;

1.21
date	96.10.23.04.49.48;	author briggs;	state Exp;
branches;
next	1.20;

1.20
date	96.10.14.01.24.58;	author briggs;	state Exp;
branches;
next	1.19;

1.19
date	96.09.21.04.03.58;	author briggs;	state Exp;
branches;
next	1.18;

1.18
date	96.08.10.21.37.46;	author briggs;	state Exp;
branches;
next	1.17;

1.17
date	96.07.27.11.40.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.06.23.15.39.10;	author briggs;	state Exp;
branches;
next	1.15;

1.15
date	96.06.08.16.21.16;	author briggs;	state Exp;
branches;
next	1.14;

1.14
date	96.05.26.18.36.22;	author briggs;	state Exp;
branches;
next	1.13;

1.13
date	96.05.26.18.14.28;	author briggs;	state Exp;
branches;
next	1.12;

1.12
date	96.05.08.02.03.14;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.02.20.13.45.50;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	96.02.04.16.40.14;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	96.01.15.12.30.11;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	96.01.14.21.11.46;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.01.09.16.11.51;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.01.05.16.17.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.18.14.51.19;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	95.12.16.16.30.04;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.11.36.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.30.18.40.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.07;	author deraadt;	state Exp;
branches;
next	;

1.64.2.1
date	2000.03.02.07.04.30;	author niklas;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2000.03.24.09.08.05;	author niklas;	state Exp;
branches;
next	1.64.2.3;

1.64.2.3
date	2001.04.18.16.10.10;	author niklas;	state Exp;
branches;
next	1.64.2.4;

1.64.2.4
date	2001.07.04.10.18.38;	author niklas;	state Exp;
branches;
next	1.64.2.5;

1.64.2.5
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.64.2.6;

1.64.2.6
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.64.2.7;

1.64.2.7
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.64.2.8;

1.64.2.8
date	2002.03.06.01.05.36;	author niklas;	state Exp;
branches;
next	1.64.2.9;

1.64.2.9
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.64.2.10;

1.64.2.10
date	2003.03.27.23.28.44;	author niklas;	state Exp;
branches;
next	1.64.2.11;

1.64.2.11
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.64.2.12;

1.64.2.12
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.64.2.13;

1.64.2.13
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	1.64.2.14;

1.64.2.14
date	2004.06.05.23.10.51;	author niklas;	state Exp;
branches;
next	;

1.91.2.1
date	2002.01.31.22.55.13;	author niklas;	state Exp;
branches;
next	1.91.2.2;

1.91.2.2
date	2002.06.11.03.36.20;	author art;	state Exp;
branches;
next	1.91.2.3;

1.91.2.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.160
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: machdep.c,v 1.159 2011/06/26 22:39:59 deraadt Exp $	*/
/*	$NetBSD: machdep.c,v 1.207 1998/07/08 04:39:34 thorpej Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * from: Utah $Hdr: machdep.c 1.63 91/04/24$
 *
 *	@@(#)machdep.c	7.16 (Berkeley) 6/3/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/exec.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/vnode.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/user.h>
#include <sys/mount.h>
#include <sys/extent.h>
#include <sys/syscallargs.h>

#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#include <ddb/db_var.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/pte.h>
#include <machine/kcore.h>
#include <machine/bus.h>
#include <machine/pmap.h>

#include <net/if.h>
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>

#include <sys/sysctl.h>

#include <dev/cons.h>
#include <mac68k/dev/adbvar.h>

#include <machine/iop.h>
#include <machine/psc.h>
#include <machine/viareg.h>

#include "wsdisplay.h"

/* The following is used externally (sysctl_hw) */
char	machine[] = MACHINE;	/* from <machine/param.h> */

struct mac68k_machine_S mac68k_machine;

volatile u_char *Via1Base, *Via2Base, *PSCBase = NULL;
u_long  NuBusBase = NBBASE;
u_long  IOBase;

vaddr_t SCSIBase;

/* These are used to map kernel space: */
#define	NBMEMRANGES	8
extern int numranges;
extern u_long low[NBMEMRANGES];
extern u_long high[NBMEMRANGES];

/* These are used to map NuBus space: */
#define	NBMAXRANGES	16
int	nbnumranges;		/* = 0 == don't use the ranges */
u_long	nbphys[NBMAXRANGES];	/* Start physical addr of this range */
u_long	nblog[NBMAXRANGES];	/* Start logical addr of this range */
long	nblen[NBMAXRANGES];	/* Length of this range If the length is */
				/* negative, all phys addrs are the same. */

/* From Booter via locore */
long	videoaddr;		/* Addr used in kernel for video. */
long	videorowbytes;		/* Used in kernel for video. */
long	videobitdepth;		/* Number of bihs per pixel */
u_long	videosize;		/* height = 31:16, width 15:0 */

/*
 * Values for IIvx-like internal video
 * -- should be zero if it is not used (usual case).
 */
u_int32_t mac68k_vidlog;	/* logical addr */
u_int32_t mac68k_vidphys;	/* physical addr */
u_int32_t mac68k_vidlen;	/* mem length */

/* Callback and cookie to run bell */
int	(*mac68k_bell_callback)(void *, int, int, int);
caddr_t	mac68k_bell_cookie;

struct vm_map *exec_map = NULL;  
struct vm_map *phys_map = NULL;

int	physmem;		/* size of physical memory, in pages */

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = PSL_LOWIPL;

/*
 * Extent maps to manage all memory space, including I/O ranges.  Allocate
 * storage for 8 regions in each, initially.  Later, iomem_malloc_safe
 * will indicate that it's safe to use malloc() to dynamically allocate
 * region descriptors.
 *
 * The extent maps are not static!  Machine-dependent NuBus and on-board
 * I/O routines need access to them for bus address space allocation.
 */
long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
struct	extent *iomem_ex;
int	iomem_malloc_safe;

/* XXX should be in locore.s for consistency */
int	astpending = 0;

void	identifycpu(void);
u_long	get_physical(u_int, u_long *);

void	initcpu(void);
int	cpu_dumpsize(void);
int	cpu_dump(int (*)(dev_t, daddr64_t, caddr_t, size_t), daddr64_t *);
void	cpu_init_kcore_hdr(void);
int	fpu_probe(void);

/* functions called from locore.s */
void	dumpsys(void);
void	mac68k_init(void);
void	straytrap(int, int);
void	nmihand(struct frame);

/*
 * Machine-dependent crash dump header info.
 */
cpu_kcore_hdr_t cpu_kcore_hdr;

 /*
 * Early initialization, before main() is called.
 */
void
mac68k_init()
{
	int i;
	extern vaddr_t avail_start;

	/*
	 * Tell the VM system about available physical memory.
	 */
	for (i = 0; i < numranges; i++) {
		if (low[i] <= avail_start && avail_start < high[i])
			uvm_page_physload(atop(avail_start), atop(high[i]),
			    atop(avail_start), atop(high[i]), 0);
		else
			uvm_page_physload(atop(low[i]), atop(high[i]),
			    atop(low[i]), atop(high[i]), 0);
	}

	/*
	 * Initialize the I/O mem extent map.
	 * Note: we don't have to check the return value since
	 * creation of a fixed extent map will never fail (since
	 * descriptor storage has already been allocated).
	 *
	 * N.B. The iomem extent manages _all_ physical addresses
	 * on the machine.  When the amount of RAM is found, all
	 * extents of RAM are allocated from the map.
	 */
	iomem_ex = extent_create("iomem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)iomem_ex_storage, sizeof(iomem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);

	/* Initialize the interrupt handlers. */
	intr_init();

	/* Initialize the VIAs */
	via_init();

	/* Initialize the PSC (if present) */
	psc_init();
}

/*
 * Console initialization: called early on from main,
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
 */
void
consinit(void)
{
	/*
	 * Generic console: sys/dev/cons.c
	 *	Initializes either ite or ser as console.
	 *	Can be called from locore.s and init_main.c.  (Ugh.)
	 */
	static int init;	/* = 0 */

	if (!init) {
		cninit();
#ifdef DDB
		/*
		 * Initialize kernel debugger, if compiled in.
		 */
		ddb_init();
#endif
		init = 1;
	} else {
#if NWSDISPLAY > 0
		/*
		 * XXX  This is an evil hack on top of an evil hack!
		 *
		 * With the graybar stuff, we've got a catch-22:  we need
		 * to do at least some console setup really early on, even
		 * before we're running with the mappings we need.  On
		 * the other hand, we're not nearly ready to do anything
		 * with wscons or the ADB driver at that point.
		 *
		 * To get around this, wscninit() ignores the first call
		 * it gets (from cninit(), if not on a serial console).
		 * Once we're here, we call wscninit() again, which sets
		 * up the console devices and does the appropriate wscons
		 * initialization.
		 */
		if (mac68k_machine.serial_console == 0) {
			cons_decl(ws);
			wscninit(NULL);
		}
#endif

		mac68k_calibrate_delay();

#if NZSC > 0 && defined(KGDB)
		zs_kgdb_init();
#endif

		if (boothowto & RB_KDB) {
#ifdef KGDB
			/* XXX - Ask on console for kgdb_dev? */
			/* Note: this will just return if kgdb_dev==NODEV */
			kgdb_connect(1);
#else	/* KGDB */
#ifdef DDB
			/* Enter DDB.  We don't have a monitor PROM. */
			Debugger();
#endif /* DDB */
#endif	/* KGDB */
		}
	}
}

#define CURRENTBOOTERVER	111

/*
 * cpu_startup: allocate memory for variable-sized tables,
 * initialize cpu, and do autoconfiguration.
 */
void
cpu_startup(void)
{
	unsigned i;
	int vers;
	vaddr_t minaddr, maxaddr;
	int delay;

	/*
	 * Initialize the kernel crash dump header.
	 */
	cpu_init_kcore_hdr();

	/*
	 * Initialize error message buffer (at end of core).
	 * high[numranges-1] was decremented in pmap_bootstrap.
	 */
	for (i = 0; i < atop(MSGBUFSIZE); i++)
		pmap_enter(pmap_kernel(), (vaddr_t)msgbufp + i * NBPG,
		    high[numranges - 1] + i * NBPG,
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	identifycpu();

	vers = mac68k_machine.booter_version;
	if (vers < CURRENTBOOTERVER) {
		/* fix older booters with indices, not versions */
		if (vers < 100)
			vers += 99;

		printf("\nYou booted with booter version %d.%d.\n",
		    vers / 100, vers % 100);
		printf("Booter version %d.%d is necessary to fully support\n",
		    CURRENTBOOTERVER / 100, CURRENTBOOTERVER % 100);
		printf("this kernel.\n\n");
		for (delay = 0; delay < 1000000; delay++);
	}
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}

	/* Safe for extent allocation to use malloc now. */
	iomem_malloc_safe = 1;
}

void
initcpu()
{
#if defined(M68040)
	extern void (*vectab[256])(void);
	void addrerr4060(void);
#endif
#ifdef M68040
	void buserr40(void);
#endif
#ifdef FPSP
	extern u_long fpvect_tab, fpvect_end, fpsp_tab;
#endif

	switch (cputype) {
#ifdef M68040
	case CPU_68040:
		vectab[2] = buserr40;
		vectab[3] = addrerr4060;
#ifdef FPSP
		bcopy(&fpsp_tab, &fpvect_tab,
		    (&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
#endif
		break;
#endif
	default:
		break;
	}

	DCIS();
}

void doboot(void)
	__attribute__((__noreturn__));

int	waittime = -1;

void
boot(howto)
	int howto;
{
	extern u_long maxaddr;

	/* take a snap shot before clobbering any registers */
	if (curproc && curproc->p_addr)
		savectx(&curproc->p_addr->u_pcb);

	/* If system is cold, just halt. */
	if (cold) {
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if (mac68k_machine.aux_interrupts != 0) {
			/*
			 * If we've been adjusting the clock, the todr
			 * will be out of synch; adjust it now unless
			 * the system was sitting in ddb.
			 */
			if ((howto & RB_TIMEBAD) == 0) {
				resettodr();
			} else {
				printf("WARNING: not updating battery clock\n");
			}
		} else {
#ifdef DIAGNOSTIC
			printf("OpenBSD/mac68k does not trust itself to update"
			    " the clock on shutdown on this machine.\n");
#endif
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();			/* Disable interrupts. */

	/* If rebooting and a dump is requested, do it. */
	if (howto & RB_DUMP) {
		dumpsys();
	}

haltsys:
	/* Run any shutdown hooks. */
	doshutdownhooks();

	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN) {
			printf("\nAttempting to power down...\n");
			via_powerdown();
			/*
			 * Shut down machines whose power functions
			 * are accessed via modified ADB calls.
			 */
			adb_poweroff();
		}
		printf("\nThe operating system has halted.\n");
		printf("Please press any key to reboot.\n\n");
		cnpollc(1);
		(void)cngetc();
		cnpollc(0);
	}

	/* Map the last physical page VA = PA for doboot() */
	pmap_enter(pmap_kernel(), (vaddr_t)maxaddr, (vaddr_t)maxaddr,
	    VM_PROT_ALL, VM_PROT_ALL|PMAP_WIRED);
	pmap_update(pmap_kernel());

	printf("rebooting...\n");
	DELAY(1000000);
	doboot();
	/* NOTREACHED */
}

/*
 * Initialize the kernel crash dump header.
 */
void
cpu_init_kcore_hdr()
{
	cpu_kcore_hdr_t *h = &cpu_kcore_hdr;
	int i;

	bzero(&cpu_kcore_hdr, sizeof(cpu_kcore_hdr));

	h->mmutype = mmutype;
	h->kernel_pa = low[0];
	h->sysseg_pa = pmap_kernel()->pm_stpa;

	/*
	 * mac68k has multiple RAM segments on some models.
	 */
	for (i = 0; i < numranges; i++) {
		h->ram_segs[i].start = low[i];
		h->ram_segs[i].size  = high[i] - low[i];
	}
}

/*
 * Compute the size of the machine-dependent crash dump header.
 * Returns size in disk blocks.
 */
int
cpu_dumpsize()
{
	int size;

	size = ALIGN(sizeof(kcore_seg_t)) + ALIGN(sizeof(cpu_kcore_hdr_t));
	return (btodb(roundup(size, dbtob(1))));
}

/*
 * Called by dumpsys() to dump the machine-dependent header.
 */
int
cpu_dump(dump, blknop)
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
	daddr64_t *blknop;
{
	int buf[dbtob(1) / sizeof(int)];
	cpu_kcore_hdr_t *chdr;
	kcore_seg_t *kseg;
	int error;

	kseg = (kcore_seg_t *)buf;
	chdr = (cpu_kcore_hdr_t *)&buf[ALIGN(sizeof(kcore_seg_t)) /
	    sizeof(int)];

	/* Create the segment header. */
	CORE_SETMAGIC(*kseg, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg->c_size = dbtob(1) - ALIGN(sizeof(kcore_seg_t));

	bcopy(&cpu_kcore_hdr, chdr, sizeof(cpu_kcore_hdr_t));
	error = (*dump)(dumpdev, *blknop, (caddr_t)buf, sizeof(buf));
	*blknop += btodb(sizeof(buf));
	return (error);
}

/*
 * These variables are needed by /sbin/savecore
 */
u_long	dumpmag = 0x8fca0101;	/* magic number */
int	dumpsize = 0;		/* pages */
long	dumplo = 0;		/* blocks */

/*
 * This is called by main to set dumplo and dumpsize.
 * Dumps always skip the first block of disk space in
 * case there might be a disk label stored there.  If there
 * is extra space, put dump at the end to reduce the chance
 * that swapping trashes it.
 */
void
dumpconf(void)
{
	cpu_kcore_hdr_t *h = &cpu_kcore_hdr;
	int nblks;	/* size of dump area */
	int i;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = 0;
	for (i = 0; h->ram_segs[i].size && i < NPHYS_RAM_SEGS; i++)
		dumpsize += atop(h->ram_segs[i].size);
	dumpsize += cpu_dumpsize();

	/* Always skip the first block, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
}

void
dumpsys()
{
	cpu_kcore_hdr_t *h = &cpu_kcore_hdr;
	daddr64_t blkno;	/* current block to write */
				/* dump routine */
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
	int pg;			/* page being dumped */
	vaddr_t maddr;	/* PA being dumped */
	int seg;		/* RAM segment being dumped */
	int error;		/* error code from (*dump)() */
	extern int msgbufmapped;

	/* XXX initialized here because of gcc lossage */
	seg = 0;
	maddr = h->ram_segs[seg].start;
	pg = 0;

	/* Don't record dump msgs in msgbuf. */
	msgbufmapped = 0;

	/* Make sure dump device is valid. */
	if (dumpdev == NODEV)
		return;
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	if (dumplo <= 0) {
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[major(dumpdev)].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif

	printf("dump ");

	/* Write the dump header. */
	error = cpu_dump(dump, &blkno);
	if (error)
		goto bad;

	for (pg = 0; pg < dumpsize; pg++) {
#define NPGMB	(1024*1024/NBPG)
		/* print out how many MBs we have dumped */
		if (pg && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		while (maddr >=
		    (h->ram_segs[seg].start + h->ram_segs[seg].size)) {
			if (++seg >= NPHYS_RAM_SEGS ||
			    h->ram_segs[seg].size == 0) {
				error = EINVAL;		/* XXX ?? */
				goto bad;
			}
			maddr = h->ram_segs[seg].start;
		}
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);
		pmap_update(pmap_kernel());

		error = (*dump)(dumpdev, blkno, vmmap, NBPG);
bad:
		switch (error) {
		case 0:
			maddr += NBPG;
			blkno += btodb(NBPG);
			break;

		case ENXIO:
			printf("device bad\n");
			return;

		case EFAULT:
			printf("device not ready\n");
			return;

		case EINVAL:
			printf("area improper\n");
			return;

		case EIO:
			printf("i/o error\n");
			return;

		case EINTR:
			printf("aborted from console\n");
			return;

		default:
			printf("error %d\n", error);
			return;
		}
	}
	printf("succeeded\n");
}

/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt (clock.c:clkread).
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for fun,
 * we guarantee that the time will be greater than the value obtained by a
 * previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
{
	int s = splhigh();
	static struct timeval lasttime;

	*tvp = time;
	tvp->tv_usec += clkread();
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
}

void
straytrap(pc, evec)
	int pc;
	int evec;
{
	printf("unexpected trap; vector offset 0x%x from 0x%x.\n",
	    (int) (evec & 0xfff), pc);
#ifdef DEBUG
#ifdef DDB
	Debugger();
#endif
#endif
}

int	*nofault;

/*
 * Level 7 interrupts can be caused by the keyboard or parity errors.
 */
void	nmihand(struct frame);

void
nmihand(frame)
	struct frame frame;
{
	static int nmihanddeep = 0;

	if (nmihanddeep)
		return;
	nmihanddeep = 1;

#ifdef DDB
	if (db_console)
		Debugger();
#endif

	nmihanddeep = 0;
}

/*
 * It should be possible to probe for the top of RAM, but Apple has
 * memory structured so that in at least some cases, it's possible
 * for RAM to be aliased across all memory--or for it to appear that
 * there is more RAM than there really is.
 */
int	get_top_of_ram(void);

int
get_top_of_ram()
{
	return ((mac68k_machine.mach_memsize * (1024 * 1024)) - 4096);
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int   namelen;
	void   *oldp;
	size_t *oldlenp;
	void   *newp;
	size_t  newlen;
	struct proc *p;
{
	dev_t   consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);	/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
			sizeof consdev));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

static char *envbuf = NULL;

/*
 * getenvvars: Grab a few useful variables
 */
void	getenvvars(u_long, char *);
long	getenv(char *);

void
getenvvars(flag, buf)
	u_long  flag;
	char   *buf;
{
	extern u_long bootdev;
#if defined(DDB) || NKSYMS > 0
	extern u_long end, esym;
#endif
	extern u_long macos_boottime;
	extern vaddr_t MacOSROMBase;
	extern long macos_gmtbias;
	extern u_short ADBDelay;
	extern u_int32_t HwCfgFlags3;
	int root_scsi_id;
	vaddr_t ROMBase;

	/*
	 * If flag & 0x80000000 == 0, then we're booting with the old booter
	 * and we should freak out.
	 */
	if ((flag & 0x80000000) == 0) {
		/* Freak out; print something if that becomes available */
	} else
		envbuf = buf;

	/* These next two should give us mapped video & serial */
	/* We need these for pre-mapping graybars & echo, but probably */
	/* only on MacII or LC.  --  XXX */
	/* videoaddr = getenv("MACOS_VIDEO"); */

	/*
	 * The following are not in a structure so that they can be
	 * accessed more quickly.
	 */
	videoaddr = getenv("VIDEO_ADDR");
	videorowbytes = getenv("ROW_BYTES");
	videobitdepth = getenv("SCREEN_DEPTH");
	videosize = getenv("DIMENSIONS");

	/*
	 * More misc stuff from booter.
	 */
	mac68k_machine.machineid = getenv("MACHINEID");
	mac68k_machine.mach_memsize = getenv("MEMSIZE");
	mac68k_machine.do_graybars = getenv("GRAYBARS");
	mac68k_machine.serial_boot_echo = getenv("SERIALECHO");
	mac68k_machine.serial_console = getenv("SERIALCONSOLE");

	mac68k_machine.modem_flags = getenv("SERIAL_MODEM_FLAGS");
	mac68k_machine.modem_cts_clk = getenv("SERIAL_MODEM_HSKICLK");
	mac68k_machine.modem_dcd_clk = getenv("SERIAL_MODEM_GPICLK");
        mac68k_machine.modem_flags = getenv("SERIAL_MODEM_DSPEED");
	mac68k_machine.print_flags = getenv("SERIAL_PRINT_FLAGS");
	mac68k_machine.print_cts_clk = getenv("SERIAL_PRINT_HSKICLK");
	mac68k_machine.print_dcd_clk = getenv("SERIAL_PRINT_GPICLK");
	mac68k_machine.print_d_speed = getenv("SERIAL_PRINT_DSPEED");
	mac68k_machine.booter_version = getenv("BOOTERVER");

	/*
	 * For now, we assume that the boot device is off the first controller.
	 * Booter versions 1.11.0 and later set a flag to tell us to construct
	 * bootdev using the SCSI ID passed in via the environment.
	 */
	root_scsi_id = getenv("ROOT_SCSI_ID");
	if (((mac68k_machine.booter_version < CURRENTBOOTERVER) ||
	    (flag & 0x40000)) && bootdev == 0)
		bootdev = MAKEBOOTDEV(4, 0, 0, root_scsi_id, 0);

	/*
	 * Booter 1.11.3 and later pass a BOOTHOWTO variable with the
	 * appropriate bits set.
	 */
	boothowto = getenv("BOOTHOWTO");
	if (boothowto == 0)
		boothowto = getenv("SINGLE_USER");

	/*
	 * Get end of symbols for kernel debugging
	 */
#if defined(DDB) || NKSYMS > 0
	esym = getenv("END_SYM");
	if (esym == 0)
		esym = (long) &end;
#endif

	/* Get MacOS time */
	macos_boottime = getenv("BOOTTIME");

	/* Save GMT BIAS saved in Booter parameters dialog box */
	macos_gmtbias = getenv("GMTBIAS");

	/*
	 * Save globals stolen from MacOS
	 */

	ROMBase = (vaddr_t)getenv("ROMBASE");
	if (ROMBase != 0)
		MacOSROMBase = ROMBase;
	ADBDelay = (u_short) getenv("ADBDELAY");
	HwCfgFlags3 = getenv("HWCFGFLAG3");
}

char	toupper(char);

char
toupper(c)
	char c;
{
	if (c >= 'a' && c <= 'z') {
		return c - 'a' + 'A';
	} else {
		return c;
	}
}

long
getenv(str)
	char *str;
{
	/*
	 * Returns the value of the environment variable "str".
	 *
	 * Format of the buffer is "var=val\0var=val\0...\0var=val\0\0".
	 *
	 * Returns 0 if the variable is not there, and 1 if the variable is
	 * there without an "=val".
	 */

	char *s, *s1;
	int val, base;

	s = envbuf;
	while (1) {
		for (s1 = str; *s1 && *s && *s != '='; s1++, s++) {
			if (toupper(*s1) != toupper(*s)) {
				break;
			}
		}
		if (*s1) {	/* No match */
			while (*s) {
				s++;
			}
			s++;
			if (*s == '\0') {	/* Not found */
				/* Boolean flags are FALSE (0) if not there */
				return 0;
			}
			continue;
		}
		if (*s == '=') {/* Has a value */
			s++;
			val = 0;
			base = 10;
			if (*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')) {
				base = 16;
				s += 2;
			} else
				if (*s == '0') {
					base = 8;
				}
			while (*s) {
				if (toupper(*s) >= 'A' && toupper(*s) <= 'F') {
					val = val * base + toupper(*s) - 'A' + 10;
				} else {
					val = val * base + (*s - '0');
				}
				s++;
			}
			return val;
		} else {	/* TRUE (1) */
			return 1;
		}
	}
}

struct cpu_model_info cpu_models[] = {

/* The first four. */
	{ MACH_MACII,		"II",			MACH_CLASSII },
	{ MACH_MACIIX,		"IIx",			MACH_CLASSII },
	{ MACH_MACIICX,		"IIcx",			MACH_CLASSII },
	{ MACH_MACSE30,		"SE/30",		MACH_CLASSII },

/* The rest of the II series... */
	{ MACH_MACIICI,		"IIci",			MACH_CLASSIIci },
	{ MACH_MACIISI,		"IIsi",			MACH_CLASSIIsi },
	{ MACH_MACIIVI,		"IIvi",			MACH_CLASSIIvx },
	{ MACH_MACIIVX,		"IIvx",			MACH_CLASSIIvx },
	{ MACH_MACIIFX,		"IIfx",			MACH_CLASSIIfx },

/* The Centris/Quadra series. */
	{ MACH_MACQ700,		"Quadra 700",		MACH_CLASSQ },
	{ MACH_MACQ900,		"Quadra 900",		MACH_CLASSQ },
	{ MACH_MACQ950,		"Quadra 950",		MACH_CLASSQ },
	{ MACH_MACQ800,		"Quadra 800",		MACH_CLASSQ },
	{ MACH_MACQ650,		"Quadra 650",		MACH_CLASSQ },
	{ MACH_MACC650,		"Centris 650",		MACH_CLASSQ },
	{ MACH_MACQ605,		"Quadra 605",		MACH_CLASSQ },
	{ MACH_MACQ605_33,	"Quadra 605/33",	MACH_CLASSQ },
	{ MACH_MACC610,		"Centris 610",		MACH_CLASSQ },
	{ MACH_MACQ610,		"Quadra 610",		MACH_CLASSQ },
	{ MACH_MACQ630,		"Quadra 630",		MACH_CLASSQ2 },
	{ MACH_MACC660AV,	"Centris 660AV",	MACH_CLASSAV },
	{ MACH_MACQ840AV,	"Quadra 840AV",		MACH_CLASSAV },

/* The Powerbooks/Duos... */
	{ MACH_MACPB100,	"PowerBook 100",	MACH_CLASSPB },
	/* PB 100 has no MMU! */
	{ MACH_MACPB140,	"PowerBook 140",	MACH_CLASSPB },
	{ MACH_MACPB145,	"PowerBook 145",	MACH_CLASSPB },
	{ MACH_MACPB150,	"PowerBook 150",	MACH_CLASSDUO },
	{ MACH_MACPB160,	"PowerBook 160",	MACH_CLASSPB },
	{ MACH_MACPB165,	"PowerBook 165",	MACH_CLASSPB },
	{ MACH_MACPB165C,	"PowerBook 165c",	MACH_CLASSPB },
	{ MACH_MACPB170,	"PowerBook 170",	MACH_CLASSPB },
	{ MACH_MACPB180,	"PowerBook 180",	MACH_CLASSPB },
	{ MACH_MACPB180C,	"PowerBook 180c",	MACH_CLASSPB },
	{ MACH_MACPB190,	"PowerBook 190",	MACH_CLASSPB },
	{ MACH_MACPB190CS,	"PowerBook 190cs",	MACH_CLASSPB },
	{ MACH_MACPB500,	"PowerBook 500",	MACH_CLASSPB },

/* The Duos */
	{ MACH_MACPB210,	"PowerBook Duo 210",	MACH_CLASSDUO },
	{ MACH_MACPB230,	"PowerBook Duo 230",	MACH_CLASSDUO },
	{ MACH_MACPB250,	"PowerBook Duo 250",	MACH_CLASSDUO },
	{ MACH_MACPB270,	"PowerBook Duo 270C",	MACH_CLASSDUO },
	{ MACH_MACPB280,	"PowerBook Duo 280",	MACH_CLASSDUO },
	{ MACH_MACPB280C,	"PowerBook Duo 280C",	MACH_CLASSDUO },

/* The Performas... */
	{ MACH_MACP600,		"Performa 600",		MACH_CLASSIIvx },
	{ MACH_MACP460,		"Performa 460",		MACH_CLASSLC },
	{ MACH_MACP550,		"Performa 550",		MACH_CLASSLC },
	{ MACH_MACP580,		"Performa 580",		MACH_CLASSQ2 },
	{ MACH_MACTV,		"TV",			MACH_CLASSLC },

/* The LCs... */
	{ MACH_MACLCII,		"LC II",		MACH_CLASSLC },
	{ MACH_MACLCIII,	"LC III",		MACH_CLASSLC },
	{ MACH_MACLC475,	"LC 475",		MACH_CLASSQ },
	{ MACH_MACLC475_33,	"LC 475/33",		MACH_CLASSQ },
	{ MACH_MACLC520,	"LC 520",		MACH_CLASSLC },
	{ MACH_MACLC575,	"LC 575",		MACH_CLASSQ2 },
	{ MACH_MACCCLASSIC,	"Color Classic",	MACH_CLASSLC },
	{ MACH_MACCCLASSICII,	"Color ClassicII",	MACH_CLASSLC },
/* Does this belong here? */
	{ MACH_MACCLASSICII,	"Classic II",		MACH_CLASSLC },

/* The unknown one and the end... */
	{ 0,			"Unknown",		MACH_CLASSII }
};				/* End of cpu_models[] initialization. */

struct intvid_info_t {
	int	machineid;
	u_long	fbbase;
	u_long	fbmask;
	u_long	fblen;
} intvid_info[] = {
	{ MACH_MACCLASSICII,	0x009f9a80,	0x0,		21888 },
	{ MACH_MACPB140,	0xfee08000,	0x0,		32 * 1024 },
	{ MACH_MACPB145,	0xfee08000,	0x0,		32 * 1024 },
	{ MACH_MACPB170,	0xfee08000,	0x0,		32 * 1024 },
	{ MACH_MACPB150,	0x60000000,	0x0,		128 * 1024 },
	{ MACH_MACPB160,	0x60000000,	0x0ffe0000,	128 * 1024 },
	{ MACH_MACPB165,	0x60000000,	0x0ffe0000,	128 * 1024 },
	{ MACH_MACPB180,	0x60000000,	0x0ffe0000,	128 * 1024 },
	{ MACH_MACPB210,	0x60000000,	0x0,		128 * 1024 },
	{ MACH_MACPB230,	0x60000000,	0x0,		128 * 1024 },
	{ MACH_MACPB250,	0x60000000,	0x0,		128 * 1024 },
	{ MACH_MACPB270,	0x60000000,	0x0,		128 * 1024 },
	{ MACH_MACPB280,	0x60000000,	0x0,		128 * 1024 },
	{ MACH_MACPB280C,	0x60000000,	0x0,		128 * 1024 },
	{ MACH_MACIICI,		0x0,		0x0,		320 * 1024 },
	{ MACH_MACIISI,		0x0,		0x0,		320 * 1024 },
	{ MACH_MACCCLASSIC,	0x50f40000,	0x0,		512 * 1024 },
/*??*/	{ MACH_MACLCII,		0x50f40000,	0x0,		512 * 1024 },
	{ MACH_MACPB165C,	0xfc040000,	0x0,		512 * 1024 },
	{ MACH_MACPB180C,	0xfc040000,	0x0,		512 * 1024 },
	{ MACH_MACPB190,	0x60000000,	0x0,		512 * 1024 },
	{ MACH_MACPB190CS,	0x60000000,	0x0,		512 * 1024 },
	{ MACH_MACPB500,	0x60000000,	0x0,		512 * 1024 },
	{ MACH_MACLCIII,	0x60b00000,	0x0,		768 * 1024 },
	{ MACH_MACLC520,	0x60000000,	0x0,		1024 * 1024 },
	{ MACH_MACP550,		0x60000000,	0x0,		1024 * 1024 },
	{ MACH_MACTV,		0x60000000,	0x0,		1024 * 1024 },
	{ MACH_MACLC475,	0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACLC475_33,	0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACLC575,	0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACC610,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACC650,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACP580,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ605,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ605_33,	0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ610,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ630,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ650,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACC660AV,	0x50100000,	0x0,		1024 * 1024 },
	{ MACH_MACQ700,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ800,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ900,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ950,		0xf9000000,	0x0,		1024 * 1024 },
	{ MACH_MACQ840AV,	0x50100000,	0x0,		2048 * 1024 },
	{ 0,			0x0,		0x0,		0 },
};				/* End of intvid_info[] initialization. */

/*
 * Missing Mac Models:
 *	PowerMac 6100
 *	PowerMac 7100
 *	PowerMac 8100
 *	PowerBook 540
 *	PowerBook 520
 *	PowerBook 150
 *	Duo 280
 *	Performa 6000s
 * 	...?
 */

char	cpu_model[120];		/* for sysctl() */

int
fpu_probe()
{
	/*
	 * A 68881 idle frame is 28 bytes and a 68882's is 60 bytes.
	 * We, of course, need to have enough room for either.
	 */
	int	fpframe[60 / sizeof(int)];
	label_t	faultbuf;
	u_char	b;

	nofault = (int *) &faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = (int *) 0;
		return (FPU_NONE);
	}

	/*
	 * Synchronize FPU or cause a fault.
	 * This should leave the 881/882 in the IDLE state,
	 * state, so we can determine which we have by
	 * examining the size of the FP state frame
	 */
	asm("fnop");

	nofault = (int *) 0;

	/*
	 * Presumably, if we're an 040 and did not take exception
	 * above, we have an FPU.  Don't bother probing.
	 */
	if (mmutype == MMU_68040)
		return (FPU_68040);

	/*
	 * Presumably, this will not cause a fault--the fnop should
	 * have if this will.  We save the state in order to get the
	 * size of the frame.
	 */
	asm("movl %0, a0; fsave a0@@" : : "a" (fpframe) : "a0" );

	b = *((u_char *) fpframe + 1);

	/*
	 * Now, restore a NULL state to reset the FPU.
	 */
	fpframe[0] = fpframe[1] = 0;
	m68881_restore((struct fpframe *) fpframe);

	/*
	 * The size of a 68881 IDLE frame is 0x18
	 *         and a 68882 frame is 0x38
	 */
	if (b == 0x18)
		return (FPU_68881);
	if (b == 0x38)
		return (FPU_68882);

	/*
	 * If it's not one of the above, we have no clue what it is.
	 */
	return (FPU_UNKNOWN);
}

void
identifycpu()
{
#ifdef DEBUG
	extern u_int delay_factor;
#endif

	/*
	 * Print the machine type...
	 */
	snprintf(cpu_model, sizeof cpu_model, "Apple Macintosh %s",
	    cpu_models[mac68k_machine.cpu_model_index].model);

	/*
	 * ... and the CPU type...
	 */
	switch (cputype) {
	case CPU_68040:
		strlcat(cpu_model, ", 68040 CPU", sizeof cpu_model);
		break;
	case CPU_68030:
		strlcat(cpu_model, ", 68030 CPU", sizeof cpu_model);
		break;
	case CPU_68020:
		strlcat(cpu_model, ", 68020 CPU", sizeof cpu_model);
		break;
	default:
		strlcat(cpu_model, ", unknown CPU", sizeof cpu_model);
		break;
	}

	/*
	 * ... and the MMU type...
	 */
	switch (mmutype) {
	case MMU_68040:
	case MMU_68030:
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
		break;
	case MMU_68851:
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
		break;
	default:
		printf("%s\n", cpu_model);
		panic("unknown MMU type %d", mmutype);
		/* NOTREACHED */
	}

	/*
	 * ... and the FPU type...
	 */
	fputype = fpu_probe();	/* should eventually move to locore */

	switch (fputype) {
	case FPU_68040:
		strlcat(cpu_model, "+FPU", sizeof cpu_model);
		break;
	case FPU_68882:
		strlcat(cpu_model, ", MC6882 FPU", sizeof cpu_model);
		break;
	case FPU_68881:
		strlcat(cpu_model, ", MC6881 FPU", sizeof cpu_model);
		break;
	case FPU_UNKNOWN:
		strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
		break;
	default:
		/*strlcat(cpu_model, ", no FPU", sizeof cpu_model);*/
		break;
	}

	/*
	 * ... and finally, the cache type.
	 */
	if (cputype == CPU_68040)
		strlcat(cpu_model, ", 4k on-chip physical I/D caches", sizeof cpu_model);

	printf("%s\n", cpu_model);
#ifdef DEBUG
	printf("cpu: delay factor %d\n", delay_factor);
#endif
}

void	get_machine_info(void);

void
get_machine_info()
{
	int i;

	for (i = 0; cpu_models[i].machineid != 0; i++)
		if (mac68k_machine.machineid == cpu_models[i].machineid)
			break;

	mac68k_machine.cpu_model_index = i;
}

const struct cpu_model_info *current_mac_model;

/*
 * Sets a bunch of machine-specific variables
 */
void	setmachdep(void);

void
setmachdep()
{
	struct cpu_model_info *cpui;

	/*
	 * First, set things that need to be set on the first pass only
	 * Ideally, we'd only call this once, but for some reason, the
	 * VIAs need interrupts turned off twice !?
	 */
	get_machine_info();

	load_addr = 0;
	cpui = &(cpu_models[mac68k_machine.cpu_model_index]);
	current_mac_model = cpui;

	mac68k_machine.via1_ipl = 1;
	mac68k_machine.aux_interrupts = 0;

	/*
	 * Set up any machine specific stuff that we have to before
	 * ANYTHING else happens
	 */
	switch (cpui->class) {	/* Base this on class of machine... */
	case MACH_CLASSII:
		VIA2 = VIA2OFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi80 = 1;
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
		via_reg(VIA2, vIER) = 0x7f;	/* disable VIA2 int */
		break;
	case MACH_CLASSPB:
		VIA2 = VIA2OFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi80 = 1;
		/* Disable everything but PM; we need it. */
		via_reg(VIA1, vIER) = 0x6f;	/* disable VIA1 int */
		/* Are we disabling something important? */
		via_reg(VIA2, vIER) = 0x7f;	/* disable VIA2 int */
		if (cputype == CPU_68040)
			mac68k_machine.sonic = 1;
		break;
	case MACH_CLASSDUO:
		/*
		 * The Duo definitely does not use a VIA2, but it looks
		 * like the VIA2 functions might be on the MSC at the RBV
		 * locations.  The rest is copied from the Powerbooks.
		 */
		VIA2 = RBVOFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi80 = 1;
		/* Disable everything but PM; we need it. */
		via_reg(VIA1, vIER) = 0x6f;	/* disable VIA1 int */
		/* Are we disabling something important? */
		via_reg(VIA2, rIER) = 0x7f;	/* disable VIA2 int */
		break;
	case MACH_CLASSQ:
	case MACH_CLASSQ2:
		VIA2 = VIA2OFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.sonic = 1;
		mac68k_machine.scsi96 = 1;
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
		via_reg(VIA2, vIER) = 0x7f;	/* disable VIA2 int */

		/* Enable A/UX interrupt scheme */
		mac68k_machine.aux_interrupts = 1;
		via_reg(VIA1, vBufB) &= (0xff ^ DB1O_AuxIntEnb);
		via_reg(VIA1, vDirB) |= DB1O_AuxIntEnb;
		mac68k_machine.via1_ipl = 6;

		break;
	case MACH_CLASSAV:
		VIA2 = VIA2OFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi96 = 1;
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
		via_reg(VIA2, vIER) = 0x7f;	/* disable VIA2 int */
		break;
	case MACH_CLASSIIci:
		VIA2 = RBVOFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi80 = 1;
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
		via_reg(VIA2, rIER) = 0x7f;	/* disable RBV int */
		break;
	case MACH_CLASSIIsi:
		VIA2 = RBVOFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi80 = 1;
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
		via_reg(VIA2, rIER) = 0x7f;	/* disable RBV int */
		break;
	case MACH_CLASSIIvx:
		VIA2 = RBVOFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi80 = 1;
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
		via_reg(VIA2, rIER) = 0x7f;	/* disable RBV int */
		break;
	case MACH_CLASSLC:
		VIA2 = RBVOFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi80 = 1;
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
		via_reg(VIA2, rIER) = 0x7f;	/* disable RBV int */
		break;
	case MACH_CLASSIIfx:
		VIA2 = OSSOFF;
		IOBase = 0x50f00000;
		Via1Base = (volatile u_char *)IOBase;
		mac68k_machine.scsi80 = 1;
		via_reg(VIA1, vIER) = 0x7f;  /* disable VIA1 int */
		break;
	default:
	case MACH_CLASSH:
		break;
	}
}

/*
 * Set IO offsets.
 */
void
mac68k_set_io_offsets(base)
	vaddr_t base;
{
	extern volatile u_char *sccA;

	switch (current_mac_model->class) {
	case MACH_CLASSQ:
		Via1Base = (volatile u_char *)base;

		/* The following two may be overridden. */
		sccA = (volatile u_char *)base + 0xc000;
		SCSIBase = base + 0xf000;

		switch (current_mac_model->machineid) {
		case MACH_MACQ900:
		case MACH_MACQ950:
			sccA = (volatile u_char *)base + 0xc020;
			iop_serial_compatible();
			mac68k_machine.scsi96_2 = 1;
			break;
		case MACH_MACQ700:
			break;
		default:
			SCSIBase = base + 0x10000;
			break;
		}
		break;
	case MACH_CLASSQ2:
		/*
		 * Note the different offset for sccA for this class of
		 * machines.  This seems to be common on many of the
		 * Quadra-type machines.
		 */
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0xc020;
		SCSIBase = base + 0x10000;
		break;
	case MACH_CLASSAV:
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0x4000;
		SCSIBase = base + 0x18000;
		PSCBase = (volatile u_char *)base + 0x31000;
		break;
	case MACH_CLASSII:
	case MACH_CLASSPB:
	case MACH_CLASSDUO:
	case MACH_CLASSIIci:
	case MACH_CLASSIIsi:
	case MACH_CLASSIIvx:
	case MACH_CLASSLC:
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0x4000;
		SCSIBase = base;
		break;
	case MACH_CLASSIIfx:
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0x4020;
		iop_serial_compatible();
		SCSIBase = base;
		break;
	default:
	case MACH_CLASSH:
		panic("Unknown/unsupported machine class (%d).",
		    current_mac_model->class);
		break;
	}

	Via2Base = Via1Base + 0x2000 * VIA2;
}

#if GRAYBARS
u_long gray_nextaddr = 0;

void
gray_bar()
{
	static int i = 0;
	static int flag = 0;

/* MF basic premise as I see it:
	1) Save the scratch regs as they are not saved by the compilier.
   	2) Check to see if we want gray bars, if so,
		display some lines of gray,
		a couple of lines of white(about 8),
		and loop to slow this down.
   	3) restore regs
*/

	__asm __volatile ("	movl a0,sp@@-;
				movl a1,sp@@-;
				movl d0,sp@@-;
				movl d1,sp@@-");

/* check to see if gray bars are turned off */
	if (mac68k_machine.do_graybars) {
		/* MF the 10*rowbytes/4 is done lots, but we want this to be
		 * slow */
		for (i = 0; i < 10 * videorowbytes / 4; i++)
			((u_long *)videoaddr)[gray_nextaddr++] = 0xaaaaaaaa;
		for (i = 0; i < 2 * videorowbytes / 4; i++)
			((u_long *)videoaddr)[gray_nextaddr++] = 0x00000000;
	}

	__asm __volatile ("	movl sp@@+,d1;
				movl sp@@+,d0;
				movl sp@@+,a1;
				movl sp@@+,a0");
}
#endif

/* in locore */
extern u_long ptest040(caddr_t addr, u_int fc);
extern int get_pte(u_int addr, u_long pte[2], u_short * psr);

/*
 * LAK (7/24/94): given a logical address, puts the physical address
 *  in *phys and return 1, or returns 0 on failure.  This is intended
 *  to look through MacOS page tables.
 */

u_long
get_physical(u_int addr, u_long * phys)
{
	extern u_int macos_tc;
	u_long pte[2], ph, mask;
	u_short psr;
	int i, numbits;

	if (mmutype == MMU_68040) {
		ph = ptest040((caddr_t)addr, FC_SUPERD);
		if ((ph & MMU40_RES) == 0) {
			ph = ptest040((caddr_t)addr, FC_USERD);
			if ((ph & MMU40_RES) == 0)
				return 0;
		}
		if ((ph & MMU40_TTR) != 0)
			ph = addr;

		mask = (macos_tc & 0x4000) ? 0x00001fff : 0x00000fff;
		ph &= (~mask);
	} else {
		i = get_pte(addr, pte, &psr);

		switch (i) {
		case -1:
			return 0;
		case 0:
			ph = pte[0] & 0xFFFFFF00;
			break;
		case 1:
			ph = pte[1] & 0xFFFFFF00;
			break;
		default:
			panic("get_physical(): bad get_pte()");
		}

		/*
		 * We must now figure out how many levels down we went and
		 * mask the bits appropriately -- the returned value may only
		 * be the upper n bits, and we have to take the rest from addr.
		 */
		numbits = 0;
		psr &= 0x0007;		/* Number of levels we went */
		for (i = 0; i < psr; i++)
			numbits += (macos_tc >> (12 - i * 4)) & 0x0f;

		/*
		 * We have to take the most significant "numbits" from
		 * the returned value "ph", and the rest from our addr.
		 * Assume that numbits != 0.
		 */
		mask = (1 << (32 - numbits)) - 1;
	}
	*phys = ph + (addr & mask);

	return 1;
}

void	check_video(char *, u_long, u_long);

void
check_video(id, limit, maxm)
	char *id;
	u_long limit, maxm;
{
	u_long addr, phys;

	if (!get_physical(videoaddr, &phys)) {
		if (mac68k_machine.do_graybars)
			printf("get_mapping(): %s.  False start.\n", id);
	} else {
		mac68k_vidlog = videoaddr;
		mac68k_vidphys = phys;
		mac68k_vidlen = 32768;
		addr = videoaddr + 32768;
		while (get_physical(addr, &phys)) {
			if ((phys - mac68k_vidphys) != mac68k_vidlen)
				break;
			if (mac68k_vidlen + 32768 > limit) {
				if (mac68k_machine.do_graybars) {
					printf("mapping: %s.  Does it never end?\n",
					    id);
					printf("    Forcing VRAM size ");
					printf("to a conservative %ldK.\n",
					    maxm/1024);
				}
				mac68k_vidlen = maxm;
				break;
			}
			mac68k_vidlen += 32768;
			addr += 32768;
		}
		if (mac68k_machine.do_graybars) {
			printf("  %s internal video at paddr 0x%x, len 0x%x.\n",
			    id, mac68k_vidphys, mac68k_vidlen);
		}
	}
}

/*
 * Find out how MacOS has mapped itself so we can do the same thing.
 * Returns the address of logical 0 so that locore can map the kernel
 * properly.
 */
u_int
get_mapping(void)
{
	struct intvid_info_t *iip;
	u_long addr, lastpage, phys, len, limit;
	int i, last, same;

	numranges = 0;
	for (i = 0; i < NBMEMRANGES; i++) {
		low[i] = 0;
		high[i] = 0;
	}

	lastpage = get_top_of_ram();

	get_physical(0, &load_addr);

	last = 0;
	for (addr = 0; addr <= lastpage && get_physical(addr, &phys);
	    addr += PAGE_SIZE) {
		if (numranges > 0 && phys != high[last]) {
			/*
			 * Attempt to find if this page is already
			 * accounted for in an existing physical segment.
			 */
			for (i = 0; i < numranges; i++) {
				if (low[i] <= phys && phys <= high[i]) {
					last = i;
					break;
				}
			}
			if (i >= numranges)
				last = numranges - 1;

			if (low[last] <= phys && phys < high[last])
				continue;	/* Skip pages we've seen. */
		}

		if (numranges > 0 && phys == high[last]) {
			/* Common case: extend existing segment on high end */
			high[last] += PAGE_SIZE;
		} else if (numranges < NBMEMRANGES - 1) {
			/* This is a new physical segment. */
			for (last = 0; last < numranges; last++)
				if (phys < low[last])
					break;

			/* Create space for segment, if necessary */
			if (last < numranges && phys < low[last]) {
				for (i = numranges; i > last; i--) {
					low[i] = low[i - 1];
					high[i] = high[i - 1];
				}
			}

			numranges++;
			low[last] = phys;
			high[last] = phys + PAGE_SIZE;
		} else {
			/* Not enough ranges. Display a warning message? */
			continue;
		}

		/* Coalesce adjoining segments as appropriate */
		if (last < (numranges - 1) && high[last] == low[last + 1] &&
		    low[last + 1] != load_addr) {
			high[last] = high[last + 1];
			for (i = last + 1; i < numranges; i++) {
				low[i] = low[i + 1];
				high[i] = high[i + 1];
			}
			--numranges;
		}
	}
	if (mac68k_machine.do_graybars) {
		printf("System RAM: %ld bytes in %ld pages.\n",
		    addr, addr / PAGE_SIZE);
		for (i = 0; i < numranges; i++) {
			printf("     Low = 0x%lx, high = 0x%lx\n",
			    low[i], high[i]);
		}
	}

	/*
	 * If we can't figure out the PA of the frame buffer by groveling
	 * the page tables, assume that we already have the correct
	 * address.  This is the case on several of the PowerBook 1xx
	 * series, in particular.
	 */
	if (!get_physical(videoaddr, &phys))
		phys = videoaddr;

	/*
	 * Find on-board video, if we have an idea of where to look
	 * on this system.
	 */
	for (iip = intvid_info; iip->machineid != 0; iip++)
		if (mac68k_machine.machineid == iip->machineid)
			break;

	if (mac68k_machine.machineid == iip->machineid &&
	    (phys & ~iip->fbmask) >= iip->fbbase &&
	    (phys & ~iip->fbmask) < (iip->fbbase + iip->fblen)) {
		mac68k_vidphys = phys & ~iip->fbmask;
		mac68k_vidlen = 32768 - (phys & 0x7fff);

		limit = iip->fbbase + iip->fblen - mac68k_vidphys;
		if (mac68k_vidlen > limit) {
			mac68k_vidlen = limit;
		} else {
			addr = videoaddr + mac68k_vidlen;
			while (get_physical(addr, &phys)) {
				if ((phys - mac68k_vidphys) != mac68k_vidlen)
					break;
				if (mac68k_vidlen + 32768 > limit) {
					mac68k_vidlen = limit;
					break;
				}
				mac68k_vidlen += 32768;
				addr += 32768;
			}
		}
	}

	if (mac68k_vidlen > 0) {
		/*
		 * We've already figured out where internal video is.
		 * Tell the user what we know.
		 */
		if (mac68k_machine.do_graybars)
			printf("On-board video at addr 0x%lx (phys 0x%x), len 0x%x.\n",
			    videoaddr, mac68k_vidphys, mac68k_vidlen);
	} else {
		/*
	 	* We should now look through all of NuBus space to find where
	 	* the internal video is being mapped.  Just to be sure we
	 	* handle all the cases, we simply map our NuBus space exactly
	 	* how MacOS did it.  As above, we find a bunch of ranges that
	 	* are contiguously mapped.  Since there are a lot of pages
	 	* that are all mapped to 0, we handle that as a special case
	 	* where the length is negative.  We search in increments of
	 	* 32768 because that's the page size that MacOS uses.
		*/
		nbnumranges = 0;
		for (i = 0; i < NBMAXRANGES; i++) {
			nbphys[i] = 0;
			nblog[i] = 0;
			nblen[i] = 0;
		}

		same = 0;
		for (addr = NBBASE; addr < NBTOP; addr += 32768) {
			if (!get_physical(addr, &phys)) {
				continue;
			}
			len = nbnumranges == 0 ? 0 : nblen[nbnumranges - 1];

#if DEBUG
			if (mac68k_machine.do_graybars)
				printf ("0x%lx --> 0x%lx\n", addr, phys);
#endif
			if (nbnumranges > 0
			    && addr == nblog[nbnumranges - 1] + len
			    && phys == nbphys[nbnumranges - 1]) {
				/* Same as last one */
				nblen[nbnumranges - 1] += 32768;
				same = 1;
			} else {
				if ((nbnumranges > 0)
				    && !same
				    && (addr == nblog[nbnumranges - 1] + len)
				    && (phys == nbphys[nbnumranges - 1] + len))
					nblen[nbnumranges - 1] += 32768;
				else {
					if (same) {
						nblen[nbnumranges - 1] = -len;
						same = 0;
					}
					if (nbnumranges == NBMAXRANGES) {
						if (mac68k_machine.do_graybars)
							printf("get_mapping(): "
							    "Too many NuBus ranges.\n");
						break;
					}
					nbnumranges++;
					nblog[nbnumranges - 1] = addr;
					nbphys[nbnumranges - 1] = phys;
					nblen[nbnumranges - 1] = 32768;
				}
			}
		}
		if (same) {
			nblen[nbnumranges - 1] = -nblen[nbnumranges - 1];
			same = 0;
		}
		if (mac68k_machine.do_graybars) {
			printf("Non-system RAM (nubus, etc.):\n");
			for (i = 0; i < nbnumranges; i++) {
				printf("     Log = 0x%lx, Phys = 0x%lx, Len = 0x%lx (%lu)\n",
				    nblog[i], nbphys[i], nblen[i], nblen[i]);
			}
		}

		/*
		 * We must now find the logical address of internal video in the
		 * ranges we made above.  Internal video is at physical 0, but
		 * a lot of pages map there.  Instead, we look for the logical
		 * page that maps to 32768 and go back one page.
		 */
		for (i = 0; i < nbnumranges; i++) {
			if (nblen[i] > 0
			    && nbphys[i] <= 32768
			    && 32768 <= nbphys[i] + nblen[i]) {
				mac68k_vidlog = nblog[i] - nbphys[i];
				mac68k_vidlen = nblen[i] + nbphys[i];
				mac68k_vidphys = 0;
				break;
			}
		}
		if (i == nbnumranges) {
			if (0x60000000 <= videoaddr && videoaddr < 0x70000000) {
				if (mac68k_machine.do_graybars)
					printf("Checking for Internal Video ");
				/*
				 * Kludge for IIvx internal video (60b0 0000).
				 * PB 520 (6000 0000)
				 */
				check_video("PB/IIvx (0x60?00000)",
				    1 * 1024 * 1024, 1 * 1024 * 1024);
			} else if (0x50F40000 <= videoaddr
			    && videoaddr < 0x50FBFFFF) {
				/*
				 * Kludge for LC internal video
				 */
				check_video("LC video (0x50f40000)",
				    512 * 1024, 512 * 1024);
			} else if (0x50100100 <= videoaddr
			    && videoaddr < 0x50400000) {
				/*
				 * Kludge for AV internal video
				 */
				check_video("AV video (0x50100100)",
				    1 * 1024 * 1024, 1 * 1024 * 1024);
			} else {
				if (mac68k_machine.do_graybars)
					printf( "  no internal video at address 0 -- "
						"videoaddr is 0x%lx.\n", videoaddr);
			}
		} else {
			if (mac68k_machine.do_graybars) {
				printf("  Video address = 0x%lx\n", videoaddr);
				printf("  Int video starts at 0x%x\n",
				    mac68k_vidlog);
				printf("  Length = 0x%x (%d) bytes\n",
				    mac68k_vidlen, mac68k_vidlen);
			}
		}
	}

	return load_addr;	/* Return physical address of logical 0 */
}

#ifdef DEBUG
/*
 * Debugging code for locore page-traversal routine.
 */
void printstar(void);
void
printstar(void)
{
	/*
	 * Be careful as we assume that no registers are clobbered
	 * when we call this from assembly.
	 */
	__asm __volatile ("	movl a0,sp@@-;
				movl a1,sp@@-;
				movl d0,sp@@-;
				movl d1,sp@@-");

	/* printf("*"); */

	__asm __volatile ("	movl sp@@+,d1;
				movl sp@@+,d0;
				movl sp@@+,a1;
				movl sp@@+,a0");
}
#endif

/*
 * Console bell callback; modularizes the console terminal emulator
 * and the audio system, so neither requires direct knowledge of the
 * other.
 */

void
mac68k_set_bell_callback(callback, cookie)
	int (*callback)(void *, int, int, int);
	void *cookie;
{
	mac68k_bell_callback = callback;
	mac68k_bell_cookie = (caddr_t)cookie;
}

int
mac68k_ring_bell(freq, length, volume)
	int freq, length, volume;
{
	if (mac68k_bell_callback)
		return ((*mac68k_bell_callback)(mac68k_bell_cookie,
		    freq, length, volume));
	else
		return (ENXIO);
}
@


1.159
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.158 2011/06/05 19:41:07 deraadt Exp $	*/
@


1.158
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.157 2011/05/30 22:25:21 oga Exp $	*/
d112 1
d506 1
@


1.157
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.156 2010/11/20 20:29:09 miod Exp $	*/
a170 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef	BUFCACHEPERCENT
#define	BUFCACHEPERCENT	5
#endif

#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.156
log
@Make sure we do not overrun the memory ranges array, should the booter
give us more ranges than we expect.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.155 2010/07/02 19:57:14 tedu Exp $	*/
d248 1
a248 2
			    atop(avail_start), atop(high[i]),
			    VM_FREELIST_DEFAULT);
d251 1
a251 2
			    atop(low[i]), atop(high[i]),
			    VM_FREELIST_DEFAULT);
@


1.155
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.154 2010/06/27 03:03:48 thib Exp $	*/
d138 1
d140 2
a141 2
extern u_long low[8];
extern u_long high[8];
a243 2
	 * Notice that we don't need to worry about avail_end here
	 * since it's equal to high[numranges-1].
d1756 1
a1756 1
	for (i = 0; i < 8; i++) {
d1789 1
a1789 1
		} else {
d1806 3
@


1.154
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.152 2009/08/11 18:46:32 miod Exp $	*/
a892 18
}

int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error = ENOEXEC;

#ifdef COMPAT_SUNOS
	{
		extern int sunos_exec_aout_makecmds(struct proc *,
			        struct exec_package *);
		if ((error = sunos_exec_aout_makecmds(p, epp)) == 0)
			return 0;
	}
#endif
	return error;
@


1.153
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d187 3
@


1.152
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.151 2009/08/09 10:40:17 blambert Exp $	*/
a397 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.151
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.150 2009/08/02 16:28:39 beck Exp $	*/
a211 1
caddr_t	allocsys(caddr_t);
a354 1
	caddr_t v;
a357 1
	vsize_t size = 0;	/* To avoid compiler warning */
a399 10
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addressses.
	 */
	size = (vsize_t)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(size))) == 0)
		panic("startup: no room for tables");
	if ((allocsys(v) - v) != size)
		panic("startup: table size inconsistency");

	/*
a445 22
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))

	return (v);
@


1.150
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.149 2009/06/15 17:01:26 beck Exp $	*/
a96 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a478 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.149
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.148 2009/06/03 21:30:20 beck Exp $	*/
a420 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.148
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.147 2008/11/09 12:34:47 tobias Exp $	*/
d421 6
@


1.147
log
@typo fixed (overriden -> overridden)

ok espie, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.146 2008/06/27 17:22:14 miod Exp $	*/
a420 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.146
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.145 2008/06/08 20:57:18 miod Exp $	*/
d1607 1
a1607 1
		/* The following two may be overriden. */
@


1.145
log
@Make sure to cnpollc(1)/cnpollc(0) around cngetc() or getsn() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.144 2008/04/09 16:58:10 deraadt Exp $	*/
d116 1
d764 4
@


1.144
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.144 2008/04/09 16:50:28 deraadt Exp $	*/
d601 1
d603 1
@


1.143
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.142 2007/07/29 21:24:05 miod Exp $	*/
d577 2
a578 2
	/* Disable interrupts. */
	splhigh();
@


1.142
log
@It turns out that VIA2 always interrupts at level 2, and IPL_BIO is always 2
too, so we can make these constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.141 2007/06/06 17:15:12 deraadt Exp $	*/
d374 1
a374 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d401 2
a402 2
	printf("real mem = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
d708 1
a708 1
		dumpsize += btoc(h->ram_segs[i].size);
@


1.141
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.140 2007/05/29 20:36:47 deraadt Exp $	*/
a1474 1
	mac68k_machine.via2_ipl = 2;
a1531 1
		mac68k_machine.via2_ipl = 2;
@


1.140
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2007/05/27 17:31:56 miod Exp $	*/
d217 1
a217 1
int	cpu_dump(int (*)(dev_t, daddr_t, caddr_t, size_t), daddr_t *);
d657 2
a658 2
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	daddr_t *blknop;
d726 1
a726 1
	daddr_t blkno;		/* current block to write */
d728 1
a728 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.139
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2007/05/26 20:26:50 pedro Exp $	*/
d694 1
a694 1
dumpconf()
a697 1
	int maj;
d700 2
a701 1
	if (dumpdev == NODEV)
a702 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
@


1.138
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2007/05/23 20:33:46 pvalchev Exp $	*/
d431 1
@


1.137
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2007/03/17 20:05:22 miod Exp $	*/
a175 6
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a360 1
	int base, residual;
d415 2
a416 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d418 2
a419 21
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
		panic("startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);
d421 5
a425 12
		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL) 
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
		pmap_update(pmap_kernel());
	}
a441 2
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
	    nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
a493 23
	/*
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless. */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.136
log
@Only invoke printstar() in get_pte() if option DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2007/03/03 21:21:25 miod Exp $	*/
d408 2
a409 1
	printf("real mem = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);
d473 2
a474 2
	printf("avail mem = %lu (%luK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
@


1.135
log
@Fix a logic error in dumpconf()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2006/09/22 22:15:19 miod Exp $	*/
d2138 1
d2162 1
@


1.134
log
@Get rid of (unused) MACH_CLASSP580 and flatten MACH_CLASSxxx values.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.133 2006/06/11 20:49:27 miod Exp $	*/
d778 1
a778 1
	if (dumpsize < dtoc(nblks - dumplo))
@


1.133
log
@Remove traces of cut'n'pasted 68060 support, since there aren't any 68060-based
macintoshes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2006/06/11 20:48:13 miod Exp $	*/
a1598 1
	case MACH_CLASSP580:
a1690 9
		break;
	case MACH_CLASSP580:
		/*
		 * Here's a queer bird... it seems to be a cross between
		 * the two different Quadra classes.
		 */
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0xc020;
		SCSIBase = base;
@


1.132
log
@Move common prototypes to <m68k/{cpu,param}.h> instead of incomplete
declarations in <machine/{cpu,param}.h> and elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2006/05/19 22:51:09 miod Exp $	*/
d557 1
a557 1
#if defined(M68040) || defined(M68060)
a560 3
#ifdef M68060
	void buserr60(void);
#endif
a568 6
#ifdef M68060
	case CPU_68060:
		vectab[2] = buserr60;
		vectab[3] = addrerr4060;
		break;
#endif
@


1.131
log
@Get rid of ``maxmem'' and fix the descriptive comment for ``physmem''.
Either maxmem is not used (mac68k), or the position of the physical memory
is set in stone so we don't need to know the top of the memory (MAXADDR
on hp300, physmem on mvme68k) it was pointing to.

Plus this gets rid of unused lowram on mvme68k - all the m68k world is not an
hp300, after all.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2006/01/24 06:50:13 miod Exp $	*/
d1522 1
a1522 1
struct cpu_model_info *current_mac_model;
@


1.130
log
@Remove unused fields from struct mac68k_machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2006/01/22 15:24:29 miod Exp $	*/
d193 1
a193 2
int	maxmem;			/* max memory per process */
int	physmem;		/* max supported memory, changes to actual */
@


1.129
log
@Finally update the todclock on shutdown, if we are using a level 6 clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2006/01/22 13:53:16 miod Exp $	*/
a96 1
#include <sys/extent.h>
a113 1
#include <net/netisr.h>
a1084 1
	mac68k_machine.mach_processor = getenv("PROCESSOR");
a1559 1
		mac68k_machine.zs_chip = 0;
a1567 1
		mac68k_machine.zs_chip = 0;
a1584 1
		mac68k_machine.zs_chip = 0;
a1596 1
		mac68k_machine.zs_chip = 0;
a1613 1
		mac68k_machine.zs_chip = 0;
a1621 1
		mac68k_machine.zs_chip = 0;
a1629 1
		mac68k_machine.zs_chip = 0;
a1637 1
		mac68k_machine.zs_chip = 0;
a1645 1
		mac68k_machine.zs_chip = 0;
a1653 1
		mac68k_machine.zs_chip = 0;
@


1.128
log
@Minimal iop code to set the serial ports to compatible mode automagically,
so that it is not necessary to change settings from MacOS before booting
into OpenBSD; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2006/01/13 21:04:36 miod Exp $	*/
d626 12
a637 9
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
#ifdef notyet
			resettodr();
#else
d639 2
a640 2
			printf("OpenBSD/mac68k does not trust itself to update the clock on shutdown.\n");
#endif
a641 2
		} else {
			printf("WARNING: not updating battery clock\n");
@


1.127
log
@Bring a few improvements from NetBSD:
- recognize a few more models.
- better memory range detection, especially if they are in direct translation
  windows on 68040.
- better internal video address detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2006/01/13 21:01:31 miod Exp $	*/
d124 1
a1693 5
			/*
			 * Note that sccA base address is based on having
			 * the serial port in `compatible' mode (set in
			 * the Serial Switch control panel before booting).
			 */
d1695 1
a1741 5
		/*
		 * Note that sccA base address is based on having
		 * the serial port in `compatible' mode (set in
		 * the Serial Switch control panel before booting).
		 */
d1744 1
@


1.126
log
@Remove unused bad{,b,w,l}addr.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2006/01/13 19:36:46 miod Exp $	*/
a959 3
#ifdef DIAGNOSTIC
	printf("Panic switch: PC is 0x%x.\n", frame.f_pc);
#endif
d1241 1
d1260 2
d1283 1
d1295 1
a1295 1
struct {
d1297 2
a1298 1
	caddr_t	fbbase;
d1301 45
a1345 33
	{ MACH_MACCLASSICII,	(caddr_t)0xfee09a80,	21888 },
	{ MACH_MACPB140,	(caddr_t)0xfee00000,	32 * 1024 },
	{ MACH_MACPB145,	(caddr_t)0xfee00000,	32 * 1024 },
	{ MACH_MACPB170,	(caddr_t)0xfee00000,	32 * 1024 },
	{ MACH_MACPB150,	(caddr_t)0x60000000,	128 * 1024 },
	{ MACH_MACPB160,	(caddr_t)0x60000000,	128 * 1024 },
	{ MACH_MACPB165,	(caddr_t)0x60000000,	128 * 1024 },
	{ MACH_MACPB180,	(caddr_t)0x60000000,	128 * 1024 },
	{ MACH_MACIICI,		(caddr_t)0x0,		320 * 1024 },
	{ MACH_MACIISI,		(caddr_t)0x0,		320 * 1024 },
	{ MACH_MACCCLASSIC,	(caddr_t)0x50f40000,	512 * 1024 },
	{ MACH_MACPB165C,	(caddr_t)0xfc040000,	512 * 1024 },
	{ MACH_MACPB180C,	(caddr_t)0xfc040000,	512 * 1024 },
	{ MACH_MACPB500,	(caddr_t)0x60000000,	512 * 1024 },
	{ MACH_MACLC520,	(caddr_t)0x60000000,	1 * 1024 * 1024 },
	{ MACH_MACLC475,	(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACLC475_33,	(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACLC575,	(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACC610,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACC650,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACP580,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ605,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ605_33,	(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ610,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ630,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ650,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACC660AV,	(caddr_t)0x50100000,	1 * 1024 * 1024 },
	{ MACH_MACQ700,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ800,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ900,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ950,		(caddr_t)0xf9000000,	1 * 1024 * 1024 },
	{ MACH_MACQ840AV,	(caddr_t)0x50100000,	2 * 1024 * 1024 },
	{ 0,			(caddr_t)0x0,		0 },
d1685 2
d1688 2
d1700 1
a1701 1
			SCSIBase = base + 0xf000;
d1760 1
d1829 2
d1890 1
a1890 2
			if ((phys - mac68k_vidphys)
			    != mac68k_vidlen)
d1907 2
a1908 3
			printf("  %s internal video at addr 0x%x (phys 0x%x), ",
			    id, mac68k_vidlog, mac68k_vidphys);
			printf("len 0x%x.\n", mac68k_vidlen);
d1921 3
a1923 2
	int i, same;
	u_long addr, lastpage, phys, len;
d1935 1
d1937 22
a1958 3
	    addr += NBPG) {
		if (numranges > 0 && phys == high[numranges - 1]) {
			high[numranges - 1] += NBPG;
d1960 13
d1974 13
a1986 2
			low[numranges - 1] = phys;
			high[numranges - 1] = phys + NBPG;
d1991 1
a1991 1
		    addr, addr / NBPG);
d1999 9
d2011 2
a2012 2
	for (i = 0; intvid_info[i].machineid; i++)
		if (mac68k_machine.machineid == intvid_info[i].machineid)
d2015 9
a2023 8
	if (mac68k_machine.machineid == intvid_info[i].machineid &&
	    get_physical(videoaddr, &phys) &&
	    phys >= (u_long)intvid_info[i].fbbase &&
	    phys < (u_long)(intvid_info[i].fbbase + intvid_info[i].fblen)) {
		mac68k_vidphys = phys;
		mac68k_vidlen = 32768;
		if (mac68k_vidlen > intvid_info[i].fblen) {
			mac68k_vidlen = intvid_info[i].fblen;
d2025 1
a2025 1
			addr = videoaddr + 32768;
d2029 2
a2030 3
				if (mac68k_vidlen + 32768 >
				    intvid_info[i].fblen) {
					mac68k_vidlen = intvid_info[i].fblen;
d2066 1
a2066 1
		for (addr = 0xF9000000; addr < 0xFF000000; addr += 32768) {
d2072 1
d2075 1
d2135 1
a2135 8
			if (0xfee00000 <= videoaddr && videoaddr < 0xfee10000) {
				/*
				 * Kludge for Classic II video.
				 */
				check_video("Classic II video (0xfee09a80)",
				    21888, 21888);
			} else if (0x60000000 <= videoaddr &&
			    videoaddr < 0x70000000) {
d2174 1
a2174 1
	return low[0];		/* Return physical address of logical 0 */
@


1.125
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2006/01/04 20:39:05 miod Exp $	*/
a943 70

int badaddr(caddr_t);

int
badaddr(addr)
	caddr_t addr;
{
	int i;
	label_t faultbuf;

	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
		return (1);
	}
	i = *(volatile short *)addr;
	nofault = (int *)0;
	return (0);
}

int
badbaddr(addr)
	caddr_t addr;
{
	int i;
	label_t faultbuf;

	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
		return (1);
	}
	i = *(volatile u_int8_t *)addr;
	nofault = (int *)0;
	return (0);
}

int
badwaddr(addr)
	caddr_t addr;
{
	int i;
	label_t faultbuf;

	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
		return (1);
	}
	i = *(volatile u_int16_t *)addr;
	nofault = (int *)0;
	return (0);
}

int
badladdr(addr)
	caddr_t addr;
{
	int i;
	label_t faultbuf;

	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
		return (1);
	}
	i = *(volatile u_int32_t *)addr;
	nofault = (int *)0;
	return (0);
}
@


1.124
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2006/01/01 13:16:01 miod Exp $	*/
a658 1
#ifndef MRG_ADB
a659 3
			 * adb_poweroff() is available only when
			 * the MRG_ADB method isn't used.
			 *
a663 1
#endif
d1123 2
a1124 1
	extern u_long macos_boottime, MacOSROMBase;
d1126 2
d1129 1
d1211 3
a1213 6
	ROMBase = (caddr_t)getenv("ROMBASE");
	if (ROMBase == (caddr_t)0) {
		ROMBase = (caddr_t)ROMBASE;
	}
	MacOSROMBase = (unsigned long) ROMBase;
	TimeDBRA = getenv("TIMEDBRA");
a1214 2
	HwCfgFlags  = getenv("HWCFGFLAGS");
	HwCfgFlags2 = getenv("HWCFGFLAG2");
a1215 2
 	ADBReInit_JTBL = getenv("ADBREINIT_JTBL");
 	mrg_ADBIntrPtr = (caddr_t)getenv("ADBINTERRUPT");
a1290 654
/*
 * ROM Vector information for calling drivers in ROMs
 *
 * According to information published on the Web by Apple, there have
 * been 9 different ROM families used in the Mac since the introduction
 * of the Lisa/XL through the latest PowerMacs (May 96).  Each family
 * has zero or more version variants and in some cases a version variant
 * may exist in one than one length format.  Generally any one specific
 * Mac will use a common set of routines within the ROM and a model-specific
 * set also in the ROM.  Luckily most of the routines used by BSD fall
 * into the common set and can therefore be defined in the ROM Family.
 * The offset addresses (address minus the ROM Base) of these common routines
 * is the same for all machines which use that ROM.  The offset addresses of
 * the machine-specific routines is generally different for each machine.
 * The machine-specific routines currently used by BSD/mac68k include:
 *       ADB_interrupt, PM_interrpt, ADBBase+130_interrupt,
 *       PMgrOp, jClkNoMem, Egret, InitEgret, and ADBReInit_JTBL
 *
 * It is possible that the routine at "jClkNoMem" is a common routine, but
 * some variation in addresses has been seen.  Also, execept for the very
 * earliest machines which used Egret, the machine-specific value of the
 * Egret routine may be unimportant as the machine-specific InitEgret code
 * seems to always set the OS Trap vector for Egret.
 *
 * Only three of the nine different ROMs are important to BSD/mac68k.
 * All other ROMs are used in early model Macs which are unable to run
 * BSD due to other hardware limitations such as 68000 CPU, no MMU
 * capability, or used only in PowerMacs.  The three that we are interested
 * in are:
 *
 * ROM Family $0178 - used in the II, IIx, IIcx, and SE/30
 *            All machines which use this ROM are now supported by BSD.
 *            There are no machine-dependent routines in these ROMs used by
 *            BSD/mac68k.  This ROM is always 256K in length.
 *
 * ROM Family $067c - used in Classic, Color Classic, Color Classic II,
 *                      IIci, IIsi, IIvi, IIvx, IIfx, LC, LC II, LC III,
 *                      LC III+, LC475, LC520, LC550, LC575, LC580, LC630,
 *                      MacTV, P200, P250, P275, P400/405/410/430, P450,
 *                      P460/466/467, P475/476, P520, P550/560, P575/577/578,
 *                      P580/588, P600, P630/631/635/636/637/638/640, Q605,
 *                      Q610, C610, Q630, C650, Q650, Q700, Q800, Q900, Q950,
 *                      PB140, PB145/145B, PB150, PB160, PB165, PB165c, PB170,
 *                      PB180, PB180c, Duo 210, Duo 230, Duo 250, Duo 270c,
 *                      Duo280, Duo 280c, PB 520/520c/540/540c/550
 *             This is the so-called "Universal" ROM used in almost all 68K
 *             machines. There are machine-dependent and machine-independent
 *             routines used by BSD/mac68k in this ROM, and except for the
 *             PowerBooks and the Duos, this ROM seems to be fairly well
 *             known by BSD/mac68k.  Desktop machines listed here that are
 *             not yet running BSD probably only lack the necessary
 *             addresses for the machine-dependent routines, or are waiting
 *             for IDE disk support.  This ROM is generally 1Meg in length,
 *             however when used in the IIci, IIfx, IIsi, LC, Classic II, and
 *             P400/405/410/430 it is 512K in length, and when used in the
 *             PB 520/520c/540/540c/550 it is 2Meg in length.
 *
 * ROM Family - $077d - used in C660AV/Q660AV, Q840AV
 *             The "Universal" ROM used on the PowerMacs and used in the
 *             68K line for the AV Macs only.  When used in the 68K AV
 *             machines the ROM is 2Meg in length; all uses in the PowerMac
 *             use a length of 4Meg.
 *
 *		Bob Nestor - <rnestor@@metronet.com>
 */
romvec_t romvecs[] =
{
	/* Vectors verified for II, IIx, IIcx, SE/30 */
	{			/* 0 */
		"Mac II class ROMs",
		(caddr_t)0x40807002,	/* where does ADB interrupt */
		(caddr_t)0x0,		/* PM interrupt (?) */
		(caddr_t)0x4080a4d8,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x40807778,	/* CountADBs */
		(caddr_t)0x40807792,	/* GetIndADB */
		(caddr_t)0x408077be,	/* GetADBInfo */
		(caddr_t)0x408077c4,	/* SetADBInfo */
		(caddr_t)0x40807704,	/* ADBReInit */
		(caddr_t)0x408072fa,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080d6d0,	/* WriteParam */
		(caddr_t)0x4080d6fa,	/* SetDateTime */
		(caddr_t)0x4080dbe8,	/* InitUtil */
		(caddr_t)0x4080dd78,	/* ReadXPRam */
		(caddr_t)0x4080dd82,	/* WriteXPRam */
		(caddr_t)0x4080ddd6,	/* jClkNoMem */
		(caddr_t)0x0,		/* ADBAlternateInit */
		(caddr_t)0x0,		/* Egret */
		(caddr_t)0x0,		/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x0,		/* ROMResourceMap List Head */
		(caddr_t)0x40814c58,	/* FixDiv */
		(caddr_t)0x40814b64,	/* FixMul */
	},
	/*
	 * Vectors verified for PB 140, PB 145, PB 170
	 * (PB 100?)
	 */
	{			/* 1 */
		"Powerbook class ROMs",
		(caddr_t)0x4088ae5e,	/* ADB interrupt */
		(caddr_t)0x408885ec,	/* PB ADB interrupt */
		(caddr_t)0x4088ae0e,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x408888ec,	/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for IIsi, IIvx, IIvi
	 */
	{			/* 2 */
		"Mac IIsi class ROMs",
		(caddr_t)0x40814912,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x408150f0,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for Mac Classic II and LC II
	 * (Other LC's?  680x0 Performas?)
	 */
	{			/* 3 */
		"Mac Classic II ROMs",
		(caddr_t)0x40a14912,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x40a150f0,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x40a0a360,	/* CountADBs */
		(caddr_t)0x40a0a37a,	/* GetIndADB */
		(caddr_t)0x40a0a3a6,	/* GetADBInfo */
		(caddr_t)0x40a0a3ac,	/* SetADBInfo */
		(caddr_t)0x40a0a752,	/* ADBReInit */
		(caddr_t)0x40a0a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x40a0c05c,	/* WriteParam */
		(caddr_t)0x40a0c086,	/* SetDateTime */
		(caddr_t)0x40a0c5cc,	/* InitUtil */
		(caddr_t)0x40a0b186,	/* ReadXPRam */
		(caddr_t)0x40a0b190,	/* WriteXPRam */
		(caddr_t)0x40a0b1e4,	/* jClkNoMem */
		(caddr_t)0x40a0a818,	/* ADBAlternateInit */
		(caddr_t)0x40a14800,	/* Egret */
		(caddr_t)0x40a147c4,	/* InitEgret */
		(caddr_t)0x40a03ba6,	/* ADBReInit_JTBL */
		(caddr_t)0x40a7eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x40a1c406,	/* FixDiv, wild guess */
		(caddr_t)0x40a1c312,	/* FixMul, wild guess */
	},
	/*
	 * Vectors verified for IIci, Q700
	 */
	{			/* 4 */
		"Mac IIci/Q700 ROMs",
		(caddr_t)0x4080a700,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x4080a5aa,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x0,		/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for Duo 230, PB 180, PB 160, PB 165/165C
	 * (Duo 210?  Duo 250?  Duo 270?)
	 */
	{			/* 5 */
		"2nd Powerbook class ROMs",
		(caddr_t)0x408b2eec,	/* ADB interrupt */
		(caddr_t)0x408885ec,	/* PB ADB interrupt */
		(caddr_t)0x408b2e76,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x408888ec,	/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b39b2,	/* jClkNoMem */	/* From PB180 */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x40888400,	/* InitPwrMgr */ /* From PB180 */
		(caddr_t)0x408cce28,	/* ADBReInit_JTBL -- from PB160*/
		(caddr_t)0x4087eb90,	/* ROMRsrcMap List Head -- from PB160*/
		(caddr_t)0x4081c406,	/* FixDiv, wild guess */
		(caddr_t)0x4081c312,	/* FixMul, wild guess */
	},
	/*
	 * Vectors verified for the Quadra, Centris 650
	 *  (610, Q800?)
	 */
	{			/* 6 */
		"Quadra/Centris ROMs",
		(caddr_t)0x408b2dea,	/* ADB int */
		(caddr_t)0x0,		/* PM intr */
 		(caddr_t)0x408b2c72,	/* ADBBase + 130 */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x40809ae6,	/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b39b6,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408d2b64,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv, wild guess */
		(caddr_t)0x4081c312,	/* FixMul, wild guess */
	},
	/*
	 * Vectors verified for the Quadra 660AV
	 *  (Quadra 840AV?)
	 */
	{			/* 7 */
		"Quadra AV ROMs",
		(caddr_t)0x4080cac6,	/* ADB int */
		(caddr_t)0x0,		/* PM int */
		(caddr_t)0x40805cd4,	/* ADBBase + 130 */
		(caddr_t)0x40839600,	/* CountADBs */
		(caddr_t)0x4083961a,	/* GetIndADB */
		(caddr_t)0x40839646,	/* GetADBInfo */
		(caddr_t)0x4083964c,	/* SetADBInfo */
		(caddr_t)0x408397b8,	/* ADBReInit */
		(caddr_t)0x4083967c,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4081141c,	/* WriteParam */
		(caddr_t)0x4081144e,	/* SetDateTime */
		(caddr_t)0x40811930,	/* InitUtil */
		(caddr_t)0x4080b624,	/* ReadXPRam */
		(caddr_t)0x4080b62e,	/* WriteXPRam */
		(caddr_t)0x40806884,	/* jClkNoMem */
		(caddr_t)0x408398c2,	/* ADBAlternateInit */
		(caddr_t)0x4080cada,	/* Egret */
		(caddr_t)0x4080de14,	/* InitEgret */
		(caddr_t)0x408143b8,	/* ADBReInit_JTBL */
		(caddr_t)0x409bdb60,	/* ROMResourceMap List Head */
		(caddr_t)0x4083b3d8,	/* FixDiv */
		(caddr_t)0x4083b2e4,	/* FixMul */
	},
	/*
	 * PB 540, PB 550
	 * (PB 520?  Duo 280?)
	 */
	{			/* 8 */
		"68040 PowerBook ROMs",
		(caddr_t)0x400b2efc,	/* ADB int */
		(caddr_t)0x400d8e66,	/* PM int */
		(caddr_t)0x400b2e86,	/* ADBBase + 130 */
		(caddr_t)0x4000a360,	/* CountADBs */
		(caddr_t)0x4000a37a,	/* GetIndADB */
		(caddr_t)0x4000a3a6,	/* GetADBInfo */
		(caddr_t)0x4000a3ac,	/* SetADBInfo */
		(caddr_t)0x4000a752,	/* ADBReInit */
		(caddr_t)0x4000a3dc,	/* ADBOp */
		(caddr_t)0x400d9302,	/* PmgrOp */
		(caddr_t)0x4000c05c,	/* WriteParam */
		(caddr_t)0x4000c086,	/* SetDateTime */
		(caddr_t)0x4000c5cc,	/* InitUtil */
		(caddr_t)0x4000b186,	/* ReadXPRam */
		(caddr_t)0x4000b190,	/* WriteXPRam */
		(caddr_t)0x400b3c08,	/* jClkNoMem */
		(caddr_t)0x4000a818,	/* ADBAlternateInit */
		(caddr_t)0x40009ae6,	/* Egret */ /* From PB520 */
		(caddr_t)0x400147c4,	/* InitEgret */
		(caddr_t)0x400a7a5c,	/* ADBReInit_JTBL */
		(caddr_t)0x4007eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4001c406,	/* FixDiv, wild guess */
		(caddr_t)0x4001c312,	/* FixMul, wild guess */
	},
	/*
	 * Verified for the Q605
	 */
	{			/* 9 */
		"Quadra/Centris 605 ROMs",
		(caddr_t)0x408a9b56,	/* ADB int */
		(caddr_t)0x0,		/* PM int */
		(caddr_t)0x408b2f94,	/* ADBBase + 130 */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PmgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3bf8,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408a99c0,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408a82c0,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for Duo 270c, PB150
	 */
	{			/* 10 */
		"Duo 270C ROMs",
		(caddr_t)0x408b2efc,	/* ADB interrupt */
		(caddr_t)0x408885ec,	/* PB ADB interrupt */
		(caddr_t)0x408b2e86,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x408888ec,	/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3bf8,	/* jClkNoMem */ /* from PB 150 */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv, wild guess */
		(caddr_t)0x4081c312,	/* FixMul, wild guess */
	},
	/*
	 * Vectors verified for Performa/LC 550
	 */
	{			/* 11 */
		"P/LC 550 ROMs",
		(caddr_t)0x408d16d6,	/* ADB interrupt */
		(caddr_t)0x0,		/* PB ADB interrupt */
		(caddr_t)0x408b2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3c04,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408d1450,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408d24a4,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv for P550 */
		(caddr_t)0x4081c312,	/* FixMul for P550 */
	},
	/*
	 * Vectors verified for the MacTV
	 */
	{			/* 12 */
		"MacTV ROMs",
		(caddr_t)0x40acfed6,	/* ADB interrupt */
		(caddr_t)0x0,		/* PB ADB interrupt */
		(caddr_t)0x40ab2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x40a0a360,	/* CountADBs */
		(caddr_t)0x40a0a37a,	/* GetIndADB */
		(caddr_t)0x40a0a3a6,	/* GetADBInfo */
		(caddr_t)0x40a0a3ac,	/* SetADBInfo */
		(caddr_t)0x40a0a752,	/* ADBReInit */
		(caddr_t)0x40a0a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x40a0c05c,	/* WriteParam */
		(caddr_t)0x40a0c086,	/* SetDateTime */
		(caddr_t)0x40a0c5cc,	/* InitUtil */
		(caddr_t)0x40a0b186,	/* ReadXPRam */
		(caddr_t)0x40a0b190,	/* WriteXPRam */
		(caddr_t)0x40ab3bf4,	/* jClkNoMem */
		(caddr_t)0x40a0a818,	/* ADBAlternateInit */
		(caddr_t)0x40acfd40,	/* Egret */
		(caddr_t)0x40a147c4,	/* InitEgret */
		(caddr_t)0x40a038a0,	/* ADBReInit_JTBL */
		(caddr_t)0x40a7eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x40a1c406,	/* FixDiv */
		(caddr_t)0x40a1c312,	/* FixMul */
	},
	/*
	 * Vectors verified for the Quadra630
	 */
	{			/* 13 */
		"Quadra630 ROMs",
		(caddr_t)0x408a9bd2,	/* ADB int */
		(caddr_t)0x0,		/* PM intr */
 		(caddr_t)0x408b2f94,	/* ADBBase + 130 */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* Wild guess at ReadXPRam */
		(caddr_t)0x4080b190,	/* Wild guess at WriteXPRam */
		(caddr_t)0x408b39f4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408a99c0,	/* Egret */
		(caddr_t)0x408147c8,	/* InitEgret */
		(caddr_t)0x408a7ef8,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for LC III
	 */
	{			/* 14 */
		"LC III ROMs",
		(caddr_t)0x40814912,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x408b2f94,	/* ADBBase + 130 interupt */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b39b6,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408d2918,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for the LC520
	 */
	{			/* 15 */
		"MacLC520 ROMs",
		(caddr_t)0x408d16d6,	/* ADB interrupt */
		(caddr_t)0x0,		/* PB ADB interrupt */
		(caddr_t)0x408b2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3c04,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408d1450,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408d2460,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv for P520 */
		(caddr_t)0x4081c312,	/* FixMul for P520 */
	},
	/*
	 * Vectors verified for the LC 575/577/578
	 */
	{			/* 16 */
		"MacLC575 ROMs",
		(caddr_t)0x408a9b56,	/* ADB interrupt */
		(caddr_t)0x0,		/* PB ADB interrupt */
		(caddr_t)0x408b2f94,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3bf8,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408a99c0,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408a81a0,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv for P520 */
		(caddr_t)0x4081c312,	/* FixMul for P520 */
	},
	/*
	 * Vectors verified for the Quadra 950
	 */
	{			/* 17 */
		"Quadra950 class ROMs",
		(caddr_t)0x40814912,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x4080a4d8,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408038bc,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for the Mac IIfx
	 */
	{			/* 18 */
		"Mac IIfx ROMs",
		(caddr_t)0x40809f4a,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x4080a4d8,	/* ADBBase + 130 interupt */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x0,		/* Egret */
		(caddr_t)0x0,		/* InitEgret */
		(caddr_t)0x408037c0,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for the Performa 588 (and 580?)
	 */
	{			/* 19 */
		"Performa 580 ROMs",
		(caddr_t)0x4089a8be,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x408b2f94,	/* ADBBase + 130 interupt */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3bf4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408a99c0,	/* Egret */
		(caddr_t)0x408147c8,	/* InitEgret */
		(caddr_t)0x408a7f74,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/* Please fill these in! -BG */
};

d1294 4
a1297 4
	{MACH_MACII, "II", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACIIX, "IIx", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACIICX, "IIcx", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACSE30, "SE/30", "", MACH_CLASSII, &romvecs[0]},
d1300 5
a1304 5
	{MACH_MACIICI, "IIci", "", MACH_CLASSIIci, &romvecs[4]},
	{MACH_MACIISI, "IIsi", "", MACH_CLASSIIsi, &romvecs[2]},
	{MACH_MACIIVI, "IIvi", "", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACIIVX, "IIvx", "", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACIIFX, "IIfx", "", MACH_CLASSIIfx, &romvecs[18]},
d1307 12
a1318 12
	{MACH_MACQ700, "Quadra", " 700", MACH_CLASSQ, &romvecs[4]},
	{MACH_MACQ900, "Quadra", " 900", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ950, "Quadra", " 950", MACH_CLASSQ, &romvecs[17]},
	{MACH_MACQ800, "Quadra", " 800", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ650, "Quadra", " 650", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACC650, "Centris", " 650", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ605, "Quadra", " 605", MACH_CLASSQ, &romvecs[9]},
	{MACH_MACC610, "Centris", " 610", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ610, "Quadra", " 610", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ630, "Quadra", " 630", MACH_CLASSQ2, &romvecs[13]},
	{MACH_MACC660AV, "Centris", " 660AV", MACH_CLASSAV, &romvecs[7]},
	{MACH_MACQ840AV, "Quadra", " 840AV", MACH_CLASSAV, &romvecs[7]},
d1321 1
a1321 1
	{MACH_MACPB100, "PowerBook", " 100", MACH_CLASSPB, &romvecs[1]},
d1323 10
a1332 10
	{MACH_MACPB140, "PowerBook", " 140", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB145, "PowerBook", " 145", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB150, "PowerBook", " 150", MACH_CLASSDUO, &romvecs[10]},
	{MACH_MACPB160, "PowerBook", " 160", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB165, "PowerBook", " 165", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB165C, "PowerBook", " 165c", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB170, "PowerBook", " 170", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB180, "PowerBook", " 180", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB180C, "PowerBook", " 180c", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB500, "PowerBook", " 500", MACH_CLASSPB, &romvecs[8]},
d1335 6
a1340 6
	{MACH_MACPB210, "PowerBook Duo", " 210", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB230, "PowerBook Duo", " 230", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB250, "PowerBook Duo", " 250", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB270, "PowerBook Duo", " 270C", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB280, "PowerBook Duo", " 280", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB280C, "PowerBook Duo", " 280C", MACH_CLASSDUO, &romvecs[5]},
d1343 5
a1347 5
	{MACH_MACP600, "Performa", " 600", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACP460, "Performa", " 460", MACH_CLASSLC, &romvecs[14]},
	{MACH_MACP550, "Performa", " 550", MACH_CLASSLC, &romvecs[11]},
	{MACH_MACP580, "Performa", " 580", MACH_CLASSQ2, &romvecs[19]},
	{MACH_MACTV,   "TV",      "",      MACH_CLASSLC, &romvecs[12]},
d1350 7
a1356 7
	{MACH_MACLCII,  "LC", " II",  MACH_CLASSLC, &romvecs[3]},
	{MACH_MACLCIII, "LC", " III", MACH_CLASSLC, &romvecs[14]},
	{MACH_MACLC475, "LC", " 475", MACH_CLASSQ,  &romvecs[9]},
	{MACH_MACLC520, "LC", " 520", MACH_CLASSLC, &romvecs[15]},
	{MACH_MACLC575, "LC", " 575", MACH_CLASSQ2, &romvecs[16]},
	{MACH_MACCCLASSIC, "Color Classic", "", MACH_CLASSLC, &romvecs[3]},
	{MACH_MACCCLASSICII, "Color Classic"," II", MACH_CLASSLC, &romvecs[3]},
d1358 1
a1358 1
	{MACH_MACCLASSICII, "Classic", " II", MACH_CLASSLC, &romvecs[3]},
d1361 1
a1361 2
	{0, "Unknown", "", MACH_CLASSII, NULL},
	{0, NULL, NULL, 0, NULL},
a1418 8
int	mach_cputype(void);

int
mach_cputype()
{
	return (mac68k_machine.mach_processor);
}

d1493 2
a1494 3
	snprintf(cpu_model, sizeof cpu_model, "Apple Macintosh %s%s",
	    cpu_models[mac68k_machine.cpu_model_index].model_major,
	    cpu_models[mac68k_machine.cpu_model_index].model_minor);
d1573 1
a1573 1
	for (i = 0; cpu_models[i].model_major; i++)
a1576 3
	if (cpu_models[i].model_major == NULL)
		i--;

a1580 1
romvec_t *mrg_MacOSROMVectors = 0;
a1726 8

	/*
	 * Set up current ROM Glue vectors.  Actually now all we do
	 * is save the address of the ROM Glue Vector table. This gets
	 * used later when we re-map the vectors from MacOS Address
	 * Space to BSD Address Space.
	 */
	mrg_MacOSROMVectors = cpui->rom_vectors;
@


1.123
log
@Enable A/UX style interrupt routing on non-AV Centrises and Quadras, gives us
smarter spl levels and the clock drift is reduced; adapted from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2005/12/17 07:31:26 miod Exp $	*/
a116 2
void netintr(void);

a121 1
#include <mac68k/mac68k/macrom.h>
d126 2
a127 1
#include "ether.h"
d153 5
a157 2
extern u_long videoaddr;	/* Addr used in kernel for video. */
extern u_long videorowbytes;	/* Used in kernel for video. */
d300 1
a300 1
	 *	Can be called from locore.s and init_main.c.
d306 1
a306 1
#ifdef  DDB
d313 23
a335 1
	} else
d337 18
d499 2
d1124 1
a1124 1
	extern u_long bootdev, videobitdepth, videosize;
a1197 1
#ifndef SYMTAB_SPACE
a1198 1
#endif
d2614 4
a2617 3
	if (!get_physical(videoaddr, &phys))
		printf("get_mapping(): %s.  False start.\n", id);
	else {
d2627 7
a2633 4
				printf("mapping: %s.  Does it never end?\n",
				    id);
				printf("               Forcing VRAM size ");
				printf("to a conservative %ldK.\n", maxm/1024);
d2640 5
a2644 5
#ifdef DIAGNOSTIC
		printf("  %s internal video at addr 0x%x (phys 0x%x), ",
		    id, mac68k_vidlog, mac68k_vidphys);
		printf("len 0x%x.\n", mac68k_vidlen);
#endif
d2679 7
a2685 4
#ifdef DIAGNOSTIC
	printf("System RAM: %ld bytes in %ld pages.\n", addr, addr / NBPG);
	for (i = 0; i < numranges; i++) {
		printf("     Low = 0x%lx, high = 0x%lx\n", low[i], high[i]);
a2686 1
#endif
d2725 3
a2727 4
#ifdef DIAGNOSTIC
		printf("On-board video at addr 0x%lx (phys 0x%x), len 0x%x.\n",
		    videoaddr, mac68k_vidphys, mac68k_vidlen);
#endif
d2753 2
a2754 3
#if 0
			printf ("0x%lx --> 0x%lx\n", addr, phys);
#endif
d2773 3
a2775 2
						printf("get_mapping(): "
						    "Too many NuBus ranges.\n");
d2789 6
a2794 5
#if 0
		printf("Non-system RAM (nubus, etc.):\n");
		for (i = 0; i < nbnumranges; i++) {
			printf("     Log = 0x%lx, Phys = 0x%lx, Len = 0x%lx (%lu)\n",
			    nblog[i], nbphys[i], nblen[i], nblen[i]);
a2795 1
#endif
d2822 2
a2823 3
#ifdef DIAGNOSTIC
				printf("Checking for Internal Video ");
#endif
d2845 3
a2847 4
#ifdef DIAGNOSTIC
				printf( "  no internal video at address 0 -- "
					"videoaddr is 0x%lx.\n", videoaddr);
#endif
d2850 7
a2856 7
#ifdef DIAGNOSTIC
			printf("  Video address = 0x%lx\n", videoaddr);
			printf("  Int video starts at 0x%x\n",
			    mac68k_vidlog);
			printf("  Length = 0x%x (%d) bytes\n",
			    mac68k_vidlen, mac68k_vidlen);
#endif
@


1.122
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2005/11/15 07:02:36 miod Exp $	*/
a2224 1
	int setup_mrg_vectors = 0;
d2238 4
d2248 1
a2248 1
		VIA2 = 1;
a2254 1
		setup_mrg_vectors = 1;
d2257 1
a2257 1
		VIA2 = 1;
d2275 1
a2275 1
		VIA2 = 0x13;
d2287 3
d2291 13
d2306 1
a2306 1
		VIA2 = 1;
d2315 1
a2315 1
		VIA2 = 0x13;
d2324 1
a2324 1
		VIA2 = 0x13;
d2333 1
a2333 1
		VIA2 = 0x13;
d2342 1
a2342 1
		VIA2 = 0x13;
d2351 1
a2351 1
		VIA2 = 0xd;
d2369 1
a2369 2
	if ((mac68k_machine.serial_console & 0x03) == 0 || setup_mrg_vectors)
		mrg_MacOSROMVectors = cpui->rom_vectors;
@


1.121
log
@More typos (especially indicies -> indices), checked with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2005/11/06 17:59:57 miod Exp $	*/
d330 1
a330 1
	vm_size_t size = 0;	/* To avoid compiler warning */
@


1.120
log
@Factorize setregs() code to m68k-common location.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2005/09/27 21:50:39 miod Exp $	*/
d358 1
a358 1
		/* fix older booters with indicies, not versions */
@


1.119
log
@Do not initialize physmem to a magic value at compile time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2005/08/06 19:51:44 martin Exp $	*/
a555 56

/*
 * Set registers on exec.
 * XXX Should clear registers except sp, pc,
 * but would break init; should be fixed soon.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long  stack;
	register_t *retval;
{
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
	struct frame *frame = (struct frame *)p->p_md.md_regs;

	frame->f_sr = PSL_USERSET;
	frame->f_pc = pack->ep_entry & ~1;
	frame->f_regs[D0] = 0;
	frame->f_regs[D1] = 0;
	frame->f_regs[D2] = 0;
	frame->f_regs[D3] = 0;
	frame->f_regs[D4] = 0;
	frame->f_regs[D5] = 0;
	frame->f_regs[D6] = 0;
	frame->f_regs[D7] = 0;
	frame->f_regs[A0] = 0;
	frame->f_regs[A1] = 0;
	frame->f_regs[A2] = (int)PS_STRINGS;
	frame->f_regs[A3] = 0;
	frame->f_regs[A4] = 0;
	frame->f_regs[A5] = 0;
	frame->f_regs[A6] = 0;
	frame->f_regs[SP] = stack;

	/* restore a null state frame */
	p->p_addr->u_pcb.pcb_fpregs.fpf_null = 0;

	if (fputype) {
		m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);
	}

#ifdef COMPAT_SUNOS
	/*
	 * SunOS' ld.so does self-modifying code without knowing
	 * about the 040's cache purging needs.  So we need to uncache
	 * writeable executable pages.
	 */
	if (p->p_emul == &emul_sunos)
		p->p_md.md_flags |= MDP_UNCACHE_WX;
	else
		p->p_md.md_flags &= ~MDP_UNCACHE_WX;
#endif
}
@


1.118
log
@overhaul the grf driver:

- Simplify grfmv_phys() to work like grfiv_phys(), and eliminate the
  second argument to both, as we don't use it anyway.
- Handle fbbase and fboff consistently throughout.
- Eliminate grfaddr() by pulling it into grfmmap(), which is the
  only place it was used, previously.
- grfmap() now gets the physical address of the framebuffer from
  the appropriate driver, rather than try to compute it by itself.
  Be careful with aligning the base to a page address and increase
  the length of the mapped region appropriately.
- Store the PA of the framebuffer in the softc.  This eliminates the need
  for the sc_phys callback; we can just store the PA in the grfbus attach
  args, rather than a function pointer, which simplifies the code nicely.
- Disable Valkyrie interrupts on the Quadra 630
- New and improved console framebuffer initialization and autoconfig.  This
  resolves a great many issues, including Performa 58x interrupt handling
  and offset displays on some models.
- Remove unused grf ioctls
- Some KNF and other minor things

help and ok miod@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 2005/07/23 23:30:56 martin Exp $	*/
a118 1
#define	MAXMEM	64*1024	/* XXX - from cmap.h */
d194 1
a194 1
int	physmem = MAXMEM;	/* max supported memory, changes to actual */
@


1.117
log
@vm_offset_t -> vaddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2005/01/11 21:07:19 martin Exp $	*/
d2047 1
a2047 1
} intvid_info[] =  {
d2056 2
d2062 18
a2079 16
	{ MACH_MACLC520,	(caddr_t)0x60000000,	1024 * 1024 },
	{ MACH_MACLC475,	(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACLC475_33,	(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACLC575,	(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACC610,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACC650,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACP580,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ605,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ605_33,	(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ610,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ630,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ650,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ700,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ800,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ900,		(caddr_t)0xf9000000,	1024 * 1024 },
	{ MACH_MACQ950,		(caddr_t)0xf9000000,	1024 * 1024 },
a2283 1
	int i;
a2402 13
	 * Set `internal' framebuffer location and length, if we know
	 * what they are.
	 */
	for (i = 0; intvid_info[i].machineid; i++) {
		if (mac68k_machine.machineid == intvid_info[i].machineid) {
			mac68k_vidlog = mac68k_vidphys =
			    (u_int32_t)intvid_info[i].fbbase;
			mac68k_vidlen = (u_int32_t)intvid_info[i].fblen;
			break;
		}
	}

	/*
d2551 1
a2554 1
	extern u_int macos_tc;
d2681 32
d2715 2
a2716 3
		 * We've already figured out where internal video is in
		 * setmachdep() (by using intvid_info[]).  Tell the user
		 * what we know.
d2719 2
a2720 2
		printf("On-board video at addr 0x%x (phys 0x%x), len 0x%x.\n",
		    mac68k_vidlog, mac68k_vidphys, mac68k_vidlen);
@


1.116
log
@rename via_shutdown() to via_powerdown() and remove unused prototype to
shrink diff to NetBSD

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2004/12/02 22:00:31 martin Exp $	*/
d141 1
a141 1
vm_offset_t SCSIBase;
d247 1
a247 1
	extern vm_offset_t avail_start;
d330 1
a330 1
	vm_offset_t minaddr, maxaddr;
d2427 1
a2427 1
	vm_offset_t base;
@


1.115
log
@move IPL setup to intr.c

ok miod@@

>From: NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2004/12/02 19:37:25 miod Exp $	*/
a556 1
void via_shutdown(void);
d672 1
a672 1
			via_shutdown();
@


1.114
log
@Make BUFCACHEPERCENT adjustable through UKC, like all other arches do.

(This means twice as less buffers on hp300 with unmodified GENERIC kernels
now)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2004/11/25 18:32:11 miod Exp $	*/
a203 13
 * Some of the below are not used yet, but might be used someday on the
 * Q700/900/950 where the interrupt controller may be reprogrammed to
 * interrupt on different levels as listed in locore.s
 */
unsigned short  mac68k_ttyipl = PSL_S | PSL_IPL2;
unsigned short  mac68k_bioipl = PSL_S | PSL_IPL2;
unsigned short  mac68k_netipl = PSL_S | PSL_IPL2;
unsigned short  mac68k_impipl = PSL_S | PSL_IPL2;
unsigned short  mac68k_clockipl = PSL_S | PSL_IPL2;
unsigned short  mac68k_statclockipl = PSL_S | PSL_IPL2;


/*
d279 3
a2477 4
		mac68k_bioipl = PSL_S | PSL_IPL4;
		mac68k_netipl = PSL_S | PSL_IPL4;
		mac68k_impipl = PSL_S | PSL_IPL4;
		mac68k_statclockipl = PSL_S | PSL_IPL4;
@


1.113
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2004/03/10 23:02:53 tom Exp $	*/
d182 5
d192 1
d497 1
d499 6
a504 11
	 * Determine how many buffers to allocate.
	 * Use 10% of memory for the first 2 Meg, then 5% of the remaining
	 * memory. Insure a minimum of 16 buffers.
	 */
	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) / 20;
	}

d510 10
@


1.112
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2004/02/19 18:46:18 miod Exp $	*/
a1032 16
int netisr;

void
netintr()
{
#define	DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << (bit))) { \
			netisr &= ~(1 << (bit)); \
			(fn)(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef	DONETISR
}

a1157 1
	/* sccaddr = getenv("MACOS_SCC"); */
d1181 1
d1185 1
a1990 1
	{MACH_MACQ605_33, "Quadra", " 605/33", MACH_CLASSQ, &romvecs[9]},
a2029 1
	{MACH_MACLC475_33, "LC", " 475/33", MACH_CLASSQ,  &romvecs[9]},
a2302 1
		mac68k_machine.sccClkConst = 115200;
a2312 1
		mac68k_machine.sccClkConst = 115200;
a2330 1
		mac68k_machine.sccClkConst = 115200;
a2345 1
		mac68k_machine.sccClkConst = 115200;
a2354 1
		mac68k_machine.sccClkConst = 115200;
a2363 1
		mac68k_machine.sccClkConst = 115200;
a2372 1
		mac68k_machine.sccClkConst = 115200;
a2381 1
		mac68k_machine.sccClkConst = 115200;
a2390 1
		mac68k_machine.sccClkConst = 115200;	/* XXX unverified */
@


1.111
log
@Kill <sys/clist.h> - nothing uses it since years.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2004/01/27 16:16:27 miod Exp $	*/
d627 3
a629 1
		howto |= RB_HALT;
@


1.110
log
@Only install the fpsp exception vectors if the cpu is a 68040.
Thus, it becomes unnecessary to check for the cpu type in the exception
handlers, saving a few cycles and a few bytes.

Tested by various people on hp300, mac68k, mvme68k, 68040 and non-68040.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2003/12/20 20:08:17 miod Exp $	*/
a88 1
#include <sys/clist.h>
@


1.109
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2003/11/06 21:09:34 mickey Exp $	*/
d526 3
d541 4
d550 1
@


1.108
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2003/06/02 23:27:49 millert Exp $	*/
d439 2
a440 2
	printf("avail mem = %lu (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
@


1.107
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.106 2003/05/09 23:10:21 art Exp $	*/
d1023 2
@


1.106
log
@No need to map the message buffer executable.

fries@@ niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2003/04/06 18:54:19 ho Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.105
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2003/02/26 22:59:32 miod Exp $	*/
d355 2
a356 1
		    VM_PROT_ALL, VM_PROT_ALL|PMAP_WIRED);
@


1.104
log
@Let this compile if no DDB
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.103 2003/02/24 17:37:59 miod Exp $	*/
d2184 1
a2184 1
	sprintf(cpu_model, "Apple Macintosh %s%s",
d2193 1
a2193 1
		strcat(cpu_model, ", 68040 CPU");
d2196 1
a2196 1
		strcat(cpu_model, ", 68030 CPU");
d2199 1
a2199 1
		strcat(cpu_model, ", 68020 CPU");
d2202 1
a2202 1
		strcat(cpu_model, ", unknown CPU");
d2212 1
a2212 1
		strcat(cpu_model, "+MMU");
d2215 1
a2215 1
		strcat(cpu_model, ", MC68851 MMU");
d2230 1
a2230 1
		strcat(cpu_model, "+FPU");
d2233 1
a2233 1
		strcat(cpu_model, ", MC6882 FPU");
d2236 1
a2236 1
		strcat(cpu_model, ", MC6881 FPU");
d2239 1
a2239 1
		strcat(cpu_model, ", unknown FPU");
d2242 1
a2242 1
		/*strcat(cpu_model, ", no FPU");*/
d2250 1
a2250 1
		strcat(cpu_model, ", 4k on-chip physical I/D caches");
@


1.103
log
@Defer the iomem extent initialization until the MMU is enabled. This is
necessary since the last pmap changes, to get proper serial console
initialization.
From NetBSD, tested by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2003/01/04 22:11:47 miod Exp $	*/
d1146 1
d1148 1
@


1.102
log
@Remove COMPAT_NOMID. It was deprecated since a long time, the man page wass
misleading, and it was never used anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2002/12/17 23:11:32 millert Exp $	*/
d277 14
a2444 14

	/*
	 * Initialize the I/O mem extent map.
	 * Note: we don't have to check the return value since
	 * creation of a fixed extent map will never fail (since
	 * descriptor storage has already been allocated).
	 *
	 * N.B. The iomem extent manages _all_ physical addresses
	 * on the machine.  When the amount of RAM is found, all
	 * extents of RAM are allocated from the map.
	 */
	iomem_ex = extent_create("iomem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)iomem_ex_storage, sizeof(iomem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
@


1.101
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2002/04/29 23:43:03 miod Exp $	*/
a1105 6

#ifdef COMPAT_NOMID
	/* Check to see if MID == 0. */
	if (((struct exec *)epp->ep_hdr)->a_midmag == ZMAGIC)
		return exec_aout_prep_oldzmagic(p, epp);
#endif
@


1.100
log
@Enforce the bio <= net <= tty <= imp <= clock spl level ordering by fixing
the tty spl, too low.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2002/04/27 01:52:13 miod Exp $	*/
a105 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a474 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.99
log
@Lots of cleanup to catch up with other m68k-based ports and modern code,
including:
- use netisr_dispatch
- extract an allocsys() function from cpu_startup()
- updated cachectl()
- a few fixes in trap()
and more...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2002/04/16 15:32:59 miod Exp $	*/
d213 1
a213 1
unsigned short  mac68k_ttyipl = PSL_S | PSL_IPL1;
@


1.98
log
@Using a dull device to probe the FPU is ridiculous, replace it with an early
initialization.
While there, rework the cpu_model string creation so that it gets a more
useful content.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2002/03/23 13:28:34 espie Exp $	*/
d144 1
a144 1
char	machine[] = "mac68k";	/* cpu "architecture" */
d230 1
a230 1
static	long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
d237 2
a238 2
static void	identifycpu(void);
static u_long	get_physical(u_int, u_long *);
d240 1
d327 1
a327 1
	caddr_t v, firstaddr;
d345 1
a345 1
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
d347 1
a347 2
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d370 1
a370 1
	printf("real mem = %d\n", ctob(physmem));
d373 2
a374 73
	 * Allocate space for system data structures.
	 * The first available real memory address is in "firstaddr".
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
	 * As pages of memory are allocated and cleared,
	 * "firstaddr" is incremented.
	 * An index into the kernel page table corresponding to the
	 * virtual memory address maintained in "v" is kept in "mapaddr".
	 */
	/*
	 * Make two passes.  The first pass calculates how much memory is
	 * needed and allocates it.  The second pass assigns virtual
	 * addresses to the various data structures.
	 */
	firstaddr = 0;
again:
	v = (caddr_t)firstaddr;

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
	/*
	 * Determine how many buffers to allocate.
	 * Use 10% of memory for the first 2 Meg, 5% of the remaining
	 * memory. Insure a minimum of 16 buffers.
	 * We allocate 3/4 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) / 20;
	}

	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	valloc(buf, struct buf, nbuf);

	/*
	 * End of first pass, size has been calculated so allocate memory
	 */
	if (firstaddr == 0) {
		size = (vm_size_t)(v - firstaddr);
		firstaddr = (caddr_t)uvm_km_alloc(kernel_map, round_page(size));
		if (firstaddr == 0)
			panic("startup: no room for tables");
		goto again;
	}
	/*
	 * End of second pass, addresses have been assigned
d376 4
a379 1
	if ((vm_size_t)(v - firstaddr) != size)
d387 1
a387 1
	if (uvm_map(kernel_map, (vm_offset_t *) &buffers, round_page(size),
d391 1
a391 1
	minaddr = (vm_offset_t)buffers;
d395 2
a396 2
		vm_size_t curbufsize;
		vm_offset_t curbuf;
d405 1
a405 1
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
d420 1
d434 4
a437 3
	printf("avail mem = %ld\n", ptoa(uvmexp.free));
	printf("using %d buffers containing %d bytes of memory\n",
	    nbuf, bufpages * PAGE_SIZE);
d462 58
d564 1
a564 1
	register struct proc *p;
a613 1
struct pcb dumppcb;
d617 1
a617 1
	register int howto;
d622 2
a623 2
	if (curproc)
		savectx((struct pcb *)curproc->p_addr);
a632 5
		extern struct proc proc0;
		/* kill the panic on that boot away */
		if (curproc == NULL)
			curproc = &proc0;

a633 4

		/*
		 * Release inodes, sync and unmount the filesystems.
		 */
a635 1
#ifdef notyet
d642 1
d644 5
a651 5
#else
# ifdef DIAGNOSTIC
		printf("OpenBSD/mac68k does not trust itself to update the clock on shutdown.\n");
# endif
#endif
a658 1
		savectx(&dumppcb);	/* XXX this goes away soon */
d687 1
a687 1
	pmap_enter(pmap_kernel(), (vm_offset_t)maxaddr, (vm_offset_t)maxaddr,
a778 1
	int chdrsize;	/* size of dump header */
a784 1

d788 1
a788 2
	if (bdevsw[maj].d_psize == NULL) {
		printf ("dumpconf: returning for d_psize\n");
a789 1
	}
d791 2
a792 1
	chdrsize = cpu_dumpsize();
d797 1
d799 9
a807 14
	/*
	 * Check to see if we will fit.  Note we always skip the
	 * first block in case there is a disk label there.
	 */
	if (nblks < (ctod(dumpsize) + chdrsize + ctod(1))) {
		dumpsize = 0;
		dumplo = -1;
		return;
	}

	/*
	 * Put dump at the end of the partition.
	 */
	dumplo = (nblks - 1) - ctod(dumpsize) - chdrsize;
d818 1
a818 1
	vm_offset_t maddr;	/* PA being dumped */
d872 1
a872 1
		pmap_enter(pmap_kernel(), (vm_offset_t)vmmap, maddr,
d877 1
a877 1
 bad:
a944 2
void straytrap(int, int);

d952 1
d956 1
d965 1
a965 1
	register caddr_t addr;
d967 1
a967 1
	register int i;
d982 1
a982 1
	register caddr_t addr;
d984 1
a984 1
	register int i;
a986 5
#ifdef lint
	i = *addr;
	if (i)
		return (0);
#endif
d999 1
a999 1
	register caddr_t addr;
d1001 1
a1001 1
	register int i;
a1003 5
#ifdef lint
	i = *addr;
	if (i)
		return (0);
#endif
d1016 1
a1016 1
	register caddr_t addr;
d1018 1
a1018 1
	register int i;
a1020 5
#ifdef lint
	i = *addr;
	if (i)
		return (0);
#endif
d1034 9
a1042 50
#ifdef INET
#if NETHER
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
#endif
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
#endif
#ifdef INET6
	if (netisr & (1 << NETISR_IPV6)) {
		netisr &= ~(1 << NETISR_IPV6);
		ip6intr();
	}
#endif
#ifdef NETATALK
	if (netisr & (1 << NETISR_ATALK)) {
		netisr &= ~(1 << NETISR_ATALK);
		atintr();
	}
#endif
#ifdef NS
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
#endif
#ifdef ISO
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
#endif
#include "ppp.h"
#if NPPP > 0
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
#endif
#include "bridge.h"
#if NBRIDGE > 0
	if (netisr & (1 << NETISR_BRIDGE)) {
		netisr &= ~(1 << NETISR_BRIDGE);
		bridgeintr();
	}
#endif
d1056 1
a1056 1
	if (nmihanddeep++)
d1058 2
a1059 2
/*	regdump(&(frame.F_t), 128);
	dumptrace(); */
d1067 1
d1147 2
a1148 2
void		getenvvars(u_long, char *);
static long	getenv(char *);
d1224 1
d1230 1
d1256 1
a1256 1
static char	toupper(char);
d1258 1
a1258 1
static char
d1269 1
a1269 1
static long
d1394 1
a1394 1
static romvec_t romvecs[] =
a1982 1

d2266 1
a2266 1
static void	get_machine_info(void);
d2268 1
a2268 1
static void
d2552 1
a2552 1
static u_long gray_nextaddr = 0;
d2601 1
a2601 1
static u_long
d2657 1
a2657 1
static void	check_video(char *, u_long, u_long);
d2659 1
a2659 1
static void
d2688 1
d2692 1
d2727 1
a2727 1
#if 1
d2740 1
d2743 1
d2838 1
d2840 1
d2862 1
d2865 1
d2868 1
d2874 1
@


1.97
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2002/03/14 03:15:55 millert Exp $	*/
d244 1
d2066 4
a2069 4
	{MACH_MACII, "II ", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACIIX, "IIx ", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACIICX, "IIcx ", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACSE30, "SE/30 ", "", MACH_CLASSII, &romvecs[0]},
d2072 5
a2076 5
	{MACH_MACIICI, "IIci ", "", MACH_CLASSIIci, &romvecs[4]},
	{MACH_MACIISI, "IIsi ", "", MACH_CLASSIIsi, &romvecs[2]},
	{MACH_MACIIVI, "IIvi ", "", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACIIVX, "IIvx ", "", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACIIFX, "IIfx ", "", MACH_CLASSIIfx, &romvecs[18]},
d2079 13
a2091 13
	{MACH_MACQ700, "Quadra", " 700 ", MACH_CLASSQ, &romvecs[4]},
	{MACH_MACQ900, "Quadra", " 900 ", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ950, "Quadra", " 950 ", MACH_CLASSQ, &romvecs[17]},
	{MACH_MACQ800, "Quadra", " 800 ", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ650, "Quadra", " 650 ", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACC650, "Centris", " 650 ", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ605, "Quadra", " 605 ", MACH_CLASSQ, &romvecs[9]},
	{MACH_MACQ605_33, "Quadra", " 605/33 ", MACH_CLASSQ, &romvecs[9]},
	{MACH_MACC610, "Centris", " 610 ", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ610, "Quadra", " 610 ", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ630, "Quadra", " 630 ", MACH_CLASSQ2, &romvecs[13]},
	{MACH_MACC660AV, "Centris", " 660AV ", MACH_CLASSAV, &romvecs[7]},
	{MACH_MACQ840AV, "Quadra", " 840AV ", MACH_CLASSAV, &romvecs[7]},
d2094 1
a2094 1
	{MACH_MACPB100, "PowerBook", " 100 ", MACH_CLASSPB, &romvecs[1]},
d2096 10
a2105 10
	{MACH_MACPB140, "PowerBook", " 140 ", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB145, "PowerBook", " 145 ", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB150, "PowerBook", " 150 ", MACH_CLASSDUO, &romvecs[10]},
	{MACH_MACPB160, "PowerBook", " 160 ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB165, "PowerBook", " 165 ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB165C, "PowerBook", " 165c ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB170, "PowerBook", " 170 ", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB180, "PowerBook", " 180 ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB180C, "PowerBook", " 180c ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB500, "PowerBook", " 500 ", MACH_CLASSPB, &romvecs[8]},
d2108 6
a2113 6
	{MACH_MACPB210, "PowerBook Duo", " 210 ", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB230, "PowerBook Duo", " 230 ", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB250, "PowerBook Duo", " 250 ", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB270, "PowerBook Duo", " 270C ", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB280, "PowerBook Duo", " 280 ", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB280C, "PowerBook Duo", " 280C ", MACH_CLASSDUO, &romvecs[5]},
d2116 5
a2120 5
	{MACH_MACP600, "Performa", " 600 ", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACP460, "Performa", " 460 ", MACH_CLASSLC, &romvecs[14]},
	{MACH_MACP550, "Performa", " 550 ", MACH_CLASSLC, &romvecs[11]},
	{MACH_MACP580, "Performa", " 580 ", MACH_CLASSQ2, &romvecs[19]},
	{MACH_MACTV,   "TV ",      "",      MACH_CLASSLC, &romvecs[12]},
d2123 8
a2130 8
	{MACH_MACLCII,  "LC", " II ",  MACH_CLASSLC, &romvecs[3]},
	{MACH_MACLCIII, "LC", " III ", MACH_CLASSLC, &romvecs[14]},
	{MACH_MACLC475, "LC", " 475 ", MACH_CLASSQ,  &romvecs[9]},
	{MACH_MACLC475_33, "LC", " 475/33 ", MACH_CLASSQ,  &romvecs[9]},
	{MACH_MACLC520, "LC", " 520 ", MACH_CLASSLC, &romvecs[15]},
	{MACH_MACLC575, "LC", " 575 ", MACH_CLASSQ2, &romvecs[16]},
	{MACH_MACCCLASSIC, "Color Classic ", "", MACH_CLASSLC, &romvecs[3]},
	{MACH_MACCCLASSICII, "Color Classic"," II ", MACH_CLASSLC, &romvecs[3]},
d2132 1
a2132 1
	{MACH_MACCLASSICII, "Classic", " II ", MACH_CLASSLC, &romvecs[3]},
d2198 65
a2262 1
static void
d2265 1
d2267 8
a2274 1
	char *mpu;
d2276 3
d2280 6
d2287 17
a2303 1
		mpu = ("(68020)");
d2305 20
a2324 2
	case CPU_68030:
		mpu = ("(68030)");
d2326 2
a2327 2
	case CPU_68040:
		mpu = ("(68040)");
d2330 1
a2330 1
		mpu = ("(unknown processor)");
d2333 7
a2339 4
	sprintf(cpu_model, "Apple Macintosh %s%s %s",
	    cpu_models[mac68k_machine.cpu_model_index].model_major,
	    cpu_models[mac68k_machine.cpu_model_index].model_minor,
	    mpu);
d2341 1
d2343 1
@


1.96
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2002/03/14 01:26:36 millert Exp $	*/
d395 3
@


1.95
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2002/01/23 17:51:52 art Exp $	*/
d242 1
a242 1
int	cpu_dump __P((int (*)(dev_t, daddr_t, caddr_t, size_t), daddr_t *));
@


1.94
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2002/01/23 17:35:56 art Exp $	*/
d128 1
a128 1
void netintr __P((void));
d179 1
a179 1
int	(*mac68k_bell_callback) __P((void *, int, int, int));
d237 2
a238 2
static void	identifycpu __P((void));
static u_long	get_physical __P((u_int, u_long *));
d240 2
a241 2
void	initcpu __P((void));
int	cpu_dumpsize __P((void));
d243 1
a243 1
void	cpu_init_kcore_hdr __P((void));
d246 4
a249 4
void	dumpsys __P((void));
void	mac68k_init __P((void));
void	straytrap __P((int, int));
void	nmihand __P((struct frame));
d528 2
a529 2
	extern void (*vectab[256]) __P((void));
	void addrerr4060 __P((void));
d532 1
a532 1
	void buserr60 __P((void));
d535 1
a535 1
	void buserr40 __P((void));
d557 1
a557 1
void doboot __P((void))
d559 1
a559 1
void via_shutdown __P((void));
d754 1
a754 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d838 1
a838 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d967 1
a967 1
void straytrap __P((int, int));
d983 1
a983 1
int badaddr __P((caddr_t));
d1126 1
a1126 1
void	nmihand __P((struct frame));
d1154 1
a1154 1
int	get_top_of_ram __P((void));
d1210 2
a1211 2
		extern int sunos_exec_aout_makecmds __P((struct proc *,
			        struct exec_package *));
d1224 2
a1225 2
void		getenvvars __P((u_long, char *));
static long	getenv __P((char *));
d1331 1
a1331 1
static char	toupper __P((char));
d2186 1
a2186 1
int	mach_cputype __P((void));
d2222 1
a2222 1
static void	get_machine_info __P((void));
d2245 1
a2245 1
void	setmachdep __P((void));
d2548 2
a2549 2
extern u_long ptest040 __P((caddr_t addr, u_int fc));
extern int get_pte __P((u_int addr, u_long pte[2], u_short * psr));
d2613 1
a2613 1
static void	check_video __P((char *, u_long, u_long));
d2830 1
a2830 1
void printstar __P((void));
d2859 1
a2859 1
	int (*callback) __P((void *, int, int, int));
@


1.93
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2002/01/16 20:50:16 miod Exp $	*/
a495 3

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.92
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2001/12/08 02:24:06 art Exp $	*/
a182 1
struct vm_map *mb_map = NULL;
@


1.91
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2001/11/28 16:13:28 art Exp $	*/
a83 1
#include <sys/map.h>
@


1.91.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2002/01/23 17:51:52 art Exp $	*/
d84 1
d184 1
d498 3
@


1.91.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91.2.1 2002/01/31 22:55:13 niklas Exp $	*/
d128 1
a128 1
void netintr(void);
d144 1
a144 1
char	machine[] = MACHINE;	/* from <machine/param.h> */
d179 1
a179 1
int	(*mac68k_bell_callback)(void *, int, int, int);
d213 1
a213 1
unsigned short  mac68k_ttyipl = PSL_S | PSL_IPL2;
d230 1
a230 1
long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
d237 2
a238 2
void	identifycpu(void);
u_long	get_physical(u_int, u_long *);
d240 4
a243 6
caddr_t	allocsys(caddr_t);
void	initcpu(void);
int	cpu_dumpsize(void);
int	cpu_dump(int (*)(dev_t, daddr_t, caddr_t, size_t), daddr_t *);
void	cpu_init_kcore_hdr(void);
int	fpu_probe(void);
d246 4
a249 4
void	dumpsys(void);
void	mac68k_init(void);
void	straytrap(int, int);
void	nmihand(struct frame);
d325 1
a325 1
	caddr_t v;
d343 1
a343 1
		pmap_enter(pmap_kernel(), (vaddr_t)msgbufp + i * NBPG,
d345 2
a346 1
		    VM_PROT_ALL, VM_PROT_ALL|PMAP_WIRED);
d369 1
a369 1
	printf("real mem = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);
d372 60
a431 2
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addressses.
d433 11
a443 4
	size = (vsize_t)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(size))) == 0)
		panic("startup: no room for tables");
	if ((allocsys(v) - v) != size)
d451 1
a451 1
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
d455 1
a455 1
	minaddr = (vaddr_t)buffers;
d459 2
a460 2
		vsize_t curbufsize;
		vaddr_t curbuf;
d469 1
a469 1
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
a483 1

d497 3
a499 4
	printf("avail mem = %lu (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
	    nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
a523 58
/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))

#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
	/*
	 * Determine how many buffers to allocate.
	 * Use 10% of memory for the first 2 Meg, then 5% of the remaining
	 * memory. Insure a minimum of 16 buffers.
	 */
	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) / 20;
	}

	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	valloc(buf, struct buf, nbuf);
	return (v);
}

d528 2
a529 2
	extern void (*vectab[256])(void);
	void addrerr4060(void);
d532 1
a532 1
	void buserr60(void);
d535 1
a535 1
	void buserr40(void);
d557 1
a557 1
void doboot(void)
d559 1
a559 1
void via_shutdown(void);
d568 1
a568 1
	struct proc *p;
d618 1
d622 1
a622 1
	int howto;
d627 2
a628 2
	if (curproc && curproc->p_addr)
		savectx(&curproc->p_addr->u_pcb);
d638 5
d644 4
d650 1
a656 1
#ifdef notyet
a657 5
#else
#ifdef DIAGNOSTIC
			printf("OpenBSD/mac68k does not trust itself to update the clock on shutdown.\n");
#endif
#endif
d661 5
d673 1
d702 1
a702 1
	pmap_enter(pmap_kernel(), (vaddr_t)maxaddr, (vaddr_t)maxaddr,
d754 1
a754 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d794 1
d801 1
d805 2
a806 1
	if (bdevsw[maj].d_psize == NULL)
d808 1
d810 1
a810 2
	if (nblks <= ctod(1))
		return;
a814 1
	dumpsize += cpu_dumpsize();
d816 14
a829 9
	/* Always skip the first block, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize < dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
d838 1
a838 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d840 1
a840 1
	vaddr_t maddr;	/* PA being dumped */
d894 1
a894 1
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
d899 1
a899 1
bad:
d967 2
a975 1
#ifdef DEBUG
a978 1
#endif
d983 1
a983 1
int badaddr(caddr_t);
d987 1
a987 1
	caddr_t addr;
d989 1
a989 1
	int i;
d1004 1
a1004 1
	caddr_t addr;
d1006 1
a1006 1
	int i;
d1009 5
d1026 1
a1026 1
	caddr_t addr;
d1028 1
a1028 1
	int i;
d1031 5
d1048 1
a1048 1
	caddr_t addr;
d1050 1
a1050 1
	int i;
d1053 5
d1071 50
a1120 9
#define	DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << (bit))) { \
			netisr &= ~(1 << (bit)); \
			(fn)(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef	DONETISR
d1126 1
a1126 1
void	nmihand(struct frame);
d1134 1
a1134 1
	if (nmihanddeep)
d1136 2
a1137 2
	nmihanddeep = 1;

a1144 1

d1154 1
a1154 1
int	get_top_of_ram(void);
d1210 2
a1211 2
		extern int sunos_exec_aout_makecmds(struct proc *,
			        struct exec_package *);
d1224 2
a1225 2
void	getenvvars(u_long, char *);
long	getenv(char *);
a1300 1
#if defined(DDB) || NKSYMS > 0
a1305 1
#endif
d1331 1
a1331 1
char	toupper(char);
d1333 1
a1333 1
char
d1344 1
a1344 1
long
d1469 1
a1469 1
romvec_t romvecs[] =
d2058 1
d2062 4
a2065 4
	{MACH_MACII, "II", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACIIX, "IIx", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACIICX, "IIcx", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACSE30, "SE/30", "", MACH_CLASSII, &romvecs[0]},
d2068 5
a2072 5
	{MACH_MACIICI, "IIci", "", MACH_CLASSIIci, &romvecs[4]},
	{MACH_MACIISI, "IIsi", "", MACH_CLASSIIsi, &romvecs[2]},
	{MACH_MACIIVI, "IIvi", "", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACIIVX, "IIvx", "", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACIIFX, "IIfx", "", MACH_CLASSIIfx, &romvecs[18]},
d2075 13
a2087 13
	{MACH_MACQ700, "Quadra", " 700", MACH_CLASSQ, &romvecs[4]},
	{MACH_MACQ900, "Quadra", " 900", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ950, "Quadra", " 950", MACH_CLASSQ, &romvecs[17]},
	{MACH_MACQ800, "Quadra", " 800", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ650, "Quadra", " 650", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACC650, "Centris", " 650", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ605, "Quadra", " 605", MACH_CLASSQ, &romvecs[9]},
	{MACH_MACQ605_33, "Quadra", " 605/33", MACH_CLASSQ, &romvecs[9]},
	{MACH_MACC610, "Centris", " 610", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ610, "Quadra", " 610", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ630, "Quadra", " 630", MACH_CLASSQ2, &romvecs[13]},
	{MACH_MACC660AV, "Centris", " 660AV", MACH_CLASSAV, &romvecs[7]},
	{MACH_MACQ840AV, "Quadra", " 840AV", MACH_CLASSAV, &romvecs[7]},
d2090 1
a2090 1
	{MACH_MACPB100, "PowerBook", " 100", MACH_CLASSPB, &romvecs[1]},
d2092 10
a2101 10
	{MACH_MACPB140, "PowerBook", " 140", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB145, "PowerBook", " 145", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB150, "PowerBook", " 150", MACH_CLASSDUO, &romvecs[10]},
	{MACH_MACPB160, "PowerBook", " 160", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB165, "PowerBook", " 165", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB165C, "PowerBook", " 165c", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB170, "PowerBook", " 170", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB180, "PowerBook", " 180", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB180C, "PowerBook", " 180c", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB500, "PowerBook", " 500", MACH_CLASSPB, &romvecs[8]},
d2104 6
a2109 6
	{MACH_MACPB210, "PowerBook Duo", " 210", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB230, "PowerBook Duo", " 230", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB250, "PowerBook Duo", " 250", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB270, "PowerBook Duo", " 270C", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB280, "PowerBook Duo", " 280", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB280C, "PowerBook Duo", " 280C", MACH_CLASSDUO, &romvecs[5]},
d2112 5
a2116 5
	{MACH_MACP600, "Performa", " 600", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACP460, "Performa", " 460", MACH_CLASSLC, &romvecs[14]},
	{MACH_MACP550, "Performa", " 550", MACH_CLASSLC, &romvecs[11]},
	{MACH_MACP580, "Performa", " 580", MACH_CLASSQ2, &romvecs[19]},
	{MACH_MACTV,   "TV",      "",      MACH_CLASSLC, &romvecs[12]},
d2119 8
a2126 8
	{MACH_MACLCII,  "LC", " II",  MACH_CLASSLC, &romvecs[3]},
	{MACH_MACLCIII, "LC", " III", MACH_CLASSLC, &romvecs[14]},
	{MACH_MACLC475, "LC", " 475", MACH_CLASSQ,  &romvecs[9]},
	{MACH_MACLC475_33, "LC", " 475/33", MACH_CLASSQ,  &romvecs[9]},
	{MACH_MACLC520, "LC", " 520", MACH_CLASSLC, &romvecs[15]},
	{MACH_MACLC575, "LC", " 575", MACH_CLASSQ2, &romvecs[16]},
	{MACH_MACCCLASSIC, "Color Classic", "", MACH_CLASSLC, &romvecs[3]},
	{MACH_MACCCLASSICII, "Color Classic"," II", MACH_CLASSLC, &romvecs[3]},
d2128 1
a2128 1
	{MACH_MACCLASSICII, "Classic", " II", MACH_CLASSLC, &romvecs[3]},
d2186 1
a2186 1
int	mach_cputype(void);
d2194 1
a2194 65
int
fpu_probe()
{
	/*
	 * A 68881 idle frame is 28 bytes and a 68882's is 60 bytes.
	 * We, of course, need to have enough room for either.
	 */
	int	fpframe[60 / sizeof(int)];
	label_t	faultbuf;
	u_char	b;

	nofault = (int *) &faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = (int *) 0;
		return (FPU_NONE);
	}

	/*
	 * Synchronize FPU or cause a fault.
	 * This should leave the 881/882 in the IDLE state,
	 * state, so we can determine which we have by
	 * examining the size of the FP state frame
	 */
	asm("fnop");

	nofault = (int *) 0;

	/*
	 * Presumably, if we're an 040 and did not take exception
	 * above, we have an FPU.  Don't bother probing.
	 */
	if (mmutype == MMU_68040)
		return (FPU_68040);

	/*
	 * Presumably, this will not cause a fault--the fnop should
	 * have if this will.  We save the state in order to get the
	 * size of the frame.
	 */
	asm("movl %0, a0; fsave a0@@" : : "a" (fpframe) : "a0" );

	b = *((u_char *) fpframe + 1);

	/*
	 * Now, restore a NULL state to reset the FPU.
	 */
	fpframe[0] = fpframe[1] = 0;
	m68881_restore((struct fpframe *) fpframe);

	/*
	 * The size of a 68881 IDLE frame is 0x18
	 *         and a 68882 frame is 0x38
	 */
	if (b == 0x18)
		return (FPU_68881);
	if (b == 0x38)
		return (FPU_68882);

	/*
	 * If it's not one of the above, we have no clue what it is.
	 */
	return (FPU_UNKNOWN);
}

void
a2196 1
#ifdef DEBUG
d2198 1
a2198 1
#endif
a2199 10
	/*
	 * Print the machine type...
	 */
	sprintf(cpu_model, "Apple Macintosh %s%s",
	    cpu_models[mac68k_machine.cpu_model_index].model_major,
	    cpu_models[mac68k_machine.cpu_model_index].model_minor);

	/*
	 * ... and the CPU type...
	 */
d2201 2
a2202 2
	case CPU_68040:
		strcat(cpu_model, ", 68040 CPU");
d2205 1
a2205 1
		strcat(cpu_model, ", 68030 CPU");
d2207 2
a2208 2
	case CPU_68020:
		strcat(cpu_model, ", 68020 CPU");
d2211 1
a2211 1
		strcat(cpu_model, ", unknown CPU");
d2214 4
a2217 47

	/*
	 * ... and the MMU type...
	 */
	switch (mmutype) {
	case MMU_68040:
	case MMU_68030:
		strcat(cpu_model, "+MMU");
		break;
	case MMU_68851:
		strcat(cpu_model, ", MC68851 MMU");
		break;
	default:
		printf("%s\n", cpu_model);
		panic("unknown MMU type %d", mmutype);
		/* NOTREACHED */
	}

	/*
	 * ... and the FPU type...
	 */
	fputype = fpu_probe();	/* should eventually move to locore */

	switch (fputype) {
	case FPU_68040:
		strcat(cpu_model, "+FPU");
		break;
	case FPU_68882:
		strcat(cpu_model, ", MC6882 FPU");
		break;
	case FPU_68881:
		strcat(cpu_model, ", MC6881 FPU");
		break;
	case FPU_UNKNOWN:
		strcat(cpu_model, ", unknown FPU");
		break;
	default:
		/*strcat(cpu_model, ", no FPU");*/
		break;
	}

	/*
	 * ... and finally, the cache type.
	 */
	if (cputype == CPU_68040)
		strcat(cpu_model, ", 4k on-chip physical I/D caches");

a2218 1
#ifdef DEBUG
a2219 1
#endif
d2222 1
a2222 1
void	get_machine_info(void);
d2224 1
a2224 1
void
d2245 1
a2245 1
void	setmachdep(void);
d2508 1
a2508 1
u_long gray_nextaddr = 0;
d2548 2
a2549 2
extern u_long ptest040(caddr_t addr, u_int fc);
extern int get_pte(u_int addr, u_long pte[2], u_short * psr);
d2557 1
a2557 1
u_long
d2613 1
a2613 1
void	check_video(char *, u_long, u_long);
d2615 1
a2615 1
void
a2643 1
#ifdef DIAGNOSTIC
a2646 1
#endif
d2681 1
a2681 1
#ifdef DIAGNOSTIC
a2693 1
#ifdef DIAGNOSTIC
a2695 1
#endif
a2789 1
#ifdef DIAGNOSTIC
a2790 1
#endif
a2811 1
#ifdef DIAGNOSTIC
a2813 1
#endif
a2815 1
#ifdef DIAGNOSTIC
a2820 1
#endif
d2830 1
a2830 1
void printstar(void);
d2859 1
a2859 1
	int (*callback)(void *, int, int, int);
@


1.91.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 6
a282 14
	/*
	 * Initialize the I/O mem extent map.
	 * Note: we don't have to check the return value since
	 * creation of a fixed extent map will never fail (since
	 * descriptor storage has already been allocated).
	 *
	 * N.B. The iomem extent manages _all_ physical addresses
	 * on the machine.  When the amount of RAM is found, all
	 * extents of RAM are allocated from the map.
	 */
	iomem_ex = extent_create("iomem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)iomem_ex_storage, sizeof(iomem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);

d347 1
a347 2
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d481 12
d1125 6
a1155 1
#if defined(DDB) || NKSYMS > 0
a1156 1
#endif
d2192 1
a2192 1
	snprintf(cpu_model, sizeof cpu_model, "Apple Macintosh %s%s",
d2201 1
a2201 1
		strlcat(cpu_model, ", 68040 CPU", sizeof cpu_model);
d2204 1
a2204 1
		strlcat(cpu_model, ", 68030 CPU", sizeof cpu_model);
d2207 1
a2207 1
		strlcat(cpu_model, ", 68020 CPU", sizeof cpu_model);
d2210 1
a2210 1
		strlcat(cpu_model, ", unknown CPU", sizeof cpu_model);
d2220 1
a2220 1
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
d2223 1
a2223 1
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
d2238 1
a2238 1
		strlcat(cpu_model, "+FPU", sizeof cpu_model);
d2241 1
a2241 1
		strlcat(cpu_model, ", MC6882 FPU", sizeof cpu_model);
d2244 1
a2244 1
		strlcat(cpu_model, ", MC6881 FPU", sizeof cpu_model);
d2247 1
a2247 1
		strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
d2250 1
a2250 1
		/*strlcat(cpu_model, ", no FPU", sizeof cpu_model);*/
d2258 1
a2258 1
		strlcat(cpu_model, ", 4k on-chip physical I/D caches", sizeof cpu_model);
d2455 14
@


1.90
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2001/11/28 13:47:38 art Exp $	*/
d349 1
d479 2
a480 3
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL,
			    VM_PROT_ALL|PMAP_WIRED);
d484 1
d709 1
a709 1

d901 1
@


1.89
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2001/11/24 17:53:41 miod Exp $	*/
d183 3
a185 3
vm_map_t exec_map = NULL;  
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.88
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2001/11/23 00:47:45 miod Exp $	*/
d454 1
a454 1
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.87
log
@Remove splsched() declaration and related stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2001/11/09 15:25:55 art Exp $	*/
d634 6
d681 1
@


1.86
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2001/11/07 01:18:00 art Exp $	*/
a220 1
unsigned short  mac68k_schedipl = PSL_S | PSL_IPL3;
@


1.85
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2001/11/06 19:53:15 miod Exp $	*/
a189 1
int	nswbuf = 0;
a429 5
	if (nswbuf == 0) {
		nswbuf = (nbuf * 3 / 4) & ~1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;	/* sanity */
	}
@


1.84
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2001/09/19 20:50:56 mickey Exp $	*/
d460 2
a461 2
	    NULL, UVM_UNKNOWN_OFFSET, UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
	    UVM_INH_NONE, UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.83
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2001/09/12 00:23:33 art Exp $	*/
a131 1
#include <vm/vm.h>
@


1.82
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2001/09/11 20:10:00 miod Exp $	*/
a132 2
#include <vm/vm_kern.h>

@


1.81
log
@Fix uvm_km_suballoc() usage flags. ok art@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2001/08/25 15:43:28 miod Exp $	*/
d508 1
a508 1
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
@


1.80
log
@Post-regdump cleanup.
Gotta run, Beck is behind me with a large axe.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2001/08/25 11:37:26 espie Exp $	*/
d500 1
a500 1
	    16 * NCARGS, TRUE, FALSE, NULL);
d506 1
a506 1
	    VM_PHYS_SIZE, TRUE, FALSE, NULL);
d509 1
a509 1
	    VM_MBUF_SIZE, FALSE, FALSE, NULL);
@


1.79
log
@One regdump to dump them all...

(moid@@ wants that commit, because it interferes with stuff he's cleaning,
and he's prepared to clean up stuff I may have forgotten, even though this
was tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2001/08/23 14:01:03 art Exp $	*/
d1142 1
a1142 1
/*	regdump(&(frame->F_t), 128);
@


1.78
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2001/08/23 12:02:04 art Exp $	*/
d1142 1
a1142 1
/*	regdump(&frame, 128);
a1151 62
}

void	dumpmem __P((u_int *, int));

void
regdump(frame, sbytes)
	struct frame *frame;
	int sbytes;
{
	static int doingdump = 0;
	register int i;
	int s;

	if (doingdump)
		return;
	s = splhigh();
	doingdump = 1;
	printf("pid = %d, pc = 0x%08x, ", curproc->p_pid, frame->f_pc);
	printf("ps = 0x%08x, ", frame->f_sr);
	printf("sfc = 0x%08x, ", getsfc());
	printf("dfc = 0x%08x\n", getdfc());
	printf("Registers:\n     ");
	for (i = 0; i < 8; i++)
		printf("        %d", i);
	printf("\ndreg:");
	for (i = 0; i < 8; i++)
		printf(" %08x", frame->f_regs[i]);
	printf("\nareg:");
	for (i = 0; i < 8; i++)
		printf(" %08x", frame->f_regs[i + 8]);
	if (sbytes > 0) {
		if (1) {	/* (frame->f_sr & PSL_S) *//* BARF - BG */
			printf("\n\nKernel stack (%08x):",
			    (int) (((int *)frame) - 1));
			dumpmem(((int *)frame) - 1, sbytes);
		} else {
			printf("\n\nUser stack (%08x):", frame->f_regs[15]);
			dumpmem((int *)frame->f_regs[15], sbytes);
		}
	}
	doingdump = 0;
	splx(s);
}

void	dumpmem __P((u_int *, int));

void
dumpmem(ptr, sz)
	register u_int *ptr;
	int sz;
{
	register int i;

	sz /= 4;
	for (i = 0; i < sz; i++) {
		if ((i & 7) == 0)
			printf("\n%08x: ", (u_int) ptr);
		else
			printf(" ");
		printf("%08x ", *ptr++);
	}
	printf("\n");
@


1.77
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2001/08/11 23:09:03 art Exp $	*/
a509 5

	/*
	 * Initialize timeouts
	 */
	timeout_init();
@


1.76
log
@redundant includes
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2001/07/25 13:25:32 art Exp $	*/
a399 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.75
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2001/07/05 10:12:10 art Exp $	*/
a132 3
#include <vm/vm_param.h>
#include <vm/pmap.h>
#include <vm/vm_map.h>
a133 2
#include <vm/vm_page.h>
#include <vm/vm_pager.h>
@


1.74
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2001/07/05 07:18:40 art Exp $	*/
d357 2
a358 2
		    VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);
d495 2
a496 2
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
			    VM_PROT_ALL);
d721 1
a721 1
	    VM_PROT_ALL, TRUE, VM_PROT_ALL);
d913 1
a913 1
		    VM_PROT_READ, TRUE, VM_PROT_READ);
@


1.73
log
@clean up includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2001/06/27 04:22:37 art Exp $	*/
a404 3
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
@


1.72
log
@old vm no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2001/05/17 18:41:48 provos Exp $	*/
a135 1
#include <vm/vm_object.h>
d138 1
@


1.71
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2001/05/08 17:30:41 aaron Exp $	*/
a139 1
#if defined(UVM)
a140 1
#endif
a190 1
#if defined(UVM)
a193 3
#else
vm_map_t buffer_map;
#endif
a282 1
#if defined(UVM)
a290 8
#else
		if (low[i] <= avail_start && avail_start < high[i])
			vm_page_physload(atop(avail_start), atop(high[i]),
			    atop(avail_start), atop(high[i]));
		else
			vm_page_physload(atop(low[i]), atop(high[i]),
			    atop(low[i]), atop(high[i]));
#endif /* UVM */
a447 3
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
a454 1
#if defined(UVM)
a455 3
#else
		firstaddr = (caddr_t)kmem_alloc(kernel_map, round_page(size));
#endif /* UVM */
a470 1
#if defined(UVM)
a475 12
#else
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
	    &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
	    &minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* Don't want to alloc more physical mem than needed. */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
#endif /* UVM */
a478 1
#if defined(UVM)
a502 16
#else /* ! UVM */
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base + 1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf + curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif /* UVM */
a507 1
#if defined(UVM)
a509 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, TRUE);
#endif
a513 1
#if defined(UVM)
a515 4
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, TRUE);
#endif
a516 1
#if defined(UVM)
a518 4
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE);
#endif
a524 1
#if defined(UVM)
a525 3
#else
	printf("avail mem = %ld\n", ptoa(cnt.v_free_count));
#endif
@


1.70
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2001/05/05 22:33:54 art Exp $	*/
a578 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *) malloc(NMBCLUSTERS + PAGE_SIZE / MCLBYTES,
	    M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS + PAGE_SIZE / MCLBYTES);
@


1.69
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.68 2001/05/05 20:56:41 art Exp $	*/
/*	$NetBSD: machdep.c,v 1.134 1997/02/14 06:15:30 scottr Exp $	*/
a4 1
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
a101 1
#include <sys/sysctl.h>
d132 1
d140 6
d147 2
a148 2
#include <arch/mac68k/mac68k/macrom.h>
#include <arch/mac68k/dev/adbvar.h>
d150 1
d155 1
a155 1
char    machine[] = "mac68k";	/* cpu "architecture" */
d172 4
a175 4
int     nbnumranges;		/* = 0 == don't use the ranges */
u_long  nbphys[NBMAXRANGES];	/* Start physical addr of this range */
u_long  nblog[NBMAXRANGES];	/* Start logical addr of this range */
long    nblen[NBMAXRANGES];	/* Length of this range If the length is */
d193 5
d199 1
d204 1
a204 1
int     nswbuf = 0;
d206 1
a206 1
int     nbuf = NBUF;
d208 1
a208 1
int     nbuf = 0;
d211 1
a211 1
int     bufpages = BUFPAGES;
d213 1
a213 1
int     bufpages = 0;
d216 2
a217 2
int     maxmem;			/* max memory per process */
int     physmem = MAXMEM;	/* max supported memory, changes to actual */
d223 1
a223 1
int     safepri = PSL_LOWIPL;
a253 1
int	want_resched = 0;
d258 1
d262 2
d265 3
d274 41
d339 1
a339 1
	} else {
a340 1
	}
d343 1
a343 1
#define CURRENTBOOTERVER	108
d352 7
a358 7
	register caddr_t	v, firstaddr;
	register unsigned	i;
	int     	vers;
	int     	base, residual;
	vm_offset_t	minaddr, maxaddr;
	vm_size_t	size = 0;	/* To avoid compiler warning */
	int     	delay;
d370 1
a370 1
		pmap_enter(pmap_kernel(), (vm_offset_t) msgbufp,
d414 1
a414 1
	v = (caddr_t) firstaddr;
d443 1
a443 1
	 * We allocate 1/2 as many swap buffer headers as file i/o buffers.
a450 1
	bufpages = min(NKMEMCLUSTERS * 2 / 5, bufpages);
d457 1
d459 1
a459 1
		nswbuf = (nbuf / 2) & ~1;	/* force even */
d463 1
d465 1
d472 6
a477 2
		size = (vm_size_t) (v - firstaddr);
		firstaddr = (caddr_t) kmem_alloc(kernel_map, round_page(size));
d485 1
a485 1
	if ((vm_size_t) (v - firstaddr) != size)
d493 8
a500 1
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *) & buffers,
d502 3
a504 3
	minaddr = (vm_offset_t) buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t) 0,
		&minaddr, size, FALSE) != KERN_SUCCESS)
d510 1
d514 26
d550 1
a550 1
		curbuf = (vm_offset_t) buffers + i * MAXBSIZE;
d554 1
d560 4
d566 1
d571 4
d577 1
d586 5
a590 1
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *) & mbutl, &maxaddr,
d592 1
d599 3
d603 1
d608 5
d630 33
d682 1
a682 1
	struct frame *frame = (struct frame *) p->p_md.md_regs;
d723 1
a723 1
int     waittime = -1;
d730 1
a730 1
	extern u_long MacOSROMBase;
d734 1
a734 1
		savectx((struct pcb *) curproc->p_addr);
d787 1
a787 1
                         * the MRG_ADB method isn't used.
d789 2
a790 2
                	 * Shut down machines whose power functions
                         * are accessed via modified ADB calls.
d792 1
a792 1
                	adb_poweroff();
d800 4
a803 7
	/*
	 * Map ROM where the MacOS likes it, so we can reboot,
	 * hopefully.
	 */
	pmap_map(MacOSROMBase, MacOSROMBase,
		 MacOSROMBase + 4 * 1024 * 1024,
		 VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);
a804 1
	
d1046 1
a1046 1
	int     s = splhigh();
d1069 2
a1070 2
	int     pc;
	int     evec;
d1079 1
a1079 1
int    *nofault;
d1090 3
a1092 8
#ifdef lint
	i = *addr;
	if (i)
		return (0);
#endif
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *) nofault)) {
		nofault = (int *) 0;
d1095 2
a1096 2
	i = *(volatile short *) addr;
	nofault = (int *) 0;
d1112 3
a1114 3
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *) nofault)) {
		nofault = (int *) 0;
d1117 2
a1118 2
	i = *(volatile u_int8_t *) addr;
	nofault = (int *) 0;
d1134 3
a1136 3
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *) nofault)) {
		nofault = (int *) 0;
d1139 2
a1140 2
	i = *(volatile u_int16_t *) addr;
	nofault = (int *) 0;
d1156 3
a1158 3
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *) nofault)) {
		nofault = (int *) 0;
d1161 2
a1162 2
	i = *(volatile u_int32_t *) addr;
	nofault = (int *) 0;
d1251 1
a1251 1
	int     sbytes;
d1255 1
a1255 1
	int     s;
d1277 2
a1278 2
			    (int) (((int *) frame) - 1));
			dumpmem(((int *) frame) - 1, sbytes);
d1281 1
a1281 1
			dumpmem((int *) frame->f_regs[15], sbytes);
d1293 1
a1293 1
	int     sz;
d1327 1
a1327 1
	int    *name;
d1360 1
a1360 1
	int     error = ENOEXEC;
d1364 1
a1364 1
	if (((struct exec *) epp->ep_hdr)->a_midmag == ZMAGIC)
d1396 1
a1396 1
	int     root_scsi_id;
d1399 3
a1401 3
         * If flag & 0x80000000 == 0, then we're booting with the old booter
         * and we should freak out.
         */
a1406 10
	root_scsi_id = getenv("ROOT_SCSI_ID");
	/*
         * For now, we assume that the boot device is off the first controller.
         */
	if (bootdev == 0)
		bootdev = MAKEBOOTDEV(4, 0, 0, root_scsi_id, 0);

	if (boothowto == 0)
		boothowto = getenv("SINGLE_USER");

d1414 3
a1416 3
         * The following are not in a structure so that they can be
         * accessed more quickly.
         */
d1423 2
a1424 2
         * More misc stuff from booter.
         */
a1437 1
	/* Should probably check this and fail if old */
d1441 20
a1460 2
         * Get end of symbols for kernel debugging
         */
d1474 2
a1475 2
         * Save globals stolen from MacOS
         */
d1477 3
a1479 3
	ROMBase = (caddr_t) getenv("ROMBASE");
	if (ROMBase == (caddr_t) 0) {
		ROMBase = (caddr_t) ROMBASE;
d1488 1
a1488 1
 	mrg_ADBIntrPtr = (caddr_t) getenv("ADBINTERRUPT");
d1495 1
a1495 1
	char    c;
d1506 1
a1506 1
	char   *str;
d1509 7
a1515 7
         * Returns the value of the environment variable "str".
         *
         * Format of the buffer is "var=val\0var=val\0...\0var=val\0\0".
         *
         * Returns 0 if the variable is not there, and 1 if the variable is there
         * without an "=val".
         */
d1517 2
a1518 2
	char   *s, *s1;
	int     val, base;
d1634 23
a1656 23
		(caddr_t) 0x40807002,	/* where does ADB interrupt */
		(caddr_t) 0x0,		/* PM interrupt (?) */
		(caddr_t) 0x4080a4d8,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x40807778,	/* CountADBs */
		(caddr_t) 0x40807792,	/* GetIndADB */
		(caddr_t) 0x408077be,	/* GetADBInfo */
		(caddr_t) 0x408077c4,	/* SetADBInfo */
		(caddr_t) 0x40807704,	/* ADBReInit */
		(caddr_t) 0x408072fa,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080d6d0,	/* WriteParam */
		(caddr_t) 0x4080d6fa,	/* SetDateTime */
		(caddr_t) 0x4080dbe8,	/* InitUtil */
		(caddr_t) 0x4080dd78,	/* ReadXPRam */
		(caddr_t) 0x4080dd82,	/* WriteXPRam */
		(caddr_t) 0x4080ddd6,	/* jClkNoMem */
		(caddr_t) 0x0,		/* ADBAlternateInit */
		(caddr_t) 0x0,		/* Egret */
		(caddr_t) 0x0,		/* InitEgret */
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
		(caddr_t) 0x40814c58,	/* FixDiv */
		(caddr_t) 0x40814b64,	/* FixMul */
d1664 23
a1686 23
		(caddr_t) 0x4088ae5e,	/* ADB interrupt */
		(caddr_t) 0x408885ec,	/* PB ADB interrupt */
		(caddr_t) 0x4088ae0e,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x408888ec,	/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x4080b1e4,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x40814800,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv */
		(caddr_t) 0x4081c312,	/* FixMul */
d1693 23
a1715 23
		(caddr_t) 0x40814912,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PM ADB interrupt */
		(caddr_t) 0x408150f0,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x4080b1e4,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x40814800,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv */
		(caddr_t) 0x4081c312,	/* FixMul */
d1723 23
a1745 23
		(caddr_t) 0x40a14912,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PM ADB interrupt */
		(caddr_t) 0x40a150f0,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x40a0a360,	/* CountADBs */
		(caddr_t) 0x40a0a37a,	/* GetIndADB */
		(caddr_t) 0x40a0a3a6,	/* GetADBInfo */
		(caddr_t) 0x40a0a3ac,	/* SetADBInfo */
		(caddr_t) 0x40a0a752,	/* ADBReInit */
		(caddr_t) 0x40a0a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x40a0c05c,	/* WriteParam */
		(caddr_t) 0x40a0c086,	/* SetDateTime */
		(caddr_t) 0x40a0c5cc,	/* InitUtil */
		(caddr_t) 0x40a0b186,	/* ReadXPRam */
		(caddr_t) 0x40a0b190,	/* WriteXPRam */
		(caddr_t) 0x40a0b1e4,	/* jClkNoMem */
		(caddr_t) 0x40a0a818,	/* ADBAlternateInit */
		(caddr_t) 0x40a14800,	/* Egret */
		(caddr_t) 0x40a147c4,	/* InitEgret */
		(caddr_t) 0x40a03ba6,	/* ADBReInit_JTBL */
		(caddr_t) 0x40a7eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x40a1c406,	/* FixDiv, wild guess */
		(caddr_t) 0x40a1c312,	/* FixMul, wild guess */
d1752 23
a1774 23
		(caddr_t) 0x4080a700,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PM ADB interrupt */
		(caddr_t) 0x4080a5aa,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x4080b1e4,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x0,		/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv */
		(caddr_t) 0x4081c312,	/* FixMul */
d1782 23
a1804 23
		(caddr_t) 0x408b2eec,	/* ADB interrupt */
		(caddr_t) 0x408885ec,	/* PB ADB interrupt */
		(caddr_t) 0x408b2e76,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x408888ec,	/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b39b2,	/* jClkNoMem */	/* From PB180 */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x40814800,	/* Egret */
		(caddr_t) 0x40888400,	/* InitPwrMgr */ /* From PB180 */
		(caddr_t) 0x408cce28,	/* ADBReInit_JTBL -- from PB160*/
		(caddr_t) 0x4087eb90,	/* ROMRsrcMap List Head -- from PB160*/
		(caddr_t) 0x4081c406,	/* FixDiv, wild guess */
		(caddr_t) 0x4081c312,	/* FixMul, wild guess */
d1812 23
a1834 23
		(caddr_t) 0x408b2dea,	/* ADB int */
		(caddr_t) 0x0,		/* PM intr */
 		(caddr_t) 0x408b2c72,	/* ADBBase + 130 */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x40809ae6,	/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b39b6,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x40814800,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x408d2b64,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv, wild guess */
		(caddr_t) 0x4081c312,	/* FixMul, wild guess */
d1842 23
a1864 23
		(caddr_t) 0x4080cac6,	/* ADB int */
		(caddr_t) 0x0,		/* PM int */
		(caddr_t) 0x40805cd4,	/* ADBBase + 130 */
		(caddr_t) 0x40839600,	/* CountADBs */
		(caddr_t) 0x4083961a,	/* GetIndADB */
		(caddr_t) 0x40839646,	/* GetADBInfo */
		(caddr_t) 0x4083964c,	/* SetADBInfo */
		(caddr_t) 0x408397b8,	/* ADBReInit */
		(caddr_t) 0x4083967c,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4081141c,	/* WriteParam */
		(caddr_t) 0x4081144e,	/* SetDateTime */
		(caddr_t) 0x40811930,	/* InitUtil */
		(caddr_t) 0x4080b624,	/* ReadXPRam */
		(caddr_t) 0x4080b62e,	/* WriteXPRam */
		(caddr_t) 0x40806884,	/* jClkNoMem */
		(caddr_t) 0x408398c2,	/* ADBAlternateInit */
		(caddr_t) 0x4080cada,	/* Egret */
		(caddr_t) 0x4080de14,	/* InitEgret */
		(caddr_t) 0x408143b8,	/* ADBReInit_JTBL */
		(caddr_t) 0x409bdb60,	/* ROMResourceMap List Head */
		(caddr_t) 0x4083b3d8,	/* FixDiv */
		(caddr_t) 0x4083b2e4,	/* FixMul */
d1872 23
a1894 23
		(caddr_t) 0x400b2efc,	/* ADB int */
		(caddr_t) 0x400d8e66,	/* PM int */
		(caddr_t) 0x400b2e86,	/* ADBBase + 130 */
		(caddr_t) 0x4000a360,	/* CountADBs */
		(caddr_t) 0x4000a37a,	/* GetIndADB */
		(caddr_t) 0x4000a3a6,	/* GetADBInfo */
		(caddr_t) 0x4000a3ac,	/* SetADBInfo */
		(caddr_t) 0x4000a752,	/* ADBReInit */
		(caddr_t) 0x4000a3dc,	/* ADBOp */
		(caddr_t) 0x400d9302,	/* PmgrOp */
		(caddr_t) 0x4000c05c,	/* WriteParam */
		(caddr_t) 0x4000c086,	/* SetDateTime */
		(caddr_t) 0x4000c5cc,	/* InitUtil */
		(caddr_t) 0x4000b186,	/* ReadXPRam */
		(caddr_t) 0x4000b190,	/* WriteXPRam */
		(caddr_t) 0x400b3c08,	/* jClkNoMem */
		(caddr_t) 0x4000a818,	/* ADBAlternateInit */
		(caddr_t) 0x40009ae6,	/* Egret */ /* From PB520 */
		(caddr_t) 0x400147c4,	/* InitEgret */
		(caddr_t) 0x400a7a5c,	/* ADBReInit_JTBL */
		(caddr_t) 0x4007eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4001c406,	/* FixDiv, wild guess */
		(caddr_t) 0x4001c312,	/* FixMul, wild guess */
d1901 23
a1923 23
		(caddr_t) 0x408a9b56,	/* ADB int */
		(caddr_t) 0x0,		/* PM int */
		(caddr_t) 0x408b2f94,	/* ADBBase + 130 */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PmgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b3bf8,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408a99c0,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x408a82c0,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv */
		(caddr_t) 0x4081c312,	/* FixMul */
d1930 23
a1952 23
		(caddr_t) 0x408b2efc,	/* ADB interrupt */
		(caddr_t) 0x408885ec,	/* PB ADB interrupt */
		(caddr_t) 0x408b2e86,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x408888ec,	/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b3bf8,	/* jClkNoMem */ /* from PB 150 */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x40814800,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv, wild guess */
		(caddr_t) 0x4081c312,	/* FixMul, wild guess */
d1959 23
a1981 23
		(caddr_t) 0x408d16d6,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PB ADB interrupt */
		(caddr_t) 0x408b2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b3c04,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408d1450,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x408d24a4,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv for P550 */
		(caddr_t) 0x4081c312,	/* FixMul for P550 */
d1988 23
a2010 23
		(caddr_t) 0x40acfed6,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PB ADB interrupt */
		(caddr_t) 0x40ab2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x40a0a360,	/* CountADBs */
		(caddr_t) 0x40a0a37a,	/* GetIndADB */	
		(caddr_t) 0x40a0a3a6,	/* GetADBInfo */
		(caddr_t) 0x40a0a3ac,	/* SetADBInfo */
		(caddr_t) 0x40a0a752,	/* ADBReInit */
		(caddr_t) 0x40a0a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x40a0c05c,	/* WriteParam */
		(caddr_t) 0x40a0c086,	/* SetDateTime */
		(caddr_t) 0x40a0c5cc,	/* InitUtil */
		(caddr_t) 0x40a0b186,	/* ReadXPRam */
		(caddr_t) 0x40a0b190,	/* WriteXPRam */
		(caddr_t) 0x40ab3bf4,	/* jClkNoMem */
		(caddr_t) 0x40a0a818,	/* ADBAlternateInit */
		(caddr_t) 0x40acfd40,	/* Egret */
		(caddr_t) 0x40a147c4,	/* InitEgret */
		(caddr_t) 0x40a038a0,	/* ADBReInit_JTBL */
		(caddr_t) 0x40a7eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x40a1c406,	/* FixDiv */
		(caddr_t) 0x40a1c312,	/* FixMul */
d2017 23
a2039 23
		(caddr_t) 0x408a9bd2,	/* ADB int */
		(caddr_t) 0x0,		/* PM intr */
 		(caddr_t) 0x408b2f94,	/* ADBBase + 130 */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* Wild guess at ReadXPRam */
		(caddr_t) 0x4080b190,	/* Wild guess at WriteXPRam */
		(caddr_t) 0x408b39f4,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408a99c0,	/* Egret */
		(caddr_t) 0x408147c8,	/* InitEgret */
		(caddr_t) 0x408a7ef8,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv */
		(caddr_t) 0x4081c312,	/* FixMul */
d2046 23
a2068 23
		(caddr_t) 0x40814912,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PM ADB interrupt */
		(caddr_t) 0x408b2f94,	/* ADBBase + 130 interupt */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b39b6,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x40814800,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x408d2918,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv */
		(caddr_t) 0x4081c312,	/* FixMul */
d2075 23
a2097 23
		(caddr_t) 0x408d16d6,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PB ADB interrupt */
		(caddr_t) 0x408b2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b3c04,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408d1450,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x408d2460,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv for P520 */
		(caddr_t) 0x4081c312,	/* FixMul for P520 */
d2104 23
a2126 23
		(caddr_t) 0x408a9b56,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PB ADB interrupt */
		(caddr_t) 0x408b2f94,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b3bf8,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408a99c0,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x408a81a0,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv for P520 */
		(caddr_t) 0x4081c312,	/* FixMul for P520 */
d2133 23
a2155 23
		(caddr_t) 0x40814912,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PM ADB interrupt */
		(caddr_t) 0x4080a4d8,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x4080b1e4,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x40814800,	/* Egret */
		(caddr_t) 0x408147c4,	/* InitEgret */
		(caddr_t) 0x408038bc,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv */
		(caddr_t) 0x4081c312,	/* FixMul */
d2162 52
a2213 23
		(caddr_t) 0x40809f4a,	/* ADB interrupt */
		(caddr_t) 0x0,		/* PM ADB interrupt */
		(caddr_t) 0x4080a4d8,	/* ADBBase + 130 interupt */
		(caddr_t) 0x4080a360,	/* CountADBs */
		(caddr_t) 0x4080a37a,	/* GetIndADB */
		(caddr_t) 0x4080a3a6,	/* GetADBInfo */
		(caddr_t) 0x4080a3ac,	/* SetADBInfo */
		(caddr_t) 0x4080a752,	/* ADBReInit */
		(caddr_t) 0x4080a3dc,	/* ADBOp */
		(caddr_t) 0x0,		/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x4080b1e4,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x0,		/* Egret */
		(caddr_t) 0x0,		/* InitEgret */
		(caddr_t) 0x408037c0,	/* ADBReInit_JTBL */
		(caddr_t) 0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv */
		(caddr_t) 0x4081c312,	/* FixMul */
d2275 1
d2318 1
d2344 1
a2344 1
char    cpu_model[120];		/* for sysctl() */
d2387 1
a2387 1
	int     i;
a2409 1
	static int firstpass = 1;
d2419 1
a2419 2
	if (firstpass) {
		get_machine_info();
d2421 1
a2421 2
		load_addr = 0;
	}
a2424 3
	if (!firstpass)
		return;

d2433 1
a2433 1
		Via1Base = (volatile u_char *) IOBase;
d2444 1
a2444 1
		Via1Base = (volatile u_char *) IOBase;
d2463 1
a2463 1
		Via1Base = (volatile u_char *) IOBase;
d2473 1
a2473 1
        case MACH_CLASSQ2:
d2476 1
d2479 1
a2479 1
		Via1Base = (volatile u_char *) IOBase;
d2489 1
a2489 1
		Via1Base = (volatile u_char *) IOBase;
d2499 1
a2499 1
		Via1Base = (volatile u_char *) IOBase;
d2509 1
a2509 1
		Via1Base = (volatile u_char *) IOBase;
d2519 1
a2519 1
		Via1Base = (volatile u_char *) IOBase;
d2529 1
a2529 1
		Via1Base = (volatile u_char *) IOBase;
d2541 1
a2541 1
	 * Set `internal' framebuffer location and length, if we know 
d2547 2
a2548 2
			    (u_int32_t) intvid_info[i].fbbase;
			mac68k_vidlen = (u_int32_t) intvid_info[i].fblen;
a2560 2

	firstpass = 0;
d2588 2
a2589 2
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0xc000;
d2598 1
a2598 1
			sccA = (volatile u_char *) base + 0xc020;
d2614 2
a2615 2
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0xc020;
d2618 9
d2628 2
a2629 2
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0x4000;
d2631 1
a2631 1
		PSCBase = (volatile u_char *) base + 0x31000;
d2644 2
a2645 2
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0x4000;
d2654 2
a2655 2
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0x4020;
d2695 1
a2695 1
			((u_long *) videoaddr)[gray_nextaddr++] = 0xaaaaaaaa;
d2697 1
a2697 1
			((u_long *) videoaddr)[gray_nextaddr++] = 0x00000000;
d2720 1
a2720 1
	u_long  pte[2], ph, mask;
d2722 1
a2722 1
	int     i, numbits;
d2726 1
a2726 1
		ph = ptest040((caddr_t) addr, FC_SUPERD);
d2728 1
a2728 1
			ph = ptest040((caddr_t) addr, FC_USERD);
d2777 2
a2778 2
	char    *id;
	u_long  limit, maxm;
d2780 1
a2780 1
	u_long  addr, phys;
d2818 2
a2819 2
	int     i, same;
	u_long  addr, lastpage, phys, len;
d2848 24
a2871 22
	/*
	 * We should now look through all of NuBus space to find where
	 * the internal video is being mapped.  Just to be sure we handle
	 * all the cases, we simply map our NuBus space exactly how
	 * MacOS did it.  As above, we find a bunch of ranges that are
	 * contiguously mapped.  Since there are a lot of pages that
	 * are all mapped to 0, we handle that as a special case where
	 * the length is negative.  We search in increments of 32768
	 * because that's the page size that MacOS uses.
	 */

	nbnumranges = 0;
	for (i = 0; i < NBMAXRANGES; i++) {
		nbphys[i] = 0;
		nblog[i] = 0;
		nblen[i] = 0;
	}

	same = 0;
	for (addr = 0xF9000000; addr < 0xFF000000; addr += 32768) {
		if (!get_physical(addr, &phys)) {
			continue;
d2873 7
a2879 1
		len = nbnumranges == 0 ? 0 : nblen[nbnumranges - 1];
d2882 1
a2882 1
		printf ("0x%lx --> 0x%lx\n", addr, phys);
d2884 4
a2887 10
		if (nbnumranges > 0
		    && addr == nblog[nbnumranges - 1] + len
		    && phys == nbphys[nbnumranges - 1]) {	/* Same as last one */
			nblen[nbnumranges - 1] += 32768;
			same = 1;
		} else {
			if ((nbnumranges > 0)
			    && !same
			    && (addr == nblog[nbnumranges - 1] + len)
			    && (phys == nbphys[nbnumranges - 1] + len)) {
d2889 1
d2891 19
a2909 3
				if (same) {
					nblen[nbnumranges - 1] = -len;
					same = 0;
a2910 9
				if (nbnumranges == NBMAXRANGES) {
					printf("get_mapping(): Too many NuBus "
					    "ranges.\n");
					break;
				}
				nbnumranges++;
				nblog[nbnumranges - 1] = addr;
				nbphys[nbnumranges - 1] = phys;
				nblen[nbnumranges - 1] = 32768;
d2913 4
a2916 5
	}
	if (same) {
		nblen[nbnumranges - 1] = -nblen[nbnumranges - 1];
		same = 0;
	}
d2918 5
a2922 5
	printf("Non-system RAM (nubus, etc.):\n");
	for (i = 0; i < nbnumranges; i++) {
		printf("     Log = 0x%lx, Phys = 0x%lx, Len = 0x%lx (%lu)\n",
		    nblog[i], nbphys[i], nblen[i], nblen[i]);
	}
d2925 15
a2939 15
	/*
	 * We must now find the logical address of internal video in the
	 * ranges we made above.  Internal video is at physical 0, but
	 * a lot of pages map there.  Instead, we look for the logical
	 * page that maps to 32768 and go back one page.
	 */

	for (i = 0; i < nbnumranges; i++) {
		if (nblen[i] > 0
		    && nbphys[i] <= 32768
		    && 32768 <= nbphys[i] + nblen[i]) {
			mac68k_vidlog = nblog[i] - nbphys[i];
			mac68k_vidlen = nblen[i] + nbphys[i];
			mac68k_vidphys = 0;
			break;
d2941 34
a2974 28
	}
	if (i == nbnumranges) {
		if (0xfee00000 <= videoaddr && videoaddr < 0xfee10000) {
			/*
			 * Kludge for Classic II video.
			 */
			check_video("Classic II video (0xfee09a80)",
					21888, 21888);
		} else if (0x60000000 <= videoaddr && videoaddr < 0x70000000) {
			printf("Checking for Internal Video ");
			/*
			 * Kludge for IIvx internal video (60b0 0000).
			 * PB 520 (6000 0000)
			 */
			check_video("PB/IIvx (0x60?00000)", 1 * 1024 * 1024,
						   1 * 1024 * 1024);
		} else if (0x50F40000 <= videoaddr && videoaddr < 0x50FBFFFF) {
			/*
			 * Kludge for LC internal video
			 */
			check_video("LC video (0x50f40000)",
					512 * 1024, 512 * 1024);
		} else if (0x50100100 <= videoaddr && videoaddr < 0x50400000) {
			/*
			 * Kludge for AV internal video
			 */
			check_video("AV video (0x50100100)", 1 * 1024 * 1024,
						1 * 1024 * 1024);
d2976 5
a2980 2
			printf( "  no internal video at address 0 -- "
				"videoaddr is 0x%lx.\n", videoaddr);
a2981 6
	} else {
		printf("  Video address = 0x%lx\n", videoaddr);
		printf("  Int video starts at 0x%x\n",
		    mac68k_vidlog);
		printf("  Length = 0x%x (%d) bytes\n",
		    mac68k_vidlen, mac68k_vidlen);
d3023 1
a3023 1
	mac68k_bell_cookie = (caddr_t) cookie;
@


1.68
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2000/04/11 02:44:28 pjanzen Exp $	*/
a505 1
	configure();
@


1.67
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2000/03/23 09:59:54 art Exp $	*/
d133 1
a133 1
#define	MAXMEM	64*1024*CLSIZE	/* XXX - from cmap.h */
d390 1
a390 1
			bufpages = physmem / 10 / CLSIZE;
d392 1
a392 1
			bufpages = (btoc(2 * 1024 * 1024) + physmem) / 20 / CLSIZE;
d454 1
a454 1
		curbufsize = CLBYTES * (i < residual ? base + 1 : base);
d475 1
a475 1
	mclrefcnt = (char *) malloc(NMBCLUSTERS + CLBYTES / MCLBYTES,
d477 1
a477 1
	bzero(mclrefcnt, NMBCLUSTERS + CLBYTES / MCLBYTES);
d488 1
a488 1
	    nbuf, bufpages * CLBYTES);
d734 1
a734 1
 * Dumps always skip the first CLBYTES of disk space in
d767 1
a767 1
	 * first CLBYTES in case there is a disk label there.
@


1.66
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2000/02/22 19:27:52 deraadt Exp $	*/
d901 1
a901 1
	while (tvp->tv_usec > 1000000) {
d907 1
a907 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
@


1.65
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 1999/12/08 06:50:16 itojun Exp $	*/
d96 1
a96 1
#include <sys/callout.h>
d366 1
a366 1
	valloc(callout, struct callout, ncallout);
d482 1
a482 1
	 * Initialize callouts
d484 1
a484 3
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i - 1].c_next = &callout[i];
@


1.64
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 1999/09/03 18:01:12 art Exp $	*/
a203 1
int     msgbufmapped;		/* set when safe to use msgbuf */
d312 1
a312 1
	for (i = 0; i < btoc(sizeof(struct msgbuf)); i++)
d317 1
a317 1
	msgbufmapped = 1;
d794 1
@


1.64.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d204 1
d313 1
a313 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d318 1
a318 1
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
a794 1
	extern int msgbufmapped;
@


1.64.2.2
log
@Sync with -current
@
text
@d96 1
a96 1
#include <sys/timeout.h>
d366 1
a366 1
	valloc(timeouts, struct timeout, ntimeout);
d482 1
a482 1
	 * Initialize timeouts
d484 3
a486 1
	timeout_init();
@


1.64.2.3
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2000/04/11 02:44:28 pjanzen Exp $	*/
d901 1
a901 1
	while (tvp->tv_usec >= 1000000) {
d907 1
a907 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
@


1.64.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: machdep.c,v 1.207 1998/07/08 04:39:34 thorpej Exp $	*/
d5 1
d103 1
d133 1
a133 2
#define	MAXMEM	64*1024	/* XXX - from cmap.h */
#include <vm/vm.h>
a140 4
#include <uvm/uvm_extern.h>

#include <sys/sysctl.h>

d142 2
a143 2
#include <mac68k/mac68k/macrom.h>
#include <mac68k/dev/adbvar.h>
a144 1
#include <machine/psc.h>
d149 1
a149 1
char	machine[] = "mac68k";	/* cpu "architecture" */
d166 4
a169 4
int	nbnumranges;		/* = 0 == don't use the ranges */
u_long	nbphys[NBMAXRANGES];	/* Start physical addr of this range */
u_long	nblog[NBMAXRANGES];	/* Start logical addr of this range */
long	nblen[NBMAXRANGES];	/* Length of this range If the length is */
d187 1
a187 3
vm_map_t exec_map = NULL;  
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
d192 1
a192 1
int	nswbuf = 0;
d194 1
a194 1
int	nbuf = NBUF;
d196 1
a196 1
int	nbuf = 0;
d199 1
a199 1
int	bufpages = BUFPAGES;
d201 1
a201 1
int	bufpages = 0;
d204 2
a205 2
int	maxmem;			/* max memory per process */
int	physmem = MAXMEM;	/* max supported memory, changes to actual */
d211 1
a211 1
int	safepri = PSL_LOWIPL;
d242 1
a246 1
void	initcpu __P((void));
a249 2

/* functions called from locore.s */
a250 3
void	mac68k_init __P((void));
void	straytrap __P((int, int));
void	nmihand __P((struct frame));
a256 32
 /*
 * Early initialization, before main() is called.
 */
void
mac68k_init()
{
	int i;
	extern vm_offset_t avail_start;

	/*
	 * Tell the VM system about available physical memory.
	 * Notice that we don't need to worry about avail_end here
	 * since it's equal to high[numranges-1].
	 */
	for (i = 0; i < numranges; i++) {
		if (low[i] <= avail_start && avail_start < high[i])
			uvm_page_physload(atop(avail_start), atop(high[i]),
			    atop(avail_start), atop(high[i]),
			    VM_FREELIST_DEFAULT);
		else
			uvm_page_physload(atop(low[i]), atop(high[i]),
			    atop(low[i]), atop(high[i]),
			    VM_FREELIST_DEFAULT);
	}

	/* Initialize the VIAs */
	via_init();

	/* Initialize the PSC (if present) */
	psc_init();
}

d281 1
a281 1
	} else
d283 1
d286 1
a286 1
#define CURRENTBOOTERVER	111
d295 7
a301 7
	caddr_t v, firstaddr;
	unsigned i;
	int vers;
	int base, residual;
	vm_offset_t minaddr, maxaddr;
	vm_size_t size = 0;	/* To avoid compiler warning */
	int delay;
d313 1
a313 1
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
d357 1
a357 1
	v = (caddr_t)firstaddr;
d386 1
a386 1
	 * We allocate 3/4 as many swap buffer headers as file i/o buffers.
d390 1
a390 1
			bufpages = physmem / 10;
d392 1
a392 1
			bufpages = (btoc(2 * 1024 * 1024) + physmem) / 20;
d394 1
a400 1

d402 1
a402 1
		nswbuf = (nbuf * 3 / 4) & ~1;	/* force even */
d406 1
d413 2
a414 2
		size = (vm_size_t)(v - firstaddr);
		firstaddr = (caddr_t)uvm_km_alloc(kernel_map, round_page(size));
d422 1
a422 1
	if ((vm_size_t)(v - firstaddr) != size)
d430 10
a439 5
	if (uvm_map(kernel_map, (vm_offset_t *) &buffers, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET, UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
	    UVM_INH_NONE, UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("startup: cannot allocate VM for buffers");
	minaddr = (vm_offset_t)buffers;
a444 1
		struct vm_page *pg;
d447 5
a451 4
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
d453 4
a456 14
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL) 
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
			    VM_PROT_ALL);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
d462 2
a463 2
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, TRUE, FALSE, NULL);
d468 2
a469 2
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, TRUE, FALSE, NULL);
d471 9
a479 2
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE, FALSE, NULL);
d486 1
a486 1
	printf("avail mem = %ld\n", ptoa(uvmexp.free));
d488 1
a488 6
	    nbuf, bufpages * PAGE_SIZE);

	/*
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();
d506 1
a506 33
}

void
initcpu()
{
#if defined(M68040) || defined(M68060)
	extern void (*vectab[256]) __P((void));
	void addrerr4060 __P((void));
#endif
#ifdef M68060
	void buserr60 __P((void));
#endif
#ifdef M68040
	void buserr40 __P((void));
#endif

	switch (cputype) {
#ifdef M68060
	case CPU_68060:
		vectab[2] = buserr60;
		vectab[3] = addrerr4060;
		break;
#endif
#ifdef M68040
	case CPU_68040:
		vectab[2] = buserr40;
		vectab[3] = addrerr4060;
		break;
#endif
	default:
		break;
	}
	DCIS();
d528 1
a528 1
	struct frame *frame = (struct frame *)p->p_md.md_regs;
d569 1
a569 1
int	waittime = -1;
d576 1
a576 1
	extern u_long maxaddr;
d580 1
a580 1
		savectx((struct pcb *)curproc->p_addr);
d633 1
a633 1
			 * the MRG_ADB method isn't used.
d635 2
a636 2
			 * Shut down machines whose power functions
			 * are accessed via modified ADB calls.
d638 1
a638 1
			adb_poweroff();
d646 7
a652 4
	/* Map the last physical page VA = PA for doboot() */
	pmap_enter(pmap_kernel(), (vm_offset_t)maxaddr, (vm_offset_t)maxaddr,
	    VM_PROT_ALL, TRUE, VM_PROT_ALL);

d654 1
d734 1
a734 1
 * Dumps always skip the first block of disk space in
d767 1
a767 1
	 * first block in case there is a disk label there.
d896 1
a896 1
	int s = splhigh();
d919 2
a920 2
	int pc;
	int evec;
d929 1
a929 1
int	*nofault;
d940 8
a947 3
	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
d950 2
a951 2
	i = *(volatile short *)addr;
	nofault = (int *)0;
d967 3
a969 3
	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
d972 2
a973 2
	i = *(volatile u_int8_t *)addr;
	nofault = (int *)0;
d989 3
a991 3
	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
d994 2
a995 2
	i = *(volatile u_int16_t *)addr;
	nofault = (int *)0;
d1011 3
a1013 3
	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
d1016 2
a1017 2
	i = *(volatile u_int32_t *)addr;
	nofault = (int *)0;
d1106 1
a1106 1
	int sbytes;
d1110 1
a1110 1
	int s;
d1132 2
a1133 2
			    (int) (((int *)frame) - 1));
			dumpmem(((int *)frame) - 1, sbytes);
d1136 1
a1136 1
			dumpmem((int *)frame->f_regs[15], sbytes);
d1148 1
a1148 1
	int sz;
d1182 1
a1182 1
	int *name;
d1215 1
a1215 1
	int error = ENOEXEC;
d1219 1
a1219 1
	if (((struct exec *)epp->ep_hdr)->a_midmag == ZMAGIC)
d1251 1
a1251 1
	int root_scsi_id;
d1254 3
a1256 3
	 * If flag & 0x80000000 == 0, then we're booting with the old booter
	 * and we should freak out.
	 */
d1262 10
d1279 3
a1281 3
	 * The following are not in a structure so that they can be
	 * accessed more quickly.
	 */
d1288 2
a1289 2
	 * More misc stuff from booter.
	 */
d1303 1
d1307 2
a1308 20
	 * For now, we assume that the boot device is off the first controller.
	 * Booter versions 1.11.0 and later set a flag to tell us to construct
	 * bootdev using the SCSI ID passed in via the environment.
	 */
	root_scsi_id = getenv("ROOT_SCSI_ID");
	if (((mac68k_machine.booter_version < CURRENTBOOTERVER) ||
	    (flag & 0x40000)) && bootdev == 0)
		bootdev = MAKEBOOTDEV(4, 0, 0, root_scsi_id, 0);

	/*
	 * Booter 1.11.3 and later pass a BOOTHOWTO variable with the
	 * appropriate bits set.
	 */
	boothowto = getenv("BOOTHOWTO");
	if (boothowto == 0)
		boothowto = getenv("SINGLE_USER");

	/*
	 * Get end of symbols for kernel debugging
	 */
d1322 2
a1323 2
	 * Save globals stolen from MacOS
	 */
d1325 3
a1327 3
	ROMBase = (caddr_t)getenv("ROMBASE");
	if (ROMBase == (caddr_t)0) {
		ROMBase = (caddr_t)ROMBASE;
d1336 1
a1336 1
 	mrg_ADBIntrPtr = (caddr_t)getenv("ADBINTERRUPT");
d1343 1
a1343 1
	char c;
d1354 1
a1354 1
	char *str;
d1357 7
a1363 7
	 * Returns the value of the environment variable "str".
	 *
	 * Format of the buffer is "var=val\0var=val\0...\0var=val\0\0".
	 *
	 * Returns 0 if the variable is not there, and 1 if the variable is
	 * there without an "=val".
	 */
d1365 2
a1366 2
	char *s, *s1;
	int val, base;
d1482 23
a1504 23
		(caddr_t)0x40807002,	/* where does ADB interrupt */
		(caddr_t)0x0,		/* PM interrupt (?) */
		(caddr_t)0x4080a4d8,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x40807778,	/* CountADBs */
		(caddr_t)0x40807792,	/* GetIndADB */
		(caddr_t)0x408077be,	/* GetADBInfo */
		(caddr_t)0x408077c4,	/* SetADBInfo */
		(caddr_t)0x40807704,	/* ADBReInit */
		(caddr_t)0x408072fa,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080d6d0,	/* WriteParam */
		(caddr_t)0x4080d6fa,	/* SetDateTime */
		(caddr_t)0x4080dbe8,	/* InitUtil */
		(caddr_t)0x4080dd78,	/* ReadXPRam */
		(caddr_t)0x4080dd82,	/* WriteXPRam */
		(caddr_t)0x4080ddd6,	/* jClkNoMem */
		(caddr_t)0x0,		/* ADBAlternateInit */
		(caddr_t)0x0,		/* Egret */
		(caddr_t)0x0,		/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x0,		/* ROMResourceMap List Head */
		(caddr_t)0x40814c58,	/* FixDiv */
		(caddr_t)0x40814b64,	/* FixMul */
d1512 23
a1534 23
		(caddr_t)0x4088ae5e,	/* ADB interrupt */
		(caddr_t)0x408885ec,	/* PB ADB interrupt */
		(caddr_t)0x4088ae0e,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x408888ec,	/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
d1541 23
a1563 23
		(caddr_t)0x40814912,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x408150f0,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
d1571 23
a1593 23
		(caddr_t)0x40a14912,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x40a150f0,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x40a0a360,	/* CountADBs */
		(caddr_t)0x40a0a37a,	/* GetIndADB */
		(caddr_t)0x40a0a3a6,	/* GetADBInfo */
		(caddr_t)0x40a0a3ac,	/* SetADBInfo */
		(caddr_t)0x40a0a752,	/* ADBReInit */
		(caddr_t)0x40a0a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x40a0c05c,	/* WriteParam */
		(caddr_t)0x40a0c086,	/* SetDateTime */
		(caddr_t)0x40a0c5cc,	/* InitUtil */
		(caddr_t)0x40a0b186,	/* ReadXPRam */
		(caddr_t)0x40a0b190,	/* WriteXPRam */
		(caddr_t)0x40a0b1e4,	/* jClkNoMem */
		(caddr_t)0x40a0a818,	/* ADBAlternateInit */
		(caddr_t)0x40a14800,	/* Egret */
		(caddr_t)0x40a147c4,	/* InitEgret */
		(caddr_t)0x40a03ba6,	/* ADBReInit_JTBL */
		(caddr_t)0x40a7eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x40a1c406,	/* FixDiv, wild guess */
		(caddr_t)0x40a1c312,	/* FixMul, wild guess */
d1600 23
a1622 23
		(caddr_t)0x4080a700,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x4080a5aa,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x0,		/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
d1630 23
a1652 23
		(caddr_t)0x408b2eec,	/* ADB interrupt */
		(caddr_t)0x408885ec,	/* PB ADB interrupt */
		(caddr_t)0x408b2e76,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x408888ec,	/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b39b2,	/* jClkNoMem */	/* From PB180 */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x40888400,	/* InitPwrMgr */ /* From PB180 */
		(caddr_t)0x408cce28,	/* ADBReInit_JTBL -- from PB160*/
		(caddr_t)0x4087eb90,	/* ROMRsrcMap List Head -- from PB160*/
		(caddr_t)0x4081c406,	/* FixDiv, wild guess */
		(caddr_t)0x4081c312,	/* FixMul, wild guess */
d1660 23
a1682 23
		(caddr_t)0x408b2dea,	/* ADB int */
		(caddr_t)0x0,		/* PM intr */
 		(caddr_t)0x408b2c72,	/* ADBBase + 130 */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x40809ae6,	/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b39b6,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408d2b64,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv, wild guess */
		(caddr_t)0x4081c312,	/* FixMul, wild guess */
d1690 23
a1712 23
		(caddr_t)0x4080cac6,	/* ADB int */
		(caddr_t)0x0,		/* PM int */
		(caddr_t)0x40805cd4,	/* ADBBase + 130 */
		(caddr_t)0x40839600,	/* CountADBs */
		(caddr_t)0x4083961a,	/* GetIndADB */
		(caddr_t)0x40839646,	/* GetADBInfo */
		(caddr_t)0x4083964c,	/* SetADBInfo */
		(caddr_t)0x408397b8,	/* ADBReInit */
		(caddr_t)0x4083967c,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4081141c,	/* WriteParam */
		(caddr_t)0x4081144e,	/* SetDateTime */
		(caddr_t)0x40811930,	/* InitUtil */
		(caddr_t)0x4080b624,	/* ReadXPRam */
		(caddr_t)0x4080b62e,	/* WriteXPRam */
		(caddr_t)0x40806884,	/* jClkNoMem */
		(caddr_t)0x408398c2,	/* ADBAlternateInit */
		(caddr_t)0x4080cada,	/* Egret */
		(caddr_t)0x4080de14,	/* InitEgret */
		(caddr_t)0x408143b8,	/* ADBReInit_JTBL */
		(caddr_t)0x409bdb60,	/* ROMResourceMap List Head */
		(caddr_t)0x4083b3d8,	/* FixDiv */
		(caddr_t)0x4083b2e4,	/* FixMul */
d1720 23
a1742 23
		(caddr_t)0x400b2efc,	/* ADB int */
		(caddr_t)0x400d8e66,	/* PM int */
		(caddr_t)0x400b2e86,	/* ADBBase + 130 */
		(caddr_t)0x4000a360,	/* CountADBs */
		(caddr_t)0x4000a37a,	/* GetIndADB */
		(caddr_t)0x4000a3a6,	/* GetADBInfo */
		(caddr_t)0x4000a3ac,	/* SetADBInfo */
		(caddr_t)0x4000a752,	/* ADBReInit */
		(caddr_t)0x4000a3dc,	/* ADBOp */
		(caddr_t)0x400d9302,	/* PmgrOp */
		(caddr_t)0x4000c05c,	/* WriteParam */
		(caddr_t)0x4000c086,	/* SetDateTime */
		(caddr_t)0x4000c5cc,	/* InitUtil */
		(caddr_t)0x4000b186,	/* ReadXPRam */
		(caddr_t)0x4000b190,	/* WriteXPRam */
		(caddr_t)0x400b3c08,	/* jClkNoMem */
		(caddr_t)0x4000a818,	/* ADBAlternateInit */
		(caddr_t)0x40009ae6,	/* Egret */ /* From PB520 */
		(caddr_t)0x400147c4,	/* InitEgret */
		(caddr_t)0x400a7a5c,	/* ADBReInit_JTBL */
		(caddr_t)0x4007eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4001c406,	/* FixDiv, wild guess */
		(caddr_t)0x4001c312,	/* FixMul, wild guess */
d1749 23
a1771 23
		(caddr_t)0x408a9b56,	/* ADB int */
		(caddr_t)0x0,		/* PM int */
		(caddr_t)0x408b2f94,	/* ADBBase + 130 */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PmgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3bf8,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408a99c0,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408a82c0,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
d1778 23
a1800 23
		(caddr_t)0x408b2efc,	/* ADB interrupt */
		(caddr_t)0x408885ec,	/* PB ADB interrupt */
		(caddr_t)0x408b2e86,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x408888ec,	/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3bf8,	/* jClkNoMem */ /* from PB 150 */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x0,		/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv, wild guess */
		(caddr_t)0x4081c312,	/* FixMul, wild guess */
d1807 23
a1829 23
		(caddr_t)0x408d16d6,	/* ADB interrupt */
		(caddr_t)0x0,		/* PB ADB interrupt */
		(caddr_t)0x408b2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3c04,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408d1450,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408d24a4,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv for P550 */
		(caddr_t)0x4081c312,	/* FixMul for P550 */
d1836 23
a1858 23
		(caddr_t)0x40acfed6,	/* ADB interrupt */
		(caddr_t)0x0,		/* PB ADB interrupt */
		(caddr_t)0x40ab2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x40a0a360,	/* CountADBs */
		(caddr_t)0x40a0a37a,	/* GetIndADB */
		(caddr_t)0x40a0a3a6,	/* GetADBInfo */
		(caddr_t)0x40a0a3ac,	/* SetADBInfo */
		(caddr_t)0x40a0a752,	/* ADBReInit */
		(caddr_t)0x40a0a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x40a0c05c,	/* WriteParam */
		(caddr_t)0x40a0c086,	/* SetDateTime */
		(caddr_t)0x40a0c5cc,	/* InitUtil */
		(caddr_t)0x40a0b186,	/* ReadXPRam */
		(caddr_t)0x40a0b190,	/* WriteXPRam */
		(caddr_t)0x40ab3bf4,	/* jClkNoMem */
		(caddr_t)0x40a0a818,	/* ADBAlternateInit */
		(caddr_t)0x40acfd40,	/* Egret */
		(caddr_t)0x40a147c4,	/* InitEgret */
		(caddr_t)0x40a038a0,	/* ADBReInit_JTBL */
		(caddr_t)0x40a7eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x40a1c406,	/* FixDiv */
		(caddr_t)0x40a1c312,	/* FixMul */
d1865 23
a1887 23
		(caddr_t)0x408a9bd2,	/* ADB int */
		(caddr_t)0x0,		/* PM intr */
 		(caddr_t)0x408b2f94,	/* ADBBase + 130 */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* Wild guess at ReadXPRam */
		(caddr_t)0x4080b190,	/* Wild guess at WriteXPRam */
		(caddr_t)0x408b39f4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408a99c0,	/* Egret */
		(caddr_t)0x408147c8,	/* InitEgret */
		(caddr_t)0x408a7ef8,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
d1894 23
a1916 23
		(caddr_t)0x40814912,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x408b2f94,	/* ADBBase + 130 interupt */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b39b6,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408d2918,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
d1923 23
a1945 23
		(caddr_t)0x408d16d6,	/* ADB interrupt */
		(caddr_t)0x0,		/* PB ADB interrupt */
		(caddr_t)0x408b2f84,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3c04,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408d1450,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408d2460,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv for P520 */
		(caddr_t)0x4081c312,	/* FixMul for P520 */
d1952 23
a1974 23
		(caddr_t)0x408a9b56,	/* ADB interrupt */
		(caddr_t)0x0,		/* PB ADB interrupt */
		(caddr_t)0x408b2f94,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3bf8,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408a99c0,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408a81a0,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv for P520 */
		(caddr_t)0x4081c312,	/* FixMul for P520 */
d1981 23
a2003 23
		(caddr_t)0x40814912,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x4080a4d8,	/* ADBBase + 130 interrupt; whatzit? */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x40814800,	/* Egret */
		(caddr_t)0x408147c4,	/* InitEgret */
		(caddr_t)0x408038bc,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
d2010 23
a2032 52
		(caddr_t)0x40809f4a,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x4080a4d8,	/* ADBBase + 130 interupt */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x4080b1e4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x0,		/* Egret */
		(caddr_t)0x0,		/* InitEgret */
		(caddr_t)0x408037c0,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
	},
	/*
	 * Vectors verified for the Performa 588 (and 580?)
	 */
	{			/* 19 */
		"Performa 580 ROMs",
		(caddr_t)0x4089a8be,	/* ADB interrupt */
		(caddr_t)0x0,		/* PM ADB interrupt */
		(caddr_t)0x408b2f94,	/* ADBBase + 130 interupt */
		(caddr_t)0x4080a360,	/* CountADBs */
		(caddr_t)0x4080a37a,	/* GetIndADB */
		(caddr_t)0x4080a3a6,	/* GetADBInfo */
		(caddr_t)0x4080a3ac,	/* SetADBInfo */
		(caddr_t)0x4080a752,	/* ADBReInit */
		(caddr_t)0x4080a3dc,	/* ADBOp */
		(caddr_t)0x0,		/* PMgrOp */
		(caddr_t)0x4080c05c,	/* WriteParam */
		(caddr_t)0x4080c086,	/* SetDateTime */
		(caddr_t)0x4080c5cc,	/* InitUtil */
		(caddr_t)0x4080b186,	/* ReadXPRam */
		(caddr_t)0x4080b190,	/* WriteXPRam */
		(caddr_t)0x408b3bf4,	/* jClkNoMem */
		(caddr_t)0x4080a818,	/* ADBAlternateInit */
		(caddr_t)0x408a99c0,	/* Egret */
		(caddr_t)0x408147c8,	/* InitEgret */
		(caddr_t)0x408a7f74,	/* ADBReInit_JTBL */
		(caddr_t)0x4087eb90,	/* ROMResourceMap List Head */
		(caddr_t)0x4081c406,	/* FixDiv */
		(caddr_t)0x4081c312,	/* FixMul */
a2093 1
	{MACH_MACP580, "Performa", " 580 ", MACH_CLASSQ2, &romvecs[19]},
a2135 1
	{ MACH_MACP580,		(caddr_t)0xf9000000,	1024 * 1024 },
d2161 1
a2161 1
char	cpu_model[120];		/* for sysctl() */
d2204 1
a2204 1
	int i;
d2227 1
d2237 2
a2238 1
	get_machine_info();
d2240 2
a2241 1
	load_addr = 0;
d2245 3
d2256 1
a2256 1
		Via1Base = (volatile u_char *)IOBase;
d2267 1
a2267 1
		Via1Base = (volatile u_char *)IOBase;
d2286 1
a2286 1
		Via1Base = (volatile u_char *)IOBase;
d2296 1
a2296 1
	case MACH_CLASSQ2:
a2298 1
	case MACH_CLASSP580:
d2301 1
a2301 1
		Via1Base = (volatile u_char *)IOBase;
d2311 1
a2311 1
		Via1Base = (volatile u_char *)IOBase;
d2321 1
a2321 1
		Via1Base = (volatile u_char *)IOBase;
d2331 1
a2331 1
		Via1Base = (volatile u_char *)IOBase;
d2341 1
a2341 1
		Via1Base = (volatile u_char *)IOBase;
d2351 1
a2351 1
		Via1Base = (volatile u_char *)IOBase;
d2363 1
a2363 1
	 * Set `internal' framebuffer location and length, if we know
d2369 2
a2370 2
			    (u_int32_t)intvid_info[i].fbbase;
			mac68k_vidlen = (u_int32_t)intvid_info[i].fblen;
d2383 2
d2412 2
a2413 2
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0xc000;
d2422 1
a2422 1
			sccA = (volatile u_char *)base + 0xc020;
d2438 2
a2439 2
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0xc020;
a2441 9
	case MACH_CLASSP580:
		/*
		 * Here's a queer bird... it seems to be a cross between
		 * the two different Quadra classes.
		 */
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0xc020;
		SCSIBase = base;
		break;
d2443 2
a2444 2
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0x4000;
d2446 1
a2446 1
		PSCBase = (volatile u_char *)base + 0x31000;
d2459 2
a2460 2
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0x4000;
d2469 2
a2470 2
		Via1Base = (volatile u_char *)base;
		sccA = (volatile u_char *)base + 0x4020;
d2510 1
a2510 1
			((u_long *)videoaddr)[gray_nextaddr++] = 0xaaaaaaaa;
d2512 1
a2512 1
			((u_long *)videoaddr)[gray_nextaddr++] = 0x00000000;
d2535 1
a2535 1
	u_long pte[2], ph, mask;
d2537 1
a2537 1
	int i, numbits;
d2541 1
a2541 1
		ph = ptest040((caddr_t)addr, FC_SUPERD);
d2543 1
a2543 1
			ph = ptest040((caddr_t)addr, FC_USERD);
d2592 2
a2593 2
	char *id;
	u_long limit, maxm;
d2595 1
a2595 1
	u_long addr, phys;
d2633 2
a2634 2
	int i, same;
	u_long addr, lastpage, phys, len;
d2663 22
a2684 24
	if (mac68k_vidlen > 0) {
		/*
		 * We've already figured out where internal video is in
		 * setmachdep() (by using intvid_info[]).  Tell the user
		 * what we know.
		 */
		printf("On-board video at addr 0x%x (phys 0x%x), len 0x%x.\n",
		    mac68k_vidlog, mac68k_vidphys, mac68k_vidlen);
	} else {
		/*
	 	* We should now look through all of NuBus space to find where
	 	* the internal video is being mapped.  Just to be sure we
	 	* handle all the cases, we simply map our NuBus space exactly
	 	* how MacOS did it.  As above, we find a bunch of ranges that
	 	* are contiguously mapped.  Since there are a lot of pages
	 	* that are all mapped to 0, we handle that as a special case
	 	* where the length is negative.  We search in increments of
	 	* 32768 because that's the page size that MacOS uses.
		*/
		nbnumranges = 0;
		for (i = 0; i < NBMAXRANGES; i++) {
			nbphys[i] = 0;
			nblog[i] = 0;
			nblen[i] = 0;
d2686 1
a2686 7

		same = 0;
		for (addr = 0xF9000000; addr < 0xFF000000; addr += 32768) {
			if (!get_physical(addr, &phys)) {
				continue;
			}
			len = nbnumranges == 0 ? 0 : nblen[nbnumranges - 1];
d2689 1
a2689 1
			printf ("0x%lx --> 0x%lx\n", addr, phys);
d2691 10
a2700 4
			if (nbnumranges > 0
			    && addr == nblog[nbnumranges - 1] + len
			    && phys == nbphys[nbnumranges - 1]) {
				/* Same as last one */
a2701 1
				same = 1;
d2703 8
a2710 19
				if ((nbnumranges > 0)
				    && !same
				    && (addr == nblog[nbnumranges - 1] + len)
				    && (phys == nbphys[nbnumranges - 1] + len))
					nblen[nbnumranges - 1] += 32768;
				else {
					if (same) {
						nblen[nbnumranges - 1] = -len;
						same = 0;
					}
					if (nbnumranges == NBMAXRANGES) {
						printf("get_mapping(): "
						    "Too many NuBus ranges.\n");
						break;
					}
					nbnumranges++;
					nblog[nbnumranges - 1] = addr;
					nbphys[nbnumranges - 1] = phys;
					nblen[nbnumranges - 1] = 32768;
d2712 4
d2718 5
a2722 4
		if (same) {
			nblen[nbnumranges - 1] = -nblen[nbnumranges - 1];
			same = 0;
		}
d2724 5
a2728 5
		printf("Non-system RAM (nubus, etc.):\n");
		for (i = 0; i < nbnumranges; i++) {
			printf("     Log = 0x%lx, Phys = 0x%lx, Len = 0x%lx (%lu)\n",
			    nblog[i], nbphys[i], nblen[i], nblen[i]);
		}
d2731 15
a2745 15
		/*
		 * We must now find the logical address of internal video in the
		 * ranges we made above.  Internal video is at physical 0, but
		 * a lot of pages map there.  Instead, we look for the logical
		 * page that maps to 32768 and go back one page.
		 */
		for (i = 0; i < nbnumranges; i++) {
			if (nblen[i] > 0
			    && nbphys[i] <= 32768
			    && 32768 <= nbphys[i] + nblen[i]) {
				mac68k_vidlog = nblog[i] - nbphys[i];
				mac68k_vidlen = nblen[i] + nbphys[i];
				mac68k_vidphys = 0;
				break;
			}
d2747 28
a2774 34
		if (i == nbnumranges) {
			if (0xfee00000 <= videoaddr && videoaddr < 0xfee10000) {
				/*
				 * Kludge for Classic II video.
				 */
				check_video("Classic II video (0xfee09a80)",
				    21888, 21888);
			} else if (0x60000000 <= videoaddr &&
			    videoaddr < 0x70000000) {
				printf("Checking for Internal Video ");
				/*
				 * Kludge for IIvx internal video (60b0 0000).
				 * PB 520 (6000 0000)
				 */
				check_video("PB/IIvx (0x60?00000)",
				    1 * 1024 * 1024, 1 * 1024 * 1024);
			} else if (0x50F40000 <= videoaddr
			    && videoaddr < 0x50FBFFFF) {
				/*
				 * Kludge for LC internal video
				 */
				check_video("LC video (0x50f40000)",
				    512 * 1024, 512 * 1024);
			} else if (0x50100100 <= videoaddr
			    && videoaddr < 0x50400000) {
				/*
				 * Kludge for AV internal video
				 */
				check_video("AV video (0x50100100)",
				    1 * 1024 * 1024, 1 * 1024 * 1024);
			} else {
				printf( "  no internal video at address 0 -- "
					"videoaddr is 0x%lx.\n", videoaddr);
			}
d2776 2
a2777 5
			printf("  Video address = 0x%lx\n", videoaddr);
			printf("  Int video starts at 0x%x\n",
			    mac68k_vidlog);
			printf("  Length = 0x%x (%d) bytes\n",
			    mac68k_vidlen, mac68k_vidlen);
d2779 6
d2826 1
a2826 1
	mac68k_bell_cookie = (caddr_t)cookie;
@


1.64.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64.2.4 2001/07/04 10:18:38 niklas Exp $	*/
d133 7
d357 2
a358 2
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d405 4
d498 2
a499 2
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL,
			    VM_PROT_ALL|PMAP_WIRED);
d509 1
a509 1
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d515 1
a515 1
	    VM_PHYS_SIZE, 0, FALSE, NULL);
d517 7
a523 2
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
d724 1
a724 1
	    VM_PROT_ALL, VM_PROT_ALL|PMAP_WIRED);
d916 1
a916 1
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);
d1156 1
a1156 1
/*	regdump(&(frame.F_t), 128);
d1166 62
@


1.64.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
d191 1
d432 5
d461 2
a462 2
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.64.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64.2.6 2001/11/13 21:00:53 niklas Exp $	*/
d183 3
a185 3
struct vm_map *exec_map = NULL;  
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d221 1
d455 1
a455 1
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
a634 6
	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}

a675 1
haltsys:
@


1.64.2.8
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
d184 1
a348 1
	pmap_update(pmap_kernel());
d478 3
a480 2
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
a483 1
		pmap_update(pmap_kernel());
d498 3
d708 1
a708 1
	pmap_update(pmap_kernel());
a899 1
		pmap_update(pmap_kernel());
@


1.64.2.9
log
@Merge in -current from about a week ago
@
text
@d128 1
a128 1
void netintr(void);
d179 1
a179 1
int	(*mac68k_bell_callback)(void *, int, int, int);
d237 2
a238 2
static void	identifycpu(void);
static u_long	get_physical(u_int, u_long *);
d240 4
a243 4
void	initcpu(void);
int	cpu_dumpsize(void);
int	cpu_dump(int (*)(dev_t, daddr_t, caddr_t, size_t), daddr_t *);
void	cpu_init_kcore_hdr(void);
d246 4
a249 4
void	dumpsys(void);
void	mac68k_init(void);
void	straytrap(int, int);
void	nmihand(struct frame);
d528 2
a529 2
	extern void (*vectab[256])(void);
	void addrerr4060(void);
d532 1
a532 1
	void buserr60(void);
d535 1
a535 1
	void buserr40(void);
d557 1
a557 1
void doboot(void)
d559 1
a559 1
void via_shutdown(void);
d754 1
a754 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d838 1
a838 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d967 1
a967 1
void straytrap(int, int);
d983 1
a983 1
int badaddr(caddr_t);
d1126 1
a1126 1
void	nmihand(struct frame);
d1154 1
a1154 1
int	get_top_of_ram(void);
d1210 2
a1211 2
		extern int sunos_exec_aout_makecmds(struct proc *,
			        struct exec_package *);
d1224 2
a1225 2
void		getenvvars(u_long, char *);
static long	getenv(char *);
d1331 1
a1331 1
static char	toupper(char);
d2186 1
a2186 1
int	mach_cputype(void);
d2222 1
a2222 1
static void	get_machine_info(void);
d2245 1
a2245 1
void	setmachdep(void);
d2548 2
a2549 2
extern u_long ptest040(caddr_t addr, u_int fc);
extern int get_pte(u_int addr, u_long pte[2], u_short * psr);
d2613 1
a2613 1
static void	check_video(char *, u_long, u_long);
d2830 1
a2830 1
void printstar(void);
d2859 1
a2859 1
	int (*callback)(void *, int, int, int);
@


1.64.2.10
log
@Sync the SMP branch with 3.3
@
text
@d106 6
d144 1
a144 1
char	machine[] = MACHINE;	/* from <machine/param.h> */
d213 1
a213 1
unsigned short  mac68k_ttyipl = PSL_S | PSL_IPL2;
d230 1
a230 1
long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
d237 2
a238 2
void	identifycpu(void);
u_long	get_physical(u_int, u_long *);
a239 1
caddr_t	allocsys(caddr_t);
a243 1
int	fpu_probe(void);
a280 14
	/*
	 * Initialize the I/O mem extent map.
	 * Note: we don't have to check the return value since
	 * creation of a fixed extent map will never fail (since
	 * descriptor storage has already been allocated).
	 *
	 * N.B. The iomem extent manages _all_ physical addresses
	 * on the machine.  When the amount of RAM is found, all
	 * extents of RAM are allocated from the map.
	 */
	iomem_ex = extent_create("iomem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)iomem_ex_storage, sizeof(iomem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);

d325 1
a325 1
	caddr_t v;
d343 1
a343 1
		pmap_enter(pmap_kernel(), (vaddr_t)msgbufp + i * NBPG,
d345 2
a346 1
		    VM_PROT_ALL, VM_PROT_ALL|PMAP_WIRED);
d369 20
a388 1
	printf("real mem = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);
d390 19
d410 4
a413 2
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addressses.
d415 29
a443 4
	size = (vsize_t)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(size))) == 0)
		panic("startup: no room for tables");
	if ((allocsys(v) - v) != size)
d451 1
a451 1
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
d455 1
a455 1
	minaddr = (vaddr_t)buffers;
d459 2
a460 2
		vsize_t curbufsize;
		vaddr_t curbuf;
d469 1
a469 1
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
a483 1

d497 3
a499 4
	printf("avail mem = %lu (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
	    nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
a523 46
/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
	/*
	 * Determine how many buffers to allocate.
	 * Use 10% of memory for the first 2 Meg, then 5% of the remaining
	 * memory. Insure a minimum of 16 buffers.
	 */
	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) / 20;
	}

	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	valloc(buf, struct buf, nbuf);
	return (v);
}

d568 1
a568 1
	struct proc *p;
d618 1
d622 1
a622 1
	int howto;
d627 2
a628 2
	if (curproc && curproc->p_addr)
		savectx(&curproc->p_addr->u_pcb);
d638 5
d644 4
d650 1
a656 1
#ifdef notyet
a657 5
#else
#ifdef DIAGNOSTIC
			printf("OpenBSD/mac68k does not trust itself to update the clock on shutdown.\n");
#endif
#endif
d661 5
d673 1
d702 1
a702 1
	pmap_enter(pmap_kernel(), (vaddr_t)maxaddr, (vaddr_t)maxaddr,
d794 1
d801 1
d805 2
a806 1
	if (bdevsw[maj].d_psize == NULL)
d808 1
d810 1
a810 2
	if (nblks <= ctod(1))
		return;
a814 1
	dumpsize += cpu_dumpsize();
d816 14
a829 9
	/* Always skip the first block, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize < dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
d840 1
a840 1
	vaddr_t maddr;	/* PA being dumped */
d894 1
a894 1
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
d899 1
a899 1
bad:
d967 2
a975 1
#ifdef DEBUG
a978 1
#endif
d987 1
a987 1
	caddr_t addr;
d989 1
a989 1
	int i;
d1004 1
a1004 1
	caddr_t addr;
d1006 1
a1006 1
	int i;
d1009 5
d1026 1
a1026 1
	caddr_t addr;
d1028 1
a1028 1
	int i;
d1031 5
d1048 1
a1048 1
	caddr_t addr;
d1050 1
a1050 1
	int i;
d1053 5
d1071 50
a1120 9
#define	DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << (bit))) { \
			netisr &= ~(1 << (bit)); \
			(fn)(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef	DONETISR
d1134 1
a1134 1
	if (nmihanddeep)
d1136 2
a1137 2
	nmihanddeep = 1;

a1144 1

d1202 6
d1224 2
a1225 2
void	getenvvars(u_long, char *);
long	getenv(char *);
a1232 1
#if defined(DDB) || NKSYMS > 0
a1233 1
#endif
a1300 1
#if defined(DDB) || NKSYMS > 0
a1305 1
#endif
d1331 1
a1331 1
char	toupper(char);
d1333 1
a1333 1
char
d1344 1
a1344 1
long
d1469 1
a1469 1
romvec_t romvecs[] =
d2058 1
d2062 4
a2065 4
	{MACH_MACII, "II", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACIIX, "IIx", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACIICX, "IIcx", "", MACH_CLASSII, &romvecs[0]},
	{MACH_MACSE30, "SE/30", "", MACH_CLASSII, &romvecs[0]},
d2068 5
a2072 5
	{MACH_MACIICI, "IIci", "", MACH_CLASSIIci, &romvecs[4]},
	{MACH_MACIISI, "IIsi", "", MACH_CLASSIIsi, &romvecs[2]},
	{MACH_MACIIVI, "IIvi", "", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACIIVX, "IIvx", "", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACIIFX, "IIfx", "", MACH_CLASSIIfx, &romvecs[18]},
d2075 13
a2087 13
	{MACH_MACQ700, "Quadra", " 700", MACH_CLASSQ, &romvecs[4]},
	{MACH_MACQ900, "Quadra", " 900", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ950, "Quadra", " 950", MACH_CLASSQ, &romvecs[17]},
	{MACH_MACQ800, "Quadra", " 800", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ650, "Quadra", " 650", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACC650, "Centris", " 650", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ605, "Quadra", " 605", MACH_CLASSQ, &romvecs[9]},
	{MACH_MACQ605_33, "Quadra", " 605/33", MACH_CLASSQ, &romvecs[9]},
	{MACH_MACC610, "Centris", " 610", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ610, "Quadra", " 610", MACH_CLASSQ, &romvecs[6]},
	{MACH_MACQ630, "Quadra", " 630", MACH_CLASSQ2, &romvecs[13]},
	{MACH_MACC660AV, "Centris", " 660AV", MACH_CLASSAV, &romvecs[7]},
	{MACH_MACQ840AV, "Quadra", " 840AV", MACH_CLASSAV, &romvecs[7]},
d2090 1
a2090 1
	{MACH_MACPB100, "PowerBook", " 100", MACH_CLASSPB, &romvecs[1]},
d2092 10
a2101 10
	{MACH_MACPB140, "PowerBook", " 140", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB145, "PowerBook", " 145", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB150, "PowerBook", " 150", MACH_CLASSDUO, &romvecs[10]},
	{MACH_MACPB160, "PowerBook", " 160", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB165, "PowerBook", " 165", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB165C, "PowerBook", " 165c", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB170, "PowerBook", " 170", MACH_CLASSPB, &romvecs[1]},
	{MACH_MACPB180, "PowerBook", " 180", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB180C, "PowerBook", " 180c", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB500, "PowerBook", " 500", MACH_CLASSPB, &romvecs[8]},
d2104 6
a2109 6
	{MACH_MACPB210, "PowerBook Duo", " 210", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB230, "PowerBook Duo", " 230", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB250, "PowerBook Duo", " 250", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB270, "PowerBook Duo", " 270C", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB280, "PowerBook Duo", " 280", MACH_CLASSDUO, &romvecs[5]},
	{MACH_MACPB280C, "PowerBook Duo", " 280C", MACH_CLASSDUO, &romvecs[5]},
d2112 5
a2116 5
	{MACH_MACP600, "Performa", " 600", MACH_CLASSIIvx, &romvecs[2]},
	{MACH_MACP460, "Performa", " 460", MACH_CLASSLC, &romvecs[14]},
	{MACH_MACP550, "Performa", " 550", MACH_CLASSLC, &romvecs[11]},
	{MACH_MACP580, "Performa", " 580", MACH_CLASSQ2, &romvecs[19]},
	{MACH_MACTV,   "TV",      "",      MACH_CLASSLC, &romvecs[12]},
d2119 8
a2126 8
	{MACH_MACLCII,  "LC", " II",  MACH_CLASSLC, &romvecs[3]},
	{MACH_MACLCIII, "LC", " III", MACH_CLASSLC, &romvecs[14]},
	{MACH_MACLC475, "LC", " 475", MACH_CLASSQ,  &romvecs[9]},
	{MACH_MACLC475_33, "LC", " 475/33", MACH_CLASSQ,  &romvecs[9]},
	{MACH_MACLC520, "LC", " 520", MACH_CLASSLC, &romvecs[15]},
	{MACH_MACLC575, "LC", " 575", MACH_CLASSQ2, &romvecs[16]},
	{MACH_MACCCLASSIC, "Color Classic", "", MACH_CLASSLC, &romvecs[3]},
	{MACH_MACCCLASSICII, "Color Classic"," II", MACH_CLASSLC, &romvecs[3]},
d2128 1
a2128 1
	{MACH_MACCLASSICII, "Classic", " II", MACH_CLASSLC, &romvecs[3]},
d2194 1
a2194 65
int
fpu_probe()
{
	/*
	 * A 68881 idle frame is 28 bytes and a 68882's is 60 bytes.
	 * We, of course, need to have enough room for either.
	 */
	int	fpframe[60 / sizeof(int)];
	label_t	faultbuf;
	u_char	b;

	nofault = (int *) &faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = (int *) 0;
		return (FPU_NONE);
	}

	/*
	 * Synchronize FPU or cause a fault.
	 * This should leave the 881/882 in the IDLE state,
	 * state, so we can determine which we have by
	 * examining the size of the FP state frame
	 */
	asm("fnop");

	nofault = (int *) 0;

	/*
	 * Presumably, if we're an 040 and did not take exception
	 * above, we have an FPU.  Don't bother probing.
	 */
	if (mmutype == MMU_68040)
		return (FPU_68040);

	/*
	 * Presumably, this will not cause a fault--the fnop should
	 * have if this will.  We save the state in order to get the
	 * size of the frame.
	 */
	asm("movl %0, a0; fsave a0@@" : : "a" (fpframe) : "a0" );

	b = *((u_char *) fpframe + 1);

	/*
	 * Now, restore a NULL state to reset the FPU.
	 */
	fpframe[0] = fpframe[1] = 0;
	m68881_restore((struct fpframe *) fpframe);

	/*
	 * The size of a 68881 IDLE frame is 0x18
	 *         and a 68882 frame is 0x38
	 */
	if (b == 0x18)
		return (FPU_68881);
	if (b == 0x38)
		return (FPU_68882);

	/*
	 * If it's not one of the above, we have no clue what it is.
	 */
	return (FPU_UNKNOWN);
}

void
a2196 1
#ifdef DEBUG
d2198 1
a2198 8
#endif

	/*
	 * Print the machine type...
	 */
	sprintf(cpu_model, "Apple Macintosh %s%s",
	    cpu_models[mac68k_machine.cpu_model_index].model_major,
	    cpu_models[mac68k_machine.cpu_model_index].model_minor);
a2199 3
	/*
	 * ... and the CPU type...
	 */
d2201 2
a2202 2
	case CPU_68040:
		strcat(cpu_model, ", 68040 CPU");
d2205 1
a2205 1
		strcat(cpu_model, ", 68030 CPU");
d2207 2
a2208 2
	case CPU_68020:
		strcat(cpu_model, ", 68020 CPU");
d2211 1
a2211 1
		strcat(cpu_model, ", unknown CPU");
d2214 4
a2217 47

	/*
	 * ... and the MMU type...
	 */
	switch (mmutype) {
	case MMU_68040:
	case MMU_68030:
		strcat(cpu_model, "+MMU");
		break;
	case MMU_68851:
		strcat(cpu_model, ", MC68851 MMU");
		break;
	default:
		printf("%s\n", cpu_model);
		panic("unknown MMU type %d", mmutype);
		/* NOTREACHED */
	}

	/*
	 * ... and the FPU type...
	 */
	fputype = fpu_probe();	/* should eventually move to locore */

	switch (fputype) {
	case FPU_68040:
		strcat(cpu_model, "+FPU");
		break;
	case FPU_68882:
		strcat(cpu_model, ", MC6882 FPU");
		break;
	case FPU_68881:
		strcat(cpu_model, ", MC6881 FPU");
		break;
	case FPU_UNKNOWN:
		strcat(cpu_model, ", unknown FPU");
		break;
	default:
		/*strcat(cpu_model, ", no FPU");*/
		break;
	}

	/*
	 * ... and finally, the cache type.
	 */
	if (cputype == CPU_68040)
		strcat(cpu_model, ", 4k on-chip physical I/D caches");

a2218 1
#ifdef DEBUG
a2219 1
#endif
d2222 1
a2222 1
void	get_machine_info(void);
d2224 1
a2224 1
void
d2412 14
d2508 1
a2508 1
u_long gray_nextaddr = 0;
d2557 1
a2557 1
u_long
d2613 1
a2613 1
void	check_video(char *, u_long, u_long);
d2615 1
a2615 1
void
a2643 1
#ifdef DIAGNOSTIC
a2646 1
#endif
d2681 1
a2681 1
#ifdef DIAGNOSTIC
a2693 1
#ifdef DIAGNOSTIC
a2695 1
#endif
a2789 1
#ifdef DIAGNOSTIC
a2790 1
#endif
a2811 1
#ifdef DIAGNOSTIC
a2813 1
#endif
a2815 1
#ifdef DIAGNOSTIC
a2820 1
#endif
@


1.64.2.11
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64.2.10 2003/03/27 23:28:44 niklas Exp $	*/
d355 1
a355 2
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d2184 1
a2184 1
	snprintf(cpu_model, sizeof cpu_model, "Apple Macintosh %s%s",
d2193 1
a2193 1
		strlcat(cpu_model, ", 68040 CPU", sizeof cpu_model);
d2196 1
a2196 1
		strlcat(cpu_model, ", 68030 CPU", sizeof cpu_model);
d2199 1
a2199 1
		strlcat(cpu_model, ", 68020 CPU", sizeof cpu_model);
d2202 1
a2202 1
		strlcat(cpu_model, ", unknown CPU", sizeof cpu_model);
d2212 1
a2212 1
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
d2215 1
a2215 1
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
d2230 1
a2230 1
		strlcat(cpu_model, "+FPU", sizeof cpu_model);
d2233 1
a2233 1
		strlcat(cpu_model, ", MC6882 FPU", sizeof cpu_model);
d2236 1
a2236 1
		strlcat(cpu_model, ", MC6881 FPU", sizeof cpu_model);
d2239 1
a2239 1
		strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
d2242 1
a2242 1
		/*strlcat(cpu_model, ", no FPU", sizeof cpu_model);*/
d2250 1
a2250 1
		strlcat(cpu_model, ", 4k on-chip physical I/D caches", sizeof cpu_model);
@


1.64.2.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64.2.11 2003/05/13 19:41:05 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.64.2.13
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d439 2
a440 2
	printf("avail mem = %lu (%luK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
a525 3
#ifdef FPSP
	extern u_long fpvect_tab, fpvect_end, fpsp_tab;
#endif
a537 4
#ifdef FPSP
		bcopy(&fpsp_tab, &fpvect_tab,
		    (&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
#endif
a542 1

a1022 2

int netisr;
@


1.64.2.14
log
@Merge with the trunk
@
text
@d89 1
d628 1
a628 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
@


1.63
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 1999/06/11 06:19:08 downsj Exp $	*/
d1041 1
a1041 1
		ipv6intr();
@


1.62
log
@Add Q900 compatible mode serial address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 1999/05/24 23:09:03 jason Exp $	*/
d315 3
a317 1
		    high[numranges - 1] + i * NBPG, VM_PROT_ALL, TRUE);
d846 1
a846 1
		    VM_PROT_READ, TRUE);
@


1.61
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 1999/05/23 06:55:06 downsj Exp $	*/
d2417 6
@


1.60
log
@Add patch for Classic II video, from
http://member.nifty.ne.jp/nyamada/netbsd/patch
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 1999/05/22 21:22:25 weingart Exp $	*/
d1065 7
@


1.59
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 1999/04/23 05:15:28 downsj Exp $	*/
d2736 7
a2742 1
		if (0x60000000 <= videoaddr && videoaddr < 0x70000000) {
@


1.58
log
@Kcore dump, from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 1999/04/22 00:35:04 downsj Exp $	*/
a365 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.57
log
@Follow proper OpenBSD shutdown/power off semantics.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 1999/02/15 08:56:05 todd Exp $	*/
d89 2
d126 1
d128 1
d242 2
a243 2
int	astpending=0;
int	want_resched=0;
d247 10
a256 1
void		dumpsys __P((void));
d305 5
d664 1
a664 1
 * These variables are needed by /sbin/savecore
d666 5
a670 3
u_long  dumpmag = 0x8fca0101;	/* magic number */
int     dumpsize = 0;		/* pages */
long    dumplo = 0;		/* blocks */
d672 1
a672 1
static int	get_max_page __P((void));
d674 3
a676 4
static int
get_max_page()
{
	int     i, max = 0;
d678 3
d682 2
a683 2
		if (high[i] > max)
			max = high[i];
a684 1
	return max;
d688 47
d744 5
a748 2
	int     nblks;
	int     maj;
d756 2
a757 4
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize) (dumpdev);
	if (nblks <= ctod(1))
d759 3
d763 3
a765 1
	dumpsize = btoc(get_max_page());
d767 8
a774 40
	/* Always skip the first CLBYTES, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
#define BYTES_PER_DUMP NBPG	/* Must be a multiple of pagesize XXX small */
static vm_offset_t dumpspace;

vm_offset_t	reserve_dumppages __P((vm_offset_t));
static int	find_range __P((vm_offset_t));
static int	find_next_range __P((vm_offset_t));

vm_offset_t
reserve_dumppages(p)
	vm_offset_t p;
{
	dumpspace = p;
	return (p + BYTES_PER_DUMP);
}

static int
find_range(pa)
	vm_offset_t pa;
{
	int     i;

	for (i = 0; i < numranges; i++) {
		if (low[i] <= pa && pa < high[i])
			return i;
a775 2
	return -1;
}
d777 4
a780 20
static int
find_next_range(pa)
	vm_offset_t pa;
{
	int     i, near, best, t;

	near = -1;
	best = 0x7FFFFFFF;
	for (i = 0; i < numranges; i++) {
		if (low[i] <= pa && pa < high[i])
			return i;
		t = low[i] - pa;
		if (t > 0) {
			if (t < best) {
				near = i;
				best = t;
			}
		}
	}
	return near;
d786 13
a798 6
	unsigned bytes, i, n;
	int     range;
	int     maddr, psize;
	daddr_t blkno;
	int     (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
	int     error = 0;
d800 4
a803 1
	msgbufmapped = 0;	/* don't record dump msgs in msgbuf */
d806 1
a806 6

	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
d808 6
a813 8
	if (dumplo < 0)
		return;
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);

	psize = (*bdevsw[major(dumpdev)].d_psize) (dumpdev);
	printf("dump ");
	if (psize == -1) {
		printf("area unavailable.\n");
d816 1
a816 3
	bytes = get_max_page();
	maddr = 0;
	range = find_range(0);
a817 32
	dump = bdevsw[major(dumpdev)].d_dump;
	for (i = 0; i < bytes; i += n) {
		/*
		 * Avoid dumping "holes."
		 */
		if ((range == -1) || (i >= high[range])) {
			range = find_next_range(i);
			if (range == -1) {
				error = EIO;
				break;
			}
			n = low[range] - i;
			maddr += n;
			blkno += btodb(n);
			continue;
		}
		/* Print out how many MBs we have to go. */
		n = bytes - i;
		if (n && (n % (1024 * 1024)) == 0)
			printf("%d ", n / (1024 * 1024));

		/* Limit size for next transfer. */
		if (n > BYTES_PER_DUMP)
			n = BYTES_PER_DUMP;

		(void) pmap_map(dumpspace, maddr, maddr + n, VM_PROT_READ);
		error = (*dump) (dumpdev, blkno, (caddr_t) dumpspace, n);
		if (error)
			break;
		maddr += n;
		blkno += btodb(n);	/* XXX? */
	}
d819 2
a820 1
	switch (error) {
d822 1
a822 3
	case ENXIO:
		printf("device bad\n");
		break;
d824 22
a845 3
	case EFAULT:
		printf("device not ready\n");
		break;
d847 7
a853 3
	case EINVAL:
		printf("area improper\n");
		break;
d855 24
a878 15
	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	case 0:
		printf("succeeded\n");
		break;

	default:
		printf("error %d\n", error);
		break;
d880 1
a880 2
	printf("\n\n");
	delay(5000000);		/* 5 seconds */
@


1.56
log
@sp or stack, not both.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 1999/02/04 23:00:25 niklas Exp $	*/
d611 12
a622 6
		printf("System halted.\n\n");
		via_shutdown();
#ifndef MRG_ADB                 /* adb_poweroff is available only when
                                 * the MRG_ADB method isn't used.       */
                adb_poweroff(); /* Shut down machines whose power functions
                                 * are accessed via modified ADB calls. */
d624 3
a626 2
		printf("You may turn the machine off,");
		printf(" or hit any key to reboot.\n");
@


1.55
log
@Deterministic register initalization on process startup
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 1999/01/07 23:16:00 deraadt Exp $	*/
d503 1
a503 1
setregs(p, pack, sp, retval)
d506 1
a506 1
	u_long  sp;
@


1.54
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 1998/05/03 07:19:54 gene Exp $	*/
d512 1
a512 1
	struct frame *frame;
d514 1
a514 1
	frame = (struct frame *) p->p_md.md_regs;
d516 16
a531 2
	frame->f_regs[SP] = sp;
	frame->f_regs[A2] = (int) PS_STRINGS;
@


1.53
log
@Don't use option MADHATTER.  It is rather silly, and there is no reason not
to pull in the internal video mappings for these models.
Includes support for internal video on the LC475, Centris and Quadras in the
600s, and Q800 and Q900 models.
Poof.  We support far more than NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 1998/05/03 07:15:15 gene Exp $	*/
d127 2
a977 8
void arpintr __P((void));
void ipintr __P((void));
void atintr __P((void));
void nsintr __P((void));
void clnlintr __P((void));
void pppintr __P((void));
void netintr __P((void));

d991 6
@


1.52
log
@Fallout from new cpu.h work.
Also, in the cpu.h merge, we grabbed a few new machine classes.
Add MRG mappings for several of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 1998/04/27 02:01:46 gene Exp $	*/
a2080 1
#ifdef MADHATTER
a2090 1
#endif
a2091 1
#ifdef MADHATTER
a2094 1
#endif
@


1.51
log
@Correct namespace collisions for bus_space_probe and split out
bus_space functions into a separate source file ala NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 1998/03/03 21:24:12 ryker Exp $	*/
a120 1
#include <machine/macinfo.h>
d147 1
a147 1
volatile u_char *Via1Base, *Via2Base;
d209 14
d235 4
d1955 29
d2001 1
a2001 1
	{MACH_MACIIFX, "IIfx ", "", MACH_CLASSIIfx, NULL},
d2011 1
d2014 1
a2014 1
	{MACH_MACQ630, "Quadra", " 630 ", MACH_CLASSQ, &romvecs[13]},
d2050 1
d2068 32
a2099 10
	{MACH_MACPB140,		(caddr_t) 0xfee00000,	32 * 1024},
	{MACH_MACPB145,		(caddr_t) 0xfee00000,	32 * 1024},
	{MACH_MACPB170,		(caddr_t) 0xfee00000,	32 * 1024},
	{MACH_MACPB160,		(caddr_t) 0x60000000,	128 * 1024},
	{MACH_MACPB165,		(caddr_t) 0x60000000,	128 * 1024},
	{MACH_MACPB180,		(caddr_t) 0x60000000,	128 * 1024},
	{MACH_MACPB165C,	(caddr_t) 0xfc040000,	512 * 1024},
	{MACH_MACPB180C,	(caddr_t) 0xfc040000,	512 * 1024},
	{MACH_MACPB500,		(caddr_t) 0x60000000,	512 * 1024},
	{0,			(caddr_t) 0x0,		0},
d2128 2
a2129 1
	char   *mpu;
d2150 1
d2212 1
d2223 1
d2225 2
a2226 1
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
d2242 1
d2244 2
a2245 1
		via_reg(VIA1, vIER) = 0x7f;	/* disable VIA1 int */
a2250 3
		mac68k_vidlog = mac68k_vidphys = 0xf9000000;
		/* Not really, but using too little memory would be wrong */
		mac68k_vidlen = 2 * 1024 * 1024;
d2257 1
d2267 1
d2277 1
d2287 1
d2297 1
d2302 9
a2312 1
	case MACH_CLASSIIfx:
d2371 1
d2394 5
d2402 1
d2411 10
d2423 2
a2424 2
	case MACH_CLASSIIfx:
		panic("Mac IIfx machine class:unsupported machine class.");
d2636 3
a2638 1
		/* printf ("0x%x --> 0x%x\n", addr, phys); */
d2671 1
a2671 1
#if 1
d2698 1
d2715 2
a2716 2
			check_video("AV video (0x50100100)", 2 * 1024 * 1024,
						2 * 1024 * 1024);
@


1.50
log
@GCC 2.8 -Wall (missed one)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 1998/03/03 04:54:22 ryker Exp $	*/
d220 1
a220 1
static	int iomem_malloc_safe;
a225 23
int		bus_mem_add_mapping __P((bus_addr_t, bus_size_t,
		    int, bus_space_handle_t *));

/*
 * Extent maps to manage all memory space, including I/O ranges.  Allocate
 * storage for 8 regions in each, initially.  Later, iomem_malloc_safe
 * will indicate that it's safe to use malloc() to dynamically allocate
 * region descriptors.
 *
 * The extent maps are not static!  Machine-dependent NuBus and on-board
 * I/O routines need access to them for bus address space allocation.
 */
static	long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
struct	extent *iomem_ex;
static	int iomem_malloc_safe;

static void	identifycpu __P((void));
static u_long	get_physical __P((u_int, u_long *));
void		dumpsys __P((void));

int		bus_mem_add_mapping __P((bus_addr_t, bus_size_t,
		    int, bus_space_handle_t *));

a2672 221
}

/*
 * bus.h implementation
 */

int
bus_space_map(t, bpa, size, cacheable, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	u_long pa, endpa;
	int error;

	/*
	 * Before we go any further, let's make sure that this
	 * region is available.
	 */
	error = extent_alloc_region(iomem_ex, bpa, size,
	    EX_NOWAIT | (iomem_malloc_safe ? EX_MALLOCOK : 0));
	if (error)
		return (error);

	pa = mac68k_trunc_page(bpa + t);
	endpa = mac68k_round_page((bpa + t + size) - 1);

#ifdef DIAGNOSTIC
	if (endpa <= pa)
		panic("bus_space_map: overflow");
#endif

	error = bus_mem_add_mapping(bpa, size, cacheable, bshp);
	if (error) {
		if (extent_free(iomem_ex, bpa, size, EX_NOWAIT |
		    (iomem_malloc_safe ? EX_MALLOCOK : 0))) {
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
			    bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}

	return (error);
}

int
bus_space_alloc(t, rstart, rend, size, alignment, boundary, cacheable,
    bpap, bshp)
	bus_space_tag_t t;
	bus_addr_t rstart, rend;
	bus_size_t size, alignment, boundary;
	int cacheable;
	bus_addr_t *bpap;
	bus_space_handle_t *bshp;
{
	u_long bpa;
	int error;

	/*
	 * Sanity check the allocation against the extent's boundaries.
	 */
	if (rstart < iomem_ex->ex_start || rend > iomem_ex->ex_end)
		panic("bus_space_alloc: bad region start/end");

	/*
	 * Do the requested allocation.
	 */
	error = extent_alloc_subregion(iomem_ex, rstart, rend, size, alignment,
	    boundary, EX_NOWAIT | (iomem_malloc_safe ?  EX_MALLOCOK : 0),
	    &bpa);

	if (error)
		return (error);

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	error = bus_mem_add_mapping(bpa, size, cacheable, bshp);
	if (error) {
		if (extent_free(iomem_ex, bpa, size, EX_NOWAIT |
		    (iomem_malloc_safe ? EX_MALLOCOK : 0))) {
			printf("bus_space_alloc: pa 0x%lx, size 0x%lx\n",
			    bpa, size);
			printf("bus_space_alloc: can't free region\n");
		}
	}

	*bpap = bpa;

	return (error);
}

int
bus_mem_add_mapping(bpa, size, cacheable, bshp)
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	u_long pa, endpa;
	vm_offset_t va;

	pa = mac68k_trunc_page(bpa);
	endpa = mac68k_round_page((bpa + size) - 1);

#ifdef DIAGNOSTIC
	if (endpa <= pa)
		panic("bus_mem_add_mapping: overflow");
#endif

	va = kmem_alloc_pageable(kernel_map, endpa - pa);
	if (va == 0)
		return (ENOMEM);

	*bshp = (bus_space_handle_t)(va + (bpa & PGOFSET));

	for (; pa < endpa; pa += NBPG, va += NBPG) {
		pmap_enter(pmap_kernel(), va, pa,
		    VM_PROT_READ | VM_PROT_WRITE, TRUE);
		if (!cacheable)
			pmap_changebit(pa, PG_CI, TRUE);
	}
 
	return 0;
}

void
bus_space_unmap(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	vm_offset_t	va, endva;
	bus_addr_t bpa;

	va = mac68k_trunc_page(bsh);
	endva = mac68k_round_page((bsh + size) - 1);

#ifdef DIAGNOSTIC
	if (endva <= va)
		panic("bus_space_unmap: overflow");
#endif

	bpa = pmap_extract(pmap_kernel(), va) + (bsh & PGOFSET);

	/*
	 * Free the kernel virtual mapping.
	 */
	kmem_free(kernel_map, va, endva - va);

	if (extent_free(iomem_ex, bpa, size,
	    EX_NOWAIT | (iomem_malloc_safe ? EX_MALLOCOK : 0))) {
		printf("bus_space_unmap: pa 0x%lx, size 0x%lx\n",
		    bpa, size);
		printf("bus_space_unmap: can't free region\n");
	}
}

void    
bus_space_free(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	/* bus_space_unmap() does all that we need to do. */
	bus_space_unmap(t, bsh, size);
}

int
bus_space_subregion(t, bsh, offset, size, nbshp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset, size;
	bus_space_handle_t *nbshp;
{

	*nbshp = bsh + offset;
	return (0);
}

int
bus_probe(t, bsh, offset, sz)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset;
	int sz;
{
	int i;
	label_t faultbuf;

	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
		return (0);
	}

	switch (sz) {
	case 1:
		i = bus_space_read_1(t, bsh, offset);
		break;
	case 2:
		i = bus_space_read_2(t, bsh, offset);
		break;
	case 4:
		i = bus_space_read_4(t, bsh, offset);
		break;
	case 8:
		/*FALLTHROUGH*/
	default:
#ifdef DIAGNOSTIC
		printf("bus_probe: unsupported data size %d\n", sz);
#endif
		nofault = (int *)0;
		return (0);
	}

	nofault = (int *)0;
	return (1);
@


1.49
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 1998/03/03 04:30:09 ryker Exp $	*/
d1181 1
a1181 1
		extern sunos_exec_aout_makecmds __P((struct proc *,
@


1.48
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 1998/02/26 15:45:10 gene Exp $	*/
d374 1
a374 1
	if (bufpages == 0)
d379 1
a379 1

@


1.47
log
@Oops.  Pull ddb/db_var.h in.  Should db_console be in db_extern.h, maybe?
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 1998/02/26 07:03:09 gene Exp $	*/
d220 1
a220 1
static	iomem_malloc_safe;
d240 1
a240 1
static	iomem_malloc_safe;
@


1.46
log
@Only break to Debugger() when the panic switch is hit if the syctl'able
db_console is set.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 1997/08/04 21:45:47 gene Exp $	*/
d117 1
@


1.45
log
@Hmmm... quick one-liner that makes the panic() in case of a Mac IIfx machine
class a lot more understandable.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 1997/07/23 04:31:59 denny Exp $	*/
d1046 1
a1046 1
#if DDB
d1048 4
a1051 1
	Debugger();
@


1.44
log
@Add netatalk interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 1997/07/11 20:46:50 gene Exp $	*/
d2339 1
a2339 1
		panic("Unknown/unsupported machine class.");
@


1.43
log
@From Steven Campbel: Allocate a bigger address space for VRAM.  This allows
at least the Q840av to boot and maybe others.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 1997/05/14 04:41:49 gene Exp $	*/
d983 1
d1002 6
@


1.42
log
@Whoops back out some changes from my local tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 1997/05/12 19:59:05 gene Exp $	*/
d2620 2
a2621 2
			check_video("AV video (0x50100100)", 1 * 1024 * 1024,
						1 * 1024 * 1024);
@


1.41
log
@According to Dave Huang (khym@@bga.com), the powerbook 150 works better if we
use Duo-class ROM vectors.  Brings support for this machine much closer.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 1997/04/24 00:54:34 gene Exp $	*/
a88 2
#include <sys/core.h>
#include <sys/kcore.h>
a124 1
#include <machine/kcore.h>	/* XXX should be pulled in by sys/kcore.h */
d243 1
d245 2
a246 13
int	dumpsize __P((void));
int	dump __P((int (*)(dev_t, daddr_t, caddr_t, size_t), daddr_t *));
void	init_kcore_hdr __P((void));

void	dumpsys __P((void));

int	bus_mem_add_mapping __P((bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *));

/*
 * Machine-dependent crash dump header info.
 */
kcore_hdr_t kcore_hdr;
a294 5
	 * Initialize the kernel crash dump header.
	 */
	init_kcore_hdr();

	/*
d591 2
a592 1
	if (howto & RB_DUMP)
d594 1
d616 3
a618 2
	pmap_map(MacOSROMBase, MacOSROMBase, MacOSROMBase + 4 * 1024 * 1024,
	    VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);
d620 1
d628 1
a628 1
 * Initialize the kernel crash dump header.
d630 3
a632 7
void
init_kcore_hdr()
{
	kcore_hdr_t *h = &kcore_hdr;
	struct m68k_kcore_hdr *m = &h->un._m68k;
	int i, j, k;
	extern char end[];
d634 1
a634 1
	bzero(&kcore_hdr, sizeof(kcore_hdr));
d636 4
a639 41
	/*
	 * Initialize the `dispatcher' portion of the header.
	 */
	strcpy(h->name, machine);
	h->page_size = NBPG;
	h->kernbase = KERNBASE;

	/*
	 * Fill in information about our MMU configuration.
	 */
	m->mmutype	= mmutype;
	m->sg_v		= SG_V;
	m->sg_frame	= SG_FRAME;
	m->sg_ishift	= SG_ISHIFT;
	m->sg_pmask	= SG_PMASK;
	m->sg40_shift1	= SG4_SHIFT1;
	m->sg40_mask2	= SG4_MASK2;
	m->sg40_shift2	= SG4_SHIFT2;
	m->sg40_mask3	= SG4_MASK3;
	m->sg40_shift3	= SG4_SHIFT3;
	m->sg40_addr1	= SG4_ADDR1;
	m->sg40_addr2	= SG4_ADDR2;
	m->pg_v		= PG_V;
	m->pg_frame	= PG_FRAME;

	/*
	 * Initialize pointer to kernel segment table.
	 */
	m->sysseg_pa = (u_int32_t)(pmap_kernel()->pm_stpa);

	/*
	 * Initialize relocation value such that:
	 *
	 *	pa = (va - KERNBASE) + reloc
	 */
	m->reloc = load_addr;

	/*
	 * Define the end of the relocatable range.
	 */
	m->relocend = (u_int32_t)end;
d641 3
a643 44
	/*
	 * mac68k has multiple RAM segments on some models.
	 */
	m->ram_segs[0].start = low[0];
	m->ram_segs[0].size  = high[0] - low[0];
	for (i = 1; i < numranges; i++) {
		if ((high[i] - low[i]) == 0)
			continue;	/* shouldn't happen, but be safe */

		/*
		 * Sort and coalesce RAM segments, as required by libkvm.  
		 */
		for (j = 0; m->ram_segs[j].size; j++) {
			if (low[i] < m->ram_segs[j].start)
				break;	/* Insert before this segment */
			if (low[i] <=
			    (m->ram_segs[j].start + m->ram_segs[j].size))
				break;	/* Overlapping or adjoining */
		}

		if (m->ram_segs[j].size) {
			if (low[i] < m->ram_segs[j].start) {
				/* Make room for new segment. */
				for (k = j; m->ram_segs[k].size; k++)
					/* counting... */;
				for (; k > j; k--) {
					m->ram_segs[k].start =
					    m->ram_segs[k - 1].start;
					m->ram_segs[k].size =
					    m->ram_segs[k - 1].size;
				}
			} else if (low[i] <=
			    (m->ram_segs[j].start + m->ram_segs[j].size)) {
				/* Coalesce segments. */
				if (high[i] > (m->ram_segs[j].start +
				    m->ram_segs[j].size))
					m->ram_segs[j].size =
					    high[i] - m->ram_segs[j].start;
				continue;
			}
		}

		m->ram_segs[j].start = low[i];
		m->ram_segs[j].size  = high[i] - low[i];
d645 1
a648 47
 * Compute the size of the machine-dependent crash dump header.
 * Returns size in disk blocks.
 */
int
dumpsize()
{
	int size;

	size = ALIGN(sizeof(kcore_seg_t)) + ALIGN(sizeof(kcore_hdr_t));
	return (btodb(roundup(size, dbtob(1))));
}

/*
 * Called by dumpsys() to dump the machine-dependent header.
 */
int
dump(dump, blknop)
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
	daddr_t *blknop;
{
	int buf[dbtob(1) / sizeof(int)];
	kcore_hdr_t *chdr;
	kcore_seg_t *kseg;
	int error;

	kseg = (kcore_seg_t *)buf;
	chdr = (kcore_hdr_t *)&buf[ALIGN(sizeof(kcore_seg_t)) /
	    sizeof(int)];

	/* Create the segment header. */
	CORE_SETMAGIC(*kseg, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg->c_size = dbtob(1) - ALIGN(sizeof(kcore_seg_t));

	bcopy(&kcore_hdr, chdr, sizeof(kcore_hdr_t));
	error = (*dump)(dumpdev, *blknop, (caddr_t)buf, sizeof(buf));
	*blknop += btodb(sizeof(buf));
	return (error);
}

/*
 * These variables are needed by /sbin/savecore
 */
u_long  dumpmag = 0x8fca0101;	/* magic number */
int     dumpsize = 0;		/* pages */
long    dumplo = 0;		/* blocks */

/*
d658 2
a659 6
	kcore_hdr_t *h = &kcore_hdr;
	struct m68k_kcore_hdr *m = &h->un._m68k;
	int chdrsize;	/* size of dump header */
	int nblks;	/* size of dump area */
	int maj;
	int i;
d670 4
a673 1
	chdrsize = dumpsize();
d675 10
a684 3
	dumpsize = 0;
	for (i = 0; m->ram_segs[i].size && i < M68K_NPHYS_RAM_SEGS; i++)
		dumpsize += btoc(m->ram_segs[i].size);
d686 51
a736 8
	/*
	 * Check to see if we will fit.  Note we always skip the
	 * first CLBYTES in case there is a disk label there.
	 */
	if (nblks < (ctod(dumpsize) + chdrsize + ctod(1))) {
		dumpsize = 0;
		dumplo = -1;
		return;
d738 1
a738 5

	/*
	 * Put dump at the end of the partition.
	 */
	dumplo = (nblks - 1) - ctod(dumpsize) - chdrsize;
d744 6
a749 14
	kcore_hdr_t *h = &kcore_hdr;
	struct m68k_kcore_hdr *m = &h->un._m68k;
	daddr_t blkno;		/* current block to write */
				/* dump routine */
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
	int pg;			/* page being dumped */
	vm_offset_t maddr;	/* PA being dumped */
	int seg;		/* RAM segment being dumped */
	int error;		/* error code from (*dump)() */

	/* XXX initialized here because of gcc lossage */
	seg = 0;
	maddr = m->ram_segs[seg].start;
	pg = 0;
d751 1
a751 4
	/* Don't put dump messages in msgbuf. */
	msgbufmapped = 0;

	/* Make sure dump device is valid. */
d754 6
a759 1
	if (dumpsize == 0) {
a760 3
		if (dumpsize == 0)
			return;
	}
a762 3
	dump = bdevsw[major(dumpdev)].d_dump;
	blkno = dumplo;

d765 1
d767 18
a784 18

	/* Write the dump header. */
	error = dump(dump, &blkno);
	if (error)
		goto bad;

	for (pg = 0; pg < dumpsize; pg++) {
#define NPGMB	(1024*1024/NBPG)
		/* print out how many MBs we have dumped */
		if (pg && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		while (maddr >=
		    (m->ram_segs[seg].start + m->ram_segs[seg].size)) {
			if (++seg >= M68K_NPHYS_RAM_SEGS ||
			    m->ram_segs[seg].size == 0) {
				error = EINVAL;		/* XXX ?? */
				goto bad;
d786 4
a789 1
			maddr = m->ram_segs[seg].start;
d791 26
a816 2
		pmap_enter(pmap_kernel(), (vm_offset_t)vmmap, maddr,
		    VM_PROT_READ, TRUE);
d818 3
a820 7
		error = (*dump)(dumpdev, blkno, vmmap, NBPG);
 bad:
		switch (error) {
		case 0:
			maddr += NBPG;
			blkno += btodb(NBPG);
			break;
d822 3
a824 27
		case ENXIO:
			printf("device bad\n");
			return;

		case EFAULT:
			printf("device not ready\n");
			return;

		case EINVAL:
			printf("area improper\n");
			return;

		case EIO:
			printf("i/o error\n");
			return;

		case EINTR:
			printf("aborted from console\n");
			return;

		default:
			printf("error %d\n", error);
			return;
		}
	}
	printf("succeeded\n");
}
d826 3
a828 7
/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
#define BYTES_PER_DUMP NBPG	/* Must be a multiple of pagesize XXX small */
static vm_offset_t dumpspace;
d830 3
a832 1
vm_offset_t	reserve_dumppages __P((vm_offset_t));
d834 6
a839 6
vm_offset_t
reserve_dumppages(p)
	vm_offset_t p;
{
	dumpspace = p;
	return (p + BYTES_PER_DUMP);
d1193 1
a1193 1
	extern u_long esym;
a1195 1
	extern char end[];
d1258 1
a1258 1
		esym = (u_int32_t)end;
@


1.40
log
@Reorganization fo boot() to make it more logical ala Scott Reynolds.  Also,
fix some prototyping.
@
text
@d89 2
d127 1
a245 1
void		dumpsys __P((void));
d247 13
a259 2
int		bus_mem_add_mapping __P((bus_addr_t, bus_size_t,
		    int, bus_space_handle_t *));
d308 5
d609 1
a609 2
	if (howto & RB_DUMP) {
		savectx(&dumppcb);	/* XXX this goes away soon */
a610 1
	}
d632 2
a633 3
	pmap_map(MacOSROMBase, MacOSROMBase,
		 MacOSROMBase + 4 * 1024 * 1024,
		 VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);
a634 1
	
d642 1
a642 1
 * These variables are needed by /sbin/savecore
d644 93
a736 3
u_long  dumpmag = 0x8fca0101;	/* magic number */
int     dumpsize = 0;		/* pages */
long    dumplo = 0;		/* blocks */
d738 4
a741 1
static int	get_max_page __P((void));
d743 6
a748 2
static int
get_max_page()
d750 1
a750 1
	int     i, max = 0;
d752 29
a780 5
	for (i = 0; i < numranges; i++) {
		if (high[i] > max)
			max = high[i];
	}
	return max;
d784 7
d800 6
a805 2
	int     nblks;
	int     maj;
d816 1
a816 2
	if (nblks <= ctod(1))
		return;
d818 3
a820 1
	dumpsize = btoc(get_max_page());
d822 9
a830 10
	/* Always skip the first CLBYTES, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
}
d832 4
a835 53
/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
#define BYTES_PER_DUMP NBPG	/* Must be a multiple of pagesize XXX small */
static vm_offset_t dumpspace;

vm_offset_t	reserve_dumppages __P((vm_offset_t));
static int	find_range __P((vm_offset_t));
static int	find_next_range __P((vm_offset_t));

vm_offset_t
reserve_dumppages(p)
	vm_offset_t p;
{
	dumpspace = p;
	return (p + BYTES_PER_DUMP);
}

static int
find_range(pa)
	vm_offset_t pa;
{
	int     i;

	for (i = 0; i < numranges; i++) {
		if (low[i] <= pa && pa < high[i])
			return i;
	}
	return -1;
}

static int
find_next_range(pa)
	vm_offset_t pa;
{
	int     i, near, best, t;

	near = -1;
	best = 0x7FFFFFFF;
	for (i = 0; i < numranges; i++) {
		if (low[i] <= pa && pa < high[i])
			return i;
		t = low[i] - pa;
		if (t > 0) {
			if (t < best) {
				near = i;
				best = t;
			}
		}
	}
	return near;
d841 17
a857 6
	unsigned bytes, i, n;
	int     range;
	int     maddr, psize;
	daddr_t blkno;
	int     (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
	int     error = 0;
d859 1
a859 1
	msgbufmapped = 0;	/* don't record dump msgs in msgbuf */
d862 1
a862 6

	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
d864 3
d869 3
a873 1
	psize = (*bdevsw[major(dumpdev)].d_psize) (dumpdev);
d875 18
a892 18
	if (psize == -1) {
		printf("area unavailable.\n");
		return;
	}
	bytes = get_max_page();
	maddr = 0;
	range = find_range(0);
	blkno = dumplo;
	dump = bdevsw[major(dumpdev)].d_dump;
	for (i = 0; i < bytes; i += n) {
		/*
		 * Avoid dumping "holes."
		 */
		if ((range == -1) || (i >= high[range])) {
			range = find_next_range(i);
			if (range == -1) {
				error = EIO;
				break;
d894 1
a894 4
			n = low[range] - i;
			maddr += n;
			blkno += btodb(n);
			continue;
d896 9
a904 12
		/* Print out how many MBs we have to go. */
		n = bytes - i;
		if (n && (n % (1024 * 1024)) == 0)
			printf("%d ", n / (1024 * 1024));

		/* Limit size for next transfer. */
		if (n > BYTES_PER_DUMP)
			n = BYTES_PER_DUMP;

		(void) pmap_map(dumpspace, maddr, maddr + n, VM_PROT_READ);
		error = (*dump) (dumpdev, blkno, (caddr_t) dumpspace, n);
		if (error)
d906 25
a930 2
		maddr += n;
		blkno += btodb(n);	/* XXX? */
d932 2
d935 7
a941 1
	switch (error) {
d943 1
a943 3
	case ENXIO:
		printf("device bad\n");
		break;
d945 6
a950 26
	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	case 0:
		printf("succeeded\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
	printf("\n\n");
	delay(5000000);		/* 5 seconds */
d1304 1
a1304 1
	extern u_long end, esym;
d1307 1
d1370 1
a1370 1
		esym = (long) &end;
d2100 1
a2100 1
	{MACH_MACPB150, "PowerBook", " 150 ", MACH_CLASSPB, &romvecs[10]},
@


1.39
log
@From Scott Reynolds:
>Clean up unused code, KNF bus_probe()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 1997/04/14 18:47:59 gene Exp $	*/
d496 2
a497 1
void doboot __P((void));
d582 1
a582 2
		printf("OpenBSD/mac68k does not trust itself to update the "
		    "RTC on shutdown.\n");
d586 13
a598 1
	splhigh();		/* extreme priority */
d600 1
a600 1
		printf("halted\n\n");
d607 4
a610 5
	} else {
		if (howto & RB_DUMP) {
			savectx(&dumppcb);
			dumpsys();
		}
d612 7
a618 2
		/* run any shutdown hooks */
		doshutdownhooks();
d620 4
a623 13
		/*
		 * Map ROM where the MacOS likes it, so we can reboot,
		 * hopefully.
		 */
		pmap_map(MacOSROMBase, MacOSROMBase,
			 MacOSROMBase + 4 * 1024 * 1024,
			 VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);
		doboot();
		/* NOTREACHED */
	}
	printf("            The system is down.\n");
	printf("You may reboot or turn the machine off, now.\n");
	for (;;);		/* Foil the compiler... */
d649 1
a649 1
 * This is called by configure to set dumplo and dumpsize.
@


1.38
log
@Bring our incarnation of John Wittowski's direct adb driver into compatible
state with NetBSD's.  The direct-to-ADB code is now enabled by default.
Using 'options MRG_ADB' will cause the kernel to revert to the 'old standby'
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 1997/04/07 03:23:35 briggs Exp $	*/
d2871 3
a2873 8
#ifdef lint
	i = *addr;
	if (i)
		return (0);
#endif
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *) nofault)) {
		nofault = (int *) 0;
d2893 1
a2893 1
		nofault = (int *) 0;
d2897 1
a2897 1
	nofault = (int *) 0;
@


1.37
log
@Ahem...  bus_probe() already exists and does what bus_space_bad_addr() does.
Nuke the latter.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 1997/04/05 16:22:07 briggs Exp $	*/
d590 2
a591 2
#ifdef HWDIRECT                 /* adb_poweroff is available only when
                                 * the HWDIRECT ADB method is used. */
@


1.36
log
@Implement a bus_space_bad_addr() function to aid in some device probing with
the bus_space universe.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 1997/04/05 15:29:10 briggs Exp $	*/
a886 36
bus_space_bad_addr(t, h, o, sz)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o;
	int			sz;
{
	register int i;
	label_t faultbuf;

#ifdef lint
	i = *addr;
	if (i)
		return (0);
#endif
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *) nofault)) {
		nofault = (int *) 0;
		return (1);
	}
	switch (sz) {
	default:
	case 1:
		i = bus_space_read_1(t, h, o);
		break;
	case 2:
		i = bus_space_read_2(t, h, o);
		break;
	case 4:
		i = bus_space_read_4(t, h, o);
		break;
	}
	nofault = (int *) 0;
	return (0);
}

int
d2570 1
a2570 1
#if 0
a2596 1
			printf("Checking for Internal Video ");
@


1.35
log
@MRG-based ADB support for the PowerBook series.  Contributed by
hamada@@next.etron.kanazawa-it.ac.jp (Takashi Hamada)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 1997/03/28 12:38:59 briggs Exp $	*/
d885 36
@


1.34
log
@Use more from m68k/m68k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 1997/03/15 05:51:15 briggs Exp $	*/
d2156 1
a2156 2
		/* Disable everything but PM; we need it. */
		via_reg(VIA1, vIER) = 0x6f;	/* disable VIA1 int */
d2173 1
a2173 2
		/* Disable everything but PM; we need it. */
		via_reg(VIA1, vIER) = 0x6f;	/* disable VIA1 int */
@


1.33
log
@AV macs don't have SONIC, they have MACE, and 040 PBs do have SONIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 1997/03/12 13:37:00 briggs Exp $	*/
a538 317
}

#define SS_RTEFRAME	1
#define SS_FPSTATE	2
#define SS_USERREGS	4

struct sigstate {
	int     ss_flags;	/* which of the following are valid */
	struct frame ss_frame;	/* original exception frame */
	struct fpframe ss_fpstate;	/* 68881/68882 state info */
};
/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int     sf_signum;	/* signo for handler */
	siginfo_t	*sf_sip;
	struct sigcontext *sf_scp;	/* context ptr for handler */
	sig_t   sf_handler;	/* handler addr for u_sigc */
	struct sigstate sf_state;	/* state of the hardware */
	struct sigcontext sf_sc;/* actual context */
	siginfo_t	sf_si;
};
#ifdef DEBUG
int     sigdebug = 0x0;
int     sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t   catcher;
	int     sig, mask;
	u_long  code;
	int	type;
	union sigval val;
{
	extern short	exframesize[];
	extern char	sigcode[], esigcode[];
	register struct proc *p = curproc;
	register struct sigframe *fp, *kfp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short	ft;
	int     oonstack;

	frame = (struct frame *) p->p_md.md_regs;
	ft = frame->f_format;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	if ((psp->ps_flags & SAS_ALTSTACK) && oonstack == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *) (psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct sigframe));
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *) frame->f_regs[SP] - 1;
	if ((unsigned) fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void) grow(p, (unsigned) fp);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %p usp %p scp %p ft %d\n",
		    p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
#endif
	if (useracc((caddr_t) fp, sizeof(struct sigframe), B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): useracc failed on sig %d\n",
			    p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	kfp = malloc(sizeof(struct sigframe), M_TEMP, M_WAITOK);
	/* Build the argument list for the signal handler. */
	kfp->sf_signum = sig;
	kfp->sf_sip = NULL;
	kfp->sf_scp = &fp->sf_sc;
	kfp->sf_handler = catcher;

	/*
	 * Save necessary hardware state.  Currently this includes:
	 *	- general registers
	 *	- original exception frame (if not a "normal" frame)
	 *	- FP coprocessor state
	 */
	kfp->sf_state.ss_flags = SS_USERREGS;
	bcopy((caddr_t) frame->f_regs,
	    (caddr_t) kfp->sf_state.ss_frame.f_regs, sizeof frame->f_regs);
	if (ft >= FMT9) {
#ifdef DEBUG
		if (ft != FMT9 && ft != FMTA && ft != FMTB)
			panic("sendsig: bogus frame type");
#endif
		kfp->sf_state.ss_flags |= SS_RTEFRAME;
		kfp->sf_state.ss_frame.f_format = frame->f_format;
		kfp->sf_state.ss_frame.f_vector = frame->f_vector;
		bcopy((caddr_t) & frame->F_u,
		    (caddr_t) & kfp->sf_state.ss_frame.F_u, exframesize[ft]);
		/*
		 * Leave an indicator that we need to clean up the kernel
		 * stack.  We do this by setting the "pad word" above the
		 * hardware stack frame to the amount the stack must be
		 * adjusted by.
		 *
		 * N.B. we increment rather than just set f_stackadj in
		 * case we are called from syscall when processing a
		 * sigreturn.  In that case, f_stackadj may be non-zero.
		 */
		frame->f_stackadj += exframesize[ft];
		frame->f_format = frame->f_vector = 0;
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sendsig(%d): copy out %d of frame %d\n",
			    p->p_pid, exframesize[ft], ft);
#endif
	}
	if (fputype) {
		kfp->sf_state.ss_flags |= SS_FPSTATE;
		m68881_save(&kfp->sf_state.ss_fpstate);
	}
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *) &kfp->sf_state.ss_fpstate)
		printf("sendsig(%d): copy out FP state (%x) to %p\n",
		    p->p_pid, *(u_int *) & kfp->sf_state.ss_fpstate,
		    &kfp->sf_state.ss_fpstate);
#endif

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	kfp->sf_sc.sc_onstack = oonstack;
	kfp->sf_sc.sc_mask = mask;
	kfp->sf_sc.sc_sp = frame->f_regs[SP];
	kfp->sf_sc.sc_fp = frame->f_regs[A6];
	kfp->sf_sc.sc_ap = (int) &fp->sf_state;
	kfp->sf_sc.sc_pc = frame->f_pc;
	kfp->sf_sc.sc_ps = frame->f_sr;

	if (psp->ps_siginfo & sigmask(sig)) {
		kfp->sf_sip = &fp->sf_si;
		initsiginfo(&kfp->sf_si, sig, code, type, val);
	}

	/* XXX For perf., do not copy out siginfo if not needed */
	(void) copyout((caddr_t) kfp, (caddr_t) fp, sizeof(struct sigframe));
	frame->f_regs[SP] = (int) fp;
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): sig %d scp %p fp %p sc_sp %x sc_ap %x\n",
		    p->p_pid, sig, kfp->sf_scp, fp,
		    kfp->sf_sc.sc_sp, kfp->sf_sc.sc_ap);
#endif
	/*
	 * Signal trampoline code is at base of user stack.
	 */
	frame->f_pc = (int) (((char *) PS_STRINGS) - (esigcode - sigcode));
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n",
		    p->p_pid, sig);
#endif
	free((caddr_t) kfp, M_TEMP);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper priviledges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	extern short	exframesize[];
	struct sigcontext *scp, context;
	struct frame	*frame;
	struct sigstate	tstate;
	int     rf, flags;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
	if ((int) scp & 1)
		return (EINVAL);
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	if (useracc((caddr_t) scp, sizeof(*scp), B_WRITE) == 0 ||
	    copyin(scp, &context, sizeof(context)))
		return (EINVAL);
	scp = &context;
	if ((scp->sc_ps & (PSL_MBZ | PSL_IPL | PSL_S)) != 0)
		return (EINVAL);
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 1)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask & ~sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->sc_sp;
	frame->f_regs[A6] = scp->sc_fp;
	frame->f_pc = scp->sc_pc;
	frame->f_sr = scp->sc_ps;

	/*
	 * Grab pointer to hardware state information.
	 * If zero, the user is probably doing a longjmp.
	 */
	if ((rf = scp->sc_ap) == 0)
		return (EJUSTRETURN);
	/*
	 * See if there is anything to do before we go to the
	 * expense of copying in close to 1/2K of data
	 */
	flags = fuword((caddr_t) rf);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): sc_ap %x flags %x\n",
		    p->p_pid, rf, flags);
#endif
	/*
	 * fuword failed (bogus sc_ap value).
	 */
	if (flags == -1)
		return (EINVAL);
	if (flags == 0 || copyin((caddr_t) rf, (caddr_t) & tstate, sizeof tstate))
		return (EJUSTRETURN);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sigreturn(%d): ssp %p usp %x scp %p ft %d\n",
		    p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		    (flags & SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
#endif
	/*
	 * Restore most of the users registers except for A6 and SP
	 * which were handled above.
	 */
	if (flags & SS_USERREGS)
		bcopy((caddr_t) tstate.ss_frame.f_regs,
		    (caddr_t) frame->f_regs, sizeof(frame->f_regs) - 2 * NBPW);
	/*
	 * Restore long stack frames.  Note that we do not copy
	 * back the saved SR or PC, they were picked up above from
	 * the sigcontext structure.
	 */
	if (flags & SS_RTEFRAME) {
		register int sz;

		/* grab frame type and validate */
		sz = tstate.ss_frame.f_format;
		if (sz > 15 || (sz = exframesize[sz]) < 0)
			return (EINVAL);
		frame->f_stackadj -= sz;
		frame->f_format = tstate.ss_frame.f_format;
		frame->f_vector = tstate.ss_frame.f_vector;
		bcopy((caddr_t) & tstate.ss_frame.F_u, (caddr_t) & frame->F_u, sz);
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sigreturn(%d): copy in %d of frame type %d\n",
			    p->p_pid, sz, tstate.ss_frame.f_format);
#endif
	}
	/*
	 * Finally we restore the original FP context
	 */
	if (flags & SS_FPSTATE)
		m68881_restore(&tstate.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *) &tstate.ss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %p\n",
		    p->p_pid, *(u_int *) & tstate.ss_fpstate,
		    &tstate.ss_fpstate);
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
@


1.32
log
@Remove some more warnings left over from NetBSD's new config.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 1997/03/08 16:17:04 briggs Exp $	*/
d2477 2
d2501 1
a2505 1
		mac68k_machine.sonic = 1;
@


1.31
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 1997/02/26 06:17:02 gene Exp $	*/
d2496 3
a2507 4
		if (cpui->machineid == MACH_MACQ700) {
			mac68k_vidlog = mac68k_vidphys = 0xf9000000;
			mac68k_vidlen = 2 * 1024 * 1024;
		}
@


1.30
log
@Add actual functions to do bus space manipulation.  Modify the
copyright as necessarry, too.

Also, while we're here, do s/NetBSD/Openbsd/ or s/NetBSD/BSD/ ass appropriate.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.29 1997/02/23 06:04:59 briggs Exp $	*/
/*	$NetBSD: machdep.c,v 1.129 1997/01/09 07:20:46 scottr Exp $	*/
d99 2
a101 1
#include <sys/mount.h>
d177 4
d228 13
d245 3
d492 1
d1521 2
a1522 3
	if (bootdev == 0) {
		bootdev = (root_scsi_id << 16) | 4;
	}
d1524 1
a1524 1
	if (boothowto == 0) {
a1525 1
	}
a2584 1
	extern volatile u_char *ASCBase;
a2603 1
		ASCBase = (volatile u_char *) base + 0x14000;
a2622 1
		ASCBase = (volatile u_char *) base + 0x14000;
a2627 1
		ASCBase = (volatile u_char *) base + 0x14000;
a2637 1
		ASCBase = (volatile u_char *) base + 0x14000;
d2971 26
@


1.29
log
@Integrate code from John P. Wittkoski <jpw@@netwizards.net> and
Takashi Hamada <hamada@@next.etron.kanazawa-it.ac.jp>.  This code
interfaces directly to the hardware to support the ADB on many
macs.  It is enabled by "options HWDIRECT" in the configuration
file.  At some point, this should probably become the default method
as interfacing to the ADB through the ROMs has been painful and sometimes
problematic.

This code should have functioning ADB support for:
	II series (II, SE/30, IIx, IIcx)
	IIsi series (IIsi, IIci, IIvx, IIvi)
	LC II, LC III
	Performa 400, 405, 430, 460, 465, 467, 600
	Classic II, Color Classic, Color Classic II
	PB 5XX series
	Duo series
	PB 140,145,145b,160,(160c?),165,165c,170,180,180c
	Quadra 700,900,950
There is an off-chance that it will work on:
	PB 150, PB 190
	Quadra/Centris 605,610,630,650,660AV,800,840AV
	LC 475,550,575,630
	Performa 475,476,575,577,578,630
Note that functioning ADB support does not mean that everything else
will work.  I obviously do not own all of the above machines (does
anyone?  ;-)...  Any reports are welcome.

Many thanks to John Wittkoski and Takashi Hamada!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1997/02/21 05:49:29 briggs Exp $	*/
d5 1
d102 1
d123 1
d203 20
d876 1
a876 1
		printf("NetBSD/mac68k does not trust itself to update the "
d1656 1
a1656 1
 * set also in the ROM.  Luckily most of the routines used by NetBSD fall
d1661 1
a1661 1
 * The machine-specific routines currently used by NetBSD/mac68k include:
d1671 1
a1671 1
 * Only three of the nine different ROMs are important to NetBSD/mac68k.
d1673 1
a1673 1
 * NetBSD due to other hardware limitations such as 68000 CPU, no MMU
d1678 1
a1678 1
 *            All machines which use this ROM are now supported by NetBSD.
d1680 1
a1680 1
 *            NetBSD/mac68k.  This ROM is always 256K in length.
d1694 1
a1694 1
 *             routines used by NetBSD/mac68k in this ROM, and except for the
d1696 2
a1697 2
 *             known by NetBSD/mac68k.  Desktop machines listed here that are
 *             not yet running NetBSD probably only lack the necessary
d2549 1
a2549 1
	 * Space to NetBSD Address Space.
d2567 14
d2956 226
@


1.28
log
@Bring in siginfo changes from mvme68k port & Theo.  Compiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 1997/01/24 01:35:48 briggs Exp $	*/
d132 2
a135 1
#include "macrom.h"
@


1.27
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 1997/01/19 03:58:06 briggs Exp $	*/
d510 1
a510 1
	int     sf_code;	/* additional info for handler */
d515 1
d529 1
a529 1
sendsig(catcher, sig, mask, code)
d533 2
d591 1
a591 1
	kfp->sf_code = code;
d594 1
d653 7
d861 5
@


1.26
log
@asm -> __asm, inline -> __inline
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.25 1997/01/16 20:43:36 kstailey Exp $	*/
/*	$NetBSD: machdep.c,v 1.122 1996/10/15 06:40:39 scottr Exp $	*/
a144 1
u_long	conspa;
a1408 1
	struct exec *execp = epp->ep_hdr;
d1411 2
a1412 1
	if (execp->a_midmag == ZMAGIC)	/* i.e., MID == 0. */
d1429 5
a1433 1
void	initenv __P((u_long, char *));
d1436 1
a1436 1
initenv(flag, buf)
d1440 6
a1449 1

d1452 1
a1452 1
	} else {
d1454 69
d1524 8
a1546 2
static long	getenv __P((char *));

d2277 17
d2320 1
a2320 1
	char   *proc;
d2322 3
a2324 3
	switch (mac68k_machine.mach_processor) {
	case MACH_68020:
		proc = ("(68020)");
d2326 2
a2327 2
	case MACH_68030:
		proc = ("(68030)");
d2329 2
a2330 2
	case MACH_68040:
		proc = ("(68040)");
a2331 1
	case MACH_PENTIUM:
d2333 1
a2333 1
		proc = ("(unknown processor)");
d2339 1
a2339 1
	    proc);
d2350 1
a2350 1
	for (i = 0; cpu_models[i].model_major; i++) {
a2352 1
	}
a2359 98
/*
 * getenvvars: Grab a few useful variables
 */
void	getenvvars __P((void));

void
getenvvars()
{
	extern u_long bootdev, videobitdepth, videosize;
	extern u_long end, esym;
	extern u_long macos_boottime, MacOSROMBase;
	extern long macos_gmtbias;
	int     root_scsi_id;

	root_scsi_id = getenv("ROOT_SCSI_ID");
	/*
         * For now, we assume that the boot device is off the first controller.
         */
	if (bootdev == 0) {
		bootdev = (root_scsi_id << 16) | 4;
	}

	if (boothowto == 0) {
		boothowto = getenv("SINGLE_USER");
	}

	/* These next two should give us mapped video & serial */
	/* We need these for pre-mapping graybars & echo, but probably */
	/* only on MacII or LC.  --  XXX */
	/* videoaddr = getenv("MACOS_VIDEO"); */
	/* sccaddr = getenv("MACOS_SCC"); */

	/*
         * The following are not in a structure so that they can be
         * accessed more quickly.
         */
	videoaddr = getenv("VIDEO_ADDR");
	videorowbytes = getenv("ROW_BYTES");
	videobitdepth = getenv("SCREEN_DEPTH");
	videosize = getenv("DIMENSIONS");

	/*
         * More misc stuff from booter.
         */
	mac68k_machine.machineid = getenv("MACHINEID");
	switch (mac68k_machine.mach_processor = getenv("PROCESSOR")) {
	case MACH_68040:
		mmutype = MMU_68040;
		break;
	default:;
	}
	mac68k_machine.mach_memsize = getenv("MEMSIZE");
	mac68k_machine.do_graybars = getenv("GRAYBARS");
	mac68k_machine.serial_boot_echo = getenv("SERIALECHO");
	mac68k_machine.serial_console = getenv("SERIALCONSOLE");

	mac68k_machine.modem_flags = getenv("SERIAL_MODEM_FLAGS");
	mac68k_machine.modem_cts_clk = getenv("SERIAL_MODEM_HSKICLK");
	mac68k_machine.modem_dcd_clk = getenv("SERIAL_MODEM_GPICLK");
	mac68k_machine.print_flags = getenv("SERIAL_PRINT_FLAGS");
	mac68k_machine.print_cts_clk = getenv("SERIAL_PRINT_HSKICLK");
	mac68k_machine.print_dcd_clk = getenv("SERIAL_PRINT_GPICLK");
	/* Should probably check this and fail if old */
	mac68k_machine.booter_version = getenv("BOOTERVER");

	/*
         * Get end of symbols for kernel debugging
         */
	esym = getenv("END_SYM");
#ifndef SYMTAB_SPACE
	if (esym == 0)
#endif
		esym = (long) &end;

	/* Get MacOS time */
	macos_boottime = getenv("BOOTTIME");

	/* Save GMT BIAS saved in Booter parameters dialog box */
	macos_gmtbias = getenv("GMTBIAS");

	/*
         * Save globals stolen from MacOS
         */

	ROMBase = (caddr_t) getenv("ROMBASE");
	if (ROMBase == (caddr_t) 0) {
		ROMBase = (caddr_t) ROMBASE;
	}
	MacOSROMBase = (unsigned long) ROMBase;
	TimeDBRA = getenv("TIMEDBRA");
	ADBDelay = (u_short) getenv("ADBDELAY");
	HwCfgFlags  = getenv("HWCFGFLAGS");
	HwCfgFlags2 = getenv("HWCFGFLAG2");
	HwCfgFlags3 = getenv("HWCFGFLAG3");
 	ADBReInit_JTBL = getenv("ADBREINIT_JTBL");
 	mrg_ADBIntrPtr = (caddr_t) getenv("ADBINTERRUPT");
}

d2374 1
a2392 8
	 * Get the console buffer physical address.  If we can't, we
	 * assume that videoaddr is already a physical address.
 	 * Note that get_physical doesn't yet work on the '040.
	 */
	if ((mmutype == MMU_68040) || !get_physical(videoaddr, &conspa))
		conspa = videoaddr;

	/*
d2493 13
d2598 4
a2601 4
	__asm("movl a0, sp@@-");
	__asm("movl a1, sp@@-");
	__asm("movl d0, sp@@-");
	__asm("movl d1, sp@@-");
d2612 5
a2616 4
	__asm("movl sp@@+, d1");
	__asm("movl sp@@+, d0");
	__asm("movl sp@@+, a1");
	__asm("movl sp@@+, a0");
d2621 1
a2621 1
extern int ptest040 __P((u_int addr));
d2639 6
a2644 3
		ph = ptest040(addr);
		if (!(ph & MMU40_RES))
			return 0;
d2646 2
a2647 2
		*phys = ph;
		mask = 0x00000fff;
d2681 1
a2681 1
	*phys = (ph & ~mask) | (addr & mask);
d2859 6
d2891 4
a2894 4
	__asm("movl a0, sp@@-");
	__asm("movl a1, sp@@-");
	__asm("movl d0, sp@@-");
	__asm("movl d1, sp@@-");
d2898 4
a2901 4
	__asm("movl sp@@+, d1");
	__asm("movl sp@@+, d0");
	__asm("movl sp@@+, a1");
	__asm("movl sp@@+, a0");
@


1.25
log
@do not call resettodr() if RB_TIMEBAD is set due to being in ddb with clock updates suspended
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1996/11/05 01:40:29 briggs Exp $	*/
d2592 4
a2595 4
	asm("movl a0, sp@@-");
	asm("movl a1, sp@@-");
	asm("movl d0, sp@@-");
	asm("movl d1, sp@@-");
d2606 4
a2609 4
	asm("movl sp@@+, d1");
	asm("movl sp@@+, d0");
	asm("movl sp@@+, a1");
	asm("movl sp@@+, a0");
d2875 4
a2878 4
	asm("movl a0, sp@@-");
	asm("movl a1, sp@@-");
	asm("movl d0, sp@@-");
	asm("movl d1, sp@@-");
d2882 4
a2885 4
	asm("movl sp@@+, d1");
	asm("movl sp@@+, d0");
	asm("movl sp@@+, a1");
	asm("movl sp@@+, a0");
@


1.24
log
@Use romvecs[14] for the P460, not romvecs[3].  From Bob Nestor
<nestor@@metronet.com> with some verification from Pete Nush.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1996/10/28 14:55:31 briggs Exp $	*/
d832 2
a833 1
		 * will be out of synch; adjust it now.
d835 5
a839 1
		resettodr();
@


1.23
log
@Include macinfo.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1996/10/28 03:48:53 briggs Exp $	*/
d2169 1
a2169 1
	{MACH_MACP460, "Performa", " 460 ", MACH_CLASSLC, &romvecs[3]},
@


1.22
log
@Most 040 models have scsi regs at base + 0x10000, not base + 0xf000
like the Q700.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1996/10/23 04:49:48 briggs Exp $	*/
d117 1
@


1.21
log
@Sync up with NetBSD and include patch from Dave Huang <khym@@bga.com>
that puts AV I/O in the right place.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 1996/10/14 01:24:58 briggs Exp $	*/
d2520 10
a2529 1
		SCSIBase = base + 0xf000;
d2540 1
a2540 1
		SCSIBase = base + 0xf000;
d2545 1
a2545 1
		ASCBase = NULL;
@


1.20
log
@More from NetBSD:
* Update ROM vectors for PB500
* Add ROM vectors for the LCIII (verified by Mike DeLima--miked@@netrover.com)
* fpu_type->fputype
* Use defines from m68k/cpu.h
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.19 1996/09/21 04:03:58 briggs Exp $	*/
/*	$NetBSD: machdep.c,v 1.121 1996/10/13 03:21:39 christos Exp $	*/
d564 1
a564 1
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x ft %d\n",
d634 1
a634 1
		printf("sendsig(%d): copy out FP state (%x) to %x\n",
d653 1
a653 1
		printf("sendsig(%d): sig %d scp %x fp %x sc_sp %x sc_ap %x\n",
d698 1
a698 1
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d751 1
a751 1
		printf("sigreturn(%d): ssp %x usp %x scp %x ft %d\n",
d791 1
a791 1
		printf("sigreturn(%d): copied in FP state (%x) at %x\n",
d1127 3
d1521 59
a1579 10
 * Egret, ADBReInit_JTBL and ROMResourceMap were added to these
 *  tables.  Egret probably isn't used anyplace anymore, but I was
 *  inspired by the default value that was used in "macrom.c".  That
 *  value was most likely non-functional for all but a few systems,
 *  so putting it here will hopefully localize system-specific ROM
 *  addresses.  Likewise ADBReInit_JTBL and ROMResourceMap are
 *  currently used on only a few systems, but changes in the Booter
 *  and changes in ROM Mapping were causing problems.  Hopefully
 *  those problems will be eliminated by having the proper addresses
 *  for those machines in this table.
a1580 4
 * What we probably need is a little MacOS Utility that can suck all
 *  these addresses from the System, tell the user if his/er system
 *  is currently supported via the romvec tables, and provide a
 *  formatted output file for inclusion here if it isn't.
d1638 1
a1638 1
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
d1657 9
a1665 9
		(caddr_t) 0x40a0c05c,	/* WriteParam */
		(caddr_t) 0x40a0c086,	/* SetDateTime */
		(caddr_t) 0x40a0c5cc,	/* InitUtil */
		(caddr_t) 0x40a0b186,	/* ReadXPRam */
		(caddr_t) 0x40a0b190,	/* WriteXPRam */
		(caddr_t) 0x40ab39b6,	/* jClkNoMem */
		(caddr_t) 0x40a0a818,	/* ADBAlternateInit */
		(caddr_t) 0x40a14800,	/* Egret */
		(caddr_t) 0x40a147c4,	/* InitEgret */
d1667 3
a1669 3
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
		(caddr_t) 0x40a1c406,	/* FixDiv */
		(caddr_t) 0x40a1c312,	/* FixMul */
d1686 14
a1699 9
		(caddr_t) 0,	/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b39b6,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408147c4,	/* InitEgret */
d1726 1
a1726 1
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
d1731 2
a1732 2
	 * Vectors verified for Duo 230, PB 180, PB 165
	 * (Duo 210?  PB 165?  PB 160?  Duo 250?  Duo 270?)
d1761 2
a1762 1
	 * Quadra, Centris merged table (C650, 610, Q800?)
d1785 2
a1786 2
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
d1791 2
a1792 2
	 * Quadra 840AV (but ADBBase + 130 intr is unknown)
	 * (PM intr is known to be 0, PMgrOp is guessed to be 0)
d1851 1
a1851 1
	 * Q 605 (but guessing at ADBBase + 130, based on Q 650)
d1857 1
a1857 1
		(caddr_t) 0x408a99de,	/* ADBBase + 130 */
d1870 1
a1870 1
		(caddr_t) 0x0,		/* jClkNoMem */
d1872 1
a1872 1
		(caddr_t) 0x40814800,	/* Egret */
d1874 4
a1877 4
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
		(caddr_t) 0x4081c406,	/* FixDiv, wild guess */
		(caddr_t) 0x4081c312,	/* FixMul, wild guess */
d1904 1
a1904 1
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
d1938 1
a1938 1
	 * Vectors for the MacTV
a1965 1

d1967 1
a1967 1
	 * Vectors verified for Quadra 630
d1984 1
a1996 1
	 * (Universal ROM version 0x067c)
d2024 87
d2133 1
a2133 1
	{MACH_MACQ950, "Quadra", " 950 ", MACH_CLASSQ, &romvecs[2]},
d2137 1
a2137 1
	{MACH_MACQ605, "Quadra", " 605", MACH_CLASSQ, &romvecs[9]},
d2162 1
a2162 1
	{MACH_MACPB270, "PowerBook Duo", " 270 ", MACH_CLASSDUO, &romvecs[5]},
d2176 2
a2177 2
	{MACH_MACLC520, "LC", " 520 ", MACH_CLASSLC, &romvecs[3]},
	{MACH_MACLC575, "LC", " 575 ", MACH_CLASSLC, &romvecs[3]},
d2179 1
d2436 1
d2520 18
a2537 1
		SCSIBase = base;
a2540 1
	case MACH_CLASSAV:
d2599 1
d2616 4
a2619 21
	/* This can not work for the 040, yet */
	if (mmutype == MMU_68040)
		return 0;

	if (mmutype == MMU_68040)
		return 0;

	i = get_pte(addr, pte, &psr);

	switch (i) {
	case -1:
		return 0;
	case 0:
		ph = pte[0] & 0xFFFFFF00;
		break;
	case 1:
		ph = pte[1] & 0xFFFFFF00;
		break;
	default:
		panic("get_physical(): bad get_pte()");
	}
d2621 4
a2624 5
	/*
	 * We must now figure out how many levels down we went and
	 * mask the bits appropriately -- the returned value may only
	 * be the upper n bits, and we've got to take the rest from addr.
	 */
d2626 12
a2637 4
	numbits = 0;
	psr &= 0x0007;		/* Number of levels we went */
	for (i = 0; i < psr; i++)
		numbits += (macos_tc >> (12 - i * 4)) & 0x0f;
d2639 9
a2647 5
	/*
	 * We have to take the most significant "numbits" from
	 * the returned value "ph", and the rest from our addr.
	 * Assume that numbits != 0.
	 */
d2649 7
a2655 1
	mask = (1 << (32 - numbits)) - 1;
@


1.19
log
@Do not call get_physical if 040.  Hardwire Q700 internal video for now.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.18 1996/08/10 21:37:46 briggs Exp $	*/
/*	$NetBSD: machdep.c,v 1.114 1996/08/06 04:03:33 scottr Exp $	*/
a198 5
/*
 * For the fpu emulation and fpu driver.
 */
int     fpu_type;

d478 1
a478 1
	if (fpu_type) {
d628 1
a628 1
	if (fpu_type) {
d1625 1
a1625 1
	 * (LC III?  Other LC's?  680x0 Performas?)
d1787 1
a1787 1
		(caddr_t) 0x0,		/* jClkNoMem */
d1789 1
a1789 1
		(caddr_t) 0x40814800,	/* Egret */
d1791 2
a1792 2
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
d1941 30
d2034 1
a2034 1
	{MACH_MACLCIII, "LC", " III ", MACH_CLASSLC, &romvecs[3]},
d2246 2
a2247 2
	 * punt and set it to 0.  Note that get_physical doesn't yet
	 * work on the '040.
d2250 1
a2250 1
		conspa = 0;
d2461 3
d2487 1
a2487 1
	for (i = 0; i < psr; i++) {
a2488 1
	}
@


1.18
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1996/07/27 11:40:38 deraadt Exp $	*/
d2221 2
a2222 1
	 * punt and set it to 0.
d2224 1
a2224 1
	if (!get_physical(videoaddr, &conspa))
d2279 4
d2431 4
@


1.17
log
@handle RB_CONFIG
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.16 1996/06/23 15:39:10 briggs Exp $	*/
/*	$NetBSD: machdep.c,v 1.110 1996/06/21 06:11:02 scottr Exp $	*/
d144 1
d204 3
a206 2
static void identifycpu __P((void));
void dumpsys __P((void));
d1917 29
d1975 1
a1975 1
	{MACH_MACQ630, "Quadra", " 630 ", MACH_CLASSQ, &romvecs[6]},
a2030 1
 *	Quadra	630
d2200 1
d2216 1
a2216 1
	if (firstpass == 0)
d2220 2
a2221 4
	 * Set up current ROM Glue vectors.  Actually now all we do
	 * is save the address of the ROM Glue Vector table. This gets
	 * used later when we re-map the vectors from MacOS Address
	 * Space to NetBSD Address Space.
d2223 2
a2224 1
	mrg_MacOSROMVectors = cpui->rom_vectors;
d2239 1
d2320 10
a2418 2
static u_long	get_physical __P((u_int, u_long *));

d2422 1
a2422 1
	u_long  pte[2], ph;
d2457 1
a2457 3
	 * Assume that the lower (32-numbits) bits of ph are
	 * already zero.  Also assume numbits != 0.  Also, notice
	 * that this is an addition, not an "or".
d2460 2
a2461 1
	*phys = ph + (addr & ((1 << (32 - numbits)) - 1));
@


1.16
log
@From scottr/NetBSD:
Test for serial console in adb_init() early, and abort if we're using it.
Initiialize ROM vectors regardless of this so that the PRAM RTC read and
write work regardless of whether a serial console is in use.

Add missing cpu model info for Powerbook 500, and correct the ROM
vectors for the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 1996/06/08 16:21:16 briggs Exp $	*/
d443 7
@


1.15
log
@Sync up with latest NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.14 1996/05/26 18:36:22 briggs Exp $	*/
/*	$NetBSD: machdep.c,v 1.108 1996/06/07 10:48:26 briggs Exp $	*/
d1763 1
a1763 1
	 * PB 540 (but ADBBase + 130 intr and PMgrOp is unknown)
d1770 1
a1770 1
		(caddr_t) 0x0,		/* ADBBase + 130 */
d1777 1
a1777 1
		(caddr_t) 0x0,		/* PmgrOp */
d1953 1
d2187 1
a2187 2
	if ((mac68k_machine.serial_console & 0x03) == 0)
		mrg_MacOSROMVectors = cpui->rom_vectors;
@


1.14
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: machdep.c,v 1.105 1996/05/25 14:45:31 briggs Exp $	*/
d1694 1
a1694 1
		(caddr_t) 0x408b39b2,	/* jClkNoMem */		/* From PB180 */
d1697 3
a1699 3
		(caddr_t) 0x40888400,	/* InitPwrMgr */	/* From PB180 */
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
d1901 1
a1901 1
		(caddr_t) 0x40ad1450,	/* Egret */
d1903 2
a1904 2
		(caddr_t) 0x0,		/* ADBReInit_JTBL */
		(caddr_t) 0x0,		/* ROMResourceMap List Head */
d2107 7
d2186 1
a2186 1
	if ((mac68k_machine.serial_console & 0x01) == 0)
@


1.13
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.12
log
@kill the panic at the boot().
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.82 1995/11/21 04:00:43 briggs Exp $	*/
d110 5
d131 1
a131 1
#include "via.h"
a242 2
	extern struct map	*useriomap;
	extern long		Usrptsize;
d430 1
a430 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
d443 1
d445 2
a446 16
	if (current_mac_model->class == MACH_CLASSII) {
		/*
		 * For the bloody Mac II ROMs, we have to map this space
		 * so that the PRam functions will work.
		 * Gee, Apple, is that a hard-coded hardware address in
		 * your code?  I think so! (_ReadXPRam + 0x0062)  We map
		 * the first 
		 */
#ifdef DIAGNOSTIC
		printf("I/O map kludge for old ROMs that use hardware %s",
			"addresses directly.\n");
#endif
		pmap_map(0x50f00000, 0x50f00000, 0x50f00000 + 0x4000,
			 VM_PROT_READ|VM_PROT_WRITE);
	}
}
d807 1
a807 1
		savectx(curproc->p_addr);
d823 1
d829 6
d872 2
d932 4
d948 1
a948 1
	int     i, max = 0;
a987 1
	int     c;
d1001 1
a1001 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d1113 3
d1126 3
d1150 1
d1167 45
a1211 1
	i = *(volatile char *) addr;
d1216 8
a1258 15
#if defined(DEBUG) && !defined(PANICBUTTON)
#define PANICBUTTON
#endif

#ifdef PANICBUTTON
int     panicbutton = 1;	/* non-zero if panic buttons are enabled */
int     crashandburn = 0;
int     candbdelay = 50;	/* give em half a second */

candbtimer()
{
	crashandburn = 0;
}
#endif

d1262 2
d1281 3
d1323 3
d1330 1
a1330 1
	register int i, val, same;
d1349 2
a1353 4
	u_long  search = 0xb00bfade;
	u_long  i, found, store;
	char   *p, *zero;

d1360 1
d1390 1
d1400 1
a1400 1
		return cpu_exec_prep_oldzmagic(p, epp);
d1414 1
a1414 42
#ifdef COMPAT_NOMID
int
cpu_exec_prep_oldzmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	struct exec *execp = epp->ep_hdr;
	struct exec_vmcmd *ccmdp;

	epp->ep_taddr = 0;
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = epp->ep_taddr + execp->a_text;
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

	/* check if vnode is in open for writing, because we want to
	 * demand-page out of it.  if it is, don't do it, for various reasons */
	if ((execp->a_text != 0 || execp->a_data != 0) &&
	    epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0\n");
#endif
		return ETXTBSY;
	}
	epp->ep_vp->v_flag |= VTEXT;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_text,
	    epp->ep_taddr, epp->ep_vp, NBPG,	/* should NBPG be CLBYTES? */
	    VM_PROT_READ | VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_data,
	    epp->ep_daddr, epp->ep_vp,
	    execp->a_text + NBPG,	/* should NBPG be CLBYTES? */
	    VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);

	/* set up command for bss segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, execp->a_bss,
	    epp->ep_daddr + execp->a_data, NULLVP, 0,
	    VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);
d1416 1
a1416 5
	return exec_aout_setup_stack(p, epp);
}
#endif				/* COMPAT_NOMID */

static char *envbuf = NULL;
d1435 2
d1448 2
d1463 1
a1463 1
	char   *s, *s1, *s2;
d1511 18
a1528 1
 *ROM Vector information for calling drivers in ROMs
d1536 1
a1536 1
		0,		/* PM interrupt (?) */
d1544 1
a1544 1
		0,		/* PMgrOp */
d1551 7
a1557 2
		0,			/* ADBAlternateInit */
		0,			/* InitEgret */
d1560 1
a1560 1
	 * Vectors verified for PB 140, PB 170
d1582 1
d1584 4
d1595 1
a1595 1
		(caddr_t) 0,	/* PM ADB interrupt */
d1603 14
a1616 9
		(caddr_t) 0,	/* PMgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x4080b1e4,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408147c4,	/* InitEgret */
d1625 1
a1625 1
		(caddr_t) 0,	/* PM ADB interrupt */
d1634 8
a1641 8
		(caddr_t) 0x40a0c05c,	/* WriteParam */
		(caddr_t) 0x40a0c086,	/* SetDateTime */
		(caddr_t) 0x40a0c5cc,	/* InitUtil */
		(caddr_t) 0x40a0b186,	/* ReadXPRam */
		(caddr_t) 0x40a0b190,	/* WriteXPRam */
		(caddr_t) 0x40ab39b6,	/* jClkNoMem */
		(caddr_t) 0x40a0a818,	/* ADBAlternateInit */
		(caddr_t) 0x40a147c4,	/* InitEgret */
d1649 1
a1649 1
		(caddr_t) 0,	/* PM ADB interrupt */
d1657 1
a1657 1
		(caddr_t) 0,	/* PMgrOp */
d1665 1
d1667 4
d1693 1
a1693 1
		(caddr_t) 0x0,	/* jClkNoMem */
d1695 6
a1700 1
		(caddr_t) 0x408147c4,	/* InitEgret */
d1708 1
a1708 1
		0,			/* PM intr */
d1724 1
d1726 4
d1738 2
a1739 2
		0,		/* PM int */
		 /* !?! */ 0,	/* ADBBase + 130 */
d1746 14
a1759 9
		0,		/* PMgrOp */
		(caddr_t) 0x0,	/* WriteParam */
		(caddr_t) 0x0,	/* SetDateTime */
		(caddr_t) 0x0,	/* InitUtil */
		(caddr_t) 0x0,	/* ReadXPRam */
		(caddr_t) 0x0,	/* WriteXPRam */
		(caddr_t) 0x0,	/* jClkNoMem */
		0,			/* ADBAlternateInit */
		0,			/* InitEgret */
d1769 1
a1769 1
		 /* !?! */ 0,	/* ADBBase + 130 */
d1776 14
a1789 9
		 /* !?! */ 0,	/* PmgrOp */
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x0,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408147c4,	/* InitEgret */
d1797 1
a1797 1
		0,		/* PM int */
d1805 1
a1805 1
		0,		/* PmgrOp */
d1811 1
a1811 1
		(caddr_t) 0x0,	/* jClkNoMem */
d1813 1
d1815 4
d1821 1
a1821 1
	 * Vectors verified for Duo 270c
d1840 1
a1840 1
		(caddr_t) 0x0,	/* jClkNoMem */
d1842 1
d1844 62
d1929 1
a1929 1
	{MACH_MACQ950, "Quadra", " 950 ", MACH_CLASSQ, &romvecs[6]},
d1937 2
a1938 2
	{MACH_MACC660AV, "Centris", " 660AV ", MACH_CLASSQ, &romvecs[7]},
	{MACH_MACQ840AV, "Quadra", " 840AV ", MACH_CLASSQ, &romvecs[7]},
d1945 1
d1952 8
a1959 6
	{MACH_MACPB210, "PowerBook", " 210 ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB230, "PowerBook", " 230 ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB250, "PowerBook", " 250 ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB270, "PowerBook", " 270 ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB280, "PowerBook", " 280 ", MACH_CLASSPB, &romvecs[5]},
	{MACH_MACPB280C, "PowerBook", " 280C ", MACH_CLASSPB, &romvecs[5]},
d1964 2
a1965 1
	{MACH_MACP550, "Performa", " 550 ", MACH_CLASSLC, &romvecs[3]},
d1970 1
a1970 1
	{MACH_MACLC475, "LC", " 475 ", MACH_CLASSLC, &romvecs[3]},
a1976 3
/* The hopeless ones... */
	{MACH_MACTV, "TV ", "", MACH_CLASSH, NULL},

d1998 2
d2033 2
a2037 1
	char   *proc;
d2054 3
a2056 1
extern void
d2143 1
d2148 2
d2173 4
a2176 1
	 * Set up current ROM Glue vectors
d2179 1
a2179 1
		mrg_setvectors(cpui->rom_vectors);
d2206 16
d2223 1
a2287 12
	case MACH_CLASSII:
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0x4000;
		ASCBase = (volatile u_char *) base + 0x14000;
		SCSIBase = base;
		break;
	case MACH_CLASSPB:
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0x4000;
		ASCBase = (volatile u_char *) base + 0x14000;
		SCSIBase = base;
		break;
d2294 3
a2297 5
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0x4000;
		ASCBase = (volatile u_char *) base + 0x14000;
		SCSIBase = base;
		break;
a2298 5
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0x4000;
		ASCBase = (volatile u_char *) base + 0x14000;
		SCSIBase = base;
		break;
a2299 5
		Via1Base = (volatile u_char *) base;
		sccA = (volatile u_char *) base + 0x4000;
		ASCBase = (volatile u_char *) base + 0x14000;
		SCSIBase = base;
		break;
d2355 1
a2355 1
extern int get_pte(u_int addr, u_long pte[2], u_short * psr);
d2363 3
a2365 1
u_long
d2413 3
a2415 1
void
d2437 1
a2437 1
				printf("to a conservative %dK.\n", maxm / 1024);
d2482 1
a2482 1
	printf("System RAM: %d bytes in %d pages.\n", addr, addr / NBPG);
d2484 1
a2484 1
		printf("     Low = 0x%x, high = 0x%x\n", low[i], high[i]);
d2511 1
a2511 1
		len = nblen[nbnumranges - 1];
d2520 1
a2520 1
			if (nbnumranges > 0
d2522 2
a2523 2
			    && addr == nblog[nbnumranges - 1] + len
			    && phys == nbphys[nbnumranges - 1] + len) {
d2546 1
a2546 1
#if 1
d2549 1
a2549 1
		printf("     Log = 0x%x, Phys = 0x%x, Len = 0x%x (%ud)\n",
d2573 1
d2578 1
a2578 1
			check_video("IIvx/PB kludge", 1 * 1024 * 1024,
d2584 2
a2585 7
			check_video("LC video kludge", 512 * 1024, 512 * 1024);
		} else if (0x90000000 <= videoaddr && videoaddr < 0xF0000000) {
			/*
			 * Kludge for NuBus Superspace video
			 */
			check_video("NuBus Super kludge",
				    4 * 1024 * 1024, 1 * 1024 * 1024);
d2588 1
a2588 1
				"videoaddr is 0x%x.\n", videoaddr);
d2591 1
a2591 1
		printf("  Video address = 0x%x\n", videoaddr);
d2604 1
@


1.11
log
@Fix #include.  (param.h -> sys/param.h).
@
text
@d821 5
@


1.10
log
@New self-calibrating spin-wait delay() from Scott Reynolds <scottr@@edsi.org>.
@
text
@d79 1
a79 1
#include <param.h>
@


1.9
log
@Updates from Kelly Campbell <camk@@ksu.ksu.edu> for some ROM addresses.
@
text
@d224 2
@


1.8
log
@from netbsd -- remove some more dead code (PR #1931)
@
text
@d1582 8
a1589 8
		(caddr_t) 0x4080c05c,	/* WriteParam */
		(caddr_t) 0x4080c086,	/* SetDateTime */
		(caddr_t) 0x4080c5cc,	/* InitUtil */
		(caddr_t) 0x4080b186,	/* ReadXPRam */
		(caddr_t) 0x4080b190,	/* WriteXPRam */
		(caddr_t) 0x408b39b6,	/* jClkNoMem */
		(caddr_t) 0x4080a818,	/* ADBAlternateInit */
		(caddr_t) 0x408147c4,	/* InitEgret */
@


1.7
log
@Add first guesses for a few more machines.
Also set sonic flag for MACH_CLASSQ.
@
text
@a1907 1
	extern u_long locore_dodebugmarks;
a1952 1
	locore_dodebugmarks = mac68k_machine.do_graybars;
@


1.6
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1791 1
d1809 3
a1811 1
	{MACH_MACPB270, "PowerBook", " 270 ", MACH_CLASSPB, &romvecs[10]},
d2055 1
@


1.5
log
@Use 115200 for IIci's serial clock constant, too.  Wierd that it ever worked
otherwise...
@
text
@d558 1
a558 1
		fp = (struct sigframe *) (psp->ps_sigstk.ss_base +
@


1.4
log
@Declare emul_sunos so '040 cache flush will compile.
@
text
@d2062 1
a2062 1
		mac68k_machine.sccClkConst = 122400;
@


1.3
log
@update from netbsd (without losing local changes)
@
text
@d468 3
@


1.2
log
@integrate 040 MDP_UNCACHE_WX cache changes by niklas & deraadt
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.80 1995/10/07 06:25:48 mycroft Exp $	*/
a125 5
#ifdef COMPAT_SUNOS
#include <compat/sunos/sunos_syscall.h>
extern struct emul emul_sunos;
#endif

d838 4
d2068 1
a2068 1
		mac68k_machine.sccClkConst = 122400;
d2077 1
a2077 1
		mac68k_machine.sccClkConst = 122400;
@


1.1
log
@Initial revision
@
text
@d126 5
d486 12
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

