head	1.24;
access;
symbols
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.16
	OPENBSD_5_0:1.23.0.14
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.12
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.10
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.8
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.12
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.10
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.8
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_9_BASE:1.4
	NIKLAS_UNDEAD:1.4.0.10
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.12;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.24.13.24.21;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.11.20.57.44;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.17.00.08.36;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.15.18.52.44;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.28.14.04.24;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.11.28.15.34.16;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.05.10.00.35;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.27.04.22.37;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.09.20.34.36;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.08.08.09.01;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.08.17.30.40;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	99.09.03.18.01.11;	author art;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.04.24.06.39.41;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.05.11.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.04.27.02.01.45;	author gene;	state Exp;
branches;
next	;

1.4.4.1
date	2001.07.04.10.18.35;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2002.03.06.01.05.35;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.13;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: bus_space.c,v 1.23 2008/06/26 05:42:12 ray Exp $	*/
/*	$NetBSD: bus_space.c,v 1.5 1999/03/26 23:41:30 mycroft Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Implementation of bus_space mapping for mac68k.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/extent.h>

#include <machine/bus.h>

#include <uvm/uvm_extern.h>

int	bus_mem_add_mapping(bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);

extern struct extent *iomem_ex;
extern int iomem_malloc_safe;
label_t *nofault;

int
bus_space_map(t, bpa, size, flags, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int flags;
	bus_space_handle_t *bshp;
{
	paddr_t pa, endpa;
	int error;

	/*
	 * Before we go any further, let's make sure that this
	 * region is available.
	 */
	error = extent_alloc_region(iomem_ex, bpa, size,
	    EX_NOWAIT | (iomem_malloc_safe ? EX_MALLOCOK : 0));
	if (error)
		return (error);

	pa = trunc_page(bpa + t);
	endpa = round_page((bpa + t + size) - 1);

#ifdef DIAGNOSTIC
	if (endpa <= pa)
		panic("bus_space_map: overflow");
#endif

	error = bus_mem_add_mapping(bpa, size, flags, bshp);
	if (error) {
		if (extent_free(iomem_ex, bpa, size, EX_NOWAIT |
		    (iomem_malloc_safe ? EX_MALLOCOK : 0))) {
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
			    bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}

	return (error);
}

int
bus_space_alloc(t, rstart, rend, size, alignment, boundary, flags, bpap, bshp)
	bus_space_tag_t t;
	bus_addr_t rstart, rend;
	bus_size_t size, alignment, boundary;
	int flags;
	bus_addr_t *bpap;
	bus_space_handle_t *bshp;
{
	u_long bpa;
	int error;

	/*
	 * Sanity check the allocation against the extent's boundaries.
	 */
	if (rstart < iomem_ex->ex_start || rend > iomem_ex->ex_end)
		panic("bus_space_alloc: bad region start/end");

	/*
	 * Do the requested allocation.
	 */
	error = extent_alloc_subregion(iomem_ex, rstart, rend, size, alignment,
	    0, boundary,
	    EX_FAST | EX_NOWAIT | (iomem_malloc_safe ?  EX_MALLOCOK : 0),
	    &bpa);

	if (error)
		return (error);

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	error = bus_mem_add_mapping(bpa, size, flags, bshp);
	if (error) {
		if (extent_free(iomem_ex, bpa, size, EX_NOWAIT |
		    (iomem_malloc_safe ? EX_MALLOCOK : 0))) {
			printf("bus_space_alloc: pa 0x%lx, size 0x%lx\n",
			    bpa, size);
			printf("bus_space_alloc: can't free region\n");
		}
	}

	*bpap = bpa;

	return (error);
}

int
bus_mem_add_mapping(bpa, size, flags, bshp)
	bus_addr_t bpa;
	bus_size_t size;
	int flags;
	bus_space_handle_t *bshp;
{
	u_long pa, endpa;
	vaddr_t va;
	pt_entry_t pte;

	pa = trunc_page(bpa);
	endpa = round_page((bpa + size) - 1);

#ifdef DIAGNOSTIC
	if (endpa <= pa)
		panic("bus_mem_add_mapping: overflow");
#endif

	va = uvm_km_valloc(kernel_map, endpa - pa);
	if (va == 0)
		return (ENOMEM);

	bshp->base = (u_long)(va + m68k_page_offset(bpa));
	bshp->swapped = 0;
	bshp->bsr1 = mac68k_bsr1;
	bshp->bsr2 = mac68k_bsr2;
	bshp->bsr4 = mac68k_bsr4;
	bshp->bsrm1 = mac68k_bsrm1;
	bshp->bsrm2 = mac68k_bsrm2;
	bshp->bsrm4 = mac68k_bsrm4;
	bshp->bsrr1 = mac68k_bsrr1;
	bshp->bsrr2 = mac68k_bsrr2;
	bshp->bsrr4 = mac68k_bsrr4;
	bshp->bsw1 = mac68k_bsw1;
	bshp->bsw2 = mac68k_bsw2;
	bshp->bsw4 = mac68k_bsw4;
	bshp->bswm1 = mac68k_bswm1;
	bshp->bswm2 = mac68k_bswm2;
	bshp->bswm4 = mac68k_bswm4;
	bshp->bswr1 = mac68k_bswr1;
	bshp->bswr2 = mac68k_bswr2;
	bshp->bswr4 = mac68k_bswr4;
	bshp->bssm1 = mac68k_bssm1;
	bshp->bssm2 = mac68k_bssm2;
	bshp->bssm4 = mac68k_bssm4;
	bshp->bssr1 = mac68k_bssr1;
	bshp->bssr2 = mac68k_bssr2;
	bshp->bssr4 = mac68k_bssr4;

	if (flags & BUS_SPACE_MAP_CACHEABLE)
		pte = PG_CWT;
	else
		pte = PG_CI;

	for (; pa < endpa; pa += PAGE_SIZE, va += PAGE_SIZE)
		pmap_enter_cache(pmap_kernel(), va, pa,
		    UVM_PROT_RW, UVM_PROT_RW | PMAP_WIRED, pte);
	pmap_update(pmap_kernel());
 
	return 0;
}

void
bus_space_unmap(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	vaddr_t va, endva;
	bus_addr_t bpa;

	va = trunc_page(bsh.base);
	endva = round_page((bsh.base + size) - 1);

#ifdef DIAGNOSTIC
	if (endva <= va)
		panic("bus_space_unmap: overflow");
#endif

	pmap_extract(pmap_kernel(), va, &bpa);
	bpa += m68k_page_offset(bsh.base);

	/*
	 * Free the kernel virtual mapping.
	 */
	pmap_remove(pmap_kernel(), va, endva);
	pmap_update(pmap_kernel());
	uvm_km_free(kernel_map, va, endva - va);

	if (extent_free(iomem_ex, bpa, size,
	    EX_NOWAIT | (iomem_malloc_safe ? EX_MALLOCOK : 0))) {
		printf("bus_space_unmap: pa 0x%lx, size 0x%lx\n",
		    bpa, size);
		printf("bus_space_unmap: can't free region\n");
	}
}

void    
bus_space_free(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	/* bus_space_unmap() does all that we need to do. */
	bus_space_unmap(t, bsh, size);
}

int
bus_space_subregion(t, bsh, offset, size, nbshp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset, size;
	bus_space_handle_t *nbshp;
{
	*nbshp = bsh;
	nbshp->base += offset;
	return (0);
}

int
mac68k_bus_space_probe(t, bsh, offset, sz)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset;
	int sz;
{
	int i;
	label_t faultbuf;

	nofault = &faultbuf;
	if (setjmp(nofault)) {
		nofault = (label_t *)0;
		return (0);
	}

	switch (sz) {
	case 1:
		i = bus_space_read_1(t, bsh, offset);
		break;
	case 2:
		i = bus_space_read_2(t, bsh, offset);
		break;
	case 4:
		i = bus_space_read_4(t, bsh, offset);
		break;
	case 8:
	default:
		panic("bus_space_probe: unsupported data size %d", sz);
		/* NOTREACHED */
	}

	nofault = (label_t *)0;
	return (1);
}

void
mac68k_bus_space_handle_swapped(t, h)
	bus_space_tag_t t;
	bus_space_handle_t *h;
{
	h->swapped = 1;
	h->bsr2 = mac68k_bsr2_swap;
	h->bsr4 = mac68k_bsr4_swap;
	h->bsrm2 = mac68k_bsrm2_swap;
	h->bsrm4 = mac68k_bsrm4_swap;
	h->bsrr2 = mac68k_bsrr2_swap;
	h->bsrr4 = mac68k_bsrr4_swap;
	h->bsw2 = mac68k_bsw2_swap;
	h->bsw4 = mac68k_bsw4_swap;
	h->bswm2 = mac68k_bswm2_swap;
	h->bswm4 = mac68k_bswm4_swap;
	h->bswr2 = mac68k_bswr2_swap;
	h->bswr4 = mac68k_bswr4_swap;
	h->bssm2 = mac68k_bssm2_swap;
	h->bssm4 = mac68k_bssm4_swap;
	h->bssr2 = mac68k_bssr2_swap;
	h->bssr4 = mac68k_bssr4_swap;
}

u_int8_t
mac68k_bsr1(bus_space_tag_t t, bus_space_handle_t *bsh, bus_size_t offset)
{
	return (*(volatile u_int8_t *) (bsh->base + offset));
}

u_int16_t
mac68k_bsr2(bus_space_tag_t t, bus_space_handle_t *bsh, bus_size_t offset)
{
	return (*(volatile u_int16_t *) (bsh->base + offset));
}

u_int16_t
mac68k_bsr2_swap(bus_space_tag_t t, bus_space_handle_t *bsh, bus_size_t offset)
{
	u_int16_t	v;

	v = (*(volatile u_int16_t *) (bsh->base + offset));
	return swap16(v);
}

u_int32_t
mac68k_bsr4(bus_space_tag_t tag, bus_space_handle_t *bsh, bus_size_t offset)
{
	return (*(volatile u_int32_t *) (bsh->base + offset));
}

u_int32_t
mac68k_bsr4_swap(bus_space_tag_t t, bus_space_handle_t *bsh, bus_size_t offset)
{
	u_int32_t	v;

	v = (*(volatile u_int32_t *) (bsh->base + offset));
	return swap32(v);
}

void
mac68k_bsrm1(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movb	a0@@,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bsrm2(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a0@@,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bsrm2_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a0@@,d1	;"
	"	rolw	#8,d1		;"
	"	movw	d1,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0","d1");
}

void
mac68k_bsrm4(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,%d0		;"
	"1:	movl	a0@@,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bsrm4_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a0@@,d1	;"
	"	rolw	#8,d1		;"
	"	swap	d1		;"
	"	rolw	#8,d1		;"
	"	movl	d1,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0","d1");
}

void
mac68k_bsrr1(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movb	a0@@+,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bsrr2(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a0@@+,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bsrr2_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a0@@+,d1	;"
	"	rolw	#8,d1		;"
	"	movw	d1,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0","d1");
}

void
mac68k_bsrr4(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a0@@+,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bsrr4_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a0@@+,d1	;"
	"	rolw	#8,d1		;"
	"	swap	d1		;"
	"	rolw	#8,d1		;"
	"	movl	d1,a1@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bsw1(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	    u_int8_t v)
{
	(*(volatile u_int8_t *)(h->base + offset)) = v;
}

void
mac68k_bsw2(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	    u_int16_t v)
{
	(*(volatile u_int16_t *)(h->base + offset)) = v;
}

void
mac68k_bsw2_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int16_t v)
{
	v = swap16(v);
	(*(volatile u_int16_t *)(h->base + offset)) = v;
}

void
mac68k_bsw4(bus_space_tag_t tag, bus_space_handle_t *h, bus_size_t offset,
	    u_int32_t v)
{
	(*(volatile u_int32_t *)(h->base + offset)) = v;
}

void
mac68k_bsw4_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int32_t v)
{
	v = swap32(v);
	(*(volatile u_int32_t *)(h->base + offset)) = v;
}

void
mac68k_bswm1(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     const u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movb	a1@@+,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bswm2(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     const u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a1@@+,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bswm2_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  const u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a1@@+,d1	;"
	"	rolw	#8,d1		;"
	"	movw	d1,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0","d1");
}

void
mac68k_bswm4(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     const u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a1@@+,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bswm4_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  const u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a1@@+,d1	;"
	"	rolw	#8,d1		;"
	"	swap	d1		;"
	"	rolw	#8,d1		;"
	"	movl	d1,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0","d1");
}

void
mac68k_bswr1(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     const u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movb	a1@@+,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bswr2(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     const u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a1@@+,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bswr2_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  const u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a1@@+,d1	;"
	"	rolw	#8,d1		;"
	"	movw	d1,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0","d1");
}

void
mac68k_bswr4(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     const u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a1@@+,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
mac68k_bswr4_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  const u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a1@@+,d1	;"
	"	rolw	#8,d1		;"
	"	swap	d1		;"
	"	rolw	#8,d1		;"
	"	movl	d1,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"					:
								:
		    "r" (h->base + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0","d1");
}

void
mac68k_bssm1(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int8_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movb	d1,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssm2(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int16_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movw	d1,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssm2_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int16_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	rolw	#8,d1		;"
	"	movl	%2,d0		;"
	"1:	movw	d1,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssm4(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int32_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movl	d1,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssm4_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int32_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	rolw	#8,d1		;"
	"	swap	d1		;"
	"	rolw	#8,d1		;"
	"	movl	%2,d0		;"
	"1:	movl	d1,a0@@	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssr1(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int8_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movb	d1,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssr2(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int16_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movw	d1,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssr2_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int16_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	rolw	#8,d1		;"
	"	movl	%2,d0		;"
	"1:	movw	d1,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssr4(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
	     u_int32_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movl	d1,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
mac68k_bssr4_swap(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int32_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	rolw	#8,d1		;"
	"	swap	d1		;"
	"	rolw	#8,d1		;"
	"	movl	%2,d0		;"
	"1:	movl	d1,a0@@+	;"
	"	subql	#1,d0		;"
	"	jne	1b"						:
									:
		    "r" (h->base + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.22 2006/06/24 13:24:21 miod Exp $	*/
@


1.22
log
@Use pmap_enter_cache() instead of physacc() in bus_mem_add_mapping(), and let
physacc() die. As a bonus, kvtop() dies too.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.21 2006/06/11 20:57:44 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@Clean the various cache and TLB invalidation function, arch by arch:
- [DI]C{FL,PL,PP} and DCFA are only called on 680[46]0 systems and are
  identical on these platforms, so don't bother checking for the MMU type.
- TBIAS is on 68060 codepath only.
- DCIAS, PCIA and TBIA are specific to some platforms and do not need to be
  implemented everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.20 2006/01/17 00:08:36 miod Exp $	*/
d158 1
a158 2
	pt_entry_t *pte;
	extern void TBIA(void);
d199 8
a206 11
	for (; pa < endpa; pa += PAGE_SIZE, va += PAGE_SIZE) {
		pmap_enter(pmap_kernel(), va, pa,
		    VM_PROT_READ | VM_PROT_WRITE,
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
		pte = kvtopte(va);
		if ((flags & BUS_SPACE_MAP_CACHEABLE))
			*pte &= ~PG_CI;
		else
			*pte |= PG_CI;
		TBIA();
	}
d235 2
@


1.20
log
@Remove unused ``stride'' bus_space internal functionality; nothing needs it.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.19 2005/09/15 18:52:44 martin Exp $	*/
d159 1
@


1.19
log
@get rid of MD m68k_trunc_page and m68k_round_page and replace by MI
trunc_page and round_page

go go go! miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.18 2005/09/12 10:07:29 martin Exp $	*/
a173 1
	bshp->stride = 1;
d312 16
a327 49
	if (h->stride == 1) {
		h->bsr2 = mac68k_bsr2_swap;
		h->bsr4 = mac68k_bsr4_swap;
		h->bsrm2 = mac68k_bsrm2_swap;
		h->bsrm4 = mac68k_bsrm4_swap;
		h->bsrr2 = mac68k_bsrr2_swap;
		h->bsrr4 = mac68k_bsrr4_swap;
		h->bsw2 = mac68k_bsw2_swap;
		h->bsw4 = mac68k_bsw4_swap;
		h->bswm2 = mac68k_bswm2_swap;
		h->bswm4 = mac68k_bswm4_swap;
		h->bswr2 = mac68k_bswr2_swap;
		h->bswr4 = mac68k_bswr4_swap;
		h->bssm2 = mac68k_bssm2_swap;
		h->bssm4 = mac68k_bssm4_swap;
		h->bssr2 = mac68k_bssr2_swap;
		h->bssr4 = mac68k_bssr4_swap;
	}
}

void
mac68k_bus_space_handle_set_stride(bus_space_tag_t t, bus_space_handle_t *h,
	int stride)
{
	h->stride = stride;
	h->bsr1 = mac68k_bsr1_gen;
	h->bsr2 = mac68k_bsr2_gen;
	h->bsr4 = mac68k_bsr4_gen;
	h->bsrm1 = mac68k_bsrm1_gen;
h->bsrm2 = mac68k_bsrm2_gen;
h->bsrm4 = mac68k_bsrm4_gen;
h->bsrr1 = mac68k_bsrr1_gen;
h->bsrr2 = mac68k_bsrr2_gen;
h->bsrr4 = mac68k_bsrr4_gen;
h->bsw1 = mac68k_bsw1_gen;
h->bsw2 = mac68k_bsw2_gen;
h->bsw4 = mac68k_bsw4_gen;
h->bswm1 = mac68k_bswm1_gen;
h->bswm2 = mac68k_bswm2_gen;
h->bswm4 = mac68k_bswm4_gen;
h->bswr1 = mac68k_bswr1_gen;
h->bswr2 = mac68k_bswr2_gen;
h->bswr4 = mac68k_bswr4_gen;
h->bssm1 = mac68k_bssm1_gen;
h->bssm2 = mac68k_bssm2_gen;
h->bssm4 = mac68k_bssm4_gen;
h->bssr1 = mac68k_bssr1_gen;
h->bssr2 = mac68k_bssr2_gen;
h->bssr4 = mac68k_bssr4_gen;
a335 6
u_int8_t
mac68k_bsr1_gen(bus_space_tag_t t, bus_space_handle_t *bsh, bus_size_t offset)
{
	return (*(volatile u_int8_t *) (bsh->base + offset * bsh->stride));
}

a350 13
u_int16_t
mac68k_bsr2_gen(bus_space_tag_t t, bus_space_handle_t *bsh, bus_size_t offset)
{
	u_int16_t	v;

	v = (*(volatile u_int8_t *) (bsh->base + offset++ * bsh->stride)) << 8;
	v |= (*(volatile u_int8_t *) (bsh->base + offset * bsh->stride));
	if (bsh->swapped) {
		swap16(v);
	}
	return v;
}

a365 18
u_int32_t
mac68k_bsr4_gen(bus_space_tag_t t, bus_space_handle_t *bsh, bus_size_t offset)
{
	u_int32_t	v;

	v = (*(volatile u_int8_t *) (bsh->base + offset++ * bsh->stride));
	v <<= 8;
	v |= (*(volatile u_int8_t *) (bsh->base + offset++ * bsh->stride));
	v <<= 8;
	v |= (*(volatile u_int8_t *) (bsh->base + offset++ * bsh->stride));
	v <<= 8;
	v |= (*(volatile u_int8_t *) (bsh->base + offset++ * bsh->stride));
	if (bsh->swapped) {
		v = swap32(v);
	}
	return v;
}

a382 9
mac68k_bsrm1_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int8_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_1(t, *h, offset);
	}
}

void
a416 18
mac68k_bsrm2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int16_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_2(t, *h, offset);
	}
}

void
mac68k_bsrms2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int16_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_stream_2(t, *h, offset);
	}
}

void
a452 18
mac68k_bsrm4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int32_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_4(t, *h, offset);
	}
}

void
mac68k_bsrms4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int32_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_stream_4(t, *h, offset);
	}
}

void
a468 10
mac68k_bsrr1_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int8_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_1(t, *h, offset);
		offset++;
	}
}

void
a502 20
mac68k_bsrr2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int16_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_2(t, *h, offset);
		offset += 2;
	}
}

void
mac68k_bsrrs2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int16_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_stream_2(t, *h, offset);
		offset += 2;
	}
}

void
a538 20
mac68k_bsrr4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int32_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_4(t, *h, offset);
		offset += 4;
	}
}

void
mac68k_bsrrs4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  u_int32_t *a, size_t c)
{
	while (c--) {
		*a++ = bus_space_read_stream_4(t, *h, offset);
		offset += 4;
	}
}

void
a545 7
mac68k_bsw1_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		u_int8_t v)
{
	(*(volatile u_int8_t *)(h->base + offset * h->stride)) = v;
}

void
a560 21
mac68k_bsws2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int16_t v)
{
	u_int8_t	v1;

	v1 = (v & 0xff00) >> 8;
	(*(volatile u_int8_t *)(h->base + offset++ * h->stride)) = v1;
	(*(volatile u_int8_t *)(h->base + offset * h->stride)) = v & 0xff;
}

void
mac68k_bsw2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		u_int16_t v)
{
	if (h->swapped) {
		v = swap16(v);
	}
	mac68k_bsws2_gen(t, h, offset, v);
}

void
a575 25
mac68k_bsws4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int32_t v)
{
	u_int8_t	v1,v2,v3;

	v1 = (v & 0xff000000) >> 24;
	v2 = (v & 0x00ff0000) >> 16;
	v3 = (v & 0x0000ff00) >> 8;
	(*(volatile u_int8_t *)(h->base + offset++ * h->stride)) = v1;
	(*(volatile u_int8_t *)(h->base + offset++ * h->stride)) = v2;
	(*(volatile u_int8_t *)(h->base + offset++ * h->stride)) = v3;
	(*(volatile u_int8_t *)(h->base + offset * h->stride)) = v & 0xff;
}

void
mac68k_bsw4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int32_t v)
{
	if (h->swapped) {
		v = swap32(v);
	}
	mac68k_bsws4_gen(t, h, offset, v);
}

void
a591 9
mac68k_bswm1_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 const u_int8_t *a, size_t c)
{
	while (c--) {
		bus_space_write_1(t, *h, offset, *a++);
	}
}

void
a625 18
mac68k_bswm2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 const u_int16_t *a, size_t c)
{
	while (c--) {
		bus_space_write_2(t, *h, offset, *a++);
	}
}

void
mac68k_bswms2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  const u_int16_t *a, size_t c)
{
	while (c--) {
		bus_space_write_stream_2(t, *h, offset, *a++);
	}
}

void
a661 18
mac68k_bswm4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 const u_int32_t *a, size_t c)
{
	while (c--) {
		bus_space_write_4(t, *h, offset, *a++);
	}
}

void
mac68k_bswms4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  const u_int32_t *a, size_t c)
{
	while (c--) {
		bus_space_write_stream_4(t, *h, offset, *a++);
	}
}

void
a677 10
mac68k_bswr1_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 const u_int8_t *a, size_t c)
{
	while (c--) {
		bus_space_write_1(t, *h, offset, *a++);
		offset++;
	}
}

void
a711 20
mac68k_bswr2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 const u_int16_t *a, size_t c)
{
	while (c--) {
		bus_space_write_2(t, *h, offset, *a++);
		offset += 2;
	}
}

void
mac68k_bswrs2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  const u_int16_t *a, size_t c)
{
	while (c--) {
		bus_space_write_stream_2(t, *h, offset, *a++);
		offset += 2;
	}
}

void
a747 20
mac68k_bswr4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 const u_int32_t *a, size_t c)
{
	while (c--) {
		bus_space_write_4(t, *h, offset, *a++);
		offset += 4;
	}
}

void
mac68k_bswrs4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		  const u_int32_t *a, size_t c)
{
	while (c--) {
		bus_space_write_4(t, *h, offset, *a++);
		offset += 4;
	}
}

void
a763 9
mac68k_bssm1_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int8_t v, size_t c)
{
	while (c--) {
		bus_space_write_1(t, *h, offset, v);
	}
}

void
a796 9
mac68k_bssm2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int16_t v, size_t c)
{
	while (c--) {
		bus_space_write_2(t, *h, offset, v);
	}
}

void
a831 9
mac68k_bssm4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int32_t v, size_t c)
{
	while (c--) {
		bus_space_write_4(t, *h, offset, v);
	}
}

void
a847 10
mac68k_bssr1_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int8_t v, size_t c)
{
	while (c--) {
		bus_space_write_1(t, *h, offset, v);
		offset++;
	}
}

void
a880 10
mac68k_bssr2_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int16_t v, size_t c)
{
	while (c--) {
		bus_space_write_2(t, *h, offset, v);
		offset += 2;
	}
}

void
a912 10
}

void
mac68k_bssr4_gen(bus_space_tag_t t, bus_space_handle_t *h, bus_size_t offset,
		 u_int32_t v, size_t c)
{
	while (c--) {
		bus_space_write_4(t, *h, offset, v);
		offset += 4;
	}
@


1.18
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.17 2004/11/28 14:04:24 miod Exp $	*/
d80 2
a81 2
	pa = m68k_trunc_page(bpa + t);
	endpa = m68k_round_page((bpa + t + size) - 1);
d160 2
a161 2
	pa = m68k_trunc_page(bpa);
	endpa = m68k_round_page((bpa + size) - 1);
d225 2
a226 2
	va = m68k_trunc_page(bsh.base);
	endva = m68k_round_page((bsh.base + size) - 1);
@


1.17
log
@Correct pmap_enter() flags usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.16 2002/03/14 01:26:35 millert Exp $	*/
d172 27
a198 1
	*bshp = (bus_space_handle_t)(va + (bpa & PGOFSET));
d225 2
a226 2
	va = m68k_trunc_page(bsh);
	endva = m68k_round_page((bsh + size) - 1);
d234 1
a234 1
	bpa += (bsh & PGOFSET);
d266 2
a267 2

	*nbshp = bsh + offset;
d305 979
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.15 2002/01/16 20:50:16 miod Exp $	*/
d174 1
a174 1
	for (; pa < endpa; pa += NBPG, va += NBPG) {
d176 2
a177 1
		    VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
@


1.15
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.14 2001/12/08 02:24:06 art Exp $	*/
d53 2
a54 2
int	bus_mem_add_mapping __P((bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *));
@


1.14
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.13 2001/11/28 15:34:16 art Exp $	*/
a47 1
#include <sys/map.h>
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.15 2002/01/16 20:50:16 miod Exp $	*/
d48 1
@


1.14.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.14.2.1 2002/01/31 22:55:13 niklas Exp $	*/
d53 2
a54 2
int	bus_mem_add_mapping(bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);
@


1.13
log
@Make pmap_update functions into nops so that we can have a consistent
pmap_update API (right now it's nop).
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.12 2001/11/06 19:53:15 miod Exp $	*/
d185 1
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.11 2001/09/19 20:50:56 mickey Exp $	*/
d183 1
a183 1
		pmap_update();
@


1.11
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.10 2001/07/25 13:25:32 art Exp $	*/
a51 1
#include <vm/vm.h>
@


1.10
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.9 2001/07/05 10:00:35 art Exp $	*/
a52 2
#include <vm/vm_kern.h>

@


1.9
log
@Get rid of the wrapper macros around extent_alloc*1
Pass the right amount of arguments and rename them back to their right names.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.8 2001/06/27 04:22:37 art Exp $	*/
d180 1
a180 1
		    VM_PROT_READ | VM_PROT_WRITE, TRUE, 0);
@


1.8
log
@old vm no more
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.7 2001/06/09 20:34:36 beck Exp $	*/
d127 1
a127 1
	    boundary,
@


1.7
log
@fix art oopsie so this compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.6 2001/06/08 08:09:01 art Exp $	*/
a54 1
#if defined(UVM)
a55 1
#endif
a171 1
#if defined(UVM)
a172 3
#else
	va = kmem_alloc_pageable(kernel_map, endpa - pa);
#endif
a214 1
#if defined(UVM)
a215 3
#else
	kmem_free(kernel_map, va, endva - va);
#endif
@


1.6
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.5 2001/05/08 17:30:40 aaron Exp $	*/
d215 2
a216 1
	pmap_extract(pmap_kernel(), va, &bpa) + (bsh & PGOFSET);
@


1.5
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.4 1999/09/03 18:01:11 art Exp $	*/
d215 1
a215 1
	bpa = pmap_extract(pmap_kernel(), va) + (bsh & PGOFSET);
@


1.4
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 2
a2 2
/*	$OpenBSD: bus_space.c,v 1.3 1999/04/24 06:39:41 downsj Exp $	*/
/*	$NetBSD: bus_space.c,v 1.2 1998/04/24 05:27:24 scottr Exp $	*/
a44 4
#if 0
#include "opt_uvm.h"
#endif

d74 1
a74 1
	u_long pa, endpa;
d163 2
a164 1
	vm_offset_t va;
d187 6
a192 2
		if (!(flags & BUS_SPACE_MAP_CACHEABLE))
			pmap_changebit(pa, PG_CI, TRUE);
d204 1
a204 1
	vm_offset_t	va, endva;
@


1.4.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: bus_space.c,v 1.5 1999/03/26 23:41:30 mycroft Exp $	*/
d45 4
d59 1
d61 1
d78 1
a78 1
	paddr_t pa, endpa;
d167 1
a167 2
	vaddr_t va;
	pt_entry_t *pte;
d177 1
d179 3
d190 2
a191 6
		pte = kvtopte(va);
		if ((flags & BUS_SPACE_MAP_CACHEABLE))
			*pte &= ~PG_CI;
		else
			*pte |= PG_CI;
		pmap_update();
d203 1
a203 1
	vaddr_t va, endva;
d214 1
a214 2
	pmap_extract(pmap_kernel(), va, &bpa);
	bpa += (bsh & PGOFSET);
d219 1
d221 3
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.4.4.1 2001/07/04 10:18:35 niklas Exp $	*/
d53 2
d127 1
a127 1
	    0, boundary,
d180 1
a180 1
		    VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
@


1.4.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
@


1.4.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.4.4.3 2001/11/13 21:00:53 niklas Exp $	*/
d183 1
a183 1
		TBIA();
@


1.4.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a184 1
	pmap_update(pmap_kernel());
@


1.4.4.6
log
@Merge in -current from about a week ago
@
text
@d53 2
a54 2
int	bus_mem_add_mapping(bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);
@


1.3
log
@Use the generic m68k param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.2 1999/01/11 05:11:36 millert Exp $	*/
d189 1
a189 1
		    VM_PROT_READ | VM_PROT_WRITE, TRUE);
@


1.2
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.1 1998/04/27 02:01:45 gene Exp $	*/
d90 2
a91 2
	pa = mac68k_trunc_page(bpa + t);
	endpa = mac68k_round_page((bpa + t + size) - 1);
d169 2
a170 2
	pa = mac68k_trunc_page(bpa);
	endpa = mac68k_round_page((bpa + size) - 1);
d206 2
a207 2
	va = mac68k_trunc_page(bsh);
	endva = mac68k_round_page((bsh + size) - 1);
@


1.1
log
@Correct namespace collisions for bus_space_probe and split out
bus_space functions into a separate source file ala NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d283 1
a283 1
		panic("bus_space_probe: unsupported data size %d\n", sz);
@

