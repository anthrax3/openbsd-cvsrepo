head	1.31;
access;
symbols
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.6
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.4
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.23
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9:1.20.0.14
	OPENBSD_2_9_BASE:1.20
	NIKLAS_UNDEAD:1.20.0.12
	OPENBSD_2_8:1.20.0.10
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.8
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.6
	SMP_BASE:1.20
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.4
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.16.0.4
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2006.01.13.19.36.46;	author miod;	state dead;
branches;
next	1.30;

1.30
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.22.19.40.51;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.27.00.12.43;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.20.18.08.08;	author martin;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.26.21.21.28;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.09.22.55.19;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.04.07.17.24;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.08.11.22.59.37;	author art;	state Exp;
branches;
next	1.20;

1.20
date	99.01.11.05.11.36;	author millert;	state Exp;
branches
	1.20.6.1;
next	1.19;

1.19
date	98.05.03.07.16.50;	author gene;	state Exp;
branches;
next	1.18;

1.18
date	97.11.30.18.25.38;	author gene;	state Exp;
branches;
next	1.17;

1.17
date	97.11.30.06.36.42;	author gene;	state Exp;
branches;
next	1.16;

1.16
date	97.04.23.00.29.15;	author gene;	state Exp;
branches;
next	1.15;

1.15
date	97.04.14.18.48.01;	author gene;	state Exp;
branches;
next	1.14;

1.14
date	97.04.14.02.10.21;	author briggs;	state Exp;
branches;
next	1.13;

1.13
date	97.04.05.16.19.29;	author briggs;	state Exp;
branches;
next	1.12;

1.12
date	97.04.05.15.29.12;	author briggs;	state Exp;
branches;
next	1.11;

1.11
date	97.03.30.21.53.25;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.03.08.16.17.05;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.02.23.06.05.00;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.01.24.01.35.49;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.01.19.03.58.08;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.10.30.05.26.29;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.10.28.14.55.32;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.08.10.21.37.47;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.36.24;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.18.14.29;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.08;	author deraadt;	state Exp;
branches;
next	;

1.20.6.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.20.6.2;

1.20.6.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.20.6.3;

1.20.6.3
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.20.6.4;

1.20.6.4
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.20.6.5;

1.20.6.5
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.06.11.03.36.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@/*	$OpenBSD: macrom.c,v 1.30 2006/01/04 20:39:05 miod Exp $	*/
/*	$NetBSD: macrom.c,v 1.47 2000/11/15 07:15:36 scottr Exp $	*/

/*-
 * Copyright (C) 1994	Bradley A. Grantham
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bradley A. Grantham.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Mac ROM Glue
 *
 * This allows MacBSD to access (in a limited fashion) routines included
 * in the Mac ROMs, like ADBReInit.
 *
 * As a (fascinating) side effect, this glue allows ROM code (or any other
 * MacOS code) to call MacBSD kernel routines, like NewPtr.
 *
 * Uncleaned-up weirdness,
 *	This doesn't work on a lot of machines.  Perhaps the IIsi stuff
 * can be generalized somewhat for others.  It looks like most machines
 * are similar to the IIsi ("Universal ROMs"?).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/queue.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/viareg.h>

#include <mac68k/dev/adbvar.h>

	/* trap modifiers (put it macrom.h) */
#define TRAP_TOOLBOX(a)	((a) & 0x800)
#define TRAP_PASSA0(a)	((a) & 0x100)
#define TRAP_NUM(a)	(TRAP_TOOLBOX(a) ? (a) & 0x3ff : (a) & 0xff)
#define TRAP_SYS(a)	((a) & 0x400)
#define TRAP_CLEAR(a)	((a) & 0x200)


	/* Mac Rom Glue global variables */
/*
 * ADB Storage.  Is 512 bytes enough?  Too much?
 */
u_char mrg_adbstore[512];
u_char mrg_adbstore2[512];
u_char mrg_adbstore3[512];
u_char mrg_ExpandMem[512];			/* 0x1ea Bytes minimum */
u_char mrg_adbstore4[32];			/* 0x16 bytes was the largest I found yet */
u_char mrg_adbstore5[80];			/* 0x46 bytes minimum */

/*
 * InitEgret in the AV ROMs requires a low memory global at 0x2010 to be
 * pointed at this jump table, which can be found at 0x40803280. It's
 * included here so we can do mrg_fixupROMBase on it.
 */

u_int32_t mrg_AVInitEgretJT[] = {
	0x408055D0, 0x4083985A, 0x40839AB6, 0x4080F180,
	0x4080C0B6, 0x4080C30A, 0x4080C380, 0x4080C482,
	0x4080C496, 0x4080C82E, 0x4080C9FE, 0x4080CA16,
	0x4081D1D6, 0x4085CDDE, 0x4080DF28, 0x4080DFC6,
	0x4080E292, 0x4080E2C0, 0x4080E348, 0x4080E600,
	0x4080E632, 0x4080E6B8, 0x4080E6E4, 0x4080E750,
	0x4080E776, 0x4080E7B4, 0x408B90E0, 0x40852490,
	0x40852280, 0x40852410, 0x4080E8F0, 0x4080E940,
	0x4080E960, 0x4080E9B0, 0x4080E9E0, 0x4080EA50,
	0x4080EA70, 0x4080EB14, 0x4080EBC0, 0x4081D1D6,
	0x40810AB0, 0x40810BDA, 0x40810CCA, 0x40810FF2,
	0x4080FF8C, 0x40810292, 0x40812CE2, 0x40813AAE,
	0x40813AE0, 0x408113DE, 0x40811EB0, 0x40811FA0,
	0x40811DD0, 0x4083B720, 0x408412E0, 0x40841300,
	0x40841380, 0x4083A390, 0x408411F0
};

caddr_t	mrg_romadbintr = (caddr_t)0;	/* ROM ADB interrupt */
caddr_t	mrg_rompmintr = 0;		/* ROM PM (?) interrupt */
const char *mrg_romident = NULL;	/* ident string for ROMs */
caddr_t	mrg_ADBAlternateInit = 0;
caddr_t	mrg_InitEgret = 0;
caddr_t	mrg_ADBIntrPtr = (caddr_t)0x0;	/* ADB interrupt taken from MacOS vector table*/
caddr_t	ROMResourceMap = 0;
extern romvec_t *mrg_MacOSROMVectors;
#if defined(MRG_TEST) || defined(MRG_DEBUG)
caddr_t	ResHndls[] = {
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0
};
#else
caddr_t	ResHndls[] = {
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0
};
#endif

/*
 * Last straw functions; we didn't set them up, so freak out!
 * When someone sees these called, we can finally go back and
 * bother to implement them.
 */

int
mrg_Delay()
{
#define TICK_DURATION 16625
	u_int32_t ticks;

	__asm __volatile ("movl	a0, %0"		/* get arguments */
		: "=g" (ticks)
		:
		: "a0");

#if defined(MRG_DEBUG)
	printf("mrg: mrg_Delay(%d) = %d ms\n", ticks, ticks * 60);
#endif
	delay(ticks * TICK_DURATION);

	/*
	 * The number of ticks since startup should be
	 * returned here. Until someone finds a need for
	 * this, we just return the requested number
	 * of ticks
	 */
	return (ticks);
}

/*
 * Handle the Deferred Task manager here
 *
 */
static caddr_t	mrg_DTList = NULL;

void
mrg_DTInstall()
{
	caddr_t	ptr, prev;

	__asm __volatile ("movl a0, %0" : "=g" (ptr));

	(caddr_t *)prev = &mrg_DTList;
	while (*prev != NULL) 
		prev = *(caddr_t *)prev;
	*(caddr_t *)ptr = NULL;
	*(caddr_t *)prev = ptr;
	setsoftdtmgr();

	__asm __volatile ("clrl d0" : : : "d0");
}

void
mrg_execute_deferred()
{
	caddr_t ptr;
	int s;

	while (mrg_DTList != NULL) {
		s = splhigh();
		ptr = *(caddr_t *)mrg_DTList;
		mrg_DTList = *(caddr_t *)ptr;
		splx(s);

		__asm __volatile ("
			moveml a0-a6/d1-d7,sp@@-
			movl %0, a0
			movl a0@@(8), a2
			movl a0@@(12), a1
			jsr a2@@
			moveml sp@@+,a0-a6/d1-d7" : : "g" (ptr));
	}
}

void
mrg_VBLQueue()
{
#define qLink 0
#define qType 4
#define vblAddr 6
#define vblCount 10
#define vblPhase 12
	caddr_t vbltask;
	caddr_t last_vbltask;
	
	last_vbltask = (caddr_t)&VBLQueue_head;
	vbltask = VBLQueue_head;
	while (0 != vbltask) {
		if (0 != *((u_int16_t *)(vbltask + vblPhase)))
			*((u_int16_t *)(vbltask + vblPhase)) -= 1;
		else if (0 != *((u_int16_t *)(vbltask + vblCount)))
			*((u_int16_t *)(vbltask + vblCount)) -= 1;
		else {
#if defined(MRG_DEBUG)
			printf("mrg: mrg_VBLQueue: calling VBL task at 0x%x with VBLTask block at %p\n",
			    *((u_int32_t *)(vbltask + vblAddr)), vbltask);
#endif
			__asm __volatile("
				movml	#0xfffe, sp@@-
				movl	%0, a0
				movl	%1, a1
				jbsr	a1@@
				movml	sp@@+, #0x7fff"
				: : "g" (vbltask),
				    "g" (*((caddr_t)(vbltask + vblAddr)))
				: "a0", "a1");
#if defined(MRG_DEBUG)
			printf("mrg: mrg_VBLQueue: back from VBL task\n");
#endif
			if (0 == *((u_int16_t *)(vbltask + vblCount))) {
#if defined(MRG_DEBUG)
				printf("mrg: mrg_VBLQueue: removing VBLTask block at %p\n",
				    vbltask);
#endif
				*((u_int32_t *)(last_vbltask + qLink)) =
				    *((u_int32_t *)(vbltask + qLink));
				/*
				 * can't free memory from VBLTask block as
				 * we don't know where it came from
				 */
				if (vbltask == VBLQueue_tail)
					VBLQueue_tail = last_vbltask;
			}
		}
		last_vbltask = vbltask;
		vbltask = (caddr_t) *((u_int32_t *)(vbltask + qLink));
	}
}

void
mrg_init_stub_1()
{
	__asm __volatile ("movml #0xffff, sp@@-");
	printf("mrg: hit mrg_init_stub_1\n");
  	__asm __volatile ("movml sp@@+, #0xffff");
}

void
mrg_init_stub_2()
{
	panic("mrg: hit mrg_init_stub_2");
}

short
Count_Resources(u_int32_t rsrc_type)
{
	rsrc_t *rsrc = (rsrc_t *)ROMResourceMap;
	short count = 0;

#if defined(MRG_DEBUG)
	printf("Count_Resources looking for 0x%08lx at 0x%08lx\n",
	    (long)rsrc_type, (long)rsrc);
#endif
	/*
	 * Return a Count of all the ROM Resouces of the requested type.
	 */
	if (ROMResourceMap == 0)
		panic("Oops! Need ROM Resource Map ListHead address!");

	while (rsrc != 0) {
#if defined(MRG_DEBUG)
		if (rsrc_type == 0)
			printf("0x%08lx: %04x %04x %04x %04x %08x %08x %08x %04x\n",
			    (long)rsrc, rsrc->unknown[0], rsrc->unknown[1],
			    rsrc->unknown[2], rsrc->unknown[3], rsrc->next,
			    rsrc->body, rsrc->name, rsrc->index);
#endif
		if (rsrc_type == 0 || (rsrc_type == rsrc->name))
			count++;
		rsrc = rsrc->next == 0 ? 0 : (rsrc_t *)(rsrc->next + ROMBase);
	}

#if defined(MRG_DEBUG)
	printf("Count_Resources found %d\n", count);
#endif
	return count;
}

caddr_t *
Get_Ind_Resource(u_int32_t rsrc_type, u_int16_t rsrc_ind)
{
	rsrc_t *rsrc = (rsrc_t *)ROMResourceMap;
	short i = 0;

	/*
	 * This routine return the "Handle" to a ROM Resource.  Since few
	 * ROM Resources are called for in OpenBSD we keep a small table
	 * for the Handles we return. (Can't reuse the Handle without
	 * defeating the purpose for a Handle in the first place!)  If
	 * we get more requests than we have space for, we panic.
	 */
	if (ROMResourceMap == 0)
		panic("Oops! Need ROM Resource Map ListHead address!");

	while (rsrc != 0) {
		if (rsrc_type == rsrc->name) {
			rsrc_ind--;
			if (rsrc_ind == 0) {
				for (i = 0;
				    i < sizeof(ResHndls) / sizeof(caddr_t); i++)
					if ((ResHndls[i] == 0) ||
					    (ResHndls[i] == (caddr_t)(rsrc->next + ROMBase))) {
						ResHndls[i] = (caddr_t)(rsrc->body + ROMBase);
						return (caddr_t *)&ResHndls[i];
					}
				panic("ResHndls table too small!");
			}
		}
		rsrc = rsrc->next == 0 ? 0 : (rsrc_t *)(rsrc->next + ROMBase);
	}
	return (caddr_t *)0;
}

void
mrg_FixDiv()
{
	panic("Oops! Need ROM address of _FixDiv for this system!");
}

void
mrg_FixMul()
{
	panic("Oops! Need ROM address of _FixMul for this system!");
}

void
mrg_1sec_timer_tick()
{	
	/* The timer tick from the Egret chip triggers this routine via
	 * Lvl1DT[0] (addr 0x192) once every second.
	 */
}
  
void
mrg_lvl1dtpanic()		/* Lvl1DT stopper */
{
	printf("Agh!  I was called from Lvl1DT!!!\n");
#ifdef DDB
	Debugger();
#endif
}

void
mrg_lvl2dtpanic()		/* Lvl2DT stopper */
{
	panic("Agh!  I was called from Lvl2DT!!!");
}

void
mrg_jadbprocpanic()	/* JADBProc stopper */
{
	panic("Agh!  Called JADBProc!");
}

void
mrg_jswapmmupanic()	/* jSwapMMU stopper */
{
	panic("Agh!  Called jSwapMMU!");
}

void
mrg_jkybdtaskpanic()	/* JKybdTask stopper */
{
	panic("Agh!  Called JKybdTask!");
}

#ifdef MRG_ADB
/*
 * mrg_adbintr() and mrg_pmintr() are defined in adb_direct.c if we
 * not using the MRG method of accessing the ADB/PRAM/RTC.
 */

int
mrg_adbintr()	/* Call ROM ADB Interrupt */
{
	if (mrg_romadbintr != NULL) {
#if defined(MRG_TRACE)
		tron();
#endif

		/* Gotta load a1 with VIA address. */
		/* ADB int expects it from Mac intr routine. */
		__asm __volatile ("
			movml	#0xffff, sp@@-
			movl	%0, a0
			movl	_VIA, a1
			jbsr	a0@@
			movml	sp@@+, #0xffff"
			:
			: "g" (mrg_romadbintr)
			: "a0", "a1");

#if defined(MRG_TRACE)
		troff();
#endif

	}
	return (1);
}

int
mrg_pmintr()	/* Call ROM PM Interrupt */
{
	if (mrg_rompmintr != NULL) {
#if defined(MRG_TRACE)
		tron();
#endif

		/* Gotta load a1 with VIA address. */
		/* ADB int expects it from Mac intr routine. */
		__asm __volatile ("
			movml	#0xffff, sp@@-
			movl	%0, a0
			movl	_VIA, a1
			jbsr	a0@@
			movml	sp@@+, #0xffff"
			:
			: "g" (mrg_rompmintr)
			: "a0", "a1");

#if defined(MRG_TRACE)
		troff();
#endif
	}
	return (1);
}
#endif	/* MRG_ADB */


void
mrg_notrap()
{
	printf("Aigh!\n");
	panic("mrg_notrap: We're doomed!");
}

int
myowntrap()
{
	printf("Oooo!  My Own Trap Routine!\n");
	return (50);
}

int
mrg_NewPtr()
{
	int result = noErr;
	u_int numbytes;
/*	u_int32_t trapword; */
	caddr_t ptr;

	__asm __volatile ("movl	d0, %0" : "=g" (numbytes) : : "d0");

#if defined(MRG_SHOWTRAPS)
	printf("mrg: NewPtr(%d bytes, ? clear, ? sys)", numbytes);
#endif

		/* plus 4 for size */
	ptr = malloc(numbytes + 4 , M_DEVBUF, M_NOWAIT); /* ?? */
		/* We ignore "Sys;" where else would it come from? */
		/* plus, (I think), malloc clears block for us */

	if (ptr == NULL) {
		result = memFullErr;
#if defined(MRG_SHOWTRAPS)
		printf(" failed.\n");
#endif
	}else{
#if defined(MRG_SHOWTRAPS)
		printf(" succeded = %p.\n", ptr);
#endif
		*(u_int32_t *)ptr = numbytes;
		ptr += 4;
		bzero(ptr, numbytes); /* NewPtr, Clear ! */
	}

	__asm __volatile("movl	%0, a0" :  : "g" (ptr) : "a0");
	return (result);
}

int
mrg_DisposPtr()
{
	int result = noErr;
	caddr_t ptr;

	__asm __volatile("movl	a0, %0" : "=g" (ptr) : : "a0");

#if defined(MRG_SHOWTRAPS)
	printf("mrg: DisposPtr(%p)\n", ptr);
#endif

	if (ptr == 0)
		result = memWZErr;
	else
		free(ptr - 4, M_DEVBUF);

	return (result);
}

int
mrg_GetPtrSize()
{
	caddr_t ptr;

	__asm __volatile("movl	a0, %0" : "=g" (ptr) : : "a0");

#if defined(MRG_SHOWTRAPS)
	printf("mrg: GetPtrSize(%p)\n", ptr);
#endif

	if (ptr == 0)
		return (memWZErr);
	else
		return (*(int *)(ptr - 4));
}

int
mrg_SetPtrSize()
{
	caddr_t ptr;
	int newbytes;

	__asm __volatile("
		movl	a0, %0
		movl	d0, %1"
		: "=g" (ptr), "=g" (newbytes) : : "d0", "a0");

#if defined(MRG_SHOWTRAPS)
	printf("mrg: SetPtrSize(%p, %d) failed\n", ptr, newbytes);
#endif

	return (memFullErr);	/* How would I handle this, anyway? */
}

int
mrg_PostEvent()
{
	return 0;
}

void
mrg_StripAddress()
{
}

int
mrg_SetTrapAddress()
{
	extern caddr_t mrg_OStraps[];
	caddr_t ptr;
	int trap_num;

	__asm __volatile("
		movl a0, %0
		movl d0, %1"
		: "=g" (ptr), "=g" (trap_num) : : "d0", "a0");

#if defined(MRG_DEBUG)
	printf("mrg: trap 0x%x set to 0x%lx\n", trap_num, (long)ptr);
#endif
	mrg_OStraps[trap_num] = ptr;
/*
 * If the Trap for Egret was changed, we'd better remember it!
 */
	if (trap_num == 0x92) {
#if defined(MRG_DEBUG)
		printf("mrg: reconfigured Egret address from 0x%lx to 0x%lx\n",
		    (long)jEgret, (long)ptr);
#endif
		jEgret = (void (*))ptr;
	}
	return 0;
}

/*
 * trap jump address tables (different per machine?)
 * Can I just use the tables stored in the ROMs?
 * *Is* there a table stored in the ROMs?
 * We only initialize the A-Traps for the routines we have
 *  provided ourselves.  The routines we will be trying to
 *  use out of the MacROMs will be initialized at run-time.
 * I did this to make the code easier to follow and to keep
 *  from taking an unexpected side trip into the MacROMs on
 *  those systems we don't have fully decoded.
 */
caddr_t mrg_OStraps[256] = {
#ifdef __GNUC__
		/* God, I love gcc.  see GCC2 manual, section 2.17, */
		/* "labeled elements in initializers." */
	[0x1e]	(caddr_t)mrg_NewPtr,
		(caddr_t)mrg_DisposPtr,
		(caddr_t)mrg_SetPtrSize,
		(caddr_t)mrg_GetPtrSize,
	[0x2f]	(caddr_t)mrg_PostEvent,
	[0x3b]	(caddr_t)mrg_Delay,	
	[0x47]	(caddr_t)mrg_SetTrapAddress,
	[0x55]	(caddr_t)mrg_StripAddress,
	[0x82]	(caddr_t)mrg_DTInstall,
#else
#error "Using a GNU C extension."
#endif
};

caddr_t mrg_ToolBoxtraps[1024] = {
	[0x19c] (caddr_t)mrg_CountResources,
	[0x19d] (caddr_t)mrg_GetIndResource,
	[0x1a0] (caddr_t)mrg_GetResource,
	[0x1af] (caddr_t)mrg_ResError,
};

/*
 * Handle a supervisor mode A-line trap.
 */
void
mrg_aline_super(struct frame *frame)
{
	caddr_t trapaddr;
	u_short trapword;
	int isOStrap;
	int trapnum;
	int a0passback;
	u_int32_t a0bucket, d0bucket;
	int danprint=0; /* This shouldn't be necessary, but seems to be.  */

#if defined(MRG_DEBUG)
	printf("mrg: a super");
#endif

	trapword = *(u_short *)frame->f_pc;

	if (trapword == 0xa71e)
		danprint = 1;

#if defined(MRG_DEBUG)
	printf(" wd 0x%lx", (long)trapword);
#endif
	isOStrap = ! TRAP_TOOLBOX(trapword);
	trapnum = TRAP_NUM(trapword);

	if (danprint) {
		/*
		 * Without these print statements, ADBReInit fails on IIsi
		 * It is unclear why--perhaps a compiler bug?  delay()s do not
		 * work, nor does some assembly similar to the  printf calls.
		 * A printf(""); is sufficient, but gcc -Wall is noisy about
		 * it, so I figured backspace is harmless enough...
		 */
		printf(" "); printf("\010");
	}

#if defined(MRG_DEBUG)
	printf(" %s # 0x%x", isOStrap? "OS" :
		"ToolBox", trapnum);
#endif

	/*
	 * Only OS Traps come to us; _alinetrap takes care of ToolBox
	 * traps, which are a horrible Frankenstein-esque abomination.
	 */

	trapaddr = mrg_OStraps[trapnum];
#if defined(MRG_DEBUG)
	printf(" addr 0x%lx\n", (long)trapaddr);
 	printf("    got:    d0 = 0x%8x,  a0 = 0x%8x, called from: 0x%8x\n",
		frame->f_regs[0], frame->f_regs[8], frame->f_pc	);
#endif
	if (trapaddr == NULL) {
		printf("unknown %s trap 0x%x, no trap address available\n",
			isOStrap ? "OS" : "ToolBox", trapword);
		panic("mrg_aline_super()");
	}
	a0passback = TRAP_PASSA0(trapword);

#if defined(MRG_TRACE)
	tron();
#endif

/* 	put a0 in a0 */
/* 	put a1 in a1 */
/* 	put d0 in d0 */
/* 	put d1 in d1 */
/*	put trapaddr in a2 */
/* save a6 */
/* 	call the damn routine */
/* restore a6 */
/* 	store d0 in d0bucket */
/* 	store a0 in d0bucket */
/* This will change a2,a1,d1,d0,a0 and possibly a6 */

	__asm __volatile ("
		movl	%2@@, d0
		movl	%2@@(4), d1
		movl	%2@@(32), a0
		movl	%2@@(36), a1
		movl	%3, a2
		jbsr	a2@@
		movl	a0, %0
		movl	d0, %1"

		: "=g" (a0bucket), "=g" (d0bucket)

		: "a" (&frame->f_regs), "g" (trapaddr)

		: "d0", "d1", "a0", "a1", "a2", "a6");

#if defined(MRG_TRACE)
	troff();
#endif
#if defined(MRG_DEBUG)
	printf("    result: d0 = 0x%8x,  a0 = 0x%8x\n",
		d0bucket, a0bucket );
 	printf(" bk");
#endif

	frame->f_regs[0] = d0bucket;
	if (a0passback)
		frame->f_regs[8] = a0bucket;

	frame->f_pc += 2;	/* skip offending instruction */

#if defined(MRG_DEBUG)
	printf(" exit\n");
#endif
}

extern u_int32_t traceloopstart[];
extern u_int32_t traceloopend;
extern u_int32_t *traceloopptr;

void
dumptrace()
{
#if defined(MRG_TRACE)
	u_int32_t *traceindex;

	printf("instruction trace:\n");
	traceindex = traceloopptr + 1;
	while (traceindex != traceloopptr) {
		printf("    %08x\n", *traceindex++);
		if (traceindex == &traceloopend)
			traceindex = &traceloopstart[0];
	}
#else
	printf("mrg: no trace functionality enabled\n");
#endif
}

	/* To find out if we're okay calling ROM vectors */
int
mrg_romready()
{
	return (mrg_romident != NULL);
}

extern unsigned long	IOBase;
extern volatile u_char	*sccA;

	/* initialize Mac ROM Glue */
void
mrg_init()
{
	char *findername = "MacBSD FakeFinder";
	vaddr_t va;
	int i;
#if defined(MRG_TEST)
	caddr_t ptr;
	short rcnt;
	int sizeptr;
	extern short mrg_ResErr;
	caddr_t *handle;
#endif
	
	/*
	 * Clear the VBLQueue.
	 */
	VBLQueue = (u_int16_t) 0;
	VBLQueue_head = (caddr_t) 0;
	VBLQueue_tail = (caddr_t) 0;
					 
#if defined(MRG_TEST)
	if (ROMResourceMap) {
		printf("mrg: testing CountResources\n");
		__asm __volatile ("
			clrl    sp@@-
			clrl    sp@@-
			.word   0xa99c
			movw    sp@@+, %0"
			: "=g" (rcnt));
		printf("mrg: found %d resources in ROM\n", rcnt);
		__asm __volatile ("
			clrl    sp@@-
			movl    #0x44525652, sp@@-
			.word   0xa99c
			movw    sp@@+, %0"
			: "=g" (rcnt));
		printf("mrg: %d are DRVR resources\n", rcnt);
		if (rcnt == 0)
			panic("Oops! No DRVR Resources found in ROM");
	}
#endif
#if defined(MRG_TEST)
	if (ROMResourceMap) {
		printf("mrg: testing GetIndResource\n");
		__asm __volatile ("
			clrl    sp@@-
			movl    #0x44525652, sp@@-
			movw    #0x01, sp@@-
			.word   0xa99d
			movl    sp@@+, %0"
			: "=g" (handle));
		printf("Handle to first DRVR resource is %p\n", handle);
		printf("DRVR: 0x%08lx -> 0x%08lx -> 0x%08lx\n",
		    (long)Get_Ind_Resource(0x44525652, 1),
		    (long)*Get_Ind_Resource(0x44525652, 1),
		    (long)*((u_int32_t *)*Get_Ind_Resource(0x44525652, 1)));
		__asm __volatile ("
			clrl    sp@@-
			movl    #0x44525652, sp@@-
			movw    #0x02, sp@@-
			.word   0xa99d
			movl    sp@@+, %0"
			: "=g" (handle));
		printf("Handle to second DRVR resource is %p\n", handle);
		printf("DRVR: 0x%08lx -> 0x%08lx -> 0x%08lx\n",
		    (long)Get_Ind_Resource(0x44525652, 2),
		    (long)*Get_Ind_Resource(0x44525652, 2),
		    (long)*((u_int32_t *)*Get_Ind_Resource(0x44525652, 2)));
	}
#endif
	if (mrg_romready()) {
		printf("mrg: '%s' ROM glue", mrg_romident);

#if defined(MRG_TRACE)
#if defined(MRG_FOLLOW)
		printf(", tracing on (verbose)");
#else /* ! defined (MRG_FOLLOW) */
		printf(", tracing on (silent)");
#endif /* defined(MRG_FOLLOW) */
#else /* !defined(MRG_TRACE) */
		printf(", tracing off");
#endif	/* defined(MRG_TRACE) */

#if defined(MRG_DEBUG)
		printf(", debug on");
#else /* !defined(MRG_DEBUG) */
		printf(", debug off");
#endif /* defined(MRG_DEBUG) */

#if defined(MRG_SHOWTRAPS)
		printf(", verbose traps");
#else /* !defined(MRG_SHOWTRAPS) */
		printf(", silent traps");
#endif /* defined(MRG_SHOWTRAPS) */
	}else{
		printf("mrg: kernel has no ROM vectors for this machine!\n");
		return;
	}

	printf("\n");

#if defined(MRG_DEBUG)
	printf("mrg: start init\n");
#endif
		/* expected globals */
	ExpandMem = &mrg_ExpandMem[0];
	*((u_int16_t *)(mrg_ExpandMem + 0x00) ) = 0x0123;	/* magic (word) */
	*((u_int32_t *)(mrg_ExpandMem + 0x02) ) = 0x000001ea;	/* Length of table (long) */
	*((u_int32_t *)(mrg_ExpandMem + 0x1e0)) = (u_int32_t) &mrg_adbstore4[0];

	*((u_int32_t *)(mrg_adbstore4 + 0x8)) = (u_int32_t) mrg_init_stub_1;
	*((u_int32_t *)(mrg_adbstore4 + 0xc)) = (u_int32_t) mrg_init_stub_2;
	*((u_int32_t *)(mrg_adbstore4 + 0x4)) = (u_int32_t) &mrg_adbstore5[0];

	*((u_int32_t *)(mrg_adbstore5 + 0x08)) = (u_int32_t) 0x00100000;
	*((u_int32_t *)(mrg_adbstore5 + 0x0c)) = (u_int32_t) 0x00100000;
	*((u_int32_t *)(mrg_adbstore5 + 0x16)) = (u_int32_t) 0x00480000;

	ADBBase = &mrg_adbstore[0];
	ADBState = &mrg_adbstore2[0];
	ADBYMM = &mrg_adbstore3[0];
	MinusOne = 0xffffffff;
	Lo3Bytes = 0x00ffffff;
	VIA = (caddr_t)Via1Base;
	MMU32Bit = 1; /* ?means MMU is in 32 bit mode? */
  	if (TimeDBRA == 0)
		TimeDBRA = 0xa3b;		/* BARF default is Mac II */
  	if (ROMBase == 0)
		panic("ROMBase not set in mrg_init()!");

	strlcpy(FinderName + 1, findername, sizeof FinderName - 1);
	FinderName[0] = (u_char) strlen(findername);
#if defined(MRG_DEBUG)
	printf("After setting globals\n");
#endif

		/* Fake jump points */
	for (i = 0; i < 8; i++) /* Set up fake Lvl1DT */
		Lvl1DT[i] = mrg_lvl1dtpanic;
	for (i = 0; i < 8; i++) /* Set up fake Lvl2DT */
		Lvl2DT[i] = mrg_lvl2dtpanic;
	Lvl1DT[0] = (void (*)(void))mrg_1sec_timer_tick;
	Lvl1DT[2] = (void (*)(void))mrg_romadbintr;
	Lvl1DT[4] = (void (*)(void))mrg_rompmintr;
	JADBProc = mrg_jadbprocpanic;	/* Fake JADBProc for the time being */
	jSwapMMU = mrg_jswapmmupanic;	/* Fake jSwapMMU for the time being */
	JKybdTask = mrg_jkybdtaskpanic;	/* Fake JKybdTask for the time being */

	/* probably very dangerous */
	jADBOp = (void (*)(void))mrg_OStraps[0x7c];

	mrg_VIA2 = (caddr_t)(Via1Base + VIA2 * 0x2000);	/* see via.h */
	SCCRd = (caddr_t)sccA;		/* ser.c ; we run before serinit */

	jDTInstall = (caddr_t)mrg_DTInstall;

	/* AV ROMs want this low memory vector to point to a jump table */
	InitEgretJTVec = (u_int32_t **)&mrg_AVInitEgretJT;

	switch (mach_cputype()) {
		case MACH_68020:	CPUFlag = 2;	break;
		case MACH_68030:	CPUFlag = 3;	break;
		case MACH_68040:	CPUFlag = 4;	break;
		default:
			printf("mrg: unknown CPU type; cannot set CPUFlag\n");
			break;
	}

#if defined(MRG_TEST)
	printf("Allocating a pointer...\n");
	ptr = (caddr_t)NewPtr(1024);
	printf("Result is 0x%lx.\n", (long)ptr);
	sizeptr = GetPtrSize((Ptr)ptr);
	printf("Pointer size is %d\n", sizeptr);
	printf("Freeing the pointer...\n");
	DisposPtr((Ptr)ptr);
	printf("Free'd.\n");

	for (i = 0; i < 500000; i++)
		if ((i % 100000) == 0)printf(".");
	printf("\n");

	mrg_ResErr = 0xdead;	/* set an error we know */
	printf("Getting error code...\n");
	i = ResError();
	printf("Result code (0xdeadbaaf): %x\n", i);
	printf("Getting an ADBS Resource...\n");
	handle = GetResource(0x41244253, 2);
	printf("Handle result from GetResource: 0x%lx\n", (long)handle);
	printf("Getting error code...\n");
	i = ResError();
	printf("Result code (-192?) : %d\n", i);

	for (i = 0; i < 500000; i++)
		if ((i % 100000) == 0)printf(".");
	printf("\n");

#if defined(MRG_TRACE)
	printf("Turning on a trace\n");
	tron();
	printf("We are now tracing\n");
	troff();
	printf("Turning off trace\n");
	dumptrace();
#endif /* MRG_TRACE */

	for (i = 0; i < 500000; i++)
		if ((i % 100000) == 0)
			printf(".");
	printf("\n");
#endif /* MRG_TEST */

#if defined(MRG_DEBUG)
	printf("after setting jump points\n");
	printf("mrg: end init\n");
#endif

	if (1) {
		/*
		 * For the bloody Mac II ROMs, we have to map this space
		 * so that the PRam functions will work.
		 * Gee, Apple, is that a hard-coded hardware address in
		 * your code?  I think so! (_ReadXPRam + 0x0062 on the
		 * II)  We map the VIAs in here.  The C610 apparently
		 * needs it, too, which means that a bunch of 040s do, too.
		 * Once again, I regret the mapping changes I made...  -akb
		 */
#ifdef DIAGNOSTIC
		printf("mrg: I/O map kludge for ROMs that use hardware %s",
			"addresses directly.\n");
#endif
		for (va = 0x50f00000; va < 0x50f04000; va += PAGE_SIZE)
			pmap_kenter_pa(va, (paddr_t)va, UVM_PROT_RW);
		pmap_update(pmap_kernel());
	}
}

#ifdef MRG_ADB
static void	setup_egret(void);

static void
setup_egret(void)
{
	if (0 != mrg_InitEgret) {

	/* This initializes ADBState (mrg_ADBStore2) and
	   enables interrupts */
		__asm __volatile ("
			movml	a0-a2, sp@@-
			movl	%1, a0		/* ADBState, mrg_adbstore2 */
			movl	%0, a1
			jbsr	a1@@
			movml	sp@@+, a0-a2 "
			:
			: "g" (mrg_InitEgret), "g" (ADBState)
			: "a0", "a1");
		jEgret = (void (*)) mrg_OStraps[0x92]; /* may have been set in asm() */
	}
	else printf("Help ...  No vector for InitEgret!!\n");
	
#if defined(MRG_DEBUG)
	printf("mrg: ADBIntrVector: 0x%8lx,  mrg_ADBIntrVector: 0x%8lx\n",
			(long) mrg_romadbintr,
			*((long *) 0x19a));
	printf("mrg: EgretOSTrap: 0x%8lx\n",
			(long) mrg_OStraps[0x92]);
#endif
}
#endif

void
mrg_initadbintr()
{
	if (mac68k_machine.do_graybars)
		printf("Got following HwCfgFlags: 0x%4x, 0x%8x, 0x%8x, 0x%8x\n",
				HwCfgFlags, HwCfgFlags2, HwCfgFlags3, ADBReInit_JTBL);

	if ((HwCfgFlags == 0) && (HwCfgFlags2 == 0) && (HwCfgFlags3 == 0)) {
		printf("Caution: No HwCfgFlags from Booter, please "
			"use at least booter version 1.8.\n");

		if (current_mac_model->class == MACH_CLASSIIsi) {
			printf("     ...  Using defaults for IIsi.\n");

			/* Egret and ADBReInit look into these HwCfgFlags */
			HwCfgFlags = 0xfc00;	
			HwCfgFlags2 = 0x0000773F;
			HwCfgFlags3 = 0x000001a6;
		}

		printf("Using HwCfgFlags: 0x%4x, 0x%8x, 0x%8x\n",
			HwCfgFlags, HwCfgFlags2, HwCfgFlags3);
	}

#ifdef MRG_ADB	
	/*
	 * If we think there is an Egret in the machine, attempt to
	 * set it up.  If not, just enable the interrupts (only on
	 * some machines, others are already on from ADBReInit?).
	 */
	if (   ((HwCfgFlags3 & 0x0e) == 0x06 )
	    || ((HwCfgFlags3 & 0x70) == 0x20 )) {
		if (mac68k_machine.do_graybars)
			printf("mrg: setup_egret:\n");

		setup_egret();

		if (mac68k_machine.do_graybars)
			printf("mrg: setup_egret: done.\n");

	} else {

		if (mac68k_machine.do_graybars)
			printf("mrg: Not setting up egret.\n");

		via_reg(VIA1, vIFR) = 0x4;
		via_reg(VIA1, vIER) = 0x84;

		if (mac68k_machine.do_graybars)
			printf("mrg: ADB interrupts enabled.\n");
	}	
#else
	/* Extra Egret setup required only for MRG ADB functions. */
	printf("mrg: skipping egret setup\n");
#endif /* MRG_ADB */
}

/*
 * NOTE:  By eliminating the setvectors routine and moving it's function
 *        to here we only have to deal with re-locating MacOS Addresses
 *        once and all in one place.
 */
void
mrg_fixupROMBase(obase, nbase)
	caddr_t obase;
	caddr_t nbase;
{
	u_int32_t oldbase, newbase;
	romvec_t *rom;
	int i;

	oldbase = (u_int32_t) obase;
	newbase = (u_int32_t) nbase;

	/*
	 * Grab the pointer to the Mac ROM Glue Vector table
	 */ 
	rom = mrg_MacOSROMVectors;

	if (rom == NULL)
		return;		/* whoops!  ROM vectors not defined! */

	mrg_romident = rom->romident;

	if (0 != mrg_ADBIntrPtr) {
		mrg_romadbintr = mrg_ADBIntrPtr;
		printf("mrg_fixup: using ADBIntrPtr from booter: 0x%08lx\n",
		    (long)mrg_ADBIntrPtr);
	} else
		mrg_romadbintr = rom->adbintr == 0 ?
		    0 : rom->adbintr - oldbase + newbase;

	mrg_rompmintr = rom->pmintr == 0 ?
	    0 : rom->pmintr - oldbase + newbase;
	mrg_ADBAlternateInit = rom->ADBAlternateInit == 0 ?
	    0 : rom->ADBAlternateInit - oldbase + newbase;

	/*
	 * mrg_adbstore becomes ADBBase
	 */
	*((u_int32_t *)(mrg_adbstore + 0x130)) = rom->adb130intr == 0 ?
	    0 : (u_int32_t) rom->adb130intr - oldbase + newbase;

	mrg_OStraps[0x77] = rom->CountADBs == 0 ?
	    0 : rom->CountADBs - oldbase + newbase;
	mrg_OStraps[0x78] = rom->GetIndADB == 0 ?
	    0 : rom->GetIndADB - oldbase + newbase;
	mrg_OStraps[0x79] = rom-> GetADBInfo == 0 ?
	    0 : rom->GetADBInfo - oldbase + newbase;
	mrg_OStraps[0x7a] = rom->SetADBInfo == 0 ?
	    0 : rom->SetADBInfo - oldbase + newbase;
	mrg_OStraps[0x7b] = rom->ADBReInit == 0 ?
	    0 : rom->ADBReInit - oldbase + newbase;
	mrg_OStraps[0x7c] = rom->ADBOp == 0 ?
	    0 : rom->ADBOp - oldbase + newbase;
	mrg_OStraps[0x85] = rom->PMgrOp == 0 ?
	    0 : rom->PMgrOp - oldbase + newbase;
	mrg_OStraps[0x51] = rom->ReadXPRam == 0 ?
	    0 : rom->ReadXPRam - oldbase + newbase;
	mrg_OStraps[0x38] = rom->WriteParam == 0 ?
	    0 : rom->WriteParam - oldbase + newbase;/* WriteParam*/
	mrg_OStraps[0x3a] = rom->SetDateTime == 0 ?
	    0 : rom->SetDateTime - oldbase + newbase;/*SetDateTime*/
	mrg_OStraps[0x3f] = rom->InitUtil == 0 ?
	    0 : rom->InitUtil - oldbase + newbase;  /* InitUtil */
	mrg_OStraps[0x51] = rom->ReadXPRam == 0 ?
	    0 : rom->ReadXPRam - oldbase + newbase; /* ReadXPRam */
	mrg_OStraps[0x52] = rom->WriteXPRam == 0 ?
	    0 : rom->WriteXPRam - oldbase + newbase;/* WriteXPRam */

	if (rom->Egret == 0) {
		jEgret = 0;
		mrg_OStraps[0x92] = 0;
	} else {
		jEgret = (void (*))(rom->Egret - oldbase + newbase);
		mrg_OStraps[0x92] = rom->Egret - oldbase + newbase;
	}
	mrg_InitEgret = rom->InitEgret == 0 ?
	    0 : rom->InitEgret - oldbase + newbase;

	if (rom->jClkNoMem == 0) {
		printf("WARNING: don't have a value for jClkNoMem, ");
		printf("please contact:  walter@@ghpc8.ihf.rwth-aachen.de\n");
		printf("Can't read RTC without it. Using MacOS boot time.\n");
		jClkNoMem = 0;
	} else
		jClkNoMem = (void (*))(rom->jClkNoMem - oldbase + newbase);
	/*
	 * Get the ToolBox Routines we may need.  These are
	 * used in the ADB Initialization of some systems.
	 * If we don't have the ROM addresses for these routines
	 * we'll setup to catch the calls in our own dummy
	 * routines. That way we can politely tell the user
	 * what we'll need to complete initialization on the system.
	 */
	mrg_ToolBoxtraps[0x04d] = rom->FixDiv == 0 ?
	    (caddr_t)mrg_FixDiv : rom->FixDiv - oldbase + newbase;
	mrg_ToolBoxtraps[0x068] = rom->FixMul == 0 ?
	    (caddr_t)mrg_FixMul : rom->FixMul - oldbase + newbase;

	/*
	 * Some systems also require this to be setup for use in
	 * ADB Initialization.  Use whatever address was provided
	 * to us in the romvec table for this system. This may
	 * cause a problem on some systems, and may need a better
	 * Trap handler in the future.
	 */
	ADBReInit_JTBL = rom->ADBReInit_JTBL == 0 ?
	   0 : (u_int32_t)rom->ADBReInit_JTBL - oldbase + newbase;

	/*
	 * Setup to trap unexpected access to ADBProc which is used in
	 * ADB Initialization on some systems. If the correct entry
	 * point in the ADBInit code is selected, this address is
	 * re-configured by the ROM during initialization. This feature
	 * is not currently used by OpenBSD.
	 */
	JADBProc = mrg_jadbprocpanic;

	/*
	 * Get the address of the first (top) Resource in the ROM.
	 * This will be the head of a linked list of all Resources
	 * in the ROM which will be mapped in mrg_InitResources.
	 */
	ROMResourceMap = rom->ROMResourceMap == 0 ?
	    0 : (void (*))(rom->ROMResourceMap - oldbase + newbase);

	for (i = 0; i < sizeof(mrg_AVInitEgretJT) / sizeof(mrg_AVInitEgretJT[0]); i++)
		mrg_AVInitEgretJT[i] = mrg_AVInitEgretJT[i] == 0 ?
		    0 : mrg_AVInitEgretJT[i] - oldbase + newbase;

#if defined(MRG_DEBUG)
	printf("mrg: ROM adbintr 0x%08lx -> 0x%08lx\n",
	    (long)rom->adbintr, (long)mrg_romadbintr);
	printf("mrg: ROM pmintr 0x%08lx -> 0x%08lx\n",
	    (long)rom->pmintr, (long)mrg_rompmintr);
	printf("mrg: OS trap 0x77 (CountADBs) = 0x%08lx -> 0x%08lx\n",
	    (long)rom->CountADBs, (long)mrg_OStraps[0x77]);
	printf("mrg: OS trap 0x78 (GetIndADB) = 0x%08lx -> 0x%08lx\n",
	    (long)rom->GetIndADB, (long)mrg_OStraps[0x78]);
	printf("mrg: OS trap 0x79 (GetADBInfo) = 0x%08lx -> 0x%08lx\n",
	    (long)rom->GetADBInfo, (long)mrg_OStraps[0x79]);
	printf("mrg: OS trap 0x7a (SetADBInfo) = 0x%08lx -> 0x%08lx\n",
	    (long)rom->SetADBInfo, (long)mrg_OStraps[0x7a]);
	printf("mrg: OS trap 0x7b (ADBReInit) = 0x%08lx -> 0x%08lx\n",
	    (long)rom->ADBReInit, (long)mrg_OStraps[0x7b]);
	printf("mrg: OS trap 0x7c (ADBOp) = 0x%08lx -> 0x%08lx\n",
	    (long)rom->ADBOp, (long)mrg_OStraps[0x7c]);
	printf("mrg: OS trap 0x85 (PMgrOp) = 0x%08lx -> 0x%08lx\n",
	    (long)rom->PMgrOp, (long)mrg_OStraps[0x85]);
	printf("mrg: OS trap 0x92 (Egret) = 0x%08lx -> 0x%08lx\n",
	    (long)rom->Egret, (long)mrg_OStraps[0x92]);
	printf("mrg: ROM ADBAltInit 0x%08lx -> 0x%08lx\n",
	    (long)rom->ADBAlternateInit, (long)mrg_ADBAlternateInit);
	printf("mrg: ROM ADBReInit_JTBL 0x%08lx -> 0x%08lx\n",
	    (long)rom->ADBReInit_JTBL, (long)ADBReInit_JTBL);
	printf("mrg: ROM InitEgret  0x%08lx -> 0x%08lx\n",
	    (long)rom->InitEgret, (long)mrg_InitEgret);
	printf("mrg: ROM Resource list-head 0x%08lx -> 0x%08lx\n",
	    (long)rom->ROMResourceMap, (long)ROMResourceMap);
#endif
}   

#ifdef MRG_ADB
void
ADBAlternateInit(void)
{
	if (0 == mrg_ADBAlternateInit) {
		ADBReInit();
	} else {
 		__asm __volatile ("
			movml	a0-a6/d0-d7, sp@@-
			movl	%0, a1
			movl	%1, a3
			jbsr	a1@@
			movml	sp@@+, a0-a6/d0-d7"
			: 
			: "g" (mrg_ADBAlternateInit), "g" (ADBBase)
			: "a1", "a3");
	}
}
#endif /* MRG_ADB */
@


1.30
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.29 2005/05/22 19:40:51 art Exp $	*/
@


1.29
log
@remove "0x" in front of %p in printfs.

eyeballed by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.28 2005/04/27 00:12:43 miod Exp $	*/
d61 1
a61 2
#include <arch/mac68k/mac68k/macrom.h>
#include <arch/mac68k/dev/adbvar.h>
d108 1
a108 1
char	*mrg_romident = NULL;		/* ident string for ROMs */
d688 4
a691 2
	/* Only OS Traps come to us; _alinetrap takes care of ToolBox
	  traps, which are a horrible Frankenstein-esque abomination. */
@


1.28
log
@Replace the last user of pmap_map() with an inline version, and kill pmap_map()
for good.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.27 2005/02/20 18:08:08 martin Exp $	*/
d842 1
a842 1
		printf("Handle to first DRVR resource is 0x%p\n", handle);
d854 1
a854 1
		printf("Handle to second DRVR resource is 0x%p\n", handle);
@


1.27
log
@overhaul macrom code from NetBSD:

- simplify the asm constraints in mrg_aline_super()
- generate a SIGILL for user-mode A-line traps
- cleanup, KNF, whitespace nitpicking and minor other updates

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.26 2005/01/13 21:06:46 martin Exp $	*/
d794 1
d1022 3
a1024 2
		pmap_map(0x50f00000, 0x50f00000, 0x50f00000 + 0x4000,
			 VM_PROT_READ|VM_PROT_WRITE);
@


1.26
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 2
a2 2
/*	$OpenBSD: macrom.c,v 1.25 2004/01/09 22:55:19 jmc Exp $	*/
/*	$NetBSD: macrom.c,v 1.31 1997/03/01 17:20:34 scottr Exp $	*/
d51 2
a53 1
#include <sys/lock.h>
d57 2
a59 3
#include "macrom.h"
#include <sys/malloc.h>
#include <machine/cpu.h>
d61 2
a62 1
#include <machine/frame.h>
d64 1
a64 1
/* trap modifiers (put it macrom.h) */
d72 1
a72 1
/* Mac Rom Glue global variables */
d108 4
a111 5
caddr_t	mrg_rompmintr = 0;			/* ROM PM (?) interrupt */
char *mrg_romident = NULL;			/* ident string for ROMs */
caddr_t mrg_ADBAlternateInit = 0;
caddr_t mrg_InitEgret = 0;
caddr_t mrg_InitPM = 0;
d113 1
a113 1
caddr_t ROMResourceMap = 0;
d116 7
a122 1
caddr_t ResHndls[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
d124 5
a128 1
caddr_t ResHndls[]={0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
a130 4
void	setup_egret(void);
void	mrg_execute_deferred(void);
void	mrg_DTInstall(void);

a140 1

d143 4
a146 4
	__asm volatile (" movl	a0, %0"		/* get arguments */
			 : "=g" (ticks)
			 : 
			 : "a0" );
d152 8
a159 4
	return(ticks);	/* The number of ticks since startup should be
			 * returned here. Until someone finds a need for
			 * this, we just return the requested number
			 *  of ticks */
d164 1
d166 1
a166 1
static caddr_t mrg_DTList = NULL;
d169 1
a169 1
mrg_DTInstall(void)
d173 1
a173 1
	__asm("	movl a0, %0" : "=g" (ptr) );
d182 1
a182 1
	__asm("	clrl d0" : : : "d0");
d186 1
a186 1
mrg_execute_deferred(void)
d197 2
a198 1
		__asm("	moveml a0-a6/d1-d7,sp@@-
d203 1
a203 1
			moveml sp@@+,a0-a6/d1-d7" : : "g" (ptr) );
a214 1

d218 1
a218 1
	last_vbltask = (caddr_t) &VBLQueue_head;
d220 35
a254 39
	while (0 != vbltask)
	{
	    if ( 0 != *((u_int16_t *)(vbltask + vblPhase)) )
	    {
		*((u_int16_t *)(vbltask + vblPhase)) -= 1;
	    } else
	    {
		if ( 0 != *((u_int16_t *)(vbltask + vblCount)) )
		{
		    *((u_int16_t *)(vbltask + vblCount)) -= 1;
		} else
		{
#if defined(MRG_DEBUG)
printf("mrg: mrg_VBLQueue: calling VBL task at 0x%x with VBLTask block at %p\n",
			   *((u_int32_t *)(vbltask + vblAddr)), vbltask);
#endif	      
		    __asm("   movml	#0xfffe, sp@@-
			    movl	%0, a0
			    movl	%1, a1
			    jbsr	a1@@
			    movml	sp@@+, #0x7fff"
			:
			: "g" (vbltask), "g" (*((caddr_t)(vbltask + vblAddr)))
			: "a0", "a1");
#if defined(MRG_DEBUG)
		    printf("mrg: mrg_VBLQueue: back from VBL task\n");
#endif	      
		    if ( 0 == *((u_int16_t *)(vbltask + vblCount)) )
		    {
#if defined(MRG_DEBUG)
		printf("mrg: mrg_VBLQueue: removing VBLTask block at %p\n",
			       vbltask);
#endif	      
			*((u_int32_t *)(last_vbltask + qLink)) = *((u_int32_t *)(vbltask + qLink));
			    /* can't free memory from VBLTask block as
		             * we don't know where it came from */
			if (vbltask == VBLQueue_tail)
			{ /* last task of do{}while */
			    VBLQueue_tail = last_vbltask;
a255 1
		    }
d257 3
a259 4
	    }
	    last_vbltask = vbltask;
	    vbltask = (caddr_t) *((u_int32_t *)(vbltask + qLink));
	} /* while */
d265 1
a265 1
  	__asm("movml #0xffff, sp@@-");
d267 1
a267 1
  	__asm("movml sp@@+, #0xffff");
d279 2
a280 2
    rsrc_t *rsrc = (rsrc_t *)ROMResourceMap;
    short count = 0;
d283 2
a284 2
    printf("Count_Resources looking for 0x%08lx at 0x%08lx\n",
	(long)rsrc_type, (long)rsrc);
d286 5
a290 5
/*
 * Return a Count of all the ROM Resouces of the requested type.
 */
    if (ROMResourceMap == 0)
        panic("Oops! Need ROM Resource Map ListHead address!");
d292 1
a292 1
    while (rsrc != 0) {
d294 11
a304 10
	if (rsrc_type == 0)
            printf("0x%08lx: %04x %04x %04x %04x %08x %08x %08x %04x\n",
                (long)rsrc, rsrc->unknown[0], rsrc->unknown[1],
		rsrc->unknown[2], rsrc->unknown[3], rsrc->next,
		rsrc->body, rsrc->name, rsrc->index);
#endif
        if (rsrc_type == 0 || (rsrc_type == rsrc->name))
            count++;
        rsrc = rsrc->next == 0 ? 0 : (rsrc_t *)(rsrc->next + ROMBase);
    }
d306 1
a306 1
    printf("Count_Resources found %d\n", count);
d308 1
a308 1
    return count;
d314 2
a315 2
    rsrc_t *rsrc = (rsrc_t *)ROMResourceMap;
    short i = 0;
d317 9
a325 7
/*
 * This routine return the "Handle" to a ROM Resource.  Since few
 *  ROM Resources are called for in OpenBSD we keep a small table
 *  for the Handles we return. (Can't reuse the Handle without
 *  defeating the purpose for a Handle in the first place!)  If
 *  we get more requests than we have space for, we panic.
 */
d327 17
a343 19
    if (ROMResourceMap == 0)
        panic("Oops! Need ROM Resource Map ListHead address!");

    while (rsrc != 0) {
        if (rsrc_type == rsrc->name) {
            rsrc_ind--;
            if (rsrc_ind == 0) {
                for (i = 0;i < sizeof(ResHndls)/sizeof(caddr_t);i++)
                    if ((ResHndls[i] == 0) ||
                        (ResHndls[i] == (caddr_t)(rsrc->next + ROMBase))) {
                            ResHndls[i] = (caddr_t)(rsrc->body + ROMBase);
                            return (caddr_t *)&ResHndls[i];
                    }
                panic("ResHndls table too small!");
            }
        }
        rsrc = rsrc->next == 0 ? 0 : (rsrc_t *)(rsrc->next + ROMBase);
    }
    return (caddr_t *) 0;
d349 1
a349 1
    panic("Oops! Need ROM address of _FixDiv for this system!");
d355 1
a355 1
    panic("Oops! Need ROM address of _FixMul for this system!");
d370 1
a370 1
#if DDB
d399 6
a404 4
#ifdef MRG_ADB		/* mrg_adbintr and mrg_pmintr are not defined
                         * here if we are using the MRG_ADB method to
			 * access the ADB/PRAM/RTC. They are
			 * defined in adb_direct.c */
d408 1
a408 2
	if(mrg_romadbintr != NULL)
	{
d415 1
a415 1
		__asm("
d430 1
a430 1
	return(1);
d433 1
a433 1
long
d436 1
a436 2
	if(mrg_rompmintr != NULL)
	{
d443 1
a443 1
		__asm("
d457 1
a457 1
	return(1);
d459 1
a459 1
#endif	/* ifdef MRG_ADB */
d473 1
a473 1
	return(50);
d481 1
d484 1
a484 2
	__asm("	movw	d0, %0"
		: "=g" (numbytes) : : "d0");
d495 1
a495 1
	if(ptr == NULL){
d502 1
a502 1
		printf(" succeeded = %p.\n", ptr);
d509 2
a510 2
	__asm("	movl	%0, a0" :  : "g" (ptr) : "a0");
	return(result);
d519 1
a519 1
	__asm("	movl	a0, %0" : "=g" (ptr) : : "a0");
d525 1
a525 1
	if(ptr == 0){
d527 1
a527 1
	}else{
a528 1
	}
d530 1
a530 1
	return(result);
d538 1
a538 1
	__asm("	movl	a0, %0" : "=g" (ptr) : : "a0");
d544 4
a547 4
	if(ptr == 0){
		return(memWZErr);
	}else
		return(*(int *)(ptr - 4));
d556 2
a557 1
	__asm("	movl	a0, %0
d565 1
a565 1
	return(memFullErr);	/* How would I handle this, anyway? */
d582 3
a584 3
        extern caddr_t mrg_OStraps[];
        caddr_t ptr;
        int trap_num;
d586 4
a589 3
        __asm("   movl a0, %0
                movl d0, %1"
                : "=g" (ptr), "=g" (trap_num) : : "d0", "a0");
d592 1
a592 1
        printf("mrg: trap 0x%x set to 0x%lx\n", trap_num, (long)ptr);
d594 1
a594 1
        mrg_OStraps[trap_num] = ptr;
d598 1
a598 1
        if (trap_num == 0x92) {
d600 2
a601 2
            printf("mrg: reconfigured Egret address from 0x%lx to 0x%lx\n",
                (long)jEgret, (long)ptr);
d603 2
a604 19
            jEgret = (void (*))ptr;
        }
        return 0;
}

int
mrg_GetTrapAddress()
{
	extern caddr_t mrg_OStraps[];
	caddr_t ptr;
	int trap_num;

	asm("	movl d0, %0"
		: "=g" (trap_num) : : "d0");

	ptr = mrg_OStraps[trap_num];

	asm("	movl %0, a0"
		: : "g" (ptr) : "a0");
a628 1
	[0x46]	(caddr_t)mrg_GetTrapAddress,
d656 1
a656 1
        int danprint=0; /* This shouldn't be necessary, but seems to be.  */
d664 2
a665 2
        if (trapword == 0xa71e)
          danprint = 1;
d681 1
a681 1
		printf("\010"); printf("\010");
d698 1
a698 1
	if(trapaddr == NULL){
d709 18
a726 20
/*
 * 	put trapaddr in a2
 * 	put a0 in a0
 * 	put a1 in a1
 * 	put d0 in d0
 * 	put d1 in d1
 * save a6
 * 	call the damn routine
 * restore a6
 * 	store d0 in d0bucket
 * 	store a0 in d0bucket
 * This will change a2,a1,d1,d0,a0 and possibly a6
 */

	__asm("
		movl	%2, d0
		movw	%3, d1
		movl	%4, a0
		movl	%5, a1
		movl	%6, a2
d733 1
a733 3
		: "m" (frame->f_regs[0]), "m" (frame->f_regs[1]),
		  "m" (frame->f_regs[8]), "m" (frame->f_regs[9]),
		  "g" (trapaddr)
d735 1
a735 3
		: "d0", "d1", "a0", "a1", "a2", "a6"

	);
d747 1
a747 1
	if(a0passback)
a756 14
	/* handle a user mode A-line trap */
void
mrg_aline_user()
{
#if 1
	/* send process a SIGILL; aline traps are illegal as yet */
#else /* how to handle real Mac App A-lines */
	/* ignore for now */
	I have no idea!
	maybe pass SIGALINE?
	maybe put global information about aline trap?
#endif
}

d769 1
a769 2
	while(traceindex != traceloopptr)
	{
d771 1
a771 1
		if(traceindex == &traceloopend)
d783 1
a783 1
	return(mrg_romident != NULL);
d812 17
a828 15
        printf("mrg: testing CountResources\n");
        __asm("   clrl    sp@@-
                clrl    sp@@-
                .word   0xa99c
                movw    sp@@+, %0"
                : "=g" (rcnt));
        printf("mrg: found %d resources in ROM\n", rcnt);
        __asm("   clrl    sp@@-
                movl    #0x44525652, sp@@-
                .word   0xa99c
                movw    sp@@+, %0"
                : "=g" (rcnt));
        printf("mrg: %d are DRVR resources\n", rcnt);
        if (rcnt == 0)
            panic("Oops! No DRVR Resources found in ROM");
d833 25
a857 23
        printf("mrg: testing GetIndResource\n");
        __asm("   clrl    sp@@-
                movl    #0x44525652, sp@@-
                movw    #0x01, sp@@-
                .word   0xa99d
                movl    sp@@+, %0"
                : "=g" (handle));
        printf("Handle to first DRVR resource is 0x%08lx\n", (long)handle);
        printf("DRVR: 0x%08lx -> 0x%08lx -> 0x%08lx\n",
            (long)Get_Ind_Resource(0x44525652, 1),
	    (long)*Get_Ind_Resource(0x44525652, 1),
               (long) *((u_int32_t *) *Get_Ind_Resource(0x44525652, 1)));
        __asm("   clrl    sp@@-
                movl    #0x44525652, sp@@-
                movw    #0x02, sp@@-
                .word   0xa99d
                movl    sp@@+, %0"
                : "=g" (handle));
        printf("Handle to second DRVR resource is 0x%08lx\n", (long)handle);
        printf("DRVR: 0x%08lx -> 0x%08lx -> 0x%08lx\n",
            (long)Get_Ind_Resource(0x44525652, 2),
	    (long)*Get_Ind_Resource(0x44525652, 2),
              (long)  *((u_int32_t *) *Get_Ind_Resource(0x44525652, 2)));
d860 1
a860 1
	if(mrg_romready()){
d896 2
a897 6

	/* magic (word) */
	*((u_int16_t *)(mrg_ExpandMem + 0x00) ) = 0x0123;
	/* Length of table (long) */
	*((u_int32_t *)(mrg_ExpandMem + 0x02) ) = 0x000001ea;

d915 1
a915 1
  	if(TimeDBRA == 0)
d917 1
a917 1
  	if(ROMBase == 0)
d927 1
a927 1
	for(i = 0; i < 8; i++) /* Set up fake Lvl1DT */
d929 1
a929 1
	for(i = 0; i < 8; i++) /* Set up fake Lvl2DT */
d934 6
a939 3
	JADBProc = mrg_jadbprocpanic; /* Fake JADBProc for the time being */
	jSwapMMU = mrg_jswapmmupanic; /* Fake jSwapMMU for the time being */
	JKybdTask = mrg_jkybdtaskpanic; /* Fake jSwapMMU for the time being */
a940 2
	jADBOp = (void (*)(void))
			mrg_OStraps[0x7c]; /* probably very dangerous */
d942 1
a942 1
	SCCRd = (caddr_t)(IOBase + sccA);   /* ser.c ; we run before serinit */
d944 1
a944 1
	jDTInstall = (caddr_t) mrg_DTInstall;
d949 1
a949 1
	switch(mach_cputype()){
d968 2
a969 2
	for(i = 0; i < 500000; i++)
		if((i % 100000) == 0)printf(".");
d983 2
a984 2
	for(i = 0; i < 500000; i++)
		if((i % 100000) == 0)printf(".");
d996 3
a998 2
	for(i = 0; i < 500000; i++)
		if((i % 100000) == 0)printf(".");
a1022 12
		if (     (current_mac_model->class == MACH_CLASSPB)
		   ||   (current_mac_model->class == MACH_CLASSDUO)) {
			/* CPU GLU */
			pmap_map(0x50080000, 0x50080000, 0x50080000 + 0x10000,	
				 VM_PROT_READ|VM_PROT_WRITE);
			/* Modem slot for PB500 */
			pmap_map(0xfb000000, 0xfb000000, 0xfb000000 + 0x10000,
				 VM_PROT_READ|VM_PROT_WRITE);
			/* ??? */
			pmap_map(0x50f80000, 0x50f80000, 0x50f80000 + 0x40000,
				 VM_PROT_READ|VM_PROT_WRITE);
		}
d1026 4
a1029 1
void
d1032 1
a1032 1
	if (0 != mrg_InitEgret){
d1036 2
a1037 1
		__asm("	movml	a0-a2, sp@@-
d1045 1
a1045 2
		/* may have been set in asm() */
		jEgret = (void (*)) mrg_OStraps[0x92];
a1056 22

#ifdef MRG_ADB
static void     setup_pm(void);

static void
setup_pm(void)
{
	if (0 != mrg_InitPM){

	/* This initializes the Power Manager system and
	   enables interrupts */
		asm("
			movml	#0xffff, sp@@-
			moval	%0, a0
			jbsr	a0@@
			movml	sp@@+, #0xffff"
			:
			: "g" (mrg_InitPM)
			: "a0"
		);
	} else printf("Help ...  No vector for InitPM!!\n");
}
d1064 1
a1064 3
			HwCfgFlags, HwCfgFlags2, HwCfgFlags3, ADBReInit_JTBL);

        if ( (HwCfgFlags == 0) && (HwCfgFlags2 == 0) && (HwCfgFlags3 == 0) ){
d1066 1
d1083 1
a1083 4
#ifndef MRG_ADB		/* Extra Egret setup not required for the
			 * MRG_ADB method. */
        printf("mrg: skipping egret setup\n");
#else
d1099 1
a1099 4
	} else if (	(current_mac_model->class == MACH_CLASSPB)
		   ||	(current_mac_model->class == MACH_CLASSDUO)) {
		if (mac68k_machine.do_graybars)
			printf("mrg: setup_pm:\n");
a1100 6
		setup_pm();

		if (mac68k_machine.do_graybars)
			printf("mrg: setup_pm: done.\n");

	} else {
d1110 4
a1113 1
#endif
d1132 63
a1194 150
/*
 * Grab the pointer to the Mac ROM Glue Vector table
 */ 
        rom = mrg_MacOSROMVectors;

        if (rom == NULL)
                return;         /* whoops!  ROM vectors not defined! */

        mrg_romident = rom->romident;

        if (0 != mrg_ADBIntrPtr) {
                mrg_romadbintr = mrg_ADBIntrPtr;
                printf("mrg_fixup: using ADBIntrPtr from booter: 0x%08lx\n",
                        (long)mrg_ADBIntrPtr);
        } else
            mrg_romadbintr = rom->adbintr == 0 ?
                0 : rom->adbintr - oldbase + newbase;

        mrg_rompmintr = rom->pmintr == 0 ?
                0 : rom->pmintr - oldbase + newbase;
        mrg_ADBAlternateInit = rom->ADBAlternateInit == 0 ?
                0 : rom->ADBAlternateInit - oldbase + newbase;

        /*
         * mrg_adbstore becomes ADBBase
         */
        *((u_int32_t *)(mrg_adbstore + 0x130)) = rom->adb130intr == 0 ?
                0 : (u_int32_t) rom->adb130intr - oldbase + newbase;

        mrg_OStraps[0x77] = rom->CountADBs == 0 ?
                0 : rom->CountADBs - oldbase + newbase;
        mrg_OStraps[0x78] = rom->GetIndADB == 0 ?
                0 : rom->GetIndADB - oldbase + newbase;
        mrg_OStraps[0x79] = rom-> GetADBInfo == 0 ?
                0 : rom->GetADBInfo - oldbase + newbase;
        mrg_OStraps[0x7a] = rom->SetADBInfo == 0 ?
                0 : rom->SetADBInfo - oldbase + newbase;
        mrg_OStraps[0x7b] = rom->ADBReInit == 0 ?
                0 : rom->ADBReInit - oldbase + newbase;
        mrg_OStraps[0x7c] = rom->ADBOp == 0 ?
                0 : rom->ADBOp - oldbase + newbase;
        mrg_OStraps[0x85] = rom->PMgrOp == 0 ?
                0 : rom->PMgrOp - oldbase + newbase;
        mrg_OStraps[0x51] = rom->ReadXPRam == 0 ?
                0 : rom->ReadXPRam - oldbase + newbase;
        mrg_OStraps[0x38] = rom->WriteParam == 0 ?
                0 : rom->WriteParam - oldbase + newbase;/* WriteParam*/
        mrg_OStraps[0x3a] = rom->SetDateTime == 0 ?
                0 : rom->SetDateTime - oldbase + newbase;/*SetDateTime*/
        mrg_OStraps[0x3f] = rom->InitUtil == 0 ?
                0 : rom->InitUtil - oldbase + newbase;  /* InitUtil */
        mrg_OStraps[0x51] = rom->ReadXPRam == 0 ?
                0 : rom->ReadXPRam - oldbase + newbase; /* ReadXPRam */
        mrg_OStraps[0x52] = rom->WriteXPRam == 0 ?
                0 : rom->WriteXPRam - oldbase + newbase;/* WriteXPRam */

        if (rom->Egret == 0) {
            jEgret = 0;
            mrg_OStraps[0x92] = 0;
        }
        else {
            jEgret = (void (*))rom->Egret - oldbase + newbase;
            mrg_OStraps[0x92] = rom->Egret - oldbase + newbase;
        }
        mrg_InitEgret = rom->InitEgret == 0 ?
                0 : rom->InitEgret - oldbase + newbase;

	if (	(current_mac_model->class == MACH_CLASSPB)
	   ||	(current_mac_model->class == MACH_CLASSDUO)) {
		switch( mac68k_machine.machineid ) {
		case MACH_MACPB170:
			mrg_InitPM =	/* PMgrInit */
				(caddr_t)0x40888400 - oldbase + newbase;
			jCacheFlush = (caddr_t)0x40809a7c - oldbase + newbase;
			mrg_OStraps[0x33] =	/* VInstall */
				(caddr_t)0x4082ea80 - oldbase + newbase;
			mrg_OStraps[0x55] =	/* MemoryDispatch */
				(caddr_t)0x4082eada - oldbase + newbase;
			mrg_OStraps[0x5e] =	/* NMInstall */
				(caddr_t)0x4082eafe - oldbase + newbase;
			mrg_OStraps[0x5f] =	/* NMRemove */
				(caddr_t)0x4082eb08 - oldbase + newbase;
			mrg_OStraps[0x8d] =	/* EnterSuperVisor */
				(caddr_t)0x4082914a - oldbase + newbase;
			mrg_OStraps[0x9e] =	/* FullProcessorSpeed */
				(caddr_t)0x40829868 - oldbase + newbase;
			mrg_OStraps[0x9f] =	/* PMgrDispatch */
				(caddr_t)0x408888d8 - oldbase + newbase;
			break;
		case MACH_MACPB140:
		case MACH_MACPB145:
			mrg_InitPM =	/* PMgrInit (symbol undef.) */
				(caddr_t)0x40888400 - oldbase + newbase;
			jCacheFlush = (caddr_t)0x40809a7c - oldbase + newbase;
			mrg_OStraps[0x33] =	/* VInstall */
				(caddr_t)0x4080a230 - oldbase + newbase;
			mrg_OStraps[0x55] =	/* _VM */
				(caddr_t)0x40805538 - oldbase + newbase;
			mrg_OStraps[0x5e] =	/* NMInstall */
				(caddr_t)0x4081d720 - oldbase + newbase;
			mrg_OStraps[0x5f] =	/* NMRemove */
				(caddr_t)0x4081d730 - oldbase + newbase;
			break;
		case MACH_MACPB160:
		case MACH_MACPB165:
		case MACH_MACPB165C:
		case MACH_MACPB180:
		case MACH_MACPB180C:
		case MACH_MACPB210:
		case MACH_MACPB230:
		case MACH_MACPB250:
		case MACH_MACPB270:
		case MACH_MACPB280:
		case MACH_MACPB280C:
			mrg_InitPM =	/* PMgrInit */
				(caddr_t)0x40888400 - oldbase + newbase;
			jCacheFlush = (caddr_t)0x40809a7c - oldbase + newbase;
			mrg_OStraps[0x33] =	/* VInstall */
				(caddr_t)0x4080a230 - oldbase + newbase;
			mrg_OStraps[0x55] =	/* MemoryDispatch */
				(caddr_t)0x40805538 - oldbase + newbase;
			mrg_OStraps[0x5e] =	/* NMInstall */
				(caddr_t)0x4082eafe - oldbase + newbase;
			mrg_OStraps[0x5f] =	/* NMRemove */
				(caddr_t)0x4082eb08 - oldbase + newbase;
			mrg_OStraps[0x8d] =	/* EnterSuperVisor */
				(caddr_t)0x4082914a - oldbase + newbase;
			mrg_OStraps[0x9e] =	/* FullProcessorSpeed */
				(caddr_t)0x40829868 - oldbase + newbase;
			mrg_OStraps[0x9f] =	/* PMgrDispatch */
				(caddr_t)0x408888d8 - oldbase + newbase;
			break;
		case MACH_MACPB500:
			mrg_InitPM =	/* PMgrInit */
				(caddr_t)0x400d8800 - oldbase + newbase;
			jCacheFlush = (caddr_t)0x40085030 - oldbase + newbase;
			mrg_OStraps[0x33] =	/* VInstall */
				(caddr_t)0x4000a230 - oldbase + newbase;
			mrg_OStraps[0x5e] =	/* NMInstall */
				(caddr_t)0x4002eafe - oldbase + newbase;
			mrg_OStraps[0x5f] =	/* NMRemove */
				(caddr_t)0x4002eb08 - oldbase + newbase;
			mrg_OStraps[0x8d] =	/* EnterSuperVisor */
				(caddr_t)0x4000a0f0 - oldbase + newbase;
			mrg_OStraps[0x9e] =	/* FullProcessorSpeed */
				(caddr_t)0x400da254 - oldbase + newbase;
			mrg_OStraps[0x9f] =	/* PMgrDispatch */
				(caddr_t)0x400d8fc0 - oldbase + newbase;
			break;
		}
d1196 2
d1199 35
a1233 36
        if (rom->jClkNoMem == 0) {
                printf("WARNING: don't have a value for jClkNoMem, please ");
		printf("contact:  walter@@ghpc8.ihf.rwth-aachen.de\n");
                printf("Can't read RTC without it. Using MacOS boot time.\n");
                jClkNoMem = 0;
        }
        else
            jClkNoMem = (void (*)) rom->jClkNoMem - oldbase + newbase;
        /*
         * Get the ToolBox Routines we may need.  These are
         *  used in the ADB Initialization of some systems.
         *  If we don't have the ROM addresses for these routines
         *  we'll setup to catch the calls in our own dummy
         *  routines. That way we can politely tell the user
         *  what we'll need to complete initialization on the system.
         */
        mrg_ToolBoxtraps[0x04d] = rom->FixDiv == 0 ?
                (caddr_t)mrg_FixDiv : rom->FixDiv - oldbase + newbase;
        mrg_ToolBoxtraps[0x068] = rom->FixMul == 0 ?
                (caddr_t)mrg_FixMul : rom->FixMul - oldbase + newbase;

        /*
         * Some systems also require this to be setup for use in
         *  ADB Initialization.  Use whatever address was provided
         *  to us in the romvec table for this system. This may
         *  cause a problem on some systems, and may need a better
         *  Trap handler in the future.
         */
        ADBReInit_JTBL = rom->ADBReInit_JTBL == 0 ?
                0 : (u_int32_t)rom->ADBReInit_JTBL - oldbase + newbase;

        /*
         * Setup to trap unexpected access to ADBProc which is used in
         * ADB Initialization on some systems. If the correct entry
         * point in the ADBInit code is selected, this address is
         * re-configured by the ROM during initialization. This feature
d1235 2
a1236 2
         */
        JADBProc = mrg_jadbprocpanic;
d1238 7
a1244 7
        /*
         * Get the address of the first (top) Resource in the ROM.
         *  This will be the head of a linked list of all Resources
         *  in the ROM which will be mapped in mrg_InitResources.
         */
        ROMResourceMap = rom->ROMResourceMap == 0 ?
                0 : (void (*))rom->ROMResourceMap - oldbase + newbase;
d1251 28
a1278 28
        printf("mrg: ROM adbintr 0x%08lx -> 0x%08lx\n",
                (long)rom->adbintr, (long)mrg_romadbintr);
        printf("mrg: ROM pmintr 0x%08lx -> 0x%08lx\n",
                (long)rom->pmintr, (long)mrg_rompmintr);
        printf("mrg: OS trap 0x77 (CountADBs) = 0x%08lx -> 0x%08lx\n",
                (long)rom->CountADBs, (long)mrg_OStraps[0x77]);
        printf("mrg: OS trap 0x78 (GetIndADB) = 0x%08lx -> 0x%08lx\n",
                (long)rom->GetIndADB, (long)mrg_OStraps[0x78]);
        printf("mrg: OS trap 0x79 (GetADBInfo) = 0x%08lx -> 0x%08lx\n",
                (long)rom->GetADBInfo, (long)mrg_OStraps[0x79]);
        printf("mrg: OS trap 0x7a (SetADBInfo) = 0x%08lx -> 0x%08lx\n",
                (long)rom->SetADBInfo, (long)mrg_OStraps[0x7a]);
        printf("mrg: OS trap 0x7b (ADBReInit) = 0x%08lx -> 0x%08lx\n",
                (long)rom->ADBReInit, (long)mrg_OStraps[0x7b]);
        printf("mrg: OS trap 0x7c (ADBOp) = 0x%08lx -> 0x%08lx\n",
                (long)rom->ADBOp, (long)mrg_OStraps[0x7c]);
        printf("mrg: OS trap 0x85 (PMgrOp) = 0x%08lx -> 0x%08lx\n",
                (long)rom->PMgrOp, (long)mrg_OStraps[0x85]);
        printf("mrg: OS trap 0x92 (Egret) = 0x%08lx -> 0x%08lx\n",
                (long)rom->Egret, (long)mrg_OStraps[0x92]);
        printf("mrg: ROM ADBAltInit 0x%08lx -> 0x%08lx\n",
                (long)rom->ADBAlternateInit, (long)mrg_ADBAlternateInit);
        printf("mrg: ROM ADBReInit_JTBL 0x%08lx -> 0x%08lx\n",
                (long)rom->ADBReInit_JTBL, (long)ADBReInit_JTBL);
        printf("mrg: ROM InitEgret  0x%08lx -> 0x%08lx\n",
                (long)rom->InitEgret, (long)mrg_InitEgret);
        printf("mrg: ROM Resource list-head 0x%08lx -> 0x%08lx\n",
                (long)rom->ROMResourceMap, (long)ROMResourceMap);
d1286 1
a1286 1
	if (0 == mrg_ADBAlternateInit){
d1289 1
a1289 1
 		__asm("
d1300 1
a1300 1
#endif
@


1.25
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.24 2003/06/04 07:17:24 miod Exp $	*/
d398 1
a398 1
long
@


1.24
log
@strlcpy; tested by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.23 2002/03/14 01:26:36 millert Exp $	*/
d497 1
a497 1
		printf(" succeded = %p.\n", ptr);
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.22 2001/11/06 19:53:15 miod Exp $	*/
d953 1
a953 1
	strcpy(&FinderName[1], findername);
@


1.22
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.21 2001/08/11 22:59:37 art Exp $	*/
d121 3
a123 3
void	setup_egret __P((void));
void	mrg_execute_deferred __P((void));
void	mrg_DTInstall __P((void));
d1099 1
a1099 1
static void     setup_pm __P((void));
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.22 2001/11/06 19:53:15 miod Exp $	*/
d121 3
a123 3
void	setup_egret(void);
void	mrg_execute_deferred(void);
void	mrg_DTInstall(void);
d1099 1
a1099 1
static void     setup_pm(void);
@


1.21
log
@unnecessary includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.20 1999/01/11 05:11:36 millert Exp $	*/
d54 1
a54 1
#include <vm/vm.h>
@


1.20
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.19 1998/05/03 07:16:50 gene Exp $	*/
a54 3
#include <vm/vm_prot.h>
#include <vm/vm_param.h>
#include <vm/pmap.h>
@


1.20.6.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.20 1999/01/11 05:11:36 millert Exp $	*/
d55 3
@


1.20.6.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
#include <uvm/uvm_extern.h>
@


1.20.6.3
log
@Merge in -current from about a week ago
@
text
@d121 3
a123 3
void	setup_egret(void);
void	mrg_execute_deferred(void);
void	mrg_DTInstall(void);
d1099 1
a1099 1
static void     setup_pm(void);
@


1.20.6.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.20.6.3 2002/03/28 10:34:05 niklas Exp $	*/
d953 1
a953 1
	strlcpy(FinderName + 1, findername, sizeof FinderName - 1);
@


1.20.6.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d497 1
a497 1
		printf(" succeeded = %p.\n", ptr);
@


1.19
log
@Fallout from recent merge of macinfo.h to cpu.h.
Also, fallout from interrupt glue structure becoming mroe dynamic using
locore-changeable variables to store ipl levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.18 1997/11/30 18:25:38 gene Exp $	*/
d272 1
a272 1
	panic("mrg: hit mrg_init_stub_2\n");
d289 1
a289 1
        panic("Oops! Need ROM Resource Map ListHead address!\n");
d324 1
a324 1
        panic("Oops! Need ROM Resource Map ListHead address!\n");
d336 1
a336 1
                panic("ResHndls table too small!\n");
d347 1
a347 1
    panic("Oops! Need ROM address of _FixDiv for this system!\n");
d353 1
a353 1
    panic("Oops! Need ROM address of _FixMul for this system!\n");
d376 1
a376 1
	panic("Agh!  I was called from Lvl2DT!!!\n");
d382 1
a382 1
	panic("Agh!  Called JADBProc!\n");
d388 1
a388 1
	panic("Agh!  Called jSwapMMU!\n");
d394 1
a394 1
	panic("Agh!  Called JKybdTask!\n");
d464 1
a464 1
	panic("mrg_notrap: We're doomed!\n");
d862 1
a862 1
            panic("Oops! No DRVR Resources found in ROM\n");
d954 1
a954 1
		panic("ROMBase not set in mrg_init()!\n");
@


1.18
log
@Pull in vm/vm.h in the appropriate order for simple_dat_lock_t in vm/pmap.h
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.17 1997/11/30 06:36:42 gene Exp $	*/
a62 1
#include <machine/macinfo.h>
@


1.17
log
@vm/lock.h -> sys/lock.h
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.16 1997/04/23 00:29:15 gene Exp $	*/
d54 1
d67 1
a67 1
	/* trap modifiers (put it macrom.h) */
d75 1
a75 1
	/* Mac Rom Glue global variables */
@


1.16
log
@NetBSD -> OpenBSD where relevant and appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.15 1997/04/14 18:48:01 gene Exp $	*/
d52 1
a55 1
#include <vm/lock.h>
@


1.15
log
@Bring our incarnation of John Wittowski's direct adb driver into compatible
state with NetBSD's.  The direct-to-ADB code is now enabled by default.
Using 'options MRG_ADB' will cause the kernel to revert to the 'old standby'
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.14 1997/04/14 02:10:21 briggs Exp $	*/
d317 1
a317 1
 *  ROM Resources are called for in NetBSD we keep a small table
d1395 1
a1395 1
	 * is not currently used by NetBSD.
@


1.14
log
@setup_pm() is only used with \!HWDIRECT.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.13 1997/04/05 16:19:29 briggs Exp $	*/
d397 2
a398 2
#ifndef HWDIRECT	/* mrg_adbintr and mrg_pmintr are not defined
                         * here if we are using the HWDIRECT method to
d457 1
a457 1
#endif	/* ifndef HWDIRECT */
d1101 1
a1101 1
#ifndef HWDIRECT
d1149 2
a1150 2
#ifdef HWDIRECT		/* Extra Egret setup not required for the
			 * HWDIRECT method. */
d1443 1
a1443 1
#ifndef HWDIRECT
@


1.13
log
@Move the PB140/145 info to it's own case.  A couple of the entry points
are different from other cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.12 1997/04/05 15:29:12 briggs Exp $	*/
d1101 1
d1122 1
@


1.12
log
@MRG-based ADB support for the PowerBook series.  Contributed by
hamada@@next.etron.kanazawa-it.ac.jp (Takashi Hamada)
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.11 1997/03/30 21:53:25 briggs Exp $	*/
a1274 2
		case MACH_MACPB140:
		case MACH_MACPB145:
d1293 14
@


1.11
log
@An implementation of pieces of the Deferred Task Manager--required by
some video cards.  Provided by Paul Goyette <paul@@pgoyette.bdt.com>.
This introduces another simulated software interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.10 1997/03/08 16:17:05 briggs Exp $	*/
d114 1
d605 17
d643 1
d928 6
a933 2
	*((u_int16_t *)(mrg_ExpandMem + 0x00) ) = 0x0123;	/* magic (word) */
	*((u_int32_t *)(mrg_ExpandMem + 0x02) ) = 0x000001ea;	/* Length of table (long) */
d1057 12
d1087 2
a1088 1
		jEgret = (void (*)) mrg_OStraps[0x92]; /* may have been set in asm() */
d1101 21
d1127 1
a1127 1
				HwCfgFlags, HwCfgFlags2, HwCfgFlags3, ADBReInit_JTBL);
d1166 10
a1176 1

d1272 73
d1346 2
a1347 2
                printf("WARNING: don't have a value for jClkNoMem, please contac
t:  walter@@ghpc8.ihf.rwth-aachen.de\n");
@


1.10
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.9 1997/02/23 06:05:00 briggs Exp $	*/
d124 2
a125 1

d155 42
d627 1
d955 2
@


1.9
log
@Integrate code from John P. Wittkoski <jpw@@netwizards.net> and
Takashi Hamada <hamada@@next.etron.kanazawa-it.ac.jp>.  This code
interfaces directly to the hardware to support the ADB on many
macs.  It is enabled by "options HWDIRECT" in the configuration
file.  At some point, this should probably become the default method
as interfacing to the ADB through the ROMs has been painful and sometimes
problematic.

This code should have functioning ADB support for:
	II series (II, SE/30, IIx, IIcx)
	IIsi series (IIsi, IIci, IIvx, IIvi)
	LC II, LC III
	Performa 400, 405, 430, 460, 465, 467, 600
	Classic II, Color Classic, Color Classic II
	PB 5XX series
	Duo series
	PB 140,145,145b,160,(160c?),165,165c,170,180,180c
	Quadra 700,900,950
There is an off-chance that it will work on:
	PB 150, PB 190
	Quadra/Centris 605,610,630,650,660AV,800,840AV
	LC 475,550,575,630
	Performa 475,476,575,577,578,630
Note that functioning ADB support does not mean that everything else
will work.  I obviously do not own all of the above machines (does
anyone?  ;-)...  Any reports are welcome.

Many thanks to John Wittkoski and Takashi Hamada!
@
text
@d1 2
a2 2
/*	$OpenBSD: macrom.c,v 1.8 1997/01/24 01:35:49 briggs Exp $	*/
/*	$NetBSD: macrom.c,v 1.30 1996/12/18 07:21:06 scottr Exp $	*/
a434 1
	u_int32_t trapword;
d437 2
a438 3
	__asm("	movw	d1, %0
		movl	d0, %1"
		: "=g" (trapword), "=g" (numbytes) : : "d0", "d1");
d441 1
a441 3
	printf("mrg: NewPtr(%d bytes, %sclear, %ssys)", numbytes,
		TRAP_SYS(trapword) ? "" : "no ",
		TRAP_CLEAR(trapword) ? "" : "no ");
d456 1
a456 1
		printf(" succeded = %x.\n", ptr);
d476 1
a476 1
	printf("mrg: DisposPtr(%x)\n", ptr);
d496 1
a496 1
	printf("mrg: GetPtrSize(%x)\n", ptr);
d511 1
a511 1
	__asm("	movl	a1, %0
d513 1
a513 1
		: "=g" (ptr), "=g" (newbytes) : : "d0", "a1");
d516 1
a516 1
	printf("mrg: SetPtrSize(%x, %d) failed\n", ptr, newbytes);
d662 1
a662 2
 * 	put trapword in d1
 * 	put trapaddr in a1
d664 1
d666 1
d672 1
a672 1
 * This will change a1,d1,d0,a0 and possibly a6
d676 1
a676 1
		movl	%2, a1
d678 4
a681 3
		movl	%4, d0
		movl	%5, a0
		jbsr	a1@@
d687 3
a689 2
		: "g" (trapaddr), "g" (trapword),
		  "m" (frame->f_regs[0]), "m" (frame->f_regs[8])
d691 1
a691 1
		: "d0", "d1", "a0", "a1", "a6"
@


1.8
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.7 1997/01/19 03:58:08 briggs Exp $	*/
d123 3
d353 4
d413 1
d438 1
a438 1
	__asm("	movl	d1, %0
d665 12
a676 10
/* 	put trapword in d1 */
/* 	put trapaddr in a1 */
/* 	put a0 in a0 */
/* 	put d0 in d0 */
/* save a6 */
/* 	call the damn routine */
/* restore a6 */
/* 	store d0 in d0bucket */
/* 	store a0 in d0bucket */
/* This will change a1,d1,d0,a0 and possibly a6 */
d690 1
a690 1
			"m" (frame->f_regs[0]), "m" (frame->f_regs[8])
d992 1
a992 3
static void	setup_egret __P((void));

static void
d1045 4
d1075 1
d1245 1
d1263 1
@


1.7
log
@asm -> __asm, inline -> __inline
@
text
@d1 2
a2 2
/*	$OpenBSD: macrom.c,v 1.6 1996/10/30 05:26:29 briggs Exp $	*/
/*	$NetBSD: macrom.c,v 1.26 1996/08/05 23:20:46 briggs Exp $	*/
d136 4
a139 4
	__asm("	movl	a0, %0"		/* get arguments */
		:
		: "g" (ticks)
		: "a0" );
@


1.6
log
@Fix spelling error in panic.  Double since of ResHndls[].  Use I/O kludge on
all systems, not just CLASSII--A bunch of Quadras apparently have hardcoded
I/O addresses in the ROMs, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.5 1996/10/28 14:55:32 briggs Exp $	*/
d136 1
a136 1
	asm("	movl	a0, %0"		/* get arguments */
d182 1
a182 1
		    asm("   movml	#0xfffe, sp@@-
d217 1
a217 1
  	asm("movml #0xffff, sp@@-");
d219 1
a219 1
  	asm("movml sp@@+, #0xffff");
d361 1
a361 1
		asm("
d390 1
a390 1
		asm("
d430 1
a430 1
	asm("	movl	d1, %0
d459 1
a459 1
	asm("	movl	%0, a0" :  : "g" (ptr) : "a0");
d469 1
a469 1
	asm("	movl	a0, %0" : "=g" (ptr) : : "a0");
d489 1
a489 1
	asm("	movl	a0, %0" : "=g" (ptr) : : "a0");
d507 1
a507 1
	asm("	movl	a1, %0
d536 1
a536 1
        asm("   movl a0, %0
d668 1
a668 1
	asm("
d777 1
a777 1
        asm("   clrl    sp@@-
d783 1
a783 1
        asm("   clrl    sp@@-
d796 1
a796 1
        asm("   clrl    sp@@-
d807 1
a807 1
        asm("   clrl    sp@@-
d991 1
a991 1
		asm("	movml	a0-a2, sp@@-
d1238 1
a1238 1
 		asm("
@


1.5
log
@Include macinfo.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.4 1996/08/10 21:37:47 briggs Exp $	*/
d120 1
a120 1
caddr_t ResHndls[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
d289 1
a289 1
                panic("ResHndls table to small!\n");
d963 1
a963 1
	if (current_mac_model->class == MACH_CLASSII) {
d968 4
a971 2
		 * your code?  I think so! (_ReadXPRam + 0x0062)  We map
		 * the first 
d974 1
a974 1
		printf("mrg: I/O map kludge for old ROMs that use hardware %s",
@


1.4
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: macrom.c,v 1.3 1996/05/26 18:36:24 briggs Exp $	*/
d62 1
@


1.3
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: macrom.c,v 1.25 1996/05/25 14:45:34 briggs Exp $	*/
d766 6
a771 3
	VBLQueue = (u_int16_t) 0;	/* No vertical blanking routines in the queue */
	VBLQueue_head = (caddr_t) 0;	/*  Let's hope that this init happens
	VBLQueue_tail = (caddr_t) 0;	 *  before the RTC interrupts are enabled */
@


1.2
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: macrom.c,v 1.18 1995/10/01 02:29:32 briggs Exp $	*/
a47 1
#include <sys/types.h>
d49 9
a57 1
#include "via.h"
d79 9
d89 19
a107 1
caddr_t	mrg_romadbintr = (caddr_t)0x40807002;	/* ROM ADB interrupt */
d113 7
d127 180
d360 1
a360 1
			movml	#0xffff, sp@@-	| better save all registers!
d364 1
a364 1
			movml	sp@@+, #0xffff"	/* better restore all registers! */
d366 2
a367 1
			: "g" (mrg_romadbintr));
d389 1
a389 1
			movml	#0xffff, sp@@-	| better save all registers!
d393 1
a393 1
			movml	sp@@+, #0xffff"	/* better restore all registers! */
d395 2
a396 1
			: "g" (mrg_rompmintr));
a419 1

d430 1
a430 1
		: "=g" (trapword), "=g" (numbytes));
d454 1
d457 1
a457 1
	asm("	movl	%0, a0" :  : "g" (ptr));
d467 1
a467 1
	asm("	movl	a0, %0" : "=g" (ptr));
a484 1
	int result = noErr;
d487 1
a487 1
	asm("	movl	a0, %0" : "=g" (ptr));
a501 1
	int result = noErr;
d507 1
a507 1
		: "=g" (ptr), "=g" (newbytes));
d522 33
d559 6
a564 1
 * (BTW, this table is initialized for Mac II.)
d575 3
a577 8
	[0x77]	(caddr_t)0x40807778,	/* CountADBs */
		(caddr_t)0x40807792,	/* GetIndADB */
		(caddr_t)0x408077be,	/* GetADBInfo */
		(caddr_t)0x408077c4,	/* SetADBInfo */
		(caddr_t)0x40807704,	/* ADBReInit */
		(caddr_t)0x408072fa,	/* ADBOp */
	[0x85]	0,			/* PMgrOp (not on II) */
	[0x92]	(caddr_t)0x40814800,	/* Egret */
d584 2
d614 1
a614 1
	printf(" wd 0x%x", trapword);
d619 10
a628 5
        if (danprint)
          {
	   /* Without these print statements, ADBReInit fails on IIsi */
            printf(""); printf("");
          }
d640 3
a642 1
	printf(" addr 0x%x\n", trapaddr);
d688 2
a740 63
	/* Set ROM Vectors */
void
mrg_setvectors(rom)
	romvec_t *rom;
{
	if (rom == NULL)
		return;		/* whoops!  ROM vectors not defined! */

	mrg_romident = rom->romident;

	if (0 != mrg_ADBIntrPtr) {
		mrg_romadbintr = mrg_ADBIntrPtr;
		printf("mrg_setvectors: using ADBIntrPtr from booter: 0x%08x\n",
			mrg_ADBIntrPtr);
	} else
 		mrg_romadbintr = rom->adbintr;
	mrg_rompmintr = rom->pmintr;
	mrg_ADBAlternateInit = rom->ADBAlternateInit;
	mrg_InitEgret = rom->InitEgret;

	/*
	 * mrg_adbstore becomes ADBBase
	 */
	*((u_int32_t *)(mrg_adbstore + 0x130)) = (u_int32_t) rom->adb130intr;

	jEgret = (void (*))0x40814800;

	mrg_OStraps[0x77] = rom->CountADBs;
	mrg_OStraps[0x78] = rom->GetIndADB;
	mrg_OStraps[0x79] = rom->GetADBInfo;
	mrg_OStraps[0x7a] = rom->SetADBInfo;
	mrg_OStraps[0x7b] = rom->ADBReInit;
	mrg_OStraps[0x7c] = rom->ADBOp;
	mrg_OStraps[0x85] = rom->PMgrOp;
	mrg_OStraps[0x51] = rom->ReadXPRam;

	mrg_OStraps[0x38] = rom->WriteParam;	/* WriteParam */
	mrg_OStraps[0x3a] = rom->SetDateTime;	/* SetDateTime */
	mrg_OStraps[0x3f] = rom->InitUtil;	/* InitUtil */
	mrg_OStraps[0x51] = rom->ReadXPRam;	/* ReadXPRam */
	mrg_OStraps[0x52] = rom->WriteXPRam;	/* WriteXPRam */
        jClkNoMem = (void (*)) rom->jClkNoMem;

	if (0 == jClkNoMem) {
		printf("WARNING: don't have a value for jClkNoMem, please contact:  walter@@ghpc8.ihf.rwth-aachen.de\n");
		printf("Can't read RTC without it. Using MacOS boot time.\n");
	}

#if defined(MRG_DEBUG)
	printf("mrg: ROM adbintr 0x%08x\n", mrg_romadbintr);
	printf("mrg: ROM pmintr 0x%08x\n", mrg_rompmintr);
	printf("mrg: OS trap 0x77 (CountADBs) = 0x%08x\n", mrg_OStraps[0x77]);
	printf("mrg: OS trap 0x78 (GetIndADB) = 0x%08x\n", mrg_OStraps[0x78]);
	printf("mrg: OS trap 0x79 (GetADBInfo) = 0x%08x\n", mrg_OStraps[0x79]);
	printf("mrg: OS trap 0x7a (SetADBInfo) = 0x%08x\n", mrg_OStraps[0x7a]);
	printf("mrg: OS trap 0x7b (ADBReInit) = 0x%08x\n", mrg_OStraps[0x7b]);
	printf("mrg: OS trap 0x7c (ADBOp) = 0x%08x\n", mrg_OStraps[0x7c]);
	printf("mrg: OS trap 0x85 (PMgrOp) = 0x%08x\n", mrg_OStraps[0x85]);
	printf("mrg: ROM ADBAltInit 0x%08x\n", mrg_ADBAlternateInit);
	printf("mrg: ROM InitEgret  0x%08x\n", mrg_InitEgret);
#endif
}

d755 1
d757 1
a757 1
	char *findername = "MacBSD FakeFinder";
d759 1
a759 1
	caddr_t *handle;
d762 53
a814 1

d816 1
a816 1
		printf("mrg: '%s' rom glue", mrg_romident);
d850 13
d886 3
a888 3
	Lvl1DT[0] = (void (*)())mrg_1sec_timer_tick;
	Lvl1DT[2] = (void (*)())mrg_romadbintr;
	Lvl1DT[4] = (void (*)())mrg_rompmintr;
d893 2
a894 1
	jADBOp = (void (*)())mrg_OStraps[0x7c];	/* probably very dangerous */
d898 3
d913 1
a913 1
	printf("Result is 0x%x.\n", ptr);
d928 3
a930 3
	printf("Getting a Resource...\n");
	handle = GetResource('ADBS', 2);
	printf("Handle result from GetResource: 0x%x\n", handle);
d957 16
d975 3
a977 1
void
d990 3
a992 1
			: "g" (mrg_InitEgret), "g" (ADBState));
d994 9
a1002 1
	else printf("Help ...  No vector for InitEgret!!");
a1007 2
	int i;

d1035 2
a1036 1
	if ( (HwCfgFlags3 & 0x0e) == 0x06 ) {
d1058 5
a1062 3
#define IS_ROM_ADDR(addr) (   ((u_int) (addr)) > oldbase         \
			   && ((u_int) (addr)) < oldbase + ROMLEN)

d1068 3
a1070 2
	int       i;
	u_int32_t temp, *p, oldbase, newbase;
d1074 118
a1191 10
	for (i=0 ; i<256 ; i++)
		if (IS_ROM_ADDR(mrg_OStraps[i])) {
			temp = (u_int) mrg_OStraps[i];
			temp = (temp - oldbase) + newbase;
			mrg_OStraps[i] = (caddr_t) temp;
		}
	p = (u_int32_t *) mrg_adbstore;
	for (i=0 ; i<512/4 ; i++)
		if (IS_ROM_ADDR(p[i]))
			p[i] = (p[i] - oldbase) + newbase;
d1193 31
a1223 24
	if (IS_ROM_ADDR(jEgret))
		jEgret = (void (*)) ((((u_int) jEgret) - oldbase) + newbase);

	if (IS_ROM_ADDR(mrg_romadbintr))
		mrg_romadbintr = mrg_romadbintr - oldbase + newbase;

	if (IS_ROM_ADDR(mrg_rompmintr))
		mrg_rompmintr = mrg_rompmintr - oldbase + newbase;

	if (IS_ROM_ADDR(mrg_romident))
		mrg_romident = mrg_romident - oldbase + newbase;

	if (IS_ROM_ADDR(jClkNoMem))
		jClkNoMem = jClkNoMem - oldbase + newbase;

	if (IS_ROM_ADDR(mrg_ADBAlternateInit))
		mrg_ADBAlternateInit = mrg_ADBAlternateInit - oldbase + newbase;

	if (IS_ROM_ADDR(mrg_InitEgret))
		mrg_InitEgret = mrg_InitEgret - oldbase + newbase;

	if (IS_ROM_ADDR(ADBReInit_JTBL))
		ADBReInit_JTBL = ADBReInit_JTBL - oldbase + newbase;
}
a1236 1
	
d1238 2
a1239 1
			: "g" (mrg_ADBAlternateInit), "g" (ADBBase) );
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
