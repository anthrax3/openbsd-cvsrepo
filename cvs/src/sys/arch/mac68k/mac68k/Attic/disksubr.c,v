head	1.64;
access;
symbols
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.4
	OPENBSD_5_0:1.63.0.2
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.59.0.4
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.58.0.4
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.55.0.2
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.51.0.4
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.51.0.2
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.19
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.6
	OPENBSD_2_9_BASE:1.13
	NIKLAS_UNDEAD:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.64
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.63;

1.63
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2011.04.06.13.46.50;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.13.15.23.10;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.24.20.52.41;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2009.05.21.23.45.48;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.22.01.06.28;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.12.06.58.35;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.11.12.35.42;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.52;

1.52
date	2008.05.19.18.42.12;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.11.04.53.42;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.20.18.15.45;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.17.15.30.03;	author martin;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.17.00.27.28;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.14.03.35.29;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.12.20.57.42;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.09.23.06.46;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.08.05.34.28;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.07.03.41.52;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.07.00.28.17;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.06.16.42.06;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.05.00.38.16;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.31.22.06.02;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.31.19.57.43;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.31.16.05.50;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.29.05.08.20;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2006.09.24.22.43.00;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.15.20.20.40;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.22.00.40.01;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.30.07.52.32;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.26.22.13.45;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.01.23.03.51;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.17.14.16.04;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.28.14.08.50;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.24.23.43.14;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.10.23.53.22;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.21.23.35.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.18.22.11.41;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.03.15.55;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.11.20.55.30;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.18.21.00.36;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	99.07.17.23.12.08;	author deraadt;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	99.04.19.04.48.02;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	99.01.08.04.29.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.10.03.21.18.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.02.14.07.01.06;	author gene;	state Exp;
branches;
next	1.7;

1.7
date	97.09.08.06.14.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.20.20.57.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.21.46.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.18.36.16;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.14.22;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.04.34.12;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.07;	author deraadt;	state Exp;
branches;
next	;

1.12.4.1
date	2001.04.18.16.10.09;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2002.03.06.01.05.35;	author niklas;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.12.4.5;

1.12.4.5
date	2003.03.27.23.28.44;	author niklas;	state Exp;
branches;
next	1.12.4.6;

1.12.4.6
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.12.4.7;

1.12.4.7
date	2004.06.05.23.10.51;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.64
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: disksubr.c,v 1.63 2011/04/16 03:21:15 krw Exp $	*/
/*	$NetBSD: disksubr.c,v 1.22 1997/11/26 04:18:20 briggs Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* rewritten, 2-5-93 MLF */
/* it's a lot cleaner now, and adding support for new partition types
 * isn't a bitch anymore
 * known bugs:
 * 1) when only an HFS_PART part exists on a drive it gets assigned to "B"
 * this is because of line 623 of sd.c, I think this line should go.
 * 2) /sbin/disklabel expects the whole disk to be in "D", we put it in
 * "C" (I think) and we don't set that position in the disklabel structure
 * as used.  Again, not my fault.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/malloc.h>
#include <sys/syslog.h>

#include <mac68k/mac68k/dpme.h>	/* MF the structure of a mac partition entry */

#define NUM_PARTS_PROBED 32

#define	NO_PART		0
#define ROOT_PART	1
#define UFS_PART	2
#define SWAP_PART	3
#define HFS_PART	4
#define SCRATCH_PART	5

int	getFreeLabelEntry(struct disklabel *);
int	whichType(struct partmapentry *);
int	fixPartTable(struct partmapentry *, long, char *);
void	setPart(struct partmapentry *, struct disklabel *, int, int);
int	getNamedType(struct partmapentry *, int8_t *, int, int, int);
int	read_mac_label(char *, struct disklabel *, int);

/*
 * Find an entry in the disk label that is unused and return it
 * or -1 if no entry
 */
int
getFreeLabelEntry(struct disklabel *lp)
{
	int i;

	for (i = 0; i < MAXPARTITIONS; i++) {
		if (i != RAW_PART && lp->d_partitions[i].p_fstype == FS_UNUSED)
			return i;
	}
	return -1;
}

/*
 * figure out what the type of the given part is and return it
 */
int
whichType(struct partmapentry *part)
{
	struct blockzeroblock *bzb;

	if (part->pmPartType[0] == '\0')
		return NO_PART;

	/*
	 * Do not show MacOS internal use partitions.
	 */
	if (strcmp(PART_DRIVER_TYPE, (char *)part->pmPartType) == 0 ||
	    strcmp(PART_DRIVER43_TYPE, (char *)part->pmPartType) == 0 ||
	    strcmp(PART_DRIVERATA_TYPE, (char *)part->pmPartType) == 0 ||
	    strcmp(PART_FWB_COMPONENT_TYPE, (char *)part->pmPartType) == 0 ||
	    strcmp(PART_PARTMAP_TYPE, (char *)part->pmPartType) == 0)
		return NO_PART;

	if (strcmp(PART_UNIX_TYPE, (char *)part->pmPartType) == 0) {
		/* unix part, swap, root, usr */
		bzb = (struct blockzeroblock *)(&part->pmBootArgs);
		if (bzb->bzbMagic != BZB_MAGIC)
			return NO_PART;

		if (bzb->bzbFlags & BZB_ROOTFS)
			return ROOT_PART;

		if ((bzb->bzbFlags & BZB_USRFS) ||
		    (bzb->bzbFlags & BZB_EXFS4) ||
		    (bzb->bzbFlags & BZB_EXFS5) ||
		    (bzb->bzbFlags & BZB_EXFS6))
			return UFS_PART;

		if (bzb->bzbType == BZB_TYPESWAP)
			return SWAP_PART;
	}
	if (strcmp(PART_MAC_TYPE, (char *)part->pmPartType) == 0)
		return HFS_PART;

	return SCRATCH_PART;	/* no known type, but label it, anyway */
}

/*
 * Take part table in crappy form, place it in a structure we can depend
 * upon.  Make sure names are NUL terminated.  Capitalize the names
 * of part types.
 */
int
fixPartTable(struct partmapentry *partTable, long size, char *base)
{
	struct partmapentry *pmap;
	char *s;
	int i;

	for (i = 0; i < NUM_PARTS_PROBED; i++) {
		pmap = (struct partmapentry *)((i * size) + base + DEV_BSIZE);
		partTable[i] = *pmap;
		pmap = &partTable[i];

		if (pmap->pmSig != DPME_MAGIC) { /* this is not valid */
			pmap->pmPartType[0] = '\0';
			return i;
		}

		pmap->pmPartName[31] = '\0';
		pmap->pmPartType[31] = '\0';

		/* toupper the string, in case caps are different... */
		for (s = pmap->pmPartType; *s; s++)
			if ((*s >= 'a') && (*s <= 'z'))
				*s = (*s - 'a' + 'A');
	}
	return NUM_PARTS_PROBED;
}

void
setPart(struct partmapentry *part, struct disklabel *lp, int fstype, int slot)
{
	DL_SETPSIZE(&lp->d_partitions[slot], part->pmPartBlkCnt);
	DL_SETPOFFSET(&lp->d_partitions[slot], part->pmPyPartStart);
	lp->d_partitions[slot].p_fstype = fstype;
}

int
getNamedType(struct partmapentry *part, int8_t *parttypes, int num_parts,
    int type, int alt)
{
	struct blockzeroblock *bzb;
	int i;

	for (i = 0; i < num_parts; i++) {
		if (parttypes[i] != type)
			continue;

		switch (type) {
		case ROOT_PART:
		case UFS_PART:
			bzb = (struct blockzeroblock *)&part[i].pmBootArgs;
			if (alt >= 0 && alt != bzb->bzbCluster)
				continue;
			break;
		case SWAP_PART:
			break;
		}
		return i;
	}
	return -1;
}

/*
 * read in the entire diskpartition table, it may be bigger or smaller
 * than NUM_PARTS_PROBED but read that many entries.  Each entry has a magic
 * number so we'll know if an entry is crap.
 * next fill in the disklabel with info like this
 * next fill in the root, usr, and swap parts.
 * then look for anything else and fit it in.
 *	A: root
 *	B: Swap
 *	C: Whole disk
 *
 * AKB -- I added to Mike's original algorithm by searching for a bzbCluster
 *	of zero for root, first.  This allows A/UX to live on cluster 1 and
 *	NetBSD to live on cluster 0--regardless of the actual order on the
 *	disk.  This whole algorithm should probably be changed in the future.
 */
int
read_mac_label(char *dlbuf, struct disklabel *lp, int spoofonly)
{
	int i, num_parts;
	int root_part, swap_part, usr_part;
	uint64_t bsdstart, bsdend;
	struct partmapentry *pmap;
	int8_t parttype[NUM_PARTS_PROBED];

	pmap = (struct partmapentry *)malloc(NUM_PARTS_PROBED *
	    sizeof(struct partmapentry), M_DEVBUF, M_NOWAIT);
	if (pmap == NULL)
		return (ENOMEM);

	bsdend = 0;
	bsdstart = DL_GETDSIZE(lp);

	num_parts = fixPartTable(pmap, lp->d_secsize, dlbuf);
	for (i = 0; i < num_parts; i++)
		parttype[i] = whichType(&pmap[i]);

	/*
	 * Find out our /, swap and /usr partitions, preferrably
	 * with a bzbCluster value of zero.
	 */
	root_part = getNamedType(pmap, parttype, num_parts, ROOT_PART, 0);
	if (root_part < 0)
		root_part =
		    getNamedType(pmap, parttype, num_parts, ROOT_PART, -1);
	swap_part = getNamedType(pmap, parttype, num_parts, SWAP_PART, -1);
	usr_part = getNamedType(pmap, parttype, num_parts, UFS_PART, 0);
	if (usr_part < 0)
		usr_part =
		    getNamedType(pmap, parttype, num_parts, UFS_PART, -1);

	/*
	 * Figure out the OpenBSD part of the disk.
	 * Unfortunately, since each OpenBSD partition maps to an A/UX
	 * partition, the OpenBSD area may not be contiguous.
	 * We return the range containing all OpenBSD partitions, and
	 * hope the user will setup the disk with a single contiguous
	 * area...
	 */

	for (i = 0; i < num_parts; i++) {
		switch (parttype[i]) {
		case ROOT_PART:
			/*
			 * If there are multiple A/UX Root partitions,
			 * only count `ours' in the OpenBSD area.
			 */
			if (i != root_part)
				continue;
			break;
		case SWAP_PART:
		case UFS_PART:
			break;
		default:
			continue;
		}

		if (bsdstart > pmap[i].pmPyPartStart)
			bsdstart = pmap[i].pmPyPartStart;
		if (bsdend < pmap[i].pmPyPartStart + pmap[i].pmPartBlkCnt)
			bsdend = pmap[i].pmPyPartStart + pmap[i].pmPartBlkCnt;
	}

	/*
	 * Add all partitions to the disklabel.
	 */

	if (root_part >= 0)
		setPart(&pmap[root_part], lp, FS_BSDFFS, 0);	/* a */
	if (swap_part >= 0)
		setPart(&pmap[swap_part], lp, FS_SWAP, 1);	/* b */
	if (usr_part >= 0)
		setPart(&pmap[usr_part], lp, FS_BSDFFS, 6);	/* g */

	for (i = 0; i < num_parts; i++) {
		int slot, fstype;

		if (i == root_part || i == swap_part || i == usr_part)
			continue;

		if ((slot = getFreeLabelEntry(lp)) < 0)
			break;

		switch (parttype[i]) {
		default:
			fstype = FS_UNUSED;
			break;
		case ROOT_PART:
			fstype = FS_BSDFFS;
			break;
		case UFS_PART:
			fstype = FS_BSDFFS;
			break;
		case SWAP_PART:
			fstype = FS_SWAP;
			break;
		case HFS_PART:
			fstype = FS_HFS;
			break;
		case SCRATCH_PART:
			fstype = FS_OTHER;
			break;
		}
		if (fstype != FS_UNUSED)
			setPart(&pmap[i], lp, fstype, slot);
	}

	free(pmap, M_DEVBUF);

	DL_SETBSTART(lp, bsdstart);
	DL_SETBEND(lp, bsdend < DL_GETDSIZE(lp) ? bsdend : DL_GETDSIZE(lp));

	/*
	 * Clear BSD partitions if spoofing. We had to insert them to be sure
	 * the HFS partitions would appear at the right positions.
	 */
	if (spoofonly) {
		for (i = 0; i < MAXPARTITIONS; i++) {
			switch (lp->d_partitions[i].p_fstype) {
			case FS_BSDFFS:
			case FS_SWAP:	/* XXX maybe unwise */
				lp->d_partitions[i].p_fstype = FS_UNUSED;
				DL_SETPSIZE(&lp->d_partitions[i], 0);
				DL_SETPOFFSET(&lp->d_partitions[i], 0);
				break;
			}
		}

		return (0);
	}

	lp->d_npartitions = MAXPARTITIONS;
	lp->d_version = 1;
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	return (checkdisklabel(lp, lp, bsdstart, bsdend));
}

/*
 * Attempt to read a disk label from a device using the indicated strategy
 * routine.  The label must be partly set up before this: secpercyl and
 * anything required in the strategy routine (e.g., sector size) must be
 * filled in before calling us.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct buf *bp = NULL;
	u_int16_t *sbSigp;
	int size;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;

	size = roundup((NUM_PARTS_PROBED + 1) << DEV_BSHIFT, lp->d_secsize);
	bp = geteblk(size);
	bp->b_dev = dev;

	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = size;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp)) {
		error = bp->b_error;
		goto done;
	}

	sbSigp = (u_int16_t *)bp->b_data;
	if (*sbSigp == 0x4552) {
		error = read_mac_label(bp->b_data, lp, spoofonly);
		if (error == 0)
			goto done;
	}

	if (spoofonly)
		goto doslabel;

	/* Get a MI label */
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp)) {
		error = bp->b_error;
		goto done;
	}

	error = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0,
	    DL_GETDSIZE(lp));
	if (error == 0)
		goto done;

doslabel:
	error = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 *
 * To avoid spreading havoc into the MacOS partition structures, we will
 * refuse to write a disklabel if the media has a MacOS signature.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	struct buf *bp = NULL;
	struct disklabel *dlp;
	int error = 0;
	u_int16_t *sbSigp;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
		goto done;

	/* Check for MacOS fingerprints */
	sbSigp = (u_int16_t *)bp->b_data;
	if (*sbSigp == 0x4552) {
		/* XXX AND THEN DO NOT WRITE?? */
		goto done;
	}

	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
	*dlp = *lp;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}
@


1.63
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.62 2011/04/15 14:57:29 krw Exp $	*/
@


1.62
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.61 2011/04/06 13:46:50 miod Exp $	*/
d413 1
a413 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d434 1
a434 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d492 1
a492 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d507 1
a507 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.61
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.60 2011/02/26 13:07:48 krw Exp $	*/
d413 2
a414 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d434 2
a435 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d492 2
a493 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d507 2
a508 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.60
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.59 2009/08/13 15:23:10 deraadt Exp $	*/
d393 1
a393 2
 * filled in before calling us.  Returns null on success and an error
 * string on failure.
@


1.59
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.58 2009/06/24 20:52:41 miod Exp $	*/
d467 1
d514 1
@


1.58
log
@Compute OpenBSD area bounds as the largest area spanning all the OpenBSD
partitions; since all of them are DPME partitions, they might not be
contiguous but that's the best we can do at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.57 2009/05/21 23:45:48 krw Exp $	*/
d101 1
a101 1
char *read_mac_label(char *, struct disklabel *, int);
d247 1
a247 1
char *
d259 1
a259 1
		return ("out of memory");
d379 1
a379 1
		return (NULL);
d396 1
a396 1
char *
d403 1
a403 1
	char *msg;
d405 1
a405 1
	if ((msg = initdisklabel(lp)))
d417 1
a417 1
		msg = "disk label I/O error";
d423 2
a424 2
		msg = read_mac_label(bp->b_data, lp, spoofonly);
		if (msg == NULL)
d437 1
a437 1
		msg = "disk label I/O error";
d441 3
a443 2
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0, DL_GETDSIZE(lp));
	if (msg == NULL)
d447 2
a448 2
	msg = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d452 2
a453 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a454 1
	}
d457 2
a458 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a459 1
	}
d467 1
a467 1
	return (msg);
@


1.57
log
@The only value that d_npartitions should have is MAXPARTITIONS.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.56 2009/01/22 01:06:28 krw Exp $	*/
d89 1
d96 6
a101 6
int getFreeLabelEntry(struct disklabel *);
int whichType(struct partmapentry *);
int fixPartTable(struct partmapentry *, long, char *);
void setPart(struct partmapentry *, struct disklabel *, int, int);
int getNamedType(struct partmapentry *, int, struct disklabel *, int, int, int *);
char *read_mac_label(char *, struct disklabel *);
d113 1
a113 2
		if (i != RAW_PART &&
		    lp->d_partitions[i].p_fstype == FS_UNUSED)
d128 1
a128 1
		return 0;
d130 3
d138 2
a139 1
		return 0;
d144 1
a144 1
			return 0;
a156 2

		return SCRATCH_PART;
d160 1
a160 4
/*
	if (strcmp(PART_SCRATCH, (char *)part->pmPartType) == 0)
		return SCRATCH_PART;
*/
d189 1
a202 1
	part->pmPartType[0] = '\0';
d206 2
a207 2
getNamedType(struct partmapentry *part, int num_parts, struct disklabel *lp,
    int type, int alt, int *maxslot)
d213 12
a224 28
		if (whichType(&(part[i])) == type) {
			switch (type) {
			case ROOT_PART:
				bzb = (struct blockzeroblock *)
				    (&part[i].pmBootArgs);
				if (alt >= 0 && alt != bzb->bzbCluster)
					goto skip;
				setPart(&(part[i]), lp, FS_BSDFFS, 0);
				break;
			case UFS_PART:
				bzb = (struct blockzeroblock *)
				    (&part[i].pmBootArgs);
				if (alt >= 0 && alt != bzb->bzbCluster)
					goto skip;
				setPart(&(part[i]), lp, FS_BSDFFS, 6);
				if (*maxslot < 6)
					*maxslot = 6;
				break;
			case SWAP_PART:
				setPart(&(part[i]), lp, FS_SWAP, 1);
				if (*maxslot < 1)
					*maxslot = 1;
				break;
			default:
				printf("disksubr.c: can't do type %d\n", type);
				break;
			}
			return 0;
d226 1
a226 1
skip:
d248 1
a248 1
read_mac_label(char *dlbuf, struct disklabel *lp)
d250 3
a252 1
	int i, num_parts, maxslot = RAW_PART;
d254 1
d261 3
d265 60
a324 5
	if (getNamedType(pmap, num_parts, lp, ROOT_PART, 0, &maxslot))
		getNamedType(pmap, num_parts, lp, ROOT_PART, -1, &maxslot);
	getNamedType(pmap, num_parts, lp, SWAP_PART, -1, &maxslot);
	if (getNamedType(pmap, num_parts, lp, UFS_PART, 0, &maxslot))
		getNamedType(pmap, num_parts, lp, UFS_PART, -1, &maxslot);
d326 4
a329 1
		int partType, slot;
d331 1
a331 2
		slot = getFreeLabelEntry(lp);
		if (slot < 0)
d334 4
a337 3
		partType = whichType(&(pmap[i]));

		switch (partType) {
d339 2
d342 1
a342 3
			setPart(&(pmap[i]), lp, FS_BSDFFS, slot);
			if (slot > maxslot)
				maxslot = slot;
d345 1
a345 3
			setPart(&(pmap[i]), lp, FS_SWAP, slot);
			if (slot > maxslot)
				maxslot = slot;
d348 1
a348 3
			setPart(&(pmap[i]), lp, FS_HFS, slot);
			if (slot > maxslot)
				maxslot = slot;
d351 1
a351 5
			setPart(&(pmap[i]), lp, FS_OTHER, slot);
			if (slot > maxslot)
				maxslot = slot;
			break;
		default:
d354 26
d381 1
d386 1
a386 2
	free(pmap, M_DEVBUF);
	return (checkdisklabel(lp, lp));
a411 3
	if (spoofonly)
		goto doslabel;

d423 1
a423 1
		msg = read_mac_label(bp->b_data, lp);
d428 3
d441 1
a441 1
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp);
@


1.56
log
@Call checkdisklabel() for labels built from native info. This will
ensure 'c' always has the correct size as the rest of the kernel
assumes. Thus prevent dd'ing causing a SCSI out-of-bounds error.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.55 2008/06/12 06:58:35 deraadt Exp $	*/
d316 1
a316 1
	lp->d_npartitions = maxslot + 1;
@


1.55
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.53 2008/06/10 20:50:23 beck Exp $	*/
d321 1
a321 1
	return NULL;
@


1.54
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.52 2008/05/19 18:42:12 miod Exp $	*/
d352 1
a352 1
	bp->b_flags = B_BUSY | B_READ;
d369 1
a369 1
	bp->b_flags = B_BUSY | B_READ;
d426 1
a426 1
	bp->b_flags = B_BUSY | B_READ;
d440 1
a440 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.53
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d352 1
a352 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d369 1
a369 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d426 1
a426 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d440 1
a440 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.52
log
@Change all remaining MD uses of MALLOC and FREE into proper malloc() and
free() calls; prodded by chl@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.51 2007/07/11 04:53:42 miod Exp $	*/
d352 1
a352 1
	bp->b_flags = B_BUSY | B_READ;
d369 1
a369 1
	bp->b_flags = B_BUSY | B_READ;
d426 1
a426 1
	bp->b_flags = B_BUSY | B_READ;
d440 1
a440 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.51
log
@Try reading a native label in the first sector, before trying to find
MBR-like partitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.50 2007/06/20 18:15:45 deraadt Exp $	*/
d270 2
a271 2
	MALLOC(pmap, struct partmapentry *,
	    NUM_PARTS_PROBED * sizeof(struct partmapentry), M_DEVBUF, M_NOWAIT);
d320 1
a320 1
	FREE(pmap, M_DEVBUF);
@


1.50
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.49 2007/06/17 15:30:03 martin Exp $	*/
d347 3
a365 4
	msg = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
		goto done;

d377 5
@


1.49
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.48 2007/06/17 00:27:28 deraadt Exp $	*/
d100 1
a100 1
char *read_mac_label(char *, struct disklabel *, struct cpu_disklabel *);
d265 1
a265 1
read_mac_label(char *dlbuf, struct disklabel *lp, struct cpu_disklabel *osdep)
d333 1
a333 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
a349 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
d358 1
a358 1
		msg = read_mac_label(bp->b_data, lp, osdep);
d363 1
a363 1
	msg = readdoslabel(bp, strat, lp, osdep, NULL, NULL, spoofonly);
a370 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
d409 1
a409 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
a422 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
@


1.48
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.47 2007/06/14 03:35:29 deraadt Exp $	*/
d134 1
a134 1
	    strcmp(PART_PARTMAP_TYPE, (char *)part->pmPartType) == 0 ||
@


1.47
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.46 2007/06/14 03:29:34 deraadt Exp $	*/
a30 2
 *
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
d32 1
d89 5
a93 5
#define ROOT_PART 1
#define UFS_PART 2
#define SWAP_PART 3
#define HFS_PART 4
#define SCRATCH_PART 5
d112 2
a113 2
		if ((i != RAW_PART)
		    && (lp->d_partitions[i].p_fstype == FS_UNUSED))
a115 1

d130 5
a134 9
	if (strcmp(PART_DRIVER_TYPE, (char *)part->pmPartType) == 0)
		return 0;
	if (strcmp(PART_DRIVER43_TYPE, (char *)part->pmPartType) == 0)
		return 0;
	if (strcmp(PART_DRIVERATA_TYPE, (char *)part->pmPartType) == 0)
		return 0;
	if (strcmp(PART_FWB_COMPONENT_TYPE, (char *)part->pmPartType) == 0)
		return 0;
	if (strcmp(PART_PARTMAP_TYPE, (char *)part->pmPartType) == 0)
d145 4
a148 4
		if ((bzb->bzbFlags & BZB_USRFS)
		    || (bzb->bzbFlags & BZB_EXFS4)
		    || (bzb->bzbFlags & BZB_EXFS5)
		    || (bzb->bzbFlags & BZB_EXFS6))
a172 1
	int i;
d175 1
a178 1

a193 1

a240 1

a244 1

d282 1
a282 2
		int partType;
		int slot;
a290 1

a291 4
		/*
		 * another root part will turn into a plain old
		 * UFS_PART partition, live with it.
		 */
d317 3
a319 1

a329 5
 *
 * This will read sector zero.  If this contains what looks like a valid
 * Macintosh boot sector, we attempt to fill in the disklabel structure.
 * If the first longword of the disk is a OpenBSD disk label magic number,
 * then we assume that it's a real disklabel and return it.
d336 3
a338 3
	char *msg = NULL;
	struct disklabel *dlp;
	int i, size;
d340 1
a340 21
	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
		goto done;
	}
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
d346 1
d352 1
a352 1
	if (biowait(bp))
d354 13
a366 2
	else {
		u_int16_t *sbSigp;
d368 9
a376 17
		sbSigp = (u_int16_t *)bp->b_data;
		if (*sbSigp == 0x4552) {
			msg = read_mac_label(bp->b_data, lp, osdep);
		} else {
			dlp = (struct disklabel *)(bp->b_data +
			    LABELOFFSET);
			if (dlp->d_magic != DISKMAGIC ||
			    dlp->d_magic2 != DISKMAGIC) {
				msg = "no OpenBSD or MacOS disk label";
			} else if (dlp->d_npartitions > MAXPARTITIONS ||
			    dkcksum(dlp) != 0) {
				msg = "disk label corrupted";
			} else {
				DL_SETDSIZE(dlp, DL_GETDSIZE(lp));
				*lp = *dlp;
			}
		}
d379 4
d384 1
a384 1
	if (msg != NULL && iso_disklabelspoof(dev, strat, lp) == 0)
d386 2
d390 1
a390 1
	if (msg && udf_disklabelspoof(dev, strat, lp) == 0)
d392 2
a400 1
	disklabeltokernlabel(lp);
a415 1
	int labelpart;
d419 1
a419 6
	labelpart = DISKPART(dev);
	if (DL_GETPOFFSET(&lp->d_partitions[labelpart]) != 0) {
		if (DL_GETPOFFSET(&lp->d_partitions[0]) != 0)
			return (EXDEV);	/* not quite right */
		labelpart = 0;
	}
d421 2
a422 1
	bp->b_dev = MAKEDISKDEV(major(dev), DISKUNIT(dev), labelpart);
d431 1
a431 3
	/*
	 * Check for MacOS fingerprints
	 */
d434 1
a434 5
		/*
		 * Read the partition map again, in case it has changed.
		 */
		if (readdisklabel(dev, strat, lp, osdep, 0) != NULL)
			error = EINVAL;
d439 1
a439 1
	bcopy(lp, dlp, sizeof(struct disklabel));
@


1.46
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.45 2007/06/12 20:57:42 deraadt Exp $	*/
d376 1
@


1.45
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.44 2007/06/09 23:06:46 krw Exp $	*/
d373 3
a375 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.44
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.43 2007/06/09 04:08:39 deraadt Exp $	*/
d441 1
a441 1
	struct buf *bp;
d483 4
a486 2
	bp->b_flags |= B_INVAL;
	brelse(bp);
@


1.43
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.42 2007/06/08 05:34:28 deraadt Exp $	*/
a485 56
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
@


1.42
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.41 2007/06/07 03:41:52 krw Exp $	*/
a428 51
}

/*
 * Check new disk label for sensibility before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *osdep)
{
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	while ((i = ffs(openmask)) != 0) {
		i--;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fragblock = opp->p_fragblock;
			npp->p_cpg = opp->p_cpg;
		}
	}
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
@


1.41
log
@Comment 'fixes'. All bounds_check_with_label now identical except for
vax and alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2007/06/07 00:28:17 krw Exp $	*/
d407 1
@


1.40
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.39 2007/06/06 16:42:06 deraadt Exp $	*/
d576 1
a576 2
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
@


1.39
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.38 2007/06/05 00:38:16 deraadt Exp $	*/
d565 1
a565 1
			goto done;
a578 1
#if LABELSECTOR != 0
d580 1
a580 2
#endif /* LABELSECTOR != 0 */
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
a591 1
done:
@


1.38
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37 2007/06/02 02:35:27 krw Exp $	*/
d107 2
a108 3
int 
getFreeLabelEntry(lp)
	struct disklabel *lp;
d124 2
a125 3
int 
whichType(part)
	struct partmapentry *part;
d177 1
a177 4
fixPartTable(partTable, size, base)
	struct partmapentry *partTable;
	long size;
	char *base;
d205 1
a205 1
void 
d214 3
a216 7
int 
getNamedType(part, num_parts, lp, type, alt, maxslot)
	struct partmapentry *part;
	int num_parts;
	struct disklabel *lp;
	int type, alt;
	int *maxslot;
d268 1
a268 1
 * 
d343 1
a343 1
 * string on failure. 
d351 2
a352 6
readdisklabel(dev, strat, lp, osdep, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int spoofonly;
d434 2
a435 4
setdisklabel(olp, nlp, openmask, osdep)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *osdep;
d455 1
a455 1
	while ((i = ffs((long)openmask)) != 0) {
d488 2
a489 5
writedisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
d525 1
a525 1
	
@


1.37
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.36 2007/05/31 22:06:02 krw Exp $	*/
d213 2
a214 2
	lp->d_partitions[slot].p_size = part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset = part->pmPyPartStart;
d375 2
a376 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d383 2
a384 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d386 3
a388 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
d477 2
a478 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
d516 2
a517 2
	if (lp->d_partitions[labelpart].p_offset != 0) {
		if (lp->d_partitions[0].p_offset != 0)
d567 1
a567 1
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
d578 2
a579 2
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
d596 1
a596 1
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsector &&
d598 1
a598 1
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsector &&
d606 1
a606 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.36
log
@Minor bounds_check_with_label nits.

1) Use local variable 'labelsector' not 'labelsect' to be consistant (hp300,
mac68k, mvme68k, mvme88k, vax).

2) Having checked for sz == 0, the next check needs only be sz < 0, not <= 0.
(mac68k, mvme68k, mvme88k)

3) Use lp->d_partitions + DISKPART(dev), rather than
lp->d_partitions[DISKPART(dev)] (hp300).

Assuming no typos there should be no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.35 2007/05/31 19:57:43 krw Exp $	*/
d439 1
a439 1
	cvtdisklabelv1(lp);
@


1.35
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.34 2007/05/31 16:05:50 krw Exp $	*/
d566 1
a566 1
	int labelsect = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
d584 1
a584 1
		if (sz <= 0) {
d595 1
a595 1
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsect &&
d597 1
a597 1
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsect &&
@


1.34
log
@Standardize on -1 as the error return value for
bounds_check_with_label. All callers check for <= 0, so no functional
change.

Feedback from miod@@.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.33 2007/05/29 06:28:15 otto Exp $	*/
d561 2
a562 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
d564 1
a564 1
#define	blockpersec(count, lp)	((count) * (((lp)->d_secsize) / DEV_BSIZE))
d580 1
a580 1
			/* if exactly at end of disk, return an EOF */
d585 1
d589 1
a589 1
		/* or truncate if part of it fits */
@


1.33
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2007/05/29 05:08:20 krw Exp $	*/
d614 1
a614 1
	return (0);
@


1.32
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 2006/09/24 22:43:00 krw Exp $	*/
d439 1
d485 1
a485 2
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
@


1.31
log
@Bring hp300, mac68k and mvme68k disklabel initialization code into
line with all other archs by initializing partitions up to RAWPART the
same way. Should be no functional change.

ok martin@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 2006/08/17 10:34:14 krw Exp $	*/
d367 1
a367 1
	struct buf *bp;
d377 4
a380 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
d392 1
a392 1
		return (NULL);
d434 5
a438 2
	bp->b_flags |= B_INVAL;
	brelse(bp);
@


1.30
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 2006/03/15 20:20:40 miod Exp $	*/
d380 1
a380 1
	for (i = 0; i < MAXPARTITIONS; i++) {
a382 1
		lp->d_partitions[i].p_fstype = FS_UNUSED;
d384 3
a386 1
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
@


1.29
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 2006/01/22 00:40:01 miod Exp $	*/
d378 1
a378 1
		lp->d_secpercyl = 1;
@


1.28
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 2005/03/30 07:52:32 deraadt Exp $	*/
a608 7
}

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
@


1.27
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 2004/12/26 22:13:45 miod Exp $	*/
a87 2
#define	b_cylin	b_resid

d397 1
a397 1
	bp->b_cylin = LABELSECTOR / lp->d_secpercyl;
d519 1
a519 1
	bp->b_cylin = LABELSECTOR / lp->d_secpercyl;
d601 1
a601 1
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.26
log
@If writedisklabel() is invoked on a DPME-labeled disk, read back the DPME
partition table - it might have been modified behind our back.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.25 2004/12/01 23:03:51 miod Exp $	*/
d426 4
@


1.25
log
@Much, much, much less stack pressure when reading a disklabel.

This is a temporary workaround which might live longer than initially expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 2004/03/17 14:16:04 miod Exp $	*/
d387 1
a387 3
	if (lp->d_partitions[RAW_PART].p_size == 0)
		lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_offset = 0;
d527 5
a531 1
		error = ENODEV;
@


1.24
log
@Make sure disklabels use at least DEV_BSIZE as their sector size.
This allows the kernel to survive reading the disklabel off a 256-bytes/sector
scsi device...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 2003/06/02 23:27:49 millert Exp $	*/
d83 1
a287 1
	char *msg = NULL;
d289 6
a294 1
	struct partmapentry pmap[NUM_PARTS_PROBED];
d344 3
a346 1
	return msg;
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 2003/02/28 14:08:50 miod Exp $	*/
d368 1
a368 1
	if (lp->d_secsize == 0)
@


1.22
log
@Fix more evil typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 2003/02/24 23:43:14 miod Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@Hammer the disklabel code once more: a few fixes, lots of simplifications,
read the label and the Apple DPME partition table in one shot (this idea from
NetBSD), and generally make things much safer.

Solves spurious panic while building labels on disks with a large number of
DPME partitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2002/12/10 23:53:22 miod Exp $	*/
d489 1
a489 1
 * To avaid sperading havoc into the MacOS partition structures, we will
a490 1
 * Otherwise, it will be 
@


1.20
log
@achetypal -> archetypal
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 2002/04/21 23:35:33 miod Exp $	*/
d103 2
a104 6
void fixPartTable(struct partmapentry *, long, char *, int *);
void setRoot(struct partmapentry *, struct disklabel *, int);
void setSwap(struct partmapentry *, struct disklabel *, int);
void setUfs(struct partmapentry *, struct disklabel *, int);
void setHfs(struct partmapentry *, struct disklabel *, int);
void setScratch(struct partmapentry *, struct disklabel *, int);
d106 1
a106 2
char *read_mac_label(dev_t, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *);
d116 1
a116 1
	int i = 0;
d183 2
a184 2
void
fixPartTable(partTable, size, base, num)
a187 1
	int *num;
d189 1
a189 1
	int i = 0;
d194 4
a197 1
		pmap = (struct partmapentry *)((i * size) + base);
d201 1
a201 1
			break;
a203 2
		(*num)++;

a209 2

		partTable[i] = *pmap;
a210 11
}

void 
setRoot(part, lp, slot)
	struct partmapentry *part;
	struct disklabel *lp;
	int slot;
{
	lp->d_partitions[slot].p_size = part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset = part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype = FS_BSDFFS;
d212 1
a212 8
#if PRINT_DISKLABELS
	printf("%c: Root '%s' at %d size %d\n", slot + 'a',
	    part->pmPartName,
	    part->pmPyPartStart,
	    part->pmPartBlkCnt);
#endif

	part->pmPartType[0] = '\0';
d216 1
a216 4
setSwap(part, lp, slot)
	struct partmapentry *part;
	struct disklabel *lp;
	int slot;
d220 1
a220 70
	lp->d_partitions[slot].p_fstype = FS_SWAP;

#if PRINT_DISKLABELS
	printf("%c: Swap '%s' at %d size %d\n", slot + 'a',
	    part->pmPartName,
	    part->pmPyPartStart,
	    part->pmPartBlkCnt);
#endif

	part->pmPartType[0] = '\0';
}

void 
setUfs(part, lp, slot)
	struct partmapentry *part;
	struct disklabel *lp;
	int slot;
{
	lp->d_partitions[slot].p_size = part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset = part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype = FS_BSDFFS;

#if PRINT_DISKLABELS
	printf("%c: Usr '%s' at %d size %d\n", slot + 'a',
	    part->pmPartName,
	    part->pmPyPartStart,
	    part->pmPartBlkCnt);
#endif

	part->pmPartType[0] = '\0';
}

void 
setHfs(part, lp, slot)
	struct partmapentry *part;
	struct disklabel *lp;
	int slot;
{
	lp->d_partitions[slot].p_size = part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset = part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype = FS_HFS;

#if PRINT_DISKLABELS
	printf("%c: HFS_PART '%s' at %d size %d\n", slot + 'a',
	    part->pmPartName,
	    part->pmPyPartStart,
	    part->pmPartBlkCnt);
#endif

	part->pmPartType[0] = '\0';
}

void 
setScratch(part, lp, slot)
	struct partmapentry *part;
	struct disklabel *lp;
	int slot;
{
	lp->d_partitions[slot].p_size = part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset = part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype = FS_OTHER;

#if PRINT_DISKLABELS
	printf("%c: Other (%s) '%s' at %d size %d\n", slot + 'a',
	    part->pmPartType,
	    part->pmPartName,
	    part->pmPyPartStart,
	    part->pmPartBlkCnt);
#endif

d233 1
a233 1
	int i = 0;
d243 1
a243 1
				setRoot(&(part[i]), lp, 0);
d250 3
a252 2
				setUfs(&(part[i]), lp, 6);
				if (*maxslot < 6) *maxslot = 6;
d255 3
a257 2
				setSwap(&(part[i]), lp, 1);
				if (*maxslot < 1) *maxslot = 1;
d289 1
a289 5
read_mac_label(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
a290 1
	struct buf *bp;
d292 1
a292 1
	int i = 0, num_parts = 0, maxslot = 0;
d295 1
a295 14
	bp = geteblk((int)lp->d_secsize * NUM_PARTS_PROBED);
	bp->b_dev = dev;
	bp->b_blkno = 1;	/* partition map starts at blk 1 */
	bp->b_bcount = lp->d_secsize * NUM_PARTS_PROBED;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylin = 1 / lp->d_secpercyl;
	(*strat)(bp);
	if (biowait(bp)) {
		msg = "I/O error reading partition map.";
		goto done;
	}

	lp->d_npartitions = 1;	/* one for 'c' */
	fixPartTable(pmap, lp->d_secsize, bp->b_un.b_addr, &num_parts);
d298 1
a300 1
	getNamedType(pmap, num_parts, lp, SWAP_PART, -1, &maxslot);
d319 3
a321 2
			setUfs(&(pmap[i]), lp, slot);
			if (slot > maxslot) maxslot = slot;
d324 3
a326 2
			setSwap(&(pmap[i]), lp, slot);
			if (slot > maxslot) maxslot = slot;
d329 3
a331 2
			setHfs(&(pmap[i]), lp, slot);
			if (slot > maxslot) maxslot = slot;
d334 3
a336 2
			setScratch(&(pmap[i]), lp, slot);
			if (slot > maxslot) maxslot = slot;
d342 1
a342 5
	lp->d_npartitions = maxslot+1;

done:
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
d369 1
a369 1
	int i;
d379 1
a379 1
	for (i = 0; i < RAW_PART; i++) {
d382 1
d392 2
a393 1
	bp = geteblk((int)lp->d_secsize * MAXPARTITIONS);
d396 1
a396 1
	bp->b_bcount = lp->d_secsize;
d405 1
a405 1
		sbSigp = (u_int16_t *)bp->b_un.b_addr;
d407 1
a407 1
			msg = read_mac_label(dev, strat, lp, osdep);
d409 1
a409 1
			dlp = (struct disklabel *)(bp->b_un.b_addr +
d424 1
a424 1
	if (msg && iso_disklabelspoof(dev, strat, lp) == 0)
d428 1
a428 1
	bp->b_flags = B_INVAL | B_AGE;
d525 1
a525 1
	sbSigp = (u_int16_t *)bp->b_un.b_addr;
d531 1
a531 1
	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
d533 1
a533 1
	bp->b_flags = B_WRITE;
d538 1
d557 2
a558 1
	int labelsect = blockpersec(lp->d_partitions[0].p_offset, lp);
a566 21
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= LABELSECTOR + labelsect &&
#if LABELSECTOR != 0
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > LABELSECTOR + labelsect &&
#endif /* LABELSECTOR != 0 */
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}

#if defined(DOSBBSECTOR) && defined(notyet)
	/* overwriting master boot record? */
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <=
	    DOSBBSECTOR + labelsect &&
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}
#endif

d573 1
a573 1
			return (0);
d582 12
d601 2
a602 1
	return (-1);
@


1.19
log
@Change disklabel policy, and allow writing disklabel to any media that does
not carry MacOS fingerprints. Media shared with MacOS will still use the
Apple partition map information, and no native BSD disklabel will be allowed
on it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 2002/04/18 22:11:41 miod Exp $	*/
d484 1
a484 1
	/* minimal requirements for achetypal disk label */
@


1.18
log
@Report explicit failure instead of success and no operation when asked to
write a disklabel. Disklabel on mac68k is virtual and constructed from the
MacOS partition table, that should only be edited from MacOS for safety.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 2002/03/14 03:15:55 millert Exp $	*/
d101 11
a111 11
static int getFreeLabelEntry(struct disklabel *);
static int whichType(struct partmapentry *);
static void fixPartTable(struct partmapentry *, long, char *, int *);
static void setRoot(struct partmapentry *, struct disklabel *, int);
static void setSwap(struct partmapentry *, struct disklabel *, int);
static void setUfs(struct partmapentry *, struct disklabel *, int);
static void setHfs(struct partmapentry *, struct disklabel *, int);
static void setScratch(struct partmapentry *, struct disklabel *, int);
static int getNamedType(struct partmapentry *, int, struct disklabel *, int, int, int *);
static char *read_mac_label(dev_t, void (*)(struct buf *),
		register struct disklabel *, struct cpu_disklabel *);
d117 1
a117 1
static int 
d135 1
a135 1
static int 
d188 1
a188 1
static void
d220 1
a220 1
static void 
d240 1
a240 1
static void 
d260 1
a260 1
static void 
d280 1
a280 1
static void 
d300 1
a300 1
static void 
d321 1
a321 1
static int 
d383 1
a383 1
static char *
d387 1
a387 1
	register struct disklabel *lp;
d395 1
a395 1
	bp = geteblk((int) lp->d_secsize * NUM_PARTS_PROBED);
d468 1
a468 1
 * If the first longword of the disk is a NetBSD disk label magic number,
d475 1
a475 1
	register struct disklabel *lp;
d479 1
a479 1
	register struct buf *bp;
d484 1
d489 2
a490 1

d496 3
a498 2
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
a504 1

a506 1
	bp->b_resid = 0;
d509 1
a509 1
	bp->b_cylin = 0; /* contained in block 0 */
d511 4
a514 4
	if (biowait(bp)) {
		msg = "I/O error reading block zero";
	} else {
		u_int16_t	*sbSigp;
d516 1
a516 1
		sbSigp = (u_int16_t *) bp->b_un.b_addr;
d520 9
a528 2
			dlp = (struct disklabel *)(bp->b_un.b_addr + 0);
			if (dlp->d_magic == DISKMAGIC) {
a529 2
			} else {
				msg = "no disk label--OpenBSD or Macintosh";
d539 1
a539 1
	bp->b_flags = B_INVAL | B_AGE | B_READ;
d549 1
a549 1
	register struct disklabel *olp, *nlp;
d553 13
a565 3
#if 0
	register i;
	register struct partition *opp, *npp;
d570 1
a593 1
#endif /* #if 0 */
d600 3
a602 2
 *  MF - 8-14-93 This function is never called.  It is here just in case
 *  we want to write dos disklabels some day. Really!
d608 1
a608 1
	register struct disklabel *lp;
a610 1
#if 0
d615 1
d627 2
a628 1
	bp->b_flags = B_READ;
d630 9
a638 1
	if (error = biowait(bp))
a639 12
	for (dlp = (struct disklabel *)bp->b_un.b_addr;
	    dlp <= (struct disklabel *)
	    (bp->b_un.b_addr + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic == DISKMAGIC && dlp->d_magic2 == DISKMAGIC &&
		    dkcksum(dlp) == 0) {
			*dlp = *lp;
			bp->b_flags = B_WRITE;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}
d641 7
a647 1
	error = ESRCH;
a650 3
#else
	return (ENODEV);
#endif /* #if 0 */
a726 1
	/* Empty for now. -- XXX */
@


1.17
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 2002/03/14 01:26:35 millert Exp $	*/
a367 2
 * MF --
 * here's what i'm gonna do:
a376 5
 *	G: Usr
 * 
 * 
 * I'm not entirely sure what netbsd386 wants in c & d
 * 386bsd wants other stuff, so i'll leave them alone
d523 1
a523 1
				msg = "no disk label--NetBSD or Macintosh";
d632 1
a632 1
	return 0;
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2001/12/11 20:55:30 miod Exp $	*/
d110 2
a111 2
static char *read_mac_label __P((dev_t, void (*)(struct buf *),
		register struct disklabel *, struct cpu_disklabel *));
@


1.15
log
@mac68k disklabel cleaning 1/3:
Add a bunch of sanity checks and fixes when building disklabels.
Tested by Takeshi Morimoto on various models.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 2001/08/12 12:03:02 heko Exp $	*/
d101 9
a109 10
static int getFreeLabelEntry __P((struct disklabel *));
static int whichType __P((struct partmapentry *));
static void fixPartTable __P((struct partmapentry *, long, char *, int *));
static void setRoot __P((struct partmapentry *, struct disklabel *, int));
static void setSwap __P((struct partmapentry *, struct disklabel *, int));
static void setUfs __P((struct partmapentry *, struct disklabel *, int));
static void setHfs __P((struct partmapentry *, struct disklabel *, int));
static void setScratch __P((struct partmapentry *, struct disklabel *, int));
static int getNamedType
__P((struct partmapentry *, int, struct disklabel *, int, int, int *));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2001/12/11 20:55:30 miod Exp $	*/
d101 12
a112 11
int getFreeLabelEntry(struct disklabel *);
int whichType(struct partmapentry *);
void fixPartTable(struct partmapentry *, long, char *, int *);
void setRoot(struct partmapentry *, struct disklabel *, int);
void setSwap(struct partmapentry *, struct disklabel *, int);
void setUfs(struct partmapentry *, struct disklabel *, int);
void setHfs(struct partmapentry *, struct disklabel *, int);
void setScratch(struct partmapentry *, struct disklabel *, int);
int getNamedType(struct partmapentry *, int, struct disklabel *, int, int, int *);
char *read_mac_label(dev_t, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *);
d118 1
a118 1
int 
d136 1
a136 1
int 
d189 1
a189 1
void
d221 1
a221 1
void 
d241 1
a241 1
void 
d261 1
a261 1
void 
d281 1
a281 1
void 
d301 1
a301 1
void 
d322 1
a322 1
int 
d369 2
d380 5
d391 1
a391 1
char *
d395 1
a395 1
	struct disklabel *lp;
d403 1
a403 1
	bp = geteblk((int)lp->d_secsize * NUM_PARTS_PROBED);
d476 1
a476 1
 * If the first longword of the disk is a OpenBSD disk label magic number,
d483 1
a483 1
	struct disklabel *lp;
d487 1
a487 1
	struct buf *bp;
a491 1
	/* minimal requirements for achetypal disk label */
d496 1
a496 2
	if (lp->d_secpercyl == 0)
		lp->d_secpercyl = 1;
d502 2
a503 3
	if (lp->d_partitions[RAW_PART].p_size == 0)
		lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_offset = 0;
d510 1
d513 1
d516 1
a516 1
	bp->b_cylin = LABELSECTOR / lp->d_secpercyl;
d518 4
a521 4
	if (biowait(bp))
		msg = "disk label I/O error";
	else {
		u_int16_t *sbSigp;
d523 1
a523 1
		sbSigp = (u_int16_t *)bp->b_un.b_addr;
d527 3
a529 8
			dlp = (struct disklabel *)(bp->b_un.b_addr +
			    LABELOFFSET);
			if (dlp->d_magic != DISKMAGIC ||
			    dlp->d_magic2 != DISKMAGIC) {
				msg = "no OpenBSD or MacOS disk label";
			} else if (dlp->d_npartitions > MAXPARTITIONS ||
			    dkcksum(dlp) != 0) {
				msg = "disk label corrupted";
d531 1
a531 1
				*lp = *dlp;
d541 1
a541 1
	bp->b_flags = B_INVAL | B_AGE;
d551 1
a551 1
	struct disklabel *olp, *nlp;
d555 3
a557 13
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}
a561 1

d585 1
d592 2
a593 3
 * To avaid sperading havoc into the MacOS partition structures, we will
 * refuse to write a disklabel if the media has a MacOS signature.
 * Otherwise, it will be 
d599 1
a599 1
	struct disklabel *lp;
d602 1
a606 1
	u_int16_t *sbSigp;
d618 1
a618 2
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylin = LABELSECTOR / lp->d_secpercyl;
d620 1
a620 9
	if ((error = biowait(bp)) != 0)
		goto done;

	/*
	 * Check for MacOS fingerprints
	 */
	sbSigp = (u_int16_t *)bp->b_un.b_addr;
	if (*sbSigp == 0x4552) {
		error = ENODEV;
d622 12
d635 1
a635 7
	
	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
	bcopy(lp, dlp, sizeof(struct disklabel));
	bp->b_flags = B_WRITE;
	(*strat)(bp);
	error = biowait(bp);

d639 3
d718 1
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 6
a108 2
int fixPartTable(struct partmapentry *, long, char *);
void setPart(struct partmapentry *, struct disklabel *, int, int);
d110 2
a111 1
char *read_mac_label(char *, struct disklabel *, struct cpu_disklabel *);
d121 1
a121 1
	int i;
d188 2
a189 2
int
fixPartTable(partTable, size, base)
d193 1
d195 1
a195 1
	int i;
d200 1
a200 4
		pmap = (struct partmapentry *)((i * size) + base + DEV_BSIZE);

		partTable[i] = *pmap;
		pmap = &partTable[i];
d204 1
a204 1
			return i;
d207 2
d215 2
d218 11
d230 8
a237 1
	return NUM_PARTS_PROBED;
d241 4
a244 1
setPart(struct partmapentry *part, struct disklabel *lp, int fstype, int slot)
d248 70
a317 1
	lp->d_partitions[slot].p_fstype = fstype;
d330 1
a330 1
	int i;
d340 1
a340 1
				setPart(&(part[i]), lp, FS_BSDFFS, 0);
d347 2
a348 3
				setPart(&(part[i]), lp, FS_BSDFFS, 6);
				if (*maxslot < 6)
					*maxslot = 6;
d351 2
a352 3
				setPart(&(part[i]), lp, FS_SWAP, 1);
				if (*maxslot < 1)
					*maxslot = 1;
d384 5
a388 1
read_mac_label(char *dlbuf, struct disklabel *lp, struct cpu_disklabel *osdep)
d390 1
d392 1
a392 1
	int i, num_parts, maxslot = RAW_PART;
d395 14
a408 1
	num_parts = fixPartTable(pmap, lp->d_secsize, dlbuf);
a410 1
	getNamedType(pmap, num_parts, lp, SWAP_PART, -1, &maxslot);
d413 1
d432 2
a433 3
			setPart(&(pmap[i]), lp, FS_BSDFFS, slot);
			if (slot > maxslot)
				maxslot = slot;
d436 2
a437 3
			setPart(&(pmap[i]), lp, FS_SWAP, slot);
			if (slot > maxslot)
				maxslot = slot;
d440 2
a441 3
			setPart(&(pmap[i]), lp, FS_HFS, slot);
			if (slot > maxslot)
				maxslot = slot;
d444 2
a445 3
			setPart(&(pmap[i]), lp, FS_OTHER, slot);
			if (slot > maxslot)
				maxslot = slot;
d451 5
a455 1
	lp->d_npartitions = maxslot + 1;
d482 1
a482 1
	int i, size;
d484 1
a484 1
	/* minimal requirements for archetypal disk label */
d492 1
a492 1
	for (i = 0; i < MAXPARTITIONS; i++) {
a494 1
		lp->d_partitions[i].p_fstype = FS_UNUSED;
d504 1
a504 2
	size = roundup((NUM_PARTS_PROBED + 1) << DEV_BSHIFT, lp->d_secsize);
	bp = geteblk(size);
d507 1
a507 1
	bp->b_bcount = size;
d516 1
a516 1
		sbSigp = (u_int16_t *)bp->b_data;
d518 1
a518 1
			msg = read_mac_label(bp->b_data, lp, osdep);
d520 1
a520 1
			dlp = (struct disklabel *)(bp->b_data +
d535 1
a535 1
	if (msg != NULL && iso_disklabelspoof(dev, strat, lp) == 0)
d539 1
a539 1
	bp->b_flags |= B_INVAL;
d600 1
a600 1
 * To avoid spreading havoc into the MacOS partition structures, we will
d602 1
d636 1
a636 1
	sbSigp = (u_int16_t *)bp->b_data;
d642 1
a642 1
	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
d644 1
a644 1
	bp->b_flags = B_BUSY | B_WRITE;
a648 1
	bp->b_flags |= B_INVAL;
d667 1
a667 2
	int labelsect = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
	    LABELSECTOR;
d676 21
d703 1
a703 1
			goto done;
a711 12

	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsect &&
#if LABELSECTOR != 0
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsect &&
#endif /* LABELSECTOR != 0 */
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}

d719 1
a719 2
done:
	return (0);
@


1.14
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 2000/10/18 21:00:36 mickey Exp $	*/
d73 1
a73 1
/* its alot cleaner now, and adding support for new partition types
d490 1
d492 2
d497 7
a503 2
	if (lp->d_secpercyl == 0)
		return (msg = "Zero secpercyl");
d512 1
a512 1
	bp->b_blkno = 0;
d516 1
a516 1
	bp->b_cylin = 1 / lp->d_secpercyl;
d656 1
d658 2
a659 5
#if 0
	int labelsect = lp->d_partitions[0].p_offset;
#endif
	int maxsz = p->p_size;
	int sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d669 1
a669 2
#if 0				/* MF this is crap, especially on swap !! */
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
d671 1
a671 1
	    bp->b_blkno + p->p_offset + sz > LABELSECTOR + labelsect &&
a676 1
#endif /* #if 0 */
d680 2
a681 1
	if (bp->b_blkno + p->p_offset <= DOSBBSECTOR &&
d689 4
a692 3
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
a695 2
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
d700 1
d704 2
a705 1
	bp->b_cylin = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
@


1.13
log
@typo in comment; from gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 1999/07/17 23:12:08 deraadt Exp $	*/
d577 1
a577 1
#endif
d633 1
a633 1
#endif
d667 1
a667 1
#endif
d672 1
a672 1
#endif
@


1.12
log
@do not brelse() badly
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1999/04/19 04:48:02 downsj Exp $	*/
d468 1
a468 1
 * Attempt to read a disk label from a device using the indicated stategy
@


1.12.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 2000/10/18 21:00:36 mickey Exp $	*/
d468 1
a468 1
 * Attempt to read a disk label from a device using the indicated strategy
@


1.12.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12.4.1 2001/04/18 16:10:09 niklas Exp $	*/
d577 1
a577 1
#endif /* #if 0 */
d633 1
a633 1
#endif /* #if 0 */
d667 1
a667 1
#endif /* LABELSECTOR != 0 */
d672 1
a672 1
#endif /* #if 0 */
@


1.12.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 1
a73 1
/* it's a lot cleaner now, and adding support for new partition types
a489 1
	int i;
a490 2
	if (lp->d_secsize == 0)
		lp->d_secsize = DEV_BSIZE;
d494 2
a495 7
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
	}
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
d504 1
a504 1
	bp->b_blkno = LABELSECTOR;
d508 1
a508 1
	bp->b_cylin = 0; /* contained in block 0 */
a647 1
#define	blockpersec(count, lp)	((count) * (((lp)->d_secsize) / DEV_BSIZE))
d649 5
a653 2
	int labelsect = blockpersec(lp->d_partitions[0].p_offset, lp);
	int sz = howmany(bp->b_bcount, DEV_BSIZE);
d663 2
a664 1
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= LABELSECTOR + labelsect &&
d666 1
a666 1
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > LABELSECTOR + labelsect &&
d672 1
d676 1
a676 2
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <=
	    DOSBBSECTOR + labelsect &&
d684 3
a686 4
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
		if (sz == 0) {
			/* if exactly at end of disk, return an EOF */
d690 2
a695 1
		/* or truncate if part of it fits */
d699 1
a699 2
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
	    lp->d_secpercyl;
@


1.12.4.4
log
@Merge in -current from about a week ago
@
text
@d101 12
a112 11
static int getFreeLabelEntry(struct disklabel *);
static int whichType(struct partmapentry *);
static void fixPartTable(struct partmapentry *, long, char *, int *);
static void setRoot(struct partmapentry *, struct disklabel *, int);
static void setSwap(struct partmapentry *, struct disklabel *, int);
static void setUfs(struct partmapentry *, struct disklabel *, int);
static void setHfs(struct partmapentry *, struct disklabel *, int);
static void setScratch(struct partmapentry *, struct disklabel *, int);
static int getNamedType(struct partmapentry *, int, struct disklabel *, int, int, int *);
static char *read_mac_label(dev_t, void (*)(struct buf *),
		register struct disklabel *, struct cpu_disklabel *);
@


1.12.4.5
log
@Sync the SMP branch with 3.3
@
text
@d101 11
a111 6
int getFreeLabelEntry(struct disklabel *);
int whichType(struct partmapentry *);
int fixPartTable(struct partmapentry *, long, char *);
void setPart(struct partmapentry *, struct disklabel *, int, int);
int getNamedType(struct partmapentry *, int, struct disklabel *, int, int, int *);
char *read_mac_label(char *, struct disklabel *, struct cpu_disklabel *);
d117 1
a117 1
int 
d121 1
a121 1
	int i;
d135 1
a135 1
int 
d188 2
a189 2
int
fixPartTable(partTable, size, base)
d193 1
d195 1
a195 1
	int i;
d200 1
a200 4
		pmap = (struct partmapentry *)((i * size) + base + DEV_BSIZE);

		partTable[i] = *pmap;
		pmap = &partTable[i];
d204 1
a204 1
			return i;
d207 2
d215 2
d218 78
d297 1
a297 1
	return NUM_PARTS_PROBED;
d300 5
a304 2
void 
setPart(struct partmapentry *part, struct disklabel *lp, int fstype, int slot)
d308 10
a317 1
	lp->d_partitions[slot].p_fstype = fstype;
d321 1
a321 1
int 
d330 1
a330 1
	int i;
d340 1
a340 1
				setPart(&(part[i]), lp, FS_BSDFFS, 0);
d347 2
a348 3
				setPart(&(part[i]), lp, FS_BSDFFS, 6);
				if (*maxslot < 6)
					*maxslot = 6;
d351 2
a352 3
				setPart(&(part[i]), lp, FS_SWAP, 1);
				if (*maxslot < 1)
					*maxslot = 1;
d368 2
d379 5
d390 6
a395 2
char *
read_mac_label(char *dlbuf, struct disklabel *lp, struct cpu_disklabel *osdep)
d397 1
d399 1
a399 1
	int i, num_parts, maxslot = RAW_PART;
d402 14
a415 1
	num_parts = fixPartTable(pmap, lp->d_secsize, dlbuf);
a417 1
	getNamedType(pmap, num_parts, lp, SWAP_PART, -1, &maxslot);
d420 1
d439 2
a440 3
			setPart(&(pmap[i]), lp, FS_BSDFFS, slot);
			if (slot > maxslot)
				maxslot = slot;
d443 2
a444 3
			setPart(&(pmap[i]), lp, FS_SWAP, slot);
			if (slot > maxslot)
				maxslot = slot;
d447 2
a448 3
			setPart(&(pmap[i]), lp, FS_HFS, slot);
			if (slot > maxslot)
				maxslot = slot;
d451 2
a452 3
			setPart(&(pmap[i]), lp, FS_OTHER, slot);
			if (slot > maxslot)
				maxslot = slot;
d458 5
a462 1
	lp->d_npartitions = maxslot + 1;
d475 1
a475 1
 * If the first longword of the disk is a OpenBSD disk label magic number,
d482 1
a482 1
	struct disklabel *lp;
d486 1
a486 1
	struct buf *bp;
d489 1
a489 1
	int i, size;
a490 1
	/* minimal requirements for archetypal disk label */
d495 1
a495 2
	if (lp->d_secpercyl == 0)
		lp->d_secpercyl = 1;
d497 1
a497 1
	for (i = 0; i < MAXPARTITIONS; i++) {
a499 1
		lp->d_partitions[i].p_fstype = FS_UNUSED;
d501 2
a502 3
	if (lp->d_partitions[RAW_PART].p_size == 0)
		lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_offset = 0;
d508 2
a509 2
	size = roundup((NUM_PARTS_PROBED + 1) << DEV_BSHIFT, lp->d_secsize);
	bp = geteblk(size);
d512 2
a513 1
	bp->b_bcount = size;
d515 1
a515 1
	bp->b_cylin = LABELSECTOR / lp->d_secpercyl;
d517 4
a520 4
	if (biowait(bp))
		msg = "disk label I/O error";
	else {
		u_int16_t *sbSigp;
d522 1
a522 1
		sbSigp = (u_int16_t *)bp->b_data;
d524 1
a524 1
			msg = read_mac_label(bp->b_data, lp, osdep);
d526 3
a528 8
			dlp = (struct disklabel *)(bp->b_data +
			    LABELOFFSET);
			if (dlp->d_magic != DISKMAGIC ||
			    dlp->d_magic2 != DISKMAGIC) {
				msg = "no OpenBSD or MacOS disk label";
			} else if (dlp->d_npartitions > MAXPARTITIONS ||
			    dkcksum(dlp) != 0) {
				msg = "disk label corrupted";
d530 1
a530 1
				*lp = *dlp;
d536 1
a536 1
	if (msg != NULL && iso_disklabelspoof(dev, strat, lp) == 0)
d540 1
a540 1
	bp->b_flags |= B_INVAL;
d550 1
a550 1
	struct disklabel *olp, *nlp;
d554 3
a556 13
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}
a560 1

d584 1
d591 2
a592 2
 * To avoid spreading havoc into the MacOS partition structures, we will
 * refuse to write a disklabel if the media has a MacOS signature.
d598 1
a598 1
	struct disklabel *lp;
d601 1
a605 1
	u_int16_t *sbSigp;
d617 1
a617 2
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylin = LABELSECTOR / lp->d_secpercyl;
d619 1
a619 9
	if ((error = biowait(bp)) != 0)
		goto done;

	/*
	 * Check for MacOS fingerprints
	 */
	sbSigp = (u_int16_t *)bp->b_data;
	if (*sbSigp == 0x4552) {
		error = ENODEV;
d621 12
d634 1
a634 7
	
	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
	bcopy(lp, dlp, sizeof(struct disklabel));
	bp->b_flags = B_BUSY | B_WRITE;
	(*strat)(bp);
	error = biowait(bp);

a635 1
	bp->b_flags |= B_INVAL;
d638 3
d657 1
a657 2
	int labelsect = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
	    LABELSECTOR;
d666 21
d693 1
a693 1
			goto done;
a701 12

	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsect &&
#if LABELSECTOR != 0
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsect &&
#endif /* LABELSECTOR != 0 */
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}

d709 1
a709 2
done:
	return (0);
d717 1
@


1.12.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12.4.5 2003/03/27 23:28:44 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.4.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d368 1
a368 1
	if (lp->d_secsize < DEV_BSIZE)
@


1.11
log
@Consider the other SVR2 partitions as BSDFFS, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1999/01/08 04:29:07 millert Exp $	*/
d494 2
a495 3
	if (lp->d_secpercyl == 0) {
		return msg = "Zero secpercyl";
	}
@


1.10
log
@check for lp->d_secpercyl == 0) in bounds_check_with_label()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1998/10/03 21:18:55 millert Exp $	*/
d164 4
a167 1
		if (bzb->bzbFlags & BZB_USRFS)
@


1.9
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 1998/02/14 07:01:06 gene Exp $	*/
d652 6
@


1.8
log
@Sync from NetBSD:
Add several new partition types.
Process unknown partition types of A/UX type as SCRATCH rather than UNKNOWN.
Hack around the long-standing 8-partition problem by searching the entire
map and filling out the disklabel struct properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 1997/09/08 06:14:50 deraadt Exp $	*/
d477 1
a477 1
readdisklabel(dev, strat, lp, osdep)
d482 1
d494 5
@


1.7
log
@disklabel spoofing code; briggs
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.6 1997/08/20 20:57:32 deraadt Exp $	*/
/*	$NetBSD: disksubr.c,v 1.14 1996/05/05 06:18:22 briggs Exp $	*/
d89 1
a89 1
#include "dpme.h"		/* MF the structure of a mac partition entry */
d147 6
d170 1
a170 1
		return 0;
d197 1
a197 1
	for (i = 0; i < MAXPARTITIONS; i++) {
d369 1
a369 1
 * than MAXPARTITIONS but read that many entries.  Each entry has a magic
@


1.6
log
@add busted cd9660 disklabel spoofing code
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.5 1997/08/08 21:46:45 niklas Exp $	*/
a488 4
i am breaking this code here to ensure that this will not compile until
cd9660 disklabel spoofing is added to the code.


d513 5
@


1.5
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.4 1996/05/26 18:36:16 briggs Exp $	*/
d488 4
@


1.4
log
@Add OpenBSD Id string.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d623 1
a623 1
bounds_check_with_label(bp, lp, wlabel)
d626 1
@


1.3
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.2
log
@Sync. w/ NetBSD
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.13 1996/02/14 14:20:54 briggs Exp $	*/
d84 1
a92 1
static int print = 0;
d100 13
d117 1
a117 1
int 
d135 1
a135 1
int 
d312 1
a312 1
int 
d346 1
a346 1
				printf("disksubr.c: can't do type \n", type);
d381 1
a381 1
char *
d384 1
a384 1
	void (*strat)();
d472 1
a472 1
	void (*strat)();
d567 1
d570 1
a570 1
	void (*strat)();
d628 1
d630 1
d682 1
a682 1
	struct dkdevice *dk;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.10 1995/07/23 21:51:47 briggs Exp $	*/
d73 8
a80 8
isn't a bitch anymore
known bugs:
1) when only an HFS_PART part exists on a drive it gets assigned to "B"
this is because of line 623 of sd.c, I think this line should go.
2) /sbin/disklabel expects the whole disk to be in "D", we put it in
"C" (I think) and we don't set that position in the disklabel structure
as used.  Again, not my fault.
*/
d87 1
a87 1
#include "dpme.h"	/* MF the structure of a mac partition entry */
d91 2
a92 2
static int print=0;
static char *mstr2upper(char *str);
a99 2
int getFreeLabelEntry(struct disklabel *lp)
{
d101 12
a112 9
find an entry in the disk label that is unused and return it
or -1 if no entry
*/
	int i=0;

	for(i=0;i<MAXPARTITIONS;i++)
	{
		if (   (i != RAW_PART)
		    && (lp->d_partitions[i].p_fstype==FS_UNUSED) )
d119 6
a124 1
int whichType(struct partmapentry *part)
d128 2
a129 4
/*
figure out what the type of the given part is and return it
*/
	if (part->pmPartType[0]=='\0') return 0;
d131 8
a138 8
	if (strcmp(PART_DRIVER_TYPE,(char *)part->pmPartType)==0 ) return 0;
	if (strcmp(PART_PARTMAP_TYPE,(char *)part->pmPartType)==0 ) return 0;

	if (strcmp(PART_UNIX_TYPE,(char *)part->pmPartType)==0)
	{
	/* unix part, swap, root, usr */
		bzb= (struct blockzeroblock *)(&part->pmBootArgs);
		if (bzb->bzbMagic!=BZB_MAGIC)
d141 2
a142 1
		if(bzb->bzbFlags & BZB_ROOTFS)	return ROOT_PART;
d144 2
a145 1
		if(bzb->bzbFlags & BZB_USRFS)  return UFS_PART;
d147 2
a148 1
	   if(bzb->bzbType == BZB_TYPESWAP) return SWAP_PART;
d152 2
a153 2
	if (strcmp(PART_MAC_TYPE,(char *)part->pmPartType)==0 ) return HFS_PART;

d155 2
a156 1
	if (strcmp(PART_SCRATCH,(char *)part->pmPartType)==0 ) return SCRATCH_PART;
a157 1

d161 11
a171 3


int fixPartTable(struct partmapentry *partTable,long size,char *base)
d173 1
a173 1
	int i=0;
d175 1
d177 2
a178 5
/*
take part table in crappy form, place it in a structure we can depend
upon.  make sure names are null terminated.  Capitalize the names
of part types.
*/
d180 4
a183 5
	for(i=0;i<MAXPARTITIONS;i++)
	{
		pmap=(struct partmapentry *)((i*size)+base);
		pmap->pmPartName[31]='\0';
		pmap->pmPartType[31]='\0';
d185 1
a185 1
		mstr2upper((char *)pmap->pmPartType);
d187 2
a188 2
		if (pmap->pmSig!=DPME_MAGIC) /* this is not valid */
			pmap->pmPartType[0]='\0';
d190 3
a192 1
		partTable[i]=*pmap;
d194 1
a195 2

	return 0;
d198 9
a206 6

int setRoot(struct partmapentry *part,struct disklabel *lp,int slot)
{
	lp->d_partitions[slot].p_size =part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset=part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype=FS_BSDFFS;
d209 4
a212 4
	printf("%c: Root '%s' at %d size %d\n",slot+'a',
		part->pmPartName,
		part->pmPyPartStart,
		part->pmPartBlkCnt);
d215 1
a215 3
	part->pmPartType[0]='\0';

	return 0;
d218 9
a226 5
int setSwap(struct partmapentry *part,struct disklabel *lp,int slot)
{
	lp->d_partitions[slot].p_size =part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset=part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype=FS_SWAP;
d229 4
a232 4
	printf("%c: Swap '%s' at %d size %d\n",slot+'a',
		part->pmPartName,
		part->pmPyPartStart,
		part->pmPartBlkCnt);
d235 2
a236 1
	part->pmPartType[0]='\0';
d238 9
a246 8
	return 0;
}
					
int setUfs(struct partmapentry *part,struct disklabel *lp,int slot)
{
	lp->d_partitions[slot].p_size =part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset=part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype=FS_BSDFFS;
d249 4
a252 4
	printf("%c: Usr '%s' at %d size %d\n",slot+'a',
		part->pmPartName,
		part->pmPyPartStart,
		part->pmPartBlkCnt);
d255 1
a255 3
	part->pmPartType[0]='\0';

	return 0;
d258 9
a266 5
int setHfs(struct partmapentry *part,struct disklabel *lp,int slot)
{
	lp->d_partitions[slot].p_size =part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset=part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype=FS_HFS;
d269 4
a272 4
	printf("%c: HFS_PART '%s' at %d size %d\n",slot+'a',
		part->pmPartName,
		part->pmPyPartStart,
		part->pmPartBlkCnt);
d275 1
a275 3
	part->pmPartType[0]='\0';

	return 0;
d278 9
a286 5
int setScratch(struct partmapentry *part,struct disklabel *lp,int slot)
{
	lp->d_partitions[slot].p_size =part->pmPartBlkCnt;
	lp->d_partitions[slot].p_offset=part->pmPyPartStart;
	lp->d_partitions[slot].p_fstype=FS_OTHER;
d289 5
a293 5
	printf("%c: Other (%s) '%s' at %d size %d\n",slot+'a',
		part->pmPartType,
		part->pmPartName,
		part->pmPyPartStart,
		part->pmPartBlkCnt);
d296 1
a296 3
	part->pmPartType[0]='\0';

	return 0;
d299 7
a305 1
int getNamedType(struct partmapentry *part,struct disklabel *lp,int type, int alt)
d307 2
a308 2
	struct blockzeroblock	*bzb;
	int			i=0;
d310 25
a334 26
	for(i=0;i<MAXPARTITIONS;i++)
	{
		if (whichType(&(part[i]))==type)
		{
			switch(type)
			{
				case ROOT_PART:
					bzb = (struct blockzeroblock *)
						(&part[i].pmBootArgs);
					if (alt >= 0 && alt != bzb->bzbCluster)
						goto skip;
					setRoot(&(part[i]),lp,0);
					break;
				case UFS_PART:
					bzb = (struct blockzeroblock *)
						(&part[i].pmBootArgs);
					if (alt >= 0 && alt != bzb->bzbCluster)
						goto skip;
					setUfs(&(part[i]),lp,6);
					break;
				case SWAP_PART:
					setSwap(&(part[i]),lp,1);
					break;
				default:
					printf("disksubr.c: can't do type \n",type);
					break;
d346 109
a454 6
 * Attempt to read a disk label from a device
 * using the indicated stategy routine.
 * The label must be partly set up before this:
 * secpercyl and anything required in the strategy routine
 * (e.g., sector size) must be filled in before calling us.
 * Returns null on success and an error string on failure.
d465 1
a465 1
	struct blockzeroblock *bzb;
a466 23
/* MF 
here's what i'm gonna do:
read in the entire diskpartition table, it may be bigger or smaller
than MAXPARTITIONS but read that many entries.  Each entry has a magic
number so we'll know if an entry is crap.
next fill in the disklabel with info like this 
next fill in the root, usr, and swap parts.
Then look for anything else and fit it in
A: root
B: Swap
C: Whole disk
G: Usr


I'm not entirely sure what netbsd386 wants in c &d 
386bsd wants other stuff, so i'll leave them alone 

AKB --	I added to Mike's original algorithm by searching for a bzbCluster
	of zero for root, first.  This allows A/UX to live on cluster 1 and
	NetBSD to live on cluster 0--regardless of the actual order on the
	disk.  This whole algorithm should probably be changed in the future.

*/
d476 3
a478 2
	bp->b_blkno = 1; 	/* pmap starts at block 1 */
	bp->b_bcount = lp->d_secsize * MAXPARTITIONS;
d483 13
a495 46
		msg = "I/O error";
	} 
	else {
		int i=0;
		struct partmapentry pmap[MAXPARTITIONS];

		fixPartTable(pmap,lp->d_secsize,bp->b_un.b_addr);
		if (getNamedType(pmap,lp,ROOT_PART, 0))
			getNamedType(pmap,lp,ROOT_PART, -1);
		if (getNamedType(pmap,lp,UFS_PART, 0))
			getNamedType(pmap,lp,UFS_PART, -1);
		getNamedType(pmap,lp,SWAP_PART, -1);
		for(i=0;i<MAXPARTITIONS;i++)
		{
			int partType;
			int slot;

			slot=getFreeLabelEntry(lp);
			if (slot < 0)
				break;

			partType=whichType(&(pmap[i]));

			switch (partType)
			{

				case ROOT_PART:
/*
another root part will turn into a plain old UFS_PART partition,
live with it.
*/
				case UFS_PART:
					setUfs(&(pmap[i]),lp,slot);
					break;
				case SWAP_PART:
					setSwap(&(pmap[i]),lp,slot);
					break;
				case HFS_PART:
					setHfs(&(pmap[i]),lp,slot);
					break;
				case SCRATCH_PART:
					setScratch(&(pmap[i]),lp,slot);
					break;
				default:
					break;

d500 1
a500 4

	lp->d_npartitions=MAXPARTITIONS;

	bp->b_flags = B_INVAL | B_AGE;
d506 1
a506 2
 * Check new disk label for sensibility
 * before setting it.
d508 1
d541 2
a542 2
 	nlp->d_checksum = 0;
 	nlp->d_checksum = dkcksum(nlp);
a547 5
/* encoding of disk minor numbers, should be elsewhere... */
#define dkunit(dev)		(minor(dev) >> 3)
#define dkpart(dev)		(minor(dev) & 07)
#define dkminor(unit, part)	(((unit) << 3) | (part))

d550 1
a550 1
 * 
d566 1
a566 1
	labelpart = dkpart(dev);
d569 1
a569 1
			return (EXDEV);			/* not quite right */
d573 1
a573 1
	bp->b_dev = makedev(major(dev), dkminor(dkunit(dev), labelpart));
d582 1
a582 1
	      (bp->b_un.b_addr + lp->d_secsize - sizeof(*dlp));
d608 4
a611 1
bounds_check_with_label(struct buf *bp, struct disklabel *lp, int wlabel)
d613 1
a613 1
	struct partition *p = lp->d_partitions + dkpart(bp->b_dev);
d615 2
a616 2
	int maxsz = p->p_size,
		sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d620 2
a621 2
#if 0	/* MF this is crap, especially on swap !! */
        if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
d623 1
a623 1
            bp->b_blkno + p->p_offset + sz > LABELSECTOR + labelsect &&
d625 4
a628 4
            (bp->b_flags & B_READ) == 0 && wlabel == 0) {
                bp->b_error = EROFS;
                goto bad;
        }
d631 1
a631 1
#if	defined(DOSBBSECTOR) && defined(notyet)
d633 5
a637 5
        if (bp->b_blkno + p->p_offset <= DOSBBSECTOR &&
            (bp->b_flags & B_READ) == 0 && wlabel == 0) {
                bp->b_error = EROFS;
                goto bad;
        }
d641 9
a649 9
        if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
                /* if exactly at end of disk, return an EOF */
                if (bp->b_blkno == maxsz) {
                        bp->b_resid = bp->b_bcount;
                        return(0);
                }
                /* or truncate if part of it fits */
                sz = maxsz - bp->b_blkno;
                if (sz <= 0) {
d651 1
a651 1
                        goto bad;
d653 2
a654 3
                bp->b_bcount = sz << DEV_BSHIFT;
        }

d656 2
a657 2
        bp->b_cylin = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
	return(1);
d661 1
a661 21
	return(-1);
}

static int
mtoupper(int c)
{
	if (( c>='a' ) && ( c<='z') )
		return ( c-'a' + 'A' );
	else
		return c;

}

static char *
mstr2upper(char *str)
{
	char *p;

	for(p=str;*p;p++)
		*p=mtoupper(*p);
	return str;
d666 2
a667 2
	struct dkdevice	*dk;
	struct device	*dev;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
