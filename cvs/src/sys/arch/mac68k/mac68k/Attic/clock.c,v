head	1.25;
access;
symbols
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.20
	OPENBSD_5_0:1.24.0.18
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.16
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.14
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.10
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.12
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.8
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.12.0.20
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.18
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.16
	OPENBSD_2_9_BASE:1.12
	NIKLAS_UNDEAD:1.12.0.14
	OPENBSD_2_8:1.12.0.12
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.10
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.8
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.24;

1.24
date	2007.07.14.19.06.48;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.09.26.06.11.42;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.09.17.19.31.04;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.15.00.10.24;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.09.22.59.35;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.02.18.10.07;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.30.01.44.22;	author martin;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.26.21.21.28;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.03.12.10.47;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.24.21.53.11;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.05.22.05.26.43;	author gene;	state Exp;
branches
	1.12.8.1
	1.12.20.1;
next	1.11;

1.11
date	98.02.13.04.35.51;	author gene;	state Exp;
branches;
next	1.10;

1.10
date	97.03.08.16.17.02;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.02.26.06.17.00;	author gene;	state Exp;
branches;
next	1.8;

1.8
date	97.01.24.01.35.44;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.05.26.18.36.14;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.05.26.18.14.20;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.02.34.14;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.02.04.16.40.12;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.02.01.05.11.39;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.04.11.00;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.06;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2003.03.27.23.28.44;	author niklas;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	;

1.12.20.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: clock.c,v 1.24 2007/07/14 19:06:48 miod Exp $	*/
/*	$NetBSD: clock.c,v 1.39 1999/11/05 19:14:56 scottr Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 *
 * from: Utah $Hdr: clock.c 1.18 91/01/21$
 *
 *	@@(#)clock.c   7.6 (Berkeley) 5/7/91
 */

/*
 * Mac II machine-dependent clock routines.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/limits.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <machine/autoconf.h>
#include <machine/psl.h>
#include <machine/cpu.h>

#include <mac68k/mac68k/pram.h>
#include <machine/viareg.h>

#include <dev/clock_subr.h>

#ifdef DEBUG
int	clock_debug = 0;
#endif

int	rtclock_intr(void *);

u_int		clk_interval;
u_int8_t	clk_inth, clk_intl;

#define	DIFF19041970	2082844800

/*
 * The Macintosh timers decrement once every 1.2766 microseconds.
 * MGFH2, p. 180
 */
#define	CLK_RATE	12766

/*
 * Start the real-time clock; i.e. set timer latches and boot timer.
 *
 * We use VIA1 timer 1.
 */
void
startrtclock()
{
#ifndef HZ
	/*
	 * By default, if HZ is not specified, use 60 Hz, unless we are
	 * using A/UX style interrupts. We then need to readjust values
	 * based on a 100Hz value in param.c.
	 */
	if (mac68k_machine.aux_interrupts == 0) {
#define	HZ_60 60
		hz = HZ_60;
		tick = 1000000 / HZ_60;
		tickadj = 240000 / (60 * HZ_60);/* can adjust 240ms in 60s */
	}
#endif

	/*
	 * Calculate clocks needed to hit hz ticks/sec.
	 *
	 * The VIA clock speed is 1.2766us, so the timer value needed is:
	 *
	 *                    1       1,000,000us     1
	 *  CLK_INTERVAL = -------- * ----------- * ------
	 e                 1.2766us       1s          hz
	 *
	 * While it may be tempting to simplify the following further,
	 * we can run into integer overflow problems.
	 * Also note:  do *not* define HZ to be less than 12; overflow
	 * will occur, yielding invalid results.
	 */
	clk_interval = ((100000000UL / hz) * 100) / 12766;
	clk_inth = ((clk_interval >> 8) & 0xff);
	clk_intl = (clk_interval & 0xff);

	/* be certain clock interrupts are off */
	via_reg(VIA1, vIER) = V1IF_T1;

	/* set timer latch */
	via_reg(VIA1, vACR) |= ACR_T1LATCH;

	/* set VIA timer 1 latch to ``hz'' Hz */
	via_reg(VIA1, vT1L) = clk_intl;
	via_reg(VIA1, vT1LH) = clk_inth;

	/* set VIA timer 1 counter started for ``hz'' Hz */
	via_reg(VIA1, vT1C) = clk_intl;
	via_reg(VIA1, vT1CH) = clk_inth;
}

void
cpu_initclocks()
{
	tickfix = 1000000 - (hz * tick);
	if (tickfix != 0) {
		int ftp;

		ftp = min(ffs(tickfix), ffs(hz));
		tickfix >>= (ftp - 1);
		tickfixinterval = hz >> (ftp - 1);
	}

	/* clear then enable clock interrupt. */
	via_reg(VIA1, vIFR) |= V1IF_T1;
	via_reg(VIA1, vIER) = 0x80 | V1IF_T1;
}

void
setstatclockrate(rateinhz)
	int rateinhz;
{
}

/*
 * Returns number of usec since last clock tick/interrupt.
 *
 * Check high byte twice to prevent missing a roll-over.
 * (race condition?)
 */
u_long
clkread()
{
	int high, high2, low;

	high = via_reg(VIA1, vT1CH);
	low = via_reg(VIA1, vT1C);

	high2 = via_reg(VIA1, vT1CH);
	if (high != high2)
		high = high2;

	/* return count left in timer / 1.27 */
	return ((clk_interval - (high << 8) - low) * 10000 / CLK_RATE);
}

static u_long	ugmt_2_pramt(u_long);
static u_long	pramt_2_ugmt(u_long);

/*
 * Convert GMT to Mac PRAM time, using rtc_offset
 * GMT bias adjustment is done elsewhere.
 */
static u_long
ugmt_2_pramt(t)
	u_long t;
{
	/* don't know how to open a file properly. */
	/* assume compiled timezone is correct. */

	return (t + DIFF19041970 - 60 * tz.tz_minuteswest);
}

/*
 * Convert a Mac PRAM time value to GMT, using rtc_offset
 * GMT bias adjustment is done elsewhere.
 */
static u_long
pramt_2_ugmt(t)
	u_long t;
{
	return (t - DIFF19041970 + 60 * tz.tz_minuteswest);
}

/*
 * Time from the booter.
 */
u_long	macos_boottime;

/*
 * Bias in minutes east from GMT (also from booter).
 */
long	macos_gmtbias;

/*
 * Flag for whether or not we can trust the PRAM.  If we don't
 * trust it, we don't write to it, and we take the MacOS value
 * that is passed from the booter (which will only be a second
 * or two off by now).
 */
int	mac68k_trust_pram = 1;

/*
 * Set global GMT time register, using a file system time base for comparison
 * and sanity checking.
 */
void
inittodr(base)
	time_t base;
{
	u_long timbuf;

	timbuf = pram_readtime();
	if (timbuf == 0) {
		/* We don't know how to access PRAM on this hardware. */
		timbuf = macos_boottime;
		mac68k_trust_pram = 0;
	} else {
		timbuf = pramt_2_ugmt(pram_readtime());
		if ((timbuf - (macos_boottime + 60 * tz.tz_minuteswest)) >
		    10 * 60) {
#ifdef DIAGNOSTIC
			printf("PRAM time does not appear"
			    " to have been read correctly.\n");
			printf("PRAM: 0x%lx, macos_boottime: 0x%lx.\n",
			    timbuf, macos_boottime + 60 * tz.tz_minuteswest);
#endif
			timbuf = macos_boottime;
			mac68k_trust_pram = 0;
		}
#ifdef DEBUG
		else
			printf("PRAM: 0x%lx, macos_boottime: 0x%lx.\n",
			    timbuf, macos_boottime);
#endif
	}

	/*
	 * GMT bias is passed in from Booter
	 * To get GMT, *subtract* GMTBIAS from *our* time
	 * (gmtbias is in minutes, mult by 60)
	 */
	timbuf -= macos_gmtbias * 60;

	if (base < 5 * SECYR) {
		printf("WARNING: file system time earlier than 1975\n");
		printf(" -- CHECK AND RESET THE DATE!\n");
		base = 36 * SECYR;	/* Last update here in 2006... */
	}
	if (timbuf < base) {
		printf(
		    "WARNING: Battery clock has earlier time than UNIX fs.\n");
		timbuf = base;
	}
	time.tv_sec = timbuf;
	time.tv_usec = 0;
}

/*
 * Set battery backed clock to a new time, presumably after someone has
 * changed system time.
 */
void
resettodr()
{
	if (mac68k_trust_pram)
		/*
		 * GMT bias is passed in from the Booter.
		 * To get *our* time, add GMTBIAS to GMT.
		 * (gmtbias is in minutes, multiply by 60).
		 */
		pram_settime(ugmt_2_pramt(time.tv_sec + macos_gmtbias * 60));
}

#define	DELAY_CALIBRATE	(0xffffff << 7)	/* Large value for calibration */

u_int		delay_factor = DELAY_CALIBRATE;
volatile int	delay_flag = 1;

int		_delay(u_int);
static int	delay_timer1_irq(void *);

static int
delay_timer1_irq(dummy)
	void *dummy;
{
	delay_flag = 0;
	return (1);
}

/*
 * Calibrate delay_factor with VIA1 timer T1.
 */
void
mac68k_calibrate_delay()
{
	u_int sum, n;

	/* Disable VIA1 timer 1 interrupts and set up service routine */
	via_reg(VIA1, vIER) = V1IF_T1;
	via1_register_irq(VIA1_T1, delay_timer1_irq, NULL, NULL);

	/* Set the timer for one-shot mode, then clear and enable interrupts */
	via_reg(VIA1, vACR) &= ~ACR_T1LATCH;
	via_reg(VIA1, vIFR) = V1IF_T1;	/* (this is needed for IIsi) */
	via_reg(VIA1, vIER) = 0x80 | V1IF_T1;

#ifdef DEBUG
	if (clock_debug)
		printf("mac68k_calibrate_delay(): entering timing loop\n");
#endif

	(void)_spl(IPLTOPSL(mac68k_machine.via1_ipl) - 1);

	for (sum = 0, n = 8; n > 0; n--) {
		delay_flag = 1;
		via_reg(VIA1, vT1C) = 0;	/* 1024 clock ticks */
		via_reg(VIA1, vT1CH) = 4;	/* (approx 1.3 msec) */
		sum += ((delay_factor >> 7) - _delay(1));
	}

	(void)splhigh();

	/* Disable timer interrupts and reset service routine */
	via_reg(VIA1, vIER) = V1IF_T1;
	via1_register_irq(VIA1_T1, rtclock_intr, NULL, NULL);

	/*
	 * If this weren't integer math, the following would look
	 * a lot prettier.  It should really be something like
	 * this:
	 *	delay_factor = ((sum / 8) / (1024 * 1.2766)) * 128;
	 * That is, average the sum, divide by the number of usec,
	 * and multiply by a scale factor of 128.
	 *
	 * We can accomplish the same thing by simplifying and using
	 * shifts, being careful to avoid as much loss of precision
	 * as possible.  (If the sum exceeds UINT_MAX/10000, we need
	 * to rearrange the calculation slightly to do this.)
	 */
	if (sum > (UINT_MAX / 10000))	/* This is a _fast_ machine! */
		delay_factor = (((sum >> 3) * 10000) / CLK_RATE) >> 3;
	else
		delay_factor = (((sum * 10000) >> 3) / CLK_RATE) >> 3;

	/* Reset the delay_flag for normal use */
	delay_flag = 1;

#ifdef DEBUG
	if (clock_debug)
		printf("mac68k_calibrate_delay(): delay_factor calibrated\n");
#endif
}
@


1.24
log
@When calibrating the delay const, only allow clock and above interrupts.

This fixes infrequent hangs on reboot due to the ethernet interface interrupting
on machines configured to use A/UX style interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.23 2006/09/26 06:11:42 miod Exp $	*/
@


1.23
log
@Go back to spl0, previous change broke Cuda adb; reported by Carl
Bloomsburg.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2006/09/17 19:31:04 miod Exp $	*/
d369 1
a369 1
	(void)spl0();
@


1.22
log
@Shorten the area where interrupts are enabled to calibrate delay(), and run
this at splclock() instead of spl0(), so that potential spurious network or
scsi interrupts on machines running in A/UX interrupt mode do not hang there.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.21 2006/01/15 00:10:24 miod Exp $	*/
d369 1
a369 1
	(void)splclock();
@


1.21
log
@Do not put HZ in the kernel configuration file anymore, and let the kernel
decide by itself: Quadra-style machines with A/UX style interrupts and clock
at level 6 will use 100Hz now, while other machines will remain at 60Hz.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2006/01/09 22:59:35 miod Exp $	*/
a354 2
	(void)spl0();

d369 2
d378 2
a408 2

	(void)splhigh();
@


1.20
log
@Spank the clock: remove relics of old GPROF code, compute tickfix for
better clock adjustment, consider clocks past year 2010 as possible, and
do not display the PRAM clock if it consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2006/01/02 18:10:07 miod Exp $	*/
a91 1
#include <mac68k/mac68k/clockreg.h>
d102 3
d121 32
d159 7
a165 7
	/* set VIA timer 1 latch to 60 Hz (100 Hz) */
	via_reg(VIA1, vT1L) = CLK_INTL;
	via_reg(VIA1, vT1LH) = CLK_INTH;

	/* set VIA timer 1 counter started for 60(100) Hz */
	via_reg(VIA1, vT1C) = CLK_INTL;
	via_reg(VIA1, vT1CH) = CLK_INTH;
d210 1
a210 1
	return ((CLK_INTERVAL - (high << 8) - low) * 10000 / CLK_RATE);
@


1.19
log
@Merge enablertclock() in cpu_initclocks(), kill unused disablertclock(), and
remove a wrong comment aboute startrtclock() being invoked twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2004/11/30 01:44:22 martin Exp $	*/
d77 4
a90 4
#if defined(GPROF) && defined(PROFTIMER)
#include <sys/gprof.h>
#endif

d95 2
a103 2
#define	DIFF19701990	630720000
#define	DIFF19702010	1261440000
d106 2
a107 1
 * Mac II machine-dependent clock routines.
d109 1
d137 9
d176 1
a176 101
	/* return((CLK_INTERVAL - (high << 8) - low) / CLK_SPEED); */
	return ((CLK_INTERVAL - (high << 8) - low) * 10000 / 12700);
}


#ifdef PROFTIMER
/*
 * Here, we have implemented code that causes VIA2's timer to count
 * the profiling clock.  Following the HP300's lead, this reduces
 * the impact on other tasks, since locore turns off the profiling clock
 * on context switches.  If need be, the profiling clock's resolution can
 * be cranked higher than the real-time clock's resolution, to prevent
 * aliasing and allow higher accuracy.
 */
int     profint = PRF_INTERVAL;	/* Clock ticks between interrupts */
int     profinthigh;
int     profintlow;
int     profscale = 0;		/* Scale factor from sys clock to prof clock */
char    profon = 0;		/* Is profiling clock on? */

/* profon values - do not change, locore.s assumes these values */
#define	PRF_NONE	0x00
#define	PRF_USER	0x01
#define	PRF_KERNEL	0x80

void
initprofclock()
{
	/* profile interval must be even divisor of system clock interval */
	if (profint > CLK_INTERVAL)
		profint = CLK_INTERVAL;
	else
		if (CLK_INTERVAL % profint != 0)
			/* try to intelligently fix clock interval */
			profint = CLK_INTERVAL / (CLK_INTERVAL / profint);

	profscale = CLK_INTERVAL / profint;

	profinthigh = profint >> 8;
	profintlow = profint & 0xff;
}

void
startprofclock()
{
	via_reg(VIA2, vT1L) = (profint - 1) & 0xff;
	via_reg(VIA2, vT1LH) = (profint - 1) >> 8;
	via_reg(VIA2, vACR) |= ACR_T1LATCH;
	via_reg(VIA2, vT1C) = (profint - 1) & 0xff;
	via_reg(VIA2, vT1CH) = (profint - 1) >> 8;
}

void
stopprofclock()
{
	via_reg(VIA2, vT1L) = 0;
	via_reg(VIA2, vT1LH) = 0;
	via_reg(VIA2, vT1C) = 0;
	via_reg(VIA2, vT1CH) = 0;
}

#ifdef GPROF
/*
 * BARF: we should check this:
 *
 * profclock() is expanded in line in lev6intr() unless profiling kernel.
 * Assumes it is called with clock interrupts blocked.
 */
void
profclock(pclk)
	clockframe *pclk;
{
	/*
	 * Came from user mode.
	 * If this process is being profiled record the tick.
	 */
	if (USERMODE(pclk->ps)) {
		if (p->p_stats.p_prof.pr_scale)
			addupc_task(&curproc, pclk->pc, 1);
	}
	/*
	 * Came from kernel (supervisor) mode.
	 * If we are profiling the kernel, record the tick.
	 */
	else
		if (profiling < 2) {
			int s = pclk->pc - s_lowpc;

			if (s < s_textsize)
				kcount[s / (HISTFRACTION * sizeof(*kcount))]++;
		}
	/*
	 * Kernel profiling was on but has been disabled.
	 * Mark as no longer profiling kernel and if all profiling done,
	 * disable the clock.
	 */
	if (profiling && (profon & PRF_KERNEL)) {
		profon &= ~PRF_KERNEL;
		if (profon == PRF_NONE)
			stopprofclock();
	}
a177 2
#endif
#endif
d193 1
a193 1
	return (t = t + DIFF19041970 - 60 * tz.tz_minuteswest);
d204 1
a204 1
	return (t = t - DIFF19041970 + 60 * tz.tz_minuteswest);
d235 3
a237 8
	timbuf = pramt_2_ugmt(pram_readtime());
	if ((timbuf - (macos_boottime + 60 * tz.tz_minuteswest)) > 10 * 60) {
#ifdef DIAGNOSTIC
		printf(
		    "PRAM time does not appear to have been read correctly.\n");
		printf("PRAM: 0x%lx, macos_boottime: 0x%lx.\n",
		    timbuf, macos_boottime + 60 * tz.tz_minuteswest);
#endif
d240 4
a243 1
	}
d245 4
a248 3
	else
		printf("PRAM: 0x%lx, macos_boottime: 0x%lx.\n",
		    timbuf, macos_boottime);
d250 9
d270 1
a270 10
		base = 21 * SECYR;	/* 1991 is our sane date */
	}
	/*
	 * Check sanity against the year 2010.  Let's hope OpenBSD/mac68k
	 * doesn't run that long!
	 */
	if (base > 40 * SECYR) {
		printf("WARNING: file system time later than 2010\n");
		printf(" -- CHECK AND RESET THE DATE!\n");
		base = 21 * SECYR;	/* 1991 is our sane date */
d275 1
a275 2
		if (((u_long) base) < (40 * SECYR))
			timbuf = base;
a294 5
#ifdef DEBUG
	else if (clock_debug)
		printf("OpenBSD/mac68k does not trust itself to try and write "
		    "to the PRAM on this system.\n");
#endif
a296 7

/*
 * The Macintosh timers decrement once every 1.2766 microseconds.
 * MGFH2, p. 180
 */
#define	CLK_RATE	12766

d310 1
a310 1
	return 1;
@


1.18
log
@provide a more accurate assembly delay() routine

ok miod@@

>From: NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2004/11/26 21:21:28 miod Exp $	*/
a116 4
/*
 * BARF MF startrt clock is called twice in init_main, configure,
 * the reason why is doced in configure
 */
d133 1
a133 1
enablertclock()
a140 6
cpu_initclocks()
{
	enablertclock();
}

void
a143 7
}

void
disablertclock()
{
	/* disable clock interrupt */
	via_reg(VIA1, vIER) = V1IF_T1;
@


1.17
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.16 2004/08/03 12:10:47 todd Exp $	*/
/*	$NetBSD: clock.c,v 1.36 1997/10/07 03:04:55 scottr Exp $	*/
d411 2
a419 1
#define	LARGE_DELAY	0x40000		/* About 335 msec */
d424 1
a424 44
/*
 * delay(usec)
 *	Delay usec microseconds.
 *
 * The delay_factor is scaled up by a factor of 128 to avoid loss
 * of precision for small delays.  As a result of this, note that
 * delays larger that LARGE_DELAY will be up to 128 usec too short,
 * due to adjustments for calculations involving 32 bit values.
 */
void
delay(usec)
	unsigned usec;
{
	volatile unsigned int cycles;

	if (usec > LARGE_DELAY)
		cycles = (usec >> 7) * delay_factor;
	else
		cycles = ((usec > 0 ? usec : 1) * delay_factor) >> 7;

	while ((cycles-- > 0) && delay_flag);
}

static unsigned	dummy_delay(unsigned);
/*
 * Dummy delay calibration.  Functionally identical to delay(), but
 * returns the number of times through the loop.
 */
static unsigned
dummy_delay(usec)
	unsigned usec;
{
	volatile unsigned int cycles;

	if (usec > LARGE_DELAY)
		cycles = (usec >> 7) * delay_factor;
	else
		cycles = ((usec > 0 ? usec : 1) * delay_factor) >> 7;

	while ((cycles-- > 0) && delay_flag);

	return ((delay_factor >> 7) - cycles);
}

d441 3
a443 2
	int n;
	unsigned sum;
d463 1
a463 1
		sum += dummy_delay(1);
d495 2
@


1.16
log
@the rest of the '#if DIAGNOSTIC' -> '#ifdef DIAGNOSTIC' in the kernel; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2003/06/02 23:27:49 millert Exp $	*/
d99 1
a99 1
void	rtclock_intr(void);
d467 1
a467 1
static void	delay_timer1_irq(void *);
d469 1
a469 1
static void
d474 1
d488 1
a488 1
	via1_register_irq(VIA1_T1, delay_timer1_irq, NULL);
d509 1
a509 1
	via1_register_irq(VIA1_T1, (void (*)(void *))rtclock_intr, NULL);
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2002/04/24 21:53:11 espie Exp $	*/
d345 1
a345 1
#if DIAGNOSTIC
@


1.14
log
@Introduce a new file, machine/internal_types.h, to hold that specific arch
type characteristics.

internal_types.h will contain only settings invisible from standard C, e.g.,
in the __* or _[A-Z]* namespace, and be reused by files like limits.h.

This allows us to shorten machine/limits.h greatly, as all the common defines
are now in sys/limits.h, plus a small stub in internal_types.h.

Tested on all arches as far as I know.
Approved after discussion with art, millert, deraadt, and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2002/03/14 01:26:35 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 1998/05/22 05:26:43 gene Exp $	*/
d83 1
a89 1
#include <machine/limits.h>
@


1.12
log
@Delete a NetBSD <-> OpenBSD "oops" from my previous merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 1998/02/13 04:35:51 gene Exp $	*/
d103 1
a103 1
void	rtclock_intr __P((void));
d291 2
a292 2
static u_long	ugmt_2_pramt __P((u_long));
static u_long	pramt_2_ugmt __P((u_long));
d450 1
a450 1
static unsigned	dummy_delay __P((unsigned));
d471 1
a471 1
static void	delay_timer1_irq __P((void *));
@


1.12.20.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 1998/05/22 05:26:43 gene Exp $	*/
a82 1
#include <sys/limits.h>
d89 1
d103 1
a103 1
void	rtclock_intr(void);
d291 2
a292 2
static u_long	ugmt_2_pramt(u_long);
static u_long	pramt_2_ugmt(u_long);
d450 1
a450 1
static unsigned	dummy_delay(unsigned);
d471 1
a471 1
static void	delay_timer1_irq(void *);
@


1.12.8.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a103 1
void	rtclock_intr(void);
d291 2
a292 2
static u_long	ugmt_2_pramt(u_long);
static u_long	pramt_2_ugmt(u_long);
d450 1
a450 1
static unsigned	dummy_delay(unsigned);
d471 1
a471 1
static void	delay_timer1_irq(void *);
@


1.12.8.2
log
@Sync the SMP branch with 3.3
@
text
@a82 1
#include <sys/limits.h>
d89 1
@


1.12.8.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12.8.2 2003/03/27 23:28:44 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11
log
@Sync to NetBSD:
+ Some datatype nits and deprecation of register
+ Implement a much better debug structure that doesn't spam you with
OpenBSD/mac68k doesn't trust itself...
Complete merge minus the rtc_offset stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 1997/03/08 16:17:02 briggs Exp $	*/
d411 1
a411 1
		printf("NetBSD/mac68k does not trust itself to try and write "
@


1.10
log
@Sync with NetBSD of about 4 March.
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.9 1997/02/26 06:17:00 gene Exp $	*/
/*	$NetBSD: clock.c,v 1.33 1997/02/28 07:49:19 scottr Exp $	*/
d95 2
a96 2
#include "pram.h"
#include "clockreg.h"
d99 4
d176 1
a176 1
	register int high, high2, low;
d272 1
a272 1
			register int s = pclk->pc - s_lowpc;
d409 4
a412 4
#if DIAGNOSTIC
	else
		printf("OpenBSD/mac68k does not trust itself to try and write "
		    "to the pram on this system.\n");
d424 1
a424 1
unsigned	delay_factor = DELAY_CALIBRATE;
d440 1
a440 1
	register unsigned int cycles;
d459 1
a459 1
	register unsigned int cycles;
d498 5
d536 2
a537 1
	printf("delay calibrated, factor = %d\n", delay_factor);
@


1.9
log
@Add actual functions to do bus space manipulation.  Modify the
copyright as necessarry, too.

Also, while we're here, do s/NetBSD/Openbsd/ or s/NetBSD/BSD/ ass appropriate.
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.8 1997/01/24 01:35:44 briggs Exp $	*/
/*	$NetBSD: clock.c,v 1.32 1997/01/15 01:28:53 perry Exp $	*/
d99 2
d487 1
a487 1
	mac68k_register_via1_t1_irq(delay_timer1_irq);
d503 1
a503 1
	mac68k_register_via1_t1_irq(NULL);
@


1.8
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 1996/05/26 18:36:14 briggs Exp $	*/
d371 1
a371 1
	 * Check sanity against the year 2010.  Let's hope NetBSD/mac68k
d405 1
a405 1
		printf("NetBSD/mac68k does not trust itself to try and write "
@


1.7
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: clock.c,v 1.29 1996/05/05 06:18:17 briggs Exp $	*/
d289 1
a289 1
 * Convert GMT to Mac PRAM time, using global timezone
d303 1
a303 1
 * Convert a Mac PRAM time value to GMT, using compiled-in timezone
@


1.6
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.5
log
@Sync. w/ NetBSD:
- Make delay() match prototype.
- Be a bit more careful when setting up timer for calibrating delay().
- Clear interrupt before enabling in calibrate_delay()
  (from John P. Wittkoski)
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.22 1996/02/19 21:40:48 scottr Exp $	*/
a79 1
#if !defined(STANDALONE)
d81 1
d83 1
d85 1
d88 1
d94 1
a94 4
#else				/* STANDALONE */
#include "stand.h"
#endif				/* STANDALONE */

d96 1
a96 1
#include "via.h"
d98 3
a100 6
static int month_days[12] = {
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
#define DIFF19041970 2082844800
#define DIFF19701990 630720000
#define DIFF19702010 1261440000
d111 2
a112 2
void 
startrtclock(void)
d114 4
a117 3
/* BARF MF startrt clock is called twice in init_main, configure,
   the reason why is doced in configure */

d134 1
a134 1
enablertclock(void)
d142 1
a142 1
cpu_initclocks(void)
d148 2
a149 1
setstatclockrate(int rateinhz)
d154 1
a154 1
disablertclock(void)
d166 1
a166 1
u_long 
d200 3
a202 3
#define PRF_NONE   0x00
#define   PRF_USER   0x01
#define   PRF_KERNEL   0x80
d204 2
a205 2
void 
initprofclock(void)
d221 2
a222 2
void 
startprofclock(void)
d231 2
a232 2
void 
stopprofclock(void)
d247 3
a249 2
void 
profclock(clockframe * pclk)
d252 3
a254 3
         * Came from user mode.
         * If this process is being profiled record the tick.
         */
d260 3
a262 3
         * Came from kernel (supervisor) mode.
         * If we are profiling the kernel, record the tick.
         */
d271 4
a274 4
         * Kernel profiling was on but has been disabled.
         * Mark as no longer profiling kernel and if all profiling done,
         * disable the clock.
         */
d284 3
d291 3
a293 2
static u_long 
ugmt_2_pramt(u_long t)
d298 1
a298 1
	return (t = t + DIFF19041970 - 60*tz.tz_minuteswest);
d305 3
a307 2
static u_long 
pramt_2_ugmt(u_long t)
d309 1
a309 1
	return (t = t - DIFF19041970 + 60*tz.tz_minuteswest);
d315 1
a315 1
u_long  macos_boottime;
d320 1
a320 1
long    macos_gmtbias;
d328 1
a328 1
int     mac68k_trust_pram = 1;
d334 3
a336 2
void 
inittodr(time_t base)
d338 1
a338 2
	u_long  timbuf;
	u_long  pramtime;
d344 3
a346 3
		   "PRAM time does not appear to have been read correctly.\n");
		printf("PRAM: 0x%x, macos_boottime: 0x%x.\n",
			timbuf, macos_boottime + 60 * tz.tz_minuteswest);
d353 2
a354 2
		printf("PRAM: 0x%x, macos_boottime: 0x%x.\n",
			timbuf, macos_boottime);
d392 2
a393 2
void 
resettodr(void)
a407 1

d417 2
a418 2
int delay_factor = DELAY_CALIBRATE;
volatile int delay_flag = 1;
d430 2
a431 1
delay(unsigned usec)
d440 1
a440 2
	while ((cycles-- > 0) && delay_flag)
		;
d443 1
d448 1
a448 1
static int
d459 1
a459 2
	while ((cycles-- > 0) && delay_flag)
		;
d464 2
d467 2
a468 1
delay_timer1_irq()
d480 1
a480 1
	int sum;
d488 1
a488 1
	via_reg(VIA1, vIFR) = V1IF_T1;		/* (this is needed for IIsi) */
d509 1
a509 1
	 * 
d512 1
a512 1
	 * as possible.  (If the sum exceeds (2^31-1)/10000, we need
d515 1
a515 1
	if (sum > 214748)	/* This is a _fast_ machine! */
@


1.4
log
@New self-calibrating spin-wait delay() from Scott Reynolds <scottr@@edsi.org>.
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.19 1996/02/03 22:49:58 briggs Exp $	*/
d426 1
a426 1
delay(int usec)
d445 1
a445 1
	int usec;
d475 2
d478 4
d491 1
a492 2
	via_reg(VIA1, vT1C) = 0;
	via_reg(VIA1, vT1CH) = 0;
@


1.3
log
@Get rid of some useless intermediate vars and add a register keyword
in delay().  There still seems to be a problem with this routine in that
when we actually touch the VIA1 T2 timer, it seems to hose the ADB
subsystem.
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.17 1996/01/29 04:10:00 briggs Exp $	*/
d81 2
a82 2
#include "param.h"
#include "kernel.h"
d84 2
a85 2
#include "machine/psl.h"
#include "machine/cpu.h"
d88 1
a88 1
#include "sys/gprof.h"
d410 6
d418 1
a418 4
 *	Delay usec microseconds.  This is inaccurate because it
 * assumes that it takes no time to actually execute.  We should
 * try to compensate for this sometime because access to the via
 * is hardly cheap.
d420 4
a423 2
 * It would probably be worthwhile to invent a version of this that
 * didn't depend on the VIA.
d428 6
a433 1
	register int	ticks, t;
d435 13
a447 2
	if (usec <= 0)
		usec = 1;
d449 2
a450 2
	if (usec < 200000)
		ticks = (usec * 10000) / CLK_RATE;
d452 1
a452 1
		ticks = (usec / CLK_RATE) * 10000;
d454 11
a464 2
	while (ticks) {
		t = min(ticks, 65535);
d466 8
a473 2
		via_reg(VIA1, vT2C) = (t & 0xff);
		via_reg(VIA1, vT2CH) = ((t >> 8) & 0xff);
d475 2
a476 2
		while (!(via_reg(VIA1, vIFR) & V1IF_T2))
			;
d478 5
a482 1
		ticks -= t;
d484 30
@


1.2
log
@Fix for delay(usec) for small usec.  From Scott Reynolds <scottr@@edsi.org>.
@
text
@d423 1
a423 2
	int     ticks;
	int     t, timerh, timerl;
d436 2
a437 5
		timerh = (t & 0xff00) >> 8;
		timerl = (t & 0xff);

		via_reg(VIA1, vT2C) = timerl;
		via_reg(VIA1, vT2CH) = timerh;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.16 1995/09/16 12:31:13 briggs Exp $	*/
d417 2
a418 1
 * Paranoia can be removed whenever...  ;-)
d423 1
a423 1
	int     ticks, paranoia = 0x10000000;
d429 4
a432 2
	ticks = usec / CLK_RATE;
	ticks = ticks * 10000;
d443 2
a444 2
		while (!(via_reg(VIA1, vIFR) & V1IF_T2) && paranoia)
			paranoia--;
a447 2
	if (!paranoia)
		printf("paranoia in delay()!!!\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
