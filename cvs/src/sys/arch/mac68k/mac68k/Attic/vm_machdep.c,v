head	1.42;
access;
symbols
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.18
	OPENBSD_5_0:1.41.0.16
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.14
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.12
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.8
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.10
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.6
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.37.0.4
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.4
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.31.0.6
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.31.0.4
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.30
	UBC:1.28.0.2
	UBC_BASE:1.28
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.18.0.6
	OPENBSD_2_9_BASE:1.18
	NIKLAS_UNDEAD:1.18.0.4
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.15.0.6
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.4
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.41;

1.41
date	2007.10.13.07.18.01;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.13.19.38.23;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.24.13.24.21;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.23.13.46.05;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.11.20.48.13;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.25.22.26.16;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.01.21.19.47;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.28.14.04.24;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.27.01.52.13;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.12.07.00.59.16;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.21.02.11.58;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.11.23.21.13;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.04.22.38;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.08.08.09.03;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.08.17.30.41;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.08.22.25.20;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.08.10.23.50;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.05.11.03.00;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.10.10.18.29.22;	author art;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	99.10.09.20.40.03;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	99.09.03.18.01.15;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.08.17.10.32.17;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.01.10.13.34.18;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	98.07.28.00.13.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.03.03.04.30.11;	author ryker;	state Exp;
branches;
next	1.8;

1.8
date	97.03.12.13.29.38;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.10.14.01.28.43;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.05.26.18.36.38;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.05.26.18.14.43;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.02.53.36;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.01.14.21.15.21;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.11.36.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.09;	author deraadt;	state Exp;
branches;
next	;

1.15.4.1
date	2001.04.18.16.10.12;	author niklas;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2001.07.04.10.18.44;	author niklas;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.15.4.4;

1.15.4.4
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.15.4.5;

1.15.4.5
date	2002.03.06.01.05.36;	author niklas;	state Exp;
branches;
next	1.15.4.6;

1.15.4.6
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.15.4.7;

1.15.4.7
date	2003.03.27.23.28.44;	author niklas;	state Exp;
branches;
next	1.15.4.8;

1.15.4.8
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	;

1.28.2.1
date	2002.06.11.03.36.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.42
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.41 2007/10/13 07:18:01 miod Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.29 1998/07/28 18:34:55 thorpej Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * from: Utah $Hdr: vm_machdep.c 1.21 91/04/06$
 *
 *	@@(#)vm_machdep.c	8.6 (Berkeley) 1/12/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/user.h>
#include <sys/vnode.h>
#include <sys/core.h>
#include <sys/exec.h>
#include <sys/ptrace.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/pte.h>
#include <machine/reg.h>

void savectx(struct pcb *);

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.  Returns 1 in the child process, 0 in the parent.
 * We currently double-map the user area so that the stack is at the same
 * address in each process; in the future we will probably relocate
 * the frame pointers on the stack after copying.
 */
void
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
{
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;
	extern struct pcb *curpcb;

	p2->p_md.md_flags = p1->p_md.md_flags;

	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
	*pcb = p1->p_addr->u_pcb;

	/*
	 * Copy the trap frame.
	 */
	tf = (struct trapframe *)((u_int)p2->p_addr + USPACE) -1;
	p2->p_md.md_regs = (int *)tf;
	*tf = *(struct trapframe *)p1->p_md.md_regs;

	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL)
		tf->tf_regs[15] = (u_int)stack + stacksize;

	sf = (struct switchframe *)tf - 1;
	sf->sf_pc = (u_int)proc_trampoline;
	pcb->pcb_regs[6] = (int)func;		/* A2 */
	pcb->pcb_regs[7] = (int)arg;		/* A3 */
	pcb->pcb_regs[11] = (int)sf;		/* SSP */
	pcb->pcb_ps = PSL_LOWIPL;		/* start kthreads at IPL 0 */
}

/*
 * cpu_exit is called as the last action during exit.
 */
void
cpu_exit(p)
	struct proc *p;
{
	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Dump the machine specific segment at the start of a core dump.
 * This means the CPU and FPU registers.  The format used here is
 * the same one ptrace uses, so gdb can be machine independent.
 *
 * XXX - Generate Sun format core dumps for Sun executables?
 */
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	struct md_core md_core;
	struct coreseg cseg;
	int error;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

	if (fputype) {
		/* Save floating point registers. */
		error = process_read_fpregs(p, &md_core.freg);
		if (error)
			return error;
	} else {
		/* Make sure these are clear. */
		bzero((caddr_t)&md_core.freg, sizeof(md_core.freg));
	}

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
	    NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
}

/*
 * Map an IO request into kernel virtual address space.
 *
 * XXX we allocate KVA space by using kmem_alloc_wait which we know
 * allocates space without backing physical memory.  This implementation
 * is a total crock, the multiple mappings of these physical pages should
 * be reflected in the higher-level VM structures to avoid problems.
 */
void
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	struct pmap *upmap, *kpmap;
	vaddr_t uva;	/* User VA (map from) */
	vaddr_t kva;	/* Kernel VA (new to) */
	vaddr_t pa;		/* physical address */
	vsize_t off;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
#endif

	uva = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - uva;
	len = round_page(off + len);
	kva = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(kva + off);

	upmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	kpmap = vm_map_pmap(phys_map);
	do {
		if (pmap_extract(upmap, uva, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		pmap_enter(kpmap, kva, pa, VM_PROT_READ | VM_PROT_WRITE,
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
		uva += PAGE_SIZE;
		kva += PAGE_SIZE;
		len -= PAGE_SIZE;
	} while (len);
	pmap_update(pmap_kernel());
}

/*
 * Free the io map PTEs associated with this IO operation.
 */
void
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	vaddr_t kva;
	vsize_t off;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
#endif

	kva = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - kva;
	len = round_page(off + len);

	pmap_remove(vm_map_pmap(phys_map), kva, kva + len);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, kva, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}
@


1.41
log
@Do not splhigh() before invoking sched_exit(), sched_exit() will do it better.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.40 2007/10/10 15:53:52 art Exp $	*/
@


1.40
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.39 2007/05/27 20:59:25 miod Exp $	*/
a121 3
 *
 * Block context switches and then call switch_exit() which will
 * switch to another process thus we never return.
a126 2
	(void)splhigh();

@


1.39
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.38 2007/03/13 19:38:23 miod Exp $	*/
d122 3
a124 4
 * We release the address space and machine-dependent resources,
 * block context switches and then call switch_exit() which will
 * free our stack and user area and switch to another process.
 * Thus, we never return.
d130 1
d132 2
a133 3
	(void)splhigh();
	switch_exit(p);
	/* NOTREACHED */
@


1.38
log
@Reset psl to spl0 in cpu_fork(), so that kthreads start at spl0 and not
splhigh(); from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.37 2006/06/24 13:24:21 miod Exp $	*/
a196 34
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of PAGE_SIZE.
 */
void
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
{
	paddr_t pa;
	boolean_t rv;

#ifdef DEBUG
	if ((size & PAGE_MASK) != 0)
		panic("pagemove");
#endif
	while (size > 0) {
		rv = pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
#ifdef DEBUG
		if (rv == FALSE)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vaddr_t)to, NULL) == TRUE)
			panic("pagemove 3");
#endif
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ | VM_PROT_WRITE);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
@


1.37
log
@Use pmap_enter_cache() instead of physacc() in bus_mem_add_mapping(), and let
physacc() die. As a bonus, kvtop() dies too.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.36 2006/06/23 13:46:05 mickey Exp $	*/
d117 1
@


1.36
log
@consistantly count context switches on exit; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.35 2006/06/11 20:48:13 miod Exp $	*/
a229 52
}

/*
 * Map `size' bytes of physical memory starting at `paddr' into
 * kernel VA space at `vaddr'.  Read/write and cache-inhibit status
 * are specified by `prot'.
 */ 
void
physaccess(vaddr, paddr, size, prot)
	caddr_t vaddr, paddr;
	int size, prot;
{
	pt_entry_t *pte;
	u_int page;

	pte = kvtopte(vaddr);
	page = (u_int)paddr & PG_FRAME;
	for (size = btoc(size); size; size--) {
		*pte++ = PG_V | prot | page;
		page += NBPG;
	}
	TBIAS();
}

void
physunaccess(vaddr, size)
	caddr_t vaddr;
	int size;
{
	pt_entry_t *pte;

	pte = kvtopte(vaddr);
	for (size = btoc(size); size; size--)
		*pte++ = PG_NV;
	TBIAS();
}

int	kvtop(caddr_t addr);

/*
 * Convert kernel VA to physical address
 */
int
kvtop(addr)
	caddr_t addr;
{
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa) == FALSE)
		panic("kvtop: zero page frame");

	return((int)pa);
@


1.35
log
@Move common prototypes to <m68k/{cpu,param}.h> instead of incomplete
declarations in <machine/{cpu,param}.h> and elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2005/09/25 22:26:16 miod Exp $	*/
a131 1
	uvmexp.swtch++;
@


1.34
log
@Define the symbolic register indexes in trapframe in <m68k/reg.h> only
#ifdef _KERNEL; also remove duplicate prototypes with <sys/ptrace.h>.
Helped by martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2004/12/01 21:19:47 miod Exp $	*/
a117 2

void	switch_exit(struct proc *);
@


1.33
log
@Sync core dumping code with other m68k platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2004/11/28 14:04:24 miod Exp $	*/
d53 1
@


1.32
log
@Correct pmap_enter() flags usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2003/06/02 23:27:49 millert Exp $	*/
a155 1
	int error;
d158 1
a158 2
	struct user *up = p->p_addr;
	int i;
d160 1
a160 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_M68K, 0);
d166 3
a168 2
	{
		struct frame *f;
a169 7
		f = (struct frame*)p->p_md.md_regs;
		for (i = 0; i < 16; i++) {
			md_core.intreg.r_regs[i] = f->f_regs[i];
		}
		md_core.intreg.r_sr = f->f_sr;
		md_core.intreg.r_pc = f->f_pc;
	}
d171 4
a174 10
		struct fpframe *f;

		f = &up->u_pcb.pcb_fpregs;
		m68881_save(f);
		for (i = 0; i < (8*3); i++) {
			md_core.freg.r_regs[i] = f->fpf_regs[i];
		}
		md_core.freg.r_fpcr  = f->fpf_fpcr;
		md_core.freg.r_fpsr  = f->fpf_fpsr;
		md_core.freg.r_fpiar = f->fpf_fpiar;
d176 1
d180 1
a180 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_M68K, CORE_CPU);
d185 2
a186 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d282 1
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2002/04/27 01:52:13 miod Exp $	*/
d333 2
a334 2
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE,
		    PMAP_WIRED);
@


1.30
log
@Lots of cleanup to catch up with other m68k-based ports and modern code,
including:
- use netisr_dispatch
- extract an allocsys() function from cpu_startup()
- updated cachectl()
- a few fixes in trap()
and more...
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2002/03/14 01:26:36 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/12/08 02:24:06 art Exp $	*/
d91 9
a99 2
	/* Sync curpcb (which is presumably p1's PCB) and copy it to p2. */
	savectx(curpcb);
d103 1
a103 2
	 * Copy the trap frame and arrange for the child to return directly
	 * through return_to_user().
a106 1

a116 1

d131 1
a131 1
volatile void
a138 1
	for(;;); /* Get rid of a compile warning */
d210 2
d213 2
a214 4
	if (!error)
		chdr->c_nseg++;

	return error;
d227 2
a228 1
	vm_offset_t pa;
d231 1
a231 1
	if (size % PAGE_SIZE)
d235 1
a235 1
		pmap_extract(pmap_kernel(), (vm_offset_t) from, &pa);
d237 1
a237 2
#if 0
		if (pa == 0)
d239 1
a239 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to, XXX) != 0)
a241 1
#endif
d243 1
a243 1
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
d297 1
a297 1
	if (pmap_extract(pmap_kernel(), (vm_offset_t)addr, &pa) == FALSE)
d313 1
a313 1
	vm_size_t len;
d316 4
a319 4
	vm_offset_t uva;	/* User VA (map from) */
	vm_offset_t kva;	/* Kernel VA (new to) */
	vm_offset_t pa;		/* physical address */
	vm_size_t off;
d321 1
d324 1
d327 1
a327 1
	off = (vm_offset_t)bp->b_data - uva;
d337 2
a338 1
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
d352 1
a352 1
	vm_size_t len;
d354 2
a355 2
	vm_offset_t kva;
	vm_size_t off;
d357 1
d360 1
d363 1
a363 1
	off = (vm_offset_t)bp->b_data - kva;
d366 2
a367 4
	/*
	 * pmap_remove() is unnecessary here, as kmem_free_wakeup()
	 * will do it for us.
	 */
@


1.28
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2001/12/07 00:59:16 miod Exp $	*/
d65 1
a65 1
void savectx __P((struct pcb *));
d118 1
a118 1
void	switch_exit __P((struct proc *));
d284 1
a284 1
int	kvtop __P((caddr_t addr));
@


1.28.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/12/08 02:24:06 art Exp $	*/
d65 1
a65 1
void savectx(struct pcb *);
d91 2
a92 9
	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
d96 2
a97 1
	 * Copy the trap frame.
d101 1
d112 1
d118 1
a118 1
void	switch_exit(struct proc *);
d127 1
a127 1
void
d135 1
a206 2
	if (error)
		return error;
d208 4
a211 2
	chdr->c_nseg++;
	return 0;
d224 1
a224 2
	paddr_t pa;
	boolean_t rv;
d227 1
a227 1
	if ((size & PAGE_MASK) != 0)
d231 1
a231 1
		rv = pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
d233 2
a234 1
		if (rv == FALSE)
d236 1
a236 1
		if (pmap_extract(pmap_kernel(), (vaddr_t)to, NULL) == TRUE)
d239 1
d241 1
a241 1
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ | VM_PROT_WRITE);
d284 1
a284 1
int	kvtop(caddr_t addr);
d295 1
a295 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa) == FALSE)
d311 1
a311 1
	vsize_t len;
d314 4
a317 4
	vaddr_t uva;	/* User VA (map from) */
	vaddr_t kva;	/* Kernel VA (new to) */
	vaddr_t pa;		/* physical address */
	vsize_t off;
a318 1
#ifdef DIAGNOSTIC
a320 1
#endif
d323 1
a323 1
	off = (vaddr_t)bp->b_data - uva;
d333 1
a333 2
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE,
		    PMAP_WIRED);
d347 1
a347 1
	vsize_t len;
d349 2
a350 2
	vaddr_t kva;
	vsize_t off;
a351 1
#ifdef DIAGNOSTIC
a353 1
#endif
d356 1
a356 1
	off = (vaddr_t)bp->b_data - kva;
d359 4
a362 2
	pmap_remove(vm_map_pmap(phys_map), kva, kva + len);
	pmap_update(pmap_kernel());
@


1.27
log
@Ratibibugle setredzone()

[Ratibibugle is local slang for g/c, remove, rototill, etc]
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2001/11/06 19:53:15 miod Exp $	*/
d240 2
a241 5
		pmap_remove(pmap_kernel(),
			   (vm_offset_t)from, (vm_offset_t)from + PAGE_SIZE);
		pmap_enter(pmap_kernel(),
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE,
			   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d246 1
d338 1
@


1.26
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2001/11/06 18:41:10 art Exp $	*/
a283 21
}

void	setredzone __P((void *, caddr_t));

/*
 * Set a red zone in the kernel stack after the u. area.
 * We don't support a redzone right now.  It really isn't clear
 * that it is a good idea since, if the kernel stack were to roll
 * into a write protected page, the processor would lock up (since
 * it cannot create an exception frame) and we would get no useful
 * post-mortem info.  Currently, under the DEBUG option, we just
 * check at every clock interrupt to see if the current k-stack has
 * gone too far (i.e. into the "redzone" page) and if so, panic.
 * Look at _lev6intr in locore.s for more details.
 */
/*ARGSUSED*/
void
setredzone(pte, vaddr)
	void *pte;
	caddr_t vaddr;
{
@


1.25
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2001/09/21 02:11:58 miod Exp $	*/
a56 2

#include <vm/vm.h>
@


1.24
log
@phys_map declaration comes from <vm/vm.h>, no need to declare it locally.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/08/11 23:21:13 art Exp $	*/
d79 1
a79 1
cpu_fork(p1, p2, stack, stacksize)
d83 2
a85 1
	void child_return __P((struct proc *, struct frame)); /* XXX */
d115 2
a116 2
	pcb->pcb_regs[6] = (int)child_return;	/* A2 */
	pcb->pcb_regs[7] = (int)p2;		/* A3 */
a117 25
}

/*
 * cpu_set_kpc
 *	Arrange for in-kernel execution of a process to continue at the
 * named PC as if the code at that address had been called as a function
 * with one argument--the named process's process pointer.
 *
 * Note that it's assumed that whne the named process returns, rei()
 * should be invoked to return to user mode.
 */
void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	struct pcb *pcbp;
	struct switchframe *sf;

	pcbp = &p->p_addr->u_pcb;
	sf = (struct switchframe *)pcbp->pcb_regs[11];
	sf->sf_pc = (u_int)proc_trampoline;
	pcbp->pcb_regs[6] = (int)pc;	/* A2 */
	pcbp->pcb_regs[7] = (int)p;	/* A3 */
@


1.23
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/07/25 13:25:32 art Exp $	*/
a347 2

extern vm_map_t phys_map;
@


1.22
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/06/27 04:22:38 art Exp $	*/
a58 2
#include <vm/vm_kern.h>
#include <vm/vm_map.h>
@


1.21
log
@old vm no more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/06/08 08:09:03 art Exp $	*/
d271 2
a272 2
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1,
			   VM_PROT_READ|VM_PROT_WRITE);
d386 1
a386 1
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
@


1.20
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/05/08 17:30:41 aaron Exp $	*/
a61 1
#if defined(UVM)
a62 1
#endif
a160 1
#if defined(UVM)
a161 3
#else
	cnt.v_swtch++;
#endif
a377 1
#if defined(UVM)
a378 3
#else
	kva = kmem_alloc_wait(phys_map, len);
#endif
a414 1
#if defined(UVM)
a415 3
#else
	kmem_free_wakeup(phys_map, kva, len);
#endif
@


1.19
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2000/06/08 22:25:20 niklas Exp $	*/
d265 1
a265 1
		pa = pmap_extract(pmap_kernel(), (vm_offset_t) from);
d267 1
d270 1
a270 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to) != 0)
d273 1
d350 1
a350 1
	vm_offset_t va;
d352 1
a352 2
	va = pmap_extract(pmap_kernel(), (vm_offset_t)addr);
	if (va == 0)
d354 1
a354 1
	return((int)va);
d394 1
a394 2
		pa = pmap_extract(upmap, uva);
		if (pa == 0)
@


1.18
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.17 2000/06/08 10:23:50 art Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.21 1996/09/16 18:00:31 scottr Exp $	*/
d62 4
d84 1
a84 1
	register struct proc *p1, *p2;
d88 4
a91 3
	register struct pcb *pcb = &p2->p_addr->u_pcb;
	register struct trapframe *tf;
	register struct switchframe *sf;
a99 2
	PMAP_ACTIVATE(p2->p_vmspace->vm_map.pmap, pcb, 0);

d106 1
d142 2
a143 2
	sf = (struct switchframe *) pcbp->pcb_regs[11];
	sf->sf_pc = (u_int) proc_trampoline;
d162 4
a165 1
	(void) splhigh();
d167 1
d194 2
a195 2
	register struct user *up = p->p_addr;
	register int i;
d204 1
a204 1
		register struct frame *f;
d206 1
a206 1
		f = (struct frame*) p->p_md.md_regs;
d214 1
a214 1
		register struct fpframe *f;
d251 1
a251 1
 * and size must be a multiple of CLSIZE.
d255 1
a255 1
	register caddr_t from, to;
d258 1
a258 1
	register vm_offset_t	pa;
d269 1
a269 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t) to) != 0)
d273 1
a273 1
			   (vm_offset_t)from, (vm_offset_t) from + PAGE_SIZE);
a282 2
void	TBIAS __P((void));

d291 1
a291 1
	register int size, prot;
d293 2
a294 2
	register pt_entry_t *pte;
	register u_int page;
a304 2
void	physunaccess __P((caddr_t, register int));

d308 1
a308 1
	register int size;
d310 1
a310 1
	register pt_entry_t *pte;
d339 1
a339 1
int	kvtop __P((register caddr_t addr));
d346 1
a346 1
	register caddr_t addr;
d359 1
a359 2
 * Map an IO request into kernel virtual address space.  Requests fall into
 * one of five catagories:
d361 4
a364 13
 *	B_PHYS|B_UAREA:	User u-area swap.
 *			Address is relative to start of u-area (p_addr).
 *	B_PHYS|B_PAGET:	User page table swap.
 *			Address is a kernel VA in usrpt (Usrptmap).
 *	B_PHYS|B_DIRTY:	Dirty page push.
 *			Address is a VA in proc2's address space.
 *	B_PHYS|B_PGIN:	Kernel pagein of user pages.
 *			Address is VA in user's address space.
 *	B_PHYS:		User "raw" IO request.
 *			Address is VA in user's address space.
 *
 * All requests are (re)mapped into kernel VA space via the useriomap
 * (a name with only slightly more meaning than "kernelmap")
a365 1
/*ARGSUSED*/
d367 9
a375 11
vmapbuf(bp, sz)
	register struct buf *bp;
	vm_size_t sz;
{
	register int npf;
	register caddr_t addr;
	register long flags = bp->b_flags;
	struct proc *p;
	int off;
	vm_offset_t kva;
	register vm_offset_t pa;
d377 1
a377 1
	if ((flags & B_PHYS) == 0)
d379 15
a393 9
	addr = bp->b_saveaddr = bp->b_un.b_addr;
	off = (int)addr & PGOFSET;
	p = bp->b_proc;
	npf = btoc(round_page(bp->b_bcount + off));
	kva = kmem_alloc_wait(phys_map, ctob(npf));
	bp->b_un.b_addr = (caddr_t) (kva + off);
	while (npf--) {
		pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    (vm_offset_t)addr);
d396 2
a397 3
		pmap_enter(vm_map_pmap(phys_map), kva, trunc_page(pa),
			   VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
		addr += PAGE_SIZE;
d399 2
a400 1
	}
a404 1
 * We also invalidate the TLB entries and restore the original b_addr.
a405 1
/*ARGSUSED*/
d407 3
a409 3
vunmapbuf(bp, sz)
	register struct buf *bp;
	vm_size_t sz;
a410 2
	register int npf;
	register caddr_t addr = bp->b_un.b_addr;
d412 1
d416 16
a431 5
	npf = btoc(round_page(bp->b_bcount + ((int)addr & PGOFSET)));
	kva = (vm_offset_t)((int)addr & ~PGOFSET);
	kmem_free_wakeup(phys_map, kva, ctob(npf));
	bp->b_un.b_addr = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
@


1.17
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2000/06/05 11:03:00 art Exp $	*/
d50 1
@


1.16
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 1999/10/10 18:29:22 art Exp $	*/
d94 1
a94 1
	PMAP_ACTIVATE(&p2->p_vmspace->vm_pmap, pcb, 0);
@


1.15
log
@do this the right way
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 1999/10/09 20:40:03 beck Exp $	*/
a155 1
	vmspace_free(p->p_vmspace);
@


1.15.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2000/06/08 22:25:20 niklas Exp $	*/
a49 1
#include <sys/signalvar.h>
d94 1
a94 1
	PMAP_ACTIVATE(p2->p_vmspace->vm_map.pmap, pcb, 0);
d156 1
@


1.15.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vm_machdep.c,v 1.29 1998/07/28 18:34:55 thorpej Exp $	*/
a61 2
#include <uvm/uvm_extern.h>

d80 1
a80 1
	struct proc *p1, *p2;
d84 3
a86 4
	void child_return __P((struct proc *, struct frame)); /* XXX */
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;
d95 2
a102 1

d138 2
a139 2
	sf = (struct switchframe *)pcbp->pcb_regs[11];
	sf->sf_pc = (u_int)proc_trampoline;
d158 2
a159 2
	(void)splhigh();
	uvmexp.swtch++;
d186 2
a187 2
	struct user *up = p->p_addr;
	int i;
d196 1
a196 1
		struct frame *f;
d198 1
a198 1
		f = (struct frame*)p->p_md.md_regs;
d206 1
a206 1
		struct fpframe *f;
d243 1
a243 1
 * and size must be a multiple of PAGE_SIZE.
d247 1
a247 1
	caddr_t from, to;
d250 1
a250 1
	vm_offset_t pa;
d257 1
a257 1
		pmap_extract(pmap_kernel(), (vm_offset_t) from, &pa);
a258 1
#if 0
d261 1
a261 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to, XXX) != 0)
a263 1
#endif
d265 1
a265 1
			   (vm_offset_t)from, (vm_offset_t)from + PAGE_SIZE);
d275 2
d285 1
a285 1
	int size, prot;
d287 2
a288 2
	pt_entry_t *pte;
	u_int page;
d299 2
d304 1
a304 1
	int size;
d306 1
a306 1
	pt_entry_t *pte;
d335 1
a335 1
int	kvtop __P((caddr_t addr));
d342 1
a342 1
	caddr_t addr;
d344 1
a344 1
	paddr_t pa;
d346 2
a347 1
	if (pmap_extract(pmap_kernel(), (vm_offset_t)addr, &pa) == FALSE)
d349 1
a349 1
	return((int)pa);
d355 13
a367 1
 * Map an IO request into kernel virtual address space.
d369 2
a370 4
 * XXX we allocate KVA space by using kmem_alloc_wait which we know
 * allocates space without backing physical memory.  This implementation
 * is a total crock, the multiple mappings of these physical pages should
 * be reflected in the higher-level VM structures to avoid problems.
d372 1
d374 11
a384 9
vmapbuf(bp, len)
	struct buf *bp;
	vm_size_t len;
{
	struct pmap *upmap, *kpmap;
	vm_offset_t uva;	/* User VA (map from) */
	vm_offset_t kva;	/* Kernel VA (new to) */
	vm_offset_t pa;		/* physical address */
	vm_size_t off;
d386 1
a386 1
	if ((bp->b_flags & B_PHYS) == 0)
d388 10
a397 11

	uva = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vm_offset_t)bp->b_data - uva;
	len = round_page(off + len);
	kva = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(kva + off);

	upmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	kpmap = vm_map_pmap(phys_map);
	do {
		if (pmap_extract(upmap, uva, &pa) == FALSE)
d399 3
a401 2
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
		uva += PAGE_SIZE;
d403 1
a403 2
		len -= PAGE_SIZE;
	} while (len);
d408 1
d410 1
d412 3
a414 3
vunmapbuf(bp, len)
	struct buf *bp;
	vm_size_t len;
d416 2
a418 1
	vm_size_t off;
d422 5
a426 12

	kva = trunc_page((vaddr_t)bp->b_data);
	off = (vm_offset_t)bp->b_data - kva;
	len = round_page(off + len);

	/*
	 * pmap_remove() is unnecessary here, as kmem_free_wakeup()
	 * will do it for us.
	 */
	uvm_km_free_wakeup(phys_map, kva, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
@


1.15.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15.4.2 2001/07/04 10:18:44 niklas Exp $	*/
d59 2
d271 2
a272 2
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE,
			   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d351 2
d386 1
a386 1
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
@


1.15.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 2
d79 1
a79 1
cpu_fork(p1, p2, stack, stacksize, func, arg)
a82 2
	void (*func)(void *);
	void *arg;
d84 1
d114 2
a115 2
	pcb->pcb_regs[6] = (int)func;		/* A2 */
	pcb->pcb_regs[7] = (int)arg;		/* A3 */
d117 25
@


1.15.4.5
log
@Merge in trunk
@
text
@d240 5
a244 2
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
a248 1
	pmap_update(pmap_kernel());
d286 21
a360 1
	pmap_update(pmap_kernel());
@


1.15.4.6
log
@Merge in -current from about a week ago
@
text
@d65 1
a65 1
void savectx(struct pcb *);
d118 1
a118 1
void	switch_exit(struct proc *);
d284 1
a284 1
int	kvtop(caddr_t addr);
@


1.15.4.7
log
@Sync the SMP branch with 3.3
@
text
@d91 2
a92 9
	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
d96 2
a97 1
	 * Copy the trap frame.
d101 1
d112 1
d127 1
a127 1
void
d135 1
a206 2
	if (error)
		return error;
d208 4
a211 2
	chdr->c_nseg++;
	return 0;
d224 1
a224 2
	paddr_t pa;
	boolean_t rv;
d227 1
a227 1
	if ((size & PAGE_MASK) != 0)
d231 1
a231 1
		rv = pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
d233 2
a234 1
		if (rv == FALSE)
d236 1
a236 1
		if (pmap_extract(pmap_kernel(), (vaddr_t)to, NULL) == TRUE)
d239 1
d241 1
a241 1
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ | VM_PROT_WRITE);
d295 1
a295 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa) == FALSE)
d311 1
a311 1
	vsize_t len;
d314 4
a317 4
	vaddr_t uva;	/* User VA (map from) */
	vaddr_t kva;	/* Kernel VA (new to) */
	vaddr_t pa;		/* physical address */
	vsize_t off;
a318 1
#ifdef DIAGNOSTIC
a320 1
#endif
d323 1
a323 1
	off = (vaddr_t)bp->b_data - uva;
d333 1
a333 2
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE,
		    PMAP_WIRED);
d347 1
a347 1
	vsize_t len;
d349 2
a350 2
	vaddr_t kva;
	vsize_t off;
a351 1
#ifdef DIAGNOSTIC
a353 1
#endif
d356 1
a356 1
	off = (vaddr_t)bp->b_data - kva;
d359 4
a362 2
	pmap_remove(vm_map_pmap(phys_map), kva, kva + len);
	pmap_update(pmap_kernel());
@


1.15.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15.4.7 2003/03/27 23:28:44 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14
log
@give pmap_enter the right number of args.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 1999/09/03 18:01:15 art Exp $	*/
d400 1
a400 2
			   VM_PROT_READ|VM_PROT_WRITE, TRUE,
			   VM_PROT_READ|VM_PROT_WRITE);
@


1.13
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 1999/08/17 10:32:17 niklas Exp $	*/
d400 2
a401 1
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
@


1.12
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 1999/01/10 13:34:18 niklas Exp $	*/
d267 2
a268 1
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1);
@


1.11
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 1998/07/28 00:13:40 millert Exp $	*/
d78 1
a78 1
cpu_fork(p1, p2)
d80 2
d102 7
a109 1
	*tf = *(struct trapframe *)p1->p_md.md_regs;
@


1.10
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1998/03/03 04:30:11 ryker Exp $	*/
d120 1
a120 1
cpu_set_kpc(p, pc)
d122 2
a123 1
	void (*pc) __P((struct proc *));
@


1.9
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 1997/03/12 13:29:38 briggs Exp $	*/
d217 1
a217 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
d223 1
a223 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
@


1.8
log
@Move prototype for physaccess.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 1996/10/14 01:28:43 briggs Exp $	*/
d178 1
a178 1
	register i;
@


1.7
log
@fpu_type -> fputype, use m68k/cpu.h--from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 1996/05/26 18:36:38 briggs Exp $	*/
a264 1
void	physaccess __P((caddr_t, caddr_t, register int, register int));
@


1.6
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vm_machdep.c,v 1.20 1996/05/05 16:50:34 briggs Exp $	*/
a65 2
extern int fpu_type;

d196 1
a196 1
	if (fpu_type) {
@


1.5
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.4
log
@Sync. w/ NetBSD: vm prototype changes.
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.16 1996/02/05 02:10:00 christos Exp $	*/
d67 2
a85 1
	extern void proc_trampoline(), child_return();
d122 2
a123 2
	struct proc	*p;
	u_int32_t	pc;
a126 1
	extern void proc_trampoline();
d131 1
a131 1
	pcbp->pcb_regs[6] = pc;		/* A2 */
d135 2
d237 1
d240 1
a240 1
	int size;
d266 3
d274 1
d291 3
d306 2
d320 1
d322 1
a322 1
	struct pte *pte;
d327 2
d332 1
@


1.3
log
@from netbsd: more of PR 1931.  Fix code that's not compiled unless DEBUG.
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.15 1996/01/12 04:16:59 briggs Exp $	*/
d348 3
a350 1
vmapbuf(bp)
d352 1
d386 3
a388 1
vunmapbuf(bp)
d390 1
@


1.2
log
@update from netbsd (without losing local changes)
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.14 1995/12/09 04:37:48 mycroft Exp $	*/
d242 1
a242 1
	if (size & CLOFFSET)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.13 1995/06/21 03:45:10 briggs Exp $	*/
d76 1
a76 1
int
a107 2

	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

