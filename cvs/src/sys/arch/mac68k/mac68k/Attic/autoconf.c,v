head	1.34;
access;
symbols
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.8
	OPENBSD_5_0:1.33.0.6
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.11.0.18
	OPENBSD_2_9_BASE:1.11
	NIKLAS_UNDEAD:1.11.0.16
	OPENBSD_2_8:1.11.0.14
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.12
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.10
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.33;

1.33
date	2010.07.01.03.20.37;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.17.13.06.57;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.19.21.58.53;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.18.23.21.17;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.13.19.36.45;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.27.18.31.09;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.01.14.49.55;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.11.19.41.10;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.25.01.45.12;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.21.23.35.52;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.25.00.43.12;	author mickey;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.05.08.17.30.40;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.05.22.33.52;	author art;	state Exp;
branches;
next	1.11;

1.11
date	97.11.28.21.09.54;	author gene;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	97.01.24.01.35.43;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.01.01.14.59.46;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	96.06.23.15.59.42;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.05.26.18.36.13;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.05.26.18.14.19;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.04.45.54;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.20.20.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.09.16.14.28;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.11.36.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.06;	author deraadt;	state Exp;
branches;
next	;

1.11.10.1
date	2001.07.04.10.18.35;	author niklas;	state Exp;
branches;
next	1.11.10.2;

1.11.10.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.11.10.3;

1.11.10.3
date	2003.03.27.23.28.44;	author niklas;	state Exp;
branches;
next	1.11.10.4;

1.11.10.4
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.11.10.5;

1.11.10.5
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: autoconf.c,v 1.33 2010/07/01 03:20:37 matthew Exp $	*/
/*	$NetBSD: autoconf.c,v 1.38 1996/12/18 05:46:09 scottr Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	8.4 (Berkeley) 10/1/93
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/disk.h>

#include <dev/cons.h>

#include <machine/autoconf.h>
#include <machine/viareg.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

int target_to_unit(u_long, u_long, u_long);
void	findbootdev(void);

struct device	*booted_device;
int		booted_partition;
dev_t		bootdev;

/*
 * Yanked from i386/i386/autoconf.c (and tweaked a bit)
 */
void
findbootdev()
{
	struct device *dv;
	int major, unit;

	booted_device = NULL;
	booted_partition = 0;	/* Assume root is on partition a */

	major = B_TYPE(bootdev);
	if (major < 0 || major >= nblkdev)
		return;

	unit = B_UNIT(bootdev);

	bootdev &= ~(B_UNITMASK << B_UNITSHIFT);
	unit = target_to_unit(-1, unit, 0);
	bootdev |= (unit << B_UNITSHIFT);

	if (disk_count <= 0)
		return;

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK && major == findblkmajor(dv) &&
		    unit == dv->dv_unit) {
			booted_device = dv;
			return;
		}
	}
}

void
cpu_configure()
{
	/* this couldn't be done in intr_init() because this uses malloc() */
	softintr_init();

	startrtclock();

	if (config_rootfound("mainbus", "mainbus") == NULL)
		panic("No mainbus found!");
	spl0();

	findbootdev();
	cold = 0;
}

void
device_register(struct device *dev, void *aux)
{
}

void
diskconf(void)
{
	setroot(booted_device, booted_partition, RB_USERREQ);
	dumpconf();
}

/*
 * Map a SCSI bus, target, lun to a device number.
 * This could be tape, disk, CD.  The calling routine, though,
 * assumes DISK.  It would be nice to allow CD, too...
 */
int
target_to_unit(bus, target, lun)
	u_long bus, target, lun;
{
	struct scsibus_softc	*scsi;
	struct scsi_link	*sc_link;
	struct device		*sc_dev;
	extern	struct cfdriver		scsibus_cd;

	if (target < 0 || target > 7 || lun < 0 || lun > 7) {
		printf("scsi target to unit, target (%ld) or lun (%ld)"
			" out of range.\n", target, lun);
		return -1;
	}

	if (bus == -1) {
		for (bus = 0 ; bus < scsibus_cd.cd_ndevs ; bus++) {
			if (scsibus_cd.cd_devs[bus]) {
				scsi = (struct scsibus_softc *)
						scsibus_cd.cd_devs[bus];
				sc_link = scsi_get_link(scsi, target, lun);
				if (sc_link != NULL) {
					sc_dev = (struct device *)
							sc_link->device_softc;
					return sc_dev->dv_unit;
				}
			}
		}
		return -1;
	}
	if (bus < 0 || bus >= scsibus_cd.cd_ndevs) {
		printf("scsi target to unit, bus (%ld) out of range.\n", bus);
		return -1;
	}
	if (scsibus_cd.cd_devs[bus]) {
		scsi = (struct scsibus_softc *) scsibus_cd.cd_devs[bus];
		sc_link = scsi_get_link(scsi, target, lun);
		if (sc_link != NULL) {
			sc_dev = (struct device *) sc_link->device_softc;
			return sc_dev->dv_unit;
		}
	}
	return -1;
}

struct nam2blk nam2blk[] = {
	{ "sd",         4 },
	{ "cd",         6 },
	{ "rd",		13 },
	{ "vnd",	8 },
	{ NULL,		-1 }
};
@


1.33
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2009/03/15 20:40:25 miod Exp $	*/
@


1.32
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2008/07/21 04:35:54 todd Exp $	*/
d163 2
a164 2
				if (scsi->sc_link[target][lun]) {
					sc_link = scsi->sc_link[target][lun];
d179 2
a180 2
		if (scsi->sc_link[target][lun]) {
			sc_link = scsi->sc_link[target][lun];
@


1.31
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2007/06/01 19:25:10 deraadt Exp $	*/
d113 3
@


1.30
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2007/06/01 19:20:46 deraadt Exp $	*/
d189 1
@


1.29
log
@provide dummy device_register()
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2007/05/04 19:30:55 deraadt Exp $	*/
a69 1
void	diskconf(void);
a119 1
	md_diskconf = diskconf;
d129 1
a129 1
diskconf()
@


1.28
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2007/05/04 03:44:44 deraadt Exp $	*/
d123 5
@


1.27
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2006/03/19 21:58:53 miod Exp $	*/
d182 1
a182 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d186 1
a187 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.26
log
@mountroot for disk devices shall be dk_mountroot(), not ffs_mountroot().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2006/01/18 23:21:17 miod Exp $	*/
a68 8
struct device	*booted_device;
int		booted_partition;

struct device *parsedisk(char *, int, int, dev_t *);
struct device *getdisk(char *, int, int, dev_t *);
int findblkmajor(struct device *);
int getstr(char *, int);
void findbootdev(void);
a69 1

d71 1
a71 371
void	setroot(void);

#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

void
cpu_configure()
{
	startrtclock();

	if (config_rootfound("mainbus", "mainbus") == NULL)
		panic("No mainbus found!");
	spl0();

	findbootdev();
	md_diskconf = diskconf;
	cold = 0;
}

void
diskconf()
{
	setroot();
	dumpconf();
}

struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "sd",         4 },
	{ "cd",         6 },
	{ "rd",		13 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	register int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)))
			return (nam2blk[i].maj);
	return (-1);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && c <= ('a' + MAXPARTITIONS - 1)) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot(void)
{
	register struct swdevt *swp;
	register struct device *dv;
	register int len;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
	struct device *bootdv, *rootdv, *swapdv;
	int bootpartition;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#else
	bootdv = booted_device;
#endif
	bootpartition = booted_partition;
	rootdv = swapdv = NULL;		/* XXX work around gcc warning */

	/*
	 * If `swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device");
			if (bootdv != NULL)
				printf(" (default %s%c)", bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len == 4 && !strcmp(buf, "halt"))
				boot(RB_HALT);
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					rootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, bootpartition, &nrootdev);
			if (dv != NULL) {
				rootdv = dv;
				break;
			}
		}

		/*
		 * Because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (rootdv->dv_class == DV_IFNET) {
			swapdv = NULL;
			goto gotswap;
		}
		for (;;) {
			printf("swap device");
			if (rootdv != NULL)
				printf(" (default %s%c)", rootdv->dv_xname,
				    rootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				switch (rootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(minor(nrootdev)), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				swapdv = rootdv;
				break;
			}
			if (len == 4 && !strcmp(buf, "halt"))
				boot(RB_HALT);
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				swapdv = dv;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else if (mountroot == NULL) {
		int majdev;

		/*
		 * "swap generic"
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 */
			rootdv = swapdv = bootdv;
			rootdev =
			    MAKEDISKDEV(majdev, bootdv->dv_unit, bootpartition);
			nswapdev = dumpdev =
			    MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			rootdv = swapdv = bootdv;
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (rootdv->dv_class) {
#ifdef NFSCLIENT
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = rootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		printf("root on %s%c", rootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		if (nswapdev != NODEV)
			printf(" swap on %s%c", swapdv->dv_xname,
			    DISKPART(nswapdev) + 'a');
		printf("\n");
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (major(rootdev) == major(swp->sw_dev) &&
		    DISKUNIT(rootdev) == DISKUNIT(minor(swp->sw_dev))) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

int
getstr(cp, size)
	register char *cp;
	register int size;
{
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}

d73 2
d111 21
d144 1
a144 1
extern	struct cfdriver		scsibus_cd;
d180 32
@


1.25
log
@Factorize akbd and ams drivers between mac68k and macppc; while there, start
moving out common adb code as well, and merge adb_direct.c into adb.c to
simplify external header files.

No functional change; more cleanups to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2006/01/13 19:36:45 miod Exp $	*/
a59 1
#include <sys/lock.h>
a68 4
#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ffs/ffs_extern.h>

d368 1
a368 1
		mountroot = ffs_mountroot;
@


1.24
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2006/01/04 20:39:05 miod Exp $	*/
a64 1
#include <machine/adbsys.h>
d94 1
a94 1
	startrtclock();		/* start before adb_init() */
@


1.23
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2005/12/27 18:31:09 miod Exp $	*/
a94 1
	mrg_init();		/* Init Mac ROM Glue */
@


1.22
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2005/08/01 14:49:55 miod Exp $	*/
d85 1
a96 1
	adb_init();		/* ADB device subsystem & driver */
d100 1
d103 7
a111 1
	cold = 0;
@


1.21
log
@Make bootdev a dev_t; ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2004/12/25 23:02:24 miod Exp $	*/
a85 1
void	swapconf(void);
d103 1
a103 1
	swapconf();
a104 24
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	int nblks, maj;

	for (swp = swdevt; swp->sw_dev != NODEV ; swp++) {
		maj = major(swp->sw_dev);
		if (maj > nblkdev)
			break;
		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
	dumpconf();
@


1.20
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2003/06/02 23:27:49 millert Exp $	*/
d477 1
a477 1
u_long		bootdev;	/* should be dev_t, but not until 32 bits */
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2003/05/11 19:41:10 deraadt Exp $	*/
d167 1
a167 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d207 1
a207 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d504 1
a504 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.18
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2003/02/25 01:45:12 miod Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@Destaticize, and add RAMDISK_HOOK glue for bsd.rd
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2002/04/21 23:35:52 miod Exp $	*/
d285 1
a285 1
				strcpy(buf, bootdv->dv_xname);
@


1.16
log
@Add ramdisk support.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2002/03/14 01:26:35 millert Exp $	*/
a78 2
#include "ether.h"

d83 5
a87 5
static struct device *getdisk(char *, int, int, dev_t *);
static int findblkmajor(struct device *);
static int getstr(char *, int);
static void findbootdev(void);
static int target_to_unit(u_long, u_long, u_long);
d92 4
d145 1
a145 1
static int
d158 1
a158 1
static struct device *
d168 3
d205 7
d215 3
d261 3
d265 1
a268 4
#ifdef DEBUG
	printf("boot device: %s\n",
		(bootdv) ? bootdv->dv_xname : "<unknown>");
#endif
d307 1
a307 1
		 * because swap must be on same device as root, for
d391 1
a391 1
#if defined(NFSCLIENT)
a393 1
#if NETHER > 0
a394 1
#endif
a396 1
#if defined(FFS)
a405 1
#endif
d435 1
a435 1
static int
d487 1
a487 1
static void
d523 1
a523 1
static int
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/06/25 00:43:12 mickey Exp $	*/
d140 1
d169 1
a169 1
				printf(" %s[a-h]", dv->dv_xname);
@


1.14
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/05/08 17:30:40 aaron Exp $	*/
d84 6
a89 6
struct device *parsedisk __P((char *, int, int, dev_t *));
static struct device *getdisk __P((char *, int, int, dev_t *));
static int findblkmajor __P((struct device *));
static int getstr __P((char *, int));
static void findbootdev __P((void));
static int target_to_unit __P((u_long, u_long, u_long));
d91 2
a92 2
void	setroot __P((void));
void	swapconf __P((void));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/06/25 00:43:12 mickey Exp $	*/
d84 6
a89 6
struct device *parsedisk(char *, int, int, dev_t *);
static struct device *getdisk(char *, int, int, dev_t *);
static int findblkmajor(struct device *);
static int getstr(char *, int);
static void findbootdev(void);
static int target_to_unit(u_long, u_long, u_long);
d91 2
a92 2
void	setroot(void);
void	swapconf(void);
a139 1
	{ "rd",		13 },
d168 1
a168 1
				printf(" %s[a-p]", dv->dv_xname);
@


1.14.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 2
d85 5
a89 5
struct device *getdisk(char *, int, int, dev_t *);
int findblkmajor(struct device *);
int getstr(char *, int);
void findbootdev(void);
int target_to_unit(u_long, u_long, u_long);
a93 4
#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

d143 1
a143 1
int
d156 1
a156 1
struct device *
a165 3
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
a199 7
#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif

a202 3
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
a245 3
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#else
a246 1
#endif
d250 4
d270 1
a270 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d292 1
a292 1
		 * Because swap must be on same device as root, for
d376 1
a376 1
#ifdef NFSCLIENT
d379 1
d381 1
d384 1
d394 1
d424 1
a424 1
int
d476 1
a476 1
void
d512 1
a512 1
int
@


1.13
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/05/05 22:33:52 art Exp $	*/
a96 2
	extern int	cold;

@


1.12
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 1997/11/28 21:09:54 gene Exp $	*/
a98 1
	VIA_initialize();	/* Init VIA hardware */
@


1.11
log
@Pull in header files needed to get definition of u_lbn_t in
ufs/ffs/ffs_extern.h.  This must be fallout from the lite2 merge.  Compiles
again.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 1997/01/24 01:35:43 briggs Exp $	*/
d51 1
a51 1
 * Configure() is called at boot time.  Available
a93 4
/*
 * configure:
 * called at boot time, configure all devices on the system
 */
d95 1
a95 1
configure()
@


1.11.10.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 1997/11/28 21:09:54 gene Exp $	*/
d51 1
a51 1
 * cpu_configure() is called at boot time.  Available
d94 4
d99 1
a99 1
cpu_configure()
d101 3
@


1.11.10.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 6
a89 6
struct device *parsedisk(char *, int, int, dev_t *);
static struct device *getdisk(char *, int, int, dev_t *);
static int findblkmajor(struct device *);
static int getstr(char *, int);
static void findbootdev(void);
static int target_to_unit(u_long, u_long, u_long);
d91 2
a92 2
void	setroot(void);
void	swapconf(void);
@


1.11.10.3
log
@Sync the SMP branch with 3.3
@
text
@d79 2
d85 5
a89 5
struct device *getdisk(char *, int, int, dev_t *);
int findblkmajor(struct device *);
int getstr(char *, int);
void findbootdev(void);
int target_to_unit(u_long, u_long, u_long);
a93 4
#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

a139 1
	{ "rd",		13 },
d142 1
a142 1
int
d155 1
a155 1
struct device *
a164 3
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
d168 1
a168 1
				printf(" %s[a-p]", dv->dv_xname);
a198 7
#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif

a201 3
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
a244 3
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#else
a245 1
#endif
d249 4
d291 1
a291 1
		 * Because swap must be on same device as root, for
d375 1
a375 1
#ifdef NFSCLIENT
d378 1
d380 1
d383 1
d393 1
d423 1
a423 1
int
d475 1
a475 1
void
d511 1
a511 1
int
@


1.11.10.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11.10.3 2003/03/27 23:28:44 niklas Exp $	*/
d285 1
a285 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
@


1.11.10.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11.10.4 2003/05/13 19:41:05 ho Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 1997/01/01 14:59:46 briggs Exp $	*/
d64 1
d75 2
@


1.9
log
@Prototypes for mountroot, etc. are now in sys/systm.h--use ufs/ffs/ffs_extern.h
for ffs_mountroot proto.
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.8 1996/06/23 15:59:42 briggs Exp $	*/
/*	$NetBSD: autoconf.c,v 1.31 1996/06/19 03:21:03 scottr Exp $	*/
d76 1
d251 1
d382 1
d384 1
@


1.8
log
@From scottr/NetBSD:
Completely revamp setroot() and friends.  Since Chris' version of this code
is close to how I reworked it, I pulled in the (essentially MI) NetBSD/alpha
and added the appropriate support around it.

- No need for the GENERIC kernel config option.
- NFS-mounted root and swap are supported.
- If we can't figure out where the root filesystem is from what the Booter
  tells us, ask the user.
- Split the mainbus autoconfig code to a separate file.

Also, update/add copyrights as appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 1996/05/26 18:36:13 briggs Exp $	*/
d74 2
a240 1
	extern int (*mountroot) __P((void *));
a245 4
	extern int nfs_mountroot __P((void *));
#endif
#if defined(FFS)
	extern int ffs_mountroot __P((void *));
@


1.7
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: autoconf.c,v 1.29 1996/05/15 02:51:00 briggs Exp $	*/
d5 2
a6 3
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990 The Regents of the University of California.
 * All rights reserved.
d8 8
a15 3
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
a43 36
 */
/*-
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * from: Utah $Hdr: autoconf.c 1.31 91/01/21$
d45 1
a45 1
 *	@@(#)autoconf.c	7.5 (Berkeley) 5/7/91
a48 8
   ALICE 
      05/23/92 BG
      I've started to re-write this procedure to use our devices and strip 
      out all the useless HP stuff, but I only got to line 120 or so 
      before I had a really bad attack of kompernelphobia and blacked out.
*/

/*
a56 1
#include <sys/device.h>
d59 1
a59 1
#include <sys/dkstat.h>
a60 1
#include <sys/dmap.h>
d62 1
a62 2

#include <sys/disklabel.h>
d65 1
a65 3
#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/vm_map.h>
d67 1
a68 5
#include <machine/autoconf.h>
#include <machine/vmparam.h>
#include <machine/param.h>
#include <machine/cpu.h>
#include <machine/pte.h>
a73 6
/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
int	cold;		    /* if 1 (locore.s), still working on cold-start */
d75 9
a83 3
#ifdef DEBUG
int	acdebug = 0;
#endif
d85 2
a86 6
static void	findbootdev __P((void));
static int	mainbus_match __P((struct device *, void *, void *));
static void	mainbus_attach __P((struct device *parent,
					struct device *self, void *aux));
static void	setroot __P((void));
static void	swapconf __P((void));
d89 2
a90 1
 * Determine mass storage and memory configuration for a machine.
d93 1
a93 1
configure(void)
d95 1
a95 1
	VIA_initialize();
d97 1
a98 1

a99 1
	
d103 1
a103 1
		panic("No main device!");
d105 1
a105 5
#if GENERIC
	if ((boothowto & RB_ASKNAME) == 0)
		setroot();
	setconf();
#else
a106 6
#endif

	/*
	 * Configure swap area and related system
	 * parameter based on device(s) used.
	 */
a107 1
	dumpconf();
d114 2
a115 2
static void
swapconf(void)
d117 2
a118 2
	register struct swdevt *swp;
	register int nblks;
d121 1
a121 2
		int maj = major(swp->sw_dev);

d132 1
d135 7
a141 5
u_long	bootdev;		/* should be dev_t, but not until 32 bits */
struct	device *bootdv = NULL;

#define	PARTITIONMASK	0x7
#define	UNITSHIFT	3
a142 5
/*
 * Map a SCSI bus, target, lun to a device number.
 * This could be tape, disk, CD.  The calling routine, though,
 * assumes DISK.  It would be nice to allow CD, too...
 */
d144 2
a145 1
target_to_unit(u_long bus, u_long target, u_long lun)
d147 2
a148 4
	struct scsibus_softc	*scsi;
	struct scsi_link	*sc_link;
	struct device		*sc_dev;
extern	struct cfdriver		scsibus_cd;
d150 13
a162 5
	if (target < 0 || target > 7 || lun < 0 || lun > 7) {
		printf("scsi target to unit, target (%ld) or lun (%ld)"
			" out of range.\n", target, lun);
		return -1;
	}
d164 10
a173 25
	if (bus == -1) {
		for (bus = 0 ; bus < scsibus_cd.cd_ndevs ; bus++) {
			if (scsibus_cd.cd_devs[bus]) {
				scsi = (struct scsibus_softc *)
						scsibus_cd.cd_devs[bus];
				if (scsi->sc_link[target][lun]) {
					sc_link = scsi->sc_link[target][lun];
					sc_dev = (struct device *)
							sc_link->device_softc;
					return sc_dev->dv_unit;
				}
			}
		}
		return -1;
	}
	if (bus < 0 || bus >= scsibus_cd.cd_ndevs) {
		printf("scsi target to unit, bus (%ld) out of range.\n", bus);
		return -1;
	}
	if (scsibus_cd.cd_devs[bus]) {
		scsi = (struct scsibus_softc *) scsibus_cd.cd_devs[bus];
		if (scsi->sc_link[target][lun]) {
			sc_link = scsi->sc_link[target][lun];
			sc_dev = (struct device *) sc_link->device_softc;
			return sc_dev->dv_unit;
d175 1
d177 1
a177 1
	return -1;
d180 5
a184 3
/* swiped from sparc/sparc/autoconf.c */
static int
findblkmajor(register struct disk *dv)
d186 13
a198 1
	register int	i;
d200 16
a215 4
	for (i=0 ; i<nblkdev ; i++) {
		if ((void (*)(struct buf *))bdevsw[i].d_strategy ==
		    dv->dk_driver->d_strategy)
			return i;
d217 3
a219 1
	return -1;
d223 7
a229 1
 * Yanked from i386/i386/autoconf.c
d231 2
a232 2
static void
findbootdev(void)
d234 1
d236 14
a249 3
	register struct disk *diskp;
	register int unit;
	int major;
d251 2
a252 3
	major = B_TYPE(bootdev);
	if (major < 0 || major >= nblkdev)
		return;
d254 10
a263 1
	unit = B_UNIT(bootdev);
d265 29
a293 3
	bootdev &= ~(B_UNITMASK << B_UNITSHIFT);
	unit = target_to_unit(-1, unit, 0);
	bootdev |= (unit << B_UNITSHIFT);
d295 66
a360 5
	if (disk_count <= 0)
		return;

	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if ((dv->dv_class == DV_DISK) && (unit == dv->dv_unit)) {
d362 1
a362 2
			 * Find the disk corresponding to the current
			 * device.
d364 2
a365 7
			if ((diskp = disk_find(dv->dv_xname)) == NULL)
				continue;

			if (major == findblkmajor(diskp)) {
				bootdv = dv;
				return;
			}
d367 2
a368 2
	}
}
d370 1
a370 11
/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
static void
setroot(void)
{
	register struct swdevt	*swp;
	register int		majdev, mindev, part;
	dev_t			nrootdev, temp;
d372 4
a375 1
	if (boothowto & RB_DFLTROOT)
a376 16
	findbootdev();
	if (bootdv == NULL) {
		printf("ARGH!!  No boot device????");
		delay(10000000);
/*		panic("ARGH!!  No boot device????"); */
	}
	nrootdev = 0;
	switch (bootdv->dv_class) {
		case DV_DISK:
			nrootdev = makedev(B_TYPE(bootdev),
					   (B_UNIT(bootdev) << UNITSHIFT)
					   + B_PARTITION(bootdev));
			break;
		default:
			printf("Only supports DISK device for booting.\n");
			break;
d379 5
a383 1
	if (rootdev == nrootdev)
d385 16
d402 3
a404 8
	majdev = major(nrootdev);
	mindev = minor(nrootdev);
	part = mindev & PARTITIONMASK;
	mindev -= part;

	rootdev = nrootdev;
	printf("Changing root device to %s%c.\n", bootdv->dv_xname, part+'a');

d406 3
a408 3
	for (swp = swdevt ; swp->sw_dev != NODEV ; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
d418 4
d426 43
a468 43
/*
 * Generic "bus" support functions.  From NetBSD/sun3.
 *
 * bus_scan:
 * This function is passed to config_search() by the attach function
 * for each of the "bus" drivers (obio, nubus).
 * The purpose of this function is to copy the "locators" into our
 * confargs structure, so child drivers may use the confargs both
 * as match parameters and as temporary storage for the defaulted
 * locator values determined in the child_match and preserved for
 * the child_attach function.  If the bus attach functions just
 * used config_found, then we would not have an opportunity to
 * setup the confargs for each child match and attach call.
 *
 * bus_print:
 * Just prints out the final (non-default) locators.
 */
int
bus_scan(parent, child, aux)
	struct device *parent;
	void *child, *aux;
{
	struct cfdata *cf = child;
	struct confargs *ca = aux;
	cfmatch_t mf;

#ifdef	DIAGNOSTIC
	if (parent->dv_cfdata->cf_driver->cd_indirect)
		panic("bus_scan: indirect?");
	if (cf->cf_fstate == FSTATE_STAR)
		panic("bus_scan: FSTATE_STAR");
#endif

	/* ca->ca_bustype set by parent */

	/*
	 * Note that this allows the match function to save
	 * defaulted locators in the confargs that will be
	 * preserved for the related attach call.
	 */
	mf = cf->cf_attach->ca_match;
	if ((*mf)(parent, cf, ca) > 0) {
		config_attach(parent, cf, ca, bus_print);
a469 1
	return (0);
a471 14
/*
 * From NetBSD/sun3.
 * Print out the confargs.  The parent name is non-NULL
 * when there was no match found by config_found().
 */
int
bus_print(args, name)
	void *args;
	char *name;
{
/*	struct confargs *ca = args; */

	if (name)
		printf("%s:", name);
d473 1
a473 4
	return(UNCONF);
}

vm_offset_t tmp_vpages[1];
d476 1
a476 6
 * Read addr with size len (1,2,4) into val.
 * If this generates a bus error, return -1
 *
 *	Create a temporary mapping,
 *	Try the access using peek_*
 *	Clean up temp. mapping
d478 2
a479 5
int
bus_peek(bustype, paddr, sz)
	int bustype;
	vm_offset_t paddr;
	int sz;
d481 5
a485 3
	int off, pte, rv;
	vm_offset_t pgva;
	caddr_t va;
d487 3
a489 2
	if (bustype != BUS_NUBUS)
		return -1;
d491 1
a491 3
	off = paddr & PGOFSET;
	paddr -= off;
	pte = (paddr & PG_FRAME) | (PG_V | PG_W | PG_CI);
d493 3
a495 2
	pgva = tmp_vpages[0];
	va = (caddr_t)pgva + off;
d497 2
a498 2
	mac68k_set_pte(pgva, pte);
	TBIS(pgva);
d500 6
a505 21
	/*
	 * OK, try the access using one of the assembly routines
	 * that will set pcb_onfault and catch any bus errors.
	 */
	rv = -1;
	switch (sz) {
	case 1:
		if (!badbaddr(va))
			rv = *((u_char *) va);
		break;
	case 2:
		if (!badwaddr(va))
			rv = *((u_int16_t *) va);
		break;
	case 4:
		if (!badladdr(va))
			rv = *((u_int32_t *) va);
		break;
	default:
		printf("bus_peek: invalid size=%d\n", sz);
		rv = -1;
a506 5

	mac68k_set_pte(pgva, PG_NV);
	TBIS(pgva);

	return rv;
d509 5
a513 36
char *
bus_mapin(bustype, paddr, sz)
	int bustype, paddr, sz;
{
	int off, pa, pmt;
	vm_offset_t va, retval;

	if (bustype != BUS_NUBUS)
		return (NULL);

	off = paddr & PGOFSET;
	pa = paddr - off;
	sz += off;
	sz = mac68k_round_page(sz);

	/* Get some kernel virtual address space. */
	va = kmem_alloc_wait(kernel_map, sz);
	if (va == 0)
		panic("bus_mapin");
	retval = va + off;

	/* Map it to the specified bus. */
#if 0	/* XXX */
	/* This has a problem with wrap-around... */
	pmap_map((int)va, pa | pmt, pa + sz, VM_PROT_ALL);
#else
	do {
		pmap_enter(pmap_kernel(), va, pa | pmt, VM_PROT_ALL, FALSE);
		va += NBPG;
		pa += NBPG;
	} while ((sz -= NBPG) > 0);
#endif

	return ((char*)retval);
}	

d515 2
a516 3
mainbus_match(parent, match, aux)
	struct device	*parent;
	void		*match, *aux;
d518 4
a521 2
	return 1;
}
d523 5
a527 5
static int bus_order[] = {
	BUS_OBIO,	/* For On-board I/O */
	BUS_NUBUS
};
#define BUS_ORDER_SZ (sizeof(bus_order)/sizeof(bus_order[0]))
d529 26
a554 13
static void
mainbus_attach(parent, self, aux)
	struct device	*parent, *self;
	void		*aux;
{
	struct confargs	ca;
	int	i;

	printf("\n");

	for (i = 0; i < BUS_ORDER_SZ; i++) {
		ca.ca_bustype = bus_order[i];
		(void) config_found(self, &ca, NULL);
d556 1
a557 8

struct cfattach mainbus_ca = {
	sizeof(struct device), mainbus_match, mainbus_attach
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};
@


1.6
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.5
log
@Move VIA_Initialize() back to where it works.
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.21 1996/01/07 22:02:39 thorpej Exp $	*/
d107 6
d117 1
d133 7
d143 2
a144 1
configure()
a145 2
	int found;

d150 2
d154 1
a154 3
	startrtclock();

	if (config_rootfound("mainbus", "mainbus") == 0)
d177 2
a178 1
swapconf()
d181 1
a181 1
	register int nblks, tblks;
a211 1
	int			targ;
d215 1
a215 1
extern	struct cfdriver		scsibuscd;
d218 1
a218 1
		printf("scsi target to unit, target (%d) or lun (%d)"
d224 2
a225 2
		for (bus = 0 ; bus < scsibuscd.cd_ndevs ; bus++) {
			if (scsibuscd.cd_devs[bus]) {
d227 1
a227 1
						scsibuscd.cd_devs[bus];
d238 2
a239 2
	if (bus < 0 || bus >= scsibuscd.cd_ndevs) {
		printf("scsi target to unit, bus (%d) out of range.\n", bus);
d242 2
a243 2
	if (scsibuscd.cd_devs[bus]) {
		scsi = (struct scsibus_softc *) scsibuscd.cd_devs[bus];
d270 2
a271 2
void
findbootdev()
d291 1
a291 1
	for (dv = alldevs ; dv ; dv = dv->dv_next) {
d313 2
a314 1
setroot()
d318 1
a318 1
	dev_t			nrootdev, nswapdev, temp;
d328 1
d332 1
a332 1
					   B_UNIT(bootdev) << UNITSHIFT
d368 46
a413 4
struct newconf_S {
	char	*name;
	int	req;
};
d415 9
a423 4
static int
mbprint(aux, name)
	void	*aux;
	char	*name;
d425 1
a425 1
	struct newconf_S	*c = (struct newconf_S *) aux;
d428 2
a429 1
		printf("%s at %s", c->name, name);
d433 15
a447 5
static int
root_matchbyname(parent, cf, aux)
	struct device	*parent;
	struct cfdata	*cf;
	void		*aux;
d449 44
a492 1
	return (strcmp(cf->cf_driver->cd_name, (char *)aux) == 0);
d495 3
a497 5
extern int
matchbyname(parent, match, aux)
	struct device	*parent;
	void		*match;
	void		*aux;
d499 5
a503 2
	struct newconf_S	*c = (struct newconf_S *) aux;
	struct device		*dv = (struct device *) match;
d505 25
a529 2
/*	printf("matchbyname: (%s) and (%s).\n", dv->dv_xname, c->name);
*/
d531 6
a536 1
	return (strcmp(dv->dv_xname, c->name) == 0);
d539 6
d550 2
a551 16
	struct newconf_S	conf_data[] = {
					{"ite0",       1},
					{"adb0",       1},
					{"ser0",       0},
					{"sn0",        0},
					{"nubus0",     1},
					{"sbc0",       0},
					{"ncrscsi0",   0},
					{"ncr96scsi0", 0},
					{"asc0",       0},
					{"fpu0",       0},
					{"floppy0",    0},
					{NULL,         0}
			 	};
	struct newconf_S	*c;
	int			fail=0, warn=0;
a553 9
	for (c=conf_data ; c->name ; c++) {
		if (config_found(self, c, mbprint)) {
		} else {
			if (c->req) {
				fail++;
			}
			warn++;
		}
	}
d555 3
a557 3
	if (fail) {
		printf("Failed to find %d required devices.\n", fail);
		panic("Can't continue.");
d561 7
a567 3
struct cfdriver mainbuscd =
      { NULL, "mainbus", root_matchbyname, mainbus_attach,
	DV_DULL, sizeof(struct device), 1, 0 };
@


1.4
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d405 1
@


1.3
log
@Go ahead and look for the sonic--no problem if we don't find it.
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.20 1995/11/01 04:59:31 briggs Exp $	*/
d242 1
a242 1
findblkmajor(register struct dkdevice *dv)
d261 1
d275 3
d279 12
a290 5
		if (   (dv->dv_class == DV_DISK)
		    && (unit == dv->dv_unit)
		    && (major == findblkmajor((struct dkdevice *) (dv+1)))) {
			bootdv = dv;
			return;
@


1.2
log
@update from netbsd (without losing local changes)
@
text
@d392 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.19.2.1 1995/10/14 22:26:33 briggs Exp $	*/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
