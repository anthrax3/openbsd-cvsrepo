head	1.20;
access;
symbols
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.14
	OPENBSD_5_0:1.19.0.12
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.10
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.8
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.4
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	NIKLAS_UNDEAD:1.2.0.10
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.19;

1.19
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.08.23.53.08;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.14.15.12.59;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.12.16.31.21;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.07.02.29.30;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.04.18.42.04;	author martin;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.04.03.47.53;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.15.06.48.23;	author martin;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.13.17.19.23;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.20.00.17.05;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.07.09.22.41.14;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.20.19.39.31;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.05.13.15.44.49;	author jason;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	98.05.08.22.15.31;	author gene;	state Exp;
branches;
next	;

1.2.4.1
date	2001.04.18.16.10.06;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: if_mc.c,v 1.19 2008/11/28 02:44:17 brad Exp $	*/
/*	$NetBSD: if_mc.c,v 1.24 2004/10/30 18:08:34 thorpej Exp $	*/

/*-
 * Copyright (c) 1997 David Huang <khym@@azeotrope.org>
 * All rights reserved.
 *
 * Portions of this code are based on code by Denton Gentry <denny1@@home.com>,
 * Charles M. Hannum, Yanagisawa Takeshi <yanagisw@@aa.ap.titech.ac.jp>, and
 * Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Driver for the AMD Am79C940 (MACE) ethernet chip, used for onboard
 * ethernet on the Centris/Quadra 660av and Quadra 840av.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/buf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_dl.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#endif

#include <uvm/uvm_extern.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

#include <machine/bus.h>
#include <mac68k/dev/if_mcreg.h>
#include <mac68k/dev/if_mcvar.h>

struct cfdriver mc_cd = {
	NULL, "mc", DV_IFNET
};

void	mcwatchdog(struct ifnet *);
int	mcinit(struct mc_softc *sc);
int	mcstop(struct mc_softc *sc);
int	mcioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
void	mcstart(struct ifnet *ifp);
void	mcreset(struct mc_softc *sc);

u_int	maceput(struct mc_softc *sc, struct mbuf *m0);
void	mc_tint(struct mc_softc *sc);
void	mace_read(struct mc_softc *, caddr_t, int);
struct mbuf *mace_get(struct mc_softc *, caddr_t, int);
static void mace_calcladrf(struct arpcom *ac, u_int8_t *af);
static inline u_int16_t ether_cmp(void *, void *);


/*
 * Compare two Ether/802 addresses for equality, inlined and
 * unrolled for speed.  Use this like bcmp().
 *
 * XXX: Add <machine/inlines.h> for stuff like this?
 * XXX: or maybe add it to libkern.h instead?
 *
 * "I'd love to have an inline assembler version of this."
 * XXX: Who wanted that? mycroft?  I wrote one, but this
 * version in C is as good as hand-coded assembly. -gwr
 *
 * Please do NOT tweak this without looking at the actual
 * assembly code generated before and after your tweaks!
 */
static inline u_int16_t
ether_cmp(one, two)
	void *one, *two;
{
	register u_int16_t *a = (u_short *) one;
	register u_int16_t *b = (u_short *) two;
	register u_int16_t diff;

#ifdef	m68k
	/*
	 * The post-increment-pointer form produces the best
	 * machine code for m68k.  This was carefully tuned
	 * so it compiles to just 8 short (2-byte) op-codes!
	 */
	diff  = *a++ - *b++;
	diff |= *a++ - *b++;
	diff |= *a++ - *b++;
#else
	/*
	 * Most modern CPUs do better with a single expression.
	 * Note that short-cut evaluation is NOT helpful here,
	 * because it just makes the code longer, not faster!
	 */
	diff = (a[0] - b[0]) | (a[1] - b[1]) | (a[2] - b[2]);
#endif

	return (diff);
}

#define ETHER_CMP	ether_cmp

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
int
mcsetup(sc, lladdr)
	struct mc_softc	*sc;
	u_int8_t *lladdr;
{
	struct ifnet *ifp = &sc->sc_if;

	/* reset the chip and disable all interrupts */
	NIC_PUT(sc, MACE_BIUCC, SWRST);
	DELAY(100);
	NIC_PUT(sc, MACE_IMR, ~0);

	bcopy(lladdr, sc->sc_enaddr, ETHER_ADDR_LEN);
	bcopy(sc->sc_enaddr, sc->sc_ethercom.ac_enaddr, ETHER_ADDR_LEN);
	printf(": address %s\n", ether_sprintf(lladdr));

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_ioctl = mcioctl;
	ifp->if_start = mcstart;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
	ifp->if_watchdog = mcwatchdog;
	IFQ_SET_READY(&ifp->if_snd);

	if_attach(ifp);
	ether_ifattach(ifp);

	return (0);
}

int
mcioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct mc_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *) data;
	int s, err = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			mcinit(sc);
			arp_ifinit(&sc->sc_ethercom, ifa);
			break;
#endif
		default:
			mcinit(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running,
			 * then stop it.
			 */
			mcstop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped,
			 * then start it.
			 */
			(void)mcinit(sc);
		} else {
			/*
			 * reset the interface to pick up any other changes
			 * in flags
			 */
			mcreset(sc);
			mcstart(ifp);
		}
		break;

	default:
		err = ether_ioctl(ifp, &sc->sc_ethercom, cmd, data);
	}

	if (err == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			mcreset(sc);
		err = 0;
	}

	splx(s);
	return (err);
}

/*
 * Encapsulate a packet of type family for the local net.
 */
void
mcstart(ifp)
	struct ifnet *ifp;
{
	struct mc_softc	*sc = ifp->if_softc;
	struct mbuf	*m;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	while (1) {
		if (ifp->if_flags & IFF_OACTIVE)
			return;

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			return;

#if NBPFILTER > 0
		/*
		 * If bpf is listening on this interface, let it
		 * see the packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		ifp->if_flags |= IFF_OACTIVE;
		maceput(sc, m);

		ifp->if_opackets++;		/* # of pkts */
	}
}

/*
 * reset and restart the MACE.  Called in case of fatal
 * hardware/software errors.
 */
void
mcreset(sc)
	struct mc_softc *sc;
{
	mcstop(sc);
	mcinit(sc);
}

int
mcinit(sc)
	struct mc_softc *sc;
{
	int s;
	u_int8_t maccc, ladrf[8];

	if (sc->sc_if.if_flags & IFF_RUNNING)
		/* already running */
		return (0);

	s = splnet();

	NIC_PUT(sc, MACE_BIUCC, sc->sc_biucc);
	NIC_PUT(sc, MACE_FIFOCC, sc->sc_fifocc);
	NIC_PUT(sc, MACE_IMR, ~0); /* disable all interrupts */
	NIC_PUT(sc, MACE_PLSCC, sc->sc_plscc);

	NIC_PUT(sc, MACE_UTR, RTRD); /* disable reserved test registers */

	/* set MAC address */
	NIC_PUT(sc, MACE_IAC, ADDRCHG);
	while (NIC_GET(sc, MACE_IAC) & ADDRCHG)
		;
	NIC_PUT(sc, MACE_IAC, PHYADDR);
	bus_space_write_multi_1(sc->sc_regt, sc->sc_regh, MACE_REG(MACE_PADR),
	    sc->sc_enaddr, ETHER_ADDR_LEN);

	/* set logical address filter */
	mace_calcladrf(&sc->sc_ethercom, ladrf);

	NIC_PUT(sc, MACE_IAC, ADDRCHG);
	while (NIC_GET(sc, MACE_IAC) & ADDRCHG)
		;
	NIC_PUT(sc, MACE_IAC, LOGADDR);
	bus_space_write_multi_1(sc->sc_regt, sc->sc_regh, MACE_REG(MACE_LADRF),
	    ladrf, 8);

	NIC_PUT(sc, MACE_XMTFC, APADXMT);
	/*
	 * No need to autostrip padding on receive... Ethernet frames
	 * don't have a length field, unlike 802.3 frames, so the MACE
	 * can't figure out the length of the packet anyways.
	 */
	NIC_PUT(sc, MACE_RCVFC, 0);

	maccc = ENXMT | ENRCV;
	if (sc->sc_if.if_flags & IFF_PROMISC)
		maccc |= PROM;

	NIC_PUT(sc, MACE_MACCC, maccc);

	if (sc->sc_bus_init)
		(*sc->sc_bus_init)(sc);

	/*
	 * Enable all interrupts except receive, since we use the DMA
	 * completion interrupt for that.
	 */
	NIC_PUT(sc, MACE_IMR, RCVINTM);

	/* flag interface as "running" */
	sc->sc_if.if_flags |= IFF_RUNNING;
	sc->sc_if.if_flags &= ~IFF_OACTIVE;

	splx(s);
	return (0);
}

/*
 * close down an interface and free its buffers
 * Called on final close of device, or if mcinit() fails
 * part way through.
 */
int
mcstop(sc)
	struct mc_softc *sc;
{
	int	s = splnet();

	NIC_PUT(sc, MACE_BIUCC, SWRST);
	DELAY(100);

	sc->sc_if.if_timer = 0;
	sc->sc_if.if_flags &= ~IFF_RUNNING;

	splx(s);
	return (0);
}

/*
 * Called if any Tx packets remain unsent after 5 seconds,
 * In all cases we just reset the chip, and any retransmission
 * will be handled by higher level protocol timeouts.
 */
void
mcwatchdog(ifp)
	struct ifnet *ifp;
{
	struct mc_softc *sc = ifp->if_softc;

	printf("mcwatchdog: resetting chip\n");
	mcreset(sc);
}

/*
 * stuff packet into MACE (at splnet)
 */
u_int
maceput(sc, m)
	struct mc_softc *sc;
	struct mbuf *m;
{
	struct mbuf *n;
	u_int len, totlen = 0;
	u_char *buff;

	buff = sc->sc_txbuf;

	for (; m; m = n) {
		u_char *data = mtod(m, u_char *);
		len = m->m_len;
		totlen += len;
		bcopy(data, buff, len);
		buff += len;
		MFREE(m, n);
	}

	if (totlen > PAGE_SIZE)
		panic("%s: maceput: packet overflow", sc->sc_dev.dv_xname);

#if 0
	if (totlen < ETHERMIN + sizeof(struct ether_header)) {
		int pad = ETHERMIN + sizeof(struct ether_header) - totlen;
		bzero(sc->sc_txbuf + totlen, pad);
		totlen = ETHERMIN + sizeof(struct ether_header);
	}
#endif

	(*sc->sc_putpacket)(sc, totlen);

	sc->sc_if.if_timer = 5;	/* 5 seconds to watch for failing to transmit */
	return (totlen);
}

void
mcintr(arg)
	void *arg;
{
struct mc_softc *sc = arg;
	u_int8_t ir;

	ir = NIC_GET(sc, MACE_IR) & ~NIC_GET(sc, MACE_IMR);
	if (ir & JAB) {
#ifdef MCDEBUG
		printf("%s: jabber error\n", sc->sc_dev.dv_xname);
#endif
		sc->sc_if.if_oerrors++;
	}

	if (ir & BABL) {
#ifdef MCDEBUG
		printf("%s: babble\n", sc->sc_dev.dv_xname);
#endif
		sc->sc_if.if_oerrors++;
	}

	if (ir & CERR) {
#ifdef MCDEBUG
		printf("%s: collision error\n", sc->sc_dev.dv_xname);
#endif
		sc->sc_if.if_collisions++;
	}

	/*
	 * Pretend we have carrier; if we don't this will be cleared
	 * shortly.
	 */
	sc->sc_havecarrier = 1;

	if (ir & XMTINT)
		mc_tint(sc);

	if (ir & RCVINT)
		mc_rint(sc);
}

void
mc_tint(sc)
	struct mc_softc *sc;
{
	u_int8_t xmtrc, xmtfs;

	xmtrc = NIC_GET(sc, MACE_XMTRC);
	xmtfs = NIC_GET(sc, MACE_XMTFS);

	if ((xmtfs & XMTSV) == 0)
		return;

	if (xmtfs & UFLO) {
		printf("%s: underflow\n", sc->sc_dev.dv_xname);
		mcreset(sc);
		return;
	}

	if (xmtfs & LCOL) {
		printf("%s: late collision\n", sc->sc_dev.dv_xname);
		sc->sc_if.if_oerrors++;
		sc->sc_if.if_collisions++;
	}

	if (xmtfs & MORE)
		/* Real number is unknown. */
		sc->sc_if.if_collisions += 2;
	else if (xmtfs & ONE)
		sc->sc_if.if_collisions++;
	else if (xmtfs & RTRY) {
		printf("%s: excessive collisions\n", sc->sc_dev.dv_xname);
		sc->sc_if.if_collisions += 16;
		sc->sc_if.if_oerrors++;
	}

	if (xmtfs & LCAR) {
		sc->sc_havecarrier = 0;
		printf("%s: lost carrier\n", sc->sc_dev.dv_xname);
		sc->sc_if.if_oerrors++;
	}

	sc->sc_if.if_flags &= ~IFF_OACTIVE;
	sc->sc_if.if_timer = 0;
	mcstart(&sc->sc_if);
}

void
mc_rint(sc)
	struct mc_softc *sc;
{
#define	rxf	sc->sc_rxframe
	u_int len;

	len = (rxf.rx_rcvcnt | ((rxf.rx_rcvsts & 0xf) << 8)) - 4;

#ifdef MCDEBUG
	if (rxf.rx_rcvsts & 0xf0)
		printf("%s: rcvcnt %02x rcvsts %02x rntpc 0x%02x rcvcc 0x%02x\n",
		    sc->sc_dev.dv_xname, rxf.rx_rcvcnt, rxf.rx_rcvsts,
		    rxf.rx_rntpc, rxf.rx_rcvcc);
#endif

	if (rxf.rx_rcvsts & OFLO) {
#ifdef MCDEBUG
		printf("%s: receive FIFO overflow\n", sc->sc_dev.dv_xname);
#endif
		sc->sc_if.if_ierrors++;
		return;
	}

	if (rxf.rx_rcvsts & CLSN)
		sc->sc_if.if_collisions++;

	if (rxf.rx_rcvsts & FRAM) {
#ifdef MCDEBUG
		printf("%s: framing error\n", sc->sc_dev.dv_xname);
#endif
		sc->sc_if.if_ierrors++;
		return;
	}

	if (rxf.rx_rcvsts & FCS) {
#ifdef MCDEBUG
		printf("%s: frame control checksum error\n", sc->sc_dev.dv_xname);
#endif
		sc->sc_if.if_ierrors++;
		return;
	}

	mace_read(sc, rxf.rx_frame, len);
#undef	rxf
}

void
mace_read(sc, pkt, len)
	struct mc_softc *sc;
	caddr_t pkt;
	int len;
{
	struct ifnet *ifp = &sc->sc_if;
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {
#ifdef MCDEBUG
		printf("%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);
#endif
		ifp->if_ierrors++;
		return;
	}

	m = mace_get(sc, pkt, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

#if NBPFILTER > 0
	/* Pass the packet to any BPF listeners. */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
}

/*
 * Pull data off an interface.
 * Len is length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present
 * we copy into clusters.
 */
struct mbuf *
mace_get(sc, pkt, totlen)
	struct mc_softc *sc;
	caddr_t pkt;
	int totlen;
{
	register struct mbuf *m;
	struct mbuf *top, **mp;
	int len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	m->m_pkthdr.rcvif = &sc->sc_if;
	m->m_pkthdr.len = totlen;
	len = MHLEN;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (NULL);
			}
			len = MLEN;
		}
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_free(m);
				m_freem(top);
				return (NULL);
			}
			len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(pkt, mtod(m, caddr_t), len);
		pkt += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

/*
 * Go through the list of multicast addresses and calculate the logical
 * address filter.
 */
void
mace_calcladrf(ac, af)
	struct arpcom *ac;
	u_int8_t *af;
{
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	register u_int32_t crc;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	*((u_int32_t *)af) = *((u_int32_t *)af + 1) = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			goto allmulti;
		}

		crc = ether_crc32_le(enm->enm_addrlo, sizeof(enm->enm_addrlo));

		/* Just want the 6 most significant bits. */
		crc >>= 26;

		/* Set the corresponding bit in the filter. */
		af[crc >> 3] |= 1 << (crc & 7);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
	return;

allmulti:
	ifp->if_flags |= IFF_ALLMULTI;
	*((u_int32_t *)af) = *((u_int32_t *)af + 1) = 0xffffffff;
}

static u_char bbr4[] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};
#define bbr(v)  ((bbr4[(v)&0xf] << 4) | bbr4[((v)>>4) & 0xf])

u_char
mc_get_enaddr(t, h, o, dst)
	bus_space_tag_t t;
	bus_space_handle_t h;
	bus_size_t o;
	u_char *dst;
{
	int	i;
	u_char	b, csum;

	/*
	 * The XOR of the 8 bytes of the ROM must be 0xff for it to be
	 * valid
	*/
	for (i = 0, csum = 0; i < 8; i++) {
		b = bus_space_read_1(t, h, o+16*i);
		if (i < ETHER_ADDR_LEN)
			dst[i] = bbr(b);
		csum ^= b;
	}

	return csum;
}
@


1.19
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.18 2008/10/08 23:53:08 brad Exp $	*/
@


1.18
log
@cosmetic change for ioctl funtions.. move splnet out from variable declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.17 2008/10/02 20:21:13 brad Exp $	*/
d179 1
a179 2
	struct ifaddr *ifa;
	struct ifreq *ifr;
a185 1
		ifa = (struct ifaddr *)data;
a225 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *) data;
		err = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ethercom) :
		    ether_delmulti(ifr, &sc->sc_ethercom);

		if (err == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly. But remember UP flag!
			 */
			if (ifp->if_flags & IFF_RUNNING)
				mcreset(sc);
			err = 0;
		}
		break;
d228 6
@


1.17
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.16 2007/10/14 15:12:59 krw Exp $	*/
d181 1
d183 1
a183 1
	int	s = splnet(), err = 0;
@


1.16
log
@'expresion' -> 'expression'. Reported by Jung on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.15 2007/01/12 16:31:21 martin Exp $	*/
a184 1

d245 1
a245 1
		err = EINVAL;
d247 1
@


1.15
log
@fix altq for mc(4); make mbuf functions return NULL instead of 0 while
there

from Brad, tested by me on all three adapters
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.14 2006/03/25 22:41:41 djm Exp $	*/
d124 1
a124 1
	 * Most modern CPUs do better with a single expresion.
@


1.14
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.13 2005/06/08 17:03:02 henning Exp $	*/
d164 2
d269 2
a270 2
		IF_DEQUEUE(&ifp->if_snd, m);
		if (m == 0)
d638 3
a640 2
	if (m == 0)
		return (0);
d650 1
a650 1
			if (m == 0) {
d652 1
a652 1
				return 0;
d661 1
a661 1
				return 0;
@


1.13
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.12 2005/06/07 02:29:30 henning Exp $	*/
d277 1
a277 1
			bpf_mtap(ifp->if_bpf, m);
d612 1
a612 1
		bpf_mtap(ifp->if_bpf, m);
@


1.12
log
@CCITT about to bite the dust, remove special casing in archs and drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.11 2005/01/04 18:42:04 martin Exp $	*/
a59 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a192 18
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				bcopy(ina->x_host.c_host,
				    LLADDR(ifp->if_sadl),
				    sizeof(sc->sc_enaddr));
			}
			/* Set new address. */
			mcinit(sc);
			break;
		    }
@


1.11
log
@ifdef MCDEBUG printf on FIFO overflows as discussed with Nick
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.10 2005/01/04 03:47:53 brad Exp $	*/
a62 8
#endif

#if defined(CCITT) && defined(LLC)
#include <sys/socketvar.h>
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>
@


1.10
log
@martin' last commit made mc(4) reset the multicast filter twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.9 2004/12/15 06:48:23 martin Exp $	*/
d583 1
d585 1
@


1.9
log
@sync with NetBSD but replace hand crafted crc logic with ether_crc32_le()

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.8 2004/12/13 17:19:23 claudio Exp $	*/
a268 1
			mcreset(sc);
@


1.8
log
@Store the local ethernet address in struct arpcom and suddenly mc(4) starts
working. OK miod@@
@
text
@d1 2
a2 2
/*	$OpenBSD: if_mc.c,v 1.7 2002/04/20 00:17:05 miod Exp $	*/
/*	$NetBSD: if_mc.c,v 1.4 1998/01/12 19:22:09 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1997 David Huang <khym@@bga.com>
a193 1
	int	temp;
a251 1
			temp = ifp->if_flags & IFF_UP;
a252 1
			ifp->if_flags |= temp;
a268 1
			temp = ifp->if_flags & IFF_UP;
d270 2
a271 1
			ifp->if_flags |= temp;
d418 1
a418 1
	sc->sc_if.if_flags &= ~(IFF_RUNNING | IFF_UP);
a433 1
	int temp;
a435 1
	temp = ifp->if_flags & IFF_UP;
a436 1
	ifp->if_flags |= temp;
d462 1
a462 1
	if (totlen > NBPG)
d502 1
d504 1
d551 1
a630 8
#if NBPFILTER > 0
	/*
	 * Check if there's a bpf filter listening on this interface.
	 * If so, hand off the raw packet to enet.
	 */
	if (ifp->if_bpf)
		bpf_tap(ifp->if_bpf, pkt, len);
#endif
d639 6
a713 1
	register u_char *cp, c;
a714 1
	register int i, len;
a725 1

d740 2
a741 13
		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			c = *cp++;
			for (i = 8; --i >= 0;) {
				if ((crc & 0x01) ^ (c & 0x01)) {
					crc >>= 1;
					crc ^= 0xedb88320;
				} else
					crc >>= 1;
				c >>= 1;
			}
		}
d765 1
a765 1
	vm_offset_t o;
@


1.7
log
@Get rid of "integrate" and "hide" bad taste modifiers, thus get non-DDB
kernels to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.6 2002/03/14 01:26:35 millert Exp $	*/
d167 1
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.5 2001/11/06 19:53:14 miod Exp $	*/
d89 11
a99 11
hide void	mcwatchdog(struct ifnet *);
hide int	mcinit(struct mc_softc *sc);
hide int	mcstop(struct mc_softc *sc);
hide int	mcioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
hide void	mcstart(struct ifnet *ifp);
hide void	mcreset(struct mc_softc *sc);

integrate u_int	maceput(struct mc_softc *sc, struct mbuf *m0);
integrate void	mc_tint(struct mc_softc *sc);
integrate void	mace_read(struct mc_softc *, caddr_t, int);
integrate struct mbuf *mace_get(struct mc_softc *, caddr_t, int);
d182 1
a182 1
hide int
d287 1
a287 1
hide void
d328 1
a328 1
hide void
d336 1
a336 1
hide int
d410 1
a410 1
hide int
d431 1
a431 1
hide void
d447 1
a447 1
integrate u_int
d524 1
a524 1
integrate void
d569 1
a569 1
integrate void
d614 1
a614 1
integrate void
d659 1
a659 1
integrate struct mbuf *
@


1.5
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.4 2001/07/09 22:41:14 fgsch Exp $	*/
d89 13
a101 13
hide void	mcwatchdog __P((struct ifnet *));
hide int	mcinit __P((struct mc_softc *sc));
hide int	mcstop __P((struct mc_softc *sc));
hide int	mcioctl __P((struct ifnet *ifp, u_long cmd, caddr_t data));
hide void	mcstart __P((struct ifnet *ifp));
hide void	mcreset __P((struct mc_softc *sc));

integrate u_int	maceput __P((struct mc_softc *sc, struct mbuf *m0));
integrate void	mc_tint __P((struct mc_softc *sc));
integrate void	mace_read __P((struct mc_softc *, caddr_t, int));
integrate struct mbuf *mace_get __P((struct mc_softc *, caddr_t, int));
static void mace_calcladrf __P((struct arpcom *ac, u_int8_t *af));
static inline u_int16_t ether_cmp __P((void *, void *));
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.5 2001/11/06 19:53:14 miod Exp $	*/
d89 13
a101 13
void	mcwatchdog(struct ifnet *);
int	mcinit(struct mc_softc *sc);
int	mcstop(struct mc_softc *sc);
int	mcioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
void	mcstart(struct ifnet *ifp);
void	mcreset(struct mc_softc *sc);

u_int	maceput(struct mc_softc *sc, struct mbuf *m0);
void	mc_tint(struct mc_softc *sc);
void	mace_read(struct mc_softc *, caddr_t, int);
struct mbuf *mace_get(struct mc_softc *, caddr_t, int);
static void mace_calcladrf(struct arpcom *ac, u_int8_t *af);
static inline u_int16_t ether_cmp(void *, void *);
d182 1
a182 1
int
d287 1
a287 1
void
d328 1
a328 1
void
d336 1
a336 1
int
d410 1
a410 1
int
d431 1
a431 1
void
d447 1
a447 1
u_int
d524 1
a524 1
void
d569 1
a569 1
void
d614 1
a614 1
void
d659 1
a659 1
struct mbuf *
@


1.4
log
@Trivial ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.3 2001/02/20 19:39:31 mickey Exp $	*/
d73 1
a73 1
#include <vm/vm.h>
@


1.3
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.2 1999/05/13 15:44:49 jason Exp $	*/
a620 1
	struct ether_header *eh = (struct ether_header *)pkt;
d649 2
a650 3
	/* Pass the packet up, with the ether header sort-of removed. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.2
log
@Compensate for the check for onwership of unicast packets in promiscuous
mode being moved to if_ether.c.  This is the last of the drivers hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.1 1998/05/08 22:15:31 gene Exp $	*/
a175 4

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.2.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.3 2001/02/20 19:39:31 mickey Exp $	*/
d176 4
@


1.2.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.2.4.1 2001/04/18 16:10:06 niklas Exp $	*/
d621 1
d650 3
a652 2
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.2.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 1
a73 1
#include <uvm/uvm_extern.h>
@


1.2.4.4
log
@Merge in -current from about a week ago
@
text
@d89 6
a94 6
hide void	mcwatchdog(struct ifnet *);
hide int	mcinit(struct mc_softc *sc);
hide int	mcstop(struct mc_softc *sc);
hide int	mcioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
hide void	mcstart(struct ifnet *ifp);
hide void	mcreset(struct mc_softc *sc);
d96 6
a101 6
integrate u_int	maceput(struct mc_softc *sc, struct mbuf *m0);
integrate void	mc_tint(struct mc_softc *sc);
integrate void	mace_read(struct mc_softc *, caddr_t, int);
integrate struct mbuf *mace_get(struct mc_softc *, caddr_t, int);
static void mace_calcladrf(struct arpcom *ac, u_int8_t *af);
static inline u_int16_t ether_cmp(void *, void *);
@


1.2.4.5
log
@Sync the SMP branch with 3.3
@
text
@d89 11
a99 11
void	mcwatchdog(struct ifnet *);
int	mcinit(struct mc_softc *sc);
int	mcstop(struct mc_softc *sc);
int	mcioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
void	mcstart(struct ifnet *ifp);
void	mcreset(struct mc_softc *sc);

u_int	maceput(struct mc_softc *sc, struct mbuf *m0);
void	mc_tint(struct mc_softc *sc);
void	mace_read(struct mc_softc *, caddr_t, int);
struct mbuf *mace_get(struct mc_softc *, caddr_t, int);
d182 1
a182 1
int
d287 1
a287 1
void
d328 1
a328 1
void
d336 1
a336 1
int
d410 1
a410 1
int
d431 1
a431 1
void
d447 1
a447 1
u_int
d524 1
a524 1
void
d569 1
a569 1
void
d614 1
a614 1
void
d659 1
a659 1
struct mbuf *
@


1.1
log
@With the new psc framework, incorporate the driver for the AMD MACE ethernet
found on Quadra/Centris AV models.
Much of this done by Allen Briggs with porting to OpenBSD by me.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d641 1
a641 2
	 * If so, hand off the raw packet to enet, then discard things
	 * not destined for us (but be sure to keep broadcast/multicast).
d643 1
a643 1
	if (ifp->if_bpf) {
a644 5
		if ((ifp->if_flags & IFF_PROMISC) != 0 &&
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    ETHER_CMP(eh->ether_dhost, sc->sc_enaddr))
			return;
	}
@

