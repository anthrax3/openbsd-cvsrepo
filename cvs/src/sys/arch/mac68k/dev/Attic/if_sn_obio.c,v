head	1.25;
access;
symbols
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.18
	OPENBSD_5_0:1.24.0.16
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.14
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.12
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.8
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.10
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.6
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.10
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.8
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.6
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.16.0.16
	OPENBSD_2_9_BASE:1.16
	NIKLAS_UNDEAD:1.16.0.14
	OPENBSD_2_8:1.16.0.12
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.10
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.8
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.6
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13;
locks; strict;
comment	@ * @;


1.25
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.24;

1.24
date	2007.09.10.20.29.46;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.23.04.17.23;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.23.04.10.13;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.01.13.15.59;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.22.20.15.55;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.04.08.52.46;	author niklas;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	98.05.03.07.12.56;	author gene;	state Exp;
branches
	1.16.8.1;
next	1.15;

1.15
date	98.04.27.02.04.35;	author gene;	state Exp;
branches;
next	1.14;

1.14
date	97.06.18.02.59.28;	author denny;	state Exp;
branches;
next	1.13;

1.13
date	97.04.22.13.37.56;	author briggs;	state Exp;
branches;
next	1.12;

1.12
date	97.04.13.14.14.52;	author briggs;	state Exp;
branches;
next	1.11;

1.11
date	97.04.10.03.16.00;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.04.07.13.03.17;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.04.07.12.45.20;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.04.07.03.23.36;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.04.06.01.02.13;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	97.04.04.14.48.56;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	97.03.29.23.26.49;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	97.03.29.02.27.11;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	97.03.17.04.17.00;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	97.03.14.14.11.35;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	97.03.12.13.20.32;	author briggs;	state Exp;
branches;
next	;

1.16.8.1
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.16.8.2;

1.16.8.2
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.16.8.3;

1.16.8.3
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*    $OpenBSD: if_sn_obio.c,v 1.24 2007/09/10 20:29:46 miod Exp $    */
/*    $NetBSD: if_sn_obio.c,v 1.9 1997/04/22 20:56:15 scottr Exp $    */

/*
 * Copyright (C) 1997 Allen Briggs
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Allen Briggs
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/viareg.h>

#include <mac68k/dev/obiovar.h>
#include <mac68k/dev/if_snreg.h>
#include <mac68k/dev/if_snvar.h>

#define SONIC_REG_BASE	0x50F0A000
#define SONIC_PROM_BASE	0x50F08000

static int	sn_obio_match(struct device *, void *, void *);
static void	sn_obio_attach(struct device *, struct device *, void *);
static int	sn_obio_getaddr(struct sn_softc *, u_int8_t *);
static int	sn_obio_getaddr_kludge(struct sn_softc *, u_int8_t *);

struct cfattach sn_obio_ca = {
	sizeof(struct sn_softc), sn_obio_match, sn_obio_attach
};

static int
sn_obio_match(struct device *parent, void *cf, void *aux)
{
	struct obio_attach_args *oa = (struct obio_attach_args *)aux;
	bus_space_handle_t bsh;
	int found = 0;

	if (!mac68k_machine.sonic)
		return 0;

	if (bus_space_map(oa->oa_tag,
	    SONIC_REG_BASE, SN_REGSIZE, 0, &bsh))
		return 0;

	if (mac68k_bus_space_probe(oa->oa_tag, bsh, 0, 4))
		found = 1;

	bus_space_unmap(oa->oa_tag, bsh, SN_REGSIZE);

	return found;
}

/*
 * Install interface into kernel networking data structures
 */
static void
sn_obio_attach(struct device *parent, struct device *self, void *aux)
{
	struct obio_attach_args *oa = (struct obio_attach_args *)aux;
	struct sn_softc	*sc = (void *)self;
	u_int8_t myaddr[ETHER_ADDR_LEN];
	int i;

	sc->snr_dcr = DCR_WAIT0 | DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
	sc->snr_dcr2 = 0;

	sc->slotno = 9;

	switch (current_mac_model->machineid) {
	case MACH_MACC610:
	case MACH_MACC650:
	case MACH_MACQ610:
	case MACH_MACQ650:
	case MACH_MACQ700:
	case MACH_MACQ800:
	case MACH_MACQ900:
	case MACH_MACQ950:
		sc->snr_dcr |= DCR_EXBUS;
		sc->bitmode = 1;
		break;

	case MACH_MACLC575:
	case MACH_MACP580:
	case MACH_MACQ630:
		break;

	case MACH_MACPB500:
		sc->snr_dcr |= DCR_SYNC | DCR_LBR;
		sc->bitmode = 0;	/* 16 bit interface */
		break;

	default:
		printf(": unsupported machine type\n");
		return;
	}

	sc->sc_regt = oa->oa_tag;

	if (bus_space_map(sc->sc_regt,
	    SONIC_REG_BASE, SN_REGSIZE, 0, &sc->sc_regh)) {
		printf(": failed to map space for SONIC regs.\n");
		return;
	}

	/* regs are addressed as words, big-endian. */
	for (i = 0; i < SN_NREGS; i++) {
		sc->sc_reg_map[i] = (bus_size_t)((i * 4) + 2);
	}

	/*
	 * Kind of kludge this.  Comm-slot cards do not really
	 * have a visible type, as far as I can tell at this time,
	 * so assume that MacOS had it properly configured and use
	 * that configuration.
	 */
	switch (current_mac_model->machineid) {
	case MACH_MACLC575:
	case MACH_MACP580:
	case MACH_MACQ630:
		NIC_PUT(sc, SNR_CR, CR_RST);	wbflush();
		i = NIC_GET(sc, SNR_DCR);
		sc->snr_dcr |= (i & 0xfff0);
		sc->bitmode = (i & DCR_DW) ? 1 : 0;
		break;
	default:
		break;
	}

	if (sn_obio_getaddr(sc, myaddr) &&
	    sn_obio_getaddr_kludge(sc, myaddr)) { /* XXX kludge for PB */
		printf(": failed to get MAC address.\n");
		bus_space_unmap(sc->sc_regt, sc->sc_regh, SN_REGSIZE);
		return;
	}

	printf(": integrated ethernet adapter, ");

	/* snsetup returns 1 if something fails */
	if (snsetup(sc, myaddr)) {
		bus_space_unmap(sc->sc_regt, sc->sc_regh, SN_REGSIZE);
		return;
	}

	if (mac68k_machine.aux_interrupts)
		intr_establish(snintr, sc, 3, sc->sc_dev.dv_xname);
	else
		add_nubus_intr(sc->slotno, IPL_NET, snintr, sc,
		    sc->sc_dev.dv_xname);
}

static int
sn_obio_getaddr(struct sn_softc *sc, u_int8_t *lladdr)
{
	bus_space_handle_t bsh;

	if (bus_space_map(sc->sc_regt, SONIC_PROM_BASE, PAGE_SIZE, 0, &bsh)) {
		printf(": failed to map space to read SONIC address.\n%s",
		    sc->sc_dev.dv_xname);
		return (-1);
	}

	if (!mac68k_bus_space_probe(sc->sc_regt, bsh, 0, 1)) {
		bus_space_unmap(sc->sc_regt, bsh, PAGE_SIZE);
		return (-1);
	}

	sn_get_enaddr(sc->sc_regt, bsh, 0, lladdr);

	bus_space_unmap(sc->sc_regt, bsh, PAGE_SIZE);

	return (0);
}

/*
 * Assume that the SONIC was initialized in MacOS.  This should go away
 * when we can properly get the MAC address on the PBs.
 */
static int
sn_obio_getaddr_kludge(struct sn_softc *sc, u_int8_t *lladdr)
{
	int i, ors = 0;

	/* Shut down NIC */
	NIC_PUT(sc, SNR_CR, CR_RST);
	wbflush();

	NIC_PUT(sc, SNR_CEP, 15); /* For some reason, Apple fills top first. */
	wbflush();
	i = NIC_GET(sc, SNR_CAP2);
	wbflush();

	ors |= i;
	lladdr[5] = i >> 8;
	lladdr[4] = i;

	i = NIC_GET(sc, SNR_CAP1);
	wbflush();

	ors |= i;
	lladdr[3] = i >> 8;
	lladdr[2] = i;

	i = NIC_GET(sc, SNR_CAP0);
	wbflush();

	ors |= i;
	lladdr[1] = i >> 8;
	lladdr[0] = i;

	NIC_PUT(sc, SNR_CR, 0);
	wbflush();

	if (ors == 0)
		return (-1);

	return (0);
}
@


1.24
log
@Pass a real ipl level to add_nubus_intr(), and make sure the interrupt
handler is invoked with spl raised to the given level, otherwise all nubus
interrupts are processed at level 2.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.23 2006/03/23 04:17:23 brad Exp $    */
@


1.23
log
@Use PAGE_SIZE instead of NBPG.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.22 2006/03/23 04:10:13 brad Exp $    */
d184 2
a185 1
		add_nubus_intr(sc->slotno, snintr, sc, sc->sc_dev.dv_xname);
@


1.22
log
@ANSI and KNF.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.21 2006/01/01 13:15:59 miod Exp $    */
d42 2
d192 1
a192 1
	if (bus_space_map(sc->sc_regt, SONIC_PROM_BASE, NBPG, 0, &bsh)) {
d199 1
a199 1
		bus_space_unmap(sc->sc_regt, bsh, NBPG);
d205 1
a205 1
	bus_space_unmap(sc->sc_regt, bsh, NBPG);
@


1.21
log
@Enable A/UX style interrupt routing on non-AV Centrises and Quadras, gives us
smarter spl levels and the clock drift is reduced; adapted from NetBSD.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.20 2004/11/26 21:21:24 miod Exp $    */
d67 1
a67 4
sn_obio_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d92 1
a92 3
sn_obio_attach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
d186 1
a186 3
sn_obio_getaddr(sc, lladdr)
	struct sn_softc	*sc;
	u_int8_t *lladdr;
d205 1
a205 1
	return 0;
d213 1
a213 3
sn_obio_getaddr_kludge(sc, lladdr)
	struct sn_softc	*sc;
	u_int8_t *lladdr;
d248 1
a248 1
		return -1;
d250 1
a250 1
	return 0;
@


1.20
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.19 2002/04/22 20:15:55 miod Exp $    */
d184 4
a187 1
	add_nubus_intr(sc->slotno, snintr, sc, sc->sc_dev.dv_xname);
@


1.19
log
@Bring several stability and performance fixes from NetBSD, as well as
more hardware support.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.18 2002/03/14 01:26:35 millert Exp $    */
d184 1
a184 1
	add_nubus_intr(sc->slotno, snintr, (void *)sc);
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.17 2001/07/04 08:52:46 niklas Exp $    */
d50 3
a52 3
#include "obiovar.h"
#include "if_snreg.h"
#include "if_snvar.h"
d72 15
a86 2
	if (mac68k_machine.sonic)
		return 1;
d88 1
a88 1
	return 0;
d107 2
d122 5
a144 2
	sc->slotno = 9;

d150 19
d175 2
@


1.17
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.9 1997/04/22 20:56:15 scottr Exp $    */
d57 4
a60 4
static int	sn_obio_match __P((struct device *, void *, void *));
static void	sn_obio_attach __P((struct device *, struct device *, void *));
static int	sn_obio_getaddr __P((struct sn_softc *, u_int8_t *));
static int	sn_obio_getaddr_kludge __P((struct sn_softc *, u_int8_t *));
@


1.17.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_obio.c,v 1.17 2001/07/04 08:52:46 niklas Exp $    */
d50 3
a52 3
#include <mac68k/dev/obiovar.h>
#include <mac68k/dev/if_snreg.h>
#include <mac68k/dev/if_snvar.h>
d57 4
a60 4
static int	sn_obio_match(struct device *, void *, void *);
static void	sn_obio_attach(struct device *, struct device *, void *);
static int	sn_obio_getaddr(struct sn_softc *, u_int8_t *);
static int	sn_obio_getaddr_kludge(struct sn_softc *, u_int8_t *);
d72 2
a73 15
	struct obio_attach_args *oa = (struct obio_attach_args *)aux;
	bus_space_handle_t bsh;
	int found = 0;

	if (!mac68k_machine.sonic)
		return 0;

	if (bus_space_map(oa->oa_tag,
	    SONIC_REG_BASE, SN_REGSIZE, 0, &bsh))
		return 0;

	if (mac68k_bus_space_probe(oa->oa_tag, bsh, 0, 4))
		found = 1;

	bus_space_unmap(oa->oa_tag, bsh, SN_REGSIZE);
d75 1
a75 1
	return found;
a93 2
	sc->slotno = 9;

a106 5
	case MACH_MACLC575:
	case MACH_MACP580:
	case MACH_MACQ630:
		break;

d125 2
a131 19
	/*
	 * Kind of kludge this.  Comm-slot cards do not really
	 * have a visible type, as far as I can tell at this time,
	 * so assume that MacOS had it properly configured and use
	 * that configuration.
	 */
	switch (current_mac_model->machineid) {
	case MACH_MACLC575:
	case MACH_MACP580:
	case MACH_MACQ630:
		NIC_PUT(sc, SNR_CR, CR_RST);	wbflush();
		i = NIC_GET(sc, SNR_DCR);
		sc->snr_dcr |= (i & 0xfff0);
		sc->bitmode = (i & DCR_DW) ? 1 : 0;
		break;
	default:
		break;
	}

a137 2

	printf(": integrated ethernet adapter, ");
@


1.16
log
@Associated fallout from removing macinfo.h and merging to cpu.h.
@
text
@d1 1
@


1.16.8.1
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*    $OpenBSD$    */
@


1.16.8.2
log
@Merge in -current from about a week ago
@
text
@d57 4
a60 4
static int	sn_obio_match(struct device *, void *, void *);
static void	sn_obio_attach(struct device *, struct device *, void *);
static int	sn_obio_getaddr(struct sn_softc *, u_int8_t *);
static int	sn_obio_getaddr_kludge(struct sn_softc *, u_int8_t *);
@


1.16.8.3
log
@Sync the SMP branch with 3.3
@
text
@d50 3
a52 3
#include <mac68k/dev/obiovar.h>
#include <mac68k/dev/if_snreg.h>
#include <mac68k/dev/if_snvar.h>
d72 2
a73 15
	struct obio_attach_args *oa = (struct obio_attach_args *)aux;
	bus_space_handle_t bsh;
	int found = 0;

	if (!mac68k_machine.sonic)
		return 0;

	if (bus_space_map(oa->oa_tag,
	    SONIC_REG_BASE, SN_REGSIZE, 0, &bsh))
		return 0;

	if (mac68k_bus_space_probe(oa->oa_tag, bsh, 0, 4))
		found = 1;

	bus_space_unmap(oa->oa_tag, bsh, SN_REGSIZE);
d75 1
a75 1
	return found;
a93 2
	sc->slotno = 9;

a106 5
	case MACH_MACLC575:
	case MACH_MACP580:
	case MACH_MACQ630:
		break;

d125 2
a131 19
	/*
	 * Kind of kludge this.  Comm-slot cards do not really
	 * have a visible type, as far as I can tell at this time,
	 * so assume that MacOS had it properly configured and use
	 * that configuration.
	 */
	switch (current_mac_model->machineid) {
	case MACH_MACLC575:
	case MACH_MACP580:
	case MACH_MACQ630:
		NIC_PUT(sc, SNR_CR, CR_RST);	wbflush();
		i = NIC_GET(sc, SNR_DCR);
		sc->snr_dcr |= (i & 0xfff0);
		sc->bitmode = (i & DCR_DW) ? 1 : 0;
		break;
	default:
		break;
	}

a137 2

	printf(": integrated ethernet adapter, ");
@


1.15
log
@Adapt to new bus_space functions after fixing namespace issues.
@
text
@d46 1
a46 1
#include <machine/macinfo.h>
@


1.14
log
@Make if_sn.c far more MI, eventually share with pica.
sonic_get is faster and simpler.
sn_ioctl works like other current ether drivers now.
Sync up with netbsd to ease maintenance; incorporate some "gratuitous" formatting changes so I won't have to do two totally seperate mods each time.
@
text
@d160 1
a160 1
	if (!bus_probe(sc->sc_regt, bsh, 0, 1)) {
@


1.13
log
@Some minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.12 1997/04/13 14:14:52 briggs Exp $	*/
a41 1

d58 2
a59 2
static int	sn_obio_getaddr __P((struct sn_softc *));
static int	sn_obio_getaddr_kludge __P((struct sn_softc *));
d66 1
a66 1
sn_obio_match(parent, vcf, aux)
d68 1
a68 1
	void *vcf;
d85 3
a87 2
	struct obio_attach_args *oa = (struct obio_attach_args *) aux;
        struct sn_softc *sc = (void *)self;
d90 1
a90 2
	sc->snr_dcr = DCR_WAIT0 | DCR_DMABLOCK |
			DCR_RFT16 | DCR_TFT16;
d94 9
a102 4
	case MACH_MACQ700: case MACH_MACQ900: case MACH_MACQ950:
	case MACH_MACQ800: case MACH_MACQ650: case MACH_MACC650:
	case MACH_MACC610: case MACH_MACQ610:
		sc->snr_dcr |= DCR_EXBUS | DCR_DW32;
d107 2
a108 2
		sc->snr_dcr |= DCR_SYNC | DCR_LBR | DCR_DW16;
  		sc->bitmode = 0;
d110 5
a114 1
        }
d118 4
a121 3
	if (bus_space_map(sc->sc_regt, SONIC_REG_BASE, SN_REGSIZE,
				0, &sc->sc_regh)) {
		panic("failed to map space for SONIC regs.\n");
d131 5
a135 7
	if (sn_obio_getaddr(sc)) {
		printf(": Failed to get MAC address.  Trying kludge.\n");
		if (sn_obio_getaddr_kludge(sc)) {
			printf("Kludge failed, too.  Attachment failed.\n");
			bus_space_unmap(sc->sc_regt, sc->sc_regh, SN_REGSIZE);
			return;
		}
d139 1
a139 1
	if (snsetup(sc)) {
d148 1
a148 1
sn_obio_getaddr(sc)
d150 1
d152 1
a152 1
	bus_space_handle_t	bsh;
d155 3
a157 1
		panic("failed to map space to read SONIC address.\n");
d162 1
a162 1
		return -1;
d165 1
a165 1
	sn_get_enaddr(sc->sc_regt, bsh, 0, sc->sc_arpcom.ac_enaddr);
d177 1
a177 1
sn_obio_getaddr_kludge(sc)
d179 1
d181 1
a181 1
	int			i, ors=0;
a183 2
	NIC_PUT(sc, SNR_CR, CR_STP);
	wbflush();
a185 4
	NIC_PUT(sc, SNR_IMR, 0);
	wbflush();
	NIC_PUT(sc, SNR_ISR, ISR_ALL);
	wbflush();
a186 2
	NIC_PUT(sc, SNR_CR, CR_RST);
	wbflush();
d193 2
a194 2
	sc->sc_enaddr[5] = i >> 8;
	sc->sc_enaddr[4] = i;
d200 2
a201 2
	sc->sc_enaddr[3] = i >> 8;
	sc->sc_enaddr[2] = i;
d207 2
a208 2
	sc->sc_enaddr[1] = i >> 8;
	sc->sc_enaddr[0] = i;
d213 4
a216 2
	if (ors == 0) return -1;
	return (0);
@


1.12
log
@Some updates based on information from Bob Nestor <rnestor@@metronet.com>
about his SONIC-T LC/PDS card.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.11 1997/04/10 03:16:00 briggs Exp $	*/
d123 1
a123 1
		printf("Failed to get MAC address.  Trying kludge.\n");
@


1.11
log
@Stop the SONIC before setting reset, not after...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.10 1997/04/07 13:03:17 briggs Exp $	*/
a139 3
static u_char bbr4[] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};
#define bbr(v)	((bbr4[(v)&0xf] << 4) | bbr4[((v)>>4) & 0xf])

a144 2
	int			i, do_bbr;
	u_char			b;
d155 1
a155 40
	/*
	 * For reasons known only to Apple, MAC addresses in the ethernet
	 * PROM are stored in Token Ring (IEEE 802.5) format, that is
	 * with all of the bits in each byte reversed (canonical bit format).
	 * When the address is read out it must be reversed to ethernet format
	 * before use.
	 *
	 * Apple has been assigned OUI's 08:00:07 and 00:a0:40. All onboard
	 * ethernet addresses on 68K machines should be in one of these
	 * two ranges.
	 *
	 * Here is where it gets complicated.
	 *
	 * The PMac 7200, 7500, 8500, and 9500 accidentally had the PROM
	 * written in standard ethernet format. The MacOS accounted for this
	 * in these systems, and did not reverse the bytes. Some other
	 * networking utilities were not so forgiving, and got confused.
	 * "Some" of Apple's Nubus ethernet cards also had their bits
	 * burned in ethernet format.
	 *
	 * Apple petitioned the IEEE and was granted the 00:05:02 (bit reversal
	 * of 00:a0:40) as well. As of OpenTransport 1.1.1, Apple removed
	 * their workaround and now reverses the bits regardless of
	 * what kind of machine it is. So PMac systems and the affected
	 * Nubus cards now use 00:05:02, instead of the 00:a0:40 for which they
	 * were intended.
	 *
	 * See Apple Techinfo article TECHINFO-0020552, "OpenTransport 1.1.1
	 * and MacOS System 7.5.3 FAQ (10/96)" for more details.
	 */
	do_bbr = 0;
	b = bus_space_read_1(sc->sc_regt, bsh, 0);
	if (b == 0x10)
		do_bbr = 1;
	sc->sc_arpcom.ac_enaddr[0] = (do_bbr) ? bbr(b) : b;

	for (i = 1 ; i < ETHER_ADDR_LEN ; i++) {
		b = bus_space_read_1(sc->sc_regt, bsh, i);
		sc->sc_arpcom.ac_enaddr[i] = (do_bbr) ? bbr(b) : b;
	}
@


1.10
log
@Bleh.  bus_probe has opposite return of my fn.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.9 1997/04/07 12:45:20 briggs Exp $	*/
d217 2
a220 2
	NIC_PUT(sc, SNR_CR, CR_STP);
	wbflush();
d226 2
@


1.9
log
@Denny suggests that we make all Quadra cases the same.  The Q700, at least
seems to be able to work with the Q650 configuration, but not vice-versa.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.8 1997/04/07 03:23:36 briggs Exp $	*/
d155 1
a155 1
	if (bus_probe(sc->sc_regt, bsh, 0, 1)) {
@


1.8
log
@Ahem...  bus_probe() already exists and does what bus_space_bad_addr() does.
Nuke the latter.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.7 1997/04/06 01:02:13 briggs Exp $	*/
d95 3
a97 12
	case MACH_MACQ700:	/* only tested on Q700 */
	case MACH_MACQ900:
	case MACH_MACQ950:
		sc->snr_dcr |= DCR_SYNC | DCR_LBR | DCR_DW32;
		sc->bitmode = 1;
		break;
  
	case MACH_MACQ800:
	case MACH_MACQ650:
	case MACH_MACC650:
	case MACH_MACC610:
	case MACH_MACQ610:
@


1.7
log
@Attempt to kludge around the fact that we can not yet get the correct MAC
address for the SONIC on PB5xx series.  This uses the bus_space_bad_addr
function that I added earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.6 1997/04/04 14:48:56 briggs Exp $	*/
d164 1
a164 1
	if (bus_space_bad_addr(sc->sc_regt, bsh, 0, 1)) {
@


1.6
log
@Do not set DCR_SYNC for the C/Q[68]xx systems.
Thanks to Steve Brown <sbrown@@best.com> for working with me to find this.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.5 1997/03/29 23:26:49 briggs Exp $	*/
d59 2
a60 1
static void	sn_obio_getaddr __P((struct sn_softc *));
d118 1
a125 2
	sn_obio_getaddr(sc);

d131 9
d152 1
a152 1
static void
d164 5
d211 52
@


1.5
log
@Update from Denton Gentry with minor bug fixes by me.
Denny says:
if_sn.c:
        - allocate sc->space using malloc (Scott wanted this).
        - make csr accesses use NIC_PUT/GET, remove sc->sc_csr.
        - add multicast and IFF_PROMISC support. multicast isn't
                well tested, but I made sure the unicast case still
                works.
        - finish the new arp interface, remove sc->sc_enaddr
if_snreg.h:
        - remove struct sonic_reg
if_snvar.h:
        - add NIC_PUT and NIC_GET macros a la if_ae
        - remove sc_txhead, it isn't used.
if_sn_nubus.c:
        - clean up support for my SE/30 card.
        - Move add_nubus_intr from if_sn.c (to keep if_sn.c MI)
if_sn_obio.c:
        - make Q610, C610, Q650, C650, Q800 use EXBUS.
        - PB500 had a "return" where "break" was intended. PB500
                probably wasn't working.
        - move add_nubus_intr from if_sn.c.
        - add an "explanation" why Apple's ethernet addr is encoded
                in token ring format in the PROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.4 1997/03/29 02:27:11 briggs Exp $	*/
d89 1
a89 1
	sc->snr_dcr = DCR_SYNC | DCR_WAIT0 | DCR_DMABLOCK |
d97 1
a97 1
		sc->snr_dcr |= DCR_LBR | DCR_DW32;
d111 1
a111 1
		sc->snr_dcr |= DCR_LBR | DCR_DW16;
d162 1
a162 1
	 * Apple has been assigned OUI's 00:08:07 and 00:a0:40. All onboard
@


1.4
log
@Fix bug that would have prevented PB5xx series from detecting the SONIC.
Bug noticed by Denny Gentry.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.3 1997/03/17 04:17:00 briggs Exp $	*/
d87 1
d89 18
a106 7
        sc->s_dcr = DCR_LBR | DCR_SYNC | DCR_WAIT0 |
                    DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;

        switch (current_mac_model->class) {
        case MACH_CLASSQ:
        case MACH_CLASSQ2:
                sc->s_dcr |= DCR_DW32;
d108 1
a108 6
                break;

        case MACH_CLASSPB:
                sc->s_dcr |= DCR_DW16;
		sc->bitmode = 0;
                break;
d110 4
a113 3
	default:
		printf("unsupported machine type\n");
		return;
d126 12
a137 1
	snsetup(sc);
d156 28
a183 3
	 * Apparently Apple goofed here.  The ethernet MAC address is
	 * stored in bit-byte-reversed format.  It is rumored that this
	 * is only true for some systems.
@


1.3
log
@A couple of cleanup items suggested by is@@netbsd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_obio.c,v 1.2 1997/03/14 14:11:35 briggs Exp $	*/
d101 1
a101 1
                return;
@


1.2
log
@Updates from Yanagisawa and Denny.  This seems to work.
@
text
@d1 1
a1 2
/*	$NetBSD$	*/
/*	$OpenBSD: if_sn_obio.c,v 1.1 1997/03/12 13:20:32 briggs Exp $	*/
a42 1
#ifdef INET
a44 1
#endif
a59 1
void	snsetup __P((struct sn_softc *));
@


1.1
log
@Bring in some fresh SONIC code from Dennis Gentry and Yanagisawa Takeshi.
Much hacked by me to merge and partially busify.
Add code that I lost a while back for digging the proper mac address for
internal ethernet.
Still needs work, but checkpointed--works at least as well as the last
version.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d99 1
a99 1
		sc->sc_is16 = 0;
d104 1
a104 1
		sc->sc_is16 = 1;
@
