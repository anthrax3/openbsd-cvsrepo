head	1.35;
access;
symbols
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.22
	OPENBSD_5_0:1.34.0.20
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.18
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.16
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.12
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.14
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.10
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.8
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.6
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.21.0.6
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.4
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	NIKLAS_UNDEAD:1.14.0.10
	OPENBSD_2_8:1.14.0.8
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.6
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.10
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.8
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.6
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.13.0.4
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.34;

1.34
date	2007.01.22.13.17.45;	author martin;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.12.16.31.21;	author martin;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.03.21.17.44;	author martin;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.06.18.40.03;	author martin;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.14.09.36.49;	author martin;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.09.20.51.48;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.05.14.22.21;	author martin;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.15.05.24.09;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.03.12.10.47;	author todd;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.16.22.54.48;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.12.19.11.02;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.28.04.15.38;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.27.20.11.39;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.20.17.02.30;	author mpech;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.07.09.22.41.14;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.20.19.39.31;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	99.05.13.15.44.49;	author jason;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	97.04.25.22.15.26;	author gene;	state Exp;
branches;
next	1.12;

1.12
date	97.04.17.17.46.41;	author gene;	state Exp;
branches;
next	1.11;

1.11
date	97.03.25.04.58.43;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.03.08.16.16.52;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.01.24.01.35.31;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	96.05.26.18.35.23;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.05.26.18.13.40;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.05.05.13.37.17;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.02.04.16.22.48;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.02.02.23.14.56;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.01.14.20.57.35;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.28.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.04.18.16.10.05;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2004.06.05.23.10.51;	author niklas;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.35
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: if_ae.c,v 1.34 2007/01/22 13:17:45 martin Exp $	*/
/*	$NetBSD: if_ae.c,v 1.78 2006/09/09 06:25:08 tsutsui Exp $	*/

/*
 * Device driver for National Semiconductor DS8390/WD83C690 based ethernet
 * adapters.
 *
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Copyright (C) 1993, David Greenman.  This software may be used, modified,
 * copied, distributed, and sold, in both source and binary form provided that
 * the above copyright and these terms are retained.  Under no circumstances is
 * the author responsible for the proper functioning of this software, nor does
 * the author assume any responsibility for damages incurred with its use.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/mbuf.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <dev/ic/dp8390reg.h>
#include <dev/ic/dp8390var.h>
#include <mac68k/dev/if_aevar.h>

struct cfdriver ae_cd = {
	NULL, "ae", DV_IFNET
};

#define ETHER_PAD_LEN	(ETHER_MIN_LEN - ETHER_CRC_LEN)

int
ae_size_card_memory(bus_space_tag_t bst, bus_space_handle_t bsh, int ofs)
{
	int i1, i2, i3, i4, i8;

	/*
	 * banks; also assume it will generally mirror in upper banks
	 * if not installed.
	 */
	i1 = (8192 * 0);
	i2 = (8192 * 1);
	i3 = (8192 * 2);
	i4 = (8192 * 3);
	i8 = (8192 * 4);

	bus_space_write_2(bst, bsh, ofs + i8, 0x8888);
	bus_space_write_2(bst, bsh, ofs + i4, 0x4444);
	bus_space_write_2(bst, bsh, ofs + i3, 0x3333);
	bus_space_write_2(bst, bsh, ofs + i2, 0x2222);
	bus_space_write_2(bst, bsh, ofs + i1, 0x1111);

	/*
	 * 1) If the memory range is decoded completely, it does not
	 *    matter what we write first: High tags written into
	 *    the void are lost.
	 * 2) If the memory range is not decoded completely (banks are
	 *    mirrored), high tags are overwritten by lower ones.
	 * 3) Lazy implementation of pathological cases - none found yet.
	 */

	if (bus_space_read_2(bst, bsh, ofs + i1) == 0x1111 &&
	    bus_space_read_2(bst, bsh, ofs + i2) == 0x2222 &&
	    bus_space_read_2(bst, bsh, ofs + i3) == 0x3333 &&
	    bus_space_read_2(bst, bsh, ofs + i4) == 0x4444 &&
	    bus_space_read_2(bst, bsh, ofs + i8) == 0x8888)
		return 8192 * 8;

	if (bus_space_read_2(bst, bsh, ofs + i1) == 0x1111 &&
	    bus_space_read_2(bst, bsh, ofs + i2) == 0x2222 &&
	    bus_space_read_2(bst, bsh, ofs + i3) == 0x3333 &&
	    bus_space_read_2(bst, bsh, ofs + i4) == 0x4444)
		return 8192 * 4;

	if ((bus_space_read_2(bst, bsh, ofs + i1) == 0x1111 &&
	    bus_space_read_2(bst, bsh, ofs + i2) == 0x2222) ||
	    (bus_space_read_2(bst, bsh, ofs + i1) == 0x3333 &&
	    bus_space_read_2(bst, bsh, ofs + i2) == 0x4444))
		return 8192 * 2;

	if (bus_space_read_2(bst, bsh, ofs + i1) == 0x1111 ||
	    bus_space_read_2(bst, bsh, ofs + i1) == 0x4444)
		return 8192;

	return 0;
}

/*
 * Zero memory and verify that it is clear.  The only difference between
 * this and the default test_mem function is that the DP8390-based NuBus
 * cards * apparently require word-wide writes and byte-wide reads, an
 * `interesting' combination.
 */
int
ae_test_mem(struct dp8390_softc *sc)
{
	bus_space_tag_t buft = sc->sc_buft;
	bus_space_handle_t bufh = sc->sc_bufh;
	int i;

	bus_space_set_region_2(buft, bufh, sc->mem_start, 0,
	    sc->mem_size / 2);

	for (i = 0; i < sc->mem_size; ++i) {
		if (bus_space_read_1(sc->sc_buft, sc->sc_bufh, i)) {
			printf(": failed to clear NIC buffer at offset %x - "
			    "check configuration\n", (sc->mem_start + i));
			return 1;
		}
	}

	return 0;
}

/*
 * Copy packet from mbuf to the board memory Currently uses an extra
 * buffer/extra memory copy, unless the whole packet fits in one mbuf.
 *
 * As in the test_mem function, we use word-wide writes.
 */
int
ae_write_mbuf(struct dp8390_softc *sc, struct mbuf *m, int buf)
{
	u_char *data, savebyte[2];
	int len, wantbyte;
	u_short totlen = 0;

	wantbyte = 0;

	for (; m ; m = m->m_next) {
		data = mtod(m, u_char *);
		len = m->m_len;
		totlen += len;
		if (len > 0) {
			/* Finish the last word. */
			if (wantbyte) {
				savebyte[1] = *data;
				bus_space_write_region_2(sc->sc_buft,
				    sc->sc_bufh, buf, (u_int16_t *)savebyte, 1);
				buf += 2;
				data++;
				len--;
				wantbyte = 0;
			}
			/* Output contiguous words. */
			if (len > 1) {
				bus_space_write_region_2(
				    sc->sc_buft, sc->sc_bufh,
				    buf, (u_int16_t *)data, len >> 1);
				buf += len & ~1;
				data += len & ~1;
				len &= 1;
			}
			/* Save last byte, if necessary. */
			if (len == 1) {
				savebyte[0] = *data;
				wantbyte = 1;
			}
		}
	}

	len = ETHER_PAD_LEN - totlen;
	if (wantbyte) {
		savebyte[1] = 0;
		bus_space_write_region_2(sc->sc_buft, sc->sc_bufh,
		    buf, (u_int16_t *)savebyte, 1);
		buf += 2;
		if (len > 0)
			totlen++;
		len--;
	}
	/* if sent data is shorter than EHTER_PAD_LEN, put 0 to padding */
	if (len > 0) {
		bus_space_set_region_2(sc->sc_buft, sc->sc_bufh, buf, 0,
		    len >> 1);
		totlen = ETHER_PAD_LEN;
	}
	return (totlen);
}
@


1.34
log
@use the MI DP8390 driver instead of rolling our own functions

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.33
log
@fix altq for mc(4); make mbuf functions return NULL instead of 0 while
there

from Brad, tested by me on all three adapters
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ae.c,v 1.32 2007/01/03 21:17:44 martin Exp $	*/
/*	$NetBSD: if_ae.c,v 1.62 1997/04/24 16:52:05 scottr Exp $	*/
d21 1
a21 2
#include <sys/errno.h>
#include <sys/ioctl.h>
a23 2
#include <sys/syslog.h>
#include <sys/device.h>
a27 1
#include <net/netisr.h>
a28 1
#ifdef INET
d34 2
a35 1
#endif
a38 1
#include <net/bpfdesc.h>
a41 1
#include <machine/viareg.h>
d44 2
a45 15
#include "if_aereg.h"
#include "if_aevar.h"

#define inline			/* XXX for debugging porpoises */

static inline void ae_rint(struct ae_softc *);
static inline void ae_xmit(struct ae_softc *);
static inline int ae_ring_copy( struct ae_softc *, int, caddr_t, int);

#define NIC_GET(sc, reg)	(bus_space_read_1((sc)->sc_regt,	\
				    (sc)->sc_regh,			\
				    ((sc)->sc_reg_map[reg])))
#define NIC_PUT(sc, reg, val)	(bus_space_write_1((sc)->sc_regt,	\
				    (sc)->sc_regh,			\
				    ((sc)->sc_reg_map[reg]), (val)))
d51 2
d54 1
a54 4
ae_size_card_memory(bst, bsh, ofs)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	int ofs;
d110 4
a113 1
 * Do bus-independent setup.
d116 1
a116 2
aesetup(sc)
	struct ae_softc *sc;
d118 2
a119 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d122 2
a123 17
	sc->cr_proto = ED_CR_RD2;

	/* Allocate one xmit buffer if < 16k, two buffers otherwise. */
	if ((sc->mem_size < 16384) ||
	    (sc->sc_flags & AE_FLAGS_NO_DOUBLE_BUFFERING))
		sc->txb_cnt = 1;
	else
		sc->txb_cnt = 2;

	sc->tx_page_start = 0;
	sc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;
	sc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);
	sc->mem_ring = sc->rec_page_start << ED_PAGE_SHIFT;

	/* Now zero memory and verify that it is clear. */
	bus_space_set_region_2(sc->sc_buft, sc->sc_bufh,
	    0, 0, sc->mem_size / 2);
d127 2
a128 1
			printf(": failed to clear shared memory\n");
a132 22
	/* Set interface to stopped condition (reset). */
	aestop(sc);

	/* Initialize ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = aestart;
	ifp->if_ioctl = aeioctl;
	if (!ifp->if_watchdog)
		ifp->if_watchdog = aewatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	/* Print additional info when attached. */
	printf(": address %s, ", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	printf("%s, %dKB memory\n", sc->type_str, sc->mem_size / 1024);

d137 2
a138 857
 * Reset interface.
 */
void
aereset(sc)
	struct ae_softc *sc;
{
	int     s;

	s = splnet();
	aestop(sc);
	aeinit(sc);
	splx(s);
}

/*
 * Take interface offline.
 */
void
aestop(sc)
	struct ae_softc *sc;
{
	int     n = 5000;

	/* Stop everything on the interface, and select page 0 registers. */
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);

	/*
	 * Wait for interface to enter stopped state, but limit # of checks to
	 * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but
	 * just in case it's an old one.
	 */
	while (((NIC_GET(sc, ED_P0_ISR) & ED_ISR_RST) == 0) && --n);
}

/*
 * Device timeout/watchdog routine.  Entered if the device neglects to generate
 * an interrupt after a transmit has been started on it.
 */

void
aewatchdog(ifp)
	struct ifnet *ifp;
{
	struct ae_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	aereset(sc);
}

/*
 * Initialize device.
 */
void
aeinit(sc)
	struct ae_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int8_t mcaf[8];
	int i;

	/*
	 * Initialize the NIC in the exact order outlined in the NS manual.
	 * This init procedure is "mandatory"...don't change what or when
	 * things happen.
	 */

	/* Reset transmitter flags. */
	ifp->if_timer = 0;

	sc->txb_inuse = 0;
	sc->txb_new = 0;
	sc->txb_next_tx = 0;

	/* Set interface for page 0, remote DMA complete, stopped. */
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);

	if (sc->use16bit) {
		/*
		 * Set FIFO threshold to 8, No auto-init Remote DMA, byte
		 * order=80x86, word-wide DMA xfers,
		 */
		NIC_PUT(sc, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
	} else {
		/* Same as above, but byte-wide DMA xfers. */
		NIC_PUT(sc, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
	}

	/* Clear remote byte count registers. */
	NIC_PUT(sc, ED_P0_RBCR0, 0);
	NIC_PUT(sc, ED_P0_RBCR1, 0);

	/* Tell RCR to do nothing for now. */
	NIC_PUT(sc, ED_P0_RCR, ED_RCR_MON);

	/* Place NIC in internal loopback mode. */
	NIC_PUT(sc, ED_P0_TCR, ED_TCR_LB0);

	/* Initialize receive buffer ring. */
	NIC_PUT(sc, ED_P0_TPSR, sc->rec_page_start);
	NIC_PUT(sc, ED_P0_PSTART, sc->rec_page_start);

	NIC_PUT(sc, ED_P0_PSTOP, sc->rec_page_stop);
	NIC_PUT(sc, ED_P0_BNRY, sc->rec_page_start);

	/*
	 * Clear all interrupts.  A '1' in each bit position clears the
	 * corresponding flag.
	 */
	NIC_PUT(sc, ED_P0_ISR, 0xff);

	/*
	 * Enable the following interrupts: receive/transmit complete,
	 * receive/transmit error, and Receiver OverWrite.
	 *
	 * Counter overflow and Remote DMA complete are *not* enabled.
	 */
	NIC_PUT(sc, ED_P0_IMR,
	    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |
	    ED_IMR_OVWE);

	/* Program command register for page 1. */
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);

	/* Copy out our station address. */
	for (i = 0; i < ETHER_ADDR_LEN; ++i)
		NIC_PUT(sc, ED_P1_PAR0 + i, sc->sc_arpcom.ac_enaddr[i]);

	/* Set multicast filter on chip. */
	ae_getmcaf(&sc->sc_arpcom, mcaf);
	for (i = 0; i < 8; i++)
		NIC_PUT(sc, ED_P1_MAR0 + i, mcaf[i]);

	/*
	 * Set current page pointer to one page after the boundary pointer, as
	 * recommended in the National manual.
	 */
	sc->next_packet = sc->rec_page_start + 1;
	NIC_PUT(sc, ED_P1_CURR, sc->next_packet);

	/* Program command register for page 0. */
	NIC_PUT(sc, ED_P1_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);

	i = ED_RCR_AB | ED_RCR_AM;
	if (ifp->if_flags & IFF_PROMISC) {
		/*
		 * Set promiscuous mode.  Multicast filter was set earlier so
		 * that we should receive all multicast packets.
		 */
		i |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;
	}
	NIC_PUT(sc, ED_P0_RCR, i);

	/* Take interface out of loopback. */
	NIC_PUT(sc, ED_P0_TCR, 0);

	/* Fire up the interface. */
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	/* Set 'running' flag, and clear output active flag. */
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	/* ...and attempt to start output. */
	aestart(ifp);
}

/*
 * This routine actually starts the transmission on the interface.
 */
static inline void
ae_xmit(sc)
	struct ae_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_short len;

	len = sc->txb_len[sc->txb_next_tx];

	/* Set NIC for page 0 register access. */
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	/* Set TX buffer start page. */
	NIC_PUT(sc, ED_P0_TPSR, sc->tx_page_start +
	    sc->txb_next_tx * ED_TXBUF_SIZE);

	/* Set TX length. */
	NIC_PUT(sc, ED_P0_TBCR0, len);
	NIC_PUT(sc, ED_P0_TBCR1, len >> 8);

	/* Set page 0, remote DMA complete, transmit packet, and *start*. */
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP |
	    ED_CR_STA);

	/* Point to next transmit buffer slot and wrap if necessary. */
	sc->txb_next_tx++;
	if (sc->txb_next_tx == sc->txb_cnt)
		sc->txb_next_tx = 0;

	/* Set a timer just in case we never hear from the board again. */
	ifp->if_timer = 2;
}

/*
 * Start output on interface.
 * We make two assumptions here:
 *  1) that the current priority is set to splnet _before_ this code
 *     is called *and* is returned to the appropriate priority after
 *     return
 *  2) that the IFF_OACTIVE flag is checked before this code is called
 *     (i.e. that the output part of the interface is idle)
 */
void
aestart(ifp)
	struct ifnet *ifp;
{
	struct ae_softc *sc = ifp->if_softc;
	struct mbuf *m0;
	int buffer;
	int len;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

outloop:
	/* See if there is room to put another packet in the buffer. */
	if (sc->txb_inuse == sc->txb_cnt) {
		/* No room.  Indicate this to the outside world and exit. */
		ifp->if_flags |= IFF_OACTIVE;
		return;
	}
	IF_DEQUEUE(&ifp->if_snd, m0);
	if (m0 == NULL)
		return;

	/* We need to use m->m_pkthdr.len, so require the header */
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("aestart: no header mbuf");

#if NBPFILTER > 0
	/* Tap off here if there is a BPF listener. */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	/* txb_new points to next open buffer slot. */
	buffer = (sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT;

	len = ae_put(sc, m0, buffer);
#ifdef DIAGNOSTIC
	if (len != m0->m_pkthdr.len)
		printf("aestart: len %d != m0->m_pkthdr.len %d.\n",
			len, m0->m_pkthdr.len);
#endif
	len = m0->m_pkthdr.len;

	m_freem(m0);
	sc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);

	/* Start the first packet transmitting. */
	if (sc->txb_inuse == 0)
		ae_xmit(sc);

	/* Point to next buffer slot and wrap if necessary. */
	if (++sc->txb_new == sc->txb_cnt)
		sc->txb_new = 0;

	sc->txb_inuse++;

	/* Loop back to the top to possibly buffer more packets. */
	goto outloop;
}

/*
 * Ethernet interface receiver interrupt.
 */
static inline void
ae_rint(sc)
	struct ae_softc *sc;
{
	u_char boundary, current;
	u_short len;
	u_char nlen;
	u_int8_t *lenp;
	struct ae_ring packet_hdr;
	int packet_ptr;

loop:
	/* Set NIC to page 1 registers to get 'current' pointer. */
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);

	/*
	 * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.
	 * it points to where new data has been buffered.  The 'CURR' (current)
	 * register points to the logical end of the ring-buffer - i.e. it
	 * points to where additional new data will be added.  We loop here
	 * until the logical beginning equals the logical end (or in other
	 * words, until the ring-buffer is empty).
	 */
	current = NIC_GET(sc, ED_P1_CURR);
	if (sc->next_packet == current)
		return;

	/* Set NIC to page 0 registers to update boundary register. */
	NIC_PUT(sc, ED_P1_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	do {
		/* Get pointer to this buffer's header structure. */
		packet_ptr = sc->mem_ring +
		    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);

		/*
		 * The byte count includes a 4 byte header that was added by
		 * the NIC.
		 */
		bus_space_read_region_1(sc->sc_buft, sc->sc_bufh,
		    packet_ptr, (u_int8_t *)&packet_hdr,
		    sizeof(struct ae_ring));
		lenp = (u_int8_t *)&packet_hdr.count; /* sigh. */
		len = lenp[0] | (lenp[1] << 8);
		packet_hdr.count = len;

		/*
		 * Try do deal with old, buggy chips that sometimes duplicate
		 * the low byte of the length into the high byte.  We do this
		 * by simply ignoring the high byte of the length and always
		 * recalculating it.
		 *
		 * NOTE: sc->next_packet is pointing at the current packet.
		 */
		if (packet_hdr.next_packet >= sc->next_packet)
			nlen = (packet_hdr.next_packet - sc->next_packet);
		else
			nlen = ((packet_hdr.next_packet - sc->rec_page_start) +
			    (sc->rec_page_stop - sc->next_packet));
		--nlen;
		if ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)
			--nlen;
		len = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);
#ifdef DIAGNOSTIC
		if (len != packet_hdr.count) {
			printf("%s: length does not match next packet pointer\n"			     , sc->sc_dev.dv_xname);
			printf("%s: len %04x nlen %04x start %02x first %02x curr %02x next %02x stop %02x\n",
			    sc->sc_dev.dv_xname, packet_hdr.count, len,
			    sc->rec_page_start, sc->next_packet, current,
			    packet_hdr.next_packet, sc->rec_page_stop);
		}
#endif

		/*
		 * Be fairly liberal about what we allow as a "reasonable"
		 * length so that a [crufty] packet will make it to BPF (and
		 * can thus be analyzed).  Note that all that is really
		 * important is that we have a length that will fit into one
		 * mbuf cluster or less; the upper layer protocols can then
		 * figure out the length from their own length field(s).
		 */
		if (len <= MCLBYTES &&
		    packet_hdr.next_packet >= sc->rec_page_start &&
		    packet_hdr.next_packet < sc->rec_page_stop) {
			/* Go get packet. */
			aeread(sc, packet_ptr + sizeof(struct ae_ring),
			    len - sizeof(struct ae_ring));
			++sc->sc_arpcom.ac_if.if_ipackets;
		} else {
			/* Really BAD.  The ring pointers are corrupted. */
			log(LOG_ERR,
			    "%s: NIC memory corrupt - invalid packet length %d\n",
			    sc->sc_dev.dv_xname, len);
			++sc->sc_arpcom.ac_if.if_ierrors;
			aereset(sc);
			return;
		}

		/* Update next packet pointer. */
		sc->next_packet = packet_hdr.next_packet;

		/*
		 * Update NIC boundary pointer - being careful to keep it one
		 * buffer behind (as recommended by NS databook).
		 */
		boundary = sc->next_packet - 1;
		if (boundary < sc->rec_page_start)
			boundary = sc->rec_page_stop - 1;
		NIC_PUT(sc, ED_P0_BNRY, boundary);
	} while (sc->next_packet != current);

	goto loop;
}

/* Ethernet interface interrupt processor. */
int
aeintr(void *arg)
{
	struct ae_softc *sc = (struct ae_softc *)arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_char isr;

	/* Set NIC to page 0 registers. */
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	isr = NIC_GET(sc, ED_P0_ISR);
	if (!isr)
		return (0);

	/* Loop until there are no more new interrupts. */
	for (;;) {
		/*
		 * Reset all the bits that we are 'acknowledging' by writing a
		 * '1' to each bit position that was set.
		 * (Writing a '1' *clears* the bit.)
		 */
		NIC_PUT(sc, ED_P0_ISR, isr);

		/*
		 * Handle transmitter interrupts.  Handle these first because
		 * the receiver will reset the board under some conditions.
		 */
		if (isr & (ED_ISR_PTX | ED_ISR_TXE)) {
			u_char  collisions = NIC_GET(sc, ED_P0_NCR) & 0x0f;

			/*
			 * Check for transmit error.  If a TX completed with an
			 * error, we end up throwing the packet away.  Really
			 * the only error that is possible is excessive
			 * collisions, and in this case it is best to allow the
			 * automatic mechanisms of TCP to backoff the flow.  Of
			 * course, with UDP we're screwed, but this is expected
			 * when a network is heavily loaded.
			 */
			(void) NIC_GET(sc, ED_P0_TSR);
			if (isr & ED_ISR_TXE) {
				/*
				 * Excessive collisions (16).
				 */
				if ((NIC_GET(sc, ED_P0_TSR) & ED_TSR_ABT)
				    && (collisions == 0)) {
					/*
					 * When collisions total 16, the P0_NCR
					 * will indicate 0, and the TSR_ABT is
					 * set.
					 */
					collisions = 16;
				}

				/* Update output errors counter. */
				++ifp->if_oerrors;
			} else {
				/*
				 * Update total number of successfully
				 * transmitted packets.
				 */
				++ifp->if_opackets;
			}

			/* Done with the buffer. */
			sc->txb_inuse--;

			/* Clear watchdog timer. */
			ifp->if_timer = 0;
			ifp->if_flags &= ~IFF_OACTIVE;

			/*
			 * Add in total number of collisions on last
			 * transmission.
			 */
			ifp->if_collisions += collisions;

			/*
			 * Decrement buffer in-use count if not zero (can only
			 * be zero if a transmitter interrupt occurred while not
			 * actually transmitting).
			 * If data is ready to transmit, start it transmitting,
			 * otherwise defer until after handling receiver.
			 */
			if (sc->txb_inuse > 0)
				ae_xmit(sc);
		}

		/* Handle receiver interrupts. */
		if (isr & (ED_ISR_PRX | ED_ISR_RXE | ED_ISR_OVW)) {
			/*
			 * Overwrite warning.  In order to make sure that a
			 * lockup of the local DMA hasn't occurred, we reset
			 * and re-init the NIC.  The NSC manual suggests only a
			 * partial reset/re-init is necessary - but some chips
			 * seem to want more.  The DMA lockup has been seen
			 * only with early rev chips - Methinks this bug was
			 * fixed in later revs.  -DG
			 */
			if (isr & ED_ISR_OVW) {
				++ifp->if_ierrors;
#ifdef DIAGNOSTIC
				log(LOG_WARNING,
				    "%s: warning - receiver ring buffer overrun\n",
				    sc->sc_dev.dv_xname);
#endif
				/* Stop/reset/re-init NIC. */
				aereset(sc);
			} else {
				/*
				 * Receiver Error.  One or more of: CRC error,
				 * frame alignment error FIFO overrun, or
				 * missed packet.
				 */
				if (isr & ED_ISR_RXE) {
					++ifp->if_ierrors;
#ifdef AE_DEBUG
					printf("%s: receive error %x\n",
					    sc->sc_dev.dv_xname,
					    NIC_GET(sc, ED_P0_RSR));
#endif
				}

				/*
				 * Go get the packet(s)
				 * XXX - Doing this on an error is dubious
				 * because there shouldn't be any data to get
				 * (we've configured the interface to not
				 * accept packets with errors).
				 */
				ae_rint(sc);
			}
		}

		/*
		 * If it looks like the transmitter can take more data, attempt
		 * to start output on the interface.  This is done after
		 * handling the receiver to give the receiver priority.
		 */
		aestart(ifp);

		/*
		 * Return NIC CR to standard state: page 0, remote DMA
		 * complete, start (toggling the TXP bit off, even if was just
		 * set in the transmit routine, is *okay* - it is 'edge'
		 * triggered from low to high).
		 */
		NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

		/*
		 * If the Network Talley Counters overflow, read them to reset
		 * them.  It appears that old 8390's won't clear the ISR flag
		 * otherwise - resulting in an infinite loop.
		 */
		if (isr & ED_ISR_CNT) {
			(void)NIC_GET(sc, ED_P0_CNTR0);
			(void)NIC_GET(sc, ED_P0_CNTR1);
			(void)NIC_GET(sc, ED_P0_CNTR2);
		}

		isr = NIC_GET(sc, ED_P0_ISR);
		if (!isr)
			break;
	}
	return (1);
}

/*
 * Process an ioctl request.
 * XXX - This code needs some work - it looks pretty ugly.
 */
int
aeioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ae_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *) data;
	struct ifreq *ifr = (struct ifreq *) data;
	int     s, error = 0;

	s = splnet();

	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			aeinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif
		default:
			aeinit(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			aestop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else
			if ((ifp->if_flags & IFF_UP) != 0 &&
			    (ifp->if_flags & IFF_RUNNING) == 0) {
				/*
				 * If interface is marked up and it is stopped, 				 * then start it.
				 */
				aeinit(sc);
			} else {
				/*
				 * Reset the interface to pick up changes in any
 				 * other flags that affect hardware registers.
				 */
				aestop(sc);
				aeinit(sc);
			}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/* Update our multicast list. */
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING) {
				aestop(sc);	/* XXX for ds_setmcaf? */
				aeinit(sc);
			}
			error = 0;
		}
		break;

	default:
		error = EINVAL;
		break;
	}

	splx(s);
	return (error);
}

/*
 * Retreive packet from shared memory and send to the next level up via
 * ether_input().  If there is a BPF listener, give a copy to BPF, too.
 */
void
aeread(sc, buf, len)
	struct ae_softc *sc;
	int buf;
	int len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;

	/* Pull packet off interface. */
	m = aeget(sc, buf, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to bpf.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);
}

/*
 * Supporting routines.
 */

/*
 * Given a source and destination address, copy 'amount' of a packet from the
 * ring buffer into a linear destination buffer.  Takes into account ring-wrap.
 */
static inline int
ae_ring_copy(sc, src, dst, amount)
	struct ae_softc *sc;
	int src;
	caddr_t dst;
	int amount;
{
	bus_space_tag_t bst = sc->sc_buft;
	bus_space_handle_t bsh = sc->sc_bufh;
	int tmp_amount;

	/* Does copy wrap to lower addr in ring buffer? */
	if (src + amount > sc->mem_size) {
		tmp_amount = sc->mem_size - src;

		/* Copy amount up to end of NIC memory. */
		bus_space_read_region_1(bst, bsh, src, dst, tmp_amount);

		amount -= tmp_amount;
		src = sc->mem_ring;
		dst += tmp_amount;
	}
	bus_space_read_region_1(bst, bsh, src, dst, amount);

	return (src + amount);
}

/*
 * Copy data from receive buffer to end of mbuf chain allocate additional mbufs
 * as needed.  Return pointer to last mbuf in chain.
 * sc = ae info (softc)
 * src = pointer in ae ring buffer
 * dst = pointer to last mbuf in mbuf chain to copy to
 * amount = amount of data to copy
 */
struct mbuf *
aeget(sc, src, total_len)
	struct ae_softc *sc;
	int src;
	u_short total_len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *top, **mp, *m;
	int len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = total_len;
	len = MHLEN;
	top = 0;
	mp = &top;

	while (total_len > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (NULL);
			}
			len = MLEN;
		}
		if (total_len >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_free(m);
				m_freem(top);
				return (NULL);
			}
			len = MCLBYTES;
		}
		m->m_len = len = min(total_len, len);
		src = ae_ring_copy(sc, src, mtod(m, caddr_t), len);
		total_len -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return top;
}

/*
 * Compute the multicast address filter from the list of multicast addresses we
 * need to listen to.
 */
void
ae_getmcaf(ac, af)
	struct arpcom *ac;
	u_char *af;
{
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	u_char *cp, c;
	u_int32_t crc;
	int i, len;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		for (i = 0; i < 8; i++)
			af[i] = 0xff;
		return;
	}
	for (i = 0; i < 8; i++)
		af[i] = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			sizeof(enm->enm_addrlo)) != 0) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			for (i = 0; i < 8; i++)
				af[i] = 0xff;
			return;
		}
		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			c = *cp++;
			for (i = 8; --i >= 0;) {
				if (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {
					crc <<= 1;
					crc ^= 0x04c11db6 | 1;
				} else
					crc <<= 1;
				c >>= 1;
			}
		}
		/* Just want the 6 most significant bits. */
		crc >>= 26;

		/* Turn on the corresponding bit in the filter. */
		af[crc >> 3] |= 1 << (crc & 0x7);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
}

/*
 * Copy packet from mbuf to the board memory
 *
 * Currently uses an extra buffer/extra memory copy,
 * unless the whole packet fits in one mbuf.
d140 1
d143 1
a143 4
ae_put(sc, m, buf)
	struct ae_softc *sc;
	struct mbuf *m;
	int buf;
d168 3
a170 3
				bus_space_write_region_2(sc->sc_buft,
				    sc->sc_bufh, buf, (u_int16_t *)data,
				    len >> 1);
d183 1
d188 10
@


1.32
log
@shorten dmesg a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.31 2006/12/06 18:40:03 martin Exp $	*/
d423 1
a423 1
	if (m0 == 0)
d859 1
a859 1
	if (m == 0) {
d932 3
a934 2
	if (m == 0)
		return 0;
d944 1
a944 1
			if (m == 0) {
d946 1
a946 1
				return 0;
d955 1
a955 1
				return 0;
@


1.31
log
@fix some multi-line comments and printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.30 2006/04/14 09:36:49 martin Exp $	*/
d184 1
a184 1
	printf("type %s, %dKB memory\n", sc->type_str, sc->mem_size / 1024);
@


1.30
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.29 2006/03/25 22:41:41 djm Exp $	*/
d159 1
a159 1
printf(": failed to clear shared memory - check configuration\n");
d382 2
a383 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);
d532 1
a532 2
			printf("%s: length does not match next packet pointer\n",
			    sc->sc_dev.dv_xname);
d802 1
a802 2
				 * If interface is marked up and it is stopped, then
				 * start it.
d807 2
a808 2
				 * Reset the interface to pick up changes in any other
				 * flags that affect hardware registers.
@


1.29
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.28 2006/01/09 20:51:48 miod Exp $	*/
d65 1
a65 1
  
d69 1
a69 1
  
@


1.28
log
@Remove duplicate defines with if_ether.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.27 2005/09/12 10:07:29 martin Exp $	*/
d432 1
a432 1
		bpf_mtap(ifp->if_bpf, m0);
d873 1
a873 1
		bpf_mtap(ifp->if_bpf, m);
@


1.27
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.26 2005/08/05 14:22:21 martin Exp $	*/
a57 4

#define	ETHER_MIN_LEN	64
#define ETHER_MAX_LEN	1518
#define	ETHER_ADDR_LEN	6
@


1.26
log
@- missing m_free()
- drop unused define

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.25 2005/01/15 05:24:09 brad Exp $	*/
d510 2
a511 1
		    packet_ptr, &packet_hdr, sizeof(struct ae_ring));
d1074 1
a1074 1
				    sc->sc_bufh, buf, savebyte, 1);
d1083 2
a1084 1
				    sc->sc_bufh, buf, data, len >> 1);
d1100 1
a1100 1
		    buf, savebyte, 1);
@


1.25
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.24 2004/11/26 21:21:24 miod Exp $	*/
a52 2
#define INTERFACE_NAME_LEN	32

a62 1

d956 1
@


1.24
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.23 2004/08/03 12:10:47 todd Exp $	*/
d834 4
a837 2
			aestop(sc);	/* XXX for ds_setmcaf? */
			aeinit(sc);
@


1.23
log
@the rest of the '#if DIAGNOSTIC' -> '#ifdef DIAGNOSTIC' in the kernel; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.22 2004/04/16 22:54:48 xsa Exp $	*/
d588 2
a589 4
void
aeintr(arg, slot)
	void *arg;
	int slot;
d600 1
a600 1
		return;
d750 1
a750 1
			return;
d752 1
@


1.22
log
@
probe correct amount of RAM on cards that have 64KB memory
>From: NetBSD
tested by Martin Reindl and nick@@.
ok nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.21 2003/03/12 19:11:02 jason Exp $	*/
d446 1
a446 1
#if DIAGNOSTIC
@


1.21
log
@backout the two previous patches, it breaks the 3com ae card and I don't
understand it enough to fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.18 2002/03/14 01:26:35 millert Exp $	*/
d83 1
a83 1
	int i1, i2, i3, i4;
d93 1
d95 4
d100 16
a115 3
	bus_space_write_2(bst, bsh, ofs + i2, 0x2222);
	bus_space_write_2(bst, bsh, ofs + i3, 0x3333);
	bus_space_write_2(bst, bsh, ofs + i4, 0x4444);
@


1.20
log
@Remove (now) bogus diagnostic check and set the output length correctly (why this was done in -two- places is beyone me); spotted and tested by Nick.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.19 2003/01/27 20:11:39 jason Exp $	*/
d428 7
d436 1
a436 1
	sc->txb_len[sc->txb_new] = len;
a1081 1
		buf += 2;
a1082 6
	if (totlen < ETHER_MIN_LEN - ETHER_CRC_LEN) {
		bus_space_set_region_2(sc->sc_buft, sc->sc_bufh, buf, 0,
		    (ETHER_MIN_LEN - ETHER_CRC_LEN - totlen) >> 1);
		totlen = ETHERMIN - ETHER_CRC_LEN;
	}

@


1.19
log
@padd < mimimum sized frames with 0's instead of whatever the chip wants; based on netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.18 2002/03/14 01:26:35 millert Exp $	*/
a427 7
#if DIAGNOSTIC
	if (len != m0->m_pkthdr.len)
		printf("aestart: len %d != m0->m_pkthdr.len %d.\n",
			len, m0->m_pkthdr.len);
#endif
	len = m0->m_pkthdr.len;

d429 1
a429 1
	sc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.17 2001/09/20 17:02:30 mpech Exp $	*/
d1082 1
d1084 6
@


1.17
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.16 2001/07/09 22:41:14 fgsch Exp $	*/
d57 3
a59 3
static inline void ae_rint __P((struct ae_softc *));
static inline void ae_xmit __P((struct ae_softc *));
static inline int ae_ring_copy __P(( struct ae_softc *, int, caddr_t, int));
@


1.17.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.17 2001/09/20 17:02:30 mpech Exp $	*/
d57 3
a59 3
static inline void ae_rint(struct ae_softc *);
static inline void ae_xmit(struct ae_softc *);
static inline int ae_ring_copy( struct ae_softc *, int, caddr_t, int);
@


1.16
log
@Trivial ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.15 2001/02/20 19:39:31 mickey Exp $	*/
d651 1
a651 1
			 * be zero if a transmitter interrupt occured while not
@


1.15
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.14 1999/05/13 15:44:49 jason Exp $	*/
a843 1
	struct ether_header *eh;
a853 3
	/* We assume that the header fits entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d863 1
a863 3
	/* Fix up data start offset in mbuf to point past ether header. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.14
log
@Compensate for the check for onwership of unicast packets in promiscuous
mode being moved to if_ether.c.  This is the last of the drivers hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.13 1997/04/25 22:15:26 gene Exp $	*/
a173 4

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.14.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.15 2001/02/20 19:39:31 mickey Exp $	*/
d174 4
@


1.14.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.14.4.1 2001/04/18 16:10:05 niklas Exp $	*/
d651 1
a651 1
			 * be zero if a transmitter interrupt occurred while not
d844 1
d855 3
d867 3
a869 1
	ether_input_mbuf(ifp, m);
@


1.14.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 3
a59 3
static inline void ae_rint(struct ae_softc *);
static inline void ae_xmit(struct ae_softc *);
static inline int ae_ring_copy( struct ae_softc *, int, caddr_t, int);
@


1.14.4.4
log
@Merge with the trunk
@
text
@d83 1
a83 1
	int i1, i2, i3, i4, i8;
a92 1
	i8 = (8192 * 4);
d94 3
a96 1
	bus_space_write_2(bst, bsh, ofs + i8, 0x8888);
a97 19
	bus_space_write_2(bst, bsh, ofs + i3, 0x3333);
	bus_space_write_2(bst, bsh, ofs + i2, 0x2222);
	bus_space_write_2(bst, bsh, ofs + i1, 0x1111);

	/*
	 * 1) If the memory range is decoded completely, it does not
	 *    matter what we write first: High tags written into
	 *    the void are lost.
	 * 2) If the memory range is not decoded completely (banks are
	 *    mirrored), high tags are overwritten by lower ones.
	 * 3) Lazy implementation of pathological cases - none found yet.
	 */

	if (bus_space_read_2(bst, bsh, ofs + i1) == 0x1111 &&
	    bus_space_read_2(bst, bsh, ofs + i2) == 0x2222 &&
	    bus_space_read_2(bst, bsh, ofs + i3) == 0x3333 &&
	    bus_space_read_2(bst, bsh, ofs + i4) == 0x4444 &&
	    bus_space_read_2(bst, bsh, ofs + i8) == 0x8888)
		return 8192 * 8;
@


1.13
log
@Cool.  Drop oversized packets rather than splitting into mbufs.  NetBSD log:
>From Mycroft:  If we fail to allocate a cluster to hold a large packet,
>simply drop it rather than using a chain of tiny mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae.c,v 1.12 1997/04/17 17:46:41 gene Exp $	*/
d867 1
a867 1
	if (ifp->if_bpf) {
a868 14

		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 &&	/* !mcast and !bcast */
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
			sizeof(eh->ether_dhost)) != 0) {
			m_freem(m);
			return;
		}
	}
@


1.12
log
@Changes earmarked 'purely cosmetic' by Scott Reynolds:
>- Remove unused `register' modifier on declarations
>- Reverse the sense of some tests to make the code more clear
>- Type casts per KNF
>- Move a static variable into the only function that uses it
>  (perhaps we can eliminate it entirely, someday?)
Also, I went through these files and XXX'ed some things that should be and
fixed a few more formatting problems per KNF.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ae.c,v 1.11 1997/03/25 04:58:43 briggs Exp $	*/
/*	$NetBSD: if_ae.c,v 1.61 1997/04/14 16:28:34 scottr Exp $	*/
d963 5
a967 2
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
@


1.11
log
@From scottr@@netbsd.org:
Several more changes to move us toward MI-ness:

 - Use more consistent and portable types in the softc.
 - Map registers using an array of bus_size_t offsets, and set up the
   mapping in the attach code (thanks to Jason Thorpe for suggesting
   this!).
 - Disable the ae-specific watchdog, which is no longer necessary in
   the general case.

Still remaining:  split out functions used to copy data to/from the
card, and retain a way to have a local driver name with the MI code.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ae.c,v 1.10 1997/03/08 16:16:52 briggs Exp $	*/
/*	$NetBSD: if_ae.c,v 1.60 1997/03/19 08:04:38 scottr Exp $	*/
d242 2
a243 2
	int     i;
	u_char  mcaf[8];
d463 1
a463 1
	u_char  boundary, current;
d465 1
a465 1
	u_char  nlen;
d743 2
a744 1
 * Process an ioctl request.  This code needs some work - it looks pretty ugly.
d748 1
a748 1
	register struct ifnet *ifp;
d753 1
a753 1
	register struct ifaddr *ifa = (struct ifaddr *) data;
d893 1
d987 3
a989 3
	register u_char *cp, c;
	register u_long crc;
	register int i, len;
@


1.10
log
@Sync with NetBSD of about 4 March.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ae.c,v 1.9 1997/01/24 01:35:31 briggs Exp $	*/
/*	$NetBSD: if_ae.c,v 1.57 1997/03/04 15:12:04 scottr Exp $	*/
a14 3
 *
 * Adapted for MacBSD by Brad Parker <brad@@fcr.com>.
 *
a65 1
#define REG_MAP(sc, reg)	((sc)->regs_rev ? (0x0f-(reg))<<2 : (reg)<<2)
d68 1
a68 1
				    (REG_MAP(sc, reg))))
d71 1
a71 1
				    (REG_MAP(sc, reg)), (val)))
@


1.9
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ae.c,v 1.8 1996/05/26 18:35:23 briggs Exp $	*/
/*	$NetBSD: if_ae.c,v 1.50 1996/12/18 02:54:43 scottr Exp $	*/
a22 1
#include <sys/types.h>
d49 1
d51 1
a51 1
#include "nubus.h"
d54 1
a57 56
/*
 * ae_softc: per line info and status
 */
struct ae_softc {
	struct device	sc_dev;
	nubus_slot	sc_slot;
/*	struct	intrhand sc_ih;	*/

	struct arpcom sc_arpcom;/* ethernet common */

	char	type_str[INTERFACE_NAME_LEN];	/* type string */
	u_short	type;		/* interface type code */
	u_char	vendor;		/* interface vendor */
	u_char	regs_rev;	/* registers are reversed */

#define	REG_MAP(sc, reg)	((sc)->regs_rev ? (0x0f-(reg))<<2 : (reg)<<2)
#define NIC_GET(sc, reg)	((sc)->nic_addr[REG_MAP(sc, reg)])
#define NIC_PUT(sc, reg, val)	((sc)->nic_addr[REG_MAP(sc, reg)] = (val))
	volatile caddr_t nic_addr;	/* NIC (DS8390) I/O bus address */
	caddr_t rom_addr;	/* on board prom address */

	u_char  cr_proto;	/* values always set in CR */

	caddr_t mem_start;	/* shared memory start address */
	caddr_t mem_end;	/* shared memory end address */
	u_long  mem_size;	/* total shared memory size */
	caddr_t mem_ring;	/* start of RX ring-buffer (in smem) */

	u_char  txb_cnt;	/* Number of transmit buffers */
	u_char  txb_inuse;	/* number of transmit buffers active */

	u_char  txb_new;	/* pointer to where new buffer will be added */
	u_char  txb_next_tx;	/* pointer to next buffer ready to xmit */
	u_short txb_len[8];	/* buffered xmit buffer lengths */
	u_char  tx_page_start;	/* first page of TX buffer area */
	u_char  rec_page_start;	/* first page of RX ring-buffer */
	u_char  rec_page_stop;	/* last page of RX ring-buffer */
	u_char  next_packet;	/* pointer to next unread RX packet */
};

static int	ae_card_vendor __P((struct nubus_attach_args *na));
static int	ae_size_card_memory __P((caddr_t addr));

int aematch __P((struct device *, struct cfdata *, void *));
void aeattach __P((struct device *, struct device *, void *));
void aeintr __P((void *, int));
int aeioctl __P((struct ifnet *, u_long, caddr_t));
void aestart __P((struct ifnet *));
void aewatchdog __P((struct ifnet *));
void aereset __P((struct ae_softc *));
void aeinit __P((struct ae_softc *));
void aestop __P((struct ae_softc *));

void aeread __P((struct ae_softc *, caddr_t, int));
struct mbuf *aeget __P((struct ae_softc *, caddr_t, int));

a59 3
u_short ae_put __P((struct ae_softc *, struct mbuf *, caddr_t));
void ae_getmcaf __P((struct arpcom *, u_char *));

d62 1
a62 10
static inline caddr_t ae_ring_copy __P((
		struct ae_softc *, caddr_t, caddr_t, int));

struct cfattach ae_ca = {
	sizeof(struct ae_softc), aematch, aeattach
};

struct cfdriver ae_cd = {
	NULL, "ae", DV_IFNET
};
a67 1
static char zero = 0;
d69 17
a85 88
/*
 * XXX These two should be moved to locore, and maybe changed to use shorts
 * instead of bytes.  The reason for these is that bcopy and bzero use longs,
 * which the ethernet cards can't handle.
 */

void			bszero __P((u_short *addr, int len));
static inline void	word_copy __P((caddr_t a, caddr_t b, int len));
static inline void	byte_copy __P((caddr_t a, caddr_t b, int len));

void
bszero(u_short * addr, int len)
{
	while (len--)
		*addr++ = 0;
}

/*
 * Memory copy, copies word at time.
 */
static inline void
word_copy(a, b, len)
	caddr_t a, b;
	int     len;
{
	u_short *x = (u_short *) a, *y = (u_short *) b;

	len >>= 1;
	while (len--)
		*y++ = *x++;
}

/*
 * Memory copy, copies bytes at time.
 */
static inline void
byte_copy(a, b, len)
	caddr_t a, b;
	int     len;
{
	while (len--)
		*b++ = *a++;
}

static int
ae_card_vendor(na)
	struct nubus_attach_args *na;
{
	int vendor;

	switch (na->drsw) {
	case NUBUS_DRSW_3COM:
	case NUBUS_DRSW_APPLE:
	case NUBUS_DRSW_TECHWORKS:
		vendor = AE_VENDOR_APPLE;
		break;
	case NUBUS_DRSW_ASANTE:
		vendor = AE_VENDOR_ASANTE;
		break;
	case NUBUS_DRSW_FARALLON:
		vendor = AE_VENDOR_FARALLON;
		break;
	case NUBUS_DRSW_FOCUS:
		vendor = AE_VENDOR_FOCUS;
		break;
	case NUBUS_DRSW_GATOR:
		switch (na->drhw) {
		default:
		case NUBUS_DRHW_INTERLAN:
			vendor = AE_VENDOR_INTERLAN;
			break;
		case NUBUS_DRHW_KINETICS:
			vendor = AE_VENDOR_DAYNA;
			break;
		}
		break;
	default:
#ifdef AE_DEBUG
		printf("Unknown ethernet drsw: %x\n", na->drsw);
#endif
		vendor = AE_VENDOR_UNKNOWN;
	}
	return vendor;
}

static int
ae_size_card_memory(addr)
	caddr_t addr;
d87 1
a87 4
	u_short *p;
	u_short i1, i2, i3, i4;

	p = (u_short *) addr;
a89 1
	 * very simple size memory, assuming it's installed in 8k
d93 14
a106 12
	i1 = (8192 * 0) / 2;
	i2 = (8192 * 1) / 2;
	i3 = (8192 * 2) / 2;
	i4 = (8192 * 3) / 2;

	p[i1] = 0x1111;
	p[i2] = 0x2222;
	p[i3] = 0x3333;
	p[i4] = 0x4444;

	if (p[i1] == 0x1111 && p[i2] == 0x2222 &&
	    p[i3] == 0x3333 && p[i4] == 0x4444)
d109 4
a112 2
	if ((p[i1] == 0x1111 && p[i2] == 0x2222) ||
	    (p[i1] == 0x3333 && p[i2] == 0x4444))
d115 2
a116 1
	if (p[i1] == 0x1111 || p[i1] == 0x4444)
a121 29
int
aematch(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
{
	struct nubus_attach_args *na = (struct nubus_attach_args *) aux;

	if (na->category != NUBUS_CATEGORY_NETWORK)
		return 0;

	if (na->type != NUBUS_TYPE_ETHERNET)
		return 0;

	switch (ae_card_vendor(na)) {
	case AE_VENDOR_APPLE:
	case AE_VENDOR_ASANTE:
	case AE_VENDOR_FARALLON:
	case AE_VENDOR_INTERLAN:
		break;

	case AE_VENDOR_DAYNA:
	case AE_VENDOR_FOCUS:
	default:
		return 0;
	}
	return 1;
}

d123 1
a123 1
 * Install interface into kernel networking data structures
d125 3
a127 4
void
aeattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
a128 2
	struct ae_softc *sc = (struct ae_softc *) self;
	struct nubus_attach_args *na = (struct nubus_attach_args *) aux;
d130 1
a130 84
	caddr_t addr;
	int i, memsize;
	int flags = 0;

	sc->regs_rev = 0;
	sc->vendor = ae_card_vendor(na);
	strncpy(sc->type_str, nubus_get_card_name(na->fmt),
	    INTERFACE_NAME_LEN);
	sc->type_str[INTERFACE_NAME_LEN-1] = '\0';

	addr = (caddr_t) na->fmt->virtual_base;
	memsize = 0;

	switch (sc->vendor) {
	case AE_VENDOR_INTERLAN:
		sc->nic_addr = addr + GC_NIC_OFFSET;
		sc->rom_addr = addr + GC_ROM_OFFSET;
		sc->mem_start = addr + GC_DATA_OFFSET;
		if ((memsize = ae_size_card_memory(sc->mem_start)) == 0) {
			printf(": failed to determine size of RAM.\n");
			return;
		}

		/* reset the NIC chip */
		*((caddr_t) addr + GC_RESET_OFFSET) = (char) zero;

		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] = *(sc->rom_addr + i * 4);
		break;

		/* apple-compatible cards */
	case AE_VENDOR_ASANTE:
	case AE_VENDOR_APPLE:
		sc->regs_rev = 1;
		sc->nic_addr = addr + AE_NIC_OFFSET;
		sc->rom_addr = addr + AE_ROM_OFFSET;
		sc->mem_start = addr + AE_DATA_OFFSET;
		if ((memsize = ae_size_card_memory(sc->mem_start)) == 0) {
			printf(": failed to determine size of RAM.\n");
			return;
		}

		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] = *(sc->rom_addr + i * 2);
		break;

	case AE_VENDOR_DAYNA:
		sc->nic_addr = addr + DP_NIC_OFFSET;
		sc->rom_addr = addr + DP_ROM_OFFSET;
		sc->mem_start = addr + DP_DATA_OFFSET;
		if ((memsize = ae_size_card_memory(sc->mem_start)) == 0) {
			printf(": failed to determine size of RAM.\n");
			return;
		}

		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] = *(sc->rom_addr + i * 4);

		break;

	case AE_VENDOR_FARALLON:
		sc->regs_rev = 1;
		sc->rom_addr = addr + FE_ROM_OFFSET;
		sc->nic_addr = addr + AE_NIC_OFFSET;
		sc->mem_start = addr + AE_DATA_OFFSET;
		if ((memsize = ae_size_card_memory(sc->mem_start)) == 0) {
			printf(": failed to determine size of RAM.\n");
			return;
		}

		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] = *(sc->rom_addr + i);
		break;
	case AE_VENDOR_FOCUS:
		printf(": unsupported Focus hardware\n");
		return;
	default:
		return;
		break;
	}
d135 2
a136 1
	if ((memsize < 16384) || (flags & AE_FLAGS_NO_DOUBLE_BUFFERING))
d143 2
a144 4
	sc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);
	sc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);
	sc->mem_size = memsize;
	sc->mem_end = sc->mem_start + memsize;
d147 2
a148 9
	bszero((u_short *) sc->mem_start, memsize / 2);

	for (i = 0; i < memsize; ++i)
		if (sc->mem_start[i])
printf("%s: failed to clear shared memory at %p - check configuration\n",
			    sc->sc_dev.dv_xname,
			    sc->mem_start + i);

	bcopy(na->fmt, &sc->sc_slot, sizeof(nubus_slot));
d150 6
d165 2
a166 1
	ifp->if_watchdog = aewatchdog;
d177 1
a177 1
	printf("type %s, %ldKB memory\n", sc->type_str, sc->mem_size / 1024);
d183 1
a183 10
	/* make sure interrupts are vectored to us */
	add_nubus_intr(sc->sc_slot.slot, aeintr, sc);

	/*
	 * XXX -- enable nubus interrupts here.  Should be done elsewhere,
	 *        but that currently breaks with some nubus video cards'
	 *	  interrupts.  So we only enable nubus interrupts if we
	 *	  have an ethernet card...  i.e., we do it here.
	 */
	enable_nubus_intr();
a224 1
static int aeintr_ctr = 0;
a231 19
#if 1
/*
 * This is a kludge!  The via code seems to miss slot interrupts
 * sometimes.  This kludges around that by calling the handler
 * by hand if the watchdog is activated. -- XXX (akb)
 */
	int     i;

	i = aeintr_ctr;

	(*via2itab[1]) ((void *) 1);

	if (i != aeintr_ctr) {
		log(LOG_ERR, "%s: device timeout, recovered\n",
		    sc->sc_dev.dv_xname);
		return;
	}
#endif

d265 10
a274 6
	/*
	 * Set FIFO threshold to 8, No auto-init Remote DMA, byte
	 * order=80x86, word-wide DMA xfers,
	 */
	NIC_PUT(sc, ED_P0_DCR,
	    ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
d405 2
a406 2
	caddr_t buffer;
	int     len;
d433 1
a433 1
	buffer = sc->mem_start + ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);
d469 2
a470 1
	u_char  nlen, *lenp;
d472 1
a472 1
	caddr_t packet_ptr;
d502 3
a504 2
		packet_hdr = *(struct ae_ring *) packet_ptr;
		lenp = (u_char *) &((struct ae_ring *) packet_ptr)->count;
d580 2
a581 2
	void	*arg;
	int	slot;
d583 1
a583 1
	struct ae_softc *sc = arg;
d585 1
a585 3
	u_char  isr;

	aeintr_ctr++;
d633 1
d667 1
d702 1
d713 1
d735 3
a737 4
			static u_char	dummy;
			dummy = NIC_GET(sc, ED_P0_CNTR0);
			dummy = NIC_GET(sc, ED_P0_CNTR1);
			dummy = NIC_GET(sc, ED_P0_CNTR2);
d739 1
d752 1
a752 1
	u_long  cmd;
d846 1
a846 1
	caddr_t buf;
d900 1
a900 1
static inline caddr_t
d903 2
a904 1
	caddr_t src, dst;
d907 3
a909 1
	u_short tmp_amount;
d912 2
a913 2
	if (src + amount > sc->mem_end) {
		tmp_amount = sc->mem_end - src;
d916 1
a916 1
		byte_copy(src, dst, tmp_amount);
d922 1
a922 1
	byte_copy(src, dst, amount);
d938 1
a938 1
	caddr_t src;
d969 1
a969 1
		src = ae_ring_copy(sc, src, mtod(m, caddr_t), (int) len);
d977 1
d1050 1
d1058 1
a1058 1
u_short
d1062 1
a1062 1
	caddr_t buf;
d1065 1
a1065 1
	int     len, wantbyte;
d1078 2
a1079 1
				word_copy(savebyte, buf, 2);
d1087 2
a1088 1
				word_copy(data, buf, len);
d1103 2
a1104 1
		word_copy(savebyte, buf, 2);
@


1.8
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: if_ae.c,v 1.46 1996/05/15 03:20:22 briggs Exp $	*/
a17 5
 * Currently supports:
 *	Apples NB Ethernet card
 *	Interlan A310 Nubus Ethernet card
 *	Cayman Systems GatorCard
 *	Asante MacCon II/E
d97 2
a98 2
static int	ae_id_card __P((nubus_slot *slot, struct ae_softc *sc));
static int	ae_size_card_memory __P((struct ae_softc *sc));
d100 1
a100 1
int aeprobe __P((struct device *, void *, void *));
d124 1
a124 1
	sizeof(struct ae_softc), aeprobe, aeattach
d182 2
a183 3
ae_id_card(slot, sc)
	nubus_slot	*slot;
	struct ae_softc *sc;
d185 1
a185 3
	nubus_dir	dir;
	nubus_dirent	dirent;
	nubus_type	slottype;
d187 1
a187 21
	nubus_get_main_dir(slot, &dir);

	if (nubus_find_rsrc(slot, &dir, 0x80, &dirent) <= 0)
		return 0;

	nubus_get_dir_from_rsrc(slot, &dirent, &dir);

	if (nubus_find_rsrc(slot, &dir, NUBUS_RSRC_TYPE, &dirent) <= 0)
		return 0;

	if (nubus_get_ind_data(slot, &dirent,
		(caddr_t) &slottype, sizeof(nubus_type)) <= 0)
		return 0;

	if (slottype.category != NUBUS_CATEGORY_NETWORK)
		return 0;

	if (slottype.type != NUBUS_TYPE_ETHERNET)
		return 0;

	switch (slottype.drsw) {
d191 1
a191 1
		sc->vendor = AE_VENDOR_APPLE;
d194 1
a194 1
		sc->vendor = AE_VENDOR_ASANTE;
d197 1
a197 1
		sc->vendor = AE_VENDOR_FARALLON;
d200 1
a200 1
		sc->vendor = AE_VENDOR_FOCUS;
d203 1
a203 1
		switch (slottype.drhw) {
d206 1
a206 1
			sc->vendor = AE_VENDOR_INTERLAN;
d209 1
a209 1
			sc->vendor = AE_VENDOR_DAYNA;
d214 4
a217 3
		printf("Unknown ethernet drsw: %x\n", slottype.drsw);
		sc->vendor = AE_VENDOR_UNKNOWN;
		return 0;
d219 1
a219 6

	strncpy(sc->type_str, nubus_get_card_name(slot), INTERFACE_NAME_LEN);

	sc->type_str[INTERFACE_NAME_LEN-1] = '\0';

	return 1;
d223 2
a224 2
ae_size_card_memory(sc)
	struct ae_softc *sc;
d229 1
a229 1
	p = (u_short *) sc->mem_start;
d261 1
a261 1
aeprobe(parent, match, aux)
d263 2
a264 1
	void   *match, *aux;
d266 4
a269 5
	struct ae_softc *sc = match;
	nubus_slot *nu = (nubus_slot *) aux;
	caddr_t	addr;
	int     i, memsize;
	int     flags = 0;
d271 1
a271 1
	if (ae_id_card(nu, sc) <= 0)
d274 30
d305 4
d310 2
a311 1
	addr = (caddr_t) nu->virtual_base;
d318 3
a320 3
		if ((memsize = ae_size_card_memory(sc)) == 0) {
			printf("Failed to determine size of RAM.\n");
			return 0;
d338 3
a340 3
		if ((memsize = ae_size_card_memory(sc)) == 0) {
			printf("Failed to determine size of RAM.\n");
			return (0);
a348 1
		printf("We think we are a Dayna card, but ");
d352 4
a355 1
		memsize = 8192;
d359 2
a360 3
			sc->sc_arpcom.ac_enaddr[i] = *(sc->rom_addr + i * 2);
		printf("it is dangerous to continue.\n");
		return (0);	/* Since we don't work yet... */
d368 3
a370 3
		if ((memsize = ae_size_card_memory(sc)) == 0) {
			printf("Failed to determine size of RAM.\n");
			return (0);
a376 1

d378 2
a379 1
		printf("Focus EtherLAN card detected, but not supported.\n");
d381 1
a381 1
		return (0);
d404 1
a404 1
		if (sc->mem_start[i]) {
a407 2
			return (0);
		}
d409 1
a409 1
	bcopy(nu, &sc->sc_slot, sizeof(nubus_slot));
a410 13
	return (1);
}

/*
 * Install interface into kernel networking data structures
 */
void
aeattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
{
	struct ae_softc *sc = (void *) self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d431 1
a431 1
	printf("type %s, %ldk mem.\n", sc->type_str, sc->mem_size / 1024);
@


1.7
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.6
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d1 1
a1 1
/*	$NetBSD: if_ae.c,v 1.40 1996/02/02 15:30:56 briggs Exp $	*/
d54 1
a54 1
#include "../mac68k/via.h"
d101 3
d106 1
a106 1
void aeintr __P((void *));
d109 1
a109 1
void aewatchdog __P(( /* short */ ));
d125 5
a129 1
		/* struct ae_softc *, caddr_t, caddr_t, u_short */ ));
d131 2
a132 2
struct cfdriver aecd = {
	NULL, "ae", aeprobe, aeattach, DV_IFNET, sizeof(struct ae_softc)
a139 1
static u_char ones = 0xff;
d147 4
d241 1
d253 1
a253 1
int
a258 1
	int     size;
d307 1
a307 1
	addr = (caddr_t) NUBUS_SLOT_TO_BASE(nu->slot);
d314 2
a315 1
		if ((memsize = ae_size_card_memory(sc)) == 0)
d317 1
d334 2
a335 1
		if ((memsize = ae_size_card_memory(sc)) == 0)
d337 1
d363 2
a364 1
		if ((memsize = ae_size_card_memory(sc)) == 0)
d366 1
d400 1
a400 1
			printf("%s: failed to clear shared memory at %x - check configuration\n",
a419 2
	struct nubus_hw *nu = aux;
	struct cfdata *cf = sc->sc_dev.dv_cfdata;
d426 2
a427 2
	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = aecd.cd_name;
d441 1
a441 1
	printf("type %s, %dk mem.\n", sc->type_str, sc->mem_size / 1024);
d499 1
d501 2
a502 2
aewatchdog(unit)
	int     unit;
d504 1
a504 1
	struct ae_softc *sc = aecd.cd_devs[unit];
d516 1
a516 1
	(*via2itab[1]) (1);
d519 2
a520 1
		log(LOG_ERR, "ae%d: device timeout, recovered\n", unit);
a539 1
	u_char  command;
d692 1
a692 1
	struct ae_softc *sc = aecd.cd_devs[ifp->if_unit];
d866 3
a868 2
aeintr(arg)
	void *arg;
d1040 1
a1040 1
	struct ae_softc *sc = aecd.cd_devs[ifp->if_unit];
d1189 1
a1189 1
	u_short amount;
d1251 1
a1251 1
		src = ae_ring_copy(sc, src, mtod(m, caddr_t), len);
@


1.5
log
@Cosmetic unsigned char -> u_char
@
text
@a48 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d1031 5
a1046 18
#endif
#ifdef NS
			/* XXX - This code is probably wrong. */
		case AF_NS:
			{
				register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

				if (ns_nullhost(*ina))
					ina->x_host =
					    *(union ns_host *) (sc->sc_arpcom.ac_enaddr);
				else
					bcopy(ina->x_host.c_host,
					    sc->sc_arpcom.ac_enaddr,
					    sizeof(sc->sc_arpcom.ac_enaddr));
				/* Set new address. */
				aeinit(sc);
				break;
			}
@


1.4
log
@Force the talley counters to be read when we get the interrupt.  GCC
was nicely optimizing the reads out for us.  Kudos for this one go to
Steven R. Weiss <srw@@hvcn.org>.  (from netbsd)
@
text
@d1009 1
a1009 1
			static unsigned char	dummy;
@


1.3
log
@from netbsd:
Patch to at least recognise FOCUS EtherLAN.  From Erik Bertelson
<erik@@sockdev.uni-c.dk>
@
text
@d1 1
a1 1
/*	$NetBSD: if_ae.c,v 1.39 1996/01/13 14:03:38 briggs Exp $	*/
d1009 4
a1012 3
			(void) NIC_GET(sc, ED_P0_CNTR0);
			(void) NIC_GET(sc, ED_P0_CNTR1);
			(void) NIC_GET(sc, ED_P0_CNTR2);
@


1.2
log
@from netbsd:
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d1 1
a1 1
/*	$NetBSD: if_ae.c,v 1.37 1995/12/24 02:30:37 mycroft Exp $	*/
d221 3
d362 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_ae.c,v 1.36 1995/09/24 14:13:58 briggs Exp $	*/
d454 1
a454 1
	s = splimp();
d667 1
a667 1
 *  1) that the current priority is set to splimp _before_ this code
d1028 1
a1028 1
	s = splimp();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
