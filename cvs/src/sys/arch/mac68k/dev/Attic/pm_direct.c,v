head	1.14;
access;
symbols
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.20
	OPENBSD_5_0:1.13.0.18
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.16
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.14
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.10
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.12
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.16
	OPENBSD_2_9_BASE:1.3
	NIKLAS_UNDEAD:1.3.0.14
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.13;

1.13
date	2007.03.17.20.01.44;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.22.15.25.30;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.18.23.21.17;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.13.19.36.44;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.11.20.09.30;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.25.18.32.10;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.14.10.47.36;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.20.17.02.30;	author mpech;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	98.05.03.07.13.00;	author gene;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	97.04.06.16.35.18;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	97.02.23.06.04.56;	author briggs;	state Exp;
branches;
next	;

1.3.8.1
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.3.8.3;

1.3.8.3
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: pm_direct.c,v 1.13 2007/03/17 20:01:44 miod Exp $	*/
/*	$NetBSD: pm_direct.c,v 1.25 2005/10/28 21:54:52 christos Exp $	*/

/*
 * Copyright (C) 1997 Takashi Hamada
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Takashi Hamada
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/* From: pm_direct.c 1.3 03/18/98 Takashi Hamada */

#ifdef DEBUG
#ifndef ADB_DEBUG
#define ADB_DEBUG
#endif
#endif

/* #define	PM_GRAB_SI	1 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/cpu.h>
#include <machine/viareg.h>

#include <dev/adb/adb.h>
#include <mac68k/dev/adbvar.h>
#include <mac68k/dev/pm_direct.h>

/* hardware dependent values */
u_int32_t HwCfgFlags3;
u_short ADBDelay = 0xcea;

/* define the types of the Power Manager */
#define PM_HW_UNKNOWN		0x00	/* don't know */
#define PM_HW_PB1XX		0x01	/* PowerBook 1XX series */
#define	PM_HW_PB5XX		0x02	/* PowerBook Duo and 5XX series */

/* useful macros */
#define PM_SR()			via_reg(VIA1, vSR)
#define PM_VIA_INTR_ENABLE()	via_reg(VIA1, vIER) = 0x90
#define PM_VIA_INTR_DISABLE()	via_reg(VIA1, vIER) = 0x10
#define PM_VIA_CLR_INTR()	via_reg(VIA1, vIFR) = 0x90
#define PM_SET_STATE_ACKON()	via_reg(VIA2, vBufB) |= 0x04
#define PM_SET_STATE_ACKOFF()	via_reg(VIA2, vBufB) &= ~0x04
#define PM_IS_ON		(0x02 == (via_reg(VIA2, vBufB) & 0x02))
#define PM_IS_OFF		(0x00 == (via_reg(VIA2, vBufB) & 0x02))

/*
 * Variables for internal use
 */
int	pmHardware = PM_HW_UNKNOWN;
u_short	pm_existent_ADB_devices = 0x0;	/* each bit expresses the existent ADB device */
u_int	pm_LCD_brightness = 0x0;
u_int	pm_LCD_contrast = 0x0;
u_int	pm_counter = 0;			/* clock count */

/* these values shows that number of data returned after 'send' cmd is sent */
char pm_send_cmd_type[] = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
	0xff, 0x00, 0x02, 0x01, 0x01, 0xff, 0xff, 0xff,
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x04, 0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x01, 0x00, 0x02, 0x02, 0xff, 0x01, 0x03, 0x01,
	0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
	0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x04, 0x04,
	0x04, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x01, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x02, 0x02, 0x02, 0x04, 0xff, 0x00, 0xff, 0xff,
	0x01, 0x01, 0x03, 0x02, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x01, 0x01, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
	0xff, 0x04, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x03, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

/* these values shows that number of data returned after 'receive' cmd is sent */
char pm_receive_cmd_type[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x03, 0x03, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x04, 0x03, 0x09, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02, 0xff, 0xff, 0x02, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x02, 0xff, 0xff, 0xff, 0xff, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};


/*
 * Define the private functions
 */

/* for debugging */
#ifdef ADB_DEBUG
void	pm_printerr(const char *, int, int, char *);
#endif

int	pm_wait_busy(int);
int	pm_wait_free(int);

/* these functions are for the PB1XX series */
int	pm_receive_pm1(u_char *);
int	pm_send_pm1(u_char, int);
int	pm_pmgrop_pm1(PMData *);
int	pm_intr_pm1(void *);

/* these functions are for the PB Duo series and the PB 5XX series */
int	pm_receive_pm2(u_char *);
int	pm_send_pm2(u_char);
int	pm_pmgrop_pm2(PMData *);
int	pm_intr_pm2(void *);

/* these functions are called from adb_direct.c */
void	pm_setup_adb(void);
void	pm_check_adb_devices(int);
int	pm_intr(void *);
int	pm_adb_op(u_char *, void *, void *, int);
void	pm_hw_setup(struct device *);

/* these functions also use the variables of adb_direct.c */
void	pm_adb_get_TALK_result(PMData *);
void	pm_adb_get_ADB_data(PMData *);
void	pm_adb_poll_next_device_pm1(PMData *);


/*
 * These variables are in adb_direct.c.
 */
extern u_char	*adbBuffer;	/* pointer to user data area */
extern void	*adbCompRout;	/* pointer to the completion routine */
extern void	*adbCompData;	/* pointer to the completion routine data */
extern int	adbWaiting;	/* waiting for return data from the device */
extern int	adbWaitingCmd;	/* ADB command we are waiting for */
extern int	adbStarting;	/* doing ADB reinit, so do "polling" differently */

#define	ADB_MAX_MSG_LENGTH	16
#define	ADB_MAX_HDR_LENGTH	8
struct adbCommand {
	u_char	header[ADB_MAX_HDR_LENGTH];	/* not used yet */
	u_char	data[ADB_MAX_MSG_LENGTH];	/* packet data only */
	u_char	*saveBuf;	/* where to save result */
	u_char	*compRout;	/* completion routine pointer */
	u_char	*compData;	/* completion routine data pointer */
	u_int	cmd;		/* the original command for this data */
	u_int	unsol;		/* 1 if packet was unsolicited */
	u_int	ack_only;	/* 1 for no special processing */
};
extern	void	adb_pass_up(struct adbCommand *);

#ifdef ADB_DEBUG
/*
 * This function dumps contents of the PMData
 */
void
pm_printerr(const char *ttl, int rval, int num, char *data)
{
	int i;

	printf("pm: %s:%04x %02x ", ttl, rval, num);
	for (i = 0; i < num; i++)
		printf("%02x ", data[i]);
	printf("\n");
}
#endif



/*
 * Check the hardware type of the Power Manager
 */
void
pm_setup_adb(void)
{
	switch (mac68k_machine.machineid) {
	case MACH_MACPB140:
	case MACH_MACPB145:
	case MACH_MACPB160:
	case MACH_MACPB165:
	case MACH_MACPB165C:
	case MACH_MACPB170:
	case MACH_MACPB180:
	case MACH_MACPB180C:
		pmHardware = PM_HW_PB1XX;
		break;
	case MACH_MACPB150:
	case MACH_MACPB210:
	case MACH_MACPB230:
	case MACH_MACPB250:
	case MACH_MACPB270:
	case MACH_MACPB280:
	case MACH_MACPB280C:
	case MACH_MACPB500:
	case MACH_MACPB190:
	case MACH_MACPB190CS:
		pmHardware = PM_HW_PB5XX;
		break;
	default:
		break;
	}
}


/*
 * Check the existent ADB devices
 */
void
pm_check_adb_devices(int id)
{
	u_short ed = 0x1;

	ed <<= id;
	pm_existent_ADB_devices |= ed;
}


/*
 * Wait until PM IC is busy
 */
int
pm_wait_busy(int xdelay)
{
	while (PM_IS_ON) {
#ifdef PM_GRAB_SI
		(void)intr_dispatch(0x70);	/* grab any serial interrupts */
#endif
		if ((--xdelay) < 0)
			return 1;	/* timeout */
	}
	return 0;
}


/*
 * Wait until PM IC is free
 */
int
pm_wait_free(int xdelay)
{
	while (PM_IS_OFF) {
#ifdef PM_GRAB_SI
		(void)intr_dispatch(0x70);	/* grab any serial interrupts */
#endif
		if ((--xdelay) < 0)
			return 0;	/* timeout */
	}
	return 1;
}



/*
 * Functions for the PB1XX series
 */

/*
 * Receive data from PM for the PB1XX series
 */
int
pm_receive_pm1(u_char *data)
{
	int rval = 0xffffcd34;

	via_reg(VIA2, vDirA) = 0x00;

	switch (1) {
	default:
		if (pm_wait_busy(0x40) != 0)
			break;			/* timeout */

		PM_SET_STATE_ACKOFF();
		*data = via_reg(VIA2, 0x200);

		rval = 0xffffcd33;
		if (pm_wait_free(0x40) == 0)
			break;			/* timeout */

		rval = 0x00;
		break;
	}

	PM_SET_STATE_ACKON();
	via_reg(VIA2, vDirA) = 0x00;

	return rval;
}



/*
 * Send data to PM for the PB1XX series
 */
int
pm_send_pm1(u_char data, int timo)
{
	int rval;

	via_reg(VIA2, vDirA) = 0xff;
	via_reg(VIA2, 0x200) = data;

	PM_SET_STATE_ACKOFF();
#if 0
	if (pm_wait_busy(0x400) == 0) {
#else
	if (pm_wait_busy(timo) == 0) {
#endif
		PM_SET_STATE_ACKON();
		if (pm_wait_free(0x40) != 0)
			rval = 0x0;
		else
			rval = 0xffffcd35;
	} else {
		rval = 0xffffcd36;
	}

	PM_SET_STATE_ACKON();
	via_reg(VIA2, vDirA) = 0x00;

	return rval;
}


/*
 * My PMgrOp routine for the PB1XX series
 */
int
pm_pmgrop_pm1(PMData *pmdata)
{
	int i;
	int s = 0x81815963;
	u_char via1_vIER, via1_vDirA;
	int rval = 0;
	int num_pm_data = 0;
	u_char pm_cmd;	
	u_char pm_data;
	u_char *pm_buf;

	/* disable all inetrrupts but PM */
	via1_vIER = via_reg(VIA1, vIER);
	PM_VIA_INTR_DISABLE();

	via1_vDirA = via_reg(VIA1, vDirA);

	switch (pmdata->command) {
	default:
		for (i = 0; i < 7; i++) {
			via_reg(VIA2, vDirA) = 0x00;	

			/* wait until PM is free */
			if (pm_wait_free(ADBDelay) == 0) {	/* timeout */
				via_reg(VIA2, vDirA) = 0x00;
				/* restore former value */
				via_reg(VIA1, vDirA) = via1_vDirA;
				via_reg(VIA1, vIER) = via1_vIER;
				return 0xffffcd38;
			}

			switch (mac68k_machine.machineid) {
			/* XXX what about 140 and 145? -- miod */
			case MACH_MACPB160:
			case MACH_MACPB165:
			case MACH_MACPB165C:
			case MACH_MACPB170:
			case MACH_MACPB180:
			case MACH_MACPB180C:
			{
				int xdelay = ADBDelay * 16;

				via_reg(VIA2, vDirA) = 0x00;
				while ((via_reg(VIA2, 0x200) == 0x7f) && (xdelay >= 0))
					xdelay--;

				if (xdelay < 0) {	/* timeout */
					via_reg(VIA2, vDirA) = 0x00;
					/* restore former value */
					via_reg(VIA1, vIER) = via1_vIER;
					return 0xffffcd38;
				}
			}
				break;
			} /* end switch */

			s = splhigh();

			via1_vDirA = via_reg(VIA1, vDirA);
			via_reg(VIA1, vDirA) &= 0x7f;

			pm_cmd = (u_char)(pmdata->command & 0xff);
			if ((rval = pm_send_pm1(pm_cmd, ADBDelay * 8)) == 0)
				break;	/* send command succeeded */

			via_reg(VIA1, vDirA) = via1_vDirA;
			splx(s);
		} /* end for */

		/* failed to send a command */
		if (i == 7) {
			via_reg(VIA2, vDirA) = 0x00;
			/* restore former value */
			via_reg(VIA1, vDirA) = via1_vDirA;
			via_reg(VIA1, vIER) = via1_vIER;
			if (s != 0x81815963)
				splx(s);
			return 0xffffcd38;
		}

		/* send # of PM data */
		num_pm_data = pmdata->num_data;
		if ((rval = pm_send_pm1((u_char)(num_pm_data & 0xff), ADBDelay * 8)) != 0)
			break;			/* timeout */

		/* send PM data */
		pm_buf = (u_char *)pmdata->s_buf;
		for (i = 0; i < num_pm_data; i++)
			if ((rval = pm_send_pm1(pm_buf[i], ADBDelay * 8)) != 0)
				break;		/* timeout */
		if ((i != num_pm_data) && (num_pm_data != 0))
			break;			/* timeout */

		/* Will PM IC return data? */
		if ((pm_cmd & 0x08) == 0) {
			rval = 0;
			break;			/* no returned data */
		}

		rval = 0xffffcd37;
		if (pm_wait_busy(ADBDelay) != 0)
			break;			/* timeout */

		/* receive PM command */
		if ((rval = pm_receive_pm1(&pm_data)) != 0)
			break;

		pmdata->command = pm_data;

		/* receive number of PM data */
		if ((rval = pm_receive_pm1(&pm_data)) != 0)
			break;			/* timeout */
		num_pm_data = pm_data;
		pmdata->num_data = num_pm_data;

		/* receive PM data */
		pm_buf = (u_char *)pmdata->r_buf;
		for (i = 0; i < num_pm_data; i++) {
			if ((rval = pm_receive_pm1(&pm_data)) != 0)
				break;		/* timeout */
			pm_buf[i] = pm_data;
		}

		rval = 0;
	}

	via_reg(VIA2, vDirA) = 0x00;	

	/* restore former value */
	via_reg(VIA1, vDirA) = via1_vDirA;
	via_reg(VIA1, vIER) = via1_vIER;
	if (s != 0x81815963)
		splx(s);

	return rval;
}


/*
 * My PM interrupt routine for PB1XX series
 */
int
pm_intr_pm1(void *arg)
{
	int s;
	int rval;
	PMData pmdata;

	s = splhigh();

	PM_VIA_CLR_INTR();				/* clear VIA1 interrupt */

	/* ask PM what happend */
	pmdata.command = 0x78;
	pmdata.num_data = 0;
	pmdata.data[0] = pmdata.data[1] = 0;
	pmdata.s_buf = &pmdata.data[2];
	pmdata.r_buf = &pmdata.data[2];
	rval = pm_pmgrop_pm1(&pmdata);
	if (rval != 0) {
#ifdef ADB_DEBUG
		if (adb_debug)
			printf("pm: PM is not ready. error code=%08x\n", rval);
#endif
		splx(s);
	}

	if ((pmdata.data[2] & 0x10) == 0x10) {
		if ((pmdata.data[2] & 0x0f) == 0) {
			/* ADB data that were requested by TALK command */
			pm_adb_get_TALK_result(&pmdata);
		} else if ((pmdata.data[2] & 0x08) == 0x8) {
			/* PM is requesting to poll  */
			pm_adb_poll_next_device_pm1(&pmdata);
		} else if ((pmdata.data[2] & 0x04) == 0x4) {
			/* ADB device event */
			pm_adb_get_ADB_data(&pmdata);
		}
	} else {
#ifdef ADB_DEBUG
		if (adb_debug)
			pm_printerr("driver does not supported this event.",
			    rval, pmdata.num_data, pmdata.data);
#endif
	}

	splx(s);

	return (1);
}



/*
 * Functions for the PB Duo series and the PB 5XX series
 */

/*
 * Receive data from PM for the PB Duo series and the PB 5XX series
 */
int
pm_receive_pm2(u_char *data)
{
	int i;
	int rval;

	rval = 0xffffcd34;

	switch (1) {
	default:
		/* set VIA SR to input mode */
		via_reg(VIA1, vACR) |= 0x0c;
		via_reg(VIA1, vACR) &= ~0x10;
		i = PM_SR();

		PM_SET_STATE_ACKOFF();
		if (pm_wait_busy((int)ADBDelay*32) != 0)
			break;		/* timeout */

		PM_SET_STATE_ACKON();
		rval = 0xffffcd33;
		if (pm_wait_free((int)ADBDelay*32) == 0)
			break;		/* timeout */

		*data = PM_SR();
		rval = 0;

		break;
	}

	PM_SET_STATE_ACKON();
	via_reg(VIA1, vACR) |= 0x1c;

	return rval;
}	



/*
 * Send data to PM for the PB Duo series and the PB 5XX series
 */
int
pm_send_pm2(u_char data)
{
	int rval;

	via_reg(VIA1, vACR) |= 0x1c;
	PM_SR() = data;

	PM_SET_STATE_ACKOFF();
	if (pm_wait_busy((int)ADBDelay*32) == 0) {
		PM_SET_STATE_ACKON();
		if (pm_wait_free((int)ADBDelay*32) != 0)
			rval = 0;
		else
			rval = 0xffffcd35;
	} else {
		rval = 0xffffcd36;
	}

	PM_SET_STATE_ACKON();
	via_reg(VIA1, vACR) |= 0x1c;

	return rval;
}



/*
 * My PMgrOp routine for the PB Duo series and the PB 5XX series
 */
int
pm_pmgrop_pm2(PMData *pmdata)
{
	int i;
	int s;
	u_char via1_vIER;
	int rval = 0;
	int num_pm_data = 0;
	u_char pm_cmd;	
	short pm_num_rx_data;
	u_char pm_data;
	u_char *pm_buf;

	s = splhigh();

	/* disable all inetrrupts but PM */
	via1_vIER = 0x10;
	via1_vIER &= via_reg(VIA1, vIER);
	via_reg(VIA1, vIER) = via1_vIER;
	if (via1_vIER != 0x0)
		via1_vIER |= 0x80;

	switch (pmdata->command) {
	default:
		/* wait until PM is free */
		pm_cmd = (u_char)(pmdata->command & 0xff);
		rval = 0xcd38;
		if (pm_wait_free(ADBDelay * 4) == 0)
			break;			/* timeout */

		if (HwCfgFlags3 & 0x00200000) {	
			/* PB 160, PB 165(c), PB 180(c)? */
			int xdelay = ADBDelay * 16;

			via_reg(VIA2, vDirA) = 0x00;
			while ((via_reg(VIA2, 0x200) == 0x07) &&
			    (xdelay >= 0))
				xdelay--;

			if (xdelay < 0) {
				rval = 0xffffcd38;
				break;		/* timeout */
			}
		}

		/* send PM command */
		if ((rval = pm_send_pm2((u_char)(pm_cmd & 0xff))))
			break;				/* timeout */

		/* send number of PM data */
		num_pm_data = pmdata->num_data;
		if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
			if (pm_send_cmd_type[pm_cmd] < 0) {
				if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
					break;		/* timeout */
				pmdata->command = 0;
			}
		} else {				/* PB 1XX series ? */
			if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
				break;			/* timeout */
		}			
		/* send PM data */
		pm_buf = (u_char *)pmdata->s_buf;
		for (i = 0 ; i < num_pm_data; i++)
			if ((rval = pm_send_pm2(pm_buf[i])) != 0)
				break;			/* timeout */
		if (i != num_pm_data)
			break;				/* timeout */


		/* check if PM will send me data  */
		pm_num_rx_data = pm_receive_cmd_type[pm_cmd];
		pmdata->num_data = pm_num_rx_data;
		if (pm_num_rx_data == 0) {
			rval = 0;
			break;				/* no return data */
		}

		/* receive PM command */
		pm_data = pmdata->command;
		if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
			pm_num_rx_data--;
			if (pm_num_rx_data == 0)
				if ((rval = pm_receive_pm2(&pm_data)) != 0) {
					rval = 0xffffcd37;
					break;
				}
			pmdata->command = pm_data;
		} else {				/* PB 1XX series ? */
			if ((rval = pm_receive_pm2(&pm_data)) != 0) {
				rval = 0xffffcd37;
				break;
			}
			pmdata->command = pm_data;
		}

		/* receive number of PM data */
		if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
			if (pm_num_rx_data < 0) {
				if ((rval = pm_receive_pm2(&pm_data)) != 0)
					break;		/* timeout */
				num_pm_data = pm_data;
			} else
				num_pm_data = pm_num_rx_data;
			pmdata->num_data = num_pm_data;
		} else {				/* PB 1XX serias ? */
			if ((rval = pm_receive_pm2(&pm_data)) != 0)
				break;			/* timeout */
			num_pm_data = pm_data;
			pmdata->num_data = num_pm_data;
		}

		/* receive PM data */
		pm_buf = (u_char *)pmdata->r_buf;
		for (i = 0; i < num_pm_data; i++) {
			if ((rval = pm_receive_pm2(&pm_data)) != 0)
				break;			/* timeout */
			pm_buf[i] = pm_data;
		}

		rval = 0;
	}

	/* restore former value */
	via_reg(VIA1, vIER) = via1_vIER;
	splx(s);

	return rval;
}


/*
 * My PM interrupt routine for the PB Duo series and the PB 5XX series
 */
int
pm_intr_pm2(void *arg)
{
	int s;
	int rval;
	PMData pmdata;

	s = splhigh();

	PM_VIA_CLR_INTR();			/* clear VIA1 interrupt */
						/* ask PM what happend */
	pmdata.command = 0x78;
	pmdata.num_data = 0;
	pmdata.s_buf = &pmdata.data[2];
	pmdata.r_buf = &pmdata.data[2];
	rval = pm_pmgrop_pm2(&pmdata);
	if (rval != 0) {
#ifdef ADB_DEBUG
		if (adb_debug)
			printf("pm: PM is not ready. error code: %08x\n", rval);
#endif
		splx(s);
	}

	switch ((u_int)(pmdata.data[2] & 0xff)) {
	case 0x00:			/* 1 sec interrupt? */
		break;
	case 0x80:			/* 1 sec interrupt? */
		pm_counter++;
		break;
	case 0x08:			/* Brightness/Contrast button on LCD panel */
		/* get brightness and contrast of the LCD */
		pm_LCD_brightness = (u_int)pmdata.data[3] & 0xff;
		pm_LCD_contrast = (u_int)pmdata.data[4] & 0xff;
/*
		pm_printerr("#08", rval, pmdata.num_data, pmdata.data);
		pmdata.command = 0x33;
		pmdata.num_data = 1;
		pmdata.s_buf = pmdata.data;
		pmdata.r_buf = pmdata.data;
		pmdata.data[0] = pm_LCD_contrast;
		rval = pm_pmgrop_pm2(&pmdata);
		pm_printerr("#33", rval, pmdata.num_data, pmdata.data);
*/
		/* this is an experimental code */
		pmdata.command = 0x41;
		pmdata.num_data = 1;
		pmdata.s_buf = pmdata.data;
		pmdata.r_buf = pmdata.data;
		pm_LCD_brightness = 0x7f - pm_LCD_brightness / 2;
		if (pm_LCD_brightness < 0x25)
			pm_LCD_brightness = 0x25;
		if (pm_LCD_brightness > 0x5a)
			pm_LCD_brightness = 0x7f;
		pmdata.data[0] = pm_LCD_brightness;
		rval = pm_pmgrop_pm2(&pmdata);
		break;
	case 0x10:			/* ADB data that were requested by TALK command */
	case 0x14:
		pm_adb_get_TALK_result(&pmdata);
		break;
	case 0x16:			/* ADB device event */
	case 0x18:
	case 0x1e:
		pm_adb_get_ADB_data(&pmdata);
		break;
	default:
#ifdef ADB_DEBUG
		if (adb_debug)
			pm_printerr("driver does not supported this event.",
			    pmdata.data[2], pmdata.num_data,
			    pmdata.data);
#endif
		break;
	}

	splx(s);

	return (1);
}


/*
 * My PMgrOp routine
 */
int
pmgrop(PMData *pmdata)
{
	switch (pmHardware) {
	case PM_HW_PB1XX:
		return (pm_pmgrop_pm1(pmdata));
		break;
	case PM_HW_PB5XX:
		return (pm_pmgrop_pm2(pmdata));
		break;
	default:
		return 1;
	}
}

int
pm_intr(void *arg)
{
	switch (pmHardware) {
	case PM_HW_PB1XX:
		return (pm_intr_pm1(arg));
	case PM_HW_PB5XX:
		return (pm_intr_pm2(arg));
	default:
		return (-1);
	}
}

void
pm_hw_setup(struct device *self)
{
	switch (pmHardware) {
	case PM_HW_PB1XX:
		via1_register_irq(4, pm_intr_pm1, self, self->dv_xname);
		PM_VIA_CLR_INTR();
		break;
	case PM_HW_PB5XX:
		via1_register_irq(4, pm_intr_pm2, self, self->dv_xname);
		PM_VIA_CLR_INTR();
		break;
	default:
		break;
	}
}


/*
 * Synchronous ADBOp routine for the Power Manager
 */
int
pm_adb_op(u_char *buffer, void *compRout, void *data, int command)
{
	int i;
	int s;
	int rval;
	int xdelay;
	PMData pmdata;
	struct adbCommand packet;

	if (adbWaiting == 1)
		return 1;

	s = splhigh();
	via_reg(VIA1, vIER) = 0x10;

 	adbBuffer = buffer;
	adbCompRout = compRout;
	adbCompData = data;

	pmdata.command = 0x20;
	pmdata.s_buf = pmdata.data;
	pmdata.r_buf = pmdata.data;

	if ((command & 0xc) == 0x8) {		/* if the command is LISTEN, add number of ADB data to number of PM data */
		if (buffer != (u_char *)0)
			pmdata.num_data = buffer[0] + 3;
	} else {
		pmdata.num_data = 3;
	}

	pmdata.data[0] = (u_char)(command & 0xff);
	pmdata.data[1] = 0;
	if ((command & 0xc) == 0x8) {		/* if the command is LISTEN, copy ADB data to PM buffer */
		if ((buffer != (u_char *)0) && (buffer[0] <= 24)) {
			pmdata.data[2] = buffer[0];		/* number of data */
			for (i = 0; i < buffer[0]; i++)
				pmdata.data[3 + i] = buffer[1 + i];
		} else
			pmdata.data[2] = 0;
	} else
		pmdata.data[2] = 0;

	if ((command & 0xc) != 0xc) {		/* if the command is not TALK */
		/* set up stuff fNULLor adb_pass_up */
		packet.data[0] = 1 + pmdata.data[2];
		packet.data[1] = command;
		for (i = 0; i < pmdata.data[2]; i++)
			packet.data[i+2] = pmdata.data[i+3];
		packet.saveBuf = adbBuffer;
		packet.compRout = adbCompRout;
		packet.compData = adbCompData;
		packet.cmd = command;
		packet.unsol = 0;
		packet.ack_only = 1;
		adb_polling = 1;
		adb_pass_up(&packet);
		adb_polling = 0;
	}

	rval = pmgrop(&pmdata);
	if (rval != 0) {
		splx(s);
		return 1;
	}

	adbWaiting = 1;
	adbWaitingCmd = command;

	PM_VIA_INTR_ENABLE();

	/* wait until the PM interrupt has occurred */
	xdelay = 0x80000;
	while (adbWaiting == 1) {
		switch (mac68k_machine.machineid) {
		case MACH_MACPB150:
		case MACH_MACPB210:
		case MACH_MACPB230:	/* daishi tested with Duo230 */
		case MACH_MACPB250:
		case MACH_MACPB270:
		case MACH_MACPB280:
		case MACH_MACPB280C:
		case MACH_MACPB190:
		case MACH_MACPB190CS:
			pm_intr((void *)0);
			break;
		default:
			if ((via_reg(VIA1, vIFR) & 0x10) == 0x10)
				pm_intr((void *)0);
			break;
		}
#ifdef PM_GRAB_SI
		(void)intr_dispatch(0x70);	/* grab any serial interrupts */
#endif
		if ((--xdelay) < 0) {
			splx(s);
			return 1;
		}
	}

	/* this command enables the interrupt by operating ADB devices */
	if (HwCfgFlags3 & 0x00020000) {		/* PB Duo series, PB 5XX series */
		pmdata.command = 0x20;
		pmdata.num_data = 4;
		pmdata.s_buf = pmdata.data;
		pmdata.r_buf = pmdata.data;
		pmdata.data[0] = 0x00;	
		pmdata.data[1] = 0x86;	/* magic spell for awaking the PM */
		pmdata.data[2] = 0x00;	
		pmdata.data[3] = 0x0c;	/* each bit may express the existent ADB device */
	} else {				/* PB 1XX series */
		pmdata.command = 0x20;
		pmdata.num_data = 3;
		pmdata.s_buf = pmdata.data;
		pmdata.r_buf = pmdata.data;
		pmdata.data[0] = (u_char)(command & 0xf0) | 0xc;
		pmdata.data[1] = 0x04;
		pmdata.data[2] = 0x00;
	}
	rval = pmgrop(&pmdata);

	splx(s);
	return rval;
}


void
pm_adb_get_TALK_result(PMData *pmdata)
{
	int i;
	struct adbCommand packet;

	/* set up data for adb_pass_up */
	packet.data[0] = pmdata->num_data-1;
	packet.data[1] = pmdata->data[3];
	for (i = 0; i <packet.data[0]-1; i++)
		packet.data[i+2] = pmdata->data[i+4];

	packet.saveBuf = adbBuffer;
	packet.compRout = adbCompRout;
	packet.compData = adbCompData;
	packet.unsol = 0;
	packet.ack_only = 0;
	adb_polling = 1;
	adb_pass_up(&packet);
	adb_polling = 0;

	adbWaiting = 0;
	adbBuffer = (long)0;
	adbCompRout = (long)0;
	adbCompData = (long)0;
}


void
pm_adb_get_ADB_data(PMData *pmdata)
{
	int i;
	struct adbCommand packet;

	/* set up data for adb_pass_up */
	packet.data[0] = pmdata->num_data-1;	/* number of raw data */
	packet.data[1] = pmdata->data[3];	/* ADB command */
	for (i = 0; i <packet.data[0]-1; i++)
		packet.data[i+2] = pmdata->data[i+4];
	packet.unsol = 1;
	packet.ack_only = 0;
	adb_pass_up(&packet);
}


void
pm_adb_poll_next_device_pm1(PMData *pmdata)
{
	int i;
	int ndid;
	u_short bendid = 0x1;
	int rval;
	PMData tmp_pmdata;

	/* find another existent ADB device to poll */
	for (i = 1; i < 16; i++) {
		ndid = (ADB_CMDADDR(pmdata->data[3]) + i) & 0xf;
		bendid <<= ndid;
		if ((pm_existent_ADB_devices & bendid) != 0)
			break;
	}

	/* poll the other device */
	tmp_pmdata.command = 0x20;
	tmp_pmdata.num_data = 3;
	tmp_pmdata.s_buf = tmp_pmdata.data;
	tmp_pmdata.r_buf = tmp_pmdata.data;
	tmp_pmdata.data[0] = (u_char)(ndid << 4) | 0xc;
	tmp_pmdata.data[1] = 0x04;	/* magic spell for awaking the PM */
	tmp_pmdata.data[2] = 0x00;
	rval = pmgrop(&tmp_pmdata);
}
@


1.13
log
@Indentation repairs, no code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.12 2006/01/22 15:25:30 miod Exp $	*/
@


1.12
log
@Print adb subsystem name early in attachment, and pass the proper device
name to interrupt counter registration, rather than "adb".
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.11 2006/01/18 23:21:17 miod Exp $	*/
d241 24
a264 24
		case MACH_MACPB140:
		case MACH_MACPB145:
		case MACH_MACPB160:
		case MACH_MACPB165:
		case MACH_MACPB165C:
		case MACH_MACPB170:
		case MACH_MACPB180:
		case MACH_MACPB180C:
			pmHardware = PM_HW_PB1XX;
			break;
		case MACH_MACPB150:
		case MACH_MACPB210:
		case MACH_MACPB230:
		case MACH_MACPB250:
		case MACH_MACPB270:
		case MACH_MACPB280:
		case MACH_MACPB280C:
		case MACH_MACPB500:
		case MACH_MACPB190:
		case MACH_MACPB190CS:
			pmHardware = PM_HW_PB5XX;
			break;
		default:
			break;
d332 10
a341 10
		default:
			if (pm_wait_busy(0x40) != 0)
				break;			/* timeout */

			PM_SET_STATE_ACKOFF();
			*data = via_reg(VIA2, 0x200);

			rval = 0xffffcd33;
			if (pm_wait_free(0x40) == 0)
				break;			/* timeout */
d343 2
a344 2
			rval = 0x00;
			break;
d410 23
a432 3
		default:
			for (i = 0; i < 7; i++) {
				via_reg(VIA2, vDirA) = 0x00;	
d434 5
a438 2
				/* wait until PM is free */
				if (pm_wait_free(ADBDelay) == 0) {	/* timeout */
d440 1
a440 2
					/* restore formar value */
					via_reg(VIA1, vDirA) = via1_vDirA;
d444 5
d450 6
a455 31
				switch (mac68k_machine.machineid) {
					case MACH_MACPB160:
					case MACH_MACPB165:
					case MACH_MACPB165C:
					case MACH_MACPB170:
					case MACH_MACPB180:
					case MACH_MACPB180C:
						{
							int xdelay = ADBDelay * 16;

							via_reg(VIA2, vDirA) = 0x00;
							while ((via_reg(VIA2, 0x200) == 0x7f) && (xdelay >= 0))
								xdelay--;

							if (xdelay < 0) {	/* timeout */
								via_reg(VIA2, vDirA) = 0x00;
								/* restore formar value */
								via_reg(VIA1, vIER) = via1_vIER;
								return 0xffffcd38;
							}
						}
				} /* end switch */

				s = splhigh();

				via1_vDirA = via_reg(VIA1, vDirA);
				via_reg(VIA1, vDirA) &= 0x7f;

				pm_cmd = (u_char)(pmdata->command & 0xff);
				if ((rval = pm_send_pm1(pm_cmd, ADBDelay * 8)) == 0)
					break;	/* send command succeeded */
d457 11
a467 1
				via_reg(VIA1, vDirA) = via1_vDirA;
d469 2
a470 1
			} /* end for */
d472 12
a483 10
			/* failed to send a command */
			if (i == 7) {
				via_reg(VIA2, vDirA) = 0x00;
				/* restore formar value */
				via_reg(VIA1, vDirA) = via1_vDirA;
				via_reg(VIA1, vIER) = via1_vIER;
				if (s != 0x81815963)
					splx(s);
				return 0xffffcd38;
			}
d485 5
a489 4
			/* send # of PM data */
			num_pm_data = pmdata->num_data;
			if ((rval = pm_send_pm1((u_char)(num_pm_data & 0xff), ADBDelay * 8)) != 0)
				break;			/* timeout */
d491 3
a493 7
			/* send PM data */
			pm_buf = (u_char *)pmdata->s_buf;
			for (i = 0; i < num_pm_data; i++)
				if ((rval = pm_send_pm1(pm_buf[i], ADBDelay * 8)) != 0)
					break;		/* timeout */
			if ((i != num_pm_data) && (num_pm_data != 0))
				break;			/* timeout */
d495 3
a497 5
			/* Will PM IC return data? */
			if ((pm_cmd & 0x08) == 0) {
				rval = 0;
				break;			/* no returned data */
			}
d499 1
a499 3
			rval = 0xffffcd37;
			if (pm_wait_busy(ADBDelay) != 0)
				break;			/* timeout */
d501 5
a505 5
			/* receive PM command */
			if ((rval = pm_receive_pm1(&pm_data)) != 0)
				break;

			pmdata->command = pm_data;
d507 3
a509 1
			/* receive number of PM data */
d511 3
a513 11
				break;			/* timeout */
			num_pm_data = pm_data;
			pmdata->num_data = num_pm_data;

			/* receive PM data */
			pm_buf = (u_char *)pmdata->r_buf;
			for (i = 0; i < num_pm_data; i++) {
				if ((rval = pm_receive_pm1(&pm_data)) != 0)
					break;		/* timeout */
				pm_buf[i] = pm_data;
			}
d515 1
a515 1
			rval = 0;
d520 1
a520 1
	/* restore formar value */
d601 9
a609 5
		default:
			/* set VIA SR to input mode */
			via_reg(VIA1, vACR) |= 0x0c;
			via_reg(VIA1, vACR) &= ~0x10;
			i = PM_SR();
d611 4
a614 3
			PM_SET_STATE_ACKOFF();
			if (pm_wait_busy((int)ADBDelay*32) != 0)
				break;		/* timeout */
d616 2
a617 4
			PM_SET_STATE_ACKON();
			rval = 0xffffcd33;
			if (pm_wait_free((int)ADBDelay*32) == 0)
				break;		/* timeout */
d619 1
a619 4
			*data = PM_SR();
			rval = 0;

			break;
d686 15
a700 6
		default:
			/* wait until PM is free */
			pm_cmd = (u_char)(pmdata->command & 0xff);
			rval = 0xcd38;
			if (pm_wait_free(ADBDelay * 4) == 0)
				break;			/* timeout */
d702 5
a706 3
			if (HwCfgFlags3 & 0x00200000) {	
				/* PB 160, PB 165(c), PB 180(c)? */
				int xdelay = ADBDelay * 16;
d708 9
a716 7
				via_reg(VIA2, vDirA) = 0x00;
				while ((via_reg(VIA2, 0x200) == 0x07) &&
				    (xdelay >= 0))
					xdelay--;

				if (xdelay < 0) {
					rval = 0xffffcd38;
d718 1
a718 1
				}
d720 12
d733 7
a739 32
			/* send PM command */
			if ((rval = pm_send_pm2((u_char)(pm_cmd & 0xff))))
				break;				/* timeout */

			/* send number of PM data */
			num_pm_data = pmdata->num_data;
			if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
				if (pm_send_cmd_type[pm_cmd] < 0) {
					if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
						break;		/* timeout */
					pmdata->command = 0;
				}
			} else {				/* PB 1XX series ? */
				if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
					break;			/* timeout */
			}			
			/* send PM data */
			pm_buf = (u_char *)pmdata->s_buf;
			for (i = 0 ; i < num_pm_data; i++)
				if ((rval = pm_send_pm2(pm_buf[i])) != 0)
					break;			/* timeout */
			if (i != num_pm_data)
				break;				/* timeout */


			/* check if PM will send me data  */
			pm_num_rx_data = pm_receive_cmd_type[pm_cmd];
			pmdata->num_data = pm_num_rx_data;
			if (pm_num_rx_data == 0) {
				rval = 0;
				break;				/* no return data */
			}
d741 5
a745 11
			/* receive PM command */
			pm_data = pmdata->command;
			if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
				pm_num_rx_data--;
				if (pm_num_rx_data == 0)
					if ((rval = pm_receive_pm2(&pm_data)) != 0) {
						rval = 0xffffcd37;
						break;
					}
				pmdata->command = pm_data;
			} else {				/* PB 1XX series ? */
d750 5
a754 1
				pmdata->command = pm_data;
d756 2
d759 3
a761 10
			/* receive number of PM data */
			if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
				if (pm_num_rx_data < 0) {
					if ((rval = pm_receive_pm2(&pm_data)) != 0)
						break;		/* timeout */
					num_pm_data = pm_data;
				} else
					num_pm_data = pm_num_rx_data;
				pmdata->num_data = num_pm_data;
			} else {				/* PB 1XX serias ? */
d763 1
a763 1
					break;			/* timeout */
d765 9
a773 2
				pmdata->num_data = num_pm_data;
			}
d775 7
a781 7
			/* receive PM data */
			pm_buf = (u_char *)pmdata->r_buf;
			for (i = 0; i < num_pm_data; i++) {
				if ((rval = pm_receive_pm2(&pm_data)) != 0)
					break;			/* timeout */
				pm_buf[i] = pm_data;
			}
d783 1
a783 1
			rval = 0;
d822 18
a839 18
		case 0x00:			/* 1 sec interrupt? */
			break;
		case 0x80:			/* 1 sec interrupt? */
			pm_counter++;
			break;
		case 0x08:			/* Brightness/Contrast button on LCD panel */
			/* get brightness and contrast of the LCD */
			pm_LCD_brightness = (u_int)pmdata.data[3] & 0xff;
			pm_LCD_contrast = (u_int)pmdata.data[4] & 0xff;
/*
			pm_printerr("#08", rval, pmdata.num_data, pmdata.data);
			pmdata.command = 0x33;
			pmdata.num_data = 1;
			pmdata.s_buf = pmdata.data;
			pmdata.r_buf = pmdata.data;
			pmdata.data[0] = pm_LCD_contrast;
			rval = pm_pmgrop_pm2(&pmdata);
			pm_printerr("#33", rval, pmdata.num_data, pmdata.data);
d841 23
a863 23
			/* this is an experimental code */
			pmdata.command = 0x41;
			pmdata.num_data = 1;
			pmdata.s_buf = pmdata.data;
			pmdata.r_buf = pmdata.data;
			pm_LCD_brightness = 0x7f - pm_LCD_brightness / 2;
			if (pm_LCD_brightness < 0x25)
				pm_LCD_brightness = 0x25;
			if (pm_LCD_brightness > 0x5a)
				pm_LCD_brightness = 0x7f;
			pmdata.data[0] = pm_LCD_brightness;
			rval = pm_pmgrop_pm2(&pmdata);
			break;
		case 0x10:			/* ADB data that were requested by TALK command */
		case 0x14:
			pm_adb_get_TALK_result(&pmdata);
			break;
		case 0x16:			/* ADB device event */
		case 0x18:
		case 0x1e:
			pm_adb_get_ADB_data(&pmdata);
			break;
		default:
d865 4
a868 4
			if (adb_debug)
				pm_printerr("driver does not supported this event.",
				    pmdata.data[2], pmdata.num_data,
				    pmdata.data);
d870 1
a870 1
			break;
d886 8
a893 8
		case PM_HW_PB1XX:
			return (pm_pmgrop_pm1(pmdata));
			break;
		case PM_HW_PB5XX:
			return (pm_pmgrop_pm2(pmdata));
			break;
		default:
			return 1;
@


1.11
log
@Factorize akbd and ams drivers between mac68k and macppc; while there, start
moving out common adb code as well, and merge adb_direct.c into adb.c to
simplify external header files.

No functional change; more cleanups to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.10 2006/01/13 19:36:44 miod Exp $	*/
d45 1
d184 1
a184 1
void	pm_hw_setup(void);
a894 4

/*
 * My PM interrupt routine
 */
a900 1

a902 1

d904 1
a904 1
		break;
a905 2

	return (-1);
a907 1

d909 1
a909 1
pm_hw_setup(void)
d912 10
a921 10
		case PM_HW_PB1XX:
			via1_register_irq(4, pm_intr_pm1, NULL, NULL);
			PM_VIA_CLR_INTR();
			break;
		case PM_HW_PB5XX:
			via1_register_irq(4, pm_intr_pm2, NULL, NULL);
			PM_VIA_CLR_INTR();
			break;
		default:
			break;
@


1.10
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.9 2006/01/04 20:39:05 miod Exp $	*/
d49 1
@


1.9
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 2
a54 4
extern u_short ADBDelay;
extern u_int32_t HwCfgFlags3;
extern struct mac68k_machine_S mac68k_machine;

a176 3
/* this function is MRG-Based (for testing) */
int	pm_pmgrop_mrg(PMData *);

d180 1
a180 1
void	pm_intr(void *);
a875 20
 * MRG-based PMgrOp routine
 */
int
pm_pmgrop_mrg(PMData *pmdata)
{
	u_int32_t rval=0;

	__asm __volatile(
	"	movl	%1,a0	\n"
	"	.word	0xa085	\n"
	"	movl	d0,%0"
		: "=g" (rval)
		: "g" (pmdata)
		: "a0","d0");

	return rval;
}


/*
a888 1
			/* return (pmgrop_mrg(pmdata)); */
d897 1
a897 1
void
d901 8
a908 8
		case PM_HW_PB1XX:
			pm_intr_pm1(arg);
			break;
		case PM_HW_PB5XX:
			pm_intr_pm2(arg);
			break;
		default:
			break;
d910 2
@


1.8
log
@for reference purposes it makes more sense to have NetBSD RCSID here;
also fix a typo in comment
@
text
@d1 2
a2 2
/*	$OpenBSD: pm_direct.c,v 1.7 2004/11/25 18:32:10 miod Exp $	*/
/*	$NetBSD: pm_direct.c,v 1.4 1998/02/23 03:11:26 scottr Exp $	*/
d18 1
a18 1
 *  This product includes software developed by Takashi HAMADA
d33 1
d35 5
a40 1
/* #define	PM_DEBUG	1 */
d43 1
a43 2
#include <sys/types.h>
#include <sys/cdefs.h>
a44 1
#include <sys/time.h>
a45 1
#include <machine/adbsys.h>
a46 1
#include <machine/param.h>
d49 2
a50 4
#include <arch/mac68k/mac68k/macrom.h>
#include <arch/mac68k/dev/adbvar.h>

#include "pm_direct.h"
d55 2
d70 2
a71 2
#define PM_IS_ON		( 0x02 == (via_reg(VIA2, vBufB) & 0x02) )
#define PM_IS_OFF		( 0x00 == (via_reg(VIA2, vBufB) & 0x02) )
d73 1
a73 1
/* 
d84 32
a115 16
	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff, 0x00,0x00,0xff,0xff,0xff,0xff,0xff,0x00,
	0xff,0x00,0x02,0x01,0x01,0xff,0xff,0xff, 0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x04,0x14,0xff,0xff,0xff,0xff,0xff,0xff, 0x00,0x00,0x02,0xff,0xff,0xff,0xff,0xff,
	0x01,0x01,0xff,0xff,0xff,0xff,0xff,0xff, 0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
	0x01,0x00,0x02,0x02,0xff,0x01,0x03,0x01, 0x00,0x01,0x00,0x00,0x00,0xff,0xff,0xff,
	0x02,0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
	0x01,0x01,0x01,0xff,0xff,0xff,0xff,0xff, 0x00,0x00,0xff,0xff,0xff,0xff,0x04,0x04,
	0x04,0xff,0x00,0xff,0xff,0xff,0xff,0xff, 0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x01,0x02,0xff,0xff,0xff,0xff,0xff,0xff, 0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
	0x02,0x02,0x02,0x04,0xff,0x00,0xff,0xff, 0x01,0x01,0x03,0x02,0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0x01,0x01,0xff,0xff,0x00,0x00,0xff,0xff,
	0xff,0x04,0x00,0xff,0xff,0xff,0xff,0xff, 0x03,0xff,0x00,0xff,0x00,0xff,0xff,0x00,
	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
d120 32
a151 16
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x02,0x02,0xff,0xff,0xff,0xff,0xff,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x05,0x15,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x02,0x02,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x02,0x00,0x03,0x03,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x04,0x04,0x03,0x09,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x06,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x02,0x02,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x02,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x02,0x02,0xff,0xff,0x02,0xff,0xff,0xff,
	0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, 0xff,0xff,0x02,0xff,0xff,0xff,0xff,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
d160 2
a161 2
#ifdef PM_DEBUG
void pm_printerr( char *, int, int, char * );
d164 2
a165 2
int pm_wait_busy(int);
int pm_wait_free(int);
d168 4
a171 4
int pm_receive_pm1(u_char *);
int pm_send_pm1(u_char,int);
int pm_pmgrop_pm1(PMData *);
void pm_intr_pm1(void);
d174 4
a177 4
int pm_receive_pm2(u_char *);
int pm_send_pm2(u_char);
int pm_pmgrop_pm2(PMData *);
void pm_intr_pm2(void);
d180 1
a180 1
int pm_pmgrop_mrg(PMData *);
d183 5
a187 4
void pm_setup_adb(void);
void pm_check_adb_devices(int);
void pm_intr(void);
int pm_adb_op(u_char *, void *, void *, int);
d189 4
a192 4
/* these functions also use the valiables of adb_direct.c */
void pm_adb_get_TALK_result(PMData *);
void pm_adb_get_ADB_data(PMData *);
void pm_adb_poll_next_device_pm1(PMData *);
d196 1
a196 1
 * These valiables are in adb_direct.c.
a198 2
#define MAX_ADB_MSG_LENGTH	20
extern u_char	adbInputBuffer[MAX_ADB_MSG_LENGTH];      /* data input buffer */
d205 13
a217 5
/*
 * Define the external functions
 */
extern void adb_comp_exec(void);	/* from adb_direct.c */

d219 1
a219 1
#ifdef PM_DEBUG
d224 1
a224 5
pm_printerr(ttl, rval, num, data)
	char	*ttl;
	int	rval;
	int	num;
	char	*data;
d228 4
a231 4
	printf( "pm: %s:%04x %02x ", ttl, rval, num );
	for( i=0; i<num; i++ )
		printf( "%02x ", data[i] );
	printf( "\n" );
a245 1
		case MACH_MACPB150:
d254 1
d262 2
d276 1
a276 2
pm_check_adb_devices(id)
	int id;
d289 1
a289 2
pm_wait_busy(delay)
	int delay;
d291 1
a291 1
	while(PM_IS_ON) {
d293 1
a293 1
		(void)intr_dispatch(0x70);
d295 2
a296 2
		if ((--delay) < 0)
			return( 1 );	/* timeout */
d298 1
a298 1
	return( 0 );
d306 1
a306 2
pm_wait_free(delay)
	int delay;
d308 1
a308 1
	while(PM_IS_OFF) {
d310 1
a310 1
		(void)intr_dispatch(0x70);
d312 2
a313 2
		if ((--delay) < 0)
			return( 0 );	/* timeout */
d315 1
a315 1
	return( 1 );
d328 1
a328 2
pm_receive_pm1(data)
	u_char *data;
d334 1
a334 1
	switch( 1 ) {
d336 1
a336 1
			if (pm_wait_busy( 0x40 ) != 0)
d343 1
a343 1
			if (pm_wait_free( 0x40 ) == 0)
d353 1
a353 1
	return( rval );
d362 1
a362 3
pm_send_pm1(data, delay)
	u_char data;
	int delay;
d364 1
a364 1
	int	rval;
d370 5
a374 1
	if (pm_wait_busy( 0x400 ) != 0) {
d376 6
a381 3
		via_reg(VIA2, vDirA) = 0x00;

		return( 0xffffcd36 );		
a383 5
	rval = 0x0;
	PM_SET_STATE_ACKON();
	if (pm_wait_free( 0x40 ) == 0)
		rval = 0xffffcd35;

d387 1
a387 1
	return( rval );
d395 1
a395 2
pm_pmgrop_pm1(pmdata)
	PMData *pmdata;
d397 8
a404 8
	int	i;
	int	s = 0x81815963;
	u_char	via1_vIER, via1_vDirA;
	int	rval = 0;
	int	num_pm_data = 0;
	u_char	pm_cmd;	
	u_char	pm_data;
	u_char	*pm_buf;
d412 1
a412 1
	switch( pmdata->command ) {
d414 1
a414 1
			for( i=0; i<7; i++ ) {
d418 1
a418 1
				if (pm_wait_free( ADBDelay ) == 0) {	/* timeout */
d423 1
a423 1
					return( 0xffffcd38 );
d426 1
a426 1
				switch( mac68k_machine.machineid ) {
d430 1
d434 1
a434 1
							int delay = ADBDelay * 16;
d437 2
a438 2
							while((via_reg(VIA2, 0x200) == 0x7f) && (delay >= 0))
								delay--;
d440 1
a440 1
							if (delay < 0) {	/* timeout */
d444 1
a444 1
								return( 0xffffcd38 );
d449 1
a449 1
				s=splhigh();
d455 2
a456 2
				if ((rval = pm_send_pm1( pm_cmd, ADBDelay*8 )) == 0)	/* succeeded to send PM command */
					break;
d468 3
a470 1
					return( 0xffffcd38 );
d475 1
a475 1
			if ((rval = pm_send_pm1( (u_char)(num_pm_data & 0xff), ADBDelay*8 )) != 0)
d480 3
a482 3
			for( i=0; i<num_pm_data; i++ )
				if((rval = pm_send_pm1( pm_buf[i], ADBDelay*8 )) != 0)
					break;			/* timeout */
d484 1
a484 1
				break;				/* timeout */
d489 1
a489 1
				break;				/* no returned data */
d493 1
a493 1
			if (pm_wait_busy( ADBDelay ) != 0) {
a494 1
			}
d497 1
a497 1
			if ((rval = pm_receive_pm1( &pm_data )) != 0)
d503 2
a504 2
			if ((rval = pm_receive_pm1( &pm_data )) != 0)
				break;				/* timeout */
d510 3
a512 3
			for( i=0; i<num_pm_data; i++ ) {
				if ((rval = pm_receive_pm1( &pm_data )) != 0)
					break;				/* timeout */
d527 1
a527 1
	return( rval );
d532 1
a532 1
 * My PM interrupt routine for PB100-series
d534 2
a535 2
void
pm_intr_pm1(void)
d537 3
a539 3
	int	s;
	int	rval;
	PMData	pmdata;
d551 1
a551 1
	rval = pm_pmgrop_pm1( &pmdata );
d553 3
a555 2
#ifdef PM_DEBUG
		printf( "pm: PM is not ready. error code=%08x\n", rval );
a557 1
		return;
d561 2
a562 1
		if ((pmdata.data[2] & 0x0f) == 0) {	/* ADB data that were requested by TALK command */
d564 2
a565 1
		} else if ((pmdata.data[2] & 0x08) == 0x8) {	/* PM is requesting to poll  */
d567 2
a568 1
		} else if ((pmdata.data[2] & 0x04) == 0x4) {	/* ADB device event */
d572 4
a575 2
#ifdef PM_DEBUG
		pm_printerr( "driver does not supported this event.", rval,  pmdata.num_data, pmdata.data );
d580 2
d594 1
a594 2
pm_receive_pm2(data)
	u_char *data;
d596 2
a597 2
	int	i;
	int	rval;
d601 1
a601 1
	switch( 1 ) {
d626 1
a626 1
	return( rval );
d635 1
a635 2
pm_send_pm2(data)
	u_char data;
d637 1
a637 1
	int	rval;
d643 1
a643 2
	rval = 0xffffcd36;
	if (pm_wait_busy((int)ADBDelay*32) != 0) {
d645 6
a650 4

		via_reg(VIA1, vACR) |= 0x1c;

		return( rval );		
a653 5
	rval = 0xffffcd35;
	if (pm_wait_free((int)ADBDelay*32) != 0)
		rval = 0;

	PM_SET_STATE_ACKON();
d656 1
a656 1
	return( rval );
d665 1
a665 2
pm_pmgrop_pm2(pmdata)
	PMData *pmdata;
d667 9
a675 9
	int	i;
	int	s;
	u_char	via1_vIER;
	int	rval = 0;
	int	num_pm_data = 0;
	u_char	pm_cmd;	
	short	pm_num_rx_data;
	u_char	pm_data;
	u_char	*pm_buf;
d677 1
a677 1
	s=splhigh();
d686 1
a686 1
	switch( pmdata->command ) {
d691 1
a691 1
			if (pm_wait_free( ADBDelay * 4 ) == 0)
d694 3
a696 2
			if (HwCfgFlags3 & 0x00200000) {		/* PB 160, PB 165(c), PB 180(c) ? */
				int	delay = ADBDelay * 16;
d699 3
a701 2
				while((via_reg(VIA2, 0x200) == 0x07) && (delay >= 0))
					delay--;
d703 1
a703 1
				if (delay < 0) {
d710 1
a710 1
			if ((rval = pm_send_pm2( (u_char)(pm_cmd & 0xff) )))
d717 1
a717 1
					if ((rval = pm_send_pm2( (u_char)(num_pm_data & 0xff) )) != 0)
d722 1
a722 1
				if ((rval = pm_send_pm2( (u_char)(num_pm_data & 0xff) )) != 0)
d727 2
a728 2
			for( i=0; i<num_pm_data; i++ )
				if((rval = pm_send_pm2( pm_buf[i] )) != 0)
d747 1
a747 1
					if ((rval = pm_receive_pm2( &pm_data )) != 0) {
d753 1
a753 1
				if ((rval = pm_receive_pm2( &pm_data )) != 0) {
d763 1
a763 1
					if ((rval = pm_receive_pm2( &pm_data )) != 0)
d770 1
a770 1
				if ((rval = pm_receive_pm2( &pm_data )) != 0)
d778 2
a779 2
			for( i=0; i<num_pm_data; i++ ) {
				if ((rval = pm_receive_pm2( &pm_data )) != 0)
d791 1
a791 1
	return( rval );
d798 2
a799 2
void
pm_intr_pm2(void)
d801 3
a803 3
	int	s;
	int	rval;
	PMData	pmdata;
d807 2
a808 2
	PM_VIA_CLR_INTR();				/* clear VIA1 interrupt */
							/* ask PM what happend */
d813 1
a813 1
	rval = pm_pmgrop_pm2( &pmdata );
d815 3
a817 2
#ifdef PM_DEBUG
		printf( "pm: PM is not ready. error code: %08x\n", rval );
a819 1
		return;
d822 2
a823 3
	switch( (u_int)(pmdata.data[2] & 0xff) ) {
		case 0x00:				/* 1 sec interrupt? */
			{
d825 1
a825 3
			}
		case 0x80:				/* 1 sec interrupt? */
			{
d828 1
a828 3
			}
		case 0x08:				/* Brightness/Contrast button on LCD panel */
			{
d833 1
a833 1
			pm_printerr( "#08", rval, pmdata.num_data, pmdata.data );
d839 2
a840 2
			rval = pm_pmgrop_pm2( &pmdata );
			pm_printerr( "#33", rval, pmdata.num_data, pmdata.data );
d848 4
a851 2
			if (pm_LCD_brightness < 0x25)	pm_LCD_brightness = 0x25;
			if (pm_LCD_brightness > 0x5a)	pm_LCD_brightness = 0x7f;
d853 1
a853 1
			rval = pm_pmgrop_pm2( &pmdata );
d855 1
a855 3
			}
							/* ADB data that were requested by TALK command */
		case 0x10:
d859 1
a859 2
							/* ADB device event */
		case 0x16:
d865 5
a869 3
			{
#ifdef PM_DEBUG
			pm_printerr( "driver does not supported this event.", pmdata.data[2], pmdata.num_data, pmdata.data );
a870 1
			}
d875 2
d884 1
a884 2
pm_pmgrop_mrg(pmdata)
	PMData *pmdata;
d888 4
a891 4
	asm("
		movl	%1, a0
		.word   0xa085
		movl	d0, %0"
d894 1
a894 1
		: "a0", "d0" );
d904 1
a904 2
pmgrop(pmdata)
	PMData *pmdata;
d906 1
a906 1
	switch( pmHardware ) {
d908 1
a908 2
			{
			return( pm_pmgrop_pm1(pmdata) );
a909 1
			}
d911 1
a911 2
			{
			return( pm_pmgrop_pm2(pmdata) );
a912 1
			}
d914 2
a915 2
/*			return( pmgrop_mrg(pmdata) );	*/
			return( -1 );
d924 1
a924 1
pm_intr(void)
d926 1
a926 1
	switch( pmHardware ) {
d928 1
a928 2
			{
			pm_intr_pm1();
a929 1
			}
d931 1
a931 2
			{
			pm_intr_pm2();
a932 1
			}
d939 17
d961 8
a968 11
pm_adb_op(buffer, compRout, data, command)
	u_char *buffer;
	void *compRout;
	void *data;
	int command;
{
	int	i,len;
	int	s;
	int	rval;
	int	delay;
	PMData	pmdata;
d971 1
a971 1
		return( -1 );
d996 1
a996 1
			for( i=0; i<buffer[0]; i++ )
d1003 21
a1023 7
	rval = pmgrop( &pmdata );
	if (rval != 0)
		return( -1 );

	if (adbWaiting == 0) {
		adbWaiting = 1;
		adbWaitingCmd = command;
d1026 3
d1031 20
a1050 5
	/* wait until the PM interrupt is occurred */
	delay = 0x80000;
	while(adbWaiting == 1) {
		if ((via_reg(VIA1, vIFR) & 0x10) == 0x10)
			pm_intr();
d1052 1
a1052 1
			(void)intr_dispatch(0x70);
d1054 4
a1057 10
		if ((--delay) < 0)
			return( -1 );
	}

	if (buffer != (u_char *)0) {
		len = adbInputBuffer[3];
		for (i=0; i<=len; i++)
				buffer[i] = adbInputBuffer[3 + i];
		if (len < 0)
			buffer[0] = 0;	
d1060 2
a1061 2
	/* this command enables the interrupt by operating ADB devices */ 
	if (HwCfgFlags3 & 0x00020000) {		/* PB Duo series, PB 500 series */
d1070 1
a1070 1
	} else {				/* PB 100-series */
d1079 1
a1079 1
	rval = pmgrop( &pmdata );
d1082 1
a1082 1
	return( rval );
d1087 1
a1087 2
pm_adb_get_TALK_result(pmdata)
	PMData *pmdata;
d1090 1
a1090 3
	int rx_pm_adb_cmd;

	rx_pm_adb_cmd = (u_int)pmdata->data[3] & 0xff;
d1092 19
a1110 19
	pmdata->data[2] &= 0xf;
	pmdata->data[1] = pmdata->data[3];
	pmdata->data[3] = pmdata->num_data - 2;

	adbInputBuffer[0] = pmdata->num_data + 1;
	for( i=1; i<pmdata->num_data+2; i++ )
		adbInputBuffer[i] = pmdata->data[i];

	if ((adbWaiting == 1) && (rx_pm_adb_cmd == adbWaitingCmd)) {
		if (adbStarting == 0)
			adb_complete( &pmdata->data[3] , (long)0, adbWaitingCmd );
		adbWaitingCmd = 0x0;
					
		adbWaiting = 0;
		adb_comp_exec();
		adbBuffer = (long)0;
		adbCompRout = (long)0;
		adbCompData = (long)0;
	}
d1115 1
a1115 2
pm_adb_get_ADB_data(pmdata)
	PMData *pmdata;
d1118 1
d1120 8
a1127 8
	i = (u_int)pmdata->data[3] & 0xff;
	pmdata->data[2] &= 0xf;
	pmdata->data[1] = pmdata->data[3];
	pmdata->data[3] = pmdata->num_data - 2;

	adbInputBuffer[0] = pmdata->num_data + 1;
	if (adbStarting == 0)
		adb_complete( &pmdata->data[3] , (long)0, i );
d1132 1
a1132 2
pm_adb_poll_next_device_pm1(pmdata)
	PMData *pmdata;
d1141 2
a1142 2
	for( i=1; i<16; i++ ) {
		ndid = (((pmdata->data[3] & 0xf0) >> 4) + i) & 0xf;
d1156 1
a1156 1
	rval = pmgrop( &tmp_pmdata );
a1157 2


@


1.7
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 2
a2 2
/*	$OpenBSD: pm_direct.c,v 1.6 2003/03/14 10:47:36 miod Exp $	*/
/*  pm_direct.c 1.22 01/09/97 Takashi Hamada */
d73 1
a73 1
 * Valiables for internal use
@


1.6
log
@spl police.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.5 2002/03/14 01:26:35 millert Exp $	*/
a175 1
extern int zshard(int);			/* from zs.c */
d257 1
a257 1
		zshard(0);		/* grab any serial interrupts */
d275 1
a275 1
		zshard(0);		/* grab any serial interrupts */
d982 1
a982 1
			zshard(0);		/* grab any serial interrupts */
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.4 2001/09/20 17:02:30 mpech Exp $	*/
d523 1
d783 1
@


1.4
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.3 1998/05/03 07:13:00 gene Exp $	*/
d128 1
a128 1
void pm_printerr __P(( char *, int, int, char * ));
d131 2
a132 2
int pm_wait_busy __P((int));
int pm_wait_free __P((int));
d135 4
a138 4
int pm_receive_pm1 __P((u_char *));
int pm_send_pm1 __P((u_char,int));
int pm_pmgrop_pm1 __P((PMData *));
void pm_intr_pm1 __P((void));
d141 4
a144 4
int pm_receive_pm2 __P((u_char *));
int pm_send_pm2 __P((u_char));
int pm_pmgrop_pm2 __P((PMData *));
void pm_intr_pm2 __P((void));
d147 1
a147 1
int pm_pmgrop_mrg __P((PMData *));
d150 4
a153 4
void pm_setup_adb __P((void));
void pm_check_adb_devices __P((int));
void pm_intr __P((void));
int pm_adb_op __P((u_char *, void *, void *, int));
d156 3
a158 3
void pm_adb_get_TALK_result __P((PMData *));
void pm_adb_get_ADB_data __P((PMData *));
void pm_adb_poll_next_device_pm1 __P((PMData *));
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.4 2001/09/20 17:02:30 mpech Exp $	*/
d128 1
a128 1
void pm_printerr( char *, int, int, char * );
d131 2
a132 2
int pm_wait_busy(int);
int pm_wait_free(int);
d135 4
a138 4
int pm_receive_pm1(u_char *);
int pm_send_pm1(u_char,int);
int pm_pmgrop_pm1(PMData *);
void pm_intr_pm1(void);
d141 4
a144 4
int pm_receive_pm2(u_char *);
int pm_send_pm2(u_char);
int pm_pmgrop_pm2(PMData *);
void pm_intr_pm2(void);
d147 1
a147 1
int pm_pmgrop_mrg(PMData *);
d150 4
a153 4
void pm_setup_adb(void);
void pm_check_adb_devices(int);
void pm_intr(void);
int pm_adb_op(u_char *, void *, void *, int);
d156 3
a158 3
void pm_adb_get_TALK_result(PMData *);
void pm_adb_get_ADB_data(PMData *);
void pm_adb_poll_next_device_pm1(PMData *);
@


1.4.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a522 1
		return;
a781 1
		return;
@


1.3
log
@Associated fallout from removing macinfo.h and merging to cpu.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.2 1997/04/06 16:35:18 briggs Exp $	*/
d975 1
a975 1
	/* wait until the PM interrupt is occured */
@


1.3.8.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.3 1998/05/03 07:13:00 gene Exp $	*/
d975 1
a975 1
	/* wait until the PM interrupt is occurred */
@


1.3.8.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d128 1
a128 1
void pm_printerr( char *, int, int, char * );
d131 2
a132 2
int pm_wait_busy(int);
int pm_wait_free(int);
d135 4
a138 4
int pm_receive_pm1(u_char *);
int pm_send_pm1(u_char,int);
int pm_pmgrop_pm1(PMData *);
void pm_intr_pm1(void);
d141 4
a144 4
int pm_receive_pm2(u_char *);
int pm_send_pm2(u_char);
int pm_pmgrop_pm2(PMData *);
void pm_intr_pm2(void);
d147 1
a147 1
int pm_pmgrop_mrg(PMData *);
d150 4
a153 4
void pm_setup_adb(void);
void pm_check_adb_devices(int);
void pm_intr(void);
int pm_adb_op(u_char *, void *, void *, int);
d156 3
a158 3
void pm_adb_get_TALK_result(PMData *);
void pm_adb_get_ADB_data(PMData *);
void pm_adb_poll_next_device_pm1(PMData *);
@


1.3.8.3
log
@Sync the SMP branch with 3.3
@
text
@a522 1
		return;
a781 1
		return;
@


1.2
log
@Now need sys/time.h here.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.1 1997/02/23 06:04:56 briggs Exp $	*/
a44 1
#include <machine/macinfo.h>
@


1.1
log
@Integrate code from John P. Wittkoski <jpw@@netwizards.net> and
Takashi Hamada <hamada@@next.etron.kanazawa-it.ac.jp>.  This code
interfaces directly to the hardware to support the ADB on many
macs.  It is enabled by "options HWDIRECT" in the configuration
file.  At some point, this should probably become the default method
as interfacing to the ADB through the ROMs has been painful and sometimes
problematic.

This code should have functioning ADB support for:
	II series (II, SE/30, IIx, IIcx)
	IIsi series (IIsi, IIci, IIvx, IIvi)
	LC II, LC III
	Performa 400, 405, 430, 460, 465, 467, 600
	Classic II, Color Classic, Color Classic II
	PB 5XX series
	Duo series
	PB 140,145,145b,160,(160c?),165,165c,170,180,180c
	Quadra 700,900,950
There is an off-chance that it will work on:
	PB 150, PB 190
	Quadra/Centris 605,610,630,650,660AV,800,840AV
	LC 475,550,575,630
	Performa 475,476,575,577,578,630
Note that functioning ADB support does not mean that everything else
will work.  I obviously do not own all of the above machines (does
anyone?  ;-)...  Any reports are welcome.

Many thanks to John Wittkoski and Takashi Hamada!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
@
