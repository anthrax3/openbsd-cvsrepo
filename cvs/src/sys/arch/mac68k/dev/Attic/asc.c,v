head	1.30;
access;
symbols
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.25.0.12
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.10
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.8
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_9_BASE:1.9
	NIKLAS_UNDEAD:1.9.0.10
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.29;

1.29
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.25.01.59.12;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2006.09.16.10.42.23;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.14.09.36.49;	author martin;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.15.20.03.06;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.22.18.37.56;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.23.19.00.26;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.23.23.28.58;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.24.22.25.12;	author martin;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.14.20.50.46;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.23.16.51.11;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.24.22.14.47;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.23.08.17.40;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.08.08.08.58;	author art;	state Exp;
branches;
next	1.9;

1.9
date	99.04.24.06.39.40;	author downsj;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	98.11.20.23.57.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.04.27.02.04.32;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.03.08.16.16.48;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	97.01.24.01.35.29;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.18.35.18;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.13.34;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.11.35.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.02;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.07.04.10.18.25;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.10.29.00.28.05;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: asc.c,v 1.29 2011/07/02 22:20:07 nicm Exp $	*/
/*	$NetBSD: asc.c,v 1.20 1997/02/24 05:47:33 scottr Exp $	*/

/*
 * Copyright (C) 1997 Scott Reynolds
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * ASC driver code and console bell support
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/poll.h>
#include <sys/timeout.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/bus.h>

#include <mac68k/dev/ascvar.h>
#include <mac68k/dev/obiovar.h>

#define	MAC68K_ASC_BASE		0x50f14000
#define	MAC68K_IIFX_ASC_BASE	0x50f10000
#define	MAC68K_ASC_LEN		0x01000

static u_int8_t		asc_wave_tab[0x800];

static int	asc_ring_bell(void *, int, int, int);
static void	asc_stop_bell(void *);

static int	ascmatch(struct device *, void *, void *);
static void	ascattach(struct device *, struct device *, void *);

struct cfattach asc_ca = {
	sizeof(struct asc_softc), ascmatch, ascattach
};

struct cfdriver asc_cd = {
	NULL, "asc", DV_DULL
};

static int
ascmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct obio_attach_args *oa = (struct obio_attach_args *)aux;
	bus_addr_t addr;
	bus_space_handle_t bsh;
	int rval = 0;

	if (oa->oa_addr != (-1))
		addr = (bus_addr_t)oa->oa_addr;
	else if (current_mac_model->machineid == MACH_MACTV)
		return 0;
	else if (current_mac_model->machineid == MACH_MACIIFX)
		addr = (bus_addr_t)MAC68K_IIFX_ASC_BASE;
	else
		addr = (bus_addr_t)MAC68K_ASC_BASE;

	if (bus_space_map(oa->oa_tag, addr, MAC68K_ASC_LEN, 0, &bsh))
		return (0);

	if (mac68k_bus_space_probe(oa->oa_tag, bsh, 0, 1))
		rval = 1;
	else
		rval = 0;

	bus_space_unmap(oa->oa_tag, bsh, MAC68K_ASC_LEN);

	return rval;
}

static void
ascattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct asc_softc *sc = (struct asc_softc *)self;
	struct obio_attach_args *oa = (struct obio_attach_args *)aux;
	bus_addr_t addr;
	int i;

	sc->sc_tag = oa->oa_tag;
	if (oa->oa_addr != (-1))
		addr = (bus_addr_t)oa->oa_addr;
	else if (current_mac_model->machineid == MACH_MACIIFX)
		addr = (bus_addr_t)MAC68K_IIFX_ASC_BASE;
	else
		addr = (bus_addr_t)MAC68K_ASC_BASE;
	if (bus_space_map(sc->sc_tag, addr, MAC68K_ASC_LEN, 0,
	    &sc->sc_handle)) {
		printf(": can't map mem space\n");
		return;
	}
	sc->sc_open = 0;
	sc->sc_ringing = 0;
	timeout_set(&sc->sc_bell_tmo, asc_stop_bell, sc);

	for (i = 0; i < 256; i++) {	/* up part of wave, four voices? */
		asc_wave_tab[i] = i / 4;
		asc_wave_tab[i + 512] = i / 4;
		asc_wave_tab[i + 1024] = i / 4;
		asc_wave_tab[i + 1536] = i / 4;
	}
	for (i = 0; i < 256; i++) {	/* down part of wave, four voices? */
		asc_wave_tab[i + 256] = 0x3f - (i / 4);
		asc_wave_tab[i + 768] = 0x3f - (i / 4);
		asc_wave_tab[i + 1280] = 0x3f - (i / 4);
		asc_wave_tab[i + 1792] = 0x3f - (i / 4);
	}

	printf(": Apple Sound Chip");
	if (oa->oa_addr != (-1))
		printf(" at %x", oa->oa_addr);
	printf("\n");

	mac68k_set_bell_callback(asc_ring_bell, sc);
}

int
ascopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	struct asc_softc *sc;
	int unit;

	unit = ASCUNIT(dev);
	if (unit >= asc_cd.cd_ndevs)
		return (ENXIO);
	sc = asc_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);
	if (sc->sc_open)
		return (EBUSY);
	sc->sc_open = 1;

	return (0);
}

int
ascclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	struct asc_softc *sc;

	sc = asc_cd.cd_devs[ASCUNIT(dev)];
	sc->sc_open = 0;

	return (0);
}

int
ascread(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
{
	return (ENXIO);
}

int
ascwrite(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
{
	return (ENXIO);
}

int
ascioctl(dev, cmd, data, flag, p)
	dev_t dev;
	int cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct asc_softc *sc;
	int error;
	int unit = ASCUNIT(dev);

	sc = asc_cd.cd_devs[unit];
	error = 0;

	switch (cmd) {
	default:
		error = EINVAL;
		break;
	}
	return (error);
}

int
ascpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	/* always fails => never blocks */
	return (events & (POLLOUT | POLLWRNORM));
}

paddr_t
ascmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	int unit = ASCUNIT(dev);
	struct asc_softc *sc;
	paddr_t pa;

	sc = asc_cd.cd_devs[unit];
	if (off >= 0 && off < MAC68K_ASC_LEN) {
		(void)pmap_extract(pmap_kernel(),
		    (vaddr_t)bus_space_vaddr(sc->sc_tag, sc->sc_handle), &pa);
		return (pa + off);
	}

	return (-1);
}

static int
asc_ring_bell(arg, freq, length, volume)
	void *arg;
	int freq, length, volume;
{
	struct asc_softc *sc = (struct asc_softc *)arg;
	unsigned long cfreq;
	int i;

	if (!sc)
		return (ENODEV);

	if (sc->sc_ringing == 0) {
		bus_space_set_region_1(sc->sc_tag, sc->sc_handle,
		    0, 0, 0x800);
		bus_space_write_region_1(sc->sc_tag, sc->sc_handle,
		    0, asc_wave_tab, 0x800);

		/* Fix this.  Need to find exact ASC sampling freq */
		cfreq = 65536 * freq / 466;

		/* printf("beep: from %d, %02x %02x %02x %02x\n",
		 * cur_beep.freq, (cfreq >> 24) & 0xff, (cfreq >> 16) & 0xff,
		 * (cfreq >> 8) & 0xff, (cfreq) & 0xff); */
		for (i = 0; i < 8; i++) {
			bus_space_write_1(sc->sc_tag, sc->sc_handle,
			    0x814 + 8 * i, (cfreq >> 24) & 0xff);
			bus_space_write_1(sc->sc_tag, sc->sc_handle,
			    0x815 + 8 * i, (cfreq >> 16) & 0xff);
			bus_space_write_1(sc->sc_tag, sc->sc_handle,
			    0x816 + 8 * i, (cfreq >> 8) & 0xff);
			bus_space_write_1(sc->sc_tag, sc->sc_handle,
			    0x817 + 8 * i, (cfreq) & 0xff);
		}		/* frequency; should put cur_beep.freq in here
				 * somewhere. */

		bus_space_write_1(sc->sc_tag, sc->sc_handle, 0x807, 3); /* 44 ? */
		bus_space_write_1(sc->sc_tag, sc->sc_handle, 0x806,
		    255 * volume / 100);
		bus_space_write_1(sc->sc_tag, sc->sc_handle, 0x805, 0);
		bus_space_write_1(sc->sc_tag, sc->sc_handle, 0x80f, 0);
		bus_space_write_1(sc->sc_tag, sc->sc_handle, 0x802, 2); /* sampled */
		bus_space_write_1(sc->sc_tag, sc->sc_handle, 0x801, 2); /* enable sampled */
		sc->sc_ringing = 1;
		timeout_add(&sc->sc_bell_tmo, length);
	}

	return (0);
}

static void
asc_stop_bell(arg)
	void *arg;
{
	struct asc_softc *sc = (struct asc_softc *)arg;

	if (!sc)
		return;

	if (sc->sc_ringing > 1000 || sc->sc_ringing < 0)
		panic("bell got out of sync?");

	if (--sc->sc_ringing == 0)	/* disable ASC */
		bus_space_write_1(sc->sc_tag, sc->sc_handle, 0x801, 0);
}

int asckqfilter(dev_t, struct knote *);

int
asckqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
{
	return (ENXIO);
}
@


1.29
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.28 2010/12/26 15:40:59 miod Exp $	*/
@


1.28
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.27 2010/05/25 01:59:12 deraadt Exp $	*/
d369 1
a369 1
	return (1);
@


1.27
log
@fix includes; fallout from the proc.h changes
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.26 2009/03/29 21:53:52 sthen Exp $	*/
d290 1
a290 1
		return atop(pa + off);
@


1.26
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.25 2006/09/16 10:42:23 miod Exp $	*/
d67 3
a69 2
#include <sys/types.h>
#include <sys/cdefs.h>
a71 2
#include <sys/systm.h>
#include <sys/param.h>
@


1.25
log
@Do not use bus_space_write_multi and happily write to NULL and die, when
bus_space_set_region was intended. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.24 2006/04/14 09:36:49 martin Exp $	*/
d160 1
a160 1
		printf(": can't map memory space\n");
@


1.24
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.23 2006/03/15 20:03:06 miod Exp $	*/
d310 1
a310 2

		bus_space_write_multi_1(sc->sc_tag, sc->sc_handle,
@


1.23
log
@Entries in cd_devs[] may be NULL, so be sure to check for them in your
device open() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.22 2006/01/22 18:37:56 miod Exp $	*/
d297 1
a297 1
static int 
d348 1
a348 1
static void 
@


1.22
log
@Add bus_space_vaddr() and use it instead of accessing private bus_space
fields. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.21 2005/10/23 19:00:26 martin Exp $	*/
d199 2
d202 1
a202 1
	if (unit >= asc_cd.cd_ndevs)
@


1.21
log
@m68k_btop() and m68k_ptob() were mostly used by mac68k only and can
be replaced by the MI versions atop() and ptoa()
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.20 2005/09/12 10:07:29 martin Exp $	*/
d287 2
a288 2
		(void)pmap_extract(pmap_kernel(), (vaddr_t)sc->sc_handle.base,
		    &pa);
@


1.20
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.19 2005/07/23 23:28:58 martin Exp $	*/
d289 1
a289 1
		return m68k_btop(pa + off);
@


1.19
log
@vm_offset_t -> {vaddr_t, bus_addr_t}
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.18 2005/04/24 22:25:12 martin Exp $	*/
d287 2
a288 1
		pmap_extract(pmap_kernel(), (vaddr_t)sc->sc_handle, &pa);
@


1.18
log
@- switch Scott Reynold's copyright to 3-clause BSD
- do not attach on the MacTV, fix base address on the IIfx (untested)
- no need to count sc->sc_ringing up, just set to 1 if ringing; timeout fix

ok miod@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.17 2004/01/14 20:50:46 miod Exp $	*/
d287 1
a287 1
		pmap_extract(pmap_kernel(), (vm_offset_t)sc->sc_handle, &pa);
@


1.17
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.16 2003/09/23 16:51:11 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Scott Reynolds for
 *      the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
d85 2
a86 2
#include "ascvar.h"
#include "obiovar.h"
d88 3
a90 2
#define	MAC68K_ASC_BASE	0x50f14000
#define	MAC68K_ASC_LEN	0x01000
d119 8
a126 2
	addr = (bus_addr_t)(oa->oa_addr != (-1) ?
	    oa->oa_addr : MAC68K_ASC_BASE);
d152 6
a157 2
	addr = (bus_addr_t)(oa->oa_addr != (-1) ?
	    oa->oa_addr : MAC68K_ASC_BASE);
d165 1
a184 1
	timeout_set(&sc->sc_bell_tmo, asc_stop_bell, sc);
d338 2
a340 2
	sc->sc_ringing++;
	timeout_add(&sc->sc_bell_tmo, length);
a367 1

@


1.16
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.15 2002/06/24 22:14:47 miod Exp $	*/
d108 1
a108 1
	NULL, "asc", DV_DULL, NULL, 0
@


1.15
log
@Provide dummy d_kqfilter() routine so that this compiles, until this driver
is rewritten to use the MI audio framework.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.14 2002/03/14 01:26:35 millert Exp $	*/
d79 1
d259 1
a259 1
ascselect(dev, rw, p)
d261 1
a261 1
	int rw;
d264 2
a265 10
	switch (rw) {
	case FREAD:
		break;

	case FWRITE:
		return (1);	/* always fails => never blocks */
		break;
	}

	return (0);
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.13 2001/11/06 19:53:14 miod Exp $	*/
d359 11
@


1.13
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.12 2001/11/01 12:13:46 art Exp $	*/
d96 2
a97 2
static int	asc_ring_bell __P((void *, int, int, int));
static void	asc_stop_bell __P((void *));
d99 2
a100 2
static int	ascmatch __P((struct device *, void *, void *));
static void	ascattach __P((struct device *, struct device *, void *));
@


1.13.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.13 2001/11/06 19:53:14 miod Exp $	*/
d96 2
a97 2
static int	asc_ring_bell(void *, int, int, int);
static void	asc_stop_bell(void *);
d99 2
a100 2
static int	ascmatch(struct device *, void *, void *);
static void	ascattach(struct device *, struct device *, void *);
@


1.13.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.13.2.1 2002/06/11 03:36:18 art Exp $	*/
a358 11
}

int asckqfilter(dev_t, struct knote *);

int
asckqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
{

	return (1);
@


1.12
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.11 2001/08/23 08:17:40 miod Exp $	*/
d81 2
a82 2
#include <vm/vm.h>
#include <vm/pmap.h>
@


1.11
log
@Convert the last old-timeout, tested by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.10 2001/06/08 08:08:58 art Exp $	*/
d275 1
a275 1
int
d278 1
a278 1
	int off;
@


1.10
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.9 1999/04/24 06:39:40 downsj Exp $	*/
d79 1
d176 1
d340 1
a340 1
	timeout(asc_stop_bell, sc, length);
@


1.9
log
@Use the generic m68k param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.8 1998/11/20 23:57:24 deraadt Exp $	*/
d281 1
a281 1
	vm_offset_t pa;
d285 1
a285 1
		pa = pmap_extract(pmap_kernel(), (vm_offset_t)sc->sc_handle);
@


1.9.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.9 1999/04/24 06:39:40 downsj Exp $	*/
d281 1
a281 1
	paddr_t pa;
d285 1
a285 1
		pmap_extract(pmap_kernel(), (vm_offset_t)sc->sc_handle, &pa);
@


1.9.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.9.4.1 2001/07/04 10:18:25 niklas Exp $	*/
a78 1
#include <sys/timeout.h>
a174 1
	timeout_set(&sc->sc_bell_tmo, asc_stop_bell, sc);
d338 1
a338 1
	timeout_add(&sc->sc_bell_tmo, length);
@


1.9.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 2
a82 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>
d275 1
a275 1
paddr_t
d278 1
a278 1
	off_t off;
@


1.9.4.4
log
@Merge in -current from about a week ago
@
text
@d96 2
a97 2
static int	asc_ring_bell(void *, int, int, int);
static void	asc_stop_bell(void *);
d99 2
a100 2
static int	ascmatch(struct device *, void *, void *);
static void	ascattach(struct device *, struct device *, void *);
@


1.9.4.5
log
@Sync the SMP branch with 3.3
@
text
@a359 11

int asckqfilter(dev_t, struct knote *);

int
asckqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
{

	return (1);
}
@


1.9.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a78 1
#include <sys/poll.h>
d107 1
a107 1
	NULL, "asc", DV_DULL
d258 1
a258 1
ascpoll(dev, events, p)
d260 1
a260 1
	int events;
d263 10
a272 2
	/* always fails => never blocks */
	return (events & (POLLOUT | POLLWRNORM));
@


1.8
log
@careful mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.7 1998/04/27 02:04:32 gene Exp $	*/
d286 1
a286 1
		return mac68k_btop(pa + off);
@


1.7
log
@Adapt to new bus_space functions after fixing namespace issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.6 1997/03/08 16:16:48 briggs Exp $	*/
d284 1
a284 1
	if (off < MAC68K_ASC_LEN) {
@


1.6
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.5 1997/01/24 01:35:29 briggs Exp $	*/
d126 1
a126 1
	if (bus_probe(oa->oa_tag, bsh, 0, 1))
@


1.5
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: asc.c,v 1.4 1996/05/26 18:35:18 briggs Exp $	*/
/*	$NetBSD: asc.c,v 1.15 1996/12/16 16:17:02 scottr Exp $	*/
d4 30
d68 1
a68 1
 * ASC driver code and asc_ringbell() support
d78 4
d85 1
d88 1
d90 2
a91 2
/* Global ASC location */
volatile unsigned char *ASCBase = (unsigned char *) 0x14000;
d93 1
d95 2
a96 6
/* bell support data */
static int asc_configured = 0;
static int bell_freq = 1880;
static int bell_length = 10;
static int bell_volume = 100;
static int bell_ringing = 0;
d98 2
a99 2
static int  ascmatch __P((struct device *, struct cfdata *, void *));
static void ascattach __P((struct device *, struct device *, void *));
d102 1
a102 1
	sizeof(struct device), ascmatch, ascattach
d110 1
a110 1
ascmatch(parent, cf, aux)
d112 1
a112 1
	struct cfdata *cf;
d115 19
a133 3
	if (badbaddr((unsigned char *) ASCBase))
		return 0;
	return 1;
d137 58
a194 30
ascattach(parent, dev, aux)
	struct device *parent, *dev;
	void   *aux;
{
	printf(" Apple sound chip.\n");
	asc_configured = 1;
}

int 
asc_setbellparams(freq, length, volume)
    int freq;
    int length;
    int volume;
{
	if (!asc_configured) return (ENODEV);

	/* I only perform these checks for sanity. */
	/* I suppose someone might want a bell that rings */
	/* all day, but then the can make kernel mods themselves. */

	if (freq < 10 || freq > 40000)
		return (EINVAL);
	if (length < 0 || length > 3600)
		return (EINVAL);
	if (volume < 0 || volume > 100)
		return (EINVAL);

	bell_freq = freq;
	bell_length = length;
	bell_volume = volume;
d199 8
d208 2
a209 11
int 
asc_getbellparams(freq, length, volume)
    int *freq;
    int *length;
    int *volume;
{
	if (!asc_configured) return (ENODEV);

	*freq = bell_freq;
	*length = bell_length;
	*volume = bell_volume;
d214 8
d223 5
a227 3
void 
asc_bellstop(param)
    int param;
d229 2
a230 1
	if (!asc_configured) return;
d232 19
a250 4
	if (bell_ringing > 1000 || bell_ringing < 0)
		panic("bell got out of synch?????");
	if (--bell_ringing == 0) {
		ASCBase[0x801] = 0;
d252 1
a252 1
	/* disable ASC */
d255 17
d273 5
a277 2
int 
asc_ringbell()
d279 9
a287 2
	int     i;
	unsigned long freq;
d289 2
a290 1
	if (!asc_configured) return (ENODEV);
d292 18
a309 16
	if (bell_ringing == 0) {
		for (i = 0; i < 0x800; i++)
			ASCBase[i] = 0;

		for (i = 0; i < 256; i++) {
			ASCBase[i] = i / 4;
			ASCBase[i + 512] = i / 4;
			ASCBase[i + 1024] = i / 4;
			ASCBase[i + 1536] = i / 4;
		}		/* up part of wave, four voices ? */
		for (i = 0; i < 256; i++) {
			ASCBase[i + 256] = 0x3f - (i / 4);
			ASCBase[i + 768] = 0x3f - (i / 4);
			ASCBase[i + 1280] = 0x3f - (i / 4);
			ASCBase[i + 1792] = 0x3f - (i / 4);
		}		/* down part of wave, four voices ? */
d312 1
a312 1
		freq = 65536 * bell_freq / 466;
d315 2
a316 2
		 * cur_beep.freq, (freq >> 24) & 0xff, (freq >> 16) & 0xff,
		 * (freq >> 8) & 0xff, (freq) & 0xff); */
d318 8
a325 4
			ASCBase[0x814 + 8 * i] = (freq >> 24) & 0xff;
			ASCBase[0x815 + 8 * i] = (freq >> 16) & 0xff;
			ASCBase[0x816 + 8 * i] = (freq >> 8) & 0xff;
			ASCBase[0x817 + 8 * i] = (freq) & 0xff;
d329 7
a335 6
		ASCBase[0x807] = 3;	/* 44 ? */
		ASCBase[0x806] = 255 * bell_volume / 100;
		ASCBase[0x805] = 0;
		ASCBase[0x80f] = 0;
		ASCBase[0x802] = 2;	/* sampled */
		ASCBase[0x801] = 2;	/* enable sampled */
d337 17
a353 2
	bell_ringing++;
	timeout((void *) asc_bellstop, 0, bell_length);
d355 2
a356 1
	return 0;
@


1.4
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: asc.c,v 1.11 1996/05/05 06:16:26 briggs Exp $	*/
d48 2
d59 1
d65 1
a65 1
static int  ascmatch __P((struct device *, void *, void *));
d77 4
a80 3
ascmatch(pdp, match, auxp)
	struct device	*pdp;
	void	*match, *auxp;
d82 2
d93 1
d102 2
d129 2
d143 2
d159 2
@


1.3
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.2
log
@update from netbsd (without losing local changes)
@
text
@d1 1
a1 1
/*	$NetBSD: asc.c,v 1.9 1995/11/01 04:58:21 briggs Exp $	*/
d49 1
d61 1
a61 1
static int ascprobe __P((struct device *, struct cfdata *, void *));
a62 1
extern int matchbyname __P((struct device *, void *, void *));
d64 7
a70 3
struct cfdriver asccd =
{NULL, "asc", matchbyname, ascattach,
DV_DULL, sizeof(struct device), NULL, 0};
d73 3
a75 4
ascprobe(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void   *aux;
a76 3
	if (strcmp(*((char **) aux), asccd.cd_name))
		return 0;

a79 1

d89 4
a92 4
asc_setbellparams(
    int freq,
    int length,
    int volume)
d114 4
a117 4
asc_getbellparams(
    int *freq,
    int *length,
    int *volume)
d128 2
a129 2
asc_bellstop(
    int param)
d186 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: asc.c,v 1.8 1995/09/21 03:36:25 briggs Exp $	*/
a86 2

	ASCBase = IOBase + ASCBase;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
