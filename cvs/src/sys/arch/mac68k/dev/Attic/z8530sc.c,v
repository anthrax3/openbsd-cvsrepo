head	1.9;
access;
symbols
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.12
	OPENBSD_5_0:1.8.0.10
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.28
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.26
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.24
	OPENBSD_2_9_BASE:1.3
	NIKLAS_UNDEAD:1.3.0.22
	OPENBSD_2_8:1.3.0.20
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.8;

1.8
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.25.18.32.10;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.03.12.10.47;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.02.15.50.34;	author briggs;	state Exp;
branches
	1.3.16.1
	1.3.28.1;
next	1.2;

1.2
date	96.09.01.18.50.02;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	96.05.26.19.02.10;	author briggs;	state Exp;
branches;
next	;

1.3.16.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2003.06.07.11.13.13;	author ho;	state Exp;
branches;
next	;

1.3.28.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: z8530sc.c,v 1.8 2009/03/15 20:40:25 miod Exp $	*/
/*	$NetBSD: z8530sc.c,v 1.5 1996/12/17 20:42:40 gwr Exp $	*/

/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)zs.c	8.1 (Berkeley) 7/19/93
 */

/*
 * Zilog Z8530 Dual UART driver (common part)
 *
 * This file contains the machine-independent parts of the
 * driver common to tty and keyboard/mouse sub-drivers.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <mac68k/dev/z8530reg.h>
#include <machine/z8530var.h>

static void zsnull_intr(struct zs_chanstate *);
static void zsnull_softint(struct zs_chanstate *);

void
zs_break(cs, set)
	struct zs_chanstate *cs;
	int set;
{
	int s;

	s = splzs();
	if (set) {
		cs->cs_preg[5] |= ZSWR5_BREAK;
		cs->cs_creg[5] |= ZSWR5_BREAK;
	} else {
		cs->cs_preg[5] &= ~ZSWR5_BREAK;
		cs->cs_creg[5] &= ~ZSWR5_BREAK;
	}
	zs_write_reg(cs, 5, cs->cs_creg[5]);
	splx(s);
}


/*
 * drain on-chip fifo
 */
void
zs_iflush(cs)
	struct zs_chanstate *cs;
{
	u_char c, rr0, rr1;

	for (;;) {
		/* Is there input available? */
		rr0 = zs_read_csr(cs);
		if ((rr0 & ZSRR0_RX_READY) == 0)
			break;

		/*
		 * First read the status, because reading the data
		 * destroys the status of this char.
		 */
		rr1 = zs_read_reg(cs, 1);
		c = zs_read_data(cs);

		if (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {
			/* Clear the receive error. */
			zs_write_csr(cs, ZSWR0_RESET_ERRORS);
		}
	}
}
	

/*
 * Write the given register set to the given zs channel in the proper order.
 * The channel must not be transmitting at the time.  The receiver will
 * be disabled for the time it takes to write all the registers.
 * Call this with interrupts disabled.
 */
void
zs_loadchannelregs(cs)
	struct zs_chanstate *cs;
{
	u_char *reg;

	/* Copy "pending" regs to "current" */
	bcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);
	reg = cs->cs_creg;	/* current regs */

	zs_write_csr(cs, ZSM_RESET_ERR);	/* XXX: reset error condition */

#if 1
	/*
	 * XXX: Is this really a good idea?
	 * XXX: Should go elsewhere! -gwr
	 */
	zs_iflush(cs);	/* XXX */
#endif

	/* disable interrupts */
	zs_write_reg(cs, 1, reg[1] & ~ZSWR1_IMASK);

	/* baud clock divisor, stop bits, parity */
	zs_write_reg(cs, 4, reg[4]);

	/* misc. TX/RX control bits */
	zs_write_reg(cs, 10, reg[10]);

	/* char size, enable (RX/TX) */
	zs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);
	zs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);

	/* synchronous mode stuff */
	zs_write_reg(cs, 6, reg[6]);
	zs_write_reg(cs, 7, reg[7]);

#if 0
	/*
	 * Registers 2 and 9 are special because they are
	 * actually common to both channels, but must be
	 * programmed through channel A.  The "zsc" attach
	 * function takes care of setting these registers
	 * and they should not be touched thereafter.
	 */
	/* interrupt vector */
	zs_write_reg(cs, 2, reg[2]);
	/* master interrupt control */
	zs_write_reg(cs, 9, reg[9]);
#endif

	/* Shut down the BRG */
	zs_write_reg(cs, 14, reg[14] & ~ZSWR14_BAUD_ENA);
	
#ifdef ZS_MD_SETCLK
	/* Let the MD code setup any external clock. */
	ZS_MD_SETCLK(cs);
#endif /* ZS_MD_SETCLK */

	/* clock mode control */
	zs_write_reg(cs, 11, reg[11]);

	/* baud rate (lo/hi) */
	zs_write_reg(cs, 12, reg[12]);
	zs_write_reg(cs, 13, reg[13]);

	/* Misc. control bits */
	zs_write_reg(cs, 14, reg[14]);

	/* which lines cause status interrupts */
	zs_write_reg(cs, 15, reg[15]);

	/*
	 * Zilog docs recommend resetting external status twice at this
	 * point. Mainly as the status bits are latched, and the first
	 * interrupt clear might unlatch them to new values, generating
	 * a second interrupt request.
	 */
	zs_write_csr(cs, ZSM_RESET_STINT);
	zs_write_csr(cs, ZSM_RESET_STINT);

	/* char size, enable (RX/TX)*/
	zs_write_reg(cs, 3, reg[3]);
	zs_write_reg(cs, 5, reg[5]);

	/* interrupt enables: RX, TX, STATUS */
	zs_write_reg(cs, 1, reg[1]);
}


/*
 * ZS hardware interrupt.  Scan all ZS channels.  NB: we know here that
 * channels are kept in (A,B) pairs.
 *
 * Do just a little, then get out; set a software interrupt if more
 * work is needed.
 *
 * We deliberately ignore the vectoring Zilog gives us, and match up
 * only the number of `reset interrupt under service' operations, not
 * the order.
 */
int
zsc_intr_hard(arg)
	void *arg;
{
	register struct zsc_softc *zsc = arg;
	register struct zs_chanstate *cs;
	register u_char rr3;

	/* First look at channel A. */
	cs = zsc->zsc_cs[0];
	/* Note: only channel A has an RR3 */
	rr3 = zs_read_reg(cs, 3);

	/*
	 * Clear interrupt first to avoid a race condition.
	 * If a new interrupt condition happens while we are
	 * servicing this one, we will get another interrupt
	 * shortly.  We can NOT just sit here in a loop, or
	 * we will cause horrible latency for other devices
	 * on this interrupt level (i.e. sun3x floppy disk).
	 */
	if (rr3 & (ZSRR3_IP_A_RX | ZSRR3_IP_A_TX | ZSRR3_IP_A_STAT)) {
		zs_write_csr(cs, ZSWR0_CLR_INTR);
		if (rr3 & ZSRR3_IP_A_RX)
			(*cs->cs_ops->zsop_rxint)(cs);
		if (rr3 & ZSRR3_IP_A_STAT)
			(*cs->cs_ops->zsop_stint)(cs);
		if (rr3 & ZSRR3_IP_A_TX)
			(*cs->cs_ops->zsop_txint)(cs);
	}

	/* Now look at channel B. */
	cs = zsc->zsc_cs[1];
	if (rr3 & (ZSRR3_IP_B_RX | ZSRR3_IP_B_TX | ZSRR3_IP_B_STAT)) {
		zs_write_csr(cs, ZSWR0_CLR_INTR);
		if (rr3 & ZSRR3_IP_B_RX)
			(*cs->cs_ops->zsop_stint)(cs);
		if (rr3 & ZSRR3_IP_B_STAT)
			(*cs->cs_ops->zsop_stint)(cs);
		if (rr3 & ZSRR3_IP_B_TX)
			(*cs->cs_ops->zsop_txint)(cs);
	}

	/* Note: caller will check cs_x->cs_softreq and DTRT. */
	return (rr3);
}


/*
 * ZS software interrupt.  Scan all channels for deferred interrupts.
 */
void
zsc_intr_soft(arg)
	void *arg;
{
	register struct zsc_softc *zsc = arg;
	register struct zs_chanstate *cs;
	register int chan;

	for (chan = 0; chan < 2; chan++) {
		cs = zsc->zsc_cs[chan];

		/*
		 * The softint flag can be safely cleared once
		 * we have decided to call the softint routine.
		 * (No need to do splzs() first.)
		 */
		if (cs->cs_softreq) {
			cs->cs_softreq = 0;
			(*cs->cs_ops->zsop_softint)(cs);
		}
	}
}

/*
 * Provide a null zs "ops" vector.
 */

static void zsnull_intr(struct zs_chanstate *);
static void zsnull_softint(struct zs_chanstate *);

static void
zsnull_intr(cs)
	struct zs_chanstate *cs;
{
	/* Ask for softint() call. */
	cs->cs_softreq = 1;
}

static void
zsnull_softint(cs)
	struct zs_chanstate *cs;
{
	zs_write_reg(cs,  1, 0);
	zs_write_reg(cs, 15, 0);
}

struct zsops zsops_null = {
	zsnull_intr,	/* receive char available */
	zsnull_intr,	/* external/status */
	zsnull_intr,	/* xmit buffer empty */
	zsnull_softint,	/* process software interrupt */
};
@


1.8
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530sc.c,v 1.7 2004/11/25 18:32:10 miod Exp $	*/
@


1.7
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530sc.c,v 1.6 2004/08/03 12:10:47 todd Exp $	*/
d232 2
a233 9
	register struct zs_chanstate *cs_a;
	register struct zs_chanstate *cs_b;
	register int rval;
	register u_char rr3, rr3a;

	cs_a = zsc->zsc_cs[0];
	cs_b = zsc->zsc_cs[1];
	rval = 0;
	rr3a = 0;
d235 2
d238 1
a238 1
	while ((rr3 = zs_read_reg(cs_a, 3)) != 0) {
d240 10
a249 1
		/* Handle receive interrupts first. */
d251 1
a251 5
			(*cs_a->cs_ops->zsop_rxint)(cs_a);
		if (rr3 & ZSRR3_IP_B_RX)
			(*cs_b->cs_ops->zsop_stint)(cs_b);
	
		/* Handle status interrupts (i.e. flow control). */
d253 1
a253 5
			(*cs_a->cs_ops->zsop_stint)(cs_a);
		if (rr3 & ZSRR3_IP_B_STAT)
			(*cs_b->cs_ops->zsop_stint)(cs_b);

		/* Handle transmit done interrupts. */
d255 1
a255 6
			(*cs_a->cs_ops->zsop_txint)(cs_a);
		if (rr3 & ZSRR3_IP_B_TX)
			(*cs_b->cs_ops->zsop_txint)(cs_b);

		/* Accumulate so we know what needs to be cleared. */
		rr3a |= rr3;
a256 1
			
d258 10
a267 8
	/* Clear interrupt. */
	if (rr3a & (ZSRR3_IP_A_RX | ZSRR3_IP_A_TX | ZSRR3_IP_A_STAT)) {
		zs_write_csr(cs_a, ZSWR0_CLR_INTR);
		rval |= 1;
	}
	if (rr3a & (ZSRR3_IP_B_RX | ZSRR3_IP_B_TX | ZSRR3_IP_B_STAT)) {
		zs_write_csr(cs_b, ZSWR0_CLR_INTR);
		rval |= 2;
d271 1
a271 1
	return (rval);
d278 1
a278 1
int
d284 1
a284 1
	register int rval, chan;
a285 1
	rval = 0;
a296 1
			rval++;
a298 1
	return (rval);
@


1.6
log
@the rest of the '#if DIAGNOSTIC' -> '#ifdef DIAGNOSTIC' in the kernel; ok miod@@
@
text
@d1 2
a2 2
/*	$OpenBSD: z8530sc.c,v 1.5 2003/06/02 23:27:49 millert Exp $	*/
/*	$NetBSD: z8530sc.c,v 1.1 1996/05/18 18:54:28 briggs Exp $	*/
d64 1
a64 2
/* #include <dev/ic/z8530reg.h> */
#include "z8530reg.h"
d67 4
a70 1
int
a86 2

	return 0;
a90 14
 * Compute the current baud rate given a ZSCC channel.
 */
int
zs_getspeed(cs)
	struct zs_chanstate *cs;
{
	int tconst;

	tconst = zs_read_reg(cs, 12);
	tconst |= zs_read_reg(cs, 13) << 8;
	return (TCONST_TO_BPS(cs->cs_pclk_div16, tconst));
}

/*
a118 43
/*
 * Figure out if a chip is an NMOS 8530, a CMOS 8530,
 * or an 85230. We use a form of the test in the Zilog SCC
 * users manual.
 */
int
zs_checkchip(cs)
	struct zs_chanstate *cs;
{
	char	r1, r2, r3;
	int	chip;

	/* we assume we can write to the chip */

	r1=cs->cs_creg[15]; /* see if bit 0 sticks */
	zs_write_reg(cs, 15, (r1 | ZSWR15_ENABLE_ENHANCED));
	if ((zs_read_reg(cs, 15) & ZSWR15_ENABLE_ENHANCED) != 0) {
		/* we have either an 8580 or 85230. NB Zilog says we should only
		 * have an 85230 at this point, but the 8580 seems to pass this
		 * test too. To test, we try to write to WR7', and see if we
		 * loose sight of RR14. */
		r2=cs->cs_creg[14];
		r3=(r2 != 0x47) ? 0x47 : 0x40;
		/* unique bit pattern to turn on reading of WR7' at RR14 */
		zs_write_reg(cs, 7, ~r2);
		if (zs_read_reg(cs, ZSRR_ENHANCED) != r2) {
			chip = ZS_CHIP_ESCC;
			zs_write_reg(cs, 7, cs->cs_creg[ZS_ENHANCED_REG]);
		} else {
			chip = ZS_CHIP_8580;
			zs_write_reg(cs, 7, cs->cs_creg[7]);
		}
		zs_write_reg(cs, 15, r1);
	} else { /* now we have to tell an NMOS from a CMOS; does WR15 D2 work? */
		zs_write_reg(cs, 15, (r1 | ZSWR15_SDLC_FIFO));
		r2=cs->cs_creg[2];
		zs_write_reg(cs, 2, (r2 | 0x80));
		chip = (zs_read_reg(cs, 6) & 0x80) ? ZS_CHIP_NMOS : ZS_CHIP_CMOS;
		zs_write_reg(cs, 2, r2);
	}
	zs_write_reg(cs, 15, r1);
	return chip;
}
d147 1
a147 2
	zs_write_reg(cs, 1, reg[1] &
		~(ZSWR1_RIE_SPECIAL_ONLY | ZSWR1_TIE | ZSWR1_SIE));
d179 5
a183 5

	if ((cs->cs_cclk_flag & ZSC_EXTERN) ||
	    (cs->cs_pclk_flag & ZSC_EXTERN))
		zsmd_setclock(cs);
	/* the md layer wants to do something; let it. */
d198 2
a199 1
	/* Zilog docs recommend resetting external status twice at this
d211 1
a211 1
	/* interrupt enables: TX, TX, STATUS */
a212 3

	cs->cs_cclk_flag = cs->cs_pclk_flag;
	cs->cs_csource = cs->cs_psource;
a235 4
#ifdef DIAGNOSTIC
	register int loopcount;
	loopcount = ZS_INTERRUPT_CNT;
#endif
d237 2
a238 2
	cs_a = &zsc->zsc_cs[0];
	cs_b = &zsc->zsc_cs[1];
d243 1
a243 7
	rr3 = zs_read_reg(cs_a, 3);

	while ((rr3 = zs_read_reg(cs_a, ZSRR_IPEND))
#ifdef DIAGNOSTIC
		 && --loopcount
#endif
		) {
d249 1
a249 1
			(*cs_b->cs_ops->zsop_rxint)(cs_b);
d256 1
a256 1
	
d262 2
a263 1
	
d266 1
a266 8
#ifdef DIAGNOSTIC
	if (loopcount == 0) {
		if (rr3 & (ZSRR3_IP_A_RX | ZSRR3_IP_A_TX | ZSRR3_IP_A_STAT))
			cs_a->cs_flags |= ZS_FLAGS_INTERRUPT_OVERRUN;
		if (rr3 & (ZSRR3_IP_B_RX | ZSRR3_IP_B_TX | ZSRR3_IP_B_STAT))
			cs_b->cs_flags |= ZS_FLAGS_INTERRUPT_OVERRUN;
	}
#endif
d278 1
a278 5
	if ((cs_a->cs_softreq) || (cs_b->cs_softreq)) {
		/* This is a machine-dependent function (or macro). */
		zsc_req_softint(zsc);
	}

d292 1
a292 1
	register int rval, unit;
d295 2
a296 2
	for (unit = 0; unit < 2; unit++) {
		cs = &zsc->zsc_cs[unit];
d306 1
a306 1
			rval = 1;
d312 6
a317 2
static void	zsnull_intr(struct zs_chanstate *);
static void	zsnull_softint(struct zs_chanstate *);
d323 2
a324 2
	zs_write_reg(cs,  1, 0);
	zs_write_reg(cs, 15, 0);
d331 2
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530sc.c,v 1.4 2002/03/14 01:26:35 millert Exp $	*/
d296 1
a296 1
#if DIAGNOSTIC
d310 1
a310 1
#if DIAGNOSTIC
d335 1
a335 1
#if DIAGNOSTIC
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530sc.c,v 1.3 1996/09/02 15:50:34 briggs Exp $	*/
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.3
log
@Detect stuck interrupts in the scc (if DIAGNOSTIC) and log it.
Patches from Bill Studenmund <wrstuden@@loki.stanford.edu>.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530sc.c,v 1.1 1996/05/26 19:02:10 briggs Exp $	*/
d396 2
a397 2
static void	zsnull_intr __P((struct zs_chanstate *));
static void	zsnull_softint __P((struct zs_chanstate *));
@


1.3.28.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530sc.c,v 1.3 1996/09/02 15:50:34 briggs Exp $	*/
d396 2
a397 2
static void	zsnull_intr(struct zs_chanstate *);
static void	zsnull_softint(struct zs_chanstate *);
@


1.3.16.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d396 2
a397 2
static void	zsnull_intr(struct zs_chanstate *);
static void	zsnull_softint(struct zs_chanstate *);
@


1.3.16.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530sc.c,v 1.3.16.1 2002/03/28 10:34:05 niklas Exp $	*/
d26 5
a30 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2
log
@From scottr@@netbsd.org:
After servicing an interrupt, check to see that there's not another
one pending before we clear the interrupt flag.  This avoids a condition
where the line appears to go catatonic (which is particularly easily
triggered by pppd).  From Bill Studenmund <wrstuden@@loki.stanford.edu>.
XXX - we should probably log this if it gets excessive.
@
text
@d2 1
a2 1
/*	$NetBSD: z8530sc.c,v 1.2 1996/08/26 14:09:19 scottr Exp $	*/
d300 4
d311 8
a318 1
	while ((rr3 = zs_read_reg(cs_a, 3))) {
d324 1
a324 1

d330 1
a330 1

d336 1
a336 1

d339 8
@


1.1
log
@Missed a few files in the previous updates.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: z8530sc.c,v 1.1 1996/05/18 18:54:28 briggs Exp $	*/
d299 1
a299 1
	register u_char rr3;
d304 1
d307 18
a324 1
	rr3 = zs_read_reg(cs_a, 3);
d326 2
a327 17
	/* Handle receive interrupts first. */
	if (rr3 & ZSRR3_IP_A_RX)
		(*cs_a->cs_ops->zsop_rxint)(cs_a);
	if (rr3 & ZSRR3_IP_B_RX)
		(*cs_b->cs_ops->zsop_rxint)(cs_b);

	/* Handle status interrupts (i.e. flow control). */
	if (rr3 & ZSRR3_IP_A_STAT)
		(*cs_a->cs_ops->zsop_stint)(cs_a);
	if (rr3 & ZSRR3_IP_B_STAT)
		(*cs_b->cs_ops->zsop_stint)(cs_b);

	/* Handle transmit done interrupts. */
	if (rr3 & ZSRR3_IP_A_TX)
		(*cs_a->cs_ops->zsop_txint)(cs_a);
	if (rr3 & ZSRR3_IP_B_TX)
		(*cs_b->cs_ops->zsop_txint)(cs_b);
d330 1
a330 1
	if (rr3 & (ZSRR3_IP_A_RX | ZSRR3_IP_A_TX | ZSRR3_IP_A_STAT)) {
d334 1
a334 1
	if (rr3 & (ZSRR3_IP_B_RX | ZSRR3_IP_B_TX | ZSRR3_IP_B_STAT)) {
@
