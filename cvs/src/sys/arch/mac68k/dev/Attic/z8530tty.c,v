head	1.25;
access;
symbols
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.8
	OPENBSD_5_0:1.24.0.6
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.22
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.20
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.18
	OPENBSD_2_9_BASE:1.10
	NIKLAS_UNDEAD:1.10.0.16
	OPENBSD_2_8:1.10.0.14
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.12
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.10
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.24;

1.24
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.28.14.13.28;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.09.17.53.38;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.31.12.00.05;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.14.09.36.49;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.25.18.32.10;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.03.06.43.02;	author david;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.15.20.32.13;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.03.03.04.54.47;	author ryker;	state Exp;
branches
	1.10.10.1
	1.10.22.1;
next	1.9;

1.9
date	97.03.12.22.51.42;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.03.12.13.36.58;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.03.11.21.03.02;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.01.35.38;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.10.14.02.49.14;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.10.13.15.29.08;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.09.02.15.50.35;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.06.08.16.21.13;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	96.05.26.19.02.12;	author briggs;	state Exp;
branches;
next	;

1.10.10.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2003.06.07.11.13.13;	author ho;	state Exp;
branches;
next	1.10.10.3;

1.10.10.3
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	;

1.10.22.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: z8530tty.c,v 1.24 2010/07/02 17:27:01 nicm Exp $	*/
/*	$NetBSD: z8530tty.c,v 1.14 1996/12/17 20:42:43 gwr Exp $	*/

/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)zs.c	8.1 (Berkeley) 7/19/93
 */

/*
 * Zilog Z8530 Dual UART driver (tty interface)
 *
 * This is the "slave" driver that will be attached to
 * the "zsc" driver for plain "tty" async. serial lines.
 *
 * Credits, history:
 *
 * The original version of this code was the sparc/dev/zs.c driver
 * as distributed with the Berkeley 4.4 Lite release.  Since then,
 * Gordon Ross reorganized the code into the current parent/child
 * driver scheme, separating the Sun keyboard and mouse support
 * into independent child drivers.
 *
 * RTS/CTS flow-control support was a collaboration of:
 *	Gordon Ross <gwr@@netbsd.org>,
 *	Bill Studenmund <wrstuden@@loki.stanford.edu>
 *	Ian Dall <Ian.Dall@@dsto.defence.gov.au>
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <mac68k/dev/z8530reg.h>
#include <machine/z8530var.h>

#ifdef KGDB
extern int zs_check_kgdb();
#endif

/*
 * How many input characters we can buffer.
 * The port-specific var.h may override this.
 * Note: must be a power of two!
 */
#ifndef	ZSTTY_RING_SIZE
#define	ZSTTY_RING_SIZE	2048
#endif

/*
 * Make this an option variable one can patch.
 * But be warned:  this must be a power of 2!
 */
int zstty_rbuf_size = ZSTTY_RING_SIZE;

/* This should usually be 3/4 of ZSTTY_RING_SIZE */
int zstty_rbuf_hiwat = (ZSTTY_RING_SIZE - (ZSTTY_RING_SIZE >> 2));

struct zstty_softc {
	struct	device zst_dev;		/* required first: base device */
	struct  tty *zst_tty;
	struct	zs_chanstate *zst_cs;

	int zst_hwflags;	/* see z8530var.h */
	int zst_swflags;	/* TIOCFLAG_SOFTCAR, ... <ttycom.h> */

	/*
	 * Printing an overrun error message often takes long enough to
	 * cause another overrun, so we only print one per second.
	 */
	long	zst_rotime;		/* time of last ring overrun */
	long	zst_fotime;		/* time of last fifo overrun */

	/*
	 * The receive ring buffer.
	 */
	int	zst_rbget;	/* ring buffer `get' index */
	volatile int	zst_rbput;	/* ring buffer `put' index */
	int	zst_ringmask;
	int	zst_rbhiwat;

	u_short	*zst_rbuf; /* rr1, data pairs */

	/*
	 * The transmit byte count and address are used for pseudo-DMA
	 * output in the hardware interrupt code.  PDMA can be suspended
	 * to get pending changes done; heldtbc is used for this.  It can
	 * also be stopped for ^S; this sets TS_TTSTOP in tp->t_state.
	 */
	int 	zst_tbc;			/* transmit byte count */
	caddr_t	zst_tba;			/* transmit buffer address */
	int 	zst_heldtbc;		/* held tbc while xmission stopped */

	/* Flags to communicate with zstty_softint() */
	volatile char zst_rx_blocked;	/* input block at ring */
	volatile char zst_rx_overrun;	/* ring overrun */
	volatile char zst_tx_busy;	/* working on an output chunk */
	volatile char zst_tx_done;	/* done with one output chunk */
	volatile char zst_tx_stopped;	/* H/W level stop (lost CTS) */
	volatile char zst_st_check;	/* got a status interrupt */
	char pad[2];
};


/* Definition of the driver for autoconfig. */
static int	zstty_match(struct device *, void *, void *);
static void	zstty_attach(struct device *, struct device *, void *);

struct cfattach zstty_ca = {
	sizeof(struct zstty_softc), zstty_match, zstty_attach
};

struct cfdriver zstty_cd = {
	NULL, "zstty", DV_TTY
};

struct zsops zsops_tty;

/* Routines called from other code. */
cdev_decl(zs);	/* open, close, read, write, ioctl, stop, ... */

void	zsstart(struct tty *);
int	zsparam(struct tty *, struct termios *);
void	zs_modem(struct zstty_softc *zst, int onoff);
int	zshwiflow(struct tty *, int);
void	zs_hwiflow(struct zstty_softc *, int);
void	zstty_rxint(register struct zs_chanstate *);
void	zstty_txint(register struct zs_chanstate *);
void	zstty_stint(register struct zs_chanstate *);
void	zstty_softint(struct zs_chanstate *);
void	zsoverrun(struct zstty_softc *, long *, char *);
/*
 * zstty_match: how is this zs channel configured?
 */
static int
zstty_match(parent, match, aux)
	struct device *parent;
	void   *match, *aux;
{
	struct cfdata *cf = match;
	struct zsc_attach_args *args = aux;

	/* Exact match is better than wildcard. */
	if (cf->cf_loc[0] == args->channel)
		return 2;

	/* This driver accepts wildcard. */
	if (cf->cf_loc[0] == -1)
		return 1;

	return 0;
}

static void
zstty_attach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;

{
	struct zsc_softc *zsc = (void *) parent;
	struct zstty_softc *zst = (void *) self;
	struct zsc_attach_args *args = aux;
	struct zs_chanstate *cs;
	struct cfdata *cf;
	struct tty *tp;
	int channel, tty_unit;
	dev_t dev;

	tty_unit = zst->zst_dev.dv_unit;
	channel = args->channel;
	cs = zsc->zsc_cs[channel];
	cs->cs_private = zst;
	cs->cs_ops = &zsops_tty;

	zst->zst_cs = cs;
	zst->zst_swflags = cf->cf_flags;	/* softcar, etc. */
	zst->zst_hwflags = args->hwflags;
	dev = makedev(zs_major, tty_unit);

	if (zst->zst_swflags)
		printf(" flags 0x%x", zst->zst_swflags);

	if (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)
		printf(": console");
	else {
#ifdef KGDB
		/*
		 * Allow kgdb to "take over" this port.  If this port is
		 * NOT the kgdb port, zs_check_kgdb() will return zero.
		 * If it IS the kgdb port, it will print "kgdb,...\n"
		 * and then return non-zero.
		 */
		if (zs_check_kgdb(cs, dev)) {
			/*
			 * This is the kgdb port (exclusive use)
			 * so skip the normal attach code.
			 */
			return;
		}
#endif
	}
	printf("\n");

	tp = ttymalloc(0);
	tp->t_dev = dev;
	tp->t_oproc = zsstart;
	tp->t_param = zsparam;
	tp->t_hwiflow = zshwiflow;

	zst->zst_tty = tp;
	zst->zst_rbhiwat =  zstty_rbuf_size;	/* impossible value */
	zst->zst_ringmask = zstty_rbuf_size - 1;
	zst->zst_rbuf = malloc(zstty_rbuf_size * sizeof(zst->zst_rbuf[0]),
			      M_DEVBUF, M_WAITOK);
	/* XXX - Do we need an MD hook here? */

	/*
	 * Hardware init
	 */
	if (zst->zst_hwflags & ZS_HWFLAG_CONSOLE) {
		/* Call zsparam similar to open. */
		struct termios t;

		/* Make console output work while closed. */
		zst->zst_swflags |= TIOCFLAG_SOFTCAR;
		/* Setup the "new" parameters in t. */
		bzero((void*)&t, sizeof(t));
		t.c_cflag  = cs->cs_defcflag;
		t.c_ospeed = cs->cs_defspeed;
		/* Enable interrupts. */
		cs->cs_preg[1] = ZSWR1_RIE | ZSWR1_SIE;
		/* Make sure zsparam will see changes. */
		tp->t_ospeed = 0;
		(void) zsparam(tp, &t);
	} else {
		/* Not the console; may need reset. */
		int reset, s;
		reset = (channel == 0) ?
			ZSWR9_A_RESET : ZSWR9_B_RESET;
		s = splzs();
		zs_write_reg(cs, 9, reset);
		splx(s);
	}

	/*
	 * Initialize state of modem control lines (DTR).
	 * If softcar is set, turn on DTR now and leave it.
	 * otherwise, turn off DTR now, and raise in open.
	 * (Keeps modem from answering too early.)
	 */
	zs_modem(zst, (zst->zst_swflags & TIOCFLAG_SOFTCAR) ? 1 : 0);
}


/*
 * Return pointer to our tty.
 */
struct tty *
zstty(dev)
	dev_t dev;
{
	struct zstty_softc *zst;
	int unit = minor(dev);

#ifdef	DIAGNOSTIC
	if (unit >= zstty_cd.cd_ndevs)
		panic("zstty");
#endif
	zst = zstty_cd.cd_devs[unit];
	return (zst->zst_tty);
}


/*
 * Open a zs serial (tty) port.
 */
int
zsopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	register struct tty *tp;
	register struct zs_chanstate *cs;
	struct zstty_softc *zst;
	int error, s, unit;

	unit = minor(dev);
	if (unit >= zstty_cd.cd_ndevs)
		return (ENXIO);
	zst = zstty_cd.cd_devs[unit];
	if (zst == NULL)
		return (ENXIO);
	tp = zst->zst_tty;
	cs = zst->zst_cs;

	/* If KGDB took the line, then tp==NULL */
	if (tp == NULL)
		return (EBUSY);

	/* It's simpler to do this up here. */
	if (((tp->t_state & (TS_ISOPEN | TS_XCLUDE))
	     ==             (TS_ISOPEN | TS_XCLUDE))
	    && (suser(p, 0) != 0) )
	{
		return (EBUSY);
	}

	s = spltty();

	if ((tp->t_state & TS_ISOPEN) == 0) {
		/* First open. */
		struct termios t;

		/*
		 * Setup the "new" parameters in t.
		 * Can not use tp->t because zsparam
		 * deals only with what has changed.
		 */
		bzero((void*)&t, sizeof(t));
		t.c_cflag  = cs->cs_defcflag;
		if (zst->zst_swflags & TIOCFLAG_CLOCAL)
			t.c_cflag |= CLOCAL;
		if (zst->zst_swflags & TIOCFLAG_CRTSCTS)
			t.c_cflag |= CRTSCTS;
		if (zst->zst_swflags & TIOCFLAG_MDMBUF)
			t.c_cflag |= MDMBUF;
		t.c_ospeed = cs->cs_defspeed;
		/* Enable interrupts. */
		cs->cs_preg[1] = ZSWR1_RIE | ZSWR1_SIE;
		/* Make sure zsparam will see changes. */
		tp->t_ospeed = 0;
		(void) zsparam(tp, &t);
		/*
		 * Note: zsparam has done: cflag, ispeed, ospeed
		 * so we just need to do: iflag, oflag, lflag, cc
		 * For "raw" mode, just leave all zeros.
		 */
		if ((zst->zst_hwflags & ZS_HWFLAG_RAW) == 0) {
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			ttychars(tp);
		}
		ttsetwater(tp);
		/* Flush any pending input. */
		zst->zst_rbget = zst->zst_rbput;
		zs_iflush(cs);	/* XXX */
		/* DTR was turned on by zsparam. */
		if (zst->zst_swflags & TIOCFLAG_SOFTCAR) {
			tp->t_state |= TS_CARR_ON;
		}
		/* XXX - The MD code could just force CLOCAL instead. */
		if (zst->zst_hwflags & ZS_HWFLAG_NO_DCD) {
			tp->t_state |= TS_CARR_ON;
		}
	}
	error = 0;

	/* In this section, we may touch the chip. */
	(void)splzs();

	/*
	 * Get initial value of RR0.  This is done after we
	 * raise DTR in case the cable loops DTR back to CTS.
	 */
	cs->cs_rr0 = zs_read_csr(cs);

	/*
	 * Wait for DCD (if necessary).  Note that we might
	 * never get status interrupt if DCD is already on.
	 */
	for (;;) {
		/* Check the DCD bit (if we have one). */
		if (cs->cs_rr0 & cs->cs_rr0_dcd)
			tp->t_state |= TS_CARR_ON;

		if ((tp->t_state & TS_CARR_ON) ||
		    (tp->t_cflag & CLOCAL) ||
		    (flags & O_NONBLOCK) )
			break;

		/* Sleep waiting for a status interrupt. */
		tp->t_state |= TS_WOPEN;
		error = ttysleep(tp, (caddr_t)&tp->t_rawq,
			TTIPRI | PCATCH, ttopen, 0);
		if (error) {
			if ((tp->t_state & TS_ISOPEN) == 0) {
				/* Never get here with softcar */
				zs_modem(zst, 0);
				tp->t_state &= ~TS_WOPEN;
				ttwakeup(tp);
			}
			break;
		}
		/* The status interrupt changed cs->cs_rr0 */
	}

	splx(s);
	if (error == 0)
		error = linesw[tp->t_line].l_open(dev, tp, p);
	return (error);
}

/*
 * Close a zs serial port.
 */
int
zsclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register struct tty *tp;
	int hup, s;

	zst = zstty_cd.cd_devs[minor(dev)];
	cs = zst->zst_cs;
	tp = zst->zst_tty;

	/* XXX This is for cons.c. */
	if ((tp->t_state & TS_ISOPEN) == 0)
		return 0;

	(*linesw[tp->t_line].l_close)(tp, flags, p);

	/* Disable interrupts. */
	s = splzs();
	cs->cs_creg[1] = cs->cs_preg[1] = 0;
	zs_write_reg(cs, 1, cs->cs_creg[1]);
	splx(s);

	/* Maybe do "hangup" (drop DTR). */
	hup = tp->t_cflag & HUPCL;
	if (zst->zst_swflags & TIOCFLAG_SOFTCAR)
		hup = 0;
	if (hup) {
		zs_modem(zst, 0);
		/* hold low for 1 second */
		(void) tsleep((caddr_t)cs, TTIPRI, ttclos, hz);
	}
	if (cs->cs_creg[5] & ZSWR5_BREAK) {
		zs_break(cs, 0);
	}

	ttyclose(tp);
	return (0);
}

/*
 * Read/write zs serial port.
 */
int
zsread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	register struct zstty_softc *zst;
	register struct tty *tp;

	zst = zstty_cd.cd_devs[minor(dev)];
	tp = zst->zst_tty;
	return (linesw[tp->t_line].l_read(tp, uio, flags));
}

int
zswrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	register struct zstty_softc *zst;
	register struct tty *tp;

	zst = zstty_cd.cd_devs[minor(dev)];
	tp = zst->zst_tty;
	return (linesw[tp->t_line].l_write(tp, uio, flags));
}

#define TIOCFLAG_ALL (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | \
                      TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF )

int
zsioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register struct tty *tp;
	register int error, tmp;

	zst = zstty_cd.cd_devs[minor(dev)];
	cs = zst->zst_cs;
	tp = zst->zst_tty;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	#ifdef ZS_MD_IOCTL
		error = ZS_MD_IOCTL;
		if (error >= 0)
			return (error);
	#endif /* ZS_MD_IOCTL */

	switch (cmd) {

	case TIOCSBRK:
		zs_break(cs, 1);
		break;

	case TIOCCBRK:
		zs_break(cs, 0);
		break;

	case TIOCGFLAGS:
		*(int *)data = zst->zst_swflags;
		break;

	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);
		tmp = *(int *)data;
		/* Check for random bits... */
		if (tmp & ~TIOCFLAG_ALL)
			return(EINVAL);
		/* Silently enforce softcar on the console. */
		if (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)
			tmp |= TIOCFLAG_SOFTCAR;
		/* These flags take effect during open. */
		zst->zst_swflags = tmp;
		break;

	case TIOCSDTR:
		zs_modem(zst, 1);
		break;

	case TIOCCDTR:
		zs_modem(zst, 0);
		break;

	case TIOCMSET:
	case TIOCMBIS:
	case TIOCMBIC:
	case TIOCMGET:
	default:
		return (ENOTTY);
	}
	return (0);
}

/*
 * Start or restart transmission.
 */
void
zsstart(tp)
	register struct tty *tp;
{
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register int s, nch;

	zst = zstty_cd.cd_devs[minor(tp->t_dev)];
	cs = zst->zst_cs;

	s = spltty();

	/*
	 * If currently active or delaying, no need to do anything.
	 */
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
		goto out;

	/*
	 * If under CRTSCTS hfc and halted, do nothing
	 * This flag can only be set with CRTSCTS.
	 */
	if (zst->zst_tx_stopped)
		goto out;

	/*
	 * If there are sleepers, and output has drained below low
	 * water mark, awaken.
	 */
	ttwakeupwr(tp);

	nch = ndqb(&tp->t_outq, 0);	/* XXX */
	(void) splzs();

	if (nch) {
		register char *p = tp->t_outq.c_cf;

		/* mark busy, enable tx done interrupts, & send first byte */
		tp->t_state |= TS_BUSY;
		zst->zst_tx_busy = 1;
		cs->cs_preg[1] |= ZSWR1_TIE;
		cs->cs_creg[1] = cs->cs_preg[1];
		zs_write_reg(cs, 1, cs->cs_creg[1]);
		zs_write_data(cs, *p);
		zst->zst_tba = p + 1;
		zst->zst_tbc = nch - 1;
	} else {
		/*
		 * Nothing to send, turn off transmit done interrupts.
		 * This is useful if something is doing polled output.
		 */
		cs->cs_preg[1] &= ~ZSWR1_TIE;
		cs->cs_creg[1] = cs->cs_preg[1];
		zs_write_reg(cs, 1, cs->cs_creg[1]);
	}
out:
	splx(s);
}

/*
 * Stop output, e.g., for ^S or output flush.
 */
int
zsstop(tp, flag)
	struct tty *tp;
	int flag;
{
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register int s;

	zst = zstty_cd.cd_devs[minor(tp->t_dev)];
	cs = zst->zst_cs;

	s = splzs();
	if (tp->t_state & TS_BUSY) {
		/*
		 * Device is transmitting; must stop it.
		 * Also clear _heldtbc to prevent any
		 * flow-control event from resuming.
		 */
		zst->zst_tbc = 0;
		zst->zst_heldtbc = 0;
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return (0);
}

/*
 * Set ZS tty parameters from termios.
 * XXX - Should just copy the whole termios after
 * making sure all the changes could be done.
 */
int
zsparam(tp, t)
	register struct tty *tp;
	register struct termios *t;
{
	struct zstty_softc *zst;
	struct zs_chanstate *cs;
	int s, bps, cflag, error;
	u_char tmp3, tmp4, tmp5;

	zst = zstty_cd.cd_devs[minor(tp->t_dev)];
	cs = zst->zst_cs;
	bps = t->c_ospeed;
	cflag = t->c_cflag;

	if (bps < 0 || (t->c_ispeed && t->c_ispeed != bps))
		return (EINVAL);
	
	/*
	 * Only whack the UART when params change.
	 * Some callers need to clear tp->t_ospee
	 * to make sure initialization gets done.
	 */
	if ((tp->t_ospeed == bps) &&
		(tp->t_cflag == cflag) )
		return (0);

	/*
	 * Call MD functions to deal with changed
	 * clock modes or H/W flow control modes.
	 * The BRG divisor is set now. (reg 12,13
	 */

	error = zs_set_speed(cs, bps);
	if (error)
		return (error);
	error = zs_set_modes(cs, cflag);
	if (error)
		return (error);

	/* OK, we are now committed to do it. */
	tp->t_cflag = cflag;
	tp->t_ospeed = bps;
	tp->t_ispeed = bps;

	/*
	 * Block interrupts so that state will not
	 * be altered until we are done setting it up.
	 *
	 * Initial values in cs_preg are set before
	 * our attach routine is called.  The master
	 * interrupt enable is handled by zsc.c
	 */
	s = splzs();

	/* Recompute character size bits. */
	tmp3 = cs->cs_preg[3] & ~ZSWR3_RXSIZE;
	tmp5 = cs->cs_preg[5] & ~ZSWR5_TXSIZE;
	switch (cflag & CSIZE) {
	case CS5:
		/* These are |= 0 but let the optimizer deal with it. */
		tmp3 |= ZSWR3_RX_5;
		tmp5 |= ZSWR5_TX_5;
		break;
	case CS6:
		tmp3 |= ZSWR3_RX_6;
		tmp5 |= ZSWR5_TX_6;
		break;
	case CS7:
		tmp3 |= ZSWR3_RX_7;
		tmp5 |= ZSWR5_TX_7;
		break;
	case CS8:
	default:
		tmp3 |= ZSWR3_RX_8;
		tmp5 |= ZSWR5_TX_8;
		break;
	}
	/* Raise or lower DTR and RTS as appropriate. */
	if (bps) {
		/* Raise DTR and RTS */
		tmp5 |= cs->cs_wr5_dtr;
	} else {
		/* Drop DTR and RTS */
		/* XXX: Should SOFTCAR prevent this? */
		tmp5 &= ~(cs->cs_wr5_dtr);
	}
	cs->cs_preg[3] = tmp3;
	cs->cs_preg[5] = tmp5;

	/*
	 * Recompute the stop bits and parity bits.  Note that
	 * zs_set_speed() may have set clock selection bits etc.
	 * in wr4, so those must preserved.
	 */
	tmp4 = cs->cs_preg[4];
	/* Recompute stop bits. */
	tmp4 &= ~ZSWR4_SBMASK;
	tmp4 |= (cflag & CSTOPB) ?
		ZSWR4_TWOSB : ZSWR4_ONESB;
	/* Recompute parity bits. */
	tmp4 &= ~ZSWR4_PARMASK;
	if ((cflag & PARODD) == 0)
		tmp4 |= ZSWR4_EVENP;
	if (cflag & PARENB)
		tmp4 |= ZSWR4_PARENB;
	cs->cs_preg[4] = tmp4;

	/* The MD function zs_set_modes handled CRTSCTS, etc. */

	/*
	 * If nothing is being transmitted, set up new current values,
	 * else mark them as pending.
	 */
	if (cs->cs_heldchange == 0) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = 0xFFFF;
		} else {
			zs_loadchannelregs(cs);
		}
	}
	splx(s);

	/* If we can throttle input, enable "high water" detection. */
	if (cflag & CHWFLOW) {
		zst->zst_rbhiwat = zstty_rbuf_hiwat;
	} else {
		/* This impossible value prevents a "high water" trigger. */
		zst->zst_rbhiwat = zstty_rbuf_size;
		/* XXX: Lost hwi ability, so unblock and restart. */
		zst->zst_rx_blocked = 0;
		if (zst->zst_tx_stopped) {
			zst->zst_tx_stopped = 0;
			zsstart(tp);
		}
	}

	return (0);
}

/*
 * Raise or lower modem control (DTR/RTS) signals.  If a character is
 * in transmission, the change is deferred.
 */
void
zs_modem(zst, onoff)
	struct zstty_softc *zst;
	int onoff;
{
	struct zs_chanstate *cs;
	int s, clr, set;

	cs = zst->zst_cs;
	if (cs->cs_wr5_dtr == 0)
		return;

	if (onoff) {
		clr = 0;
		set = cs->cs_wr5_dtr;
	} else {
		clr = cs->cs_wr5_dtr;
		set = 0;
	}

	s = splzs();
	cs->cs_preg[5] &= ~clr;
	cs->cs_preg[5] |= set;
	if (cs->cs_heldchange == 0) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = (1<<5);
		} else {
			cs->cs_creg[5] = cs->cs_preg[5];
			zs_write_reg(cs, 5, cs->cs_creg[5]);
		}
	}
	splx(s);
}

/*
 * Try to block or unblock input using hardware flow-control.
 * This is called by kern/tty.c if MDMBUF|CRTSCTS is set, and
 * if this function returns non-zero, the TS_TBLOCK flag will
 * be set or cleared according to the "stop" arg passed.
 */
int
zshwiflow(tp, stop)
	struct tty *tp;
	int stop;
{
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	int s;

	zst = zstty_cd.cd_devs[minor(tp->t_dev)];
	cs = zst->zst_cs;

	/* Can not do this without some bit assigned as RTS. */
	if (cs->cs_wr5_rts == 0)
		return (0);

	s = splzs();
	if (stop) {
		/*
		 * The tty layer is asking us to block input.
		 * If we already did it, just return TRUE.
		 */
		if (zst->zst_rx_blocked)
			goto out;
		zst->zst_rx_blocked = 1;
	} else {
		/*
		 * The tty layer is asking us to resume input.
		 * The input ring is always empty by now.
		 */
		zst->zst_rx_blocked = 0;
	}
	zs_hwiflow(zst, stop);
 out:
	splx(s);
	return 1;
}

/*
 * Internal version of zshwiflow
 * called at splzs
 */
void
zs_hwiflow(zst, stop)
	register struct zstty_softc *zst;
	int stop;
{
	register struct zs_chanstate *cs;
	register int clr, set;

	cs = zst->zst_cs;
	
	if (cs->cs_wr5_rts == 0)
		return;

	if (stop) {
		/* Block input (Lower RTS) */
		clr = cs->cs_wr5_rts;
		set = 0;
	} else {
		/* Unblock input (Raise RTS) */
		clr = 0;
		set = cs->cs_wr5_rts;
	}

	cs->cs_preg[5] &= ~clr;
	cs->cs_preg[5] |= set;
	if (cs->cs_heldchange == 0) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = (1<<5);
		} else {
			cs->cs_creg[5] = cs->cs_preg[5];
			zs_write_reg(cs, 5, cs->cs_creg[5]);
		}
	}
}


/****************************************************************
 * Interface to the lower layer (zscc)
 ****************************************************************/

void zstty_rxint(struct zs_chanstate *);
void zstty_txint(struct zs_chanstate *);
void zstty_stint(struct zs_chanstate *);

/*
 * receiver ready interrupt.
 * called at splzs
 */
void
zstty_rxint(cs)
	register struct zs_chanstate *cs;
{
	register struct zstty_softc *zst;
	register int cc, put, put_next, ringmask;
	register u_char c, rr0, rr1;
	register u_short ch_rr1;

	zst = cs->cs_private;
	put = zst->zst_rbput;
	ringmask = zst->zst_ringmask;

nextchar:

	/*
	 * First read the status, because reading the received char
	 * destroys the status of this char.
	 */
	rr1 = zs_read_reg(cs, 1);
	c = zs_read_data(cs);
	ch_rr1 = (c << 8) | rr1;

	if (ch_rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {
		/* Clear the receive error. */
		zs_write_csr(cs, ZSWR0_RESET_ERRORS);
	}

	/* XXX: Check for the stop character? */

	zst->zst_rbuf[put] = ch_rr1;
	put_next = (put + 1) & ringmask;

	/* Would overrun if increment makes (put==get). */
	if (put_next == zst->zst_rbget) {
		zst->zst_rx_overrun = 1;
	} else {
		/* OK, really increment. */
		put = put_next;
	}

	/* Keep reading until the FIFO is empty. */
	rr0 = zs_read_csr(cs);
	if (rr0 & ZSRR0_RX_READY)
		goto nextchar;

	/* Done reading. */
	zst->zst_rbput = put;

	/*
	 * If ring is getting too full, try to block input.
	 */
	cc = put - zst->zst_rbget;
	if (cc < 0)
		cc += zstty_rbuf_size;
	if ((cc > zst->zst_rbhiwat) && (zst->zst_rx_blocked == 0)) {
		zst->zst_rx_blocked = 1;
		zs_hwiflow(zst, 1);
	}

	/* Ask for softint() call. */
	cs->cs_softreq = 1;
}

/*
 * transmitter ready interrupt.  (splzs)
 */
void
zstty_txint(cs)
	register struct zs_chanstate *cs;
{
	register struct zstty_softc *zst;
	register int count;

	zst = cs->cs_private;

	/*
	 * If we suspended output for a "held" change,
	 * then handle that now and resume.
	 * Do flow-control changes ASAP.
	 * When the only change is for flow control,
	 * avoid hitting other registers, because that
	 * often makes the stupid zs drop input...
	 */
	if (cs->cs_heldchange) {
		if (cs->cs_heldchange == (1<<5)) {
			/* Avoid whacking the chip... */
			cs->cs_creg[5] = cs->cs_preg[5];
			zs_write_reg(cs, 5, cs->cs_creg[5]);
		} else
			zs_loadchannelregs(cs);
		cs->cs_heldchange = 0;
		count = zst->zst_heldtbc;
	} else
		count = zst->zst_tbc;

	/*
	 * If our transmit buffer still has data,
	 * just send the next character.
	 */
	if (count > 0) {
		/* Send the next char. */
		zst->zst_tbc = --count;
		zs_write_data(cs, *zst->zst_tba);
		zst->zst_tba++;
		return;
	}

	zs_write_csr(cs, ZSWR0_RESET_TXINT);

	/* Ask the softint routine for more output. */
	zst->zst_tx_busy = 0;
	zst->zst_tx_done = 1;
	cs->cs_softreq = 1;
}

/*
 * status change interrupt.  (splzs)
 */
void
zstty_stint(cs)
	register struct zs_chanstate *cs;
{
	register struct zstty_softc *zst;
	register u_char rr0, delta;

	zst = cs->cs_private;

	rr0 = zs_read_csr(cs);
	zs_write_csr(cs, ZSWR0_RESET_STATUS);

	/*
	 * Check here for console break, so that we can abort
	 * even when interrupts are locking up the machine.
	 */
	if ((rr0 & ZSRR0_BREAK) &&
		(zst->zst_hwflags & ZS_HWFLAG_CONSOLE))
	{
		zs_abort(cs);
		return;
	}

	/*
	 * We have to accumulate status line changes here.
	 * Otherwise, if we get multiple status interrupts
	 * before the softint runs, we could fail to notice
	 * some status line changes in the softint routine.
	 * Fix from Bill Studenmund, October 1996.
	 */
	delta = (cs->cs_rr0 ^ rr0);
	cs->cs_rr0_delta |= delta;
	cs->cs_rr0 = rr0;
	
	/*
	 * Need to handle CTS output flow control here.
	 * Output remains stopped as long as either the
	 * zst_tx_stopped or TS_TTSTOP flag is set.
	 * Never restart here; the softint routine will
	 * do that after things are ready to move.
	 */
	if ((delta & cs->cs_rr0_cts) &&
		((rr0 & cs->cs_rr0_cts) == 0))
	{
		zst->zst_tbc = 0;
		zst->zst_heldtbc = 0;
		zst->zst_tx_stopped = 1;
	}
	zst->zst_st_check = 1;

	/* Ask for softint() call. */
	cs->cs_softreq = 1;
}

/*
 * Print out a ring or fifo overrun error message.
 */
void
zsoverrun(zst, ptime, what)
	struct zstty_softc *zst;
	long *ptime;
	char *what;
{

	if (*ptime != time_second) {
		*ptime = time_second;
		log(LOG_WARNING, "%s: %s overrun\n",
			zst->zst_dev.dv_xname, what);
	}
}

/*
 * Software interrupt.  Called at zssoft
 *
 * The main job to be done here is to empty the input ring
 * by passing its contents up to the tty layer.  The ring is
 * always emptied during this operation, therefore the ring
 * must not be larger than the space after "high water" in
 * the tty layer, or the tty layer might drop our input.
 *
 * Note: an "input blockage" condition is assumed to exist if
 * EITHER the TS_TBLOCK flag or zst_rx_blocked flag is set.
 */
void
zstty_softint(cs)
	struct zs_chanstate *cs;
{
	register struct zstty_softc *zst;
	register struct linesw *line;
	register struct tty *tp;
	register int get, c, s;
	int ringmask, overrun;
	register u_short ring_data;
	register u_char rr0, delta;

	zst  = cs->cs_private;
	tp   = zst->zst_tty;
	line = &linesw[tp->t_line];
	ringmask = zst->zst_ringmask;
	overrun = 0;

	/*
	 * Raise to tty priority while servicing the ring.
	 */
	s = spltty();

	if (zst->zst_rx_overrun) {
		zst->zst_rx_overrun = 0;
		zsoverrun(zst, &zst->zst_rotime, "ring");
	}

	/*
	 * Copy data from the receive ring into the tty layer.
	 */
	get = zst->zst_rbget;
	while (get != zst->zst_rbput) {
		ring_data = zst->zst_rbuf[get];
		get = (get + 1) & ringmask;

		if (ring_data & ZSRR1_DO)
			overrun++;
		/* low byte of ring_data is rr1 */
		c = (ring_data >> 8) & 0xff;
		if (ring_data & ZSRR1_FE)
			c |= TTY_FE;
		if (ring_data & ZSRR1_PE)
			c |= TTY_PE;

		line->l_rint(c, tp);
	}
	zst->zst_rbget = get;

	/*
	 * If the overrun flag is set now, it was set while
	 * copying char/status pairs from the ring, which
	 * means this was a hardware (fifo) overrun.
	 */
	if (overrun) {
		zsoverrun(zst, &zst->zst_fotime, "fifo");
	}

	/*
	 * We have emptied the input ring.  Maybe unblock input.
	 * Note: an "input blockage" condition is assumed to exist
	 * when EITHER zst_rx_blocked or the TS_TBLOCK flag is set,
	 * so unblock here ONLY if TS_TBLOCK has not been set.
	 */
	if (zst->zst_rx_blocked && ((tp->t_state & TS_TBLOCK) == 0)) {
		(void) splzs();
		zst->zst_rx_blocked = 0;
		zs_hwiflow(zst, 0);	/* unblock input */
		(void) spltty();
	}

	/*
	 * Do any deferred work for status interrupts.
	 * The rr0 was saved in the h/w interrupt to
	 * avoid another splzs in here.
	 */
	if (zst->zst_st_check) {
		zst->zst_st_check = 0;

		(void) splzs();
		rr0 = cs->cs_rr0;
		delta = cs->cs_rr0_delta;
		cs->cs_rr0_delta = 0;
		(void) spltty();

		/* Note, the MD code may use DCD for something else. */
		if (delta & cs->cs_rr0_dcd) {
			c = ((rr0 & cs->cs_rr0_dcd) != 0);
			if (line->l_modem(tp, c) == 0)
				zs_modem(zst, c);
		}
		
		/* Note, cs_rr0_cts is set only with H/W flow control. */
		if (delta & cs->cs_rr0_cts) {
			/*
			 * Only do restart here.  Stop is handled
			 * at the h/w interrupt level.
			 */
			if (rr0 & cs->cs_rr0_cts) {
				zst->zst_tx_stopped = 0;
				/* tp->t_state &= ~TS_TTSTOP; */
				(*line->l_start)(tp);
			}
		}
	}

	if (zst->zst_tx_done) {
		zst->zst_tx_done = 0;
		tp->t_state &= ~TS_BUSY;
		if (tp->t_state & TS_FLUSH)
			tp->t_state &= ~TS_FLUSH;
		else
			ndflush(&tp->t_outq, zst->zst_tba -
				(caddr_t) tp->t_outq.c_cf);
		line->l_start(tp);
	}

	splx(s);
}

struct zsops zsops_tty = {
	zstty_rxint,	/* receive char available */
	zstty_stint,	/* external/status */
	zstty_txint,	/* xmit buffer empty */
	zstty_softint,	/* process software interrupt */
};

@


1.24
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.23 2010/06/28 14:13:28 deraadt Exp $	*/
@


1.23
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.22 2010/04/12 12:57:52 tedu Exp $	*/
d642 1
a642 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.22
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.21 2009/11/09 17:53:38 nicm Exp $	*/
d248 1
a248 1
	tp = ttymalloc();
@


1.21
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.20 2009/10/31 12:00:05 fgsch Exp $	*/
d446 1
a446 1
		error = linesw[tp->t_line].l_open(dev, tp);
d473 1
a473 1
	(*linesw[tp->t_line].l_close)(tp, flags);
@


1.20
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.19 2009/10/31 06:40:16 deraadt Exp $	*/
a647 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.19
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.18 2009/03/15 20:40:25 miod Exp $	*/
d349 1
a349 1
	    && (p->p_ucred->cr_uid != 0) )
@


1.18
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.17 2006/04/14 09:36:49 martin Exp $	*/
d648 1
@


1.17
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.16 2004/11/25 18:32:10 miod Exp $	*/
d166 10
a175 10
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
static void	zs_modem(struct zstty_softc *zst, int onoff);
static int	zshwiflow(struct tty *, int);
static void	zs_hwiflow(struct zstty_softc *, int);
static void	zstty_rxint(register struct zs_chanstate *);
static void	zstty_txint(register struct zs_chanstate *);
static void	zstty_stint(register struct zs_chanstate *);
static void	zstty_softint(struct zs_chanstate *);
static void	zsoverrun(struct zstty_softc *, long *, char *);
d179 1
a179 1
int
d198 1
a198 1
void
d612 1
a612 1
static void
d714 1
a714 1
static int
d860 1
a860 1
static void
d944 1
a944 1
static void
d986 3
a988 3
static void zstty_rxint (struct zs_chanstate *);
static void zstty_txint (struct zs_chanstate *);
static void zstty_stint (struct zs_chanstate *);
d994 1
a994 1
static void
d1061 1
a1061 1
static void
d1113 1
a1113 1
static void
d1170 1
a1170 1
static void
d1196 1
a1196 1
static void
@


1.16
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.15 2003/11/03 06:43:02 david Exp $	*/
d179 1
a179 1
int 
d198 1
a198 1
void 
d1147 1
a1147 1
	/* 
@


1.15
log
@spelling fixes (in the comments)
@
text
@d1 2
a2 2
/*	$OpenBSD: z8530tty.c,v 1.14 2003/10/03 16:44:49 miod Exp $	*/
/*	$NetBSD: z8530tty.c,v 1.10 1996/12/18 05:17:44 scottr Exp $	*/
d50 13
d78 1
a78 2
/* #include <dev/ic/z8530reg.h> */
#include "z8530reg.h"
d86 9
d103 44
a146 1
struct zstty_stats z8530tty_stats;
d171 5
a175 5
static int	zsgetbaud(register struct zs_chanstate *,
		    register int *rate, register int *tc, register u_char *rr4,
		    register u_char *rr11, register u_char *rr14,
		    register int *source, register int *sourceflag);

d180 1
a180 1
zstty_match(parent, vcf, aux)
d182 1
a182 2
	void *vcf;
	void *aux;
d184 1
a184 1
	struct cfdata *cf = (struct cfdata *) vcf;
a212 1
	cf = zst->zst_dev.dv_cfdata;
d215 1
a215 1
	cs = &zsc->zsc_cs[channel];
d222 1
a222 9
	
	zst->zst_cflag = ZSTTY_DEF_CFLAG;	/* set up defaults */
	zst->zst_iflag = TTYDEF_IFLAG;		/* an ioctl can change */
	zst->zst_lflag = TTYDEF_LFLAG;		/* these values, modifying */
	zst->zst_oflag = TTYDEF_OFLAG;		/* initial defaults */
	zst->zst_ispeed = zst->zst_ospeed = cs->cs_defspeed;
	/* zst_cc set after tty is malloc'd */

	dev = makedev(ZSTTY_MAJOR, tty_unit);
d228 1
a228 1
		printf(" (console)");
d246 1
a252 2
	ttychars(tp);
	bcopy(tp->t_cc, zst->zst_cc, sizeof(tp->t_cc));
d259 1
a260 15
	zstty_mdattach(zsc, zst, cs, tp); /*let the md code customize stuff */

	if (zst->zst_hwflags & (ZS_HWFLAG_IGCTS | ZS_HWFLAG_IGDCD)) {
		printf("\n  Ignoring ");
		switch (zst->zst_hwflags & (ZS_HWFLAG_IGCTS | ZS_HWFLAG_IGDCD)) {
		case ZS_HWFLAG_IGCTS:
			printf("CTS line "); break;
		case ZS_HWFLAG_IGDCD:
			printf("DCD line "); break;
		default:
			printf("CTS and DCD lines ");
		}
	}

	printf("\n");
d265 4
a268 1
		/* This unit is the console. */
d270 9
a278 8
		/* Call _param so interrupts get enabled. */
		bcopy(&zst->zst_termios, &tp->t_termios, sizeof(struct termios));
		/* copy the whole termios in as the first "first open" won't
		 * do it since the speed != 0 */
		cs->cs_defspeed = zs_getspeed(cs);
		tp->t_ispeed = cs->cs_defspeed;
		tp->t_ospeed = cs->cs_defspeed;
		(void) zsparam(tp, &tp->t_termios);
a341 4
#ifdef  ZSTTYDEBUG
        zsprintf("zs_open to channel at %p\n",cs->cs_reg_csr);
#endif

d357 32
a388 12
		if ((tp->t_ispeed == 0) || (zst->zst_resetdef)) {
			/* First open. Executed if either the tty
			 * was uninitialized, or if we choose to
			 * reset defaults w/ each open. */
			bcopy(&zst->zst_termios, &tp->t_termios,
			    sizeof(struct termios));
			if (zst->zst_swflags & TIOCFLAG_CLOCAL)
				tp->t_cflag |= CLOCAL;
			if (zst->zst_swflags & TIOCFLAG_CRTSCTS)
				tp->t_cflag |= CRTSCTS;
			if (zst->zst_swflags & TIOCFLAG_MDMBUF)
				tp->t_cflag |= MDMBUF;
a389 1
		(void) zsparam(tp, &tp->t_termios);
d394 1
a394 2
		/* Turn on DTR */
		zs_modem(zst, 1);
d398 4
d405 2
a406 5
	/* Wait for carrier. */
#ifdef  ZSTTYDEBUG
        zsprintf("wait for carrier...\n");
#endif
	for (;;) {
d408 5
a412 4
		if (zst->zst_hwflags & ZS_HWFLAG_IGDCD) {
			tp->t_state |= TS_CARR_ON;
			break;
		}
d414 7
a420 3
		/* Might never get status intr if carrier already on. */
		cs->cs_rr0 = zs_read_csr(cs);
		if (cs->cs_rr0 & ZSRR0_DCD) {
a421 2
			break;
		}
a425 1
		{
a426 1
		}
d428 1
d441 1
a444 6

#ifdef  ZSTTYDEBUG
        zsprintf("...carrier %s\n",
                           (tp->t_state & TS_CARR_ON) ? "on" : "off");
#endif

a446 1

d463 1
a463 5
	int hup;

#ifdef  ZSTTYDEBUG
        zsprintf("zs_close\n");
#endif
d474 8
a492 1
	/* XXX - turn off interrupts? */
d555 6
a560 3
	error = zsmdioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
a598 24
#if 0
	case SetSafeOpen:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);
		zst->zst_resetdef = 1;
		break;

	case ClearSafeOpen:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);
		zst->zst_resetdef = 0;
		break;

	case SetOpenDefaults:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);
		bcopy(&tp->t_termios, &zst->zst_termios, \
			sizeof(struct termios));
		break;
#endif

d633 1
d635 2
a636 3
	if (tp->t_cflag & CRTSCTS)
		if (zst->zst_tx_stopped)
			goto out;
d650 1
a652 1
	nch = ndqb(&tp->t_outq, 0);	/* XXX */
d658 1
a658 1

d697 2
d701 1
a701 1
		zst->zst_heldtbc = 0;	/* XXX */
a705 131
	return(0);
}

#ifndef ZS_TOLERANCE
#define ZS_TOLERANCE 50
/* 5% in tenths of a % */
#endif

/*
 * Search through the signal sources in the channel, and
 * pick the best one for the baud rate requested. Return
 * a -1 if not achievable in tolerance. Otherwise ret 0
 * and fill in the values.
 *
 * This routine draws inspiration from the Atari port's zs.c
 * driver in NetBSD1.1 which did the same type of source switching.
 * Tolerance code inspired by comspeed routine in isa/com.c.
 *
 * By Bill Studenmund, 1996-05-12
 */
static int
zsgetbaud(cs, rate, tc, rr4, rr11, rr14, source, sourceflag)
	register struct zs_chanstate *cs;
	register int *rate, *tc, *source, *sourceflag;
	register u_char *rr4, *rr11, *rr14;
{
	int i, tc0, tc1, s, sf, rate0, rate1, err, tol;

	s = -1;		/* no valid source yet */
	tol = ZS_TOLERANCE;

	sf = 0; tc0 = 0; rate0 = 0;	/* XXX Kill gcc warning */

	/*
	 * Step through all the sources and see which one matches
	 * the best. A source has to match BETTER than tol to be chosen.
	 * Thus if two sources give the same error, the first one will be
	 * chosen. Also, allow for the possability that one source might run
	 * both the BRG and the direct divider (i.e. RTxC).
	 */
	for (i=0; i< cs->cs_clock_count; i++) {
		if (cs->cs_clocks[i].clk <= 0)
			continue;	/* skip non-existent or bad clocks */
		if (cs->cs_clocks[i].flags & ZSC_BRG) {
			/* check out BRG at /16 */
			tc1 = BPS_TO_TCONST(cs->cs_clocks[i].clk >> 4, rate[0]);
			if (tc1 >= 0) {
				rate1 = TCONST_TO_BPS(cs->cs_clocks[i].clk >> 4, tc1);
				err = abs(((rate1 - rate[0])*1000)/rate[0]);
				if (err < tol) {
					tol = err;
					s = i;
					sf = cs->cs_clocks[i].flags & ~ZSC_DIV;
					tc0 = tc1;
					rate0 = rate1;
				}
			}
		}
		if (cs->cs_clocks[i].flags & ZSC_DIV) {
			/*
			 * Check out either /1, /16, /32, or /64
			 * Note: for /1, you'd better be using a synchronized
			 * clock!
			 */
			int b0 = cs->cs_clocks[i].clk, e0 = abs(b0-rate[0]);
			int b1 = b0 >> 4, e1 = abs(b1-rate[0]);
			int b2 = b1 >> 1, e2 = abs(b2-rate[0]);
			int b3 = b2 >> 1, e3 = abs(b3-rate[0]);

			if (e0 < e1 && e0 < e2 && e0 < e3) {
				err = e0;
				rate1 = b0;
				tc1 = ZSWR4_CLK_X1;
			} else if (e0 > e1 && e1 < e2  && e1 < e3) {
				err = e1;
				rate1 = b1;
				tc1 = ZSWR4_CLK_X16;
			} else if (e0 > e2 && e1 > e2 && e2 < e3) {
				err = e2;
				rate1 = b2;
				tc1 = ZSWR4_CLK_X32;
			} else {
				err = e3;
				rate1 = b3;
				tc1 = ZSWR4_CLK_X64;
			}

			err = (err * 1000)/rate[0];
			if (err < tol) {
				tol = err;
				s = i;
				sf = cs->cs_clocks[i].flags & ~ZSC_BRG;
				tc0 = tc1;
				rate0 = rate1;
			}
		}
	}
#ifdef ZSTTYDEBUG
	zsprintf("Checking for rate %d. Found source #%d.\n",rate[0], s);
#endif
	if (s == -1) return (-1);
	/*
	 * Now we have a source, so set it up.
	 */
	*source = s;
	*sourceflag = sf;
	rate[0] = rate0;
	if (sf & ZSC_BRG) {
		*rr4 = ZSWR4_CLK_X16;
		*rr11= ZSWR11_RXCLK_BAUD | ZSWR11_TXCLK_BAUD;
		if (sf & ZSC_PCLK) {
			*rr14 = ZSWR14_BAUD_ENA | ZSWR14_BAUD_FROM_PCLK;
		} else {
			*rr14 = ZSWR14_BAUD_ENA;
		}
		*tc = tc0;
	} else {
		*rr4 = tc0;
		if (sf & ZSC_RTXDIV) {
			*rr11 = ZSWR11_RXCLK_RTXC | ZSWR11_TXCLK_RTXC;
		} else {
			*rr11 = ZSWR11_RXCLK_TRXC | ZSWR11_TXCLK_TRXC;
		}
		*rr14= 0;
		*tc = 0xffff;
	}
#ifdef ZSTTYDEBUG
	zsprintf("Rate is %7d, tc is %7d, source no. %2d, flags %4x\n", \
	    *rate, *tc, *source, *sourceflag);
	zsprintf("Registers are: 4 %x, 11 %x, 14 %x\n\n", *rr4, *rr11, *rr14);
#endif
a712 1
 * XXX - Only whack the UART when params change...
d719 4
a722 5
	register struct zstty_softc *zst;
	register struct zs_chanstate *cs;
	register int s, cflag, hfc;
	u_char tmp3, tmp4, tmp5, tmp11, tmp14;
	int	bps, tconst, src, srcflag;
d726 2
a728 1
	bps = t->c_ospeed;
d731 8
a738 3
	if (bps == 0) {
		/* stty 0 => drop DTR and RTS */
		zs_modem(zst, 0);
a739 10
	}
	if (0 > zsgetbaud(cs, &bps, &tconst, &tmp4, &tmp11, &tmp14,
	    &src, &srcflag))
		return (EINVAL);

	tp->t_ispeed = tp->t_ospeed = bps;
	cs->cs_psource = src;
	cs->cs_pclk_flag = srcflag;

	cflag = t->c_cflag;
d742 3
a744 4
	 * Make sure we don't enable hfc on a signal line we're ignoring
	 *
	 * As we enable CTS interrupts only if we have CRTSCTS, this code
	 * also effectivly turns off ZSWR15_CTS_IE.
a745 4
	if (zst->zst_hwflags & ZS_HWFLAG_IGDCD)
		cflag &= ~MDMBUF;
	if (zst->zst_hwflags & ZS_HWFLAG_IGCTS)
		cflag &= ~CRTSCTS;
d747 8
d756 3
d762 1
a762 4
	 */
	s = splzs();

	/*
d767 1
d769 3
a771 3
	cs->cs_preg[12] = tconst & 255;
	cs->cs_preg[13] = tconst >> 8;

d774 3
a776 2
		tmp3 = ZSWR3_RX_5;
		tmp5 = ZSWR5_TX_5;
d779 2
a780 2
		tmp3 = ZSWR3_RX_6;
		tmp5 = ZSWR5_TX_6;
d783 2
a784 2
		tmp3 = ZSWR3_RX_7;
		tmp5 = ZSWR5_TX_7;
d788 2
a789 2
		tmp3 = ZSWR3_RX_8;
		tmp5 = ZSWR5_TX_8;
d792 24
a815 5

	cs->cs_preg[3] = tmp3 | ZSWR3_RX_ENABLE;
	cs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;

	tmp4 |= (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);
d822 1
a822 41
	/*
	 * Output hardware flow control on the chip is horrendous:
	 * if carrier detect drops, the receiver is disabled and if
	 * CTS drops, the transmitter is stoped IN MID CHARACTER!
	 * Therefore, do not set the HFC bit, and instead use
	 * the status interrupts to detect CTS changes.
	 */
	if (cflag & CRTSCTS) {
		zst->zst_rbhiwat = zstty_rbuf_hiwat;
		cs->cs_preg[15] |= ZSWR15_CTS_IE;
	} else {
		zst->zst_rbhiwat = zstty_rbuf_size; /* impossible value */
		cs->cs_preg[15] &= ~ZSWR15_CTS_IE;
	}
	/* Shouldn't the zst_rbhiwat stuff be if (cflag & CHWFLOW) ? wrs */

	/*
	 * Disable DCD interrupts if we've been told to ignore
	 * the DCD pin. Happens on mac68k because the input line for
	 * DCD can also be used as a clock input.
	 */
	if (zst->zst_hwflags & ZS_HWFLAG_IGDCD)
		cs->cs_preg[15] &= ~ZSWR15_DCD_IE;
	else
		cs->cs_preg[15] |= ZSWR15_DCD_IE;

	/*
	 * now find out which line to change for input flow control.
	 * Important as some ports (mac68k) don't always have input
	 * flow control when they have output flow control (RTS actually
	 * controls buffers on the Xmitter output).
	 */
	hfc = (cflag & CRTSCTS) ? 1 : 0;
	hfc |= (cflag & MDMBUF) ? 2 : 0;

	zst->zst_hwimask = zst->zst_hwimasks[hfc];
	if ((zst->zst_rx_blocked) && (zst->zst_hwimask))
		cs->cs_preg[5] &= ~zst->zst_hwimask;
	/* make sure we enforce halted-ness */

	/* XXX check for loss of output blocking if loosing hwi ability? */
d829 1
a829 1
		if (tp->t_state & TS_BUSY) {
d832 1
a832 1
			cs->cs_heldchange = 0xFF;
d838 15
a852 1
	/* check for ttstart if lost output flow control? XXX */
d866 1
a866 2
	struct tty *tp;
	int s, bis, and;
d869 2
a870 1
	tp = zst->zst_tty;
d873 2
a874 2
		bis = ZSWR5_DTR | ZSWR5_RTS;
		and = ~0;
d876 2
a877 2
		bis = 0;
		and = ~(ZSWR5_DTR | ZSWR5_RTS);
d879 1
d881 2
a882 1
	cs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;
d884 1
a884 1
		if (tp->t_state & TS_BUSY) {
d908 1
d912 5
a917 10
	/*
	 * This loop checks to see that we can in fact control input.
	 * If not, then do little except tell the upper layer the truth.
	 */
	if (zst->zst_hwimask == 0) {
		if (stop)
			return 0;
		else
			return 1; /* yes, w/o hwi we can unblock input. ;-) */
	}
a926 1
		z8530tty_stats.tty_block++;
a932 1
		z8530tty_stats.tty_unblock++;
d950 1
a950 2
	register struct tty *tp;
	register int bis, and;
d953 3
a955 1
	tp = zst->zst_tty;
d959 2
a960 2
		bis = 0;
		and = ~zst->zst_hwimask;
d963 2
a964 2
		bis = zst->zst_hwimask;
		and = ~0;
d967 2
a968 1
	cs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;
d970 1
a970 1
		if (tp->t_state & TS_BUSY) {
d986 3
a988 8
static void	zstty_rxint(register struct zs_chanstate *);
static void	zstty_txint(register struct zs_chanstate *);
static void	zstty_stint(register struct zs_chanstate *);
static void	zsoverrun(struct zstty_softc *, long *, char *);
static void	zstty_softint(struct zs_chanstate *);
/*
 * XXX: need to do input flow-control to avoid ring overrun.
 */
a1051 1
		z8530tty_stats.ring_block++;
d1105 2
a1106 1
	zst->zst_tx_empty = 1;
d1118 1
a1118 2
	register struct tty *tp;
	register u_char rr0;
a1120 1
	tp  = zst->zst_tty;
d1129 2
a1130 1
	if ((rr0 & ZSRR0_BREAK))
d1132 1
a1132 1
		zs_abort(zst);
d1137 11
d1154 3
a1156 1
	if (((rr0 & ZSRR0_CTS) == 0) && (tp->t_cflag & CRTSCTS)) {
a1160 3

	cs->cs_rr0_changes |= cs->cs_rr0 ^ rr0;
	cs->cs_rr0 = rr0;
d1177 2
a1178 2
	if (*ptime != time.tv_sec) {
		*ptime = time.tv_sec;
d1206 1
a1206 1
	register u_char rr0, delta, flag;
a1222 6
	if (cs->cs_flags & ZS_FLAGS_INTERRUPT_OVERRUN) {
		(void) splzs();
		cs->cs_flags &= ~ZS_FLAGS_INTERRUPT_OVERRUN;
		(void) spltty();
		zsoverrun(zst, &zst->zst_intotime, "interrupt");
	}
a1263 1
		z8530tty_stats.ring_unblock++;
d1275 1
d1277 7
a1283 10
		delta = cs->cs_rr0_changes;
		cs->cs_rr0_changes = 0;
		if ((delta & ZSRR0_DCD) &&
		    ~(zst->zst_hwflags & ZS_HWFLAG_IGDCD)) {
			c = ((rr0 & ZSRR0_DCD) != 0);
			if ((tp->t_cflag & CHWFLOW) == CHWFLOW) {
				flag = 1;
				tp->t_cflag &= ~MDMBUF;
			} else
				flag = 0;
a1285 9
			if (flag)
				tp->t_cflag |= MDMBUF;
			/*
			 * The above trick hides MDMBUF from the tty layer
			 * if we also have CRTSCTS; Used as mac68k takes
			 * the two of them as meaning do CRTSCTS with DCD
			 * as the hwi line. Just CRTSCTS doesn't have a
			 * hwi line.
			 */
d1287 3
a1289 1
		if ((delta & ZSRR0_CTS) && (tp->t_cflag & CRTSCTS)) {
d1294 1
a1294 1
			if (rr0 & ZSRR0_CTS) {
d1296 1
a1296 1
				tp->t_state &= ~TS_TTSTOP;
d1302 2
a1303 2
	if (zst->zst_tx_empty) {
		zst->zst_tx_empty = 0;
d1309 1
a1309 1
					(caddr_t) tp->t_outq.c_cf);
a1321 1

@


1.14
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.13 2003/08/15 20:32:13 tedu Exp $	*/
d710 1
a710 1
			continue;	/* skip non-existant or bad clocks */
@


1.13
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.12 2003/06/02 23:27:49 millert Exp $	*/
a199 1
	tty_attach(tp);
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.11 2002/03/14 01:26:35 millert Exp $	*/
d518 1
a518 1
		error = suser(p->p_ucred, &p->p_acflag);
d542 1
a542 1
		error = suser(p->p_ucred, &p->p_acflag);
d549 1
a549 1
		error = suser(p->p_ucred, &p->p_acflag);
d556 1
a556 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.10 1998/03/03 04:54:47 ryker Exp $	*/
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.9 1997/03/12 22:51:42 briggs Exp $	*/
d106 6
a111 6
static void	zsstart __P((struct tty *));
static int	zsparam __P((struct tty *, struct termios *));
static void	zs_modem __P((struct zstty_softc *zst, int onoff));
static int	zshwiflow __P((struct tty *, int));
static void	zs_hwiflow __P((struct zstty_softc *, int));
static int	zsgetbaud __P((register struct zs_chanstate *,
d114 1
a114 1
		    register int *source, register int *sourceflag));
d1094 5
a1098 5
static void	zstty_rxint __P((register struct zs_chanstate *));
static void	zstty_txint __P((register struct zs_chanstate *));
static void	zstty_stint __P((register struct zs_chanstate *));
static void	zsoverrun __P((struct zstty_softc *, long *, char *));
static void	zstty_softint __P((struct zs_chanstate *));
@


1.10.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.10 1998/03/03 04:54:47 ryker Exp $	*/
d106 6
a111 6
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
static void	zs_modem(struct zstty_softc *zst, int onoff);
static int	zshwiflow(struct tty *, int);
static void	zs_hwiflow(struct zstty_softc *, int);
static int	zsgetbaud(register struct zs_chanstate *,
d114 1
a114 1
		    register int *source, register int *sourceflag);
d1094 5
a1098 5
static void	zstty_rxint(register struct zs_chanstate *);
static void	zstty_txint(register struct zs_chanstate *);
static void	zstty_stint(register struct zs_chanstate *);
static void	zsoverrun(struct zstty_softc *, long *, char *);
static void	zstty_softint(struct zs_chanstate *);
@


1.10.10.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 6
a111 6
static void	zsstart(struct tty *);
static int	zsparam(struct tty *, struct termios *);
static void	zs_modem(struct zstty_softc *zst, int onoff);
static int	zshwiflow(struct tty *, int);
static void	zs_hwiflow(struct zstty_softc *, int);
static int	zsgetbaud(register struct zs_chanstate *,
d114 1
a114 1
		    register int *source, register int *sourceflag);
d1094 5
a1098 5
static void	zstty_rxint(register struct zs_chanstate *);
static void	zstty_txint(register struct zs_chanstate *);
static void	zstty_stint(register struct zs_chanstate *);
static void	zsoverrun(struct zstty_softc *, long *, char *);
static void	zstty_softint(struct zs_chanstate *);
@


1.10.10.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.10.10.1 2002/03/28 10:34:05 niklas Exp $	*/
d26 5
a30 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.10.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d200 1
d518 1
a518 1
		error = suser(p, 0);
d542 1
a542 1
		error = suser(p, 0);
d549 1
a549 1
		error = suser(p, 0);
d556 1
a556 1
		error = suser(p, 0);
d711 1
a711 1
			continue;	/* skip non-existent or bad clocks */
@


1.9
log
@Fix a conflict.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.8 1997/03/12 13:36:58 briggs Exp $	*/
d1020 1
a1020 1
	if (zst->zst_hwimask == 0) 
d1025 1
a1025 1

@


1.8
log
@Remove some more warnings left over from NetBSD's new config.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.7 1997/03/11 21:03:02 gene Exp $	*/
a126 1
	struct cfdata *cf = vcf;
@


1.7
log
@Second parameter of *match functions should be void (thank you ISA bus) and
*stop functions return int's under OpenBSD.  This cleans up a
bunch of compile-time warnings for the mac68k.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.6 1997/01/24 01:35:38 briggs Exp $	*/
d125 1
@


1.6
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.5 1996/10/14 02:49:14 briggs Exp $	*/
d90 1
a90 1
static int	zstty_match(struct device *, struct cfdata *, void *);
d120 1
a120 1
zstty_match(parent, cf, aux)
d122 1
a122 1
	struct cfdata *cf;
d126 1
d673 1
@


1.5
log
@Oops.  zsstop still needs to return int in OpenBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: z8530tty.c,v 1.4 1996/10/13 15:29:08 briggs Exp $	*/
/*	$NetBSD: z8530tty.c,v 1.7 1996/10/13 03:21:30 christos Exp $	*/
d90 1
a90 1
static int	zstty_match(struct device *, void *, void *);
d120 1
a120 1
zstty_match(parent, match, aux)
d122 2
a123 1
	void   *match, *aux;
a124 1
	struct cfdata *cf = match;
d701 2
@


1.4
log
@* Fix from Bill Studenmund <wrstuden@@loki.stanford.edu> for transmission
  lockups.
Changes from NetBSD:
- Add a ZS_CONSOLE_ABORT option to enable a serial console break to
  force a drop to the system debugger.  WARNING:  this used to be the
  default behavior!  Modify custom kernel configs accordingly.
- Check for ZS_HWFLAG_CONABRT in zs_abort(), and don't abort if it's
  not set.
- ttystop function returns void.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.3 1996/09/02 15:50:35 briggs Exp $	*/
d649 1
a649 1
void
@


1.3
log
@Detect stuck interrupts in the scc (if DIAGNOSTIC) and log it.
Patches from Bill Studenmund <wrstuden@@loki.stanford.edu>.
@
text
@d1 2
a2 2
/*	$OpenBSD: z8530tty.c,v 1.2 1996/06/08 16:21:13 briggs Exp $	*/
/*	$NetBSD: z8530tty.c,v 1.3 1996/06/01 00:13:41 scottr Exp $	*/
d618 2
a625 1
		(void) splzs();
a637 1
		(void) splzs();
d649 1
a649 1
int
a671 1
	return (0);
d1240 1
a1240 2
	if ((rr0 & ZSRR0_BREAK) &&
		(zst->zst_hwflags & ZS_HWFLAG_CONABRT))
d1259 2
a1260 1
	cs->cs_rr0_new = rr0;
d1382 3
a1384 3
		rr0 = cs->cs_rr0_new;
		delta = rr0 ^ cs->cs_rr0;
		cs->cs_rr0 = rr0;
@


1.2
log
@Sync up with latest NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.1 1996/05/26 19:02:12 briggs Exp $	*/
d1323 6
@


1.1
log
@Missed a few files in the previous updates.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: z8530tty.c,v 1.2 1996/05/23 02:06:53 briggs Exp $	*/
d203 1
@

