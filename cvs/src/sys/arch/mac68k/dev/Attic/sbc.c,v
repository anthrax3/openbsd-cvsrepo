head	1.21;
access;
symbols
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.12
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.12.0.14
	OPENBSD_2_9_BASE:1.12
	NIKLAS_UNDEAD:1.12.0.12
	OPENBSD_2_8:1.12.0.10
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.6
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.21
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.20;

1.20
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.16.21.19.05;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.29.03.04.18;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.13.21.12.56;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.02.06.43.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.09.21.48.31;	author miod;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	99.01.11.05.11.35;	author millert;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	98.05.03.07.13.01;	author gene;	state Exp;
branches;
next	1.10;

1.10
date	97.04.18.21.58.54;	author gene;	state Exp;
branches;
next	1.9;

1.9
date	97.04.08.00.26.15;	author gene;	state Exp;
branches;
next	1.8;

1.8
date	97.03.08.16.16.58;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.01.35.37;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	97.01.18.17.58.37;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.45.55;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.28.14.46.22;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.16.06.32;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.06.08.16.21.12;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	96.05.26.19.02.09;	author briggs;	state Exp;
branches;
next	;

1.12.6.1
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: sbc.c,v 1.20 2010/06/28 18:31:01 krw Exp $	*/
/*	$NetBSD: sbc.c,v 1.24 1997/04/18 17:38:08 scottr Exp $	*/

/*
 * Copyright (C) 1996 Scott Reynolds.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Scott Reynolds for
 *      the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file contains only the machine-dependent parts of the mac68k
 * NCR 5380 SCSI driver.  (Autoconfig stuff and PDMA functions.)
 * The machine-independent parts are in ncr5380sbc.c
 *
 * Supported hardware includes:
 * Macintosh II family 5380-based controller
 *
 * Credits, history:
 *
 * Scott Reynolds wrote this module, based on work by Allen Briggs
 * (mac68k), Gordon W. Ross and David Jones (sun3), and Leo Weppelman
 * (atari).  Thanks to Allen for supplying crucial interpretation of the
 * NetBSD/mac68k 1.1 'ncrscsi' driver.  Also, Allen, Gordon, and Jason
 * Thorpe all helped to refine this code, and were considerable sources
 * of moral support.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>

#include <dev/ic/ncr5380reg.h>
#include <dev/ic/ncr5380var.h>

#include <machine/cpu.h>
#include <machine/viareg.h>

#include "sbcreg.h"
#include "sbcvar.h"

int	sbc_debug = 0 /* | SBC_DB_INTR | SBC_DB_DMA */;
int	sbc_link_flags = 0 /* | SDEV_DB2 */;
int	sbc_options = 0 /* | SBC_PDMA */;

static	void	sbc_minphys(struct buf *bp, struct scsi_link *sl);

struct scsi_adapter	sbc_ops = {
	ncr5380_scsi_cmd,		/* scsi_cmd() */
	sbc_minphys,			/* scsi_minphys() */
	NULL,				/* probe_dev() */
	NULL,				/* free_dev() */
};

struct cfdriver sbc_cd = {
	NULL, "sbc", DV_DULL
};

static	int	sbc_ready(struct ncr5380_softc *);
static	void	sbc_wait_not_req(struct ncr5380_softc *);

static void
sbc_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > MAX_DMA_LEN)
		bp->b_bcount = MAX_DMA_LEN;
	minphys(bp);
}


/***
 * General support for Mac-specific SCSI logic.
 ***/

int
sbc_irq_intr(p)
	void *p;
{
	struct ncr5380_softc *ncr_sc = p;
	int claimed = 0;

	/* How we ever arrive here without IRQ set is a mystery... */
	if (*ncr_sc->sci_csr & SCI_CSR_INT) {
#ifdef SBC_DEBUG
		if (sbc_debug & SBC_DB_INTR)
			decode_5380_intr(ncr_sc);
#endif
		claimed = ncr5380_intr(ncr_sc);
		if (!claimed) {
			if (((*ncr_sc->sci_csr & ~SCI_CSR_PHASE_MATCH) == SCI_CSR_INT)
			    && ((*ncr_sc->sci_bus_csr & ~SCI_BUS_RST) == 0))
				SCI_CLR_INTR(ncr_sc);	/* RST interrupt */
#ifdef SBC_DEBUG
			else {
				printf("%s: spurious intr\n",
				    ncr_sc->sc_dev.dv_xname);
				SBC_BREAK;
			}
#endif
		}
	}

	return (claimed);
}

#ifdef SBC_DEBUG
void
decode_5380_intr(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	u_char csr = *ncr_sc->sci_csr;
	u_char bus_csr = *ncr_sc->sci_bus_csr;

	if (((csr & ~(SCI_CSR_PHASE_MATCH | SCI_CSR_ATN)) == SCI_CSR_INT) &&
	    ((bus_csr & ~(SCI_BUS_MSG | SCI_BUS_CD | SCI_BUS_IO | SCI_BUS_DBP)) == SCI_BUS_SEL)) {
		if (csr & SCI_BUS_IO)
			printf("%s: reselect\n", ncr_sc->sc_dev.dv_xname);
		else
			printf("%s: select\n", ncr_sc->sc_dev.dv_xname);
	} else if (((csr & ~SCI_CSR_ACK) == (SCI_CSR_DONE | SCI_CSR_INT)) &&
	    ((bus_csr & (SCI_BUS_RST | SCI_BUS_BSY | SCI_BUS_SEL)) == SCI_BUS_BSY))
		printf("%s: dma eop\n", ncr_sc->sc_dev.dv_xname);
	else if (((csr & ~SCI_CSR_PHASE_MATCH) == SCI_CSR_INT) &&
	    ((bus_csr & ~SCI_BUS_RST) == 0))
		printf("%s: bus reset\n", ncr_sc->sc_dev.dv_xname);
	else if (((csr & ~(SCI_CSR_DREQ | SCI_CSR_ATN | SCI_CSR_ACK)) == (SCI_CSR_PERR | SCI_CSR_INT | SCI_CSR_PHASE_MATCH)) &&
	    ((bus_csr & (SCI_BUS_RST | SCI_BUS_BSY | SCI_BUS_SEL)) == SCI_BUS_BSY))
		printf("%s: parity error\n", ncr_sc->sc_dev.dv_xname);
	else if (((csr & ~SCI_CSR_ATN) == SCI_CSR_INT) &&
	    ((bus_csr & (SCI_BUS_RST | SCI_BUS_BSY | SCI_BUS_REQ | SCI_BUS_SEL)) == (SCI_BUS_BSY | SCI_BUS_REQ)))
		printf("%s: phase mismatch\n", ncr_sc->sc_dev.dv_xname);
	else if (((csr & ~SCI_CSR_PHASE_MATCH) == (SCI_CSR_INT | SCI_CSR_DISC)) &&
	    (bus_csr == 0))
		printf("%s: disconnect\n", ncr_sc->sc_dev.dv_xname);
	else
		printf("%s: unknown intr: csr=%x, bus_csr=%x\n",
		    ncr_sc->sc_dev.dv_xname, csr, bus_csr);
}
#endif


/***
 * The following code implements polled PDMA.
 ***/

#define	TIMEOUT	5000000			/* x 2 usec = 10 sec */

static __inline__ int
sbc_ready(sc)
	struct ncr5380_softc *sc;
{
	int i = TIMEOUT;

	for (;;) {
		if ((*sc->sci_csr & (SCI_CSR_DREQ|SCI_CSR_PHASE_MATCH)) ==
		    (SCI_CSR_DREQ|SCI_CSR_PHASE_MATCH))
			return 1;
		if (((*sc->sci_csr & SCI_CSR_PHASE_MATCH) == 0) ||
		    (SCI_BUSY(sc) == 0))
			return 0;
		if (--i < 0)
			break;
		delay(2);
	}

	printf("%s: ready timeout\n", sc->sc_dev.dv_xname);
	return 0;
}

static __inline__ void
sbc_wait_not_req(sc)
	struct ncr5380_softc *sc;
{
	int i = TIMEOUT;

	for (;;) {
		if ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0 ||
		    (*sc->sci_csr & SCI_CSR_PHASE_MATCH) == 0 ||
		    SCI_BUSY(sc) == 0) {
			return;
		}
		if (--i < 0)
			break;
		delay(2);
	}
	printf("%s: pdma not_req timeout\n", sc->sc_dev.dv_xname);
}

int
sbc_pdma_in(ncr_sc, phase, datalen, data)
	struct ncr5380_softc *ncr_sc;
	int phase, datalen;
	u_char *data;
{
	struct sbc_softc *sc = (struct sbc_softc *)ncr_sc;
	volatile u_int32_t *long_data = (u_int32_t *)sc->sc_drq_addr;
	volatile u_int8_t *byte_data = (u_int8_t *)sc->sc_nodrq_addr;
	int resid, s;

	s = splbio();
	*ncr_sc->sci_mode |= SCI_MODE_DMA;
	*ncr_sc->sci_irecv = 0;

#define R4	*((u_int32_t *)data)++ = *long_data++
#define R1	*data++ = *byte_data++
	for (resid = datalen; resid >= 128; resid -= 128) {
		if (sbc_ready(ncr_sc) == 0)
			goto interrupt;
		R4; R4; R4; R4; R4; R4; R4; R4;
		R4; R4; R4; R4; R4; R4; R4; R4;
		R4; R4; R4; R4; R4; R4; R4; R4;
		R4; R4; R4; R4; R4; R4; R4; R4;

		long_data = (u_int32_t *)sc->sc_drq_addr;
		byte_data = (u_int8_t *)sc->sc_nodrq_addr;
	}
	while (resid) {
		if (sbc_ready(ncr_sc) == 0)
			goto interrupt;
		R1;
		resid--;
	}
#undef R4
#undef R1

	sbc_wait_not_req(ncr_sc);
interrupt:
	SCI_CLR_INTR(ncr_sc);
	*ncr_sc->sci_mode &= ~SCI_MODE_DMA;
	splx(s);
	return datalen - resid;
}

int
sbc_pdma_out(ncr_sc, phase, datalen, data)
	struct ncr5380_softc *ncr_sc;
	int phase, datalen;
	u_char *data;
{
	struct sbc_softc *sc = (struct sbc_softc *)ncr_sc;
	volatile u_int32_t *long_data = (u_int32_t *)sc->sc_drq_addr;
	volatile u_int8_t *byte_data = (u_int8_t *)sc->sc_nodrq_addr;
	int i, s, resid;
	u_char icmd;

	if (datalen < 64)
		return ncr5380_pio_out(ncr_sc, phase, datalen, data);

	s = splbio();
	icmd = *(ncr_sc->sci_icmd) & SCI_ICMD_RMASK;
	*ncr_sc->sci_icmd = icmd | SCI_ICMD_DATA;
	*ncr_sc->sci_mode |= SCI_MODE_DMA;
	*ncr_sc->sci_dma_send = 0;

	resid = datalen;
	if (sbc_ready(ncr_sc) == 0)
		goto interrupt;

#define W1	*byte_data++ = *data++
#define W4	*long_data++ = *((u_int32_t *)data)++
	while (resid >= 64) {
		if (sbc_ready(ncr_sc) == 0)
			goto interrupt;
		W1;
		resid--;
		if (sbc_ready(ncr_sc) == 0)
			goto interrupt;
		W1;
		resid--;
		if (sbc_ready(ncr_sc) == 0)
			goto interrupt;
		W1;
		resid--;
		if (sbc_ready(ncr_sc) == 0)
			goto interrupt;
		W1;
		resid--;
		if (sbc_ready(ncr_sc) == 0)
			goto interrupt;
		W4; W4; W4; W4;
		W4; W4; W4; W4;
		W4; W4; W4; W4;
		W4; W4; W4;
		resid -= 60;

		long_data = (u_int32_t *)sc->sc_drq_addr;
		byte_data = (u_int8_t *)sc->sc_nodrq_addr;
	}
	for (; resid; resid--) {
		if (sbc_ready(ncr_sc) == 0)
			goto interrupt;
		W1;
	}
#undef  W1
#undef  W4

	for (i = TIMEOUT; i > 0; i--) {
		if ((*ncr_sc->sci_csr & (SCI_CSR_DREQ|SCI_CSR_PHASE_MATCH))
		    != SCI_CSR_DREQ)
			break;
	}
	if (i != 0)
		*byte_data = 0;
	else
		printf("%s: timeout waiting for final SCI_DSR_DREQ.\n",
			ncr_sc->sc_dev.dv_xname);

	sbc_wait_not_req(ncr_sc);
interrupt:
	SCI_CLR_INTR(ncr_sc);
	*ncr_sc->sci_mode &= ~SCI_MODE_DMA;
	*ncr_sc->sci_icmd = icmd;
	splx(s);
	return (datalen - resid);
}


/***
 * The following code implements interrupt-driven PDMA.
 ***/

/*
 * This is the meat of the PDMA transfer.
 * When we get here, we shove data as fast as the mac can take it.
 * We depend on several things:
 *   * All macs after the Mac Plus that have a 5380 chip should have a general
 *     logic IC that handshakes data for blind transfers.
 *   * If the SCSI controller finishes sending/receiving data before we do,
 *     the same general logic IC will generate a /BERR for us in short order.
 *   * The fault address for said /BERR minus the base address for the
 *     transfer will be the amount of data that was actually written.
 *
 * We use the nofault flag and the setjmp/longjmp in locore.s so we can
 * detect and handle the bus error for early termination of a command.
 * This is usually caused by a disconnecting target.
 */
int
sbc_drq_intr(p)
	void *p;
{
	extern int *nofault, m68k_fault_addr;
	struct sbc_softc *sc = (struct sbc_softc *)p;
	struct ncr5380_softc *ncr_sc = (struct ncr5380_softc *)p;
	struct sci_req *sr = ncr_sc->sc_current;
	struct sbc_pdma_handle *dh = sr->sr_dma_hand;
	label_t faultbuf;
	volatile u_int32_t *long_drq;
	u_int32_t *long_data;
	volatile u_int8_t *drq;
	u_int8_t *data;
	int count, dcount, resid;
#ifdef SBC_WRITE_HACK
	u_int8_t tmp;
#endif

	/*
	 * If we're not ready to xfer data, or have no more, just return.
	 */
	if ((*ncr_sc->sci_csr & SCI_CSR_DREQ) == 0 || dh->dh_len == 0)
		return (0);

#ifdef SBC_DEBUG
	if (sbc_debug & SBC_DB_INTR)
		printf("%s: drq intr, dh_len=0x%x, dh_flags=0x%x\n",
		    ncr_sc->sc_dev.dv_xname, dh->dh_len, dh->dh_flags);
#endif

	/*
	 * Setup for a possible bus error caused by SCSI controller
	 * switching out of DATA-IN/OUT before we're done with the
	 * current transfer.
	 */
	nofault = (int *) &faultbuf;

	if (setjmp((label_t *)nofault)) {
		nofault = (int *) 0;
		if ((dh->dh_flags & SBC_DH_DONE) == 0) {
			count = ((  (u_long)m68k_fault_addr
				  - (u_long)sc->sc_drq_addr));

			if ((count < 0) || (count > dh->dh_len)) {
				printf("%s: complete=0x%x (pending 0x%x)\n",
				    ncr_sc->sc_dev.dv_xname, count, dh->dh_len);
				panic("something is wrong");
			}

			dh->dh_addr += count;
			dh->dh_len -= count;
		} else
			count = 0;

#ifdef SBC_DEBUG
		if (sbc_debug & SBC_DB_INTR)
			printf("%s: drq /berr, complete=0x%x (pending 0x%x)\n",
			   ncr_sc->sc_dev.dv_xname, count, dh->dh_len);
#endif
		m68k_fault_addr = 0;

		return (1);
	}

	if (dh->dh_flags & SBC_DH_OUT) { /* Data Out */
#if notyet /* XXX */
		/*
		 * Get the source address aligned.
		 */
		resid =
		    count = min(dh->dh_len, 4 - (((int)dh->dh_addr) & 0x3));
		if (count && count < 4) {
			drq = (volatile u_int8_t *)sc->sc_drq_addr;
			data = (u_int8_t *)dh->dh_addr;

#define W1		*drq++ = *data++
			while (count) {
				W1; count--;
			}
#undef W1
			dh->dh_addr += resid;
			dh->dh_len -= resid;
		}

		/*
		 * Start the transfer.
		 */
		while (dh->dh_len) {
			dcount = count = min(dh->dh_len, MAX_DMA_LEN);
			long_drq = (volatile u_int32_t *)sc->sc_drq_addr;
			long_data = (u_int32_t *)dh->dh_addr;

#define W4		*long_drq++ = *long_data++
			while (count >= 64) {
				W4; W4; W4; W4; W4; W4; W4; W4;
				W4; W4; W4; W4; W4; W4; W4; W4; /*  64 */
				count -= 64;
			}
			while (count >= 4) {
				W4; count -= 4;
			}
#undef W4
			data = (u_int8_t *)long_data;
			drq = (u_int8_t *)long_drq;
#else /* notyet */
		/*
		 * Start the transfer.
		 */
		while (dh->dh_len) {
			dcount = count = min(dh->dh_len, MAX_DMA_LEN);
			drq = (volatile u_int8_t *)sc->sc_drq_addr;
			data = (u_int8_t *)dh->dh_addr;
#endif /* notyet */

#define W1		*drq++ = *data++
			while (count) {
				W1; count--;
			}
#undef W1
			dh->dh_len -= dcount;
			dh->dh_addr += dcount;
		}
		dh->dh_flags |= SBC_DH_DONE;

#ifdef SBC_WRITE_HACK
		/*
		 * XXX -- Read a byte from the SBC to trigger a /BERR.
		 * This seems to be necessary for us to notice that
		 * the target has disconnected.  Ick.  06 jun 1996 (sr)
		 */
		if (dcount >= MAX_DMA_LEN) {
#if 0
			while ((*ncr_sc->sci_csr & SCI_CSR_ACK) == 0)
				;
#endif
			drq = (volatile u_int8_t *)sc->sc_drq_addr;
		}
		tmp = *drq;
#endif
	} else {	/* Data In */
		/*
		 * Get the dest address aligned.
		 */
		resid =
		    count = min(dh->dh_len, 4 - (((int)dh->dh_addr) & 0x3));
		if (count && count < 4) {
			data = (u_int8_t *)dh->dh_addr;
			drq = (volatile u_int8_t *)sc->sc_drq_addr;

#define R1		*data++ = *drq++
			while (count) {
				R1; count--;
			}
#undef R1
			dh->dh_addr += resid;
			dh->dh_len -= resid;
		}

		/*
		 * Start the transfer.
		 */
		while (dh->dh_len) {
			dcount = count = min(dh->dh_len, MAX_DMA_LEN);
			long_data = (u_int32_t *)dh->dh_addr;
			long_drq = (volatile u_int32_t *)sc->sc_drq_addr;

#define R4		*long_data++ = *long_drq++
			while (count >= 64) {
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;	/* 64 */
				count -= 64;
			}
			while (count >= 4) {
				R4; count -= 4;
			}
#undef R4
			data = (u_int8_t *)long_data;
			drq = (volatile u_int8_t *)long_drq;

#define R1		*data++ = *drq++
			while (count) {
				R1; count--;
			}
#undef R1
			dh->dh_len -= dcount;
			dh->dh_addr += dcount;
		}
		dh->dh_flags |= SBC_DH_DONE;
	}

	/*
	 * OK.  No bus error occurred above.  Clear the nofault flag
	 * so we no longer short-circuit bus errors.
	 */
	nofault = (int *) 0;

#ifdef SBC_DEBUG
	if (sbc_debug & (SBC_DB_REG | SBC_DB_INTR))
		printf("%s: drq intr complete: csr=0x%x, bus_csr=0x%x\n",
		    ncr_sc->sc_dev.dv_xname, *ncr_sc->sci_csr,
		    *ncr_sc->sci_bus_csr);
#endif

	return (1);
}

void
sbc_dma_alloc(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct sbc_softc *sc = (struct sbc_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct scsi_xfer *xs = sr->sr_xs;
	struct sbc_pdma_handle *dh;
	int		i, xlen;

#ifdef DIAGNOSTIC
	if (sr->sr_dma_hand != NULL)
		panic("sbc_dma_alloc: already have PDMA handle");
#endif

	/* Polled transfers shouldn't allocate a PDMA handle. */
	if (sr->sr_flags & SR_IMMED)
		return;

	xlen = ncr_sc->sc_datalen;

	/* Make sure our caller checked sc_min_dma_len. */
	if (xlen < MIN_DMA_LEN)
		panic("sbc_dma_alloc: len=0x%x", xlen);

	/*
	 * Find free PDMA handle.  Guaranteed to find one since we
	 * have as many PDMA handles as the driver has processes.
	 * (instances?)
	 */
	 for (i = 0; i < SCI_OPENINGS; i++) {
		if ((sc->sc_pdma[i].dh_flags & SBC_DH_BUSY) == 0)
			goto found;
	}
	panic("sbc: no free PDMA handles");
found:
	dh = &sc->sc_pdma[i];
	dh->dh_flags = SBC_DH_BUSY;
	dh->dh_addr = ncr_sc->sc_dataptr;
	dh->dh_len = xlen;

	/* Copy the 'write' flag for convenience. */
	if (xs->flags & SCSI_DATA_OUT)
		dh->dh_flags |= SBC_DH_OUT;

	sr->sr_dma_hand = dh;
}

void
sbc_dma_free(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct sci_req *sr = ncr_sc->sc_current;
	struct sbc_pdma_handle *dh = sr->sr_dma_hand;

#ifdef DIAGNOSTIC
	if (sr->sr_dma_hand == NULL)
		panic("sbc_dma_free: no DMA handle");
#endif

	if (ncr_sc->sc_state & NCR_DOINGDMA)
		panic("sbc_dma_free: free while in progress");

	if (dh->dh_flags & SBC_DH_BUSY) {
		dh->dh_flags = 0;
		dh->dh_addr = NULL;
		dh->dh_len = 0;
	}
	sr->sr_dma_hand = NULL;
}

void
sbc_dma_poll(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct sci_req *sr = ncr_sc->sc_current;

	/*
	 * We shouldn't arrive here; if SR_IMMED is set, then
	 * dma_alloc() should have refused to allocate a handle
	 * for the transfer.  This forces the polled PDMA code
	 * to handle the request...
	 */
#ifdef SBC_DEBUG
	if (sbc_debug & SBC_DB_DMA)
		printf("%s: lost DRQ interrupt?\n", ncr_sc->sc_dev.dv_xname);
#endif
	sr->sr_flags |= SR_OVERDUE;
}

void
sbc_dma_setup(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	/* Not needed; we don't have real DMA */
}

void
sbc_dma_start(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct sbc_softc *sc = (struct sbc_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct sbc_pdma_handle *dh = sr->sr_dma_hand;

	/*
	 * Match bus phase, clear pending interrupts, set DMA mode, and
	 * assert data bus (for writing only), then start the transfer.
	 */
	if (dh->dh_flags & SBC_DH_OUT) {
		*ncr_sc->sci_tcmd = PHASE_DATA_OUT;
		SCI_CLR_INTR(ncr_sc);
		if (sc->sc_clrintr)
			(*sc->sc_clrintr)(ncr_sc);
		*ncr_sc->sci_mode |= SCI_MODE_DMA;
		*ncr_sc->sci_icmd = SCI_ICMD_DATA;
		*ncr_sc->sci_dma_send = 0;
	} else {
		*ncr_sc->sci_tcmd = PHASE_DATA_IN;
		SCI_CLR_INTR(ncr_sc);
		if (sc->sc_clrintr)
			(*sc->sc_clrintr)(ncr_sc);
		*ncr_sc->sci_mode |= SCI_MODE_DMA;
		*ncr_sc->sci_icmd = 0;
		*ncr_sc->sci_irecv = 0;
	}
	ncr_sc->sc_state |= NCR_DOINGDMA;

#ifdef SBC_DEBUG
	if (sbc_debug & SBC_DB_DMA)
		printf("%s: PDMA started, va=%p, len=0x%x\n",
		    ncr_sc->sc_dev.dv_xname, dh->dh_addr, dh->dh_len);
#endif
}

void
sbc_dma_stop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct sbc_softc *sc = (struct sbc_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct sbc_pdma_handle *dh = sr->sr_dma_hand;
	int ntrans;

	if ((ncr_sc->sc_state & NCR_DOINGDMA) == 0) {
#ifdef SBC_DEBUG
		if (sbc_debug & SBC_DB_DMA)
			printf("%s: dma_stop: DMA not running\n",
			    ncr_sc->sc_dev.dv_xname);
#endif
		return;
	}
	ncr_sc->sc_state &= ~NCR_DOINGDMA;

	if ((ncr_sc->sc_state & NCR_ABORTING) == 0) {
		ntrans = ncr_sc->sc_datalen - dh->dh_len;

#ifdef SBC_DEBUG
		if (sbc_debug & SBC_DB_DMA)
			printf("%s: dma_stop: ntrans=0x%x\n",
			    ncr_sc->sc_dev.dv_xname, ntrans);
#endif

		if (ntrans > ncr_sc->sc_datalen)
			panic("sbc_dma_stop: excess transfer");

		/* Adjust data pointer */
		ncr_sc->sc_dataptr += ntrans;
		ncr_sc->sc_datalen -= ntrans;

		/* Clear any pending interrupts. */
		SCI_CLR_INTR(ncr_sc);
		if (sc->sc_clrintr)
			(*sc->sc_clrintr)(ncr_sc);
	}

	/* Put SBIC back into PIO mode. */
	*ncr_sc->sci_mode &= ~SCI_MODE_DMA;
	*ncr_sc->sci_icmd = 0;

#ifdef SBC_DEBUG
	if (sbc_debug & SBC_DB_REG)
		printf("%s: dma_stop: csr=0x%x, bus_csr=0x%x\n",
		    ncr_sc->sc_dev.dv_xname, *ncr_sc->sci_csr,
		    *ncr_sc->sci_bus_csr);
#endif
}
@


1.20
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.19 2010/06/26 23:24:43 guenther Exp $	*/
@


1.19
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.18 2009/02/16 21:19:05 miod Exp $	*/
a84 9
};

/* This is copied from julian's bt driver */
/* "so we have a default dev struct for our link struct." */
struct scsi_device sbc_dev = {
	NULL,		/* Use default error handler.	    */
	NULL,		/* Use default start handler.		*/
	NULL,		/* Use default async handler.	    */
	NULL,		/* Use default "done" routine.	    */
@


1.18
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.17 2007/12/29 03:04:18 dlg Exp $	*/
a59 1
#include <sys/user.h>
@


1.17
log
@fix comments after the members of scsi_adapter were changed.

prompted by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.16 2006/12/13 21:12:56 miod Exp $	*/
d79 1
a79 1
static	void	sbc_minphys(struct buf *bp);
d105 1
a105 1
sbc_minphys(struct buf *bp)
d109 1
a109 1
	return (minphys(bp));
@


1.16
log
@Remove the dma_eop callback in the ncr5380 driver md attachment, it was always
doing nothing and the mi code does not use it anymore anyway. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.15 2004/12/02 06:43:25 miod Exp $	*/
d82 4
a85 4
	ncr5380_scsi_cmd,		/* scsi_cmd()		*/
	sbc_minphys,			/* scsi_minphys()	*/
	NULL,				/* open_target_lu()	*/
	NULL,				/* close_target_lu()	*/
@


1.15
log
@Oops, repair *SBC kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.14 2002/03/14 01:26:35 millert Exp $	*/
a718 7
}

void
sbc_dma_eop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	/* Not used; the EOP pin is wired high (GMFH, pp. 389-390) */
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.13 2001/09/09 21:48:31 miod Exp $	*/
d117 1
a117 1
void
d144 2
d379 1
a379 1
void
d402 1
a402 1
		return;
d441 1
a441 1
		return;
d582 2
@


1.13
log
@Repair compilation of mac68k GENERIC_SBC kernel.
From Takeshi Morimoto <morimoto@@anat1.med.kyoto-u.ac.jp>, PR #2037
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.12 1999/01/11 05:11:35 millert Exp $	*/
d79 1
a79 1
static	void	sbc_minphys __P((struct buf *bp));
d101 2
a102 2
static	int	sbc_ready __P((struct ncr5380_softc *));
static	void	sbc_wait_not_req __P((struct ncr5380_softc *));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.13 2001/09/09 21:48:31 miod Exp $	*/
d79 1
a79 1
static	void	sbc_minphys(struct buf *bp);
d101 2
a102 2
static	int	sbc_ready(struct ncr5380_softc *);
static	void	sbc_wait_not_req(struct ncr5380_softc *);
@


1.12
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.11 1998/05/03 07:13:01 gene Exp $	*/
d381 1
a381 1
	extern int *nofault, mac68k_buserr_addr;
d418 1
a418 1
			count = ((  (u_long)mac68k_buserr_addr
d437 1
a437 1
		mac68k_buserr_addr = 0;
@


1.12.6.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.12 1999/01/11 05:11:35 millert Exp $	*/
d381 1
a381 1
	extern int *nofault, m68k_fault_addr;
d418 1
a418 1
			count = ((  (u_long)m68k_fault_addr
d437 1
a437 1
		m68k_fault_addr = 0;
@


1.12.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
a79 1
static	void	sbc_minphys(struct buf *bp);
d101 2
a102 2
static	int	sbc_ready(struct ncr5380_softc *);
static	void	sbc_wait_not_req(struct ncr5380_softc *);
@


1.11
log
@Associated fallout from removing macinfo.h and merging to cpu.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.10 1997/04/18 21:58:54 gene Exp $	*/
d605 1
a605 1
		panic("sbc_dma_alloc: len=0x%x\n", xlen);
d753 1
a753 1
			panic("sbc_dma_stop: excess transfer\n");
@


1.10
log
@More fixes from Scott Reynolds:
>For small writes, use PIO rather than PDMA; this increases the reliability
>of the driver (considerably, on some systems/targets).
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.9 1997/04/08 00:26:15 gene Exp $	*/
a69 1
#include <machine/macinfo.h>
@


1.9
log
@Rewrite to make dma more stable from scottr@@netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: sbc.c,v 1.8 1997/03/08 16:16:58 briggs Exp $	*/
/*	$NetBSD: sbc.c,v 1.22 1997/03/01 20:18:58 scottr Exp $	*/
d78 1
a78 1
int	sbc_options = SBC_PDMA;
d237 2
a238 2
	volatile long *long_data = (long *)sc->sc_drq_addr;
	volatile u_char *byte_data = (u_char *)sc->sc_nodrq_addr;
d245 2
a246 2
#define R4	*((long *)data)++ = *long_data
#define R1	*data++ = *byte_data
d254 3
d282 2
a283 2
	volatile long *long_data = (long *)sc->sc_drq_addr;
	volatile u_char *byte_data = (u_char *)sc->sc_nodrq_addr;
d287 3
d300 2
a301 2
#define W1	*byte_data = *data++
#define W4	*long_data = *((long*)data)++
d326 3
d383 2
a384 2
	struct sbc_softc *sc = (struct sbc_softc *) p;
	struct ncr5380_softc *ncr_sc = (struct ncr5380_softc *) p;
d416 1
a416 1
	if (setjmp((label_t *) nofault)) {
d419 2
a420 2
			count = ((  (u_long) mac68k_buserr_addr
				  - (u_long) sc->sc_drq_addr));
d449 1
a449 1
		    count = min(dh->dh_len, 4 - (((int) dh->dh_addr) & 0x3));
d451 2
a452 2
			drq = (volatile u_int8_t *) sc->sc_drq_addr;
			data = (u_int8_t *) dh->dh_addr;
d468 2
a469 2
			long_drq = (volatile u_int32_t *) sc->sc_drq_addr;
			long_data = (u_int32_t *) dh->dh_addr;
d481 2
a482 2
			data = (u_int8_t *) long_data;
			drq = (u_int8_t *) long_drq;
d489 2
a490 2
			drq = (volatile u_int8_t *) sc->sc_drq_addr;
			data = (u_int8_t *) dh->dh_addr;
d514 1
a514 1
			drq = (volatile u_int8_t *) sc->sc_drq_addr;
d523 1
a523 1
		    count = min(dh->dh_len, 4 - (((int) dh->dh_addr) & 0x3));
d525 2
a526 2
			data = (u_int8_t *) dh->dh_addr;
			drq = (volatile u_int8_t *) sc->sc_drq_addr;
d542 2
a543 2
			long_data = (u_int32_t *) dh->dh_addr;
			long_drq = (volatile u_int32_t *) sc->sc_drq_addr;
d555 2
a556 2
			data = (u_int8_t *) long_data;
			drq = (volatile u_int8_t *) long_drq;
d587 1
a587 1
	struct sbc_softc *sc = (struct sbc_softc *) ncr_sc;
d684 1
a684 1
	struct sbc_softc *sc = (struct sbc_softc *) ncr_sc;
d729 1
a729 1
	struct sbc_softc *sc = (struct sbc_softc *) ncr_sc;
@


1.8
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.7 1997/01/24 01:35:37 briggs Exp $	*/
d102 2
a103 3
static		int	sbc_wait_busy __P((struct ncr5380_softc *));
static		int	sbc_ready __P((struct ncr5380_softc *));
static		int	sbc_wait_dreq __P((struct ncr5380_softc *));
a117 66
/* These are used in the following inline functions. */
int sbc_wait_busy_timo = 1000 * 5000;	/* X2 = 10 S. */
int sbc_ready_timo = 1000 * 5000;	/* X2 = 10 S. */
int sbc_wait_dreq_timo = 1000 * 5000;	/* X2 = 10 S. */

/* Return zero on success. */
static __inline__ int
sbc_wait_busy(sc)
	struct ncr5380_softc *sc;
{
	register int timo = sbc_wait_busy_timo;
	for (;;) {
		if (SCI_BUSY(sc)) {
			timo = 0;	/* return 0 */
			break;
		}
		if (--timo < 0)
			break;	/* return -1 */
		delay(2);
	}
	return (timo);
}

static __inline__ int
sbc_ready(sc)
	struct ncr5380_softc *sc;
{
	register int timo = sbc_ready_timo;

	for (;;) {
		if ((*sc->sci_csr & (SCI_CSR_DREQ|SCI_CSR_PHASE_MATCH))
		    == (SCI_CSR_DREQ|SCI_CSR_PHASE_MATCH)) {
			timo = 0;
			break;
		}
		if (((*sc->sci_csr & SCI_CSR_PHASE_MATCH) == 0)
		    || (SCI_BUSY(sc) == 0)) {
			timo = -1;
			break;
		}
		if (--timo < 0)
			break;	/* return -1 */
		delay(2);
	}
	return (timo);
}

static __inline__ int
sbc_wait_dreq(sc)
	struct ncr5380_softc *sc;
{
	register int timo = sbc_wait_dreq_timo;

	for (;;) {
		if ((*sc->sci_csr & (SCI_CSR_DREQ|SCI_CSR_PHASE_MATCH))
		    == (SCI_CSR_DREQ|SCI_CSR_PHASE_MATCH)) {
			timo = 0;
			break;
		}
		if (--timo < 0)
			break;	/* return -1 */
		delay(2);
	}
	return (timo);
}

d122 2
a123 2
	register struct ncr5380_softc *ncr_sc = p;
	register int claimed = 0;
d152 2
a153 2
	register u_char csr = *ncr_sc->sci_csr;
	register u_char bus_csr = *ncr_sc->sci_bus_csr;
d187 5
a191 6
int
sbc_pdma_out(ncr_sc, phase, count, data)
	struct ncr5380_softc *ncr_sc;
	int phase;
	int count;
	u_char *data;
d193 13
a205 4
	struct sbc_softc *sc = (struct sbc_softc *)ncr_sc;
	register volatile long *long_data = (long *) sc->sc_drq_addr;
	register volatile u_char *byte_data = (u_char *) sc->sc_nodrq_addr;
	register int len = count;
d207 3
a209 2
	if (count < ncr_sc->sc_min_dma_len || (sc->sc_options & SBC_PDMA) == 0)
		return ncr5380_pio_out(ncr_sc, phase, count, data);
d211 5
a215 4
	if (sbc_wait_busy(ncr_sc) == 0) {
		*ncr_sc->sci_mode |= SCI_MODE_DMA;
		*ncr_sc->sci_icmd |= SCI_ICMD_DATA;
		*ncr_sc->sci_dma_send = 0;
d217 5
a221 22
#define W1	*byte_data = *data++
#define W4	*long_data = *((long*)data)++
		while (len >= 64) {
			if (sbc_ready(ncr_sc))
				goto timeout;
			W1;
			if (sbc_ready(ncr_sc))
				goto timeout;
			W1;
			if (sbc_ready(ncr_sc))
				goto timeout;
			W1;
			if (sbc_ready(ncr_sc))
				goto timeout;
			W1;
			if (sbc_ready(ncr_sc))
				goto timeout;
			W4; W4; W4; W4;
			W4; W4; W4; W4;
			W4; W4; W4; W4;
			W4; W4; W4;
			len -= 64;
d223 6
a228 11
		while (len) {
			if (sbc_ready(ncr_sc))
				goto timeout;
			W1;
			len--;
		}
#undef  W1
#undef  W4
		if (sbc_wait_dreq(ncr_sc))
			printf("%s: timeout waiting for DREQ.\n",
			    ncr_sc->sc_dev.dv_xname);
d230 14
a243 1
		*byte_data = 0;
d245 15
a259 12
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_mode &= ~SCI_MODE_DMA;
		*ncr_sc->sci_icmd = 0;
	}
	return count - len;

timeout:
	printf("%s: pdma_out: timeout len=%d count=%d\n",
	    ncr_sc->sc_dev.dv_xname, len, count);
	if ((*ncr_sc->sci_csr & SCI_CSR_PHASE_MATCH) == 0) {
		*ncr_sc->sci_icmd &= ~SCI_ICMD_DATA;
		--len;
d261 2
d264 2
d268 2
a269 2
	*ncr_sc->sci_icmd = 0;
	return count - len;
d273 1
a273 1
sbc_pdma_in(ncr_sc, phase, count, data)
d275 1
a275 2
	int phase;
	int count;
d279 14
a292 3
	register volatile long *long_data = (long *) sc->sc_drq_addr;
	register volatile u_char *byte_data = (u_char *) sc->sc_nodrq_addr;
	register int len = count;
d294 34
a327 2
	if (count < ncr_sc->sc_min_dma_len || (sc->sc_options & SBC_PDMA) == 0)
		return ncr5380_pio_in(ncr_sc, phase, count, data);
d329 4
a332 78
	if (sbc_wait_busy(ncr_sc) == 0) {
		*ncr_sc->sci_mode |= SCI_MODE_DMA;
		*ncr_sc->sci_icmd |= SCI_ICMD_DATA;
		*ncr_sc->sci_irecv = 0;

#define R4	*((long *)data)++ = *long_data
#define R1	*data++ = *byte_data
		while (len >= 1024) {
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 128 */
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 256 */
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 384 */
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 512 */
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 640 */
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 768 */
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 896 */
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 1024 */
			len -= 1024;
		}
		while (len >= 128) {
			if (sbc_ready(ncr_sc))
				goto timeout;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;		/* 128 */
			len -= 128;
		}
		while (len) {
			if (sbc_ready(ncr_sc))
				goto timeout;
			R1;
			len--;
		}
#undef R4
#undef R1
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_mode &= ~SCI_MODE_DMA;
		*ncr_sc->sci_icmd = 0;
d334 5
a338 5
	return count - len;

timeout:
	printf("%s: pdma_in: timeout len=%d count=%d\n",
	    ncr_sc->sc_dev.dv_xname, len, count);
d340 2
d344 3
a346 2
	*ncr_sc->sci_icmd = 0;
	return count - len;
d373 11
a383 12
	extern	int		*nofault, mac68k_buserr_addr;
	register struct sbc_softc *sc = (struct sbc_softc *) p;
	register struct ncr5380_softc *ncr_sc = (struct ncr5380_softc *) p;
	register struct sci_req *sr = ncr_sc->sc_current;
	register struct sbc_pdma_handle *dh = sr->sr_dma_hand;
	label_t			faultbuf;
	volatile u_int32_t	*long_drq;
	u_int32_t		*long_data;
	volatile u_int8_t	*drq;
	u_int8_t		*data;
	register int		count;
	int			dcount, resid;
d385 1
a385 1
	u_int8_t		tmp;
d675 1
a675 1
	register struct sbc_softc *sc = (struct sbc_softc *) ncr_sc;
d720 1
a720 1
	register struct sbc_softc *sc = (struct sbc_softc *) ncr_sc;
d723 1
a723 1
	register int ntrans;
@


1.7
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: sbc.c,v 1.6 1997/01/18 17:58:37 briggs Exp $	*/
/*	$NetBSD: sbc.c,v 1.18 1997/01/20 04:27:49 scottr Exp $	*/
d5 1
a5 2
 * Copyright (c) 1996 Scott Reynolds
 * All rights reserved.
d15 6
a20 5
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *      This product includes software developed by Scott Reynolds.
d22 1
a22 1
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
d25 1
a25 1
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
d74 1
d76 3
a78 47
/*
 * Transfers smaller than this are done using PIO
 * (on assumption they're not worth PDMA overhead)
 */
#define	MIN_DMA_LEN 128

/*
 * Transfers larger than 8192 bytes need to be split up
 * due to the size of the PDMA space.
 */
#define	MAX_DMA_LEN 0x2000

/*
 * From Guide to the Macintosh Family Hardware, pp. 137-143
 * These are offsets from SCSIBase (see pmap_bootstrap.c)
 */
#define	SBC_REG_OFS		0x10000
#define	SBC_DMA_OFS		0x12000
#define	SBC_HSK_OFS		0x06000

#define	SBC_DMA_OFS_PB500	0x06000

#define	SBC_REG_OFS_IIFX	0x08000		/* Just guessing... */
#define	SBC_DMA_OFS_IIFX	0x0c000
#define	SBC_HSK_OFS_IIFX	0x0e000

#define	SBC_REG_OFS_DUO2	0x00000
#define	SBC_DMA_OFS_DUO2	0x02000
#define	SBC_HSK_OFS_DUO2	0x04000

#ifdef SBC_DEBUG
# define	SBC_DB_INTR	0x01
# define	SBC_DB_DMA	0x02
# define	SBC_DB_REG	0x04
# define	SBC_DB_BREAK	0x08

	int	sbc_debug = 0 /* | SBC_DB_INTR | SBC_DB_DMA */;
	int	sbc_link_flags = 0 /* | SDEV_DB2 */;

# ifndef DDB
#  define	Debugger()	printf("Debug: sbc.c:%d\n", __LINE__)
# endif
# define	SBC_BREAK \
		do { if (sbc_debug & SBC_DB_BREAK) Debugger(); } while (0)
#else
# define	SBC_BREAK
#endif
a79 49
/*
 * This structure is used to keep track of PDMA requests.
 */
struct sbc_pdma_handle {
	int	dh_flags;	/* flags */
#define	SBC_DH_BUSY	0x01	/* This handle is in use */
#define	SBC_DH_OUT	0x02	/* PDMA data out (write) */
#define	SBC_DH_DONE	0x04	/* PDMA transfer is complete */
	u_char	*dh_addr;	/* data buffer */
	int	dh_len;		/* length of data buffer */
};

/*
 * The first structure member has to be the ncr5380_softc
 * so we can just cast to go back and forth between them.
 */
struct sbc_softc {
	struct ncr5380_softc ncr_sc;
	volatile struct sbc_regs *sc_regs;
	volatile vm_offset_t	sc_drq_addr;
	volatile vm_offset_t	sc_nodrq_addr;
	volatile u_int8_t	*sc_ienable;
	volatile u_int8_t	*sc_iflag;
	int			sc_options;	/* options for this instance. */
	struct sbc_pdma_handle sc_pdma[SCI_OPENINGS];
};

/*
 * Options.  By default, SCSI interrupts and reselect are disabled.
 * You may enable either of these features with the `flags' directive
 * in your kernel's configuration file.
 *
 * Alternatively, you can patch your kernel with DDB or some other
 * mechanism.  The sc_options member of the softc is OR'd with
 * the value in sbc_options.
 *
 * The options code is based on the sparc 'si' driver's version of
 * the same.
 */     
#define	SBC_PDMA	0x01	/* Use PDMA for polled transfers */
#define	SBC_INTR	0x02	/* Allow SCSI IRQ/DRQ interrupts */
#define	SBC_RESELECT	0x04	/* Allow disconnect/reselect */
#define	SBC_OPTIONS_MASK	(SBC_RESELECT|SBC_INTR|SBC_PDMA)
#define	SBC_OPTIONS_BITS	"\10\3RESELECT\2INTR\1PDMA"
int sbc_options = SBC_PDMA;

static	int	sbc_match __P((struct device *, struct cfdata *, void *));
static	void	sbc_attach __P((struct device *, struct device *, void *));
static	int	sbc_print __P((void *, const char *));
d82 1
a82 22
static	int	sbc_wait_busy __P((struct ncr5380_softc *));
static	int	sbc_ready __P((struct ncr5380_softc *));
static	int	sbc_wait_dreq __P((struct ncr5380_softc *));
static	int	sbc_pdma_in __P((struct ncr5380_softc *, int, int, u_char *));
static	int	sbc_pdma_out __P((struct ncr5380_softc *, int, int, u_char *));
#ifdef SBC_DEBUG
static	void	decode_5380_intr __P((struct ncr5380_softc *));
#endif

	void	sbc_intr_enable __P((struct ncr5380_softc *));
	void	sbc_intr_disable __P((struct ncr5380_softc *));
	void	sbc_irq_intr __P((void *));
	void	sbc_drq_intr __P((void *));
	void	sbc_dma_alloc __P((struct ncr5380_softc *));
	void	sbc_dma_free __P((struct ncr5380_softc *));
	void	sbc_dma_poll __P((struct ncr5380_softc *));
	void	sbc_dma_setup __P((struct ncr5380_softc *));
	void	sbc_dma_start __P((struct ncr5380_softc *));
	void	sbc_dma_eop __P((struct ncr5380_softc *));
	void	sbc_dma_stop __P((struct ncr5380_softc *));

static struct scsi_adapter	sbc_ops = {
d91 1
a91 1
static struct scsi_device sbc_dev = {
a97 4
struct cfattach sbc_ca = {
	sizeof(struct sbc_softc), sbc_match, sbc_attach
};

d102 3
a104 168

static int
sbc_match(parent, cf, args)
	struct device *parent;
	struct cfdata *cf;
	void *args;
{
	switch (current_mac_model->machineid) {
	case MACH_MACIIFX:	/* Note: the IIfx isn't (yet) supported. */
		break;
	case MACH_MACPB210:
	case MACH_MACPB230:
	case MACH_MACPB250:
	case MACH_MACPB270:
	case MACH_MACPB280:
	case MACH_MACPB280C:
		if (cf->cf_unit == 1)
			return 1;
		/*FALLTHROUGH*/
	default:
		if (cf->cf_unit == 0 && mac68k_machine.scsi80)
			return 1;
	}
	return 0;
}

static void
sbc_attach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct sbc_softc *sc = (struct sbc_softc *) self;
	struct ncr5380_softc *ncr_sc = (struct ncr5380_softc *) sc;
	char bits[64];
	extern vm_offset_t SCSIBase;

	/* Pull in the options flags. */ 
	sc->sc_options = ((ncr_sc->sc_dev.dv_cfdata->cf_flags | sbc_options)
	    & SBC_OPTIONS_MASK);

	/*
	 * Set up offsets to 5380 registers and GLUE I/O space, and turn
	 * off options we know we can't support on certain models.
	 */
	switch (current_mac_model->machineid) {
	case MACH_MACIIFX:	/* Note: the IIfx isn't (yet) supported. */
		sc->sc_regs = (struct sbc_regs *)(SCSIBase + SBC_REG_OFS_IIFX);
		sc->sc_drq_addr = (vm_offset_t)(SCSIBase + SBC_HSK_OFS_IIFX);
		sc->sc_nodrq_addr = (vm_offset_t)(SCSIBase + SBC_DMA_OFS_IIFX);
		sc->sc_options &= ~(SBC_INTR | SBC_RESELECT);
		break;
	case MACH_MACPB500:
		sc->sc_regs = (struct sbc_regs *)(SCSIBase + SBC_REG_OFS);
		sc->sc_drq_addr = (vm_offset_t)(SCSIBase + SBC_HSK_OFS); /*??*/
		sc->sc_nodrq_addr = (vm_offset_t)(SCSIBase + SBC_DMA_OFS_PB500);
		sc->sc_options &= ~(SBC_INTR | SBC_RESELECT);
		break;
	case MACH_MACPB210:
	case MACH_MACPB230:
	case MACH_MACPB250:
	case MACH_MACPB270:
	case MACH_MACPB280:
	case MACH_MACPB280C:
		if (ncr_sc->sc_dev.dv_unit == 1) {
			sc->sc_regs = (struct sbc_regs *)(0xfee00000 + SBC_REG_OFS_DUO2);
			sc->sc_drq_addr = (vm_offset_t)(0xfee00000 + SBC_HSK_OFS_DUO2);
			sc->sc_nodrq_addr = (vm_offset_t)(0xfee00000 + SBC_DMA_OFS_DUO2);
			break;
		}
		/*FALLTHROUGH*/
	default:
		sc->sc_regs = (struct sbc_regs *)(SCSIBase + SBC_REG_OFS);
		sc->sc_drq_addr = (vm_offset_t)(SCSIBase + SBC_HSK_OFS);
		sc->sc_nodrq_addr = (vm_offset_t)(SCSIBase + SBC_DMA_OFS);
		break;
	}

	/*
	 * Fill in the prototype scsi_link.
	 */
	ncr_sc->sc_link.adapter_softc = sc;
	ncr_sc->sc_link.adapter_target = 7;
	ncr_sc->sc_link.adapter = &sbc_ops;
	ncr_sc->sc_link.device = &sbc_dev;

	/*
	 * Initialize fields used by the MI code
	 */
	ncr_sc->sci_r0 = &sc->sc_regs->sci_pr0.sci_reg;
	ncr_sc->sci_r1 = &sc->sc_regs->sci_pr1.sci_reg;
	ncr_sc->sci_r2 = &sc->sc_regs->sci_pr2.sci_reg;
	ncr_sc->sci_r3 = &sc->sc_regs->sci_pr3.sci_reg;
	ncr_sc->sci_r4 = &sc->sc_regs->sci_pr4.sci_reg;
	ncr_sc->sci_r5 = &sc->sc_regs->sci_pr5.sci_reg;
	ncr_sc->sci_r6 = &sc->sc_regs->sci_pr6.sci_reg;
	ncr_sc->sci_r7 = &sc->sc_regs->sci_pr7.sci_reg;

	/*
	 * MD function pointers used by the MI code.
	 */
	if (sc->sc_options & SBC_PDMA) {
		ncr_sc->sc_pio_out   = sbc_pdma_out;
		ncr_sc->sc_pio_in    = sbc_pdma_in;
	} else {
		ncr_sc->sc_pio_out   = ncr5380_pio_out;
		ncr_sc->sc_pio_in    = ncr5380_pio_in;
	}
	ncr_sc->sc_dma_alloc = NULL;
	ncr_sc->sc_dma_free  = NULL;
	ncr_sc->sc_dma_poll  = NULL;
	ncr_sc->sc_intr_on   = NULL;
	ncr_sc->sc_intr_off  = NULL;
	ncr_sc->sc_dma_setup = NULL;
	ncr_sc->sc_dma_start = NULL;
	ncr_sc->sc_dma_eop   = NULL;
	ncr_sc->sc_dma_stop  = NULL;
	ncr_sc->sc_flags = 0;
	ncr_sc->sc_min_dma_len = MIN_DMA_LEN;

	if (sc->sc_options & SBC_INTR) {
		if (sc->sc_options & SBC_RESELECT)
			ncr_sc->sc_flags |= NCR5380_PERMIT_RESELECT;
		ncr_sc->sc_dma_alloc = sbc_dma_alloc;
		ncr_sc->sc_dma_free  = sbc_dma_free;
		ncr_sc->sc_dma_poll  = sbc_dma_poll;
		ncr_sc->sc_dma_setup = sbc_dma_setup;
		ncr_sc->sc_dma_start = sbc_dma_start;
		ncr_sc->sc_dma_eop   = sbc_dma_eop;
		ncr_sc->sc_dma_stop  = sbc_dma_stop;
		mac68k_register_scsi_drq(sbc_drq_intr, ncr_sc);
		mac68k_register_scsi_irq(sbc_irq_intr, ncr_sc);
	} else
		ncr_sc->sc_flags |= NCR5380_FORCE_POLLING;

	/*
	 * Initialize fields used only here in the MD code.
	 */
	if (VIA2 == VIA2OFF) {
		sc->sc_ienable = Via1Base + VIA2 * 0x2000 + vIER;
		sc->sc_iflag   = Via1Base + VIA2 * 0x2000 + vIFR;
	} else {
		sc->sc_ienable = Via1Base + VIA2 * 0x2000 + rIER;
		sc->sc_iflag   = Via1Base + VIA2 * 0x2000 + rIFR;
	}

	if (sc->sc_options)
		printf(": options=%s", bitmask_snprintf(sc->sc_options,
		    SBC_OPTIONS_BITS, bits, sizeof(bits)));
	printf("\n");

	/* Now enable SCSI interrupts through VIA2, if appropriate */
	if (sc->sc_options & SBC_INTR)
		sbc_intr_enable(ncr_sc);

#ifdef SBC_DEBUG
	if (sbc_debug)
		printf("%s: softc=%p regs=%p\n", ncr_sc->sc_dev.dv_xname,
		    sc, sc->sc_regs);
	ncr_sc->sc_link.flags |= sbc_link_flags;
#endif

	/*
	 *  Initialize the SCSI controller itself.
	 */
	ncr5380_init(ncr_sc);
	ncr5380_reset_scsibus(ncr_sc);
	config_found(self, &(ncr_sc->sc_link), scsiprint);
}
a184 29

/***
 * Macintosh SCSI interrupt support routines.
 ***/

void
sbc_intr_enable(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	register struct sbc_softc *sc = (struct sbc_softc *) ncr_sc;
	int s;

	s = splhigh();
	*sc->sc_ienable = 0x80 | (V2IF_SCSIIRQ | V2IF_SCSIDRQ);
	splx(s);
}

void
sbc_intr_disable(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	register struct sbc_softc *sc = (struct sbc_softc *) ncr_sc;
	int s;

	s = splhigh();
	*sc->sc_ienable = (V2IF_SCSIIRQ | V2IF_SCSIDRQ);
	splx(s);
}

d254 1
a254 1
static	int
d331 1
a331 1
static	int
d775 2
a776 1
		*sc->sc_iflag = 0x80 | (V2IF_SCSIIRQ | V2IF_SCSIDRQ);
d783 2
a784 1
		*sc->sc_iflag = 0x80 | (V2IF_SCSIIRQ | V2IF_SCSIDRQ);
d842 2
a843 1
		*sc->sc_iflag = 0x80 | V2IF_SCSIIRQ;
@


1.6
log
@Use scsiprint (and remove scsiprint from esp.c).
@
text
@d1 2
a2 2
/*	$OpenBSD: sbc.c,v 1.5 1996/11/23 21:45:55 kstailey Exp $	*/
/*	$NetBSD: sbc.c,v 1.9 1996/06/19 01:47:28 scottr Exp $	*/
d92 1
a93 1
#define	SBC_DMA_OFS		0x12000
d98 1
d100 4
a103 1
#define	SBC_DMA_OFS_IIFX	0x0c000
d169 1
a169 1
static	int	sbc_match __P((struct device *, void *, void *));
d221 1
a221 1
sbc_match(parent, match, args)
d223 2
a224 1
	void *match, *args;
d226 17
a242 3
	if (!mac68k_machine.scsi80)
		return 0;
	return 1;
d252 1
d276 13
d365 2
a366 1
		printf(": options=%b", sc->sc_options, SBC_OPTIONS_BITS);
d784 1
d786 1
d821 2
a822 1
		}
d894 1
d908 1
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.4 1996/10/28 14:46:22 briggs Exp $	*/
d351 1
a351 11
	config_found(self, &(ncr_sc->sc_link), sbc_print);
}

static int
sbc_print(aux, name)
	void *aux;
	const char *name;
{
	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
@


1.4
log
@Include macinfo.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.3 1996/06/23 16:06:32 briggs Exp $	*/
d167 1
a167 1
static	int	sbc_print __P((void *, char *));
d357 1
a357 1
	char *name;
@


1.3
log
@From scottr/NetBSD:
Update some comments, and the copyright

Deal with interrupt flags more carefully, and use the correct offset
for PB500-series SCSI I/O.  While I'm here, update the copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbc.c,v 1.2 1996/06/08 16:21:12 briggs Exp $	*/
d70 1
@


1.2
log
@Sync up with latest NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: sbc.c,v 1.1 1996/05/26 19:02:09 briggs Exp $	*/
/*	$NetBSD: sbc.c,v 1.7 1996/05/29 14:26:33 scottr Exp $	*/
a5 2
 * Copyright (c) 1995 David Jones
 * Copyright (c) 1995 Allen Briggs
d19 2
a20 3
 *    must display the following acknowledgement:
 *      This product includes software developed by David Jones, Allen
 *	Briggs and Scott Reynolds.
d45 5
a49 7
 * (mac68k), David Jones (sun3), and Leo Weppelman (atari).  Allen
 * supplied some crucial interpretation of the NetBSD 1.1 'ncrscsi'
 * driver.  Allen, Gordon W. Ross, and Jason Thorpe all helped to
 * refine this code, and were considerable sources of moral support.
 *
 * The sbc_options code is based on similar code in Jason's modified
 * NetBSD/sparc 'si' driver.
d69 1
d87 1
a87 1
 * From Guide to the Macintosh Family Hardware, p. 137
d90 9
a98 3
#define	SBC_REGISTER_OFFSET	0x10000
#define	SBC_DMA_DRQ_OFFSET	0x06000
#define	SBC_DMA_NODRQ_OFFSET	0x12000
d125 1
d137 5
a141 5
	volatile long	*sc_drq_addr;
	volatile u_char	*sc_nodrq_addr;
	volatile u_char	*sc_ienable;
	volatile u_char	*sc_iflag;
	int		sc_options;	/* options for this instance. */
d153 3
d239 2
a240 1
	 * Set up base address of 5380
d242 19
a260 1
	sc->sc_regs = (struct sbc_regs *)(SCSIBase + SBC_REGISTER_OFFSET);
d285 7
a291 2
	ncr_sc->sc_pio_out   = sbc_pdma_out;
	ncr_sc->sc_pio_in    = sbc_pdma_in;
d304 1
a304 3
	if ((sc->sc_options & SBC_INTR) == 0) {
		ncr_sc->sc_flags |= NCR5380_FORCE_POLLING;
	} else {
d316 2
a317 1
	}
a321 2
	sc->sc_drq_addr = (long *) (SCSIBase + SBC_DMA_DRQ_OFFSET);
	sc->sc_nodrq_addr = (u_char *) (SCSIBase + SBC_DMA_NODRQ_OFFSET);
d535 1
d548 2
a549 2
	register volatile long *long_data = sc->sc_drq_addr;
	register volatile u_char *byte_data = sc->sc_nodrq_addr;
d625 2
a626 2
	register volatile long *long_data = sc->sc_drq_addr;
	register volatile u_char *byte_data = sc->sc_nodrq_addr;
d759 1
d782 9
a790 2
		count = ((  (u_long) mac68k_buserr_addr
			  - (u_long) sc->sc_drq_addr));
d792 2
a793 4
		if ((count < 0) || (count > dh->dh_len)) {
			printf("%s: complete=0x%x (pending 0x%x)\n",
			    ncr_sc->sc_dev.dv_xname, count, dh->dh_len);
			panic("something is wrong");
d795 1
d798 2
a799 2
			printf("%s: drq /berr, pending=0x%x, complete=0x%x\n",
			   ncr_sc->sc_dev.dv_xname, dh->dh_len, count);
a800 3

		dh->dh_addr += count;
		dh->dh_len -= count;
d807 1
a807 1
#ifdef notyet
d814 1
d816 1
a816 1
			drq = (u_int8_t *) sc->sc_drq_addr;
d827 1
a827 1
		 * Get ready to start the transfer.
d846 4
a849 9
#define W1		*drq++ = *data++
			while (count) {
				W1; count--;
			}
#undef W1
			dh->dh_len -= dcount;
			dh->dh_addr += dcount;
		}
#else
d854 2
d864 1
a864 5
#endif

		/* Wait for the GLUE to raise /ACK */
		while ((*ncr_sc->sci_csr & SCI_CSR_ACK) == 0)
			;
d867 3
a869 2
		 * If the SCSI bus is still busy, trigger a bus error
		 * by writing another byte to the SBC.
d871 8
a878 3
		if (*ncr_sc->sci_bus_csr & SCI_BUS_BSY)
			*((u_int8_t *) sc->sc_drq_addr) = 0;

d887 2
a888 1
			drq = (u_int8_t *) sc->sc_drq_addr;
d899 1
a899 1
		 * Get ready to start the transfer.
d903 1
a904 1
			long_data = (u_int32_t *) dh->dh_addr;
d907 1
a907 8
			while (count >= 512) {
				if ((*ncr_sc->sci_csr & SCI_CSR_DREQ) == 0) {
					nofault = (int *) 0;

					dh->dh_addr += (dcount - count);
					dh->dh_len -= (dcount - count);
					return;
				}
d910 1
a910 15
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;	/* 128 */
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;	/* 256 */
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;
				R4; R4; R4; R4; R4; R4; R4; R4;	/* 512 */
				count -= 512;
d917 2
a918 1
			drq = (u_int8_t *) long_drq;
d927 1
a962 6
#ifndef SBCTEST
	/* XXX - we don't trust PDMA writes yet! */
	if (xs->flags & SCSI_DATA_OUT)
		return;
#endif

d1121 1
a1121 1
		*sc->sc_iflag = 0x80 | (V2IF_SCSIIRQ | V2IF_SCSIDRQ);
@


1.1
log
@Missed a few files in the previous updates.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sbc.c,v 1.6 1996/05/08 03:44:56 scottr Exp $	*/
d753 2
a754 2
		count = (  (u_long) mac68k_buserr_addr
			 - (u_long) sc->sc_drq_addr);
d775 1
d821 26
d921 7
d1037 1
d1042 2
a1043 2
	 * Match bus phase, set DMA mode, and assert data bus (for
	 * writing only), then start the transfer.
d1048 1
d1055 1
d1080 1
d1113 1
@
