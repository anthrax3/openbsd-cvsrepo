head	1.21;
access;
symbols
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.12
	OPENBSD_5_0:1.20.0.10
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.8
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.6
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.10
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.8
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.12.0.20
	OPENBSD_2_9_BASE:1.12
	NIKLAS_UNDEAD:1.12.0.18
	OPENBSD_2_8:1.12.0.16
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.14
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.12
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.10
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.8
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.6
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11;
locks; strict;
comment	@ * @;


1.21
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.20;

1.20
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.10.20.29.46;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.23.04.10.13;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.26.21.09.35;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.22.20.15.55;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.04.08.52.45;	author niklas;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	97.06.18.02.59.28;	author denny;	state Exp;
branches
	1.12.12.1;
next	1.11;

1.11
date	97.05.01.18.32.48;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.04.22.13.37.56;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.04.14.00.45.41;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.04.13.16.44.01;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.04.13.14.14.51;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	97.04.10.00.17.42;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	97.04.08.04.14.46;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	97.03.29.23.26.49;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	97.03.17.04.16.59;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	97.03.14.14.11.35;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	97.03.12.13.20.32;	author briggs;	state Exp;
branches;
next	;

1.12.12.1
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.12.12.2;

1.12.12.2
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.12.12.3;

1.12.12.3
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*    $OpenBSD: if_sn_nubus.c,v 1.20 2009/03/29 21:53:52 sthen Exp $  */
/*    $NetBSD: if_sn_nubus.c,v 1.13 1997/05/11 19:11:34 scottr Exp $  */
/*
 * Copyright (C) 1997 Allen Briggs
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Allen Briggs
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/systm.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <machine/bus.h>
#include <machine/viareg.h>

#include <mac68k/dev/nubus.h>
#include <mac68k/dev/if_snreg.h>
#include <mac68k/dev/if_snvar.h>

#define	INTERFACE_NAME_LEN	32

static int	sn_nubus_match(struct device *, void *, void *);
static void	sn_nubus_attach(struct device *, struct device *, void *);
static int	sn_nb_card_vendor(bus_space_tag_t, bus_space_handle_t,
		    struct nubus_attach_args *);

struct cfattach sn_nubus_ca = {
	sizeof(struct sn_softc), sn_nubus_match, sn_nubus_attach
};


static int
sn_nubus_match(struct device *parent, void *cf, void *aux)
{
	struct nubus_attach_args *na = (struct nubus_attach_args *) aux;
	bus_space_handle_t bsh;
	int rv;

	if (bus_space_map(na->na_tag,
	    NUBUS_SLOT2PA(na->slot), NBMEMSIZE, 0, &bsh))
		return (0);

	rv = 0;

	if (na->category == NUBUS_CATEGORY_NETWORK &&
	    na->type == NUBUS_TYPE_ETHERNET) {
		switch (sn_nb_card_vendor(na->na_tag, bsh, na)) {
		default:
			break;

		case SN_VENDOR_APPLE:
		case SN_VENDOR_APPLE16:
		case SN_VENDOR_ASANTELC:
		case SN_VENDOR_DAYNA:
			rv = 1;
			break;
		}
	}

	bus_space_unmap(na->na_tag, bsh, NBMEMSIZE);

	return (rv);
}

/*
 * Install interface into kernel networking data structures
 */
static void
sn_nubus_attach(struct device *parent, struct device *self, void *aux)
{
	struct sn_softc *sc = (void *)self;
	struct nubus_attach_args *na = (struct nubus_attach_args *)aux;
	int i, success, offset;
	bus_space_tag_t	bst;
	bus_space_handle_t bsh, tmp_bsh;
	u_int8_t myaddr[ETHER_ADDR_LEN];
	char cardtype[INTERFACE_NAME_LEN];	/* type string */

	(void)(&offset);	/* Work around lame gcc initialization bug */

	bst = na->na_tag;
	if (bus_space_map(bst, NUBUS_SLOT2PA(na->slot), NBMEMSIZE, 0, &bsh)) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_regt = bst;

	strncpy(cardtype, nubus_get_card_name(bst, bsh, na->fmt),
	    INTERFACE_NAME_LEN);

	success = 0;

	sc->slotno = na->slot;

	switch (sn_nb_card_vendor(bst, bsh, na)) {
	case SN_VENDOR_DAYNA:
		sc->snr_dcr = DCR_ASYNC | DCR_WAIT0 |
		    DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
		sc->snr_dcr2 = 0;
		sc->bitmode = 1;	/* 32 bit card */

		if (bus_space_subregion(bst, bsh,
		    0x00180000, SN_REGSIZE, &sc->sc_regh)) {
			printf(": can't map register space\n");
			break;
		}

		if (bus_space_subregion(bst, bsh,
		    0x00ffe004, ETHER_ADDR_LEN, &tmp_bsh)) {
			printf(": can't map ROM space\n");
			break;
		}

		sn_get_enaddr(bst, tmp_bsh, 0, myaddr);

		offset = 2;
		success = 1;
		break;

	case SN_VENDOR_APPLE:
		sc->snr_dcr = DCR_ASYNC | DCR_WAIT0 |
		    DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
		sc->snr_dcr2 = 0;
		sc->bitmode = 1; /* 32 bit card */

		if (bus_space_subregion(bst, bsh,
		    0x0, SN_REGSIZE, &sc->sc_regh)) {
			printf(": failed to map register space.\n");
			break;
		}

		if (bus_space_subregion(bst, bsh,
		    0x40000, ETHER_ADDR_LEN, &tmp_bsh)) {
			printf(": failed to map ROM space.\n");
			break;
		}

		sn_get_enaddr(bst, tmp_bsh, 0, myaddr);

		offset = 0;
		success = 1;
		break;

	case SN_VENDOR_APPLE16:
		sc->snr_dcr = DCR_ASYNC | DCR_WAIT0 | DCR_EXBUS |
			DCR_DMABLOCK | DCR_PO1 | DCR_RFT16 | DCR_TFT16;
		sc->snr_dcr2 = 0;
		sc->bitmode = 0; /* 16 bit card */

		if (bus_space_subregion(bst, bsh,
		    0x0, SN_REGSIZE, &sc->sc_regh)) {
			printf(": failed to map register space.\n");
			break;
		}

		if (bus_space_subregion(bst, bsh,
		    0x40000, ETHER_ADDR_LEN, &tmp_bsh)) {
			printf(": failed to map ROM space.\n");
			break;
		}

		sn_get_enaddr(bst, tmp_bsh, 0, myaddr);

		offset = 0;
		success = 1;
		break;

	case SN_VENDOR_ASANTELC: /* Macintosh LC Ethernet Adapter */
		sc->snr_dcr = DCR_ASYNC | DCR_WAIT0 |
			DCR_DMABLOCK | DCR_PO1 | DCR_RFT16 | DCR_TFT16;
		sc->snr_dcr2 = 0;
		sc->bitmode = 0; /* 16 bit card */

		if (bus_space_subregion(bst, bsh,
		    0x0, SN_REGSIZE, &sc->sc_regh)) {
			printf(": failed to map register space.\n");
			break;
		}

		if (bus_space_subregion(bst, bsh,
		    0x400000, ETHER_ADDR_LEN, &tmp_bsh)) {
			printf(": failed to map ROM space.\n");
			break;
		}

		sn_get_enaddr(bst, tmp_bsh, 0, myaddr);

		offset = 0;
		success = 1;
		break;

	default:
		/*
		 * You can't actually get this default, the snmatch
		 * will fail for unknown hardware. If you're adding support
		 * for a new card, the following defaults are a
		 * good starting point.
		 */
		sc->snr_dcr = DCR_SYNC | DCR_WAIT0 | DCR_DW32 |
		    DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
		sc->snr_dcr2 = 0;
		success = 0;
		printf(": unknown card: attachment incomplete.\n");
	}

	if (!success) {
		bus_space_unmap(bst, bsh, NBMEMSIZE);
		return;
	}

	/* Regs are addressed as words, big endian. */
	for (i = 0; i < SN_NREGS; i++) {
		sc->sc_reg_map[i] = (bus_size_t)((i * 4) + offset);
	}

	printf(": %s, ", cardtype);

	/* snsetup returns 1 if something fails */
	if (snsetup(sc, myaddr)) {
		bus_space_unmap(bst, bsh, NBMEMSIZE);
		return;
	}

	add_nubus_intr(sc->slotno, IPL_NET, snintr, sc, sc->sc_dev.dv_xname);
}

static int
sn_nb_card_vendor(bus_space_tag_t bst, bus_space_handle_t bsh,
    struct nubus_attach_args *na)
{
	int vendor = SN_VENDOR_UNKNOWN;

	switch (na->drsw) {
	case NUBUS_DRSW_3COM:
		if (na->drhw == NUBUS_DRHW_APPLE_SNT)
			vendor = SN_VENDOR_APPLE;
		else if (na->drhw == NUBUS_DRHW_APPLE_SN)
			vendor = SN_VENDOR_APPLE16;
		break;
	case NUBUS_DRSW_APPLE:
		if (na->drhw == NUBUS_DRHW_ASANTE_LC)
			vendor = SN_VENDOR_ASANTELC;
		else
			vendor = SN_VENDOR_APPLE;
		break;
	case NUBUS_DRSW_TECHWORKS:
		vendor = SN_VENDOR_APPLE;
		break;
	case NUBUS_DRSW_GATOR:
		if (na->drhw == NUBUS_DRHW_KINETICS &&
		    strncmp(nubus_get_card_name(bst, bsh, na->fmt),
		    "EtherPort", 9) != 0)
			vendor = SN_VENDOR_DAYNA;
		break;
	case NUBUS_DRSW_DAYNA:
		vendor = SN_VENDOR_DAYNA;
		break;
	}

	return (vendor);
}
@


1.20
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.19 2007/09/10 20:29:46 miod Exp $  */
@


1.19
log
@Pass a real ipl level to add_nubus_intr(), and make sure the interrupt
handler is invoked with spl raised to the given level, otherwise all nubus
interrupts are processed at level 2.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.18 2006/03/23 04:10:13 brad Exp $  */
d118 1
a118 1
		printf(": failed to map memory space.\n");
d140 1
a140 1
			printf(": failed to map register space.\n");
d146 1
a146 1
			printf(": failed to map ROM space.\n");
@


1.18
log
@ANSI and KNF.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.17 2005/04/26 21:09:35 martin Exp $  */
d260 1
a260 1
	add_nubus_intr(sc->slotno, snintr, sc, sc->sc_dev.dv_xname);
@


1.17
log
@new NuBus slot space mapping/probing code utilizing bus_space(9)

ok miod@@

from NetBSD
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.16 2004/11/26 21:21:24 miod Exp $  */
d68 1
a68 4
sn_nubus_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d97 1
a97 1
	return rv;
d104 1
a104 3
sn_nubus_attach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
d264 2
a265 4
sn_nb_card_vendor(bst, bsh, na)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	struct nubus_attach_args *na;
d296 1
a296 1
	return vendor;
@


1.16
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.15 2002/04/22 20:15:55 miod Exp $  */
d129 1
a129 1
	strncpy(cardtype, nubus_get_card_name(na->fmt),
d294 1
a294 1
		    strncmp(nubus_get_card_name(na->fmt),
@


1.15
log
@Bring several stability and performance fixes from NetBSD, as well as
more hardware support.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.14 2002/03/14 01:26:35 millert Exp $  */
d265 1
a265 1
	add_nubus_intr(sc->slotno, snintr, (void *)sc);
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.13 2001/07/04 08:52:45 niklas Exp $  */
d51 5
a55 3
#include "nubus.h"
#include "if_snreg.h"
#include "if_snvar.h"
d90 2
a92 1
		case SN_VENDOR_APPLE16:
d117 1
d129 3
d209 24
d257 2
a265 2

	return;
d278 1
a278 1
		if (na->drhw == NUBUS_DRHW_APPLE_SN)
d280 1
a280 1
		else if (na->drhw == NUBUS_DRHW_APPLE_SNT)
d284 5
@


1.13
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.13 1997/05/11 19:11:34 scottr Exp $  */
d55 4
a58 4
static int	sn_nubus_match __P((struct device *, void *, void *));
static void	sn_nubus_attach __P((struct device *, struct device *, void *));
static int	sn_nb_card_vendor __P((bus_space_tag_t, bus_space_handle_t,
		    struct nubus_attach_args *));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn_nubus.c,v 1.13 2001/07/04 08:52:45 niklas Exp $  */
d51 8
a58 10
#include <mac68k/dev/nubus.h>
#include <mac68k/dev/if_snreg.h>
#include <mac68k/dev/if_snvar.h>

#define	INTERFACE_NAME_LEN	32

static int	sn_nubus_match(struct device *, void *, void *);
static void	sn_nubus_attach(struct device *, struct device *, void *);
static int	sn_nb_card_vendor(bus_space_tag_t, bus_space_handle_t,
		    struct nubus_attach_args *);
d88 1
a89 2
		case SN_VENDOR_ASANTELC:
		case SN_VENDOR_DAYNA:
a113 1
	char cardtype[INTERFACE_NAME_LEN];	/* type string */
a124 3
	strncpy(cardtype, nubus_get_card_name(na->fmt),
	    INTERFACE_NAME_LEN);

a201 24
	case SN_VENDOR_ASANTELC: /* Macintosh LC Ethernet Adapter */
		sc->snr_dcr = DCR_ASYNC | DCR_WAIT0 |
			DCR_DMABLOCK | DCR_PO1 | DCR_RFT16 | DCR_TFT16;
		sc->snr_dcr2 = 0;
		sc->bitmode = 0; /* 16 bit card */

		if (bus_space_subregion(bst, bsh,
		    0x0, SN_REGSIZE, &sc->sc_regh)) {
			printf(": failed to map register space.\n");
			break;
		}

		if (bus_space_subregion(bst, bsh,
		    0x400000, ETHER_ADDR_LEN, &tmp_bsh)) {
			printf(": failed to map ROM space.\n");
			break;
		}

		sn_get_enaddr(bst, tmp_bsh, 0, myaddr);

		offset = 0;
		success = 1;
		break;

a225 2
	printf(": %s, ", cardtype);

d233 2
d247 1
a247 1
		if (na->drhw == NUBUS_DRHW_APPLE_SNT)
d249 1
a249 1
		else if (na->drhw == NUBUS_DRHW_APPLE_SN)
a252 5
		if (na->drhw == NUBUS_DRHW_ASANTE_LC)
			vendor = SN_VENDOR_ASANTELC;
		else
			vendor = SN_VENDOR_APPLE;
		break;
@


1.12
log
@Make if_sn.c far more MI, eventually share with pica.
sonic_get is faster and simpler.
sn_ioctl works like other current ether drivers now.
Sync up with netbsd to ease maintenance; incorporate some "gratuitous" formatting changes so I won't have to do two totally seperate mods each time.
@
text
@d1 1
@


1.12.12.1
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*    $OpenBSD$  */
@


1.12.12.2
log
@Merge in -current from about a week ago
@
text
@d55 4
a58 4
static int	sn_nubus_match(struct device *, void *, void *);
static void	sn_nubus_attach(struct device *, struct device *, void *);
static int	sn_nb_card_vendor(bus_space_tag_t, bus_space_handle_t,
		    struct nubus_attach_args *);
@


1.12.12.3
log
@Sync the SMP branch with 3.3
@
text
@d51 3
a53 5
#include <mac68k/dev/nubus.h>
#include <mac68k/dev/if_snreg.h>
#include <mac68k/dev/if_snvar.h>

#define	INTERFACE_NAME_LEN	32
d88 1
a89 2
		case SN_VENDOR_ASANTELC:
		case SN_VENDOR_DAYNA:
a113 1
	char cardtype[INTERFACE_NAME_LEN];	/* type string */
a124 3
	strncpy(cardtype, nubus_get_card_name(na->fmt),
	    INTERFACE_NAME_LEN);

a201 24
	case SN_VENDOR_ASANTELC: /* Macintosh LC Ethernet Adapter */
		sc->snr_dcr = DCR_ASYNC | DCR_WAIT0 |
			DCR_DMABLOCK | DCR_PO1 | DCR_RFT16 | DCR_TFT16;
		sc->snr_dcr2 = 0;
		sc->bitmode = 0; /* 16 bit card */

		if (bus_space_subregion(bst, bsh,
		    0x0, SN_REGSIZE, &sc->sc_regh)) {
			printf(": failed to map register space.\n");
			break;
		}

		if (bus_space_subregion(bst, bsh,
		    0x400000, ETHER_ADDR_LEN, &tmp_bsh)) {
			printf(": failed to map ROM space.\n");
			break;
		}

		sn_get_enaddr(bst, tmp_bsh, 0, myaddr);

		offset = 0;
		success = 1;
		break;

a225 2
	printf(": %s, ", cardtype);

d233 2
d247 1
a247 1
		if (na->drhw == NUBUS_DRHW_APPLE_SNT)
d249 1
a249 1
		else if (na->drhw == NUBUS_DRHW_APPLE_SN)
a252 5
		if (na->drhw == NUBUS_DRHW_ASANTE_LC)
			vendor = SN_VENDOR_ASANTELC;
		else
			vendor = SN_VENDOR_APPLE;
		break;
@


1.11
log
@Treat drhw 118 and 119 the same for Apple ethernet cards.
@
text
@d1 1
a1 3
/*	$OpenBSD: if_sn_nubus.c,v 1.10 1997/04/22 13:37:56 briggs Exp $	*/
/*	$NetBSD: if_sn_nubus.c,v 1.12 1997/05/01 18:17:13 briggs Exp $	*/

d42 1
d45 1
a50 1
#include "if_aereg.h"	/* For AE_VENDOR values */
d56 2
a57 1
static int	sn_nb_card_vendor __P((struct nubus_attach_args *));
d63 1
d65 1
a65 1
sn_nubus_match(parent, vcf, aux)
d67 1
a67 1
	void *vcf;
d74 2
a75 2
	if (bus_space_map(na->na_tag, NUBUS_SLOT2PA(na->slot), NBMEMSIZE,
	    0, &bsh))
d82 3
a84 1
		switch (sn_nb_card_vendor(na)) {
d86 3
a88 2
		case AE_VENDOR_APPLE:
		case AE_VENDOR_DAYNA:
a90 3

		default:
			break;
d107 3
a109 3
        struct sn_softc *sc = (void *)self;
        struct nubus_attach_args *na = (struct nubus_attach_args *)aux;
	int		i, success, offset;
d111 4
a114 1
	bus_space_handle_t	bsh, tmp_bsh;
a122 1
	sc->bitmode = 1;
d126 1
a126 2
        sc->bitmode = 1;		/* 32-bit card */
        sc->slotno = na->slot;
d128 4
a131 4
        switch (sn_nb_card_vendor(na)) {
	case AE_VENDOR_DAYNA:
                sc->snr_dcr = DCR_ASYNC | DCR_WAIT0 | DCR_DW32 |
			DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
d133 1
d135 2
a136 2
		if (bus_space_subregion(bst, bsh, 0x00180000, SN_REGSIZE,
					&sc->sc_regh)) {
d141 2
a142 2
		if (bus_space_subregion(bst, bsh, 0x00ffe004, ETHER_ADDR_LEN,
					&tmp_bsh)) {
d147 1
a147 1
		sn_get_enaddr(bst, tmp_bsh, 0, sc->sc_arpcom.ac_enaddr);
d151 1
a151 1
                break;
d153 3
a155 3
	case AE_VENDOR_APPLE:
                sc->snr_dcr = DCR_ASYNC | DCR_WAIT0 | DCR_DW32 |
			DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
d157 1
d159 2
a160 2
		if (bus_space_subregion(bst, bsh, 0x0, SN_REGSIZE,
					&sc->sc_regh)) {
d165 2
a166 2
		if (bus_space_subregion(bst, bsh, 0x40000, ETHER_ADDR_LEN,
					&tmp_bsh)) {
d171 1
a171 1
		sn_get_enaddr(bst, tmp_bsh, 0, sc->sc_arpcom.ac_enaddr);
d175 1
a175 1
                break;
d177 3
a179 9
        default:
                /*
                 * You can't actually get this default, the snmatch
                 * will fail for unknown hardware. If you're adding support
                 * for a new card, the following defaults are a
                 * good starting point.
                 */
                sc->snr_dcr = DCR_SYNC | DCR_WAIT0 | DCR_DW32 |
			DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
d181 16
d198 13
d213 1
a213 1
        }
a219 1
	snsetup(sc);
d226 1
a226 1
	if (snsetup(sc)) {
d237 3
a239 1
sn_nb_card_vendor(na)
d242 1
a242 1
	int vendor;
d246 4
a249 9
		switch (na->drhw) {
		case NUBUS_DRHW_APPLE_SN:
		case NUBUS_DRHW_APPLE_SNT:
			vendor = AE_VENDOR_APPLE;
			break;
		default:
			vendor = AE_VENDOR_UNKNOWN;
			break;
		}
d253 1
a253 10
		vendor = AE_VENDOR_APPLE;
		break;
	case NUBUS_DRSW_ASANTE:
		vendor = AE_VENDOR_ASANTE;
		break;
	case NUBUS_DRSW_FARALLON:
		vendor = AE_VENDOR_FARALLON;
		break;
	case NUBUS_DRSW_FOCUS:
		vendor = AE_VENDOR_FOCUS;
d256 4
a259 13
		switch (na->drhw) {
		default:
		case NUBUS_DRHW_INTERLAN:
			vendor = AE_VENDOR_INTERLAN;
			break;
		case NUBUS_DRHW_KINETICS:
			if (strncmp(
			    nubus_get_card_name(na->fmt), "EtherPort", 9) == 0)
				vendor = AE_VENDOR_KINETICS;
			else
				vendor = AE_VENDOR_DAYNA;
			break;
		}
d262 1
a262 1
		vendor = AE_VENDOR_DAYNA;
a263 5
	default:
#ifdef DIAGNOSTIC
		printf("Unknown ethernet drsw: %x\n", na->drsw);
#endif
		vendor = AE_VENDOR_UNKNOWN;
d265 1
@


1.10
log
@Some minor cleanup.
@
text
@d1 2
a2 1
/*	$OpenBSD: if_sn_nubus.c,v 1.9 1997/04/14 00:45:41 briggs Exp $	*/
d220 1
@


1.9
log
@Use an offset parameter when loading the reg_map--some cards use the "other"
16 bits of the words.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_nubus.c,v 1.8 1997/04/13 16:44:01 briggs Exp $	*/
d182 3
a184 2
		printf(": attachment incomplete.\n");
                return;
@


1.8
log
@Oops.  We do not want to unmap something that we've used bus_space_subregion
to get.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_nubus.c,v 1.7 1997/04/13 14:14:51 briggs Exp $	*/
d107 1
a107 1
	int		i, success;
d145 1
d168 1
d194 1
a194 1
		sc->sc_reg_map[i] = (bus_size_t)((i * 4) + 2);
@


1.7
log
@Some updates based on information from Bob Nestor <rnestor@@metronet.com>
about his SONIC-T LC/PDS card.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_nubus.c,v 1.6 1997/04/10 00:17:42 briggs Exp $	*/
a144 2
		bus_space_unmap(bst, tmp_bsh, ETHER_ADDR_LEN);

a165 2

		bus_space_unmap(bst, tmp_bsh, ETHER_ADDR_LEN);
@


1.6
log
@Ack.  Make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_nubus.c,v 1.5 1997/04/08 04:14:46 briggs Exp $	*/
a56 2
static int	sn_nb_get_enaddr __P((struct nubus_attach_args *,
					u_int8_t *, int));
d143 3
a145 11
		/*
		 * Copy out the ethernet address from the card's ROM
		 *
		 * See if_sn_obio.c for a discussion of bit reversal
		 * in Apple's MAC address PROMs. As far as I can tell
		 * Dayna stores their Mac address in ethernet format,
		 * not Token Ring.
		 */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] =
					bus_space_read_1(bst, tmp_bsh, i);
d155 1
a155 1
		if (bus_space_subregion(bst, bsh, 0x00180000, SN_REGSIZE,
d161 9
a169 1
		sn_nb_get_enaddr(na, sc->sc_arpcom.ac_enaddr, 0x8);
a264 21
}

static int
sn_nb_get_enaddr(na, ep, rsrc1)
	struct nubus_attach_args *na;
	u_int8_t *ep;
	int	rsrc1;
{
	nubus_dir dir;
	nubus_dirent dirent;

	nubus_get_main_dir(na->fmt, &dir);
	if (nubus_find_rsrc(na->fmt, &dir, na->rsrcid, &dirent) <= 0)
		return 1;
	nubus_get_dir_from_rsrc(na->fmt, &dirent, &dir);
	if (nubus_find_rsrc(na->fmt, &dir, rsrc1, &dirent) <= 0)
		return 1;
	if (nubus_get_ind_data(na->fmt, &dirent, ep, ETHER_ADDR_LEN) <= 0)
		return 1;

	return 0;
@


1.5
log
@Some patches from Bob Nestor <rnestor@@metronet.com> to edge toward support
for an Apple SONIC-based ethernet card.  Includes a patch to the nubus
probing that we worked out together.  Some cards, like his, were being
missed and/or probed like video cards\!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_nubus.c,v 1.4 1997/03/29 23:26:49 briggs Exp $	*/
d171 1
a171 1
		sn_nb_get_enaddr(na, sc->sc_arpcom.ac_enaddr, na, 0x8);
@


1.4
log
@Update from Denton Gentry with minor bug fixes by me.
Denny says:
if_sn.c:
        - allocate sc->space using malloc (Scott wanted this).
        - make csr accesses use NIC_PUT/GET, remove sc->sc_csr.
        - add multicast and IFF_PROMISC support. multicast isn't
                well tested, but I made sure the unicast case still
                works.
        - finish the new arp interface, remove sc->sc_enaddr
if_snreg.h:
        - remove struct sonic_reg
if_snvar.h:
        - add NIC_PUT and NIC_GET macros a la if_ae
        - remove sc_txhead, it isn't used.
if_sn_nubus.c:
        - clean up support for my SE/30 card.
        - Move add_nubus_intr from if_sn.c (to keep if_sn.c MI)
if_sn_obio.c:
        - make Q610, C610, Q650, C650, Q800 use EXBUS.
        - PB500 had a "return" where "break" was intended. PB500
                probably wasn't working.
        - move add_nubus_intr from if_sn.c.
        - add an "explanation" why Apple's ethernet addr is encoded
                in token ring format in the PROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_nubus.c,v 1.3 1997/03/17 04:16:59 briggs Exp $	*/
d57 2
a82 3
		default:
			rv = UNSUPP;
			break;
d84 1
a84 1
		/* This is it for now... */
d88 3
d160 16
d186 1
d220 9
d267 21
@


1.3
log
@A couple of cleanup items suggested by is@@netbsd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn_nubus.c,v 1.2 1997/03/14 14:11:35 briggs Exp $	*/
d127 3
a129 2
                sc->s_dcr = DCR_ASYNC | DCR_WAIT0 | DCR_USR1 |
                         DCR_DW32 | DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
d145 5
d165 3
a167 2
                sc->s_dcr = DCR_LBR | DCR_SYNC | DCR_WAIT0 |
                         DCR_DW32 | DCR_DMABLOCK | DCR_RFT16 | DCR_TFT16;
d177 14
d228 3
@


1.2
log
@Updates from Yanagisawa and Denny.  This seems to work.
@
text
@d1 1
a1 2
/*	$NetBSD$	*/
/*	$OpenBSD: if_sn_nubus.c,v 1.1 1997/03/12 13:20:32 briggs Exp $	*/
a42 1
#ifdef INET
a44 1
#endif
a56 2

void	snsetup __P((struct sn_softc *));
@


1.1
log
@Bring in some fresh SONIC code from Dennis Gentry and Yanagisawa Takeshi.
Much hacked by me to merge and partially busify.
Add code that I lost a while back for digging the proper mac address for
internal ethernet.
Still needs work, but checkpointed--works at least as well as the last
version.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d123 1
a123 1
	sc->sc_is16 = 0;
d127 3
a153 1
                sc->slotno = na->slot;
@
