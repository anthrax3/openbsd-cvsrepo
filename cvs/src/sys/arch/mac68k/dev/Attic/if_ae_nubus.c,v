head	1.20;
access;
symbols
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.12
	OPENBSD_5_0:1.19.0.10
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.8
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.26
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.24
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.22
	OPENBSD_2_9_BASE:1.7
	NIKLAS_UNDEAD:1.7.0.20
	OPENBSD_2_8:1.7.0.18
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.16
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.14
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.20
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.19;

1.19
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.10.20.29.46;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.22.13.17.45;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.25.15.07.55;	author martin;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.05.20.27.14;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.26.21.09.35;	author martin;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.04.00.38.37;	author martin;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.08.06.59.43;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.01.21.19.11;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.02.21.01.44;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.05.01.18.32.49;	author briggs;	state Exp;
branches
	1.7.14.1
	1.7.26.1;
next	1.6;

1.6
date	97.04.24.02.17.56;	author gene;	state Exp;
branches;
next	1.5;

1.5
date	97.04.08.04.14.45;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	97.03.25.04.58.43;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	97.03.18.01.02.50;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	97.03.12.13.36.58;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	97.03.08.16.16.53;	author briggs;	state Exp;
branches;
next	;

1.7.14.1
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.7.14.2;

1.7.14.2
date	2004.06.05.23.10.51;	author niklas;	state Exp;
branches;
next	;

1.7.26.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: if_ae_nubus.c,v 1.19 2009/03/29 21:53:52 sthen Exp $	*/
/*	$NetBSD: if_ae_nubus.c,v 1.17 1997/05/01 18:17:16 briggs Exp $	*/

/*
 * Copyright (C) 1997 Scott Reynolds
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Some parts are derived from code adapted for MacBSD by Brad Parker
 * <brad@@fcr.com>.
 *
 * Currently supports:
 *	Apple NB Ethernet Card
 *	Apple NB Ethernet Card II
 *	Interlan A310 NuBus Ethernet card
 *	Cayman Systems GatorCard
 *	Asante MacCon II/E
 *	Kinetics EtherPort SE/30
 */

#define	AE_OLD_GET_ENADDR

#include <sys/param.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/systm.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <machine/bus.h>
#include <machine/viareg.h>

#include <net/if_media.h>

#include <dev/ic/dp8390reg.h>
#include <dev/ic/dp8390var.h>
#include <mac68k/dev/nubus.h>
#include <mac68k/dev/if_aevar.h>
#include <mac68k/dev/if_aereg.h>

static int	ae_nubus_match(struct device *, void *, void *);
static void	ae_nubus_attach(struct device *, struct device *, void *);
static int	ae_nb_card_vendor(bus_space_tag_t, bus_space_handle_t,
		    struct nubus_attach_args *);
static int	ae_nb_get_enaddr(bus_space_tag_t, bus_space_handle_t,
		    struct nubus_attach_args *, u_int8_t *);
#ifdef DEBUG
static void	ae_nb_watchdog(struct ifnet *);
#endif

struct cfattach ae_nubus_ca = {
	sizeof(struct dp8390_softc), ae_nubus_match, ae_nubus_attach
};

static int
ae_nubus_match(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct nubus_attach_args *na = (struct nubus_attach_args *) aux;
	bus_space_handle_t bsh;
	int rv = 0;

	if (bus_space_map(na->na_tag, NUBUS_SLOT2PA(na->slot), NBMEMSIZE,
	    0, &bsh))
		return (0);

	if (na->category == NUBUS_CATEGORY_NETWORK &&
	    na->type == NUBUS_TYPE_ETHERNET) {
		switch (ae_nb_card_vendor(na->na_tag, bsh, na)) {
		case DP8390_VENDOR_APPLE:
		case DP8390_VENDOR_ASANTE:
		case DP8390_VENDOR_FARALLON:
		case DP8390_VENDOR_INTERLAN:
		case DP8390_VENDOR_KINETICS:
		case DP8390_VENDOR_CABLETRON:
			rv = 1;
			break;
		case DP8390_VENDOR_DAYNA:
		case DP8390_VENDOR_FOCUS:
			/* not supported yet */
			/* FALLTHROUGH */
		default:
			rv = 0;
			break;
		}
	}

	bus_space_unmap(na->na_tag, bsh, NBMEMSIZE);

	return (rv);
}

/*
 * Install interface into kernel networking data structures
 */
static void
ae_nubus_attach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
{
	struct dp8390_softc *sc = (struct dp8390_softc *)self;
	struct nubus_attach_args *na = (struct nubus_attach_args *) aux;
#ifdef DEBUG
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
#endif
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	int i, success;
	const char *cardtype;

	bst = na->na_tag;
	if (bus_space_map(bst, NUBUS_SLOT2PA(na->slot), NBMEMSIZE,
	    0, &bsh)) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_regt = sc->sc_buft = bst;
	sc->sc_flags = self->dv_cfdata->cf_flags;

	cardtype = nubus_get_card_name(bst, bsh, na->fmt);

	sc->is790 = 0;

	sc->mem_start = 0;
	sc->mem_size = 0;

	success = 0;

	switch (ae_nb_card_vendor(bst, bsh, na)) {
	case DP8390_VENDOR_APPLE:	/* Apple-compatible cards */
	case DP8390_VENDOR_ASANTE:
		/* Map register offsets */
		for (i = 0; i < 16; i++) /* reverse order, longword aligned */
			sc->sc_reg_map[i] = (15 - i) << 2;

		sc->dcr_reg = (ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
		if (bus_space_subregion(bst, bsh,
		    AE_REG_OFFSET, AE_REG_SIZE, &sc->sc_regh)) {
			printf(": failed to map register space\n");
			break;
		}
		if ((sc->mem_size = ae_size_card_memory(bst, bsh,
		    AE_DATA_OFFSET)) == 0) {
			printf(": failed to determine size of RAM.\n");
			break;
		}
		if (bus_space_subregion(bst, bsh,
		    AE_DATA_OFFSET, sc->mem_size, &sc->sc_bufh)) {
			printf(": failed to map register space\n");
			break;
		}
#ifdef AE_OLD_GET_ENADDR
		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] =
			    bus_space_read_1(bst, bsh, (AE_ROM_OFFSET + i * 2));
#else
		if (ae_nb_get_enaddr(bst, bsh, na, sc->sc_arpcom.ac_enaddr)) {
			printf(": can't find MAC address\n");
			break;
		}
#endif

		success = 1;
		break;

	case DP8390_VENDOR_DAYNA:
		/* Map register offsets */
		for (i = 0; i < 16; i++) /* normal order, longword aligned */
			sc->sc_reg_map[i] = i << 2;

		sc->dcr_reg = (ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
		if (bus_space_subregion(bst, bsh,
		    DP_REG_OFFSET, AE_REG_SIZE, &sc->sc_regh)) {
			printf(": failed to map register space\n");
			break;
		}
		sc->mem_size = 8192;
		if (bus_space_subregion(bst, bsh,
		    DP_DATA_OFFSET, sc->mem_size, &sc->sc_bufh)) {
			printf(": failed to map register space\n");
			break;
		}
#ifdef AE_OLD_GET_ENADDR
		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] =
			    bus_space_read_1(bst, bsh, (DP_ROM_OFFSET + i * 2));
#else
		if (ae_nb_get_enaddr(bst, bsh, na, sc->sc_arpcom.ac_enaddr)) {
			printf(": can't find MAC address\n");
			break;
		}
#endif

	case DP8390_VENDOR_FARALLON:
		/* Map register offsets */
		for (i = 0; i < 16; i++) /* reverse order, longword aligned */
			sc->sc_reg_map[i] = (15 - i) << 2;

		sc->dcr_reg = (ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
		if (bus_space_subregion(bst, bsh,
		    AE_REG_OFFSET, AE_REG_SIZE, &sc->sc_regh)) {
			printf(": failed to map register space\n");
			break;
		}
		if ((sc->mem_size = ae_size_card_memory(bst, bsh,
		    AE_DATA_OFFSET)) == 0) {
			printf(": failed to determine size of RAM.\n");
			break;
		}
		if (bus_space_subregion(bst, bsh,
		    AE_DATA_OFFSET, sc->mem_size, &sc->sc_bufh)) {
			printf(": failed to map register space\n");
			break;
		}
#ifdef AE_OLD_GET_ENADDR
		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] =
			    bus_space_read_1(bst, bsh, (FE_ROM_OFFSET + i));
#endif

		success = 1;
		break;

	case DP8390_VENDOR_INTERLAN:
		/* Map register offsets */
		for (i = 0; i < 16; i++) /* normal order, longword aligned */
			sc->sc_reg_map[i] = i << 2;

		sc->dcr_reg = (ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
		if (bus_space_subregion(bst, bsh,
		    GC_REG_OFFSET, AE_REG_SIZE, &sc->sc_regh)) {
			printf(": failed to map register space\n");
			break;
		}
		if ((sc->mem_size = ae_size_card_memory(bst, bsh,
		    GC_DATA_OFFSET)) == 0) {
			printf(": failed to determine size of RAM.\n");
			break;
		}
		if (bus_space_subregion(bst, bsh,
		    GC_DATA_OFFSET, sc->mem_size, &sc->sc_bufh)) {
			printf(": failed to map register space\n");
			break;
		}

		/* reset the NIC chip */
		bus_space_write_1(bst, bsh, GC_RESET_OFFSET, 0);

		if (ae_nb_get_enaddr(bst, bsh, na, sc->sc_arpcom.ac_enaddr)) {
			/* Fall back to snarf directly from ROM.  Ick.  */
			for (i = 0; i < ETHER_ADDR_LEN; ++i)
				sc->sc_arpcom.ac_enaddr[i] =
				    bus_space_read_1(bst, bsh,
					(GC_ROM_OFFSET + i * 4));
		}

		success = 1;
		break;

	case DP8390_VENDOR_KINETICS:
		/* Map register offsets */
		for (i = 0; i < 16; i++) /* normal order, longword aligned */
			sc->sc_reg_map[i] = i << 2;

		/* sc->use16bit = 0; */
		if (bus_space_subregion(bst, bsh,
		    KE_REG_OFFSET, AE_REG_SIZE, &sc->sc_regh)) {
			printf(": failed to map register space\n");
			break;
		}
		if ((sc->mem_size = ae_size_card_memory(bst, bsh,
		    KE_DATA_OFFSET)) == 0) {
			printf(": failed to determine size of RAM.\n");
			break;
		}
		if (bus_space_subregion(bst, bsh,
		    KE_DATA_OFFSET, sc->mem_size, &sc->sc_bufh)) {
			printf(": failed to map register space\n");
			break;
		}
		if (ae_nb_get_enaddr(bst, bsh, na, sc->sc_arpcom.ac_enaddr)) {
			printf(": can't find MAC address\n");
			break;
		}

		success = 1;
		break;
	case DP8390_VENDOR_CABLETRON:
		/* Map register offsets */
		for (i = 0; i < 16; i++)
		    sc->sc_reg_map[i] = i << 1; /* normal order, word aligned */

		sc->dcr_reg = (ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
		if (bus_space_subregion(bst, bsh,
		    CT_REG_OFFSET, AE_REG_SIZE, &sc->sc_regh)) {
			printf(": failed to map register space\n");
			break;
		}
		if ((sc->mem_size = ae_size_card_memory(bst, bsh,
		    CT_DATA_OFFSET)) == 0) {
			printf(": failed to determine size of RAM.\n");
			break;
		}
		if (bus_space_subregion(bst, bsh,
		    CT_DATA_OFFSET, sc->mem_size, &sc->sc_bufh)) {
			printf(": failed to map register space\n");
			break;
		}
		if (ae_nb_get_enaddr(bst, bsh, na, sc->sc_arpcom.ac_enaddr)) {
			printf(": can't find MAC address\n");
			break;
		}
		success = 1;
	default:
		break;
	}

	if (!success) {
		bus_space_unmap(bst, bsh, NBMEMSIZE);
		return;
	}

	/*
	 * Override test_mem and write_mbuf functions; other defaults
	 * already work properly.
	 */
	sc->test_mem = ae_test_mem;
	sc->write_mbuf = ae_write_mbuf;
#ifdef DEBUG
	ifp->if_watchdog = ae_nb_watchdog;	/* Override watchdog */
#endif
	sc->sc_media_init = dp8390_media_init;

	/* Interface is always enabled. */
	sc->sc_enabled = 1;

	printf(": %s, %dKB memory", cardtype, sc->mem_size / 1024);

	if (dp8390_config(sc)) {
		bus_space_unmap(bst, bsh, NBMEMSIZE);
		return;
	}

	/* make sure interrupts are vectored to us */
	add_nubus_intr(na->slot, IPL_NET, dp8390_intr, sc, sc->sc_dev.dv_xname);
}

static int
ae_nb_card_vendor(bst, bsh, na)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	struct nubus_attach_args *na;
{
	int vendor;

	switch (na->drsw) {
	case NUBUS_DRSW_3COM:
		switch (na->drhw) {
		case NUBUS_DRHW_APPLE_SN:
		case NUBUS_DRHW_APPLE_SNT:
			vendor = DP8390_VENDOR_UNKNOWN;
			break;
		default:
			vendor = DP8390_VENDOR_APPLE;
			break;
		}
		break;
	case NUBUS_DRSW_APPLE:
		if (na->drhw == NUBUS_DRHW_ASANTE_LC) {
			vendor = DP8390_VENDOR_UNKNOWN;
			break;
		}
		/* FALLTHROUGH */
	case NUBUS_DRSW_DAYNA2:
	case NUBUS_DRSW_TECHWORKS:
	case NUBUS_DRSW_TFLLAN:
		if (na->drhw == NUBUS_DRHW_CABLETRON) {
			vendor = DP8390_VENDOR_CABLETRON;
		} else {
			vendor = DP8390_VENDOR_APPLE;
		}
		break;
	case NUBUS_DRSW_ASANTE:
		vendor = DP8390_VENDOR_ASANTE;
		break;
	case NUBUS_DRSW_FARALLON:
		vendor = DP8390_VENDOR_FARALLON;
		break;
	case NUBUS_DRSW_FOCUS:
		vendor = DP8390_VENDOR_FOCUS;
		break;
	case NUBUS_DRSW_GATOR:
		switch (na->drhw) {
		default:
		case NUBUS_DRHW_INTERLAN:
			vendor = DP8390_VENDOR_INTERLAN;
			break;
		case NUBUS_DRHW_KINETICS:
			if (strncmp(nubus_get_card_name(bst, bsh, na->fmt),
			    "EtherPort", 9) == 0)
				vendor = DP8390_VENDOR_KINETICS;
			else
				vendor = DP8390_VENDOR_DAYNA;
			break;
		}
		break;
	default:
		vendor = DP8390_VENDOR_UNKNOWN;
	}
	return vendor;
}

static int
ae_nb_get_enaddr(bst, bsh, na, ep)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	struct nubus_attach_args *na;
	u_int8_t *ep;
{
	nubus_dir dir;
	nubus_dirent dirent;
	int rv;

	/*
	 * XXX - note hardwired resource IDs here (0x80); these are
	 * assumed to be used by all cards, but should be fixed when
	 * we find out more about Ethernet card resources.
	 */
	nubus_get_main_dir(na->fmt, &dir);
	switch (ae_nb_card_vendor(bst, bsh, na)) {
	case DP8390_VENDOR_APPLE:
		if (na->drsw == NUBUS_DRSW_TFLLAN) {	/* TFL LAN E410/E420 */
			rv = nubus_find_rsrc(bst, bsh, na->fmt,
			    &dir, 0x80, &dirent);
			break;
		}
		/* FALLTHROUGH */
	default:
		rv = nubus_find_rsrc(bst, bsh, na->fmt, &dir, 0x80, &dirent);
		break;
	}
	if (rv <= 0)
		return 1;
	nubus_get_dir_from_rsrc(na->fmt, &dirent, &dir);
	if (nubus_find_rsrc(bst, bsh, na->fmt, &dir, 0x80, &dirent) <= 0)
		return 1;
	if (nubus_get_ind_data(bst, bsh,
	    na->fmt, &dirent, ep, ETHER_ADDR_LEN) <= 0)
		return 1;

	return 0;
}

#ifdef DEBUG
static void
ae_nb_watchdog(ifp)
	struct ifnet *ifp;
{
	struct dp8390_softc *sc = ifp->if_softc;
	extern via2hand_t via2intrs[7];

/*
 * This is a kludge!  The via code seems to miss slot interrupts
 * sometimes.  This kludges around that by calling the handler
 * by hand if the watchdog is activated. -- XXX (akb)
 * XXX note that this assumes the nubus handler is first in the chain.
 */
	if (!SLIST_EMPTY(&via2intrs[1])) {
		struct via2hand *vh = SLIST_FIRST(&via2intrs[1]);
		(void)(*vh->vh_fn)(vh->vh_arg);
	}

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	dp8390_reset(sc);
}
#endif
@


1.19
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.18 2007/09/10 20:29:46 miod Exp $	*/
@


1.18
log
@Pass a real ipl level to add_nubus_intr(), and make sure the interrupt
handler is invoked with spl raised to the given level, otherwise all nubus
interrupts are processed at level 2.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.17 2007/01/22 13:17:45 martin Exp $	*/
d146 1
a146 1
		printf(": can't map memory space\n");
@


1.17
log
@use the MI DP8390 driver instead of rolling our own functions

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.16 2006/02/25 15:07:55 martin Exp $	*/
d381 1
a381 1
	add_nubus_intr(na->slot, dp8390_intr, sc, sc->sc_dev.dv_xname);
@


1.16
log
@initialize rv to zero avoiding match on whatever is just next on the bus
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.15 2006/01/05 20:27:14 miod Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Scott Reynolds for
 *      the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
d63 2
a64 1
#include "nubus.h"
d66 4
a69 2
#include "if_aereg.h"
#include "if_aevar.h"
d82 1
a82 1
	sizeof(struct ae_softc), ae_nubus_match, ae_nubus_attach
d102 6
a107 6
		case AE_VENDOR_APPLE:
		case AE_VENDOR_ASANTE:
		case AE_VENDOR_FARALLON:
		case AE_VENDOR_INTERLAN:
		case AE_VENDOR_KINETICS:
		case AE_VENDOR_CABLETRON:
d110 2
a111 2
		case AE_VENDOR_DAYNA:
		case AE_VENDOR_FOCUS:
d133 1
a133 1
	struct ae_softc *sc = (struct ae_softc *) self;
d140 2
a141 1
	int i,success;
d152 6
a157 5
	sc->use16bit = 1;
	sc->vendor = ae_nb_card_vendor(bst, bsh, na);
	strncpy(sc->type_str, nubus_get_card_name(bst, bsh, na->fmt),
	    INTERFACE_NAME_LEN);
	sc->type_str[INTERFACE_NAME_LEN-1] = '\0';
d162 3
a164 3
	switch (sc->vendor) {
	case AE_VENDOR_APPLE:	/* Apple-compatible cards */
	case AE_VENDOR_ASANTE:
d169 1
d200 30
a229 1
	case AE_VENDOR_FARALLON:
d234 1
d260 1
a260 1
	case AE_VENDOR_INTERLAN:
d265 1
d296 1
a296 1
	case AE_VENDOR_KINETICS:
d301 1
a301 1
		sc->use16bit = 0;
d324 4
d329 21
a350 1
		/* shouldn't happen */
d359 6
d368 8
a375 1
	if (aesetup(sc)) {
d381 1
a381 1
	add_nubus_intr(na->slot, aeintr, sc, sc->sc_dev.dv_xname);
d393 11
d406 1
a406 1
			vendor = AE_VENDOR_UNKNOWN;
d414 1
a414 1
			vendor = AE_VENDOR_CABLETRON;
d416 1
a416 12
			vendor = AE_VENDOR_APPLE;
		}
		break;
	case NUBUS_DRSW_3COM:
		switch (na->drhw) {
		case NUBUS_DRHW_APPLE_SN:
		case NUBUS_DRHW_APPLE_SNT:
			vendor = AE_VENDOR_UNKNOWN;
			break;
		default:	/* Apple, others, supported by AE */
			vendor = AE_VENDOR_APPLE;
			break;
d420 1
a420 1
		vendor = AE_VENDOR_ASANTE;
d423 1
a423 1
		vendor = AE_VENDOR_FARALLON;
d426 1
a426 1
		vendor = AE_VENDOR_FOCUS;
d432 1
a432 1
			vendor = AE_VENDOR_INTERLAN;
d437 1
a437 1
				vendor = AE_VENDOR_KINETICS;
d439 1
a439 1
				vendor = AE_VENDOR_DAYNA;
d444 1
a444 1
		vendor = AE_VENDOR_UNKNOWN;
d467 1
a467 1
	case AE_VENDOR_APPLE:
d495 1
a495 1
	struct ae_softc *sc = ifp->if_softc;
d512 1
a512 1
	aereset(sc);
@


1.15
log
@A match() function should never, never, ever return UNSUPP for unsupported
hardware - if only because UNSUPP is 2, not 0. So you'll match, and later
have to do ``oops, twas not my fault, honest'' in attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.14 2005/04/26 21:09:35 martin Exp $	*/
d94 1
a94 1
	int rv;
@


1.14
log
@new NuBus slot space mapping/probing code utilizing bus_space(9)

ok miod@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.13 2005/03/04 00:38:37 martin Exp $	*/
a99 2
	rv = 0;

d113 2
a114 2
			rv = UNSUPP;
			break;
d116 1
d123 1
a123 1
	return rv;
a197 31
	case AE_VENDOR_DAYNA:
		/* Map register offsets */
		for (i = 0; i < 16; i++) /* normal order, longword aligned */
			sc->sc_reg_map[i] = i << 2;

		if (bus_space_subregion(bst, bsh,
		    DP_REG_OFFSET, AE_REG_SIZE, &sc->sc_regh)) {
			printf(": failed to map register space\n");
			break;
		}
		sc->mem_size = 8192;
		if (bus_space_subregion(bst, bsh,
		    DP_DATA_OFFSET, sc->mem_size, &sc->sc_bufh)) {
			printf(": failed to map register space\n");
			break;
		}
#ifdef AE_OLD_GET_ENADDR
		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] =
			    bus_space_read_1(bst, bsh, (DP_ROM_OFFSET + i * 2));
#else
		if (ae_nb_get_enaddr(bst, bsh, na, sc->sc_arpcom.ac_enaddr)) {
			printf(": can't find MAC address\n");
			break;
		}
#endif

		printf(": unsupported Dayna hardware\n");
		break;

a227 4
	case AE_VENDOR_FOCUS:
		printf(": unsupported Focus hardware\n");
		break;

d293 1
@


1.13
log
@match a bunch more Nubus cards from NetBSD;
makes my DaynaPORT E/II-3 work
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.12 2004/12/08 06:59:43 miod Exp $	*/
d74 4
a77 2
static int	ae_nb_card_vendor(struct nubus_attach_args *);
static int	ae_nb_get_enaddr(struct nubus_attach_args *, u_int8_t *);
d104 1
a104 1
		switch (ae_nb_card_vendor(na)) {
d154 2
a155 2
	sc->vendor = ae_nb_card_vendor(na);
	strncpy(sc->type_str, nubus_get_card_name(na->fmt),
d190 1
a190 1
		if (ae_nb_get_enaddr(na, sc->sc_arpcom.ac_enaddr)) {
d221 1
a221 1
		if (ae_nb_get_enaddr(na, sc->sc_arpcom.ac_enaddr)) {
d288 1
a288 1
		if (ae_nb_get_enaddr(na, sc->sc_arpcom.ac_enaddr)) {
d320 1
a320 1
		if (ae_nb_get_enaddr(na, sc->sc_arpcom.ac_enaddr)) {
d350 3
a352 1
ae_nb_card_vendor(na)
d400 2
a401 2
			if (strncmp(
			    nubus_get_card_name(na->fmt), "EtherPort", 9) == 0)
d415 3
a417 1
ae_nb_get_enaddr(na, ep)
d431 1
a431 1
	switch (ae_nb_card_vendor(na)) {
d434 2
a435 1
			rv = nubus_find_rsrc(na->fmt, &dir, 0x80, &dirent);
d440 1
a440 1
		rv = nubus_find_rsrc(na->fmt, &dir, 0x80, &dirent);
d446 1
a446 1
	if (nubus_find_rsrc(na->fmt, &dir, 0x80, &dirent) <= 0)
d448 2
a449 1
	if (nubus_get_ind_data(na->fmt, &dirent, ep, ETHER_ADDR_LEN) <= 0)
@


1.12
log
@Tweak interrupt handling code to allow shared interrupts for VIA2 sources.
This will be necessary shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.11 2004/12/01 21:19:11 miod Exp $	*/
d108 1
d355 6
d362 6
a367 1
		vendor = AE_VENDOR_APPLE;
d417 1
d425 12
a436 1
	if (nubus_find_rsrc(na->fmt, &dir, 0x80, &dirent) <= 0)
@


1.11
log
@Let kernels with option DEBUG link again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.10 2004/11/26 21:21:24 miod Exp $	*/
d429 1
a429 1
	extern struct intrhand via2intrs[7];
d435 1
d437 4
a440 2
	if (via2intrs[1].ih_fn != NULL)
		(void)(*via2intrs[1].ih_fn)(via2intrs[1].ih_arg);
@


1.10
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.9 2004/04/02 21:01:44 xsa Exp $	*/
d429 1
d436 2
a437 1
	(*via2itab[1])((void *) 1);
@


1.9
log
@
set correct MAC address for Farallon eth' cards.
Tested by Martin Reindl <mreindl at catai.org>
ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.8 2002/03/14 01:26:35 millert Exp $	*/
d343 1
a343 1
	add_nubus_intr(na->slot, aeintr, sc);
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.7 1997/05/01 18:32:49 briggs Exp $	*/
d46 2
@


1.7
log
@Treat drhw 118 and 119 the same for Apple ethernet cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.6 1997/04/24 02:17:56 gene Exp $	*/
d70 4
a73 4
static int	ae_nubus_match __P((struct device *, void *, void *));
static void	ae_nubus_attach __P((struct device *, struct device *, void *));
static int	ae_nb_card_vendor __P((struct nubus_attach_args *));
static int	ae_nb_get_enaddr __P((struct nubus_attach_args *, u_int8_t *));
d75 1
a75 1
static void	ae_nb_watchdog __P((struct ifnet *));
@


1.7.26.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ae_nubus.c,v 1.7 1997/05/01 18:32:49 briggs Exp $	*/
d70 4
a73 4
static int	ae_nubus_match(struct device *, void *, void *);
static void	ae_nubus_attach(struct device *, struct device *, void *);
static int	ae_nb_card_vendor(struct nubus_attach_args *);
static int	ae_nb_get_enaddr(struct nubus_attach_args *, u_int8_t *);
d75 1
a75 1
static void	ae_nb_watchdog(struct ifnet *);
@


1.7.14.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 4
a73 4
static int	ae_nubus_match(struct device *, void *, void *);
static void	ae_nubus_attach(struct device *, struct device *, void *);
static int	ae_nb_card_vendor(struct nubus_attach_args *);
static int	ae_nb_get_enaddr(struct nubus_attach_args *, u_int8_t *);
d75 1
a75 1
static void	ae_nb_watchdog(struct ifnet *);
@


1.7.14.2
log
@Merge with the trunk
@
text
@a46 2
#define	AE_OLD_GET_ENADDR

@


1.6
log
@Inspired by NetBSD changes: ditch AE_DEBUG diagnostics.  This kills the AE_DEBUG option (if for some reason anyone is using it).
@
text
@d1 2
a2 2
/*	$NetBSD: if_ae_nubus.c,v 1.11 1997/03/19 08:04:39 scottr Exp $	*/
/*	$OpenBSD: if_ae_nubus.c,v 1.5 1997/04/08 04:14:45 briggs Exp $	*/
d358 1
@


1.5
log
@Some patches from Bob Nestor <rnestor@@metronet.com> to edge toward support
for an Apple SONIC-based ethernet card.  Includes a patch to the nubus
probing that we worked out together.  Some cards, like his, were being
missed and/or probed like video cards\!
@
text
@d2 1
a2 1
/*	$OpenBSD: if_ae_nubus.c,v 1.4 1997/03/25 04:58:43 briggs Exp $	*/
a389 3
#ifdef AE_DEBUG
		printf("Unknown ethernet drsw: %x\n", na->drsw);
#endif
@


1.4
log
@From scottr@@netbsd.org:
Several more changes to move us toward MI-ness:

 - Use more consistent and portable types in the softc.
 - Map registers using an array of bus_size_t offsets, and set up the
   mapping in the attach code (thanks to Jason Thorpe for suggesting
   this!).
 - Disable the ae-specific watchdog, which is no longer necessary in
   the general case.

Still remaining:  split out functions used to copy data to/from the
card, and retain a way to have a local driver name with the MI code.
@
text
@d2 1
a2 1
/*	$OpenBSD: if_ae_nubus.c,v 1.3 1997/03/18 01:02:50 briggs Exp $	*/
a350 1
	case NUBUS_DRSW_3COM:
d354 10
@


1.3
log
@From Scott Reynolds <scottr@@netbsd.org> (, but compilable ;-)
Some cards we identify as InterLAN cards do not seem to have the MAC
address in the configuration ROM.  For these, fall back to the old
method if we can't find the expected sResource record.
@
text
@d1 2
a2 2
/*	$NetBSD: if_ae_nubus.c,v 1.9 1997/03/17 20:26:01 scottr Exp $	*/
/*	$OpenBSD: if_ae_nubus.c,v 1.2 1997/03/12 13:36:58 briggs Exp $	*/
d34 12
d74 1
d76 1
d132 1
d134 1
a147 1
	sc->regs_rev = 0;
d160 4
a163 1
		sc->regs_rev = 1;
d195 4
d226 4
a229 1
		sc->regs_rev = 1;
d260 4
d295 4
d332 1
d334 1
d414 1
a420 1
#if 1
a426 1
#endif
d433 1
@


1.2
log
@Remove some more warnings left over from NetBSD's new config.
@
text
@d1 2
a2 2
/*	$NetBSD: if_ae_nubus.c,v 1.5 1997/02/28 08:56:06 scottr Exp $	*/
/*	$OpenBSD$	*/
d121 1
a121 4
	int success;
#ifdef AE_OLD_GET_ENADDR
	int i;
#endif
a253 6
#ifdef AE_OLD_GET_ENADDR
		/* Get station address from on-board ROM */
		for (i = 0; i < ETHER_ADDR_LEN; ++i)
			sc->sc_arpcom.ac_enaddr[i] =
			    bus_space_read_1(bst, bsh, (GC_ROM_OFFSET + i * 4));
#else
d255 5
a259 2
			printf(": can't find MAC address\n");
			break;
a260 1
#endif
@


1.1
log
@Sync with NetBSD of about 4 March.
@
text
@d2 1
a104 1
printf("ae_nubus_match returning %d\n", rv);
a125 1
printf("ae_nubus_attach\n");
a144 1
printf("ae_nubus_attach vendor switch\n");
a299 1
printf("ae_nubus_attach vendor switch done\n");
@
