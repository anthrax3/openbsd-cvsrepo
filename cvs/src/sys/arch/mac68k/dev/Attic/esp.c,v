head	1.32;
access;
symbols
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.6
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.28.0.4
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.27.0.6
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.6
	OPENBSD_2_9_BASE:1.13
	NIKLAS_UNDEAD:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.10
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.8
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.6
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.4
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11;
locks; strict;
comment	@ * @;


1.32
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.31;

1.31
date	2010.11.11.17.55.32;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.16.21.19.05;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.29.21.24.02;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.13.19.39.52;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.22.18.37.56;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.04.20.30.58;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.01.13.39.23;	author martin;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.09.09.15.53;	author martin;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.10.18.23.23;	author martin;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.08.06.59.43;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.05.12.27.02;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.11.19.20.26;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.04.08.52.44;	author niklas;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2000.06.12.06.10.48;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	98.05.03.07.12.54;	author gene;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	97.03.08.16.16.50;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.03.05.15.17.04;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.02.27.14.02.37;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.01.19.03.23.24;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.01.18.17.58.39;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.21.45.50;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.04.18.51.54;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.11.04.16.46.45;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.11.02.06.47.22;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.10.30.05.35.01;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	96.10.28.22.40.18;	author briggs;	state Exp;
branches;
next	;

1.12.8.1
date	2001.04.18.16.10.05;	author niklas;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.12.8.4;

1.12.8.4
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.12.8.5;

1.12.8.5
date	2003.06.07.11.13.13;	author ho;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.32
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: esp.c,v 1.31 2010/11/11 17:55:32 miod Exp $	*/
/*	$NetBSD: esp.c,v 1.17 1998/09/05 15:15:35 pk Exp $	*/

/*
 * Copyright (c) 1997 Jason R. Thorpe.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Peter Galbavy
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Based on aic6360 by Jarle Greipsland
 *
 * Acknowledgements: Many of the algorithms used in this driver are
 * inspired by the work of Julian Elischer (julian@@tfs.com) and
 * Charles Hannum (mycroft@@duality.gnu.ai.mit.edu).  Thanks a million!
 */

/*
 * Initial m68k mac support from Allen Briggs <briggs@@macbsd.com>
 * (basically consisting of the match, a bit of the attach, and the
 *  "DMA" glue functions).
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/queue.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/param.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>

#include <machine/viareg.h>

#include <mac68k/dev/espvar.h>
#include <mac68k/dev/obiovar.h>

void	espattach(struct device *, struct device *, void *);
int	espmatch(struct device *, void *, void *);

/* Linkup to the rest of the kernel */
struct cfattach esp_ca = {
	sizeof(struct esp_softc), espmatch, espattach
};

struct scsi_adapter esp_switch = {
	ncr53c9x_scsi_cmd,
	scsi_minphys,		/* no max at this level; handled by DMA code */
	NULL,
	NULL,
};

/*
 * Functions and the switch for the MI code.
 */
u_char	esp_read_reg(struct ncr53c9x_softc *, int);
void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
int	esp_dma_isintr(struct ncr53c9x_softc *);
void	esp_dma_reset(struct ncr53c9x_softc *);
int	esp_dma_intr(struct ncr53c9x_softc *);
int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *);
void	esp_dma_go(struct ncr53c9x_softc *);
void	esp_dma_stop(struct ncr53c9x_softc *);
int	esp_dma_isactive(struct ncr53c9x_softc *);
void	esp_quick_write_reg(struct ncr53c9x_softc *, int, u_char);
int	esp_quick_dma_intr(struct ncr53c9x_softc *);
int	esp_quick_dma_setup(struct ncr53c9x_softc *, caddr_t *,
		size_t *, int, size_t *);
void	esp_quick_dma_go(struct ncr53c9x_softc *);
int	esp_intr(void *);

static __inline__ int esp_dafb_have_dreq(struct esp_softc *esc);
static __inline__ int esp_iosb_have_dreq(struct esp_softc *esc);
int (*esp_have_dreq) (struct esp_softc *esc);

struct ncr53c9x_glue esp_glue = {
	esp_read_reg,
	esp_write_reg,
	esp_dma_isintr,
	esp_dma_reset,
	esp_dma_intr,
	esp_dma_setup,
	esp_dma_go,
	esp_dma_stop,
	esp_dma_isactive,
	NULL,			/* gl_clear_latched_intr */
};

int
espmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;

	if ((cf->cf_unit == 0) && mac68k_machine.scsi96) {
		return 1;
	}
	if ((cf->cf_unit == 1) && mac68k_machine.scsi96_2) {
		return 1;
	}
	return 0;
}

/*
 * Attach this instance, and then all the sub-devices
 */
void
espattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct obio_attach_args *oa = (struct obio_attach_args *)aux;
	extern vaddr_t		SCSIBase;
	struct esp_softc	*esc = (void *)self;
	struct ncr53c9x_softc	*sc = &esc->sc_ncr53c9x;
	int			quick = 0;
	unsigned long		reg_offset;

	reg_offset = SCSIBase - IOBase;
	esc->sc_tag = oa->oa_tag;

	/*
	 * For Wombat, Primus and Optimus motherboards, DREQ is
	 * visible on bit 0 of the IOSB's emulated VIA2 vIFR (and
	 * the SCSI registers are offset 0x1000 bytes from IOBase).
	 *
	 * For the Q700/900/950 it's at f9800024 for bus 0 and
	 * f9800028 for bus 1 (900/950).  For these machines, that is also
	 * a (12-bit) configuration register for DAFB's control of the
	 * pseudo-DMA timing.  The default value is 0x1d1.
	 */
	esp_have_dreq = esp_dafb_have_dreq;
	if (sc->sc_dev.dv_unit == 0) {
		if (reg_offset == 0x10000) {
			quick = 1;
			esp_have_dreq = esp_iosb_have_dreq;
		} else if (reg_offset == 0x18000) {
			quick = 0;
		} else {
			if (bus_space_map(esc->sc_tag, 0xf9800024,
					4, 0, &esc->sc_bsh)) {
				printf("failed to map 4 at 0xf9800024.\n");
			} else {
				quick = 1;
				bus_space_write_4(esc->sc_tag,
					esc->sc_bsh, 0, 0x1d1);
			}
		}
	} else {
		if (bus_space_map(esc->sc_tag, 0xf9800028, 4, 0,
				&esc->sc_bsh)) {
			printf("failed to map 4 at 0xf9800028.\n");
		} else {
			quick = 1;
			bus_space_write_4(esc->sc_tag, esc->sc_bsh, 0, 0x1d1);
		}
	}
	if (quick) {
		esp_glue.gl_write_reg = esp_quick_write_reg;
		esp_glue.gl_dma_intr = esp_quick_dma_intr;
		esp_glue.gl_dma_setup = esp_quick_dma_setup;
		esp_glue.gl_dma_go = esp_quick_dma_go;
	}

	/*
	 * Set up the glue for MI code early; we use some of it here.
	 */
	sc->sc_glue = &esp_glue;

	esc->sc_ih.vh_fn = esp_intr;
	esc->sc_ih.vh_arg = esc;
	esc->sc_ih.vh_ipl = VIA2_SCSIIRQ;

	/*
	 * Save the regs
	 */
	if (sc->sc_dev.dv_unit == 0) {
		esc->sc_reg = (volatile u_char *) SCSIBase;
		via2_register_irq(&esc->sc_ih, self->dv_xname);
		esc->irq_mask = V2IF_SCSIIRQ;
		if (reg_offset == 0x10000) {
			/* From the Q650 developer's note */
			sc->sc_freq = 16500;
		} else {
			sc->sc_freq = 25000;
		}
	} else {
		esc->sc_reg = (volatile u_char *) SCSIBase + 0x402;
		via2_register_irq(&esc->sc_ih, self->dv_xname);
		esc->irq_mask = 0;
		sc->sc_freq = 25000;
	}

	if (quick) {
		printf(" (pseudo-DMA)");
	}

#ifdef DEBUG
	printf(" address %p", esc->sc_reg);
#endif

	sc->sc_id = 7;

	/*
	 * It is necessary to try to load the 2nd config register here,
	 * to find out what rev the esp chip is, else the esp_reset
	 * will not set up the defaults correctly.
	 */
	sc->sc_cfg1 = sc->sc_id; /* | NCRCFG1_PARENB; */
	sc->sc_cfg2 = NCRCFG2_SCSI2;
	sc->sc_cfg3 = 0;
	sc->sc_rev = NCR_VARIANT_NCR53C96;

	/*
	 * This is the value used to start sync negotiations
	 * Note that the NCR register "SYNCTP" is programmed
	 * in "clocks per byte", and has a minimum value of 4.
	 * The SCSI period used in negotiation is one-fourth
	 * of the time (in nanoseconds) needed to transfer one byte.
	 * Since the chip's clock is given in kHz, we have the following
	 * formula: 4 * period = (1000000 / freq) * 4
	 */
	sc->sc_minsync = 1000000 / sc->sc_freq;

	/* We need this to fit into the TCR... */
	sc->sc_maxxfer = 64 * 1024;

	if (quick == 0) {
		sc->sc_minsync = 0;	/* No synchronous xfers w/o DMA */
		sc->sc_maxxfer = 8 * 1024;
	}

	/* convert sc_freq to MHz */
	sc->sc_freq /= 1000;

	/*
	 * Configure interrupts.
	 */
	if (esc->irq_mask) {
		via2_reg(vPCR) = 0x22;
		via2_reg(vIFR) = esc->irq_mask;
		via2_reg(vIER) = 0x80 | esc->irq_mask;
	}

	/*
	 * Now try to attach all the sub-devices
	 */
	ncr53c9x_attach(sc, &esp_switch);
}

/*
 * Glue functions.
 */

u_char
esp_read_reg(sc, reg)
	struct ncr53c9x_softc *sc;
	int reg;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return esc->sc_reg[reg * 16];
}

void
esp_write_reg(sc, reg, val)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char val;
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	u_char v = val;

	if (reg == NCR_CMD && v == (NCRCMD_TRANS|NCRCMD_DMA)) {
		v = NCRCMD_TRANS;
	}
	esc->sc_reg[reg * 16] = v;
}

void
esp_dma_stop(sc)
	struct ncr53c9x_softc *sc;
{
}

int
esp_dma_isactive(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return esc->sc_active;
}

int
esp_dma_isintr(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return esc->sc_reg[NCR_STAT * 16] & 0x80;
}

void
esp_dma_reset(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	esc->sc_active = 0;
	esc->sc_tc = 0;
}

int
esp_dma_intr(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	volatile u_char *cmdreg, *intrreg, *statreg, *fiforeg;
	u_char	*p;
	u_int	espphase, espstat, espintr;
	int	cnt;

	if (esc->sc_active == 0) {
		printf("dma_intr--inactive DMA\n");
		return -1;
	}

	if ((sc->sc_espintr & NCRINTR_BS) == 0) {
		esc->sc_active = 0;
		return 0;
	}

	cnt = *esc->sc_dmalen;
	if (*esc->sc_dmalen == 0) {
		printf("data interrupt, but no count left.");
	}

	p = *esc->sc_dmaaddr;
	espphase = sc->sc_phase;
	espstat = (u_int) sc->sc_espstat;
	espintr = (u_int) sc->sc_espintr;
	cmdreg = esc->sc_reg + NCR_CMD * 16;
	fiforeg = esc->sc_reg + NCR_FIFO * 16;
	statreg = esc->sc_reg + NCR_STAT * 16;
	intrreg = esc->sc_reg + NCR_INTR * 16;
	do {
		if (esc->sc_datain) {
			*p++ = *fiforeg;
			cnt--;
			if (espphase == DATA_IN_PHASE) {
				*cmdreg = NCRCMD_TRANS;
			} else {
				esc->sc_active = 0;
			}
	 	} else {
			if (   (espphase == DATA_OUT_PHASE)
			    || (espphase == MESSAGE_OUT_PHASE)) {
				*fiforeg = *p++;
				cnt--;
				*cmdreg = NCRCMD_TRANS;
			} else {
				esc->sc_active = 0;
			}
		}

		if (esc->sc_active) {
			while (!(*statreg & 0x80));
			espstat = *statreg;
			espintr = *intrreg;
			espphase = (espintr & NCRINTR_DIS)
				    ? /* Disconnected */ BUSFREE_PHASE
				    : espstat & PHASE_MASK;
		}
	} while (esc->sc_active && (espintr & NCRINTR_BS));
	sc->sc_phase = espphase;
	sc->sc_espstat = (u_char) espstat;
	sc->sc_espintr = (u_char) espintr;
	*esc->sc_dmaaddr = p;
	*esc->sc_dmalen = cnt;

	if (*esc->sc_dmalen == 0) {
		esc->sc_tc = NCRSTAT_TC;
	}
	sc->sc_espstat |= esc->sc_tc;
	return 0;
}

int
esp_dma_setup(sc, addr, len, datain, dmasize)
	struct ncr53c9x_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
	size_t *dmasize;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	esc->sc_dmaaddr = addr;
	esc->sc_dmalen = len;
	esc->sc_datain = datain;
	esc->sc_dmasize = *dmasize;
	esc->sc_tc = 0;

	return 0;
}

void
esp_dma_go(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	if (esc->sc_datain == 0) {
		esc->sc_reg[NCR_FIFO * 16] = **esc->sc_dmaaddr;
		(*esc->sc_dmalen)--;
		(*esc->sc_dmaaddr)++;
	}
	esc->sc_active = 1;
}

void
esp_quick_write_reg(sc, reg, val)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char val;
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	u_char v = val;

	esc->sc_reg[reg * 16] = v;
}

int
esp_quick_dma_intr(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	int trans=0, resid=0;

	if (esc->sc_active == 0)
		panic("dma_intr--inactive DMA");

	esc->sc_active = 0;

	if (esc->sc_dmasize == 0) {
		int	res;

		res = 65536;
		res -= NCR_READ_REG(sc, NCR_TCL);
		res -= NCR_READ_REG(sc, NCR_TCM) << 8;
		printf("dmaintr: discarded %d b (last transfer was %d b).\n",
			res, esc->sc_prevdmasize);
		return 0;
	}

	if (esc->sc_datain &&
	    (resid = (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF)) != 0) {
		printf("dmaintr: empty FIFO of %d\n", resid);
		DELAY(1);
	}

	if ((sc->sc_espstat & NCRSTAT_TC) == 0) {
		resid += NCR_READ_REG(sc, NCR_TCL);
		resid += NCR_READ_REG(sc, NCR_TCM) << 8;

		if (resid == 0)
			resid = 65536;
	}
	
	trans = esc->sc_dmasize - resid;
	if (trans < 0) {
		printf("dmaintr: trans < 0????");
		trans = esc->sc_dmasize;
	}

	NCR_DMA(("dmaintr: trans %d, resid %d.\n", trans, resid));
	*esc->sc_dmaaddr += trans;
	*esc->sc_dmalen -= trans;

	return 0;
}

int
esp_quick_dma_setup(sc, addr, len, datain, dmasize)
	struct ncr53c9x_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
	size_t *dmasize;
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	esc->sc_dmaaddr = addr;
	esc->sc_dmalen = len;

	esc->sc_pdmaddr = (u_int16_t *) *addr;
	esc->sc_pdmalen = *len;

	if (esc->sc_pdmalen & 1) {
		esc->sc_pdmalen--;
		esc->sc_pad = 1;
	} else {
		esc->sc_pad = 0;
	}

	esc->sc_datain = datain;
	esc->sc_prevdmasize = esc->sc_dmasize;
	esc->sc_dmasize = *dmasize;

	return 0;
}

static __inline__ int
esp_dafb_have_dreq(esc)
	struct esp_softc *esc;
{
	return (*(volatile u_int32_t *)
	    bus_space_vaddr(esc->sc_tag, esc->sc_bsh) & 0x200);
}

static __inline__ int
esp_iosb_have_dreq(esc)
	struct esp_softc *esc;
{
	return (via2_reg(vIFR) & V2IF_SCSIDRQ);
}

/* Faster spl constructs, without saving old values */
#define	__splx(s)	__asm __volatile ("movew %0,sr" : : "di" (s));
#define	__splvm()	__splx(mac68k_vmipl)
#define	__splbio()	__splx(PSL_S | PSL_IPL2)

void
esp_quick_dma_go(sc)
	struct ncr53c9x_softc *sc;
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	extern int *nofault;
	label_t faultbuf;
	u_int16_t volatile *pdma;
	u_char volatile *statreg;
	int espspl;

	esc->sc_active = 1;

	espspl = splbio();

restart_dmago:
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *) nofault)) {
		int	i=0;

		nofault = (int *) 0;
		statreg = esc->sc_reg + NCR_STAT * 16;
		for (;;) {
			if (*statreg & 0x80) {
				goto gotintr;
			}

			if (esp_have_dreq(esc)) {
				break;
			}

			DELAY(1);
			if (i++ > 10000)
				panic("esp_dma_go: Argh!");
		}
		goto restart_dmago;
	}

	statreg = esc->sc_reg + NCR_STAT * 16;
	pdma = (u_int16_t *) (esc->sc_reg + 0x100);

#define WAIT while (!esp_have_dreq(esc)) if (*statreg & 0x80) goto gotintr

	if (esc->sc_datain == 0) {
		while (esc->sc_pdmalen) {
			WAIT;
			__splvm(); *pdma = *(esc->sc_pdmaddr)++; __splbio();
			esc->sc_pdmalen -= 2;
		}
		if (esc->sc_pad) {
			unsigned short  us;
			unsigned char   *c;
			c = (unsigned char *) esc->sc_pdmaddr;
			us = *c;
			WAIT;
			__splvm(); *pdma = us; __splbio();
		}
	} else {
		while (esc->sc_pdmalen) {
			WAIT;
			__splvm(); *(esc->sc_pdmaddr)++ = *pdma; __splbio();
			esc->sc_pdmalen -= 2;
		}
		if (esc->sc_pad) {
			unsigned short  us;
			unsigned char   *c;
			WAIT;
			__splvm(); us = *pdma; __splbio();
			c = (unsigned char *) esc->sc_pdmaddr;
			*c = us & 0xff;
		}
	}
#undef WAIT
	nofault = (int *) 0;
	
	if ((*statreg & 0x80) == 0) {
		splx(espspl);
		return;
	}

gotintr:
	ncr53c9x_intr(sc);
	splx(espspl);
}

int
esp_intr(void *v)
{
	struct esp_softc *esc = (struct esp_softc *)v;

	if (esc->sc_reg[NCR_STAT * 16] & NCRSTAT_INT)
		return (ncr53c9x_intr(v));

	return (0);
}
@


1.31
log
@Compute syhcnronous transfer periods with a better accuracy, to get better
results on the 16.5MHz clock case. ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.30 2010/06/28 18:31:01 krw Exp $	*/
@


1.30
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.29 2010/06/26 23:24:43 guenther Exp $	*/
d249 1
a249 1
			sc->sc_freq = 16500000;
d251 1
a251 1
			sc->sc_freq = 25000000;
d257 1
a257 1
		sc->sc_freq = 25000000;
d286 2
a287 2
	 * Since the chip's clock is given in MHz, we have the following
	 * formula: 4 * period = (1000 / freq) * 4
d289 1
a289 1
	sc->sc_minsync = (1000 * 1000000) / sc->sc_freq;
d299 2
a300 2
	/* gimme MHz */
	sc->sc_freq /= 1000000;
@


1.29
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.28 2009/02/16 21:19:05 miod Exp $	*/
a116 7
struct scsi_device esp_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

d314 1
a314 1
	ncr53c9x_attach(sc, &esp_switch, &esp_dev);
@


1.28
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.27 2007/07/29 21:24:02 miod Exp $	*/
a83 1
#include <sys/user.h>
@


1.27
log
@It turns out that VIA2 always interrupts at level 2, and IPL_BIO is always 2
too, so we can make these constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.26 2006/03/13 19:39:52 brad Exp $	*/
d113 1
a113 1
	minphys,		/* no max at this level; handled by DMA code */
@


1.26
log
@remove splimp.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.25 2006/01/22 18:37:56 miod Exp $	*/
d606 1
a606 1
#define	__splbio()	__splx(mac68k_bioipl)
@


1.25
log
@Add bus_space_vaddr() and use it instead of accessing private bus_space
fields. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.24 2006/01/04 20:30:58 miod Exp $	*/
d605 1
a605 1
#define	__splimp()	__splx(mac68k_impipl)
d654 1
a654 1
			__splimp(); *pdma = *(esc->sc_pdmaddr)++; __splbio();
d663 1
a663 1
			__splimp(); *pdma = us; __splbio();
d668 1
a668 1
			__splimp(); *(esc->sc_pdmaddr)++ = *pdma; __splbio();
d675 1
a675 1
			__splimp(); us = *pdma; __splbio();
@


1.24
log
@More accurate sc_minsync computation on 16.5MHz ESPs; ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.23 2005/10/01 13:39:23 martin Exp $	*/
d592 2
a593 1
	return (*(volatile u_int32_t *)(esc->sc_bsh.base) & 0x200);
@


1.23
log
@simplifiy esp_dafb_have_dreq()

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.22 2005/08/09 09:15:53 martin Exp $	*/
a277 3
	/* gimme MHz */
	sc->sc_freq /= 1000000;

d297 1
a297 1
	sc->sc_minsync = 1000 / sc->sc_freq;
d306 3
@


1.22
log
@Save a variable in espmatch(), vm_offset_t->vaddr_t, print DEBUG address
after everything else, fix transfer sizes on quick/non-quick and attach
sub devices after interrupts are configured.

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.21 2005/07/18 02:43:25 fgsch Exp $	*/
d592 1
a592 4
	u_int32_t r;

	r = bus_space_read_4(esc->sc_tag, esc->sc_bsh, 0);
	return (r & 0x200);
@


1.21
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.20 2004/12/10 18:23:23 martin Exp $	*/
a167 1
	int	found = 0;
d170 1
a170 1
		found = 1;
d173 1
a173 1
		found = 1;
d175 1
a175 2
	
	return found;
d187 1
a187 1
	extern vm_offset_t	SCSIBase;
d199 1
a199 1
	 * the scsi registers are offset 0x1000 bytes from IOBase).
d256 1
d268 4
a274 3
	if (esp_glue.gl_dma_go == esp_quick_dma_go) {
		printf(" (pseudo-DMA)");
	}
d302 2
a303 3
	sc->sc_minsync = 0;	/* No synchronous xfers w/o DMA */
	/* Really no limit, but since we want to fit into the TCR... */
	sc->sc_maxxfer = 8 * 1024; /*64 * 1024; XXX */
d305 4
a308 4
	/*
	 * Now try to attach all the sub-devices
	 */
	ncr53c9x_attach(sc, &esp_switch, &esp_dev);
d318 5
d392 1
a392 2
	register struct esp_softc *esc = (struct esp_softc *)sc;
	register u_char	*p;
d394 3
a396 2
	register u_int	espphase, espstat, espintr;
	register int	cnt;
@


1.20
log
@pseudo-DMA for non-AV Quadras, inspired by NetBSD
with lots of help from miod@@
additional testing by nick@@ and otto@@

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.19 2004/12/08 06:59:43 miod Exp $	*/
d512 1
a512 1
		panic("dma_intr--inactive DMA\n");
@


1.19
log
@Tweak interrupt handling code to allow shared interrupts for VIA2 sources.
This will be necessary shortly.
@
text
@d1 2
a2 2
/*	$OpenBSD: esp.c,v 1.18 2004/11/26 21:21:24 miod Exp $	*/
/*	$NetBSD: esp.c,v 1.59 1996/10/13 02:59:48 christos Exp $	*/
a36 1
 * Copyright (c) 1995 Paul Kranenburg
d92 1
d101 1
d138 10
d168 1
d170 8
a177 5
	if ((cf->cf_unit == 0) && mac68k_machine.scsi96)
		return (1);
	if ((cf->cf_unit == 1) && mac68k_machine.scsi96_2)
		return (1);
	return (0);
d188 1
d190 50
a239 2
	struct esp_softc *esc = (void *)self;
	struct ncr53c9x_softc *sc = &esc->sc_ncr53c9x;
d246 1
a246 1
	esc->sc_ih.vh_fn = ncr53c9x_intr;
d248 1
a253 2
		unsigned long	reg_offset;

a254 1
		esc->sc_ih.vh_ipl = VIA2_SCSIIRQ;
a256 1
		reg_offset = SCSIBase - IOBase;
a263 1
		esc->sc_ih.vh_ipl = VIA2_SCSIDRQ;
d265 1
a265 1
		esc->irq_mask = V2IF_SCSIDRQ; /* V2IF_T1? */
d269 6
a274 1
	printf(": address %p", esc->sc_reg);
d286 1
a286 1
	sc->sc_cfg1 = sc->sc_id | NCRCFG1_PARENB;
d304 1
a304 1
	sc->sc_maxxfer = 64 * 1024;
d314 5
a318 3
	via2_reg(vPCR) = 0x22;
	via2_reg(vIFR) = esc->irq_mask;
	via2_reg(vIER) = 0x80 | esc->irq_mask;
d350 15
d404 2
a405 2
	cnt = *esc->sc_pdmalen;
	if (*esc->sc_pdmalen == 0) {
d450 1
a450 1
	*esc->sc_pdmalen = cnt;
d452 1
a452 1
	if (*esc->sc_pdmalen == 0) {
d470 1
a470 1
	esc->sc_pdmalen = len;
d486 1
a486 1
		(*esc->sc_pdmalen)--;
d493 1
a493 1
esp_dma_stop(sc)
d495 2
d498 4
d505 103
a607 1
esp_dma_isactive(sc)
d611 25
d637 63
a699 1
	return esc->sc_active;
@


1.18
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.17 2003/06/05 12:27:02 deraadt Exp $	*/
d182 3
d192 2
a193 2
		via2_register_irq(VIA2_SCSIIRQ, ncr53c9x_intr, esc,
		    self->dv_xname);
d203 2
a204 2
		via2_register_irq(VIA2_SCSIDRQ, ncr53c9x_intr, esc,
		    self->dv_xname);
@


1.17
log
@3/4 knockout for peter galbavy
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.16 2003/02/11 19:20:26 mickey Exp $	*/
d189 2
a190 2
		via2_register_irq(VIA2_SCSIIRQ,
					(void (*)(void *))ncr53c9x_intr, esc);
d200 2
a201 2
		via2_register_irq(VIA2_SCSIDRQ,
					(void (*)(void *))ncr53c9x_intr, esc);
@


1.16
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.15 2002/03/14 01:26:35 millert Exp $	*/
a47 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.14 2001/07/04 08:52:44 niklas Exp $	*/
d215 1
a215 1
	/* gimme Mhz */
@


1.14
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.59 1996/10/13 02:59:48 christos Exp $	*/
d107 2
a108 2
void	espattach	__P((struct device *, struct device *, void *));
int	espmatch	__P((struct device *, void *, void *));
d132 10
a141 10
u_char	esp_read_reg __P((struct ncr53c9x_softc *, int));
void	esp_write_reg __P((struct ncr53c9x_softc *, int, u_char));
int	esp_dma_isintr __P((struct ncr53c9x_softc *));
void	esp_dma_reset __P((struct ncr53c9x_softc *));
int	esp_dma_intr __P((struct ncr53c9x_softc *));
int	esp_dma_setup __P((struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *));
void	esp_dma_go __P((struct ncr53c9x_softc *));
void	esp_dma_stop __P((struct ncr53c9x_softc *));
int	esp_dma_isactive __P((struct ncr53c9x_softc *));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.14 2001/07/04 08:52:44 niklas Exp $	*/
d107 2
a108 2
void	espattach(struct device *, struct device *, void *);
int	espmatch(struct device *, void *, void *);
d132 10
a141 10
u_char	esp_read_reg(struct ncr53c9x_softc *, int);
void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
int	esp_dma_isintr(struct ncr53c9x_softc *);
void	esp_dma_reset(struct ncr53c9x_softc *);
int	esp_dma_intr(struct ncr53c9x_softc *);
int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *);
void	esp_dma_go(struct ncr53c9x_softc *);
void	esp_dma_stop(struct ncr53c9x_softc *);
int	esp_dma_isactive(struct ncr53c9x_softc *);
@


1.14.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d215 1
a215 1
	/* gimme MHz */
@


1.13
log
@move cfdriver to ncr53c9x.c and device declaration to conf/files.
@
text
@d1 1
@


1.12
log
@Associated fallout from removing macinfo.h and merging to cpu.h.
@
text
@a113 4
struct cfdriver esp_cd = {
	NULL, "esp", DV_DULL
};

@


1.12.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d114 4
@


1.12.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.12.8.3
log
@Merge in -current from about a week ago
@
text
@d107 2
a108 2
void	espattach(struct device *, struct device *, void *);
int	espmatch(struct device *, void *, void *);
d132 10
a141 10
u_char	esp_read_reg(struct ncr53c9x_softc *, int);
void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
int	esp_dma_isintr(struct ncr53c9x_softc *);
void	esp_dma_reset(struct ncr53c9x_softc *);
int	esp_dma_intr(struct ncr53c9x_softc *);
int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *);
void	esp_dma_go(struct ncr53c9x_softc *);
void	esp_dma_stop(struct ncr53c9x_softc *);
int	esp_dma_isactive(struct ncr53c9x_softc *);
@


1.12.8.4
log
@Sync the SMP branch with 3.3
@
text
@d215 1
a215 1
	/* gimme MHz */
@


1.12.8.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: esp.c,v 1.12.8.4 2003/03/27 23:28:43 niklas Exp $	*/
d48 5
@


1.11
log
@Sync with NetBSD of about 4 March.
@
text
@a101 1
#include <machine/macinfo.h>
@


1.10
log
@Copyright foo.
@
text
@d198 2
a199 2
		mac68k_register_scsi_irq(
				(void (*)(void *)) ncr53c9x_intr, esc);
d209 2
a210 2
		mac68k_register_scsi_b_irq(
				(void (*)(void *)) ncr53c9x_intr, sc);
@


1.9
log
@mac68k-specific portion of m.i. ncr53c9x driver.
@
text
@d4 2
a5 1
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
d17 2
a18 1
 *	This product includes software developed by Charles M. Hannum.
d72 6
@


1.8
log
@inline -> __inline
@
text
@d91 3
a93 11
#if defined(__sparc__)
#define	SPARC_DRIVER
#include <machine/autoconf.h>
#include <sparc/dev/sbusvar.h>
#include <sparc/dev/dmareg.h>
#include <sparc/dev/dmavar.h>
#include <sparc/dev/espreg.h>
#include <sparc/dev/espvar.h>
#else
#if (_MACHINE == mac68k)
#define MAC68K_DRIVER
a96 12
struct dma_softc {
	struct esp_softc	*sc_esp;
	int		sc_active;
	int		sc_tc;
	int		sc_datain;
	size_t		sc_dmasize;
	size_t		sc_dmatrans;
	char		**sc_dmaaddr;
	size_t		*sc_pdmalen;
};

#include <mac68k/dev/espreg.h>
a97 25
#undef ESPCMD_DMA
#define ESPCMD_DMA	0	/* No DMA */
#undef ESPCMD_TRPAD
#define ESPCMD_TRPAD	0x98 	/* TRPAD needs DMA flag*/

static __inline__ void	dma_intr __P((struct dma_softc *sc));

static __inline__ void
dma_intr(sc)
	struct dma_softc *sc;
{
	register struct esp_softc	*sc_esp;
	register u_char	*p;
	register u_int	espphase, espstat, espintr;
	register int	cnt;

	if (sc->sc_active == 0) {
		printf("dma_intr--inactive DMA\n");
		return;
	}

	if ((sc->sc_esp->sc_espintr & ESPINTR_BS) == 0) {
		sc->sc_active = 0;
		return;
	}
d99 2
a100 85
	cnt = *sc->sc_pdmalen;
	if (*sc->sc_pdmalen == 0) {
		printf("data interrupt, but no count left.");
	}

	p = *sc->sc_dmaaddr;
	sc_esp = sc->sc_esp;
	espphase = sc_esp->sc_phase;
	espstat = (u_int) sc_esp->sc_espstat;
	espintr = (u_int) sc_esp->sc_espintr;
	do {
		if (sc->sc_datain) {
			*p++ = ESP_READ_REG(sc_esp, ESP_FIFO);
			cnt--;
			if (espphase == DATA_IN_PHASE) {
				ESPCMD(sc_esp, ESPCMD_TRANS);
			} else {
				sc->sc_active = 0;
			}
	 	} else {
			if (   (espphase == DATA_OUT_PHASE)
			    || (espphase == MESSAGE_OUT_PHASE)) {
				ESP_WRITE_REG(sc_esp, ESP_FIFO, *p++);
				cnt--;
				ESPCMD(sc_esp, ESPCMD_TRANS);
			} else {
				sc->sc_active = 0;
			}
		}

		if (sc->sc_active) {
			while (!DMA_ISINTR(sc));
			espstat = ESP_READ_REG(sc_esp, ESP_STAT);
			espintr = ESP_READ_REG(sc_esp, ESP_INTR);
			espphase = (espintr & ESPINTR_DIS)
				    ? /* Disconnected */ BUSFREE_PHASE
				    : espstat & ESPSTAT_PHASE;
		}
	} while (sc->sc_active && (espintr & ESPINTR_BS));
	sc_esp->sc_phase = espphase;
	sc_esp->sc_espstat = (u_char) espstat;
	sc_esp->sc_espintr = (u_char) espintr;
	*sc->sc_dmaaddr = p;
	*sc->sc_pdmalen = cnt;

	if (*sc->sc_pdmalen == 0) {
		sc->sc_tc = ESPSTAT_TC;
	}
	sc->sc_esp->sc_espstat |= sc->sc_tc;
}
#else
#include <dev/tc/tcvar.h>
#include <alpha/tc/tcdsvar.h>
#include <alpha/tc/espreg.h>
#include <alpha/tc/espvar.h>
#endif
#endif

int esp_debug = 0; /*ESP_SHOWPHASE|ESP_SHOWMISC|ESP_SHOWTRAC|ESP_SHOWCMDS;*/

/*static*/ void	espattach	__P((struct device *, struct device *, void *));
/*static*/ int	espmatch	__P((struct device *, void *, void *));
/*static*/ u_int	esp_adapter_info __P((struct esp_softc *));
/*static*/ void	espreadregs	__P((struct esp_softc *));
/*static*/ void	esp_select	__P((struct esp_softc *, struct esp_ecb *));
/*static*/ int esp_reselect	__P((struct esp_softc *, int));
/*static*/ void	esp_scsi_reset	__P((struct esp_softc *));
/*static*/ void	esp_reset	__P((struct esp_softc *));
/*static*/ void	esp_init	__P((struct esp_softc *, int));
/*static*/ int	esp_scsi_cmd	__P((struct scsi_xfer *));
/*static*/ int	esp_poll	__P((struct esp_softc *, struct scsi_xfer *, int));
/*static*/ void	esp_sched	__P((struct esp_softc *));
/*static*/ void	esp_done	__P((struct esp_softc *, struct esp_ecb *));
/*static*/ void	esp_msgin	__P((struct esp_softc *));
/*static*/ void	esp_msgout	__P((struct esp_softc *));
/*static*/ int	espintr		__P((struct esp_softc *));
/*static*/ void	esp_timeout	__P((void *arg));
/*static*/ void	esp_abort	__P((struct esp_softc *, struct esp_ecb *));
/*static*/ void esp_dequeue	__P((struct esp_softc *, struct esp_ecb *));
void esp_sense __P((struct esp_softc *, struct esp_ecb *));
void esp_free_ecb __P((struct esp_softc *, struct esp_ecb *, int));
struct esp_ecb *esp_get_ecb __P((struct esp_softc *, int));
static __inline int esp_stp2cpb __P((struct esp_softc *, int));
static __inline int esp_cpb2stp __P((struct esp_softc *, int));
static __inline void esp_setsync __P((struct esp_softc *, struct esp_tinfo *));
d112 1
a112 1
	esp_scsi_cmd,
d125 27
d158 1
a158 12
#ifdef SPARC_DRIVER
	register struct confargs *ca = aux;
	register struct romaux *ra = &ca->ca_ra;

	if (strcmp(cf->cf_driver->cd_name, ra->ra_name))
		return (0);
	if (ca->ca_bustype == BUS_SBUS)
		return (1);
	ra->ra_len = NBPG;
	return (probeget(ra->ra_vaddr, 1) != -1);
#else
#ifdef MAC68K_DRIVER
a163 8
#else
	struct tcdsdev_attach_args *tcdsdev = aux;

	if (strncmp(tcdsdev->tcdsda_modname, "PMAZ-AA ", TC_ROM_LLEN))
		return (0);
	return (!tc_badaddr(tcdsdev->tcdsda_addr));
#endif
#endif
a173 4
#ifdef SPARC_DRIVER
	register struct confargs *ca = aux;
#else
#ifdef MAC68K_DRIVER
d175 2
a176 9
#else
	register struct tcdsdev_attach_args *tcdsdev = aux;
#endif
#endif
	struct esp_softc *sc = (void *)self;
#ifdef SPARC_DRIVER
	struct bootpath *bp;
	int dmachild = strncmp(parent->dv_xname, "dma", 3) == 0;
#endif
a177 1
#ifdef SPARC_DRIVER
d179 1
a179 2
	 * Make sure things are sane. I don't know if this is ever
	 * necessary, but it seem to be in all of Torek's code.
d181 1
a181 7
	if (ca->ca_ra.ra_nintr != 1) {
		printf(": expected 1 interrupt, got %d\n", ca->ca_ra.ra_nintr);
		return;
	}

	sc->sc_pri = ca->ca_ra.ra_intr[0].int_pri;
	printf(" pri %d", sc->sc_pri);
d184 1
a184 2
	 * Map my registers in, if they aren't already in virtual
	 * address space.
a185 8
	if (ca->ca_ra.ra_vaddr)
		sc->sc_reg = (volatile u_char *) ca->ca_ra.ra_vaddr;
	else {
		sc->sc_reg = (volatile u_char *)
		    mapiodev(ca->ca_ra.ra_reg, 0, ca->ca_ra.ra_len, ca->ca_bustype);
	}
#else
#ifdef MAC68K_DRIVER
d189 4
a192 3
		sc->sc_reg = (volatile u_char *) SCSIBase;
		mac68k_register_scsi_irq((void (*)(void *)) espintr, sc);
		sc->irq_mask = V2IF_SCSIIRQ;
d200 4
a203 3
		sc->sc_reg = (volatile u_char *) SCSIBase + 0x402;
		mac68k_register_scsi_b_irq((void (*)(void *)) espintr, sc);
		sc->irq_mask = V2IF_SCSIDRQ; /* V2IF_T1? */
d206 2
a207 2
	sc->sc_dma = &sc->_sc_dma;
	printf(": address %p", sc->sc_reg);
a209 37
#else
	sc->sc_reg = (volatile u_int32_t *)tcdsdev->tcdsda_addr;
	sc->sc_cookie = tcdsdev->tcdsda_cookie;
	sc->sc_dma = tcdsdev->tcdsda_sc;

	printf(": address %x", sc->sc_reg);
	tcds_intr_establish(parent, sc->sc_cookie, TC_IPL_BIO,
	    (int (*)(void *))espintr, sc);
#endif
#endif

#ifdef SPARC_DRIVER
	/* Other settings */
	sc->sc_node = ca->ca_ra.ra_node;
	if (ca->ca_bustype == BUS_SBUS) {
		sc->sc_id = getpropint(sc->sc_node, "initiator-id", 7);
		sc->sc_freq = getpropint(sc->sc_node, "clock-frequency", -1);
	} else {
		sc->sc_id = 7;
		sc->sc_freq = 24000000;
	}
	if (sc->sc_freq < 0)
		sc->sc_freq = ((struct sbus_softc *)
		    sc->sc_dev.dv_parent)->sc_clockfreq;
#else
#ifdef MAC68K_DRIVER
#else
	if (parent->dv_cfdata->cf_driver == &tcds_cd) {
		sc->sc_id = tcdsdev->tcdsda_id;
		sc->sc_freq = tcdsdev->tcdsda_freq;
	} else {
		/* XXX */
		sc->sc_id = 7;
		sc->sc_freq = 24000000;
	}
#endif
#endif
a213 30
#ifdef SPARC_DRIVER
	if (dmachild) {
		sc->sc_dma = (struct dma_softc *)parent;
		sc->sc_dma->sc_esp = sc;
	} else {
		/*
		 * find the DMA by poking around the dma device structures
		 *
		 * What happens here is that if the dma driver has not been
		 * configured, then this returns a NULL pointer. Then when the
		 * dma actually gets configured, it does the opposing test, and
		 * if the sc->sc_esp field in it's softc is NULL, then tries to
		 * find the matching esp driver.
		 *
		 */
		sc->sc_dma = (struct dma_softc *)
			getdevunit("dma", sc->sc_dev.dv_unit);

		/*
		 * and a back pointer to us, for DMA
		 */
		if (sc->sc_dma)
			sc->sc_dma->sc_esp = sc;
		else
			panic("espattach: no dma found");
	}
#else
	sc->sc_dma->sc_esp = sc;		/* XXX */
#endif

d219 2
a220 31
	sc->sc_cfg1 = sc->sc_id | ESPCFG1_PARENB;
#ifdef SPARC_DRIVER
	sc->sc_cfg2 = ESPCFG2_SCSI2 | ESPCFG2_RPE;
	sc->sc_cfg3 = ESPCFG3_CDB;
	ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);

	if ((ESP_READ_REG(sc, ESP_CFG2) & ~ESPCFG2_RSVD) != (ESPCFG2_SCSI2 | ESPCFG2_RPE)) {
		printf(": ESP100");
		sc->sc_rev = ESP100;
	} else {
		sc->sc_cfg2 = ESPCFG2_SCSI2;
		ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);
		sc->sc_cfg3 = 0;
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
		sc->sc_cfg3 = (ESPCFG3_CDB | ESPCFG3_FCLK);
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
		if (ESP_READ_REG(sc, ESP_CFG3) != (ESPCFG3_CDB | ESPCFG3_FCLK)) {
			printf(": ESP100A");
			sc->sc_rev = ESP100A;
		} else {
			/* ESPCFG2_FE enables > 64K transfers */
			sc->sc_cfg2 |= ESPCFG2_FE;
			sc->sc_cfg3 = 0;
			ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
			printf(": ESP200");
			sc->sc_rev = ESP200;
		}
	}
#else
#ifdef MAC68K_DRIVER
	sc->sc_cfg2 = ESPCFG2_SCSI2;
d222 1
a222 9
	printf(": NCR53C96");
	sc->sc_rev = NCR53C96;
#else
	sc->sc_cfg2 = ESPCFG2_SCSI2;
	sc->sc_cfg3 = 0x4;		/* Save residual byte. XXX??? */
	printf(": NCR53C94");
	sc->sc_rev = NCR53C94;
#endif
#endif
d226 1
a226 1
	 * Note that the ESP register "SYNCTP" is programmed
a234 21
#ifdef SPARC_DRIVER
	/*
	 * Alas, we must now modify the value a bit, because it's
	 * only valid when can switch on FASTCLK and FASTSCSI bits
	 * in config register 3...
	 */
	switch (sc->sc_rev) {
	case ESP100:
		sc->sc_maxxfer = 64 * 1024;
		sc->sc_minsync = 0;	/* No synch on old chip? */
		break;
	case ESP100A:
		sc->sc_maxxfer = 64 * 1024;
		sc->sc_minsync = esp_cpb2stp(sc, 5); /* Min clocks/byte is 5 */
		break;
	case ESP200:
		sc->sc_maxxfer = 16 * 1024 * 1024;
		/* XXX - do actually set FAST* bits */
	}
#else
#ifdef MAC68K_DRIVER
a237 10
#else
	sc->sc_maxxfer = 64 * 1024;
#endif
#endif

	sc->sc_ccf = FREQTOCCF(sc->sc_freq);

	/* The value *must not* be == 1. Make it 2 */
	if (sc->sc_ccf == 1)
		sc->sc_ccf = 2;
d240 1
a240 56
	 * The recommended timeout is 250ms. This register is loaded
	 * with a value calculated as follows, from the docs:
	 *
	 *		(timout period) x (CLK frequency)
	 *	reg = -------------------------------------
	 *		 8192 x (Clock Conversion Factor)
	 *
	 * Since CCF has a linear relation to CLK, this generally computes
	 * to the constant of 153.
	 */
	sc->sc_timeout = ((250 * 1000) * sc->sc_freq) / (8192 * sc->sc_ccf);

	/* CCF register only has 3 bits; 0 is actually 8 */
	sc->sc_ccf &= 7;

	/* Reset state & bus */
	sc->sc_state = 0;
	esp_init(sc, 1);

	printf(" %dMhz, target %d\n", sc->sc_freq, sc->sc_id);

#ifdef SPARC_DRIVER
	/* add me to the sbus structures */
	sc->sc_sd.sd_reset = (void *) esp_reset;
#if defined(SUN4C) || defined(SUN4M)
	if (ca->ca_bustype == BUS_SBUS) {
		if (dmachild)
			sbus_establish(&sc->sc_sd, sc->sc_dev.dv_parent);
		else
			sbus_establish(&sc->sc_sd, &sc->sc_dev);
	}
#endif /* SUN4C || SUN4M */
#endif

#ifdef SPARC_DRIVER
	/* and the interuppts */
	sc->sc_ih.ih_fun = (void *) espintr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(sc->sc_pri, &sc->sc_ih);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
#endif

	/*
	 * fill in the prototype scsi_link.
	sc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_id;
	sc->sc_link.adapter = &esp_switch;
	sc->sc_link.device = &esp_dev;
	sc->sc_link.openings = 2;

	/*
	 * If the boot path is "esp" at the moment and it's me, then
	 * walk our pointer to the sub-device, ready for the config
	 * below.
d242 1
a242 15
#ifdef SPARC_DRIVER
	bp = ca->ca_ra.ra_bp;
	switch (ca->ca_bustype) {
	case BUS_SBUS:
		if (bp != NULL && strcmp(bp->name, "esp") == 0 &&
		    SAME_ESP(sc, bp, ca))
			bootpath_store(1, bp + 1);
		break;
	default:
		if (bp != NULL && strcmp(bp->name, "esp") == 0 &&
			bp->val[0] == -1 && bp->val[1] == sc->sc_dev.dv_unit)
			bootpath_store(1, bp + 1);
		break;
	}
#endif
d245 1
a245 1
	 * Now try to attach all the sub-devices
a246 3
	config_found(self, &sc->sc_link, scsiprint);

#ifdef MAC68K_DRIVER
d248 2
a249 6
	via2_reg(vIFR) = sc->irq_mask;
	via2_reg(vIER) = 0x80 | sc->irq_mask;
#endif
#ifdef SPARC_DRIVER
	bootpath_store(1, NULL);
#endif
d253 1
a253 6
 * This is the generic esp reset function. It does not reset the SCSI bus,
 * only this controllers, but kills any on-going commands, and also stops
 * and resets the DMA.
 *
 * After reset, registers are loaded with the defaults from the attach
 * routine above.
a254 38
void
esp_reset(sc)
	struct esp_softc *sc;
{

	/* reset DMA first */
	DMA_RESET(sc->sc_dma);

	/* reset SCSI chip */
	ESPCMD(sc, ESPCMD_RSTCHIP);
	ESPCMD(sc, ESPCMD_NOP);
	DELAY(500);

	/* do these backwards, and fall through */
	switch (sc->sc_rev) {
#ifndef SPARC_DRIVER
	case NCR53C96:
	case NCR53C94:
#endif
	case ESP200:
		ESP_WRITE_REG(sc, ESP_CFG3, sc->sc_cfg3);
	case ESP100A:
		ESP_WRITE_REG(sc, ESP_CFG2, sc->sc_cfg2);
	case ESP100:
		ESP_WRITE_REG(sc, ESP_CFG1, sc->sc_cfg1);
		ESP_WRITE_REG(sc, ESP_CCF, sc->sc_ccf);
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_TIMEOUT, sc->sc_timeout);
		break;
	default:
		printf("%s: unknown revision code, assuming ESP100\n",
		    sc->sc_dev.dv_xname);
		ESP_WRITE_REG(sc, ESP_CFG1, sc->sc_cfg1);
		ESP_WRITE_REG(sc, ESP_CCF, sc->sc_ccf);
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_TIMEOUT, sc->sc_timeout);
	}
}
d256 4
a259 6
/*
 * Reset the SCSI bus, but not the chip
 */
void
esp_scsi_reset(sc)
	struct esp_softc *sc;
d261 1
a261 8
#ifdef SPARC_DRIVER
	/* stop DMA first, as the chip will return to Bus Free phase */
	DMACSR(sc->sc_dma) &= ~D_EN_DMA;
#else
	/*
	 * XXX STOP DMA FIRST
	 */
#endif
d263 1
a263 2
	printf("esp: resetting SCSI bus\n");
	ESPCMD(sc, ESPCMD_RSTSCSI);
a265 3
/*
 * Initialize esp state machine
 */
d267 4
a270 3
esp_init(sc, doreset)
	struct esp_softc *sc;
	int doreset;
d272 2
a273 2
	struct esp_ecb *ecb;
	int r;
d275 2
a276 54
	ESP_TRACE(("[ESP_INIT(%d)] ", doreset));

	if (sc->sc_state == 0) {
		/* First time through; initialize. */
		TAILQ_INIT(&sc->ready_list);
		TAILQ_INIT(&sc->nexus_list);
		TAILQ_INIT(&sc->free_list);
		sc->sc_nexus = NULL;
		ecb = sc->sc_ecb;
		bzero(ecb, sizeof(sc->sc_ecb));
		for (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {
			TAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);
			ecb++;
		}
		bzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));
	} else {
		/* Cancel any active commands. */
		sc->sc_state = ESP_CLEANING;
		if ((ecb = sc->sc_nexus) != NULL) {
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, ecb);
			esp_done(sc, ecb);
		}
		while ((ecb = sc->nexus_list.tqh_first) != NULL) {
			ecb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(esp_timeout, ecb);
			esp_done(sc, ecb);
		}
	}

	/*
	 * reset the chip to a known state
	 */
	esp_reset(sc);

	sc->sc_phase = sc->sc_prevphase = INVALID_PHASE;
	for (r = 0; r < 8; r++) {
		struct esp_tinfo *ti = &sc->sc_tinfo[r];
/* XXX - config flags per target: low bits: no reselect; high bits: no synch */
		int fl = sc->sc_dev.dv_cfdata->cf_flags;

		ti->flags = ((sc->sc_minsync && !(fl & (1<<(r+8))))
				? T_NEGOTIATE : 0) |
				((fl & (1<<r)) ? T_RSELECTOFF : 0) |
				T_NEED_TO_RESET;
		ti->period = sc->sc_minsync;
		ti->offset = 0;
	}

	if (doreset) {
		sc->sc_state = ESP_SBR;
		ESPCMD(sc, ESPCMD_RSTSCSI);
	} else {
		sc->sc_state = ESP_IDLE;
d278 1
d281 3
a283 44
/*
 * Read the ESP registers, and save their contents for later use.
 * ESP_STAT, ESP_STEP & ESP_INTR are mostly zeroed out when reading
 * ESP_INTR - so make sure it is the last read.
 *
 * I think that (from reading the docs) most bits in these registers
 * only make sense when he DMA CSR has an interrupt showing. Call only
 * if an interrupt is pending.
 */
void
espreadregs(sc)
	struct esp_softc *sc;
{

	sc->sc_espstat = ESP_READ_REG(sc, ESP_STAT);
	/* Only the stepo bits are of interest */
	sc->sc_espstep = ESP_READ_REG(sc, ESP_STEP) & ESPSTEP_MASK;
	sc->sc_espintr = ESP_READ_REG(sc, ESP_INTR);

#if !defined(SPARC_DRIVER) && !defined(MAC68K_DRIVER)
	/* Clear the TCDS interrupt bit. */
	(void)tcds_scsi_isintr(sc->sc_dma, 1);
#endif

	/*
	 * Determine the SCSI bus phase, return either a real SCSI bus phase
	 * or some pseudo phase we use to detect certain exceptions.
	 */

	sc->sc_phase = (sc->sc_espintr & ESPINTR_DIS)
			? /* Disconnected */ BUSFREE_PHASE
			: sc->sc_espstat & ESPSTAT_PHASE;

	ESP_MISC(("regs[intr=%02x,stat=%02x,step=%02x] ",
		sc->sc_espintr, sc->sc_espstat, sc->sc_espstep));
}

/*
 * Convert chip register Clock Per Byte value to Synchronous Transfer Period.
 */
static __inline int
esp_cpb2stp(sc, cpb)
	struct esp_softc *sc;
	int cpb;
d285 1
a285 65
	return ((250 * cpb) / sc->sc_freq);
}

/*
 * Convert Synchronous Transfer Period to chip register Clock Per Byte value.
 */
static __inline int
esp_stp2cpb(sc, period)
	struct esp_softc *sc;
	int period;
{
	int v;
	v = (sc->sc_freq * period) / 250;
	if (esp_cpb2stp(sc, v) < period)
		/* Correct round-down error */
		v++;
	return v;
}

static __inline void
esp_setsync(sc, ti)
	struct esp_softc *sc;
	struct esp_tinfo *ti;
{

	if (ti->flags & T_SYNCMODE) {
		ESP_WRITE_REG(sc, ESP_SYNCOFF, ti->offset);
		ESP_WRITE_REG(sc, ESP_SYNCTP, esp_stp2cpb(sc, ti->period));
	} else {
		ESP_WRITE_REG(sc, ESP_SYNCOFF, 0);
		ESP_WRITE_REG(sc, ESP_SYNCTP, 0);
	}
}

/*
 * Send a command to a target, set the driver state to ESP_SELECTING
 * and let the caller take care of the rest.
 *
 * Keeping this as a function allows me to say that this may be done
 * by DMA instead of programmed I/O soon.
 */
void
esp_select(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{
	struct scsi_link *sc_link = ecb->xs->sc_link;
	int target = sc_link->target;
	struct esp_tinfo *ti = &sc->sc_tinfo[target];
	u_char *cmd;
	int clen;

	ESP_TRACE(("[esp_select(t%d,l%d,cmd:%x)] ", sc_link->target, sc_link->lun, ecb->cmd.opcode));

	/* new state ESP_SELECTING */
	sc->sc_state = ESP_SELECTING;

	ESPCMD(sc, ESPCMD_FLUSH);

	/*
	 * The docs say the target register is never reset, and I
	 * can't think of a better place to set it
	 */
	ESP_WRITE_REG(sc, ESP_SELID, target);
	esp_setsync(sc, ti);
d287 1
a287 21
	/*
	 * Who am I. This is where we tell the target that we are
	 * happy for it to disconnect etc.
	 */
	ESP_WRITE_REG(sc, ESP_FIFO,
		MSG_IDENTIFY(sc_link->lun, (ti->flags & T_RSELECTOFF)?0:1));

	if (ti->flags & T_NEGOTIATE) {
		/* Arbitrate, select and stop after IDENTIFY message */
		ESPCMD(sc, ESPCMD_SELATNS);
		return;
	}

	/* Now the command into the FIFO */
	cmd = (u_char *)&ecb->cmd;
	clen = ecb->clen;
	while (clen--)
		ESP_WRITE_REG(sc, ESP_FIFO, *cmd++);

	/* And get the targets attention */
	ESPCMD(sc, ESPCMD_SELATN);
d291 2
a292 4
esp_free_ecb(sc, ecb, flags)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
	int flags;
d294 1
a294 1
	int s;
d296 2
a297 13
	s = splbio();

	ecb->flags = 0;
	TAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (ecb->chain.tqe_next == 0)
		wakeup(&sc->free_list);

	splx(s);
d300 3
a302 4
struct esp_ecb *
esp_get_ecb(sc, flags)
	struct esp_softc *sc;
	int flags;
d304 5
a308 2
	struct esp_ecb *ecb;
	int s;
d310 3
a312 40
	s = splbio();

	while ((ecb = sc->free_list.tqh_first) == NULL &&
	       (flags & SCSI_NOSLEEP) == 0)
		tsleep(&sc->free_list, PRIBIO, "especb", 0);
	if (ecb) {
		TAILQ_REMOVE(&sc->free_list, ecb, chain);
		ecb->flags |= ECB_ALLOC;
	}

	splx(s);
	return ecb;
}

/*
 * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS
 */

/*
 * Start a SCSI-command
 * This function is called by the higher level SCSI-driver to queue/run
 * SCSI-commands.
 */
int
esp_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_softc *sc = sc_link->adapter_softc;
	struct esp_ecb *ecb;
	int s, flags;

	ESP_TRACE(("[esp_scsi_cmd] "));
	ESP_CMDS(("[0x%x, %d]->%d ", (int)xs->cmd->opcode, xs->cmdlen,
	    sc_link->target));

	flags = xs->flags;
	if ((ecb = esp_get_ecb(sc, flags)) == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		return TRY_AGAIN_LATER;
d315 3
a317 13
	/* Initialize ecb */
	ecb->xs = xs;
	ecb->timeout = xs->timeout;

	if (xs->flags & SCSI_RESET) {
		ecb->flags |= ECB_RESET;
		ecb->clen = 0;
		ecb->dleft = 0;
	} else {
		bcopy(xs->cmd, &ecb->cmd, xs->cmdlen);
		ecb->clen = xs->cmdlen;
		ecb->daddr = xs->data;
		ecb->dleft = xs->datalen;
a318 1
	ecb->stat = 0;
d320 3
a322 16
	s = splbio();

	TAILQ_INSERT_TAIL(&sc->ready_list, ecb, chain);
	if (sc->sc_state == ESP_IDLE)
		esp_sched(sc);

	splx(s);

	if ((flags & SCSI_POLL) == 0)
		return SUCCESSFULLY_QUEUED;

	/* Not allowed to use interrupts, use polling instead */
	if (esp_poll(sc, xs, ecb->timeout)) {
		esp_timeout(ecb);
		if (esp_poll(sc, xs, ecb->timeout))
			esp_timeout(ecb);
a323 2
	return COMPLETE;
}
d325 26
a350 24
/*
 * Used when interrupt driven I/O isn't allowed, e.g. during boot.
 */
int
esp_poll(sc, xs, count)
	struct esp_softc *sc;
	struct scsi_xfer *xs;
	int count;
{

	ESP_TRACE(("[esp_poll] "));
	while (count) {
		if (DMA_ISINTR(sc->sc_dma)) {
			espintr(sc);
		}
#if alternatively
		if (ESP_READ_REG(sc, ESP_STAT) & ESPSTAT_INT)
			espintr(sc);
#endif
		if ((xs->flags & ITSDONE) != 0)
			return 0;
		if (sc->sc_state == ESP_IDLE) {
			ESP_TRACE(("[esp_poll: rescheduling] "));
			esp_sched(sc);
a351 5
		DELAY(1000);
		count--;
	}
	return 1;
}
d353 7
a359 109

/*
 * LOW LEVEL SCSI UTILITIES
 */

/*
 * Schedule a scsi operation.  This has now been pulled out of the interrupt
 * handler so that we may call it from esp_scsi_cmd and esp_done.  This may
 * save us an unecessary interrupt just to get things going.  Should only be
 * called when state == ESP_IDLE and at bio pl.
 */
void
esp_sched(sc)
	struct esp_softc *sc;
{
	struct esp_ecb *ecb;
	struct scsi_link *sc_link;
	struct esp_tinfo *ti;

	ESP_TRACE(("[esp_sched] "));
	if (sc->sc_state != ESP_IDLE)
		panic("esp_sched: not IDLE (state=%d)", sc->sc_state);

	/*
	 * Find first ecb in ready queue that is for a target/lunit
	 * combinations that is not busy.
	 */
	for (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {
		sc_link = ecb->xs->sc_link;
		ti = &sc->sc_tinfo[sc_link->target];
		if ((ti->lubusy & (1 << sc_link->lun)) == 0) {
			TAILQ_REMOVE(&sc->ready_list, ecb, chain);
			sc->sc_nexus = ecb;
			esp_select(sc, ecb);
			break;
		} else
			ESP_MISC(("%d:%d busy\n",
			    sc_link->target, sc_link->lun));
	}
}

void
esp_sense(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_tinfo *ti = &sc->sc_tinfo[sc_link->target];
	struct scsi_sense *ss = (void *)&ecb->cmd;

	ESP_MISC(("requesting sense "));
	/* Next, setup a request sense command block */
	bzero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = sc_link->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);
	ecb->clen = sizeof(*ss);
	ecb->daddr = (char *)&xs->sense;
	ecb->dleft = sizeof(struct scsi_sense_data);
	ecb->flags |= ECB_SENSE;
	ti->senses++;
	if (ecb->flags & ECB_NEXUS)
		ti->lubusy &= ~(1 << sc_link->lun);
	if (ecb == sc->sc_nexus) {
		esp_select(sc, ecb);
	} else {
		esp_dequeue(sc, ecb);
		TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
		if (sc->sc_state == ESP_IDLE)
			esp_sched(sc);
	}
}

/*
 * POST PROCESSING OF SCSI_CMD (usually current)
 */
void
esp_done(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_tinfo *ti = &sc->sc_tinfo[sc_link->target];

	ESP_TRACE(("[esp_done(error:%x)] ", xs->error));

	/*
	 * Now, if we've come here with no error code, i.e. we've kept the
	 * initial XS_NOERROR, and the status code signals that we should
	 * check sense, we'll need to set up a request sense cmd block and
	 * push the command back into the ready queue *before* any other
	 * commands for this target/lunit, else we lose the sense info.
	 * We don't support chk sense conditions for the request sense cmd.
	 */
	if (xs->error == XS_NOERROR) {
		if ((ecb->flags & ECB_ABORT) != 0) {
			xs->error = XS_DRIVER_STUFFUP;
		} else if ((ecb->flags & ECB_SENSE) != 0) {
			xs->error = XS_SENSE;
		} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {
			/* First, save the return values */
			xs->resid = ecb->dleft;
			xs->status = ecb->stat;
			esp_sense(sc, ecb);
			return;
		} else {
			xs->resid = ecb->dleft;
d361 6
a366 1
	}
d368 2
a369 10
	xs->flags |= ITSDONE;

#if ESP_DEBUG > 0
	if (esp_debug & ESP_SHOWMISC) {
		if (xs->resid != 0)
			printf("resid=%d ", xs->resid);
		if (xs->error == XS_SENSE)
			printf("sense=0x%02x\n", xs->sense.error_code);
		else
			printf("error=%d\n", xs->error);
d371 2
a372 17
#endif

	/*
	 * Remove the ECB from whatever queue it's on.
	 */
	if (ecb->flags & ECB_NEXUS)
		ti->lubusy &= ~(1 << sc_link->lun);
	if (ecb == sc->sc_nexus) {
		sc->sc_nexus = NULL;
		sc->sc_state = ESP_IDLE;
		esp_sched(sc);
	} else
		esp_dequeue(sc, ecb);
		
	esp_free_ecb(sc, ecb, xs->flags);
	ti->cmds++;
	scsi_done(xs);
a374 30
void
esp_dequeue(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
{

	if (ecb->flags & ECB_NEXUS) {
		TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
	} else {
		TAILQ_REMOVE(&sc->ready_list, ecb, chain);
	}
}

/*
 * INTERRUPT/PROTOCOL ENGINE
 */

/*
 * Schedule an outgoing message by prioritizing it, and asserting
 * attention on the bus. We can only do this when we are the initiator
 * else there will be an illegal command interrupt.
 */
#define esp_sched_msgout(m) \
	do {						\
		ESP_MISC(("esp_sched_msgout %d ", m));	\
		ESPCMD(sc, ESPCMD_SETATN);		\
		sc->sc_flags |= ESP_ATN;		\
		sc->sc_msgpriq |= (m);			\
	} while (0)

d376 6
a381 3
esp_reselect(sc, message)
	struct esp_softc *sc;
	int message;
d383 1
a383 4
	u_char selid, target, lun;
	struct esp_ecb *ecb;
	struct scsi_link *sc_link;
	struct esp_tinfo *ti;
d385 5
a389 11
	/*
	 * The SCSI chip made a snapshot of the data bus while the reselection
	 * was being negotiated.  This enables us to determine which target did
	 * the reselect.
	 */
	selid = sc->sc_selid & ~(1 << sc->sc_id);
	if (selid & (selid - 1)) {
		printf("%s: reselect with invalid selid %02x; sending DEVICE RESET\n",
		    sc->sc_dev.dv_xname, selid);
		goto reset;
	}
d391 1
a391 46
	/*
	 * Search wait queue for disconnected cmd
	 * The list should be short, so I haven't bothered with
	 * any more sophisticated structures than a simple
	 * singly linked list.
	 */
	target = ffs(selid) - 1;
	lun = message & 0x07;
	for (ecb = sc->nexus_list.tqh_first; ecb != NULL;
	     ecb = ecb->chain.tqe_next) {
		sc_link = ecb->xs->sc_link;
		if (sc_link->target == target && sc_link->lun == lun)
			break;
	}
	if (ecb == NULL) {
		printf("%s: reselect from target %d lun %d with no nexus; sending ABORT\n",
		    sc->sc_dev.dv_xname, target, lun);
		goto abort;
	}

	/* Make this nexus active again. */
	TAILQ_REMOVE(&sc->nexus_list, ecb, chain);
	sc->sc_state = ESP_CONNECTED;
	sc->sc_nexus = ecb;
	ti = &sc->sc_tinfo[target];
	ti->lubusy |= (1 << lun);
	esp_setsync(sc, ti);

	if (ecb->flags & ECB_RESET)
		esp_sched_msgout(SEND_DEV_RESET);
	else if (ecb->flags & ECB_ABORT)
		esp_sched_msgout(SEND_ABORT);

	/* Do an implicit RESTORE POINTERS. */
	sc->sc_dp = ecb->daddr;
	sc->sc_dleft = ecb->dleft;

	return (0);

reset:
	esp_sched_msgout(SEND_DEV_RESET);
	return (1);

abort:
	esp_sched_msgout(SEND_ABORT);
	return (1);
a393 10
#define IS1BYTEMSG(m) (((m) != 1 && (m) < 0x20) || (m) & 0x80)
#define IS2BYTEMSG(m) (((m) & 0xf0) == 0x20)
#define ISEXTMSG(m) ((m) == 1)

/*
 * Get an incoming message as initiator.
 *
 * The SCSI bus must already be in MESSAGE_IN_PHASE and there is a
 * byte in the FIFO
 */
d395 2
a396 2
esp_msgin(sc)
	register struct esp_softc *sc;
d398 1
a398 1
	register int v;
d400 4
a403 30
	ESP_TRACE(("[esp_msgin(curmsglen:%d)] ", sc->sc_imlen));

	if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) == 0) {
		printf("%s: msgin: no msg byte available\n",
			sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Prepare for a new message.  A message should (according
	 * to the SCSI standard) be transmitted in one single
	 * MESSAGE_IN_PHASE. If we have been in some other phase,
	 * then this is a new message.
	 */
	if (sc->sc_prevphase != MESSAGE_IN_PHASE) {
		sc->sc_flags &= ~ESP_DROP_MSGI;
		sc->sc_imlen = 0;
	}

	v = ESP_READ_REG(sc, ESP_FIFO);
	ESP_MISC(("<msgbyte:0x%02x>", v));

#if 0
	if (sc->sc_state == ESP_RESELECTED && sc->sc_imlen == 0) {
		/*
		 * Which target is reselecting us? (The ID bit really)
		 */
		sc->sc_selid = v;
		ESP_MISC(("selid=0x%2x ", sc->sc_selid));
		return;
d405 1
a405 207
#endif

	sc->sc_imess[sc->sc_imlen] = v;

	/*
	 * If we're going to reject the message, don't bother storing
	 * the incoming bytes.  But still, we need to ACK them.
	 */

	if ((sc->sc_flags & ESP_DROP_MSGI)) {
		ESPCMD(sc, ESPCMD_MSGOK);
		printf("<dropping msg byte %x>",
			sc->sc_imess[sc->sc_imlen]);
		return;
	}

	if (sc->sc_imlen >= ESP_MAX_MSG_LEN) {
		esp_sched_msgout(SEND_REJECT);
		sc->sc_flags |= ESP_DROP_MSGI;
	} else {
		sc->sc_imlen++;
		/*
		 * This testing is suboptimal, but most
		 * messages will be of the one byte variety, so
		 * it should not effect performance
		 * significantly.
		 */
		if (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))
			goto gotit;
		if (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))
			goto gotit;
		if (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&
		    sc->sc_imlen == sc->sc_imess[1] + 2)
			goto gotit;
	}
	/* Ack what we have so far */
	ESPCMD(sc, ESPCMD_MSGOK);
	return;

gotit:
	ESP_MSGS(("gotmsg(%x)", sc->sc_imess[0]));
	/*
	 * Now we should have a complete message (1 byte, 2 byte
	 * and moderately long extended messages).  We only handle
	 * extended messages which total length is shorter than
	 * ESP_MAX_MSG_LEN.  Longer messages will be amputated.
	 */
	switch (sc->sc_state) {
		struct esp_ecb *ecb;
		struct esp_tinfo *ti;

	case ESP_CONNECTED:
		ecb = sc->sc_nexus;
		ti = &sc->sc_tinfo[ecb->xs->sc_link->target];

		switch (sc->sc_imess[0]) {
		case MSG_CMDCOMPLETE:
			ESP_MSGS(("cmdcomplete "));
			if (sc->sc_dleft < 0) {
				struct scsi_link *sc_link = ecb->xs->sc_link;
				printf("%s: %d extra bytes from %d:%d\n",
				    sc->sc_dev.dv_xname, -sc->sc_dleft,
				    sc_link->target, sc_link->lun);
				sc->sc_dleft = 0;
			}
			ecb->xs->resid = ecb->dleft = sc->sc_dleft;
			sc->sc_state = ESP_CMDCOMPLETE;
			break;

		case MSG_MESSAGE_REJECT:
			if (esp_debug & ESP_SHOWMSGS)
				printf("%s: our msg rejected by target\n",
				    sc->sc_dev.dv_xname);
			switch (sc->sc_msgout) {
			case SEND_SDTR:
				sc->sc_flags &= ~ESP_SYNCHNEGO;
				ti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);
				esp_setsync(sc, ti);
				break;
			case SEND_INIT_DET_ERR:
				goto abort;
			}
			break;

		case MSG_NOOP:
			ESP_MSGS(("noop "));
			break;

		case MSG_DISCONNECT:
			ESP_MSGS(("disconnect "));
			ti->dconns++;
			sc->sc_state = ESP_DISCONNECT;
			if ((ecb->xs->sc_link->quirks & SDEV_AUTOSAVE) == 0)
				break;
			/*FALLTHROUGH*/

		case MSG_SAVEDATAPOINTER:
			ESP_MSGS(("save datapointer "));
			ecb->daddr = sc->sc_dp;
			ecb->dleft = sc->sc_dleft;
			break;

		case MSG_RESTOREPOINTERS:
			ESP_MSGS(("restore datapointer "));
			sc->sc_dp = ecb->daddr;
			sc->sc_dleft = ecb->dleft;
			break;

		case MSG_EXTENDED:
			ESP_MSGS(("extended(%x) ", sc->sc_imess[2]));
			switch (sc->sc_imess[2]) {
			case MSG_EXT_SDTR:
				ESP_MSGS(("SDTR period %d, offset %d ",
					sc->sc_imess[3], sc->sc_imess[4]));
				if (sc->sc_imess[1] != 3)
					goto reject;
				ti->period = sc->sc_imess[3];
				ti->offset = sc->sc_imess[4];
				ti->flags &= ~T_NEGOTIATE;
				if (sc->sc_minsync == 0 ||
				    ti->offset == 0 ||
				    ti->period > 124) {
					printf("%s:%d: async\n", "esp",
						ecb->xs->sc_link->target);
					if ((sc->sc_flags&ESP_SYNCHNEGO) == 0) {
						/* target initiated negotiation */
						ti->offset = 0;
						ti->flags &= ~T_SYNCMODE;
						esp_sched_msgout(SEND_SDTR);
					} else {
						/* we are async */
						ti->flags &= ~T_SYNCMODE;
					}
				} else {
					int r = 250/ti->period;
					int s = (100*250)/ti->period - 100*r;
					int p;

					p =  esp_stp2cpb(sc, ti->period);
					ti->period = esp_cpb2stp(sc, p);
#ifdef ESP_DEBUG
					sc_print_addr(ecb->xs->sc_link);
					printf("max sync rate %d.%02dMb/s\n",
						r, s);
#endif
					if ((sc->sc_flags&ESP_SYNCHNEGO) == 0) {
						/* target initiated negotiation */
						if (ti->period < sc->sc_minsync)
							ti->period = sc->sc_minsync;
						if (ti->offset > 15)
							ti->offset = 15;
						ti->flags &= ~T_SYNCMODE;
						esp_sched_msgout(SEND_SDTR);
					} else {
						/* we are sync */
						ti->flags |= T_SYNCMODE;
					}
				}
				sc->sc_flags &= ~ESP_SYNCHNEGO;
				esp_setsync(sc, ti);
				break;

			default:
				printf("%s: unrecognized MESSAGE EXTENDED; sending REJECT\n",
				    sc->sc_dev.dv_xname);
				goto reject;
			}
			break;

		default:
			ESP_MSGS(("ident "));
			printf("%s: unrecognized MESSAGE; sending REJECT\n",
			    sc->sc_dev.dv_xname);
		reject:
			esp_sched_msgout(SEND_REJECT);
			break;
		}
		break;

	case ESP_RESELECTED:
		if (!MSG_ISIDENTIFY(sc->sc_imess[0])) {
			printf("%s: reselect without IDENTIFY; sending DEVICE RESET\n",
			    sc->sc_dev.dv_xname);
			goto reset;
		}

		(void) esp_reselect(sc, sc->sc_imess[0]);
		break;

	default:
		printf("%s: unexpected MESSAGE IN; sending DEVICE RESET\n",
		    sc->sc_dev.dv_xname);
	reset:
		esp_sched_msgout(SEND_DEV_RESET);
		break;

	abort:
		esp_sched_msgout(SEND_ABORT);
		break;
	}

	/* Ack last message byte */
	ESPCMD(sc, ESPCMD_MSGOK);

	/* Done, reset message pointer. */
	sc->sc_flags &= ~ESP_DROP_MSGI;
	sc->sc_imlen = 0;
a407 4

/*
 * Send the highest priority, scheduled message
 */
d409 2
a410 2
esp_msgout(sc)
	register struct esp_softc *sc;
a411 105
	struct esp_tinfo *ti;
	struct esp_ecb *ecb;
	size_t size;

	ESP_TRACE(("[esp_msgout(priq:%x, prevphase:%x)]", sc->sc_msgpriq, sc->sc_prevphase));

	if (sc->sc_flags & ESP_ATN) {
		if (sc->sc_prevphase != MESSAGE_OUT_PHASE) {
		new:
			ESPCMD(sc, ESPCMD_FLUSH);
			DELAY(1);
			sc->sc_msgoutq = 0;
			sc->sc_omlen = 0;
		}
	} else {
		if (sc->sc_prevphase == MESSAGE_OUT_PHASE) {
			esp_sched_msgout(sc->sc_msgoutq);
			goto new;
		} else {
			printf("esp at line %d: unexpected MESSAGE OUT phase\n", __LINE__);
		}
	}
			
	if (sc->sc_omlen == 0) {
		/* Pick up highest priority message */
		sc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;
		sc->sc_msgoutq |= sc->sc_msgout;
		sc->sc_msgpriq &= ~sc->sc_msgout;
		sc->sc_omlen = 1;		/* "Default" message len */
		switch (sc->sc_msgout) {
		case SEND_SDTR:
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			sc->sc_omess[0] = MSG_EXTENDED;
			sc->sc_omess[1] = 3;
			sc->sc_omess[2] = MSG_EXT_SDTR;
			sc->sc_omess[3] = ti->period;
			sc->sc_omess[4] = ti->offset;
			sc->sc_omlen = 5;
			if ((sc->sc_flags & ESP_SYNCHNEGO) == 0) {
				ti->flags |= T_SYNCMODE;
				esp_setsync(sc, ti);
			}
			break;
		case SEND_IDENTIFY:
			if (sc->sc_state != ESP_CONNECTED) {
				printf("esp at line %d: no nexus\n", __LINE__);
			}
			ecb = sc->sc_nexus;
			sc->sc_omess[0] = MSG_IDENTIFY(ecb->xs->sc_link->lun,0);
			break;
		case SEND_DEV_RESET:
			sc->sc_flags |= ESP_ABORTING;
			sc->sc_omess[0] = MSG_BUS_DEV_RESET;
			ecb = sc->sc_nexus;
			ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
			ti->flags &= ~T_SYNCMODE;
			ti->flags |= T_NEGOTIATE;
			break;
		case SEND_PARITY_ERROR:
			sc->sc_omess[0] = MSG_PARITY_ERROR;
			break;
		case SEND_ABORT:
			sc->sc_flags |= ESP_ABORTING;
			sc->sc_omess[0] = MSG_ABORT;
			break;
		case SEND_INIT_DET_ERR:
			sc->sc_omess[0] = MSG_INITIATOR_DET_ERR;
			break;
		case SEND_REJECT:
			sc->sc_omess[0] = MSG_MESSAGE_REJECT;
			break;
		default:
			ESPCMD(sc, ESPCMD_RSTATN);
			sc->sc_flags &= ~ESP_ATN;
			sc->sc_omess[0] = MSG_NOOP;
			break;
		}
		sc->sc_omp = sc->sc_omess;
	}

#if 1
	/* (re)send the message */
	size = min(sc->sc_omlen, sc->sc_maxxfer);
	DMA_SETUP(sc->sc_dma, &sc->sc_omp, &sc->sc_omlen, 0, &size);
#ifndef MAC68K_DRIVER
	/* Program the SCSI counter */
	ESP_WRITE_REG(sc, ESP_TCL, size);
	ESP_WRITE_REG(sc, ESP_TCM, size >> 8);
	if (sc->sc_cfg2 & ESPCFG2_FE) {
		ESP_WRITE_REG(sc, ESP_TCH, size >> 16);
	}
	/* load the count in */
	ESPCMD(sc, ESPCMD_NOP|ESPCMD_DMA);
#endif
	ESPCMD(sc, ESPCMD_TRANS|ESPCMD_DMA);
	DMA_GO(sc->sc_dma);
#else
	{	int i;
		for (i = 0; i < sc->sc_omlen; i++)
			ESP_WRITE_REG(sc, FIFO, sc->sc_omess[i]);
		ESPCMD(sc, ESPCMD_TRANS);
		sc->sc_omlen = 0;
	}
#endif
a413 9
/*
 * This is the most critical part of the driver, and has to know
 * how to deal with *all* error conditions and phases from the SCSI
 * bus. If there are no errors and the DMA was active, then call the
 * DMA pseudo-interrupt handler. If this returns 1, then that was it
 * and we can return from here without further processing.
 *
 * Most of this needs verifying.
 */
d415 2
a416 597
espintr(sc)
	register struct esp_softc *sc;
{
	register struct esp_ecb *ecb;
	register struct scsi_link *sc_link;
	struct esp_tinfo *ti;
	int loop;
	size_t size;

	ESP_TRACE(("[espintr]"));

	/*
	 * I have made some (maybe seriously flawed) assumptions here,
	 * but basic testing (uncomment the printf() below), show that
	 * certainly something happens when this loop is here.
	 *
	 * The idea is that many of the SCSI operations take very little
	 * time, and going away and getting interrupted is too high an
	 * overhead to pay. For example, selecting, sending a message
	 * and command and then doing some work can be done in one "pass".
	 *
	 * The DELAY is not variable because I do not understand that the
	 * DELAY loop should be fixed-time regardless of CPU speed, but
	 * I am *assuming* that the faster SCSI processors get things done
	 * quicker (sending a command byte etc), and so there is no
	 * need to be too slow.
	 *
	 * This is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1
	 * at 40Mhz. This needs testing.
	 */
	for (loop = 0; 1;loop++, DELAY(50/sc->sc_freq)) {
		/* a feeling of deja-vu */
		if (!DMA_ISINTR(sc->sc_dma))
			return (loop != 0);
#if 0
		if (loop)
			printf("*");
#endif

		/* and what do the registers say... */
		espreadregs(sc);

errintr:
		sc->sc_intrcnt.ev_count++;

		/*
		 * At the moment, only a SCSI Bus Reset or Illegal
		 * Command are classed as errors. A disconnect is a
		 * valid condition, and we let the code check is the
		 * "ESP_BUSFREE_OK" flag was set before declaring it
		 * and error.
		 *
		 * Also, the status register tells us about "Gross
		 * Errors" and "Parity errors". Only the Gross Error
		 * is really bad, and the parity errors are dealt
		 * with later
		 *
		 * TODO
		 *	If there are too many parity error, go to slow
		 *	cable mode ?
		 */

		/* SCSI Reset */
		if (sc->sc_espintr & ESPINTR_SBR) {
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			if (sc->sc_state != ESP_SBR) {
				printf("%s: SCSI bus reset\n",
					sc->sc_dev.dv_xname);
				esp_init(sc, 0); /* Restart everything */
				return 1;
			}
#if 0
	/*XXX*/		printf("<expected bus reset: "
				"[intr %x, stat %x, step %d]>\n",
				sc->sc_espintr, sc->sc_espstat,
				sc->sc_espstep);
#endif
			if (sc->sc_nexus)
				panic("%s: nexus in reset state",
				      sc->sc_dev.dv_xname);
			goto sched;
		}

		ecb = sc->sc_nexus;

#define ESPINTR_ERR (ESPINTR_SBR|ESPINTR_ILL)
		if (sc->sc_espintr & ESPINTR_ERR ||
		    sc->sc_espstat & ESPSTAT_GE) {

			if (sc->sc_espstat & ESPSTAT_GE) {
				/* no target ? */
				if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
				if (sc->sc_state == ESP_CONNECTED ||
				    sc->sc_state == ESP_SELECTING) {
					ecb->xs->error = XS_DRIVER_STUFFUP;
					esp_done(sc, ecb);
				}
				return 1;
			}

			if (sc->sc_espintr & ESPINTR_ILL) {
				/* illegal command, out of sync ? */
				printf("%s: illegal command: 0x%x (state %d, phase %x, prevphase %x)\n",
					sc->sc_dev.dv_xname, sc->sc_lastcmd,
					sc->sc_state, sc->sc_phase,
					sc->sc_prevphase);
				if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
					ESPCMD(sc, ESPCMD_FLUSH);
					DELAY(1);
				}
				esp_init(sc, 0); /* Restart everything */
				return 1;
			}
		}

		/*
		 * Call if DMA is active.
		 *
		 * If DMA_INTR returns true, then maybe go 'round the loop
		 * again in case there is no more DMA queued, but a phase
		 * change is expected.
		 */
		if (DMA_ISACTIVE(sc->sc_dma)) {
			DMA_INTR(sc->sc_dma);
			/* If DMA active here, then go back to work... */
			if (   (sc->sc_espstat & ESPSTAT_GE)
			    || (sc->sc_espintr & ESPINTR_ERR))
				goto errintr;
			if (DMA_ISACTIVE(sc->sc_dma))
				return 1;

			if (sc->sc_dleft == 0 &&
			    (sc->sc_espstat & ESPSTAT_TC) == 0)
				printf("%s: !TC [intr %x, stat %x, step %d]"
				       " prevphase %x, resid %x\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr,
					sc->sc_espstat,
					sc->sc_espstep,
					sc->sc_prevphase,
					ecb?ecb->dleft:-1);
		}

#if 0	/* Unreliable on some ESP revisions? */
		if ((sc->sc_espstat & ESPSTAT_INT) == 0) {
			printf("%s: spurious interrupt\n", sc->sc_dev.dv_xname);
			return 1;
		}
#endif

		/*
		 * check for less serious errors
		 */
		if (sc->sc_espstat & ESPSTAT_PE) {
			printf("%s: SCSI bus parity error\n",
				sc->sc_dev.dv_xname);
			if (sc->sc_prevphase == MESSAGE_IN_PHASE)
				esp_sched_msgout(SEND_PARITY_ERROR);
			else
				esp_sched_msgout(SEND_INIT_DET_ERR);
		}

		if (sc->sc_espintr & ESPINTR_DIS) {
			ESP_MISC(("<DISC [intr %x, stat %x, step %d]>",
				sc->sc_espintr,sc->sc_espstat,sc->sc_espstep));
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			/*
			 * This command must (apparently) be issued within
			 * 250mS of a disconnect. So here you are...
			 */
			ESPCMD(sc, ESPCMD_ENSEL);
			switch (sc->sc_state) {
			case ESP_RESELECTED:
				goto sched;

			case ESP_SELECTING:
				ecb->xs->error = XS_SELTIMEOUT;
				goto finish;

			case ESP_CONNECTED:
				if ((sc->sc_flags & ESP_SYNCHNEGO)) {
#ifdef ESP_DEBUG
					if (ecb)
						sc_print_addr(ecb->xs->sc_link);
					printf("sync nego not completed!\n");
#endif
					ti = &sc->sc_tinfo[ecb->xs->sc_link->target];
					sc->sc_flags &= ~ESP_SYNCHNEGO;
					ti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);
				}

				/* it may be OK to disconnect */
				if ((sc->sc_flags & ESP_ABORTING) == 0) {
					/*  
					 * Section 5.1.1 of the SCSI 2 spec
					 * suggests issuing a REQUEST SENSE
					 * following an unexpected disconnect.
					 * Some devices go into a contingent
					 * allegiance condition when
					 * disconnecting, and this is necessary
					 * to clean up their state.
					 */     
					printf("%s: unexpected disconnect; ",
					    sc->sc_dev.dv_xname);
					if (ecb->flags & ECB_SENSE) {
						printf("resetting\n");
						goto reset;
					}
					printf("sending REQUEST SENSE\n");
					esp_sense(sc, ecb);
					goto out;
				}

				ecb->xs->error = XS_DRIVER_STUFFUP;
				goto finish;

			case ESP_DISCONNECT:
				TAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);
				sc->sc_nexus = NULL;
				goto sched;

			case ESP_CMDCOMPLETE:
				goto finish;
			}
		}

		switch (sc->sc_state) {

		case ESP_SBR:
			printf("%s: waiting for SCSI Bus Reset to happen\n",
				sc->sc_dev.dv_xname);
			return 1;

		case ESP_RESELECTED:
			/*
			 * we must be continuing a message ?
			 */
			if (sc->sc_phase != MESSAGE_IN_PHASE) {
				printf("%s: target didn't identify\n",
					sc->sc_dev.dv_xname);
				esp_init(sc, 1);
				return 1;
			}
printf("<<RESELECT CONT'd>>");
#if XXXX
			esp_msgin(sc);
			if (sc->sc_state != ESP_CONNECTED) {
				/* IDENTIFY fail?! */
				printf("%s: identify failed\n",
					sc->sc_dev.dv_xname);
				esp_init(sc, 1);
				return 1;
			}
#endif
			break;

		case ESP_IDLE:
if (sc->sc_flags & ESP_ICCS) printf("[[esp: BUMMER]]");
		case ESP_SELECTING:
			sc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;
			sc->sc_flags = 0;

			if (sc->sc_espintr & ESPINTR_RESEL) {
				/*
				 * If we're trying to select a
				 * target ourselves, push our command
				 * back into the ready list.
				 */
				if (sc->sc_state == ESP_SELECTING) {
					ESP_MISC(("backoff selector "));
					sc_link = sc->sc_nexus->xs->sc_link;
					ti = &sc->sc_tinfo[sc_link->target];
					TAILQ_INSERT_HEAD(&sc->ready_list,
					    sc->sc_nexus, chain);
					ecb = sc->sc_nexus = NULL;
				}
				sc->sc_state = ESP_RESELECTED;
				if (sc->sc_phase != MESSAGE_IN_PHASE) {
					/*
					 * Things are seriously fucked up.
					 * Pull the brakes, i.e. reset
					 */
					printf("%s: target didn't identify\n",
						sc->sc_dev.dv_xname);
					esp_init(sc, 1);
					return 1;
				}
				if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) != 2) {
					printf("%s: RESELECT: %d bytes in FIFO!\n",
						sc->sc_dev.dv_xname,
						ESP_READ_REG(sc, ESP_FFLAG) &
						ESPFIFO_FF);
					esp_init(sc, 1);
					return 1;
				}
				sc->sc_selid = ESP_READ_REG(sc, ESP_FIFO);
				ESP_MISC(("selid=0x%2x ", sc->sc_selid));
				esp_msgin(sc);	/* Handle identify message */
				if (sc->sc_state != ESP_CONNECTED) {
					/* IDENTIFY fail?! */
					printf("%s: identify failed\n",
						sc->sc_dev.dv_xname);
					esp_init(sc, 1);
					return 1;
				}
				continue; /* ie. next phase expected soon */
			}

#define	ESPINTR_DONE	(ESPINTR_FC|ESPINTR_BS)
			if ((sc->sc_espintr & ESPINTR_DONE) == ESPINTR_DONE) {
				ecb = sc->sc_nexus;
				if (!ecb)
					panic("esp: not nexus at sc->sc_nexus");

				sc_link = ecb->xs->sc_link;
				ti = &sc->sc_tinfo[sc_link->target];

				switch (sc->sc_espstep) {
				case 0:
					printf("%s: select timeout/no disconnect\n",
						sc->sc_dev.dv_xname);
					ecb->xs->error = XS_SELTIMEOUT;
					goto finish;
				case 1:
					if ((ti->flags & T_NEGOTIATE) == 0) {
						printf("%s: step 1 & !NEG\n",
							sc->sc_dev.dv_xname);
						goto reset;
					}
					if (sc->sc_phase != MESSAGE_OUT_PHASE) {
						printf("%s: !MSGOUT\n",
							sc->sc_dev.dv_xname);
						goto reset;
					}
					/* Start negotiating */
					ti->period = sc->sc_minsync;
					ti->offset = 15;
					sc->sc_flags |= ESP_SYNCHNEGO;
					esp_sched_msgout(SEND_SDTR);
					break;
				case 3:
					/*
					 * Grr, this is supposed to mean
					 * "target left command phase
					 *  prematurely". It seems to happen
					 * regularly when sync mode is on.
					 * Look at FIFO to see if command
					 * went out.
					 * (Timing problems?)
					 */
					if ((ESP_READ_REG(sc, ESP_FFLAG)&ESPFIFO_FF) == 0) {
						/* Hope for the best.. */
						break;
					}
					printf("(%s:%d:%d): selection failed;"
						" %d left in FIFO "
						"[intr %x, stat %x, step %d]\n",
						sc->sc_dev.dv_xname,
						sc_link->target,
						sc_link->lun,
						ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
					ESPCMD(sc, ESPCMD_FLUSH);
					esp_sched_msgout(SEND_ABORT);
					return 1;
				case 2:
					/* Select stuck at Command Phase */
					ESPCMD(sc, ESPCMD_FLUSH);
				case 4:
					/* So far, everything went fine */
					break;
				}
#if 0
				if (ecb->xs->flags & SCSI_RESET)
					esp_sched_msgout(SEND_DEV_RESET);
				else if (ti->flags & T_NEGOTIATE)
					esp_sched_msgout(
					    SEND_IDENTIFY | SEND_SDTR);
				else
					esp_sched_msgout(SEND_IDENTIFY);
#endif

				ecb->flags |= ECB_NEXUS;
				ti->lubusy |= (1 << sc_link->lun);

				sc->sc_prevphase = INVALID_PHASE; /* ?? */
				/* Do an implicit RESTORE POINTERS. */
				sc->sc_dp = ecb->daddr;
				sc->sc_dleft = ecb->dleft;

				/* On our first connection, schedule a timeout. */
				if ((ecb->xs->flags & SCSI_POLL) == 0)
					timeout(esp_timeout, ecb, (ecb->timeout * hz) / 1000);

				sc->sc_state = ESP_CONNECTED;
				break;
			} else {
				printf("%s: unexpected status after select"
					": [intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
				goto reset;
			}
			if (sc->sc_state == ESP_IDLE) {
				printf("%s: stray interrupt\n", sc->sc_dev.dv_xname);
					return 0;
			}
			break;

		case ESP_CONNECTED:
			if (sc->sc_flags & ESP_ICCS) {
				u_char msg;

				sc->sc_flags &= ~ESP_ICCS;

				if (!(sc->sc_espintr & ESPINTR_DONE)) {
					printf("%s: ICCS: "
					      ": [intr %x, stat %x, step %x]\n",
						sc->sc_dev.dv_xname,
						sc->sc_espintr, sc->sc_espstat,
						sc->sc_espstep);
				}
				if ((ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) != 2) {
					int i = (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) - 2;
					while (i--)
						(void) ESP_READ_REG(sc, ESP_FIFO);
				}
				ecb->stat = ESP_READ_REG(sc, ESP_FIFO);
				msg = ESP_READ_REG(sc, ESP_FIFO);
				ESP_PHASE(("<stat:(%x,%x)>", ecb->stat, msg));
				if (msg == MSG_CMDCOMPLETE) {
					ecb->xs->resid = ecb->dleft = sc->sc_dleft;
					sc->sc_state = ESP_CMDCOMPLETE;
				} else
					printf("%s: STATUS_PHASE: msg %d\n",
						sc->sc_dev.dv_xname, msg);
				ESPCMD(sc, ESPCMD_MSGOK);
				continue; /* ie. wait for disconnect */
			}
			break;
		default:
			panic("%s: invalid state: %d",
			      sc->sc_dev.dv_xname,
			      sc->sc_state);
		}

		/*
		 * Driver is now in state ESP_CONNECTED, i.e. we
		 * have a current command working the SCSI bus.
		 */
		if (sc->sc_state != ESP_CONNECTED || ecb == NULL) {
			panic("esp no nexus");
		}

		switch (sc->sc_phase) {
		case MESSAGE_OUT_PHASE:
			ESP_PHASE(("MESSAGE_OUT_PHASE "));
			esp_msgout(sc);
			sc->sc_prevphase = MESSAGE_OUT_PHASE;
			break;
		case MESSAGE_IN_PHASE:
			ESP_PHASE(("MESSAGE_IN_PHASE "));
			if (sc->sc_espintr & ESPINTR_BS) {
				ESPCMD(sc, ESPCMD_FLUSH);
				sc->sc_flags |= ESP_WAITI;
				ESPCMD(sc, ESPCMD_TRANS);
			} else if (sc->sc_espintr & ESPINTR_FC) {
				if ((sc->sc_flags & ESP_WAITI) == 0) {
					printf("%s: MSGIN: unexpected FC bit: "
						"[intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
				}
				sc->sc_flags &= ~ESP_WAITI;
				esp_msgin(sc);
			} else {
				printf("%s: MSGIN: weird bits: "
					"[intr %x, stat %x, step %x]\n",
					sc->sc_dev.dv_xname,
					sc->sc_espintr, sc->sc_espstat,
					sc->sc_espstep);
			}
			sc->sc_prevphase = MESSAGE_IN_PHASE;
			break;
		case COMMAND_PHASE: {
			/* well, this means send the command again */
			u_char *cmd = (u_char *)&ecb->cmd;
			int i;

			ESP_PHASE(("COMMAND_PHASE 0x%02x (%d) ",
				ecb->cmd.opcode, ecb->clen));
			if (ESP_READ_REG(sc, ESP_FFLAG) & ESPFIFO_FF) {
				ESPCMD(sc, ESPCMD_FLUSH);
				DELAY(1);
			}
			/* Now the command into the FIFO */
			for (i = 0; i < ecb->clen; i++)
				ESP_WRITE_REG(sc, ESP_FIFO, *cmd++);
			ESPCMD(sc, ESPCMD_TRANS);
			sc->sc_prevphase = COMMAND_PHASE;
			}
			break;
		case DATA_OUT_PHASE:
			ESP_PHASE(("DATA_OUT_PHASE [%d] ",  sc->sc_dleft));
			ESPCMD(sc, ESPCMD_FLUSH);
			size = min(sc->sc_dleft, sc->sc_maxxfer);
			DMA_SETUP(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft,
				  0, &size);
			sc->sc_prevphase = DATA_OUT_PHASE;
			goto setup_xfer;
		case DATA_IN_PHASE:
			ESP_PHASE(("DATA_IN_PHASE "));
			if (sc->sc_rev == ESP100)
				ESPCMD(sc, ESPCMD_FLUSH);
			size = min(sc->sc_dleft, sc->sc_maxxfer);
			DMA_SETUP(sc->sc_dma, &sc->sc_dp, &sc->sc_dleft,
				  1, &size);
			sc->sc_prevphase = DATA_IN_PHASE;
		setup_xfer:
#ifdef MAC68K_DRIVER
			if (!size) {
#endif
			/* Program the SCSI counter */
			ESP_WRITE_REG(sc, ESP_TCL, size);
			ESP_WRITE_REG(sc, ESP_TCM, size >> 8);
			if (sc->sc_cfg2 & ESPCFG2_FE) {
				ESP_WRITE_REG(sc, ESP_TCH, size >> 16);
			}
			/* load the count in */
			ESPCMD(sc, ESPCMD_NOP|ESPCMD_DMA);
#ifdef MAC68K_DRIVER
			}
#endif

			/*
			 * Note that if `size' is 0, we've already transceived
			 * all the bytes we want but we're still in DATA PHASE.
			 * Apparently, the device needs padding. Also, a
			 * transfer size of 0 means "maximum" to the chip
			 * DMA logic.
			 */
			ESPCMD(sc,
			       (size==0?ESPCMD_TRPAD:ESPCMD_TRANS)|ESPCMD_DMA);
			DMA_GO(sc->sc_dma);
			return 1;
		case STATUS_PHASE:
			ESP_PHASE(("STATUS_PHASE "));
			sc->sc_flags |= ESP_ICCS;
			ESPCMD(sc, ESPCMD_ICCS);
			sc->sc_prevphase = STATUS_PHASE;
			break;
		case INVALID_PHASE:
			break;
		default:
			printf("%s: unexpected bus phase; resetting\n",
			    sc->sc_dev.dv_xname);
			goto reset;
		}
	}
	panic("esp: should not get here..");

reset:
	esp_init(sc, 1);
	return 1;

finish:
	untimeout(esp_timeout, ecb);
	esp_done(sc, ecb);
	goto out;

sched:
	sc->sc_state = ESP_IDLE;
	esp_sched(sc);
	goto out;

out:
	return 1;
}

void
esp_abort(sc, ecb)
	struct esp_softc *sc;
	struct esp_ecb *ecb;
d418 1
d420 1
a420 55
	/* 2 secs for the abort */
	ecb->timeout = ESP_ABORT_TIMEOUT;
	ecb->flags |= ECB_ABORT;

	if (ecb == sc->sc_nexus) {
		/*
		 * If we're still selecting, the message will be scheduled
		 * after selection is complete.
		 */
		if (sc->sc_state == ESP_CONNECTED)
			esp_sched_msgout(SEND_ABORT);
	} else {
		esp_dequeue(sc, ecb);
		TAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);
		if (sc->sc_state == ESP_IDLE)
			esp_sched(sc);
	}
}

void
esp_timeout(arg)
	void *arg;
{
	struct esp_ecb *ecb = arg;
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct esp_softc *sc = sc_link->adapter_softc;
	int s;

	sc_print_addr(sc_link);
	printf("%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], "
	       "<state %d, nexus %p, phase(c %x, p %x), resid %x, msg(q %x,o %x) %s>",
		sc->sc_dev.dv_xname,
		ecb, ecb->flags, ecb->dleft, ecb->stat,
		sc->sc_state, sc->sc_nexus, sc->sc_phase, sc->sc_prevphase,
		sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,
		DMA_ISACTIVE(sc->sc_dma) ? "DMA active" : "");
#if ESP_DEBUG > 0
	printf("TRACE: %s.", ecb->trace);
#endif

	s = splbio();

	if (ecb->flags & ECB_ABORT) {
		/* abort timed out */
		printf(" AGAIN\n");
		esp_init(sc, 1);
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		xs->error = XS_TIMEOUT;
		esp_abort(sc, ecb);
	}

	splx(s);
@


1.7
log
@Use scsiprint (and remove scsiprint from esp.c).
@
text
@d226 3
a228 3
static inline int esp_stp2cpb __P((struct esp_softc *, int));
static inline int esp_cpb2stp __P((struct esp_softc *, int));
static inline void esp_setsync __P((struct esp_softc *, struct esp_tinfo *));
d784 1
a784 1
static inline int
d795 1
a795 1
static inline int
d808 1
a808 1
static inline void
@


1.6
log
@added const to second parameter of cfprint_t routines
@
text
@a285 9
int scsiprint __P((void *, const char *));
int
scsiprint(aux, name)
	void *aux;
	const char *name;
{
	return (UNCONF);
}

@


1.5
log
@Q900, etc. have 2nd scsi adapter at offset of 0x402, not 0x400 from the 1st.
@
text
@d286 1
a286 1
int scsiprint __P((void *, char *));
d290 1
a290 1
	char *name;
@


1.4
log
@Improve performance some.  Still pretty bad.
@
text
@d356 1
a356 1
		sc->sc_reg = (volatile u_char *) SCSIBase + 0x400;
@


1.3
log
@Improve reliability on my Q700, at least.  Was getting the occasional
glitch--an extra byte on occasion.
@
text
@d129 1
d131 1
d135 1
a135 1
		printf("dma_intr--inactive\n");
d144 5
d150 22
a171 8
	cnt = *sc->sc_pdmalen;
	if (sc->sc_datain) {
		if (cnt) {
			*p++ = ESP_READ_REG(sc->sc_esp, ESP_FIFO);
			*sc->sc_dmaaddr = p;
			--(*sc->sc_pdmalen);
		} else {
			printf("data in, but no count!\n");
d173 8
a180 11
	}
	if (sc->sc_esp->sc_phase == DATA_IN_PHASE) {
		ESPCMD(sc->sc_esp, ESPCMD_TRANS);
	} else if (   (sc->sc_esp->sc_phase == DATA_OUT_PHASE)
		   || (sc->sc_esp->sc_phase == MESSAGE_OUT_PHASE)) {
		if (cnt) {
			ESP_WRITE_REG(sc->sc_esp, ESP_FIFO, *p++);
			*sc->sc_dmaaddr = p;
			--(*sc->sc_pdmalen);
		} else {
			printf("data out, but no count!\n");
d182 7
a188 4
		ESPCMD(sc->sc_esp, ESPCMD_TRANS);
	} else {
		sc->sc_active = 0;
	}
d1692 1
d1781 3
@


1.2
log
@Go ahead and try dual scsi even though we'll probably need to make another
pass at it.
Macs with scsi offsets of 0x10000 have a SCSI CLK of 16.5MHz.  All other
(68k-based) appear to use 25MHz.
@
text
@d108 1
d129 2
a130 1
	u_char	*p;
d137 5
d143 1
d145 1
a145 1
		if (ESP_READ_REG(sc->sc_esp, ESP_FFLAG) & ESPFIFO_FF) {
d147 2
a148 1
			(*sc->sc_pdmalen)--;
d150 1
a150 2
			printf("DMA, Data in, no data, pdmalen is %d\n",
				*sc->sc_pdmalen);
d152 11
a162 12
		*sc->sc_dmaaddr = p;
		if (sc->sc_esp->sc_phase != DATA_IN_PHASE) {
			if (*sc->sc_pdmalen == 0) {
				/*
				 * Fake terminal count since this isn't
				 * a real DMA transaction and the chip
				 * will therefore not trip TC itself.
				 */
				sc->sc_esp->sc_espstat |= ESPSTAT_TC;
			}
			sc->sc_active = 0;
			return;
a164 6
	} else if (sc->sc_esp->sc_phase == DATA_OUT_PHASE) {
		p++;
		ESP_WRITE_REG(sc->sc_esp, ESP_FIFO, *p);
		*sc->sc_dmaaddr = p;
		(*sc->sc_pdmalen)--;
		ESPCMD(sc->sc_esp, ESPCMD_TRANS);
a165 4
		if (   (sc->sc_esp->sc_prevphase == DATA_OUT_PHASE)
		    && (*sc->sc_pdmalen == 0)) {
			sc->sc_esp->sc_espstat |= ESPSTAT_TC;
		}
d168 4
d451 1
a451 1
	sc->sc_cfg3 = 0x4;
d1120 1
a1120 1
#ifdef ESP_DEBUG
d1597 1
d1606 1
d2158 3
d2169 3
@


1.1
log
@SCSI driver, functional but slow on the Quadra 700.
@
text
@a250 1
#if TRY_DUAL_SCSI
a252 1
#endif
d322 2
d327 6
a332 1
#if TRY_DUAL_SCSI
d336 2
a337 2
		sc->irq_mask = V2IF_SCSIIRQ; /* V2IF_T1? */
#endif
a342 1
	sc->sc_freq = 25000000;
@
