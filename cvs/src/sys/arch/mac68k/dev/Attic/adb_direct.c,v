head	1.20;
access;
symbols
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.20
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.18
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.16
	OPENBSD_2_9_BASE:1.10
	NIKLAS_UNDEAD:1.10.0.14
	OPENBSD_2_8:1.10.0.12
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.10
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.8
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8;
locks; strict;
comment	@ * @;


1.20
date	2006.01.18.23.21.16;	author miod;	state dead;
branches;
next	1.19;

1.19
date	2006.01.16.21.48.20;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.13.19.36.43;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.08.17.45.29;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.04.20.39.04;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.26.21.21.23;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.25.18.32.10;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.03.06.43.02;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.14.10.47.36;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.05.03.07.12.51;	author gene;	state Exp;
branches
	1.10.8.1
	1.10.20.1;
next	1.9;

1.9
date	98.04.22.19.59.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.22.23.50.05;	author gene;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	97.04.22.20.11.34;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.04.18.22.08.07;	author gene;	state Exp;
branches;
next	1.5;

1.5
date	97.04.14.18.47.53;	author gene;	state Exp;
branches;
next	1.4;

1.4
date	97.04.07.01.22.15;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	97.03.31.12.59.11;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	97.03.29.17.26.59;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	97.02.23.06.04.52;	author briggs;	state Exp;
branches;
next	;

1.8.6.1
date	98.04.22.20.00.11;	author deraadt;	state Exp;
branches;
next	;

1.10.8.1
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.10.8.2;

1.10.8.2
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.10.8.3;

1.10.8.3
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	;

1.10.20.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	1.10.20.2;

1.10.20.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Factorize akbd and ams drivers between mac68k and macppc; while there, start
moving out common adb code as well, and merge adb_direct.c into adb.c to
simplify external header files.

No functional change; more cleanups to come.
@
text
@/*	$OpenBSD: adb_direct.c,v 1.19 2006/01/16 21:48:20 miod Exp $	*/
/*	$NetBSD: adb_direct.c,v 1.51 2005/06/16 22:43:36 jmc Exp $	*/

/* From: adb_direct.c 2.02 4/18/97 jpw */

/*
 * Copyright (C) 1996, 1997 John P. Wittkoski
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by John P. Wittkoski.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code is rather messy, but I don't have time right now
 * to clean it up as much as I would like.
 * But it works, so I'm happy. :-) jpw
 */
 
/*
 * TO DO:
 *  - We could reduce the time spent in the adb_intr_* routines
 *    by having them save the incoming and outgoing data directly 
 *    in the adbInbound and adbOutbound queues, as it would reduce
 *    the number of times we need to copy the data around. It
 *    would also make the code more readable and easier to follow.
 *  - (Related to above) Use the header part of adbCommand to 
 *    reduce the number of copies we have to do of the data.
 *  - (Related to above) Actually implement the adbOutbound queue.
 *    This is fairly easy once you switch all the intr routines
 *    over to using adbCommand structs directly.
 *  - There is a bug in the state machine of adb_intr_cuda
 *    code that causes hangs, especially on 030 machines, probably
 *    because of some timing issues. Because I have been unable to 
 *    determine the exact cause of this bug, I used the timeout function 
 *    to check for and recover from this condition. If anyone finds 
 *    the actual cause of this bug, the calls to timeout and the 
 *    adb_cuda_tickle routine can be removed.
 */

#include <sys/param.h>
#include <sys/cdefs.h>
#include <sys/pool.h>
#include <sys/queue.h>
#include <sys/systm.h>
#include <sys/timeout.h>

#include <machine/viareg.h>
#include <machine/param.h>
#include <machine/cpu.h>
#include <mac68k/dev/adbvar.h>
#define printf_intr printf

/* some misc. leftovers */
#define vPB		0x0000
#define vPB3		0x08
#define vPB4		0x10
#define vPB5		0x20
#define vSR_INT		0x04
#define vSR_OUT		0x10

/* the type of ADB action that we are currently preforming */
#define ADB_ACTION_NOTREADY	0x1	/* has not been initialized yet */
#define ADB_ACTION_IDLE		0x2	/* the bus is currently idle */
#define ADB_ACTION_OUT		0x3	/* sending out a command */
#define ADB_ACTION_IN		0x4	/* receiving data */
#define ADB_ACTION_POLLING	0x5	/* polling - II only */

/*
 * These describe the state of the ADB bus itself, although they
 * don't necessarily correspond directly to ADB states.
 * Note: these are not really used in the IIsi code.
 */
#define ADB_BUS_UNKNOWN		0x1	/* we don't know yet - all models */
#define ADB_BUS_IDLE		0x2	/* bus is idle - all models */
#define ADB_BUS_CMD		0x3	/* starting a command - II models */
#define ADB_BUS_ODD		0x4	/* the "odd" state - II models */
#define ADB_BUS_EVEN		0x5	/* the "even" state - II models */
#define ADB_BUS_ACTIVE		0x6	/* active state - IIsi models */
#define ADB_BUS_ACK		0x7	/* currently ACKing - IIsi models */

/*
 * Shortcuts for setting or testing the VIA bit states.
 * Not all shortcuts are used for every type of ADB hardware.
 */
#define ADB_SET_STATE_IDLE_II()		via_reg(VIA1, vBufB) |= (vPB4 | vPB5)
#define ADB_SET_STATE_IDLE_IISI()	via_reg(VIA1, vBufB) &= ~(vPB4 | vPB5)
#define ADB_SET_STATE_IDLE_CUDA()	via_reg(VIA1, vBufB) |= (vPB4 | vPB5)
#define ADB_SET_STATE_CMD()		via_reg(VIA1, vBufB) &= ~(vPB4 | vPB5)
#define ADB_SET_STATE_EVEN()		via_reg(VIA1, vBufB) = ((via_reg(VIA1, \
						vBufB) | vPB4) & ~vPB5)
#define ADB_SET_STATE_ODD()		via_reg(VIA1, vBufB) = ((via_reg(VIA1, \
						vBufB) | vPB5) & ~vPB4)
#define ADB_SET_STATE_ACTIVE() 		via_reg(VIA1, vBufB) |= vPB5
#define ADB_SET_STATE_INACTIVE()	via_reg(VIA1, vBufB) &= ~vPB5
#define ADB_SET_STATE_TIP()		via_reg(VIA1, vBufB) &= ~vPB5
#define ADB_CLR_STATE_TIP() 		via_reg(VIA1, vBufB) |= vPB5
#define ADB_SET_STATE_ACKON()		via_reg(VIA1, vBufB) |= vPB4
#define ADB_SET_STATE_ACKOFF()		via_reg(VIA1, vBufB) &= ~vPB4
#define ADB_TOGGLE_STATE_ACK_CUDA()	via_reg(VIA1, vBufB) ^= vPB4
#define ADB_SET_STATE_ACKON_CUDA()	via_reg(VIA1, vBufB) &= ~vPB4
#define ADB_SET_STATE_ACKOFF_CUDA()	via_reg(VIA1, vBufB) |= vPB4
#define ADB_SET_SR_INPUT()		via_reg(VIA1, vACR) &= ~vSR_OUT
#define ADB_SET_SR_OUTPUT()		via_reg(VIA1, vACR) |= vSR_OUT
#define ADB_SR()			via_reg(VIA1, vSR)
#define ADB_VIA_INTR_ENABLE()		via_reg(VIA1, vIER) = 0x84
#define ADB_VIA_INTR_DISABLE()		via_reg(VIA1, vIER) = 0x04
#define ADB_VIA_CLR_INTR()		via_reg(VIA1, vIFR) = 0x04
#define ADB_INTR_IS_OFF			(vPB3 == (via_reg(VIA1, vBufB) & vPB3))
#define ADB_INTR_IS_ON			(0 == (via_reg(VIA1, vBufB) & vPB3))
#define ADB_SR_INTR_IS_OFF		(0 == (via_reg(VIA1, vIFR) & vSR_INT))
#define ADB_SR_INTR_IS_ON		(vSR_INT == (via_reg(VIA1, \
						vIFR) & vSR_INT))

/*
 * This is the delay that is required (in uS) between certain
 * ADB transactions. The actual timing delay for for each uS is
 * calculated at boot time to account for differences in machine speed.
 */
#define ADB_DELAY	150

/*
 * Maximum ADB message length; includes space for data, result, and
 * device code - plus a little for safety.
 */
#define ADB_MAX_MSG_LENGTH	16
#define ADB_MAX_HDR_LENGTH	8

#define ADB_QUEUE		32
#define ADB_TICKLE_TICKS	4

/*
 * A structure for storing information about each ADB device.
 */
struct ADBDevEntry {
	void	(*ServiceRtPtr)(void);
	void	*DataAreaAddr;
	int	devType;
	int	origAddr;
	int	currentAddr;
};

/*
 * Used to hold ADB commands that are waiting to be sent out.
 */
struct adbCmdHoldEntry {
	u_char	outBuf[ADB_MAX_MSG_LENGTH];	/* our message */
	u_char	*saveBuf;	/* buffer to know where to save result */
	u_char	*compRout;	/* completion routine pointer */
	u_char	*data;		/* completion routine data pointer */
};

/*
 * Eventually used for two separate queues, the queue between 
 * the upper and lower halves, and the outgoing packet queue.
 * TO DO: adbCommand can replace all of adbCmdHoldEntry eventually
 */
struct adbCommand {
	u_char	header[ADB_MAX_HDR_LENGTH];	/* not used yet */
	u_char	data[ADB_MAX_MSG_LENGTH];	/* packet data only */
	u_char	*saveBuf;	/* where to save result */
	u_char	*compRout;	/* completion routine pointer */
	u_char	*compData;	/* completion routine data pointer */
	u_int	cmd;		/* the original command for this data */
	u_int	unsol;		/* 1 if packet was unsolicited */
	u_int	ack_only;	/* 1 for no special processing */
};

/*
 * Text representations of each hardware class
 */
const char	*adbHardwareDescr[MAX_ADB_HW + 1] = {
	"unknown",
	"II series",
	"IIsi series",
	"PowerBook",
	"Cuda",
};

/*
 * A few variables that we need and their initial values.
 */
int	adbHardware = ADB_HW_UNKNOWN;
int	adbActionState = ADB_ACTION_NOTREADY;
int	adbBusState = ADB_BUS_UNKNOWN;
int	adbWaiting = 0;		/* waiting for return data from the device */
int	adbWriteDelay = 0;	/* working on (or waiting to do) a write */
int	adbOutQueueHasData = 0;	/* something in the queue waiting to go out */
int	adbNextEnd = 0;		/* the next incoming bute is the last (II) */
int	adbSoftPower = 0;	/* machine supports soft power */

int	adbWaitingCmd = 0;	/* ADB command we are waiting for */
u_char	*adbBuffer = (long)0;	/* pointer to user data area */
void	*adbCompRout = (long)0;	/* pointer to the completion routine */
void	*adbCompData = (long)0;	/* pointer to the completion routine data */
long	adbFakeInts = 0;	/* keeps track of fake ADB interrupts for
				 * timeouts (II) */
int	adbStarting = 1;	/* doing ADBReInit so do polling differently */
int	adbSendTalk = 0;	/* the intr routine is sending the talk, not
				 * the user (II) */
int	adbPolling = 0;		/* we are polling for service request */
int	adbPollCmd = 0;		/* the last poll command we sent */

u_char	adbInputBuffer[ADB_MAX_MSG_LENGTH];	/* data input buffer */
u_char	adbOutputBuffer[ADB_MAX_MSG_LENGTH];	/* data output buffer */
struct	adbCmdHoldEntry adbOutQueue;		/* our 1 entry output queue */

int	adbSentChars = 0;	/* how many characters we have sent */
int	adbLastDevice = 0;	/* last ADB dev we heard from (II ONLY) */
int	adbLastDevIndex = 0;	/* last ADB dev loc in dev table (II ONLY) */
int	adbLastCommand = 0;	/* the last ADB command we sent (II) */

struct	ADBDevEntry ADBDevTable[16];	/* our ADB device table */
int	ADBNumDevices;		/* num. of ADB devices found with ADBReInit */

struct	adbCommand adbInbound[ADB_QUEUE];	/* incoming queue */
volatile int	adbInCount = 0;		/* how many packets in in queue */
int	adbInHead = 0;			/* head of in queue */
int	adbInTail = 0;			/* tail of in queue */
struct	adbCommand adbOutbound[ADB_QUEUE]; /* outgoing queue - not used yet */
int	adbOutCount = 0;		/* how many packets in out queue */
int	adbOutHead = 0;			/* head of out queue */
int	adbOutTail = 0;			/* tail of out queue */

int	tickle_count = 0;		/* how many tickles seen for this packet? */
int	tickle_serial = 0;		/* the last packet tickled */
int	adb_cuda_serial = 0;		/* the current packet */

struct timeout adb_cuda_timeout;

extern struct mac68k_machine_S mac68k_machine;

void	pm_setup_adb(void);
void	pm_hw_setup(void);
void	pm_check_adb_devices(int);
int	pm_adb_op(u_char *, void *, void *, int);
void	pm_init_adb_device(void);

/*
 * The following are private routines.
 */
#ifdef ADB_DEBUG
void	print_single(u_char *);
#endif
int	adb_intr(void *);
int	adb_intr_II(void *);
int	adb_intr_IIsi(void *);
int	adb_intr_cuda(void *);
void	adb_soft_intr(void);
int	send_adb_II(u_char *, u_char *, void *, void *, int);
int	send_adb_IIsi(u_char *, u_char *, void *, void *, int);
int	send_adb_cuda(u_char *, u_char *, void *, void *, int);
void	adb_intr_cuda_test(void);
void	adb_cuda_tickle(void);
void	adb_pass_up(struct adbCommand *);
void	adb_reinit(void);
int	count_adbs(void);
int	get_ind_adb_info(ADBDataBlock *, int);
int	get_adb_info(ADBDataBlock *, int);
int	set_adb_info(ADBSetInfoBlock *, int);
void	adb_setup_hw_type(void);
int	adb_op(Ptr, Ptr, Ptr, short);
void	adb_read_II(u_char *);
void	adb_hw_setup(void);
void	adb_hw_setup_IIsi(u_char *);
int	adb_cmd_result(u_char *);
int	adb_cmd_extra(u_char *);
int	adb_guess_next_device(void);
int	adb_prog_switch_enable(void);
int	adb_prog_switch_disable(void);
/* we should create this and it will be the public version */
int	send_adb(u_char *, void *, void *);

#ifdef ADB_DEBUG
/*
 * print_single
 * Diagnostic display routine. Displays the hex values of the
 * specified elements of the u_char. The length of the "string"
 * is in [0].
 */
void
print_single(u_char *str)
{
	int x;

	if (str == 0) {
		printf_intr("no data - null pointer\n");
		return;
	}
	if (*str == 0) {
		printf_intr("nothing returned\n");
		return;
	}
	if (*str > 20) {
		printf_intr("ADB: ACK > 20 no way!\n");
		*str = (u_char)20;
	}
	printf_intr("(length=0x%x):", (u_int)*str);
	for (x = 1; x <= *str; x++)
		printf_intr("  0x%02x", (u_int)*(str + x));
	printf_intr("\n");
}
#endif

void
adb_cuda_tickle(void)
{
	volatile int s;

	if (adbActionState == ADB_ACTION_IN) {
		if (tickle_serial == adb_cuda_serial) {
			if (++tickle_count > 0) {
				s = splhigh();
				adbActionState = ADB_ACTION_IDLE;
				adbInputBuffer[0] = 0;
				ADB_SET_STATE_IDLE_CUDA();
				splx(s);
			}
		} else {
			tickle_serial = adb_cuda_serial;
			tickle_count = 0;
		}
	} else {
		tickle_serial = adb_cuda_serial;
		tickle_count = 0;
	}

	timeout_add(&adb_cuda_timeout, ADB_TICKLE_TICKS);
}

/*
 * called when when an adb interrupt happens
 *
 * Cuda version of adb_intr
 * TO DO: do we want to add some calls to intr_dispatch() here to
 * grab serial interrupts?
 */
int
adb_intr_cuda(void *arg)
{
	volatile int i, ending;
	volatile unsigned int s;
	struct adbCommand packet;

	s = splhigh();		/* can't be too careful - might be called */
	/* from a routine, NOT an interrupt */

	ADB_VIA_CLR_INTR();	/* clear interrupt */
	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */

switch_start:
	switch (adbActionState) {
	case ADB_ACTION_IDLE:
		/*
		 * This is an unexpected packet, so grab the first (dummy)
		 * byte, set up the proper vars, and tell the chip we are
		 * starting to receive the packet by setting the TIP bit.
		 */
		adbInputBuffer[1] = ADB_SR();
		adb_cuda_serial++;
		if (ADB_INTR_IS_OFF)	/* must have been a fake start */
			break;

		ADB_SET_SR_INPUT();
		ADB_SET_STATE_TIP();

		adbInputBuffer[0] = 1;
		adbActionState = ADB_ACTION_IN;
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("idle 0x%02x ", adbInputBuffer[1]);
#endif
		break;

	case ADB_ACTION_IN:
		adbInputBuffer[++adbInputBuffer[0]] = ADB_SR();
		/* intr off means this is the last byte (end of frame) */
		if (ADB_INTR_IS_OFF)
			ending = 1;
		else
			ending = 0;

		if (1 == ending) {	/* end of message? */
#ifdef ADB_DEBUG
			if (adb_debug) {
				printf_intr("in end 0x%02x ",
				    adbInputBuffer[adbInputBuffer[0]]);
				print_single(adbInputBuffer);
			}
#endif

			/*
			 * Are we waiting AND does this packet match what we
			 * are waiting for AND is it coming from either the
			 * ADB or RTC/PRAM sub-device? This section _should_
			 * recognize all ADB and RTC/PRAM type commands, but
			 * there may be more... NOTE: commands are always at
			 * [4], even for RTC/PRAM commands.
			 */
			/* set up data for adb_pass_up */
			memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);
				
			if ((adbWaiting == 1) &&
			    (adbInputBuffer[4] == adbWaitingCmd) &&
			    ((adbInputBuffer[2] == 0x00) ||
			    (adbInputBuffer[2] == 0x01))) {
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.unsol = 0;
				packet.ack_only = 0;
				adb_pass_up(&packet);

				adbWaitingCmd = 0;	/* reset "waiting" vars */
				adbWaiting = 0;
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
			} else {
				packet.unsol = 1;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			}


			/* reset vars and signal the end of this frame */
			adbActionState = ADB_ACTION_IDLE;
			adbInputBuffer[0] = 0;
			ADB_SET_STATE_IDLE_CUDA();
			/*ADB_SET_SR_INPUT();*/

			/*
			 * If there is something waiting to be sent out,
			 * the set everything up and send the first byte.
			 */
			if (adbWriteDelay == 1) {
				delay(ADB_DELAY);	/* required */
				adbSentChars = 0;
				adbActionState = ADB_ACTION_OUT;
				/*
				 * If the interrupt is on, we were too slow
				 * and the chip has already started to send
				 * something to us, so back out of the write
				 * and start a read cycle.
				 */
				if (ADB_INTR_IS_ON) {
					ADB_SET_SR_INPUT();
					ADB_SET_STATE_IDLE_CUDA();
					adbSentChars = 0;
					adbActionState = ADB_ACTION_IDLE;
					adbInputBuffer[0] = 0;
					break;
				}
				/*
				 * If we got here, it's ok to start sending
				 * so load the first byte and tell the chip
				 * we want to send.
				 */
				ADB_SET_STATE_TIP();
				ADB_SET_SR_OUTPUT();
				ADB_SR() = adbOutputBuffer[adbSentChars + 1];
			}
		} else {
			ADB_TOGGLE_STATE_ACK_CUDA();
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("in 0x%02x ",
				    adbInputBuffer[adbInputBuffer[0]]);
#endif
		}
		break;

	case ADB_ACTION_OUT:
		i = ADB_SR();	/* reset SR-intr in IFR */
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("intr out 0x%02x ", i);
#endif

		adbSentChars++;
		if (ADB_INTR_IS_ON) {	/* ADB intr low during write */
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("intr was on ");
#endif
			ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
			ADB_SET_STATE_IDLE_CUDA();
			adbSentChars = 0;	/* must start all over */
			adbActionState = ADB_ACTION_IDLE;	/* new state */
			adbInputBuffer[0] = 0;
			adbWriteDelay = 1;	/* must retry when done with
						 * read */
			delay(ADB_DELAY);
			goto switch_start;	/* process next state right
						 * now */
			break;
		}
		if (adbOutputBuffer[0] == adbSentChars) {	/* check for done */
			if (0 == adb_cmd_result(adbOutputBuffer)) {	/* do we expect data
									 * back? */
				adbWaiting = 1;	/* signal waiting for return */
				adbWaitingCmd = adbOutputBuffer[2];	/* save waiting command */
			} else {	/* no talk, so done */
				/* set up stuff for adb_pass_up */
				memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.cmd = adbWaitingCmd;
				packet.unsol = 0;
				packet.ack_only = 1;
				adb_pass_up(&packet);

				/* reset "waiting" vars, just in case */
				adbWaitingCmd = 0;
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
			}

			adbWriteDelay = 0;	/* done writing */
			adbActionState = ADB_ACTION_IDLE;	/* signal bus is idle */
			ADB_SET_SR_INPUT();
			ADB_SET_STATE_IDLE_CUDA();
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("write done ");
#endif
		} else {
			ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* send next byte */
			ADB_TOGGLE_STATE_ACK_CUDA();	/* signal byte ready to
							 * shift */
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("toggle ");
#endif
		}
		break;

	case ADB_ACTION_NOTREADY:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: not yet initialized\n");
#endif
		break;

	default:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("intr: unknown ADB state\n");
#endif
		break;
	}

	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */

	splx(s);		/* restore */

	return (1);
}				/* end adb_intr_cuda */


int
send_adb_cuda(u_char *in, u_char *buffer, void *compRout, void *data, int
	command)
{
	int s, len;

#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("SEND\n");
#endif

	if (adbActionState == ADB_ACTION_NOTREADY)
		return 1;

	/* Don't interrupt while we are messing with the ADB */
	s = splhigh();

	if ((adbActionState == ADB_ACTION_IDLE) &&	/* ADB available? */
	    (ADB_INTR_IS_OFF)) {	/* and no incoming interrupt? */
	} else
		if (adbWriteDelay == 0)	/* it's busy, but is anything waiting? */
			adbWriteDelay = 1;	/* if no, then we'll "queue"
						 * it up */
		else {
			splx(s);
			return 1;	/* really busy! */
		}

#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("QUEUE\n");
#endif
	if ((long)in == (long)0) {	/* need to convert? */
		/*
		 * Don't need to use adb_cmd_extra here because this section
		 * will be called ONLY when it is an ADB command (no RTC or
		 * PRAM)
		 */
		if ((command & 0x0c) == 0x08)	/* copy addl data ONLY if
						 * doing a listen! */
			len = buffer[0];	/* length of additional data */
		else
			len = 0;/* no additional data */

		adbOutputBuffer[0] = 2 + len;	/* dev. type + command + addl.
						 * data */
		adbOutputBuffer[1] = 0x00;	/* mark as an ADB command */
		adbOutputBuffer[2] = (u_char)command;	/* load command */

		/* copy additional output data, if any */
		memcpy(adbOutputBuffer + 3, buffer + 1, len);
	} else
		/* if data ready, just copy over */
		memcpy(adbOutputBuffer, in, in[0] + 2);

	adbSentChars = 0;	/* nothing sent yet */
	adbBuffer = buffer;	/* save buffer to know where to save result */
	adbCompRout = compRout;	/* save completion routine pointer */
	adbCompData = data;	/* save completion routine data pointer */
	adbWaitingCmd = adbOutputBuffer[2];	/* save wait command */

	if (adbWriteDelay != 1) {	/* start command now? */
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("out start NOW");
#endif
		delay(ADB_DELAY);
		adbActionState = ADB_ACTION_OUT;	/* set next state */
		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
		ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* load byte for output */
		ADB_SET_STATE_ACKOFF_CUDA();
		ADB_SET_STATE_TIP();	/* tell ADB that we want to send */
	}
	adbWriteDelay = 1;	/* something in the write "queue" */

	splx(s);

	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked? */
		/* poll until byte done */
		while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
		    || (adbWaiting == 1))
			if (ADB_SR_INTR_IS_ON) { /* wait for "interrupt" */
				adb_intr_cuda(NULL); /* go process it */
				if (adb_polling)
					adb_soft_intr();
			}

	return 0;
}				/* send_adb_cuda */


int
adb_intr_II(void *arg)
{
	struct adbCommand packet;
	int i, intr_on = 0;
	int send = 0;
	unsigned int s;

	s = splhigh();		/* can't be too careful - might be called */
	/* from a routine, NOT an interrupt */

	ADB_VIA_CLR_INTR();	/* clear interrupt */

	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */

	delay(ADB_DELAY);	/* yuck (don't remove) */

	(void)intr_dispatch(0x70); /* grab any serial interrupts */

	if (ADB_INTR_IS_ON)
		intr_on = 1;	/* save for later */
	
switch_start:
	switch (adbActionState) {
	case ADB_ACTION_POLLING:
		if (!intr_on) {
			if (adbOutQueueHasData) {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("POLL-doing-out-queue. ");
#endif
				ADB_SET_STATE_IDLE_II();
				delay(ADB_DELAY);

				/* copy over data */
				memcpy(adbOutputBuffer, adbOutQueue.outBuf,
				    adbOutQueue.outBuf[0] + 2);

				adbBuffer = adbOutQueue.saveBuf;	/* user data area */
				adbCompRout = adbOutQueue.compRout;	/* completion routine */
				adbCompData = adbOutQueue.data;	/* comp. rout. data */
				adbOutQueueHasData = 0;	/* currently processing
							 * "queue" entry */
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_OUT;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to send */
				break;
			} else {
#ifdef ADB_DEBUG
				if (adb_debug)
					printf_intr("pIDLE ");
#endif
				adbActionState = ADB_ACTION_IDLE;
			}
		} else {
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("pIN ");
#endif
			adbActionState = ADB_ACTION_IN;
		}
		delay(ADB_DELAY);
		(void)intr_dispatch(0x70); /* grab any serial interrupts */
		goto switch_start;
		break;
	case ADB_ACTION_IDLE:
		if (!intr_on) {
			i = ADB_SR();
			adbBusState = ADB_BUS_IDLE;
			adbActionState = ADB_ACTION_IDLE;
			ADB_SET_STATE_IDLE_II();
			break;
		}
		adbInputBuffer[0] = 1;
		adbInputBuffer[1] = ADB_SR();	/* get first byte */
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("idle 0x%02x ", adbInputBuffer[1]);
#endif
		ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
		adbActionState = ADB_ACTION_IN;	/* set next state */
		ADB_SET_STATE_EVEN();	/* set bus state to even */
		adbBusState = ADB_BUS_EVEN;
		break;

	case ADB_ACTION_IN:
		adbInputBuffer[++adbInputBuffer[0]] = ADB_SR();	/* get byte */
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("in 0x%02x ",
			    adbInputBuffer[adbInputBuffer[0]]);
#endif
		ADB_SET_SR_INPUT();	/* make sure SR is set to IN */

		if (intr_on) {	/* process last byte of packet */
			adbInputBuffer[0]--;	/* minus one */
			/*
			 * If intr_on was true, and it's the second byte, then
			 * the byte we just discarded is really valid, so
			 * adjust the count
			 */
			if (adbInputBuffer[0] == 2) {
				adbInputBuffer[0]++;
			}
				
#ifdef ADB_DEBUG
			if (adb_debug & 0x80) {
				printf_intr("done: ");
				print_single(adbInputBuffer);
			}
#endif

			adbLastDevice = ADB_CMDADDR(adbInputBuffer[1]);
			
			if (adbInputBuffer[0] == 1 && !adbWaiting) {	/* SRQ!!!*/
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr(" xSRQ! ");
#endif
				adb_guess_next_device();
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("try 0x%0x ",
					    adbLastDevice);
#endif
				adbOutputBuffer[0] = 1;
				adbOutputBuffer[1] = ADBTALK(adbLastDevice, 0);
			
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_POLLING;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to */
				break;
			}
				
			/* set up data for adb_pass_up */
			memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);

			if (!adbWaiting && (adbInputBuffer[0] != 0)) {
				packet.unsol = 1;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			} else {
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.unsol = 0;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			}

			adbWaiting = 0;
			adbInputBuffer[0] = 0;
			adbBuffer = (long)0;
			adbCompRout = (long)0;
			adbCompData = (long)0;
			/*
			 * Since we are done, check whether there is any data
			 * waiting to do out. If so, start the sending the data.
			 */
			if (adbOutQueueHasData == 1) {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("XXX: DOING OUT QUEUE\n");
#endif
				/* copy over data */
				memcpy(adbOutputBuffer, adbOutQueue.outBuf,
				    adbOutQueue.outBuf[0] + 2);
				adbBuffer = adbOutQueue.saveBuf;	/* user data area */
				adbCompRout = adbOutQueue.compRout;	/* completion routine */
				adbCompData = adbOutQueue.data;	/* comp. rout. data */
				adbOutQueueHasData = 0;	/* currently processing
							 * "queue" entry */
				send = 1;
			} else {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("XXending ");
#endif
				adb_guess_next_device();
				adbOutputBuffer[0] = 1;
				adbOutputBuffer[1] = ((adbLastDevice & 0x0f) << 4) | 0x0c;
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_POLLING;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to */
				break;
			}
		}

		/*
		 * If send is true then something above determined that
		 * the message has ended and we need to start sending out
		 * a new message immediately. This could be because there
		 * is data waiting to go out or because an SRQ was seen.
		 */
		if (send) {
			adbSentChars = 0;	/* nothing sent yet */
			adbActionState = ADB_ACTION_OUT;	/* set next state */
			ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
			ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
			adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
			ADB_SET_STATE_CMD();	/* tell ADB that we want to
						 * send */
			break;
		}
		/* We only get this far if the message hasn't ended yet. */
		switch (adbBusState) {	/* set to next state */
		case ADB_BUS_EVEN:
			ADB_SET_STATE_ODD();	/* set state to odd */
			adbBusState = ADB_BUS_ODD;
			break;

		case ADB_BUS_ODD:
			ADB_SET_STATE_EVEN();	/* set state to even */
			adbBusState = ADB_BUS_EVEN;
			break;
		default:
			printf_intr("strange state!!!\n");	/* huh? */
			break;
		}
		break;

	case ADB_ACTION_OUT:
		i = ADB_SR();	/* clear interrupt */
		adbSentChars++;
		/*
		 * If the outgoing data was a TALK, we must
		 * switch to input mode to get the result.
		 */
		if ((adbOutputBuffer[1] & 0x0c) == 0x0c) {
			adbInputBuffer[0] = 1;
			adbInputBuffer[1] = i;
			adbActionState = ADB_ACTION_IN;
			ADB_SET_SR_INPUT();
			adbBusState = ADB_BUS_EVEN;
			ADB_SET_STATE_EVEN();
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("talk out 0x%02x ", i);
#endif
			/* we want something back */
			adbWaiting = 1;
			break;
		}
		/*
		 * If it's not a TALK, check whether all data has been sent.
		 * If so, call the completion routine and clean up. If not,
		 * advance to the next state.
		 */
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("non-talk out 0x%0x ", i);
#endif
		ADB_SET_SR_OUTPUT();
		if (adbOutputBuffer[0] == adbSentChars) {	/* check for done */
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("done \n");
#endif
			/* set up stuff for adb_pass_up */
			memcpy(packet.data, adbOutputBuffer, adbOutputBuffer[0] + 1);
			packet.saveBuf = adbBuffer;
			packet.compRout = adbCompRout;
			packet.compData = adbCompData;
			packet.cmd = adbWaitingCmd;
			packet.unsol = 0;
			packet.ack_only = 1;
			adb_pass_up(&packet);

			/* reset "waiting" vars, just in case */ 
			adbBuffer = (long)0;
			adbCompRout = (long)0;
			adbCompData = (long)0;
			if (adbOutQueueHasData == 1) {
				/* copy over data */
				memcpy(adbOutputBuffer, adbOutQueue.outBuf,
				    adbOutQueue.outBuf[0] + 2);
				adbBuffer = adbOutQueue.saveBuf;	/* user data area */
				adbCompRout = adbOutQueue.compRout;	/* completion routine */
				adbCompData = adbOutQueue.data;	/* comp. rout. data */
				adbOutQueueHasData = 0;	/* currently processing
							 * "queue" entry */
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_OUT;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to
							 * send */
				break;
			} else {
				/* send talk to last device instead */
				adbOutputBuffer[0] = 1;
				adbOutputBuffer[1] =
				    ADBTALK(ADB_CMDADDR(adbOutputBuffer[1]), 0);
			
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_IDLE;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to */
				break;
			}
		}
		ADB_SR() = adbOutputBuffer[adbSentChars + 1];
		switch (adbBusState) {	/* advance to next state */
		case ADB_BUS_EVEN:
			ADB_SET_STATE_ODD();	/* set state to odd */
			adbBusState = ADB_BUS_ODD;
			break;

		case ADB_BUS_CMD:
		case ADB_BUS_ODD:
			ADB_SET_STATE_EVEN();	/* set state to even */
			adbBusState = ADB_BUS_EVEN;
			break;

		default:
#ifdef ADB_DEBUG
			if (adb_debug) {
				printf_intr("strange state!!! (0x%x)\n",
				    adbBusState);
			}
#endif
			break;
		}
		break;

	default:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: unknown ADB state (during intr)\n");
#endif
		break;
	}

	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */

	splx(s);		/* restore */

	return (1);

}


/*
 * send_adb version for II series machines
 */
int
send_adb_II(u_char *in, u_char *buffer, void *compRout, void *data, int command)
{
	int s, len;

	if (adbActionState == ADB_ACTION_NOTREADY)	/* return if ADB not
							 * available */
		return 1;

	/* Don't interrupt while we are messing with the ADB */
	s = splhigh();

	if (0 != adbOutQueueHasData) {	/* right now, "has data" means "full" */
		splx(s);	/* sorry, try again later */
		return 1;
	}
	if ((long)in == (long)0) {	/* need to convert? */
		/*
		 * Don't need to use adb_cmd_extra here because this section
		 * will be called ONLY when it is an ADB command (no RTC or
		 * PRAM), especially on II series!
		 */
		if ((command & 0x0c) == 0x08)	/* copy addl data ONLY if
						 * doing a listen! */
			len = buffer[0];	/* length of additional data */
		else
			len = 0;/* no additional data */

		adbOutQueue.outBuf[0] = 1 + len;	/* command + addl. data */
		adbOutQueue.outBuf[1] = (u_char)command;	/* load command */

		/* copy additional output data, if any */
		memcpy(adbOutQueue.outBuf + 2, buffer + 1, len);
	} else
		/* if data ready, just copy over */
		memcpy(adbOutQueue.outBuf, in, in[0] + 2);

	adbOutQueue.saveBuf = buffer;	/* save buffer to know where to save
					 * result */
	adbOutQueue.compRout = compRout;	/* save completion routine
						 * pointer */
	adbOutQueue.data = data;/* save completion routine data pointer */

	if ((adbActionState == ADB_ACTION_IDLE) &&	/* is ADB available? */
	    (ADB_INTR_IS_OFF)) {	/* and no incoming interrupts? */
		/* then start command now */
		memcpy(adbOutputBuffer, adbOutQueue.outBuf,
		    adbOutQueue.outBuf[0] + 2);		/* copy over data */

		adbBuffer = adbOutQueue.saveBuf;	/* pointer to user data
							 * area */
		adbCompRout = adbOutQueue.compRout;	/* pointer to the
							 * completion routine */
		adbCompData = adbOutQueue.data;	/* pointer to the completion
						 * routine data */

		adbSentChars = 0;	/* nothing sent yet */
		adbActionState = ADB_ACTION_OUT;	/* set next state */
		adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */

		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */

		ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* load byte for output */
		ADB_SET_STATE_CMD();	/* tell ADB that we want to send */
		adbOutQueueHasData = 0;	/* currently processing "queue" entry */
	} else
		adbOutQueueHasData = 1;	/* something in the write "queue" */

	splx(s);

	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked? */
		/* poll until message done */
		while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
		    || (adbWaiting == 1))
			if (ADB_SR_INTR_IS_ON) { /* wait for "interrupt" */
				adb_intr_II(NULL); /* go process it */
				if (adb_polling)
					adb_soft_intr();
			}

	return 0;
}


/*
 * This routine is called from the II series interrupt routine
 * to determine what the "next" device is that should be polled.
 */
int
adb_guess_next_device(void)
{
	int last, i, dummy;

	if (adbStarting) {
		/*
		 * Start polling EVERY device, since we can't be sure there is
		 * anything in the device table yet
		 */
		if (adbLastDevice < 1 || adbLastDevice > 15)
			adbLastDevice = 1;
		if (++adbLastDevice > 15)	/* point to next one */
			adbLastDevice = 1;
	} else {
		/* find the next device using the device table */
		if (adbLastDevice < 1 || adbLastDevice > 15)	/* let's be parinoid */
			adbLastDevice = 2;
		last = 1;	/* default index location */

		for (i = 1; i < 16; i++)	/* find index entry */
			if (ADBDevTable[i].currentAddr == adbLastDevice) {	/* look for device */
				last = i;	/* found it */
				break;
			}
		dummy = last;	/* index to start at */
		for (;;) {	/* find next device in index */
			if (++dummy > 15)	/* wrap around if needed */
				dummy = 1;
			if (dummy == last) {	/* didn't find any other
						 * device! This can happen if
						 * there are no devices on the
						 * bus */
				dummy = 1;
				break;
			}
			/* found the next device */
			if (ADBDevTable[dummy].devType != 0)
				break;
		}
		adbLastDevice = ADBDevTable[dummy].currentAddr;
	}
	return adbLastDevice;
}


/*
 * Called when when an adb interrupt happens.
 * This routine simply transfers control over to the appropriate
 * code for the machine we are running on.
 */
int
adb_intr(void *arg)
{
	switch (adbHardware) {
	case ADB_HW_II:
		return adb_intr_II(arg);
		break;

	case ADB_HW_IISI:
		return adb_intr_IIsi(arg);
		break;

	case ADB_HW_PB:		/* Should not come through here. */
		break;

	case ADB_HW_CUDA:
		return adb_intr_cuda(arg);
		break;

	case ADB_HW_UNKNOWN:
		break;
	}

	return (-1);
}


/*
 * called when when an adb interrupt happens
 *
 * IIsi version of adb_intr
 *
 */
int
adb_intr_IIsi(void *arg)
{
	struct adbCommand packet;
	int i, ending;
	unsigned int s;

	s = splhigh();		/* can't be too careful - might be called */
	/* from a routine, NOT an interrupt */

	ADB_VIA_CLR_INTR();	/* clear interrupt */

	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */

switch_start:
	switch (adbActionState) {
	case ADB_ACTION_IDLE:
		delay(ADB_DELAY);	/* short delay is required before the
					 * first byte */

		ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
		ADB_SET_STATE_ACTIVE();	/* signal start of data frame */
		adbInputBuffer[1] = ADB_SR();	/* get byte */
		adbInputBuffer[0] = 1;
		adbActionState = ADB_ACTION_IN;	/* set next state */

		ADB_SET_STATE_ACKON();	/* start ACK to ADB chip */
		delay(ADB_DELAY);	/* delay */
		ADB_SET_STATE_ACKOFF();	/* end ACK to ADB chip */
		(void)intr_dispatch(0x70); /* grab any serial interrupts */
		break;

	case ADB_ACTION_IN:
		ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
		adbInputBuffer[++adbInputBuffer[0]] = ADB_SR();	/* get byte */
		if (ADB_INTR_IS_OFF)	/* check for end of frame */
			ending = 1;
		else
			ending = 0;

		ADB_SET_STATE_ACKON();	/* start ACK to ADB chip */
		delay(ADB_DELAY);	/* delay */
		ADB_SET_STATE_ACKOFF();	/* end ACK to ADB chip */
		(void)intr_dispatch(0x70); /* grab any serial interrupts */

		if (1 == ending) {	/* end of message? */
			ADB_SET_STATE_INACTIVE();	/* signal end of frame */
			/*
			 * This section _should_ handle all ADB and RTC/PRAM
			 * type commands, but there may be more...  Note:
			 * commands are always at [4], even for rtc/pram
			 * commands
			 */
			/* set up data for adb_pass_up */
			memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);
				
			if ((adbWaiting == 1) &&	/* are we waiting AND */
			    (adbInputBuffer[4] == adbWaitingCmd) &&	/* the cmd we sent AND */
			    ((adbInputBuffer[2] == 0x00) ||	/* it's from the ADB
								 * device OR */
				(adbInputBuffer[2] == 0x01))) {	/* it's from the
								 * PRAM/RTC device */

				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.unsol = 0;
				packet.ack_only = 0;
				adb_pass_up(&packet);

				adbWaitingCmd = 0;	/* reset "waiting" vars */
				adbWaiting = 0;
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
			} else {
				packet.unsol = 1;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			}

			adbActionState = ADB_ACTION_IDLE;
			adbInputBuffer[0] = 0;	/* reset length */

			if (adbWriteDelay == 1) {	/* were we waiting to
							 * write? */
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_OUT;	/* set next state */

				delay(ADB_DELAY);	/* delay */
				(void)intr_dispatch(0x70); /* grab any serial interrupts */

				if (ADB_INTR_IS_ON) {	/* ADB intr low during
							 * write */
					ADB_SET_STATE_IDLE_IISI();	/* reset */
					ADB_SET_SR_INPUT();	/* make sure SR is set
								 * to IN */
					adbSentChars = 0;	/* must start all over */
					adbActionState = ADB_ACTION_IDLE;	/* new state */
					adbInputBuffer[0] = 0;
					/* may be able to take this out later */
					delay(ADB_DELAY);	/* delay */
					break;
				}
				ADB_SET_STATE_ACTIVE();	/* tell ADB that we want
							 * to send */
				ADB_SET_STATE_ACKOFF();	/* make sure */
				ADB_SET_SR_OUTPUT();	/* set shift register
							 * for OUT */
				ADB_SR() = adbOutputBuffer[adbSentChars + 1];
				ADB_SET_STATE_ACKON();	/* tell ADB byte ready
							 * to shift */
			}
		}
		break;

	case ADB_ACTION_OUT:
		i = ADB_SR();	/* reset SR-intr in IFR */
		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */

		ADB_SET_STATE_ACKOFF();	/* finish ACK */
		adbSentChars++;
		if (ADB_INTR_IS_ON) {	/* ADB intr low during write */
			ADB_SET_STATE_IDLE_IISI();	/* reset */
			ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
			adbSentChars = 0;	/* must start all over */
			adbActionState = ADB_ACTION_IDLE;	/* new state */
			adbInputBuffer[0] = 0;
			adbWriteDelay = 1;	/* must retry when done with
						 * read */
			delay(ADB_DELAY);	/* delay */
			(void)intr_dispatch(0x70); /* grab any serial interrupts */
			goto switch_start;	/* process next state right
						 * now */
			break;
		}
		delay(ADB_DELAY);	/* required delay */
		(void)intr_dispatch(0x70); /* grab any serial interrupts */

		if (adbOutputBuffer[0] == adbSentChars) {	/* check for done */
			if (0 == adb_cmd_result(adbOutputBuffer)) {	/* do we expect data
									 * back? */
				adbWaiting = 1;	/* signal waiting for return */
				adbWaitingCmd = adbOutputBuffer[2];	/* save waiting command */
			} else {/* no talk, so done */
				/* set up stuff for adb_pass_up */
				memcpy(packet.data, adbInputBuffer,
				    adbInputBuffer[0] + 1);
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.cmd = adbWaitingCmd;
				packet.unsol = 0;
				packet.ack_only = 1;
				adb_pass_up(&packet);

				/* reset "waiting" vars, just in case */
				adbWaitingCmd = 0;
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
			}

			adbWriteDelay = 0;	/* done writing */
			adbActionState = ADB_ACTION_IDLE;	/* signal bus is idle */
			ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
			ADB_SET_STATE_INACTIVE();	/* end of frame */
		} else {
			ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* send next byte */
			ADB_SET_STATE_ACKON();	/* signal byte ready to shift */
		}
		break;

	case ADB_ACTION_NOTREADY:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: not yet initialized\n");
#endif
		break;

	default:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("intr: unknown ADB state\n");
#endif
		break;
	}

	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */

	splx(s);		/* restore */

	return (1);
}				/* end adb_intr_IIsi */


/*****************************************************************************
 * if the device is currently busy, and there is no data waiting to go out, then
 * the data is "queued" in the outgoing buffer. If we are already waiting, then
 * we return.
 * in: if (in == 0) then the command string is built from command and buffer
 *     if (in != 0) then in is used as the command string
 * buffer: additional data to be sent (used only if in == 0)
 *         this is also where return data is stored
 * compRout: the completion routine that is called when then return value
 *	     is received (if a return value is expected)
 * data: a data pointer that can be used by the completion routine
 * command: an ADB command to be sent (used only if in == 0)
 *
 */
int
send_adb_IIsi(u_char *in, u_char *buffer, void *compRout, void *data, int
	command)
{
	int s, len;

	if (adbActionState == ADB_ACTION_NOTREADY)
		return 1;

	/* Don't interrupt while we are messing with the ADB */
	s = splhigh();

	if ((adbActionState == ADB_ACTION_IDLE) &&	/* ADB available? */
	    (ADB_INTR_IS_OFF)) {/* and no incoming interrupt? */

	} else
		if (adbWriteDelay == 0)	/* it's busy, but is anything waiting? */
			adbWriteDelay = 1;	/* if no, then we'll "queue"
						 * it up */
		else {
			splx(s);
			return 1;	/* really busy! */
		}

	if ((long)in == (long)0) {	/* need to convert? */
		/*
		 * Don't need to use adb_cmd_extra here because this section
		 * will be called ONLY when it is an ADB command (no RTC or
		 * PRAM)
		 */
		if ((command & 0x0c) == 0x08)	/* copy addl data ONLY if
						 * doing a listen! */
			len = buffer[0];	/* length of additional data */
		else
			len = 0;/* no additional data */

		adbOutputBuffer[0] = 2 + len;	/* dev. type + command + addl.
						 * data */
		adbOutputBuffer[1] = 0x00;	/* mark as an ADB command */
		adbOutputBuffer[2] = (u_char)command;	/* load command */

		/* copy additional output data, if any */
		memcpy(adbOutputBuffer + 3, buffer + 1, len);
	} else
		/* if data ready, just copy over */
		memcpy(adbOutputBuffer, in, in[0] + 2);

	adbSentChars = 0;	/* nothing sent yet */
	adbBuffer = buffer;	/* save buffer to know where to save result */
	adbCompRout = compRout;	/* save completion routine pointer */
	adbCompData = data;	/* save completion routine data pointer */
	adbWaitingCmd = adbOutputBuffer[2];	/* save wait command */

	if (adbWriteDelay != 1) {	/* start command now? */
		adbActionState = ADB_ACTION_OUT;	/* set next state */

		ADB_SET_STATE_ACTIVE();	/* tell ADB that we want to send */
		ADB_SET_STATE_ACKOFF();	/* make sure */

		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */

		ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* load byte for output */

		ADB_SET_STATE_ACKON();	/* tell ADB byte ready to shift */
	}
	adbWriteDelay = 1;	/* something in the write "queue" */

	splx(s);

	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked? */
		/* poll until byte done */
		while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
		    || (adbWaiting == 1))
			if (ADB_SR_INTR_IS_ON) { /* wait for "interrupt" */
				adb_intr_IIsi(NULL); /* go process it */
				if (adb_polling)
					adb_soft_intr();
			}

	 return 0;
}				/* send_adb_IIsi */

/* 
 * adb_pass_up is called by the interrupt-time routines.
 * It takes the raw packet data that was received from the
 * device and puts it into the queue that the upper half
 * processes. It then signals for a soft ADB interrupt which
 * will eventually call the upper half routine (adb_soft_intr).
 *
 * If in->unsol is 0, then this is either the notification
 * that the packet was sent (on a LISTEN, for example), or the 
 * response from the device (on a TALK). The completion routine
 * is called only if the user specified one.
 *
 * If in->unsol is 1, then this packet was unsolicited and
 * so we look up the device in the ADB device table to determine
 * what it's default service routine is.
 *
 * If in->ack_only is 1, then we really only need to call
 * the completion routine, so don't do any other stuff.
 *
 * Note that in->data contains the packet header AND data,
 * while adbInbound[]->data contains ONLY data.
 *
 * Note: Called only at interrupt time. Assumes this.
 */
void
adb_pass_up(struct adbCommand *in)
{
	int start = 0, len = 0, cmd = 0;
	ADBDataBlock block;

	/* temp for testing */
	/*u_char *buffer = 0;*/
	/*u_char *compdata = 0;*/
	/*u_char *comprout = 0;*/

	if (adbInCount >= ADB_QUEUE) {
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: ring buffer overflow\n");
#endif
		return;
	}

	if (in->ack_only) {
		len = in->data[0];
		cmd = in->cmd;
		start = 0;
	} else {
		switch (adbHardware) {
		case ADB_HW_II:
			cmd = in->data[1];
			if (in->data[0] < 2)
				len = 0;
			else
				len = in->data[0]-1;
			start = 1;
			break;

		case ADB_HW_IISI:
		case ADB_HW_CUDA:
			/* If it's unsolicited, accept only ADB data for now */
			if (in->unsol)
				if (0 != in->data[2])
					return;
			cmd = in->data[4];
			if (in->data[0] < 5)
				len = 0;
			else
				len = in->data[0]-4;
			start = 4;
			break;

		case ADB_HW_PB:
			cmd = in->data[1];
			if (in->data[0] < 2)
				len = 0;
			else
				len = in->data[0]-1;
			start = 1;
			break;

		case ADB_HW_UNKNOWN:
			return;
		}

		/* Make sure there is a valid device entry for this device */
		if (in->unsol) {
			/* ignore unsolicited data during adbreinit */
			if (adbStarting)
				return;
			/* get device's comp. routine and data area */
			if (-1 == get_adb_info(&block, ADB_CMDADDR(cmd)))
				return;
		}
	}

	/*
 	 * If this is an unsolicited packet, we need to fill in
 	 * some info so adb_soft_intr can process this packet
 	 * properly. If it's not unsolicited, then use what
 	 * the caller sent us.
 	 */
	if (in->unsol) {
		adbInbound[adbInTail].compRout = (void *)block.dbServiceRtPtr;
		adbInbound[adbInTail].compData = (void *)block.dbDataAreaAddr;
		adbInbound[adbInTail].saveBuf = (void *)adbInbound[adbInTail].data;
	} else {
		adbInbound[adbInTail].compRout = (void *)in->compRout;
		adbInbound[adbInTail].compData = (void *)in->compData;
		adbInbound[adbInTail].saveBuf = (void *)in->saveBuf;
	}

#ifdef ADB_DEBUG
	if (adb_debug && in->data[1] == 2) 
		printf_intr("adb: caught error\n");
#endif

	/* copy the packet data over */
	/*
	 * TO DO: If the *_intr routines fed their incoming data
	 * directly into an adbCommand struct, which is passed to 
	 * this routine, then we could eliminate this copy.
	 */
	memcpy(adbInbound[adbInTail].data + 1, in->data + start + 1, len);
	adbInbound[adbInTail].data[0] = len;
	adbInbound[adbInTail].cmd = cmd;

	adbInCount++;
	if (++adbInTail >= ADB_QUEUE)
		adbInTail = 0;

	/*
	 * If the debugger is running, call upper half manually.
	 * Otherwise, trigger a soft interrupt to handle the rest later.
	 */
	if (adb_polling)
		adb_soft_intr();
	else
		setsoftadb();

	return;
}


/*
 * Called to process the packets after they have been
 * placed in the incoming queue.
 *
 */
void
adb_soft_intr(void)
{
	int s;
	int cmd = 0;
	u_char *buffer = 0;
	u_char *comprout = 0;
	u_char *compdata = 0;

/*delay(2*ADB_DELAY);*/

	while (adbInCount) {
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("%x %x %x ",
			    adbInCount, adbInHead, adbInTail);
#endif
		/* get the data we need from the queue */
		buffer = adbInbound[adbInHead].saveBuf;
		comprout = adbInbound[adbInHead].compRout;
		compdata = adbInbound[adbInHead].compData;
		cmd = adbInbound[adbInHead].cmd;
	
		/* copy over data to data area if it's valid */
		/*
		 * Note that for unsol packets we don't want to copy the
	 	 * data anywhere, so buffer was already set to 0.
	 	 * For ack_only buffer was set to 0, so don't copy.
		 */
		if (buffer)
			memcpy(buffer, adbInbound[adbInHead].data,
			    adbInbound[adbInHead].data[0] + 1);

#ifdef ADB_DEBUG
			if (adb_debug & 0x80) {
				printf_intr("%p %p %p %x ",
				    buffer, comprout, compdata, (short)cmd);
				printf_intr("buf: ");
				print_single(adbInbound[adbInHead].data);
			}
#endif

		/* call default completion routine if it's valid */
		if (comprout) {
			(void)((int (*)(u_char *, u_char *, int))comprout)
			    (buffer, compdata, cmd);
		}

		s = splhigh();
		adbInCount--;
		if (++adbInHead >= ADB_QUEUE)
			adbInHead = 0;
		splx(s);

	}
	return;
}


/*
 * This is my version of the ADBOp routine. It mainly just calls the
 * hardware-specific routine.
 *
 *   data 	: pointer to data area to be used by compRout
 *   compRout	: completion routine
 *   buffer	: for LISTEN: points to data to send - MAX 8 data bytes,
 *		  byte 0 = # of bytes
 *		: for TALK: points to place to save return data
 *   command	: the adb command to send
 *   result	: 0 = success
 *		: -1 = could not complete
 */
int
adb_op(Ptr buffer, Ptr compRout, Ptr data, short command)
{
	int result;

	switch (adbHardware) {
	case ADB_HW_II:
		result = send_adb_II((u_char *)0, (u_char *)buffer,
		    (void *)compRout, (void *)data, (int)command);
		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_IISI:
		result = send_adb_IIsi((u_char *)0, (u_char *)buffer,
		    (void *)compRout, (void *)data, (int)command);
		/*
		 * I wish I knew why this delay is needed. It usually needs to
		 * be here when several commands are sent in close succession,
		 * especially early in device probes when doing collision
		 * detection. It must be some race condition. Sigh. - jpw
		 */
		delay(100);
		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_PB:
		result = pm_adb_op((u_char *)buffer, (void *)compRout,
		    (void *)data, (int)command);

		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_CUDA:
		result = send_adb_cuda((u_char *)0, (u_char *)buffer,
		    (void *)compRout, (void *)data, (int)command);
		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}


/*
 * adb_hw_setup
 * This routine sets up the possible machine specific hardware
 * config (mainly VIA settings) for the various models.
 */
void
adb_hw_setup(void)
{
	volatile int i;
	u_char send_string[ADB_MAX_MSG_LENGTH];

	switch (adbHardware) {
	case ADB_HW_II:
		via1_register_irq(2, adb_intr_II, NULL, NULL);

		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN (II, IIsi) */
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware (II, IIsi) */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on (II, IIsi) */
		ADB_SET_STATE_IDLE_II();	/* set ADB bus state to idle */

		ADB_VIA_CLR_INTR();	/* clear interrupt */
		break;

	case ADB_HW_IISI:
		via1_register_irq(2, adb_intr_IIsi, NULL, NULL);
		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN (II, IIsi) */
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware (II, IIsi) */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on (II, IIsi) */
		ADB_SET_STATE_IDLE_IISI();	/* set ADB bus state to idle */

		/* get those pesky clock ticks we missed while booting */
		for (i = 0; i < 30; i++) {
			delay(ADB_DELAY);
			adb_hw_setup_IIsi(send_string);
#ifdef ADB_DEBUG
			if (adb_debug) {
				printf_intr("adb: cleanup: ");
				print_single(send_string);
			}
#endif
			delay(ADB_DELAY);
			if (ADB_INTR_IS_OFF)
				break;
		}
		break;

	case ADB_HW_PB:
		/*
		 * XXX - really PM_VIA_CLR_INTR - should we put it in
		 * pm_direct.h?
		 */
		pm_hw_setup();
		break;

	case ADB_HW_CUDA:
		via1_register_irq(2, adb_intr_cuda, NULL, NULL);
		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN */
		via_reg(VIA1, vACR) = (via_reg(VIA1, vACR) | 0x0c) & ~0x10;
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on */
		ADB_SET_STATE_IDLE_CUDA();	/* set ADB bus state to idle */

		/* sort of a device reset */
		i = ADB_SR();	/* clear interrupt */
		ADB_VIA_INTR_DISABLE();	/* no interrupts while clearing */
		ADB_SET_STATE_IDLE_CUDA();	/* reset state to idle */
		delay(ADB_DELAY);
		ADB_SET_STATE_TIP();	/* signal start of frame */
		delay(ADB_DELAY);
		ADB_TOGGLE_STATE_ACK_CUDA();
		delay(ADB_DELAY);
		ADB_CLR_STATE_TIP();
		delay(ADB_DELAY);
		ADB_SET_STATE_IDLE_CUDA();	/* back to idle state */
		i = ADB_SR();	/* clear interrupt */
		ADB_VIA_INTR_ENABLE();	/* ints ok now */
		break;

	case ADB_HW_UNKNOWN:
	default:
		via_reg(VIA1, vIER) = 0x04;	/* turn interrupts off - TO
						 * DO: turn PB ints off? */
		return;
		break;
	}
}


/*
 * adb_hw_setup_IIsi
 * This is sort of a "read" routine that forces the adb hardware through a read cycle
 * if there is something waiting. This helps "clean up" any commands that may have gotten
 * stuck or stopped during the boot process.
 *
 */
void
adb_hw_setup_IIsi(u_char *buffer)
{
	int i;
	int dummy;
	int s;
	long my_time;
	int endofframe;

	delay(ADB_DELAY);

	i = 1;			/* skip over [0] */
	s = splhigh();		/* block ALL interrupts while we are working */
	ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */
	/* this is required, especially on faster machines */
	delay(ADB_DELAY);

	if (ADB_INTR_IS_ON) {
		ADB_SET_STATE_ACTIVE();	/* signal start of data frame */

		endofframe = 0;
		while (0 == endofframe) {
			/*
			 * Poll for ADB interrupt and watch for timeout.
			 * If time out, keep going in hopes of not hanging
			 * the ADB chip - I think
			 */
			my_time = ADB_DELAY * 5;
			while ((ADB_SR_INTR_IS_OFF) && (my_time-- > 0))
				dummy = via_reg(VIA1, vBufB);

			buffer[i++] = ADB_SR();	/* reset interrupt flag by
						 * reading vSR */
			/*
			 * Perhaps put in a check here that ignores all data
			 * after the first ADB_MAX_MSG_LENGTH bytes ???
			 */
			if (ADB_INTR_IS_OFF)	/* check for end of frame */
				endofframe = 1;

			ADB_SET_STATE_ACKON();	/* send ACK to ADB chip */
			delay(ADB_DELAY);	/* delay */
			ADB_SET_STATE_ACKOFF();	/* send ACK to ADB chip */
		}
		ADB_SET_STATE_INACTIVE();	/* signal end of frame and
						 * delay */

		/* probably don't need to delay this long */
		delay(ADB_DELAY);
	}
	buffer[0] = --i;	/* [0] is length of message */
	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */
	splx(s);		/* restore interrupts */

	return;
}				/* adb_hw_setup_IIsi */



/*
 * adb_reinit sets up the adb stuff
 *
 */
void
adb_reinit(void)
{
	u_char send_string[ADB_MAX_MSG_LENGTH];
	ADBDataBlock data;	/* temp. holder for getting device info */
	volatile int i, x;
	int s;
	int command;
	int result;
	int saveptr;		/* point to next free relocation address */
	int device;
	int nonewtimes;		/* times thru loop w/o any new devices */

	via1_register_irq(2, adb_intr, NULL, "adb");
	adb_setup_hw_type();	/* setup hardware type */

	/* Make sure we are not interrupted while building the table. */
	/* ints must be on for PB & IOP (at least, for now) */
	if (adbHardware != ADB_HW_PB)
		s = splhigh();
	else
		s = 0;		/* XXX shut the compiler up*/

	ADBNumDevices = 0;	/* no devices yet */

	/* Let intr routines know we are running reinit */
	adbStarting = 1;

	/*
	 * Initialize the ADB table.  For now, we'll always use the same table
	 * that is defined at the beginning of this file - no mallocs.
	 */
	for (i = 0; i < 16; i++) {
		ADBDevTable[i].devType = 0;
		ADBDevTable[i].origAddr = ADBDevTable[i].currentAddr = 0;
	}

	adb_hw_setup();		/* init the VIA bits and hard reset ADB */

	delay(1000);

	/* send an ADB reset first */
	(void)adb_op_sync((Ptr)0, (Ptr)0, (Ptr)0, (short)0x00);
	delay(3000);

	/*
	 * Probe for ADB devices. Probe devices 1-15 quickly to determine
	 * which device addresses are in use and which are free. For each
	 * address that is in use, move the device at that address to a higher
	 * free address. Continue doing this at that address until no device
	 * responds at that address. Then move the last device that was moved
	 * back to the original address. Do this for the remaining addresses
	 * that we determined were in use.
	 * 
	 * When finished, do this entire process over again with the updated
	 * list of in use addresses. Do this until no new devices have been
	 * found in 20 passes though the in use address list. (This probably
	 * seems long and complicated, but it's the best way to detect multiple
	 * devices at the same address - sometimes it takes a couple of tries
	 * before the collision is detected.)
	 */

	/* initial scan through the devices */
	for (i = 1; i < 16; i++) {
		command = ADBTALK(i, 3);
		result = adb_op_sync((Ptr)send_string, (Ptr)0,
		    (Ptr)0, (short)command);

		if (result == 0 && send_string[0] != 0) {
			/* found a device */
			++ADBNumDevices;
			KASSERT(ADBNumDevices < 16);
			ADBDevTable[ADBNumDevices].devType =
				(int)(send_string[2]);
			ADBDevTable[ADBNumDevices].origAddr = i;
			ADBDevTable[ADBNumDevices].currentAddr = i;
			ADBDevTable[ADBNumDevices].DataAreaAddr =
			    (long)0;
			ADBDevTable[ADBNumDevices].ServiceRtPtr = (void *)0;
			pm_check_adb_devices(i);	/* tell pm driver device
							 * is here */
		}
	}

	/* find highest unused address */
	for (saveptr = 15; saveptr > 0; saveptr--)
		if (-1 == get_adb_info(&data, saveptr))
			break;

#ifdef ADB_DEBUG
	if (adb_debug & 0x80) {
		printf_intr("first free is: 0x%02x\n", saveptr);
		printf_intr("devices: %i\n", ADBNumDevices);
	}
#endif

	nonewtimes = 0;		/* no loops w/o new devices */
	while (saveptr > 0 && nonewtimes++ < 11) {
		for (i = 1;saveptr > 0 && i <= ADBNumDevices; i++) {
			device = ADBDevTable[i].currentAddr;
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("moving device 0x%02x to 0x%02x "
				    "(index 0x%02x)  ", device, saveptr, i);
#endif

			/* send TALK R3 to address */
			command = ADBTALK(device, 3);
			(void)adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);

			/* move device to higher address */
			command = ADBLISTEN(device, 3);
			send_string[0] = 2;
			send_string[1] = (u_char)(saveptr | 0x60);
			send_string[2] = 0xfe;
			(void)adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
			delay(1000);

			/* send TALK R3 - anthing at new address? */
			command = ADBTALK(saveptr, 3);
			send_string[0] = 0;
			result = adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
			delay(1000);

			if (result != 0 || send_string[0] == 0) {
				/*
				 * maybe there's a communication breakdown;
				 * just in case, move it back from whence it
				 * came, and we'll try again later
				 */
				command = ADBLISTEN(saveptr, 3);
				send_string[0] = 2;
				send_string[1] = (u_char)(device | 0x60);
				send_string[2] = 0x00;
				(void)adb_op_sync((Ptr)send_string, (Ptr)0,
				    (Ptr)0, (short)command);
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("failed, continuing\n");
#endif
				delay(1000);
				continue;
			}

			/* send TALK R3 - anything at old address? */
			command = ADBTALK(device, 3);
			send_string[0] = 0;
			result = adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
			if (result == 0 && send_string[0] != 0) {
				/* new device found */
				/* update data for previously moved device */
				ADBDevTable[i].currentAddr = saveptr;
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("old device at index %i\n",i);
#endif
				/* add new device in table */
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("new device found\n");
#endif
				if (saveptr > ADBNumDevices) {
					++ADBNumDevices;
					KASSERT(ADBNumDevices < 16);
				}
				ADBDevTable[ADBNumDevices].devType =
					(int)(send_string[2]);
				ADBDevTable[ADBNumDevices].origAddr = device;
				ADBDevTable[ADBNumDevices].currentAddr = device;
				/* These will be set correctly in adbsys.c */
				/* Until then, unsol. data will be ignored. */
				ADBDevTable[ADBNumDevices].DataAreaAddr =
				    (long)0;
				ADBDevTable[ADBNumDevices].ServiceRtPtr =
				    (void *)0;
				/* find next unused address */
				for (x = saveptr; x > 0; x--) {
					if (-1 == get_adb_info(&data, x)) {
						saveptr = x;
						break;
					}
				}
				if (x == 0)
					saveptr = 0;
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("new free is 0x%02x\n",
					    saveptr);
#endif
				nonewtimes = 0;
				/* tell pm driver device is here */
				pm_check_adb_devices(device);
			} else {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("moving back...\n");
#endif
				/* move old device back */
				command = ADBLISTEN(saveptr, 3);
				send_string[0] = 2;
				send_string[1] = (u_char)(device | 0x60);
				send_string[2] = 0xfe;
				(void)adb_op_sync((Ptr)send_string, (Ptr)0,
				    (Ptr)0, (short)command);
				delay(1000);
			}
		}
	}

#ifdef ADB_DEBUG
	if (adb_debug) {
		for (i = 1; i <= ADBNumDevices; i++) {
			x = get_ind_adb_info(&data, i);
			if (x != -1)
				printf_intr("index 0x%x, addr 0x%x, type 0x%hx\n",
				    i, x, data.devType);
		}
	}
#endif

	/* enable the programmer's switch, if we have one */
	adb_prog_switch_enable();

#ifdef ADB_DEBUG
	if (adb_debug) {
		if (0 == ADBNumDevices)	/* tell user if no devices found */
			printf_intr("adb: no devices found\n");
	}
#endif

	adbStarting = 0;	/* not starting anymore */
#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("adb: ADBReInit complete\n");
#endif

	if (adbHardware == ADB_HW_CUDA) {
		timeout_set(&adb_cuda_timeout, (void *)adb_cuda_tickle, NULL);
		timeout_add(&adb_cuda_timeout, ADB_TICKLE_TICKS);
	}

	/* ints must be on for PB & IOP (at least, for now) */
	if (adbHardware != ADB_HW_PB)
		splx(s);

	return;
}


/*
 * adb_cmd_result
 *
 * This routine lets the caller know whether the specified adb command string
 * should expect a returned result, such as a TALK command.
 *
 * returns: 0 if a result should be expected
 *          1 if a result should NOT be expected
 */
int
adb_cmd_result(u_char *in)
{
	switch (adbHardware) {
	case ADB_HW_II:
		/* was it an ADB talk command? */
		if ((in[1] & 0x0c) == 0x0c)
			return 0;
		return 1;

	case ADB_HW_IISI:
	case ADB_HW_CUDA:
		/* was it an ADB talk command? */
		if ((in[1] == 0x00) && ((in[2] & 0x0c) == 0x0c))
			return 0;
		/* was it an RTC/PRAM read date/time? */
		if ((in[1] == 0x01) && (in[2] == 0x03))
			return 0;
		return 1;

	case ADB_HW_PB:
		return 1;

	case ADB_HW_UNKNOWN:
	default:
		return 1;
	}
}


/*
 * adb_cmd_extra
 *
 * This routine lets the caller know whether the specified adb command string
 * may have extra data appended to the end of it, such as a LISTEN command.
 *
 * returns: 0 if extra data is allowed
 *          1 if extra data is NOT allowed
 */
int
adb_cmd_extra(u_char *in)
{
	switch (adbHardware) {
	case ADB_HW_II:
		if ((in[1] & 0x0c) == 0x08)	/* was it a listen command? */
			return 0;
		return 1;

	case ADB_HW_IISI:
	case ADB_HW_CUDA:
		/*
		 * TO DO: support needs to be added to recognize RTC and PRAM
		 * commands
		 */
		if ((in[2] & 0x0c) == 0x08)	/* was it a listen command? */
			return 0;
		/* add others later */
		return 1;

	case ADB_HW_PB:
		return 1;

	case ADB_HW_UNKNOWN:
	default:
		return 1;
	}
}


void 
adb_setup_hw_type(void)
{
	long response;

	response = mac68k_machine.machineid;

	/*
	 * Determine what type of ADB hardware we are running on.
	 */
	switch (response) {
	case MACH_MACC610:		/* Centris 610 */
	case MACH_MACC650:		/* Centris 650 */
	case MACH_MACII:		/* II */
	case MACH_MACIICI:		/* IIci */
	case MACH_MACIICX:		/* IIcx */
	case MACH_MACIIX:		/* IIx */
	case MACH_MACQ610:		/* Quadra 610 */
	case MACH_MACQ650:		/* Quadra 650 */
	case MACH_MACQ700:		/* Quadra 700 */
	case MACH_MACQ800:		/* Quadra 800 */
	case MACH_MACSE30:		/* SE/30 */
		adbHardware = ADB_HW_II;
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using II series hardware support\n");
#endif
		break;

	case MACH_MACCLASSICII:		/* Classic II */
	case MACH_MACLCII:		/* LC II, Performa 400/405/430 */
	case MACH_MACLCIII:		/* LC III, Performa 450 */
	case MACH_MACIISI:		/* IIsi */
	case MACH_MACIIVI:		/* IIvi */
	case MACH_MACIIVX:		/* IIvx */
	case MACH_MACP460:		/* Performa 460/465/467 */
	case MACH_MACP600:		/* Performa 600 */
		adbHardware = ADB_HW_IISI;
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using IIsi series hardware support\n");
#endif
		break;

	case MACH_MACPB140:		/* PowerBook 140 */
	case MACH_MACPB145:		/* PowerBook 145 */
	case MACH_MACPB160:		/* PowerBook 160 */
	case MACH_MACPB165:		/* PowerBook 165 */
	case MACH_MACPB165C:		/* PowerBook 165c */
	case MACH_MACPB170:		/* PowerBook 170 */
	case MACH_MACPB180:		/* PowerBook 180 */
	case MACH_MACPB180C:		/* PowerBook 180c */
		adbHardware = ADB_HW_PB;
		pm_setup_adb();
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using PowerBook 100-series hardware support\n");
#endif
		break;

	case MACH_MACPB150:		/* PowerBook 150 */
	case MACH_MACPB210:		/* PowerBook Duo 210 */
	case MACH_MACPB230:		/* PowerBook Duo 230 */
	case MACH_MACPB250:		/* PowerBook Duo 250 */
	case MACH_MACPB270:		/* PowerBook Duo 270 */
	case MACH_MACPB280:		/* PowerBook Duo 280 */
	case MACH_MACPB280C:		/* PowerBook Duo 280c */
	case MACH_MACPB500:		/* PowerBook 500 series */
	case MACH_MACPB190:		/* PowerBook 190 */
	case MACH_MACPB190CS:		/* PowerBook 190cs */
		adbHardware = ADB_HW_PB;
		pm_setup_adb();
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using PowerBook Duo-series and PowerBook 500-series hardware support\n");
#endif
		break;

	case MACH_MACC660AV:		/* Centris 660AV */
	case MACH_MACCCLASSIC:		/* Color Classic */
	case MACH_MACCCLASSICII:	/* Color Classic II */
	case MACH_MACLC475:		/* LC 475, Performa 475/476 */
	case MACH_MACLC475_33:		/* Clock-chipped 47x */
	case MACH_MACLC520:		/* LC 520 */
	case MACH_MACLC575:		/* LC 575, Performa 575/577/578 */
	case MACH_MACP550:		/* LC 550, Performa 550 */
	case MACH_MACTV:		/* Macintosh TV */
	case MACH_MACP580:		/* Performa 580/588 */
	case MACH_MACQ605:		/* Quadra 605 */
	case MACH_MACQ605_33:		/* Clock-chipped Quadra 605 */
	case MACH_MACQ630:		/* LC 630, Performa 630, Quadra 630 */
	case MACH_MACQ840AV:		/* Quadra 840AV */
		adbHardware = ADB_HW_CUDA;
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using Cuda series hardware support\n");
#endif
		break;

	default:
		adbHardware = ADB_HW_UNKNOWN;
#ifdef ADB_DEBUG
		if (adb_debug) {
			printf_intr("adb: hardware type unknown for this machine\n");
			printf_intr("adb: ADB support is disabled\n");
		}
#endif
		break;
	}

	/*
	 * Determine whether this machine has ADB based soft power.
	 */
	switch (response) {
	case MACH_MACCCLASSIC:		/* Color Classic */
	case MACH_MACCCLASSICII:	/* Color Classic II */
	case MACH_MACIISI:		/* IIsi */
	case MACH_MACIIVI:		/* IIvi */
	case MACH_MACIIVX:		/* IIvx */
	case MACH_MACLC520:		/* LC 520 */
	case MACH_MACLC575:		/* LC 575, Performa 575/577/578 */
	case MACH_MACP550:		/* LC 550, Performa 550 */
	case MACH_MACTV:		/* Macintosh TV */
	case MACH_MACP580:		/* Performa 580/588 */
	case MACH_MACP600:		/* Performa 600 */
	case MACH_MACQ630:		/* LC 630, Performa 630, Quadra 630 */
	case MACH_MACQ840AV:		/* Quadra 840AV */
		adbSoftPower = 1;
		break;
	}
}
	
int 
count_adbs(void)
{
	int i;
	int found;

	found = 0;

	for (i = 1; i < 16; i++)
		if (0 != ADBDevTable[i].currentAddr)
			found++;

	return found;
}

int 
get_ind_adb_info(ADBDataBlock *info, int index)
{
	if ((index < 1) || (index > 15))	/* check range 1-15 */
		return (-1);

#ifdef ADB_DEBUG
	if (adb_debug & 0x80)
		printf_intr("index 0x%x devType is: 0x%x\n", index,
		    ADBDevTable[index].devType);
#endif
	if (0 == ADBDevTable[index].devType)	/* make sure it's a valid entry */
		return (-1);

	info->devType = (unsigned char)(ADBDevTable[index].devType);
	info->origADBAddr = (unsigned char)(ADBDevTable[index].origAddr);
	info->dbServiceRtPtr = (Ptr)ADBDevTable[index].ServiceRtPtr;
	info->dbDataAreaAddr = (Ptr)ADBDevTable[index].DataAreaAddr;

	return (ADBDevTable[index].currentAddr);
}

int 
get_adb_info(ADBDataBlock *info, int adbAddr)
{
	int i;

	if ((adbAddr < 1) || (adbAddr > 15))	/* check range 1-15 */
		return (-1);

	for (i = 1; i < 15; i++)
		if (ADBDevTable[i].currentAddr == adbAddr) {
			info->devType = (unsigned char)(ADBDevTable[i].devType);
			info->origADBAddr = (unsigned char)(ADBDevTable[i].origAddr);
			info->dbServiceRtPtr = (Ptr)ADBDevTable[i].ServiceRtPtr;
			info->dbDataAreaAddr = ADBDevTable[i].DataAreaAddr;
			return 0;	/* found */
		}

	return (-1);		/* not found */
}

int 
set_adb_info(ADBSetInfoBlock *info, int adbAddr)
{
	int i;

	if ((adbAddr < 1) || (adbAddr > 15))	/* check range 1-15 */
		return (-1);

	for (i = 1; i < 15; i++)
		if (ADBDevTable[i].currentAddr == adbAddr) {
			ADBDevTable[i].ServiceRtPtr =
			    (void *)(info->siServiceRtPtr);
			ADBDevTable[i].DataAreaAddr = info->siDataAreaAddr;
			return 0;	/* found */
		}

	return (-1);		/* not found */

}

/* caller should really use machine-independant version: getPramTime */
/* this version does pseudo-adb access only */
int 
adb_read_date_time(unsigned long *time)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;

	switch (adbHardware) {
	case ADB_HW_II:
		return -1;

	case ADB_HW_IISI:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x03;	/* read date/time */
		result = send_adb_IIsi((u_char *)output, (u_char *)output,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for result */
			;

		*time = (long)(*(long *)(output + 1));
		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_CUDA:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x03;	/* read date/time */
		result = send_adb_cuda((u_char *)output, (u_char *)output,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for result */
			;

		*time = (long)(*(long *)(output + 1));
		return 0;

	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}

/* caller should really use machine-independant version: setPramTime */
/* this version does pseudo-adb access only */
int 
adb_set_date_time(unsigned long time)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;

	switch (adbHardware) {
	case ADB_HW_II:
		return -1;

	case ADB_HW_IISI:
		output[0] = 0x06;	/* 6 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x09;	/* set date/time */
		output[3] = (u_char)(time >> 24);
		output[4] = (u_char)(time >> 16);
		output[5] = (u_char)(time >> 8);
		output[6] = (u_char)(time);
		result = send_adb_IIsi((u_char *)output, (u_char *)0,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_CUDA:
		output[0] = 0x06;	/* 6 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x09;	/* set date/time */
		output[3] = (u_char)(time >> 24);
		output[4] = (u_char)(time >> 16);
		output[5] = (u_char)(time >> 8);
		output[6] = (u_char)(time);
		result = send_adb_cuda((u_char *)output, (u_char *)0,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}


int 
adb_poweroff(void)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;

	if (!adbSoftPower)
		return -1;

	adb_polling = 1;

	switch (adbHardware) {
	case ADB_HW_IISI:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x0a;	/* set date/time */
		result = send_adb_IIsi((u_char *)output, (u_char *)0,
		    (void *)0, (void *)0, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		for (;;);		/* wait for power off */

		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_CUDA:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x0a;	/* set date/time */
		result = send_adb_cuda((u_char *)output, (u_char *)0,
		    (void *)0, (void *)0, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		for (;;);		/* wait for power off */

		return 0;

	case ADB_HW_II:			/* II models don't do ADB soft power */
	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}

int 
adb_prog_switch_enable(void)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;

	switch (adbHardware) {
	case ADB_HW_IISI:
		output[0] = 0x03;	/* 3 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x1c;	/* prog. switch control */
		output[3] = 0x01;	/* enable */
		result = send_adb_IIsi((u_char *)output, (u_char *)0,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_II:		/* II models don't do prog. switch */
	case ADB_HW_CUDA:	/* cuda doesn't do prog. switch TO DO: verify this */
	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}

int 
adb_prog_switch_disable(void)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;

	switch (adbHardware) {
	case ADB_HW_IISI:
		output[0] = 0x03;	/* 3 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x1c;	/* prog. switch control */
		output[3] = 0x01;	/* disable */
		result = send_adb_IIsi((u_char *)output, (u_char *)0,
			(void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_II:		/* II models don't do prog. switch */
	case ADB_HW_CUDA:	/* cuda doesn't do prog. switch */
	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}

int 
CountADBs(void)
{
	return (count_adbs());
}

void 
ADBReInit(void)
{
	adb_reinit();
}

int 
GetIndADB(ADBDataBlock *info, int index)
{
	return (get_ind_adb_info(info, index));
}

int 
GetADBInfo(ADBDataBlock *info, int adbAddr)
{
	return (get_adb_info(info, adbAddr));
}

int 
SetADBInfo(ADBSetInfoBlock *info, int adbAddr)
{
	return (set_adb_info(info, adbAddr));
}

int 
ADBOp(Ptr buffer, Ptr compRout, Ptr data, short commandNum)
{
	return (adb_op(buffer, compRout, data, commandNum));
}
@


1.19
log
@Do not register adb and pm interrupts until the related devices initialize.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.18 2006/01/13 19:36:43 miod Exp $	*/
@


1.18
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.17 2006/01/08 17:45:29 miod Exp $	*/
d1971 1
@


1.17
log
@Drop native MacOS support from the adb direct code, and skip callback
wrappers used to convert between MacOS pascal calling convention and the
C calling convention, unless option MRG_ADB. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.16 2006/01/04 20:39:04 miod Exp $	*/
a257 1
void	pm_intr(void *);
a1689 14
#ifdef MRG_ADB
			__asm __volatile (
			"	movml #0xffff,sp@@- \n"	/* save all regs */
			"	movl %0,a2	\n" 	/* compdata */
			"	movl %1,a1	\n" 	/* comprout */
			"	movl %2,a0 	\n"	/* buffer */
			"	movl %3,d0 	\n"	/* cmd */
			"	jbsr a1@@ 	\n"	/* go call routine */
			"	movml sp@@+,#0xffff"	/* restore all regs */
			    :
			    : "g"(compdata), "g"(comprout),
				"g"(buffer), "g"(cmd)
			    : "d0", "a0", "a1", "a2");
#else
a1691 1
#endif
a2180 1
#ifndef MRG_ADB
a2182 1
#endif
a2496 15
#ifndef MRG_ADB
int
mrg_adbintr(void)
{
	adb_intr(NULL);
	return 1;	/* mimic mrg_adbintr in macrom.h just in case */
}

int
mrg_pmintr(void)
{
	pm_intr(NULL);
	return 1;	/* mimic mrg_pmintr in macrom.h just in case */
}

a2758 2

#endif
@


1.16
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a62 2
#if defined(__NetBSD__) || defined(__OpenBSD__)

a74 11
#else /* !__NetBSD__, i.e. Mac OS */
#include "via.h"				/* for macos based testing */
/* #define ADB_DEBUG */				/* more verbose for testing */

/* Types of ADB hardware that we support */
#define ADB_HW_UNKNOWN		0x0	/* don't know */
#define ADB_HW_II		0x1	/* Mac II series */
#define ADB_HW_IISI		0x2	/* Mac IIsi series */
#define ADB_HW_PB		0x3	/* PowerBook series */
#define ADB_HW_CUDA		0x4	/* Machines with a Cuda chip */
#endif /* __NetBSD__ */
a278 1
void	adb_op_comprout(void);
a288 1
void	adb_comp_exec(void);
a1655 6
#if 0
	s = splhigh();
	printf_intr("sr: %x\n", (s & 0x0700));
	splx(s);
#endif

d1691 1
a1691 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d1693 1
a1693 1
			"	movml #0xffff,sp@@- \n" /* save all regs */
d1704 3
a1706 11
#else					/* for macos based testing */
			asm
			{
				movem.l a0/a1/a2/d0, -(a7)
				move.l compdata, a2
				move.l comprout, a1
				move.l buffer, a0
				move.w cmd, d0
				jsr(a1)
				movem.l(a7)+, d0/a2/a1/a0
			}
a2224 38
}


/*
 * adb_comp_exec
 * This is a general routine that calls the completion routine if there is one.
 * NOTE: This routine is now only used by pm_direct.c
 *       All the code in this file (adb_direct.c) uses 
 *       the adb_pass_up routine now.
 */
void
adb_comp_exec(void)
{
	if ((long)0 != adbCompRout) /* don't call if empty return location */
#if defined(__NetBSD__) || defined(__OpenBSD__)
		__asm __volatile(
		"	movml #0xffff,sp@@- \n" /* save all registers */
		"	movl %0,a2 \n"		/* adbCompData */
		"	movl %1,a1 \n"		/* adbCompRout */
		"	movl %2,a0 \n"		/* adbBuffer */
		"	movl %3,d0 \n"		/* adbWaitingCmd */
		"	jbsr a1@@ \n"		/* go call the routine */
		"	movml sp@@+,#0xffff"	/* restore all registers */
		    :
		    : "g"(adbCompData), "g"(adbCompRout),
			"g"(adbBuffer), "g"(adbWaitingCmd)
		    : "d0", "a0", "a1", "a2");
#else /* for Mac OS-based testing */
		asm {
			movem.l a0/a1/a2/d0, -(a7)
			move.l adbCompData, a2
			move.l adbCompRout, a1
			move.l adbBuffer, a0
			move.w adbWaitingCmd, d0
			jsr(a1)
			movem.l(a7) +, d0/a2/a1/a0
		}
#endif
@


1.15
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 2
a2 2
/*	$OpenBSD: adb_direct.c,v 1.14 2004/11/25 18:32:10 miod Exp $	*/
/*	$NetBSD: adb_direct.c,v 1.5 1997/04/21 18:04:28 scottr Exp $	*/
d4 1
a4 1
/*  From: adb_direct.c 2.02 4/18/97 jpw */
d36 2
a37 1
/* This code is rather messy, but I don't have time right now
d39 23
a61 1
 * But it works, so I'm happy. :-) jpw */
d67 2
d70 1
d75 1
a75 4
#include <machine/adbsys.h>			/* required for adbvar.h */

#include <arch/mac68k/mac68k/macrom.h>
#include "adbvar.h"
d77 1
a77 1
#else
d79 1
a79 9
typedef unsigned char	u_char;
#endif


#ifdef MRG_ADB
int     adb_poweroff(void);
int     adb_read_date_time(unsigned long *t);
int     adb_set_date_time(unsigned long t);
#endif
d81 7
a87 2
/* more verbose for testing */
/*#define DEBUG*/
a96 7
/* types of adb hardware that we (will eventually) support */
#define ADB_HW_UNKNOWN		0x01	/* don't know */
#define ADB_HW_II		0x02	/* Mac II series */
#define ADB_HW_IISI		0x03	/* Mac IIsi series */
#define ADB_HW_PB		0x04	/* PowerBook series */
#define ADB_HW_CUDA		0x05	/* Machines with a Cuda chip */

d98 5
a102 4
#define ADB_ACTION_NOTREADY	0x01	/* has not been initialized yet */
#define ADB_ACTION_IDLE		0x02	/* the bus is currently idle */
#define ADB_ACTION_OUT		0x03	/* sending out a command */
#define ADB_ACTION_IN		0x04	/* receiving data */
d109 7
a115 7
#define ADB_BUS_UNKNOWN		0x01	/* we don't know yet - all models */
#define ADB_BUS_IDLE		0x02	/* bus is idle - all models */
#define ADB_BUS_CMD		0x03	/* starting a command - II models */
#define ADB_BUS_ODD		0x04	/* the "odd" state - II models */
#define ADB_BUS_EVEN		0x05	/* the "even" state - II models */
#define ADB_BUS_ACTIVE		0x06	/* active state - IIsi models */
#define ADB_BUS_ACK		0x07	/* currently ACKing - IIsi models */
d128 1
a128 1
						vBufB) | vPB5) & ~vPB4 )
d161 5
a165 1
#define MAX_ADB_MSG_LENGTH	20
d173 3
a175 3
	char	devType;
	char	origAddr;
	char	currentAddr;
d182 1
a182 1
	u_char	outBuf[MAX_ADB_MSG_LENGTH];	/* our message */
d189 27
d225 1
d228 3
a230 3
u_char	*adbBuffer = (long) 0;	/* pointer to user data area */
void	*adbCompRout = (long) 0;	/* pointer to the completion routine */
void	*adbCompData = (long) 0;	/* pointer to the completion routine data */
d239 2
a240 2
u_char	adbInputBuffer[MAX_ADB_MSG_LENGTH];	/* data input buffer */
u_char	adbOutputBuffer[MAX_ADB_MSG_LENGTH];	/* data output buffer */
d248 1
a248 1
struct ADBDevEntry ADBDevTable[16];	/* our ADB device table */
d251 15
d269 1
d271 1
a271 1
void	pm_intr(void);
d278 1
d280 6
a285 4
void	adb_intr(void);
void	adb_intr_II(void);
void	adb_intr_IIsi(void);
void	adb_intr_cuda(void);
d290 2
a291 1
void	adb_handle_unsol(u_char *);
a299 2
void	adb_handle_unsol(u_char *);
int	adb_op_sync(Ptr, Ptr, Ptr, short);
d301 2
a302 2
void	adb_cleanup(u_char *);
void	adb_cleanup_IIsi(u_char *);
d312 1
d320 1
a320 2
print_single(thestring)
	u_char *thestring;
d324 2
a325 2
	if ((int) (thestring[0]) == 0) {
		printf_intr("nothing returned\n");
d328 2
a329 2
	if (thestring == 0) {
		printf_intr("no data - null pointer\n");
d332 1
a332 1
	if (thestring[0] > 20) {
d334 1
a334 1
		thestring[0] = 20;
d336 3
a338 3
	printf_intr("(length=0x%x):", thestring[0]);
	for (x = 0; x < thestring[0]; x++)
		printf_intr("  0x%02x", thestring[x + 1]);
d341 24
d366 2
d373 2
a374 1
 * TO DO: do we want to add some zshard calls in here?
d376 2
a377 2
void
adb_intr_cuda(void)
d379 3
a381 2
	int i, ending, len;
	unsigned int s;
a386 1

d392 2
a393 1
		/* This is an unexpected packet, so grab the first (dummy)
d395 2
a396 1
		 * starting to receive the packet by setting the TIP bit. */
d398 5
d404 1
a404 5
		ADB_SET_SR_INPUT();
		delay(ADB_DELAY);	/* required delay */
#ifdef DEBUG
		printf_intr("idle 0x%02x ", adbInputBuffer[1]);
#endif
d407 4
a420 4
		/* if the second byte is 0xff, it's a "dummy" packet */
		if (adbInputBuffer[2] == 0xff)
			ending = 1;

d422 6
a427 4
#ifdef DEBUG
			printf_intr("in end 0x%02x ",
			    adbInputBuffer[adbInputBuffer[0]]);
			print_single(adbInputBuffer);
d430 2
a431 1
			/* Are we waiting AND does this packet match what we
d436 5
a440 1
			 * [4], even for RTC/PRAM commands. */
d445 6
d452 1
a452 19
				if (adbBuffer != (long) 0) {
					/* if valid return data pointer */
					/* get return length minus extras */
					len = adbInputBuffer[0] - 4;
					/*
					 * If adb_op is ever made to be called
					 * from a user routine, we should use
					 * a copyout or copyin here to be sure
					 * we're in the correct context
					 */
					for (i = 1; i <= len; i++)
						adbBuffer[i] = adbInputBuffer[4 + i];
					if (len < 0)
						len = 0;
					adbBuffer[0] = len;
				}
				/* call completion routine and clean up */
				adb_comp_exec();
				adbWaitingCmd = 0;
d454 3
a456 3
				adbBuffer = (long) 0;
				adbCompRout = (long) 0;
				adbCompData = (long) 0;
d458 3
a460 14
				/*
				 * This was an unsolicited packet, so
				 * pass the data off to the handler for
				 * this device if we are NOT doing this
				 * during a ADBReInit.
				 * This section IGNORES all data that is not
				 * from the ADB sub-device. That is, not from
				 * RTC or PRAM. Maybe we should fix later,
				 * but do the other devices every send things
				 * without being asked?
				 */
				if (adbStarting == 0)
					if (adbInputBuffer[2] == 0x00)
						adb_handle_unsol(adbInputBuffer);
d463 1
d468 1
a477 3

/* TO DO: don't we need to set up adbWaiting vars here??? */

d485 1
a486 1
					ADB_SET_SR_INPUT();
d497 1
a499 1
				ADB_SET_STATE_TIP();
d503 4
a506 3
#ifdef DEBUG
			printf_intr("in 0x%02x ",
			    adbInputBuffer[adbInputBuffer[0]]);
d513 3
a515 2
#ifdef DEBUG
		printf_intr("intr out 0x%02x ", i);
a516 1
		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
d520 3
a522 2
#ifdef DEBUG
			printf_intr("intr was on ");
d524 1
a525 1
			ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
d541 16
a556 8
			} else {/* no talk, so done */
				adb_comp_exec();	/* call completion
							 * routine */
				adbWaitingCmd = 0;	/* reset "waiting" vars,
							 * just in case */
				adbBuffer = (long) 0;
				adbCompRout = (long) 0;
				adbCompData = (long) 0;
d561 1
d563 3
a565 2
#ifdef DEBUG
			printf_intr("write done ");
d571 3
a573 2
#ifdef DEBUG
			printf_intr("toggle ");
d579 4
a582 1
		printf_intr("adb: not yet initialized\n");
d586 5
a590 1
		printf_intr("intr: unknown ADB state\n");
d597 2
a598 2
	return;
}				/* end adb_intr_IIsi */
d602 1
a602 1
send_adb_cuda(u_char * in, u_char * buffer, void *compRout, void *data, int
d605 1
a605 1
	int i, s, len;
d607 3
a609 2
#ifdef DEBUG
	printf_intr("SEND\n");
d615 2
a616 2
	s = splhigh();		/* don't interrupt while we are messing with
				 * the ADB */
d629 3
a631 2
#ifdef DEBUG
	printf_intr("QUEUE\n");
d633 6
a638 4
	if ((long) in == (long) 0) {	/* need to convert? */
		/* don't need to use adb_cmd_extra here because this section
		 * will be called */
		/* ONLY when it is an ADB command (no RTC or PRAM) */
d648 1
a648 1
		adbOutputBuffer[2] = (u_char) command;	/* load command */
d650 2
a651 3
		for (i = 1; i <= len; i++)	/* copy additional output
						 * data, if any */
			adbOutputBuffer[2 + i] = buffer[i];
d653 2
a654 2
		for (i = 0; i <= (adbOutputBuffer[0] + 1); i++)
			adbOutputBuffer[i] = in[i];
d663 3
a665 2
#ifdef DEBUG
		printf_intr("out start NOW");
d678 1
a678 1
	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked ? */
d682 5
a686 3
			if (ADB_SR_INTR_IS_ON)	/* wait for "interrupt" */
				adb_intr_cuda();	/* go process
							 * "interrupt" */
d692 2
a693 3
/* TO DO: add one or two zshard calls in here */
void
adb_intr_II(void)
d695 3
a697 2
	int i, len, intr_on = 0;
	int send = 0, do_srq = 0;
d707 4
a710 2
/*if (ADB_INTR_IS_ON)*/
/*	printf_intr("INTR ON ");*/
d713 16
d730 30
a759 1
	switch (adbActionState) {
a761 2
			/* printf_intr("FAKE DROPPED \n"); */
			/* printf_intr(" XX "); */
d763 3
a767 2
		adbNextEnd = 0;
		/* printf_intr("idle "); */
d770 4
a773 1
		/* printf_intr("0x%02x ", adbInputBuffer[1]); */
d782 5
a786 2
		/* printf_intr("in 0x%02x ",
		 * adbInputBuffer[adbInputBuffer[0]]); */
d789 57
a845 26
		/*
		 * Check for an unsolicited Service Request (SRQ).
		 * An empty SRQ packet NEVER ends, so we must manually
		 * check for the following condition.
		 */
		if (adbInputBuffer[0] == 4 && adbInputBuffer[2] == 0xff &&
		    adbInputBuffer[3] == 0xff && adbInputBuffer[4] == 0xff &&
		    intr_on && !adbNextEnd)
			do_srq = 1;

		if (adbNextEnd == 1) {	/* process last byte of packet */
			adbNextEnd = 0;
			/* printf_intr("done: "); */

			/* If the following conditions are true (4 byte
			 * message, last 3 bytes are 0xff) then we basically
			 * got a "no response" from the ADB chip, so change
			 * the message to an empty one. We also clear intr_on
			 * to stop the SRQ send later on because these packets
			 * normally have the SRQ bit set even when there is
			 * NOT a pending SRQ. */
			if (adbInputBuffer[0] == 4 && adbInputBuffer[2] == 0xff &&
			    adbInputBuffer[3] == 0xff && adbInputBuffer[4] == 0xff) {
				/* printf_intr("NO RESP "); */
				intr_on = 0;
				adbInputBuffer[0] = 0;
a846 1
			adbLastDevice = (adbInputBuffer[1] & 0xf0) >> 4;
a847 29
			if ((!adbWaiting || adbPolling)
			    && (adbInputBuffer[0] != 0)) {
				/* unsolicided - ignore if starting */
				if (!adbStarting)
					adb_handle_unsol(adbInputBuffer);
			} else
				if (!adbPolling) {	/* someone asked for it */
					/* printf_intr("SOL: "); */
					/* print_single(adbInputBuffer); */
					if (adbBuffer != (long) 0) {	/* if valid return data
									 * pointer */
						/* get return length minus
						 * extras */
						len = adbInputBuffer[0] - 1;

						/* if adb_op is ever made to
						 * be called from a user
						 * routine, we should use a
						 * copyout or copyin here to
						 * be sure we're in the
						 * correct context. */
						for (i = 1; i <= len; i++)
							adbBuffer[i] = adbInputBuffer[i + 1];
						if (len < 0)
							len = 0;
						adbBuffer[0] = len;
					}
					adb_comp_exec();
				}
a848 1
			adbPolling = 0;
d850 3
a852 3
			adbBuffer = (long) 0;
			adbCompRout = (long) 0;
			adbCompData = (long) 0;
d858 4
a861 1
				/* printf_intr("XXX: DOING OUT QUEUE\n"); */
d863 2
a864 2
				for (i = 0; i <= (adbOutQueue.outBuf[0] + 1); i++)
					adbOutputBuffer[i] = adbOutQueue.outBuf[i];
a869 1
				adbPolling = 0;
d871 16
a886 37
				/* if intr_on is true, then it's a SRQ so poll
				 * other devices. */
			} else
				if (intr_on) {
					/* printf_intr("starting POLL "); */
					do_srq = 1;
					adbPolling = 1;
				} else
					if ((adbInputBuffer[1] & 0x0f) != 0x0c) {
						/* printf_intr("xC HACK "); */
						adbPolling = 1;
						send = 1;
						adbOutputBuffer[0] = 1;
						adbOutputBuffer[1] = (adbInputBuffer[1] & 0xf0) | 0x0c;
					} else {
						/* printf_intr("ending "); */
						adbBusState = ADB_BUS_IDLE;
						adbActionState = ADB_ACTION_IDLE;
						ADB_SET_STATE_IDLE_II();
						break;
					}
		}
		/*
		 * If do_srq is true then something above determined that
		 * the message has ended and some device is sending a
		 * service request. So we need to determine the next device
		 * and send a poll to it. (If the device we send to isn't the
		 * one that sent the SRQ, that ok as it will be caught
		 * the next time though.)
		 */
		if (do_srq) {
			/* printf_intr("SRQ! "); */
			adbPolling = 1;
			adb_guess_next_device();
			adbOutputBuffer[0] = 1;
			adbOutputBuffer[1] = ((adbLastDevice & 0x0f) << 4) | 0x0c;
			send = 1;
d888 1
a895 1
			adbNextEnd = 0;
a905 3
		if (!intr_on)	/* if adb intr. on then the */
			adbNextEnd = 1;	/* NEXT byte is the last */

a922 3
		adbNextEnd = 0;
		if (!adbPolling)
			adbWaiting = 1;	/* not unsolicited */
d936 6
a941 1
			/* printf_intr("talk out 0x%02x ", i); */
d944 2
a945 1
		/* If it's not a TALK, check whether all data has been sent.
d947 6
a952 2
		 * advance to the next state. */
		/* printf_intr("non-talk out 0x%0x ", i); */
d955 18
a972 5
			/* printf_intr("done \n"); */
			adb_comp_exec();
			adbBuffer = (long) 0;
			adbCompRout = (long) 0;
			adbCompData = (long) 0;
d975 2
a976 2
				for (i = 0; i <= (adbOutQueue.outBuf[0] + 1); i++)
					adbOutputBuffer[i] = adbOutQueue.outBuf[i];
d982 8
a989 1
				adbPolling = 0;
d991 1
d993 10
a1002 2
				adbOutputBuffer[1] = (adbOutputBuffer[1] & 0xf0) | 0x0c;
				adbPolling = 1;	/* non-user poll */
a1003 9
			adbNextEnd = 0;
			adbSentChars = 0;	/* nothing sent yet */
			adbActionState = ADB_ACTION_OUT;	/* set next state */
			ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
			ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
			adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
			ADB_SET_STATE_CMD();	/* tell ADB that we want to
						 * send */
			break;
d1019 6
a1024 1
			printf_intr("strange state!!! (0x%x)\n", adbBusState);
d1030 5
a1034 1
		printf_intr("adb: unknown ADB state (during intr)\n");
d1041 1
a1041 1
	return;
d1050 1
a1050 1
send_adb_II(u_char * in, u_char * buffer, void *compRout, void *data, int command)
d1052 1
a1052 1
	int i, s, len;
d1058 2
a1059 2
	s = splhigh();		/* don't interrupt while we are messing with
				 * the ADB */
d1065 1
a1065 1
	if ((long) in == (long) 0) {	/* need to convert? */
d1078 1
a1078 1
		adbOutQueue.outBuf[1] = (u_char) command;	/* load command */
d1080 2
a1081 3
		for (i = 1; i <= len; i++)	/* copy additional output
						 * data, if any */
			adbOutQueue.outBuf[1 + i] = buffer[i];
d1084 1
a1084 2
		for (i = 0; i <= (adbOutQueue.outBuf[0] + 1); i++)
			adbOutQueue.outBuf[i] = in[i];
d1093 1
a1093 2
	    (ADB_INTR_IS_OFF) &&/* and no incoming interrupts? */
	    (adbPolling == 0)) {/* and we are not currently polling */
d1095 2
a1096 2
		for (i = 0; i <= (adbOutQueue.outBuf[0] + 1); i++)	/* copy over data */
			adbOutputBuffer[i] = adbOutQueue.outBuf[i];
d1119 1
a1119 1
	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked ? */
d1122 6
a1127 3
		    || (adbWaiting == 1) || (adbPolling == 1))
			if (ADB_SR_INTR_IS_ON)	/* wait for "interrupt" */
				adb_intr_II();	/* go process "interrupt" */
d1143 4
a1146 2
		/* start polling EVERY device, since we can't be sure there is
		 * anything in the device table yet */
d1170 1
a1170 1
				dummy = 2;
d1181 2
d1188 2
a1189 2
void
adb_intr(void)
d1192 2
a1193 2
		case ADB_HW_II:
		adb_intr_II();
d1197 1
a1197 1
		adb_intr_IIsi();
d1200 1
a1200 1
	case ADB_HW_PB:
d1204 1
a1204 1
		adb_intr_cuda();
d1210 2
d1221 2
a1222 2
void
adb_intr_IIsi(void)
d1224 2
a1225 1
	int i, ending, len;
d1250 1
a1250 1
		(void)intr_dispatch(0x70);
d1264 1
a1264 1
		(void)intr_dispatch(0x70);
d1268 9
a1276 5
			/* this section _should_ handle all ADB and RTC/PRAM
			 * type commands, */
			/* but there may be more... */
			/* note: commands are always at [4], even for rtc/pram
			 * commands */
d1284 6
a1289 17
				/* is this data we are waiting for? */
				if (adbBuffer != (long) 0) {	/* if valid return data
								 * pointer */
					/* get return length minus extras */
					len = adbInputBuffer[0] - 4;
					/* if adb_op is ever made to be called
					 * from a user routine, we should use
					 * a copyout or copyin here to be sure
					 * we're in the correct context */
					for (i = 1; i <= len; i++)
						adbBuffer[i] = adbInputBuffer[4 + i];
					if (len < 0)
						len = 0;
					adbBuffer[0] = len;
				}
				adb_comp_exec();	/* call completion
							 * routine */
d1293 3
a1295 3
				adbBuffer = (long) 0;
				adbCompRout = (long) 0;
				adbCompData = (long) 0;
d1297 3
a1299 10
				/* pass the data off to the handler */
				/* This section IGNORES all data that is not
				 * from the ADB sub-device. That is, not from
				 * rtc or pram. Maybe we should fix later,
				 * but do the other devices every send things
				 * without being asked? */
				if (adbStarting == 0)	/* ignore if during
							 * adbreinit */
					if (adbInputBuffer[2] == 0x00)
						adb_handle_unsol(adbInputBuffer);
d1311 1
a1311 1
				(void)intr_dispatch(0x70);
d1352 1
a1352 1
			(void)intr_dispatch(0x70);
d1358 1
a1358 1
		(void)intr_dispatch(0x70);
d1366 16
a1381 7
				adb_comp_exec();	/* call completion
							 * routine */
				adbWaitingCmd = 0;	/* reset "waiting" vars,
							 * just in case */
				adbBuffer = (long) 0;
				adbCompRout = (long) 0;
				adbCompData = (long) 0;
d1395 4
a1398 1
		printf_intr("adb: not yet initialized\n");
d1402 5
a1406 1
		printf_intr("intr: unknown ADB state\n");
d1413 1
a1413 1
	return;
d1421 3
a1423 3
 * in: if (in==0) then the command string is built from command and buffer
 *     if (in!=0) then in is used as the command string
 * buffer: additional data to be sent (used only if in==0)
d1428 1
a1428 1
 * command: an ADB command to be sent (used only if in==0)
d1432 1
a1432 1
send_adb_IIsi(u_char * in, u_char * buffer, void *compRout, void *data, int
d1435 1
a1435 1
	int i, s, len;
d1440 2
a1441 2
	s = splhigh();		/* don't interrupt while we are messing with
				 * the ADB */
d1455 6
a1460 4
	if ((long) in == (long) 0) {	/* need to convert? */
		/* don't need to use adb_cmd_extra here because this section
		 * will be called */
		/* ONLY when it is an ADB command (no RTC or PRAM) */
d1470 1
a1470 1
		adbOutputBuffer[2] = (u_char) command;	/* load command */
d1472 2
a1473 3
		for (i = 1; i <= len; i++)	/* copy additional output
						 * data, if any */
			adbOutputBuffer[2 + i] = buffer[i];
d1475 2
a1476 2
		for (i = 0; i <= (adbOutputBuffer[0] + 1); i++)
			adbOutputBuffer[i] = in[i];
d1500 1
a1500 1
	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked ? */
d1504 5
a1508 3
			if (ADB_SR_INTR_IS_ON)	/* wait for "interrupt" */
				adb_intr_IIsi();	/* go process
							 * "interrupt" */
d1510 1
a1510 1
	return 0;
d1513 21
a1533 41

/*
 * adb_comp_exec
 * This is a general routine that calls the completion routine if there is one.
 */
void
adb_comp_exec(void)
{
	if ((long) 0 != adbCompRout)	/* don't call if empty return location */
#if defined(__NetBSD__) || defined(__OpenBSD__)
		asm("
		    movml #0xffff, sp@@-		| save all registers
		    movl %0, a2 		| adbCompData
		    movl %1, a1 		| adbCompRout
		    movl %2, a0 		| adbBuffer
		    movl %3, d0 		| adbWaitingCmd
		    jbsr a1@@ 			| go call the routine
		    movml sp@@+, #0xffff		| restore all registers"
		    :
		    :"g"(adbCompData), "g"(adbCompRout),
		     "g"(adbBuffer), "g"(adbWaitingCmd)
		    :"d0", "a0", "a1", "a2");
#else					/* for macos based testing */
		asm {
			movem.l a0/a1/a2/d0, -(a7)
			move.l adbCompData, a2
			move.l adbCompRout, a1
			move.l adbBuffer, a0
			move.w adbWaitingCmd, d0
			jsr(a1)
			movem.l(a7) +, d0/a2/a1/a0
		}
#endif
}


/*
 * This routine handles what needs to be done after an unsolicited
 * message is read from the ADB device.  'in' points to the raw
 * data received from the device, including device number
 * (on IIsi) and result code.
d1535 1
a1535 4
 * Note that the service (completion) routine for an unsolicited
 * message is whatever is set in the ADB device table. This is
 * different than for a device responding to a specific request,
 * where the completion routine is defined by the caller.
d1538 1
a1538 1
adb_handle_unsol(u_char * in)
d1540 1
a1540 3
	int i, cmd = 0;
	u_char data[MAX_ADB_MSG_LENGTH];
	u_char *buffer = 0;
d1543 27
a1569 4
	/* make local copy so we don't destroy the real one - it may be needed
	 * later. */
	for (i = 0; i <= (in[0] + 1); i++)
		data[i] = in[i];
d1571 13
a1583 8
	switch (adbHardware) {
	case ADB_HW_II:
		/* adjust the "length" byte */
		cmd = data[1];
		if (data[0] < 2)
			data[1] = 0;
		else
			data[1] = data[0] - 1;
d1585 8
a1592 2
		buffer = (data + 1);
		break;
d1594 1
a1594 4
	case ADB_HW_IISI:
	case ADB_HW_CUDA:
		/* only handles ADB for now */
		if (0 != *(data + 2))
d1596 59
a1655 6
		/* adjust the "length" byte */
		cmd = data[4];
		if (data[0] < 5)
			data[4] = 0;
		else
			data[4] = data[0] - 4;
d1657 13
a1669 2
		buffer = (data + 4);
		break;
d1671 5
a1675 2
	case ADB_HW_PB:
		return;		/* how does PM handle "unsolicited" messages? */
d1677 1
a1677 3
	case ADB_HW_UNKNOWN:
		return;
	}
d1679 30
a1708 2
	if (-1 == get_adb_info(&block, ((cmd & 0xf0) >> 4)))
		return;
d1710 2
a1711 5
	/* call default completion routine if it's valid */
	/* TO DO: This section of code is somewhat redundant with
	 * adb_comp_exec (above). Some day we may want to generalize it and
	 * make it a single function. */
	if ((long) 0 != (long) block.dbServiceRtPtr) {
d1713 12
a1724 12
		asm("
		    movml #0xffff, sp@@-		| save all registers
		    movl %0, a2 		| block.dbDataAreaAddr
		    movl %1, a1 		| block.dbServiceRtPtr
		    movl %2, a0 		| buffer
		    movl %3, d0 		| cmd
		    jbsr a1@@ 			| go call the routine
		    movml sp@@+, #0xffff		| restore all registers"
		    :
		    : "g"(block.dbDataAreaAddr),
		      "g"(block.dbServiceRtPtr), "g"(buffer), "g"(cmd)
		    : "d0", "a0", "a1", "a2");
d1726 11
a1736 9
		asm
		{
			movem.l a0/a1/a2/d0, -(a7)
			move.l block.dbDataAreaAddr, a2
			move.l block.dbServiceRtPtr, a1
			move.l buffer, a0
			move.w cmd, d0
			jsr(a1)
			movem.l(a7) +, d0/a2/a1/a0
d1738 7
a1744 1
#endif
d1751 2
a1752 2
 * This is my version of the ADBOp routine. It mainly just calls the hardware-specific
 * routine.
d1760 2
a1761 2
 *   result     : 0 = success
 *              : -1 = could not complete
d1770 2
a1771 3
		result = send_adb_II((u_char *) 0,
		    (u_char *) buffer, (void *) compRout,
		    (void *) data, (int) command);
d1779 2
a1780 3
		result = send_adb_IIsi((u_char *) 0,
		    (u_char *) buffer, (void *) compRout,
		    (void *) data, (int) command);
d1805 2
a1806 3
		result = send_adb_cuda((u_char *) 0,
		    (u_char *) buffer, (void *) compRout,
		    (void *) data, (int) command);
d1821 3
a1823 2
 * adb_cleanup
 * This routine simply calls the appropriate version of the adb_cleanup routine.
d1826 1
a1826 1
adb_cleanup(u_char * in)
d1829 1
d1833 15
d1852 14
d1867 13
a1879 1
		adb_cleanup_IIsi(in);
d1884 1
a1884 1
		 * XXX -  really PM_VIA_CLR_INTR - should we put it in
d1887 1
a1887 1
		via_reg(VIA1, vIFR) = 0x90;	/* clear interrupt */
d1891 16
d1923 3
d1927 1
d1933 1
a1933 1
 * adb_cleanup_IIsi
d1940 1
a1940 1
adb_cleanup_IIsi(u_char * buffer)
d1962 5
a1966 3
			/* poll for ADB interrupt and watch for timeout */
			/* if time out, keep going in hopes of not hanging the
			 * ADB chip - I think */
d1973 4
a1976 2
			/* perhaps put in a check here that ignores all data
			 * after the first MAX_ADB_MSG_LENGTH bytes ??? */
d1995 1
a1995 1
}				/* adb_cleanup_IIsi */
d2006 2
a2007 2
	u_char send_string[MAX_ADB_MSG_LENGTH];
	int s = 0;
d2009 1
d2015 2
a2016 1
	ADBDataBlock data;	/* temp. holder for getting device info */
d2019 2
a2020 1
	if (adbHardware != ADB_HW_PB)	/* ints must be on for PB? */
d2022 2
d2030 5
a2034 3
	/* Initialize the ADB table.  For now, we'll always use the same table
	 * that is defined at the beginning of this file - no mallocs. */
	for (i = 0; i < 16; i++)
d2036 2
d2039 1
a2039 33
	adb_setup_hw_type();	/* setup hardware type */

	/* Set up all the VIA bits we need to do the ADB stuff. */
	switch (adbHardware) {
	case ADB_HW_II:
		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN (II, IIsi) */
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware (II, IIsi) */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on (II, IIsi) */
		ADB_SET_STATE_IDLE_II();	/* set ADB bus state to idle */
		break;

	case ADB_HW_IISI:
		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN (II, IIsi) */
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware (II, IIsi) */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on (II, IIsi) */
		ADB_SET_STATE_IDLE_IISI();	/* set ADB bus state to idle */
		break;
d2041 1
a2041 2
	case ADB_HW_PB:
		break;		/* there has to be more than this? */
d2043 3
a2045 23
	case ADB_HW_CUDA:
		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN */
		via_reg(VIA1, vACR) = (via_reg(VIA1, vACR) | 0x0c) & ~0x10;
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on */
		ADB_SET_STATE_IDLE_CUDA();	/* set ADB bus state to idle */
		break;

	case ADB_HW_UNKNOWN:	/* if type unknown then skip out */
	default:
		via_reg(VIA1, vIER) = 0x04;	/* turn interrupts off - TO
						 * DO: turn PB ints off? */
		splx(s);
		return;
	}
d2048 1
a2048 18
	 * Clear out any "leftover" commands.  Remember that up until this
	 * point, the interrupt routine will be either off or it should be
	 * able to ignore inputs until the device table is built.
	 */
	for (i = 0; i < 30; i++) {
		delay(ADB_DELAY);
		adb_cleanup(send_string);
		printf_intr("adb: cleanup: ");
		print_single(send_string);
		delay(ADB_DELAY);
		if (ADB_INTR_IS_OFF)
			break;
	}

	/* send an ADB reset first */
	adb_op_sync((Ptr) 0, (Ptr) 0, (Ptr) 0, (short) 0x00);

	/* Probe for ADB devices. Probe devices 1-15 quickly to determine
d2056 4
a2059 4
	 * When finished, do this entire process over again with the updated list
	 * of in use addresses. Do this until no new devices have been found
	 * in 20 passes though the in use address list. (This probably seems
	 * long and complicated, but it's the best way to detect multiple
d2061 2
a2062 1
	 * before the collision is detected.) */
d2066 10
a2075 4
		command = (int) (0x0f | ((int) (i & 0x000f) << 4));	/* talk R3 */
		result = adb_op_sync((Ptr) send_string, (Ptr) 0, (Ptr) 0, (short) command);
		if (0x00 != send_string[0]) {	/* anything come back ?? */
			ADBDevTable[++ADBNumDevices].devType = (u_char) send_string[2];
d2078 3
a2080 4
			ADBDevTable[ADBNumDevices].DataAreaAddr = (long) 0;
			ADBDevTable[ADBNumDevices].ServiceRtPtr = (void *) 0;
			/* printf_intr("initial device found (at index %i)\n",
			 * ADBNumDevices); */
d2091 6
a2096 5
	if (saveptr == 0)	/* no free addresses??? */
		saveptr = 15;

	/* printf_intr("first free is: 0x%02x\n", saveptr); */
	/* printf_intr("devices: %i\n", ADBNumDevices); */
d2099 2
a2100 2
	while (nonewtimes++ < 11) {
		for (i = 1; i <= ADBNumDevices; i++) {
d2102 5
a2106 2
			/* printf_intr("moving device 0x%02x to 0x%02x (index
			 * 0x%02x)  ", device, saveptr, i); */
d2109 3
a2111 2
			command = (int) (0x0f | ((int) (device & 0x000f) << 4));
			adb_op_sync((Ptr) send_string, (Ptr) 0, (Ptr) 0, (short) command);
d2114 1
a2114 1
			command = (int) (0x0b | ((int) (device & 0x000f) << 4));
d2116 1
a2116 1
			send_string[1] = (u_char) (saveptr | 0x60);
d2118 30
a2147 1
			adb_op_sync((Ptr) send_string, (Ptr) 0, (Ptr) 0, (short) command);
d2150 5
a2154 3
			command = (int) (0x0f | ((int) (device & 0x000f) << 4));
			result = adb_op_sync((Ptr) send_string, (Ptr) 0, (Ptr) 0, (short) command);
			if (send_string[0] != 0) {
d2158 4
a2161 1
				/* printf_intr("old device at index %i\n",i); */
d2163 10
a2172 2
				/* printf_intr("new device found\n"); */
				ADBDevTable[++ADBNumDevices].devType = (u_char) send_string[2];
d2177 4
a2180 2
				ADBDevTable[ADBNumDevices].DataAreaAddr = (long) 0;
				ADBDevTable[ADBNumDevices].ServiceRtPtr = (void *) 0;
d2182 1
a2182 1
				for (x = saveptr; x > 0; x--)
d2187 8
a2194 2
				/* printf_intr("new free is 0x%02x\n",
				 * saveptr); */
d2199 4
a2202 1
				/* printf_intr("moving back...\n"); */
d2204 1
a2204 1
				command = (int) (0x0b | ((int) (saveptr & 0x000f) << 4));
d2206 1
a2206 1
				send_string[1] = (u_char) (device | 0x60);
d2208 3
a2210 1
				adb_op_sync((Ptr) send_string, (Ptr) 0, (Ptr) 0, (short) command);
d2215 8
a2222 6
#ifdef DEBUG
	for (i = 1; i <= ADBNumDevices; i++) {
		x = get_ind_adb_info(&data, i);
		if (x != -1)
			printf_intr("index 0x%x, addr 0x%x, type 0x%x\n", i, x, data.devType);

d2226 4
a2229 2
	adb_prog_switch_enable();	/* enable the programmer's switch, if
					 * we have one */
d2231 6
a2236 2
	if (0 == ADBNumDevices)	/* tell user if no devices found */
		printf_intr("adb: no devices found\n");
d2239 9
a2247 1
	printf_intr("adb: ADBReInit complete\n");
d2249 2
a2250 1
	if (adbHardware != ADB_HW_PB)	/* ints must be on for PB? */
d2252 1
d2257 44
a2300 3
/* adb_cmd_result
 * This routine lets the caller know whether the specified adb command string should
 * expect a returned result, such as a TALK command.
d2305 1
a2305 1
adb_cmd_result(u_char * in)
d2308 1
a2308 1
		case ADB_HW_II:
d2312 1
a2312 3
		else
			return 1;
		break;
d2316 1
a2316 1
		/* was is an ADB talk command? */
d2319 4
a2322 7
		/* was is an RTC/PRAM read date/time? */
		else
			if ((in[1] == 0x01) && (in[2] == 0x03))
				return 0;
			else
				return 1;
		break;
a2325 1
		break;
d2334 6
a2339 3
/* adb_cmd_extra
 * This routine lets the caller know whether the specified adb command string may have
 * extra data appended to the end of it, such as a LISTEN command.
d2344 1
a2344 1
adb_cmd_extra(u_char * in)
d2347 1
a2347 1
		case ADB_HW_II:
d2350 1
a2350 3
		else
			return 1;
		break;
d2354 4
a2357 2
		/* TO DO: support needs to be added to recognize RTC and PRAM
		 * commands */
d2360 2
a2361 3
		else		/* add others later */
			return 1;
		break;
a2364 1
		break;
a2372 35
/* adb_op_sync
 * This routine does exactly what the adb_op routine does, except that after the
 * adb_op is called, it waits until the return value is present before returning
 */
int
adb_op_sync(Ptr buffer, Ptr compRout, Ptr data, short command)
{
	int result;
	volatile int flag = 0;

	result = adb_op(buffer, (void *) adb_op_comprout,
	    (void *) &flag, command);	/* send command */
	if (result == 0) {	/* send ok? */
		while (0 == flag);	/* wait for compl. routine */
		return 0;
	} else
		return result;
}


/* adb_op_comprout
 * This function is used by the adb_op_sync routine so it knows when the function is
 * done.
 */
void 
adb_op_comprout(void)
{
#if defined(__NetBSD__) || defined(__OpenBSD__)
	asm("movw	#1,a2@@			| update flag value");
#else				/* for macos based testing */
	asm {
		move.w #1,(a2) }		/* update flag value */
#endif
}

d2380 3
d2384 11
a2394 11
	case 6:		/* II */
	case 7:		/* IIx */
	case 8:		/* IIcx */
	case 9:		/* SE/30 */
	case 11:	/* IIci */
	case 22:	/* Quadra 700 */
	case 30:	/* Centris 650 */
	case 35:	/* Quadra 800 */
	case 36:	/* Quadra 650 */
	case 52:	/* Centris 610 */
	case 53:	/* Quadra 610 */
d2396 4
a2399 1
		printf_intr("adb: using II series hardware support\n");
d2401 9
a2409 12
	case 18:	/* IIsi */
	case 20:	/* Quadra 900 - not sure if IIsi or not */
	case 23:	/* Classic II */
	case 26:	/* Quadra 950 - not sure if IIsi or not */
	case 27:	/* LC III, Performa 450 */
	case 37:	/* LC II, Performa 400/405/430 */
	case 44:	/* IIvi */
	case 45:	/* Performa 600 */
	case 48:	/* IIvx */
	case 49:	/* Color Classic - not sure if IIsi or not */
	case 62:	/* Performa 460/465/467 */
	case 83:	/* Color Classic II - not sure if IIsi or not */
d2411 4
a2414 1
		printf_intr("adb: using IIsi series hardware support\n");
d2416 9
a2424 9
	case 21:	/* PowerBook 170 */
	case 25:	/* PowerBook 140 */
	case 54:	/* PowerBook 145 */
	case 34:	/* PowerBook 160 */
	case 84:	/* PowerBook 165 */
	case 50:	/* PowerBook 165c */
	case 33:	/* PowerBook 180 */
	case 71:	/* PowerBook 180c */
	case 115:	/* PowerBook 150 */
d2427 4
a2430 1
		printf_intr("adb: using PowerBook 100-series hardware support\n");
d2432 11
a2442 7
	case 29:	/* PowerBook Duo 210 */
	case 32:	/* PowerBook Duo 230 */
	case 38:	/* PowerBook Duo 250 */
	case 72:	/* PowerBook 500 series */
	case 77:	/* PowerBook Duo 270 */
	case 102:	/* PowerBook Duo 280 */
	case 103:	/* PowerBook Duo 280c */
d2445 4
a2448 1
		printf_intr("adb: using PowerBook Duo-series and PowerBook 500-series hardware support\n");
d2450 15
a2464 8
	case 56:	/* LC 520 */
	case 60:	/* Centris 660AV */
	case 78:	/* Quadra 840AV */
	case 80:	/* LC 550, Performa 550 */
	case 89:	/* LC 475, Performa 475/476 */
	case 92:	/* LC 575, Performa 575/577/578 */
	case 94:	/* Quadra 605 */
	case 98:	/* LC 630, Performa 630, Quadra 630 */
d2466 4
a2469 1
		printf_intr("adb: using Cuda series hardware support\n");
d2471 1
d2474 27
a2500 2
		printf_intr("adb: hardware type unknown for this machine\n");
		printf_intr("adb: ADB support is disabled\n");
d2514 1
a2514 1
		if (0 != ADBDevTable[i].devType)
d2521 1
a2521 1
get_ind_adb_info(ADBDataBlock * info, int index)
d2526 5
a2530 2
	/* printf_intr("index 0x%x devType is: 0x%x\n", index,
	    ADBDevTable[index].devType); */
d2534 4
a2537 4
	info->devType = ADBDevTable[index].devType;
	info->origADBAddr = ADBDevTable[index].origAddr;
	info->dbServiceRtPtr = (Ptr) ADBDevTable[index].ServiceRtPtr;
	info->dbDataAreaAddr = (Ptr) ADBDevTable[index].DataAreaAddr;
d2543 1
a2543 1
get_adb_info(ADBDataBlock * info, int adbAddr)
d2552 2
a2553 2
			info->devType = ADBDevTable[i].devType;
			info->origADBAddr = ADBDevTable[i].origAddr;
d2563 1
a2563 1
set_adb_info(ADBSetInfoBlock * info, int adbAddr)
d2586 1
a2586 1
	adb_intr();
d2591 1
a2591 1
mrg_pmintr(void)	/* we don't do this yet */
d2593 1
a2593 1
	pm_intr();
a2595 1
#endif
d2597 1
a2597 1
/* caller should really use machine-independent version: getPramTime */
d2602 1
a2602 1
	u_char output[MAX_ADB_MSG_LENGTH];
d2614 2
a2615 3
		result = send_adb_IIsi((u_char *) output,
		    (u_char *) output, (void *) adb_op_comprout,
		    (int *) &flag, (int) 0);
d2622 1
a2622 1
		*time = (long) (*(long *) (output + 1));
d2632 2
a2633 3
		result = send_adb_cuda((u_char *) output,
		    (u_char *) output, (void *) adb_op_comprout,
		    (void *) &flag, (int) 0);
d2640 1
a2640 1
		*time = (long) (*(long *) (output + 1));
d2649 1
a2649 1
/* caller should really use machine-independent version: setPramTime */
d2654 1
a2654 1
	u_char output[MAX_ADB_MSG_LENGTH];
d2666 6
a2671 7
		output[3] = (u_char) (time >> 24);
		output[4] = (u_char) (time >> 16);
		output[5] = (u_char) (time >> 8);
		output[6] = (u_char) (time);
		result = send_adb_IIsi((u_char *) output,
		    (u_char *) 0, (void *) adb_op_comprout,
		    (void *) &flag, (int) 0);
d2687 6
a2692 7
		output[3] = (u_char) (time >> 24);
		output[4] = (u_char) (time >> 16);
		output[5] = (u_char) (time >> 8);
		output[6] = (u_char) (time);
		result = send_adb_cuda((u_char *) output,
		    (u_char *) 0, (void *) adb_op_comprout,
		    (void *) &flag, (int) 0);
d2711 1
a2711 1
	u_char output[MAX_ADB_MSG_LENGTH];
d2714 5
d2724 2
a2725 2
		result = send_adb_IIsi((u_char *) output,
		    (u_char *) 0, (void *) 0, (void *) 0, (int) 0);
d2736 14
a2749 3
	/* TO DO: some cuda models claim to do soft power - check out */
	case ADB_HW_II:			/* II models don't do soft power */
	case ADB_HW_CUDA:		/* cuda doesn't do soft power */
d2759 1
a2759 1
	u_char output[MAX_ADB_MSG_LENGTH];
d2769 2
a2770 3
		result = send_adb_IIsi((u_char *) output,
		    (u_char *) 0, (void *) adb_op_comprout,
		    (void *) &flag, (int) 0);
d2793 1
a2793 1
	u_char output[MAX_ADB_MSG_LENGTH];
d2803 2
a2804 3
		result = send_adb_IIsi((u_char *) output,
		    (u_char *) 0, (void *) adb_op_comprout,
		    (void *) &flag, (int) 0);
a2823 2
#ifndef MRG_ADB

d2837 1
a2837 1
GetIndADB(ADBDataBlock * info, int index)
d2843 1
a2843 1
GetADBInfo(ADBDataBlock * info, int adbAddr)
d2849 1
a2849 1
SetADBInfo(ADBSetInfoBlock * info, int adbAddr)
a2860 1

@


1.14
log
@Move towards a more flexible and generic interrupt system, as well as better
zs behaviour.

From NetBSD; integration work by Martin Reindl
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.13 2003/11/03 06:43:02 david Exp $	*/
d2155 1
a2155 1
long
d2162 1
a2162 1
long
@


1.13
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.12 2003/03/14 10:47:36 miod Exp $	*/
a206 2
int	zshard(int);

d1074 1
a1074 1
		zshard(0);	/* grab any serial interrupts */
d1088 1
a1088 1
		zshard(0);	/* grab any serial interrupts */
d1149 1
a1149 1
				zshard(0);	/* grab any serial interrupts */
d1190 1
a1190 1
			zshard(0);		/* grab any serial interrupts */
d1196 1
a1196 1
		zshard(0);	/* grab any serial interrupts */
@


1.12
log
@spl police.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.11 2002/03/14 01:26:35 millert Exp $	*/
d2172 1
a2172 1
/* caller should really use machine-independant version: getPramTime */
d2226 1
a2226 1
/* caller should really use machine-independant version: setPramTime */
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.10 1998/05/03 07:12:51 gene Exp $	*/
a1668 2
	(void)(&s);		/* work around lame GCC bug */

d1740 1
a1741 1
		break;
@


1.10
log
@Associated fallout from removing macinfo.h and merging to cpu.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.9 1998/04/22 19:59:49 deraadt Exp $	*/
d61 3
a63 3
int     adb_poweroff __P((void));
int     adb_read_date_time __P((unsigned long *t));
int     adb_set_date_time __P((unsigned long t));
d153 1
a153 1
	void	(*ServiceRtPtr) __P((void));
d207 1
a207 1
int	zshard __P((int));
d209 5
a213 5
void	pm_setup_adb __P((void));
void	pm_check_adb_devices __P((int));
void	pm_intr __P((void));
int	pm_adb_op __P((u_char *, void *, void *, int));
void	pm_init_adb_device __P((void));
d218 29
a246 29
void	print_single __P((u_char *));
void	adb_intr __P((void));
void	adb_intr_II __P((void));
void	adb_intr_IIsi __P((void));
void	adb_intr_cuda __P((void));
int	send_adb_II __P((u_char *, u_char *, void *, void *, int));
int	send_adb_IIsi __P((u_char *, u_char *, void *, void *, int));
int	send_adb_cuda __P((u_char *, u_char *, void *, void *, int));
void	adb_intr_cuda_test __P((void));
void	adb_handle_unsol __P((u_char *));
void	adb_op_comprout __P((void));
void	adb_reinit __P((void));
int	count_adbs __P((void));
int	get_ind_adb_info __P((ADBDataBlock *, int));
int	get_adb_info __P((ADBDataBlock *, int));
int	set_adb_info __P((ADBSetInfoBlock *, int));
void	adb_setup_hw_type __P((void));
int	adb_op __P((Ptr, Ptr, Ptr, short));
void	adb_handle_unsol __P((u_char *));
int	adb_op_sync __P((Ptr, Ptr, Ptr, short));
void	adb_read_II __P((u_char *));
void	adb_cleanup __P((u_char *));
void	adb_cleanup_IIsi __P((u_char *));
void	adb_comp_exec __P((void));
int	adb_cmd_result __P((u_char *));
int	adb_cmd_extra __P((u_char *));
int	adb_guess_next_device __P((void));
int	adb_prog_switch_enable __P((void));
int	adb_prog_switch_disable __P((void));
d248 1
a248 1
int	send_adb __P((u_char *, void *, void *));
@


1.10.20.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.10 1998/05/03 07:12:51 gene Exp $	*/
d61 3
a63 3
int     adb_poweroff(void);
int     adb_read_date_time(unsigned long *t);
int     adb_set_date_time(unsigned long t);
d153 1
a153 1
	void	(*ServiceRtPtr)(void);
d207 1
a207 1
int	zshard(int);
d209 5
a213 5
void	pm_setup_adb(void);
void	pm_check_adb_devices(int);
void	pm_intr(void);
int	pm_adb_op(u_char *, void *, void *, int);
void	pm_init_adb_device(void);
d218 29
a246 29
void	print_single(u_char *);
void	adb_intr(void);
void	adb_intr_II(void);
void	adb_intr_IIsi(void);
void	adb_intr_cuda(void);
int	send_adb_II(u_char *, u_char *, void *, void *, int);
int	send_adb_IIsi(u_char *, u_char *, void *, void *, int);
int	send_adb_cuda(u_char *, u_char *, void *, void *, int);
void	adb_intr_cuda_test(void);
void	adb_handle_unsol(u_char *);
void	adb_op_comprout(void);
void	adb_reinit(void);
int	count_adbs(void);
int	get_ind_adb_info(ADBDataBlock *, int);
int	get_adb_info(ADBDataBlock *, int);
int	set_adb_info(ADBSetInfoBlock *, int);
void	adb_setup_hw_type(void);
int	adb_op(Ptr, Ptr, Ptr, short);
void	adb_handle_unsol(u_char *);
int	adb_op_sync(Ptr, Ptr, Ptr, short);
void	adb_read_II(u_char *);
void	adb_cleanup(u_char *);
void	adb_cleanup_IIsi(u_char *);
void	adb_comp_exec(void);
int	adb_cmd_result(u_char *);
int	adb_cmd_extra(u_char *);
int	adb_guess_next_device(void);
int	adb_prog_switch_enable(void);
int	adb_prog_switch_disable(void);
d248 1
a248 1
int	send_adb(u_char *, void *, void *);
@


1.10.20.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1669 2
a1741 1
		splx(s);
d1743 1
@


1.10.8.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 3
a63 3
int     adb_poweroff(void);
int     adb_read_date_time(unsigned long *t);
int     adb_set_date_time(unsigned long t);
d153 1
a153 1
	void	(*ServiceRtPtr)(void);
d207 1
a207 1
int	zshard(int);
d209 5
a213 5
void	pm_setup_adb(void);
void	pm_check_adb_devices(int);
void	pm_intr(void);
int	pm_adb_op(u_char *, void *, void *, int);
void	pm_init_adb_device(void);
d218 29
a246 29
void	print_single(u_char *);
void	adb_intr(void);
void	adb_intr_II(void);
void	adb_intr_IIsi(void);
void	adb_intr_cuda(void);
int	send_adb_II(u_char *, u_char *, void *, void *, int);
int	send_adb_IIsi(u_char *, u_char *, void *, void *, int);
int	send_adb_cuda(u_char *, u_char *, void *, void *, int);
void	adb_intr_cuda_test(void);
void	adb_handle_unsol(u_char *);
void	adb_op_comprout(void);
void	adb_reinit(void);
int	count_adbs(void);
int	get_ind_adb_info(ADBDataBlock *, int);
int	get_adb_info(ADBDataBlock *, int);
int	set_adb_info(ADBSetInfoBlock *, int);
void	adb_setup_hw_type(void);
int	adb_op(Ptr, Ptr, Ptr, short);
void	adb_handle_unsol(u_char *);
int	adb_op_sync(Ptr, Ptr, Ptr, short);
void	adb_read_II(u_char *);
void	adb_cleanup(u_char *);
void	adb_cleanup_IIsi(u_char *);
void	adb_comp_exec(void);
int	adb_cmd_result(u_char *);
int	adb_cmd_extra(u_char *);
int	adb_guess_next_device(void);
int	adb_prog_switch_enable(void);
int	adb_prog_switch_disable(void);
d248 1
a248 1
int	send_adb(u_char *, void *, void *);
@


1.10.8.2
log
@Sync the SMP branch with 3.3
@
text
@d1669 2
a1741 1
		splx(s);
d1743 1
@


1.10.8.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2172 1
a2172 1
/* caller should really use machine-independent version: getPramTime */
d2226 1
a2226 1
/* caller should really use machine-independent version: setPramTime */
@


1.9
log
@prototypes; ryker
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.8 1997/04/22 23:50:05 gene Exp $	*/
a49 1
#include <machine/macinfo.h>
@


1.8
log
@Damn.  Change _all_ instances of #ifdef __NetBSD__ to #if
defined(__NetBSD__) || defined(__OpenBSD__).  This compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.7 1997/04/22 20:11:34 gene Exp $	*/
d58 7
@


1.8.6.1
log
@update release: prototypes; ryker
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.9 1998/04/22 19:59:49 deraadt Exp $	*/
a57 7
#endif


#ifdef MRG_ADB
int     adb_poweroff __P((void));
int     adb_read_date_time __P((unsigned long *t));
int     adb_set_date_time __P((unsigned long t));
@


1.7
log
@Pull in John Wittowski's HWDIRECT updates from 04/18.
Also, sync up with NetBSD with correct RCSids.
Credit goes to Scott Reynolds for the space -> tab KNF in this file.
Also, note that although rcsid's are matching, we do not support the
opt_mrg_adb.h file as NetBSD does.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.6 1997/04/18 22:08:07 gene Exp $	*/
d1337 1
a1337 1
#ifdef __NetBSD__
d1431 1
a1431 1
#ifdef __NetBSD__
d1990 1
a1990 1
#ifdef __NetBSD__
@


1.6
log
@Change via NetBSD via Scott Reynolds via Takashi Namada who provided the
original baseline for these changes.  "Make sure to call adbop() on Power
Manager-based machines."  Also, substantical cleanup and beautification.
@
text
@d1 4
a4 2
/*	$OpenBSD: adb_direct.c,v 1.5 1997/04/14 18:47:53 gene Exp $	*/
/*  adb_direct.c 1.91 1/20/97 jpw */
d40 3
a42 1
#include <sys/types.h>
a43 1
#include <sys/param.h>
d46 2
d49 1
a50 1
#include <machine/viareg.h>
d53 6
a58 3
#include <arch/mac68k/dev/adbvar.h>

#include "pm_direct.h"
d61 1
a61 1
/*#define HWDIRECT_TEST*/
d105 3
a107 3
#define ADB_SET_STATE_EVEN()		via_reg(VIA1, vBufB) = ( (via_reg(VIA1, \
						vBufB) | vPB4) & ~vPB5 )
#define ADB_SET_STATE_ODD()		via_reg(VIA1, vBufB) = ( (via_reg(VIA1, \
d124 5
a128 4
#define ADB_INTR_IS_OFF			( vPB3 == (via_reg(VIA1, vBufB) & vPB3) )
#define ADB_INTR_IS_ON			( 0 == (via_reg(VIA1, vBufB) & vPB3) )
#define ADB_SR_INTR_IS_OFF		( 0 == (via_reg(VIA1, vIFR) & vSR_INT) )
#define ADB_SR_INTR_IS_ON		( vSR_INT == (via_reg(VIA1, vIFR) & vSR_INT) )
d130 1
a130 1
/* 
d135 1
a135 1
#define ADB_ACK_DELAY	150
d146 1
a146 1
struct ADBDevEntry	{
d158 4
a161 4
        u_char	outBuf[MAX_ADB_MSG_LENGTH];	/* our message */
        u_char	*saveBuf;	/* buffer to know where to save result */
        u_char	*compRout;	/* completion routine pointer */
        u_char	*data;		/* completion routine data pointer */
d172 1
a172 1
int	adbOutQueueHasData = 0;	/* something in the "queue" waiting to go out */
d175 20
a194 22
int     adbWaitingCmd = 0;      /* ADB command we are waiting for */
u_char *adbBuffer = (long) 0;   /* pointer to user data area */
void   *adbCompRout = (long) 0; /* pointer to the completion routine */
void   *adbCompData = (long) 0; /* pointer to the completion routine data */
long    adbFakeInts = 0;        /* keeps track of fake ADB interrupts for
                                 * timeouts (II) */
int     adbStarting = 0;        /* doing ADB reinit, so do "polling" differently */
int     adbSendTalk = 0;        /* the intr routine is sending the talk, not
                                 * the user (II) */
int     adbPolling = 0;         /* we are polling for service request */
int     adbPollCmd = 0;         /* the last poll command we sent */

u_char adbInputBuffer[MAX_ADB_MSG_LENGTH];      /* data input buffer */
u_char adbOutputBuffer[MAX_ADB_MSG_LENGTH];     /* data output buffer */
struct adbCmdHoldEntry adbOutQueue;		/* our 1 entry output "queue" */

int     adbSentChars = 0;       /* how many characters we have sent */
int     adbLastDevice = 0;      /* last ADB device we heard from (II ONLY) */
int     adbLastDevIndex = 0;    /* last ADB device loc. in device table (II ONLY) */
int     adbLastCommand = 0;     /* the last ADB command we sent (II) */
int     adbWaitingSubDev = 0;   /* ADB sub-device (RTC, PRAM, etc) - IIsi ONLY - unused */
int     adbWaitingDevice = 0;   /* ADB device we are waiting for - unused */
d196 2
a197 2
struct ADBDevEntry ADBDevTable[16];     /* our ADB device table */
int     ADBNumDevices;          /* number of ADB devices found with ADBReInit */
d201 1
a201 1
extern int	zshard __P((int));
d203 5
d212 1
a212 1
void	print_single __P((unsigned char *));
d217 5
a221 4
int	send_adb_II __P((unsigned char *, unsigned char *, void *, void *, int));
int	send_adb_IIsi __P((unsigned char *, unsigned char *, void *, void *, int));
int	send_adb_cuda __P((unsigned char *, unsigned char *, void *, void *, int));
void 	db_handle_unsol __P((unsigned char *));
d230 1
a230 1
void	adb_handle_unsol __P((unsigned char *));
d232 3
a234 3
void	adb_read_II __P((unsigned char *));
void	adb_cleanup __P((unsigned char *));
void	adb_cleanup_IIsi __P((unsigned char *));
d236 2
a237 2
int	adb_cmd_result __P((unsigned char *));
int	adb_cmd_extra __P((unsigned char *));
d242 1
a242 1
int	send_adb __P((unsigned char *, void *, void *));
a243 1
  
d250 1
a250 1
void 
d252 1
a252 1
        u_char *thestring;
d254 1
a254 1
        int     x;
d256 16
a271 16
        if ((int)(thestring[0]) == 0) {
                printf("nothing returned\n");
                return;
        }
        if (thestring == 0) {
                printf("no data - null pointer\n");
                return;
        }
        if (thestring[0] > 20) {
                printf("ADB: ACK > 20 no way!\n");
                thestring[0] = 20;
        }
        printf("(length=0x%x):", thestring[0]);
        for (x = 0; x < thestring[0]; x++)
                printf("  0x%02x", thestring[x + 1]);
        printf("\n");
d275 2
a276 2
/* 
 * called when when an adb interrupt happens 
d279 1
a279 1
 * TO DO: can probably reduce the number of zshard calls in here
d281 1
a281 1
void 
d284 2
a285 2
        int     i, ending, len;
        unsigned int s;
d287 2
a288 2
        s = splhigh();          /* can't be too careful - might be called */
                                /* from a routine, NOT an interrupt */
d290 1
a290 1
        ADB_VIA_CLR_INTR();     /* clear interrupt */
d292 1
a292 1
        ADB_VIA_INTR_DISABLE(); /* disable ADB interrupt on IIs. */
d295 48
a342 33
        switch (adbActionState) {
        case ADB_ACTION_IDLE:
                adbInputBuffer[1] = ADB_SR();   /* get byte */
                ADB_SET_SR_INPUT();		/* make sure SR is set to IN */
                ADB_SET_STATE_TIP();		/* signal start of data frame */
        	printf("idle 0x%02x ", adbInputBuffer[1]);
                adbInputBuffer[0] = 1;
                adbActionState = ADB_ACTION_IN; /* set next state */
                break;

        case ADB_ACTION_IN:
                adbInputBuffer[++adbInputBuffer[0]] = ADB_SR(); /* get byte */
                ADB_SET_SR_INPUT();		/* make sure SR is set to IN */
                if (ADB_INTR_IS_OFF)		/* check for end of frame */
                        ending = 1;
                else
                        ending = 0;

                if (1 == ending) {      /* end of message? */
                        ADB_CLR_STATE_TIP();       /* signal end of frame */
                	printf("in end 0x%02x ", adbInputBuffer[adbInputBuffer[0]]);
                	print_single(adbInputBuffer);
                        /* this section _should_ handle all ADB and RTC/PRAM type commands, */
                        /* but there may be more... */
                        /* note: commands are always at [4], even for rtc/pram commands */
                        if ((adbWaiting == 1) &&        /* are we waiting AND */
                            (adbInputBuffer[4] == adbWaitingCmd) &&     /* the cmd we sent AND */
                            ((adbInputBuffer[2] == 0x00) ||     /* it's from the
								 * ADB device OR */
                                (adbInputBuffer[2] == 0x01))) { /* it's from the PRAM/RTC device */
                                
                                /* is this data we are waiting for? */
                                if (adbBuffer != (long) 0) {    /* if valid return data pointer */
d344 36
a379 108
                                        len = adbInputBuffer[0] - 4;    
                                        /* if adb_op is ever made to be called from a user
                                         * routine, we should use a copyout or copyin
                                         * here to be sure we're in the correct context */
                                        for (i = 1; i <= len; i++)
                                                adbBuffer[i] = adbInputBuffer[4 + i];
                                        if (len < 0)
                                                len = 0;
                                        adbBuffer[0] = len;
                                }
                                adb_comp_exec();        /* call completion routine */

                                adbWaitingCmd = 0;      /* reset "waiting" vars */
                                adbWaiting = 0;
                                adbBuffer = (long) 0;
                                adbCompRout = (long) 0;
                                adbCompData = (long) 0;
                        } else {
                                /* pass the data off to the handler */
                                /* This section IGNORES all data that is not from 
                                 * the ADB sub-device. That is, not from rtc or pram.
                                 * Maybe we  should fix later, but do the other
                                 * devices every send things without
                                 * being asked? */
                                if (adbStarting == 0)   /* ignore if during adbreinit */
                                        if (adbInputBuffer[2] == 0x00)
                                                adb_handle_unsol(adbInputBuffer);
                        }

                        adbActionState = ADB_ACTION_IDLE;
                        adbInputBuffer[0] = 0;  /* reset length */

                        if (adbWriteDelay == 1) {       /* were we waiting to write? */\
                        	printf("WRITE DELAY ");
                                adbSentChars = 0;       /* nothing sent yet */
                                adbActionState = ADB_ACTION_OUT;        /* set next state */

                                if (ADB_INTR_IS_ON) {   /* ADB intr low during write */
                                        ADB_CLR_STATE_TIP();      /* reset */
                                        ADB_SET_SR_INPUT();     /* make sure SR is set to IN */
                                        adbSentChars = 0;       /* must start all over */
                                        adbActionState = ADB_ACTION_IDLE;	/* new state */
                                        adbInputBuffer[0] = 0;
                                        break;
                                }
                                ADB_SET_SR_OUTPUT();    /* set shift register for OUT */
                                ADB_SR() = adbOutputBuffer[adbSentChars + 1];
                                ADB_SET_STATE_TIP();	/* tell ADB that we want to send */
                        }
                } else {
                	ADB_TOGGLE_STATE_ACK_CUDA();
                	printf("in 0x%02x ", adbInputBuffer[adbInputBuffer[0]]);
                }
                	
                break;

        case ADB_ACTION_OUT:
                i = ADB_SR();		/* reset SR-intr in IFR */
        	printf("intr out 0x%02x ", i);
                ADB_SET_SR_OUTPUT();    /* set shift register for OUT */

                adbSentChars++;
                if (ADB_INTR_IS_ON) {		/* ADB intr low during write */
                printf("intr was on ");
                        ADB_CLR_STATE_TIP();      /* reset */
                        ADB_SET_SR_INPUT();     /* make sure SR is set to IN */
                        adbSentChars = 0;       /* must start all over */
                        adbActionState = ADB_ACTION_IDLE;       /* new state */
                        adbInputBuffer[0] = 0;
                        adbWriteDelay = 1;      /* must retry when done with read */
                        delay(ADB_ACK_DELAY);   /* delay */
                        /* TO DO: not sure if this is the right thing to do for Cuda */
                        goto switch_start;      /* process next state right now */
                        break;
                }

                if (adbOutputBuffer[0] == adbSentChars) {       /* check for done */
                        if (0 == adb_cmd_result(adbOutputBuffer)) {     /* do we expect data back? */
                                adbWaiting = 1; /* signal waiting for return */
                                adbWaitingCmd = adbOutputBuffer[2];     /* save waiting command */
                        } else {        /* no talk, so done */
                                adb_comp_exec();        /* call completion routine */
                                adbWaitingCmd = 0;      /* reset "waiting" vars, just in case */
                                adbBuffer = (long) 0;
                                adbCompRout = (long) 0;
                                adbCompData = (long) 0;
                        }

                        adbWriteDelay = 0;      /* done writing */
                        adbActionState = ADB_ACTION_IDLE;       /* signal bus is idle */
                        /*ADB_SET_SR_INPUT();		make sure SR is set to IN */
                        ADB_TOGGLE_STATE_ACK_CUDA();
                        ADB_CLR_STATE_TIP();       	/* end of frame */
                	printf("write done ");
                } else {
                        ADB_SR() = adbOutputBuffer[adbSentChars + 1];   /* send next byte */
                        ADB_TOGGLE_STATE_ACK_CUDA();  /* signal byte ready to shift */
                        printf("toggle ");
                }
                break;

        case ADB_ACTION_NOTREADY:
                printf("adb: not yet initialized\n");
                break;

        default:
                printf("intr: unknown ADB state\n");
        }
d381 47
a427 1
        ADB_VIA_INTR_ENABLE();  /* enable ADB interrupt on IIs. */
d429 6
a434 1
        splx(s);                /* restore */
d436 31
a466 2
        return;
}                               /* end adb_intr_IIsi */
d468 15
d484 19
a502 3
int 
send_adb_cuda(u_char *in, u_char *buffer, void *compRout, void *data, int
command)
d504 1
a504 1
        int     i, s, len;
d506 20
a525 2
        if (adbActionState == ADB_ACTION_NOTREADY)
                return 1;
d527 39
a565 41
        s = splhigh();          /* don't interrupt while we are messing with the ADB */

        if ((adbActionState == ADB_ACTION_IDLE) &&      /* ADB available? */
            (ADB_INTR_IS_OFF)) {       			/* and no incoming interrupt? */

        } else if (adbWriteDelay == 0)  /* it's busy, but is anything waiting? */
                adbWriteDelay = 1;      /* if no, then we'll "queue" it up */
        else {
                splx(s);
                return 1;       /* really busy! */
        }

        if ((long) in == (long) 0) {    /* need to convert? */
                /* don't need to use adb_cmd_extra here because this section will be called */
                /* ONLY when it is an ADB command (no RTC or PRAM) */
                if ((command & 0x0c) == 0x08)   /* copy addl data ONLY if doing a listen! */
                        len = buffer[0];        /* length of additional data */
                else
                        len = 0;		/* no additional data */

                adbOutputBuffer[0] = 2 + len;   /* dev. type + command + addl. data */
                adbOutputBuffer[1] = 0x00;      /* mark as an ADB command */
                adbOutputBuffer[2] = (u_char) command;  /* load command */

                for (i = 1; i <= len; i++)      /* copy additional output data, if any */
                        adbOutputBuffer[2 + i] = buffer[i];
        } else
                for (i = 0; i <= (adbOutputBuffer[0] + 1); i++)
                        adbOutputBuffer[i] = in[i];

        adbSentChars = 0;       /* nothing sent yet */
        adbBuffer = buffer;     /* save buffer to know where to save result */
        adbCompRout = compRout; /* save completion routine pointer */
        adbCompData = data;     /* save completion routine data pointer */
        adbWaitingCmd = adbOutputBuffer[2];     /* save wait command */

        if (adbWriteDelay != 1) {       /* start command now? */
        printf("out start ");
                adbActionState = ADB_ACTION_OUT;        /* set next state */
                ADB_SET_SR_OUTPUT();    /* set shift register for OUT */
                ADB_SR() = adbOutputBuffer[adbSentChars + 1];   /* load byte for output */
d567 5
a571 12
                ADB_SET_STATE_TIP(); /* tell ADB that we want to send */
        }
        adbWriteDelay = 1;		/* something in the write "queue" */

        splx(s);

        if (0x0100 <= (s & 0x0700))     /* were VIA1 interrupts blocked ? */
                /* poll until byte done */
                while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
                    || (adbWaiting == 1))
                        if (ADB_SR_INTR_IS_ON)  /* wait for "interrupt" */
                                adb_intr_cuda();     /* go process "interrupt" */
d573 10
a582 2
        return 0;
}                               /* send_adb_cuda */
d589 3
a591 3
        int	i, len, intr_on = 0;
        int	send = 0, do_srq = 0;
        unsigned int	s;
d593 2
a594 2
        s = splhigh();          /* can't be too careful - might be called */
                                /* from a routine, NOT an interrupt */
d596 1
a596 1
        ADB_VIA_CLR_INTR();     /* clear interrupt */
d598 1
a598 1
        ADB_VIA_INTR_DISABLE(); /* disable ADB interrupt on IIs. */
d601 152
a752 163
/*	printf("INTR ON ");*/
if (ADB_INTR_IS_ON)
	intr_on=1;	/* save for later */

        switch (adbActionState) {
        case ADB_ACTION_IDLE:
        	if ( !intr_on ) {
        		/*printf("FAKE DROPPED \n");*/
        		/*printf(" XX ");*/
        		i=ADB_SR();
        		break;
        	}
        	adbNextEnd=0;
        	/*printf("idle ");*/
                adbInputBuffer[0] = 1;
                adbInputBuffer[1] = ADB_SR();   /* get first byte */
		/*printf("0x%02x ", adbInputBuffer[1]);*/
                ADB_SET_SR_INPUT();     	/* make sure SR is set to IN */
                adbActionState = ADB_ACTION_IN;	/* set next state */
                ADB_SET_STATE_EVEN();   	/* set bus state to even */
                adbBusState = ADB_BUS_EVEN;
        	break;
        
        case ADB_ACTION_IN:
                adbInputBuffer[++adbInputBuffer[0]] = ADB_SR(); /* get byte */
		/*printf("in 0x%02x ", adbInputBuffer[adbInputBuffer[0]]);*/
                ADB_SET_SR_INPUT();     /* make sure SR is set to IN */
                
                /*
                 * Check for an unsolicited Service Request (SRQ).
                 * An empty SRQ packet NEVER ends, so we must manually
                 * check for the following condition. 
                 */
                if ( adbInputBuffer[0]==4 && adbInputBuffer[2]==0xff &&
                    adbInputBuffer[3]==0xff && adbInputBuffer[4]==0xff &&
                    intr_on && !adbNextEnd )
                    	do_srq=1;
                
                if (adbNextEnd==1) {	/* process last byte of packet */
                 	adbNextEnd=0;
                	/*printf("done: ");*/
                	
                	/* 
                	 * If the following conditions are true (4 byte
                	 * message, last 3 bytes are 0xff) then we
                	 * basically got a "no response" from the ADB chip,
                	 * so change the message to an empty one.
                	 * We also clear intr_on to stop the SRQ send later
                	 * on because these packets normally have the SRQ 
                	 * bit set even when there is NOT a pending SRQ.
                	 */
                	if ( adbInputBuffer[0]==4 && adbInputBuffer[2]==0xff &&
                	    adbInputBuffer[3]==0xff && adbInputBuffer[4]==0xff ) {
                	    	/*printf("NO RESP ");*/
                	    	intr_on=0;
                		adbInputBuffer[0]=0;
                	}
                	
                	adbLastDevice=(adbInputBuffer[1] & 0xf0) >> 4;
                	
                	if ((!adbWaiting || adbPolling )
                	    && (adbInputBuffer[0] != 0)) {
                		/* unsolicided - ignore if starting */
                		if (!adbStarting)
                			adb_handle_unsol(adbInputBuffer);
                	} else if ( !adbPolling ) { /* someone asked for it */
                		/*printf("SOL: ");*/
                		/*print_single(adbInputBuffer);*/
                                if (adbBuffer != (long) 0) {	/* if valid return data pointer */
					/* get return length minus extras */
                                        len = adbInputBuffer[0] - 1;
                                           
                                        /* if adb_op is ever made to be called from a user
                                         * routine, we should  use a copyout or copyin
                                         * here to be sure we're in the correct context. */
                                        for (i = 1; i <= len; i++)
                                                adbBuffer[i] = adbInputBuffer[i + 1];
                                        if (len < 0)
                                                len = 0;
                                        adbBuffer[0] = len;
                                }
                		adb_comp_exec();
                	}
                	                	
                	adbWaiting=0;
                	adbPolling=0;
                	adbInputBuffer[0]=0;
                        adbBuffer = (long) 0;
                        adbCompRout = (long) 0;
                        adbCompData = (long) 0;
                        /*
                         * Since we are done, check whether there is any data 
                         * waiting to do out. If so, start the sending the data.
                         */
                        if (adbOutQueueHasData == 1) {
                        /*printf("XXX: DOING OUT QUEUE\n");*/
                                /* copy over data */
                                for (i = 0; i <= (adbOutQueue.outBuf[0] + 1); i++)
                                        adbOutputBuffer[i] = adbOutQueue.outBuf[i];
                                adbBuffer = adbOutQueue.saveBuf;	/* user data area */
                                adbCompRout = adbOutQueue.compRout;     /* completion routine */
                                adbCompData = adbOutQueue.data; 	/* comp. rout. data */
                                adbOutQueueHasData = 0; /* currently processing "queue" entry */
                                adbPolling=0;
                                send=1;
                	/* if intr_on is true, then it's a SRQ
                	 * so poll other devices. */
                	} else if (intr_on) {
                		/*printf("starting POLL ");*/
                		do_srq=1;
                		adbPolling=1;
                	} else if ( (adbInputBuffer[1] & 0x0f) != 0x0c) {
                		/*printf("xC HACK ");*/
                		adbPolling=1;
                 		send=1;
                		adbOutputBuffer[0]=1;
                		adbOutputBuffer[1]=(adbInputBuffer[1] & 0xf0) | 0x0c;
                	} else {
                		/*printf("ending ");*/
                		adbBusState=ADB_BUS_IDLE;
                		adbActionState=ADB_ACTION_IDLE;
                		ADB_SET_STATE_IDLE_II();
                		break;
                	}
                }
                
                /*
                 * If do_srq is true then something above determined that
                 * the message has ended and some device is sending a 
                 * service request. So we need to determine the next device
                 * and send a poll to it. (If the device we send to isn't the
                 * one that sent the SRQ, that ok as it will be caught
                 * the next time though.)
                 */
                if ( do_srq ) {
                	/*printf("SRQ! ");*/
                	adbPolling=1;
                	adb_guess_next_device();
			adbOutputBuffer[0]=1;
			adbOutputBuffer[1]=((adbLastDevice & 0x0f) << 4) | 0x0c;
			send=1;
                }

                /*
                 * If send is true then something above determined that
                 * the message has ended and we need to start sending out
                 * a new message immediately. This could be because there
                 * is data waiting to go out or because an SRQ was seen.
                 */
                if ( send ) {
                	adbNextEnd = 0;
        		adbSentChars = 0;       		/* nothing sent yet */
        		adbActionState = ADB_ACTION_OUT;        /* set next state */
        		ADB_SET_SR_OUTPUT();			/* set shift register for OUT */
        		ADB_SR() = adbOutputBuffer[1];		/* load byte for output */
        		adbBusState = ADB_BUS_CMD;		/* set bus to cmd state */
        		ADB_SET_STATE_CMD();    		/* tell ADB that we want to send */
        		break;
                }

		/* 
		 * We only get this far if the message hasn't
		 * ended yet.
d754 18
a771 6
                if (!intr_on)			/* if adb intr. on then the */
                	adbNextEnd=1;		/* NEXT byte is the last */
                	
               	switch (adbBusState) {  	/* set to next state */
                case ADB_BUS_EVEN:
                	ADB_SET_STATE_ODD();    /* set state to odd */
d773 1
a773 1
                	break;
d776 36
a811 39
                	ADB_SET_STATE_EVEN();   /* set state to even */
                	adbBusState = ADB_BUS_EVEN;
               		break;
                default:
               		printf("strange state!!!\n");      /* huh? */
                	break;
                }
        	break;
        
        case ADB_ACTION_OUT:
               	adbNextEnd=0;
               	if (!adbPolling)
               		adbWaiting=1;		/* not unsolicited */
        	i=ADB_SR();			/* clear interrupt */
        	adbSentChars++;
        	/*
        	 * If the outgoing data was a TALK, we must
        	 * switch to input mode to get the result.
        	 */
        	if ( (adbOutputBuffer[1] & 0x0c) == 0x0c ) {
        		adbInputBuffer[0]=1;
        		adbInputBuffer[1]=i;
        		adbActionState=ADB_ACTION_IN;
        		ADB_SET_SR_INPUT();
        		adbBusState= ADB_BUS_EVEN;
        		ADB_SET_STATE_EVEN();
        		/*printf("talk out 0x%02x ", i);*/
        		break;
        	}
        	
        	/* 
        	 * If it's not a TALK, check whether all data has been
        	 * sent. If so, call the completion routine and clean up.
        	 * If not, advance to the next state.
        	 */
        	/*printf("non-talk out 0x%0x ", i);*/
        	ADB_SET_SR_OUTPUT();
                if (adbOutputBuffer[0] == adbSentChars) {       /* check for done */
			/*printf("done \n");*/
d813 52
a864 51
                        adbBuffer = (long) 0;
                        adbCompRout = (long) 0;
                        adbCompData = (long) 0;
                        if (adbOutQueueHasData == 1) {
                                /* copy over data */
                                for (i = 0; i <= (adbOutQueue.outBuf[0] + 1); i++)
                                        adbOutputBuffer[i] = adbOutQueue.outBuf[i];
                                adbBuffer = adbOutQueue.saveBuf;	/* user data area */
                                adbCompRout = adbOutQueue.compRout;     /* completion routine */
                                adbCompData = adbOutQueue.data; 	/* comp. rout. data */
                                adbOutQueueHasData = 0; /* currently processing "queue" entry */
                                adbPolling=0;
                        } else {
                        	adbOutputBuffer[0]=1;
                        	adbOutputBuffer[1]=(adbOutputBuffer[1] & 0xf0) | 0x0c;
        			adbPolling=1;			/* non-user poll */
        		}
                        adbNextEnd = 0;
        		adbSentChars = 0;       		/* nothing sent yet */
        		adbActionState = ADB_ACTION_OUT;        /* set next state */
        		ADB_SET_SR_OUTPUT();			/* set shift register for OUT */
        		ADB_SR() = adbOutputBuffer[1];		/* load byte for output */
        		adbBusState = ADB_BUS_CMD;		/* set bus to cmd state */
        		ADB_SET_STATE_CMD();    		/* tell ADB that we want to send */
        		break;
               }
                
        	ADB_SR() = adbOutputBuffer[adbSentChars + 1];
               	switch (adbBusState) {  	/* advance to next state */
                case ADB_BUS_EVEN:
                	ADB_SET_STATE_ODD();    /* set state to odd */
                	adbBusState = ADB_BUS_ODD;
                	break;

                case ADB_BUS_CMD:
                case ADB_BUS_ODD:
                        ADB_SET_STATE_EVEN();   /* set state to even */
                        adbBusState = ADB_BUS_EVEN;
                        break;

                default:
                        printf("strange state!!! (0x%x)\n", adbBusState);
                        break;
                }
        	break;
        	
        default:
                printf("adb: unknown ADB state (during intr)\n");
        }
	
        ADB_VIA_INTR_ENABLE();  /* enable ADB interrupt on IIs. */
d866 1
a866 1
        splx(s);                /* restore */
d868 1
a868 1
        return;
d873 2
a874 2
/* 
 * send_adb version for II series machines 
d877 1
a877 1
send_adb_II(u_char *in, u_char *buffer, void *compRout, void *data, int command)
d879 1
a879 1
        int     i, s, len;
d881 3
a883 2
        if (adbActionState == ADB_ACTION_NOTREADY)      /* return if ADB not available */
                return 1;
d885 2
a886 1
        s = splhigh();          /* don't interrupt while we are messing with the ADB */
d888 67
a954 60
        if (0 != adbOutQueueHasData) {  /* right now, "has data" means "full" */
                splx(s);		/* sorry, try again later */
                return 1;
        }
        if ((long) in == (long) 0) {    /* need to convert? */
                /*
                 * Don't need to use adb_cmd_extra here because this section
                 * will be called ONLY when it is an ADB command (no RTC or
                 * PRAM), especially on II series!
                 */
                if ((command & 0x0c) == 0x08)   /* copy addl data ONLY if doing a listen! */
                        len = buffer[0];        /* length of additional data */
                else
                        len = 0;		/* no additional data */

                adbOutQueue.outBuf[0] = 1 + len;	/* command + addl. data */
                adbOutQueue.outBuf[1] = (u_char) command;	/* load command */

                for (i = 1; i <= len; i++)      /* copy additional output data, if any */
                        adbOutQueue.outBuf[1 + i] = buffer[i];
        } else
      			/* if data ready, just copy over */                
      		for (i = 0; i <= (adbOutQueue.outBuf[0] + 1); i++)
                        adbOutQueue.outBuf[i] = in[i];

        adbOutQueue.saveBuf = buffer;   	/* save buffer to know where to save result */
        adbOutQueue.compRout = compRout;        /* save completion routine pointer */
        adbOutQueue.data = data;		/* save completion routine data pointer */

        if ((adbActionState == ADB_ACTION_IDLE) &&      /* is ADB available? */
            (ADB_INTR_IS_OFF) &&			/* and no incoming interrupts? */
            (adbPolling == 0)) {			/* and we are not currently polling */
            						/* then start command now */
                for (i = 0; i <= (adbOutQueue.outBuf[0] + 1); i++)      /* copy over data */
                        adbOutputBuffer[i] = adbOutQueue.outBuf[i];
                        
                adbBuffer = adbOutQueue.saveBuf;        /* pointer to user data area */
                adbCompRout = adbOutQueue.compRout;     /* pointer to the completion routine */
                adbCompData = adbOutQueue.data; 	/* pointer to the completion routine data */

                adbSentChars = 0;       		/* nothing sent yet */
                adbActionState = ADB_ACTION_OUT;        /* set next state */
                adbBusState = ADB_BUS_CMD;		/* set bus to cmd state */

                ADB_SET_SR_OUTPUT();			/* set shift register for OUT */

                ADB_SR() = adbOutputBuffer[adbSentChars + 1];   /* load byte for output */
                ADB_SET_STATE_CMD();    /* tell ADB that we want to send */
                adbOutQueueHasData = 0; /* currently processing "queue" entry */
        } else
                adbOutQueueHasData = 1; /* something in the write "queue" */

        splx(s);

        if (0x0100 <= (s & 0x0700))     /* were VIA1 interrupts blocked ? */
                /* poll until message done */
                while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
                    || (adbWaiting == 1) || (adbPolling == 1))
                        if (ADB_SR_INTR_IS_ON)		/* wait for "interrupt" */
                                adb_intr_II();       /* go process "interrupt" */
d956 1
a956 1
        return 0;
d967 1
a967 1
	int	last, i, dummy;
d970 3
a972 3
		/* start polling EVERY device, since we can't 
		 * be sure there is anything in the device table yet */
		if (adbLastDevice < 1 || adbLastDevice > 15)   
d974 1
a974 1
		if (++adbLastDevice > 15)       /* point to next one */
d978 1
a978 1
		if (adbLastDevice < 1 || adbLastDevice > 15)	/* let's be parinoid */ 
d980 2
a981 2
		last = 1;		/* default index location */
        	                        
d983 2
a984 2
 			if (ADBDevTable[i].currentAddr == adbLastDevice) {	/* look for device */   
				last = i;       /* found it */
d987 3
a989 4
       	                                 
		dummy = last;   /* index to start at */
		for (;;) {      /* find next device in index */
    			if (++dummy > 15)       /* wrap around if needed */
d991 5
a995 4
			if (dummy == last) {    /* didn't find any other
       	                                  * device! This can happen if there
       	                                  * are no devices on the bus */
				dummy = 2;      
d999 1
a999 1
			if (ADBDevTable[dummy].devType != 0)   
d1002 1
a1002 1
		adbLastDevice=ADBDevTable[dummy].currentAddr;     
d1006 1
a1006 2

/* 
d1011 1
a1011 1
void 
d1014 4
a1017 8
        switch (adbHardware) {
        case ADB_HW_II:
                adb_intr_II();
                break;

        case ADB_HW_IISI:
                adb_intr_IIsi();
                break;
d1019 6
a1024 2
        case ADB_HW_PB:
                break;
d1029 4
a1032 4
		
        case ADB_HW_UNKNOWN:
                break;
        }
d1036 2
a1037 2
/* 
 * called when when an adb interrupt happens 
d1042 1
a1042 1
void 
d1045 2
a1046 2
        int     i, ending, len;
        unsigned int s;
d1048 2
a1049 2
        s = splhigh();          /* can't be too careful - might be called */
                                /* from a routine, NOT an interrupt */
d1051 1
a1051 1
        ADB_VIA_CLR_INTR();     /* clear interrupt */
d1053 1
a1053 1
        ADB_VIA_INTR_DISABLE(); /* disable ADB interrupt on IIs. */
d1056 47
a1102 43
        switch (adbActionState) {
        case ADB_ACTION_IDLE:
                delay(ADB_ACK_DELAY);   /* short delay is required
                                         * before the first byte */

                ADB_SET_SR_INPUT();		/* make sure SR is set to IN */
                ADB_SET_STATE_ACTIVE();		/* signal start of data frame */
                adbInputBuffer[1] = ADB_SR();   /* get byte */
                adbInputBuffer[0] = 1;
                adbActionState = ADB_ACTION_IN; /* set next state */

                ADB_SET_STATE_ACKON();		/* start ACK to ADB chip */
                delay(ADB_ACK_DELAY);		/* delay */
                ADB_SET_STATE_ACKOFF();		/* end ACK to ADB chip */
                zshard(0);			/* grab any serial interrupts */
                break;

        case ADB_ACTION_IN:
                ADB_SET_SR_INPUT();		/* make sure SR is set to IN */
                adbInputBuffer[++adbInputBuffer[0]] = ADB_SR(); /* get byte */
                if (ADB_INTR_IS_OFF)		/* check for end of frame */
                        ending = 1;
                else
                        ending = 0;

                ADB_SET_STATE_ACKON();  /* start ACK to ADB chip */
                delay(ADB_ACK_DELAY);   /* delay */
                ADB_SET_STATE_ACKOFF(); /* end ACK to ADB chip */
                zshard(0);              /* grab any serial interrupts */

                if (1 == ending) {      /* end of message? */
                        ADB_SET_STATE_INACTIVE();       /* signal end of frame */
                        /* this section _should_ handle all ADB and RTC/PRAM type commands, */
                        /* but there may be more... */
                        /* note: commands are always at [4], even for rtc/pram commands */
                        if ((adbWaiting == 1) &&        /* are we waiting AND */
                            (adbInputBuffer[4] == adbWaitingCmd) &&     /* the cmd we sent AND */
                            ((adbInputBuffer[2] == 0x00) ||     /* it's from the
								 * ADB device OR */
                                (adbInputBuffer[2] == 0x01))) { /* it's from the PRAM/RTC device */
                                
                                /* is this data we are waiting for? */
                                if (adbBuffer != (long) 0) {    /* if valid return data pointer */
d1104 66
a1169 108
                                        len = adbInputBuffer[0] - 4;    
                                        /* if adb_op is ever made to be called from a user
                                         * routine, we should use a copyout or copyin
                                         * here to be sure we're in the correct context */
                                        for (i = 1; i <= len; i++)
                                                adbBuffer[i] = adbInputBuffer[4 + i];
                                        if (len < 0)
                                                len = 0;
                                        adbBuffer[0] = len;
                                }
                                adb_comp_exec();        /* call completion routine */

                                adbWaitingCmd = 0;      /* reset "waiting" vars */
                                adbWaiting = 0;
                                adbBuffer = (long) 0;
                                adbCompRout = (long) 0;
                                adbCompData = (long) 0;
                        } else {
                                /* pass the data off to the handler */
                                /* This section IGNORES all data that is not from 
                                 * the ADB sub-device. That is, not from rtc or pram.
                                 * Maybe we  should fix later, but do the other
                                 * devices every send things without
                                 * being asked? */
                                if (adbStarting == 0)   /* ignore if during adbreinit */
                                        if (adbInputBuffer[2] == 0x00)
                                                adb_handle_unsol(adbInputBuffer);
                        }

                        adbActionState = ADB_ACTION_IDLE;
                        adbInputBuffer[0] = 0;  /* reset length */

                        if (adbWriteDelay == 1) {       /* were we waiting to write? */
                                adbSentChars = 0;       /* nothing sent yet */
                                adbActionState = ADB_ACTION_OUT;        /* set next state */

                                delay(ADB_ACK_DELAY);   /* delay */
                                zshard(0);      	/* grab any serial interrupts */

                                if (ADB_INTR_IS_ON) {   /* ADB intr low during write */
                                        ADB_SET_STATE_IDLE_IISI();      /* reset */
                                        ADB_SET_SR_INPUT();     /* make sure SR is set to IN */
                                        adbSentChars = 0;       /* must start all over */
                                        adbActionState = ADB_ACTION_IDLE;	/* new state */
                                        adbInputBuffer[0] = 0;
                                        /* may be able to take this out later */
                                        delay(ADB_ACK_DELAY);   /* delay */
                                        break;
                                }
                                ADB_SET_STATE_ACTIVE(); /* tell ADB that we want to send */
                                ADB_SET_STATE_ACKOFF(); /* make sure */
                                ADB_SET_SR_OUTPUT();    /* set shift register for OUT */
                                ADB_SR() = adbOutputBuffer[adbSentChars + 1];
                                ADB_SET_STATE_ACKON();  /* tell ADB byte ready to shift */
                        }
                }
                break;

        case ADB_ACTION_OUT:
                i = ADB_SR();		/* reset SR-intr in IFR */
                ADB_SET_SR_OUTPUT();    /* set shift register for OUT */

                ADB_SET_STATE_ACKOFF(); /* finish ACK */
                adbSentChars++;
                if (ADB_INTR_IS_ON) {		/* ADB intr low during write */
                        ADB_SET_STATE_IDLE_IISI();      /* reset */
                        ADB_SET_SR_INPUT();     /* make sure SR is set to IN */
                        adbSentChars = 0;       /* must start all over */
                        adbActionState = ADB_ACTION_IDLE;       /* new state */
                        adbInputBuffer[0] = 0;
                        adbWriteDelay = 1;      /* must retry when done with read */
                        delay(ADB_ACK_DELAY);   /* delay */
                        zshard(0);              /* grab any serial interrupts */
                        goto switch_start;      /* process next state  right now */
                        break;
                }
                delay(ADB_ACK_DELAY);   /* required delay */
                zshard(0);		/* grab any serial interrupts */

                if (adbOutputBuffer[0] == adbSentChars) {       /* check for done */
                        if (0 == adb_cmd_result(adbOutputBuffer)) {     /* do we expect data back? */
                                adbWaiting = 1; /* signal waiting for return */
                                adbWaitingCmd = adbOutputBuffer[2];     /* save waiting command */
                        } else {        /* no talk, so done */
                                adb_comp_exec();        /* call completion routine */
                                adbWaitingCmd = 0;      /* reset "waiting" vars, just in case */
                                adbBuffer = (long) 0;
                                adbCompRout = (long) 0;
                                adbCompData = (long) 0;
                        }

                        adbWriteDelay = 0;      /* done writing */
                        adbActionState = ADB_ACTION_IDLE;       /* signal bus is idle */
                        ADB_SET_SR_INPUT();		/* make sure SR is set to IN */
                        ADB_SET_STATE_INACTIVE();       /* end of frame */
                } else {
                        ADB_SR() = adbOutputBuffer[adbSentChars + 1];   /* send next byte */
                        ADB_SET_STATE_ACKON();  /* signal byte ready to shift */
                }
                break;

        case ADB_ACTION_NOTREADY:
                printf("adb: not yet initialized\n");
                break;

        default:
                printf("intr: unknown ADB state\n");
        }
d1171 47
a1217 1
        ADB_VIA_INTR_ENABLE();  /* enable ADB interrupt on IIs. */
d1219 3
a1221 1
        splx(s);                /* restore */
d1223 10
a1232 2
        return;
}                               /* end adb_intr_IIsi */
d1243 1
a1243 1
 * compRout: the completion routine that is called when then return value 
d1247 1
a1247 1
 *           
d1249 3
a1251 3
int 
send_adb_IIsi(u_char *in, u_char *buffer, void *compRout, void *data, int
command)
d1253 1
a1253 1
        int     i, s, len;
d1255 2
a1256 2
        if (adbActionState == ADB_ACTION_NOTREADY)
                return 1;
d1258 14
a1271 1
        s = splhigh();          /* don't interrupt while we are messing with the ADB */
d1273 30
a1302 2
        if ((adbActionState == ADB_ACTION_IDLE) &&      /* ADB available? */
            (ADB_INTR_IS_OFF)) {       			/* and no incoming interrupt? */
d1304 2
a1305 6
        } else if (adbWriteDelay == 0)  /* it's busy, but is anything waiting? */
                adbWriteDelay = 1;      /* if no, then we'll "queue" it up */
        else {
                splx(s);
                return 1;       /* really busy! */
        }
d1307 1
a1307 7
        if ((long) in == (long) 0) {    /* need to convert? */
                /* don't need to use adb_cmd_extra here because this section will be called */
                /* ONLY when it is an ADB command (no RTC or PRAM) */
                if ((command & 0x0c) == 0x08)   /* copy addl data ONLY if doing a listen! */
                        len = buffer[0];        /* length of additional data */
                else
                        len = 0;		/* no additional data */
d1309 1
a1309 3
                adbOutputBuffer[0] = 2 + len;   /* dev. type + command + addl. data */
                adbOutputBuffer[1] = 0x00;      /* mark as an ADB command */
                adbOutputBuffer[2] = (u_char) command;  /* load command */
d1311 3
a1313 5
                for (i = 1; i <= len; i++)      /* copy additional output data, if any */
                        adbOutputBuffer[2 + i] = buffer[i];
        } else
                for (i = 0; i <= (adbOutputBuffer[0] + 1); i++)
                        adbOutputBuffer[i] = in[i];
d1315 1
a1315 5
        adbSentChars = 0;       /* nothing sent yet */
        adbBuffer = buffer;     /* save buffer to know where to save result */
        adbCompRout = compRout; /* save completion routine pointer */
        adbCompData = data;     /* save completion routine data pointer */
        adbWaitingCmd = adbOutputBuffer[2];     /* save wait command */
d1317 7
a1323 2
        if (adbWriteDelay != 1) {       /* start command now? */
                adbActionState = ADB_ACTION_OUT;        /* set next state */
d1325 2
a1326 2
                ADB_SET_STATE_ACTIVE(); /* tell ADB that we want to send */
                ADB_SET_STATE_ACKOFF(); /* make sure */
a1327 1
                ADB_SET_SR_OUTPUT();    /* set shift register for OUT */
d1329 1
a1329 20
                ADB_SR() = adbOutputBuffer[adbSentChars + 1];   /* load byte for output */

                ADB_SET_STATE_ACKON();  /* tell ADB byte ready to shift */
        }
        adbWriteDelay = 1;		/* something in the write "queue" */

        splx(s);

        if (0x0100 <= (s & 0x0700))     /* were VIA1 interrupts blocked ? */
                /* poll until byte done */
                while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
                    || (adbWaiting == 1))
                        if (ADB_SR_INTR_IS_ON)  /* wait for "interrupt" */
                                adb_intr_IIsi();     /* go process "interrupt" */

        return 0;
}                               /* send_adb_IIsi */


/* 
d1333 2
a1334 1
void adb_comp_exec(void)
d1336 25
a1360 23
	if ( (long)0 != adbCompRout )			/* don't call if empty return location */
		#if defined(__NetBSD__) || defined(__OpenBSD__)
		asm ( "
			movml   #0xffff, sp@@-   | save all registers
			movl    %0,a2       	| adbCompData
			movl    %1,a1       	| adbCompRout
			movl    %2,a0       	| adbBuffer
			movl    %3,d0       	| adbWaitingCmd
			jbsr    a1@@     	| go call the routine
			movml   sp@@+, #0xffff   | restore all registers"
			:  : "g" (adbCompData), "g" (adbCompRout), "g" (adbBuffer), "g" (adbWaitingCmd) );
		#else					/* for macos based testing */
		asm 
			{
			movem.l	a0/a1/a2/d0,-(a7)
			move.l	adbCompData,a2
			move.l	adbCompRout,a1
			move.l	adbBuffer,a0
			move.w	adbWaitingCmd,d0
			jsr		(a1)
			movem.l	(a7)+,d0/a2/a1/a0
			}
		#endif
d1362 1
a1362 1
	
d1365 9
a1373 3
 * this routine handles what needs to be done after a message is read 
 * from the adb data points to the raw data received from the device, 
 * including device number (on IIsi) and result code.
d1375 2
a1376 2
void 
adb_handle_unsol(u_char *in)
d1378 18
a1395 2
        int     i, cmd;
        u_char	data[MAX_ADB_MSG_LENGTH];
d1397 20
a1416 36
	/* make local copy so we don't destroy the real one - it may
	 * be needed later. */
        for (i = 0; i <= (in[0] + 1); i++)
        	data[i] = in[i];
	
        switch (adbHardware) {
        case ADB_HW_II:
                /* adjust the "length" byte */
                cmd = data[1];
                if (data[0] < 2)
                        data[1] = 0;
                else
                        data[1] = data[0] - 1;

                adb_complete((data + 1), (long) 0, cmd);

                break;

        case ADB_HW_IISI:
        case ADB_HW_CUDA:
                /* only handles ADB for now */
                if (0 != *(data + 2))
                        return;

                /* adjust the "length" byte */
                cmd = data[4];
                if (data[0] < 5)
                        data[4] = 0;
                else
                        data[4] = data[0] - 4;

                adb_complete((data + 4), (long) 0, cmd);

                break;
                
        case ADB_HW_PB:
d1419 36
a1454 11
        case ADB_HW_UNKNOWN:
                return;
        }

        return;

#if 0
        /* this should really be used later, once it is set up properly */
        /* AND we need to make sure that we DON'T call it if it is zero! */
        if ( 0 != ADBDevTable[i].devType )
                (*(ADBDevTable[i].ServiceRtPtr))();
d1456 2
d1465 1
a1465 1
 *   data 		: pointer to data area to be used by compRout
d1467 3
a1469 2
 *   buffer		: for LISTEN: points to data to send - MAX 8 data bytes, byte 0 = # of bytes
 *				: for TALK: points to place to save return data
a1470 1
 
d1474 1
a1474 1
int 
d1477 1
a1477 1
        int     result;
d1479 15
a1493 11
        switch (adbHardware) {
        case ADB_HW_II:
                result = send_adb_II((u_char *) 0,
                    (u_char *) buffer, (void *) compRout,
                    (void *) data, (int) command);
                break;

        case ADB_HW_IISI:
                result = send_adb_IIsi((u_char *) 0, 
                    (u_char *) buffer, (void *) compRout,
                    (void *) data, (int) command);
d1496 1
a1496 1
		 * be here when several commands are sent in close succession, 
d1501 4
d1507 8
a1514 13
        case ADB_HW_PB:
 		result = pm_adb_op((u_char *)buffer, (void *)compRout,
 		    (void *)data, (int)command);
 		if (result == 0)
 			return 0;
 		else
 			return -1;
                break;

        case ADB_HW_CUDA:
                result = send_adb_cuda((u_char *) 0, 
                    (u_char *) buffer, (void *) compRout,
                    (void *) data, (int) command);
d1517 11
a1527 1
        case ADB_HW_UNKNOWN:
d1529 2
a1530 6
                return -1;
        }
        if (result == 0)
             return 0;
        else
             return -1;
d1538 2
a1539 2
void 
adb_cleanup(u_char *in)
d1541 39
a1579 24
        switch (adbHardware) {
        case ADB_HW_II:
                ADB_VIA_CLR_INTR();     /* clear interrupt */
                break;

        case ADB_HW_IISI:
                /* get those pesky clock ticks we missed while booting */
                adb_cleanup_IIsi(in);
                break;

        case ADB_HW_PB:
		/* TO DO: really PM_VIA_CLR_INTR - should we put it in pm_direct.h? */
                via_reg(VIA1, vIFR) = 0x90;   /* clear interrupt */
                break;

        case ADB_HW_CUDA:
        	/* TO DO: probably need some sort of cleanup for Cuda */
		ADB_VIA_CLR_INTR();
		ADB_SET_STATE_IDLE_CUDA();
                break;

        case ADB_HW_UNKNOWN:
                return;
        }
d1581 3
a1583 3
	
	
/* 
d1590 2
a1591 2
void 
adb_cleanup_IIsi(u_char *buffer)
d1593 50
a1642 44
        int     i;
        int     dummy;
        int     s;
        long    my_time;
        int     endofframe;

        delay(ADB_ACK_DELAY);

        i = 1;                  /* skip over [0] */
        s = splhigh();          /* block ALL interrupts while we are working */
        ADB_SET_SR_INPUT();     /* make sure SR is set to IN */
        ADB_VIA_INTR_DISABLE(); /* disable ADB interrupt on IIs. */
        /* this is required, especially on faster machines */
        delay(ADB_ACK_DELAY);

        if (ADB_INTR_IS_ON) {
                ADB_SET_STATE_ACTIVE(); /* signal start of data frame */

                endofframe = 0;
                while (0 == endofframe) {
                        /* poll for ADB interrupt and watch for timeout */
                        /* if time out, keep going in hopes of not hanging the ADB chip - I think */
                        my_time = ADB_ACK_DELAY * 5;
                        while ((ADB_SR_INTR_IS_OFF) && (my_time-- > 0))
                                dummy = via_reg(VIA1, vBufB);

                        buffer[i++] = ADB_SR(); /* reset interrupt flag by reading vSR */
                        /* perhaps put in a check here that ignores all data
                         * after the first MAX_ADB_MSG_LENGTH bytes ??? */
                        if (ADB_INTR_IS_OFF)    /* check for end of frame */
                                endofframe = 1;

                        ADB_SET_STATE_ACKON();  /* send ACK to ADB chip */
                        delay(ADB_ACK_DELAY);   /* delay */
                        ADB_SET_STATE_ACKOFF(); /* send ACK to ADB chip */
                }
                ADB_SET_STATE_INACTIVE();       /* signal end of frame and delay */

                /* probably don't need to delay this long */
                delay(ADB_ACK_DELAY);
        }
        buffer[0] = --i;        /* [0] is length of message */
        ADB_VIA_INTR_ENABLE();  /* enable ADB interrupt on IIs. */
        splx(s);                /* restore interrupts */
a1643 2
        return;
}                               /* adb_cleanup_IIsi */
d1650 1
a1650 1
void 
d1653 8
a1660 8
    u_char send_string[MAX_ADB_MSG_LENGTH];
    int    s;
    int    i, x;
    int    command;
    int    result;
	int	saveptr;	/* point to next free relocation address */
	int	device;
	int	nonewtimes;	/* times thru loop w/o any new devices */
d1663 1
a1663 1
	(void)(&s);		/* XXX workaround gcc bug */
d1665 32
a1696 2
        /* Make sure we are not interrupted while building the table. */
       	s = splhigh();
d1698 14
a1711 1
        ADBNumDevices = 0;	/* no devices yet */
d1713 20
a1732 48
        /* Let intr routines know we are running reinit */
        adbStarting = 1;

        /* Initialize the ADB table.  For now, we'll always use the same
         * table that is defined at the beginning of this file - no mallocs.
         */
        for (i = 0; i < 16; i++)
                ADBDevTable[i].devType = 0;

        adb_setup_hw_type();			/* setup hardware type */

        /* Set up all the VIA bits we need to do the ADB stuff.
         */
        switch (adbHardware) {
       	case ADB_HW_II:
        	via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5: outputs */
        	via_reg(VIA1, vDirB) &= 0xf7;   /* register B bit 3: input */
        	via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set to IN (II, IIsi) */
        	adbActionState = ADB_ACTION_IDLE;	/* used by all types of hardware (II, IIsi) */
        	adbBusState = ADB_BUS_IDLE;     /* this var. used in II-series code only */
        	via_reg(VIA1, vIER) = 0x84;     /* make sure VIA interrupts are on (II, IIsi) */
                ADB_SET_STATE_IDLE_II();        /* set ADB bus state to idle */
               	break;

       	case ADB_HW_IISI:
        	via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5: outputs */
        	via_reg(VIA1, vDirB) &= 0xf7;   /* register B bit 3: input */
        	via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set to IN (II, IIsi) */
        	adbActionState = ADB_ACTION_IDLE;	/* used by all types of hardware (II, IIsi) */
        	adbBusState = ADB_BUS_IDLE;     /* this var. used in II-series code only */
        	via_reg(VIA1, vIER) = 0x84;     /* make sure VIA interrupts are on (II, IIsi) */
                ADB_SET_STATE_IDLE_IISI();      /* set ADB bus state to idle */
               	break;

       	case ADB_HW_PB:
		break;				/* there has to be more than this? */

        case ADB_HW_CUDA:
        	via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5: outputs */
        	via_reg(VIA1, vDirB) &= 0xf7;   /* register B bit 3: input */
        	via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set to IN */
        	adbActionState = ADB_ACTION_IDLE;	/* used by all types of hardware */
        	adbBusState = ADB_BUS_IDLE;     /* this var. used in II-series code only */
        	via_reg(VIA1, vIER) = 0x84;     /* make sure VIA interrupts are on */
                ADB_SET_STATE_IDLE_CUDA();      /* set ADB bus state to idle */
                break;
                
        case ADB_HW_UNKNOWN:			/* if type unknown then skip out */
d1734 3
a1736 2
               	via_reg(VIA1, vIER) = 0x04;     /* turn interrupts off - TO DO: turn PB ints off? */
               	return;
d1738 1
a1738 1
        }
d1740 4
a1743 38
        /*
         * Clear out any "leftover" commands.  Remember that up until this
         * point, the interrupt routine will be either off or it should be
         * able to ignore inputs until the device table is built.
         */
        for (i = 0; i < 30; i++) {
                delay(ADB_ACK_DELAY);
                adb_cleanup(send_string);
                printf("adb: cleanup: ");
                print_single(send_string);
                delay(ADB_ACK_DELAY);
                if (ADB_INTR_IS_OFF)
                        break;
        }

        /* send an ADB reset first */
        adb_op_sync((Ptr) 0, (Ptr) 0, (Ptr) 0, (short) 0x00);

	/* 
	 * Probe for ADB devices.
	 * Probe devices 1-15 quickly to determine which
	 * device addresses are in use and which are free.
	 * For each address that is in use, move the device
	 * at that address to a higher free address. 
	 * Continue doing this at that address until 
	 * no device responds at that address. Then move 
	 * the last device that was moved back to the 
	 * original address. Do this for the remaining
	 * addresses that we determined were in use.
	 *
	 * When finished, do this entire process over again
	 * with the updated list of in use addresses. Do this
	 * until no new devices have been found in 20 passes
	 * though the in use address list.
	 * (This probably seems long and complicated, but it's
	 * the best way to detect multiple devices at the
	 * same address - sometimes it takes a couple of tries
	 * before the collision is detected.)
d1745 28
a1772 1
	 
d1774 1
a1774 1
	for ( i=1; i<16; i++) {
d1777 1
a1777 1
		if (0x00 != send_string[0]) {   /* anything come back ?? */
d1783 4
a1786 2
			/*printf("initial device found (at index %d)\n", ADBNumDevices);*/
			pm_check_adb_devices(i);
d1789 1
a1789 1
	
d1791 2
a1792 2
	for ( saveptr=15; saveptr>0; saveptr-- )
		if ( -1 == get_adb_info(&data, saveptr) )
d1794 13
a1806 12
		
	if ( saveptr==0 )	/* no free addresses??? */
		saveptr=15;
	
	/*printf("first free is: 0x%02x\n", saveptr);*/
	/*printf("devices: %d\n", ADBNumDevices);*/
	
	nonewtimes=0;		/* no loops w/o new devices */
	while ( nonewtimes++ < 11 ) {
		for ( i=1; i <= ADBNumDevices; i++ ) {
			device=ADBDevTable[i].currentAddr;
			/*printf("moving device 0x%02x to 0x%02x (index 0x%02x)  ", device, saveptr, i);*/
d1811 1
a1811 1
			
d1813 6
a1818 6
	        	command = (int) (0x0b | ((int) (device & 0x000f) << 4));
	        	send_string[0]=2;
	        	send_string[1]=(u_char) (saveptr | 0x60 );
	        	send_string[2]=0xfe;
                	adb_op_sync((Ptr) send_string, (Ptr) 0, (Ptr) 0, (short) command);
		
d1822 1
a1822 1
			if ( send_string[0] != 0 ) {
d1825 2
a1826 2
				ADBDevTable[i].currentAddr=saveptr;
				/*printf("old device at index %d\n",i);*/
d1828 1
a1828 1
				/*printf("new device found\n");*/
d1832 2
d1837 3
a1839 3
				for ( x=saveptr; x>0; x-- )
					if ( -1 == get_adb_info(&data, x) ) {
						saveptr=x;
d1842 5
a1846 2
				/*printf("new free is 0x%02x\n", saveptr);*/
				nonewtimes=0;
d1848 1
a1848 1
				/*printf("moving back...\n");*/
d1850 5
a1854 5
	        		command = (int) (0x0b | ((int) (saveptr & 0x000f) << 4));
	        		send_string[0]=2;
	        		send_string[1]=(u_char) (device | 0x60 );
	        		send_string[2]=0xfe;
                		adb_op_sync((Ptr) send_string, (Ptr) 0, (Ptr) 0, (short) command);
d1859 8
a1866 1
        adb_prog_switch_enable();       /* enable the programmer's switch, if we have one */
d1868 2
a1869 2
        if (0 == ADBNumDevices)         /* tell user if no devices found */
                printf("adb: no devices found\n");
d1871 2
a1872 2
        adbStarting = 0;        /* not starting anymore */
        printf("adb: ADBReInit complete\n");
d1874 2
a1875 1
        splx(s);
d1877 3
a1879 1
        return;
d1889 2
a1890 2
int 
adb_cmd_result(u_char *in)
d1892 8
a1899 8
        switch (adbHardware) {
        case ADB_HW_II:
        	/* was it an ADB talk command? */
                if ((in[1] & 0x0c) == 0x0c)
                        return 0;
                else
                        return 1;
                break;
d1901 2
a1902 2
        case ADB_HW_IISI:
        case ADB_HW_CUDA:
d1904 9
a1912 13
                if ((in[1] == 0x00) && ((in[2] & 0x0c) == 0x0c))
                	return 0;
                else
                	/* was is an RTC/PRAM read date/time? */
                        if ((in[1] == 0x01) && (in[2] == 0x03)) 
                                return 0;
                        else
                                return 1;
                break;

        case ADB_HW_PB:
                return 1;
                break;
d1914 5
a1918 1
        case ADB_HW_UNKNOWN:
d1920 2
a1921 2
                return 1;
        }
d1931 2
a1932 2
int 
adb_cmd_extra(u_char *in)
d1934 21
a1954 21
        switch (adbHardware) {
        case ADB_HW_II:
                if ((in[1] & 0x0c) == 0x08)     /* was it a listen command? */
                        return 0;
                else
                        return 1;
                break;

        case ADB_HW_IISI:
        case ADB_HW_CUDA:
                /* TO DO: support needs to be added to recognize RTC
                 * and PRAM commands */
                if ((in[2] & 0x0c) == 0x08)     /* was it a listen command? */
                        return 0;
                else    /* add others later */
                        return 1;
                break;

        case ADB_HW_PB:
                return 1;
                break;
d1956 1
a1956 1
        case ADB_HW_UNKNOWN:
d1958 2
a1959 2
                return 1;
        }
d1967 1
a1967 1
int 
d1970 2
a1971 2
        int     result;
        volatile int     flag;
d1973 7
a1979 12
        flag = 0;
        result = adb_op(buffer, (void *) adb_op_comprout,
            (void *) &flag, command);   /* send command */
        if (result == 0) {              /* send ok? */
                /* Don't need to use adb_cmd_result since this section is
                 * hardware independent, and for ADB commands only (no RTC or PRAM) */
                /*if ((command & 0x0c) == 0x0c)   was it a talk? */
                        while (0 == flag) ;

                return 0;
        } else
                return result;
d1984 1
a1984 1
 * This function is used by the adb_op_sync routine so it knows when the function is 
d1987 2
a1988 1
void adb_op_comprout(void)
d1990 6
a1995 5
	#if defined(__NetBSD__) || defined(__OpenBSD__)
    	asm ( "movw    #1,a2@@			| update flag value" );
	#else					/* for macos based testing */
	asm	{ move.w #1,(a2) }		/* update flag value */
	#endif
d2001 1
a2001 1
        long    response;
d2003 1
a2003 1
        response = mac68k_machine.machineid;
d2005 71
a2075 69
        switch (response) {
        case 6:         /* II */
        case 7:         /* IIx */
        case 8:         /* IIcx */
        case 9:         /* SE/30 */
        case 11:        /* IIci */
        case 22:        /* Quadra 700 */
        case 30:        /* Centris 650 */
        case 35:        /* Quadra 800 */
        case 36:        /* Quadra 650 */
        case 52:        /* Centris 610 */
        case 53:        /* Centris 650 */
                adbHardware = ADB_HW_II;
                printf("adb: using II series hardware support\n");
                break;
        case 18:        /* IIsi */
        case 20:        /* Quadra 900 - not sure if IIsi or not */
        case 23:        /* Classic II */
        case 26:        /* Quadra 950 - not sure if IIsi or not */
        case 27:        /* LC III, Performa 450 */
        case 37:        /* LC II, Performa 400/405/430 */
        case 44:        /* IIvi */
        case 45:        /* Performa 600 */
        case 48:        /* IIvx */
        case 49:        /* Color Classic - not sure if IIsi or not */
        case 62:        /* Performa 460/465/467 */
        case 83:        /* Color Classic II (number right?) - not sure if IIsi or not */
                adbHardware = ADB_HW_IISI;
                printf("adb: using IIsi series hardware support\n");
                break;
        case 21:        /* PowerBook 170 */
        case 25:        /* PowerBook 140 */
        case 54:        /* PowerBook 145 */
        case 34:        /* PowerBook 160 */
        case 84:        /* PowerBook 165 */
        case 50:        /* PowerBook 165c */
        case 33:        /* PowerBook 180 */
        case 71:        /* PowerBook 180c */
        case 115:       /* PowerBook 150 */
                adbHardware=ADB_HW_PB;
                pm_setup_adb();
                printf("adb: using PowerBook 100-series hardware support\n");
                break;
        case 29:        /* PowerBook Duo 210 */
        case 32:        /* PowerBook Duo 230 */
        case 38:        /* PowerBook Duo 250 */
        case 72:        /* PowerBook 500 series */
        case 77:        /* PowerBook Duo 270 */
        case 102:       /* PowerBook Duo 280 */
        case 103:       /* PowerBook Duo 280c */
                adbHardware=ADB_HW_PB;
                pm_setup_adb();
		printf("adb: using PowerBook Duo-series and PowerBook 500-series hardware support\n");
                break;
        case 60:        /* Centris 660AV */
        case 78:        /* Quadra 840AV */
        case 89:        /* LC 475, Performa 475/476 */
        case 92:        /* LC 575, Performa 575/577/578 */
        case 94:        /* Quadra 605 */
        case 98:        /* LC 630, Performa 630, Quadra 630 */
                adbHardware = ADB_HW_CUDA;
                printf("adb: using Cuda series hardware support\n");
                break;
        default:
                adbHardware = ADB_HW_UNKNOWN;
                printf("adb: hardware type unknown for this machine\n");
                printf("adb: ADB support is disabled\n");
                break;
        }
d2081 2
a2082 2
        int     i;
        int     found;
d2084 1
a2084 1
        found = 0;
d2086 3
a2088 3
        for (i = 1; i < 16; i++)
                if (0 != ADBDevTable[i].devType)
                        found++;
d2090 1
a2090 1
        return found;
d2096 2
a2097 2
        if ((index < 1) || (index > 15))        /* check range 1-15 */
                return (-1);
d2099 9
a2107 9
        /* printf("index 0x%x devType is: 0x%x\n", index,
            ADBDevTable[index].devType); */
        if (0 == ADBDevTable[index].devType)    /* make sure it's a valid entry */
                return (-1);

        info->devType = ADBDevTable[index].devType;
        info->origADBAddr = ADBDevTable[index].origAddr;
        info->dbServiceRtPtr = (Ptr) ADBDevTable[index].ServiceRtPtr;
        info->dbDataAreaAddr = (Ptr) ADBDevTable[index].DataAreaAddr;
d2109 1
a2109 1
        return (ADBDevTable[index].currentAddr);
d2115 1
a2115 1
        int     i;
d2117 2
a2118 2
        if ((adbAddr < 1) || (adbAddr > 15))    /* check range 1-15 */
                return (-1);
d2120 8
a2127 8
        for (i = 1; i < 15; i++)
                if (ADBDevTable[i].currentAddr == adbAddr) {
                        info->devType = ADBDevTable[i].devType;
                        info->origADBAddr = ADBDevTable[i].origAddr;
                        info->dbServiceRtPtr = (Ptr)ADBDevTable[i].ServiceRtPtr;
                        info->dbDataAreaAddr = ADBDevTable[i].DataAreaAddr;
                        return 0;       /* found */
                }
d2129 1
a2129 1
        return (-1);            /* not found */
d2135 1
a2135 1
        int     i;
d2137 2
a2138 2
        if ((adbAddr < 1) || (adbAddr > 15))    /* check range 1-15 */
                return (-1);
d2140 7
a2146 7
        for (i = 1; i < 15; i++)
                if (ADBDevTable[i].currentAddr == adbAddr) {
                        ADBDevTable[i].ServiceRtPtr =
                            (void *) (info->siServiceRtPtr);
                        ADBDevTable[i].DataAreaAddr = info->siDataAreaAddr;
                        return 0;       /* found */
                }
d2148 1
a2148 1
        return (-1);            /* not found */
d2156 1
a2156 1
        adb_intr();
d2173 17
a2189 17
        u_char output[MAX_ADB_MSG_LENGTH];
        int     result;
        volatile int     flag = 0;

        switch (adbHardware) {
        case ADB_HW_II:
                return -1;

        case ADB_HW_IISI:
                output[0] = 0x02;       /* 2 byte message */
                output[1] = 0x01;       /* to pram/rtc device */
                output[2] = 0x03;       /* read date/time */
                result = send_adb_IIsi((u_char *) output,
                    (u_char *) output, (void *) adb_op_comprout,
                    (void *) &flag, (int) 0);
                if (result != 0)        /* exit if not sent */
                        return -1;
d2191 2
a2192 1
                while (0 == flag) ;     /* wait for result */
d2194 2
a2195 2
                *time = (long) (*(long *) (output + 1));
                return 0;
d2197 2
a2198 2
        case ADB_HW_PB:
                return -1;
d2201 19
a2219 18
                output[0] = 0x02;       /* 2 byte message */
                output[1] = 0x01;       /* to pram/rtc device */
                output[2] = 0x03;       /* read date/time */
                result = send_adb_cuda((u_char *) output,
                    (u_char *) output, (void *) adb_op_comprout,
                    (void *) &flag, (int) 0);
                if (result != 0)        /* exit if not sent */
                        return -1;

                while (0 == flag) ;     /* wait for result */

                *time = (long) (*(long *) (output + 1));
                return 0;

        case ADB_HW_UNKNOWN:
        default:
                return -1;
        }
d2227 3
a2229 3
        u_char output[MAX_ADB_MSG_LENGTH];
        int     result;
        volatile int     flag = 0;
d2231 2
a2232 2
        switch (adbHardware) {
        case ADB_HW_II:
d2235 13
a2247 13
        case ADB_HW_IISI:
                output[0] = 0x06;       /* 6 byte message */
                output[1] = 0x01;       /* to pram/rtc device */
                output[2] = 0x09;       /* set date/time */
                output[3] = (u_char) (time >> 24);
                output[4] = (u_char) (time >> 16);
                output[5] = (u_char) (time >> 8);
                output[6] = (u_char) (time);
                result = send_adb_IIsi((u_char *) output,
                    (u_char *) 0, (void *) adb_op_comprout,
                    (void *) &flag, (int) 0);
                if (result != 0)        /* exit if not sent */
                        return -1;
d2249 2
a2250 1
                while (0 == flag) ;     /* wait for send to finish */
d2252 1
a2252 1
                return 0;
d2254 2
a2255 2
        case ADB_HW_PB:
                return -1;
d2258 12
a2269 12
                output[0] = 0x06;       /* 6 byte message */
                output[1] = 0x01;       /* to pram/rtc device */
                output[2] = 0x09;       /* set date/time */
                output[3] = (u_char) (time >> 24);
                output[4] = (u_char) (time >> 16);
                output[5] = (u_char) (time >> 8);
                output[6] = (u_char) (time);
                result = send_adb_cuda((u_char *) output,
                    (u_char *) 0, (void *) adb_op_comprout,
                    (void *) &flag, (int) 0);
                if (result != 0)        /* exit if not sent */
                        return -1;
d2271 2
a2272 1
                while (0 == flag) ;     /* wait for send to finish */
d2274 1
a2274 1
                return 0;
d2276 1
a2276 1
        case ADB_HW_UNKNOWN:
d2278 2
a2279 2
                return -1;
        }
d2286 2
a2287 2
        u_char output[MAX_ADB_MSG_LENGTH];
        int     result;
d2289 9
a2297 9
        switch (adbHardware) {
        case ADB_HW_IISI:
                output[0] = 0x02;       /* 2 byte message */
                output[1] = 0x01;       /* to pram/rtc/soft-power device */
                output[2] = 0x0a;       /* set date/time */
                result = send_adb_IIsi((u_char *) output,
                    (u_char *) 0, (void *) 0, (void *) 0, (int) 0);
                if (result != 0)        /* exit if not sent */
                        return -1;
d2299 1
a2299 1
                for (;;) ;		/* wait for power off */
d2301 1
a2301 1
                return 0;
d2303 2
a2304 2
        case ADB_HW_PB:
                return -1;
d2307 1
a2307 1
        case ADB_HW_II:			/* II models don't do soft power */
d2309 1
a2309 1
        case ADB_HW_UNKNOWN:
d2311 3
a2313 3
                return -1;
        }
}                               /* adb_poweroff */
d2318 27
a2344 26
        u_char output[MAX_ADB_MSG_LENGTH];
        int     result;
        volatile int     flag = 0;

        switch (adbHardware) {
        case ADB_HW_IISI:
                output[0] = 0x03;       /* 3 byte message */
                output[1] = 0x01;       /* to pram/rtc/soft-power device */
                output[2] = 0x1c;       /* prog. switch control */
                output[3] = 0x01;       /* enable */
                result = send_adb_IIsi((u_char *) output,
                    (u_char *) 0, (void *) adb_op_comprout,
                    (void *) &flag, (int) 0);
                if (result != 0)        /* exit if not sent */
                        return -1;

                while (0 == flag) ;     /* wait for send to finish */

                return 0;

        case ADB_HW_PB:
                return -1;

        case ADB_HW_II:		/* II models don't do prog. switch */
        case ADB_HW_CUDA:	/* cuda doesn't do prog. switch */
        case ADB_HW_UNKNOWN:
d2346 3
a2348 3
                return -1;
        }
}                               /* adb_prog_switch_enable */
d2353 27
a2379 26
        u_char output[MAX_ADB_MSG_LENGTH];
        int     result;
        volatile int     flag = 0;

        switch (adbHardware) {
        case ADB_HW_IISI:
                output[0] = 0x03;       /* 3 byte message */
                output[1] = 0x01;       /* to pram/rtc/soft-power device */
                output[2] = 0x1c;       /* prog. switch control */
                output[3] = 0x01;       /* disable */
                result = send_adb_IIsi((u_char *) output,
                    (u_char *) 0, (void *) adb_op_comprout,
                    (void *) &flag, (int) 0);
                if (result != 0)        /* exit if not sent */
                        return -1;

                while (0 == flag) ;     /* wait for send to finish */

                return 0;

        case ADB_HW_PB:
                return -1;

        case ADB_HW_II:		/* II models don't do prog. switch */
        case ADB_HW_CUDA:	/* cuda doesn't do prog. switch */
        case ADB_HW_UNKNOWN:
d2381 3
a2383 3
                return -1;
        }
}                               /* adb_prog_switch_disable */
d2390 1
a2390 1
        return (count_adbs());
d2396 1
a2396 1
        adb_reinit();
d2402 1
a2402 1
        return (get_ind_adb_info(info, index));
d2408 1
a2408 1
        return (get_adb_info(info, adbAddr));
d2414 1
a2414 1
        return (set_adb_info(info, adbAddr));
d2420 1
a2420 1
        return (adb_op(buffer, compRout, data, commandNum));
d2424 1
@


1.5
log
@Bring our incarnation of John Wittowski's direct adb driver into compatible
state with NetBSD's.  The direct-to-ADB code is now enabled by default.
Using 'options MRG_ADB' will cause the kernel to revert to the 'old standby'
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.4 1997/04/07 01:22:15 briggs Exp $	*/
d149 4
a152 4
        u_char outBuf[MAX_ADB_MSG_LENGTH];	/* our message */
        u_char *saveBuf;        /* buffer to know where to save result */
        u_char *compRout;	/* completion routine pointer */
        u_char *data;		/* completion routine data pointer */
d193 2
a194 1
extern int zshard(int);
d200 28
a227 28
void print_single __P((unsigned char *));
void adb_intr __P((void));
void adb_intr_II __P((void));
void adb_intr_IIsi __P((void));
void adb_intr_cuda __P((void));
int send_adb_II __P((unsigned char *, unsigned char *, void *, void *, int));
int send_adb_IIsi __P((unsigned char *, unsigned char *, void *, void *, int));
int send_adb_cuda __P((unsigned char *, unsigned char *, void *, void *, int));
void adb_handle_unsol __P((unsigned char *));
void adb_op_comprout __P((void));
void adb_reinit __P((void));
int count_adbs __P((void));
int get_ind_adb_info __P((ADBDataBlock *, int));
int get_adb_info __P((ADBDataBlock *, int));
int set_adb_info __P((ADBSetInfoBlock *, int));
void adb_setup_hw_type __P((void));
int adb_op __P((Ptr, Ptr, Ptr, short));
void adb_handle_unsol __P((unsigned char *));
int adb_op_sync __P((Ptr, Ptr, Ptr, short));
void adb_read_II __P((unsigned char *));
void adb_cleanup __P((unsigned char *));
void adb_cleanup_IIsi __P((unsigned char *));
void adb_comp_exec __P((void));
int adb_cmd_result __P((unsigned char *));
int adb_cmd_extra __P((unsigned char *));
int adb_guess_next_device __P((void));
int adb_prog_switch_enable __P((void));
int adb_prog_switch_disable __P((void));
d229 1
a229 1
int send_adb __P((unsigned char *, void *, void *));
d1293 1
d1348 6
a1353 3
		result = pm_adb_op(
                    (u_char *) buffer, (void *) compRout,
                    (void *) data, (int) command);
d1483 2
d1488 1
a1488 1
        ADBNumDevices=0;	/* no devices yet */
@


1.4
log
@Fix m68k/153 as suggested by David Leonard <d@@occult.fnarg.net.au>.
Fix a couple more, similar, bugs while I'm here to save David the
trouble of reporting them, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.3 1997/03/31 12:59:11 briggs Exp $	*/
d1939 1
a1939 1
#ifdef HWDIRECT
d2166 1
a2166 1
#ifdef HWDIRECT
@


1.3
log
@PR#140, Fix from David Leonard <d@@occult.fnarg.net.au>.  Prevents endless loop
for Egret and Cuda ADB.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.2 1997/03/29 17:26:59 briggs Exp $	*/
d1757 1
a1757 1
        int     flag;
d2014 1
a2014 1
        int     flag = 0;
d2103 1
a2103 1
        int     flag = 0;
d2137 1
a2137 1
        int     flag = 0;
@


1.2
log
@__NetBSD__ -> __NetBSD__ || __OpenBSD__ (conditionals for compiling in MacOS).
@
text
@d1 1
a1 1
/*	$OpenBSD: adb_direct.c,v 1.1 1997/02/23 06:04:52 briggs Exp $	*/
d1962 1
a1962 1
        int     flag = 0;
@


1.1
log
@Integrate code from John P. Wittkoski <jpw@@netwizards.net> and
Takashi Hamada <hamada@@next.etron.kanazawa-it.ac.jp>.  This code
interfaces directly to the hardware to support the ADB on many
macs.  It is enabled by "options HWDIRECT" in the configuration
file.  At some point, this should probably become the default method
as interfacing to the ADB through the ROMs has been painful and sometimes
problematic.

This code should have functioning ADB support for:
	II series (II, SE/30, IIx, IIcx)
	IIsi series (IIsi, IIci, IIvx, IIvi)
	LC II, LC III
	Performa 400, 405, 430, 460, 465, 467, 600
	Classic II, Color Classic, Color Classic II
	PB 5XX series
	Duo series
	PB 140,145,145b,160,(160c?),165,165c,170,180,180c
	Quadra 700,900,950
There is an off-chance that it will work on:
	PB 150, PB 190
	Quadra/Centris 605,610,630,650,660AV,800,840AV
	LC 475,550,575,630
	Performa 475,476,575,577,578,630
Note that functioning ADB support does not mean that everything else
will work.  I obviously do not own all of the above machines (does
anyone?  ;-)...  Any reports are welcome.

Many thanks to John Wittkoski and Takashi Hamada!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1219 1
a1219 1
		#ifdef __NetBSD__
d1780 1
a1780 1
	#ifdef __NetBSD__
@
