head	1.56;
access;
symbols
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.4
	OPENBSD_5_0:1.55.0.2
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.54.0.4
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.54.0.2
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.50.0.2
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.47.0.4
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.4
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.45.0.2
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.33.0.8
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.33.0.6
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.4
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.32
	UBC:1.30.0.2
	UBC_BASE:1.30
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_9_BASE:1.27
	NIKLAS_UNDEAD:1.26.0.2
	OPENBSD_2_8:1.25.0.8
	OPENBSD_2_8_BASE:1.25
	OPENBSD_2_7:1.25.0.6
	OPENBSD_2_7_BASE:1.25
	SMP:1.25.0.4
	SMP_BASE:1.25
	kame_19991208:1.25
	OPENBSD_2_6:1.25.0.2
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.24.0.2
	OPENBSD_2_5_BASE:1.24
	OPENBSD_2_4:1.23.0.6
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.23.0.4
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.23.0.2
	OPENBSD_2_2_BASE:1.23
	OPENBSD_2_1:1.22.0.2
	OPENBSD_2_1_BASE:1.22
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.56
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.55;

1.55
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2010.03.31.19.46.27;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2009.04.14.16.01.04;	author oga;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2008.10.08.23.53.08;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.04.17.55.15;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.12.16.31.21;	author martin;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.24.13.23.27;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.16.20.37.23;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.14.09.36.49;	author martin;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.23.18.51.37;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.23.04.17.23;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.23.03.59.58;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.23.23.28.58;	author martin;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.22.19.40.51;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2005.01.04.19.53.37;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.19.17.25.42;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.22.20.15.55;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.07.04.08.52.45;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.16.12.49.46;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.20.19.39.31;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.10.15.33.06;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	99.05.13.15.44.49;	author jason;	state Exp;
branches
	1.25.4.1;
next	1.24;

1.24
date	99.01.11.05.11.34;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.06.18.02.59.27;	author denny;	state Exp;
branches;
next	1.22;

1.22
date	97.04.25.03.29.15;	author briggs;	state Exp;
branches;
next	1.21;

1.21
date	97.04.18.11.58.34;	author briggs;	state Exp;
branches;
next	1.20;

1.20
date	97.04.13.14.14.51;	author briggs;	state Exp;
branches;
next	1.19;

1.19
date	97.04.10.03.15.59;	author briggs;	state Exp;
branches;
next	1.18;

1.18
date	97.04.10.02.35.02;	author briggs;	state Exp;
branches;
next	1.17;

1.17
date	97.03.29.23.26.48;	author briggs;	state Exp;
branches;
next	1.16;

1.16
date	97.03.25.05.02.39;	author briggs;	state Exp;
branches;
next	1.15;

1.15
date	97.03.17.13.09.05;	author briggs;	state Exp;
branches;
next	1.14;

1.14
date	97.03.17.12.20.22;	author briggs;	state Exp;
branches;
next	1.13;

1.13
date	97.03.17.04.26.15;	author briggs;	state Exp;
branches;
next	1.12;

1.12
date	97.03.17.04.20.54;	author briggs;	state Exp;
branches;
next	1.11;

1.11
date	97.03.17.04.04.32;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.03.14.14.11.34;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.03.12.13.20.31;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	96.10.28.14.46.25;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.10.19.10.02.53;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.09.21.03.34.55;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.05.26.18.35.25;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.18.13.41;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.05.13.37.20;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.27.58;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	96.01.14.21.29.28;	author briggs;	state Exp;
branches;
next	;

1.25.4.1
date	2001.04.18.16.10.06;	author niklas;	state Exp;
branches;
next	1.25.4.2;

1.25.4.2
date	2001.07.04.10.18.26;	author niklas;	state Exp;
branches;
next	1.25.4.3;

1.25.4.3
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.25.4.4;

1.25.4.4
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.25.4.5;

1.25.4.5
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.25.4.6;

1.25.4.6
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.30.2.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.56
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*    $OpenBSD: if_sn.c,v 1.55 2011/04/07 15:30:15 miod Exp $        */
/*    $NetBSD: if_sn.c,v 1.13 1997/04/25 03:40:10 briggs Exp $        */

/*
 * National Semiconductor  DP8393X SONIC Driver
 * Copyright (c) 1991   Algorithmics Ltd (http://www.algor.co.uk)
 * You may use, copy, and modify this program so long as you retain the
 * copyright line.
 *
 * This driver has been substantially modified since Algorithmics donated
 * it.
 *
 *   Denton Gentry <denny1@@home.com>
 * and also
 *   Yanagisawa Takeshi <yanagisw@@aa.ap.titech.ac.jp>
 * did the work to get this running on the Macintosh.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/buf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_dl.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#include <uvm/uvm_extern.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

#include <machine/bus.h>
#include <machine/cpu.h>
/* #include <machine/viareg.h> */
#include <mac68k/dev/if_snreg.h>
#include <mac68k/dev/if_snvar.h>

static void	snwatchdog(struct ifnet *);
static int	sninit(struct sn_softc *);
static int	snstop(struct sn_softc *);
static int	snioctl(struct ifnet *, u_long, caddr_t);
static void	snstart(struct ifnet *);
static void	snreset(struct sn_softc *);

static void	caminitialise(struct sn_softc *);
static void	camentry(struct sn_softc *, int, u_char *);
static void	camprogram(struct sn_softc *);
static void	initialise_tda(struct sn_softc *);
static void	initialise_rda(struct sn_softc *);
static void	initialise_rra(struct sn_softc *);
#ifdef SNDEBUG
static void	camdump(struct sn_softc *);
#endif

static void	sonictxint(struct sn_softc *);
static void	sonicrxint(struct sn_softc *);

static __inline__ int	sonicput(struct sn_softc *, struct mbuf *,
			    int);
static __inline__ int	sonic_read(struct sn_softc *, caddr_t, int);
static __inline__ struct mbuf *sonic_get(struct sn_softc *, caddr_t, int);

struct cfdriver sn_cd = {
	NULL, "sn", DV_IFNET
};

/*
 * SONIC buffers need to be aligned 16 or 32 bit aligned.
 * These macros calculate and verify alignment.
 */
#define	ROUNDUP(p, N)	(((int) p + N - 1) & ~(N - 1))

#define SOALIGN(m, array)	(m ? (ROUNDUP(array, 4)) : (ROUNDUP(array, 2)))

#define LOWER(x) ((unsigned)(x) & 0xffff)
#define UPPER(x) ((unsigned)(x) >> 16)

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
int
snsetup(struct sn_softc *sc, u_int8_t *lladdr)
{
	struct ifnet *ifp = &sc->sc_if;
	struct pglist pglist;
	vm_page_t pg;
	paddr_t phys;
	vaddr_t	p, pp;
	int	i, offset, error;

	/*
	 * XXX if_sn.c is intended to be MI. Should it allocate memory
	 * for its descriptor areas, or expect the MD attach code
	 * to do that?
	 */
	TAILQ_INIT(&pglist);
	error = uvm_pglistalloc(SN_NPAGES * PAGE_SIZE, 0, -1,
	    PAGE_SIZE, 0, &pglist, 1, UVM_PLA_NOWAIT);
	if (error != 0) {
		printf(": could not allocate descriptor memory\n");
		return (error);
	}
	
	/*
	 * Map the pages uncached.
	 */
	sc->space = uvm_km_valloc(kernel_map, SN_NPAGES * PAGE_SIZE);
	if (sc->space == 0) {
		printf(": can't map descriptor memory\n");
		uvm_pglistfree(&pglist);
		return (ENOMEM);
	}

	phys = VM_PAGE_TO_PHYS(TAILQ_FIRST(&pglist));
	p = pp = sc->space;
	TAILQ_FOREACH(pg, &pglist, pageq) {
		pmap_enter_cache(pmap_kernel(), p, VM_PAGE_TO_PHYS(pg),
		    UVM_PROT_RW, UVM_PROT_RW | PMAP_WIRED, PG_CI);
		p += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
	p = pp;

	/*
	 * Put the pup in reset mode (sninit() will fix it later),
	 * stop the timer, disable all interrupts and clear any interrupts.
	 */
	NIC_PUT(sc, SNR_CR, CR_STP);
	wbflush();
	NIC_PUT(sc, SNR_CR, CR_RST);
	wbflush();
	NIC_PUT(sc, SNR_IMR, 0);
	wbflush();
	NIC_PUT(sc, SNR_ISR, ISR_ALL);
	wbflush();

	for (i = 0; i < NRRA; i++) {
		sc->p_rra[i] = (void *)p;
		sc->v_rra[i] = (p - sc->space) + phys;
		p += RXRSRC_SIZE(sc);
	}
	sc->v_rea = (p - sc->space) + phys;

	p = SOALIGN(sc, p);

	sc->p_cda = (void *)(p);
	sc->v_cda = (p - sc->space) + phys;
	p += CDA_SIZE(sc);

	p = SOALIGN(sc, p);

	for (i = 0; i < NTDA; i++) {
		struct mtd *mtdp = &sc->mtda[i];
		mtdp->mtd_txp = (void *)p;
		mtdp->mtd_vtxp = (p - sc->space) + phys;
		p += TXP_SIZE(sc);
	}

	p = SOALIGN(sc, p);

#ifdef DIAGNOSTIC
	if ((p - pp) > PAGE_SIZE) {
		printf (": sizeof RRA (%ld) + CDA (%ld) +"
		    "TDA (%ld) > PAGE_SIZE (%d). Punt!\n",
		    (ulong)sc->p_cda - (ulong)sc->p_rra[0],
		    (ulong)sc->mtda[0].mtd_txp - (ulong)sc->p_cda,
		    (ulong)p - (ulong)sc->mtda[0].mtd_txp,
		    PAGE_SIZE);
		return (EINVAL);
	}
#endif

	p = pp + PAGE_SIZE;
	pp = p;

	sc->sc_nrda = PAGE_SIZE / RXPKT_SIZE(sc);
	sc->p_rda = (caddr_t)p;
	sc->v_rda = (p - sc->space) + phys;

	p = pp + PAGE_SIZE;

	for (i = 0; i < NRBA; i++) {
		sc->rbuf[i] = (caddr_t)p;
		sc->rbuf_phys[i] = (p - sc->space) + phys;
		p += PAGE_SIZE;
	}

	pp = p;
	offset = 0;
	for (i = 0; i < NTDA; i++) {
		struct mtd *mtdp = &sc->mtda[i];

		mtdp->mtd_buf = (caddr_t)p;
		mtdp->mtd_vbuf = (p - sc->space) + phys;
		offset += TXBSIZE;
		if (offset < PAGE_SIZE - TXBSIZE) {
			p += TXBSIZE;
		} else {
			p = pp + PAGE_SIZE;
			pp = p;
			offset = 0;
		}
	}

#ifdef SNDEBUG
	camdump(sc);
#endif
	printf("address %s\n", ether_sprintf(lladdr));

#ifdef SNDEBUG
	printf("%s: buffers: rra=%p cda=%p rda=%p tda=%p\n",
	    sc->sc_dev.dv_xname, sc->p_rra[0], sc->p_cda,
	    sc->p_rda, sc->mtda[0].mtd_txp);
#endif

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	bcopy(lladdr, sc->sc_enaddr, ETHER_ADDR_LEN);

	ifp->if_softc = sc;
	ifp->if_ioctl = snioctl;
	ifp->if_start = snstart;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
	ifp->if_watchdog = snwatchdog;
	if_attach(ifp);
	ether_ifattach(ifp);

	return (0);
}

static int
snioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct sn_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *) data;
	int s, err = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			(void)sninit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif
		default:
			(void)sninit(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running,
			 * then stop it.
			 */
			snstop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped,
			 * then start it.
			 */
			(void)sninit(sc);
		} else {
			/*
			 * reset the interface to pick up any other changes
			 * in flags
			 */
			snreset(sc);
			snstart(ifp);
		}
		break;

	default:
		err = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (err == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			snreset(sc);
		err = 0;
	}

	splx(s);
	return (err);
}

/*
 * Encapsulate a packet of type family for the local net.
 */
static void
snstart(struct ifnet *ifp)
{
	struct sn_softc	*sc = ifp->if_softc;
	struct mbuf	*m;
	int		mtd_next;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

outloop:
	/* Check for room in the xmit buffer. */
	if ((mtd_next = (sc->mtd_free + 1)) == NTDA)
		mtd_next = 0;

	if (mtd_next == sc->mtd_hw) {
		ifp->if_flags |= IFF_OACTIVE;
		return;
	}

	IF_DEQUEUE(&ifp->if_snd, m);
	if (m == NULL)
		return;

	/* We need the header for m_pkthdr.len. */
	if ((m->m_flags & M_PKTHDR) == 0)
		panic("%s: snstart: no header mbuf", sc->sc_dev.dv_xname);

#if NBPFILTER > 0
	/*
	 * If bpf is listening on this interface, let it
	 * see the packet before we commit it to the wire.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

	/*
	 * If there is nothing in the o/p queue, and there is room in
	 * the Tx ring, then send the packet directly.  Otherwise append
	 * it to the o/p queue.
	 */
	if ((sonicput(sc, m, mtd_next)) > 0) {
	} else {
		IF_PREPEND(&ifp->if_snd, m);
		return;
	}

	sc->mtd_prev = sc->mtd_free;
	sc->mtd_free = mtd_next;

	ifp->if_opackets++;		/* # of pkts */

	/* Jump back for possibly more punishment. */
	goto outloop;
}

/*
 * reset and restart the SONIC.  Called in case of fatal
 * hardware/software errors.
 */
static void
snreset(struct sn_softc *sc)
{
	snstop(sc);
	sninit(sc);
}

static int
sninit(struct sn_softc *sc)
{
	u_long	s_rcr;
	int	s;

	if (sc->sc_if.if_flags & IFF_RUNNING)
		/* already running */
		return (0);

	s = splnet();

	NIC_PUT(sc, SNR_CR, CR_RST);	/* DCR only accessible in reset mode! */

	/* config it */
	NIC_PUT(sc, SNR_DCR, (sc->snr_dcr |
		(sc->bitmode ? DCR_DW32 : DCR_DW16)));
	NIC_PUT(sc, SNR_DCR2, sc->snr_dcr2);

	s_rcr = RCR_BRD | RCR_LBNONE;
	if (sc->sc_if.if_flags & IFF_PROMISC)
		s_rcr |= RCR_PRO;
	if (sc->sc_if.if_flags & IFF_ALLMULTI)
		s_rcr |= RCR_AMC;
	NIC_PUT(sc, SNR_RCR, s_rcr);

	NIC_PUT(sc, SNR_IMR, (IMR_PRXEN | IMR_PTXEN | IMR_TXEREN | IMR_LCDEN));

	/* clear pending interrupts */
	NIC_PUT(sc, SNR_ISR, ISR_ALL);

	/* clear tally counters */
	NIC_PUT(sc, SNR_CRCT, -1);
	NIC_PUT(sc, SNR_FAET, -1);
	NIC_PUT(sc, SNR_MPT, -1);

	initialise_tda(sc);
	initialise_rda(sc);
	initialise_rra(sc);

	/* enable the chip */
	NIC_PUT(sc, SNR_CR, 0);
	wbflush();

	/* program the CAM */
	camprogram(sc);

	/* get it to read resource descriptors */
	NIC_PUT(sc, SNR_CR, CR_RRRA);
	wbflush();
	while ((NIC_GET(sc, SNR_CR)) & CR_RRRA)
		continue;

	/* enable rx */
	NIC_PUT(sc, SNR_CR, CR_RXEN);
	wbflush();

	/* flag interface as "running" */
	sc->sc_if.if_flags |= IFF_RUNNING;
	sc->sc_if.if_flags &= ~IFF_OACTIVE;

	splx(s);
	return (0);
}

/*
 * close down an interface and free its buffers
 * Called on final close of device, or if sninit() fails
 * part way through.
 */
static int
snstop(struct sn_softc *sc)
{
	struct mtd *mtd;
	int	s = splnet();

	/* stick chip in reset */
	NIC_PUT(sc, SNR_CR, CR_RST);
	wbflush();

	/* free all receive buffers (currently static so nothing to do) */

	/* free all pending transmit mbufs */
	while (sc->mtd_hw != sc->mtd_free) {
		mtd = &sc->mtda[sc->mtd_hw];
		if (mtd->mtd_mbuf)
			m_freem(mtd->mtd_mbuf);
		if (++sc->mtd_hw == NTDA) sc->mtd_hw = 0;
	}

	sc->sc_if.if_timer = 0;
	sc->sc_if.if_flags &= ~IFF_RUNNING;

	splx(s);
	return (0);
}

/*
 * Called if any Tx packets remain unsent after 5 seconds,
 * In all cases we just reset the chip, and any retransmission
 * will be handled by higher level protocol timeouts.
 */
static void
snwatchdog(struct ifnet *ifp)
{
	struct sn_softc *sc = ifp->if_softc;
	struct mtd *mtd;

	if (sc->mtd_hw != sc->mtd_free) {
		/* something still pending for transmit */
		mtd = &sc->mtda[sc->mtd_hw];
		if (SRO(sc->bitmode, mtd->mtd_txp, TXP_STATUS) == 0)
			log(LOG_ERR, "%s: Tx - timeout\n",
			    sc->sc_dev.dv_xname);
		else
			log(LOG_ERR, "%s: Tx - lost interrupt\n",
			    sc->sc_dev.dv_xname);
		snreset(sc);
	}
}

/*
 * stuff packet into sonic (at splnet)
 */
static __inline__ int
sonicput(struct sn_softc *sc, struct mbuf *m0, int mtd_next)
{
	struct mtd *mtdp;
	struct mbuf *m;
	u_char	*buff;
	void	*txp;
	u_int	len = 0;
	u_int	totlen = 0;

	/* grab the replacement mtd */
	mtdp = &sc->mtda[sc->mtd_free];

	buff = mtdp->mtd_buf;
	
	/* this packet goes to mtdnext fill in the TDA */
	mtdp->mtd_mbuf = m0;
	txp = mtdp->mtd_txp;

	/* Write to the config word. Every (NTDA/2)+1 packets we set an intr */
	if (sc->mtd_pint == 0) {
		sc->mtd_pint = NTDA/2;
		SWO(sc->bitmode, txp, TXP_CONFIG, TCR_PINT);
	} else {
		sc->mtd_pint--;
		SWO(sc->bitmode, txp, TXP_CONFIG, 0);
	}

	for (m = m0; m; m = m->m_next) {
		u_char *data = mtod(m, u_char *);
		len = m->m_len;
		totlen += len;
		bcopy(data, buff, len);
		buff += len;
	}
	if (totlen >= TXBSIZE) {
		panic("%s: sonicput: packet overflow", sc->sc_dev.dv_xname);
	}

	SWO(sc->bitmode, txp, TXP_FRAGOFF + (0 * TXP_FRAGSIZE) + TXP_FPTRLO,
	    LOWER(mtdp->mtd_vbuf));
	SWO(sc->bitmode, txp, TXP_FRAGOFF + (0 * TXP_FRAGSIZE) + TXP_FPTRHI,
	    UPPER(mtdp->mtd_vbuf));

	if (totlen < ETHERMIN + ETHER_HDR_LEN) {
		int pad = ETHERMIN + ETHER_HDR_LEN - totlen;
		bzero(mtdp->mtd_buf + totlen, pad);
		totlen = ETHERMIN + ETHER_HDR_LEN;
	}

	SWO(sc->bitmode, txp, TXP_FRAGOFF + (0 * TXP_FRAGSIZE) + TXP_FSIZE,
	    totlen);
	SWO(sc->bitmode, txp, TXP_FRAGCNT, 1);
	SWO(sc->bitmode, txp, TXP_PKTSIZE, totlen);

	/* link onto the next mtd that will be used */
	SWO(sc->bitmode, txp, TXP_FRAGOFF + (1 * TXP_FRAGSIZE) + TXP_FPTRLO,
	    LOWER(sc->mtda[mtd_next].mtd_vtxp) | EOL);

	/*
	 * The previous txp.tlink currently contains a pointer to
	 * our txp | EOL. Want to clear the EOL, so write our
	 * pointer to the previous txp.
	 */
	SWO(sc->bitmode, sc->mtda[sc->mtd_prev].mtd_txp, sc->mtd_tlinko,
	    LOWER(mtdp->mtd_vtxp));

	/* make sure chip is running */
	wbflush();
	NIC_PUT(sc, SNR_CR, CR_TXP);
	wbflush();
	sc->sc_if.if_timer = 5;	/* 5 seconds to watch for failing to transmit */

	return (totlen);
}

/*
 * These are called from sonicioctl() when /etc/ifconfig is run to set
 * the address or switch the i/f on.
 */
/*
 * CAM support
 */
static void
caminitialise(struct sn_softc *sc)
{
	void	*p_cda = sc->p_cda;
	int	i;
	int	bitmode = sc->bitmode;
	int	camoffset;

	for (i = 0; i < MAXCAM; i++) {
		camoffset = i * CDA_CAMDESC;
		SWO(bitmode, p_cda, (camoffset + CDA_CAMEP), i);
		SWO(bitmode, p_cda, (camoffset + CDA_CAMAP2), 0);
		SWO(bitmode, p_cda, (camoffset + CDA_CAMAP1), 0);
		SWO(bitmode, p_cda, (camoffset + CDA_CAMAP0), 0);
	}
	SWO(bitmode, p_cda, CDA_ENABLE, 0);
}

static void
camentry(struct sn_softc *sc, int entry, u_char *ea)
{
	void	*p_cda = sc->p_cda;
	int	bitmode = sc->bitmode;
	int	camoffset = entry * CDA_CAMDESC;

	SWO(bitmode, p_cda, camoffset + CDA_CAMEP, entry);
	SWO(bitmode, p_cda, camoffset + CDA_CAMAP2, (ea[5] << 8) | ea[4]);
	SWO(bitmode, p_cda, camoffset + CDA_CAMAP1, (ea[3] << 8) | ea[2]);
	SWO(bitmode, p_cda, camoffset + CDA_CAMAP0, (ea[1] << 8) | ea[0]);
	SWO(bitmode, p_cda, CDA_ENABLE,
	    (SRO(bitmode, p_cda, CDA_ENABLE) | (1 << entry)));
}

static void
camprogram(struct sn_softc *sc)
{
	struct ether_multistep step;
	struct ether_multi *enm;
	struct ifnet *ifp;
	int	timeout;
	int	mcount = 0;

	caminitialise(sc);

	ifp = &sc->sc_if;

	/* Always load our own address first. */
	camentry (sc, mcount, sc->sc_enaddr);
	mcount++;

	/* Assume we won't need allmulti bit. */
	ifp->if_flags &= ~IFF_ALLMULTI;

	/* Loop through multicast addresses */
	ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
	while (enm != NULL) {
		if (mcount == MAXCAM) {
			 ifp->if_flags |= IFF_ALLMULTI;
			 break;
		}

		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    sizeof(enm->enm_addrlo)) != 0) {
			/*
			 * SONIC's CAM is programmed with specific
			 * addresses. It has no way to specify a range.
			 * (Well, thats not exactly true. If the
			 * range is small one could program each addr
			 * within the range as a separate CAM entry)
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			break;
		}

		/* program the CAM with the specified entry */
		camentry(sc, mcount, enm->enm_addrlo);
		mcount++;

		ETHER_NEXT_MULTI(step, enm);
	}

	NIC_PUT(sc, SNR_CDP, LOWER(sc->v_cda));
	NIC_PUT(sc, SNR_CDC, MAXCAM);
	NIC_PUT(sc, SNR_CR, CR_LCAM);
	wbflush();

	timeout = 10000;
	while ((NIC_GET(sc, SNR_CR) & CR_LCAM) && timeout--)
		continue;
	if (timeout == 0) {
		/* XXX */
		panic("%s: CAM initialisation failed", sc->sc_dev.dv_xname);
	}
	timeout = 10000;
	while (((NIC_GET(sc, SNR_ISR) & ISR_LCD) == 0) && timeout--)
		continue;

	if (NIC_GET(sc, SNR_ISR) & ISR_LCD)
		NIC_PUT(sc, SNR_ISR, ISR_LCD);
	else
		printf("%s: CAM initialisation without interrupt\n",
		    sc->sc_dev.dv_xname);
}

#ifdef SNDEBUG
static void
camdump(struct sn_softc *sc)
{
	int	i;

	printf("CAM entries:\n");
	NIC_PUT(sc, SNR_CR, CR_RST);
	wbflush();

	for (i = 0; i < 16; i++) {
		ushort  ap2, ap1, ap0;
		NIC_PUT(sc, SNR_CEP, i);
		wbflush();
		ap2 = NIC_GET(sc, SNR_CAP2);
		ap1 = NIC_GET(sc, SNR_CAP1);
		ap0 = NIC_GET(sc, SNR_CAP0);
		printf("%d: ap2=0x%x ap1=0x%x ap0=0x%x\n", i, ap2, ap1, ap0);
	}
	printf("CAM enable 0x%x\n", NIC_GET(sc, SNR_CEP));

	NIC_PUT(sc, SNR_CR, 0);
	wbflush();
}
#endif

static void
initialise_tda(struct sn_softc *sc)
{
	struct mtd *mtd;
	int	i;

	for (i = 0; i < NTDA; i++) {
		mtd = &sc->mtda[i];
		mtd->mtd_mbuf = 0;
	}

	sc->mtd_hw = 0;
	sc->mtd_prev = NTDA - 1;
	sc->mtd_free = 0;
	sc->mtd_tlinko = TXP_FRAGOFF + 1*TXP_FRAGSIZE + TXP_FPTRLO;
	sc->mtd_pint = NTDA/2;

	NIC_PUT(sc, SNR_UTDA, UPPER(sc->mtda[0].mtd_vtxp));
	NIC_PUT(sc, SNR_CTDA, LOWER(sc->mtda[0].mtd_vtxp));
}

static void
initialise_rda(struct sn_softc *sc)
{
	int		bitmode = sc->bitmode;
	int		i;
	caddr_t		p_rda = 0;
	u_int32_t	v_rda = 0;

	/* link the RDA's together into a circular list */
	for (i = 0; i < (sc->sc_nrda - 1); i++) {
		p_rda = sc->p_rda + (i * RXPKT_SIZE(sc));
		v_rda = sc->v_rda + ((i+1) * RXPKT_SIZE(sc));
		SWO(bitmode, p_rda, RXPKT_RLINK, LOWER(v_rda));
		SWO(bitmode, p_rda, RXPKT_INUSE, 1);
	}
	p_rda = sc->p_rda + ((sc->sc_nrda - 1) * RXPKT_SIZE(sc));
	SWO(bitmode, p_rda, RXPKT_RLINK, LOWER(sc->v_rda) | EOL);
	SWO(bitmode, p_rda, RXPKT_INUSE, 1);

	/* mark end of receive descriptor list */
	sc->sc_rdamark = sc->sc_nrda - 1;

	sc->sc_rxmark = 0;

	NIC_PUT(sc, SNR_URDA, UPPER(sc->v_rda));
	NIC_PUT(sc, SNR_CRDA, LOWER(sc->v_rda));
	wbflush();
}

static void
initialise_rra(struct sn_softc *sc)
{
	int	i;
	u_int	v;
	int	bitmode = sc->bitmode;

	if (bitmode)
		NIC_PUT(sc, SNR_EOBC, RBASIZE(sc) / 2 - 2);
	else
		NIC_PUT(sc, SNR_EOBC, RBASIZE(sc) / 2 - 1);

	NIC_PUT(sc, SNR_URRA, UPPER(sc->v_rra[0]));
	NIC_PUT(sc, SNR_RSA, LOWER(sc->v_rra[0]));
	/* rea must point just past the end of the rra space */
	NIC_PUT(sc, SNR_REA, LOWER(sc->v_rea));
	NIC_PUT(sc, SNR_RRP, LOWER(sc->v_rra[0]));
	NIC_PUT(sc, SNR_RSC, 0);

	/* fill up SOME of the rra with buffers */
	for (i = 0; i < NRBA; i++) {
		v = sc->rbuf_phys[i];
		SWO(bitmode, sc->p_rra[i], RXRSRC_PTRHI, UPPER(v));
		SWO(bitmode, sc->p_rra[i], RXRSRC_PTRLO, LOWER(v));
		SWO(bitmode, sc->p_rra[i], RXRSRC_WCHI, UPPER(PAGE_SIZE/2));
		SWO(bitmode, sc->p_rra[i], RXRSRC_WCLO, LOWER(PAGE_SIZE/2));
	}
	sc->sc_rramark = NRBA;
	NIC_PUT(sc, SNR_RWP, LOWER(sc->v_rra[sc->sc_rramark]));
	wbflush();
}

int
snintr(void *arg)
{
	struct sn_softc *sc = (struct sn_softc *)arg;
	int isr;
	int rv = 0;

	while ((isr = (NIC_GET(sc, SNR_ISR) & ISR_ALL)) != 0) {
		rv = 1;
		/* scrub the interrupts that we are going to service */
		NIC_PUT(sc, SNR_ISR, isr);
		wbflush();

		if (isr & (ISR_BR | ISR_LCD | ISR_TC))
			printf("%s: unexpected interrupt status 0x%x\n",
			    sc->sc_dev.dv_xname, isr);

		if (isr & (ISR_TXDN | ISR_TXER | ISR_PINT))
			sonictxint(sc);

		if (isr & ISR_PKTRX)
			sonicrxint(sc);

		if (isr & (ISR_HBL | ISR_RDE | ISR_RBE | ISR_RBAE | ISR_RFO)) {
			if (isr & ISR_HBL)
				/*
				 * The repeater is not providing a heartbeat.
				 * In itself this isn't harmful, lots of the
				 * cheap repeater hubs don't supply a heartbeat.
				 * So ignore the lack of heartbeat. Its only
				 * if we can't detect a carrier that we have a
				 * problem.
				 */
				;
			if (isr & ISR_RDE)
				printf("%s: receive descriptors exhausted\n",
				    sc->sc_dev.dv_xname);
			if (isr & ISR_RBE)
				printf("%s: receive buffers exhausted\n",
				    sc->sc_dev.dv_xname);
			if (isr & ISR_RBAE)
				printf("%s: receive buffer area exhausted\n",
				    sc->sc_dev.dv_xname);
			if (isr & ISR_RFO)
				printf("%s: receive FIFO overrun\n",
				    sc->sc_dev.dv_xname);
			if (isr & (ISR_RDE | ISR_RBE | ISR_RBAE /* | ISR_RFO */))
				snreset(sc);
		}
		if (isr & (ISR_CRC | ISR_FAE | ISR_MP)) {
#ifdef notdef
			if (isr & ISR_CRC)
				sc->sc_crctally++;
			if (isr & ISR_FAE)
				sc->sc_faetally++;
			if (isr & ISR_MP)
				sc->sc_mptally++;
#endif
		}
		snstart(&sc->sc_if);
	}

	return (rv);
}

/*
 * Transmit interrupt routine
 */
static void
sonictxint(struct sn_softc *sc)
{
	struct mtd	*mtd;
	void		*txp;
	unsigned short	txp_status;
	int		mtd_hw;
	struct ifnet	*ifp = &sc->sc_if;

	mtd_hw = sc->mtd_hw;

	if (mtd_hw == sc->mtd_free)
		return;

	while (mtd_hw != sc->mtd_free) {
		mtd = &sc->mtda[mtd_hw];

		txp = mtd->mtd_txp;

		if (SRO(sc->bitmode, txp, TXP_STATUS) == 0) {
			break; /* it hasn't really gone yet */
		}

#ifdef SNDEBUG
		{
			struct ether_header *eh;

			eh = (struct ether_header *) mtd->mtd_buf;
			printf("%s: xmit status=0x%x len=%d type=0x%x from %s",
			    sc->sc_dev.dv_xname,
			    SRO(sc->bitmode, txp, TXP_STATUS),
			    SRO(sc->bitmode, txp, TXP_PKTSIZE),
			    htons(eh->ether_type),
			    ether_sprintf(eh->ether_shost));
			printf(" (to %s)\n", ether_sprintf(eh->ether_dhost));
		}
#endif /* SNDEBUG */

		ifp->if_flags &= ~IFF_OACTIVE;

		if (mtd->mtd_mbuf != 0) {
			m_freem(mtd->mtd_mbuf);
			mtd->mtd_mbuf = 0;
		}
		if (++mtd_hw == NTDA) mtd_hw = 0;

		txp_status = SRO(sc->bitmode, txp, TXP_STATUS);

		ifp->if_collisions += (txp_status & TCR_EXC) ? 16 :
			((txp_status & TCR_NC) >> 12);

		if ((txp_status & TCR_PTX) == 0) {
			ifp->if_oerrors++;
			
			/* XXX - DG This looks bogus */
			if (mtd_hw != sc->mtd_free) {
				mtd = &sc->mtda[mtd_hw];
				NIC_PUT(sc, SNR_CTDA, LOWER(mtd->mtd_vtxp));
				NIC_PUT(sc, SNR_CR, CR_TXP);
				wbflush();
				break;
			}
		}
	}

	sc->mtd_hw = mtd_hw;
	return;
}

/*
 * Receive interrupt routine
 */
static void
sonicrxint(struct sn_softc *sc)
{
	caddr_t	rda;
	int	orra;
	int	len;
	int	rramark;
	int	rdamark;
	int	bitmode = sc->bitmode;
	u_int16_t rxpkt_ptr;

	rda = sc->p_rda + (sc->sc_rxmark * RXPKT_SIZE(sc));

	while (SRO(bitmode, rda, RXPKT_INUSE) == 0) {
		u_int status = SRO(bitmode, rda, RXPKT_STATUS);

		orra = RBASEQ(SRO(bitmode, rda, RXPKT_SEQNO)) & RRAMASK;
		rxpkt_ptr = SRO(bitmode, rda, RXPKT_PTRLO);
		len = SRO(bitmode, rda, RXPKT_BYTEC) - FCSSIZE;
		if (status & RCR_PRX) {
			caddr_t pkt = sc->rbuf[orra & RBAMASK] +
			    m68k_page_offset(rxpkt_ptr);
			if (sonic_read(sc, pkt, len))
				sc->sc_if.if_ipackets++;
			else
				sc->sc_if.if_ierrors++;
		} else
			sc->sc_if.if_ierrors++;

		/*
		 * give receive buffer area back to chip.
		 *
		 * If this was the last packet in the RRA, give the RRA to
		 * the chip again.
		 * If sonic read didnt copy it out then we would have to
		 * wait !!
		 * (dont bother add it back in again straight away)
		 *
		 * Really, we're doing p_rra[rramark] = p_rra[orra] but
		 * we have to use the macros because SONIC might be in
		 * 16 or 32 bit mode.
		 */
		if (status & RCR_LPKT) {
			void *tmp1, *tmp2;

			rramark = sc->sc_rramark;
			tmp1 = sc->p_rra[rramark];
			tmp2 = sc->p_rra[orra];
			SWO(bitmode, tmp1, RXRSRC_PTRLO,
				SRO(bitmode, tmp2, RXRSRC_PTRLO));
			SWO(bitmode, tmp1, RXRSRC_PTRHI,
				SRO(bitmode, tmp2, RXRSRC_PTRHI));
			SWO(bitmode, tmp1, RXRSRC_WCLO,
				SRO(bitmode, tmp2, RXRSRC_WCLO));
			SWO(bitmode, tmp1, RXRSRC_WCHI,
				SRO(bitmode, tmp2, RXRSRC_WCHI));

			/* zap old rra for fun */
			SWO(bitmode, tmp2, RXRSRC_WCHI, 0);
			SWO(bitmode, tmp2, RXRSRC_WCLO, 0);

			sc->sc_rramark = (++rramark) & RRAMASK;
			NIC_PUT(sc, SNR_RWP, LOWER(sc->v_rra[rramark]));
			wbflush();
		}

		/*
		 * give receive descriptor back to chip simple
		 * list is circular
		 */
		rdamark = sc->sc_rdamark;
		SWO(bitmode, rda, RXPKT_INUSE, 1);
		SWO(bitmode, rda, RXPKT_RLINK,
			SRO(bitmode, rda, RXPKT_RLINK) | EOL);
		SWO(bitmode, (sc->p_rda + (rdamark * RXPKT_SIZE(sc))), RXPKT_RLINK,
			SRO(bitmode, (sc->p_rda + (rdamark * RXPKT_SIZE(sc))),
			RXPKT_RLINK) & ~EOL);
		sc->sc_rdamark = sc->sc_rxmark;

		if (++sc->sc_rxmark >= sc->sc_nrda)
			sc->sc_rxmark = 0;
		rda = sc->p_rda + (sc->sc_rxmark * RXPKT_SIZE(sc));
	}
}

/*
 * sonic_read -- pull packet off interface and forward to
 * appropriate protocol handler
 */
static __inline__ int
sonic_read(struct sn_softc *sc, caddr_t pkt, int len)
{
	struct ifnet *ifp = &sc->sc_if;
#ifdef SNDEBUG
	struct ether_header *et;
#endif
	struct mbuf *m;

#ifdef SNDEBUG
	/*
	 * Get pointer to ethernet header (in input buffer).
	 */
	et = (struct ether_header *)pkt;

	printf("%s: rcvd %p len=%d type=0x%x from %s",
	    sc->sc_dev.dv_xname, et, len, htons(et->ether_type),
	    ether_sprintf(et->ether_shost));
	printf(" (to %s)\n", ether_sprintf(et->ether_dhost));
#endif /* SNDEBUG */

	if (len < (ETHER_MIN_LEN - ETHER_CRC_LEN) ||
	    len > (ETHER_MAX_LEN - ETHER_CRC_LEN)) {
		printf("%s: invalid packet length %d bytes\n",
		    sc->sc_dev.dv_xname, len);
		return (0);
	}

	m = sonic_get(sc, pkt, len);
	if (m == NULL)
		return (0);
#if NBPFILTER > 0
	/* Pass this up to any BPF listeners. */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
	ether_input_mbuf(ifp, m);
	return (1);
}

/*
 * munge the received packet into an mbuf chain
 */
static __inline__ struct mbuf *
sonic_get(struct sn_softc *sc, caddr_t pkt, int datalen)
{
	struct	mbuf *m, *top, **mp;
	int	len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	m->m_pkthdr.rcvif = &sc->sc_if;
	m->m_pkthdr.len = datalen;
	len = MHLEN;
	top = 0;
	mp = &top;

	while (datalen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (NULL);
			}
			len = MLEN;
		}
		if (datalen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				if (top)
					m_freem(top);
				return (NULL);
			}
			len = MCLBYTES;
		}
		m->m_len = len = min(datalen, len);

		bcopy(pkt, mtod(m, caddr_t), (unsigned) len);
		pkt += len;
		datalen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

static u_char bbr4[] = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};
#define bbr(v)	((bbr4[(v)&0xf] << 4) | bbr4[((v)>>4) & 0xf])

void
sn_get_enaddr(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    u_char *dst)
{
	int	i, do_bbr;
	u_char	b;

	/*
	 * For reasons known only to Apple, MAC addresses in the ethernet
	 * PROM are stored in Token Ring (IEEE 802.5) format, that is
	 * with all of the bits in each byte reversed (canonical bit format).
	 * When the address is read out it must be reversed to ethernet format
	 * before use.
	 *
	 * Apple has been assigned OUI's 08:00:07 and 00:a0:40. All onboard
	 * ethernet addresses on 68K machines should be in one of these
	 * two ranges.
	 *
	 * Here is where it gets complicated.
	 *
	 * The PMac 7200, 7500, 8500, and 9500 accidentally had the PROM
	 * written in standard ethernet format. The MacOS accounted for this
	 * in these systems, and did not reverse the bytes. Some other
	 * networking utilities were not so forgiving, and got confused.
	 * "Some" of Apple's Nubus ethernet cards also had their bits
	 * burned in ethernet format.
	 *
	 * Apple petitioned the IEEE and was granted the 00:05:02 (bit reversal
	 * of 00:a0:40) as well. As of OpenTransport 1.1.1, Apple removed
	 * their workaround and now reverses the bits regardless of
	 * what kind of machine it is. So PMac systems and the affected
	 * Nubus cards now use 00:05:02, instead of the 00:a0:40 for which they
	 * were intended.
	 *
	 * See Apple Techinfo article TECHINFO-0020552, "OpenTransport 1.1.1
	 * and MacOS System 7.5.3 FAQ (10/96)" for more details.
	 */
	do_bbr = 0;
	b = bus_space_read_1(t, h, o);
	if (b == 0x10)
		do_bbr = 1;
	dst[0] = (do_bbr) ? bbr(b) : b;

	for (i = 1 ; i < ETHER_ADDR_LEN ; i++) {
		b = bus_space_read_1(t, h, o+i);
		dst[i] = (do_bbr) ? bbr(b) : b;
	}
}
@


1.55
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.54 2010/03/31 19:46:27 miod Exp $        */
@


1.54
log
@Make sure the boundaries of uvm_pglistalloc() calls are set up with low
being page-aligned, and high being end of page (i.e.
high & PAGE_MASK == PAGE_MASK) everywhere, for consistency. Future code
will depend on this.
ok deraadt@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.53 2009/04/14 16:01:04 oga Exp $        */
d127 1
a127 1
	if (sc->space == NULL) {
@


1.53
log
@Convert the waitok field of uvm_pglistalloc to "flags", more will be added soon.

For the possibility of sleeping, the first two flags are UVM_PLA_WAITOK
and UVM_PLA_NOWAIT. It is an error not to show intention, so assert that
one of the two is provided. Switch over every caller in the tree to
using the appropriate flag.

ok art@@, ariane@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.52 2009/03/29 21:53:52 sthen Exp $        */
d116 1
a116 1
	error = uvm_pglistalloc(SN_NPAGES * PAGE_SIZE, 0, -PAGE_SIZE,
@


1.52
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.51 2009/03/15 20:40:25 miod Exp $        */
d117 1
a117 1
	    PAGE_SIZE, 0, &pglist, 1, 0);
@


1.51
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.50 2008/11/28 02:44:17 brad Exp $        */
d128 1
a128 1
		printf(": could not map descriptor memory\n");
@


1.50
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.49 2008/10/08 23:53:08 brad Exp $        */
a31 1
#include <net/netisr.h>
@


1.49
log
@cosmetic change for ioctl funtions.. move splnet out from variable declaration.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.48 2008/10/02 20:21:13 brad Exp $        */
a253 2
	struct ifaddr *ifa;
	struct ifreq *ifr;
d255 1
a261 1
		ifa = (struct ifaddr *)data;
a301 18
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *) data;
		if (cmd == SIOCADDMULTI)
			err = ether_addmulti(ifr, &sc->sc_arpcom);
		else
			err = ether_delmulti(ifr, &sc->sc_arpcom);

		if (err == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly. But remember UP flag!
			 */
			if (ifp->if_flags & IFF_RUNNING)
				snreset(sc);
			err = 0;
		}
		break;
d304 6
@


1.48
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.47 2007/09/04 17:55:15 miod Exp $        */
d257 3
a259 1
	int	s = splnet(), err = 0;
@


1.47
log
@Reset the chip after internal memory exhaustion, makes the driver more solid
with heavy NFS usage.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.46 2007/01/12 16:31:21 martin Exp $        */
a259 1

d321 1
a321 1
		err = EINVAL;
d323 1
@


1.46
log
@fix altq for mc(4); make mbuf functions return NULL instead of 0 while
there

from Brad, tested by me on all three adapters
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.45 2006/06/24 13:23:27 miod Exp $        */
d864 2
@


1.45
log
@Allocate ethernet buffers as uvm pages, and map them with pmap_enter_cache(),
instead of crossing fingers and expecting malloc() to return aligned and
contiguous memory.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.44 2006/04/16 20:37:23 miod Exp $        */
d352 1
a352 1
	if (m == 0)
d1095 3
a1097 2
	if (m == 0)
		return (0);
d1107 1
a1107 1
			if (m == 0) {
d1109 1
a1109 1
				return (0);
d1116 3
a1118 2
				if (top) m_freem(top);
				return (0);
@


1.44
log
@Remove assert definitions which are provided by libkern.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.43 2006/04/14 09:36:49 martin Exp $        */
d105 5
a109 4
	u_char	*p;
	u_char	*pp;
	int	i;
	int	offset;
d116 27
a142 1
	sc->space = malloc((SN_NPAGES + 1) * PAGE_SIZE, M_DEVBUF, M_WAITOK);
a156 21
	/*
	 * because the SONIC is basically 16bit device it 'concatenates'
	 * a higher buffer address to a 16 bit offset--this will cause wrap
	 * around problems near the end of 64k !!
	 */
	p = sc->space;
	pp = (u_char *)ROUNDUP ((int)p, PAGE_SIZE);
	p = pp;

	/*
	 * Disable caching on the SONIC's data space.
	 * The pages might not be physically contiguous, so set
	 * each page individually.
	 */
	for (i = 0; i < SN_NPAGES; i++) {
		physaccess (p, (caddr_t)SONIC_GETDMA(p), PAGE_SIZE,
			PG_V | PG_RW | PG_CI);
		p += PAGE_SIZE;
	}
	p = pp;

d159 1
a159 1
		sc->v_rra[i] = SONIC_GETDMA(p);
d162 1
a162 1
	sc->v_rea = SONIC_GETDMA(p);
d164 1
a164 1
	p = (u_char *)SOALIGN(sc, p);
d167 1
a167 1
	sc->v_cda = SONIC_GETDMA(p);
d170 1
a170 1
	p = (u_char *)SOALIGN(sc, p);
d175 1
a175 1
		mtdp->mtd_vtxp = SONIC_GETDMA(p);
d179 1
a179 1
	p = (u_char *)SOALIGN(sc, p);
d181 1
d183 1
a183 1
		printf ("%s: sizeof RRA (%ld) + CDA (%ld) +"
a184 1
		    sc->sc_dev.dv_xname,
d189 1
a189 1
		return(1);
d191 1
d197 2
a198 2
	sc->p_rda = (caddr_t) p;
	sc->v_rda = SONIC_GETDMA(p);
d204 1
d209 1
a209 1
	offset = TXBSIZE;
d213 2
a214 2
		mtdp->mtd_buf = p;
		mtdp->mtd_vbuf = SONIC_GETDMA(p);
d216 1
a216 1
		if (offset < PAGE_SIZE) {
d221 1
a221 1
			offset = TXBSIZE;
d807 1
a807 1
		v = SONIC_GETDMA(sc->rbuf[i]);
@


1.43
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.42 2006/03/25 22:41:41 djm Exp $        */
a83 17

#undef assert
#undef _assert

#ifdef NDEBUG
#define	assert(e)	((void)0)
#define	_assert(e)	((void)0)
#else
#define	_assert(e)	assert(e)
#ifdef __STDC__
#define	assert(e)	((e) ? (void)0 : __assert("sn ", __FILE__, __LINE__, #e))
#else	/* PCC */
#define	assert(e)	((e) ? (void)0 : __assert("sn "__FILE__, __LINE__, "e"))
#endif
#endif

int sndebug = 0;
@


1.42
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.41 2006/03/23 18:51:37 brad Exp $        */
d408 1
a408 1
static int 
d478 1
a478 1
static int 
d532 1
a532 1
static __inline__ int 
d615 1
a615 1
static void 
d633 1
a633 1
static void 
d644 1
a644 1
	SWO(bitmode, p_cda, CDA_ENABLE, 
d648 1
a648 1
static void 
d720 1
a720 1
static void 
d745 1
a745 1
static void 
d893 1
a893 1
static void 
d965 1
a965 1
static void 
d1054 1
a1054 1
static __inline__ int 
d1087 2
a1088 2
	if (ifp->if_bpf) 
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN); 
@


1.41
log
@- Remove variable names from function prototypes.
- Use ether_input_mbuf() and bpf_mtap().

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.40 2006/03/23 04:17:23 brad Exp $        */
d374 1
a374 1
		bpf_mtap(ifp->if_bpf, m);
d1088 1
a1088 1
		bpf_mtap(ifp->if_bpf, m); 
@


1.40
log
@Use PAGE_SIZE instead of NBPG.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.39 2006/03/23 03:59:58 brad Exp $        */
d57 5
a61 5
static int	sninit(struct sn_softc *sc);
static int	snstop(struct sn_softc *sc);
static int	snioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
static void	snstart(struct ifnet *ifp);
static void	snreset(struct sn_softc *sc);
d64 1
a64 1
static void	camentry(struct sn_softc *, int, u_char *ea);
d70 1
a70 1
static void	camdump(struct sn_softc *sc);
d76 2
a77 2
static __inline__ int	sonicput(struct sn_softc *sc, struct mbuf *m0,
			    int mtd_next);
d79 1
a79 2
static __inline__ struct mbuf *sonic_get(struct sn_softc *,
			    struct ether_header *, int);
d576 2
a577 2
	if (totlen < ETHERMIN + sizeof(struct ether_header)) {
		int pad = ETHERMIN + sizeof(struct ether_header) - totlen;
d579 1
a579 1
		totlen = ETHERMIN + sizeof(struct ether_header);
d983 1
a983 2
		len = SRO(bitmode, rda, RXPKT_BYTEC) -
			sizeof(struct ether_header) - FCSSIZE;
d1058 1
d1060 1
d1063 1
d1069 4
a1072 7
#ifdef SNDEBUG
	{
		printf("%s: rcvd %p len=%d type=0x%x from %s",
		    sc->sc_dev.dv_xname, et, len, htons(et->ether_type),
		    ether_sprintf(et->ether_shost));
		printf(" (to %s)\n", ether_sprintf(et->ether_dhost));
	}
d1075 2
a1076 1
	if (len < ETHERMIN || len > ETHERMTU) {
d1082 3
d1086 3
a1088 7
	/*
	 * Check if there's a bpf filter listening on this interface.
	 * If so, hand off the raw packet to enet.
	 */
	if (ifp->if_bpf)
		bpf_tap(ifp->if_bpf, pkt,
		    len + sizeof(struct ether_header));
d1090 1
a1090 4
	m = sonic_get(sc, et, len);
	if (m == NULL)
		return (0);
	ether_input(ifp, et, m);
a1093 2
#define sonicdataaddr(eh, off, type)	((type)(((caddr_t)((eh) + 1) + (off))))

d1098 1
a1098 1
sonic_get(struct sn_softc *sc, struct ether_header *eh, int datalen)
a1101 1
	caddr_t	pkt = sonicdataaddr(eh, 0, caddr_t);
@


1.39
log
@ANSIfy
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.38 2005/09/12 10:07:29 martin Exp $        */
d133 1
a133 1
	sc->space = malloc((SN_NPAGES + 1) * NBPG, M_DEVBUF, M_WAITOK);
d154 1
a154 1
	pp = (u_char *)ROUNDUP ((int)p, NBPG);
d163 1
a163 1
		physaccess (p, (caddr_t)SONIC_GETDMA(p), NBPG,
d165 1
a165 1
		p += NBPG;
d193 1
a193 1
	if ((p - pp) > NBPG) {
d195 1
a195 1
		    "TDA (%ld) > NBPG (%d). Punt!\n",
d200 1
a200 1
		    NBPG);
d204 1
a204 1
	p = pp + NBPG;
d207 1
a207 1
	sc->sc_nrda = NBPG / RXPKT_SIZE(sc);
d211 1
a211 1
	p = pp + NBPG;
d215 1
a215 1
		p += NBPG;
d226 1
a226 1
		if (offset < NBPG) {
d229 1
a229 1
			p = pp + NBPG;
d820 2
a821 2
		SWO(bitmode, sc->p_rra[i], RXRSRC_WCHI, UPPER(NBPG/2));
		SWO(bitmode, sc->p_rra[i], RXRSRC_WCLO, LOWER(NBPG/2));
@


1.38
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.37 2005/07/23 23:28:58 martin Exp $        */
d120 1
a120 3
snsetup(sc, lladdr)
	struct sn_softc	*sc;
	u_int8_t *lladdr;
d262 1
a262 4
snioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d342 1
a342 2
snstart(ifp)
	struct ifnet *ifp;
d403 1
a403 2
snreset(sc)
	struct sn_softc *sc;
d410 1
a410 2
sninit(sc)
	struct sn_softc *sc;
d480 1
a480 2
snstop(sc)
	struct sn_softc *sc;
d512 1
a512 2
snwatchdog(ifp)
	struct ifnet *ifp;
d534 1
a534 4
sonicput(sc, m0, mtd_next)
	struct sn_softc *sc;
	struct mbuf *m0;
	int mtd_next;
d617 1
a617 2
caminitialise(sc)
	struct sn_softc *sc;
d635 1
a635 4
camentry(sc, entry, ea)
	int entry;
	u_char *ea;
	struct sn_softc *sc;
d650 1
a650 2
camprogram(sc)
	struct sn_softc *sc;
d722 1
a722 2
camdump(sc)
	struct sn_softc *sc;
d747 1
a747 2
initialise_tda(sc)
	struct sn_softc *sc;
d768 1
a768 2
initialise_rda(sc)
	struct sn_softc *sc;
d797 1
a797 2
initialise_rra(sc)
	struct sn_softc *sc;
d895 1
a895 2
sonictxint(sc)
	struct sn_softc *sc;
d967 1
a967 2
sonicrxint(sc)
	struct sn_softc *sc;
d1057 1
a1057 4
sonic_read(sc, pkt, len)
	struct sn_softc *sc;
	caddr_t pkt;
	int len;
d1105 1
a1105 4
sonic_get(sc, eh, datalen)
	struct sn_softc *sc;
	struct ether_header *eh;
	int datalen;
d1153 2
a1154 5
sn_get_enaddr(t, h, o, dst)
	bus_space_tag_t	t;
	bus_space_handle_t h;
	bus_addr_t o;
	u_char *dst;
@


1.37
log
@vm_offset_t -> {vaddr_t, bus_addr_t}
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.36 2005/05/22 19:40:51 art Exp $        */
d1011 2
a1012 2
			caddr_t pkt =
			    sc->rbuf[orra & RBAMASK] + (rxpkt_ptr & PGOFSET);
@


1.36
log
@remove "0x" in front of %p in printfs.

eyeballed by krw@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.35 2005/01/04 19:53:37 brad Exp $        */
d1186 1
a1186 1
	vm_offset_t o;
@


1.35
log
@- make sure int is in running state before touching the multicast filter
- remove song and dance with IFF_UP, based on NetBSD commit to mc(4)

ok martin@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.34 2004/11/26 21:21:24 miod Exp $        */
d1097 1
a1097 1
		printf("%s: rcvd 0x%p len=%d type=0x%x from %s",
@


1.34
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.33 2003/01/19 17:25:42 henning Exp $        */
a272 1
	int	temp;
a312 1
			temp = ifp->if_flags & IFF_UP;
a313 1
			ifp->if_flags |= temp;
d331 2
a332 3
			temp = ifp->if_flags & IFF_UP;
			snreset(sc);
			ifp->if_flags |= temp;
d509 1
a509 1
	sc->sc_if.if_flags &= ~(IFF_RUNNING | IFF_UP);
a525 1
	int	temp;
a535 1
		temp = ifp->if_flags & IFF_UP;
a536 1
		ifp->if_flags |= temp;
@


1.33
log
@shut up, dn(4). There's really no need to printf junk nobody wants to read
for every collision.

ok theo
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.32 2002/04/22 20:15:55 miod Exp $        */
d857 2
a858 4
void
snintr(arg, slot)
	void	*arg;
	int	slot;
d861 2
a862 1
	int	isr;
d865 1
d916 2
a917 1
	return;
@


1.32
log
@Bring several stability and performance fixes from NetBSD, as well as
more hardware support.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.31 2002/03/14 01:26:35 millert Exp $        */
a975 2
			printf("%s: Tx packet status=0x%x\n",
			    sc->sc_dev.dv_xname, txp_status);
a978 1
				printf("resubmitting remaining packets\n");
@


1.31
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.30 2001/11/06 19:53:14 miod Exp $        */
d240 1
a240 1
	printf(" address %s\n", ether_sprintf(lladdr));
d433 1
a433 1
	NIC_PUT(sc, SNR_CR, CR_RST);	/* DCR only accessable in reset mode! */
d1174 1
a1174 1
			len = MLEN;
@


1.30
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.29 2001/07/04 08:52:45 niklas Exp $        */
d56 13
a68 13
static void	snwatchdog __P((struct ifnet *));
static int	sninit __P((struct sn_softc *sc));
static int	snstop __P((struct sn_softc *sc));
static int	snioctl __P((struct ifnet *ifp, u_long cmd, caddr_t data));
static void	snstart __P((struct ifnet *ifp));
static void	snreset __P((struct sn_softc *sc));

static void	caminitialise __P((struct sn_softc *));
static void	camentry __P((struct sn_softc *, int, u_char *ea));
static void	camprogram __P((struct sn_softc *));
static void	initialise_tda __P((struct sn_softc *));
static void	initialise_rda __P((struct sn_softc *));
static void	initialise_rra __P((struct sn_softc *));
d70 1
a70 1
static void	camdump __P((struct sn_softc *sc));
d73 2
a74 2
static void	sonictxint __P((struct sn_softc *));
static void	sonicrxint __P((struct sn_softc *));
d76 5
a80 5
static __inline__ int	sonicput __P((struct sn_softc *sc, struct mbuf *m0,
			    int mtd_next));
static __inline__ int	sonic_read __P((struct sn_softc *, caddr_t, int));
static __inline__ struct mbuf *sonic_get __P((struct sn_softc *,
			    struct ether_header *, int));
@


1.30.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.30 2001/11/06 19:53:14 miod Exp $        */
d56 13
a68 13
static void	snwatchdog(struct ifnet *);
static int	sninit(struct sn_softc *sc);
static int	snstop(struct sn_softc *sc);
static int	snioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
static void	snstart(struct ifnet *ifp);
static void	snreset(struct sn_softc *sc);

static void	caminitialise(struct sn_softc *);
static void	camentry(struct sn_softc *, int, u_char *ea);
static void	camprogram(struct sn_softc *);
static void	initialise_tda(struct sn_softc *);
static void	initialise_rda(struct sn_softc *);
static void	initialise_rra(struct sn_softc *);
d70 1
a70 1
static void	camdump(struct sn_softc *sc);
d73 2
a74 2
static void	sonictxint(struct sn_softc *);
static void	sonicrxint(struct sn_softc *);
d76 5
a80 5
static __inline__ int	sonicput(struct sn_softc *sc, struct mbuf *m0,
			    int mtd_next);
static __inline__ int	sonic_read(struct sn_softc *, caddr_t, int);
static __inline__ struct mbuf *sonic_get(struct sn_softc *,
			    struct ether_header *, int);
d240 1
a240 1
	printf("address %s\n", ether_sprintf(lladdr));
d433 1
a433 1
	NIC_PUT(sc, SNR_CR, CR_RST);	/* DCR only accessible in reset mode! */
d1174 1
a1174 1
			len = MCLBYTES;
@


1.30.2.2
log
@sync
@
text
@d1 1
a1 1
/*    $OpenBSD$        */
d976 2
d981 1
@


1.29
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*    $OpenBSD: if_sn.c,v 1.13 1997/04/25 03:40:10 briggs Exp $        */
d42 1
a42 1
#include <vm/vm.h>
@


1.28
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
@


1.27
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@a134 5
	if (sc->space == NULL) {
		printf ("%s: memory allocation for descriptors failed\n",
			sc->sc_dev.dv_xname);
		return (1);
	}
@


1.26
log
@seperate -> separate, okay aaron@@
@
text
@a260 3
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.25
log
@Compensate for the check for onwership of unicast packets in promiscuous
mode being moved to if_ether.c.  This is the last of the drivers hopefully.
@
text
@d716 1
a716 1
			 * within the range as a seperate CAM entry)
@


1.25.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d261 3
d716 1
a716 1
			 * within the range as a separate CAM entry)
@


1.25.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d135 5
@


1.25.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*    $OpenBSD$        */
@


1.25.4.4
log
@Merge in -current
@
text
@d42 1
a42 1
#include <uvm/uvm_extern.h>
@


1.25.4.5
log
@Merge in -current from about a week ago
@
text
@d56 6
a61 6
static void	snwatchdog(struct ifnet *);
static int	sninit(struct sn_softc *sc);
static int	snstop(struct sn_softc *sc);
static int	snioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
static void	snstart(struct ifnet *ifp);
static void	snreset(struct sn_softc *sc);
d63 6
a68 6
static void	caminitialise(struct sn_softc *);
static void	camentry(struct sn_softc *, int, u_char *ea);
static void	camprogram(struct sn_softc *);
static void	initialise_tda(struct sn_softc *);
static void	initialise_rda(struct sn_softc *);
static void	initialise_rra(struct sn_softc *);
d70 1
a70 1
static void	camdump(struct sn_softc *sc);
d73 2
a74 2
static void	sonictxint(struct sn_softc *);
static void	sonicrxint(struct sn_softc *);
d76 5
a80 5
static __inline__ int	sonicput(struct sn_softc *sc, struct mbuf *m0,
			    int mtd_next);
static __inline__ int	sonic_read(struct sn_softc *, caddr_t, int);
static __inline__ struct mbuf *sonic_get(struct sn_softc *,
			    struct ether_header *, int);
@


1.25.4.6
log
@Sync the SMP branch with 3.3
@
text
@d240 1
a240 1
	printf("address %s\n", ether_sprintf(lladdr));
d433 1
a433 1
	NIC_PUT(sc, SNR_CR, CR_RST);	/* DCR only accessible in reset mode! */
d976 2
d981 1
d1174 1
a1174 1
			len = MCLBYTES;
@


1.24
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1129 1
a1129 2
	 * If so, hand off the raw packet to enet, then discard things
	 * not destined for us (but be sure to keep broadcast/multicast).
d1131 1
a1131 1
	if (ifp->if_bpf) {
a1133 6
		if ((ifp->if_flags & IFF_PROMISC) != 0 &&
		    (et->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(et->ether_dhost, &sc->sc_enaddr,
		    sizeof(et->ether_dhost)) != 0)
			return (0);
	}
@


1.23
log
@Make if_sn.c far more MI, eventually share with pica.
sonic_get is faster and simpler.
sn_ioctl works like other current ether drivers now.
Sync up with netbsd to ease maintenance; incorporate some "gratuitous" formatting changes so I won't have to do two totally seperate mods each time.
@
text
@d739 1
a739 1
		panic("%s: CAM initialisation failed\n", sc->sc_dev.dv_xname);
@


1.22
log
@A couple of performance improvements from Denny Gentry <denny1@@home.com>
@
text
@d1 1
a1 2
/*	$NetBSD: if_sn.c,v 1.7 1997/03/20 17:47:51 scottr Exp $	*/
/*	$OpenBSD: if_sn.c,v 1.21 1997/04/18 11:58:34 briggs Exp $	*/
d4 1
a4 1
 * National Semiconductor  SONIC Driver
a31 1
#include <net/route.h>
a42 2
extern int kvtop(caddr_t addr);

a48 2
typedef unsigned char uchar;

d51 1
a51 1
#include <machine/viareg.h>
d55 19
a73 7
static void snwatchdog __P((struct ifnet *));
static int sninit __P((struct sn_softc *sc));
static int snstop __P((struct sn_softc *sc));
static inline int sonicput __P((struct sn_softc *sc, struct mbuf *m0));
static int snioctl __P((struct ifnet *ifp, u_long cmd, caddr_t data));
static void snstart __P((struct ifnet *ifp));
static void snreset __P((struct sn_softc *sc));
d75 5
a79 1
void camdump __P((struct sn_softc *sc));
d100 1
a100 1
int ethdebug = 0;
d119 1
a119 1
snsetup(sc)
d121 1
d123 5
a127 5
	struct ifnet	*ifp = &sc->sc_if;
	unsigned char	*p;
	unsigned char	*pp;
	int		i;

d160 1
a160 1
	pp = (unsigned char *)ROUNDUP ((int)p, NBPG);
d169 1
a169 1
		physaccess (p, (caddr_t) kvtop(p), NBPG,
d177 1
a177 1
		sc->v_rra[i] = kvtop(p);
d180 1
a180 1
	sc->v_rea = kvtop(p);
d182 1
a182 1
	p = (unsigned char *)SOALIGN(sc, p);
d184 2
a185 2
	sc->p_cda = (void *) (p);
	sc->v_cda = kvtop(p);
d188 1
a188 1
	p = (unsigned char *)SOALIGN(sc, p);
d193 1
a193 1
		mtdp->mtd_vtxp = kvtop(p);
d197 1
a197 1
	p = (unsigned char *)SOALIGN(sc, p);
d201 6
a206 6
			"TDA (%ld) > NBPG (%d). Punt!\n",
			sc->sc_dev.dv_xname,
			(ulong)sc->p_cda - (ulong)sc->p_rra[0],
			(ulong)sc->mtda[0].mtd_txp - (ulong)sc->p_cda,
			(ulong)p - (ulong)sc->mtda[0].mtd_txp,
			NBPG);
d213 3
a215 14
	if ((NRDA * RXPKT_SIZE(sc)) > NBPG) {
		printf ("%s: sizeof NRDA (%d) > NBPG (%d). Punt!\n",
			sc->sc_dev.dv_xname,
			NRDA * RXPKT_SIZE(sc), NBPG);
		return (1);
	}

	for (i = 0; i < NRDA; i++) {
		sc->p_rda[i] = (void *) p;
		sc->v_rda[i] = kvtop(p);
		p += RXPKT_SIZE(sc);
	}

	p = (unsigned char *)SOALIGN(sc, p);
d220 1
a220 1
		sc->rbuf[i] = (caddr_t) p;
d224 15
a238 6
	for (i = 0; i < NTXB; i+=2) {
		sc->tbuf[i] = (caddr_t) p;
		sc->tbuf[i+1] = (caddr_t)(p + (NBPG/2));
		sc->vtbuf[i] = kvtop(sc->tbuf[i]);
		sc->vtbuf[i+1] = kvtop(sc->tbuf[i+1]);
		p += NBPG;
d241 1
a241 1
#if 0
d244 1
a244 1
	printf(" address %s\n", ether_sprintf(sc->sc_enaddr));
d246 4
a249 3
#if 0
printf("sonic buffers: rra=%p cda=0x%x rda=0x%x tda=0x%x\n",
	sc->p_rra[0], sc->p_cda, sc->p_rda[0], sc->mtda[0].mtd_txp);
d253 2
d258 2
a259 2
	ifp->if_flags = 
		IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
d276 5
a280 4
	struct ifaddr	*ifa;
	struct sn_softc	*sc = ifp->if_softc;
	int		s = splnet(), err = 0;
	int		temp;
d290 1
a290 1
			(void)sninit(ifp->if_softc);
d295 1
a295 1
			(void)sninit(ifp->if_softc);
d302 6
a307 2
		    ifp->if_flags & IFF_RUNNING) {
			snstop(ifp->if_softc);
d309 13
a321 12
		} else if (ifp->if_flags & IFF_UP &&
		    (ifp->if_flags & IFF_RUNNING) == 0)
			(void)sninit(ifp->if_softc);
		/*
		 * If the state of the promiscuous bit changes, the interface
		 * must be reset to effect the change.
		 */
		if (((ifp->if_flags ^ sc->sc_iflags) & IFF_PROMISC) &&
		    (ifp->if_flags & IFF_RUNNING)) {
			sc->sc_iflags = ifp->if_flags;
			printf("change in flags\n");
			temp = sc->sc_if.if_flags & IFF_UP;
d323 1
a323 1
			sc->sc_if.if_flags |= temp;
d330 3
a332 3
		if(cmd == SIOCADDMULTI)
			err = ether_addmulti((struct ifreq *)data,
						&sc->sc_arpcom);
d334 1
a334 2
			err = ether_delmulti((struct ifreq *)data,
						&sc->sc_arpcom);
d341 1
a341 1
			temp = sc->sc_if.if_flags & IFF_UP;
d343 1
a343 1
			sc->sc_if.if_flags |= temp;
d361 3
a363 3
	struct sn_softc *sc = ifp->if_softc;
	struct mbuf *m;
	int	len;
d365 1
a365 1
	if ((sc->sc_if.if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d370 4
a373 1
	if (sc->txb_inuse == sc->txb_cnt) {
d384 1
a384 1
		panic("snstart: no header mbuf");
d400 1
a400 3
	if ((len = sonicput(sc, m)) > 0) {
		len = m->m_pkthdr.len;
		m_freem(m);
d406 2
a407 3
	/* Point to next buffer slot and wrap if necessary. */
	if (++sc->txb_new == sc->txb_cnt)
		sc->txb_new = 0;
d409 1
a409 4
	sc->txb_inuse++;

	ifp->if_opackets++;	/* # of pkts */
	sc->sc_sum.ls_opacks++;		/* # of pkts */
a415 12
 * This is called from sonicioctl() when /etc/ifconfig is run to set
 * the address or switch the i/f on.
 */
static void caminitialise __P((struct sn_softc *));
static void camentry __P((struct sn_softc *, int, unsigned char *ea));
static void camprogram __P((struct sn_softc *));
static void initialise_tda __P((struct sn_softc *));
static void initialise_rda __P((struct sn_softc *));
static void initialise_rra __P((struct sn_softc *));
static void initialise_tba __P((struct sn_softc *));

/*
d431 2
a432 2
	int			s;
	unsigned long		s_rcr;
d443 2
a444 1
	NIC_PUT(sc, SNR_DCR, sc->snr_dcr);
a466 1
	initialise_tba(sc);
d487 1
d503 1
a503 1
	int s = splnet();
d514 2
a515 1
		mtd->mtd_buf = 0;
a517 1
	sc->txb_inuse = 0;
d536 2
a537 2
	struct mtd	*mtd;
	int		temp;
d544 1
a544 1
				sc->sc_dev.dv_xname);
d547 1
a547 1
			   	 sc->sc_dev.dv_xname);
d557 2
a558 2
static inline int 
sonicput(sc, m0)
d561 1
d563 6
a568 13
	unsigned char		*buff, *buffer;
	void			*txp;
	struct mtd		*mtdp;
	struct mbuf		*m;
	unsigned int		len = 0;
	unsigned int		totlen = 0;
	int			mtd_free = sc->mtd_free;
	int			mtd_next;
	int			txb_new = sc->txb_new;

	if (NIC_GET(sc, SNR_CR) & CR_TXP) {
		return (0);
	}
d571 1
a571 4
	mtdp = &sc->mtda[mtd_free];

	if ((mtd_next = mtd_free + 1) == NTDA)
		mtd_next = 0;
d573 1
a573 6
	if (mtd_next == sc->mtd_hw) {
		return (0);
	}

	/* We are guaranteed, if we get here, that the xmit buffer is free. */
	buff = buffer = sc->tbuf[txb_new];
d576 1
a576 1
	mtdp->mtd_buf = buffer;
d578 9
a586 1
	SWO(sc->bitmode, txp, TXP_CONFIG, 0);
d589 1
a589 1
		unsigned char *data = mtod(m, u_char *);
d596 1
a596 1
		panic("packet overflow in sonicput.");
d598 5
a602 4
	SWO(sc->bitmode, txp, TXP_FRAGOFF+(0*TXP_FRAGSIZE)+TXP_FPTRLO,
		LOWER(sc->vtbuf[txb_new]));
	SWO(sc->bitmode, txp, TXP_FRAGOFF+(0*TXP_FRAGSIZE)+TXP_FPTRHI,
		UPPER(sc->vtbuf[txb_new]));
d606 1
a606 1
		bzero(buffer + totlen, pad);
d610 2
a611 2
	SWO(sc->bitmode, txp, TXP_FRAGOFF+(0*TXP_FRAGSIZE)+TXP_FSIZE,
		totlen);
d616 2
a617 2
	SWO(sc->bitmode, txp, TXP_FRAGOFF+(1*TXP_FRAGSIZE)+TXP_FPTRLO,
		LOWER(sc->mtda[mtd_next].mtd_vtxp) | EOL);
d625 1
a625 4
		LOWER(mtdp->mtd_vtxp));

	sc->mtd_prev = mtd_free;
	sc->mtd_free = mtd_next;
d636 4
a639 6
static void sonictxint __P((struct sn_softc *));
static void sonicrxint __P((struct sn_softc *));

static inline int sonic_read __P((struct sn_softc *, caddr_t, int));
static inline struct mbuf *sonic_get __P((struct sn_softc *, struct ether_header *, int));

a646 1
	int    	i;
d648 1
d665 1
a665 1
	unsigned char *ea;
d668 1
a669 1
	void	*p_cda = sc->p_cda;
d677 1
a677 1
		(SRO(bitmode, p_cda, CDA_ENABLE) | (1 << entry)));
d684 5
a688 5
	int			timeout;
	int			mcount = 0;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	struct ifnet		*ifp;
d695 1
a695 1
	camentry (sc, 0, sc->sc_enaddr);
d710 1
a710 1
				sizeof(enm->enm_addrlo)) != 0) {
d739 1
a739 2
		panic("%s: CAM initialisation failed\n",
		    sc->sc_dev.dv_xname);
d752 1
a752 1
#if 0
d757 1
a757 1
	int i;
d772 1
a772 1
	printf("CAM enable 0x%x\n", NIC_GET(sc, SNR_CE));
d784 1
a784 1
	int     i;
d788 1
a788 1
		mtd->mtd_buf = 0;
d792 1
a792 1
	sc->mtd_prev = NTDA-1;
d795 1
d805 4
a808 2
	int	bitmode = sc->bitmode;
	int     i;
d811 9
a819 6
	for (i = 0; i < (NRDA - 1); i++) {
		SWO(bitmode, sc->p_rda[i], RXPKT_RLINK, LOWER(sc->v_rda[i+1]));
		SWO(bitmode, sc->p_rda[i], RXPKT_INUSE, 1);
	}
	SWO(bitmode, sc->p_rda[NRDA - 1], RXPKT_RLINK, LOWER(sc->v_rda[0]) | EOL);
	SWO(bitmode, sc->p_rda[NRDA - 1], RXPKT_INUSE, 1);
d822 1
a822 1
	sc->sc_rdamark = NRDA - 1;
d826 2
a827 2
	NIC_PUT(sc, SNR_URDA, UPPER(sc->v_rda[0]));
	NIC_PUT(sc, SNR_CRDA, LOWER(sc->v_rda[0]));
d835 3
a837 3
	int     	i;
	unsigned int	v;
	int		bitmode = sc->bitmode;
d853 1
a853 1
		v = kvtop(sc->rbuf[i]);
a863 9
static void
initialise_tba(sc)
	struct sn_softc *sc;
{
	sc->txb_cnt = NTXB;
	sc->txb_inuse = 0;
	sc->txb_new = 0;
}

d869 1
a869 1
	struct sn_softc	*sc = (struct sn_softc *)arg;
d933 1
d935 5
a939 2
	struct mtd	*mtd;
	/* XXX DG make mtd_hw a local var */
d941 1
a941 1
	if (sc->mtd_hw == sc->mtd_free)
d944 2
a945 4
	while (sc->mtd_hw != sc->mtd_free) {
		mtd = &sc->mtda[sc->mtd_hw];
		if (mtd->mtd_buf == 0)
			break;
d949 3
a951 2
		if (SRO(sc->bitmode, txp, TXP_STATUS) == 0)
			return; /* it hasn't really gone yet */
d953 2
a954 1
		if (ethdebug) {
d958 2
a959 1
			printf("xmit status=0x%x len=%d type=0x%x from %s",
d966 11
a976 3
		sc->txb_inuse--;
		mtd->mtd_buf = 0;
		if (++sc->mtd_hw == NTDA) sc->mtd_hw = 0;
d978 2
a979 1
		/* XXX - Do stats here. */
d981 2
a982 1
		if ((SRO(sc->bitmode, txp, TXP_STATUS) & TCR_PTX) == 0) {
d984 2
a985 3
			    sc->sc_dev.dv_xname,
			    SRO(sc->bitmode, txp, TXP_STATUS));

d987 1
a987 1
			if (sc->mtd_hw != sc->mtd_free) {
d989 1
a989 1
				mtd = &sc->mtda[sc->mtd_hw];
d993 1
a993 1
				return;
d997 3
d1009 7
a1015 7
	void			*rda;
	int     		orra;
	int			len;
	int			rramark;
	int			rdamark;
	int			bitmode = sc->bitmode;
	u_int16_t		rxpkt_ptr;
d1017 1
a1017 1
	rda = sc->p_rda[sc->sc_rxmark];
d1020 1
a1020 1
		unsigned status = SRO(bitmode, rda, RXPKT_STATUS);
d1027 3
a1029 2
			caddr_t pkt = sc->rbuf[orra & RBAMASK] + (rxpkt_ptr & PGOFSET);
			if (sonic_read(sc, pkt, len)) {
d1031 2
a1032 3
				sc->sc_sum.ls_ipacks++;
				sc->sc_missed = 0;
			}
d1081 3
a1083 2
		SWO(bitmode, sc->p_rda[rdamark], RXPKT_RLINK,
			SRO(bitmode, sc->p_rda[rdamark], RXPKT_RLINK) & ~EOL);
d1086 1
a1086 1
		if (++sc->sc_rxmark >= NRDA)
d1088 1
a1088 1
		rda = sc->p_rda[sc->sc_rxmark];
d1096 1
a1096 1
static inline int 
d1107 2
a1108 2
         * Get pointer to ethernet header (in input buffer).
         */
d1111 4
a1114 3
	if (ethdebug) {
		printf("rcvd 0x%p len=%d type=0x%x from %s",
		    et, len, htons(et->ether_type),
d1118 2
d1137 2
a1138 2
		    bcmp(et->ether_dhost, sc->sc_enaddr,
			    sizeof(et->ether_dhost)) != 0)
d1146 1
a1146 1
	return(1);
d1149 1
a1149 1
#define sonicdataaddr(eh, off, type)       ((type)(((caddr_t)((eh)+1)+(off))))
a1152 2
 * because we are using stupid buffer management this
 * is slow.
d1154 1
a1154 1
static inline struct mbuf *
d1160 1
a1160 2
	struct mbuf *m;
	struct mbuf *top = 0, **mp = &top;
d1162 1
a1162 3
	char   *spkt = sonicdataaddr(eh, 0, caddr_t);
	char   *epkt = spkt + datalen;
	char *cp = spkt;
a1163 1
	epkt = cp + datalen;
d1169 3
a1171 1
	m->m_len = MHLEN;
d1180 1
a1180 1
			m->m_len = MLEN;
d1182 1
a1182 2
		len = min(datalen, epkt - cp);
		if (len >= MINCLSIZE) {
d1184 5
a1188 14
			if (m->m_flags & M_EXT)
				m->m_len = len = min(len, MCLBYTES);
			else
				len = m->m_len;
		} else {
			/*
		         * Place initial small packet/header at end of mbuf.
		         */
			if (len < m->m_len) {
				if (top == 0 && len + max_linkhdr <= m->m_len)
					m->m_data += max_linkhdr;
				m->m_len = len;
			} else
				len = m->m_len;
d1190 5
a1194 2
		bcopy(cp, mtod(m, caddr_t), (unsigned) len);
		cp += len;
a1196 3
		datalen -= len;
		if (cp == epkt)
			cp = spkt;
d1198 1
d1207 1
a1207 1
	bus_space_tag_t	   t;
d1209 2
a1210 2
	vm_offset_t	   o;
	u_char		   *dst;
d1212 2
a1213 2
	int			i, do_bbr;
	u_char			b;
@


1.21
log
@Fix from Denny Gentry--initialize receive seq. count and don't skip an entry
when programming the CAM.
@
text
@d2 1
a2 1
/*	$OpenBSD: if_sn.c,v 1.20 1997/04/13 14:14:51 briggs Exp $	*/
a178 8
	for (i = 0; i < NRDA; i++) {
		sc->p_rda[i] = (void *) p;
		sc->v_rda[i] = kvtop(p);
		p += RXPKT_SIZE(sc);
	}

	p = (unsigned char *)SOALIGN(sc, p);

d190 1
a190 1
			"RDA (%ld) + TDA (%ld) > NBPG (%d). Punt!\n",
d193 1
a193 2
			(ulong)sc->p_rda[0] - (ulong)sc->p_cda,
			(ulong)sc->mtda[0].mtd_txp - (ulong)sc->p_rda[0],
d198 18
@


1.20
log
@Some updates based on information from Bob Nestor <rnestor@@metronet.com>
about his SONIC-T LC/PDS card.
@
text
@d2 1
a2 1
/*	$OpenBSD: if_sn.c,v 1.19 1997/04/10 03:15:59 briggs Exp $	*/
a698 1
	mcount++;
d842 1
@


1.19
log
@Stop the SONIC before setting reset, not after...
@
text
@d2 1
a2 1
/*	$OpenBSD: if_sn.c,v 1.18 1997/04/10 02:35:02 briggs Exp $	*/
d1194 55
@


1.18
log
@Changes from Denny Gentry <denny1@@home.com>:
Change in the way receive buffer areas are handled.  Before we gave
the chip 16 buffers, each 1536 bytes (big enough for one packet).
Now we're handing the chip 8 buffers, each 4 Kbytes, and letting
the chip fit as many packets as it can in each one.  This should
help keep it from running out of buffer space.  Also make some of
the performance-crucial routines inline.  It made no measurable
difference except to make me feel better
@
text
@d2 1
a2 1
/*	$OpenBSD: if_sn.c,v 1.17 1997/03/29 23:26:48 briggs Exp $	*/
d134 2
a136 2
	wbflush();
	NIC_PUT(sc, SNR_CR, CR_STP);
@


1.17
log
@Update from Denton Gentry with minor bug fixes by me.
Denny says:
if_sn.c:
        - allocate sc->space using malloc (Scott wanted this).
        - make csr accesses use NIC_PUT/GET, remove sc->sc_csr.
        - add multicast and IFF_PROMISC support. multicast isn't
                well tested, but I made sure the unicast case still
                works.
        - finish the new arp interface, remove sc->sc_enaddr
if_snreg.h:
        - remove struct sonic_reg
if_snvar.h:
        - add NIC_PUT and NIC_GET macros a la if_ae
        - remove sc_txhead, it isn't used.
if_sn_nubus.c:
        - clean up support for my SE/30 card.
        - Move add_nubus_intr from if_sn.c (to keep if_sn.c MI)
if_sn_obio.c:
        - make Q610, C610, Q650, C650, Q800 use EXBUS.
        - PB500 had a "return" where "break" was intended. PB500
                probably wasn't working.
        - move add_nubus_intr from if_sn.c.
        - add an "explanation" why Apple's ethernet addr is encoded
                in token ring format in the PROM.
@
text
@d2 1
a2 1
/*	$OpenBSD: if_sn.c,v 1.16 1997/03/25 05:02:39 briggs Exp $	*/
d64 1
a64 1
static int sonicput __P((struct sn_softc *sc, struct mbuf *m0));
d210 1
a210 1
	for (i = 0; i < NRBA; i+=2) {
a211 1
		sc->rbuf[i+1] = (caddr_t)(p + (NBPG/2));
d545 1
a545 1
static int 
d635 2
a636 2
static int sonic_read __P((struct sn_softc *, caddr_t, int));
static struct mbuf *sonic_get __P((struct sn_softc *, struct ether_header *, int));
d833 1
a833 1
	if (bitmode)	/* eobc must be >= MAXETHERPKT */
d837 1
d849 2
a850 2
		SWO(bitmode, sc->p_rra[i], RXRSRC_WCHI, UPPER(RBASIZE(sc) / 2));
		SWO(bitmode, sc->p_rra[i], RXRSRC_WCLO, LOWER(RBASIZE(sc) / 2));
d879 1
a879 1
		if (isr & (ISR_BR | ISR_LCD | ISR_PINT | ISR_TC))
d883 1
a883 1
		if (isr & (ISR_TXDN | ISR_TXER))
d1000 1
a1000 2
	void			*tmp1;
	void			*tmp2;
a1005 3
		if ((status & RCR_LPKT) == 0)
			printf("%s: more than one packet in RBA!\n",
			    sc->sc_dev.dv_xname);
d1008 1
d1012 2
a1013 1
			if (sonic_read(sc, sc->rbuf[orra & RBAMASK], len)) {
d1024 3
a1026 2
		 * orra is now empty of packets and can be freed if
		 * sonic read didnt copy it out then we would have to
d1034 2
a1035 15
		rramark = sc->sc_rramark;
		tmp1 = sc->p_rra[rramark];
		tmp2 = sc->p_rra[orra];
		SWO(bitmode, tmp1, RXRSRC_PTRLO,
			SRO(bitmode, tmp2, RXRSRC_PTRLO));
		SWO(bitmode, tmp1, RXRSRC_PTRHI,
			SRO(bitmode, tmp2, RXRSRC_PTRHI));
		SWO(bitmode, tmp1, RXRSRC_WCLO,
			SRO(bitmode, tmp2, RXRSRC_WCLO));
		SWO(bitmode, tmp1, RXRSRC_WCHI,
			SRO(bitmode, tmp2, RXRSRC_WCHI));

		/* zap old rra for fun */
		SWO(bitmode, tmp2, RXRSRC_WCHI, 0);
		SWO(bitmode, tmp2, RXRSRC_WCLO, 0);
d1037 20
a1056 3
		sc->sc_rramark = (++rramark) & RRAMASK;
		NIC_PUT(sc, SNR_RWP, LOWER(sc->v_rra[rramark]));
		wbflush();
d1080 1
a1080 1
static int 
d1137 1
a1137 1
static struct mbuf *
@


1.16
log
@From scottr@@netbsd.org:
Several minor changes:

 - Indent some comments appropriately per KNF.
 - Output all diagnostics using the device name rather than a static string.
 - Fix a (mostly marmless) bug in snintr(), where loss of heartbeat wasn't
   properly ignored and could mask the `receive descriptors exhausted'
   diagnostic.
@
text
@d2 1
a2 1
/*	$OpenBSD: if_sn.c,v 1.15 1997/03/17 13:09:05 briggs Exp $	*/
d31 1
a60 12
#include	"nubus.h"

/*
 * Register access macros:
 * SWR is "Sonic Write Register"
 * SRD is "Sonic Read Register"
 */
#define SWR(a, x) 	(a) = (x)
#define SRD(a)		((a) & 0xffff)

#define wbflush()

a64 1
static void snintr __P((void *, int));
d108 1
a108 1
void
a116 1
	sc->sc_csr = (struct sonic_reg *) sc->sc_regh;
d119 3
a121 1
	 * Disable caching on the SONIC's data space.
d123 6
a128 2
	physaccess((caddr_t) sc->space, (caddr_t) kvtop((caddr_t) sc->space),
		sizeof(sc->space), PG_V | PG_RW | PG_CI);
d131 2
a132 2
	 * Put the pup in reset mode (sninit() will fix it later)
	 * and clear any interrupts.
d134 3
a136 1
	sc->sc_csr->s_cr = CR_RST;
d138 3
a140 1
	sc->sc_csr->s_isr = 0x7fff;
d148 1
a148 1
	p = &sc->space[0];
d152 12
d197 1
a197 1
		printf ("sn: sizeof RRA (%ld) + CDA (%ld) +"
d199 1
d205 1
a205 1
		return;
d238 2
a239 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
d247 1
a247 1
	add_nubus_intr(sc->slotno, snintr, (void *) sc);
d256 4
a259 4
	struct ifaddr *ifa;
	struct sn_softc *sc = ifp->if_softc;
	int     s = splnet(), err = 0;
	int	temp;
a330 2
 * Use trailer local net encapsulation if enough data in first
 * packet leaves a multiple of 512 bytes of data in remainder.
d397 7
a403 7
void caminitialise __P((struct sn_softc *));
void camentry __P((struct sn_softc *, int, unsigned char *ea));
void camprogram __P((struct sn_softc *));
void initialise_tda __P((struct sn_softc *));
void initialise_rda __P((struct sn_softc *));
void initialise_rra __P((struct sn_softc *));
void initialise_tba __P((struct sn_softc *));
a412 1
	printf("snreset\n");
d421 2
a422 2
	struct sonic_reg *csr = sc->sc_csr;
	int s;
d430 1
a430 1
	csr->s_cr = CR_RST;	/* s_dcr only accessable reset mode! */
d433 11
a443 3
	csr->s_dcr = sc->s_dcr | (sc->bitmode ? DCR_DW32 : DCR_DW16);
	csr->s_rcr = RCR_BRD | RCR_LBNONE;
	csr->s_imr = IMR_PRXEN | IMR_PTXEN | IMR_TXEREN | IMR_LCDEN;
d446 1
a446 1
	csr->s_isr = 0x7fff;
d449 3
a451 3
	csr->s_crct = -1;
	csr->s_faet = -1;
	csr->s_mpt = -1;
d459 1
a459 1
	csr->s_cr = 0;
d462 1
a462 3
	/* program the CAM with our address */
	caminitialise(sc);
	camentry(sc, 0, sc->sc_enaddr);
d466 1
a466 1
	csr->s_cr = CR_RRRA;
d468 1
a468 1
	while (csr->s_cr & CR_RRRA)
d472 1
a472 1
	csr->s_cr = CR_RXEN;
d495 1
a495 1
	sc->sc_csr->s_cr = CR_RST;
a550 1
	struct sonic_reg	*csr = sc->sc_csr;
d561 1
a561 1
	if (sc->sc_csr->s_cr & CR_TXP) {
d626 1
a626 1
	csr->s_cr = CR_TXP;
d633 2
a634 2
void sonictxint __P((struct sn_softc *));
void sonicrxint __P((struct sn_softc *));
d636 2
a637 2
int sonic_read __P((struct sn_softc *, caddr_t, int));
struct mbuf *sonic_get __P((struct sn_softc *, struct ether_header *, int));
d642 1
a642 1
void 
d649 1
d651 7
a657 2
	for (i = 0; i < MAXCAM; i++)
		SWO(bitmode, p_cda, (CDA_CAMDESC * i + CDA_CAMEP), i);
d661 1
a661 1
void 
d669 1
a669 1
	int		camoffset = entry * CDA_CAMDESC;
d675 2
a676 1
	SWO(bitmode, p_cda, CDA_ENABLE, (1 << entry));
d679 1
a679 1
void 
d683 42
a724 2
	struct sonic_reg *csr;
	int     timeout;
d726 6
a731 4
	csr = sc->sc_csr;
	csr->s_cdp = LOWER(sc->v_cda);
	csr->s_cdc = MAXCAM;
	csr->s_cr = CR_LCAM;
d735 1
a735 1
	while (csr->s_cr & CR_LCAM && timeout--)
d743 1
a743 1
	while ((csr->s_isr & ISR_LCD) == 0 && timeout--)
d746 2
a747 2
	if (csr->s_isr & ISR_LCD)
		csr->s_isr = ISR_LCD;
d754 1
a754 1
void 
a757 1
	struct sonic_reg *csr = sc->sc_csr;
d761 1
a761 1
	csr->s_cr = CR_RST;
d766 1
a766 1
		csr->s_cep = i;
d768 3
a770 3
		ap2 = csr->s_cap2;
		ap1 = csr->s_cap1;
		ap0 = csr->s_cap0;
d773 1
a773 1
	printf("CAM enable 0x%lx\n", csr->s_cep);
d775 1
a775 1
	csr->s_cr = 0;
d780 1
a780 1
void 
a783 1
	struct sonic_reg *csr;
a786 2
	csr = sc->sc_csr;

d797 2
a798 2
	csr->s_utda = UPPER(sc->mtda[0].mtd_vtxp);
	csr->s_ctda = LOWER(sc->mtda[0].mtd_vtxp);
d801 1
a801 1
void 
a804 1
	struct sonic_reg *csr;
a807 2
	csr = sc->sc_csr;

d821 2
a822 2
	SWR(csr->s_urda, UPPER(sc->v_rda[0]));
	SWR(csr->s_crda, LOWER(sc->v_rda[0]));
d826 1
a826 1
void 
a829 1
	struct sonic_reg *csr;
d834 2
a835 4
	csr = sc->sc_csr;

	if (bitmode)
		csr->s_eobc = RBASIZE(sc) / 2 - 2; /* must be >= MAXETHERPKT */
d837 3
a839 3
		csr->s_eobc = RBASIZE(sc) / 2 - 1; /* must be >= MAXETHERPKT */
	csr->s_urra = UPPER(sc->v_rra[0]);
	csr->s_rsa = LOWER(sc->v_rra[0]);
d841 2
a842 2
	csr->s_rea = LOWER(sc->v_rea);
	csr->s_rrp = LOWER(sc->v_rra[0]);
d853 1
a853 1
	csr->s_rwp = LOWER(sc->v_rra[sc->sc_rramark]);
d857 1
a857 1
void 
d866 1
a866 1
static void
a871 1
	struct sonic_reg *csr = sc->sc_csr;
d874 1
a874 1
	while ((isr = (csr->s_isr & ISR_ALL)) != 0) {
d876 1
a876 1
		csr->s_isr = isr;
d931 1
a931 1
void 
a935 1
	struct sonic_reg *csr;
a941 2
	csr = sc->sc_csr;

d978 2
a979 2
				csr->s_ctda = LOWER(mtd->mtd_vtxp);
				csr->s_cr = CR_TXP;
d990 1
a990 1
void 
a993 1
	struct sonic_reg	*csr = sc->sc_csr;
d1052 1
a1052 1
		csr->s_rwp = LOWER(sc->v_rra[rramark]);
d1077 1
a1077 1
int 
a1088 3
         * Deal with trailer protocol: if type is PUP trailer
         * get true type from first 16-bit word past data.
         * Remember that type was trailer by setting off.
d1134 1
a1134 1
struct mbuf *
@


1.15
log
@Flip around Takeshi Yanagisawa's name.  Add back a physaccess() call that I was a bit hasty
in removing.
@
text
@d1 2
a2 1
/*	$OpenBSD: if_sn.c,v 1.14 1997/03/17 12:20:22 briggs Exp $	*/
d131 3
a133 3
/*
 * Disable caching on the SONIC's data space.
 */
d137 4
a140 4
/*
 * Put the pup in reset mode (sninit() will fix it later)
 * and clear any interrupts.
 */
d146 5
a150 5
/*
 * because the SONIC is basically 16bit device it 'concatenates'
 * a higher buffer address to a 16 bit offset--this will cause wrap
 * around problems near the end of 64k !!
 */
d677 2
a678 1
		panic("sonic: CAM initialisation failed\n");
d687 2
a688 1
		printf("sonic: CAM initialisation without interrupt\n");
d829 2
a830 1
			printf("sonic: unexpected interrupt status 0x%x\n", isr);
d848 1
d850 2
a851 1
				printf("sonic: receive descriptors exhausted\n");
d853 2
a854 1
				printf("sonic: receive buffers exhausted\n");
d856 2
a857 1
				printf("sonic: receive buffer area exhausted\n");
d859 2
a860 1
				printf("sonic: receive FIFO overrun\n");
d922 3
a924 2
			printf("sonic: Tx packet status=0x%x\n",
				SRO(sc->bitmode, txp, TXP_STATUS));
d961 2
a962 1
			printf("sonic: more than one packet in RBA!\n");
d1055 2
a1056 1
		printf("sonic: invalid packet length %d bytes\n", len);
@


1.14
log
@*Blush*  It's Denton, not Dennis, Gentry.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn.c,v 1.13 1997/03/17 04:26:15 briggs Exp $	*/
d14 1
a14 1
 *   Takeshi Yanagisawa <yanagisw@@aa.ap.titech.ac.jp>
d129 6
@


1.13
log
@Fix typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn.c,v 1.12 1997/03/17 04:20:54 briggs Exp $	*/
d12 1
a12 1
 *   Dennis Gentry <denny1@@home.com>
@


1.12
log
@A couple of cleanup items suggested by is@@netbsd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn.c,v 1.11 1997/03/17 04:04:32 briggs Exp $	*/
d360 1
a360 1
		IF_PREPEND(ifp->if_snd, m);
@


1.11
log
@Integrate a couple of changes suggested by Scott Reynolds and Takeshi Yanagisawa.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn.c,v 1.10 1997/03/14 14:11:34 briggs Exp $	*/
d334 1
a334 1
	IF_DEQUEUE(&sc->sc_if.if_snd, m);
d347 2
a348 2
	if (sc->sc_if.if_bpf)
		bpf_mtap(sc->sc_if.if_bpf, m);
d360 1
a360 1
		IF_PREPEND(sc->sc_if.if_snd, m);
d370 1
a370 1
	sc->sc_if.if_opackets++;	/* # of pkts */
d516 1
a516 1
		temp = sc->sc_if.if_flags & IFF_UP;
d518 1
a518 1
		sc->sc_if.if_flags |= temp;
d1048 2
a1049 2
	if (sc->sc_if.if_bpf) {
		bpf_tap(sc->sc_if.if_bpf, pkt,
@


1.10
log
@Updates from Yanagisawa and Denny.  This seems to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn.c,v 1.8 1996/10/28 14:46:25 briggs Exp $	*/
d11 5
a130 9
 * Disable caching on register and DMA space.
 */
	physaccess((caddr_t) sc->sc_csr, (caddr_t) kvtop((caddr_t) sc->sc_csr),
		SN_REGSIZE, PG_V | PG_RW | PG_CI);

	physaccess((caddr_t) sc->space, (caddr_t) kvtop((caddr_t) sc->space),
		sizeof(sc->space), PG_V | PG_RW | PG_CI);

/*
a333 4
	if (sc->sc_csr->s_cr & CR_TXP) {
		return;
	}

d356 6
a361 5
	len = sonicput(sc, m);
#if 0
	if (len != m->m_pkthdr.len) {
		printf("snstart: len %d != m->m_pkthdr.len %d.\n",
			len, m->m_pkthdr.len);
a362 4
#endif
	len = m->m_pkthdr.len;

	m_freem(m);
d540 4
@


1.9
log
@Bring in some fresh SONIC code from Dennis Gentry and Yanagisawa Takeshi.
Much hacked by me to merge and partially busify.
Add code that I lost a while back for digging the proper mac address for
internal ethernet.
Still needs work, but checkpointed--works at least as well as the last
version.
@
text
@d1 1
a1 2
/*      $OpenBSD: if_sn.c,v 1.8 1996/10/28 14:46:25 briggs Exp $       
*/
d56 7
a62 2
#define SWR(a, x)       (a) = (x)
#define SRD(a)	  ((a) & 0xffff)
d69 1
a69 2
static int sonicput32 __P((struct sn_softc *sc, struct mbuf *m0));
static int sonicput16 __P((struct sn_softc *sc, struct mbuf *m0));
a73 4
static void sntxint16 __P((struct sn_softc *));
static void sntxint32 __P((struct sn_softc *));
static void snrxint16 __P((struct sn_softc *));
static void snrxint32 __P((struct sn_softc *));
d75 1
d77 3
a79 1
void camdump __P((struct sn_softc *sc));
d85 2
a86 2
#define assert(e)       ((void)0)
#define _assert(e)      ((void)0)
d88 1
a88 1
#define _assert(e)      assert(e)
d90 3
a92 3
#define assert(e)       ((e) ? (void)0 : __assert("sn ", __FILE__, __LINE__, #e))
#else   /* PCC */
#define assert(e)       ((e) ? (void)0 : __assert("sn "__FILE__, __LINE__, "e"))
d98 7
a104 1
#define ROUNDUP(p, N)   (((int) p + N - 1) & ~(N - 1))
d110 3
a112 2
 * Nicely aligned pointers into the SONIC buffers
 * p_ points at physical (K1_SEG) addresses.
a113 21

/* Meta transmit descriptors */
struct mtd {
	struct mtd	*mtd_link;
	void		*mtd_txp;
	int		mtd_vtxp;
	unsigned char	*mtd_buf;
} mtda[NTDA];

struct mtd *mtdfree;	    /* list of free meta transmit descriptors */
struct mtd *mtdhead;	    /* head of descriptors assigned to chip */
struct mtd *mtdtail;	    /* tail of descriptors assigned to chip */
struct mtd *mtdnext;	    /* next descriptor to give to chip */

void mtd_free __P((struct mtd *));
struct mtd *mtd_alloc __P((void));

struct cfdriver sn_cd = {
	NULL, "sn", DV_IFNET
};

d150 1
d152 4
a155 5
	if ((RRASIZE + CDASIZE + RDASIZE + TDASIZE) > NBPG) {
		printf ("sn: sizeof RRA (%d) + CDA (%d) + "
			"RDA (%d) + TDA (%d) > NBPG (%d).  Punt!\n",
			RRASIZE, CDASIZE, RDASIZE, TDASIZE, NBPG);
		return;
d157 1
d159 1
a159 4
	p = pp;
	sc->p_rra = (void *) p;
	sc->v_rra = kvtop((caddr_t) sc->p_rra);
	p += RRASIZE;
d162 4
a165 2
	sc->v_cda = kvtop((caddr_t) sc->p_cda);
	p += CDASIZE;
d167 27
a193 7
	sc->p_rda = (void *) p;
	sc->v_rda = kvtop((caddr_t) sc->p_rda);
	p += RDASIZE;

	sc->p_tda = (void *) p;
	sc->v_tda = kvtop((caddr_t) sc->p_tda);
	p += TDASIZE;
d217 2
a218 2
printf("sonic buffers: rra=0x%x cda=0x%x rda=0x%x tda=0x%x\n",
	sc->p_rra, sc->p_cda, sc->p_rda, sc->p_tda);
a226 1

a229 1

a232 7
	if (sc->sc_is16) {
		sc->rxint = snrxint16;
		sc->txint = sntxint16;
	} else {
		sc->rxint = snrxint32;
		sc->txint = sntxint32;
	}
d245 1
a245 1
	int     temp;
d274 1
a274 2
		 * If the state of the promiscuous bit changes, the
interface
d326 1
a326 1
	int     len;
d338 4
d364 1
a364 5
	if (sc->sc_is16) {
		len = sonicput16(sc, m);
	} else {
		len = sonicput32(sc, m);
	}
d382 1
a382 1
	sc->sc_sum.ls_opacks++;	 /* # of pkts */
d393 1
a393 1
void camentry __P((struct sn_softc *, int, unsigned char *));
d426 1
a426 1
	csr->s_cr = CR_RST;     /* s_dcr only accessable reset mode! */
d429 1
a429 1
	csr->s_dcr = sc->s_dcr;
d491 2
a492 2
	while ((mtd = mtdhead) != NULL) {
		mtdhead = mtdhead->mtd_link;
d494 1
a494 1
		mtd_free(mtd);
a495 1
	mtdnext = mtd_alloc();
d515 2
a516 2
	int temp;
	u_long status;
d518 1
a518 1
	if (mtdhead && mtdhead->mtd_buf) {
d520 2
a521 7
		if (sc->sc_is16) {
			status = ((struct _short_TXpkt *)
				  mtdhead->mtd_txp)->status;
		} else {
			status = ((struct TXpkt *) mtdhead->mtd_txp)->status;
		}
		if (status == 0)
d526 1
a526 1
				 sc->sc_dev.dv_xname);
d534 1
a534 1
 * stuff packet into sonic (at splnet) (16-bit)
d537 1
a537 1
sonicput16(sc, m0)
d541 10
a550 7
	struct sonic_reg *csr = sc->sc_csr;
	unsigned char   *buff, *buffer, *data;
	struct _short_TXpkt *txp;
	struct mtd *mtdnew;
	struct mbuf *m;
	unsigned int len = 0;
	unsigned int totlen = 0;
d553 1
a553 2
	if ((mtdnew = mtd_alloc()) == 0)
		return (0);
d555 2
a556 7
	/* We are guaranteed, if we get here, that the xmit buffer is free. */
	buff = buffer = sc->tbuf[sc->txb_new];
	
	/* this packet goes to mdtnext fill in the TDA */
	mtdnext->mtd_buf = buffer;
	txp = mtdnext->mtd_txp;
	SWR(txp->config, 0);
d558 2
a559 9
	for (m = m0; m; m = m->m_next) {
		data = mtod(m, u_char *);
		len = m->m_len;
		totlen += len;
		bcopy(data, buff, len);
		buff += len;
	}
	if (totlen >= TXBSIZE) {
		panic("packet overflow in sonicput.");
a560 63
	SWR(txp->u[0].frag_ptrlo, LOWER(sc->vtbuf[sc->txb_new]));
	SWR(txp->u[0].frag_ptrhi, UPPER(sc->vtbuf[sc->txb_new]));
	SWR(txp->u[0].frag_size, totlen);

	if (totlen < ETHERMIN + sizeof(struct ether_header)) {
		int pad = ETHERMIN + sizeof(struct ether_header) - totlen;
		bzero(buffer + totlen, pad);
		SWR(txp->u[0].frag_size, pad + SRD(txp->u[0].frag_size));
		totlen = ETHERMIN + sizeof(struct ether_header);
	}
	SWR(txp->frag_count, 1);
	SWR(txp->pkt_size, totlen);

	/* link onto the next mtd that will be used */
	SWR(txp->u[1].tlink, LOWER(mtdnew->mtd_vtxp) | EOL);

	if (mtdhead == 0) {
		/* no current transmit list start with this one */
		mtdtail = mtdhead = mtdnext;
		csr->s_ctda = LOWER(mtdnext->mtd_vtxp);
	} else {
		/*
		 * have a transmit list append it to end note
		 * mtdnext is already physicaly linked to mtdtail in
		 * mtdtail->mtd_txp->u[mtdtail->mtd_txp->frag_count].tlink
		 */
		struct _short_TXpkt *tp;

		tp = (struct _short_TXpkt *) mtdtail->mtd_txp;
		SWR(tp->u[tp->frag_count].tlink,
			SRD(tp->u[tp->frag_count].tlink) & ~EOL);
		mtdtail = mtdnext;
	}
	mtdnext->mtd_link = mtdnew;
	mtdnext = mtdnew;

	/* make sure chip is running */
	wbflush();
	csr->s_cr = CR_TXP;
	wbflush();
	sc->sc_if.if_timer = 5; /* 5 seconds to watch for failing to transmit */
	return (totlen);
}

/*
 * 32-bit version of sonicput
 */
static int 
sonicput32(sc, m0)
	struct sn_softc *sc;
	struct mbuf *m0;
{
	struct sonic_reg *csr = sc->sc_csr;
	unsigned char   *buff, *buffer, *data;
	struct TXpkt *txp;
	struct mtd *mtdnew;
	struct mbuf *m;
	unsigned int len = 0;
	unsigned int totlen = 0;

	/* grab the replacement mtd */
	if ((mtdnew = mtd_alloc()) == 0)
		return (0);
d563 1
a563 1
	buff = buffer = sc->tbuf[sc->txb_new];
d565 4
a568 4
	/* this packet goes to mdtnext fill in the TDA */
	mtdnext->mtd_buf = buffer;
	txp = mtdnext->mtd_txp;
	SWR(txp->config, 0);
d571 1
a571 1
		data = mtod(m, u_char *);
d580 4
a583 3
	SWR(txp->u[0].frag_ptrlo, LOWER(sc->vtbuf[sc->txb_new]));
	SWR(txp->u[0].frag_ptrhi, UPPER(sc->vtbuf[sc->txb_new]));
	SWR(txp->u[0].frag_size, totlen);
a587 1
		SWR(txp->u[0].frag_size, pad + SRD(txp->u[0].frag_size));
d590 5
a594 2
	SWR(txp->frag_count, 1);
	SWR(txp->pkt_size, totlen);
d597 2
a598 1
	SWR(txp->u[1].tlink, LOWER(mtdnew->mtd_vtxp) | EOL);
d600 7
a606 11
	if (mtdhead == 0) {
		/* no current transmit list start with this one */
		mtdtail = mtdhead = mtdnext;
		csr->s_ctda = LOWER(mtdnext->mtd_vtxp);
	} else {
		/*
		 * have a transmit list append it to end note
		 * mtdnext is already physicaly linked to mtdtail in
		 * mtdtail->mtd_txp->u[mtdtail->mtd_txp->frag_count].tlink
		 */
		struct TXpkt *tp;
d608 2
a609 7
		tp = (struct TXpkt *) mtdtail->mtd_txp;
		SWR(tp->u[tp->frag_count].tlink,
			SRD(tp->u[tp->frag_count].tlink) & ~EOL);
		mtdtail = mtdnext;
	}
	mtdnext->mtd_link = mtdnew;
	mtdnext = mtdnew;
d615 2
a616 1
	sc->sc_if.if_timer = 5; /* 5 seconds to watch for failing to transmit */
d620 3
a625 20
void 
mtd_free(mtd)
	struct mtd *mtd;
{
	mtd->mtd_link = mtdfree;
	mtdfree = mtd;
}

struct mtd *
mtd_alloc()
{
	struct mtd *mtd = mtdfree;

	if (mtd) {
		mtdfree = mtd->mtd_link;
		mtd->mtd_link = 0;
	}
	return (mtd);
}

d633 7
a639 17
	int     i;

	if (sc->sc_is16) {
		struct _short_CDA *p_cda;

		p_cda = (struct _short_CDA *) sc->p_cda;
		for (i = 0; i < MAXCAM; i++)
			SWR(p_cda->desc[i].cam_ep, i);
		SWR(p_cda->enable, 0);
	} else {
		struct CDA *p_cda;

		p_cda = (struct CDA *) sc->p_cda;
		for (i = 0; i < MAXCAM; i++)
			SWR(p_cda->desc[i].cam_ep, i);
		SWR(p_cda->enable, 0);
	}
a643 1
	struct sn_softc *sc;
d646 1
d648 9
a656 19
	if (sc->sc_is16) {
		struct _short_CDA *p_cda;

		p_cda = (struct _short_CDA *) sc->p_cda;
		SWR(p_cda->desc[entry].cam_ep, entry);
		SWR(p_cda->desc[entry].cam_ap2, (ea[5] << 8) | ea[4]);
		SWR(p_cda->desc[entry].cam_ap1, (ea[3] << 8) | ea[2]);
		SWR(p_cda->desc[entry].cam_ap0, (ea[1] << 8) | ea[0]);
		SWR(p_cda->enable, SRD(p_cda->enable) | (1 << entry));
	} else {
		struct CDA *p_cda;

		p_cda = (struct CDA *) sc->p_cda;
		SWR(p_cda->desc[entry].cam_ep, entry);
		SWR(p_cda->desc[entry].cam_ap2, (ea[5] << 8) | ea[4]);
		SWR(p_cda->desc[entry].cam_ap1, (ea[3] << 8) | ea[2]);
		SWR(p_cda->desc[entry].cam_ap0, (ea[1] << 8) | ea[0]);
		SWR(p_cda->enable, SRD(p_cda->enable) | (1 << entry));
	}
d723 1
a723 2
	int     i, psize;
	u_long	p;
a726 6
	mtdfree = mtdhead = mtdtail = (struct mtd *) 0;

	p = (u_long) sc->p_tda;
	psize = (sc->sc_is16 ?
			sizeof(struct _short_TXpkt) : sizeof(struct TXpkt));

d728 1
a728 3
		mtd = &mtda[i];
		mtd->mtd_txp = (struct TXpkt *) p;
		mtd->mtd_vtxp = kvtop((caddr_t) mtd->mtd_txp);
a729 2
		mtd_free(mtd);
		p += psize;
a730 1
	mtdnext = mtd_alloc();
d732 7
a738 1
	csr->s_utda = UPPER(sc->v_tda);
d746 1
d752 6
a757 12
	if (sc->sc_is16) {
		int			v_rda;
		struct _short_RXpkt	*p_rda;

		p_rda = (struct _short_RXpkt *) sc->p_rda;
		for (i = 0; i < (NRDA - 1); i++) {
			SWR(p_rda[i].rlink,
			 LOWER(v_rda + (i + 1) * sizeof(struct _short_RXpkt)));
			SWR(p_rda[i].in_use, 1);
		}
		SWR(p_rda[NRDA - 1].rlink, LOWER(v_rda) | EOL);
		SWR(p_rda[NRDA - 1].in_use, 1);
d759 2
a760 19
		/* mark end of receive descriptor list */
		sc->sc_lrxp = &p_rda[NRDA - 1];
	} else {
		int		v_rda;
		struct RXpkt	*p_rda;

		v_rda = sc->v_rda;
		p_rda = (struct RXpkt *) sc->p_rda;
		for (i = 0; i < (NRDA - 1); i++) {
			SWR(p_rda[i].rlink,
				LOWER(v_rda + (i + 1) * sizeof(struct RXpkt)));
			SWR(p_rda[i].in_use, 1);
		}
		SWR(p_rda[NRDA - 1].rlink, LOWER(v_rda) | EOL);
		SWR(p_rda[NRDA - 1].in_use, 1);

		/* mark end of receive descriptor list */
		sc->sc_lrxp = &p_rda[NRDA - 1];
	}
d764 2
a765 2
	csr->s_urda = UPPER(sc->v_rda);
	csr->s_crda = LOWER(sc->v_rda);
d774 3
a776 2
	int     i;
	int	rr_size;
d780 9
a788 11
	if (sc->sc_is16) {
		rr_size = sizeof(struct _short_RXrsrc);
		csr->s_eobc = RBASIZE(sc) / 2 - 1;  /* must be >= MAXETHERPKT */
	} else {
		rr_size = sizeof(struct RXrsrc);
		csr->s_eobc = RBASIZE(sc) / 2 - 2;  /* must be >= MAXETHERPKT */
	}
	csr->s_urra = UPPER(sc->v_rra);
	csr->s_rsa = LOWER(sc->v_rra);
	csr->s_rea = LOWER(sc->v_rra + (NRRA * rr_size));
	csr->s_rrp = LOWER(sc->v_rra);
d791 6
a796 20
	if (sc->sc_is16) {
		struct _short_RXrsrc *p_rra;

		p_rra = (struct _short_RXrsrc *) sc->p_rra;
		for (i = 0; i < NRBA; i++) {
			SWR(p_rra[i].buff_ptrhi, UPPER(kvtop(sc->rbuf[i])));
			SWR(p_rra[i].buff_ptrlo, LOWER(kvtop(sc->rbuf[i])));
			SWR(p_rra[i].buff_wchi, UPPER(RBASIZE(sc) / 2));
			SWR(p_rra[i].buff_wclo, LOWER(RBASIZE(sc) / 2));
		}
	} else {
		struct RXrsrc *p_rra;

		p_rra = (struct RXrsrc *) sc->p_rra;
		for (i = 0; i < NRBA; i++) {
			SWR(p_rra[i].buff_ptrhi, UPPER(kvtop(sc->rbuf[i])));
			SWR(p_rra[i].buff_ptrlo, LOWER(kvtop(sc->rbuf[i])));
			SWR(p_rra[i].buff_wchi, UPPER(RBASIZE(sc) / 2));
			SWR(p_rra[i].buff_wclo, LOWER(RBASIZE(sc) / 2));
		}
d799 1
a799 1
	csr->s_rwp = LOWER(sc->v_rra + (sc->sc_rramark * rr_size));
d814 2
a815 2
	void    *arg;
	int     slot;
d817 1
a817 1
	struct sn_softc *sc = (struct sn_softc *)arg;
d819 1
a819 1
	int     isr;
d830 1
a830 1
			(*sc->txint)(sc);
d833 1
a833 1
			(*sc->rxint)(sc);
d870 1
a870 1
 * Transmit interrupt routine (16-bit)
d872 2
a873 2
static void 
sntxint16(sc)
d876 1
a876 1
	struct _short_TXpkt *txp;
d878 2
a879 1
	struct mtd *mtd;
d881 1
a881 1
	if (mtdhead == (struct mtd *) 0)
d886 2
a887 1
	while ((mtd = mtdhead) != NULL) {
d891 1
a891 1
		txp = (struct _short_TXpkt *) mtd->mtd_txp;
d893 2
a894 2
		if (SRD(txp->status) == 0)      /* it hasn't really gone yet */
			return;
d901 2
a902 2
			    txp->status,
			    txp->pkt_size,
d909 1
a909 3
		mtdhead = mtd->mtd_link;

		mtd_free(mtd);
d913 3
a915 2
		if ((SRD(txp->status) & TCR_PTX) == 0) {
			printf("sonic: Tx packet status=0x%x\n", txp->status);
d918 1
a918 1
			if (mtdhead != mtdnext) {
d920 2
a921 1
				csr->s_ctda = LOWER(mtdhead->mtd_vtxp);
a927 2
	/* mtdhead should be at mtdnext (go) */
	mtdhead = 0;
d931 1
a931 1
 * Transmit interrupt routine (32-bit)
d933 2
a934 63
static void 
sntxint32(sc)
	struct sn_softc *sc;
{
	struct TXpkt *txp;
	struct sonic_reg *csr;
	struct mtd *mtd;

	if (mtdhead == (struct mtd *) 0)
		return;

	csr = sc->sc_csr;

	while ((mtd = mtdhead) != NULL) {
		if (mtd->mtd_buf == 0)
			break;

		txp = mtd->mtd_txp;

		if (SRD(txp->status) == 0)      /* it hasn't really gone yet */
			return;

		if (ethdebug) {
			struct ether_header *eh;

			eh = (struct ether_header *) mtd->mtd_buf;
			printf("xmit status=0x%lx len=%ld type=0x%x from %s",
			    txp->status,
			    txp->pkt_size,
			    htons(eh->ether_type),
			    ether_sprintf(eh->ether_shost));
			printf(" (to %s)\n", ether_sprintf(eh->ether_dhost));
		}
		sc->txb_inuse--;
		mtd->mtd_buf = 0;
		mtdhead = mtd->mtd_link;

		mtd_free(mtd);

		/* XXX - Do stats here. */

		if ((SRD(txp->status) & TCR_PTX) == 0) {
			printf("sonic: Tx packet status=0x%lx\n", txp->status);

			/* XXX - DG This looks bogus */
			if (mtdhead != mtdnext) {
				printf("resubmitting remaining packets\n");
				csr->s_ctda = LOWER(mtdhead->mtd_vtxp);
				csr->s_cr = CR_TXP;
				wbflush();
				return;
			}
		}
	}
	/* mtdhead should be at mtdnext (go) */
	mtdhead = 0;
}

/*
 * Receive interrupt routine (16-bit)
 */
static void 
snrxint16(sc)
d938 2
a939 3
	struct _short_RXpkt	*rxp, *p_rda;
	struct _short_RXrsrc	*p_rra;
	int			orra;
d941 5
d947 1
a947 3
	p_rra = (struct _short_RXrsrc *) sc->p_rra;
	p_rda = (struct _short_RXpkt *) sc->p_rda;
	rxp = &p_rda[sc->sc_rxmark];
d949 2
a950 2
	while (SRD(rxp->in_use) == 0) {
		unsigned status = SRD(rxp->status);
d954 3
a956 3
		orra = RBASEQ(SRD(rxp->seq_no)) & RRAMASK;
		len = SRD(rxp->byte_count)
				- sizeof(struct ether_header) - FCSSIZE;
a972 64
		 */
		p_rra[sc->sc_rramark] = p_rra[orra];

		/* zap old rra for fun */
		p_rra[orra].buff_wchi = 0;
		p_rra[orra].buff_wclo = 0;

		sc->sc_rramark = (sc->sc_rramark + 1) & RRAMASK;
		csr->s_rwp = LOWER(sc->v_rra +
			(sc->sc_rramark * sizeof(struct _short_RXrsrc)));
		wbflush();

		/*
		 * give receive descriptor back to chip simple
		 * list is circular
		 */
		SWR(rxp->in_use, 1);
		SWR(rxp->rlink, SRD(rxp->rlink) | EOL);
		SWR(((struct _short_RXpkt *) sc->sc_lrxp)->rlink,
		    SRD(((struct _short_RXpkt *) sc->sc_lrxp)->rlink) & ~EOL);
		sc->sc_lrxp = (void *) rxp;

		if (++sc->sc_rxmark >= NRDA)
			sc->sc_rxmark = 0;
		rxp = &p_rda[sc->sc_rxmark];
	}
}

/*
 * Receive interrupt routine (normal 32-bit)
 */
static void 
snrxint32(sc)
	struct sn_softc *sc;
{
	struct sonic_reg  *csr = sc->sc_csr;
	struct RXpkt      *rxp, *p_rda;
	struct RXrsrc	  *p_rra;
	int		  orra;
	int		  len;

	p_rra = (struct RXrsrc *) sc->p_rra;
	p_rda = (struct RXpkt *) sc->p_rda;
	rxp = &p_rda[sc->sc_rxmark];

	while (SRD(rxp->in_use) == 0) {
		unsigned status = SRD(rxp->status);
		if ((status & RCR_LPKT) == 0)
			printf("sonic: more than one packet in RBA!\n");

		orra = RBASEQ(SRD(rxp->seq_no)) & RRAMASK;
		len = SRD(rxp->byte_count)
				- sizeof(struct ether_header) - FCSSIZE;
		if (status & RCR_PRX) {
			if (sonic_read(sc, sc->rbuf[orra & RBAMASK], len)) {
				sc->sc_if.if_ipackets++;
				sc->sc_sum.ls_ipacks++;
				sc->sc_missed = 0;
			}
		} else
			sc->sc_if.if_ierrors++;

		/*
		 * give receive buffer area back to chip.
d974 3
a976 4
		 * orra is now empty of packets and can be freed if
		 * sonic read didnt copy it out then we would have to
		 * wait !!
		 * (dont bother add it back in again straight away)
d978 11
a988 1
		p_rra[sc->sc_rramark] = p_rra[orra];
d991 2
a992 2
		p_rra[orra].buff_wchi = 0;
		p_rra[orra].buff_wclo = 0;
d994 2
a995 3
		sc->sc_rramark = (sc->sc_rramark + 1) & RRAMASK;
		csr->s_rwp = LOWER(sc->v_rra +
			(sc->sc_rramark * sizeof(struct RXrsrc)));
d1002 7
a1008 5
		SWR(rxp->in_use, 1);
		SWR(rxp->rlink, SRD(rxp->rlink) | EOL);
		SWR(((struct RXpkt *) sc->sc_lrxp)->rlink,
			SRD(((struct RXpkt *) sc->sc_lrxp)->rlink) & ~EOL);
		sc->sc_lrxp = (void *) rxp;
d1012 1
a1012 1
		rxp = &p_rda[sc->sc_rxmark];
d1031 5
a1035 5
	 * Get pointer to ethernet header (in input buffer).
	 * Deal with trailer protocol: if type is PUP trailer
	 * get true type from first 16-bit word past data.
	 * Remember that type was trailer by setting off.
	 */
d1053 1
a1053 2
	 * not destined for us (but be sure to keep
broadcast/multicast).
d1072 1
a1072 1
#define sonicdataaddr(eh, off, type)      ((type)(((caddr_t)((eh)+1)+(off))))
d1088 3
a1090 3
	char	*spkt = sonicdataaddr(eh, 0, caddr_t);
	char	*epkt = spkt + datalen;
	char	*cp = spkt;
d1118 2
a1119 2
			 * Place initial small packet/header at end of mbuf.
			 */
@


1.8
log
@Include macinfo.h.
@
text
@d1 2
a2 1
/*	$OpenBSD: if_sn.c,v 1.7 1996/10/19 10:02:53 niklas Exp $	*/
a13 2
#include "sn.h"

d39 2
a46 3
#define NTXB	10	/* Number of xmit buffers */

#define SONICDW 32
d49 1
a50 1
#include <machine/macinfo.h>
d52 2
a53 1
#include <mac68k/dev/if_sn.h>
d55 4
a58 2
#define SWR(a, x) 	(a) = (x)
#define SRD(a)		((a) & 0xffff)
a61 52
/*
 * Statistics collected over time
 */
struct sn_stats {
	int     ls_opacks;	/* packets transmitted */
	int     ls_ipacks;	/* packets received */
	int     ls_tdr;		/* contents of tdr after collision */
	int     ls_tdef;	/* packets where had to wait */
	int     ls_tone;	/* packets with one retry */
	int     ls_tmore;	/* packets with more than one retry */
	int     ls_tbuff;	/* transmit buff errors */
	int     ls_tuflo;	/* "      uflo  "     */
	int     ls_tlcol;
	int     ls_tlcar;
	int     ls_trtry;
	int     ls_rbuff;	/* receive buff errors */
	int     ls_rfram;	/* framing     */
	int     ls_roflo;	/* overflow    */
	int     ls_rcrc;
	int     ls_rrng;	/* rx ring sequence error */
	int     ls_babl;	/* chip babl error */
	int     ls_cerr;	/* collision error */
	int     ls_miss;	/* missed packet */
	int     ls_merr;	/* memory error */
	int     ls_copies;	/* copies due to out of range mbufs */
	int     ls_maxmbufs;	/* max mbufs on transmit */
	int     ls_maxslots;	/* max ring slots on transmit */
};

struct sn_softc {
	struct	device sc_dev;
	struct	arpcom sc_arpcom;
#define	sc_if		sc_arpcom.ac_if		/* network visible interface */
#define	sc_enaddr	sc_arpcom.ac_enaddr	/* hardware ethernet address */

	struct sonic_reg *sc_csr;	/* hardware pointer */
	int	sc_rxmark;		/* position in rx ring for reading buffs */

	int	sc_rramark;		/* index into rra of wp */

	int	sc_txhead;		/* index of first TDA passed to chip  */
	int	sc_missed;		/* missed packet counter */

	int	txb_cnt;		/* total number of xmit buffers */
	int	txb_inuse;		/* number of active xmit buffers */
	int	txb_new;		/* index of next open slot. */

	struct	RXpkt *sc_lrxp;		/* last RDA available to chip */
	struct	sn_stats sc_sum;
	short	sc_iflags;
} sn_softc;

a62 3
static int snmatch __P((struct device *, void *, void *));
static void snattach __P((struct device *, struct device *, void *));
static int sngetaddr __P((struct sn_softc *sc));
d65 3
a67 2
static int sonicput __P((struct sn_softc *sc, struct mbuf *m0));
static int snintr __P((struct sn_softc *, int));
d71 5
a78 8
struct cfattach sn_ca = {
	sizeof(struct sn_softc), snmatch, snattach
};

struct cfdriver sn_cd = {
	NULL, "sn", DV_IFNET
};

d83 2
a84 2
#define	assert(e)	((void)0)
#define	_assert(e)	((void)0)
d86 1
a86 1
#define	_assert(e)	assert(e)
d88 3
a90 3
#define	assert(e)	((e) ? (void)0 : __assert("sn ", __FILE__, __LINE__, #e))
#else	/* PCC */
#define	assert(e)	((e) ? (void)0 : __assert("sn "__FILE__, __LINE__, "e"))
d96 1
a96 11
/*
 * SONIC buffers need to be aligned 16 or 32 bit aligned.
 * These macros calculate and verify alignment.
 */
#if SONICDW == 32
#define SONICALIGN 4
#else
#define SONICALIGN 2
#endif
#define SOALIGN(array) (((int)array+SONICALIGN-1) & ~(SONICALIGN-1))
#define SOALIGNED(p) (!(((uint)p)&(SONICALIGN-1)))
a101 40
 * buffer sizes in 32 bit mode
 * 1 TXpkt is 4 hdr words + (3 * FRAGMAX) + 1 link word
 * FRAGMAX == 16 => 54 words == 216 bytes
 *
 * 1 RxPkt is 7 words == 28 bytes
 * 1 Rda   is 4 words == 16 bytes
 */

#define NRRA	32		/* # receive resource descriptors */
#define RRAMASK	0x1f		/* the reason why it must be power of two */

#define NRBA	16		/* # receive buffers < NRRA */
#define NRDA	NRBA		/* # receive descriptors */
#define NTDA	4		/* # transmit descriptors */

#define CDASIZE sizeof(struct CDA)
#define RRASIZE (NRRA*sizeof(struct RXrsrc))
#define RDASIZE (NRDA*sizeof(struct RXpkt))
#define TDASIZE (NTDA*sizeof(struct TXpkt))

#define FCSSIZE	4		/* size of FCS append te received packets */

/*
 * maximum receive packet size plus 2 byte pad to make each
 * one aligned. 4 byte slop (required for eobc)
 */
#define RBASIZE	(sizeof(struct ether_header) + ETHERMTU	+ FCSSIZE + 2 + 4)

/*
 * space required for descriptors
 */
#define DESC_SIZE (RRASIZE + CDASIZE + RDASIZE + TDASIZE + SONICALIGN - 1)

/*
 * 16k transmit buffer area
 */
#define TXBSIZE	1536	/* 6*2^8 -- the same size as the 8390 TXBUF */
#define TBASIZE	(TXBSIZE * NTXB)

/*
a104 6
struct RXrsrc	*p_rra;	/* receiver resource descriptors */
struct RXpkt	*p_rda;	/* receiver desriptors */
struct TXpkt	*p_tda;	/* transmitter descriptors */
struct CDA	*p_cda;	/* CAM descriptors */
char		*p_rba;	/* receive buffer area base */
char		*p_tba;	/* transmit buffer area base */
d108 4
a111 3
	struct	mtd *mtd_link;
	struct	TXpkt *mtd_txp;
	unsigned char *mtd_buf;
d114 4
a117 4
struct mtd *mtdfree;		/* list of free meta transmit descriptors */
struct mtd *mtdhead;		/* head of descriptors assigned to chip */
struct mtd *mtdtail;		/* tail of descriptors assigned to chip */
struct mtd *mtdnext;		/* next descriptor to give to chip */
d122 7
a128 4
static int
snmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d130 4
a133 2
	if (!mac68k_machine.sonic)
		return 0;
d135 1
a135 2
	return 1;
}
d138 1
a138 3
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
d140 2
a141 19
static void
snattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
{
extern	unsigned char	SONICSPACE;
extern	unsigned long	SONICSPACE_size;
	struct sn_softc *sc = (void *)self;
	struct ifnet *ifp = &sc->sc_if;
	int base, p, pp;

	/* Must allocate extra memory in case we need to round later. */
	pp = (DESC_SIZE + NRBA*RBASIZE + 0x10000 + 4 + TBASIZE);
	if (pp != SONICSPACE_size) {
		printf(": SONICSPACE_size (%ld) != pp (%d).  Punt!\n",
			SONICSPACE_size, pp);
		return;
	}
	base = p = (int) &SONICSPACE;
d143 2
a144 2
#define SONIC_IO_OFFSET	0xA000
	sc->sc_csr = (struct sonic_reg *)(IOBase + SONIC_IO_OFFSET);
d160 13
a172 3
	if ((p ^ (p + RRASIZE + CDASIZE)) & 0x10000)
		p = (p + 0x10000) & ~0xffff;
	p_rra = (struct RXrsrc *) p;
d175 2
a176 1
	p_cda = (struct CDA *) p;
d179 2
a180 3
	if ((p ^ (p + RDASIZE)) & 0x10000)
		p = (p + 0x10000) & ~0xffff;
	p_rda = (struct RXpkt *) p;
d183 2
a184 3
	if ((p ^ (p + TDASIZE)) & 0x10000)
		p = (p + 0x10000) & ~0xffff;
	p_tda = (struct TXpkt *) p;
d187 1
a187 3
	p = SOALIGN(p);
	p_rba = (char *) p;
	p += NRBA * RBASIZE;
d189 13
a201 1
	p_tba = (char *) p;
d206 1
a206 3
	sngetaddr(sc);
	printf(" address %s, ", ether_sprintf(sc->sc_enaddr));
	printf("SONIC ethernet--%d bytes at 0x%x.\n", pp, base);
d209 2
a210 2
printf("sonic buffers: rra=0x%x cda=0x%x rda=0x%x tda=0x%x rba=0x%x tba=0x%x\n",
	p_rra, p_cda, p_rda, p_tda, p_rba, p_tba);
d219 1
d223 1
d227 8
a234 2
	add_nubus_intr(9, (void (*) __P((void *, int))) snintr, (void *) sc);
	enable_nubus_intr();
d246 1
a246 6
	int	temp, error;

	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}
d275 2
a276 1
		 * If the state of the promiscuous bit changes, the interface
d328 1
a328 1
	int	len;
d362 6
a367 2
	len = sonicput(sc, m);
#if DIAGNOSTIC
d384 1
a384 1
	sc->sc_sum.ls_opacks++;		/* # of pkts */
d394 2
a395 2
void caminitialise __P((void));
void camentry __P((int, unsigned char *ea));
d428 1
a428 1
	csr->s_cr = CR_RST;	/* s_dcr only accessable reset mode! */
d431 1
a431 2
	csr->s_dcr = DCR_LBR | DCR_SYNC | DCR_WAIT0 | DCR_DW32 | DCR_DMABLOCK |
	    DCR_RFT16 | DCR_TFT16;
d433 1
a433 1
	csr->s_imr = IMR_PRXEN | IMR_PTXEN | IMR_TXEREN | IMR_HBLEN | IMR_LCDEN;
d453 2
a454 2
	caminitialise();
	camentry(0, sc->sc_enaddr);
d519 1
d523 7
a529 1
		if (mtdhead->mtd_txp->status == 0)
d534 1
a534 1
			   	 sc->sc_dev.dv_xname);
d542 1
a542 1
 * stuff packet into sonic (at splnet)
d545 1
a545 1
sonicput(sc, m0)
d550 2
a551 2
	unsigned char	*buff, *buffer, *data;
	struct TXpkt *txp;
d554 2
a555 1
	int len = 0, totlen = 0;
d562 1
a562 1
	buff = buffer = p_tba + sc->txb_new * TXBSIZE;
d579 2
a580 2
	SWR(txp->u[0].frag_ptrlo, LOWER(buffer));
	SWR(txp->u[0].frag_ptrhi, UPPER(buffer));
d583 1
a583 1
	if (len < ETHERMIN + sizeof(struct ether_header)) {
a584 1
printf("Padding %d to %d bytes\n", totlen, totlen+pad);
d593 1
a593 1
	SWR(txp->u[0].tlink, LOWER(mtdnew->mtd_txp) | EOL);
d598 1
a598 1
		csr->s_ctda = LOWER(txp);
d605 5
a609 2
		SWR(mtdtail->mtd_txp->u[mtdtail->mtd_txp->frag_count].tlink,
		    SRD(mtdtail->mtd_txp->u[mtdtail->mtd_txp->frag_count].tlink) & ~EOL);
d619 1
a619 1
	sc->sc_if.if_timer = 5;	/* 5 seconds to watch for failing to transmit */
d624 1
a624 3
 *  Read out the ethernet address from the cam. It is stored
 *  there by the boot when doing a loopback test. Thus we don't
 *  have to fetch it from nv ram.
d627 1
a627 1
sngetaddr(sc)
d629 1
d631 57
a687 1
	unsigned i;
d689 9
a697 1
	sc->sc_csr->s_cr = CR_RST;
d699 1
a699 2
	sc->sc_csr->s_cep = 15; /* For some reason, Apple fills top first. */
	i = sc->sc_csr->s_cap2;
d701 2
a702 14
	sc->sc_enaddr[5] = i >> 8;
	sc->sc_enaddr[4] = i;
	i = sc->sc_csr->s_cap1;
	wbflush();
	sc->sc_enaddr[3] = i >> 8;
	sc->sc_enaddr[2] = i;
	i = sc->sc_csr->s_cap0;
	wbflush();
	sc->sc_enaddr[1] = i >> 8;
	sc->sc_enaddr[0] = i;

	sc->sc_csr->s_cr = 0;
	wbflush();
	return (0);
d705 1
a705 4
void sonictxint __P((struct sn_softc *));
void sonicrxint __P((struct sn_softc *));

int sonic_read __P((struct sn_softc *, struct RXpkt *));
d732 2
a733 1
caminitialise()
d737 15
a751 3
	for (i = 0; i < MAXCAM; i++)
		SWR(p_cda->desc[i].cam_ep, i);
	SWR(p_cda->enable, 0);
d755 2
a756 1
camentry(entry, ea)
d760 19
a778 5
	SWR(p_cda->desc[entry].cam_ep, entry);
	SWR(p_cda->desc[entry].cam_ap2, (ea[5] << 8) | ea[4]);
	SWR(p_cda->desc[entry].cam_ap1, (ea[3] << 8) | ea[2]);
	SWR(p_cda->desc[entry].cam_ap0, (ea[1] << 8) | ea[0]);
	SWR(p_cda->enable, SRD(p_cda->enable) | (1 << entry));
d789 1
a789 1
	csr->s_cdp = LOWER(p_cda);
d845 2
a846 1
	int     i;
d852 4
d858 2
a859 1
		mtd->mtd_txp = &p_tda[i];
d862 1
d866 1
a866 1
	csr->s_utda = UPPER(p_tda);
d879 31
a909 3
	for (i = 0; i < (NRDA - 1); i++) {
		SWR(p_rda[i].rlink, LOWER(&p_rda[i + 1]));
		SWR(p_rda[i].in_use, 1);
a910 5
	SWR(p_rda[NRDA - 1].rlink, LOWER(&p_rda[0]) | EOL);
	SWR(p_rda[NRDA - 1].in_use, 1);

	/* mark end of receive descriptor list */
	sc->sc_lrxp = &p_rda[NRDA - 1];
d914 2
a915 2
	csr->s_urda = UPPER(&p_rda[0]);
	csr->s_crda = LOWER(&p_rda[0]);
d925 1
d929 11
a939 5
	csr->s_eobc = RBASIZE / 2 - 2;	/* must be >= MAXETHERPKT */
	csr->s_urra = UPPER(p_rra);
	csr->s_rsa = LOWER(p_rra);
	csr->s_rea = LOWER(&p_rra[NRRA]);
	csr->s_rrp = LOWER(p_rra);
d942 20
a961 5
	for (i = 0; i < NRBA; i++) {
		SWR(p_rra[i].buff_ptrhi, UPPER(&p_rba[i * RBASIZE]));
		SWR(p_rra[i].buff_ptrlo, LOWER(&p_rba[i * RBASIZE]));
		SWR(p_rra[i].buff_wchi, UPPER(RBASIZE / 2));
		SWR(p_rra[i].buff_wclo, LOWER(RBASIZE / 2));
d964 1
a964 1
	csr->s_rwp = LOWER(&p_rra[sc->sc_rramark]);
d977 4
a980 4
static int 
snintr(sc, slot)
	struct sn_softc *sc;
	int	slot;
d982 1
d984 1
a984 1
	int	isr;
a986 1
printf("snintr: %x.\n", isr);
d995 1
a995 1
			sonictxint(sc);
d998 1
a998 1
			sonicrxint(sc);
d1002 8
a1009 1
				printf("sonic: no heartbeat\n");
d1031 1
a1031 1
	return (1);
d1035 1
a1035 1
 * Transmit interrupt routine
d1037 63
a1099 2
void 
sonictxint(sc)
d1117 1
a1117 1
		if (SRD(txp->status) == 0)	/* it hasn't really gone yet */
d1142 1
d1145 1
a1145 1
				csr->s_ctda = LOWER(mtdhead->mtd_txp);
a1152 2
	assert(mtdhead == mtdnext);
	assert(mtdhead->mtd_link == 0);
d1157 1
a1157 1
 * Receive interrupt routine
d1159 2
a1160 2
void 
sonicrxint(sc)
d1163 5
a1167 3
	struct sonic_reg *csr = sc->sc_csr;
	struct RXpkt *rxp;
	int     orra;
d1169 2
a1176 1
		assert(PSNSEQ(SRD(rxp->seq_no)) == 0);
d1178 3
d1182 1
a1182 1
			if (sonic_read(sc, rxp)) {
d1191 21
a1211 3
		 * give receive buffer area back to chip XXX what buffer
		 * did the sonic use for this descriptor answer look at
		 * the rba sequence number !! 
d1213 34
d1248 10
a1257 4

		assert(SRD(rxp->pkt_ptrhi) == SRD(p_rra[orra].buff_ptrhi));
		assert(SRD(rxp->pkt_ptrlo) == SRD(p_rra[orra].buff_ptrlo));
		assert(SRD(p_rra[orra].buff_wclo));
d1260 2
d1274 2
a1275 1
		csr->s_rwp = LOWER(&p_rra[sc->sc_rramark]);
d1284 3
a1286 2
		SWR(sc->sc_lrxp->rlink, SRD(sc->sc_lrxp->rlink) & ~EOL);
		sc->sc_lrxp = rxp;
d1299 1
a1299 1
sonic_read(sc, rxp)
d1301 2
a1302 1
	struct RXpkt *rxp;
a1304 1
	/*extern char *ether_sprintf();*/
a1306 2
	int     len;
	caddr_t	pkt;
d1309 5
a1313 9
         * Get input data length.
         * Get pointer to ethernet header (in input buffer).
         * Deal with trailer protocol: if type is PUP trailer
         * get true type from first 16-bit word past data.
         * Remember that type was trailer by setting off.
         */

	len = SRD(rxp->byte_count) - sizeof(struct ether_header) - FCSSIZE;
	pkt = (caddr_t)((SRD(rxp->pkt_ptrhi) << 16) | SRD(rxp->pkt_ptrlo));
d1317 2
a1318 2
		printf("rcvd 0x%p status=0x%lx, len=%d type=0x%x from %s",
		    et, rxp->status, len, htons(et->ether_type),
d1331 2
a1332 1
	 * not destined for us (but be sure to keep broadcast/multicast).
d1351 1
a1351 1
#define sonicdataaddr(eh, off, type)       ((type)(((caddr_t)((eh)+1)+(off))))
d1367 3
a1369 3
	char   *spkt = sonicdataaddr(eh, 0, caddr_t);
	char   *epkt = spkt + datalen;
	char *cp = spkt;
d1397 2
a1398 2
		         * Place initial small packet/header at end of mbuf.
		         */
@


1.7
log
@__assert added, impl from netbsd, however put elsewhere. use it instead
of private versions (one even using the userland header) in if_sn.c
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn.c,v 1.6 1996/09/21 03:34:55 briggs Exp $	*/
d52 1
@


1.6
log
@Remove include of assert.h and fix a format error in debug camdump() code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sn.c,v 1.5 1996/05/26 18:35:25 briggs Exp $	*/
d143 1
a143 1
#define	assert(e)	((e) ? (void)0 : __assert(__FILE__, __LINE__, #e))
d145 1
a145 1
#define	assert(e)	((e) ? (void)0 : __assert(__FILE__, __LINE__, "e"))
a147 10

void
__assert(file, line, failedexpr)
	const char *file, *failedexpr;
	int line;
{
	(void)printf(
	    "assertion \"%s\" failed: file \"%s\", line %d\n",
	    failedexpr, file, line);
}
@


1.5
log
@Add OpenBSD Id string.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 15
a148 1
#include <assert.h>
d858 1
a858 1
	printf("CAM enable 0x%x\n", csr->s_cep);
@


1.4
log
@Sync with NetBSD-current.
@
text
@d1 2
@


1.3
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d50 1
d52 1
d89 3
a91 3
	struct	arpcom sc_ac;
#define	sc_if		sc_ac.ac_if	/* network visible interface */
#define	sc_enaddr	sc_ac.ac_enaddr	/* hardware ethernet address */
d110 17
a126 2
int snmatch __P((struct device *, void *, void *));
void snattach __P((struct device *, struct device *, void *));
d128 2
a129 2
struct cfdriver sncd = {
	NULL, "sn", snmatch, snattach, DV_IFNET, sizeof(struct sn_softc)
a142 35
void 
m_check(m)
	struct mbuf *m;
{
	if (m->m_flags & M_EXT) {
		assert(m->m_len >= 0);
		assert(m->m_len <= m->m_ext.ext_size);
		assert(m->m_data >= &m->m_ext.ext_buf[0]);
		assert(m->m_data <= &m->m_ext.ext_buf[m->m_ext.ext_size]);
		assert(m->m_data + m->m_len <= &m->m_ext.ext_buf[m->m_ext.ext_size]);
	} else if (m->m_flags & M_PKTHDR) {
		assert(m->m_len >= 0);
		assert(m->m_len <= MHLEN);
		assert(m->m_data >= m->m_pktdat);
		assert(m->m_data <= &m->m_pktdat[MHLEN]);
		assert(m->m_data + m->m_len <= &m->m_pktdat[MHLEN]);
	} else {
		assert(m->m_len >= 0);
		assert(m->m_len <= MLEN);
		assert(m->m_data >= m->m_dat);
		assert(m->m_data <= &m->m_dat[MLEN]);
		assert(m->m_data + m->m_len <= &m->m_dat[MLEN]);
	}
}

void 
m_checkm(m)
	struct mbuf *m;
{
	while (m) {
		m_check(m);
		m = m->m_next;
	}
}

a144 6
int snintr __P((struct sn_softc *));
int snioctl __P((struct ifnet *ifp, u_long cmd, caddr_t data));
void snstart __P((struct ifnet *ifp));
void snwatchdog __P(( /*int unit */ ));
void snreset __P((struct sn_softc *sc));

d226 1
a226 8
int sngetaddr __P((struct sn_softc *sc));
int sninit __P((int unit));
int snstop __P((int unit));
int sonicput __P((struct sn_softc *sc, struct mbuf *m0));

void camdump __P((struct sn_softc *sc));

int
a230 6
	struct cfdata *cf = match;
	struct confargs *ca = aux;

	if (matchbyname(parent, cf, aux) == 0)
		return 0;

d242 1
a242 1
void
a249 1
	struct confargs *ca = aux;
a250 1
	struct cfdata *cf = sc->sc_dev.dv_cfdata;
d256 1
a256 1
		printf(": SONICSPACE_size (%d) != pp (%d).  Punt!\n",
d315 2
a316 5
	add_nubus_intr(9, snintr, (void *) sc);
	enable_nubus_intr();

	ifp->if_name = "sn";
	ifp->if_unit = sc->sc_dev.dv_unit;
d326 3
d331 1
a331 1
int
d338 1
a338 1
	struct sn_softc *sc = sncd.cd_devs[ifp->if_unit];
d340 1
a340 1
	int	temp;
d355 2
a356 2
			(void)sninit(ifp->if_unit);
			arp_ifinit(&sc->sc_ac, ifa);
d360 1
a360 1
			(void)sninit(ifp->if_unit);
d368 1
a368 1
			snstop(ifp->if_unit);
d372 1
a372 1
			(void)sninit(ifp->if_unit);
d391 2
a392 1
			err = ether_addmulti((struct ifreq *)data, &sc->sc_ac);
d394 2
a395 1
			err = ether_delmulti((struct ifreq *)data, &sc->sc_ac);
d420 1
a420 1
void
d424 1
a424 1
	struct sn_softc *sc = sncd.cd_devs[ifp->if_unit];
d500 1
a500 1
void
d505 2
a506 2
	snstop(sc->sc_dev.dv_unit);
	sninit(sc->sc_dev.dv_unit);
d509 3
a511 3
int 
sninit(unit)
	int unit;
a512 1
	struct sn_softc *sc = sncd.cd_devs[unit];
d514 1
a514 1
	int s, error;
a566 4

bad:
	snstop(sc->sc_dev.dv_unit);
	return (error);
d574 3
a576 3
int 
snstop(unit)
	int unit;
a577 1
	struct sn_softc *sc = sncd.cd_devs[unit];
d588 1
a588 1
	while (mtd = mtdhead) {
d608 3
a610 3
void
snwatchdog(unit)
	int unit;
d612 1
a612 1
	struct sn_softc *sc = sncd.cd_devs[unit];
d618 2
a619 2
			log(LOG_ERR, "%s%d: Tx - timeout\n",
			    sc->sc_if.if_name, sc->sc_if.if_unit);
d621 2
a622 2
			log(LOG_ERR, "%s%d: Tx - lost interrupt\n",
			    sc->sc_if.if_name, sc->sc_if.if_unit);
d632 1
a632 1
int 
d642 1
a642 1
	int i, len = 0, totlen = 0;
d713 1
a713 1
int 
d717 1
a717 2
	unsigned i, x, y;
	char   *cp, *ea;
a796 1
	int     i;
a929 2
	int     i;

d935 2
a936 2
int 
snintr(sc)
d938 1
d943 1
a943 1
	while (isr = (csr->s_isr & ISR_ALL)) {
d1001 1
a1001 1
	while (mtd = mtdhead) {
d1014 1
a1014 1
			printf("xmit status=0x%x len=%d type=0x%x from %s",
d1030 1
a1030 1
			printf("sonic: Tx packet status=0x%x\n", txp->status);
a1055 1
	u_long  addr;
d1130 1
a1130 1
	int     len, off, i;
d1146 1
a1146 1
		printf("rcvd 0x%x status=0x%x, len=%d type=0x%x from %s",
d1169 1
a1169 1
			return;
@


1.2
log
@include cpu.h.
@
text
@a35 10
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#ifdef RMP
#include <netrmp/rmp.h>
#include <netrmp/rmp_var.h>
#endif

d381 5
a397 17
#ifdef NS
		case AF_NS:
			{
				struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);

				if (ns_nullhost(*ina)) {
					ina->x_host = *(union ns_host *)(sc->sc_enaddr);
				} else {
					/* XXX
					 * add an extra i/f address to
					 * sonic filter
					 */
				}
			}
			(void)sninit(ifp->if_unit);
			break;
#endif	/* NS */
@


1.1
log
@Preliminary cut at SONIC driver.  Quadra only at this point.
Still apparently not getting interrupts for some reason, so this is more
or less just a checkpoint.
@
text
@d59 1
@
