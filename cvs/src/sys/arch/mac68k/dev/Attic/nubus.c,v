head	1.35;
access;
symbols
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.16
	OPENBSD_5_0:1.34.0.14
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.12
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.10
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.6
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.8
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.6
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.27.0.4
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.27
	UBC:1.24.0.2
	UBC_BASE:1.24
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9:1.14.0.12
	OPENBSD_2_9_BASE:1.14
	NIKLAS_UNDEAD:1.14.0.10
	OPENBSD_2_8:1.14.0.8
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.6
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.12.0.10
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.8
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.6
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.4
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.34;

1.34
date	2008.05.19.18.42.12;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.10.17.47.54;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.14.09.36.49;	author martin;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.01.17.04.52;	author martin;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.26.21.09.35;	author martin;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.28.14.04.24;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.09.00.59.26;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.29.06.26.50;	author pvalchev;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.03.15.55;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.10.00.58.04;	author miod;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.12.08.02.24.06;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.20.21.29.23;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.11.23.21.13;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.27.04.22.37;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.08.08.09.00;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.08.17.30.40;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	99.09.03.18.01.09;	author art;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.04.24.06.39.40;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	97.04.24.02.10.15;	author gene;	state Exp;
branches;
next	1.11;

1.11
date	97.04.23.13.38.35;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.04.08.04.14.46;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.03.12.13.15.58;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.03.08.16.16.56;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.01.35.35;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.21.45.54;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.09.21.03.36.58;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.18.35.32;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.13.47;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.01.14.20.58.54;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.07.04.10.18.28;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2002.03.06.01.05.35;	author niklas;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.14.4.6;

1.14.4.6
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.14.4.7;

1.14.4.7
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	;

1.24.2.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.35
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: nubus.c,v 1.34 2008/05/19 18:42:12 miod Exp $	*/
/*	$NetBSD: nubus.c,v 1.53 2002/04/13 17:49:41 briggs Exp $	*/

/*
 * Copyright (c) 1995, 1996 Allen Briggs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Allen Briggs.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/conf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/vmparam.h>
#include <machine/param.h>
#include <machine/cpu.h>
#include <machine/pte.h>
#include <machine/viareg.h>

#include <mac68k/dev/nubus.h>

#ifdef DEBUG
#define NDB_PROBE	0x1
#define NDB_FOLLOW	0x2
#define NDB_ARITH	0x4
static int	nubus_debug = 0 /* | NDB_PROBE | NDB_FOLLOW | NDB_ARITH */ ;
#endif

static int	nubus_print(void *, const char *);
static int	nubus_match(struct device *, void *, void *);
static void	nubus_attach(struct device *, struct device *, void *);
static int	nubus_video_resource(int);

static int	nubus_probe_slot(bus_space_tag_t, bus_space_handle_t,
		    int, nubus_slot *);
static u_int32_t nubus_calc_CRC(bus_space_tag_t, bus_space_handle_t,
		    nubus_slot *);

static u_long	nubus_adjust_ptr(u_int8_t, u_long, long);
static u_int8_t	nubus_read_1(bus_space_tag_t, bus_space_handle_t,
		    u_int8_t, u_long);
#ifdef notyet
static u_int16_t nubus_read_2(bus_space_tag_t, bus_space_handle_t,
		    u_int8_t, u_long);
#endif
static u_int32_t nubus_read_4(bus_space_tag_t, bus_space_handle_t,
		    u_int8_t, u_long);

struct cfattach nubus_ca = {
	sizeof(struct nubus_softc), nubus_match, nubus_attach
};

struct cfdriver nubus_cd = {
	NULL, "nubus", DV_DULL,
};

static int
nubus_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	static int nubus_matched = 0;

	/* Allow only one instance. */
	if (nubus_matched)
		return (0);

	nubus_matched = 1;
	return (1);
}

static void
nubus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct nubus_attach_args na_args;
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	nubus_slot fmtblock;
	nubus_dir dir;
	nubus_dirent dirent;
	nubus_type slottype;
	u_long entry;
	int i, rsrcid;
	u_int8_t lanes;

	printf("\n");

	for (i = NUBUS_MIN_SLOT; i <= NUBUS_MAX_SLOT; i++) {
		na_args.slot = i;
		na_args.na_tag = bst = MAC68K_BUS_SPACE_MEM;

		if (bus_space_map(bst,
		    NUBUS_SLOT2PA(na_args.slot), NBMEMSIZE, 0, &bsh)) {
#ifdef DEBUG
			if (nubus_debug & NDB_PROBE)
				printf("%s: failed to map slot %x, "
				"address %p (in use?)\n",
				self->dv_xname, i,
				(void *)NUBUS_SLOT2PA(i));
#endif
			continue;
		}

		if (nubus_probe_slot(bst, bsh, i, &fmtblock) <= 0) {
notfound:
			bus_space_unmap(bst, bsh, NBMEMSIZE);
			continue;
		}

		rsrcid = 0x80;
		lanes = fmtblock.bytelanes;

		nubus_get_main_dir(&fmtblock, &dir);

		/*
		 * Get the resource for the first function on the card.
		 * This is assumed to be at resource ID 0x80.  If we can
		 * not find this entry (as we can not on some video cards),
		 * check to see if we can get a different ID from the list
		 * of video resources given to us by the booter.  If that
		 * doesn't work either, take the first resource following
		 * the board resource.
		 * If we only find a board resource, report that.
		 * There are cards that do not have anything else; their
		 * driver then has to match on the board resource and
		 * the card name.
		 */
		if (nubus_find_rsrc(bst, bsh,
		    &fmtblock, &dir, rsrcid, &dirent) <= 0) {
			if ((rsrcid = nubus_video_resource(i)) == -1) {
				int has_board_rsrc = 0;

				/*
				 * Since nubus_find_rsrc failed, the directory
				 * is back at its base.
				 */
				entry = dir.curr_ent;

				/*
				 * All nubus cards should have a board
				 * resource, but be sure that's what it
				 * is before we skip it, and note the fact.
				 */
				rsrcid = nubus_read_1(bst, bsh,
				    lanes, entry);
				if (rsrcid == 0x1) {
					has_board_rsrc = 1;
					entry = nubus_adjust_ptr(lanes,
					    dir.curr_ent, 4);
				}
				rsrcid = nubus_read_1(bst, bsh, lanes, entry);
				/* end of chain? */
				if (rsrcid == 0xff) {
					if (!has_board_rsrc)
						goto notfound;
					else
						rsrcid = 0x01;
				}
#ifdef DEBUG
				if (nubus_debug & NDB_FOLLOW)
					printf("\tUsing rsrc 0x%x.\n", rsrcid);
#endif
			}
			/*
			 * Try to find the resource passed by the booter
			 * or the one we just tracked down.
			 */
			if (nubus_find_rsrc(bst, bsh,
			    &fmtblock, &dir, rsrcid, &dirent) <= 0)
				goto notfound;
		}

		nubus_get_dir_from_rsrc(&fmtblock, &dirent, &dir);

		if (nubus_find_rsrc(bst, bsh,
		    &fmtblock, &dir, NUBUS_RSRC_TYPE, &dirent) <= 0)
			goto notfound;

		if (nubus_get_ind_data(bst, bsh, &fmtblock, &dirent,
		    (caddr_t)&slottype, sizeof(nubus_type)) <= 0)
			goto notfound;

		/*
		 * If this is a display card, try to pull out the correct
		 * display mode as passed by the booter.
		 */
		if (slottype.category == NUBUS_CATEGORY_DISPLAY) {
			int r;

			if ((r = nubus_video_resource(i)) != -1) {

				nubus_get_main_dir(&fmtblock, &dir);

				if (nubus_find_rsrc(bst, bsh,
				    &fmtblock, &dir, r, &dirent) <= 0)
					goto notfound;

				nubus_get_dir_from_rsrc(&fmtblock,
				    &dirent, &dir);

				if (nubus_find_rsrc(bst, bsh, &fmtblock, &dir,
				    NUBUS_RSRC_TYPE, &dirent) <= 0)
					goto notfound;

				if (nubus_get_ind_data(bst, bsh,
				    &fmtblock, &dirent, (caddr_t)&slottype,
				    sizeof(nubus_type)) <= 0)
					goto notfound;

				rsrcid = r;
			}
		}

		na_args.slot = i;
		na_args.rsrcid = rsrcid;
		na_args.category = slottype.category;
		na_args.type = slottype.type;
		na_args.drsw = slottype.drsw;
		na_args.drhw = slottype.drhw;
		na_args.fmt = &fmtblock;

		bus_space_unmap(bst, bsh, NBMEMSIZE);

		config_found(self, &na_args, nubus_print);
	}

	enable_nubus_intr();
}

static int
nubus_print(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct nubus_attach_args *na = (struct nubus_attach_args *)aux;
	bus_space_tag_t bst = na->na_tag;
	bus_space_handle_t bsh;

	if (pnp) {
		printf("%s slot %x", pnp, na->slot);
		if (bus_space_map(bst,
		    NUBUS_SLOT2PA(na->slot), NBMEMSIZE, 0, &bsh) == 0) {
			printf(": %s", nubus_get_card_name(bst, bsh, na->fmt));
			printf(" (Vendor: %s,", nubus_get_vendor(bst, bsh,
			    na->fmt, NUBUS_RSRC_VEND_ID));
			printf(" Part: %s)", nubus_get_vendor(bst, bsh,
			    na->fmt, NUBUS_RSRC_VEND_PART));

			bus_space_unmap(bst, bsh, NBMEMSIZE);
		}
#ifdef DIAGNOSTIC
		else
			printf(":");
		printf(" Type: %04x %04x %04x %04x",
		    na->category, na->type, na->drsw, na->drhw);
#endif
	} else {
		printf(" slot %x", na->slot);
	}
	return (UNCONF);
}

static int
nubus_video_resource(slot)
	int slot;
{
	extern u_int16_t mac68k_vrsrc_vec[];
	int i;

	for (i = 0 ; i < 6 ; i++)
		if ((mac68k_vrsrc_vec[i] & 0xff) == slot)
			return ((mac68k_vrsrc_vec[i] >> 8) & 0xff);
	return (-1);
}

/*
 * Probe a given nubus slot.  If a card is there and we can get the
 * format block from its clutching decl. ROMs, fill the format block
 * and return non-zero.  If we can't find a card there with a valid
 * decl. ROM, return 0.
 *
 * First, we check to see if we can access the memory at the tail
 * end of the slot.  If so, then we check for a bytelanes byte.  We
 * could probably just return a failure status if we bus error on
 * the first try, but there really is little reason not to go ahead
 * and check the other three locations in case there's a weird card
 * out there.
 *
 * Checking for a card involves locating the "bytelanes" byte which
 * tells us how to interpret the declaration ROM's data.  The format
 * block is at the top of the card's standard memory space and the
 * bytelanes byte is at the end of that block.
 *
 * After some inspection of the bytelanes byte, it appears that it
 * takes the form 0xXY where Y is a bitmask of the bytelanes in use
 * and X is a bitmask of the lanes to ignore.  Hence, (X ^ Y) == 0
 * and (less obviously), Y will have the upper N bits clear if it is
 * found N bytes from the last possible location.  Both that and
 * the exclusive-or check are made.
 *
 * If a valid
 */
static u_int8_t	nbits[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};
static int
nubus_probe_slot(bst, bsh, slot, fmt)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	int slot;
	nubus_slot *fmt;
{
	u_long ofs, hdr;
	int i, j, found, hdr_size;
	u_int8_t lanes;

#ifdef DEBUG
	if (nubus_debug & NDB_PROBE)
		printf("probing slot %x\n", slot);
#endif

	/*
	 * The idea behind this glorious work of art is to probe for only
	 * valid bytelanes values at appropriate locations (see DC&D p. 159
	 * for a list).  Note the pattern:  the first 8 values are at offset
	 * 0xffffff in the slot's space; the next 4 values at 0xfffffe; the
	 * next 2 values at 0xfffffd; and the last one at 0xfffffc.
	 *
	 * The nested loops implement an efficient search of this space,
	 * probing first for a valid address, then checking for each of the
	 * valid bytelanes values at that address.
	 */
	ofs = NBMEMSIZE;
	lanes = 0xf;

	for (j = 8, found = 0; j > 0 && !found; j >>= 1) {
		ofs--;
		for (i = j; i > 0; i--, lanes--) {
			if (!mac68k_bus_space_probe(bst, bsh, ofs, 1)) {
				lanes -= i;
				break;
			}
			if (bus_space_read_1(bst, bsh, ofs) ==
			    (((~lanes & 0xf) << 4) | lanes)) {
				found = 1;
				break;
			}
		}
	}

	if (!found) {
#ifdef DEBUG
		if (nubus_debug & NDB_PROBE)
			printf("bytelanes not found for slot %x\n", slot);
#endif
		return 0;
	}

	fmt->bytelanes = lanes;
	fmt->step = nbits[(lanes & 0x0f)];
	fmt->slot = slot;	/* XXX redundant; get rid of this someday */

#ifdef DEBUG
	if (nubus_debug & NDB_PROBE)
		printf("bytelanes of 0x%x found for slot 0x%x.\n",
		    fmt->bytelanes, slot);
#endif

	/*
	 * Go ahead and attempt to load format header.
	 * First, we need to find the first byte beyond memory that
	 * would be valid.  This is necessary for NUBUS_ROM_offset()
	 * to work.
	 */
	hdr = NBMEMSIZE;
	hdr_size = 20;

	i = 0x10 | (lanes & 0x0f);
	while ((i & 1) == 0) {
		hdr++;
		i >>= 1;
	}
	fmt->top = hdr;
	hdr = nubus_adjust_ptr(lanes, hdr, -hdr_size);
#ifdef DEBUG
	if (nubus_debug & NDB_PROBE)
		printf("fmt->top is 0x%lx, that minus 0x%x puts us at 0x%lx.\n",
		    fmt->top, hdr_size, hdr);
	if (nubus_debug & NDB_ARITH)
		for (i = 1 ; i < 8 ; i++)
			printf("0x%lx - 0x%x = 0x%lx, + 0x%x = 0x%lx.\n",
			    hdr, i, nubus_adjust_ptr(lanes, hdr, -i),
			    i, nubus_adjust_ptr(lanes, hdr,  i));
#endif

	fmt->directory_offset =
	    0xff000000 | nubus_read_4(bst, bsh, lanes, hdr);
	hdr = nubus_adjust_ptr(lanes, hdr, 4);
	fmt->length = nubus_read_4(bst, bsh, lanes, hdr);
	hdr = nubus_adjust_ptr(lanes, hdr, 4);
	fmt->crc = nubus_read_4(bst, bsh, lanes, hdr);
	hdr = nubus_adjust_ptr(lanes, hdr, 4);
	fmt->revision_level = nubus_read_1(bst, bsh, lanes, hdr);
	hdr = nubus_adjust_ptr(lanes, hdr, 1);
	fmt->format = nubus_read_1(bst, bsh, lanes, hdr);
	hdr = nubus_adjust_ptr(lanes, hdr, 1);
	fmt->test_pattern = nubus_read_4(bst, bsh, lanes, hdr);

#ifdef DEBUG
	if (nubus_debug & NDB_PROBE) {
		printf("Directory offset 0x%x\t", fmt->directory_offset);
		printf("Length 0x%x\t", fmt->length);
		printf("CRC 0x%x\n", fmt->crc);
		printf("Revision level 0x%x\t", fmt->revision_level);
		printf("Format 0x%x\t", fmt->format);
		printf("Test Pattern 0x%x\n", fmt->test_pattern);
	}
#endif

	if ((fmt->directory_offset & 0x00ff0000) == 0) {
		printf("Invalid looking directory offset (0x%x)!\n",
		    fmt->directory_offset);
		return 0;
	}
	if (fmt->test_pattern != NUBUS_ROM_TEST_PATTERN) {
		printf("Nubus--test pattern invalid:\n");
		printf("       slot 0x%x, bytelanes 0x%x?\n", fmt->slot, lanes);
		printf("       read test 0x%x, compare with 0x%x.\n",
		    fmt->test_pattern, NUBUS_ROM_TEST_PATTERN);
		return 0;
	}

	/* Perform CRC */
	if (fmt->crc != nubus_calc_CRC(bst, bsh, fmt)) {
		printf("Nubus--crc check failed, slot 0x%x.\n", fmt->slot);
		return 0;
	}

	return 1;
}

static u_int32_t
nubus_calc_CRC(bst, bsh, fmt)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	nubus_slot	*fmt;
{
#if 0
	u_long base, ptr, crc_loc;
	u_int32_t sum;
	u_int8_t lanes = fmt->bytelanes;

	base = fmt->top;
	crc_loc = NUBUS_ROM_offset(fmt, base, -12);
	ptr = NUBUS_ROM_offset(fmt, base, -fmt->length);

	sum = 0;
	while (ptr < base)
		roll #1, sum
		if (ptr == crc_loc) {
			roll #3, sum
			ptr = nubus_adjust_ptr(lanes, ptr, 3);
		} else {
			sum += nubus_read_1(bst, bsh, lanes, ptr);
		}
		ptr = nubus_adjust_ptr(lanes, ptr, 1);
	}

	return sum;
#endif
	return fmt->crc;
}

/*
 * Compute byte offset on card, taking into account bytelanes.
 * Base must be on a valid bytelane for this function to work.
 * Return the new address.
 *
 * XXX -- There has GOT to be a better way to do this.
 */
static u_long
nubus_adjust_ptr(lanes, base, amt)
	u_int8_t lanes;
	u_long base;
	long amt;
{
	u_int8_t b, t;

	if (!amt)
		return base;

	if (amt < 0) {
		amt = -amt;
		b = lanes;
		t = (b << 4);
		b <<= (3 - (base & 0x3));
		while (amt) {
			b <<= 1;
			if (b == t)
				b = lanes;
			if (b & 0x08)
				amt--;
			base--;
		}
		return base;
	}

	t = (lanes & 0xf) | 0x10;
	b = t >> (base & 0x3);
	while (amt) {
		b >>= 1;
		if (b == 1)
			b = t;
		if (b & 1)
			amt--;
		base++;
	}

	return base;
}

static u_int8_t
nubus_read_1(bst, bsh, lanes, ofs)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	u_int8_t lanes;
	u_long ofs;
{
	return bus_space_read_1(bst, bsh, ofs);
}

#ifdef notyet
/* Nothing uses this, yet */
static u_int16_t
nubus_read_2(bst, bsh, lanes, ofs)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	u_int8_t lanes;
	u_long ofs;
{
	u_int16_t s;

	s = (nubus_read_1(bst, bsh, lanes, ofs) << 8);
	ofs = nubus_adjust_ptr(lanes, ofs, 1);
	s |= nubus_read_1(bst, bsh, lanes, ofs);
	return s;
}
#endif

static u_int32_t
nubus_read_4(bst, bsh, lanes, ofs)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	u_int8_t lanes;
	u_long ofs;
{
	u_int32_t l;
	int i;

	l = 0;
	for (i = 0; i < 4; i++) {
		l = (l << 8) | nubus_read_1(bst, bsh, lanes, ofs);
		ofs = nubus_adjust_ptr(lanes, ofs, 1);
	}
	return l;
}

void
nubus_get_main_dir(fmt, dir_return)
	nubus_slot *fmt;
	nubus_dir *dir_return;
{
#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_get_main_dir(%p, %p)\n",
		    fmt, dir_return);
#endif
	dir_return->dirbase = nubus_adjust_ptr(fmt->bytelanes, fmt->top,
	    fmt->directory_offset - 20);
	dir_return->curr_ent = dir_return->dirbase;
}

void
nubus_get_dir_from_rsrc(fmt, dirent, dir_return)
	nubus_slot *fmt;
	nubus_dirent *dirent;
	nubus_dir *dir_return;
{
	u_long loc;

#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_get_dir_from_rsrc(%p, %p, %p).\n",
		    fmt, dirent, dir_return);
#endif
	if ((loc = dirent->offset) & 0x800000) {
		loc |= 0xff000000;
	}
	dir_return->dirbase =
	    nubus_adjust_ptr(fmt->bytelanes, dirent->myloc, loc);
	dir_return->curr_ent = dir_return->dirbase;
}

int
nubus_find_rsrc(bst, bsh, fmt, dir, rsrcid, dirent_return)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	nubus_slot *fmt;
	nubus_dir *dir;
	u_int8_t rsrcid;
	nubus_dirent *dirent_return;
{
	u_long entry;
	u_int8_t byte, lanes = fmt->bytelanes;

#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_find_rsrc(%p, %p, 0x%x, %p)\n",
		    fmt, dir, rsrcid, dirent_return);
#endif
	if (fmt->test_pattern != NUBUS_ROM_TEST_PATTERN)
		return -1;

	entry = dir->curr_ent;
	do {
		byte = nubus_read_1(bst, bsh, lanes, entry);
#ifdef DEBUG
		if (nubus_debug & NDB_FOLLOW)
			printf("\tFound rsrc 0x%x.\n", byte);
#endif
		if (byte == rsrcid) {
			dirent_return->myloc = entry;
			dirent_return->rsrc_id = rsrcid;
			entry = nubus_read_4(bst, bsh, lanes, entry);
			dirent_return->offset = (entry & 0x00ffffff);
			return 1;
		}
		if (byte == 0xff) {
			entry = dir->dirbase;
		} else {
			entry = nubus_adjust_ptr(lanes, entry, 4);
		}
	} while (entry != (u_long)dir->curr_ent);
	return 0;
}

int
nubus_get_ind_data(bst, bsh, fmt, dirent, data_return, nbytes)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	nubus_slot *fmt;
	nubus_dirent *dirent;
	caddr_t data_return;
	int nbytes;
{
	u_long loc;
	u_int8_t lanes = fmt->bytelanes;

#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_get_ind_data(%p, %p, %p, %d).\n",
		    fmt, dirent, data_return, nbytes);
#endif
	if ((loc = dirent->offset) & 0x800000) {
		loc |= 0xff000000;
	}
	loc = nubus_adjust_ptr(lanes, dirent->myloc, loc);

	while (nbytes--) {
		*data_return++ = nubus_read_1(bst, bsh, lanes, loc);
		loc = nubus_adjust_ptr(lanes, loc, 1);
	}
	return 1;
}

int
nubus_get_c_string(bst, bsh, fmt, dirent, data_return, max_bytes)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	nubus_slot *fmt;
	nubus_dirent *dirent;
	caddr_t data_return;
	int max_bytes;
{
	u_long loc;
	u_int8_t lanes = fmt->bytelanes;

#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_get_c_string(%p, %p, %p, %d).\n",
		    fmt, dirent, data_return, max_bytes);
#endif
	if ((loc = dirent->offset) & 0x800000)
		loc |= 0xff000000;

	loc = nubus_adjust_ptr(lanes, dirent->myloc, loc);

	*data_return = '\0';
	while (max_bytes--) {
		if ((*data_return++ =
		    nubus_read_1(bst, bsh, lanes, loc)) == 0)
			return 1;
		loc = nubus_adjust_ptr(lanes, loc, 1);
	}
	*(data_return-1) = '\0';
	return 0;
}

/*
 * Get list of address ranges for an sMemory resource
 * ->  DC&D, p.171
 */
int
nubus_get_smem_addr_rangelist(bst, bsh, fmt, dirent, data_return)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	nubus_slot *fmt;
	nubus_dirent *dirent;
	caddr_t data_return;
{
	u_long loc;
	u_int8_t lanes = fmt->bytelanes;
	long blocklen;
	caddr_t blocklist;

#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_get_smem_addr_rangelist(%p, %p, %p).\n",
		    fmt, dirent, data_return);
#endif
	if ((loc = dirent->offset) & 0x800000) {
		loc |= 0xff000000;
	}
	loc = nubus_adjust_ptr(lanes, dirent->myloc, loc);

	/* Obtain the block length from the head of the list */
	blocklen = nubus_read_4(bst, bsh, lanes, loc);

	/*
	 * malloc a block of (blocklen) bytes
	 * caller must recycle block after use
	 */
	blocklist = (caddr_t)malloc(blocklen, M_TEMP, M_WAITOK);

	/* read ((blocklen - 4) / 8) (length,offset) pairs into block */
	nubus_get_ind_data(bst, bsh, fmt, dirent, blocklist, blocklen);
#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW) {
		int ii;
		nubus_smem_rangelist *rlist;

		rlist = (nubus_smem_rangelist *)blocklist;
		printf("\tblock@@%p, len 0x0%X\n", rlist, rlist->length);

		for (ii=0; ii < ((blocklen - 4) / 8); ii++) {
			printf("\tRange %d: base addr 0x%X [0x%X]\n", ii,
			    rlist->range[ii].offset, rlist->range[ii].length);
		}
	}
#endif
	*(caddr_t *)data_return = blocklist;

	return 1;
}

static char	*huh = "???";

char *
nubus_get_vendor(bst, bsh, fmt, rsrc)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	nubus_slot *fmt;
	int rsrc;
{
	static char str_ret[64];
	nubus_dir dir;
	nubus_dirent ent;

#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_get_vendor(%p, 0x%x).\n", fmt, rsrc);
#endif
	nubus_get_main_dir(fmt, &dir);
	if (nubus_find_rsrc(bst, bsh, fmt, &dir, 1, &ent) <= 0)
		return huh;
	nubus_get_dir_from_rsrc(fmt, &ent, &dir);

	if (nubus_find_rsrc(bst, bsh, fmt, &dir, NUBUS_RSRC_VENDORINFO, &ent)
	    <= 0)
		return huh;
	nubus_get_dir_from_rsrc(fmt, &ent, &dir);

	if (nubus_find_rsrc(bst, bsh, fmt, &dir, rsrc, &ent) <= 0)
		return huh;

	nubus_get_c_string(bst, bsh, fmt, &ent, str_ret, 64);

	return str_ret;
}

char *
nubus_get_card_name(bst, bsh, fmt)
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	nubus_slot *fmt;
{
	static char name_ret[64];
	nubus_dir dir;
	nubus_dirent ent;

#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_get_card_name(%p).\n", fmt);
#endif
	nubus_get_main_dir(fmt, &dir);

	if (nubus_find_rsrc(bst, bsh, fmt, &dir, 1, &ent) <= 0)
		return huh;

	nubus_get_dir_from_rsrc(fmt, &ent, &dir);

	if (nubus_find_rsrc(bst, bsh, fmt, &dir, NUBUS_RSRC_NAME, &ent) <= 0)
		return huh;

	nubus_get_c_string(bst, bsh, fmt, &ent, name_ret, 64);

	return name_ret;
}

#ifdef DEBUG
void
nubus_scan_slot(bst, slotno)
	bus_space_tag_t bst;
	int slotno;
{
	int i=0, state=0;
	char twirl[] = "-\\|/";
	bus_space_handle_t sc_bsh;

	if (bus_space_map(bst, NUBUS_SLOT2PA(slotno), NBMEMSIZE, 0, &sc_bsh)) {
		printf("nubus_scan_slot: failed to map slot %x\n", slotno);
		return;
	}

	printf("Scanning slot %c for accessible regions:\n",
		slotno == 9 ? '9' : slotno - 10 + 'A');
	for (i=0 ; i<NBMEMSIZE; i++) {
		if (mac68k_bus_space_probe(bst, sc_bsh, i, 1)) {
			if (state == 0) {
				printf("\t0x%x-", i);
				state = 1;
			}
		} else {
			if (state) {
				printf("0x%x\n", i);
				state = 0;
			}
		}
		if (i%100 == 0) {
			printf("%c\b", twirl[(i/100)%4]);
		}
	}
	if (state) {
		printf("0x%x\n", i);
	}
	return;
}
#endif
@


1.34
log
@Change all remaining MD uses of MALLOC and FREE into proper malloc() and
free() calls; prodded by chl@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.33 2007/04/10 17:47:54 miod Exp $	*/
@


1.33
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.32 2006/04/14 09:36:49 martin Exp $	*/
d774 1
a774 1
	MALLOC(blocklist,caddr_t,blocklen,M_TEMP,M_WAITOK);
@


1.32
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.31 2005/05/01 17:04:52 martin Exp $	*/
d311 1
a311 1
 * format block from it's clutching decl. ROMs, fill the format block
@


1.31
log
@- Sync nubus IDs with NetBSD and add some more
- add support for reading sMemory resources from nubus cards (currently unused)
- support a bunch more nubus video cards. The Miro PRISMA GX seems to handle
  interrupts like the Radius DirectColor/GX, so just treat it the same.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.30 2005/04/26 21:09:35 martin Exp $	*/
d142 1
a142 1
  
@


1.30
log
@new NuBus slot space mapping/probing code utilizing bus_space(9)

ok miod@@

from NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: nubus.c,v 1.29 2004/11/28 14:04:24 miod Exp $	*/
/*	$NetBSD: nubus.c,v 1.45 1998/06/02 02:24:03 scottr Exp $	*/
d35 1
d56 1
a56 1
static int	nubus_debug = 0 /* | NDB_PROBE */;
d156 4
d164 2
d175 1
a175 1
				 * is before we skip it.
d179 2
a180 1
				if (rsrcid == 0x1)
d183 1
a183 1

d185 7
a195 2
				if (rsrcid == 0xff)	/* end of chain */
					goto notfound;
d738 57
@


1.29
log
@Correct pmap_enter() flags usage.
@
text
@d1 2
a2 2
/*	$OpenBSD: nubus.c,v 1.28 2003/05/09 00:59:26 art Exp $	*/
/*	$NetBSD: nubus.c,v 1.35 1997/04/22 20:20:32 scottr Exp $	*/
d49 1
a49 1
#include "nubus.h"
a51 1
static int	nubus_debug = 0x01;
d55 1
d61 1
a61 1
int		nubus_video_resource(int);
d63 8
a70 4
static int	probe_slot(int slot, nubus_slot *fmt);
static u_long	IncPtr(nubus_slot *fmt, u_long base, long amt);
static u_long	nubus_calc_CRC(nubus_slot *fmt);
static u_char	GetByte(nubus_slot *fmt, u_long ptr);
d72 2
a73 1
/* unused */ static u_short	GetWord(nubus_slot *fmt, u_long ptr);
d75 2
a76 3
static u_long	GetLong(nubus_slot *fmt, u_long ptr);

static int	nubus_peek(vm_offset_t, int);
d87 1
a87 1
nubus_match(parent, vcf, aux)
d89 1
a89 1
	void *vcf;
d108 2
d116 7
d124 9
a132 4
  	printf("\n");
  
  	for (i = NUBUS_MIN_SLOT; i <= NUBUS_MAX_SLOT; i++) {
		if (probe_slot(i, &fmtblock) <= 0)
d134 1
d136 6
d143 1
d156 2
a157 1
		if (nubus_find_rsrc(&fmtblock, &dir, rsrcid, &dirent) <= 0) {
d170 2
a171 1
				rsrcid = GetByte(&fmtblock, entry);
d173 2
a174 2
					entry =
					    IncPtr(&fmtblock, dir.curr_ent, 4);
d176 1
a176 1
				rsrcid = GetByte(&fmtblock, entry);
d181 2
a182 2
				if (rsrcid == 0xff)
					continue;	/* end of chain */
d188 3
a190 4
			if (nubus_find_rsrc(&fmtblock, &dir,
					    rsrcid, &dirent) <= 0) {
				continue;
			}
d195 7
a201 7
		if (nubus_find_rsrc(&fmtblock, &dir, NUBUS_RSRC_TYPE,
		    &dirent) <= 0)
			continue;

		if (nubus_get_ind_data(&fmtblock, &dirent,
		    (caddr_t) &slottype, sizeof(nubus_type)) <= 0)
			continue;
d208 1
a208 1
			int	r;
d214 3
a216 3
				if (nubus_find_rsrc(&fmtblock, &dir,
						    r, &dirent) <= 0)
					continue;
d219 1
a219 1
							&dirent, &dir);
d221 8
a228 8
				if (nubus_find_rsrc(&fmtblock, &dir,
						NUBUS_RSRC_TYPE, &dirent) <= 0)
					continue;

				if (nubus_get_ind_data(&fmtblock, &dirent,
						(caddr_t) &slottype,
						sizeof(nubus_type)) <= 0)
					continue;
d242 2
d245 1
a245 1
  	}
a246 3
	/*
	 * enable nubus interrupts here.
	 */
d251 1
a251 1
nubus_print(aux, name)
d253 1
a253 1
	const char *name;
d255 13
a267 1
	struct nubus_attach_args *na = (struct nubus_attach_args *) aux;
d269 2
a270 7
	if (name) {
		printf("%s: slot %x: %s", name, na->fmt->slot,
		    nubus_get_card_name(na->fmt));
		printf(" (Vendor: %s,",
		    nubus_get_vendor(na->fmt, NUBUS_RSRC_VEND_ID));
		printf(" Part: %s",
		    nubus_get_vendor(na->fmt, NUBUS_RSRC_VEND_PART));
d272 2
d277 2
d283 1
a283 1
int
d323 1
a323 1
static u_char	nbits[]={0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};
d325 5
a329 3
probe_slot(slot, fmt)
	int		slot;
	nubus_slot	*fmt;
d331 3
a333 12
	caddr_t		rom_probe;
	vm_offset_t	hdr;
#ifdef DEBUG
	vm_offset_t	pa;
#endif
	u_int		data;
	int		hdr_size, i;

	fmt->bytelanes = 0;
	fmt->slot = (u_long)slot;

	rom_probe = (caddr_t) (NUBUS_SLOT2PA(fmt->slot) + NBMEMSIZE);
d336 2
a337 5
	if (nubus_debug & NDB_PROBE) {
		pmap_extract(pmap_kernel(), (vm_offset_t) rom_probe - 1, &pa);
		printf("probing slot %d, first probe at %p (PA %lx).\n",
		    slot, rom_probe - 1, pa);
	}
d340 13
a352 1
	for (i = 4; i && (fmt->bytelanes == 0); i--) {
d354 12
a365 14
		rom_probe--;

		data = nubus_peek((vm_offset_t) rom_probe, 1);

		if (data == (u_int) -1)
			continue;

		if (data == 0)
			continue;

		if (   ((((data & 0xf0) >> 4) ^ (data & 0x0f)) == 0x0f)
		    && ((data & 0x0f) < (1 << i)) ) {
			fmt->bytelanes = data;
			fmt->step = nbits[(data & 0x0f)];
d368 2
d371 2
a372 3
	if (nubus_debug & NDB_PROBE)
		if (fmt->bytelanes == 0)
			printf("bytelanes not found for slot 0x%x.\n", slot);
d374 2
d377 3
a379 2
	if (fmt->bytelanes == 0)
		return 0;
d384 1
a384 1
			fmt->bytelanes, slot);
a386 2
	hdr_size = 20;

d393 2
a394 10
	hdr = (vm_offset_t)
		nubus_mapin(NUBUS_SLOT2PA(fmt->slot), NBMEMSIZE);
	if (hdr == NULL) {
		printf("Failed to map %d bytes for NuBUS slot %d probe.  ",
			NBMEMSIZE, fmt->slot);
		printf("Physical slot address %x\n",
			(unsigned int) NUBUS_SLOT2PA(fmt->slot));
	}
	fmt->virtual_base = hdr;
	hdr += NBMEMSIZE;
d396 1
a396 1
	i = 0x10 | (fmt->bytelanes & 0x0f);
d402 1
a402 1
	hdr = IncPtr(fmt, hdr, -hdr_size);
d406 20
a425 21
			fmt->top, hdr_size, hdr);
#if 0
	for (i=1 ; i < 8 ; i++) {
		printf("0x%x - 0x%x = 0x%x, + 0x%x = 0x%x.\n",
			hdr, i, IncPtr(fmt, hdr, -i),
			     i, IncPtr(fmt, hdr,  i));
	}
#endif
#endif

	fmt->directory_offset = 0xff000000 | GetLong(fmt, hdr);
	hdr = IncPtr(fmt, hdr, 4);
	fmt->length = GetLong(fmt, hdr);
	hdr = IncPtr(fmt, hdr, 4);
	fmt->crc = GetLong(fmt, hdr);
	hdr = IncPtr(fmt, hdr, 4);
	fmt->revision_level = GetByte(fmt, hdr);
	hdr = IncPtr(fmt, hdr, 1);
	fmt->format = GetByte(fmt, hdr);
	hdr = IncPtr(fmt, hdr, 1);
	fmt->test_pattern = GetLong(fmt, hdr);
d440 1
a440 1
			fmt->directory_offset);
d445 1
a445 2
		printf("       slot 0x%x, bytelanes 0x%x?\n",
			fmt->slot, fmt->bytelanes);
d447 1
a447 1
			fmt->test_pattern, NUBUS_ROM_TEST_PATTERN);
d452 2
a453 3
	if (fmt->crc != nubus_calc_CRC(fmt)) {
		printf("Nubus--crc check failed, slot 0x%x.\n",
			fmt->slot);
d460 32
d500 4
a503 4
IncPtr(fmt, base, amt)
	nubus_slot	*fmt;
	u_long		base;
	long		amt;
d505 1
a505 1
	u_char 	b, t;
d512 1
a512 1
		b = fmt->bytelanes;
d518 1
a518 1
				b = fmt->bytelanes;
d526 1
a526 1
	t = (fmt->bytelanes & 0xf) | 0x10;
d540 6
a545 33
static u_long
nubus_calc_CRC(fmt)
	nubus_slot	*fmt;
{
#if 0
	u_long	base, ptr, crc_loc, sum;
	int	i;

	base = fmt->top;
	crc_loc = NUBUS_ROM_offset(fmt, base, -12);
	ptr = NUBUS_ROM_offset(fmt, base, -fmt->length);

	sum = 0;
	while (ptr < base)
		roll #1, sum
		if (ptr == crc_loc) {
			roll #3, sum
			ptr = IncPtr(fmt, ptr, 3);
		} else {
			sum += GetByte(fmt, ptr);
		}
		ptr = IncPtr(fmt, ptr, 1);
	}

	return sum;
#endif
	return fmt->crc;
}

static u_char
GetByte(fmt, ptr)
	nubus_slot	*fmt;
	u_long		ptr;
d547 1
a547 1
	return *(caddr_t)ptr;
d552 12
a563 10
static u_short
GetWord(fmt, ptr)
	nubus_slot	*fmt;
	u_long		ptr;
{
	u_short	s;

	s = (GetByte(fmt, ptr) << 8);
	ptr = IncPtr(fmt, ptr, 1);
	s |= GetByte(fmt, ptr);
d568 6
a573 4
static u_long
GetLong(fmt, ptr)
	nubus_slot	*fmt;
	u_long		ptr;
d575 2
a576 2
	register u_long l;
	register int	i;
d579 3
a581 3
	for ( i = 0; i < 4; i++) {
		l = (l << 8) | GetByte(fmt, ptr);
		ptr = IncPtr(fmt, ptr, 1);
d587 3
a589 3
nubus_get_main_dir(slot, dir_return)
	nubus_slot	*slot;
	nubus_dir	*dir_return;
d593 2
a594 2
		printf("nubus_get_main_dir(0x%x, 0x%x)\n",
			(u_int) slot, (u_int) dir_return);
d596 23
a618 2
	dir_return->dirbase = IncPtr(slot, slot->top,
					slot->directory_offset - 20);
d623 7
a629 5
nubus_find_rsrc(slot, dir, rsrcid, dirent_return)
	nubus_slot	*slot;
	nubus_dir	*dir;
	u_int8_t	rsrcid;
	nubus_dirent	*dirent_return;
d631 2
a632 2
	u_long		entry;
	u_char		byte;
d636 2
a637 3
		printf("nubus_find_rsrc(0x%x, 0x%x, 0x%x, 0x%x)\n",
			(u_int) slot, (u_int) dir, (u_int) rsrcid,
			(u_int) dirent_return);
d639 1
a639 1
	if (slot->test_pattern != NUBUS_ROM_TEST_PATTERN)
d644 1
a644 1
		byte = GetByte(slot, entry);
d652 1
a652 1
			entry = GetLong(slot, entry);
d659 1
a659 1
			entry = IncPtr(slot, entry, 4);
d661 1
a661 1
	} while (entry != (u_long) dir->curr_ent);
a664 20
void
nubus_get_dir_from_rsrc(slot, dirent, dir_return)
	nubus_slot	*slot;
	nubus_dirent	*dirent;
	nubus_dir	*dir_return;
{
	u_long	loc;

#ifdef DEBUG
	if (nubus_debug & NDB_FOLLOW)
		printf("nubus_get_dir_from_rsrc(0x%x, 0x%x, 0x%x).\n",
			(u_int) slot, (u_int) dirent, (u_int) dir_return);
#endif
	if ((loc = dirent->offset) & 0x800000) {
		loc |= 0xff000000;
	}
	dir_return->dirbase = IncPtr(slot, dirent->myloc, loc);
	dir_return->curr_ent = dir_return->dirbase;
}

d666 4
a669 2
nubus_get_ind_data(slot, dirent, data_return, nbytes)
	nubus_slot *slot;
d674 2
a675 1
	u_long	loc;
d679 2
a680 3
		printf("nubus_get_ind_data(0x%x, 0x%x, 0x%x, %d).\n",
			(u_int) slot, (u_int) dirent, (u_int) data_return,
			nbytes);
d685 1
a685 1
	loc = IncPtr(slot, dirent->myloc, loc);
d688 2
a689 2
		*data_return++ = GetByte(slot, loc);
		loc = IncPtr(slot, loc, 1);
d695 4
a698 2
nubus_get_c_string(slot, dirent, data_return, max_bytes)
	nubus_slot *slot;
d703 2
a704 1
	u_long	loc;
d708 2
a709 3
		printf("nubus_get_c_string(0x%x, 0x%x, 0x%x, %d).\n",
			(u_int) slot, (u_int) dirent, (u_int) data_return,
			max_bytes);
d711 1
a711 1
	if ((loc = dirent->offset) & 0x800000) {
d713 2
a714 2
	}
	loc = IncPtr(slot, dirent->myloc, loc);
d718 2
a719 1
		if ((*data_return++ = GetByte(slot, loc)) == 0)
d721 1
a721 1
		loc = IncPtr(slot, loc, 1);
d723 1
d730 9
a738 7
nubus_get_vendor(slot, rsrc)
	nubus_slot	*slot;
	int		rsrc;
{
static	char		str_ret[64];
	nubus_dir	dir;
	nubus_dirent	ent;
d742 1
a742 1
		printf("nubus_get_vendor(0x%x, 0x%x).\n", (u_int) slot, rsrc);
d744 2
a745 2
	nubus_get_main_dir(slot, &dir);
	if (nubus_find_rsrc(slot, &dir, 1, &ent) <= 0)
d747 1
a747 1
	nubus_get_dir_from_rsrc(slot, &ent, &dir);
d749 2
a750 1
	if (nubus_find_rsrc(slot, &dir, NUBUS_RSRC_VENDORINFO, &ent) <= 0)
d752 1
a752 1
	nubus_get_dir_from_rsrc(slot, &ent, &dir);
d754 1
a754 1
	if (nubus_find_rsrc(slot, &dir, rsrc, &ent) <= 0)
d757 1
a757 1
	nubus_get_c_string(slot, &ent, str_ret, 64);
d763 4
a766 2
nubus_get_card_name(slot)
	nubus_slot	*slot;
d768 3
a770 3
static	char		name_ret[64];
	nubus_dir	dir;
	nubus_dirent	ent;
d774 1
a774 1
		printf("nubus_get_card_name(0x%lx).\n", (u_long) slot);
d776 1
a776 1
	nubus_get_main_dir(slot, &dir);
d778 1
a778 1
	if (nubus_find_rsrc(slot, &dir, 1, &ent) <= 0)
d781 1
a781 1
	nubus_get_dir_from_rsrc(slot, &ent, &dir);
d783 1
a783 1
	if (nubus_find_rsrc(slot, &dir, NUBUS_RSRC_NAME, &ent) <= 0)
d786 1
a786 1
	nubus_get_c_string(slot, &ent, name_ret, 64);
d791 35
a825 55
/*
 * bus_*() functions adapted from sun3 generic "bus" support
 * by Allen Briggs.
 */

vm_offset_t tmp_vpages[1];

/*
 * Read addr with size len (1,2,4) into val.
 * If this generates a bus error, return -1
 *
 *	Create a temporary mapping,
 *	Try the access using peek_*
 *	Clean up temp. mapping
 */
static int
nubus_peek(paddr, sz)
	vm_offset_t paddr;
	int sz;
{
	int off, pte, rv;
	vm_offset_t pgva;
	caddr_t va;

	off = paddr & PGOFSET;
	paddr -= off;
	pte = (paddr & PG_FRAME) | (PG_V | PG_W | PG_CI);

	pgva = tmp_vpages[0];
	va = (caddr_t)pgva + off;

	mac68k_set_pte(pgva, pte);
	TBIS(pgva);

	/*
	 * OK, try the access using one of the assembly routines
	 * that will set pcb_onfault and catch any bus errors.
	 */
	rv = -1;
	switch (sz) {
	case 1:
		if (!badbaddr(va))
			rv = *((u_char *) va);
		break;
	case 2:
		if (!badwaddr(va))
			rv = *((u_int16_t *) va);
		break;
	case 4:
		if (!badladdr(va))
			rv = *((u_int32_t *) va);
		break;
	default:
		printf("bus_peek: invalid size=%d\n", sz);
		rv = -1;
d827 1
a827 35

	mac68k_set_pte(pgva, PG_NV);
	TBIS(pgva);

	return rv;
}

char *
nubus_mapin(paddr, sz)
	int paddr, sz;
{
	int off, pa, pmt=0;
	vm_offset_t va, retval;

	off = paddr & PGOFSET;
	pa = paddr - off;
	sz += off;
	sz = m68k_round_page(sz);

	/* Get some kernel virtual address space. */
	va = uvm_km_valloc_wait(kernel_map, sz);
	if (va == 0)
		panic("bus_mapin");
	retval = va + off;

	/* Map it to the specified bus. */
	do {
		pmap_enter(pmap_kernel(), va, pa | pmt,
		    VM_PROT_READ|VM_PROT_WRITE, VM_PROT_READ|VM_PROT_WRITE);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	} while ((sz -= PAGE_SIZE) > 0);
	pmap_update(pmap_kernel());

	return ((char *)retval);
d829 1
@


1.28
log
@Remove dead (ifdef 0) code that pollutes my greps.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.27 2002/04/29 06:26:50 pvalchev Exp $	*/
d825 4
a828 4
			   VM_PROT_READ|VM_PROT_WRITE, 0);
		va += NBPG;
		pa += NBPG;
	} while ((sz -= NBPG) > 0);
@


1.27
log
@wierd -> weird
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.26 2002/03/14 03:15:55 millert Exp $	*/
a822 4
#if 0	/* XXX */
	/* This has a problem with wrap-around... */
	pmap_map((int)va, pa | pmt, pa + sz, VM_PROT_ALL);
#else
a828 1
#endif
@


1.26
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.25 2002/03/14 01:26:35 millert Exp $	*/
d269 1
a269 1
 * and check the other three locations in case there's a wierd card
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.24 2001/12/10 00:58:04 miod Exp $	*/
d836 1
a836 1
	return ((char*)retval);
@


1.24
log
@No need to include <sys/dmap.h> and define related variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.23 2001/12/08 02:24:06 art Exp $	*/
d58 9
a66 9
static int	nubus_print __P((void *, const char *));
static int	nubus_match __P((struct device *, void *, void *));
static void	nubus_attach __P((struct device *, struct device *, void *));
int		nubus_video_resource __P((int));

static int	probe_slot __P((int slot, nubus_slot *fmt));
static u_long	IncPtr __P((nubus_slot *fmt, u_long base, long amt));
static u_long	nubus_calc_CRC __P((nubus_slot *fmt));
static u_char	GetByte __P((nubus_slot *fmt, u_long ptr));
d68 1
a68 1
/* unused */ static u_short	GetWord __P((nubus_slot *fmt, u_long ptr));
d70 1
a70 1
static u_long	GetLong __P((nubus_slot *fmt, u_long ptr));
d72 1
a72 1
static int	nubus_peek __P((vm_offset_t, int));
@


1.24.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.24 2001/12/10 00:58:04 miod Exp $	*/
d58 9
a66 9
static int	nubus_print(void *, const char *);
static int	nubus_match(struct device *, void *, void *);
static void	nubus_attach(struct device *, struct device *, void *);
int		nubus_video_resource(int);

static int	probe_slot(int slot, nubus_slot *fmt);
static u_long	IncPtr(nubus_slot *fmt, u_long base, long amt);
static u_long	nubus_calc_CRC(nubus_slot *fmt);
static u_char	GetByte(nubus_slot *fmt, u_long ptr);
d68 1
a68 1
/* unused */ static u_short	GetWord(nubus_slot *fmt, u_long ptr);
d70 1
a70 1
static u_long	GetLong(nubus_slot *fmt, u_long ptr);
d72 1
a72 1
static int	nubus_peek(vm_offset_t, int);
d269 1
a269 1
 * and check the other three locations in case there's a weird card
d836 1
a836 1
	return ((char *)retval);
@


1.24.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d823 4
d833 1
@


1.23
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.22 2001/11/06 19:53:14 miod Exp $	*/
a37 1
#include <sys/dmap.h>
@


1.22
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.21 2001/09/19 20:50:56 mickey Exp $	*/
d835 1
@


1.21
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.20 2001/08/20 21:29:23 miod Exp $	*/
a39 1
#include <vm/vm.h>
@


1.20
log
@Not only is Apple hardware disgusting, but code doesn't even compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.19 2001/08/11 23:21:13 art Exp $	*/
a40 2
#include <vm/vm_kern.h>

@


1.19
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.18 2001/07/25 13:25:32 art Exp $	*/
d41 1
@


1.18
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.17 2001/06/27 04:22:37 art Exp $	*/
a40 2
#include <vm/vm_kern.h>
#include <vm/vm_map.h>
@


1.17
log
@old vm no more
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.16 2001/06/08 08:09:00 art Exp $	*/
d834 1
a834 1
			   VM_PROT_READ|VM_PROT_WRITE, FALSE, 0);
@


1.16
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.15 2001/05/08 17:30:40 aaron Exp $	*/
a43 1
#if defined(UVM)
a44 1
#endif
a821 1
#if defined(UVM)
a822 3
#else
	va = kmem_alloc_wait(kernel_map, sz);
#endif
@


1.15
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.14 1999/09/03 18:01:09 art Exp $	*/
d314 1
a314 1
		pa = pmap_extract(pmap_kernel(), (vm_offset_t) rom_probe - 1);
@


1.14
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.13 1999/04/24 06:39:40 downsj Exp $	*/
d44 4
d824 3
d828 1
@


1.14.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.14 1999/09/03 18:01:09 art Exp $	*/
a43 2
#include <uvm/uvm_extern.h>

d310 1
a310 1
		pmap_extract(pmap_kernel(), (vm_offset_t) rom_probe - 1, &pa);
d820 1
a820 1
	va = uvm_km_valloc_wait(kernel_map, sz);
@


1.14.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.14.4.1 2001/07/04 10:18:28 niklas Exp $	*/
d41 3
d834 1
a834 1
			   VM_PROT_READ|VM_PROT_WRITE, 0);
@


1.14.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
@


1.14.4.4
log
@Merge in trunk
@
text
@d38 1
a834 1
	pmap_update(pmap_kernel());
@


1.14.4.5
log
@Merge in -current from about a week ago
@
text
@d58 9
a66 9
static int	nubus_print(void *, const char *);
static int	nubus_match(struct device *, void *, void *);
static void	nubus_attach(struct device *, struct device *, void *);
int		nubus_video_resource(int);

static int	probe_slot(int slot, nubus_slot *fmt);
static u_long	IncPtr(nubus_slot *fmt, u_long base, long amt);
static u_long	nubus_calc_CRC(nubus_slot *fmt);
static u_char	GetByte(nubus_slot *fmt, u_long ptr);
d68 1
a68 1
/* unused */ static u_short	GetWord(nubus_slot *fmt, u_long ptr);
d70 1
a70 1
static u_long	GetLong(nubus_slot *fmt, u_long ptr);
d72 1
a72 1
static int	nubus_peek(vm_offset_t, int);
d836 1
a836 1
	return ((char *)retval);
@


1.14.4.6
log
@Sync the SMP branch with 3.3
@
text
@d269 1
a269 1
 * and check the other three locations in case there's a weird card
@


1.14.4.7
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.14.4.6 2003/03/27 23:28:43 niklas Exp $	*/
d823 4
d833 1
@


1.13
log
@Use the generic m68k param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.12 1997/04/24 02:10:15 gene Exp $	*/
d831 2
a832 1
		pmap_enter(pmap_kernel(), va, pa | pmt, VM_PROT_ALL, FALSE);
@


1.12
log
@Followingthe Scott Reynolds gravy train, very minor:
>#ifdef DIAGNOSTIC, print the NuBus type fields for unrecognized boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.11 1997/04/23 13:38:35 briggs Exp $	*/
d817 1
a817 1
	sz = mac68k_round_page(sz);
@


1.11
log
@On video devices, if we're loading non-default resource values, save the
resource ID.  Thanks to Paul Goyette <paul@@pgoyette.bdt.com> for spotting
this one.
@
text
@d1 2
a2 2
/*	$OpenBSD: nubus.c,v 1.10 1997/04/08 04:14:46 briggs Exp $	*/
/*	$NetBSD: nubus.c,v 1.32 1997/02/28 07:54:02 scottr Exp $	*/
d235 1
a235 1
		printf("%s: slot %x: %s ", name, na->fmt->slot,
d237 1
a237 1
		printf("(Vendor: %s, ",
d239 1
a239 1
		printf("Part: %s)",
d241 4
@


1.10
log
@Some patches from Bob Nestor <rnestor@@metronet.com> to edge toward support
for an Apple SONIC-based ethernet card.  Includes a patch to the nubus
probing that we worked out together.  Some cards, like his, were being
missed and/or probed like video cards\!
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.9 1997/03/12 13:15:58 briggs Exp $	*/
d205 2
@


1.9
log
@cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.8 1997/03/08 16:16:56 briggs Exp $	*/
d111 1
d120 1
a120 2
		if ((rsrcid = nubus_video_resource(i)) == (-1))
			rsrcid = 0x80;
d124 44
a167 2
		if (nubus_find_rsrc(&fmtblock, &dir, rsrcid, &dirent) <= 0)
			continue;
d178 29
@


1.8
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: nubus.c,v 1.7 1997/01/24 01:35:35 briggs Exp $	*/
a53 1
#define DEBUG
d55 1
a55 1
static int	nubus_debug = 0x07;
a242 5
#ifdef DEBUG
	if (nubus_debug & NDB_PROBE) {
		printf("Peeking %p\n", rom_probe);
	}
#endif
a244 2
		printf("data %u\n", data);

a707 1
		printf("checking badbaddr\n");
a709 1
		printf("got back %d\n", rv);
a723 1
printf("setting_pte_back\n");
a724 1
printf("TBIS\n");
a726 1
printf("returning %d\n", rv);
@


1.7
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: nubus.c,v 1.6 1996/11/23 21:45:54 kstailey Exp $	*/
/*	$NetBSD: nubus.c,v 1.29 1996/12/17 06:47:39 scottr Exp $	*/
d45 1
d50 1
d54 1
d56 1
a56 1
static int	nubus_debug = 0x01;
d63 1
a63 1
static int	nubus_match __P((struct device *, struct cfdata *, void *));
d87 1
a87 1
nubus_match(parent, cf, aux)
d89 1
a89 1
	struct cfdata *cf;
d148 5
d230 1
a230 1
	rom_probe = (caddr_t) (NUBUS_SLOT_TO_PADDR(fmt->slot) + NBMEMSIZE);
d235 1
a235 1
		printf("probing slot %d, first probe at 0x%x (PA %p).\n",
d244 5
d250 4
a253 1
		if (data == -1)
d289 1
a289 1
		nubus_mapin(NUBUS_SLOT_TO_PADDR(fmt->slot), NBMEMSIZE);
d294 1
a294 1
			(unsigned int) NUBUS_SLOT_TO_PADDR(fmt->slot));
d308 1
a308 1
		printf("fmt->top is 0x%p, that minus 0x%x puts us at 0x%p.\n",
d716 1
d719 1
d734 1
d736 1
d739 1
@


1.6
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: nubus.c,v 1.4 1996/05/26 18:35:32 briggs Exp $	*/
/*	$NetBSD: nubus.c,v 1.23 1996/05/08 15:14:53 scottr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995 Allen Briggs.  All rights reserved.
d36 7
d45 2
d48 1
a48 2

#include <vm/vm.h>
d59 4
a62 3
static int	nubusprint __P((void *, const char *));
static int	nubusmatch __P((struct device *, void *, void *));
static void	nubusattach __P((struct device *, struct device *, void *));
d73 2
d76 1
a76 1
	sizeof(struct nubus_softc), nubusmatch, nubusattach
d80 1
a80 1
	NULL, "nubus", DV_DULL, 1
d84 1
a84 1
nubusmatch(parent, vcf, aux)
d86 2
a87 1
	void *vcf, *aux;
d89 1
a89 1
	struct confargs *ca = aux;
d91 2
a92 1
	if (ca->ca_bustype != BUS_NUBUS)
d94 3
a96 1
	return(1);
d100 45
a144 15
nubusattach(parent, self, aux)
	struct	device	*parent, *self;
	void		*aux;
{
	nubus_slot		fmtblock;
	int			i;

	printf("\n");

	for (i = NUBUS_MIN_SLOT; i <= NUBUS_MAX_SLOT; i++) {
		if (probe_slot(i, &fmtblock)) {
			/*config_search(bus_scan, &fmtblock, nubusprint);*/
			config_found(self, &fmtblock, nubusprint);
		}
	}
d148 2
a149 2
nubusprint(aux, name)
	void	   *aux;
d152 1
a152 1
	nubus_slot	*fmt;
a153 1
	fmt = (nubus_slot *) aux;
d155 2
a156 2
		printf("%s: slot %x: %s ", name, fmt->slot,
				nubus_get_card_name(fmt));
d158 3
a160 3
				nubus_get_vendor(fmt, NUBUS_RSRC_VEND_ID));
		printf("Part: %s) ",
				nubus_get_vendor(fmt, NUBUS_RSRC_VEND_PART));
d165 13
d236 1
a236 1
		data = bus_peek(BUS_NUBUS, (vm_offset_t) rom_probe, 1);
d273 1
a273 1
		bus_mapin(BUS_NUBUS,NUBUS_SLOT_TO_PADDR(fmt->slot),NBMEMSIZE);
d657 96
@


1.5
log
@%p implies 0x.
@
text
@d51 1
a51 1
static int	nubusprint __P((void *, char *));
d104 2
a105 2
	void	*aux;
	char	*name;
@


1.4
log
@Add OpenBSD Id string.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d170 1
a170 1
		printf("probing slot %d, first probe at 0x%x (PA 0x%p).\n",
@


1.3
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.2
log
@from netbsd: Fixes from PR #1931.
@
text
@d1 1
a1 1
/*	$NetBSD: nubus.c,v 1.15 1996/01/12 04:16:43 briggs Exp $	*/
d36 1
d43 1
a43 1
#if DEBUG
d50 3
a52 5
extern int	matchbyname();

static int	nubusprint __P((void *aux, char *name));
static void	nubusattach __P((struct device *parent, struct device *self,
				 void *aux));
d58 3
a60 1
static u_short	GetWord __P((nubus_slot *fmt, u_long ptr));
d63 6
a68 3
struct cfdriver nubuscd = {
	NULL, "nubus", matchbyname, nubusattach,
	DV_DULL, sizeof(struct nubus_softc), 1
d71 12
a87 1
	extern u_int32_t	mac68k_vidlog;
d93 1
a93 20
	/*
	 * Kludge for internal video.
	 */
	if (mac68k_vidlog) {
		int	int_video_slot = NUBUS_INT_VIDEO_PSUEDO_SLOT;

		fmtblock.top = NUBUS_SLOT_TO_BASE(int_video_slot);
		fmtblock.slot = int_video_slot;
		fmtblock.bytelanes = 0x0F;
		fmtblock.step = 4;
		fmtblock.test_pattern = ~NUBUS_ROM_TEST_PATTERN;
		fmtblock.format = 1;
		fmtblock.revision_level = 1;
		fmtblock.crc = 1;
		fmtblock.length = 0;
		fmtblock.directory_offset = 0;
		config_found(self, &fmtblock, nubusprint);
	}

	for ( i = NUBUS_MIN_SLOT; i <= NUBUS_MAX_SLOT; i++) {
d95 1
a106 2
	int		slot;
	char		*info;
d154 5
a158 3
	u_long		hdr;
	u_long		phys;
	u_char		data;
d164 1
a164 1
	rom_probe = (caddr_t) (NUBUS_SLOT_TO_BASE(fmt->slot) + NBMEMSIZE);
d168 3
a170 3
		phys = pmap_extract(pmap_kernel(), (vm_offset_t)rom_probe-1);
		printf("probing slot %d, first probe at 0x%x (phys 0x%x).\n",
			slot, rom_probe-1, phys);
d178 2
a179 1
		if (badbaddr(rom_probe))
d182 1
a182 1
		if ((data = *rom_probe) == 0)
d202 2
a203 2
		printf("bytelanes of 0x%x found for slot 0x%x (base 0x%x).\n",
			fmt->bytelanes, slot, NUBUS_SLOT_TO_BASE(slot));
d214 11
a224 1
	hdr = NUBUS_SLOT_TO_BASE(fmt->slot) + NBMEMSIZE;
d234 1
a234 1
		printf("fmt->top is 0x%x, that minus 0x%x puts us at 0x%x.\n",
d257 1
a257 1
#if DEBUG
d377 2
d391 1
d414 1
a414 3
	u_long		off;

#if DEBUG
d434 1
a434 1
#if DEBUG
d446 1
a446 1
#if DEBUG
d474 1
a474 1
#if DEBUG
d495 1
a495 1
#if DEBUG
d522 1
a522 1
#if DEBUG
d553 1
a553 1
#if DEBUG
d582 1
a582 1
#if DEBUG
d584 1
a584 1
		printf("nubus_get_card_name(0x%x).\n", (u_long) slot);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nubus.c,v 1.14 1995/08/04 02:55:17 briggs Exp $	*/
d171 1
a171 1
		phys = pmap_extract(pmap_kernel(), rom_probe-1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
