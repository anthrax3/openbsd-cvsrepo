head	1.26;
access;
symbols
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.21
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.17.0.16
	OPENBSD_2_9_BASE:1.17
	NIKLAS_UNDEAD:1.17.0.14
	OPENBSD_2_8:1.17.0.12
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.10
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.8
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.6
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.4
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.15.0.4
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2006.01.04.20.39.05;	author miod;	state dead;
branches;
next	1.25;

1.25
date	2005.07.23.23.28.58;	author martin;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.27.48;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.11.05.13.37;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.06.08.08.08.59;	author art;	state Exp;
branches;
next	1.17;

1.17
date	98.05.03.07.12.58;	author gene;	state Exp;
branches
	1.17.8.1;
next	1.16;

1.16
date	97.11.14.03.40.58;	author gene;	state Exp;
branches;
next	1.15;

1.15
date	97.04.14.17.56.45;	author gene;	state Exp;
branches;
next	1.14;

1.14
date	97.04.14.01.00.35;	author briggs;	state Exp;
branches;
next	1.13;

1.13
date	97.04.08.04.41.26;	author briggs;	state Exp;
branches;
next	1.12;

1.12
date	97.04.03.03.53.27;	author briggs;	state Exp;
branches;
next	1.11;

1.11
date	97.03.12.13.26.38;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.03.08.16.16.54;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.01.24.01.35.33;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.01.19.03.18.02;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.11.10.14.29.41;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.10.28.14.46.23;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.08.10.21.37.45;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.06.08.16.21.10;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.35.27;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.18.13.43;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches;
next	;

1.17.8.1
date	2001.07.04.10.18.27;	author niklas;	state Exp;
branches;
next	1.17.8.2;

1.17.8.2
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.17.8.3;

1.17.8.3
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.17.8.4;

1.17.8.4
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.17.8.5;

1.17.8.5
date	2003.06.07.11.13.13;	author ho;	state Exp;
branches;
next	1.17.8.6;

1.17.8.6
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.28.05;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@/*	$OpenBSD: ite.c,v 1.25 2005/07/23 23:28:58 martin Exp $	*/
/*	$NetBSD: ite.c,v 1.32 1997/02/20 00:23:25 scottr Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: ite.c 1.28 92/12/20$
 *
 *	@@(#)ite.c	8.2 (Berkeley) 1/12/94
 */

/*
 * ite.c
 *
 * The ite module handles the system console; that is, stuff printed
 * by the kernel and by user programs while "desktop" and X aren't
 * running.  Some (very small) parts are based on hp300's 4.4 ite.c,
 * hence the above copyright.
 *
 *   -- Brad and Lawrence, June 26th, 1994
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <dev/cons.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/tty.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/viareg.h>

#define KEYBOARD_ARRAY
#include <machine/keyboard.h>
#include <machine/adbsys.h>
#include <machine/iteioctl.h>
#include <machine/grfioctl.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>

#include "../mac68k/macrom.h"

#include "nubus.h"
#include "itevar.h"
#include "grfvar.h"

#include "6x10.h"
#define CHARWIDTH	6
#define CHARHEIGHT	10

/* Local function prototypes */
static __inline void putpixel1(int, int, int *, int);
static void	putpixel2(int, int, int *, int);
static void	putpixel4(int, int, int *, int);
static void	putpixel8(int, int, int *, int);
static void	putpixel16(int, int, int *, int);
static void	putpixel32(int, int, int *, int);
static void	reversepixel1(int, int, int);
static void	writechar(char, int, int, int);
static void	drawcursor(void);
static void	erasecursor(void);
static void	scrollup(void);
static void	scrolldown(void);
static void	clear_screen(int);
static void	clear_line(int);
static void	reset_tabs(void);
static void	clear_tabs(void);
static void	vt100_reset(void);
static void	putc_normal(char);
static void	putc_esc(char);
static void	putc_gotpars(char);
static void	putc_getpars(char);
static void	putc_square(char);
static void	ite_putchar(char);
static int	ite_pollforchar(void);
static int	itematch(struct device *, void *, void *);
static void	iteattach(struct device *, struct device *, void *);
static int	ite_init(void);

#define dprintf if (0) printf

#define ATTR_NONE	0
#define ATTR_BOLD	1
#define ATTR_UNDER	2
#define ATTR_REVERSE	4

enum vt100state_e {
	ESnormal,		/* Nothing yet                             */
	ESesc,			/* Got ESC                                 */
	ESsquare,		/* Got ESC [				   */
	ESgetpars,		/* About to get or getting the parameters  */
	ESgotpars,		/* Finished getting the parameters         */
	ESfunckey,		/* Function key                            */
	EShash,			/* DEC-specific stuff (screen align, etc.) */
	ESsetG0,		/* Specify the G0 character set            */
	ESsetG1,		/* Specify the G1 character set            */
	ESignore		/* Ignore this sequence                    */
} vt100state = ESnormal;

/* From Booter via locore */
long		videoaddr;
long		videorowbytes;
long		videobitdepth;
unsigned long	videosize;

/* Calculated by itecninit() */
static int	ite_initted = 0;
static int	width, height;		/* width, height in pixels */
static int	scrcols, scrrows;	/* width, height in characters */
static int	screenrowbytes;		/* number of visible bytes per row */

/* VT100 emulation */
#define MAXPARS	16			/* max number of VT100 op parameters */
static int	par[MAXPARS], numpars;	/* parameter array, # of parameters */
static int	x = 0, y = 0;		/* current VT100 cursor location */
static int	savex, savey;		/* saved cursor location */
static int	hanging_cursor;		/* cursor waiting for more output */
static int	attr;			/* current video attribute */
static char	tab_stops[255];		/* tab stops */
static int	scrreg_top;		/* scroll region */
static int	scrreg_bottom;

/* Console bell parameters */
static int	bell_freq = 1880;	/* frequency */
static int	bell_length = 10;	/* duration */
static int	bell_volume = 100;	/* volume */

/* For polled ADB mode */
static int	polledkey;
extern int	adb_polling;

extern u_int32_t mac68k_vidphys;

struct tty	*ite_tty;		/* Our tty */

static void	(*putpixel)(int x, int y, int *c, int num);
static void	(*reversepixel)(int x, int y, int num);

/* For capslock key functionality */
#define isealpha(ch)  (((ch)>='A'&&(ch)<='Z')||((ch)>='a'&&(ch)<='z')||((ch)>=0xC0&&(ch)<=0xFF))

/*
 * Bitmap handling functions
 */

static __inline void 
putpixel1(xx, yy, c, num)
	int xx, yy;
	int *c;
	int num;
{
	unsigned int i, mask;
	unsigned char *sc;

	sc = (unsigned char *) videoaddr;

	i = 7 - (xx & 7);
	mask = ~(1 << i);
	sc += yy * videorowbytes + (xx >> 3);
	while (num--) {
		*sc &= mask;
		*sc |= (*c++ & 1) << i;
		sc += videorowbytes;
	}
}

static void 
putpixel2(xx, yy, c, num)
	int xx, yy;
	int *c;
	int num;
{
	unsigned int i, mask;
	unsigned char *sc;

	sc = (unsigned char *) videoaddr;

	i = 6 - ((xx & 3) << 1);
	mask = ~(3 << i);
	sc += yy * videorowbytes + (xx >> 2);
	while (num--) {
		*sc &= mask;
		*sc |= (*c++ & 3) << i;
		sc += videorowbytes;
	}
}

static void 
putpixel4(xx, yy, c, num)
	int xx, yy;
	int *c;
	int num;
{
	unsigned int i, mask;
	unsigned char *sc;

	sc = (unsigned char *) videoaddr;

	i = 4 - ((xx & 1) << 2);
	mask = ~(15 << i);
	sc += yy * videorowbytes + (xx >> 1);
	while (num--) {
		*sc &= mask;
		*sc |= (*c++ & 15) << i;
		sc += videorowbytes;
	}
}

static void 
putpixel8(xx, yy, c, num)
	int xx, yy;
	int *c;
	int num;
{
	unsigned char *sc;

	sc = (unsigned char *) videoaddr;

	sc += yy * videorowbytes + xx;
	while (num--) {
		*sc = *c++ & 0xff;
		sc += videorowbytes;
	}
}

static void
putpixel16(xx, yy, c, num)
	int xx, yy;
	int *c;
	int num;
{
	unsigned short	*sc;
	int		videorowshorts;
	unsigned char	uc;

	sc = (unsigned short *)videoaddr;

	videorowshorts = videorowbytes >> 1;
	sc += yy * videorowshorts + xx;
	while (num--) {
		uc = (*c++ & 0xff);
		*sc = (uc << 8) | uc;
		sc += videorowshorts;
	}
}

static void
putpixel32(xx, yy, c, num)
	int xx, yy;
	int *c;
	int num;
{
	unsigned long	*sc;
	int		videorowlongs;
	unsigned char	uc;

	sc = (unsigned long *)videoaddr;

	videorowlongs = videorowbytes >> 2;
	sc += yy * videorowlongs + xx;
	while (num--) {
		uc = (*c++ & 0xff);
		*sc = (uc << 24) | (uc << 16) | (uc << 8) | uc;
		sc += videorowlongs;
}
}

static void 
reversepixel1(xx, yy, num)
	int xx, yy, num;
{
	unsigned int mask;
	unsigned char *sc;
	unsigned long *sl;
	unsigned short *ss;
	int		videorowshorts;
	int		videorowlongs;

	sc = (unsigned char *) videoaddr;
	mask = 0;		/* Get rid of warning from compiler */

	switch (videobitdepth) {
	case 1:
		mask = 1 << (7 - (xx & 7));
		sc += yy * videorowbytes + (xx >> 3);
		break;
	case 2:
		mask = 3 << (6 - ((xx & 3) << 1));
		sc += yy * videorowbytes + (xx >> 2);
		break;
	case 4:
		mask = 15 << (4 - ((xx & 1) << 2));
		sc += yy * videorowbytes + (xx >> 1);
		break;
	case 8:
		mask = 255;
		sc += yy * videorowbytes + xx;
		break;
	case 16:
		videorowshorts = videorowbytes >> 1;
		ss = (unsigned short *) videoaddr;
		ss += yy * videorowshorts + xx;
		while (num--) {
			*ss ^= 0xffff;
			ss += videorowshorts;
		}
		return;
	case 32:
		videorowlongs = videorowbytes >> 2;
		sl = (unsigned long *) videoaddr;
		sl += yy * videorowlongs + xx;
		while (num--) {
			*sl ^= 0xffffffff;
			sl += videorowlongs;
		}
		return;
	default:
		panic("reversepixel(): unsupported bit depth");
	}

	while (num--) {
		*sc ^= mask;
		sc += videorowbytes;
	}
}

static void 
writechar(ch, x, y, attr)
	char ch;
	int x, y, attr;
{
	int i, j, mask, rev, col[CHARHEIGHT];
	unsigned char *c;

	ch &= 0x7F;
	x *= CHARWIDTH;
	y *= CHARHEIGHT;

	rev = (attr & ATTR_REVERSE) ? 255 : 0;

	c = &Font6x10[ch * CHARHEIGHT];

	switch (videobitdepth) {
	case 1:
		for (j = 0; j < CHARWIDTH; j++) {
			mask = 1 << (CHARWIDTH - 1 - j);
			for (i = 0; i < CHARHEIGHT; i++)
				col[i] = ((c[i] & mask) ? 255 : 0) ^ rev;
			putpixel1(x + j, y, col, CHARHEIGHT);
		}
		if (attr & ATTR_UNDER) {
			col[0] = 255;
			for (j = 0; j < CHARWIDTH; j++)
				putpixel1(x + j, y + CHARHEIGHT - 1, col, 1);
		}
		break;
	case 2:
	case 4:
	case 8:
	case 16:
	case 32:
		for (j = 0; j < CHARWIDTH; j++) {
			mask = 1 << (CHARWIDTH - 1 - j);
			for (i = 0; i < CHARHEIGHT; i++)
				col[i] = ((c[i] & mask) ? 255 : 0) ^ rev;
			putpixel(x + j, y, col, CHARHEIGHT);
		}
		if (attr & ATTR_UNDER) {
			col[0] = 255;
			for (j = 0; j < CHARWIDTH; j++)
				putpixel(x + j, y + CHARHEIGHT - 1, col, 1);
		}
		break;
	}
}

static void 
drawcursor()
{
	unsigned int j, X, Y;

	X = x * CHARWIDTH;
	Y = y * CHARHEIGHT;

	for (j = 0; j < CHARWIDTH; j++)
		reversepixel(X + j, Y, CHARHEIGHT);
}

static void 
erasecursor()
{
	unsigned int j, X, Y;

	X = x * CHARWIDTH;
	Y = y * CHARHEIGHT;

	for (j = 0; j < CHARWIDTH; j++)
		reversepixel(X + j, Y, CHARHEIGHT);
}

static void 
scrollup()
{
	unsigned char *from, *to;
	unsigned int linebytes;
	unsigned short i;

	linebytes = videorowbytes * CHARHEIGHT;
	to = (unsigned char *) videoaddr + (scrreg_top * linebytes);
	from = to + linebytes;

	for (i = (scrreg_bottom - scrreg_top) * CHARHEIGHT; i > 0; i--) {
		ovbcopy(from, to, screenrowbytes);
		from += videorowbytes;
		to += videorowbytes;
	}
	for (i = CHARHEIGHT; i > 0; i--) {
		bzero(to, screenrowbytes);
		to += videorowbytes;
	}
}

static void 
scrolldown()
{
	unsigned char *from, *to;
	unsigned int linebytes;
	unsigned short i;

	linebytes = videorowbytes * CHARHEIGHT;
	to = (unsigned char *) videoaddr + ((scrreg_bottom + 1) * linebytes);
	from = to - linebytes;

	for (i = (scrreg_bottom - scrreg_top) * CHARHEIGHT; i > 0; i--) {
		from -= videorowbytes;
		to -= videorowbytes;
		ovbcopy(from, to, screenrowbytes);
	}
	for (i = CHARHEIGHT; i > 0; i--) {
		to -= videorowbytes;
		bzero(to, screenrowbytes);
	}
}

static void 
clear_screen(which)
	int which;
{
	unsigned char *p;
	unsigned short len, i;

	p = (unsigned char *) videoaddr;

	switch (which) {
	case 0:		/* To end of screen	 */
		if (x > 0) {
			clear_line(0);
			if (y < scrrows)
				y++;
			x = 0;
		}
		p += y * videorowbytes * CHARHEIGHT;
		len = scrrows - y;
		break;
	case 1:		/* To start of screen	 */
		if (x > 0) {
			clear_line(1);
			if (y > 0)
				y--;
			x = 0;
		}
		len = y;
		break;
	case 2:		/* Whole screen		 */
	default:
		len = scrrows;
		break;
	}

	for (i = len * CHARHEIGHT; i > 0; i--) {
		bzero(p, screenrowbytes);
		p += videorowbytes;
	}
}

static void 
clear_line(which)
	int which;
{
	unsigned char *to;
	unsigned int linebytes;
	int start, end, i;


	/*
	 * This routine runs extremely slowly.  I don't think it's
	 * used all that often, except for To end of line.  I'll go
	 * back and speed this up when I speed up the whole ite
	 * module. --LK
	 */

	switch (which) {
	default:
	case 0:		/* To end of line	 */
		start = x;
		end = scrcols;
		break;
	case 1:		/* To start of line	 */
		start = 0;
		end = x;
		break;
	case 2:		/* Whole line		 */
		linebytes = videorowbytes * CHARHEIGHT;
		to = (unsigned char *) videoaddr + (y * linebytes);

		for (i = CHARHEIGHT; i > 0; i--) {
			bzero(to, screenrowbytes);
			to += videorowbytes;
		}
		return;
	}

	for (i = start; i < end; i++)
		writechar(' ', i, y, ATTR_NONE);
}

static void
reset_tabs()
{
	int i;

	for (i = 0; i<= scrcols; i++)
		tab_stops[i] = ((i % 8) == 0);
}

static void
clear_tabs()
{
	int i;

	for (i = 0; i <= scrcols; i++)
		tab_stops[i] = 0;
}

static void
vt100_reset()
{
	reset_tabs();
	scrreg_top    = 0;
	scrreg_bottom = scrrows - 1;
	attr = ATTR_NONE;
}

static void 
putc_normal(ch)
	char ch;
{
	switch (ch) {
	case '\a':		/* Beep			 */
		mac68k_ring_bell(bell_freq, bell_length, bell_volume);
		break;
	case 127:		/* Delete		 */
	case '\b':		/* Backspace		 */
		if (hanging_cursor)
			hanging_cursor = 0;
		else if (x > 0)
			x--;
		break;
	case '\t':		/* Tab			 */
		do
			ite_putchar(' ');
		while ((tab_stops[x] == 0) && (x < scrcols));
		break;
	case '\n':		/* Line feed		 */
		if (y == scrreg_bottom)
			scrollup();
		else
			y++;
		break;
	case '\r':		/* Carriage return	 */
		x = 0;
		hanging_cursor = 0;
		break;
	case '\e':		/* Escape		 */
		vt100state = ESesc;
		hanging_cursor = 0;
		break;
	default:
		if (ch >= ' ') {
			if (hanging_cursor) {
				x = 0;
				if (y == scrreg_bottom)
					scrollup();
				else
					y++;
				hanging_cursor = 0;
			}

			writechar(ch, x, y, attr);

			if (x == scrcols - 1)
				hanging_cursor = 1;
			else
				x++;
			if (x >= scrcols) {	/* can we ever get here? */
				x = 0;
				y++;
			}
		}
		break;
	}
}

static void 
putc_esc(ch)
	char ch;
{
	vt100state = ESnormal;

	switch (ch) {
	case '[':
		vt100state = ESsquare;
		break;
	case '(':
		vt100state = ESsetG0;
		break;
	case ')':
		vt100state = ESsetG1;
		break;
	case 'E':		/* Next line		 */
		x = 0;
		/* FALLTHROUGH */
	case 'D':		/* Line feed		 */
		if (y == scrreg_bottom)
			scrollup();
		else
			y++;
		break;
	case 'H':		/* Set tab stop		 */
		tab_stops[x] = 1;
		break;
	case 'M':		/* Cursor up		 */
		if (y == scrreg_top)
			scrolldown();
		else
			y--;
		break;
	case '>':
		vt100_reset();
		break;
	case '7':		/* Save cursor		 */
		savex = x;
		savey = y;
		break;
	case '8':		/* Restore cursor	 */
		x = savex;
		y = savey;
		break;
	default:
		/* Rest not supported */
		break;
	}
}

static void 
putc_gotpars(ch)
	char ch;
{
	int i;

	vt100state = ESnormal;
	switch (ch) {
	case 'A':		/* Up			 */
		y -= par[0] ? par[0] : 1;
		break;
	case 'B':		/* Down			 */
		y += par[0] ? par[0] : 1;
		break;
	case 'C':		/* Right		 */
		x+= par[0] ? par[0] : 1;
		break;
	case 'D':		/* Left			 */
		x-= par[0] ? par[0] : 1;
		break;
	case 'H':		/* Set cursor position	 */
	case 'f':		/* Set cursor position   */
		x = par[1] - 1;
		y = par[0] - 1;
		hanging_cursor = 0;
		break;
	case 'J':		/* Clear part of screen	 */
		clear_screen(par[0]);
		break;
	case 'K':		/* Clear part of line	 */
		clear_line(par[0]);
		break;
	case 'L':		/* Add line		*/
		if (scrreg_top < scrreg_bottom) {
			i = scrreg_top;
			scrreg_top = y;
			scrolldown();
			scrreg_top = i;
		} else
			clear_line(0);
		break;
	case 'M':		/* Delete line		*/
		if (scrreg_top < scrreg_bottom) {
			i = scrreg_top;
			scrreg_top = y;
			scrollup();
			scrreg_top = i;
		} else
			clear_line(0);
		break;
	case 'g':		/* Clear tab stops	 */
		if (numpars >= 1) {
			if (par[0] == 3)
				clear_tabs();
			else if (par[0] == 0)
				tab_stops[x] = 0;
		}
		break;
	case 'm':		/* Set attribute	 */
		for (i = 0; i < numpars; i++) {
			switch (par[i]) {
			case 0:
				attr = ATTR_NONE;
				break;
			case 1:
				attr |= ATTR_BOLD;
				break;
			case 4:
				attr |= ATTR_UNDER;
				break;
			case 7:
				attr |= ATTR_REVERSE;
				break;
			case 21:
				attr &= ~ATTR_BOLD;
				break;
			case 24:
				attr &= ~ATTR_UNDER;
				break;
			case 27:
				attr &= ~ATTR_REVERSE;
				break;
			}
		}
		break;
	case 'r':		/* Set scroll region	 */
		/* ensure top < bottom, and both within limits */
		if ((numpars > 0) && (par[0] < scrrows))
			scrreg_top = par[0] - 1;
		else
			scrreg_top = 0;
		if ((numpars > 1) && (par[1] <= scrrows) && (par[1] > par[0]))
			scrreg_bottom = par[1] - 1;
		else
			scrreg_bottom = scrrows - 1;
		break;
	}
}

static void 
putc_getpars(ch)
	char ch;
{
	switch (ch) {
	case '?':
		/* Not supported */
		return;
	case '[':
		vt100state = ESnormal;
		/* Not supported */
		return;
	default:
		if (ch == ';' && numpars < MAXPARS - 1)
			numpars++;
		else if (ch >= '0' && ch <= '9') {
			par[numpars] *= 10;
			par[numpars] += ch - '0';
		} else {
			numpars++;
			vt100state = ESgotpars;
			putc_gotpars(ch);
		}
	}
}

static void 
putc_square(ch)
	char ch;
{
	unsigned short i;

	for (i = 0; i < MAXPARS; i++)
		par[i] = 0;

	numpars = 0;
	vt100state = ESgetpars;

	putc_getpars(ch);
}

static void 
ite_putchar(ch)
	char ch;
{
	switch (vt100state) {
	default:
		vt100state = ESnormal;	/* FALLTHROUGH */
	case ESnormal:
		putc_normal(ch);
		break;
	case ESesc:
		putc_esc(ch);
		break;
	case ESsquare:
		putc_square(ch);
		break;
	case ESgetpars:
		putc_getpars(ch);
		break;
	case ESgotpars:
		putc_gotpars(ch);
		break;
	}

	if (x >= scrcols)
		x = scrcols - 1;
	if (x < 0)
		x = 0;
	if (y >= scrrows)
		y = scrrows - 1;
	if (y < 0)
		y = 0;
}


/*
 * Keyboard support functions
 */

static int 
ite_pollforchar()
{
	int s;
	register int intbits;

	s = splhigh();

	polledkey = -1;
	adb_polling = 1;

	/* pretend we're VIA interrupt dispatcher */
	while (polledkey == -1) {
		intbits = via_reg(VIA1, vIFR);

		if (intbits & V1IF_ADBRDY) {
			(void)mrg_adbintr();
			via_reg(VIA1, vIFR) = V1IF_ADBRDY;
		}
		if (intbits & 0x10) {
			(void)mrg_pmintr();
			via_reg(VIA1, vIFR) = 0x10;
		}
	}

	adb_polling = 0;

	splx(s);

	return polledkey;
}


/*
 * Autoconfig attachment
 */

struct cfattach ite_ca = {
	sizeof(struct device), itematch, iteattach
};

struct cfdriver ite_cd = {
	NULL, "ite", DV_TTY
};

static int
itematch(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct grfbus_attach_args *ga = aux;
	struct grfmode *gm = ga->ga_grfmode;
	paddr_t pa;

	if (strcmp(ga->ga_name, "ite"))
		return 0;
	pmap_extract(pmap_kernel(), (vaddr_t) gm->fbbase + gm->fboff, &pa);

	return (pa == (vaddr_t) mac68k_vidphys);
}

static void 
iteattach(parent, self, aux)
	struct device *parent, *self;
	void	*aux;
{
	printf(" (minimal console)\n");
	(void) ite_init();
}


/*
 * Tty handling functions
 */

int
iteopen(dev, mode, devtype, p)
	dev_t dev;
	int mode;
	int devtype;
	struct proc *p;
{
	register struct tty *tp;
	register int error;

	dprintf("iteopen(): enter(0x%x)\n", (int) dev);

	if (!ite_initted)
		return (ENXIO);

	if (ite_tty == NULL) {
		tp = ite_tty = ttymalloc();
	} else
		tp = ite_tty;
	if ((tp->t_state & (TS_ISOPEN | TS_XCLUDE)) == (TS_ISOPEN | TS_XCLUDE)
	    && p->p_ucred->cr_uid != 0)
		return (EBUSY);

	tp->t_oproc = itestart;
	tp->t_param = NULL;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = CS8 | CREAD;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		tp->t_state = TS_ISOPEN | TS_CARR_ON;
		ttsetwater(tp);
	}

	error = (*linesw[tp->t_line].l_open) (dev, tp);
	tp->t_winsize.ws_row = scrrows;
	tp->t_winsize.ws_col = scrcols;

	dprintf("iteopen(): exit(%d)\n", error);
	return (error);
}

int
iteclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	dprintf("iteclose: enter (%d)\n", (int) dev);

	(*linesw[ite_tty->t_line].l_close) (ite_tty, flag);
	ttyclose(ite_tty);
#if 0
	ttyfree(ite_tty);
	ite_tty = (struct tty *) 0;
#endif

	dprintf("iteclose: exit\n");
	return 0;
}

int
iteread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	dprintf("iteread: enter\n");
	return (*linesw[ite_tty->t_line].l_read) (ite_tty, uio, flag);
}

int
itewrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	dprintf("itewrite: enter\n");
	return (*linesw[ite_tty->t_line].l_write) (ite_tty, uio, flag);
}

struct tty *
itetty(dev)
	dev_t dev;
{
	return (ite_tty);
}

int
iteioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	int cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	register struct tty *tp = ite_tty;
	int error;

	dprintf("iteioctl: enter(%d, 0x%x)\n", cmd, cmd);

	error = (*linesw[tp->t_line].l_ioctl) (tp, cmd, addr, flag, p);
	if (error >= 0) {
		dprintf("iteioctl: exit(%d)\n", error);
		return (error);
	}

	error = ttioctl(tp, cmd, addr, flag, p);
	if (error >= 0) {
		dprintf("iteioctl: exit(%d)\n", error);
		return (error);
	}

	switch (cmd) {
	case ITEIOC_RINGBELL:
		return mac68k_ring_bell(bell_freq, bell_length, bell_volume);
	case ITEIOC_SETBELL:
		{
			struct bellparams *bp = (void *) addr;

			/* Do some sanity checks. */
			if (bp->freq < 10 || bp->freq > 40000)
				return (EINVAL);
			if (bp->len < 0 || bp->len > 3600)
				return (EINVAL);
			if (bp->vol < 0 || bp->vol > 100)
				return (EINVAL);

			bell_freq = bp->freq;
			bell_length = bp->len;
			bell_volume = bp->vol;
			return (0);
		}
	case ITEIOC_GETBELL:
		{
			struct bellparams *bp = (void *) addr;

			bell_freq = bp->freq;
			bell_length = bp->len;
			bell_volume = bp->vol;
			return (0);
		}
	}

	dprintf("iteioctl: exit(ENOTTY)\n");
	return (ENOTTY);
}

void 
itestart(tp)
	register struct tty *tp;
{
	register int cc, s;

	s = spltty();
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {
		splx(s);
		return;
	}
	tp->t_state |= TS_BUSY;

	cc = tp->t_outq.c_cc;
	splx(s);
	erasecursor();
	while (cc-- > 0)
		ite_putchar(getc(&tp->t_outq));
	drawcursor();

	s = spltty();
	tp->t_state &= ~TS_BUSY;
	splx(s);
}

void 
itestop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY)
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	splx(s);
}

int
ite_intr(event)
	adb_event_t *event;
{
	static int shift = 0, control = 0, capslock = 0;
	int key, press, val, state;
	char str[10], *s;

	key = event->u.k.key;
	press = ADBK_PRESS(key);
	val = ADBK_KEYVAL(key);

	if (val == ADBK_SHIFT)
		shift = press;
	else if (val == ADBK_CAPSLOCK)
		capslock = !capslock;
	else if (val == ADBK_CONTROL)
		control = press;
	else if (press) {
		switch (val) {
		case ADBK_UP:
			str[0] = '\e';
			str[1] = 'O';
			str[2] = 'A';
			str[3] = '\0';
			break;
		case ADBK_DOWN:
			str[0] = '\e';
			str[1] = 'O';
			str[2] = 'B';
			str[3] = '\0';
			break;
		case ADBK_RIGHT:
			str[0] = '\e';
			str[1] = 'O';
			str[2] = 'C';
			str[3] = '\0';
			break;
		case ADBK_LEFT:
			str[0] = '\e';
			str[1] = 'O';
			str[2] = 'D';
			str[3] = '\0';
			break;
		default:
			state = 0;
			if (capslock && isealpha(keyboard[val][1]))
				state = 1;
			if (shift)
				state = 1;
			if (control)
				state = 2;
			str[0] = keyboard[val][state];
			str[1] = '\0';
			break;
		}
		if (adb_polling)
			polledkey = str[0];
		else
			for (s = str; *s; s++)
				(*linesw[ite_tty->t_line].l_rint)(*s, ite_tty);
	}
	return 0;
}
/*
 * Console functions
 */

int
itecnprobe(cp)
	struct consdev *cp;
{
	int maj, unit;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == iteopen)
			break;

	if (maj == nchrdev)
		panic("itecnprobe(): did not find iteopen().");

	unit = 0;		/* hardcode first device as console. */

	/* initialize required fields */
	cp->cn_dev = makedev(maj, unit);
	cp->cn_pri = CN_INTERNAL;

	return 0;
}

int
itecninit(cp)
	struct consdev *cp;
{
	return ite_init();
}

void
itereset()
{
	width = videosize & 0xffff;
	height = (videosize >> 16) & 0xffff;
	scrrows = height / CHARHEIGHT;
	scrcols = width / CHARWIDTH;

	switch (videobitdepth) {
	default:
	case 1:
		putpixel = putpixel1;
		reversepixel = reversepixel1;
		screenrowbytes = (width + 7) >> 3;
		break;
	case 2:
		putpixel = putpixel2;
		reversepixel = reversepixel1;
		screenrowbytes = (width + 3) >> 2;
		break;
	case 4:
		putpixel = putpixel4;
		reversepixel = reversepixel1;
		screenrowbytes = (width + 1) >> 1;
		break;
	case 8:
		putpixel = putpixel8;
		reversepixel = reversepixel1;
		screenrowbytes = width;
		break;
	case 16:
		putpixel = putpixel16;
		reversepixel = reversepixel1;
		screenrowbytes = width*2;
		break;
	case 32:
		putpixel = putpixel32;
		reversepixel = reversepixel1;
		screenrowbytes = width*4;
		break;
	}

	vt100_reset();
}

int
ite_init()
{
	if (ite_initted)
		return 0;

	ite_initted = 1;
	itereset();
	return iteon((dev_t) 0, 0);
}

int
iteon(dev, flags)
	dev_t	dev;
	int	flags;
{
	erasecursor();
	clear_screen(2);
	drawcursor();
	return 0;
}

int
iteoff(dev, flags)
	dev_t	dev;
	int	flags;
{
	erasecursor();
	clear_screen(2);
	return 0;
}

int
itecngetc(dev)
	dev_t	dev;
{
	/* Oh, man... */

	return ite_pollforchar();
}

void
itecnputc(dev, c)
	dev_t	dev;
	int	c;
{
	extern dev_t mac68k_zsdev;
	extern int zscnputc(dev_t dev, int c);

	erasecursor();
	ite_putchar(c);
	drawcursor();
	if (mac68k_machine.serial_boot_echo)
		zscnputc(mac68k_zsdev, c);
}
@


1.25
log
@vm_offset_t -> {vaddr_t, bus_addr_t}
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.24 2004/11/26 21:21:24 miod Exp $	*/
@


1.24
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.23 2003/10/03 16:44:49 miod Exp $	*/
d938 1
a938 1
	pmap_extract(pmap_kernel(), (vm_offset_t) gm->fbbase + gm->fboff, &pa);
d940 1
a940 1
	return (pa == (vm_offset_t) mac68k_vidphys);
@


1.23
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.22 2003/06/02 23:27:48 millert Exp $	*/
d897 1
a897 1
			mrg_adbintr();
d901 1
a901 1
			mrg_pmintr();
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.21 2002/06/11 05:13:37 miod Exp $	*/
a973 1
		tty_attach(tp);
@


1.21
log
@cnputc() routines are void, not int.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.20 2002/03/14 01:26:35 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.19 2001/11/06 19:53:14 miod Exp $	*/
d1337 1
a1337 1
int
a1349 2

	return c;
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.18 2001/06/08 08:08:59 art Exp $	*/
d93 27
a119 27
static __inline void putpixel1 __P((int, int, int *, int));
static void	putpixel2 __P((int, int, int *, int));
static void	putpixel4 __P((int, int, int *, int));
static void	putpixel8 __P((int, int, int *, int));
static void	putpixel16 __P((int, int, int *, int));
static void	putpixel32 __P((int, int, int *, int));
static void	reversepixel1 __P((int, int, int));
static void	writechar __P((char, int, int, int));
static void	drawcursor __P((void));
static void	erasecursor __P((void));
static void	scrollup __P((void));
static void	scrolldown __P((void));
static void	clear_screen __P((int));
static void	clear_line __P((int));
static void	reset_tabs __P((void));
static void	clear_tabs __P((void));
static void	vt100_reset __P((void));
static void	putc_normal __P((char));
static void	putc_esc __P((char));
static void	putc_gotpars __P((char));
static void	putc_getpars __P((char));
static void	putc_square __P((char));
static void	ite_putchar __P((char));
static int	ite_pollforchar __P((void));
static int	itematch __P((struct device *, void *, void *));
static void	iteattach __P((struct device *, struct device *, void *));
static int	ite_init __P((void));
d177 2
a178 2
static void	(*putpixel) __P((int x, int y, int *c, int num));
static void	(*reversepixel) __P((int x, int y, int num));
d1343 1
a1343 1
	extern int zscnputc __P((dev_t dev, int c));
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.19 2001/11/06 19:53:14 miod Exp $	*/
d93 27
a119 27
static __inline void putpixel1(int, int, int *, int);
static void	putpixel2(int, int, int *, int);
static void	putpixel4(int, int, int *, int);
static void	putpixel8(int, int, int *, int);
static void	putpixel16(int, int, int *, int);
static void	putpixel32(int, int, int *, int);
static void	reversepixel1(int, int, int);
static void	writechar(char, int, int, int);
static void	drawcursor(void);
static void	erasecursor(void);
static void	scrollup(void);
static void	scrolldown(void);
static void	clear_screen(int);
static void	clear_line(int);
static void	reset_tabs(void);
static void	clear_tabs(void);
static void	vt100_reset(void);
static void	putc_normal(char);
static void	putc_esc(char);
static void	putc_gotpars(char);
static void	putc_getpars(char);
static void	putc_square(char);
static void	ite_putchar(char);
static int	ite_pollforchar(void);
static int	itematch(struct device *, void *, void *);
static void	iteattach(struct device *, struct device *, void *);
static int	ite_init(void);
d177 2
a178 2
static void	(*putpixel)(int x, int y, int *c, int num);
static void	(*reversepixel)(int x, int y, int num);
d1343 1
a1343 1
	extern int zscnputc(dev_t dev, int c);
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.19.2.1 2002/06/11 03:36:19 art Exp $	*/
d1337 1
a1337 1
void
d1350 2
@


1.18
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.17 1998/05/03 07:12:58 gene Exp $	*/
d79 2
a80 2
#include <vm/vm.h>
#include <vm/pmap.h>
@


1.17
log
@Associated fallout from removing macinfo.h and merging to cpu.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.16 1997/11/14 03:40:58 gene Exp $	*/
d938 1
a938 1
	vm_offset_t pa;
d942 1
a942 1
	pa = pmap_extract(pmap_kernel(), (vm_offset_t) gm->fbbase + gm->fboff);
@


1.17.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.17 1998/05/03 07:12:58 gene Exp $	*/
d938 1
a938 1
	paddr_t pa;
d942 1
a942 1
	pmap_extract(pmap_kernel(), (vm_offset_t) gm->fbbase + gm->fboff, &pa);
@


1.17.8.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 2
a80 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>
@


1.17.8.3
log
@Merge in -current from about a week ago
@
text
@d93 27
a119 27
static __inline void putpixel1(int, int, int *, int);
static void	putpixel2(int, int, int *, int);
static void	putpixel4(int, int, int *, int);
static void	putpixel8(int, int, int *, int);
static void	putpixel16(int, int, int *, int);
static void	putpixel32(int, int, int *, int);
static void	reversepixel1(int, int, int);
static void	writechar(char, int, int, int);
static void	drawcursor(void);
static void	erasecursor(void);
static void	scrollup(void);
static void	scrolldown(void);
static void	clear_screen(int);
static void	clear_line(int);
static void	reset_tabs(void);
static void	clear_tabs(void);
static void	vt100_reset(void);
static void	putc_normal(char);
static void	putc_esc(char);
static void	putc_gotpars(char);
static void	putc_getpars(char);
static void	putc_square(char);
static void	ite_putchar(char);
static int	ite_pollforchar(void);
static int	itematch(struct device *, void *, void *);
static void	iteattach(struct device *, struct device *, void *);
static int	ite_init(void);
d177 2
a178 2
static void	(*putpixel)(int x, int y, int *c, int num);
static void	(*reversepixel)(int x, int y, int num);
d1343 1
a1343 1
	extern int zscnputc(dev_t dev, int c);
@


1.17.8.4
log
@Sync the SMP branch with 3.3
@
text
@d1337 1
a1337 1
void
d1350 2
@


1.17.8.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.17.8.4 2003/03/27 23:28:43 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.8.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d974 1
@


1.16
log
@Fix tabstop handling largely as well as some issues with putchar.  General
cleanup verses vttest to make things prettier.  Still not perfect, though.
From Dave Huang <khym@@bga.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.15 1997/04/14 17:56:45 gene Exp $	*/
a69 1
#include <machine/macinfo.h>
@


1.15
log
@Whoops.  A spurious '{' slipped into an if statement.  This compiles again.
Also, since I'm here, fix some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.14 1997/04/14 01:00:35 briggs Exp $	*/
d109 1
d579 9
d612 1
a612 1
		do {
d614 1
a614 2
			x++;
		} while ((tab_stops[x] == 0) && (x < scrcols));
d672 3
d716 1
a716 8
		i = par[0];
		do {
			if (y == scrreg_top)
				scrolldown();
			else
				y--;
			i--;
		} while (i > 0);
d719 1
a719 8
		i = par[0];
		do {
			if (y == scrreg_bottom)
				scrollup();
			else
				y++;
			i--;
		} while (i > 0);
d728 1
d758 6
a763 2
		if (numpars >= 1 && par[0] == 3)
			reset_tabs();
@


1.14
log
@Capslock support from Steve Brown <sbrown@@best.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.13 1997/04/08 04:41:26 briggs Exp $	*/
d1113 2
a1114 1
itestart(register struct tty * tp)
d1138 3
a1140 1
itestop(struct tty * tp, int flag)
d1152 2
a1153 1
ite_intr(adb_event_t * event)
d1197 1
a1197 1
			if (capslock && isealpha(keyboard[val][1])) {
d1220 2
a1221 1
itecnprobe(struct consdev * cp)
d1243 2
a1244 1
itecninit(struct consdev * cp)
d1306 3
a1308 1
iteon(dev_t dev, int flags)
d1317 3
a1319 1
iteoff(dev_t dev, int flags)
d1327 2
a1328 1
itecngetc(dev_t dev)
d1336 3
a1338 1
itecnputc(dev_t dev, int c)
@


1.13
log
@Changes from Michael R. Zucca <mrz5149@@cs.rit.edu> for 16-bit and 32-bit
console support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.12 1997/04/03 03:53:27 briggs Exp $	*/
d180 2
d1151 1
a1151 1
	static int shift = 0, control = 0;
d1161 2
d1193 2
@


1.12
log
@PR#141 from David Leonard <d@@occult.fnarg.net.au> with some small mods by
me.
- Provide option (enabled in GENERIC and GENERICSBC) to disable ADB
  configuration when serial console is enabled.  Old behavior allows
  booting even if ADB probe hangs (Apple had several ways to access
  ADB).
- Configure ite0 differently--don't assume that it's only extant if it
  is the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.11 1997/03/12 13:26:38 briggs Exp $	*/
d98 2
d265 42
d313 4
d338 18
d399 2
d1237 2
a1238 2
int
ite_init()
a1239 4
	if (ite_initted)
		return 0;

	ite_initted = 1;
d1267 10
d1280 1
d1282 8
@


1.11
log
@Fix for bizarre internal framebuffers that don't start on page boundaries.
Dave Huang found this one...
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.10 1997/03/08 16:16:54 briggs Exp $	*/
d117 1
d881 1
d1166 9
d1207 1
a1207 1
	return iteon(cp->cn_dev, 0);
@


1.10
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.9 1997/01/24 01:35:33 briggs Exp $	*/
d115 1
a115 1
static int	itematch __P((struct device *, struct cfdata *, void *));
d858 1
a858 1
itematch(parent, cf, aux)
d860 1
a860 1
	struct cfdata *cf;
d869 1
a869 1
	pa = pmap_extract(pmap_kernel(), (vm_offset_t) gm->fbbase);
@


1.9
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: ite.c,v 1.8 1997/01/19 03:18:02 briggs Exp $	*/
/*	$NetBSD: ite.c,v 1.30 1996/12/18 03:06:06 scottr Exp $	*/
d68 1
a68 1
#include <machine/viareg.h>
d72 1
a87 1
#include "ascvar.h"
d161 5
d521 1
a521 1
		asc_ringbell();
d1007 1
a1007 4
		{
			asc_ringbell();
			return (0);
		}
d1012 11
a1022 1
			asc_setbellparams(bp->freq, bp->len, bp->vol);
d1029 3
a1031 1
			asc_getbellparams(&bp->freq, &bp->len, &bp->vol);
@


1.8
log
@inline -> __inline
@
text
@d1 2
a2 2
/*	$OpenBSD: ite.c,v 1.7 1996/11/10 14:29:41 briggs Exp $	*/
/*	$NetBSD: ite.c,v 1.27 1996/11/10 09:35:04 scottr Exp $	*/
d115 1
a115 1
static int	itematch __P((struct device *, void *, void *));
d165 1
a165 1
extern u_long	conspa;
d440 1
d853 1
a853 1
itematch(parent, match, aux)
d855 2
a856 1
	void *match, *aux;
d866 1
a866 1
	return (pa == (vm_offset_t) conspa);
@


1.7
log
@NetBSD changes from scottr:
VT220-related emulation additions:
 - Add reset attribute sequences for bold, underline, and reverse
 - Add insert/delete line sequences
 - Recognize but ignore G0/G1 character set sequences

Performance:
 - Speed up clear_line() when clearing the entire line

Also, some stylistic changes for checking/setting scroll region bounds
and in putc_getpars().

These changes make the ITE work properly with the 1.2 termcap file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.6 1996/10/28 14:46:23 briggs Exp $	*/
d94 1
a94 1
static inline void putpixel1 __P((int, int, int *, int));
d177 1
a177 1
static inline void 
@


1.6
log
@Include macinfo.h.
@
text
@d1 2
a2 2
/*	$OpenBSD: ite.c,v 1.5 1996/08/10 21:37:45 briggs Exp $	*/
/*	$NetBSD: ite.c,v 1.24 1996/08/05 01:26:35 scottr Exp $	*/
d374 1
a374 1
	to = (unsigned char *) videoaddr + ((scrreg_top - 1) * linebytes);
d396 1
a396 1
	to = (unsigned char *) videoaddr + (scrreg_bottom * linebytes);
d454 2
d458 1
d477 8
a484 3
		start = 0;
		end = scrcols;
		break;
d504 2
a505 2
	scrreg_top    = 1;
	scrreg_bottom = scrrows;
d531 1
a531 1
		if (y == scrreg_bottom - 1)
d548 1
a548 1
				if (y == scrreg_bottom - 1)
d580 6
d587 1
a587 1
		if (y == scrreg_bottom - 1)
d596 1
a596 1
		if (y == scrreg_top - 1)
d629 1
a629 1
			if (y == scrreg_top - 1)
d639 1
a639 1
			if (y == scrreg_bottom - 1)
d663 18
d700 9
d715 1
a715 1
			scrreg_top = par[0];
d717 1
a717 1
			scrreg_top = 1;
d719 1
a719 1
			scrreg_bottom = par[1];
d721 1
a721 1
			scrreg_bottom = scrrows;
d730 2
a731 1
	if (ch == '?') {
d734 1
a734 2
	}
	if (ch == '[') {
d738 11
a748 10
	}
	if (ch == ';' && numpars < MAXPARS - 1)
		numpars++;
	else if (ch >= '0' && ch <= '9') {
		par[numpars] *= 10;
		par[numpars] += ch - '0';
	} else {
		numpars++;
		vt100state = ESgotpars;
		putc_gotpars(ch);
@


1.5
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.4 1996/06/08 16:21:10 briggs Exp $	*/
d70 1
@


1.4
log
@Sync up with latest NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: ite.c,v 1.3 1996/05/26 18:35:27 briggs Exp $	*/
/*	$NetBSD: ite.c,v 1.23 1996/06/01 00:13:39 scottr Exp $	*/
d59 2
d62 3
a65 1
#include <sys/ioctl.h>
a66 4
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <dev/cons.h>
d76 4
d83 3
a86 1
#include "itevar.h"
d164 2
d809 13
a821 5
itematch(pdp, match, auxp)
	struct device	*pdp;
	void	*match, *auxp;
{
	return 1;
d825 2
a826 2
iteattach(parent, dev, aux)
	struct device *parent, *dev;
a1110 2
	vt100_reset();

d1114 1
a1114 1
		putpixel = putpixel2;
d1134 2
@


1.3
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ite.c,v 1.22 1996/05/25 00:56:38 briggs Exp $	*/
d836 1
a836 1
	if (ite_tty == NULL)
d838 2
a839 1
	else
@


1.2
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ite.c,v 1.16 1995/07/17 01:24:34 briggs Exp $	*/
d67 1
a67 1
#include "../mac68k/via.h"
d76 5
d85 25
d130 32
a161 30
/* Received from MacBSDBoot, stored by Locore: */
long    videoaddr;
long    videorowbytes;
long    videobitdepth;
unsigned long videosize;

/* Calculated in itecninit(): */
static int width, height, scrrows, scrcols;
static void (*putpixel) (int x, int y, int *c, int num);
static void (*reversepixel) (int x, int y, int num);

/* VT100 state: */
#define MAXPARS	16
static int x = 0, y = 0, savex, savey;
static int par[MAXPARS], numpars, hanging_cursor, attr;

/* Our tty: */
struct tty *ite_tty;

/* For polled ADB mode: */
static int polledkey;
extern int adb_polling;

/* Misc */
void    itestart();
static void ite_putchar(char ch);

/* VT100 tab stops & scroll region */
static char tab_stops[255];
static int  scrreg_top, scrreg_bottom;
d168 4
a171 1
putpixel1(int xx, int yy, int *c, int num)
d189 4
a192 1
putpixel2(int xx, int yy, int *c, int num)
d210 4
a213 1
putpixel4(int xx, int yy, int *c, int num)
d231 4
a234 1
putpixel8(int xx, int yy, int *c, int num)
d248 2
a249 1
reversepixel1(int xx, int yy, int num)
d285 3
a287 1
writechar(char ch, int x, int y, int attr)
d289 1
a289 1
	int     i, j, mask, rev, col[CHARHEIGHT];
d304 1
a304 1
			for (i = 0; i < CHARHEIGHT; i++) {
a305 1
			}
d310 1
a310 1
			for (j = 0; j < CHARWIDTH; j++) {
a311 1
			}
d319 1
a319 1
			for (i = 0; i < CHARHEIGHT; i++) {
a320 1
			}
d325 1
a325 1
			for (j = 0; j < CHARWIDTH; j++) {
a326 1
			}
d333 1
a333 1
drawcursor(void)
d335 1
a335 1
	int     j, X, Y;
d340 1
a340 1
	for (j = 0; j < CHARWIDTH; j++) {
a341 1
	}
d345 1
a345 1
erasecursor(void)
d347 1
a347 1
	int     j, X, Y;
d352 1
a352 1
	for (j = 0; j < CHARWIDTH; j++) {
a353 1
	}
d357 1
a357 1
scrollup(void)
d359 16
a374 14
	unsigned long *from, *to;
	int     i, linelongs, tocopy, copying;
	linelongs = videorowbytes * CHARHEIGHT / 4;

	to = (unsigned long *) videoaddr + ((scrreg_top-1) * linelongs);
	from = to + linelongs;

	tocopy = (scrreg_bottom - scrreg_top) * linelongs;
	while (tocopy > 0) {
		copying = (tocopy > 16383) ? 16383 : tocopy;
		bcopy(from, to, copying * 4);
		from += copying;
		to += copying;
		tocopy -= copying;
a375 2
	to = (unsigned long *) videoaddr;
	bzero(to + (scrreg_bottom - 1) * linelongs, linelongs * sizeof(long));
d379 1
a379 1
scrolldown(void)
d381 16
a396 12
	unsigned long *from, *to;
	int     i, linelongs;
	linelongs = videorowbytes * CHARHEIGHT / 4;

	to = (unsigned long *) videoaddr + linelongs * (scrreg_bottom);
	from = to - linelongs;

	for (i = (scrreg_bottom - scrreg_top) * linelongs; i > 0; i--) {
		*--to = *--from;
	}
	for (i = linelongs; i > 0; i--) {
		*--to = 0;
d401 2
a402 1
clear_screen(int which)
d404 2
a405 2
	unsigned long *p;
	int     i, linelongs;
d407 1
a407 2
	p = (unsigned long *) videoaddr;
	linelongs = videorowbytes * CHARHEIGHT / 4;
d411 8
a418 2
		p += y * linelongs;
		i = (scrrows - y) * linelongs;
d421 7
a427 1
		i = y * linelongs;
d430 1
a430 1
		i = scrrows * linelongs;
d434 4
a437 1
	bzero(p, i * sizeof(long));
d441 2
a442 1
clear_line(int which)
d444 1
a444 1
	int     start, end, i;
d454 1
d469 1
a469 1
	for (i = start; i < end; i++) {
a470 1
	}
d472 1
d474 1
a474 1
reset_tabs(void)
d478 1
a478 1
	for (i = 0; i<= scrcols; i++) {
a479 1
	}
d483 1
a483 1
vt100_reset(void)
d485 1
a485 1
	reset_tabs;
d492 2
a493 1
putc_normal(char ch)
d501 1
a501 1
		if (hanging_cursor) {
d503 2
a504 4
		} else
			if (x > 0) {
				x--;
			}
d509 2
a510 1
		} while (tab_stops[x] = 0);
d513 1
a513 1
		if (y == scrreg_bottom - 1) {
d515 1
a515 1
		} else {
a516 1
		}
d530 1
a530 1
				if (y == scrreg_bottom - 1) {
d532 1
a532 1
				} else {
a533 1
				}
d536 1
d538 2
a539 1
			if (x == scrcols - 1) {
d541 1
a541 1
			} else {
a542 1
			}
d553 2
a554 1
putc_esc(char ch)
d563 1
a563 1
		if (y == scrreg_bottom - 1) {
d565 1
a565 1
		} else {
a566 1
		}
d572 1
a572 1
		if (y == scrreg_top - 1) {
d574 1
a574 1
		} else {
a575 1
		}
d595 2
a596 1
putc_gotpars(char ch)
d598 1
a598 1
	int     i;
d605 1
a605 1
			if (y == scrreg_top - 1) {
d607 1
a607 1
			} else {
a608 1
			};
d615 1
a615 1
			if (y == scrreg_bottom - 1) {
d617 1
a617 1
			} else {
a618 1
			};
d640 1
a640 1
		if (numpars >= 1 && par[0] == 3) {
a641 1
		}
d663 1
a663 1
		if ((numpars > 0) && (par[0] < scrrows)) {
d665 1
a665 1
		} else {
d667 1
a667 2
		}
		if ((numpars > 1) && (par[1] <= scrrows) && (par[1] > par[0])) {
d669 1
a669 1
		} else {
a670 1
		}
d676 2
a677 1
putc_getpars(char ch)
d688 1
a688 1
	if (ch == ';' && numpars < MAXPARS - 1) {
d690 8
a697 9
	} else
		if (ch >= '0' && ch <= '9') {
			par[numpars] *= 10;
			par[numpars] += ch - '0';
		} else {
			numpars++;
			vt100state = ESgotpars;
			putc_gotpars(ch);
		}
d701 2
a702 1
putc_square(char ch)
d704 1
a704 1
	int     i;
d706 1
a706 1
	for (i = 0; i < MAXPARS; i++) {
a707 1
	}
d716 2
a717 1
ite_putchar(char ch)
d720 2
a721 1
		default:vt100state = ESnormal;	/* FALLTHROUGH */
d739 1
a739 1
	if (x >= scrcols) {
d741 1
a741 2
	}
	if (x < 0) {
d743 1
a743 2
	}
	if (y >= scrrows) {
d745 1
a745 2
	}
	if (y < 0) {
a746 1
	}
d748 2
d755 1
a755 10
ite_dopollkey(int key)
{
	polledkey = key;

	return 0;
}


static int 
ite_pollforchar(void)
d757 1
a757 1
	int     s;
d785 2
d788 1
a788 1
 * Tty handling functions
d791 16
d808 3
a810 1
iteattach(struct device * parent, struct device * dev, void *aux)
a814 1
extern int matchbyname();
d816 3
a818 3
struct cfdriver itecd = {
	NULL, "ite", matchbyname, iteattach, DV_TTY, sizeof(struct device)
};
d821 5
a825 1
iteopen(dev_t dev, int mode, int devtype, struct proc * p)
a828 1
	int     first = 0;
d831 4
d842 1
d856 1
d860 1
d866 5
a870 1
iteclose(dev_t dev, int flag, int mode, struct proc * p)
d873 1
d880 1
d886 4
a889 1
iteread(dev_t dev, struct uio * uio, int flag)
a892 1
	dprintf("iteread: exit\n");
d896 4
a899 1
itewrite(dev_t dev, struct uio * uio, int flag)
a902 1
	dprintf("itewrite: exit\n");
d907 1
a907 1
	dev_t   dev;
d913 6
a918 1
iteioctl(dev_t dev, int cmd, caddr_t addr, int flag, struct proc * p)
d921 1
a921 1
	int     error;
d924 1
d930 1
d936 1
d938 2
a939 1
	case ITEIOC_RINGBELL:{
d943 2
a944 1
	case ITEIOC_SETBELL:{
d950 2
a951 1
	case ITEIOC_GETBELL:{
d958 1
a966 1
	int     hiwat = 0, hadcursor = 0;
d978 1
a978 1
	while (cc-- > 0) {
a979 1
	}
d990 1
a990 1
	int     s;
d993 2
a994 2
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0) {
a995 2
		}
	}
d1003 2
a1004 2
	int     key, press, val, state;
	char    str[10], *s;
d1010 1
a1010 1
	if (val == ADBK_SHIFT) {
d1012 45
a1056 50
	} else
		if (val == ADBK_CONTROL) {
			control = press;
		} else
			if (press) {
				switch (val) {
				case ADBK_UP:
					str[0] = '\e';
					str[1] = 'O';
					str[2] = 'A';
					str[3] = '\0';
					break;
				case ADBK_DOWN:
					str[0] = '\e';
					str[1] = 'O';
					str[2] = 'B';
					str[3] = '\0';
					break;
				case ADBK_RIGHT:
					str[0] = '\e';
					str[1] = 'O';
					str[2] = 'C';
					str[3] = '\0';
					break;
				case ADBK_LEFT:
					str[0] = '\e';
					str[1] = 'O';
					str[2] = 'D';
					str[3] = '\0';
					break;
				default:
					state = 0;
					if (shift) {
						state = 1;
					}
					if (control) {
						state = 2;
					}
					str[0] = keyboard[val][state];
					str[1] = '\0';
					break;
				}
				if (adb_polling) {
					polledkey = str[0];
				} else {
					for (s = str; *s; s++) {
						(*linesw[ite_tty->t_line].l_rint) (*s, ite_tty);
					}
				}
			}
d1065 1
a1065 1
	int     maj, unit;
d1068 2
a1069 2
	for (maj = 0; maj < nchrdev; maj++) {
		if (cdevsw[maj].d_open == iteopen) {
a1070 2
		}
	}
d1072 1
a1072 1
	if (maj == nchrdev) {
d1074 1
a1074 1
	}
d1080 2
d1087 1
d1100 1
d1105 1
d1110 1
d1115 1
d1119 1
a1119 1
	iteon(cp->cn_dev, 0);
d1128 1
d1136 1
d1150 2
a1151 4
	extern dev_t mac68k_serdev;
	int     s;

/* 	s = splhigh (); */
d1157 1
a1157 1
		sercnputc(mac68k_serdev, c);
d1159 1
a1159 1
/* 	splx (s); */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
