head	1.23;
access;
symbols
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.26
	OPENBSD_5_0:1.22.0.24
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.22
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.20
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.16
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.18
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.14
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.12
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.10
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.8
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.6
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.6
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.14
	OPENBSD_2_9_BASE:1.13
	NIKLAS_UNDEAD:1.13.0.12
	OPENBSD_2_8:1.13.0.10
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.8
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.6
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.6
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.4
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.22;

1.22
date	2006.01.16.21.45.57;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.23.23.36.26;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.08.06.59.43;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.03.12.10.47;	author todd;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.14.10.47.36;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.13.18.26.12;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.08.17.30.40;	author aaron;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.01.11.05.11.34;	author millert;	state Exp;
branches
	1.13.6.1;
next	1.12;

1.12
date	98.05.03.07.12.59;	author gene;	state Exp;
branches;
next	1.11;

1.11
date	97.04.27.19.28.39;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.04.07.12.56.45;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.03.08.16.16.54;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.01.24.01.35.33;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.10.28.14.46.23;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.06.08.16.21.11;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.05.26.18.35.28;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.18.13.43;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.01.25.05.28.23;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.11.35.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches;
next	;

1.13.6.1
date	2001.07.04.10.18.28;	author niklas;	state Exp;
branches;
next	1.13.6.2;

1.13.6.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.13.6.3;

1.13.6.3
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2002.10.29.00.28.05;	author art;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: mac68k5380.c,v 1.22 2006/01/16 21:45:57 miod Exp $	*/
/*	$NetBSD: mac68k5380.c,v 1.29 1997/02/28 15:50:50 scottr Exp $	*/

/*
 * Copyright (c) 1995 Allen Briggs
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Allen Briggs
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Derived from atari5380.c for the mac68k port of NetBSD.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/syslog.h>
#include <sys/buf.h>
#include <scsi/scsi_all.h>
#include <scsi/scsi_message.h>
#include <scsi/scsiconf.h>

/*
 * Include the driver definitions
 */

#include <machine/viareg.h>

#include "ncr5380reg.h"
#include "ncr5380var.h"

/*
 * Set the various driver options
 */
#define	NREQ		18	/* Size of issue queue			*/
#define	AUTO_SENSE	1	/* Automatically issue a request-sense 	*/

#define	DRNAME		ncrscsi	/* used in various prints	*/
#undef	DBG_SEL			/* Show the selection process		*/
#undef	DBG_REQ			/* Show enqueued/ready requests		*/
#undef	DBG_NOWRITE		/* Do not allow writes to the targets	*/
#undef	DBG_PIO			/* Show the polled-I/O process		*/
#undef	DBG_INF			/* Show information transfer process	*/
#define	DBG_NOSTATIC		/* No static functions, all in DDB trace*/
#define	DBG_PID		25	/* Keep track of driver			*/
#ifdef DBG_NOSTATIC
#	define	static
#endif
#ifdef DBG_SEL
#	define	DBG_SELPRINT(a,b)	printf(a,b)
#else
#	define DBG_SELPRINT(a,b)
#endif
#ifdef DBG_PIO
#	define DBG_PIOPRINT(a,b,c) 	printf(a,b,c)
#else
#	define DBG_PIOPRINT(a,b,c)
#endif
#ifdef DBG_INF
#	define DBG_INFPRINT(a,b,c)	a(b,c)
#else
#	define DBG_INFPRINT(a,b,c)
#endif
#ifdef DBG_PID
	/* static	char	*last_hit = NULL, *olast_hit = NULL; */
	static char *last_hit[DBG_PID];
#	define	PID(a)	\
	{ int i; \
	  for (i=0; i < DBG_PID-1; i++) \
		last_hit[i] = last_hit[i + 1]; \
	  last_hit[DBG_PID - 1] = a; }
#else
#	define	PID(a)
#endif

#undef 	REAL_DMA		/* Use DMA if sensible			*/
#define scsi_ipending()		(GET_5380_REG(NCR5380_DMSTAT) & SC_IRQ_SET)
#define fair_to_keep_dma()	1
#define claimed_dma()		1
#define reconsider_dma()
#define	USE_PDMA	1	/* Use special pdma-transfer function	*/
#define MIN_PHYS	0x2000	/* pdma space w/ /DSACK is only 0x2000  */

#define	ENABLE_NCR5380(sc)	cur_softc = sc;

/*
 * softc of currently active controller (well, we only have one for now).
 */

static struct ncr_softc	*cur_softc;

struct scsi_5380 {
	volatile u_char	scsi_5380[8*16]; /* 8 regs, 1 every 16th byte. */
};

extern vaddr_t		SCSIBase;
static volatile u_char	*ncr		= (volatile u_char *) 0x10000;
static volatile u_char	*ncr_5380_with_drq	= (volatile u_char *)  0x6000;
static volatile u_char	*ncr_5380_without_drq	= (volatile u_char *) 0x12000;

#define SCSI_5380		((struct scsi_5380 *) ncr)
#define GET_5380_REG(rnum)	SCSI_5380->scsi_5380[((rnum)<<4)]
#define SET_5380_REG(rnum,val)	(SCSI_5380->scsi_5380[((rnum)<<4)] = (val))

static int	ncr5380_irq_intr(void *);
static int	ncr5380_drq_intr(void *);
static void	do_ncr5380_drq_intr(void *);

static __inline__ void	scsi_clr_ipend(void);
static		  void	scsi_mach_init(struct ncr_softc *sc);
static		  int	machine_match(struct device *parent,
			    struct cfdata *cf, void *aux,
			    struct cfdriver *cd);
static __inline__ int	pdma_ready(void);
static		  int	transfer_pdma(u_char *phasep, u_char *data,
					u_long *count);

static __inline__ void
scsi_clr_ipend(void)
{
	int tmp;

	tmp = GET_5380_REG(NCR5380_IRCV);
	scsi_clear_irq();
}

static void
scsi_mach_init(sc)
	struct ncr_softc	*sc;
{
	static int initted = 0;

	if (initted++)
		panic("scsi_mach_init called again.");

	ncr		= (volatile u_char *)
			  (SCSIBase + (u_long) ncr);
	ncr_5380_with_drq	= (volatile u_char *)
			  (SCSIBase + (u_int) ncr_5380_with_drq);
	ncr_5380_without_drq	= (volatile u_char *)
			  (SCSIBase + (u_int) ncr_5380_without_drq);

	if (VIA2 == VIA2OFF) {
		scsi_enable = Via1Base + VIA2 * 0x2000 + vIER;
		scsi_flag   = Via1Base + VIA2 * 0x2000 + vIFR;
	} else {
		scsi_enable = Via1Base + VIA2 * 0x2000 + rIER;
		scsi_flag   = Via1Base + VIA2 * 0x2000 + rIFR;
	}

	sc->sc_ih_irq.vh_fn = ncr5380_irq_intr;
	sc->sc_ih_irq.vh_arg = sc;
	sc->sc_ih_irq.vh_ipl = VIA2_SCSIIRQ;
	via2_register_irq(&sc->sc_ih_irq, sc->sc_dev.dv_xname);
	sc->sc_ih_drq.vh_fn = ncr5380_drq_intr;
	sc->sc_ih_drq.vh_arg = sc;
	sc->sc_ih_drq.vh_ipl = VIA2_SCSIDRQ;
	via2_register_irq(&sc->sc_ih_drq, sc->sc_dev.dv_xname);
}

static int
machine_match(parent, cf, aux, cd)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
	struct cfdriver *cd;
{
	if (!mac68k_machine.scsi80)
		return 0;
	return 1;
}

#if USE_PDMA
int	pdma_5380_dir = 0;

u_char	*pending_5380_data;
u_long	pending_5380_count;

#define NCR5380_PDMA_DEBUG 1 	/* Maybe we try with this off eventually. */

#if NCR5380_PDMA_DEBUG
int		pdma_5380_sends = 0;
int		pdma_5380_bytes = 0;

void
pdma_stat(void)
{
	printf("PDMA SCSI: %d xfers completed for %d bytes.\n",
		pdma_5380_sends, pdma_5380_bytes);
	printf("pdma_5380_dir = %d\t",
		pdma_5380_dir);
	printf("datap = %p, remainder = %ld.\n",
		pending_5380_data, pending_5380_count);
	scsi_show();
}
#endif

void
pdma_cleanup(void)
{
	SC_REQ	*reqp = connected;
	int	s;

	s = splbio();
	PID("pdma_cleanup0");

	pdma_5380_dir = 0;

#if NCR5380_PDMA_DEBUG
	pdma_5380_sends++;
	pdma_5380_bytes+=(reqp->xdata_len - pending_5380_count);
#endif

	/*
	 * Update pointers.
	 */
	reqp->xdata_ptr += reqp->xdata_len - pending_5380_count;
	reqp->xdata_len  = pending_5380_count;

	/*
	 * Reset DMA mode.
	 */
	SET_5380_REG(NCR5380_MODE, GET_5380_REG(NCR5380_MODE) & ~SC_M_DMA);

	/*
	 * Clear any pending interrupts.
	 */
	scsi_clr_ipend();

	/*
	 * Tell interrupt functions that DMA has ended.
	 */
	reqp->dr_flag &= ~DRIVER_IN_DMA;

	SET_5380_REG(NCR5380_MODE, IMODE_BASE);
	SET_5380_REG(NCR5380_ICOM, 0);

	splx(s);

	/*
	 * Back for more punishment.
	 */
	PID("pdma_cleanup1");
	run_main(cur_softc);
	PID("pdma_cleanup2");
}
#endif

static __inline__ int
pdma_ready(void)
{
#if USE_PDMA
	SC_REQ	*reqp = connected;
	int	dmstat, idstat;
extern	u_char	ncr5380_no_parchk;

	PID("pdma_ready0");
	if (pdma_5380_dir) {
		PID("pdma_ready1.");
		/*
		 * For a phase mis-match, ATN is a "don't care," IRQ is 1 and
		 * all other bits in the Bus & Status Register are 0.  Also,
		 * the current SCSI Bus Status Register has a 1 for BSY and
		 * REQ.  Since we're just checking that this interrupt isn't a
		 * reselection or a reset, we just check for either.
		 */
		dmstat = GET_5380_REG(NCR5380_DMSTAT);
		idstat = GET_5380_REG(NCR5380_IDSTAT);
		if (   ((dmstat & (0xff & ~SC_ATN_STAT)) == SC_IRQ_SET)
		    && ((idstat & (SC_S_BSY|SC_S_REQ))
			== (SC_S_BSY | SC_S_REQ)) ) {
			PID("pdma_ready2");
			pdma_cleanup();
			return 1;
		} else if (PH_IN(reqp->phase) && (dmstat & SC_PAR_ERR)) {
			if (!(ncr5380_no_parchk & (1 << reqp->targ_id)))
				/* XXX: Should be parity error ???? */
				reqp->xs->error = XS_DRIVER_STUFFUP;
			PID("pdma_ready3");
			/* XXX: is this the right reaction? */
			pdma_cleanup();
			return 1;
		} else if (   !(idstat & SC_S_REQ)
			   || (((idstat>>2) & 7) != reqp->phase)) {
#ifdef DIAGNOSTIC
			/* XXX: is this the right reaction? Can this happen? */
			scsi_show();
			printf("Unexpected phase change.\n");
#endif
			reqp->xs->error = XS_DRIVER_STUFFUP;
			pdma_cleanup();
			return 1;
		} else {
			scsi_show();
			panic("Spurious interrupt during PDMA xfer.");
		}
	} else
		PID("pdma_ready4");
#endif
	return 0;
}

static int
ncr5380_irq_intr(p)
	void	*p;
{
	PID("irq");

#if USE_PDMA
	if (pdma_ready()) {
		return (1);
	}
#endif
	scsi_idisable();
	ncr_ctrl_intr(cur_softc);
	return (1);
}

/*
 * This is the meat of the PDMA transfer.
 * When we get here, we shove data as fast as the mac can take it.
 * We depend on several things:
 *   * All macs after the Mac Plus that have a 5380 chip should have a general
 *     logic IC that handshakes data for blind transfers.
 *   * If the SCSI controller finishes sending/receiving data before we do,
 *     the same general logic IC will generate a /BERR for us in short order.
 *   * The fault address for said /BERR minus the base address for the
 *     transfer will be the amount of data that was actually written.
 *
 * We use the nofault flag and the setjmp/longjmp in locore.s so we can
 * detect and handle the bus error for early termination of a command.
 * This is usually caused by a disconnecting target.
 */
static void
do_ncr5380_drq_intr(p)
	void	*p;
{
#if USE_PDMA
extern	int			*nofault, m68k_fault_addr;
	label_t			faultbuf;
	register int		count;
	volatile u_int32_t	*long_drq;
	u_int32_t		*long_data;
	volatile u_int8_t	*drq, tmp_data;
	u_int8_t		*data;

#if DBG_PID
	if (pdma_5380_dir == 2) {
		PID("drq (in)");
	} else {
		PID("drq (out)");
	}
#endif

	/*
	 * Setup for a possible bus error caused by SCSI controller
	 * switching out of DATA-IN/OUT before we're done with the
	 * current transfer.
	 */
	nofault = (int *) &faultbuf;

	if (setjmp((label_t *) nofault)) {
		PID("drq berr");
		nofault = (int *) 0;
		count = (  (u_long) m68k_fault_addr
			 - (u_long) ncr_5380_with_drq);
		if ((count < 0) || (count > pending_5380_count)) {
			printf("pdma %s: cnt = %d (0x%x) (pending cnt %ld)\n",
				(pdma_5380_dir == 2) ? "in" : "out",
				count, count, pending_5380_count);
			panic("something is wrong");
		}

		pending_5380_data += count;
		pending_5380_count -= count;

		m68k_fault_addr = 0;

		PID("end drq early");

		return;
	}

	if (pdma_5380_dir == 2) { /* Data In */
		int	resid;

		/*
		 * Get the dest address aligned.
		 */
		resid = count = min(pending_5380_count,
				    4 - (((int) pending_5380_data) & 0x3));
		if (count && (count < 4)) {
			data = (u_int8_t *) pending_5380_data;
			drq = (u_int8_t *) ncr_5380_with_drq;
			while (count) {
#define R1	*data++ = *drq++
				R1; count--;
#undef R1
			}
			pending_5380_data += resid;
			pending_5380_count -= resid;
		}

		/*
		 * Get ready to start the transfer.
		 */
		while (pending_5380_count) {
		int dcount;

		dcount = count = min(pending_5380_count, MIN_PHYS);
		long_drq = (volatile u_int32_t *) ncr_5380_with_drq;
		long_data = (u_int32_t *) pending_5380_data;

#define R4	*long_data++ = *long_drq++
		while ( count > 64 ) {
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;	/* 64 */
			count -= 64;
		}
		while (count > 8) {
			R4; R4; count -= 8;
		}
#undef R4
		data = (u_int8_t *) long_data;
		drq = (u_int8_t *) long_drq;
		while (count) {
#define R1	*data++ = *drq++
			R1; count--;
#undef R1
		}
		pending_5380_count -= dcount;
		pending_5380_data += dcount;
		}
	} else {
		int	resid;

		/*
		 * Get the source address aligned.
		 */
		resid = count = min(pending_5380_count,
				    4 - (((int) pending_5380_data) & 0x3));
		if (count && (count < 4)) {
			data = (u_int8_t *) pending_5380_data;
			drq = (u_int8_t *) ncr_5380_with_drq;
			while (count) {
#define W1	*drq++ = *data++
				W1; count--;
#undef W1
			}
			pending_5380_data += resid;
			pending_5380_count -= resid;
		}

		/*
		 * Get ready to start the transfer.
		 */
		while (pending_5380_count) {
		int dcount;

		dcount = count = min(pending_5380_count, MIN_PHYS);
		long_drq = (volatile u_int32_t *) ncr_5380_with_drq;
		long_data = (u_int32_t *) pending_5380_data;

#define W4	*long_drq++ = *long_data++
		while ( count > 64 ) {
			W4; W4; W4; W4; W4; W4; W4; W4;
			W4; W4; W4; W4; W4; W4; W4; W4; /*  64 */
			count -= 64;
		}
		while ( count > 8 ) {
			W4; W4;
			count -= 8;
		}
#undef W4
		data = (u_int8_t *) long_data;
		drq = (u_int8_t *) long_drq;
		while (count) {
#define W1	*drq++ = *data++
			W1; count--;
#undef W1
		}
		pending_5380_count -= dcount;
		pending_5380_data += dcount;
		}

		PID("write complete");

		drq = (volatile u_int8_t *) ncr_5380_with_drq;
		tmp_data = *drq;

		PID("read a byte to force a phase change");
	}

	/*
	 * OK.  No bus error occurred above.  Clear the nofault flag
	 * so we no longer short-circuit bus errors.
	 */
	nofault = (int *) 0;

	PID("end drq");
#endif	/* if USE_PDMA */
}

static int
ncr5380_drq_intr(p)
	void	*p;
{
	int rv = 0;

	while (GET_5380_REG(NCR5380_DMSTAT) & SC_DMA_REQ) {
		do_ncr5380_drq_intr(p);
		scsi_clear_drq();
		rv = 1;
	}

	return (rv);
}

#if USE_PDMA

#define SCSI_TIMEOUT_VAL	10000000

static int
transfer_pdma(phasep, data, count)
	u_char	*phasep;
	u_char	*data;
	u_long	*count;
{
	SC_REQ *reqp = connected;
	int len = *count, s, scsi_timeout = SCSI_TIMEOUT_VAL;

	if (pdma_5380_dir) {
		panic("ncrscsi: transfer_pdma called when operation already "
			"pending.");
	}
	PID("transfer_pdma0")

	/*
 	 * Don't bother with PDMA if we can't sleep or for small transfers.
 	 */
	if (reqp->dr_flag & DRIVER_NOINT) {
		PID("pdma, falling back to transfer_pio.")
		transfer_pio(phasep, data, count, 0);
		return -1;
	}

	/*
	 * We are probably already at spl2(), so this is likely a no-op.
	 * Paranoia.
	 */
	s = splbio();

	scsi_idisable();

	/*
	 * Match phases with target.
	 */
	SET_5380_REG(NCR5380_TCOM, *phasep);

	/*
	 * Clear pending interrupts.
	 */
	scsi_clr_ipend();

	/*
	 * Wait until target asserts BSY.
	 */
	while (    ((GET_5380_REG(NCR5380_IDSTAT) & SC_S_BSY) == 0)
		&& (--scsi_timeout) );
	if (!scsi_timeout) {
#ifdef DIAGNOSTIC
		printf("scsi timeout: waiting for BSY in %s.\n",
			(*phasep == PH_DATAOUT) ? "pdma_out" : "pdma_in");
#endif
		goto scsi_timeout_error;
	}

	/*
	 * Tell the driver that we're in DMA mode.
	 */
	reqp->dr_flag |= DRIVER_IN_DMA;

	/*
	 * Load transfer values for DRQ interrupt handlers.
	 */
	pending_5380_data = data;
	pending_5380_count = len;

	/*
	 * Set the transfer function to be called on DRQ interrupts.
	 * And note that we're waiting.
	 */
	switch (*phasep) {
	default:
		panic("Unexpected phase in transfer_pdma.");
	case PH_DATAOUT:
		pdma_5380_dir = 1;
		SET_5380_REG(NCR5380_ICOM, GET_5380_REG(NCR5380_ICOM)|SC_ADTB);
		SET_5380_REG(NCR5380_MODE, GET_5380_REG(NCR5380_MODE)|SC_M_DMA);
		SET_5380_REG(NCR5380_DMSTAT, 0);
		break;
	case PH_DATAIN:
		pdma_5380_dir = 2;
		SET_5380_REG(NCR5380_ICOM, 0);
		SET_5380_REG(NCR5380_MODE, GET_5380_REG(NCR5380_MODE)|SC_M_DMA);
		SET_5380_REG(NCR5380_IRCV, 0);
		break;
	}

	PID("waiting for interrupt.")

	/*
	 * Now that we're set up, enable interrupts and drop processor
	 * priority back down.
	 */
	scsi_ienable();
	splx(s);
	return 0;

scsi_timeout_error:
	/*
	 * Clear the DMA mode.
	 */
	SET_5380_REG(NCR5380_MODE, GET_5380_REG(NCR5380_MODE) & ~SC_M_DMA);
	splx(s);
	return -1;
}
#endif /* if USE_PDMA */

/* Include general routines. */
#include <mac68k/dev/ncr5380.c>
@


1.22
log
@Let the intrhand structs be softc fields, rather than static global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.21 2005/07/23 23:36:26 martin Exp $	*/
@


1.21
log
@- no need to include sys/dkstat.h
- some formatting fixes and KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.20 2004/12/08 06:59:43 miod Exp $	*/
a49 1
#include "ncr5380reg.h"
a50 1
#include <machine/stdarg.h>
d53 1
a155 1
	static struct via2hand ih_irq, ih_drq;
d175 8
a182 8
	ih_irq.vh_fn = ncr5380_irq_intr;
	ih_irq.vh_arg = sc;
	ih_irq.vh_ipl = VIA2_SCSIIRQ;
	via2_register_irq(&ih_irq, sc->sc_dev.dv_xname);
	ih_drq.vh_fn = ncr5380_drq_intr;
	ih_drq.vh_arg = sc;
	ih_drq.vh_ipl = VIA2_SCSIDRQ;
	via2_register_irq(&ih_drq, sc->sc_dev.dv_xname);
@


1.20
log
@Tweak interrupt handling code to allow shared interrupts for VIA2 sources.
This will be necessary shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.19 2004/11/26 21:21:24 miod Exp $	*/
a40 1
#include <sys/dkstat.h>
d94 3
a96 3
	  for (i=0; i< DBG_PID-1; i++) \
		last_hit[i] = last_hit[i+1]; \
	  last_hit[DBG_PID-1] = a; }
d121 1
a121 1
extern vm_offset_t	SCSIBase;
d144 1
a144 1
scsi_clr_ipend()
d146 1
a146 1
	int	tmp;
d156 1
a156 1
	static int	initted = 0;
d212 1
a212 1
pdma_stat()
d276 1
a276 1
pdma_ready()
d555 2
a556 2
	SC_REQ	*reqp = connected;
	int	len = *count, s, scsi_timeout = SCSI_TIMEOUT_VAL;
@


1.19
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.18 2004/08/03 12:10:47 todd Exp $	*/
d158 1
d178 8
a185 4
	via2_register_irq(VIA2_SCSIIRQ, ncr5380_irq_intr, sc,
	    sc->sc_dev.dv_xname);
	via2_register_irq(VIA2_SCSIDRQ, ncr5380_drq_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.18
log
@the rest of the '#if DIAGNOSTIC' -> '#ifdef DIAGNOSTIC' in the kernel; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.17 2003/03/14 10:47:36 miod Exp $	*/
d131 2
a132 2
static void	ncr5380_irq_intr(void *);
static void	ncr5380_drq_intr(void *);
d177 4
a180 2
	via2_register_irq(VIA2_SCSIIRQ, ncr5380_irq_intr, sc);
	via2_register_irq(VIA2_SCSIDRQ, ncr5380_drq_intr, sc);
d325 1
a325 1
static void
d333 1
a333 1
		return;
d338 1
a522 3
	return;
#else
	return;
d526 1
a526 1
static void
d530 2
d535 1
d537 2
@


1.17
log
@spl police.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.16 2002/10/13 18:26:12 krw Exp $	*/
d588 1
a588 1
#if DIAGNOSTIC
@


1.16
log
@Remove more '\n's from panic() statements.  From Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.15 2002/03/14 01:26:35 millert Exp $	*/
d642 1
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.14 2001/05/08 17:30:40 aaron Exp $	*/
d551 1
a551 1
			"pending.\n");
@


1.14
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.13 1999/01/11 05:11:34 millert Exp $	*/
d133 1
a133 1
static void	do_ncr5380_drq_intr __P((void *));
d135 3
a137 3
static __inline__ void	scsi_clr_ipend __P((void));
static		  void	scsi_mach_init __P((struct ncr_softc *sc));
static		  int	machine_match __P((struct device *parent,
d139 4
a142 4
			    struct cfdriver *cd));
static __inline__ int	pdma_ready __P((void));
static		  int	transfer_pdma __P((u_char *phasep, u_char *data,
					u_long *count));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.14 2001/05/08 17:30:40 aaron Exp $	*/
d133 1
a133 1
static void	do_ncr5380_drq_intr(void *);
d135 3
a137 3
static __inline__ void	scsi_clr_ipend(void);
static		  void	scsi_mach_init(struct ncr_softc *sc);
static		  int	machine_match(struct device *parent,
d139 4
a142 4
			    struct cfdriver *cd);
static __inline__ int	pdma_ready(void);
static		  int	transfer_pdma(u_char *phasep, u_char *data,
					u_long *count);
@


1.14.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.14.4.1 2002/06/11 03:36:19 art Exp $	*/
d551 1
a551 1
			"pending.");
@


1.14.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a641 1
	splx(s);
@


1.13
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.12 1998/05/03 07:12:59 gene Exp $	*/
d358 1
a358 1
extern	int			*nofault, mac68k_buserr_addr;
d384 1
a384 1
		count = (  (u_long) mac68k_buserr_addr
d396 1
a396 1
		mac68k_buserr_addr = 0;
@


1.13.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.13 1999/01/11 05:11:34 millert Exp $	*/
d358 1
a358 1
extern	int			*nofault, m68k_fault_addr;
d384 1
a384 1
		count = (  (u_long) m68k_fault_addr
d396 1
a396 1
		m68k_fault_addr = 0;
@


1.13.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 1
a133 1
static void	do_ncr5380_drq_intr(void *);
d135 3
a137 3
static __inline__ void	scsi_clr_ipend(void);
static		  void	scsi_mach_init(struct ncr_softc *sc);
static		  int	machine_match(struct device *parent,
d139 4
a142 4
			    struct cfdriver *cd);
static __inline__ int	pdma_ready(void);
static		  int	transfer_pdma(u_char *phasep, u_char *data,
					u_long *count);
@


1.13.6.3
log
@Sync the SMP branch with 3.3
@
text
@d551 1
a551 1
			"pending.");
a641 1
	splx(s);
@


1.12
log
@Associated fallout from removing macinfo.h and merging to cpu.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.11 1997/04/27 19:28:39 briggs Exp $	*/
d160 1
a160 1
		panic("scsi_mach_init called again.\n");
d315 1
a315 1
			panic("Spurious interrupt during PDMA xfer.\n");
d612 1
a612 1
		panic("Unexpected phase in transfer_pdma.\n");
@


1.11
log
@What was I thinking?
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.10 1997/04/07 12:56:45 briggs Exp $	*/
a53 1
#include <machine/macinfo.h>
@


1.10
log
@Perhaps improve reliability with some small performance sacrifice.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.9 1997/03/08 16:16:54 briggs Exp $	*/
a453 6
		/*
		 * OK.  No bus error occurred above.  Clear the nofault flag
		 * so we no longer short-circuit bus errors.
		 */
		nofault = (int *) 0;

a507 6
		/*
		 * OK.  No bus error occurred above.  Clear the nofault flag
		 * so we no longer short-circuit bus errors.
		 */
		nofault = (int *) 0;

d513 6
@


1.9
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.8 1997/01/24 01:35:33 briggs Exp $	*/
d435 1
a435 1
		while ( count >= 64 ) {
d440 2
a441 2
		while (count >= 4) {
			R4; count -= 4;
d454 6
d491 1
a491 1
		while ( count >= 64 ) {
d496 3
a498 2
		while (count >= 4) {
			W4; count -= 4;
d511 1
d514 6
d523 1
a523 3
		PID("read a byte?");

		nofault = (int *) 0;
a524 6

	/*
	 * OK.  No bus error occurred above.  Clear the nofault flag
	 * so we no longer short-circuit bus errors.
	 */
	nofault = (int *) 0;
@


1.8
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: mac68k5380.c,v 1.7 1996/10/28 14:46:23 briggs Exp $	*/
/*	$NetBSD: mac68k5380.c,v 1.28 1996/12/19 21:48:17 scottr Exp $	*/
d178 2
a179 2
	mac68k_register_scsi_irq(ncr5380_irq_intr, sc);
	mac68k_register_scsi_drq(ncr5380_drq_intr, sc);
@


1.7
log
@Include macinfo.h.
@
text
@d1 2
a2 2
/*	$OpenBSD: mac68k5380.c,v 1.6 1996/06/08 16:21:11 briggs Exp $	*/
/*	$NetBSD: mac68k5380.c,v 1.25 1996/06/07 01:45:43 briggs Exp $	*/
d138 3
a140 2
static		  int	machine_match __P((struct device *pdp, void *match,
					   void *auxp, struct cfdriver *cd));
d183 5
a187 4
machine_match(pdp, match, auxp, cd)
	struct device	*pdp;
	void		*match, *auxp;
	struct cfdriver	*cd;
@


1.6
log
@Sync up with latest NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mac68k5380.c,v 1.5 1996/05/26 18:35:28 briggs Exp $	*/
d54 1
@


1.5
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mac68k5380.c,v 1.24 1996/05/25 16:42:24 briggs Exp $	*/
@


1.4
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.3
log
@Bring some fixes over from NetBSD.
@
text
@d1 1
a1 1
/*	$NetBSD: mac68k5380.c,v 1.15 1995/11/01 04:59:03 briggs Exp $	*/
d50 1
a50 1
#include <mac68k/dev/ncr5380reg.h>
d53 1
d55 1
a55 1
#include "../mac68k/via.h"
d70 31
a100 1
#define	DBG_PID		15	/* Keep track of driver			*/
d102 1
a125 2
static volatile u_char	*scsi_enable		= NULL;

d130 11
a140 2
void	ncr5380_irq_intr(void *);
void	ncr5380_drq_intr(void *);
d148 1
a148 20
}

extern __inline__ void
scsi_ienable()
{
	int	s;

	s = splhigh();
	*scsi_enable = 0x80 | (V2IF_SCSIIRQ | V2IF_SCSIDRQ);
	splx(s);
}

extern __inline__ void
scsi_idisable()
{
	int	s;

	s = splhigh();
	*scsi_enable = V2IF_SCSIIRQ | V2IF_SCSIDRQ;
	splx(s);
d167 1
a167 1
	if (VIA2 == VIA2OFF)
d169 2
a170 1
	else
d172 2
d180 1
a180 1
machine_match(pdp, cdp, auxp, cd)
d182 1
a182 2
	struct cfdata	*cdp;
	void		*auxp;
a184 2
	if (matchbyname(pdp, cdp, auxp) == 0)
		return 0;
a186 2
	if (cdp->cf_unit != 0)
		return 0;
a201 3
char	*pdma_5380_state="", *pdma_5380_prev_state="";
#define DBG_SET(x) {pdma_5380_prev_state=pdma_5380_state; pdma_5380_state=(x);}

d209 1
a209 1
	printf("datap = 0x%x, remainder = %d.\n",
a210 2
	printf("state: %s\t", pdma_5380_state);
	printf("last state: %s\n", pdma_5380_prev_state);
d219 1
a219 1
	int	bytes, s;
d222 1
a226 1
	DBG_SET("in pdma_cleanup().")
d260 1
a260 3
#if NCR5380_PDMA_DEBUG
	pdma_5380_state = "pdma_cleanup() -- going back to run_main().";
#endif
d262 1
a262 3
#if NCR5380_PDMA_DEBUG
	pdma_5380_state = "pdma_cleanup() -- back from run_main().";
#endif
d274 1
d276 1
a276 14
#if NCR5380_PDMA_DEBUG
		DBG_SET("got irq interrupt in xfer.")
#endif
		/*
		 * If Mr. IRQ isn't set one might wonder how we got
		 * here.  It does happen, though.
		 */
		dmstat = GET_5380_REG(NCR5380_DMSTAT);
		if (!(dmstat & SC_IRQ_SET)) {
#if NCR5380_PDMA_DEBUG
		DBG_SET("irq not set.")
#endif
			return 0;
		}
d284 1
d289 1
a289 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("BSY|REQ.")
#endif
d296 1
a296 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("PARITY.")
#endif
d314 2
a315 1
	}
d320 1
a320 1
void
d324 1
a324 1
	struct ncr_softc	*sc = p;
d331 2
a332 4
	if (GET_5380_REG(NCR5380_DMSTAT) & SC_IRQ_SET) {
		scsi_idisable();
		ncr_ctrl_intr(cur_softc);
	}
d350 2
a351 2
void
ncr5380_drq_intr(p)
a355 1
	struct ncr_softc	*sc = p;
d360 1
a360 1
	volatile u_int8_t	*drq;
d363 5
a367 6
	/*
	 * If we're not ready to xfer data, just return.
	 */
	if (   !(GET_5380_REG(NCR5380_DMSTAT) & SC_DMA_REQ)
	    || !pdma_5380_dir) {
		return;
a368 16

	/*
	 * I don't think this should be necessary, but it is
	 * for writes--at least to some devices.  They don't
	 * let go of PH_DATAOUT until we do pdma_cleanup().
	 */
	if (pending_5380_count == 0) {
#if NCR5380_PDMA_DEBUG
		DBG_SET("forcing pdma_cleanup().")
#endif
		pdma_cleanup();
		return;
	}

#if NCR5380_PDMA_DEBUG
	DBG_SET("got drq interrupt.")
d379 1
a380 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("buserr in xfer.")
#endif
d384 1
a384 2
			printf("pdma %s: count = %d (0x%x) (pending "
				"count %d)\n",
a392 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("handled bus error in xfer.")
#endif
d394 3
a402 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("Data in.")
#endif
a408 3
#if NCR5380_PDMA_DEBUG
			DBG_SET("Data in (aligning dest).")
#endif
a425 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("Data in (starting read).")
#endif
d431 1
a431 11
		while ( count >= 512 ) {
			if (!(GET_5380_REG(NCR5380_DMSTAT) & SC_DMA_REQ)) {
				nofault = (int *) 0;

				pending_5380_data += (dcount - count);
				pending_5380_count -= (dcount - count);
#if NCR5380_PDMA_DEBUG
				DBG_SET("drq low")
#endif
				return;
			}
d434 1
a434 15
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;	/* 128 */
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;	/* 256 */
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;
			R4; R4; R4; R4; R4; R4; R4; R4;	/* 512 */
			count -= 512;
a439 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("Data in (finishing up).")
#endif
a452 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("Data out.")
#endif
a458 3
#if NCR5380_PDMA_DEBUG
			DBG_SET("Data out (aligning dest).")
#endif
a475 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("Data out (starting write).")
#endif
a489 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("Data out (cleaning up).")
#endif
d500 8
d516 6
a521 3
#if NCR5380_PDMA_DEBUG
	DBG_SET("done in xfer.")
#endif
d523 8
a530 1
#endif	/* if USE_PDMA */
d544 1
a544 2
	int	len = *count, i, scsi_timeout = SCSI_TIMEOUT_VAL;
	int	s, err;
d550 1
a550 3
#if NCR5380_PDMA_DEBUG
	DBG_SET("in transfer_pdma.")
#endif
d556 1
a556 3
#if NCR5380_PDMA_DEBUG
		DBG_SET("pdma, actually using transfer_pio.")
#endif
a602 4
#if NCR5380_PDMA_DEBUG
	DBG_SET("setting up for interrupt.")
#endif

d624 1
a624 3
#if NCR5380_PDMA_DEBUG
	DBG_SET("wait for interrupt.")
#endif
@


1.2
log
@update from netbsd (without losing local changes)
@
text
@d69 1
a69 1
#undef	DBG_PID			/* Keep track of driver			*/
d178 1
a178 1
/* #define DEBUG 1 	Maybe we try with this off eventually. */
d180 1
a180 1
#if DEBUG
d184 2
a185 1
char	*pdma_5380_state="";
d192 1
a192 1
	printf("pdma_5380_dir = %d.\n",
d196 3
a198 1
	printf("pdma_5380_state = %s.\n", pdma_5380_state);
d212 2
a213 2
#if DEBUG
	pdma_5380_state = "in pdma_cleanup().";
d247 3
d251 3
d266 2
a267 2
#if DEBUG
		pdma_5380_state = "got irq interrupt in xfer.";
d275 3
d291 3
d300 3
d375 14
a388 1
	    || !pdma_5380_dir)
d390 1
d392 2
a393 2
#if DEBUG
	pdma_5380_state = "got drq interrupt.";
d405 2
a406 2
#if DEBUG
		pdma_5380_state = "buserr in xfer.";
d421 2
a422 2
#if DEBUG
		pdma_5380_state = "handled bus error in xfer.";
d431 3
d437 6
a442 2
		resid = count = 4 - (((int) pending_5380_data) & 0x3);
		if (count < 4) {
d460 3
d474 2
a475 2
#if DEBUG
				pdma_5380_state = "drq low";
d501 3
d517 3
d523 6
a528 2
		resid = count = 4 - (((int) pending_5380_data) & 0x3);
		if (count < 4) {
d546 3
d563 3
d584 2
a585 18
#if DEBUG
	pdma_5380_state = "done in xfer--waiting.";
#endif

	/*
	 * Is this necessary?
	 */
	while (!(   (GET_5380_REG(NCR5380_DMSTAT) & SC_ACK_STAT)
		 || (GET_5380_REG(NCR5380_IDSTAT) &    SC_S_REQ) ));

	/*
	 * Update pointers for pdma_cleanup().
	 */
	pending_5380_data += pending_5380_count;
	pending_5380_count = 0;

#if DEBUG
	pdma_5380_state = "done in xfer.";
a587 2
	pdma_cleanup();
	return;
d609 2
a610 2
#if DEBUG
	pdma_5380_state = "in transfer_pdma.";
d617 2
a618 2
#if DEBUG
		pdma_5380_state = "pdma, actually using transfer_pio.";
a660 6
	 * Set DMA mode and assert data bus.
	 */
	SET_5380_REG(NCR5380_MODE, GET_5380_REG(NCR5380_MODE) | SC_M_DMA);
	SET_5380_REG(NCR5380_ICOM, GET_5380_REG(NCR5380_ICOM) | SC_ADTB);

	/*
d666 2
a667 2
#if DEBUG
	pdma_5380_state = "wait for interrupt.";
d679 2
d685 2
d690 4
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mac68k5380.c,v 1.14 1995/10/01 05:10:20 briggs Exp $	*/
d379 4
a382 3
			printf("pdma in: count = %d (0x%x) (pending "
				"count %d)\n", count, count,
				pending_5380_count);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
