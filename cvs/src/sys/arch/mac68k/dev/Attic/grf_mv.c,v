head	1.36;
access;
symbols
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.18
	OPENBSD_5_0:1.35.0.16
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.14
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.12
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.8
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.10
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.6
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.4
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.33.0.4
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.4
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.8
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.17.0.16
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.14
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.17.0.12
	OPENBSD_2_9_BASE:1.17
	NIKLAS_UNDEAD:1.17.0.10
	OPENBSD_2_8:1.17.0.8
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.6
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.4
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.10
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.8
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.16.0.6
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.16.0.4
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.35;

1.35
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.10.20.29.46;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.12.13.52.07;	author martin;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.26.22.23.15;	author martin;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.22.18.37.56;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.10.21.19.14;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.09.20.51.48;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.08.20.35.21;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.06.19.51.43;	author martin;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.23.23.28.58;	author martin;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.12.20.51.29;	author martin;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.01.17.04.52;	author martin;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.26.21.09.35;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.09.22.55.19;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.04.24.06.39.40;	author downsj;	state Exp;
branches
	1.17.4.1
	1.17.16.1;
next	1.16;

1.16
date	97.05.03.02.30.29;	author briggs;	state Exp;
branches;
next	1.15;

1.15
date	97.05.02.00.59.52;	author briggs;	state Exp;
branches;
next	1.14;

1.14
date	97.05.01.03.36.51;	author briggs;	state Exp;
branches;
next	1.13;

1.13
date	97.04.17.17.46.39;	author gene;	state Exp;
branches;
next	1.12;

1.12
date	97.04.10.20.34.33;	author briggs;	state Exp;
branches;
next	1.11;

1.11
date	97.04.01.13.52.34;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.03.29.23.47.13;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.03.14.14.16.52;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.03.12.13.36.57;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.03.08.16.16.51;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.01.35.31;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.09.21.03.55.47;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.08.10.21.37.44;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.35.21;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.18.13.38;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches;
next	;

1.17.4.1
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	;

1.17.16.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: grf_mv.c,v 1.35 2007/09/17 01:33:33 krw Exp $	*/
/*	$NetBSD: grf_nubus.c,v 1.62 2001/01/22 20:27:02 briggs Exp $	*/

/*
 * Copyright (c) 1995 Allen Briggs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Device-specific routines for handling Nubus-based video cards.
 */

#include <sys/param.h>

#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/viareg.h>

#include <mac68k/dev/nubus.h>

#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <mac68k/dev/macfbvar.h>

int	macfb_nubus_match(struct device *, void *, void *);
void	macfb_nubus_attach(struct device *, struct device *, void *);

struct cfattach macfb_nubus_ca = {
	sizeof(struct macfb_softc), macfb_nubus_match, macfb_nubus_attach
};

void	load_image_data(caddr_t data, struct image_data *image);

int	grfmv_intr_generic_write1(void *vsc);
int	grfmv_intr_generic_write4(void *vsc);
int	grfmv_intr_generic_or4(void *vsc);

int	grfmv_intr_cb264(void *vsc);
int	grfmv_intr_cb364(void *vsc);
int	grfmv_intr_cmax(void *vsc);
int	grfmv_intr_cti(void *vsc);
int	grfmv_intr_radius(void *vsc);
int	grfmv_intr_radius24(void *vsc);
int	grfmv_intr_supermacgfx(void *vsc);
int	grfmv_intr_lapis(void *vsc);
int	grfmv_intr_formac(void *vsc);
int	grfmv_intr_vimage(void *vsc);
int	grfmv_intr_gvimage(void *vsc);
int	grfmv_intr_radius_gsc(void *vsc);
int	grfmv_intr_radius_gx(void *vsc);
int	grfmv_intr_relax_200(void *);
int	grfmv_intr_mvc(void *);
int	grfmv_intr_viltro_340(void *);

#define CARD_NAME_LEN	64

void
load_image_data(caddr_t data, struct image_data *image)
{
	bcopy(data     , &image->size,       4);
	bcopy(data +  4, &image->offset,     4);
	bcopy(data +  8, &image->rowbytes,   2);
	bcopy(data + 10, &image->top,        2);
	bcopy(data + 12, &image->left,       2);
	bcopy(data + 14, &image->bottom,     2);
	bcopy(data + 16, &image->right,      2);
	bcopy(data + 18, &image->version,    2);
	bcopy(data + 20, &image->packType,   2);
	bcopy(data + 22, &image->packSize,   4);
	bcopy(data + 26, &image->hRes,       4);
	bcopy(data + 30, &image->vRes,       4);
	bcopy(data + 34, &image->pixelType,  2);
	bcopy(data + 36, &image->pixelSize,  2);
	bcopy(data + 38, &image->cmpCount,   2);
	bcopy(data + 40, &image->cmpSize,    2);
	bcopy(data + 42, &image->planeBytes, 4);
}

int
macfb_nubus_match(struct device *parent, void *vcf, void *aux)
{
	struct nubus_attach_args *na = (struct nubus_attach_args *)aux;

	if (na->category != NUBUS_CATEGORY_DISPLAY)
		return (0);

	if (na->type != NUBUS_TYPE_VIDEO)
		return (0);

	if (na->drsw != NUBUS_DRSW_APPLE)
		return (0);

	/*
	 * If we've gotten this far, then we're dealing with a real-live
	 * Apple QuickDraw-compatible display card resource.  Now, how to
	 * determine that this is an active resource???  Dunno.  But we'll
	 * proceed like it is.
	 */
	return (1);
}

void
macfb_nubus_attach(struct device *parent, struct device *self, void *aux)
{
	struct nubus_attach_args *na = (struct nubus_attach_args *)aux;
	struct macfb_softc *sc = (struct macfb_softc *)self;
	struct image_data image_store, image;
	char cardname[CARD_NAME_LEN];
	nubus_dirent dirent;
	nubus_dir dir, mode_dir, board_dir;
	int mode;
	struct macfb_devconfig *dc;

	bcopy(na->fmt, &sc->sc_slot, sizeof(nubus_slot));

	sc->sc_tag = na->na_tag;
	sc->card_id = na->drhw;
	sc->sc_basepa = (bus_addr_t)NUBUS_SLOT2PA(na->slot);
	sc->sc_fbofs = 0;

	if (bus_space_map(sc->sc_tag, sc->sc_basepa, NBMEMSIZE,
	    0, &sc->sc_regh)) {
		printf(": failed to map slot %d\n", na->slot);
		return;
	}

	nubus_get_main_dir(&sc->sc_slot, &dir);

	if (nubus_find_rsrc(sc->sc_tag, sc->sc_regh,
	    &sc->sc_slot, &dir, na->rsrcid, &dirent) <= 0) {
		printf(": failed to get board rsrc.\n");
		goto bad;
	}

	nubus_get_dir_from_rsrc(&sc->sc_slot, &dirent, &board_dir);

	if (nubus_find_rsrc(sc->sc_tag, sc->sc_regh,
	    &sc->sc_slot, &board_dir, NUBUS_RSRC_TYPE, &dirent) <= 0)
		if ((na->rsrcid != 128) ||
		    (nubus_find_rsrc(sc->sc_tag, sc->sc_regh,
		    &sc->sc_slot, &dir, 129, &dirent) <= 0)) {
			printf(": failed to get board rsrc.\n");
			goto bad;
		}

	mode = NUBUS_RSRC_FIRSTMODE;
	if (nubus_find_rsrc(sc->sc_tag, sc->sc_regh,
	    &sc->sc_slot, &board_dir, mode, &dirent) <= 0) {
		printf(": probe failed to get board rsrc.\n");
		goto bad;
	}

	nubus_get_dir_from_rsrc(&sc->sc_slot, &dirent, &mode_dir);

	if (nubus_find_rsrc(sc->sc_tag, sc->sc_regh,
	    &sc->sc_slot, &mode_dir, VID_PARAMS, &dirent) <= 0) {
		printf(": probe failed to get mode dir.\n");
		goto bad;
	}

	if (nubus_get_ind_data(sc->sc_tag, sc->sc_regh, &sc->sc_slot,
	    &dirent, (caddr_t)&image_store, sizeof(struct image_data)) <= 0) {
		printf(": probe failed to get indirect mode data.\n");
		goto bad;
	}

	/* Need to load display info (and driver?), etc... (?) */

	load_image_data((caddr_t)&image_store, &image);

	dc = malloc(sizeof(*dc), M_DEVBUF, M_WAITOK | M_ZERO);
	
	dc->dc_vaddr = (vaddr_t)bus_space_vaddr(sc->sc_tag, sc->sc_handle);
	dc->dc_paddr = sc->sc_basepa;
	dc->dc_offset = image.offset;
	dc->dc_wid = image.right - image.left;
	dc->dc_ht = image.bottom - image.top;
	dc->dc_depth = image.pixelSize;
	dc->dc_rowbytes = image.rowbytes;
	dc->dc_size = dc->dc_ht * dc->dc_rowbytes;

	/* Perform common video attachment. */

	strlcpy(cardname, nubus_get_card_name(sc->sc_tag, sc->sc_regh,
	    &sc->sc_slot), sizeof cardname);
	printf(": %s\n", cardname);

	if (sc->card_id == NUBUS_DRHW_TFB) {
		/*
		 * This is the Toby card, but apparently some manufacturers
		 * (like Cornerstone) didn't bother to get/use their own
		 * value here, even though the cards are different, so we
		 * so we try to differentiate here.
		 */
		if (strncmp(cardname, "Samsung 768", 11) == 0)
			sc->card_id = NUBUS_DRHW_SAM768;
#ifdef DEBUG
		else if (strncmp(cardname, "Toby frame", 10) != 0)
			printf("%s: This display card pretends to be a TFB!\n",
			    sc->sc_dev.dv_xname);
#endif
	}

	switch (sc->card_id) {
	case NUBUS_DRHW_TFB:
	case NUBUS_DRHW_M2HRVC:
	case NUBUS_DRHW_PVC:
		sc->cli_offset = 0xa0000;
		sc->cli_value = 0;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write1, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_WVC:
		sc->cli_offset = 0xa00000;
		sc->cli_value = 0;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write1, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_COLORMAX:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_cmax, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_SE30:
		/* Do nothing--SE/30 interrupts are disabled */
		break;
	case NUBUS_DRHW_MDC:
		sc->cli_offset = 0x200148;
		sc->cli_value = 1;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write4, sc,
		    sc->sc_dev.dv_xname);

		/* Enable interrupts; to disable, write 0x7 to this location */
		bus_space_write_4(sc->sc_tag, sc->sc_regh, 0x20013C, 5);
		break;
	case NUBUS_DRHW_CB264:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_cb264, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_CB364:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_cb364, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_RPC8:
		sc->cli_offset = 0xfdff8f;
		sc->cli_value = 0xff;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write1, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_RPC8XJ:
		sc->cli_value = 0x66;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_radius, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_RPC24X:
	case NUBUS_DRHW_BOOGIE:
		sc->cli_value = 0x64;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_radius, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_RPC24XP:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_radius24, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_RADGSC:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_radius_gsc, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_RDCGX:
	case NUBUS_DRHW_MPGX:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_radius_gx, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_FIILX:
	case NUBUS_DRHW_FIISXDSP:
	case NUBUS_DRHW_FUTURASX:
		sc->cli_offset = 0xf05000;
		sc->cli_value = 0x80;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write1, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_SAM768:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_cti, sc,
		sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_SUPRGFX:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_supermacgfx, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_SPECTRM8:
		sc->cli_offset = 0x0de178;
		sc->cli_value = 0x80;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_or4, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_LAPIS:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_lapis, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_RELAX200:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_relax_200, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_BAER:
	case NUBUS_DRHW_FORMAC:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_formac, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_ROPS24LXI:
	case NUBUS_DRHW_ROPS24XLTV:
	case NUBUS_DRHW_ROPS24MXTV:
	case NUBUS_DRHW_THUNDER24:
		sc->cli_offset = 0xfb0010;
		sc->cli_value = 0x00;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write4, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_ROPSPPGT:
		sc->cli_offset = 0xf50010;
		sc->cli_value = 0x02;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write4, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_VIMAGE:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_vimage, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_GVIMAGE:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_gvimage, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_MC2124NB:
		sc->cli_offset = 0xfd1000;
		sc->cli_value = 0x00;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write4, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_MICRON:
		sc->cli_offset = 0xa00014;
		sc->cli_value = 0;
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_generic_write4, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_MVC:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_mvc, sc,
		    sc->sc_dev.dv_xname);
		break;
	case NUBUS_DRHW_VILTRO340:
		add_nubus_intr(na->slot, IPL_TTY, grfmv_intr_viltro_340, sc,
		    sc->sc_dev.dv_xname);
		break;
	default:
		printf("%s: Unknown video card ID 0x%x\n",
		    sc->sc_dev.dv_xname, sc->card_id);
		goto bad;
	}

	/* Perform common video attachment. */
	macfb_attach_common(sc, dc);
	return;

bad:
	bus_space_unmap(sc->sc_tag, sc->sc_regh, NBMEMSIZE);
}

/* Interrupt handlers... */
/*
 * Generic routine to clear interrupts for cards where it simply takes
 * a MOV.B to clear the interrupt.  The offset and value of this byte
 * varies between cards.
 */
/*ARGSUSED*/
int
grfmv_intr_generic_write1(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;

	bus_space_write_1(sc->sc_tag, sc->sc_regh,
	    sc->cli_offset, (u_int8_t)sc->cli_value);
	return (1);
}

/*
 * Generic routine to clear interrupts for cards where it simply takes
 * a MOV.L to clear the interrupt.  The offset and value of this byte
 * varies between cards.
 */
/*ARGSUSED*/
int
grfmv_intr_generic_write4(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;

	bus_space_write_4(sc->sc_tag, sc->sc_regh,
	    sc->cli_offset, sc->cli_value);
	return (1);
}

/*
 * Generic routine to clear interrupts for cards where it simply takes
 * an OR.L to clear the interrupt.  The offset and value of this byte
 * varies between cards.
 */
/*ARGSUSED*/
int
grfmv_intr_generic_or4(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	unsigned long	scratch;

	scratch = bus_space_read_4(sc->sc_tag, sc->sc_regh, sc->cli_offset);
	scratch |= 0x80;
	bus_space_write_4(sc->sc_tag, sc->sc_regh, sc->cli_offset, scratch);
	return (1);
}

/*
 * Routine to clear interrupts for the Radius PrecisionColor 8xj card.
 */
/*ARGSUSED*/
int
grfmv_intr_radius(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	u_int8_t c;

	c = sc->cli_value;

	c |= 0x80;
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0xd00403, c);
	c &= 0x7f;
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0xd00403, c);
	return (1);
}

/*
 * Routine to clear interrupts for the Radius PrecisionColor 24Xp card.
 * Is this what the 8xj routine is doing, too?
 */
/*ARGSUSED*/
int
grfmv_intr_radius24(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	u_int8_t c;

	c = 0x80 | bus_space_read_1(sc->sc_tag, sc->sc_regh, 0xfffd8);
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0xd00403, c);
	c &= 0x7f;
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0xd00403, c);
	return (1);
}

/*
 * Routine to clear interrupts on Samsung 768x1006 video controller.
 * This controller was manufactured by Cornerstone Technology, Inc.,
 * now known as Cornerstone Imaging.
 *
 * To clear this interrupt, we apparently have to set, then clear,
 * bit 2 at byte offset 0x80000 from the card's base.
 *	Information for this provided by Brad Salai <bsalai@@servtech.com>
 */
/*ARGSUSED*/
int
grfmv_intr_cti(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	u_int8_t c;

	c = bus_space_read_1(sc->sc_tag, sc->sc_regh, 0x80000);
	c |= 0x02;
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0x80000, c);
	c &= 0xfd;
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0x80000, c);
	return (1);
}

/*ARGSUSED*/
int
grfmv_intr_cb264(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	volatile char *slotbase;

	slotbase = (volatile char *)bus_space_vaddr(sc->sc_tag, sc->sc_handle);
	asm volatile("	movl	%0,a0
			movl	a0@@(0xff6028),d0
			andl	#0x2,d0
			beq	_mv_intr0
			movql	#0x3,d0
		_mv_intr0:
			movl	a0@@(0xff600c),d1
			andl	#0x3,d1
			cmpl	d1,d0
			beq	_mv_intr_fin
			movl	d0,a0@@(0xff600c)
			nop
			tstb	d0
			beq	_mv_intr1
			movl	#0x0002,a0@@(0xff6040)
			movl	#0x0102,a0@@(0xff6044)
			movl	#0x0105,a0@@(0xff6048)
			movl	#0x000e,a0@@(0xff604c)
			movl	#0x001c,a0@@(0xff6050)
			movl	#0x00bc,a0@@(0xff6054)
			movl	#0x00c3,a0@@(0xff6058)
			movl	#0x0061,a0@@(0xff605c)
			movl	#0x0012,a0@@(0xff6060)
			bra	_mv_intr_fin
		_mv_intr1:
			movl	#0x0002,a0@@(0xff6040)
			movl	#0x0209,a0@@(0xff6044)
			movl	#0x020c,a0@@(0xff6048)
			movl	#0x000f,a0@@(0xff604c)
			movl	#0x0027,a0@@(0xff6050)
			movl	#0x00c7,a0@@(0xff6054)
			movl	#0x00d7,a0@@(0xff6058)
			movl	#0x006b,a0@@(0xff605c)
			movl	#0x0029,a0@@(0xff6060)
		_mv_intr_fin:
			movl	#0x1,a0@@(0xff6014)"
		: : "g" (slotbase) : "a0","d0","d1");
	return (1);
}

/*
 * Support for the Colorboard 364 might be more complex than it needs to
 * be.  If we can find more information about this card, this might be
 * significantly simplified.  Contributions welcome...  :-)
 */
/*ARGSUSED*/
int
grfmv_intr_cb364(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	volatile char *slotbase;

	slotbase = (volatile char *)bus_space_vaddr(sc->sc_tag, sc->sc_handle);
	asm volatile("	movl	%0,a0
			movl	a0@@(0xfe6028),d0
			andl	#0x2,d0
			beq	_cb364_intr4
			movql	#0x3,d0
			movl	a0@@(0xfe6018),d1
			movl	#0x3,a0@@(0xfe6018)
			movw	a0@@(0xfe7010),d2
			movl	d1,a0@@(0xfe6018)
			movl	a0@@(0xfe6020),d1
			btst	#0x06,d2
			beq	_cb364_intr0
			btst	#0x00,d1
			beq	_cb364_intr5
			bsr	_cb364_intr1
			bra	_cb364_intr_out
		_cb364_intr0:
			btst	#0x00,d1
			bne	_cb364_intr5
			bsr	_cb364_intr1
			bra	_cb364_intr_out
		_cb364_intr1:
			movl	d0,a0@@(0xfe600c)
			nop
			tstb	d0
			beq	_cb364_intr3
			movl	#0x0002,a0@@(0xfe6040)
			movl	#0x0105,a0@@(0xfe6048)
			movl	#0x000e,a0@@(0xfe604c)
			movl	#0x00c3,a0@@(0xfe6058)
			movl	#0x0061,a0@@(0xfe605c)
			btst	#0x06,d2
			beq	_cb364_intr2
			movl	#0x001c,a0@@(0xfe6050)
			movl	#0x00bc,a0@@(0xfe6054)
			movl	#0x0012,a0@@(0xfe6060)
			movl	#0x000e,a0@@(0xfe6044)
			movl	#0x00c3,a0@@(0xfe6064)
			movl	#0x0061,a0@@(0xfe6020)
			rts
		_cb364_intr2:
			movl	#0x0016,a0@@(0xfe6050)
			movl	#0x00b6,a0@@(0xfe6054)
			movl	#0x0011,a0@@(0xfe6060)
			movl	#0x0101,a0@@(0xfe6044)
			movl	#0x00bf,a0@@(0xfe6064)
			movl	#0x0001,a0@@(0xfe6020)
			rts
		_cb364_intr3:
			movl	#0x0002,a0@@(0xfe6040)
			movl	#0x0209,a0@@(0xfe6044)
			movl	#0x020c,a0@@(0xfe6048)
			movl	#0x000f,a0@@(0xfe604c)
			movl	#0x0027,a0@@(0xfe6050)
			movl	#0x00c7,a0@@(0xfe6054)
			movl	#0x00d7,a0@@(0xfe6058)
			movl	#0x006b,a0@@(0xfe605c)
			movl	#0x0029,a0@@(0xfe6060)
			oril	#0x0040,a0@@(0xfe6064)
			movl	#0x0000,a0@@(0xfe6020)
			rts
		_cb364_intr4:
			movq	#0x00,d0
		_cb364_intr5:
			movl	a0@@(0xfe600c),d1
			andl	#0x3,d1
			cmpl	d1,d0
			beq	_cb364_intr_out
			bsr	_cb364_intr1
		_cb364_intr_out:
			movl	#0x1,a0@@(0xfe6014)
		_cb364_intr_quit:
		" : : "g" (slotbase) : "a0","d0","d1","d2");
	return (1);
}

/*
 * Interrupt clearing routine for SuperMac GFX card.
 */
/*ARGSUSED*/
int
grfmv_intr_supermacgfx(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	u_int8_t dummy;

	dummy = bus_space_read_1(sc->sc_tag, sc->sc_regh, 0xE70D3);
	return (1);
}

/*
 * Routine to clear interrupts for the Sigma Designs ColorMax card.
 */
/*ARGSUSED*/
int
grfmv_intr_cmax(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	u_int32_t dummy;

	dummy = bus_space_read_4(sc->sc_tag, sc->sc_regh, 0xf501c);
	dummy = bus_space_read_4(sc->sc_tag, sc->sc_regh, 0xf5018);
	return (1);
}

/*
 * Routine to clear interrupts for the Lapis ProColorServer 8 PDS card
 * (for the SE/30).
 */
/*ARGSUSED*/
int
grfmv_intr_lapis(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;

	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0xff7000, 0x08);
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0xff7000, 0x0C);
	return (1);
}

/*
 * Routine to clear interrupts for the Formac ProNitron 80.IVb
 * and Color Card II
 */
/*ARGSUSED*/
int
grfmv_intr_formac(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	u_int8_t dummy;

	dummy = bus_space_read_1(sc->sc_tag, sc->sc_regh, 0xde80db);
	dummy = bus_space_read_1(sc->sc_tag, sc->sc_regh, 0xde80d3);
	return (1);
}

/*
 * Routine to clear interrupts for the Vimage by Interware Co., Ltd.
 */
/*ARGSUSED*/
int
grfmv_intr_vimage(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;

	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0x800000, 0x67);
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0x800000, 0xE7);
	return (1);
}

/*
 * Routine to clear interrupts for the Grand Vimage by Interware Co., Ltd.
 */
/*ARGSUSED*/
int
grfmv_intr_gvimage(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	u_int8_t dummy;

	dummy = bus_space_read_1(sc->sc_tag, sc->sc_regh, 0xf00000);
	return (1);
}

/*
 * Routine to clear interrupts for the Radius GS/C
 */
/*ARGSUSED*/
int
grfmv_intr_radius_gsc(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;
	u_int8_t dummy;

	dummy = bus_space_read_1(sc->sc_tag, sc->sc_regh, 0xfb802);
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0xfb802, 0xff);
	return (1);
}

/*
 * Routine to clear interrupts for the Radius GS/C
 */
/*ARGSUSED*/
int
grfmv_intr_radius_gx(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;

	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0x600000, 0x00);
	bus_space_write_1(sc->sc_tag, sc->sc_regh, 0x600000, 0x20);
	return (1);
}

/*
 * Routine to clear interrupts for the Relax 19" model 200.
 */
/*ARGSUSED*/
int
grfmv_intr_relax_200(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;

	/* The board ROM driver code has a tst.l here. */
	bus_space_read_4(sc->sc_tag, sc->sc_handle, 0x000D0040);
	return (1);
}

/*
 * Routine to clear interrupts for the Apple Mac II Monochrome Video Card.
 */
/*ARGSUSED*/
int
grfmv_intr_mvc(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;

	bus_space_write_4(sc->sc_tag, sc->sc_handle, 0x00040000, 0);
	bus_space_write_4(sc->sc_tag, sc->sc_handle, 0x00020000, 0);    
	return (1);
}

/*
 * Routine to clear interrupts for the VillageTronic Mac Picasso 340.
 */
/*ARGSUSED*/
int
grfmv_intr_viltro_340(void *vsc)
{
	struct macfb_softc *sc = (struct macfb_softc *)vsc;

	/* Yes, two read accesses to the same spot. */
	bus_space_read_1(sc->sc_tag, sc->sc_handle, 0x0500);
	bus_space_read_1(sc->sc_tag, sc->sc_handle, 0x0500);
	return (1);
}
@


1.35
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.34 2007/09/10 20:29:46 miod Exp $	*/
@


1.34
log
@Pass a real ipl level to add_nubus_intr(), and make sure the interrupt
handler is invoked with spl raised to the given level, otherwise all nubus
interrupts are processed at level 2.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.33 2007/01/12 13:52:07 martin Exp $	*/
d198 1
a198 2
	dc = malloc(sizeof(*dc), M_DEVBUF, M_WAITOK);
	bzero(dc, sizeof(*dc));
@


1.33
log
@support a few more video cards, untested:

Formac Baers/ProNitron 80.IVb
Apple Mac II Monochrome Video Card
VillageTronic Mac Picasso 340
Relax 19" Model 200

prodded by miod@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.32 2006/02/26 22:23:15 martin Exp $	*/
d238 1
a238 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write1, sc,
d244 1
a244 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write1, sc,
d248 1
a248 1
		add_nubus_intr(na->slot, grfmv_intr_cmax, sc,
d257 1
a257 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write4, sc,
d264 1
a264 1
		add_nubus_intr(na->slot, grfmv_intr_cb264, sc,
d268 1
a268 1
		add_nubus_intr(na->slot, grfmv_intr_cb364, sc,
d274 1
a274 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write1, sc,
d279 1
a279 1
		add_nubus_intr(na->slot, grfmv_intr_radius, sc,
d285 1
a285 1
		add_nubus_intr(na->slot, grfmv_intr_radius, sc,
d289 1
a289 1
		add_nubus_intr(na->slot, grfmv_intr_radius24, sc,
d293 1
a293 1
		add_nubus_intr(na->slot, grfmv_intr_radius_gsc, sc,
d298 1
a298 1
		add_nubus_intr(na->slot, grfmv_intr_radius_gx, sc,
d306 1
a306 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write1, sc,
d310 1
a310 1
		add_nubus_intr(na->slot, grfmv_intr_cti, sc,
d314 1
a314 1
		add_nubus_intr(na->slot, grfmv_intr_supermacgfx, sc,
d320 1
a320 1
		add_nubus_intr(na->slot, grfmv_intr_generic_or4, sc,
d324 1
a324 1
		add_nubus_intr(na->slot, grfmv_intr_lapis, sc,
d328 1
a328 1
		add_nubus_intr(na->slot, grfmv_intr_relax_200, sc,
d333 1
a333 1
		add_nubus_intr(na->slot, grfmv_intr_formac, sc,
d342 1
a342 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write4, sc,
d348 1
a348 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write4, sc,
d352 1
a352 1
		add_nubus_intr(na->slot, grfmv_intr_vimage, sc,
d356 1
a356 1
		add_nubus_intr(na->slot, grfmv_intr_gvimage, sc,
d362 1
a362 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write4, sc,
d368 1
a368 1
		add_nubus_intr(na->slot, grfmv_intr_generic_write4, sc,
d372 1
a372 1
		add_nubus_intr(na->slot, grfmv_intr_mvc, sc,
d376 1
a376 1
		add_nubus_intr(na->slot, grfmv_intr_viltro_340, sc,
@


1.32
log
@skip common macfb attachment on unknown cards

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.31 2006/01/22 18:37:56 miod Exp $	*/
d78 3
d327 5
d371 8
d687 2
a688 1
 * Routine to clear interrupts for the Formac Color Card II
d756 43
@


1.31
log
@Add bus_space_vaddr() and use it instead of accessing private bus_space
fields. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.30 2006/01/10 21:19:14 miod Exp $	*/
d364 1
a364 1
		printf("%s: Unknown video card ID 0x%x --",
d366 1
a366 2
		printf(" Not installing interrupt routine.\n");
		break;
@


1.30
log
@Simplify external macfb interfaces, kill an intermediate attachment structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.29 2006/01/09 20:51:48 miod Exp $	*/
d198 1
a198 1
	dc->dc_vaddr = (vaddr_t)sc->sc_handle.base; /* XXX evil hack */
d497 1
a497 1
	slotbase = (volatile char *)(sc->sc_handle.base); /* XXX evil hack */
d550 1
a550 1
	slotbase = (volatile char *)(sc->sc_handle.base); /* XXX evil hack */
@


1.29
log
@Ditch the grf frame buffer abstraction, and directly attach macfb to
either obio or nubus. No functional change, shaves a few more KB...
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.28 2006/01/08 20:35:21 miod Exp $	*/
a47 3
/*
#include <dev/wscons/wsconsio.h>
*/
d136 1
a136 1
	struct grfmode gm;
d195 13
a207 7
	gm.psize = image.pixelSize;
	gm.width = image.right - image.left;
	gm.height = image.bottom - image.top;
	gm.rowbytes = image.rowbytes;
	gm.fbsize = gm.height * gm.rowbytes;
	gm.fbbase = (caddr_t)(sc->sc_handle.base);	/* XXX evil hack */
	gm.fboff = image.offset;
d371 1
a371 1
	macfb_attach_common(sc, &gm);
@


1.28
log
@Remove unused grf_softc members; do not keep temporary data in grf_softc
either, instead keep it on the stack or directly in attachment structures.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.27 2006/01/04 20:39:05 miod Exp $	*/
a38 1
#include <sys/mman.h>
a46 1
#include <mac68k/dev/grfvar.h>
d48 9
a56 1
static void	load_image_data(caddr_t data, struct image_data *image);
d58 3
a60 17
static int	grfmv_intr_generic_write1(void *vsc);
static int	grfmv_intr_generic_write4(void *vsc);
static int	grfmv_intr_generic_or4(void *vsc);

static int	grfmv_intr_cb264(void *vsc);
static int	grfmv_intr_cb364(void *vsc);
static int	grfmv_intr_cmax(void *vsc);
static int	grfmv_intr_cti(void *vsc);
static int	grfmv_intr_radius(void *vsc);
static int	grfmv_intr_radius24(void *vsc);
static int	grfmv_intr_supermacgfx(void *vsc);
static int	grfmv_intr_lapis(void *vsc);
static int	grfmv_intr_formac(void *vsc);
static int	grfmv_intr_vimage(void *vsc);
static int	grfmv_intr_gvimage(void *vsc);
static int	grfmv_intr_radius_gsc(void *vsc);
static int	grfmv_intr_radius_gx(void *vsc);
d62 1
a62 2
static int	grfmv_match(struct device *, void *, void *);
static void	grfmv_attach(struct device *, struct device *, void *);
d64 17
a80 3
struct cfdriver macvid_cd = {
	NULL, "macvid", DV_DULL
};
d82 1
a82 3
struct cfattach macvid_ca = {
	sizeof(struct grfbus_softc), grfmv_match, grfmv_attach
};
d84 2
a85 4
static void
load_image_data(data, image)
	caddr_t	data;
	struct	image_data *image;
d106 2
a107 5
static int
grfmv_match(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
d112 1
a112 1
		return 0;
d115 1
a115 1
		return 0;
d118 1
a118 1
		return 0;
d126 1
a126 2

	return 1;
d129 2
a130 4
static void
grfmv_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a131 1
	struct grfbus_softc *sc = (struct grfbus_softc *)self;
d133 1
a134 1
	struct grfmode gm;
d139 1
d150 1
a150 1
		printf(": grfmv_attach: failed to map slot %d\n", na->slot);
d158 2
a159 3
bad:
		bus_space_unmap(sc->sc_tag, sc->sc_regh, NBMEMSIZE);
		return;
d168 2
a169 1
		    &sc->sc_slot, &dir, 129, &dirent) <= 0))
d171 1
d206 2
a207 3
	strncpy(cardname, nubus_get_card_name(sc->sc_tag, sc->sc_regh,
	    &sc->sc_slot), CARD_NAME_LEN);
	cardname[CARD_NAME_LEN-1] = '\0';
d219 1
d223 1
d368 5
a372 1
	grf_establish(sc, &gm);
d382 2
a383 3
static int
grfmv_intr_generic_write1(vsc)
	void	*vsc;
d385 1
a385 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d398 2
a399 3
static int
grfmv_intr_generic_write4(vsc)
	void	*vsc;
d401 1
a401 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d414 2
a415 3
static int
grfmv_intr_generic_or4(vsc)
	void	*vsc;
d417 1
a417 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d430 2
a431 3
static int
grfmv_intr_radius(vsc)
	void	*vsc;
d433 1
a433 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d450 2
a451 3
static int
grfmv_intr_radius24(vsc)
	void	*vsc;
d453 1
a453 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d473 2
a474 3
static int
grfmv_intr_cti(vsc)
	void	*vsc;
d476 1
a476 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d488 2
a489 3
static int
grfmv_intr_cb264(vsc)
	void	*vsc;
d491 1
a491 1
	struct grfbus_softc *sc;
a493 1
	sc = (struct grfbus_softc *)vsc;
d541 2
a542 3
static int
grfmv_intr_cb364(vsc)
	void	*vsc;
d544 1
a544 1
	struct grfbus_softc *sc;
a546 1
	sc = (struct grfbus_softc *)vsc;
d628 2
a629 3
static int
grfmv_intr_supermacgfx(vsc)
	void	*vsc;
d631 1
a631 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d642 2
a643 3
static int
grfmv_intr_cmax(vsc)
	void	*vsc;
d645 1
a645 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d658 2
a659 3
static int
grfmv_intr_lapis(vsc)
	void	*vsc;
d661 1
a661 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d672 2
a673 3
static int
grfmv_intr_formac(vsc)
	void	*vsc;
d675 1
a675 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d687 2
a688 3
static int
grfmv_intr_vimage(vsc)
	void	*vsc;
d690 1
a690 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d701 2
a702 3
static int
grfmv_intr_gvimage(vsc)
	void	*vsc;
d704 1
a704 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d715 2
a716 3
static int
grfmv_intr_radius_gsc(vsc)
	void	*vsc;
d718 1
a718 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
d730 2
a731 3
static int
grfmv_intr_radius_gx(vsc)
	void	*vsc;
d733 1
a733 1
	struct grfbus_softc *sc = (struct grfbus_softc *)vsc;
@


1.27
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.26 2005/09/12 10:07:29 martin Exp $	*/
d140 1
a140 1
	struct grfmode *gm;
d143 1
a143 1
	nubus_dir dir, mode_dir;
d168 1
a168 1
	nubus_get_dir_from_rsrc(&sc->sc_slot, &dirent, &sc->board_dir);
d171 1
a171 1
	    &sc->sc_slot, &sc->board_dir, NUBUS_RSRC_TYPE, &dirent) <= 0)
d179 1
a179 1
	    &sc->sc_slot, &sc->board_dir, mode, &dirent) <= 0) {
d202 7
a208 12
	gm = &sc->curr_mode;
	gm->mode_id = mode;
	gm->ptype = image.pixelType;
	gm->psize = image.pixelSize;
	gm->width = image.right - image.left;
	gm->height = image.bottom - image.top;
	gm->rowbytes = image.rowbytes;
	gm->hres = image.hRes;
	gm->vres = image.vRes;
	gm->fbsize = gm->height * gm->rowbytes;
	gm->fbbase = (caddr_t)(sc->sc_handle.base);	/* XXX evil hack */
	gm->fboff = image.offset;
d371 1
a371 1
	grf_establish(sc);
@


1.26
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.25 2005/08/06 19:51:43 martin Exp $	*/
a44 1
#include <machine/grfioctl.h>
a69 1
static int	grfmv_mode(struct grf_softc *gp, int cmd, void *arg);
d376 1
a376 21
	grf_establish(sc, &sc->sc_slot, grfmv_mode);
}

static int
grfmv_mode(gp, cmd, arg)
	struct grf_softc *gp;
	int cmd;
	void *arg;
{
	switch (cmd) {
	case GM_GRFON:
	case GM_GRFOFF:
		return 0;
	case GM_CURRMODE:
		break;
	case GM_NEWMODE:
		break;
	case GM_LISTMODES:
		break;
	}
	return EINVAL;
@


1.25
log
@overhaul the grf driver:

- Simplify grfmv_phys() to work like grfiv_phys(), and eliminate the
  second argument to both, as we don't use it anyway.
- Handle fbbase and fboff consistently throughout.
- Eliminate grfaddr() by pulling it into grfmmap(), which is the
  only place it was used, previously.
- grfmap() now gets the physical address of the framebuffer from
  the appropriate driver, rather than try to compute it by itself.
  Be careful with aligning the base to a page address and increase
  the length of the mapped region appropriately.
- Store the PA of the framebuffer in the softc.  This eliminates the need
  for the sc_phys callback; we can just store the PA in the grfbus attach
  args, rather than a function pointer, which simplifies the code nicely.
- Disable Valkyrie interrupts on the Quadra 630
- New and improved console framebuffer initialization and autoconfig.  This
  resolves a great many issues, including Performa 58x interrupt handling
  and offset displays on some models.
- Remove unused grf ioctls
- Some KNF and other minor things

help and ok miod@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.24 2005/07/23 23:28:58 martin Exp $	*/
d214 1
a214 1
	gm->fbbase = (caddr_t)sc->sc_regh;	/* XXX evil hack */
d528 1
a528 1
	slotbase = (volatile char *)sc->sc_regh; /* XXX evil hack */
d583 1
a583 1
	slotbase = (volatile char *)sc->sc_regh; /* XXX evil hack */
@


1.24
log
@vm_offset_t -> {vaddr_t, bus_addr_t}
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.23 2005/06/12 20:51:29 martin Exp $	*/
a71 1
static caddr_t	grfmv_phys(struct grf_softc *gp, vaddr_t addr);
d152 2
d155 2
a156 2
	if (bus_space_map(sc->sc_tag,
	    NUBUS_SLOT2PA(na->slot), NBMEMSIZE, 0, &sc->sc_regh)) {
d378 1
a378 1
	grf_establish(sc, &sc->sc_slot, grfmv_mode, grfmv_phys);
a398 9
}

static caddr_t
grfmv_phys(gp, addr)
	struct grf_softc *gp;
	vaddr_t addr;
{
	return (caddr_t)(NUBUS_SLOT2PA(gp->sc_slot->slot) +
	    (addr - gp->sc_regh));	/* XXX evil hack */
@


1.23
log
@handle SuperMac Thunder/24 interrupts
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.22 2005/05/01 17:04:52 martin Exp $	*/
d72 1
a72 1
static caddr_t	grfmv_phys(struct grf_softc *gp, vm_offset_t addr);
d403 1
a403 1
	vm_offset_t addr;
@


1.22
log
@- Sync nubus IDs with NetBSD and add some more
- add support for reading sMemory resources from nubus cards (currently unused)
- support a bunch more nubus video cards. The Miro PRISMA GX seems to handle
  interrupts like the Radius DirectColor/GX, so just treat it the same.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.21 2005/04/26 21:09:35 martin Exp $	*/
d337 1
@


1.21
log
@new NuBus slot space mapping/probing code utilizing bus_space(9)

ok miod@@

from NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: grf_mv.c,v 1.20 2004/11/26 21:21:24 miod Exp $	*/
/*	$NetBSD: grf_mv.c,v 1.24 1997/05/03 02:29:54 briggs Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Allen Briggs.
 * 4. The name of the author may not be used to endorse or promote products
d48 2
a49 2
#include "nubus.h"
#include "grfvar.h"
d53 4
a56 3
static int	grfmv_intr_generic(void *vsc);
static int	grfmv_intr_radius(void *vsc);
static int	grfmv_intr_cti(void *vsc);
d59 11
d149 2
a153 2
	bcopy(na->fmt, &sc->sc_slot, sizeof(nubus_slot));

d205 2
a206 4
	gm->fbbase = (caddr_t)(sc->sc_regh +
				m68k_trunc_page(image.offset)); /* XXX evil! */
	gm->fboff = image.offset & PGOFSET;
	gm->rowbytes = image.rowbytes;
d209 1
a209 1
	gm->fbsize = sc->curr_mode.height * sc->curr_mode.rowbytes;
d212 3
a214 2
	gm->ptype = image.pixelType;
	gm->psize = image.pixelSize;
d236 1
d238 1
a238 1
	case NUBUS_DRHW_TFB:
d241 1
a241 1
		add_nubus_intr(na->slot, grfmv_intr_generic, sc,
d247 31
a277 1
		add_nubus_intr(na->slot, grfmv_intr_generic, sc,
d281 7
d291 13
d306 1
d309 1
a309 1
		add_nubus_intr(na->slot, grfmv_intr_generic, sc,
d314 14
d330 20
a349 2
	case NUBUS_DRHW_CB264:
		add_nubus_intr(na->slot, grfmv_intr_cb264, sc,
d352 2
a353 2
	case NUBUS_DRHW_CB364:
		add_nubus_intr(na->slot, grfmv_intr_cb364, sc,
d356 5
a360 2
	case NUBUS_DRHW_SE30:
		/* Do nothing--SE/30 interrupts are disabled */
d363 5
a367 1
		/* What do we know about this one? */
d369 1
a369 1
		printf("%s: Unknown video card 0x%x--",
d371 1
a371 1
		printf("Not installing interrupt routine.\n");
d411 2
a412 2
 * a CLR.B to clear the interrupt.  The offset of this byte varies between
 * cards.
d416 1
a416 1
grfmv_intr_generic(vsc)
d422 17
d444 19
d473 1
a473 6
	/*
	 * The value 0x66 was the observed value on one	card.  It is read
	 * from the driver's information block, so this may not be sufficient.
	 * Then again, we're not setting up any other interrupts...
	 */
	c = 0x66;
d483 19
d528 2
a529 1
grfmv_intr_cb264(void *vsc)
d535 1
a535 1
	slotbase = (volatile char *)sc->sc_regh;	/* XXX evil hack */
d583 2
a584 1
grfmv_intr_cb364(void *vsc)
d590 1
a590 1
	slotbase = (volatile char *)sc->sc_regh;	/* XXX evil hack */
d664 124
@


1.20
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.19 2004/01/09 22:55:19 jmc Exp $	*/
d140 1
d145 6
d153 4
a156 1
	if (nubus_find_rsrc(&sc->sc_slot, &dir, na->rsrcid, &dirent) <= 0)
d158 1
d162 2
a163 2
	if (nubus_find_rsrc(&sc->sc_slot, &sc->board_dir,
	    NUBUS_RSRC_TYPE, &dirent) <= 0)
d165 3
a167 2
		    (nubus_find_rsrc(&sc->sc_slot, &dir, 129, &dirent) <= 0))
			return;
d170 4
a173 4
	if (nubus_find_rsrc(&sc->sc_slot, &sc->board_dir, mode, &dirent) <= 0) {
		printf("\n%s: probe failed to get board rsrc.\n",
		    sc->sc_dev.dv_xname);
		return;
d178 4
a181 5
	if (nubus_find_rsrc(&sc->sc_slot, &mode_dir, VID_PARAMS, &dirent)
	    <= 0) {
		printf("\n%s: probe failed to get mode dir.\n",
		    sc->sc_dev.dv_xname);
		return;
d184 4
a187 5
	if (nubus_get_ind_data(&sc->sc_slot, &dirent, (caddr_t)&image_store,
				sizeof(struct image_data)) <= 0) {
		printf("\n%s: probe failed to get indirect mode data.\n",
		    sc->sc_dev.dv_xname);
		return;
d196 2
a197 2
	gm->fbbase = (caddr_t)(sc->sc_slot.virtual_base +
				m68k_trunc_page(image.offset));
d208 2
a209 2
	strncpy(cardname, nubus_get_card_name(&sc->sc_slot),
		CARD_NAME_LEN);
d223 1
a223 1
			printf("%s: card masquerades as Toby Framebuffer",
d232 1
a232 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_generic, sc,
d238 1
a238 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_generic, sc,
d242 1
a242 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_radius, sc,
d247 1
a247 1
		sc->cli_offset = 0xF05000;
d249 1
a249 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_generic, sc,
d253 1
a253 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_cti, sc,
d257 1
a257 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_cb264, sc,
d261 1
a261 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_cb364, sc,
d306 1
a306 1
				(addr - gp->sc_slot->virtual_base));
d317 2
a318 1
grfmv_intr_generic(void *vsc)
d320 1
a320 2
	struct grfbus_softc *sc;
	volatile char *slotbase;
d322 2
a323 3
	sc = (struct grfbus_softc *)vsc;
	slotbase = (volatile char *)sc->sc_slot.virtual_base;
	slotbase[sc->cli_offset] = sc->cli_value;
d328 1
a328 3
 * Generic routine to clear interrupts for cards where it simply takes
 * a CLR.B to clear the interrupt.  The offset of this byte varies between
 * cards.
d332 2
a333 1
grfmv_intr_radius(void *vsc)
d335 2
a336 6
	unsigned char	c;
	struct grfbus_softc *sc;
	volatile char *slotbase;

	sc = (struct grfbus_softc *)vsc;
	slotbase = (volatile char *)sc->sc_slot.virtual_base;
d346 3
a348 3
	slotbase[0xD00403] = c;
	c &= 0x7F;
	slotbase[0xD00403] = c;
d363 2
a364 1
grfmv_intr_cti(void *vsc)
d366 2
a367 2
	struct grfbus_softc *sc;
	volatile char *slotbase;
d369 5
a373 4
	sc = (struct grfbus_softc *)vsc;
	slotbase = ((volatile char *)sc->sc_slot.virtual_base) + 0x00080000;
	*slotbase = (*slotbase | 0x02);
	*slotbase = (*slotbase & 0xFD);
d385 1
a385 1
	slotbase = (volatile char *)sc->sc_slot.virtual_base;
d439 1
a439 1
	slotbase = (volatile char *)sc->sc_slot.virtual_base;
@


1.19
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.18 2002/03/14 01:26:35 millert Exp $	*/
d56 5
a60 5
static void	grfmv_intr_generic(void *vsc, int slot);
static void	grfmv_intr_radius(void *vsc, int slot);
static void	grfmv_intr_cti(void *vsc, int slot);
static void	grfmv_intr_cb264(void *vsc, int slot);
static void	grfmv_intr_cb364(void *vsc, int slot);
d222 2
a223 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_generic, sc);
d228 2
a229 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_generic, sc);
d232 2
a233 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_radius, sc);
d239 2
a240 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_generic, sc);
d243 2
a244 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_cti, sc);
d247 2
a248 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_cb264, sc);
d251 2
a252 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_cb364, sc);
d306 2
a307 4
static void
grfmv_intr_generic(vsc, slot)
	void	*vsc;
	int	slot;
d315 1
d324 2
a325 4
static void
grfmv_intr_radius(vsc, slot)
	void	*vsc;
	int	slot;
d345 1
d358 2
a359 4
static void
grfmv_intr_cti(vsc, slot)
	void	*vsc;
	int	slot;
d368 1
d372 2
a373 4
static void
grfmv_intr_cb264(vsc, slot)
	void	*vsc;
	int	slot;
d417 1
d426 2
a427 4
static void
grfmv_intr_cb364(vsc, slot)
	void	*vsc;
	int	slot;
d507 1
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.17 1999/04/24 06:39:40 downsj Exp $	*/
d213 1
a213 1
			printf("%s: card masquaredes as Toby Framebuffer",
@


1.17
log
@Use the generic m68k param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.16 1997/05/03 02:30:29 briggs Exp $	*/
d54 1
a54 1
static void	load_image_data __P((caddr_t data, struct image_data *image));
d56 10
a65 10
static void	grfmv_intr_generic __P((void *vsc, int slot));
static void	grfmv_intr_radius __P((void *vsc, int slot));
static void	grfmv_intr_cti __P((void *vsc, int slot));
static void	grfmv_intr_cb264 __P((void *vsc, int slot));
static void	grfmv_intr_cb364 __P((void *vsc, int slot));

static int	grfmv_mode __P((struct grf_softc *gp, int cmd, void *arg));
static caddr_t	grfmv_phys __P((struct grf_softc *gp, vm_offset_t addr));
static int	grfmv_match __P((struct device *, void *, void *));
static void	grfmv_attach __P((struct device *, struct device *, void *));
@


1.17.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.17 1999/04/24 06:39:40 downsj Exp $	*/
d54 1
a54 1
static void	load_image_data(caddr_t data, struct image_data *image);
d56 10
a65 10
static void	grfmv_intr_generic(void *vsc, int slot);
static void	grfmv_intr_radius(void *vsc, int slot);
static void	grfmv_intr_cti(void *vsc, int slot);
static void	grfmv_intr_cb264(void *vsc, int slot);
static void	grfmv_intr_cb364(void *vsc, int slot);

static int	grfmv_mode(struct grf_softc *gp, int cmd, void *arg);
static caddr_t	grfmv_phys(struct grf_softc *gp, vm_offset_t addr);
static int	grfmv_match(struct device *, void *, void *);
static void	grfmv_attach(struct device *, struct device *, void *);
@


1.17.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
static void	load_image_data(caddr_t data, struct image_data *image);
d56 10
a65 10
static void	grfmv_intr_generic(void *vsc, int slot);
static void	grfmv_intr_radius(void *vsc, int slot);
static void	grfmv_intr_cti(void *vsc, int slot);
static void	grfmv_intr_cb264(void *vsc, int slot);
static void	grfmv_intr_cb364(void *vsc, int slot);

static int	grfmv_mode(struct grf_softc *gp, int cmd, void *arg);
static caddr_t	grfmv_phys(struct grf_softc *gp, vm_offset_t addr);
static int	grfmv_match(struct device *, void *, void *);
static void	grfmv_attach(struct device *, struct device *, void *);
@


1.17.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d213 1
a213 1
			printf("%s: card masquerades as Toby Framebuffer",
@


1.16
log
@Support for clearing interrupts on a Rasterops Colorboard 364.
Thanks go to Michel Chalufour <michelc@@tiac.net> for grovelling around for
me.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.15 1997/05/02 00:59:52 briggs Exp $	*/
d187 1
a187 1
				mac68k_trunc_page(image.offset));
@


1.15
log
@Thanks to Tobias Beal <tbeal41@@maine.maine.edu>, we can clear interrupts
on at least one Radius Precisioncolor 8 board.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf_mv.c,v 1.14 1997/05/01 03:36:51 briggs Exp $	*/
/*	$NetBSD: grf_mv.c,v 1.23 1997/05/02 00:54:29 briggs Exp $	*/
d60 1
d242 2
d245 1
a245 1
		add_nubus_intr(sc->sc_slot.slot, grfmv_intr_cb264, sc);
d415 91
@


1.14
log
@Clear the interrupts properly on an E-Machines Futura II LX and make a wild
guess at clearing them on a Futura II SX/DSP and RasterOps ColorBoard 364.
Thanks to Michel Chalufour <michelc@@tiac.net> for loaning me the II LX.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf_mv.c,v 1.13 1997/04/17 17:46:39 gene Exp $	*/
/*	$NetBSD: grf_mv.c,v 1.17 1997/02/24 06:20:06 scottr Exp $	*/
d57 1
d228 3
a300 1
	static char zero = 0;
d306 32
a337 1
	slotbase[sc->cli_offset] = zero;
@


1.13
log
@Changes earmarked 'purely cosmetic' by Scott Reynolds:
>- Remove unused `register' modifier on declarations
>- Reverse the sense of some tests to make the code more clear
>- Type casts per KNF
>- Move a static variable into the only function that uses it
>  (perhaps we can eliminate it entirely, someday?)
Also, I went through these files and XXX'ed some things that should be and
fixed a few more formatting problems per KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.12 1997/04/10 20:34:33 briggs Exp $	*/
d219 1
d224 7
d237 1
@


1.12
log
@Ignore SE/30 faux-video card.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.11 1997/04/01 13:52:34 briggs Exp $	*/
a55 1
static char zero = 0;
d103 1
a103 1
	struct nubus_attach_args *na = (struct nubus_attach_args *) aux;
d129 2
a130 2
	struct grfbus_softc *sc = (struct grfbus_softc *) self;
	struct nubus_attach_args *na = (struct nubus_attach_args *) aux;
d171 1
a171 1
	if (nubus_get_ind_data(&sc->sc_slot, &dirent, (caddr_t) &image_store,
d180 1
a180 1
	load_image_data((caddr_t) &image_store, &image);
d184 1
a184 1
	gm->fbbase = (caddr_t) (sc->sc_slot.virtual_base +
d199 1
d208 1
a208 1
		if (strncmp(cardname, "Samsung 768", 11) == 0) {
d210 3
a212 4
		} else if (strncmp(cardname, "Toby frame", 10) == 0) {
		} else {
			printf(": (evil card pretending to be TFB)");
		}
a214 2
	printf(": %s\n", cardname);

d237 2
a238 1
		printf("        Unknown video card 0x%x--", sc->card_id);
d272 1
a272 1
	return (caddr_t) (NUBUS_SLOT2PA(gp->sc_slot->slot) +
d288 3
a290 2
	caddr_t			 slotbase;
	struct grfbus_softc	*sc;
d292 2
a293 2
	sc = (struct grfbus_softc *) vsc;
	slotbase = (caddr_t) sc->sc_slot.virtual_base;
d312 2
a313 2
	volatile char		*slotbase;
	struct grfbus_softc	*sc;
d315 2
a316 2
	sc = (struct grfbus_softc *) vsc;
	slotbase = ((volatile char *) sc->sc_slot.virtual_base) + 0x00080000;
d328 1
a328 1
	caddr_t slotbase;
d330 2
a331 2
	sc = (struct grfbus_softc *) vsc;
	slotbase = (caddr_t) sc->sc_slot.virtual_base;
@


1.11
log
@Add DrHW for RasterOps CB264--From Scott Reynolds--and link it in to the
proper interrupt routine.  grfmv_intr_mystery changed to grfmv_intr_cb264.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.10 1997/03/29 23:47:13 briggs Exp $	*/
d233 3
@


1.10
log
@Do not register an interrupt handler unless we know that we can clear
interrupts properly.
Take a stab at clearing interrupts correctly for stupid Samsung video
card that masquerades as a Toby Frame Buffer card.
Break out interrupt routines by card type, including the cards that just
need a byte cleared to clear the interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.9 1997/03/14 14:16:52 briggs Exp $	*/
d59 1
a59 4

#ifdef MYSTERY
static void	grfmv_intr_mystery __P((void *vsc, int slot));
#endif
d231 3
a318 1
#ifdef MYSTERY
d321 1
a321 1
grfmv_intr_mystery(vsc, slot)
a367 1
#endif
@


1.9
log
@Possible fix for SE/30 internal video problems.  Thanks to Denny Gentry for
figuring out what was going wrong there.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.8 1997/03/12 13:36:57 briggs Exp $	*/
a54 1
static void	grfmv_intr __P((void *vsc, int slot));
a55 1
#ifndef MYSTERY
d57 5
a100 66
/*ARGSUSED*/
static void
grfmv_intr(vsc, slot)
	void	*vsc;
	int	slot;
{
#ifdef MYSTERY
	struct grfbus_softc *sc;
	caddr_t slotbase;

	sc = (struct grfbus_softc *) vsc;
	slotbase = (caddr_t) sc->sc_slot.virtual_base;
	asm volatile("	movl	%0,a0
			movl	a0@@(0xff6028),d0
			andl	#0x2,d0
			beq	_mv_intr0
			movql	#0x3,d0
		_mv_intr0:
			movl	a0@@(0xff600c),d1
			andl	#0x3,d1
			cmpl	d1,d0
			beq	_mv_intr_fin
			movl	d0,a0@@(0xff600c)
			nop
			tstb	d0
			beq	_mv_intr1
			movl	#0x0002,a0@@(0xff6040)
			movl	#0x0102,a0@@(0xff6044)
			movl	#0x0105,a0@@(0xff6048)
			movl	#0x000e,a0@@(0xff604c)
			movl	#0x001c,a0@@(0xff6050)
			movl	#0x00bc,a0@@(0xff6054)
			movl	#0x00c3,a0@@(0xff6058)
			movl	#0x0061,a0@@(0xff605c)
			movl	#0x0012,a0@@(0xff6060)
			bra	_mv_intr_fin
		_mv_intr1:
			movl	#0x0002,a0@@(0xff6040)
			movl	#0x0209,a0@@(0xff6044)
			movl	#0x020c,a0@@(0xff6048)
			movl	#0x000f,a0@@(0xff604c)
			movl	#0x0027,a0@@(0xff6050)
			movl	#0x00c7,a0@@(0xff6054)
			movl	#0x00d7,a0@@(0xff6058)
			movl	#0x006b,a0@@(0xff605c)
			movl	#0x0029,a0@@(0xff6060)
		_mv_intr_fin:
			movl	#0x1,a0@@(0xff6014)"
		: : "g" (slotbase) : "a0","d0","d1");
#else
	caddr_t			 slotbase;
	struct grfbus_softc	*sc;

	sc = (struct grfbus_softc *) vsc;
	slotbase = (caddr_t) sc->sc_slot.virtual_base;
	switch (sc->card_id) {
	case NUBUS_DRHW_WVC:
		slotbase[0xa00000] = zero;
		break;
	default:
		slotbase[0xa0000] = zero;
		break;
	}
#endif
}

d204 15
d221 20
a240 1
	add_nubus_intr(sc->sc_slot.slot, grfmv_intr, sc);
d274 96
@


1.8
log
@Remove some more warnings left over from NetBSD's new config.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.7 1997/03/08 16:16:51 briggs Exp $	*/
d251 3
a253 2
	gm->fbbase = (caddr_t) (sc->sc_slot.virtual_base + image.offset);
	gm->fboff = image.offset;
@


1.7
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.6 1997/01/24 01:35:31 briggs Exp $	*/
d63 1
a63 1
static int	grfmv_match __P((struct device *, struct cfdata *, void *));
d165 1
a165 1
grfmv_match(parent, cf, aux)
d167 1
a167 1
	struct cfdata *cf;
@


1.6
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf_mv.c,v 1.5 1996/09/21 03:55:47 briggs Exp $	*/
/*	$NetBSD: grf_mv.c,v 1.15 1996/12/16 16:17:06 scottr Exp $	*/
d46 1
d57 1
d59 1
d104 44
d161 1
d299 1
a299 1
	return (caddr_t) (NUBUS_SLOT_TO_PADDR(gp->sc_slot->slot) +
@


1.5
log
@Handle the two-page display card, although it doesn't appear to be generating
video interrupts on my Q700 (perhaps it realized that DAFB will do that).
@
text
@d1 2
a2 2
/*	$OpenBSD: grf_mv.c,v 1.4 1996/08/10 21:37:44 briggs Exp $	*/
/*	$NetBSD: grf_mv.c,v 1.12 1996/08/04 06:03:54 scottr Exp $	*/
a54 1
static int	get_vrsrcid __P((nubus_slot *slot));
d60 1
a60 1
static int	grfmv_match __P((struct device *, void *, void *));
d117 1
a117 14
get_vrsrcid(slot)
	nubus_slot	*slot;
{
extern	u_short	mac68k_vrsrc_vec[];
	int	i;

	for (i = 0 ; i < 6 ; i++)
		if ((mac68k_vrsrc_vec[i] & 0xff) == slot->slot)
			return ((mac68k_vrsrc_vec[i] >> 8) & 0xff);
	return 0x80;
}

static int
grfmv_match(parent, self, aux)
d119 2
a120 1
	void *self, *aux;
d122 1
a122 30
	struct grfbus_softc	*sc;
	nubus_slot	*slot = (nubus_slot *) aux;
	nubus_dir	dir, *dirp, *dirp2;
	nubus_dirent	dirent, *direntp;
	nubus_type	slottype;
	int		vrsrc;

	sc = (struct grfbus_softc *) self;	/* XXX: indirect brokenness */
	dirp = &dir;
	direntp = &dirent;
	nubus_get_main_dir(slot, dirp);

	vrsrc = get_vrsrcid(slot);
	if (nubus_find_rsrc(slot, dirp, vrsrc, direntp) <= 0) {
		if (   (vrsrc != 128)
		    || (nubus_find_rsrc(slot, dirp, 129, direntp) <= 0)) {
			return 0;
		}
	}

	dirp2 = (nubus_dir *) &sc->board_dir;
	nubus_get_dir_from_rsrc(slot, direntp, dirp2);

	if (nubus_find_rsrc(slot, dirp2, NUBUS_RSRC_TYPE, direntp) <= 0)
		/* Type is a required entry...  This should never happen. */
		return 0;

	if (nubus_get_ind_data(slot, direntp,
			(caddr_t) &slottype, sizeof(nubus_type)) <= 0)
		return 0;
d124 1
a124 1
	if (slottype.category != NUBUS_CATEGORY_DISPLAY)
d127 1
a127 1
	if (slottype.type != NUBUS_TYPE_VIDEO)
d130 1
a130 1
	if (slottype.drsw != NUBUS_DRSW_APPLE)
a139 6
	sc->card_id = slottype.drhw;

	sc->sc_slot = *slot;

	/* Need to load display info (and driver?), etc... */

d148 2
a149 1
	struct grfbus_softc	*sc;
d151 11
a161 5
	struct		grfmode *gm;
	char		cardname[CARD_NAME_LEN];
	nubus_dirent	dirent;
	nubus_dir	mode_dir;
	int		mode;
d163 10
a172 2
	sc = (struct grfbus_softc *) self;
	gm = &sc->curr_mode;
d197 2
d201 1
@


1.4
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_mv.c,v 1.3 1996/05/26 18:35:21 briggs Exp $	*/
d107 8
a114 1
	slotbase[0xa0000] = zero;
@


1.3
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: grf_mv.c,v 1.11 1996/05/19 22:27:07 scottr Exp $	*/
d246 1
a246 1
	grf_establish(sc, grfmv_mode, grfmv_phys);
@


1.2
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: grf_mv.c,v 1.7 1995/08/24 04:27:16 briggs Exp $	*/
d43 1
d45 1
d47 1
a47 1
#include <machine/cpu.h>
d52 3
a54 3
extern int	grfmv_probe __P((struct grf_softc *gp, nubus_slot *slot));
extern int	grfmv_init __P((struct grf_softc *gp));
extern int	grfmv_mode __P((struct grf_softc *gp, int cmd, void *arg));
d58 13
d95 1
d97 2
a98 2
grfmv_intr(sc, slot)
	struct	grf_softc *sc;
d101 2
a102 2
	struct grf_softc *gp;
	caddr_t		 slotbase;
d104 2
a105 1
	slotbase = (caddr_t) NUBUS_SLOT_TO_BASE(slot);
a113 1
extern	int	mac68k_vrsrc_cnt;
d122 4
a125 4
extern int
grfmv_probe(sc, slot)
	struct	grf_softc *sc;
	nubus_slot	*slot;
d127 3
a129 1
	nubus_dir	dir, *dirp, dir2, *dirp2;
d134 1
d176 2
d183 4
a186 3
extern int
grfmv_init(sc)
	struct grf_softc *sc;
d188 1
d190 2
d195 3
a197 1
	u_long		base;
d200 5
a204 2
	if (nubus_find_rsrc(&sc->sc_slot, &sc->board_dir, mode, &dirent) <= 0)
		return 0;
d208 6
a213 2
	if (nubus_find_rsrc(&sc->sc_slot, &mode_dir, VID_PARAMS, &dirent) <= 0)
		return 0;
d216 5
a220 2
				sizeof(struct image_data)) <= 0)
		return 0;
d224 11
a234 13
	base = NUBUS_SLOT_TO_BASE(sc->sc_slot.slot);

	sc->curr_mode.mode_id = mode;
	sc->curr_mode.fbbase = (caddr_t) (base + image.offset);
	sc->curr_mode.fboff = image.offset;
	sc->curr_mode.rowbytes = image.rowbytes;
	sc->curr_mode.width = image.right - image.left;
	sc->curr_mode.height = image.bottom - image.top;
	sc->curr_mode.fbsize = sc->curr_mode.height * sc->curr_mode.rowbytes;
	sc->curr_mode.hres = image.hRes;
	sc->curr_mode.vres = image.vRes;
	sc->curr_mode.ptype = image.pixelType;
	sc->curr_mode.psize = image.pixelSize;
d236 1
a236 1
	strncpy(sc->card_name, nubus_get_card_name(&sc->sc_slot),
d238 1
d240 1
a240 1
	sc->card_name[CARD_NAME_LEN-1] = '\0';
d244 2
a245 1
	return 1;
d248 1
a248 1
extern int
d268 1
a268 1
extern caddr_t
d273 2
a274 1
	return (caddr_t) NUBUS_VIRT_TO_PHYS(addr);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
