head	1.29;
access;
symbols
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.8
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.6
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.26.0.8
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.6
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.13.0.8
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.18
	OPENBSD_2_9_BASE:1.10
	NIKLAS_UNDEAD:1.10.0.16
	OPENBSD_2_8:1.10.0.14
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.12
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.10
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.28;

1.28
date	2011.06.15.21.32.03;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.10.17.47.54;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.13.20.56.54;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.04.15.35.09;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.14.09.36.49;	author martin;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.12.17.03.25;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.22.15.25.30;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.20.00.10.09;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.18.23.21.16;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.13.19.36.43;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.08.17.45.29;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.08.17.25.05;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.04.20.39.04;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.21.18.16.37;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.23.16.51.11;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.15.22.06.37;	author miod;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	98.03.03.04.29.44;	author ryker;	state Exp;
branches
	1.10.10.1;
next	1.9;

1.9
date	97.04.06.02.59.57;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.03.12.13.36.56;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.02.23.06.04.52;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.01.35.27;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.05.26.18.35.14;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.18.13.31;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.11.35.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.51.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.02;	author deraadt;	state Exp;
branches;
next	;

1.10.10.1
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.10.10.3;

1.10.10.3
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: adb.c,v 1.28 2011/06/15 21:32:03 miod Exp $	*/
/*	$NetBSD: adb.c,v 1.47 2005/06/16 22:43:36 jmc Exp $	*/
/*	$NetBSD: adb_direct.c,v 1.51 2005/06/16 22:43:36 jmc Exp $	*/

/*
 * Copyright (C) 1996, 1997 John P. Wittkoski
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by John P. Wittkoski.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (C) 1994	Bradley A. Grantham
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bradley A. Grantham.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code is rather messy, but I don't have time right now
 * to clean it up as much as I would like.
 * But it works, so I'm happy. :-) jpw
 */

/*
 * TO DO:
 *  - We could reduce the time spent in the adb_intr_* routines
 *    by having them save the incoming and outgoing data directly
 *    in the adbInbound and adbOutbound queues, as it would reduce
 *    the number of times we need to copy the data around. It
 *    would also make the code more readable and easier to follow.
 *  - (Related to above) Use the header part of adbCommand to
 *    reduce the number of copies we have to do of the data.
 *  - (Related to above) Actually implement the adbOutbound queue.
 *    This is fairly easy once you switch all the intr routines
 *    over to using adbCommand structs directly.
 *  - There is a bug in the state machine of adb_intr_cuda
 *    code that causes hangs, especially on 030 machines, probably
 *    because of some timing issues. Because I have been unable to
 *    determine the exact cause of this bug, I used the timeout function
 *    to check for and recover from this condition. If anyone finds
 *    the actual cause of this bug, the calls to timeout and the
 *    adb_cuda_tickle routine can be removed.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/timeout.h>
#include <sys/systm.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/viareg.h>

#include <dev/adb/adb.h>
#include <mac68k/dev/adbvar.h>

#define printf_intr printf

int	adb_polling;		/* Are we polling?  (Debugger mode) */
#ifdef ADB_DEBUG
int	adb_debug;		/* Output debugging messages */
#endif /* ADB_DEBUG */

struct adb_softc {
	struct device	 sc_dev;
	void		*sc_softih;
};

/* some misc. leftovers */
#define vPB		0x0000
#define vPB3		0x08
#define vPB4		0x10
#define vPB5		0x20
#define vSR_INT		0x04
#define vSR_OUT		0x10

/* the type of ADB action that we are currently preforming */
#define ADB_ACTION_NOTREADY	0x1	/* has not been initialized yet */
#define ADB_ACTION_IDLE		0x2	/* the bus is currently idle */
#define ADB_ACTION_OUT		0x3	/* sending out a command */
#define ADB_ACTION_IN		0x4	/* receiving data */
#define ADB_ACTION_POLLING	0x5	/* polling - II only */

/*
 * These describe the state of the ADB bus itself, although they
 * don't necessarily correspond directly to ADB states.
 * Note: these are not really used in the IIsi code.
 */
#define ADB_BUS_UNKNOWN		0x1	/* we don't know yet - all models */
#define ADB_BUS_IDLE		0x2	/* bus is idle - all models */
#define ADB_BUS_CMD		0x3	/* starting a command - II models */
#define ADB_BUS_ODD		0x4	/* the "odd" state - II models */
#define ADB_BUS_EVEN		0x5	/* the "even" state - II models */
#define ADB_BUS_ACTIVE		0x6	/* active state - IIsi models */
#define ADB_BUS_ACK		0x7	/* currently ACKing - IIsi models */

/*
 * Shortcuts for setting or testing the VIA bit states.
 * Not all shortcuts are used for every type of ADB hardware.
 */
#define ADB_SET_STATE_IDLE_II()		via_reg(VIA1, vBufB) |= (vPB4 | vPB5)
#define ADB_SET_STATE_IDLE_IISI()	via_reg(VIA1, vBufB) &= ~(vPB4 | vPB5)
#define ADB_SET_STATE_IDLE_CUDA()	via_reg(VIA1, vBufB) |= (vPB4 | vPB5)
#define ADB_SET_STATE_CMD()		via_reg(VIA1, vBufB) &= ~(vPB4 | vPB5)
#define ADB_SET_STATE_EVEN()		via_reg(VIA1, vBufB) = ((via_reg(VIA1, \
						vBufB) | vPB4) & ~vPB5)
#define ADB_SET_STATE_ODD()		via_reg(VIA1, vBufB) = ((via_reg(VIA1, \
						vBufB) | vPB5) & ~vPB4)
#define ADB_SET_STATE_ACTIVE() 		via_reg(VIA1, vBufB) |= vPB5
#define ADB_SET_STATE_INACTIVE()	via_reg(VIA1, vBufB) &= ~vPB5
#define ADB_SET_STATE_TIP()		via_reg(VIA1, vBufB) &= ~vPB5
#define ADB_CLR_STATE_TIP() 		via_reg(VIA1, vBufB) |= vPB5
#define ADB_SET_STATE_ACKON()		via_reg(VIA1, vBufB) |= vPB4
#define ADB_SET_STATE_ACKOFF()		via_reg(VIA1, vBufB) &= ~vPB4
#define ADB_TOGGLE_STATE_ACK_CUDA()	via_reg(VIA1, vBufB) ^= vPB4
#define ADB_SET_STATE_ACKON_CUDA()	via_reg(VIA1, vBufB) &= ~vPB4
#define ADB_SET_STATE_ACKOFF_CUDA()	via_reg(VIA1, vBufB) |= vPB4
#define ADB_SET_SR_INPUT()		via_reg(VIA1, vACR) &= ~vSR_OUT
#define ADB_SET_SR_OUTPUT()		via_reg(VIA1, vACR) |= vSR_OUT
#define ADB_SR()			via_reg(VIA1, vSR)
#define ADB_VIA_INTR_ENABLE()		via_reg(VIA1, vIER) = 0x84
#define ADB_VIA_INTR_DISABLE()		via_reg(VIA1, vIER) = 0x04
#define ADB_VIA_CLR_INTR()		via_reg(VIA1, vIFR) = 0x04
#define ADB_INTR_IS_OFF			(vPB3 == (via_reg(VIA1, vBufB) & vPB3))
#define ADB_INTR_IS_ON			(0 == (via_reg(VIA1, vBufB) & vPB3))
#define ADB_SR_INTR_IS_OFF		(0 == (via_reg(VIA1, vIFR) & vSR_INT))
#define ADB_SR_INTR_IS_ON		(vSR_INT == (via_reg(VIA1, \
						vIFR) & vSR_INT))

/*
 * This is the delay that is required (in uS) between certain
 * ADB transactions. The actual timing delay for for each uS is
 * calculated at boot time to account for differences in machine speed.
 */
#define ADB_DELAY	150

/*
 * Maximum ADB message length; includes space for data, result, and
 * device code - plus a little for safety.
 */
#define ADB_MAX_MSG_LENGTH	16
#define ADB_MAX_HDR_LENGTH	8

#define ADB_QUEUE		32
#define ADB_TICKLE_TICKS	4

/*
 * A structure for storing information about each ADB device.
 */
struct ADBDevEntry {
	void	(*ServiceRtPtr)(void);
	void	*DataAreaAddr;
	int	devType;
	int	origAddr;
	int	currentAddr;
};

/*
 * Used to hold ADB commands that are waiting to be sent out.
 */
struct adbCmdHoldEntry {
	u_char	outBuf[ADB_MAX_MSG_LENGTH];	/* our message */
	u_char	*saveBuf;	/* buffer to know where to save result */
	u_char	*compRout;	/* completion routine pointer */
	u_char	*data;		/* completion routine data pointer */
};

/*
 * Eventually used for two separate queues, the queue between
 * the upper and lower halves, and the outgoing packet queue.
 * TO DO: adbCommand can replace all of adbCmdHoldEntry eventually
 */
struct adbCommand {
	u_char	header[ADB_MAX_HDR_LENGTH];	/* not used yet */
	u_char	data[ADB_MAX_MSG_LENGTH];	/* packet data only */
	u_char	*saveBuf;	/* where to save result */
	u_char	*compRout;	/* completion routine pointer */
	u_char	*compData;	/* completion routine data pointer */
	u_int	cmd;		/* the original command for this data */
	u_int	unsol;		/* 1 if packet was unsolicited */
	u_int	ack_only;	/* 1 for no special processing */
};

/*
 * Text representations of each hardware class
 */
const char *adbHardwareDescr[] = {
	"unknown",
	"II series",
	"IIsi series",
	"PowerBook",
	"Cuda",
	"IOP"
};

/*
 * A few variables that we need and their initial values.
 */
int	adbHardware = ADB_HW_UNKNOWN;
int	adbActionState = ADB_ACTION_NOTREADY;
int	adbBusState = ADB_BUS_UNKNOWN;
int	adbWaiting;		/* waiting for return data from the device */
int	adbWriteDelay;		/* working on (or waiting to do) a write */
int	adbOutQueueHasData;	/* something in the queue waiting to go out */
int	adbSoftPower;		/* machine supports soft power */

int	adbWaitingCmd;		/* ADB command we are waiting for */
u_char	*adbBuffer;		/* pointer to user data area */
void	*adbCompRout;		/* pointer to the completion routine */
void	*adbCompData;		/* pointer to the completion routine data */
int	adbStarting = 1;	/* doing adb_reinit so do polling differently */

u_char	adbInputBuffer[ADB_MAX_MSG_LENGTH];	/* data input buffer */
u_char	adbOutputBuffer[ADB_MAX_MSG_LENGTH];	/* data output buffer */
struct	adbCmdHoldEntry adbOutQueue;		/* our 1 entry output queue */

int	adbSentChars;		/* how many characters we have sent */
int	adbLastDevice;		/* last ADB dev we heard from (II ONLY) */

struct	ADBDevEntry ADBDevTable[16];	/* our ADB device table */
int	ADBNumDevices;		/* num. of ADB devices found with adb_reinit */

struct	adbCommand adbInbound[ADB_QUEUE];	/* incoming queue */
volatile int	adbInCount;		/* how many packets in in queue */
int	adbInHead;			/* head of in queue */
int	adbInTail;			/* tail of in queue */
struct	adbCommand adbOutbound[ADB_QUEUE]; /* outgoing queue - not used yet */
int	adbOutCount;			/* how many packets in out queue */
int	adbOutHead;			/* head of out queue */
int	adbOutTail;			/* tail of out queue */

int	tickle_count;			/* how many tickles seen for this packet? */
int	tickle_serial;			/* the last packet tickled */
int	adb_cuda_serial;		/* the current packet */

struct timeout adb_cuda_timeout;

void	pm_setup_adb(void);
void	pm_hw_setup(struct device *);
void	pm_check_adb_devices(int);
int	pm_adb_op(u_char *, void *, void *, int);
void	pm_init_adb_device(void);

/*
 * The following are private routines.
 */
#ifdef ADB_DEBUG
void	print_single(u_char *);
#endif
int	adb_intr(void *);
int	adb_intr_II(void *);
int	adb_intr_IIsi(void *);
int	adb_intr_cuda(void *);
void	adb_soft_intr(void *);
int	send_adb_II(u_char *, u_char *, void *, void *, int);
int	send_adb_IIsi(u_char *, u_char *, void *, void *, int);
int	send_adb_cuda(u_char *, u_char *, void *, void *, int);
void	adb_intr_cuda_test(void);
void	adb_cuda_tickle(void);
void	adb_pass_up(struct adbCommand *);
void	adb_op_comprout(caddr_t, caddr_t, int);
void	adb_reinit(struct adb_softc *);
int	count_adbs(void);
int	get_ind_adb_info(ADBDataBlock *, int);
int	get_adb_info(ADBDataBlock *, int);
void	adb_setup_hw_type(void);
int	adb_op(Ptr, Ptr, Ptr, short);
void	adb_read_II(u_char *);
void	adb_hw_setup(struct adb_softc *);
void	adb_hw_setup_IIsi(u_char *);
int	adb_cmd_result(u_char *);
int	adb_guess_next_device(void);
int	adb_prog_switch_enable(void);
int	adb_prog_switch_disable(void);
/* we should create this and it will be the public version */
int	send_adb(u_char *, void *, void *);

#ifdef ADB_DEBUG
/*
 * print_single
 * Diagnostic display routine. Displays the hex values of the
 * specified elements of the u_char. The length of the "string"
 * is in [0].
 */
void
print_single(u_char *str)
{
	int x;

	if (str == NULL) {
		printf_intr("no data - null pointer\n");
		return;
	}
	if (*str == '\0') {
		printf_intr("nothing returned\n");
		return;
	}
	if (*str > 20) {
		printf_intr("ADB: ACK > 20 no way!\n");
		*str = (u_char)20;
	}
	printf_intr("(length=0x%x):", (u_int)*str);
	for (x = 1; x <= *str; x++)
		printf_intr("  0x%02x", (u_int)*(str + x));
	printf_intr("\n");
}
#endif

void
adb_cuda_tickle(void)
{
	volatile int s;

	if (adbActionState == ADB_ACTION_IN) {
		if (tickle_serial == adb_cuda_serial) {
			if (++tickle_count > 0) {
				s = splhigh();
				adbActionState = ADB_ACTION_IDLE;
				adbInputBuffer[0] = 0;
				ADB_SET_STATE_IDLE_CUDA();
				splx(s);
			}
		} else {
			tickle_serial = adb_cuda_serial;
			tickle_count = 0;
		}
	} else {
		tickle_serial = adb_cuda_serial;
		tickle_count = 0;
	}

	timeout_add(&adb_cuda_timeout, ADB_TICKLE_TICKS);
}

/*
 * called when when an adb interrupt happens
 *
 * Cuda version of adb_intr
 * TO DO: do we want to add some calls to intr_dispatch() here to
 * grab serial interrupts?
 */
int
adb_intr_cuda(void *arg)
{
	volatile int i, ending;
	volatile unsigned int s;
	struct adbCommand packet;

	s = splhigh();		/* can't be too careful - might be called */
				/* from a routine, NOT an interrupt */

	ADB_VIA_CLR_INTR();	/* clear interrupt */
	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */

switch_start:
	switch (adbActionState) {
	case ADB_ACTION_IDLE:
		/*
		 * This is an unexpected packet, so grab the first (dummy)
		 * byte, set up the proper vars, and tell the chip we are
		 * starting to receive the packet by setting the TIP bit.
		 */
		adbInputBuffer[1] = ADB_SR();
		adb_cuda_serial++;
		if (ADB_INTR_IS_OFF)	/* must have been a fake start */
			break;

		ADB_SET_SR_INPUT();
		ADB_SET_STATE_TIP();

		adbInputBuffer[0] = 1;
		adbActionState = ADB_ACTION_IN;
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("idle 0x%02x ", adbInputBuffer[1]);
#endif
		break;

	case ADB_ACTION_IN:
		adbInputBuffer[++adbInputBuffer[0]] = ADB_SR();
		/* intr off means this is the last byte (end of frame) */
		if (ADB_INTR_IS_OFF)
			ending = 1;
		else
			ending = 0;

		if (1 == ending) {	/* end of message? */
#ifdef ADB_DEBUG
			if (adb_debug) {
				printf_intr("in end 0x%02x ",
				    adbInputBuffer[adbInputBuffer[0]]);
				print_single(adbInputBuffer);
			}
#endif

			/*
			 * Are we waiting AND does this packet match what we
			 * are waiting for AND is it coming from either the
			 * ADB or RTC/PRAM sub-device? This section _should_
			 * recognize all ADB and RTC/PRAM type commands, but
			 * there may be more... NOTE: commands are always at
			 * [4], even for RTC/PRAM commands.
			 */
			/* set up data for adb_pass_up */
			memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);
				
			if ((adbWaiting == 1) &&
			    (adbInputBuffer[4] == adbWaitingCmd) &&
			    ((adbInputBuffer[2] == 0x00) ||
			    (adbInputBuffer[2] == 0x01))) {
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.unsol = 0;
				packet.ack_only = 0;
				adb_pass_up(&packet);

				adbWaitingCmd = 0;	/* reset "waiting" vars */
				adbWaiting = 0;
				adbBuffer = NULL;
				adbCompRout = NULL;
				adbCompData = NULL;
			} else {
				packet.unsol = 1;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			}


			/* reset vars and signal the end of this frame */
			adbActionState = ADB_ACTION_IDLE;
			adbInputBuffer[0] = 0;
			ADB_SET_STATE_IDLE_CUDA();
			/*ADB_SET_SR_INPUT();*/

			/*
			 * If there is something waiting to be sent out,
			 * the set everything up and send the first byte.
			 */
			if (adbWriteDelay == 1) {
				delay(ADB_DELAY);	/* required */
				adbSentChars = 0;
				adbActionState = ADB_ACTION_OUT;
				/*
				 * If the interrupt is on, we were too slow
				 * and the chip has already started to send
				 * something to us, so back out of the write
				 * and start a read cycle.
				 */
				if (ADB_INTR_IS_ON) {
					ADB_SET_SR_INPUT();
					ADB_SET_STATE_IDLE_CUDA();
					adbSentChars = 0;
					adbActionState = ADB_ACTION_IDLE;
					adbInputBuffer[0] = 0;
					break;
				}
				/*
				 * If we got here, it's ok to start sending
				 * so load the first byte and tell the chip
				 * we want to send.
				 */
				ADB_SET_STATE_TIP();
				ADB_SET_SR_OUTPUT();
				ADB_SR() = adbOutputBuffer[adbSentChars + 1];
			}
		} else {
			ADB_TOGGLE_STATE_ACK_CUDA();
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("in 0x%02x ",
				    adbInputBuffer[adbInputBuffer[0]]);
#endif
		}
		break;

	case ADB_ACTION_OUT:
		i = ADB_SR();	/* reset SR-intr in IFR */
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("intr out 0x%02x ", i);
#endif

		adbSentChars++;
		if (ADB_INTR_IS_ON) {	/* ADB intr low during write */
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("intr was on ");
#endif
			ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
			ADB_SET_STATE_IDLE_CUDA();
			adbSentChars = 0;	/* must start all over */
			adbActionState = ADB_ACTION_IDLE;	/* new state */
			adbInputBuffer[0] = 0;
			adbWriteDelay = 1;	/* must retry when done with
						 * read */
			delay(ADB_DELAY);
			goto switch_start;	/* process next state right
						 * now */
			break;
		}
		if (adbOutputBuffer[0] == adbSentChars) {	/* check for done */
			if (0 == adb_cmd_result(adbOutputBuffer)) {	/* do we expect data
									 * back? */
				adbWaiting = 1;	/* signal waiting for return */
				adbWaitingCmd = adbOutputBuffer[2];	/* save waiting command */
			} else {	/* no talk, so done */
				/* set up stuff for adb_pass_up */
				memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.cmd = adbWaitingCmd;
				packet.unsol = 0;
				packet.ack_only = 1;
				adb_pass_up(&packet);

				/* reset "waiting" vars, just in case */
				adbWaitingCmd = 0;
				adbBuffer = NULL;
				adbCompRout = NULL;
				adbCompData = NULL;
			}

			adbWriteDelay = 0;	/* done writing */
			adbActionState = ADB_ACTION_IDLE;	/* signal bus is idle */
			ADB_SET_SR_INPUT();
			ADB_SET_STATE_IDLE_CUDA();
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("write done ");
#endif
		} else {
			ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* send next byte */
			ADB_TOGGLE_STATE_ACK_CUDA();	/* signal byte ready to
							 * shift */
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("toggle ");
#endif
		}
		break;

	case ADB_ACTION_NOTREADY:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: not yet initialized\n");
#endif
		break;

	default:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("intr: unknown ADB state\n");
#endif
		break;
	}

	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */

	splx(s);		/* restore */

	return (1);
}


int
send_adb_cuda(u_char *in, u_char *buffer, void *compRout, void *data, int
	command)
{
	int s, len;

#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("SEND\n");
#endif

	if (adbActionState == ADB_ACTION_NOTREADY)
		return 1;

	/* Don't interrupt while we are messing with the ADB */
	s = splhigh();

	if ((adbActionState == ADB_ACTION_IDLE) &&	/* ADB available? */
	    (ADB_INTR_IS_OFF)) {	/* and no incoming interrupt? */
	} else
		if (adbWriteDelay == 0)	/* it's busy, but is anything waiting? */
			adbWriteDelay = 1;	/* if no, then we'll "queue"
						 * it up */
		else {
			splx(s);
			return 1;	/* really busy! */
		}

#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("QUEUE\n");
#endif
	if ((long)in == (long)0) {	/* need to convert? */
		/*
		 * Don't need to use adb_cmd_extra here because this section
		 * will be called ONLY when it is an ADB command (no RTC or
		 * PRAM)
		 */
		if ((command & 0x0c) == 0x08)	/* copy addl data ONLY if
						 * doing a listen! */
			len = buffer[0];	/* length of additional data */
		else
			len = 0;/* no additional data */

		adbOutputBuffer[0] = 2 + len;	/* dev. type + command + addl.
						 * data */
		adbOutputBuffer[1] = 0x00;	/* mark as an ADB command */
		adbOutputBuffer[2] = (u_char)command;	/* load command */

		/* copy additional output data, if any */
		memcpy(adbOutputBuffer + 3, buffer + 1, len);
	} else
		/* if data ready, just copy over */
		memcpy(adbOutputBuffer, in, in[0] + 2);

	adbSentChars = 0;	/* nothing sent yet */
	adbBuffer = buffer;	/* save buffer to know where to save result */
	adbCompRout = compRout;	/* save completion routine pointer */
	adbCompData = data;	/* save completion routine data pointer */
	adbWaitingCmd = adbOutputBuffer[2];	/* save wait command */

	if (adbWriteDelay != 1) {	/* start command now? */
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("out start NOW");
#endif
		delay(ADB_DELAY);
		adbActionState = ADB_ACTION_OUT;	/* set next state */
		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
		ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* load byte for output */
		ADB_SET_STATE_ACKOFF_CUDA();
		ADB_SET_STATE_TIP();	/* tell ADB that we want to send */
	}
	adbWriteDelay = 1;	/* something in the write "queue" */

	splx(s);

	/* were VIA1 interrupts blocked? */
	if (PSLTOIPL(s) >= mac68k_machine.via1_ipl) {
		/* poll until byte done */
		while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
		    || (adbWaiting == 1))
			if (ADB_SR_INTR_IS_ON) { /* wait for "interrupt" */
				adb_intr_cuda(NULL); /* go process it */
				if (adb_polling)
					adb_soft_intr(NULL);
			}
	}

	return 0;
}


int
adb_intr_II(void *arg)
{
	struct adbCommand packet;
	int i, intr_on = 0;
	int send = 0;
	unsigned int s;

	s = splhigh();		/* can't be too careful - might be called */
				/* from a routine, NOT an interrupt */

	ADB_VIA_CLR_INTR();	/* clear interrupt */

	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */

	delay(ADB_DELAY);	/* yuck (don't remove) */

	(void)intr_dispatch(0x70); /* grab any serial interrupts */

	if (ADB_INTR_IS_ON)
		intr_on = 1;	/* save for later */
	
switch_start:
	switch (adbActionState) {
	case ADB_ACTION_POLLING:
		if (!intr_on) {
			if (adbOutQueueHasData) {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("POLL-doing-out-queue. ");
#endif
				ADB_SET_STATE_IDLE_II();
				delay(ADB_DELAY);

				/* copy over data */
				memcpy(adbOutputBuffer, adbOutQueue.outBuf,
				    adbOutQueue.outBuf[0] + 2);

				adbBuffer = adbOutQueue.saveBuf;	/* user data area */
				adbCompRout = adbOutQueue.compRout;	/* completion routine */
				adbCompData = adbOutQueue.data;	/* comp. rout. data */
				adbOutQueueHasData = 0;	/* currently processing
							 * "queue" entry */
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_OUT;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to send */
				break;
			} else {
#ifdef ADB_DEBUG
				if (adb_debug)
					printf_intr("pIDLE ");
#endif
				adbActionState = ADB_ACTION_IDLE;
			}
		} else {
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("pIN ");
#endif
			adbActionState = ADB_ACTION_IN;
		}
		delay(ADB_DELAY);
		(void)intr_dispatch(0x70); /* grab any serial interrupts */
		goto switch_start;
		break;
	case ADB_ACTION_IDLE:
		if (!intr_on) {
			i = ADB_SR();
			adbBusState = ADB_BUS_IDLE;
			adbActionState = ADB_ACTION_IDLE;
			ADB_SET_STATE_IDLE_II();
			break;
		}
		adbInputBuffer[0] = 1;
		adbInputBuffer[1] = ADB_SR();	/* get first byte */
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("idle 0x%02x ", adbInputBuffer[1]);
#endif
		ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
		adbActionState = ADB_ACTION_IN;	/* set next state */
		ADB_SET_STATE_EVEN();	/* set bus state to even */
		adbBusState = ADB_BUS_EVEN;
		break;

	case ADB_ACTION_IN:
		adbInputBuffer[++adbInputBuffer[0]] = ADB_SR();	/* get byte */
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("in 0x%02x ",
			    adbInputBuffer[adbInputBuffer[0]]);
#endif
		ADB_SET_SR_INPUT();	/* make sure SR is set to IN */

		if (intr_on) {	/* process last byte of packet */
			adbInputBuffer[0]--;	/* minus one */
			/*
			 * If intr_on was true, and it's the second byte, then
			 * the byte we just discarded is really valid, so
			 * adjust the count
			 */
			if (adbInputBuffer[0] == 2) {
				adbInputBuffer[0]++;
			}
				
#ifdef ADB_DEBUG
			if (adb_debug & 0x80) {
				printf_intr("done: ");
				print_single(adbInputBuffer);
			}
#endif

			adbLastDevice = ADB_CMDADDR(adbInputBuffer[1]);
			
			if (adbInputBuffer[0] == 1 && !adbWaiting) {	/* SRQ!!!*/
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr(" xSRQ! ");
#endif
				adb_guess_next_device();
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("try 0x%0x ",
					    adbLastDevice);
#endif
				adbOutputBuffer[0] = 1;
				adbOutputBuffer[1] = ADBTALK(adbLastDevice, 0);
			
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_POLLING;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to */
				break;
			}
				
			/* set up data for adb_pass_up */
			memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);

			if (!adbWaiting && (adbInputBuffer[0] != 0)) {
				packet.unsol = 1;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			} else {
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.unsol = 0;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			}

			adbWaiting = 0;
			adbInputBuffer[0] = 0;
			adbBuffer = NULL;
			adbCompRout = NULL;
			adbCompData = NULL;
			/*
			 * Since we are done, check whether there is any data
			 * waiting to do out. If so, start the sending the data.
			 */
			if (adbOutQueueHasData == 1) {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("XXX: DOING OUT QUEUE\n");
#endif
				/* copy over data */
				memcpy(adbOutputBuffer, adbOutQueue.outBuf,
				    adbOutQueue.outBuf[0] + 2);
				adbBuffer = adbOutQueue.saveBuf;	/* user data area */
				adbCompRout = adbOutQueue.compRout;	/* completion routine */
				adbCompData = adbOutQueue.data;	/* comp. rout. data */
				adbOutQueueHasData = 0;	/* currently processing
							 * "queue" entry */
				send = 1;
			} else {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("XXending ");
#endif
				adb_guess_next_device();
				adbOutputBuffer[0] = 1;
				adbOutputBuffer[1] = ((adbLastDevice & 0x0f) << 4) | 0x0c;
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_POLLING;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to */
				break;
			}
		}

		/*
		 * If send is true then something above determined that
		 * the message has ended and we need to start sending out
		 * a new message immediately. This could be because there
		 * is data waiting to go out or because an SRQ was seen.
		 */
		if (send) {
			adbSentChars = 0;	/* nothing sent yet */
			adbActionState = ADB_ACTION_OUT;	/* set next state */
			ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
			ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
			adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
			ADB_SET_STATE_CMD();	/* tell ADB that we want to
						 * send */
			break;
		}
		/* We only get this far if the message hasn't ended yet. */
		switch (adbBusState) {	/* set to next state */
		case ADB_BUS_EVEN:
			ADB_SET_STATE_ODD();	/* set state to odd */
			adbBusState = ADB_BUS_ODD;
			break;

		case ADB_BUS_ODD:
			ADB_SET_STATE_EVEN();	/* set state to even */
			adbBusState = ADB_BUS_EVEN;
			break;
		default:
			printf_intr("strange state!!!\n");	/* huh? */
			break;
		}
		break;

	case ADB_ACTION_OUT:
		i = ADB_SR();	/* clear interrupt */
		adbSentChars++;
		/*
		 * If the outgoing data was a TALK, we must
		 * switch to input mode to get the result.
		 */
		if ((adbOutputBuffer[1] & 0x0c) == 0x0c) {
			adbInputBuffer[0] = 1;
			adbInputBuffer[1] = i;
			adbActionState = ADB_ACTION_IN;
			ADB_SET_SR_INPUT();
			adbBusState = ADB_BUS_EVEN;
			ADB_SET_STATE_EVEN();
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("talk out 0x%02x ", i);
#endif
			/* we want something back */
			adbWaiting = 1;
			break;
		}
		/*
		 * If it's not a TALK, check whether all data has been sent.
		 * If so, call the completion routine and clean up. If not,
		 * advance to the next state.
		 */
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("non-talk out 0x%0x ", i);
#endif
		ADB_SET_SR_OUTPUT();
		if (adbOutputBuffer[0] == adbSentChars) {	/* check for done */
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("done \n");
#endif
			/* set up stuff for adb_pass_up */
			memcpy(packet.data, adbOutputBuffer, adbOutputBuffer[0] + 1);
			packet.saveBuf = adbBuffer;
			packet.compRout = adbCompRout;
			packet.compData = adbCompData;
			packet.cmd = adbWaitingCmd;
			packet.unsol = 0;
			packet.ack_only = 1;
			adb_pass_up(&packet);

			/* reset "waiting" vars, just in case */
			adbBuffer = NULL;
			adbCompRout = NULL;
			adbCompData = NULL;
			if (adbOutQueueHasData == 1) {
				/* copy over data */
				memcpy(adbOutputBuffer, adbOutQueue.outBuf,
				    adbOutQueue.outBuf[0] + 2);
				adbBuffer = adbOutQueue.saveBuf;	/* user data area */
				adbCompRout = adbOutQueue.compRout;	/* completion routine */
				adbCompData = adbOutQueue.data;	/* comp. rout. data */
				adbOutQueueHasData = 0;	/* currently processing
							 * "queue" entry */
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_OUT;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to
							 * send */
				break;
			} else {
				/* send talk to last device instead */
				adbOutputBuffer[0] = 1;
				adbOutputBuffer[1] =
				    ADBTALK(ADB_CMDADDR(adbOutputBuffer[1]), 0);
			
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_IDLE;	/* set next state */
				ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
				ADB_SR() = adbOutputBuffer[1];	/* load byte for output */
				adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */
				ADB_SET_STATE_CMD();	/* tell ADB that we want to */
				break;
			}
		}
		ADB_SR() = adbOutputBuffer[adbSentChars + 1];
		switch (adbBusState) {	/* advance to next state */
		case ADB_BUS_EVEN:
			ADB_SET_STATE_ODD();	/* set state to odd */
			adbBusState = ADB_BUS_ODD;
			break;

		case ADB_BUS_CMD:
		case ADB_BUS_ODD:
			ADB_SET_STATE_EVEN();	/* set state to even */
			adbBusState = ADB_BUS_EVEN;
			break;

		default:
#ifdef ADB_DEBUG
			if (adb_debug) {
				printf_intr("strange state!!! (0x%x)\n",
				    adbBusState);
			}
#endif
			break;
		}
		break;

	default:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: unknown ADB state (during intr)\n");
#endif
		break;
	}

	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */

	splx(s);		/* restore */

	return (1);

}


/*
 * send_adb version for II series machines
 */
int
send_adb_II(u_char *in, u_char *buffer, void *compRout, void *data, int command)
{
	int s, len;

	if (adbActionState == ADB_ACTION_NOTREADY)	/* return if ADB not
							 * available */
		return 1;

	/* Don't interrupt while we are messing with the ADB */
	s = splhigh();

	if (0 != adbOutQueueHasData) {	/* right now, "has data" means "full" */
		splx(s);	/* sorry, try again later */
		return 1;
	}
	if ((long)in == (long)0) {	/* need to convert? */
		/*
		 * Don't need to use adb_cmd_extra here because this section
		 * will be called ONLY when it is an ADB command (no RTC or
		 * PRAM), especially on II series!
		 */
		if ((command & 0x0c) == 0x08)	/* copy addl data ONLY if
						 * doing a listen! */
			len = buffer[0];	/* length of additional data */
		else
			len = 0;/* no additional data */

		adbOutQueue.outBuf[0] = 1 + len;	/* command + addl. data */
		adbOutQueue.outBuf[1] = (u_char)command;	/* load command */

		/* copy additional output data, if any */
		memcpy(adbOutQueue.outBuf + 2, buffer + 1, len);
	} else
		/* if data ready, just copy over */
		memcpy(adbOutQueue.outBuf, in, in[0] + 2);

	adbOutQueue.saveBuf = buffer;	/* save buffer to know where to save
					 * result */
	adbOutQueue.compRout = compRout;	/* save completion routine
						 * pointer */
	adbOutQueue.data = data;/* save completion routine data pointer */

	if ((adbActionState == ADB_ACTION_IDLE) &&	/* is ADB available? */
	    (ADB_INTR_IS_OFF)) {	/* and no incoming interrupts? */
		/* then start command now */
		memcpy(adbOutputBuffer, adbOutQueue.outBuf,
		    adbOutQueue.outBuf[0] + 2);		/* copy over data */

		adbBuffer = adbOutQueue.saveBuf;	/* pointer to user data
							 * area */
		adbCompRout = adbOutQueue.compRout;	/* pointer to the
							 * completion routine */
		adbCompData = adbOutQueue.data;	/* pointer to the completion
						 * routine data */

		adbSentChars = 0;	/* nothing sent yet */
		adbActionState = ADB_ACTION_OUT;	/* set next state */
		adbBusState = ADB_BUS_CMD;	/* set bus to cmd state */

		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */

		ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* load byte for output */
		ADB_SET_STATE_CMD();	/* tell ADB that we want to send */
		adbOutQueueHasData = 0;	/* currently processing "queue" entry */
	} else
		adbOutQueueHasData = 1;	/* something in the write "queue" */

	splx(s);

	/* were VIA1 interrupts blocked? */
	if (PSLTOIPL(s) >= mac68k_machine.via1_ipl) {
		/* poll until message done */
		while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
		    || (adbWaiting == 1))
			if (ADB_SR_INTR_IS_ON) { /* wait for "interrupt" */
				adb_intr_II(NULL); /* go process it */
				if (adb_polling)
					adb_soft_intr(NULL);
			}
	}

	return 0;
}


/*
 * This routine is called from the II series interrupt routine
 * to determine what the "next" device is that should be polled.
 */
int
adb_guess_next_device(void)
{
	int last, i, dummy;

	if (adbStarting) {
		/*
		 * Start polling EVERY device, since we can't be sure there is
		 * anything in the device table yet
		 */
		if (adbLastDevice < 1 || adbLastDevice > 15)
			adbLastDevice = 1;
		if (++adbLastDevice > 15)	/* point to next one */
			adbLastDevice = 1;
	} else {
		/* find the next device using the device table */
		if (adbLastDevice < 1 || adbLastDevice > 15)	/* let's be parinoid */
			adbLastDevice = 2;
		last = 1;	/* default index location */

		for (i = 1; i < 16; i++)	/* find index entry */
			if (ADBDevTable[i].currentAddr == adbLastDevice) {	/* look for device */
				last = i;	/* found it */
				break;
			}
		dummy = last;	/* index to start at */
		for (;;) {	/* find next device in index */
			if (++dummy > 15)	/* wrap around if needed */
				dummy = 1;
			if (dummy == last) {	/* didn't find any other
						 * device! This can happen if
						 * there are no devices on the
						 * bus */
				dummy = 1;
				break;
			}
			/* found the next device */
			if (ADBDevTable[dummy].devType != 0)
				break;
		}
		adbLastDevice = ADBDevTable[dummy].currentAddr;
	}
	return adbLastDevice;
}

#include "akbd.h"
#if NAKBD > 0
/*
 * Called when when an adb interrupt happens.
 * This routine simply transfers control over to the appropriate
 * code for the machine we are running on.
 */
int
adb_intr(void *arg)
{
	switch (adbHardware) {
	case ADB_HW_II:
		return adb_intr_II(arg);
	case ADB_HW_IISI:
		return adb_intr_IIsi(arg);
	case ADB_HW_CUDA:
		return adb_intr_cuda(arg);
	default:
		return (-1);
	}
}
#endif

/*
 * called when when an adb interrupt happens
 *
 * IIsi version of adb_intr
 *
 */
int
adb_intr_IIsi(void *arg)
{
	struct adbCommand packet;
	int i, ending;
	unsigned int s;

	s = splhigh();		/* can't be too careful - might be called */
				/* from a routine, NOT an interrupt */

	ADB_VIA_CLR_INTR();	/* clear interrupt */

	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */

switch_start:
	switch (adbActionState) {
	case ADB_ACTION_IDLE:
		delay(ADB_DELAY);	/* short delay is required before the
					 * first byte */

		ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
		ADB_SET_STATE_ACTIVE();	/* signal start of data frame */
		adbInputBuffer[1] = ADB_SR();	/* get byte */
		adbInputBuffer[0] = 1;
		adbActionState = ADB_ACTION_IN;	/* set next state */

		ADB_SET_STATE_ACKON();	/* start ACK to ADB chip */
		delay(ADB_DELAY);	/* delay */
		ADB_SET_STATE_ACKOFF();	/* end ACK to ADB chip */
		(void)intr_dispatch(0x70); /* grab any serial interrupts */
		break;

	case ADB_ACTION_IN:
		ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
		adbInputBuffer[++adbInputBuffer[0]] = ADB_SR();	/* get byte */
		if (ADB_INTR_IS_OFF)	/* check for end of frame */
			ending = 1;
		else
			ending = 0;

		ADB_SET_STATE_ACKON();	/* start ACK to ADB chip */
		delay(ADB_DELAY);	/* delay */
		ADB_SET_STATE_ACKOFF();	/* end ACK to ADB chip */
		(void)intr_dispatch(0x70); /* grab any serial interrupts */

		if (1 == ending) {	/* end of message? */
			ADB_SET_STATE_INACTIVE();	/* signal end of frame */
			/*
			 * This section _should_ handle all ADB and RTC/PRAM
			 * type commands, but there may be more...  Note:
			 * commands are always at [4], even for rtc/pram
			 * commands
			 */
			/* set up data for adb_pass_up */
			memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);
				
			if ((adbWaiting == 1) &&	/* are we waiting AND */
			    (adbInputBuffer[4] == adbWaitingCmd) &&	/* the cmd we sent AND */
			    ((adbInputBuffer[2] == 0x00) ||	/* it's from the ADB
								 * device OR */
				(adbInputBuffer[2] == 0x01))) {	/* it's from the
								 * PRAM/RTC device */

				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.unsol = 0;
				packet.ack_only = 0;
				adb_pass_up(&packet);

				adbWaitingCmd = 0;	/* reset "waiting" vars */
				adbWaiting = 0;
				adbBuffer = NULL;
				adbCompRout = NULL;
				adbCompData = NULL;
			} else {
				packet.unsol = 1;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			}

			adbActionState = ADB_ACTION_IDLE;
			adbInputBuffer[0] = 0;	/* reset length */

			if (adbWriteDelay == 1) {	/* were we waiting to
							 * write? */
				adbSentChars = 0;	/* nothing sent yet */
				adbActionState = ADB_ACTION_OUT;	/* set next state */

				delay(ADB_DELAY);	/* delay */
				(void)intr_dispatch(0x70); /* grab any serial interrupts */

				if (ADB_INTR_IS_ON) {	/* ADB intr low during
							 * write */
					ADB_SET_STATE_IDLE_IISI();	/* reset */
					ADB_SET_SR_INPUT();	/* make sure SR is set
								 * to IN */
					adbSentChars = 0;	/* must start all over */
					adbActionState = ADB_ACTION_IDLE;	/* new state */
					adbInputBuffer[0] = 0;
					/* may be able to take this out later */
					delay(ADB_DELAY);	/* delay */
					break;
				}
				ADB_SET_STATE_ACTIVE();	/* tell ADB that we want
							 * to send */
				ADB_SET_STATE_ACKOFF();	/* make sure */
				ADB_SET_SR_OUTPUT();	/* set shift register
							 * for OUT */
				ADB_SR() = adbOutputBuffer[adbSentChars + 1];
				ADB_SET_STATE_ACKON();	/* tell ADB byte ready
							 * to shift */
			}
		}
		break;

	case ADB_ACTION_OUT:
		i = ADB_SR();	/* reset SR-intr in IFR */
		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */

		ADB_SET_STATE_ACKOFF();	/* finish ACK */
		adbSentChars++;
		if (ADB_INTR_IS_ON) {	/* ADB intr low during write */
			ADB_SET_STATE_IDLE_IISI();	/* reset */
			ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
			adbSentChars = 0;	/* must start all over */
			adbActionState = ADB_ACTION_IDLE;	/* new state */
			adbInputBuffer[0] = 0;
			adbWriteDelay = 1;	/* must retry when done with
						 * read */
			delay(ADB_DELAY);	/* delay */
			(void)intr_dispatch(0x70); /* grab any serial interrupts */
			goto switch_start;	/* process next state right
						 * now */
			break;
		}
		delay(ADB_DELAY);	/* required delay */
		(void)intr_dispatch(0x70); /* grab any serial interrupts */

		if (adbOutputBuffer[0] == adbSentChars) {	/* check for done */
			if (0 == adb_cmd_result(adbOutputBuffer)) {	/* do we expect data
									 * back? */
				adbWaiting = 1;	/* signal waiting for return */
				adbWaitingCmd = adbOutputBuffer[2];	/* save waiting command */
			} else {/* no talk, so done */
				/* set up stuff for adb_pass_up */
				memcpy(packet.data, adbInputBuffer,
				    adbInputBuffer[0] + 1);
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.cmd = adbWaitingCmd;
				packet.unsol = 0;
				packet.ack_only = 1;
				adb_pass_up(&packet);

				/* reset "waiting" vars, just in case */
				adbWaitingCmd = 0;
				adbBuffer = NULL;
				adbCompRout = NULL;
				adbCompData = NULL;
			}

			adbWriteDelay = 0;	/* done writing */
			adbActionState = ADB_ACTION_IDLE;	/* signal bus is idle */
			ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
			ADB_SET_STATE_INACTIVE();	/* end of frame */
		} else {
			ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* send next byte */
			ADB_SET_STATE_ACKON();	/* signal byte ready to shift */
		}
		break;

	case ADB_ACTION_NOTREADY:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: not yet initialized\n");
#endif
		break;

	default:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("intr: unknown ADB state\n");
#endif
		break;
	}

	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */

	splx(s);		/* restore */

	return (1);
}


/*****************************************************************************
 * if the device is currently busy, and there is no data waiting to go out, then
 * the data is "queued" in the outgoing buffer. If we are already waiting, then
 * we return.
 * in: if (in == 0) then the command string is built from command and buffer
 *     if (in != 0) then in is used as the command string
 * buffer: additional data to be sent (used only if in == 0)
 *         this is also where return data is stored
 * compRout: the completion routine that is called when then return value
 *	     is received (if a return value is expected)
 * data: a data pointer that can be used by the completion routine
 * command: an ADB command to be sent (used only if in == 0)
 *
 */
int
send_adb_IIsi(u_char *in, u_char *buffer, void *compRout, void *data, int
	command)
{
	int s, len;

	if (adbActionState == ADB_ACTION_NOTREADY)
		return 1;

	/* Don't interrupt while we are messing with the ADB */
	s = splhigh();

	if ((adbActionState == ADB_ACTION_IDLE) &&	/* ADB available? */
	    (ADB_INTR_IS_OFF)) {/* and no incoming interrupt? */

	} else
		if (adbWriteDelay == 0)	/* it's busy, but is anything waiting? */
			adbWriteDelay = 1;	/* if no, then we'll "queue"
						 * it up */
		else {
			splx(s);
			return 1;	/* really busy! */
		}

	if ((long)in == (long)0) {	/* need to convert? */
		/*
		 * Don't need to use adb_cmd_extra here because this section
		 * will be called ONLY when it is an ADB command (no RTC or
		 * PRAM)
		 */
		if ((command & 0x0c) == 0x08)	/* copy addl data ONLY if
						 * doing a listen! */
			len = buffer[0];	/* length of additional data */
		else
			len = 0;/* no additional data */

		adbOutputBuffer[0] = 2 + len;	/* dev. type + command + addl.
						 * data */
		adbOutputBuffer[1] = 0x00;	/* mark as an ADB command */
		adbOutputBuffer[2] = (u_char)command;	/* load command */

		/* copy additional output data, if any */
		memcpy(adbOutputBuffer + 3, buffer + 1, len);
	} else
		/* if data ready, just copy over */
		memcpy(adbOutputBuffer, in, in[0] + 2);

	adbSentChars = 0;	/* nothing sent yet */
	adbBuffer = buffer;	/* save buffer to know where to save result */
	adbCompRout = compRout;	/* save completion routine pointer */
	adbCompData = data;	/* save completion routine data pointer */
	adbWaitingCmd = adbOutputBuffer[2];	/* save wait command */

	if (adbWriteDelay != 1) {	/* start command now? */
		adbActionState = ADB_ACTION_OUT;	/* set next state */

		ADB_SET_STATE_ACTIVE();	/* tell ADB that we want to send */
		ADB_SET_STATE_ACKOFF();	/* make sure */

		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */

		ADB_SR() = adbOutputBuffer[adbSentChars + 1];	/* load byte for output */

		ADB_SET_STATE_ACKON();	/* tell ADB byte ready to shift */
	}
	adbWriteDelay = 1;	/* something in the write "queue" */

	splx(s);

	/* were VIA1 interrupts blocked? */
	if (PSLTOIPL(s) >= mac68k_machine.via1_ipl) {
		/* poll until byte done */
		while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
		    || (adbWaiting == 1))
			if (ADB_SR_INTR_IS_ON) { /* wait for "interrupt" */
				adb_intr_IIsi(NULL); /* go process it */
				if (adb_polling)
					adb_soft_intr(NULL);
			}
	}

	return 0;
}

/*
 * adb_pass_up is called by the interrupt-time routines.
 * It takes the raw packet data that was received from the
 * device and puts it into the queue that the upper half
 * processes. It then signals for a soft ADB interrupt which
 * will eventually call the upper half routine (adb_soft_intr).
 *
 * If in->unsol is 0, then this is either the notification
 * that the packet was sent (on a LISTEN, for example), or the
 * response from the device (on a TALK). The completion routine
 * is called only if the user specified one.
 *
 * If in->unsol is 1, then this packet was unsolicited and
 * so we look up the device in the ADB device table to determine
 * what its default service routine is.
 *
 * If in->ack_only is 1, then we really only need to call
 * the completion routine, so don't do any other stuff.
 *
 * Note that in->data contains the packet header AND data,
 * while adbInbound[]->data contains ONLY data.
 *
 * Note: Called only at interrupt time. Assumes this.
 */
void
adb_pass_up(struct adbCommand *in)
{
	extern struct cfdriver adb_cd;
	struct adb_softc *sc;
	int start = 0, len = 0, cmd = 0;
	ADBDataBlock block;

	if (adbInCount >= ADB_QUEUE) {
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: ring buffer overflow\n");
#endif
		return;
	}

	if (in->ack_only) {
		len = in->data[0];
		cmd = in->cmd;
		start = 0;
	} else {
		switch (adbHardware) {
		case ADB_HW_IOP:
		case ADB_HW_II:
			cmd = in->data[1];
			if (in->data[0] < 2)
				len = 0;
			else
				len = in->data[0]-1;
			start = 1;
			break;

		case ADB_HW_IISI:
		case ADB_HW_CUDA:
			/* If it's unsolicited, accept only ADB data for now */
			if (in->unsol)
				if (0 != in->data[2])
					return;
			cmd = in->data[4];
			if (in->data[0] < 5)
				len = 0;
			else
				len = in->data[0]-4;
			start = 4;
			break;

		case ADB_HW_PB:
			cmd = in->data[1];
			if (in->data[0] < 2)
				len = 0;
			else
				len = in->data[0]-1;
			start = 1;
			break;

		case ADB_HW_UNKNOWN:
			return;
		}

		/* Make sure there is a valid device entry for this device */
		if (in->unsol) {
			/* ignore unsolicited data during adbreinit */
			if (adbStarting)
				return;
			/* get device's comp. routine and data area */
			if (-1 == get_adb_info(&block, ADB_CMDADDR(cmd)))
				return;
		}
	}

	/*
 	 * If this is an unsolicited packet, we need to fill in
 	 * some info so adb_soft_intr can process this packet
 	 * properly. If it's not unsolicited, then use what
 	 * the caller sent us.
 	 */
	if (in->unsol) {
		adbInbound[adbInTail].compRout = (void *)block.dbServiceRtPtr;
		adbInbound[adbInTail].compData = (void *)block.dbDataAreaAddr;
		adbInbound[adbInTail].saveBuf = (void *)adbInbound[adbInTail].data;
	} else {
		adbInbound[adbInTail].compRout = (void *)in->compRout;
		adbInbound[adbInTail].compData = (void *)in->compData;
		adbInbound[adbInTail].saveBuf = (void *)in->saveBuf;
	}

#ifdef ADB_DEBUG
	if (adb_debug && in->data[1] == 2)
		printf_intr("adb: caught error\n");
#endif

	/* copy the packet data over */
	/*
	 * TO DO: If the *_intr routines fed their incoming data
	 * directly into an adbCommand struct, which is passed to
	 * this routine, then we could eliminate this copy.
	 */
	memcpy(adbInbound[adbInTail].data + 1, in->data + start + 1, len);
	adbInbound[adbInTail].data[0] = len;
	adbInbound[adbInTail].cmd = cmd;

	adbInCount++;
	if (++adbInTail >= ADB_QUEUE)
		adbInTail = 0;

	/*
	 * If the debugger is running, call upper half manually.
	 * Otherwise, trigger a soft interrupt to handle the rest later.
	 */
	if (adb_cd.cd_ndevs != 0)
		sc = (struct adb_softc *)adb_cd.cd_devs[0];
	else
		sc = NULL;
	if (adb_polling || sc == NULL || sc->sc_softih == NULL)
		adb_soft_intr(NULL);
	else
		softintr_schedule(sc->sc_softih);
}


/*
 * Called to process the packets after they have been
 * placed in the incoming queue.
 *
 */
void
adb_soft_intr(void *arg)
{
	int s;
	int cmd = 0;
	u_char *buffer;
	void *comprout;
	u_char *compdata;

/*delay(2*ADB_DELAY);*/

	while (adbInCount) {
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("%x %x %x ",
			    adbInCount, adbInHead, adbInTail);
#endif
		/* get the data we need from the queue */
		buffer = adbInbound[adbInHead].saveBuf;
		comprout = adbInbound[adbInHead].compRout;
		compdata = adbInbound[adbInHead].compData;
		cmd = adbInbound[adbInHead].cmd;
	
		/* copy over data to data area if it's valid */
		/*
		 * Note that for unsol packets we don't want to copy the
	 	 * data anywhere, so buffer was already set to 0.
	 	 * For ack_only buffer was set to 0, so don't copy.
		 */
		if (buffer)
			memcpy(buffer, adbInbound[adbInHead].data,
			    adbInbound[adbInHead].data[0] + 1);

#ifdef ADB_DEBUG
			if (adb_debug & 0x80) {
				printf_intr("%p %p %p %x ",
				    buffer, comprout, compdata, (short)cmd);
				printf_intr("buf: ");
				print_single(adbInbound[adbInHead].data);
			}
#endif

		/*
		 * Remove the packet from the queue before calling
		 * the completion routine, so that the completion
		 * routine can reentrantly process the queue.  For
		 * example, this happens when polling is turned on
		 * by entering the debugger by keystroke.
		 */
		s = splhigh();
		adbInCount--;
		if (++adbInHead >= ADB_QUEUE)
			adbInHead = 0;
		splx(s);

		/* call default completion routine if it's valid */
		if (comprout) {
			(void)((int (*)(u_char *, u_char *, int))comprout)
			    (buffer, compdata, cmd);
		}
	}
}


/*
 * This is my version of the ADBOp routine. It mainly just calls the
 * hardware-specific routine.
 *
 *   data 	: pointer to data area to be used by compRout
 *   compRout	: completion routine
 *   buffer	: for LISTEN: points to data to send - MAX 8 data bytes,
 *		  byte 0 = # of bytes
 *		: for TALK: points to place to save return data
 *   command	: the adb command to send
 *   result	: 0 = success
 *		: -1 = could not complete
 */
int
adb_op(Ptr buffer, Ptr compRout, Ptr data, short command)
{
	int result;

	switch (adbHardware) {
	case ADB_HW_II:
		result = send_adb_II((u_char *)0, (u_char *)buffer,
		    (void *)compRout, (void *)data, (int)command);
		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_IISI:
		result = send_adb_IIsi((u_char *)0, (u_char *)buffer,
		    (void *)compRout, (void *)data, (int)command);
		/*
		 * I wish I knew why this delay is needed. It usually needs to
		 * be here when several commands are sent in close succession,
		 * especially early in device probes when doing collision
		 * detection. It must be some race condition. Sigh. - jpw
		 */
		delay(100);
		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_PB:
		result = pm_adb_op((u_char *)buffer, (void *)compRout,
		    (void *)data, (int)command);

		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_CUDA:
		result = send_adb_cuda((u_char *)0, (u_char *)buffer,
		    (void *)compRout, (void *)data, (int)command);
		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_IOP:
	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}


/*
 * adb_hw_setup
 * This routine sets up the possible machine specific hardware
 * config (mainly VIA settings) for the various models.
 */
void
adb_hw_setup(struct adb_softc *sc)
{
	volatile int i;
	u_char send_string[ADB_MAX_MSG_LENGTH];

	switch (adbHardware) {
	case ADB_HW_II:
		via1_register_irq(2, adb_intr_II, sc, sc->sc_dev.dv_xname);

		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN (II, IIsi) */
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware (II, IIsi) */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on (II, IIsi) */
		ADB_SET_STATE_IDLE_II();	/* set ADB bus state to idle */

		ADB_VIA_CLR_INTR();	/* clear interrupt */
		break;

	case ADB_HW_IISI:
		via1_register_irq(2, adb_intr_IIsi, sc, sc->sc_dev.dv_xname);
		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN (II, IIsi) */
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware (II, IIsi) */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on (II, IIsi) */
		ADB_SET_STATE_IDLE_IISI();	/* set ADB bus state to idle */

		/* get those pesky clock ticks we missed while booting */
		for (i = 0; i < 30; i++) {
			delay(ADB_DELAY);
			adb_hw_setup_IIsi(send_string);
#ifdef ADB_DEBUG
			if (adb_debug) {
				printf_intr("adb: cleanup: ");
				print_single(send_string);
			}
#endif
			delay(ADB_DELAY);
			if (ADB_INTR_IS_OFF)
				break;
		}
		break;

	case ADB_HW_PB:
		/*
		 * XXX - really PM_VIA_CLR_INTR - should we put it in
		 * pm_direct.h?
		 */
		pm_hw_setup(&sc->sc_dev);
		break;

	case ADB_HW_CUDA:
		via1_register_irq(2, adb_intr_cuda, sc, sc->sc_dev.dv_xname);
		via_reg(VIA1, vDirB) |= 0x30;	/* register B bits 4 and 5:
						 * outputs */
		via_reg(VIA1, vDirB) &= 0xf7;	/* register B bit 3: input */
		via_reg(VIA1, vACR) &= ~vSR_OUT;	/* make sure SR is set
							 * to IN */
		via_reg(VIA1, vACR) = (via_reg(VIA1, vACR) | 0x0c) & ~0x10;
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware */
		adbBusState = ADB_BUS_IDLE;	/* this var. used in II-series
						 * code only */
		via_reg(VIA1, vIER) = 0x84;	/* make sure VIA interrupts
						 * are on */
		ADB_SET_STATE_IDLE_CUDA();	/* set ADB bus state to idle */

		/* sort of a device reset */
		i = ADB_SR();	/* clear interrupt */
		ADB_VIA_INTR_DISABLE();	/* no interrupts while clearing */
		ADB_SET_STATE_IDLE_CUDA();	/* reset state to idle */
		delay(ADB_DELAY);
		ADB_SET_STATE_TIP();	/* signal start of frame */
		delay(ADB_DELAY);
		ADB_TOGGLE_STATE_ACK_CUDA();
		delay(ADB_DELAY);
		ADB_CLR_STATE_TIP();
		delay(ADB_DELAY);
		ADB_SET_STATE_IDLE_CUDA();	/* back to idle state */
		i = ADB_SR();	/* clear interrupt */
		ADB_VIA_INTR_ENABLE();	/* ints ok now */
		break;

	case ADB_HW_IOP:
	case ADB_HW_UNKNOWN:
	default:
		via_reg(VIA1, vIER) = 0x04;	/* turn interrupts off - TO
						 * DO: turn PB ints off? */
		break;
	}
}


/*
 * adb_hw_setup_IIsi
 * This is sort of a "read" routine that forces the adb hardware through a read cycle
 * if there is something waiting. This helps "clean up" any commands that may have gotten
 * stuck or stopped during the boot process.
 *
 */
void
adb_hw_setup_IIsi(u_char *buffer)
{
	int i;
	int dummy;
	int s;
	long my_time;
	int endofframe;

	delay(ADB_DELAY);

	i = 1;			/* skip over [0] */
	s = splhigh();		/* block ALL interrupts while we are working */
	ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */
	/* this is required, especially on faster machines */
	delay(ADB_DELAY);

	if (ADB_INTR_IS_ON) {
		ADB_SET_STATE_ACTIVE();	/* signal start of data frame */

		endofframe = 0;
		while (0 == endofframe) {
			/*
			 * Poll for ADB interrupt and watch for timeout.
			 * If time out, keep going in hopes of not hanging
			 * the ADB chip - I think
			 */
			my_time = ADB_DELAY * 5;
			while ((ADB_SR_INTR_IS_OFF) && (my_time-- > 0))
				dummy = via_reg(VIA1, vBufB);

			buffer[i++] = ADB_SR();	/* reset interrupt flag by
						 * reading vSR */
			/*
			 * Perhaps put in a check here that ignores all data
			 * after the first ADB_MAX_MSG_LENGTH bytes ???
			 */
			if (ADB_INTR_IS_OFF)	/* check for end of frame */
				endofframe = 1;

			ADB_SET_STATE_ACKON();	/* send ACK to ADB chip */
			delay(ADB_DELAY);	/* delay */
			ADB_SET_STATE_ACKOFF();	/* send ACK to ADB chip */
		}
		ADB_SET_STATE_INACTIVE();	/* signal end of frame and
						 * delay */

		/* probably don't need to delay this long */
		delay(ADB_DELAY);
	}
	buffer[0] = --i;	/* [0] is length of message */
	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */
	splx(s);		/* restore interrupts */
}



/*
 * adb_reinit sets up the adb stuff
 *
 */
void
adb_reinit(struct adb_softc *sc)
{
	u_char send_string[ADB_MAX_MSG_LENGTH];
	ADBDataBlock data;	/* temp. holder for getting device info */
	volatile int i, x;
	int s;
	int command;
	int result;
	int saveptr;		/* point to next free relocation address */
	int device;
	int nonewtimes;		/* times thru loop w/o any new devices */

	/* Make sure we are not interrupted while building the table. */
	/* ints must be on for PB & IOP (at least, for now) */
	if (adbHardware != ADB_HW_PB && adbHardware != ADB_HW_IOP)
		s = splhigh();
	else
		s = 0;		/* XXX shut the compiler up*/

	ADBNumDevices = 0;	/* no devices yet */

	/* Let intr routines know we are running reinit */
	adbStarting = 1;

	/*
	 * Initialize the ADB table.  For now, we'll always use the same table
	 * that is defined at the beginning of this file - no mallocs.
	 */
	for (i = 0; i < 16; i++) {
		ADBDevTable[i].devType = 0;
		ADBDevTable[i].origAddr = ADBDevTable[i].currentAddr = 0;
	}

	adb_hw_setup(sc);	/* init the VIA bits and hard reset ADB */

	delay(1000);

	/* send an ADB reset first */
	(void)adb_op_sync((Ptr)0, (short)0x00);
	delay(3000);

	/*
	 * Probe for ADB devices. Probe devices 1-15 quickly to determine
	 * which device addresses are in use and which are free. For each
	 * address that is in use, move the device at that address to a higher
	 * free address. Continue doing this at that address until no device
	 * responds at that address. Then move the last device that was moved
	 * back to the original address. Do this for the remaining addresses
	 * that we determined were in use.
	 *
	 * When finished, do this entire process over again with the updated
	 * list of in use addresses. Do this until no new devices have been
	 * found in 20 passes though the in use address list. (This probably
	 * seems long and complicated, but it's the best way to detect multiple
	 * devices at the same address - sometimes it takes a couple of tries
	 * before the collision is detected.)
	 */

	/* initial scan through the devices */
	for (i = 1; i < 16; i++) {
		command = ADBTALK(i, 3);
		result = adb_op_sync((Ptr)send_string, (short)command);

		if (result == 0 && send_string[0] != 0) {
			/* found a device */
			++ADBNumDevices;
			KASSERT(ADBNumDevices < 16);
			ADBDevTable[ADBNumDevices].devType =
				(int)(send_string[2]);
			ADBDevTable[ADBNumDevices].origAddr = i;
			ADBDevTable[ADBNumDevices].currentAddr = i;
			ADBDevTable[ADBNumDevices].DataAreaAddr = NULL;
			ADBDevTable[ADBNumDevices].ServiceRtPtr = NULL;
			pm_check_adb_devices(i);	/* tell pm driver device
							 * is here */
		}
	}

	/* find highest unused address */
	for (saveptr = 15; saveptr > 0; saveptr--)
		if (-1 == get_adb_info(&data, saveptr))
			break;

#ifdef ADB_DEBUG
	if (adb_debug & 0x80) {
		printf_intr("first free is: 0x%02x\n", saveptr);
		printf_intr("devices: %i\n", ADBNumDevices);
	}
#endif

	nonewtimes = 0;		/* no loops w/o new devices */
	while (saveptr > 0 && nonewtimes++ < 11) {
		for (i = 1;saveptr > 0 && i <= ADBNumDevices; i++) {
			device = ADBDevTable[i].currentAddr;
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("moving device 0x%02x to 0x%02x "
				    "(index 0x%02x)  ", device, saveptr, i);
#endif

			/* send TALK R3 to address */
			command = ADBTALK(device, 3);
			(void)adb_op_sync((Ptr)send_string, (short)command);

			/* move device to higher address */
			command = ADBLISTEN(device, 3);
			send_string[0] = 2;
			send_string[1] = (u_char)(saveptr | 0x60);
			send_string[2] = 0xfe;
			(void)adb_op_sync((Ptr)send_string, (short)command);
			delay(1000);

			/* send TALK R3 - anthing at new address? */
			command = ADBTALK(saveptr, 3);
			send_string[0] = 0;
			result = adb_op_sync((Ptr)send_string, (short)command);
			delay(1000);

			if (result != 0 || send_string[0] == 0) {
				/*
				 * maybe there's a communication breakdown;
				 * just in case, move it back from whence it
				 * came, and we'll try again later
				 */
				command = ADBLISTEN(saveptr, 3);
				send_string[0] = 2;
				send_string[1] = (u_char)(device | 0x60);
				send_string[2] = 0x00;
				(void)adb_op_sync((Ptr)send_string,
				    (short)command);
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("failed, continuing\n");
#endif
				delay(1000);
				continue;
			}

			/* send TALK R3 - anything at old address? */
			command = ADBTALK(device, 3);
			send_string[0] = 0;
			result = adb_op_sync((Ptr)send_string, (short)command);
			if (result == 0 && send_string[0] != 0) {
				/* new device found */
				/* update data for previously moved device */
				ADBDevTable[i].currentAddr = saveptr;
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("old device at index %i\n",i);
#endif
				/* add new device in table */
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("new device found\n");
#endif
				if (saveptr > ADBNumDevices) {
					++ADBNumDevices;
					KASSERT(ADBNumDevices < 16);
				}
				ADBDevTable[ADBNumDevices].devType =
					(int)(send_string[2]);
				ADBDevTable[ADBNumDevices].origAddr = device;
				ADBDevTable[ADBNumDevices].currentAddr = device;
				/* These will be set correctly in adbsys.c */
				/* Until then, unsol. data will be ignored. */
				ADBDevTable[ADBNumDevices].DataAreaAddr =
				    (long)0;
				ADBDevTable[ADBNumDevices].ServiceRtPtr =
				    (void *)0;
				/* find next unused address */
				for (x = saveptr; x > 0; x--) {
					if (-1 == get_adb_info(&data, x)) {
						saveptr = x;
						break;
					}
				}
				if (x == 0)
					saveptr = 0;
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("new free is 0x%02x\n",
					    saveptr);
#endif
				nonewtimes = 0;
				/* tell pm driver device is here */
				pm_check_adb_devices(device);
			} else {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("moving back...\n");
#endif
				/* move old device back */
				command = ADBLISTEN(saveptr, 3);
				send_string[0] = 2;
				send_string[1] = (u_char)(device | 0x60);
				send_string[2] = 0xfe;
				(void)adb_op_sync((Ptr)send_string,
				    (short)command);
				delay(1000);
			}
		}
	}

#ifdef ADB_DEBUG
	if (adb_debug) {
		for (i = 1; i <= ADBNumDevices; i++) {
			x = get_ind_adb_info(&data, i);
			if (x != -1)
				printf_intr("index 0x%x, addr 0x%x, type 0x%hx\n",
				    i, x, data.devType);
		}
	}
#endif

	/* enable the programmer's switch, if we have one */
	adb_prog_switch_enable();

#ifdef ADB_DEBUG
	if (adb_debug) {
		if (0 == ADBNumDevices)	/* tell user if no devices found */
			printf_intr("adb: no devices found\n");
	}
#endif

	adbStarting = 0;	/* not starting anymore */
#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("adb: adb_reinit complete\n");
#endif

	if (adbHardware == ADB_HW_CUDA) {
		timeout_set(&adb_cuda_timeout, (void *)adb_cuda_tickle, NULL);
		timeout_add(&adb_cuda_timeout, ADB_TICKLE_TICKS);
	}

	/* ints must be on for PB & IOP (at least, for now) */
	if (adbHardware != ADB_HW_PB && adbHardware != ADB_HW_IOP)
		splx(s);
}


/*
 * adb_cmd_result
 *
 * This routine lets the caller know whether the specified adb command string
 * should expect a returned result, such as a TALK command.
 *
 * returns: 0 if a result should be expected
 *          1 if a result should NOT be expected
 */
int
adb_cmd_result(u_char *in)
{
	switch (adbHardware) {
	case ADB_HW_IOP:
	case ADB_HW_II:
		/* was it an ADB talk command? */
		if ((in[1] & 0x0c) == 0x0c)
			return 0;
		return 1;

	case ADB_HW_IISI:
	case ADB_HW_CUDA:
		/* was it an ADB talk command? */
		if ((in[1] == 0x00) && ((in[2] & 0x0c) == 0x0c))
			return 0;
		/* was it an RTC/PRAM read date/time? */
		if ((in[1] == 0x01) && (in[2] == 0x03))
			return 0;
		return 1;

	case ADB_HW_PB:
		return 1;

	case ADB_HW_UNKNOWN:
	default:
		return 1;
	}
}

void
adb_setup_hw_type(void)
{
	/*
	 * Determine what type of ADB hardware we are running on.
	 */
	switch (mac68k_machine.machineid) {
	case MACH_MACC610:		/* Centris 610 */
	case MACH_MACC650:		/* Centris 650 */
	case MACH_MACII:		/* II */
	case MACH_MACIICI:		/* IIci */
	case MACH_MACIICX:		/* IIcx */
	case MACH_MACIIX:		/* IIx */
	case MACH_MACQ610:		/* Quadra 610 */
	case MACH_MACQ650:		/* Quadra 650 */
	case MACH_MACQ700:		/* Quadra 700 */
	case MACH_MACQ800:		/* Quadra 800 */
	case MACH_MACSE30:		/* SE/30 */
		adbHardware = ADB_HW_II;
		break;

	case MACH_MACCLASSICII:		/* Classic II */
	case MACH_MACLCII:		/* LC II, Performa 400/405/430 */
	case MACH_MACLCIII:		/* LC III, Performa 450 */
	case MACH_MACIISI:		/* IIsi */
	case MACH_MACIIVI:		/* IIvi */
	case MACH_MACIIVX:		/* IIvx */
	case MACH_MACP460:		/* Performa 460/465/467 */
	case MACH_MACP600:		/* Performa 600 */
		adbHardware = ADB_HW_IISI;
		break;

	case MACH_MACPB140:		/* PowerBook 140 */
	case MACH_MACPB145:		/* PowerBook 145 */
	case MACH_MACPB150:		/* PowerBook 150 */
	case MACH_MACPB160:		/* PowerBook 160 */
	case MACH_MACPB165:		/* PowerBook 165 */
	case MACH_MACPB165C:		/* PowerBook 165c */
	case MACH_MACPB170:		/* PowerBook 170 */
	case MACH_MACPB180:		/* PowerBook 180 */
	case MACH_MACPB180C:		/* PowerBook 180c */
	case MACH_MACPB190:		/* PowerBook 190 */
	case MACH_MACPB190CS:		/* PowerBook 190cs */
	case MACH_MACPB210:		/* PowerBook Duo 210 */
	case MACH_MACPB230:		/* PowerBook Duo 230 */
	case MACH_MACPB250:		/* PowerBook Duo 250 */
	case MACH_MACPB270:		/* PowerBook Duo 270 */
	case MACH_MACPB280:		/* PowerBook Duo 280 */
	case MACH_MACPB280C:		/* PowerBook Duo 280c */
	case MACH_MACPB500:		/* PowerBook 500 series */
		adbHardware = ADB_HW_PB;
		pm_setup_adb();
		break;

	case MACH_MACC660AV:		/* Centris 660AV */
	case MACH_MACCCLASSIC:		/* Color Classic */
	case MACH_MACCCLASSICII:	/* Color Classic II */
	case MACH_MACLC475:		/* LC 475, Performa 475/476 */
	case MACH_MACLC475_33:		/* Clock-chipped 47x */
	case MACH_MACLC520:		/* LC 520 */
	case MACH_MACLC575:		/* LC 575, Performa 575/577/578 */
	case MACH_MACP550:		/* LC 550, Performa 550 */
	case MACH_MACTV:		/* Macintosh TV */
	case MACH_MACP580:		/* Performa 580/588 */
	case MACH_MACQ605:		/* Quadra 605 */
	case MACH_MACQ605_33:		/* Clock-chipped Quadra 605 */
	case MACH_MACQ630:		/* LC 630, Performa 630, Quadra 630 */
	case MACH_MACQ840AV:		/* Quadra 840AV */
		adbHardware = ADB_HW_CUDA;
		break;

	case MACH_MACQ900:		/* Quadra 900 */
	case MACH_MACQ950:		/* Quadra 950 */
	case MACH_MACIIFX:		/* Mac IIfx */
		adbHardware = ADB_HW_IOP;
		break;

	default:
		adbHardware = ADB_HW_UNKNOWN;
		break;
	}

	/*
	 * Determine whether this machine has ADB based soft power.
	 */
	switch (mac68k_machine.machineid) {
	case MACH_MACCCLASSIC:		/* Color Classic */
	case MACH_MACCCLASSICII:	/* Color Classic II */
	case MACH_MACIISI:		/* IIsi */
	case MACH_MACIIVI:		/* IIvi */
	case MACH_MACIIVX:		/* IIvx */
	case MACH_MACLC520:		/* LC 520 */
	case MACH_MACLC575:		/* LC 575, Performa 575/577/578 */
	case MACH_MACP550:		/* LC 550, Performa 550 */
	case MACH_MACTV:		/* Macintosh TV */
	case MACH_MACP580:		/* Performa 580/588 */
	case MACH_MACP600:		/* Performa 600 */
	case MACH_MACQ630:		/* LC 630, Performa 630, Quadra 630 */
	case MACH_MACQ840AV:		/* Quadra 840AV */
		adbSoftPower = 1;
		break;
	}
}

/*
 * adb_op_sync
 *
 * This routine does exactly what the adb_op routine does, except that after
 * the adb_op is called, it waits until the return value is present before
 * returning.
 */
int
adb_op_sync(Ptr buffer, short command)
{
	int tmout;
	int result;
	volatile int flag = 0;

	result = adb_op(buffer, (void *)adb_op_comprout, (Ptr)&flag,
	    command);	/* send command */
	if (result == 0) {		/* send ok? */
		/*
		 * Total time to wait is calculated as follows:
		 *  - Tlt (stop to start time): 260 usec
		 *  - start bit: 100 usec
		 *  - up to 8 data bytes: 64 * 100 usec = 6400 usec
		 *  - stop bit (with SRQ): 140 usec
		 * Total: 6900 usec
		 *
		 * This is the total time allowed by the specification.  Any
		 * device that doesn't conform to this will fail to operate
		 * properly on some Apple systems.  In spite of this we
		 * double the time to wait; some Cuda-based apparently
		 * queues some commands and allows the main CPU to continue
		 * processing (radical concept, eh?).  To be safe, allow
		 * time for two complete ADB transactions to occur.
		 */
		for (tmout = 13800; !flag && tmout >= 10; tmout -= 10)
			delay(10);
		if (!flag && tmout > 0)
			delay(tmout);

		if (!flag)
			result = -2;
	}

	return result;
}

/*
 * adb_op_comprout
 *
 * This function is used by the adb_op_sync routine so it knows when the
 * function is done.
 */
void
adb_op_comprout(caddr_t buffer, caddr_t data_area, int adb_command)
{
	*(int *)data_area = 0x01;		/* update flag value */
}
	
int
count_adbs(void)
{
	int i;
	int found;

	found = 0;

	for (i = 1; i < 16; i++)
		if (0 != ADBDevTable[i].currentAddr)
			found++;

	return found;
}

int
get_ind_adb_info(ADBDataBlock *info, int index)
{
	if ((index < 1) || (index > 15))	/* check range 1-15 */
		return (-1);

#ifdef ADB_DEBUG
	if (adb_debug & 0x80)
		printf_intr("index 0x%x devType is: 0x%x\n", index,
		    ADBDevTable[index].devType);
#endif
	if (0 == ADBDevTable[index].devType)	/* make sure it's a valid entry */
		return (-1);

	info->devType = (unsigned char)(ADBDevTable[index].devType);
	info->origADBAddr = (unsigned char)(ADBDevTable[index].origAddr);
	info->dbServiceRtPtr = (Ptr)ADBDevTable[index].ServiceRtPtr;
	info->dbDataAreaAddr = (Ptr)ADBDevTable[index].DataAreaAddr;

	return (ADBDevTable[index].currentAddr);
}

int
get_adb_info(ADBDataBlock *info, int adbAddr)
{
	int i;

	if ((adbAddr < 1) || (adbAddr > 15))	/* check range 1-15 */
		return (-1);

	for (i = 1; i < 15; i++)
		if (ADBDevTable[i].currentAddr == adbAddr) {
			info->devType = (unsigned char)(ADBDevTable[i].devType);
			info->origADBAddr = (unsigned char)(ADBDevTable[i].origAddr);
			info->dbServiceRtPtr = (Ptr)ADBDevTable[i].ServiceRtPtr;
			info->dbDataAreaAddr = ADBDevTable[i].DataAreaAddr;
			return 0;	/* found */
		}

	return (-1);		/* not found */
}

int
set_adb_info(ADBSetInfoBlock *info, int adbAddr)
{
	int i;

	if ((adbAddr < 1) || (adbAddr > 15))	/* check range 1-15 */
		return (-1);

	for (i = 1; i < 15; i++)
		if (ADBDevTable[i].currentAddr == adbAddr) {
			ADBDevTable[i].ServiceRtPtr =
			    (void *)(info->siServiceRtPtr);
			ADBDevTable[i].DataAreaAddr = info->siDataAreaAddr;
			return 0;	/* found */
		}

	return (-1);		/* not found */
}

/* caller should really use machine-independant version: getPramTime */
/* this version does pseudo-adb access only */
int
adb_read_date_time(unsigned long *time)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;

	switch (adbHardware) {
	case ADB_HW_IOP:
	case ADB_HW_II:
		return -1;

	case ADB_HW_IISI:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x03;	/* read date/time */
		result = send_adb_IIsi((u_char *)output, (u_char *)output,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for result */
			;

		*time = (long)(*(long *)(output + 1));
		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_CUDA:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x03;	/* read date/time */
		result = send_adb_cuda((u_char *)output, (u_char *)output,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for result */
			;

		*time = (long)(*(long *)(output + 1));
		return 0;

	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}

/* caller should really use machine-independant version: setPramTime */
/* this version does pseudo-adb access only */
int
adb_set_date_time(unsigned long time)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;

	switch (adbHardware) {
	case ADB_HW_IOP:
	case ADB_HW_II:
		return -1;

	case ADB_HW_IISI:
		output[0] = 0x06;	/* 6 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x09;	/* set date/time */
		output[3] = (u_char)(time >> 24);
		output[4] = (u_char)(time >> 16);
		output[5] = (u_char)(time >> 8);
		output[6] = (u_char)(time);
		result = send_adb_IIsi((u_char *)output, (u_char *)0,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_CUDA:
		output[0] = 0x06;	/* 6 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x09;	/* set date/time */
		output[3] = (u_char)(time >> 24);
		output[4] = (u_char)(time >> 16);
		output[5] = (u_char)(time >> 8);
		output[6] = (u_char)(time);
		result = send_adb_cuda((u_char *)output, (u_char *)0,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}


int
adb_poweroff(void)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;

	if (!adbSoftPower)
		return -1;

	adb_polling = 1;

	switch (adbHardware) {
	case ADB_HW_IISI:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x0a;	/* set date/time */
		result = send_adb_IIsi((u_char *)output, (u_char *)0,
		    (void *)0, (void *)0, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		for (;;);		/* wait for power off */

		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_CUDA:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x0a;	/* set date/time */
		result = send_adb_cuda((u_char *)output, (u_char *)0,
		    (void *)0, (void *)0, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		for (;;);		/* wait for power off */

		return 0;

	case ADB_HW_IOP:		/* IOP models don't do ADB soft power */
	case ADB_HW_II:			/* II models don't do ADB soft power */
	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}

int
adb_prog_switch_enable(void)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;

	switch (adbHardware) {
	case ADB_HW_IISI:
		output[0] = 0x03;	/* 3 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x1c;	/* prog. switch control */
		output[3] = 0x01;	/* enable */
		result = send_adb_IIsi((u_char *)output, (u_char *)0,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_II:		/* II models don't do prog. switch */
	case ADB_HW_IOP:	/* IOP models don't do prog. switch */
	case ADB_HW_CUDA:	/* cuda doesn't do prog. switch TO DO: verify this */
	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}

#if 0
int
adb_prog_switch_disable(void)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;

	switch (adbHardware) {
	case ADB_HW_IISI:
		output[0] = 0x03;	/* 3 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x1c;	/* prog. switch control */
		output[3] = 0x01;	/* disable */
		result = send_adb_IIsi((u_char *)output, (u_char *)0,
			(void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_PB:
		return -1;

	case ADB_HW_II:		/* II models don't do prog. switch */
	case ADB_HW_IOP:	/* IOP models don't do prog. switch */
	case ADB_HW_CUDA:	/* cuda doesn't do prog. switch */
	case ADB_HW_UNKNOWN:
	default:
		return -1;
	}
}
#endif

/*
 * Function declarations.
 */
int	adbmatch(struct device *, void *, void *);
void	adbattach(struct device *, struct device *, void *);
void	adb_attach_deferred(void *);

/*
 * Driver definition.
 */

struct cfattach adb_ca = {
	sizeof(struct adb_softc), adbmatch, adbattach
};

int
adbmatch(struct device *parent, void *vcf, void *aux)
{
	static int adb_matched = 0;

	/* Allow only one instance. */
	if (adb_matched)
		return (0);

	adb_matched = 1;
	return (1);
}

void
adbattach(struct device *parent, struct device *self, void *aux)
{
	adb_setup_hw_type();	/* setup hardware type */
	printf(": %s\n", adbHardwareDescr[adbHardware]);
	startuphook_establish(adb_attach_deferred, self);
}

void
adb_attach_deferred(void *v)
{
	struct adb_softc *sc = v;
	ADBDataBlock adbdata;
	struct adb_attach_args aa_args;
	int totaladbs;
	int adbindex, adbaddr;

	printf("%s: ", sc->sc_dev.dv_xname);
	adb_polling = 1;
	adb_reinit(sc);

#ifdef ADB_DEBUG
	if (adb_debug)
		printf("adb: done with adb_reinit\n");
#endif

	totaladbs = count_adbs();

	printf("%d target%s\n", totaladbs, (totaladbs == 1) ? "" : "s");

	/* for each ADB device */
	for (adbindex = 1; adbindex <= totaladbs; adbindex++) {
		/* Get the ADB information */
		adbaddr = get_ind_adb_info(&adbdata, adbindex);

		aa_args.name = adb_device_name;
		aa_args.origaddr = (int)(adbdata.origADBAddr);
		aa_args.adbaddr = adbaddr;
		aa_args.handler_id = (int)(adbdata.devType);

		(void)config_found(&sc->sc_dev, &aa_args, adbprint);
	}

	sc->sc_softih = softintr_establish(IPL_SOFTTTY, adb_soft_intr, NULL);
	adb_polling = 0;
}
@


1.28
log
@Add a const char* as first member of struct adb_attach_args, so that we can
pass a struct confargs * on macppc for some specific children of the adb
node, and not confuse real adb device attachments.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.27 2009/03/15 20:40:25 miod Exp $	*/
@


1.27
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.26 2007/04/10 17:47:54 miod Exp $	*/
d2807 1
@


1.26
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.25 2007/03/13 20:56:54 miod Exp $	*/
d116 5
d306 1
a306 1
void	adb_soft_intr(void);
d314 1
a314 1
void	adb_reinit(struct device *);
d321 1
a321 1
void	adb_hw_setup(struct device *);
d402 1
a402 1
	/* from a routine, NOT an interrupt */
d616 1
a616 1
}				/* end adb_intr_cuda */
d704 1
a704 1
					adb_soft_intr();
d709 1
a709 1
}				/* send_adb_cuda */
d1147 1
a1147 1
					adb_soft_intr();
d1426 1
a1426 1
}				/* end adb_intr_IIsi */
d1520 1
a1520 1
					adb_soft_intr();
d1524 2
a1525 2
	 return 0;
}				/* send_adb_IIsi */
d1554 2
d1660 6
a1665 2
	if (adb_polling)
		adb_soft_intr();
d1667 1
a1667 1
		setsoftadb();
d1677 1
a1677 1
adb_soft_intr(void)
d1817 1
a1817 1
adb_hw_setup(struct device *self)
d1824 1
a1824 1
		via1_register_irq(2, adb_intr_II, self, self->dv_xname);
d1843 1
a1843 1
		via1_register_irq(2, adb_intr_IIsi, self, self->dv_xname);
d1878 1
a1878 1
		pm_hw_setup(self);
d1882 1
a1882 1
		via1_register_irq(2, adb_intr_cuda, self, self->dv_xname);
d1993 1
a1993 1
adb_reinit(struct device *self)
d2026 1
a2026 1
	adb_hw_setup(self);	/* init the VIA bits and hard reset ADB */
a2507 1

d2754 1
d2756 1
a2756 1
	sizeof(struct device), adbmatch, adbattach
d2783 1
a2783 1
	struct device *self = v;
d2789 1
a2789 1
	printf("%s: ", self->dv_xname);
d2791 1
a2791 1
	adb_reinit(self);
d2811 1
a2811 1
		(void)config_found(self, &aa_args, adbprint);
d2813 2
@


1.25
log
@Drop the second and third arguments to adb_op_sync, for they are not used;
while there, remove explicit global variable initializations to zero,
and appease the gods by removing the most ludicrous spurious casts.

No functional change (except for code shrinkage).
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.24 2007/03/04 15:35:09 miod Exp $	*/
d1536 1
a1536 1
 * what it's default service routine is.
@


1.24
log
@Limit knowledge of splfoo() return values, and use mac68k_machine.via1_ipl
instead of hardcoded 1; this gets us rid of unnecessary polls on machines
running with A/UX interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.23 2006/04/14 09:36:49 martin Exp $	*/
d249 9
a257 9
int	adbWaiting = 0;		/* waiting for return data from the device */
int	adbWriteDelay = 0;	/* working on (or waiting to do) a write */
int	adbOutQueueHasData = 0;	/* something in the queue waiting to go out */
int	adbSoftPower = 0;	/* machine supports soft power */

int	adbWaitingCmd = 0;	/* ADB command we are waiting for */
u_char	*adbBuffer = (long)0;	/* pointer to user data area */
void	*adbCompRout = (long)0;	/* pointer to the completion routine */
void	*adbCompData = (long)0;	/* pointer to the completion routine data */
d264 2
a265 2
int	adbSentChars = 0;	/* how many characters we have sent */
int	adbLastDevice = 0;	/* last ADB dev we heard from (II ONLY) */
d271 3
a273 3
volatile int	adbInCount = 0;		/* how many packets in in queue */
int	adbInHead = 0;			/* head of in queue */
int	adbInTail = 0;			/* tail of in queue */
d275 7
a281 7
int	adbOutCount = 0;		/* how many packets in out queue */
int	adbOutHead = 0;			/* head of out queue */
int	adbOutTail = 0;			/* tail of out queue */

int	tickle_count = 0;		/* how many tickles seen for this packet? */
int	tickle_serial = 0;		/* the last packet tickled */
int	adb_cuda_serial = 0;		/* the current packet */
a312 1
int	set_adb_info(ADBSetInfoBlock *, int);
d337 1
a337 1
	if (str == 0) {
d341 1
a341 1
	if (*str == 0) {
d467 3
a469 3
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
d567 3
a569 3
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
d716 1
a716 1
	/* from a routine, NOT an interrupt */
d865 3
a867 3
			adbBuffer = (long)0;
			adbCompRout = (long)0;
			adbCompData = (long)0;
d985 3
a987 3
			adbBuffer = (long)0;
			adbCompRout = (long)0;
			adbCompData = (long)0;
d1236 1
a1236 1
	/* from a routine, NOT an interrupt */
d1300 3
a1302 3
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
d1386 3
a1388 3
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
a1551 5
	/* temp for testing */
	/*u_char *buffer = 0;*/
	/*u_char *compdata = 0;*/
	/*u_char *comprout = 0;*/

a1656 2

	return;
d1670 3
a1672 3
	u_char *buffer = 0;
	u_char *comprout = 0;
	u_char *compdata = 0;
d2020 1
a2020 1
	(void)adb_op_sync((Ptr)0, (Ptr)0, (Ptr)0, (short)0x00);
d2043 1
a2043 2
		result = adb_op_sync((Ptr)send_string, (Ptr)0,
		    (Ptr)0, (short)command);
d2053 2
a2054 3
			ADBDevTable[ADBNumDevices].DataAreaAddr =
			    (long)0;
			ADBDevTable[ADBNumDevices].ServiceRtPtr = (void *)0;
d2084 1
a2084 2
			(void)adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
d2091 1
a2091 2
			(void)adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
d2097 1
a2097 2
			result = adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
d2110 2
a2111 2
				(void)adb_op_sync((Ptr)send_string, (Ptr)0,
				    (Ptr)0, (short)command);
d2123 1
a2123 2
			result = adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
d2178 2
a2179 2
				(void)adb_op_sync((Ptr)send_string, (Ptr)0,
				    (Ptr)0, (short)command);
a2371 4
 *
 * NOTE: The user specified compRout is ignored, since this routine specifies
 * it's own to adb_op, which is why you really called this in the first place
 * anyway.
d2374 1
a2374 1
adb_op_sync(Ptr buffer, Ptr compRout, Ptr data, short command)
d2420 1
a2420 1
	*(u_short *)data_area = 0x01;		/* update flag value */
@


1.23
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.22 2006/02/12 17:03:25 miod Exp $	*/
d692 2
a693 1
	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked? */
d702 1
d1135 2
a1136 1
	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked? */
d1145 1
d1508 2
a1509 1
	if (0x0100 <= (s & 0x0700))	/* were VIA1 interrupts blocked? */
d1518 1
@


1.22
log
@Remove packets from the queue before calling their completion routine, as
done on macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.21 2006/01/22 15:25:30 miod Exp $	*/
d70 1
a70 1
 
d74 1
a74 1
 *    by having them save the incoming and outgoing data directly 
d78 1
a78 1
 *  - (Related to above) Use the header part of adbCommand to 
d85 4
a88 4
 *    because of some timing issues. Because I have been unable to 
 *    determine the exact cause of this bug, I used the timeout function 
 *    to check for and recover from this condition. If anyone finds 
 *    the actual cause of this bug, the calls to timeout and the 
d216 1
a216 1
 * Eventually used for two separate queues, the queue between 
d983 1
a983 1
			/* reset "waiting" vars, just in case */ 
d1517 1
a1517 1
/* 
d1525 1
a1525 1
 * that the packet was sent (on a LISTEN, for example), or the 
d1631 1
a1631 1
	if (adb_debug && in->data[1] == 2) 
d1638 1
a1638 1
	 * directly into an adbCommand struct, which is passed to 
d2033 1
a2033 1
	 * 
d2270 1
a2270 1
void 
d2392 1
a2392 1
	result = adb_op(buffer, (void *)adb_op_comprout, (Ptr)&flag, 
d2429 1
a2429 1
void 
d2435 1
a2435 1
int 
d2450 1
a2450 1
int 
d2472 1
a2472 1
int 
d2492 1
a2492 1
int 
d2514 1
a2514 1
int 
d2567 1
a2567 1
int 
d2625 1
a2625 1
int 
d2674 1
a2674 1
int 
d2710 1
a2710 1
int 
@


1.21
log
@Print adb subsystem name early in attachment, and pass the proper device
name to interrupt counter registration, rather than "adb".
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.20 2006/01/20 00:10:09 miod Exp $	*/
d1709 7
a1715 6
		/* call default completion routine if it's valid */
		if (comprout) {
			(void)((int (*)(u_char *, u_char *, int))comprout)
			    (buffer, compdata, cmd);
		}

d1722 5
a1727 1
	return;
@


1.20
log
@Remove unused stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.19 2006/01/18 23:21:16 miod Exp $	*/
d234 1
a234 1
const char	*adbHardwareDescr[MAX_ADB_HW + 1] = {
d240 1
d286 1
a286 1
void	pm_hw_setup(void);
d309 1
a309 1
void	adb_reinit(void);
d317 1
a317 1
void	adb_hw_setup(void);
d1196 2
a1197 1

a1208 2
		break;

a1210 5
		break;

	case ADB_HW_PB:		/* Should not come through here. */
		break;

d1213 2
a1214 4
		break;

	case ADB_HW_UNKNOWN:
		break;
a1215 2

	return (-1);
d1217 1
a1217 1

d1566 1
d1789 1
d1803 1
a1803 1
adb_hw_setup(void)
d1810 1
a1810 1
		via1_register_irq(2, adb_intr_II, NULL, NULL);
d1829 1
a1829 1
		via1_register_irq(2, adb_intr_IIsi, NULL, NULL);
d1864 1
a1864 1
		pm_hw_setup();
d1868 1
a1868 1
		via1_register_irq(2, adb_intr_cuda, NULL, NULL);
d1899 1
a1903 1
		return;
d1970 1
a1970 3

	return;
}				/* adb_hw_setup_IIsi */
d1979 1
a1979 1
adb_reinit(void)
a1990 3
	via1_register_irq(2, adb_intr, NULL, "adb");
	adb_setup_hw_type();	/* setup hardware type */

d1993 1
a1993 1
	if (adbHardware != ADB_HW_PB)
d2012 1
a2012 1
	adb_hw_setup();		/* init the VIA bits and hard reset ADB */
d2221 1
a2221 1
	if (adbHardware != ADB_HW_PB)
a2222 2

	return;
d2239 1
a2267 4
	long response;

	response = mac68k_machine.machineid;

d2271 1
a2271 1
	switch (response) {
a2283 4
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using II series hardware support\n");
#endif
a2294 4
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using IIsi series hardware support\n");
#endif
d2299 1
d2306 2
a2307 9
		adbHardware = ADB_HW_PB;
		pm_setup_adb();
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using PowerBook 100-series hardware support\n");
#endif
		break;

	case MACH_MACPB150:		/* PowerBook 150 */
a2314 2
	case MACH_MACPB190:		/* PowerBook 190 */
	case MACH_MACPB190CS:		/* PowerBook 190cs */
a2316 4
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using PowerBook Duo-series and PowerBook 500-series hardware support\n");
#endif
d2334 6
a2339 4
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: using Cuda series hardware support\n");
#endif
a2343 6
#ifdef ADB_DEBUG
		if (adb_debug) {
			printf_intr("adb: hardware type unknown for this machine\n");
			printf_intr("adb: ADB support is disabled\n");
		}
#endif
d2350 1
a2350 1
	switch (response) {
d2517 1
d2570 1
d2661 1
d2696 1
d2704 1
d2732 1
d2739 1
d2771 2
a2772 1
	printf("\n");
d2785 1
a2785 2
	printf("%s", self->dv_xname);

d2787 1
a2787 3
	adb_reinit();

	printf(": %s", adbHardwareDescr[adbHardware]);
d2796 1
a2796 1
	printf(", %d target%s\n", totaladbs, (totaladbs == 1) ? "" : "s");
@


1.19
log
@Factorize akbd and ams drivers between mac68k and macppc; while there, start
moving out common adb code as well, and merge adb_direct.c into adb.c to
simplify external header files.

No functional change; more cleanups to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.18 2006/01/13 19:36:43 miod Exp $	*/
a250 1
int	adbNextEnd = 0;		/* the next incoming bute is the last (II) */
a256 2
long	adbFakeInts = 0;	/* keeps track of fake ADB interrupts for
				 * timeouts (II) */
a257 4
int	adbSendTalk = 0;	/* the intr routine is sending the talk, not
				 * the user (II) */
int	adbPolling = 0;		/* we are polling for service request */
int	adbPollCmd = 0;		/* the last poll command we sent */
a264 2
int	adbLastDevIndex = 0;	/* last ADB dev loc in dev table (II ONLY) */
int	adbLastCommand = 0;	/* the last ADB command we sent (II) */
a318 1
int	adb_cmd_extra(u_char *);
a2276 40


/*
 * adb_cmd_extra
 *
 * This routine lets the caller know whether the specified adb command string
 * may have extra data appended to the end of it, such as a LISTEN command.
 *
 * returns: 0 if extra data is allowed
 *          1 if extra data is NOT allowed
 */
int
adb_cmd_extra(u_char *in)
{
	switch (adbHardware) {
	case ADB_HW_II:
		if ((in[1] & 0x0c) == 0x08)	/* was it a listen command? */
			return 0;
		return 1;

	case ADB_HW_IISI:
	case ADB_HW_CUDA:
		/*
		 * TO DO: support needs to be added to recognize RTC and PRAM
		 * commands
		 */
		if ((in[2] & 0x0c) == 0x08)	/* was it a listen command? */
			return 0;
		/* add others later */
		return 1;

	case ADB_HW_PB:
		return 1;

	case ADB_HW_UNKNOWN:
	default:
		return 1;
	}
}

@


1.18
log
@Remove the Mac Rom Glue code completely. With the ADB ``direct'' code being
used by default, and since all PRAM accesses are either directly fiddling
with VIA registers or through ADB commands, the MRG code has no reason to
stay. This means the kernel is now not running unknown PROM code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.17 2006/01/08 17:45:29 miod Exp $	*/
d3 31
d65 27
d99 1
d104 1
d106 1
d109 68
d178 9
a186 1
 * Function declarations.
d188 2
a189 4
int	adbmatch(struct device *, void *, void *);
void	adbattach(struct device *, struct device *, void *);
int	adbprint(void *, const char *);
void	adb_attach_deferred(void *);
d191 2
a192 1
extern void	adb_jadbproc(void);
d195 1
a195 1
 * Global variables.
d197 7
a203 4
int	adb_polling = 0;	/* Are we polling?  (Debugger mode) */
#ifdef ADB_DEBUG
int	adb_debug = 0;		/* Output debugging messages */
#endif /* ADB_DEBUG */
d205 9
a213 3
extern struct	mac68k_machine_S mac68k_machine;
extern int	adbHardware;
extern char	*adbHardwareDescr[];
d216 3
a218 1
 * Driver definition.
d220 9
a228 2
struct cfattach adb_ca = {
	sizeof(struct device), adbmatch, adbattach
d230 10
a239 2
struct cfdriver adb_cd = {
	NULL, "adb", DV_DULL
d242 102
a343 2
int
adbmatch(struct device *parent, void *vcf, void *aux)
d345 1
a345 1
	static int adb_matched = 0;
d347 16
a362 6
	/* Allow only one instance. */
	if (adb_matched)
		return (0);

	adb_matched = 1;
	return (1);
d364 1
d367 1
a367 1
adbattach(struct device *parent, struct device *self, void *aux)
d369 21
a389 2
	printf("\n");
	startuphook_establish(adb_attach_deferred, self);
d392 9
a400 2
void
adb_attach_deferred(void *v)
d402 220
a621 5
	struct device *self = v;
	ADBDataBlock adbdata;
	struct adb_attach_args aa_args;
	int totaladbs;
	int adbindex, adbaddr;
a622 2
	printf("%s", self->dv_xname);
	adb_polling = 1;
d624 5
a628 2
	ADBReInit();
	printf(": %s", adbHardwareDescr[adbHardware]);
d632 1
a632 1
		printf("adb: done with ADBReInit\n");
d635 2
a636 1
	totaladbs = CountADBs();
d638 2
a639 1
	printf(", %d target%s\n", totaladbs, (totaladbs == 1) ? "" : "s");
d641 10
a650 4
	/* for each ADB device */
	for (adbindex = 1; adbindex <= totaladbs; adbindex++) {
		/* Get the ADB information */
		adbaddr = GetIndADB(&adbdata, adbindex);
d652 32
a683 3
		aa_args.origaddr = (int)(adbdata.origADBAddr);
		aa_args.adbaddr = adbaddr;
		aa_args.handler_id = (int)(adbdata.devType);
d685 11
a695 1
		(void)config_found(self, &aa_args, adbprint);
d697 16
a712 2
	adb_polling = 0;
}
d716 1
a716 1
adbprint(void *args, const char *name)
d718 93
a810 2
	struct adb_attach_args *aa_args = (struct adb_attach_args *)args;
	int rv = UNCONF;
d812 17
a828 2
	if (name) {	/* no configured device matched */
		rv = UNSUPP; /* most ADB device types are unsupported */
d830 22
a851 23
		/* print out what kind of ADB device we have found */
		switch(aa_args->origaddr) {
#ifdef ADBVERBOSE
		case ADBADDR_SECURE:
			printf("security dongle (%d)",
			    aa_args->handler_id);
			break;
#endif
		case ADBADDR_MAP:
			printf("mapped device (%d)",
			    aa_args->handler_id);
			rv = UNCONF;
			break;
		case ADBADDR_REL:
			printf("relative positioning device (%d)",
			    aa_args->handler_id);
			rv = UNCONF;
			break;
#ifdef ADBVERBOSE
		case ADBADDR_ABS:
			switch (aa_args->handler_id) {
			case ADB_ARTPAD:
				printf("WACOM ArtPad II");
d853 55
a907 3
			default:
				printf("absolute positioning device (%d)",
				    aa_args->handler_id);
d910 55
d966 46
a1011 8
		case ADBADDR_DATATX:
			printf("data transfer device (modem?) (%d)",
			    aa_args->handler_id);
			break;
		case ADBADDR_MISC:
			switch (aa_args->handler_id) {
			case ADB_POWERKEY:
				printf("Sophisticated Circuits PowerKey");
d1013 12
a1024 3
			default:
				printf("misc. device (remote control?) (%d)",
				    aa_args->handler_id);
d1027 12
d1040 1
d1042 6
a1047 2
			printf("unknown type %d device, (handler %d)",
			    aa_args->origaddr, aa_args->handler_id);
a1048 1
#endif /* ADBVERBOSE */
d1050 8
a1057 1
		printf(" at %s", name);
d1060 5
a1064 1
	printf(" addr %d", aa_args->adbaddr);
a1065 1
	return (rv);
d1070 1391
d2478 1
a2478 1
	result = ADBOp(buffer, (void *)adb_op_comprout, (Ptr)&flag, 
a2508 1

d2519 377
@


1.17
log
@Drop native MacOS support from the adb direct code, and skip callback
wrappers used to convert between MacOS pascal calling convention and the
C calling convention, unless option MRG_ADB. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.16 2006/01/08 17:25:05 miod Exp $	*/
a111 29
#ifdef MRG_ADB
	if (!mrg_romready()) {
		printf(": no ROM ADB driver in this kernel for this machine\n");
		return;
	}

#ifdef ADB_DEBUG
	if (adb_debug)
		printf("adb: call mrg_initadbintr\n");
#endif

	mrg_initadbintr();	/* Mac ROM Glue okay to do ROM intr */
#ifdef ADB_DEBUG
	if (adb_debug)
		printf("adb: returned from mrg_initadbintr\n");
#endif

	/* ADBReInit pre/post-processing */
	JADBProc = adb_jadbproc;

	/* Initialize ADB */
#ifdef ADB_DEBUG
	if (adb_debug)
		printf("adb: calling ADBAlternateInit.\n");
#endif

	printf(": mrg");
	ADBAlternateInit();
#else
a119 2
#endif /* MRG_ADB */

a263 7
#ifdef MRG_ADB
void 
adb_op_comprout(void)
{
	asm("movw	#1,a2@@			| update flag value");
}
#else
a268 1
#endif
@


1.16
log
@Display unhandled adb devices as "whatever at adb0 addr X" like all buses do;
while there, make the detailed descriptions dependent on ADBVERBOSE (enabled
in GENERIC) instead of DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.15 2006/01/04 20:39:04 miod Exp $	*/
d295 1
d301 7
@


1.15
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a179 1
		printf("%s addr %d: ", name, aa_args->adbaddr);
d181 1
a181 1
#ifdef DIAGNOSTIC
d197 1
a197 1
#ifdef DIAGNOSTIC
d225 2
a226 2
			printf("unknown type device, (handler %d)",
			    aa_args->handler_id);
d228 1
a228 1
#endif /* DIAGNOSTIC */
d230 4
a233 2
	} else		/* a device matched and was configured */
		printf(" addr %d: ", aa_args->adbaddr);
@


1.14
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: adb.c,v 1.13 2003/09/23 16:51:11 millert Exp $	*/
/*	$NetBSD: adb.c,v 1.13 1996/12/16 16:17:02 scottr Exp $	*/
d4 1
a4 1
/*-
d14 1
a14 1
e*    notice, this list of conditions and the following disclaimer in the
d37 1
a37 1
#include <sys/ioctl.h>
a38 1
#include <sys/poll.h>
a41 2
#include <sys/time.h>
#include <sys/timeout.h>
d44 1
a44 1
#include <machine/keyboard.h>
d46 1
a46 3
#include <arch/mac68k/mac68k/macrom.h>
#include <arch/mac68k/dev/adbvar.h>
#include <arch/mac68k/dev/itevar.h>
d51 6
a56 2
static int	adbmatch(struct device *, void *, void *);
static void	adbattach(struct device *, struct device *, void *);
d61 8
a68 1
int     adb_polling = 0;	/* Are we polling?  (Debugger mode) */
d71 1
a71 1
 * Local variables.
a72 25

/* External keyboard translation matrix */
extern unsigned char keyboard[128][3];

/* Event queue definitions */
#if !defined(ADB_MAX_EVENTS)
#define ADB_MAX_EVENTS 200	/* Maximum events to be kept in queue */
				/* maybe should be higher for slower macs? */
#endif				/* !defined(ADB_MAX_EVENTS) */
static adb_event_t adb_evq[ADB_MAX_EVENTS];	/* ADB event queue */
static int adb_evq_tail = 0;	/* event queue tail */
static int adb_evq_len = 0;	/* event queue length */

/* ADB device state information */
static int adb_isopen = 0;	/* Are we queuing events for adb_read? */
static struct selinfo adb_selinfo;	/* select() info */
static struct proc *adb_ioproc = NULL;	/* process to wakeup */

/* Key repeat parameters */
static int adb_rptdelay = 20;	/* ticks before auto-repeat */
static int adb_rptinterval = 6;	/* ticks between auto-repeat */
static int adb_repeating = -1;	/* key that is auto-repeating */
static adb_event_t adb_rptevent;/* event to auto-repeat */

/* Driver definition.  -- This should probably be a bus...  */
a75 1

d80 8
a87 1
struct timeout repeat_timeout;
d89 2
a90 7
static int
adbmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	return 1;
d93 2
a94 4
static void
adbattach(parent, dev, aux)
	struct device *parent, *dev;
	void   *aux;
d96 2
a97 1
	printf(" (ADB event device)\n");
d100 2
a101 3
void 
adb_enqevent(event)
    adb_event_t *event;
d103 5
a107 1
	int     s;
d109 2
a110 2
	if (adb_evq_tail < 0 || adb_evq_tail >= ADB_MAX_EVENTS)
		panic("adb: event queue tail is out of bounds");
d112 5
a116 4
	if (adb_evq_len < 0 || adb_evq_len > ADB_MAX_EVENTS)
		panic("adb: event queue len is out of bounds");

	s = splhigh();
d118 4
a121 11
	if (adb_evq_len == ADB_MAX_EVENTS) {
		splx(s);
		return;		/* Oh, well... */
	}
	adb_evq[(adb_evq_len + adb_evq_tail) % ADB_MAX_EVENTS] =
	    *event;
	adb_evq_len++;

	selwakeup(&adb_selinfo);
	if (adb_ioproc)
		psignal(adb_ioproc, SIGIO);
d123 5
a127 2
	splx(s);
}
d129 2
a130 11
void 
adb_handoff(event)
    adb_event_t *event;
{
	if (adb_isopen && !adb_polling) {
		adb_enqevent(event);
	} else {
		if (event->def_addr == 2)
			ite_intr(event);
	}
}
d132 5
d138 5
a142 5
void 
adb_autorepeat(keyp)
    void *keyp;
{
	int     key = (int) keyp;
d144 4
a147 13
	adb_rptevent.bytes[0] |= 0x80;
	microtime(&adb_rptevent.timestamp);
	adb_handoff(&adb_rptevent);	/* do key up */

	adb_rptevent.bytes[0] &= 0x7f;
	microtime(&adb_rptevent.timestamp);
	adb_handoff(&adb_rptevent);	/* do key down */

	if (adb_repeating == key) {
		timeout_set(&repeat_timeout, adb_autorepeat, keyp);
		timeout_add(&repeat_timeout, adb_rptinterval);
	}
}
d149 1
d151 1
a151 5
void 
adb_dokeyupdown(event)
    adb_event_t *event;
{
	int     adb_key;
d153 1
a153 23
	if (event->def_addr == 2) {
		adb_key = event->u.k.key & 0x7f;
		if (!(event->u.k.key & 0x80) &&
		    keyboard[event->u.k.key & 0x7f][0] != 0) {
			/* ignore shift & control */
			if (adb_repeating != -1) {
				timeout_del(&repeat_timeout);
			}
			adb_rptevent = *event;
			adb_repeating = adb_key;
			timeout_set(&repeat_timeout, adb_autorepeat,
			    (caddr_t)adb_key);
			timeout_add(&repeat_timeout, adb_rptdelay);
		} else {
			if (adb_repeating != -1) {
				adb_repeating = -1;
				timeout_del(&repeat_timeout);
			}
			adb_rptevent = *event;
		}
	}
	adb_handoff(event);
}
d155 4
a158 1
static int adb_ms_buttons = 0;
d160 3
a162 6
void 
adb_keymaybemouse(event)
    adb_event_t *event;
{
	static int optionkey_down = 0;
	adb_event_t new_event;
d164 1
a164 78
	if (event->u.k.key == ADBK_KEYDOWN(ADBK_OPTION)) {
		optionkey_down = 1;
	} else if (event->u.k.key == ADBK_KEYUP(ADBK_OPTION)) {
		/* key up */
		optionkey_down = 0;
		if (adb_ms_buttons & 0xfe) {
			adb_ms_buttons &= 1;
			new_event.def_addr = ADBADDR_MS;
			new_event.u.m.buttons = adb_ms_buttons;
			new_event.u.m.dx = new_event.u.m.dy = 0;
			microtime(&new_event.timestamp);
			adb_dokeyupdown(&new_event);
		}
	} else if (optionkey_down) {
		if (event->u.k.key == ADBK_KEYDOWN(ADBK_LEFT)) {
			adb_ms_buttons |= 2;	/* middle down */
			new_event.def_addr = ADBADDR_MS;
			new_event.u.m.buttons = adb_ms_buttons;
			new_event.u.m.dx = new_event.u.m.dy = 0;
			microtime(&new_event.timestamp);
			adb_dokeyupdown(&new_event);
		} else if (event->u.k.key == ADBK_KEYUP(ADBK_LEFT)) {
			adb_ms_buttons &= ~2;	/* middle up */
			new_event.def_addr = ADBADDR_MS;
			new_event.u.m.buttons = adb_ms_buttons;
			new_event.u.m.dx = new_event.u.m.dy = 0;
			microtime(&new_event.timestamp);
			adb_dokeyupdown(&new_event);
		} else if (event->u.k.key == ADBK_KEYDOWN(ADBK_RIGHT)) {
			adb_ms_buttons |= 4;	/* right down */
			new_event.def_addr = ADBADDR_MS;
			new_event.u.m.buttons = adb_ms_buttons;
			new_event.u.m.dx = new_event.u.m.dy = 0;
			microtime(&new_event.timestamp);
			adb_dokeyupdown(&new_event);
		} else if (event->u.k.key == ADBK_KEYUP(ADBK_RIGHT)) {
			adb_ms_buttons &= ~4;	/* right up */
			new_event.def_addr = ADBADDR_MS;
			new_event.u.m.buttons = adb_ms_buttons;
			new_event.u.m.dx = new_event.u.m.dy = 0;
			microtime(&new_event.timestamp);
			adb_dokeyupdown(&new_event);
		} else if (ADBK_MODIFIER(event->u.k.key)) {
		/* ctrl, shift, cmd */
			adb_dokeyupdown(event);
		} else if (!(event->u.k.key & 0x80)) {
		/* key down */
			new_event = *event;

			/* send option-down */
			new_event.u.k.key = ADBK_KEYDOWN(ADBK_OPTION);
			new_event.bytes[0] = new_event.u.k.key;
			microtime(&new_event.timestamp);
			adb_dokeyupdown(&new_event);

			/* send key-down */
			new_event.u.k.key = event->bytes[0];
			new_event.bytes[0] = new_event.u.k.key;
			microtime(&new_event.timestamp);
			adb_dokeyupdown(&new_event);

			/* send key-up */
			new_event.u.k.key =
				ADBK_KEYUP(ADBK_KEYVAL(event->bytes[0]));
			microtime(&new_event.timestamp);
			new_event.bytes[0] = new_event.u.k.key;
			adb_dokeyupdown(&new_event);

			/* send option-up */
			new_event.u.k.key = ADBK_KEYUP(ADBK_OPTION);
			new_event.bytes[0] = new_event.u.k.key;
			microtime(&new_event.timestamp);
			adb_dokeyupdown(&new_event);
		} else {
			/* option-keyup -- do nothing. */
		}
	} else {
		adb_dokeyupdown(event);
d166 1
d170 2
a171 3
void 
adb_processevent(event)
    adb_event_t *event;
d173 2
a174 2
	adb_event_t new_event;
	int i, button_bit, max_byte, mask, buttons;
d176 2
a177 2
	new_event = *event;
	buttons = 0;
d179 45
a223 26
	switch (event->def_addr) {
	case ADBADDR_KBD:
		new_event.u.k.key = event->bytes[0];
		new_event.bytes[1] = 0xff;
		adb_keymaybemouse(&new_event);
		if (event->bytes[1] != 0xff) {
			new_event.u.k.key = event->bytes[1];
			new_event.bytes[0] = event->bytes[1];
			new_event.bytes[1] = 0xff;
			adb_keymaybemouse(&new_event);
		}
		break;
	case ADBADDR_MS:
		/*
		 * This should handle both plain ol' Apple mice and mice
		 * that claim to support the Extended Apple Mouse Protocol.
		 */
		max_byte = event->byte_count;
		button_bit = 1;
		switch (event->hand_id) {
		case ADBMS_USPEED:
			/* MicroSpeed mouse */
			if (max_byte == 4)
				buttons = (~event->bytes[2]) & 0xff;
			else
				buttons = (event->bytes[0] & 0x80) ? 0 : 1;
d226 2
a227 18
			/* Classic Mouse Protocol (up to 2 buttons) */
			for (i = 0; i < 2; i++, button_bit <<= 1)
				/* 0 when button down */
				if (!(event->bytes[i] & 0x80))
					buttons |= button_bit;
				else
					buttons &= ~button_bit;
			/* Extended Protocol (up to 6 more buttons) */
			for (mask = 0x80; i < max_byte;
			     i += (mask == 0x80), button_bit <<= 1) {
				/* 0 when button down */
				if (!(event->bytes[i] & mask))
					buttons |= button_bit;
				else
					buttons &= ~button_bit;
				mask = ((mask >> 4) & 0xf)
					| ((mask & 0xf) << 4);
			}
d229 1
d231 2
a232 101
		new_event.u.m.buttons = adb_ms_buttons | buttons;
		new_event.u.m.dx = ((signed int) (event->bytes[1] & 0x3f)) -
					((event->bytes[1] & 0x40) ? 64 : 0);
		new_event.u.m.dy = ((signed int) (event->bytes[0] & 0x3f)) -
					((event->bytes[0] & 0x40) ? 64 : 0);
		adb_dokeyupdown(&new_event);
		break;
	default:		/* God only knows. */
		adb_dokeyupdown(event);
	}
}


int 
adbopen(dev, flag, mode, p)
    dev_t dev;
    int flag, mode;
    struct proc *p;
{
	register int unit;
	int error = 0;
	int s;

	unit = minor(dev);
	if (unit != 0)
		return (ENXIO);

	s = splhigh();
	if (adb_isopen) {
		splx(s);
		return (EBUSY);
	}
	splx(s);
	adb_evq_tail = 0;
	adb_evq_len = 0;
	adb_isopen = 1;
	adb_ioproc = p;

	return (error);
}


int 
adbclose(dev, flag, mode, p)
    dev_t dev;
    int flag, mode;
    struct proc *p;
{
	adb_isopen = 0;
	adb_ioproc = NULL;
	return (0);
}


int 
adbread(dev, uio, flag)
    dev_t dev;
    struct uio *uio;
    int flag;
{
	int s, error;
	int willfit;
	int total;
	int firstmove;
	int moremove;

	if (uio->uio_resid < sizeof(adb_event_t))
		return (EMSGSIZE);	/* close enough. */

	s = splhigh();
	if (adb_evq_len == 0) {
		splx(s);
		return (0);
	}
	willfit = howmany(uio->uio_resid, sizeof(adb_event_t));
	total = (adb_evq_len < willfit) ? adb_evq_len : willfit;

	firstmove = (adb_evq_tail + total > ADB_MAX_EVENTS)
	    ? (ADB_MAX_EVENTS - adb_evq_tail) : total;

	error = uiomove((caddr_t) & adb_evq[adb_evq_tail],
	    firstmove * sizeof(adb_event_t), uio);
	if (error) {
		splx(s);
		return (error);
	}
	moremove = total - firstmove;

	if (moremove > 0) {
		error = uiomove((caddr_t) & adb_evq[0],
		    moremove * sizeof(adb_event_t), uio);
		if (error) {
			splx(s);
			return (error);
		}
	}
	adb_evq_tail = (adb_evq_tail + total) % ADB_MAX_EVENTS;
	adb_evq_len -= total;
	splx(s);
	return (0);
}
d234 1
a234 8

int 
adbwrite(dev, uio, flag)
    dev_t dev;
    struct uio *uio;
    int flag;
{
	return 0;
d238 13
a250 7
int 
adbioctl(dev, cmd, data, flag, p)
    dev_t dev;
    int cmd;
    caddr_t data;
    int flag;
    struct proc *p;
d252 27
a278 21
	switch (cmd) {
	case ADBIOC_DEVSINFO: {
		adb_devinfo_t *di;
		ADBDataBlock adbdata;
		int totaldevs;
		int adbaddr;
		int i;

		di = (void *) data;

		/* Initialize to no devices */
		for (i = 0; i < 16; i++)
			di->dev[i].addr = -1;

		totaldevs = CountADBs();
		for (i = 1; i <= totaldevs; i++) {
			adbaddr = GetIndADB(&adbdata, i);
			di->dev[adbaddr].addr = adbaddr;
			di->dev[adbaddr].default_addr = adbdata.origADBAddr;
			di->dev[adbaddr].handler_id = adbdata.devType;
			}
d280 2
a281 2
		/* Must call ADB Manager to get devices now */
		break;
d284 1
a284 32
	case ADBIOC_GETREPEAT:{
		adb_rptinfo_t *ri;

		ri = (void *) data;
		ri->delay_ticks = adb_rptdelay;
		ri->interval_ticks = adb_rptinterval;
		break;
	}

	case ADBIOC_SETREPEAT:{
		adb_rptinfo_t *ri;

		ri = (void *) data;
		adb_rptdelay = ri->delay_ticks;
		adb_rptinterval = ri->interval_ticks;
		break;
	}

	case ADBIOC_RESET:
		adb_init();
		break;

	case ADBIOC_LISTENCMD:{
		adb_listencmd_t *lc;

		lc = (void *) data;
	}

	default:
		return (EINVAL);
	}
	return (0);
d288 8
a295 5
int 
adbpoll(dev, events, p)
    dev_t dev;
    int events;
    struct proc *p;
d297 1
a297 15
	int revents = 0;

	if (events & (POLLIN | POLLRDNORM)) {
		/* succeed if there is something to read */
		if (adb_evq_len > 0)
			revents |= events & (POLLIN | POLLRDNORM);
		else
			selrecord(p, &adb_selinfo);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		/* always fails => never blocks */
		revents |= events & (POLLOUT | POLLWRNORM);
	}

	return (revents);
@


1.13
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.12 2002/03/14 01:26:35 millert Exp $	*/
d38 1
a38 1
#include <sys/select.h>
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.11 2001/08/15 22:06:37 miod Exp $	*/
d39 1
d544 1
a544 1
adbselect(dev, rw, p)
d546 1
a546 1
    int rw;
d549 3
a551 2
	switch (rw) {
	case FREAD:
d554 7
a560 7
			return (1);
		selrecord(p, &adb_selinfo);
		break;

	case FWRITE:
		return (1);	/* always fails => never blocks */
		break;
d563 1
a563 1
	return (0);
@


1.11
log
@New timeouts, tested by beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.10 1998/03/03 04:29:44 ryker Exp $	*/
d55 2
a56 2
static int	adbmatch __P((struct device *, void *, void *));
static void	adbattach __P((struct device *, struct device *, void *));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.11 2001/08/15 22:06:37 miod Exp $	*/
d55 2
a56 2
static int	adbmatch(struct device *, void *, void *);
static void	adbattach(struct device *, struct device *, void *);
@


1.10
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.9 1997/04/06 02:59:57 briggs Exp $	*/
d43 1
d99 2
d175 2
a176 1
		timeout(adb_autorepeat, keyp, adb_rptinterval);
d193 1
a193 2
				untimeout(adb_autorepeat,
				    (void *) adb_rptevent.u.k.key);
d197 3
a199 2
			timeout(adb_autorepeat,
			    (void *) adb_key, adb_rptdelay);
d203 1
a203 2
				untimeout(adb_autorepeat,
				    (void *) adb_rptevent.u.k.key);
@


1.10.10.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.10 1998/03/03 04:29:44 ryker Exp $	*/
a42 1
#include <sys/timeout.h>
a97 2
struct timeout repeat_timeout;

d172 1
a172 2
		timeout_set(&repeat_timeout, adb_autorepeat, keyp);
		timeout_add(&repeat_timeout, adb_rptinterval);
d189 2
a190 1
				timeout_del(&repeat_timeout);
d194 2
a195 3
			timeout_set(&repeat_timeout, adb_autorepeat,
			    (caddr_t)adb_key);
			timeout_add(&repeat_timeout, adb_rptdelay);
d199 2
a200 1
				timeout_del(&repeat_timeout);
@


1.10.10.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 2
a56 2
static int	adbmatch(struct device *, void *, void *);
static void	adbattach(struct device *, struct device *, void *);
@


1.10.10.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a38 1
#include <sys/poll.h>
d543 1
a543 1
adbpoll(dev, events, p)
d545 1
a545 1
    int events;
d548 2
a549 3
	int revents = 0;

	if (events & (POLLIN | POLLRDNORM)) {
d552 7
a558 7
			revents |= events & (POLLIN | POLLRDNORM);
		else
			selrecord(p, &adb_selinfo);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		/* always fails => never blocks */
		revents |= events & (POLLOUT | POLLWRNORM);
d561 1
a561 1
	return (revents);
@


1.9
log
@Eradicate #include <sys/*> from machine/*.h.  Prompting from Gene.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.8 1997/03/12 13:36:56 briggs Exp $	*/
d208 1
a208 1
static  adb_ms_buttons = 0;
@


1.8
log
@Remove some more warnings left over from NetBSD's new config.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.7 1997/02/23 06:04:52 briggs Exp $	*/
d37 1
d42 1
@


1.7
log
@Integrate code from John P. Wittkoski <jpw@@netwizards.net> and
Takashi Hamada <hamada@@next.etron.kanazawa-it.ac.jp>.  This code
interfaces directly to the hardware to support the ADB on many
macs.  It is enabled by "options HWDIRECT" in the configuration
file.  At some point, this should probably become the default method
as interfacing to the ADB through the ROMs has been painful and sometimes
problematic.

This code should have functioning ADB support for:
	II series (II, SE/30, IIx, IIcx)
	IIsi series (IIsi, IIci, IIvx, IIvi)
	LC II, LC III
	Performa 400, 405, 430, 460, 465, 467, 600
	Classic II, Color Classic, Color Classic II
	PB 5XX series
	Duo series
	PB 140,145,145b,160,(160c?),165,165c,170,180,180c
	Quadra 700,900,950
There is an off-chance that it will work on:
	PB 150, PB 190
	Quadra/Centris 605,610,630,650,660AV,800,840AV
	LC 475,550,575,630
	Performa 475,476,575,577,578,630
Note that functioning ADB support does not mean that everything else
will work.  I obviously do not own all of the above machines (does
anyone?  ;-)...  Any reports are welcome.

Many thanks to John Wittkoski and Takashi Hamada!
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.6 1997/01/24 01:35:27 briggs Exp $	*/
d52 1
a52 1
static int	adbmatch __P((struct device *, struct cfdata *, void *));
d97 1
a97 1
adbmatch(parent, cf, aux)
d99 1
a99 1
	struct cfdata *cf;
@


1.6
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.5 1996/05/26 18:35:14 briggs Exp $	*/
a41 1
#include <machine/adbsys.h>
d45 3
a47 3
#include "adbvar.h"
#include "itevar.h"
#include "../mac68k/macrom.h"
@


1.5
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: adb.c,v 1.9 1996/05/05 16:21:20 briggs Exp $	*/
d53 1
a53 1
static int	adbmatch __P((struct device *, void *, void *));
d98 4
a101 3
adbmatch(pdp, match, auxp)
	struct device	*pdp;
	void	*match, *auxp;
@


1.4
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.3
log
@update from netbsd (without losing local changes)
@
text
@d1 1
a1 1
/*	$NetBSD: adb.c,v 1.5 1995/11/01 04:40:21 briggs Exp $	*/
d38 1
d42 1
d46 1
d52 2
a53 1
static void	adbattach __P((struct device *parent, struct device *dev, void *aux));
d87 4
a90 1
extern int matchbyname();
d92 2
a93 3
/* Driver definition. */
struct cfdriver adbcd = {
	NULL, "adb", matchbyname, adbattach, DV_DULL, sizeof(struct device),
d96 8
d325 5
a329 5
		/* Classic Mouse Protocol (up to 2 buttons) */
		for (i = 0; i < 2; i++, button_bit <<= 1)
			/* 0 when button down */
			if (!(event->bytes[i] & 0x80))
				buttons |= button_bit;
d331 22
a352 10
				buttons &= ~button_bit;
		/* Extended Protocol (up to 6 more buttons) */
		for (mask = 0x80; i < max_byte;
		     i += (mask == 0x80), button_bit <<= 1) {
			/* 0 when button down */
			if (!(event->bytes[i] & mask))
				buttons |= button_bit;
			else
				buttons &= ~button_bit;
			mask = ((mask >> 4) & 0xf) | ((mask & 0xf) << 4);
@


1.2
log
@from NetBSD
@
text
@d1 1
a1 1
/*	$NetBSD: adb.c,v 1.4.2.1 1995/11/02 04:35:05 briggs Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: adb.c,v 1.4 1995/09/03 20:59:53 briggs Exp $	*/
d287 1
a287 1
	int i, button_bit, max_byte, mask;
d290 1
d315 1
a315 1
				adb_ms_buttons |= button_bit;
d317 1
a317 1
				adb_ms_buttons &= ~button_bit;
d323 1
a323 1
				adb_ms_buttons |= button_bit;
d325 1
a325 1
				adb_ms_buttons &= ~button_bit;
d328 1
a328 1
		new_event.u.m.buttons = adb_ms_buttons;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

