head	1.15;
access;
symbols
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.24
	OPENBSD_5_0:1.14.0.22
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.20
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.18
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.14
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.16
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.12
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.10
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.20
	OPENBSD_2_9_BASE:1.8
	NIKLAS_UNDEAD:1.8.0.18
	OPENBSD_2_8:1.8.0.16
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.14
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.12
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.15
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.14;

1.14
date	2006.06.24.13.23.27;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.23.23.28.58;	author martin;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.26.21.21.24;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.22.20.15.55;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.04.08.52.46;	author niklas;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	97.06.18.02.59.29;	author denny;	state Exp;
branches
	1.8.12.1;
next	1.7;

1.7
date	97.04.25.03.29.14;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	97.04.23.00.28.22;	author gene;	state Exp;
branches;
next	1.5;

1.5
date	97.04.13.14.14.52;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	97.04.10.02.35.03;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	97.03.29.23.26.50;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	97.03.14.14.11.36;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	97.03.12.13.20.33;	author briggs;	state Exp;
branches;
next	;

1.8.12.1
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*    $OpenBSD: if_snvar.h,v 1.14 2006/06/24 13:23:27 miod Exp $      */
/*    $NetBSD: if_snvar.h,v 1.8 1997/04/25 03:40:09 briggs Exp $      */

/*
 * Copyright (c) 1991   Algorithmics Ltd (http://www.algor.co.uk)
 * You may use, copy, and modify this program so long as you retain the
 * copyright line.
 */

/*
 * if_snvar.h -- National Semiconductor DP8393X (SONIC) NetBSD/mac68k vars
 */

/*
 * Vendor types
 */
#define	SN_VENDOR_UNKNOWN	0xff	/* Unknown */
#define	SN_VENDOR_APPLE		0x00	/* Apple Computer/compatible */
#define	SN_VENDOR_DAYNA		0x01	/* Dayna/Kinetics EtherPort */
#define	SN_VENDOR_APPLE16	0x02	/* Apple Twisted Pair Ether NB */
#define	SN_VENDOR_ASANTELC	0x09	/* Asante Macintosh LC Ethernet */

/*
 * Memory access macros. Since we handle SONIC in 16 bit mode (PB5X0)
 * and 32 bit mode (everything else) using a single GENERIC kernel
 * binary, all structures have to be accessed using macros which can
 * adjust the offsets appropriately.
 */
#define	SWO(m, a, o, x)	(m ? (*(u_int32_t *)((u_int32_t *)(a) + (o)) = (x)) : \
			     (*(u_int16_t *)((u_int16_t *)(a) + (o)) = (x)))
#define	SRO(m, a, o)	(m ? (*(u_int32_t *)((u_int32_t *)(a) + (o)) & 0xffff) : \
			     (*(u_int16_t *)((u_int16_t *)(a) + (o)) & 0xffff))

/*
 * Register access macros. We use bus_space_* to talk to the Sonic
 * registers. A mapping table is used in case a particular configuration
 * hooked the regs up at non-word offsets.
 */
#define	NIC_GET(sc, reg)	(bus_space_read_2((sc)->sc_regt,	\
					(sc)->sc_regh,			\
					((sc)->sc_reg_map[(reg)])))
#define	NIC_PUT(sc, reg, val)	(bus_space_write_2((sc)->sc_regt,	\
					(sc)->sc_regh,			\
					((sc)->sc_reg_map[reg]),	\
					(val)))

#define	SN_REGSIZE	SN_NREGS*4

/* mac68k does not have any write buffers to flush... */
#define	wbflush()

/*
 * buffer sizes in 32 bit mode
 * 1 TXpkt is 4 hdr words + (3 * FRAGMAX) + 1 link word == 23 words == 92 bytes
 *
 * 1 RxPkt is 7 words == 28 bytes
 * 1 Rda   is 4 words == 16 bytes
 *
 * The CDA is 17 words == 68 bytes
 *
 * total space in page 0 = NTDA * 92 + NRRA * 16 + NRDA * 28 + 68
 */

#define NRBA    32		/* # receive buffers < NRRA */
#define RBAMASK (NRBA-1)
#define NTDA    16		/* # transmit descriptors */
#define NRRA    64		/* # receive resource descriptors */
#define RRAMASK (NRRA-1)	/* the reason why NRRA must be power of two */

#define FCSSIZE 4		/* size of FCS appended to packets */

/*
 * maximum receive packet size plus 2 byte pad to make each
 * one aligned. 4 byte slop (required for eobc)
 */
#define RBASIZE(sc)	(sizeof(struct ether_header) + ETHERMTU + FCSSIZE + \
			 ((sc)->bitmode ? 6 : 2))

/*
 * transmit buffer area
 */
#define TXBSIZE	1536	/* 6*2^8 -- the same size as the 8390 TXBUF */

#define	SN_NPAGES	(2 + NRBA + (NTDA/2))

typedef struct mtd {
	void		*mtd_txp;
	paddr_t		mtd_vtxp;
	caddr_t		mtd_buf;
	paddr_t		mtd_vbuf;
	struct mbuf	*mtd_mbuf;
} mtd_t;

/*
 * The sn_softc for Mac68k if_sn.
 */
typedef struct sn_softc {
	struct device	sc_dev;
	struct arpcom	sc_arpcom;
#define	sc_if		sc_arpcom.ac_if
#define	sc_enaddr	sc_arpcom.ac_enaddr	/* hardware ethernet address */

	bus_space_tag_t		sc_regt;
	bus_space_handle_t	sc_regh;

	int		bitmode;	/* 32 bit mode == 1, 16 == 0 */
	bus_size_t	sc_reg_map[SN_NREGS];	/* register offsets */

	u_int16_t	snr_dcr;	/* DCR for this instance */
	u_int16_t	snr_dcr2;	/* DCR2 for this instance */
	int		slotno;		/* Slot number */

	int		sc_rramark;	/* index into p_rra of wp */
	void		*p_rra[NRRA];	/* RX resource descs */
	paddr_t		v_rra[NRRA];	/* DMA addresses of p_rra */
	u_int32_t	v_rea;		/* ptr to the end of the rra space */

	int		sc_rxmark;	/* current hw pos in rda ring */
	int		sc_rdamark;	/* current sw pos in rda ring */
	int		sc_nrda;	/* total number of RDAs */
	caddr_t		p_rda;
	paddr_t		v_rda;

	caddr_t		rbuf[NRBA];
	paddr_t		rbuf_phys[NRBA];

	struct mtd	mtda[NTDA];
	int		mtd_hw;		/* idx of first mtd given to hw */
	int		mtd_prev;	/* idx of last mtd given to hardware */
	int		mtd_free;	/* next free mtd to use */
	int		mtd_tlinko;	/*
					 * offset of tlink of last txp given
					 * to SONIC. Need to clear EOL on
					 * this word to add a desc.
					 */
	int		mtd_pint;	/* Counter to set TXP_PINT */

	void		*p_cda;
	u_int32_t	v_cda;

	vaddr_t		space;
} sn_softc_t;

/*
 * Accessing SONIC data structures and registers as 32 bit values
 * makes code endianess independent.  The SONIC is however always in
 * bigendian mode so it is necessary to ensure that data structures shared
 * between the CPU and the SONIC are always in bigendian order.
 */

/*
 * Receive Resource Descriptor
 * This structure describes the buffers into which packets
 * will be received.  Note that more than one packet may be
 * packed into a single buffer if constraints permit.
 */
#define	RXRSRC_PTRLO	0	/* buffer address LO */
#define	RXRSRC_PTRHI	1	/* buffer address HI */
#define	RXRSRC_WCLO	2	/* buffer size (16bit words) LO */
#define	RXRSRC_WCHI	3	/* buffer size (16bit words) HI */

#define	RXRSRC_SIZE(sc)	(sc->bitmode ? (4 * 4) : (4 * 2))

/*
 * Receive Descriptor
 * This structure holds information about packets received.
 */
#define	RXPKT_STATUS	0
#define	RXPKT_BYTEC	1
#define	RXPKT_PTRLO	2
#define	RXPKT_PTRHI	3
#define	RXPKT_SEQNO	4
#define	RXPKT_RLINK	5
#define	RXPKT_INUSE	6
#define	RXPKT_SIZE(sc)	(sc->bitmode ? (7 * 4) : (7 * 2))

#define RBASEQ(x) (((x)>>8)&0xff)
#define PSNSEQ(x) ((x) & 0xff)

/*
 * Transmit Descriptor
 * This structure holds information about packets to be transmitted.
 */
#define FRAGMAX	8		/* maximum number of fragments in a packet */

#define	TXP_STATUS	0	/* + transmitted packet status */
#define	TXP_CONFIG	1	/* transmission configuration */
#define	TXP_PKTSIZE	2	/* entire packet size in bytes */
#define	TXP_FRAGCNT	3	/* # fragments in packet */

#define	TXP_FRAGOFF	4	/* offset to first fragment */
#define	TXP_FRAGSIZE	3	/* size of each fragment desc */
#define	TXP_FPTRLO	0	/* ptr to packet fragment LO */
#define	TXP_FPTRHI	1	/* ptr to packet fragment HI */
#define	TXP_FSIZE	2	/* fragment size */

#define	TXP_WORDS	TXP_FRAGOFF + (FRAGMAX*TXP_FRAGSIZE) + 1	/* 1 for tlink */
#define	TXP_SIZE(sc)	((sc->bitmode) ? (TXP_WORDS*4) : (TXP_WORDS*2))

#define EOL	0x0001		/* end of list marker for link fields */

/*
 * CDA, the CAM descriptor area. The SONIC has a 16 entry CAM to
 * match incoming addresses against. It is programmed via DMA
 * from a memory region.
 */
#define MAXCAM	16	/* number of user entries in CAM */
#define	CDA_CAMDESC	4	/* # words i na descriptor */
#define	CDA_CAMEP	0	/* CAM Address Port 0 xx-xx-xx-xx-YY-YY */
#define	CDA_CAMAP0	1	/* CAM Address Port 1 xx-xx-YY-YY-xx-xx */
#define	CDA_CAMAP1	2	/* CAM Address Port 2 YY-YY-xx-xx-xx-xx */
#define	CDA_CAMAP2	3
#define	CDA_ENABLE	64	/* mask enabling CAM entries */
#define	CDA_SIZE(sc)	((4*16 + 1) * ((sc->bitmode) ? 4 : 2))

int	snsetup(struct sn_softc *sc, u_int8_t *);
int	snintr(void *);
void	sn_get_enaddr(bus_space_tag_t t, bus_space_handle_t h,
	    bus_addr_t o, u_char *dst);
@


1.14
log
@Allocate ethernet buffers as uvm pages, and map them with pmap_enter_cache(),
instead of crossing fingers and expecting malloc() to return aligned and
contiguous memory.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_snvar.h,v 1.13 2005/07/23 23:28:58 martin Exp $      */
@


1.13
log
@vm_offset_t -> {vaddr_t, bus_addr_t}
@
text
@d1 1
a1 1
/*    $OpenBSD: if_snvar.h,v 1.12 2004/11/26 21:21:24 miod Exp $      */
a46 3
extern int	kvtop(caddr_t addr);
#define	SONIC_GETDMA(p)	(u_int32_t)(kvtop((caddr_t)(p)))

d84 1
a84 1
#define	SN_NPAGES	2 + NRBA + (NTDA/2)
d88 1
a88 1
	u_int32_t	mtd_vtxp;
d90 1
a90 1
	u_int32_t	mtd_vbuf;
d115 1
a115 1
	u_int32_t	v_rra[NRRA];	/* DMA addresses of p_rra */
d122 1
a122 1
	u_int32_t	v_rda;
d125 1
d141 1
a141 1
	unsigned char	*space;
@


1.12
log
@More interrupt system cleaning and homogenization:
- switch all interrupt functions to an int (*)(void *) prototype.
- do not register dummy functions for all unhandled interrupts, instead
  let the dispatchers cope with NULL.
- add evcount interrupt counters.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_snvar.h,v 1.11 2002/04/22 20:15:55 miod Exp $      */
d221 1
a221 1
	    vm_offset_t o, u_char *dst);
@


1.11
log
@Bring several stability and performance fixes from NetBSD, as well as
more hardware support.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_snvar.h,v 1.10 2002/03/14 01:26:35 millert Exp $      */
d219 1
a219 1
void	snintr(void *, int);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*    $OpenBSD: if_snvar.h,v 1.9 2001/07/04 08:52:46 niklas Exp $      */
d21 1
d67 1
a67 1
#define NRBA    8		/* # receive buffers < NRRA */
d69 2
a70 2
#define NTDA    8		/* # transmit descriptors */
#define NRRA    16		/* # receive resource descriptors */
@


1.9
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*    $OpenBSD: if_snvar.h,v 1.8 1997/04/25 03:40:09 briggs Exp $      */
d217 4
a220 4
int	snsetup __P((struct sn_softc *sc, u_int8_t *));
void	snintr __P((void *, int));
void	sn_get_enaddr __P((bus_space_tag_t t, bus_space_handle_t h,
	    vm_offset_t o, u_char *dst));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*    $OpenBSD: if_snvar.h,v 1.9 2001/07/04 08:52:46 niklas Exp $      */
a20 1
#define	SN_VENDOR_ASANTELC	0x09	/* Asante Macintosh LC Ethernet */
d66 1
a66 1
#define NRBA    32		/* # receive buffers < NRRA */
d68 2
a69 2
#define NTDA    16		/* # transmit descriptors */
#define NRRA    64		/* # receive resource descriptors */
d217 4
a220 4
int	snsetup(struct sn_softc *sc, u_int8_t *);
void	snintr(void *, int);
void	sn_get_enaddr(bus_space_tag_t t, bus_space_handle_t h,
	    vm_offset_t o, u_char *dst);
@


1.8
log
@Make if_sn.c far more MI, eventually share with pica.
sonic_get is faster and simpler.
sn_ioctl works like other current ether drivers now.
Sync up with netbsd to ease maintenance; incorporate some "gratuitous" formatting changes so I won't have to do two totally seperate mods each time.
@
text
@d1 1
@


1.8.12.1
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*    $OpenBSD$      */
@


1.8.12.2
log
@Merge in -current from about a week ago
@
text
@d217 4
a220 4
int	snsetup(struct sn_softc *sc, u_int8_t *);
void	snintr(void *, int);
void	sn_get_enaddr(bus_space_tag_t t, bus_space_handle_t h,
	    vm_offset_t o, u_char *dst);
@


1.8.12.3
log
@Sync the SMP branch with 3.3
@
text
@a20 1
#define	SN_VENDOR_ASANTELC	0x09	/* Asante Macintosh LC Ethernet */
d66 1
a66 1
#define NRBA    32		/* # receive buffers < NRRA */
d68 2
a69 2
#define NTDA    16		/* # transmit descriptors */
#define NRRA    64		/* # receive resource descriptors */
@


1.7
log
@A couple of performance improvements from Denny Gentry <denny1@@home.com>
@
text
@d1 1
a1 1
/*      $OpenBSD: if_snvar.h,v 1.6 1997/04/23 00:28:22 gene Exp $       */
d10 1
a10 1
 * if_snvar.h -- National Semiconductor DP83932BVF (SONIC) OpenBSD/mac68k vars
d14 8
d27 4
a30 4
#define	SWO(m, a, o, x)	(m ? (*(u_int32_t *)((u_int32_t *)a + o) = (x)) : \
			     (*(u_int16_t *)((u_int16_t *)a + o) = (x)))
#define	SRO(m, a, o)	(m ? (*(u_int32_t *)((u_int32_t *)a + o) & 0xffff) : \
			     (*(u_int16_t *)((u_int16_t *)a + o) & 0xffff))
d39 1
a39 1
					((sc)->sc_reg_map[reg])))
d44 4
a66 1
#define NRDA    146
d83 1
a83 4
#define NTXB    NTDA	/* Number of xmit buffers */
#define TXBSIZE 1536    /* 6*2^8 -- the same size as the 8390 TXBUF */

#define	SN_NPAGES	2 + 8 + 4
d85 1
a85 28
/*
 * Statistics collected over time
 */
struct sn_stats {
	int     ls_opacks;	/* packets transmitted */
	int     ls_ipacks;	/* packets received */
	int     ls_tdr;		/* contents of tdr after collision */
	int     ls_tdef;	/* packets where had to wait */
	int     ls_tone;	/* packets with one retry */
	int     ls_tmore;	/* packets with more than one retry */
	int     ls_tbuff;	/* transmit buff errors */
	int     ls_tuflo;       /* "      uflo  "     */
	int     ls_tlcol;
	int     ls_tlcar;
	int     ls_trtry;
	int     ls_rbuff;       /* receive buff errors */
	int     ls_rfram;       /* framing     */
	int     ls_roflo;       /* overflow    */
	int     ls_rcrc;
	int     ls_rrng;	/* rx ring sequence error */
	int     ls_babl;	/* chip babl error */
	int     ls_cerr;	/* collision error */
	int     ls_miss;	/* missed packet */
	int     ls_merr;	/* memory error */
	int     ls_copies;      /* copies due to out of range mbufs */
	int     ls_maxmbufs;    /* max mbufs on transmit */
	int     ls_maxslots;    /* max ring slots on transmit */
};
d89 4
a92 2
	int		mtd_vtxp;
	unsigned char	*mtd_buf;
d99 3
a101 3
	struct	device sc_dev;
	struct	arpcom sc_arpcom;
#define	sc_if		sc_arpcom.ac_if		/* network visible interface */
d107 1
a107 3
	struct sn_stats	sc_sum;
	short		sc_iflags;
	unsigned short	bitmode;	/* 32 bit mode == 1, 16 == 0 */
d112 1
a112 13
	int	slotno;			/* Slot number */

	int	sc_rxmark;		/* pos. in rx ring for reading buffs */
	int	sc_rramark;		/* index into p_rra of wp */
	void *p_rra[NRRA];		/* RX resource descs */
	int	v_rra[NRRA];		/* DMA addresses of p_rra */
	int	v_rea;			/* ptr to the end of the rra space */

	int	sc_rdamark;
	void *p_rda[NRDA];
	int	v_rda[NRDA];

	caddr_t	rbuf[NRBA];
d114 10
a123 1
	int	sc_missed;		/* missed packet counter */
d125 1
a125 3
	int	txb_cnt;		/* total number of xmit buffers */
	int	txb_inuse;		/* number of active xmit buffers */
	int	txb_new;		/* index of next open slot. */
d136 1
a136 3

	caddr_t		tbuf[NTXB];
	int		vtbuf[NTXB];	/* DMA address of tbuf */
d139 1
a139 1
	int		v_cda;
d216 2
a217 1
int	snsetup __P((struct sn_softc *sc));
d219 1
a219 2
			   vm_offset_t o, u_char *dst));
void	snintr __P((void *, int));
@


1.6
log
@NetBSD -> OpenBSD in comments.  Last references in here.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_snvar.h,v 1.5 1997/04/13 14:14:52 briggs Exp $       */
d43 1
a43 2
 * 1 TXpkt is 4 hdr words + (3 * FRAGMAX) + 1 link word
 * FRAGMAX == 16 => 54 words == 216 bytes
d47 4
d55 4
a58 4
#define NRDA    NRBA*4
#define NTDA    4		/* # transmit descriptors */
#define NRRA    32		/* # receive resource descriptors */
#define RRAMASK (NRRA-1)	/* the reason why it must be power of two */
d72 1
a72 1
#define NTXB    10      /* Number of xmit buffers */
d75 1
a75 1
#define	SN_NPAGES	1 + 8 + 5
@


1.5
log
@Some updates based on information from Bob Nestor <rnestor@@metronet.com>
about his SONIC-T LC/PDS card.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_snvar.h,v 1.4 1997/04/10 02:35:03 briggs Exp $       */
d10 1
a10 1
 * if_snvar.h -- National Semiconductor DP83932BVF (SONIC) NetBSD/mac68k vars
@


1.4
log
@Changes from Denny Gentry <denny1@@home.com>:
Change in the way receive buffer areas are handled.  Before we gave
the chip 16 buffers, each 1536 bytes (big enough for one packet).
Now we're handing the chip 8 buffers, each 4 Kbytes, and letting
the chip fit as many packets as it can in each one.  This should
help keep it from running out of buffer space.  Also make some of
the performance-crucial routines inline.  It made no measurable
difference except to make me feel better
@
text
@d1 1
a1 1
/*      $OpenBSD: if_snvar.h,v 1.3 1997/03/29 23:26:50 briggs Exp $       */
d240 2
@


1.3
log
@Update from Denton Gentry with minor bug fixes by me.
Denny says:
if_sn.c:
        - allocate sc->space using malloc (Scott wanted this).
        - make csr accesses use NIC_PUT/GET, remove sc->sc_csr.
        - add multicast and IFF_PROMISC support. multicast isn't
                well tested, but I made sure the unicast case still
                works.
        - finish the new arp interface, remove sc->sc_enaddr
if_snreg.h:
        - remove struct sonic_reg
if_snvar.h:
        - add NIC_PUT and NIC_GET macros a la if_ae
        - remove sc_txhead, it isn't used.
if_sn_nubus.c:
        - clean up support for my SE/30 card.
        - Move add_nubus_intr from if_sn.c (to keep if_sn.c MI)
if_sn_obio.c:
        - make Q610, C610, Q650, C650, Q800 use EXBUS.
        - PB500 had a "return" where "break" was intended. PB500
                probably wasn't working.
        - move add_nubus_intr from if_sn.c.
        - add an "explanation" why Apple's ethernet addr is encoded
                in token ring format in the PROM.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_snvar.h,v 1.2 1997/03/14 14:11:36 briggs Exp $       */
d50 3
a52 3
#define NRBA    16		/* # receive buffers < NRRA */
#define RBAMASK 0x0f
#define NRDA    NRBA
d55 1
a55 1
#define RRAMASK 0x1f		/* the reason why it must be power of two */
d207 1
a207 1
#define FRAGMAX	16		/* maximum number of fragments in a packet */
d220 1
a220 1
#define	TXP_WORDS	TXP_FRAGOFF + FRAGMAX*TXP_FSIZE + 1	/* 1 for tlink */
@


1.2
log
@Updates from Yanagisawa and Denny.  This seems to work.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_snvar.h,v 1.1 1997/03/12 13:20:33 briggs Exp $       */
d10 1
a10 1
 * if_sonic.h -- National Semiconductor DP83932BVF (SONIC)
d25 17
d72 2
d124 1
d126 2
a127 1
	unsigned int	s_dcr;		/* DCR for this instance */
d129 1
a129 1
	struct sonic_reg *sc_csr;	/* hardware pointer */
a130 1

a141 1
	int	sc_txhead;		/*XXX idx of first TDA passed to chip */
d164 1
a164 1
	unsigned char	space[(1 + 1 + 8 + 5) * NBPG];
d239 2
a240 1
void	snsetup __P((struct sn_softc *sc));
@


1.1
log
@Bring in some fresh SONIC code from Dennis Gentry and Yanagisawa Takeshi.
Much hacked by me to merge and partially busify.
Add code that I lost a while back for digging the proper mac address for
internal ethernet.
Still needs work, but checkpointed--works at least as well as the last
version.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_sn.h,v 1.2 1996/05/26 18:35:26 briggs Exp $       */
d14 11
a32 3
#define NRRA    32		/* # receive resource descriptors */
#define RRAMASK 0x1f		/* the reason why it must be power of two */

d35 1
a35 1
#define NRDA    NRBA		/* # receive descriptors */
d37 2
a38 5

#define CDASIZE sizeof(struct CDA)
#define RRASIZE (NRRA*sizeof(struct RXrsrc))
#define RDASIZE (NRDA*sizeof(struct RXpkt))
#define TDASIZE (NTDA*sizeof(struct TXpkt))
d46 2
a47 3
#define RBASIZE(sc)	\
	(sizeof(struct ether_header) + ETHERMTU + FCSSIZE + \
	 ((sc)->sc_is16 ? 2 : 6))
d84 6
d94 4
a97 4
	struct  device sc_dev;
	struct  arpcom sc_arpcom;
#define sc_if	   sc_arpcom.ac_if	 /* network visible interface */
#define sc_enaddr       sc_arpcom.ac_enaddr     /* hardware ethernet address */
d102 17
a118 1
	int		sc_is16;
d120 1
a120 15
	unsigned int    s_dcr;	  /* DCR for this instance */
	int     	slotno;

	struct sonic_reg *sc_csr;       /* hardware pointer */

	int     sc_rxmark;	      /* pos. in rx ring for reading bufs */

	int     sc_rramark;	     /* index into rra of wp */

	int     sc_txhead;	      /* index of first TDA passed to chip */
	int     sc_missed;	      /* missed packet counter */

	int     txb_cnt;		/* total number of xmit buffers */
	int     txb_inuse;	      /* number of active xmit buffers */
	int     txb_new;		/* index of next open slot. */
d122 2
a123 1
	void	*sc_lrxp;	 /* last RDA available to chip */
d125 13
a137 2
	struct  sn_stats sc_sum;
	short   sc_iflags;
d139 2
a140 8
	void	*p_rra; /* struct RXrsrc: receiver resource descriptors */
	int	 v_rra; /* DMA address of rra */
	void	*p_rda; /* struct RXpkt: receiver desriptors */
	int	 v_rda;
	void	*p_tda; /* struct TXpkt: transmitter descriptors */
	int	 v_tda;
	void	*p_cda; /* struct CDA: CAM descriptors */
	int	 v_cda; /* DMA address of CDA */
d142 2
a143 2
	void	(*rxint) __P((struct sn_softc *));
	void	(*txint) __P((struct sn_softc *));
d145 1
a145 4
	caddr_t	rbuf[NRBA];
	caddr_t	tbuf[NTXB];
	int	vtbuf[NTXB];
	unsigned char   space[(1 + 1 + 8 + 5) * NBPG];
a147 1

d161 6
a166 12
struct RXrsrc {
	u_long  buff_ptrlo;	/* buffer address LO */
	u_long  buff_ptrhi;	/* buffer address HI */
	u_long  buff_wclo;	/* buffer size (16bit words) LO */ 
	u_long  buff_wchi;	/* buffer size (16bit words) HI */
};
struct _short_RXrsrc {
	u_short  buff_ptrlo;	/* buffer address LO */
	u_short  buff_ptrhi;	/* buffer address HI */
	u_short  buff_wclo;	/* buffer size (16bit words) LO */ 
	u_short  buff_wchi;	/* buffer size (16bit words) HI */
};
d172 9
a180 18
struct RXpkt {
	u_long  status;		/* + receive status */
	u_long  byte_count;	/* + packet byte count (including FCS) */
	u_long  pkt_ptrlo;	/* + packet data LO (in RBA) */
	u_long  pkt_ptrhi;	/* + packet data HI (in RBA) */
	u_long  seq_no;		/* + RBA sequence numbers */
	u_long  rlink;		/* link to next receive descriptor */
	u_long  in_use;		/* + packet available to SONIC */
};
struct _short_RXpkt {
	u_short  status;	/* + receive status */
	u_short  byte_count;	/* + packet byte count (including FCS) */
	u_short  pkt_ptrlo;	/* + packet data LO (in RBA) */
	u_short  pkt_ptrhi;	/* + packet data HI (in RBA) */
	u_short  seq_no;	/* + RBA sequence numbers */
	u_short  rlink;		/* link to next receive descriptor */
	u_short  in_use;	/* + packet available to SONIC */
};
d188 1
a188 27
#define FRAGMAX 16	      /* maximum number of fragments in a packet */
struct TXpkt {
	u_long  status;		/* + transmitted packet status */
	u_long  config;		/* transmission configuration */
	u_long  pkt_size;	/* entire packet size in bytes */
	u_long  frag_count;	/* # fragments in packet */
	struct {
		u_long  frag_ptrlo;	/* pointer to packet fragment LO */
		u_long  frag_ptrhi;	/* pointer to packet fragment HI */
		u_long  frag_size;	/* fragment size */
	} u[FRAGMAX];
	u_long  :32;	/* This makes tcp->u[FRAGMAX].u_link.link valid! */
};
struct _short_TXpkt {
	u_short  status;	/* + transmitted packet status */
	u_short  config;	/* transmission configuration */
	u_short  pkt_size;	/* entire packet size in bytes */
	u_short  frag_count;	/* # fragments in packet */
	struct {
		u_short  frag_ptrlo;     /* pointer to packet fragment LO */
		u_short  frag_ptrhi;     /* pointer to packet fragment HI */
		u_short  frag_size;      /* fragment size */
	} u[FRAGMAX];
	u_short  :16;	/* This makes tcp->u[FRAGMAX].u_link.link valid! */
};

#define tlink frag_ptrlo
d190 29
a218 21
#define EOL     0x0001	  /* end of list marker for link fields */

#define MAXCAM  16      /* number of user entries in CAM */
struct CDA {
	struct {
		u_long  cam_ep;     /* CAM Entry Pointer */
		u_long  cam_ap0;    /* CAM Address Port 0 xx-xx-xx-xx-YY-YY */
		u_long  cam_ap1;    /* CAM Address Port 1 xx-xx-YY-YY-xxxx */
		u_long  cam_ap2;    /* CAM Address Port 2 YY-YY-xx-xx-xx-xx */
	} desc[MAXCAM];
	u_long  enable;		    /* mask enabling CAM entries */
};
struct _short_CDA {
	struct {
		u_short  cam_ep;    /* CAM Entry Pointer */
		u_short  cam_ap0;   /* CAM Address Port 0 xx-xx-xx-xx-YY-YY */
		u_short  cam_ap1;   /* CAM Address Port 1 xx-xx-YY-YY-xxxx */
		u_short  cam_ap2;   /* CAM Address Port 2 YY-YY-xx-xx-xx-xx */
	} desc[MAXCAM];
	u_short  enable;	    /* mask enabling CAM entries */
};
@
