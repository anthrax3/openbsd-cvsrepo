head	1.20;
access;
symbols
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.16
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.12
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.14
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12;
locks; strict;
comment	@ * @;


1.20
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.19;

1.19
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.30.15.15.21;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.14.09.36.49;	author martin;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.13.22.35.17;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.13.22.07.55;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.04.10.25.21;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.30.20.41.51;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.30.12.15.06;	author martin;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.23.19.05.23;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.22.19.40.54;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.10.21.19.14;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.09.21.52.12;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.09.20.51.48;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.08.20.35.21;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.08.17.19.46;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.08.16.59.35;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.08.16.36.54;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.04.20.39.05;	author miod;	state Exp;
branches;
next	;


desc
@@


1.20
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: macfb.c,v 1.19 2010/12/26 15:40:59 miod Exp $	*/
/* $NetBSD: macfb.c,v 1.11 2005/01/15 16:00:59 chs Exp $ */
/*
 * Copyright (c) 1998 Matt DeBergalis
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Matt DeBergalis
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/cpu.h>
#include <machine/bus.h>

#include <mac68k/dev/nubus.h>

#include <uvm/uvm_extern.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <mac68k/dev/macfbvar.h>

struct cfdriver macfb_cd = {
	NULL, "macfb", DV_DULL
};

int	macfb_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	macfb_mmap(void *, off_t, int);
int	macfb_alloc_screen(void *, const struct wsscreen_descr *,
		    void **, int *, int *, long *);
void	macfb_free_screen(void *, void *);
int	macfb_show_screen(void *, void *, int,
		    void (*)(void *, int, int), void *);

const struct wsdisplay_accessops macfb_accessops = {
	macfb_ioctl,
	macfb_mmap,
	macfb_alloc_screen,
	macfb_free_screen,
	macfb_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	NULL	/* burner */
};

int	macfb_alloc_cattr(void *, int, int, int, long *);
int	macfb_alloc_hattr(void *, int, int, int, long *);
int	macfb_alloc_mattr(void *, int, int, int, long *);
int	macfb_color_setup(struct macfb_devconfig *);
int	macfb_getcmap(struct macfb_devconfig *, struct wsdisplay_cmap *);
int	macfb_init(struct macfb_devconfig *);
int	macfb_is_console(paddr_t);
void	macfb_palette_setup(struct macfb_devconfig *);
int	macfb_putcmap(struct macfb_devconfig *, struct wsdisplay_cmap *);

paddr_t macfb_consaddr;

static struct macfb_devconfig macfb_console_dc;

/* From Booter via locore */
extern long		videoaddr;
extern long		videorowbytes;
extern long		videobitdepth;
extern u_long		videosize;
extern u_int32_t	mac68k_vidphys;
extern u_int32_t	mac68k_vidlen;

extern int rasops_alloc_cattr(void *, int, int, int, long *);

int
macfb_is_console(paddr_t addr)
{
	if (addr != macfb_consaddr && (addr >= NBBASE && addr < NBTOP)) {
		/*
		 * This is in the NuBus standard slot space range, so we
		 * may well have to look at 0xFssxxxxx, too.  Mask off the
		 * slot number and duplicate it in bits 20-23, per IM:V
		 * pp 459, 463, and IM:VI ch 30 p 17.
		 * Note:  this is an ugly hack and I wish I knew what
		 * to do about it.  -- sr
		 */
		addr = (paddr_t)(((u_long)addr & 0xff0fffff) |
		    (((u_long)addr & 0x0f000000) >> 4));
	}
	return ((mac68k_machine.serial_console & 0x03) == 0
	    && (addr == macfb_consaddr));
}

int
macfb_init(struct macfb_devconfig *dc)
{
	struct rasops_info *ri = &dc->dc_ri;
	int bgcolor;

	bzero(ri, sizeof(*ri));
	ri->ri_depth = dc->dc_depth;
	ri->ri_stride = dc->dc_rowbytes;
	ri->ri_flg = RI_CENTER;
	ri->ri_bits = (void *)(dc->dc_vaddr + dc->dc_offset);
	ri->ri_width = dc->dc_wid;
	ri->ri_height = dc->dc_ht;
	ri->ri_hw = dc;

	/* swap B and R if necessary */
	switch (ri->ri_depth) {
	case 16:
		ri->ri_rnum = 5;
		ri->ri_rpos = 11;
		ri->ri_gnum = 6;
		ri->ri_gpos = 5;
		ri->ri_bnum = 5;
		ri->ri_bpos = 0;
		break;
	case 24:
	case 32:
		ri->ri_rnum = 8;
		ri->ri_rpos = 16;
		ri->ri_gnum = 8;
		ri->ri_gpos = 8;
		ri->ri_bnum = 8;
		ri->ri_bpos = 0;
		break;
	}

	/*
	 * Ask for an unholy big display, rasops will trim this to more
	 * reasonable values.
	 */
	if (rasops_init(ri, 160, 160) != 0)
		return (-1);

	bgcolor = macfb_color_setup(dc);

	/*
	 * Clear display. We can't pass RI_CLEAR in ri_flg and have rasops
	 * do it for us until we know how to setup the colormap first.
	 */
	memset((char *)dc->dc_vaddr + dc->dc_offset, bgcolor,
	     dc->dc_rowbytes * dc->dc_ht);

	strlcpy(dc->dc_wsd.name, "std", sizeof(dc->dc_wsd.name));
	dc->dc_wsd.ncols = ri->ri_cols;
	dc->dc_wsd.nrows = ri->ri_rows;
	dc->dc_wsd.textops = &ri->ri_ops;
	dc->dc_wsd.fontwidth = ri->ri_font->fontwidth;
	dc->dc_wsd.fontheight = ri->ri_font->fontheight;
	dc->dc_wsd.capabilities = ri->ri_caps;

	return (0);
}

int
macfb_color_setup(struct macfb_devconfig *dc)
{
	extern int rasops_alloc_cattr(void *, int, int, int, long *);
	struct rasops_info *ri = &dc->dc_ri;

	/* nothing to do for non-indexed modes... */
	if (ri->ri_depth > 8)
		return (0);	/* fill in black */

	if (dc->dc_setcolor == NULL || ISSET(dc->dc_flags, FB_MACOS_PALETTE) ||
	    ri->ri_depth < 2) {
		/*
		 * Until we know how to setup the colormap, or if we are
		 * already initialized (i.e. glass console), constrain ourselves
		 * to mono mode. Note that we need to use our own alloc_attr
		 * routine to compensate for inverted black and white colors.
		 */
		ri->ri_ops.alloc_attr = macfb_alloc_mattr;
		ri->ri_caps &= ~(WSSCREEN_WSCOLORS | WSSCREEN_HILIT);
		if (ri->ri_depth == 8)
			ri->ri_devcmap[15] = 0xffffffff;

		macfb_palette_setup(dc);

		return (0xff);	/* fill in black inherited from MacOS */
	}

	/* start from the rasops colormap */
	bcopy(rasops_cmap, dc->dc_cmap, 256 * 3);

	switch (ri->ri_depth) {
	case 2:
		/*
		 * 2bpp mode does not really have colors, only two gray
		 * shades in addition to black and white, to allow
		 * hilighting.
		 *
		 * Our palette needs to be:
		 *   00 black
		 *   01 dark gray (highlighted black, sort of)
		 *   02 light gray (normal white)
		 *   03 white (highlighted white)
		 */
		bcopy(dc->dc_cmap + (255 - WSCOL_WHITE) * 3,
		    dc->dc_cmap + 1 * 3, 3);
		bcopy(dc->dc_cmap + WSCOL_WHITE * 3, dc->dc_cmap + 2 * 3, 3);
		bcopy(dc->dc_cmap + (8 + WSCOL_WHITE) * 3,
		    dc->dc_cmap + 3 * 3, 3);
		ri->ri_caps |= WSSCREEN_HILIT;
		ri->ri_ops.alloc_attr = macfb_alloc_hattr;
		break;
	case 4:
		/*
		 * Tweak colormap
		 *
		 * Due to the way rasops cursor work, we need to provide
		 * inverted copies of the 8 basic colors as the other 8
		 * in 4bpp mode.
		 */
		bcopy(dc->dc_cmap + (256 - 8) * 3, dc->dc_cmap + 8 * 3, 8 * 3);
		ri->ri_caps |= WSSCREEN_WSCOLORS;
		ri->ri_ops.alloc_attr = macfb_alloc_cattr;
		break;
	default:
	case 8:
		break;
	}

	(*dc->dc_setcolor)(dc, 0, 1 << ri->ri_depth);

	return (WSCOL_BLACK);	/* fill in our own black */
}

/*
 * Initialize a black and white, MacOS compatible, shadow colormap.
 * This is necessary if we still want to be able to run X11 with colors.
 */
void
macfb_palette_setup(struct macfb_devconfig *dc)
{
	memset(dc->dc_cmap, 0xff, 3);		/* white */
	bzero(dc->dc_cmap + 3, 255 * 3);	/* black */
}

/*
 * Attribute allocator for monochrome displays (either 1bpp or no colormap
 * control). Note that the colors we return are indexes into ri_devcmap which
 * will select the actual bits.
 */
int
macfb_alloc_mattr(void *cookie, int fg, int bg, int flg, long *attr)
{
	if ((flg & (WSATTR_BLINK | WSATTR_HILIT | WSATTR_WSCOLORS)) != 0)
		return (EINVAL);

	/*
	 * Default values are white on black. However, on indexed displays,
	 * 0 is white and all bits set is black.
	 */
	if ((flg & WSATTR_REVERSE) != 0) {
		fg = 15;
		bg = 0;
	} else {
		fg = 0;
		bg = 15;
	}

	*attr = (bg << 16) | (fg << 24) | ((flg & WSATTR_UNDERLINE) ? 7 : 6);
	return (0);
}

/*
 * Attribute allocator for 2bpp displays.
 * Note that the colors we return are indexes into ri_devcmap which will
 * select the actual bits.
 */
int
macfb_alloc_hattr(void *cookie, int fg, int bg, int flg, long *attr)
{
	if ((flg & (WSATTR_BLINK | WSATTR_WSCOLORS)) != 0)
		return (EINVAL);

	if ((flg & WSATTR_REVERSE) != 0) {
		fg = WSCOL_BLACK;
		bg = WSCOL_WHITE;
	} else {
		fg = WSCOL_WHITE;
		bg = WSCOL_BLACK;
	}

	if ((flg & WSATTR_HILIT) != 0)
		fg += 8;

	*attr = (bg << 16) | (fg << 24) | ((flg & WSATTR_UNDERLINE) ? 7 : 6);
	return (0);
}

/*
 * Attribute allocator for 4bpp displays.
 */
int
macfb_alloc_cattr(void *cookie, int fg, int bg, int flg, long *attr)
{
	if ((flg & (WSATTR_BLINK | WSATTR_HILIT)) != 0)
		return (EINVAL);

	return (rasops_alloc_cattr(cookie, fg, bg, flg, attr));
}

void
macfb_attach_common(struct macfb_softc *sc, struct macfb_devconfig *dc)
{
	struct wsemuldisplaydev_attach_args waa;
	int isconsole;

	/* Print hardware characteristics. */
	printf("%s: %dx%d, ", sc->sc_dev.dv_xname, dc->dc_wid, dc->dc_ht);
	if (dc->dc_depth == 1)
		printf("monochrome");
	else
		printf("%dbit color", dc->dc_depth);
	printf(" display\n");

	isconsole = macfb_is_console(sc->sc_basepa + dc->dc_offset);

	if (isconsole) {
		macfb_console_dc.dc_setcolor = dc->dc_setcolor;
		macfb_console_dc.dc_cmapregs = dc->dc_cmapregs;
		free(dc, M_DEVBUF);
		dc = sc->sc_dc = &macfb_console_dc;
		dc->dc_nscreens = 1;
		macfb_color_setup(dc);
		/* XXX at this point we should reset the emulation to have
		 * it pick better attributes for kernel messages. Oh well. */
	} else {
		sc->sc_dc = dc;
		if (macfb_init(dc) != 0)
			return;
	}

	dc->dc_scrlist[0] = &dc->dc_wsd;
	dc->dc_screenlist.nscreens = 1;
	dc->dc_screenlist.screens =
	    (const struct wsscreen_descr **)dc->dc_scrlist;

	waa.console = isconsole;
	waa.scrdata = &dc->dc_screenlist;
	waa.accessops = &macfb_accessops;
	waa.accesscookie = sc;
	waa.defaultscreens = 0;

	config_found((struct device *)sc, &waa, wsemuldisplaydevprint);
}

int
macfb_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct macfb_softc *sc = v;
	struct macfb_devconfig *dc = sc->sc_dc;
	struct wsdisplay_fbinfo *wdf;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(int *)data = WSDISPLAY_TYPE_MAC68K;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = dc->dc_ri.ri_height;
		wdf->width = dc->dc_ri.ri_width;
		wdf->depth = dc->dc_ri.ri_depth;
		if (dc->dc_ri.ri_depth > 8 || dc->dc_setcolor == NULL)
			wdf->cmsize = 0;
		else
			wdf->cmsize = 1 << dc->dc_ri.ri_depth;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = dc->dc_ri.ri_stride;
		break;
	case WSDISPLAYIO_GETCMAP:
		if (dc->dc_ri.ri_depth > 8 || dc->dc_setcolor == NULL)
			return (0);
		return (macfb_getcmap(dc, (struct wsdisplay_cmap *)data));
	case WSDISPLAYIO_PUTCMAP:
		if (dc->dc_ri.ri_depth > 8 || dc->dc_setcolor == NULL)
			return (0);
		return (macfb_putcmap(dc, (struct wsdisplay_cmap *)data));
	case WSDISPLAYIO_SMODE:
		if (dc->dc_ri.ri_depth > 8 || dc->dc_setcolor == NULL)
			return (0);
		if (*(u_int *)data == WSDISPLAYIO_MODE_EMUL &&
		    ISSET(dc->dc_flags, FB_MACOS_PALETTE)) {
			macfb_palette_setup(dc);
			(*dc->dc_setcolor)(dc, 0, 1 << dc->dc_ri.ri_depth);
			/* clear display */
			memset((char *)dc->dc_vaddr + dc->dc_offset, 0xff,
			     dc->dc_rowbytes * dc->dc_ht);
		}
		break;
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		break;
	default:
		return (-1);
	}

	return (0);
}

paddr_t
macfb_mmap(void *v, off_t offset, int prot)
{
	struct macfb_softc *sc = v;
	struct macfb_devconfig *dc = sc->sc_dc;
	paddr_t addr;

	if (offset >= 0 &&
	    offset < round_page(dc->dc_size))
		addr = (dc->dc_paddr + dc->dc_offset + offset);
	else
		addr = (-1);

	return addr;
}

int
macfb_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *defattrp)
{
	struct macfb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_dc->dc_ri;

	if (sc->sc_dc->dc_nscreens > 0)
		return (ENOMEM);

	*cookiep = ri;
	*curxp = *curyp = 0;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, defattrp);
	sc->sc_dc->dc_nscreens++;

	return (0);
}

void
macfb_free_screen(void *v, void *cookie)
{
	struct macfb_softc *sc = v;

	sc->sc_dc->dc_nscreens--;
}

int
macfb_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

int
macfb_getcmap(struct macfb_devconfig *dc, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index, count = cm->count;
	u_int colcount = 1 << dc->dc_ri.ri_depth;
	int i, error;
	u_int8_t ramp[256], *c, *r;

	if (index >= colcount || count > colcount - index)
		return (EINVAL);

	/* extract reds */
	c = dc->dc_cmap + 0 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->red, count)) != 0)
		return (error);

	/* extract greens */
	c = dc->dc_cmap + 1 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->green, count)) != 0)
		return (error);

	/* extract blues */
	c = dc->dc_cmap + 2 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->blue, count)) != 0)
		return (error);

	return (0);
}

int
macfb_putcmap(struct macfb_devconfig *dc, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index, count = cm->count;
	u_int colcount = 1 << dc->dc_ri.ri_depth;
	int i, error;
	u_int8_t r[256], g[256], b[256], *nr, *ng, *nb, *c;

	if (index >= colcount || count > colcount - index)
		return (EINVAL);

	if ((error = copyin(cm->red, r, count)) != 0)
		return (error);
	if ((error = copyin(cm->green, g, count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, b, count)) != 0)
		return (error);

	nr = r, ng = g, nb = b;
	c = dc->dc_cmap + index * 3;
	for (i = count; i != 0; i--) {
		*c++ = *nr++;
		*c++ = *ng++;
		*c++ = *nb++;
	}

	(*dc->dc_setcolor)(dc, index, index + count);

	return (0);
}

int
macfb_cnattach()
{
	struct macfb_devconfig *dc = &macfb_console_dc;
	long defattr;
	struct rasops_info *ri;

	dc->dc_vaddr = trunc_page(videoaddr);
	dc->dc_paddr = trunc_page(mac68k_vidphys);
	dc->dc_offset = m68k_page_offset(mac68k_vidphys);
	dc->dc_wid = videosize & 0xffff;
	dc->dc_ht = (videosize >> 16) & 0xffff;
	dc->dc_depth = videobitdepth;
	dc->dc_rowbytes = videorowbytes;
	dc->dc_size = (mac68k_vidlen > 0) ?
	    mac68k_vidlen : dc->dc_ht * dc->dc_rowbytes;

	/* set up the display */
	dc->dc_flags |= FB_MACOS_PALETTE;
	if (macfb_init(dc) != 0)
		return (-1);

	ri = &dc->dc_ri;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&dc->dc_wsd, ri, 0, 0, defattr);

	macfb_consaddr = mac68k_vidphys;
	return (0);
}
@


1.19
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.18 2006/11/29 12:13:54 miod Exp $	*/
@


1.18
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.17 2006/06/30 15:15:21 miod Exp $	*/
d440 1
a440 1
		addr = atop(dc->dc_paddr + dc->dc_offset + offset);
@


1.17
log
@When allocating the default rasops attribute, it is not necessary to use
non-zero parameters on a color display as long as we want white on black;
this was inherited from sparc but this is not necessary on these platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.16 2006/04/14 09:36:49 martin Exp $	*/
d372 1
@


1.16
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.15 2006/03/13 22:35:17 miod Exp $	*/
d458 1
a458 5
	if ((ri->ri_caps & WSSCREEN_WSCOLORS) && ri->ri_depth <= 8)
		ri->ri_ops.alloc_attr(ri, WSCOL_WHITE, WSCOL_BLACK,
		    WSATTR_WSCOLORS, defattrp);
	else
		ri->ri_ops.alloc_attr(ri, 0, 0, 0, defattrp);
d568 1
a568 6
	if ((ri->ri_caps & WSSCREEN_WSCOLORS) && ri->ri_depth <= 8)
		ri->ri_ops.alloc_attr(ri, WSCOL_WHITE, WSCOL_BLACK,
		    WSATTR_WSCOLORS, &defattr);
	else
		ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);

@


1.15
log
@Put wsscreen_list array inside the softc instead of on the stack; similar fix
as happened on hp300 and sparc* yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.13 2006/03/04 10:25:21 miod Exp $	*/
d238 1
a238 1
		 * Due to the way rasops cursor work, we need to provide 
@


1.14
log
@Although we can not currently run the glass console with colors if in an
indexed mode, remember the colormap information (if any) when the real driver
attaches, and use it to allow for X11 to control the colormap.

This allows glass console and 8bpp X11 on DAFB (previously, this would only
be possible if the console was on cereal).
@
text
@d171 7
a177 7
	strlcpy(dc->wsd.name, "std", sizeof(dc->wsd.name));
	dc->wsd.ncols = ri->ri_cols;
	dc->wsd.nrows = ri->ri_rows;
	dc->wsd.textops = &ri->ri_ops;
	dc->wsd.fontwidth = ri->ri_font->fontwidth;
	dc->wsd.fontheight = ri->ri_font->fontheight;
	dc->wsd.capabilities = ri->ri_caps;
a335 2
	struct wsscreen_descr *scrlist[1];
	struct wsscreen_list screenlist;
d353 1
a353 1
		dc->nscreens = 1;
d363 4
a366 3
	scrlist[0] = &dc->wsd;
	screenlist.nscreens = 1;
	screenlist.screens = (const struct wsscreen_descr **)scrlist;
d369 1
a369 1
	waa.scrdata = &screenlist;
d453 1
a453 1
	if (sc->sc_dc->nscreens > 0)
d463 1
a463 1
	sc->sc_dc->nscreens++;
d473 1
a473 1
	sc->sc_dc->nscreens--;
d578 1
a578 1
	wsdisplay_cnattach(&dc->wsd, ri, 0, 0, defattr);
@


1.13
log
@Set up a ``different shades of gray'' palette at 2bpp, this gives us
highlighting.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.12 2006/01/30 20:41:51 miod Exp $	*/
d83 1
d192 1
a192 1
	if (dc->dc_setcolor == NULL ||
d195 2
a196 1
		 * Until we know how to setup the colormap, constrain ourselves
d204 3
d257 11
d351 2
d393 1
a393 1
		if (dc->dc_ri.ri_depth > 8)
d396 1
a396 2
			wdf->cmsize = (dc->dc_ri.ri_caps & WSSCREEN_WSCOLORS) ?
			    1 << dc->dc_ri.ri_depth : 0;
d402 1
a402 2
		if (dc->dc_ri.ri_depth > 8 ||
		    (dc->dc_ri.ri_caps & WSSCREEN_WSCOLORS) == 0)
d406 1
a406 2
		if (dc->dc_ri.ri_depth > 8 ||
		    (dc->dc_ri.ri_caps & WSSCREEN_WSCOLORS) == 0)
d409 12
d568 1
@


1.12
log
@swap B and R in 24bpp and 32bpp modes too; tested martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.11 2006/01/30 12:15:06 martin Exp $	*/
d77 1
d192 1
a192 1
	    ri->ri_depth < 4 /* XXX unfair with 2bpp */) {
d209 20
d251 5
d278 29
@


1.11
log
@pretty printf, for 32bit mode

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.10 2006/01/23 19:05:23 miod Exp $	*/
d132 3
a134 2
	/* swap B and R */
	if (ri->ri_depth == 16) {
d141 10
@


1.10
log
@Be sure to clear color capabilities from rasops at 8bpp if we do not have
a setcolor routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.9 2006/01/22 19:40:54 miod Exp $	*/
d259 1
a259 1
	printf("%s: %dx%d ", sc->sc_dev.dv_xname, dc->dc_wid, dc->dc_ht);
d263 1
a263 1
		printf("%d color", 1 << dc->dc_depth);
@


1.9
log
@Colormap support for DAFB frame buffers (using information from Linux).
However, color can not be enabled in emulation mode if the display is the
console at this point, but 8bpp X11 works.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.8 2006/01/10 21:19:14 miod Exp $	*/
d187 1
@


1.8
log
@Simplify external macfb interfaces, kill an intermediate attachment structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.7 2006/01/09 21:52:12 miod Exp $	*/
d76 4
a79 1
int	macfb_alloc_attr(void *, int, int, int, long *);
d82 1
d96 2
d121 1
a121 8
	extern int rasops_alloc_cattr(void *, int, int, int, long *);

	/*
	 * Clear display. We can't pass RI_CLEAR in ri_flg and have rasops
	 * do it for us until we know how to setup the colormap first.
	 */
	memset((char *)dc->dc_vaddr + dc->dc_offset,
	    dc->dc_depth <= 8 ? 0xff : 0, dc->dc_rowbytes * dc->dc_ht);
d149 8
a156 11
	if (ri->ri_depth <= 8) {
		/*
		 * Until we know how to setup the colormap, constrain ourselves
		 * to mono mode. Note that we need to use our own alloc_attr
		 * routine to compensate for inverted black and white colors.
		 */
		ri->ri_ops.alloc_attr = macfb_alloc_attr;
		ri->ri_caps &= ~(WSSCREEN_WSCOLORS | WSSCREEN_HILIT);
		if (ri->ri_depth == 8)
			ri->ri_devcmap[15] = 0xffffffff;
	}
d170 1
a170 1
macfb_alloc_attr(void *cookie, int fg, int bg, int flg, long *attr)
d172 40
a211 2
	struct rasops_info *ri = cookie;
	int swap;
d213 8
d228 4
a231 1
	if (ri->ri_depth <= 8) {
a233 9
	} else {
		bg = WSCOL_BLACK;
		fg = WSCOL_WHITE;
	}

	if ((flg & WSATTR_REVERSE) != 0) {
		swap = fg;
		fg = bg;
		bg = swap;
d240 9
d271 3
a302 1

d308 5
a312 1
		wdf->cmsize = 0;	/* until we can change it... */
a313 1

d317 10
a326 1

a364 1
#ifdef notyet
a368 1
#endif
d391 66
a477 1
#ifdef notyet
a481 1
#endif
@


1.7
log
@Introduce a wsdisplay type for mac68k frame buffers; we might need to become
less generic in the future, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.6 2006/01/09 20:51:48 miod Exp $	*/
d205 1
a205 1
macfb_attach_common(struct macfb_softc *sc, struct grfmode *gm)
d213 2
a214 2
	printf("%s: %dx%d ", sc->sc_dev.dv_xname, gm->width, gm->height);
	if (gm->psize == 1)
d217 1
a217 1
		printf("%d color", 1 << gm->psize);
d220 1
a220 1
	isconsole = macfb_is_console(sc->sc_basepa + gm->fboff);
d223 3
a225 2
		sc->sc_dc = &macfb_console_dc;
		sc->sc_dc->nscreens = 1;
d227 2
a228 15
		sc->sc_dc = malloc(sizeof(struct macfb_devconfig),
		    M_DEVBUF, M_WAITOK);
		sc->sc_dc->dc_vaddr = (vaddr_t)gm->fbbase;
		sc->sc_dc->dc_paddr = sc->sc_basepa;
		sc->sc_dc->dc_size = gm->fbsize;

		sc->sc_dc->dc_wid = gm->width;
		sc->sc_dc->dc_ht = gm->height;
		sc->sc_dc->dc_depth = gm->psize;
		sc->sc_dc->dc_rowbytes = gm->rowbytes;

		sc->sc_dc->dc_offset = gm->fboff;
		sc->sc_dc->nscreens = 0;

		if (macfb_init(sc->sc_dc) != 0)
d232 1
a232 1
	scrlist[0] = &sc->sc_dc->wsd;
d334 1
a334 1
macfb_cnattach(paddr_t addr)
d342 1
a342 1

a346 1

a348 1
	dc->dc_offset = m68k_page_offset(mac68k_vidphys);
d365 1
a365 1
	macfb_consaddr = addr;
@


1.6
log
@Ditch the grf frame buffer abstraction, and directly attach macfb to
either obio or nubus. No functional change, shaves a few more KB...
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.5 2006/01/08 20:35:21 miod Exp $	*/
d265 1
a265 1
		*(int *)data = 0;	/* XXX */
@


1.5
log
@Remove unused grf_softc members; do not keep temporary data in grf_softc
either, instead keep it on the stack or directly in attachment structures.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.4 2006/01/08 17:19:46 miod Exp $	*/
a42 1
#include <mac68k/dev/grfvar.h>
a51 7
int	macfb_match(struct device *, void *, void *);
void	macfb_attach(struct device *, struct device *, void *);

struct cfattach macfb_ca = {
	sizeof(struct macfb_softc), macfb_match, macfb_attach
};

a88 1
extern u_int32_t	mac68k_vidlog;
a203 6
int
macfb_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

d205 1
a205 1
macfb_attach(struct device *parent, struct device *self, void *aux)
a206 3
	struct grfbus_attach_args *ga = aux;
	struct grfmode *gm = &ga->ga_grfmode;
	struct macfb_softc *sc;
d212 7
a218 1
	sc = (struct macfb_softc *)self;
d220 1
a220 6
#ifdef DIAGNOSTIC	/* temporary */
	printf(" offset %p", gm->fboff);
#endif
	printf("\n");

	isconsole = macfb_is_console(ga->ga_phys + gm->fboff);
d229 1
a229 1
		sc->sc_dc->dc_paddr = ga->ga_phys;
d253 1
a253 1
	config_found(self, &waa, wsemuldisplaydevprint);
a254 1

@


1.4
log
@Advertize color on non-indexed modes, and swap blue and red at 16bpp (might be
necessary at 24 and 32bpp as well).
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.1 2006/01/04 20:39:05 miod Exp $	*/
d223 1
a223 1
	struct grfmode *gm = ga->ga_grfmode;
d237 1
a237 1
	isconsole = macfb_is_console(ga->ga_phys + ga->ga_grfmode->fboff);
@


1.3
log
@Use Nubus-related constants from <machine/cpu.h> instead of hardcoded values.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.2 2006/01/08 16:36:54 miod Exp $	*/
d142 10
d159 11
a169 9
	/*
	 * Until we know how to setup the colormap, constrain ourselves to
	 * mono mode. Note that we need to use our own alloc_attr routine
	 * to compensate for inverted black and white colors.
	 */
	ri->ri_ops.alloc_attr = macfb_alloc_attr;
	ri->ri_caps &= ~(WSSCREEN_WSCOLORS | WSSCREEN_HILIT);
	if (ri->ri_depth == 8)
		ri->ri_devcmap[15] = 0xffffffff;
@


1.2
log
@Switch macfb from an rcons backend to a rasops backend; supposedly restores
all pixel depth operation, but there are still font display problems at
4bpp and 16bpp at the moment; also make sure the display is white on black,
whichever colour depth we are in.
@
text
@d1 1
a1 1
/*	$OpenBSD: macfb.c,v 1.1 2006/01/04 20:39:05 miod Exp $	*/
d104 1
a104 2
	if (addr != macfb_consaddr &&
	    (addr >= 0xf9000000 && addr <= 0xfeffffff)) {
@


1.1
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 1
#include <mac68k/dev/macfbvar.h>
d48 2
d51 1
a51 3
#include <dev/rcons/raster.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/wscons/wsdisplayvar.h>
d53 2
a54 2
int macfb_match(struct device *, void *, void *);
void macfb_attach(struct device *, struct device *, void *);
a63 28
const struct wsdisplay_emulops macfb_emulops = {
	rcons_cursor,
	rcons_mapchar,
	rcons_putchar,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_alloc_attr
};

struct wsscreen_descr macfb_stdscreen = {
	"std",
	0, 0, /* will be filled in -- XXX shouldn't, it's global */
	&macfb_emulops,
	0, 0,
	WSSCREEN_REVERSE
};

const struct wsscreen_descr *_macfb_scrlist[] = {
	&macfb_stdscreen,
};

const struct wsscreen_list macfb_screenlist = {
	sizeof(_macfb_scrlist) / sizeof(struct wsscreen_descr *),
	_macfb_scrlist
};

d84 3
a86 1
void macfb_init(struct macfb_devconfig *);
a88 1
static int macfb_is_console(paddr_t);
d101 1
a101 1
static int
d121 2
a122 2
void
macfb_clear(struct macfb_devconfig *dc)
d124 25
a148 1
	int i, rows;
d150 19
a168 5
	/* clear the display */
	rows = dc->dc_ht;
	for (i = 0; rows-- > 0; i += dc->dc_rowbytes)
		memset((u_char *)dc->dc_vaddr + dc->dc_offset + i,
		    0, dc->dc_rowbytes);
d171 2
a172 2
void
macfb_init(struct macfb_devconfig *dc)
d174 2
a175 2
	struct raster *rap;
	struct rcons *rcp;
d177 14
a190 1
	macfb_clear(dc);
d192 5
a196 14
	rap = &dc->dc_raster;
	rap->width = dc->dc_wid;
	rap->height = dc->dc_ht;
	rap->depth = dc->dc_depth;
	rap->linelongs = dc->dc_rowbytes / sizeof(u_int32_t);
	rap->pixels = (u_int32_t *)(dc->dc_vaddr + dc->dc_offset);

	/* initialize the raster console blitter */
	rcp = &dc->dc_rcons;
	rcp->rc_sp = rap;
	rcp->rc_crow = rcp->rc_ccol = -1;
	rcp->rc_crowp = &rcp->rc_crow;
	rcp->rc_ccolp = &rcp->rc_ccol;
	rcons_init(rcp, 128, 192);
d198 2
a199 2
	macfb_stdscreen.nrows = dc->dc_rcons.rc_maxrow;
	macfb_stdscreen.ncols = dc->dc_rcons.rc_maxcol;
d215 2
d230 1
a230 1
		sc->nscreens = 1;
d232 2
a233 1
		sc->sc_dc = malloc(sizeof(struct macfb_devconfig), M_DEVBUF, M_WAITOK);
d244 1
d246 3
a248 1
		macfb_init(sc->sc_dc);
d250 3
a252 2
		sc->nscreens = 0;
	}
d255 1
a255 1
	waa.scrdata = &macfb_screenlist;
d277 3
a279 3
		wdf->height = dc->dc_raster.height;
		wdf->width = dc->dc_raster.width;
		wdf->depth = dc->dc_raster.depth;
d284 1
a284 1
		*(u_int *)data = dc->dc_rowbytes;
d318 1
a318 1
	long defattr;
d320 1
a320 1
	if (sc->nscreens > 0)
d323 11
a333 6
	*cookiep = &sc->sc_dc->dc_rcons; /* one and only for now */
	*curxp = 0;
	*curyp = 0;
	rcons_alloc_attr(&sc->sc_dc->dc_rcons, 0, 0, 0, &defattr);
	*defattrp = defattr;
	sc->nscreens++;
d342 1
a342 6
#ifdef DIAGNOSTIC
	if (sc->sc_dc == &macfb_console_dc)
		panic("cfb_free_screen: console");
#endif

	sc->nscreens--;
d349 1
a349 1
	return 0;
d357 1
d372 2
a373 1
	macfb_init(&macfb_console_dc);
d375 8
a382 1
	rcons_alloc_attr(&dc->dc_rcons, 0, 0, 0, &defattr);
d384 1
a384 2
	wsdisplay_cnattach(&macfb_stdscreen, &dc->dc_rcons,
			0, 0, defattr);
@

