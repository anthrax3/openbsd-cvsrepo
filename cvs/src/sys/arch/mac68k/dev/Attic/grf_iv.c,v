head	1.43;
access;
symbols
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.18
	OPENBSD_5_0:1.42.0.16
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.14
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.12
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.42.0.8
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.42.0.10
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.6
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.4
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.41.0.6
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.41.0.4
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.12
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.10
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.8
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.6
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.19.0.16
	UBC_BASE:1.19
	OPENBSD_3_0:1.19.0.14
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.19.0.12
	OPENBSD_2_9_BASE:1.19
	NIKLAS_UNDEAD:1.19.0.10
	OPENBSD_2_8:1.19.0.8
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.6
	OPENBSD_2_7_BASE:1.19
	SMP:1.19.0.4
	SMP_BASE:1.19
	kame_19991208:1.19
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.15.0.6
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.15.0.4
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.42;

1.42
date	2007.09.17.01.33.32;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.13.22.35.17;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.30.20.47.15;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.23.19.06.04;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.22.19.40.54;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.22.18.37.56;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.20.00.09.36;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.10.21.19.14;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.09.20.51.48;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.08.20.35.21;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.04.20.39.04;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.27.09.45.48;	author martin;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.27.07.15.19;	author martin;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.26.15.44.05;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.15.18.52.44;	author martin;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.06.19.51.43;	author martin;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.01.19.09.19;	author martin;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.01.11.19.33;	author martin;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.23.23.28.58;	author martin;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.08.06.57.48;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.03.06.40.13;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.04.24.06.39.40;	author downsj;	state Exp;
branches
	1.19.4.1
	1.19.16.1;
next	1.18;

1.18
date	99.01.11.05.11.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.05.03.07.12.55;	author gene;	state Exp;
branches;
next	1.16;

1.16
date	98.04.27.02.04.34;	author gene;	state Exp;
branches;
next	1.15;

1.15
date	97.04.21.00.58.14;	author briggs;	state Exp;
branches;
next	1.14;

1.14
date	97.03.30.22.44.03;	author briggs;	state Exp;
branches;
next	1.13;

1.13
date	97.03.29.03.16.18;	author briggs;	state Exp;
branches;
next	1.12;

1.12
date	97.03.18.05.54.01;	author briggs;	state Exp;
branches;
next	1.11;

1.11
date	97.03.18.05.37.50;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.03.14.14.15.22;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	97.03.12.13.26.37;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	97.03.08.16.16.51;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.01.35.30;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.10.28.14.46.24;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.09.21.03.47.13;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.08.10.21.37.43;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.35.21;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.18.13.37;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches;
next	;

1.19.4.1
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	;

1.19.16.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.43
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: grf_iv.c,v 1.42 2007/09/17 01:33:32 krw Exp $	*/
/*	$NetBSD: grf_iv.c,v 1.17 1997/02/20 00:23:27 scottr Exp $	*/

/*
 * Copyright (C) 1998 Scott Reynolds
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1995 Allen Briggs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Allen Briggs.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Graphics display driver for the Macintosh internal video for machines
 * that don't map it into a fake nubus card.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/viareg.h>

#include <uvm/uvm_extern.h>

#include <mac68k/dev/nubus.h>
#include <mac68k/dev/obiovar.h>

#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <mac68k/dev/macfbvar.h>

extern u_int32_t	mac68k_vidphys;
extern u_int32_t	mac68k_vidlen;
extern long		videoaddr;
extern long		videorowbytes;
extern long		videobitdepth;
extern u_long		videosize;

int	macfb_obio_match(struct device *, void *, void *);
void	macfb_obio_attach(struct device *, struct device *, void *);

struct cfattach macfb_obio_ca = {
	sizeof(struct macfb_softc), macfb_obio_match, macfb_obio_attach
};

#define DAFB_BASE		0xf9000000
#define DAFB_CONTROL_BASE	0xf9800000
#define	DAFB_CMAP_BASE		0xf9800200
#define CIVIC_BASE		0x50100000
#define CIVIC_CONTROL_BASE	0x50036000
#define VALKYRIE_BASE		0xf9000000
#define VALKYRIE_CONTROL_BASE	0x50f2a000

void	dafb_setcolor(void *, u_int, u_int);

int
macfb_obio_match(struct device *parent, void *vcf, void *aux)
{
	struct obio_attach_args *oa = (struct obio_attach_args *)aux;
	bus_space_handle_t bsh;
	static int found;

	if (found != 0)
		return (0);

	found = 1;

        switch (current_mac_model->class) {
	case MACH_CLASSQ2:
		if (current_mac_model->machineid != MACH_MACLC575)
			break;

		/*
		 * Note:  the only system in this class that does not have
		 * the Valkyrie chip -- at least, that we know of -- is
		 * the Performa/LC 57x series.  This system has a version
		 * of the DAFB controller, instead.
		 *
		 * If this assumption proves false, we'll have to be more
		 * intelligent here.
		 */
		/*FALLTHROUGH*/
	case MACH_CLASSQ:
		/*
		 * Assume DAFB for all of these, unless we can't
		 * access the memory.
		 */
		if (bus_space_map(oa->oa_tag, DAFB_CONTROL_BASE, 0x120, 0,
		    &bsh) != 0)
			return (0);

		if (mac68k_bus_space_probe(oa->oa_tag, bsh, 0x1c, 4) == 0 ||
		    mac68k_bus_space_probe(oa->oa_tag, bsh, 0x104, 4) == 0)
			found = 0;

		bus_space_unmap(oa->oa_tag, bsh, 0x120);
		break;
	case MACH_CLASSAV:
		break;
	case MACH_CLASSIIci:
	case MACH_CLASSIIsi:
		if (mac68k_vidlen == 0 ||
		    (via2_reg(rMonitor) & RBVMonitorMask) == RBVMonIDNone)
			found = 0;
		break;
	default:
		if (mac68k_vidlen == 0)
			found = 0;
		break;
	}

	return (found);
}

void
macfb_obio_attach(struct device *parent, struct device *self, void *aux)
{
	struct obio_attach_args *oa = (struct obio_attach_args *) aux;
	struct macfb_softc *sc = (struct macfb_softc *)self;
	u_long length;
	u_int32_t vbase1, vbase2;
	struct macfb_devconfig *dc;

	sc->card_id = 0;
	sc->sc_tag = oa->oa_tag;

	dc = malloc(sizeof(*dc), M_DEVBUF, M_WAITOK | M_ZERO);

        switch (current_mac_model->class) {
	case MACH_CLASSQ2:
		if (current_mac_model->machineid != MACH_MACLC575) {
			sc->sc_basepa = VALKYRIE_BASE;
			length = 0x00100000;		/* 1MB */

			if (sc->sc_basepa <= mac68k_vidphys &&
			    mac68k_vidphys < (sc->sc_basepa + length))
				sc->sc_fbofs = mac68k_vidphys - sc->sc_basepa;
			else
				sc->sc_fbofs = 0;

#ifdef DEBUG
			printf(" @@ %lx", sc->sc_basepa + sc->sc_fbofs);
#endif

			if (bus_space_map(sc->sc_tag, VALKYRIE_CONTROL_BASE,
			    0x40, 0, &sc->sc_regh) != 0) {
				printf(": can't map Valkyrie registers\n");
				free(dc, M_DEVBUF);
				return;
			}
			/* Disable interrupts */
			bus_space_write_1(sc->sc_tag, sc->sc_regh, 0x18, 0x1);
			bus_space_unmap(sc->sc_tag, sc->sc_regh, 0x40);

			printf(": Valkyrie\n");
			break;
		}
		/*
		 * Note:  the only system in this class that does not have
		 * the Valkyrie chip -- at least, that we know of -- is
		 * the Performa/LC 57x series.  This system has a version
		 * of the DAFB controller, instead.
		 *
		 * If this assumption proves false, we'll have to be more
		 * intelligent here.
		 */
		/*FALLTHROUGH*/
        case MACH_CLASSQ:
		if (bus_space_map(sc->sc_tag, DAFB_CONTROL_BASE, 0x120, 0,
		    &sc->sc_regh)) {
			printf(": can't map DAFB registers\n");
			free(dc, M_DEVBUF);
			return;
		}

		sc->sc_basepa = DAFB_BASE;
		length = 0x00100000;		/* 1MB */

		/* Compute the current frame buffer offset */
		vbase1 = bus_space_read_4(sc->sc_tag, sc->sc_regh, 0x0) & 0xfff;

		/*
		 * XXX The following exists because the DAFB v7 in these
		 * systems doesn't return reasonable values to use for fbofs.
		 * Ken'ichi Ishizaka gets credit for this hack.  (sar 19990426)
		 * (Does this get us the correct result for _all_ DAFB-
		 * equipped systems and monitor combinations?  It seems
		 * possible, if not likely...)
		 */
		switch (current_mac_model->machineid) {
		case MACH_MACLC475:
		case MACH_MACLC475_33:
		case MACH_MACLC575:
		case MACH_MACQ605:
		case MACH_MACQ605_33:
			vbase1 &= 0x3f;
			break;
		}
		vbase2 = bus_space_read_4(sc->sc_tag, sc->sc_regh, 0x4) & 0xf;
		sc->sc_fbofs = (vbase1 << 9) | (vbase2 << 5);

#ifdef DEBUG
		printf(" @@ %lx", sc->sc_basepa + sc->sc_fbofs);
#endif

		/* Disable interrupts */
		bus_space_write_4(sc->sc_tag, sc->sc_regh, 0x104, 0);

		/* Clear any pending interrupts */
		bus_space_write_4(sc->sc_tag, sc->sc_regh, 0x10C, 0);
		bus_space_write_4(sc->sc_tag, sc->sc_regh, 0x110, 0);
		bus_space_write_4(sc->sc_tag, sc->sc_regh, 0x114, 0);

		printf(": DAFB, monitor sense %x\n",
		    (bus_space_read_4(sc->sc_tag, sc->sc_regh, 0x1c) & 0x7));

		bus_space_unmap(sc->sc_tag, sc->sc_regh, 0x120);

		if (bus_space_map(sc->sc_tag, DAFB_CMAP_BASE, 0x20, 0,
		    &sc->sc_regh) == 0) {
			dc->dc_cmapregs = (vaddr_t)bus_space_vaddr(sc->sc_tag,
			    sc->sc_regh);
			dc->dc_setcolor = dafb_setcolor;
		}

		break;
	case MACH_CLASSAV:
		sc->sc_basepa = CIVIC_BASE;
		length = 0x00200000;		/* 2MB */

		if (sc->sc_basepa <= mac68k_vidphys &&
		    mac68k_vidphys < (sc->sc_basepa + length))
			sc->sc_fbofs = mac68k_vidphys - sc->sc_basepa;
		else
			sc->sc_fbofs = 0;

#ifdef DEBUG
		printf(" @@ %lx", sc->sc_basepa + sc->sc_fbofs);
#endif

		if (bus_space_map(sc->sc_tag, CIVIC_CONTROL_BASE, PAGE_SIZE,
		    0, &sc->sc_regh) != 0) {
			printf(": can't map Civic registers\n");
			free(dc, M_DEVBUF);
			return;
		}

		/* Disable interrupts */
		bus_space_write_1(sc->sc_tag, sc->sc_regh, 0x120, 0);
		bus_space_unmap(sc->sc_tag, sc->sc_regh, PAGE_SIZE);

		printf(": Civic\n");
		break;
	case MACH_CLASSIIci:
	case MACH_CLASSIIsi:
		sc->sc_basepa = trunc_page(mac68k_vidphys);
		sc->sc_fbofs = m68k_page_offset(mac68k_vidphys);
		length = mac68k_vidlen + sc->sc_fbofs;

#ifdef DEBUG
		printf(" @@ %lx: RBV", sc->sc_basepa + sc->sc_fbofs);
		switch (via2_reg(rMonitor) & RBVMonitorMask) {
		case RBVMonIDBWP:
			printf(", 15\" monochrome portrait");
			break;
		case RBVMonIDRGB12:
			printf(", 12\" color");
			break;
		case RBVMonIDRGB15:
			printf(", 15\" color");
			break;
		case RBVMonIDStd:
			printf(", Macintosh II");
			break;
		default:
			printf(", unrecognized");
			break;
		}
		printf(" display\n");
#else
		printf(": RBV\n");
#endif

		break;
	default:
		sc->sc_basepa = trunc_page(mac68k_vidphys);
		sc->sc_fbofs = m68k_page_offset(mac68k_vidphys);
		length = mac68k_vidlen + sc->sc_fbofs;

#ifdef DEBUG
		printf(" @@ %lx:", sc->sc_basepa + sc->sc_fbofs);
#endif
		printf(": On-board video\n");
		break;
	}

	if (bus_space_map(sc->sc_tag, sc->sc_basepa, length, 0,
	    &sc->sc_handle)) {
		printf("%s: failed to map video RAM\n", sc->sc_dev.dv_xname);
		free(dc, M_DEVBUF);
		return;
	}

	if (sc->sc_basepa <= mac68k_vidphys &&
	    mac68k_vidphys < (sc->sc_basepa + length))
		videoaddr =
		    (vaddr_t)bus_space_vaddr(sc->sc_tag, sc->sc_handle) +
		    sc->sc_fbofs;

	dc->dc_vaddr = (vaddr_t)bus_space_vaddr(sc->sc_tag, sc->sc_handle);
	dc->dc_paddr = sc->sc_basepa;
	dc->dc_offset = sc->sc_fbofs;
	dc->dc_wid = videosize & 0xffff;
	dc->dc_ht = (videosize >> 16) & 0xffff;
	dc->dc_depth = videobitdepth;
	dc->dc_rowbytes = videorowbytes;
	dc->dc_size = dc->dc_ht * dc->dc_rowbytes;

	/* Perform common video attachment. */
	macfb_attach_common(sc, dc);
}

/*
 * Basic indexed modes palette handling.
 */

void
dafb_setcolor(void *v, u_int start, u_int end)
{
	struct macfb_devconfig *dc = v;
	u_int i;
	u_int8_t *c;

	c = dc->dc_cmap;

	/*
	 * DAFB can not start a colormap update at a color index different
	 * than zero, so we need to reprogram all slots below the requested
	 * range.
	 */
	*(volatile u_int32_t *)(dc->dc_cmapregs) = 0;
	for (i = 0; i < end; i++) {
		*(volatile u_int8_t *)(dc->dc_cmapregs + 0x13) = *c++;
		*(volatile u_int8_t *)(dc->dc_cmapregs + 0x13) = *c++;
		*(volatile u_int8_t *)(dc->dc_cmapregs + 0x13) = *c++;
	}
}
@


1.42
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.41 2006/03/13 22:35:17 miod Exp $	*/
@


1.41
log
@Put wsscreen_list array inside the softc instead of on the stack; similar fix
as happened on hp300 and sparc* yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.40 2006/01/30 20:47:15 miod Exp $	*/
d178 1
a178 2
	dc = malloc(sizeof(*dc), M_DEVBUF, M_WAITOK);
	bzero(dc, sizeof(*dc));
@


1.40
log
@Do not disable frame buffer interrupts in the match() function, but rather
in attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.39 2006/01/23 19:06:04 miod Exp $	*/
a369 1
	dc->nscreens = 0;
@


1.39
log
@Be more careful when mapping DAFB color registers, so that we don't prevent
esp to map the turbo registers on Q700/900/950.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.38 2006/01/22 19:40:54 miod Exp $	*/
a112 1
	u_int base;
d121 2
a122 5
		if (current_mac_model->machineid != MACH_MACLC575) {
			base = VALKYRIE_CONTROL_BASE;

			if (bus_space_map(oa->oa_tag, base, 0x40, 0, &bsh))
				return (0);
a123 6
			/* Disable interrupts */
			bus_space_write_1(oa->oa_tag, bsh, 0x18, 0x1);

			bus_space_unmap(oa->oa_tag, bsh, 0x40);
			break;
		}
d139 2
a140 3
		base = DAFB_CONTROL_BASE;

		if (bus_space_map(oa->oa_tag, base, 0x20, 0, &bsh))
d143 3
a145 6
		if (mac68k_bus_space_probe(oa->oa_tag, bsh, 0x1c, 4) == 0) {
			bus_space_unmap(oa->oa_tag, bsh, 0x20);
			return (0);
		}

		bus_space_unmap(oa->oa_tag, bsh, 0x20);
d147 1
a147 17
		if (bus_space_map(oa->oa_tag, base + 0x100, 0x20, 0, &bsh))
			return (0);

		if (mac68k_bus_space_probe(oa->oa_tag, bsh, 0x04, 4) == 0) {
			bus_space_unmap(oa->oa_tag, bsh, 0x20);
			return (0);
		}

		/* Disable interrupts */
		bus_space_write_4(oa->oa_tag, bsh, 0x04, 0);

		/* Clear any interrupts */
		bus_space_write_4(oa->oa_tag, bsh, 0x0C, 0);
		bus_space_write_4(oa->oa_tag, bsh, 0x10, 0);
		bus_space_write_4(oa->oa_tag, bsh, 0x14, 0);

		bus_space_unmap(oa->oa_tag, bsh, 0x20);
a149 9
		base = CIVIC_CONTROL_BASE;

		if (bus_space_map(oa->oa_tag, base, 0x1000, 0, &bsh))
			return (0);

		/* Disable interrupts */
		bus_space_write_1(oa->oa_tag, bsh, 0x120, 0);

		bus_space_unmap(oa->oa_tag, bsh, 0x1000);
d176 1
d196 11
d210 9
a218 1
		/* See note in grfiv_match() */
d221 1
a221 2
		sc->sc_tag = oa->oa_tag;
		if (bus_space_map(sc->sc_tag, DAFB_CONTROL_BASE, 0x20, 0,
d223 1
a223 1
			printf(": failed to map DAFB register space\n");
d257 9
d269 1
a269 1
		bus_space_unmap(sc->sc_tag, sc->sc_regh, 0x20);
d292 12
@


1.38
log
@Colormap support for DAFB frame buffers (using information from Linux).
However, color can not be enabled in emulation mode if the display is the
console at this point, but 8bpp X11 works.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.37 2006/01/22 18:37:56 miod Exp $	*/
d241 1
a241 1
		if (bus_space_map(sc->sc_tag, DAFB_CONTROL_BASE, PAGE_SIZE, 0,
d280 8
a287 4
		dc->dc_cmapregs =
		    (vaddr_t)bus_space_vaddr(sc->sc_tag, sc->sc_regh) +
		    (DAFB_CMAP_BASE - DAFB_CONTROL_BASE);
		dc->dc_setcolor = dafb_setcolor;
@


1.37
log
@Add bus_space_vaddr() and use it instead of accessing private bus_space
fields. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.36 2006/01/20 00:09:36 miod Exp $	*/
d99 1
d105 2
d210 1
a210 1
	u_long base, length;
d216 3
a239 1
		base = DAFB_CONTROL_BASE;
d241 2
a242 1
		if (bus_space_map(sc->sc_tag, base, 0x20, 0, &sc->sc_regh)) {
d244 1
d280 5
a284 1
		bus_space_unmap(sc->sc_tag, sc->sc_regh, 0x20);
d347 1
a356 3
	dc = malloc(sizeof(*dc), M_DEVBUF, M_WAITOK);
	bzero(dc, sizeof(*dc));
	
d369 26
@


1.36
log
@Make sure we can only match once for internal video.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.35 2006/01/10 21:19:14 miod Exp $	*/
d341 3
a343 1
		videoaddr = sc->sc_handle.base + sc->sc_fbofs; /* XXX big ol' hack */
d348 1
a348 1
	dc->dc_vaddr = (vaddr_t)sc->sc_handle.base; /* XXX yet another hack */
@


1.35
log
@Simplify external macfb interfaces, kill an intermediate attachment structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.34 2006/01/09 20:51:48 miod Exp $	*/
d109 1
a109 1
	int found;
d111 3
@


1.34
log
@Ditch the grf frame buffer abstraction, and directly attach macfb to
either obio or nubus. No functional change, shaves a few more KB...
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.33 2006/01/08 20:35:21 miod Exp $	*/
d67 1
d206 1
a206 1
	struct grfmode gm;
d340 12
a351 7
	gm.psize = videobitdepth;
	gm.width = videosize & 0xffff;
	gm.height = (videosize >> 16) & 0xffff;
	gm.rowbytes = videorowbytes;
	gm.fbsize = gm.height * gm.rowbytes;
	gm.fbbase = (caddr_t)sc->sc_handle.base; /* XXX yet another hack */
	gm.fboff = sc->sc_fbofs;
d354 1
a354 1
	macfb_attach_common(sc, &gm);
@


1.33
log
@Remove unused grf_softc members; do not keep temporary data in grf_softc
either, instead keep it on the stack or directly in attachment structures.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.32 2006/01/04 20:39:04 miod Exp $	*/
d58 1
a65 5
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/proc.h>
d77 4
a80 1
#include <mac68k/dev/grfvar.h>
d89 2
a90 6
static int	grfiv_match(struct device *, void *, void *);
static void	grfiv_attach(struct device *, struct device *, void *);

struct cfdriver intvid_cd = {
	NULL, "intvid", DV_DULL
};
d92 2
a93 2
struct cfattach intvid_ca = {
	sizeof(struct grfbus_softc), grfiv_match, grfiv_attach
d103 2
a104 5
static int
grfiv_match(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
d119 1
a119 1
				return 0;
d145 1
a145 1
			return 0;
d149 1
a149 1
			return 0;
d155 1
a155 1
			return 0;
d159 1
a159 1
			return 0;
d176 1
a176 1
			return 0;
d195 1
a195 1
	return found;
d198 2
a199 4
static void
grfiv_attach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
d202 1
a202 2
	struct grfbus_softc *sc;
	struct grfmode gm;
d205 1
a205 2

	sc = (struct grfbus_softc *)self;
d266 1
a266 1
		printf(": DAFB: monitor sense %x\n",
d293 1
a293 4
		printf(" @@ %lx", sc->sc_basepa + sc->sc_fbofs);
#endif
		printf(": RBV");
#ifdef DEBUG
d296 1
a296 1
			printf(": 15\" monochrome portrait");
d299 1
a299 1
			printf(": 12\" color");
d302 1
a302 1
			printf(": 15\" color");
d305 1
a305 1
			printf(": Macintosh II");
d308 1
a308 1
			printf(": unrecognized");
d311 3
a313 1
		printf(" display");
a314 1
		printf("\n");
d322 4
a325 2
		printf(" @@ %lx: On-board video\n",
		    sc->sc_basepa + sc->sc_fbofs);
d348 1
a348 1
	grf_establish(sc, &gm);
@


1.32
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.31 2005/09/27 09:45:48 martin Exp $	*/
d213 1
a213 1
	struct grfmode *gm;
d351 7
a357 12
	gm = &(sc->curr_mode);
	gm->mode_id = 0;
	gm->psize = videobitdepth;
	gm->ptype = 0;
	gm->width = videosize & 0xffff;
	gm->height = (videosize >> 16) & 0xffff;
	gm->rowbytes = videorowbytes;
	gm->hres = 80;				/* XXX Hack */
	gm->vres = 80;				/* XXX Hack */
	gm->fbsize = gm->height * gm->rowbytes;
	gm->fbbase = (caddr_t)sc->sc_handle.base; /* XXX yet another hack */
	gm->fboff = sc->sc_fbofs;
d360 1
a360 1
	grf_establish(sc);
@


1.31
log
@- don't mess with SCSI controller bits here, only map the two regions
  we need
- unmap Valkyrie register space after matching, we don't use it later

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.30 2005/09/27 07:15:19 martin Exp $	*/
a74 1
#include <machine/grfioctl.h>
a89 1
static int	grfiv_mode(struct grf_softc *gp, int cmd, void *arg);
d365 1
a365 21
	grf_establish(sc, NULL, grfiv_mode);
}

static int
grfiv_mode(sc, cmd, arg)
	struct grf_softc *sc;
	int cmd;
	void *arg;
{
	switch (cmd) {
	case GM_GRFON:
	case GM_GRFOFF:
		return 0;
	case GM_CURRMODE:
		break;
	case GM_NEWMODE:
		break;
	case GM_LISTMODES:
		break;
	}
	return EINVAL;
@


1.30
log
@missing pieces for RBV video handling

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.29 2005/09/26 15:44:05 martin Exp $	*/
d133 2
d154 1
a154 1
		if (bus_space_map(oa->oa_tag, base, 0x1000, 0, &bsh))
d158 1
a158 1
			bus_space_unmap(oa->oa_tag, bsh, PAGE_SIZE);
d162 9
a170 3
		/* Set "Turbo SCSI" configuration to default */
		bus_space_write_4(oa->oa_tag, bsh, 0x24, 0x1d1); /* ch0 */
		bus_space_write_4(oa->oa_tag, bsh, 0x28, 0x1d1); /* ch1 */
d173 1
a173 1
		bus_space_write_4(oa->oa_tag, bsh, 0x104, 0);
d176 3
a178 3
		bus_space_write_4(oa->oa_tag, bsh, 0x10C, 0);
		bus_space_write_4(oa->oa_tag, bsh, 0x110, 0);
		bus_space_write_4(oa->oa_tag, bsh, 0x114, 0);
d180 1
a180 1
		bus_space_unmap(oa->oa_tag, bsh, PAGE_SIZE);
d246 1
a246 1
		if (bus_space_map(sc->sc_tag, base, 0x1000, 0, &sc->sc_regh)) {
d283 1
a283 1
		bus_space_unmap(sc->sc_tag, sc->sc_regh, 0x1000);
@


1.29
log
@- correct framebuffer calculation offset by marking off garbage bits in
  the DAFB v7
- treat the Quadra 605 like the LC47x

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.28 2005/09/15 18:52:44 martin Exp $	*/
d185 6
d291 33
@


1.28
log
@get rid of MD m68k_trunc_page and m68k_round_page and replace by MI
trunc_page and round_page

go go go! miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.27 2005/09/12 10:07:29 martin Exp $	*/
d242 1
a242 3
		vbase2 = bus_space_read_4(sc->sc_tag, sc->sc_regh, 0x4) & 0xf;
		sc->sc_fbofs = (vbase1 << 9) | (vbase2 << 5);
#if 1
d244 6
a249 2
		 * XXX The following hack exists because the DAFB v7 in these
		 * systems doesn't compute fbofs correctly. (sar 19980813)
d255 3
a257 1
			sc->sc_fbofs = 0x1000;
d260 2
a261 1
#endif
@


1.27
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.26 2005/08/06 19:51:43 martin Exp $	*/
d78 2
d282 1
a282 1
		sc->sc_basepa = m68k_trunc_page(mac68k_vidphys);
@


1.26
log
@overhaul the grf driver:

- Simplify grfmv_phys() to work like grfiv_phys(), and eliminate the
  second argument to both, as we don't use it anyway.
- Handle fbbase and fboff consistently throughout.
- Eliminate grfaddr() by pulling it into grfmmap(), which is the
  only place it was used, previously.
- grfmap() now gets the physical address of the framebuffer from
  the appropriate driver, rather than try to compute it by itself.
  Be careful with aligning the base to a page address and increase
  the length of the mapped region appropriately.
- Store the PA of the framebuffer in the softc.  This eliminates the need
  for the sc_phys callback; we can just store the PA in the grfbus attach
  args, rather than a function pointer, which simplifies the code nicely.
- Disable Valkyrie interrupts on the Quadra 630
- New and improved console framebuffer initialization and autoconfig.  This
  resolves a great many issues, including Performa 58x interrupt handling
  and offset displays on some models.
- Remove unused grf ioctls
- Some KNF and other minor things

help and ok miod@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.25 2005/08/01 19:09:19 martin Exp $	*/
d281 1
a281 1
		sc->sc_fbofs = mac68k_vidphys & PGOFSET;
d297 1
a297 1
		videoaddr = sc->sc_handle + sc->sc_fbofs; /* XXX big ol' hack */
d309 1
a309 1
	gm->fbbase = (caddr_t)sc->sc_handle;	/* XXX yet another hack */
@


1.25
log
@unmap correct size, oops
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.24 2005/08/01 11:19:33 martin Exp $	*/
d5 26
a63 1

d78 3
a80 3
#include "nubus.h"
#include "obiovar.h"
#include "grfvar.h"
a81 1
extern u_int32_t	mac68k_vidlog;
d83 2
d87 1
a87 1
extern unsigned long	videosize;
a89 1
static caddr_t	grfiv_phys(struct grf_softc *gp, vaddr_t addr);
d101 3
a103 1
#define QUADRA_DAFB_BASE	0xF9800000
d105 2
d114 4
a117 3
	struct obio_attach_args *oa = (struct obio_attach_args *) aux;
	bus_space_handle_t	bsh;
	int			found, sense;
a121 1
	case MACH_CLASSQ:
d123 5
d129 15
d148 1
d150 2
a151 4
		if (bus_space_map(oa->oa_tag, QUADRA_DAFB_BASE, PAGE_SIZE,
					0, &bsh)) {
			panic("failed to map space for DAFB regs.");
		}
d153 1
a153 1
		if (mac68k_bus_space_probe(oa->oa_tag, bsh, 0x1C, 4) == 0) {
d155 1
a155 2
			found = 0;
			goto nodafb;
a157 7
		sense = (bus_space_read_4(oa->oa_tag, bsh, 0x1C) & 7);

#if 0	/* when using a non-Apple monitor with an adapter, sense is zero */
		if (sense == 0)
			found = 0;
#endif

d171 3
d175 2
a176 1
		break;
a177 5
	case MACH_CLASSAV:
		if (bus_space_map(oa->oa_tag, CIVIC_CONTROL_BASE, 0x1000,
					0, &bsh)) {
			panic("failed to map space for CIVIC control regs.\n");	
		}
d180 1
a182 1

d184 1
a184 2
nodafb:
		if (mac68k_vidlog == 0) {
a185 2
		}

a191 2
#define R4(sc, o) (bus_space_read_4((sc)->sc_tag, (sc)->sc_regh, o) & 0xfff)

d198 4
a201 2
	struct grfbus_softc	*sc;
	struct grfmode		*gm;
d203 1
a203 1
	sc = (struct grfbus_softc *) self;
d208 19
d228 1
a228 1
        case MACH_CLASSQ2:
d230 23
a252 3
		if (bus_space_map(sc->sc_tag, QUADRA_DAFB_BASE, 0x20,
					0, &sc->sc_regh)) {
			panic("failed to map space for DAFB regs.");
d254 24
a277 2
		printf(": DAFB: Monitor sense %x.\n", R4(sc,0x1C)&7);
		bus_space_unmap(sc->sc_tag, sc->sc_regh, 0x20);
d280 6
a285 1
		printf(": Internal Video\n");
d289 10
d306 5
a310 5
	gm->hres = 80;		/* XXX Hack */
	gm->vres = 80;		/* XXX Hack */
	gm->fbsize = gm->rowbytes * gm->height;
	gm->fbbase = (caddr_t) m68k_trunc_page(mac68k_vidlog);
	gm->fboff = mac68k_vidlog & PGOFSET;
d313 1
a313 1
	grf_establish(sc, NULL, grfiv_mode, grfiv_phys);
a333 12
}

static caddr_t
grfiv_phys(gp, addr)
	struct grf_softc *gp;
	vaddr_t addr;
{
	/*
	 * If we're using IIsi or similar, this will be 0.
	 * If we're using IIvx or similar, this will be correct.
	 */
	return (caddr_t) mac68k_vidphys;
@


1.24
log
@- disable video interrupts on AV machines
- unmap unused DAFB registers on all other Quadras after attachment

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.23 2005/07/23 23:28:58 martin Exp $	*/
d180 1
a180 1
		bus_space_unmap(sc->sc_tag, sc->sc_regh, 0x1000);
@


1.23
log
@vm_offset_t -> {vaddr_t, bus_addr_t}
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.22 2004/12/08 06:57:48 miod Exp $	*/
d77 1
d134 10
d180 1
@


1.22
log
@Only map the DAFB video registers in attach, so that other code can map
the non-video parts. Will be necessary shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.21 2004/12/03 06:40:13 miod Exp $	*/
d64 1
a64 1
static caddr_t	grfiv_phys(struct grf_softc *gp, vm_offset_t addr);
d215 1
a215 1
	vm_offset_t addr;
@


1.21
log
@Always attach intvid even if the monitor sense code seems wrong; this is
the case with non-Apple monitors connected with video adaptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.20 2002/03/14 01:26:35 millert Exp $	*/
d99 1
a99 1
		if (bus_space_map(oa->oa_tag, QUADRA_DAFB_BASE, 0x1000,
d105 1
a105 1
			bus_space_unmap(oa->oa_tag, bsh, 0x1000);
d129 1
a129 1
		bus_space_unmap(oa->oa_tag, bsh, 0x1000);
d164 1
a164 1
		if (bus_space_map(sc->sc_tag, QUADRA_DAFB_BASE, 0x1000,
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.19 1999/04/24 06:39:40 downsj Exp $	*/
d112 1
d115 1
@


1.19
log
@Use the generic m68k param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.18 1999/01/11 05:11:34 millert Exp $	*/
d63 4
a66 4
static int	grfiv_mode __P((struct grf_softc *gp, int cmd, void *arg));
static caddr_t	grfiv_phys __P((struct grf_softc *gp, vm_offset_t addr));
static int	grfiv_match __P((struct device *, void *, void *));
static void	grfiv_attach __P((struct device *, struct device *, void *));
@


1.19.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.19 1999/04/24 06:39:40 downsj Exp $	*/
d63 4
a66 4
static int	grfiv_mode(struct grf_softc *gp, int cmd, void *arg);
static caddr_t	grfiv_phys(struct grf_softc *gp, vm_offset_t addr);
static int	grfiv_match(struct device *, void *, void *);
static void	grfiv_attach(struct device *, struct device *, void *);
@


1.19.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 4
a66 4
static int	grfiv_mode(struct grf_softc *gp, int cmd, void *arg);
static caddr_t	grfiv_phys(struct grf_softc *gp, vm_offset_t addr);
static int	grfiv_match(struct device *, void *, void *);
static void	grfiv_attach(struct device *, struct device *, void *);
@


1.18
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.17 1998/05/03 07:12:55 gene Exp $	*/
d183 1
a183 1
	gm->fbbase = (caddr_t) mac68k_trunc_page(mac68k_vidlog);
@


1.17
log
@Associated fallout from removing macinfo.h and merging to cpu.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.16 1998/04/27 02:04:34 gene Exp $	*/
d101 1
a101 1
			panic("failed to map space for DAFB regs.\n");
d164 1
a164 1
			panic("failed to map space for DAFB regs.\n");
@


1.16
log
@Adapt to new bus_space functions after fixing namespace issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.15 1997/04/21 00:58:14 briggs Exp $	*/
a49 1
#include <machine/macinfo.h>
@


1.15
log
@Take care when accessing DAFB--some quadra-class machines use other video
controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.14 1997/03/30 22:44:03 briggs Exp $	*/
d105 1
a105 1
		if (bus_probe(oa->oa_tag, bsh, 0x1C, 4) == 0) {
@


1.14
log
@Minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.13 1997/03/29 03:16:18 briggs Exp $	*/
d92 2
a93 2
        case MACH_CLASSQ:
        case MACH_CLASSQ2:
d95 4
a98 1
		/* Assume DAFB for all of these */
d105 6
d133 1
@


1.13
log
@A bit more DAFB initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.12 1997/03/18 05:54:01 briggs Exp $	*/
a76 5
/* XXX -- kludge */
#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/vm_map.h>

a156 1
		/* Show off a bit -- no need to really set these. */
@


1.12
log
@Bad idea to reset mac68k_vidphys/videorowbytes here.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.11 1997/03/18 05:37:50 briggs Exp $	*/
d112 4
d127 1
@


1.11
log
@Handle DAFB better.  Only configure if we think a monitor is attached and
disable interrupts from the bloody card in any case.  Also snag video
address and rowbytes from the controller, too, just for fun.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.10 1997/03/14 14:15:22 briggs Exp $	*/
a157 3
		mac68k_vidphys = (R4(sc, 0) << 9) | ((R4(sc, 4) & 0xf) << 5);
		mac68k_vidphys += 0xF9000000;
		videorowbytes = R4(sc,8) << 2;
@


1.10
log
@Use macro to truncate page.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.9 1997/03/12 13:26:37 briggs Exp $	*/
d55 1
a68 2
static void	grfiv_q700intr __P((void *client_data, int slot));

d82 1
a82 10
static void
grfiv_q700intr(client_data, slot)
	void *client_data;
	int slot;
{
	long	*addr;

	addr = (long *) ((char *) client_data + 0x10c);
	*addr = 0;
}
d90 18
a107 1
	char		*addr = NULL;
d109 12
a120 3
	if (mac68k_vidlog == 0) {
		return 0;
	}
a121 4
	switch (mac68k_machine.machineid) {
	case MACH_MACQ700:
		addr = nubus_mapin(0xf9800000, 0x1000);
		add_nubus_intr(15, grfiv_q700intr, addr);
d124 4
d131 1
a131 1
	return 1;
d134 2
d141 1
d149 18
a166 1
	printf(": Internal Video\n");
@


1.9
log
@Fix for bizarre internal framebuffers that don't start on page boundaries.
Dave Huang found this one...
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.8 1997/03/08 16:16:51 briggs Exp $	*/
d142 1
a142 1
	gm->fbbase = (caddr_t) (mac68k_vidlog & ~PGOFSET);
@


1.8
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.7 1997/01/24 01:35:30 briggs Exp $	*/
d65 1
a65 1
static int	grfiv_match __P((struct device *, struct cfdata *, void *));
d95 1
a95 1
grfiv_match(parent, cf, aux)
d97 1
a97 1
	struct cfdata *cf;
a100 1
	static int	internal_video_found = 0;
d102 1
a102 1
	if (internal_video_found || (mac68k_vidlog == 0)) {
d142 2
a143 2
	gm->fbbase = (caddr_t) mac68k_vidlog;
	gm->fboff = 0;
@


1.7
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf_iv.c,v 1.6 1996/10/28 14:46:24 briggs Exp $	*/
/*	$NetBSD: grf_iv.c,v 1.16 1996/12/16 16:17:06 scottr Exp $	*/
d48 1
@


1.6
log
@Include macinfo.h.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf_iv.c,v 1.5 1996/09/21 03:47:13 briggs Exp $	*/
/*	$NetBSD: grf_iv.c,v 1.13 1996/08/04 06:03:52 scottr Exp $	*/
d64 1
a64 1
static int	grfiv_match __P((struct device *, void *, void *));
d77 5
d94 4
a97 3
grfiv_match(pdp, match, auxp)
	struct device	*pdp;
	void	*match, *auxp;
d108 1
a108 1
		addr = bus_mapin(BUS_NUBUS, 0xf9800000, 0x1000);
@


1.5
log
@Initial support for Quadra 700 internal video interrupt handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.4 1996/08/10 21:37:43 briggs Exp $	*/
d49 1
@


1.4
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_iv.c,v 1.3 1996/05/26 18:35:21 briggs Exp $	*/
d47 2
d50 1
a50 1
#include <machine/cpu.h>
d66 2
d76 11
d92 1
d97 9
@


1.3
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: grf_iv.c,v 1.12 1996/05/19 22:27:06 scottr Exp $	*/
d114 1
a114 1
	grf_establish(sc, grfiv_mode, grfiv_phys);
@


1.2
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: grf_iv.c,v 1.10 1995/08/11 17:48:19 briggs Exp $	*/
d44 1
a51 4
extern int	grfiv_probe __P((struct grf_softc *sc, nubus_slot *ignore));
extern int	grfiv_init __P((struct grf_softc *sc));
extern int	grfiv_mode __P((struct grf_softc *sc, int cmd, void *arg));

d58 17
a74 4
extern int
grfiv_probe(sc, slotinfo)
	struct grf_softc *sc;
	nubus_slot *slotinfo;
d82 1
a82 12
	if (   (NUBUS_SLOT_TO_BASE(slotinfo->slot) <= mac68k_vidlog)
	    && (mac68k_vidlog < NUBUS_SLOT_TO_BASE(slotinfo->slot + 1))) {
		internal_video_found++;
		return 1;
	}

	if (slotinfo->slot == NUBUS_INT_VIDEO_PSUEDO_SLOT) {
		internal_video_found++;
		return 1;
	}

	return 0;
d85 4
a88 3
extern int
grfiv_init(sc)
	struct	grf_softc *sc;
d90 4
a93 2
	struct grfmode *gm;
	int i, j;
d97 1
a97 1
	strcpy(sc->card_name, "Internal video");
d112 2
a113 1
	return 1;
d116 1
a116 1
extern int
d136 1
a136 1
extern caddr_t
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
