head	1.31;
access;
symbols
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.25.0.6
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.21
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_9_BASE:1.9
	NIKLAS_UNDEAD:1.9.0.10
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2006.01.04.20.39.04;	author miod;	state dead;
branches;
next	1.30;

1.30
date	2005.10.23.19.00.26;	author martin;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.15.18.52.44;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.06.19.51.43;	author martin;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.23.23.28.58;	author martin;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.26.16.35.56;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.23.16.51.11;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.23.27.48;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.09.23.09.21;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.29.18.30.21;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.28.13.47.38;	author art;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.11.23.07.12;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.04.22.37;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.17.18.48.35;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.10.21.08.48;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.10.07.59.05;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.08.17.30.39;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	99.04.24.06.39.40;	author downsj;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	98.11.20.23.57.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.03.12.13.36.57;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	97.03.08.16.16.50;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	97.01.24.01.35.29;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.08.10.21.37.43;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.35.20;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.18.13.36;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.03;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.07.04.10.18.26;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2002.03.06.01.05.35;	author niklas;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.9.4.8;

1.9.4.8
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.9.4.9;

1.9.4.9
date	2003.06.07.11.13.13;	author ho;	state Exp;
branches;
next	1.9.4.10;

1.9.4.10
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.36.18;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Import NetBSD's direct adb code on mac68k, switching to real keyboard and mouse
drivers, and to wscons as the console; a few parts borrowed from OpenBSD/macppc
as well.

Currently only working with displays configured in 1bpp or 8bpp modes; this
limitation will be worked on ASAP.

Tested by claudio@@ kettenis@@ martin@@ nick@@ and I on various models. X11 changes
coming soon.
@
text
@/*	$OpenBSD: grf.c,v 1.30 2005/10/23 19:00:26 martin Exp $	*/
/*	$NetBSD: grf.c,v 1.53 1998/06/02 02:14:20 scottr Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: grf.c 1.31 91/01/21$
 *
 *	@@(#)grf.c	7.8 (Berkeley) 5/7/91
 */

/*
 * Graphics display driver for the Macintosh.
 * This is the hardware-independent portion of the driver.
 * Hardware access is through the grfdev routines below.
 */

#include <sys/param.h>

#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/vnode.h>
#include <sys/systm.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/grfioctl.h>

#include <miscfs/specfs/specdev.h>

#include <uvm/uvm.h>

#include <mac68k/dev/nubus.h>
#include <mac68k/dev/itevar.h>
#include <mac68k/dev/grfvar.h>

#include "grf.h"
#include "ite.h"

#if NITE == 0
#define	iteon(u,f)
#define	iteoff(u,f)
#endif

int	grfmatch(struct device *, void *, void *);
void	grfattach(struct device *, struct device *, void *);

struct cfdriver grf_cd = {
	NULL, "grf", DV_DULL
};

struct cfattach grf_ca = {
	sizeof(struct grf_softc), grfmatch, grfattach
};

#ifdef DEBUG
#define GRF_DEBUG
#endif

#ifdef GRF_DEBUG
#define GDB_DEVNO	0x01
#define GDB_MMAP	0x02
#define GDB_IOMAP	0x04
#define GDB_LOCK	0x08
int grfdebug = 0;
#endif

int
grfmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct grfbus_attach_args *ga = aux;

	return (strcmp(ga->ga_name, "grf") == 0);
}

void
grfattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct grf_softc *sc = (struct grf_softc *)self;
	struct grfbus_attach_args *ga = aux;

	printf("\n");

	/* Load forwarded pointers. */
	sc->sc_grfmode = ga->ga_grfmode;
	sc->sc_slot = ga->ga_slot;
	sc->sc_tag = ga->ga_tag;
	sc->sc_regh = ga->ga_handle;
	sc->sc_mode = ga->ga_mode;
	sc->sc_phys = ga->ga_phys;

	sc->sc_flags = GF_ALIVE;	/* XXX bogus */

	/*
	 * Attach ite semantics to the grf.  Change the name, forward
	 * everything else.
	 */
	ga->ga_name = "ite";
	(void)config_found(self, ga, grfbusprint);
}

/*ARGSUSED*/
int
grfopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	register struct grf_softc *gp;
	int unit;
	int error;

	unit = GRFUNIT(dev);
	gp = grf_cd.cd_devs[unit];

	if (unit >= grf_cd.cd_ndevs || (gp->sc_flags & GF_ALIVE) == 0)
		return (ENXIO);

	if ((gp->sc_flags & (GF_OPEN | GF_EXCLUDE)) == (GF_OPEN | GF_EXCLUDE))
		return (EBUSY);

	/*
	 * First open.
	 * XXX: always put in graphics mode.
	 */
	error = 0;
	if ((gp->sc_flags & GF_OPEN) == 0) {
		gp->sc_flags |= GF_OPEN;
		error = grfon(dev);
	}
	return (error);
}

/*ARGSUSED*/
int
grfclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	register struct grf_softc *gp;

	gp = grf_cd.cd_devs[GRFUNIT(dev)];

	(void)grfoff(dev);
	gp->sc_flags &= GF_ALIVE;

	return (0);
}

/*ARGSUSED*/
int
grfioctl(dev, cmd, data, flag, p)
	dev_t dev;
	int cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct grf_softc *gp;
	struct grfmode *gm;
	int     error;
	int	unit = GRFUNIT(dev);

	gp = grf_cd.cd_devs[unit];
	gm = gp->sc_grfmode;
	error = 0;

	switch (cmd) {
	case GRFIOCON:
		error = grfon(dev);
		break;
	case GRFIOCOFF:
		error = grfoff(dev);
		break;

	case GRFIOCGMODE:
		bcopy(gm, data, sizeof(struct grfmode));
		break;
	case GRFIOCGETMODE:
		error = (*gp->sc_mode)(gp, GM_CURRMODE, data);
		break;
	case GRFIOCSETMODE:
		error = (*gp->sc_mode)(gp, GM_NEWMODE, data);
		break;
	case GRFIOCLISTMODES:
		error = (*gp->sc_mode)(gp, GM_LISTMODES, data);
		break;

	default:
		error = EINVAL;
		break;
	}
	return (error);
}

/*ARGSUSED*/
int
grfpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	/* always fails => never blocks */
	return (events & (POLLOUT | POLLWRNORM));
}

/*ARGSUSED*/
paddr_t
grfmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	struct grf_softc *gp = grf_cd.cd_devs[GRFUNIT(dev)];
	struct grfmode *gm = gp->sc_grfmode;
	u_long addr;

#ifdef GRF_DEBUG
	if (grfdebug & GDB_MMAP)
		printf("grfmmap(%x): off %x, prot %x\n", dev, off, prot);
#endif

	if (off < trunc_page(gm->fboff) ||
	    off >= round_page(gm->fbsize + gm->fboff))
		addr = (-1);	/* XXX bogus */
	else
		addr = atop(gp->sc_phys + off);

#ifdef GRF_DEBUG
	if (grfdebug & GDB_MMAP)
		printf("grfmmap(%x): returning addr 0x%08lx\n", dev, addr);
#endif
	return (int)addr;
}

int
grfon(dev)
	dev_t   dev;
{
	int     unit = GRFUNIT(dev);
	struct grf_softc *gp;

	gp = grf_cd.cd_devs[unit];

	/*
	 * XXX: iteoff call relies on devices being in same order
	 * as ITEs and the fact that iteoff only uses the minor part
	 * of the dev arg.
	 */
	iteoff(unit, 3);

	return (*gp->sc_mode)(gp, GM_GRFON, NULL);
}

int
grfoff(dev)
	dev_t   dev;
{
	int     unit = GRFUNIT(dev);
	struct grf_softc *gp;
	int     error;

	gp = grf_cd.cd_devs[unit];

	error = (*gp->sc_mode)(gp, GM_GRFOFF, NULL);

	/* XXX: see comment for iteoff above */
	iteon(unit, 2);

	return (error);
}
@


1.30
log
@m68k_btop() and m68k_ptob() were mostly used by mac68k only and can
be replaced by the MI versions atop() and ptoa()
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.29 2005/09/15 18:52:44 martin Exp $	*/
@


1.29
log
@get rid of MD m68k_trunc_page and m68k_round_page and replace by MI
trunc_page and round_page

go go go! miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.28 2005/08/06 19:51:43 martin Exp $	*/
d271 1
a271 1
		addr = m68k_btop(gp->sc_phys + off);
@


1.28
log
@overhaul the grf driver:

- Simplify grfmv_phys() to work like grfiv_phys(), and eliminate the
  second argument to both, as we don't use it anyway.
- Handle fbbase and fboff consistently throughout.
- Eliminate grfaddr() by pulling it into grfmmap(), which is the
  only place it was used, previously.
- grfmap() now gets the physical address of the framebuffer from
  the appropriate driver, rather than try to compute it by itself.
  Be careful with aligning the base to a page address and increase
  the length of the mapped region appropriately.
- Store the PA of the framebuffer in the softc.  This eliminates the need
  for the sc_phys callback; we can just store the PA in the grfbus attach
  args, rather than a function pointer, which simplifies the code nicely.
- Disable Valkyrie interrupts on the Quadra 630
- New and improved console framebuffer initialization and autoconfig.  This
  resolves a great many issues, including Performa 58x interrupt handling
  and offset displays on some models.
- Remove unused grf ioctls
- Some KNF and other minor things

help and ok miod@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.27 2005/07/23 23:28:58 martin Exp $	*/
d267 2
a268 2
	if (off < m68k_trunc_page(gm->fboff) ||
	    off >= m68k_round_page(gm->fbsize + gm->fboff))
@


1.27
log
@vm_offset_t -> {vaddr_t, bus_addr_t}
@
text
@d1 2
a2 2
/*	$OpenBSD: grf.c,v 1.26 2005/05/26 16:35:56 miod Exp $	*/
/*	$NetBSD: grf.c,v 1.41 1997/02/24 06:20:04 scottr Exp $	*/
d69 3
a71 3
#include "nubus.h"
#include "itevar.h"
#include "grfvar.h"
d93 4
d101 1
a101 1
static int grfdebug = (GDB_DEVNO|GDB_MMAP|GDB_IOMAP|GDB_LOCK);
d128 2
d188 1
a188 1
	(void) grfoff(dev);
a212 16
	case GRFIOCGINFO: /* XXX - This should go away as soon as X and	*/
			  /*       dt are fixed to use GRFIOC*MODE*	*/
		{ struct grfinfo *g;
		  g = (struct grfinfo *) data;
		  bzero(data, sizeof(struct grfinfo));
		  g->gd_id = gm->mode_id;
		  g->gd_fbaddr = gm->fbbase;
		  g->gd_fbsize = gm->fbsize;
		  g->gd_colors = 1 << (u_int32_t) gm->psize;
		  g->gd_planes = gm->psize;
		  g->gd_fbwidth = g->gd_dwidth = gm->width;
		  g->gd_fbheight = g->gd_dheight = gm->height;
		  g->gd_fbrowbytes = gm->rowbytes;
		}
		break;

a218 6
	case GRFIOCMAP:
		error = grfmap(dev, (caddr_t *) data, p);
		break;
	case GRFIOCUNMAP:
		error = grfunmap(dev, *(caddr_t *) data, p);
		break;
d258 14
a271 2
	int     unit = GRFUNIT(dev);
	struct grf_softc *gp;
d273 5
a277 2
	gp = grf_cd.cd_devs[unit];
	return (grfaddr(gp, off));
d296 1
a296 1
	return (*gp->sc_mode) (gp, GM_GRFON, NULL);
d309 1
a309 3
	(void) grfunmap(dev, (caddr_t) 0, curproc);

	error = (*gp->sc_mode) (gp, GM_GRFOFF, NULL);
a314 89
}

int
grfaddr(gp, off)
	struct grf_softc *gp;
	register int off;
{
	register struct grfmode *gm = gp->sc_grfmode;
	u_long	addr;

	if (off >= 0 && off < m68k_round_page(gm->fbsize + gm->fboff)) {
		addr = (u_long)(*gp->sc_phys)(gp, (vaddr_t)gm->fbbase)+off;
		return m68k_btop(addr);
	}
	/* bogus */
	return (-1);
}

int
grfmap(dev, addrp, p)
	dev_t dev;
	caddr_t *addrp;
	struct proc *p;
{
	extern u_int32_t mac68k_vidphys;
	struct grf_softc *gp;
	struct specinfo si;
	struct vnode vn;
	int len, error;
	int flags;

	gp = grf_cd.cd_devs[GRFUNIT(dev)];
#ifdef DEBUG
	if (grfdebug & GDB_MMAP)
		printf("grfmap(%d): addr %p\n", p->p_pid, *addrp);
#endif
	len = m68k_round_page(gp->sc_grfmode->fbsize + gp->sc_grfmode->fboff);
	flags = MAP_SHARED | MAP_FIXED;

	if (gp->sc_slot == NULL)
		*addrp = (caddr_t) m68k_trunc_page(mac68k_vidphys);
	else
		*addrp = (caddr_t) m68k_trunc_page(
		    NUBUS_SLOT2PA(gp->sc_slot->slot));

	vn.v_type = VCHR;	/* XXX */
	vn.v_specinfo = &si;	/* XXX */
	vn.v_rdev = dev;	/* XXX */

	error = uvm_mmap(&p->p_vmspace->vm_map, (vaddr_t *)addrp,
	    (vm_size_t)len, UVM_PROT_RW, UVM_PROT_RW, flags, (caddr_t)&vn, 0,
	    p->p_rlimit[RLIMIT_MEMLOCK].rlim_cur, p);

	/* Offset into page: */
	*addrp += (unsigned long) gp->sc_grfmode->fboff & 0xfff;

#ifdef DEBUG
	if (grfdebug & GDB_MMAP)
		printf("grfmap(%d): returning addr %p\n", p->p_pid, *addrp);
#endif

	return (error);
}

int
grfunmap(dev, addr, p)
	dev_t   dev;
	caddr_t addr;
	struct proc *p;
{
	struct grf_softc *gp;
	vm_size_t size;

	gp = grf_cd.cd_devs[GRFUNIT(dev)];

#ifdef DEBUG
	if (grfdebug & GDB_MMAP)
		printf("grfunmap(%d): dev %x addr %p\n", p->p_pid, dev, addr);
#endif

	if (addr == 0)
		return (EINVAL);/* XXX: how do we deal with this? */

	size = round_page(gp->sc_grfmode->fbsize);

	uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr,
	    (vaddr_t)addr + size);

	return (0);
@


1.26
log
@Sync with uvm_mmap() api change.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.25 2003/09/23 16:51:11 millert Exp $	*/
d329 1
a329 1
		addr = (u_long)(*gp->sc_phys)(gp, (vm_offset_t)gm->fbbase)+off;
d367 1
a367 1
	error = uvm_mmap(&p->p_vmspace->vm_map, (vm_offset_t *)addrp,
d403 2
a404 2
	uvm_unmap(&p->p_vmspace->vm_map, (vm_offset_t)addr,
	    (vm_offset_t)addr + size);
@


1.25
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.24 2003/06/02 23:27:48 millert Exp $	*/
d369 1
a369 1
	    p->p_rlimit[RLIMIT_MEMLOCK].rlim_cur);
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.23 2003/05/09 23:09:21 art Exp $	*/
d55 1
d258 1
a258 1
grfselect(dev, rw, p)
d260 1
a260 1
	int rw;
d263 2
a264 3
	if (rw == FREAD)
		return (0);
	return (1);
@


1.23
log
@No need to map framebuffers executable. Really.

fries@@ niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.22 2002/10/29 18:30:21 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.22
log
@Since memory deallocation can't fail, remove the error return from
uvm_unmap, uvm_deallocate and a few other functions.
Simplifies some code and reduces diff to the UBC branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.21 2002/03/14 01:26:35 millert Exp $	*/
d372 1
a372 1
	    (vm_size_t)len, VM_PROT_ALL, VM_PROT_ALL, flags, (caddr_t)&vn, 0,
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.20 2001/12/19 08:58:05 art Exp $	*/
a393 1
	int     rv;
d407 1
a407 1
	rv = uvm_unmap(&p->p_vmspace->vm_map, (vm_offset_t)addr,
d410 1
a410 1
	return (rv == 0 ? 0 : EINVAL);
@


1.20
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.19 2001/11/28 13:47:38 art Exp $	*/
d84 2
a85 2
int	grfmatch __P((struct device *, void *, void *));
void	grfattach __P((struct device *, struct device *, void *));
@


1.19
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.18 2001/11/06 19:53:14 miod Exp $	*/
d394 1
d408 1
a408 1
	uvm_unmap(&p->p_vmspace->vm_map, (vm_offset_t)addr,
d411 1
a411 1
	return (0);
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.19 2001/11/28 13:47:38 art Exp $	*/
d84 2
a85 2
int	grfmatch(struct device *, void *, void *);
void	grfattach(struct device *, struct device *, void *);
@


1.19.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d372 1
a372 1
	    (vm_size_t)len, UVM_PROT_RW, UVM_PROT_RW, flags, (caddr_t)&vn, 0,
@


1.18
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.17 2001/11/01 12:13:46 art Exp $	*/
a393 1
	int     rv;
d407 1
a407 1
	rv = uvm_unmap(&p->p_vmspace->vm_map, (vm_offset_t)addr,
d410 1
a410 1
	return (rv == KERN_SUCCESS ? 0 : EINVAL);
@


1.17
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.16 2001/09/11 20:05:24 miod Exp $	*/
a68 2

#include <vm/vm.h>
@


1.16
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.15 2001/08/11 23:07:12 art Exp $	*/
d274 1
a274 1
int
d277 1
a277 1
	int off;
@


1.15
log
@redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.14 2001/06/27 04:22:37 art Exp $	*/
a70 1
#include <vm/vm_kern.h>
@


1.14
log
@old vm no more
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.13 2001/05/17 18:48:35 aaron Exp $	*/
a71 2
#include <vm/vm_page.h>
#include <vm/vm_pager.h>
@


1.13
log
@Insert comma missing from r1.11 commit; found by beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.12 2001/05/10 21:08:48 millert Exp $	*/
a74 1
#if defined(UVM)
a75 1
#endif
a375 1
#if defined(UVM)
a378 4
#else
	error = vm_mmap(&p->p_vmspace->vm_map, (vm_offset_t *) addrp,
	    (vm_size_t) len, VM_PROT_ALL, VM_PROT_ALL, flags, (caddr_t) &vn, 0);
#endif
a412 1
#if defined(UVM)
a414 3
#else
	rv = vm_deallocate(&p->p_vmspace->vm_map, (vm_offset_t) addr, size);
#endif
@


1.12
log
@Add missing #include <sys/resourcevar.h> so these can compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.11 2001/05/10 07:59:05 art Exp $	*/
d380 1
a380 1
	    (vm_size_t)len, VM_PROT_ALL, VM_PROT_ALL, flags, (caddr_t)&vn, 0
@


1.11
log
@Some locking protocol fixes and better enforcement of wiring limits.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.10 2001/05/08 17:30:39 aaron Exp $	*/
d60 1
@


1.10
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.9 1999/04/24 06:39:40 downsj Exp $	*/
d379 2
a380 1
	    (vm_size_t)len, VM_PROT_ALL, VM_PROT_ALL, flags, (caddr_t)&vn, 0);
@


1.9
log
@Use the generic m68k param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.8 1998/11/20 23:57:24 deraadt Exp $	*/
d74 4
d377 4
d383 1
d418 4
d423 1
@


1.9.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.9 1999/04/24 06:39:40 downsj Exp $	*/
a59 1
#include <sys/resourcevar.h>
a73 2
#include <uvm/uvm.h>

d373 2
a374 3
	error = uvm_mmap(&p->p_vmspace->vm_map, (vm_offset_t *)addrp,
	    (vm_size_t)len, VM_PROT_ALL, VM_PROT_ALL, flags, (caddr_t)&vn, 0,
	    p->p_rlimit[RLIMIT_MEMLOCK].rlim_cur);
d409 1
a409 2
	rv = uvm_unmap(&p->p_vmspace->vm_map, (vm_offset_t)addr,
	    (vm_offset_t)addr + size);
@


1.9.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.9.4.1 2001/07/04 10:18:26 niklas Exp $	*/
d71 3
@


1.9.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 2
d274 1
a274 1
paddr_t
d277 1
a277 1
	off_t off;
@


1.9.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.9.4.3 2001/11/13 21:00:52 niklas Exp $	*/
d394 1
d408 1
a408 1
	uvm_unmap(&p->p_vmspace->vm_map, (vm_offset_t)addr,
d411 1
a411 1
	return (0);
@


1.9.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a393 1
	int     rv;
d407 1
a407 1
	rv = uvm_unmap(&p->p_vmspace->vm_map, (vm_offset_t)addr,
d410 1
a410 1
	return (rv == 0 ? 0 : EINVAL);
@


1.9.4.6
log
@Merge in -current from about a week ago
@
text
@d84 2
a85 2
int	grfmatch(struct device *, void *, void *);
void	grfattach(struct device *, struct device *, void *);
@


1.9.4.7
log
@Sync the SMP branch with 3.3
@
text
@d394 1
d408 1
a408 1
	uvm_unmap(&p->p_vmspace->vm_map, (vm_offset_t)addr,
d411 1
a411 1
	return (0);
@


1.9.4.8
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.9.4.7 2003/03/27 23:28:43 niklas Exp $	*/
d372 1
a372 1
	    (vm_size_t)len, UVM_PROT_RW, UVM_PROT_RW, flags, (caddr_t)&vn, 0,
@


1.9.4.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.9.4.8 2003/05/13 19:41:05 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a54 1
#include <sys/poll.h>
d257 1
a257 1
grfpoll(dev, events, p)
d259 1
a259 1
	int events;
d262 3
a264 2
	/* always fails => never blocks */
	return (events & (POLLOUT | POLLWRNORM));
@


1.8
log
@careful mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.7 1997/03/12 13:36:57 briggs Exp $	*/
d334 1
a334 1
	if (off >= 0 && off < mac68k_round_page(gm->fbsize + gm->fboff)) {
d336 1
a336 1
		return mac68k_btop(addr);
d360 1
a360 1
	len = mac68k_round_page(gp->sc_grfmode->fbsize + gp->sc_grfmode->fboff);
d364 1
a364 1
		*addrp = (caddr_t) mac68k_trunc_page(mac68k_vidphys);
d366 1
a366 1
		*addrp = (caddr_t) mac68k_trunc_page(
@


1.7
log
@Remove some more warnings left over from NetBSD's new config.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.6 1997/03/08 16:16:50 briggs Exp $	*/
d334 1
a334 1
	if (off < mac68k_round_page(gm->fbsize + gm->fboff)) {
@


1.6
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.5 1997/01/24 01:35:29 briggs Exp $	*/
d86 1
a86 1
int	grfmatch __P((struct device *, struct cfdata *, void *));
d106 1
a106 1
grfmatch(parent, cf, aux)
d108 1
a108 1
	struct cfdata *cf;
@


1.5
log
@Sync w/ NETBSD_CURRENT_971122.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf.c,v 1.4 1996/08/10 21:37:43 briggs Exp $	*/
/*	$NetBSD: grf.c,v 1.39 1996/12/16 16:17:05 scottr Exp $	*/
d63 2
a65 1
#include <machine/cpu.h>
d367 1
a367 1
		    NUBUS_SLOT_TO_PADDR(gp->sc_slot->slot));
@


1.4
log
@Sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf.c,v 1.3 1996/05/26 18:35:20 briggs Exp $	*/
/*	$NetBSD: grf.c,v 1.35 1996/08/05 01:26:31 scottr Exp $	*/
d85 1
a85 1
int	grfmatch __P((struct device *, void *, void *));
d105 1
a105 1
grfmatch(parent, match, aux)
d107 2
a108 1
	void *match, *aux;
@


1.3
log
@Add OpenBSD Id string.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: grf.c,v 1.33 1996/05/19 22:27:04 scottr Exp $	*/
a131 1
#ifdef notyet
a137 1
#endif
d346 1
d361 5
a365 2
	*addrp = (caddr_t) mac68k_trunc_page(
				NUBUS_SLOT_TO_PADDR(gp->sc_slot->slot));
@


1.2
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: grf.c,v 1.29 1995/09/21 11:13:27 briggs Exp $	*/
d60 1
d73 1
d84 5
a88 20
static int	grf_match __P((/*struct device *parent, struct device *dev,
				    void *aux*/));
static void	grf_attach __P((struct device *parent, struct device *dev,
				void *aux));

static void	fake_internal __P((void));

extern int	grfmv_probe __P((struct grf_softc *gp, nubus_slot *nu));
extern int	grfmv_init __P((struct grf_softc *gp));
extern int	grfmv_mode __P((struct grf_softc *gp, int cmd, void *arg));
extern caddr_t	grfmv_phys __P((struct grf_softc *gp, vm_offset_t addr));

extern int	grfiv_probe __P((struct grf_softc *gp, nubus_slot *ignore));
extern int	grfiv_init __P((struct grf_softc *gp));
extern int	grfiv_mode __P((struct grf_softc *gp, int cmd, void *arg));
extern caddr_t	grfiv_phys __P((struct grf_softc *gp, vm_offset_t addr));

struct cfdriver grfcd = {
	NULL, "grf", grf_match, grf_attach, DV_DULL,
	sizeof(struct grf_softc)
d91 2
a92 7
struct grfdev grfdev[] = {
/* DrSW             (*gd_probe)() (*gd_init)() (*gd_mode)()  gd_desc
       (*gd_phys)()                                                   */
{  NUBUS_DRSW_APPLE,  grfmv_probe,  grfmv_init,  grfmv_mode, "QD-compatible",
         grfmv_phys },
{              0xFF,  grfiv_probe,  grfiv_init,  grfiv_mode, "Internal video",
         grfiv_phys },
a94 2
static int ngrfdev=(sizeof(grfdev) / sizeof(grfdev[0]));

a95 1
static int grfdebug = 0xff;
d100 1
d103 8
a110 17
static int
grf_match(parent, match, aux)
	struct	device *parent;
	void	*match, *aux;
{
	struct	grf_softc *sc = match;
	nubus_slot *nu = (nubus_slot *) aux;
	int	i, r;

	for (i = 0; i < ngrfdev; i++) {
		if ((r = (*grfdev[i].gd_probe)(sc, nu)) > 0) {
			sc->g_type = i;
			bcopy(aux, &sc->sc_slot, sizeof(nubus_slot));
			return r;
		}
	}
	return 0;
d113 2
a114 2
static void
grf_attach(parent, self, aux)
d116 1
a116 1
	void   *aux;
d118 2
a119 1
	struct grf_softc	*sc;
d121 1
a121 1
	sc = (struct grf_softc *) self;
d123 5
a127 5
	if ((*grfdev[sc->g_type].gd_init)(sc) == 0) {
		printf("\n");
		return;
	}
	sc->g_flags = GF_ALIVE;
d129 1
a129 1
	printf(": %d x %d ", sc->curr_mode.width, sc->curr_mode.height);
d131 8
a138 7
	if (sc->curr_mode.psize == 1)
		printf("monochrome");
	else
		printf("%d color", 1 << sc->curr_mode.psize);

	printf(" %s (%s) display\n",
		grfdev[sc->g_type].gd_desc, sc->card_name);
d154 1
a154 1
	gp = grfcd.cd_devs[unit];
d156 1
a156 1
	if (unit >= grfcd.cd_ndevs || (gp->g_flags & GF_ALIVE) == 0)
d159 1
a159 1
	if ((gp->g_flags & (GF_OPEN | GF_EXCLUDE)) == (GF_OPEN | GF_EXCLUDE))
d167 2
a168 2
	if ((gp->g_flags & GF_OPEN) == 0) {
		gp->g_flags |= GF_OPEN;
d175 1
d184 1
a184 1
	gp = grfcd.cd_devs[GRFUNIT(dev)];
d187 1
a187 1
	gp->g_flags &= GF_ALIVE;
d193 1
d201 2
a202 1
	register struct grf_softc *gp;
d206 2
a207 1
	gp = grfcd.cd_devs[unit];
d216 8
a223 8
		  g->gd_id = gp->curr_mode.mode_id;
		  g->gd_fbaddr = gp->curr_mode.fbbase;
		  g->gd_fbsize = gp->curr_mode.fbsize;
		  g->gd_colors = 1 << (u_int32_t) gp->curr_mode.psize;
		  g->gd_planes = gp->curr_mode.psize;
		  g->gd_fbwidth = g->gd_dwidth = gp->curr_mode.width;
		  g->gd_fbheight = g->gd_dheight = gp->curr_mode.height;
		  g->gd_fbrowbytes = gp->curr_mode.rowbytes;
d241 1
a241 1
		bcopy(&gp->curr_mode, data, sizeof(struct grfmode));
d244 1
a244 1
		error = (*grfdev[gp->g_type].gd_mode)(gp, GM_CURRMODE, data);
d247 1
a247 1
		error = (*grfdev[gp->g_type].gd_mode)(gp, GM_NEWMODE, data);
d250 1
a250 1
		error = (*grfdev[gp->g_type].gd_mode)(gp, GM_LISTMODES, data);
d261 1
d273 1
d282 1
a282 1
	gp = grfcd.cd_devs[unit];
d293 1
a293 1
	gp = grfcd.cd_devs[unit];
d302 1
a302 1
	return (*grfdev[gp->g_type].gd_mode) (gp, GM_GRFON, NULL);
d313 1
a313 1
	gp = grfcd.cd_devs[unit];
d317 1
a317 1
	error = (*grfdev[gp->g_type].gd_mode) (gp, GM_GRFOFF, NULL);
d330 1
a330 1
	register struct grfmode *gm = &gp->curr_mode;
d333 2
a334 3
	if (off < mac68k_round_page(gm->fbsize + gm->fboff) ) {
		addr = (u_long) (*grfdev[gp->g_type].gd_phys) (gp, gm->fbbase)
				+ off;
d353 1
a353 1
	gp = grfcd.cd_devs[GRFUNIT(dev)];
d356 1
a356 1
		printf("grfmap(%d): addr %x\n", p->p_pid, *addrp);
d358 1
a358 1
	len = mac68k_round_page(gp->curr_mode.fbsize + gp->curr_mode.fboff);
d362 1
a362 1
			NUBUS_VIRT_TO_PHYS((u_int) gp->curr_mode.fbbase));
d369 1
a369 2
	    (vm_size_t) len, VM_PROT_ALL, VM_PROT_ALL, flags, (caddr_t) & vn,
	    0);
d372 1
a372 1
	*addrp += (unsigned long) gp->curr_mode.fboff & 0xfff;
d376 1
a376 1
		printf("grfmap(%d): returning addr %x\n", p->p_pid, *addrp);
d392 1
a392 1
	gp = grfcd.cd_devs[GRFUNIT(dev)];
d396 1
a396 1
		printf("grfunmap(%d): dev %x addr %x\n", p->p_pid, dev, addr);
d402 1
a402 1
	size = round_page(gp->curr_mode.fbsize);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
