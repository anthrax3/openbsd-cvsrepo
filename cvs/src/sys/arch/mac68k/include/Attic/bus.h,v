head	1.16;
access;
symbols
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.8.0.16
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.14
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.12
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.12
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.10
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.8
	OPENBSD_2_9_BASE:1.6
	NIKLAS_UNDEAD:1.6.0.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.8
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2012.06.20.18.23.51;	author matthew;	state dead;
branches;
next	1.15;

1.15
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.12;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.16.19.07.35;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.22.18.37.58;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.17.00.08.35;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.12.10.07.29;	author martin;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.19.17.51.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.15.03.56.49;	author todd;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	98.04.27.02.01.48;	author gene;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	97.11.30.06.12.20;	author gene;	state Exp;
branches;
next	1.3;

1.3
date	97.04.07.03.23.37;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	97.04.05.16.22.06;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	97.02.26.05.38.12;	author gene;	state Exp;
branches;
next	;

1.5.8.1
date	2000.03.24.09.08.03;	author niklas;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	;

1.6.12.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: bus.h,v 1.15 2011/03/23 16:54:35 pirofti Exp $	*/
/*	$NetBSD: bus.h,v 1.9 1998/01/13 18:32:15 scottr Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (C) 1997 Scott Reynolds.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_H_
#define _MACHINE_BUS_H_

/*
 * Value for the mac68k bus space tag, not to be used directly by MI code.
 */
#define MAC68K_BUS_SPACE_MEM	0	/* space is mem space */

/*
 * Bus address and size types
 */
typedef u_long bus_addr_t;
typedef u_long bus_size_t;

/*
 * Access methods for bus resources and address space.
 */
#define BSH_T	struct bus_space_handle_s
typedef int	bus_space_tag_t;
typedef struct	bus_space_handle_s {
	u_long	base;
	int	swapped;

	u_int8_t	(*bsr1)(bus_space_tag_t, BSH_T *, bus_size_t);
	u_int16_t	(*bsr2)(bus_space_tag_t, BSH_T *, bus_size_t);
	u_int32_t	(*bsr4)(bus_space_tag_t, BSH_T *, bus_size_t);
	void		(*bsrm1)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int8_t *, size_t);
	void		(*bsrm2)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int16_t *, size_t);
	void		(*bsrm4)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int32_t *, size_t);
	void		(*bsrms2)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int16_t *, size_t);
	void		(*bsrms4)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int32_t *, size_t);
	void		(*bsrr1)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int8_t *, size_t);
	void		(*bsrr2)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int16_t *, size_t);
	void		(*bsrr4)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int32_t *, size_t);
	void		(*bsrrs1)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int8_t *, size_t);
	void		(*bsrrs2)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int16_t *, size_t);
	void		(*bsrrs4)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int32_t *, size_t);
	void		(*bsw1)(bus_space_tag_t, BSH_T *, bus_size_t, u_int8_t);
	void		(*bsw2)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int16_t);
	void		(*bsw4)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int32_t);
	void		(*bswm1)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int8_t *, size_t);
	void		(*bswm2)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int16_t *, size_t);
	void		(*bswm4)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int32_t *, size_t);
	void		(*bswms1)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int8_t *, size_t);
	void		(*bswms2)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int16_t *, size_t);
	void		(*bswms4)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int32_t *, size_t);
	void		(*bswr1)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int8_t *, size_t);
	void		(*bswr2)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int16_t *, size_t);
	void		(*bswr4)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int32_t *, size_t);
	void		(*bswrs1)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int8_t *, size_t);
	void		(*bswrs2)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int16_t *, size_t);
	void		(*bswrs4)(bus_space_tag_t, BSH_T *, bus_size_t,
				const u_int32_t *, size_t);
	void		(*bssm1)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int8_t v, size_t);
	void		(*bssm2)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int16_t v, size_t);
	void		(*bssm4)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int32_t v, size_t);
	void		(*bssr1)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int8_t v, size_t);
	void		(*bssr2)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int16_t v, size_t);
	void		(*bssr4)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int32_t v, size_t);	
} bus_space_handle_t;
#undef BSH_T

void	mac68k_bus_space_handle_swapped(bus_space_tag_t,
		bus_space_handle_t *h);

/*
 *	int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
 *	    bus_size_t size, int flags, bus_space_handle_t *bshp);
 *
 * Map a region of bus space.
 */

#define	BUS_SPACE_MAP_CACHEABLE		0x01
#define	BUS_SPACE_MAP_LINEAR		0x02
#define	BUS_SPACE_MAP_PREFETCHABLE	0x04

int	bus_space_map(bus_space_tag_t, bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);

/*
 *	void bus_space_unmap(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
 *
 * Unmap a region of bus space.
 */

void	bus_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);

/*
 *	int bus_space_subregion(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t offset, bus_size_t size,
 *	    bus_space_handle_t *nbshp);
 *
 * Get a new handle for a subregion of an already-mapped area of bus space.
 */

int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);

/*
 *	int bus_space_alloc(bus_space_tag_t t, bus_addr_t, rstart,
 *	    bus_addr_t rend, bus_size_t size, bus_size_t align,
 *	    bus_size_t boundary, int flags, bus_addr_t *addrp,
 *	    bus_space_handle_t *bshp);
 *
 * Allocate a region of bus space.
 */

int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t align,
	    bus_size_t boundary, int flags, bus_addr_t *addrp,
	    bus_space_handle_t *bshp);

/*
 *	int bus_space_free(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
 *
 * Free a region of bus space.
 */

void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);

/*
 *	int mac68k_bus_space_probe(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t offset, int sz);
 *
 * Probe the bus at t/bsh/offset, using sz as the size of the load.
 *
 * This is a machine-dependent extension, and is not to be used by
 * machine-independent code.
 */

int	mac68k_bus_space_probe(bus_space_tag_t t,
	    bus_space_handle_t bsh, bus_size_t offset, int sz);

/*
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
 *
 * Read a 1, 2, 4, or 8 byte quantity from bus space
 * described by tag/handle/offset.
 */

u_int8_t mac68k_bsr1(bus_space_tag_t tag, bus_space_handle_t *bsh,
			  bus_size_t offset);
u_int16_t mac68k_bsr2(bus_space_tag_t tag, bus_space_handle_t *bsh,
			  bus_size_t offset);
u_int16_t mac68k_bsr2_swap(bus_space_tag_t tag, bus_space_handle_t *bsh,
				bus_size_t offset);
u_int32_t mac68k_bsr4(bus_space_tag_t tag, bus_space_handle_t *bsh,
				bus_size_t offset);
u_int32_t mac68k_bsr4_swap(bus_space_tag_t tag, bus_space_handle_t *bsh,
				bus_size_t offset);	

#define	bus_space_read_1(t,h,o) (h).bsr1((t), &(h), (o))
#define	bus_space_read_2(t,h,o) (h).bsr2((t), &(h), (o))
#define	bus_space_read_4(t,h,o) (h).bsr4((t), &(h), (o))

/*
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.
 */

void mac68k_bsrm1(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int8_t *, size_t);
void mac68k_bsrm2(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t *, size_t);
void mac68k_bsrm2_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t *, size_t);
void mac68k_bsrm4(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);
void mac68k_bsrms4(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);
void mac68k_bsrm4_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);

#define bus_space_read_multi_1(t, h, o, a, c) (h).bsrm1(t, &(h), o, a, c)
#define bus_space_read_multi_2(t, h, o, a, c) (h).bsrm2(t, &(h), o, a, c)
#define bus_space_read_multi_4(t, h, o, a, c) (h).bsrm4(t, &(h), o, a, c)

/*
 *	void bus_space_read_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */

void mac68k_bsrr1(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int8_t *, size_t);
void mac68k_bsrr2(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t *, size_t);
void mac68k_bsrr2_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t *, size_t);
void mac68k_bsrr4(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);
void mac68k_bsrr4_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);

#define bus_space_read_region_1(t, h, o, a, c) (h).bsrr1(t,&(h),o,a,c)
#define bus_space_read_region_2(t, h, o, a, c) (h).bsrr2(t,&(h),o,a,c)
#define bus_space_read_region_4(t, h, o, a, c) (h).bsrr4(t,&(h),o,a,c)

/*
 *	void bus_space_write_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t value);
 *
 * Write the 1, 2, 4, or 8 byte value `value' to bus space
 * described by tag/handle/offset.
 */

void mac68k_bsw1(bus_space_tag_t, bus_space_handle_t *, bus_size_t, u_int8_t);
void mac68k_bsw2(bus_space_tag_t, bus_space_handle_t *, bus_size_t, u_int16_t);
void mac68k_bsw2_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t);
void mac68k_bsw4(bus_space_tag_t, bus_space_handle_t *, bus_size_t, u_int32_t);
void mac68k_bsw4_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t);

#define bus_space_write_1(t, h, o, v) (h).bsw1(t, &(h), o, v)
#define bus_space_write_2(t, h, o, v) (h).bsw2(t, &(h), o, v)
#define bus_space_write_4(t, h, o, v) (h).bsw4(t, &(h), o, v)

/*
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
 * provided to bus space described by tag/handle/offset.
 */

void mac68k_bswm1(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int8_t *, size_t);
void mac68k_bswm2(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int16_t *, size_t);
void mac68k_bswm2_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int16_t *, size_t);
void mac68k_bswm4(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int32_t *, size_t);
void mac68k_bswm4_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int32_t *, size_t);

#define bus_space_write_multi_1(t, h, o, a, c) (h).bswm1(t, &(h), o, a, c)
#define bus_space_write_multi_2(t, h, o, a, c) (h).bswm2(t, &(h), o, a, c)
#define bus_space_write_multi_4(t, h, o, a, c) (h).bswm4(t, &(h), o, a, c)

/*
 *	void bus_space_write_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */

void mac68k_bswr1(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int8_t *, size_t);
void mac68k_bswr2(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int16_t *, size_t);
void mac68k_bswr2_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int16_t *, size_t);
void mac68k_bswr4(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int32_t *, size_t);
void mac68k_bswr4_swap(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int32_t *, size_t);

#define bus_space_write_region_1(t, h, o, a, c) (h).bswr1(t, &(h), o, a, c)
#define bus_space_write_region_2(t, h, o, a, c) (h).bswr2(t, &(h), o, a, c)
#define bus_space_write_region_4(t, h, o, a, c) (h).bswr4(t, &(h), o, a, c)

/*
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */

void mac68k_bssm1(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int8_t v, size_t c);
void mac68k_bssm2(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int16_t v, size_t c);
void mac68k_bssm2_swap(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int16_t v, size_t c);
void mac68k_bssm4(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int32_t v, size_t c);
void mac68k_bssm4_swap(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int32_t v, size_t c);

#define bus_space_set_multi_1(t, h, o, val, c) (h).bssm1(t, &(h), o, val, c)
#define bus_space_set_multi_2(t, h, o, val, c) (h).bssm2(t, &(h), o, val, c)
#define bus_space_set_multi_4(t, h, o, val, c) (h).bssm4(t, &(h), o, val, c)

/*
 *	void bus_space_set_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle starting at `offset'.
 */

void mac68k_bssr1(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int8_t v, size_t c);
void mac68k_bssr2(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int16_t v, size_t c);
void mac68k_bssr2_swap(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int16_t v, size_t c);
void mac68k_bssr4(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int32_t v, size_t c);
void mac68k_bssr4_swap(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int32_t v, size_t c);

#define bus_space_set_region_1(t, h, o, val, c) (h).bssr1(t, &(h), o, val, c)
#define bus_space_set_region_2(t, h, o, val, c) (h).bssr2(t, &(h), o, val, c)
#define bus_space_set_region_4(t, h, o, val, c) (h).bssr4(t, &(h), o, val, c)

/*
 * Bus read/write barrier methods.
 *
 *	void bus_space_barrier(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags);
 *
 * Note: the 680x0 does not currently require barriers, but we must
 * provide the flags to MI code.
 */
#define	bus_space_barrier(t, h, o, l, f)	\
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))
#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */

#define	bus_space_vaddr(t, h)			(void *)((h).base)

#endif /* _MACHINE_BUS_H_ */
@


1.15
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2009/07/26 18:48:55 miod Exp $	*/
@


1.14
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2008/06/26 05:42:12 ray Exp $	*/
d60 2
a61 2
#ifndef _MAC68K_BUS_H_
#define _MAC68K_BUS_H_
d434 1
a434 1
#endif /* _MAC68K_BUS_H_ */
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2006/04/16 19:07:35 miod Exp $	*/
d164 1
d200 1
a200 1
	    bus_size_t boundary, int cacheable, bus_addr_t *addrp,
@


1.12
log
@Remove bus_space_{read,write}_stream and bus_space_copy_region methods, which
are not used in OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2006/01/22 18:37:58 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@Add bus_space_vaddr() and use it instead of accessing private bus_space
fields. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.10 2006/01/17 00:08:35 miod Exp $	*/
a92 3
	u_int8_t	(*bsrs1)(bus_space_tag_t, BSH_T *, bus_size_t);
	u_int16_t	(*bsrs2)(bus_space_tag_t, BSH_T *, bus_size_t);
	u_int32_t	(*bsrs4)(bus_space_tag_t, BSH_T *, bus_size_t);
a119 6
	void		(*bsws1)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int8_t);
	void		(*bsws2)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int16_t);
	void		(*bsws4)(bus_space_tag_t, BSH_T *, bus_size_t,
				u_int32_t);
a253 3
#define bus_space_read_stream_1(t,h,o)  (h).bsrs1((t), &(h), (o))
#define bus_space_read_stream_2(t,h,o)  (h).bsrs2((t), &(h), (o))
#define bus_space_read_stream_4(t,h,o)  (h).bsrs4((t), &(h), (o))
a325 3
#define bus_space_write_stream_1(t, h, o, v) (h).bsws1(t, &(h), o, v)
#define bus_space_write_stream_2(t, h, o, v) (h).bsws2(t, &(h), o, v)
#define bus_space_write_stream_4(t, h, o, v) (h).bsws4(t, &(h), o, v)
a421 43

/*
 *	void bus_space_copy_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh1, bus_size_t off1,
 *	    bus_space_handle_t bsh2, bus_size_t off2,
 *	    size_t count);
 *
 * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
 * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
 */

#define	__MAC68K_copy_region_N(BYTES)					\
static __inline void __CONCAT(bus_space_copy_region_,BYTES)		\
	    (bus_space_tag_t,						\
	    bus_space_handle_t bsh1, bus_size_t off1,			\
	    bus_space_handle_t bsh2, bus_size_t off2,			\
	    bus_size_t count);						\
									\
static __inline void							\
__CONCAT(bus_space_copy_region_,BYTES)(t, h1, o1, h2, o2, c)		\
	bus_space_tag_t t;						\
	bus_space_handle_t h1, h2;					\
	bus_size_t o1, o2, c;						\
{									\
	bus_size_t o;							\
									\
	if ((h1.base + o1) >= (h2.base + o2)) {			\
		/* src after dest: copy forward */			\
		for (o = 0; c != 0; c--, o += BYTES)			\
			__CONCAT(bus_space_write_,BYTES)(t, h2, o2 + o,	\
			    __CONCAT(bus_space_read_,BYTES)(t, h1, o1 + o)); \
	} else {							\
		/* dest after src: copy backwards */			\
		for (o = (c - 1) * BYTES; c != 0; c--, o -= BYTES)	\
			__CONCAT(bus_space_write_,BYTES)(t, h2, o2 + o,	\
			    __CONCAT(bus_space_read_,BYTES)(t, h1, o1 + o)); \
	}								\
}
__MAC68K_copy_region_N(1)
__MAC68K_copy_region_N(2)
__MAC68K_copy_region_N(4)

#undef __MAC68K_copy_region_N
@


1.10
log
@Remove unused ``stride'' bus_space internal functionality; nothing needs it.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 2005/09/12 10:07:29 martin Exp $	*/
d495 2
@


1.9
log
@- Add byte-swap and stride options to bus_space.
- Add bus_space_*_stream_N functions
- Replace PGOFSET with m68k_trunc_page() or m68k_page_offset()

from NetBSD, testing help by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 2002/03/19 17:51:04 millert Exp $	*/
a88 1
	int	stride;
a169 2
void	mac68k_bus_space_handle_set_stride(bus_space_tag_t t,
		bus_space_handle_t *h, int stride);
a250 2
u_int8_t mac68k_bsr1_gen(bus_space_tag_t tag, bus_space_handle_t *bsh,
			  bus_size_t offset);
a254 2
u_int16_t mac68k_bsr2_gen(bus_space_tag_t tag, bus_space_handle_t *bsh,
				bus_size_t offset);
a258 2
u_int32_t mac68k_bsr4_gen(bus_space_tag_t tag, bus_space_handle_t *bsh,
				bus_size_t offset);
a266 4
#if 0	/* Cause a link error for bus_space_read_8 */
#define	bus_space_read_8(t, h, o)	!!! bus_space_read_8 unimplemented !!!
#endif

a277 2
void mac68k_bsrm1_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int8_t *, size_t);
a281 4
void mac68k_bsrm2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t *, size_t);
void mac68k_bsrms2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t *, size_t);
a287 4
void mac68k_bsrm4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);
void mac68k_bsrms4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);
a292 4
#if 0	/* Cause a link error for bus_space_read_multi_8 */
#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 unimplemented !!!
#endif

a304 2
void mac68k_bsrr1_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int8_t *, size_t);
a308 4
void mac68k_bsrr2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t *, size_t);
void mac68k_bsrrs2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t *, size_t);
a312 4
void mac68k_bsrr4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);
void mac68k_bsrrs4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t *, size_t);
a317 4
#if 0	/* Cause a link error for bus_space_read_region_8 */
#define	bus_space_read_region_8	!!! bus_space_read_region_8 unimplemented !!!
#endif

a327 2
void mac68k_bsw1_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int8_t);
a330 4
void mac68k_bsw2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t);
void mac68k_bsws2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int16_t);
a333 4
void mac68k_bsw4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t);
void mac68k_bsws4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	u_int32_t);
a341 4
#if 0	/* Cause a link error for bus_space_write_8 */
#define	bus_space_write_8	!!! bus_space_write_8 not implemented !!!
#endif

a352 2
void mac68k_bswm1_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int8_t *, size_t);
a356 4
void mac68k_bswm2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int16_t *, size_t);
void mac68k_bswms2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int16_t *, size_t);
a360 4
void mac68k_bswm4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int32_t *, size_t);
void mac68k_bswms4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int32_t *, size_t);
a365 5
#if 0	/* Cause a link error for bus_space_write_8 */
#define	bus_space_write_multi_8(t, h, o, a, c)				\
			!!! bus_space_write_multi_8 unimplemented !!!
#endif

a376 2
void mac68k_bswr1_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int8_t *, size_t);
a380 4
void mac68k_bswr2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int16_t *, size_t);
void mac68k_bswrs2_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int16_t *, size_t);
a384 4
void mac68k_bswr4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int32_t *, size_t);
void mac68k_bswrs4_gen(bus_space_tag_t, bus_space_handle_t *, bus_size_t,
	const u_int32_t *, size_t);
a389 5
#if 0	/* Cause a link error for bus_space_write_region_8 */
#define	bus_space_write_region_8					\
			!!! bus_space_write_region_8 unimplemented !!!
#endif

a400 2
void mac68k_bssm1_gen(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int8_t v, size_t c);
a404 2
void mac68k_bssm2_gen(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int16_t v, size_t c);
a408 2
void mac68k_bssm4_gen(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int32_t v, size_t c);
a413 5
#if 0	/* Cause a link error for bus_space_set_multi_8 */
#define	bus_space_set_multi_8						\
			!!! bus_space_set_multi_8 unimplemented !!!
#endif

a424 2
void mac68k_bssr1_gen(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int8_t v, size_t c);
a428 2
void mac68k_bssr2_gen(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int16_t v, size_t c);
a432 2
void mac68k_bssr4_gen(bus_space_tag_t t, bus_space_handle_t *h,
			bus_size_t o, u_int32_t v, size_t c);
a437 5
#if 0	/* Cause a link error for bus_space_set_region_8 */
#define	bus_space_set_region_8						\
			!!! bus_space_set_region_8 unimplemented !!!
#endif

a477 4
#if 0	/* Cause a link error for bus_space_copy_8 */
#define	bus_space_copy_8						\
			!!! bus_space_copy_8 unimplemented !!!
#endif
@


1.8
log
@Fix bus_space_copy_region_ macro that got messed up by unpeeing.
miod@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.7 2002/03/14 01:26:35 millert Exp $	*/
d84 1
d86 87
a172 1
typedef u_long	bus_space_handle_t;
d252 23
a274 8
#define	bus_space_read_1(t, h, o)					\
    ((void) t, (*(volatile u_int8_t *)((h) + (o))))

#define	bus_space_read_2(t, h, o)					\
    ((void) t, (*(volatile u_int16_t *)((h) + (o))))

#define	bus_space_read_4(t, h, o)					\
    ((void) t, (*(volatile u_int32_t *)((h) + (o))))
d289 26
a314 41
#define	bus_space_read_multi_1(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movb	a0@@,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_read_multi_2(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movw	a0@@,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_read_multi_4(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movl	a0@@,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);
d330 24
a353 41
#define	bus_space_read_region_1(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movb	a0@@+,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_read_region_2(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movw	a0@@+,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_read_region_4(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movl	a0@@+,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);
d368 24
a391 8
#define	bus_space_write_1(t, h, o, v)					\
    ((void) t, ((void)(*(volatile u_int8_t *)((h) + (o)) = (v))))

#define	bus_space_write_2(t, h, o, v)					\
    ((void) t, ((void)(*(volatile u_int16_t *)((h) + (o)) = (v))))

#define	bus_space_write_4(t, h, o, v)					\
    ((void) t, ((void)(*(volatile u_int32_t *)((h) + (o)) = (v))))
d406 24
a429 41
#define	bus_space_write_multi_1(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movb	a1@@+,a0@@				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_write_multi_2(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movw	a1@@+,a0@@				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_write_multi_4(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movl	a1@@+,a0@@				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);
d445 24
a468 41
#define	bus_space_write_region_1(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movb	a1@@+,a0@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_write_region_2(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movw	a1@@+,a0@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_write_region_4(t, h, o, a, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movl	a1@@+,a0@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (a), "g" (c)		:	\
		    "a0","a1","d0");					\
} while (0);
d484 20
a503 41
#define	bus_space_set_multi_1(t, h, o, val, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,d1					;	\
		movl	%2,d0					;	\
	1:	movb	d1,a0@@					;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (val), "g" (c)		:	\
		    "a0","d0","d1");					\
} while (0);

#define	bus_space_set_multi_2(t, h, o, val, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,d1					;	\
		movl	%2,d0					;	\
	1:	movw	d1,a0@@					;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (val), "g" (c)		:	\
		    "a0","d0","d1");					\
} while (0);

#define	bus_space_set_multi_4(t, h, o, val, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,d1					;	\
		movl	%2,d0					;	\
	1:	movl	d1,a0@@					;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (val), "g" (c)		:	\
		    "a0","d0","d1");					\
} while (0);
d519 20
a538 41
#define	bus_space_set_region_1(t, h, o, val, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,d1					;	\
		movl	%2,d0					;	\
	1:	movb	d1,a0@@+					;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (val), "g" (c)		:	\
		    "a0","d0","d1");					\
} while (0);

#define	bus_space_set_region_2(t, h, o, val, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,d1					;	\
		movl	%2,d0					;	\
	1:	movw	d1,a0@@+					;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (val), "g" (c)		:	\
		    "a0","d0","d1");					\
} while (0);

#define	bus_space_set_region_4(t, h, o, val, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,d1					;	\
		movl	%2,d0					;	\
	1:	movl	d1,a0@@+					;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h) + (o)), "g" (val), "g" (c)		:	\
		    "a0","d0","d1");					\
} while (0);
d570 1
a570 1
	if ((h1 + o1) >= (h2 + o2)) {					\
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 2000/03/15 03:56:49 todd Exp $	*/
d546 2
a547 1
static __inline void __CONCAT(bus_space_copy_region_,BYTES)		\(bus_space_tag_t,						\
@


1.6
log
@implimented -> implemented
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 1998/04/27 02:01:48 gene Exp $	*/
d88 2
a89 2
 *	int bus_space_map __P((bus_space_tag_t t, bus_addr_t addr,
 *	    bus_size_t size, int flags, bus_space_handle_t *bshp));
d97 2
a98 2
int	bus_space_map __P((bus_space_tag_t, bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *));
d101 2
a102 2
 *	void bus_space_unmap __P((bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size));
d107 1
a107 1
void	bus_space_unmap __P((bus_space_tag_t, bus_space_handle_t, bus_size_t));
d110 1
a110 1
 *	int bus_space_subregion __P((bus_space_tag_t t,
d112 1
a112 1
 *	    bus_space_handle_t *nbshp));
d117 2
a118 2
int	bus_space_subregion __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp));
d121 1
a121 1
 *	int bus_space_alloc __P((bus_space_tag_t t, bus_addr_t, rstart,
d124 1
a124 1
 *	    bus_space_handle_t *bshp));
d129 1
a129 1
int	bus_space_alloc __P((bus_space_tag_t t, bus_addr_t rstart,
d132 1
a132 1
	    bus_space_handle_t *bshp));
d135 2
a136 2
 *	int bus_space_free __P((bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size));
d141 2
a142 2
void	bus_space_free __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size));
d145 2
a146 2
 *	int mac68k_bus_space_probe __P((bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t offset, int sz));
d154 2
a155 2
int	mac68k_bus_space_probe __P((bus_space_tag_t t,
	    bus_space_handle_t bsh, bus_size_t offset, int sz));
d158 2
a159 2
 *	u_intN_t bus_space_read_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset));
d179 1
a179 1
 *	void bus_space_read_multi_N __P((bus_space_tag_t tag,
d181 1
a181 1
 *	    u_intN_t *addr, size_t count));
d234 1
a234 1
 *	void bus_space_read_region_N __P((bus_space_tag_t tag,
d236 1
a236 1
 *	    u_intN_t *addr, size_t count));
d290 1
a290 1
 *	void bus_space_write_N __P((bus_space_tag_t tag,
d292 1
a292 1
 *	    u_intN_t value));
d312 1
a312 1
 *	void bus_space_write_multi_N __P((bus_space_tag_t tag,
d314 1
a314 1
 *	    const u_intN_t *addr, size_t count));
d368 1
a368 1
 *	void bus_space_write_region_N __P((bus_space_tag_t tag,
d370 1
a370 1
 *	    const u_intN_t *addr, size_t count));
d424 1
a424 1
 *	void bus_space_set_multi_N __P((bus_space_tag_t tag,
d426 1
a426 1
 *	    size_t count));
d480 1
a480 1
 *	void bus_space_set_region_N __P((bus_space_tag_t tag,
d482 1
a482 1
 *	    size_t count));
d536 1
a536 1
 *	void bus_space_copy_N __P((bus_space_tag_t tag,
d539 1
a539 1
 *	    size_t count));
d546 1
a546 2
static __inline void __CONCAT(bus_space_copy_region_,BYTES)		\
	__P((bus_space_tag_t,						\
d549 1
a549 1
	    bus_size_t count));						\
d584 1
a584 1
 *	void bus_space_barrier __P((bus_space_tag_t tag,
d586 1
a586 1
 *	    bus_size_t len, int flags));
@


1.6.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 2000/03/15 03:56:49 todd Exp $	*/
d88 2
a89 2
 *	int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
 *	    bus_size_t size, int flags, bus_space_handle_t *bshp);
d97 2
a98 2
int	bus_space_map(bus_space_tag_t, bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);
d101 2
a102 2
 *	void bus_space_unmap(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
d107 1
a107 1
void	bus_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
d110 1
a110 1
 *	int bus_space_subregion(bus_space_tag_t t,
d112 1
a112 1
 *	    bus_space_handle_t *nbshp);
d117 2
a118 2
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
d121 1
a121 1
 *	int bus_space_alloc(bus_space_tag_t t, bus_addr_t, rstart,
d124 1
a124 1
 *	    bus_space_handle_t *bshp);
d129 1
a129 1
int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
d132 1
a132 1
	    bus_space_handle_t *bshp);
d135 2
a136 2
 *	int bus_space_free(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
d141 2
a142 2
void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
d145 2
a146 2
 *	int mac68k_bus_space_probe(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t offset, int sz);
d154 2
a155 2
int	mac68k_bus_space_probe(bus_space_tag_t t,
	    bus_space_handle_t bsh, bus_size_t offset, int sz);
d158 2
a159 2
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d179 1
a179 1
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
d181 1
a181 1
 *	    u_intN_t *addr, size_t count);
d234 1
a234 1
 *	void bus_space_read_region_N(bus_space_tag_t tag,
d236 1
a236 1
 *	    u_intN_t *addr, size_t count);
d290 1
a290 1
 *	void bus_space_write_N(bus_space_tag_t tag,
d292 1
a292 1
 *	    u_intN_t value);
d312 1
a312 1
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
d314 1
a314 1
 *	    const u_intN_t *addr, size_t count);
d368 1
a368 1
 *	void bus_space_write_region_N(bus_space_tag_t tag,
d370 1
a370 1
 *	    const u_intN_t *addr, size_t count);
d424 1
a424 1
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
d426 1
a426 1
 *	    size_t count);
d480 1
a480 1
 *	void bus_space_set_region_N(bus_space_tag_t tag,
d482 1
a482 1
 *	    size_t count);
d536 1
a536 1
 *	void bus_space_copy_N(bus_space_tag_t tag,
d539 1
a539 1
 *	    size_t count);
d547 1
a547 1
	    (bus_space_tag_t,						\
d550 1
a550 1
	    bus_size_t count);						\
d585 1
a585 1
 *	void bus_space_barrier(bus_space_tag_t tag,
d587 1
a587 1
 *	    bus_size_t len, int flags);
@


1.5
log
@Correct namespace collisions for bus_space_probe and split out
bus_space functions into a separate source file ala NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d364 1
a364 1
			!!! bus_space_write_multi_8 unimplimented !!!
@


1.5.8.1
log
@Sync with -current
@
text
@d364 1
a364 1
			!!! bus_space_write_multi_8 unimplemented !!!
@


1.5.8.2
log
@Merge in -current from about a week ago
@
text
@d88 2
a89 2
 *	int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
 *	    bus_size_t size, int flags, bus_space_handle_t *bshp);
d97 2
a98 2
int	bus_space_map(bus_space_tag_t, bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);
d101 2
a102 2
 *	void bus_space_unmap(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
d107 1
a107 1
void	bus_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
d110 1
a110 1
 *	int bus_space_subregion(bus_space_tag_t t,
d112 1
a112 1
 *	    bus_space_handle_t *nbshp);
d117 2
a118 2
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
d121 1
a121 1
 *	int bus_space_alloc(bus_space_tag_t t, bus_addr_t, rstart,
d124 1
a124 1
 *	    bus_space_handle_t *bshp);
d129 1
a129 1
int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
d132 1
a132 1
	    bus_space_handle_t *bshp);
d135 2
a136 2
 *	int bus_space_free(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
d141 2
a142 2
void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
d145 2
a146 2
 *	int mac68k_bus_space_probe(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t offset, int sz);
d154 2
a155 2
int	mac68k_bus_space_probe(bus_space_tag_t t,
	    bus_space_handle_t bsh, bus_size_t offset, int sz);
d158 2
a159 2
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d179 1
a179 1
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
d181 1
a181 1
 *	    u_intN_t *addr, size_t count);
d234 1
a234 1
 *	void bus_space_read_region_N(bus_space_tag_t tag,
d236 1
a236 1
 *	    u_intN_t *addr, size_t count);
d290 1
a290 1
 *	void bus_space_write_N(bus_space_tag_t tag,
d292 1
a292 1
 *	    u_intN_t value);
d312 1
a312 1
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
d314 1
a314 1
 *	    const u_intN_t *addr, size_t count);
d368 1
a368 1
 *	void bus_space_write_region_N(bus_space_tag_t tag,
d370 1
a370 1
 *	    const u_intN_t *addr, size_t count);
d424 1
a424 1
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
d426 1
a426 1
 *	    size_t count);
d480 1
a480 1
 *	void bus_space_set_region_N(bus_space_tag_t tag,
d482 1
a482 1
 *	    size_t count);
d536 1
a536 1
 *	void bus_space_copy_N(bus_space_tag_t tag,
d539 1
a539 1
 *	    size_t count);
d547 1
a547 1
	    (bus_space_tag_t,						\
d550 1
a550 1
	    bus_size_t count);						\
d585 1
a585 1
 *	void bus_space_barrier(bus_space_tag_t tag,
d587 1
a587 1
 *	    bus_size_t len, int flags);
@


1.4
log
@Canonify the _*_H_ namespace appropriately.
Also, clean up comments and wrap with _KERNEL correctly.
@
text
@d1 39
a39 2
/*      $OpenBSD: bus.h,v 1.3 1997/04/07 03:23:37 briggs Exp $ */
/*	$NetBSD: bus.h,v 1.6 1997/02/24 05:55:14 scottr Exp $	*/
a42 1
 * Copyright (C) 1996 Jason R. Thorpe.  All rights reserved.
d52 1
a52 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Scott Reynolds and
 *	Jason Thorpe for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
d87 10
a96 2
#ifdef _KERNEL
/* in machdep.c */
d98 19
a116 3
				int, bus_space_handle_t *));
void	bus_space_unmap __P((bus_space_tag_t, bus_space_handle_t,
				bus_size_t));
d120 9
d133 8
d143 13
a155 1
#endif /* _KERNEL */
d545 30
a574 42
#define	bus_space_copy_1(t, h1, o1, h2, o2, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movb	a0@@+,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h1) + (o1)), "r" ((h2) + (o2)), "g" (c) :	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_copy_2(t, h1, o1, h2, o2, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movw	a0@@+,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h1) + (o1)), "r" ((h2) + (o2)), "g" (c) :	\
		    "a0","a1","d0");					\
} while (0);

#define	bus_space_copy_4(t, h1, o1, h2, o2, c) do {			\
	(void) t;							\
	__asm __volatile ("						\
		movl	%0,a0					;	\
		movl	%1,a1					;	\
		movl	%2,d0					;	\
	1:	movl	a0@@+,a1@@+				;	\
		subql	#1,d0					;	\
		jne	1b"					:	\
								:	\
		    "r" ((h1) + (o1)), "r" ((h2) + (o2)), "g" (c) :	\
		    "a0","a1","d0");					\
} while (0);

d580 2
d594 2
a595 8
#define	BUS_BARRIER_READ	0x01		/* force read barrier */
#define	BUS_BARRIER_WRITE	0x02		/* force write barrier */

/*
 * Machine-dependent extensions.
 */
int	bus_probe __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, int sz));
@


1.3
log
@Ahem...  bus_probe() already exists and does what bus_space_bad_addr() does.
Nuke the latter.
@
text
@d1 1
a1 1
/*      $OpenBSD: bus.h,v 1.2 1997/04/05 16:22:06 briggs Exp $ */
d55 1
d70 1
@


1.2
log
@Implement a bus_space_bad_addr() function to aid in some device probing with
the bus_space universe.
@
text
@d1 1
a1 1
/*      $OpenBSD: bus.h,v 1.1 1997/02/26 05:38:12 gene Exp $ */
a68 2
int	bus_space_bad_addr __P((bus_space_tag_t tag, bus_space_handle_t hand,
				bus_size_t offset, int byte_size));
@


1.1
log
@Adds support for bus_space functions borrowed in concept from the
i386 and in execution from scott reynolds.
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d55 1
d69 2
@
