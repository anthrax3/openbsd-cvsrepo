head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.2.0.20
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.18
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.16
	OPENBSD_2_9_BASE:1.2
	NIKLAS_UNDEAD:1.2.0.14
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.8
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.5;

1.5
date	2004.12.14.14.50.55;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.15.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.05.08.22.13.02;	author gene;	state Exp;
branches
	1.2.8.1
	1.2.20.1;
next	1.1;

1.1
date	98.02.13.04.14.54;	author gene;	state Exp;
branches;
next	;

1.2.8.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	;

1.2.20.1
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.6
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: psc.h,v 1.5 2004/12/14 14:50:55 martin Exp $	*/
/*	$NetBSD: psc.h,v 1.5 2004/03/26 12:15:46 wiz Exp $	*/

/*-
 * Copyright (c) 1997 David Huang <khym@@azeotrope.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Some register definitions for the PSC, present only on the
 * Centris/Quadra 660av and the Quadra 840av.
 */

extern volatile u_int8_t *PSCBase;

#define psc_reg1(r) (*((volatile u_int8_t *)(PSCBase+r)))
#define	psc_reg2(r) (*((volatile u_int16_t *)(PSCBase+r)))
#define	psc_reg4(r) (*((volatile u_int32_t *)(PSCBase+r)))

void	psc_init(void);

int	add_psc_lev3_intr(void (*)(void *), void *);
int	add_psc_lev4_intr(int, int (*)(void *), void *);
int	add_psc_lev5_intr(int, void (*)(void *), void *);
int	add_psc_lev6_intr(int, void (*)(void *), void *);

int	remove_psc_lev3_intr(void);
int	remove_psc_lev4_intr(int);
int	remove_psc_lev5_intr(int);
int	remove_psc_lev6_intr(int);

/*
 * Reading an interrupt status register returns a mask of the
 * currently interrupting devices (one bit per device). Reading an
 * interrupt enable register returns a mask of the currently enabled
 * devices. Writing an interrupt enable register with the MSB set
 * enables the interrupts in the lower 4 bits, while writing with the
 * MSB clear disables the corresponding interrupts.
 * e.g. write 0x81 to enable device 0, write 0x86 to enable devices 1
 * and 2, write 0x02 to disable device 1.
 *
 * Level 3 device 0 is MACE
 * Level 4 device 0 is 3210 DSP?
 * Level 4 device 1 is SCC channel A (modem port)
 * Level 4 device 2 is SCC channel B (printer port)
 * Level 4 device 3 is MACE DMA completion
 * Level 5 device 0 is 3210 DSP?
 * Level 5 device 1 is 3210 DSP?
 * Level 6 device 0 is ?
 * Level 6 device 1 is ?
 * Level 6 device 2 is ?
 */

/* PSC interrupt registers */
#define PSC_ISR_BASE   0x100   /* ISR is BASE + 0x10 * level */
#define PSC_IER_BASE   0x104   /* IER is BASE + 0x10 * level */

#define	PSC_LEV3_ISR	0x130	/* level 3 interrupt status register */
#define	PSC_LEV3_IER	0x134	/* level 3 interrupt enable register */
#define	  PSCINTR_ENET      0	/*   Ethernet interrupt */

#define	PSC_LEV4_ISR	0x140	/* level 4 interrupt status register */
#define	PSC_LEV4_IER	0x144	/* level 4 interrupt enable register */
#define	  PSCINTR_SCCA      1	/*   SCC channel A interrupt */
#define	  PSCINTR_SCCB      2	/*   SCC channel B interrupt */
#define	  PSCINTR_ENET_DMA  3	/*   Ethernet DMA completion interrupt */

#define	PSC_LEV5_ISR	0x150	/* level 5 interrupt status register */
#define	PSC_LEV5_IER	0x154	/* level 5 interrupt enable register */

#define	PSC_LEV6_ISR	0x160	/* level 6 interrupt status register */
#define	PSC_LEV6_IER	0x164	/* level 6 interrupt enable register */

/* PSC DMA channel control registers */
#define	PSC_CTLBASE	0xc00

#define PSC_SCSI_CTL	0xc00	/* SCSI control/status */
#define	PSC_ENETRD_CTL	0xc10	/* MACE receive DMA channel control/status */
#define	PSC_ENETWR_CTL	0xc20	/* MACE transmit DMA channel control/status */
#define	PSC_FDC_CTL	0xc30	/* Floppy disk */
#define PSC_SCCA_CTL	0xc40	/* SCC channel A */
#define PSC_SCCB_CTL	0xc50	/* SCC channel B */
#define PSC_SCCATX_CTL	0xc60	/* SCC channel A transmit */

/* PSC DMA channels */
#define	PSC_ADDRBASE	0x1000
#define	PSC_LENBASE	0x1004
#define	PSC_CMDBASE	0x1008

#define	PSC_SCSI_ADDR	0x1000	/* SCSI DMA address register */
#define PSC_SCSI_LEN	0x1004	/* SCSI DMA buffer count */
#define	PSC_SCSI_CMD	0x1008	/* SCSI DMA command register */
#define	PSC_ENETRD_ADDR	0x1020	/* MACE receive DMA address register */
#define	PSC_ENETRD_LEN	0x1024	/* MACE receive DMA buffer count */
#define	PSC_ENETRD_CMD	0x1028	/* MACE receive DMA command register */
#define	PSC_ENETWR_ADDR	0x1040	/* MACE transmit DMA address register */
#define	PSC_ENETWR_LEN	0x1044	/* MACE transmit DMA length */
#define	PSC_ENETWR_CMD	0x1048	/* MACE transmit DMA command register */

/*
 * PSC DMA channels are controlled by two sets of registers (see p.29
 * of the Quadra 840av and Centris 660av Developer Note). Add the
 * following offsets to get the desired register set.
 */
#define	PSC_SET0	0x00
#define	PSC_SET1	0x10
@


1.5
log
@sync with NetBSD, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psc.h,v 1.4 2002/03/14 03:15:55 millert Exp $	*/
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 2
a2 2
/*	$OpenBSD: psc.h,v 1.3 2002/03/14 01:26:35 millert Exp $	*/
/*	$NetBSD: psc.h,v 1.3 1998/04/24 05:27:24 scottr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1997 David Huang <khym@@bga.com>
d75 3
d95 3
d100 4
d106 7
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: psc.h,v 1.2 1998/05/08 22:13:02 gene Exp $	*/
d42 4
a45 4
int	add_psc_lev3_intr __P((void (*)(void *), void *));
int	add_psc_lev4_intr __P((int, int (*)(void *), void *));
int	add_psc_lev5_intr __P((int, void (*)(void *), void *));
int	add_psc_lev6_intr __P((int, void (*)(void *), void *));
@


1.2
log
@New and much smarter handling of the PSC chip.
Based on briggs' work with some by me.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
void	psc_init __P((void));
d47 4
a50 4
int	remove_psc_lev3_intr __P((void));
int	remove_psc_lev4_intr __P((int));
int	remove_psc_lev5_intr __P((int));
int	remove_psc_lev6_intr __P((int));
@


1.2.20.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psc.h,v 1.2 1998/05/08 22:13:02 gene Exp $	*/
d40 1
a40 1
void	psc_init(void);
d42 9
a50 9
int	add_psc_lev3_intr(void (*)(void *), void *);
int	add_psc_lev4_intr(int, int (*)(void *), void *);
int	add_psc_lev5_intr(int, void (*)(void *), void *);
int	add_psc_lev6_intr(int, void (*)(void *), void *);

int	remove_psc_lev3_intr(void);
int	remove_psc_lev4_intr(int);
int	remove_psc_lev5_intr(int);
int	remove_psc_lev6_intr(int);
@


1.2.8.1
log
@Merge in -current from about a week ago
@
text
@d40 1
a40 1
void	psc_init(void);
d42 4
a45 4
int	add_psc_lev3_intr(void (*)(void *), void *);
int	add_psc_lev4_intr(int, int (*)(void *), void *);
int	add_psc_lev5_intr(int, void (*)(void *), void *);
int	add_psc_lev6_intr(int, void (*)(void *), void *);
d47 4
a50 4
int	remove_psc_lev3_intr(void);
int	remove_psc_lev4_intr(int);
int	remove_psc_lev5_intr(int);
int	remove_psc_lev6_intr(int);
@


1.1
log
@Prototypes and defines for the Quadra-line psc chip.
Not yet used but will be in the code that is to come (mc).
@
text
@d1 2
a2 1
/*	$NetBSD: psc.h,v 1.2 1997/11/07 13:31:21 briggs Exp $	*/
d40 11
a50 9
int add_psc_lev3_intr __P((void (*)(void *), void *));
int add_psc_lev4_intr __P((int, int (*)(void *), void *));
int add_psc_lev5_intr __P((int, void (*)(void *), void *));
int add_psc_lev6_intr __P((int, void (*)(void *), void *));

int remove_psc_lev3_intr __P((void));
int remove_psc_lev4_intr __P((int));
int remove_psc_lev5_intr __P((int));
int remove_psc_lev6_intr __P((int));
@

