head	1.21;
access;
symbols
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.24
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.22
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.18
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.20
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.16
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.14
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.12
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.10
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.10
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.8
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.6
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.4
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_9_BASE:1.8
	NIKLAS_UNDEAD:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2012.06.20.18.23.52;	author matthew;	state dead;
branches;
next	1.20;

1.20
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.27.00.12.43;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.01.00.28.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.10.22.25.40;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.20.19.02.28;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.02.02.01.52;	author millert;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.11.30.20.58.18;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.28.15.34.16;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.18.20.50.18;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.08.17.30.40;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	99.04.24.06.39.40;	author downsj;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	98.03.07.07.27.45;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.11.30.06.12.32;	author gene;	state Exp;
branches;
next	1.5;

1.5
date	97.03.08.16.17.01;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	97.02.18.05.13.13;	author gene;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.18.35.58;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.05.26.18.14.11;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.06;	author deraadt;	state Exp;
branches;
next	;

1.8.4.1
date	2001.07.04.10.18.33;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.13;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.06.11.03.36.19;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@RIP mac68k.  No one loves you anymore.
@
text
@/*	$OpenBSD: pmap.h,v 1.20 2011/03/23 16:54:36 pirofti Exp $	*/

#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_

#include <m68k/pmap_motorola.h>

#ifdef	_KERNEL
void pmap_init_md(void);
#define	PMAP_INIT_MD()	pmap_init_md()
#endif	/* _KERNEL */

#endif	/* _MACHINE_PMAP_H_ */
@


1.20
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.19 2005/04/27 00:12:43 miod Exp $	*/
@


1.19
log
@Replace the last user of pmap_map() with an inline version, and kill pmap_map()
for good.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.18 2003/03/01 00:28:48 miod Exp $	*/
d3 2
a4 2
#ifndef	_MAC68K_PMAP_H_
#define	_MAC68K_PMAP_H_
d13 1
a13 1
#endif	/* _MAC68K_PMAP_H_ */
@


1.18
log
@- only declare and provide pmap_map() for mac68k, until it bites the dust.
  Other m68k-based arches do not need it.
- do not wait to allocate struct pv_page. Either pmap_enter() has been
  invoked with PMAP_CANFAIL and can live with this, or we are close to
  fandagoland anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.17 2002/03/14 01:26:35 millert Exp $	*/
a8 4

vaddr_t	pmap_map(vaddr_t, paddr_t, paddr_t, int);
void mac68k_set_pte(vaddr_t, paddr_t);

a10 1

@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.16 2002/01/10 22:25:40 miod Exp $	*/
d10 2
a11 1
void mac68k_set_pte(vaddr_t va, paddr_t pge);
@


1.16
log
@Bring back pmap_motorola for mac68k.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.15 2001/12/20 19:02:28 miod Exp $	*/
d10 1
a10 1
void mac68k_set_pte __P((vaddr_t va, paddr_t pge));
d12 1
a12 1
void pmap_init_md __P((void));
@


1.15
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d1 1
a1 2
/*	$OpenBSD: pmap.h,v 1.14 2001/12/02 02:01:52 millert Exp $	*/
/*	$NetBSD: pmap.h,v 1.26 1999/07/21 03:18:21 briggs Exp $	*/
a2 74
/*
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* 
 *	@@(#)pmap.h	7.6 (Berkeley) 5/10/91
 */
d6 1
a6 88
#include <machine/cpu.h>
#include <machine/pte.h>

#if defined(M68040)
#define MAC_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
#else
#define MAC_SEG_SIZE	NBSEG
#endif

#define mac68k_trunc_seg(x)	(((unsigned)(x)) & ~(MAC_SEG_SIZE-1))
#define mac68k_round_seg(x)	mac68k_trunc_seg((unsigned)(x)+MAC_SEG_SIZE-1)

/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	st_entry_t		*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	long			pm_ptpages;	/* more stats: PT pages */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040, we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed
 * for the kernel and users.  8 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define MAXKL2SIZE	32
#define MAXUL2SIZE	8
#define l2tobm(n)	(1 << (n))
#define bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define	PMAP_ACTIVATE(pmap, loadhw)					\
{									\
	if ((loadhw))							\
		loadustp(m68k_btop((paddr_t)(pmap)->pm_stpa));		\
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.
 */
typedef struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
} *pv_entry_t;

#define	PV_CI		0x01	/* all entries must be cache inhibited */
#define PV_PTPAGE	0x02	/* entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define NPVPPG	170

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};
a8 14
extern struct pmap	kernel_pmap_store;

#define	pmap_kernel()			(&kernel_pmap_store)
#define active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define	active_user_pmap(pm)	\
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

extern struct pv_entry *pv_table;	/* array of entries, one per page */

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update(pmap)			/* nothing */
d10 1
a10 2
extern	pt_entry_t *Sysmap;
extern	char *vmmap;			/* map for mem, dumps, etc. */
d12 2
a13 3
/* pmap.c */
vm_offset_t pmap_map __P((vaddr_t, paddr_t, paddr_t, int));
void mac68k_set_pte __P((vm_offset_t va, vm_offset_t pge));
@


1.14
log
@1) kill old vm_*_t types (no real effect)
2) Change flag in uvm_km_suballoc() from VM_MAP_PAGEABLE to 0
3) Pass pmap_extract the address of Segtabzeropa, not Segtabzeropa itself
@
text
@d1 2
a2 1
/*	$OpenBSD: pmap.h,v 1.13 2001/11/30 20:58:18 miod Exp $	*/
d4 74
d81 88
a168 1
#include <m68k/pmap_motorola.h>
d171 14
d186 2
a187 1
void mac68k_set_pte __P((vaddr_t va, paddr_t pge));
d189 3
a191 2
void pmap_init_md __P((void));
#define	PMAP_INIT_MD()	pmap_init_md()
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.16 2002/01/10 22:25:40 miod Exp $	*/
@


1.14.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.14.2.1 2002/01/31 22:55:13 niklas Exp $	*/
d10 1
a10 1
void mac68k_set_pte(vaddr_t va, paddr_t pge);
d12 1
a12 1
void pmap_init_md(void);
@


1.14.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d10 1
a10 2
vaddr_t	pmap_map(vaddr_t, paddr_t, paddr_t, int);
void mac68k_set_pte(vaddr_t, paddr_t);
@


1.13
log
@Switch to pmap_motorola.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.12 2001/11/28 16:13:28 art Exp $	*/
d10 1
a10 1
void mac68k_set_pte __P((vm_offset_t va, vm_offset_t pge));
@


1.12
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 2
/*	$OpenBSD: pmap.h,v 1.11 2001/11/28 15:34:16 art Exp $	*/
/*	$NetBSD: pmap.h,v 1.26 1999/07/21 03:18:21 briggs Exp $	*/
a2 74
/*
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,
 *			Michael L. Finch, Bradley A. Grantham, and
 *			Lawrence A. Kesteloot
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Alice Group.
 * 4. The names of the Alice Group or any of its members may not be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* 
 *	@@(#)pmap.h	7.6 (Berkeley) 5/10/91
 */
d6 1
a6 88
#include <machine/cpu.h>
#include <machine/pte.h>

#if defined(M68040)
#define MAC_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
#else
#define MAC_SEG_SIZE	NBSEG
#endif

#define mac68k_trunc_seg(x)	(((unsigned)(x)) & ~(MAC_SEG_SIZE-1))
#define mac68k_round_seg(x)	mac68k_trunc_seg((unsigned)(x)+MAC_SEG_SIZE-1)

/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	st_entry_t		*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	long			pm_ptpages;	/* more stats: PT pages */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040, we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed
 * for the kernel and users.  8 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define MAXKL2SIZE	32
#define MAXUL2SIZE	8
#define l2tobm(n)	(1 << (n))
#define bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define	PMAP_ACTIVATE(pmap, loadhw)					\
{									\
	if ((loadhw))							\
		loadustp(m68k_btop((paddr_t)(pmap)->pm_stpa));		\
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.
 */
typedef struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
} *pv_entry_t;

#define	PV_CI		0x01	/* all entries must be cache inhibited */
#define PV_PTPAGE	0x02	/* entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define NPVPPG	170

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};
a8 1
extern struct pmap	kernel_pmap_store;
d10 1
a10 6
#define	pmap_kernel()			(&kernel_pmap_store)
#define active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define	active_user_pmap(pm)	\
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)
d12 2
a13 12
extern struct pv_entry *pv_table;	/* array of entries, one per page */

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update()			/* nothing */

extern	pt_entry_t *Sysmap;
extern	char *vmmap;			/* map for mem, dumps, etc. */

/* pmap.c */
vm_offset_t pmap_map __P((vaddr_t, paddr_t, paddr_t, int));
void mac68k_set_pte __P((vm_offset_t va, vm_offset_t pge));
@


1.11
log
@Make pmap_update functions into nops so that we can have a consistent
pmap_update API (right now it's nop).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.10 2001/08/18 20:50:18 art Exp $	*/
d103 1
a103 1
	simple_lock_data_t	pm_lock;	/* lock on pmap */
@


1.10
log
@Move pmap_{de,}activate to vm/pmap.h, it's same on all archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9 2001/05/08 17:30:40 aaron Exp $	*/
d184 1
@


1.9
log
@Substantial update from NetBSD, most notably gives us UVM support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.8 1999/04/24 06:39:40 downsj Exp $	*/
a190 4

struct proc;
void	pmap_activate __P((struct proc *));
void	pmap_deactivate __P((struct proc *));
@


1.8
log
@Use the generic m68k param.h.
@
text
@d1 2
a2 2
/*	$OpenBSD: pmap.h,v 1.7 1998/03/07 07:27:45 gene Exp $	*/
/*	$NetBSD: pmap.h,v 1.14 1997/02/02 18:19:55 scottr Exp $	*/
d81 1
a81 1
#include <machine/pcb.h>
a98 1
	int			pm_stchanged;	/* ST changed */
d129 5
a133 8
#define PMAP_ACTIVATE(pmapp, pcbp, iscurproc) \
	if ((pmapp)->pm_stchanged) { \
		(pcbp)->pcb_ustp = m68k_btop((vm_offset_t)(pmapp)->pm_stpa); \
		if (iscurproc) \
			loadustp((pcbp)->pcb_ustp); \
		(pmapp)->pm_stchanged = FALSE; \
	}
#define PMAP_DEACTIVATE(pmapp, pcbp)
d142 1
a142 1
	vm_offset_t	pv_va;		/* virtual address for mapping */
d171 1
a171 1
struct pmap	kernel_pmap_store;
d176 3
a181 2
#define pa_to_pvh(pa)			(&pv_table[pmap_page_index(pa)])

a187 1
__BEGIN_DECLS
d189 6
a194 23
void	mac68k_set_pte __P((vm_offset_t va, vm_offset_t pge));
void	pmap_remove_mapping  __P((pmap_t, vm_offset_t, pt_entry_t *, int));
boolean_t	pmap_testbit __P((vm_offset_t, int));
void	pmap_changebit       __P((vm_offset_t, int, boolean_t));
void	pmap_enter_ptpage    __P((pmap_t, vm_offset_t));
vm_offset_t   pmap_map __P((vm_offset_t, vm_offset_t, vm_offset_t, int));
void	pmap_pvdump          __P((vm_offset_t));
void	pmap_check_wiring    __P((char *, vm_offset_t));
void	pmap_collect_pv __P((void));
void	pmap_activate __P((register pmap_t, struct pcb *));
void	pmap_deactivate __P((register pmap_t, struct pcb *));

/* pmap_bootstrap.c */
void	pmap_bootstrap __P((vm_offset_t, register vm_offset_t));
void	bootstrap_mac68k __P((int));

/* locore.s */
void	loadustp __P((vm_offset_t));
void	TBIA __P((void));
void	TBIS __P((vm_offset_t));
void	DCFP __P((vm_offset_t));
void	ICPP __P((vm_offset_t));
__END_DECLS
@


1.8.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pmap.h,v 1.26 1999/07/21 03:18:21 briggs Exp $	*/
d81 1
a81 1
#include <machine/cpu.h>
d99 1
d130 8
a137 5
#define	PMAP_ACTIVATE(pmap, loadhw)					\
{									\
	if ((loadhw))							\
		loadustp(m68k_btop((paddr_t)(pmap)->pm_stpa));		\
}
d146 1
a146 1
	vaddr_t		pv_va;		/* virtual address for mapping */
d175 1
a175 1
extern struct pmap	kernel_pmap_store;
a179 3
#define	active_user_pmap(pm)	\
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)
d183 2
d191 1
d193 23
a215 6
vm_offset_t pmap_map __P((vaddr_t, paddr_t, paddr_t, int));
void mac68k_set_pte __P((vm_offset_t va, vm_offset_t pge));

struct proc;
void	pmap_activate __P((struct proc *));
void	pmap_deactivate __P((struct proc *));
@


1.8.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.8.4.1 2001/07/04 10:18:33 niklas Exp $	*/
d191 4
@


1.8.4.3
log
@Merge in -current
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 74
d81 88
a168 1
#include <m68k/pmap_motorola.h>
d171 13
d185 2
a186 1
void mac68k_set_pte __P((vaddr_t va, paddr_t pge));
d188 3
a190 2
void pmap_init_md __P((void));
#define	PMAP_INIT_MD()	pmap_init_md()
@


1.8.4.4
log
@Merge in -current from about a week ago
@
text
@d10 1
a10 1
void mac68k_set_pte(vaddr_t va, paddr_t pge);
d12 1
a12 1
void pmap_init_md(void);
@


1.8.4.5
log
@Sync the SMP branch with 3.3
@
text
@d10 1
a10 2
vaddr_t	pmap_map(vaddr_t, paddr_t, paddr_t, int);
void mac68k_set_pte(vaddr_t, paddr_t);
@


1.7
log
@Prototype pmap_map here so we can use it in machdep.c.
Eventually, pmap_activate and pmap_deactivate will go away completely in favor
of a better m68k framework, but we're not ready for that.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 1997/11/30 06:12:32 gene Exp $	*/
d132 1
a132 1
		(pcbp)->pcb_ustp = mac68k_btop((vm_offset_t)(pmapp)->pm_stpa); \
@


1.6
log
@Canonify the _*_H_ namespace appropriately.
Also, clean up comments and wrap with _KERNEL correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 1997/03/08 16:17:01 briggs Exp $	*/
d198 1
@


1.5
log
@Sync with NetBSD of about 4 March.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 1997/02/18 05:13:13 gene Exp $	*/
d78 2
a79 2
#ifndef	_PMAP_MACHINE_
#define	_PMAP_MACHINE_
d218 1
a218 1
#endif	/* _PMAP_MACHINE_ */
@


1.4
log
@Synch declaration of copypage w/ m68k-general definitions per Ken's changes.
This might get moved out soon.
@
text
@d1 2
a2 2
/*	$OpenBSD: pmap.h,v 1.3 1996/05/26 18:35:58 briggs Exp $	*/
/*	$NetBSD: pmap.h,v 1.13 1996/05/18 18:52:41 briggs Exp $	*/
a213 1
void	copypage __P((void *, void *));
@


1.3
log
@Add OpenBSD Id string.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d214 1
a214 1
void	copypage __P((caddr_t, caddr_t));
@


1.2
log
@Sync with NetBSD-current.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pmap.h,v 1.11 1995/06/24 16:18:50 briggs Exp $	*/
d80 1
d189 27
d218 1
a218 1
#endif	_PMAP_MACHINE_
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

