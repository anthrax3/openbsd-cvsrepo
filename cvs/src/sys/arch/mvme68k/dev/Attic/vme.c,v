head	1.31;
access;
symbols
	OPENBSD_5_5:1.30.0.14
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.10
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.8
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.6
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.12
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.10
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.8
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.6
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.14
	UBC:1.11.0.10
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.8
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.6
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.30;

1.30
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.27.22.04.03;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.01.22.08.13;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.01.21.40.49;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.17.22.28.41;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.27.14.19.09;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.24.22.43.16;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.30.22.29.45;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.02.18.02.13;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.02.17.57.29;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.14.20.52.49;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.20.00.34.28;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.08.20.18.34;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.28.14.47.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.26.23.31.59;	author deraadt;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	2000.01.24.05.20.54;	author smurph;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	98.01.19.00.13.04;	author etheisen;	state Exp;
branches;
next	1.8;

1.8
date	97.02.05.15.50.55;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.24.20.30.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.11.21.04.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.46.02;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.06.11.10.15.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.11.06.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.43.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.43.06;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2001.04.18.16.10.31;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.11.10.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vme.c,v 1.30 2011/04/07 15:30:15 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 2000 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/fcntl.h>
#include <sys/device.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <uvm/uvm_extern.h>

#include <mvme68k/dev/vme.h>

#include "lrc.h"
#include "mc.h"
#include "ofobio.h"
#include "pcc.h"
#include "pcctwo.h"

#if NLRC > 0
#include <mvme68k/dev/lrcreg.h>
#endif
#if NMC > 0
#include <mvme68k/dev/mcreg.h>
#endif
#if NPCC > 0
#include <mvme68k/dev/pccreg.h>
#endif
#if NPCCTWO > 0
#include <mvme68k/dev/pcctworeg.h>
#endif

int  vmematch(struct device *, void *, void *);
void vmeattach(struct device *, struct device *, void *);

void vme1chip_init(struct vmesoftc *sc);
void vme2chip_init(struct vmesoftc *sc);
paddr_t vme2chip_map(u_long base, int len, int dwidth);
int vme2abort(void *);

void vmeunmap(vaddr_t, int);
int vmeprint(void *, const char *);

static int vmebustype;

struct vme2reg *sys_vme2;

struct cfattach vme_ca = {
	sizeof(struct vmesoftc), vmematch, vmeattach
};

struct cfdriver vme_cd = {
	NULL, "vme", DV_DULL
};

/*
 * bus_space routines for VME mappings
 */

int	vme_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	vme_unmap(bus_space_handle_t, bus_size_t);
int	vme_subregion(bus_space_handle_t, bus_size_t, bus_size_t,
	    bus_space_handle_t *);
void *	vme_vaddr(bus_space_handle_t);

const struct mvme68k_bus_space_tag vme_bustag = {
	vme_map,
	vme_unmap,
	vme_subregion,
	vme_vaddr
};

/*
 * VME space mapping functions
 */

int
vme_map(bus_addr_t addr, bus_size_t size, int flags, bus_space_handle_t *ret)
{
	vaddr_t map;

	map = (vaddr_t)mapiodev((paddr_t)addr, size);
	if (map == 0)
		return ENOMEM;

	*ret = (bus_space_handle_t)map;
	return 0;
}

void
vme_unmap(bus_space_handle_t handle, bus_size_t size)
{
	unmapiodev((vaddr_t)handle, size);
}

int
vme_subregion(bus_space_handle_t handle, bus_addr_t offset, bus_size_t size,
    bus_space_handle_t *ret)
{
	*ret = handle + offset;
	return (0);
}

void *
vme_vaddr(bus_space_handle_t handle)
{
	return (void *)handle;
}

/*
 * Extra D16 access functions
 *
 * D16 cards will trigger bus errors on attempting to read or write more
 * than 16 bits on the bus. Given how the m88k processor works, this means
 * basically that all long (D32) accesses must be carefully taken care of.
 *
 * Since the kernels bcopy() and bzero() routines will use 32 bit accesses
 * for performance, here are specific D16-compatible routines. They will
 * also revert to D8 operations if neither of the operands is properly
 * aligned.
 */

void d16_bcopy(const void *, void *, size_t);
void d16_bzero(void *, size_t);

void
d16_bcopy(const void *src, void *dst, size_t len)
{
	if ((vaddr_t)src & 1 || (vaddr_t)dst & 1)
		bus_space_write_region_1(&vme_bustag, 0, (vaddr_t)dst,
		    (void *)src, len);
	else {
		bus_space_write_region_2(&vme_bustag, 0, (vaddr_t)dst,
		    (void *)src, len / 2);
		if (len & 1)
			bus_space_write_1(&vme_bustag, 0,
			    dst + len - 1, *(u_int8_t *)(src + len - 1));
	}
}

void
d16_bzero(void *dst, size_t len)
{
	if ((vaddr_t)dst & 1)
		bus_space_set_region_1(&vme_bustag, 0, (vaddr_t)dst, 0, len);
	else {
		bus_space_set_region_2(&vme_bustag, 0, (vaddr_t)dst, 0, len / 2);
		if (len & 1)
			bus_space_write_1(&vme_bustag, 0, dst + len - 1, 0);
	}
}

/*
 * Configuration glue
 */

int
vmematch(parent, cf, args)
	struct device *parent;
	void *cf;
	void *args;
{
#if NMC > 0
	struct confargs *ca = args;

	if (ca->ca_bustype == BUS_MC) {
		if (sys_mc->mc_ver & MC_VER_NOVME)
			return (0);
	}
#endif
	return (1);
}

#if defined(MVME162) || defined(MVME167) || defined(MVME172) || defined(MVME177)
/*
 * make local addresses 1G-2G correspond to VME addresses 3G-4G,
 * as D32
 */
#define VME2_D32STARTPHYS	(1*1024*1024*1024UL)
#define VME2_D32ENDPHYS		(2*1024*1024*1024UL)
#define VME2_D32STARTVME	(3*1024*1024*1024UL)
#define VME2_D32BITSVME		(3*1024*1024*1024UL)

/*
 * make local addresses 3G-3.75G correspond to VME addresses 3G-3.75G,
 * as D16
 */
#define VME2_D16STARTPHYS	(3*1024*1024*1024UL)
#define VME2_D16ENDPHYS		(3*1024*1024*1024UL + 768*1024*1024UL)
#endif

/*
 * Returns a physical address mapping for a VME address & length.
 * Note: on some hardware it is not possible to create certain
 * mappings, ie. the MVME147 cannot do 32 bit accesses to VME bus
 * addresses from 0 to physmem.
 */
paddr_t
vmepmap(sc, vmeaddr, len, bustype)
	struct vmesoftc *sc;
	paddr_t vmeaddr;
	int len;
	int bustype;
{
	paddr_t base = vmeaddr;

	len = roundup(len, NBPG);
	switch (vmebustype) {
#if NLRC > 0 || NOFOBIO > 0 || NPCC > 0
	case BUS_LRC:
	case BUS_OFOBIO:
	case BUS_PCC:
		switch (bustype) {
		case BUS_VMES:
#ifdef DEBUG
			printf("base %8p/0x%8x len 0x%x\n",
				vmeaddr, base, len);
#endif
			if (base > VME1_A16BASE &&
			    (base+len - VME1_A16BASE) < VME1_A16D16LEN) {
				base = base - VME1_A16BASE + VME1_A16D16BASE;
#ifdef DEBUG
				printf("vmes1: base = 0x%8x\n", base); /* 1:1 */
#endif
			} else if (base > VME1_A32D16BASE &&
			    base+len < VME1_A16BASE) {
				/* 1:1 mapped */
#ifdef DEBUG
				printf("vmes2: base = 0x%8x\n", base);
#endif
			} else {
				printf("%s: cannot map pa 0x%x len 0x%x\n",
				    sc->sc_dev.dv_xname, base, len);
				return (0);
			}
			break;
		case BUS_VMEL:
			if (base >= physmem && (base+len) < VME1_A32D32LEN)
				base = base + VME1_A32D32BASE;
			else if (base+len < VME1_A32D16LEN)		/* HACK! */
				base = base + VME1_A32D16BASE;
			else {
				printf("%s: cannot map pa 0x%x len 0x%x\n",
				    sc->sc_dev.dv_xname, base, len);
				return (0);
			}
			break;
		}
		break;
#endif
#if NMC > 0 || NPCCTWO > 0
	case BUS_MC:
	case BUS_PCCTWO:
		switch (bustype) {
		case BUS_VMES:
#ifdef DEBUG
			printf("base %x len %d\n", base, len);
#endif
			if (base > VME2_A16BASE &&
			    (base+len-VME2_A16BASE) < VME2_A16D16LEN) {
				/* XXX busted? */
				base = base - VME2_A16BASE + VME2_A16D16BASE;
			} else if (base > VME2_A24BASE &&
			    (base+len-VME2_A24BASE) < VME2_A24D16LEN) {
				base = base - VME2_A24BASE + VME2_D16STARTPHYS;
			} else if ((base+len) < VME2_A32D16LEN) {
				/* XXX busted? */
				base = base + VME2_A32D16BASE;
			} else {
#ifdef DEBUG
				printf("vme2chip_map\n");
#endif
				base = vme2chip_map(base, len, 16);
			}
			break;
		case BUS_VMEL:
#if 0
			if (base > VME2_A16BASE &&
			    (base+len-VME2_A16BASE) < VME2_A16D32LEN)
				base = base - VME2_A16BASE + VME2_A16D32BASE;
#endif
			base = vme2chip_map(base, len, 32);
			break;
		}
		break;
#endif
	}
	return (base);
}

/* if successful, returns the va of a vme bus mapping */
vaddr_t
vmemap(sc, vmeaddr, len, bustype)
	struct vmesoftc *sc;
	paddr_t vmeaddr;
	int len;
	int bustype;
{
	paddr_t pa;
	vaddr_t va;

	pa = vmepmap(sc, vmeaddr, len, bustype);
	if (pa == 0)
		return (0);
	va = mapiodev(pa, len);
	return (va);
}

void
vmeunmap(va, len)
	vaddr_t va;
	int len;
{
	unmapiodev(va, len);
}

int
vmerw(sc, uio, flags, bus)
	struct vmesoftc *sc;
	struct uio *uio;
	int flags;
	int bus;
{
	vaddr_t v;
	int c;
	struct iovec *iov;
	vaddr_t vme;
	int error = 0;

	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("vmerw");
			continue;
		}

		v = uio->uio_offset;
		c = min(iov->iov_len, MAXPHYS);
		if ((v & PGOFSET) + c > NBPG)	/* max NBPG at a time */
			c = NBPG - (v & PGOFSET);
		if (c == 0)
			return (0);
		vme = vmemap(sc, trunc_page(v), NBPG, BUS_VMES);
		if (vme == 0) {
			error = EFAULT;	/* XXX? */
			continue;
		}
		error = uiomove((void *)vme + (v & PGOFSET), c, uio);
		vmeunmap(vme, NBPG);
	}
	return (error);
}

int
vmeprint(args, bus)
	void *args;
	const char *bus;
{
	struct confargs *ca = args;

	printf(" addr 0x%x", ca->ca_paddr);
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
	if (ca->ca_vec > 0)
		printf(" vec 0x%x", ca->ca_vec);
	return (UNCONF);
}

int
vmescan(parent, child, args, bustype)
	struct device *parent;
	void *child, *args;
	int bustype;
{
	struct cfdata *cf = child;
	struct confargs *ca = args;
	struct confargs oca;

	bzero(&oca, sizeof oca);
	oca.ca_iot = &vme_bustag;
	oca.ca_dmat = ca->ca_dmat;
	oca.ca_bustype = bustype;
	oca.ca_paddr = cf->cf_loc[0];
	oca.ca_vec = cf->cf_loc[1];
	oca.ca_ipl = cf->cf_loc[2];
	if (oca.ca_ipl > 0 && oca.ca_vec == -1)
		oca.ca_vec = intr_findvec(255, 0);
	oca.ca_offset = oca.ca_paddr;
	oca.ca_vaddr = (vaddr_t)-1;	/* nothing mapped during probe */
	oca.ca_name = cf->cf_driver->cd_name;

	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return (0);

	config_attach(parent, cf, &oca, vmeprint);
	return (1);
}

void
vmeattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct vmesoftc *sc = (struct vmesoftc *)self;
	struct confargs *ca = args;
#if NLRC > 0 || NOFOBIO > 0 || NPCC > 0
	struct vme1reg *vme1;
#endif
#if NMC > 0 || NPCCTWO > 0
	struct vme2reg *vme2;
#endif

	sc->sc_vaddr = ca->ca_vaddr;

	vmebustype = ca->ca_bustype;
	switch (ca->ca_bustype) {
#if NLRC > 0 || NOFOBIO > 0 || NPCC > 0
	case BUS_LRC:
	case BUS_OFOBIO:
	case BUS_PCC:
		vme1 = (struct vme1reg *)sc->sc_vaddr;
		if (vme1->vme1_scon & VME1_SCON_SWITCH)
			printf(": system controller");
		printf("\n");
		vme1chip_init(sc);
		break;
#endif
#if NMC > 0 || NPCCTWO > 0
	case BUS_MC:
	case BUS_PCCTWO:
		vme2 = (struct vme2reg *)sc->sc_vaddr;
		if (vme2->vme2_tctl & VME2_TCTL_SCON)
			printf(": system controller");
		printf("\n");
		vme2chip_init(sc);
		break;
#endif
	}

	while (config_found(self, args, NULL))
		;
}

/*
 * On the VMEbus, only one cpu may be configured to respond to any
 * particular vme ipl. Therefore, it wouldn't make sense to globally
 * enable all the interrupts all the time -- it would not be possible
 * to put two cpu's and one vme card into a single cage. Rather, we
 * enable each vme interrupt only when we are attaching a device that
 * uses it. This makes it easier (though not trivial) to put two cpu
 * cards in one VME cage, and both can have some limited access to vme
 * interrupts (just can't share the same irq).
 * Obviously no check is made to see if another cpu is using that
 * interrupt. If you share you will lose.
 */
int
vmeintr_establish(vec, ih, name)
	int vec;
	struct intrhand *ih;
	const char *name;
{
	struct vmesoftc *sc = (struct vmesoftc *) vme_cd.cd_devs[0];
#if NLRC > 0 || NOFOBIO > 0 || NPCC > 0
	struct vme1reg *vme1;
#endif
#if NMC > 0 || NPCCTWO > 0
	struct vme2reg *vme2;
#endif
	int x;

	x = intr_establish(vec, ih, name);

	switch (vmebustype) {
#if NLRC > 0 || NOFOBIO > 0 || NPCC > 0
	case BUS_LRC:
	case BUS_OFOBIO:
	case BUS_PCC:
		vme1 = (struct vme1reg *)sc->sc_vaddr;
		vme1->vme1_irqen = vme1->vme1_irqen |
		    VME1_IRQ_VME(ih->ih_ipl);
		break;
#endif
#if NMC > 0 || NPCCTWO > 0
	case BUS_MC:
	case BUS_PCCTWO:
		vme2 = (struct vme2reg *)sc->sc_vaddr;
		vme2->vme2_irqen = vme2->vme2_irqen |
		    VME2_IRQ_VME(ih->ih_ipl);
		break;
#endif
	}
	return (x);
}

#if defined(MVME141) || defined(MVME147) || defined(MVME165)
void
vme1chip_init(sc)
	struct vmesoftc *sc;
{
	struct vme1reg *vme1 = (struct vme1reg *)sc->sc_vaddr;

	vme1->vme1_scon &= ~VME1_SCON_SYSFAIL;	/* XXX doesn't work */
}
#endif


#if defined(MVME162) || defined(MVME167) || defined(MVME172) || defined(MVME177)

/*
 * XXX what AM bits should be used for the D32/D16 mappings?
 */
void
vme2chip_init(sc)
	struct vmesoftc *sc;
{
	struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vaddr;
	u_long ctl;

	sys_vme2 = vme2;

	/* turn off SYSFAIL LED */
	vme2->vme2_tctl &= ~VME2_TCTL_SYSFAIL;

	/*
	 * Display the VMEChip2 decoder status.
	 */
	printf("%s: using BUG parameters\n", sc->sc_dev.dv_xname);
	ctl = vme2->vme2_gcsrctl;
	if (ctl & VME2_GCSRCTL_MDEN1) {
		printf("%s: 1phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname,
		    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
		    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN2) {
		printf("%s: 2phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname,
		    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
		    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN3) {
		printf("%s: 3phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname,
		    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000,
		    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN4) {
		printf("%s: 4phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname,
		    vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000,
		    (vme2->vme2_master4 << 16) + (vme2->vme2_master4mod << 16),
		    (vme2->vme2_master4 & 0xffff0000) +
		      (vme2->vme2_master4mod & 0xffff0000));
	}

	/*
	 * Map the VME irq levels to the cpu levels 1:1.
	 * This is rather inflexible, but much easier.
	 */
	vme2->vme2_irql4 = (7 << VME2_IRQL4_VME7SHIFT) |
	    (6 << VME2_IRQL4_VME6SHIFT) | (5 << VME2_IRQL4_VME5SHIFT) |
	    (4 << VME2_IRQL4_VME4SHIFT) | (3 << VME2_IRQL4_VME3SHIFT) |
	    (2 << VME2_IRQL4_VME2SHIFT) | (1 << VME2_IRQL4_VME1SHIFT);

#if NPCCTWO > 0
	if (vmebustype == BUS_PCCTWO) {
		/* 
		 * pseudo driver, abort interrupt handler
		 */
		sc->sc_abih.ih_fn = vme2abort;
		sc->sc_abih.ih_ipl = 7;
		sc->sc_abih.ih_wantframe = 1;

		intr_establish(110, &sc->sc_abih, sc->sc_dev.dv_xname);	/* XXX 110 */
		vme2->vme2_irqen |= VME2_IRQ_AB;
	}
#endif
	/*
	 * Enable ACFAIL interrupt, but disable Timer 1 interrupt - we
	 * prefer it without for delay().
	 */
	vme2->vme2_irqen = (vme2->vme2_irqen | VME2_IRQ_ACF) & ~VME2_IRQ_TIC1;
}

/*
 * A32 accesses on the MVME1[67]x require setting up mappings in
 * the VME2 chip.
 * XXX VME address must be between 2G and 4G
 * XXX We only support D32 at the moment..
 */
u_long
vme2chip_map(base, len, dwidth)
	u_long base;
	int len, dwidth;
{
	switch (dwidth) {
	case 16:
		if (base < VME2_D16STARTPHYS ||
		    base + (u_long)len > VME2_D16ENDPHYS)
			return (0);
		return (base);
	case 32:
		if (base < VME2_D32STARTVME)
			return (0);
		return (base - VME2_D32STARTVME + VME2_D32STARTPHYS);
	default:
		return (0);
	}
}

#if NPCCTWO > 0
int
vme2abort(frame)
	void *frame;
{
	if ((sys_vme2->vme2_irqstat & VME2_IRQ_AB) != 0)
		sys_vme2->vme2_irqclr = VME2_IRQ_AB;

	nmihand(frame);
	return (1);
}
#endif
#endif
@


1.30
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.29 2010/06/27 22:04:03 miod Exp $ */
@


1.29
log
@More include necessary after <sys/user.h> inclusion removal
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.28 2010/06/26 23:24:43 guenther Exp $ */
d116 1
a116 1
	if (map == NULL)
d636 1
a636 1
			return (NULL);
d640 1
a640 1
			return (NULL);
d643 1
a643 1
		return (NULL);
@


1.28
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.27 2009/03/01 22:08:13 miod Exp $ */
d42 3
@


1.27
log
@Support for MVME141 boards. Tested with both VME and VSB memory boards
(and MVME327 SCSI and MVME376 Ethernet, to provide a complete system).
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.26 2009/03/01 21:40:49 miod Exp $ */
a32 1
#include <sys/user.h>
@


1.26
log
@Support for MVME165 board - code written in april 2006, eventually debugged
last month.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.25 2009/02/17 22:28:41 miod Exp $ */
d47 1
d240 1
a240 1
#if NLRC > 0 || NPCC > 0
d242 1
d440 1
a440 1
#if NLRC > 0 || NPCC > 0
d451 1
a451 1
#if NLRC > 0 || NPCC > 0
d453 1
d497 1
a497 1
#if NLRC > 0 || NPCC > 0
d508 1
a508 1
#if NLRC > 0 || NPCC > 0
d510 1
d529 1
a529 1
#if defined(MVME147) || defined(MVME165)
@


1.25
log
@Add real bus_space and bus_dma to mvme68k, so that it can benefit from
recent driver work; this gives us better osiop and vs drivers, vsbic
(although currently disabled on 68060 boards until more bugs are fixed),
and the ability to boot and root off vs and vsbic.

Existing code is not modified and still uses memory mapped structures;
this might change eventually as more code gets factorized and moved to
MI land.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.24 2005/11/27 14:19:09 miod Exp $ */
d45 2
a47 1
#include "mc.h"
d50 2
a51 2
#if NPCC > 0
#include <mvme68k/dev/pccreg.h>
d56 3
d204 1
a204 1
#if defined(MVME162) || defined(MVME167) || defined(MVME177)
d239 2
a240 1
#if NPCC > 0
a419 1

d438 1
a438 1
#if NPCC > 0
d449 2
a450 1
#if NPCC > 0
d494 1
a494 1
#if NPCC > 0
d505 2
a506 1
#if NPCC > 0
d525 1
a525 1
#if defined(MVME147)
d537 1
a537 1
#if defined(MVME162) || defined(MVME167) || defined(MVME177)
a593 1
	printf("%s: vme to cpu irq level 1:1\n",sc->sc_dev.dv_xname);
d646 2
a647 2
	struct vmesoftc *sc = (struct vmesoftc *)vme_cd.cd_devs[0];
	struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vaddr;
a648 5
	if ((vme2->vme2_irqstat & VME2_IRQ_AB) == 0) {
		printf("%s: abort irq not set\n", sc->sc_dev.dv_xname);
		return (0);
	}
	vme2->vme2_irqclr = VME2_IRQ_AB;
@


1.24
log
@Get rid of the `len' locator for VME devices, since mappings have a page
granularity anyway; devices who would want more than one page mapped in
order to probe for the hardware can take appropriate action in their cfmatch
routine anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.23 2005/11/24 22:43:16 miod Exp $ */
d82 101
d388 3
a390 1
	printf(" addr 0x%x", ca->ca_offset);
a392 2
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
d403 1
a403 1
	struct vmesoftc *sc = (struct vmesoftc *)parent;
d407 2
d417 1
a417 3
	oca.ca_vaddr = vmemap(sc, oca.ca_paddr, PAGE_SIZE, oca.ca_bustype);
	if (oca.ca_vaddr == 0)
		oca.ca_vaddr = (vaddr_t)-1;
d419 2
a420 3
	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0) {
		if (oca.ca_vaddr != (vaddr_t)-1)
			vmeunmap(oca.ca_vaddr, PAGE_SIZE);
d422 1
a422 5
	}
	/*
	 * If match works, the driver is responsible for
	 * vmunmap()ing if it does not need the mapping. 
	 */
d466 1
a466 1
	while (config_found(self, NULL, NULL))
@


1.23
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.22 2004/07/30 22:29:45 miod Exp $ */
d308 2
a309 3
	oca.ca_len = cf->cf_loc[1];
	oca.ca_vec = cf->cf_loc[2];
	oca.ca_ipl = cf->cf_loc[3];
a311 2
	if (oca.ca_len == -1)
		oca.ca_len = 4096;
d314 1
a314 1
	oca.ca_vaddr = vmemap(sc, oca.ca_paddr, oca.ca_len, oca.ca_bustype);
d320 1
a320 1
			vmeunmap(oca.ca_vaddr, oca.ca_len);
@


1.22
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.21 2004/07/02 18:02:13 miod Exp $ */
d64 1
a64 1
u_long vme2chip_map(u_long base, int len, int dwidth);
d67 1
a67 1
void vmeunmap(void *, int);
d123 1
a123 1
void *
d126 1
a126 1
	void *vmeaddr;
d130 1
a130 1
	u_int32_t base = (u_int32_t)vmeaddr;
d157 1
a157 1
				return (NULL);
d168 1
a168 1
				return (NULL);
a196 2
				if (base == NULL)
					return (NULL);
a205 2
			if (base == NULL)
				return (NULL);
d211 1
a211 1
	return ((void *)base);
d215 1
a215 1
void *
d218 1
a218 1
	void *vmeaddr;
d222 2
a223 1
	void *pa, *va;
d226 2
a227 2
	if (pa == NULL)
		return (NULL);
d234 1
a234 1
	void *va;
d247 4
a250 4
	register vm_offset_t v;
	register int c;
	register struct iovec *iov;
	void *vme;
d269 2
a270 3
		vme = vmemap(sc, (void *)(v & ~PGOFSET),
		    NBPG, BUS_VMES);
		if (vme == NULL) {
d307 1
a307 1
	oca.ca_paddr = (void *)cf->cf_loc[0];
d316 1
a316 1
	oca.ca_offset = (u_int)oca.ca_paddr;
d318 2
a319 2
	if (!oca.ca_vaddr)
		oca.ca_vaddr = (void *)-1;
d322 1
a322 1
		if (oca.ca_vaddr != (void *)-1)
@


1.21
log
@During bootup, only print the VMEChip2 decoder settings for those which are
enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.20 2004/07/02 17:57:29 miod Exp $ */
d394 1
a394 1
vmeintr_establish(vec, ih)
d397 1
d408 1
a408 1
	x = (intr_establish(vec, ih));
d510 1
a510 1
		intr_establish(110, &sc->sc_abih);	/* XXX 110 */
@


1.20
log
@Kill ca_master in autoconf structures. Drivers either only attach to one
specific bus (mc/pcc/pcctwo), or they know it from the ca_bustype value,
and can use the globals sys_busname variables.

This also allows for some code simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.19 2004/01/14 20:52:49 miod Exp $ */
d458 3
a460 1
	ctl = vme2->vme2_masterctl;
d462 28
a489 24
	/* setup a A32D16 space */
	printf("%s: 1phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
	    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);

	/* setup a A32D32 space */
	printf("%s: 2phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
	    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);

	/* setup a A24D16 space */
	printf("%s: 3phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000,
	    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000);

	/* setup a XXXXXX space */
	printf("%s: 4phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000,
	    (vme2->vme2_master4 << 16) + (vme2->vme2_master4mod << 16),
       (vme2->vme2_master4 & 0xffff0000) + (vme2->vme2_master4 & 0xffff0000));
d499 1
a499 4
	/*
	printf("%s: vme2_irql4 = 0x%08x\n",	sc->sc_dev.dv_xname,
	    vme2->vme2_irql4);
	*/
@


1.19
log
@mvme* do not support buses with indirect configuration, so don't check and
mourn for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.18 2004/01/14 20:50:48 miod Exp $ */
d92 1
a92 3
		struct mcreg *mc = (struct mcreg *)ca->ca_master;

		if (mc->mc_ver & MC_VER_NOVME)
a323 1
	oca.ca_master = (void *)sc;
@


1.18
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.17 2003/12/20 00:34:28 miod Exp $ */
a309 5

	if (parent->dv_cfdata->cf_driver->cd_indirect) {
		printf(" indirect devices not supported\n");
		return 0;
	}
@


1.17
log
@Passl -Wformat. Fix some blatant -Wuninitialized errors as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.16 2003/10/08 20:18:34 miod Exp $ */
d79 1
a79 1
	NULL, "vme", DV_DULL, 0
@


1.16
log
@On 167 and 177 boards, use a VMEChip2 timer for accurate delay() whenever
possible, rather than a tight loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.15 2003/06/02 05:09:14 deraadt Exp $ */
d140 2
a141 1
			printf("base 0x%8x/0x%8x len 0x%x\n",
d143 1
d147 1
d149 1
d153 1
d155 1
d181 3
a183 1
			/*printf("base %x len %d\n", base, len);*/
d195 1
d197 1
d469 1
a469 1
	printf("%s: 1phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
d475 1
a475 1
	printf("%s: 2phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
d481 1
a481 1
	printf("%s: 3phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
d487 1
a487 1
	printf("%s: 4phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
@


1.15
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.14 2002/04/28 14:47:50 miod Exp $ */
d72 2
a348 1
	int scon;
d357 3
a359 2
		scon = (vme1->vme1_scon & VME1_SCON_SWITCH);
		printf(": %sscon\n", scon ? "" : "not ");
d367 3
a369 2
		scon = (vme2->vme2_tctl & VME2_TCTL_SCON);
		printf(": %ssystem controller\n", scon ? "" : "not ");
d451 2
d508 5
a512 1
	vme2->vme2_irqen = vme2->vme2_irqen | VME2_IRQ_ACF;
@


1.14
log
@A few more tweaks to let non-GENERIC kernels (MVMEfoo) build as well with -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.13 2002/04/27 23:21:05 miod Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.12 2002/03/14 01:26:37 millert Exp $ */
d92 1
a94 1
#if NMC > 0
d347 1
d349 2
d352 1
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.11 2000/03/26 23:31:59 deraadt Exp $ */
d68 2
a69 2
int vme1chip_init(struct vmesoftc *sc);
int vme2chip_init(struct vmesoftc *sc);
d71 4
a74 1
int vme2abort(struct frame *frame);
d246 1
a246 1
	register vm_offset_t o, v;
a302 1
	struct confargs *ca = args;
d427 1
a427 1
int
d443 1
a443 1
int
d448 1
a448 1
	u_long ctl, addr, vasize;
d477 2
a478 2
	    vme2->vme2_master4 << 16 + vme2->vme2_master4mod << 16,
       vme2->vme2_master4 & 0xffff0000 + vme2->vme2_master4 & 0xffff0000);
a497 1
		sc->sc_abih.ih_arg = 0;
d529 2
d537 1
a537 1
	struct frame *frame;
d542 1
a542 1
	if (vme2->vme2_irqstat & VME2_IRQ_AB == 0) {
@


1.11
log
@callout.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.10 2000/01/24 05:20:54 smurph Exp $ */
d65 2
a66 2
int  vmematch __P((struct device *, void *, void *));
void vmeattach __P((struct device *, struct device *, void *));
d68 4
a71 4
int vme1chip_init __P((struct vmesoftc *sc));
int vme2chip_init __P((struct vmesoftc *sc));
u_long vme2chip_map __P((u_long base, int len, int dwidth));
int vme2abort __P((struct frame *frame));
@


1.11.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.11 2000/03/26 23:31:59 deraadt Exp $ */
d65 2
a66 2
int  vmematch(struct device *, void *, void *);
void vmeattach(struct device *, struct device *, void *);
d68 4
a71 7
void vme1chip_init(struct vmesoftc *sc);
void vme2chip_init(struct vmesoftc *sc);
u_long vme2chip_map(u_long base, int len, int dwidth);
int vme2abort(void *);

void vmeunmap(void *, int);
int vmeprint(void *, const char *);
a88 1
#if NMC > 0
d91 1
d243 1
a243 1
	register vm_offset_t v;
d300 1
a344 1
#if NPCC > 0
a345 2
#endif
#if NMC > 0 || NPCCTWO > 0
a346 1
#endif
d425 1
a425 1
void
d441 1
a441 1
void
d446 1
a446 1
	u_long ctl;
d475 2
a476 2
	    (vme2->vme2_master4 << 16) + (vme2->vme2_master4mod << 16),
       (vme2->vme2_master4 & 0xffff0000) + (vme2->vme2_master4 & 0xffff0000));
d496 1
a527 2
	default:
		return (NULL);
d534 1
a534 1
	void *frame;
d539 1
a539 1
	if ((vme2->vme2_irqstat & VME2_IRQ_AB) == 0) {
@


1.10
log
@Fixed bug in disksubr.c relating to disklabels.  Added MVME376 support to le.  Made installboot insert M68K for volume ID, not M88K.  Correctly documented installboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.9 1998/01/19 00:13:04 etheisen Exp $ */
a41 1
#include <sys/callout.h>
@


1.10.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.11 2000/03/26 23:31:59 deraadt Exp $ */
d42 1
@


1.10.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d65 2
a66 2
int  vmematch(struct device *, void *, void *);
void vmeattach(struct device *, struct device *, void *);
d68 4
a71 4
int vme1chip_init(struct vmesoftc *sc);
int vme2chip_init(struct vmesoftc *sc);
u_long vme2chip_map(u_long base, int len, int dwidth);
int vme2abort(struct frame *frame);
@


1.10.2.3
log
@Sync the SMP branch with 3.3
@
text
@d68 2
a69 2
void vme1chip_init(struct vmesoftc *sc);
void vme2chip_init(struct vmesoftc *sc);
d71 1
a71 4
int vme2abort(void *);

void vmeunmap(void *, int);
int vmeprint(void *, const char *);
a88 1
#if NMC > 0
d91 1
d243 1
a243 1
	register vm_offset_t v;
d300 1
a344 1
#if NPCC > 0
a345 2
#endif
#if NMC > 0 || NPCCTWO > 0
a346 1
#endif
d425 1
a425 1
void
d441 1
a441 1
void
d446 1
a446 1
	u_long ctl;
d475 2
a476 2
	    (vme2->vme2_master4 << 16) + (vme2->vme2_master4mod << 16),
       (vme2->vme2_master4 & 0xffff0000) + (vme2->vme2_master4 & 0xffff0000));
d496 1
a527 2
	default:
		return (NULL);
d534 1
a534 1
	void *frame;
d539 1
a539 1
	if ((vme2->vme2_irqstat & VME2_IRQ_AB) == 0) {
@


1.10.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.10.2.3 2003/03/27 23:32:16 niklas Exp $ */
d16 6
@


1.10.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a71 2
struct vme2reg *sys_vme2;

d77 1
a77 1
	NULL, "vme", DV_DULL
d138 1
a138 2
#ifdef DEBUG
			printf("base %8p/0x%8x len 0x%x\n",
a139 1
#endif
a142 1
#ifdef DEBUG
a143 1
#endif
a146 1
#ifdef DEBUG
a147 1
#endif
d173 1
a173 3
#ifdef DEBUG
			printf("base %x len %d\n", base, len);
#endif
a184 1
#ifdef DEBUG
a185 1
#endif
d299 5
d347 1
d356 2
a357 3
		if (vme1->vme1_scon & VME1_SCON_SWITCH)
			printf(": system controller");
		printf("\n");
d365 2
a366 3
		if (vme2->vme2_tctl & VME2_TCTL_SCON)
			printf(": system controller");
		printf("\n");
a447 2
	sys_vme2 = vme2;

d454 1
a454 1
	printf("%s: 1phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
d460 1
a460 1
	printf("%s: 2phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
d466 1
a466 1
	printf("%s: 3phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
d472 1
a472 1
	printf("%s: 4phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
d503 1
a503 5
	/*
	 * Enable ACFAIL interrupt, but disable Timer 1 interrupt - we
	 * prefer it without for delay().
	 */
	vme2->vme2_irqen = (vme2->vme2_irqen | VME2_IRQ_ACF) & ~VME2_IRQ_TIC1;
@


1.9
log
@Cleanup output for probed VME devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.8 1997/02/05 15:50:55 deraadt Exp $ */
d5 1
d367 1
a367 1
		printf(": %sscon\n", scon ? "" : "not ");
d447 1
a447 1
	u_long ctl;
d453 3
a455 5

	/* unused decoders 1 */
	vme2->vme2_master1 = 0;
	ctl &= ~(VME2_MASTERCTL_ALL << VME2_MASTERCTL_1SHIFT);
	printf("%s: 1phys 0x%08x-0x%08x to VMExxx 0x%08x-0x%08x\n",
d460 2
a461 4
	/* unused decoders 2 */
	vme2->vme2_master2 = 0;
	ctl &= ~(VME2_MASTERCTL_ALL << VME2_MASTERCTL_2SHIFT);
	printf("%s: 2phys 0x%08x-0x%08x to VMExxx 0x%08x-0x%08x\n",
d467 1
a467 6
	vme2->vme2_master3 = ((VME2_D16ENDPHYS-1) & 0xffff0000) |
	    (VME2_D16STARTPHYS >> 16);
	ctl &= ~(VME2_MASTERCTL_ALL << VME2_MASTERCTL_3SHIFT);
	ctl |= (VME2_MASTERCTL_D16 | VME2_MASTERCTL_AM24UD) <<
	    VME2_MASTERCTL_3SHIFT;
	printf("%s: 3phys 0x%08x-0x%08x to VMED16 0x%08x-0x%08x\n",
d472 2
a473 9
	/* setup a A32D32 space */
	vme2->vme2_master4 = ((VME2_D32ENDPHYS-1) & 0xffff0000) |
	    (VME2_D32STARTPHYS >> 16);
	vme2->vme2_master4mod = (VME2_D32STARTVME & 0xffff0000) |
	    (VME2_D32BITSVME >> 16);
	ctl &= ~(VME2_MASTERCTL_ALL << VME2_MASTERCTL_4SHIFT);
	ctl |= (VME2_MASTERCTL_AM32UD) <<
	    VME2_MASTERCTL_4SHIFT;
	printf("%s: 4phys 0x%08x-0x%08x to VMED32 0x%08x-0x%08x\n",
d476 2
a477 22
	    vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000);

	vme2->vme2_masterctl = ctl;
	ctl = vme2->vme2_gcsrctl;

	/* enable A16 short IO map decoder (0xffffxxxx) */
	ctl &= ~(VME2_GCSRCTL_I1EN | VME2_GCSRCTL_I1D16 | VME2_GCSRCTL_I1WP |
	    VME2_GCSRCTL_I1SU);
	ctl |= VME2_GCSRCTL_I1EN | VME2_GCSRCTL_I1D16 | VME2_GCSRCTL_I1SU;

	/* enable A24D16 (0xf0xxxxxx) and A32D16 (0xf[1-e]xxxxxx) decoders */
	ctl &= ~(VME2_GCSRCTL_I2EN | VME2_GCSRCTL_I2WP | VME2_GCSRCTL_I2SU |
	    VME2_GCSRCTL_I2PD);
	ctl |= VME2_GCSRCTL_I2EN | VME2_GCSRCTL_I2SU | VME2_GCSRCTL_I2PD;

	/* map decoders 3 & 4 which were just configured */
	ctl &= ~(VME2_GCSRCTL_MDEN4 | VME2_GCSRCTL_MDEN3 | VME2_GCSRCTL_MDEN1 |
	    VME2_GCSRCTL_MDEN2);
	ctl |= VME2_GCSRCTL_MDEN4 | VME2_GCSRCTL_MDEN3;

	vme2->vme2_gcsrctl = ctl;

d486 2
d490 1
a490 1

d493 3
d541 1
a541 1
		printf("%s: vme2chip irq not set\n", sc->sc_dev.dv_xname);
a548 1

@


1.8
log
@correct boottime messages
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.7 1996/12/24 20:30:40 deraadt Exp $ */
d141 2
a142 1
			printf("base %8x/%8x len %8x\n", vmeaddr, base, len);
d146 1
a146 1
				printf("vmes1: base = %8x\n", base); /* 1:1 */
d150 1
a150 1
				printf("vmes2: base = %8x\n", base);
d152 1
a152 1
				printf("%s: cannot map pa %x len %x\n",
d163 1
a163 1
				printf("%s: cannot map pa %x len %x\n",
d286 1
a286 1
		printf(" vec %d", ca->ca_vec);
@


1.7
log
@for the moment, yammer a bit more
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.6 1996/12/11 21:04:13 deraadt Exp $ */
a318 2
printf("pa=%8x len=%8x vec=%d ipl=%d\n", oca.ca_paddr, oca.ca_len,
oca.ca_vec, oca.ca_ipl);
a321 1
printf("va=%8x\n", oca.ca_vaddr);
d520 2
a521 1
	printf("vme2_irql4 = 0x%08x\n", vme2->vme2_irql4);
@


1.6
log
@correct master decoded logic; i have mapped a vmes device successfully now
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.5 1996/11/23 21:46:02 kstailey Exp $ */
d523 1
d536 1
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d102 18
d175 1
d177 2
a178 1
			    (base+len-VME2_A16BASE) < VME2_A16D16LEN)
d180 5
a184 4
			else if (base > VME2_A24BASE &&
			    (base+len-VME2_A24BASE) < VME2_A24D16LEN)
				base = base - VME2_A24BASE + VME2_A24D16BASE;
			else if ((base+len) < VME2_A32D16LEN)
d186 2
a187 1
			else {
d283 1
a283 1
	printf(" offset 0x%x", ca->ca_offset);
d437 1
a440 16
 * make local addresses 1G-2G correspond to VME addresses 3G-4G,
 * as D32
 */
#define VME2_D32STARTPHYS	(1*1024*1024*1024UL)
#define VME2_D32ENDPHYS		(2*1024*1024*1024UL)
#define VME2_D32STARTVME	(3*1024*1024*1024UL)
#define VME2_D32BITSVME		(3*1024*1024*1024UL)

/*
 * make local addresses 3G-3.75G correspond to VME addresses 3G-3.75G,
 * as D16
 */
#define VME2_D16STARTPHYS	(3*1024*1024*1024UL)
#define VME2_D16ENDPHYS		(3*1024*1024*1024UL + 768*1024*1024UL)

/*
d455 4
a458 3
#if 0
	/* unused decoders 1 & 2 */
	printf("%s: phys 0x%08x-0x%08x to VMExxx 0x%08x-0x%08x\n",
d462 5
a466 1
	printf("%s: phys 0x%08x-0x%08x to VMExxx 0x%08x-0x%08x\n",
a469 1
#endif
d471 1
a471 1
	/* setup a D16 space */
d475 1
a475 1
	ctl |= (VME2_MASTERCTL_AM32SP | VME2_MASTERCTL_D16) <<
d477 1
a477 2
#if 0
	printf("%s: phys 0x%08x-0x%08x to VMED16 0x%08x-0x%08x\n",
d479 2
a480 3
	    VME2_D16STARTPHYS, VME2_D16ENDPHYS-1,
	    VME2_D16STARTPHYS, VME2_D16ENDPHYS-1);
#endif
d482 1
a482 1
	/* setup a D32 space */
d488 1
a488 1
	ctl |= (VME2_MASTERCTL_AM32SP) <<
d490 1
a490 2
#if 0
	printf("%s: phys 0x%08x-0x%08x to VMED32 0x%08x-0x%08x\n",
d492 2
a493 3
	    VME2_D32STARTPHYS, VME2_D32ENDPHYS-1,
	    VME2_D32STARTVME, VME2_D32STARTVME | ~VME2_D32BITSVME);
#endif
a495 1

@


1.4
log
@use void * for pa/va instead of caddr_t
@
text
@d257 1
a257 1
	char *bus;
@


1.3
log
@cfattach/cfdriver split
@
text
@d108 1
a108 1
caddr_t
d111 1
a111 1
	caddr_t vmeaddr;
d115 1
a115 1
	u_long base = (u_long)vmeaddr;
d123 1
d125 1
a125 1
			    (base+len - VME1_A16BASE) < VME1_A16D16LEN)
d127 6
a132 3
			else if (base+len < VME1_A32D16LEN)
				base = base + VME1_A32D16BASE;
			else {
d185 1
a185 1
	return ((caddr_t)base);
d189 1
a189 1
caddr_t
d192 1
a192 1
	caddr_t vmeaddr;
d196 1
a196 1
	caddr_t pa, va;
d198 1
a198 1
	pa = vmepmap(sc, pa, len, bustype);
d207 1
a207 1
	caddr_t va;
d223 1
a223 1
	caddr_t vme;
d242 1
a242 1
		vme = vmemap(sc, (caddr_t)(v & ~PGOFSET),
d248 1
a248 1
		error = uiomove((caddr_t)vme + (v & PGOFSET), c, uio);
d292 8
a299 5
		oca.ca_vec = intr_freevec();

	oca.ca_offset = (int)oca.ca_paddr;
	oca.ca_vaddr = (void *)vmemap(sc, oca.ca_paddr, oca.ca_len,
	    oca.ca_bustype);
d302 1
d310 4
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d75 6
a80 3
struct cfdriver vmecd = {
	NULL, "vme", vmematch, vmeattach,
	DV_DULL, sizeof(struct vmesoftc), 0
d297 1
a297 1
	if ((*cf->cf_driver->cd_match)(parent, cf, &oca) == 0) {
d361 1
a361 1
	struct vmesoftc *sc = (struct vmesoftc *) vmecd.cd_devs[0];
d548 1
a548 1
	struct vmesoftc *sc = (struct vmesoftc *)vmecd.cd_devs[0];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
d17 2
a18 1
 *      This product includes software developed by Theo de Raadt
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
