head	1.23;
access;
symbols
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.22;

1.22
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.27.22.04.03;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.01.21.37.41;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.20.05.19.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.24.22.43.16;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.27.16.04.08;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.03.14.36.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.01.12.13.46;	author art;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.05.16.12.49.46;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.23.31.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.29.04.11.25;	author smurph;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	96.04.28.11.11.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.01.17.57.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.17.12.45.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.48.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.43.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.43.07;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2001.04.18.16.10.21;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.19.23;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: flash.c,v 1.22 2010/12/26 15:40:59 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/fcntl.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/mioctl.h>

#include "mc.h"

#if NMC > 0
#include <mvme68k/dev/mcreg.h>
#endif

#include <mvme68k/dev/flashreg.h>

struct flashsoftc {
	struct device	 sc_dev;
	paddr_t		 sc_paddr;
	volatile u_char *sc_vaddr;
	u_char		 sc_manu;
	u_char		 sc_ii;
	int		 sc_len;
	int		 sc_zonesize;
};

void flashattach(struct device *, struct device *, void *);
int  flashmatch(struct device *, void *, void *);

struct cfattach flash_ca = {
	sizeof(struct flashsoftc), flashmatch, flashattach
};

struct cfdriver flash_cd = {
	NULL, "flash", DV_DULL
};

int flashwritebyte(struct flashsoftc *sc, int addr, u_char val);
int flasherasezone(struct flashsoftc *sc, int addr);
u_char *flashsavezone(struct flashsoftc *, int);
int flashwritezone(struct flashsoftc *, u_char *, int);

struct flashii intel_flashii[] = {
	{ "28F008SA",	FLII_INTEL_28F008SA,	1024*1024,	64*1024 },
	{ "28F008SA-L",	FLII_INTEL_28F008SA_L,	1024*1024,	64*1024 },
	{ "28F016SA",	FLII_INTEL_28F016SA,	1024*1024,	64*1024 },
	{ NULL },
};

struct flashmanu {
	char *name;
	u_char	manu;
	struct flashii *flashii;
} flashmanu[] = {
	{ "intel", FLMANU_INTEL, intel_flashii },
	{ NULL, 0, NULL }
};

int
flashmatch(parent, cf, args)
	struct device *parent;
	void *cf;
	void *args;
{
	struct confargs *ca = args;

	switch (cputyp) {
#ifdef MVME147
	case CPU_147:
		return (0);
#endif
#ifdef MVME165
	case CPU_165:
		return (0);
#endif
#ifdef MVME167
	case CPU_166:
	case CPU_167:
		/*
		 * XXX: 166 has 4 byte-wide flash rams side-by-side, and
		 * isn't supported (yet).
		 */
		return (0);
#endif
#ifdef MVME177
	case CPU_176:
	case CPU_177:
		/*
		 * XXX: 177 has no flash.
		 */
		return (0);
#endif
#if defined(MVME162) || defined(MVME172)
	case CPU_162:
	case CPU_172:
		if (badpaddr(ca->ca_paddr, 1))
			return (0);

		if (!mc_hasflash())
			return 0;
		return (1);
#endif
	default:
		return (0);
	}
}

void
flashattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct flashsoftc *sc = (struct flashsoftc *)self;
	struct confargs *ca = args;
	int manu, ident;

	sc->sc_paddr = ca->ca_paddr;
	sc->sc_vaddr = (volatile u_char *)mapiodev(sc->sc_paddr, NBPG);

	switch (cputyp) {
#ifdef MVME162
	case CPU_162:
		mc_enableflashwrite(1);
		break;
#endif
#ifdef MVME172
	case CPU_172:
		mc_enableflashwrite(1);
		break;
#endif
	}

	/* read manufacturer and product identifier from flash */
	sc->sc_vaddr[0] = FLCMD_RESET;
	sc->sc_vaddr[0] = FLCMD_READII;
	sc->sc_manu = sc->sc_vaddr[0];
	sc->sc_ii = sc->sc_vaddr[1];
	sc->sc_vaddr[0] = FLCMD_RESET;
	for (manu = 0; flashmanu[manu].name; manu++)
		if (flashmanu[manu].manu == sc->sc_manu)
			break;
	if (flashmanu[manu].name == NULL) {
		printf(": unknown manu 0x%02x ident %02x\n",
		    sc->sc_manu, sc->sc_ii);
		return;
	}
	for (ident = 0; flashmanu[manu].flashii[ident].name; ident++)
		if (flashmanu[manu].flashii[ident].ii == sc->sc_ii)
			break;
	if (flashmanu[manu].flashii[ident].name == NULL) {
		printf(": unknown manu %s ident 0x%02x\n",
		    flashmanu[manu].name, sc->sc_ii);
		return;
	}
	sc->sc_len = flashmanu[manu].flashii[ident].size;
	sc->sc_zonesize = flashmanu[manu].flashii[ident].zonesize;
	printf(": %s %s len %d", flashmanu[manu].name,
	    flashmanu[manu].flashii[ident].name, sc->sc_len);

	sc->sc_vaddr[0] = FLCMD_CLEARSTAT;
	sc->sc_vaddr[0] = FLCMD_RESET;

	unmapiodev((vaddr_t)sc->sc_vaddr, NBPG);
	sc->sc_vaddr = (volatile u_char *)mapiodev(sc->sc_paddr, sc->sc_len);
	if (sc->sc_vaddr == NULL) {
		sc->sc_len = 0;
		printf(" -- failed to map");
	}
	printf("\n");
}

u_char *
flashsavezone(sc, start)
	struct flashsoftc *sc;
	int start;
{
	u_char *zone;

	zone = (u_char *)malloc(sc->sc_zonesize, M_TEMP, M_WAITOK);
	sc->sc_vaddr[0] = FLCMD_RESET;
	bcopy((u_char *)&sc->sc_vaddr[start], zone, sc->sc_zonesize);
	return (zone);
}

int
flashwritezone(sc, zone, start)
	struct flashsoftc *sc;
	u_char *zone;
	int start;
{
	u_char sr;
	int i;

	for (i = 0; i < sc->sc_zonesize; i++) {
		if (zone[i] == 0xff)
			continue;
		sc->sc_vaddr[start + i] = FLCMD_WSETUP;
		sc->sc_vaddr[start + i] = zone[i];
		do {
			sc->sc_vaddr[0] = FLCMD_READSTAT;
			sr = sc->sc_vaddr[0];
		} while ((sr & FLSR_WSMS) == 0);
		if (sr & FLSR_BWS)
			return (i);	/* write failed on this byte! */
		sc->sc_vaddr[0] = FLCMD_RESET;
	}
	free(zone, M_TEMP);
	return (0);
}

int
flasherasezone(sc, addr)
	struct flashsoftc *sc;
	int addr;
{
	u_char	sr;

	printf("erasing zone at %d\n", addr);

	sc->sc_vaddr[addr] = FLCMD_ESETUP;
	sc->sc_vaddr[addr] = FLCMD_ECONFIRM;

	sc->sc_vaddr[0] = FLCMD_READSTAT;
	sr = sc->sc_vaddr[0];
	while ((sr & FLSR_WSMS) == 0) {
		sc->sc_vaddr[0] = FLCMD_READSTAT;
		sr = sc->sc_vaddr[0];
	}
	printf("sr=%2x\n", sr);

	sc->sc_vaddr[0] = FLCMD_RESET;
	if (sr & FLSR_ES)
		return (-1);
	return (0);
}

/*
 * Should add some light retry code. If a write fails see if an
 * erase helps the situation... eventually flash rams become
 * useless but perhaps we can get just one more cycle out of it.
 */
int
flashwritebyte(sc, addr, val)
	struct flashsoftc *sc;
	int addr;
	u_char val;
{
	u_char sr;

	sc->sc_vaddr[addr] = FLCMD_CLEARSTAT;
	sr = sc->sc_vaddr[0];
	sc->sc_vaddr[addr] = FLCMD_WSETUP;
	sc->sc_vaddr[addr] = val;
	delay(9);
	do {
		sr = sc->sc_vaddr[addr];
	} while ((sr & FLSR_WSMS) == 0);
	printf("write status %2x\n", sr);

	sc->sc_vaddr[0] = FLCMD_RESET;
	if (sr & FLSR_BWS)
		return (-1);	/* write failed! */
	return (0);
}


/*ARGSUSED*/
int
flashopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	if (minor(dev) >= flash_cd.cd_ndevs ||
	    flash_cd.cd_devs[minor(dev)] == NULL)
		return (ENODEV);

	return (0);
}

/*ARGSUSED*/
int
flashclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	return (0);
}

/*ARGSUSED*/
int
flashioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = minor(dev);
	struct flashsoftc *sc = (struct flashsoftc *) flash_cd.cd_devs[unit];
	int error = 0;
	
	switch (cmd) {
	case MIOCGSIZ:
		*(int *)data = sc->sc_len;
		break;
	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

/*ARGSUSED*/
int
flashread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct flashsoftc *sc = (struct flashsoftc *) flash_cd.cd_devs[unit];
	vaddr_t v;
	int c;
	struct iovec *iov;
	int error = 0;

	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("flashrw");
			continue;
		}

		v = uio->uio_offset;
		c = min(iov->iov_len, MAXPHYS);
		if (v + c > sc->sc_len)
			c = sc->sc_len - v;	/* till end of FLASH */
		if (c == 0)
			return (0);
		error = uiomove((u_char *)sc->sc_vaddr + v, c, uio);
	}
	return (error);
}

/*ARGSUSED*/
int
flashwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct flashsoftc *sc = (struct flashsoftc *) flash_cd.cd_devs[unit];
	vaddr_t v;
	int c, i, r;
	struct iovec *iov;
	int error = 0;
	u_char *cmpbuf;
	int neederase = 0, needwrite = 0;
	int zonestart, zoneoff;

	cmpbuf = (u_char *)malloc(sc->sc_zonesize, M_TEMP, M_WAITOK);

	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("flashrw");
			continue;
		}

		/* 
		 * constrain to be at most a zone in size, and
		 * aligned to be within that one zone only.
		*/
		v = uio->uio_offset;
		zonestart = v & ~(sc->sc_zonesize - 1);
		zoneoff = v & (sc->sc_zonesize - 1);
		c = min(iov->iov_len, MAXPHYS);
		if (v + c > sc->sc_len)
			c = sc->sc_len - v;	/* till end of FLASH */
		if (c > sc->sc_zonesize - zoneoff)
			c = sc->sc_zonesize - zoneoff; /* till end of zone */
		if (c == 0)
			return (0);
		error = uiomove((u_char *)cmpbuf, c, uio);

		/*
		 * compare to see if we are going to need a block erase
		 * operation.
		 */
		sc->sc_vaddr[0] = FLCMD_RESET;
		for (i = 0; i < c; i++) {
			u_char x = sc->sc_vaddr[v + i];
			if (cmpbuf[i] & ~x)
				neederase = 1;
			if (cmpbuf[i] != x)
				needwrite = 1;
		}
		if (needwrite && !neederase) {
			/*
			 * we don't need to erase. all the bytes being
			 * written (thankfully) set bits.
			 */
			for (i = 0; i < c; i++) {
				if (cmpbuf[i] == sc->sc_vaddr[v + i])
					continue;
				r = flashwritebyte(sc, v + i, cmpbuf[i]);
				if (r == 0)
					continue;
				/*
				 * this doesn't make sense. we
				 * thought we didn't need to erase,
				 * but a write failed. let's try an
				 * erase operation..
				 */
				printf("%s: failed write at %d, trying erase\n",
				    sc->sc_dev.dv_xname, i);
				goto tryerase;
			}
		} else if (neederase) {
			u_char *mem;

tryerase:
			mem = flashsavezone(sc, zonestart);
			for (i = 0; i < c; i++)
				mem[zoneoff + i] = cmpbuf[i];
			flasherasezone(sc, zonestart);
			r = flashwritezone(sc, mem, zonestart);
			if (r) {
				printf("%s: failed at offset %x\n",
				    sc->sc_dev.dv_xname, r);
				free(mem, M_TEMP);
				error = EIO;
			}
		}
	}

	free(cmpbuf, M_TEMP);
	return (error);
}

paddr_t
flashmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	int unit = minor(dev);
	struct flashsoftc *sc = (struct flashsoftc *) flash_cd.cd_devs[unit];

	/* allow access only in RAM */
	if (off < 0 || off >= round_page(sc->sc_len))
		return (-1);
	return (sc->sc_paddr + off);
}
@


1.22
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.21 2010/06/27 22:04:03 miod Exp $ */
@


1.21
log
@More include necessary after <sys/user.h> inclusion removal
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.20 2010/06/26 23:24:43 guenther Exp $ */
d502 1
a502 1
	return (atop(sc->sc_paddr + off));
@


1.20
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.19 2009/03/01 21:37:41 miod Exp $ */
d39 2
@


1.19
log
@Clean up match routines vs board id; this should give 166, 172 and 176 a
change to work better.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.18 2007/12/20 05:19:38 miod Exp $ */
a30 1
#include <sys/user.h>
@


1.18
log
@Stricter range checks in mmap function.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.17 2005/12/17 07:31:26 miod Exp $ */
d104 1
d106 5
a110 1
	if (cputyp == CPU_147)
d114 6
a119 7
	/*
	 * XXX: 166 has 4 byte-wide flash rams side-by-side, and
	 * isn't supported (yet).
	 */
	if (cputyp == CPU_166)
		return (0);
	if (cputyp == CPU_167)
d123 5
a127 4
	/*
	 * XXX: 177 has no flash.
	 */
	if (cputyp == CPU_177)
d130 11
a140 2

	if (badpaddr(ca->ca_paddr, 1))
d142 1
a142 5

	if (!mc_hasflash())
		return 0;
   
	return (1);
@


1.17
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.16 2005/11/24 22:43:16 miod Exp $ */
d489 1
a489 1
	if (off < 0 || off > sc->sc_len)
@


1.16
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.15 2005/10/27 16:04:08 martin Exp $ */
d353 3
a355 3
	register vm_offset_t v;
	register int c;
	register struct iovec *iov;
d388 3
a390 3
	register vm_offset_t v;
	register int c, i, r;
	register struct iovec *iov;
@


1.15
log
@stupid me, of course these MD macros need to be converted to MI macros
as well
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.14 2004/07/03 14:36:34 miod Exp $ */
d55 7
a61 7
	struct device		sc_dev;
	u_char *		sc_paddr;
	volatile u_char *	sc_vaddr;
	u_char			sc_manu;
	u_char			sc_ii;
	int			sc_len;
	int			sc_zonesize;
d126 1
a126 1
	if (badpaddr((paddr_t)ca->ca_paddr, 1))
d145 1
a145 1
	sc->sc_vaddr = mapiodev(sc->sc_paddr, NBPG);
d190 2
a191 2
	unmapiodev((void *)sc->sc_vaddr, NBPG);
	sc->sc_vaddr = mapiodev(sc->sc_paddr, sc->sc_len);
@


1.14
log
@Oops, one more mmap() bounds check.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.13 2004/01/14 20:50:48 miod Exp $ */
d491 1
a491 1
	return (m68k_btop(sc->sc_paddr + off));
@


1.13
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.12 2003/06/02 05:09:14 deraadt Exp $ */
d489 1
a489 1
	if (off > sc->sc_len)
@


1.12
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.11 2002/04/27 23:21:05 miod Exp $ */
d72 1
a72 1
	NULL, "flash", DV_DULL, 0
@


1.11
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.10 2002/03/14 01:26:37 millert Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.9 2001/11/01 12:13:46 art Exp $ */
a34 1
#include <sys/conf.h>
d46 1
d48 1
d62 1
a62 1
	u_char *			sc_paddr;
d83 2
d132 1
a132 1
	if (badpaddr(ca->ca_paddr, 1))
d235 1
a235 1
		} while (sr & FLSR_WSMS == 0);
d302 1
a302 1
flashopen(dev, flag, mode)
d305 1
d307 1
d311 1
d317 1
a317 1
flashclose(dev, flag, mode)
d320 1
d329 4
a332 3
	dev_t   dev;
	u_char *data;
	int     cmd, flag;
a498 1

@


1.9
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.8 2001/05/16 12:49:46 ho Exp $ */
d69 2
a70 2
void flashattach __P((struct device *, struct device *, void *));
int  flashmatch __P((struct device *, void *, void *));
d80 2
a81 2
int flashwritebyte __P((struct flashsoftc *sc, int addr, u_char val));
int flasherasezone __P((struct flashsoftc *sc, int addr));
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.9 2001/11/01 12:13:46 art Exp $ */
d35 1
a46 1

a47 1
#include <machine/conf.h>
d61 1
a61 1
	u_char *		sc_paddr;
d69 2
a70 2
void flashattach(struct device *, struct device *, void *);
int  flashmatch(struct device *, void *, void *);
d80 2
a81 4
int flashwritebyte(struct flashsoftc *sc, int addr, u_char val);
int flasherasezone(struct flashsoftc *sc, int addr);
u_char *flashsavezone(struct flashsoftc *, int);
int flashwritezone(struct flashsoftc *, u_char *, int);
d129 1
a129 1
	if (badpaddr((paddr_t)ca->ca_paddr, 1))
d232 1
a232 1
		} while ((sr & FLSR_WSMS) == 0);
d299 1
a299 1
flashopen(dev, flag, mode, p)
a301 1
	struct proc *p;
a302 1

a305 1

d311 1
a311 1
flashclose(dev, flag, mode, p)
a313 1
	struct proc *p;
d322 3
a324 4
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
d491 1
@


1.8
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.7 2000/03/26 23:31:59 deraadt Exp $ */
d477 1
a477 1
int
d480 2
a481 1
	int off, prot;
@


1.7
log
@callout.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.6 2000/01/29 04:11:25 smurph Exp $ */
a209 2
	if (!zone)
		return (NULL);
a394 2
	if (!cmpbuf)
		return (ENOMEM);
@


1.6
log
@Updated flash and ipic device compatability with MC rev 0x01.  zs mods to work with LX style 162 boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.5 1996/04/28 11:11:50 deraadt Exp $ */
a40 1
#include <sys/callout.h>
@


1.6.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.7 2000/03/26 23:31:59 deraadt Exp $ */
d41 1
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.6.2.1 2001/04/18 16:10:21 niklas Exp $ */
d210 2
d397 2
@


1.6.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d477 1
a477 1
paddr_t
d480 1
a480 2
	off_t off;
	int prot;
@


1.6.2.4
log
@Merge in -current from about a week ago
@
text
@d69 2
a70 2
void flashattach(struct device *, struct device *, void *);
int  flashmatch(struct device *, void *, void *);
d80 2
a81 2
int flashwritebyte(struct flashsoftc *sc, int addr, u_char val);
int flasherasezone(struct flashsoftc *sc, int addr);
@


1.6.2.5
log
@Sync the SMP branch with 3.3
@
text
@d35 1
a46 1

a47 1
#include <machine/conf.h>
d61 1
a61 1
	u_char *		sc_paddr;
a81 2
u_char *flashsavezone(struct flashsoftc *, int);
int flashwritezone(struct flashsoftc *, u_char *, int);
d129 1
a129 1
	if (badpaddr((paddr_t)ca->ca_paddr, 1))
d232 1
a232 1
		} while ((sr & FLSR_WSMS) == 0);
d299 1
a299 1
flashopen(dev, flag, mode, p)
a301 1
	struct proc *p;
a302 1

a305 1

d311 1
a311 1
flashclose(dev, flag, mode, p)
a313 1
	struct proc *p;
d322 3
a324 4
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
d491 1
@


1.6.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.6.2.5 2003/03/27 23:32:16 niklas Exp $ */
d15 6
@


1.6.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d72 1
a72 1
	NULL, "flash", DV_DULL
@


1.5
log
@cfattach/cfdriver split; we hate caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d87 1
d96 2
a97 2
	{ "intel",	FLMANU_INTEL,		intel_flashii },
	{ NULL }
d122 7
d133 3
a135 3
	/*
	 * XXX: need to determine if it is flash or rom
	 */
d157 5
a169 1

@


1.4
log
@for now, assume no flash on 167 (is this true?)
@
text
@d1 1
a1 1
/*	$Id: flash.c,v 1.3 1995/11/17 12:45:52 deraadt Exp $ */
d62 1
a62 1
	caddr_t			sc_paddr;
d73 6
a78 3
struct cfdriver flashcd = {
	NULL, "flash", flashmatch, flashattach,
	DV_DULL, sizeof(struct flashsoftc), 0
d182 1
a182 1
	unmapiodev(sc->sc_vaddr, NBPG);
d191 1
a191 1
caddr_t
d196 1
a196 1
	caddr_t zone;
d202 1
a202 1
	bcopy((caddr_t)&sc->sc_vaddr[start], zone, sc->sc_zonesize);
d209 1
a209 1
	caddr_t zone;
d294 2
a295 2
	if (minor(dev) >= flashcd.cd_ndevs ||
	    flashcd.cd_devs[minor(dev)] == NULL)
d314 1
a314 1
	caddr_t data;
d319 1
a319 1
	struct flashsoftc *sc = (struct flashsoftc *) flashcd.cd_devs[unit];
d341 1
a341 1
	struct flashsoftc *sc = (struct flashsoftc *) flashcd.cd_devs[unit];
d363 1
a363 1
		error = uiomove((caddr_t)sc->sc_vaddr + v, c, uio);
d376 1
a376 1
	struct flashsoftc *sc = (struct flashsoftc *) flashcd.cd_devs[unit];
d381 1
a381 1
	caddr_t cmpbuf;
d385 1
a385 1
	cmpbuf = (caddr_t)malloc(sc->sc_zonesize, M_TEMP, M_WAITOK);
d413 1
a413 1
		error = uiomove((caddr_t)cmpbuf, c, uio);
d449 1
a449 1
			caddr_t mem;
d476 1
a476 1
	struct flashsoftc *sc = (struct flashsoftc *) flashcd.cd_devs[unit];
@


1.3
log
@add a neat hack for write, but it still does not work
@
text
@d1 1
a1 1
/*	$Id: flash.c,v 1.2 1995/11/07 08:48:55 deraadt Exp $ */
d114 2
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d174 3
d183 42
a224 1
	printf("\n"); 
d227 56
d370 93
a462 1
	return (ENXIO);
a478 75
int
flasherasezone(sc, addr)
	struct flashsoftc *sc;
	int addr;
{
	u_char	sr;

	sc->sc_vaddr[addr] = FLCMD_ESETUP;
	sc->sc_vaddr[addr] = FLCMD_ECONFIRM;

	/* XXX should use sleep/wakeup/timeout combination */
	do {
		sc->sc_vaddr[0] = FLCMD_READSTAT;
		sr = sc->sc_vaddr[0];
	} while (sr & FLSR_WSMS == 0);
	if (sr & FLSR_ES)
		return (-1);
	return (0);
}

/*
 * Should add some light retry code. If a write fails see if an
 * erase helps the situation... eventually flash rams become
 * useless but perhaps we can get just one more cycle out of it.
 */
int
flashwritebyte(sc, addr, val)
	struct flashsoftc *sc;
	int addr;
	u_char val;
{
	u_char sr;

	/*
	 * If a zero'd bit in the flash memory needs to become set,
	 * then the zone must be erased and rebuilt.
	 */
	if (val & ~sc->sc_vaddr[addr]) {
		int faddr = addr & ~(sc->sc_zonesize - 1);
		u_char *zone;
		int i;

		zone = (u_char *)malloc(sc->sc_zonesize, M_TEMP, M_WAITOK);
		if (!zone)
			return (-1);
		bcopy((caddr_t)&sc->sc_vaddr[faddr], zone, sc->sc_zonesize);

		if (flasherasezone(sc, faddr) == -1)
			return (-1);

		zone[addr - faddr] = val;
		for (i = 0; i < sc->sc_zonesize; i++) {
			sc->sc_vaddr[faddr + i] = FLCMD_WSETUP;
			sc->sc_vaddr[faddr + i] = zone[i];
			do {
				sc->sc_vaddr[0] = FLCMD_READSTAT;
				sr = sc->sc_vaddr[0];
			} while (sr & FLSR_WSMS == 0);
			if (sr & FLSR_BWS)
				return (-1);	/* write failed! */
		}
		free(zone, M_TEMP);
		return (0);
	}

	sc->sc_vaddr[addr] = FLCMD_WSETUP;
	sc->sc_vaddr[addr] = val;
	do {
		sc->sc_vaddr[0] = FLCMD_READSTAT;
		sr = sc->sc_vaddr[0];
	} while (sr & FLSR_WSMS == 0);
	if (sr & FLSR_BWS)
		return (-1);	/* write failed! */
	return (0);
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
d17 2
a18 1
 *      This product includes software developed by Theo de Raadt
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
