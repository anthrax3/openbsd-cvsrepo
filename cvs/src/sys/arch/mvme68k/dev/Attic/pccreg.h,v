head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.34
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.32
	OPENBSD_5_0:1.7.0.30
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.28
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.26
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.22
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.24
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.20
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.26
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.24
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.22
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.20
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.8;

1.8
date	2012.11.04.13.33.32;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.30.22.29.45;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.11.03.27;	author deraadt;	state Exp;
branches
	1.3.16.1
	1.3.26.1;
next	1.2;

1.2
date	95.11.07.08.49.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.10;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.43.01;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	;

1.3.26.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: pccreg.h,v 1.8 2012/11/04 13:33:32 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * MVME147 PCC chip
 */
struct pccreg {
	volatile u_long		pcc_dmataddr;	/* dma table address */
	volatile u_long		pcc_dmadaddr;	/* dma data address */
	volatile u_long		pcc_dmabcnt;	/* dma byte count */
	volatile u_long		pcc_dmahold;	/* dma data hold register */
	volatile u_short	pcc_t1pload;	/* timer1 preload */
	volatile u_short	pcc_t1count;	/* timer1 count */
	volatile u_short	pcc_t2pload;	/* timer2 preload */
	volatile u_short	pcc_t2count;	/* timer2 count */
	volatile u_char		pcc_t1irq;	/* timer1 interrupt ctrl */
	volatile u_char		pcc_t1ctl;	/* timer1 ctrl reg */
	volatile u_char		pcc_t2irq;	/* timer2 interrupt ctrl */
	volatile u_char		pcc_t2ctl;	/* timer2 ctrl reg */
	volatile u_char		pcc_acfirq;	/* acfail intr reg */
	volatile u_char		pcc_dogirq;	/* watchdog intr reg */
	volatile u_char		pcc_lpirq;	/* printer intr reg */
	volatile u_char		pcc_lpctl;	/* printer ctrl */
	volatile u_char		pcc_dmairq;	/* dma interrupt control */
	volatile u_char		pcc_dmacsr;	/* dma csr */
	volatile u_char		pcc_busirq;	/* bus error interrupt */
	volatile u_char		pcc_dmasr;	/* dma status register */
	volatile u_char		pcc_abortirq;	/* abort interrupt control reg */
	volatile u_char		pcc_tafcr;	/* table address function code reg */
	volatile u_char		pcc_zsirq;	/* serial interrupt reg */
	volatile u_char		pcc_genctl;	/* general control register */
	volatile u_char		pcc_leirq;	/* ethernet interrupt */
	volatile u_char		pcc_gensr;	/* general status */
	volatile u_char		pcc_sbicirq;	/* sbic interrupt reg */
	volatile u_char		pcc_slavebase;	/* slave base addr reg */
	volatile u_char		pcc_sw1inq;	/* software interrupt #1 cr */
	volatile u_char		pcc_vecbase;	/* interrupt base vector register */
	volatile u_char		pcc_sw2irq;	/* software interrupt #2 cr */
	volatile u_char		pcc_chiprev;	/* revision level */
};
#define PCCSPACE_PCCCHIP_OFF	0x1000

/*
 * points to system's PCC. This is not active until the pcc0 device
 * has been attached.
 */
extern struct pccreg *sys_pcc;

/*
 * We lock off our interrupt vector at 0x40.
 */
#define PCC_VECBASE	0x40
#define PCC_NVEC	12

/*
 * Vectors we use
 */
#define PCCV_ACFAIL	0
#define PCCV_BERR	1
#define PCCV_ABORT	2
#define PCCV_ZS		3
#define PCCV_LE		4
#define PCCV_SBIC	5
#define PCCV_DMA	6
#define PCCV_PRINTER	7
#define PCCV_TIMER1	8
#define PCCV_TIMER2	9
#define PCCV_SOFT1	10
#define PCCV_SOFT2	11

#define PCC_DMABCNT_MAKEFC(fcn)	((fcn) << 24)
#define PCC_DMABCNT_FCMASK	0x07000000
#define PCC_DMABCNT_L		0x80000000
#define PCC_DMABCNT_CNTMASK	0x00ffffff

#define PCC_DMACSR_DONE		0x80
#define PCC_DMACSR_ERR8BIT	0x40
#define PCC_DMACSR_TNOT32	0x20
#define PCC_DMACSR_DMAERRDATA	0x10
#define PCC_DMACSR_DMAERRTABLE	0x08
#define PCC_DMACSR_TOSCSI	0x04
#define PCC_DMACSR_USETABLE	0x02
#define PCC_DMACSR_DEN		0x01

#define PCC_SBIC_RESETIRQ	0x40
#define PCC_SBIC_RESETABS	0x20

/*
 * Fairly standard irq register bits.
 */
#define PCC_IRQ_IPL	0x07
#define PCC_IRQ_IEN	0x08
#define PCC_IRQ_INT	0x80

#define PCC_LPIRQ_ACK	0x20

/*
 * clock/timer
 */
#define PCC_TIMERACK	0x80	/* ack intr */
#define PCC_TIMERCLEAR	0x00	/* reset and clear timer */
#define PCC_TIMERSTART	0x03	/* start timer */
#define PCC_TIMER_COVF	0x04	/* clear overflow */
#define PCC_TIMER_OVF_SHIFT	4

#define	PCC_TIMERFREQ	160000	/* 1000000 /6.25 */
#define	pcc_timer_hz2lim(hz)	(65536 - (PCC_TIMERFREQ/(hz)))
#define	pcc_timer_us2lim(us)	(65536 - (PCC_TIMERFREQ/(1000000/(us))))

/*
 * serial control
 */
#define PCC_ZS_PCCVEC	0x10	/* let PCC supply vector */

/*
 * abort switch
 */
#define PCC_ABORT_IEN	0x08	/* enable interrupt */
#define PCC_ABORT_ABS	0x40	/* current state of switch */
#define PCC_ABORT_ACK	0x80	/* intr active; or write to ack */

/*
 * for the console we need zs phys addr
 */
#define ZS0_PHYS_147	(INTIOBASE_147 + 0x3000)
#define ZS1_PHYS_147	(INTIOBASE_147 + 0x3800)

/* XXX */
int	pccintr_establish(int, struct intrhand *, const char *);
int	pccspeed(struct pccreg *);

#define PCC_GENCTL_IEN	0x10
@


1.8
log
@Switch mvme68k to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccreg.h,v 1.7 2004/07/30 22:29:45 miod Exp $ */
@


1.7
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccreg.h,v 1.6 2003/06/02 05:09:14 deraadt Exp $ */
d127 2
d130 3
a132 2
#define	pcc_timer_hz2lim(hz)	(65536 - (160000/(hz)))
#define	pcc_timer_us2lim(us)	(65536 - (160000/(1000000/(us))))
@


1.6
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: pccreg.h,v 1.5 2002/04/27 23:21:05 miod Exp $ */
d150 1
a150 1
int	pccintr_establish(int vec, struct intrhand *ih);
@


1.5
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: pccreg.h,v 1.4 2002/03/14 01:26:37 millert Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pccreg.h,v 1.3 1996/04/28 11:03:27 deraadt Exp $ */
d157 1
@


1.3
log
@add OpenBSD header
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d156 1
a156 1
int	pccintr_establish __P((int vec, struct intrhand *ih));
@


1.3.26.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pccreg.h,v 1.3 1996/04/28 11:03:27 deraadt Exp $ */
d156 1
a156 2
int	pccintr_establish(int vec, struct intrhand *ih);
int	pccspeed(struct pccreg *);
@


1.3.16.1
log
@Merge in -current from about a week ago
@
text
@d156 1
a156 1
int	pccintr_establish(int vec, struct intrhand *ih);
@


1.3.16.2
log
@Sync the SMP branch with 3.3
@
text
@a156 1
int	pccspeed(struct pccreg *);
@


1.3.16.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pccreg.h,v 1.3.16.2 2003/03/27 23:32:16 niklas Exp $ */
d15 6
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $Id: pccreg.h,v 1.1.1.1 1995/07/25 23:12:08 chuck Exp $ */
d4 1
a4 2
 *
 * Copyright (c) 1995 Charles D. Cranor
d17 2
a18 1
 *      This product includes software developed by Charles D. Cranor.
d35 1
a35 1
 * peripheral channel controller (at pa fffe1000)
d37 33
a69 34

struct pcc {
  volatile u_long dma_taddr;		/* dma table address */
  volatile u_long dma_daddr;		/* dma data address */
  volatile u_long dma_bcnt;		/* dma byte count */
  volatile u_long dma_hold;		/* dma data hold register */
  volatile u_short t1_pload;		/* timer1 preload */
  volatile u_short t1_count;		/* timer1 count */
  volatile u_short t2_pload;		/* timer2 preload */
  volatile u_short t2_count;		/* timer2 count */
  volatile u_char t1_int;		/* timer1 interrupt ctrl */
  volatile u_char t1_cr;		/* timer1 ctrl reg */
  volatile u_char t2_int;		/* timer2 interrupt ctrl */
  volatile u_char t2_cr;		/* timer2 ctrl reg */
  volatile u_char acf_int;		/* acfail intr reg */
  volatile u_char dog_int;		/* watchdog intr reg */
  volatile u_char pr_int;		/* printer intr reg */
  volatile u_char pr_cr;		/* printer ctrl */
  volatile u_char dma_int;		/* dma interrupt control */
  volatile u_char dma_csr;		/* dma csr */
  volatile u_char bus_int;		/* bus error interrupt */
  volatile u_char dma_sr;		/* dma status register */
  volatile u_char abrt_int;		/* abort interrupt control reg */
  volatile u_char ta_fcr;		/* table address function code reg */
  volatile u_char zs_int;		/* serial interrupt reg */
  volatile u_char gen_cr;		/* general control register */
  volatile u_char le_int;		/* ethernet interrupt */
  volatile u_char gen_sr;		/* general status */
  volatile u_char scsi_int;		/* scsi interrupt reg */
  volatile u_char slave_ba;		/* slave base addr reg */
  volatile u_char sw1_int;		/* software interrupt #1 cr */
  volatile u_char int_vectr;		/* interrupt base vector register */
  volatile u_char sw2_int;		/* software interrupt #2 cr */
  volatile u_char pcc_rev;		/* revision level */
d71 1
a71 1

d74 2
a75 1
 * points to system's PCC
d77 1
a77 2

extern struct pcc *sys_pcc;
d80 1
a80 2
 * we lock off our interrupt vector at 0x40.  if this is changed 
 * we'll need to change vector.s
d82 2
a83 3

#define PCC_VECBASE 0x40
#define PCC_NVEC 12
d86 1
a86 1
 * vectors we use
a87 1

d93 2
a94 2
#define PCCV_SCSIP	5
#define PCCV_SCSID	6
d101 26
d128 1
a128 1
 * enable interrupt
d130 3
d134 2
a135 1
#define PCC_IENABLE 0x08
d138 1
a138 1
 * interrupt mask
d140 1
a140 2

#define PCC_IMASK 0x7
d143 1
a143 1
 * clock/timer
d145 3
a147 5

#define PCC_TIMERACK 0x80	/* ack intr */
#define PCC_TIMER100HZ 63936	/* load value for 100Hz */
#define PCC_TIMERCLEAR 0x0	/* reset and clear timer */
#define PCC_TIMERSTART 0x3      /* start timer */
d150 1
a150 1
 * serial control
d152 5
d158 1
a158 1
#define PCC_ZSEXTERN 0x10	/* let PCC supply vector */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD$ */
d4 2
a5 1
 * Copyright (c) 1995 Theo de Raadt
d18 1
a18 1
 *      This product includes software developed by Theo de Raadt
d35 1
a35 1
 * MVME147 PCC chip
d37 34
a70 33
struct pccreg {
	volatile u_long		pcc_dmataddr;	/* dma table address */
	volatile u_long		pcc_dmadaddr;	/* dma data address */
	volatile u_long		pcc_dmabcnt;	/* dma byte count */
	volatile u_long		pcc_dmahold;	/* dma data hold register */
	volatile u_short	pcc_t1pload;	/* timer1 preload */
	volatile u_short	pcc_t1count;	/* timer1 count */
	volatile u_short	pcc_t2pload;	/* timer2 preload */
	volatile u_short	pcc_t2count;	/* timer2 count */
	volatile u_char		pcc_t1irq;	/* timer1 interrupt ctrl */
	volatile u_char		pcc_t1ctl;	/* timer1 ctrl reg */
	volatile u_char		pcc_t2irq;	/* timer2 interrupt ctrl */
	volatile u_char		pcc_t2ctl;	/* timer2 ctrl reg */
	volatile u_char		pcc_acfirq;	/* acfail intr reg */
	volatile u_char		pcc_dogirq;	/* watchdog intr reg */
	volatile u_char		pcc_lpirq;	/* printer intr reg */
	volatile u_char		pcc_lpctl;	/* printer ctrl */
	volatile u_char		pcc_dmairq;	/* dma interrupt control */
	volatile u_char		pcc_dmacsr;	/* dma csr */
	volatile u_char		pcc_busirq;	/* bus error interrupt */
	volatile u_char		pcc_dmasr;	/* dma status register */
	volatile u_char		pcc_abortirq;	/* abort interrupt control reg */
	volatile u_char		pcc_tafcr;	/* table address function code reg */
	volatile u_char		pcc_zsirq;	/* serial interrupt reg */
	volatile u_char		pcc_genctl;	/* general control register */
	volatile u_char		pcc_leirq;	/* ethernet interrupt */
	volatile u_char		pcc_gensr;	/* general status */
	volatile u_char		pcc_sbicirq;	/* sbic interrupt reg */
	volatile u_char		pcc_slavebase;	/* slave base addr reg */
	volatile u_char		pcc_sw1inq;	/* software interrupt #1 cr */
	volatile u_char		pcc_vecbase;	/* interrupt base vector register */
	volatile u_char		pcc_sw2irq;	/* software interrupt #2 cr */
	volatile u_char		pcc_chiprev;	/* revision level */
d72 1
a72 1
#define PCCSPACE_PCCCHIP_OFF	0x1000
d75 1
a75 2
 * points to system's PCC. This is not active until the pcc0 device
 * has been attached.
d77 2
a78 1
extern struct pccreg *sys_pcc;
d81 2
a82 1
 * We lock off our interrupt vector at 0x40.
d84 3
a86 2
#define PCC_VECBASE	0x40
#define PCC_NVEC	12
d89 1
a89 1
 * Vectors we use
d91 1
d97 2
a98 2
#define PCCV_SBIC	5
#define PCCV_DMA	6
d105 3
a107 23
#define PCC_DMABCNT_MAKEFC(fcn)	((fcn) << 24)
#define PCC_DMABCNT_FCMASK	0x07000000
#define PCC_DMABCNT_L		0x80000000
#define PCC_DMABCNT_CNTMASK	0x00ffffff

#define PCC_DMACSR_DONE		0x80
#define PCC_DMACSR_ERR8BIT	0x40
#define PCC_DMACSR_TNOT32	0x20
#define PCC_DMACSR_DMAERRDATA	0x10
#define PCC_DMACSR_DMAERRTABLE	0x08
#define PCC_DMACSR_TOSCSI	0x04
#define PCC_DMACSR_USETABLE	0x02
#define PCC_DMACSR_DEN		0x01

#define PCC_SBIC_RESETIRQ	0x40
#define PCC_SBIC_RESETABS	0x20

/*
 * Fairly standard irq register bits.
 */
#define PCC_IRQ_IPL	0x07
#define PCC_IRQ_IEN	0x08
#define PCC_IRQ_INT	0x80
d109 1
a109 1
#define PCC_LPIRQ_ACK	0x20
d112 1
a112 1
 * clock/timer
a113 3
#define PCC_TIMERACK	0x80	/* ack intr */
#define PCC_TIMERCLEAR	0x00	/* reset and clear timer */
#define PCC_TIMERSTART	0x03	/* start timer */
d115 1
a115 2
#define	pcc_timer_hz2lim(hz)	(65536 - (160000/(hz)))
#define	pcc_timer_us2lim(us)	(65536 - (160000/(1000000/(us))))
d118 1
a118 1
 * serial control
a119 1
#define PCC_ZS_PCCVEC	0x10	/* let PCC supply vector */
d121 4
a124 6
/*
 * abort switch
 */
#define PCC_ABORT_IEN	0x08	/* enable interrupt */
#define PCC_ABORT_ABS	0x40	/* current state of switch */
#define PCC_ABORT_ACK	0x80	/* intr active; or write to ack */
d127 1
a127 1
 * for the console we need zs phys addr
a128 5
#define ZS0_PHYS_147	(INTIOBASE_147 + 0x3000)
#define ZS1_PHYS_147	(INTIOBASE_147 + 0x3800)

/* XXX */
int	pccintr_establish __P((int vec, struct intrhand *ih));
d130 1
a130 1
#define PCC_GENCTL_IEN	0x10
@
