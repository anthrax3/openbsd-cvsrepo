head	1.24;
access;
symbols
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.6
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.6
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2013.07.02.04.39.04;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2012.11.04.13.33.32;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.01.22.08.13;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.01.21.40.49;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.20.05.19.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.21.14.49.33;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.24.22.43.16;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.27.16.04.08;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.02.18.00.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.02.17.37.16;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.01.12.13.46;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.01.04.04.00.51;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.11.02.44.29;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.01.11.05.11.38;	author millert;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	96.06.11.10.15.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.11.06.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.43.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.43.06;	author deraadt;	state Exp;
branches;
next	;

1.5.6.1
date	2001.04.18.16.10.25;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.5.6.5;

1.5.6.5
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.5.6.6;

1.5.6.6
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: nvram.c,v 1.23 2013/07/02 04:39:04 guenther Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* 
 * 8/22/2000 BH Cleaned up year 2000 problems with calendar hardware.
 * This code will break again in 2068 or so - come dance on my grave.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/timetc.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/mioctl.h>
#include <machine/psl.h>

#include <uvm/uvm_extern.h>

#include <mvme68k/dev/memdevs.h>
#include <mvme68k/dev/nvramreg.h>

struct nvramsoftc {
	struct device	sc_dev;
	paddr_t		sc_paddr;
	vaddr_t		sc_vaddr;
	int             sc_len;
	void		*sc_clockregs;
};

void    nvramattach(struct device *, struct device *, void *);
int     nvrammatch(struct device *, void *, void *);

struct cfattach nvram_ca = {
	sizeof(struct nvramsoftc), nvrammatch, nvramattach
};

struct cfdriver nvram_cd = {
	NULL, "nvram", DV_DULL
};

int
nvrammatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct confargs *ca = args;   

/*X*/	if (ca->ca_vaddr == (vaddr_t)-1)
/*X*/		return (1);
	return (!badvaddr(ca->ca_vaddr, 1));
}

void
nvramattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct confargs *ca = args;
	struct nvramsoftc *sc = (struct nvramsoftc *)self;
	vsize_t maplen;

	sc->sc_paddr = ca->ca_paddr;
	sc->sc_vaddr = (vaddr_t)ca->ca_vaddr;

	switch (cputyp) {
	default:
		sc->sc_len = MK48T08_SIZE;
		break;
#ifdef MVME141
	case CPU_141:
		sc->sc_len = MK48T02_SIZE;
		break;
#endif
#ifdef MVME147
	case CPU_147:
		sc->sc_len = MK48T02_SIZE;
		break;
#endif
	}

	/*
	 * On the MVME165, the MK48T08 is mapped as one byte per longword,
	 * thus spans four time as much address space.
	 */
#ifdef MVME165
	if (cputyp == CPU_165)
		maplen = 4 * sc->sc_len;
	else
#endif
		maplen = sc->sc_len;

/*X*/	if (sc->sc_vaddr == -1)
/*X*/		sc->sc_vaddr = mapiodev(sc->sc_paddr, maplen);
/*X*/	if (sc->sc_vaddr == 0)
/*X*/		panic("failed to map!");

#ifdef MVME165
	if (cputyp == CPU_165)
		sc->sc_clockregs = (void *)(sc->sc_vaddr + maplen -
		    sizeof(struct clockreg_165));
	else
#endif
		sc->sc_clockregs = (void *)(sc->sc_vaddr + sc->sc_len -
		    sizeof(struct clockreg));

	printf(": MK48T0%d len %d\n", sc->sc_len / 1024, sc->sc_len);
}

/*
 * BCD to decimal and decimal to BCD.
 */
#define	FROMBCD(x)	(((x) >> 4) * 10 + ((x) & 0xf))
#define	TOBCD(x)	(((x) / 10 * 16) + ((x) % 10))

#define	SECYR		(SECDAY * 365)
#define	LEAPYEAR(y)	(((y) & 3) == 0)

/*
 * This code is defunct after 2068.
 * Will Unix still be here then??
 */
const short dayyr[12] =
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};

struct chiptime {
	int     sec;
	int     min;
	int     hour;
	int     wday;
	int     day;
	int     mon;
	int     year;
};

time_t chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);

time_t
chiptotime(sec, min, hour, day, mon, year)
	register int sec, min, hour, day, mon, year;
{
	register int days, yr;

	sec = FROMBCD(sec);
	min = FROMBCD(min);
	hour = FROMBCD(hour);
	day = FROMBCD(day);
	mon = FROMBCD(mon);
	year = FROMBCD(year) + YEAR0;

	/* simple sanity checks */
	if (year>164 || mon<1 || mon>12 || day<1 || day>31)
		return (0);
	yr = 70;
	days = 0;

	if (year < 70) {		/* 2000 <= year */
		for (; yr < 100; yr++)	/* deal with first 30 years */
			days += LEAPYEAR(yr) ? 366 : 365;
		yr = 0;
	}

	for (; yr < year; yr++)		/* deal with years left */
		days += LEAPYEAR(yr) ? 366 : 365;

	days += dayyr[mon - 1] + day - 1;

	if (LEAPYEAR(yr) && mon > 2)
		days++;

	/* now have days since Jan 1, 1970; the rest is easy... */
	return ((time_t)days * SECDAY + hour * 3600 + min * 60 + sec);
}

void
timetochip(c)
	struct chiptime *c;
{
	time_t t2, now = time_second;
	int t, t3;

	/* January 1 1970 was a Thursday (4 in unix wdays) */
	/* compute the days since the epoch */
	t2 = now / SECDAY;

	t3 = (t2 + 4) % 7;	/* day of week */
	c->wday = TOBCD(t3 + 1);

	/* compute the year */
	t = 69;
	while (t2 >= 0) {	/* whittle off years */
		t3 = t2;
		t++;
		t2 -= LEAPYEAR(t) ? 366 : 365;
	}
	c->year = t;

	/* t3 = month + day; separate */
	t = LEAPYEAR(t);
	for (t2 = 1; t2 < 12; t2++)
		if (t3 < (dayyr[t2] + ((t && (t2 > 1)) ? 1:0)))
			break;

	/* t2 is month */
	c->mon = t2;
	c->day = t3 - dayyr[t2 - 1] + 1;
	if (t && t2 > 2)
		c->day--;

	/* the rest is easy */
	t = now % SECDAY;
	c->hour = t / 3600;
	t %= 3600;
	c->min = t / 60;
	c->sec = t % 60;

	c->sec = TOBCD(c->sec);
	c->min = TOBCD(c->min);
	c->hour = TOBCD(c->hour);
	c->day = TOBCD(c->day);
	c->mon = TOBCD(c->mon);
	c->year = TOBCD((c->year - YEAR0) % 100);
}

/*
 * Set up the system's time, given a `reasonable' time value.
 */
void
inittodr(base)
	time_t base;
{
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[0];
	int sec, min, hour, day, mon, year;
	int badbase = 0, waszero = base == 0;
	struct timespec ts;

	ts.tv_sec = ts.tv_nsec = 0;

	if (base < (2012 - 1970) * SECYR) {
		/*
		 * If base is 0, assume filesystem time is just unknown
		 * instead of preposterous. Don't bark.
		 */
		if (base != 0)
			printf("WARNING: preposterous time in file system\n");
		/* not going to use it anyway, if the chip is readable */
		base = (2012 - 1970) * SECYR;
		badbase = 1;
	}

#ifdef MVME165
	if (cputyp == CPU_165) {
		struct clockreg_165 *cl = sc->sc_clockregs;

		cl->cl_csr |= CLK_READ;	 /* enable read (stop time) */
		sec = cl->cl_sec;
		min = cl->cl_min;
		hour = cl->cl_hour;
		day = cl->cl_mday;
		mon = cl->cl_month;
		year = cl->cl_year;
		cl->cl_csr &= ~CLK_READ;	/* time wears on */
	} else
#endif
	{
		struct clockreg *cl = sc->sc_clockregs;

		cl->cl_csr |= CLK_READ;	 /* enable read (stop time) */
		sec = cl->cl_sec;
		min = cl->cl_min;
		hour = cl->cl_hour;
		day = cl->cl_mday;
		mon = cl->cl_month;
		year = cl->cl_year;
		cl->cl_csr &= ~CLK_READ;	/* time wears on */
	}

	if ((ts.tv_sec = chiptotime(sec, min, hour, day, mon, year)) == 0) {
		printf("WARNING: bad date in nvram");
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the clock.
		 */
		ts.tv_sec = base;
		tc_setclock(&ts);

		if (!badbase)
			resettodr();
	} else {
		int deltat = ts.tv_sec - base;

		tc_setclock(&ts);
		if (deltat < 0)
			deltat = -deltat;
		if (waszero || deltat < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %d days",
		       ts.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
	}
	printf(" -- CHECK AND RESET THE DATE!\n");
}

/*
 * Reset the clock based on the current time.
 * Used when the current clock is preposterous, when the time is changed,
 * and when rebooting.  Do nothing if the time is not yet known, e.g.,
 * when crashing during autoconfig.
 */
void
resettodr()
{
	struct nvramsoftc *sc = (struct nvramsoftc *)nvram_cd.cd_devs[0];
	struct chiptime c;

	if (!time_second || sc == NULL || sc->sc_clockregs == NULL)
		return;
	timetochip(&c);

#ifdef MVME165
	if (cputyp == CPU_165) {
		struct clockreg_165 *cl = sc->sc_clockregs;

		cl->cl_csr |= CLK_WRITE;	/* enable write */
		cl->cl_sec = c.sec;
		cl->cl_min = c.min;
		cl->cl_hour = c.hour;
		cl->cl_wday = c.wday;
		cl->cl_mday = c.day;
		cl->cl_month = c.mon;
		cl->cl_year = c.year;
		cl->cl_csr &= ~CLK_WRITE;	/* load them up */
	} else
#endif
	{
		struct clockreg *cl = sc->sc_clockregs;

		cl->cl_csr |= CLK_WRITE;	/* enable write */
		cl->cl_sec = c.sec;
		cl->cl_min = c.min;
		cl->cl_hour = c.hour;
		cl->cl_wday = c.wday;
		cl->cl_mday = c.day;
		cl->cl_month = c.mon;
		cl->cl_year = c.year;
		cl->cl_csr &= ~CLK_WRITE;	/* load them up */
	}
}

/*ARGSUSED*/
int
nvramopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	if (minor(dev) >= nvram_cd.cd_ndevs ||
	    nvram_cd.cd_devs[minor(dev)] == NULL)
		return (ENODEV);
#ifdef MVME165
	/* for now, do not allow userland to access the nvram on 165. */
	if (cputyp == CPU_165)
		return (ENXIO);
#endif
	return (0);
}

/*ARGSUSED*/
int
nvramclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	return (0);
}

/*ARGSUSED*/
int
nvramioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[unit];
	int error = 0;

	switch (cmd) {
	case MIOCGSIZ:
		*(int *)data = sc->sc_len;
		break;
	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

/*ARGSUSED*/
int
nvramrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[unit];

	return (memdevrw(sc->sc_vaddr, sc->sc_len, uio, flags));
}

/*
 * If the NVRAM is of the 2K variety, an extra 2K of who-knows-what
 * will also be mmap'd, due to NBPG being 4K. On the MVME147 the NVRAM
 * repeats, so userland gets two copies back-to-back.
 */
paddr_t
nvrammmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[unit];

	if (minor(dev) != 0)
		return (-1);

	/* allow access only in RAM */
	if (off < 0 || off >= round_page(sc->sc_len))
		return (-1);
	return (sc->sc_paddr + off);
}
@


1.23
log
@Use time_t for storing and returning time_t values, and cast to time_t
before the last multiplication that might take it past 2^31 secounds.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.22 2012/11/04 13:33:32 miod Exp $ */
@


1.22
log
@Switch mvme68k to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.21 2010/12/26 15:40:59 miod Exp $ */
d164 1
a164 1
u_long chiptotime(int, int, int, int, int, int);
d167 1
a167 1
u_long
d201 1
a201 1
	return (days * SECDAY + hour * 3600 + min * 60 + sec);
d208 2
a209 1
	int t, t2, t3, now = time_second;
@


1.21
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.20 2009/03/01 22:08:13 miod Exp $ */
d38 1
a50 4
#if defined(GPROF)
#include <sys/gmon.h>
#endif

a138 32
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt (clock.c:clkread).
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for fun,
 * we guarantee that the time will be greater than the value obtained by a
 * previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
{
	int s = splhigh();
	static struct timeval lasttime;

	*tvp = time;
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
}

/*
d208 1
a208 1
	int t, t2, t3, now = time.tv_sec;
d263 1
d265 3
a267 1
	if (base < 5 * SECYR) {
d275 1
a275 1
		base = 21*SECYR + 186*SECDAY + SECDAY/2;
d306 1
a306 1
	if ((time.tv_sec = chiptotime(sec, min, hour, day, mon, year)) == 0) {
d312 3
a314 1
		time.tv_sec = base;
d318 1
a318 1
		int deltat = time.tv_sec - base;
d320 1
d326 1
a326 1
		       time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d340 1
a340 1
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[0];
d343 1
a343 1
	if (!time.tv_sec || sc->sc_clockregs == NULL)
@


1.20
log
@Support for MVME141 boards. Tested with both VME and VSB memory boards
(and MVME327 SCSI and MVME376 Ethernet, to provide a complete system).
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.19 2009/03/01 21:40:49 miod Exp $ */
d492 1
a492 1
	return (atop(sc->sc_paddr + off));
@


1.19
log
@Support for MVME165 board - code written in april 2006, eventually debugged
last month.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.18 2007/12/20 05:19:38 miod Exp $ */
d97 9
a105 1
	sc->sc_len = MK48T08_SIZE;
d107 1
a107 1
	if (cputyp == CPU_147)
d109 1
d111 1
@


1.18
log
@Stricter range checks in mmap function.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.17 2006/06/21 14:49:33 deraadt Exp $ */
d59 1
a59 1
	struct clockreg *sc_regs;
d92 1
d98 1
d101 1
d103 10
d115 1
a115 1
/*X*/		sc->sc_vaddr = mapiodev(sc->sc_paddr, MAX(sc->sc_len, NBPG));
d119 8
a126 2
	sc->sc_regs = (struct clockreg *)(sc->sc_vaddr + sc->sc_len -
					  sizeof(struct clockreg));
a285 1
	register struct clockreg *cl = sc->sc_regs;
d300 28
a327 8
	cl->cl_csr |= CLK_READ;	 /* enable read (stop time) */
	sec = cl->cl_sec;
	min = cl->cl_min;
	hour = cl->cl_hour;
	day = cl->cl_mday;
	mon = cl->cl_month;
	year = cl->cl_year;
	cl->cl_csr &= ~CLK_READ;	/* time wears on */
a359 1
	register struct clockreg *cl = sc->sc_regs;
d362 1
a362 1
	if (!time.tv_sec || cl == NULL)
d365 29
a393 9
	cl->cl_csr |= CLK_WRITE;	/* enable write */
	cl->cl_sec = c.sec;
	cl->cl_min = c.min;
	cl->cl_hour = c.hour;
	cl->cl_wday = c.wday;
	cl->cl_mday = c.day;
	cl->cl_month = c.mon;
	cl->cl_year = c.year;
	cl->cl_csr &= ~CLK_WRITE;	/* load them up */
d406 5
@


1.17
log
@let this compile after time.h changes
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.16 2005/11/24 22:43:16 miod Exp $ */
d418 1
a418 1
	if (off < 0 || off > sc->sc_len)
@


1.16
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.15 2005/10/27 16:04:08 martin Exp $ */
a149 1
#define	SECDAY		(24 * 60 * 60)
@


1.15
log
@stupid me, of course these MD macros need to be converted to MI macros
as well
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.14 2004/07/02 18:00:50 miod Exp $ */
d55 3
a57 3
	struct device   sc_dev;
	void *          sc_paddr;
	void *          sc_vaddr;
d80 1
a80 1
/*X*/	if (ca->ca_vaddr == (void *)-1)
d82 1
a82 1
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 1));
d94 1
a94 1
	sc->sc_vaddr = ca->ca_vaddr;
d101 3
a103 4
/*X*/	if (sc->sc_vaddr == (void *)-1)
/*X*/		sc->sc_vaddr = mapiodev((void *)sc->sc_paddr,
/*X*/		    MAX(sc->sc_len, NBPG));
/*X*/	if (sc->sc_vaddr == NULL)
@


1.14
log
@Stricter bounds checking for mmap() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.13 2004/07/02 17:37:16 miod Exp $ */
d45 2
d422 1
a422 1
	return (m68k_btop(sc->sc_paddr + off));
@


1.13
log
@Merge *ramread() and *ramwrite(), as done on mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.12 2004/01/14 20:50:48 miod Exp $ */
d418 1
a418 1
	if (off > sc->sc_len)
@


1.12
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.11 2003/06/02 05:09:14 deraadt Exp $ */
d389 1
a389 14
nvramread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[unit];

	return (memdevrw(sc->sc_vaddr, sc->sc_len, uio, flags));
}

/*ARGSUSED*/
int
nvramwrite(dev, uio, flags)
@


1.11
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.10 2002/04/27 23:21:05 miod Exp $ */
d68 1
a68 1
	NULL, "nvram", DV_DULL, 0
@


1.10
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.9 2002/03/14 01:26:37 millert Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.8 2001/11/01 12:13:46 art Exp $ */
d40 1
d44 1
a44 1
#include <machine/psl.h>
d46 1
d49 3
d79 2
a80 2
struct device *parent;
void *vcf, *args;
a81 1
	struct cfdata *cf = vcf;
d86 1
a86 1
	return (!badvaddr(ca->ca_vaddr, 1));
d91 2
a92 2
struct device *parent, *self;
void *args;
d107 1
a107 1
/*X*/		max(sc->sc_len, NBPG));
d129 1
a129 1
register struct timeval *tvp;
a134 1
	tvp->tv_usec;
d166 14
a179 1
static u_long
d181 1
a181 1
register int sec, min, hour, day, mon, year;
d216 1
a216 10
struct chiptime {
	int     sec;
	int     min;
	int     hour;
	int     wday;
	int     day;
	int     mon;
	int     year;
};

d218 1
a218 1
register struct chiptime *c;
d220 1
a220 1
	register int t, t2, t3, now = time.tv_sec;
d268 1
d270 1
a270 1
time_t base;
d324 1
d347 4
a350 3
nvramopen(dev, flag, mode)
dev_t dev;
int flag, mode;
d360 4
a363 3
nvramclose(dev, flag, mode)
dev_t dev;
int flag, mode;
d372 5
a376 4
dev_t   dev;
caddr_t data;
int     cmd, flag;
struct proc *p;
d396 3
a398 3
dev_t dev;
struct uio *uio;
int flags;
d409 3
a411 3
dev_t dev;
struct uio *uio;
int flags;
@


1.8
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.7 2001/01/04 04:00:51 smurph Exp $ */
d61 2
a62 2
void    nvramattach __P((struct device *, struct device *, void *));
int     nvrammatch __P((struct device *, void *, void *));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.8 2001/11/01 12:13:46 art Exp $ */
a39 1
#include <sys/systm.h>
d43 1
a43 1

a44 1
#include <machine/conf.h>
a46 3
#include <machine/psl.h>

#include <mvme68k/dev/memdevs.h>
d61 2
a62 2
void    nvramattach(struct device *, struct device *, void *);
int     nvrammatch(struct device *, void *, void *);
d74 2
a75 2
	struct device *parent;
	void *vcf, *args;
d77 1
d82 1
a82 1
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 1));
d87 2
a88 2
	struct device *parent, *self;
	void *args;
d103 1
a103 1
/*X*/		    MAX(sc->sc_len, NBPG));
d125 1
a125 1
	register struct timeval *tvp;
d131 1
d163 1
a163 14
struct chiptime {
	int     sec;
	int     min;
	int     hour;
	int     wday;
	int     day;
	int     mon;
	int     year;
};

u_long chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);

u_long
d165 1
a165 1
	register int sec, min, hour, day, mon, year;
d200 10
a209 1
void
d211 1
a211 1
	struct chiptime *c;
d213 1
a213 1
	int t, t2, t3, now = time.tv_sec;
a260 1
void
d262 1
a262 1
	time_t base;
a315 1
void
d338 3
a340 4
nvramopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d350 3
a352 4
nvramclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d361 4
a364 5
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d384 3
a386 3
	dev_t dev;
	struct uio *uio;
	int flags;
d397 3
a399 3
	dev_t dev;
	struct uio *uio;
	int flags;
@


1.7
log
@Y2K fix for TODC - Submitted by Bob Harbour.  Thanks Bob!
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.6 2000/04/11 02:44:29 pjanzen Exp $ */
d412 1
a412 1
int
d414 3
a416 2
dev_t dev;
int off, prot;
@


1.6
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.5 1999/01/11 05:11:38 millert Exp $ */
d34 5
d54 4
a57 4
	struct device	sc_dev;
	void *		sc_paddr;
	void *		sc_vaddr;
	int		sc_len;
d61 2
a62 2
void	nvramattach __P((struct device *, struct device *, void *));
int	nvrammatch __P((struct device *, void *, void *));
d74 2
a75 2
	struct device *parent;
	void *vcf, *args;
d78 1
a78 1
	struct confargs *ca = args;
d87 2
a88 2
	struct device *parent, *self;
	void *args;
d100 1
d103 1
a103 1
/*X*/		    max(sc->sc_len, NBPG));
d108 1
a108 1
	    sizeof(struct clockreg));
d125 1
a125 1
	register struct timeval *tvp;
d161 1
a161 1
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
d165 1
a165 1
	register int sec, min, hour, day, mon, year;
d177 1
a177 1
	if (year < 70 || year > 164 || mon < 1 || mon > 12 || day < 1 || day > 31)
d179 1
d181 8
a188 1
	for (yr = 70; yr < year; yr++)
d190 1
d192 1
d195 1
d201 7
a207 7
	int	sec;
	int	min;
	int	hour;
	int	wday;
	int	day;
	int	mon;
	int	year;
d211 1
a211 1
	register struct chiptime *c;
d215 2
a216 1
	/* compute the year */
d218 2
a219 1
	t3 = (t2 + 2) % 7;	/* day of week */
d222 1
d234 1
a234 1
		if (t3 < dayyr[t2] + (t && t2 > 1))
d255 1
a255 1
	c->year = TOBCD(c->year - YEAR0);
d262 1
a262 1
	time_t base;
d305 1
a305 1
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d339 2
a340 2
	dev_t dev;
	int flag, mode;
d351 2
a352 2
	dev_t dev;
	int flag, mode;
d361 4
a364 4
	dev_t   dev;
	caddr_t data;
	int     cmd, flag;
	struct proc *p;
d369 1
a369 1
	
d384 3
a386 3
	dev_t dev;
	struct uio *uio;
	int flags;
d397 3
a399 3
	dev_t dev;
	struct uio *uio;
	int flags;
d414 2
a415 2
	dev_t dev;
	int off, prot;
@


1.5
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.4 1996/06/11 10:15:16 deraadt Exp $ */
d126 1
a126 1
	while (tvp->tv_usec > 1000000) {
d132 1
a132 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
@


1.5.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.7 2001/01/04 04:00:51 smurph Exp $ */
a33 5
/* 
 * 8/22/2000 BH Cleaned up year 2000 problems with calendar hardware.
 * This code will break again in 2068 or so - come dance on my grave.
 */

d49 4
a52 4
	struct device   sc_dev;
	void *          sc_paddr;
	void *          sc_vaddr;
	int             sc_len;
d56 2
a57 2
void    nvramattach __P((struct device *, struct device *, void *));
int     nvrammatch __P((struct device *, void *, void *));
d69 2
a70 2
struct device *parent;
void *vcf, *args;
d73 1
a73 1
	struct confargs *ca = args;   
d82 2
a83 2
struct device *parent, *self;
void *args;
a94 1

d97 1
a97 1
/*X*/		max(sc->sc_len, NBPG));
d102 1
a102 1
					  sizeof(struct clockreg));
d119 1
a119 1
register struct timeval *tvp;
d126 1
a126 1
	while (tvp->tv_usec >= 1000000) {
d132 1
a132 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
d155 1
a155 1
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
d159 1
a159 1
register int sec, min, hour, day, mon, year;
d171 1
a171 1
	if (year>164 || mon<1 || mon>12 || day<1 || day>31)
a172 1
	yr = 70;
d174 1
a174 8

	if (year < 70) {		/* 2000 <= year */
		for (; yr < 100; yr++)	/* deal with first 30 years */
			days += LEAPYEAR(yr) ? 366 : 365;
		yr = 0;
	}

	for (; yr < year; yr++)		/* deal with years left */
a175 1

a176 1

a178 1

d184 7
a190 7
	int     sec;
	int     min;
	int     hour;
	int     wday;
	int     day;
	int     mon;
	int     year;
d194 1
a194 1
register struct chiptime *c;
d198 1
a198 2
	/* January 1 1970 was a Thursday (4 in unix wdays) */
	/* compute the days since the epoch */
d200 1
a200 2

	t3 = (t2 + 4) % 7;	/* day of week */
a202 1
	/* compute the year */
d214 1
a214 1
		if (t3 < (dayyr[t2] + ((t && (t2 > 1)) ? 1:0)))
d235 1
a235 1
	c->year = TOBCD((c->year - YEAR0) % 100);
d242 1
a242 1
time_t base;
d285 1
a285 1
		       time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d319 2
a320 2
dev_t dev;
int flag, mode;
d331 2
a332 2
dev_t dev;
int flag, mode;
d341 4
a344 4
dev_t   dev;
caddr_t data;
int     cmd, flag;
struct proc *p;
d349 1
a349 1

d364 3
a366 3
dev_t dev;
struct uio *uio;
int flags;
d377 3
a379 3
dev_t dev;
struct uio *uio;
int flags;
d394 2
a395 2
dev_t dev;
int off, prot;
@


1.5.6.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d412 1
a412 1
paddr_t
d414 2
a415 3
	dev_t dev;
	off_t off;
	int prot;
@


1.5.6.3
log
@Merge in -current from about a week ago
@
text
@d61 2
a62 2
void    nvramattach(struct device *, struct device *, void *);
int     nvrammatch(struct device *, void *, void *);
@


1.5.6.4
log
@Sync the SMP branch with 3.3
@
text
@a39 1
#include <sys/systm.h>
d43 1
a43 1

a44 1
#include <machine/conf.h>
a46 3
#include <machine/psl.h>

#include <mvme68k/dev/memdevs.h>
d74 2
a75 2
	struct device *parent;
	void *vcf, *args;
d77 1
d82 1
a82 1
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 1));
d87 2
a88 2
	struct device *parent, *self;
	void *args;
d103 1
a103 1
/*X*/		    MAX(sc->sc_len, NBPG));
d125 1
a125 1
	register struct timeval *tvp;
d131 1
d163 1
a163 14
struct chiptime {
	int     sec;
	int     min;
	int     hour;
	int     wday;
	int     day;
	int     mon;
	int     year;
};

u_long chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);

u_long
d165 1
a165 1
	register int sec, min, hour, day, mon, year;
d200 10
a209 1
void
d211 1
a211 1
	struct chiptime *c;
d213 1
a213 1
	int t, t2, t3, now = time.tv_sec;
a260 1
void
d262 1
a262 1
	time_t base;
a315 1
void
d338 3
a340 4
nvramopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d350 3
a352 4
nvramclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d361 4
a364 5
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d384 3
a386 3
	dev_t dev;
	struct uio *uio;
	int flags;
d397 3
a399 3
	dev_t dev;
	struct uio *uio;
	int flags;
@


1.5.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.5.6.4 2003/03/27 23:32:16 niklas Exp $ */
d14 6
@


1.5.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d68 1
a68 1
	NULL, "nvram", DV_DULL
@


1.4
log
@use void * for pa/va instead of caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d99 1
a99 1
/*X*/		panic("failed to map!\n");
@


1.3
log
@cfattach/cfdriver split
@
text
@d50 2
a51 2
	caddr_t		sc_paddr;
	caddr_t		sc_vaddr;
d75 1
a75 1
/*X*/	if (ca->ca_vaddr == (caddr_t)-1)
d95 2
a96 2
/*X*/	if (sc->sc_vaddr == (caddr_t)-1)
/*X*/		sc->sc_vaddr = mapiodev((caddr_t)sc->sc_paddr,
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d59 6
a64 3
struct cfdriver nvramcd = {
	NULL, "nvram", nvrammatch, nvramattach,
	DV_DULL, sizeof(struct nvramsoftc), 0
d244 1
a244 1
	struct nvramsoftc *sc = (struct nvramsoftc *) nvramcd.cd_devs[0];
d298 1
a298 1
	struct nvramsoftc *sc = (struct nvramsoftc *) nvramcd.cd_devs[0];
d322 2
a323 2
	if (minor(dev) >= nvramcd.cd_ndevs ||
	    nvramcd.cd_devs[minor(dev)] == NULL)
d347 1
a347 1
	struct nvramsoftc *sc = (struct nvramsoftc *) nvramcd.cd_devs[unit];
d369 1
a369 1
	struct nvramsoftc *sc = (struct nvramsoftc *) nvramcd.cd_devs[unit];
d382 1
a382 1
	struct nvramsoftc *sc = (struct nvramsoftc *) nvramcd.cd_devs[unit];
d398 1
a398 1
	struct nvramsoftc *sc = (struct nvramsoftc *) nvramcd.cd_devs[unit];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
d5 1
a5 12
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Lawrence Berkeley Laboratory.
 *
d16 4
a19 5
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d21 5
a25 5
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
