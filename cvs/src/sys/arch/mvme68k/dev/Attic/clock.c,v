head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.14
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.12
	OPENBSD_5_0:1.16.0.10
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.8
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.6
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.18
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.16
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.3.0.26
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.24
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.22
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.20
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.17;

1.17
date	2012.11.04.13.33.32;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.01.22.08.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.01.21.40.49;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.21.20.32.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.30.22.29.44;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.30.10.02.42;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.03.14.36.19;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.08.20.18.34;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.28.14.47.50;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.11.06.02;	author deraadt;	state Exp;
branches
	1.3.16.1
	1.3.26.1;
next	1.2;

1.2
date	95.11.07.08.48.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.43.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.43.05;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.3.16.4;

1.3.16.4
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.3.26.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: clock.c,v 1.17 2012/11/04 13:33:32 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)clock.c     8.1 (Berkeley) 6/11/93
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/timetc.h>

#include <machine/psl.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>

#include "lrc.h"
#include "mc.h"
#include "ofobio.h"
#include "pcc.h"
#include "pcctwo.h"

#if NLRC > 0
#include <mvme68k/dev/lrcreg.h>
#endif
#if NMC > 0
#include <mvme68k/dev/mcreg.h>
#endif
#if NOFOBIO > 0
#include <mvme68k/dev/ofobioreg.h>
#endif
#if NPCC > 0
#include <mvme68k/dev/pccreg.h>
#endif
#if NPCCTWO > 0
#include <mvme68k/dev/pcctworeg.h>
#include <mvme68k/dev/vme.h>
extern struct vme2reg *sys_vme2;
#endif

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 8192 would
 * give us offsets in [0..8191].  Instead, we take offsets in [1..8191].
 * This is symmetric about the point 2048, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
int statvar = 8192;
int statmin;		/* statclock interval - 1/2*variance */

struct clocksoftc {
	struct device	sc_dev;
	struct intrhand sc_profih;
	struct intrhand sc_statih;
};

void	clockattach(struct device *, struct device *, void *);
int	clockmatch(struct device *, void *, void *);

struct cfattach clock_ca = {
	sizeof(struct clocksoftc), clockmatch, clockattach
};

struct cfdriver clock_cd = {
	NULL, "clock", DV_DULL
};

int	clockintr(void *);
int	statintr(void *);

int	clockbus;
u_char	stat_reset, prof_reset;

/*
 * Every machine must have a clock tick device of some sort; for this
 * platform this file manages it, no matter what form it takes.
 */
int
clockmatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	return (1);
}

void
clockattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct confargs *ca = args;
	struct clocksoftc *sc = (struct clocksoftc *)self;

	sc->sc_profih.ih_fn = clockintr;
	sc->sc_profih.ih_arg = 0;
	sc->sc_profih.ih_wantframe = 1;
	sc->sc_profih.ih_ipl = ca->ca_ipl;

	sc->sc_statih.ih_fn = statintr;
	sc->sc_statih.ih_arg = 0;
	sc->sc_statih.ih_wantframe = 1;
	sc->sc_statih.ih_ipl = ca->ca_ipl;

	clockbus = ca->ca_bustype;
	switch (ca->ca_bustype) {
#if NLRC > 0
	case BUS_LRC:
		/*
		 * XXX once we have dynamic ipl levels, put clock at ipl 6,
		 * move it to timer1, then use timer2/ipl5 for statclock.
		 * But then time counters will need to be implemented
		 * differently.
		 */
		lrcintr_establish(LRCVEC_TIMER2, &sc->sc_profih, "clock");
		break;
#endif
#if NMC > 0
	case BUS_MC:
		prof_reset = ca->ca_ipl | MC_IRQ_IEN | MC_IRQ_ICLR;
		stat_reset = ca->ca_ipl | MC_IRQ_IEN | MC_IRQ_ICLR;
		mcintr_establish(MCV_TIMER1, &sc->sc_profih, "clock");
		mcintr_establish(MCV_TIMER2, &sc->sc_statih, "stat");
		break;
#endif
#if NOFOBIO > 0
	case BUS_OFOBIO:
	    {
		extern struct timecounter ofobio_timecounter; /* below */

		ofobio_timecounter.tc_priv = sc;
		intr_establish(OFOBIOVEC_CLOCK, &sc->sc_profih, "clock");
	    }
		break;
#endif
#if NPCC > 0
	case BUS_PCC:
		prof_reset = ca->ca_ipl | PCC_IRQ_IEN | PCC_TIMERACK;
		stat_reset = ca->ca_ipl | PCC_IRQ_IEN | PCC_TIMERACK;
		pccintr_establish(PCCV_TIMER1, &sc->sc_profih, "clock");
		pccintr_establish(PCCV_TIMER2, &sc->sc_statih, "stat");
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		prof_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		stat_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		pcctwointr_establish(PCC2V_TIMER1, &sc->sc_profih, "clock");
		pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih, "stat");
		break;
#endif
	}

	printf("\n");
}

#if NLRC > 0
u_int	lrc_get_timecount(struct timecounter *);
struct timecounter lrc_timecounter = {
	.tc_get_timecount = lrc_get_timecount,
	.tc_counter_mask = 0x00ffffff,	/* 24-bit timer */
	.tc_frequency = 1000000,	/* 1MHz */
	.tc_name = "lrc",
	.tc_quality = 100
};

u_int
lrc_get_timecount(struct timecounter *tc)
{
	/*
	 * Because LRC timers start counting at one, we need to count
	 * wraparounds, and subtract the number of wraparounds, since
	 * we go from FFFFFF to 000001.
	 */
	static u_int lrc_wraparounds = 0;
	static uint32_t lrc_last = 0;
	uint32_t lrc_cur;

	lrc_cur = sys_lrc->lrc_t1cnt & 0x00ffffff;
	if (lrc_cur < lrc_last)
		lrc_wraparounds++;
	lrc_last = lrc_cur;

	return lrc_cur - lrc_wraparounds;
}
#endif

#if NMC > 0
u_int	mc_get_timecount(struct timecounter *);
struct timecounter mc_timecounter = {
	.tc_get_timecount = mc_get_timecount,
	.tc_counter_mask = 0xffffffff,	/* 32-bit timer */
	.tc_frequency = 1000000,	/* 1MHz */
	.tc_name = "mc",
	.tc_quality = 100
};

u_int
mc_get_timecount(struct timecounter *tc)
{
	/*
	 * Note that, theoretically, we ought to check for counter overflows.
	 * However, this timer is free-running with a rollover period of 71.6
	 * minutes - if two time counter readings are separated by more than
	 * this amount, there are more important issues to take care of first.
	 */
	return sys_mc->mc_t3count;
}
#endif

#if NOFOBIO > 0
u_int	ofobio_get_timecount(struct timecounter *);
struct timecounter ofobio_timecounter = {
	.tc_get_timecount = ofobio_get_timecount,
	.tc_counter_mask = 0xffffffff,
	/* .tc_frequency will be filled in */
	.tc_name = "ofobio",
	.tc_quality = 0
};

u_int
ofobio_get_timecount(struct timecounter *tc)
{
	struct clocksoftc *sc = tc->tc_priv;

	/*
	 * XXX It should be possible to get a better resolution by
	 * XXX peeking at the DART internal state, but the way this
	 * XXX clock is wired is horrible enough as is.
	 */
	return sc->sc_profih.ih_count.ec_count;
}
#endif

#if NPCC > 0
u_int	pcc_get_timecount(struct timecounter *);
uint32_t pcc_curcnt;
struct timecounter pcc_timecounter = {
	.tc_get_timecount = pcc_get_timecount,
	.tc_counter_mask = 0xffffffff,	/* 32-bit timer */
	.tc_frequency = PCC_TIMERFREQ,
	.tc_name = "pcc",
	.tc_quality = 100
};

u_int
pcc_get_timecount(struct timecounter *tc)
{
	uint16_t tcr1, tcr2, pload;
	uint8_t tctl;
	u_int cnt;
	int s;

	pload = sys_pcc->pcc_t1pload;
	s = splclock();
	tcr1 = sys_pcc->pcc_t1count;
	tctl = sys_pcc->pcc_t1ctl;
	/*
	 * Since we can not freeze the counter while reading the count
	 * and overflow registers, read them a second time; if the counter
	 * has wrapped, pick the second reading.
	 */
	tcr2 = sys_pcc->pcc_t1count;
	if (tcr2 < tcr1) {
		tcr1 = tcr2;
		tctl = sys_pcc->pcc_t1ctl;
	}
	cnt = pcc_curcnt;
	splx(s);
	tctl >>= PCC_TIMER_OVF_SHIFT;
	while (tctl-- != 0)
		cnt += 0x10000U - pload;
	cnt += tcr1 - pload;

	return cnt;
}
#endif

#if NPCCTWO > 0
u_int	pcctwo_get_timecount(struct timecounter *);
uint32_t pcctwo_curcnt;
struct timecounter pcctwo_timecounter = {
	.tc_get_timecount = pcctwo_get_timecount,
	.tc_counter_mask = 0xffffffff,	/* 32-bit timer */
	.tc_frequency = 1000000,	/* 1MHz */
	.tc_name = "pcctwo",
	.tc_quality = 100
};

u_int
pcctwo_get_timecount(struct timecounter *tc)
{
	uint32_t tcr1, tcr2;
	uint8_t tctl;
	u_int cnt, cmp;
	int s;

	cmp = sys_pcc2->pcc2_t1cmp;
	s = splclock();
	tcr1 = sys_pcc2->pcc2_t1count;
	tctl = sys_pcc2->pcc2_t1ctl;
	/*
	 * Since we can not freeze the counter while reading the count
	 * and overflow registers, read them a second time; if the counter
	 * has wrapped, pick the second reading.
	 */
	tcr2 = sys_pcc2->pcc2_t1count;
	if (tcr2 < tcr1) {
		tcr1 = tcr2;
		tctl = sys_pcc2->pcc2_t1ctl;
	}
	cnt = pcctwo_curcnt;
	splx(s);
	tctl >>= PCC2_TCTL_OVF_SHIFT;
	while (tctl-- != 0)
		cnt += cmp;
	cnt += tcr1;

	return cnt;
}
#endif

/*
 * clockintr: ack intr and call hardclock
 */
int
clockintr(arg)
	void *arg;
{
	u_int oflow = 1;
#if NMC > 0 || NPCC > 0 || NPCCTWO > 0
	uint32_t t1, t2;
	uint8_t c;
#endif

	switch (clockbus) {
#if NLRC > 0
	case BUS_LRC:
		/* nothing to do */
		break;
#endif
#if NOFOBIO > 0
	case BUS_OFOBIO:
		sys_ofobio->csr_c &= ~OFO_CSRC_TIMER_ACK;
		break;
#endif
#if NMC > 0
	case BUS_MC:
		/*
		 * Since we can not freeze the counter while reading the count
		 * and overflow registers, read them a second time; if the
		 * counter has wrapped, pick the second reading.
		 */
		t1 = sys_mc->mc_t1count;
		c = sys_mc->mc_t1ctl;
		t2 = sys_mc->mc_t1count;
		if (t2 < t1)	/* just wrapped */
			c = sys_mc->mc_t1ctl;
		sys_mc->mc_t1ctl = MC_TCTL_CEN | MC_TCTL_COC | MC_TCTL_COVF;
		sys_mc->mc_t1irq = prof_reset;
		oflow = c >> MC_TCTL_OVF_SHIFT;
		break;
#endif
#if NPCC > 0
	case BUS_PCC:
		/*
		 * Since we can not freeze the counter while reading the count
		 * and overflow registers, read them a second time; if the
		 * counter has wrapped, pick the second reading.
		 */
		t1 = sys_pcc->pcc_t1count;
		c = sys_pcc->pcc_t1ctl;
		t2 = sys_pcc->pcc_t1count;
		if (t2 < t1)	/* just wrapped */
			c = sys_pcc->pcc_t1ctl;
		sys_pcc->pcc_t1ctl = PCC_TIMER_COVF | PCC_TIMERSTART;
		sys_pcc->pcc_t1irq = prof_reset;
		oflow = c >> PCC_TIMER_OVF_SHIFT;
		pcc_curcnt += oflow * (0x10000 - sys_pcc->pcc_t1pload);
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		/*
		 * Since we can not freeze the counter while reading the count
		 * and overflow registers, read them a second time; if the
		 * counter has wrapped, pick the second reading.
		 */
		t1 = sys_pcc2->pcc2_t1count;
		c = sys_pcc2->pcc2_t1ctl;
		t2 = sys_pcc2->pcc2_t1count;
		if (t2 < t1)	/* just wrapped */
			c = sys_pcc2->pcc2_t1ctl;
		sys_pcc2->pcc2_t1ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC |
		    PCC2_TCTL_COVF;
		sys_pcc2->pcc2_t1irq = prof_reset;
		oflow = c >> PCC2_TCTL_OVF_SHIFT;
		pcctwo_curcnt += oflow * sys_pcc2->pcc2_t1cmp;
		break;
#endif
	}

	while (oflow-- != 0)
		hardclock(arg);

	return (1);
}

/*
 * Set up real-time and, if available, statistics clock.
 */
void
cpu_initclocks()
{
	register int statint, minint;

	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
		tick = 1000000 / hz;
	}
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
	switch (clockbus) {
#if NLRC > 0
	case BUS_LRC:
		profhz = stathz = 0;	/* only one timer available for now */

		/*
		 * LRC timer usage:
		 * timer0 is used for delay().
		 * timer1 is used for time counters.
		 * timer2 is used for the scheduling clock.
		 */
		sys_lrc->lrc_tcr0 = 0;
		sys_lrc->lrc_tcr1 = TCR_TLD1;	/* reset to one */
		sys_lrc->lrc_tcr1 = TCR_TEN1 | TCR_TCYC1 | TCR_TIS_NONE;

		sys_lrc->lrc_t2base = tick + 1;
		sys_lrc->lrc_tcr2 = TCR_TLD2;	/* reset to one */
		sys_lrc->lrc_tcr2 = TCR_TEN2 | TCR_TCYC2 | TCR_T2IE;

		tc_init(&lrc_timecounter);
		break;
#endif
#if NOFOBIO > 0
	case BUS_OFOBIO:
		profhz = stathz = 0;	/* only one timer available */

		ofobio_clocksetup();

		ofobio_timecounter.tc_frequency = hz;
		tc_init(&ofobio_timecounter);
		break;
#endif
#if NMC > 0
	case BUS_MC:
		/*
		 * MC timer usage:
		 * timer1 is used for the scheduling clock.
		 * timer2 is used for the statistics clock.
		 * timer3 is used for time counters.
		 */

		sys_mc->mc_t1ctl = 0;
		sys_mc->mc_t1cmp = mc_timer_us2lim(tick);
		sys_mc->mc_t1count = 0;
		sys_mc->mc_t1ctl = MC_TCTL_CEN | MC_TCTL_COC | MC_TCTL_COVF;
		sys_mc->mc_t1irq = prof_reset;

		sys_mc->mc_t2ctl = 0;
		sys_mc->mc_t2cmp = mc_timer_us2lim(statint);
		sys_mc->mc_t2count = 0;
		sys_mc->mc_t2ctl = MC_TCTL_CEN | MC_TCTL_COC | MC_TCTL_COVF;
		sys_mc->mc_t2irq = stat_reset;

		sys_mc->mc_t3ctl = 0;
		sys_mc->mc_t3cmp = 0;
		sys_mc->mc_t3count = 0;
		sys_mc->mc_t3ctl = MC_TCTL_CEN;
		sys_mc->mc_t3irq = 0;
		tc_init(&mc_timecounter);
		break;
#endif
#if NPCC > 0
	case BUS_PCC:
		sys_pcc->pcc_t1pload = pcc_timer_us2lim(tick);
		sys_pcc->pcc_t1ctl = PCC_TIMERCLEAR;
		sys_pcc->pcc_t1ctl = PCC_TIMERSTART;
		sys_pcc->pcc_t1irq = prof_reset;

		sys_pcc->pcc_t2pload = pcc_timer_us2lim(statint);
		sys_pcc->pcc_t2ctl = PCC_TIMERCLEAR;
		sys_pcc->pcc_t2ctl = PCC_TIMERSTART;
		sys_pcc->pcc_t2irq = stat_reset;

		tc_init(&pcc_timecounter);
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		/* profclock */
		sys_pcc2->pcc2_t1ctl = 0;
		sys_pcc2->pcc2_t1cmp = pcc2_timer_us2lim(tick);
		sys_pcc2->pcc2_t1count = 0;
		sys_pcc2->pcc2_t1ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC |
		    PCC2_TCTL_COVF;
		sys_pcc2->pcc2_t1irq = prof_reset;

		/* statclock */
		sys_pcc2->pcc2_t2ctl = 0;
		sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(statint);
		sys_pcc2->pcc2_t2count = 0;
		sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC |
		    PCC2_TCTL_COVF;
		sys_pcc2->pcc2_t2irq = stat_reset;

		tc_init(&pcctwo_timecounter);
		break;
#endif
	}
	statmin = statint - (statvar >> 1);
}

void
setstatclockrate(newhz)
	int newhz;
{
}

int
statintr(cap)
	void *cap;
{
	register u_long newint, r, var;

	switch (clockbus) {
#if NPCC > 0
	case BUS_PCC:
		sys_pcc->pcc_t2irq = stat_reset;
		break;
#endif
#if NMC > 0
	case BUS_MC:
		sys_mc->mc_t2irq = stat_reset;
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		sys_pcc2->pcc2_t2irq = stat_reset;
		break;
#endif
	}

	statclock((struct clockframe *)cap);

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	switch (clockbus) {
#if NPCC > 0
	case BUS_PCC:
		sys_pcc->pcc_t2pload = pcc_timer_us2lim(newint);
		sys_pcc->pcc_t2ctl = PCC_TIMERCLEAR;
		sys_pcc->pcc_t2ctl = PCC_TIMERSTART;
		sys_pcc->pcc_t2irq = stat_reset;
		break;
#endif
#if NMC > 0
	case BUS_MC:
		sys_mc->mc_t2ctl = 0;
		sys_mc->mc_t2cmp = mc_timer_us2lim(newint);
		sys_mc->mc_t2count = 0;		/* should I? */
		sys_mc->mc_t2irq = stat_reset;
		sys_mc->mc_t2ctl = MC_TCTL_CEN | MC_TCTL_COC;
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		sys_pcc2->pcc2_t2ctl = 0;
		sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(newint);
		sys_pcc2->pcc2_t2count = 0;		/* should I? */
		sys_pcc2->pcc2_t2irq = stat_reset;
		sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC;
		break;
#endif
	}
	return (1);
}

void
delay(us)
	int us;
{
#if NPCC > 0 || NOFOBIO > 0
	volatile register int c;
#endif

	switch (clockbus) {
#if NLRC > 0
	case BUS_LRC:
	{
		struct lrcreg *lrc;

		if (sys_lrc != NULL)
			lrc = sys_lrc;
		else
			lrc = (struct lrcreg *)IIOV(0xfff90000);

		/* use timer0 and wait for it to wrap */
		lrc->lrc_t0base = us + 1;
		lrc->lrc_tcr0 = TCR_TLD0;	/* reset to one */
		lrc->lrc_stat = STAT_TMR0;	/* clear latch */
		lrc->lrc_tcr0 = TCR_TEN0;
		while ((lrc->lrc_stat & STAT_TMR0) == 0)
			;
	}
		break;
#endif
#if NMC > 0
	case BUS_MC:
		/*
		 * Reset and restart a free-running timer 1MHz, watch
		 * for it to reach the required count.
		 */
	{
		struct mcreg *mc;

		if (sys_mc != NULL)
			mc = sys_mc;
		else
			mc = (struct mcreg *)IIOV(0xfff00000);

		mc->mc_t3irq = 0;
		mc->mc_t3ctl = 0;
		mc->mc_t3count = 0;
		mc->mc_t3ctl = MC_TCTL_CEN | MC_TCTL_COVF;

		while (mc->mc_t3count < us)
			;
	}
		break;
#endif
#if NPCC > 0 || NOFOBIO > 0
	case BUS_PCC:
	case BUS_OFOBIO:
		/*
		 * XXX MVME147 doesn't have a 3rd free-running timer,
		 * so we use a stupid loop. Fix the code to watch t1:
		 * the profiling timer.
		 * MVME141 only has one timer, so there is no hope
		 * either.
		 */
		c = 2 * us;
		while (--c > 0)
			;
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		/*
		 * Use the first VMEChip2 timer in polling mode whenever
		 * possible.
		 */
	{
		struct vme2reg *vme2;

		if (sys_vme2 != NULL)
			vme2 = sys_vme2;
		else
			vme2 = (struct vme2reg *)IIOV(0xfff40000);

		vme2->vme2_t1cmp = 0xffffffff;
		vme2->vme2_t1count = 0;
		vme2->vme2_tctl |= VME2_TCTL_CEN;

		while (vme2->vme2_t1count < us)
			;

		vme2->vme2_tctl &= ~VME2_TCTL_CEN;
	}
		break;
#endif
	}
}
@


1.17
log
@Switch mvme68k to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2009/03/01 22:08:13 miod Exp $ */
@


1.16
log
@Support for MVME141 boards. Tested with both VME and VSB memory boards
(and MVME327 SCSI and MVME376 Ethernet, to provide a complete system).
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2009/03/01 21:40:49 miod Exp $ */
d70 1
d171 2
d187 4
d192 1
d216 166
d389 6
d408 11
d420 1
d425 11
d437 2
d443 12
d456 2
d462 3
a464 1
	hardclock(arg);
d498 6
d505 3
a507 2
		sys_lrc->lrc_tcr1 = 0;
		/* profclock as timer 2 */
d511 2
d520 3
d527 7
a533 1
		/* profclock */
a539 1
		/* statclock */
d545 7
d565 2
d586 2
@


1.15
log
@Support for MVME165 board - code written in april 2006, eventually debugged
last month.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2009/02/21 20:32:34 miod Exp $ */
d77 1
d87 3
d182 5
d221 5
d248 1
a248 2
 * Set up real-time clock; we don't have a statistics clock at
 * present.
d275 1
a275 1
		profhz = stathz = 0;
d285 7
d423 1
a423 1
#if NPCC > 0
d472 1
a472 1
#if NPCC > 0
d474 1
d479 2
@


1.14
log
@Previous delay() fix broke 1x2 boards. Make sure delay() works on them
before mc attaches, as intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2004/07/30 22:29:44 miod Exp $ */
d75 2
a77 1
#include "mc.h"
d80 6
a93 3
#if NMC > 0
#include <mvme68k/dev/mcreg.h>
#endif
d161 7
a167 6
#if NPCC > 0
	case BUS_PCC:
		prof_reset = ca->ca_ipl | PCC_IRQ_IEN | PCC_TIMERACK;
		stat_reset = ca->ca_ipl | PCC_IRQ_IEN | PCC_TIMERACK;
		pccintr_establish(PCCV_TIMER1, &sc->sc_profih, "clock");
		pccintr_establish(PCCV_TIMER2, &sc->sc_statih, "stat");
d178 8
d207 3
a209 3
#if NPCC > 0
	case BUS_PCC:
		sys_pcc->pcc_t1irq = prof_reset;
d217 5
d260 10
a269 11
#if NPCC > 0
	case BUS_PCC:
		sys_pcc->pcc_t1pload = pcc_timer_us2lim(tick);
		sys_pcc->pcc_t1ctl = PCC_TIMERCLEAR;
		sys_pcc->pcc_t1ctl = PCC_TIMERSTART;
		sys_pcc->pcc_t1irq = prof_reset;

		sys_pcc->pcc_t2pload = pcc_timer_us2lim(statint);
		sys_pcc->pcc_t2ctl = PCC_TIMERCLEAR;
		sys_pcc->pcc_t2ctl = PCC_TIMERSTART;
		sys_pcc->pcc_t2irq = stat_reset;
d289 13
d408 16
a423 9
#if NPCC > 0
	case BUS_PCC:
		/*
		 * XXX MVME147 doesn't have a 3rd free-running timer,
		 * so we use a stupid loop. Fix the code to watch t1:
		 * the profiling timer.
		 */
		c = 2 * us;
		while (--c > 0)
d425 1
d450 12
@


1.13
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2004/07/30 10:02:42 miod Exp $ */
d373 1
a373 1
#if (NPCC > 0) || (NPCCTWO > 0)
d396 12
a407 4
		sys_mc->mc_t3irq = 0;
		sys_mc->mc_t3ctl = 0;
		sys_mc->mc_t3count = 0;
		sys_mc->mc_t3ctl = MC_TCTL_CEN | MC_TCTL_COVF;
d409 1
a409 1
		while (sys_mc->mc_t3count < us)
d411 1
d418 1
a418 2
		 * possible. However, since clock attaches before vme,
		 * use a tight loop if necessary.
@


1.12
log
@Might count timer interrupts as well (oops).
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2004/07/03 14:36:19 miod Exp $ */
a69 1
#include <sys/evcount.h>
a104 1
	struct evcount	sc_profcnt;
a105 1
	struct evcount	sc_statcnt;
d161 2
a162 2
		pccintr_establish(PCCV_TIMER1, &sc->sc_profih);
		pccintr_establish(PCCV_TIMER2, &sc->sc_statih);
d169 2
a170 2
		mcintr_establish(MCV_TIMER1, &sc->sc_profih);
		mcintr_establish(MCV_TIMER2, &sc->sc_statih);
d177 2
a178 2
		pcctwointr_establish(PCC2V_TIMER1, &sc->sc_profih);
		pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih);
a182 5
	evcount_attach(&sc->sc_statcnt, "stat", (void *)&sc->sc_statih.ih_ipl,
	    &evcount_intr);
	evcount_attach(&sc->sc_profcnt, "clock", (void *)&sc->sc_profih.ih_ipl,
	    &evcount_intr);

a192 2
	struct clocksoftc *sc = clock_cd.cd_devs[0];

a210 1
	sc->sc_profcnt.ec_count++;
a304 1
	struct clocksoftc *sc = clock_cd.cd_devs[0];
a324 1
	sc->sc_statcnt.ec_count++;
@


1.11
log
@On 1[67]7 boards, always use the VMEChip2 timers for delay(), even if the
device is not attached yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2004/01/14 20:50:48 miod Exp $ */
d70 1
d106 1
d108 1
d186 5
d201 2
d220 2
d316 1
d337 1
@


1.10
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2003/10/08 20:18:34 miod Exp $ */
d411 17
a427 14
		if (sys_vme2 != NULL) {
			sys_vme2->vme2_t1cmp = 0xffffffff;
			sys_vme2->vme2_t1count = 0;
			sys_vme2->vme2_tctl |= VME2_TCTL_CEN;

			while (sys_vme2->vme2_t1count < us)
				;

			sys_vme2->vme2_tctl &= ~VME2_TCTL_CEN;
		} else {
			c = 4 * us;
			while (--c > 0)
				;
		}
@


1.9
log
@On 167 and 177 boards, use a VMEChip2 timer for accurate delay() whenever
possible, rather than a tight loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2003/06/02 23:27:50 millert Exp $ */
d116 1
a116 1
	NULL, "clock", DV_DULL, 0
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2003/06/02 05:09:14 deraadt Exp $ */
d84 2
a90 4
#if defined(GPROF)
#include <sys/gmon.h>
#endif

d407 3
a409 3
		 * XXX MVME167 doesn't have a 3rd free-running timer,
		 * so we use a stupid loop. Fix the code to watch t1:
		 * the profiling timer.
d411 14
a424 3
		c = 4 * us;
		while (--c > 0)
			;
@


1.7
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 2002/04/28 14:47:50 miod Exp $ */
d47 1
a47 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@A few more tweaks to let non-GENERIC kernels (MVMEfoo) build as well with -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 2002/04/27 23:21:05 miod Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.5
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 2002/03/14 01:26:37 millert Exp $ */
d384 1
d386 1
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 1996/04/28 11:06:02 deraadt Exp $ */
d77 1
d79 1
a79 1
#include <sys/device.h>
d230 1
d380 1
d382 1
a382 1
	register int us;
d397 1
a397 1
		return (0);
d412 1
a412 1
		return (0);
d424 1
a424 1
		return (0);
@


1.3
log
@cfattach/cfdriver split
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d119 2
a120 2
void	clockattach __P((struct device *, struct device *, void *));
int	clockmatch __P((struct device *, void *, void *));
d130 2
a131 2
int	clockintr __P((void *));
int	statintr __P((void *));
@


1.3.26.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 1996/04/28 11:06:02 deraadt Exp $ */
d77 1
a78 2
#include <sys/kernel.h>
#include <sys/systm.h>
d119 2
a120 2
void	clockattach(struct device *, struct device *, void *);
int	clockmatch(struct device *, void *, void *);
d130 2
a131 2
int	clockintr(void *);
int	statintr(void *);
a228 1
void
a377 1
void
d379 1
a379 1
	int us;
a380 1
#if (NPCC > 0) || (NPCCTWO > 0)
a381 1
#endif
d394 1
a394 1
		break;
d409 1
a409 1
		break;
d421 1
a421 1
		break;
@


1.3.16.1
log
@Merge in -current from about a week ago
@
text
@d119 2
a120 2
void	clockattach(struct device *, struct device *, void *);
int	clockmatch(struct device *, void *, void *);
d130 2
a131 2
int	clockintr(void *);
int	statintr(void *);
@


1.3.16.2
log
@Sync the SMP branch with 3.3
@
text
@d77 1
a78 2
#include <sys/kernel.h>
#include <sys/systm.h>
a228 1
void
a377 1
void
d379 1
a379 1
	int us;
a380 1
#if (NPCC > 0) || (NPCCTWO > 0)
a381 1
#endif
d394 1
a394 1
		break;
d409 1
a409 1
		break;
d421 1
a421 1
		break;
@


1.3.16.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3.16.2 2003/03/27 23:32:16 niklas Exp $ */
d14 6
d53 5
a57 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.16.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a83 2
#include <mvme68k/dev/vme.h>
extern struct vme2reg *sys_vme2;
d89 4
d118 1
a118 1
	NULL, "clock", DV_DULL
d409 3
a411 3
		 * Use the first VMEChip2 timer in polling mode whenever
		 * possible. However, since clock attaches before vme,
		 * use a tight loop if necessary.
d413 3
a415 14
		if (sys_vme2 != NULL) {
			sys_vme2->vme2_t1cmp = 0xffffffff;
			sys_vme2->vme2_t1count = 0;
			sys_vme2->vme2_tctl |= VME2_TCTL_CEN;

			while (sys_vme2->vme2_t1count < us)
				;

			sys_vme2->vme2_tctl &= ~VME2_TCTL_CEN;
		} else {
			c = 4 * us;
			while (--c > 0)
				;
		}
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d122 6
a127 3
struct cfdriver clockcd = {
	NULL, "clock", clockmatch, clockattach,
	DV_DULL, sizeof(struct clocksoftc), 0
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
d5 28
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
