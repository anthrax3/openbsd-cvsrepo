head	1.55;
access;
symbols
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.53.0.4
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.2
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.52.0.10
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.8
	OPENBSD_5_0:1.52.0.6
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.52.0.4
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.44.0.6
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.4
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.43.0.6
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.4
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.40.0.6
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.4
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.40.0.2
	OPENBSD_3_6_BASE:1.40
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.28
	UBC:1.22.0.4
	UBC_BASE:1.22
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.21.0.4
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.19.0.2
	SMP_BASE:1.19
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.8
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.6
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.16.0.4
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.14.0.2
	OPENBSD_2_0_BASE:1.14
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.55
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.54;

1.54
date	2013.10.07.17.53.57;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2012.11.04.13.33.32;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2010.06.28.14.13.29;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.31.12.00.06;	author fgsch;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.31.12.25.52;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.01.21.37.41;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2006.06.11.20.46.50;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.01.11.59.39;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.24.22.43.16;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.09.06.04.18;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.31.22.28.58;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.30.22.29.44;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.30.09.50.15;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.02.18.01.15;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.02.17.57.29;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.20.00.34.28;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.03.21.09.01;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.12.03.49.54;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.11.05.13.39;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.27.05.44.47;	author nate;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	2000.07.06.12.54.55;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.26.23.31.58;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.25.21.02.32;	author deraadt;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.01.06.03.21.42;	author smurph;	state Exp;
branches;
next	1.17;

1.17
date	99.10.04.04.23.41;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	97.07.27.08.16.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.04.02.05.25.45;	author rahnds;	state Exp;
branches;
next	1.14;

1.14
date	96.06.11.10.17.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.06.11.10.15.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.05.10.16.54.54;	author rahnds;	state Exp;
branches;
next	1.11;

1.11
date	96.05.07.07.47.34;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.04.28.11.06.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	95.12.16.19.42.39;	author rahnds;	state Exp;
branches;
next	1.8;

1.8
date	95.12.01.20.39.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	95.12.01.19.26.41;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	95.12.01.19.10.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.01.18.13.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.19.03.04.16;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	95.11.07.08.48.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.29.16.49.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.43.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.43.01;	author deraadt;	state Exp;
branches;
next	;

1.19.2.1
date	2001.04.18.16.10.21;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.07.04.10.19.22;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2002.03.06.01.06.59;	author niklas;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.22.4.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: cl.c,v 1.54 2013/10/07 17:53:57 miod Exp $ */

/*
 * Copyright (c) 1995 Dale Rahn. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */  

/* DMA mode still does not work!!! */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>

#include <dev/cons.h>

#include <mvme68k/dev/clreg.h>

#include "cl.h"

#ifdef DDB
#include <ddb/db_var.h>
#endif

#include "pcctwo.h"

#if NPCCTWO > 0
#include <mvme68k/dev/pcctworeg.h>
#endif

#define splcl() spltty()
#define USE_BUFFER

/* min timeout 0xa, what is a good value */
#define CL_TIMEOUT	0x10
#define CL_FIFO_MAX	0x20
#define CL_FIFO_CNT	0xc
#define	CL_RX_TIMEOUT	0x10

#define CL_RXDMAINT	0x82
#define CL_TXDMAINT	0x42
#define CL_TXMASK	0x47
#define CL_RXMASK	0x87 
#define CL_TXINTR	0x02
#define CL_RXINTR	0x02

struct cl_cons {
	paddr_t	cl_paddr;
	struct clreg *cl_vaddr;
	volatile struct pcctworeg *pcctwoaddr;
	u_char	channel;
} cl_cons;

struct cl_info {
	struct tty *tty;
	u_char	cl_swflags;
	u_char	cl_softchar;
	u_char	cl_consio;
	u_char	cl_speed;
	u_char	cl_parstop;	/* parity, stop bits. */
	u_char	cl_rxmode;
	u_char	cl_txmode;
	u_char	cl_clen;
	u_char	cl_parity;
	u_char  transmitting;
	u_long  txcnt;
	u_long  rxcnt;

	void *rx[2];
	void *rxp[2];
	void *tx[2];
	void *txp[2];

	volatile u_char *pconsum;
	volatile u_char *psupply;
	volatile u_char *buffer; 
	volatile int	nchar;
};
#define CLCD_PORTS_PER_CHIP 4
#define CL_BUFSIZE 256

#ifndef DO_MALLOC
/* four (4) buffers per port */
char cl_dmabuf [CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
#endif

struct clsoftc {
	struct device	sc_dev;
	time_t	sc_rotime;	/* time of last ring overrun */
	time_t	sc_fotime;	/* time of last fifo overrun */
	u_char *pbase;
	struct clreg *cl_reg;
	struct cl_info		sc_cl[CLCD_PORTS_PER_CHIP];
	struct intrhand		sc_ih_e;
	struct intrhand		sc_ih_m;
	struct intrhand		sc_ih_t;
	struct intrhand		sc_ih_r;
	char			sc_errintrname[16 + 4];
	char			sc_mxintrname[16 + 3];
	char			sc_rxintrname[16 + 3];
	char			sc_txintrname[16 + 3];
	int			sc_flags;
	void			*sc_softih;
};

const struct {
	u_int speed;
	u_char divisor;
	u_char clock;
	u_char rx_timeout;
} cl_clocks[] = {
	{ 64000, 0x26, 0, 0x01},
	{ 56000, 0x2c, 0, 0x01},
	{ 38400, 0x40, 0, 0x01},
	{ 19200, 0x81, 0, 0x02},
	{  9600, 0x40, 1, 0x04},
	{  7200, 0x56, 1, 0x04},
	{  4800, 0x81, 1, 0x08},
	{  3600, 0xad, 1, 0x08},
	{  2400, 0x40, 2, 0x10},
	{  1200, 0x81, 2, 0x20},
	{   600, 0x40, 3, 0x40},
	{   300, 0x81, 3, 0x80},
	{   150, 0x40, 3, 0x80},
	{   110, 0x58, 4, 0xff},
	{    50, 0xC2, 4, 0xff},
	{     0, 0x00, 0, 0},
};

/* prototypes */
cons_decl(cl);
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct clsoftc *sc, struct termios *par, int channel);

int clparam(struct tty *tp, struct termios *t);
int cl_mintr(void *);
int cl_txintr(void *);
int cl_rxintr(void *);
void cl_overflow(struct clsoftc *sc, int channel, time_t *ptime, u_char *msg);
void cl_parity(struct clsoftc *sc, int channel);
void cl_frame(struct clsoftc *sc, int channel);
void cl_break( struct clsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
void cl_dumpport(int channel);

int	clprobe(struct device *parent, void *self, void *aux);
void	clattach(struct device *parent, struct device *self, void *aux);

void cl_initchannel(struct clsoftc *sc, int channel);
void clputc(struct clsoftc *sc, int unit, u_char c);
u_char clgetc(struct clsoftc *sc, int *channel);
void cloutput(struct tty *tp);
void cl_softint(void *);
void cl_appendbufn(struct clsoftc *sc, u_char channel, u_char *buf, u_short cnt);

struct tty *cltty(dev_t);
int cl_instat(struct clsoftc *);
void clcnpollc(dev_t, int);
void cl_break(struct clsoftc *, int);
void cl_appendbuf(struct clsoftc *, u_char, u_char);

struct cfattach cl_ca = {
	sizeof(struct clsoftc), clprobe, clattach
};

struct cfdriver cl_cd = {
	NULL, "cl", DV_TTY
};

#define CLCDBUF 80

#define CL_UNIT(x) (minor(x) >> 2)
#define CL_CHANNEL(x) (minor(x) & 3)
#define CL_TTY(x) (minor(x))

struct tty *
cltty(dev)
	dev_t dev;
{
	int unit, channel;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (NULL);
	}
	channel = CL_CHANNEL(dev);
	return sc->sc_cl[channel].tty;
}

int
clprobe(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
{
	/* probing onboard 166/167/177/187 CL-cd2400
	 * should be previously configured, 
	 * we can check the value before resetting the chip
	 */
	struct clreg *cl_reg;
	struct confargs *ca = aux;
	int ret;

	switch (cputyp) {
	case CPU_166:
	case CPU_167:
	case CPU_176:
	case CPU_177:
		break;
	default:
		return 0;
	}

	cl_reg = (struct clreg *)ca->ca_vaddr;

#if 0
	ret = !badvaddr(&cl_reg->cl_gfrcr,1);
#else
	ret = 1;
#endif
	return ret;
}

void
clattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct clsoftc *sc = (struct clsoftc *)self;
	struct confargs *ca = aux;
	int i;

	sc->cl_reg = (struct clreg *)ca->ca_vaddr;

	if (ca->ca_paddr == cl_cons.cl_paddr) {
		/* if this device is configured as console,
		 * line cl_cons.channel is the console */
		sc->sc_cl[0].cl_consio = 1;
		printf(": console");
	} else {
		/* reset chip only if we are not console device */
		/* wait for GFRCR */
	}
        /* allow chip to settle before continuing */
        delay(800);

	/* set up global registers */
	sc->cl_reg->cl_tpr = CL_TIMEOUT;
	sc->cl_reg->cl_rpilr = 0x03;
	sc->cl_reg->cl_tpilr = 0x02;
	sc->cl_reg->cl_mpilr = 0x01;

#ifdef DO_MALLOC
	sc->sc_cl[0].rx[0] = (void *)(dvma_malloc(16 * CL_BUFSIZE));
#else
	sc->sc_cl[0].rx[0] = (void *) (&cl_dmabuf);
#endif
	sc->sc_cl[0].rx[1] = (void *)(((int)sc->sc_cl[0].rx[0]) + CL_BUFSIZE);
	sc->sc_cl[1].rx[0] = (void *)(((int)sc->sc_cl[0].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[1].rx[1] = (void *)(((int)sc->sc_cl[1].rx[0]) + CL_BUFSIZE);

	sc->sc_cl[2].rx[0] = (void *)(((int)sc->sc_cl[1].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[2].rx[1] = (void *)(((int)sc->sc_cl[2].rx[0]) + CL_BUFSIZE);
	sc->sc_cl[3].rx[0] = (void *)(((int)sc->sc_cl[2].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[3].rx[1] = (void *)(((int)sc->sc_cl[3].rx[0]) + CL_BUFSIZE);

	sc->sc_cl[0].tx[0] = (void *)(((int)sc->sc_cl[3].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[0].tx[1] = (void *)(((int)sc->sc_cl[0].tx[0]) + CL_BUFSIZE);
	sc->sc_cl[1].tx[0] = (void *)(((int)sc->sc_cl[0].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[1].tx[1] = (void *)(((int)sc->sc_cl[1].tx[0]) + CL_BUFSIZE);

	sc->sc_cl[2].tx[0] = (void *)(((int)sc->sc_cl[1].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[2].tx[1] = (void *)(((int)sc->sc_cl[2].tx[0]) + CL_BUFSIZE);
	sc->sc_cl[3].tx[0] = (void *)(((int)sc->sc_cl[2].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[3].tx[1] = (void *)(((int)sc->sc_cl[3].tx[0]) + CL_BUFSIZE);
#ifdef USE_BUFFER
	/* receive buffer and dma buffer are "shared" */
	for (i = 0; i < CLCD_PORTS_PER_CHIP; i++) {
		sc->sc_cl[i].buffer = sc->sc_cl[i].rx[0];
		sc->sc_cl[i].pconsum = sc->sc_cl[i].buffer;
		sc->sc_cl[i].psupply = sc->sc_cl[i].buffer;
		sc->sc_cl[i].nchar = 0;
	}
	sc->sc_softih = softintr_establish(IPL_SOFTTTY, cl_softint, sc);
#endif
	for (i = 0; i < CLCD_PORTS_PER_CHIP; i++) {
#if 0
		int j;

		for (j = 0; j < 2 ; j++) {
			sc->sc_cl[i].rxp[j] = (void *)kvtop(sc->sc_cl[i].rx[j]);
			printf("cl[%d].rxbuf[%d] %x p %x\n",
			    i, j, sc->sc_cl[i].rx[j], sc->sc_cl[i].rxp[j]);
			sc->sc_cl[i].txp[j] = (void *)kvtop(sc->sc_cl[i].tx[j]);
			printf("cl[%d].txbuf[%d] %x p %x\n",
			    i, j, sc->sc_cl[i].tx[j], sc->sc_cl[i].txp[j]);
		}
#endif
		
#if 0
		sc->sc_cl[i].cl_rxmode =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x01));
		sc->sc_cl[i].cl_txmode =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x02));
		sc->sc_cl[i].cl_softchar =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x04));
#endif
		cl_initchannel(sc, i);
	}

	/* enable interrupts */
	sc->sc_ih_e.ih_fn = cl_rxintr;
	sc->sc_ih_e.ih_arg = sc;
	sc->sc_ih_e.ih_ipl = ca->ca_ipl;
	sc->sc_ih_e.ih_wantframe = 0;

	sc->sc_ih_m.ih_fn = cl_mintr;
	sc->sc_ih_m.ih_arg = sc;
	sc->sc_ih_m.ih_ipl = ca->ca_ipl;
	sc->sc_ih_m.ih_wantframe = 0;

	sc->sc_ih_t.ih_fn = cl_txintr;
	sc->sc_ih_t.ih_arg = sc;
	sc->sc_ih_t.ih_ipl = ca->ca_ipl;
	sc->sc_ih_t.ih_wantframe = 0;

	sc->sc_ih_r.ih_fn = cl_rxintr;
	sc->sc_ih_r.ih_arg = sc;
	sc->sc_ih_r.ih_ipl = ca->ca_ipl;
	sc->sc_ih_r.ih_wantframe = 0;

	snprintf(sc->sc_errintrname, sizeof sc->sc_errintrname,
	    "%s_err", self->dv_xname);
	snprintf(sc->sc_mxintrname, sizeof sc->sc_mxintrname,
	    "%s_mx", self->dv_xname);
	snprintf(sc->sc_rxintrname, sizeof sc->sc_rxintrname,
	    "%s_rx", self->dv_xname);
	snprintf(sc->sc_txintrname, sizeof sc->sc_txintrname,
	    "%s_tx", self->dv_xname);

	pcctwointr_establish(PCC2V_SCC_RXE,&sc->sc_ih_e, sc->sc_errintrname);
	pcctwointr_establish(PCC2V_SCC_M,&sc->sc_ih_m, sc->sc_mxintrname);
	pcctwointr_establish(PCC2V_SCC_TX,&sc->sc_ih_t, sc->sc_txintrname);
	pcctwointr_establish(PCC2V_SCC_RX,&sc->sc_ih_r, sc->sc_rxintrname);
	sys_pcc2->pcc2_sccerr = 0x01; /* clear errors */

	/* enable all interrupts at ca_ipl */
	sys_pcc2->pcc2_sccirq = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
	sys_pcc2->pcc2_scctx  = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
	sys_pcc2->pcc2_sccrx  = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);

	printf("\n");
}

void
cl_initchannel(sc, channel)
	struct clsoftc *sc;
	int channel;
{
	int s;
	struct clreg *cl_reg = sc->cl_reg;

	/* set up option registers */
	sc->sc_cl[channel].tty = NULL;
	s = splhigh();

	cl_reg->cl_car	= (u_char) channel;
	cl_reg->cl_livr	= PCC2_VECBASE + 0xc;/* set vector base at 5C */
	cl_reg->cl_ier	= 0x00;

	if (sc->sc_cl[channel].cl_consio == 0) {
		cl_reg->cl_cmr	= 0x02; 
		cl_reg->cl_cor1	= 0x17;
		cl_reg->cl_cor2	= 0x00;
		cl_reg->cl_cor3	= 0x02;
		cl_reg->cl_cor4	= 0xec;
		cl_reg->cl_cor5	= 0xec;
		cl_reg->cl_cor6	= 0x00;
		cl_reg->cl_cor7	= 0x00;
		cl_reg->cl_schr1	= 0x00;
		cl_reg->cl_schr2	= 0x00;
		cl_reg->cl_schr3	= 0x00;
		cl_reg->cl_schr4	= 0x00;
		cl_reg->cl_scrl	= 0x00;
		cl_reg->cl_scrh	= 0x00;
		cl_reg->cl_lnxt	= 0x00;
		cl_reg->cl_rbpr	= 0x40; /* 9600 */
		cl_reg->cl_rcor	= 0x01;
		cl_reg->cl_tbpr	= 0x40; /* 9600 */
		cl_reg->cl_tcor	= 0x01 << 5;
		/* console port should be 0x88 already */
		cl_reg->cl_msvr_rts	= 0x00;
		cl_reg->cl_msvr_dtr	= 0x00;
		cl_reg->cl_rtprl	= CL_RX_TIMEOUT;
		cl_reg->cl_rtprh	= 0x00;

		sc->cl_reg->cl_ccr = 0x20;
		while (sc->cl_reg->cl_ccr != 0)
			;
	}

	splx(s);
}


int cldefaultrate = TTYDEF_SPEED;

int clmctl (dev, bits, how)
	dev_t dev;
	int bits;
	int how;
{
	int s;
	struct clsoftc *sc;
	/* should only be called with valid device */
	sc = (struct clsoftc *) cl_cd.cd_devs[CL_UNIT(dev)];
	/*
	printf("mctl: dev %x, bits %x, how %x,\n",dev, bits, how);
	*/
	/* settings are currently ignored */
	s = splcl();
	switch (how) {
	case DMSET:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x01;
		} else {
			sc->cl_reg->cl_msvr_rts = 0x00;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x02;
		} else {
			sc->cl_reg->cl_msvr_dtr = 0x00;
		}
		break;

	case DMBIC:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x00;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x00;
		}
		break;

	case DMBIS:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x01;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x02;
		}
		break;

	case DMGET:
		bits = 0;

		{
			u_char msvr;
			msvr = sc->cl_reg->cl_msvr_rts;
			if( msvr & 0x80) {
				bits |= TIOCM_DSR;
			}
			if( msvr & 0x40) {
				bits |= TIOCM_CD;
			}
			if( msvr & 0x20) {
				bits |= TIOCM_CTS;
			}
			if( msvr & 0x10) {
				bits |= TIOCM_DTR;
			}
			if( msvr & 0x02) {
				bits |= TIOCM_DTR;
			}
			if( msvr & 0x01) {
				bits |= TIOCM_RTS;
			}
			
		}
		break;
	}
	splx(s);
#if 0
	bits = 0;
	/* proper defaults? */
	bits |= TIOCM_DTR;
	bits |= TIOCM_RTS;
	bits |= TIOCM_CTS;
	bits |= TIOCM_CD;
	/*	bits |= TIOCM_RI; */
	bits |= TIOCM_DSR;
#endif

	/*
	printf("retbits %x\n", bits);
	*/
	return(bits);
}

int
clopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int s, unit, channel;
	struct cl_info *cl;
	struct clsoftc *sc;
	struct tty *tp;
	
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	s = splcl();
	if (cl->tty) {
		tp = cl->tty;
	} else {
		tp = cl->tty = ttymalloc(0);
	}
	tp->t_oproc = clstart;
	tp->t_param = clparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = cldefaultrate;

			if(sc->sc_cl[channel].cl_consio != 0) {
				/* console is 8N1 */
				tp->t_cflag = (CREAD | CS8 | HUPCL);
			} else {
				tp->t_cflag = TTYDEF_CFLAG;
			}
		}
		/*
		 * do these all the time
		 */
		if (cl->cl_swflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (cl->cl_swflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (cl->cl_swflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		clparam(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
#ifdef XXX
		if ((cl->cl_swflags & TIOCFLAG_SOFTCAR) ||
			(clmctl(dev, 0, DMGET) & TIOCM_CD)) {
			tp->t_state |= TS_CARR_ON;
		} else {
			tp->t_state &= ~TS_CARR_ON;
		}
#endif
		tp->t_state |= TS_CARR_ON;
		{
			u_char save = sc->cl_reg->cl_car;
			sc->cl_reg->cl_car = channel;
			sc->cl_reg->cl_ier	= 0x88;
#ifdef CL_DMA_WORKS
			{
			sc->cl_reg->cl_cmr	=
				/* CL_TXDMAINT | */ CL_RXDMAINT; 
			sc->cl_reg->cl_ier	= 0xa8;
			sc->cl_reg->cl_licr	= 0x00;
			}
			sc->cl_reg->cl_arbadrl	=
				((u_long)sc->sc_cl[channel].rxp[0]) & 0xffff;
			sc->cl_reg->cl_arbadru	=
				((u_long)sc->sc_cl[channel].rxp[0]) >> 16;
			sc->cl_reg->cl_brbadrl	=
				((u_long)sc->sc_cl[channel].rxp[1]) & 0xffff;
			sc->cl_reg->cl_brbadru	=
				((u_long)sc->sc_cl[channel].rxp[1]) >> 16;
			sc->cl_reg->cl_atbadrl	=
				((u_long)sc->sc_cl[channel].txp[0]) & 0xffff;
			sc->cl_reg->cl_atbadru	=
				((u_long)sc->sc_cl[channel].txp[0]) >> 16;
			sc->cl_reg->cl_btbadrl	=
				((u_long)sc->sc_cl[channel].txp[1]) & 0xffff;
			sc->cl_reg->cl_btbadru	=
				((u_long)sc->sc_cl[channel].txp[1]) >> 16;
			sc->cl_reg->cl_arbcnt	= CL_BUFSIZE;
			sc->cl_reg->cl_brbcnt	= CL_BUFSIZE;
			sc->cl_reg->cl_arbsts	= 0x01;
			sc->cl_reg->cl_brbsts	= 0x01;
if (channel == 2) { /* test one channel now */
			/* shift for tx DMA */
			/* no shift for rx DMA */
#if 0
			/* tx only */
			sc->cl_reg->cl_licr	= (CL_DMAMODE << 4);
			sc->cl_reg->cl_cmr	= 0x42; 
#endif
		/* rx only */
			sc->cl_reg->cl_licr	= 0x00;
			sc->cl_reg->cl_cmr	= 0x82; 
}
			sc->cl_reg->cl_ccr = 0x20;
			while (sc->cl_reg->cl_ccr != 0) {
			}
#endif /* CL_DMA_WORKS */
			sc->cl_reg->cl_car = save;
		}
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0) {
		splx(s);
		return(EBUSY);
	}
#ifdef XXX
	/*
	 * if NONBLOCK requested, ignore carrier
	 */
	if (flag & O_NONBLOCK)
	goto done;
#endif

	splx(s);
	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
#ifdef DEBUG
	cl_dumpport(channel);
#endif
	return((*linesw[tp->t_line].l_open)(dev, tp, p));
}
int clparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	int unit, channel;
	struct clsoftc *sc;
	int s;
	dev_t dev;

	dev = tp->t_dev;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	clccparam(sc, t, channel);
	s = splcl();
	cl_unblock(tp);
	splx(s);
	return 0;
}

#if 0
void cloutput(tp)
	struct tty *tp;
{
	int cc, s, unit, cnt;
	u_char *tptr;
	int channel;
	struct clsoftc *sc;
	dev_t dev;
	u_char cl_obuffer[CLCDBUF+1];

	dev = tp->t_dev;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return;
	}
	channel = CL_CHANNEL(dev);

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splcl();
	cc = tp->t_outq.c_cc;
	while (cc > 0) {
/*XXX*/
		cnt = min (CLCDBUF,cc);
		cnt = q_to_b(&tp->t_outq, cl_obuffer, cnt);
		if (cnt == 0) {
			break;
		}
		for (tptr = cl_obuffer; tptr < &cl_obuffer[cnt]; tptr++) {
			clputc(sc, channel, *tptr);
		}
		cc -= cnt;
	}
	splx(s);
}
#endif

int
clclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	int s;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	(*linesw[tp->t_line].l_close)(tp, flag, p);

	s = splcl();
	
	sc->cl_reg->cl_car = channel;
	if(cl->cl_consio == 0 && (tp->t_cflag & HUPCL) != 0) {
		sc->cl_reg->cl_msvr_rts = 0x00;
		sc->cl_reg->cl_msvr_dtr = 0x00;
		sc->cl_reg->cl_ccr = 0x05;
	}

	splx(s);
	ttyclose(tp);

#if 0
	cl->tty = NULL;
#endif
#ifdef DEBUG
	cl_dumpport(channel);
#endif

	return 0;
}

int
clread (dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;
	return((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
clwrite (dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;
	return((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

int
clioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error;
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return(error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return(error);

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;

	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
		(void) clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) clmctl(dev, *(int *) data, DMSET);
		break;

	case TIOCMBIS:
		(void) clmctl(dev, *(int *) data, DMBIS);
		break;

	case TIOCMBIC:
		(void) clmctl(dev, *(int *) data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = clmctl(dev, 0, DMGET);
		break;
	case TIOCGFLAGS:
		*(int *)data = cl->cl_swflags;
		break;
	case TIOCSFLAGS:
		error = suser(p, 0); 
		if (error != 0)
			return(EPERM); 

		cl->cl_swflags = *(int *)data;
		cl->cl_swflags &= /* only allow valid flags */
			(TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;
	default:
		return(ENOTTY);
	}

	return 0;
}
int
clstop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = splcl();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
}

void
clcnprobe(cp)
	struct consdev *cp;
{
	int maj;

	switch (cputyp) {
	case CPU_166:
	case CPU_167:
	case CPU_176:
	case CPU_177:
		break;
	default:
		return;
	}

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == clopen)
			break;
	cp->cn_dev = makedev (maj, 0);
	cp->cn_pri = CN_LOWPRI;
}

void
clcninit(cp)
	struct consdev *cp;
{
	struct clreg *cl_reg;
	
	cl_cons.cl_paddr = 0xfff45000;
	cl_cons.cl_vaddr = (struct clreg *)IIOV(cl_cons.cl_paddr);
	cl_cons.pcctwoaddr = (void *)IIOV(0xfff42000);
	cl_reg = cl_cons.cl_vaddr;

	/* reset the chip? */
#ifdef CLCD_DO_RESET
#endif

#if 1
	/* set up globals */
	cl_reg->cl_tftc  = 0x10;
	cl_reg->cl_tpr   = CL_TIMEOUT; /* is this correct?? */
	cl_reg->cl_rpilr = 0x03;
	cl_reg->cl_tpilr = 0x02;
	cl_reg->cl_mpilr = 0x01;

	/* set up the tty00 to be 9600 8N1 */
	cl_reg->cl_car   = 0x00;
	cl_reg->cl_cor1  = 0x17;	/* No parity, ignore parity, 8 bit char */
	cl_reg->cl_cor2  = 0x00;
	cl_reg->cl_cor3  = 0x02;	/* 1 stop bit */
	cl_reg->cl_cor4  = 0x00;
	cl_reg->cl_cor5  = 0x00;
	cl_reg->cl_cor6  = 0x00;
	cl_reg->cl_cor7  = 0x00;
	cl_reg->cl_schr1 = 0x00;
	cl_reg->cl_schr2 = 0x00;
	cl_reg->cl_schr3 = 0x00;
	cl_reg->cl_schr4 = 0x00;
	cl_reg->cl_scrl  = 0x00;
	cl_reg->cl_scrh  = 0x00;
	cl_reg->cl_lnxt  = 0x00;
	cl_reg->cl_cpsr  = 0x00;
#endif
}

int
cl_instat(sc)
	struct clsoftc *sc;
{
	struct clreg *cl_reg;
	if ( NULL == sc) {
		cl_reg = cl_cons.cl_vaddr;
	} else {
		cl_reg = sc->cl_reg;
	}
	return (cl_reg->cl_rir & 0x40);
}
int
clcngetc(dev)
	dev_t dev;
{
	u_char val, reoir, licr, isrl, data, fifo_cnt;
#if 0
	u_char status;
#endif
	int got_char = 0;
	u_char ier_old = 0xff;
	struct clreg *cl_reg = cl_cons.cl_vaddr;
	volatile struct pcctworeg *pcc2_base = cl_cons.pcctwoaddr;

	cl_reg->cl_car = 0;
	if (!(cl_reg->cl_ier & 0x08)) {
		ier_old = cl_reg->cl_ier;
		cl_reg->cl_ier	= 0x08;
	}
	while (got_char == 0) {
		val = cl_reg->cl_rir;
		/* if no receive interrupt pending wait */
		if (!(val & 0x80)) {
			continue;
		}
		/* XXX do we need to suck the entire FIFO contents? */
		reoir = pcc2_base->pcc2_sccrxiack; /* receive PIACK */
		licr = cl_reg->cl_licr;
		if (((licr >> 2) & 0x3) == 0) {
			/* is the interrupt for us (port 0) */
			/* the character is for us yea. */
			isrl = cl_reg->cl_risrl;
#if 0
			if (isrl & 0x01) {
				status = BREAK;
			}
			if (isrl & 0x02) {
				status = FRAME;
			}
			if (isrl & 0x04) {
				status = PARITY;
			}
			if (isrl & 0x08) {
				status = OVERFLOW;
			}
			/* we do not have special characters ;-) */
#endif
			fifo_cnt = cl_reg->cl_rfoc;
			data = cl_reg->cl_rdr;
			if (ier_old != 0xff) {
				cl_reg->cl_ier  = ier_old;
			}
			got_char = 1;
			cl_reg->cl_teoir = 0x00;
		} else {
			data = cl_reg->cl_rdr;
			cl_reg->cl_teoir = 0x00;
		}

	}
	
	return data;
}

void
clcnputc(dev, c)
	dev_t dev;
	u_char c;
{
	clputc(0, 0, c);
}

void
clcnpollc(dev, on)
	dev_t dev;
	int on;
{
	if (1 == on) {
		/* enable polling */
	} else {
		/* disable polling */
	}
	return;
}

void
clputc(sc, unit, c)
	struct clsoftc *sc;
	int unit;
	u_char c;
{
	int s;
	u_char schar;
	u_char oldchannel;
	struct clreg *cl_reg;
	if (0 == sc) {
		/* output on console */
		cl_reg = cl_cons.cl_vaddr;
	} else {
		cl_reg = sc->cl_reg;
	}
#ifdef NEW_CLCD_STRUCT
	/* should we disable, flush and all that goo? */
	cl->car = unit;
	schar = cl->schr3;
	cl->schr3 = c;
	cl->stcr = 0x08 | 0x03; /* send special char, char 3 */
	while (0 != cl->stcr) {
		/* wait until cl notices the command
		 * otherwise it may not notice the character
		 * if we send characters too fast.
		 */
	}
	cl->schr3 = schar;
#else
if (unit == 0) {
	s = splhigh();
	oldchannel = cl_reg->cl_car;
	cl_reg->cl_car = unit;
	schar = cl_reg->cl_schr3;
	cl_reg->cl_schr3 = c;
	cl_reg->cl_stcr = 0x08 | 0x03; /* send special char, char 3 */
	while (0 != cl_reg->cl_stcr) {
		/* wait until cl notices the command
		 * otherwise it may not notice the character
		 * if we send characters too fast.
		 */
	}
	DELAY(5);
	cl_reg->cl_schr3 = schar;
	cl_reg->cl_car = oldchannel;
	splx(s);
} else {
	s = splhigh();
	oldchannel = cl_reg->cl_car;
	cl_reg->cl_car = unit;
	if (cl_reg->cl_tftc > 0) {
		cl_reg->cl_tdr = c;
	}
	cl_reg->cl_car = oldchannel;
	splx(s);
}
#endif
	return;
}

u_char 
clgetc(sc, channel)
	struct clsoftc *sc;
	int *channel;
{
	struct clreg *cl_reg;
	volatile struct pcctworeg *pcc2_base;
	u_char val, reoir, licr, isrl, fifo_cnt, data;
	if (sc == NULL) {
		cl_reg = cl_cons.cl_vaddr;
		pcc2_base = cl_cons.pcctwoaddr;
	} else {
		cl_reg = sc->cl_reg;
		pcc2_base = sys_pcc2;
	}
	val = cl_reg->cl_rir;
	/* if no receive interrupt pending wait */
	if (!(val & 0x80)) {
		return 0;
	}
	/* XXX do we need to suck the entire FIFO contents? */
	reoir = pcc2_base->pcc2_sccrxiack; /* receive PIACK */
	licr = cl_reg->cl_licr;
	*channel = (licr >> 2) & 0x3;
	/* is the interrupt for us (port 0) */
	/* the character is for us yea. */
	isrl = cl_reg->cl_risrl;
#if 0
	if (isrl & 0x01) {
		status = BREAK;
	}
	if (isrl & 0x02) {
		status = FRAME;
	}
	if (isrl & 0x04) {
		status = PARITY;
	}
	if (isrl & 0x08) {
		status = OVERFLOW;
	}
	/* we do not have special characters ;-) */
#endif
	fifo_cnt = cl_reg->cl_rfoc;
	if (fifo_cnt > 0) {
		data = cl_reg->cl_rdr;
		cl_reg->cl_teoir = 0x00;
	} else {
		data = 0;
		cl_reg->cl_teoir = 0x08;
	}
	return data;
}
int
clccparam(sc, par, channel)
	struct clsoftc *sc;
	struct termios *par;
	int channel;
{
	u_int divisor, clk, clen;
	int s, imask, ints;

	s = splcl();
	sc->cl_reg->cl_car = channel;
	if (par->c_ospeed == 0) { 
		/* dont kill the console */
		if(sc->sc_cl[channel].cl_consio == 0) {
			/* disconnect, drop RTS DTR stop receiver */
			sc->cl_reg->cl_msvr_rts = 0x00;
			sc->cl_reg->cl_msvr_dtr = 0x00;
			sc->cl_reg->cl_ccr = 0x05;
		}
		splx(s);
		return (0xff);
	}

	sc->cl_reg->cl_msvr_rts = 0x03;
	sc->cl_reg->cl_msvr_dtr = 0x03;

	divisor = cl_clkdiv(par->c_ospeed);
	clk	= cl_clknum(par->c_ospeed);
	sc->cl_reg->cl_tbpr = divisor;
	sc->cl_reg->cl_tcor = clk << 5;
	divisor = cl_clkdiv(par->c_ispeed);
	clk	= cl_clknum(par->c_ispeed);
	sc->cl_reg->cl_rbpr = divisor;
	sc->cl_reg->cl_rcor = clk;
	sc->cl_reg->cl_rtprl = cl_clkrxtimeout(par->c_ispeed);
	sc->cl_reg->cl_rtprh = 0x00;

	switch (par->c_cflag & CSIZE) {
	case CS5:
		clen = 4; /* this is the mask for the chip. */
		imask = 0x1F;
		break;
	case CS6:
		clen = 5;
		imask = 0x3F;
		break;
	case CS7:
		clen = 6;
		imask = 0x7F;
		break;
	default:
		clen = 7;
		imask = 0xFF;
	}
	sc->cl_reg->cl_cor3 = par->c_cflag & PARENB ? 4 : 2;

	{
		u_char cor1;
		if (par->c_cflag & PARENB) {
			if (par->c_cflag & PARODD) {
				cor1 = 0xE0 | clen ; /* odd */
			} else {
				cor1 = 0x40 | clen ; /* even */
			}
		} else {
			cor1 = 0x10 | clen; /* ignore parity */
		}
		if (sc->cl_reg->cl_cor1 != cor1) { 
			sc->cl_reg->cl_cor1 = cor1;
			sc->cl_reg->cl_ccr = 0x20;
			while (sc->cl_reg->cl_ccr != 0) {
			}
		}
	}

	if (sc->sc_cl[channel].cl_consio == 0 && (par->c_cflag & CREAD) == 0)
		sc->cl_reg->cl_ccr = 0x08;
	else
		sc->cl_reg->cl_ccr = 0x0a;
	while (sc->cl_reg->cl_ccr != 0) {
	}
	ints = 0;
#define SCC_DSR 0x80
#define SCC_DCD 0x40
#define SCC_CTS 0x20
	if ((par->c_cflag & CLOCAL) == 0) {
		ints |= SCC_DCD;
	}
	if ((par->c_cflag & CCTS_OFLOW) != 0) {
		ints |= SCC_CTS;
	}
	if ((par->c_cflag & CRTSCTS) != 0) {
		ints |= SCC_CTS;
	}
#ifdef DONT_LET_HARDWARE
	if ((par->c_cflag & CCTS_IFLOW) != 0) {
		ints |= SCC_DSR;
	}
#endif
	sc->cl_reg->cl_cor4 = ints | CL_FIFO_CNT;
	sc->cl_reg->cl_cor5 = ints | CL_FIFO_CNT;

	return imask;
}
static int clknum = 0;
u_char 
cl_clkdiv(speed)
	int speed;
{
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
		return cl_clocks[clknum].divisor;
	}
	for  (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[i].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].divisor;
		}
	}
	/* return some sane value if unknown speed */
	return cl_clocks[4].divisor;
}
u_char 
cl_clknum(speed)
	int speed;
{
	int found = 0;
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
		return cl_clocks[clknum].clock;
	}
	for  (i = 0; found != 0 && cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[clknum].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].clock;
		}
	}
	/* return some sane value if unknown speed */
	return cl_clocks[4].clock;
}
u_char 
cl_clkrxtimeout(speed)
	int speed;
{
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
		return cl_clocks[clknum].rx_timeout;
	}
	for  (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[i].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].rx_timeout;
		}
	}
	/* return some sane value if unknown speed */
	return cl_clocks[4].rx_timeout;
}
void
cl_unblock(tp)
	struct tty *tp;
{
	tp->t_state &= ~TS_FLUSH;
	if (tp->t_outq.c_cc != 0)
		clstart(tp);
}
void
clstart(tp)
	struct tty *tp;
{
	dev_t dev;
#if 0
	u_char cbuf;
	int cnt;
#endif
	struct clsoftc *sc;
	int channel, unit, s;

	dev = tp->t_dev;
	channel = CL_CHANNEL(dev);
/* hack to test output on non console only */
#if 0
	if (channel == 0) {
		cloutput(tp);
		return;
	}
#endif
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs || 
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return;
	}

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splcl();
#if 0
	if (sc->sc_cl[channel].transmitting == 1) {
		/* i'm busy, go away, I will get to it later. */
		splx(s);
		return;
	}
	cnt = q_to_b(&tp->t_outq, &cbuf, 1);
	if ( cnt != 0 ) {
		sc->sc_cl[channel].transmitting = 1;
		sc->cl_reg->cl_car = channel;
		sc->cl_reg->cl_tdr = cbuf;
	} else {
		sc->sc_cl[channel].transmitting = 0;
	}
#else
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0)
	{
		tp->t_state |= TS_BUSY;
		sc->cl_reg->cl_car = channel;
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier | 0x3;
	}
#endif
	splx(s);
	return;
}
int
cl_mintr(arg)
	void *arg;
{
	struct clsoftc *sc = (struct clsoftc *)arg;
	u_char mir, misr, msvr;
	int channel;
	if(((mir = sc->cl_reg->cl_mir) & 0x40) == 0x0) {
		/* only if intr is not shared? */
		log(LOG_WARNING, "cl_mintr extra intr\n");
		return 0;
	}

	channel = mir & 0x03;
	misr = sc->cl_reg->cl_misr;
	msvr = sc->cl_reg->cl_msvr_rts;
	if (misr & 0x01) {
		/* timers are not currently used?? */
		log(LOG_WARNING, "cl_mintr: channel %x timer 1 unexpected\n",channel);
	}
	if (misr & 0x02) {
		/* timers are not currently used?? */
		log(LOG_WARNING, "cl_mintr: channel %x timer 2 unexpected\n",channel);
	}
	if (misr & 0x20) {
		struct tty *tp = sc->sc_cl[channel].tty;
#ifdef VERBOSE_LOG_MESSAGES
		log(LOG_WARNING, "cl_mintr: channel %x cts %x\n",channel, 
		((msvr & 0x20) != 0x0)
		);
#endif
		if (msvr & 0x20) {
			cl_unblock(tp);
		}
	}
	if (misr & 0x40) {
		struct tty *tp = sc->sc_cl[channel].tty;
#ifdef VERBOSE_LOG_MESSAGES
		log(LOG_WARNING, "cl_mintr: channel %x cd %x\n",channel,
		((msvr & 0x40) != 0x0)
		);
#endif
		(*linesw[tp->t_line].l_modem)(tp, ((msvr & 0x40) != 0x0) );
	}
	if (misr & 0x80) {
#ifdef VERBOSE_LOG_MESSAGES
		log(LOG_WARNING, "cl_mintr: channel %x dsr %x\n",channel,
		((msvr & 0x80) != 0x0)
		);
#endif
	}
	sc->cl_reg->cl_meoir = 0x00;
	return 1;
}

int
cl_txintr(arg)
	void *arg;
{
	struct clsoftc *sc = (struct clsoftc *)arg;
	static int empty = 0;
	u_char tir, cmr, teoir;
	u_char max;
	int channel;
	struct tty *tp;
	int cnt;
	u_char buffer[CL_FIFO_MAX +1];
	u_char *tptr;
	if(((tir = sc->cl_reg->cl_tir) & 0x40) == 0x0) {
		/* only if intr is not shared ??? */
		log(LOG_WARNING, "cl_txintr extra intr\n");
		return 0;
	}

	channel	= tir & 0x03;
	cmr	= sc->cl_reg->cl_cmr;
	
	sc->sc_cl[channel].txcnt ++;

	tp = sc->sc_cl[channel].tty;
	if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0) {
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
		sc->cl_reg->cl_teoir = 0x08;
		return 1;
	}
	switch (cmr & CL_TXMASK) {
	case CL_TXDMAINT:
		{
			u_char dmabsts;
			int nbuf, busy, resid;
			void *pbuffer;
			dmabsts = sc->cl_reg->cl_dmabsts;
		log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x\n",
			channel, dmabsts);
			nbuf = ((dmabsts & 0x8) >> 3) & 0x1;
			busy = ((dmabsts & 0x4) >> 2) & 0x1;

			do {
				pbuffer = sc->sc_cl[channel].tx[nbuf];
				resid = tp->t_outq.c_cc;
				cnt = min (CL_BUFSIZE,resid);
		log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %p\n",
			resid, cnt, pbuffer);
				if (cnt != 0) {
					cnt = q_to_b(&tp->t_outq, pbuffer, cnt);
					resid -= cnt;
					if (nbuf == 0) {
						sc->cl_reg->cl_atbadru =
							((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
						sc->cl_reg->cl_atbadrl =
							((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
						sc->cl_reg->cl_atbcnt = cnt;
						sc->cl_reg->cl_atbsts = 0x43;
					} else {
						sc->cl_reg->cl_btbadru =
							((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
						sc->cl_reg->cl_btbadrl =
							((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
						sc->cl_reg->cl_btbcnt = cnt;
						sc->cl_reg->cl_btbsts = 0x43;
					}
				teoir = 0x08;
				} else {
					teoir = 0x08;
					if (tp->t_state & TS_BUSY) {
						tp->t_state &= ~(TS_BUSY | TS_FLUSH);
						if (tp->t_state & TS_ASLEEP) {
							tp->t_state &= ~TS_ASLEEP;
							wakeup((caddr_t) &tp->t_outq);
						}
						selwakeup(&tp->t_wsel);
					}
					sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
				}
				nbuf = ~nbuf & 0x1;
				busy--;
			} while (resid != 0 && busy != -1);/* if not busy do other buffer */
		log(LOG_WARNING, "cl_txintr: done\n");
		}
		break;
	case CL_TXINTR:
		max = sc->cl_reg->cl_tftc;
		cnt = min ((int)max,tp->t_outq.c_cc);
		if (cnt != 0) {
			cnt = q_to_b(&tp->t_outq, buffer, cnt);
			empty = 0;
			for (tptr = buffer; tptr < &buffer[cnt]; tptr++) {
				sc->cl_reg->cl_tdr = *tptr;
			}
			teoir = 0x00;
		} else {
			if (empty > 5 && ((empty % 20000 )== 0)) {
			log(LOG_WARNING, "cl_txintr to many empty intr %d channel %d\n",
				empty, channel);
			}
			empty++;
			teoir = 0x08;
			if (tp->t_state & TS_BUSY) {
				tp->t_state &= ~(TS_BUSY | TS_FLUSH);
				if (tp->t_state & TS_ASLEEP) {
					tp->t_state &= ~TS_ASLEEP;
					wakeup((caddr_t) &tp->t_outq);
				}
				selwakeup(&tp->t_wsel);
			}
			sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
		}
		break;
	default:
		log(LOG_WARNING, "cl_txintr unknown mode %x\n", cmr);
		/* we probably will go to hell quickly now */
		teoir = 0x08;
	}
	sc->cl_reg->cl_teoir = teoir;
	return 1;
}

int
cl_rxintr(arg)
	void *arg;
{
	struct clsoftc *sc = (struct clsoftc *)arg;
	u_char rir, channel, cmr, risrl;
	u_char fifocnt;
	struct tty *tp;
	int i;
	u_char reoir;
	u_char buffer[CL_FIFO_MAX +1];
#ifdef DDB
	int wantddb = 0;
#endif
	
	rir = sc->cl_reg->cl_rir;
	if((rir & 0x40) == 0x0) {
		/* only if intr is not shared ??? */
		log(LOG_WARNING, "cl_rxintr extra intr\n");
		return 0;
	}

	channel = rir & 0x3;
	cmr = sc->cl_reg->cl_cmr;
	reoir = 0x08;

	sc->sc_cl[channel].rxcnt ++;
	risrl = sc->cl_reg->cl_risrl;
	if (risrl & 0x80) {
		/* timeout, no characters */
		reoir = 0x08;
	} else
	/* We don't need no sinkin special characters */
	if (risrl & 0x08) {
		cl_overflow (sc, channel, &sc->sc_fotime, "fifo");
		reoir = 0x08;
	} else
	if (risrl & 0x04) {
		cl_parity(sc, channel);
		reoir = 0x08;
	} else
	if (risrl & 0x02) {
		cl_frame(sc, channel);
		reoir = 0x08;
	} else
	if (risrl & 0x01) {
#ifdef DDB
		if (sc->sc_cl[channel].cl_consio)
			wantddb = db_console;
#endif
		cl_break(sc, channel);
		reoir = 0x08;
	}

	switch (cmr & CL_RXMASK) {
	case CL_RXDMAINT:
		{
			int nbuf;
			u_short cnt;
			int bufcomplete;
			u_char status, dmabsts;
			u_char risrh = sc->cl_reg->cl_risrh;
			dmabsts = sc->cl_reg->cl_dmabsts;
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x risrl %x risrh %x\n",
	channel, dmabsts, risrl, risrh);
#endif
			nbuf = (risrh & 0x08) ? 1 : 0;
			bufcomplete = (risrh & 0x20) ? 1 : 0;
			if (nbuf == 0) {
				cnt  = sc->cl_reg->cl_arbcnt;
				status =  sc->cl_reg->cl_arbsts;
			} else {
				cnt  = sc->cl_reg->cl_brbcnt;
				status =  sc->cl_reg->cl_brbsts;
			}
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_rxintr: 1channel %x buf %x cnt %x status %x\n",
channel, nbuf, cnt, status);
#endif
#ifdef USE_BUFFER
			cl_appendbufn(sc, channel,
				sc->sc_cl[channel].rx[nbuf], cnt);
#else 
			{
				int i;
				u_char *pbuf;
				tp = sc->sc_cl[channel].tty;
				pbuf = sc->sc_cl[channel].rx[nbuf];
			/* this should be done at off level */
{
	u_short rcbadru, rcbadrl;
	u_char arbsts, brbsts;
	u_char *pbufs, *pbufe;
	rcbadru = sc->cl_reg->cl_rcbadru;
	rcbadrl = sc->cl_reg->cl_rcbadrl;
	arbsts =  sc->cl_reg->cl_arbsts;
	brbsts =  sc->cl_reg->cl_brbsts;
	pbufs = sc->sc_cl[channel].rxp[nbuf];
	pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
	cnt = pbufe - pbufs;
#ifdef DMA_DEBUG
	log(LOG_WARNING, "cl_rxintr: rcbadru %x rcbadrl %x arbsts %x brbsts %x cnt %x\n",
	rcbadru, rcbadrl, arbsts, brbsts, cnt);
#endif
#ifdef DMA_DEBUG1
	log(LOG_WARNING, "cl_rxintr: buf %x cnt %x\n",
	nbuf, cnt);
#endif
}
				reoir = 0x0 | (bufcomplete) ? 0 : 0xd0;
				sc->cl_reg->cl_reoir = reoir;
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_rxintr: reoir %x\n", reoir);
#endif
				delay(10); /* give the chip a moment */
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_rxintr: 2channel %x buf %x cnt %x status %x\n",
channel, nbuf, cnt, status);
#endif
				for (i = 0; i < cnt; i++) {
					u_char c;
					c = pbuf[i];
					(*linesw[tp->t_line].l_rint)(c,tp);
				}
			/* this should be done at off level */
				if (nbuf == 0) {
					sc->cl_reg->cl_arbcnt = CL_BUFSIZE;
					sc->cl_reg->cl_arbsts = 0x01;
				} else {
					sc->cl_reg->cl_brbcnt = CL_BUFSIZE;
					sc->cl_reg->cl_brbsts = 0x01;
				}
			}
#endif
		}
		sc->cl_reg->cl_reoir = reoir;
		break;
	case CL_RXINTR:
		fifocnt = sc->cl_reg->cl_rfoc;
		tp = sc->sc_cl[channel].tty;
		for (i = 0; i < fifocnt; i++) {
			buffer[i] = sc->cl_reg->cl_rdr;
		}
		if (NULL == tp) {
			/* if the channel is not configured,
			 * dont send characters upstream.
			 * also fix problem with NULL dereference
			 */
			reoir = 0x00;
			break;
		}

		sc->cl_reg->cl_reoir = reoir;
#ifdef USE_BUFFER
		cl_appendbufn(sc, channel, buffer, fifocnt);
#else
		for (i = 0; i < fifocnt; i++) {
			u_char c;
			c = buffer[i];
			/* does any restricitions exist on spl
			 * for this call
			 */
			(*linesw[tp->t_line].l_rint)(c,tp);
			reoir = 0x00;
		}
#endif
		break;
	default:
		log(LOG_WARNING, "cl_rxintr unknown mode %x\n", cmr);
		/* we probably will go to hell quickly now */
		reoir = 0x08;
		sc->cl_reg->cl_reoir = reoir;
	}
#ifdef DDB
	if (wantddb != 0)
		Debugger();
#endif
	return 1;
}

void
cl_overflow (sc, channel, ptime, msg)
struct clsoftc *sc;
int channel;
time_t *ptime;
u_char *msg;
{
/*
	if (*ptime != time_second) {
*/
	{
/*
		*ptime = time_second;
*/
		log(LOG_WARNING, "%s%d[%d]: %s overrun\n", cl_cd.cd_name,
			0 /* fix */, channel, msg);
	}
	return;
}
void
cl_parity (sc, channel)
	struct clsoftc *sc;
	int channel;
{
#ifdef VERBOSE_LOG_MESSAGES
	log(LOG_WARNING, "%s%d[%d]: parity error\n", cl_cd.cd_name, 0, channel);
#endif
	return;
}
void
cl_frame (sc, channel)
	struct clsoftc *sc;
	int channel;
{
#ifdef VERBOSE_LOG_MESSAGES
	log(LOG_WARNING, "%s%d[%d]: frame error\n", cl_cd.cd_name, 0, channel);
#endif
	return;
}
void
cl_break (sc, channel)
	struct clsoftc *sc;
	int channel;
{
#ifdef VERBOSE_LOG_MESSAGES
	log(LOG_WARNING, "%s%d[%d]: break detected\n", cl_cd.cd_name, 0, channel);
#endif
	return;
}

void
cl_dumpport(channel)
	int channel;
{
	u_char	livr, cmr, cor1, cor2, cor3, cor4, cor5, cor6, cor7,
		schr1, schr2, schr3, schr4, scrl, scrh, lnxt,
		rbpr, rcor, tbpr, tcor, rpilr, rir, tpr, ier, ccr,
		dmabsts, arbsts, brbsts, atbsts, btbsts,
		csr, rts, dtr, rtprl, rtprh;
	volatile void * parbadru, *parbadrl,  *parbsts, *parbcnt;
	u_short rcbadru, rcbadrl, arbadru, arbadrl, arbcnt,
		brbadru, brbadrl, brbcnt;
	u_short tcbadru, tcbadrl, atbadru, atbadrl, atbcnt,
		btbadru, btbadrl, btbcnt;
	struct clsoftc *sc;

	struct clreg *cl_reg;
	int s;

	cl_reg = cl_cons.cl_vaddr;

	sc = (struct clsoftc *) cl_cd.cd_devs[0];

	s = splcl();
	cl_reg->cl_car	= (u_char) channel;
	livr = cl_reg->cl_livr;
	cmr = cl_reg->cl_cmr;
	cor1 = cl_reg->cl_cor1;
	cor2 = cl_reg->cl_cor2;
	cor3 = cl_reg->cl_cor3;
	cor4 = cl_reg->cl_cor4;
	cor5 = cl_reg->cl_cor5;
	cor6 = cl_reg->cl_cor6;
	cor7 = cl_reg->cl_cor7;
	schr1 = cl_reg->cl_schr1;
	schr2 = cl_reg->cl_schr2;
	schr3 = cl_reg->cl_schr3;
	schr4 = cl_reg->cl_schr4;
	scrl = cl_reg->cl_scrl;
	scrh = cl_reg->cl_scrh;
	lnxt = cl_reg->cl_lnxt;
	rbpr = cl_reg->cl_rbpr;
	rcor = cl_reg->cl_rcor;
	tbpr = cl_reg->cl_tbpr;
	rpilr = cl_reg->cl_rpilr;
	rir = cl_reg->cl_rir;
	ier = cl_reg->cl_ier;
	ccr = cl_reg->cl_ccr;
	tcor = cl_reg->cl_tcor;
	csr = cl_reg->cl_csr;
	tpr = cl_reg->cl_tpr;
	rts = cl_reg->cl_msvr_rts;
	dtr = cl_reg->cl_msvr_dtr;
	rtprl = cl_reg->cl_rtprl;
	rtprh = cl_reg->cl_rtprh;
	dmabsts = cl_reg->cl_dmabsts;
	tcbadru = cl_reg->cl_tcbadru;
	tcbadrl = cl_reg->cl_tcbadrl;
	rcbadru = cl_reg->cl_rcbadru;
	rcbadrl = cl_reg->cl_rcbadrl;

	parbadru = &(cl_reg->cl_arbadru);
	parbadrl = &(cl_reg->cl_arbadrl);
	parbcnt  = &(cl_reg->cl_arbcnt);
	parbsts  = &(cl_reg->cl_arbsts);

	arbadru = cl_reg->cl_arbadru;
	arbadrl = cl_reg->cl_arbadrl;
	arbcnt  = cl_reg->cl_arbcnt;
	arbsts  = cl_reg->cl_arbsts;

	brbadru = cl_reg->cl_brbadru;
	brbadrl = cl_reg->cl_brbadrl;
	brbcnt  = cl_reg->cl_brbcnt;
	brbsts  = cl_reg->cl_brbsts;

	atbadru = cl_reg->cl_atbadru;
	atbadrl = cl_reg->cl_atbadrl;
	atbcnt  = cl_reg->cl_atbcnt;
	atbsts  = cl_reg->cl_atbsts;

	btbadru = cl_reg->cl_btbadru;
	btbadrl = cl_reg->cl_btbadrl;
	btbcnt  = cl_reg->cl_btbcnt;
	btbsts  = cl_reg->cl_btbsts;

	splx(s);

	printf("{ port %x livr %x cmr %x\n",
		  channel,livr,   cmr);
	printf("cor1 %x cor2 %x cor3 %x cor4 %x cor5 %x cor6 %x cor7 %x\n",
		cor1,   cor2,   cor3,   cor4,   cor5,   cor6,   cor7);
	printf("schr1 %x schr2 %x schr3 %x schr4 %x\n",
		schr1,   schr2,   schr3,   schr4);
	printf("scrl %x scrh %x lnxt %x\n",
		scrl,   scrh,   lnxt);
	printf("rbpr %x rcor %x tbpr %x tcor %x\n",
		rbpr,   rcor,   tbpr,   tcor);
	printf("rpilr %x rir %x ier %x ccr %x\n",
		rpilr,   rir,   ier,   ccr);
	printf("tpr %x csr %x rts %x dtr %x\n",
		tpr,   csr,   rts,   dtr);
	printf("rtprl %x rtprh %x\n",
		rtprl,   rtprh);
	printf("rxcnt %lx txcnt %lx\n",
		sc->sc_cl[channel].rxcnt, sc->sc_cl[channel].txcnt);
	printf("dmabsts %x, tcbadru %x, tcbadrl %x, rcbadru %x, rcbadrl %x,\n",
		dmabsts,    tcbadru,    tcbadrl,    rcbadru,    rcbadrl );
	printf("parbadru %p, parbadrl %p, parbcnt %p, parbsts %p\n",
		parbadru,    parbadrl,    parbcnt,    parbsts);
	printf("arbadru %x, arbadrl %x, arbcnt %x, arbsts %x\n",
		arbadru,    arbadrl,    arbcnt,    arbsts);
	printf("brbadru %x, brbadrl %x, brbcnt %x, brbsts %x\n",
		brbadru,    brbadrl,    brbcnt,    brbsts);
	printf("atbadru %x, atbadrl %x, atbcnt %x, atbsts %x\n",
		atbadru,    atbadrl,    atbcnt,    atbsts);
	printf("btbadru %x, btbadrl %x, btbcnt %x, btbsts %x\n",
		btbadru,    btbadrl,    btbcnt,    btbsts);
	printf("}\n");
	return;
}
#ifdef USE_BUFFER
void
cl_appendbuf(sc, channel, c)
	struct clsoftc *sc;
	u_char channel;
	u_char c;
{
	/* int s; */
	/* s = splcl(); */
	if (1 + sc->sc_cl[channel].nchar >= CL_BUFSIZE ) {
		cl_overflow (sc, channel, &sc->sc_fotime, "rbuf");
		/* just toss the character */
		return;
	}
	*(sc->sc_cl[channel].psupply++) = c;
	if (&(sc->sc_cl[channel].buffer[CL_BUFSIZE])
	   == sc->sc_cl[channel].psupply) {
		sc->sc_cl[channel].psupply = sc->sc_cl[channel].buffer;
	}
	sc->sc_cl[channel].nchar ++;
	softintr_schedule(sc->sc_softih);
	/* splx (s); */
	
}
void
cl_appendbufn(sc, channel, buf, cnt)
	struct clsoftc *sc;
	u_char channel;
	u_char *buf;
	u_short cnt;
{
	/* int s; */
	int i;
	/* s = splcl(); */ /* should be called at splcl(). */
	if (cnt + sc->sc_cl[channel].nchar >= CL_BUFSIZE ) {
		cl_overflow (sc, channel, &sc->sc_fotime, "rbuf");
		/* just toss the character(s)
		 *  It could be argued that not all of the charactes
		 *  should be tossed, just the ones that actually
		 *  overflow the buffer. eh, O well.
		 */
		return;
	}
	for (i = 0; i < cnt; i++) {
		*(sc->sc_cl[channel].psupply++) = buf[i];
		if (&(sc->sc_cl[channel].buffer[CL_BUFSIZE]) == sc->sc_cl[channel].psupply)
		{
			sc->sc_cl[channel].psupply = sc->sc_cl[channel].buffer;
		}
		sc->sc_cl[channel].nchar ++;
	}
	softintr_schedule(sc->sc_softih);
	/* splx (s); */
}

void
cl_softint(arg)
	void *arg;
{
	struct clsoftc *sc = (struct clsoftc *)arg;
	int i;
	int s;
	u_char c;
	struct tty *tp;

	for (i = 0 ; i < CLCD_PORTS_PER_CHIP; i ++) {
/* printf("channel %x sc %x\n", i, sc); */ 
		tp = sc->sc_cl[i].tty;
/* printf("channel %x pconsum %x\n", i, sc->sc_cl[i].pconsum); */ 
		while (sc->sc_cl[i].nchar > 0) {
			s = splcl();
			c = *(sc->sc_cl[i].pconsum++);
			if (&(sc->sc_cl[i].buffer[CL_BUFSIZE]) == sc->sc_cl[i].pconsum)
			{
				sc->sc_cl[i].pconsum = sc->sc_cl[i].buffer;
			}
			sc->sc_cl[i].nchar--;
			splx(s);
			(*linesw[tp->t_line].l_rint)(c,tp);
		}
	}
}
#endif
@


1.54
log
@Do not invoke ttymodem() directly, but l_modem from the current linedisc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.53 2012/11/04 13:33:32 miod Exp $ */
@


1.53
log
@Switch mvme68k to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.52 2010/06/28 14:13:29 deraadt Exp $ */
d1469 1
a1469 1
		ttymodem(tp, ((msvr & 0x40) != 0x0) );
@


1.52
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.51 2010/04/12 12:57:52 tedu Exp $ */
d1793 1
a1793 1
	if (*ptime != time.tv_sec) {
d1797 1
a1797 1
		*ptime = time.tv_sec;
@


1.51
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.50 2009/11/09 17:53:39 nicm Exp $ */
d557 1
a557 1
		tp = cl->tty = ttymalloc();
@


1.50
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.49 2009/10/31 12:00:06 fgsch Exp $ */
d674 1
a674 1
	return((*linesw[tp->t_line].l_open)(dev, tp));
d762 1
a762 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.49
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.48 2009/10/31 06:40:16 deraadt Exp $ */
a1557 1
						KNOTE(&tp->t_wsel.si_note, 0);
a1590 1
				KNOTE(&tp->t_wsel.si_note, 0);
@


1.48
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.47 2009/05/31 12:25:52 miod Exp $ */
d653 1
a653 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
@


1.47
log
@Fix definition of CL_FIFO_MAX to match what the hardware can do; this in
turn fixes a stack smash in cl_rxintr().
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.46 2009/03/15 20:40:25 miod Exp $ */
d1558 1
d1592 1
@


1.46
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.45 2009/03/01 21:37:41 miod Exp $ */
d64 1
a64 1
#define CL_FIFO_MAX	0x10
@


1.45
log
@Clean up match routines vs board id; this should give 166, 172 and 176 a
change to work better.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.44 2008/01/23 16:37:57 jsing Exp $ */
d131 1
a131 1
	u_int8_t		ssir;
d318 1
a318 1
	sc->ssir = allocate_sir(cl_softint, (void *)sc);
d1976 1
a1976 1
	setsoftint(sc->ssir);
d2007 1
a2007 1
	setsoftint(sc->ssir);
@


1.44
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.43 2006/06/11 20:46:50 miod Exp $ */
d236 8
a243 2
	if (cputyp != CPU_167 && cputyp != CPU_166 && cputyp != CPU_177)
	{
d246 2
a247 1
   cl_reg = (struct clreg *)ca->ca_vaddr;
d937 1
d939 1
@


1.43
log
@Factorize spl handling functions and software interrupt routines between
m68k-based platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.42 2006/01/01 11:59:39 miod Exp $ */
d942 1
a942 1
	cp->cn_pri = CN_NORMAL;
@


1.42
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.41 2005/11/24 22:43:16 miod Exp $ */
d131 1
a131 1
	int			ssir;
@


1.41
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.40 2004/08/09 06:04:18 miod Exp $ */
a933 1
		cp->cn_pri = CN_DEAD;
@


1.40
log
@Unbreak RAMDISK; deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.39 2004/07/31 22:28:58 miod Exp $ */
d76 1
a76 1
	void	*cl_paddr;
d952 2
a953 2
	cl_cons.cl_paddr = (void *)0xfff45000;
	cl_cons.cl_vaddr   = (struct clreg *)IIOV(cl_cons.cl_paddr);
@


1.39
log
@Always reset the cd2400 chip if console, and do not partially reprogram
it later when the device attaches; fixes some jitter in output on MVME177.
Tested on MVME167 and MVME177.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.38 2004/07/30 22:29:44 miod Exp $ */
d1607 1
d1609 1
@


1.38
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.37 2004/07/30 09:50:15 miod Exp $ */
d159 1
a159 4
int clcnprobe(struct consdev *cp);
int clcninit(struct consdev *cp);
int clcngetc(dev_t dev);
void clcnputc(dev_t dev, u_char c);
a336 2
        /* allow chip to settle before continuing */
        delay(50);
d389 1
d393 1
a395 1
	/* if the port is not the console, should be init for all ports??*/
d397 2
a398 1
	if (sc->sc_cl[channel].cl_consio != 1) {
d423 4
a426 3
	}
	sc->cl_reg->cl_ccr = 0x20;
	while (sc->cl_reg->cl_ccr != 0) {
d568 1
a568 1
			if(sc->sc_cl[channel].cl_consio == 1) {
d923 1
a923 1
int
a926 2
	/* always there ? */
	/* serial major */
d929 9
a943 2

	return 1;
d946 1
a946 1
int
d948 1
a948 1
struct consdev *cp;
a949 4
#ifdef MAP_DOES_WORK
	int size = (0x1ff + PGOFSET) & ~PGOFSET;
	int pcc2_size = (0x3C + PGOFSET) & ~PGOFSET;
#endif
a952 4
#ifdef MAP_DOES_WORK
	cl_cons.cl_vaddr = mapiodev(cl_cons.cl_paddr,size);
	cd_pcc2_base = mapiodev(0xfff42000,pcc2_size);
#else
a954 1
#endif
d956 1
d960 2
a962 1
#ifdef NOT_ALREADY_SETUP
a986 1
	return 0;
d1273 1
a1273 3
	if (sc->sc_cl[channel].cl_consio == 0
		&& (par->c_cflag & CREAD) == 0 )
	{
d1275 1
a1275 1
	} else {
a1276 1
	}
d1640 1
d1642 2
a1643 1
			wantddb = 1;
d1769 1
a1769 1
	if (wantddb && db_console)
@


1.37
log
@Switch mvme68k to evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.36 2004/07/02 18:01:15 miod Exp $ */
a37 1
#include <sys/evcount.h>
a116 6
	struct evcount	sc_txintrcnt;
	char		sc_txintrname[16 + 3];
	struct evcount	sc_rxintrcnt;
	char		sc_rxintrname[16 + 3];
	struct evcount	sc_mxintrcnt;
	char		sc_mxintrname[16 + 3];
d126 4
a362 14
	switch (ca->ca_bustype) {
	case BUS_PCCTWO:
		pcctwointr_establish(PCC2V_SCC_RXE,&sc->sc_ih_e);
		pcctwointr_establish(PCC2V_SCC_M,&sc->sc_ih_m);
		pcctwointr_establish(PCC2V_SCC_TX,&sc->sc_ih_t);
		pcctwointr_establish(PCC2V_SCC_RX,&sc->sc_ih_r);
		sys_pcc2->pcc2_sccerr = 0x01; /* clear errors */

		/* enable all interrupts at ca_ipl */
		sys_pcc2->pcc2_sccirq = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
		sys_pcc2->pcc2_scctx  = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
		sys_pcc2->pcc2_sccrx  = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
		break;
	}
d364 6
d372 11
a382 10
	evcount_attach(&sc->sc_txintrcnt, sc->sc_txintrname,
	    (void *)&sc->sc_ih_t.ih_ipl, &evcount_intr);
	snprintf(sc->sc_rxintrname, sizeof sc->sc_rxintrname,
	    "%s_rx", self->dv_xname);
	evcount_attach(&sc->sc_rxintrcnt, sc->sc_rxintrname,
	    (void *)&sc->sc_ih_r.ih_ipl, &evcount_intr);
	snprintf(sc->sc_mxintrname, sizeof sc->sc_mxintrname,
	    "%s_mx", self->dv_xname);
	evcount_attach(&sc->sc_mxintrcnt, sc->sc_mxintrname,
	    (void *)&sc->sc_ih_m.ih_ipl, &evcount_intr);
a1438 1
	sc->sc_mxintrcnt.ec_count++;
a1499 1
	sc->sc_txintrcnt.ec_count++;
d1623 1
a1623 1
	sc->sc_rxintrcnt.ec_count++;
@


1.36
log
@Remove unused code, per mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.35 2004/07/02 17:57:29 miod Exp $ */
d38 1
a38 1
/* #include <sys/queue.h> */
d118 6
a123 3
	struct evcnt sc_txintrcnt;
	struct evcnt sc_rxintrcnt;
	struct evcnt sc_mxintrcnt;
d381 13
a393 3
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_txintrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_rxintrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_mxintrcnt);
d1449 1
a1449 1
	sc->sc_mxintrcnt.ev_count++;
d1511 1
a1511 1
	sc->sc_txintrcnt.ev_count++;
d1635 1
a1635 1
	sc->sc_rxintrcnt.ev_count++;
@


1.35
log
@Kill ca_master in autoconf structures. Drivers either only attach to one
specific bus (mc/pcc/pcctwo), or they know it from the ca_bustype value,
and can use the globals sys_busname variables.

This also allows for some code simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.34 2004/01/14 20:50:48 miod Exp $ */
a193 1
void cl_chkinput(void);
a206 2
int dopoll = 1;

a1146 42

/*
#ifdef CLCD_DO_POLLED_INPUT
*/
#if 1
void
cl_chkinput()
{
	struct tty *tp;
	int unit;
	struct clsoftc *sc;
	int channel;

	if (dopoll == 0)
		return;
	for (unit = 0; unit < cl_cd.cd_ndevs; unit++) {
		if (unit >= cl_cd.cd_ndevs || 
			(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
			continue;
		}
		if (cl_instat(sc)) {
			while (cl_instat(sc)){
				int ch;
				u_char c;
				/*
				*(pinchar++) = clcngetc();
				*/
				ch = clgetc(sc,&channel) & 0xff;
				c = ch;

				tp = sc->sc_cl[channel].tty;
				if (NULL != tp) {
					(*linesw[tp->t_line].l_rint)(c,tp);
				}
			}
			/*
			wakeup(tp);
			*/
		}
	}
}
#endif
@


1.34
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.33 2003/12/20 00:34:28 miod Exp $ */
a129 1
	struct pcctworeg	*sc_pcctwo;
d133 2
a134 1
struct {
a266 1
	sc->sc_pcctwo = ca->ca_master;
a367 1
		dopoll = 0;
d372 1
a372 2
		sc->sc_pcctwo = (void *)ca->ca_master;
		sc->sc_pcctwo->pcc2_sccerr = 0x01; /* clear errors */
d375 3
a377 3
		sc->sc_pcctwo->pcc2_sccirq = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_scctx  = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_sccrx  = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
d1201 1
a1201 1
	if (0 == sc) {
d1206 1
a1206 1
		pcc2_base = sc->sc_pcctwo;
@


1.33
log
@Passl -Wformat. Fix some blatant -Wuninitialized errors as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.32 2003/10/03 16:44:50 miod Exp $ */
d203 1
a203 1
	NULL, "cl", DV_TTY, 0
@


1.32
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.31 2003/08/15 20:32:14 tedu Exp $ */
d1021 1
d1575 1
a1575 1
		log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %x\n",
d1923 1
d1982 1
a1982 1
	printf("rxcnt %x txcnt %x\n",
d1986 1
a1986 1
	printf("parbadru %x, parbadrl %x, parbcnt %x, parbsts %x\n",
@


1.31
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.30 2003/06/03 21:09:01 deraadt Exp $ */
a555 1
		tty_attach(tp);
@


1.30
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.29 2003/06/02 05:09:14 deraadt Exp $ */
d899 1
a899 1
		error = suser(p->p_ucred, &p->p_acflag); 
@


1.29
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.28 2002/06/12 03:49:54 miod Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.28
log
@cnputc() will take care of the necessary cr->cr/lf translation, so don't
do it in those consoles either.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.27 2002/06/11 05:13:39 miod Exp $ */
a5 1
 *   
@


1.27
log
@cnputc() routines are void, not int.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.26 2002/04/27 23:21:05 miod Exp $ */
a1082 4
	/* is this the correct location for the cr -> cr/lf tranlation? */
	if (c == '\n')
		clputc(0, 0, '\r');

@


1.26
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.25 2002/03/14 03:15:56 millert Exp $ */
d168 1
a168 1
int clcnputc(dev_t dev, u_char c);
d1078 1
a1078 1
int
a1087 1
	return 0;
@


1.25
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.24 2002/03/14 01:26:37 millert Exp $ */
a35 1
#include <sys/conf.h>
d43 1
d45 3
d49 1
a49 1
#include <machine/autoconf.h>
d51 1
d53 1
a53 1
#include <sys/syslog.h>
d66 1
a66 1
#define splcl() spl3()
d177 3
a179 3
int cl_mintr(struct clsoftc *sc);
int cl_txintr(struct clsoftc *sc);
int cl_rxintr(struct clsoftc *sc);
d190 5
a194 12
int clopen(dev_t dev, int flag, int mode, struct proc *p);
int clclose(dev_t dev, int flag, int mode, struct proc *p);
int clread(dev_t dev, struct uio *uio, int flag);
int clwrite(dev_t dev, struct uio *uio, int flag);
int clioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int clstop(struct tty *tp, int flag);

static void cl_initchannel(struct clsoftc *sc, int channel);
static void clputc(struct clsoftc *sc, int unit, u_char c);
static u_char clgetc(struct clsoftc *sc, int *channel);
static void cloutput(struct tty *tp);
void cl_softint(struct clsoftc *sc);
d197 7
d220 2
a221 3
extern int cputyp;

struct tty * cltty(dev)
d235 2
a236 1
int	clprobe(parent, self, aux)
d327 1
d329 1
a329 1
#if 0
d395 2
a396 1
static void
d538 2
a539 1
int clopen (dev, flag, mode, p)
d707 1
d745 1
d747 2
a748 1
int clclose (dev, flag, mode, p)
d790 3
a792 1
int clread (dev, uio, flag)
d795 1
a795 1
int flag;
d813 3
a815 1
int clwrite (dev, uio, flag)
d836 3
a838 1
int clioctl (dev, cmd, data, flag, p)
d840 1
a840 1
	int cmd;
d1020 4
a1023 1
	u_char val, reoir, licr, isrl, data, status, fifo_cnt;
d1090 2
d1103 2
a1104 1
static void
d1206 2
a1207 1
static u_char 
d1432 1
d1434 2
d1437 1
a1437 1
	int channel, unit, s, cnt;
d1484 2
a1485 2
cl_mintr(sc)
	struct clsoftc *sc;
d1487 1
d1540 2
a1541 2
cl_txintr(sc)
	struct clsoftc *sc;
d1543 2
a1544 1
	static empty = 0;
d1663 2
a1664 2
cl_rxintr(sc)
	struct clsoftc *sc;
d1666 1
a1667 1
	u_char c;
a1889 25
cl_dumpport0()
{
	cl_dumpport(0);
	return;
}
void
cl_dumpport1()
{
	cl_dumpport(1);
	return;
}
void
cl_dumpport2()
{
	cl_dumpport(2);
	return;
}
void
cl_dumpport3()
{
	cl_dumpport(3);
	return;
}

void
d2016 1
a2016 1
	int s;
d2040 1
a2040 1
	int s;
d2065 2
a2066 2
cl_softint(sc)
	struct clsoftc *sc;
d2068 1
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.23 2002/02/15 20:45:30 nordin Exp $ */
d196 1
a196 1
static void cloutput __P( (struct tty *tp));
@


1.23
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.22 2001/06/27 05:44:47 nate Exp $ */
d161 35
a195 35
int clcnprobe __P((struct consdev *cp));
int clcninit __P((struct consdev *cp));
int clcngetc __P((dev_t dev));
int clcnputc __P((dev_t dev, u_char c));
u_char cl_clkdiv __P((int speed));
u_char cl_clknum __P((int speed));
u_char cl_clkrxtimeout __P((int speed));
void clstart __P((struct tty *tp));
void cl_unblock __P((struct tty *tp));
int clccparam __P((struct clsoftc *sc, struct termios *par, int channel));

int clparam __P((struct tty *tp, struct termios *t));
int cl_mintr __P((struct clsoftc *sc));
int cl_txintr __P((struct clsoftc *sc));
int cl_rxintr __P((struct clsoftc *sc));
void cl_overflow __P((struct clsoftc *sc, int channel, time_t *ptime, u_char *msg));
void cl_parity __P((struct clsoftc *sc, int channel));
void cl_frame __P((struct clsoftc *sc, int channel));
void cl_break __P(( struct clsoftc *sc, int channel));
int clmctl __P((dev_t dev, int bits, int how));
void cl_dumpport __P((int channel));

int	clprobe __P((struct device *parent, void *self, void *aux));
void	clattach __P((struct device *parent, struct device *self, void *aux));

int clopen  __P((dev_t dev, int flag, int mode, struct proc *p));
int clclose __P((dev_t dev, int flag, int mode, struct proc *p));
int clread  __P((dev_t dev, struct uio *uio, int flag));
int clwrite __P((dev_t dev, struct uio *uio, int flag));
int clioctl __P((dev_t dev, int cmd, caddr_t data, int flag, struct proc *p));
int clstop  __P((struct tty *tp, int flag));

static void cl_initchannel __P((struct clsoftc *sc, int channel));
static void clputc __P((struct clsoftc *sc, int unit, u_char c));
static u_char clgetc __P((struct clsoftc *sc, int *channel));
d197 2
a198 2
void cl_softint __P((struct clsoftc *sc));
void cl_appendbufn __P((struct clsoftc *sc, u_char channel, u_char *buf, u_short cnt));
@


1.22
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.21 2000/07/06 12:54:55 art Exp $ */
d514 1
a514 1
	(void)splx(s);
@


1.22.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.22 2001/06/27 05:44:47 nate Exp $ */
d36 1
a43 1
#include <sys/syslog.h>
d45 1
a45 1

a46 3
#include <machine/conf.h>
#include <machine/cpu.h>

a47 1

d49 1
a49 1

d62 1
a62 1
#define splcl() spltty()
d161 38
a198 38
int clcnprobe(struct consdev *cp);
int clcninit(struct consdev *cp);
int clcngetc(dev_t dev);
int clcnputc(dev_t dev, u_char c);
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct clsoftc *sc, struct termios *par, int channel);

int clparam(struct tty *tp, struct termios *t);
int cl_mintr(void *);
int cl_txintr(void *);
int cl_rxintr(void *);
void cl_overflow(struct clsoftc *sc, int channel, time_t *ptime, u_char *msg);
void cl_parity(struct clsoftc *sc, int channel);
void cl_frame(struct clsoftc *sc, int channel);
void cl_break( struct clsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
void cl_dumpport(int channel);

int	clprobe(struct device *parent, void *self, void *aux);
void	clattach(struct device *parent, struct device *self, void *aux);

void cl_initchannel(struct clsoftc *sc, int channel);
void clputc(struct clsoftc *sc, int unit, u_char c);
u_char clgetc(struct clsoftc *sc, int *channel);
void cloutput(struct tty *tp);
void cl_softint(void *);
void cl_appendbufn(struct clsoftc *sc, u_char channel, u_char *buf, u_short cnt);

struct tty *cltty(dev_t);
int cl_instat(struct clsoftc *);
void clcnpollc(dev_t, int);
void cl_chkinput(void);
void cl_break(struct clsoftc *, int);
void cl_appendbuf(struct clsoftc *, u_char, u_char);
d216 3
a218 2
struct tty *
cltty(dev)
d232 1
a232 2
int
clprobe(parent, self, aux)
d323 1
a324 2
		int j;

d390 1
a390 2

void
d514 1
a514 1
	splx(s);
d532 1
a532 2
int
clopen(dev, flag, mode, p)
a699 1
#if 0
a736 1
#endif
d738 1
a738 2
int
clclose(dev, flag, mode, p)
d780 1
a780 3

int
clread (dev, uio, flag)
d783 1
a783 1
	int flag;
d801 1
a801 3

int
clwrite (dev, uio, flag)
d822 1
a822 3

int
clioctl(dev, cmd, data, flag, p)
d824 1
a824 1
	u_long cmd;
d1004 1
a1004 4
	u_char val, reoir, licr, isrl, data, fifo_cnt;
#if 0
	u_char status;
#endif
a1070 2

void
d1082 1
a1082 2

void
d1184 1
a1184 2

u_char 
a1408 1
#if 0
a1409 2
	int cnt;
#endif
d1411 1
a1411 1
	int channel, unit, s;
d1458 2
a1459 2
cl_mintr(arg)
	void *arg;
a1460 1
	struct clsoftc *sc = (struct clsoftc *)arg;
d1513 2
a1514 2
cl_txintr(arg)
	void *arg;
d1516 1
a1516 2
	struct clsoftc *sc = (struct clsoftc *)arg;
	static int empty = 0;
d1635 2
a1636 2
cl_rxintr(arg)
	void *arg;
a1637 1
	struct clsoftc *sc = (struct clsoftc *)arg;
d1639 1
d1862 25
d2013 1
a2013 1
	/* int s; */
d2037 1
a2037 1
	/* int s; */
d2062 2
a2063 2
cl_softint(arg)
	void *arg;
a2064 1
	struct clsoftc *sc = (struct clsoftc *)arg;
@


1.22.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.22.4.1 2002/06/11 03:36:49 art Exp $ */
d168 1
a168 1
void clcnputc(dev_t dev, u_char c);
d1078 1
a1078 1
void
d1083 4
d1088 1
@


1.21
log
@Make the handling of going into ddb from the console more like the
other architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.20 2000/03/26 23:31:58 deraadt Exp $ */
d1250 1
a1250 1
			/* disconnect, drop RTS DTR stop reciever */
@


1.20
log
@callout.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.19 2000/01/25 21:02:32 deraadt Exp $ */
d52 4
a1644 1
#ifdef CONSOLEBREAKDDB
a1645 1
#endif
a1677 1
#ifdef CONSOLEBREAKDDB
a1679 1
#endif
d1804 2
a1805 2
#ifdef CONSOLEBREAKDDB
	if (wantddb)
@


1.19
log
@fix dmesg print
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.18 2000/01/06 03:21:42 smurph Exp $ */
a35 1
#include <sys/callout.h>
@


1.19.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.21 2000/07/06 12:54:55 art Exp $ */
d36 1
a52 4
#ifdef DDB
#include <ddb/db_var.h>
#endif

d1642 1
d1644 1
d1677 1
d1680 1
d1805 2
a1806 2
#ifdef DDB
	if (wantddb && db_console)
@


1.19.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.19.2.1 2001/04/18 16:10:21 niklas Exp $ */
d1250 1
a1250 1
			/* disconnect, drop RTS DTR stop receiver */
@


1.19.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d514 1
a514 1
	splx(s);
@


1.19.2.4
log
@Merge in -current from about a week ago
@
text
@d161 10
a170 10
int clcnprobe(struct consdev *cp);
int clcninit(struct consdev *cp);
int clcngetc(dev_t dev);
int clcnputc(dev_t dev, u_char c);
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct clsoftc *sc, struct termios *par, int channel);
d172 10
a181 10
int clparam(struct tty *tp, struct termios *t);
int cl_mintr(struct clsoftc *sc);
int cl_txintr(struct clsoftc *sc);
int cl_rxintr(struct clsoftc *sc);
void cl_overflow(struct clsoftc *sc, int channel, time_t *ptime, u_char *msg);
void cl_parity(struct clsoftc *sc, int channel);
void cl_frame(struct clsoftc *sc, int channel);
void cl_break( struct clsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
void cl_dumpport(int channel);
d183 2
a184 2
int	clprobe(struct device *parent, void *self, void *aux);
void	clattach(struct device *parent, struct device *self, void *aux);
d186 6
a191 6
int clopen(dev_t dev, int flag, int mode, struct proc *p);
int clclose(dev_t dev, int flag, int mode, struct proc *p);
int clread(dev_t dev, struct uio *uio, int flag);
int clwrite(dev_t dev, struct uio *uio, int flag);
int clioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int clstop(struct tty *tp, int flag);
d193 6
a198 6
static void cl_initchannel(struct clsoftc *sc, int channel);
static void clputc(struct clsoftc *sc, int unit, u_char c);
static u_char clgetc(struct clsoftc *sc, int *channel);
static void cloutput(struct tty *tp);
void cl_softint(struct clsoftc *sc);
void cl_appendbufn(struct clsoftc *sc, u_char channel, u_char *buf, u_short cnt);
@


1.19.2.5
log
@Sync the SMP branch with 3.3
@
text
@d36 1
a43 1
#include <sys/syslog.h>
d45 1
a45 1

a46 3
#include <machine/conf.h>
#include <machine/cpu.h>

a47 1

d49 1
a49 1

d62 1
a62 1
#define splcl() spltty()
d164 1
a164 1
void clcnputc(dev_t dev, u_char c);
d173 3
a175 3
int cl_mintr(void *);
int cl_txintr(void *);
int cl_rxintr(void *);
d186 12
a197 5
void cl_initchannel(struct clsoftc *sc, int channel);
void clputc(struct clsoftc *sc, int unit, u_char c);
u_char clgetc(struct clsoftc *sc, int *channel);
void cloutput(struct tty *tp);
void cl_softint(void *);
a199 7
struct tty *cltty(dev_t);
int cl_instat(struct clsoftc *);
void clcnpollc(dev_t, int);
void cl_chkinput(void);
void cl_break(struct clsoftc *, int);
void cl_appendbuf(struct clsoftc *, u_char, u_char);

d216 3
a218 2
struct tty *
cltty(dev)
d232 1
a232 2
int
clprobe(parent, self, aux)
d323 1
a324 2
		int j;

d390 1
a390 2

void
d532 1
a532 2
int
clopen(dev, flag, mode, p)
a699 1
#if 0
a736 1
#endif
d738 1
a738 2
int
clclose(dev, flag, mode, p)
d780 1
a780 3

int
clread (dev, uio, flag)
d783 1
a783 1
	int flag;
d801 1
a801 3

int
clwrite (dev, uio, flag)
d822 1
a822 3

int
clioctl(dev, cmd, data, flag, p)
d824 1
a824 1
	u_long cmd;
d1004 1
a1004 4
	u_char val, reoir, licr, isrl, data, fifo_cnt;
#if 0
	u_char status;
#endif
d1059 1
a1059 1
void
d1064 4
d1069 1
a1070 2

void
d1082 1
a1082 2

void
d1184 1
a1184 2

u_char 
a1408 1
#if 0
a1409 2
	int cnt;
#endif
d1411 1
a1411 1
	int channel, unit, s;
d1458 2
a1459 2
cl_mintr(arg)
	void *arg;
a1460 1
	struct clsoftc *sc = (struct clsoftc *)arg;
d1513 2
a1514 2
cl_txintr(arg)
	void *arg;
d1516 1
a1516 2
	struct clsoftc *sc = (struct clsoftc *)arg;
	static int empty = 0;
d1635 2
a1636 2
cl_rxintr(arg)
	void *arg;
a1637 1
	struct clsoftc *sc = (struct clsoftc *)arg;
d1639 1
d1862 25
d2013 1
a2013 1
	/* int s; */
d2037 1
a2037 1
	/* int s; */
d2062 2
a2063 2
cl_softint(arg)
	void *arg;
a2064 1
	struct clsoftc *sc = (struct clsoftc *)arg;
@


1.19.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.19.2.5 2003/03/27 23:32:16 niklas Exp $ */
d6 1
d15 5
@


1.19.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d203 1
a203 1
	NULL, "cl", DV_TTY
d556 1
d899 1
a899 1
		error = suser(p, 0); 
a1021 1

d1575 1
a1575 1
		log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %p\n",
a1922 1
	rir = cl_reg->cl_rir;
d1981 1
a1981 1
	printf("rxcnt %lx txcnt %lx\n",
d1985 1
a1985 1
	printf("parbadru %p, parbadrl %p, parbcnt %p, parbsts %p\n",
@


1.18
log
@Added support for MVME177 (mc68060)
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.17 1999/10/04 04:23:41 smurph Exp $ */
d272 1
a272 1
		printf(" console");
@


1.17
log
@Fixed garbled dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.16 1997/07/27 08:16:35 deraadt Exp $ */
d234 1
a234 1
	/* probing onboard 166/167/187 CL-cd2400
d241 1
a241 5
	if (cputyp != CPU_167 && cputyp != CPU_166
#ifdef CPU_187
		&& cputyp != CPU_187
#endif
		)
d245 1
a245 1
	cl_reg = (struct clreg *)ca->ca_vaddr;
@


1.16
log
@time_t is not long
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.15 1997/04/02 05:25:45 rahnds Exp $ */
d275 1
a275 1
		sc->sc_cl[cl_cons.channel].cl_consio = 1;
d282 1
a282 1
        delay(50);
@


1.15
log
@add off-level character recieve.
improve transmission when CTS goes low (like on a modem)
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.14 1996/06/11 10:17:34 deraadt Exp $ */
d173 1
a173 1
void cl_overflow __P((struct clsoftc *sc, int channel, long *ptime, u_char *msg));
d1820 1
a1820 1
long *ptime;
@


1.14
log
@tty_attach()
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.13 1996/06/11 10:15:05 deraadt Exp $ */
d60 1
d101 5
d131 1
d194 2
d281 3
d313 10
d335 1
d346 3
a1463 1
	struct tty *tp;
d1483 2
d1488 4
d1495 1
d1499 1
d1503 1
d1507 1
d1715 3
a1717 2
#if USE_BUFFER
			cl_appendbufn(sc, channel, sc->rx[nbuf], cnt);
d1789 3
a1794 3
#if USE_BUFFER
		cl_appendbuf(sc, channel, c);
#else
d1800 1
a1801 1
		}
d1840 1
d1842 1
d1850 1
d1852 1
d1860 1
d1862 1
d2011 82
@


1.13
log
@use void * for pa/va instead of caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d530 1
@


1.12
log
@Add some code bulletproofing, I have had this around for some time
I actually thought it was checked in.

This should stop any extra transmit interupts occuring and a possible
crash if another system talks to the tty port before it is completely
configured.

Also allows debugging when no processes have the port open for writing.
If abort is pressed before getty starts.
@
text
@d75 1
a75 1
	u_char *cl_paddr;
d240 1
a240 1
	cl_reg = ca->ca_vaddr;
d260 1
a260 1
	sc->cl_reg = ca->ca_vaddr;
@


1.11
log
@delete impossible to reach code, use more defined constants
@
text
@d980 1
d983 5
d1018 3
d1503 1
d1741 8
@


1.10
log
@cfattach/cfdriver split
@
text
@d354 3
a356 3
		sc->sc_pcctwo->pcc2_sccirq = 0x10 | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_scctx  = 0x10 | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_sccrx  = 0x10 | (ca->ca_ipl & 0x7);
a357 3
	default:	
		/* oops */
		panic ("cl driver on unknown bus\n");
@


1.9
log
@Two changes are made in this checkin.
The first is a change to force the console to stay 8N1, the configuration
of the bug/prom during the first open to the device by init.

The second is to not enable interupts until the port is opened. Previously
receive and CD change interrutps were enabled at config time. If a
character arrived before the port was opened for the first time, it
would crash the system.
@
text
@d1 1
a1 1
/*	$Id: cl.c,v 1.14 1995/12/15 22:32:51 drahn Exp drahn $ */
d188 6
a193 2
struct cfdriver clcd = {
	NULL, "cl", clprobe, clattach, DV_TTY, sizeof(struct clsoftc), 0
d212 2
a213 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d426 1
a426 1
	sc = (struct clsoftc *) clcd.cd_devs[CL_UNIT(dev)];
d522 2
a523 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d662 2
a663 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d689 2
a690 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d727 2
a728 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d767 2
a768 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d788 2
a789 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d812 2
a813 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d1125 3
a1127 3
	for (unit = 0; unit < clcd.cd_ndevs; unit++) {
		if (unit >= clcd.cd_ndevs || 
			(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d1391 2
a1392 2
	if (unit >= clcd.cd_ndevs || 
		(sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d1778 1
a1778 1
		log(LOG_WARNING, "%s%d[%d]: %s overrun\n", clcd.cd_name,
d1788 1
a1788 1
	log(LOG_WARNING, "%s%d[%d]: parity error\n", clcd.cd_name, 0, channel);
d1796 1
a1796 1
	log(LOG_WARNING, "%s%d[%d]: frame error\n", clcd.cd_name, 0, channel);
d1804 1
a1804 1
	log(LOG_WARNING, "%s%d[%d]: break detected\n", clcd.cd_name, 0, channel);
d1854 1
a1854 1
	sc = (struct clsoftc *) clcd.cd_devs[0];
@


1.8
log
@we cannot jump into ddb until the interrupt has been acknowledged to the
chip. set a flag and defer calling ddb till end of interrupt routine.
@
text
@d1 1
a1 1
/*	$Id: cl.c,v 1.7 1995/12/01 19:26:41 deraadt Exp $ */
a374 1
	/* async, do we want to try DMA at some point? */
d376 2
a377 2
	cl_reg->cl_ier	= 0x88;  /* should change XXX */
	/* if the port is not the console */
a403 9
	if (channel == 2) { /* test one channel now */
		/* shift for tx DMA */
		/* no shift for rx DMA */
	/* async only */
	/* rx only (tx commented out) */
		cl_reg->cl_cmr	= /* CL_TXDMAINT | */ CL_RXDMAINT; 
		cl_reg->cl_ier	= 0xa8; 
		cl_reg->cl_licr	= 0x00;
	}
a542 1
			tp->t_cflag = TTYDEF_CFLAG;
d545 7
a574 1
#ifdef CL_DMA_WORKS
d578 8
d621 1
a623 1
#endif /* CL_DMA_WORKS */
@


1.7
log
@previous verbosity patch was wrong
@
text
@d1 1
a1 1
/*	$Id: cl.c,v 1.6 1995/12/01 19:10:47 deraadt Exp $ */
d1596 3
d1631 4
d1750 4
a1796 4
#ifdef CONSOLEBREAKDDB
	if (sc->sc_cl[channel].cl_consio)
		Debugger();
#endif
@


1.6
log
@add CONSOLEBREAKDDB support. also be less verbose at boot..
@
text
@d1 1
a1 1
/*	$Id: cl.c,v 1.5 1995/12/01 18:13:15 deraadt Exp $ */
a296 1
#if 0
d299 1
d301 6
a306 6
		sc->sc_cl[i].rxp[j] = (void *)kvtop(sc->sc_cl[i].rx[j]);
printf("cl[%d].rxbuf[%d] %x p %x\n",
	i, j, sc->sc_cl[i].rx[j], sc->sc_cl[i].rxp[j]);
		sc->sc_cl[i].txp[j] = (void *)kvtop(sc->sc_cl[i].tx[j]);
printf("cl[%d].txbuf[%d] %x p %x\n",
	i, j, sc->sc_cl[i].tx[j], sc->sc_cl[i].txp[j]);
d308 1
a318 1
#endif
@


1.5
log
@fixed ddb, improved fifo handling, new still-not-working dma support
from drahn@@pacific.urbana.mcd.mot.com
@
text
@d1 1
a1 1
/*	$Id$ */
d297 1
d318 1
d1786 4
@


1.4
log
@in clcninit: we need to use IIOV to convert the physical address of
the console to a virtual address.   otherwise we can not print anything
because our register pointer is wrong (this is on the 167).
@
text
@d1 1
a1 1
/*	$Id: cl.c,v 1.3 1995/11/07 08:48:52 deraadt Exp $ */
d33 2
d67 6
a72 2
#define CL_DMAMODE	0x1
#define CL_INTRMODE	0x0
d76 1
a76 1
	volatile struct clreg *cl_vaddr;
d95 5
d102 7
d117 1
a117 1
	volatile struct clreg *cl_reg;
d154 1
a154 1
int clcnputc __P((dev_t dev, char c));
d166 1
a166 1
void cl_overflow __P((struct clsoftc *sc, int channel, long *ptime, char *msg));
d184 1
a184 1
static void clputc __P((struct clsoftc *sc, int unit, char c));
d225 1
a225 1
	volatile struct clreg *cl_reg;
d274 23
d298 9
d368 1
a368 1
	volatile struct clreg *cl_reg = sc->cl_reg;
d372 1
a372 1
	cl_reg->cl_car	= (char) channel;
a375 1
	cl_reg->cl_licr	= 0x00;  /* will change if DMA support XXX */
d403 12
d577 42
d672 1
a672 1
	char *tptr;
d676 1
a676 1
	char cl_obuffer[CLCDBUF+1];
d913 1
a913 1
	volatile struct clreg *cl_reg;
d960 1
a960 1
	volatile struct clreg *cl_reg;
d974 1
a974 1
	volatile struct clreg *cl_reg = cl_cons.cl_vaddr;
d1021 1
a1021 1
	char c;
d1045 1
a1045 1
	char c;
d1050 1
a1050 1
	volatile struct clreg *cl_reg;
d1148 1
a1148 1
	volatile struct clreg *cl_reg;
d1251 8
a1258 3
	if (par->c_cflag & PARENB) {
		if (par->c_cflag & PARODD) {
			sc->cl_reg->cl_cor1 = 0xE0 | clen ; /* odd */
d1260 7
a1266 1
			sc->cl_reg->cl_cor1 = 0x40 | clen ; /* even */
a1267 2
	} else {
		sc->cl_reg->cl_cor1 = 0x10 | clen; /* ignore parity */
d1277 2
d1425 1
a1425 1
		printf("cl_mintr extra intr\n");
d1435 1
a1435 1
		printf ("cl_mintr: channel %x timer 1 unexpected\n",channel);
d1439 1
a1439 1
		printf ("cl_mintr: channel %x timer 2 unexpected\n",channel);
d1442 1
a1442 1
		printf ("cl_mintr: channel %x cts %x\n",channel, 
d1448 1
a1448 1
		printf ("cl_mintr: channel %x cd %x\n",channel,
d1454 1
a1454 1
		printf ("cl_mintr: channel %x dsr %x\n",channel,
d1467 1
a1467 1
	u_char tir, licr, teoir;
d1476 1
a1476 1
		printf ("cl_txintr extra intr\n");
d1482 1
a1482 1
	licr	= sc->cl_reg->cl_licr;
d1491 54
a1544 3
	switch ((licr >> 4)& 0x3) {
	case CL_DMAMODE:
		teoir = 0x08;
d1546 1
a1546 1
	case CL_INTRMODE:
d1558 1
a1558 1
			printf("cl_txintr to many empty intr %d channel %d\n",
d1575 1
a1575 1
		printf("cl_txintr unknown mode %x\n", ((licr >> 4) & 0x3));
d1587 1
a1587 1
	u_char rir, channel, licr, risrl;
d1593 1
d1598 1
a1598 1
		printf ("cl_rxintr extra intr\n");
d1603 1
a1603 1
	licr = sc->cl_reg->cl_licr;
d1607 22
d1630 82
a1711 3
	switch (licr & 0x03) {
	case CL_DMAMODE:
		reoir = 0x08;
d1713 11
a1723 27
	case CL_INTRMODE:
		risrl = sc->cl_reg->cl_risrl;
		if (risrl & 0x80) {
			/* timeout, no characters */
			reoir = 0x08;
		} else
		/* We don't need no sinkin special characters */
		if (risrl & 0x08) {
			cl_overflow (sc, channel, &sc->sc_fotime, "fifo");
			reoir = 0x08;
		} else
		if (risrl & 0x04) {
			cl_parity(sc, channel);
			reoir = 0x08;
		} else
		if (risrl & 0x02) {
			cl_frame(sc, channel);
			reoir = 0x08;
		} else
		if (risrl & 0x01) {
			cl_break(sc, channel);
			reoir = 0x08;
		} else {
			fifocnt = sc->cl_reg->cl_rfoc;
			tp = sc->sc_cl[channel].tty;
			for (i = 0; i < fifocnt; i++) {
				c = sc->cl_reg->cl_rdr;
d1725 1
a1725 1
				cl_appendbuf(sc, channel, c);
d1727 5
a1731 5
				/* does any restricitions exist on spl
				 * for this call
				 */
				(*linesw[tp->t_line].l_rint)(c,tp);
				reoir = 0x00;
a1732 1
			}
d1736 1
a1736 1
		printf("cl_rxintr unknown mode %x\n",licr & 0x03);
d1739 1
a1740 1
	sc->cl_reg->cl_reoir = reoir;
d1749 1
a1749 1
char *msg;
d1758 1
a1758 1
		log(LOG_WARNING, "%s%d[%d]: %s overrun", clcd.cd_name,
d1768 1
a1768 1
	log(LOG_WARNING, "%s%d[%d]: parity error", clcd.cd_name, 0, channel);
d1776 1
a1776 1
	log(LOG_WARNING, "%s%d[%d]: frame error", clcd.cd_name, 0, channel);
d1784 1
a1784 1
	log(LOG_WARNING, "%s%d[%d]: break detected", clcd.cd_name, 0, channel);
d1820 1
d1822 5
d1829 1
a1829 1
	volatile struct clreg *cl_reg;
d1837 1
a1837 1
	cl_reg->cl_car	= (char) channel;
d1867 31
d1918 12
@


1.3
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d817 2
a818 2
	cl_cons.cl_vaddr   = (struct clreg *)cl_cons.cl_paddr;
	cl_cons.pcctwoaddr = (void *)0xfff42000;
@


1.2
log
@fixes from dale
@
text
@d1 2
a2 1
/* $NetBSD$ */
d17 1
a17 1
 *   This product includes software developed by Dale Rahn.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/*	$NetBSD$	*/

d4 1
d46 1
a46 1
#include <mvme68k/dev/cd2400reg.h>
d56 2
d69 1
a69 1
	volatile u_char *cl_vaddr;
a88 1

d97 2
a98 1
	volatile u_char *vbase;
a106 1

d162 1
a162 1
int clstop __P((struct tty *tp, int flag));
d167 1
a167 1
static void cloutput __P((struct tty *tp));
a173 2
char cltty_ibuffer[CLCDBUF+1];
char cl_obuffer[CLCDBUF+1];
d183 1
a183 2
struct tty *
cltty(dev)
a187 1

d190 1
a190 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d194 1
a194 1
	return (sc->sc_cl[channel].tty);
d197 1
a197 7
/*
 * probing onboard 166/167/187 CL-cd2400
 * should be previously configured, 
 * we can check the value before resetting the chip
 */
int
clprobe(parent, self, aux)
d202 5
a206 2
	volatile u_char *cd_base;
	struct cfdata *cf = self;
d209 9
a218 4
	if (cputyp != CPU_167 && cputyp != CPU_166)
		return (0);

	cd_base = ca->ca_vaddr;
d220 3
a222 1
	return (!badvaddr(&cd_base[CD2400_GFRCR], 1));
d224 1
a224 1
	return (ret);
a235 3
#if 0
	int size = (CD2400_SIZE + PGOFSET) & ~PGOFSET;
#endif
d237 1
a237 1
	sc->vbase = ca->ca_vaddr;
d250 4
a253 4
	sc->vbase[CD2400_TPR] = CL_TIMEOUT;
	sc->vbase[CD2400_RPILR] = 0x03;
	sc->vbase[CD2400_TPILR] = 0x02;
	sc->vbase[CD2400_MPILR] = 0x01;
d258 1
a258 1
		    !(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x01));
d260 1
a260 1
		    !(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x02));
d262 1
a262 1
		    !(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x04));
d289 4
a292 4
		pcctwointr_establish(PCC2V_SCC_RXE, &sc->sc_ih_e);
		pcctwointr_establish(PCC2V_SCC_M, &sc->sc_ih_m);
		pcctwointr_establish(PCC2V_SCC_TX, &sc->sc_ih_t);
		pcctwointr_establish(PCC2V_SCC_RX, &sc->sc_ih_r);
d297 7
a303 4
		sc->sc_pcctwo->pcc2_sccirq = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_scctx = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_sccrx = PCC2_IRQ_IEN | (ca->ca_ipl & 0x7);
		break;
a310 1

d317 1
a317 2
	volatile u_char *cd_base = sc->vbase;

d321 1
a321 1
	cd_base[CD2400_CAR] = (char)channel;
d323 3
a325 3
	cd_base[CD2400_LIVR] = PCC2_VECBASE + 0xc;/* set vector base at 5C */
	cd_base[CD2400_IER] = 0x88;	/* should change XXX */
	cd_base[CD2400_LICR] = 0x00;	/* will change if DMA support XXX */
d328 19
a346 19
		cd_base[CD2400_CMR] = 0x02; 
		cd_base[CD2400_COR1] = 0x17;
		cd_base[CD2400_COR2] = 0x00;
		cd_base[CD2400_COR3] = 0x02;
		cd_base[CD2400_COR4] = 0xec;
		cd_base[CD2400_COR5] = 0xec;
		cd_base[CD2400_COR6] = 0x00;
		cd_base[CD2400_COR7] = 0x00;
		cd_base[CD2400_SCHR1] = 0x00;
		cd_base[CD2400_SCHR2] = 0x00;
		cd_base[CD2400_SCHR3] = 0x00;
		cd_base[CD2400_SCHR4] = 0x00;
		cd_base[CD2400_SCRl] = 0x00;
		cd_base[CD2400_SCRh] = 0x00;
		cd_base[CD2400_LNXT] = 0x00;
		cd_base[CD2400_RBPR] = 0x40; /* 9600 */
		cd_base[CD2400_RCOR] = 0x01;
		cd_base[CD2400_TBPR] = 0x40; /* 9600 */
		cd_base[CD2400_TCOR] = 0x01 << 5;
d348 4
a351 4
		cd_base[CD2400_MSVR_RTS] = 0x00;
		cd_base[CD2400_MSVR_DTR] = 0x00;
		cd_base[CD2400_RTPRl] = CL_RX_TIMEOUT;
		cd_base[CD2400_RTPRh] = 0x00;
d353 1
d357 1
d360 1
a360 1
int clmctl(dev, bits, how)
a364 1
	struct clsoftc *sc = (struct clsoftc *)clcd.cd_devs[CL_UNIT(dev)];
d366 6
a371 1

d373 1
a373 1
	s = spltty();
d376 2
a377 2
		if (bits & TIOCM_RTS) {
			sc->vbase[CD2400_MSVR_RTS] = 0x01;
d379 1
a379 1
			sc->vbase[CD2400_MSVR_RTS] = 0x00;
d381 2
a382 2
		if (bits & TIOCM_DTR) {
			sc->vbase[CD2400_MSVR_DTR] = 0x02;
d384 1
a384 1
			sc->vbase[CD2400_MSVR_DTR] = 0x00;
d389 2
a390 2
		if (bits & TIOCM_RTS) {
			sc->vbase[CD2400_MSVR_RTS] = 0x00;
d392 2
a393 2
		if (bits & TIOCM_DTR) {
			sc->vbase[CD2400_MSVR_DTR] = 0x00;
d398 2
a399 2
		if (bits & TIOCM_RTS) {
			sc->vbase[CD2400_MSVR_RTS] = 0x01;
d401 2
a402 2
		if (bits & TIOCM_DTR) {
			sc->vbase[CD2400_MSVR_DTR] = 0x02;
d408 1
d410 3
a412 3
			u_char msvr = sc->vbase[CD2400_MSVR_RTS];

			if (msvr & 0x80)
d414 2
a415 1
			if (msvr & 0x40)
d417 2
a418 1
			if (msvr & 0x20)
d420 2
a421 1
			if (msvr & 0x10)
d423 2
a424 1
			if (msvr & 0x02)
d426 2
a427 1
			if (msvr & 0x01)
d429 2
d449 1
a449 1
	return (bits);
d452 1
a452 2
int
clopen(dev, flag, mode, p)
d465 1
a465 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d470 1
a470 1
	s = spltty();
d517 1
a517 1
		return (EBUSY);
d524 1
a524 1
		goto done;
d536 1
a536 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d538 1
a538 3

int
clparam(tp, t)
d550 1
a550 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
a556 5
/*
	t->c_ispeed = tp->t_ispeed;
	t->c_ospeed = tp->t_ospeed;
	t->c_cflag = tp->t_cflag;
*/
d558 1
a558 1
	s = spltty();
d561 1
a561 1
	return (0);
d564 1
a564 2
void
cloutput(tp)
d572 1
d577 1
a577 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d585 1
a585 1
	s = spltty();
d589 1
a589 1
		cnt = min(CLCDBUF, cc);
d602 1
a602 2
int
clclose(dev, flag, mode, p)
d615 1
a615 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d623 7
a629 6
	s = spltty();
	sc->vbase[CD2400_CAR] = channel;
	if (cl->cl_consio == 0 && (tp->t_cflag & HUPCL) != 0) {
		sc->vbase[CD2400_MSVR_RTS] = 0x00;
		sc->vbase[CD2400_MSVR_DTR] = 0x00;
		sc->vbase[CD2400_CCR] = 0x05;
d638 1
a638 1
#if 0
d641 2
a642 1
	return (0);
d644 1
a644 3

int
clread(dev, uio, flag)
d647 1
a647 1
	int flag;
a652 1

d655 1
a655 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d662 2
a663 2
		return (ENXIO);
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d665 1
a665 3

int
clwrite(dev, uio, flag)
a673 1

d676 1
a676 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d683 2
a684 2
		return (ENXIO);
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d686 1
a686 3

int
clioctl(dev, cmd, data, flag, p)
a697 1

d700 1
a700 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d707 1
a707 1
		return (ENXIO);
d711 1
a711 1
		return (error);
d715 1
a715 1
		return (error);
d755 1
a755 1
			return (EPERM); 
d762 1
a762 1
		return (ENOTTY);
d765 1
a765 1
	return (0);
a766 1

d774 1
a774 1
	s = spltty();
d780 1
a780 1
	return (0);
d798 1
a798 1
	return (1);
d803 1
a803 1
	struct consdev *cp;
d809 1
a809 1
	volatile u_char *cd_base;
d813 2
a814 2
	cl_cons.cl_vaddr = mapiodev(cl_cons.cl_paddr, size);
	cd_pcc2_base = mapiodev(0xfff42000, pcc2_size);
d816 1
a816 1
	cl_cons.cl_vaddr = cl_cons.cl_paddr;
d819 1
a819 1
	cd_base = cl_cons.cl_vaddr;
a822 26
#ifdef NEW_CLCD_STRUCT
	/* set up globals */
	cl->tftc = 0x10;
	cl->tpr = CL_TIMEOUT; /* is this correct?? */
	cl->rpilr = 0x03;
	cl->tpilr = 0x02;
	cl->mpilr = 0x01;

	/* set up the tty00 to be 9600 8N1 */
	cl->car = 0x00;
	cl->cor1 = 0x17;	/* No parity, ignore parity, 8 bit char */
	cl->cor2 = 0x00;
	cl->cor3 = 0x02;	/* 1 stop bit */
	cl->cor4 = 0x00;
	cl->cor5 = 0x00;
	cl->cor6 = 0x00;
	cl->cor7 = 0x00;
	cl->schr1 = 0x00;
	cl->schr2 = 0x00;
	cl->schr3 = 0x00;
	cl->schr4 = 0x00;
	cl->scrl = 0x00;
	cl->scrh = 0x00;
	cl->lnxt = 0x00;
	cl->cpsr = 0x00;
#else
d825 5
a829 5
	cd_base[CD2400_TFTC] = 0x10;
	cd_base[CD2400_TPR] = CL_TIMEOUT; /* is this correct?? */
	cd_base[CD2400_RPILR] = 0x03;
	cd_base[CD2400_TPILR] = 0x02;
	cd_base[CD2400_MPILR] = 0x01;
d832 16
a847 16
	cd_base[CD2400_CAR] = 0x00;
	cd_base[CD2400_COR1] = 0x17;	/* No parity, ignore parity, 8 bit char */
	cd_base[CD2400_COR2] = 0x00;
	cd_base[CD2400_COR3] = 0x02;	/* 1 stop bit */
	cd_base[CD2400_COR4] = 0x00;
	cd_base[CD2400_COR5] = 0x00;
	cd_base[CD2400_COR6] = 0x00;
	cd_base[CD2400_COR7] = 0x00;
	cd_base[CD2400_SCHR1] = 0x00;
	cd_base[CD2400_SCHR2] = 0x00;
	cd_base[CD2400_SCHR3] = 0x00;
	cd_base[CD2400_SCHR4] = 0x00;
	cd_base[CD2400_SCRl] = 0x00;
	cd_base[CD2400_SCRh] = 0x00;
	cd_base[CD2400_LNXT] = 0x00;
	cd_base[CD2400_CPSR] = 0x00;
d849 1
a849 2
#endif
	return (0);
d856 1
a856 2
	volatile u_char *cd_base;

d858 1
a858 1
		cd_base = cl_cons.cl_vaddr;
d860 1
a860 1
		cd_base = sc->vbase;
d862 1
a862 1
	return (cd_base[CD2400_RIR] & 0x80);
a863 1

d870 1
a870 1
	volatile u_char *cd_base = cl_cons.cl_vaddr;
a871 1

d873 1
a873 1
		val = cd_base[CD2400_RIR];
d880 1
a880 1
		licr = cd_base[CD2400_LICR];
d883 2
a884 2
			/* the character is for us. */
			isrl = cd_base[CD2400_RISRl];
d900 2
a901 2
			fifo_cnt = cd_base[CD2400_RFOC];
			data = cd_base[CD2400_RDR];
d903 1
a903 1
			cd_base[CD2400_TEOIR] = 0x00;
d905 2
a906 2
			data = cd_base[CD2400_RDR];
			cd_base[CD2400_TEOIR] = 0x00;
d910 2
a911 1
	return (data);
d924 1
a924 1
	return (0);
a925 1

d935 1
a936 1

d946 1
a946 1
	volatile u_char *cd_base;
d949 1
a949 1
		cd_base = cl_cons.cl_vaddr;
d951 1
a951 1
		cd_base = sc->vbase;
d969 6
a974 6
	oldchannel = cd_base[CD2400_CAR];
	cd_base[CD2400_CAR] = unit;
	schar = cd_base[CD2400_SCHR3];
	cd_base[CD2400_SCHR3] = c;
	cd_base[CD2400_STCR] = 0x08 | 0x03; /* send special char, char 3 */
	while (0 != cd_base[CD2400_STCR]) {
d981 2
a982 2
	cd_base[CD2400_SCHR3] = schar;
	cd_base[CD2400_CAR] = oldchannel;
d986 4
a989 4
	oldchannel = cd_base[CD2400_CAR];
	cd_base[CD2400_CAR] = unit;
	if (cd_base[CD2400_TFTC] > 0) {
		cd_base[CD2400_TDR] = c;
d991 1
a991 1
	cd_base[CD2400_CAR] = oldchannel;
d995 1
d1024 1
a1024 1
				ch = clgetc(sc, &channel) & 0xff;
d1029 1
a1029 1
					(*linesw[tp->t_line].l_rint)(c, tp);
a1038 1

d1044 1
a1044 1
	volatile u_char *cd_base;
a1046 1

d1048 1
a1048 1
		cd_base = cl_cons.cl_vaddr;
d1051 1
a1051 1
		cd_base = sc->vbase;
d1054 1
a1054 1
	val = cd_base[CD2400_RIR];
d1057 1
a1057 1
		return (0);
d1061 1
a1061 1
	licr = cd_base[CD2400_LICR];
d1065 1
a1065 1
	isrl = cd_base[CD2400_RISRl];
d1081 1
a1081 1
	fifo_cnt = cd_base[CD2400_RFOC];
d1083 2
a1084 2
		data = cd_base[CD2400_RDR];
		cd_base[CD2400_TEOIR] = 0x00;
d1087 1
a1087 1
		cd_base[CD2400_TEOIR] = 0x08;
d1089 1
a1089 1
	return (data);
a1090 1

d1100 2
a1101 2
	s = spltty();
	sc->vbase[CD2400_CAR] = channel;
d1104 1
a1104 1
		if (sc->sc_cl[channel].cl_consio == 0) {
d1106 3
a1108 3
			sc->vbase[CD2400_MSVR_RTS] = 0x00;
			sc->vbase[CD2400_MSVR_DTR] = 0x00;
			sc->vbase[CD2400_CCR] = 0x05;
d1114 2
a1115 2
	sc->vbase[CD2400_MSVR_RTS] = 0x03;
	sc->vbase[CD2400_MSVR_DTR] = 0x03;
d1118 3
a1120 3
	clk = cl_clknum(par->c_ospeed);
	sc->vbase[CD2400_TBPR] = divisor;
	sc->vbase[CD2400_TCOR] = clk << 5;
d1122 5
a1126 5
	clk = cl_clknum(par->c_ispeed);
	sc->vbase[CD2400_RBPR] = divisor;
	sc->vbase[CD2400_RCOR] = clk;
	sc->vbase[CD2400_RTPRl] = cl_clkrxtimeout(par->c_ispeed);
	sc->vbase[CD2400_RTPRh] = 0x00;
d1145 1
a1145 1
	sc->vbase[CD2400_COR3] = par->c_cflag & PARENB ? 4 : 2;
d1149 1
a1149 1
			sc->vbase[CD2400_COR1] = 0xE0 | clen ; /* odd */
d1151 1
a1151 1
			sc->vbase[CD2400_COR1] = 0x40 | clen ; /* even */
d1154 1
a1154 1
		sc->vbase[CD2400_COR1] = 0x10 | clen; /* ignore parity */
d1157 4
a1160 6
	if (sc->sc_cl[channel].cl_consio == 0 &&
	    (par->c_cflag & CREAD) == 0 ) {
/*
		sc->vbase[CD2400_CSR] = 0x08;
*/
		sc->vbase[CD2400_CCR] = 0x08;
d1162 1
a1162 1
		sc->vbase[CD2400_CCR] = 0x0a;
d1182 4
a1185 3
	sc->vbase[CD2400_COR4] = ints | CL_FIFO_CNT;
	sc->vbase[CD2400_COR5] = ints | CL_FIFO_CNT;
	return (imask);
a1186 1

d1188 1
a1188 2

u_char
a1192 1

d1194 1
a1194 1
		return (cl_clocks[clknum].divisor);
d1199 1
a1199 1
			return (cl_clocks[clknum].divisor);
d1203 1
a1203 1
	return (cl_clocks[4].divisor);
a1204 1

a1210 1

d1212 1
a1212 1
		return (cl_clocks[clknum].clock);
d1217 1
a1217 1
			return (cl_clocks[clknum].clock);
d1221 1
a1221 1
	return (cl_clocks[4].clock);
a1222 1

a1227 1

d1229 1
a1229 1
		return (cl_clocks[clknum].rx_timeout);
d1234 1
a1234 1
			return (cl_clocks[clknum].rx_timeout);
d1238 1
a1238 1
	return (cl_clocks[4].rx_timeout);
a1239 1

a1247 1

d1268 1
a1268 1
	    (sc = (struct clsoftc *) clcd.cd_devs[unit]) == NULL) {
d1275 1
a1275 1
	s = spltty();
d1283 1
a1283 1
	if (cnt != 0) {
d1285 2
a1286 2
		sc->vbase[CD2400_CAR] = channel;
		sc->vbase[CD2400_TDR] = cbuf;
d1291 2
a1292 1
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0) {
d1294 2
a1295 2
		sc->vbase[CD2400_CAR] = channel;
		sc->vbase[CD2400_IER] = 0xb;
d1299 1
a1300 1

d1308 1
a1308 3

	mir = sc->vbase[CD2400_MIR];
	if ((mir & 0x40) == 0x0) {
d1311 1
a1311 1
		return (0);
d1316 2
a1317 2
	misr = sc->vbase[CD2400_MISR];
	msvr = sc->vbase[CD2400_MSVR_RTS];
d1320 1
a1320 1
		printf("cl_mintr: channel %x timer 1 unexpected\n", channel);
d1324 1
a1324 1
		printf("cl_mintr: channel %x timer 2 unexpected\n", channel);
d1327 3
a1329 2
		printf("cl_mintr: channel %x cts %x\n", channel, 
		    (msvr & 0x20) != 0x0);
d1333 4
a1336 4

		printf("cl_mintr: channel %x cd %x\n", channel,
		    (msvr & 0x40) != 0x0);
		ttymodem(tp, (msvr & 0x40) != 0x0);
d1339 3
a1341 2
		printf("cl_mintr: channel %x dsr %x\n", channel,
		    (msvr & 0x80) != 0x0);
d1343 2
a1344 2
	sc->vbase[CD2400_MEOIR] = 0x00;
	return (1);
d1359 1
a1359 3

	tir = sc->vbase[CD2400_TIR];
	if ((tir & 0x40) == 0x0) {
d1361 2
a1362 2
		printf("cl_txintr extra intr\n");
		return (0);
d1366 2
a1367 2
	channel = tir & 0x03;
	licr = sc->vbase[CD2400_LICR];
d1373 2
a1374 2
		sc->vbase[CD2400_TEOIR] = 0x08;
		return (1);
d1376 1
a1376 1
	switch ((licr >> 4) & 0x3) {
d1381 2
a1382 2
		max = sc->vbase[CD2400_TFTC];
		cnt = min((int)max, tp->t_outq.c_cc);
d1387 1
a1387 1
				sc->vbase[CD2400_TDR]= *tptr;
d1391 3
a1393 3
			if (empty > 5 && (empty % 20000 ) == 0) {
				printf("cl_txintr: too many empty intr %d chan %d\n",
				    empty, channel);
d1401 1
a1401 1
					wakeup((caddr_t)&tp->t_outq);
d1405 1
a1405 1
			sc->vbase[CD2400_IER] = sc->vbase[CD2400_IER] & ~0x3;
d1409 1
a1409 1
		printf("cl_txintr unknown mode %x\n", (licr >> 4) & 0x3);
d1413 2
a1414 2
	sc->vbase[CD2400_TEOIR] = teoir;
	return (1);
d1428 2
a1429 2
	rir = sc->vbase[CD2400_RIR];
	if ((rir & 0x40) == 0x0) {
d1431 2
a1432 2
		printf("cl_rxintr extra intr\n");
		return (0);
d1436 1
a1436 1
	licr = sc->vbase[CD2400_LICR];
d1446 1
a1446 1
		risrl = sc->vbase[CD2400_RISRl];
d1468 1
a1468 1
			fifocnt = sc->vbase[CD2400_RFOC];
d1471 1
a1471 1
				c = sc->vbase[CD2400_RDR];
d1478 1
a1478 1
				(*linesw[tp->t_line].l_rint)(c, tp);
d1485 1
a1485 1
		printf("cl_rxintr unknown mode %x\n", licr & 0x03);
d1489 2
a1490 2
	sc->vbase[CD2400_REOIR] = reoir;
	return (1);
d1494 5
a1498 5
cl_overflow(sc, channel, ptime, msg)
	struct clsoftc *sc;
	int channel;
	long *ptime;
	char *msg;
d1505 1
a1505 1
		*ptime = time.tv_sec);
d1510 1
a1511 1

d1513 1
a1513 1
cl_parity(sc, channel)
d1518 1
a1519 1

d1521 1
a1521 1
cl_frame(sc, channel)
d1526 1
a1527 1

d1529 1
a1529 1
cl_break(sc, channel)
d1534 1
d1541 1
a1542 1

d1547 1
a1548 1

d1553 1
a1554 1

d1559 1
d1566 7
a1572 6
	u_char livr, cmr, cor1, cor2, cor3, cor4, cor5, cor6, cor7;
	u_char schr1, schr2, schr3, schr4, scrl, scrh, lnxt;
	u_char rbpr, rcor, tbpr, tcor, rpilr, rir, tpr, ier, ccr;
	u_char csr, rts, dtr, rtprl, rtprh;
	struct clsoftc *sc = (struct clsoftc *) clcd.cd_devs[0];
	volatile u_char *cd_base = cl_cons.cl_vaddr;
d1575 35
a1609 31
	s = spltty();
	cd_base[CD2400_CAR] = (char) channel;
	livr = cd_base[CD2400_LIVR];
	cmr = cd_base[CD2400_CMR];
	cor1 = cd_base[CD2400_COR1];
	cor2 = cd_base[CD2400_COR2];
	cor3 = cd_base[CD2400_COR3];
	cor4 = cd_base[CD2400_COR4];
	cor5 = cd_base[CD2400_COR5];
	cor6 = cd_base[CD2400_COR6];
	cor7 = cd_base[CD2400_COR7];
	schr1 = cd_base[CD2400_SCHR1];
	schr2 = cd_base[CD2400_SCHR2];
	schr3 = cd_base[CD2400_SCHR3];
	schr4 = cd_base[CD2400_SCHR4];
	scrl = cd_base[CD2400_SCRl];
	scrh = cd_base[CD2400_SCRh];
	lnxt = cd_base[CD2400_LNXT];
	rbpr = cd_base[CD2400_RBPR];
	rcor = cd_base[CD2400_RCOR];
	tbpr = cd_base[CD2400_TBPR];
	rpilr = cd_base[CD2400_RPILR];
	ier = cd_base[CD2400_IER];
	ccr = cd_base[CD2400_CCR];
	tcor = cd_base[CD2400_TCOR];
	csr = cd_base[CD2400_CSR];
	tpr = cd_base[CD2400_TPR];
	rts = cd_base[CD2400_MSVR_RTS];
	dtr = cd_base[CD2400_MSVR_DTR];
	rtprl = cd_base[CD2400_RTPRl];
	rtprh = cd_base[CD2400_RTPRh];
d1612 2
a1613 1
	printf("{ port %x livr %x cmr %x\n", channel, livr, cmr);
d1615 15
a1629 10
	    cor1, cor2, cor3, cor4, cor5, cor6, cor7);
	printf("schr1 %x schr2 %x schr3 %x schr4 %x\n", schr1, schr2, schr3,
	    schr4);
	printf("scrl %x scrh %x lnxt %x\n", scrl, scrh, lnxt);
	printf("rbpr %x rcor %x tbpr %x tcor %x\n", rbpr, rcor, tbpr, tcor);
	printf("rpilr %x rir %x ier %x ccr %x\n", rpilr, rir, ier, ccr);
	printf("tpr %x csr %x rts %x dtr %x\n", tpr, csr, rts, dtr);
	printf("rtprl %x rtprh %x\n", rtprl, rtprh);
	printf("rxcnt %x txcnt %x\n", sc->sc_cl[channel].rxcnt,
	    sc->sc_cl[channel].txcnt);
d1631 1
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
