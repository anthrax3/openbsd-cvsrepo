head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.16
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.12
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.10
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.10
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.18
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.10
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.20;

1.20
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.01.21.37.41;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.20.05.19.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.25.19.19.39;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.24.22.43.16;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.27.16.04.08;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.02.18.00.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.02.17.37.16;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.28.14.47.50;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.11.20.17.02.31;	author etheisen;	state Exp;
branches
	1.5.10.1;
next	1.4;

1.4
date	96.06.11.10.15.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.11.06.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.43.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.43.05;	author deraadt;	state Exp;
branches;
next	;

1.5.10.1
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.5.10.2;

1.5.10.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.5.10.3;

1.5.10.3
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.5.10.4;

1.5.10.4
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.5.10.5;

1.5.10.5
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: sram.c,v 1.20 2010/12/26 15:40:59 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/systm.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/mioctl.h>

#include <mvme68k/dev/memdevs.h>

#include "mc.h"

#if NMC > 0
#include <mvme68k/dev/mcreg.h>
#endif

#include <uvm/uvm_extern.h>

struct sramsoftc {
	struct device	sc_dev;
	paddr_t		sc_paddr;
	vaddr_t		sc_vaddr;
	int		sc_len;
};

void sramattach(struct device *, struct device *, void *);
int  srammatch(struct device *, void *, void *);

struct cfattach sram_ca = {
	sizeof(struct sramsoftc), srammatch, sramattach
};

struct cfdriver sram_cd = {
	NULL, "sram", DV_DULL
};

int
srammatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct confargs *ca = args;

	if (cputyp == CPU_147)
		return (0);

	return (!badpaddr(ca->ca_paddr, 1));
}

void
sramattach(parent, self, args)
	struct device *parent, *self;
	void	*args;
{
	struct confargs *ca = args;
	struct sramsoftc *sc = (struct sramsoftc *)self;
#if defined(MVME162) || defined(MVME172)
	struct mcreg *mc;
#endif

	switch (cputyp) {
#if defined(MVME162) || defined(MVME172)
	case CPU_162:
	case CPU_172:
		/* XXX this code will almost never be used. just in case. */
		mc = sys_mc;
		if (!mc)
			mc = (struct mcreg *)(IIOV(0xfff00000) + MC_MCCHIP_OFF);

		switch (mc->mc_memoptions & MC_MEMOPTIONS_SRAMMASK) {
		case MC_MEMOPTIONS_SRAM128K:
			sc->sc_len = 128*1024;
			break;
		case MC_MEMOPTIONS_SRAM512K:
			sc->sc_len = 512*1024;
			break;
		case MC_MEMOPTIONS_SRAM1M:
			sc->sc_len = 1024*1024;
			break;
		case MC_MEMOPTIONS_SRAM2M:
			sc->sc_len = 2048*1024;
			break;
		}
		break;
#endif
#ifdef MVME167
	case CPU_166:
	case CPU_167:
		sc->sc_len = 128*1024;		/* always 128K */
		break;
#endif
#ifdef MVME177
	case CPU_176:
	case CPU_177:
		sc->sc_len = 128*1024;		/* always 128K */
		break;
#endif
	default:
		sc->sc_len = 0;
		break;
	}

	printf(": len %d", sc->sc_len);

	sc->sc_paddr = ca->ca_paddr;
	sc->sc_vaddr = mapiodev(sc->sc_paddr, sc->sc_len);
	if (sc->sc_vaddr == 0) {
		sc->sc_len = 0;
		printf(" -- failed to map");
	}
	printf("\n");
}

/*ARGSUSED*/
int
sramopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	if (minor(dev) >= sram_cd.cd_ndevs ||
	    sram_cd.cd_devs[minor(dev)] == NULL)
		return (ENODEV);
	return (0);
}

/*ARGSUSED*/
int
sramclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	return (0);
}

/*ARGSUSED*/
int
sramioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = minor(dev);
	struct sramsoftc *sc = (struct sramsoftc *) sram_cd.cd_devs[unit];
	int error = 0;
	
	switch (cmd) {
	case MIOCGSIZ:
		*(int *)data = sc->sc_len;
		break;
	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

/*ARGSUSED*/
int
sramrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct sramsoftc *sc = (struct sramsoftc *) sram_cd.cd_devs[unit];

	return (memdevrw(sc->sc_vaddr, sc->sc_len, uio, flags));
}

paddr_t
srammmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	int unit = minor(dev);
	struct sramsoftc *sc = (struct sramsoftc *) sram_cd.cd_devs[unit];

	if (minor(dev) != 0)
		return (-1);

	/* allow access only in RAM */
	if (off < 0 || off >= round_page(sc->sc_len))
		return (-1);
	return (sc->sc_paddr + off);
}
@


1.20
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.19 2009/03/01 21:37:41 miod Exp $ */
@


1.19
log
@Clean up match routines vs board id; this should give 166, 172 and 176 a
change to work better.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.18 2007/12/20 05:19:38 miod Exp $ */
d222 1
a222 1
	return (atop(sc->sc_paddr + off));
@


1.18
log
@Stricter range checks in mmap function.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.17 2005/11/25 19:19:39 miod Exp $ */
d89 1
a89 1
#ifdef MVME162
d94 1
a94 1
#ifdef MVME162
d96 1
d119 1
a120 1
	case CPU_166:
d125 1
@


1.17
log
@We don't have a va mapping in match() so don't bother trying to use badvaddr()
at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.16 2005/11/24 22:43:16 miod Exp $ */
d218 1
a218 1
	if (off < 0 || off > sc->sc_len)
@


1.16
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.15 2005/10/27 16:04:08 martin Exp $ */
d78 2
a79 3
	if (ca->ca_vaddr == (vaddr_t)-1)
		return (!badpaddr(ca->ca_paddr, 1));
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 1));
@


1.15
log
@stupid me, of course these MD macros need to be converted to MI macros
as well
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.14 2004/07/02 18:00:50 miod Exp $ */
d53 2
a54 2
	void *		sc_paddr;
	void *		sc_vaddr;
d78 2
a79 2
	if (ca->ca_vaddr == (void *)-1)
		return (!badpaddr((paddr_t)ca->ca_paddr, 1));
d137 2
a138 2
	sc->sc_vaddr = mapiodev((void *)sc->sc_paddr, sc->sc_len);
	if (sc->sc_vaddr == NULL) {
@


1.14
log
@Stricter bounds checking for mmap() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.13 2004/07/02 17:37:16 miod Exp $ */
d221 1
a221 1
	return (m68k_btop(sc->sc_paddr + off));
@


1.13
log
@Merge *ramread() and *ramwrite(), as done on mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.12 2004/01/14 20:50:48 miod Exp $ */
d219 1
a219 1
	if (off > sc->sc_len)
@


1.12
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.11 2003/06/02 05:09:14 deraadt Exp $ */
d195 1
a195 14
sramread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct sramsoftc *sc = (struct sramsoftc *) sram_cd.cd_devs[unit];

	return (memdevrw(sc->sc_vaddr, sc->sc_len, uio, flags));
}

/*ARGSUSED*/
int
sramwrite(dev, uio, flags)
@


1.11
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.10 2002/04/28 14:47:50 miod Exp $ */
d66 1
a66 1
	NULL, "sram", DV_DULL, 0
@


1.10
log
@A few more tweaks to let non-GENERIC kernels (MVMEfoo) build as well with -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.9 2002/04/27 23:21:05 miod Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.8 2002/03/14 01:26:37 millert Exp $ */
d96 1
d98 1
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.7 2001/11/06 19:53:15 miod Exp $ */
a34 1
#include <sys/conf.h>
d40 1
d42 2
a43 1
#include <sys/device.h>
a44 1
#include <machine/autoconf.h>
d47 2
a79 1
	struct cfdata *cf = vcf;
d85 2
a86 2
		return (!badpaddr(ca->ca_paddr, 1));
	return (!badvaddr(ca->ca_vaddr, 1));
a96 1
	int i;
d151 1
a151 1
sramopen(dev, flag, mode)
d154 1
d164 1
a164 1
sramclose(dev, flag, mode)
d167 1
d176 2
a177 1
	dev_t   dev;
d179 1
a179 1
	int     cmd, flag;
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.6 2001/11/01 12:13:46 art Exp $ */
d62 2
a63 2
void sramattach __P((struct device *, struct device *, void *));
int  srammatch __P((struct device *, void *, void *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.7 2001/11/06 19:53:15 miod Exp $ */
d35 1
d41 1
d43 1
a43 1

a44 2
#include <machine/conf.h>
#include <machine/cpu.h>
a46 2
#include <mvme68k/dev/memdevs.h>

d62 2
a63 2
void sramattach(struct device *, struct device *, void *);
int  srammatch(struct device *, void *, void *);
d78 1
d84 2
a85 2
		return (!badpaddr((paddr_t)ca->ca_paddr, 1));
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 1));
a94 1
#ifdef MVME162
d96 1
a96 1
#endif
d151 1
a151 1
sramopen(dev, flag, mode, p)
a153 1
	struct proc *p;
d163 1
a163 1
sramclose(dev, flag, mode, p)
a165 1
	struct proc *p;
d174 1
a174 2
	dev_t dev;
	u_long cmd;
d176 1
a176 1
	int flag;
@


1.6
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.5 1997/11/20 17:02:31 etheisen Exp $ */
d53 1
a53 1
#include <vm/vm.h>
@


1.5
log
@177 boards have 128k SRAM.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.4 1996/06/11 10:15:24 deraadt Exp $ */
d220 1
a220 1
int
d223 2
a224 1
	int off, prot;
@


1.5.10.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d53 1
a53 1
#include <uvm/uvm_extern.h>
d220 1
a220 1
paddr_t
d223 1
a223 2
	off_t off;
	int prot;
@


1.5.10.2
log
@Merge in -current from about a week ago
@
text
@d62 2
a63 2
void sramattach(struct device *, struct device *, void *);
int  srammatch(struct device *, void *, void *);
@


1.5.10.3
log
@Sync the SMP branch with 3.3
@
text
@d35 1
d41 1
d43 1
a43 1

a44 2
#include <machine/conf.h>
#include <machine/cpu.h>
a46 2
#include <mvme68k/dev/memdevs.h>

d78 1
d84 2
a85 2
		return (!badpaddr((paddr_t)ca->ca_paddr, 1));
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 1));
a94 1
#ifdef MVME162
d96 1
a96 1
#endif
d151 1
a151 1
sramopen(dev, flag, mode, p)
a153 1
	struct proc *p;
d163 1
a163 1
sramclose(dev, flag, mode, p)
a165 1
	struct proc *p;
d174 1
a174 2
	dev_t dev;
	u_long cmd;
d176 1
a176 1
	int flag;
@


1.5.10.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.5.10.3 2003/03/27 23:32:16 niklas Exp $ */
d15 6
@


1.5.10.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d66 1
a66 1
	NULL, "sram", DV_DULL
@


1.4
log
@use void * for pa/va instead of caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d130 1
a130 1
		XXX
@


1.3
log
@cfattach/cfdriver split
@
text
@d57 2
a58 2
	caddr_t		sc_paddr;
	caddr_t		sc_vaddr;
d83 1
a83 1
	if (ca->ca_vaddr == (caddr_t)-1)
d141 1
a141 1
	sc->sc_vaddr = mapiodev((caddr_t)sc->sc_paddr, sc->sc_len);
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d65 6
a70 3
struct cfdriver sramcd = {
	NULL, "sram", srammatch, sramattach,
	DV_DULL, sizeof(struct sramsoftc), 0
d155 2
a156 2
	if (minor(dev) >= sramcd.cd_ndevs ||
	    sramcd.cd_devs[minor(dev)] == NULL)
d180 1
a180 1
	struct sramsoftc *sc = (struct sramsoftc *) sramcd.cd_devs[unit];
d202 1
a202 1
	struct sramsoftc *sc = (struct sramsoftc *) sramcd.cd_devs[unit];
d215 1
a215 1
	struct sramsoftc *sc = (struct sramsoftc *) sramcd.cd_devs[unit];
d226 1
a226 1
	struct sramsoftc *sc = (struct sramsoftc *) sramcd.cd_devs[unit];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
d17 2
a18 1
 *      This product includes software developed by Theo de Raadt
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
