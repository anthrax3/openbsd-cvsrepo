head	1.14;
access;
symbols
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.20
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.14
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2006.03.04.12.26.43;	author miod;	state dead;
branches;
next	1.13;

1.13
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.29.19.17.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.30.22.29.45;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.02.17.57.29;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.03.06.54.25;	author david;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.06.08.08.09.07;	author art;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.21.46.00;	author kstailey;	state Exp;
branches
	1.4.14.1;
next	1.3;

1.3
date	96.04.28.11.03.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.42.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.42.59;	author deraadt;	state Exp;
branches;
next	;

1.4.14.1
date	2001.07.04.10.19.27;	author niklas;	state Exp;
branches;
next	1.4.14.2;

1.4.14.2
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.4.14.3;

1.4.14.3
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.4.14.4;

1.4.14.4
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.4.14.5;

1.4.14.5
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Dead meat.
@
text
@/*	$OpenBSD: sbicdma.c,v 1.13 2005/12/17 07:31:26 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1995 Dale Rahn. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * as you may guess by some of the routines in this file,
 * dma is not yet working. - its on the TODO list
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <machine/autoconf.h>
#include <mvme68k/dev/pccreg.h>
#include <mvme68k/dev/sbicreg.h>
#include <mvme68k/dev/sbicvar.h>
#include <mvme68k/dev/dmavar.h>

void	sbicdmaattach(struct device *, struct device *, void *);
int	sbicdmamatch(struct device *, void *, void *);
int	sbicdmaprint(void *auxp, const char *);

void	sbicdma_dmafree(struct sbic_softc *);
void	sbicdma_dmastop(struct sbic_softc *);
int	sbicdma_dmanext(struct sbic_softc *);
int	sbicdma_dmago(struct sbic_softc *, char *, int, int);
int	sbicdma_dmaintr(struct sbic_softc *);
int	sbicdma_scintr(struct sbic_softc *);

struct scsi_adapter sbicdma_scsiswitch = {
	sbic_scsicmd,
	sbic_minphys,
	0,		      /* no lun support */
	0,		      /* no lun support */
};

struct scsi_device sbicdma_scsidev = {
	NULL,	   /* use default error handler */
	NULL,	   /* have a queue served by this ??? */
	NULL,	   /* have no async handler ??? */
	NULL,	   /* Use default done routine */
}; 

#ifdef DEBUG
int	sbicdma_debug = 1;
#endif

int	sbicdma_maxdma = 0;    /* Maximum size per DMA transfer */
int	sbicdma_dmamask = 0; 
int	sbicdma_dmabounce = 0; 
 
struct cfdriver sbiccd = {
	NULL, "sbic", sbicdmamatch, sbicdmaattach,
	DV_DULL, sizeof(struct sbic_softc),
};

int
sbicdmamatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	/*
	 * XXX finish to properly probe
	 */
	return (1);
}

void
sbicdmaattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct	sbic_softc *sc = (struct sbic_softc *)self;
	struct	confargs *ca = args;

	sc->sc_dmafree = sbicdma_dmafree;
	sc->sc_dmago = sbicdma_dmago;
	sc->sc_dmanext = sbicdma_dmanext;
	sc->sc_dmastop = sbicdma_dmastop;
	sc->sc_dmacmd = 0;

	sc->sc_flags |= SBICF_BADDMA;
	sc->sc_dmamask = 0;
	sc->sc_sbicp = (sbic_regmap_p)ca->ca_vaddr;
	sc->sc_clkfreq = 100;

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = 7;
	sc->sc_link.adapter = &sbicdma_scsiswitch;
	sc->sc_link.device = &sbicdma_scsidev;
	sc->sc_link.openings = 1;

	printf(": target %d\n", sc->sc_link.adapter_target);

	/* connect the interrupts */
	sc->sc_ih.ih_fn = sbicdma_scintr;
	sc->sc_ih.ih_arg = sc;
	sc->sc_ih.ih_ipl = ca->ca_ipl;
	pccintr_establish(PCCV_SBIC, &sc->sc_ih, self->dv_xname);

	sc->sc_dmaih.ih_fn = sbicdma_dmaintr;
	sc->sc_dmaih.ih_arg = sc;
	sc->sc_dmaih.ih_ipl = ca->ca_ipl;
	pccintr_establish(PCCV_DMA, &sc->sc_dmaih, self->dv_xname);

	sys_pcc->pcc_dmairq = sc->sc_dmaih.ih_ipl | PCC_IRQ_INT;
	sys_pcc->pcc_sbicirq = sc->sc_ih.ih_ipl | PCC_SBIC_RESETIRQ;

	sbicreset(sc);

	config_found(self, &sc->sc_link, sbicdmaprint);
}

/*
 * print diag if pnp is NULL else just extra
 */
int
sbicdmaprint(auxp, pnp)
	void		*auxp;
	const char	*pnp;
{
	if (pnp == NULL)
		return (UNCONF);
	return (QUIET);
}

int
sbicdma_dmago(sc, va, count, flags)
	struct	sbic_softc *sc;
	char	*va;
	int	count, flags;
{
	u_char	csr;
	u_long	pa;

	pmap_extract(pmap_kernel(), (vaddr_t)va, &pa);
#ifdef DEBUG
	if (sbicdma_debug)
		printf("%s: dmago: va 0x%x pa 0x%x cnt %d flags %x\n",
		    sc->sc_dev.dv_xname, va, pa, count, flags);
#endif

	sc->sc_flags |= SBICF_INTR;
	sys_pcc->pcc_dmadaddr = (u_long)pa;
	if (count & PCC_DMABCNT_CNTMASK) {
		printf("%s: dma count 0x%x too large\n",
		    sc->sc_dev.dv_xname, count);
		return (0);
	}
	sys_pcc->pcc_dmabcnt = (PCC_DMABCNT_MAKEFC(FC_USERD)) |
	    (count & PCC_DMABCNT_CNTMASK);

	/* make certain interrupts are disabled first, and reset */
	sys_pcc->pcc_dmairq = sc->sc_dmaih.ih_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
	sys_pcc->pcc_sbicirq = sc->sc_ih.ih_ipl | PCC_SBIC_RESETIRQ | PCC_IRQ_IEN;
	sys_pcc->pcc_dmacsr = 0;
	sys_pcc->pcc_dmacsr = PCC_DMACSR_DEN |
	    ((flags & DMAGO_READ) == 0) ? PCC_DMACSR_TOSCSI : 0;

	return (sc->sc_tcnt);
}

int
sbicdma_dmaintr(sc)
	struct sbic_softc *sc;
{
	u_char	stat;
	int	ret = 0;

	/* DMA done */
	stat = sys_pcc->pcc_dmacsr;
#ifdef DEBUG
printf("dmaintr%d ", stat);
#endif
	if (stat & PCC_DMACSR_DONE) {
		sys_pcc->pcc_dmacsr = 0;
		sys_pcc->pcc_dmairq = 0;	/* ack and remove intr */
		if (stat & PCC_DMACSR_ERR8BIT) {
			printf("%s: 8 bit error\n", sc->sc_dev.dv_xname);
		}
		if (stat & PCC_DMACSR_DMAERRDATA) {
			printf("%s: DMA bus error\n", sc->sc_dev.dv_xname);
		}
		return (1);
	}
	return (0);
}

int
sbicdma_scintr(sc)
	struct sbic_softc *sc;
{
	u_char	stat;
	int	ret = 0;

#ifdef DEBUG
printf("scintr%d ", stat);
#endif
	stat = sys_pcc->pcc_sbicirq;
	if (stat & PCC_SBIC_RESETIRQ) {
		printf("%s: scintr: a scsi device pulled reset\n",
		    sc->sc_dev.dv_xname);
		sys_pcc->pcc_sbicirq = sys_pcc->pcc_sbicirq | PCC_SBIC_RESETIRQ;
	} else if (stat & PCC_IRQ_INT) {
		sys_pcc->pcc_sbicirq = 0;
		sbicintr(sc);
		ret = 1;
	}
	return (ret);
}

void
sbicdma_dmastop(sc)
	struct sbic_softc *sc;
{
#ifdef DEBUG
	printf("sbicdma_dmastop called\n");
#endif
	/* XXX do nothing */
}

int
sbicdma_dmanext(sc)
	struct sbic_softc *sc;
{
#ifdef DEBUG
	printf("sbicdma_dmanext called\n");
#endif
}

void
sbicdma_dmafree(sc)
	struct sbic_softc *sc;
{
#ifdef DEBUG
	printf("sbicdma_dmafree called\n");
#endif
	/* make certain interrupts are disabled first, reset */
	sys_pcc->pcc_dmairq = 0;
}
@


1.13
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.12 2004/09/29 19:17:40 miod Exp $ */
@


1.12
log
@Ratibibugle now useless evcnt structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.11 2004/07/30 22:29:45 miod Exp $ */
d166 1
a166 1
	pmap_extract(pmap_kernel(), (vm_offset_t)va, &pa);
@


1.11
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.10 2004/07/02 17:57:29 miod Exp $ */
a140 3
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_dmaintrcnt);

a213 1
		sc->sc_dmaintrcnt.ev_count++;
a237 1
		sc->sc_intrcnt.ev_count++;
@


1.10
log
@Kill ca_master in autoconf structures. Drivers either only attach to one
specific bus (mc/pcc/pcctwo), or they know it from the ca_bustype value,
and can use the globals sys_busname variables.

This also allows for some code simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.9 2003/11/03 06:54:25 david Exp $ */
d129 1
a129 1
	pccintr_establish(PCCV_SBIC, &sc->sc_ih);
d134 1
a134 1
	pccintr_establish(PCCV_DMA, &sc->sc_dmaih);
@


1.9
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.8 2003/06/02 05:09:14 deraadt Exp $ */
a103 1
	struct	pccreg *pcc;
a105 1
	sc->sc_cregs = (struct pccreg *)ca->ca_master;
d136 2
a137 3
	pcc = (struct pccreg *)sc->sc_cregs;
	pcc->pcc_dmairq = sc->sc_dmaih.ih_ipl | PCC_IRQ_INT;
	pcc->pcc_sbicirq = sc->sc_ih.ih_ipl | PCC_SBIC_RESETIRQ;
a165 1
	struct	pccreg *pcc = (struct pccreg *)sc->sc_cregs;
d177 1
a177 1
	pcc->pcc_dmadaddr = (u_long)pa;
d183 1
a183 1
	pcc->pcc_dmabcnt = (PCC_DMABCNT_MAKEFC(FC_USERD)) |
d187 4
a190 4
	pcc->pcc_dmairq = sc->sc_dmaih.ih_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
	pcc->pcc_sbicirq = sc->sc_ih.ih_ipl | PCC_SBIC_RESETIRQ | PCC_IRQ_IEN;
	pcc->pcc_dmacsr = 0;
	pcc->pcc_dmacsr = PCC_DMACSR_DEN |
a199 1
	struct	pccreg *pcc = (struct pccreg *)sc->sc_cregs;
d204 2
a205 1
	stat = pcc->pcc_dmacsr;
d207 1
d209 2
a210 2
		pcc->pcc_dmacsr = 0;
		pcc->pcc_dmairq = 0;	/* ack and remove intr */
a226 1
	struct	pccreg *pcc = (struct pccreg *)sc->sc_cregs;
d230 1
d232 2
a233 1
	stat = pcc->pcc_sbicirq;
d237 1
a237 1
		pcc->pcc_sbicirq = pcc->pcc_sbicirq | PCC_SBIC_RESETIRQ;
d239 1
a239 1
		pcc->pcc_sbicirq = 0;
d251 1
d253 1
d261 1
d263 1
d270 1
a270 2
	struct pccreg *pcc = (struct pccreg *)sc->sc_cregs;

d272 1
d274 1
a274 1
	pcc->pcc_dmairq = 0;
@


1.8
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.7 2002/03/14 01:26:37 millert Exp $ */
d190 1
a190 1
	/* make certain interupts are disabled first, and reset */
d271 1
a271 1
	/* make certain interupts are disabled first, reset */
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.6 2001/11/06 19:53:15 miod Exp $ */
a14 8
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 *    and
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.5 2001/06/08 08:09:07 art Exp $ */
d57 10
a66 10
void	sbicdmaattach	__P((struct device *, struct device *, void *));
int	sbicdmamatch	__P((struct device *, void *, void *));
int	sbicdmaprint	__P((void *auxp, const char *));

void	sbicdma_dmafree	__P((struct sbic_softc *));
void	sbicdma_dmastop	__P((struct sbic_softc *));
int	sbicdma_dmanext	__P((struct sbic_softc *));
int	sbicdma_dmago	__P((struct sbic_softc *, char *, int, int));
int	sbicdma_dmaintr	__P((struct sbic_softc *));
int	sbicdma_scintr	__P((struct sbic_softc *));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.6 2001/11/06 19:53:15 miod Exp $ */
d57 10
a66 10
void	sbicdmaattach(struct device *, struct device *, void *);
int	sbicdmamatch(struct device *, void *, void *);
int	sbicdmaprint(void *auxp, const char *);

void	sbicdma_dmafree(struct sbic_softc *);
void	sbicdma_dmastop(struct sbic_softc *);
int	sbicdma_dmanext(struct sbic_softc *);
int	sbicdma_dmago(struct sbic_softc *, char *, int, int);
int	sbicdma_dmaintr(struct sbic_softc *);
int	sbicdma_scintr(struct sbic_softc *);
@


1.5
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.4 1996/11/23 21:46:00 kstailey Exp $ */
d46 1
a46 1
#include <vm/vm.h>
@


1.4
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d181 1
a181 1
	pa = (u_long)pmap_extract(pmap_kernel(), (vm_offset_t)va);
@


1.4.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.4 1996/11/23 21:46:00 kstailey Exp $ */
d181 1
a181 1
	pmap_extract(pmap_kernel(), (vm_offset_t)va, &pa);
@


1.4.14.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d46 1
a46 1
#include <uvm/uvm_extern.h>
@


1.4.14.3
log
@Merge in -current from about a week ago
@
text
@d57 3
a59 3
void	sbicdmaattach(struct device *, struct device *, void *);
int	sbicdmamatch(struct device *, void *, void *);
int	sbicdmaprint(void *auxp, const char *);
d61 6
a66 6
void	sbicdma_dmafree(struct sbic_softc *);
void	sbicdma_dmastop(struct sbic_softc *);
int	sbicdma_dmanext(struct sbic_softc *);
int	sbicdma_dmago(struct sbic_softc *, char *, int, int);
int	sbicdma_dmaintr(struct sbic_softc *);
int	sbicdma_scintr(struct sbic_softc *);
@


1.4.14.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbicdma.c,v 1.4.14.3 2002/03/28 10:34:05 niklas Exp $ */
d15 8
@


1.4.14.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d190 1
a190 1
	/* make certain interrupts are disabled first, and reset */
d271 1
a271 1
	/* make certain interrupts are disabled first, reset */
@


1.3
log
@add OpenBSD header
@
text
@d59 1
a59 1
int	sbicdmaprint	__P((void *auxp, char *));
d163 2
a164 2
	void	*auxp;
	char	*pnp;
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$	*/
d17 4
a20 1
 *   This product includes software developed by Dale Rahn.
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
