head	1.30;
access;
symbols
	OPENBSD_5_3:1.29.0.10
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.8
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.6
	OPENBSD_5_0:1.29.0.4
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.10
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2013.05.19.20.32.47;	author miod;	state dead;
branches;
next	1.29;

1.29
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.29.21.12.01;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.27.16.04.24;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.22.20.16.43;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.25.17.52.02;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.12.11.14.02;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.29.13.56.14;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.28.22.17.21;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.03.18.09.37;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.20.00.34.28;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.03.06.54.25;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.11.19.20.26;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.02.49.22;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.10.15.33.07;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.11.24.01.13.51;	author mickey;	state Exp;
branches
	1.5.10.1;
next	1.4;

1.4
date	96.05.10.12.42.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.11.24.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.42.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.42.58;	author deraadt;	state Exp;
branches;
next	;

1.5.10.1
date	2001.04.18.16.10.26;	author niklas;	state Exp;
branches;
next	1.5.10.2;

1.5.10.2
date	2001.10.31.03.01.17;	author nate;	state Exp;
branches;
next	1.5.10.3;

1.5.10.3
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.5.10.4;

1.5.10.4
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.5.10.5;

1.5.10.5
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.5.10.6;

1.5.10.6
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.5.10.7;

1.5.10.7
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2003.05.19.21.45.31;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Switch mvme68k to MI wdsc(4) driver. Tested on MVME147.
@
text
@/*	$OpenBSD: sbic.c,v 1.29 2010/11/18 21:13:19 miod Exp $ */
/*	$NetBSD: sbic.c,v 1.2 1996/04/23 16:32:54 chuck Exp $	*/

/*
 * Changes Copyright (c) 1996 Steve Woodford
 * Original Copyright (c) 1994 Christian E. Hopps
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson of Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *  @@(#)scsi.c  7.5 (Berkeley) 5/4/91
 */

/*
 * Steve Woodford (SCW), Apr, 1996
 * MVME147S WD33C93 Scsi Bus Interface Controller driver,
 *
 * Basically a de-loused and tidied up version of the Amiga AMD 33C93 driver.
 *
 * The original driver used features which required at least a WD33C93A
 * chip. The '147 has the original WD33C93 chip (no 'A' suffix).
 *
 * This version of the driver is pretty well generic, so should work with
 * any flavour of WD33C93 chip.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h> /* For hz */
#include <sys/disklabel.h>
#include <sys/buf.h>
#include <sys/queue.h>
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <uvm/uvm_extern.h>
#include <mvme68k/dev/dmavar.h>
#include <mvme68k/dev/sbicreg.h>
#include <mvme68k/dev/sbicvar.h>
#include <machine/autoconf.h>
#include <mvme68k/dev/pccreg.h>


/*
 * Since I can't find this in any other header files
 */
#define SCSI_PHASE(reg) (reg&0x07)

/*
 * SCSI delays
 * In u-seconds, primarily for state changes on the SPC.
 */
#define SBIC_CMD_WAIT   50000   /* wait per step of 'immediate' cmds */
#define SBIC_DATA_WAIT  50000   /* wait per data in/out step */
#define SBIC_INIT_WAIT  50000   /* wait per step (both) during init */

/*
 * Convenience macro for waiting for a particular sbic event
 */
#define SBIC_WAIT(regs, until, timeo) sbicwait(regs, until, timeo, __LINE__)

int     sbicicmd(struct sbic_softc *, void *, int, void *, int);
int     sbicgo(struct sbic_softc *, struct scsi_xfer *);
int     sbicdmaok(struct sbic_softc *, struct scsi_xfer *);
int     sbicwait(sbic_regmap_p, u_char, int , int);
int     sbiccheckdmap(void *, u_long, u_long);
u_char  sbicselectbus(struct sbic_softc *);
int     sbicxfout(sbic_regmap_p, int, void *);
int     sbicxfin(sbic_regmap_p, int, void *);
int     sbicfromscsiperiod(struct sbic_softc *, int);
int     sbictoscsiperiod(struct sbic_softc *, int);
int     sbicintr(struct sbic_softc *);
int     sbicpoll(struct sbic_softc *);
int     sbicnextstate(struct sbic_softc *, u_char, u_char);
int     sbicmsgin(struct sbic_softc *);
int     sbicabort(struct sbic_softc *, char *);
void    sbicxfdone(struct sbic_softc *);
void    sbicerror(struct sbic_softc *,u_char);
void    sbicreset(struct sbic_softc *);
void    sbic_scsidone(struct sbic_acb *, int);
void    sbic_sched(struct sbic_softc *);
void    sbic_save_ptrs(struct sbic_softc *);
void    sbic_load_ptrs(struct sbic_softc *);
void    sbicinit(struct sbic_softc *);

/*
 * Synch xfer parameters, and timing conversions
 */
int     sbic_min_period = SBIC_SYN_MIN_PERIOD;  /* in cycles = f(ICLK,FSn) */
int     sbic_max_offset = SBIC_SYN_MAX_OFFSET;  /* pure number */
int     sbic_cmd_wait   = SBIC_CMD_WAIT;
int     sbic_data_wait  = SBIC_DATA_WAIT;
int     sbic_init_wait  = SBIC_INIT_WAIT;

/*
 * was broken before.. now if you want this you get it for all drives
 * on sbic controllers.
 */
u_char  sbic_inhibit_sync[8];
int     sbic_enable_reselect     = 1;   /* Allow Disconnect / Reselect */
int     sbic_no_dma              = 0;   /* Use PIO transfers instead of DMA */
int     sbic_parallel_operations = 1;   /* Allow command queues */

/*
 * Some useful stuff for debugging purposes
 */
#ifdef DEBUG
int     sbicdma_ops     = 0;    /* total DMA operations */
int     sbicdma_hits    = 0;    /* number of DMA chains that were contiguous */
int     sbicdma_misses  = 0;    /* number of DMA chains that were not contiguous */
int     sbicdma_saves   = 0;

#define QPRINTF(a) if (sbic_debug > 1) printf a

int     sbic_debug      = 0;    /* Debug all chip related things */
int     sync_debug      = 0;    /* Debug all Synchronous Scsi related things */
int     reselect_debug  = 0;    /* Debug all reselection related things */
int     report_sense    = 0;    /* Always print Sense information */
int     data_pointer_debug = 0; /* Debug Data Pointer related things */

void    sbictimeout(struct sbic_softc *dev);

#else
#define QPRINTF(a)  /* */
#endif

/*
 * Save DMA pointers.  Take into account partial transfer. Shut down DMA.
 */
void
sbic_save_ptrs(dev)
    struct sbic_softc   *dev;
{
    sbic_regmap_p       regs;
    struct sbic_acb*    acb;
    int                 count,
                        asr,
                        s;

    /*
     * Only need to save pointers if DMA was active...
     */
    if ( dev->sc_cur == NULL || (dev->sc_flags & SBICF_INDMA) == 0 )
        return;

    regs = dev->sc_sbicp;

    s = splbio();

    /*
     * Wait until WD chip is idle
     */
    do {
        GET_SBIC_asr(regs, asr);
        if( asr & SBIC_ASR_DBR ) {
            printf("sbic_save_ptrs: asr %02x canceled!\n", asr);
            splx(s);
            return;
        }
    } while( asr & (SBIC_ASR_BSY|SBIC_ASR_CIP) );


    /*
     * Save important state.
     * must be done before dmastop
     */
    acb            = dev->sc_nexus;
    acb->sc_dmacmd = dev->sc_dmacmd;

    /*
     * Fetch the residual count
     */
    SBIC_TC_GET(regs, count);

    /*
     * Shut down DMA
     */
    dev->sc_dmastop(dev);

    /*
     * No longer in DMA
     */
    dev->sc_flags &= ~SBICF_INDMA;

    /*
     * Ensure the WD chip is back in polled I/O mode, with nothing to
     * transfer.
     */
    SBIC_TC_PUT(regs, 0);
    SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);

    /*
     * Update current count...
     */
    acb->sc_tcnt = count;

    /*
     * Work out how many bytes were actually transferred
     */
    count        = dev->sc_tcnt - count;
    dev->sc_tcnt = acb->sc_tcnt;

    /*
     * Fixup partial xfers
     */
    acb->sc_kv.dc_addr  += count;
    acb->sc_kv.dc_count -= count;
    acb->sc_pa.dc_addr  += count;
    acb->sc_pa.dc_count -= count >> 1;

#ifdef DEBUG
    if ( data_pointer_debug )
        printf("save at (%x,%x):%x\n",
               dev->sc_cur->dc_addr, dev->sc_cur->dc_count,count);
    sbicdma_saves++;
#endif

    splx(s);
}


/*
 * DOES NOT RESTART DMA!!!
 */
void
sbic_load_ptrs(dev)
    struct sbic_softc   *dev;
{
    struct sbic_acb *acb = dev->sc_nexus;
    int             s;

    if ( acb->sc_kv.dc_count == 0 ) {
        /*
         * No data to xfer
         */
        return;
    }

    s = splbio();

    /*
     * Reset the Scatter-Gather chain
     */
    dev->sc_last = dev->sc_cur = &acb->sc_pa;

    /*
     * Restore the Transfer Count and DMA specific data
     */
    dev->sc_tcnt   = acb->sc_tcnt;
    dev->sc_dmacmd = acb->sc_dmacmd;

#ifdef DEBUG
    sbicdma_ops++;
#endif

    /*
     * Need to fixup new segment?
     */
    if ( dev->sc_tcnt == 0 ) {
        /*
         * sc_tcnt == 0 implies end of segment
         */
        char    *vaddr, *paddr;
        int     count;

        /*
         * do kvm to pa mappings
         */
        vaddr = acb->sc_kv.dc_addr;
        paddr = acb->sc_pa.dc_addr = (char *)kvtop((vaddr_t)vaddr);

        for (count = (NBPG - ((int)vaddr & PGOFSET));
             count < acb->sc_kv.dc_count &&
                (char *)kvtop((vaddr_t)vaddr + count + 4) == paddr + count + 4;
             count += NBPG)
            ;   /* Do nothing */

        /*
         * If it's all contiguous...
         */
        if ( count > acb->sc_kv.dc_count ) {
            count = acb->sc_kv.dc_count;
#ifdef  DEBUG
            sbicdma_hits++;
#endif
        }
#ifdef  DEBUG
        else
            sbicdma_misses++;
#endif

        acb->sc_tcnt        = count;
        acb->sc_pa.dc_count = count >> 1;

#ifdef DEBUG
        if ( data_pointer_debug )
            printf("DMA recalc:kv(%x,%x)pa(%x,%x)\n", acb->sc_kv.dc_addr,
                                                      acb->sc_kv.dc_count,
                                                      acb->sc_pa.dc_addr,
                                                      acb->sc_tcnt);
#endif

    }

    splx(s);
}

/*
 * used by specific sbic controller
 *
 * it appears that the higher level code does nothing with LUN's
 * so I will too.  I could plug it in, however so could they
 * in scsi_scsi_cmd().
 */
void
sbic_scsicmd(xs)
    struct scsi_xfer *xs;
{
    struct scsi_link    *slp = xs->sc_link;
    struct sbic_softc   *dev = slp->adapter_softc;
    struct sbic_acb     *acb;
    int                 flags = xs->flags,
                        s;

    if ( dev->sc_nexus && (flags & SCSI_POLL) )
        panic("sbic_scsicmd: busy");

    s = splbio();

    if ( (acb = TAILQ_FIRST(&dev->free_list)) != NULL )
        TAILQ_REMOVE(&dev->free_list, acb, chain);

    splx(s);

    if ( acb == NULL ) {
#ifdef DEBUG
        printf("sbic_scsicmd: unable to queue request for target %d\n",
            slp->target);
#ifdef DDB
        Debugger();
#endif
#endif
	xs->error = XS_NO_CCB;
	scsi_done(xs);
        return;
    }

    if ( flags & SCSI_DATA_IN )
        acb->flags = ACB_ACTIVE | ACB_DATAIN;
    else
        acb->flags = ACB_ACTIVE;

    acb->xs             = xs;
    acb->clen           = xs->cmdlen;
    acb->sc_kv.dc_addr  = xs->data;
    acb->sc_kv.dc_count = xs->datalen;
    acb->pa_addr        = xs->data ? (char *)kvtop((vaddr_t)xs->data) : 0;
    bcopy(xs->cmd, &acb->cmd, xs->cmdlen);

    if ( flags & SCSI_POLL ) {
        /*
         * This has major side effects -- it locks up the machine
         */
        int stat;

        s = splbio();

        dev->sc_flags |= SBICF_ICMD;

        do {
            /*
             * If we already had a nexus, while away the time until idle...
             * This is likely only to happen if a reselection occurs between
             * here and our earlier check for ICMD && sc_nexus (which would
             * have resulted in a panic() had it been true).
             */
            while ( dev->sc_nexus )
                sbicpoll(dev);

            /*
             * Fix up the new nexus
             */
            dev->sc_nexus   = acb;
            dev->sc_xs      = xs;
            dev->target     = slp->target;
            dev->lun        = slp->lun;

            stat = sbicicmd(dev, &acb->cmd, acb->clen,
                            acb->sc_kv.dc_addr, acb->sc_kv.dc_count);

        } while ( dev->sc_nexus != acb );

        sbic_scsidone(acb, stat);

        splx(s);

        return;
    }

    s = splbio();
    TAILQ_INSERT_TAIL(&dev->ready_list, acb, chain);

    /*
     * If nothing is active, try to start it now.
     */
    if ( dev->sc_nexus == NULL )
        sbic_sched(dev);

    splx(s);
}

/*
 * attempt to start the next available command
 */
void
sbic_sched(dev)
    struct sbic_softc *dev;
{
    struct scsi_xfer    *xs;
    struct scsi_link    *slp = NULL;    /* Gag the compiler */
    struct sbic_acb     *acb;
    int                 flags,
                        stat;

    /*
     * XXXSCW
     * I'll keep this test here, even though I can't see any obvious way
     * in which sbic_sched() could be called with sc_nexus non NULL
     */
    if ( dev->sc_nexus )
        return;         /* a command is current active */

    /*
     * Loop through the ready list looking for work to do...
     */
    TAILQ_FOREACH(acb, &dev->ready_list, chain) {
        int     i, j;

        slp = acb->xs->sc_link;
        i   = slp->target;
        j   = 1 << slp->lun;

        /*
         * We've found a potential command, but is the target/lun busy?
         */
        if ( (dev->sc_tinfo[i].lubusy & j) == 0 ) {
            /*
             * Nope, it's not busy, so we can use it.
             */
            dev->sc_tinfo[i].lubusy |= j;
            TAILQ_REMOVE(&dev->ready_list, acb, chain);
            dev->sc_nexus = acb;
            acb->sc_pa.dc_addr = acb->pa_addr;  /* XXXX check */
            break;
        }
    }

    if ( acb == NULL ) {
        QPRINTF(("sbicsched: no work\n"));
        return;         /* did not find an available command */
    }

#ifdef DEBUG
    if ( data_pointer_debug > 1 )
        printf("sbic_sched(%d,%d)\n", slp->target, slp->lun);
#endif

    dev->sc_xs = xs = acb->xs;
    flags      = xs->flags;

    if ( flags & SCSI_RESET )
        sbicreset(dev);

    dev->sc_stat[0] = -1;
    dev->target     = slp->target;
    dev->lun        = slp->lun;

    if ( flags & SCSI_POLL || (!sbic_parallel_operations &&
                              (sbicdmaok(dev, xs) == 0)) )
        stat = sbicicmd(dev, &acb->cmd, acb->clen,
                        acb->sc_kv.dc_addr, acb->sc_kv.dc_count);
    else
    if ( sbicgo(dev, xs) == 0 )
        return;
    else
        stat = dev->sc_stat[0];

    sbic_scsidone(acb, stat);
}

void
sbic_scsidone(acb, stat)
    struct sbic_acb *acb;
    int             stat;
{
    struct scsi_xfer    *xs  = acb->xs;
    struct scsi_link    *slp = xs->sc_link;
    struct sbic_softc   *dev = slp->adapter_softc;
    int                 dosched = 0;

#ifdef DIAGNOSTIC
    if ( acb == NULL || xs == NULL ) {
        printf("sbic_scsidone -- (%d,%d) no scsi_xfer\n", dev->target, dev->lun);
#ifdef DDB
        Debugger();
#endif
        return;
    }
#endif

    /*
     * is this right?
     */
    xs->status = stat;

#ifdef DEBUG
    if ( data_pointer_debug > 1 )
        printf("scsidone: (%d,%d)->(%d,%d)%02x\n", slp->target, slp->lun,
                                                   dev->target, dev->lun, stat);

    if ( xs->sc_link->target == dev->sc_link.adapter_target )
        panic("target == hostid");
#endif

    if ( xs->error == XS_NOERROR && (acb->flags & ACB_CHKSENSE) == 0 ) {

        if ( stat == SCSI_CHECK ) {
            /*
             * Schedule a REQUEST SENSE
             */
            struct scsi_sense *ss = (void *)&acb->cmd;

#ifdef DEBUG
            if ( report_sense )
                printf("sbic_scsidone: autosense %02x targ %d lun %d",
                        acb->cmd.opcode, slp->target, slp->lun);
#endif

            bzero(ss, sizeof(*ss));

            ss->opcode          = REQUEST_SENSE;
            ss->byte2           = slp->lun << 5;
            ss->length          = sizeof(struct scsi_sense_data);

            acb->clen           = sizeof(*ss);
            acb->sc_kv.dc_addr  = (char *)&xs->sense;
            acb->sc_kv.dc_count = sizeof(struct scsi_sense_data);
            acb->pa_addr        = (char *)kvtop((vaddr_t)&xs->sense); /* XXX check */
            acb->flags          = ACB_ACTIVE | ACB_CHKSENSE | ACB_DATAIN;

            TAILQ_INSERT_HEAD(&dev->ready_list, acb, chain);

            dev->sc_tinfo[slp->target].lubusy &= ~(1 << slp->lun);
            dev->sc_tinfo[slp->target].senses++;

            if ( dev->sc_nexus == acb ) {
                dev->sc_nexus = NULL;
                dev->sc_xs = NULL;
                sbic_sched(dev);
            }
            return;
        }
    }

    if ( xs->error == XS_NOERROR && (acb->flags & ACB_CHKSENSE) != 0 ) {

        xs->error = XS_SENSE;

#ifdef DEBUG
        if (report_sense)
            printf(" => %02x\n", xs->sense.flags);
#endif

    } else {
        xs->resid = 0;      /* XXXX */
    }

    /*
     * Remove the ACB from whatever queue it's on.  We have to do a bit of
     * a hack to figure out which queue it's on.  Note that it is *not*
     * necessary to cdr down the ready queue, but we must cdr down the
     * nexus queue and see if it's there, so we can mark the unit as no
     * longer busy.  This code is sickening, but it works.
     */
    if ( acb == dev->sc_nexus ) {

        dev->sc_nexus = NULL;
        dev->sc_xs    = NULL;

        dev->sc_tinfo[slp->target].lubusy &= ~(1 << slp->lun);

        if ( !TAILQ_EMPTY(&dev->ready_list) )
            dosched = 1;    /* start next command */

    } else
    if (TAILQ_LAST(&dev->ready_list, acb_list) == TAILQ_NEXT(acb, chain)) {

        TAILQ_REMOVE(&dev->ready_list, acb, chain);

    } else {

        register struct sbic_acb *a;

	TAILQ_FOREACH(a, &dev->nexus_list, chain) {
            if ( a == acb ) {
                TAILQ_REMOVE(&dev->nexus_list, acb, chain);
                dev->sc_tinfo[slp->target].lubusy &= ~(1 << slp->lun);
                break;
            }
        }

        if ( a )
            ;
        else if ( TAILQ_NEXT(acb, chain) != NULL) {
            TAILQ_REMOVE(&dev->ready_list, acb, chain);
        } else {
            printf("%s: can't find matching acb\n", dev->sc_dev.dv_xname);
#ifdef DDB
            Debugger();
#endif
        }
    }

    /*
     * Put it on the free list.
     */
    acb->flags = ACB_FREE;
    TAILQ_INSERT_HEAD(&dev->free_list, acb, chain);

    dev->sc_tinfo[slp->target].cmds++;

    scsi_done(xs);

    if ( dosched )
        sbic_sched(dev);
}

int
sbicdmaok(dev, xs)
    struct sbic_softc   *dev;
    struct scsi_xfer    *xs;
{
    if ( sbic_no_dma || xs->datalen & 0x03 || (int)xs->data & 0x03)
        return(0);

    /*
     * controller supports dma to any addresses?
     */
    if ( (dev->sc_flags & SBICF_BADDMA) == 0 )
        return(1);

    /*
     * this address is ok for dma?
     */
    if ( sbiccheckdmap(xs->data, xs->datalen, dev->sc_dmamask) == 0 )
        return(1);

    return(0);
}

int
sbicwait(regs, until, timeo, line)
    sbic_regmap_p   regs;
    u_char          until;
    int             timeo;
    int             line;
{
    u_char  val;

    if ( timeo == 0 )
        timeo = 1000000;    /* some large value.. */

    GET_SBIC_asr(regs, val);

    while ( (val & until) == 0 ) {

        if ( timeo-- == 0 ) {
            int csr;
            GET_SBIC_csr(regs, csr);
            printf("sbicwait TIMEO @@%d with asr=x%x csr=x%x\n", line, val, csr);
#if defined(DDB) && defined(DEBUG)
            Debugger();
#endif
            return(val); /* Maybe I should abort */
            break;
        }

        DELAY(1);
        GET_SBIC_asr(regs, val);
    }

    return(val);
}

int
sbicabort(dev, where)
    struct sbic_softc   *dev;
    char                *where;
{
    sbic_regmap_p   regs = dev->sc_sbicp;
    u_char          csr,
                    asr;

    GET_SBIC_asr(regs, asr);
    GET_SBIC_csr(regs, csr);

    printf ("%s: abort %s: csr = 0x%02x, asr = 0x%02x\n",
            dev->sc_dev.dv_xname, where, csr, asr);

    /*
     * Clean up chip itself
     */
    if ( dev->sc_flags & SBICF_SELECTED ) {

        while ( asr & SBIC_ASR_DBR ) {
            /*
             * sbic is jammed w/data. need to clear it
             * But we don't know what direction it needs to go
             */
            GET_SBIC_data(regs, asr);
            printf("%s: abort %s: clearing data buffer 0x%02x\n",
                   dev->sc_dev.dv_xname, where, asr);
            GET_SBIC_asr(regs, asr);
            if ( asr & SBIC_ASR_DBR ) /* Not the read direction, then */
                SET_SBIC_data(regs, asr);
            GET_SBIC_asr(regs, asr);
        }

        WAIT_CIP(regs);

        printf("%s: sbicabort - sending ABORT command\n", dev->sc_dev.dv_xname);
        SET_SBIC_cmd(regs, SBIC_CMD_ABORT);
        WAIT_CIP(regs);

        GET_SBIC_asr(regs, asr);

        if ( asr & (SBIC_ASR_BSY|SBIC_ASR_LCI) ) {
            /*
             * ok, get more drastic..
             */
            printf("%s: sbicabort - asr %x, trying to reset\n",
                    dev->sc_dev.dv_xname, asr);
            sbicreset(dev);
            dev->sc_flags &= ~SBICF_SELECTED;
            return SBIC_STATE_ERROR;
        }

        printf("%s: sbicabort - sending DISC command\n", dev->sc_dev.dv_xname);
        SET_SBIC_cmd(regs, SBIC_CMD_DISC);

        do {
            SBIC_WAIT (regs, SBIC_ASR_INT, 0);
            GET_SBIC_asr(regs, asr);
            GET_SBIC_csr (regs, csr);
            QPRINTF(("csr: 0x%02x, asr: 0x%02x\n", csr, asr));
        } while ( (csr != SBIC_CSR_DISC) && (csr != SBIC_CSR_DISC_1) &&
                  (csr != SBIC_CSR_CMD_INVALID) );

        /*
         * lets just hope it worked..
         */
        dev->sc_flags &= ~SBICF_SELECTED;
    }

    return SBIC_STATE_ERROR;
}


/*
 * Initialize driver-private structures
 */
void
sbicinit(dev)
    struct sbic_softc *dev;
{
    u_int   i;

    extern u_long   scsi_nosync;
    extern int      shift_nosync;

    if ( (dev->sc_flags & SBICF_ALIVE) == 0 ) {

        struct sbic_acb *acb;

        TAILQ_INIT(&dev->ready_list);
        TAILQ_INIT(&dev->nexus_list);
        TAILQ_INIT(&dev->free_list);

        dev->sc_nexus = NULL;
        dev->sc_xs    = NULL;

        acb = dev->sc_acb;
        bzero(acb, sizeof(dev->sc_acb));

        for (i = 0; i < sizeof(dev->sc_acb) / sizeof(*acb); i++) {
            TAILQ_INSERT_TAIL(&dev->free_list, acb, chain);
            acb++;
        }

        bzero(dev->sc_tinfo, sizeof(dev->sc_tinfo));

#ifdef DEBUG
        /*
         * make sure timeout is really not needed
         */
        timeout((void *)sbictimeout, dev, 30 * hz);
#endif

    } else
        panic("sbic: reinitializing driver!");

    dev->sc_flags |=  SBICF_ALIVE;
    dev->sc_flags &= ~SBICF_SELECTED;

    /*
     * initialize inhibit array
     */
    if ( scsi_nosync ) {

        u_int inhibit_sync = (scsi_nosync >> shift_nosync) & 0xff;

        shift_nosync += 8;

#ifdef DEBUG
        if ( inhibit_sync )
            printf("%s: Inhibiting synchronous transfer %02x\n",
                        dev->sc_dev.dv_xname, inhibit_sync);
#endif
        for (i = 0; i < 8; ++i) {
            if ( inhibit_sync & (1 << i) )
                sbic_inhibit_sync[i] = 1;
        }
    }

    sbicreset(dev);
}

void
sbicreset(dev)
    struct sbic_softc *dev;
{
    sbic_regmap_p   regs = dev->sc_sbicp;
    u_int           my_id,
                    s;
    u_char          csr;

    s = splbio();

    my_id = dev->sc_link.adapter_target & SBIC_ID_MASK;

    if (dev->sc_clkfreq < 110)
        my_id |= SBIC_ID_FS_8_10;
    else if (dev->sc_clkfreq < 160)
        my_id |= SBIC_ID_FS_12_15;
    else if (dev->sc_clkfreq < 210)
        my_id |= SBIC_ID_FS_16_20;

    SET_SBIC_myid(regs, my_id);

    /*
     * Reset the chip
     */
    SET_SBIC_cmd(regs, SBIC_CMD_RESET);
    DELAY(25);

    SBIC_WAIT(regs, SBIC_ASR_INT, 0);
    GET_SBIC_csr(regs, csr);       /* clears interrupt also */

    /*
     * Set up various chip parameters
     */
    SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);

    /*
     * don't allow Selection (SBIC_RID_ES)
     * until we can handle target mode!!
     */
    SET_SBIC_rselid(regs, SBIC_RID_ER);

    /*
     * Asynchronous for now
     */
    SET_SBIC_syn(regs, 0);

    /*
     * Anything else was zeroed by reset
     */
    splx(s);

    dev->sc_flags &= ~SBICF_SELECTED;
}

void
sbicerror(dev, csr)
    struct sbic_softc   *dev;
    u_char              csr;
{
    struct scsi_xfer    *xs  = dev->sc_xs;

#ifdef DIAGNOSTIC
    if ( xs == NULL )
        panic("sbicerror: dev->sc_xs == NULL");
#endif

    if ( xs->flags & SCSI_SILENT )
        return;

    printf("%s: csr == 0x%02x\n", dev->sc_dev.dv_xname, csr);
}

/*
 * select the bus, return when selected or error.
 *
 * Returns the current CSR following selection and optionally MSG out phase.
 * i.e. the returned CSR *should* indicate CMD phase...
 * If the return value is 0, some error happened.
 */
u_char
sbicselectbus(dev)
    struct sbic_softc   *dev;
{
    sbic_regmap_p   regs   = dev->sc_sbicp;
    u_char          target = dev->target,
                    lun    = dev->lun,
                    asr,
                    csr,
                    id;

    /*
     * if we're already selected, return (XXXX panic maybe?)
     */
    if ( dev->sc_flags & SBICF_SELECTED )
        return(0);

    QPRINTF(("sbicselectbus %d: ", target));

    /*
     * issue select
     */
    SET_SBIC_selid(regs, target);
    SET_SBIC_timeo(regs, SBIC_TIMEOUT(250, dev->sc_clkfreq));

    GET_SBIC_asr(regs, asr);

    if ( asr & (SBIC_ASR_INT|SBIC_ASR_BSY) ) {
        /*
         * This means we got ourselves reselected upon
         */
        QPRINTF(("WD busy (reselect?)\n"));
        return 0;
    }

    SET_SBIC_cmd(regs, SBIC_CMD_SEL_ATN);

    /*
     * wait for select (merged from separate function may need
     * cleanup)
     */
    WAIT_CIP(regs);

    do {

        asr = SBIC_WAIT(regs, SBIC_ASR_INT | SBIC_ASR_LCI, 0);

        if ( asr & SBIC_ASR_LCI ) {
            QPRINTF(("late LCI: asr %02x\n", asr));
            return 0;
        }

        /*
         * Clear interrupt
         */
        GET_SBIC_csr (regs, csr);

        QPRINTF(("%02x ", csr));

        /*
         * Reselected from under our feet?
         */
        if ( csr == SBIC_CSR_RSLT_NI || csr == SBIC_CSR_RSLT_IFY ) {
            QPRINTF(("got reselected, asr %02x\n", asr));
            /*
             * We need to handle this now so we don't lock up later
             */
            sbicnextstate(dev, csr, asr);

            return 0;
        }

        /*
         * Whoops!
         */
        if ( csr == SBIC_CSR_SLT || csr == SBIC_CSR_SLT_ATN ) {
            panic("sbicselectbus: target issued select!");
            return 0;
        }

    } while (csr != (SBIC_CSR_MIS_2 | MESG_OUT_PHASE) &&
             csr != (SBIC_CSR_MIS_2 | CMD_PHASE) &&
             csr != SBIC_CSR_SEL_TIMEO);

    /*
     * Anyone at home?
     */
    if ( csr == SBIC_CSR_SEL_TIMEO ) {
        dev->sc_xs->error = XS_SELTIMEOUT;
        QPRINTF(("Selection Timeout\n"));
        return 0;
    }

    QPRINTF(("Selection Complete\n"));

    /*
     * Assume we're now selected
     */
    GET_SBIC_selid(regs, id);
    dev->target    = id;
    dev->lun       = lun;
    dev->sc_flags |= SBICF_SELECTED;

    /*
     * Enable (or not) reselection
     * XXXSCW This is probably not necessary since we don't use use the
     * Select-and-Xfer-with-ATN command to initiate a selection...
     */
    if ( !sbic_enable_reselect && TAILQ_EMPTY(&dev->nexus_list))
        SET_SBIC_rselid (regs, 0);
    else
        SET_SBIC_rselid (regs, SBIC_RID_ER);

    /*
     * We only really need to do anything when the target goes to MSG out
     * If the device ignored ATN, it's probably old and brain-dead,
     * but we'll try to support it anyhow.
     * If it doesn't support message out, it definitely doesn't
     * support synchronous transfers, so no point in even asking...
     */
    if ( csr == (SBIC_CSR_MIS_2 | MESG_OUT_PHASE) ) {
        /*
         * Send identify message (SCSI-2 requires an identify msg)
         */
        if ( sbic_inhibit_sync[id] && dev->sc_sync[id].state == SYNC_START ) {
            /*
             * Handle drives that don't want to be asked
             * whether to go sync at all.
             */
            dev->sc_sync[id].offset = 0;
            dev->sc_sync[id].period = sbic_min_period;
            dev->sc_sync[id].state  = SYNC_DONE;
        }

        /*
         * Do we need to negotiate Synchronous Xfers for this target?
         */
        if ( dev->sc_sync[id].state != SYNC_START ) {
            /*
             * Nope, we've already negotiated.
             * Now see if we should allow the target to disconnect/reselect...
             */
            if ( dev->sc_xs->flags & SCSI_POLL || dev->sc_flags & SBICF_ICMD ||
                                                  !sbic_enable_reselect )
                SEND_BYTE (regs, MSG_IDENTIFY | lun);
            else
                SEND_BYTE (regs, MSG_IDENTIFY_DR | lun);

        } else {
            /*
             * try to initiate a sync transfer.
             * So compose the sync message we're going
             * to send to the target
             */
#ifdef DEBUG
            if ( sync_debug )
                printf("\nSending sync request to target %d ... ", id);
#endif
            /*
             * setup scsi message sync message request
             */
            dev->sc_msg[0] = MSG_IDENTIFY | lun;
            dev->sc_msg[1] = MSG_EXT_MESSAGE;
            dev->sc_msg[2] = 3;
            dev->sc_msg[3] = MSG_SYNC_REQ;
            dev->sc_msg[4] = sbictoscsiperiod(dev, sbic_min_period);
            dev->sc_msg[5] = sbic_max_offset;

            sbicxfout(regs, 6, dev->sc_msg);

            dev->sc_sync[id].state = SYNC_SENT;
#ifdef DEBUG
            if ( sync_debug )
                printf ("sent\n");
#endif
        }

        /*
         * There's one interrupt still to come: the change to CMD phase...
         */
        SBIC_WAIT(regs, SBIC_ASR_INT , 0);
        GET_SBIC_csr(regs, csr);
    }

    /*
     * set sync or async
     */
    if ( dev->sc_sync[target].state == SYNC_DONE ) {
#ifdef  DEBUG
        if ( sync_debug )
            printf("select(%d): sync reg = 0x%02x\n", target,
                            SBIC_SYN(dev->sc_sync[target].offset,
                                     dev->sc_sync[target].period));
#endif
        SET_SBIC_syn(regs, SBIC_SYN(dev->sc_sync[target].offset,
                                    dev->sc_sync[target].period));
    } else {
#ifdef  DEBUG
        if ( sync_debug )
            printf("select(%d): sync reg = 0x%02x\n", target,
                            SBIC_SYN(0,sbic_min_period));
#endif
        SET_SBIC_syn(regs, SBIC_SYN(0, sbic_min_period));
    }

    return csr;
}

/*
 * Information Transfer *to* a Scsi Target.
 *
 * Note: Don't expect there to be an interrupt immediately after all
 * the data is transferred out. The WD spec sheet says that the Transfer-
 * Info command for non-MSG_IN phases only completes when the target
 * next asserts 'REQ'. That is, when the SCSI bus changes to a new state.
 *
 * This can have a nasty effect on commands which take a relatively long
 * time to complete, for example a START/STOP unit command may remain in
 * CMD phase until the disk has spun up. Only then will the target change
 * to STATUS phase. This is really only a problem for immediate commands
 * since we don't allow disconnection for them (yet).
 */
int
sbicxfout(regs, len, bp)
    sbic_regmap_p   regs;
    int             len;
    void            *bp;
{
    int     wait = sbic_data_wait;
    u_char  asr,
            *buf = bp;

    QPRINTF(("sbicxfout {%d} %02x %02x %02x %02x %02x "
        "%02x %02x %02x %02x %02x\n", len, buf[0], buf[1], buf[2],
        buf[3], buf[4], buf[5], buf[6], buf[7], buf[8], buf[9]));

    /*
     * sigh.. WD-PROTO strikes again.. sending the command in one go
     * causes the chip to lock up if talking to certain (misbehaving?)
     * targets. Anyway, this procedure should work for all targets, but
     * it's slightly slower due to the overhead
     */
    WAIT_CIP (regs);

    SBIC_TC_PUT (regs, 0);
    SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);
    SBIC_TC_PUT (regs, (unsigned)len);
    SET_SBIC_cmd (regs, SBIC_CMD_XFER_INFO);

    /*
     * Loop for each byte transferred
     */
    do {

        GET_SBIC_asr (regs, asr);

        if ( asr & SBIC_ASR_DBR ) {
            if ( len ) {
                SET_SBIC_data (regs, *buf);
                buf++;
                len--;
            } else {
                SET_SBIC_data (regs, 0);
            }
            wait = sbic_data_wait;
        }

    } while ( len && (asr & SBIC_ASR_INT) == 0 && wait-- > 0 );

#ifdef  DEBUG
    QPRINTF(("sbicxfout done: %d bytes remaining (wait:%d)\n", len, wait));
#endif

    /*
     * Normally, an interrupt will be pending when this routing returns.
     */
    return(len);
}

/*
 * Information Transfer *from* a Scsi Target
 * returns # bytes left to read
 */
int
sbicxfin(regs, len, bp)
    sbic_regmap_p   regs;
    int             len;
    void            *bp;
{
    int     wait = sbic_data_wait;
    u_char  *buf = bp;
    u_char  asr;
#ifdef  DEBUG
    u_char  *obp = bp;
#endif

    WAIT_CIP (regs);

    SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);
    SBIC_TC_PUT (regs, (unsigned)len);
    SET_SBIC_cmd (regs, SBIC_CMD_XFER_INFO);

    /*
     * Loop for each byte transferred
     */
    do {

        GET_SBIC_asr (regs, asr);

        if ( asr & SBIC_ASR_DBR ) {
            if ( len ) {
                GET_SBIC_data (regs, *buf);
                buf++;
                len--;
            } else {
                u_char foo;
                GET_SBIC_data (regs, foo);
            }
            wait = sbic_data_wait;
        }

    } while ( (asr & SBIC_ASR_INT) == 0 && wait-- > 0 );

    QPRINTF(("sbicxfin {%d} %02x %02x %02x %02x %02x %02x "
        "%02x %02x %02x %02x\n", len, obp[0], obp[1], obp[2],
        obp[3], obp[4], obp[5], obp[6], obp[7], obp[8], obp[9]));

    SBIC_TC_PUT (regs, 0);

    /*
     * this leaves with one csr to be read
     */
    return len;
}

/*
 * SCSI 'immediate' command:  issue a command to some SCSI device
 * and get back an 'immediate' response (i.e., do programmed xfer
 * to get the response data).  'cbuf' is a buffer containing a scsi
 * command of length clen bytes.  'buf' is a buffer of length 'len'
 * bytes for data.  The transfer direction is determined by the device
 * (i.e., by the scsi bus data xfer phase).  If 'len' is zero, the
 * command must supply no data.
 *
 * Note that although this routine looks like it can handle disconnect/
 * reselect, the fact is that it can't. There is still some work to be
 * done to clean this lot up.
 */
int
sbicicmd(dev, cbuf, clen, buf, len)
    struct sbic_softc   *dev;
    void                *cbuf,
                        *buf;
    int                 clen,
                        len;
{
    sbic_regmap_p   regs = dev->sc_sbicp;
    struct sbic_acb *acb = dev->sc_nexus;
    u_char          csr,
                    asr;
    int             still_busy = SBIC_STATE_RUNNING;
#ifdef  DEBUG
    int             counter = 0;
#endif

    /*
     * Make sure pointers are OK
     */
    dev->sc_last = dev->sc_cur = &acb->sc_pa;
    dev->sc_tcnt = acb->sc_tcnt = 0;

    acb->sc_dmacmd      = 0;
    acb->sc_pa.dc_count = 0; /* No DMA */
    acb->sc_kv.dc_addr  = buf;
    acb->sc_kv.dc_count = len;

#ifdef  DEBUG
    if ( data_pointer_debug > 1 )
        printf("sbicicmd(%d,%d):%d\n", dev->target, dev->lun, acb->sc_kv.dc_count);
#endif

    /*
     * set the sbic into non-DMA mode
     */
    SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);

    dev->sc_stat[0] = 0xff;
    dev->sc_msg[0]  = 0xff;

    /*
     * We're stealing the SCSI bus
     */
    dev->sc_flags |= SBICF_ICMD;

    do {
        GET_SBIC_asr (regs, asr);

        /*
         * select the SCSI bus (it's an error if bus isn't free)
         */
        if ( (dev->sc_flags & SBICF_SELECTED) == 0 &&
             still_busy != SBIC_STATE_DISCONNECT ) {
            if ( (csr = sbicselectbus(dev)) == 0 ) {
                dev->sc_flags &= ~SBICF_ICMD;
                return(-1);
            }
        } else
        if ( (asr & (SBIC_ASR_BSY | SBIC_ASR_INT)) == SBIC_ASR_INT )
            GET_SBIC_csr(regs, csr);
        else
            csr = 0;

        if ( csr ) {

            QPRINTF((">ASR:0x%02x CSR:0x%02x< ", asr, csr));

            switch ( csr ) {

              case SBIC_CSR_S_XFERRED:
              case SBIC_CSR_DISC:
              case SBIC_CSR_DISC_1:
                {
                    u_char  phase;

                    dev->sc_flags &= ~SBICF_SELECTED;
                    GET_SBIC_cmd_phase (regs, phase);

                    if ( phase == 0x60 ) {
                        GET_SBIC_tlun (regs, dev->sc_stat[0]);
                        still_busy = SBIC_STATE_DONE; /* done */
                    } else {
#ifdef DEBUG
                        if ( reselect_debug > 1 )
                            printf("sbicicmd: handling disconnect\n");
#endif
                        still_busy = SBIC_STATE_DISCONNECT;
                    }
                }
                break;

              case SBIC_CSR_XFERRED | CMD_PHASE:
              case SBIC_CSR_MIS     | CMD_PHASE:
              case SBIC_CSR_MIS_1   | CMD_PHASE:
              case SBIC_CSR_MIS_2   | CMD_PHASE:
                {
                    if ( sbicxfout(regs, clen, cbuf) )
                        still_busy = sbicabort(dev, "icmd sending cmd");
                }
                break;

              case SBIC_CSR_XFERRED | STATUS_PHASE:
              case SBIC_CSR_MIS     | STATUS_PHASE:
              case SBIC_CSR_MIS_1   | STATUS_PHASE:
              case SBIC_CSR_MIS_2   | STATUS_PHASE:
                {
                    /*
                     * The sbic does the status/cmd-complete reading ok,
                     * so do this with its hi-level commands.
                     */
#ifdef DEBUG
                    if ( sbic_debug )
                        printf("SBICICMD status phase (bsy=%d)\n", still_busy);
#endif
                    SET_SBIC_cmd_phase(regs, 0x46);
                    SET_SBIC_cmd(regs, SBIC_CMD_SEL_ATN_XFER);
                }
                break;

              default:
                {
                    still_busy = sbicnextstate(dev, csr, asr);
                }
                break;
            }

            /*
             * make sure the last command was taken,
             * ie. we're not hunting after an ignored command..
             */
            GET_SBIC_asr(regs, asr);

            /*
             * tapes may take a loooong time..
             */
            while (asr & SBIC_ASR_BSY ) {

                if ( asr & SBIC_ASR_DBR ) {
                    int     i;

                    printf("sbicicmd: Waiting while sbic is jammed, CSR:%02x,ASR:%02x\n", csr,asr);
#ifdef DDB
                    Debugger();
#endif
                    /*
                     * SBIC is jammed
                     * DUNNO which direction
                     * Try old direction
                     */
                    GET_SBIC_data(regs, i);
                    GET_SBIC_asr(regs, asr);

                    if ( asr & SBIC_ASR_DBR ) /* Wants us to write */
                        SET_SBIC_data(regs, i);
                }

                GET_SBIC_asr(regs, asr);
            }
        }

        /*
         * wait for last command to complete
         */
        if ( asr & SBIC_ASR_LCI ) {
            printf("sbicicmd: last command ignored\n");
        }
        else
        if ( still_busy >= SBIC_STATE_RUNNING ) /* Bsy */
            SBIC_WAIT (regs, SBIC_ASR_INT, sbic_cmd_wait);

        /*
         * do it again
         */
    } while ( still_busy >= SBIC_STATE_RUNNING && dev->sc_stat[0] == 0xff );

    /*
     * Sometimes we need to do an extra read of the CSR
     */
    GET_SBIC_csr(regs, csr);

#ifdef DEBUG
    if ( data_pointer_debug > 1 )
        printf("sbicicmd done(%d,%d):%d =%d=\n", dev->target, dev->lun,
                                                 acb->sc_kv.dc_count,
                                                 dev->sc_stat[0]);
#endif

    dev->sc_flags &= ~SBICF_ICMD;

    return(dev->sc_stat[0]);
}

/*
 * Finish SCSI xfer command:  After the completion interrupt from
 * a read/write operation, sequence through the final phases in
 * programmed i/o.  This routine is a lot like sbicicmd except we
 * skip (and don't allow) the select, cmd out and data in/out phases.
 */
void
sbicxfdone(dev)
    struct sbic_softc   *dev;
{
    sbic_regmap_p   regs = dev->sc_sbicp;
    u_char          phase,
                    csr;
    int             s;

    QPRINTF(("{"));
    s = splbio();

    /*
     * have the sbic complete on its own
     */
    SBIC_TC_PUT(regs, 0);
    SET_SBIC_cmd_phase(regs, 0x46);
    SET_SBIC_cmd(regs, SBIC_CMD_SEL_ATN_XFER);

    do {

        SBIC_WAIT (regs, SBIC_ASR_INT, 0);
        GET_SBIC_csr (regs, csr);
        QPRINTF(("%02x:", csr));

    } while ( (csr != SBIC_CSR_DISC) && (csr != SBIC_CSR_DISC_1) &&
              (csr != SBIC_CSR_S_XFERRED));

    dev->sc_flags &= ~SBICF_SELECTED;

    GET_SBIC_cmd_phase (regs, phase);
    QPRINTF(("}%02x", phase));

    if ( phase == 0x60 )
        GET_SBIC_tlun(regs, dev->sc_stat[0]);
    else
        sbicerror(dev, csr);

    QPRINTF(("=STS:%02x=\n", dev->sc_stat[0]));

    splx(s);
}

/*
 * No DMA chains
 */
int
sbicgo(dev, xs)
    struct sbic_softc   *dev;
    struct scsi_xfer    *xs;
{
    struct sbic_acb *acb = dev->sc_nexus;
    sbic_regmap_p   regs = dev->sc_sbicp;
    int             i,
                    dmaflags,
                    count,
                    usedma;
    u_char          csr,
                    asr,
                    *addr;

    dev->target = xs->sc_link->target;
    dev->lun    = xs->sc_link->lun;

    usedma = sbicdmaok(dev, xs);

#ifdef DEBUG
    if ( data_pointer_debug > 1 )
        printf("sbicgo(%d,%d): usedma=%d\n", dev->target, dev->lun, usedma);
#endif

    /*
     * select the SCSI bus (it's an error if bus isn't free)
     */
    if ( (csr = sbicselectbus(dev)) == 0 )
        return(0); /* Not done: needs to be rescheduled */

    dev->sc_stat[0] = 0xff;

    /*
     * Calculate DMA chains now
     */
    if ( acb->flags & ACB_DATAIN )
        dmaflags = DMAGO_READ;
    else
        dmaflags = 0;

    addr  = acb->sc_kv.dc_addr;
    count = acb->sc_kv.dc_count;

    if ( count && ((char *)kvtop((vaddr_t)addr) != acb->sc_pa.dc_addr) ) {
        printf("sbic: DMA buffer mapping changed %p->%lx\n",
                acb->sc_pa.dc_addr, kvtop((vaddr_t)addr));
#ifdef DDB
        Debugger();
#endif
    }

#ifdef DEBUG
    ++sbicdma_ops;          /* count total DMA operations */
#endif

    /*
     * Allocate the DMA chain
     * Mark end of segment...
     */
    acb->sc_tcnt        = dev->sc_tcnt = 0;
    acb->sc_pa.dc_count = 0;

    sbic_load_ptrs(dev);

    /*
     * Enable interrupts but don't do any DMA
     * enintr() also enables interrupts for the sbic
     */
    dev->sc_enintr(dev);

    if ( usedma ) {
        dev->sc_tcnt = dev->sc_dmago(dev, acb->sc_pa.dc_addr,
                                          acb->sc_pa.dc_count, dmaflags);
#ifdef DEBUG
        dev->sc_dmatimo = dev->sc_tcnt ? 1 : 0;
#endif
    } else
        dev->sc_dmacmd = 0; /* Don't use DMA */

    acb->sc_dmacmd = dev->sc_dmacmd;

#ifdef DEBUG
    if ( data_pointer_debug > 1 ) {
        printf("sbicgo dmago:%d(%x:%x) dmacmd=0x%02x\n", dev->target,
                                           dev->sc_cur->dc_addr,
                                           dev->sc_tcnt,
                                           dev->sc_dmacmd);
    }
#endif

    /*
     * Lets cycle a while then let the interrupt handler take over.
     */
    GET_SBIC_asr(regs, asr);

    do {

        QPRINTF(("go "));

        /*
         * Handle the new phase
         */
        i = sbicnextstate(dev, csr, asr);
#if 0
        WAIT_CIP(regs);
#endif
        if ( i == SBIC_STATE_RUNNING ) {
            GET_SBIC_asr(regs, asr);

            if ( asr & SBIC_ASR_LCI )
                printf("sbicgo: LCI asr:%02x csr:%02x\n", asr, csr);

            if ( asr & SBIC_ASR_INT )
                GET_SBIC_csr(regs, csr);
        }

    } while ( i == SBIC_STATE_RUNNING && asr & (SBIC_ASR_INT|SBIC_ASR_LCI) );

    if ( i == SBIC_STATE_DONE ) {
        if ( dev->sc_stat[0] == 0xff )
#if 0
            printf("sbicgo: done & stat = 0xff\n");
#else
            ;
#endif
        else
            return 1;   /* Did we really finish that fast? */
    }

    return 0;
}


int
sbicintr(dev)
    struct sbic_softc   *dev;
{
    sbic_regmap_p       regs = dev->sc_sbicp;
    u_char              asr,
                        csr;
    int                 i;

    /*
     * pending interrupt?
     */
    GET_SBIC_asr (regs, asr);
    if ( (asr & SBIC_ASR_INT) == 0 )
        return(0);

    GET_SBIC_csr(regs, csr);

    do {

        QPRINTF(("intr[0x%x]", csr));

        i = sbicnextstate(dev, csr, asr);
#if 0
        WAIT_CIP(regs);
#endif
        if ( i == SBIC_STATE_RUNNING ) {
            GET_SBIC_asr(regs, asr);

            if ( asr & SBIC_ASR_LCI )
                printf("sbicgo: LCI asr:%02x csr:%02x\n", asr, csr);

            if ( asr & SBIC_ASR_INT )
                GET_SBIC_csr(regs, csr);
        }

    } while ( i == SBIC_STATE_RUNNING && asr & (SBIC_ASR_INT|SBIC_ASR_LCI) );

    QPRINTF(("intr done. state=%d, asr=0x%02x\n", i, asr));

    return(1);
}

/*
 * Run commands and wait for disconnect.
 * This is only ever called when a command is in progress, when we
 * want to busy wait for it to finish.
 */
int
sbicpoll(dev)
    struct sbic_softc   *dev;
{
    sbic_regmap_p       regs = dev->sc_sbicp;
    u_char              asr,
                        csr = 0;
    int                 i;

    /*
     * Wait for the next interrupt
     */
    SBIC_WAIT(regs, SBIC_ASR_INT, sbic_cmd_wait);

    do {
        GET_SBIC_asr (regs, asr);

        if ( asr & SBIC_ASR_INT )
            GET_SBIC_csr(regs, csr);

        QPRINTF(("poll[0x%x]", csr));

        /*
         * Handle it
         */
        i = sbicnextstate(dev, csr, asr);

        WAIT_CIP(regs);
        GET_SBIC_asr(regs, asr);

        /*
         * tapes may take a loooong time..
         */
        while ( asr & SBIC_ASR_BSY ) {
            u_char z = 0;

            if ( asr & SBIC_ASR_DBR ) {
                printf("sbipoll: Waiting while sbic is jammed, CSR:%02x,ASR:%02x\n", csr,asr);
#ifdef DDB
                Debugger();
#endif
                /*
                 * SBIC is jammed
                 * DUNNO which direction
                 * Try old direction
                 */
                GET_SBIC_data(regs, z);
                GET_SBIC_asr(regs, asr);

                if ( asr & SBIC_ASR_DBR ) /* Wants us to write */
                    SET_SBIC_data(regs, z);
            }

            GET_SBIC_asr(regs, asr);
        }

        if ( asr & SBIC_ASR_LCI )
            printf("sbicpoll: LCI asr:%02x csr:%02x\n", asr,csr);
        else
        if ( i == SBIC_STATE_RUNNING ) /* BSY */
            SBIC_WAIT(regs, SBIC_ASR_INT, sbic_cmd_wait);

    } while ( i == SBIC_STATE_RUNNING );

    return(1);
}

/*
 * Handle a single msgin
 */
int
sbicmsgin(dev)
    struct sbic_softc   *dev;
{
    sbic_regmap_p       regs = dev->sc_sbicp;
    int                 recvlen = 1;
    u_char              asr,
                        csr,
                        *tmpaddr,
                        *msgaddr;

    tmpaddr = msgaddr = dev->sc_msg;

    tmpaddr[0] = 0xff;
    tmpaddr[1] = 0xff;

    GET_SBIC_asr(regs, asr);

#ifdef DEBUG
    if ( reselect_debug > 1 )
        printf("sbicmsgin asr=%02x\n", asr);
#endif

    GET_SBIC_selid (regs, csr);
    SET_SBIC_selid (regs, csr | SBIC_SID_FROM_SCSI);

    SBIC_TC_PUT(regs, 0);
    SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);

    do {
        while( recvlen-- ) {

            /*
             * Fetch the next byte of the message
             */
            RECV_BYTE(regs, *tmpaddr);

            /*
             * get the command completion interrupt, or we
             * can't send a new command (LCI)
             */
            SBIC_WAIT(regs, SBIC_ASR_INT, 0);
            GET_SBIC_csr(regs, csr);

#ifdef DEBUG
            if ( reselect_debug > 1 )
                printf("sbicmsgin: got %02x csr %02x\n", *tmpaddr, csr);
#endif

            tmpaddr++;

            if ( recvlen ) {
                /*
                 * Clear ACK, and wait for the interrupt for the next byte
                 */
                SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);
                SBIC_WAIT(regs, SBIC_ASR_INT, 0);
                GET_SBIC_csr(regs, csr);
            }
        }

        if ( msgaddr[0] == 0xff ) {
            printf("sbicmsgin: sbic swallowed our message\n");
            break;
        }

#ifdef DEBUG
        if ( sync_debug ) {
            GET_SBIC_asr(regs, asr);
            printf("msgin done csr 0x%x asr 0x%x msg 0x%x\n", csr, asr, msgaddr[0]);
        }
#endif
        /*
         * test whether this is a reply to our sync
         * request
         */
        if ( MSG_ISIDENTIFY(msgaddr[0]) ) {

            /*
             * Got IFFY msg -- ack it
             */
            QPRINTF(("IFFY"));

        } else
        if ( msgaddr[0] == MSG_REJECT &&
             dev->sc_sync[dev->target].state == SYNC_SENT) {

            /*
             * Target probably rejected our Sync negotiation.
             */
            QPRINTF(("REJECT of SYN"));

#ifdef DEBUG
            if ( sync_debug )
                printf("target %d rejected sync, going async\n", dev->target);
#endif

            dev->sc_sync[dev->target].period = sbic_min_period;
            dev->sc_sync[dev->target].offset = 0;
            dev->sc_sync[dev->target].state  = SYNC_DONE;
            SET_SBIC_syn(regs, SBIC_SYN(dev->sc_sync[dev->target].offset,
                                        dev->sc_sync[dev->target].period));

        } else
        if ( msgaddr[0] == MSG_REJECT ) {

            /*
             * we'll never REJECt a REJECT message..
             */
            QPRINTF(("REJECT"));

        } else
        if ( msgaddr[0] == MSG_SAVE_DATA_PTR ) {

            /*
             * don't reject this either.
             */
            QPRINTF(("MSG_SAVE_DATA_PTR"));

        } else
        if ( msgaddr[0] == MSG_RESTORE_PTR ) {

            /*
             * don't reject this either.
             */
            QPRINTF(("MSG_RESTORE_PTR"));

        } else
        if ( msgaddr[0] == MSG_DISCONNECT ) {

            /*
             * Target is disconnecting...
             */
            QPRINTF(("DISCONNECT"));

#ifdef DEBUG
            if ( reselect_debug > 1 && msgaddr[0] == MSG_DISCONNECT )
                printf("sbicmsgin: got disconnect msg %s\n",
                       (dev->sc_flags & SBICF_ICMD) ? "rejecting" : "");
#endif

            if ( dev->sc_flags & SBICF_ICMD ) {
                /*
                 * We're in immediate mode. Prevent disconnects.
                 * prepare to reject the message, NACK
                 */
                SET_SBIC_cmd(regs, SBIC_CMD_SET_ATN);
                WAIT_CIP(regs);
            }

        } else
        if ( msgaddr[0] == MSG_CMD_COMPLETE ) {

            /*
             * !! KLUDGE ALERT !! quite a few drives don't seem to
             * really like the current way of sending the
             * sync-handshake together with the ident-message, and
             * they react by sending command-complete and
             * disconnecting right after returning the valid sync
             * handshake. So, all I can do is reselect the drive,
             * and hope it won't disconnect again. I don't think
             * this is valid behavior, but I can't help fixing a
             * problem that apparently exists.
             *
             * Note: we should not get here on `normal' command
             * completion, as that condition is handled by the
             * high-level sel&xfer resume command used to walk
             * thru status/cc-phase.
             */
            QPRINTF(("CMD_COMPLETE"));

#ifdef DEBUG
            if ( sync_debug )
                printf ("GOT MSG %d! target %d acting weird.."
                        " waiting for disconnect...\n", msgaddr[0], dev->target);
#endif

            /*
             * Check to see if sbic is handling this
             */
            GET_SBIC_asr(regs, asr);

            /*
             * XXXSCW: I'm not convinced of this, we haven't negated ACK yet...
             */
            if ( asr & SBIC_ASR_BSY )
                return SBIC_STATE_RUNNING;

            /*
             * Let's try this: Assume it works and set status to 00
             */
            dev->sc_stat[0] = 0;

        } else
        if ( msgaddr[0] == MSG_EXT_MESSAGE && tmpaddr == &(msgaddr[1]) ) {

            /*
             * Target is sending us an extended message. We'll assume it's
             * the response to our Sync. negotiation.
             */
            QPRINTF(("ExtMSG\n"));

            /*
             * Read in whole extended message. First, negate ACK to accept
             * the MSG_EXT_MESSAGE byte...
             */
            SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);

            /*
             * Wait for the interrupt for the next byte (length)
             */
            SBIC_WAIT(regs, SBIC_ASR_INT, 0);
            GET_SBIC_csr(regs, csr);

#ifdef  DEBUG
            QPRINTF(("CLR ACK csr %02x\n", csr));
#endif

            /*
             * Read the length byte
             */
            RECV_BYTE(regs, *tmpaddr);

            /*
             * Wait for command completion IRQ
             */
            SBIC_WAIT(regs, SBIC_ASR_INT, 0);
            GET_SBIC_csr(regs, csr);

            /*
             * Reload the loop counter
             */
            recvlen = *tmpaddr++;

            QPRINTF(("Recving ext msg, csr %02x len %02x\n", csr, recvlen));

        } else
        if ( msgaddr[0] == MSG_EXT_MESSAGE && msgaddr[1] == 3 &&
             msgaddr[2] == MSG_SYNC_REQ ) {

            /*
             * We've received the complete Extended Message Sync. Request...
             */
            QPRINTF(("SYN"));

            /*
             * Compute the required Transfer Period for the WD chip...
             */
            dev->sc_sync[dev->target].period = sbicfromscsiperiod(dev, msgaddr[3]);
            dev->sc_sync[dev->target].offset = msgaddr[4];
            dev->sc_sync[dev->target].state  = SYNC_DONE;

            /*
             * Put the WD chip in synchronous mode
             */
            SET_SBIC_syn(regs, SBIC_SYN(dev->sc_sync[dev->target].offset,
                                        dev->sc_sync[dev->target].period));
#ifdef  DEBUG
            if ( sync_debug )
                printf("msgin(%d): sync reg = 0x%02x\n", dev->target,
                                SBIC_SYN(dev->sc_sync[dev->target].offset,
                                         dev->sc_sync[dev->target].period));
#endif

            printf("%s: target %d now synchronous, period=%dns, offset=%d.\n",
                   dev->sc_dev.dv_xname, dev->target,
                   msgaddr[3] * 4, msgaddr[4]);

        } else {

            /*
             * We don't support whatever this message is...
             */
#ifdef DEBUG
            if ( sbic_debug || sync_debug )
                printf ("sbicmsgin: Rejecting message 0x%02x\n", msgaddr[0]);
#endif

            /*
             * prepare to reject the message, NACK
             */
            SET_SBIC_cmd(regs, SBIC_CMD_SET_ATN);
            WAIT_CIP(regs);
        }

        /*
         * Negate ACK to complete the transfer
         */
        SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);

        /*
         * Wait for the interrupt for the next byte, or phase change.
         * Only read the CSR if we have more data to transfer.
         * XXXSCW: We should really verify that we're still in MSG IN phase
         * before blindly going back around this loop, but that would mean
         * we read the CSR... <sigh>
         */
        SBIC_WAIT(regs, SBIC_ASR_INT, 0);
        if ( recvlen > 0 )
            GET_SBIC_csr(regs, csr);

    } while ( recvlen > 0 );

    /*
     * Should still have one CSR to read
     */
    return SBIC_STATE_RUNNING;
}


/*
 * sbicnextstate()
 * return:
 *      SBIC_STATE_DONE        == done
 *      SBIC_STATE_RUNNING     == working
 *      SBIC_STATE_DISCONNECT  == disconnected
 *      SBIC_STATE_ERROR       == error
 */
int
sbicnextstate(dev, csr, asr)
    struct sbic_softc   *dev;
    u_char              csr,
                        asr;
{
    sbic_regmap_p       regs = dev->sc_sbicp;
    struct sbic_acb     *acb = dev->sc_nexus;

    QPRINTF(("next[%02x,%02x]: ",asr,csr));

    switch (csr) {

      case SBIC_CSR_XFERRED | CMD_PHASE:
      case SBIC_CSR_MIS     | CMD_PHASE:
      case SBIC_CSR_MIS_1   | CMD_PHASE:
      case SBIC_CSR_MIS_2   | CMD_PHASE:
        {
            if ( sbicxfout(regs, acb->clen, &acb->cmd) )
                goto abort;
        }
        break;

      case SBIC_CSR_XFERRED | STATUS_PHASE:
      case SBIC_CSR_MIS     | STATUS_PHASE:
      case SBIC_CSR_MIS_1   | STATUS_PHASE:
      case SBIC_CSR_MIS_2   | STATUS_PHASE:
        {
            SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);

            /*
             * this should be the normal i/o completion case.
             * get the status & cmd complete msg then let the
             * device driver look at what happened.
             */
            sbicxfdone(dev);

#ifdef DEBUG
            dev->sc_dmatimo = 0;
            if ( data_pointer_debug > 1 )
                printf("next dmastop: %d(%x:%x)\n", dev->target,
                                                    dev->sc_cur->dc_addr,
                                                    dev->sc_tcnt);
#endif
            /*
             * Stop the DMA chip
             */
            dev->sc_dmastop(dev);

            dev->sc_flags &= ~(SBICF_INDMA | SBICF_DCFLUSH);

            /*
             * Indicate to the upper layers that the command is done
             */
            sbic_scsidone(acb, dev->sc_stat[0]);

            return SBIC_STATE_DONE;
        }

      case SBIC_CSR_XFERRED | DATA_OUT_PHASE:
      case SBIC_CSR_XFERRED | DATA_IN_PHASE:
      case SBIC_CSR_MIS     | DATA_OUT_PHASE:
      case SBIC_CSR_MIS     | DATA_IN_PHASE:
      case SBIC_CSR_MIS_1   | DATA_OUT_PHASE:
      case SBIC_CSR_MIS_1   | DATA_IN_PHASE:
      case SBIC_CSR_MIS_2   | DATA_OUT_PHASE:
      case SBIC_CSR_MIS_2   | DATA_IN_PHASE:
        {
            /*
             * Verify that we expected to transfer data...
             */
            if ( acb->sc_kv.dc_count <= 0 ) {
                printf("next: DATA phase with xfer count == %d, asr:0x%02x csr:0x%02x\n",
                        acb->sc_kv.dc_count, asr, csr);
                goto abort;
            }

            /*
             * Should we transfer using PIO or DMA ?
             */
            if ( dev->sc_xs->flags & SCSI_POLL || dev->sc_flags & SBICF_ICMD ||
                 acb->sc_dmacmd == 0 ) {

                /*
                 * Do PIO transfer
                 */
                int     i;

#ifdef DEBUG
                if ( data_pointer_debug > 1 )
                    printf("next PIO: %d(%x:%x)\n", dev->target,
                                                    acb->sc_kv.dc_addr,
                                                    acb->sc_kv.dc_count);
#endif

                if ( SBIC_PHASE(csr) == DATA_IN_PHASE )
                    /*
                     * data in
                     */
                    i = sbicxfin(regs, acb->sc_kv.dc_count,
                                       acb->sc_kv.dc_addr);
                else
                    /*
                     * data out
                     */
                    i = sbicxfout(regs, acb->sc_kv.dc_count,
                                        acb->sc_kv.dc_addr);

                acb->sc_kv.dc_addr += (acb->sc_kv.dc_count - i);
                acb->sc_kv.dc_count = i;

                /*
                 * Update current count...
                 */
                acb->sc_tcnt = dev->sc_tcnt = i;

                dev->sc_flags &= ~SBICF_INDMA;

            } else {

                /*
                 * Do DMA transfer
                 * set next dma addr and dec count
                 */
                sbic_save_ptrs(dev);
                sbic_load_ptrs(dev);

                SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI |
                                       SBIC_MACHINE_DMA_MODE);

#ifdef DEBUG
                dev->sc_dmatimo = 1;
                if ( data_pointer_debug > 1 )
                    printf("next DMA: %d(%x:%x)\n", dev->target,
                                                    dev->sc_cur->dc_addr,
                                                    dev->sc_tcnt);
#endif
                /*
                 * Start the DMA chip going
                 */
                dev->sc_tcnt = dev->sc_dmanext(dev);

                /*
                 * Tell the WD chip how much to transfer this time around
                 */
                SBIC_TC_PUT(regs, (unsigned)dev->sc_tcnt);

                /*
                 * Start the transfer
                 */
                SET_SBIC_cmd(regs, SBIC_CMD_XFER_INFO);

                /*
                 * Indicate that we're in DMA mode
                 */
                dev->sc_flags |= SBICF_INDMA;
            }
        }
        break;

      case SBIC_CSR_XFERRED | MESG_IN_PHASE:
      case SBIC_CSR_MIS     | MESG_IN_PHASE:
      case SBIC_CSR_MIS_1   | MESG_IN_PHASE:
      case SBIC_CSR_MIS_2   | MESG_IN_PHASE:
        {
            sbic_save_ptrs(dev);

            /*
             * Handle a single message in...
             */
            return sbicmsgin(dev);
        }

      case SBIC_CSR_MSGIN_W_ACK:
        {
            /*
             * We should never see this since it's handled in 'sbicmsgin()'
             * but just for the sake of paranoia...
             */
            SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK); /* Dunno what I'm ACKing */
            printf("Acking unknown msgin CSR:%02x",csr);
        }
        break;

      case SBIC_CSR_XFERRED | MESG_OUT_PHASE:
      case SBIC_CSR_MIS     | MESG_OUT_PHASE:
      case SBIC_CSR_MIS_1   | MESG_OUT_PHASE:
      case SBIC_CSR_MIS_2   | MESG_OUT_PHASE:
        {
            /*
             * We only ever handle a message out phase here for sending a
             * REJECT message.
             */
            sbic_save_ptrs(dev);

#ifdef DEBUG
            if (sync_debug)
                printf ("sending REJECT msg to last msg.\n");
#endif

            SEND_BYTE(regs, MSG_REJECT);
            WAIT_CIP(regs);
        }
        break;

      case SBIC_CSR_DISC:
      case SBIC_CSR_DISC_1:
        {
            /*
             * Try to schedule another target
             */
            sbic_save_ptrs(dev);

            dev->sc_flags &= ~SBICF_SELECTED;

#ifdef DEBUG
            if ( reselect_debug > 1 )
                printf("sbicnext target %d disconnected\n", dev->target);
#endif

            TAILQ_INSERT_HEAD(&dev->nexus_list, acb, chain);

            ++dev->sc_tinfo[dev->target].dconns;

            dev->sc_nexus = NULL;
            dev->sc_xs    = NULL;

            if ( acb->xs->flags & SCSI_POLL || dev->sc_flags & SBICF_ICMD ||
                                               !sbic_parallel_operations )
                return SBIC_STATE_DISCONNECT;

            QPRINTF(("sbicnext: calling sbic_sched\n"));

            sbic_sched(dev);

            QPRINTF(("sbicnext: sbic_sched returned\n"));

            return SBIC_STATE_DISCONNECT;
        }

      case SBIC_CSR_RSLT_NI:
      case SBIC_CSR_RSLT_IFY:
        {
            /*
             * A reselection.
             * Note that since we don't enable Advanced Features (assuming
             * the WD chip is at least the 'A' revision), we're only ever
             * likely to see the 'SBIC_CSR_RSLT_NI' status. But for the
             * hell of it, we'll handle it anyway, for all the extra code
             * it needs...
             */
            u_char  newtarget,
                    newlun;

            GET_SBIC_rselid(regs, newtarget);

            /*
             * check SBIC_RID_SIV?
             */
            newtarget &= SBIC_RID_MASK;

            if ( csr == SBIC_CSR_RSLT_IFY ) {

                /*
                 * Read Identify msg to avoid lockup
                 */
                GET_SBIC_data(regs, newlun);
                WAIT_CIP(regs);
                newlun &= SBIC_TLUN_MASK;

            } else {

                /*
                 * Need to read Identify message the hard way, assuming
                 * the target even sends us one...
                 */
                for (newlun = 255; newlun; --newlun) {
                    GET_SBIC_asr(regs, asr);
                    if (asr & SBIC_ASR_INT)
                        break;
                    delay(10);
                }

                /*
                 * If we didn't get an interrupt, somethink's up
                 */
                if ( (asr & SBIC_ASR_INT) == 0 ) {
                    printf("%s: Reselect without identify? asr %x\n",
                            dev->sc_dev.dv_xname, asr);
                    newlun = 0; /* XXXX */
                } else {
                    /*
                     * We got an interrupt, verify that it's a change to
                     * message in phase, and if so read the message.
                     */
                    GET_SBIC_csr(regs,csr);

                    if (csr == (SBIC_CSR_MIS   | MESG_IN_PHASE) ||
                        csr == (SBIC_CSR_MIS_1 | MESG_IN_PHASE) ||
                        csr == (SBIC_CSR_MIS_2 | MESG_IN_PHASE)) {
                        /*
                         * Yup, gone to message in. Fetch the target LUN
                         */
                        sbicmsgin(dev);
                        newlun = dev->sc_msg[0] & 0x07;

                    } else {
                        /*
                         * Whoops! Target didn't go to message in phase!!
                         */
                        printf("RSLT_NI - not MESG_IN_PHASE %x\n", csr);
                        newlun = 0; /* XXXSCW */
                    }
                }
            }

            /*
             * Ok, we have the identity of the reselecting target.
             */
#ifdef DEBUG
            if ( reselect_debug > 1 ||
                (reselect_debug && csr == SBIC_CSR_RSLT_NI) ) {
                printf("sbicnext: reselect %s from targ %d lun %d\n",
                        csr == SBIC_CSR_RSLT_NI ? "NI" : "IFY", newtarget, newlun);
            }
#endif

            if ( dev->sc_nexus ) {
                /*
                 * Whoops! We've been reselected with an command in progress!
                 * The best we can do is to put the current command back on the
                 * ready list and hope for the best.
                 */
#ifdef DEBUG
                if ( reselect_debug > 1 ) {
                    printf("%s: reselect %s with active command\n",
                        dev->sc_dev.dv_xname,
                        csr == SBIC_CSR_RSLT_NI ? "NI" : "IFY");
                }
#endif

                TAILQ_INSERT_HEAD(&dev->ready_list, dev->sc_nexus, chain);

                dev->sc_tinfo[dev->target].lubusy &= ~(1 << dev->lun);

                dev->sc_nexus = NULL;
                dev->sc_xs    = NULL;
            }

            /*
             * Reload sync values for this target
             */
            if ( dev->sc_sync[newtarget].state == SYNC_DONE )
                SET_SBIC_syn(regs, SBIC_SYN (dev->sc_sync[newtarget].offset,
                                             dev->sc_sync[newtarget].period));
            else
                SET_SBIC_syn(regs, SBIC_SYN (0, sbic_min_period));

            /*
             * Loop through the nexus list until we find the saved entry
             * for the reselecting target...
             */
	    TAILQ_FOREACH(acb, &dev->nexus_list, chain) {

                if ( acb->xs->sc_link->target == newtarget &&
                     acb->xs->sc_link->lun    == newlun) {
                    /*
                     * We've found the saved entry. Dequeue it, and 
                     * make it current again.
                     */
                    TAILQ_REMOVE(&dev->nexus_list, acb, chain);

                    dev->sc_nexus  = acb;
                    dev->sc_xs     = acb->xs;
                    dev->sc_flags |= SBICF_SELECTED;
                    dev->target    = newtarget;
                    dev->lun       = newlun;
                    break;
                }
            }

            if ( acb == NULL ) {
                printf("%s: reselect %s targ %d not in nexus_list %p\n",
                        dev->sc_dev.dv_xname,
                        csr == SBIC_CSR_RSLT_NI ? "NI" : "IFY", newtarget,
                        &TAILQ_FIRST(&dev->nexus_list));
                panic("bad reselect in sbic");
            }

            if ( csr == SBIC_CSR_RSLT_IFY )
                SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);
        }
        break;

      default:
        abort:
        {
            /*
             * Something unexpected happened -- deal with it.
             */
            printf("next: aborting asr 0x%02x csr 0x%02x\n", asr, csr);

#ifdef DDB
            Debugger();
#endif

#ifdef DEBUG
            dev->sc_dmatimo = 0;
            if ( data_pointer_debug > 1 )
                printf("next dmastop: %d(%x:%x)\n", dev->target,
                                                    dev->sc_cur->dc_addr,
                                                    dev->sc_tcnt);
#endif

            dev->sc_dmastop(dev);
            SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);
            if ( dev->sc_xs ) sbicerror(dev, csr);
            sbicabort(dev, "next");

            if ( dev->sc_flags & SBICF_INDMA ) {
                dev->sc_flags &= ~(SBICF_INDMA | SBICF_DCFLUSH);

#ifdef DEBUG
                dev->sc_dmatimo = 0;
                if ( data_pointer_debug > 1 )
                    printf("next dmastop: %d(%x:%x)\n", dev->target,
                                                        dev->sc_cur->dc_addr,
                                                        dev->sc_tcnt);
#endif
                sbic_scsidone(acb, -1);
            }

            return SBIC_STATE_ERROR;
        }
    }

    return(SBIC_STATE_RUNNING);
}


/*
 * Check if DMA can not be used with specified buffer
 */
int
sbiccheckdmap(bp, len, mask)
    void    *bp;
    u_long  len,
            mask;
{
    u_char  *buffer;
    u_long  phy_buf;
    u_long  phy_len;

    buffer = bp;

    if ( len == 0 )
        return(1);

    while ( len ) {

        phy_buf = kvtop((vaddr_t)buffer);
        phy_len = NBPG - ((int) buffer & PGOFSET);

        if ( len < phy_len )
            phy_len = len;

        if ( phy_buf & mask )
            return(1);

        buffer += phy_len;
        len    -= phy_len;
    }

    return(0);
}

int
sbictoscsiperiod(dev, a)
    struct sbic_softc   *dev;
    int                 a;
{
    unsigned int fs;

    /*
     * cycle = DIV / (2 * CLK)
     * DIV = FS + 2
     * best we can do is 200ns at 20MHz, 2 cycles
     */

    GET_SBIC_myid(dev->sc_sbicp, fs);

    fs = (fs >> 6) + 2;         /* DIV */

    fs = (fs * 10000) / (dev->sc_clkfreq << 1); /* Cycle, in ns */

    if ( a < 2 )
        a = 8;                  /* map to Cycles */

    return ( (fs * a) >> 2 );   /* in 4 ns units */
}

int
sbicfromscsiperiod(dev, p)
    struct sbic_softc   *dev;
    int                 p;
{
    unsigned    fs,
                ret;

    /*
     * Just the inverse of the above
     */
    GET_SBIC_myid(dev->sc_sbicp, fs);

    fs = (fs >> 6) + 2;     /* DIV */

    fs = (fs * 10000) / (dev->sc_clkfreq << 1); /* Cycle, in ns */

    ret = p << 2;           /* in ns units */
    ret = ret / fs;         /* in Cycles */

    if ( ret < sbic_min_period )
        return(sbic_min_period);

    /*
     * verify rounding
     */
    if ( sbictoscsiperiod(dev, ret) < p )
        ret++;

    return( (ret >= 8) ? 0 : ret );
}

#ifdef DEBUG
void
sbictimeout(dev)
    struct sbic_softc   *dev;
{
    int     s,
            asr;

    s = splbio();

    if ( dev->sc_dmatimo ) {

        if ( dev->sc_dmatimo > 1 ) {

            printf("%s: dma timeout #%d\n", dev->sc_dev.dv_xname,
                                            dev->sc_dmatimo - 1);

            GET_SBIC_asr(dev->sc_sbicp, asr);

            if ( asr & SBIC_ASR_INT ) {
                /*
                 * We need to service a missed IRQ
                 */
                sbicintr(dev);
            } else {
                (void) sbicabort(dev, "timeout");
                splx(s);
                return;
            }
        }

        dev->sc_dmatimo++;
    }

    splx(s);

    timeout((void *)sbictimeout, dev, 30 * hz);
}
#endif
@


1.29
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.28 2010/06/29 21:12:01 krw Exp $ */
@


1.28
log
@Shrink struct scsi_sense_data and thus the sense member of scsi_xfer,
to 18 bytes by removing the extra_bytes field. sbic.c was the only
consumer, and that was in a DEBUG message.

18 bytes is the minimum length mandated by the SCSI spec. Anything
more is vendor/device specific information.

This fixes a usb key that yuo@@ had, and probably others.

Any device that decides to pay attention to extra sense data must
allocate its own space.

ok marco@@ matthew@@ miod@@ yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.27 2010/05/20 00:55:17 krw Exp $ */
a57 1
#include <sys/dkstat.h>
@


1.27
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.26 2010/03/27 16:04:24 miod Exp $ */
d598 1
a598 2
            printf(" => %02x %02x\n", xs->sense.flags, 
			xs->sense.extra_bytes[3]);
@


1.26
log
@Fix fallout of the scsi_cmd() interface change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.25 2010/03/23 01:57:19 krw Exp $ */
a370 1
	s = splbio();
a371 1
	splx(s);
@


1.25
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.24 2010/01/09 23:15:06 krw Exp $ */
d342 1
a342 1
int
@


1.24
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.23 2009/11/22 20:16:43 krw Exp $ */
d370 5
a374 1
        return (NO_CCB);
d426 1
a426 1
        return(COMPLETE);
a438 2

    return(SUCCESSFULLY_QUEUED);
@


1.23
log
@Remove only use in the tree of ESCAPE_NOT_SUPPORTED. Which, ironically,
wasn't supported. Nuke #define of ESCAPE_NOT_SUPPORTED at the same
time.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.22 2009/02/16 21:19:06 miod Exp $ */
a604 2

    xs->flags |= ITSDONE;
@


1.22
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.21 2008/11/25 17:52:02 krw Exp $ */
a353 3

    if ( slp->target == slp->adapter_target )
        return ESCAPE_NOT_SUPPORTED;
@


1.21
log
@Another bunch of TRY_AGAIN_LATER -> NO_CCB when no I/O could be started.

"looks sane to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.20 2008/09/12 11:14:02 miod Exp $ */
a152 15


/*
 * default minphys routine for sbic based controllers
 */
void
sbic_minphys(bp)
    struct buf *bp;
{
    /*
     * No max transfer at this level.
     */
    minphys(bp);
}

@


1.20
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.19 2007/05/29 13:56:14 pyr Exp $ */
d388 1
a388 1
        return(TRY_AGAIN_LATER);
@


1.19
log
@TAILQ_LAST takes two arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.18 2007/05/28 22:17:21 pyr Exp $ */
a365 3

    if ( flags & SCSI_DATA_UIO )
        panic("sbic: scsi data uio requested");
@


1.18
log
@avoid bypassing sys/queue.h in many places in the kernel.
many assumptions were made about the way the various list types are
implemented.

lots of suggestions and help from otto and miod.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.17 2005/12/03 18:09:37 krw Exp $ */
d647 1
a647 1
    if (TAILQ_LAST(&dev->ready_list) == TAILQ_NEXT(acb, chain)) {
@


1.17
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.16 2004/12/25 23:02:24 miod Exp $ */
d60 1
d647 1
a647 1
    if ( dev->ready_list.tqh_last == &acb->chain.tqe_next ) {
@


1.16
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.15 2003/12/20 00:34:28 miod Exp $ */
a389 2
        xs->error = XS_DRIVER_STUFFUP;

@


1.15
log
@Passl -Wformat. Fix some blatant -Wuninitialized errors as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.14 2003/11/03 06:54:25 david Exp $ */
d377 1
a377 1
    if ( (acb = dev->free_list.tqh_first) != NULL )
d485 1
a485 1
    for (acb = dev->ready_list.tqh_first; acb; acb = acb->chain.tqe_next) {
d644 1
a644 1
        if ( dev->ready_list.tqh_first )
d656 1
a656 1
        for (a = dev->nexus_list.tqh_first; a; a = a->chain.tqe_next) {
d666 1
a666 1
        else if ( acb->chain.tqe_next ) {
d1078 1
a1078 1
    if ( !sbic_enable_reselect && dev->nexus_list.tqh_first == NULL)
d2495 1
a2495 2
            for (acb = dev->nexus_list.tqh_first; acb;
                                                  acb = acb->chain.tqe_next) {
d2518 1
a2518 1
                        &dev->nexus_list.tqh_first);
@


1.14
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.13 2003/06/02 23:27:50 millert Exp $ */
d1608 1
a1608 1
        printf("sbic: DMA buffer mapping changed %x->%x\n",
d1751 1
a1751 1
                        csr;
d2516 1
a2516 1
                printf("%s: reselect %s targ %d not in nexus_list %x\n",
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.12 2003/02/11 19:20:26 mickey Exp $ */
d1087 1
a1087 1
     * If it doesn't support message out, it definately doesn't
@


1.12
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.11 2002/04/27 23:21:05 miod Exp $ */
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by the University of
 *  California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.10 2002/03/14 03:15:56 millert Exp $ */
d2624 1
a2624 1
     * best we can do is 200ns at 20Mhz, 2 cycles
@


1.10
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.9 2002/03/14 01:26:37 millert Exp $ */
a91 2
extern u_int kvtop();

d114 1
d315 1
a315 1
        paddr = acb->sc_pa.dc_addr = (char *) kvtop(vaddr);
d319 1
a319 1
                     (char *)kvtop(vaddr + count + 4) == paddr + count + 4;
d408 1
a408 1
    acb->pa_addr        = xs->data ? (char *)kvtop(xs->data) : 0;
d601 1
a601 1
            acb->pa_addr        = (char *)kvtop(&xs->sense); /* XXX check */
d1611 1
a1611 1
    if ( count && ((char *)kvtop(addr) != acb->sc_pa.dc_addr) ) {
d1613 1
a1613 1
                acb->sc_pa.dc_addr, kvtop(addr));
d2434 3
a2436 3
                    if ( csr == SBIC_CSR_MIS   | MESG_IN_PHASE ||
                         csr == SBIC_CSR_MIS_1 | MESG_IN_PHASE ||
                         csr == SBIC_CSR_MIS_2 | MESG_IN_PHASE ) {
d2598 1
a2598 1
        phy_buf = kvtop(buffer);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.8 2001/11/06 02:49:22 art Exp $ */
d320 1
a320 1
                     (char*)kvtop(vaddr + count + 4) == paddr + count + 4;
@


1.8
log
@remove the last uses of vm/vm_page.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.7 2001/09/11 20:05:24 miod Exp $ */
d94 22
a115 22
int     sbicicmd            __P((struct sbic_softc *, void *, int, void *, int));
int     sbicgo              __P((struct sbic_softc *, struct scsi_xfer *));
int     sbicdmaok           __P((struct sbic_softc *, struct scsi_xfer *));
int     sbicwait            __P((sbic_regmap_p, u_char, int , int));
int     sbiccheckdmap       __P((void *, u_long, u_long));
u_char  sbicselectbus       __P((struct sbic_softc *));
int     sbicxfout           __P((sbic_regmap_p, int, void *));
int     sbicxfin            __P((sbic_regmap_p, int, void *));
int     sbicfromscsiperiod  __P((struct sbic_softc *, int));
int     sbictoscsiperiod    __P((struct sbic_softc *, int));
int     sbicintr            __P((struct sbic_softc *));
int     sbicpoll            __P((struct sbic_softc *));
int     sbicnextstate       __P((struct sbic_softc *, u_char, u_char));
int     sbicmsgin           __P((struct sbic_softc *));
int     sbicabort           __P((struct sbic_softc *, char *));
void    sbicxfdone          __P((struct sbic_softc *));
void    sbicerror           __P((struct sbic_softc *,u_char));
void    sbicreset           __P((struct sbic_softc *));
void    sbic_scsidone       __P((struct sbic_acb *, int));
void    sbic_sched          __P((struct sbic_softc *));
void    sbic_save_ptrs      __P((struct sbic_softc *));
void    sbic_load_ptrs      __P((struct sbic_softc *));
d152 1
a152 1
void    sbictimeout __P((struct sbic_softc *dev));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.8 2001/11/06 02:49:22 art Exp $ */
d92 24
a115 23
int     sbicicmd(struct sbic_softc *, void *, int, void *, int);
int     sbicgo(struct sbic_softc *, struct scsi_xfer *);
int     sbicdmaok(struct sbic_softc *, struct scsi_xfer *);
int     sbicwait(sbic_regmap_p, u_char, int , int);
int     sbiccheckdmap(void *, u_long, u_long);
u_char  sbicselectbus(struct sbic_softc *);
int     sbicxfout(sbic_regmap_p, int, void *);
int     sbicxfin(sbic_regmap_p, int, void *);
int     sbicfromscsiperiod(struct sbic_softc *, int);
int     sbictoscsiperiod(struct sbic_softc *, int);
int     sbicintr(struct sbic_softc *);
int     sbicpoll(struct sbic_softc *);
int     sbicnextstate(struct sbic_softc *, u_char, u_char);
int     sbicmsgin(struct sbic_softc *);
int     sbicabort(struct sbic_softc *, char *);
void    sbicxfdone(struct sbic_softc *);
void    sbicerror(struct sbic_softc *,u_char);
void    sbicreset(struct sbic_softc *);
void    sbic_scsidone(struct sbic_acb *, int);
void    sbic_sched(struct sbic_softc *);
void    sbic_save_ptrs(struct sbic_softc *);
void    sbic_load_ptrs(struct sbic_softc *);
void    sbicinit(struct sbic_softc *);
d152 1
a152 1
void    sbictimeout(struct sbic_softc *dev);
d316 1
a316 1
        paddr = acb->sc_pa.dc_addr = (char *)kvtop((vaddr_t)vaddr);
d320 1
a320 1
                (char *)kvtop((vaddr_t)vaddr + count + 4) == paddr + count + 4;
d409 1
a409 1
    acb->pa_addr        = xs->data ? (char *)kvtop((vaddr_t)xs->data) : 0;
d602 1
a602 1
            acb->pa_addr        = (char *)kvtop((vaddr_t)&xs->sense); /* XXX check */
d1612 1
a1612 1
    if ( count && ((char *)kvtop((vaddr_t)addr) != acb->sc_pa.dc_addr) ) {
d1614 1
a1614 1
                acb->sc_pa.dc_addr, kvtop((vaddr_t)addr));
d2435 3
a2437 3
                    if (csr == (SBIC_CSR_MIS   | MESG_IN_PHASE) ||
                        csr == (SBIC_CSR_MIS_1 | MESG_IN_PHASE) ||
                        csr == (SBIC_CSR_MIS_2 | MESG_IN_PHASE)) {
d2599 1
a2599 1
        phy_buf = kvtop((vaddr_t)buffer);
@


1.8.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d2624 1
a2624 1
     * best we can do is 200ns at 20MHz, 2 cycles
@


1.7
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.6 2000/11/10 15:33:07 provos Exp $ */
d66 1
a66 4
#include <vm/vm.h>
#include <vm/vm_page.h>
#include <vm/pmap.h>
#include <machine/pmap.h>
@


1.6
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.5 1997/11/24 01:13:51 mickey Exp $ */
a66 1
#include <vm/vm_kern.h>
@


1.5
log
@partially apply that dk_* pr
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.4 1996/05/10 12:42:02 deraadt Exp $ */
d1017 1
a1017 1
     * wait for select (merged from seperate function may need
@


1.5.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.6 2000/11/10 15:33:07 provos Exp $ */
d1017 1
a1017 1
     * wait for select (merged from separate function may need
@


1.5.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.5.10.1 2001/04/18 16:10:26 niklas Exp $ */
d67 1
@


1.5.10.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d66 4
a69 1
#include <uvm/uvm_extern.h>
@


1.5.10.4
log
@Merge in -current from about a week ago
@
text
@d94 22
a115 22
int     sbicicmd(struct sbic_softc *, void *, int, void *, int);
int     sbicgo(struct sbic_softc *, struct scsi_xfer *);
int     sbicdmaok(struct sbic_softc *, struct scsi_xfer *);
int     sbicwait(sbic_regmap_p, u_char, int , int);
int     sbiccheckdmap(void *, u_long, u_long);
u_char  sbicselectbus(struct sbic_softc *);
int     sbicxfout(sbic_regmap_p, int, void *);
int     sbicxfin(sbic_regmap_p, int, void *);
int     sbicfromscsiperiod(struct sbic_softc *, int);
int     sbictoscsiperiod(struct sbic_softc *, int);
int     sbicintr(struct sbic_softc *);
int     sbicpoll(struct sbic_softc *);
int     sbicnextstate(struct sbic_softc *, u_char, u_char);
int     sbicmsgin(struct sbic_softc *);
int     sbicabort(struct sbic_softc *, char *);
void    sbicxfdone(struct sbic_softc *);
void    sbicerror(struct sbic_softc *,u_char);
void    sbicreset(struct sbic_softc *);
void    sbic_scsidone(struct sbic_acb *, int);
void    sbic_sched(struct sbic_softc *);
void    sbic_save_ptrs(struct sbic_softc *);
void    sbic_load_ptrs(struct sbic_softc *);
d152 1
a152 1
void    sbictimeout(struct sbic_softc *dev);
d320 1
a320 1
                     (char *)kvtop(vaddr + count + 4) == paddr + count + 4;
@


1.5.10.5
log
@Sync the SMP branch with 3.3
@
text
@d92 2
a115 1
void    sbicinit(struct sbic_softc *);
d316 1
a316 1
        paddr = acb->sc_pa.dc_addr = (char *)kvtop((vaddr_t)vaddr);
d320 1
a320 1
                (char *)kvtop((vaddr_t)vaddr + count + 4) == paddr + count + 4;
d409 1
a409 1
    acb->pa_addr        = xs->data ? (char *)kvtop((vaddr_t)xs->data) : 0;
d602 1
a602 1
            acb->pa_addr        = (char *)kvtop((vaddr_t)&xs->sense); /* XXX check */
d1612 1
a1612 1
    if ( count && ((char *)kvtop((vaddr_t)addr) != acb->sc_pa.dc_addr) ) {
d1614 1
a1614 1
                acb->sc_pa.dc_addr, kvtop((vaddr_t)addr));
d2435 3
a2437 3
                    if (csr == (SBIC_CSR_MIS   | MESG_IN_PHASE) ||
                        csr == (SBIC_CSR_MIS_1 | MESG_IN_PHASE) ||
                        csr == (SBIC_CSR_MIS_2 | MESG_IN_PHASE)) {
d2599 1
a2599 1
        phy_buf = kvtop((vaddr_t)buffer);
d2625 1
a2625 1
     * best we can do is 200ns at 20MHz, 2 cycles
@


1.5.10.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbic.c,v 1.5.10.5 2003/03/27 23:32:16 niklas Exp $ */
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.10.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1087 1
a1087 1
     * If it doesn't support message out, it definitely doesn't
d1608 1
a1608 1
        printf("sbic: DMA buffer mapping changed %p->%lx\n",
d1751 1
a1751 1
                        csr = 0;
d2516 1
a2516 1
                printf("%s: reselect %s targ %d not in nexus_list %p\n",
@


1.4
log
@fix sync scsi
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a567 4

    if ( slp->device_softc &&
        ((struct device *)(slp->device_softc))->dv_unit < dk_ndrive)
        ++dk_xfer[((struct device *)(slp->device_softc))->dv_unit];
@


1.3
log
@wdsc driver hacked from amiga driver by Steve Woodford
@
text
@d2 1
d810 1
a810 1
            return -1;
d830 1
a830 1
    return -1;
a1007 9
    /*
     * set sync or async
     */
    if ( dev->sc_sync[target].state == SYNC_DONE )
        SET_SBIC_syn(regs, SBIC_SYN(dev->sc_sync[target].offset,
                                    dev->sc_sync[target].period));
    else
        SET_SBIC_syn(regs, SBIC_SYN(0, sbic_min_period));

d1089 1
a1089 1
     * Select-and-Xfer-with-ATN command to initialte a selection...
d1167 21
d1192 12
a1203 1
 * Information Transfer *to* a Scsi Target
d1250 1
a1250 4
    } while ( (asr & SBIC_ASR_INT) == 0 && wait-- > 0 );

    SBIC_TC_GET(regs, len);
    SBIC_TC_PUT(regs, 0);
d1257 1
a1257 1
     * this leaves with one csr to be read
d1326 4
d1343 4
a1346 1
    int             still_busy = 1;
d1383 2
a1384 1
        if ( (dev->sc_flags & SBICF_SELECTED) == 0 ) {
d1390 1
d1392 6
d1399 1
a1399 1
        QPRINTF((">ASR:0x%02x CSR:0x%02x <", asr, csr));
d1401 5
a1405 1
        switch ( csr ) {
d1407 7
a1413 13
          case SBIC_CSR_S_XFERRED:
          case SBIC_CSR_DISC:
          case SBIC_CSR_DISC_1:
            {
                u_char  phase;

                dev->sc_flags &= ~SBICF_SELECTED;
                GET_SBIC_cmd_phase (regs, phase);

                if ( phase == 0x60 ) {
                    GET_SBIC_tlun (regs, dev->sc_stat[0]);
                    still_busy = 0; /* done */
                } else {
d1415 2
a1416 2
                    if ( reselect_debug > 1 )
                        printf("sbicicmd: handling disconnect\n");
d1418 2
a1419 1
                    still_busy = SBIC_STATE_DISCONNECT;
d1421 1
a1421 2
            }
            break;
d1423 9
a1431 9
          case SBIC_CSR_XFERRED | CMD_PHASE:
          case SBIC_CSR_MIS     | CMD_PHASE:
          case SBIC_CSR_MIS_1   | CMD_PHASE:
          case SBIC_CSR_MIS_2   | CMD_PHASE:
            {
                if ( sbicxfout(regs, clen, cbuf) )
                    still_busy = sbicabort(dev, "icmd sending cmd");
            }
            break;
d1433 9
a1441 9
          case SBIC_CSR_XFERRED | STATUS_PHASE:
          case SBIC_CSR_MIS     | STATUS_PHASE:
          case SBIC_CSR_MIS_1   | STATUS_PHASE:
          case SBIC_CSR_MIS_2   | STATUS_PHASE:
            {
                /*
                 * The sbic does the status/cmd-complete reading ok,
                 * so do this with its hi-level commands.
                 */
d1443 2
a1444 2
                if ( sbic_debug )
                    printf("SBICICMD status phase (bsy=%d)\n", still_busy);
d1446 4
a1449 4
                SET_SBIC_cmd_phase(regs, 0x46);
                SET_SBIC_cmd(regs, SBIC_CMD_SEL_ATN_XFER);
            }
            break;
d1451 5
a1455 3
          default:
            {
                still_busy = sbicnextstate(dev, csr, asr);
a1456 2
            break;
        }
d1458 5
a1462 5
        /*
         * make sure the last command was taken,
         * ie. we're not hunting after an ignored command..
         */
        GET_SBIC_asr(regs, asr);
d1464 4
a1467 4
        /*
         * tapes may take a loooong time..
         */
        while (asr & SBIC_ASR_BSY ) {
d1469 2
a1470 2
            if ( asr & SBIC_ASR_DBR ) {
                int     i;
d1472 1
a1472 1
                printf("sbicicmd: Waiting while sbic is jammed, CSR:%02x,ASR:%02x\n", csr,asr);
d1474 1
a1474 1
                Debugger();
d1476 12
a1487 6
                /*
                 * SBIC is jammed
                 * DUNNO which direction
                 * Try old direction
                 */
                GET_SBIC_data(regs, i);
a1488 3

                if ( asr & SBIC_ASR_DBR ) /* Wants us to write */
                    SET_SBIC_data(regs, i);
a1489 2

            GET_SBIC_asr(regs, asr);
d1499 1
a1499 1
        if ( still_busy == 1 ) /* Bsy */
d1505 1
a1505 1
    } while ( still_busy > 0 && dev->sc_stat[0] == 0xff );
d1726 2
a1729 3
        if ( asr & SBIC_ASR_INT )
            GET_SBIC_csr(regs, csr);

d1736 9
a1744 1
        GET_SBIC_asr(regs, asr);
d1792 1
d1804 1
a1804 1
                GET_SBIC_data(regs, i);
d1808 1
a1808 1
                    SET_SBIC_data(regs, i);
d1817 1
a1817 1
        if ( i == 1 ) /* BSY */
d2085 6
d2141 4
a2144 4
 *      0  == done
 *      1  == working
 *      2  == disconnected
 *      -1 == error
d2426 1
a2426 1
                    delay(1);
d2433 2
a2434 4
#ifdef DEBUG
                    if ( reselect_debug )
                        printf("RSLT_NI - no IFFY message? asr %x\n", asr);
#endif
a2435 1

d2704 4
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d4 2
a5 1
 * Copyright (c) 1994 Christian E. Hopps
d22 2
a23 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d40 1
a40 1
 *	@@(#)scsi.c	7.5 (Berkeley) 5/4/91
d44 10
a53 1
 * AMD 33C93 scsi adaptor driver
d68 1
a69 1
#include <machine/autoconf.h>
d73 2
a75 1
#include <vm/pmap.h>
d77 4
a80 2
/* Since I can't find this in any other header files */
#define SCSI_PHASE(reg)	(reg&0x07)
d86 3
a88 3
#define	SBIC_CMD_WAIT	50000	/* wait per step of 'immediate' cmds */
#define	SBIC_DATA_WAIT	50000	/* wait per data in/out step */
#define	SBIC_INIT_WAIT	50000	/* wait per step (both) during init */
d90 3
a92 1
#define	b_cylin		b_resid
d97 22
a118 24
int  sbicicmd __P((struct sbic_softc *, int, int, void *, int, void *, int));
int  sbicgo __P((struct sbic_softc *, struct scsi_xfer *));
int  sbicdmaok __P((struct sbic_softc *, struct scsi_xfer *));
int  sbicwait __P((sbic_regmap_p, char, int , int));
int  sbiccheckdmap __P((void *, u_long, u_long));
int  sbicselectbus __P((struct sbic_softc *, sbic_regmap_p, u_char, u_char, u_char));
int  sbicxfstart __P((sbic_regmap_p, int, u_char, int));
int  sbicxfout __P((sbic_regmap_p regs, int, void *, int));
int  sbicfromscsiperiod __P((struct sbic_softc *, sbic_regmap_p, int));
int  sbictoscsiperiod __P((struct sbic_softc *, sbic_regmap_p, int));
int  sbicintr __P((struct sbic_softc *));
int  sbicpoll __P((struct sbic_softc *));
int  sbicnextstate __P((struct sbic_softc *, u_char, u_char));
int  sbicmsgin __P((struct sbic_softc *));
int  sbicxfin __P((sbic_regmap_p regs, int, void *));
int  sbicabort __P((struct sbic_softc *, sbic_regmap_p, char *));
void sbicxfdone __P((struct sbic_softc *, sbic_regmap_p, int));
void sbicerror __P((struct sbic_softc *, sbic_regmap_p, u_char));
void sbicstart __P((struct sbic_softc *));
void sbicreset __P((struct sbic_softc *));
void sbic_scsidone __P((struct sbic_acb *, int));
void sbic_sched __P((struct sbic_softc *));
void sbic_save_ptrs __P((struct sbic_softc *, sbic_regmap_p,int,int));
void sbic_load_ptrs __P((struct sbic_softc *, sbic_regmap_p,int,int));
d123 5
a127 6
int sbic_min_period = SBIC_SYN_MIN_PERIOD;  /* in cycles = f(ICLK,FSn) */
int sbic_max_offset = SBIC_SYN_MAX_OFFSET;  /* pure number */

int sbic_cmd_wait = SBIC_CMD_WAIT;
int sbic_data_wait = SBIC_DATA_WAIT;
int sbic_init_wait = SBIC_INIT_WAIT;
d133 4
a136 5
int sbic_inhibit_sync = 1;
int sbic_enable_reselect = 1;
int sbic_clock_override = 0;
int sbic_no_dma = 0;
int sbic_parallel_operations = 1;
d138 3
d142 5
a146 6
sbic_regmap_p debug_sbic_regs;
int	sbicdma_ops = 0;	/* total DMA operations */
int	sbicdma_bounces = 0;	/* number operations using bounce buffer */
int	sbicdma_hits = 0;	/* number of DMA chains that were contiguous */
int	sbicdma_misses = 0;	/* number of DMA chains that were not contiguous */
int     sbicdma_saves = 0;
d148 9
a156 9
int	sbic_debug = 0;
int	sync_debug = 0;
int	sbic_dma_debug = 0;
int	reselect_debug = 0;
int	report_sense = 0;
int	data_pointer_debug = 0;
int	sbic_timeout = 0;
u_char	debug_asr, debug_csr, timeout_active=0, routine;
void sbictimeout __P((struct sbic_softc *dev));
d158 1
a158 1
#define QPRINTF
d161 1
d167 1
a167 1
	struct buf *bp;
d169 5
a174 5
	/*
	 * No max transfer at this level.
	 */
	minphys(bp);
}
d180 85
a264 58
sbic_save_ptrs(dev, regs, target, lun)
	struct sbic_softc *dev;
	sbic_regmap_p regs;
	int target, lun;
{
	int count, asr, csr, s;
	unsigned long ptr;
	char *vptr;
	struct sbic_acb* acb;

	extern vm_offset_t vm_first_phys;

	if( !dev->sc_cur ) return;
	if( !(dev->sc_flags & SBICF_INDMA) ) return; /* DMA not active */

	s = splbio();

	acb = dev->sc_nexus;
	count = -1;
	do {
		GET_SBIC_asr(regs, asr);
		if( asr & SBIC_ASR_DBR ) {
			printf("sbic_save_ptrs: asr %02x canceled!\n", asr);
			splx(s);
			return;
		}
	} while( asr & (SBIC_ASR_BSY|SBIC_ASR_CIP) );

	/* Save important state */
	/* must be done before dmastop */
	acb->sc_dmacmd = dev->sc_dmacmd;
	SBIC_TC_GET(regs, count);

	/* Shut down DMA ====CAREFUL==== */
	dev->sc_dmastop(dev);
	dev->sc_flags &= ~SBICF_INDMA;
	SBIC_TC_PUT(regs, 0);

#ifdef DEBUG
	if(!count && sbic_debug) printf("%dcount0",target);
	if(data_pointer_debug == -1)
		printf("SBIC saving target %d data pointers from (%x,%x)%xASR:%02x",
		       target, dev->sc_cur->dc_addr, dev->sc_cur->dc_count,
		       acb->sc_dmacmd, asr);
#endif

	/* Fixup partial xfers */
	acb->sc_kv.dc_addr += (dev->sc_tcnt - count);
	acb->sc_kv.dc_count -= (dev->sc_tcnt - count);
	acb->sc_pa.dc_addr += (dev->sc_tcnt - count);
	acb->sc_pa.dc_count -= ((dev->sc_tcnt - count)>>1);

	acb->sc_tcnt = dev->sc_tcnt = count;
#ifdef DEBUG
	if(data_pointer_debug)
		printf(" at (%x,%x):%x\n",
		       dev->sc_cur->dc_addr, dev->sc_cur->dc_count,count);
	sbicdma_saves++;
d266 2
a267 1
	splx(s);
d274 3
a276 4
void sbic_load_ptrs(dev, regs, target, lun)
	struct sbic_softc *dev;
	sbic_regmap_p regs;
	int target, lun;
d278 2
a279 14
	int i, s, asr, count;
	char* vaddr, * paddr;
	struct sbic_acb *acb;

	acb = dev->sc_nexus;
	if( !acb->sc_kv.dc_count )
		/* No data to xfer */
		return;

	s = splbio();

	dev->sc_last = dev->sc_cur = &acb->sc_pa;
	dev->sc_tcnt = acb->sc_tcnt;
	dev->sc_dmacmd = acb->sc_dmacmd;
d281 69
a349 2
#ifdef DEBUG
	sbicdma_ops++;
a350 6
	if( !dev->sc_tcnt ) {
		/* sc_tcnt == 0 implies end of segment */

		/* do kvm to pa mappings */
		paddr = acb->sc_pa.dc_addr =
			(char *) kvtop(acb->sc_kv.dc_addr);
d352 1
a352 19
		vaddr = acb->sc_kv.dc_addr;
		count = acb->sc_kv.dc_count;
		for(count = (NBPG - ((int)vaddr & PGOFSET));
		    count < acb->sc_kv.dc_count
		    && (char*)kvtop(vaddr + count + 4) == paddr + count + 4;
		    count += NBPG);
		/* If it's all contiguous... */
		if(count > acb->sc_kv.dc_count ) {
			count = acb->sc_kv.dc_count;
#ifdef DEBUG
			sbicdma_hits++;
#endif
		} else {
#ifdef DEBUG
			sbicdma_misses++;
#endif
		}
		acb->sc_tcnt = count;
		acb->sc_pa.dc_count = count >> 1;
d354 1
a354 16
#ifdef DEBUG
		if(data_pointer_debug)
			printf("DMA recalc:kv(%x,%x)pa(%x,%x)\n",
			       acb->sc_kv.dc_addr,
			       acb->sc_kv.dc_count,
			       acb->sc_pa.dc_addr,
			       acb->sc_tcnt);
#endif
	}
	splx(s);
#ifdef DEBUG
	if(data_pointer_debug)
		printf("SBIC restoring target %d data pointers at (%x,%x)%x\n",
		       target, dev->sc_cur->dc_addr, dev->sc_cur->dc_count,
		       dev->sc_dmacmd);
#endif
d366 1
a366 1
	struct scsi_xfer *xs;
d368 8
a375 4
	struct sbic_acb *acb;
	struct sbic_softc *dev;
	struct scsi_link *slp;
	int flags, s, stat;
d377 2
a378 3
	slp = xs->sc_link;
	dev = slp->adapter_softc;
	flags = xs->flags;
d380 2
a381 2
	if (flags & SCSI_DATA_UIO)
		panic("sbic: scsi data uio requested");
d383 1
a383 2
	if (dev->sc_nexus && flags & SCSI_POLL)
		panic("sbic_scsicmd: busy");
d385 2
a386 2
	if (slp->target == slp->adapter_target)
		return ESCAPE_NOT_SUPPORTED;
d388 1
a388 5
	s = splbio();
	acb = dev->free_list.tqh_first;
	if (acb)
		TAILQ_REMOVE(&dev->free_list, acb, chain);
	splx(s);
d390 1
a390 1
	if (acb == NULL) {
d392 2
a393 2
		printf("sbic_scsicmd: unable to queue request for target %d\n",
		    slp->target);
d395 1
a395 1
		Debugger();
d398 65
a462 52
		xs->error = XS_DRIVER_STUFFUP;
		return(TRY_AGAIN_LATER);
	}

	acb->flags = ACB_ACTIVE;
	if (flags & SCSI_DATA_IN)
		acb->flags |= ACB_DATAIN;
	acb->xs = xs;
	bcopy(xs->cmd, &acb->cmd, xs->cmdlen);
	acb->clen = xs->cmdlen;
	acb->sc_kv.dc_addr = xs->data;
	acb->sc_kv.dc_count = xs->datalen;
	acb->pa_addr = xs->data ? (char *)kvtop(xs->data) : 0;	/* XXXX check */

	if (flags & SCSI_POLL) {
		s = splbio();
		/*
		 * This has major side effects -- it locks up the machine
		 */

		dev->sc_flags |= SBICF_ICMD;
		do {
			while(dev->sc_nexus)
				sbicpoll(dev);
			dev->sc_nexus = acb;
			dev->sc_stat[0] = -1;
			dev->sc_xs = xs;
			dev->target = slp->target;
			dev->lun = slp->lun;
			stat = sbicicmd(dev, slp->target, slp->lun,
					&acb->cmd, acb->clen,
					acb->sc_kv.dc_addr, acb->sc_kv.dc_count);
		} while (dev->sc_nexus != acb);
		sbic_scsidone(acb, stat);

		splx(s);
		return(COMPLETE);
	}

	s = splbio();
	TAILQ_INSERT_TAIL(&dev->ready_list, acb, chain);

	if (dev->sc_nexus) {
		splx(s);
		return(SUCCESSFULLY_QUEUED);
	}

	/*
	 * nothing is active, try to start it now.
	 */
	sbic_sched(dev);
	splx(s);
d464 3
a466 6
/* TODO:  add sbic_poll to do SCSI_POLL operations */
#if 0
	if (flags & SCSI_POLL)
		return(COMPLETE);
#endif
	return(SUCCESSFULLY_QUEUED);
d474 1
a474 1
	struct sbic_softc *dev;
d476 68
a543 50
	struct scsi_xfer *xs;
	struct scsi_link *slp;
	struct sbic_acb *acb;
	int flags, /*phase,*/ stat, i;

	if (dev->sc_nexus)
		return;			/* a command is current active */

	for (acb = dev->ready_list.tqh_first; acb; acb = acb->chain.tqe_next) {
		slp = acb->xs->sc_link;
		i = slp->target;
		if (!(dev->sc_tinfo[i].lubusy & (1 << slp->lun))) {
			struct sbic_tinfo *ti = &dev->sc_tinfo[i];

			TAILQ_REMOVE(&dev->ready_list, acb, chain);
			dev->sc_nexus = acb;
			slp = acb->xs->sc_link;
			ti = &dev->sc_tinfo[slp->target];
			ti->lubusy |= (1 << slp->lun);
			acb->sc_pa.dc_addr = acb->pa_addr;	/* XXXX check */
			break;
		}
	}

	if (acb == NULL)
		return;			/* did not find an available command */

	dev->sc_xs = xs = acb->xs;
	slp = xs->sc_link;
	flags = xs->flags;

	if (flags & SCSI_RESET)
		sbicreset(dev);

#ifdef DEBUG
	if( data_pointer_debug > 1 )
		printf("sbic_sched(%d,%d)\n",slp->target,slp->lun);
#endif
	dev->sc_stat[0] = -1;
	dev->target = slp->target;
	dev->lun = slp->lun;
	if ( flags & SCSI_POLL || ( !sbic_parallel_operations
				   && (/*phase == STATUS_PHASE ||*/
				       sbicdmaok(dev, xs) == 0) ) )
		stat = sbicicmd(dev, slp->target, slp->lun, &acb->cmd,
		    acb->clen, acb->sc_kv.dc_addr, acb->sc_kv.dc_count);
	else if (sbicgo(dev, xs) == 0)
		return;
	else
		stat = dev->sc_stat[0];
d545 1
a545 1
	sbic_scsidone(acb, stat);
d550 2
a551 2
	struct sbic_acb *acb;
	int stat;
d553 5
a557 8
	struct scsi_xfer *xs;
	struct scsi_link *slp;
	struct sbic_softc *dev;
	int s, dosched = 0;

	xs = acb->xs;
	slp = xs->sc_link;
	dev = slp->adapter_softc;
d559 2
a560 3
	if (acb == NULL || xs == NULL) {
		printf("sbic_scsidone -- (%d,%d) no scsi_xfer\n",
		       dev->target, dev->lun);
d562 4
a565 1
		Debugger();
d567 67
a633 2
		return;
	}
d635 47
a681 95
#if 1
	if (((struct device *)(slp->device_softc))->dv_unit < dk_ndrive)
		++dk_xfer[((struct device *)(slp->device_softc))->dv_unit];
#endif
	/*
	 * is this right?
	 */
	xs->status = stat;

#ifdef DEBUG
	if( data_pointer_debug > 1 )
		printf("scsidone: (%d,%d)->(%d,%d)%02x\n",
		       slp->target, slp->lun,
		       dev->target,  dev->lun,  stat);
	if( xs->sc_link->target == dev->sc_link.adapter_target )
		panic("target == hostid");
#endif

	if (xs->error == XS_NOERROR && !(acb->flags & ACB_CHKSENSE)) {
		if (stat == SCSI_CHECK) {
			/* Schedule a REQUEST SENSE */
			struct scsi_sense *ss = (void *)&acb->cmd;
#ifdef DEBUG
			if (report_sense)
				printf("sbic_scsidone: autosense %02x targ %d lun %d",
				    acb->cmd.opcode, slp->target, slp->lun);
#endif
			bzero(ss, sizeof(*ss));
			ss->opcode = REQUEST_SENSE;
			ss->byte2 = slp->lun << 5;
			ss->length = sizeof(struct scsi_sense_data);
			acb->clen = sizeof(*ss);
			acb->sc_kv.dc_addr = (char *)&xs->sense;
			acb->sc_kv.dc_count = sizeof(struct scsi_sense_data);
			acb->pa_addr = (char *)kvtop(&xs->sense); /* XXX check */
			acb->flags = ACB_ACTIVE | ACB_CHKSENSE | ACB_DATAIN;
			TAILQ_INSERT_HEAD(&dev->ready_list, acb, chain);
			dev->sc_tinfo[slp->target].lubusy &=
			    ~(1 << slp->lun);
			dev->sc_tinfo[slp->target].senses++;
			if (dev->sc_nexus == acb) {
				dev->sc_nexus = NULL;
				sbic_sched(dev);
			}
			return;
		}
	}
	if (xs->error == XS_NOERROR && (acb->flags & ACB_CHKSENSE)) {
		xs->error = XS_SENSE;
#ifdef DEBUG
		if (report_sense)
			printf(" => %02x %02x\n", xs->sense.extended_flags,
			    xs->sense.extended_extra_bytes[3]);
#endif
	} else {
		xs->resid = 0;		/* XXXX */
	}
#if whataboutthisone
		case SCSI_BUSY:
			xs->error = XS_BUSY;
			break;
#endif
	xs->flags |= ITSDONE;

	/*
	 * Remove the ACB from whatever queue it's on.  We have to do a bit of
	 * a hack to figure out which queue it's on.  Note that it is *not*
	 * necessary to cdr down the ready queue, but we must cdr down the
	 * nexus queue and see if it's there, so we can mark the unit as no
	 * longer busy.  This code is sickening, but it works.
	 */
	if (acb == dev->sc_nexus) {
		dev->sc_nexus = NULL;
		dev->sc_tinfo[slp->target].lubusy &= ~(1<<slp->lun);
		if (dev->ready_list.tqh_first)
			dosched = 1;	/* start next command */
	} else if (dev->ready_list.tqh_last == &acb->chain.tqe_next) {
		TAILQ_REMOVE(&dev->ready_list, acb, chain);
	} else {
		register struct sbic_acb *acb2;
		for (acb2 = dev->nexus_list.tqh_first; acb2;
		    acb2 = acb2->chain.tqe_next)
			if (acb2 == acb) {
				TAILQ_REMOVE(&dev->nexus_list, acb, chain);
				dev->sc_tinfo[slp->target].lubusy
					&= ~(1<<slp->lun);
				break;
			}
		if (acb2)
			;
		else if (acb->chain.tqe_next) {
			TAILQ_REMOVE(&dev->ready_list, acb, chain);
		} else {
			printf("%s: can't find matching acb\n",
			    dev->sc_dev.dv_xname);
d683 1
a683 1
			Debugger();
d685 2
a686 5
		}
	}
	/* Put it on the free list. */
	acb->flags = ACB_FREE;
	TAILQ_INSERT_HEAD(&dev->free_list, acb, chain);
d688 5
a692 1
	dev->sc_tinfo[slp->target].cmds++;
d694 1
a694 1
	scsi_done(xs);
d696 4
a699 2
	if (dosched)
		sbic_sched(dev);
d704 2
a705 2
	struct sbic_softc *dev;
	struct scsi_xfer *xs;
d707 14
a720 34
	if (sbic_no_dma || xs->datalen & 0x1 || (u_int)xs->data & 0x3)
		return(0);
	/*
	 * controller supports dma to any addresses?
	 */
	else if ((dev->sc_flags & SBICF_BADDMA) == 0)
		return(1);
	/*
	 * this address is ok for dma?
	 */
	else if (sbiccheckdmap(xs->data, xs->datalen, dev->sc_dmamask) == 0)
		return(1);
#if 0
	/*
	 * we have a bounce buffer?
	 */
	else if (dev->sc_tinfo[xs->sc_link->target].bounce)
		return(1);
	/*
	 * try to get one
	 */
	else if (dev->sc_tinfo[xs->sc_link->target].bounce
		 = (char *)alloc_z2mem(MAXPHYS)) {
		if (isztwomem(dev->sc_tinfo[xs->sc_link->target].bounce))
			printf("alloc ZII target %d bounce pa 0x%x\n",
			       xs->sc_link->target,
			       kvtop(dev->sc_tinfo[xs->sc_link->target].bounce));
		else if (dev->sc_tinfo[xs->sc_link->target].bounce)
			printf("alloc CHIP target %d bounce pa 0x%x\n",
			       xs->sc_link->target,
			       PREP_DMA_MEM(dev->sc_tinfo[xs->sc_link->target].bounce));
		return(1);
	}
#endif
d722 1
a722 1
	return(0);
a724 1

d727 18
a744 17
	sbic_regmap_p regs;
	char until;
	int timeo;
	int line;
{
	u_char val;
	int csr;

	if (timeo == 0)
		timeo = 10000;	/* some large value.. */

	GET_SBIC_asr(regs,val);
	while ((val & until) == 0) {
		if (timeo-- == 0) {
			GET_SBIC_csr(regs, csr);
			printf("sbicwait TIMEO @@%d with asr=x%x csr=x%x\n",
			    line, val, csr);
d746 1
a746 1
			Debugger();
d748 9
a756 7
			return(val); /* Maybe I should abort */
			break;
		}
		DELAY(1);
		GET_SBIC_asr(regs,val);
	}
	return(val);
d760 68
a827 9
sbicabort(dev, regs, where)
	struct sbic_softc *dev;
	sbic_regmap_p regs;
	char *where;
{
	u_char csr, asr;

	GET_SBIC_csr(regs, csr);
	GET_SBIC_asr(regs, asr);
d829 1
a829 53
	printf ("%s: abort %s: csr = 0x%02x, asr = 0x%02x\n",
	    dev->sc_dev.dv_xname, where, csr, asr);


#if 0
	/* Clean up running command */
	if (dev->sc_nexus != NULL) {
		dev->sc_nexus->xs->error = XS_DRIVER_STUFFUP;
		sbic_scsidone(dev->sc_nexus, dev->sc_stat[0]);
	}
	while (acb = dev->nexus_list.tqh_first) {
		acb->xs->error = XS_DRIVER_STUFFUP;
		sbic_scsidone(acb, -1 /*acb->stat[0]*/);
	}
#endif

	/* Clean up chip itself */
	if (dev->sc_flags & SBICF_SELECTED) {
		while( asr & SBIC_ASR_DBR ) {
			/* sbic is jammed w/data. need to clear it */
			/* But we don't know what direction it needs to go */
			GET_SBIC_data(regs, asr);
			printf("%s: abort %s: clearing data buffer 0x%02x\n",
			       dev->sc_dev.dv_xname, where, asr);
			GET_SBIC_asr(regs, asr);
			if( asr & SBIC_ASR_DBR ) /* Not the read direction, then */
				SET_SBIC_data(regs, asr);
			GET_SBIC_asr(regs, asr);
		}
		WAIT_CIP(regs);
		SET_SBIC_cmd(regs, SBIC_CMD_ABORT);
		WAIT_CIP(regs);

		GET_SBIC_asr(regs, asr);
		if (asr & (SBIC_ASR_BSY|SBIC_ASR_LCI)) {
			/* ok, get more drastic.. */

			sbicreset(dev);
			dev->sc_flags &= ~SBICF_SELECTED;
			return -1;
		}
		SET_SBIC_cmd(regs, SBIC_CMD_DISC);

		do {
			SBIC_WAIT (regs, SBIC_ASR_INT, 0);
			GET_SBIC_csr (regs, csr);
		} while ((csr != SBIC_CSR_DISC) && (csr != SBIC_CSR_DISC_1)
		    && (csr != SBIC_CSR_CMD_INVALID));

		/* lets just hope it worked.. */
		dev->sc_flags &= ~SBICF_SELECTED;
	}
	return -1;
a835 1

d838 1
a838 1
	struct sbic_softc *dev;
d840 15
a854 21
	sbic_regmap_p regs;
	u_int my_id, i, s;
	u_char csr;
	struct sbic_acb *acb;

	regs = dev->sc_sbicp;

	if ((dev->sc_flags & SBICF_ALIVE) == 0) {
		TAILQ_INIT(&dev->ready_list);
		TAILQ_INIT(&dev->nexus_list);
		TAILQ_INIT(&dev->free_list);
		dev->sc_nexus = NULL;
		dev->sc_xs = NULL;
		acb = dev->sc_acb;
		bzero(acb, sizeof(dev->sc_acb));
		for (i = 0; i < sizeof(dev->sc_acb) / sizeof(*acb); i++) {
			TAILQ_INSERT_TAIL(&dev->free_list, acb, chain);
			acb++;
		}
		bzero(dev->sc_tinfo, sizeof(dev->sc_tinfo));
	} else panic("sbic: reinitializing driver!");
d856 2
a857 2
	dev->sc_flags |= SBICF_ALIVE;
	dev->sc_flags &= ~SBICF_SELECTED;
d859 4
a862 2
	sbicreset(dev);
}
d864 1
a864 8
void
sbicreset(dev)
	struct sbic_softc *dev;
{
	sbic_regmap_p regs;
	u_int my_id, i, s;
	u_char csr;
	struct sbic_acb *acb;
d866 5
a870 9
	regs = dev->sc_sbicp;
#if 0
	if (dev->sc_flags & SBICF_ALIVE) {
		SET_SBIC_cmd(regs, SBIC_CMD_ABORT);
		WAIT_CIP(regs);
	}
#else
		SET_SBIC_cmd(regs, SBIC_CMD_ABORT);
		WAIT_CIP(regs);
a871 2
	s = splbio();
	my_id = dev->sc_link.adapter_target & SBIC_ID_MASK;
d873 10
a882 37
	/* Enable advanced mode */
	my_id |= SBIC_ID_EAF /*| SBIC_ID_EHP*/ ;
	SET_SBIC_myid(regs, my_id);

	/*
	 * Disable interrupts (in dmainit) then reset the chip
	 */
	SET_SBIC_cmd(regs, SBIC_CMD_RESET);
	DELAY(25);
	SBIC_WAIT(regs, SBIC_ASR_INT, 0);
	GET_SBIC_csr(regs, csr);       /* clears interrupt also */

	if (dev->sc_clkfreq < 110)
		my_id |= SBIC_ID_FS_8_10;
	else if (dev->sc_clkfreq < 160)
		my_id |= SBIC_ID_FS_12_15;
	else if (dev->sc_clkfreq < 210)
		my_id |= SBIC_ID_FS_16_20;

	SET_SBIC_myid(regs, my_id);

	/*
	 * Set up various chip parameters
	 */
	SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI /* | SBIC_CTL_HSP */
	    | SBIC_MACHINE_DMA_MODE);
	/*
	 * don't allow (re)selection (SBIC_RID_ES)
	 * until we can handle target mode!!
	 */
	SET_SBIC_rselid(regs, SBIC_RID_ER);
	SET_SBIC_syn(regs, 0);     /* asynch for now */

	/*
	 * anything else was zeroed by reset
	 */
	splx(s);
d884 3
a886 24
#if 0
	if ((dev->sc_flags & SBICF_ALIVE) == 0) {
		TAILQ_INIT(&dev->ready_list);
		TAILQ_INIT(&dev->nexus_list);
		TAILQ_INIT(&dev->free_list);
		dev->sc_nexus = NULL;
		dev->sc_xs = NULL;
		acb = dev->sc_acb;
		bzero(acb, sizeof(dev->sc_acb));
		for (i = 0; i < sizeof(dev->sc_acb) / sizeof(*acb); i++) {
			TAILQ_INSERT_TAIL(&dev->free_list, acb, chain);
			acb++;
		}
		bzero(dev->sc_tinfo, sizeof(dev->sc_tinfo));
	} else {
		if (dev->sc_nexus != NULL) {
			dev->sc_nexus->xs->error = XS_DRIVER_STUFFUP;
			sbic_scsidone(dev->sc_nexus, dev->sc_stat[0]);
		}
		while (acb = dev->nexus_list.tqh_first) {
			acb->xs->error = XS_DRIVER_STUFFUP;
			sbic_scsidone(acb, -1 /*acb->stat[0]*/);
		}
	}
d888 4
a891 1
	dev->sc_flags |= SBICF_ALIVE;
d893 7
a899 1
	dev->sc_flags &= ~SBICF_SELECTED;
d903 2
a904 4
sbicerror(dev, regs, csr)
	struct sbic_softc *dev;
	sbic_regmap_p regs;
	u_char csr;
d906 47
a952 1
	struct scsi_xfer *xs;
d954 9
a962 1
	xs = dev->sc_xs;
d965 2
a966 2
	if (xs == NULL)
		panic("sbicerror");
a967 2
	if (xs->flags & SCSI_SILENT)
		return;
d969 4
a972 2
	printf("%s: ", dev->sc_dev.dv_xname);
	printf("csr == 0x%02x\n", csr);	/* XXX */
d977 4
d982 192
a1173 15
int
sbicselectbus(dev, regs, target, lun, our_addr)
        struct sbic_softc *dev;
	sbic_regmap_p regs;
	u_char target, lun, our_addr;
{
	u_char asr, csr, id;

	QPRINTF(("sbicselectbus %d\n", target));

	/*
	 * if we're already selected, return (XXXX panic maybe?)
	 */
	if (dev->sc_flags & SBICF_SELECTED)
		return(1);
d1175 1
a1175 187
	SET_SBIC_rselid (regs, 0);
#if 0
	GET_SBIC_asr(regs, asr);
	if( asr & (SBIC_ASR_INT|SBIC_ASR_BSY) ) {
		/* This means we got ourselves reselected upon */
/*		printf("sbicselectbus: weird asr %02x\n", asr);*/
#ifdef DDB
/*		Debugger();*/
#endif
		SET_SBIC_rselid (regs, SBIC_RID_ER);
		return 1;
	}
#endif
	/*
	 * issue select
	 */
	SBIC_TC_PUT(regs, 0);
	SET_SBIC_selid(regs, target);
	SET_SBIC_timeo(regs, SBIC_TIMEOUT(250,dev->sc_clkfreq));

	/*
	 * set sync or async
	 */
	if (dev->sc_sync[target].state == SYNC_DONE)
		SET_SBIC_syn(regs, SBIC_SYN (dev->sc_sync[target].offset,
		    dev->sc_sync[target].period));
	else
		SET_SBIC_syn(regs, SBIC_SYN (0, sbic_min_period));

	GET_SBIC_asr(regs, asr);
	if( asr & (SBIC_ASR_INT|SBIC_ASR_BSY) ) {
		/* This means we got ourselves reselected upon */
/*		printf("sbicselectbus: INT/BSY asr %02x\n", asr);*/
#ifdef DDB
/*		Debugger();*/
#endif
		return 1;
	}

	SET_SBIC_cmd(regs, SBIC_CMD_SEL_ATN);

	/*
	 * wait for select (merged from seperate function may need
	 * cleanup)
	 */
	WAIT_CIP(regs);
#if 0
	GET_SBIC_asr(regs, asr);
	if( asr & SBIC_ASR_LCI ) {
		/* This means we got ourselves reselected upon */
#ifdef DEBUG
		if (reselect_debug)
			printf("sbicselectbus: LCI asr %02x\n", asr);
/*		Debugger();*/
#endif
		return 1;
	}
#endif
	do {
		asr = SBIC_WAIT(regs, SBIC_ASR_INT | SBIC_ASR_LCI, 0);
		if (asr & SBIC_ASR_LCI) {
#ifdef DEBUG
			if (reselect_debug)
				printf("sbicselectbus: late LCI asr %02x\n", asr);
#endif
			return 1;
		}
		GET_SBIC_csr (regs, csr);
		QPRINTF(("%02x ", csr));
		if( csr == SBIC_CSR_RSLT_NI || csr == SBIC_CSR_RSLT_IFY) {
#ifdef DEBUG
			if( reselect_debug || 1 )
				printf("sbicselectbus: reselected asr %02x\n", asr);
#endif
			/* We need to handle this now so we don't lock up later */
			sbicnextstate(dev, csr, asr);
			return 1;
		}
		if( csr == SBIC_CSR_SLT || csr == SBIC_CSR_SLT_ATN) {
			panic("sbicselectbus: target issued select!");
			return 1;
		}
	} while (csr != (SBIC_CSR_MIS_2|MESG_OUT_PHASE)
	    && csr != (SBIC_CSR_MIS_2|CMD_PHASE) && csr != SBIC_CSR_SEL_TIMEO);

	/* Enable (or not) reselection */
	if( (dev->sc_xs->flags & SCSI_POLL
	   || (dev->sc_flags & SBICF_ICMD)
	   || !sbic_enable_reselect)
	   && dev->nexus_list.tqh_first == NULL )
		SET_SBIC_rselid (regs, 0);
	else
		SET_SBIC_rselid (regs, SBIC_RID_ER);

	if (csr == (SBIC_CSR_MIS_2|CMD_PHASE)) {
		dev->sc_flags |= SBICF_SELECTED;	/* device ignored ATN */
		GET_SBIC_selid(regs, id);
		dev->target = id;
		GET_SBIC_tlun(regs,dev->lun);
		if( dev->lun & SBIC_TLUN_VALID )
			dev->lun &= SBIC_TLUN_MASK;
		else
			dev->lun = lun;
	} else if (csr == (SBIC_CSR_MIS_2|MESG_OUT_PHASE)) {
		/*
		 * Send identify message
		 * (SCSI-2 requires an identify msg (?))
		 */
		GET_SBIC_selid(regs, id);
		dev->target = id;
		GET_SBIC_tlun(regs,dev->lun);
		if( dev->lun & SBIC_TLUN_VALID )
			dev->lun &= SBIC_TLUN_MASK;
		else
			dev->lun = lun;
		/*
		 * handle drives that don't want to be asked
		 * whether to go sync at all.
		 */
		if (sbic_inhibit_sync && dev->sc_sync[id].state == SYNC_START) {
#ifdef DEBUG
			if (sync_debug)
				printf("Forcing target %d asynchronous.\n", id);
#endif
			dev->sc_sync[id].offset = 0;
			dev->sc_sync[id].period = sbic_min_period;
			dev->sc_sync[id].state = SYNC_DONE;
		}


		if (dev->sc_sync[id].state != SYNC_START){
			if( dev->sc_xs->flags & SCSI_POLL
			   || (dev->sc_flags & SBICF_ICMD)
			   || !sbic_enable_reselect )
				SEND_BYTE (regs, MSG_IDENTIFY | lun);
			else
				SEND_BYTE (regs, MSG_IDENTIFY_DR | lun);
		} else {
			/*
			 * try to initiate a sync transfer.
			 * So compose the sync message we're going
			 * to send to the target
			 */

#ifdef DEBUG
			if (sync_debug)
				printf("Sending sync request to target %d ... ",
				    id);
#endif
			/*
			 * setup scsi message sync message request
			 */
			dev->sc_msg[0] = MSG_IDENTIFY | lun;
			dev->sc_msg[1] = MSG_EXT_MESSAGE;
			dev->sc_msg[2] = 3;
			dev->sc_msg[3] = MSG_SYNC_REQ;
			dev->sc_msg[4] = sbictoscsiperiod(dev, regs,
			    sbic_min_period);
			dev->sc_msg[5] = sbic_max_offset;

			if (sbicxfstart(regs, 6, MESG_OUT_PHASE, sbic_cmd_wait))
				sbicxfout(regs, 6, dev->sc_msg, MESG_OUT_PHASE);

			dev->sc_sync[id].state = SYNC_SENT;
#ifdef DEBUG
			if (sync_debug)
				printf ("sent\n");
#endif
		}

		SBIC_WAIT (regs, SBIC_ASR_INT, 0);
		GET_SBIC_csr (regs, csr);
		QPRINTF(("[%02x]", csr));
#ifdef DEBUG
		if (sync_debug && dev->sc_sync[id].state == SYNC_SENT)
			printf("csr-result of last msgout: 0x%x\n", csr);
#endif

		if (csr != SBIC_CSR_SEL_TIMEO)
			dev->sc_flags |= SBICF_SELECTED;
	}
	if (csr == SBIC_CSR_SEL_TIMEO)
		dev->sc_xs->error = XS_SELTIMEOUT;

	QPRINTF(("\n"));

	return(csr == SBIC_CSR_SEL_TIMEO);
d1178 3
d1182 57
a1238 29
sbicxfstart(regs, len, phase, wait)
	sbic_regmap_p regs;
	int len, wait;
	u_char phase;
{
	u_char id;

	switch (phase) {
	case DATA_IN_PHASE:
	case MESG_IN_PHASE:
		GET_SBIC_selid (regs, id);
		id |= SBIC_SID_FROM_SCSI;
		SET_SBIC_selid (regs, id);
		SBIC_TC_PUT (regs, (unsigned)len);
		break;
	case DATA_OUT_PHASE:
	case MESG_OUT_PHASE:
	case CMD_PHASE:
		GET_SBIC_selid (regs, id);
		id &= ~SBIC_SID_FROM_SCSI;
		SET_SBIC_selid (regs, id);
		SBIC_TC_PUT (regs, (unsigned)len);
		break;
	default:
		SBIC_TC_PUT (regs, 0);
	}
	QPRINTF(("sbicxfstart %d, %d, %d\n", len, phase, wait));

	return(1);
d1241 4
a1244 54
int
sbicxfout(regs, len, bp, phase)
	sbic_regmap_p regs;
	int len;
	void *bp;
	int phase;
{
	u_char orig_csr, csr, asr, *buf;
	int wait;

	buf = bp;
	wait = sbic_data_wait;

	QPRINTF(("sbicxfout {%d} %02x %02x %02x %02x %02x "
	    "%02x %02x %02x %02x %02x\n", len, buf[0], buf[1], buf[2],
	    buf[3], buf[4], buf[5], buf[6], buf[7], buf[8], buf[9]));

	GET_SBIC_csr (regs, orig_csr);

	/*
	 * sigh.. WD-PROTO strikes again.. sending the command in one go
	 * causes the chip to lock up if talking to certain (misbehaving?)
	 * targets. Anyway, this procedure should work for all targets, but
	 * it's slightly slower due to the overhead
	 */
	WAIT_CIP (regs);
	SET_SBIC_cmd (regs, SBIC_CMD_XFER_INFO);
	for (;len > 0; len--) {
		GET_SBIC_asr (regs, asr);
		while ((asr & SBIC_ASR_DBR) == 0) {
			if ((asr & SBIC_ASR_INT) || --wait < 0) {
#ifdef DEBUG
				if (sbic_debug)
					printf("sbicxfout fail: l%d i%x w%d\n",
					    len, asr, wait);
#endif
				return (len);
			}
/*			DELAY(1);*/
			GET_SBIC_asr (regs, asr);
		}

		SET_SBIC_data (regs, *buf);
		buf++;
	}
	SBIC_TC_GET(regs, len);
	QPRINTF(("sbicxfout done %d bytes\n", len));
	/*
	 * this leaves with one csr to be read
	 */
	return(0);
}

/* returns # bytes left to read */
d1247 48
a1294 64
	sbic_regmap_p regs;
	int len;
	void *bp;
{
	int wait, read;
	u_char *obp, *buf;
	u_char orig_csr, csr, asr;

	wait = sbic_data_wait;
	obp = bp;
	buf = bp;

	GET_SBIC_csr (regs, orig_csr);

	QPRINTF(("sbicxfin %d, csr=%02x\n", len, orig_csr));

	WAIT_CIP (regs);
	SET_SBIC_cmd (regs, SBIC_CMD_XFER_INFO);
	for (;len > 0; len--) {
		GET_SBIC_asr (regs, asr);
		if((asr & SBIC_ASR_PE)) {
#ifdef DEBUG
			printf("sbicxfin parity error: l%d i%x w%d\n",
			       len, asr, wait);
/*			return ((unsigned long)buf - (unsigned long)bp); */
#ifdef DDB
			Debugger();
#endif
#endif
		}
		while ((asr & SBIC_ASR_DBR) == 0) {
			if ((asr & SBIC_ASR_INT) || --wait < 0) {
#ifdef DEBUG
				if (sbic_debug) {
	QPRINTF(("sbicxfin fail:{%d} %02x %02x %02x %02x %02x %02x "
	    "%02x %02x %02x %02x\n", len, obp[0], obp[1], obp[2],
	    obp[3], obp[4], obp[5], obp[6], obp[7], obp[8], obp[9]));
					printf("sbicxfin fail: l%d i%x w%d\n",
					    len, asr, wait);
}
#endif
				return len;
			}

			if( ! asr & SBIC_ASR_BSY ) {
				GET_SBIC_csr(regs, csr);
				QPRINTF(("[CSR%02xASR%02x]", csr, asr));
			}

/*			DELAY(1);*/
			GET_SBIC_asr (regs, asr);
		}

		GET_SBIC_data (regs, *buf);
/*		QPRINTF(("asr=%02x, csr=%02x, data=%02x\n", asr, csr, *buf));*/
		buf++;
	}

	QPRINTF(("sbicxfin {%d} %02x %02x %02x %02x %02x %02x "
	    "%02x %02x %02x %02x\n", len, obp[0], obp[1], obp[2],
	    obp[3], obp[4], obp[5], obp[6], obp[7], obp[8], obp[9]));

	/* this leaves with one csr to be read */
	return len;
d1307 130
a1436 113
sbicicmd(dev, target, lun, cbuf, clen, buf, len)
	struct sbic_softc *dev;
	void *cbuf, *buf;
	int clen, len;
{
	sbic_regmap_p regs;
	u_char phase, csr, asr;
	int wait, newtarget, cmd_sent, parity_err;
	struct sbic_acb *acb;

	int discon;
	int i;

#define CSR_LOG_BUF_SIZE 0
#if CSR_LOG_BUF_SIZE
	int bufptr;
	int csrbuf[CSR_LOG_BUF_SIZE];
	bufptr=0;
#endif

	regs = dev->sc_sbicp;
	acb = dev->sc_nexus;

	/* Make sure pointers are OK */
	dev->sc_last = dev->sc_cur = &acb->sc_pa;
	dev->sc_tcnt = acb->sc_tcnt = 0;
	acb->sc_pa.dc_count = 0; /* No DMA */
	acb->sc_kv.dc_addr = buf;
	acb->sc_kv.dc_count = len;

#ifdef DEBUG
	routine = 3;
	debug_sbic_regs = regs; /* store this to allow debug calls */
	if( data_pointer_debug > 1 )
		printf("sbicicmd(%d,%d):%d\n", target, lun,
		       acb->sc_kv.dc_count);
#endif

	/*
	 * set the sbic into non-DMA mode
	 */
	SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI /*| SBIC_CTL_HSP*/);

	dev->sc_stat[0] = 0xff;
	dev->sc_msg[0] = 0xff;
	i = 1; /* pre-load */

	/* We're stealing the SCSI bus */
	dev->sc_flags |= SBICF_ICMD;

	do {
		/*
		 * select the SCSI bus (it's an error if bus isn't free)
		 */
		if (!( dev->sc_flags & SBICF_SELECTED )
		    && sbicselectbus(dev, regs, target, lun, dev->sc_scsiaddr)) {
			/*printf("sbicicmd trying to select busy bus!\n");*/
			dev->sc_flags &= ~SBICF_ICMD;
			return(-1);
		}

		/*
		 * Wait for a phase change (or error) then let the device sequence
		 * us through the various SCSI phases.
		 */

		wait = sbic_cmd_wait;

		GET_SBIC_asr (regs, asr);
		GET_SBIC_csr (regs, csr);
		QPRINTF((">ASR:%02xCSR:%02x<", asr, csr));

#if CSR_LOG_BUF_SIZE
		csrbuf[bufptr++] = csr;
#endif


		switch (csr) {
		case SBIC_CSR_S_XFERRED:
		case SBIC_CSR_DISC:
		case SBIC_CSR_DISC_1:
			dev->sc_flags &= ~SBICF_SELECTED;
			GET_SBIC_cmd_phase (regs, phase);
			if (phase == 0x60) {
				GET_SBIC_tlun (regs, dev->sc_stat[0]);
				i = 0; /* done */
/*				break; /* Bypass all the state gobldygook */
			} else {
#ifdef DEBUG
				if(reselect_debug>1)
					printf("sbicicmd: handling disconnect\n");
#endif
				i = SBIC_STATE_DISCONNECT;
			}
			break;

		case SBIC_CSR_XFERRED|CMD_PHASE:
		case SBIC_CSR_MIS|CMD_PHASE:
		case SBIC_CSR_MIS_1|CMD_PHASE:
		case SBIC_CSR_MIS_2|CMD_PHASE:
			if (sbicxfstart(regs, clen, CMD_PHASE, sbic_cmd_wait))
				if (sbicxfout(regs, clen,
					      cbuf, CMD_PHASE))
					i = sbicabort(dev, regs,"icmd sending cmd");
#if 0
			GET_SBIC_csr(regs, csr); /* Lets us reload tcount */
			WAIT_CIP(regs);
			GET_SBIC_asr(regs, asr);
			if( asr & (SBIC_ASR_BSY|SBIC_ASR_LCI|SBIC_ASR_CIP) )
				printf("next: cmd sent asr %02x, csr %02x\n",
				       asr, csr);
#endif
			break;
d1438 1
a1438 73
#if 0
		case SBIC_CSR_XFERRED|DATA_OUT_PHASE:
		case SBIC_CSR_XFERRED|DATA_IN_PHASE:
		case SBIC_CSR_MIS|DATA_OUT_PHASE:
		case SBIC_CSR_MIS|DATA_IN_PHASE:
		case SBIC_CSR_MIS_1|DATA_OUT_PHASE:
		case SBIC_CSR_MIS_1|DATA_IN_PHASE:
		case SBIC_CSR_MIS_2|DATA_OUT_PHASE:
		case SBIC_CSR_MIS_2|DATA_IN_PHASE:
			if (acb->sc_kv.dc_count <= 0)
				i = sbicabort(dev, regs, "icmd out of data");
			else {
			  wait = sbic_data_wait;
			  if (sbicxfstart(regs,
					  acb->sc_kv.dc_count,
					  SBIC_PHASE(csr), wait))
			    if (csr & 0x01)
			      /* data in? */
			      i=sbicxfin(regs,
					 acb->sc_kv.dc_count,
					 acb->sc_kv.dc_addr);
			    else
			      i=sbicxfout(regs,
					  acb->sc_kv.dc_count,
					  acb->sc_kv.dc_addr,
					     SBIC_PHASE(csr));
			  acb->sc_kv.dc_addr +=
				  (acb->sc_kv.dc_count - i);
			  acb->sc_kv.dc_count = i;
			  i = 1;
			}
			break;

#endif
		case SBIC_CSR_XFERRED|STATUS_PHASE:
		case SBIC_CSR_MIS|STATUS_PHASE:
		case SBIC_CSR_MIS_1|STATUS_PHASE:
		case SBIC_CSR_MIS_2|STATUS_PHASE:
			/*
			 * the sbic does the status/cmd-complete reading ok,
			 * so do this with its hi-level commands.
			 */
#ifdef DEBUG
			if(sbic_debug)
				printf("SBICICMD status phase\n");
#endif
			SBIC_TC_PUT(regs, 0);
			SET_SBIC_cmd_phase(regs, 0x46);
			SET_SBIC_cmd(regs, SBIC_CMD_SEL_ATN_XFER);
			break;

#if THIS_IS_A_RESERVED_STATE
		case BUS_FREE_PHASE:		/* This is not legal */
			if( dev->sc_stat[0] != 0xff )
				goto out;
			break;
#endif

		default:
			i = sbicnextstate(dev, csr, asr);
		}

		/*
		 * make sure the last command was taken,
		 * ie. we're not hunting after an ignored command..
		 */
		GET_SBIC_asr(regs, asr);

		/* tapes may take a loooong time.. */
		while (asr & SBIC_ASR_BSY){
			if(asr & SBIC_ASR_DBR) {
				printf("sbicicmd: Waiting while sbic is jammed, CSR:%02x,ASR:%02x\n",
				       csr,asr);
d1440 1
a1440 34
				Debugger();
#endif
				/* SBIC is jammed */
				/* DUNNO which direction */
				/* Try old direction */
				GET_SBIC_data(regs,i);
				GET_SBIC_asr(regs, asr);
				if( asr & SBIC_ASR_DBR) /* Wants us to write */
					SET_SBIC_data(regs,i);
			}
			GET_SBIC_asr(regs, asr);
		}

		/*
		 * wait for last command to complete
		 */
		if (asr & SBIC_ASR_LCI) {
			printf("sbicicmd: last command ignored\n");
		}
		else if( i == 1 ) /* Bsy */
			SBIC_WAIT (regs, SBIC_ASR_INT, wait);

		/*
		 * do it again
		 */
	} while ( i > 0 && dev->sc_stat[0] == 0xff);

	/* Sometimes we need to do an extra read of the CSR */
	GET_SBIC_csr(regs, csr);

#if CSR_LOG_BUF_SIZE
	if(reselect_debug>1)
		for(i=0; i<bufptr; i++)
			printf("CSR:%02x", csrbuf[i]);
d1442 40
a1481 7

#ifdef DEBUG
	if(data_pointer_debug > 1)
		printf("sbicicmd done(%d,%d):%d =%d=\n",
		       dev->target, lun,
		       acb->sc_kv.dc_count,
		       dev->sc_stat[0]);
d1484 1
a1484 2
	QPRINTF(("=STS:%02x=", dev->sc_stat[0]));
	dev->sc_flags &= ~SBICF_ICMD;
d1486 1
a1486 1
	return(dev->sc_stat[0]);
d1496 19
a1514 41
sbicxfdone(dev, regs, target)
	struct sbic_softc *dev;
	sbic_regmap_p regs;
	int target;
{
	u_char phase, csr;
	int s;

	QPRINTF(("{"));
	s = splbio();

	/*
	 * have the sbic complete on its own
	 */
	SBIC_TC_PUT(regs, 0);
	SET_SBIC_cmd_phase(regs, 0x46);
	SET_SBIC_cmd(regs, SBIC_CMD_SEL_ATN_XFER);

	do {
		SBIC_WAIT (regs, SBIC_ASR_INT, 0);
		GET_SBIC_csr (regs, csr);
		QPRINTF(("%02x:", csr));
	} while ((csr != SBIC_CSR_DISC) && (csr != SBIC_CSR_DISC_1)
	    && (csr != SBIC_CSR_S_XFERRED));

	dev->sc_flags &= ~SBICF_SELECTED;

	GET_SBIC_cmd_phase (regs, phase);
	QPRINTF(("}%02x", phase));
	if (phase == 0x60)
		GET_SBIC_tlun(regs, dev->sc_stat[0]);
	else
		sbicerror(dev, regs, csr);

	QPRINTF(("=STS:%02x=\n", dev->sc_stat[0]));
	splx(s);
}

	/*
	 * No DMA chains
	 */
d1516 25
d1543 2
a1544 2
	struct sbic_softc *dev;
	struct scsi_xfer *xs;
d1546 42
a1587 56
	int i, dmaflags, count, wait, usedma;
	u_char csr, asr, cmd, *addr;
	sbic_regmap_p regs;
	struct sbic_acb *acb;

	dev->target = xs->sc_link->target;
	dev->lun = xs->sc_link->lun;
	acb = dev->sc_nexus;
	regs = dev->sc_sbicp;

	usedma = sbicdmaok(dev, xs);
#ifdef DEBUG
	routine = 1;
	debug_sbic_regs = regs; /* store this to allow debug calls */
	if( data_pointer_debug > 1 )
		printf("sbicgo(%d,%d)\n", dev->target, dev->lun);
#endif

	/*
	 * set the sbic into DMA mode
	 */
	if( usedma )
		SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI |
				 SBIC_MACHINE_DMA_MODE);
	else
		SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);


	/*
	 * select the SCSI bus (it's an error if bus isn't free)
	 */
	if (sbicselectbus(dev, regs, dev->target, dev->lun,
	    dev->sc_scsiaddr)) {
/*		printf("sbicgo: Trying to select busy bus!\n"); */
		return(0); /* Not done: needs to be rescheduled */
	}
	dev->sc_stat[0] = 0xff;

	/*
	 * Calculate DMA chains now
	 */

	dmaflags = 0;
	if (acb->flags & ACB_DATAIN)
		dmaflags |= DMAGO_READ;


	/*
	 * Deal w/bounce buffers.
	 */

	addr = acb->sc_kv.dc_addr;
	count = acb->sc_kv.dc_count;
	if (count && (char *)kvtop(addr) != acb->sc_pa.dc_addr)	{ /* XXXX check */
		printf("sbic: DMA buffer mapping changed %x->%x\n",
		    acb->sc_pa.dc_addr, kvtop(addr));
d1589 1
a1589 1
		Debugger();
d1591 1
a1591 1
	}
d1594 1
a1594 1
	++sbicdma_ops;			/* count total DMA operations */
d1596 49
a1644 15
	if (count && usedma && dev->sc_flags & SBICF_BADDMA &&
	    sbiccheckdmap(addr, count, dev->sc_dmamask)) {
		/*
		 * need to bounce the dma.
		 */
		if (dmaflags & DMAGO_READ) {
			acb->flags |= ACB_BBUF;
			acb->sc_dmausrbuf = addr;
			acb->sc_dmausrlen = count;
			acb->sc_usrbufpa = (u_char *)kvtop(addr);
			if(!dev->sc_tinfo[dev->target].bounce) {
				printf("sbicgo: HELP! no bounce allocated for %d\n",
				       dev->target);
				printf("xfer: (%x->%x,%x)\n", acb->sc_dmausrbuf,
				       acb->sc_usrbufpa, acb->sc_dmausrlen);
d1646 11
a1656 35
				dev->sc_tinfo[xs->sc_link->target].bounce
					= (char *)alloc_z2mem(MAXPHYS);
				if (isztwomem(dev->sc_tinfo[xs->sc_link->target].bounce))
					printf("alloc ZII target %d bounce pa 0x%x\n",
					       xs->sc_link->target,
					       kvtop(dev->sc_tinfo[xs->sc_link->target].bounce));
				else if (dev->sc_tinfo[xs->sc_link->target].bounce)
					printf("alloc CHIP target %d bounce pa 0x%x\n",
					       xs->sc_link->target,
					       PREP_DMA_MEM(dev->sc_tinfo[xs->sc_link->target].bounce));
#endif

				printf("Allocating %d bounce at %x\n",
				       dev->target,
				       kvtop(dev->sc_tinfo[dev->target].bounce));
			}
		} else {	/* write: copy to dma buffer */
#ifdef DEBUG
			if(data_pointer_debug)
			printf("sbicgo: copying %x bytes to target %d bounce %x\n",
			       count, dev->target,
			       kvtop(dev->sc_tinfo[dev->target].bounce));
#endif
			bcopy (addr, dev->sc_tinfo[dev->target].bounce, count);
		}
		addr = dev->sc_tinfo[dev->target].bounce;/* and use dma buffer */
		acb->sc_kv.dc_addr = addr;
#ifdef DEBUG
		++sbicdma_bounces;		/* count number of bounced */
#endif
	}

	/*
	 * Allocate the DMA chain
	 */
d1658 4
a1661 1
	/* Set start KVM addresses */
d1663 3
a1665 2
	acb->sc_kv.dc_addr = addr;
	acb->sc_kv.dc_count = count;
d1667 3
d1671 1
a1671 71
	/* Mark end of segment */
	acb->sc_tcnt = dev->sc_tcnt = 0;
	acb->sc_pa.dc_count = 0;

	sbic_load_ptrs(dev, regs, dev->target, dev->lun);
	/* Enable interrupts but don't do any DMA */
	dev->sc_tcnt = dev->sc_dmago(dev, acb->sc_pa.dc_addr,
				     acb->sc_pa.dc_count,
				     dmaflags);
	dev->sc_flags |= SBICF_INDMA;
        if( !usedma )
		dev->sc_dmacmd = 0; /* Don't use DMA */
/*	SBIC_TC_PUT(regs, dev->sc_tcnt); /* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
	sbic_save_ptrs(dev, regs, dev->target, dev->lun);

	/*
	 * push the data cache ( I think this won't work (EH))
	 */
#if defined(M68040)
	if (mmutype == MMU_68040 && usedma && count) {
		dma_cachectl(addr, count);
		if (((u_int)addr & 0xF) || (((u_int)addr + count) & 0xF))
			dev->sc_flags |= SBICF_DCFLUSH;
	}
#endif

	/*
	 * dmago() also enables interrupts for the sbic
	 */
#ifdef DEBUG
	if( data_pointer_debug > 1 )
		printf("sbicgo dmago:%d(%x:%x)\n",
		       dev->target,dev->sc_cur->dc_addr,dev->sc_tcnt);
	if( sbic_timeout && !timeout_active ) {
		timeout((void *)sbictimeout, (void*)dev, sbic_timeout * hz);
		timeout_active = 1;
	}
	debug_asr = asr;
	debug_csr = csr;
#endif

	/*
	 * Lets cycle a while then let the interrupt handler take over
	 */

	GET_SBIC_asr(regs, asr);
	do {
		GET_SBIC_csr(regs, csr);
#ifdef DEBUG
		debug_csr = csr;
		routine = 1;
#endif
		QPRINTF(("go[0x%x]", csr));

		i = sbicnextstate(dev, csr, asr);

		WAIT_CIP(regs);
		GET_SBIC_asr(regs, asr);
#ifdef DEBUG
		debug_asr = asr;
#endif
		if(asr & SBIC_ASR_LCI) printf("sbicgo: LCI asr:%02x csr:%02x\n",
					      asr,csr);
	} while( i == SBIC_STATE_RUNNING
		&& asr & (SBIC_ASR_INT|SBIC_ASR_LCI) );

	if (i == SBIC_STATE_DONE && dev->sc_stat[0] != 0xff) { 
		/* Did we really finish that fast? */
		return 1;
	}
	return 0;
d1677 1
a1677 1
	struct sbic_softc *dev;
d1679 4
a1682 6
	sbic_regmap_p regs;
	struct dma_chain *df, *dl;
	u_char asr, csr, *tmpaddr;
	struct sbic_acb *acb;
	int i, newtarget, newlun;
	unsigned tcnt;
d1684 6
a1689 1
	regs = dev->sc_sbicp;
d1691 1
a1691 6
	/*
	 * pending interrupt?
	 */
	GET_SBIC_asr (regs, asr);
	if ((asr & SBIC_ASR_INT) == 0)
		return(0);
d1693 2
a1694 7
	do {
		GET_SBIC_csr(regs, csr);
#ifdef DEBUG
		debug_csr = csr;
		routine = 2;
#endif
		QPRINTF(("intr[0x%x]", csr));
d1696 1
a1696 1
		i = sbicnextstate(dev, csr, asr);
d1698 1
a1698 5
		WAIT_CIP(regs);
		GET_SBIC_asr(regs, asr);
#ifdef DEBUG
		debug_asr = asr;
#endif
d1700 1
a1700 2
		if(asr & SBIC_ASR_LCI) printf("sbicintr: LCI asr:%02x csr:%02x\n",
					      asr,csr);
d1702 7
a1708 3
	} while(i == SBIC_STATE_RUNNING &&
		asr & (SBIC_ASR_INT|SBIC_ASR_LCI));
	return(1);
d1712 3
a1714 1
 * Run commands and wait for disconnect
d1718 1
a1718 1
	struct sbic_softc *dev;
d1720 17
a1736 5
	sbic_regmap_p regs;
	u_char asr, csr;
	struct sbic_pending* pendp;
	int i;
	unsigned tcnt;
d1738 4
a1741 1
	regs = dev->sc_sbicp;
d1743 2
a1744 11
	do {
		GET_SBIC_asr (regs, asr);
#ifdef DEBUG
		debug_asr = asr;
#endif
		GET_SBIC_csr(regs, csr);
#ifdef DEBUG
		debug_csr = csr;
		routine = 2;
#endif
		QPRINTF(("poll[0x%x]", csr));
d1746 4
a1749 1
		i = sbicnextstate(dev, csr, asr);
d1751 2
a1752 7
		WAIT_CIP(regs);
		GET_SBIC_asr(regs, asr);
		/* tapes may take a loooong time.. */
		while (asr & SBIC_ASR_BSY){
			if(asr & SBIC_ASR_DBR) {
				printf("sbipoll: Waiting while sbic is jammed, CSR:%02x,ASR:%02x\n",
				       csr,asr);
d1754 1
a1754 1
				Debugger();
d1756 24
a1779 17
				/* SBIC is jammed */
				/* DUNNO which direction */
				/* Try old direction */
				GET_SBIC_data(regs,i);
				GET_SBIC_asr(regs, asr);
				if( asr & SBIC_ASR_DBR) /* Wants us to write */
					SET_SBIC_data(regs,i);
			}
			GET_SBIC_asr(regs, asr);
		}

		if(asr & SBIC_ASR_LCI) printf("sbicpoll: LCI asr:%02x csr:%02x\n",
					      asr,csr);
		else if( i == 1 ) /* BSY */
			SBIC_WAIT(regs, SBIC_ASR_INT, sbic_cmd_wait);
	} while(i == SBIC_STATE_RUNNING);
	return(1);
a1784 1

d1787 1
a1787 1
	struct sbic_softc *dev;
d1789 297
a2085 251
	sbic_regmap_p regs;
	int recvlen;
	u_char asr, csr, *tmpaddr;

	regs = dev->sc_sbicp;

	dev->sc_msg[0] = 0xff;
	dev->sc_msg[1] = 0xff;

	GET_SBIC_asr(regs, asr);
#ifdef DEBUG
	if(reselect_debug>1)
		printf("sbicmsgin asr=%02x\n", asr);
#endif

	sbic_save_ptrs(dev, regs, dev->target, dev->lun);

	GET_SBIC_selid (regs, csr);
	SET_SBIC_selid (regs, csr | SBIC_SID_FROM_SCSI);

	SBIC_TC_PUT(regs, 0);
	tmpaddr = dev->sc_msg;
	recvlen = 1;
	do {
		while( recvlen-- ) {
			GET_SBIC_asr(regs, asr);
			GET_SBIC_csr(regs, csr);
			QPRINTF(("sbicmsgin ready to go (csr,asr)=(%02x,%02x)\n",
				 csr, asr));

			RECV_BYTE(regs, *tmpaddr);
#if 1
			/*
			 * get the command completion interrupt, or we
			 * can't send a new command (LCI)
			 */
			SBIC_WAIT(regs, SBIC_ASR_INT, 0);
			GET_SBIC_csr(regs, csr);
#else
			WAIT_CIP(regs);
			do {
				GET_SBIC_asr(regs, asr);
				csr = 0xff;
				GET_SBIC_csr(regs, csr);
				if( csr == 0xff )
					printf("sbicmsgin waiting: csr %02x asr %02x\n", csr, asr);
			} while( csr == 0xff );
#endif
#ifdef DEBUG
			if(reselect_debug>1)
				printf("sbicmsgin: got %02x csr %02x asr %02x\n",
				       *tmpaddr, csr, asr);
#endif
#if do_parity_check
			if( asr & SBIC_ASR_PE ) {
				printf ("Parity error");
				/* This code simply does not work. */
				WAIT_CIP(regs);
				SET_SBIC_cmd(regs, SBIC_CMD_SET_ATN);
				WAIT_CIP(regs);
				GET_SBIC_asr(regs, asr);
				WAIT_CIP(regs);
				SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);
				WAIT_CIP(regs);
				if( !(asr & SBIC_ASR_LCI) )
					/* Target wants to send garbled msg*/
					continue;
				printf("--fixing\n");
				/* loop until a msgout phase occurs on target */
				while(csr & 0x07 != MESG_OUT_PHASE) {
					while( asr & SBIC_ASR_BSY &&
					      !(asr & SBIC_ASR_DBR|SBIC_ASR_INT) )
						GET_SBIC_asr(regs, asr);
					if( asr & SBIC_ASR_DBR )
						panic("msgin: jammed again!\n");
					GET_SBIC_csr(regs, csr);
					if( csr & 0x07 != MESG_OUT_PHASE ) {
						sbicnextstate(dev, csr, asr);
						sbic_save_ptrs(dev, regs,
							       dev->target,
							       dev->lun);
					}
				}
				/* Should be msg out by now */
				SEND_BYTE(regs, MSG_PARITY_ERROR);
			}
			else
#endif
				tmpaddr++;

			if(recvlen) {
				/* Clear ACK */
				WAIT_CIP(regs);
				GET_SBIC_asr(regs, asr);
				GET_SBIC_csr(regs, csr);
				QPRINTF(("sbicmsgin pre byte CLR_ACK (csr,asr)=(%02x,%02x)\n",
					 csr, asr));
				SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);
				SBIC_WAIT(regs, SBIC_ASR_INT, 0);
			}

		};

		if(dev->sc_msg[0] == 0xff) {
			printf("sbicmsgin: sbic swallowed our message\n");
			break;
		}
#ifdef DEBUG
		if (sync_debug)
			printf("msgin done csr 0x%x asr 0x%x msg 0x%x\n",
			       csr, asr, dev->sc_msg[0]);
#endif
		/*
		 * test whether this is a reply to our sync
		 * request
		 */
		if (MSG_ISIDENTIFY(dev->sc_msg[0])) {
			QPRINTF(("IFFY"));
#if 0
			/* There is an implied load-ptrs here */
			sbic_load_ptrs(dev, regs, dev->target, dev->lun);
#endif
			/* Got IFFY msg -- ack it */
		} else if (dev->sc_msg[0] == MSG_REJECT
			   && dev->sc_sync[dev->target].state == SYNC_SENT) {
			QPRINTF(("REJECT of SYN"));
#ifdef DEBUG
			if (sync_debug)
				printf("target %d rejected sync, going async\n",
				       dev->target);
#endif
			dev->sc_sync[dev->target].period = sbic_min_period;
			dev->sc_sync[dev->target].offset = 0;
			dev->sc_sync[dev->target].state = SYNC_DONE;
			SET_SBIC_syn(regs,
				     SBIC_SYN(dev->sc_sync[dev->target].offset,
					      dev->sc_sync[dev->target].period));
		} else if ((dev->sc_msg[0] == MSG_REJECT)) {
			QPRINTF(("REJECT"));
			/*
			 * we'll never REJECt a REJECT message..
			 */
		} else if ((dev->sc_msg[0] == MSG_SAVE_DATA_PTR)) {
			QPRINTF(("MSG_SAVE_DATA_PTR"));
			/*
			 * don't reject this either.
			 */
		} else if ((dev->sc_msg[0] == MSG_DISCONNECT)) {
			QPRINTF(("DISCONNECT"));
#ifdef DEBUG
			if( reselect_debug>1 && dev->sc_msg[0] == MSG_DISCONNECT )
				printf("sbicmsgin: got disconnect msg %s\n",
				       (dev->sc_flags & SBICF_ICMD)?"rejecting":"");
#endif
			if( dev->sc_flags & SBICF_ICMD ) {
				/* We're in immediate mode. Prevent disconnects. */
				/* prepare to reject the message, NACK */
				SET_SBIC_cmd(regs, SBIC_CMD_SET_ATN);
				WAIT_CIP(regs);
			}
		} else if (dev->sc_msg[0] == MSG_CMD_COMPLETE ) {
			QPRINTF(("CMD_COMPLETE"));
			/* !! KLUDGE ALERT !! quite a few drives don't seem to
			 * really like the current way of sending the
			 * sync-handshake together with the ident-message, and
			 * they react by sending command-complete and
			 * disconnecting right after returning the valid sync
			 * handshake. So, all I can do is reselect the drive,
			 * and hope it won't disconnect again. I don't think
			 * this is valid behavior, but I can't help fixing a
			 * problem that apparently exists.
			 *
			 * Note: we should not get here on `normal' command
			 * completion, as that condition is handled by the
			 * high-level sel&xfer resume command used to walk
			 * thru status/cc-phase.
			 */

#ifdef DEBUG
			if (sync_debug)
				printf ("GOT MSG %d! target %d acting weird.."
					" waiting for disconnect...\n",
					dev->sc_msg[0], dev->target);
#endif
			/* Check to see if sbic is handling this */
			GET_SBIC_asr(regs, asr);
			if(asr & SBIC_ASR_BSY)
				return SBIC_STATE_RUNNING;

			/* Let's try this: Assume it works and set status to 00 */
			dev->sc_stat[0] = 0;
		} else if (dev->sc_msg[0] == MSG_EXT_MESSAGE
			   && tmpaddr == &dev->sc_msg[1]) {
			QPRINTF(("ExtMSG\n"));
			/* Read in whole extended message */
			SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);
			SBIC_WAIT(regs, SBIC_ASR_INT, 0);
			GET_SBIC_asr(regs, asr);
			GET_SBIC_csr(regs, csr);
			QPRINTF(("CLR ACK asr %02x, csr %02x\n", asr, csr));
			RECV_BYTE(regs, *tmpaddr);
			/* Wait for command completion IRQ */
			SBIC_WAIT(regs, SBIC_ASR_INT, 0);
			recvlen = *tmpaddr++;
			QPRINTF(("Recving ext msg, asr %02x csr %02x len %02x\n",
			       asr, csr, recvlen));
		} else if (dev->sc_msg[0] == MSG_EXT_MESSAGE && dev->sc_msg[1] == 3
			   && dev->sc_msg[2] == MSG_SYNC_REQ) {
			QPRINTF(("SYN"));
			dev->sc_sync[dev->target].period =
				sbicfromscsiperiod(dev,
						   regs, dev->sc_msg[3]);
			dev->sc_sync[dev->target].offset = dev->sc_msg[4];
			dev->sc_sync[dev->target].state = SYNC_DONE;
			SET_SBIC_syn(regs,
				     SBIC_SYN(dev->sc_sync[dev->target].offset,
					      dev->sc_sync[dev->target].period));
			printf("%s: target %d now synchronous,"
			       " period=%dns, offset=%d.\n",
			       dev->sc_dev.dv_xname, dev->target,
			       dev->sc_msg[3] * 4, dev->sc_msg[4]);
		} else {
#ifdef DEBUG
			if (sbic_debug || sync_debug)
				printf ("sbicmsgin: Rejecting message 0x%02x\n",
					dev->sc_msg[0]);
#endif
			/* prepare to reject the message, NACK */
			SET_SBIC_cmd(regs, SBIC_CMD_SET_ATN);
			WAIT_CIP(regs);
		}
		/* Clear ACK */
		WAIT_CIP(regs);
		GET_SBIC_asr(regs, asr);
		GET_SBIC_csr(regs, csr);
		QPRINTF(("sbicmsgin pre CLR_ACK (csr,asr)=(%02x,%02x)%d\n",
			 csr, asr, recvlen));
		SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);
		SBIC_WAIT(regs, SBIC_ASR_INT, 0);
	}
#if 0
	while((csr == SBIC_CSR_MSGIN_W_ACK)
	      || (SBIC_PHASE(csr) == MESG_IN_PHASE));
#else
	while (recvlen>0);
#endif

	QPRINTF(("sbicmsgin finished: csr %02x, asr %02x\n",csr, asr));

	/* Should still have one CSR to read */
	return SBIC_STATE_RUNNING;
d2092 4
a2095 4
 *		0  == done
 *		1  == working
 *		2  == disconnected
 *		-1 == error
d2099 395
a2493 277
	struct sbic_softc *dev;
	u_char csr, asr;
{
	sbic_regmap_p regs;
	struct dma_chain *df, *dl;
	struct sbic_acb *acb;
	int i, newtarget, newlun, wait;
	unsigned tcnt;

	regs = dev->sc_sbicp;
	acb = dev->sc_nexus;

	QPRINTF(("next[%02x,%02x]",asr,csr));

	switch (csr) {
	case SBIC_CSR_XFERRED|CMD_PHASE:
	case SBIC_CSR_MIS|CMD_PHASE:
	case SBIC_CSR_MIS_1|CMD_PHASE:
	case SBIC_CSR_MIS_2|CMD_PHASE:
		sbic_save_ptrs(dev, regs, dev->target, dev->lun);
		if (sbicxfstart(regs, acb->clen, CMD_PHASE, sbic_cmd_wait))
			if (sbicxfout(regs, acb->clen,
				      &acb->cmd, CMD_PHASE))
				goto abort;
		break;

	case SBIC_CSR_XFERRED|STATUS_PHASE:
	case SBIC_CSR_MIS|STATUS_PHASE:
	case SBIC_CSR_MIS_1|STATUS_PHASE:
	case SBIC_CSR_MIS_2|STATUS_PHASE:
		/*
		 * this should be the normal i/o completion case.
		 * get the status & cmd complete msg then let the
		 * device driver look at what happened.
		 */
		sbicxfdone(dev,regs,dev->target);
		/*
		 * check for overlapping cache line, flush if so
		 */
#ifdef M68040
		if (dev->sc_flags & SBICF_DCFLUSH) {
#if 0
			printf("sbic: 68040 DMA cache flush needs fixing? %x:%x\n",
			    dev->sc_xs->data, dev->sc_xs->datalen);
#endif
		}
#endif
#ifdef DEBUG
		if( data_pointer_debug > 1 )
			printf("next dmastop: %d(%x:%x)\n",
			       dev->target,dev->sc_cur->dc_addr,dev->sc_tcnt);
#endif
		dev->sc_dmastop(dev); /* was dmafree */
		if (acb->flags & ACB_BBUF) {
			if ((u_char *)kvtop(acb->sc_dmausrbuf) != acb->sc_usrbufpa)
				printf("%s: WARNING - buffer mapping changed %x->%x\n",
				    dev->sc_dev.dv_xname, acb->sc_usrbufpa,
				    kvtop(acb->sc_dmausrbuf));
#ifdef DEBUG
			if(data_pointer_debug)
			printf("sbicgo:copying %x bytes from target %d bounce %x\n",
			       acb->sc_dmausrlen,
			       dev->target,
			       kvtop(dev->sc_tinfo[dev->target].bounce));
#endif
			bcopy(dev->sc_tinfo[dev->target].bounce,
			      acb->sc_dmausrbuf,
			      acb->sc_dmausrlen);
		}
		dev->sc_flags &= ~(SBICF_INDMA | SBICF_DCFLUSH);
		sbic_scsidone(acb, dev->sc_stat[0]);
		return SBIC_STATE_DONE;

	case SBIC_CSR_XFERRED|DATA_OUT_PHASE:
	case SBIC_CSR_XFERRED|DATA_IN_PHASE:
	case SBIC_CSR_MIS|DATA_OUT_PHASE:
	case SBIC_CSR_MIS|DATA_IN_PHASE:
	case SBIC_CSR_MIS_1|DATA_OUT_PHASE:
	case SBIC_CSR_MIS_1|DATA_IN_PHASE:
	case SBIC_CSR_MIS_2|DATA_OUT_PHASE:
	case SBIC_CSR_MIS_2|DATA_IN_PHASE:
		if( dev->sc_xs->flags & SCSI_POLL || dev->sc_flags & SBICF_ICMD
		   || acb->sc_dmacmd == 0 ) {
			/* Do PIO */
			SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI);
			if (acb->sc_kv.dc_count <= 0) {
				printf("sbicnextstate:xfer count %d asr%x csr%x\n",
				       acb->sc_kv.dc_count, asr, csr);
				goto abort;
			}
			wait = sbic_data_wait;
			if( sbicxfstart(regs,
					acb->sc_kv.dc_count,
					SBIC_PHASE(csr), wait))
				if( SBIC_PHASE(csr) == DATA_IN_PHASE )
					/* data in? */
					i=sbicxfin(regs,
						   acb->sc_kv.dc_count,
						   acb->sc_kv.dc_addr);
				else
					i=sbicxfout(regs,
						    acb->sc_kv.dc_count,
						    acb->sc_kv.dc_addr,
						    SBIC_PHASE(csr));
			acb->sc_kv.dc_addr +=
				(acb->sc_kv.dc_count - i);
			acb->sc_kv.dc_count = i;
		} else {
			/*
			 * do scatter-gather dma
			 * hacking the controller chip, ouch..
			 */
			SET_SBIC_control(regs, SBIC_CTL_EDI | SBIC_CTL_IDI |
					 SBIC_MACHINE_DMA_MODE);
			/*
			 * set next dma addr and dec count
			 */
#if 0
			SBIC_TC_GET(regs, tcnt);
			dev->sc_cur->dc_count -= ((dev->sc_tcnt - tcnt) >> 1);
			dev->sc_cur->dc_addr += (dev->sc_tcnt - tcnt);
			dev->sc_tcnt = acb->sc_tcnt = tcnt;
#else
			sbic_save_ptrs(dev, regs, dev->target, dev->lun);
			sbic_load_ptrs(dev, regs, dev->target, dev->lun);
#endif
#ifdef DEBUG
			if( data_pointer_debug > 1 )
				printf("next dmanext: %d(%x:%x)\n",
				       dev->target,dev->sc_cur->dc_addr,
				       dev->sc_tcnt);
#endif
			dev->sc_tcnt = dev->sc_dmanext(dev);
			SBIC_TC_PUT(regs, (unsigned)dev->sc_tcnt);
			SET_SBIC_cmd(regs, SBIC_CMD_XFER_INFO);
			dev->sc_flags |= SBICF_INDMA;
		}
		break;

	case SBIC_CSR_XFERRED|MESG_IN_PHASE:
	case SBIC_CSR_MIS|MESG_IN_PHASE:
	case SBIC_CSR_MIS_1|MESG_IN_PHASE:
	case SBIC_CSR_MIS_2|MESG_IN_PHASE:
		return sbicmsgin(dev);

	case SBIC_CSR_MSGIN_W_ACK:
		SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK); /* Dunno what I'm ACKing */
		printf("Acking unknown msgin CSR:%02x",csr);
		break;

	case SBIC_CSR_XFERRED|MESG_OUT_PHASE:
	case SBIC_CSR_MIS|MESG_OUT_PHASE:
	case SBIC_CSR_MIS_1|MESG_OUT_PHASE:
	case SBIC_CSR_MIS_2|MESG_OUT_PHASE:
#ifdef DEBUG
		if (sync_debug)
			printf ("sending REJECT msg to last msg.\n");
#endif

		sbic_save_ptrs(dev, regs, dev->target, dev->lun);
		/*
		 * should only get here on reject,
		 * since it's always US that
		 * initiate a sync transfer
		 */
		SEND_BYTE(regs, MSG_REJECT);
		WAIT_CIP(regs);
		if( asr & (SBIC_ASR_BSY|SBIC_ASR_LCI|SBIC_ASR_CIP) )
			printf("next: REJECT sent asr %02x\n", asr);
		return SBIC_STATE_RUNNING;

	case SBIC_CSR_DISC:
	case SBIC_CSR_DISC_1:
		dev->sc_flags &= ~(SBICF_INDMA|SBICF_SELECTED);

		/* Try to schedule another target */
#ifdef DEBUG
		if(reselect_debug>1)
			printf("sbicnext target %d disconnected\n", dev->target);
#endif
		TAILQ_INSERT_HEAD(&dev->nexus_list, acb, chain);
		++dev->sc_tinfo[dev->target].dconns;
		dev->sc_nexus = NULL;
		dev->sc_xs = NULL;

		if( acb->xs->flags & SCSI_POLL
		   || (dev->sc_flags & SBICF_ICMD)
		   || !sbic_parallel_operations )
			return SBIC_STATE_DISCONNECT;
		sbic_sched(dev);
		return SBIC_STATE_DISCONNECT;

	case SBIC_CSR_RSLT_NI:
	case SBIC_CSR_RSLT_IFY:
		GET_SBIC_rselid(regs, newtarget);
		/* check SBIC_RID_SIV? */
		newtarget &= SBIC_RID_MASK;
		if (csr == SBIC_CSR_RSLT_IFY) {
			/* Read IFY msg to avoid lockup */
			GET_SBIC_data(regs, newlun);
			WAIT_CIP(regs);
			newlun &= SBIC_TLUN_MASK;
		} else {
			/* Need to get IFY message */
			for (newlun = 256; newlun; --newlun) {
				GET_SBIC_asr(regs, asr);
				if (asr & SBIC_ASR_INT)
					break;
				delay(1);
			}
			newlun = 0;	/* XXXX */
			if ((asr & SBIC_ASR_INT) == 0) {
#ifdef DEBUG
				if (reselect_debug)
					printf("RSLT_NI - no IFFY message? asr %x\n", asr);
#endif
			} else {
				GET_SBIC_csr(regs,csr);
				if (csr == SBIC_CSR_MIS|MESG_IN_PHASE ||
				    csr == SBIC_CSR_MIS_1|MESG_IN_PHASE ||
				    csr == SBIC_CSR_MIS_2|MESG_IN_PHASE) {
					sbicmsgin(dev);
					newlun = dev->sc_msg[0] & 7;
				} else {
					printf("RSLT_NI - not MESG_IN_PHASE %x\n",
					    csr);
				}
			}
		}
#ifdef DEBUG
		if(reselect_debug>1 || (reselect_debug && csr==SBIC_CSR_RSLT_NI))
			printf("sbicnext: reselect %s from targ %d lun %d\n",
			    csr == SBIC_CSR_RSLT_NI ? "NI" : "IFY",
			    newtarget, newlun);
#endif
		if (dev->sc_nexus) {
#ifdef DEBUG
			if (reselect_debug > 1)
				printf("%s: reselect %s with active command\n",
				    dev->sc_dev.dv_xname,
				    csr == SBIC_CSR_RSLT_NI ? "NI" : "IFY");
#ifdef DDB
/*			Debugger();*/
#endif
#endif
			TAILQ_INSERT_HEAD(&dev->ready_list, dev->sc_nexus, chain);
			dev->sc_tinfo[dev->target].lubusy &= ~(1 << dev->lun);
		}
		/* Reload sync values for this target */
		if (dev->sc_sync[newtarget].state == SYNC_DONE)
			SET_SBIC_syn(regs, SBIC_SYN (dev->sc_sync[newtarget].offset,
			    dev->sc_sync[newtarget].period));
		else
			SET_SBIC_syn(regs, SBIC_SYN (0, sbic_min_period));
		for (acb = dev->nexus_list.tqh_first; acb;
		    acb = acb->chain.tqe_next) {
			if (acb->xs->sc_link->target != newtarget ||
			    acb->xs->sc_link->lun != newlun)
				continue;
			TAILQ_REMOVE(&dev->nexus_list, acb, chain);
			dev->sc_nexus = acb;
			dev->sc_xs = acb->xs;
			dev->sc_flags |= SBICF_SELECTED;
			dev->target = newtarget;
			dev->lun = newlun;
			break;
		}
		if (acb == NULL) {
			printf("%s: reselect %s targ %d not in nexus_list %x\n",
			    dev->sc_dev.dv_xname,
			    csr == SBIC_CSR_RSLT_NI ? "NI" : "IFY", newtarget,
			    &dev->nexus_list.tqh_first);
			panic("bad reselect in sbic");
		}
		if (csr == SBIC_CSR_RSLT_IFY)
			SET_SBIC_cmd(regs, SBIC_CMD_CLR_ACK);
		break;
d2495 1
a2495 1
	default:
d2497 6
a2502 4
		/*
		 * Something unexpected happened -- deal with it.
		 */
		printf("sbicnextstate: aborting csr %02x asr %02x\n", csr, asr);
d2504 1
a2504 1
		Debugger();
d2506 1
d2508 5
a2512 16
		if( data_pointer_debug > 1 )
			printf("next dmastop: %d(%x:%x)\n",
			       dev->target,dev->sc_cur->dc_addr,dev->sc_tcnt);
#endif
		dev->sc_dmastop(dev);
		sbicerror(dev, regs, csr);
		sbicabort(dev, regs, "next");
		if (dev->sc_flags & SBICF_INDMA) {
			/*
			 * check for overlapping cache line, flush if so
			 */
#ifdef M68040
			if (dev->sc_flags & SBICF_DCFLUSH) {
#if 0
				printf("sibc: 68040 DMA cache flush needs fixing? %x:%x\n",
				    dev->sc_xs->data, dev->sc_xs->datalen);
d2514 9
a2522 4
			}
#endif
			dev->sc_flags &=
				~(SBICF_INDMA | SBICF_DCFLUSH);
d2524 5
a2528 3
		if( data_pointer_debug > 1 )
			printf("next dmastop: %d(%x:%x)\n",
			       dev->target,dev->sc_cur->dc_addr,dev->sc_tcnt);
d2530 6
a2535 5
			dev->sc_dmastop(dev);
			sbic_scsidone(acb, -1);
		}
                return SBIC_STATE_ERROR;
	}
d2537 1
a2537 1
	return(SBIC_STATE_RUNNING);
a2543 1

d2546 3
a2548 2
	void *bp;
	u_long len, mask;
d2550 25
a2574 19
	u_char *buffer;
	u_long phy_buf;
	u_long phy_len;

	buffer = bp;

	if (len == 0)
		return(0);

	while (len) {
		phy_buf = kvtop(buffer);
		if (len < (phy_len = NBPG - ((int) buffer & PGOFSET)))
			phy_len = len;
		if (phy_buf & mask)
			return(1);
		buffer += phy_len;
		len -= phy_len;
	}
	return(0);
d2578 22
a2599 18
sbictoscsiperiod(dev, regs, a)
	struct sbic_softc *dev;
	sbic_regmap_p regs;
	int a;
{
	unsigned int fs;

	/*
	 * cycle = DIV / (2*CLK)
	 * DIV = FS+2
	 * best we can do is 200ns at 20Mhz, 2 cycles
	 */

	GET_SBIC_myid(regs,fs);
	fs = (fs >>6) + 2;		/* DIV */
	fs = (fs * 10000) / (dev->sc_clkfreq<<1);	/* Cycle, in ns */
	if (a < 2) a = 8;		/* map to Cycles */
	return ((fs*a)>>2);		/* in 4 ns units */
d2603 3
a2605 4
sbicfromscsiperiod(dev, regs, p)
	struct sbic_softc *dev;
	sbic_regmap_p regs;
	int p;
d2607 7
a2613 1
	register unsigned int fs, ret;
d2615 1
a2615 1
	/* Just the inverse of the above */
d2617 1
a2617 3
	GET_SBIC_myid(regs,fs);
	fs = (fs >>6) + 2;		/* DIV */
	fs = (fs * 10000) / (dev->sc_clkfreq<<1);   /* Cycle, in ns */
d2619 2
a2620 4
	ret = p << 2;			/* in ns units */
	ret = ret / fs;			/* in Cycles */
	if (ret < sbic_min_period)
		return(sbic_min_period);
d2622 10
a2631 4
	/* verify rounding */
	if (sbictoscsiperiod(dev, regs, ret) < p)
		ret++;
	return (ret >= 8) ? 0 : ret;
d2635 6
d2642 10
a2651 3
void sbicdumpstate()
{
	u_char csr, asr;
d2653 7
a2659 8
	GET_SBIC_asr(debug_sbic_regs,asr);
	GET_SBIC_csr(debug_sbic_regs,csr);
	printf("%s: asr:csr(%02x:%02x)->(%02x:%02x)\n",
	       (routine==1)?"sbicgo":
	       (routine==2)?"sbicintr":
	       (routine==3)?"sbicicmd":
	       (routine==4)?"sbicnext":"unknown",
	       debug_asr, debug_csr, asr, csr);
d2661 2
a2662 1
}
d2664 1
a2664 4
void sbictimeout(dev)
	struct sbic_softc *dev;
{
	int s, asr;
d2666 1
a2666 14
	/* Dump this every second while there's an active command */
	if( dev->sc_nexus ) {
		s = splbio();
		GET_SBIC_asr(dev->sc_sbicp, asr);
		if( asr & SBIC_ASR_INT ) {
			/* We need to service a missed IRQ */
			printf("Servicing a missed int:(%02x,%02x)->(%02x,??)\n",
			       debug_asr, debug_csr, asr);
			sbicintr(dev);
		}
		splx(s);
		sbicdumpstate();
		timeout((void *)sbictimeout, (void*)dev, sbic_timeout * hz);
	} else timeout_active = 0;
a2667 1

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sbic.c,v 1.14 1995/08/18 15:28:03 chopps Exp $	*/
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
