head	1.27;
access;
symbols
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.18.0.18
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.14
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.12
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.10
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.14
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.27
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.26;

1.26
date	2013.10.07.17.53.57;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.07.04.00.25.37;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2012.11.04.13.33.32;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.28.14.13.29;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.24.22.43.16;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.30.22.29.45;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.30.09.50.15;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.02.17.57.29;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.21.09.01;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.27.05.44.48;	author nate;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.03.26.23.31.59;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.02.22.12.09.45;	author deraadt;	state Exp;
branches
	1.3.14.1;
next	1.2;

1.2
date	97.02.11.02.55.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.12.24.20.31.23;	author deraadt;	state Exp;
branches;
next	;

1.3.14.1
date	2001.04.18.16.10.32;	author niklas;	state Exp;
branches;
next	1.3.14.2;

1.3.14.2
date	2001.07.04.10.19.29;	author niklas;	state Exp;
branches;
next	1.3.14.3;

1.3.14.3
date	2002.03.06.01.07.00;	author niklas;	state Exp;
branches;
next	1.3.14.4;

1.3.14.4
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.3.14.5;

1.3.14.5
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.3.14.6;

1.3.14.6
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.3.14.7;

1.3.14.7
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: wl.c,v 1.26 2013/10/07 17:53:57 miod Exp $ */

/*
 * Copyright (c) 1995 Dale Rahn. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */  

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>

#include <mvme68k/dev/wlreg.h>
#include <mvme68k/dev/vme.h>

#include "cl.h"

#include "vmes.h"

#define splcl() spltty()

/* min timeout 0xa, what is a good value */
#define CL_TIMEOUT	0x10
#define CL_FIFO_MAX	0x10
#define CL_FIFO_CNT	0xc
#define	CL_RX_TIMEOUT	0x10

#define CL_RXDMAINT	0x82
#define CL_TXDMAINT	0x42
#define CL_TXMASK	0x47
#define CL_RXMASK	0x87 
#define CL_TXINTR	0x02
#define CL_RXINTR	0x02

#define WLRAMLEN	(1 << 16)
struct clboard {
	union {
		struct clreg	clreg;
		volatile char		xx[256];
	} chips[2];
	union {
		volatile u_char		base;
		volatile char		xx[256];
	} sram;
	union {
		volatile u_char		val;
		volatile char		xx[256];
	} ringstatus;
	union {
		volatile u_char		val;
		volatile char		xx[256];
	} ringreset;
	union {
		volatile u_char		val;
		volatile char		xx[256];
	} master;
	union {
		volatile u_char		val;
		volatile char		xx[256];
	} reset;
};


struct cl_info {
	struct tty *tty;
	u_char	cl_swflags;
	u_char	cl_softchar;
	u_char	cl_speed;
	u_char	cl_parstop;	/* parity, stop bits. */
	u_char	cl_rxmode;
	u_char	cl_txmode;
	u_char	cl_clen;
	u_char	cl_parity;
	u_char  transmitting;
	u_long  txcnt;
	u_long  rxcnt;

	volatile void	*rx[2];
	volatile void	*rxp[2];
	volatile void	*tx[2];
	volatile void	*txp[2];
};
#define CLCD_PORTS_PER_CHIP 4
#define CL_BUFSIZE 128

struct wlsoftc {
	struct device	sc_dev;
	char		sc_txintrname[16 + 3];
	char		sc_rxintrname[16 + 3];
	char		sc_mxintrname[16 + 3];

	time_t		sc_rotime;	/* time of last ring overrun */
	time_t		sc_fotime;	/* time of last fifo overrun */

	u_char		sc_memv;
	paddr_t		sc_memvme;
	void		*sc_memp;
	vaddr_t		sc_memkv;

	struct clreg	*cl_reg;
	struct cl_info	sc_cl[CLCD_PORTS_PER_CHIP];
	struct intrhand	sc_ih_e;
	struct intrhand	sc_ih_m;
	struct intrhand	sc_ih_t;
	struct intrhand	sc_ih_r;
	u_char		sc_vec;
	int		sc_flags;
};

struct {
	u_int speed;
	u_char divisor;
	u_char clock;
	u_char rx_timeout;
} cl_clocks[] = {
	/* 30.000 MHz */
	{   64000, 0x3a, 0, 0x01 },
	{   56000, 0x42, 0, 0x01 },
	{   38400, 0x61, 0, 0x01 },
	{   19200, 0xc2, 0, 0x01 },
	{    9600, 0x61, 1, 0x02 },
	{    7200, 0x81, 1, 0x04 },
	{    4800, 0xc2, 1, 0x04 },
	{    3600, 0x40, 2, 0x08 },
	{    2400, 0x61, 2, 0x10 },
	{    1200, 0xc2, 2, 0x20 },
	{     600, 0x61, 3, 0x40 },
	{     300, 0xc2, 3, 0x80 },
	{     150, 0x61, 4, 0xa0 },
	{     110, 0x84, 4, 0xff },
	{      50, 0x00, 5, 0xff },
	{       0, 0x00, 0, 0},
};

/* prototypes */
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct wlsoftc *sc, struct termios *par, int channel);

int clparam(struct tty *tp, struct termios *t);
int cl_intr(struct wlsoftc *sc, int);
int cl_mintr(struct wlsoftc *sc);
int cl_txintr(struct wlsoftc *sc);
int cl_rxintr(struct wlsoftc *sc);
void cl_overflow(struct wlsoftc *sc, int channel, time_t *ptime, u_char *msg);
void cl_parity(struct wlsoftc *sc, int channel);
void cl_frame(struct wlsoftc *sc, int channel);
void cl_break( struct wlsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
void cl_dumpport(int channel);

int	wlprobe(struct device *parent, void *self, void *aux);
void	wlattach(struct device *parent, struct device *self, void *aux);

static void cl_initchannel(struct wlsoftc *sc, int channel);
static void clputc(struct wlsoftc *sc, int unit, u_char c);
static u_char clgetc(struct wlsoftc *sc, int *channel);
static void cloutput(struct tty *tp);

struct cfattach wl_ca = {
	sizeof(struct wlsoftc), wlprobe, wlattach
};

struct cfdriver wl_cd = {
	NULL, "wl", DV_TTY
};

#define CLCDBUF 80

#define CL_UNIT(x) (minor(x) >> 2)
#define CL_CHANNEL(x) (minor(x) & 3)
#define CL_TTY(x) (minor(x))

extern int cputyp;

struct tty *
wltty(dev)
	dev_t dev;
{
	int unit = CL_UNIT(dev);
	int channel;
	struct wlsoftc *sc;

	if (unit >= wl_cd.cd_ndevs || 
	    (sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL)
		return (NULL);
	channel = CL_CHANNEL(dev);
	return sc->sc_cl[channel].tty;
}

int
wlprobe(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
{
	struct confargs *ca = aux;
	struct wlsoftc *sc = self;
	struct clreg *cl_reg = (struct clreg *)ca->ca_vaddr;

	if (ca->ca_vec & 0x03) {
		printf("%s: bad vector\n", sc->sc_dev.dv_xname);
		return (0);
	}
	return (!badvaddr(&cl_reg->cl_gfrcr, 1));
}

void
wlattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct wlsoftc *sc = (struct wlsoftc *)self;
	struct confargs *ca = aux;
	struct clboard *clb = (struct clboard *)ca->ca_vaddr;
	void *p;
	int i, j, s;

	sc->cl_reg = (struct clreg *)&clb->chips[0].clreg;
	sc->sc_vec = ca->ca_vec;

	sc->sc_memv = 0xa5 + 0;
	sc->sc_memvme = ((0xff00 + sc->sc_memv) << 16);

	clb->reset.val = 0xff;		/* reset card */
	DELAY(1000);
	clb->sram.base = (sc->sc_memvme >> 16) & 0xff;
	DELAY(1000);
	clb->master.val = 0x01;		/* enable sram decoder */
	DELAY(1000);

	printf(":");
	/*printf(" va=%x sc=%x slot 0x%02x vmes 0x%08x", sc->cl_reg, sc,
	    sc->sc_memv, sc->sc_memvme);*/

	while (sc->cl_reg->cl_gfrcr == 0x00)
		;
	sc->cl_reg->cl_ccr = 0x10;	/* reset it */
	while (sc->cl_reg->cl_gfrcr == 0x00)
		;
	if (sc->cl_reg->cl_gfrcr <= 0x10)
		printf(" rev %c", 'A' + sc->cl_reg->cl_gfrcr);
	else
		printf(" rev 0x%02x", sc->cl_reg->cl_gfrcr);
	printf("\n");

	/* set up global registers */
	sc->cl_reg->cl_tpr = CL_TIMEOUT;
	sc->cl_reg->cl_rpilr = (ca->ca_ipl << 1) | 1;
	sc->cl_reg->cl_tpilr = (ca->ca_ipl << 1) | 1;
	sc->cl_reg->cl_mpilr = (ca->ca_ipl << 1) | 1;

	sc->sc_memkv = vmemap(((struct vmessoftc *)parent)->sc_vme,
	    sc->sc_memvme, WLRAMLEN, BUS_VMES);
	sc->sc_memp = (void *)kvtop(sc->sc_memkv);
	if (sc->sc_memkv == 0)
		printf("%s: got no memory", sc->sc_dev.dv_xname);
	else if (badvaddr(sc->sc_memkv, 1))
		printf("%s: cannot tap 0x%08x", sc->sc_dev.dv_xname, sc->sc_memkv);
	else {
		u_char *x = (u_char *)sc->sc_memkv;

		/*printf("%s: pa 0x%08x va 0x%08x", sc->sc_dev.dv_xname,
		    sc->sc_memp, sc->sc_memkv);*/
		x[0] = 0xaa;
		x[1] = 0x55;
		if (x[0] != 0xaa || x[1] != 0x55)
			printf(" 0x%02x 0x%02x", x[0], x[1]);
		x[0] = 0x55;
		x[1] = 0xaa;
		if (x[0] != 0x55 || x[1] != 0xaa)
			printf(" 0x%02x 0x%02x", x[0], x[1]);
		bzero(x, WLRAMLEN);
	}

	/* enable interrupts */
	sc->sc_ih_e.ih_fn = cl_intr;
	sc->sc_ih_e.ih_arg = sc;
	sc->sc_ih_e.ih_ipl = ca->ca_ipl;
	sc->sc_ih_e.ih_wantframe = 0;

	sc->sc_ih_m.ih_fn = cl_intr;
	sc->sc_ih_m.ih_arg = sc;
	sc->sc_ih_m.ih_ipl = ca->ca_ipl;
	sc->sc_ih_m.ih_wantframe = 0;

	sc->sc_ih_t.ih_fn = cl_intr;
	sc->sc_ih_t.ih_arg = sc;
	sc->sc_ih_t.ih_ipl = ca->ca_ipl;
	sc->sc_ih_t.ih_wantframe = 0;

	sc->sc_ih_r.ih_fn = cl_intr;
	sc->sc_ih_r.ih_arg = sc;
	sc->sc_ih_r.ih_ipl = ca->ca_ipl;
	sc->sc_ih_r.ih_wantframe = 0;

	snprintf(sc->sc_txintrname, sizeof sc->sc_txintrname,
	    "%s_tx", self->dv_xname);
	snprintf(sc->sc_rxintrname, sizeof sc->sc_rxintrname,
	    "%s_rx", self->dv_xname);
	snprintf(sc->sc_mxintrname, sizeof sc->sc_mxintrname,
	    "%s_mx", self->dv_xname);

	vmeintr_establish(ca->ca_vec + 0, &sc->sc_ih_e, sc->sc_rxintrname);
	vmeintr_establish(ca->ca_vec + 1, &sc->sc_ih_m, sc->sc_mxintrname);
	vmeintr_establish(ca->ca_vec + 2, &sc->sc_ih_t, sc->sc_txintrname);
	vmeintr_establish(ca->ca_vec + 3, &sc->sc_ih_r, sc->sc_rxintrname);

	p = (void *)sc->sc_memkv;
	s = splhigh();
	for (i = 0; i < CLCD_PORTS_PER_CHIP; i++) {
		for (j = 0; j < 2; j++) {
			sc->sc_cl[i].rx[j] = p;
			sc->sc_cl[i].rxp[j] = (void *)(p - (void *)sc->sc_memkv);
			/*printf("%d:%d rx v %x p %x\n",
			    i, j, sc->sc_cl[i].rx[j], sc->sc_cl[i].rxp[j]);*/
			p += CL_BUFSIZE;
		}
		for (j = 0; j < 2; j++) {
			sc->sc_cl[i].tx[j] = p;
			sc->sc_cl[i].txp[j] = (void *)(p - (void *)sc->sc_memkv);
			/*printf("%d:%d tx v %x p %x\n",
			    i, j, sc->sc_cl[i].tx[j], sc->sc_cl[i].txp[j]);*/
			p += CL_BUFSIZE;
		}
		cl_initchannel(sc, i);
	}
	splx(s);
}

static void
cl_initchannel(sc, channel)
	struct wlsoftc *sc;
	int channel;
{
	struct clreg *cl_reg = sc->cl_reg;

	/* set up option registers */
	cl_reg->cl_car	= channel;
	cl_reg->cl_livr	= sc->sc_vec;
	cl_reg->cl_ier	= 0x00;
	cl_reg->cl_cmr	= 0x02;
	cl_reg->cl_cor1	= 0x17;
	cl_reg->cl_cor2	= 0x00;
	cl_reg->cl_cor3	= 0x02;
	cl_reg->cl_cor4	= 0xec;
	cl_reg->cl_cor5	= 0xec;
	cl_reg->cl_cor6	= 0x00;
	cl_reg->cl_cor7	= 0x00;
	cl_reg->cl_schr1 = 0x00;
	cl_reg->cl_schr2 = 0x00;
	cl_reg->cl_schr3 = 0x00;
	cl_reg->cl_schr4 = 0x00;
	cl_reg->cl_scrl	= 0x00;
	cl_reg->cl_scrh	= 0x00;
	cl_reg->cl_lnxt	= 0x00;
	cl_reg->cl_rbpr	= 0x40; /* 9600 */
	cl_reg->cl_rcor	= 0x01;
	cl_reg->cl_tbpr	= 0x40; /* 9600 */
	cl_reg->cl_tcor	= 0x01 << 5;
	/* console port should be 0x88 already */
	cl_reg->cl_msvr_rts	= 0x00;
	cl_reg->cl_msvr_dtr	= 0x00;
	cl_reg->cl_rtprl	= CL_RX_TIMEOUT;
	cl_reg->cl_rtprh	= 0x00;
	sc->cl_reg->cl_ccr = 0x20;
	while (sc->cl_reg->cl_ccr != 0)
		;
}


int cldefaultrate = TTYDEF_SPEED;

int clmctl (dev, bits, how)
	dev_t dev;
	int bits;
	int how;
{
	int s;
	struct wlsoftc *sc;
	/* should only be called with valid device */
	sc = (struct wlsoftc *) wl_cd.cd_devs[CL_UNIT(dev)];
	/*
	printf("mctl: dev %x, bits %x, how %x,\n",dev, bits, how);
	*/
	/* settings are currently ignored */
	s = splcl();
	switch (how) {
	case DMSET:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x01;
		} else {
			sc->cl_reg->cl_msvr_rts = 0x00;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x02;
		} else {
			sc->cl_reg->cl_msvr_dtr = 0x00;
		}
		break;

	case DMBIC:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x00;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x00;
		}
		break;

	case DMBIS:
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x01;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x02;
		}
		break;

	case DMGET:
		bits = 0;

		{
			u_char msvr;
			msvr = sc->cl_reg->cl_msvr_rts;
			if( msvr & 0x80) {
				bits |= TIOCM_DSR;
			}
			if( msvr & 0x40) {
				bits |= TIOCM_CD;
			}
			if( msvr & 0x20) {
				bits |= TIOCM_CTS;
			}
			if( msvr & 0x10) {
				bits |= TIOCM_DTR;
			}
			if( msvr & 0x02) {
				bits |= TIOCM_DTR;
			}
			if( msvr & 0x01) {
				bits |= TIOCM_RTS;
			}
			
		}
		break;
	}
	splx(s);
#if 0
	bits = 0;
	/* proper defaults? */
	bits |= TIOCM_DTR;
	bits |= TIOCM_RTS;
	bits |= TIOCM_CTS;
	bits |= TIOCM_CD;
	/*	bits |= TIOCM_RI; */
	bits |= TIOCM_DSR;
#endif

	/*
	printf("retbits %x\n", bits);
	*/
	return(bits);
}

int
wlopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int s, unit, channel;
	struct cl_info *cl;
	struct wlsoftc *sc;
	struct tty *tp;
	
	unit = CL_UNIT(dev);
	if (unit >= wl_cd.cd_ndevs || 
		(sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	s = splcl();
	if (cl->tty) {
		tp = cl->tty;
	} else {
		tp = cl->tty = ttymalloc(0);
	}
	tp->t_oproc = clstart;
	tp->t_param = clparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = cldefaultrate;

			tp->t_cflag = TTYDEF_CFLAG;
		}
		/*
		 * do these all the time
		 */
		if (cl->cl_swflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (cl->cl_swflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (cl->cl_swflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		clparam(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
		tp->t_state |= TS_CARR_ON;
		{
			u_char save = sc->cl_reg->cl_car;
			sc->cl_reg->cl_car = channel;
			sc->cl_reg->cl_ier = IER_MDM | IER_RXD;
			sc->cl_reg->cl_car = save;
		}
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0) {
		splx(s);
		return(EBUSY);
	}

	splx(s);
	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
	return((*linesw[tp->t_line].l_open)(dev, tp, p));
}

int clparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	int unit, channel;
	struct wlsoftc *sc;
	int s;
	dev_t dev;

	dev = tp->t_dev;
	unit = CL_UNIT(dev);
	if (unit >= wl_cd.cd_ndevs || 
		(sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	clccparam(sc, t, channel);
	s = splcl();
	cl_unblock(tp);
	splx(s);
	return 0;
}

void cloutput(tp)
	struct tty *tp;
{
	int cc, s, unit, cnt;
	u_char *tptr;
	int channel;
	struct wlsoftc *sc;
	dev_t dev;
	u_char cl_obuffer[CLCDBUF+1];

	dev = tp->t_dev;
	unit = CL_UNIT(dev);
	if (unit >= wl_cd.cd_ndevs || 
		(sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
		return;
	}
	channel = CL_CHANNEL(dev);

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splcl();
	cc = tp->t_outq.c_cc;
	while (cc > 0) {
/*XXX*/
		cnt = min(CLCDBUF,cc);
		cnt = q_to_b(&tp->t_outq, cl_obuffer, cnt);
		if (cnt == 0) {
			break;
		}
		for (tptr = cl_obuffer; tptr < &cl_obuffer[cnt]; tptr++) {
			clputc(sc, channel, *tptr);
		}
		cc -= cnt;
	}
	splx(s);
}

int
wlclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct wlsoftc *sc;
	int s;
	unit = CL_UNIT(dev);
	if (unit >= wl_cd.cd_ndevs || 
		(sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	(*linesw[tp->t_line].l_close)(tp, flag, p);

	s = splcl();
	
	sc->cl_reg->cl_car = channel;
	if((tp->t_cflag & HUPCL) != 0) {
		sc->cl_reg->cl_msvr_rts = 0x00;
		sc->cl_reg->cl_msvr_dtr = 0x00;
		sc->cl_reg->cl_ccr = 0x05;
		sc->cl_reg->cl_ier = 0x00;
	}

	splx(s);
	ttyclose(tp);

#if 0
	cl->tty = NULL;
#endif
	return (0);
}

int
wlread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct wlsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= wl_cd.cd_ndevs || 
		(sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;
	return((*linesw[tp->t_line].l_read)(tp, uio, flag));
}
int
wlwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct wlsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= wl_cd.cd_ndevs || 
		(sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;
	return((*linesw[tp->t_line].l_write)(tp, uio, flag));
}
int
wlioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error;
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct wlsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= wl_cd.cd_ndevs || 
		(sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (!tp)
		return ENXIO;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return(error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return(error);

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;

	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
		(void) clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) clmctl(dev, *(int *) data, DMSET);
		break;

	case TIOCMBIS:
		(void) clmctl(dev, *(int *) data, DMBIS);
		break;

	case TIOCMBIC:
		(void) clmctl(dev, *(int *) data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = clmctl(dev, 0, DMGET);
		break;
	case TIOCGFLAGS:
		*(int *)data = cl->cl_swflags;
		break;
	case TIOCSFLAGS:
		error = suser(p, 0); 
		if (error != 0)
			return(EPERM); 

		cl->cl_swflags = *(int *)data;
		cl->cl_swflags &= /* only allow valid flags */
			(TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;
	default:
		return(ENOTTY);
	}

	return 0;
}
int
wlstop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = splcl();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
}

static u_char 
clgetc(sc, channel)
	struct wlsoftc *sc;
	int *channel;
{
	struct clreg *cl_reg;
	u_char reoir, licr, isrl, fifo_cnt, data;

	cl_reg = sc->cl_reg;
	/* if no receive interrupt pending wait */
	if ((cl_reg->cl_rir & RIR_REN) == 0) {
		return 0;
	}
	/* XXX do we need to suck the entire FIFO contents? */
	licr = cl_reg->cl_licr;
	*channel = (licr >> 2) & 0x3;
	/* is the interrupt for us (port 0) */
	/* the character is for us yea. */
	isrl = cl_reg->cl_risrl;
#if 0
	if (isrl & 0x01) {
		status = BREAK;
	}
	if (isrl & 0x02) {
		status = FRAME;
	}
	if (isrl & 0x04) {
		status = PARITY;
	}
	if (isrl & 0x08) {
		status = OVERFLOW;
	}
	/* we do not have special characters ;-) */
#endif
	fifo_cnt = cl_reg->cl_rfoc;
	if (fifo_cnt > 0) {
		data = cl_reg->cl_rdr;
		cl_reg->cl_teoir = 0x00;
	} else {
		data = 0;
		cl_reg->cl_teoir = 0x08;
	}
	return data;
}

int
clccparam(sc, par, channel)
	struct wlsoftc *sc;
	struct termios *par;
	int channel;
{
	u_int divisor, clk, clen;
	int s, imask, ints;

	s = splcl();
	sc->cl_reg->cl_car = channel;
	if (par->c_ospeed == 0) { 
		/* disconnect, drop RTS DTR stop receiver */
		sc->cl_reg->cl_msvr_rts = 0x00;
		sc->cl_reg->cl_msvr_dtr = 0x00;
		sc->cl_reg->cl_ccr = 0x05;
		splx(s);
		return (0xff);
	}

	sc->cl_reg->cl_msvr_rts = 0x03;
	sc->cl_reg->cl_msvr_dtr = 0x03;

	divisor = cl_clkdiv(par->c_ospeed);
	clk	= cl_clknum(par->c_ospeed);
	sc->cl_reg->cl_tbpr = divisor;
	sc->cl_reg->cl_tcor = clk << 5;
	divisor = cl_clkdiv(par->c_ispeed);
	clk	= cl_clknum(par->c_ispeed);
	sc->cl_reg->cl_rbpr = divisor;
	sc->cl_reg->cl_rcor = clk;
	sc->cl_reg->cl_rtprl = cl_clkrxtimeout(par->c_ispeed);
	sc->cl_reg->cl_rtprh = 0x00;

	switch (par->c_cflag & CSIZE) {
	case CS5:
		clen = 4; /* this is the mask for the chip. */
		imask = 0x1F;
		break;
	case CS6:
		clen = 5;
		imask = 0x3F;
		break;
	case CS7:
		clen = 6;
		imask = 0x7F;
		break;
	default:
		clen = 7;
		imask = 0xFF;
	}
	sc->cl_reg->cl_cor3 = par->c_cflag & PARENB ? 4 : 2;

	{
		u_char cor1;
		if (par->c_cflag & PARENB) {
			if (par->c_cflag & PARODD) {
				cor1 = 0xE0 | clen ; /* odd */
			} else {
				cor1 = 0x40 | clen ; /* even */
			}
		} else {
			cor1 = 0x10 | clen; /* ignore parity */
		}
		if (sc->cl_reg->cl_cor1 != cor1) { 
			sc->cl_reg->cl_cor1 = cor1;
			sc->cl_reg->cl_ccr = 0x20;
			while (sc->cl_reg->cl_ccr != 0)
				;
		}
	}

	if ((par->c_cflag & CREAD) == 0) {
		sc->cl_reg->cl_ccr = 0x08;
	} else {
		sc->cl_reg->cl_ccr = 0x0a;
	}
	while (sc->cl_reg->cl_ccr != 0)
		;

	ints = 0;
#define SCC_DSR 0x80
#define SCC_DCD 0x40
#define SCC_CTS 0x20
	if ((par->c_cflag & CLOCAL) == 0) {
		ints |= SCC_DCD;
	}
	if ((par->c_cflag & CCTS_OFLOW) != 0) {
		ints |= SCC_CTS;
	}
	if ((par->c_cflag & CRTSCTS) != 0) {
		ints |= SCC_CTS;
	}
#ifdef DONT_LET_HARDWARE
	if ((par->c_cflag & CCTS_IFLOW) != 0) {
		ints |= SCC_DSR;
	}
#endif
	sc->cl_reg->cl_cor4 = ints | CL_FIFO_CNT;
	sc->cl_reg->cl_cor5 = ints | CL_FIFO_CNT;

	return imask;
}

static int clknum = 0;

u_char 
cl_clkdiv(speed)
	int speed;
{
	int i = 0;

	if (cl_clocks[clknum].speed == speed)
		return cl_clocks[clknum].divisor;

	for  (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[i].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].divisor;
		}
	}

	/* return some sane value if unknown speed */
	clknum = 4;
	return cl_clocks[clknum].divisor;
}
u_char 
cl_clknum(speed)
	int speed;
{
	int found = 0;
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
		return cl_clocks[clknum].clock;
	}
	for  (i = 0; found != 0 && cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[clknum].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].clock;
		}
	}
	/* return some sane value if unknown speed */
	return cl_clocks[4].clock;
}
u_char 
cl_clkrxtimeout(speed)
	int speed;
{
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
		return cl_clocks[clknum].rx_timeout;
	}
	for  (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[i].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].rx_timeout;
		}
	}
	/* return some sane value if unknown speed */
	return cl_clocks[4].rx_timeout;
}
void
cl_unblock(tp)
	struct tty *tp;
{
	tp->t_state &= ~TS_FLUSH;
	if (tp->t_outq.c_cc != 0)
		clstart(tp);
}
void
clstart(tp)
	struct tty *tp;
{
	dev_t dev;
	u_char cbuf;
	struct wlsoftc *sc;
	int channel, unit, s, cnt;

	dev = tp->t_dev;
	channel = CL_CHANNEL(dev);
	unit = CL_UNIT(dev);
	if (unit >= wl_cd.cd_ndevs || 
	    (sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
		return;
	}

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splcl();
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0) {
		tp->t_state |= TS_BUSY;
		sc->cl_reg->cl_car = channel;
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier | IER_TXMPTY | IER_TXD;
#if 0
		zscnputc(0, 'S');
#endif
	}
	splx(s);
}

int
cl_intr(sc, vec)
	struct wlsoftc *sc;
	int vec;
{
	u_char livr = sc->cl_reg->cl_livr;
	u_char stk = sc->cl_reg->cl_stk;
	int i = 0;

	stk = ((stk & 0x80) >> 6) | (stk & 0x01);
#if 1
	zscnputc(0, '[');
	zscnputc(0, '0' + vec - 0x70);
	zscnputc(0, '0' + livr - 0x70);
	zscnputc(0, '0' + stk);
	zscnputc(0, ']');
#endif

	switch (stk & 3) {
	case 0:
#if 0
		i += cl_rxintr(sc);
		i += cl_mintr(sc);
		i += cl_txintr(sc);
#else
		i += cl_rxintr(sc);
#endif
		break;
	case 1:
		i += cl_mintr(sc);
		break;
	case 2:
		i += cl_txintr(sc);
		break;
	case 3:
		i += cl_rxintr(sc);
		break;
	}
	return (i);
}

int
cl_mintr(sc)
	struct wlsoftc *sc;
{
	u_char mir, misr, msvr;
	int channel;
	struct tty *tp;

	mir = sc->cl_reg->cl_mir;
	if((mir & MIR_MACT) == 0)
		return 0;
	zscnputc(0, 'M');

	misr = sc->cl_reg->cl_misr;
	msvr = sc->cl_reg->cl_msvr_rts;
	channel = mir & MIR_MCM_M;

	printf("stk 0x%x mir 0x%x chan 0x%x\n",
	    sc->cl_reg->cl_stk, mir, channel);

	if (misr & MISR_TIMER1) {
		/* timers are not currently used?? */
		log(LOG_WARNING, "cl_mintr: channel %x timer 1 unexpected\n",channel);
	}
	if (misr & MISR_TIMER2) {
		/* timers are not currently used?? */
		log(LOG_WARNING, "cl_mintr: channel %x timer 2 unexpected\n",channel);
	}
	if (misr & MISR_CTSCHG) {
		log(LOG_WARNING, "cl_mintr: channel %x cts %x\n",channel, 
		    ((msvr & 0x20) != 0x0));
	}
	if (misr & MISR_CDCHG) {
		struct tty *tp = sc->sc_cl[channel].tty;
		log(LOG_WARNING, "cl_mintr: channel %x cd %x\n",channel,
		    ((msvr & 0x40) != 0x0));
		(*linesw[tp->t_line].l_modem)(tp, ((msvr & 0x40) != 0x0) );
	}
	if (misr & MISR_DSRCHG) {
		log(LOG_WARNING, "cl_mintr: channel %x dsr %x\n",channel,
		    ((msvr & 0x80) != 0x0));
	}
	sc->cl_reg->cl_meoir = 0x00;
	return 1;
}

int
cl_txintr(sc)
	struct wlsoftc *sc;
{
	static int empty = 0;
	u_char tir, cmr, teoir, tisr, tftc;
	int chan;
	struct tty *tp;
	int cnt;
	u_char buffer[CL_FIFO_MAX +1];
	u_char *tptr;
	u_char dmabsts;
	int nbuf, busy, resid;
	void *pbuffer;

	tir = sc->cl_reg->cl_tir;
	if((tir & (TIR_TEN|TIR_TACT)) == 0)
		return 0;
#if 0
	zscnputc(0, 'T');
#endif

	cmr = sc->cl_reg->cl_cmr;
	chan = tir & TIR_TCN_M;
	tisr = sc->cl_reg->cl_tisr;
	tftc = sc->cl_reg->cl_tftc;
	
	printf("stk 0x%x tir 0x%x chan 0x%x cmr 0x%x tisr 0x%x tftc 0x%x\n",
	    sc->cl_reg->cl_stk, tir, chan, cmr, tisr, tftc);

	sc->sc_cl[chan].txcnt++;
	tp = sc->sc_cl[chan].tty;

	if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0) {
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~(IER_TXMPTY|IER_TXD);
		sc->cl_reg->cl_teoir = TEOIR_NOTRANSF;
		return 1;
	}

	switch (cmr & CL_TXMASK) {
	case CL_TXINTR:
		cnt = min((int)tftc, tp->t_outq.c_cc);
		if (cnt != 0) {
			/*printf("s%d ", cnt);*/
			cnt = q_to_b(&tp->t_outq, buffer, cnt);
			/*printf("%d:", cnt);*/
			empty = 0;
			for (tptr = buffer; tptr < &buffer[cnt]; tptr++) {
				/*printf("%c", *tptr);*/
				sc->cl_reg->cl_tdr = *tptr;
			}
			/*printf("\n", cnt);*/
			teoir = 0;
		} else {
			if (empty > 5 && ((empty % 20000 )== 0))
				log(LOG_WARNING, "cl_txintr empty intr %d chan %d\n",
				    empty, chan);
			empty++;
			teoir = TEOIR_NOTRANSF;
			if (tp->t_state & TS_BUSY) {
				tp->t_state &= ~(TS_BUSY | TS_FLUSH);
				if (tp->t_state & TS_ASLEEP) {
					tp->t_state &= ~TS_ASLEEP;
					wakeup((caddr_t) &tp->t_outq);
				}
				selwakeup(&tp->t_wsel);
			}
			sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~(IER_TXMPTY|IER_TXD);
		}
		break;
	default:
		log(LOG_WARNING, "cl_txintr unknown mode %x\n", cmr);
		/* we probably will go to hell quickly now */
		teoir = TEOIR_NOTRANSF;
		break;
	}
	sc->cl_reg->cl_teoir = teoir;
	return (1);
}

int
cl_rxintr(sc)
	struct wlsoftc *sc;
{
	u_char rir, chan, cmr, risrl;
	u_char buffer[CL_FIFO_MAX +1];
	u_char reoir = REOIR_NOTRANSF, fifocnt, c;
	struct tty *tp;
	int i;
	
	rir = sc->cl_reg->cl_rir;
	if((rir & RIR_RACT) == 0)
		return 0;
#if 0
	zscnputc(0, 'R');
#endif

	cmr = sc->cl_reg->cl_cmr;
	risrl = sc->cl_reg->cl_risrl;
	chan = rir & RIR_RCN_M;

	/*printf("stk 0x%x rir 0x%x chan 0x%x cmr 0x%x risrl 0x%x\n",
	    sc->cl_reg->cl_stk, rir, chan, cmr, risrl);*/

	sc->sc_cl[chan].rxcnt++;

	if (risrl & RISRL_TIMEOUT) {
		reoir = REOIR_NOTRANSF;
	} else if (risrl & RISRL_OE) {
		cl_overflow(sc, chan, &sc->sc_fotime, "fifo");
		reoir = REOIR_NOTRANSF;
	} else if (risrl & RISRL_PE) {
		cl_parity(sc, chan);
		reoir = REOIR_NOTRANSF;
	} else if (risrl & RISRL_FE) {
		cl_frame(sc, chan);
		reoir = REOIR_NOTRANSF;
	} else if (risrl & RISRL_BREAK) {
		cl_break(sc, chan);
		reoir = REOIR_NOTRANSF;
	} else {
		switch (cmr & CL_RXMASK) {
		case CL_RXINTR:
			fifocnt = sc->cl_reg->cl_rfoc;
			tp = sc->sc_cl[chan].tty;
			for (i = 0; i < fifocnt; i++)
				buffer[i] = sc->cl_reg->cl_rdr;
			if (NULL == tp) {
				/*
				 * if the channel is not configured,
				 * dont send characters upstream.
				 * also fix problem with NULL dereference
				 */
				reoir = 0;
				break;
			}
	
			sc->cl_reg->cl_reoir = reoir;
			for (i = 0; i < fifocnt; i++) {
				u_char c = buffer[i];
	
				/* does any restricitions exist on spl for this call */
				(*linesw[tp->t_line].l_rint)(c, tp);
				reoir = 0;
			}
			break;
		default:
			log(LOG_WARNING, "cl_rxintr unknown mode %x\n", cmr);
			/* we probably will go to hell quickly now */
			reoir = REOIR_NOTRANSF;
			break;
		}
	}
	sc->cl_reg->cl_reoir = reoir;
	return (1);
}

void
cl_overflow (sc, channel, ptime, msg)
struct wlsoftc *sc;
int channel;
time_t *ptime;
u_char *msg;
{
/*
	if (*ptime != time_second) {
*/
	{
/*
		*ptime = time_second;
*/
		log(LOG_WARNING, "%s%d[%d]: %s overrun\n", wl_cd.cd_name,
			0 /* fix */, channel, msg);
	}
}

void
cl_parity (sc, channel)
	struct wlsoftc *sc;
	int channel;
{
	log(LOG_WARNING, "%s%d[%d]: parity error\n", wl_cd.cd_name, 0, channel);
}

void
cl_frame (sc, channel)
	struct wlsoftc *sc;
	int channel;
{
	log(LOG_WARNING, "%s%d[%d]: frame error\n", wl_cd.cd_name, 0, channel);
}

void
cl_break (sc, channel)
	struct wlsoftc *sc;
	int channel;
{
	log(LOG_WARNING, "%s%d[%d]: break detected\n", wl_cd.cd_name, 0, channel);
}

void
cl_dumpport0()
{
	cl_dumpport(0);
}

void
cl_dumpport1()
{
	cl_dumpport(1);
}

void
cl_dumpport2()
{
	cl_dumpport(2);
}

void
cl_dumpport3()
{
	cl_dumpport(3);
}

void
cl_dumpport(channel)
	int channel;
{
	u_char	livr, cmr, cor1, cor2, cor3, cor4, cor5, cor6, cor7,
		schr1, schr2, schr3, schr4, scrl, scrh, lnxt,
		rbpr, rcor, tbpr, tcor, rpilr, rir, tpr, ier, ccr,
		dmabsts, arbsts, brbsts, atbsts, btbsts,
		csr, rts, dtr, rtprl, rtprh;
	volatile void * parbadru, *parbadrl,  *parbsts, *parbcnt;
	u_short rcbadru, rcbadrl, arbadru, arbadrl, arbcnt,
		brbadru, brbadrl, brbcnt;
	u_short tcbadru, tcbadrl, atbadru, atbadrl, atbcnt,
		btbadru, btbadrl, btbcnt;
	struct wlsoftc *sc;

	struct clreg *cl_reg;
	int s;

	sc = (struct wlsoftc *) wl_cd.cd_devs[0];
	cl_reg = sc->cl_reg;

	s = splcl();
	cl_reg->cl_car	= (u_char) channel;
	livr = cl_reg->cl_livr;
	cmr = cl_reg->cl_cmr;
	cor1 = cl_reg->cl_cor1;
	cor2 = cl_reg->cl_cor2;
	cor3 = cl_reg->cl_cor3;
	cor4 = cl_reg->cl_cor4;
	cor5 = cl_reg->cl_cor5;
	cor6 = cl_reg->cl_cor6;
	cor7 = cl_reg->cl_cor7;
	schr1 = cl_reg->cl_schr1;
	schr2 = cl_reg->cl_schr2;
	schr3 = cl_reg->cl_schr3;
	schr4 = cl_reg->cl_schr4;
	scrl = cl_reg->cl_scrl;
	scrh = cl_reg->cl_scrh;
	lnxt = cl_reg->cl_lnxt;
	rbpr = cl_reg->cl_rbpr;
	rcor = cl_reg->cl_rcor;
	tbpr = cl_reg->cl_tbpr;
	rpilr = cl_reg->cl_rpilr;
	ier = cl_reg->cl_ier;
	ccr = cl_reg->cl_ccr;
	tcor = cl_reg->cl_tcor;
	csr = cl_reg->cl_csr;
	tpr = cl_reg->cl_tpr;
	rts = cl_reg->cl_msvr_rts;
	dtr = cl_reg->cl_msvr_dtr;
	rtprl = cl_reg->cl_rtprl;
	rtprh = cl_reg->cl_rtprh;
	dmabsts = cl_reg->cl_dmabsts;
	tcbadru = cl_reg->cl_tcbadru;
	tcbadrl = cl_reg->cl_tcbadrl;
	rcbadru = cl_reg->cl_rcbadru;
	rcbadrl = cl_reg->cl_rcbadrl;

	parbadru = &(cl_reg->cl_arbadru);
	parbadrl = &(cl_reg->cl_arbadrl);
	parbcnt  = &(cl_reg->cl_arbcnt);
	parbsts  = &(cl_reg->cl_arbsts);

	arbadru = cl_reg->cl_arbadru;
	arbadrl = cl_reg->cl_arbadrl;
	arbcnt  = cl_reg->cl_arbcnt;
	arbsts  = cl_reg->cl_arbsts;

	brbadru = cl_reg->cl_brbadru;
	brbadrl = cl_reg->cl_brbadrl;
	brbcnt  = cl_reg->cl_brbcnt;
	brbsts  = cl_reg->cl_brbsts;

	atbadru = cl_reg->cl_atbadru;
	atbadrl = cl_reg->cl_atbadrl;
	atbcnt  = cl_reg->cl_atbcnt;
	atbsts  = cl_reg->cl_atbsts;

	btbadru = cl_reg->cl_btbadru;
	btbadrl = cl_reg->cl_btbadrl;
	btbcnt  = cl_reg->cl_btbcnt;
	btbsts  = cl_reg->cl_btbsts;

	splx(s);

	printf("{ port %x livr %x cmr %x\n",
		  channel,livr,   cmr);
	printf("cor1 %x cor2 %x cor3 %x cor4 %x cor5 %x cor6 %x cor7 %x\n",
		cor1,   cor2,   cor3,   cor4,   cor5,   cor6,   cor7);
	printf("schr1 %x schr2 %x schr3 %x schr4 %x\n",
		schr1,   schr2,   schr3,   schr4);
	printf("scrl %x scrh %x lnxt %x\n",
		scrl,   scrh,   lnxt);
	printf("rbpr %x rcor %x tbpr %x tcor %x\n",
		rbpr,   rcor,   tbpr,   tcor);
	printf("rpilr %x rir %x ier %x ccr %x\n",
		rpilr,   rir,   ier,   ccr);
	printf("tpr %x csr %x rts %x dtr %x\n",
		tpr,   csr,   rts,   dtr);
	printf("rtprl %x rtprh %x\n",
		rtprl,   rtprh);
	printf("rxcnt %x txcnt %x\n",
		sc->sc_cl[channel].rxcnt, sc->sc_cl[channel].txcnt);
	printf("dmabsts %x, tcbadru %x, tcbadrl %x, rcbadru %x, rcbadrl %x,\n",
		dmabsts,    tcbadru,    tcbadrl,    rcbadru,    rcbadrl );
	printf("parbadru %x, parbadrl %x, parbcnt %x, parbsts %x\n",
		parbadru,    parbadrl,    parbcnt,    parbsts);
	printf("arbadru %x, arbadrl %x, arbcnt %x, arbsts %x\n",
		arbadru,    arbadrl,    arbcnt,    arbsts);
	printf("brbadru %x, brbadrl %x, brbcnt %x, brbsts %x\n",
		brbadru,    brbadrl,    brbcnt,    brbsts);
	printf("atbadru %x, atbadrl %x, atbcnt %x, atbsts %x\n",
		atbadru,    atbadrl,    atbcnt,    atbsts);
	printf("btbadru %x, btbadrl %x, btbcnt %x, btbsts %x\n",
		btbadru,    btbadrl,    btbcnt,    btbsts);
	printf("}\n");
}

static void
clputc(sc, unit, c)
	struct wlsoftc *sc;
	int unit;
	u_char c;
{
	int s;
	u_char schar;
	u_char oldchannel;
	struct clreg *cl_reg;
	cl_reg = sc->cl_reg;

	s = splhigh();
	oldchannel = cl_reg->cl_car;
	cl_reg->cl_car = unit;
	if (cl_reg->cl_tftc > 0) {
		cl_reg->cl_tdr = c;
	}
	cl_reg->cl_car = oldchannel;
	splx(s);
}
@


1.26
log
@Do not invoke ttymodem() directly, but l_modem from the current linedisc.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.25 2013/07/04 00:25:37 guenther Exp $ */
@


1.25
log
@Merge rev 1.16 of cl.c: time_t is not long
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.24 2012/11/04 13:33:32 miod Exp $ */
d1145 1
a1145 1
		ttymodem(tp, ((msvr & 0x40) != 0x0) );
@


1.24
log
@Switch mvme68k to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.23 2010/06/28 14:13:29 deraadt Exp $ */
d176 1
a176 1
void cl_overflow(struct wlsoftc *sc, int channel, long *ptime, u_char *msg);
d1316 1
a1316 1
long *ptime;
@


1.23
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.22 2010/04/12 12:57:52 tedu Exp $ */
d1320 1
a1320 1
	if (*ptime != time.tv_sec) {
d1324 1
a1324 1
		*ptime = time.tv_sec;
@


1.22
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.21 2009/11/09 17:53:39 nicm Exp $ */
d521 1
a521 1
		tp = cl->tty = ttymalloc();
@


1.21
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.20 2009/10/31 12:00:07 fgsch Exp $ */
d572 1
a572 1
	return((*linesw[tp->t_line].l_open)(dev, tp));
d659 1
a659 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.20
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.19 2009/10/31 06:40:16 deraadt Exp $ */
a1220 1
				KNOTE(&tp->t_wsel.si_note, 0);
@


1.19
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.18 2005/11/24 22:43:16 miod Exp $ */
d561 1
a561 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
@


1.18
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.17 2004/07/30 22:29:45 miod Exp $ */
d1221 1
@


1.17
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.16 2004/07/30 09:50:15 miod Exp $ */
d124 1
a124 1
	void		*sc_memvme;
d126 1
a126 1
	void		*sc_memkv;
d255 1
a255 1
	sc->sc_memvme = (void *)((0xff00 + sc->sc_memv) << 16);
d259 1
a259 1
	clb->sram.base = ((u_int)sc->sc_memvme >> 16) & 0xff;
d288 1
a288 1
	if (sc->sc_memkv == NULL)
d293 1
a293 1
		u_char *x = sc->sc_memkv;
d341 1
a341 1
	p = sc->sc_memkv;
d346 1
a346 1
			sc->sc_cl[i].rxp[j] = (void *)(p - sc->sc_memkv);
d353 1
a353 1
			sc->sc_cl[i].txp[j] = (void *)(p - sc->sc_memkv);
@


1.16
log
@Switch mvme68k to evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.15 2004/07/02 17:57:29 miod Exp $ */
a35 1
#include <sys/evcount.h>
a115 1
	struct evcount	sc_txintrcnt;
a116 1
	struct evcount	sc_rxintrcnt;
a117 1
	struct evcount	sc_mxintrcnt;
a328 5
	vmeintr_establish(ca->ca_vec + 0, &sc->sc_ih_e);
	vmeintr_establish(ca->ca_vec + 1, &sc->sc_ih_m);
	vmeintr_establish(ca->ca_vec + 2, &sc->sc_ih_t);
	vmeintr_establish(ca->ca_vec + 3, &sc->sc_ih_r);

a330 2
	evcount_attach(&sc->sc_txintrcnt, sc->sc_txintrname,
	    (void *)&sc->sc_ih_t.ih_ipl, &evcount_intr);
a332 2
	evcount_attach(&sc->sc_rxintrcnt, sc->sc_rxintrname,
	    (void *)&sc->sc_ih_r.ih_ipl, &evcount_intr);
d335 5
a339 2
	evcount_attach(&sc->sc_mxintrcnt, sc->sc_mxintrname,
	    (void *)&sc->sc_ih_m.ih_ipl, &evcount_intr);
a1128 2
	sc->sc_mxintrcnt.ec_count++;

a1184 1
	sc->sc_txintrcnt.ec_count++;
a1258 1
	sc->sc_rxintrcnt.ec_count++;
@


1.15
log
@Kill ca_master in autoconf structures. Drivers either only attach to one
specific bus (mc/pcc/pcctwo), or they know it from the ca_bustype value,
and can use the globals sys_busname variables.

This also allows for some code simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.14 2004/01/14 20:50:48 miod Exp $ */
d36 1
d117 6
a122 3
	struct evcnt	sc_txintrcnt;
	struct evcnt	sc_rxintrcnt;
	struct evcnt	sc_mxintrcnt;
d338 12
a349 3
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_txintrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_rxintrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_mxintrcnt);
d1139 1
a1139 1
	sc->sc_mxintrcnt.ev_count++;
d1197 1
a1197 1
	sc->sc_txintrcnt.ev_count++;
d1272 1
a1272 1
	sc->sc_rxintrcnt.ev_count++;
@


1.14
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.13 2003/10/03 16:44:50 miod Exp $ */
a133 1
	struct vme2reg	*sc_vme2;
a251 1
	sc->sc_vme2 = ca->ca_master;
@


1.13
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.12 2003/08/15 20:32:14 tedu Exp $ */
d197 1
a197 1
	NULL, "wl", DV_TTY, 0
@


1.12
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.11 2003/06/03 21:09:01 deraadt Exp $ */
a520 1
		tty_attach(tp);
@


1.11
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.10 2003/06/02 05:09:14 deraadt Exp $ */
d792 1
a792 1
		error = suser(p->p_ucred, &p->p_acflag); 
@


1.10
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.9 2002/04/27 23:21:05 miod Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.8 2002/03/14 03:15:56 millert Exp $ */
a5 1
 *   
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.7 2002/03/14 01:26:37 millert Exp $ */
a33 1
#include <sys/conf.h>
d41 4
d46 1
a46 1
#include <machine/autoconf.h>
d49 1
a49 1
#include <sys/syslog.h>
d54 1
a54 1
#define splcl() spl3()
a192 7
int wlopen(dev_t dev, int flag, int mode, struct proc *p);
int wlclose(dev_t dev, int flag, int mode, struct proc *p);
int wlread(dev_t dev, struct uio *uio, int flag);
int wlwrite(dev_t dev, struct uio *uio, int flag);
int wlioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int wlstop(struct tty *tp, int flag);

d503 2
a504 1
int wlopen (dev, flag, mode, p)
d645 2
a646 1
int wlclose (dev, flag, mode, p)
d686 2
a687 1
int wlread (dev, uio, flag)
d708 2
a709 1
int wlwrite (dev, uio, flag)
d730 2
a731 1
int wlioctl (dev, cmd, data, flag, p)
d733 1
a733 1
	int cmd;
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.6 2002/02/15 20:45:30 nordin Exp $ */
d200 1
a200 1
static void cloutput __P( (struct tty *tp));
@


1.6
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.5 2001/06/27 05:44:48 nate Exp $ */
d168 32
a199 32
u_char cl_clkdiv __P((int speed));
u_char cl_clknum __P((int speed));
u_char cl_clkrxtimeout __P((int speed));
void clstart __P((struct tty *tp));
void cl_unblock __P((struct tty *tp));
int clccparam __P((struct wlsoftc *sc, struct termios *par, int channel));

int clparam __P((struct tty *tp, struct termios *t));
int cl_intr __P((struct wlsoftc *sc, int));
int cl_mintr __P((struct wlsoftc *sc));
int cl_txintr __P((struct wlsoftc *sc));
int cl_rxintr __P((struct wlsoftc *sc));
void cl_overflow __P((struct wlsoftc *sc, int channel, long *ptime, u_char *msg));
void cl_parity __P((struct wlsoftc *sc, int channel));
void cl_frame __P((struct wlsoftc *sc, int channel));
void cl_break __P(( struct wlsoftc *sc, int channel));
int clmctl __P((dev_t dev, int bits, int how));
void cl_dumpport __P((int channel));

int	wlprobe __P((struct device *parent, void *self, void *aux));
void	wlattach __P((struct device *parent, struct device *self, void *aux));

int wlopen  __P((dev_t dev, int flag, int mode, struct proc *p));
int wlclose __P((dev_t dev, int flag, int mode, struct proc *p));
int wlread  __P((dev_t dev, struct uio *uio, int flag));
int wlwrite __P((dev_t dev, struct uio *uio, int flag));
int wlioctl __P((dev_t dev, int cmd, caddr_t data, int flag, struct proc *p));
int wlstop  __P((struct tty *tp, int flag));

static void cl_initchannel __P((struct wlsoftc *sc, int channel));
static void clputc __P((struct wlsoftc *sc, int unit, u_char c));
static u_char clgetc __P((struct wlsoftc *sc, int *channel));
@


1.5
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.4 2000/03/26 23:31:59 deraadt Exp $ */
d489 1
a489 1
	(void)splx(s);
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.5 2001/06/27 05:44:48 nate Exp $ */
d34 1
d42 1
a42 2
#include <sys/syslog.h>

a43 3
#include <machine/conf.h>
#include <machine/cpu.h>

d46 1
a46 1

d51 1
a51 1
#define splcl() spltty()
d168 33
a200 26
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct wlsoftc *sc, struct termios *par, int channel);

int clparam(struct tty *tp, struct termios *t);
int cl_intr(struct wlsoftc *sc, int);
int cl_mintr(struct wlsoftc *sc);
int cl_txintr(struct wlsoftc *sc);
int cl_rxintr(struct wlsoftc *sc);
void cl_overflow(struct wlsoftc *sc, int channel, long *ptime, u_char *msg);
void cl_parity(struct wlsoftc *sc, int channel);
void cl_frame(struct wlsoftc *sc, int channel);
void cl_break( struct wlsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
void cl_dumpport(int channel);

int	wlprobe(struct device *parent, void *self, void *aux);
void	wlattach(struct device *parent, struct device *self, void *aux);

static void cl_initchannel(struct wlsoftc *sc, int channel);
static void clputc(struct wlsoftc *sc, int unit, u_char c);
static u_char clgetc(struct wlsoftc *sc, int *channel);
static void cloutput(struct tty *tp);
d489 1
a489 1
	splx(s);
d507 1
a507 2
int
wlopen(dev, flag, mode, p)
d648 1
a648 2
int
wlclose(dev, flag, mode, p)
d688 1
a688 2
int
wlread(dev, uio, flag)
d709 1
a709 2
int
wlwrite(dev, uio, flag)
d730 1
a730 2
int
wlioctl(dev, cmd, data, flag, p)
d732 1
a732 1
	u_long cmd;
@


1.4
log
@callout.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.3 1997/02/22 12:09:45 deraadt Exp $ */
d884 1
a884 1
		/* disconnect, drop RTS DTR stop reciever */
@


1.3
log
@sends and receives and illustrates that the vme board has interrupt vector bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.2 1997/02/11 02:55:44 deraadt Exp $ */
a33 1
#include <sys/callout.h>
@


1.3.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.4 2000/03/26 23:31:59 deraadt Exp $ */
d34 1
@


1.3.14.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.3.14.1 2001/04/18 16:10:32 niklas Exp $ */
d884 1
a884 1
		/* disconnect, drop RTS DTR stop receiver */
@


1.3.14.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d489 1
a489 1
	splx(s);
@


1.3.14.4
log
@Merge in -current from about a week ago
@
text
@d168 6
a173 6
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct wlsoftc *sc, struct termios *par, int channel);
d175 11
a185 11
int clparam(struct tty *tp, struct termios *t);
int cl_intr(struct wlsoftc *sc, int);
int cl_mintr(struct wlsoftc *sc);
int cl_txintr(struct wlsoftc *sc);
int cl_rxintr(struct wlsoftc *sc);
void cl_overflow(struct wlsoftc *sc, int channel, long *ptime, u_char *msg);
void cl_parity(struct wlsoftc *sc, int channel);
void cl_frame(struct wlsoftc *sc, int channel);
void cl_break( struct wlsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
void cl_dumpport(int channel);
d187 2
a188 2
int	wlprobe(struct device *parent, void *self, void *aux);
void	wlattach(struct device *parent, struct device *self, void *aux);
d190 6
a195 6
int wlopen(dev_t dev, int flag, int mode, struct proc *p);
int wlclose(dev_t dev, int flag, int mode, struct proc *p);
int wlread(dev_t dev, struct uio *uio, int flag);
int wlwrite(dev_t dev, struct uio *uio, int flag);
int wlioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int wlstop(struct tty *tp, int flag);
d197 4
a200 4
static void cl_initchannel(struct wlsoftc *sc, int channel);
static void clputc(struct wlsoftc *sc, int unit, u_char c);
static u_char clgetc(struct wlsoftc *sc, int *channel);
static void cloutput(struct tty *tp);
@


1.3.14.5
log
@Sync the SMP branch with 3.3
@
text
@d34 1
d42 1
a42 2
#include <sys/syslog.h>

a43 3
#include <machine/conf.h>
#include <machine/cpu.h>

d46 1
a46 1

d51 1
a51 1
#define splcl() spltty()
d190 7
d507 1
a507 2
int
wlopen(dev, flag, mode, p)
d648 1
a648 2
int
wlclose(dev, flag, mode, p)
d688 1
a688 2
int
wlread(dev, uio, flag)
d709 1
a709 2
int
wlwrite(dev, uio, flag)
d730 1
a730 2
int
wlioctl(dev, cmd, data, flag, p)
d732 1
a732 1
	u_long cmd;
@


1.3.14.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.3.14.5 2003/03/27 23:32:16 niklas Exp $ */
d6 1
d15 5
@


1.3.14.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d197 1
a197 1
	NULL, "wl", DV_TTY
d521 1
d792 1
a792 1
		error = suser(p, 0); 
@


1.2
log
@ok, transmit on port 0 works...
@
text
@d1 1
a1 1
/*	$OpenBSD: wl.c,v 1.1 1996/12/24 20:31:23 deraadt Exp $ */
d71 1
a71 1
		char		xx[256];
d74 2
a75 2
		u_char		base;
		char		xx[256];
d78 2
a79 2
		u_char		val;
		char		xx[256];
d82 2
a83 2
		u_char		val;
		char		xx[256];
d86 2
a87 2
		u_char		val;
		char		xx[256];
d90 2
a91 2
		u_char		val;
		char		xx[256];
d110 4
a113 4
	void	*rx[2];
	void	*rxp[2];
	void	*tx[2];
	void	*txp[2];
d116 1
a116 1
#define CL_BUFSIZE 256
d150 13
a162 13
	{   64000, 0x3a, 0, 0xff },
	{   56000, 0x42, 0, 0xff },
	{   38400, 0x61, 0, 0xff },
	{   19200, 0xc2, 0, 0xff },
	{    9600, 0x61, 1, 0xff },
	{    7200, 0x81, 1, 0xff },
	{    4800, 0xc2, 1, 0xff },
	{    3600, 0x40, 2, 0xff },
	{    2400, 0x61, 2, 0xff },
	{    1200, 0xc2, 2, 0xff },
	{     600, 0x61, 3, 0xff },
	{     300, 0xc2, 3, 0xff },
	{     150, 0x61, 4, 0xff },
d177 1
d322 1
a322 1
	sc->sc_ih_e.ih_fn = cl_rxintr;
d327 1
a327 1
	sc->sc_ih_m.ih_fn = cl_mintr;
d332 1
a332 1
	sc->sc_ih_t.ih_fn = cl_txintr;
d337 1
a337 1
	sc->sc_ih_r.ih_fn = cl_rxintr;
a379 2
	printf("init %d\n", channel);

d568 1
a568 1
			sc->cl_reg->cl_ier	= 0x88;
d636 1
a636 1
		cnt = min (CLCDBUF,cc);
d677 1
d834 2
a835 1
	u_char val, reoir, licr, isrl, fifo_cnt, data;
a836 2

	val = cl_reg->cl_rir;
d838 1
a838 1
	if (!(val & 0x80)) {
d1055 1
a1055 1
		(sc = (struct wlsoftc *) wl_cd.cd_devs[unit]) == NULL) {
a1062 1
	/*cl_dumpport(0);*/
d1066 2
a1067 1
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier | 0x3;
d1069 1
d1075 41
d1123 2
a1124 5
zscnputc(0, 'M');

	if(((mir = sc->cl_reg->cl_mir) & 0x40) == 0x0) {
		/* only if intr is not shared? */
		log(LOG_WARNING, "cl_mintr extra intr\n");
d1126 1
a1126 2
	}
	sc->sc_mxintrcnt.ev_count++;
a1127 1
	channel = mir & 0x03;
d1130 8
a1137 1
	if (misr & 0x01) {
d1141 1
a1141 1
	if (misr & 0x02) {
d1145 1
a1145 1
	if (misr & 0x20) {
d1147 1
a1147 2
		((msvr & 0x20) != 0x0)
		);
d1149 1
a1149 1
	if (misr & 0x40) {
d1152 1
a1152 2
		((msvr & 0x40) != 0x0)
		);
d1155 1
a1155 1
	if (misr & 0x80) {
d1157 1
a1157 2
		((msvr & 0x80) != 0x0)
		);
d1167 3
a1169 4
	static empty = 0;
	u_char tir, cmr, teoir;
	u_char max;
	int channel;
d1178 3
a1180 2
zscnputc(0, 'T');

d1182 1
a1182 5
	if(((tir = sc->cl_reg->cl_tir) & 0x40) == 0x0) {
		/* only if intr is not shared ??? */
		log(LOG_WARNING, "cl_txintr extra intr\n");
		return 0;
	}
a1183 1
	sc->sc_txintrcnt.ev_count++;
d1185 4
a1188 2
	channel	= tir & 0x03;
	cmr	= sc->cl_reg->cl_cmr;
d1190 2
a1191 2
	printf("tir 0x%x chan 0x%x cmr 0x%x\n",
	    tir, channel, cmr);
d1193 3
a1195 1
	sc->sc_cl[channel].txcnt ++;
a1196 1
	tp = sc->sc_cl[channel].tty;
d1198 2
a1199 2
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
		sc->cl_reg->cl_teoir = 0x08;
d1202 1
a1203 54
#if 0
	case CL_TXDMAINT:
		dmabsts = sc->cl_reg->cl_dmabsts;
		log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x\n",
			channel, dmabsts);
		nbuf = ((dmabsts & 0x8) >> 3) & 0x1;
		busy = ((dmabsts & 0x4) >> 2) & 0x1;
		do {
			pbuffer = sc->sc_cl[channel].tx[nbuf];
			resid = tp->t_outq.c_cc;
			cnt = min (CL_BUFSIZE,resid);
			log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %x\n",
				resid, cnt, pbuffer);
			if (cnt != 0) {
				cnt = q_to_b(&tp->t_outq, pbuffer, cnt);
				resid -= cnt;
				if (nbuf == 0) {
					sc->cl_reg->cl_atbadru =
					    ((u_long) sc->sc_cl[channel].txp[nbuf])
					    >> 16;
					sc->cl_reg->cl_atbadrl =
					    ((u_long) sc->sc_cl[channel].txp[nbuf]) &
					    0xffff;
					sc->cl_reg->cl_atbcnt = cnt;
					sc->cl_reg->cl_atbsts = 0x43;
				} else {
					sc->cl_reg->cl_btbadru =
					    ((u_long) sc->sc_cl[channel].txp[nbuf])
					    >> 16;
					sc->cl_reg->cl_btbadrl =
					    ((u_long) sc->sc_cl[channel].txp[nbuf]) &
					    0xffff;
					sc->cl_reg->cl_btbcnt = cnt;
					sc->cl_reg->cl_btbsts = 0x43;
				}
				teoir = 0x08;
			} else {
				teoir = 0x08;
				if (tp->t_state & TS_BUSY) {
					tp->t_state &= ~(TS_BUSY | TS_FLUSH);
					if (tp->t_state & TS_ASLEEP) {
							tp->t_state &= ~TS_ASLEEP;
							wakeup((caddr_t) &tp->t_outq);
					}
					selwakeup(&tp->t_wsel);
				}
				sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
			}
			nbuf = ~nbuf & 0x1;
			busy--;
		} while (resid != 0 && busy != -1);
		log(LOG_WARNING, "cl_txintr: done\n");
		break;
#endif
d1205 1
a1205 2
		max = sc->cl_reg->cl_tftc;
		cnt = min ((int)max,tp->t_outq.c_cc);
d1207 1
d1209 1
d1211 2
a1212 1
			for (tptr = buffer; tptr < &buffer[cnt]; tptr++)
d1214 3
a1216 1
			teoir = 0x00;
d1219 2
a1220 2
				log(LOG_WARNING, "cl_txintr empty intr %d channel %d\n",
				    empty, channel);
d1222 1
a1222 1
			teoir = 0x08;
d1231 1
a1231 1
			sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
d1237 2
a1238 1
		teoir = 0x08;
d1248 1
a1248 1
	u_char rir, channel, cmr, risrl;
d1250 1
a1250 1
	u_char reoir, fifocnt, c;
d1255 6
a1260 2
	sc->sc_rxintrcnt.ev_count++;
	channel = rir & 0x3;
d1262 2
a1263 1
	reoir = 0x08;
d1265 2
a1266 21
	sc->sc_cl[channel].rxcnt ++;
	risrl = sc->cl_reg->cl_risrl;
zscnputc(0, 'R');
	printf("rir 0x%x chan 0x%x cmr 0x%x risrl 0x%x\n",
	    rir, channel, cmr, risrl);
	if (risrl & 0x80) {
		/* timeout, no characters */
		reoir = 0x08;
	} else if (risrl & 0x08) {
		cl_overflow (sc, channel, &sc->sc_fotime, "fifo");
		reoir = 0x08;
	} else if (risrl & 0x04) {
		cl_parity(sc, channel);
		reoir = 0x08;
	} else if (risrl & 0x02) {
		cl_frame(sc, channel);
		reoir = 0x08;
	} else if (risrl & 0x01) {
		cl_break(sc, channel);
		reoir = 0x08;
	}
d1268 2
a1269 24
	switch (cmr & CL_RXMASK) {
#if 0
	case CL_RXDMAINT:
		{
			int nbuf;
			u_short cnt;
			int bufcomplete;
			u_char status, dmabsts;
			u_char risrh = sc->cl_reg->cl_risrh;
			int i;
			u_char *pbuf;

			dmabsts = sc->cl_reg->cl_dmabsts;
			nbuf = (risrh & 0x08) ? 1 : 0;
			bufcomplete = (risrh & 0x20) ? 1 : 0;
			if (nbuf == 0) {
				cnt  = sc->cl_reg->cl_arbcnt;
				status =  sc->cl_reg->cl_arbsts;
			} else {
				cnt  = sc->cl_reg->cl_brbcnt;
				status =  sc->cl_reg->cl_brbsts;
			}
			tp = sc->sc_cl[channel].tty;
			pbuf = sc->sc_cl[channel].rx[nbuf];
d1271 29
a1299 13
			/* this should be done at off level */
			{
				u_short rcbadru, rcbadrl;
				u_char arbsts, brbsts;
				u_char *pbufs, *pbufe;
				rcbadru = sc->cl_reg->cl_rcbadru;
				rcbadrl = sc->cl_reg->cl_rcbadrl;
				arbsts =  sc->cl_reg->cl_arbsts;
				brbsts =  sc->cl_reg->cl_brbsts;
				pbufs = sc->sc_cl[channel].rxp[nbuf];
				pbufe = (u_char *)(((u_long)rcbadru << 16) |
				    (u_long)rcbadrl);
				cnt = pbufe - pbufs;
d1301 1
a1301 1
			reoir = 0x0 | (bufcomplete) ? 0 : 0xd0;
d1303 6
a1308 5
			delay(10); /* give the chip a moment */
			for (i = 0; i < cnt; i++) {
				u_char c;
				c = pbuf[i];
				(*linesw[tp->t_line].l_rint)(c,tp);
d1310 5
a1314 24
			/* this should be done at off level */
			if (nbuf == 0) {
				sc->cl_reg->cl_arbcnt = CL_BUFSIZE;
				sc->cl_reg->cl_arbsts = 0x01;
			} else {
				sc->cl_reg->cl_brbcnt = CL_BUFSIZE;
				sc->cl_reg->cl_brbsts = 0x01;
			}
		}
		sc->cl_reg->cl_reoir = reoir;
		break;
#endif
	case CL_RXINTR:
		fifocnt = sc->cl_reg->cl_rfoc;
		tp = sc->sc_cl[channel].tty;
		for (i = 0; i < fifocnt; i++) {
			buffer[i] = sc->cl_reg->cl_rdr;
		}
		if (NULL == tp) {
			/* if the channel is not configured,
			 * dont send characters upstream.
			 * also fix problem with NULL dereference
			 */
			reoir = 0x00;
a1316 16

		sc->cl_reg->cl_reoir = reoir;
		for (i = 0; i < fifocnt; i++) {
			u_char c = buffer[i];
			/* does any restricitions exist on spl
			 * for this call
			 */
			(*linesw[tp->t_line].l_rint)(c,tp);
			reoir = 0x00;
		}
		break;
	default:
		log(LOG_WARNING, "cl_rxintr unknown mode %x\n", cmr);
		/* we probably will go to hell quickly now */
		reoir = 0x08;
		sc->cl_reg->cl_reoir = reoir;
d1318 1
d1520 5
a1524 29
#if 0
	if (unit == 0) {
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		schar = cl_reg->cl_schr3;
		cl_reg->cl_schr3 = c;
		cl_reg->cl_stcr = 0x08 | 0x03; /* send special char, char 3 */
		while (0 != cl_reg->cl_stcr) {
			/* wait until cl notices the command
			 * otherwise it may not notice the character
			 * if we send characters too fast.
			 */
		}
		DELAY(5);
		cl_reg->cl_schr3 = schar;
		cl_reg->cl_car = oldchannel;
		splx(s);
	} else {
#endif
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		if (cl_reg->cl_tftc > 0) {
			cl_reg->cl_tdr = c;
		}
		cl_reg->cl_car = oldchannel;
		splx(s);
#if 0
d1526 2
a1527 1
#endif
@


1.1
log
@nearly working driver for wglen serial card
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.14 1996/06/11 10:17:34 deraadt Exp $ */
a32 2
/* DMA mode still does not work!!! */

a42 1
/* #include <sys/queue.h> */
d52 1
a52 1
#define splcl() spl4()
a117 5
#ifndef DO_MALLOC
/* four (4) buffers per port */
char cl_dmabuf [2 * CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
#endif

d142 1
d149 17
a165 16
	{ 64000, 0x26, 0, 0x01},
	{ 56000, 0x2c, 0, 0x01},
	{ 38400, 0x40, 0, 0x01},
	{ 19200, 0x81, 0, 0x02},
	{  9600, 0x40, 1, 0x04},
	{  7200, 0x56, 1, 0x04},
	{  4800, 0x81, 1, 0x08},
	{  3600, 0xad, 1, 0x08},
	{  2400, 0x40, 2, 0x10},
	{  1200, 0x81, 2, 0x20},
	{   600, 0x40, 3, 0x40},
	{   300, 0x81, 3, 0x80},
	{   150, 0x40, 3, 0x80},
	{   110, 0x58, 4, 0xff},
	{    50, 0xC2, 4, 0xff},
	{     0, 0x00, 0, 0},
d260 1
a260 1
	int i, j;
d276 3
a278 2
	printf(": va=%x sc=%x slot 0x%02x vmes 0x%08x ", sc->cl_reg, sc,
	    sc->sc_memv, sc->sc_memvme);
d285 5
a289 1
	printf("rev %02x\n", sc->cl_reg->cl_gfrcr);
d307 2
a308 3
		printf("%s: pa 0x%08x va 0x%08x", sc->sc_dev.dv_xname,
		    sc->sc_memp, sc->sc_memkv);
		printf(" tap");
d311 2
a312 1
		printf(" 0x%02x 0x%02x", x[0], x[1]);
d315 2
a316 3
		printf(" 0x%02x 0x%02x", x[0], x[1]);
		printf(" neato");

a317 1
		printf(" zero\n");
a349 1
#if 1
d351 1
d356 2
a357 2
			printf("%d:%d rx v %x p %x\n",
			    i, j, sc->sc_cl[i].rx[j], sc->sc_cl[i].rxp[j]);
d363 2
a364 2
			printf("%d:%d tx v %x p %x\n",
			    i, j, sc->sc_cl[i].tx[j], sc->sc_cl[i].txp[j]);
d369 1
a369 35
#else
	sc->sc_cl[0].rx[0] = sc->sc_memkv;
	sc->sc_cl[0].rx[1] = (void *)(((int)sc->sc_cl[0].rx[0]) + CL_BUFSIZE);
	sc->sc_cl[1].rx[0] = (void *)(((int)sc->sc_cl[0].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[1].rx[1] = (void *)(((int)sc->sc_cl[1].rx[0]) + CL_BUFSIZE);

	sc->sc_cl[2].rx[0] = (void *)(((int)sc->sc_cl[1].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[2].rx[1] = (void *)(((int)sc->sc_cl[2].rx[0]) + CL_BUFSIZE);
	sc->sc_cl[3].rx[0] = (void *)(((int)sc->sc_cl[2].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[3].rx[1] = (void *)(((int)sc->sc_cl[3].rx[0]) + CL_BUFSIZE);

	sc->sc_cl[0].tx[0] = (void *)(((int)sc->sc_cl[3].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[0].tx[1] = (void *)(((int)sc->sc_cl[0].tx[0]) + CL_BUFSIZE);
	sc->sc_cl[1].tx[0] = (void *)(((int)sc->sc_cl[0].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[1].tx[1] = (void *)(((int)sc->sc_cl[1].tx[0]) + CL_BUFSIZE);

	sc->sc_cl[2].tx[0] = (void *)(((int)sc->sc_cl[1].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[2].tx[1] = (void *)(((int)sc->sc_cl[2].tx[0]) + CL_BUFSIZE);
	sc->sc_cl[3].tx[0] = (void *)(((int)sc->sc_cl[2].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[3].tx[1] = (void *)(((int)sc->sc_cl[3].tx[0]) + CL_BUFSIZE);

	for (i = 0; i < CLCD_PORTS_PER_CHIP; i++) {
		for (j = 0; j < 2 ; j++) {
			sc->sc_cl[i].rxp[j] = (void *)(sc->sc_cl[i].rx[j] -
			    sc->sc_memkv);
			sc->sc_cl[i].txp[j] = (void *)(sc->sc_cl[i].tx[j] -
			    sc->sc_memkv);
			printf("cl[%d].rxbuf[%d] %x p %x\n",
			    i, j, sc->sc_cl[i].rx[j], sc->sc_cl[i].rxp[j]);
			printf("cl[%d].txbuf[%d] %x p %x\n",
			    i, j, sc->sc_cl[i].tx[j], sc->sc_cl[i].txp[j]);
		}
		cl_initchannel(sc, i);
	}
#endif
a376 1
	int s;
d379 2
d382 1
a382 3
	sc->sc_cl[channel].tty = NULL;
	s = splhigh();
	cl_reg->cl_car	= (u_char) channel;
d385 1
a385 1
	cl_reg->cl_cmr	= 0x02; 
a411 2

	splx(s);
a564 8
#ifdef XXX
		if ((cl->cl_swflags & TIOCFLAG_SOFTCAR) ||
			(clmctl(dev, 0, DMGET) & TIOCM_CD)) {
			tp->t_state |= TS_CARR_ON;
		} else {
			tp->t_state &= ~TS_CARR_ON;
		}
#endif
a569 43
#ifdef CL_DMA_WORKS
			{
			sc->cl_reg->cl_cmr	=
				/* CL_TXDMAINT | */ CL_RXDMAINT; 
			sc->cl_reg->cl_ier	= 0xa8;
			sc->cl_reg->cl_licr	= 0x00;
			}
			sc->cl_reg->cl_arbadrl	=
				((u_long)sc->sc_cl[channel].rxp[0]) & 0xffff;
			sc->cl_reg->cl_arbadru	=
				((u_long)sc->sc_cl[channel].rxp[0]) >> 16;
			sc->cl_reg->cl_brbadrl	=
				((u_long)sc->sc_cl[channel].rxp[1]) & 0xffff;
			sc->cl_reg->cl_brbadru	=
				((u_long)sc->sc_cl[channel].rxp[1]) >> 16;
			sc->cl_reg->cl_atbadrl	=
				((u_long)sc->sc_cl[channel].txp[0]) & 0xffff;
			sc->cl_reg->cl_atbadru	=
				((u_long)sc->sc_cl[channel].txp[0]) >> 16;
			sc->cl_reg->cl_btbadrl	=
				((u_long)sc->sc_cl[channel].txp[1]) & 0xffff;
			sc->cl_reg->cl_btbadru	=
				((u_long)sc->sc_cl[channel].txp[1]) >> 16;
			sc->cl_reg->cl_arbcnt	= CL_BUFSIZE;
			sc->cl_reg->cl_brbcnt	= CL_BUFSIZE;
			sc->cl_reg->cl_arbsts	= 0x01;
			sc->cl_reg->cl_brbsts	= 0x01;
if (channel == 2) { /* test one channel now */
			/* shift for tx DMA */
			/* no shift for rx DMA */
#if 0
			/* tx only */
			sc->cl_reg->cl_licr	= (CL_DMAMODE << 4);
			sc->cl_reg->cl_cmr	= 0x42; 
#endif
		/* rx only */
			sc->cl_reg->cl_licr	= 0x00;
			sc->cl_reg->cl_cmr	= 0x82; 
}
			sc->cl_reg->cl_ccr = 0x20;
			while (sc->cl_reg->cl_ccr != 0)
				;
#endif /* CL_DMA_WORKS */
a575 7
#ifdef XXX
	/*
	 * if NONBLOCK requested, ignore carrier
	 */
	if (flag & O_NONBLOCK)
	goto done;
#endif
a582 3
#ifdef DEBUG
	cl_dumpport(channel);
#endif
d585 1
d686 1
a686 5
#ifdef DEBUG
	cl_dumpport(channel);
#endif

	return 0;
d977 1
d979 1
d985 2
a986 1
	if (cl_clocks[clknum].speed == speed) {
d988 1
a988 1
	}
d995 1
d997 2
a998 1
	return cl_clocks[4].divisor;
a1059 3
	printf("WS");
	printf("channel %d unit %d\n", channel, unit);

d1064 2
a1065 18
	cl_dumpport(0);
#if 0
	if (sc->sc_cl[channel].transmitting == 1) {
		/* i'm busy, go away, I will get to it later. */
		splx(s);
		return;
	}
	cnt = q_to_b(&tp->t_outq, &cbuf, 1);
	if ( cnt != 0 ) {
		sc->sc_cl[channel].transmitting = 1;
		sc->cl_reg->cl_car = channel;
		sc->cl_reg->cl_tdr = cbuf;
	} else {
		sc->sc_cl[channel].transmitting = 0;
	}
#else
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0)
	{
a1067 1
		printf("ier %02x\n", sc->cl_reg->cl_ier);
d1069 1
a1069 1
		printf("whac");
a1070 1
#endif
a1071 3
	printf("ked\n");
	cl_dumpport(0);
	return;
d1073 1
a1081 1
zscnputc(0, 'W');
d1135 3
a1138 1
zscnputc(0, 'W');
d1141 1
d1147 1
d1153 3
d1165 1
d1167 1
a1167 5
		{
			u_char dmabsts;
			int nbuf, busy, resid;
			void *pbuffer;
			dmabsts = sc->cl_reg->cl_dmabsts;
d1170 32
a1201 27
			nbuf = ((dmabsts & 0x8) >> 3) & 0x1;
			busy = ((dmabsts & 0x4) >> 2) & 0x1;

			do {
				pbuffer = sc->sc_cl[channel].tx[nbuf];
				resid = tp->t_outq.c_cc;
				cnt = min (CL_BUFSIZE,resid);
		log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %x\n",
			resid, cnt, pbuffer);
				if (cnt != 0) {
					cnt = q_to_b(&tp->t_outq, pbuffer, cnt);
					resid -= cnt;
					if (nbuf == 0) {
						sc->cl_reg->cl_atbadru =
							((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
						sc->cl_reg->cl_atbadrl =
							((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
						sc->cl_reg->cl_atbcnt = cnt;
						sc->cl_reg->cl_atbsts = 0x43;
					} else {
						sc->cl_reg->cl_btbadru =
							((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
						sc->cl_reg->cl_btbadrl =
							((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
						sc->cl_reg->cl_btbcnt = cnt;
						sc->cl_reg->cl_btbsts = 0x43;
					}
d1203 3
a1205 5
				} else {
					teoir = 0x08;
					if (tp->t_state & TS_BUSY) {
						tp->t_state &= ~(TS_BUSY | TS_FLUSH);
						if (tp->t_state & TS_ASLEEP) {
a1207 2
						}
						selwakeup(&tp->t_wsel);
d1209 1
a1209 1
					sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
d1211 5
a1215 3
				nbuf = ~nbuf & 0x1;
				busy--;
			} while (resid != 0 && busy != -1);/* if not busy do other buffer */
a1216 1
		}
d1218 1
d1225 1
a1225 1
			for (tptr = buffer; tptr < &buffer[cnt]; tptr++) {
a1226 1
			}
d1229 3
a1231 4
			if (empty > 5 && ((empty % 20000 )== 0)) {
			log(LOG_WARNING, "cl_txintr to many empty intr %d channel %d\n",
				empty, channel);
			}
d1251 1
a1251 1
	return 1;
d1259 2
a1260 2
	u_char c;
	u_char fifocnt;
a1262 2
	u_char reoir;
	u_char buffer[CL_FIFO_MAX +1];
a1263 3
zscnputc(0, 'W');
zscnputc(0, 'R');

a1264 5
	if((rir & 0x40) == 0x0) {
		/* only if intr is not shared ??? */
		log(LOG_WARNING, "cl_rxintr extra intr\n");
		return 0;
	}
d1272 3
d1278 1
a1278 3
	} else
	/* We don't need no sinkin special characters */
	if (risrl & 0x08) {
d1281 1
a1281 2
	} else
	if (risrl & 0x04) {
d1284 1
a1284 2
	} else
	if (risrl & 0x02) {
d1287 1
a1287 2
	} else
	if (risrl & 0x01) {
d1293 1
d1301 3
a1304 4
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x risrl %x risrh %x\n",
	channel, dmabsts, risrl, risrh);
#endif
d1314 4
a1317 7
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_rxintr: 1channel %x buf %x cnt %x status %x\n",
channel, nbuf, cnt, status);
#endif
#if USE_BUFFER
			cl_appendbufn(sc, channel, sc->rx[nbuf], cnt);
#else 
d1319 20
a1338 4
				int i;
				u_char *pbuf;
				tp = sc->sc_cl[channel].tty;
				pbuf = sc->sc_cl[channel].rx[nbuf];
d1340 6
a1345 43
{
	u_short rcbadru, rcbadrl;
	u_char arbsts, brbsts;
	u_char *pbufs, *pbufe;
	rcbadru = sc->cl_reg->cl_rcbadru;
	rcbadrl = sc->cl_reg->cl_rcbadrl;
	arbsts =  sc->cl_reg->cl_arbsts;
	brbsts =  sc->cl_reg->cl_brbsts;
	pbufs = sc->sc_cl[channel].rxp[nbuf];
	pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
	cnt = pbufe - pbufs;
#ifdef DMA_DEBUG
	log(LOG_WARNING, "cl_rxintr: rcbadru %x rcbadrl %x arbsts %x brbsts %x cnt %x\n",
	rcbadru, rcbadrl, arbsts, brbsts, cnt);
#endif
#ifdef DMA_DEBUG1
	log(LOG_WARNING, "cl_rxintr: buf %x cnt %x\n",
	nbuf, cnt);
#endif
}
				reoir = 0x0 | (bufcomplete) ? 0 : 0xd0;
				sc->cl_reg->cl_reoir = reoir;
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_rxintr: reoir %x\n", reoir);
#endif
				delay(10); /* give the chip a moment */
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_rxintr: 2channel %x buf %x cnt %x status %x\n",
channel, nbuf, cnt, status);
#endif
				for (i = 0; i < cnt; i++) {
					u_char c;
					c = pbuf[i];
					(*linesw[tp->t_line].l_rint)(c,tp);
				}
			/* this should be done at off level */
				if (nbuf == 0) {
					sc->cl_reg->cl_arbcnt = CL_BUFSIZE;
					sc->cl_reg->cl_arbsts = 0x01;
				} else {
					sc->cl_reg->cl_brbcnt = CL_BUFSIZE;
					sc->cl_reg->cl_brbsts = 0x01;
				}
a1346 1
#endif
d1350 1
d1368 1
a1368 5
			u_char c;
			c = buffer[i];
#if USE_BUFFER
		cl_appendbuf(sc, channel, c);
#else
a1373 1
#endif
d1382 1
a1382 1
	return 1;
a1401 1
	return;
d1403 1
a1409 1
	return;
d1411 1
a1417 1
	return;
d1419 1
a1425 1
	return;
a1431 1
	return;
d1433 1
a1437 1
	return;
d1439 1
a1443 1
	return;
d1445 1
a1449 1
	return;
a1568 1
	return;
d1583 29
a1611 11
#ifdef NEW_CLCD_STRUCT
	/* should we disable, flush and all that goo? */
	cl->car = unit;
	schar = cl->schr3;
	cl->schr3 = c;
	cl->stcr = 0x08 | 0x03; /* send special char, char 3 */
	while (0 != cl->stcr) {
		/* wait until cl notices the command
		 * otherwise it may not notice the character
		 * if we send characters too fast.
		 */
a1612 29
	cl->schr3 = schar;
#else
if (unit == 0) {
	s = splhigh();
	oldchannel = cl_reg->cl_car;
	cl_reg->cl_car = unit;
	schar = cl_reg->cl_schr3;
	cl_reg->cl_schr3 = c;
	cl_reg->cl_stcr = 0x08 | 0x03; /* send special char, char 3 */
	while (0 != cl_reg->cl_stcr) {
		/* wait until cl notices the command
		 * otherwise it may not notice the character
		 * if we send characters too fast.
		 */
	}
	DELAY(5);
	cl_reg->cl_schr3 = schar;
	cl_reg->cl_car = oldchannel;
	splx(s);
} else {
	s = splhigh();
	oldchannel = cl_reg->cl_car;
	cl_reg->cl_car = unit;
	if (cl_reg->cl_tftc > 0) {
		cl_reg->cl_tdr = c;
	}
	cl_reg->cl_car = oldchannel;
	splx(s);
}
a1613 1
	return;
@
