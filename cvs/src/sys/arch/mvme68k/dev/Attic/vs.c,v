head	1.38;
access;
symbols
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.35.0.12
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.10
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.8
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.6
	OPENBSD_5_0:1.35.0.4
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2
	SMP_BASE:1.1;
locks; strict;
comment	@ * @;


1.38
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.37;

1.37
date	2014.01.21.23.47.41;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.18.04.11.07;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2010.12.23.20.25.15;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.17.22.28.41;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.25.17.52.02;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.30.18.08.03;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.22.15.18.23;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.19.18.42.12;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.06.02.18.38;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.02.18.53.56;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.03.18.09.37;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.30.22.29.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.30.09.50.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.20.16.43.51;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.09.05.34.00;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.20.16.48.23;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.14.02.00.41;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.03.06.54.25;	author david;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.14.07.20.25;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.00.30.38;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.06.26.21.35.38;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.25.00.43.13;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.16.12.49.47;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.10.19.53.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.25.04.18.17;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.04.18.16.10.31;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.04.10.19.28;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2004.06.05.23.10.53;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.05.19.21.45.31;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vs.c,v 1.37 2014/01/21 23:47:41 jsg Exp $ */

/*
 * Copyright (c) 2004, 2009, Miodrag Vallat.
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson of Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * MVME328S SCSI adaptor driver
 */

/* This card lives in D16 space */
#define	__BUS_SPACE_RESTRICT_D16__

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/buf.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <mvme68k/dev/vsreg.h>
#include <mvme68k/dev/vsvar.h>
#include <mvme68k/dev/vme.h>

int	vsmatch(struct device *, void *, void *);
void	vsattach(struct device *, struct device *, void *);
void	vs_minphys(struct buf *, struct scsi_link *);
void	vs_scsicmd(struct scsi_xfer *);

struct scsi_adapter vs_scsiswitch = {
	vs_scsicmd,
	vs_minphys,
	0,			/* no lun support */
	0,			/* no lun support */
};

struct cfattach vs_ca = {
	sizeof(struct vs_softc), vsmatch, vsattach,
};

struct cfdriver vs_cd = {
	NULL, "vs", DV_DULL,
};

int	do_vspoll(struct vs_softc *, struct scsi_xfer *, int);
void	thaw_queue(struct vs_softc *, int);
void	thaw_all_queues(struct vs_softc *);
int	vs_alloc_sg(struct vs_softc *);
int	vs_alloc_wq(struct vs_softc *);
void	vs_build_sg_list(struct vs_softc *, struct vs_cb *, bus_addr_t);
void	vs_chksense(struct vs_cb *, struct scsi_xfer *);
int	vs_eintr(void *);
int	vs_getcqe(struct vs_softc *, bus_addr_t *, bus_addr_t *);
int	vs_identify(struct vs_channel *, int);
int	vs_initialize(struct vs_softc *);
int	vs_intr(struct vs_softc *);
int	vs_load_command(struct vs_softc *, struct vs_cb *, bus_addr_t,
	    bus_addr_t, struct scsi_link *, int, struct scsi_generic *, int,
	    uint8_t *, int);
int	vs_nintr(void *);
void	vs_poll(struct vs_softc *, struct vs_cb *);
void	vs_print_addr(struct vs_softc *, struct scsi_xfer *);
struct vs_cb *vs_find_queue(struct scsi_link *, struct vs_softc *);
void	vs_reset(struct vs_softc *, int);
void	vs_resync(struct vs_softc *);
void	vs_scsidone(struct vs_softc *, struct vs_cb *);
int	vs_unit_value(int, int, int);

static __inline__ void vs_free(struct vs_softc *, struct vs_cb *);
static __inline__ void vs_clear_return_info(struct vs_softc *);

int
vsmatch(struct device *device, void *cf, void *args)
{
	struct confargs *ca = args;
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;
	int rc;
	u_int16_t id;

	if (bus_space_map(iot, ca->ca_paddr, S_SHORTIO, 0, &ioh) != 0)
		return 0;
	rc = badvaddr((vaddr_t)bus_space_vaddr(iot, ioh) + sh_CSS + CSB_TYPE, 2);
	if (rc == 0) {
		id = bus_space_read_2(iot, ioh, sh_CSS + CSB_TYPE);
		if (id != JAGUAR && id != COUGAR)
			rc = 1;
		/*
		 * Note that this will reject Cougar boards configured with
		 * less than 2KB of short I/O memory.
		 * Is it worth checking for a Cougar signature at lower
		 * addresses, knowing that we can't really work unless
		 * the board is jumped to enable the whole 2KB?
		 */
	}
	bus_space_unmap(iot, ioh, S_SHORTIO);

	return rc == 0;
}

void
vsattach(struct device *parent, struct device *self, void *args)
{
	struct vs_softc *sc = (struct vs_softc *)self;
	struct vs_channel *vc;
	struct confargs *ca = args;
	struct scsi_link *sc_link;
	struct scsibus_attach_args saa;
#ifdef notyet
	int evec, bus;
#else
	int bus;
#endif
	int tmp;

#ifdef notyet
	/* get the next available vector for the error interrupt */
	evec = vme_findvec(ca->ca_vec);

	if (ca->ca_vec < 0 || evec < 0) {
		printf(": no more interrupts!\n");
		return;
	}
#endif
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_BIO;

#ifdef notyet
	printf(" vec 0x%x: ", evec);
#else
	printf(": ");
#endif

	sc->sc_dmat = ca->ca_dmat;
	sc->sc_iot = ca->ca_iot;
	if (bus_space_map(sc->sc_iot, ca->ca_paddr, S_SHORTIO, 0,
	    &sc->sc_ioh) != 0) {
		printf("can't map registers!\n");
		return;
	}

	sc->sc_bid = csb_read(2, CSB_TYPE);
	sc->sc_ipl = ca->ca_ipl;
	sc->sc_nvec = ca->ca_vec;
#ifdef notyet
	sc->sc_evec = evec;
#else
	sc->sc_evec = ca->ca_vec;
#endif

	if (vs_initialize(sc))
		return;

	sc->sc_ih_n.ih_fn = vs_nintr;
	sc->sc_ih_n.ih_arg = sc;
	sc->sc_ih_n.ih_wantframe = 0;
	sc->sc_ih_n.ih_ipl = ca->ca_ipl;

	sc->sc_ih_e.ih_fn = vs_eintr;
	sc->sc_ih_e.ih_arg = sc;
	sc->sc_ih_e.ih_wantframe = 0;
	sc->sc_ih_e.ih_ipl = ca->ca_ipl;

	vmeintr_establish(sc->sc_nvec, &sc->sc_ih_n, self->dv_xname);
#ifdef notyet
	snprintf(sc->sc_intrname_e, sizeof sc->sc_intrname_e,
	    "%s_err", self->dv_xname);
	vmeintr_establish(sc->sc_evec, &sc->sc_ih_e, sc->sc_intrname_e);
#endif

	/*
	 * Attach all scsi units on us, watching for boot device
	 * (see device_register).
	 */
	tmp = bootpart;
	if (ca->ca_paddr != bootaddr)
		bootpart = -1;		/* invalid flag to device_register */

	for (bus = 0; bus < 2; bus++) {
		vc = &sc->sc_channel[bus];
		if (vc->vc_id < 0)
			continue;

		sc_link = &vc->vc_link;
		sc_link->adapter = &vs_scsiswitch;
		sc_link->adapter_buswidth = vc->vc_width;
		sc_link->adapter_softc = sc;
		sc_link->adapter_target = vc->vc_id;
		if (sc->sc_bid != JAGUAR)
			sc_link->luns = 1;	/* not enough queues */
		sc_link->openings = 1;
		if (bus != 0)
			sc_link->flags = SDEV_2NDBUS;

		printf("%s: channel %d", sc->sc_dev.dv_xname, bus);
		switch (vc->vc_type) {
		case VCT_SE:
			printf(", single-ended");
			break;
		case VCT_DIFFERENTIAL:
			printf(", differential");
			break;
		}
		printf("\n");

		if (vc->vc_width == 0) {
			printf("%s: daughterboard disabled, "
			    "not enough on-board memory\n",
			    sc->sc_dev.dv_xname);
			continue;
		}

		bzero(&saa, sizeof(saa));
		saa.saa_sc_link = &vc->vc_link;

		bootbus = bus;
		config_found(self, &saa, scsiprint);
	}

	bootpart = tmp;		    /* restore old values */
	bootbus = 0;
}

void
vs_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ptoa(MAX_SG_ELEMENTS))
		bp->b_bcount = ptoa(MAX_SG_ELEMENTS);
	minphys(bp);
}

void
vs_print_addr(struct vs_softc *sc, struct scsi_xfer *xs)
{
	if (xs == NULL)
		printf("%s: ", sc->sc_dev.dv_xname);
	else {
		sc_print_addr(xs->sc_link);

		/* print bus number too if appropriate */
		if (sc->sc_channel[1].vc_width >= 0)
			printf("(channel %d) ",
			    !!(xs->sc_link->flags & SDEV_2NDBUS));
	}
}

int
do_vspoll(struct vs_softc *sc, struct scsi_xfer *xs, int canreset)
{
	int to;
	int crsw, bus;

	if (xs != NULL) {
		bus = !!(xs->sc_link->flags & SDEV_2NDBUS);
		to = xs->timeout;
		if (to == 0)
			to = 2000;
	} else {
		bus = -1;
		to = 2000;
	}

	while (((crsw = CRSW) & (M_CRSW_CRBV | M_CRSW_CC)) == 0) {
		if (to-- <= 0) {
			vs_print_addr(sc, xs);
			printf("command timeout, crsw 0x%x\n", crsw);

			if (canreset) {
				vs_reset(sc, bus);
				vs_resync(sc);
			}
			return 1;
		}
		delay(1000);
	}
#ifdef VS_DEBUG
	printf("%s: crsw %04x to %d/%d\n",
	    __func__, crsw, to, xs ? xs->timeout : 2000);
#endif
	return 0;
}

void
vs_poll(struct vs_softc *sc, struct vs_cb *cb)
{
	struct scsi_xfer *xs;
	int s;
	int rc;

	xs = cb->cb_xs;
	rc = do_vspoll(sc, xs, 1);

	s = splbio();
	if (rc != 0) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
#ifdef VS_DEBUG
		printf("%s: polled command timed out\n", __func__);
#endif
		vs_free(sc, cb);
		scsi_done(xs);
	} else
		vs_scsidone(sc, cb);
	splx(s);

	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;

	vs_clear_return_info(sc);
}

void
thaw_queue(struct vs_softc *sc, int target)
{
	THAW(target);

	/* loop until thawed */
	while (THAW_REG & M_THAW_TWQE)
		;
}

void
thaw_all_queues(struct vs_softc *sc)
{
	int i;

	for (i = 1; i <= sc->sc_nwq; i++)
		thaw_queue(sc, i);
}

void
vs_scsidone(struct vs_softc *sc, struct vs_cb *cb)
{
	struct scsi_xfer *xs = cb->cb_xs;
	u_int32_t len;
	int error;

	len = vs_read(4, sh_RET_IOPB + IOPB_LENGTH);
	xs->resid = xs->datalen - len;

	error = vs_read(2, sh_RET_IOPB + IOPB_STATUS);
#ifdef VS_DEBUG
	printf("%s: queue %d, len %u (resid %d) error %d\n",
	    __func__, cb->cb_q, len, xs->resid, error);
	if (error != 0)
		printf("%s: last select %d %d, phase %02x %02x\n",
		    __func__, csb_read(1, CSB_LPDS), csb_read(1, CSB_LSDS),
		    csb_read(1, CSB_PPS), csb_read(1, CSB_SPS));
#endif
	if ((error & 0xff) == SCSI_SELECTION_TO) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
	} else {
		if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
			bus_dmamap_sync(sc->sc_dmat, cb->cb_dmamap, 0,
			    cb->cb_dmalen, (xs->flags & SCSI_DATA_IN) ?
			      BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, cb->cb_dmamap);
		}

		xs->status = error >> 8;
	}

	while (xs->status == SCSI_CHECK) {
		vs_chksense(cb, xs);
	}

	vs_free(sc, cb);
	scsi_done(xs);
}

void
vs_scsicmd(struct scsi_xfer *xs)
{
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	int flags;
	bus_addr_t cqep, iopb;
	struct vs_cb *cb;
	int s;
	int rc;

	flags = xs->flags;
	if (flags & SCSI_POLL) {
		cb = sc->sc_cb;
		cqep = sh_MCE;
		iopb = sh_MCE_IOPB;

#ifdef VS_DEBUG
		if (mce_read(2, CQE_QECR) & M_QECR_GO)
			printf("%s: master command queue busy\n",
			    sc->sc_dev.dv_xname);
#endif
		/* Wait until we can use the command queue entry. */
		while (mce_read(2, CQE_QECR) & M_QECR_GO)
			;
#ifdef VS_DEBUG
		if (cb->cb_xs != NULL) {
			printf("%s: master command not idle\n",
			    sc->sc_dev.dv_xname);
			xs->error = XS_BUSY;
			scsi_done(xs);
			return;
		}
#endif
		s = splbio();
	} else {
		s = splbio();
		cb = vs_find_queue(slp, sc);
		if (cb == NULL) {
			splx(s);
#ifdef VS_DEBUG
			printf("%s: queue for target %d is busy\n",
			    sc->sc_dev.dv_xname, slp->target);
#endif
			xs->error = XS_NO_CCB;
			scsi_done(xs);
		}
		if (vs_getcqe(sc, &cqep, &iopb)) {
			/* XXX shouldn't happen since our queue is ready */
			splx(s);
#ifdef VS_DEBUG
			printf("%s: no free CQEs\n", sc->sc_dev.dv_xname);
#endif
			xs->error = XS_NO_CCB;
			scsi_done(xs);
		}
	}

#ifdef VS_DEBUG
	printf("%s: sending SCSI command %02x (length %d) on queue %d\n",
	    __func__, xs->cmd->opcode, xs->cmdlen, cb->cb_q);
#endif
	rc = vs_load_command(sc, cb, cqep, iopb, slp, xs->flags,
	    xs->cmd, xs->cmdlen, xs->data, xs->datalen);
	if (rc != 0) {
		printf("%s: unable to load DMA map: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		splx(s);
		return;
	}

	vs_write(1, cqep + CQE_WORK_QUEUE, cb->cb_q);

	cb->cb_xs = xs;
	splx(s);

	vs_write(4, cqep + CQE_CTAG, (u_int32_t)cb);

	if (crb_read(2, CRB_CRSW) & M_CRSW_AQ)
		vs_write(2, cqep + CQE_QECR, M_QECR_AA | M_QECR_GO);
	else
		vs_write(2, cqep + CQE_QECR, M_QECR_GO);

	if (flags & SCSI_POLL) {
		/* poll for the command to complete */
		vs_poll(sc, cb);
	}
}

int
vs_load_command(struct vs_softc *sc, struct vs_cb *cb, bus_addr_t cqep,
    bus_addr_t iopb, struct scsi_link *slp, int flags,
    struct scsi_generic *cmd, int cmdlen, uint8_t *data, int datalen)
{
	unsigned int iopb_len;
	int option;
	int rc;

	/*
	 * We should only provide the iopb len if the controller is not
	 * able to compute it from the SCSI command group.
	 * Note that Jaguar has no knowledge of group 2.
	 */
	switch ((cmd->opcode) >> 5) {
	case 0:
	case 1:
	case 5:
		iopb_len = 0;
		break;
	case 2:
		if (sc->sc_bid == COUGAR)
			iopb_len = 0;
		else
		/* FALLTHROUGH */
	default:
		iopb_len = IOPB_SHORT_SIZE + ((cmdlen + 1) >> 1);
		break;
	}

	vs_bzero(iopb, IOPB_LONG_SIZE);
	bus_space_write_region_1(sc->sc_iot, sc->sc_ioh, iopb + IOPB_SCSI_DATA,
	    (u_int8_t *)cmd, cmdlen);
	vs_write(2, iopb + IOPB_CMD, IOPB_PASSTHROUGH);
	vs_write(2, iopb + IOPB_UNIT,
	  vs_unit_value(slp->flags & SDEV_2NDBUS, slp->target, slp->lun));
#ifdef VS_DEBUG
	printf("%s: target %d lun %d encoded as %04x\n",
	    __func__, slp->target, slp->lun, (u_int)
	    vs_unit_value(slp->flags & SDEV_2NDBUS, slp->target, slp->lun));
#endif
	vs_write(1, iopb + IOPB_NVCT, sc->sc_nvec);
	vs_write(1, iopb + IOPB_EVCT, sc->sc_evec);

	/*
	 * Setup DMA map for data transfer
	 */
	if (flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		cb->cb_dmalen = (bus_size_t)datalen;
		rc = bus_dmamap_load(sc->sc_dmat, cb->cb_dmamap,
		    data, cb->cb_dmalen, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_STREAMING |
		    ((flags & SCSI_DATA_IN) ? BUS_DMA_READ : BUS_DMA_WRITE));
		if (rc != 0)
			return rc;

		bus_dmamap_sync(sc->sc_dmat, cb->cb_dmamap, 0,
		    cb->cb_dmalen, (flags & SCSI_DATA_IN) ?
		      BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
	}

	option = 0;
	if (flags & SCSI_DATA_OUT)
		option |= M_OPT_DIR;
	if (slp->adapter_buswidth > 8)
		option |= M_OPT_GO_WIDE;

	if (flags & SCSI_POLL) {
		vs_write(2, iopb + IOPB_OPTION, option);
		vs_write(2, iopb + IOPB_LEVEL, 0);
	} else {
		vs_write(2, iopb + IOPB_OPTION, option | M_OPT_IE);
		vs_write(2, iopb + IOPB_LEVEL, sc->sc_ipl);
	}
	vs_write(2, iopb + IOPB_ADDR, ADDR_MOD);

	if (flags & (SCSI_DATA_IN | SCSI_DATA_OUT))
		vs_build_sg_list(sc, cb, iopb);

	vs_bzero(cqep, CQE_SIZE);
	vs_write(2, cqep + CQE_IOPB_ADDR, iopb);
	vs_write(1, cqep + CQE_IOPB_LENGTH, iopb_len);
	/* CQE_WORK_QUEUE to be filled by the caller */

	return 0;
}

void
vs_chksense(struct vs_cb *cb, struct scsi_xfer *xs)
{
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	struct scsi_sense ss;
	int rc;
	int s;

#ifdef VS_DEBUG
	printf("%s: target %d\n", __func__, slp->target);
#endif
	/* ack and clear the error */
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;
	xs->status = 0;

	/* Wait until we can use the command queue entry. */
	while (mce_read(2, CQE_QECR) & M_QECR_GO)
		;

	bzero(&ss, sizeof ss);
	ss.opcode = REQUEST_SENSE;
	ss.byte2 = slp->lun << 5;
	ss.length = sizeof(xs->sense);

#ifdef VS_DEBUG
	printf("%s: sending SCSI command %02x (length %d) on queue %d\n",
	    __func__, ss.opcode, sizeof ss, 0);
#endif
	rc = vs_load_command(sc, cb, sh_MCE, sh_MCE_IOPB, slp,
	    SCSI_DATA_IN | SCSI_POLL,
	    (struct scsi_generic *)&ss, sizeof ss, (uint8_t *)&xs->sense,
	    sizeof(xs->sense));
	if (rc != 0) {
		printf("%s: unable to load DMA map: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		xs->error = XS_DRIVER_STUFFUP;
		xs->status = 0;
		return;
	}

	mce_write(1, CQE_WORK_QUEUE, 0);
	mce_write(2, CQE_QECR, M_QECR_GO);

	/* poll for the command to complete */
	s = splbio();
	do_vspoll(sc, xs, 1);
	xs->status = vs_read(2, sh_RET_IOPB + IOPB_STATUS) >> 8;
	splx(s);
}

int
vs_getcqe(struct vs_softc *sc, bus_addr_t *cqep, bus_addr_t *iopbp)
{
	bus_addr_t cqe, iopb;
	int qhdp;

	qhdp = mcsb_read(2, MCSB_QHDP);
	cqe = sh_CQE(qhdp);
	iopb = sh_IOPB(qhdp);

	if (vs_read(2, cqe + CQE_QECR) & M_QECR_GO) {
		/* queue still in use, should never happen */
		return EAGAIN;
	}

	if (++qhdp == NUM_CQE)
		qhdp = 0;
	mcsb_write(2, MCSB_QHDP, qhdp);

	vs_bzero(cqe, CQE_SIZE);
	*cqep = cqe;
	*iopbp = iopb;
	return (0);
}

int
vs_identify(struct vs_channel *vc, int cid)
{
	vc->vc_width = 0;
	vc->vc_type = VCT_UNKNOWN;

	if (vc->vc_id < 0)
		return (0);

	switch (cid) {
	case 0x00:
		vc->vc_width = 8;
		vc->vc_type = VCT_SE;
		break;
	case 0x01:
		vc->vc_width = 8;
		vc->vc_type = VCT_DIFFERENTIAL;
		break;
	case 0x02:
		vc->vc_width = 16;
		vc->vc_type = VCT_SE;
		break;
	case 0x03:
	case 0x0e:
		vc->vc_width = 16;
		vc->vc_type = VCT_DIFFERENTIAL;
		break;
	default:
		vc->vc_id = -1;
		return (0);
	}

	return (vc->vc_width - 1);
}

int
vs_initialize(struct vs_softc *sc)
{
	int i, msr, id, rc;
	u_int targets;

	/*
	 * Reset the board, and wait for it to get ready.
	 * The reset signal is applied for 70 usec, and the board status
	 * is not tested until 100 usec after the reset signal has been
	 * cleared, per the manual (MVME328/D1) pages 4-6 and 4-9.
	 */

	mcsb_write(2, MCSB_MCR, M_MCR_RES | M_MCR_SFEN);
	delay(70);
	mcsb_write(2, MCSB_MCR, M_MCR_SFEN);

	delay(100);
	i = 0;
	for (;;) {
		msr = mcsb_read(2, MCSB_MSR);
		if ((msr & (M_MSR_BOK | M_MSR_CNA)) == M_MSR_BOK)
			break;
		if (++i > 5000) {
			printf("board reset failed, status %x\n", msr);
			return 1;
		}
		delay(1000);
	}

	/* describe the board */
	switch (sc->sc_bid) {
	default:
	case JAGUAR:
		printf("Jaguar");
		break;
	case COUGAR:
		id = csb_read(1, CSB_EXTID);
		switch (id) {
		case 0x00:
			printf("Cougar");
			break;
		case 0x02:
			printf("Cougar II");
			break;
		default:
			printf("unknown Cougar version %02x", id);
			break;
		}
		break;
	}

	/* initialize channels id */
	sc->sc_channel[0].vc_id = csb_read(1, CSB_PID);
	sc->sc_channel[1].vc_id = -1;
	switch (id = csb_read(1, CSB_DBID)) {
	case DBID_SCSI2:
	case DBID_SCSI:
		sc->sc_channel[1].vc_id = csb_read(1, CSB_SID);
		break;
	case DBID_PRINTER:
		printf(", printer port");
		break;
	case DBID_NONE:
		break;
	default:
		printf(", unknown daughterboard id %x", id);
		break;
	}

	printf("\n");

	/*
	 * On cougar boards, find how many work queues we can use,
	 * and whether we are on wide or narrow buses.
	 */
	switch (sc->sc_bid) {
	case COUGAR:
		sc->sc_nwq = csb_read(2, CSB_NWQ);
		/*
		 * Despite what the documentation says, this value is not
		 * always provided. If it is invalid, decide on the number
		 * of available work queues from the memory size, as the
		 * firmware does.
		 */
#ifdef VS_DEBUG
		printf("%s: controller reports %d work queues\n",
		    __func__, sc->sc_nwq);
#endif
		if (sc->sc_nwq != 0x0f && sc->sc_nwq != 0xff) {
			if (csb_read(2, CSB_BSIZE) >= 0x0100)
				sc->sc_nwq = 0xff;	/* >= 256KB, 255 WQ */
			else
				sc->sc_nwq = 0x0f;	/* < 256KB, 15 WQ */
		}
#ifdef VS_DEBUG
		printf("%s: driver deducts %d work queues\n",
		    __func__, sc->sc_nwq);
#endif
		if (sc->sc_nwq > NUM_WQ)
			sc->sc_nwq = NUM_WQ;

		targets = vs_identify(&sc->sc_channel[0],
		    csb_read(1, CSB_PFECID));
		targets += vs_identify(&sc->sc_channel[1],
		    csb_read(1, CSB_SFECID));

		if (sc->sc_nwq > targets)
			sc->sc_nwq = targets;
		else {
			/*
			 * We can't drive the daughter board if there is not
			 * enough on-board memory for all the work queues.
			 * XXX This might work by moving everything off-board?
			 */
			if (sc->sc_nwq < targets)
				sc->sc_channel[1].vc_width = 0;
		}
		break;
	default:
	case JAGUAR:
		sc->sc_nwq = JAGUAR_MAX_WQ;
		sc->sc_channel[0].vc_width = sc->sc_channel[1].vc_width = 8;
		break;
	}

	CRB_CLR_DONE;
	mcsb_write(2, MCSB_QHDP, 0);

	vs_bzero(sh_CIB, CIB_SIZE);
	cib_write(2, CIB_NCQE, NUM_CQE);
	cib_write(2, CIB_BURST, 0);
	cib_write(2, CIB_NVECT, (sc->sc_ipl << 8) | sc->sc_nvec);
	cib_write(2, CIB_EVECT, (sc->sc_ipl << 8) | sc->sc_evec);
	cib_write(2, CIB_PID, 0x08);	/* use default */
	cib_write(2, CIB_SID, 0x08);	/* use default */
	cib_write(2, CIB_CRBO, sh_CRB);
	cib_write(4, CIB_SELECT, SELECTION_TIMEOUT);
	cib_write(4, CIB_WQTIMO, 4);
	cib_write(4, CIB_VMETIMO, 0 /* VME_BUS_TIMEOUT */);
	cib_write(2, CIB_ERR_FLGS, M_ERRFLGS_RIN | M_ERRFLGS_RSE);
	cib_write(2, CIB_SBRIV, (sc->sc_ipl << 8) | sc->sc_evec);
	cib_write(1, CIB_SOF0, 0x15);
	cib_write(1, CIB_SRATE0, 100 / 4);
	cib_write(1, CIB_SOF1, 0);
	cib_write(1, CIB_SRATE1, 0);

	vs_bzero(sh_MCE_IOPB, IOPB_LONG_SIZE);
	mce_iopb_write(2, IOPB_CMD, CNTR_INIT);
	mce_iopb_write(2, IOPB_OPTION, 0);
	mce_iopb_write(1, IOPB_NVCT, sc->sc_nvec);
	mce_iopb_write(1, IOPB_EVCT, sc->sc_evec);
	mce_iopb_write(2, IOPB_LEVEL, 0 /* sc->sc_ipl */);
	mce_iopb_write(2, IOPB_ADDR, SHIO_MOD);
	mce_iopb_write(4, IOPB_BUFF, sh_CIB);
	mce_iopb_write(4, IOPB_LENGTH, CIB_SIZE);

	vs_bzero(sh_MCE, CQE_SIZE);
	mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
	mce_write(1, CQE_IOPB_LENGTH, 0);
	mce_write(1, CQE_WORK_QUEUE, 0);
	mce_write(2, CQE_QECR, M_QECR_GO);

	/* poll for the command to complete */
	do_vspoll(sc, NULL, 1);

	if ((rc = vs_alloc_sg(sc)) != 0)
		return rc;

	if ((rc = vs_alloc_wq(sc)) != 0)
		return rc;

	/* initialize work queues */
#ifdef VS_DEBUG
	printf("%s: initializing %d work queues\n",
	    __func__, sc->sc_nwq);
#endif

	for (i = 1; i <= sc->sc_nwq; i++) {
		/* Wait until we can use the command queue entry. */
		while (mce_read(2, CQE_QECR) & M_QECR_GO)
			;

		vs_bzero(sh_MCE_IOPB, IOPB_LONG_SIZE);
		mce_iopb_write(2, WQCF_CMD, CNTR_INIT_WORKQ);
		mce_iopb_write(2, WQCF_OPTION, 0);
		mce_iopb_write(1, WQCF_NVCT, sc->sc_nvec);
		mce_iopb_write(1, WQCF_EVCT, sc->sc_evec);
		mce_iopb_write(2, WQCF_ILVL, 0 /* sc->sc_ipl */);
		mce_iopb_write(2, WQCF_WORKQ, i);
		mce_iopb_write(2, WQCF_WOPT, M_WOPT_FE | M_WOPT_IWQ);
		if (sc->sc_bid == JAGUAR)
			mce_iopb_write(2, WQCF_SLOTS, JAGUAR_MAX_Q_SIZ);
		mce_iopb_write(4, WQCF_CMDTO, 4);	/* 1 second */
		if (sc->sc_bid != JAGUAR)
			mce_iopb_write(2, WQCF_UNIT,
			    vs_unit_value(i > sc->sc_channel[0].vc_width,
				i - sc->sc_channel[0].vc_width, 0));

		vs_bzero(sh_MCE, CQE_SIZE);
		mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
		mce_write(1, CQE_IOPB_LENGTH, 0);
		mce_write(1, CQE_WORK_QUEUE, 0);
		mce_write(2, CQE_QECR, M_QECR_GO);

		/* poll for the command to complete */
		do_vspoll(sc, NULL, 1);
		if (CRSW & M_CRSW_ER) {
			printf("%s: work queue %d initialization error 0x%x\n",
			    sc->sc_dev.dv_xname, i,
			    vs_read(2, sh_RET_IOPB + IOPB_STATUS));
			return ENXIO;
		}
		CRB_CLR_DONE;
	}

	/* start queue mode */
	mcsb_write(2, MCSB_MCR, mcsb_read(2, MCSB_MCR) | M_MCR_SQM);

	/* reset all SCSI buses */
	vs_reset(sc, -1);
	/* sync all devices */
	vs_resync(sc);

	return 0;
}

/*
 * Allocate memory for the scatter/gather lists.
 *
 * Since vs_minphys() makes sure we won't need more than flat lists of
 * up to MAX_SG_ELEMENTS entries, we need to allocate storage for one
 * such list per work queue.
 */
int
vs_alloc_sg(struct vs_softc *sc)
{
	size_t sglen;
	int nseg;
	int rc;

	sglen = (sc->sc_nwq + 1) * MAX_SG_ELEMENTS * sizeof(struct vs_sg_entry);
	sglen = round_page(sglen);

	rc = bus_dmamem_alloc(sc->sc_dmat, sglen, 0, 0,
	    &sc->sc_sgseg, 1, &nseg, BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: unable to allocate s/g memory: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail1;
	}
	rc = bus_dmamem_map(sc->sc_dmat, &sc->sc_sgseg, nseg, sglen,
	    (caddr_t *)&sc->sc_sgva, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (rc != 0) {
		printf("%s: unable to map s/g memory: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail2;
	}
	rc = bus_dmamap_create(sc->sc_dmat, sglen, 1, sglen, 0,
	    BUS_DMA_NOWAIT /* | BUS_DMA_ALLOCNOW */, &sc->sc_sgmap);
	if (rc != 0) {
		printf("%s: unable to create s/g dma map: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail3;
	}
	rc = bus_dmamap_load(sc->sc_dmat, sc->sc_sgmap, sc->sc_sgva,
	    sglen, NULL, BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: unable to load s/g dma map: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail4;
	}

	return 0;

fail4:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_sgmap);
fail3:
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_sgva, PAGE_SIZE);
fail2:
	bus_dmamem_free(sc->sc_dmat, &sc->sc_sgseg, 1);
fail1:
	return rc;
}

/*
 * Allocate one command block per work qeue.
 */
int
vs_alloc_wq(struct vs_softc *sc)
{
	struct vs_cb *cb;
	u_int i;
	int rc;

	sc->sc_cb = malloc((sc->sc_nwq + 1) * sizeof(struct vs_cb), M_DEVBUF,
	    M_ZERO | M_NOWAIT);
	if (sc->sc_cb == NULL) {
		printf("%s: unable to allocate %d work queues\n",
		    sc->sc_dev.dv_xname, sc->sc_nwq);
		return ENOMEM;
	}

	for (i = 0, cb = sc->sc_cb; i <= sc->sc_nwq; i++, cb++) {
		cb->cb_q = i;

		rc = bus_dmamap_create(sc->sc_dmat, ptoa(MAX_SG_ELEMENTS),
		    MAX_SG_ELEMENTS, MAX_SG_ELEMENT_SIZE, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &cb->cb_dmamap);
		if (rc != 0) {
			printf("%s: unable to create dma map for queue %d"
			    ": error %d\n",
			    sc->sc_dev.dv_xname, i, rc);
			goto fail;
		}
	}

	return 0;

fail:
	while (i != 0) {
		i--; cb--;
		bus_dmamap_destroy(sc->sc_dmat, cb->cb_dmamap);
	}
	free(sc->sc_cb, M_DEVBUF);
	sc->sc_cb = NULL;

	return rc;
}

void
vs_resync(struct vs_softc *sc)
{
	struct vs_channel *vc;
	int bus, target;

	for (bus = 0; bus < 2; bus++) {
		vc = &sc->sc_channel[bus];
		if (vc->vc_id < 0 || vc->vc_width == 0)
			break;

		for (target = 0; target < vc->vc_width; target++) {
			if (target == vc->vc_id)
				continue;

			/* Wait until we can use the command queue entry. */
			while (mce_read(2, CQE_QECR) & M_QECR_GO)
				;

			vs_bzero(sh_MCE_IOPB, IOPB_SHORT_SIZE);
			mce_iopb_write(2, DRCF_CMD, CNTR_DEV_REINIT);
			mce_iopb_write(2, DRCF_OPTION, 0); /* prefer polling */
			mce_iopb_write(1, DRCF_NVCT, sc->sc_nvec);
			mce_iopb_write(1, DRCF_EVCT, sc->sc_evec);
			mce_iopb_write(2, DRCF_ILVL, 0);
			mce_iopb_write(2, DRCF_UNIT,
			    vs_unit_value(bus, target, 0));

			vs_bzero(sh_MCE, CQE_SIZE);
			mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
			mce_write(1, CQE_IOPB_LENGTH, 0);
			mce_write(1, CQE_WORK_QUEUE, 0);
			mce_write(2, CQE_QECR, M_QECR_GO);

			/* poll for the command to complete */
			do_vspoll(sc, NULL, 0);
			if (CRSW & M_CRSW_ER)
				CRB_CLR_ER;
			CRB_CLR_DONE;
		}
	}
}

void
vs_reset(struct vs_softc *sc, int bus)
{
	int b, s;

	s = splbio();

	for (b = 0; b < 2; b++) {
		if (bus >= 0 && b != bus)
			continue;

		/* Wait until we can use the command queue entry. */
		while (mce_read(2, CQE_QECR) & M_QECR_GO)
			;

		vs_bzero(sh_MCE_IOPB, IOPB_SHORT_SIZE);
		mce_iopb_write(2, SRCF_CMD, IOPB_RESET);
		mce_iopb_write(2, SRCF_OPTION, 0);	/* prefer polling */
		mce_iopb_write(1, SRCF_NVCT, sc->sc_nvec);
		mce_iopb_write(1, SRCF_EVCT, sc->sc_evec);
		mce_iopb_write(2, SRCF_ILVL, 0);
		mce_iopb_write(2, SRCF_BUSID, b << 15);

		vs_bzero(sh_MCE, CQE_SIZE);
		mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
		mce_write(1, CQE_IOPB_LENGTH, 0);
		mce_write(1, CQE_WORK_QUEUE, 0);
		mce_write(2, CQE_QECR, M_QECR_GO);

		/* poll for the command to complete */
		for (;;) {
			do_vspoll(sc, NULL, 0);
			/* ack & clear scsi error condition cause by reset */
			if (CRSW & M_CRSW_ER) {
				CRB_CLR_DONE;
				vs_write(2, sh_RET_IOPB + IOPB_STATUS, 0);
				break;
			}
			CRB_CLR_DONE;
		}
	}

	thaw_all_queues(sc);

	splx(s);
}

/* free a cb and thaw its queue; invoked at splbio */
static __inline__ void
vs_free(struct vs_softc *sc, struct vs_cb *cb)
{
	if (cb->cb_q != 0)
		thaw_queue(sc, cb->cb_q);
	cb->cb_xs = NULL;
}

/* normal interrupt routine */
int
vs_nintr(void *vsc)
{
	struct vs_softc *sc = (struct vs_softc *)vsc;
	struct vs_cb *cb;
	int s;

#ifndef notyet	/* bogus! */
	if ((CRSW & CONTROLLER_ERROR) == CONTROLLER_ERROR)
		return vs_eintr(sc);
#endif

	/* Got a valid interrupt on this device */
	s = splbio();
	cb = (struct vs_cb *)crb_read(4, CRB_CTAG);

	/*
	 * If this is a controller error, there won't be a cb
	 * pointer in the CTAG field.  Bad things happen if you try
	 * to point to address 0.  But then, we should have caught
	 * the controller error above.
	 */
	if (cb != NULL) {
#ifdef VS_DEBUG
		printf("%s: interrupt for queue %d\n", __func__, cb->cb_q);
#endif
		vs_scsidone(sc, cb);
	} else {
#ifdef VS_DEBUG
		printf("%s: normal interrupt but no related command???\n",
		    __func__);
#endif
	}

	/* ack the interrupt */
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;

	vs_clear_return_info(sc);
	splx(s);

	return 1;
}

/* error interrupts */
int
vs_eintr(void *vsc)
{
	struct vs_softc *sc = (struct vs_softc *)vsc;
	struct vs_cb *cb;
	struct scsi_xfer *xs;
	int crsw, ecode;
	int s;

	/* Got a valid interrupt on this device */
	s = splbio();

	crsw = vs_read(2, sh_CEVSB + CEVSB_CRSW);
	ecode = vs_read(1, sh_CEVSB + CEVSB_ERROR);
	cb = (struct vs_cb *)crb_read(4, CRB_CTAG);
	xs = cb != NULL ? cb->cb_xs : NULL;

#ifdef VS_DEBUG
	printf("%s: error interrupt, crsw %04x, error %d, queue %d\n",
	    __func__, (u_int)crsw, ecode, cb ? cb->cb_q : -1);
#endif
	vs_print_addr(sc, xs);

	if (crsw & M_CRSW_RST) {
		printf("bus reset\n");
	} else {
		switch (ecode) {
		case CEVSB_ERR_TYPE:
			printf("IOPB type error\n");
			break;
		case CEVSB_ERR_TO:
			printf("timeout\n");
			break;
		case CEVSB_ERR_TR:
			printf("reconnect error\n");
			break;
		case CEVSB_ERR_OF:
			printf("overflow\n");
			break;
		case CEVSB_ERR_BD:
			printf("bad direction\n");
			break;
		case CEVSB_ERR_NR:
			printf("non-recoverable error\n");
			break;
		case CEVSB_ERR_PANIC:
			printf("board panic\n");
			break;
		default:
			printf("unexpected error %x\n", ecode);
			break;
		}
	}

	if (xs != NULL) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		scsi_done(xs);
	}

	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;

	thaw_all_queues(sc);
	vs_clear_return_info(sc);
	splx(s);

	return 1;
}

static void
vs_clear_return_info(struct vs_softc *sc)
{
	vs_bzero(sh_RET_IOPB, CRB_SIZE + IOPB_LONG_SIZE);
}

/*
 * Choose the first available work queue (invoked at splbio).
 * We used a simple round-robin mechanism which is faster than rescanning
 * from the beginning if we have more than one target on the bus.
 */
struct vs_cb *
vs_find_queue(struct scsi_link *sl, struct vs_softc *sc)
{
	struct vs_cb *cb;
	u_int q;

	/*
	 * Map the target number (0-7/15) to the 1-7/15 range, target 0
	 * picks the host adapter target number (since host adapter
	 * commands are issued on queue #0).
	 */
	q = sl->target;
	if (q == 0)
		q = sl->adapter_target;
	if (sl->flags & SDEV_2NDBUS)
		q += sc->sc_channel[0].vc_width - 1; /* map to 8-14 or 16-30 */

	if ((cb = sc->sc_cb + q)->cb_xs == NULL)
		return (cb);

	return (NULL);
}

/*
 * Encode a specific target.
 */
int
vs_unit_value(int bus, int tgt, int lun)
{
	int unit = 0;

	if (bus != 0)
		unit |= M_UNIT_BUS;	/* secondary bus */

	if (tgt > 7 || lun > 7) {
		/* extended addressing (for Cougar II-Wide only) */
		unit |= M_UNIT_EXT;
		unit |= (lun & 0x3f) << 8;
		unit |= (tgt & 0x0f) << 0;
	} else {
		unit |= lun << 3;
		unit |= tgt << 0;
	}

	return (unit);
}

/*
 * Build the scatter/gather list for the given control block and update
 * its IOPB.
 */
void
vs_build_sg_list(struct vs_softc *sc, struct vs_cb *cb, bus_addr_t iopb)
{
	struct vs_sg_entry *sgentry;
	int segno;
	bus_dma_segment_t *seg = cb->cb_dmamap->dm_segs;
	bus_size_t sgoffs;
	bus_size_t len;

	/*
	 * No need to build a scatter/gather chain if there is only
	 * one contiguous physical area.
	 */
	if (cb->cb_dmamap->dm_nsegs == 1) {
		vs_write(4, iopb + IOPB_BUFF, seg->ds_addr);
		vs_write(4, iopb + IOPB_LENGTH, cb->cb_dmalen);
		return;
	}

	/*
	 * Otherwise, we need to build the flat s/g list.
	 */

	sgentry = sc->sc_sgva + cb->cb_q * MAX_SG_ELEMENTS;
	sgoffs = (vaddr_t)sgentry - (vaddr_t)sc->sc_sgva;

	len = cb->cb_dmalen;
	for (segno = 0; segno < cb->cb_dmamap->dm_nsegs; seg++, segno++) {
		if (seg->ds_len > len) {
			sgentry->count.bytes = htobe16(len);
			len = 0;
		} else {
			sgentry->count.bytes = htobe16(seg->ds_len);
			len -= seg->ds_len;
		}
		sgentry->pa_high = htobe16(seg->ds_addr >> 16);
		sgentry->pa_low = htobe16(seg->ds_addr & 0xffff);
		sgentry->addr = htobe16(ADDR_MOD);
		sgentry++;
	}

	bus_dmamap_sync(sc->sc_dmat, sc->sc_sgmap, sgoffs,
	    cb->cb_dmamap->dm_nsegs * sizeof(struct vs_sg_entry),
	    BUS_DMASYNC_PREWRITE);

	vs_write(2, iopb + IOPB_OPTION,
	    vs_read(2, iopb + IOPB_OPTION) | M_OPT_SG);
	vs_write(2, iopb + IOPB_ADDR,
	    vs_read(2, iopb + IOPB_ADDR) | M_ADR_SG_LINK);
	vs_write(4, iopb + IOPB_BUFF,
	    sc->sc_sgmap->dm_segs[0].ds_addr + sgoffs);
	vs_write(4, iopb + IOPB_LENGTH, cb->cb_dmamap->dm_nsegs);
	vs_write(4, iopb + IOPB_SGTTL, cb->cb_dmalen);
}
@


1.37
log
@add a missing argument to a debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.36 2014/01/18 04:11:07 dlg Exp $ */
@


1.36
log
@if the controller is too busy to do a POLLed command, return XS_BUSY
instead of XS_NO_CCB.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.35 2010/12/23 20:25:15 miod Exp $ */
d599 1
a599 1
	printf("%s: target %d\n", slp->target);
@


1.35
log
@Better malloc the right size, overruns are so 200x... Pass the brown paper
bag, please.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.34 2010/11/18 21:13:19 miod Exp $ */
d440 1
a440 1
			xs->error = XS_NO_CCB;
@


1.34
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.33 2010/06/28 18:31:01 krw Exp $ */
d813 1
a813 1
			 * We can't drive the daugther board if there is not
d943 1
a943 1
	sglen = sc->sc_nwq * MAX_SG_ELEMENTS * sizeof(struct vs_sg_entry);
d997 1
a997 1
	sc->sc_cb = malloc(sc->sc_nwq * sizeof(struct vs_cb), M_DEVBUF,
@


1.33
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.32 2010/05/20 00:55:17 krw Exp $ */
a47 1
#include <sys/dkstat.h>
@


1.32
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.31 2010/03/23 01:57:19 krw Exp $ */
a75 7
struct scsi_device vs_scsidev = {
	NULL,		/* use default error handler */
	NULL,		/* do not have a start function */
	NULL,		/* have no async handler */
	NULL,		/* Use default done routine */
};

a227 1
		sc_link->device = &vs_scsidev;
@


1.31
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.30 2010/01/09 23:15:06 krw Exp $ */
a449 1
			s = splbio();
a450 1
			splx(s);
a464 1
			s = splbio();
a465 1
			splx(s);
a473 1
			s = splbio();
a474 1
			splx(s);
@


1.30
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.29 2009/11/22 14:14:10 krw Exp $ */
d67 1
a67 1
int	vs_scsicmd(struct scsi_xfer *);
d107 1
a107 1
int	vs_poll(struct vs_softc *, struct vs_cb *);
d330 1
a330 1
int
a357 1
	return (COMPLETE);
d420 1
a420 1
int
d449 5
a453 1
			return (NO_CCB);
d466 4
a469 1
			return (NO_CCB);
d477 4
a480 1
			return (NO_CCB);
d496 1
a496 1
		return (COMPLETE);
d513 1
a513 1
		return vs_poll(sc, cb);
a514 2

	return (SUCCESSFULLY_QUEUED);
@


1.29
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.28 2009/02/17 22:28:41 miod Exp $ */
a343 1
		xs->flags |= ITSDONE;
a416 1
	xs->flags |= ITSDONE;
a1242 1
		xs->flags |= ITSDONE;
@


1.28
log
@Add real bus_space and bus_dma to mvme68k, so that it can benefit from
recent driver work; this gives us better osiop and vs drivers, vsbic
(although currently disabled on 68060 boards until more bugs are fixed),
and the ability to boot and root off vs and vsbic.

Existing code is not modified and still uses memory mapped structures;
this might change eventually as more code gets factorized and moved to
MI land.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.27 2009/02/16 21:19:06 miod Exp $ */
d452 1
a452 1
			return (TRY_AGAIN_LATER);
d465 1
a465 1
			return (TRY_AGAIN_LATER);
d473 1
a473 1
			return (TRY_AGAIN_LATER);
@


1.27
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.26 2008/11/25 17:52:02 krw Exp $ */
d4 1
d38 1
a38 1
 * MVME328 scsi adaptor driver
d41 3
d52 2
d58 115
a172 1
#include <machine/param.h>
d174 5
a178 1
#include <uvm/uvm_param.h>
d180 13
a192 4
#ifdef mvme88k
#include <mvme88k/dev/vsreg.h>
#include <mvme88k/dev/vsvar.h>
#include <machine/mmu.h>
d194 21
a214 2
#include <mvme68k/dev/vsreg.h>
#include <mvme68k/dev/vsvar.h>
d217 42
a258 29
void scopy(void *, void *, u_int);
void szero(void *, u_int);
int do_vspoll(struct vs_softc *, int, int);
void thaw_queue(struct vs_softc *, u_int8_t);
int  vs_checkintr(struct vs_softc *, struct scsi_xfer *, int *);
void vs_chksense(struct scsi_xfer *);
void vs_reset(struct vs_softc *);
void vs_resync(struct vs_softc *);
void vs_initialize(struct vs_softc *);
void vs_intr(void *);
int  vs_poll(struct vs_softc *, struct scsi_xfer *);
void vs_scsidone(struct scsi_xfer *, int);
M328_CQE  *vs_getcqe(struct vs_softc *);
M328_IOPB *vs_getiopb(struct vs_softc *);
void vs_link_sg_element(sg_list_element_t *, vaddr_t, int);
void vs_link_sg_list(sg_list_element_t *, vaddr_t, int);

/* 
 * 16 bit 's' memory functions.  MVME328 is a D16 board.
 * We must program with that in mind or else...
 * bcopy/bzero (the 'b' meaning byte) is implemented in 
 * 32 bit operations for speed, so thay are not really 
 * 'byte' operations at all!!  MVME1x7 can be set up to 
 * handle D32 -> D16 read/writes via VMEChip2 Address 
 * modifiers, however MVME188 can not.  These next two
 * functions insure 16 bit copy/zero operations.  The 
 * structures are all implemented with 16 bit or less
 * types.   smurph
 */
d260 2
a261 10
void
scopy(src, dst, cnt)
	void *src, *dst;
	u_int cnt;
{ 
	u_int16_t volatile *x, *y, z; 

	z = cnt >> 1; 
	x = (u_int16_t *) src; 
	y = (u_int16_t *) dst; 
d263 2
a264 2
	while (z--) {
		*y++ = *x++; 
d266 3
d272 1
a272 3
szero(src, cnt)
	void *src;
	u_int cnt;
d274 4
a277 3
	u_int16_t *source;
	u_int16_t zero = 0;
	u_int16_t z; 
d279 12
a290 5
	source = (u_int16_t *) src;
	z = cnt >> 1; 

	while (z--) {
		*source++ = zero;
d295 2
a296 2
do_vspoll(sc, to, canreset)
	struct vs_softc *sc;
d298 11
a308 3
	int canreset;
{
	int i;
d310 8
a317 20
	if (to <= 0 ) to = 50000;
	/* use cmd_wait values? */
	i = 50000;
	/*spl0();*/
	while (!(CRSW & (M_CRSW_CRBV | M_CRSW_CC))) {
		if (--i <= 0) {
#ifdef DEBUG
			printf ("waiting: timeout %d crsw 0x%x\n", to, CRSW);
#endif
			i = 50000;
			--to;
			if (to <= 0) {
				/*splx(s);*/
				if (canreset) {
					vs_reset(sc);
					vs_resync(sc);
				}
				printf ("timed out: timeout %d crsw 0x%x\n",
				    to, CRSW);
				return 1;
d319 1
d321 1
d323 4
d331 2
a332 2
vs_poll(sc, xs)
	struct vs_softc *sc;
d334 23
a356 3
{
	int status;
	int to;
d358 1
a358 12
	/*s = splbio();*/
	to = xs->timeout / 1000;
	for (;;) {
		if (do_vspoll(sc, to, 1)) break;
		if (vs_checkintr(sc, xs, &status)) {
			vs_scsidone(xs, status);
		}
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER(CRSW);
		CRB_CLR_DONE(CRSW);
		if (xs->flags & ITSDONE) break;
	}
d363 4
a366 8
thaw_queue(sc, target)
	struct vs_softc *sc;
	u_int8_t target;
{
	u_short t;
	t = target << 8;
	t |= 0x0001;
	THAW_REG = t;
d368 11
a378 1
	while (THAW_REG & 0x01);
d381 2
a382 4
void 
vs_scsidone (xs, stat)
	struct scsi_xfer *xs;
	int stat;                             
d384 29
a412 3
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
a413 1
	xs->status = stat;
d415 1
a415 2
		vs_chksense(xs);
		thaw_queue(sc, slp->target + 1);
d417 1
d419 1
a419 6
	/*sc->sc_tinfo[slp->target].cmds++;*/
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
	thaw_queue(sc, slp->target + 1);
	szero(riopb, sizeof(M328_IOPB));
d424 1
a424 2
vs_scsicmd(xs)
	struct scsi_xfer *xs;
d429 4
a432 16
	unsigned long buf, len;
	u_short iopb_len;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	M328_CQE *cqep;
	M328_IOPB *iopb;
	M328_CMD *m328_cmd;

	/* If the target doesn't exist, abort */
	if (!sc->sc_tinfo[slp->target].avail) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		xs->flags |= ITSDONE;
		scsi_done(xs);
	}
a434 34
#ifdef SDEBUG
	printf("scsi_cmd() ");
	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}
#endif 
d436 20
a455 2
		cqep = mc;
		iopb = miopb;
d457 19
a475 21
		cqep = vs_getcqe(sc);
		if (cqep == NULL) {
			return (NO_CCB);
		}
		iopb = vs_getiopb(sc);
	}

	/* s = splbio();*/
	iopb_len = sizeof(M328_short_IOPB) + xs->cmdlen;
	szero(iopb, sizeof(M328_IOPB));

	scopy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
	iopb->iopb_CMD = IOPB_SCSI;
#if 0
	LV(iopb->iopb_BUFF, kvtop(xs->data));
	LV(iopb->iopb_LENGTH, xs->datalen);
#endif   
	iopb->iopb_UNIT = slp->lun << 3;
	iopb->iopb_UNIT |= slp->target;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;
d477 13
a489 17
	/*
	 * Since the 88k's don't support cache snooping, we have
	 * to flush the cache for a write and flush with inval for
	 * a read, prior to starting the IO.
	 */
	if (xs->flags & SCSI_DATA_IN) {  /* read */
#if defined(mvme88k)
		dma_cachectl(xs->data, xs->datalen,
		    DMA_CACHE_SYNC_INVAL);
#endif      
		iopb->iopb_OPTION |= OPT_READ;
	} else {                         /* write */
#if defined(mvme88k)
		dma_cachectl(xs->data, xs->datalen,
		    DMA_CACHE_SYNC);
#endif      
		iopb->iopb_OPTION |= OPT_WRITE;
d492 12
d505 2
a506 5
		iopb->iopb_OPTION |= OPT_INTDIS;
		iopb->iopb_LEVEL = 0;
	} else {
		iopb->iopb_OPTION |= OPT_INTEN;
		iopb->iopb_LEVEL = sc->sc_ipl;
d508 12
a519 1
	iopb->iopb_ADDR = ADDR_MOD;
d522 3
a524 3
	 * Wait until we can use the command queue entry.
	 * Should only have to wait if the master command 
	 * queue entry is busy.
d526 52
a577 1
	while (cqep->cqe_QECR & M_QECR_GO);
a578 2
	cqep->cqe_IOPB_ADDR = OFF(iopb);
	cqep->cqe_IOPB_LENGTH = iopb_len;
d580 2
a581 10
		cqep->cqe_WORK_QUEUE = slp->target + 1;
	} else {
		cqep->cqe_WORK_QUEUE = slp->target + 1;
	}
   
	m328_cmd = (M328_CMD*)malloc(sizeof(M328_CMD), M_DEVBUF, M_WAITOK);
   
	m328_cmd->xs = xs;
	if (xs->datalen) {
		m328_cmd->top_sg_list = vs_build_memory_structure(xs, iopb);
d583 2
a584 1
		m328_cmd->top_sg_list = (M328_SG)0;
d586 1
d588 2
a589 1
	LV(cqep->cqe_CTAG, m328_cmd);
d591 4
a594 10
	if (crb->crb_CRSW & M_CRSW_AQ) {
		cqep->cqe_QECR = M_QECR_AA;
	}
	VL(buf, iopb->iopb_BUFF);
	VL(len, iopb->iopb_LENGTH);
#ifdef SDEBUG
	printf("tgt %d lun %d buf %x len %d wqn %d ipl %d\n", slp->target, 
	    slp->lun, buf, len, cqep->cqe_WORK_QUEUE, iopb->iopb_LEVEL);
#endif 
	cqep->cqe_QECR |= M_QECR_GO;
d596 1
a596 8
	if (flags & SCSI_POLL) {
		/* poll for the command to complete */
		/*splx(s);*/
		vs_poll(sc, xs);
		return (COMPLETE);
	}
	/*splx(s);*/
	return (SUCCESSFULLY_QUEUED);
d600 1
a600 2
vs_chksense(xs)
	struct scsi_xfer *xs;
a601 1
	int s;
d604 3
a606 4
	struct scsi_sense *ss;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
d608 3
d612 3
a614 2
	CRB_CLR_DONE(CRSW);
	CRB_CLR_ER(CRSW);
d617 28
a644 23
	szero(miopb, sizeof(M328_IOPB));
	/* This is a command, so point to it */
	ss = (void *)&miopb->iopb_SCSI[0];
	szero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = slp->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);

	miopb->iopb_CMD = IOPB_SCSI;
	miopb->iopb_OPTION = OPT_READ;
	miopb->iopb_NVCT = (u_char)sc->sc_nvec;
	miopb->iopb_EVCT = (u_char)sc->sc_evec;
	miopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	miopb->iopb_ADDR = ADDR_MOD;
	LV(miopb->iopb_BUFF, kvtop((vaddr_t)&xs->sense));
	LV(miopb->iopb_LENGTH, sizeof(struct scsi_sense_data));

	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(miopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) +
	    sizeof(struct scsi_sense);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
d647 2
a648 10
	do_vspoll(sc, 0, 1);
	/*
	if (xs->cmd->opcode != PREVENT_ALLOW) {
		xs->error = XS_SENSE;
	}
	*/
	xs->status = riopb->iopb_STATUS >> 8;
#ifdef SDEBUG
	scsi_print_sense(xs);
#endif   
d652 2
a653 3
M328_CQE *
vs_getcqe(sc)
	struct vs_softc *sc;
d655 2
a656 2
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_CQE *cqep;
d658 17
a674 8
	cqep = (M328_CQE *)&sc->sc_vsreg->sh_CQE[mcsb->mcsb_QHDP];

	if (cqep->cqe_QECR & M_QECR_GO)
		return NULL; /* Hopefully, this will never happen */
	mcsb->mcsb_QHDP++;
	if (mcsb->mcsb_QHDP == NUM_CQE) mcsb->mcsb_QHDP = 0;
	szero(cqep, sizeof(M328_CQE));
	return cqep;
d677 2
a678 3
M328_IOPB *
vs_getiopb(sc)
	struct vs_softc *sc;
d680 2
a681 3
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	int slot;
d683 24
a706 4
	if (mcsb->mcsb_QHDP == 0) {
		slot = NUM_CQE - 1;
	} else {
		slot = mcsb->mcsb_QHDP - 1;
d708 2
a709 3
	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_IOPB[slot];
	szero(iopb, sizeof(M328_IOPB));
	return iopb;
d712 2
a713 3
void
vs_initialize(sc)
	struct vs_softc *sc;
d715 160
a874 52
	M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	M328_WQCF *wiopb = (M328_WQCF *)&sc->sc_vsreg->sh_MCE_IOPB;
	u_short i, crsw;
	int failed = 0;

	CRB_CLR_DONE(CRSW);
	szero(cib, sizeof(M328_CIB));
	mcsb->mcsb_QHDP = 0;
	sc->sc_qhp = 0;
	cib->cib_NCQE = 10;
	cib->cib_BURST = 0;
	cib->cib_NVECT = sc->sc_ipl << 8;
	cib->cib_NVECT |= sc->sc_nvec;
	cib->cib_EVECT = sc->sc_ipl << 8;
	cib->cib_EVECT |= sc->sc_evec;
	cib->cib_PID = 0x07;
	cib->cib_SID = 0x00;
	cib->cib_CRBO = OFF(crb);
	cib->cib_SELECT_msw = HI(SELECTION_TIMEOUT);
	cib->cib_SELECT_lsw = LO(SELECTION_TIMEOUT);
	cib->cib_WQ0TIMO_msw = HI(4);
	cib->cib_WQ0TIMO_lsw = LO(4);
	cib->cib_VMETIMO_msw = 0; /*HI(VME_BUS_TIMEOUT);*/
	cib->cib_VMETIMO_lsw = 0; /*LO(VME_BUS_TIMEOUT);*/
	cib->cib_SBRIV = sc->sc_ipl << 8;
	cib->cib_SBRIV |= sc->sc_evec;
	cib->cib_SOF0 = 0x15;
	cib->cib_SRATE0 = 100/4;
	cib->cib_SOF1 = 0x0;
	cib->cib_SRATE1 = 0x0;

	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	szero(iopb, sizeof(M328_IOPB));
	iopb->iopb_CMD = CNTR_INIT;
	iopb->iopb_OPTION = 0;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;
	iopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	iopb->iopb_ADDR = SHIO_MOD;
	LV(iopb->iopb_BUFF, OFF(cib));
	LV(iopb->iopb_LENGTH, sizeof(M328_CIB));

	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(iopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
d876 7
a882 2
	do_vspoll(sc, 0, 1);
	CRB_CLR_DONE(CRSW);
d885 32
a916 17
	for (i=1; i<8; i++) {
		szero(wiopb, sizeof(M328_IOPB));
		wiopb->wqcf_CMD = CNTR_INIT_WORKQ;
		wiopb->wqcf_OPTION = 0;
		wiopb->wqcf_NVCT = (u_char)sc->sc_nvec;
		wiopb->wqcf_EVCT = (u_char)sc->sc_evec;
		wiopb->wqcf_ILVL = 0; /*sc->sc_ipl;*/
		wiopb->wqcf_WORKQ = i;
		wiopb->wqcf_WOPT = (WQO_FOE | WQO_INIT);
		wiopb->wqcf_SLOTS = JAGUAR_MAX_Q_SIZ;
		LV(wiopb->wqcf_CMDTO, 2);

		szero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(wiopb);
		mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
d918 1
a918 1
		do_vspoll(sc, 0, 1);
d920 4
a923 4
			/*printf("\nerror: queue %d status = 0x%x\n",
			    i, riopb->iopb_STATUS);*/
			/*failed = 1;*/
			CRB_CLR_ER(CRSW);
d925 1
a925 2
		CRB_CLR_DONE(CRSW);
		delay(500);
d927 1
d929 54
a982 7
	CRSW = 0;
	mcsb->mcsb_MCR |= M_MCR_SQM;
	crsw = CRSW;
	do_vspoll(sc, 0, 1);
	if (CRSW & M_CRSW_ER) {
		printf("error: status = 0x%x\n", riopb->iopb_STATUS);
		CRB_CLR_ER(CRSW);
a983 1
	CRB_CLR_DONE(CRSW);
d985 50
a1034 3
	if (failed) {
		printf(": failed!\n");
		return;
d1036 4
a1039 5
	/* reset SCSI bus */
	vs_reset(sc);
	/* sync all devices */
	vs_resync(sc);
	printf("\n");
d1043 1
a1043 2
vs_resync(sc)
	struct vs_softc *sc;
d1045 36
a1080 28
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
	u_short i;

	for (i=0; i<7; i++) {
		szero(devreset, sizeof(M328_DRCF));
		devreset->drcf_CMD = CNTR_DEV_REINIT;
		devreset->drcf_OPTION = 0x00;       /* no interrupts yet... */
		devreset->drcf_NVCT = sc->sc_nvec;
		devreset->drcf_EVCT = sc->sc_evec;
		devreset->drcf_ILVL = 0;
		devreset->drcf_UNIT = i;

		szero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(devreset);
		mc->cqe_IOPB_LENGTH = sizeof(M328_DRCF);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
		/* poll for the command to complete */
		do_vspoll(sc, 0, 0);
		if (riopb->iopb_STATUS) {
			sc->sc_tinfo[i].avail = 0;
		} else {
			sc->sc_tinfo[i].avail = 1;
		}
		if (CRSW & M_CRSW_ER) {
			CRB_CLR_ER(CRSW);
a1081 1
		CRB_CLR_DONE(CRSW);
d1086 1
a1086 2
vs_reset(sc)
	struct vs_softc *sc;
d1088 2
a1089 12
	u_int s;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  

	szero(reset, sizeof(M328_SRCF));
	reset->srcf_CMD = IOPB_RESET;
	reset->srcf_OPTION = 0x00;       /* no interrupts yet... */
	reset->srcf_NVCT = sc->sc_nvec;
	reset->srcf_EVCT = sc->sc_evec;
	reset->srcf_ILVL = 0;
	reset->srcf_BUSID = 0;
d1092 32
a1123 14
	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(reset);
	mc->cqe_IOPB_LENGTH = sizeof(M328_SRCF);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	for (;;) {
		do_vspoll(sc, 0, 0);
		/* ack & clear scsi error condition cause by reset */
		if (CRSW & M_CRSW_ER) {
			CRB_CLR_ER(CRSW);
			CRB_CLR_DONE(CRSW);
			riopb->iopb_STATUS = 0;
			break;
a1124 1
		CRB_CLR_DONE(CRSW);
d1126 3
a1128 2
	/* thaw all work queues */
	thaw_queue(sc, 0xFF);
d1132 8
a1139 5
/*
 * Process an interrupt from the MVME328
 * We'll generally update: xs->{flags,resid,error,sense,status} and
 * occasionally xs->retries.
 */
d1141 1
d1143 1
a1143 4
vs_checkintr(sc, xs, status)
	struct vs_softc *sc;
	struct scsi_xfer *xs;
	int *status;
d1145 24
a1168 77
	int target = -1;
	int lun = -1;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	struct scsi_generic *cmd;
	u_long buf;
	u_long len;
	u_char error;

	target = xs->sc_link->target;
	lun = xs->sc_link->lun;
	cmd = (struct scsi_generic *)&riopb->iopb_SCSI[0];

	VL(buf, riopb->iopb_BUFF);
	VL(len, riopb->iopb_LENGTH);
	*status = riopb->iopb_STATUS >> 8;
	error = riopb->iopb_STATUS & 0xFF;

#ifdef SDEBUG
	printf("scsi_chk() ");

	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}

	printf("tgt %d lun %d buf %x len %d status %x ",
	    target, lun, buf, len, riopb->iopb_STATUS);

	if (CRSW & M_CRSW_EX) {
		printf("[ex]");
	}
	if (CRSW & M_CRSW_QMS) {
		printf("[qms]");
	}
	if (CRSW & M_CRSW_SC) {
		printf("[sc]");
	}
	if (CRSW & M_CRSW_SE) {
		printf("[se]");
	}
	if (CRSW & M_CRSW_AQ) {
		printf("[aq]");
	}
	if (CRSW & M_CRSW_ER) {
		printf("[er]");
	}
	printf("\n");
#endif   
	if (len != xs->datalen) {
		xs->resid = xs->datalen - len;
d1170 4
a1173 1
		xs->resid = 0;
d1176 8
a1183 5
	if (error == SCSI_SELECTION_TO) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		*status = -1;
	}
d1187 3
a1189 3
void
vs_intr(arg)
	void *arg;
d1191 2
a1192 2
	struct vs_softc *sc = (struct vs_softc *)arg;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
d1194 1
a1194 3
	M328_CMD *m328_cmd;
	unsigned long loc;
	int status;
d1197 1
a1198 1
	/* Got a valid interrupt on this device */
d1200 39
a1238 22
	VL(loc, crb->crb_CTAG);
#ifdef SDEBUG
	printf("Interrupt!!! ");
	printf("loc == 0x%x\n", loc);
#endif 
	/*
	 * If this is a controller error, there won't be a m328_cmd
	 * pointer in the CTAG field.  Bad things happen if you try 
	 * to point to address 0.  Controller error should be handled
	 * in vsdma.c  I'll change this soon - steve.
	 */
	if (loc) {
		m328_cmd = (M328_CMD *)loc;
		xs = m328_cmd->xs;
		if (m328_cmd->top_sg_list) {
			vs_dealloc_scatter_gather(m328_cmd->top_sg_list);
			m328_cmd->top_sg_list = (M328_SG)0;
		}
      
		free(m328_cmd, M_DEVBUF); /* free the command tag */
		if (vs_checkintr (sc, xs, &status)) {
			vs_scsidone(xs, status);
d1241 14
d1256 8
d1267 3
a1269 1
 * Useful functions for scatter/gather list
d1271 5
d1277 10
a1286 4
M328_SG
vs_alloc_scatter_gather()
{
	M328_SG sg;
d1288 2
a1289 1
	sg = malloc(sizeof(struct m328_sg), M_DEVBUF, M_WAITOK | M_ZERO);
d1291 1
a1291 1
	return (sg);
d1294 5
a1298 3
void
vs_dealloc_scatter_gather(sg)
	M328_SG sg;
d1300 4
a1303 1
	int i;
d1305 8
a1312 4
	if (sg->level > 0) {
		for (i = 0; sg->down[i] && i<MAX_SG_ELEMENTS; i++) {
			vs_dealloc_scatter_gather(sg->down[i]);
		}
a1313 9
	free(sg, M_DEVBUF);
}

void
vs_link_sg_element(element, phys_add, len)
	sg_list_element_t *element;
	vaddr_t phys_add;
	int len;
{
d1315 1
a1315 6
	element->count.bytes = len;
	LV(element->address, phys_add);
	element->link = 0; /* FALSE */
	element->transfer_type = NORMAL_TYPE;
	element->memory_type = LONG_TRANSFER;
	element->address_modifier = 0xD;
d1318 4
d1323 1
a1323 18
vs_link_sg_list(list, phys_add, elements)
	sg_list_element_t *list;
	vaddr_t phys_add;
	int elements;
{

	list->count.scatter.gather  = elements;
	LV(list->address, phys_add);
	list->link = 1;    /* TRUE */
	list->transfer_type = NORMAL_TYPE;
	list->memory_type = LONG_TRANSFER;
	list->address_modifier = 0xD;
}

M328_SG 
vs_build_memory_structure(xs, iopb)
	struct scsi_xfer *xs;
	M328_IOPB  *iopb;              /* the iopb */
d1325 5
a1329 7
	M328_SG   sg;
	vaddr_t starting_point_virt, point_virt, virt;
	paddr_t starting_point_phys, point1_phys, point2_phys;
	u_int len;
	int level;

	sg = (M328_SG)0;   /* Hopefully we need no scatter/gather list */
d1332 2
a1333 15
	 * We have the following things:
	 * virt			the virtual address of the contiguous virtual
	 *			memory block
	 * len			the length of the contiguous virtual memory
	 *			block
	 * starting_point_virt	the virtual address of the contiguous
	 *			*physical* memory block
	 * starting_point_phys	the *physical* address of the contiguous
	 *			*physical* memory block
	 * point_virt		the pointer to the virtual memory we are
	 *			checking at the moment
	 * point1_phys		the pointer to the *physical* memory we are
	 *			checking at the moment
	 * point2_phys		the pointer to the *physical* memory we are
	 *			checking at the moment
d1335 4
a1338 106
   
	level = 0;
	virt = starting_point_virt = (vaddr_t)xs->data;
	point1_phys = starting_point_phys = kvtop((vaddr_t)xs->data);
	len = xs->datalen;

	/*
	 * Check if we need scatter/gather
	*/
	if (len > PAGE_SIZE) {
		for (level = 0, point_virt = round_page(starting_point_virt+1);
			/* if we do already scatter/gather we have to stay in
			   the loop and jump */
		    point_virt < virt + (vaddr_t)len || sg;
		    point_virt += PAGE_SIZE) {	/* out later */

			point2_phys = kvtop(point_virt);

			if ((point2_phys - trunc_page(point1_phys) - PAGE_SIZE) ||
			    /* physical memory is not contiguous */
			    (point_virt - starting_point_virt >=
			    MAX_SG_BLOCK_SIZE && sg)) {
				/* we only can access (1<<16)-1 bytes in
				   scatter/gather_mode */
				if (point_virt - starting_point_virt >=
				    MAX_SG_BLOCK_SIZE) {
					/* We were walking too far for one
					   scatter/gather block ... */
					assert( MAX_SG_BLOCK_SIZE > PAGE_SIZE );
					point_virt =
					    trunc_page(starting_point_virt +
						MAX_SG_BLOCK_SIZE-1);
					/* So go back to the beginning of the
					   last matching page and generate the
					   physical address of this location
					   for the next time. */
					point2_phys = kvtop(point_virt);
				}

				if (!sg) {
					/* We allocate our fist scatter/gather
					   list */
					sg = vs_alloc_scatter_gather();
				}
#if 1 /* broken firmware */
				if (sg->elements >= MAX_SG_ELEMENTS) {
					vs_dealloc_scatter_gather(sg);
					return (NULL);
				}
#else /* if the firmware will ever get fixed */
				while (sg->elements >= MAX_SG_ELEMENTS) {
					/* If the list full in this layer ? */
					if (!sg->up) {
						sg->up =
						    vs_alloc_scatter_gather();
						sg->up->level = sg->level+1;
						sg->up->down[0] = sg;
						sg->up->elements = 1;
					}
					/* link this full list also in physical
					   memory */
					vs_link_sg_list(
					    &(sg->up->list[
						sg->up->elements - 1]), 
					    kvtop((vaddr_t)sg->list),
					    sg->elements);
					sg = sg->up;      /* Climb up */
				}
				/* As long as we are not a the base level */
				while (sg->level) { 
					int i;

					i = sg->elements;
					/* We need a new element */
					sg->down[i] =
					    vs_alloc_scatter_gather();  
					sg->down[i]->level = sg->level - 1;
					sg->down[i]->up = sg;
					sg->elements++;
					sg = sg->down[i]; /* Climb down */
				}
#endif /* 1 */

				if (point_virt < virt+(vaddr_t)len) {
					/* linking element */
					vs_link_sg_element(
					    &(sg->list[sg->elements]), 
					    starting_point_phys, 
					    point_virt-starting_point_virt);
					sg->elements++;
				} else {
					/* linking last element */
					vs_link_sg_element(
					    &(sg->list[sg->elements]), 
					    starting_point_phys, 
					    (vaddr_t)(virt + len) -
					        starting_point_virt);
					sg->elements++;
					break;
					/* We have now collected all blocks */
				}
				starting_point_virt = point_virt;
				starting_point_phys = point2_phys;
			}
			point1_phys = point2_phys;
		}
d1342 1
a1342 1
	 * Climb up along the right side of the tree until we reach the top.
d1345 30
a1374 19
	if (sg) {
		while (sg->up) {
			/* link this list also in physical memory */
			vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
			    kvtop((vaddr_t)sg->list), sg->elements);
			sg = sg->up;                   /* Climb up */
		}

		iopb->iopb_OPTION |= M_OPT_SG;
		iopb->iopb_ADDR |= M_ADR_SG_LINK;
		LV(iopb->iopb_BUFF, kvtop((vaddr_t)sg->list));
		LV(iopb->iopb_LENGTH, sg->elements);
		LV(iopb->iopb_SGTTL, len);
	} else { 
		/* no scatter/gather necessary */
		LV(iopb->iopb_BUFF, starting_point_phys);
		LV(iopb->iopb_LENGTH, len);
	}
	return (sg);
@


1.26
log
@Another bunch of TRY_AGAIN_LATER -> NO_CCB when no I/O could be started.

"looks sane to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.25 2008/07/30 18:08:03 miod Exp $ */
a125 13
}

/*
 * default minphys routine for MVME328 based controllers
 */
void
vs_minphys(bp)
	struct buf *bp;
{
	/*
	 * No max transfer at this level.
	 */
	minphys(bp);
@


1.25
log
@Do not print adapter target id on the attachment line, now that scsibus(4)
prints it. These should be the last offenders.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.24 2008/06/22 15:18:23 miod Exp $ */
d300 1
a300 1
			return (TRY_AGAIN_LATER);
@


1.24
log
@One last forgotten FREE().
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.23 2008/05/19 18:42:12 miod Exp $ */
d593 1
a593 1
	printf(": target %d\n", sc->sc_link.adapter_target);
@


1.23
log
@Change all remaining MD uses of MALLOC and FREE into proper malloc() and
free() calls; prodded by chl@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.22 2007/10/06 02:18:38 krw Exp $ */
d808 1
a808 1
		FREE(m328_cmd, M_DEVBUF); /* free the command tag */
@


1.22
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.21 2007/10/03 10:52:11 krw Exp $ */
d363 1
a363 1
	MALLOC(m328_cmd, M328_CMD*, sizeof(M328_CMD), M_DEVBUF, M_WAITOK);
@


1.21
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.20 2006/06/02 18:53:56 miod Exp $ */
d841 1
a841 1
	FREE(sg, M_DEVBUF);
@


1.20
log
@feild -> field
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.19 2005/12/03 18:09:37 krw Exp $ */
d825 1
a825 2
	MALLOC(sg, M328_SG, sizeof(struct m328_sg), M_DEVBUF, M_WAITOK);
	bzero(sg, sizeof(struct m328_sg));
@


1.19
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.18 2004/07/30 22:29:45 miod Exp $ */
d796 1
a796 1
	 * pointer in the CTAG feild.  Bad things happen if you try 
@


1.18
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.17 2004/07/30 09:50:15 miod Exp $ */
a299 1
			xs->error = XS_DRIVER_STUFFUP;
@


1.17
log
@Switch mvme68k to evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.16 2004/05/20 16:43:51 miod Exp $ */
a46 1
#include <sys/evcount.h>
@


1.16
log
@Fix arithmetic in vs_getiopb(), from mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.15 2004/05/09 05:34:00 krw Exp $ */
d47 1
@


1.15
log
@Eliminate verbosity parameter to scsi_print_sense and the associated
chunk of code. It was never executed unless you were debugging a
mvmex8k 'vs' device.

ok miod@@ (mvmex8k bits) marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.14 2004/01/20 16:48:23 miod Exp $ */
d299 4
a304 4
	if (cqep == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
	}
d477 1
a477 1
		slot = NUM_CQE;
@


1.14
log
@In some situations, the MVME328S can be so hung that our current reset code
fails. Unfortunately, in this case, do_vspoll() would invoke the reset
function ad nauseum.

Allow the flow to exit this infernal loop, attach() will correctly fail.

This is temporary band-aid until a stronger reset sequence is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.13 2004/01/14 02:00:41 krw Exp $ */
d446 1
a446 1
	scsi_print_sense(xs, 2);
@


1.13
log
@Nuke SDEV_NOLUNS, SDEV_FORCELUNS, and PQUIRK_FORCELUNS quirks. Also
moreluns field in scsi_link structure.  Instead, treat an INQUIRY
result that duplicates the INQUIRY result of LUN 0 as proof the LUN
does not exist.  Compensate for lack of SDEV_NOLUNS where necessary by
setting sc_link->luns to 1, which has the same effect. From Marco
Peereboom.

Don't issue Test Unit Ready command before INQUIRY command - not
necessary and potentially harmful to devices with ADEV_NOTUR quirk
since quirks have not been set yet. From mycroft@@NetBSD

ok deraadt@@, mvme* changes by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.12 2003/11/07 10:16:45 jmc Exp $ */
d67 1
a67 1
int do_vspoll(struct vs_softc *, int);
d142 1
a142 1
do_vspoll(sc, to)
d145 1
d162 4
a165 2
				vs_reset(sc);
				vs_resync(sc);
d186 1
a186 1
		if (do_vspoll(sc, to)) break;
d438 1
a438 1
	do_vspoll(sc, 0);
d543 1
a543 1
	do_vspoll(sc, 0);
d565 1
a565 1
		do_vspoll(sc, 0);
d579 1
a579 1
	do_vspoll(sc, 0);
d621 1
a621 1
		do_vspoll(sc, 0);
d659 1
a659 1
		do_vspoll(sc, 0);
@


1.12
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.11 2003/11/03 06:54:25 david Exp $ */
a255 1
	slp->quirks |= SDEV_NOLUNS;
@


1.11
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.10 2003/06/02 23:27:50 millert Exp $ */
d937 3
a939 3
					   last matching page and gererate the
					   physadress of this location for the
					   next time. */
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.9 2002/12/14 07:20:25 fgsch Exp $ */
d1030 1
a1030 1
		/* no scatter/gather neccessary */
@


1.9
log
@handeled -> handled; reported by someone on the list, but i no longer
have the mail.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.7 2002/03/14 01:26:37 millert Exp $ */
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d800 1
a800 1
	 * to point to address 0.  Controller error should be handeled
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.6 2001/11/06 00:30:38 art Exp $ */
d69 4
d74 1
a74 1
int  vs_chksense(struct scsi_xfer *);
d78 1
a78 1
int  vs_intr(struct vs_softc *);
d81 4
a84 2
M328_CQE  * vs_getcqe(struct vs_softc *);
M328_IOPB * vs_getiopb(struct vs_softc *);
a85 1
extern u_int   kvtop();
d100 3
a102 1
scopy(void *src, void *dst, unsigned short cnt) 
d104 1
a104 1
   register unsigned short volatile *x, *y, z; 
d106 7
a112 7
   z = cnt >> 1; 
   x = (unsigned short *) src; 
   y = (unsigned short *) dst; 

   while (z--) {
      *y++ = *x++; 
   }
d116 3
a118 1
szero(void *src, u_long cnt)
d120 10
a129 11
   register unsigned short *source;
   register unsigned short zero = 0;
   register unsigned short z; 

   source = (unsigned short *) src;
   z = cnt >> 1; 

   while (z--) {
      *source++ = zero;
   }
   return;
a131 4




d137 1
a137 1
struct buf *bp;
d139 19
a157 17
   /*
    * No max transfer at this level.
    */
   minphys(bp);
}

int do_vspoll(sc, to)
struct vs_softc *sc;
int to;
{
   int i;
   if (to <= 0 ) to = 50000;
   /* use cmd_wait values? */
   i = 50000;
   /*spl0();*/
   while (!(CRSW & (M_CRSW_CRBV | M_CRSW_CC))) {
      if (--i <= 0) {
d159 1
a159 1
         printf ("waiting: timeout %d crsw 0x%x\n", to, CRSW);
d161 13
a173 12
         i = 50000;
         --to;
         if (to <= 0) {
            /*splx(s);*/
            vs_reset(sc);
            vs_resync(sc);
            printf ("timed out: timeout %d crsw 0x%x\n", to, CRSW);
            return 1;
         }
      }
   }
   return 0;
d178 25
a202 2
struct vs_softc *sc;
struct scsi_xfer *xs;
d204 6
a209 38
   M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_CQE *cqep;
   M328_IOPB *iopb;
   int i;
   int status;
   int s;
   int to;

   /*s = splbio();*/
   to = xs->timeout / 1000;
   for (;;) {
      if (do_vspoll(sc, to)) break;
      if (vs_checkintr(sc, xs, &status)) {
         vs_scsidone(xs, status);
      }
      if (CRSW & M_CRSW_ER)
         CRB_CLR_ER(CRSW);
      CRB_CLR_DONE(CRSW);
      if (xs->flags & ITSDONE) break;
   }
   return (COMPLETE);
}

void thaw_queue(sc, target)
struct vs_softc *sc;
u_int8_t target;
{
   u_short t;
   t = target << 8;
   t |= 0x0001;
   THAW_REG = t;
   /* loop until thawed */
   while (THAW_REG & 0x01);
d214 2
a215 2
struct scsi_xfer *xs;
int stat;                             
d217 17
a233 16
   struct scsi_link *slp = xs->sc_link;
   struct vs_softc *sc = slp->adapter_softc;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   xs->status = stat;
   while (xs->status == SCSI_CHECK) {
      vs_chksense(xs);
      thaw_queue(sc, slp->target + 1);
   }
   xs->flags |= ITSDONE;
   /*sc->sc_tinfo[slp->target].cmds++;*/
   if (CRSW & M_CRSW_ER)
      CRB_CLR_ER(CRSW);
   CRB_CLR_DONE(CRSW);
   thaw_queue(sc, slp->target + 1);
   szero(riopb, sizeof(M328_IOPB));
   scsi_done(xs);
d238 1
a238 1
struct scsi_xfer *xs;
d240 19
a258 21
   struct scsi_link *slp = xs->sc_link;
   struct vs_softc *sc = slp->adapter_softc;
   int flags, s, i;
   unsigned long buf, len;
   u_short iopb_len;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_CQE *cqep;
   M328_IOPB *iopb;
   M328_CMD *m328_cmd;

   /* If the target doesn't exist, abort */
   if (!sc->sc_tinfo[slp->target].avail) {
      xs->error = XS_SELTIMEOUT;
      xs->status = -1;
      xs->flags |= ITSDONE;
      scsi_done(xs);
   }
d260 2
a261 2
   slp->quirks |= SDEV_NOLUNS;
   flags = xs->flags;
d263 32
a294 32
   printf("scsi_cmd() ");
   if (xs->cmd->opcode == 0) {
      printf("TEST_UNIT_READY ");
   } else if (xs->cmd->opcode == REQUEST_SENSE) {
      printf("REQUEST_SENSE   ");
   } else if (xs->cmd->opcode == INQUIRY) {
      printf("INQUIRY         ");
   } else if (xs->cmd->opcode == MODE_SELECT) {
      printf("MODE_SELECT     ");
   } else if (xs->cmd->opcode == MODE_SENSE) {
      printf("MODE_SENSE      ");
   } else if (xs->cmd->opcode == START_STOP) {
      printf("START_STOP      ");
   } else if (xs->cmd->opcode == RESERVE) {
      printf("RESERVE         ");
   } else if (xs->cmd->opcode == RELEASE) {
      printf("RELEASE         ");
   } else if (xs->cmd->opcode == PREVENT_ALLOW) {
      printf("PREVENT_ALLOW   ");
   } else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
      printf("POSITION_TO_EL  ");
   } else if (xs->cmd->opcode == CHANGE_DEFINITION) {
      printf("CHANGE_DEF      ");
   } else if (xs->cmd->opcode == MODE_SENSE_BIG) {
      printf("MODE_SENSE_BIG  ");
   } else if (xs->cmd->opcode == MODE_SELECT_BIG) {
      printf("MODE_SELECT_BIG ");
   } else if (xs->cmd->opcode == 0x25) {
      printf("READ_CAPACITY   ");
   } else if (xs->cmd->opcode == 0x08) {
      printf("READ_COMMAND    ");
   }
d296 15
a310 15
   if (flags & SCSI_POLL) {
      cqep = mc;
      iopb = miopb;
   } else {
      cqep = vs_getcqe(sc);
      iopb = vs_getiopb(sc);
   }
   if (cqep == NULL) {
      xs->error = XS_DRIVER_STUFFUP;
      return (TRY_AGAIN_LATER);
   }

/*	s = splbio();*/
   iopb_len = sizeof(M328_short_IOPB) + xs->cmdlen;
   szero(iopb, sizeof(M328_IOPB));
d312 2
a313 2
   scopy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
   iopb->iopb_CMD = IOPB_SCSI;
d315 2
a316 2
   LV(iopb->iopb_BUFF, kvtop(xs->data));
   LV(iopb->iopb_LENGTH, xs->datalen);
d318 11
a328 11
   iopb->iopb_UNIT = slp->lun << 3;
   iopb->iopb_UNIT |= slp->target;
   iopb->iopb_NVCT = (u_char)sc->sc_nvec;
   iopb->iopb_EVCT = (u_char)sc->sc_evec;

   /*
    * Since the 88k's don't support cache snooping, we have
    * to flush the cache for a write and flush with inval for
    * a read, prior to starting the IO.
    */
   if (xs->flags & SCSI_DATA_IN) {  /* read */
d330 2
a331 2
      dma_cachectl((vm_offset_t)xs->data, xs->datalen,
                   DMA_CACHE_SYNC_INVAL);
d333 5
a337 5
      iopb->iopb_OPTION |= OPT_READ;
   } else {                         /* write */
#if defined(MVME187)
      dma_cachectl((vm_offset_t)xs->data, xs->datalen,
                   DMA_CACHE_SYNC);
d339 2
a340 2
      iopb->iopb_OPTION |= OPT_WRITE;
   }
d342 23
a364 23
   if (flags & SCSI_POLL) {
      iopb->iopb_OPTION |= OPT_INTDIS;
      iopb->iopb_LEVEL = 0;
   } else {
      iopb->iopb_OPTION |= OPT_INTEN;
      iopb->iopb_LEVEL = sc->sc_ipl;
   }
   iopb->iopb_ADDR = ADDR_MOD;

   /*
    * Wait until we can use the command queue entry.
    * Should only have to wait if the master command 
    * queue entry is busy.
    */
   while (cqep->cqe_QECR & M_QECR_GO);

   cqep->cqe_IOPB_ADDR = OFF(iopb);
   cqep->cqe_IOPB_LENGTH = iopb_len;
   if (flags & SCSI_POLL) {
      cqep->cqe_WORK_QUEUE = slp->target + 1;
   } else {
      cqep->cqe_WORK_QUEUE = slp->target + 1;
   }
d366 1
a366 1
   MALLOC(m328_cmd, M328_CMD*, sizeof(M328_CMD), M_DEVBUF, M_WAITOK);
d368 14
a381 14
   m328_cmd->xs = xs;
   if (xs->datalen) {
      m328_cmd->top_sg_list = vs_build_memory_structure(xs, iopb);
   } else {
      m328_cmd->top_sg_list = (M328_SG)0;
   }

   LV(cqep->cqe_CTAG, m328_cmd);

   if (crb->crb_CRSW & M_CRSW_AQ) {
      cqep->cqe_QECR = M_QECR_AA;
   }
   VL(buf, iopb->iopb_BUFF);
   VL(len, iopb->iopb_LENGTH);
d383 2
a384 2
   printf("tgt %d lun %d buf %x len %d wqn %d ipl %d\n", slp->target, 
          slp->lun, buf, len, cqep->cqe_WORK_QUEUE, iopb->iopb_LEVEL);
d386 1
a386 1
   cqep->cqe_QECR |= M_QECR_GO;
d388 8
a395 8
   if (flags & SCSI_POLL) {
      /* poll for the command to complete */
/*      splx(s);*/
      vs_poll(sc, xs);
      return (COMPLETE);
   }
/*	splx(s);*/
   return (SUCCESSFULLY_QUEUED);
d398 1
a398 1
int
d400 1
a400 1
struct scsi_xfer *xs;
d402 45
a446 44
   int flags, s, i;
   struct scsi_link *slp = xs->sc_link;
   struct vs_softc *sc = slp->adapter_softc;
   struct scsi_sense *ss;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;

   /* ack and clear the error */
   CRB_CLR_DONE(CRSW);
   CRB_CLR_ER(CRSW);
   xs->status = 0;

   szero(miopb, sizeof(M328_IOPB));
   /* This is a command, so point to it */
   ss = (void *)&miopb->iopb_SCSI[0];
   szero(ss, sizeof(*ss));
   ss->opcode = REQUEST_SENSE;
   ss->byte2 = slp->lun << 5;
   ss->length = sizeof(struct scsi_sense_data);

   miopb->iopb_CMD = IOPB_SCSI;
   miopb->iopb_OPTION = OPT_READ;
   miopb->iopb_NVCT = (u_char)sc->sc_nvec;
   miopb->iopb_EVCT = (u_char)sc->sc_evec;
   miopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
   miopb->iopb_ADDR = ADDR_MOD;
   LV(miopb->iopb_BUFF, kvtop(&xs->sense));
   LV(miopb->iopb_LENGTH, sizeof(struct scsi_sense_data));

   szero(mc, sizeof(M328_CQE));
   mc->cqe_IOPB_ADDR = OFF(miopb);
   mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) + sizeof(struct scsi_sense);
   mc->cqe_WORK_QUEUE = 0;
   mc->cqe_QECR = M_QECR_GO;
   /* poll for the command to complete */
   s = splbio();
   do_vspoll(sc, 0);
   /*
   if (xs->cmd->opcode != PREVENT_ALLOW) {
      xs->error = XS_SENSE;
   }
   */
   xs->status = riopb->iopb_STATUS >> 8;
d448 1
a448 1
   scsi_print_sense(xs, 2);
d450 1
a450 1
   splx(s);
d455 1
a455 1
struct vs_softc *sc;
d457 2
a458 2
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_CQE *cqep;
d460 1
a460 1
   cqep = (M328_CQE *)&sc->sc_vsreg->sh_CQE[mcsb->mcsb_QHDP];
d462 6
a467 6
   if (cqep->cqe_QECR & M_QECR_GO)
      return NULL; /* Hopefully, this will never happen */
   mcsb->mcsb_QHDP++;
   if (mcsb->mcsb_QHDP == NUM_CQE) mcsb->mcsb_QHDP = 0;
   szero(cqep, sizeof(M328_CQE));
   return cqep;
d472 1
a472 1
struct vs_softc *sc;
d474 12
a485 12
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_IOPB *iopb;
   int slot;

   if (mcsb->mcsb_QHDP == 0) {
      slot = NUM_CQE;
   } else {
      slot = mcsb->mcsb_QHDP - 1;
   }
   iopb = (M328_IOPB *)&sc->sc_vsreg->sh_IOPB[slot];
   szero(iopb, sizeof(M328_IOPB));
   return iopb;
d490 1
a490 1
struct vs_softc *sc;
d492 105
a596 104
   M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_IOPB *iopb;
   M328_WQCF *wiopb = (M328_WQCF *)&sc->sc_vsreg->sh_MCE_IOPB;
   u_short i, crsw;
   int failed = 0;

   CRB_CLR_DONE(CRSW);
   szero(cib, sizeof(M328_CIB));
   mcsb->mcsb_QHDP = 0;
   sc->sc_qhp = 0;
   cib->cib_NCQE = 10;
   cib->cib_BURST = 0;
   cib->cib_NVECT = sc->sc_ipl << 8;
   cib->cib_NVECT |= sc->sc_nvec;
   cib->cib_EVECT = sc->sc_ipl << 8;
   cib->cib_EVECT |= sc->sc_evec;
   cib->cib_PID = 0x07;
   cib->cib_SID = 0x00;
   cib->cib_CRBO = OFF(crb);
   cib->cib_SELECT_msw = HI(SELECTION_TIMEOUT);
   cib->cib_SELECT_lsw = LO(SELECTION_TIMEOUT);
   cib->cib_WQ0TIMO_msw = HI(4);
   cib->cib_WQ0TIMO_lsw = LO(4);
   cib->cib_VMETIMO_msw = 0; /*HI(VME_BUS_TIMEOUT);*/
   cib->cib_VMETIMO_lsw = 0; /*LO(VME_BUS_TIMEOUT);*/
   cib->cib_SBRIV = sc->sc_ipl << 8;
   cib->cib_SBRIV |= sc->sc_evec;
   cib->cib_SOF0 = 0x15;
   cib->cib_SRATE0 = 100/4;
   cib->cib_SOF1 = 0x0;
   cib->cib_SRATE1 = 0x0;

   iopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
   szero(iopb, sizeof(M328_IOPB));
   iopb->iopb_CMD = CNTR_INIT;
   iopb->iopb_OPTION = 0;
   iopb->iopb_NVCT = (u_char)sc->sc_nvec;
   iopb->iopb_EVCT = (u_char)sc->sc_evec;
   iopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
   iopb->iopb_ADDR = SHIO_MOD;
   LV(iopb->iopb_BUFF, OFF(cib));
   LV(iopb->iopb_LENGTH, sizeof(M328_CIB));

   szero(mc, sizeof(M328_CQE));
   mc->cqe_IOPB_ADDR = OFF(iopb);
   mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
   mc->cqe_WORK_QUEUE = 0;
   mc->cqe_QECR = M_QECR_GO;
   /* poll for the command to complete */
   do_vspoll(sc, 0);
   CRB_CLR_DONE(CRSW);

   /* initialize work queues */
   for (i=1; i<8; i++) {
      szero(wiopb, sizeof(M328_IOPB));
      wiopb->wqcf_CMD = CNTR_INIT_WORKQ;
      wiopb->wqcf_OPTION = 0;
      wiopb->wqcf_NVCT = (u_char)sc->sc_nvec;
      wiopb->wqcf_EVCT = (u_char)sc->sc_evec;
      wiopb->wqcf_ILVL = 0; /*sc->sc_ipl;*/
      wiopb->wqcf_WORKQ = i;
      wiopb->wqcf_WOPT = (WQO_FOE | WQO_INIT);
      wiopb->wqcf_SLOTS = JAGUAR_MAX_Q_SIZ;
      LV(wiopb->wqcf_CMDTO, 2);

      szero(mc, sizeof(M328_CQE));
      mc->cqe_IOPB_ADDR = OFF(wiopb);
      mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
      mc->cqe_WORK_QUEUE = 0;
      mc->cqe_QECR = M_QECR_GO;
      /* poll for the command to complete */
      do_vspoll(sc, 0);
      if (CRSW & M_CRSW_ER) {
         /*printf("\nerror: queue %d status = 0x%x\n", i, riopb->iopb_STATUS);*/
         /*failed = 1;*/
         CRB_CLR_ER(CRSW);
      }
      CRB_CLR_DONE(CRSW);
      delay(500);
   }
   /* start queue mode */
   CRSW = 0;
   mcsb->mcsb_MCR |= M_MCR_SQM;
   crsw = CRSW;
   do_vspoll(sc, 0);
   if (CRSW & M_CRSW_ER) {
      printf("error: status = 0x%x\n", riopb->iopb_STATUS);
      CRB_CLR_ER(CRSW);
   }
   CRB_CLR_DONE(CRSW);

   if (failed) {
      printf(": failed!\n");
      return;
   }
   /* reset SCSI bus */
   vs_reset(sc);
   /* sync all devices */
   vs_resync(sc);
   printf(": target %d\n", sc->sc_link.adapter_target);
d601 1
a601 1
struct vs_softc *sc;
d603 31
a633 31
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
   u_short i;

   for (i=0; i<7; i++) {
      szero(devreset, sizeof(M328_DRCF));
      devreset->drcf_CMD = CNTR_DEV_REINIT;
      devreset->drcf_OPTION = 0x00;       /* no interrupts yet... */
      devreset->drcf_NVCT = sc->sc_nvec;
      devreset->drcf_EVCT = sc->sc_evec;
      devreset->drcf_ILVL = 0;
      devreset->drcf_UNIT = i;

      szero(mc, sizeof(M328_CQE));
      mc->cqe_IOPB_ADDR = OFF(devreset);
      mc->cqe_IOPB_LENGTH = sizeof(M328_DRCF);
      mc->cqe_WORK_QUEUE = 0;
      mc->cqe_QECR = M_QECR_GO;
      /* poll for the command to complete */
      do_vspoll(sc, 0);
      if (riopb->iopb_STATUS) {
         sc->sc_tinfo[i].avail = 0;
      } else {
         sc->sc_tinfo[i].avail = 1;
      }
      if (CRSW & M_CRSW_ER) {
         CRB_CLR_ER(CRSW);
      }
      CRB_CLR_DONE(CRSW);
   }
d638 1
a638 1
struct vs_softc *sc;
d640 34
a673 44
   struct vsreg * rp;
   u_int s;
   u_char  i;
   struct iopb_reset* iopr;
   struct cqe *cqep;
   struct iopb_scsi *iopbs;
   struct scsi_sense *ss;
   M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
   M328_IOPB *iopb;

   szero(reset, sizeof(M328_SRCF));
   reset->srcf_CMD = IOPB_RESET;
   reset->srcf_OPTION = 0x00;       /* no interrupts yet... */
   reset->srcf_NVCT = sc->sc_nvec;
   reset->srcf_EVCT = sc->sc_evec;
   reset->srcf_ILVL = 0;
   reset->srcf_BUSID = 0;
   s = splbio();

   szero(mc, sizeof(M328_CQE));
   mc->cqe_IOPB_ADDR = OFF(reset);
   mc->cqe_IOPB_LENGTH = sizeof(M328_SRCF);
   mc->cqe_WORK_QUEUE = 0;
   mc->cqe_QECR = M_QECR_GO;
   /* poll for the command to complete */
   while (1) {
      do_vspoll(sc, 0);
      /* ack & clear scsi error condition cause by reset */
      if (CRSW & M_CRSW_ER) {
         CRB_CLR_ER(CRSW);
         CRB_CLR_DONE(CRSW);
         riopb->iopb_STATUS = 0;
         break;
      }
      CRB_CLR_DONE(CRSW);
   }
   /* thaw all work queues */
   thaw_queue(sc, 0xFF);
   splx (s);
a675 1

d684 20
a703 22
struct   vs_softc *sc;
struct scsi_xfer *xs;
int   *status;
{
   struct vsreg * rp = sc->sc_vsreg;
   int   target = -1;
   int   lun = -1;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   struct scsi_generic *cmd;
   u_long buf;
   u_long len;
   u_char error;

   target = xs->sc_link->target;
   lun = xs->sc_link->lun;
   cmd = (struct scsi_generic *)&riopb->iopb_SCSI[0];

   VL(buf, riopb->iopb_BUFF);
   VL(len, riopb->iopb_LENGTH);
   *status = riopb->iopb_STATUS >> 8;
   error = riopb->iopb_STATUS & 0xFF;
d706 1
a706 1
   printf("scsi_chk() ");
d708 54
a761 53
   if (xs->cmd->opcode == 0) {
      printf("TEST_UNIT_READY ");
   } else if (xs->cmd->opcode == REQUEST_SENSE) {
      printf("REQUEST_SENSE   ");
   } else if (xs->cmd->opcode == INQUIRY) {
      printf("INQUIRY         ");
   } else if (xs->cmd->opcode == MODE_SELECT) {
      printf("MODE_SELECT     ");
   } else if (xs->cmd->opcode == MODE_SENSE) {
      printf("MODE_SENSE      ");
   } else if (xs->cmd->opcode == START_STOP) {
      printf("START_STOP      ");
   } else if (xs->cmd->opcode == RESERVE) {
      printf("RESERVE         ");
   } else if (xs->cmd->opcode == RELEASE) {
      printf("RELEASE         ");
   } else if (xs->cmd->opcode == PREVENT_ALLOW) {
      printf("PREVENT_ALLOW   ");
   } else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
      printf("POSITION_TO_EL  ");
   } else if (xs->cmd->opcode == CHANGE_DEFINITION) {
      printf("CHANGE_DEF      ");
   } else if (xs->cmd->opcode == MODE_SENSE_BIG) {
      printf("MODE_SENSE_BIG  ");
   } else if (xs->cmd->opcode == MODE_SELECT_BIG) {
      printf("MODE_SELECT_BIG ");
   } else if (xs->cmd->opcode == 0x25) {
      printf("READ_CAPACITY   ");
   } else if (xs->cmd->opcode == 0x08) {
      printf("READ_COMMAND    ");
   }

   printf("tgt %d lun %d buf %x len %d status %x ", target, lun, buf, len, riopb->iopb_STATUS);

   if (CRSW & M_CRSW_EX) {
      printf("[ex]");
   }
   if (CRSW & M_CRSW_QMS) {
      printf("[qms]");
   }
   if (CRSW & M_CRSW_SC) {
      printf("[sc]");
   }
   if (CRSW & M_CRSW_SE) {
      printf("[se]");
   }
   if (CRSW & M_CRSW_AQ) {
      printf("[aq]");
   }
   if (CRSW & M_CRSW_ER) {
      printf("[er]");
   }
   printf("\n");
d763 12
a774 12
   if (len != xs->datalen) {
      xs->resid = xs->datalen - len;
   } else {
      xs->resid = 0;
   }

   if (error == SCSI_SELECTION_TO) {
      xs->error = XS_SELTIMEOUT;
      xs->status = -1;
      *status = -1;
   }
   return 1;
d777 3
a779 3
int
vs_intr (sc)
register struct vs_softc *sc;
d781 10
a790 8
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   struct scsi_xfer *xs;
   M328_CMD *m328_cmd;
   unsigned long loc;
   int status;
   int s;
   s = splbio();
   /* Got a valid interrupt on this device */
d792 1
a792 1
   VL(loc, crb->crb_CTAG);
d794 2
a795 2
   printf("Interrupt!!! ");
   printf("loc == 0x%x\n", loc);
d797 13
a809 13
   /*
    * If this is a controller error, there won't be a m328_cmd
    * pointer in the CTAG feild.  Bad things happen if you try 
    * to point to address 0.  Controller error should be handeled
    * in vsdma.c  I'll change this soon - steve.
    */
   if (loc) {
      m328_cmd = (M328_CMD *)loc;
      xs = m328_cmd->xs;
      if (m328_cmd->top_sg_list) {
         vs_dealloc_scatter_gather(m328_cmd->top_sg_list);
         m328_cmd->top_sg_list = (M328_SG)0;
      }
d811 6
a816 6
      FREE(m328_cmd, M_DEVBUF); /* free the command tag */
      if (vs_checkintr (sc, xs, &status)) {
         vs_scsidone(xs, status);
      }
   }
   splx(s);
d824 1
a824 1
vs_alloc_scatter_gather(void)
d826 1
a826 1
   M328_SG sg;
d828 2
a829 2
   MALLOC(sg, M328_SG, sizeof(struct m328_sg), M_DEVBUF, M_WAITOK);
   bzero(sg, sizeof(struct m328_sg));
d831 1
a831 1
   return (sg);
d835 2
a836 1
vs_dealloc_scatter_gather(M328_SG sg)
d838 1
a838 1
   register int i;
d840 6
a845 6
   if (sg->level > 0) {
      for (i=0; sg->down[i] && i<MAX_SG_ELEMENTS; i++) {
         vs_dealloc_scatter_gather(sg->down[i]);
      }
   }
   FREE(sg, M_DEVBUF);
d849 4
a852 3
vs_link_sg_element(sg_list_element_t * element,
                               register vm_offset_t       phys_add,
                               register int         len)
d854 7
a860 6
   element->count.bytes = len;
   LV(element->address, phys_add);
   element->link = 0; /* FALSE */
   element->transfer_type = NORMAL_TYPE;
   element->memory_type = LONG_TRANSFER;
   element->address_modifier = 0xD;
d864 4
a867 3
vs_link_sg_list(sg_list_element_t * list,
                            register vm_offset_t    phys_add,
                            register int      elements)
d870 6
a875 6
   list->count.scatter.gather  = elements;
   LV(list->address, phys_add);
   list->link = 1;    /* TRUE */
   list->transfer_type = NORMAL_TYPE;
   list->memory_type = LONG_TRANSFER;
   list->address_modifier = 0xD;
a877 1

d880 2
a881 2
struct scsi_xfer *xs;
M328_IOPB  *iopb;              /* the iopb */
d883 25
a907 18
   M328_SG   sg;
   vm_offset_t starting_point_virt, starting_point_phys, point_virt, 
      point1_phys, point2_phys, virt;
   unsigned len;
   int       level;

   sg = (M328_SG)0;   /* Hopefully we need no scatter/gather list */

   /*
    * We have the following things:
    *	virt			the virtuell address of the contiguous virtual memory block
    *	len			the lenght of the contiguous virtual memory block
    *	starting_point_virt	the virtual address of the contiguous *physical* memory block
    *	starting_point_phys	the *physical* address of the contiguous *physical* memory block
    *	point_virt		the pointer to the virtual memory we are checking at the moment
    *	point1_phys		the pointer to the *physical* memory we are checking at the moment
    *	point2_phys		the pointer to the *physical* memory we are checking at the moment
    */
d909 43
a951 29
   level = 0;
   virt = starting_point_virt = (vm_offset_t)xs->data;
   point1_phys = starting_point_phys = kvtop(xs->data);
   len = xs->datalen;
   /*
    * Check if we need scatter/gather
    */

   if (len > PAGE_SIZE) {
      for (level = 0, point_virt = round_page(starting_point_virt+1);
          /* if we do already scatter/gather we have to stay in the loop and jump */
          point_virt < virt + (vm_offset_t)len || sg ;
          point_virt += PAGE_SIZE) {                      /* out later */

         point2_phys = kvtop(point_virt);

         if ((point2_phys - trunc_page(point1_phys) - PAGE_SIZE) ||                  /* physical memory is not contiguous */
             (point_virt - starting_point_virt >= MAX_SG_BLOCK_SIZE && sg)) {   /* we only can access (1<<16)-1 bytes in scatter/gather_mode */
            if (point_virt - starting_point_virt >= MAX_SG_BLOCK_SIZE) {           /* We were walking too far for one scatter/gather block ... */
               assert( MAX_SG_BLOCK_SIZE > PAGE_SIZE );
               point_virt = trunc_page(starting_point_virt+MAX_SG_BLOCK_SIZE-1);    /* So go back to the beginning of the last matching page */
               /* and gererate the physadress of this location for the next time. */
               point2_phys = kvtop(point_virt);
            }

            if (!sg) {
               /* We allocate our fist scatter/gather list */
               sg = vs_alloc_scatter_gather();
            }
d953 4
a956 6

            if (sg->elements >= MAX_SG_ELEMENTS) {
               vs_dealloc_scatter_gather(sg);
               return (NULL);
            }

d958 31
a988 24
            while (sg->elements >= MAX_SG_ELEMENTS) {
               if (!sg->up) { /* If the list full in this layer ? */
                  sg->up = vs_alloc_scatter_gather();
                  sg->up->level = sg->level+1;
                  sg->up->down[0] = sg;
                  sg->up->elements = 1;
               }
               /* link this full list also in physical memory */
               vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
                                           kvtop((vm_offset_t)sg->list),
                                           sg->elements);
               sg = sg->up;      /* Climb up */
            }
            while (sg->level) {  /* As long as we are not a the base level */
               register int i;

               i = sg->elements;
               /* We need a new element */
               sg->down[i] = vs_alloc_scatter_gather();  
               sg->down[i]->level = sg->level - 1;
               sg->down[i]->up = sg;
               sg->elements++;
               sg = sg->down[i]; /* Climb down */
            }
d991 48
a1038 45
            if (point_virt < virt+(vm_offset_t)len) {
               /* linking element */
               vs_link_sg_element(&(sg->list[sg->elements]), 
                                  starting_point_phys, 
                                  point_virt-starting_point_virt);
               sg->elements++;
            } else {
               /* linking last element */
               vs_link_sg_element(&(sg->list[sg->elements]), 
                                  starting_point_phys, 
                                  (vm_offset_t)(virt+len)-starting_point_virt);
               sg->elements++;
               break;                         /* We have now collected all blocks */
            }
            starting_point_virt = point_virt;
            starting_point_phys = point2_phys;
         }
         point1_phys = point2_phys;
      }
   }

   /*
    * Climb up along the right side of the tree until we reach the top.
    */

   if (sg) {
      while (sg->up) {
         /* link this list also in physical memory */
         vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
                         kvtop((vm_offset_t)sg->list),
                         sg->elements);
         sg = sg->up;                   /* Climb up */
      }

      iopb->iopb_OPTION |= M_OPT_SG;
      iopb->iopb_ADDR |= M_ADR_SG_LINK;
      LV(iopb->iopb_BUFF, kvtop((vm_offset_t)sg->list));
      LV(iopb->iopb_LENGTH, sg->elements);
      LV(iopb->iopb_SGTTL, len);
   } else { 
      /* no scatter/gather neccessary */
      LV(iopb->iopb_BUFF, starting_point_phys);
      LV(iopb->iopb_LENGTH, len);
   }
   return (sg);
a1039 1

@


1.6
log
@Kill vm/vm_param.h, move it to uvm/uvm_param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.5 2001/06/26 21:35:38 miod Exp $ */
d69 10
a78 10
int  vs_checkintr        __P((struct vs_softc *, struct scsi_xfer *, int *));
int  vs_chksense         __P((struct scsi_xfer *));
void vs_reset            __P((struct vs_softc *));
void vs_resync           __P((struct vs_softc *));
void vs_initialize       __P((struct vs_softc *));
int  vs_intr             __P((struct vs_softc *));
int  vs_poll             __P((struct vs_softc *, struct scsi_xfer *));
void vs_scsidone         __P((struct scsi_xfer *, int));
M328_CQE  * vs_getcqe    __P((struct vs_softc *));
M328_IOPB * vs_getiopb   __P((struct vs_softc *));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.6 2001/11/06 00:30:38 art Exp $ */
d69 10
a78 16
void scopy(void *, void *, u_int);
void szero(void *, u_int);
int do_vspoll(struct vs_softc *, int);
void thaw_queue(struct vs_softc *, u_int8_t);
int  vs_checkintr(struct vs_softc *, struct scsi_xfer *, int *);
void vs_chksense(struct scsi_xfer *);
void vs_reset(struct vs_softc *);
void vs_resync(struct vs_softc *);
void vs_initialize(struct vs_softc *);
void vs_intr(void *);
int  vs_poll(struct vs_softc *, struct scsi_xfer *);
void vs_scsidone(struct scsi_xfer *, int);
M328_CQE  *vs_getcqe(struct vs_softc *);
M328_IOPB *vs_getiopb(struct vs_softc *);
void vs_link_sg_element(sg_list_element_t *, vaddr_t, int);
void vs_link_sg_list(sg_list_element_t *, vaddr_t, int);
d80 1
d95 1
a95 3
scopy(src, dst, cnt)
	void *src, *dst;
	u_int cnt;
d97 1
a97 1
	u_int16_t volatile *x, *y, z; 
d99 7
a105 7
	z = cnt >> 1; 
	x = (u_int16_t *) src; 
	y = (u_int16_t *) dst; 

	while (z--) {
		*y++ = *x++; 
	}
d109 1
a109 3
szero(src, cnt)
	void *src;
	u_int cnt;
d111 11
a121 10
	u_int16_t *source;
	u_int16_t zero = 0;
	u_int16_t z; 

	source = (u_int16_t *) src;
	z = cnt >> 1; 

	while (z--) {
		*source++ = zero;
	}
d124 4
d133 1
a133 1
	struct buf *bp;
d135 17
a151 19
	/*
	 * No max transfer at this level.
	 */
	minphys(bp);
}

int
do_vspoll(sc, to)
	struct vs_softc *sc;
	int to;
{
	int i;

	if (to <= 0 ) to = 50000;
	/* use cmd_wait values? */
	i = 50000;
	/*spl0();*/
	while (!(CRSW & (M_CRSW_CRBV | M_CRSW_CC))) {
		if (--i <= 0) {
d153 1
a153 1
			printf ("waiting: timeout %d crsw 0x%x\n", to, CRSW);
d155 12
a166 13
			i = 50000;
			--to;
			if (to <= 0) {
				/*splx(s);*/
				vs_reset(sc);
				vs_resync(sc);
				printf ("timed out: timeout %d crsw 0x%x\n",
				    to, CRSW);
				return 1;
			}
		}
	}
	return 0;
d171 2
a172 25
	struct vs_softc *sc;
	struct scsi_xfer *xs;
{
	int status;
	int to;

	/*s = splbio();*/
	to = xs->timeout / 1000;
	for (;;) {
		if (do_vspoll(sc, to)) break;
		if (vs_checkintr(sc, xs, &status)) {
			vs_scsidone(xs, status);
		}
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER(CRSW);
		CRB_CLR_DONE(CRSW);
		if (xs->flags & ITSDONE) break;
	}
	return (COMPLETE);
}

void
thaw_queue(sc, target)
	struct vs_softc *sc;
	u_int8_t target;
d174 38
a211 6
	u_short t;
	t = target << 8;
	t |= 0x0001;
	THAW_REG = t;
	/* loop until thawed */
	while (THAW_REG & 0x01);
d216 2
a217 2
	struct scsi_xfer *xs;
	int stat;                             
d219 16
a234 17
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;

	xs->status = stat;
	while (xs->status == SCSI_CHECK) {
		vs_chksense(xs);
		thaw_queue(sc, slp->target + 1);
	}
	xs->flags |= ITSDONE;
	/*sc->sc_tinfo[slp->target].cmds++;*/
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
	thaw_queue(sc, slp->target + 1);
	szero(riopb, sizeof(M328_IOPB));
	scsi_done(xs);
d239 1
a239 1
	struct scsi_xfer *xs;
d241 21
a261 19
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	int flags;
	unsigned long buf, len;
	u_short iopb_len;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	M328_CQE *cqep;
	M328_IOPB *iopb;
	M328_CMD *m328_cmd;

	/* If the target doesn't exist, abort */
	if (!sc->sc_tinfo[slp->target].avail) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		xs->flags |= ITSDONE;
		scsi_done(xs);
	}
d263 2
a264 2
	slp->quirks |= SDEV_NOLUNS;
	flags = xs->flags;
d266 32
a297 32
	printf("scsi_cmd() ");
	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}
d299 15
a313 15
	if (flags & SCSI_POLL) {
		cqep = mc;
		iopb = miopb;
	} else {
		cqep = vs_getcqe(sc);
		iopb = vs_getiopb(sc);
	}
	if (cqep == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
	}

	/* s = splbio();*/
	iopb_len = sizeof(M328_short_IOPB) + xs->cmdlen;
	szero(iopb, sizeof(M328_IOPB));
d315 2
a316 2
	scopy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
	iopb->iopb_CMD = IOPB_SCSI;
d318 2
a319 2
	LV(iopb->iopb_BUFF, kvtop(xs->data));
	LV(iopb->iopb_LENGTH, xs->datalen);
d321 11
a331 11
	iopb->iopb_UNIT = slp->lun << 3;
	iopb->iopb_UNIT |= slp->target;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;

	/*
	 * Since the 88k's don't support cache snooping, we have
	 * to flush the cache for a write and flush with inval for
	 * a read, prior to starting the IO.
	 */
	if (xs->flags & SCSI_DATA_IN) {  /* read */
d333 2
a334 2
		dma_cachectl(xs->data, xs->datalen,
		    DMA_CACHE_SYNC_INVAL);
d336 5
a340 5
		iopb->iopb_OPTION |= OPT_READ;
	} else {                         /* write */
#if defined(mvme88k)
		dma_cachectl(xs->data, xs->datalen,
		    DMA_CACHE_SYNC);
d342 2
a343 2
		iopb->iopb_OPTION |= OPT_WRITE;
	}
d345 23
a367 23
	if (flags & SCSI_POLL) {
		iopb->iopb_OPTION |= OPT_INTDIS;
		iopb->iopb_LEVEL = 0;
	} else {
		iopb->iopb_OPTION |= OPT_INTEN;
		iopb->iopb_LEVEL = sc->sc_ipl;
	}
	iopb->iopb_ADDR = ADDR_MOD;

	/*
	 * Wait until we can use the command queue entry.
	 * Should only have to wait if the master command 
	 * queue entry is busy.
	 */
	while (cqep->cqe_QECR & M_QECR_GO);

	cqep->cqe_IOPB_ADDR = OFF(iopb);
	cqep->cqe_IOPB_LENGTH = iopb_len;
	if (flags & SCSI_POLL) {
		cqep->cqe_WORK_QUEUE = slp->target + 1;
	} else {
		cqep->cqe_WORK_QUEUE = slp->target + 1;
	}
d369 1
a369 1
	MALLOC(m328_cmd, M328_CMD*, sizeof(M328_CMD), M_DEVBUF, M_WAITOK);
d371 14
a384 14
	m328_cmd->xs = xs;
	if (xs->datalen) {
		m328_cmd->top_sg_list = vs_build_memory_structure(xs, iopb);
	} else {
		m328_cmd->top_sg_list = (M328_SG)0;
	}

	LV(cqep->cqe_CTAG, m328_cmd);

	if (crb->crb_CRSW & M_CRSW_AQ) {
		cqep->cqe_QECR = M_QECR_AA;
	}
	VL(buf, iopb->iopb_BUFF);
	VL(len, iopb->iopb_LENGTH);
d386 2
a387 2
	printf("tgt %d lun %d buf %x len %d wqn %d ipl %d\n", slp->target, 
	    slp->lun, buf, len, cqep->cqe_WORK_QUEUE, iopb->iopb_LEVEL);
d389 1
a389 1
	cqep->cqe_QECR |= M_QECR_GO;
d391 8
a398 8
	if (flags & SCSI_POLL) {
		/* poll for the command to complete */
		/*splx(s);*/
		vs_poll(sc, xs);
		return (COMPLETE);
	}
	/*splx(s);*/
	return (SUCCESSFULLY_QUEUED);
d401 1
a401 1
void
d403 1
a403 1
	struct scsi_xfer *xs;
d405 44
a448 45
	int s;
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	struct scsi_sense *ss;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;

	/* ack and clear the error */
	CRB_CLR_DONE(CRSW);
	CRB_CLR_ER(CRSW);
	xs->status = 0;

	szero(miopb, sizeof(M328_IOPB));
	/* This is a command, so point to it */
	ss = (void *)&miopb->iopb_SCSI[0];
	szero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = slp->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);

	miopb->iopb_CMD = IOPB_SCSI;
	miopb->iopb_OPTION = OPT_READ;
	miopb->iopb_NVCT = (u_char)sc->sc_nvec;
	miopb->iopb_EVCT = (u_char)sc->sc_evec;
	miopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	miopb->iopb_ADDR = ADDR_MOD;
	LV(miopb->iopb_BUFF, kvtop((vaddr_t)&xs->sense));
	LV(miopb->iopb_LENGTH, sizeof(struct scsi_sense_data));

	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(miopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) +
	    sizeof(struct scsi_sense);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	s = splbio();
	do_vspoll(sc, 0);
	/*
	if (xs->cmd->opcode != PREVENT_ALLOW) {
		xs->error = XS_SENSE;
	}
	*/
	xs->status = riopb->iopb_STATUS >> 8;
d450 1
a450 1
	scsi_print_sense(xs, 2);
d452 1
a452 1
	splx(s);
d457 1
a457 1
	struct vs_softc *sc;
d459 2
a460 2
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_CQE *cqep;
d462 1
a462 1
	cqep = (M328_CQE *)&sc->sc_vsreg->sh_CQE[mcsb->mcsb_QHDP];
d464 6
a469 6
	if (cqep->cqe_QECR & M_QECR_GO)
		return NULL; /* Hopefully, this will never happen */
	mcsb->mcsb_QHDP++;
	if (mcsb->mcsb_QHDP == NUM_CQE) mcsb->mcsb_QHDP = 0;
	szero(cqep, sizeof(M328_CQE));
	return cqep;
d474 1
a474 1
	struct vs_softc *sc;
d476 12
a487 12
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	int slot;

	if (mcsb->mcsb_QHDP == 0) {
		slot = NUM_CQE;
	} else {
		slot = mcsb->mcsb_QHDP - 1;
	}
	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_IOPB[slot];
	szero(iopb, sizeof(M328_IOPB));
	return iopb;
d492 1
a492 1
	struct vs_softc *sc;
d494 104
a597 105
	M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	M328_WQCF *wiopb = (M328_WQCF *)&sc->sc_vsreg->sh_MCE_IOPB;
	u_short i, crsw;
	int failed = 0;

	CRB_CLR_DONE(CRSW);
	szero(cib, sizeof(M328_CIB));
	mcsb->mcsb_QHDP = 0;
	sc->sc_qhp = 0;
	cib->cib_NCQE = 10;
	cib->cib_BURST = 0;
	cib->cib_NVECT = sc->sc_ipl << 8;
	cib->cib_NVECT |= sc->sc_nvec;
	cib->cib_EVECT = sc->sc_ipl << 8;
	cib->cib_EVECT |= sc->sc_evec;
	cib->cib_PID = 0x07;
	cib->cib_SID = 0x00;
	cib->cib_CRBO = OFF(crb);
	cib->cib_SELECT_msw = HI(SELECTION_TIMEOUT);
	cib->cib_SELECT_lsw = LO(SELECTION_TIMEOUT);
	cib->cib_WQ0TIMO_msw = HI(4);
	cib->cib_WQ0TIMO_lsw = LO(4);
	cib->cib_VMETIMO_msw = 0; /*HI(VME_BUS_TIMEOUT);*/
	cib->cib_VMETIMO_lsw = 0; /*LO(VME_BUS_TIMEOUT);*/
	cib->cib_SBRIV = sc->sc_ipl << 8;
	cib->cib_SBRIV |= sc->sc_evec;
	cib->cib_SOF0 = 0x15;
	cib->cib_SRATE0 = 100/4;
	cib->cib_SOF1 = 0x0;
	cib->cib_SRATE1 = 0x0;

	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	szero(iopb, sizeof(M328_IOPB));
	iopb->iopb_CMD = CNTR_INIT;
	iopb->iopb_OPTION = 0;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;
	iopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	iopb->iopb_ADDR = SHIO_MOD;
	LV(iopb->iopb_BUFF, OFF(cib));
	LV(iopb->iopb_LENGTH, sizeof(M328_CIB));

	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(iopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	do_vspoll(sc, 0);
	CRB_CLR_DONE(CRSW);

	/* initialize work queues */
	for (i=1; i<8; i++) {
		szero(wiopb, sizeof(M328_IOPB));
		wiopb->wqcf_CMD = CNTR_INIT_WORKQ;
		wiopb->wqcf_OPTION = 0;
		wiopb->wqcf_NVCT = (u_char)sc->sc_nvec;
		wiopb->wqcf_EVCT = (u_char)sc->sc_evec;
		wiopb->wqcf_ILVL = 0; /*sc->sc_ipl;*/
		wiopb->wqcf_WORKQ = i;
		wiopb->wqcf_WOPT = (WQO_FOE | WQO_INIT);
		wiopb->wqcf_SLOTS = JAGUAR_MAX_Q_SIZ;
		LV(wiopb->wqcf_CMDTO, 2);

		szero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(wiopb);
		mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
		/* poll for the command to complete */
		do_vspoll(sc, 0);
		if (CRSW & M_CRSW_ER) {
			/*printf("\nerror: queue %d status = 0x%x\n",
			    i, riopb->iopb_STATUS);*/
			/*failed = 1;*/
			CRB_CLR_ER(CRSW);
		}
		CRB_CLR_DONE(CRSW);
		delay(500);
	}
	/* start queue mode */
	CRSW = 0;
	mcsb->mcsb_MCR |= M_MCR_SQM;
	crsw = CRSW;
	do_vspoll(sc, 0);
	if (CRSW & M_CRSW_ER) {
		printf("error: status = 0x%x\n", riopb->iopb_STATUS);
		CRB_CLR_ER(CRSW);
	}
	CRB_CLR_DONE(CRSW);

	if (failed) {
		printf(": failed!\n");
		return;
	}
	/* reset SCSI bus */
	vs_reset(sc);
	/* sync all devices */
	vs_resync(sc);
	printf(": target %d\n", sc->sc_link.adapter_target);
d602 1
a602 1
	struct vs_softc *sc;
d604 31
a634 31
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
	u_short i;

	for (i=0; i<7; i++) {
		szero(devreset, sizeof(M328_DRCF));
		devreset->drcf_CMD = CNTR_DEV_REINIT;
		devreset->drcf_OPTION = 0x00;       /* no interrupts yet... */
		devreset->drcf_NVCT = sc->sc_nvec;
		devreset->drcf_EVCT = sc->sc_evec;
		devreset->drcf_ILVL = 0;
		devreset->drcf_UNIT = i;

		szero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(devreset);
		mc->cqe_IOPB_LENGTH = sizeof(M328_DRCF);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
		/* poll for the command to complete */
		do_vspoll(sc, 0);
		if (riopb->iopb_STATUS) {
			sc->sc_tinfo[i].avail = 0;
		} else {
			sc->sc_tinfo[i].avail = 1;
		}
		if (CRSW & M_CRSW_ER) {
			CRB_CLR_ER(CRSW);
		}
		CRB_CLR_DONE(CRSW);
	}
d639 1
a639 1
	struct vs_softc *sc;
d641 44
a684 34
	u_int s;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  

	szero(reset, sizeof(M328_SRCF));
	reset->srcf_CMD = IOPB_RESET;
	reset->srcf_OPTION = 0x00;       /* no interrupts yet... */
	reset->srcf_NVCT = sc->sc_nvec;
	reset->srcf_EVCT = sc->sc_evec;
	reset->srcf_ILVL = 0;
	reset->srcf_BUSID = 0;
	s = splbio();

	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(reset);
	mc->cqe_IOPB_LENGTH = sizeof(M328_SRCF);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	for (;;) {
		do_vspoll(sc, 0);
		/* ack & clear scsi error condition cause by reset */
		if (CRSW & M_CRSW_ER) {
			CRB_CLR_ER(CRSW);
			CRB_CLR_DONE(CRSW);
			riopb->iopb_STATUS = 0;
			break;
		}
		CRB_CLR_DONE(CRSW);
	}
	/* thaw all work queues */
	thaw_queue(sc, 0xFF);
	splx(s);
d687 1
d696 22
a717 20
	struct vs_softc *sc;
	struct scsi_xfer *xs;
	int *status;
{
	int target = -1;
	int lun = -1;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	struct scsi_generic *cmd;
	u_long buf;
	u_long len;
	u_char error;

	target = xs->sc_link->target;
	lun = xs->sc_link->lun;
	cmd = (struct scsi_generic *)&riopb->iopb_SCSI[0];

	VL(buf, riopb->iopb_BUFF);
	VL(len, riopb->iopb_LENGTH);
	*status = riopb->iopb_STATUS >> 8;
	error = riopb->iopb_STATUS & 0xFF;
d720 1
a720 1
	printf("scsi_chk() ");
d722 53
a774 54
	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}

	printf("tgt %d lun %d buf %x len %d status %x ",
	    target, lun, buf, len, riopb->iopb_STATUS);

	if (CRSW & M_CRSW_EX) {
		printf("[ex]");
	}
	if (CRSW & M_CRSW_QMS) {
		printf("[qms]");
	}
	if (CRSW & M_CRSW_SC) {
		printf("[sc]");
	}
	if (CRSW & M_CRSW_SE) {
		printf("[se]");
	}
	if (CRSW & M_CRSW_AQ) {
		printf("[aq]");
	}
	if (CRSW & M_CRSW_ER) {
		printf("[er]");
	}
	printf("\n");
d776 12
a787 12
	if (len != xs->datalen) {
		xs->resid = xs->datalen - len;
	} else {
		xs->resid = 0;
	}

	if (error == SCSI_SELECTION_TO) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		*status = -1;
	}
	return 1;
d790 3
a792 3
void
vs_intr(arg)
	void *arg;
d794 8
a801 10
	struct vs_softc *sc = (struct vs_softc *)arg;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	struct scsi_xfer *xs;
	M328_CMD *m328_cmd;
	unsigned long loc;
	int status;
	int s;

	s = splbio();
	/* Got a valid interrupt on this device */
d803 1
a803 1
	VL(loc, crb->crb_CTAG);
d805 2
a806 2
	printf("Interrupt!!! ");
	printf("loc == 0x%x\n", loc);
d808 13
a820 13
	/*
	 * If this is a controller error, there won't be a m328_cmd
	 * pointer in the CTAG feild.  Bad things happen if you try 
	 * to point to address 0.  Controller error should be handeled
	 * in vsdma.c  I'll change this soon - steve.
	 */
	if (loc) {
		m328_cmd = (M328_CMD *)loc;
		xs = m328_cmd->xs;
		if (m328_cmd->top_sg_list) {
			vs_dealloc_scatter_gather(m328_cmd->top_sg_list);
			m328_cmd->top_sg_list = (M328_SG)0;
		}
d822 6
a827 6
		FREE(m328_cmd, M_DEVBUF); /* free the command tag */
		if (vs_checkintr (sc, xs, &status)) {
			vs_scsidone(xs, status);
		}
	}
	splx(s);
d835 1
a835 1
vs_alloc_scatter_gather()
d837 1
a837 1
	M328_SG sg;
d839 2
a840 2
	MALLOC(sg, M328_SG, sizeof(struct m328_sg), M_DEVBUF, M_WAITOK);
	bzero(sg, sizeof(struct m328_sg));
d842 1
a842 1
	return (sg);
d846 1
a846 2
vs_dealloc_scatter_gather(sg)
	M328_SG sg;
d848 1
a848 1
	int i;
d850 6
a855 6
	if (sg->level > 0) {
		for (i = 0; sg->down[i] && i<MAX_SG_ELEMENTS; i++) {
			vs_dealloc_scatter_gather(sg->down[i]);
		}
	}
	FREE(sg, M_DEVBUF);
d859 3
a861 4
vs_link_sg_element(element, phys_add, len)
	sg_list_element_t *element;
	vaddr_t phys_add;
	int len;
d863 6
a868 7

	element->count.bytes = len;
	LV(element->address, phys_add);
	element->link = 0; /* FALSE */
	element->transfer_type = NORMAL_TYPE;
	element->memory_type = LONG_TRANSFER;
	element->address_modifier = 0xD;
d872 3
a874 4
vs_link_sg_list(list, phys_add, elements)
	sg_list_element_t *list;
	vaddr_t phys_add;
	int elements;
d877 6
a882 6
	list->count.scatter.gather  = elements;
	LV(list->address, phys_add);
	list->link = 1;    /* TRUE */
	list->transfer_type = NORMAL_TYPE;
	list->memory_type = LONG_TRANSFER;
	list->address_modifier = 0xD;
d885 1
d888 2
a889 2
	struct scsi_xfer *xs;
	M328_IOPB  *iopb;              /* the iopb */
d891 18
a908 25
	M328_SG   sg;
	vaddr_t starting_point_virt, point_virt, virt;
	paddr_t starting_point_phys, point1_phys, point2_phys;
	u_int len;
	int level;

	sg = (M328_SG)0;   /* Hopefully we need no scatter/gather list */

	/*
	 * We have the following things:
	 * virt			the virtual address of the contiguous virtual
	 *			memory block
	 * len			the length of the contiguous virtual memory
	 *			block
	 * starting_point_virt	the virtual address of the contiguous
	 *			*physical* memory block
	 * starting_point_phys	the *physical* address of the contiguous
	 *			*physical* memory block
	 * point_virt		the pointer to the virtual memory we are
	 *			checking at the moment
	 * point1_phys		the pointer to the *physical* memory we are
	 *			checking at the moment
	 * point2_phys		the pointer to the *physical* memory we are
	 *			checking at the moment
	 */
d910 29
a938 43
	level = 0;
	virt = starting_point_virt = (vaddr_t)xs->data;
	point1_phys = starting_point_phys = kvtop((vaddr_t)xs->data);
	len = xs->datalen;

	/*
	 * Check if we need scatter/gather
	*/
	if (len > PAGE_SIZE) {
		for (level = 0, point_virt = round_page(starting_point_virt+1);
			/* if we do already scatter/gather we have to stay in
			   the loop and jump */
		    point_virt < virt + (vaddr_t)len || sg;
		    point_virt += PAGE_SIZE) {	/* out later */

			point2_phys = kvtop(point_virt);

			if ((point2_phys - trunc_page(point1_phys) - PAGE_SIZE) ||
			    /* physical memory is not contiguous */
			    (point_virt - starting_point_virt >=
			    MAX_SG_BLOCK_SIZE && sg)) {
				/* we only can access (1<<16)-1 bytes in
				   scatter/gather_mode */
				if (point_virt - starting_point_virt >=
				    MAX_SG_BLOCK_SIZE) {
					/* We were walking too far for one
					   scatter/gather block ... */
					assert( MAX_SG_BLOCK_SIZE > PAGE_SIZE );
					point_virt =
					    trunc_page(starting_point_virt +
						MAX_SG_BLOCK_SIZE-1);
					/* So go back to the beginning of the
					   last matching page and gererate the
					   physadress of this location for the
					   next time. */
					point2_phys = kvtop(point_virt);
				}

				if (!sg) {
					/* We allocate our fist scatter/gather
					   list */
					sg = vs_alloc_scatter_gather();
				}
d940 6
a945 4
				if (sg->elements >= MAX_SG_ELEMENTS) {
					vs_dealloc_scatter_gather(sg);
					return (NULL);
				}
d947 24
a970 31
				while (sg->elements >= MAX_SG_ELEMENTS) {
					/* If the list full in this layer ? */
					if (!sg->up) {
						sg->up =
						    vs_alloc_scatter_gather();
						sg->up->level = sg->level+1;
						sg->up->down[0] = sg;
						sg->up->elements = 1;
					}
					/* link this full list also in physical
					   memory */
					vs_link_sg_list(
					    &(sg->up->list[
						sg->up->elements - 1]), 
					    kvtop((vaddr_t)sg->list),
					    sg->elements);
					sg = sg->up;      /* Climb up */
				}
				/* As long as we are not a the base level */
				while (sg->level) { 
					int i;

					i = sg->elements;
					/* We need a new element */
					sg->down[i] =
					    vs_alloc_scatter_gather();  
					sg->down[i]->level = sg->level - 1;
					sg->down[i]->up = sg;
					sg->elements++;
					sg = sg->down[i]; /* Climb down */
				}
d973 45
a1017 48
				if (point_virt < virt+(vaddr_t)len) {
					/* linking element */
					vs_link_sg_element(
					    &(sg->list[sg->elements]), 
					    starting_point_phys, 
					    point_virt-starting_point_virt);
					sg->elements++;
				} else {
					/* linking last element */
					vs_link_sg_element(
					    &(sg->list[sg->elements]), 
					    starting_point_phys, 
					    (vaddr_t)(virt + len) -
					        starting_point_virt);
					sg->elements++;
					break;
					/* We have now collected all blocks */
				}
				starting_point_virt = point_virt;
				starting_point_phys = point2_phys;
			}
			point1_phys = point2_phys;
		}
	}

	/*
	 * Climb up along the right side of the tree until we reach the top.
	 */

	if (sg) {
		while (sg->up) {
			/* link this list also in physical memory */
			vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
			    kvtop((vaddr_t)sg->list), sg->elements);
			sg = sg->up;                   /* Climb up */
		}

		iopb->iopb_OPTION |= M_OPT_SG;
		iopb->iopb_ADDR |= M_ADR_SG_LINK;
		LV(iopb->iopb_BUFF, kvtop((vaddr_t)sg->list));
		LV(iopb->iopb_LENGTH, sg->elements);
		LV(iopb->iopb_SGTTL, len);
	} else { 
		/* no scatter/gather neccessary */
		LV(iopb->iopb_BUFF, starting_point_phys);
		LV(iopb->iopb_LENGTH, len);
	}
	return (sg);
d1019 1
@


1.6.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d800 1
a800 1
	 * to point to address 0.  Controller error should be handled
@


1.5
log
@A few changes to mvme68k:
+ switch to UVM
+ fix the system trace problem
+ big cleanup of locore.s (macro for BUG calls, use more common m68k
  code whenever possible, and the macros in <m68k/asm.h>)
+ better indentation on some parts (old KNF)
+ call doshutdownhooks() at shutdown
+ use <net/netisr_dispatch.h>
+ upgrade pmap.c to something very close to our current hp300 pmap.c,
  minus support for PMAP_NEW and for HP MMU
+ various tidbits I forget to mention here

work and tests by smurph@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.4 2001/06/25 00:43:13 mickey Exp $ */
a54 2
#include <vm/vm_param.h>

d57 2
@


1.4
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.3 2001/05/16 12:49:47 ho Exp $ */
d51 1
d54 3
d60 1
a60 2
#define PAGESIZE 4096  /* should get this out of a header? XXX - smurph */
#ifdef __m88k_
d63 1
a63 3
#include "machine/mmu.h"
#define ROUND_PAGE m88k_round_page
#define TRUNC_PAGE m88k_trunc_page
a66 2
#define ROUND_PAGE m68k_round_page
#define TRUNC_PAGE m68k_trunc_page
d332 1
a332 1
#if defined(MVME187) || defined(MVME188) || defined(MVME197)
d918 2
a919 2
   if (len > PAGESIZE) {
      for (level = 0, point_virt = ROUND_PAGE(starting_point_virt+1);
d922 1
a922 1
          point_virt += PAGESIZE) {                      /* out later */
d926 1
a926 1
         if ((point2_phys - TRUNC_PAGE(point1_phys) - PAGESIZE) ||                  /* physical memory is not contiguous */
d929 2
a930 2
               assert( MAX_SG_BLOCK_SIZE > PAGESIZE );
               point_virt = TRUNC_PAGE(starting_point_virt+MAX_SG_BLOCK_SIZE-1);    /* So go back to the beginning of the last matching page */
@


1.3
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.2 2000/06/10 19:53:23 deraadt Exp $ */
a80 1
extern int cold;
@


1.2
log
@better ifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.1 2000/01/25 04:18:17 smurph Exp $ */
a841 4
   assert ( sg );
   if ( !sg ) {
      panic ("Memory for scatter_gather_list not available");
   }
@


1.1
log
@Added support for MVME328 SCSI VME board.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.2 1999/09/27 18:43:25 smurph Exp $ */
d57 6
a62 6
#if defined(MVME187) || defined(MVME188) || defined(MVME197)
   #include <mvme88k/dev/vsreg.h>
   #include <mvme88k/dev/vsvar.h>
   #include "machine/mmu.h"
   #define ROUND_PAGE m88k_round_page
   #define TRUNC_PAGE m88k_trunc_page
d64 5
a68 5
   #include <mvme68k/dev/vsreg.h>
   #include <mvme68k/dev/vsvar.h>
   #define ROUND_PAGE m68k_round_page
   #define TRUNC_PAGE m68k_trunc_page
#endif /* defined(MVME187) || defined(MVME188) || defined(MVME197) */
@


1.1.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.2 2000/06/10 19:53:23 deraadt Exp $ */
d57 6
a62 6
#ifdef __m88k_
#include <mvme88k/dev/vsreg.h>
#include <mvme88k/dev/vsvar.h>
#include "machine/mmu.h"
#define ROUND_PAGE m88k_round_page
#define TRUNC_PAGE m88k_trunc_page
d64 5
a68 5
#include <mvme68k/dev/vsreg.h>
#include <mvme68k/dev/vsvar.h>
#define ROUND_PAGE m68k_round_page
#define TRUNC_PAGE m68k_trunc_page
#endif
@


1.1.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.1.2.1 2001/04/18 16:10:31 niklas Exp $ */
a50 1

a52 3

#include <vm/vm_param.h>

d56 2
a57 1
#ifdef mvme88k
d60 3
a62 1
#include <machine/mmu.h>
d66 2
d81 1
d334 1
a334 1
#if defined(mvme88k)
d842 4
d924 2
a925 2
   if (len > PAGE_SIZE) {
      for (level = 0, point_virt = round_page(starting_point_virt+1);
d928 1
a928 1
          point_virt += PAGE_SIZE) {                      /* out later */
d932 1
a932 1
         if ((point2_phys - trunc_page(point1_phys) - PAGE_SIZE) ||                  /* physical memory is not contiguous */
d935 2
a936 2
               assert( MAX_SG_BLOCK_SIZE > PAGE_SIZE );
               point_virt = trunc_page(starting_point_virt+MAX_SG_BLOCK_SIZE-1);    /* So go back to the beginning of the last matching page */
@


1.1.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d55 2
a58 2

#include <uvm/uvm_param.h>
@


1.1.2.4
log
@Merge in -current from about a week ago
@
text
@d69 10
a78 10
int  vs_checkintr(struct vs_softc *, struct scsi_xfer *, int *);
int  vs_chksense(struct scsi_xfer *);
void vs_reset(struct vs_softc *);
void vs_resync(struct vs_softc *);
void vs_initialize(struct vs_softc *);
int  vs_intr(struct vs_softc *);
int  vs_poll(struct vs_softc *, struct scsi_xfer *);
void vs_scsidone(struct scsi_xfer *, int);
M328_CQE  * vs_getcqe(struct vs_softc *);
M328_IOPB * vs_getiopb(struct vs_softc *);
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@a68 4
void scopy(void *, void *, u_int);
void szero(void *, u_int);
int do_vspoll(struct vs_softc *, int);
void thaw_queue(struct vs_softc *, u_int8_t);
d70 1
a70 1
void vs_chksense(struct scsi_xfer *);
d74 1
a74 1
void vs_intr(void *);
d77 2
a78 4
M328_CQE  *vs_getcqe(struct vs_softc *);
M328_IOPB *vs_getiopb(struct vs_softc *);
void vs_link_sg_element(sg_list_element_t *, vaddr_t, int);
void vs_link_sg_list(sg_list_element_t *, vaddr_t, int);
d80 1
d95 1
a95 3
scopy(src, dst, cnt)
	void *src, *dst;
	u_int cnt;
d97 1
a97 1
	u_int16_t volatile *x, *y, z; 
d99 7
a105 7
	z = cnt >> 1; 
	x = (u_int16_t *) src; 
	y = (u_int16_t *) dst; 

	while (z--) {
		*y++ = *x++; 
	}
d109 13
a121 14
szero(src, cnt)
	void *src;
	u_int cnt;
{
	u_int16_t *source;
	u_int16_t zero = 0;
	u_int16_t z; 

	source = (u_int16_t *) src;
	z = cnt >> 1; 

	while (z--) {
		*source++ = zero;
	}
d124 4
d133 1
a133 1
	struct buf *bp;
d135 17
a151 19
	/*
	 * No max transfer at this level.
	 */
	minphys(bp);
}

int
do_vspoll(sc, to)
	struct vs_softc *sc;
	int to;
{
	int i;

	if (to <= 0 ) to = 50000;
	/* use cmd_wait values? */
	i = 50000;
	/*spl0();*/
	while (!(CRSW & (M_CRSW_CRBV | M_CRSW_CC))) {
		if (--i <= 0) {
d153 1
a153 1
			printf ("waiting: timeout %d crsw 0x%x\n", to, CRSW);
d155 12
a166 13
			i = 50000;
			--to;
			if (to <= 0) {
				/*splx(s);*/
				vs_reset(sc);
				vs_resync(sc);
				printf ("timed out: timeout %d crsw 0x%x\n",
				    to, CRSW);
				return 1;
			}
		}
	}
	return 0;
d171 2
a172 2
	struct vs_softc *sc;
	struct scsi_xfer *xs;
d174 38
a211 29
	int status;
	int to;

	/*s = splbio();*/
	to = xs->timeout / 1000;
	for (;;) {
		if (do_vspoll(sc, to)) break;
		if (vs_checkintr(sc, xs, &status)) {
			vs_scsidone(xs, status);
		}
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER(CRSW);
		CRB_CLR_DONE(CRSW);
		if (xs->flags & ITSDONE) break;
	}
	return (COMPLETE);
}

void
thaw_queue(sc, target)
	struct vs_softc *sc;
	u_int8_t target;
{
	u_short t;
	t = target << 8;
	t |= 0x0001;
	THAW_REG = t;
	/* loop until thawed */
	while (THAW_REG & 0x01);
d216 2
a217 2
	struct scsi_xfer *xs;
	int stat;                             
d219 16
a234 17
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;

	xs->status = stat;
	while (xs->status == SCSI_CHECK) {
		vs_chksense(xs);
		thaw_queue(sc, slp->target + 1);
	}
	xs->flags |= ITSDONE;
	/*sc->sc_tinfo[slp->target].cmds++;*/
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
	thaw_queue(sc, slp->target + 1);
	szero(riopb, sizeof(M328_IOPB));
	scsi_done(xs);
d239 1
a239 1
	struct scsi_xfer *xs;
d241 21
a261 19
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	int flags;
	unsigned long buf, len;
	u_short iopb_len;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	M328_CQE *cqep;
	M328_IOPB *iopb;
	M328_CMD *m328_cmd;

	/* If the target doesn't exist, abort */
	if (!sc->sc_tinfo[slp->target].avail) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		xs->flags |= ITSDONE;
		scsi_done(xs);
	}
d263 2
a264 2
	slp->quirks |= SDEV_NOLUNS;
	flags = xs->flags;
d266 32
a297 32
	printf("scsi_cmd() ");
	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}
d299 15
a313 15
	if (flags & SCSI_POLL) {
		cqep = mc;
		iopb = miopb;
	} else {
		cqep = vs_getcqe(sc);
		iopb = vs_getiopb(sc);
	}
	if (cqep == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
	}

	/* s = splbio();*/
	iopb_len = sizeof(M328_short_IOPB) + xs->cmdlen;
	szero(iopb, sizeof(M328_IOPB));
d315 2
a316 2
	scopy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
	iopb->iopb_CMD = IOPB_SCSI;
d318 2
a319 2
	LV(iopb->iopb_BUFF, kvtop(xs->data));
	LV(iopb->iopb_LENGTH, xs->datalen);
d321 11
a331 11
	iopb->iopb_UNIT = slp->lun << 3;
	iopb->iopb_UNIT |= slp->target;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;

	/*
	 * Since the 88k's don't support cache snooping, we have
	 * to flush the cache for a write and flush with inval for
	 * a read, prior to starting the IO.
	 */
	if (xs->flags & SCSI_DATA_IN) {  /* read */
d333 2
a334 2
		dma_cachectl(xs->data, xs->datalen,
		    DMA_CACHE_SYNC_INVAL);
d336 5
a340 5
		iopb->iopb_OPTION |= OPT_READ;
	} else {                         /* write */
#if defined(mvme88k)
		dma_cachectl(xs->data, xs->datalen,
		    DMA_CACHE_SYNC);
d342 2
a343 2
		iopb->iopb_OPTION |= OPT_WRITE;
	}
d345 23
a367 23
	if (flags & SCSI_POLL) {
		iopb->iopb_OPTION |= OPT_INTDIS;
		iopb->iopb_LEVEL = 0;
	} else {
		iopb->iopb_OPTION |= OPT_INTEN;
		iopb->iopb_LEVEL = sc->sc_ipl;
	}
	iopb->iopb_ADDR = ADDR_MOD;

	/*
	 * Wait until we can use the command queue entry.
	 * Should only have to wait if the master command 
	 * queue entry is busy.
	 */
	while (cqep->cqe_QECR & M_QECR_GO);

	cqep->cqe_IOPB_ADDR = OFF(iopb);
	cqep->cqe_IOPB_LENGTH = iopb_len;
	if (flags & SCSI_POLL) {
		cqep->cqe_WORK_QUEUE = slp->target + 1;
	} else {
		cqep->cqe_WORK_QUEUE = slp->target + 1;
	}
d369 1
a369 1
	MALLOC(m328_cmd, M328_CMD*, sizeof(M328_CMD), M_DEVBUF, M_WAITOK);
d371 14
a384 14
	m328_cmd->xs = xs;
	if (xs->datalen) {
		m328_cmd->top_sg_list = vs_build_memory_structure(xs, iopb);
	} else {
		m328_cmd->top_sg_list = (M328_SG)0;
	}

	LV(cqep->cqe_CTAG, m328_cmd);

	if (crb->crb_CRSW & M_CRSW_AQ) {
		cqep->cqe_QECR = M_QECR_AA;
	}
	VL(buf, iopb->iopb_BUFF);
	VL(len, iopb->iopb_LENGTH);
d386 2
a387 2
	printf("tgt %d lun %d buf %x len %d wqn %d ipl %d\n", slp->target, 
	    slp->lun, buf, len, cqep->cqe_WORK_QUEUE, iopb->iopb_LEVEL);
d389 1
a389 1
	cqep->cqe_QECR |= M_QECR_GO;
d391 8
a398 8
	if (flags & SCSI_POLL) {
		/* poll for the command to complete */
		/*splx(s);*/
		vs_poll(sc, xs);
		return (COMPLETE);
	}
	/*splx(s);*/
	return (SUCCESSFULLY_QUEUED);
d401 1
a401 1
void
d403 1
a403 1
	struct scsi_xfer *xs;
d405 44
a448 45
	int s;
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	struct scsi_sense *ss;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;

	/* ack and clear the error */
	CRB_CLR_DONE(CRSW);
	CRB_CLR_ER(CRSW);
	xs->status = 0;

	szero(miopb, sizeof(M328_IOPB));
	/* This is a command, so point to it */
	ss = (void *)&miopb->iopb_SCSI[0];
	szero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = slp->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);

	miopb->iopb_CMD = IOPB_SCSI;
	miopb->iopb_OPTION = OPT_READ;
	miopb->iopb_NVCT = (u_char)sc->sc_nvec;
	miopb->iopb_EVCT = (u_char)sc->sc_evec;
	miopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	miopb->iopb_ADDR = ADDR_MOD;
	LV(miopb->iopb_BUFF, kvtop((vaddr_t)&xs->sense));
	LV(miopb->iopb_LENGTH, sizeof(struct scsi_sense_data));

	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(miopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) +
	    sizeof(struct scsi_sense);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	s = splbio();
	do_vspoll(sc, 0);
	/*
	if (xs->cmd->opcode != PREVENT_ALLOW) {
		xs->error = XS_SENSE;
	}
	*/
	xs->status = riopb->iopb_STATUS >> 8;
d450 1
a450 1
	scsi_print_sense(xs, 2);
d452 1
a452 1
	splx(s);
d457 1
a457 1
	struct vs_softc *sc;
d459 2
a460 2
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_CQE *cqep;
d462 1
a462 1
	cqep = (M328_CQE *)&sc->sc_vsreg->sh_CQE[mcsb->mcsb_QHDP];
d464 6
a469 6
	if (cqep->cqe_QECR & M_QECR_GO)
		return NULL; /* Hopefully, this will never happen */
	mcsb->mcsb_QHDP++;
	if (mcsb->mcsb_QHDP == NUM_CQE) mcsb->mcsb_QHDP = 0;
	szero(cqep, sizeof(M328_CQE));
	return cqep;
d474 1
a474 1
	struct vs_softc *sc;
d476 12
a487 12
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	int slot;

	if (mcsb->mcsb_QHDP == 0) {
		slot = NUM_CQE;
	} else {
		slot = mcsb->mcsb_QHDP - 1;
	}
	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_IOPB[slot];
	szero(iopb, sizeof(M328_IOPB));
	return iopb;
d492 1
a492 1
	struct vs_softc *sc;
d494 104
a597 105
	M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	M328_WQCF *wiopb = (M328_WQCF *)&sc->sc_vsreg->sh_MCE_IOPB;
	u_short i, crsw;
	int failed = 0;

	CRB_CLR_DONE(CRSW);
	szero(cib, sizeof(M328_CIB));
	mcsb->mcsb_QHDP = 0;
	sc->sc_qhp = 0;
	cib->cib_NCQE = 10;
	cib->cib_BURST = 0;
	cib->cib_NVECT = sc->sc_ipl << 8;
	cib->cib_NVECT |= sc->sc_nvec;
	cib->cib_EVECT = sc->sc_ipl << 8;
	cib->cib_EVECT |= sc->sc_evec;
	cib->cib_PID = 0x07;
	cib->cib_SID = 0x00;
	cib->cib_CRBO = OFF(crb);
	cib->cib_SELECT_msw = HI(SELECTION_TIMEOUT);
	cib->cib_SELECT_lsw = LO(SELECTION_TIMEOUT);
	cib->cib_WQ0TIMO_msw = HI(4);
	cib->cib_WQ0TIMO_lsw = LO(4);
	cib->cib_VMETIMO_msw = 0; /*HI(VME_BUS_TIMEOUT);*/
	cib->cib_VMETIMO_lsw = 0; /*LO(VME_BUS_TIMEOUT);*/
	cib->cib_SBRIV = sc->sc_ipl << 8;
	cib->cib_SBRIV |= sc->sc_evec;
	cib->cib_SOF0 = 0x15;
	cib->cib_SRATE0 = 100/4;
	cib->cib_SOF1 = 0x0;
	cib->cib_SRATE1 = 0x0;

	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	szero(iopb, sizeof(M328_IOPB));
	iopb->iopb_CMD = CNTR_INIT;
	iopb->iopb_OPTION = 0;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;
	iopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	iopb->iopb_ADDR = SHIO_MOD;
	LV(iopb->iopb_BUFF, OFF(cib));
	LV(iopb->iopb_LENGTH, sizeof(M328_CIB));

	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(iopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	do_vspoll(sc, 0);
	CRB_CLR_DONE(CRSW);

	/* initialize work queues */
	for (i=1; i<8; i++) {
		szero(wiopb, sizeof(M328_IOPB));
		wiopb->wqcf_CMD = CNTR_INIT_WORKQ;
		wiopb->wqcf_OPTION = 0;
		wiopb->wqcf_NVCT = (u_char)sc->sc_nvec;
		wiopb->wqcf_EVCT = (u_char)sc->sc_evec;
		wiopb->wqcf_ILVL = 0; /*sc->sc_ipl;*/
		wiopb->wqcf_WORKQ = i;
		wiopb->wqcf_WOPT = (WQO_FOE | WQO_INIT);
		wiopb->wqcf_SLOTS = JAGUAR_MAX_Q_SIZ;
		LV(wiopb->wqcf_CMDTO, 2);

		szero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(wiopb);
		mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
		/* poll for the command to complete */
		do_vspoll(sc, 0);
		if (CRSW & M_CRSW_ER) {
			/*printf("\nerror: queue %d status = 0x%x\n",
			    i, riopb->iopb_STATUS);*/
			/*failed = 1;*/
			CRB_CLR_ER(CRSW);
		}
		CRB_CLR_DONE(CRSW);
		delay(500);
	}
	/* start queue mode */
	CRSW = 0;
	mcsb->mcsb_MCR |= M_MCR_SQM;
	crsw = CRSW;
	do_vspoll(sc, 0);
	if (CRSW & M_CRSW_ER) {
		printf("error: status = 0x%x\n", riopb->iopb_STATUS);
		CRB_CLR_ER(CRSW);
	}
	CRB_CLR_DONE(CRSW);

	if (failed) {
		printf(": failed!\n");
		return;
	}
	/* reset SCSI bus */
	vs_reset(sc);
	/* sync all devices */
	vs_resync(sc);
	printf(": target %d\n", sc->sc_link.adapter_target);
d602 1
a602 1
	struct vs_softc *sc;
d604 31
a634 31
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
	u_short i;

	for (i=0; i<7; i++) {
		szero(devreset, sizeof(M328_DRCF));
		devreset->drcf_CMD = CNTR_DEV_REINIT;
		devreset->drcf_OPTION = 0x00;       /* no interrupts yet... */
		devreset->drcf_NVCT = sc->sc_nvec;
		devreset->drcf_EVCT = sc->sc_evec;
		devreset->drcf_ILVL = 0;
		devreset->drcf_UNIT = i;

		szero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(devreset);
		mc->cqe_IOPB_LENGTH = sizeof(M328_DRCF);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
		/* poll for the command to complete */
		do_vspoll(sc, 0);
		if (riopb->iopb_STATUS) {
			sc->sc_tinfo[i].avail = 0;
		} else {
			sc->sc_tinfo[i].avail = 1;
		}
		if (CRSW & M_CRSW_ER) {
			CRB_CLR_ER(CRSW);
		}
		CRB_CLR_DONE(CRSW);
	}
d639 1
a639 1
	struct vs_softc *sc;
d641 44
a684 34
	u_int s;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  

	szero(reset, sizeof(M328_SRCF));
	reset->srcf_CMD = IOPB_RESET;
	reset->srcf_OPTION = 0x00;       /* no interrupts yet... */
	reset->srcf_NVCT = sc->sc_nvec;
	reset->srcf_EVCT = sc->sc_evec;
	reset->srcf_ILVL = 0;
	reset->srcf_BUSID = 0;
	s = splbio();

	szero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(reset);
	mc->cqe_IOPB_LENGTH = sizeof(M328_SRCF);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	for (;;) {
		do_vspoll(sc, 0);
		/* ack & clear scsi error condition cause by reset */
		if (CRSW & M_CRSW_ER) {
			CRB_CLR_ER(CRSW);
			CRB_CLR_DONE(CRSW);
			riopb->iopb_STATUS = 0;
			break;
		}
		CRB_CLR_DONE(CRSW);
	}
	/* thaw all work queues */
	thaw_queue(sc, 0xFF);
	splx(s);
d687 1
d696 22
a717 20
	struct vs_softc *sc;
	struct scsi_xfer *xs;
	int *status;
{
	int target = -1;
	int lun = -1;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	struct scsi_generic *cmd;
	u_long buf;
	u_long len;
	u_char error;

	target = xs->sc_link->target;
	lun = xs->sc_link->lun;
	cmd = (struct scsi_generic *)&riopb->iopb_SCSI[0];

	VL(buf, riopb->iopb_BUFF);
	VL(len, riopb->iopb_LENGTH);
	*status = riopb->iopb_STATUS >> 8;
	error = riopb->iopb_STATUS & 0xFF;
d720 1
a720 1
	printf("scsi_chk() ");
d722 53
a774 54
	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}

	printf("tgt %d lun %d buf %x len %d status %x ",
	    target, lun, buf, len, riopb->iopb_STATUS);

	if (CRSW & M_CRSW_EX) {
		printf("[ex]");
	}
	if (CRSW & M_CRSW_QMS) {
		printf("[qms]");
	}
	if (CRSW & M_CRSW_SC) {
		printf("[sc]");
	}
	if (CRSW & M_CRSW_SE) {
		printf("[se]");
	}
	if (CRSW & M_CRSW_AQ) {
		printf("[aq]");
	}
	if (CRSW & M_CRSW_ER) {
		printf("[er]");
	}
	printf("\n");
d776 12
a787 12
	if (len != xs->datalen) {
		xs->resid = xs->datalen - len;
	} else {
		xs->resid = 0;
	}

	if (error == SCSI_SELECTION_TO) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		*status = -1;
	}
	return 1;
d790 3
a792 3
void
vs_intr(arg)
	void *arg;
d794 8
a801 7
	struct vs_softc *sc = (struct vs_softc *)arg;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	struct scsi_xfer *xs;
	M328_CMD *m328_cmd;
	unsigned long loc;
	int status;
	int s;
d803 1
a803 4
	s = splbio();
	/* Got a valid interrupt on this device */

	VL(loc, crb->crb_CTAG);
d805 2
a806 2
	printf("Interrupt!!! ");
	printf("loc == 0x%x\n", loc);
d808 13
a820 13
	/*
	 * If this is a controller error, there won't be a m328_cmd
	 * pointer in the CTAG feild.  Bad things happen if you try 
	 * to point to address 0.  Controller error should be handled
	 * in vsdma.c  I'll change this soon - steve.
	 */
	if (loc) {
		m328_cmd = (M328_CMD *)loc;
		xs = m328_cmd->xs;
		if (m328_cmd->top_sg_list) {
			vs_dealloc_scatter_gather(m328_cmd->top_sg_list);
			m328_cmd->top_sg_list = (M328_SG)0;
		}
d822 6
a827 6
		FREE(m328_cmd, M_DEVBUF); /* free the command tag */
		if (vs_checkintr (sc, xs, &status)) {
			vs_scsidone(xs, status);
		}
	}
	splx(s);
d835 1
a835 1
vs_alloc_scatter_gather()
d837 1
a837 1
	M328_SG sg;
d839 2
a840 2
	MALLOC(sg, M328_SG, sizeof(struct m328_sg), M_DEVBUF, M_WAITOK);
	bzero(sg, sizeof(struct m328_sg));
d842 1
a842 1
	return (sg);
d846 1
a846 2
vs_dealloc_scatter_gather(sg)
	M328_SG sg;
d848 1
a848 1
	int i;
d850 6
a855 6
	if (sg->level > 0) {
		for (i = 0; sg->down[i] && i<MAX_SG_ELEMENTS; i++) {
			vs_dealloc_scatter_gather(sg->down[i]);
		}
	}
	FREE(sg, M_DEVBUF);
d859 3
a861 4
vs_link_sg_element(element, phys_add, len)
	sg_list_element_t *element;
	vaddr_t phys_add;
	int len;
d863 6
a868 7

	element->count.bytes = len;
	LV(element->address, phys_add);
	element->link = 0; /* FALSE */
	element->transfer_type = NORMAL_TYPE;
	element->memory_type = LONG_TRANSFER;
	element->address_modifier = 0xD;
d872 3
a874 4
vs_link_sg_list(list, phys_add, elements)
	sg_list_element_t *list;
	vaddr_t phys_add;
	int elements;
d877 6
a882 6
	list->count.scatter.gather  = elements;
	LV(list->address, phys_add);
	list->link = 1;    /* TRUE */
	list->transfer_type = NORMAL_TYPE;
	list->memory_type = LONG_TRANSFER;
	list->address_modifier = 0xD;
d885 1
d888 2
a889 2
	struct scsi_xfer *xs;
	M328_IOPB  *iopb;              /* the iopb */
d891 18
a908 25
	M328_SG   sg;
	vaddr_t starting_point_virt, point_virt, virt;
	paddr_t starting_point_phys, point1_phys, point2_phys;
	u_int len;
	int level;

	sg = (M328_SG)0;   /* Hopefully we need no scatter/gather list */

	/*
	 * We have the following things:
	 * virt			the virtual address of the contiguous virtual
	 *			memory block
	 * len			the length of the contiguous virtual memory
	 *			block
	 * starting_point_virt	the virtual address of the contiguous
	 *			*physical* memory block
	 * starting_point_phys	the *physical* address of the contiguous
	 *			*physical* memory block
	 * point_virt		the pointer to the virtual memory we are
	 *			checking at the moment
	 * point1_phys		the pointer to the *physical* memory we are
	 *			checking at the moment
	 * point2_phys		the pointer to the *physical* memory we are
	 *			checking at the moment
	 */
d910 29
a938 43
	level = 0;
	virt = starting_point_virt = (vaddr_t)xs->data;
	point1_phys = starting_point_phys = kvtop((vaddr_t)xs->data);
	len = xs->datalen;

	/*
	 * Check if we need scatter/gather
	*/
	if (len > PAGE_SIZE) {
		for (level = 0, point_virt = round_page(starting_point_virt+1);
			/* if we do already scatter/gather we have to stay in
			   the loop and jump */
		    point_virt < virt + (vaddr_t)len || sg;
		    point_virt += PAGE_SIZE) {	/* out later */

			point2_phys = kvtop(point_virt);

			if ((point2_phys - trunc_page(point1_phys) - PAGE_SIZE) ||
			    /* physical memory is not contiguous */
			    (point_virt - starting_point_virt >=
			    MAX_SG_BLOCK_SIZE && sg)) {
				/* we only can access (1<<16)-1 bytes in
				   scatter/gather_mode */
				if (point_virt - starting_point_virt >=
				    MAX_SG_BLOCK_SIZE) {
					/* We were walking too far for one
					   scatter/gather block ... */
					assert( MAX_SG_BLOCK_SIZE > PAGE_SIZE );
					point_virt =
					    trunc_page(starting_point_virt +
						MAX_SG_BLOCK_SIZE-1);
					/* So go back to the beginning of the
					   last matching page and gererate the
					   physadress of this location for the
					   next time. */
					point2_phys = kvtop(point_virt);
				}

				if (!sg) {
					/* We allocate our fist scatter/gather
					   list */
					sg = vs_alloc_scatter_gather();
				}
d940 6
a945 4
				if (sg->elements >= MAX_SG_ELEMENTS) {
					vs_dealloc_scatter_gather(sg);
					return (NULL);
				}
d947 24
a970 31
				while (sg->elements >= MAX_SG_ELEMENTS) {
					/* If the list full in this layer ? */
					if (!sg->up) {
						sg->up =
						    vs_alloc_scatter_gather();
						sg->up->level = sg->level+1;
						sg->up->down[0] = sg;
						sg->up->elements = 1;
					}
					/* link this full list also in physical
					   memory */
					vs_link_sg_list(
					    &(sg->up->list[
						sg->up->elements - 1]), 
					    kvtop((vaddr_t)sg->list),
					    sg->elements);
					sg = sg->up;      /* Climb up */
				}
				/* As long as we are not a the base level */
				while (sg->level) { 
					int i;

					i = sg->elements;
					/* We need a new element */
					sg->down[i] =
					    vs_alloc_scatter_gather();  
					sg->down[i]->level = sg->level - 1;
					sg->down[i]->up = sg;
					sg->elements++;
					sg = sg->down[i]; /* Climb down */
				}
d973 45
a1017 48
				if (point_virt < virt+(vaddr_t)len) {
					/* linking element */
					vs_link_sg_element(
					    &(sg->list[sg->elements]), 
					    starting_point_phys, 
					    point_virt-starting_point_virt);
					sg->elements++;
				} else {
					/* linking last element */
					vs_link_sg_element(
					    &(sg->list[sg->elements]), 
					    starting_point_phys, 
					    (vaddr_t)(virt + len) -
					        starting_point_virt);
					sg->elements++;
					break;
					/* We have now collected all blocks */
				}
				starting_point_virt = point_virt;
				starting_point_phys = point2_phys;
			}
			point1_phys = point2_phys;
		}
	}

	/*
	 * Climb up along the right side of the tree until we reach the top.
	 */

	if (sg) {
		while (sg->up) {
			/* link this list also in physical memory */
			vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
			    kvtop((vaddr_t)sg->list), sg->elements);
			sg = sg->up;                   /* Climb up */
		}

		iopb->iopb_OPTION |= M_OPT_SG;
		iopb->iopb_ADDR |= M_ADR_SG_LINK;
		LV(iopb->iopb_BUFF, kvtop((vaddr_t)sg->list));
		LV(iopb->iopb_LENGTH, sg->elements);
		LV(iopb->iopb_SGTTL, len);
	} else { 
		/* no scatter/gather neccessary */
		LV(iopb->iopb_BUFF, starting_point_phys);
		LV(iopb->iopb_LENGTH, len);
	}
	return (sg);
d1019 1
@


1.1.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.1.2.5 2003/03/27 23:32:16 niklas Exp $ */
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d67 1
a67 1
int do_vspoll(struct vs_softc *, int, int);
d142 1
a142 1
do_vspoll(sc, to, canreset)
a144 1
	int canreset;
d161 2
a162 4
				if (canreset) {
					vs_reset(sc);
					vs_resync(sc);
				}
d183 1
a183 1
		if (do_vspoll(sc, to, 1)) break;
d256 1
d436 1
a436 1
	do_vspoll(sc, 0, 1);
d541 1
a541 1
	do_vspoll(sc, 0, 1);
d563 1
a563 1
		do_vspoll(sc, 0, 1);
d577 1
a577 1
	do_vspoll(sc, 0, 1);
d619 1
a619 1
		do_vspoll(sc, 0, 0);
d657 1
a657 1
		do_vspoll(sc, 0, 0);
d937 3
a939 3
					   last matching page and generate the
					   physical address of this location
					   for the next time. */
d1030 1
a1030 1
		/* no scatter/gather necessary */
@


1.1.2.8
log
@Merge with the trunk
@
text
@a298 4
		if (cqep == NULL) {
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d301 4
d446 1
a446 1
	scsi_print_sense(xs);
d477 1
a477 1
		slot = NUM_CQE - 1;
@


