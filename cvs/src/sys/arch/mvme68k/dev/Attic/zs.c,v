head	1.36;
access;
symbols
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.14
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.12
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.10
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.8
	OPENBSD_5_0:1.34.0.6
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.4
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.26.0.6
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.12
	UBC:1.9.0.10
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.35;

1.35
date	2013.12.01.21.56.42;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.28.14.13.29;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.11.20.46.50;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.15.20.04.36;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.01.11.59.39;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.24.22.43.16;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.01.09.55.49;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.15.05.57.39;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.31.22.27.34;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.30.22.29.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.30.09.50.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.02.17.57.29;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.02.22.49.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.26.23.31.59;	author deraadt;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	2000.01.29.04.11.25;	author smurph;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.01.27.03.28.38;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.27.03.06.50;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	96.06.11.10.17.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.11.10.15.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.11.06.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.10;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.43.00;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.04.18.16.10.33;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	;

1.9.10.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: zs.c,v 1.35 2013/12/01 21:56:42 miod Exp $	*/
/*	$NetBSD: zs.c,v 1.29 2001/05/30 15:24:24 lukem Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Zilog Z8530 Dual UART driver (machine-dependent part)
 *
 * Runs two serial lines per chip using slave drivers.
 * Plain tty/async lines use the zstty slave.
 * Sun keyboard/mouse uses the zskbd/zsms slaves.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/z8530var.h>

#ifdef DDB
#include <ddb/db_var.h>
#endif

#include <dev/cons.h>

#include <dev/ic/z8530reg.h>

#include "mc.h"
#include "pcc.h"

#if NPCC > 0
#include <mvme68k/dev/pccreg.h>
#endif
#if NMC > 0
#include <mvme68k/dev/mcreg.h>
#endif

#include "zs.h"

/*
 * Some warts needed by z8530tty.c -
 * The default parity REALLY needs to be the same as the PROM uses,
 * or you can not see messages done with printf during boot-up...
 */
int zs_def_cflag = (CREAD | CS8 | HUPCL);
int zs_major = 12;

#define PCLK_FREQ_147	5000000
#define PCLK_FREQ_162	10000000

#define	ZS_DELAY()

/* physical layout on the MVME147 */
struct zschan_147 {
	volatile uint8_t	zc_csr;
	volatile uint8_t	zc_data;
};

/* physical layout on the MVME1x2 */
struct zschan_162 {
	uint8_t			zc_xxx0;
	volatile uint8_t	zc_csr;
	uint8_t			zc_xxx1;
	volatile uint8_t	zc_data;
};

#if NMC > 0
/*
 * MC rev 0x01 has a bug and can not access the data register directly.
 */
int mc_rev1_bug = 0;
#endif

static uint8_t zs_init_reg[17] = {
	0,				/* 0: CMD (reset, etc.) */
	0,				/* 1: No interrupts yet. */
	0,				/* 2: IVECT */
	ZSWR3_RX_8 | ZSWR3_RX_ENABLE,
	ZSWR4_CLK_X16 | ZSWR4_ONESB,
	ZSWR5_TX_8 | ZSWR5_TX_ENABLE,
	0,				/* 6: TXSYNC/SYNCLO */
	0,				/* 7: RXSYNC/SYNCHI */
	0,				/* 8: alias for data port */
	ZSWR9_MASTER_IE ,
	0,				/*10: Misc. TX/RX control bits */
	ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD,
	0,				/*12: BAUDLO (default=9600) */
	0,				/*13: BAUDHI (default=9600) */
	ZSWR14_BAUD_ENA | ZSWR14_BAUD_FROM_PCLK,
	ZSWR15_BREAK_IE,
	ZSWR7P_TX_FIFO			/*7': TX FIFO interrupt level */
};

/* Console ops */
cons_decl(zs);
struct consdev zs_consdev = {
	zscnprobe,
	zscninit,
	zscngetc,
	zscnputc,
	zscnpollc,
	NULL,
};

static int zs_consunit = -1;
static int zs_conschan = -1;


/****************************************************************
 * Autoconfig
 ****************************************************************/

/* Definition of the driver for autoconfig. */
int	zs_match(struct device *, void *, void *);
void	zs_attach(struct device *, struct device *, void *);
int	zs_print(void *, const char *);

struct cfdriver zs_cd = {
	NULL, "zs", DV_TTY
};

const struct cfattach zs_ca = {
	sizeof(struct zsc_softc), zs_match, zs_attach
};

/* Interrupt handlers. */
int	zshard(void *);
void	zssoft(void *);

int	zs_get_speed(struct zs_chanstate *);

/*
 * Is the zs chip present?
 */
int
zs_match(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;
	unsigned char *zstest = (unsigned char *)ca->ca_vaddr;

	/* 
	 * If zs1 is in the config, we must test to see if it really exists.  
	 * Some 162s only have one scc device, but the memory location for 
	 * the second scc still checks valid and every byte contains 0xFF. So 
	 * this is what we test with for now. XXX - smurph
	 */
	if (!badvaddr((vaddr_t)ca->ca_vaddr, 1))
		if (*zstest == 0xFF)
			return (0);
		else
			return (1);
	else
		return (0);
}

void
zs_attach(struct device *parent, struct device *self, void *aux)
{
	struct zsc_softc *zsc = (void *)self;
	struct confargs *ca = aux;
	struct zsc_attach_args zsc_args;
	struct zs_chanstate *cs;
	int s, channel, has_fifo;
	int pclk;
	uint8_t ir;

	switch (cputyp) {
	default:
#ifdef MVME147
	case CPU_147:
		pclk = PCLK_FREQ_147;
		break;
#endif
#if defined(MVME162) || defined(MVME172)
	case CPU_162:
	case CPU_172:
		pclk = PCLK_FREQ_162;
		break;
#endif
	}

	switch (ca->ca_bustype) {
#if NPCC > 0
	case BUS_PCC:
		zs_init_reg[9] |= ZSWR9_NO_VECTOR;
		break;
#endif
#if NMC > 0
	case BUS_MC:
		if (sys_mc->mc_chiprev != 0x01)
			mc_rev1_bug = 0;
		zs_init_reg[2] = MC_VECBASE + MCV_ZS;
		break;
#endif
	}

	/*
	 * Initialize software state for each channel.
	 */
	for (channel = 0; channel < 2; channel++) {
		zsc_args.channel = channel;
		cs = &zsc->zsc_cs_store[channel];
		zsc->zsc_cs[channel] = cs;

		cs->cs_channel = channel;
		cs->cs_private = NULL;
		cs->cs_ops = &zsops_null;
		cs->cs_brg_clk = pclk / 16;

		switch (cputyp) {
		default:
#ifdef MVME147
		case CPU_147:
		    {
			struct zschan_147 *zc;

			zc = (struct zschan_147 *)ca->ca_vaddr;
			cs->cs_reg_csr = &zc[channel ^ 1].zc_csr;
			cs->cs_reg_data = &zc[channel ^ 1].zc_data;
		    }
			break;
#endif
#if defined(MVME162) || defined(MVME172)
		case CPU_162:
		case CPU_172:
		    {
			struct zschan_162 *zc;

			zc = (struct zschan_162 *)ca->ca_vaddr;
			cs->cs_reg_csr = &zc[channel ^ 1].zc_csr;
			cs->cs_reg_data = &zc[channel ^ 1].zc_data;
		    }
			break;
#endif
		}

		/*
		 * Figure out whether this chip is a 8530 or a 85230.
		 */
		if (channel == 0) {
			zs_write_reg(cs, 15, ZSWR15_ENABLE_ENHANCED);
			has_fifo = zs_read_reg(cs, 15) & ZSWR15_ENABLE_ENHANCED;

			if (has_fifo) {
				zs_write_reg(cs, 15, 0);
				printf(": 85230\n");
			} else
				printf(": 8530\n");
		}

		if (has_fifo)
			zs_init_reg[15] |= ZSWR15_ENABLE_ENHANCED;
		else
			zs_init_reg[15] &= ~ZSWR15_ENABLE_ENHANCED;

		if (self->dv_unit == zs_consunit && channel == zs_conschan) {
			zsc_args.consdev = &zs_consdev;
			zsc_args.hwflags =
			    ZS_HWFLAG_CONSOLE | ZS_HWFLAG_USE_CONSDEV;
		} else {
			zsc_args.consdev = NULL;
			zsc_args.hwflags = 0;
		}

		bcopy(zs_init_reg, cs->cs_creg, 16);
		bcopy(zs_init_reg, cs->cs_preg, 16);

		cs->cs_defspeed = zs_get_speed(cs);
		cs->cs_defcflag = zs_def_cflag;

		/* Make these correspond to cs_defcflag (-crtscts) */
		cs->cs_rr0_dcd = ZSRR0_DCD;
		cs->cs_rr0_cts = 0;
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;

		/*
		 * Clear the master interrupt enable.
		 * The INTENA is common to both channels,
		 * so just do it on the A channel.
		 */
		if (channel == 0) {
			zs_write_reg(cs, 9, 0);
		}

		/*
		 * Look for a child driver for this channel.
		 * The child attach will setup the hardware.
		 */
		if (!config_found(&zsc->zsc_dev, (void *)&zsc_args, zs_print)) {
			/* No sub-driver.  Just reset it. */
			u_char reset = (channel == 0) ?
				ZSWR9_A_RESET : ZSWR9_B_RESET;
			s = splzs();
			zs_write_reg(cs,  9, reset);
			splx(s);
		} 
	}

	/*
	 * Now safe to install interrupt handlers.
	 */
	zsc->zsc_ih.ih_fn = zshard;
	zsc->zsc_ih.ih_arg = zsc;
	zsc->zsc_ih.ih_ipl = IPL_ZS;
	zsc->zsc_ih.ih_wantframe = 0;

	switch (ca->ca_bustype) {
#if NPCC > 0
	case BUS_PCC:
		pccintr_establish(PCCV_ZS, &zsc->zsc_ih, self->dv_xname);
		break;
#endif
#if NMC > 0
	case BUS_MC:
		mcintr_establish(MCV_ZS, &zsc->zsc_ih, self->dv_xname);
		break;
#endif
	}

	zsc->zsc_softih = softintr_establish(IPL_SOFTTTY, zssoft, zsc);

	/*
	 * Set the master interrupt enable and interrupt vector.
	 * (common to both channels, do it on A)
	 */
	cs = zsc->zsc_cs[0];
	s = splhigh();
	/* interrupt vector */
	zs_write_reg(cs, 2, zs_init_reg[2]);
	/* master interrupt control (enable) */
	zs_write_reg(cs, 9, zs_init_reg[9]);
	splx(s);

	switch (ca->ca_bustype) {
#if NPCC > 0
	case BUS_PCC:
		ir = sys_pcc->pcc_zsirq;
		if ((ir & PCC_IRQ_IPL) != 0 && (ir & PCC_IRQ_IPL) != IPL_ZS)
			panic("zs configured at different IPLs");
		sys_pcc->pcc_zsirq = IPL_ZS | PCC_IRQ_IEN | PCC_ZS_PCCVEC;
		break;
#endif
#if NMC > 0
	case BUS_MC:
		ir = sys_mc->mc_zsirq;
		if ((ir & MC_IRQ_IPL) != 0 && (ir & MC_IRQ_IPL) != IPL_ZS)
			panic("zs configured at different IPLs");
		sys_mc->mc_zsirq = IPL_ZS | MC_IRQ_IEN;
		break;
#endif
	}
}

int
zs_print(void *aux, const char *name)
{
	struct zsc_attach_args *args = aux;

	if (name != NULL)
		printf("%s: ", name);

	if (args->channel != -1)
		printf(" channel %d", args->channel);

	return (UNCONF);
}

int
zshard(void *arg)
{
	struct zsc_softc *zsc = (struct zsc_softc *)arg;
	int rr3, rval;

	rval = 0;
	while ((rr3 = zsc_intr_hard(zsc))) {
		/* Count up the interrupts. */
		rval |= rr3;
	}
	if (((zsc->zsc_cs[0] && zsc->zsc_cs[0]->cs_softreq) ||
	     (zsc->zsc_cs[1] && zsc->zsc_cs[1]->cs_softreq)) &&
	    zsc->zsc_softih) {
		softintr_schedule(zsc->zsc_softih);
	}
	return (rval);
}

void
zssoft(void *arg)
{
	struct zsc_softc *zsc = (struct zsc_softc *)arg;
	int s;

	/* Make sure we call the tty layer at spltty. */
	s = spltty();
	zsc_intr_soft(zsc);
	splx(s);
}

/*
 * Compute the current baud rate given a ZS channel.
 */
int
zs_get_speed(struct zs_chanstate *cs)
{
	int tconst;

	tconst = zs_read_reg(cs, 12);
	tconst |= zs_read_reg(cs, 13) << 8;
	return (TCONST_TO_BPS(cs->cs_brg_clk, tconst));
}

/*
 * MD functions for setting the baud rate and control modes.
 */
int
zs_set_speed(struct zs_chanstate *cs, int bps)
{
	int tconst, real_bps;

	if (bps == 0)
		return (0);

#ifdef	DIAGNOSTIC
	if (cs->cs_brg_clk == 0)
		panic("zs_set_speed");
#endif

	tconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);
	if (tconst < 0)
		return (EINVAL);

	/* Convert back to make sure we can do it. */
	real_bps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);

	/* XXX - Allow some tolerance here? */
	if (real_bps != bps)
		return (EINVAL);

	cs->cs_preg[12] = tconst;
	cs->cs_preg[13] = tconst >> 8;

	/* Caller will stuff the pending registers. */
	return (0);
}

int
zs_set_modes(struct zs_chanstate *cs, int cflag)
{
	int s;

	/*
	 * Output hardware flow control on the chip is horrendous:
	 * if carrier detect drops, the receiver is disabled, and if
	 * CTS drops, the transmitter is stopped IN MID CHARACTER!
	 * Therefore, NEVER set the HFC bit, and instead use the
	 * status interrupt to detect CTS changes.
	 */
	s = splzs();
	cs->cs_rr0_pps = 0;
	if ((cflag & (CLOCAL | MDMBUF)) != 0) {
		cs->cs_rr0_dcd = 0;
		if ((cflag & MDMBUF) == 0)
			cs->cs_rr0_pps = ZSRR0_DCD;
	} else
		cs->cs_rr0_dcd = ZSRR0_DCD;
	if ((cflag & CRTSCTS) != 0) {
		cs->cs_wr5_dtr = ZSWR5_DTR;
		cs->cs_wr5_rts = ZSWR5_RTS;
		cs->cs_rr0_cts = ZSRR0_CTS;
	} else if ((cflag & MDMBUF) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_DCD;
	} else {
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;
		cs->cs_rr0_cts = 0;
	}
	splx(s);

	/* Caller will stuff the pending registers. */
	return (0);
}


/*
 * Read or write the chip with suitable delays.
 */

uint8_t
zs_read_reg(struct zs_chanstate *cs, uint8_t reg)
{
	uint8_t val;

	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return (val);
}

void
zs_write_reg(struct zs_chanstate *cs, uint8_t reg, uint8_t val)
{
	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	*cs->cs_reg_csr = val;
	ZS_DELAY();
}

uint8_t
zs_read_csr(struct zs_chanstate *cs)
{
	uint8_t val;

	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return (val);
}

void
zs_write_csr(struct zs_chanstate *cs, uint8_t val)
{
	*cs->cs_reg_csr = val;
	ZS_DELAY();
}

uint8_t
zs_read_data(struct zs_chanstate *cs)
{
	uint8_t val;

#if NMC > 0
	if (mc_rev1_bug)
		return zs_read_reg(cs, 8);
#endif
	val = *cs->cs_reg_data;
	ZS_DELAY();
	return (val);
}

void 
zs_write_data(struct zs_chanstate *cs, uint8_t val)
{
#if NMC > 0
	if (mc_rev1_bug) {
		zs_write_reg(cs, 8, val);
		return;
	}
#endif
	*cs->cs_reg_data = val;
	ZS_DELAY();
}

/*
 * Handle user request to enter kernel debugger.
 */
void
zs_abort(struct zs_chanstate *cs)
{
	int rr0;

	/* Wait for end of break to avoid PROM abort. */
	/* XXX - Limit the wait? */
	do {
		rr0 = zs_read_csr(cs);
	} while (rr0 & ZSRR0_BREAK);

#if defined(KGDB)
	zskgdb(cs);
#elif defined(DDB)
	Debugger();
#endif
}

/****************************************************************
 * Console support functions
 ****************************************************************/

struct zs_consptr {
	volatile uint8_t *zc_csr;
	volatile uint8_t *zc_data;
};

static struct zs_consptr zs_consptr;

void
zscnprobe(struct consdev *cp)
{
	switch (cputyp) {
	default:
		return;
#ifdef MVME147
	case CPU_147:
		break;
#endif
#if defined(MVME162) || defined(MVME172)
	case CPU_162:
	case CPU_172:
		break;
#endif
	}

	cp->cn_dev = makedev(zs_major, 0);
	cp->cn_pri = CN_LOWPRI;
}

void
zscninit(struct consdev *cp)
{
	switch (cputyp) {
	default:
#ifdef MVME147
	case CPU_147:
	    {
		struct zschan_147 *zc;

		zc = (struct zschan_147 *)IIOV(ZS0_PHYS_147);
		zs_consptr.zc_csr = &zc[1].zc_csr;
		zs_consptr.zc_data = &zc[1].zc_data;
	    }
#if NMC > 0
	    	mc_rev1_bug = 0;
#endif
		break;
#endif
#if defined(MVME162) || defined(MVME172)
	case CPU_162:
	case CPU_172:
	    {
		struct zschan_162 *zc;

		zc = (struct zschan_162 *)IIOV(ZS0_PHYS_162);
		zs_consptr.zc_csr = &zc[1].zc_csr;
		zs_consptr.zc_data = &zc[1].zc_data;
	    }
		break;
#endif
	}

	zs_consunit = 0;
	zs_conschan = 0;
}

/*
 * Polled console input putchar.
 */
int
zscngetc(dev_t dev)
{
	struct zs_consptr *zc = &zs_consptr;
	int s, c, rr0;

	s = splhigh();
	/* Wait for a character to arrive. */
	do {
		rr0 = *zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_RX_READY) == 0);

#if NMC > 0
	if (mc_rev1_bug) {
		*zc->zc_csr = 8;
		ZS_DELAY();
		c = *zc->zc_csr;
		ZS_DELAY();
	} else
#endif
	{
		c = *zc->zc_data;
		ZS_DELAY();
	}
	splx(s);

	return (c);
}

/*
 * Polled console output putchar.
 */
void
zscnputc(dev_t dev, int c)
{
	struct zs_consptr *zc = &zs_consptr;
	int s, rr0;

	s = splhigh();

	/* Wait for transmitter to become ready. */
	do {
		rr0 = *zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_TX_READY) == 0);

	/*
	 * Send the next character.
	 */
#if NMC > 0
	if (mc_rev1_bug) {
		*zc->zc_csr = 8;
		ZS_DELAY();
		*zc->zc_csr = c;
		ZS_DELAY();
	} else
#endif
	{
		*zc->zc_data = c;
		ZS_DELAY();
	}

	splx(s);
}

void
zscnpollc(dev_t dev, int on)
{
}
@


1.35
log
@switch mvme68k to the MI zs(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.24 2013/04/21 14:44:16 sebastia Exp $	*/
@


1.34
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 2
a2 1
/*	$OpenBSD: zs.c,v 1.33 2010/06/28 14:13:29 deraadt Exp $ */
d4 2
a5 4
/*
 * Copyright (c) 2000 Steve Murphree, Jr.
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1993 Paul Mackerras.
d8 3
d20 11
a30 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d32 1
d34 5
a38 1
 * Serial I/O via an SCC,
d40 1
d42 4
d47 1
d50 1
a50 3
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/kernel.h>
a51 2
#include <sys/fcntl.h>
#include <sys/device.h>
d56 1
d64 1
a64 1
#include <mvme68k/dev/scc.h>
d66 1
a67 1
#include "mc.h"
d78 7
a84 4
#define NZSLINE		(NZS*2)

#define RECV_BUF	512
#define ERROR_DET	0xed
d86 2
a87 1
#define TS_DRAIN	TS_FLUSH /* waiting for output to drain */
d89 1
a89 1
#define splzs()		_splraise(PSL_S | PSL_IPL4)
d91 4
a94 19
struct zs {
	short    flags;		/* see below */
	char     rr0;		/* holds previous CTS, DCD state */
	u_char      imask;		/* mask for input chars */
	int      nzs_open;	/* # opens as /dev/zsn */
	struct tty  *tty;		/* link to tty structure */
	struct sccregs scc;		/* SCC shadow registers */
	u_char      *rcv_get;
	u_char      *rcv_put;
	u_char      *rcv_end;
	volatile int   rcv_count;
	int      rcv_len;
	char     *send_ptr;
	int      send_count;
	int      sent_count;
	volatile char  modem_state;
	volatile char  modem_change;
	volatile short hflags;
	char     rcv_buf[RECV_BUF];
d97 6
a102 19
/* Bits in flags */
#define ZS_SIDEA	1
#define ZS_INITED	2
#define ZS_INTEN	4
#define ZS_RESET	8
#define ZS_CONSOLE	0x20

/* Bits in hflags */
#define ZH_OBLOCK	1	/* output blocked by CTS */
#define ZH_SIRQ		2	/* soft interrupt request */
#define ZH_TXING	4	/* transmitter active */
#define ZH_RXOVF	8	/* receiver buffer overflow */

struct zssoftc {
	struct device	 sc_dev;
	struct zs	 sc_zs[2];
	struct intrhand	 sc_ih;
	void		*sc_softih;
	int      	 sc_flags;
a103 1
#define ZSSF_85230	1
d105 6
a110 1
struct tty *zs_tty[NZSLINE];
d112 19
a130 4
struct   termios zs_cons_termios;
int   zs_cons_unit = 0;
int   zs_is_console = 0;
struct   sccregs *zs_cons_scc;
d132 10
a141 5
void  zsstart(struct tty *);
int   zsparam(struct tty *, struct termios *);
int   zsirq(void *);
int   zsregs(vaddr_t, int, volatile u_char **, volatile u_char **);
int   zspclk(void);
d143 2
a144 1
void  zs_softint(void *);
a145 2
#define zsunit(dev)	(minor(dev) >> 1)
#define zsside(dev)	(minor(dev) & 1)
d147 8
a154 5
/*
 * Autoconfiguration stuff.
 */
void  zsattach(struct device *, struct device *, void *);
int   zsmatch(struct device *, void *, void *);
d156 2
a157 2
struct cfattach zs_ca = {
	sizeof(struct zssoftc), zsmatch, zsattach
d160 2
a161 2
struct cfdriver zs_cd = {
	NULL, "zs", DV_TTY
d164 5
a168 14
void	zs_ttydef(struct zs *);
struct tty *zstty(dev_t);
void	zs_init(struct zs *);
void	zscc_init(struct zs *, struct termios *);
int	zscc_params(struct sccregs *, struct termios *);
int	zscc_mget(struct sccregs *);
void	zscc_mset(struct sccregs *, int);
void	zscc_mclr(struct sccregs *, int);
void	zs_drain(struct zs *);
void	zs_unblock(struct tty *);
void	zs_txint(struct zssoftc *, struct zs *);
void	zs_rxint(struct zssoftc *, struct zs *);
void	zs_extint(struct zssoftc *, struct zs *);
cons_decl(zs);
d170 3
d174 1
a174 3
zsmatch(parent, vcf, args)
	struct device *parent;
	void  *vcf, *args;
d176 1
a176 1
	struct confargs *ca = args;
d178 1
d195 1
a195 3
zsattach(parent, self, args)
	struct device *parent, *self;
	void  *args;
d197 22
a218 17
	struct zssoftc *sc;
	struct zs *zp, *zc;
	u_char  ir;
	volatile struct scc *scc;
	volatile u_char *scc_cr, *scc_dr;
	struct confargs *ca = args;
	int     zs_level = ca->ca_ipl;
	int   size;
	static int initirq = 0;

	sc = (struct zssoftc *) self;

	/* connect the interrupt */
	sc->sc_ih.ih_fn = zsirq;
	sc->sc_ih.ih_arg = (void *)self->dv_unit;
	sc->sc_ih.ih_ipl = zs_level;
	sc->sc_ih.ih_wantframe = 0;
d223 1
a223 1
		pccintr_establish(PCCV_ZS, &sc->sc_ih, self->dv_xname);
d228 3
a230 8
		if (sys_mc->mc_chiprev == 0x01)
			/* 
			 * MC rev 0x01 has a bug and can not access scc regs directly. 
			 * Macros will do the right thing based on the value of 
			 * mc_rev1_bug - XXX smurph 
			 */
			mc_rev1_bug = 1; /* defined in scc.h */
		mcintr_establish(MCV_ZS, &sc->sc_ih, self->dv_xname);
a234 3
	zp = &sc->sc_zs[0];
	scc = (volatile struct scc *)ca->ca_vaddr;

d236 1
a236 3
	 * the locations of the control and data register move around
	 * on different MVME models, so we generate independent pointers
	 * to them.
d238 9
a246 1
	size = zsregs(ca->ca_vaddr, 0, &scc_cr, &scc_dr);
d248 88
a335 11
	if (zs_is_console && self->dv_unit == zs_cons_unit) {
		/* SCC is the console - it's already reset */
		zc = zp + zsside(zs_cons_unit);
		zc->scc = *zs_cons_scc;
		zs_cons_scc = &zc->scc;
		zc->flags |= ZS_CONSOLE;
	} else {
		/* reset the SCC */
		*(scc_cr + size) = 0;
		*(scc_cr + size) = 9;
		*(scc_cr + size) = 0xC0;	/* hardware reset of SCC, both sides */
d338 7
a344 10
	/* side A */
	zp->scc.s_cr = scc_cr + size;
	zp->scc.s_dr = scc_dr + size;
	zp->flags |= ZS_SIDEA | ZS_RESET;

	/* side B */
	++zp;
	zp->scc.s_cr = scc_cr;
	zp->scc.s_dr = scc_dr;
	zp->flags |= ZS_RESET;
d346 12
a357 1
	sc->sc_softih = softintr_establish(IPL_SOFTTTY, zs_softint, sc);
d359 1
a359 1
	printf("\n");
d362 2
a363 6
	 * XXX we end up doing this twice... once for
	 * each ZS chip. We should really not turn interrupts on until
	 * we have initialized the last of the two chips. But then we
	 * will need to search the config system to see if we will be
	 * called for the 2nd chip... otherwise, a config without a zs1
	 * would never enable interrupts!
d365 8
d375 6
a380 8
		case BUS_PCC:
			ir = sys_pcc->pcc_zsirq;
			if ((ir & PCC_IRQ_IPL) != 0 && (ir & PCC_IRQ_IPL) != zs_level)
				panic("zs configured at different IPLs");
			if (initirq)
				break;
			sys_pcc->pcc_zsirq = zs_level | PCC_IRQ_IEN | PCC_ZS_PCCVEC;
			break;
d383 6
a388 8
		case BUS_MC:
			ir = sys_mc->mc_zsirq;
			if ((ir & MC_IRQ_IPL) != 0 && (ir & MC_IRQ_IPL) != zs_level)
				panic("zs configured at different IPLs");
			if (initirq)
				break;
			sys_mc->mc_zsirq = zs_level | MC_IRQ_IEN;
			break;
a390 1
	initirq = 1;
d393 2
a394 3
void
zs_ttydef(zp)
	struct zs *zp;
d396 1
a396 1
	struct tty *tp = zp->tty;
d398 5
a402 18
	if ((zp->flags & ZS_CONSOLE) == 0) {
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
	} else
		tp->t_termios = zs_cons_termios;
	ttychars(tp);
	ttsetwater(tp);
	tp->t_oproc = zsstart;
	tp->t_param = zsparam;

	zp->rcv_get = zp->rcv_buf;
	zp->rcv_put = zp->rcv_buf;
	zp->rcv_end = zp->rcv_buf + sizeof(zp->rcv_buf);
	zp->rcv_len = sizeof(zp->rcv_buf) / 2;
}
d404 1
a404 7
struct tty *
zstty(dev)
	dev_t   dev;
{
	if (minor(dev) < NZSLINE)
		return (zs_tty[minor(dev)]);
	return (NULL);
a406 1
/* ARGSUSED */
d408 1
a408 4
zsopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d410 7
a416 15
	register struct tty *tp;
	int     error;
	struct zs *zp;
	struct zssoftc *sc;

	if (zsunit(dev) >= zs_cd.cd_ndevs ||
		 (sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(dev)]) == NULL)
		return (ENODEV);

	zp = &sc->sc_zs[zsside(dev)];
	if (zp->tty == NULL) {
		zp->tty = ttymalloc(0);
		zs_ttydef(zp);
		if (minor(dev) < NZSLINE)
			zs_tty[minor(dev)] = zp->tty;
d418 6
a423 16
	tp = zp->tty;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		zs_init(zp);
		if ((zp->modem_state & SCC_DCD) != 0)
			tp->t_state |= TS_CARR_ON;
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0)
		return (EBUSY);

	error = ((*linesw[tp->t_line].l_open) (dev, tp, p));

	if (error == 0)
		++zp->nzs_open;
	return (error);
d426 2
a427 5
int
zsclose(dev, flag, mode, p)
	dev_t   dev;
	int     flag, mode;
	struct proc *p;
d429 1
a429 3
	struct zs *zp;
	struct tty *tp;
	struct zssoftc *sc;
d432 3
a434 11
	if (zsunit(dev) >= zs_cd.cd_ndevs ||
		 (sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(dev)]) == NULL)
		return (ENODEV);
	zp = &sc->sc_zs[zsside(dev)];
	tp = zp->tty;

	(*linesw[tp->t_line].l_close) (tp, flag, p);
	s = splzs();
	if ((zp->flags & ZS_CONSOLE) == 0 && (tp->t_cflag & HUPCL) != 0)
		ZBIC(&zp->scc, 5, 0x82);		  /* drop DTR, RTS */
	ZBIC(&zp->scc, 3, 1);	/* disable receiver */
a435 3
	ttyclose(tp);
	zp->nzs_open = 0;
	return (0);
d438 3
a440 1
/*ARGSUSED*/
d442 1
a442 4
zsread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int   flag;
d444 1
a444 3
	struct zssoftc *sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(dev)];
	struct zs *zp = &sc->sc_zs[zsside(dev)];
	struct tty *tp = zp->tty;
d446 3
a448 1
	return ((*linesw[tp->t_line].l_read) (tp, uio, flag));
d451 3
a453 1
/*ARGSUSED*/
d455 1
a455 4
zswrite(dev, uio, flag)
	dev_t   dev;
	struct uio *uio;
	int     flag;
d457 1
a457 3
	struct zssoftc *sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(dev)];
	struct zs *zp = &sc->sc_zs[zsside(dev)];
	struct tty *tp = zp->tty;
d459 7
a465 2
	return ((*linesw[tp->t_line].l_write) (tp, uio, flag));
}
d467 3
a469 59
int
zsioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct zssoftc *sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(dev)];
	struct zs *zp = &sc->sc_zs[zsside(dev)];
	struct tty *tp = zp->tty;
	register struct sccregs *scc = &zp->scc;
	register int error, s;

	error = (*linesw[tp->t_line].l_ioctl) (tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = 0;
	s = splzs();
	switch (cmd) {
		case TIOCSDTR:
			ZBIS(scc, 5, 0x80);
			break;
		case TIOCCDTR:
			ZBIC(scc, 5, 0x80);
			break;
		case TIOCSBRK:
			splx(s);
			zs_drain(zp);
			s = splzs();
			ZBIS(scc, 5, 0x10);
			spltty();
			zs_unblock(tp);
			break;
		case TIOCCBRK:
			ZBIC(scc, 5, 0x10);
			break;
		case TIOCMGET:
			*(int *) data = zscc_mget(scc);
			break;
		case TIOCMSET:
			zscc_mset(scc, *(int *) data);
			zscc_mclr(scc, ~*(int *) data);
			break;
		case TIOCMBIS:
			zscc_mset(scc, *(int *) data);
			break;
		case TIOCMBIC:
			zscc_mclr(scc, *(int *) data);
			break;
		default:
			error = ENOTTY;
	}
	splx(s);
	return (error);
}
d471 2
a472 8
int
zsparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct zssoftc *sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &sc->sc_zs[zsside(tp->t_dev)];
	register int s;
d474 3
a476 15
	zs_drain(zp);
	s = splzs();
	zp->imask = zscc_params(&zp->scc, t);
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	if ((tp->t_cflag & CCTS_OFLOW) == 0)
		zp->hflags &= ~ZH_OBLOCK;
	else if ((zp->modem_state & 0x20) == 0)
		zp->hflags |= ZH_OBLOCK;
	spltty();
	zs_unblock(tp);
	splx(s);
	return (0);
}
d478 2
a479 7
void
zsstart(tp)
	struct tty *tp;
{
	struct zssoftc *sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &sc->sc_zs[zsside(tp->t_dev)];
	register int s, n;
d481 2
a482 15
	s = spltty();
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_DRAIN)) == 0) {
		n = ndqb(&tp->t_outq, 0);
		if (n > 0) {
			tp->t_state |= TS_BUSY;
			splzs();
			zp->hflags |= ZH_TXING;
			zp->send_ptr = tp->t_outq.c_cf;
			zp->send_count = n;
			zp->sent_count = 0;
			zs_txint(sc, zp);
			spltty();
		}
	}
	splx(s);
d486 1
a486 3
zsstop(tp, flag)
	struct tty *tp;
	int flag;
d488 1
a488 3
	struct zssoftc *sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &sc->sc_zs[zsside(tp->t_dev)];
	int     s, n;
d490 7
d498 19
a516 8
	zp->send_count = 0;
	n = zp->sent_count;
	zp->sent_count = 0;
	if ((tp->t_state & TS_BUSY) != 0 && (flag & FWRITE) == 0) {
		tp->t_state &= ~TS_BUSY;
		spltty();
		ndflush(&tp->t_outq, n);
		ttwakeupwr(tp);
d519 2
a523 5
void
zs_init(zp)
	struct zs *zp;
{
	register int s;
d525 3
a527 8
	s = splzs();
	zscc_init(zp, &zp->tty->t_termios);
	zp->rr0 = zp->modem_state = ZREAD0(&zp->scc);
	ZBIS(&zp->scc, 1, 0x13);/* ints on tx, rx and ext/status */
	ZBIS(&zp->scc, 9, 8);	/* enable ints */
	zp->flags |= ZS_INTEN;
	splx(s);
}
d529 2
a530 4
void
zscc_init(zp, par)
	struct zs *zp;
	struct termios *par;
d532 1
a532 1
	struct sccregs *scc;
d534 5
a538 11
	scc = &zp->scc;
#if defined(MVME162) || defined(MVME172)
	if (cputyp == CPU_162 || cputyp == CPU_172)
		ZWRITE(scc, 2, MC_VECBASE+MCV_ZS);
#endif
	ZWRITE(scc, 10, 0);
	ZWRITE(scc, 11, 0x50);	/* rx & tx clock = brgen */
	ZWRITE(scc, 14, 3);	/* brgen enabled, from pclk */
	zp->imask = zscc_params(scc, par);
	ZBIS(scc, 5, 0x82);	/* set DTR and RTS */
	zp->flags |= ZS_INITED;
d541 2
a542 4
int
zscc_params(scc, par)
	struct sccregs *scc;
	struct termios *par;
d544 4
a547 57
	unsigned divisor, speed;
	int     spd, imask, ints;

	speed = par->c_ospeed;
	if (speed == 0) {
		/* disconnect - drop DTR & RTS, disable receiver */
		ZBIC(scc, 5, 0x82);
		ZBIC(scc, 3, 1);
		return (0xFF);
	}
	if ((par->c_cflag & CREAD) == 0)
		ZBIC(scc, 3, 1);/* disable receiver */
	divisor = (zspclk() / 32 + (speed >> 1)) / speed - 2;
	ZWRITE(scc, 12, divisor);
	ZWRITE(scc, 13, divisor >> 8);
	switch (par->c_cflag & CSIZE) {
		case CS5:
			spd = 0;
			imask = 0x1F;
			break;
		case CS6:
			spd = 0x40;
			imask = 0x3F;
			break;
		case CS7:
			spd = 0x20;
			imask = 0x7F;
			break;
		default:
			spd = 0x60;
			imask = 0xFF;
	}
	ZWRITE(scc, 5, (scc->s_val[5] & ~0x60) | spd);
	ZWRITE(scc, 3, (scc->s_val[3] & ~0xC0) | (spd << 1));
	spd = par->c_cflag & CSTOPB ? 8 : 0;
	spd |= par->c_cflag & PARENB ? par->c_cflag & PARODD ? 1 : 3 : 0;
	ZWRITE(scc, 4, 0x44 | spd);
	ZBIS(scc, 5, 8);	/* enable transmitter */
	if ((par->c_cflag & CREAD) != 0)
		ZBIS(scc, 3, 1);/* enable receiver */
	ints = 0;
	if ((par->c_cflag & CLOCAL) == 0)
		ints |= SCC_DCD;
	if ((par->c_cflag & CCTS_OFLOW) != 0)
		ints |= SCC_CTS;
#if 0
	if (cputyp == CPU_162 || cputyp == CPU_172) {
		ZWRITE(scc, 15, ints | 1);
		/*
		 * now.. register 7 has become register 7': disable all
		 * 82530-only features for now
		 */
		ZWRITE(scc, 7, 0x20);
	}
#endif
	ZWRITE(scc, 15, ints);
	return (imask);
d550 2
a551 3
int
zscc_mget(scc)
	register struct sccregs *scc;
d553 1
a553 15
	int     bits = 0, rr0;

	if ((scc->s_val[3] & SCC_RCVEN) != 0)
		bits |= TIOCM_LE;
	if ((scc->s_val[5] & SCC_DTR) != 0)
		bits |= TIOCM_DTR;
	if ((scc->s_val[5] & SCC_RTS) != 0)
		bits |= TIOCM_RTS;
	rr0 = ZREAD0(scc);
	if ((rr0 & SCC_CTS) != 0)
		bits |= TIOCM_CTS;
	if ((rr0 & SCC_DCD) != 0)
		bits |= TIOCM_CAR;
	return (bits);
}
d555 3
a557 11
void
zscc_mset(scc, bits)
	register struct sccregs *scc;
	int bits;
{
	if ((bits & TIOCM_LE) != 0)
		ZBIS(scc, 3, SCC_RCVEN);
	if ((bits & TIOCM_DTR) != 0)
		ZBIS(scc, 5, SCC_DTR);
	if ((bits & TIOCM_RTS) != 0)
		ZBIS(scc, 5, SCC_RTS);
d561 1
a561 3
zscc_mclr(scc, bits)
	register struct sccregs *scc;
	int bits;
d563 2
a564 6
	if ((bits & TIOCM_LE) != 0)
		ZBIC(scc, 3, SCC_RCVEN);
	if ((bits & TIOCM_DTR) != 0)
		ZBIC(scc, 5, TIOCM_DTR);
	if ((bits & TIOCM_RTS) != 0)
		ZBIC(scc, 5, SCC_RTS);
d567 2
a568 3
void
zs_drain(zp)
	register struct zs *zp;
d570 1
a570 1
	register int s;
d572 7
a578 10
	zp->tty->t_state |= TS_DRAIN;
	/* wait for Tx buffer empty and All sent bits to be set */
	s = splzs();
	while ((ZREAD0(&zp->scc) & SCC_TXRDY) == 0 ||
			 (ZREAD(&zp->scc, 1) & 1) == 0) {
		splx(s);
		DELAY(100);
		s = splzs();
	}
	splx(s);
d581 2
a582 3
void
zs_unblock(tp)
	register struct tty *tp;
d584 8
a591 3
	tp->t_state &= ~TS_DRAIN;
	if (tp->t_outq.c_cc != 0)
		zsstart(tp);
d595 1
a595 1
 * Hardware interrupt from an SCC.
d597 2
a598 3
int
zsirq(arg)
	void *arg;
d600 1
a600 4
	int unit = (int)arg;
	struct zssoftc *sc = (struct zssoftc *) zs_cd.cd_devs[unit];
	struct zs *zp = &sc->sc_zs[0];
	int ipend;
d602 5
a606 17
	ipend = ZREAD(&zp->scc, 3);	/* read int pending from A side */
	if (ipend == 0)
		return (0);
	if ((ipend & 0x20) != 0)
		zs_rxint(sc, zp);
	if ((ipend & 0x10) != 0)
		zs_txint(sc, zp);
	if ((ipend & 0x8) != 0)
		zs_extint(sc, zp);
	++zp;				/* now look for B side ints */
	if ((ipend & 0x4) != 0)
		zs_rxint(sc, zp);
	if ((ipend & 0x2) != 0)
		zs_txint(sc, zp);
	if ((ipend & 0x1) != 0)
		zs_extint(sc, zp);
	ZWRITE0(&zp->scc, 0x38);	/* reset highest IUS */
d608 5
a612 1
	return (1);
d615 3
a617 25
void
zs_txint(struct zssoftc *sc, struct zs *zp)
{
	struct sccregs *scc;
	int     c;
	u_char *get;

	scc = &zp->scc;
	ZWRITE0(scc, 0x28);	/* reset Tx interrupt */
	if ((zp->hflags & ZH_OBLOCK) == 0) {
		get = zp->send_ptr;
		while ((ZREAD0(scc) & SCC_TXRDY) != 0 && zp->send_count > 0) {
			c = *get++;
			ZWRITED(scc, c);
			--zp->send_count;
			++zp->sent_count;
		}
		zp->send_ptr = get;
		if (zp->send_count == 0 && (zp->hflags & ZH_TXING) != 0) {
			zp->hflags &= ~ZH_TXING;
			zp->hflags |= ZH_SIRQ;
			softintr_schedule(sc->sc_softih);
		}
	}
}
d619 4
a622 5
void
zs_rxint(struct zssoftc *sc, struct zs *zp)
{
	register int stat, c, n, extra;
	u_char *put;
d624 1
a624 39
	put = zp->rcv_put;
	n = zp->rcv_count;
	for (;;) {
		if ((ZREAD0(&zp->scc) & SCC_RXFULL) == 0)	/* check Rx full */
			break;
		stat = ZREAD(&zp->scc, 1) & 0x70;
		c = ZREADD(&zp->scc) & zp->imask;
		/* stat encodes parity, overrun, framing errors */
		if (stat != 0)
			ZWRITE0(&zp->scc, 0x30);	/* reset error */
		if ((zp->hflags & ZH_RXOVF) != 0) {
			zp->hflags &= ~ZH_RXOVF;
			stat |= 0x20;
		}
		extra = (stat != 0 || c == ERROR_DET) ? 2 : 0;
		if (n + extra + 1 < zp->rcv_len) {
			if (extra != 0) {
				*put++ = ERROR_DET;
				if (put >= zp->rcv_end)
					put = zp->rcv_buf;
				*put++ = stat;
				if (put >= zp->rcv_end)
					put = zp->rcv_buf;
				n += 2;
			}
			*put++ = c;
			if (put >= zp->rcv_end)
				put = zp->rcv_buf;
			++n;
		} else
			zp->hflags |= ZH_RXOVF;
	}
	if (n > zp->rcv_count) {
		zp->rcv_put = put;
		zp->rcv_count = n;
		zp->hflags |= ZH_SIRQ;
		softintr_schedule(sc->sc_softih);
	}
}
a625 1
/* Ext/status interrupt */
d627 1
a627 1
zs_extint(struct zssoftc *sc, struct zs *zp)
d629 11
a639 11
	int     rr0;
	struct tty *tp = zp->tty;

	rr0 = ZREAD0(&zp->scc);
	ZWRITE0(&zp->scc, 0x10);/* reset ext/status int */

	/* Handle break */
	if (rr0 & 0x80) {
#ifdef DDB
		if (ISSET(zp->flags, ZS_CONSOLE) && db_console != 0)
			Debugger();
d643 2
a644 13
	if ((tp->t_cflag & CCTS_OFLOW) != 0) {
		if ((rr0 & 0x20) == 0)
			zp->hflags |= ZH_OBLOCK;
		else {
			zp->hflags &= ~ZH_OBLOCK;
			if ((rr0 & SCC_TXRDY) != 0)
				zs_txint(sc, zp);
		}
	}
	zp->modem_change |= rr0 ^ zp->modem_state;
	zp->modem_state = rr0;
	zp->hflags |= ZH_SIRQ;
	softintr_schedule(sc->sc_softih);
a646 1
/* ARGSUSED */
d648 1
a648 2
zs_softint(arg)
	void *arg;
a649 97
	struct zssoftc *sc = (struct zssoftc *)arg;
	int     s, c, stat, rr0;
	struct zs *zp;
	struct tty *tp;
	u_char *get;
	int     side;

	s = splzs();
	zp = &sc->sc_zs[0];
	for (side = 0; side < 2; ++side, ++zp) {
		if ((zp->hflags & ZH_SIRQ) == 0)
			continue;
		zp->hflags &= ~ZH_SIRQ;
		tp = zp->tty;

		/* check for tx done */
		spltty();
		if (tp != NULL && zp->send_count == 0
			 && (tp->t_state & TS_BUSY) != 0) {
			tp->t_state &= ~(TS_BUSY | TS_FLUSH);
			ndflush(&tp->t_outq, zp->sent_count);
			ttwakeupwr(tp);
			if (tp->t_line != 0)
				(*linesw[tp->t_line].l_start) (tp);
			else
				zsstart(tp);
		}
		splzs();

		/* check for received characters */
		get = zp->rcv_get;
		while (zp->rcv_count > 0) {
			c = *get++;
			if (get >= zp->rcv_end)
				get = zp->rcv_buf;
			if (c == ERROR_DET) {
				stat = *get++;
				if (get >= zp->rcv_end)
					get = zp->rcv_buf;
				c = *get++;
				if (get >= zp->rcv_end)
					get = zp->rcv_buf;
				zp->rcv_count -= 3;
			} else {
				stat = 0;
				--zp->rcv_count;
			}
			spltty();
			if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0)
				continue;
			if (zp->nzs_open == 0) {
			} else {
				if ((stat & 0x10) != 0)
					c |= TTY_PE;
				if ((stat & 0x20) != 0) {
					log(LOG_WARNING, "zs: fifo overflow\n");
					c |= TTY_FE;	/* need some error for
							 * slip stuff */
				}
				if ((stat & 0x40) != 0)
					c |= TTY_FE;
				(*linesw[tp->t_line].l_rint) (c, tp);
			}
			splzs();
		}
		zp->rcv_get = get;

		/* check for modem lines changing */
		while (zp->modem_change != 0 || zp->modem_state != zp->rr0) {
			rr0 = zp->rr0 ^ zp->modem_change;
			zp->modem_change = rr0 ^ zp->modem_state;

			/* Check if DCD (carrier detect) has changed */
			if (tp != NULL && (rr0 & 8) != (zp->rr0 & 8)) {
				spltty();
				ttymodem(tp, rr0 & 8);
				/* XXX possibly should disable line if
				 * return value is 0 */
				splzs();
			}
			zp->rr0 = rr0;
		}
	}
	splx(s);
}

/*
 * Routines for using side A of the first SCC as a console.
 */

/* probe for the SCC; should check hardware */
void
zscnprobe(cp)
	struct consdev *cp;
{
	int maj;

d651 2
d654 13
d669 7
d677 1
a677 2
	default:
		return;
d680 2
a681 7
	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == zsopen)
			break;

	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_LOWPRI;
d684 3
a686 15
/* initialize the keyboard for use as the console */
struct termios zscn_termios = {
	TTYDEF_IFLAG,
	TTYDEF_OFLAG,
	(CREAD | CS8 | HUPCL),
	TTYDEF_LFLAG,
	{0},
	TTYDEF_SPEED,
	TTYDEF_SPEED
};

struct sccregs zs_cons_sccregs;
int     zs_cons_imask;

/* Polling routine for console input from a serial port. */
d688 1
a688 2
zscngetc(dev)
	dev_t dev;
d690 2
a691 2
	register struct sccregs *scc = zs_cons_scc;
	int     c, s, stat;
d693 18
a710 10
	s = splhigh();	/* XXX was splzs() */
	for (;;) {
		while ((ZREAD0(scc) & SCC_RXFULL) == 0)	/* wait for Rx full */
			;
		stat = ZREAD(scc, 1) & 0x70;
		c = ZREADD(scc) & zs_cons_imask;
		/* stat encodes parity, overrun, framing errors */
		if (stat == 0)
			break;
		ZWRITE0(scc, 0x30);	/* reset error */
d713 1
d717 3
d721 1
a721 3
zscnputc(dev, c)
	dev_t dev;
	int c;
d723 2
a724 2
	register struct sccregs *scc = zs_cons_scc;
	int     s;
d726 1
a726 6
	s = splhigh();	/* XXX was splzs() */
	while ((ZREAD0(scc) & SCC_TXRDY) == 0)
		;
	ZWRITED(scc, c);
	splx(s);
}
d728 5
a732 13
void
zscninit(cp)
	struct consdev *cp;
{
	int unit = 0;
	struct termios *tiop = &zscn_termios;
	volatile u_char *scc_cr, *scc_dr;
	struct sccregs *scc;
	int size;

	zs_cons_unit = unit;
	zs_is_console = 1;
	zs_cons_scc = scc = &zs_cons_sccregs;
d735 1
a735 3
	 * the locations of the control and data register move around
	 * on different MVME models, so we generate independent pointers
	 * to them.
d737 7
a743 75
	size = zsregs(0, unit, &scc_cr, &scc_dr);

	*(scc_cr + size) = 0;
	*(scc_cr + size) = 9;
	*(scc_cr + size) = 0xC0;	/* hardware reset of SCC, both sides */
	if (!zsside(unit)) {
		scc_cr += size;
		scc_dr += size;
	}

	scc->s_cr = scc_cr;
	scc->s_dr = scc_dr;
#if defined(MVME162) || defined(MVME172)
	if (cputyp == CPU_162 || cputyp == CPU_172)
		ZWRITE(scc, 2, MC_VECBASE+MCV_ZS);
#endif
	ZWRITE(scc, 10, 0);
	ZWRITE(scc, 11, 0x50);	/* rx & tx clock = brgen */
	ZWRITE(scc, 14, 3);	/* brgen enabled, from pclk */
	zs_cons_imask = zscc_params(scc, tiop);
	ZBIS(scc, 5, 0x82);	/* set DTR and RTS */

	zs_cons_termios = *tiop;/* save for later */
}

#ifdef MVME147
u_long zs_cons_addrs_147[] = { ZS0_PHYS_147, ZS1_PHYS_147};
#endif
#if defined(MVME162) || defined(MVME172)
u_long zs_cons_addrs_162[] = { ZS0_PHYS_162, ZS1_PHYS_162};
#endif

/*
 * fills in pointers to the registers and returns how far apart
 * the two halves of the chip are.
 * 
 * it vaddr == NULL, it tries to determine the hardware address in
 * an intelligent fashion from the unit number.
 */
int
zsregs(va, unit, crp, drp)
	vaddr_t va;
	int unit;
	volatile u_char **crp, **drp;
{
#ifdef MVME147
	volatile struct scc_147 *scc_adr_147;
#endif
#if defined(MVME162) || defined(MVME172)
	volatile struct scc_162 *scc_adr_162;
#endif
	volatile u_char *scc_cr, *scc_dr;
	int size;

	switch (cputyp) {
#ifdef MVME147
		case CPU_147:
			if (va == 0)
				va = IIOV(zs_cons_addrs_147[unit]);
			scc_adr_147 = (volatile struct scc_147 *)va;
			scc_cr = &scc_adr_147->cr;
			scc_dr = &scc_adr_147->dr;
			size = sizeof(struct scc_147);
			break;
#endif
#if defined(MVME162) || defined(MVME172)
		case CPU_162:
		case CPU_172:
			if (va == 0)
				va = IIOV(zs_cons_addrs_162[unit]);
			scc_adr_162 = (volatile struct scc_162 *)va;
			scc_cr = &scc_adr_162->cr;
			scc_dr = &scc_adr_162->dr;
			size = sizeof(struct scc_162);
			break;
d745 3
d750 1
a750 3
	*crp = scc_cr;
	*drp = scc_dr;
	return (size);
d753 2
a754 2
int
zspclk()
a755 13
	switch (cputyp) {
#ifdef MVME147
		case CPU_147:
			return (PCLK_FREQ_147);
#endif
#if defined(MVME162) || defined(MVME172)
		case CPU_162:
		case CPU_172:
			return (PCLK_FREQ_162);
#endif
		default:
			return 0;
	}
@


1.33
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.32 2010/06/26 23:24:43 guenther Exp $ */
d560 1
a560 7
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (tp->t_state & TS_ASLEEP) {
				tp->t_state &= ~TS_ASLEEP;
				wakeup((caddr_t) & tp->t_outq);
			}
			selwakeup(&tp->t_wsel);
		}
d902 1
a902 7
			if (tp->t_outq.c_cc <= tp->t_lowat) {
				if (tp->t_state & TS_ASLEEP) {
					tp->t_state &= ~TS_ASLEEP;
					wakeup((caddr_t) & tp->t_outq);
				}
				selwakeup(&tp->t_wsel);
			}
@


1.32
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.31 2010/04/12 12:57:52 tedu Exp $ */
d354 1
a354 1
		zp->tty = ttymalloc();
@


1.31
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.30 2009/11/09 17:53:39 nicm Exp $ */
a34 1
#include <sys/user.h>
@


1.30
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.29 2009/10/31 12:00:07 fgsch Exp $ */
d371 1
a371 1
	error = ((*linesw[tp->t_line].l_open) (dev, tp));
d395 1
a395 1
	(*linesw[tp->t_line].l_close) (tp, flag);
@


1.29
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.28 2009/10/31 06:40:16 deraadt Exp $ */
a566 1
			KNOTE(&tp->t_wsel.si_note, 0);
a914 1
				KNOTE(&tp->t_wsel.si_note, 0);
@


1.28
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.27 2009/03/15 20:40:25 miod Exp $ */
d368 1
a368 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
@


1.27
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.26 2008/01/23 16:37:57 jsing Exp $ */
d567 1
d916 1
@


1.26
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.25 2006/06/11 20:46:50 miod Exp $ */
d112 5
a116 4
	struct device  sc_dev;
	struct zs   sc_zs[2];
	struct intrhand   sc_ih;
	int      sc_flags;
a132 1
u_int8_t sir_zs;
d162 3
a164 3
void	zs_txint(struct zs *);
void	zs_rxint(struct zs *);
void	zs_extint(struct zs *);
d266 1
a266 2
	if (sir_zs == 0)
		sir_zs = allocate_sir(zs_softint, 0);
d537 1
a537 1
			zs_txint(zp);
d761 1
a761 1
		zs_rxint(zp);
d763 1
a763 1
		zs_txint(zp);
d765 1
a765 1
		zs_extint(zp);
d768 1
a768 1
		zs_rxint(zp);
d770 1
a770 1
		zs_txint(zp);
d772 1
a772 1
		zs_extint(zp);
d779 1
a779 2
zs_txint(zp)
	register struct zs *zp;
d799 1
a799 1
			setsoftint(sir_zs);
d805 1
a805 2
zs_rxint(zp)
	register struct zs *zp;
d846 1
a846 1
		setsoftint(sir_zs);
d852 1
a852 2
zs_extint(zp)
	register struct zs *zp;
d874 1
a874 1
				zs_txint(zp);
d880 1
a880 1
	setsoftint(sir_zs);
d888 1
d893 1
a893 1
	int     unit, side;
d896 3
a898 2
	for (unit = 0; unit < zs_cd.cd_ndevs; ++unit) {
		if (zs_cd.cd_devs[unit] == NULL)
d900 2
a901 6
		zp = &((struct zssoftc *) zs_cd.cd_devs[unit])->sc_zs[0];
		for (side = 0; side < 2; ++side, ++zp) {
			if ((zp->hflags & ZH_SIRQ) == 0)
				continue;
			zp->hflags &= ~ZH_SIRQ;
			tp = zp->tty;
d903 10
a912 12
			/* check for tx done */
			spltty();
			if (tp != NULL && zp->send_count == 0
				 && (tp->t_state & TS_BUSY) != 0) {
				tp->t_state &= ~(TS_BUSY | TS_FLUSH);
				ndflush(&tp->t_outq, zp->sent_count);
				if (tp->t_outq.c_cc <= tp->t_lowat) {
					if (tp->t_state & TS_ASLEEP) {
						tp->t_state &= ~TS_ASLEEP;
						wakeup((caddr_t) & tp->t_outq);
					}
					selwakeup(&tp->t_wsel);
d914 1
a914 4
				if (tp->t_line != 0)
					(*linesw[tp->t_line].l_start) (tp);
				else
					zsstart(tp);
d916 6
a921 1
			splzs();
d923 10
a932 3
			/* check for received characters */
			get = zp->rcv_get;
			while (zp->rcv_count > 0) {
d936 16
a951 11
				if (c == ERROR_DET) {
					stat = *get++;
					if (get >= zp->rcv_end)
						get = zp->rcv_buf;
					c = *get++;
					if (get >= zp->rcv_end)
						get = zp->rcv_buf;
					zp->rcv_count -= 3;
				} else {
					stat = 0;
					--zp->rcv_count;
d953 15
d969 3
a971 16
				if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0)
					continue;
				if (zp->nzs_open == 0) {
					
				} else {
					if ((stat & 0x10) != 0)
						c |= TTY_PE;
					if ((stat & 0x20) != 0) {
						log(LOG_WARNING, "zs: fifo overflow\n");
						c |= TTY_FE;	/* need some error for
								 * slip stuff */
					}
					if ((stat & 0x40) != 0)
						c |= TTY_FE;
					(*linesw[tp->t_line].l_rint) (c, tp);
				}
d974 1
a974 17
			zp->rcv_get = get;

			/* check for modem lines changing */
			while (zp->modem_change != 0 || zp->modem_state != zp->rr0) {
				rr0 = zp->rr0 ^ zp->modem_change;
				zp->modem_change = rr0 ^ zp->modem_state;

				/* Check if DCD (carrier detect) has changed */
				if (tp != NULL && (rr0 & 8) != (zp->rr0 & 8)) {
					spltty();
					ttymodem(tp, rr0 & 8);
					/* XXX possibly should disable line if
					 * return value is 0 */
					splzs();
				}
				zp->rr0 = rr0;
			}
@


1.25
log
@Factorize spl handling functions and software interrupt routines between
m68k-based platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.24 2006/03/15 20:04:36 miod Exp $ */
d1014 1
a1014 1
	cp->cn_pri = CN_NORMAL;
@


1.24
log
@Correct checks against cd_ndevs - valid numbers are strictly inferior to
cd_ndevs.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.23 2006/01/01 11:59:39 miod Exp $ */
d132 1
a132 1
u_long   sir_zs;
@


1.23
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.22 2005/11/24 22:43:16 miod Exp $ */
d390 1
a390 1
	if (zsunit(dev) > zs_cd.cd_ndevs ||
@


1.22
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.21 2005/05/01 09:55:49 miod Exp $ */
a1004 1
		cp->cn_pri = CN_DEAD;
@


1.21
log
@Bring raise-only semantics to splsoft* on m68k and m88k, as done elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.20 2004/09/15 05:57:39 miod Exp $ */
d129 1
a129 2
int   zsregs(void *va, int unit, volatile u_char **crp,
						  volatile u_char **drp);
d1089 1
a1089 1
	size = zsregs(NULL, unit, &scc_cr, &scc_dr);
d1130 1
a1130 1
	void *va;
d1146 2
a1147 2
			if (!va)
				va = (void *)IIOV(zs_cons_addrs_147[unit]);
d1157 2
a1158 2
			if (!va)
				va = (void *)IIOV(zs_cons_addrs_162[unit]);
@


1.20
log
@Crude diff to allow user break on zs to enter ddb, for 147/1x2; spotted
by matthieu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.19 2004/07/31 22:27:34 miod Exp $ */
d75 1
a75 1
#define splzs()		spl4()
@


1.19
log
@Use cons_decl() instead of homemade wrong prototypes.
While there, fix a mismatch between the zs device number and the associated
dev_t nodes.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.18 2004/07/30 22:29:45 miod Exp $ */
d48 4
d864 9
@


1.18
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.17 2004/07/30 09:50:15 miod Exp $ */
a61 1

d162 1
a162 5
int	zscnprobe(struct consdev *);
void	zscninit(void);
int	zscngetc(dev_t);
void	zscnputc(dev_t, int);
void	zs_cnsetup(int, struct termios *);
a200 1
	/* connect the interrupt */
d203 1
d239 1
a239 1
	if (zs_is_console && self->dv_unit == zsunit(zs_cons_unit)) {
d981 1
a981 1
int
d988 7
a994 7
		case CPU_147:
		case CPU_162:
		case CPU_172:
			break;
		default:
			cp->cn_pri = CN_DEAD;
			return (0);
a1001 1
		/* initialize required fields */
d1003 1
a1003 3
	cp->cn_pri = CN_INTERNAL;	/* better than PROM console */

	return (1);
a1019 6
void
zscninit()
{
	zs_cnsetup(0, &zscn_termios);
}

d1059 2
a1060 3
zs_cnsetup(unit, tiop)
	int unit;
	struct termios *tiop;
d1062 2
d1135 1
a1135 1
				va = (void *)IIOV(zs_cons_addrs_147[zsunit(unit)]);
d1146 1
a1146 1
				va = (void *)IIOV(zs_cons_addrs_162[zsunit(unit)]);
@


1.17
log
@Switch mvme68k to evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.16 2004/07/02 17:57:29 miod Exp $ */
a42 1
#include <sys/evcount.h>
a110 1
	struct evcount   sc_intrcnt;
d217 1
a217 1
		pccintr_establish(PCCV_ZS, &sc->sc_ih);
d229 1
a229 1
		mcintr_establish(MCV_ZS, &sc->sc_ih);
a303 3

	evcount_attach(&sc->sc_intrcnt, self->dv_xname,
	    (void *)&sc->sc_ih.ih_ipl, &evcount_intr);
a777 1
	sc->sc_intrcnt.ec_count++;
@


1.16
log
@Kill ca_master in autoconf structures. Drivers either only attach to one
specific bus (mc/pcc/pcctwo), or they know it from the ca_bustype value,
and can use the globals sys_busname variables.

This also allows for some code simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.15 2004/01/14 20:50:48 miod Exp $ */
d43 1
d50 1
d112 1
a112 1
	struct evcnt   sc_intrcnt;
d214 2
d307 2
a308 1
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d783 1
a783 1
	sc->sc_intrcnt.ev_count++;
@


1.15
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.14 2003/10/03 16:44:50 miod Exp $ */
a111 6
#if NPCC > 0
	struct pccreg  *sc_pcc;
#endif
#if NMC > 0
	struct mcreg   *sc_mc;
#endif
d214 3
a216 4
		case BUS_PCC:
			pccintr_establish(PCCV_ZS, &sc->sc_ih);
			sc->sc_pcc = (struct pccreg *)ca->ca_master;
			break;
d219 10
a228 11
		case BUS_MC:
			if (sys_mc->mc_chiprev == 0x01)
				/* 
				 * MC rev 0x01 has a bug and can not access scc regs directly. 
				 * Macros will do the right thing based on the value of 
				 * mc_rev1_bug - XXX smurph 
				 */
				mc_rev1_bug = 1; /* defined in scc.h */
			mcintr_establish(MCV_ZS, &sc->sc_ih);
			sc->sc_mc = (struct mcreg *)ca->ca_master;
			break;
d282 1
a282 1
			ir = sc->sc_pcc->pcc_zsirq;
d287 1
a287 1
			sc->sc_pcc->pcc_zsirq = zs_level | PCC_IRQ_IEN | PCC_ZS_PCCVEC;
d292 1
a292 1
			ir = sc->sc_mc->mc_zsirq;
d297 1
a297 1
			sc->sc_mc->mc_zsirq = zs_level | MC_IRQ_IEN;
@


1.14
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.13 2003/06/02 05:09:14 deraadt Exp $ */
d153 1
a153 1
	NULL, "zs", DV_TTY, 0
@


1.13
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.12 2002/06/02 22:49:59 deraadt Exp $ */
a366 1
		tty_attach(zp->tty);
@


1.12
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.11 2002/04/27 23:21:05 miod Exp $ */
a16 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
@


1.11
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.10 2002/03/14 01:26:37 millert Exp $ */
d22 1
a22 1
 *    derived from this software withough specific prior written permission
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.9 2000/03/26 23:31:59 deraadt Exp $ */
a38 1
#include <sys/conf.h>
d49 3
d53 1
a53 1
#include <machine/autoconf.h>
a134 1
int   zsopen(dev_t, int, int, struct proc *);
d137 1
a137 1
int   zsirq(int unit);
d143 1
a143 1
void  zs_softint(void);
d162 19
d183 2
a184 2
struct device *parent;
void  *vcf, *args;
a185 1
	struct cfdata *cf = vcf;
d194 1
a194 1
	if (!badvaddr(ca->ca_vaddr, 1))
d205 2
a206 2
struct device *parent, *self;
void  *args;
d322 1
a322 1
struct zs *zp;
d347 1
a347 1
dev_t   dev;
d357 3
a359 3
dev_t dev;
int flag, mode;
struct proc *p;
d398 3
a400 3
dev_t   dev;
int     flag, mode;
struct proc *p;
d427 3
a429 3
dev_t dev;
struct uio *uio;
int   flag;
d441 3
a443 3
dev_t   dev;
struct uio *uio;
int     flag;
d454 5
a458 4
dev_t   dev;
caddr_t data;
int     cmd, flag;
struct proc *p;
d514 2
a515 2
struct tty *tp;
struct termios *t;
d539 1
a539 1
struct tty *tp;
d562 1
d564 2
a565 2
struct tty *tp;
int flag;
d588 1
d591 1
d593 1
a593 1
struct zs *zp;
d606 1
d608 2
a609 2
struct zs *zp;
struct termios *par;
d614 2
a615 2
#ifdef MVME162
	if (cputyp == CPU_162)
d628 2
a629 2
struct sccregs *scc;
struct termios *par;
d677 1
a677 1
	if (cputyp == CPU_162) {
d690 1
d692 1
a692 1
register struct sccregs *scc;
d710 1
d712 2
a713 2
register struct sccregs *scc;
int bits;
d723 1
d725 2
a726 2
register struct sccregs *scc;
int bits;
d736 1
d738 1
a738 1
register struct zs *zp;
d754 1
d756 1
a756 1
register struct tty *tp;
d767 2
a768 2
zsirq(unit)
int unit;
d770 1
d772 2
a773 2
	register struct zs *zp = &sc->sc_zs[0];
	register int ipend, x;
d797 1
d799 1
a799 1
register struct zs *zp;
a800 1
	struct tty *tp = zp->tty;
d824 1
d826 1
a826 1
register struct zs *zp;
d872 1
d874 1
a874 1
register struct zs *zp;
d896 1
d898 2
a899 1
zs_softint()
d901 1
a901 1
	int     s, n, n0, c, stat, rr0;
d1002 1
d1004 1
a1004 1
struct consdev *cp;
d1011 1
d1044 1
d1053 1
a1053 1
dev_t dev;
d1073 1
d1075 2
a1076 2
dev_t dev;
int c;
d1088 1
d1090 2
a1091 2
int unit;
struct termios *tiop;
d1118 2
a1119 2
#ifdef MVME162
	if (cputyp == CPU_162)
d1134 1
a1134 1
#ifdef MVME162
d1147 3
a1149 3
void *va;
int unit;
volatile u_char **crp, **drp;
d1154 1
a1154 1
#ifdef MVME162
d1171 1
a1171 1
#ifdef MVME162
d1173 1
d1197 1
a1197 1
#ifdef MVME162
d1199 1
d1202 2
@


1.9
log
@callout.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.8 2000/01/29 04:11:25 smurph Exp $ */
d133 7
a139 7
int   zsopen   __P((dev_t, int, int, struct proc *));
void  zsstart  __P((struct tty *));
int   zsparam  __P((struct tty *, struct termios *));
int   zsirq __P((int unit));
int   zsregs   __P((void *va, int unit, volatile u_char **crp,
						  volatile u_char **drp));
int   zspclk   __P((void));
d142 1
a142 1
void  zs_softint __P((void));
d150 2
a151 2
void  zsattach __P((struct device *, struct device *, void *));
int   zsmatch __P((struct device *, void *, void *));
@


1.9.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.9 2000/03/26 23:31:59 deraadt Exp $ */
d22 1
a22 1
 *    derived from this software without specific prior written permission
d39 1
d50 1
a50 1

a51 3
#include <machine/conf.h>
#include <machine/cpu.h>

d133 7
a139 6
void  zsstart(struct tty *);
int   zsparam(struct tty *, struct termios *);
int   zsirq(void *);
int   zsregs(void *va, int unit, volatile u_char **crp,
						  volatile u_char **drp);
int   zspclk(void);
d142 1
a142 1
void  zs_softint(void *);
d150 2
a151 2
void  zsattach(struct device *, struct device *, void *);
int   zsmatch(struct device *, void *, void *);
a160 19
void	zs_ttydef(struct zs *);
struct tty *zstty(dev_t);
void	zs_init(struct zs *);
void	zscc_init(struct zs *, struct termios *);
int	zscc_params(struct sccregs *, struct termios *);
int	zscc_mget(struct sccregs *);
void	zscc_mset(struct sccregs *, int);
void	zscc_mclr(struct sccregs *, int);
void	zs_drain(struct zs *);
void	zs_unblock(struct tty *);
void	zs_txint(struct zs *);
void	zs_rxint(struct zs *);
void	zs_extint(struct zs *);
int	zscnprobe(struct consdev *);
void	zscninit(void);
int	zscngetc(dev_t);
void	zscnputc(dev_t, int);
void	zs_cnsetup(int, struct termios *);

d163 2
a164 2
	struct device *parent;
	void  *vcf, *args;
d166 1
d175 1
a175 1
	if (!badvaddr((vaddr_t)ca->ca_vaddr, 1))
d186 2
a187 2
	struct device *parent, *self;
	void  *args;
d303 1
a303 1
	struct zs *zp;
d328 1
a328 1
	dev_t   dev;
d338 3
a340 3
	dev_t dev;
	int flag, mode;
	struct proc *p;
d379 3
a381 3
	dev_t   dev;
	int     flag, mode;
	struct proc *p;
d408 3
a410 3
	dev_t dev;
	struct uio *uio;
	int   flag;
d422 3
a424 3
	dev_t   dev;
	struct uio *uio;
	int     flag;
d435 4
a438 5
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d494 2
a495 2
	struct tty *tp;
	struct termios *t;
d519 1
a519 1
	struct tty *tp;
a541 1
int
d543 2
a544 2
	struct tty *tp;
	int flag;
a566 1
	return (0);
a568 1
void
d570 1
a570 1
	struct zs *zp;
a582 1
void
d584 2
a585 2
	struct zs *zp;
	struct termios *par;
d590 2
a591 2
#if defined(MVME162) || defined(MVME172)
	if (cputyp == CPU_162 || cputyp == CPU_172)
d604 2
a605 2
	struct sccregs *scc;
	struct termios *par;
d653 1
a653 1
	if (cputyp == CPU_162 || cputyp == CPU_172) {
a665 1
int
d667 1
a667 1
	register struct sccregs *scc;
a684 1
void
d686 2
a687 2
	register struct sccregs *scc;
	int bits;
a696 1
void
d698 2
a699 2
	register struct sccregs *scc;
	int bits;
a708 1
void
d710 1
a710 1
	register struct zs *zp;
a725 1
void
d727 1
a727 1
	register struct tty *tp;
d738 2
a739 2
zsirq(arg)
	void *arg;
a740 1
	int unit = (int)arg;
d742 2
a743 2
	struct zs *zp = &sc->sc_zs[0];
	int ipend;
a766 1
void
d768 1
a768 1
	register struct zs *zp;
d770 1
a793 1
void
d795 1
a795 1
	register struct zs *zp;
a840 1
void
d842 1
a842 1
	register struct zs *zp;
a863 1
/* ARGSUSED */
d865 1
a865 2
zs_softint(arg)
	void *arg;
d867 1
a867 1
	int     s, c, stat, rr0;
a967 1
int
d969 1
a969 1
	struct consdev *cp;
a975 1
		case CPU_172:
a1007 1
void
d1016 1
a1016 1
	dev_t dev;
a1035 1
void
d1037 2
a1038 2
	dev_t dev;
	int c;
a1049 1
void
d1051 2
a1052 2
	int unit;
	struct termios *tiop;
d1079 2
a1080 2
#if defined(MVME162) || defined(MVME172)
	if (cputyp == CPU_162 || cputyp == CPU_172)
d1095 1
a1095 1
#if defined(MVME162) || defined(MVME172)
d1108 3
a1110 3
	void *va;
	int unit;
	volatile u_char **crp, **drp;
d1115 1
a1115 1
#if defined(MVME162) || defined(MVME172)
d1132 1
a1132 1
#if defined(MVME162) || defined(MVME172)
a1133 1
		case CPU_172:
d1157 1
a1157 1
#if defined(MVME162) || defined(MVME172)
a1158 1
		case CPU_172:
a1160 2
		default:
			return 0;
@


1.8
log
@Updated flash and ipic device compatability with MC rev 0x01.  zs mods to work with LX style 162 boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.6 2000/01/27 03:06:50 smurph Exp $ */
a44 1
#include <sys/callout.h>
@


1.8.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.9 2000/03/26 23:31:59 deraadt Exp $ */
d45 1
@


1.8.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d133 7
a139 7
int   zsopen(dev_t, int, int, struct proc *);
void  zsstart(struct tty *);
int   zsparam(struct tty *, struct termios *);
int   zsirq(int unit);
int   zsregs(void *va, int unit, volatile u_char **crp,
						  volatile u_char **drp);
int   zspclk(void);
d142 1
a142 1
void  zs_softint(void);
d150 2
a151 2
void  zsattach(struct device *, struct device *, void *);
int   zsmatch(struct device *, void *, void *);
@


1.8.2.3
log
@Sync the SMP branch with 3.3
@
text
@d22 1
a22 1
 *    derived from this software without specific prior written permission
d39 1
d50 1
a50 1

a51 3
#include <machine/conf.h>
#include <machine/cpu.h>

d133 1
d136 1
a136 1
int   zsirq(void *);
d142 1
a142 1
void  zs_softint(void *);
a160 19
void	zs_ttydef(struct zs *);
struct tty *zstty(dev_t);
void	zs_init(struct zs *);
void	zscc_init(struct zs *, struct termios *);
int	zscc_params(struct sccregs *, struct termios *);
int	zscc_mget(struct sccregs *);
void	zscc_mset(struct sccregs *, int);
void	zscc_mclr(struct sccregs *, int);
void	zs_drain(struct zs *);
void	zs_unblock(struct tty *);
void	zs_txint(struct zs *);
void	zs_rxint(struct zs *);
void	zs_extint(struct zs *);
int	zscnprobe(struct consdev *);
void	zscninit(void);
int	zscngetc(dev_t);
void	zscnputc(dev_t, int);
void	zs_cnsetup(int, struct termios *);

d163 2
a164 2
	struct device *parent;
	void  *vcf, *args;
d166 1
d175 1
a175 1
	if (!badvaddr((vaddr_t)ca->ca_vaddr, 1))
d186 2
a187 2
	struct device *parent, *self;
	void  *args;
d303 1
a303 1
	struct zs *zp;
d328 1
a328 1
	dev_t   dev;
d338 3
a340 3
	dev_t dev;
	int flag, mode;
	struct proc *p;
d379 3
a381 3
	dev_t   dev;
	int     flag, mode;
	struct proc *p;
d408 3
a410 3
	dev_t dev;
	struct uio *uio;
	int   flag;
d422 3
a424 3
	dev_t   dev;
	struct uio *uio;
	int     flag;
d435 4
a438 5
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d494 2
a495 2
	struct tty *tp;
	struct termios *t;
d519 1
a519 1
	struct tty *tp;
a541 1
int
d543 2
a544 2
	struct tty *tp;
	int flag;
a566 1
	return (0);
a568 1
void
d570 1
a570 1
	struct zs *zp;
a582 1
void
d584 2
a585 2
	struct zs *zp;
	struct termios *par;
d590 2
a591 2
#if defined(MVME162) || defined(MVME172)
	if (cputyp == CPU_162 || cputyp == CPU_172)
d604 2
a605 2
	struct sccregs *scc;
	struct termios *par;
d653 1
a653 1
	if (cputyp == CPU_162 || cputyp == CPU_172) {
a665 1
int
d667 1
a667 1
	register struct sccregs *scc;
a684 1
void
d686 2
a687 2
	register struct sccregs *scc;
	int bits;
a696 1
void
d698 2
a699 2
	register struct sccregs *scc;
	int bits;
a708 1
void
d710 1
a710 1
	register struct zs *zp;
a725 1
void
d727 1
a727 1
	register struct tty *tp;
d738 2
a739 2
zsirq(arg)
	void *arg;
a740 1
	int unit = (int)arg;
d742 2
a743 2
	struct zs *zp = &sc->sc_zs[0];
	int ipend;
a766 1
void
d768 1
a768 1
	register struct zs *zp;
d770 1
a793 1
void
d795 1
a795 1
	register struct zs *zp;
a840 1
void
d842 1
a842 1
	register struct zs *zp;
a863 1
/* ARGSUSED */
d865 1
a865 2
zs_softint(arg)
	void *arg;
d867 1
a867 1
	int     s, c, stat, rr0;
a967 1
int
d969 1
a969 1
	struct consdev *cp;
a975 1
		case CPU_172:
a1007 1
void
d1016 1
a1016 1
	dev_t dev;
a1035 1
void
d1037 2
a1038 2
	dev_t dev;
	int c;
a1049 1
void
d1051 2
a1052 2
	int unit;
	struct termios *tiop;
d1079 2
a1080 2
#if defined(MVME162) || defined(MVME172)
	if (cputyp == CPU_162 || cputyp == CPU_172)
d1095 1
a1095 1
#if defined(MVME162) || defined(MVME172)
d1108 3
a1110 3
	void *va;
	int unit;
	volatile u_char **crp, **drp;
d1115 1
a1115 1
#if defined(MVME162) || defined(MVME172)
d1132 1
a1132 1
#if defined(MVME162) || defined(MVME172)
a1133 1
		case CPU_172:
d1157 1
a1157 1
#if defined(MVME162) || defined(MVME172)
a1158 1
		case CPU_172:
a1160 2
		default:
			return 0;
@


1.8.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.8.2.3 2003/03/27 23:32:16 niklas Exp $ */
d17 6
@


1.8.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d153 1
a153 1
	NULL, "zs", DV_TTY
d367 1
@


1.7
log
@goof.
@
text
@d4 1
d66 1
d74 1
a74 1
#define TS_DRAIN	TS_FLUSH/* waiting for output to drain */
d79 18
a96 18
	short		flags;		/* see below */
	char		rr0;		/* holds previous CTS, DCD state */
	u_char		imask;		/* mask for input chars */
	int		nzs_open;	/* # opens as /dev/zsn */
	struct tty	*tty;		/* link to tty structure */
	struct sccregs	scc;		/* SCC shadow registers */
	u_char		*rcv_get;
	u_char		*rcv_put;
	u_char		*rcv_end;
	volatile int	rcv_count;
	int		rcv_len;
	char		*send_ptr;
	int		send_count;
	int		sent_count;
	volatile char	modem_state;
	volatile char	modem_change;
	volatile short	hflags;
	char		rcv_buf[RECV_BUF];
d113 4
a116 4
	struct device	sc_dev;
	struct zs	sc_zs[2];
	struct evcnt	sc_intrcnt;
	struct intrhand	sc_ih;
d118 1
a118 1
	struct pccreg	*sc_pcc;
d121 1
a121 1
	struct mcreg	*sc_mc;
d123 1
a123 1
	int		sc_flags;
d129 12
a140 12
struct	termios zs_cons_termios;
int	zs_cons_unit = 0;
int	zs_is_console = 0;
struct	sccregs *zs_cons_scc;

int	zsopen	__P((dev_t, int, int, struct proc *));
void	zsstart	__P((struct tty *));
int	zsparam	__P((struct tty *, struct termios *));
int	zsirq	__P((int unit));
int	zsregs	__P((void *va, int unit, volatile u_char **crp,
	    volatile u_char **drp));
int	zspclk	__P((void));
d142 2
a143 2
u_long	sir_zs;
void	zs_softint __P((void));
d151 2
a152 2
void	zsattach __P((struct device *, struct device *, void *));
int	zsmatch __P((struct device *, void *, void *));
d164 2
a165 2
	struct device *parent;
	void	*vcf, *args;
d169 14
a182 17
   unsigned char *zstest = (unsigned char *)ca->ca_vaddr;
   /* 
    * If zs1 is in the config, we must test to see if it really exists.  
    * Some 162s only have one scc device, but the memory location for 
    * the second scc still checks valid and every byte contains 0xFF. So 
    * this is what we test with for now. XXX - smurph
    */
   if (!badvaddr(ca->ca_vaddr, 1))
      if (*zstest == 0xFF)
         return(0);
      else 
         return(1);
   else 
      return(0);
#if 0
   return (!badvaddr(ca->ca_vaddr, 1));
#endif 
d187 2
a188 2
	struct device *parent, *self;
	void	*args;
d197 1
a197 1
	int	size;
d208 4
a211 4
	case BUS_PCC:
		pccintr_establish(PCCV_ZS, &sc->sc_ih);
		sc->sc_pcc = (struct pccreg *)ca->ca_master;
		break;
d214 11
a224 4
	case BUS_MC:
		mcintr_establish(MCV_ZS, &sc->sc_ih);
		sc->sc_mc = (struct mcreg *)ca->ca_master;
		break;
d277 7
a283 5
	case BUS_PCC:
		ir = sc->sc_pcc->pcc_zsirq;
		if ((ir & PCC_IRQ_IPL) != 0 && (ir & PCC_IRQ_IPL) != zs_level)
			panic("zs configured at different IPLs");
		if (initirq)
a284 2
		sc->sc_pcc->pcc_zsirq = zs_level | PCC_IRQ_IEN | PCC_ZS_PCCVEC;
		break;
d287 7
a293 5
	case BUS_MC:
		ir = sc->sc_mc->mc_zsirq;
		if ((ir & MC_IRQ_IPL) != 0 && (ir & MC_IRQ_IPL) != zs_level)
			panic("zs configured at different IPLs");
		if (initirq)
a294 2
		sc->sc_mc->mc_zsirq = zs_level | MC_IRQ_IEN;
		break;
d304 1
a304 1
	struct zs *zp;
d329 1
a329 1
	dev_t   dev;
d339 3
a341 3
	dev_t dev;
	int flag, mode;
	struct proc *p;
d349 1
a349 1
	    (sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(dev)]) == NULL)
d380 3
a382 3
	dev_t   dev;
	int     flag, mode;
	struct proc *p;
d390 1
a390 1
	    (sc = (struct zssoftc *) zs_cd.cd_devs[zsunit(dev)]) == NULL)
d398 2
a399 2
		ZBIC(&zp->scc, 5, 0x82);        /* drop DTR, RTS */
	ZBIC(&zp->scc, 3, 1);   /* disable receiver */
d409 3
a411 3
	dev_t	dev;
	struct uio *uio;
	int	flag;
d423 3
a425 3
	dev_t   dev;
	struct uio *uio;
	int     flag;
d436 4
a439 4
	dev_t   dev;
	caddr_t data;
	int     cmd, flag;
	struct proc *p;
d456 32
a487 32
	case TIOCSDTR:
		ZBIS(scc, 5, 0x80);
		break;
	case TIOCCDTR:
		ZBIC(scc, 5, 0x80);
		break;
	case TIOCSBRK:
		splx(s);
		zs_drain(zp);
		s = splzs();
		ZBIS(scc, 5, 0x10);
		spltty();
		zs_unblock(tp);
		break;
	case TIOCCBRK:
		ZBIC(scc, 5, 0x10);
		break;
	case TIOCMGET:
		*(int *) data = zscc_mget(scc);
		break;
	case TIOCMSET:
		zscc_mset(scc, *(int *) data);
		zscc_mclr(scc, ~*(int *) data);
		break;
	case TIOCMBIS:
		zscc_mset(scc, *(int *) data);
		break;
	case TIOCMBIC:
		zscc_mclr(scc, *(int *) data);
		break;
	default:
		error = ENOTTY;
d495 2
a496 2
	struct tty *tp;
	struct termios *t;
d520 1
a520 1
	struct tty *tp;
d544 2
a545 2
	struct tty *tp;
	int flag;
d571 1
a571 1
	struct zs *zp;
d585 2
a586 2
	struct zs *zp;
	struct termios *par;
d605 2
a606 2
	struct sccregs *scc;
	struct termios *par;
d624 15
a638 15
	case CS5:
		spd = 0;
		imask = 0x1F;
		break;
	case CS6:
		spd = 0x40;
		imask = 0x3F;
		break;
	case CS7:
		spd = 0x20;
		imask = 0x7F;
		break;
	default:
		spd = 0x60;
		imask = 0xFF;
d668 1
a668 1
	register struct sccregs *scc;
d687 2
a688 2
	register struct sccregs *scc;
	int bits;
d699 2
a700 2
	register struct sccregs *scc;
	int bits;
d711 1
a711 1
	register struct zs *zp;
d719 1
a719 1
	    (ZREAD(&zp->scc, 1) & 1) == 0) {
d728 1
a728 1
	register struct tty *tp;
d740 1
a740 1
	int unit;
d769 1
a769 1
	register struct zs *zp;
d796 1
a796 1
	register struct zs *zp;
d843 1
a843 1
	register struct zs *zp;
d888 1
a888 1
			    && (tp->t_state & TS_BUSY) != 0) {
d927 1
d970 1
a970 1
	struct consdev *cp;
d975 6
a980 6
	case CPU_147:
	case CPU_162:
		break;
	default:
		cp->cn_pri = CN_DEAD;
		return (0);
d988 1
a988 1
	/* initialize required fields */
d1017 1
a1017 1
	dev_t dev;
d1038 2
a1039 2
	dev_t dev;
	int c;
d1052 2
a1053 2
	int unit;
	struct termios *tiop;
d1094 1
a1094 1
u_long zs_cons_addrs_147[] = { ZS0_PHYS_147, ZS1_PHYS_147 };
d1097 1
a1097 1
u_long zs_cons_addrs_162[] = { ZS0_PHYS_162, ZS1_PHYS_162 };
d1109 3
a1111 3
	void *va;
	int unit;
	volatile u_char **crp, **drp;
d1124 8
a1131 8
	case CPU_147:
		if (!va)
			va = (void *)IIOV(zs_cons_addrs_147[zsunit(unit)]);
		scc_adr_147 = (volatile struct scc_147 *)va;
		scc_cr = &scc_adr_147->cr;
		scc_dr = &scc_adr_147->dr;
		size = sizeof(struct scc_147);
		break;
d1134 8
a1141 8
	case CPU_162:
		if (!va)
			va = (void *)IIOV(zs_cons_addrs_162[zsunit(unit)]);
		scc_adr_162 = (volatile struct scc_162 *)va;
		scc_cr = &scc_adr_162->cr;
		scc_dr = &scc_adr_162->dr;
		size = sizeof(struct scc_162);
		break;
d1155 2
a1156 2
	case CPU_147:
		return (PCLK_FREQ_147);
d1159 2
a1160 2
	case CPU_162:
		return (PCLK_FREQ_162);
@


1.6
log
@Fix for boards with only one zs chip.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.5 1996/06/11 10:17:40 deraadt Exp $ */
d175 1
a175 1
      if (*zstest != 0xFF)
@


1.5
log
@tty_attach()
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.4 1996/06/11 10:15:38 deraadt Exp $ */
d167 17
a183 2

	return (!badvaddr(ca->ca_vaddr, 1));
@


1.4
log
@use void * for pa/va instead of caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.2 1995/11/07 08:49:39 deraadt Exp $ */
d334 1
@


1.3
log
@cfattach/cfdriver split
@
text
@d136 1
a136 1
int	zsregs	__P((caddr_t va, int unit, volatile u_char **crp,
d1086 1
a1086 1
	caddr_t	va;
d1103 1
a1103 1
			va = (caddr_t)IIOV(zs_cons_addrs_147[zsunit(unit)]);
d1113 1
a1113 1
			va = (caddr_t)IIOV(zs_cons_addrs_162[zsunit(unit)]);
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d152 6
a157 2
struct cfdriver zscd = {
	NULL, "zs", zsmatch, zsattach, DV_TTY, sizeof(struct zssoftc), 0
d327 2
a328 2
	if (zsunit(dev) >= zscd.cd_ndevs ||
	    (sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)]) == NULL)
d367 2
a368 2
	if (zsunit(dev) > zscd.cd_ndevs ||
	    (sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)]) == NULL)
d391 1
a391 1
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
d405 1
a405 1
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
d419 1
a419 1
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
d476 1
a476 1
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
d500 1
a500 1
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
d525 1
a525 1
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
d720 1
a720 1
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[unit];
d853 2
a854 2
	for (unit = 0; unit < zscd.cd_ndevs; ++unit) {
		if (zscd.cd_devs[unit] == NULL)
d856 1
a856 1
		zp = &((struct zssoftc *) zscd.cd_devs[unit])->sc_zs[0];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: zs.c,v 1.1.1.1 1995/07/25 23:12:07 chuck Exp $	*/
d4 1
d16 5
a20 1
 * 3. The name of the author may not be used to endorse or promote products
d51 1
a52 1
#include <mvme68k/dev/iio.h>
d54 5
d60 4
a65 1
#if NZS > 0
a66 3
/*#define PCLK_FREQ	8333333*/
#undef PCLK_FREQ		/* XXXCDC */
#define PCLK_FREQ	5000000
d77 18
a94 20
	short   flags;		/* see below */
	char    rr0;		/* holds previous CTS, DCD state */
	unsigned char imask;	/* mask for input chars */
	int     nzs_open;	/* # opens as /dev/zsn */
	int     nkbd_open;	/* # opens as a keyboard */
	int     gsp_unit;	/* unit to send kbd chars to */
	struct tty *tty;	/* link to tty structure */
	struct sccregs scc;	/* SCC shadow registers */
	u_char *rcv_get;
	u_char *rcv_put;
	u_char *rcv_end;
	volatile int rcv_count;
	int     rcv_len;
	char   *send_ptr;
	int     send_count;
	int     sent_count;
	volatile char modem_state;
	volatile char modem_change;
	volatile short hflags;
	char    rcv_buf[RECV_BUF];
d111 11
a121 2
	struct device dev;
	struct zs zs[2];
d123 1
d127 12
a138 10
struct termios zs_cons_termios;
int     zs_cons_unit = 0;
int     zs_is_console = 0;
struct sccregs *zs_cons_scc;

int zsopen __P((dev_t, int, int, struct proc *));
void zsstart __P((struct tty *));
int zsparam __P((struct tty *, struct termios *));
int zsirq __P((int unit));
void zs_softint __P((void));
d140 2
a141 2
unsigned long sir_zs;
void    zs_softint();
d149 2
a150 2
void zsattach __P((struct device *, struct device *, void *));
int zsmatch __P((struct device *, void *, void *));
d159 1
a159 1
	void   *vcf, *args;
d162 1
d164 1
a164 1
	return !badbaddr((caddr_t) IIO_CFLOC_ADDR(cf));
d170 1
a170 1
	void   *args;
d172 1
a172 1
	struct zssoftc *dv;
d176 8
a183 1
	int     zs_level = IIO_CFLOC_LEVEL(self->dv_cfdata);
d185 17
a201 1
	iio_print(self->dv_cfdata);
d203 2
a204 4
	/* connect the interrupt */
	dv = (struct zssoftc *) self;
	pccintr_establish(PCCV_ZS, zsirq, zs_level, self->dv_unit);
	/* XXXCDC: needs some work to handle zs1 */
d206 6
a211 2
	zp = &dv->zs[0];
	scc = (volatile struct scc *) IIO_CFLOC_ADDR(self->dv_cfdata);
d221 3
a223 3
		scc->cr = 0;
		scc->cr = 9;
		scc->cr = 0xC0;	/* hardware reset of SCC, both sides */
d227 2
a228 1
	zp->scc.s_adr = scc + 1;
d233 2
a234 1
	zp->scc.s_adr = scc;
d239 1
d242 33
a274 4
	ir = sys_pcc->zs_int;
	if ((ir & PCC_IMASK) != 0 && (ir & PCC_IMASK) != zs_level)
		panic("zs configured at different IPLs");
	sys_pcc->zs_int = zs_level | PCC_IENABLE | PCC_ZSEXTERN;
d277 3
a279 1
zs_ttydef(struct zs *zp)
a305 1

a307 1

d312 5
a316 1
zsopen(dev_t dev, int flag, int mode, struct proc * p)
d321 1
a321 1
	struct zssoftc *dv;
d323 3
a325 3
	if (zsunit(dev) > zscd.cd_ndevs
	    || (dv = (struct zssoftc *) zscd.cd_devs[zsunit(dev)]) == NULL)
		return ENODEV;
d327 1
a327 1
	zp = &dv->zs[zsside(dev)];
d342 2
a343 3
	} else
		if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
			return (EBUSY);
d349 1
a349 1
	return error;
d360 2
a361 2
	struct zssoftc *dv;
	int     s;
d363 4
a366 4
	if (zsunit(dev) > zscd.cd_ndevs
	    || (dv = (struct zssoftc *) zscd.cd_devs[zsunit(dev)]) == NULL)
		return ENODEV;
	zp = &dv->zs[zsside(dev)];
d369 7
a375 9
	if (zp->nkbd_open == 0) {
		(*linesw[tp->t_line].l_close) (tp, flag);
		s = splzs();
		if ((zp->flags & ZS_CONSOLE) == 0 && (tp->t_cflag & HUPCL) != 0)
			ZBIC(&zp->scc, 5, 0x82);	/* drop DTR, RTS */
		ZBIC(&zp->scc, 3, 1);	/* disable receiver */
		splx(s);
		ttyclose(tp);
	}
d381 1
d383 1
a383 1
	dev_t   dev;
d385 1
a385 1
	int     flag;
d387 2
a388 2
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
	struct zs *zp = &dv->zs[zsside(dev)];
d395 1
d401 2
a402 2
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
	struct zs *zp = &dv->zs[zsside(dev)];
d408 1
d415 2
a416 2
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
	struct zs *zp = &dv->zs[zsside(dev)];
d464 1
a464 1
	return error;
d467 1
d472 2
a473 2
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &dv->zs[zsside(tp->t_dev)];
d484 2
a485 3
	else
		if ((zp->modem_state & 0x20) == 0)
			zp->hflags |= ZH_OBLOCK;
d489 1
a489 1
	return 0;
d496 2
a497 2
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &dv->zs[zsside(tp->t_dev)];
d517 3
a519 1
zsstop(struct tty * tp, int flag)
d521 2
a522 2
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &dv->zs[zsside(tp->t_dev)];
d565 4
a568 1
	ZWRITE(scc, 2, 0);
d590 1
a590 1
		return 0xFF;
d594 1
a594 1
	divisor = (PCLK_FREQ / 32 + (speed >> 1)) / speed - 2;
d627 10
d638 1
a638 1
	return imask;
d641 2
a642 1
zscc_mget(register struct sccregs * scc)
d657 1
a657 1
	return bits;
d660 3
a662 1
zscc_mset(register struct sccregs * scc, int bits)
d672 3
a674 1
zscc_mclr(register struct sccregs * scc, int bits)
d684 2
a685 1
zs_drain(register struct zs * zp)
d692 2
a693 2
	while ((ZREAD0(&zp->scc) & SCC_TXRDY) == 0
	    || (ZREAD(&zp->scc, 1) & 1) == 0) {
d701 2
a702 1
zs_unblock(register struct tty * tp)
d713 2
a714 1
zsirq(int unit)
d716 2
a717 2
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[unit];
	register struct zs *zp = &dv->zs[0];
a718 1
	register volatile struct scc *scc;
d720 3
a722 5
	x = splzs();
	scc = zp->scc.s_adr;
	scc->cr = 3;		/* read int pending from A side */
	DELAY(5);
	ipend = scc->cr;
d729 1
a729 1
	++zp;			/* now look for B side ints */
d736 4
a739 2
	splx(x);
	return ipend != 0;
d742 2
a743 1
zs_txint(register struct zs * zp)
d769 2
a770 1
zs_rxint(register struct zs * zp)
d816 2
a817 1
zs_extint(register struct zs * zp)
d852 1
a852 1
		zp = &((struct zssoftc *) zscd.cd_devs[unit])->zs[0];
a900 4
#ifdef notdef
					if (stat == 0)
						kbd_newchar(zp->gsp_unit, c);
#endif
a937 43
 * Routines to divert an SCC channel to the input side of /dev/gsp
 * for the keyboard.
 */
int
zs_kbdopen(int unit, int gsp_unit, struct termios * tiop, struct proc * p)
{
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(unit)];
	struct zs *zp = &dv->zs[zsside(unit)];
	int     error;

	error = zsopen(unit, 0, 0, p);
	if (error != 0)
		return error;
	++zp->nkbd_open;
	--zp->nzs_open;
	zsparam(zp->tty, tiop);
	zp->gsp_unit = gsp_unit;
	return 0;
}

void
zs_kbdclose(int unit)
{
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(unit)];
	struct zs *zp = &dv->zs[zsside(unit)];

	zp->nkbd_open = 0;
	if (zp->nzs_open == 0)
		zsclose(unit, 0, 0, 0);
}

void
zs_kbdput(int unit, int c)
{
	struct zssoftc *dv = (struct zssoftc *) zscd.cd_devs[zsunit(unit)];
	struct zs *zp = &dv->zs[zsside(unit)];
	struct tty *tp = zp->tty;

	putc(c, &tp->t_outq);
	zsstart(tp);
}

/*
d945 10
a954 3
	int     maj;
	char   *prom_cons;
	extern char *prom_getvar();
d963 1
a963 1
	cp->cn_pri = CN_NORMAL;
d965 1
a965 1
	return 1;
d972 1
a972 1
	TTYDEF_CFLAG,
a981 3
unsigned zs_cons_addrs[] = {ZS0_PHYS, ZS1_PHYS};


d989 2
a990 1
zscngetc(dev_t dev)
d995 1
a995 1
	s = splzs();
d1007 1
a1007 1
	return c;
d1010 3
a1012 1
zscnputc(dev_t dev, int c)
d1017 3
a1019 2
	s = splzs();
	while ((ZREAD0(scc) & SCC_TXRDY) == 0);
d1024 3
a1026 1
zs_cnsetup(int unit, struct termios * tiop)
d1028 3
a1030 2
	register volatile struct scc *scc_adr;
	register struct sccregs *scc;
d1036 14
a1049 1
	scc_adr = (volatile struct scc *) IIOV(zs_cons_addrs[zsunit(unit)]);
d1051 6
a1056 8
	scc_adr[1].cr = 0;
	scc_adr[1].cr = 9;
	scc_adr[1].cr = 0xC0;	/* hardware reset of SCC, both sides */
	if (!zsside(unit))
		++scc_adr;

	scc->s_adr = scc_adr;
	ZWRITE(scc, 2, 0);
d1066 7
d1074 5
a1078 2
 * Routines for using the keyboard SCC as the input side of
 * the 'gsp' console device.
d1080 14
d1095 30
a1124 4
/* probe for the keyboard; should check hardware */
zs_kbdcnprobe(cp, unit)
	struct consdev *cp;
	int     unit;
d1126 10
a1135 1
	return (unsigned) unit < NZSLINE;
a1136 1
#endif				/* NZS */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: zs.c,v 1.4 1994/10/26 02:33:32 cgd Exp $	*/
a3 1
 * Copyright (c) 1995 Theo de Raadt
a45 1
#include <machine/autoconf.h>
d47 1
a48 5

#include "pcc.h"
#include "mc.h"

#if NPCC > 0
a49 4
#endif
#if NMC > 0
#include <mvme68k/dev/mcreg.h>
#endif
d52 1
d54 3
d67 20
a86 18
	short		flags;		/* see below */
	char		rr0;		/* holds previous CTS, DCD state */
	u_char		imask;		/* mask for input chars */
	int		nzs_open;	/* # opens as /dev/zsn */
	struct tty	*tty;		/* link to tty structure */
	struct sccregs	scc;		/* SCC shadow registers */
	u_char		*rcv_get;
	u_char		*rcv_put;
	u_char		*rcv_end;
	volatile int	rcv_count;
	int		rcv_len;
	char		*send_ptr;
	int		send_count;
	int		sent_count;
	volatile char	modem_state;
	volatile char	modem_change;
	volatile short	hflags;
	char		rcv_buf[RECV_BUF];
d103 2
a104 11
	struct device	sc_dev;
	struct zs	sc_zs[2];
	struct evcnt	sc_intrcnt;
	struct intrhand	sc_ih;
#if NPCC > 0
	struct pccreg	*sc_pcc;
#endif
#if NMC > 0
	struct mcreg	*sc_mc;
#endif
	int		sc_flags;
a105 1
#define ZSSF_85230	1
d109 10
a118 12
struct	termios zs_cons_termios;
int	zs_cons_unit = 0;
int	zs_is_console = 0;
struct	sccregs *zs_cons_scc;

int	zsopen	__P((dev_t, int, int, struct proc *));
void	zsstart	__P((struct tty *));
int	zsparam	__P((struct tty *, struct termios *));
int	zsirq	__P((int unit));
int	zsregs	__P((caddr_t va, int unit, volatile u_char **crp,
	    volatile u_char **drp));
int	zspclk	__P((void));
d120 2
a121 2
u_long	sir_zs;
void	zs_softint __P((void));
d129 2
a130 2
void	zsattach __P((struct device *, struct device *, void *));
int	zsmatch __P((struct device *, void *, void *));
d139 1
a139 1
	void	*vcf, *args;
a141 1
	struct confargs *ca = args;
d143 1
a143 1
	return (!badvaddr(ca->ca_vaddr, 1));
d149 1
a149 1
	void	*args;
d151 1
a151 1
	struct zssoftc *sc;
d155 3
a157 5
	volatile u_char *scc_cr, *scc_dr;
	struct confargs *ca = args;
	int     zs_level = ca->ca_ipl;
	int	size;
	static int initirq = 0;
d160 3
a162 22
	sc = (struct zssoftc *) self;

	sc->sc_ih.ih_fn = zsirq;
	sc->sc_ih.ih_arg = (void *)self->dv_unit;
	sc->sc_ih.ih_ipl = zs_level;
	switch (ca->ca_bustype) {
#if NPCC > 0
	case BUS_PCC:
		pccintr_establish(PCCV_ZS, &sc->sc_ih);
		sc->sc_pcc = (struct pccreg *)ca->ca_master;
		break;
#endif
#if NMC > 0
	case BUS_MC:
		mcintr_establish(MCV_ZS, &sc->sc_ih);
		sc->sc_mc = (struct mcreg *)ca->ca_master;
		break;
#endif
	}

	zp = &sc->sc_zs[0];
	scc = (volatile struct scc *)ca->ca_vaddr;
d164 2
a165 6
	/*
	 * the locations of the control and data register move around
	 * on different MVME models, so we generate independent pointers
	 * to them.
	 */
	size = zsregs(ca->ca_vaddr, 0, &scc_cr, &scc_dr);
d175 3
a177 3
		*(scc_cr + size) = 0;
		*(scc_cr + size) = 9;
		*(scc_cr + size) = 0xC0;	/* hardware reset of SCC, both sides */
d181 1
a181 2
	zp->scc.s_cr = scc_cr + size;
	zp->scc.s_dr = scc_dr + size;
d186 1
a186 2
	zp->scc.s_cr = scc_cr;
	zp->scc.s_dr = scc_dr;
a190 1

d193 4
a196 33
	/*
	 * XXX we end up doing this twice... once for
	 * each ZS chip. We should really not turn interrupts on until
	 * we have initialized the last of the two chips. But then we
	 * will need to search the config system to see if we will be
	 * called for the 2nd chip... otherwise, a config without a zs1
	 * would never enable interrupts!
	 */
	switch (ca->ca_bustype) {
#if NPCC > 0
	case BUS_PCC:
		ir = sc->sc_pcc->pcc_zsirq;
		if ((ir & PCC_IRQ_IPL) != 0 && (ir & PCC_IRQ_IPL) != zs_level)
			panic("zs configured at different IPLs");
		if (initirq)
			break;
		sc->sc_pcc->pcc_zsirq = zs_level | PCC_IRQ_IEN | PCC_ZS_PCCVEC;
		break;
#endif
#if NMC > 0
	case BUS_MC:
		ir = sc->sc_mc->mc_zsirq;
		if ((ir & MC_IRQ_IPL) != 0 && (ir & MC_IRQ_IPL) != zs_level)
			panic("zs configured at different IPLs");
		if (initirq)
			break;
		sc->sc_mc->mc_zsirq = zs_level | MC_IRQ_IEN;
		break;
#endif
	}
	initirq = 1;

	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d199 1
a199 3
void
zs_ttydef(zp)
	struct zs *zp;
d226 1
d229 1
d234 1
a234 5
int
zsopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d239 1
a239 1
	struct zssoftc *sc;
d241 3
a243 3
	if (zsunit(dev) >= zscd.cd_ndevs ||
	    (sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)]) == NULL)
		return (ENODEV);
d245 1
a245 1
	zp = &sc->sc_zs[zsside(dev)];
d260 3
a262 2
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
		return (EBUSY);
d268 1
a268 1
	return (error);
d279 2
a280 2
	struct zssoftc *sc;
	int s;
d282 4
a285 4
	if (zsunit(dev) > zscd.cd_ndevs ||
	    (sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)]) == NULL)
		return (ENODEV);
	zp = &sc->sc_zs[zsside(dev)];
d288 9
a296 7
	(*linesw[tp->t_line].l_close) (tp, flag);
	s = splzs();
	if ((zp->flags & ZS_CONSOLE) == 0 && (tp->t_cflag & HUPCL) != 0)
		ZBIC(&zp->scc, 5, 0x82);        /* drop DTR, RTS */
	ZBIC(&zp->scc, 3, 1);   /* disable receiver */
	splx(s);
	ttyclose(tp);
a301 1
int
d303 1
a303 1
	dev_t	dev;
d305 1
a305 1
	int	flag;
d307 2
a308 2
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
	struct zs *zp = &sc->sc_zs[zsside(dev)];
a314 1
int
d320 2
a321 2
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
	struct zs *zp = &sc->sc_zs[zsside(dev)];
a326 1
int
d333 2
a334 2
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(dev)];
	struct zs *zp = &sc->sc_zs[zsside(dev)];
d382 1
a382 1
	return (error);
a384 1
int
d389 2
a390 2
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &sc->sc_zs[zsside(tp->t_dev)];
d401 3
a403 2
	else if ((zp->modem_state & 0x20) == 0)
		zp->hflags |= ZH_OBLOCK;
d407 1
a407 1
	return (0);
d414 2
a415 2
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &sc->sc_zs[zsside(tp->t_dev)];
d435 1
a435 3
zsstop(tp, flag)
	struct tty *tp;
	int flag;
d437 2
a438 2
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[zsunit(tp->t_dev)];
	struct zs *zp = &sc->sc_zs[zsside(tp->t_dev)];
d481 1
a481 4
#ifdef MVME162
	if (cputyp == CPU_162)
		ZWRITE(scc, 2, MC_VECBASE+MCV_ZS);
#endif
d503 1
a503 1
		return (0xFF);
d507 1
a507 1
	divisor = (zspclk() / 32 + (speed >> 1)) / speed - 2;
a539 10
#if 0
	if (cputyp == CPU_162) {
		ZWRITE(scc, 15, ints | 1);
		/*
		 * now.. register 7 has become register 7': disable all
		 * 82530-only features for now
		 */
		ZWRITE(scc, 7, 0x20);
	}
#endif
d541 1
a541 1
	return (imask);
d544 1
a544 2
zscc_mget(scc)
	register struct sccregs *scc;
d559 1
a559 1
	return (bits);
d562 1
a562 3
zscc_mset(scc, bits)
	register struct sccregs *scc;
	int bits;
d572 1
a572 3
zscc_mclr(scc, bits)
	register struct sccregs *scc;
	int bits;
d582 1
a582 2
zs_drain(zp)
	register struct zs *zp;
d589 2
a590 2
	while ((ZREAD0(&zp->scc) & SCC_TXRDY) == 0 ||
	    (ZREAD(&zp->scc, 1) & 1) == 0) {
d598 1
a598 2
zs_unblock(tp)
	register struct tty *tp;
d609 1
a609 2
zsirq(unit)
	int unit;
d611 2
a612 2
	struct zssoftc *sc = (struct zssoftc *) zscd.cd_devs[unit];
	register struct zs *zp = &sc->sc_zs[0];
d614 1
d616 5
a620 3
	ipend = ZREAD(&zp->scc, 3);	/* read int pending from A side */
	if (ipend == 0)
		return (0);
d627 1
a627 1
	++zp;				/* now look for B side ints */
d634 2
a635 4
	ZWRITE0(&zp->scc, 0x38);	/* reset highest IUS */

	sc->sc_intrcnt.ev_count++;
	return (1);
d638 1
a638 2
zs_txint(zp)
	register struct zs *zp;
d664 1
a664 2
zs_rxint(zp)
	register struct zs *zp;
d710 1
a710 2
zs_extint(zp)
	register struct zs *zp;
d745 1
a745 1
		zp = &((struct zssoftc *) zscd.cd_devs[unit])->sc_zs[0];
d794 4
d835 43
d885 3
a887 10
	int maj;

	switch (cputyp) {
	case CPU_147:
	case CPU_162:
		break;
	default:
		cp->cn_pri = CN_DEAD;
		return (0);
	}
d896 1
a896 1
	cp->cn_pri = CN_INTERNAL;	/* better than PROM console */
d898 1
a898 1
	return (1);
d905 1
a905 1
	(CREAD | CS8 | HUPCL),
d915 3
d925 1
a925 2
zscngetc(dev)
	dev_t dev;
d930 1
a930 1
	s = splhigh();	/* XXX was splzs() */
d942 1
a942 1
	return (c);
d945 1
a945 3
zscnputc(dev, c)
	dev_t dev;
	int c;
d950 2
a951 3
	s = splhigh();	/* XXX was splzs() */
	while ((ZREAD0(scc) & SCC_TXRDY) == 0)
		;
d956 1
a956 3
zs_cnsetup(unit, tiop)
	int unit;
	struct termios *tiop;
d958 2
a959 3
	volatile u_char *scc_cr, *scc_dr;
	struct sccregs *scc;
	int size;
d965 7
a971 14
	/*
	 * the locations of the control and data register move around
	 * on different MVME models, so we generate independent pointers
	 * to them.
	 */
	size = zsregs(NULL, unit, &scc_cr, &scc_dr);

	*(scc_cr + size) = 0;
	*(scc_cr + size) = 9;
	*(scc_cr + size) = 0xC0;	/* hardware reset of SCC, both sides */
	if (!zsside(unit)) {
		scc_cr += size;
		scc_dr += size;
	}
d973 2
a974 6
	scc->s_cr = scc_cr;
	scc->s_dr = scc_dr;
#ifdef MVME162
	if (cputyp == CPU_162)
		ZWRITE(scc, 2, MC_VECBASE+MCV_ZS);
#endif
a983 7
#ifdef MVME147
u_long zs_cons_addrs_147[] = { ZS0_PHYS_147, ZS1_PHYS_147 };
#endif
#ifdef MVME162
u_long zs_cons_addrs_162[] = { ZS0_PHYS_162, ZS1_PHYS_162 };
#endif

d985 2
a986 5
 * fills in pointers to the registers and returns how far apart
 * the two halves of the chip are.
 * 
 * it vaddr == NULL, it tries to determine the hardware address in
 * an intelligent fashion from the unit number.
a987 14
int
zsregs(va, unit, crp, drp)
	caddr_t	va;
	int unit;
	volatile u_char **crp, **drp;
{
#ifdef MVME147
	volatile struct scc_147 *scc_adr_147;
#endif
#ifdef MVME162
	volatile struct scc_162 *scc_adr_162;
#endif
	volatile u_char *scc_cr, *scc_dr;
	int size;
d989 4
a992 30
	switch (cputyp) {
#ifdef MVME147
	case CPU_147:
		if (!va)
			va = (caddr_t)IIOV(zs_cons_addrs_147[zsunit(unit)]);
		scc_adr_147 = (volatile struct scc_147 *)va;
		scc_cr = &scc_adr_147->cr;
		scc_dr = &scc_adr_147->dr;
		size = sizeof(struct scc_147);
		break;
#endif
#ifdef MVME162
	case CPU_162:
		if (!va)
			va = (caddr_t)IIOV(zs_cons_addrs_162[zsunit(unit)]);
		scc_adr_162 = (volatile struct scc_162 *)va;
		scc_cr = &scc_adr_162->cr;
		scc_dr = &scc_adr_162->dr;
		size = sizeof(struct scc_162);
		break;
#endif
	}

	*crp = scc_cr;
	*drp = scc_dr;
	return (size);
}

int
zspclk()
d994 1
a994 10
	switch (cputyp) {
#ifdef MVME147
	case CPU_147:
		return (PCLK_FREQ_147);
#endif
#ifdef MVME162
	case CPU_162:
		return (PCLK_FREQ_162);
#endif
	}
d996 1
@
