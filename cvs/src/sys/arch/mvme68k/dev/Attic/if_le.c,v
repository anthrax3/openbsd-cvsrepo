head	1.35;
access;
symbols
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.20
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.18
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.16
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.14
	OPENBSD_5_0:1.33.0.12
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.10
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.8
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.4
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.31.0.12
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.10
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.8
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.6
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.20
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.10
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.8
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.6
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.4
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.34;

1.34
date	2013.09.24.20.10.46;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.21.20.33.08;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.17.22.28.40;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.11.07.21.58;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.24.22.43.16;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.30.22.29.45;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.30.09.50.15;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.02.17.57.29;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.29.06.23.44;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.30.21.25.58;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.14.19.23.11;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.13.13.17.21;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.29.09.08.17;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.29.06.26.50;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.21.20.45.51;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.19.04.07.09;	author deraadt;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.01.29.04.11.25;	author smurph;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.01.24.05.20.53;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	98.09.16.22.41.18;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	97.08.08.08.31.50;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.08.20.05.17.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.06.11.10.08.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.29.17.54.12;	author chuck;	state Exp;
branches;
next	1.7;

1.7
date	96.05.10.12.42.24;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.06.21.53.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.05.13.37.32;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.04.28.11.06.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.31.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.10;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.43.03;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2002.03.06.01.07.00;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	1.14.2.6;

1.14.2.6
date	2004.06.05.23.10.53;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.15;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.36.49;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: if_le.c,v 1.34 2013/09/24 20:10:46 miod Exp $ */

/*-
 * Copyright (c) 1982, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 10/30/93
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <net/if_media.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <dev/ic/lancereg.h>
#include <dev/ic/lancevar.h>
#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>

#include <mvme68k/dev/if_lereg.h>
#include <mvme68k/dev/if_levar.h>
#include <mvme68k/dev/vme.h>

#include "pcc.h"
#if NPCC > 0
#include <mvme68k/dev/pccreg.h>
#endif

/* autoconfiguration driver */
void  leattach(struct device *, struct device *, void *);
int   lematch(struct device *, void *, void *);

struct cfattach le_ca = {
	sizeof(struct le_softc), lematch, leattach
};

void	lewrcsr(struct lance_softc *, uint16_t, uint16_t);
uint16_t lerdcsr(struct lance_softc *, uint16_t);
void	vlewrcsr(struct lance_softc *, uint16_t, uint16_t);
uint16_t vlerdcsr(struct lance_softc *, uint16_t);
void	nvram_cmd(struct lance_softc *, uint8_t, uint16_t);
uint16_t nvram_read(struct lance_softc *, uint8_t);
void	vleetheraddr(struct lance_softc *);
void	vleinit(struct lance_softc *);
void	vlereset(struct lance_softc *);
int	vle_intr(void *);

/* send command to the nvram controller */
void
nvram_cmd(struct lance_softc *sc, uint8_t cmd, uint16_t addr)
{
	int i;
	struct vlereg1 *reg1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;

	for (i=0;i<8;i++) {
		reg1->ler1_ear=((cmd|(addr<<1))>>i); 
		CDELAY; 
	} 
}

/* read nvram one bit at a time */
uint16_t
nvram_read(struct lance_softc *sc, uint8_t nvram_addr)
{
	uint16_t val = 0, mask = 0x04000;
	uint16_t wbit;
	/* these used by macros DO NOT CHANGE!*/
	struct vlereg1 *reg1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
	((struct le_softc *)sc)->csr = 0x4f;
	ENABLE_NVRAM;
	nvram_cmd(sc, NVRAM_RCL, 0);
	DISABLE_NVRAM;
	CDELAY;
	ENABLE_NVRAM;
	nvram_cmd(sc, NVRAM_READ, nvram_addr);
	for (wbit=0; wbit<15; wbit++) {
		(reg1->ler1_ear & 0x01) ? (val = (val | mask)) : (val = (val & (~mask)));
		mask = mask>>1;
		CDELAY;
	}
	(reg1->ler1_ear & 0x01) ? (val = (val | 0x8000)) : (val = (val & 0x7FFF));
	CDELAY;
	DISABLE_NVRAM;
	return (val);
}

void
vleetheraddr(struct lance_softc *sc)
{
	uint8_t * cp = sc->sc_arpcom.ac_enaddr;
	uint16_t ival[3];
	uint8_t i;

	for (i=0; i<3; i++) {
		ival[i] = nvram_read(sc, i);
	}
	memcpy(cp, &ival[0], 6);
}

void
lewrcsr(struct lance_softc *sc, uint16_t port, uint16_t val)
{
	struct lereg1 *ler1 = (struct lereg1 *)((struct le_softc *)sc)->sc_r1;

	ler1->ler1_rap = port;
	ler1->ler1_rdp = val;
}

void
vlewrcsr(struct lance_softc *sc, uint16_t port, uint16_t val)
{
	struct vlereg1 *ler1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;

	ler1->ler1_rap = port;
	ler1->ler1_rdp = val;
}

uint16_t
lerdcsr(struct lance_softc *sc, uint16_t port)
{
	struct lereg1 *ler1 = (struct lereg1 *)((struct le_softc *)sc)->sc_r1;
	uint16_t val;

	ler1->ler1_rap = port;
	val = ler1->ler1_rdp;
	return (val);
}

uint16_t
vlerdcsr(struct lance_softc *sc, uint16_t port)
{
	struct vlereg1 *ler1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
	uint16_t val;

	ler1->ler1_rap = port;
	val = ler1->ler1_rdp;
	return (val);
}

/* init MVME376, set ipl and vec */
void
vleinit(struct lance_softc *sc)
{
	struct vlereg1 *reg1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
	uint8_t vec = ((struct le_softc *)sc)->sc_vec;
	uint8_t ipl = ((struct le_softc *)sc)->sc_ipl;
	((struct le_softc *)sc)->csr = 0x4f;
	WRITE_CSR_AND( ~ipl );
	SET_VEC(vec);
	return;
}

/* MVME376 hardware reset */
void
vlereset(struct lance_softc *sc)
{
	struct vlereg1 *reg1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
	RESET_HW;
#ifdef LEDEBUG
	if (sc->sc_debug) {
		printf("\nle: hardware reset\n");
	}
#endif
	SYSFAIL_CL;
	return;
}

int
vle_intr(void *sc)
{
	struct vlereg1 *reg1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
	int rc;
	rc = am7990_intr(sc);
	ENABLE_INTR;
	return (rc);
}

int
lematch(struct device *parent, void *vcf, void *args)
{
	struct confargs *ca = args;
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;
	int rc;

	switch (ca->ca_bustype) {
	case BUS_PCC:
		return (!badvaddr((vaddr_t)ca->ca_vaddr, 2));
	case BUS_VMES:
		if (bus_space_map(iot, ca->ca_paddr, VLEREGSIZE, 0, &ioh) != 0)
			return 0;
		rc = badvaddr((vaddr_t)bus_space_vaddr(iot, ioh), 2);
		bus_space_unmap(iot, ioh, VLEREGSIZE);
		return rc == 0;
	default:
		return 0;
	}
}

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
void
leattach(struct device *parent, struct device *self, void *aux)
{
	struct le_softc *lesc = (struct le_softc *)self;
	struct lance_softc *sc = &lesc->sc_am7990.lsc;
	struct confargs *ca = aux;
	int pri = ca->ca_ipl;
	extern void *etherbuf;
	paddr_t addr;
	int card;
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh, memh;

	/* XXX the following declarations should be elsewhere */
	extern void myetheraddr(uint8_t *);

	switch (ca->ca_bustype) {
	case BUS_VMES:
		/* 
		 * get the first available etherbuf.  MVME376 uses its own
		 * dual-ported RAM for etherbuf.  It is set by dip switches
		 * on board.  We support the six Motorola address locations,
		 * however, the board can be set up at any other address.
		 * XXX These physical addresses should be mapped in extio!!!
		 */
		switch (ca->ca_paddr) {
		case 0xffff1200:
			card = 0;
			break;
		case 0xffff1400:
			card = 1;
			break;
		case 0xffff1600:
			card = 2;
			break;
		case 0xffff5400:
			card = 3;
			break;
		case 0xffff5600:
			card = 4;
			break;
		case 0xffffa400:
			card = 5;
			break;
		default:
			printf(": unsupported address\n");
			return;
		}

		if (bus_space_map(iot, ca->ca_paddr, VLEREGSIZE, 0, &ioh) !=
		    0) {
			printf(": can't map registers!\n");
			return;
		}

		addr = VLEMEMBASE - (card * VLEMEMSIZE);
		if (bus_space_map(iot, addr, VLEMEMSIZE, BUS_SPACE_MAP_LINEAR,
		    &memh) != 0) {
			printf(": can't map buffers!\n");
			bus_space_unmap(iot, ioh, VLEREGSIZE);
			return;
		}
		lesc->sc_r1 = (void *)bus_space_vaddr(iot, ioh);
		lesc->sc_ipl = ca->ca_ipl;
		lesc->sc_vec = ca->ca_vec;

		sc->sc_mem = (void *)bus_space_vaddr(iot, memh);
		sc->sc_memsize = VLEMEMSIZE;
		sc->sc_addr = addr & 0x00ffffff;
		sc->sc_conf3 = LE_C3_BSWP;
		sc->sc_hwreset = vlereset;
		sc->sc_rdcsr = vlerdcsr;
		sc->sc_wrcsr = vlewrcsr;
		sc->sc_hwinit = vleinit;
		sc->sc_copytodesc = lance_copytobuf_contig;
		sc->sc_copyfromdesc = lance_copyfrombuf_contig;
		sc->sc_copytobuf = lance_copytobuf_contig;
		sc->sc_copyfrombuf = lance_copyfrombuf_contig;
		sc->sc_zerobuf = lance_zerobuf_contig;
		/* get ether address */
		vleetheraddr(sc);
		break;      
	case BUS_PCC:
		sc->sc_mem = etherbuf;
		lesc->sc_r1 = (void *)ca->ca_vaddr;
		sc->sc_conf3 = LE_C3_BSWP /*| LE_C3_ACON | LE_C3_BCON*/;
		sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);
		sc->sc_memsize = LEMEMSIZE;
		sc->sc_rdcsr = lerdcsr;
		sc->sc_wrcsr = lewrcsr;
		sc->sc_hwreset = NULL;
		sc->sc_hwinit = NULL;
		sc->sc_copytodesc = lance_copytobuf_contig;
		sc->sc_copyfromdesc = lance_copyfrombuf_contig;
		sc->sc_copytobuf = lance_copytobuf_contig;
		sc->sc_copyfrombuf = lance_copyfrombuf_contig;
		sc->sc_zerobuf = lance_zerobuf_contig;
		/* get ether address */
		myetheraddr(sc->sc_arpcom.ac_enaddr);
		break;
	default:
		printf(": unknown bus type\n");
		return;
	}

	am7990_config(&lesc->sc_am7990);

	/* connect the interrupt */
	switch (ca->ca_bustype) {
	case BUS_VMES:
		lesc->sc_ih.ih_fn = vle_intr;
		lesc->sc_ih.ih_arg = sc;
		lesc->sc_ih.ih_ipl = pri;
		vmeintr_establish(ca->ca_vec + 0, &lesc->sc_ih, self->dv_xname);
		break;
#if NPCC > 0
	case BUS_PCC:
		lesc->sc_ih.ih_fn = am7990_intr;
		lesc->sc_ih.ih_arg = sc;
		lesc->sc_ih.ih_ipl = pri;
		pccintr_establish(PCCV_LE, &lesc->sc_ih, self->dv_xname);
		sys_pcc->pcc_leirq = pri | PCC_IRQ_IEN;
		break;
#endif
	}
}
@


1.34
log
@Sync the MI LANCE code ( le(4) ) with NetBSD, except for the following:
- the am7990_get() - now lance_get() - is unchanged.
- the interrupt acknowledge logic is unchanged, and will disable interrupts,
  then acknowledge all interrupt conditions.

Add ILACC (79900) support (from NetBSD).

Both LANCE (am7990.c) and ILACC (am79900.c) code share as much common code
(lance.c) as possible. This affects all le(4) attachments, but the changes
are mostly mechanical, to split am7990-specific parts from lance-agnostic
parts.

Compile tested on all affected platforms. Tested on alpha, hp300, luna88k,
mvme88k, sparc, sparc64 and vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.33 2009/02/21 20:33:08 miod Exp $ */
@


1.33
log
@No need to use special copy{from,to}buf for MVME376, the board's buffers
are mapped uncached anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.32 2009/02/17 22:28:40 miod Exp $ */
d56 2
d78 10
a87 12
static int lebustype;

void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
void vlewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t vlerdcsr(struct am7990_softc *, u_int16_t);
void nvram_cmd(struct am7990_softc *, u_char, u_short);
u_int16_t nvram_read(struct am7990_softc *, u_char);
void vleetheraddr(struct am7990_softc *);
void vleinit(struct am7990_softc *);
void vlereset(struct am7990_softc *);
int vle_intr(void *);
d91 1
a91 4
nvram_cmd(sc, cmd, addr)
	struct am7990_softc *sc;
	u_char cmd;
	u_short addr;
d103 2
a104 4
u_int16_t
nvram_read(sc, nvram_addr)
	struct am7990_softc *sc;
	u_char nvram_addr;
d106 2
a107 2
	u_short val = 0, mask = 0x04000;
	u_int16_t wbit;
d129 1
a129 2
vleetheraddr(sc)
	struct am7990_softc *sc;
d131 3
a133 3
	u_char * cp = sc->sc_arpcom.ac_enaddr;
	u_int16_t ival[3];
	u_char i;
d142 1
a142 3
lewrcsr(sc, port, val)
	struct am7990_softc *sc;
	u_int16_t port, val;
d144 1
a144 1
	register struct lereg1 *ler1 = (struct lereg1 *)((struct le_softc *)sc)->sc_r1;
d151 1
a151 3
vlewrcsr(sc, port, val)
	struct am7990_softc *sc;
	u_int16_t port, val;
d153 1
a153 1
	register struct vlereg1 *ler1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
d159 2
a160 4
u_int16_t
lerdcsr(sc, port)
	struct am7990_softc *sc;
	u_int16_t port;
d162 2
a163 2
	register struct lereg1 *ler1 = (struct lereg1 *)((struct le_softc *)sc)->sc_r1;
	u_int16_t val;
d170 2
a171 4
u_int16_t
vlerdcsr(sc, port)
	struct am7990_softc *sc;
	u_int16_t port;
d173 2
a174 2
	register struct vlereg1 *ler1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
	u_int16_t val;
d183 1
a183 2
vleinit(sc)
	struct am7990_softc *sc;
d185 3
a187 3
	register struct vlereg1 *reg1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
	u_char vec = ((struct le_softc *)sc)->sc_vec;
	u_char ipl = ((struct le_softc *)sc)->sc_ipl;
d196 1
a196 2
vlereset(sc)
	struct am7990_softc *sc;
d198 1
a198 1
	register struct vlereg1 *reg1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
d210 1
a210 2
vle_intr(sc)
	void *sc;
d212 1
a212 1
	register struct vlereg1 *reg1 = (struct vlereg1 *)((struct le_softc *)sc)->sc_r1;
d220 1
a220 3
lematch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
d247 1
a247 4
leattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d249 2
a250 2
	register struct le_softc *lesc = (struct le_softc *)self;
	struct am7990_softc *sc = &lesc->sc_am7990;
d260 1
a260 1
	extern void myetheraddr(u_char *);
d262 1
a262 3
	lebustype = ca->ca_bustype;

	switch (lebustype) {
d320 5
a324 5
		sc->sc_copytodesc = am7990_copytobuf_contig;
		sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
		sc->sc_copytobuf = am7990_copytobuf_contig;
		sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
		sc->sc_zerobuf = am7990_zerobuf_contig;
d338 5
a342 5
		sc->sc_copytodesc = am7990_copytobuf_contig;
		sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
		sc->sc_copytobuf = am7990_copytobuf_contig;
		sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
		sc->sc_zerobuf = am7990_zerobuf_contig;
d351 1
a351 1
	am7990_config(sc);
d354 1
a354 1
	switch (lebustype) {
@


1.32
log
@Add real bus_space and bus_dma to mvme68k, so that it can benefit from
recent driver work; this gives us better osiop and vs drivers, vsbic
(although currently disabled on 68060 boards until more bugs are fixed),
and the ability to boot and root off vs and vsbic.

Existing code is not modified and still uses memory mapped structures;
this might change eventually as more code gets factorized and moved to
MI land.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.31 2006/01/11 07:21:58 miod Exp $ */
a87 2
void vle_copytobuf_contig(struct am7990_softc *, void *, int, int);
void vle_zerobuf_contig(struct am7990_softc *, int, int);
a235 34
void
vle_copytobuf_contig(sc, from, boff, len)
	struct am7990_softc *sc;
	void *from;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/* 
	 * Do the cache stuff 
	 */
	dma_cachectl(buf + boff, len);
	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(from, buf + boff, len);
}

void
vle_zerobuf_contig(sc, boff, len)
	struct am7990_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	/* 
	 * Do the cache stuff 
	 */
	dma_cachectl(buf + boff, len);
	/*
	 * Just let bzero() do the work
	 */
	bzero(buf + boff, len);
}

d344 1
a344 1
		sc->sc_copytodesc = vle_copytobuf_contig;
d346 1
a346 1
		sc->sc_copytobuf = vle_copytobuf_contig;
@


1.31
log
@Switch to __HAVE_DEVICE_REGISTER to find the device we're booted from.
Simpler, better.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.30 2005/11/24 22:43:16 miod Exp $ */
d278 3
a280 3
	/* check physical addr for bogus MVME162 addr @@0xffffd200. weird XXX - smurph */
	if (cputyp == CPU_162 && ca->ca_paddr == 0xffffd200)
		return (0);
d282 12
a293 1
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 2));
d314 2
d355 6
d362 4
a365 5

		sc->sc_mem = (void *)mapiodev(addr, VLEMEMSIZE);
		if (sc->sc_mem == NULL) {
			printf("\n%s: no more memory in external I/O map\n",
			    sc->sc_dev.dv_xname);
d368 1
a368 3
		sc->sc_addr = addr & 0x00ffffff;

		lesc->sc_r1 = (void *)ca->ca_vaddr;
d371 2
d374 1
@


1.30
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.29 2004/07/30 22:29:45 miod Exp $ */
a307 4

	/* Are we the boot device? */
	if (ca->ca_paddr == bootaddr)
		bootdv = self;
@


1.29
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.28 2004/07/30 09:50:15 miod Exp $ */
d279 1
a279 1
	if (cputyp == CPU_162 && ca->ca_paddr == (void *)0xffffd200)
d301 1
a301 1
	caddr_t addr;
d322 1
a322 1
		switch ((int)ca->ca_paddr) {
d346 1
a346 1
		addr = (caddr_t)(VLEMEMBASE - (card * VLEMEMSIZE));
d354 1
a354 1
		sc->sc_addr = (paddr_t)addr & 0x00ffffff;
@


1.28
log
@Switch mvme68k to evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.27 2004/07/02 17:57:29 miod Exp $ */
a42 1
#include <sys/evcount.h>
d404 1
a404 1
		vmeintr_establish(ca->ca_vec + 0, &lesc->sc_ih);
d411 1
a411 1
		pccintr_establish(PCCV_LE, &lesc->sc_ih);
a415 3

	evcount_attach(&lesc->sc_intrcnt, self->dv_xname,
	    (void *)&lesc->sc_ih.ih_ipl, &evcount_intr);
@


1.27
log
@Kill ca_master in autoconf structures. Drivers either only attach to one
specific bus (mc/pcc/pcctwo), or they know it from the ca_bustype value,
and can use the globals sys_busname variables.

This also allows for some code simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.26 2004/04/29 06:23:44 miod Exp $ */
d43 1
a395 7
	evcnt_attach(&sc->sc_dev, "intr", &lesc->sc_intrcnt);
	evcnt_attach(&sc->sc_dev, "errs", &lesc->sc_errcnt);

	/*
	if (lebustype == BUS_VMES) 
		vleinit(sc);
	*/
d417 3
@


1.26
log
@Correctly initialize the hardware's memory address on MVME376, it uses
A24 accesses. Fixes the reccurent timeout problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.25 2003/12/30 21:25:58 miod Exp $ */
d419 1
a419 1
		((struct pccreg *)ca->ca_master)->pcc_leirq = pri | PCC_IRQ_IEN;
@


1.25
log
@Add support for all six Motorola-supported configurations of MVME376
cards. The original code would only work with the first configuration,
as the etherbuf addresses grow _downwards_ from 0xfd6c0000 with Motorola's
jumper configuration.

Reference: MVME376 Ethernet Communication Controller User's Manual (MVME376/D1)

While there, do not panic() on failure to attach, but simply print an
error message and return.

XXX Proper care of the memory mapping still needs to be written, as the memory
XXX space of the MVME376 is always outside extio.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.24 2003/10/14 19:23:11 miod Exp $ */
d354 1
a354 5
		sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);
		if (sc->sc_addr == 0L) {
			printf("\n%s: kvtop() failed!\n", sc->sc_dev.dv_xname);
			return;
		}
@


1.24
log
@Oops, unbrek.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.23 2003/10/13 13:17:21 miod Exp $ */
d302 1
d316 5
a320 5
		 * get the first available etherbuf.  MVME376 uses its own dual-ported 
		 * RAM for etherbuf.  It is set by dip switches on board.  We support 
		 * the four Motorola address locations, however, the board can be set up 
		 * at any other address. We must map this space into the extio map. 
		 * XXX-smurph.
d323 2
a324 2
		case 0xFFFF1200:
			addr = (caddr_t)0xFD6C0000;
d326 2
a327 2
		case 0xFFFF1400:
			addr = (caddr_t)0xFD700000;
d329 2
a330 2
		case 0xFFFF1600:
			addr = (caddr_t)0xFD740000;
d332 8
a339 2
		case 0xFFFFD200:
			addr = (caddr_t)0xFD780000;
d342 2
a343 1
			panic("le: invalid address");
d345 3
d349 11
a359 2
		if (sc->sc_mem == NULL)
			panic("le: no more memory in external I/O map");
a364 1
		sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);
d396 2
a397 1
		panic("le: unknown bus type.");
@


1.23
log
@Do not define LEDEBUG by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.22 2003/09/29 09:08:17 miod Exp $ */
d218 1
d222 1
@


1.22
log
@avaliable -> available
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.21 2003/06/02 23:27:50 millert Exp $ */
a55 1
#define LEDEBUG 1
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.20 2002/10/12 01:09:43 krw Exp $ */
d314 1
a314 1
		 * get the first avaliable etherbuf.  MVME376 uses its own dual-ported 
@


1.20
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.19 2002/04/29 06:26:50 pvalchev Exp $ */
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@wierd -> weird
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.18 2002/04/27 23:21:05 miod Exp $ */
d342 1
a342 1
			panic("\nle: no more memory in external I/O map\n");
d380 1
a380 1
		panic("\nle: unknown bus type.\n");
@


1.18
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.17 2002/03/14 01:26:37 millert Exp $ */
d281 1
a281 1
	/* check physical addr for bogus MVME162 addr @@0xffffd200. wierd XXX - smurph */
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.16 2001/12/21 20:45:51 miod Exp $ */
d83 12
a94 4
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
hide void vlewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t vlerdcsr(struct am7990_softc *, u_int16_t);
d97 5
a101 4
nvram_cmd(sc, cmd, addr )
struct am7990_softc *sc;
u_char cmd;
u_short addr;
a103 2
	u_char rcmd = 0;
	u_char rcmd2= 0;
a105 3
	rcmd = addr;
	rcmd = rcmd << 3;
	rcmd |= cmd;
d115 2
a116 2
struct am7990_softc *sc;
u_char nvram_addr;
a120 1
	int i;
d142 1
a142 1
struct am7990_softc *sc;
d154 1
a154 1
hide void
d156 2
a157 2
struct am7990_softc *sc;
u_int16_t port, val;
d165 1
a165 1
hide void
d167 2
a168 2
struct am7990_softc *sc;
u_int16_t port, val;
d176 1
a176 1
hide u_int16_t
d178 2
a179 2
struct am7990_softc *sc;
u_int16_t port;
d189 1
a189 1
hide u_int16_t
d191 2
a192 2
struct am7990_softc *sc;
u_int16_t port;
d205 1
a205 1
struct am7990_softc *sc;
d219 1
a219 1
struct am7990_softc *sc;
d232 1
a232 1
register void *sc;
d243 3
a245 3
struct am7990_softc *sc;
void *from;
int boff, len;
d261 2
a262 2
struct am7990_softc *sc;
int boff, len;
d277 2
a278 2
struct device *parent;
void *vcf, *args;
a279 1
	struct cfdata *cf = vcf;
d285 1
a285 1
	return (!badvaddr(ca->ca_vaddr, 2));
d295 3
a297 3
struct device *parent;
struct device *self;
void *aux;
a301 1
	register int a;
d348 1
a348 1
		sc->sc_addr = kvtop(sc->sc_mem);
d365 1
a365 1
		sc->sc_addr = kvtop(sc->sc_mem);
a410 3



@


1.16
log
@Let this compile for kernels where no pcc device is configured (i.e. kernels
with no 147 support).
Problem reported by "Bob" <bharbour@@emr.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.15 2001/12/19 04:07:09 deraadt Exp $ */
d83 4
a86 4
hide void lewrcsr __P((struct am7990_softc *, u_int16_t, u_int16_t));
hide u_int16_t lerdcsr __P((struct am7990_softc *, u_int16_t));
hide void vlewrcsr __P((struct am7990_softc *, u_int16_t, u_int16_t));
hide u_int16_t vlerdcsr __P((struct am7990_softc *, u_int16_t));
@


1.15
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.14 2000/01/29 04:11:25 smurph Exp $ */
d66 4
d71 1
a71 1
#include <mvme68k/dev/vme.h>
d399 1
d407 1
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.16 2001/12/21 20:45:51 miod Exp $ */
d66 1
a68 5
#include "pcc.h"
#if NPCC > 0
#include <mvme68k/dev/pccreg.h>
#endif

a394 1
#if NPCC > 0
a401 1
#endif
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.15.2.1 2002/01/31 22:55:15 niklas Exp $ */
d83 4
a86 12
void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
void vlewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t vlerdcsr(struct am7990_softc *, u_int16_t);
void nvram_cmd(struct am7990_softc *, u_char, u_short);
u_int16_t nvram_read(struct am7990_softc *, u_char);
void vleetheraddr(struct am7990_softc *);
void vleinit(struct am7990_softc *);
void vlereset(struct am7990_softc *);
int vle_intr(void *);
void vle_copytobuf_contig(struct am7990_softc *, void *, int, int);
void vle_zerobuf_contig(struct am7990_softc *, int, int);
d89 4
a92 5
void
nvram_cmd(sc, cmd, addr)
	struct am7990_softc *sc;
	u_char cmd;
	u_short addr;
d95 2
d99 3
d111 2
a112 2
	struct am7990_softc *sc;
	u_char nvram_addr;
d117 1
d139 1
a139 1
	struct am7990_softc *sc;
d151 1
a151 1
void
d153 2
a154 2
	struct am7990_softc *sc;
	u_int16_t port, val;
d162 1
a162 1
void
d164 2
a165 2
	struct am7990_softc *sc;
	u_int16_t port, val;
d173 1
a173 1
u_int16_t
d175 2
a176 2
	struct am7990_softc *sc;
	u_int16_t port;
d186 1
a186 1
u_int16_t
d188 2
a189 2
	struct am7990_softc *sc;
	u_int16_t port;
d202 1
a202 1
	struct am7990_softc *sc;
d216 1
a216 1
	struct am7990_softc *sc;
d229 1
a229 1
	void *sc;
d240 3
a242 3
	struct am7990_softc *sc;
	void *from;
	int boff, len;
d258 2
a259 2
	struct am7990_softc *sc;
	int boff, len;
d274 2
a275 2
	struct device *parent;
	void *vcf, *args;
d277 1
d279 1
a279 1
	/* check physical addr for bogus MVME162 addr @@0xffffd200. weird XXX - smurph */
d283 1
a283 1
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 2));
d293 3
a295 3
	struct device *parent;
	struct device *self;
	void *aux;
d300 1
d347 1
a347 1
		sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);
d364 1
a364 1
		sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);
d410 3
@


1.15.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.15.2.2 2002/06/11 03:36:49 art Exp $ */
d342 1
a342 1
			panic("le: no more memory in external I/O map");
d380 1
a380 1
		panic("le: unknown bus type.");
@


1.14
log
@Updated flash and ipic device compatability with MC rev 0x01.  zs mods to work with LX style 162 boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.13 2000/01/24 05:20:53 smurph Exp $ */
d311 20
a330 62
		case BUS_VMES:
			/* 
			 * get the first avaliable etherbuf.  MVME376 uses its own dual-ported 
			 * RAM for etherbuf.  It is set by dip switches on board.  We support 
			 * the four Motorola address locations, however, the board can be set up 
			 * at any other address. We must map this space into the extio map. 
			 * XXX-smurph.
			 */
			switch ((int)ca->ca_paddr) {
				case 0xFFFF1200:
					addr = (caddr_t)0xFD6C0000;
					break;
				case 0xFFFF1400:
					addr = (caddr_t)0xFD700000;
					break;
				case 0xFFFF1600:
					addr = (caddr_t)0xFD740000;
					break;
				case 0xFFFFD200:
					addr = (caddr_t)0xFD780000;
					break;
				default:
					panic("le: invalid address");
			}
			sc->sc_mem = (void *)mapiodev(addr, VLEMEMSIZE);
			if (sc->sc_mem == NULL)
				panic("\nle: no more memory in external I/O map\n");
			lesc->sc_r1 = (void *)ca->ca_vaddr;
			lesc->sc_ipl = ca->ca_ipl;
			lesc->sc_vec = ca->ca_vec;
			sc->sc_memsize = VLEMEMSIZE;
			sc->sc_conf3 = LE_C3_BSWP;
			sc->sc_addr = kvtop(sc->sc_mem);
			sc->sc_hwreset = vlereset;
			sc->sc_rdcsr = vlerdcsr;
			sc->sc_wrcsr = vlewrcsr;
			sc->sc_hwinit = vleinit;
			sc->sc_copytodesc = vle_copytobuf_contig;
			sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
			sc->sc_copytobuf = vle_copytobuf_contig;
			sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
			sc->sc_zerobuf = am7990_zerobuf_contig;
			/* get ether address */
			vleetheraddr(sc);
			break;      
		case BUS_PCC:
			sc->sc_mem = etherbuf;
			lesc->sc_r1 = (void *)ca->ca_vaddr;
			sc->sc_conf3 = LE_C3_BSWP /*| LE_C3_ACON | LE_C3_BCON*/;
			sc->sc_addr = kvtop(sc->sc_mem);
			sc->sc_memsize = LEMEMSIZE;
			sc->sc_rdcsr = lerdcsr;
			sc->sc_wrcsr = lewrcsr;
			sc->sc_hwreset = NULL;
			sc->sc_hwinit = NULL;
			sc->sc_copytodesc = am7990_copytobuf_contig;
			sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
			sc->sc_copytobuf = am7990_copytobuf_contig;
			sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
			sc->sc_zerobuf = am7990_zerobuf_contig;
			/* get ether address */
			myetheraddr(sc->sc_arpcom.ac_enaddr);
d333 43
a375 1
			panic("\nle: unknown bus type.\n");
d389 13
a401 13
		case BUS_VMES:
			lesc->sc_ih.ih_fn = vle_intr;
			lesc->sc_ih.ih_arg = sc;
			lesc->sc_ih.ih_ipl = pri;
			vmeintr_establish(ca->ca_vec + 0, &lesc->sc_ih);
			break;
		case BUS_PCC:
			lesc->sc_ih.ih_fn = am7990_intr;
			lesc->sc_ih.ih_arg = sc;
			lesc->sc_ih.ih_ipl = pri;
			pccintr_establish(PCCV_LE, &lesc->sc_ih);
			((struct pccreg *)ca->ca_master)->pcc_leirq = pri | PCC_IRQ_IEN;
			break;
@


1.14.2.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d66 1
a68 5
#include "pcc.h"
#if NPCC > 0
#include <mvme68k/dev/pccreg.h>
#endif

d311 62
a372 20
	case BUS_VMES:
		/* 
		 * get the first avaliable etherbuf.  MVME376 uses its own dual-ported 
		 * RAM for etherbuf.  It is set by dip switches on board.  We support 
		 * the four Motorola address locations, however, the board can be set up 
		 * at any other address. We must map this space into the extio map. 
		 * XXX-smurph.
		 */
		switch ((int)ca->ca_paddr) {
		case 0xFFFF1200:
			addr = (caddr_t)0xFD6C0000;
			break;
		case 0xFFFF1400:
			addr = (caddr_t)0xFD700000;
			break;
		case 0xFFFF1600:
			addr = (caddr_t)0xFD740000;
			break;
		case 0xFFFFD200:
			addr = (caddr_t)0xFD780000;
d375 1
a375 43
			panic("le: invalid address");
		}
		sc->sc_mem = (void *)mapiodev(addr, VLEMEMSIZE);
		if (sc->sc_mem == NULL)
			panic("\nle: no more memory in external I/O map\n");
		lesc->sc_r1 = (void *)ca->ca_vaddr;
		lesc->sc_ipl = ca->ca_ipl;
		lesc->sc_vec = ca->ca_vec;
		sc->sc_memsize = VLEMEMSIZE;
		sc->sc_conf3 = LE_C3_BSWP;
		sc->sc_addr = kvtop(sc->sc_mem);
		sc->sc_hwreset = vlereset;
		sc->sc_rdcsr = vlerdcsr;
		sc->sc_wrcsr = vlewrcsr;
		sc->sc_hwinit = vleinit;
		sc->sc_copytodesc = vle_copytobuf_contig;
		sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
		sc->sc_copytobuf = vle_copytobuf_contig;
		sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
		sc->sc_zerobuf = am7990_zerobuf_contig;
		/* get ether address */
		vleetheraddr(sc);
		break;      
	case BUS_PCC:
		sc->sc_mem = etherbuf;
		lesc->sc_r1 = (void *)ca->ca_vaddr;
		sc->sc_conf3 = LE_C3_BSWP /*| LE_C3_ACON | LE_C3_BCON*/;
		sc->sc_addr = kvtop(sc->sc_mem);
		sc->sc_memsize = LEMEMSIZE;
		sc->sc_rdcsr = lerdcsr;
		sc->sc_wrcsr = lewrcsr;
		sc->sc_hwreset = NULL;
		sc->sc_hwinit = NULL;
		sc->sc_copytodesc = am7990_copytobuf_contig;
		sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
		sc->sc_copytobuf = am7990_copytobuf_contig;
		sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
		sc->sc_zerobuf = am7990_zerobuf_contig;
		/* get ether address */
		myetheraddr(sc->sc_arpcom.ac_enaddr);
		break;
	default:
		panic("\nle: unknown bus type.\n");
d389 13
a401 15
	case BUS_VMES:
		lesc->sc_ih.ih_fn = vle_intr;
		lesc->sc_ih.ih_arg = sc;
		lesc->sc_ih.ih_ipl = pri;
		vmeintr_establish(ca->ca_vec + 0, &lesc->sc_ih);
		break;
#if NPCC > 0
	case BUS_PCC:
		lesc->sc_ih.ih_fn = am7990_intr;
		lesc->sc_ih.ih_arg = sc;
		lesc->sc_ih.ih_ipl = pri;
		pccintr_establish(PCCV_LE, &lesc->sc_ih);
		((struct pccreg *)ca->ca_master)->pcc_leirq = pri | PCC_IRQ_IEN;
		break;
#endif
@


1.14.2.2
log
@Merge in -current from about a week ago
@
text
@d83 4
a86 4
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
hide void vlewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t vlerdcsr(struct am7990_softc *, u_int16_t);
@


1.14.2.3
log
@Sync the SMP branch with 3.3
@
text
@d83 4
a86 12
void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
void vlewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t vlerdcsr(struct am7990_softc *, u_int16_t);
void nvram_cmd(struct am7990_softc *, u_char, u_short);
u_int16_t nvram_read(struct am7990_softc *, u_char);
void vleetheraddr(struct am7990_softc *);
void vleinit(struct am7990_softc *);
void vlereset(struct am7990_softc *);
int vle_intr(void *);
void vle_copytobuf_contig(struct am7990_softc *, void *, int, int);
void vle_zerobuf_contig(struct am7990_softc *, int, int);
d89 4
a92 5
void
nvram_cmd(sc, cmd, addr)
	struct am7990_softc *sc;
	u_char cmd;
	u_short addr;
d95 2
d99 3
d111 2
a112 2
	struct am7990_softc *sc;
	u_char nvram_addr;
d117 1
d139 1
a139 1
	struct am7990_softc *sc;
d151 1
a151 1
void
d153 2
a154 2
	struct am7990_softc *sc;
	u_int16_t port, val;
d162 1
a162 1
void
d164 2
a165 2
	struct am7990_softc *sc;
	u_int16_t port, val;
d173 1
a173 1
u_int16_t
d175 2
a176 2
	struct am7990_softc *sc;
	u_int16_t port;
d186 1
a186 1
u_int16_t
d188 2
a189 2
	struct am7990_softc *sc;
	u_int16_t port;
d202 1
a202 1
	struct am7990_softc *sc;
d216 1
a216 1
	struct am7990_softc *sc;
d229 1
a229 1
	void *sc;
d240 3
a242 3
	struct am7990_softc *sc;
	void *from;
	int boff, len;
d258 2
a259 2
	struct am7990_softc *sc;
	int boff, len;
d274 2
a275 2
	struct device *parent;
	void *vcf, *args;
d277 1
d279 1
a279 1
	/* check physical addr for bogus MVME162 addr @@0xffffd200. weird XXX - smurph */
d283 1
a283 1
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 2));
d293 3
a295 3
	struct device *parent;
	struct device *self;
	void *aux;
d300 1
d341 1
a341 1
			panic("le: no more memory in external I/O map");
d347 1
a347 1
		sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);
d364 1
a364 1
		sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);
d379 1
a379 1
		panic("le: unknown bus type.");
d410 3
@


1.14.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.14.2.3 2003/03/27 23:32:16 niklas Exp $ */
d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d56 1
a218 1
#ifdef LEDEBUG
a221 1
#endif
a300 1
	int card;
d314 5
a318 5
		 * get the first available etherbuf.  MVME376 uses its own
		 * dual-ported RAM for etherbuf.  It is set by dip switches
		 * on board.  We support the six Motorola address locations,
		 * however, the board can be set up at any other address.
		 * XXX These physical addresses should be mapped in extio!!!
d321 2
a322 8
		case 0xffff1200:
			card = 0;
			break;
		case 0xffff1400:
			card = 1;
			break;
		case 0xffff1600:
			card = 2;
d324 2
a325 2
		case 0xffff5400:
			card = 3;
d327 2
a328 2
		case 0xffff5600:
			card = 4;
d330 2
a331 2
		case 0xffffa400:
			card = 5;
d334 1
a334 2
			printf(": unsupported address\n");
			return;
a335 3

		addr = (caddr_t)(VLEMEMBASE - (card * VLEMEMSIZE));

d337 2
a338 11
		if (sc->sc_mem == NULL) {
			printf("\n%s: no more memory in external I/O map\n",
			    sc->sc_dev.dv_xname);
			return;
		}
		sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);
		if (sc->sc_addr == 0L) {
			printf("\n%s: kvtop() failed!\n", sc->sc_dev.dv_xname);
			return;
		}

d344 1
d376 1
a376 2
		printf(": unknown bus type\n");
		return;
@


1.14.2.6
log
@Merge with the trunk
@
text
@d354 5
a358 1
		sc->sc_addr = (paddr_t)addr & 0x00ffffff;
@


1.13
log
@Fixed bug in disksubr.c relating to disklabels.  Added MVME376 support to le.  Made installboot insert M68K for volume ID, not M88K.  Correctly documented installboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 1998/09/16 22:41:18 jason Exp $ */
d70 2
a71 2
void	leattach(struct device *, struct device *, void *);
int	lematch(struct device *, void *, void *);
d90 3
a92 3
   int i;
   u_char rcmd = 0;
   u_char rcmd2= 0;
d94 8
a101 8
   
   rcmd = addr;
   rcmd = rcmd << 3;
   rcmd |= cmd;
   for(i=0;i<8;i++){ 
      reg1->ler1_ear=((cmd|(addr<<1))>>i); 
      CDELAY; 
   } 
d110 4
a113 4
   u_short val = 0, mask = 0x04000;
   u_int16_t wbit;
   /* these used by macros DO NOT CHANGE!*/
   int i;
d115 16
a130 16
   ((struct le_softc *)sc)->csr = 0x4f;
   ENABLE_NVRAM;
   nvram_cmd(sc, NVRAM_RCL, 0);
   DISABLE_NVRAM;
   CDELAY;
   ENABLE_NVRAM;
   nvram_cmd(sc, NVRAM_READ, nvram_addr);
   for (wbit=0; wbit<15; wbit++) {
      (reg1->ler1_ear & 0x01) ? (val = (val | mask)) : (val = (val & (~mask)));
      mask = mask>>1;
      CDELAY;
   }
   (reg1->ler1_ear & 0x01) ? (val = (val | 0x8000)) : (val = (val & 0x7FFF));
   CDELAY;
   DISABLE_NVRAM;
   return (val);
d137 8
a144 8
   u_char * cp = sc->sc_arpcom.ac_enaddr;
   u_int16_t ival[3];
   u_char i;
   
   for (i=0; i<3; i++) {
      ival[i] = nvram_read(sc, i);
   }
   memcpy(cp, &ival[0], 6);
d149 2
a150 2
	struct am7990_softc *sc;
	u_int16_t port, val;
d160 2
a161 2
	struct am7990_softc *sc;
	u_int16_t port, val;
d171 2
a172 2
	struct am7990_softc *sc;
	u_int16_t port;
d184 2
a185 2
	struct am7990_softc *sc;
	u_int16_t port;
d198 1
a198 1
	struct am7990_softc *sc;
d201 5
a205 5
   u_char vec = ((struct le_softc *)sc)->sc_vec;
   u_char ipl = ((struct le_softc *)sc)->sc_ipl;
   ((struct le_softc *)sc)->csr = 0x4f;
   WRITE_CSR_AND( ~ipl );
   SET_VEC(vec);
d212 1
a212 1
	struct am7990_softc *sc;
d225 1
a225 1
	register void *sc;
d228 4
a231 4
   int rc;
   rc = am7990_intr(sc);
   ENABLE_INTR;
   return (rc);
d236 3
a238 3
	struct am7990_softc *sc;
	void *from;
	int boff, len;
d242 4
a245 4
   /* 
    * Do the cache stuff 
    */
   dma_cachectl(buf + boff, len);
d254 2
a255 2
	struct am7990_softc *sc;
	int boff, len;
d258 4
a261 4
   /* 
    * Do the cache stuff 
    */
   dma_cachectl(buf + boff, len);
d270 2
a271 2
	struct device *parent;
	void *vcf, *args;
d275 3
d289 3
a291 3
	struct device *parent;
	struct device *self;
	void *aux;
d303 1
a303 1
   
d311 65
a375 65
   case BUS_VMES:
      /* 
		 * get the first avaliable etherbuf.  MVME376 uses its own dual-ported 
		 * RAM for etherbuf.  It is set by dip switches on board.  We support 
		 * the four Motorola address locations, however, the board can be set up 
		 * at any other address. We must map this space into the extio map. 
		 * XXX-smurph.
		 */
      switch ((int)ca->ca_paddr) {
      case 0xFFFF1200:
         addr = (caddr_t)0xFD6C0000;
         break;
      case 0xFFFF1400:
         addr = (caddr_t)0xFD700000;
         break;
      case 0xFFFF1600:
         addr = (caddr_t)0xFD740000;
         break;
		case 0xFFFFD200:
         addr = (caddr_t)0xFD780000;
         break;
      default:
         panic("le: invalid address");
      }
      sc->sc_mem = (void *)mapiodev(addr, VLEMEMSIZE);
      if (sc->sc_mem == NULL) 
			panic("\nle: no more memory in external I/O map\n");
   	lesc->sc_r1 = (void *)ca->ca_vaddr;
      lesc->sc_ipl = ca->ca_ipl;
      lesc->sc_vec = ca->ca_vec;
   	sc->sc_memsize = VLEMEMSIZE;
   	sc->sc_conf3 = LE_C3_BSWP;
   	sc->sc_addr = kvtop(sc->sc_mem);
      sc->sc_hwreset = vlereset;
      sc->sc_rdcsr = vlerdcsr;
      sc->sc_wrcsr = vlewrcsr;
      sc->sc_hwinit = vleinit;
		sc->sc_copytodesc = vle_copytobuf_contig;
		sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
		sc->sc_copytobuf = vle_copytobuf_contig;
		sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
		sc->sc_zerobuf = am7990_zerobuf_contig;
		/* get ether address */
   	vleetheraddr(sc);
		break;		
   case BUS_PCC:
      sc->sc_mem = etherbuf;
   	lesc->sc_r1 = (void *)ca->ca_vaddr;
   	sc->sc_conf3 = LE_C3_BSWP /*| LE_C3_ACON | LE_C3_BCON*/;
   	sc->sc_addr = kvtop(sc->sc_mem);
   	sc->sc_memsize = LEMEMSIZE;
      sc->sc_rdcsr = lerdcsr;
      sc->sc_wrcsr = lewrcsr;
      sc->sc_hwreset = NULL;
      sc->sc_hwinit = NULL;
		sc->sc_copytodesc = am7990_copytobuf_contig;
		sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
		sc->sc_copytobuf = am7990_copytobuf_contig;
		sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
		sc->sc_zerobuf = am7990_zerobuf_contig;
      /* get ether address */
      myetheraddr(sc->sc_arpcom.ac_enaddr);
		break;
	default:
		panic("\nle: unknown bus type.\n");
d389 13
a401 13
   case BUS_VMES:
		lesc->sc_ih.ih_fn = vle_intr;
		lesc->sc_ih.ih_arg = sc;
		lesc->sc_ih.ih_ipl = pri;
		vmeintr_establish(ca->ca_vec + 0, &lesc->sc_ih);
		break;
	case BUS_PCC:
		lesc->sc_ih.ih_fn = am7990_intr;
		lesc->sc_ih.ih_arg = sc;
		lesc->sc_ih.ih_ipl = pri;
		pccintr_establish(PCCV_LE, &lesc->sc_ih);
		((struct pccreg *)ca->ca_master)->pcc_leirq = pri | PCC_IRQ_IEN;
		break;
d405 1
a405 1
   
@


1.12
log
@o if_media'fied am7990
o if_media'fied sun4m le.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.11 1997/08/08 08:31:50 downsj Exp $ */
d60 1
d67 1
d77 2
d81 65
d152 12
a163 1
	register struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
d174 14
a187 1
	register struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
d195 73
d296 1
d300 2
d307 67
a373 8
	sc->sc_mem = etherbuf;
	lesc->sc_r1 = (struct lereg1 *)ca->ca_vaddr;
	sc->sc_conf3 = LE_C3_BSWP /*| LE_C3_ACON | LE_C3_BCON*/;
	sc->sc_addr = kvtop(sc->sc_mem);
	sc->sc_memsize = LEMEMSIZE;

	myetheraddr(sc->sc_arpcom.ac_enaddr);

d377 4
a380 10
	sc->sc_copytodesc = am7990_copytobuf_contig;
	sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
	sc->sc_copytobuf = am7990_copytobuf_contig;
	sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
	sc->sc_zerobuf = am7990_zerobuf_contig;

	sc->sc_rdcsr = lerdcsr;
	sc->sc_wrcsr = lewrcsr;
	sc->sc_hwreset = NULL;
	sc->sc_hwinit = NULL;
d385 15
a399 5
	lesc->sc_ih.ih_fn = am7990_intr;
	lesc->sc_ih.ih_arg = sc;
	lesc->sc_ih.ih_ipl = pri;
	pccintr_establish(PCCV_LE, &lesc->sc_ih);
	((struct pccreg *)ca->ca_master)->pcc_leirq = pri | PCC_IRQ_IEN;
d401 3
@


1.11
log
@Initialize hwreset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.10 1996/08/20 05:17:08 deraadt Exp $ */
d54 2
@


1.10
log
@init sc_mem; cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.9 1996/06/11 10:08:26 deraadt Exp $ */
d155 1
@


1.9
log
@call am7990_config()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.7 1996/05/10 12:42:24 deraadt Exp $ */
a74 1
hide void lehwinit __P((struct am7990_softc *));
a99 6
hide void
lehwinit(sc)
	struct am7990_softc *sc;
{
}

a131 2
	printf(" pri %d", pri);

d136 1
a136 6
	/* connect the interrupt */
	lesc->sc_ih.ih_fn = am7990_intr;
	lesc->sc_ih.ih_arg = sc;
	lesc->sc_ih.ih_ipl = pri;
	pccintr_establish(PCCV_LE, &lesc->sc_ih);

d139 2
a140 2
	sc->sc_addr = (u_long)etherbuf;
	sc->sc_memsize = MEMSIZE;
d155 1
a155 1
	sc->sc_hwinit = lehwinit;
d159 5
@


1.8
log
@update for new generic boot
@
text
@d171 2
@


1.7
log
@split le driver, if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d140 4
@


1.6
log
@fix russian typo
@
text
@a39 3
/*
 * AMD 7990 LANCE
 */
a40 1
#include <sys/device.h>
a41 1
#include <sys/kernel.h>
d43 1
a43 1
#include <sys/buf.h>
d45 1
a45 2
#include <sys/syslog.h>
#include <sys/ioctl.h>
a46 3
#include <sys/errno.h>

#include <vm/vm.h>
a48 7
#include <net/netisr.h>
#include <net/route.h>
#if NBPFILTER > 0
#include <sys/select.h>
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif
a51 3
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
d55 1
d57 3
a59 2
#include <machine/autoconf.h>
#include <machine/pmap.h>
d62 1
a64 57
/* DVMA address to LANCE address -- the Sbus/MMU will resupply the 0xff */
#define LANCE_ADDR(x) ((int)x)

int	ledebug = 0;		/* console error messages */

#ifdef PACKETSTATS
long	lexpacketsizes[LEMTU+1];
long	lerpacketsizes[LEMTU+1];
#endif

/* Per interface statistics */
/* XXX this should go in something like if_levar.h */
struct	lestats {
	long	lexints;	/* transmitter interrupts */
	long	lerints;	/* receiver interrupts */
	long	lerbufs;	/* total buffers received during interrupts */
	long	lerhits;	/* times current rbuf was full */
	long	lerscans;	/* rbufs scanned before finding first full */
};

/*
 * Ethernet software status per interface.
 *
 * Each interface is referenced by a network interface structure,
 * le_if, which the routing code uses to locate the interface.
 * This structure contains the output queue for the interface, its address, ...
 */
struct le_softc {
	struct	device sc_dev;		/* base device */
	struct	evcnt sc_intrcnt;	/* # of interrupts, per le */
	struct	evcnt sc_errcnt;	/* # of errors, per le */
	struct	intrhand sc_ih;

	struct	arpcom sc_ac;		/* common Ethernet structures */
#define	sc_if	sc_ac.ac_if		/* network-visible interface */
#define	sc_addr	sc_ac.ac_enaddr		/* hardware Ethernet address */
	struct	lereg1 *sc_r1;		/* LANCE registers */
	struct	lereg2 *sc_r2;		/* dual-port RAM */
	int	sc_rmd;			/* predicted next rmd to process */
	int	sc_runt;
	int	sc_jab;
	int	sc_merr;
	int	sc_babl;
	int	sc_cerr;
	int	sc_miss;
	int	sc_xint;
	int	sc_xown;
	int	sc_uflo;
	int	sc_rxlen;
	int	sc_rxoff;
	int	sc_txoff;
	int	sc_busy;
	short	sc_iflags;
	struct	lestats sc_lestats;	/* per interface statistics */
};


d69 1
a69 1
struct	cfattach le_ca = {
d73 22
a94 3
struct	cfdriver le_cd = {
	NULL, "le", DV_IFNET, 0
};
d96 4
a99 16
/* Forwards */
void	leattach(struct device *, struct device *, void *);
void	lesetladrf(struct le_softc *);
void	lereset(struct device *);
int	leinit(int);
void	lestart(struct ifnet *);
int	leintr(void *);
void	lexint(struct le_softc *);
void	lerint(struct le_softc *);
void	leread(struct le_softc *, char *, int);
int	leput(char *, struct mbuf *);
struct mbuf *leget(char *, int, int, struct ifnet *);
int	leioctl(struct ifnet *, u_long, caddr_t);
void	leerror(struct le_softc *, int);
void	lererror(struct le_softc *, char *);
void	lexerror(struct le_softc *);
d101 5
a105 1
extern void *etherbuf;
d124 1
a124 1
leattach(parent, self, args)
d127 1
a127 1
	void *args;
d129 3
a131 4
	register struct le_softc *sc = (struct le_softc *)self;
	register struct lereg2 *ler2;
	struct ifnet *ifp = &sc->sc_if;
	struct confargs *ca = args;
d134 1
d139 2
d142 24
a165 53
	sc->sc_ih.ih_fn = leintr;
	sc->sc_ih.ih_arg = sc;
	sc->sc_ih.ih_ipl = pri;
	pccintr_establish(PCCV_LE, &sc->sc_ih);

	sc->sc_r1 = (struct lereg1 *)ca->ca_vaddr;

	ler2 = sc->sc_r2 = (struct lereg2 *) etherbuf;

	myetheraddr(sc->sc_addr);
	printf(": address %s\n", ether_sprintf(sc->sc_addr));

	/*
	 * Setup for transmit/receive
	 *
	 * According to Van, some versions of the Lance only use this
	 * address to receive packets; it doesn't put them in
	 * output packets. We'll want to make sure that lestart()
	 * installs the address.
	 */
	ler2->ler2_padr[0] = sc->sc_addr[1];
	ler2->ler2_padr[1] = sc->sc_addr[0];
	ler2->ler2_padr[2] = sc->sc_addr[3];
	ler2->ler2_padr[3] = sc->sc_addr[2];
	ler2->ler2_padr[4] = sc->sc_addr[5];
	ler2->ler2_padr[5] = sc->sc_addr[4];
	a = LANCE_ADDR(&ler2->ler2_rmd);
	ler2->ler2_rlen = LE_RLEN | (a >> 16);
	ler2->ler2_rdra = a;
	a = LANCE_ADDR(&ler2->ler2_tmd);
	ler2->ler2_tlen = LE_TLEN | (a >> 16);
	ler2->ler2_tdra = a;

	/*
	 * Set up event counters.
	 */
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
	evcnt_attach(&sc->sc_dev, "errs", &sc->sc_errcnt);

	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = "le";
	ifp->if_ioctl = leioctl;
	ifp->if_start = lestart;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
#ifdef IFF_NOTRAILERS
	/* XXX still compile when the blasted things are gone... */
	ifp->if_flags |= IFF_NOTRAILERS;
#endif
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
	if_attach(ifp);
	ether_ifattach(ifp);
a167 691
}

/*
 * Setup the logical address filter
 */
void
lesetladrf(sc)
	register struct le_softc *sc;
{
	register struct lereg2 *ler2 = sc->sc_r2;
	register struct ifnet *ifp = &sc->sc_if;
	register struct ether_multi *enm;
	register u_char *cp, c;
	register u_long crc;
	register int i, len;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast
	 * addresses through a crc generator, and then using the high
	 * order 6 bits as a index into the 64 bit logical address
	 * filter. The high order two bits select the word, while the
	 * rest of the bits select the bit within the word.
	 */

	ler2->ler2_ladrf[0] = 0;
	ler2->ler2_ladrf[1] = 0;
	ler2->ler2_ladrf[2] = 0;
	ler2->ler2_ladrf[3] = 0;
	ifp->if_flags &= ~IFF_ALLMULTI;
	ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);
	while (enm != NULL) {
		if (bcmp((caddr_t)&enm->enm_addrlo,
		    (caddr_t)&enm->enm_addrhi, sizeof(enm->enm_addrlo)) != 0) {
			/*
			 * We must listen to a range of multicast
			 * addresses. For now, just accept all
			 * multicasts, rather than trying to set only
			 * those filter bits needed to match the range.
			 * (At this time, the only use of address
			 * ranges is for IP multicast routing, for
			 * which the range is big enough to require all
			 * bits set.)
			 */
			ler2->ler2_ladrf[0] = 0xffff;
			ler2->ler2_ladrf[1] = 0xffff;
			ler2->ler2_ladrf[2] = 0xffff;
			ler2->ler2_ladrf[3] = 0xffff;
			ifp->if_flags |= IFF_ALLMULTI;
			return;
		}

		/*
		 * One would think, given the AM7990 document's polynomial
		 * of 0x04c11db6, that this should be 0x6db88320 (the bit
		 * reversal of the AMD value), but that is not right.  See
		 * the BASIC listing: bit 0 (our bit 31) must then be set.
		 */
		cp = (unsigned char *)&enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = 6; --len >= 0;) {
			c = *cp++;
			for (i = 0; i < 8; i++) {
				if ((c & 0x01) ^ (crc & 0x01)) {
					crc >>= 1;
					crc = crc ^ 0xedb88320;
				} else
					crc >>= 1;
				c >>= 1;
			}
		}
		/* Just want the 6 most significant bits. */
		crc = crc >> 26;

		/* Turn on the corresponding bit in the filter. */
		ler2->ler2_ladrf[crc >> 4] |= 1 << (crc & 0xf);

		ETHER_NEXT_MULTI(step, enm);
	}
}

void
lereset(dev)
	struct device *dev;
{
	register struct le_softc *sc = (struct le_softc *)dev;
	register struct lereg1 *ler1 = sc->sc_r1;
	register struct lereg2 *ler2 = sc->sc_r2;
	register int i, a, timo, stat;

#if NBPFILTER > 0
	if (sc->sc_if.if_flags & IFF_PROMISC)
		ler2->ler2_mode = LE_MODE_NORMAL | LE_MODE_PROM;
	else
#endif
		ler2->ler2_mode = LE_MODE_NORMAL;
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_STOP;

	/* Setup the logical address filter */
	lesetladrf(sc);

	/* init receive and transmit rings */
	for (i = 0; i < LERBUF; i++) {
		a = LANCE_ADDR(&ler2->ler2_rbuf[i][0]);
		ler2->ler2_rmd[i].rmd0 = a;
		ler2->ler2_rmd[i].rmd1_hadr = a >> 16;
		ler2->ler2_rmd[i].rmd1_bits = LE_R1_OWN;
		ler2->ler2_rmd[i].rmd2 = -LEMTU | LE_XMD2_ONES;
		ler2->ler2_rmd[i].rmd3 = 0;
	}
	for (i = 0; i < LETBUF; i++) {
		a = LANCE_ADDR(&ler2->ler2_tbuf[i][0]);
		ler2->ler2_tmd[i].tmd0 = a;
		ler2->ler2_tmd[i].tmd1_hadr = a >> 16;
		ler2->ler2_tmd[i].tmd1_bits = 0;
		ler2->ler2_tmd[i].tmd2 = LE_XMD2_ONES;
		ler2->ler2_tmd[i].tmd3 = 0;
	}

bzero((void *)&ler2->ler2_rbuf[0][0], (LERBUF + LETBUF) * LEMTU);
	/* lance will stuff packet into receive buffer 0 next */
	sc->sc_rmd = 0;

	/* tell the chip where to find the initialization block */
	a = LANCE_ADDR(&ler2->ler2_mode);
	ler1->ler1_rap = LE_CSR1;
	ler1->ler1_rdp = a;
	ler1->ler1_rap = LE_CSR2;
	ler1->ler1_rdp = a >> 16;
	ler1->ler1_rap = LE_CSR3;
	ler1->ler1_rdp = LE_C3_BSWP /*| LE_C3_ACON | LE_C3_BCON*/;
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_INIT;
	timo = 100000;
	while (((stat = ler1->ler1_rdp) & (LE_C0_ERR | LE_C0_IDON)) == 0) {
		if (--timo == 0) {
			printf("%s: init timeout, stat=%b\n",
			    sc->sc_dev.dv_xname, stat, LE_C0_BITS);
			break;
		}
	}
	if (stat & LE_C0_ERR)
		printf("%s: init failed, ler1=0x%x, stat=%b\n",
		    sc->sc_dev.dv_xname, ler1, stat, LE_C0_BITS);
	else
		ler1->ler1_rdp = LE_C0_IDON;	/* clear IDON */
	ler1->ler1_rdp = LE_C0_STRT | LE_C0_INEA;
	sc->sc_if.if_flags &= ~IFF_OACTIVE;
}

/*
 * Initialization of interface
 */
int
leinit(unit)
	int unit;
{
	register struct le_softc *sc = le_cd.cd_devs[unit];
	register struct ifnet *ifp = &sc->sc_if;
	register int s;

	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		s = splnet();
		ifp->if_flags |= IFF_RUNNING;
		lereset(&sc->sc_dev);
		lestart(ifp);
		splx(s);
	}
	return (0);
}

/*
 * Start output on interface.  Get another datagram to send
 * off of the interface queue, and copy it to the interface
 * before starting the output.
 */
void
lestart(ifp)
	register struct ifnet *ifp;
{
	register struct le_softc *sc = le_cd.cd_devs[ifp->if_unit];
	register struct letmd *tmd;
	register struct mbuf *m;
	register int len;
	if ((sc->sc_if.if_flags & IFF_RUNNING) == 0) 
		return;
	IF_DEQUEUE(&sc->sc_if.if_snd, m);
	if (m == 0) 
		return;

	len = leput((char *)sc->sc_r2->ler2_tbuf[0], m);

#if NBPFILTER > 0
	/*
	 * If bpf is listening on this interface, let it
	 * see the packet before we commit it to the wire.
	 */
	if (sc->sc_if.if_bpf)
		bpf_tap(sc->sc_if.if_bpf, (char *)sc->sc_r2->ler2_tbuf[0], len);
#endif

#ifdef PACKETSTATS
	if (len <= LEMTU)
		lexpacketsizes[len]++;
#endif
	tmd = sc->sc_r2->ler2_tmd;
	tmd->tmd3 = 0;
	tmd->tmd2 = -len | LE_XMD2_ONES;
	tmd->tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;
	sc->sc_if.if_flags |= IFF_OACTIVE;
	return;
}

int
leintr(dev)
	register void *dev;
{
	register struct le_softc *sc = dev;
	register struct lereg1 *ler1 = sc->sc_r1;
	register int csr0;

	csr0 = ler1->ler1_rdp;
	if ((csr0 & LE_C0_INTR) == 0)
		return (0);
	sc->sc_intrcnt.ev_count++;

	if (csr0 & LE_C0_ERR) {
		sc->sc_errcnt.ev_count++;
		leerror(sc, csr0);
		if (csr0 & LE_C0_MERR) {
			sc->sc_merr++;
			lereset(&sc->sc_dev);
			return (1);
		}
		if (csr0 & LE_C0_BABL)
			sc->sc_babl++;
		if (csr0 & LE_C0_CERR)
			sc->sc_cerr++;
		if (csr0 & LE_C0_MISS)
			sc->sc_miss++;
		ler1->ler1_rdp = LE_C0_BABL|LE_C0_CERR|LE_C0_MISS|LE_C0_INEA;
	}
	if ((csr0 & LE_C0_RXON) == 0) {
		sc->sc_rxoff++;
		lereset(&sc->sc_dev);
		return (1);
	}
	if ((csr0 & LE_C0_TXON) == 0) {
		sc->sc_txoff++;
		lereset(&sc->sc_dev);
		return (1);
	}
	if (csr0 & LE_C0_RINT) {
		/* interrupt is cleared in lerint */
		lerint(sc);
	}
	if (csr0 & LE_C0_TINT) {
		ler1->ler1_rdp = LE_C0_TINT|LE_C0_INEA;
		lexint(sc);
	}
	return (1);
}

/*
 * Ethernet interface transmitter interrupt.
 * Start another output if more data to send.
 */
void
lexint(sc)
	register struct le_softc *sc;
{
	register struct letmd *tmd = sc->sc_r2->ler2_tmd;

	sc->sc_lestats.lexints++;
	if ((sc->sc_if.if_flags & IFF_OACTIVE) == 0) {
		sc->sc_xint++;
		return;
	}
	if (tmd->tmd1_bits & LE_T1_OWN) {
		sc->sc_xown++;
		return;
	}
	if (tmd->tmd1_bits & LE_T1_ERR) {
err:
		lexerror(sc);
		sc->sc_if.if_oerrors++;
		if (tmd->tmd3 & (LE_T3_BUFF|LE_T3_UFLO)) {
			sc->sc_uflo++;
			lereset(&sc->sc_dev);
		} else if (tmd->tmd3 & LE_T3_LCOL)
			sc->sc_if.if_collisions++;
		else if (tmd->tmd3 & LE_T3_RTRY)
			sc->sc_if.if_collisions += 16;
	}
	else if (tmd->tmd3 & LE_T3_BUFF)
		/* XXX documentation says BUFF not included in ERR */
		goto err;
	else if (tmd->tmd1_bits & LE_T1_ONE)
		sc->sc_if.if_collisions++;
	else if (tmd->tmd1_bits & LE_T1_MORE)
		/* what is the real number? */
		sc->sc_if.if_collisions += 2;
	else
		sc->sc_if.if_opackets++;
	sc->sc_if.if_flags &= ~IFF_OACTIVE;
	lestart(&sc->sc_if);
}

#define	LENEXTRMP \
	if (++bix == LERBUF) bix = 0, rmd = sc->sc_r2->ler2_rmd; else ++rmd

/*
 * Ethernet interface receiver interrupt.
 * If input error just drop packet.
 * Decapsulate packet based on type and pass to type specific
 * higher-level input routine.
 */
void
lerint(sc)
	register struct le_softc *sc;
{
	register int bix = sc->sc_rmd;
	register struct lermd *rmd = &sc->sc_r2->ler2_rmd[bix];

	sc->sc_lestats.lerints++;
	/*
	 * Out of sync with hardware, should never happen?
	 */
	if (rmd->rmd1_bits & LE_R1_OWN) {
		do {
			sc->sc_lestats.lerscans++;
			LENEXTRMP;
		} while ((rmd->rmd1_bits & LE_R1_OWN) && bix != sc->sc_rmd);
		if (bix == sc->sc_rmd)
			printf("%s: RINT with no buffer\n",
			    sc->sc_dev.dv_xname);
	} else
		sc->sc_lestats.lerhits++;

	/*
	 * Process all buffers with valid data
	 */
	while ((rmd->rmd1_bits & LE_R1_OWN) == 0) {
		int len = rmd->rmd3;

		/* Clear interrupt to avoid race condition */
		sc->sc_r1->ler1_rdp = LE_C0_RINT|LE_C0_INEA;

		if (rmd->rmd1_bits & LE_R1_ERR) {
			sc->sc_rmd = bix;
			lererror(sc, "bad packet");
			sc->sc_if.if_ierrors++;
		} else if ((rmd->rmd1_bits & (LE_R1_STP|LE_R1_ENP)) !=
		    (LE_R1_STP|LE_R1_ENP)) {
			/* XXX make a define for LE_R1_STP|LE_R1_ENP? */
			/*
			 * Find the end of the packet so we can see how long
			 * it was.  We still throw it away.
			 */
			do {
				sc->sc_r1->ler1_rdp = LE_C0_RINT|LE_C0_INEA;
				rmd->rmd3 = 0;
				rmd->rmd1_bits = LE_R1_OWN;
				LENEXTRMP;
			} while (!(rmd->rmd1_bits &
			    (LE_R1_OWN|LE_R1_ERR|LE_R1_STP|LE_R1_ENP)));
			sc->sc_rmd = bix;
			lererror(sc, "chained buffer");
			sc->sc_rxlen++;
			/*
			 * If search terminated without successful completion
			 * we reset the hardware (conservative).
			 */
			if ((rmd->rmd1_bits &
			    (LE_R1_OWN|LE_R1_ERR|LE_R1_STP|LE_R1_ENP)) !=
			    LE_R1_ENP) {
				lereset(&sc->sc_dev);
				return;
			}
		} else {
			leread(sc, (char *)sc->sc_r2->ler2_rbuf[bix], len);
#ifdef PACKETSTATS
			lerpacketsizes[len]++;
#endif
			sc->sc_lestats.lerbufs++;
		}
		rmd->rmd3 = 0;
		rmd->rmd1_bits = LE_R1_OWN;
		LENEXTRMP;
	}
	sc->sc_rmd = bix;
}

void
leread(sc, pkt, len)
	register struct le_softc *sc;
	char *pkt;
	int len;
{
	register struct ether_header *et;
	register struct ifnet *ifp = &sc->sc_if;
	struct mbuf *m;
	struct ifqueue *inq;
	int flags;

	ifp->if_ipackets++;
	et = (struct ether_header *)pkt;
	et->ether_type = ntohs((u_short)et->ether_type);
	/* adjust input length to account for header and CRC */
	len -= sizeof(struct ether_header) + 4;

	if (len <= 0) {
		if (ledebug)
			log(LOG_WARNING,
			    "%s: ierror(runt packet): from %s: len=%d\n",
			    sc->sc_dev.dv_xname,
			    ether_sprintf(et->ether_shost), len);
		sc->sc_runt++;
		ifp->if_ierrors++;
		return;
	}

	/* Setup mbuf flags we'll need later */
	flags = 0;
	if (bcmp((caddr_t)etherbroadcastaddr,
	    (caddr_t)et->ether_dhost, sizeof(etherbroadcastaddr)) == 0)
		flags |= M_BCAST;
	if (et->ether_dhost[0] & 1)
		flags |= M_MCAST;

#if NBPFILTER > 0
	/*
	 * Check if there's a bpf filter listening on this interface.
	 * If so, hand off the raw packet to enet, then discard things
	 * not destined for us (but be sure to keep broadcast/multicast).
	 */
	if (sc->sc_if.if_bpf) {
		bpf_tap(sc->sc_if.if_bpf, pkt,
		    len + sizeof(struct ether_header));
		if ((flags & (M_BCAST | M_MCAST)) == 0 &&
		    bcmp(et->ether_dhost, sc->sc_addr,
			    sizeof(et->ether_dhost)) != 0)
			return;
	}
#endif
	m = leget(pkt, len, 0, ifp);
	if (m == 0)
		return;
	ether_input(ifp, et, m);
}

/*
 * Routine to copy from mbuf chain to transmit
 * buffer in board local memory.
 *
 * ### this can be done by remapping in some cases
 */
int
leput(lebuf, m)
	register char *lebuf;
	register struct mbuf *m;
{
	register struct mbuf *mp;
	register int len, tlen = 0;

	for (mp = m; mp; mp = mp->m_next) {
		len = mp->m_len;
		if (len == 0)
			continue;
		tlen += len;
		bcopy(mtod(mp, char *), lebuf, len);
		lebuf += len;
	}
	m_freem(m);
	if (tlen < LEMINSIZE) {
		bzero(lebuf, LEMINSIZE - tlen);
		tlen = LEMINSIZE;
	}
	return (tlen);
}

/*
 * Routine to copy from board local memory into mbufs.
 */
struct mbuf *
leget(lebuf, totlen, off0, ifp)
	char *lebuf;
	int totlen, off0;
	struct ifnet *ifp;
{
	register struct mbuf *m;
	struct mbuf *top = 0, **mp = &top;
	register int off = off0, len;
	register char *cp;
	char *epkt;

	lebuf += sizeof(struct ether_header);
	cp = lebuf;
	epkt = cp + totlen;
	if (off) {
		cp += off + 2 * sizeof(u_short);
		totlen -= 2 * sizeof(u_short);
	}

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return (0);
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	m->m_len = MHLEN;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return (0);
			}
			m->m_len = MLEN;
		}
		len = min(totlen, epkt - cp);
		if (len >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				m->m_len = len = min(len, MCLBYTES);
			else
				len = m->m_len;
		} else {
			/*
			 * Place initial small packet/header at end of mbuf.
			 */
			if (len < m->m_len) {
				if (top == 0 && len + max_linkhdr <= m->m_len)
					m->m_data += max_linkhdr;
				m->m_len = len;
			} else
				len = m->m_len;
		}
		bcopy(cp, mtod(m, caddr_t), (unsigned)len);
		cp += len;
		*mp = m;
		mp = &m->m_next;
		totlen -= len;
		if (cp == epkt)
			cp = lebuf;
	}
	return (top);
}

/*
 * Process an ioctl request.
 */
int
leioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	register struct ifaddr *ifa;
	register struct le_softc *sc = le_cd.cd_devs[ifp->if_unit];
	register struct lereg1 *ler1;
	int s = splnet(), error = 0;

	if ((error = ether_ioctl(ifp, &sc->sc_ac, cmd, data)) > 0) {
		splx(s);
		return error;
	}

	switch (cmd) {

	case SIOCSIFADDR:
		ifa = (struct ifaddr *)data;
		ifp->if_flags |= IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			(void)leinit(ifp->if_unit);
			arp_ifinit(&sc->sc_ac, ifa);
			break;
#endif
		default:
			(void)leinit(ifp->if_unit);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		ler1 = sc->sc_r1;
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    ifp->if_flags & IFF_RUNNING) {
			ler1->ler1_rdp = LE_C0_STOP;
			ifp->if_flags &= ~IFF_RUNNING;
		} else if (ifp->if_flags & IFF_UP &&
		    (ifp->if_flags & IFF_RUNNING) == 0)
			(void)leinit(ifp->if_unit);
		/*
		 * If the state of the promiscuous bit changes, the interface
		 * must be reset to effect the change.
		 */
		if (((ifp->if_flags ^ sc->sc_iflags) & IFF_PROMISC) &&
		    (ifp->if_flags & IFF_RUNNING)) {
			sc->sc_iflags = ifp->if_flags;
			lereset(&sc->sc_dev);
			lestart(ifp);
		}
		break;

	case SIOCADDMULTI:
		error = ether_addmulti((struct ifreq *)data, &sc->sc_ac);
		goto update_multicast;

	case SIOCDELMULTI:
		error = ether_delmulti((struct ifreq *)data, &sc->sc_ac);
	update_multicast:
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			lereset(&sc->sc_dev);
			error = 0;
		}
		break;

	default:
		error = EINVAL;
	}
	splx(s);
	return (error);
}

void
leerror(sc, stat)
	register struct le_softc *sc;
	int stat;
{
	if (!ledebug)
		return;

	/*
	 * Not all transceivers implement heartbeat
	 * so we only log CERR once.
	 */
	if ((stat & LE_C0_CERR) && sc->sc_cerr)
		return;
	log(LOG_WARNING, "%s: error: stat=%b\n",
	    sc->sc_dev.dv_xname, stat, LE_C0_BITS);
}

void
lererror(sc, msg)
	register struct le_softc *sc;
	char *msg;
{
	register struct lermd *rmd;
	int len;

	if (!ledebug)
		return;

	rmd = &sc->sc_r2->ler2_rmd[sc->sc_rmd];
	len = rmd->rmd3;
	log(LOG_WARNING, "%s: ierror(%s): from %s: buf=%d, len=%d, rmd1=%b\n",
	    sc->sc_dev.dv_xname, msg, len > 11 ?
	    ether_sprintf((u_char *)&sc->sc_r2->ler2_rbuf[sc->sc_rmd][6]) :
	    "unknown",
	    sc->sc_rmd, len, rmd->rmd1_bits, LE_R1_BITS);
}

void
lexerror(sc)
	register struct le_softc *sc;
{
	register struct letmd *tmd;
	register int len, tmd3, tdr;

	if (!ledebug)
		return;

	tmd = sc->sc_r2->ler2_tmd;
	tmd3 = tmd->tmd3;
	tdr = tmd3 & LE_T3_TDR_MASK;
	len = -(tmd->tmd2 & ~LE_XMD2_ONES);
	log(LOG_WARNING,
    "%s: oerror: to %s: buf=%d, len=%d, tmd1=%b, tmd3=%b, tdr=%d (%d nsecs)\n",
	    sc->sc_dev.dv_xname, len > 5 ?
	    ether_sprintf((u_char *)&sc->sc_r2->ler2_tbuf[0][0]) : "unknown",
	    0, len,
	    tmd->tmd1_bits, LE_T1_BITS,
	    tmd3, LE_T3_BITS, tdr, tdr * 100);
@


1.5
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d821 1
a821 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
d823 1
a823 1
		retun error;
@


1.4
log
@cfattach/cfdriver split
@
text
@a73 9
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#ifdef APPLETALK
#include <netddp/atalk.h>
#endif

d821 5
a836 21
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)(sc->sc_addr);
			else {
				/*
				 * The manual says we can't change the address
				 * while the receiver is armed,
				 * so reset everything
				 */
				ifp->if_flags &= ~IFF_RUNNING;
				bcopy((caddr_t)ina->x_host.c_host,
				    (caddr_t)sc->sc_addr, sizeof(sc->sc_addr));
			}
			(void)leinit(ifp->if_unit);	/* does le_setaddr() */
			break;
		    }
@


1.3
log
@use splnet instead of splimp
@
text
@d1 1
a1 1
/*	$Id: if_le.c,v 1.2 1995/11/07 08:49:02 deraadt Exp $ */
d150 8
a157 2
struct	cfdriver lecd =
    { NULL, "le", lematch, leattach, DV_IFNET, sizeof(struct le_softc) };
d424 1
a424 1
	register struct le_softc *sc = lecd.cd_devs[unit];
d447 1
a447 1
	register struct le_softc *sc = lecd.cd_devs[ifp->if_unit];
d826 1
a826 1
	register struct le_softc *sc = lecd.cd_devs[ifp->if_unit];
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d423 1
a423 1
		s = splimp();
d822 1
a822 1
	int s = splimp(), error = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.1.1.1 1995/07/25 23:12:09 chuck Exp $ */
d84 1
a86 1
#include <mvme68k/dev/iio.h>
d121 1
d170 1
a170 1
void *ledatabuf; /* XXXCDC hack from pmap bootstrap */
d178 1
a178 1
	struct iioargs *ia = args;
d180 1
a180 1
	return !badbaddr((caddr_t) IIO_CFLOC_ADDR(cf));
d197 1
d199 1
a199 1
	int pri = IIO_CFLOC_LEVEL(self->dv_cfdata);
a203 2
	iio_print(self->dv_cfdata);

d205 4
a208 3
	pccintr_establish(PCCV_LE, leintr, pri, sc);

	sc->sc_r1 = (struct lereg1 *) IIO_CFLOC_ADDR(self->dv_cfdata);
d210 1
d212 1
a212 1
	ler2 = sc->sc_r2 = (struct lereg2 *) ledatabuf;
d215 1
a215 1
	printf(" ler2 0x%x address %s\n", ler2, ether_sprintf(sc->sc_addr));
a257 1
	sys_pcc->le_int = pri | PCC_IENABLE;
d259 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.20 1995/04/12 08:47:21 pk Exp $ */
a83 1
#include <machine/autoconf.h>
d86 1
a120 1
	struct	intrhand sc_ih;
d169 1
a169 1
extern void *etherbuf;
d177 1
a177 1
	struct confargs *ca = args;
d179 1
a179 1
	return (!badvaddr(ca->ca_vaddr, 2));
a195 1
	struct confargs *ca = args;
d197 1
a197 1
	int pri = ca->ca_ipl;
d202 2
d205 3
a207 4
	sc->sc_ih.ih_fn = leintr;
	sc->sc_ih.ih_arg = sc;
	sc->sc_ih.ih_ipl = pri;
	pccintr_establish(PCCV_LE, &sc->sc_ih);
a208 1
	sc->sc_r1 = (struct lereg1 *)ca->ca_vaddr;
d210 1
a210 1
	ler2 = sc->sc_r2 = (struct lereg2 *) etherbuf;
d213 1
a213 1
	printf(": address %s\n", ether_sprintf(sc->sc_addr));
d256 1
a257 1
	((struct pccreg *)ca->ca_master)->pcc_leirq = pri | PCC_IRQ_IEN;
@
