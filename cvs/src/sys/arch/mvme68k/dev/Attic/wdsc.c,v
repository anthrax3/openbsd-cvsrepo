head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.12
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.10
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.8
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.5.0.24
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.22
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.20
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.20
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.19;

1.19
date	2013.11.30.20.25.47;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.19.20.32.47;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.30.18.08.03;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.22.11.37.06;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.15.20.20.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.30.22.29.45;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.02.17.57.29;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.28.10.54.10;	author deraadt;	state Exp;
branches
	1.5.14.1
	1.5.24.1;
next	1.4;

1.4
date	96.11.23.21.46.02;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.29.17.54.13;	author chuck;	state Exp;
branches;
next	1.2;

1.2
date	96.05.06.21.54.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.28.11.24.48;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2003.03.27.23.32.16;	author niklas;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.5.14.4;

1.5.14.4
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.5.24.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: wdsc.c,v 1.19 2013/11/30 20:25:47 miod Exp $ */

/*
 * Copyright (c) 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2001 Wayne Knowles
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Wayne Knowles
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1996 Steve Woodford
 * Copyright (c) 1982, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *  @@(#)wdsc.c
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <machine/autoconf.h>

#include <mvme68k/dev/pccreg.h>
#include <mvme68k/dev/wdscreg.h>

#include <dev/ic/wd33c93reg.h>
#include <dev/ic/wd33c93var.h>

struct dma_table_entry {
	uint32_t	dc_paddr;
	uint32_t	dc_cnt;
};

struct wdsc_softc {
	struct wd33c93_softc	sc_wd33c93;
	bus_dma_tag_t		sc_dmat;
	bus_dmamap_t		sc_dmamap;
	bus_dmamap_t		sc_tablemap;
	bus_dma_segment_t	sc_tableseg;
	vaddr_t			sc_tableva;
	struct intrhand		sc_dmaih;
	struct intrhand		sc_wdscih;
	int			sc_ipl;
	int			sc_flags;
#define	WDSC_DMA_ACTIVE			0x01
#define	WDSC_DMA_MAPLOADED		0x02
	u_short			sc_dmacmd;
};

int	wdscmatch(struct device *, void *, void *);
void	wdscattach(struct device *, struct device *, void *);

const struct cfattach wdsc_ca = {
	sizeof(struct wdsc_softc), wdscmatch, wdscattach
};

struct cfdriver wdsc_cd = {
	NULL, "wdsc", DV_DULL
};

int	wdsc_dmasetup(struct wd33c93_softc *, void **, size_t *, int, size_t *);
int	wdsc_dmago(struct wd33c93_softc *);
void	wdsc_dmastop(struct wd33c93_softc *);

int	wdsc_alloc_physical(struct wdsc_softc *, bus_dmamap_t *,
	    bus_dma_segment_t *, vaddr_t *, bus_size_t, const char *);
int	wdsc_dmaintr(void *);
int	wdsc_scsiintr(void *);

struct scsi_adapter wdsc_switch = {
	wd33c93_scsi_cmd,
	scsi_minphys,
	NULL,
	NULL
};

/*
 * Match for SCSI devices on the onboard WD33C93 chip
 */
int
wdscmatch(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = (struct confargs *)aux;

	if (strcmp(ca->ca_name, wdsc_cd.cd_name) != 0)
		return 0;
	return 1;
}

/*
 * Attach the wdsc driver
 */
void
wdscattach(struct device *parent, struct device *self, void *aux)
{
	struct wdsc_softc *wsc = (struct wdsc_softc *)self;
	struct confargs *ca = (struct confargs *)aux;
	struct wd33c93_softc *sc = &wsc->sc_wd33c93;
	int tmp;

	/*
	 * Map address and data registers.
	 */

	sc->sc_regt = ca->ca_iot;
	if (bus_space_map(ca->ca_iot, ca->ca_paddr + 0, 1, 0,
	    &sc->sc_asr_regh) != 0) {
		printf(": failed to map asr register\n");
		return;
	}
	if (bus_space_map(ca->ca_iot, ca->ca_paddr + 1, 1, 0,
	    &sc->sc_data_regh) != 0) {
		printf(": failed to map data register\n");
		return;
	}

	/*
	 * Allocate DMA map for up to MAXPHYS bytes.
	 */

	wsc->sc_dmat = ca->ca_dmat;
	if (bus_dmamap_create(ca->ca_dmat, MAXPHYS, 1 + atop(MAXPHYS),
	    0, 0, BUS_DMA_WAITOK, &wsc->sc_dmamap) != 0) {
		printf(": failed to create dmamap\n");
		return;
	}

	/*
	 * Allocate table walk memory.
	 */
	if (wdsc_alloc_physical(wsc, &wsc->sc_tablemap, &wsc->sc_tableseg,
	    &wsc->sc_tableva,
	    sizeof(struct dma_table_entry) * (1 + atop(MAXPHYS)),
	    "dma table") != 0) {
		bus_dmamap_destroy(ca->ca_dmat, wsc->sc_dmamap);
		return;
	}

	sc->sc_dmasetup = wdsc_dmasetup;
	sc->sc_dmago = wdsc_dmago;
	sc->sc_dmastop = wdsc_dmastop;
	sc->sc_reset = NULL;

	/*
	 * The onboard WD33C93 of the MVME147 is usually clocked at 10MHz...
	 */
	sc->sc_clkfreq = 100;
	sc->sc_id = 7;
	sc->sc_dmamode = SBIC_CTL_DMA;

	wsc->sc_dmacmd  = 0;
	wsc->sc_ipl = ca->ca_ipl;

	sys_pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_INT;
	sys_pcc->pcc_dmairq = ca->ca_ipl | PCC_IRQ_INT;
	sys_pcc->pcc_dmacsr  = 0;

	/*
	 * Register interrupt handlers for DMA and WDSC
	 */
	wsc->sc_dmaih.ih_fn = wdsc_dmaintr;
	wsc->sc_dmaih.ih_arg = wsc;
	wsc->sc_dmaih.ih_ipl = ca->ca_ipl;
	pccintr_establish(PCCV_DMA, &wsc->sc_dmaih, self->dv_xname);

	wsc->sc_wdscih.ih_fn = wdsc_scsiintr;
	wsc->sc_wdscih.ih_arg = wsc;
	wsc->sc_wdscih.ih_ipl = ca->ca_ipl;
	pccintr_establish(PCCV_SBIC, &wsc->sc_wdscih, self->dv_xname);

	/*
	 * Attach all SCSI devices on us, watching for boot device
	 * (see device_register).
	 */
	tmp = bootpart;
	if (ca->ca_paddr != bootaddr) 
		bootpart = -1;
	wd33c93_attach(sc, &wdsc_switch);
	bootpart = tmp;		/* restore old value */

	sys_pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
}

/*
 * Prime the hardware for a DMA transfer
 */
int
wdsc_dmasetup(struct wd33c93_softc *sc, void **addr, size_t *len, int datain,
    size_t *dmasize)
{
	struct wdsc_softc *wsc = (struct wdsc_softc *)sc;
	int count;
	int rc;

	KASSERT((wsc->sc_flags & WDSC_DMA_ACTIVE) == 0);

	count = *len;
	if (count) {
		KASSERT((wsc->sc_flags & WDSC_DMA_MAPLOADED) == 0);

		if (datain)
			wsc->sc_dmacmd = DMAC_CSR_ENABLE;
		else
			wsc->sc_dmacmd = DMAC_CSR_ENABLE | DMAC_CSR_WRITE;

		rc = bus_dmamap_load(wsc->sc_dmat, wsc->sc_dmamap,
		    *addr, count, NULL, BUS_DMA_NOWAIT);
		if (rc != 0)
			panic("%s: bus_dmamap_load failed, rc=%d",
			    sc->sc_dev.dv_xname, rc);

		bus_dmamap_sync(wsc->sc_dmat, wsc->sc_dmamap, 0,
		    wsc->sc_dmamap->dm_mapsize, datain ?
		      BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);

		/*
		 * Build dma table, unless transfer fits in one
		 * contiguous chunk
		 */
		if (wsc->sc_dmamap->dm_nsegs > 1) {
			struct dma_table_entry *entry;
			bus_dma_segment_t *seg;
			int i;

			entry = (struct dma_table_entry *)wsc->sc_tableva;
			seg = wsc->sc_dmamap->dm_segs;
			for (i = wsc->sc_dmamap->dm_nsegs; i != 0; i--) {
				entry->dc_paddr = seg->ds_addr;
				entry->dc_cnt = seg->ds_len |
				    (FC_SUPERD << 24) | (1UL << 31);
				seg++;
				entry++;
			}
			(--entry)->dc_cnt &= ~(1UL << 31);

			wsc->sc_dmacmd |= DMAC_CSR_TABLE;
		}

		wsc->sc_flags |= WDSC_DMA_MAPLOADED;
	}

	return count;
}

/*
 * Trigger a DMA transfer
 */
int
wdsc_dmago(struct wd33c93_softc *sc)
{
	struct wdsc_softc *wsc = (struct wdsc_softc *)sc;

	KASSERT((wsc->sc_flags & WDSC_DMA_ACTIVE) == 0);
	KASSERT((wsc->sc_flags & WDSC_DMA_MAPLOADED));

	wsc->sc_flags |= WDSC_DMA_ACTIVE;

	sys_pcc->pcc_dmacsr = 0;
	sys_pcc->pcc_dmairq = wsc->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
	if (wsc->sc_dmamap->dm_nsegs > 1) {
		sys_pcc->pcc_tafcr = FC_SUPERD;
		sys_pcc->pcc_dmataddr = wsc->sc_tableseg.ds_addr;
	} else {
		sys_pcc->pcc_dmadaddr =
		    (unsigned long)wsc->sc_dmamap->dm_segs[0].ds_addr;
		sys_pcc->pcc_dmabcnt = (FC_SUPERD << 24) |
		    (unsigned long)wsc->sc_dmamap->dm_segs[0].ds_len;
	}
	sys_pcc->pcc_dmacsr = wsc->sc_dmacmd;

	return wsc->sc_dmamap->dm_mapsize;
}

/*
 * Stop DMA, and disable DMA interrupts
 */
void
wdsc_dmastop(struct wd33c93_softc *sc)
{
	struct wdsc_softc *wsc = (struct wdsc_softc *)sc;

	if (wsc->sc_flags & WDSC_DMA_ACTIVE) {
		sys_pcc->pcc_dmacsr = 0;
		sys_pcc->pcc_dmairq = wsc->sc_ipl | PCC_IRQ_INT;

		bus_dmamap_sync(wsc->sc_dmat, wsc->sc_dmamap, 0,
		    wsc->sc_dmamap->dm_mapsize,
		    wsc->sc_dmacmd & DMAC_CSR_WRITE ?
		      BUS_DMASYNC_POSTWRITE : BUS_DMASYNC_POSTREAD);
	}
	if (wsc->sc_flags & WDSC_DMA_MAPLOADED)
		bus_dmamap_unload(wsc->sc_dmat, wsc->sc_dmamap);
	wsc->sc_flags &= ~(WDSC_DMA_ACTIVE | WDSC_DMA_MAPLOADED);
}

/*
 * DMA completion interrupt
 */
int
wdsc_dmaintr(void *arg)
{
	struct wdsc_softc *wsc = (struct wdsc_softc *)arg;
	int rc = -1;

	/*
	 * Really a DMA interrupt?
	 */
	if ((sys_pcc->pcc_dmairq & PCC_IRQ_INT) == 0)
		return 0;

	if (sys_pcc->pcc_dmacsr & DMAC_CSR_DONE) {
		rc = 1;
		/* acknowledge interrupt... */
		sys_pcc->pcc_dmairq = wsc->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
		if (sys_pcc->pcc_dmacsr & (DMAC_CSR_TBUSERR | DMAC_CSR_DBUSERR |
					DMAC_CSR_TSIZE | DMAC_CSR_8BITS)) {
			printf("%s: DMA error, CSR=%02x\n",
			    wsc->sc_wd33c93.sc_dev.dv_xname,
			    sys_pcc->pcc_dmacsr);
		}
		sys_pcc->pcc_dmacsr = 0;
		sys_pcc->pcc_dmairq = wsc->sc_ipl | PCC_IRQ_INT;
	}

	return rc;
}

/*
 * SCSI interrupt
 */
int
wdsc_scsiintr(void *arg)
{
	struct wdsc_softc *wsc = (struct wdsc_softc *)arg;
	int rc;

	/*
	 * Really a SCSI interrupt?
	 */
	if ((sys_pcc->pcc_sbicirq & PCC_IRQ_INT) == 0)
		return 0;

	rc = wd33c93_intr(&wsc->sc_wd33c93);

	/*
	 * Acknowledge and clear the interrupt
	 */
	sys_pcc->pcc_sbicirq = wsc->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;

	return rc;
}

/*
 * Allocate contiguous physical memory.
 */
int
wdsc_alloc_physical(struct wdsc_softc *wsc, bus_dmamap_t *dmamap,
    bus_dma_segment_t *dmaseg, vaddr_t *va, bus_size_t len, const char *what)
{
	int nseg;
	int rc;

	len = round_page(len);

	rc = bus_dmamem_alloc(wsc->sc_dmat, len, 0, 0, dmaseg, 1, &nseg,
	    BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: unable to allocate %s memory: error %d\n",
		    wsc->sc_wd33c93.sc_dev.dv_xname, what, rc);
		goto fail1;
	}

	rc = bus_dmamem_map(wsc->sc_dmat, dmaseg, nseg, len,
	    (caddr_t *)va, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (rc != 0) {
		printf("%s: unable to map %s memory: error %d\n",
		    wsc->sc_wd33c93.sc_dev.dv_xname, what, rc);
		goto fail2;
	}

	rc = bus_dmamap_create(wsc->sc_dmat, len, 1, len, 0,
	    BUS_DMA_NOWAIT /* | BUS_DMA_ALLOCNOW */, dmamap);
	if (rc != 0) {
		printf("%s: unable to create %s dma map: error %d\n",
		    wsc->sc_wd33c93.sc_dev.dv_xname, what, rc);
		goto fail3;
	}

	rc = bus_dmamap_load(wsc->sc_dmat, *dmamap, (void *)*va, len, NULL,
	    BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: unable to load %s dma map: error %d\n",
		    wsc->sc_wd33c93.sc_dev.dv_xname, what, rc);
		goto fail4;
	}

	return 0;

fail4:
	bus_dmamap_destroy(wsc->sc_dmat, *dmamap);
fail3:
	bus_dmamem_unmap(wsc->sc_dmat, (caddr_t)*va, PAGE_SIZE);
fail2:
	bus_dmamem_free(wsc->sc_dmat, dmaseg, 1);
fail1:
	return rc;
}
@


1.19
log
@Spurious linefeed
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.18 2013/05/19 20:32:47 miod Exp $ */
@


1.18
log
@Switch mvme68k to MI wdsc(4) driver. Tested on MVME147.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.17 2010/06/28 18:31:01 krw Exp $ */
a211 2

	printf("\n");
@


1.17
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.16 2009/02/16 21:19:06 miod Exp $ */
d4 50
d84 1
d89 3
d94 1
a94 4
#include <mvme68k/dev/dmavar.h>
#include <mvme68k/dev/sbicreg.h>
#include <mvme68k/dev/sbicvar.h>
#include <mvme68k/dev/wdscreg.h>
d96 1
d98 1
d100 2
a101 2
void    wdscattach(struct device *, struct device *, void *);
int     wdscmatch(struct device *, struct cfdata *, void *);
d103 4
a106 6
void    wdsc_enintr(struct sbic_softc *);
int     wdsc_dmago(struct sbic_softc *, char *, int, int);
int     wdsc_dmanext(struct sbic_softc *);
void    wdsc_dmastop(struct sbic_softc *);
int     wdsc_dmaintr(void *);
int     wdsc_scsiintr(void *);
d108 15
a122 2
extern void sbicinit(struct sbic_softc *);
extern int sbicintr(struct sbic_softc *);
d124 2
a125 6
struct scsi_adapter wdsc_scsiswitch = {
	sbic_scsicmd,
	scsi_minphys,
	0,          /* no lun support */
	0,          /* no lun support */
};
d127 2
a128 2
struct cfattach wdsc_ca = {
	sizeof(struct sbic_softc), (cfmatch_t)wdscmatch, wdscattach
d135 15
a149 6
/*
 * Define 'scsi_nosync = 0x00' to enable sync SCSI mode.
 * This is untested as yet, use at your own risk...
 */
u_long      scsi_nosync  = 0xff;
int         shift_nosync = 0;
d155 1
a155 4
wdscmatch(pdp, cdp, auxp)
	struct device *pdp;
	struct cfdata *cdp;
	void *auxp;
d157 5
a161 4
	/*
	 * Match everything
	 */
	return(1);
a163 1

d168 1
a168 3
wdscattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d170 3
a172 3
	struct sbic_softc   *sc = (struct sbic_softc *)self;
	struct confargs *ca = aux;
	struct scsibus_attach_args saa;
d175 3
a177 1
	printf("\n");
d179 11
a189 5
	sc->sc_enintr  = wdsc_enintr;
	sc->sc_dmago   = wdsc_dmago;
	sc->sc_dmanext = wdsc_dmanext;
	sc->sc_dmastop = wdsc_dmastop;
	sc->sc_dmacmd  = 0;
d191 3
a193 4
	sc->sc_link.adapter_softc  = sc;
	sc->sc_link.adapter_target = 7;
	sc->sc_link.adapter        = &wdsc_scsiswitch;
	sc->sc_link.openings       = 2;
d195 6
a200 1
	sc->sc_sbicp = (sbic_regmap_p)ca->ca_vaddr;
d203 1
a203 1
	 * Everything is a valid dma address.
d205 14
a218 1
	sc->sc_dmamask = 0;
d221 1
a221 2
	 * The onboard WD33C93 of the '147 is usually clocked at 10MHz...
	 * (We use 10 times this for accuracy in later calculations)
d224 2
d227 2
a228 6
	/*
	 * Initialize the hardware
	 */
	sbicinit(sc);

	sc->sc_ipl = ca->ca_ipl;
d235 1
a235 1
	 * Fix up the interrupts
d237 4
a240 9
	sc->sc_dmaih.ih_fn = wdsc_dmaintr;
	sc->sc_dmaih.ih_arg = sc;
	sc->sc_dmaih.ih_ipl = ca->ca_ipl;
	pccintr_establish(PCCV_DMA, &sc->sc_dmaih, self->dv_xname);

	sc->sc_sbicih.ih_fn = wdsc_scsiintr;
	sc->sc_sbicih.ih_arg = sc;
	sc->sc_sbicih.ih_ipl = ca->ca_ipl;
	pccintr_establish(PCCV_SBIC, &sc->sc_sbicih, self->dv_xname);
d242 4
a245 1
	sys_pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
d248 1
a248 1
	 * Attach all scsi units on us, watching for boot device
a250 3
	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

d254 1
a254 1
	config_found(self, &saa, scsiprint);
a255 1
}
d257 1
a257 10
/*
 * Enable DMA interrupts
 */
void
wdsc_enintr(dev)
	struct sbic_softc *dev;
{
	dev->sc_flags |= SBICF_INTR;

	sys_pcc->pcc_dmairq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
d264 2
a265 4
wdsc_dmago(dev, addr, count, flags)
	struct sbic_softc *dev;
	char *addr;
	int count, flags;
d267 44
a310 7
	/*
	 * Set up the command word based on flags
	 */
	if ((flags & DMAGO_READ) == 0)
		dev->sc_dmacmd = DMAC_CSR_ENABLE | DMAC_CSR_WRITE;
	else
		dev->sc_dmacmd = DMAC_CSR_ENABLE;
d312 2
a313 2
	dev->sc_flags |= SBICF_INTR;
	dev->sc_tcnt   = dev->sc_cur->dc_count << 1;
d315 2
a316 10
	/*
	 * Prime the hardware.
	 * Note, it's probably not necessary to do this here, since dmanext
	 * is called just prior to the actual transfer.
	 */
	sys_pcc->pcc_dmacsr   = 0;
	sys_pcc->pcc_dmairq   = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
	sys_pcc->pcc_dmadaddr = (unsigned long)dev->sc_cur->dc_addr;
	sys_pcc->pcc_dmabcnt  = (unsigned long)dev->sc_tcnt | (1 << 24);
	sys_pcc->pcc_dmacsr   = dev->sc_dmacmd;
d318 1
a318 1
	return dev->sc_tcnt;
d322 1
a322 1
 * Prime the hardware for the next DMA transfer
d325 1
a325 2
wdsc_dmanext(dev)
	struct sbic_softc *dev;
d327 4
a330 8
	if (dev->sc_cur > dev->sc_last) {
		/*
		 * Shouldn't happen !!
		 */
		printf("wdsc_dmanext at end !!!\n");
		wdsc_dmastop(dev);
		return 0;
	}
d332 1
a332 1
	dev->sc_tcnt = dev->sc_cur->dc_count << 1;
d334 12
a345 8
	/* 
	 * Load the next DMA address
	 */
	sys_pcc->pcc_dmacsr   = 0;
	sys_pcc->pcc_dmairq   = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
	sys_pcc->pcc_dmadaddr = (unsigned long)dev->sc_cur->dc_addr;
	sys_pcc->pcc_dmabcnt  = (unsigned long)dev->sc_tcnt | (1 << 24);
	sys_pcc->pcc_dmacsr   = dev->sc_dmacmd;
d347 1
a347 1
	return dev->sc_tcnt;
d351 1
a351 1
 * Stop DMA, and disable interrupts
d354 1
a354 2
wdsc_dmastop(dev)
	struct sbic_softc *dev;
d356 1
a356 1
	int s;
d358 12
a369 6
	s = splbio();

	sys_pcc->pcc_dmacsr    = 0;
	sys_pcc->pcc_dmairq    = dev->sc_ipl | PCC_IRQ_INT;

	splx(s);
d373 1
a373 1
 * Come here following a DMA interrupt
d376 1
a376 2
wdsc_dmaintr(arg)
	void *arg;
d378 2
a379 2
	struct sbic_softc *dev = (struct sbic_softc *)arg;
	int found = 0;
a386 4
	/*
	 * Was it a completion interrupt?
	 * XXXSCW Note: Support for other DMA interrupts is required, eg. buserr
	 */
d388 11
a398 3
		++found;

		sys_pcc->pcc_dmairq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
d401 1
a401 1
	return found;
d405 1
a405 1
 * Come here for SCSI interrupts
d408 1
a408 2
wdsc_scsiintr(arg)
	void *arg;
d410 2
a411 2
	struct sbic_softc *dev = (struct sbic_softc *)arg;
	int found;
d419 1
a419 4
	/*
	 * Go handle it
	 */
	found = sbicintr(dev);
d424 50
a473 1
	sys_pcc->pcc_sbicirq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
d475 8
a482 1
	return found;
@


1.16
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.15 2008/07/30 18:08:03 miod Exp $ */
a66 7
struct scsi_device wdsc_scsidev = {
	NULL,       /* use default error handler */
	NULL,       /* do not have a start function */
	NULL,       /* have no async handler */
	NULL,       /* Use default done routine */
};

a121 1
	sc->sc_link.device         = &wdsc_scsidev;
@


1.15
log
@Do not print adapter target id on the attachment line, now that scsibus(4)
prints it. These should be the last offenders.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.14 2006/11/28 23:59:45 dlg Exp $ */
d62 1
a62 1
	sbic_minphys,
@


1.14
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.13 2006/04/22 11:37:06 miod Exp $ */
d118 2
a130 2

	printf(": SCSI ID %d\n", sc->sc_link.adapter_target);
@


1.13
log
@Correct an evil typo which broke MVME147 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.12 2006/03/15 20:20:40 miod Exp $ */
d115 1
d175 3
d181 1
a181 1
	config_found(self, &sc->sc_link, scsiprint);
@


1.12
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.11 2004/07/30 22:29:45 miod Exp $ */
d177 1
a177 1
	config_found(parent, &sc->sc_link, scsiprint);
@


1.11
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.10 2004/07/02 17:57:29 miod Exp $ */
d172 1
a172 1
	 * (see dk_establish).
@


1.10
log
@Kill ca_master in autoconf structures. Drivers either only attach to one
specific bus (mc/pcc/pcctwo), or they know it from the ca_bustype value,
and can use the globals sys_busname variables.

This also allows for some code simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.9 2004/01/14 20:50:48 miod Exp $ */
d61 4
a64 4
    sbic_scsicmd,
    sbic_minphys,
    0,          /* no lun support */
    0,          /* no lun support */
d68 4
a71 4
    NULL,       /* use default error handler */
    NULL,       /* do not have a start functio */
    NULL,       /* have no async handler */
    NULL,       /* Use default done routine */
d94 3
a96 3
    struct device *pdp;
    struct cfdata *cdp;
    void *auxp;
d98 4
a101 4
    /*
     * Match everything
     */
    return(1);
d109 3
a111 3
wdscattach(pdp, dp, auxp)
    struct device *pdp, *dp;
    void *auxp;
d113 66
a178 67
    struct sbic_softc   *sc = (struct sbic_softc *)dp;
    struct confargs *ca = auxp;
    int tmp;

    sc->sc_enintr  = wdsc_enintr;
    sc->sc_dmago   = wdsc_dmago;
    sc->sc_dmanext = wdsc_dmanext;
    sc->sc_dmastop = wdsc_dmastop;
    sc->sc_dmacmd  = 0;

    sc->sc_link.adapter_softc  = sc;
    sc->sc_link.adapter_target = 7;
    sc->sc_link.adapter        = &wdsc_scsiswitch;
    sc->sc_link.device         = &wdsc_scsidev;
    sc->sc_link.openings       = 2;

    printf(": target %d\n", sc->sc_link.adapter_target);

    sc->sc_sbicp = (sbic_regmap_p)ca->ca_vaddr;

    /*
     * Eveything is a valid dma address.
     * 
     */
    sc->sc_dmamask = 0;

    /*
     * The onboard WD33C93 of the '147 is usually clocked at 10MHz...
     * (We use 10 times this for accuracy in later calculations)
     */
    sc->sc_clkfreq = 100;

    /*
     * Initialise the hardware
     */
    sbicinit(sc);

    sc->sc_ipl = ca->ca_ipl;

    sys_pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_INT;
    sys_pcc->pcc_dmairq = ca->ca_ipl | PCC_IRQ_INT;
    sys_pcc->pcc_dmacsr  = 0;

    /*
     * Fix up the interrupts
     */
    sc->sc_dmaih.ih_fn = wdsc_dmaintr;
    sc->sc_dmaih.ih_arg = sc;
    sc->sc_dmaih.ih_ipl = ca->ca_ipl;
    pccintr_establish(PCCV_DMA, &sc->sc_dmaih);

    sc->sc_sbicih.ih_fn = wdsc_scsiintr;
    sc->sc_sbicih.ih_arg = sc;
    sc->sc_sbicih.ih_ipl = ca->ca_ipl;
    pccintr_establish(PCCV_SBIC, &sc->sc_sbicih);

    sys_pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;

    /*
     * Attach all scsi units on us, watching for boot device
     * (see dk_establish).
     */
    tmp = bootpart;
    if (ca->ca_paddr != bootaddr) 
	bootpart = -1;		/* invalid flag to dk_establish */
    config_found(dp, &sc->sc_link, scsiprint);
    bootpart = tmp;		/* restore old value */
d186 1
a186 1
    struct sbic_softc *dev;
d188 1
a188 1
    dev->sc_flags |= SBICF_INTR;
d190 1
a190 1
    sys_pcc->pcc_dmairq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
d198 3
a200 3
    struct sbic_softc *dev;
    char *addr;
    int count, flags;
d202 21
a222 21
    /*
     * Set up the command word based on flags
     */
    if ( (flags & DMAGO_READ) == 0 )
        dev->sc_dmacmd = DMAC_CSR_ENABLE | DMAC_CSR_WRITE;
    else
        dev->sc_dmacmd = DMAC_CSR_ENABLE;

    dev->sc_flags |= SBICF_INTR;
    dev->sc_tcnt   = dev->sc_cur->dc_count << 1;

    /*
     * Prime the hardware.
     * Note, it's probably not necessary to do this here, since dmanext
     * is called just prior to the actual transfer.
     */
    sys_pcc->pcc_dmacsr   = 0;
    sys_pcc->pcc_dmairq   = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
    sys_pcc->pcc_dmadaddr = (unsigned long)dev->sc_cur->dc_addr;
    sys_pcc->pcc_dmabcnt  = (unsigned long)dev->sc_tcnt | (1 << 24);
    sys_pcc->pcc_dmacsr   = dev->sc_dmacmd;
d224 1
a224 1
    return(dev->sc_tcnt);
d232 1
a232 1
    struct sbic_softc *dev;
d234 19
a252 19
    if ( dev->sc_cur > dev->sc_last ) {
        /*
         * Shouldn't happen !!
         */
        printf("wdsc_dmanext at end !!!\n");
        wdsc_dmastop(dev);
        return(0);
    }

    dev->sc_tcnt = dev->sc_cur->dc_count << 1;

    /* 
     * Load the next DMA address
     */
    sys_pcc->pcc_dmacsr   = 0;
    sys_pcc->pcc_dmairq   = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
    sys_pcc->pcc_dmadaddr = (unsigned long)dev->sc_cur->dc_addr;
    sys_pcc->pcc_dmabcnt  = (unsigned long)dev->sc_tcnt | (1 << 24);
    sys_pcc->pcc_dmacsr   = dev->sc_dmacmd;
d254 1
a254 1
    return(dev->sc_tcnt);
d262 1
a262 1
    struct sbic_softc *dev;
d264 1
a264 1
    int                 s;
d266 1
a266 1
    s = splbio();
d268 2
a269 2
    sys_pcc->pcc_dmacsr    = 0;
    sys_pcc->pcc_dmairq    = dev->sc_ipl | PCC_IRQ_INT;
d271 1
a271 1
    splx(s);
d281 2
a282 2
    struct sbic_softc *dev = (struct sbic_softc *)arg;
    int                 found = 0;
d284 12
a295 12
    /*
     * Really a DMA interrupt?
     */
    if ( (sys_pcc->pcc_dmairq & PCC_IRQ_INT) == 0 )
        return(0);

    /*
     * Was it a completion interrupt?
     * XXXSCW Note: Support for other DMA interrupts is required, eg. buserr
     */
    if ( sys_pcc->pcc_dmacsr & DMAC_CSR_DONE ) {
        ++found;
d297 2
a298 2
        sys_pcc->pcc_dmairq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
    }
d300 1
a300 1
    return(found);
d310 2
a311 2
    struct sbic_softc *dev = (struct sbic_softc *)arg;
    int                 found;
d313 15
a327 15
    /*
     * Really a SCSI interrupt?
     */
    if ( (sys_pcc->pcc_sbicirq & PCC_IRQ_INT) == 0 )
        return(0);

    /*
     * Go handle it
     */
    found = sbicintr(dev);

    /*
     * Acknowledge and clear the interrupt
     */
    sys_pcc->pcc_sbicirq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
d329 1
a329 1
    return(found);
@


1.9
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.8 2003/06/02 23:27:50 millert Exp $ */
a114 1
    struct pccreg *pcc = (struct pccreg *)ca->ca_master;
a130 1
    sc->sc_cregs = (void *)pcc;
d152 3
a154 3
    pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_INT;
    pcc->pcc_dmairq = ca->ca_ipl | PCC_IRQ_INT;
    pcc->pcc_dmacsr  = 0;
d169 1
a169 1
    pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
a188 2
    struct pccreg *pcc = dev->sc_cregs;

d191 1
a191 1
    pcc->pcc_dmairq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
a202 2
    volatile struct pccreg *pc = dev->sc_cregs;

d219 5
a223 5
    pc->pcc_dmacsr   = 0;
    pc->pcc_dmairq   = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
    pc->pcc_dmadaddr = (unsigned long)dev->sc_cur->dc_addr;
    pc->pcc_dmabcnt  = (unsigned long)dev->sc_tcnt | (1 << 24);
    pc->pcc_dmacsr   = dev->sc_dmacmd;
a234 2
    volatile struct pccreg *pc = dev->sc_cregs;

d249 5
a253 5
    pc->pcc_dmacsr   = 0;
    pc->pcc_dmairq   = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
    pc->pcc_dmadaddr = (unsigned long)dev->sc_cur->dc_addr;
    pc->pcc_dmabcnt  = (unsigned long)dev->sc_tcnt | (1 << 24);
    pc->pcc_dmacsr   = dev->sc_dmacmd;
a264 1
    volatile struct pccreg *pc = dev->sc_cregs;
d269 2
a270 2
    pc->pcc_dmacsr    = 0;
    pc->pcc_dmairq    = dev->sc_ipl | PCC_IRQ_INT;
a282 1
    volatile struct pccreg *pc = dev->sc_cregs;
d288 1
a288 1
    if ( (pc->pcc_dmairq & PCC_IRQ_INT) == 0 )
d295 1
a295 1
    if ( pc->pcc_dmacsr & DMAC_CSR_DONE ) {
d298 1
a298 1
        pc->pcc_dmairq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
a311 1
    volatile struct pccreg *pc = dev->sc_cregs;
d317 1
a317 1
    if ( (pc->pcc_sbicirq & PCC_IRQ_INT) == 0 )
d328 1
a328 1
    pc->pcc_sbicirq = dev->sc_ipl | PCC_IRQ_IEN | PCC_IRQ_INT;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.7 2002/04/27 23:21:05 miod Exp $ */
d79 1
a79 1
    NULL, "wdsc", DV_DULL, NULL, 0 
@


1.7
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.6 2002/03/14 01:26:37 millert Exp $ */
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by the University of
 *  California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.5 1997/01/28 10:54:10 deraadt Exp $ */
d58 5
a62 2
int     wdsc_dmaintr(struct sbic_softc *);
int     wdsc_scsiintr(struct sbic_softc *);
a119 1
    int                 ipl;
d292 2
a293 2
wdsc_dmaintr(dev)
    struct sbic_softc *dev;
d295 1
d322 2
a323 2
wdsc_scsiintr(dev)
    struct sbic_softc *dev;
d325 1
@


1.5
log
@use scsiprint
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.4 1996/11/23 21:46:02 kstailey Exp $ */
d51 2
a52 2
void    wdscattach      __P((struct device *, struct device *, void *));
int     wdscmatch       __P((struct device *, struct cfdata *, void *));
d54 6
a59 6
void    wdsc_enintr     __P((struct sbic_softc *));
int     wdsc_dmago      __P((struct sbic_softc *, char *, int, int));
int     wdsc_dmanext    __P((struct sbic_softc *));
void    wdsc_dmastop    __P((struct sbic_softc *));
int     wdsc_dmaintr    __P((struct sbic_softc *));
int     wdsc_scsiintr   __P((struct sbic_softc *));
@


1.5.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.5 1997/01/28 10:54:10 deraadt Exp $ */
d51 2
a52 2
void    wdscattach(struct device *, struct device *, void *);
int     wdscmatch(struct device *, struct cfdata *, void *);
d54 6
a59 9
void    wdsc_enintr(struct sbic_softc *);
int     wdsc_dmago(struct sbic_softc *, char *, int, int);
int     wdsc_dmanext(struct sbic_softc *);
void    wdsc_dmastop(struct sbic_softc *);
int     wdsc_dmaintr(void *);
int     wdsc_scsiintr(void *);

extern void sbicinit(struct sbic_softc *);
extern int sbicintr(struct sbic_softc *);
d117 1
d290 2
a291 2
wdsc_dmaintr(arg)
	void *arg;
a292 1
    struct sbic_softc *dev = (struct sbic_softc *)arg;
d319 2
a320 2
wdsc_scsiintr(arg)
	void *arg;
a321 1
    struct sbic_softc *dev = (struct sbic_softc *)arg;
@


1.5.14.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d51 2
a52 2
void    wdscattach(struct device *, struct device *, void *);
int     wdscmatch(struct device *, struct cfdata *, void *);
d54 6
a59 6
void    wdsc_enintr(struct sbic_softc *);
int     wdsc_dmago(struct sbic_softc *, char *, int, int);
int     wdsc_dmanext(struct sbic_softc *);
void    wdsc_dmastop(struct sbic_softc *);
int     wdsc_dmaintr(struct sbic_softc *);
int     wdsc_scsiintr(struct sbic_softc *);
@


1.5.14.2
log
@Sync the SMP branch with 3.3
@
text
@d58 2
a59 5
int     wdsc_dmaintr(void *);
int     wdsc_scsiintr(void *);

extern void sbicinit(struct sbic_softc *);
extern int sbicintr(struct sbic_softc *);
d117 1
d290 2
a291 2
wdsc_dmaintr(arg)
	void *arg;
a292 1
    struct sbic_softc *dev = (struct sbic_softc *)arg;
d319 2
a320 2
wdsc_scsiintr(arg)
	void *arg;
a321 1
    struct sbic_softc *dev = (struct sbic_softc *)arg;
@


1.5.14.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wdsc.c,v 1.5.14.2 2003/03/27 23:32:16 niklas Exp $ */
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.14.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d79 1
a79 1
	NULL, "wdsc", DV_DULL
@


1.4
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a50 1
int     wdscprint       __P((void *auxp, const char *));
d182 1
a182 1
    config_found(dp, &sc->sc_link, wdscprint);
a184 14

/*
 * print diag if pnp is NULL else just extra
 */
int
wdscprint(auxp, pnp)
    void *auxp;
    const char *pnp;
{
    if (pnp == NULL)
        return(UNCONF);
    return(QUIET);
}

@


1.3
log
@update for new generic boot
@
text
@d51 1
a51 1
int     wdscprint       __P((void *auxp, char *));
d193 1
a193 1
    char *pnp;
@


1.2
log
@correct my interrupt bugs
@
text
@d119 1
d177 2
a178 1
     * Attach all scsi units on us
d180 3
d184 1
@


1.1
log
@wdsc driver hacked from amiga driver by Steve Woodford
@
text
@d154 6
d166 1
a166 1
    pcctwointr_establish(PCCV_DMA, &sc->sc_dmaih);
d171 1
a171 5
    pcctwointr_establish(PCCV_SBIC, &sc->sc_dmaih);

    pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_IEN;
    pcc->pcc_dmairq = ca->ca_ipl | PCC_IRQ_IEN;
    pcc->pcc_dmacsr  = 0;
d173 1
a173 1
    pcc->pcc_sbicirq = ca->ca_ipl | PCC_IRQ_IEN /* | PCC_IRQ_INT */;
d206 1
a206 1
    pcc->pcc_dmairq = dev->sc_ipl | PCC_IRQ_IEN /*| PCC_IRQ_INT*/;
d308 1
a308 1
    if ( (pc->pcc_dmairq & 0x80) == 0 )
d337 1
a337 1
    if ( (pc->pcc_sbicirq & 0x80) == 0 )
@
