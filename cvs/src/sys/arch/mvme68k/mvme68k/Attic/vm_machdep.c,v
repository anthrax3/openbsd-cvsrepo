head	1.50;
access;
symbols
	OPENBSD_5_5:1.49.0.8
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.4
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.49.0.2
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.48.0.20
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.18
	OPENBSD_5_0:1.48.0.16
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.14
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.12
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.48.0.8
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.48.0.10
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.6
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.4
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.42.0.4
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.38.0.8
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.38.0.6
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.38.0.4
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.38
	SMP_SYNC_B:1.38
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.35.0.4
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.33.0.4
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.35
	UBC:1.33.0.2
	UBC_BASE:1.33
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.14.0.6
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.49;

1.49
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.13.07.18.01;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.20.17.29.36;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.13.19.38.23;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.24.14.04.04;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.23.13.46.05;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.25.22.26.16;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.11.23.51.26;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.02.23.27.51;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.30.20.37.42;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.28.14.47.54;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.27.23.21.06;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.29.21.26.33;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.05.20.35.43;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.27.04.19.17;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.26.21.35.43;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.10.14.54.46;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.08.08.09.10;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.06.00.45.52;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.05.20.56.45;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.05.20.39.41;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.12.07.38.33;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.06.12.56.19;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.08.22.25.21;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.07.15.49.40;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.05.11.03.02;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.09.27.20.30.32;	author smurph;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.09.03.18.01.24;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.08.17.10.32.17;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.06.06.15.38.34;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.01.10.13.34.18;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	98.07.28.00.13.44;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.03.31.00.24.17;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.06.11.10.15.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.04.16.07.50;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.28.10.57.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.15.02.24.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.28.01.24.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.50.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.13;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.42.55;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.04.18.16.10.42;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.07.04.10.19.44;	author niklas;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2001.10.31.03.01.17;	author nate;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2002.03.06.01.07.00;	author niklas;	state Exp;
branches;
next	1.14.4.6;

1.14.4.6
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.14.4.7;

1.14.4.7
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.14.4.8;

1.14.4.8
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	;

1.33.2.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.49 2013/01/16 19:04:43 miod Exp $ */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: vm_machdep.c 1.21 91/04/06$
 *
 *	@@(#)vm_machdep.c	8.6 (Berkeley) 1/12/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/core.h>
#include <sys/exec.h>
#include <sys/ptrace.h>

#include <machine/cpu.h>
#include <machine/pte.h>
#include <machine/reg.h>
#include <machine/frame.h>

#include <uvm/uvm_extern.h>

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.  Returns 1 in the child process, 0 in the parent.
 * We currently double-map the user area so that the stack is at the same
 * address in each process; in the future we will probably relocate
 * the frame pointers on the stack after copying.
 */

void
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
{
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;
	extern struct pcb *curpcb;

	p2->p_md.md_flags = p1->p_md.md_flags;

	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
	*pcb = p1->p_addr->u_pcb;

	/*
	 * Copy the trap frame, and arrange for the child to return directly
	 * through return_to_user().
	 */
	tf = (struct trapframe *)((u_int)p2->p_addr + USPACE) - 1;
	p2->p_md.md_regs = (int *)tf;
	*tf = *(struct trapframe *)p1->p_md.md_regs;
	
	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL)
		tf->tf_regs[15] = (u_int)stack + stacksize;
	
	sf = (struct switchframe *)tf - 1;
	sf->sf_pc = (u_int)proc_trampoline;
	pcb->pcb_regs[6] = (int)func;		/* A2 */
	pcb->pcb_regs[7] = (int)arg;		/* A3 */
	pcb->pcb_regs[11] = (int)sf;		/* SSP */
	pcb->pcb_ps = PSL_LOWIPL;		/* start kthreads at IPL 0 */
}

/*
 * cpu_exit is called as the last action during exit.
 */
void
cpu_exit(p)
	struct proc *p;
{
	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Dump the machine specific header information at the start of a core dump.
 */
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	struct md_core md_core;
	struct coreseg cseg;
	int error;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

	if (fputype) {
		/* Save floating point registers. */
		error = process_read_fpregs(p, &md_core.freg);
		if (error)
			return error;
	} else {
		/* Make sure these are clear. */
		bzero((caddr_t)&md_core.freg, sizeof(md_core.freg));
	}

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
}

/*
 * Convert kernel VA to physical address
 */
paddr_t
kvtop(addr)
	vaddr_t addr;
{
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), addr, &pa) == FALSE)
		panic("kvtop: zero page frame");

	return (pa);
}

/*
 * Map an IO request into kernel virtual address space.
 *
 * XXX we allocate KVA space by using kmem_alloc_wait which we know
 * allocates space without backing physical memory.  This implementation
 * is a total crock, the multiple mappings of these physical pages should
 * be reflected in the higher-level VM structures to avoid problems.
 */
void
vmapbuf(bp, siz)
	struct buf *bp;
	vsize_t siz;
{
	int npf;
	caddr_t addr;
	struct proc *p;
	int off;
	vaddr_t kva;
	paddr_t pa;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
#endif

	addr = bp->b_saveaddr = bp->b_data;
	off = (int)addr & PGOFSET;
	p = bp->b_proc;
	npf = atop(round_page(bp->b_bcount + off));
	kva = uvm_km_valloc_wait(phys_map, ptoa(npf));
	bp->b_data = (caddr_t)(kva + off);
	while (npf--) {
		if (pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    (vaddr_t)addr, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		pmap_enter(vm_map_pmap(phys_map), kva, trunc_page(pa),
			   VM_PROT_READ|VM_PROT_WRITE, VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
		addr += PAGE_SIZE;
		kva += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}

/*
 * Free the io map PTEs associated with this IO operation.
 */
void
vunmapbuf(bp, siz)
	struct buf *bp;
	vsize_t siz;
{
	caddr_t addr;
	int npf;
	vaddr_t kva;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
#endif

	addr = bp->b_data;
	npf = atop(round_page(bp->b_bcount + ((int)addr & PGOFSET)));
	kva = (vaddr_t)((int)addr & ~PGOFSET);
	pmap_remove(vm_map_pmap(phys_map), kva, kva + ptoa(npf));
	pmap_update(vm_map_pmap(phys_map));
	uvm_km_free_wakeup(phys_map, kva, ptoa(npf));
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
}
@


1.49
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.48 2007/11/02 19:18:54 martin Exp $ */
@


1.48
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.47 2007/10/13 07:18:01 miod Exp $ */
d172 1
a172 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
	    NULL, p);
d178 1
a178 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.47
log
@Do not splhigh() before invoking sched_exit(), sched_exit() will do it better.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.46 2007/10/10 15:53:52 art Exp $ */
d230 2
a231 2
	npf = btoc(round_page(bp->b_bcount + off));
	kva = uvm_km_valloc_wait(phys_map, ctob(npf));
d263 1
a263 1
	npf = btoc(round_page(bp->b_bcount + ((int)addr & PGOFSET)));
d265 1
a265 1
	pmap_remove(vm_map_pmap(phys_map), kva, kva + ctob(npf));
d267 1
a267 1
	uvm_km_free_wakeup(phys_map, kva, ctob(npf));
@


1.46
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.45 2007/06/20 17:29:36 miod Exp $ */
a119 3
 *
 * Block context switches and then call switch_exit() which will
 * switch to another process thus we never return.
a124 2
	(void)splhigh();

@


1.45
log
@In vunmapbuf(), explicitely remove mappings before invoking uvm_km_free().
Even if the latter would end up removing the mappings by itself, it would
do so using pmap_remove() because phys_map is not intrsafe; but some
platforms use pmap_kenter_pa() in vmapbuf(). By removing the mappings
ourselves, we can ensure the remove function used matches the enter function
which has been used.
Discussed and theoretical ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.44 2007/05/27 20:59:25 miod Exp $ */
d120 3
a122 5
 * We release the address space and machine-dependent resources,
 * including the memory for the user structure and kernel stack.
 * Once finished, we call switch_exit, which switches to a temporary
 * pcb and stack and never returns.  We block memory allocation
 * until switch_exit has made things safe again.
d128 1
d130 2
a131 3
	splhigh();
	switch_exit(p);
	/* NOTREACHED */
@


1.44
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.43 2007/03/13 19:38:23 miod Exp $ */
d272 2
@


1.43
log
@Reset psl to spl0 in cpu_fork(), so that kthreads start at spl0 and not
splhigh(); from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.42 2006/06/24 14:04:04 miod Exp $ */
a191 33
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap.
 */
void
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
{
	paddr_t pa;
	boolean_t rv;

#ifdef DEBUG
	if ((size & PAGE_MASK) != 0)
		panic("pagemove");
#endif
	while (size > 0) {
		rv = pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
#ifdef DEBUG
		if (rv == FALSE)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vaddr_t)to, NULL) == TRUE)
			panic("pagemove 3");
#endif
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
@


1.42
log
@Replace physaccess() usage with pmap_kenter_cache().
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.41 2006/06/23 13:46:05 mickey Exp $ */
d115 1
@


1.41
log
@consistantly count context switches on exit; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.40 2005/12/17 07:31:26 miod Exp $ */
a223 37
}

/*
 * Map `size' bytes of physical memory starting at `paddr' into
 * kernel VA space at `vaddr'.  Read/write and cache-inhibit status
 * are specified by `prot'.
 */ 
void
physaccess(vaddr, paddr, size, prot)
	vaddr_t vaddr;
	paddr_t paddr;
	size_t size;
	int prot;
{
	pt_entry_t *pte;
	u_int page;

	pte = kvtopte(vaddr);
	page = (u_int)paddr & PG_FRAME;
	for (size = btoc(size); size; size--) {
		*pte++ = PG_V | prot | page;
		page += NBPG;
	}
	TBIAS();
}

void
physunaccess(vaddr, size)
	vaddr_t vaddr;
	size_t size;
{
	pt_entry_t *pte;

	pte = kvtopte(vaddr);
	for (size = btoc(size); size; size--)
		*pte++ = PG_NV;
	TBIAS();
@


1.40
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.39 2005/09/25 22:26:16 miod Exp $ */
a130 1
	uvmexp.swtch++;
@


1.39
log
@Define the symbolic register indexes in trapframe in <m68k/reg.h> only
#ifdef _KERNEL; also remove duplicate prototypes with <sys/ptrace.h>.
Helped by martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.38 2004/01/11 23:51:26 miod Exp $ */
d203 1
a203 1
	vm_offset_t pa;
d211 1
a211 1
		rv = pmap_extract(pmap_kernel(), (vm_offset_t)from, &pa);
d215 1
a215 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to, NULL) == TRUE)
d218 2
a219 2
		pmap_kremove((vm_offset_t)from, PAGE_SIZE);
		pmap_kenter_pa((vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
d273 1
a273 1
	if (pmap_extract(pmap_kernel(), (vm_offset_t)addr, &pa) == FALSE)
d289 2
a290 2
	register struct buf *bp;
	vm_size_t siz;
d292 2
a293 2
	register int npf;
	register caddr_t addr;
d296 2
a297 2
	vm_offset_t kva;
	vm_offset_t pa;
d312 1
a312 1
		    (vm_offset_t)addr, &pa) == FALSE)
d327 2
a328 2
	register struct buf *bp;
	vm_size_t siz;
d330 3
a332 3
	register caddr_t addr;
	register int npf;
	vm_offset_t kva;
d341 1
a341 1
	kva = (vm_offset_t)((int)addr & ~PGOFSET);
@


1.38
log
@Use splhigh() instead of splimp() in cpu_exit. [similar fix as done on mvme88k]
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.37 2003/06/02 23:27:51 millert Exp $ */
d51 1
@


1.37
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.36 2003/05/30 20:37:42 miod Exp $ */
d129 1
a129 1
	(void) splimp();
@


1.36
log
@Sync the core dump routine with hp300; generates correct coredumps again.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.35 2002/04/28 14:47:54 miod Exp $ */
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.35
log
@A few more tweaks to let non-GENERIC kernels (MVMEfoo) build as well with -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2002/04/27 23:21:06 miod Exp $ */
d53 2
d59 1
d142 4
d153 42
a194 2
	return (vn_rdwr(UIO_WRITE, vp, (caddr_t) p->p_addr, USPACE,
	    (off_t)0, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p));
@


1.34
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2001/12/08 02:24:06 art Exp $ */
a249 1
	register long flags = bp->b_flags;
d256 1
a256 1
	if ((flags & B_PHYS) == 0)
@


1.33
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2001/11/06 19:53:15 miod Exp $ */
a81 1
	extern void proc_trampoline(), child_return();
d190 4
a193 2
	caddr_t vaddr, paddr;
	register int size, prot;
d195 2
a196 2
	register pt_entry_t *pte;
	register u_int page;
d209 2
a210 2
	caddr_t vaddr;
	register int size;
d212 1
a212 1
	register pt_entry_t *pte;
d223 1
a223 1
int
d225 1
a225 1
	caddr_t addr;
d231 2
a232 1
	return((int)pa);
@


1.33.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2001/12/08 02:24:06 art Exp $ */
d82 1
d191 2
a192 4
	vaddr_t vaddr;
	paddr_t paddr;
	size_t size;
	int prot;
d194 2
a195 2
	pt_entry_t *pte;
	u_int page;
d208 2
a209 2
	vaddr_t vaddr;
	size_t size;
d211 1
a211 1
	pt_entry_t *pte;
d222 1
a222 1
paddr_t
d224 1
a224 1
	vaddr_t addr;
d230 1
a230 2

	return (pa);
d248 1
d255 1
a255 1
	if ((bp->b_flags & B_PHYS) == 0)
@


1.32
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2001/11/06 18:41:10 art Exp $ */
d181 1
d274 1
@


1.31
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2001/09/29 21:26:33 miod Exp $ */
a57 1
#include <vm/vm.h>
@


1.30
log
@Remove unused routines, and a few style/harmonization fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2001/09/19 20:50:56 mickey Exp $ */
d72 2
a73 2
cpu_fork(p1, p2, stack, stacksize)
	register struct proc *p1, *p2;
d76 2
d79 3
a81 3
	register struct pcb *pcb = &p2->p_addr->u_pcb;
	register struct trapframe *tf;
	register struct switchframe *sf;
d100 1
a100 1
	 * through return_to_user().  Note the inline version of cpu_set_kpc().
d114 2
a115 2
	pcb->pcb_regs[6] = (int)child_return;	/* A2 */
	pcb->pcb_regs[7] = (int)p2;		/* A3 */
a116 10
}

void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	p->p_addr->u_pcb.pcb_regs[6] = (int)pc;		/* A2 */
	p->p_addr->u_pcb.pcb_regs[7] = (int)arg;	/* A3 */
@


1.29
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/08/05 20:35:43 miod Exp $ */
d74 2
a75 2
   void *stack;
   size_t stacksize;
a145 7
void
cpu_cleanup(p)
	struct proc *p;
{

}

a227 18
 * Set a red zone in the kernel stack after the u. area.
 * We don't support a redzone right now.  It really isn't clear
 * that it is a good idea since, if the kernel stack were to roll
 * into a write protected page, the processor would lock up (since
 * it cannot create an exception frame) and we would get no useful
 * post-mortem info.  Currently, under the DEBUG option, we just
 * check at every clock interrupt to see if the current k-stack has
 * gone too far (i.e. into the "redzone" page) and if so, panic.
 * Look at _lev6intr in locore.s for more details.
 */
/*ARGSUSED*/
setredzone(pte, vaddr)
	pt_entry_t *pte;
	caddr_t vaddr;
{
}

/*
a240 2
extern vm_map_t phys_map;

d262 1
d265 2
d296 1
d299 2
@


1.28
log
@Use syntaxic sugar provided by PMAP_NEW
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2001/07/25 13:25:32 art Exp $ */
a58 1
#include <vm/vm_kern.h>
@


1.27
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2001/06/27 04:19:17 art Exp $ */
d178 1
d185 1
a185 1
		pmap_extract(pmap_kernel(), (vm_offset_t)from, &pa);
d187 1
a187 2
#if 0
		if (pa == 0)
d189 1
a189 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to, XXX) != 0)
d192 2
a193 7
#endif
		pmap_remove(pmap_kernel(),
			    (vm_offset_t)from, (vm_offset_t)from + PAGE_SIZE);
		pmap_enter(pmap_kernel(),
			   (vm_offset_t)to, pa, 
            VM_PROT_READ|VM_PROT_WRITE,
            VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.26
log
@zap old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2001/06/26 21:35:43 miod Exp $ */
d197 2
a198 2
            VM_PROT_READ|VM_PROT_WRITE, 1, 
            VM_PROT_READ|VM_PROT_WRITE);
d308 1
a308 1
			   VM_PROT_READ|VM_PROT_WRITE, TRUE, VM_PROT_READ|VM_PROT_WRITE);
@


1.25
log
@A few changes to mvme68k:
+ switch to UVM
+ fix the system trace problem
+ big cleanup of locore.s (macro for BUG calls, use more common m68k
  code whenever possible, and the macros in <m68k/asm.h>)
+ better indentation on some parts (old KNF)
+ call doshutdownhooks() at shutdown
+ use <net/netisr_dispatch.h>
+ upgrade pmap.c to something very close to our current hp300 pmap.c,
  minus support for PMAP_NEW and for HP MMU
+ various tidbits I forget to mention here

work and tests by smurph@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2001/06/10 14:54:46 miod Exp $ */
a59 1
#if defined(UVM)
a60 1
#endif
a141 1
#if defined(UVM)
a142 3
#else
	cnt.v_swtch++;
#endif
a300 1
#if defined(UVM)
a301 3
#else
	kva = kmem_alloc_wait(phys_map, ctob(npf));
#endif
a330 1
#if defined(UVM)
a331 3
#else
	kmem_free_wakeup(phys_map, kva, ctob(npf));
#endif
@


1.24
log
@Post pmap_extract() changes cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/06/08 08:09:10 art Exp $ */
d60 3
d86 11
a96 2
	/* Sync curpcb (which is presumably p1's PCB) and copy it to p2. */
	savectx(curpcb);
d107 1
a107 1
   /*
d113 1
a113 1
   sf = (struct switchframe *)tf - 1;
a114 1

d144 3
d148 1
d216 1
d218 1
a218 1
	void *vaddr, *paddr;
d233 1
d267 1
d307 3
d311 1
d341 3
d345 1
@


1.23
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/05/06 00:45:52 art Exp $ */
d168 1
a168 1
	register vm_offset_t pa;
d281 1
a281 1
	register vm_offset_t pa;
@


1.22
log
@Update some comments wrt. the CLSIZE changes.
And remove that memory price comment from 1981. It is amusing, but also
confusing because the math in there is only correct on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/05/05 20:56:45 art Exp $ */
d175 1
a175 1
		pa = pmap_extract(pmap_kernel(), (vm_offset_t)from);
d177 1
d180 1
a180 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to) != 0)
d183 1
d251 1
a251 1
	register caddr_t addr;
d253 1
a253 1
	vm_offset_t va;
d255 1
a255 2
	va = pmap_extract(pmap_kernel(), (vm_offset_t)addr);
	if (va == 0)
d257 1
a257 1
	return((int)va);
d292 2
a293 3
		pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    (vm_offset_t)addr);
		if (pa == 0)
@


1.21
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/04/05 20:39:41 deraadt Exp $ */
d161 1
a161 2
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of CLSIZE.
@


1.20
log
@undo changes which did not even compile
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2000/07/06 12:56:19 art Exp $ */
d172 1
a172 1
	if (size & CLOFSET)
@


1.19
log
@Initial code for UVM.  not tested yet...
@
text
@a59 3
#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif
d95 1
a95 1
	/*
d101 1
a101 1
	sf = (struct switchframe *)tf - 1;
a132 3
#if defined(UVM)
	uvmexp.swtch++;
#else
a133 1
#endif
a288 3
#if defined(UVM)
	kva = uvm_km_valloc_wait(phys_map, ctob(npf));
#else
a289 1
#endif
a319 3
#if defined(UVM)
	uvm_km_free_wakeup(phys_map, kva, ctob(npf));
#else
a320 1
#endif
@


1.18
log
@Fix pmap_activate and activation of the
correct pmap.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2000/06/08 22:25:21 niklas Exp $ */
d60 3
d98 1
a98 1
   /*
d104 1
a104 1
   sf = (struct switchframe *)tf - 1;
d136 3
d140 1
d296 3
d300 1
d331 3
d335 1
@


1.17
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2000/06/08 21:12:04 niklas Exp $ */
a85 2

	PMAP_ACTIVATE(p2->p_vmspace->vm_map.pmap, pcb, 0);
@


1.16
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2000/06/05 11:03:02 art Exp $ */
d48 1
@


1.15
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 1999/09/27 20:30:32 smurph Exp $ */
d86 1
a86 1
	PMAP_ACTIVATE(&p2->p_vmspace->vm_pmap, pcb, 0);
@


1.14
log
@This gets us to 2.6...
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 1999/01/10 13:34:18 niklas Exp $ */
a131 2

	vmspace_free(p->p_vmspace);
@


1.14.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/04/05 20:39:41 deraadt Exp $ */
a47 1
#include <sys/signalvar.h>
d86 2
d132 2
@


1.14.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14.4.1 2001/04/18 16:10:42 niklas Exp $ */
a59 1
#include <uvm/uvm_extern.h>
d83 2
a84 11
	p2->p_md.md_flags = p1->p_md.md_flags;

	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
d95 1
a95 1
	/*
d101 1
a101 1
	sf = (struct switchframe *)tf - 1;
d103 1
d133 1
a133 1
	uvmexp.swtch++;
d161 2
a162 1
 * Both addresses are assumed to reside in the Sysmap.
d169 1
a169 1
	vm_offset_t pa;
d172 1
a172 1
	if ((size & PAGE_MASK) != 0)
d176 1
a176 1
		pmap_extract(pmap_kernel(), (vm_offset_t)from, &pa);
a177 1
#if 0
d180 1
a180 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to, XXX) != 0)
a182 1
#endif
a199 1
void
d201 1
a201 1
	caddr_t vaddr, paddr;
a215 1
void
a248 1
int
d250 1
a250 1
	caddr_t addr;
d252 1
a252 1
	paddr_t pa;
d254 2
a255 1
	if (pmap_extract(pmap_kernel(), (vm_offset_t)addr, &pa) == FALSE)
d257 1
a257 1
	return((int)pa);
d281 1
a281 1
	vm_offset_t pa;
d289 1
a289 1
	kva = uvm_km_valloc_wait(phys_map, ctob(npf));
d292 3
a294 2
		if (pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    (vm_offset_t)addr, &pa) == FALSE)
d320 1
a320 1
	uvm_km_free_wakeup(phys_map, kva, ctob(npf));
@


1.14.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14.4.2 2001/07/04 10:19:44 niklas Exp $ */
d59 1
d75 2
a76 2
	void *stack;
	size_t stacksize;
d147 7
a177 1
	boolean_t rv;
d184 1
a184 1
		rv = pmap_extract(pmap_kernel(), (vm_offset_t)from, &pa);
d186 2
a187 1
		if (rv == FALSE)
d189 1
a189 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to, NULL) == TRUE)
d192 7
a198 2
		pmap_kremove((vm_offset_t)from, PAGE_SIZE);
		pmap_kenter_pa((vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
d241 18
d272 2
a294 1
#ifdef DIAGNOSTIC
a296 2
#endif

d308 1
a308 1
			   VM_PROT_READ|VM_PROT_WRITE, VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
a325 1
#ifdef DIAGNOSTIC
a327 2
#endif

@


1.14.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d58 1
d72 2
a73 2
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
a75 2
	void (*func)(void *);
	void *arg;
d77 3
a79 3
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;
d98 1
a98 1
	 * through return_to_user().
d112 2
a113 2
	pcb->pcb_regs[6] = (int)func;		/* A2 */
	pcb->pcb_regs[7] = (int)arg;		/* A3 */
d115 10
@


1.14.4.5
log
@Merge in trunk
@
text
@a180 1
	pmap_update(pmap_kernel());
a272 1
	pmap_update(pmap_kernel());
@


1.14.4.6
log
@Sync the SMP branch with 3.3
@
text
@d82 1
d191 2
a192 4
	vaddr_t vaddr;
	paddr_t paddr;
	size_t size;
	int prot;
d194 2
a195 2
	pt_entry_t *pte;
	u_int page;
d208 2
a209 2
	vaddr_t vaddr;
	size_t size;
d211 1
a211 1
	pt_entry_t *pte;
d222 1
a222 1
paddr_t
d224 1
a224 1
	vaddr_t addr;
d230 1
a230 2

	return (pa);
d248 1
d255 1
a255 1
	if ((bp->b_flags & B_PHYS) == 0)
@


1.14.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14.4.6 2003/03/27 23:32:17 niklas Exp $ */
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
a52 2
#include <sys/core.h>
#include <sys/exec.h>
a56 1
#include <machine/frame.h>
a138 4
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};
d146 2
a147 42
	struct md_core md_core;
	struct coreseg cseg;
	int error;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

	if (fputype) {
		/* Save floating point registers. */
		error = process_read_fpregs(p, &md_core.freg);
		if (error)
			return error;
	} else {
		/* Make sure these are clear. */
		bzero((caddr_t)&md_core.freg, sizeof(md_core.freg));
	}

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
	    NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
@


1.14.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d129 1
a129 1
	splhigh();
@


1.13
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 1999/08/17 10:32:17 niklas Exp $ */
d69 1
d73 2
a74 2
	void *stack;
	size_t stacksize;
d86 1
a86 1
	PMAP_ACTIVATE(p2->p_vmspace->vm_map.pmap, pcb, 0);
d95 2
a96 2

	/*
d101 3
a104 2
	sf = (struct switchframe *)tf - 1;
	sf->sf_pc = (u_int)proc_trampoline;
d189 3
a191 2
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1,
			   VM_PROT_READ|VM_PROT_WRITE);
d300 1
a300 1
			   VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
@


1.12
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 1999/06/06 15:38:34 deraadt Exp $ */
d187 2
a188 1
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1);
d297 1
a297 1
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
@


1.11
log
@pmap callout changes for uvm; art
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 1999/01/10 13:34:18 niklas Exp $ */
d70 1
a70 1
cpu_fork(p1, p2)
d72 2
d94 7
@


1.10
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1998/07/28 00:13:44 millert Exp $ */
d83 1
a83 1
	PMAP_ACTIVATE(&p2->p_vmspace->vm_pmap, pcb, 0);
@


1.9
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 1997/03/31 00:24:17 downsj Exp $ */
d87 1
a87 1
	 * through return_to_user().
d100 1
a100 1
cpu_set_kpc(p, pc)
d102 2
a103 1
	void (*pc) __P((struct proc *));
d105 2
a106 2

	p->p_addr->u_pcb.pcb_regs[6] = (int)pc;	/* A2 */
@


1.8
log
@Modernize OpenBSD/mvme68k to match various changes in m68k and hp300 code.

Compiles, but untested for lack of hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 1996/06/11 10:15:58 deraadt Exp $ */
d147 1
a147 2
	    (off_t)0, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, (int *) NULL,
	    p));
@


1.7
log
@use void * for pa/va instead of caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a78 2
	p2->p_md.md_flags = p1->p_md.md_flags & ~MDP_HPUXTRACE;

a145 12

#ifdef COMPAT_HPUX
	extern struct emul emul_hpux;

	/*
	 * If we loaded from an HP-UX format binary file we dump enough
	 * of an HP-UX style user struct so that the HP-UX debuggers can
	 * grok it.
	 */
	if (p->p_emul == &emul_hpux)
		return (hpux_dumpu(vp, cred));
#endif
@


1.6
log
@proto nicely
@
text
@d205 1
a205 1
	caddr_t vaddr, paddr;
@


1.5
log
@change vmapbuf/vunmapbuf decls
@
text
@d104 1
a104 1
	u_long pc;
d107 1
a107 1
	p->p_addr->u_pcb.pcb_regs[6] = pc;	/* A2 */
d142 1
a142 1
cpu_coredump(p, vp, cred)
d146 1
d170 1
d172 2
a173 2
	register caddr_t from, to;
	int size;
@


1.4
log
@cpu_fork changes type
@
text
@d1 1
a1 1
/*	$Id: vm_machdep.c,v 1.3 1995/11/28 01:24:42 deraadt Exp $ */
d272 2
a273 1
vmapbuf(bp)
d275 1
d308 2
a309 1
vunmapbuf(bp)
d311 1
@


1.3
log
@delete last chunks of MAPPEDCOPY
@
text
@d1 1
a1 1
/*	$Id: vm_machdep.c,v 1.2 1995/11/07 08:50:29 deraadt Exp $ */
d69 1
a69 1
int
a98 2

	return (0);
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
a323 89

#ifdef MAPPEDCOPY
u_int mappedcopysize = 4096;

mappedcopyin(fromp, top, count)
	register char *fromp, *top;
	register int count;
{
	register vm_offset_t kva, upa;
	register int off, len;
	int alignable;
	pmap_t upmap;
	extern caddr_t CADDR1;

	kva = (vm_offset_t) CADDR1;
	off = (vm_offset_t)fromp & PAGE_MASK;
	alignable = (off == ((vm_offset_t)top & PAGE_MASK));
	upmap = vm_map_pmap(&curproc->p_vmspace->vm_map);
	while (count > 0) {
		/*
		 * First access of a page, use fubyte to make sure
		 * page is faulted in and read access allowed.
		 */
		if (fubyte(fromp) == -1)
			return (EFAULT);
		/*
		 * Map in the page and bcopy data in from it
		 */
		upa = pmap_extract(upmap, trunc_page(fromp));
		if (upa == 0)
			panic("mappedcopyin");
		len = min(count, PAGE_SIZE-off);
		pmap_enter(pmap_kernel(), kva, upa, VM_PROT_READ, TRUE);
		if (len == PAGE_SIZE && alignable && off == 0)
			copypage(kva, top);
		else
			bcopy((caddr_t)(kva+off), top, len);
		fromp += len;
		top += len;
		count -= len;
		off = 0;
	}
	pmap_remove(pmap_kernel(), kva, kva+PAGE_SIZE);
	return (0);
}

mappedcopyout(fromp, top, count)
	register char *fromp, *top;
	register int count;
{
	register vm_offset_t kva, upa;
	register int off, len;
	int alignable;
	pmap_t upmap;
	extern caddr_t CADDR2;

	kva = (vm_offset_t) CADDR2;
	off = (vm_offset_t)top & PAGE_MASK;
	alignable = (off == ((vm_offset_t)fromp & PAGE_MASK));
	upmap = vm_map_pmap(&curproc->p_vmspace->vm_map);
	while (count > 0) {
		/*
		 * First access of a page, use subyte to make sure
		 * page is faulted in and write access allowed.
		 */
		if (subyte(top, *fromp) == -1)
			return (EFAULT);
		/*
		 * Map in the page and bcopy data out to it
		 */
		upa = pmap_extract(upmap, trunc_page(top));
		if (upa == 0)
			panic("mappedcopyout");
		len = min(count, PAGE_SIZE-off);
		pmap_enter(pmap_kernel(), kva, upa,
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
		if (len == PAGE_SIZE && alignable && off == 0)
			copypage(fromp, kva);
		else
			bcopy(fromp, (caddr_t)(kva+off), len);
		fromp += len;
		top += len;
		count -= len;
		off = 0;
	}
	pmap_remove(pmap_kernel(), kva, kva+PAGE_SIZE);
	return (0);
}
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.2 1995/08/10 19:46:45 chuck Exp $	*/
a51 5
#include <sys/core.h>
#include <sys/exec.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>
d57 3
d127 1
a127 1
	(void) splhigh();
d133 7
a142 4
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};
d144 1
a144 1
cpu_coredump(p, vp, cred, chdr)
a147 1
	struct core *chdr;
a148 3
	struct md_core md_core;
	struct coreseg cseg;
	int error;
d161 3
a163 34

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_M68K, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

	/* Save floating point registers. */
	error = process_read_fpregs(p, &md_core.freg);
	if (error)
		return error;

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_M68K, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
	    (int *)0, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, (int *)0, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.24 1995/05/25 01:11:29 mycroft Exp $	*/
d52 5
a61 3
#include <vm/vm.h>
#include <vm/vm_kern.h>

d129 1
a129 1
	(void) splimp();
a134 7
void
cpu_cleanup(p)
	struct proc *p;
{

}

d138 4
d143 1
a143 1
cpu_coredump(p, vp, cred)
d147 1
d149 3
d164 34
a197 3
	return (vn_rdwr(UIO_WRITE, vp, (caddr_t) p->p_addr, USPACE,
	    (off_t)0, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, (int *) NULL,
	    p));
@
