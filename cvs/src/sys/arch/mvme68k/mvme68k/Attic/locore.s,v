head	1.64;
access;
symbols
	OPENBSD_5_5:1.63.0.8
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.63.0.4
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.63.0.2
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.62.0.10
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.8
	OPENBSD_5_0:1.62.0.6
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.62.0.4
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.61.0.4
	OPENBSD_4_6_BASE:1.61
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.55.0.4
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.53.0.4
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.47.0.2
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.43.0.2
	OPENBSD_3_6_BASE:1.43
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.32
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.20.0.4
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.19
	OPENBSD_2_6:1.19.0.6
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.19.0.4
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.64
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.63;

1.63
date	2013.02.02.13.36.05;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2010.06.29.20.30.32;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.01.22.08.13;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.01.21.40.49;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.18.20.48.02;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2009.02.18.20.46.37;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2009.02.18.20.45.49;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.15.13.46.22;	author martin;	state Exp;
branches;
next	1.53;

1.53
date	2006.07.03.18.55.36;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.11.20.57.44;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.19.22.51.09;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.21.22.21.54;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.21.12.27.58;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2005.08.14.12.52.40;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.30.21.28.48;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.01.21.13.59;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.29.07.34.42;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.07.30.09.50.17;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.07.02.17.33.43;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.20.09.20.42;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.24.21.09.37;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.09.00.08.13;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.03.07.46.58;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.02.22.55.55;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.02.23.27.51;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.31.17.28.14;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.04.17.21.31;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.18.21.41.02;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.11.19.08.30;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.10.23.15.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.06.21.13.28;	author millert;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.08.31.00.37.20;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.13.00.01.47;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.27.04.19.17;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.26.21.35.41;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.05.20.39.39;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.12.07.38.31;	author smurph;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.06.12.56.18;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.05.11.03.01;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.06.03.21.43;	author smurph;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	98.09.06.20.10.53;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.03.01.00.37.41;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	97.07.27.09.10.55;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.03.31.00.24.13;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.02.10.17.49.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.02.10.11.39.25;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.02.08.10.50.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.02.03.15.04.57;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.01.28.09.01.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.11.23.23.19.41;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.06.16.00.53.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.29.16.37.17;	author chuck;	state Exp;
branches;
next	1.7;

1.7
date	96.05.03.09.03.49;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.04.28.10.57.27;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.15.02.24.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.07.08.50.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.28.11.14.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.12.25.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.12;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.42.43;	author deraadt;	state Exp;
branches;
next	;

1.20.2.1
date	2001.04.18.16.10.39;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.07.04.10.19.38;	author niklas;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.10.31.03.01.17;	author nate;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2002.03.06.01.07.00;	author niklas;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2004.06.05.23.10.53;	author niklas;	state Exp;
branches;
next	;

1.29.2.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2003.05.19.21.45.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: locore.s,v 1.63 2013/02/02 13:36:05 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1999 Steve Murphree, Jr. (68060 support)
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1980, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: locore.s 1.66 92/12/22$
 *
 *	@@(#)locore.s	8.6 (Berkeley) 5/27/94
 */

#include "assym.h"
#include "ksyms.h"
#include <machine/asm.h>
#include <machine/prom.h>
#include <machine/trap.h>

/*
 * Relocate a symbol, used before MMU is enabled.
 */
#define	_RELOC(var, ar) \
	lea	var,ar

#define	RELOC(var, ar)		_RELOC(_C_LABEL(var), ar)
#define	ASRELOC(var, ar)	_RELOC(_ASM_LABEL(var), ar)

/*
 * Invoke a BUG routine.
 */
#define BUGCALL(id) \
	trap	#15;	\
	.short	id

/*
 * Temporary stack for a variety of purposes.
 * Try and make this the first thing is the data segment so it
 * is page aligned.  Note that if we overflow here, we run into
 * our text segment.
 */
	.data
	.space	NBPG
ASLOCAL(tmpstk)

/*
 * Initialization
 *
 * The bootstrap loader loads us in starting at 0, and VBR is non-zero.
 * On entry, args on stack are boot device, boot filename, console unit,
 * boot flags (howto), boot device name, filesystem type name.
 */
BSS(esym, 4)
BSS(emini, 4)
BSS(smini, 4)
BSS(promvbr, 4)
BSS(promcall, 4)

	.chip	68020
	.text
/*
GLOBAL(edata)
GLOBAL(etext)
GLOBAL(end)
*/
GLOBAL(kernel_text)

ASENTRY_NOPROFILE(start)
	movw	#PSL_HIGHIPL,%sr	| no interrupts
	movl	%sp@@(4), %d7		| get boothowto
	movl	%sp@@(8), %d6		| get bootaddr
	movl	%sp@@(12),%d5		| get bootctrllun
	movl	%sp@@(16),%d4		| get bootdevlun
	movl	%sp@@(20),%d3		| get bootpart
	movl	%sp@@(24),%d2		| get esyms
	/* note: d2-d7 in use */

	ASRELOC(tmpstk, %a0)
	movl	%a0,%sp			| give ourselves a temporary stack

	RELOC(edata, %a0)		| clear out BSS
	movl	#_C_LABEL(end)-4,%d0	| (must be <= 256 kB)
	subl	#_C_LABEL(edata),%d0
	lsrl	#2,%d0
1:	clrl	%a0@@+
	dbra	%d0,1b

	movc	%vbr,%d0		| save prom's trap #15 vector
	RELOC(promvbr, %a0)
	movl	%d0, %a0@@
	RELOC(esym, %a0)
	movl	%d2,%a0@@		| store end of symbol table
	/* note: d2 now free, d3-d7 still in use */
	
	clrl	%sp@@-
	BUGCALL(MVMEPROM_GETBRDID)
	movl	%sp@@+, %a1

	movl	#SIZEOF_MVMEPROM_BRDID, %d0	| copy to local variables
	RELOC(brdid, %a0)
1:	movb	%a1@@+, %a0@@+
	subql	#1, %d0
	bne	1b

	clrl	%d0
	RELOC(brdid, %a1)
	movw	%a1@@(MVMEPROM_BRDID_MODEL), %d0
	RELOC(cputyp, %a0)
	movl	%d0, %a0@@		| init _cputyp

#ifdef MVME141
	cmpw	#CPU_141, %d0
	beq	is141
#endif

#ifdef MVME147
	cmpw	#CPU_147, %d0
	beq	is147
#endif

#ifdef MVME162
	cmpw	#CPU_162, %d0
	beq	is162
#endif

#ifdef MVME165
	cmpw	#CPU_165, %d0
	beq	is165
#endif

#ifdef MVME167
	cmpw	#CPU_166, %d0
	beq	is167
	cmpw	#CPU_167, %d0
	beq	is167
#endif

#ifdef MVME177
        cmpw	#CPU_176, %d0
	beq	is177
        cmpw	#CPU_177, %d0
	beq	is177
#endif
	
#ifdef MVME172
	cmpw	#CPU_172, %d0
	beq	is172
#endif
	
	.data
notsup:	.asciz	"kernel does not support this model."
notsupend:
	.even
	.text

	| first we bitch, then we die.
	movl	#notsupend, %sp@@-
	movl	#notsup, %sp@@-
	BUGCALL(MVMEPROM_OUTSTRCRLF)
	addql	#8,%sp

	BUGCALL(MVMEPROM_EXIT)		| return to m68kbug
	/*NOTREACHED*/

	.chip	68030

#ifdef MVME141
is141:
	RELOC(mmutype, %a0)		| no, we have 68030
	movl	#MMU_68030,%a0@@		| set to reflect 68030 PMMU

	RELOC(cputype, %a0)		| no, we have 68030
	movl	#CPU_68030,%a0@@		| set to reflect 68030 CPU

	RELOC(clockbus, %a0)		| timer is on ofobio
	movl	#BUS_OFOBIO, %a0@@

	movl	#CACHE_OFF,%d0
	movc	%d0,%cacr		| clear and disable on-chip cache(s)

	ASRELOC(memsize141, %a1)	| how much memory?
	jbsr	%a1@@
	movl	%d0, %d1

	RELOC(iiomapsize, %a1)
	movl	#INTIOSIZE_141, %a1@@
	RELOC(iiomapbase, %a1)
	movl	#INTIOBASE_141, %a1@@
	bra	Lstart1
#endif

#ifdef MVME147
is147:
	RELOC(mmutype, %a0)		| no, we have 68030
	movl	#MMU_68030,%a0@@		| set to reflect 68030 PMMU

	RELOC(cputype, %a0)		| no, we have 68030
	movl	#CPU_68030,%a0@@		| set to reflect 68030 CPU

	RELOC(clockbus, %a0)		| timer is on pcc
	movl	#BUS_PCC, %a0@@

	movl	#CACHE_OFF,%d0
	movc	%d0,%cacr		| clear and disable on-chip cache(s)

	movb	#0, 0xfffe1026		| XXX serial interrupt off
	movb	#0, 0xfffe1018		| XXX timer 1 off
	movb	#0, 0xfffe1028		| XXX ethernet off

	movl	#0xfffe0000, %a0	| mvme147 nvram base
	| move nvram component of etheraddr (only last 3 bytes)
	RELOC(myea, %a1)
	movw	%a0@@(NVRAM_147_ETHER+0), %a1@@(3+0)
	movb	%a0@@(NVRAM_147_ETHER+2), %a1@@(3+2)
	movl	%a0@@(NVRAM_147_EMEM), %d1	| pass memory size

	RELOC(iiomapsize, %a1)
	movl	#INTIOSIZE_147, %a1@@
	RELOC(iiomapbase, %a1)
	movl	#INTIOBASE_147, %a1@@
	bra	Lstart1
#endif

	.chip	68040

#ifdef MVME162
is162:
#if 0
	| the following 3 things are "just in case". they won't make
	| the kernel work properly, but they will at least let it get
	| far enough that you can figure out that something had an
	| interrupt pending. which the bootrom shouldn't allow, i don't
	| think..
	clrb	0xfff42002 		| XXX MCchip irq off
	clrl	0xfff42018		| XXX MCchip timers irq off
	clrb	0xfff4201d		| XXX MCchip scc irq off
#endif
	RELOC(memsize162, %a1)		| how much memory?
	jbsr	%a1@@
	movl	%d0, %d2

	RELOC(mmutype, %a0)
	movl	#MMU_68040,%a0@@		| with a 68040 MMU

	RELOC(cputype, %a0)		| no, we have 68040
	movl	#CPU_68040,%a0@@		| set to reflect 68040 CPU

	RELOC(fputype, %a0)
	movl	#FPU_68040,%a0@@		| and a 68040 FPU

	RELOC(clockbus, %a0)		| timer is on mc
	movl	#BUS_MC, %a0@@

	RELOC(vectab, %a1)
	movl	#_C_LABEL(buserr40),%a1@@(8)
	movl	#_C_LABEL(addrerr4060),%a1@@(12)

	bra	is16x
#endif

#ifdef MVME165
is165:
	movl	#0xfffe0000, %a0	| MVME165 CSR
	movl	%a0@@, %d0
	movl	#4*1024*1024, %d1
	btst	#18, %d0		| 4MEG*
	jeq	1f			| not set, this is a 4MB board.
	movl	#16*1024*1024, %d1	| set, this is a 16MB board.

	RELOC(mmutype, %a0)
	movl	#MMU_68040,%a0@@		| with a 68040 MMU

	RELOC(cputype, %a0)		| no, we have 68040
	movl	#CPU_68040,%a0@@		| set to reflect 68040 CPU

	RELOC(fputype, %a0)
	movl	#FPU_68040,%a0@@		| and a 68040 FPU

	RELOC(clockbus, %a0)		| timer is on lrc
	movl	#BUS_LRC, %a0@@

	RELOC(vectab, %a1)
	movl	#_C_LABEL(buserr40),%a1@@(8)
	movl	#_C_LABEL(addrerr4060),%a1@@(12)

	RELOC(iiomapsize, %a1)
	movl	#INTIOSIZE_165, %a1@@
	RELOC(iiomapbase, %a1)
	movl	#INTIOBASE_165, %a1@@

	bra	Lstart1
#endif

#ifdef MVME167
is167:
	RELOC(memsize1x7, %a1)		| how much memory?
	jbsr	%a1@@

	RELOC(mmutype, %a0)
	movl	#MMU_68040,%a0@@		| with a 68040 MMU

	RELOC(cputype, %a0)		| no, we have 68040
	movl	#CPU_68040,%a0@@		| set to reflect 68040 CPU

	RELOC(fputype, %a0)
	movl	#FPU_68040,%a0@@		| and a 68040 FPU

	RELOC(clockbus, %a0)		| timer is on pcctwo
	movl	#BUS_PCCTWO, %a0@@

	RELOC(vectab, %a1)
	movl	#_C_LABEL(buserr40),%a1@@(8)
	movl	#_C_LABEL(addrerr4060),%a1@@(12)

	bra	is16x
#endif

	.chip	68060

#ifdef MVME172
is172:
	
	RELOC(memsize162, %a1)		| how much memory?
	jbsr	%a1@@
	movl	%d0, %d2
        
        /* enable Super Scalar Dispatch */        
	movec	%pcr,%d0
	bset   #0,%d0			| turn on bit 0.
	movec	%d0,%pcr
        
	RELOC(mmutype, %a0)
	movl	#MMU_68060,%a0@@		| with a 68060 MMU

	RELOC(cputype, %a0)		| no, we have 68060
	movl	#CPU_68060,%a0@@		| set to reflect 68060 CPU

	RELOC(fputype, %a0)
	movl	#FPU_68060,%a0@@		| and a 68060 FPU

	RELOC(clockbus, %a0)		| timer is on mc
	movl	#BUS_MC, %a0@@

	RELOC(vectab, %a1)
	movl	#_C_LABEL(buserr60),%a1@@(8)
	movl	#_C_LABEL(addrerr4060),%a1@@(12)

	bra	is16x
#endif

#ifdef MVME177
is177:
	RELOC(memsize1x7, %a1)		| how much memory?
	jbsr	%a1@@
        
        /* enable Super Scalar Dispatch */        
	movc	%pcr,%d0
	bset   #0,%d0			| turn on bit 0.
	movc	%d0,%pcr

	RELOC(mmutype, %a0)
	movl	#MMU_68060,%a0@@		| with a 68060 MMU

	RELOC(cputype, %a0)		| no, we have 68060
	movl	#CPU_68060,%a0@@		| set to reflect 68060 CPU
	
	RELOC(fputype, %a0)
	movl	#FPU_68060,%a0@@		| and a 68060 FPU

	RELOC(clockbus, %a0)		| timer is on pcctwo
	movl	#BUS_PCCTWO, %a0@@

	RELOC(vectab, %a1)
	movl	#_C_LABEL(buserr60),%a1@@(8)
	movl	#_C_LABEL(addrerr4060),%a1@@(12)

	bra	is16x
#endif

	.chip	68020

#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined(MVME172)
#define	ROMPKT_LEN	200
BSS(rompkt, ROMPKT_LEN)
	.even
	.text
is16x:
	RELOC(iiomapsize, %a1)
	movl	#INTIOSIZE_162, %a1@@
	RELOC(iiomapbase, %a1)
	movl	#INTIOBASE_162, %a1@@

	/* get ethernet address */
	RELOC(rompkt, %a0)		| build a .NETCTRL packet
	movb	#0, %a0@@(NETCTRL_DEV)	| onboard ethernet
	movb	#0, %a0@@(NETCTRL_CTRL)	| onboard ethernet
	movl	#NETCTRLCMD_GETETHER, %a0@@(NETCTRL_CMD)
	RELOC(myea, %a1)
	movl	%a1, %a0@@(NETCTRL_ADDR)	| where to put it
	movl	#6, %a0@@(NETCTRL_LEN)	| it is 6 bytes long

	movl	%a0, %sp@@-
	BUGCALL(MVMEPROM_NETCTRL)	| ask the rom
	addl	#4, %sp

	| if memory size is unknown, print a diagnostic and make an
	| assumption
	movl	%d2, %d1
	cmpl	#0, %d1
	bne	Lstart1

	movl	#unkmemend, %sp@@-
	movl	#unkmem, %sp@@-
	BUGCALL(MVMEPROM_OUTSTRCRLF)
	addql	#8,%sp

	movl	#4*1024*1024, %d1	| XXX assume 4M of ram
	bra	Lstart1

	.data
unkmem:	.asciz	"could not figure out how much memory; assuming 4M."
unkmemend:
	.even
	.text

#endif

Lstart1:
/* initialize source/destination control registers for movs */
	moveq	#FC_USERD,%d0		| user space
	movc	%d0,%sfc		|   as source
	movc	%d0,%dfc		|   and destination of transfers
        moveq	#PGSHIFT,%d2
	lsrl	%d2,%d1			| convert to pages
	RELOC(physmem, %a0)
	movl	%d1,%a0@@		| save as physmem

/* configure kernel and proc0 VA space so we can get going */
#if defined(DDB) || NKSYMS > 0
	RELOC(esym,%a0)			| end of static kernel text/data/syms
	movl	%a0@@,%d2
	jne	Lstart2
#endif
	movl	#_C_LABEL(end),%d2	| end of static kernel text/data
Lstart2:
	addl	#NBPG-1,%d2
	andl	#PG_FRAME,%d2		| round to a page
	movl	%d2,%a4

/* do pmap_bootstrap stuff */	
	clrl	%sp@@-			| firstpa
	pea	%a4@@			| nextpa
	RELOC(pmap_bootstrap,%a0)
	jbsr	%a0@@			| pmap_bootstrap(firstpa, nextpa)
	addql	#8,%sp

#if defined(M68040) || defined(M68060)
/*
 * While still running physical, override copypage() with the 68040
 * optimized version, copypage040(), if possible.
 * This relies upon the fact that copypage() immediately follows
 * copypage040() in memory.
 */
	RELOC(mmutype, %a0)
	cmpl	#MMU_68040,%a0@@
	jgt	Lmmu_enable
	RELOC(copypage040, %a0)
	RELOC(copypage, %a1)
	movl	%a1, %a2
1:
	movw	%a0@@+, %a2@@+
	cmpl	%a0, %a1
	jgt	1b
#endif

/*
 * Enable the MMU.
 * Since the kernel is mapped logical == physical, we just turn it on.
 */
Lmmu_enable:
	RELOC(Sysseg, %a0)		| system segment table addr
	movl	%a0@@,%d1		| read value (a KVA)
	RELOC(mmutype, %a0)
	cmpl	#MMU_68040,%a0@@		| 68040 or 68060?
	jgt	Lmotommu1 		| no, skip
	.chip	68040
	movc	%d1,%srp
	movc	%d1,%urp
	jra	Lstploaddone
	.chip	68020
Lmotommu1:
	RELOC(protorp, %a0)
	movl	#0x80000202,%a0@@	| nolimit + share global + 4 byte PTEs
	movl	%d1,%a0@@(4)		| + segtable address
	pmove	%a0@@,%srp		| load the supervisor root pointer
	movl	#0x80000002,%a0@@	| reinit upper half for CRP loads
Lstploaddone:
	RELOC(mmutype, %a0)
	cmpl	#MMU_68040,%a0@@		| 68040 or 68060?
	jgt	Lmotommu2		| no, skip

	.chip	68040
	moveq	#0,%d0			| ensure TT regs are disabled
	movc	%d0,%itt0
	movc	%d0,%itt1
	movc	%d0,%dtt0
	movc	%d0,%dtt1
	cinva	%bc
	pflusha
        movl	#0x8000,%d0
	movc	%d0,%tc
	/* Enable 68060 extensions here */
	RELOC(mmutype, %a0)
	cmpl	#MMU_68060,%a0@@		| 68060?
        jne     Lchache040
        movl	#CACHE60_ON,%d0		| branch cache, etc...
	movc	%d0,%cacr		| turn on both caches
	jmp	Lenab1
Lchache040:
        movl	#CACHE40_ON,%d0
	movc	%d0,%cacr		| turn on both caches
	jmp	Lenab1
	.chip	68020
Lmotommu2:
	movl	#0x82c0aa00,%a2@@	| value to load TC with
	pmove	%a2@@,%tc		| load it
Lenab1:

/*
 * Should be running mapped from this point on
 */
/* select the software page size now */
	lea	_ASM_LABEL(tmpstk),%sp	| temporary stack
	jbsr	_C_LABEL(uvm_setpagesize) | select software page size
/* set kernel stack, user SP, and initial pcb */
	movl	_C_LABEL(proc0paddr),%a1| get proc0 pcb addr
	lea	%a1@@(USPACE-4),%sp	| set kernel stack to end of area
	lea	_C_LABEL(proc0), %a2	| initialize proc0.p_addr so that
	movl	%a1,%a2@@(P_ADDR)	|  we don't deref NULL in trap()
	movl	#USRSTACK-4,%a2
	movl	%a2,%usp		| init user SP
	movl	%a1,_C_LABEL(curpcb)	| proc0 is running

	tstl	_C_LABEL(fputype)	| Have an FPU?
	jeq	Lenab2			| No, skip.
	clrl	%a1@@(PCB_FPCTX)		| ensure null FP context
	movl	%a1,%sp@@-
	jbsr	_C_LABEL(m68881_restore) | restore it (does not kill a1)
	addql	#4,%sp
Lenab2:
/* flush TLB and turn on caches */
	jbsr	_ASM_LABEL(TBIA)	| invalidate TLB
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060?
	jle	Lnocache0		| yes, cache already on
	movl	#CACHE_ON,%d0
	movc	%d0,%cacr		| clear cache(s)
Lnocache0:
/* final setup for C code */
	movl	#_C_LABEL(vectab),%d2	| set VBR
	movc	%d2,%vbr
	movw	#PSL_LOWIPL,%sr		| lower SPL
	movl	%d3, _C_LABEL(bootpart)	| save bootpart
	movl	%d4, _C_LABEL(bootdevlun) | save bootdevlun
	movl	%d5, _C_LABEL(bootctrllun) | save bootctrllun
	movl	%d6, _C_LABEL(bootaddr)	| save bootaddr
	movl	%d7, _C_LABEL(boothowto)| save boothowto
	/* d3-d7 now free */

/* Final setup for call to main(). */
	jbsr	_C_LABEL(mvme68k_init)
 
/*
 * Create a fake exception frame so that cpu_fork() can copy it.
 * main() never returns; we exit to user mode from a forked process
 * later on.
 */
	clrw	%sp@@-			| vector offset/frame type
	clrl	%sp@@-			| PC - filled in by "execve"
	movw	#PSL_USER,%sp@@-		| in user mode
	clrl	%sp@@-			| stack adjust count and padding
	lea	%sp@@(-64),%sp		| construct space for D0-D7/A0-A7
	lea	_C_LABEL(proc0),%a0	| save pointer to frame
	movl	%sp,%a0@@(P_MD_REGS)	|   in proc0.p_md.md_regs

	jra	_C_LABEL(main)		| main()
	PANIC("main() returned")
	/* NOTREACHED */

#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined(MVME172)
/*
 * Figure out the size of onboard DRAM by querying the memory controller(s).
 * This has to be done in locore as badaddr() can not yet be used at this
 * point.
 */
GLOBAL(memsize1x7)
	movl	#0xfff43008,%a0		| MEMC040/MEMECC Controller #1
	jbsr	memc040read
	movl	%d0,%d2

	movl	#0xfff43108,%a0		| MEMC040/MEMECC Controller #2
	jbsr	memc040read
	addl	%d0,%d2

	rts

/*
 * Probe for a memory controller ASIC (MEMC040 or MEMECC) at the
 * address in a0. If found, return the size in bytes of any RAM
 * controller by the ASIC in d0. Otherwise return zero.
 */
ASLOCAL(memc040read)
	moveml	%d1-%d2/%a1-%a2,%sp@@-	| save scratch regs
	movc	%vbr,%d2		| Save vbr
	RELOC(vectab,%a2)		| Install our own vectab, temporarily
	movc	%a2,%vbr
	ASRELOC(Lmemc040berr,%a1)	| get address of bus error handler
	movl	%a2@@(8),%sp@@-		| Save current bus error handler addr
	movl	%a1,%a2@@(8)		| Install our own handler
	movl	%sp,%d0			| Save current stack pointer value
	movql	#0x07,%d1
	andb	%a0@@,%d1		| Access MEMC040/MEMECC
	movl	#0x400000,%d0
	lsll	%d1,%d0			| Convert to memory size, in bytes
Lmemc040ret:
	movc	%d2,%vbr		| Restore original vbr
	movl	%sp@@+,%a2@@(8)		| Restore original bus error handler
	moveml	%sp@@+,%d1-%d2/%a1-%a2
	rts
/*
 * If the memory controller doesn't exist, we get a bus error trying
 * to access a0@@ above. Control passes here, where we flag 'no bytes',
 * ditch the exception frame and return as normal.
 */
Lmemc040berr:
	movl	%d0,%sp			| Get rid of the exception frame
	clrl	%d0			| No ASIC at this location, then!
	jbra	Lmemc040ret		| Done

#endif	/* 162 | 167 | 172 | 177 */

#ifdef MVME141
ASLOCAL(memsize141)
	moveml	%d1-%d3/%a0-%a2,%sp@@-	| save working registers
	movc	%vbr,%d2		| save vbr
	RELOC(vectab,%a2)
	movc	%a2,%vbr		| install our own vectab
	ASRELOC(Lmem141sizeerr,%a1)
	movl	%a2@@(8),%sp@@-		| save bus error and
	movl	%a2@@(12),%sp@@-		| address error vectors
	movl	%a1,%a2@@(8)		| and put ours in place
	movl	%a1,%a2@@(12)
	movl	%sp,%d3			| save stack
	movql	#0,%d0
	movl	%d0,%a0			| starting test address
Lmem141loop:
	movb	%a0@@,%d0		| try byte, word and long access
	movw	%a0@@,%d0
	movl	%a0@@,%d0
	movl	%d0,%d1
	movl	%a0@@,%d0		| read it again
	cmp	%d0,%d1			| and compare
	bne	Lmem141ret		| if they differ, it's not ram
	movel	#(1024 * 1024),%d0
	addl	%d0,%a0
	bra	Lmem141loop
Lmem141ret:
	movl	%a0,%d0			| d0 = size in bytes
	movc	%d2,%vbr		| restore vbr
	movl	%sp@@+,%a2@@(12)		| and vectors
	movl	%sp@@+,%a2@@(8)
	moveml	%sp@@+,%d1-%d3/%a0-%a2
	rts
ASLOCAL(Lmem141sizeerr)
	movl	%d3,%sp			| get rid of the exception frame
	jbra	Lmem141ret
#endif	/* MVME141 */

/*
 * proc_trampoline: call function in register a2 with a3 as an arg
 * and then rei.
 */
GLOBAL(proc_trampoline)
	movl	%a3,%sp@@-		| push function arg
	jbsr	%a2@@			| call function
	addql	#4,%sp			| pop arg
	movl	%sp@@(FR_SP),%a0		| grab and load
	movl	%a0,%usp		|   user SP
	moveml	%sp@@+,#0x7FFF		| restore most user regs
	addql	#8,%sp			| toss SP and stack adjust
	jra	_ASM_LABEL(rei)		| and return


/*
 * Trap/interrupt vector routines - new for 060
 */
#include <m68k/m68k/trap_subr.s>

#if defined(M68040) || defined(M68060)
ENTRY_NOPROFILE(addrerr4060)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	movl	%sp@@(FR_HW+8),%sp@@-
	clrl	%sp@@-			| dummy code
	movl	#T_ADDRERR,%sp@@-	| mark address error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
#endif

#if defined(M68060)
ENTRY_NOPROFILE(buserr60)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	movel	%sp@@(FR_HW+12),%d0	| FSLW
	btst	#2,%d0			| branch prediction error?
	jeq	Lnobpe			
	movc	%cacr,%d2
	orl	#IC60_CABC,%d2		| clear all branch cache entries
	movc	%d2,%cacr
	movl	%d0,%d1
	andl	#0x7ffd,%d1
	jeq	_ASM_LABEL(faultstkadjnotrap2)
Lnobpe:
| we need to adjust for misaligned addresses
	movl	%sp@@(FR_HW+8),%d1	| grab VA
	btst	#27,%d0			| check for mis-aligned access
	jeq	Lberr3			| no, skip
	addl	#28,%d1			| yes, get into next page
            				| operand case: 3,
                                        | instruction case: 4+12+12
	andl	#PG_FRAME,%d1            | and truncate
Lberr3:
	movl	%d1,%sp@@-
	movl	%d0,%sp@@-		| code is FSLW now.
	andw	#0x1f80,%d0 
	jeq	Lbuserr60		| no, handle as usual
	movl	#T_MMUFLT,%sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lbuserr60:
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	Lisberr			| Bus Error?
	movl	_C_LABEL(nofault),%sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
#endif
#if defined(M68040)
ENTRY_NOPROFILE(buserr40)
        clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	movl	%sp@@(FR_HW+20),%d1	| get fault address
	moveq	#0,%d0
	movw	%sp@@(FR_HW+12),%d0	| get SSW
	btst	#11,%d0			| check for mis-aligned
	jeq	Lbe1stpg		| no skip
	addl	#3,%d1			| get into next page
	andl	#PG_FRAME,%d1		| and truncate
Lbe1stpg:
	movl	%d1,%sp@@-		| pass fault address.
	movl	%d0,%sp@@-		| pass SSW as code
	btst	#10,%d0			| test ATC
	jeq	Lbuserr40		| no, handle as usual
	movl	#T_MMUFLT,%sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lbuserr40:        
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	Lisberr			| it is a bus error
	movl	_C_LABEL(nofault),%sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
#endif

ENTRY_NOPROFILE(busaddrerr2030)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	lea	%sp@@(FR_HW),%a1		| grab base of HW berr frame
	moveq	#0,%d0
	movw	%a1@@(10),%d0		| grab SSW for fault processing
	btst	#12,%d0			| RB set?
	jeq	LbeX0			| no, test RC
	bset	#14,%d0			| yes, must set FB
	movw	%d0,%a1@@(10)		| for hardware too
LbeX0:
	btst	#13,%d0			| RC set?
	jeq	LbeX1			| no, skip
	bset	#15,%d0			| yes, must set FC
	movw	%d0,%a1@@(10)		| for hardware too
LbeX1:
	btst	#8,%d0			| data fault?
	jeq	Lbe0			| no, check for hard cases
	movl	%a1@@(16),%d1		| fault address is as given in frame
	jra	Lbe10			| thats it
Lbe0:
	btst	#4,%a1@@(6)		| long (type B) stack frame?
	jne	Lbe4			| yes, go handle
	movl	%a1@@(2),%d1		| no, can use save PC
	btst	#14,%d0			| FB set?
	jeq	Lbe3			| no, try FC
	addql	#4,%d1			| yes, adjust address
	jra	Lbe10			| done
Lbe3:
	btst	#15,%d0			| FC set?
	jeq	Lbe10			| no, done
	addql	#2,%d1			| yes, adjust address
	jra	Lbe10			| done
Lbe4:
	movl	%a1@@(36),%d1		| long format, use stage B address
	btst	#15,%d0			| FC set?
	jeq	Lbe10			| no, all done
	subql	#2,%d1			| yes, adjust address
Lbe10:
	movl	%d1,%sp@@-		| push fault VA
	movl	%d0,%sp@@-		| and padded SSW
	movw	%a1@@(6),%d0		| get frame format/vector offset
	andw	#0x0FFF,%d0		| clear out frame format
	cmpw	#12,%d0			| address error vector?
	jeq	Lisaerr			| yes, go to it
	movl	%d1,%a0			| fault address
	movl	%sp@@,%d0		| function code from ssw
	btst	#8,%d0			| data fault?
	jne	Lbe10a
	movql	#1,%d0			| user program access FC
					| (we dont separate data/program)
	btst	#5,%a1@@			| supervisor mode?
	jeq	Lbe10a			| if no, done
	movql	#5,%d0			| else supervisor program access
Lbe10a:
	ptestr	%d0,%a0@@,#7		| do a table search
	pmove	%psr,%sp@@		| save result
	movb	%sp@@,%d1
	btst	#2,%d1			| invalid (incl. limit viol. and berr)?
	jeq	Lmightnotbemerr		| no -> wp check
	btst	#7,%d1			| is it MMU table berr?
	jeq	Lismerr			| no, must be fast
	jra	Lisberr1		| real bus err needs not be fast.
Lmightnotbemerr:
	btst	#3,%d1			| write protect bit set?
	jeq	Lisberr1		| no: must be bus error
	movl	%sp@@,%d0		| ssw into low word of d0
	andw	#0xc0,%d0		| Write protect is set on page:
	cmpw	#0x40,%d0		| was it read cycle?
	jeq	Lisberr1		| yes, was not WPE, must be bus err
Lismerr:
	movl	#T_MMUFLT,%sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lisaerr:
	movl	#T_ADDRERR,%sp@@-	| mark address error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lisberr1:
	clrw	%sp@@			| re-clear pad word
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	Lisberr			| it is a bus error
	movl	_C_LABEL(nofault),%sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
Lisberr:
	movl	#T_BUSERR,%sp@@-		| mark bus error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it

/*
 * FP exceptions.
 */
ENTRY_NOPROFILE(fpfline)
#if defined(M68040) || defined(M68060)
	cmpl	#FPU_68040,_C_LABEL(fputype) | 68040 or 68060 FPU?
	jlt	Lfp_unimp		| no, skip FPSP
	cmpw	#0x202c,%sp@@(6)		| format type 2?
	jne	_C_LABEL(illinst)	| no, not an FP emulation
Ldofp_unimp:
#ifdef FPSP
	jmp	_ASM_LABEL(fpsp_unimp)	| yes, go handle it
#endif
Lfp_unimp:
#endif/* M68040 || M68060 */
#ifdef FPU_EMULATE
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save registers
	moveq	#T_FPEMULI,%d0		| denote as FP emulation trap
	jra	_ASM_LABEL(fault)	| do it
#else
	jra	_C_LABEL(illinst)
#endif

ENTRY_NOPROFILE(fpunsupp)
#if defined(M68040) || defined(M68060)
	cmpl	#FPU_68040,_C_LABEL(fputype) | 68040 or 68060 FPU?
	jlt	_C_LABEL(illinst)	| no, treat as illinst
#ifdef FPSP
	jmp	_ASM_LABEL(fpsp_unsupp)	| yes, go handle it
#endif
Lfp_unsupp:
#endif /* M68040 */
#ifdef FPU_EMULATE
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save registers
	moveq	#T_FPEMULD,%d0		| denote as FP emulation trap
	jra	_ASM_LABEL(fault)		| do it
#else
	jra	_C_LABEL(illinst)
#endif

/*
 * Handles all other FP coprocessor exceptions.
 * Note that since some FP exceptions generate mid-instruction frames
 * and may cause signal delivery, we need to test for stack adjustment
 * after the trap call.
 */
ENTRY_NOPROFILE(fpfault)
	clrl	%sp@@-		| stack adjust count
	moveml	#0xFFFF,%sp@@-	| save user registers
	movl	%usp,%a0	| and save
	movl	%a0,%sp@@(FR_SP)	|   the user stack pointer
	clrl	%sp@@-		| no VA arg
	movl	_C_LABEL(curpcb),%a0 | current pcb
	lea	%a0@@(PCB_FPCTX),%a0 | address of FP savearea
	fsave	%a0@@		| save state
#if defined(M68040) || defined(M68060)
	/* always null state frame on 68040, 68060 */
	cmpl	#CPU_68040,_C_LABEL(cputype)
	jge	Lfptnull
#endif
	tstb	%a0@@		| null state frame?
	jeq	Lfptnull	| yes, safe
	clrw	%d0		| no, need to tweak BIU
	movb	%a0@@(1),%d0	| get frame size
	bset	#3,%a0@@(0,%d0:w)| set exc_pend bit of BIU
Lfptnull:
	fmovem	%fpsr,%sp@@-	| push fpsr as code argument
	frestore %a0@@		| restore state
	movl	#T_FPERR,%sp@@-	| push type arg
	jra	_ASM_LABEL(faultstkadj)	| call trap and deal with stack cleanup

/*
 * Other exceptions only cause four and six word stack frame and require
 * no post-trap stack adjustment.
 */
ENTRY_NOPROFILE(hardtrap)
	moveml	#0xC0C0,%sp@@-		| save scratch regs
	lea	%sp@@(16),%a1		| get pointer to frame
	movl	%a1,%sp@@-
	movw	%sp@@(26),%d0
	movl	%d0,%sp@@-		| push exception vector info
	movl	%sp@@(26),%sp@@-		| and PC
	jbsr	_C_LABEL(hardintr)	| doit
	lea	%sp@@(12),%sp		| pop args
	moveml	%sp@@+,#0x0303		| restore regs
	jra	_ASM_LABEL(rei)		| all done

ENTRY_NOPROFILE(badtrap)
	moveml	#0xC0C0,%sp@@-		| save scratch regs
	movw	%sp@@(22),%sp@@-		| push exception vector info
	clrw	%sp@@-
	movl	%sp@@(22),%sp@@-		| and PC
	jbsr	_C_LABEL(straytrap)	| report
	addql	#8,%sp			| pop args
	moveml	%sp@@+,#0x0303		| restore regs
	jra	_ASM_LABEL(rei)		| all done

ENTRY_NOPROFILE(trap0)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	movl	%d0,%sp@@-		| push syscall number
	jbsr	_C_LABEL(syscall)	| handle it
	addql	#4,%sp			| pop syscall arg
	tstl	_C_LABEL(astpending)
	jne	Lrei2
	tstl	_C_LABEL(softpending)
	jeq	Ltrap1
	movw	#SPL1,%sr
	tstl	_C_LABEL(softpending)
	jne	Lsir1
Ltrap1:
	movl	%sp@@(FR_SP),%a0		| grab and restore
	movl	%a0,%usp		|   user SP
	moveml	%sp@@+,#0x7FFF		| restore most registers
	addql	#8,%sp			| pop SP and stack adjust
	rte

/*
 * Trap 1 - sigreturn
 */
ENTRY_NOPROFILE(trap1)
	jra	_ASM_LABEL(sigreturn)

/*
 * Trap 2 - trace trap
 */
ENTRY_NOPROFILE(trap2)
	jra	_C_LABEL(trace)

/*
 * Trap 12 is the entry point for the cachectl "syscall"
 *	cachectl(command, addr, length)
 * command in d0, addr in a1, length in d1
 */
ENTRY_NOPROFILE(trap12)
	movl	%d1,%sp@@-		| push length
	movl	%a1,%sp@@-		| push addr
	movl	%d0,%sp@@-		| push command
	movl	CURPROC,%sp@@-		| push proc pointer
	jbsr	_C_LABEL(cachectl)	| do it
	lea	%sp@@(16),%sp		| pop args
	jra	_ASM_LABEL(rei)		| all done

/*
 * Trace (single-step) trap (trap 1 or 2) instruction. Kernel-mode is
 * special. User mode traps are simply passed on to trap().
 */
ENTRY_NOPROFILE(trace)
	clrl	%sp@@-
	moveml	#0xFFFF,%sp@@-
	moveq	#T_TRACE,%d0

	| Check PSW and see what happened.
	|   T=0 S=0	(should not happen)
	|   T=1 S=0	trace trap from user mode
	|   T=0 S=1	trace trap on a trap instruction
	|   T=0 S=0	trace trap from system mode (kernel breakpoint)

	movw	%sp@@(FR_HW),%d1		| get SSW
	notw	%d1			| XXX no support for T0 on 680[234]0
	andw	#PSL_S,%d1		| from system mode (T=1, S=1)?
	jeq	Lkbrkpt			| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault

/*
 * Trap 15 is used for:
 *	- GDB breakpoints (in user programs)
 *	- KGDB breakpoints (in the kernel)
 *	- trace traps for SUN binaries (not fully supported yet)
 *	- calling the prom, but only from the kernel
 * We just pass it on and let trap() sort it all out
 */
ENTRY_NOPROFILE(trap15)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-

	tstl	_C_LABEL(promcall)
	jeq	L_notpromcall
	moveml	%sp@@+,#0xFFFF
	addql	#4, %sp
	| unwind stack to put to known value
	| this routine is from the 147 BUG manual
	| currently save and restore are excessive.
	subql	#4,%sp
	link	%a6,#0
	moveml	#0xFFFE,%sp@@-
	movl	_C_LABEL(promvbr),%a0
	movw	%a6@@(14),%d0
	andl	#0xfff,%d0
	movl	%a0@@(%d0:w),%a6@@(4)
	moveml	%sp@@+,#0x7FFF
	unlk	%a6
	rts
	| really jumps to the bug trap handler
L_notpromcall:
	moveq	#T_TRAP15,%d0
	movw	%sp@@(FR_HW),%d1		| get PSW
	andw	#PSL_S,%d1		| from system mode?
	jne	Lkbrkpt			| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault

Lkbrkpt: | Kernel-mode breakpoint or trace trap. (d0=trap_type)
	| Save the system sp rather than the user sp.
	movw	#PSL_HIGHIPL,%sr	| lock out interrupts
	lea	%sp@@(FR_SIZE),%a6	| Save stack pointer
	movl	%a6,%sp@@(FR_SP)		|   from before trap

	| If we are not on tmpstk switch to it.
	| (so debugger can change the stack pointer)
	movl	%a6,%d1
	cmpl	#_ASM_LABEL(tmpstk),%d1
	jls	Lbrkpt2			| already on tmpstk
	| Copy frame to the temporary stack
	movl	%sp,%a0			| a0=src
	lea	_ASM_LABEL(tmpstk)-96,%a1 | a1=dst
	movl	%a1,%sp			| sp=new frame
	moveq	#FR_SIZE,%d1
Lbrkpt1:
	movl	%a0@@+,%a1@@+
	subql	#4,%d1
	bgt	Lbrkpt1

Lbrkpt2:
	| Call the trap handler for the kernel debugger.
	| Do not call trap() to do it, so that we can
	| set breakpoints in trap() if we want.  We know
	| the trap type is either T_TRACE or T_BREAKPOINT.
	| If we have both DDB and KGDB, let KGDB see it first,
	| because KGDB will just return 0 if not connected.
	| Save args in d2, a2
	movl	%d0,%d2			| trap type
	movl	%sp,%a2			| frame ptr
#ifdef KGDB
	| Let KGDB handle it (if connected)
	movl	%a2,%sp@@-		| push frame ptr
	movl	%d2,%sp@@-		| push trap type
	jbsr	_C_LABEL(kgdb_trap)	| handle the trap
	addql	#8,%sp			| pop args
	cmpl	#0,%d0			| did kgdb handle it?
	jne	Lbrkpt3			| yes, done
#endif
#ifdef DDB
	| Let DDB handle it
	movl	%a2,%sp@@-		| push frame ptr
	movl	%d2,%sp@@-		| push trap type
	jbsr	_C_LABEL(kdb_trap)	| handle the trap
	addql	#8,%sp			| pop args
	cmpl	#0,%d0			| did ddb handle it?
	jne	Lbrkpt3			| yes, done
#endif
	| Drop into the prom
	BUGCALL(MVMEPROM_EXIT)
Lbrkpt3:
	| The stack pointer may have been modified, or
	| data below it modified (by kgdb push call),
	| so push the hardware frame at the current sp
	| before restoring registers and returning.

	movl	%sp@@(FR_SP),%a0		| modified sp
	lea	%sp@@(FR_SIZE),%a1	| end of our frame
	movl	%a1@@-,%a0@@-		| copy 2 longs with
	movl	%a1@@-,%a0@@-		| ... predecrement
	movl	%a0,%sp@@(FR_SP)		| sp = h/w frame
	moveml	%sp@@+,#0x7FFF		| restore all but sp
	movl	%sp@@,%sp		| ... and sp
	rte				| all done

/* Use common m68k sigreturn */
#include <m68k/m68k/sigreturn.s>

/*
 * Interrupt handlers.
 * No device interrupts are auto-vectored.
 */

ENTRY_NOPROFILE(spurintr)
	addql	#1,_C_LABEL(uvmexp)+UVMEXP_INTRS
	jra	_ASM_LABEL(rei)		| all done

/*
 * Emulation of VAX REI instruction.
 *
 * This code deals with checking for and servicing ASTs
 * (profiling, scheduling) and software interrupts (network, softclock).
 * We check for ASTs first, just like the VAX.  To avoid excess overhead
 * the T_ASTFLT handling code will also check for software interrupts so we
 * do not have to do it here.  After identifing that we need an AST we
 * drop the IPL to allow device interrupts.
 *
 * This code is complicated by the fact that sendsig may have been called
 * necessitating a stack cleanup.
 */

BSS(softpending,4)

ASENTRY_NOPROFILE(rei)
	tstl	_C_LABEL(astpending)	| AST pending?
	jeq	Lchksir			| no, go check for SIR
Lrei1:
	btst	#5,%sp@@			| yes, are we returning to user mode?
	jne	Lchksir			| no, go check for SIR
	movw	#PSL_LOWIPL,%sr		| lower SPL
	clrl	%sp@@-			| stack adjust
	moveml	#0xFFFF,%sp@@-		| save all registers
	movl	%usp,%a1		| including
	movl	%a1,%sp@@(FR_SP)		|    the users SP
Lrei2:
	clrl	%sp@@-			| VA == none
	clrl	%sp@@-			| code == none
	movl	#T_ASTFLT,%sp@@-		| type == async system trap
	jbsr	_C_LABEL(trap)		| go handle it
	lea	%sp@@(12),%sp		| pop value args
	movl	%sp@@(FR_SP),%a0		| restore user SP
	movl	%a0,%usp		|   from save area
	movw	%sp@@(FR_ADJ),%d0		| need to adjust stack?
	jne	Laststkadj		| yes, go to it
	moveml	%sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,%sp			| toss SP and stack adjust
	rte				| and do real RTE
Laststkadj:
	lea	%sp@@(FR_HW),%a1		| pointer to HW frame
	addql	#8,%a1			| source pointer
	movl	%a1,%a0			| source
	addw	%d0,%a0			|  + hole size = dest pointer
	movl	%a1@@-,%a0@@-		| copy
	movl	%a1@@-,%a0@@-		|  8 bytes
	movl	%a0,%sp@@(FR_SP)		| new SSP
	moveml	%sp@@+,#0x7FFF		| restore user registers
	movl	%sp@@,%sp		| and our SP
	rte				| and do real RTE
Lchksir:
	tstl	_C_LABEL(softpending)	| SIR pending?
	jeq	Ldorte			| no, all done
	movl	%d0,%sp@@-		| need a scratch register
	movw	%sp@@(4),%d0		| get SR
	andw	#PSL_IPL7,%d0		| mask all but IPL
	jne	Lnosir			| came from interrupt, no can do
	movl	%sp@@+,%d0		| restore scratch register
Lgotsir:
	movw	#SPL1,%sr		| prevent others from servicing int
	tstl	_C_LABEL(softpending)	| too late?
	jeq	Ldorte			| yes, oh well...
	clrl	%sp@@-			| stack adjust
	moveml	#0xFFFF,%sp@@-		| save all registers
	movl	%usp,%a1		| including
	movl	%a1,%sp@@(FR_SP)		|    the users SP
Lsir1:
	clrl	%sp@@-			| VA == none
	clrl	%sp@@-			| code == none
	movl	#T_SSIR,%sp@@-		| type == software interrupt
	jbsr	_C_LABEL(trap)		| go handle it
	lea	%sp@@(12),%sp		| pop value args
	movl	%sp@@(FR_SP),%a0		| restore
	movl	%a0,%usp		|   user SP
	moveml	%sp@@+,#0x7FFF		| and all remaining registers
	addql	#8,%sp			| pop SP and stack adjust
	rte
Lnosir:
	movl	%sp@@+,%d0		| restore scratch register
Ldorte:
	rte				| real return

/*
 * Use common m68k signal trampoline.
 */
#include <m68k/m68k/sigcode.s>

/*
 * Use common m68k support routines.
 */
#include <m68k/m68k/support.s>

	.data
GLOBAL(curpcb)
	.long	0

ASBSS(nullpcb,SIZEOF_PCB)

ENTRY_NOPROFILE(cpu_idle_cycle)
	stop	#PSL_LOWIPL
	rts

/*
 * cpu_switchto(struct proc *oldproc, struct proc *newproc)
 *
 * NOTE: On the mc68851 we attempt to avoid flushing the
 * entire ATC.  The effort involved in selective flushing may not be
 * worth it, maybe we should just flush the whole thing?
 *
 * NOTE 2: With the new VM layout we now no longer know if an inactive
 * user's PTEs have been changed (formerly denoted by the SPTECHG p_flag
 * bit).  For now, we just always flush the full ATC.
 */
ENTRY(cpu_switchto)
	movl	%sp@@(4), %d0		| oldproc
	beq	Lswnofpsave		| is NULL, don't save anything

	/*
	 * Save state of previous process in its pcb.
	 */
        movl	_C_LABEL(curpcb),%a1
	movw	%sr, %a1@@(PCB_PS)	| save sr before switching context
	moveml	#0xFCFC,%a1@@(PCB_REGS)	| save non-scratch registers
	movl	%usp,%a2		| grab USP (a2 has been saved)
	movl	%a2,%a1@@(PCB_USP)	| and save it
#ifdef FPU_EMULATE
	tstl	_C_LABEL(fputype)	| do we have any FPU?
	jeq	Lswnofpsave		| no, dont save
#endif
	lea	%a1@@(PCB_FPCTX),%a2	| pointer to FP save area
	fsave	%a2@@			| save FP state
#ifdef M68060
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
	jeq	Lsavfp60                | yes, goto Lsavfp60
#endif  /* M68060 */
	tstb	%a2@@			| null state frame?
	jeq	Lswnofpsave		| yes, all done
	fmovem	%fp0-%fp7,%a2@@(FPF_REGS)	| save FP general registers
	fmovem	%fpcr/%fpsr/%fpi,%a2@@(FPF_FPCR)	| save FP control registers
#ifdef M68060
	jra	Lswnofpsave
Lsavfp60:
	tstb	%a2@@(2)			| null state frame?
	jeq	Lswnofpsave		| yes, all done
	fmovem	%fp0-%fp7,%a2@@(FPF_REGS)| save FP general registers
	fmovem	%fpcr,%a2@@(FPF_FPCR)	| save FP control registers
	fmovem	%fpsr,%a2@@(FPF_FPSR)
	fmovem	%fpi,%a2@@(FPF_FPI)
#endif /* M68060 */

Lswnofpsave:
	movl	%sp@@(8), %a0		| newproc

	movl	%a0, CURPROC
	movb	#SONPROC,%a0@@(P_STAT)
	movl	%a0@@(P_ADDR),%a1	| get p_addr
	movl	%a1,_C_LABEL(curpcb)

	/*
	 * Activate process's address space.
	 * XXX Should remember the last USTP value loaded, and call this
	 * XXX only of it has changed.
	 */
	pea	%a0@@			| push proc
	jbsr	_C_LABEL(pmap_activate)	| pmap_activate(p)
	addql	#4,%sp	
	movl	_C_LABEL(curpcb),%a1	| restore p_addr

	lea	_ASM_LABEL(tmpstk),%sp	| now goto a tmp stack for NMI

	moveml	%a1@@(PCB_REGS),#0xFCFC	| and registers
	movl	%a1@@(PCB_USP),%a0
	movl	%a0,%usp		| and USP

#ifdef FPU_EMULATE
	tstl	_C_LABEL(fputype)	| do we _have_ any fpu?
	jne	Lresnonofpatall
	movw	%a1@@(PCB_PS),%sr	| no, restore PS
	rts
Lresnonofpatall:
#endif
	lea	%a1@@(PCB_FPCTX),%a0	| pointer to FP save area
#ifdef M68060
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
	jeq	Lresfp60rest1           | yes, goto Lresfp60rest1
#endif /* M68060 */
	tstb	%a0@@			| null state frame?
	jeq	Lresfprest2		| yes, easy
	fmovem	%a0@@(FPF_FPCR),%fpcr/%fpsr/%fpi	| restore FP control registers
	fmovem	%a0@@(FPF_REGS),%fp0-%fp7	| restore FP general registers
Lresfprest2:
	frestore %a0@@			| restore state
	movw	%a1@@(PCB_PS),%sr	| no, restore PS
	rts

#ifdef M68060
Lresfp60rest1:
	tstb	%a0@@(2)			| null state frame?
	jeq	Lresfp60rest2		| yes, easy
	fmovem	%a0@@(FPF_FPCR),%fpcr	| restore FP control registers
	fmovem	%a0@@(FPF_FPSR),%fpsr
	fmovem	%a0@@(FPF_FPI),%fpi
	fmovem	%a0@@(FPF_REGS),%fp0-%fp7	| restore FP general registers
Lresfp60rest2:
	frestore %a0@@			| restore state
	movw	%a1@@(PCB_PS),%sr	| no, restore PS
	rts
#endif /* M68060 */


/*
 * savectx(pcb)
 * Update pcb, saving current processor state.
 */
ENTRY(savectx)
	movl	%sp@@(4),%a1
	movw	%sr,%a1@@(PCB_PS)
	movl	%usp,%a0		| grab USP
	movl	%a0,%a1@@(PCB_USP)		| and save it
	moveml	#0xFCFC,%a1@@(PCB_REGS)	| save non-scratch registers
#ifdef FPU_EMULATE
	tstl	_C_LABEL(fputype)
	jeq	Lsavedone
#endif
	lea	%a1@@(PCB_FPCTX),%a0	| pointer to FP save area
	fsave	%a0@@			| save FP state
#ifdef M68060
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
	jeq	Lsavctx60               | yes, goto Lsavctx60
#endif
	tstb	%a0@@			| null state frame?
	jeq	Lsavedone		| yes, all done
	fmovem	%fp0-%fp7,%a0@@(FPF_REGS)	| save FP general registers
	fmovem	%fpcr/%fpsr/%fpi,%a0@@(FPF_FPCR)	| save FP control registers
	rts
#ifdef	M68060
Lsavctx60:
	tstb	%a0@@(2)
	jeq	Lsavedone
	fmovem	%fp0-%fp7,%a0@@(FPF_REGS)	| save FP general registers
	fmovem	%fpcr,%a0@@(FPF_FPCR)	| save FP control registers
	fmovem	%fpsr,%a0@@(FPF_FPSR)
	fmovem	%fpi,%a0@@(FPF_FPI)
#endif
Lsavedone:
	rts

#if defined(M68040) || defined(M68060)
ENTRY(suline)
	movl	%sp@@(4),%a0		| address to write
	movl	_C_LABEL(curpcb),%a1	| current pcb
	movl	#Lslerr,%a1@@(PCB_ONFAULT) | where to return to on a fault
	movl	%sp@@(8),%a1		| address of line
	movl	%a1@@+,%d0		| get lword
	movsl	%d0,%a0@@+		| put lword
	nop				| sync
	movl	%a1@@+,%d0		| get lword
	movsl	%d0,%a0@@+		| put lword
	nop				| sync
	movl	%a1@@+,%d0		| get lword
	movsl	%d0,%a0@@+		| put lword
	nop				| sync
	movl	%a1@@+,%d0		| get lword
	movsl	%d0,%a0@@+		| put lword
	nop				| sync
	moveq	#0,%d0			| indicate no fault
	jra	Lsldone
Lslerr:
	moveq	#-1,%d0
Lsldone:
	movl	_C_LABEL(curpcb),%a1	| current pcb
	clrl	%a1@@(PCB_ONFAULT)	| clear fault address
	rts
#endif

/*
 * Invalidate entire TLB.
 */
ASENTRY_NOPROFILE(TBIA)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060?
	jle	Ltbia040                | yes, goto Ltbia040
	pflusha				| flush entire TLB
	tstl	_C_LABEL(mmutype)
	jpl	Lmc68851a		| 68851 implies no d-cache
	movl	#DC_CLEAR,%d0
	movc	%d0,%cacr		| invalidate on-chip d-cache
Lmc68851a:
	rts
	.chip	68040
Ltbia040:
	pflusha
#ifdef M68060
	cmpl	#MMU_68060,_C_LABEL(mmutype) | is 68060?
	jne	Ltbiano60               | no, skip
	movc	%cacr,%d0
	orl	#IC60_CABC,%d0		| and clear all branch cache entries
	movc	%d0,%cacr
#endif
Ltbiano60:
	.chip	68020
	rts


/*
 * Invalidate any TLB entry for given VA (TB Invalidate Single)
 */
ENTRY(TBIS)
	movl	%sp@@(4),%a0		| get addr to flush
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060 ?
	jle	Ltbis040                | yes, goto Ltbis040
	tstl	_C_LABEL(mmutype)
	jpl	Lmc68851b		| is 68851?
	pflush	#0,#0,%a0@@		| flush address from both sides
	movl	#DC_CLEAR,%d0
	movc	%d0,%cacr		| invalidate on-chip data cache
	rts
Lmc68851b:
	pflushs	#0,#0,%a0@@		| flush address from both sides
	rts
	.chip	68040
Ltbis040:
	moveq	#FC_SUPERD,%d0		| select supervisor
	movc	%d0,%dfc
	pflush	%a0@@
	moveq	#FC_USERD,%d0		| select user
	movc	%d0,%dfc
	pflush	%a0@@
#ifdef M68060
	cmpl	#MMU_68060,_C_LABEL(mmutype) | is 68060?
	jne	Ltbisno60               | no, skip
	movc	%cacr,%d0
	orl	#IC60_CABC,%d0		| and clear all branch cache entries
	movc	%d0,%cacr
Ltbisno60:
#endif
	.chip	68020
	rts

/*
 * Invalidate supervisor side of TLB
 */
#if defined(M68060)
	.chip	68040
ENTRY(TBIAS)
	| 68060 cannot specify supervisor/user on pflusha, so we flush all
	pflusha
	movc	%cacr,%d0
	orl	#IC60_CABC,%d0		| and clear all branch cache entries
	movc	%d0,%cacr
	rts
	.chip	68020
#endif

#if defined(M68060)
/*
 * Invalidate user side of TLB
 */
ENTRY(TBIAU)
	cmpl	#MMU_68040,_C_LABEL(mmutype)
	jle	Ltbiau040
	tstl	_C_LABEL(mmutype)
	jpl	Lmc68851d		| 68851?
	pflush	#0,#4			| flush user TLB entries
	movl	#DC_CLEAR,%d0
	movc	%d0,%cacr		| invalidate on-chip d-cache
	rts
Lmc68851d:
	pflushs	#0,#4			| flush user TLB entries
	rts
	.chip	68040
Ltbiau040:
| 68040 cannot specify supervisor/user on pflusha, so we flush all
	pflusha
#ifdef M68060
	cmpl	#MMU_68060,_C_LABEL(mmutype)
	jne	Ltbiauno60
	movc	%cacr,%d0
	orl	#IC60_CUBC,%d0		| but only user branch cache entries
	movc	%d0,%cacr
Ltbiauno60:
#endif
	.chip	68020
	rts
#endif	/* defined(M68060) */

/*
 * Invalidate instruction cache
 */
ENTRY(ICIA)
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060?
	jgt	1f			| no, skip
	.chip	68040
	cinva	%ic
	rts
1:
	.chip	68020
#endif
	movl	#IC_CLEAR,%d0
	movc	%d0,%cacr		| invalidate i-cache
	rts

/*
 * Invalidate data cache.
 *
 * NOTE: we do not flush 68030 on-chip cache as there are no aliasing
 * problems with DC_WA.  The only cases we have to worry about are context
 * switch and TLB changes, both of which are handled "in-line" in resume
 * and TBI*.
 * Because of this, since there is no way on 68040 and 68060 to flush
 * user and supervisor modes specfically, DCIS and DCIU are the same entry
 * point as DCIA.
 */
ENTRY(DCIA)
ENTRY(DCIS)
ENTRY(DCIU)
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060?
	jgt	1f			| no, skip
	.chip	68040
	cpusha	%dc
1:
	.chip	68020
#endif
	rts

#if defined(M68040) || defined(M68060)
	.chip	68040
ENTRY(ICPA)
	cinva	%ic
	rts
ENTRY(DCFA)
	cpusha	%dc
	rts
ENTRY(ICPL)
	movl	%sp@@(4),%a0		| address
	cinvl	%ic,%a0@@
	rts
ENTRY(ICPP)
	movl	%sp@@(4),%a0		| address
	cinvp	%ic,%a0@@
	rts
ENTRY(DCPL)
	movl	%sp@@(4),%a0		| address
	cinvl	%dc,%a0@@
	rts
ENTRY(DCPP)
	movl	%sp@@(4),%a0		| address
	cinvp	%dc,%a0@@
	rts
ENTRY(DCFL)
	movl	%sp@@(4),%a0		| address
	cpushl	%dc,%a0@@
	rts
ENTRY(DCFP)
	movl	%sp@@(4),%a0		| address
	cpushp	%dc,%a0@@
	rts
	.chip	68020
#endif

ENTRY(getsfc)
	movc	%sfc,%d0
	rts

ENTRY(getdfc)
	movc	%dfc,%d0
	rts

/*
 * Load a new user segment table pointer.
 */
ENTRY(loadustp)
	movl	%sp@@(4),%d0		| new USTP
	moveq	#PGSHIFT,%d1
	lsll	%d1,%d0			| convert to addr
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_C_LABEL(mmutype)
#ifdef M68060
	jlt	Lldustp060
#endif
#ifdef M68040
	jeq	Lldustp040
#endif
#endif
	pflusha				| flush entire TLB
	lea	_C_LABEL(protorp),%a0	| CRP prototype
	movl	%d0,%a0@@(4)		| stash USTP
	pmove	%a0@@,%crp		| load root pointer
	movl	#CACHE_CLR,%d0
	movc	%d0,%cacr		| invalidate cache(s)
	rts

	.chip	68040
#ifdef M68060
Lldustp060:
	movc	%cacr,%d1
	orl	#IC60_CUBC,%d1		| clear user branch cache entries
	movc	%d1,%cacr
	/* FALLTHROUGH */
#endif
Lldustp040:
	pflusha
	movc	%d0,%urp
	.chip	68020
	rts

/*
 * Set processor priority level calls.  Most are implemented with
 * inline asm expansions.  However, spl0 requires special handling
 * as we need to check for our emulated software interrupts.
 */

ENTRY(spl0)
	moveq	#0,%d0
	movw	%sr,%d0			| get old SR for return
	movw	#PSL_LOWIPL,%sr		| restore new SR
	tstl	_C_LABEL(softpending)	| software interrupt pending?
	jeq	Lspldone		| no, all done
	subql	#4,%sp			| make room for RTE frame
	movl	%sp@@(4),%sp@@(2)		| position return address
	clrw	%sp@@(6)			| set frame type 0
	movw	#PSL_LOWIPL,%sp@@	| and new SR
	jra	Lgotsir			| go handle it
Lspldone:
	rts

/*
 * Save and restore 68881 state.
 * Pretty awful looking since our assembler does not
 * recognize FP mnemonics.
 */
ENTRY(m68881_save)
	movl	%sp@@(4),%a0		| save area pointer
	fsave	%a0@@			| save state
#ifdef M68060
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
	jeq	Lm68060fpsave		| yes, goto Lm68060fpsave
#endif
	tstb	%a0@@			| null state frame?
	jeq	Lm68881sdone		| yes, all done
	fmovem	%fp0-%fp7,%a0@@(FPF_REGS)	| save FP general registers
	fmovem	%fpcr/%fpsr/%fpi,%a0@@(FPF_FPCR)	| save FP control registers
Lm68881sdone:
	rts

#ifdef M68060
Lm68060fpsave:
	tstb	%a0@@(2)			| null state frame?
	jeq	Lm68060sdone		| yes, all done
	fmovem	%fp0-%fp7,%a0@@(FPF_REGS)| save FP general registers
	fmovem	%fpcr,%a0@@(FPF_FPCR)	| save FP control registers
	fmovem	%fpsr,%a0@@(FPF_FPSR)
	fmovem	%fpi,%a0@@(FPF_FPI)
Lm68060sdone:
	rts
#endif

ENTRY(m68881_restore)
	movl	%sp@@(4),%a0		| save area pointer
#ifdef M68060
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
	jeq	Lm68060fprestore	| yes, goto Lm68060fprestore
#endif
	tstb	%a0@@			| null state frame?
	jeq	Lm68881rdone		| yes, easy
	fmovem	%a0@@(FPF_FPCR),%fpcr/%fpsr/%fpi	| restore FP control registers
	fmovem	%a0@@(FPF_REGS),%fp0-%fp7	| restore FP general registers
Lm68881rdone:
	frestore %a0@@			| restore state
	rts

#ifdef M68060
Lm68060fprestore:
	tstb	%a0@@(2)			| null state frame?
	jeq	Lm68060fprdone		| yes, easy
	fmovem	%a0@@(FPF_FPCR),%fpcr	| restore FP control registers
	fmovem	%a0@@(FPF_FPSR),%fpsr
	fmovem	%a0@@(FPF_FPI),%fpi
	fmovem	%a0@@(FPF_REGS),%fp0-%fp7| restore FP general registers
Lm68060fprdone:
	frestore %a0@@			| restore state
	rts
#endif

/*
 * Handle the nitty-gritty of rebooting the machine.
 * Basically we just turn off the MMU and jump to the appropriate ROM routine.
 * XXX add support for rebooting -- that means looking at boothowto and doing
 * the right thing
 */
ENTRY_NOPROFILE(doboot)
	lea	_ASM_LABEL(tmpstk),%sp	| physical SP in case of NMI
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jgt	Lbootnot040		| no, skip
	.chip	68040
	movl	#0,%d0
	movc	%d0,%cacr		| caches off
	movc	%d0,%tc			| turn off MMU
	bra	1f
	.chip	68020
Lbootnot040:
#endif
	movl	#CACHE_OFF,%d0
	movc	%d0,%cacr		| disable on-chip cache(s)
	movl	#0,%a7@@			| value for pmove to TC (turn off MMU)
	pmove	%a7@@,%tc		| disable MMU

1:	movl	#0,%d0
	movc	%d0,%vbr		| ROM VBR

	/*
	 * We're going down. Make various sick attempts to reset the board.
	 */
	RELOC(cputyp, %a0)
	movl	%a0@@,%d0
	cmpw	#CPU_147,%d0
	bne	not147
	movl	#0xfffe2000,%a0		| MVME147: "struct vme1reg *"
vmechipreset:
	movw	%a0@@,%d0
	movl	%d0,%d1
	andw	#0x0001,%d1		| is VME1_SCON_SWITCH set?
	beq	1f			| not SCON. may not use SRESET.
	orw	#0x0002,%d0		| ok, assert VME1_SCON_SRESET
	movw	%d0,%a0@@
1:
	movl	#0xff800000,%a0		| if we get here, SRESET did not work.
	movl	%a0@@(4),%a0		| try jumping directly to the ROM.
	jsr	%a0@@
	| still alive! just return to the prom..
	bra	3f

not147:
	cmpw	#CPU_165, %d0
	bne	not165
	movl	#0xfff90020,%a0		| disable timer2 (clock)
	movl	#0, %a0@@
	movl	#0xfffb0000,%a0		| MVME165 VMEChip base address
	/* similar to MVME147 sequence above */
	bra	vmechipreset

not165:
	cmpw	#CPU_141, %d0
	bne	not141
	movl	#0xfffb0000,%a0		| MVME141 VMEChip base address
	/* similar to MVME147 sequence above */
	bra	vmechipreset

not141:
	movl	#0xfff40000,%a0		| MVME16x: "struct vme2reg *"
	movl	%a0@@(0x60),%d0
	movl	%d0,%d1
	andl	#0x40000000,%d1		| is VME2_TCTL_SCON set?
	beq	1f			| not SCON. may not use SRESET.
	orl	#0x00800000,%d0		| ok, assert VME2_TCTL_SRST
	movl	%d0,%a0@@(0x60)
1:
	| lets try the local bus reset
	movl	#0xfff40000,%a0		| MVME16x: "struct vme2reg *"
	movl	%a0@@(0x104),%d0
	orw	#0x00000080,%d0
	movl	%d0,%a0@@(0x104)
	| lets try jumping off to rom.
	movl	#0xff800000,%a0		| if we get here, SRESET did not work.
	movl	%a0@@(4),%a0		| try jumping directly to the ROM.
	jsr	%a0@@
	| still alive! just return to the prom..

3:	BUGCALL(MVMEPROM_EXIT)		| return to m68kbug
	/*NOTREACHED*/

#if defined(M68060) && defined(M060SP)
GLOBAL(intemu60)
	jra	_C_LABEL(I_CALL_TOP)+0x80+0x00
GLOBAL(fpiemu60)
	jra	_C_LABEL(FP_CALL_TOP)+0x80+0x30
GLOBAL(fpdemu60)
	jra	_C_LABEL(FP_CALL_TOP)+0x80+0x38
GLOBAL(fpeaemu60)
	jra	_C_LABEL(FP_CALL_TOP)+0x80+0x40
#endif

	.data
	.p2align 2
GLOBAL(mmutype)
	.long	MMU_68030	| default to MMU_68030
GLOBAL(cputype)
	.long	CPU_68030	| default to CPU_68030
GLOBAL(fputype)
	.long	FPU_68881	| default to 68881 FPU
GLOBAL(protorp)
	.long	0,0		| prototype root pointer
GLOBAL(cold)
	.long	1		| cold start flag
GLOBAL(proc0paddr)
	.long	0		| KVA of proc0 u-area
GLOBAL(intiobase)
	.long	0		| KVA of base of internal IO space
GLOBAL(intiolimit)
	.long	0		| KVA of end of internal IO space
GLOBAL(extiobase)
	.long	0		| KVA of base of external IO space

#include <mvme68k/mvme68k/vectors.s>
@


1.63
log
@mvme68k ELF bits. Boot block updates heavily based upon the recent mvme88k
a.out->ELF transition.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.62 2010/06/29 20:30:32 guenther Exp $ */
@


1.62
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.61 2009/03/15 20:40:25 miod Exp $ */
d110 1
d120 7
a126 7
	movw	#PSL_HIGHIPL,sr		| no interrupts
	movl	sp@@(4), d7		| get boothowto
	movl	sp@@(8), d6		| get bootaddr
	movl	sp@@(12),d5		| get bootctrllun
	movl	sp@@(16),d4		| get bootdevlun
	movl	sp@@(20),d3		| get bootpart
	movl	sp@@(24),d2		| get esyms
d129 2
a130 2
	ASRELOC(tmpstk, a0)
	movl	a0,sp			| give ourselves a temporary stack
d132 12
a143 12
	RELOC(edata, a0)		| clear out BSS
	movl	#_C_LABEL(end)-4,d0	| (must be <= 256 kB)
	subl	#_C_LABEL(edata),d0
	lsrl	#2,d0
1:	clrl	a0@@+
	dbra	d0,1b

	movc	vbr,d0			| save prom's trap #15 vector
	RELOC(promvbr, a0)
	movl	d0, a0@@
	RELOC(esym, a0)
	movl	d2,a0@@			| store end of symbol table
d146 1
a146 1
	clrl	sp@@-
d148 1
a148 1
	movl	sp@@+, a1
d150 4
a153 4
	movl	#SIZEOF_MVMEPROM_BRDID, d0	| copy to local variables
	RELOC(brdid, a0)
1:	movb	a1@@+, a0@@+
	subql	#1, d0
d156 5
a160 5
	clrl	d0
	RELOC(brdid, a1)
	movw	a1@@(MVMEPROM_BRDID_MODEL), d0
	RELOC(cputyp, a0)
	movl	d0, a0@@			| init _cputyp
d163 1
a163 1
	cmpw	#CPU_141, d0
d168 1
a168 1
	cmpw	#CPU_147, d0
d173 1
a173 1
	cmpw	#CPU_162, d0
d178 1
a178 1
	cmpw	#CPU_165, d0
d183 1
a183 1
	cmpw	#CPU_166, d0
d185 1
a185 1
	cmpw	#CPU_167, d0
d190 1
a190 1
        cmpw	#CPU_176, d0
d192 1
a192 1
        cmpw	#CPU_177, d0
d197 1
a197 1
	cmpw	#CPU_172, d0
d208 2
a209 2
	movl	#notsupend, sp@@-
	movl	#notsup, sp@@-
d211 1
a211 1
	addql	#8,sp
d216 2
d220 2
a221 2
	RELOC(mmutype, a0)		| no, we have 68030
	movl	#MMU_68030,a0@@		| set to reflect 68030 PMMU
d223 2
a224 2
	RELOC(cputype, a0)		| no, we have 68030
	movl	#CPU_68030,a0@@		| set to reflect 68030 CPU
d226 2
a227 2
	RELOC(clockbus, a0)		| timer is on ofobio
	movl	#BUS_OFOBIO, a0@@
d229 11
a239 11
	movl	#CACHE_OFF,d0
	movc	d0,cacr			| clear and disable on-chip cache(s)

	ASRELOC(memsize141, a1)		| how much memory?
	jbsr	a1@@
	movl	d0, d1

	RELOC(iiomapsize, a1)
	movl	#INTIOSIZE_141, a1@@
	RELOC(iiomapbase, a1)
	movl	#INTIOBASE_141, a1@@
d245 2
a246 2
	RELOC(mmutype, a0)		| no, we have 68030
	movl	#MMU_68030,a0@@		| set to reflect 68030 PMMU
d248 2
a249 2
	RELOC(cputype, a0)		| no, we have 68030
	movl	#CPU_68030,a0@@		| set to reflect 68030 CPU
d251 2
a252 2
	RELOC(clockbus, a0)		| timer is on pcc
	movl	#BUS_PCC, a0@@
d254 2
a255 2
	movl	#CACHE_OFF,d0
	movc	d0,cacr			| clear and disable on-chip cache(s)
d261 1
a261 1
	movl	#0xfffe0000, a0		| mvme147 nvram base
d263 9
a271 9
	RELOC(myea, a1)
	movw	a0@@(NVRAM_147_ETHER+0), a1@@(3+0)
	movb	a0@@(NVRAM_147_ETHER+2), a1@@(3+2)
	movl	a0@@(NVRAM_147_EMEM), d1	| pass memory size

	RELOC(iiomapsize, a1)
	movl	#INTIOSIZE_147, a1@@
	RELOC(iiomapbase, a1)
	movl	#INTIOBASE_147, a1@@
d275 2
d289 3
a291 3
	RELOC(memsize162, a1)		| how much memory?
	jbsr	a1@@
	movl	d0, d2
d293 2
a294 2
	RELOC(mmutype, a0)
	movl	#MMU_68040,a0@@		| with a 68040 MMU
d296 2
a297 2
	RELOC(cputype, a0)		| no, we have 68040
	movl	#CPU_68040,a0@@		| set to reflect 68040 CPU
d299 2
a300 2
	RELOC(fputype, a0)
	movl	#FPU_68040,a0@@		| and a 68040 FPU
d302 2
a303 2
	RELOC(clockbus, a0)		| timer is on mc
	movl	#BUS_MC, a0@@
d305 3
a307 3
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr40),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)
d314 4
a317 4
	movl	#0xfffe0000, a0		| MVME165 CSR
	movl	a0@@, d0
	movl	#4*1024*1024, d1
	btst	#18, d0			| 4MEG*
d319 1
a319 1
	movl	#16*1024*1024, d1	| set, this is a 16MB board.
d321 2
a322 2
	RELOC(mmutype, a0)
	movl	#MMU_68040,a0@@		| with a 68040 MMU
d324 2
a325 2
	RELOC(cputype, a0)		| no, we have 68040
	movl	#CPU_68040,a0@@		| set to reflect 68040 CPU
d327 2
a328 2
	RELOC(fputype, a0)
	movl	#FPU_68040,a0@@		| and a 68040 FPU
d330 2
a331 2
	RELOC(clockbus, a0)		| timer is on lrc
	movl	#BUS_LRC, a0@@
d333 3
a335 3
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr40),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)
d337 4
a340 4
	RELOC(iiomapsize, a1)
	movl	#INTIOSIZE_165, a1@@
	RELOC(iiomapbase, a1)
	movl	#INTIOBASE_165, a1@@
d347 2
a348 2
	RELOC(memsize1x7, a1)		| how much memory?
	jbsr	a1@@
d350 2
a351 2
	RELOC(mmutype, a0)
	movl	#MMU_68040,a0@@		| with a 68040 MMU
d353 2
a354 2
	RELOC(cputype, a0)		| no, we have 68040
	movl	#CPU_68040,a0@@		| set to reflect 68040 CPU
d356 2
a357 2
	RELOC(fputype, a0)
	movl	#FPU_68040,a0@@		| and a 68040 FPU
d359 2
a360 2
	RELOC(clockbus, a0)		| timer is on pcctwo
	movl	#BUS_PCCTWO, a0@@
d362 3
a364 3
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr40),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)
d369 2
d374 3
a376 3
	RELOC(memsize162, a1)		| how much memory?
	jbsr	a1@@
	movl	d0, d2
d379 3
a381 3
	.word	0x4e7a,0x0808		| movc	pcr,d0
	bset   #0,d0                    | turn on bit 0.
	.word	0x4e7b,0x0808		| movc	d0,pcr  Bang!
d383 2
a384 2
	RELOC(mmutype, a0)
	movl	#MMU_68060,a0@@		| with a 68060 MMU
d386 2
a387 2
	RELOC(cputype, a0)		| no, we have 68060
	movl	#CPU_68060,a0@@		| set to reflect 68060 CPU
d389 2
a390 2
	RELOC(fputype, a0)
	movl	#FPU_68060,a0@@		| and a 68060 FPU
d392 2
a393 2
	RELOC(clockbus, a0)		| timer is on mc
	movl	#BUS_MC, a0@@
d395 3
a397 3
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr60),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)
d404 2
a405 2
	RELOC(memsize1x7, a1)		| how much memory?
	jbsr	a1@@
d408 3
a410 3
	.word	0x4e7a,0x0808		| movc	pcr,d0
	bset   #0,d0                    | turn on bit 0.
	.word	0x4e7b,0x0808		| movc	d0,pcr  Bang!  We are smokin' !
d412 2
a413 2
	RELOC(mmutype, a0)
	movl	#MMU_68060,a0@@		| with a 68060 MMU
d415 2
a416 2
	RELOC(cputype, a0)		| no, we have 68060
	movl	#CPU_68060,a0@@		| set to reflect 68060 CPU
d418 2
a419 2
	RELOC(fputype, a0)
	movl	#FPU_68060,a0@@		| and a 68060 FPU
d421 2
a422 2
	RELOC(clockbus, a0)		| timer is on pcctwo
	movl	#BUS_PCCTWO, a0@@
d424 3
a426 3
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr60),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)
d431 2
d439 4
a442 4
	RELOC(iiomapsize, a1)
	movl	#INTIOSIZE_162, a1@@
	RELOC(iiomapbase, a1)
	movl	#INTIOBASE_162, a1@@
d445 7
a451 7
	RELOC(rompkt, a0)		| build a .NETCTRL packet
	movb	#0, a0@@(NETCTRL_DEV)	| onboard ethernet
	movb	#0, a0@@(NETCTRL_CTRL)	| onboard ethernet
	movl	#NETCTRLCMD_GETETHER, a0@@(NETCTRL_CMD)
	RELOC(myea, a1)
	movl	a1, a0@@(NETCTRL_ADDR)	| where to put it
	movl	#6, a0@@(NETCTRL_LEN)	| it is 6 bytes long
d453 1
a453 1
	movl	a0, sp@@-
d455 1
a455 1
	addl	#4, sp
d459 2
a460 2
	movl	d2, d1
	cmpl	#0, d1
d463 2
a464 2
	movl	#unkmemend, sp@@-
	movl	#unkmem, sp@@-
d466 1
a466 1
	addql	#8,sp
d468 1
a468 1
	movl	#4*1024*1024, d1	| XXX assume 4M of ram
d481 7
a487 7
	moveq	#FC_USERD,d0		| user space
	movc	d0,sfc			|   as source
	movc	d0,dfc			|   and destination of transfers
        moveq	#PGSHIFT,d2
	lsrl	d2,d1			| convert to pages
	RELOC(physmem, a0)
	movl	d1,a0@@			| save as physmem
d491 2
a492 2
	RELOC(esym,a0)			| end of static kernel text/data/syms
	movl	a0@@,d2
d495 1
a495 1
	movl	#_C_LABEL(end),d2	| end of static kernel text/data
d497 3
a499 3
	addl	#NBPG-1,d2
	andl	#PG_FRAME,d2		| round to a page
	movl	d2,a4
d502 5
a506 5
	clrl	sp@@-			| firstpa
	pea	a4@@			| nextpa
	RELOC(pmap_bootstrap,a0)
	jbsr	a0@@			| pmap_bootstrap(firstpa, nextpa)
	addql	#8,sp
d515 2
a516 2
	RELOC(mmutype, a0)
	cmpl	#MMU_68040,a0@@
d518 3
a520 3
	RELOC(copypage040, a0)
	RELOC(copypage, a1)
	movl	a1, a2
d522 2
a523 2
	movw	a0@@+, a2@@+
	cmpl	a0, a1
d532 4
a535 4
	RELOC(Sysseg, a0)		| system segment table addr
	movl	a0@@,d1			| read value (a KVA)
	RELOC(mmutype, a0)
	cmpl	#MMU_68040,a0@@		| 68040 or 68060?
d537 3
a539 2
	.long	0x4e7b1807		| movc d1,srp
	.long	0x4e7b1806		| movc d1,urp
d541 1
d543 5
a547 5
	RELOC(protorp, a0)
	movl	#0x80000202,a0@@		| nolimit + share global + 4 byte PTEs
	movl	d1,a0@@(4)		| + segtable address
	pmove	a0@@,srp			| load the supervisor root pointer
	movl	#0x80000002,a0@@		| reinit upper half for CRP loads
d549 2
a550 2
	RELOC(mmutype, a0)
	cmpl	#MMU_68040,a0@@		| 68040 or 68060?
d553 10
a562 10
	moveq	#0,d0			| ensure TT regs are disabled
	.long	0x4e7b0004		| movc d0,itt0
	.long	0x4e7b0005		| movc d0,itt1
	.long	0x4e7b0006		| movc d0,dtt0
	.long	0x4e7b0007		| movc d0,dtt1

	.word	0xf4d8			| cinva bc
	.word	0xf518			| pflusha
        movl	#0x8000,d0
	.long	0x4e7b0003		| movc d0,tc
d564 2
a565 2
	RELOC(mmutype, a0)
	cmpl	#MMU_68060,a0@@		| 68060?
d567 2
a568 2
        movl	#CACHE60_ON,d0          | branch cache, etc...
	movc	d0,cacr			| turn on both caches
d571 2
a572 2
        movl	#CACHE40_ON,d0
	movc	d0,cacr			| turn on both caches
d574 1
d576 2
a577 2
	movl	#0x82c0aa00,a2@@		| value to load TC with
	pmove	a2@@,tc			| load it
d584 1
a584 1
	lea	_ASM_LABEL(tmpstk),sp	| temporary stack
d587 7
a593 7
	movl	_C_LABEL(proc0paddr),a1	| get proc0 pcb addr
	lea	a1@@(USPACE-4),sp	| set kernel stack to end of area
	lea	_C_LABEL(proc0), a2	| initialize proc0.p_addr so that
	movl	a1,a2@@(P_ADDR)		|  we don't deref NULL in trap()
	movl	#USRSTACK-4,a2
	movl	a2,usp			| init user SP
	movl	a1,_C_LABEL(curpcb)	| proc0 is running
d597 2
a598 2
	clrl	a1@@(PCB_FPCTX)		| ensure null FP context
	movl	a1,sp@@-
d600 1
a600 1
	addql	#4,sp
d606 2
a607 2
	movl	#CACHE_ON,d0
	movc	d0,cacr			| clear cache(s)
d610 8
a617 8
	movl	#_vectab,d2		| set VBR
	movc	d2,vbr
	movw	#PSL_LOWIPL,sr		| lower SPL
	movl	d3, _C_LABEL(bootpart)	| save bootpart
	movl	d4, _C_LABEL(bootdevlun) | save bootdevlun
	movl	d5, _C_LABEL(bootctrllun) | save bootctrllun
	movl	d6, _C_LABEL(bootaddr)	| save bootaddr
	movl	d7, _C_LABEL(boothowto)	| save boothowto
d628 7
a634 7
	clrw	sp@@-			| vector offset/frame type
	clrl	sp@@-			| PC - filled in by "execve"
	movw	#PSL_USER,sp@@-		| in user mode
	clrl	sp@@-			| stack adjust count and padding
	lea	sp@@(-64),sp		| construct space for D0-D7/A0-A7
	lea	_C_LABEL(proc0),a0	| save pointer to frame
	movl	sp,a0@@(P_MD_REGS)	|   in proc0.p_md.md_regs
d647 1
a647 1
	movl	#0xfff43008,a0		| MEMC040/MEMECC Controller #1
d649 1
a649 1
	movl	d0,d2
d651 1
a651 1
	movl	#0xfff43108,a0		| MEMC040/MEMECC Controller #2
d653 1
a653 1
	addl	d0,d2
d663 12
a674 12
	moveml	d1-d2/a1-a2,sp@@-	| save scratch regs
	movc	vbr,d2			| Save vbr
	RELOC(vectab,a2)		| Install our own vectab, temporarily
	movc	a2,vbr
	ASRELOC(Lmemc040berr,a1)	| get address of bus error handler
	movl	a2@@(8),sp@@-		| Save current bus error handler addr
	movl	a1,a2@@(8)		| Install our own handler
	movl	sp,d0			| Save current stack pointer value
	movql	#0x07,d1
	andb	a0@@,d1			| Access MEMC040/MEMECC
	movl	#0x400000,d0
	lsll	d1,d0			| Convert to memory size, in bytes
d676 3
a678 3
	movc	d2,vbr			| Restore original vbr
	movl	sp@@+,a2@@(8)		| Restore original bus error handler
	moveml	sp@@+,d1-d2/a1-a2
d686 2
a687 2
	movl	d0,sp			| Get rid of the exception frame
	clrl	d0			| No ASIC at this location, then!
d694 12
a705 12
	moveml	d1-d3/a0-a2,sp@@-	| save working registers
	movc	vbr,d2			| save vbr
	RELOC(vectab,a2)
	movc	a2,vbr			| install our own vectab
	ASRELOC(Lmem141sizeerr,a1)
	movl	a2@@(8),sp@@-		| save bus error and
	movl	a2@@(12),sp@@-		| address error vectors
	movl	a1,a2@@(8)		| and put ours in place
	movl	a1,a2@@(12)
	movl	sp,d3			| save stack
	movql	#0,d0
	movl	d0,a0			| starting test address
d707 6
a712 6
	movb	a0@@,d0			| try byte, word and long access
	movw	a0@@,d0
	movl	a0@@,d0
	movl	d0,d1
	movl	a0@@,d0			| read it again
	cmp	d0,d1			| and compare
d714 2
a715 2
	movel	#(1024 * 1024),d0
	addl	d0,a0
d718 5
a722 5
	movl	a0,d0			| d0 = size in bytes
	movc	d2,vbr			| restore vbr
	movl	sp@@+,a2@@(12)		| and vectors
	movl	sp@@+,a2@@(8)
	moveml	sp@@+,d1-d3/a0-a2
d725 1
a725 1
	movl	d3,sp			| get rid of the exception frame
d734 7
a740 7
	movl	a3,sp@@-			| push function arg
	jbsr	a2@@			| call function
	addql	#4,sp			| pop arg
	movl	sp@@(FR_SP),a0		| grab and load
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most user regs
	addql	#8,sp			| toss SP and stack adjust
d751 7
a757 7
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	sp@@(FR_HW+8),sp@@-
	clrl	sp@@-			| dummy code
	movl	#T_ADDRERR,sp@@-		| mark address error
d763 6
a768 6
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movel	sp@@(FR_HW+12),d0	| FSLW
	btst	#2,d0			| branch prediction error?
d770 5
a774 5
	movc	cacr,d2
	orl	#IC60_CABC,d2		| clear all branch cache entries
	movc	d2,cacr
	movl	d0,d1
	andl	#0x7ffd,d1
d778 2
a779 2
	movl	sp@@(FR_HW+8),d1		| grab VA
	btst	#27,d0			| check for mis-aligned access
d781 1
a781 1
	addl	#28,d1			| yes, get into next page
d784 1
a784 1
	andl	#PG_FRAME,d1            | and truncate
d786 3
a788 3
	movl	d1,sp@@-
	movl	d0,sp@@-			| code is FSLW now.
	andw	#0x1f80,d0 
d790 1
a790 1
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
d795 1
a795 1
	movl	_C_LABEL(nofault),sp@@-	| yes,
d800 8
a807 8
        clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	sp@@(FR_HW+20),d1	| get fault address
	moveq	#0,d0
	movw	sp@@(FR_HW+12),d0	| get SSW
	btst	#11,d0			| check for mis-aligned
d809 2
a810 2
	addl	#3,d1			| get into next page
	andl	#PG_FRAME,d1		| and truncate
d812 3
a814 3
	movl	d1,sp@@-			| pass fault address.
	movl	d0,sp@@-			| pass SSW as code
	btst	#10,d0			| test ATC
d816 1
a816 1
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
d821 1
a821 1
	movl	_C_LABEL(nofault),sp@@-	| yes,
d827 8
a834 8
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	lea	sp@@(FR_HW),a1		| grab base of HW berr frame
	moveq	#0,d0
	movw	a1@@(10),d0		| grab SSW for fault processing
	btst	#12,d0			| RB set?
d836 2
a837 2
	bset	#14,d0			| yes, must set FB
	movw	d0,a1@@(10)		| for hardware too
d839 1
a839 1
	btst	#13,d0			| RC set?
d841 2
a842 2
	bset	#15,d0			| yes, must set FC
	movw	d0,a1@@(10)		| for hardware too
d844 1
a844 1
	btst	#8,d0			| data fault?
d846 1
a846 1
	movl	a1@@(16),d1		| fault address is as given in frame
d849 1
a849 1
	btst	#4,a1@@(6)		| long (type B) stack frame?
d851 2
a852 2
	movl	a1@@(2),d1		| no, can use save PC
	btst	#14,d0			| FB set?
d854 1
a854 1
	addql	#4,d1			| yes, adjust address
d857 1
a857 1
	btst	#15,d0			| FC set?
d859 1
a859 1
	addql	#2,d1			| yes, adjust address
d862 2
a863 2
	movl	a1@@(36),d1		| long format, use stage B address
	btst	#15,d0			| FC set?
d865 1
a865 1
	subql	#2,d1			| yes, adjust address
d867 5
a871 5
	movl	d1,sp@@-			| push fault VA
	movl	d0,sp@@-			| and padded SSW
	movw	a1@@(6),d0		| get frame format/vector offset
	andw	#0x0FFF,d0		| clear out frame format
	cmpw	#12,d0			| address error vector?
d873 3
a875 3
	movl	d1,a0			| fault address
	movl	sp@@,d0			| function code from ssw
	btst	#8,d0			| data fault?
d877 1
a877 1
	movql	#1,d0			| user program access FC
d879 1
a879 1
	btst	#5,a1@@			| supervisor mode?
d881 1
a881 1
	movql	#5,d0			| else supervisor program access
d883 4
a886 4
	ptestr	d0,a0@@,#7		| do a table search
	pmove	psr,sp@@			| save result
	movb	sp@@,d1
	btst	#2,d1			| invalid (incl. limit viol. and berr)?
d888 1
a888 1
	btst	#7,d1			| is it MMU table berr?
d892 1
a892 1
	btst	#3,d1			| write protect bit set?
d894 3
a896 3
	movl	sp@@,d0			| ssw into low word of d0
	andw	#0xc0,d0		| Write protect is set on page:
	cmpw	#0x40,d0		| was it read cycle?
d899 1
a899 1
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
d902 1
a902 1
	movl	#T_ADDRERR,sp@@-		| mark address error
d905 1
a905 1
	clrw	sp@@			| re-clear pad word
d908 1
a908 1
	movl	_C_LABEL(nofault),sp@@-	| yes,
d912 1
a912 1
	movl	#T_BUSERR,sp@@-		| mark bus error
d922 1
a922 1
	cmpw	#0x202c,sp@@(6)		| format type 2?
d931 3
a933 3
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save registers
	moveq	#T_FPEMULI,d0		| denote as FP emulation trap
d949 3
a951 3
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save registers
	moveq	#T_FPEMULD,d0		| denote as FP emulation trap
d964 8
a971 8
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-	| save user registers
	movl	usp,a0		| and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	movl	_C_LABEL(curpcb),a0 | current pcb
	lea	a0@@(PCB_FPCTX),a0 | address of FP savearea
	fsave	a0@@		| save state
d977 1
a977 1
	tstb	a0@@		| null state frame?
d979 3
a981 3
	clrw	d0		| no, need to tweak BIU
	movb	a0@@(1),d0	| get frame size
	bset	#3,a0@@(0,d0:w)	| set exc_pend bit of BIU
d983 3
a985 3
	fmovem	fpsr,sp@@-	| push fpsr as code argument
	frestore a0@@		| restore state
	movl	#T_FPERR,sp@@-	| push type arg
d993 6
a998 6
	moveml	#0xC0C0,sp@@-		| save scratch regs
	lea	sp@@(16),a1		| get pointer to frame
	movl	a1,sp@@-
	movw	sp@@(26),d0
	movl	d0,sp@@-			| push exception vector info
	movl	sp@@(26),sp@@-		| and PC
d1000 2
a1001 2
	lea	sp@@(12),sp		| pop args
	moveml	sp@@+,#0x0303		| restore regs
d1005 4
a1008 4
	moveml	#0xC0C0,sp@@-		| save scratch regs
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
	movl	sp@@(22),sp@@-		| and PC
d1010 2
a1011 2
	addql	#8,sp			| pop args
	moveml	sp@@+,#0x0303		| restore regs
d1015 5
a1019 5
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	d0,sp@@-			| push syscall number
d1021 1
a1021 1
	addql	#4,sp			| pop syscall arg
d1026 1
a1026 1
	movw	#SPL1,sr
d1030 4
a1033 4
	movl	sp@@(FR_SP),a0		| grab and restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most registers
	addql	#8,sp			| pop SP and stack adjust
d1054 4
a1057 4
	movl	d1,sp@@-			| push length
	movl	a1,sp@@-			| push addr
	movl	d0,sp@@-			| push command
	movl	CURPROC,sp@@-		| push proc pointer
d1059 1
a1059 1
	lea	sp@@(16),sp		| pop args
d1067 3
a1069 3
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRACE,d0
d1077 3
a1079 3
	movw	sp@@(FR_HW),d1		| get SSW
	notw	d1			| XXX no support for T0 on 680[234]0
	andw	#PSL_S,d1		| from system mode (T=1, S=1)?
d1092 2
a1093 2
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-
d1097 2
a1098 2
	moveml	sp@@+,#0xFFFF
	addql	#4, sp
d1102 9
a1110 9
	subql	#4,sp
	link	a6,#0
	moveml	#0xFFFE,sp@@-
	movl	_C_LABEL(promvbr),a0
	movw	a6@@(14),d0
	andl	#0xfff,d0
	movl	a0@@(d0:w),a6@@(4)
	moveml	sp@@+,#0x7FFF
	unlk	a6
d1114 3
a1116 3
	moveq	#T_TRAP15,d0
	movw	sp@@(FR_HW),d1		| get PSW
	andw	#PSL_S,d1		| from system mode?
d1122 3
a1124 3
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	lea	sp@@(FR_SIZE),a6		| Save stack pointer
	movl	a6,sp@@(FR_SP)		|   from before trap
d1128 2
a1129 2
	movl	a6,d1
	cmpl	#_ASM_LABEL(tmpstk),d1
d1132 4
a1135 4
	movl	sp,a0			| a0=src
	lea	_ASM_LABEL(tmpstk)-96,a1 | a1=dst
	movl	a1,sp			| sp=new frame
	moveq	#FR_SIZE,d1
d1137 2
a1138 2
	movl	a0@@+,a1@@+
	subql	#4,d1
d1149 2
a1150 2
	movl	d0,d2			| trap type
	movl	sp,a2			| frame ptr
d1153 2
a1154 2
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
d1156 2
a1157 2
	addql	#8,sp			| pop args
	cmpl	#0,d0			| did kgdb handle it?
d1162 2
a1163 2
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
d1165 2
a1166 2
	addql	#8,sp			| pop args
	cmpl	#0,d0			| did ddb handle it?
d1177 7
a1183 7
	movl	sp@@(FR_SP),a0		| modified sp
	lea	sp@@(FR_SIZE),a1		| end of our frame
	movl	a1@@-,a0@@-		| copy 2 longs with
	movl	a1@@-,a0@@-		| ... predecrement
	movl	a0,sp@@(FR_SP)		| sp = h/w frame
	moveml	sp@@+,#0x7FFF		| restore all but sp
	movl	sp@@,sp			| ... and sp
d1218 1
a1218 1
	btst	#5,sp@@			| yes, are we returning to user mode?
d1220 5
a1224 5
	movw	#PSL_LOWIPL,sr		| lower SPL
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
d1226 3
a1228 3
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_ASTFLT,sp@@-		| type == async system trap
d1230 4
a1233 4
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
d1235 2
a1236 2
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SP and stack adjust
d1239 9
a1247 9
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
d1252 3
a1254 3
	movl	d0,sp@@-			| need a scratch register
	movw	sp@@(4),d0		| get SR
	andw	#PSL_IPL7,d0		| mask all but IPL
d1256 1
a1256 1
	movl	sp@@+,d0			| restore scratch register
d1258 1
a1258 1
	movw	#SPL1,sr		| prevent others from servicing int
d1261 4
a1264 4
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
d1266 3
a1268 3
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_SSIR,sp@@-		| type == software interrupt
d1270 5
a1274 5
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| and all remaining registers
	addql	#8,sp			| pop SP and stack adjust
d1277 1
a1277 1
	movl	sp@@+,d0			| restore scratch register
d1313 1
a1313 1
	movl	sp@@(4), d0		| oldproc
d1319 5
a1323 5
        movl	_C_LABEL(curpcb),a1
	movw	sr, a1@@(PCB_PS)		| save sr before switching context
	moveml	#0xFCFC,a1@@(PCB_REGS)	| save non-scratch registers
	movl	usp,a2			| grab USP (a2 has been saved)
	movl	a2,a1@@(PCB_USP)		| and save it
d1328 2
a1329 2
	lea	a1@@(PCB_FPCTX),a2	| pointer to FP save area
	fsave	a2@@			| save FP state
d1334 1
a1334 1
	tstb	a2@@			| null state frame?
d1336 2
a1337 2
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(FPF_FPCR)	| save FP control registers
d1341 1
a1341 1
	tstb	a2@@(2)			| null state frame?
d1343 4
a1346 4
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a2@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a2@@(FPF_FPSR)
	fmovem	fpi,a2@@(FPF_FPI)
d1350 1
a1350 1
	movl	sp@@(8), a0		| newproc
d1352 4
a1355 4
	movl	a0, CURPROC
	movb	#SONPROC,a0@@(P_STAT)
	movl	a0@@(P_ADDR),a1		| get p_addr
	movl	a1,_C_LABEL(curpcb)
d1362 1
a1362 1
	pea	a0@@			| push proc
d1364 2
a1365 2
	addql	#4,sp	
	movl	_C_LABEL(curpcb),a1	| restore p_addr
d1367 1
a1367 1
	lea	_ASM_LABEL(tmpstk),sp	| now goto a tmp stack for NMI
d1369 3
a1371 3
	moveml	a1@@(PCB_REGS),#0xFCFC	| and registers
	movl	a1@@(PCB_USP),a0
	movl	a0,usp			| and USP
d1376 1
a1376 2
	movw	a1@@(PCB_PS),sr		| no, restore PS
	moveq	#1,d0			| return 1 (for alternate returns)
d1380 1
a1380 1
	lea	a1@@(PCB_FPCTX),a0	| pointer to FP save area
d1385 1
a1385 1
	tstb	a0@@			| null state frame?
d1387 2
a1388 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1390 2
a1391 3
	frestore a0@@			| restore state
	movw	a1@@(PCB_PS),sr		| no, restore PS
	moveq	#1,d0			| return 1 (for alternate returns)
d1396 1
a1396 1
	tstb	a0@@(2)			| null state frame?
d1398 4
a1401 4
	fmovem	a0@@(FPF_FPCR),fpcr	| restore FP control registers
	fmovem	a0@@(FPF_FPSR),fpsr
	fmovem	a0@@(FPF_FPI),fpi
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1403 2
a1404 3
	frestore a0@@			| restore state
	movw	a1@@(PCB_PS),sr		| no, restore PS
	moveq	#1,d0			| return 1 (for alternate returns)
d1414 5
a1418 5
	movl	sp@@(4),a1
	movw	sr,a1@@(PCB_PS)
	movl	usp,a0			| grab USP
	movl	a0,a1@@(PCB_USP)		| and save it
	moveml	#0xFCFC,a1@@(PCB_REGS)	| save non-scratch registers
d1423 2
a1424 2
	lea	a1@@(PCB_FPCTX),a0	| pointer to FP save area
	fsave	a0@@			| save FP state
d1429 1
a1429 1
	tstb	a0@@			| null state frame?
d1431 2
a1432 3
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
	moveq	#0,d0
d1436 1
a1436 1
	tstb	a0@@(2)
d1438 4
a1441 4
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a0@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a0@@(FPF_FPSR)
	fmovem	fpi,a0@@(FPF_FPI)
a1443 1
	moveq	#0,d0			| return 0
d1448 6
a1453 6
	movl	sp@@(4),a0		| address to write
	movl	_C_LABEL(curpcb),a1	| current pcb
	movl	#Lslerr,a1@@(PCB_ONFAULT) | where to return to on a fault
	movl	sp@@(8),a1		| address of line
	movl	a1@@+,d0			| get lword
	movsl	d0,a0@@+			| put lword
d1455 2
a1456 2
	movl	a1@@+,d0			| get lword
	movsl	d0,a0@@+			| put lword
d1458 2
a1459 2
	movl	a1@@+,d0			| get lword
	movsl	d0,a0@@+			| put lword
d1461 2
a1462 2
	movl	a1@@+,d0			| get lword
	movsl	d0,a0@@+			| put lword
d1464 1
a1464 1
	moveq	#0,d0			| indicate no fault
d1467 1
a1467 1
	moveq	#-1,d0
d1469 2
a1470 2
	movl	_C_LABEL(curpcb),a1	| current pcb
	clrl	a1@@(PCB_ONFAULT)	| clear fault address
d1483 2
a1484 2
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
d1487 1
d1489 1
a1489 1
	.word	0xf518			| pflusha
d1493 3
a1495 3
	movc	cacr,d0
	orl	#IC60_CABC,d0		| and clear all branch cache entries
	movc	d0,cacr
d1498 1
d1506 1
a1506 1
	movl	sp@@(4),a0		| get addr to flush
d1511 3
a1513 3
	pflush	#0,#0,a0@@		| flush address from both sides
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip data cache
d1516 1
a1516 1
	pflushs	#0,#0,a0@@		| flush address from both sides
d1518 1
d1520 6
a1525 6
	moveq	#FC_SUPERD,d0		| select supervisor
	movc	d0,dfc
	.word	0xf508			| pflush a0@@
	moveq	#FC_USERD,d0		| select user
	movc	d0,dfc
	.word	0xf508			| pflush a0@@
d1529 3
a1531 3
	movc	cacr,d0
	orl	#IC60_CABC,d0		| and clear all branch cache entries
	movc	d0,cacr
d1534 1
d1541 1
d1544 4
a1547 4
	.word	0xf518			| pflusha
	movc	cacr,d0
	orl	#IC60_CABC,d0		| and clear all branch cache entries
	movc	d0,cacr
d1549 1
d1562 2
a1563 2
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
d1568 1
d1571 1
a1571 1
	.word	0xf518			| pflusha
d1575 3
a1577 3
	movc	cacr,d0
	orl	#IC60_CUBC,d0		| but only user branch cache entries
	movc	d0,cacr
d1580 1
d1591 2
a1592 1
	.word	0xf498			| cinva ic
d1595 1
d1597 2
a1598 2
	movl	#IC_CLEAR,d0
	movc	d0,cacr			| invalidate i-cache
d1618 2
a1619 1
	.word	0xf478			| cpusha dc
d1621 1
d1626 1
d1628 1
a1628 1
	.word	0xf498			| cinva ic
d1631 1
a1631 1
	.word	0xf478			| cpusha dc
d1634 2
a1635 2
	movl	sp@@(4),a0		| address
	.word	0xf488			| cinvl ic,a0@@
d1638 2
a1639 2
	movl	sp@@(4),a0		| address
	.word	0xf490			| cinvp ic,a0@@
d1642 2
a1643 2
	movl	sp@@(4),a0		| address
	.word	0xf448			| cinvl dc,a0@@
d1646 2
a1647 2
	movl	sp@@(4),a0		| address
	.word	0xf450			| cinvp dc,a0@@
d1650 2
a1651 2
	movl	sp@@(4),a0		| address
	.word	0xf468			| cpushl dc,a0@@
d1654 2
a1655 2
	movl	sp@@(4),a0		| address
	.word	0xf470			| cpushp dc,a0@@
d1657 1
d1661 1
a1661 1
	movc	sfc,d0
d1665 1
a1665 1
	movc	dfc,d0
d1672 3
a1674 3
	movl	sp@@(4),d0		| new USTP
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to addr
d1685 5
a1689 5
	lea	_C_LABEL(protorp),a0	| CRP prototype
	movl	d0,a0@@(4)		| stash USTP
	pmove	a0@@,crp			| load root pointer
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
d1692 1
d1695 3
a1697 3
	movc	cacr,d1
	orl	#IC60_CUBC,d1		| clear user branch cache entries
	movc	d1,cacr
d1701 3
a1703 2
	.word	0xf518			| pflusha
	.long	0x4e7b0806		| movec d0,URP
d1713 3
a1715 3
	moveq	#0,d0
	movw	sr,d0			| get old SR for return
	movw	#PSL_LOWIPL,sr		| restore new SR
d1718 4
a1721 4
	subql	#4,sp			| make room for RTE frame
	movl	sp@@(4),sp@@(2)		| position return address
	clrw	sp@@(6)			| set frame type 0
	movw	#PSL_LOWIPL,sp@@		| and new SR
d1732 2
a1733 2
	movl	sp@@(4),a0		| save area pointer
	fsave	a0@@			| save state
d1738 1
a1738 1
	tstb	a0@@			| null state frame?
d1740 2
a1741 2
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1747 1
a1747 1
	tstb	a0@@(2)			| null state frame?
d1749 4
a1752 4
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a0@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a0@@(FPF_FPSR)
	fmovem	fpi,a0@@(FPF_FPI)
d1758 1
a1758 1
	movl	sp@@(4),a0		| save area pointer
d1763 1
a1763 1
	tstb	a0@@			| null state frame?
d1765 2
a1766 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1768 1
a1768 1
	frestore a0@@			| restore state
d1773 1
a1773 1
	tstb	a0@@(2)			| null state frame?
d1775 4
a1778 4
	fmovem	a0@@(FPF_FPCR),fpcr	| restore FP control registers
	fmovem	a0@@(FPF_FPSR),fpsr
	fmovem	a0@@(FPF_FPI),fpi
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1780 1
a1780 1
	frestore a0@@			| restore state
d1791 1
a1791 1
	lea	_ASM_LABEL(tmpstk),sp	| physical SP in case of NMI
d1795 4
a1798 3
	movl	#0,d0
	movc	d0,cacr			| caches off
	.long	0x4e7b0003		| movc d0,tc (turn off MMU)
d1800 1
d1803 4
a1806 4
	movl	#CACHE_OFF,d0
	movc	d0,cacr			| disable on-chip cache(s)
	movl	#0,a7@@			| value for pmove to TC (turn off MMU)
	pmove	a7@@,tc			| disable MMU
d1808 2
a1809 2
1:	movl	#0,d0
	movc	d0,vbr			| ROM VBR
d1814 3
a1816 3
	RELOC(cputyp, a0)
	movl	a0@@,d0
	cmpw	#CPU_147,d0
d1818 1
a1818 1
	movl	#0xfffe2000,a0		| MVME147: "struct vme1reg *"
d1820 3
a1822 3
	movw	a0@@,d0
	movl	d0,d1
	andw	#0x0001,d1		| is VME1_SCON_SWITCH set?
d1824 2
a1825 2
	orw	#0x0002,d0		| ok, assert VME1_SCON_SRESET
	movw	d0,a0@@
d1827 3
a1829 3
	movl	#0xff800000,a0		| if we get here, SRESET did not work.
	movl	a0@@(4),a0		| try jumping directly to the ROM.
	jsr	a0@@
d1834 1
a1834 1
	cmpw	#CPU_165, d0
d1836 3
a1838 3
	movl	#0xfff90020,a0		| disable timer2 (clock)
	movl	#0, a0@@
	movl	#0xfffb0000,a0		| MVME165 VMEChip base address
d1843 1
a1843 1
	cmpw	#CPU_141, d0
d1845 1
a1845 1
	movl	#0xfffb0000,a0		| MVME141 VMEChip base address
d1850 4
a1853 4
	movl	#0xfff40000,a0		| MVME16x: "struct vme2reg *"
	movl	a0@@(0x60),d0
	movl	d0,d1
	andl	#0x40000000,d1		| is VME2_TCTL_SCON set?
d1855 2
a1856 2
	orl	#0x00800000,d0		| ok, assert VME2_TCTL_SRST
	movl	d0,a0@@(0x60)
d1859 4
a1862 4
	movl	#0xfff40000,a0		| MVME16x: "struct vme2reg *"
	movl	a0@@(0x104),d0
	orw	#0x00000080,d0
	movl	d0,a0@@(0x104)
d1864 3
a1866 3
	movl	#0xff800000,a0		| if we get here, SRESET did not work.
	movl	a0@@(4),a0		| try jumping directly to the ROM.
	jsr	a0@@
d1874 1
a1874 1
	jra	_I_CALL_TOP+128+0x00
d1876 1
a1876 1
	jra	_FP_CALL_TOP+128+0x30
d1878 1
a1878 1
	jra	_FP_CALL_TOP+128+0x38
d1880 1
a1880 1
	jra	_FP_CALL_TOP+128+0x40
d1884 1
a1894 2
GLOBAL(want_resched)
	.long	0
@


1.61
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.60 2009/03/01 22:08:13 miod Exp $ */
d1037 1
a1037 1
 * Trap 12 is the entry point for the cachectl "syscall" (both HPUX & BSD)
d1539 1
a1539 1
#if defined(COMPAT_HPUX) || defined(M68060)
d1567 1
a1567 1
#endif	/* defined(COMPAT_HPUX) || defined(M68060) */
@


1.60
log
@Support for MVME141 boards. Tested with both VME and VSB memory boards
(and MVME327 SCSI and MVME376 Ethernet, to provide a complete system).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.59 2009/03/01 21:40:49 miod Exp $ */
d1012 1
a1012 1
	tstb	_C_LABEL(ssir)
d1015 1
a1015 1
	tstb	_C_LABEL(ssir)
d1200 1
a1200 1
BSS(ssir,1)
d1238 1
a1238 1
	tstb	_C_LABEL(ssir)		| SIR pending?
d1247 1
a1247 1
	tstb	_C_LABEL(ssir)		| too late?
d1693 1
a1693 1
	tstb	_C_LABEL(ssir)		| software interrupt pending?
@


1.59
log
@Support for MVME165 board - code written in april 2006, eventually debugged
last month.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.58 2009/02/18 20:48:02 miod Exp $ */
d161 5
d215 25
a490 13
#if 0
	| XXX clear from end-of-kernel to 1M, as a workaround for an
	| insane pmap_bootstrap bug I cannot find (68040-specific)
	movl	a4,a0
	movl	#1024*1024,d0
	cmpl	a0,d0			| end of kernel is beyond 1M?
	jlt	2f
	subl	a0,d0
1:	clrb	a0@@+
	subql	#1,d0
	bne	1b
2:
#endif
d499 1
d516 1
a597 1
#if 1
a599 1
#endif	
d677 39
a715 1
#endif
d1818 7
@


1.58
log
@delay() would only work as intended after clock0 attached. Initialize the
delay strategy variable in locore now; this fixes the occasional console
output artefacts on MVME177.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.57 2009/02/18 20:46:37 miod Exp $ */
d171 5
a183 1
#ifdef notyet	
a185 1
#endif        
d277 33
d1739 1
d1754 9
@


1.57
log
@Check for nofault being set in the 68030 bus error handler, too. This makes
bad[pv]addr work again on MVME147.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.56 2009/02/18 20:45:49 miod Exp $ */
d215 3
d264 3
d288 3
d319 3
d347 3
@


1.56
log
@Repair DCI[ASU] operation on 68030 processors, broken by accident in r1.53
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.55 2007/10/10 15:53:52 art Exp $ */
d788 5
@


1.55
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.54 2007/05/15 13:46:22 martin Exp $ */
d1491 1
@


1.54
log
@switch m68k to __HAVE_CPUINFO

help miod@@, art@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.53 2006/07/03 18:55:36 miod Exp $ */
a1167 5
/*
 * Use common m68k process manipulation routines.
 */
#include <m68k/m68k/proc_subr.s>

d1174 1
a1174 22
/*
 * At exit of a process, do a switch for the last time.
 * Switch to a safe stack and PCB, and deallocate the process's resources.
 */
ENTRY(switch_exit)
	movl	sp@@(4),a0
	| save state into garbage pcb
	movl	#_ASM_LABEL(nullpcb),_C_LABEL(curpcb)
	lea	_ASM_LABEL(tmpstk),sp	| goto a tmp stack

        /* Schedule the vmspace and stack to be freed. */
	movl    a0,sp@@-                 | exit2(p)
	jbsr    _C_LABEL(exit2)
	lea     sp@@(4),sp               | pop args

	jra	_C_LABEL(cpu_switch)

/*
 * When no processes are on the runq, Swtch branches to Idle
 * to wait for something to come ready.
 */
ASENTRY_NOPROFILE(Idle)
d1176 1
a1176 8
	movw	#PSL_HIGHIPL,sr
	movl	_C_LABEL(whichqs),d0
	jeq	_ASM_LABEL(Idle)
	jra	Lsw1

Lbadsw:
	PANIC("switch")
	/*NOTREACHED*/
d1179 1
a1179 1
 * cpu_switch()
d1189 3
a1191 7
ENTRY(cpu_switch)
	movl	_C_LABEL(curpcb),a0	| current pcb
	movw	sr,a0@@(PCB_PS)		| save sr before changing ipl
#ifdef notyet
	movl	CURPROC,sp@@-		| remember last proc running
#endif
	clrl	CURPROC
a1193 37
	 * Find the highest-priority queue that isn't empty,
	 * then take the first proc from that queue.
	 */
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	movl	_C_LABEL(whichqs),d0
	jeq	_ASM_LABEL(Idle)
Lsw1:
	movl	d0,d1
	negl	d0
	andl	d1,d0
	bfffo	d0{#0:#32},d1
	eorib	#31,d1

	movl	d1,d0
	lslb	#3,d1			| convert queue number to index
	addl	#_C_LABEL(qs),d1	| locate queue (q)
	movl	d1,a1
	movl	a1@@(P_FORW),a0		| p = q->p_forw
	cmpal	d1,a0			| anyone on queue?
	jeq	Lbadsw			| no, panic
	movl	a0@@(P_FORW),a1@@(P_FORW)	| q->p_forw = p->p_forw
	movl	a0@@(P_FORW),a1		| n = p->p_forw
	movl	d1,a1@@(P_BACK)		| n->p_back = q
	cmpal	d1,a1			| anyone left on queue?
	jne	Lsw2			| yes, skip
	movl	_C_LABEL(whichqs),d1
	bclr	d0,d1			| no, clear bit
	movl	d1,_C_LABEL(whichqs)
Lsw2:
	movl	a0,CURPROC
	clrl	_C_LABEL(want_resched)
#ifdef notyet
	movl	sp@@+,a1
	cmpl	a0,a1			| switching to same proc?
	jeq	Lswdone			| yes, skip save and restore
#endif
	/*
d1197 1
d1225 1
d1227 3
a1229 6
#ifdef DIAGNOSTIC
	tstl	a0@@(P_WCHAN)
	jne	Lbadsw
	cmpb	#SRUN,a0@@(P_STAT)
	jne	Lbadsw
#endif
a1230 1
	clrl	a0@@(P_BACK)		| clear back link
@


1.53
log
@Backout premature incomplete 060 stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.52 2006/06/11 20:57:44 miod Exp $ */
d934 1
a934 1
	movl	_C_LABEL(curproc),sp@@-	| push proc pointer
d1226 1
a1226 1
	movl	_C_LABEL(curproc),sp@@-	| remember last proc running
d1228 1
a1228 1
	clrl	_C_LABEL(curproc)
d1260 1
a1260 1
	movl	a0,_C_LABEL(curproc)
@


1.52
log
@Clean the various cache and TLB invalidation function, arch by arch:
- [DI]C{FL,PL,PP} and DCFA are only called on 680[46]0 systems and are
  identical on these platforms, so don't bother checking for the MMU type.
- TBIAS is on 68060 codepath only.
- DCIAS, PCIA and TBIA are specific to some platforms and do not need to be
  implemented everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.51 2006/05/19 22:51:09 miod Exp $ */
a1558 3
 *
 * On 68060, since we have disabled cache invalidation on pushes, we need
 * an explicit cinva after the cpusha.
a1566 3
	jeq	1f
	.word	0xf458			| cinva dc
1:
@


1.51
log
@Get rid of ``maxmem'' and fix the descriptive comment for ``physmem''.
Either maxmem is not used (mac68k), or the position of the physical memory
is set in stone so we don't need to know the top of the memory (MAXADDR
on hp300, physmem on mvme68k) it was pointing to.

Plus this gets rid of unused lowram on mvme68k - all the m68k world is not an
hp300, after all.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.50 2006/04/21 22:21:54 miod Exp $ */
d521 1
a521 1
	jbsr	_C_LABEL(TBIA)		| invalidate TLB
d1435 1
a1435 2
ENTRY(TBIA)
_C_LABEL(_TBIA):
a1461 4
#ifdef DEBUG
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush entire TLB
#endif
d1494 1
d1496 1
a1496 17
#ifdef DEBUG
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush everything
#endif
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060 ?
	jle	Ltbias040               | yes, goto Ltbias040
	tstl	_C_LABEL(mmutype)
	jpl	Lmc68851c		| 68851?
	pflush #4,#4			| flush supervisor TLB entries
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts
Lmc68851c:
	pflushs #4,#4			| flush supervisor TLB entries
	rts
Ltbias040:
| 68040 cannot specify supervisor/user on pflusha, so we flush all
a1497 3
#ifdef M68060
	cmpl	#MMU_68060,_C_LABEL(mmutype)
	jne	Ltbiasno60
d1501 1
a1501 1
Ltbiasno60:
a1502 1
	rts
d1504 1
a1508 4
#ifdef DEBUG
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush everything
#endif
d1532 1
d1539 2
a1540 3
ENTRY(ICPA)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jgt	Lmotommu7		| no, skip
d1543 1
a1543 1
Lmotommu7:
d1551 1
d1556 6
d1564 2
a1565 1
_C_LABEL(_DCIA):
d1567 2
a1568 2
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jgt	Lmotommu8		| no, skip
d1570 3
a1572 2
	rts
Lmotommu8:
a1575 2
ENTRY(DCIS)
_C_LABEL(_DCIS):
d1577 2
a1578 3
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jgt	Lmotommu9		| no, skip
	.word	0xf478			| cpusha dc
d1580 1
a1580 9
Lmotommu9:
#endif
	rts

ENTRY(DCIU)
_C_LABEL(_DCIU):
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jgt	LmotommuA		| no, skip
a1582 5
LmotommuA:
#endif
	rts

#if defined(M68040) || defined(M68060)
a1598 3
ENTRY(DCPA)
	.word	0xf458			| cinva dc
	rts
a1608 13
ENTRY(PCIA)
#if defined(M68040) || defined(M68060)
ENTRY(DCFA)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jgt	LmotommuB		| no, skip
	.word	0xf478			| cpusha dc
	rts
LmotommuB:
#endif
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts

d1620 1
a1620 1
ENTRY(loadustp)       /* XXX - smurph */
d1624 2
d1627 1
a1627 2
	cmpl	#MMU_68060,_C_LABEL(mmutype) | 68040 or 68060?
	jeq	Lldustp060		| yes, goto Lldustp060
d1629 1
a1629 1
	cmpl	#MMU_68040,_C_LABEL(mmutype)
d1631 2
d1646 1
a1652 5
ENTRY(ploadw)
	movl	sp@@(4),a0		| address to load
	ploadw	#1,a0@@			| pre-load translation
	rts

d1687 2
a1688 2
	fmovem fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1696 1
a1696 1
	fmovem fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
a1831 7

#ifdef DEBUG
ASGLOBAL(fulltflush)
	.long	0
ASGLOBAL(fullcflush)
	.long	0
#endif
@


1.50
log
@Since bugtty (and BUG routines in general) can only work if we keep the BUG
mapped, and we don't, do not bother carrying this code around - it can not
be used anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.49 2006/01/21 12:27:58 miod Exp $ */
a103 1
BSS(lowram, 4)
a119 1
	movl	#0,a5			| RAM starts at 0
a144 3
        RELOC(lowram, a0)
	movl	a5,a0@@			| store start of physical memory

d395 1
a395 6
	lsrl	d2,d1			| convert to page (click) number
	RELOC(maxmem, a0)
	movl	d1,a0@@			| save as maxmem
	movl	a5,d0			| lowram value from ROM via boot
	lsrl	d2,d0			| convert to page number
	subl	d0,d1			| compute amount of RAM present
d397 1
a397 1
	movl	d1,a0@@			| and physmem
a409 1
	addl	a5,a4			| convert to PA
d425 1
a425 2
	RELOC(mmutype, a0)
        pea	a5@@			| firstpa
a454 1
	addl	a5,d1			| convert to PA
@


1.49
log
@Remove old mdpflag debug help.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48 2005/08/14 12:52:40 miod Exp $ */
a107 1
BSS(needprom, 4)
a274 3
|	RELOC(needprom,a0)		| this machine needs the prom mapped!
|	movl	#1,a0@@

a323 4

|	RELOC(needprom,a0)		| this machine needs the prom mapped!
|	movl	#1,a0@@
	
a484 17
	RELOC(needprom,a0)
	cmpl	#0,a0@@
	beq	1f
	/*
	 * this machine needs the prom mapped. we use the translation
	 * registers to map it in.. and the ram it needs.
	 */
	movel	#0xff00a044,d0		| map top 16meg 1/1 for bug eprom exe
	.long	0x4e7b0004		| movc d0,itt0
	moveq	#0,d0			| ensure itt1 is disabled
	.long	0x4e7b0005		| movc d0,itt1
	movel	#0xff00a040,d0		| map top 16meg 1/1 for bug io access
	.long	0x4e7b0006		| movc d0,dtt0
	moveq	#0,d0			| ensure dtt1 is disabled
	.long	0x4e7b0007		| movc d0,dtt1
	bra	2f
1:
a489 1
2:
@


1.48
log
@DCIAS() no more.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.47 2004/12/30 21:28:48 miod Exp $ */
a1213 1
GLOBAL(masterpaddr)		| XXX compatibility (debuggers)
a1215 4
ASLOCAL(mdpflag)
	.byte	0		| copy of proc md_flags low byte
	.align	2

a1345 2
	| low byte of p_md.md_flags
	movb	a0@@(P_MD_FLAGS+3),_ASM_LABEL(mdpflag)
@


1.47
log
@If we are running on a 68040 or a 68060 processor, overwrite the copypage()
code with the faster copypage040() before the kernel text is mapped read-only.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.46 2004/12/24 22:50:30 miod Exp $ */
a1648 10
	rts

| Invalid single cache line
ENTRY(DCIAS)
_C_LABEL(_DCIAS):
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060
	jle	Ldciasx
	movl	sp@@(4),a0
	.word	0xf468			| cpushl dc,a0@@
Ldciasx:
@


1.46
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.45 2004/12/01 21:13:59 miod Exp $ */
d450 17
@


1.45
log
@5 -> FC_SUPERD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.44 2004/09/29 07:34:42 miod Exp $ */
a1093 1
	addql	#1,_C_LABEL(intrcnt)+0
a1928 18

/* interrupt counters */
GLOBAL(intrnames)
	.asciz	"spur"
	.asciz	"lev1"
	.asciz	"lev2"
	.asciz	"lev3"
	.asciz	"lev4"
	.asciz	"clock"
	.asciz	"lev6"
	.asciz	"nmi"
	.asciz	"statclock"
GLOBAL(eintrnames)
	.even

GLOBAL(intrcnt)
	.long	0,0,0,0,0,0,0,0,0,0
GLOBAL(eintrcnt)
@


1.44
log
@Do not count 060SP traps; there are too many of them, better handle them
as fast as possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.43 2004/07/30 09:50:17 miod Exp $ */
d1510 1
a1510 1
	moveq	#5,d0		        | select supervisor
@


1.43
log
@Switch mvme68k to evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.42 2004/07/02 17:33:43 miod Exp $ */
a677 1
	addql	#1, _C_LABEL(ec_60bpe) + EC_COUNT32
a1892 1
	addql	#1, _C_LABEL(ec_60iem) + EC_COUNT32
a1894 1
	addql	#1, _C_LABEL(ec_60fpiem) + EC_COUNT32
a1896 1
	addql	#1, _C_LABEL(ec_60fpdem) + EC_COUNT32
a1898 1
	addql	#1, _C_LABEL(ec_60fpeaem) + EC_COUNT32
@


1.42
log
@Cope with SONPROC scheduler changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.41 2004/05/20 09:20:42 kettenis Exp $ */
d72 1
a72 1
 * Macro to relocate a symbol, used before MMU is enabled.
d81 1
a81 1
 * Macro to invoke a BUG routine.
d678 1
a678 1
	addql	#1,L60bpe
d1892 1
a1892 1
#ifdef M68060
d1894 1
a1894 1
	addql	#1,L60iem
d1897 1
a1897 1
	addql	#1,L60fpiem
d1900 1
a1900 1
	addql	#1,L60fpdem
d1903 1
a1903 1
	addql	#1,L60fpeaem
a1946 10
#ifdef M68060
	.asciz	"60intemu"
	.asciz	"60fpiemu"
	.asciz	"60fpdemu"
	.asciz	"60fpeaemu"
	.asciz	"60bpe"
#endif
#ifdef FPU_EMULATE
	.asciz	"fpe"
#endif
a1951 10
#ifdef M68060
L60iem:		.long	0
L60fpiem:	.long	0
L60fpdem:	.long	0
L60fpeaem:	.long	0
L60bpe:		.long	0
#endif
#ifdef FPU_EMULATE
Lfpecnt:	.long	0
#endif
@


1.41
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.40 2004/04/24 21:09:37 miod Exp $ */
d1334 1
@


1.40
log
@Insane people can't spell insane correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.39 2004/03/09 00:08:13 xsa Exp $ */
d957 1
d959 1
a959 1
	lea	sp@@(12),sp		| pop args
@


1.39
log
@
same typo as in mac68k/mac68k/locore.s
ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.38 2004/03/03 07:46:58 miod Exp $ */
d431 1
a431 1
	| inane pmap_bootstrap bug I cannot find (68040-specific)
@


1.38
log
@Handle 68060 branch prediction error traps before checking whether we are
ignoring bus errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.36 2003/06/02 23:27:51 millert Exp $ */
d567 1
a567 1
 * main() nevers returns; we exit to user mode from a forked process
@


1.37
log
@68040 boards would not set address error and bus error trap vectors correctly;
fix inspired by the hp300 code.
@
text
@a666 5
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	Lbuserr60		| no, handle as usual
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
Lbuserr60:
d694 5
d700 2
a701 1
	jra	Lismerr			| no, MMU fault.
a704 6
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	Lbuserr40		| no, handle as usual
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
Lbuserr40:        
d720 1
a720 1
	jeq	Lisberr			| it is a bus error
d723 6
@


1.36
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.35 2003/06/02 05:09:14 deraadt Exp $ */
d267 4
d291 4
d319 4
d349 4
d730 1
a730 10
_C_LABEL(buserr):
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	Lberr			| no, handle as usual
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
Lberr:
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jgt	_C_LABEL(addrerr)	| no, skip
a735 35
	moveq	#0,d0
	movw	a1@@(12),d0		| grab SSW
	movl	a1@@(20),d1		| and fault VA
	btst	#11,d0			| check for mis-aligned access
	jeq	Lberr2			| no, skip
	addl	#3,d1			| yes, get into next page
	andl	#PG_FRAME,d1		| and truncate
Lberr2:
	movl	d1,sp@@-			| push fault VA
	movl	d0,sp@@-			| and padded SSW
	btst	#10,d0			| ATC bit set?
	jeq	Lisberr			| no, must be a real bus error
	movc	dfc,d1			| yes, get MMU fault
	movc	d0,dfc			| store faulting function code
	movl	sp@@(4),a0		| get faulting address
	.word	0xf568			| ptestr a0@@
	movc	d1,dfc
	.long	0x4e7a0805		| movc mmusr,d0
	movw	d0,sp@@			| save (ONLY LOW 16 BITS!)
	jra	Lismerr
#endif
_C_LABEL(addrerr):
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	lea	sp@@(FR_HW),a1		| grab base of HW berr frame
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jgt	Lbenot040		| no, skip
	movl	a1@@(8),sp@@-		| yes, push fault address
	clrl	sp@@-			| no SSW for address fault
	jra	Lisaerr			| go deal with it
Lbenot040:
#endif
@


1.35
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.34 2003/05/31 17:28:14 miod Exp $ */
d44 1
a44 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.34
log
@Don't use orw with a > 16 bits constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.33 2003/01/04 17:21:31 miod Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.33
log
@When detecting the memory size on 167 and 177, probe both memory controllers
instead than only the first one.
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.32 2002/04/18 21:41:02 miod Exp $ */
d1910 1
a1910 1
	orw	#0x00800000,d0		| ok, assert VME2_TCTL_SRST
@


1.32
log
@- use a define instead of a hardcoded value for 68040 cache control
- 68060 FPU operations should test fputype, not mmutype, for 060 land,
  if only for consistency reasons.
Tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.31 2002/02/11 19:08:30 miod Exp $ */
a286 1
	movl	d0, d2
a331 1
	movl	d0, d2
a373 27
#if 0
	/* 
	 * get memory size using ENVIRON. unfortunately i've not managed
	 * to get this working.
	 */
	RELOC(rompkt, a0)
	movl	#ENVIRONCMD_READ, sp@@-	| request environment information
	movl	#ROMPKT_LEN, sp@@-	| max length
	movl	a0, sp@@-		| point to info packet
	BUGCALL(MVMEPROM_ENVIRON)	| ask the rom
	addl	#12, sp
	| XXX should check return values

	clrl	d2			| memsize = 0
1:	clrl	d0
	movb	a0@@+, d0		| look for a "memsize" chunk in the
	cmpb	#ENVIRONTYPE_EOL, d0	| environment
	beq	3f
	cmpb	#ENVIRONTYPE_MEMSIZE, d0
	beq	2f
	movb	a0@@+, d0
	addl	d0, a0
	bra	1b
2:	movl	a0@@(7), d2		| XXX memory size (fix @@(7) offset!)
3:
#endif

d575 51
@


1.31
log
@Merge pmap_bootstrap060() with pmap_bootstrap().
Thanks to deraadt@@ for testing on mvme177.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.30 2002/02/10 23:15:05 deraadt Exp $ */
d535 1
a535 1
        movl	#0x80008000,d0
d1324 1
a1324 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | is 68060?
d1380 1
a1380 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | is 68060?
d1426 1
a1426 1
	cmpl	#MMU_68060,_mmutype     | is 68060?
d1749 1
a1749 1
	.word	0xf518			| pflusha XXX TDR
d1787 1
a1787 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | 68040 or 68060?
d1812 1
a1812 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | 68040 or 68060?
@


1.30
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.29 2001/12/06 21:13:28 millert Exp $ */
a467 10
	cmpl	#MMU_68060,a0@@		| 68060?
	jne	Lpmap040	        | no, skip
        pea	a5@@			| firstpa
	pea	a4@@			| nextpa
	RELOC(pmap_bootstrap060,a0)
	jbsr	a0@@			| pmap_bootstrap(firstpa, nextpa)
	addql	#8,sp
        bra     Lmmu_enable
      
Lpmap040:	
d567 2
a568 4
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jeq	Lnocache0		| yes, cache already on
	cmpl	#MMU_68060,_mmutype	| 68060?
	jeq	Lnocache0		| yes, cache already on
d1652 2
a1653 4
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jeq	Ldciasx
	cmpl	#MMU_68060,_C_LABEL(mmutype) | 68060
	jeq	Ldciasx
@


1.29
log
@Define proper macros for FP frame offsets rather than magic numbers.
From NetBSD (tsutsui).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.28 2001/08/31 00:37:20 miod Exp $ */
d810 1
a810 1
					| (we dont seperate data/program)
@


1.29.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.29 2001/12/06 21:13:28 millert Exp $ */
d468 10
d545 1
a545 1
        movl	#CACHE40_ON,d0
d577 4
a580 2
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060?
	jle	Lnocache0		| yes, cache already on
d810 1
a810 1
					| (we dont separate data/program)
d1336 1
a1336 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
d1392 1
a1392 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
d1438 1
a1438 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
d1664 4
a1667 2
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060
	jle	Ldciasx
d1763 1
a1763 1
	.word	0xf518			| pflusha
d1801 1
a1801 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
d1826 1
a1826 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
@


1.29.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d287 1
d333 1
d376 27
a603 51

#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined(MVME172)
/*
 * Figure out the size of onboard DRAM by querying the memory controller(s).
 * This has to be done in locore as badaddr() can not yet be used at this
 * point.
 */
GLOBAL(memsize1x7)
	movl	#0xfff43008,a0		| MEMC040/MEMECC Controller #1
	jbsr	memc040read
	movl	d0,d2

	movl	#0xfff43108,a0		| MEMC040/MEMECC Controller #2
	jbsr	memc040read
	addl	d0,d2

	rts

/*
 * Probe for a memory controller ASIC (MEMC040 or MEMECC) at the
 * address in a0. If found, return the size in bytes of any RAM
 * controller by the ASIC in d0. Otherwise return zero.
 */
ASLOCAL(memc040read)
	moveml	d1-d2/a1-a2,sp@@-	| save scratch regs
	movc	vbr,d2			| Save vbr
	RELOC(vectab,a2)		| Install our own vectab, temporarily
	movc	a2,vbr
	ASRELOC(Lmemc040berr,a1)	| get address of bus error handler
	movl	a2@@(8),sp@@-		| Save current bus error handler addr
	movl	a1,a2@@(8)		| Install our own handler
	movl	sp,d0			| Save current stack pointer value
	movql	#0x07,d1
	andb	a0@@,d1			| Access MEMC040/MEMECC
	movl	#0x400000,d0
	lsll	d1,d0			| Convert to memory size, in bytes
Lmemc040ret:
	movc	d2,vbr			| Restore original vbr
	movl	sp@@+,a2@@(8)		| Restore original bus error handler
	moveml	sp@@+,d1-d2/a1-a2
	rts
/*
 * If the memory controller doesn't exist, we get a bus error trying
 * to access a0@@ above. Control passes here, where we flag 'no bytes',
 * ditch the exception frame and return as normal.
 */
Lmemc040berr:
	movl	d0,sp			| Get rid of the exception frame
	clrl	d0			| No ASIC at this location, then!
	jbra	Lmemc040ret		| Done
#endif
@


1.28
log
@The fact that my tree builds should not prevent the official tree to
build as well... Right now, .s files can't include unmodified <machine/psl.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.27 2001/08/13 00:01:47 miod Exp $ */
d1341 2
a1342 2
	fmovem	fp0-fp7,a2@@(216)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(312)	| save FP control registers
d1348 4
a1351 4
	fmovem	fp0-fp7,a2@@(216)	| save FP general registers
	fmovem	fpcr,a2@@(312)		| save FP control registers
	fmovem	fpsr,a2@@(316)
	fmovem	fpi,a2@@(320)
d1397 2
a1398 2
	fmovem	a0@@(312),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
d1409 4
a1412 4
	fmovem	a0@@(312),fpcr		| restore FP control registers
	fmovem	a0@@(316),fpsr
	fmovem	a0@@(320),fpi
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
d1443 2
a1444 2
	fmovem	fp0-fp7,a0@@(216)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(312)	| save FP control registers
d1451 4
a1454 4
	fmovem	fp0-fp7,a0@@(216)	| save FP general registers
	fmovem	fpcr,a0@@(312)		| save FP control registers
	fmovem	fpsr,a0@@(316)
	fmovem	fpi,a0@@(320)
d1806 2
a1807 2
	fmovem fp0-fp7,a0@@(216)		| save FP general registers
	fmovem fpcr/fpsr/fpi,a0@@(312)	| save FP control registers
d1815 4
a1818 4
	fmovem fp0-fp7,a0@@(216)		| save FP general registers
	fmovem	fpcr,a0@@(312)		| save FP control registers
	fmovem	fpsr,a0@@(316)
	fmovem	fpi,a0@@(320)
d1831 2
a1832 2
	fmovem	a0@@(312),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
d1841 4
a1844 4
	fmovem	a0@@(312),fpcr		| restore FP control registers
	fmovem	a0@@(316),fpsr
	fmovem	a0@@(320),fpi
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
@


1.27
log
@ecacheon(), ecacheoff() good bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.26 2001/06/27 04:19:17 art Exp $ */
d79 1
@


1.26
log
@zap old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.25 2001/06/26 21:35:41 miod Exp $ */
a1723 6
	rts

ENTRY(ecacheon)
	rts

ENTRY(ecacheoff)
@


1.25
log
@A few changes to mvme68k:
+ switch to UVM
+ fix the system trace problem
+ big cleanup of locore.s (macro for BUG calls, use more common m68k
  code whenever possible, and the macros in <m68k/asm.h>)
+ better indentation on some parts (old KNF)
+ call doshutdownhooks() at shutdown
+ use <net/netisr_dispatch.h>
+ upgrade pmap.c to something very close to our current hp300 pmap.c,
  minus support for PMAP_NEW and for HP MMU
+ various tidbits I forget to mention here

work and tests by smurph@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.24 2001/04/05 20:39:39 deraadt Exp $ */
a556 1
#if defined(UVM)
a557 3
#else
	jbsr	_C_LABEL(vm_set_page_size) | select software page size
#endif
a1120 1
#if defined(UVM)
a1121 3
#else
	addql	#1,_C_LABEL(cnt)+V_INTR
#endif
@


1.24
log
@undo changes which did not even compile
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.22 2000/07/06 12:56:18 art Exp $ */
d81 16
d104 1
a104 5
	.globl	tmpstk
tmpstk:

#define	RELOC(var, ar) \
	lea	var,ar
d113 7
a119 7
	.comm	_lowram,4
	.comm	_esym,4
	.comm	_emini,4
	.comm	_smini,4
	.comm	_needprom,4
	.comm	_promvbr,4
	.comm	_promcall,4
d122 8
a129 6
	.globl	_edata
	.globl	_etext,_end
	.globl	start
	.globl	_kernel_text
_kernel_text:
start:
d140 1
a140 1
	RELOC(tmpstk, a0)
d143 3
a145 3
	RELOC(_edata, a0)		| clear out BSS
	movl	#_end-4,d0		| (must be <= 256 kB)
	subl	#_edata,d0
d151 1
a151 1
	RELOC(_promvbr, a0)
d153 1
a153 1
	RELOC(_esym, a0)
d157 1
a157 1
        RELOC(_lowram, a0)
d161 1
a161 2
	trap	#15
	.short	MVMEPROM_GETBRDID
d165 1
a165 1
	RELOC(_brdid, a0)
d171 1
a171 1
	RELOC(_brdid, a1)
d173 1
a173 1
	RELOC(_cputyp, a0)
d208 1
a208 1
notsup:	.ascii	"kernel does not support this model."
d216 1
a216 2
	trap	#15
	.short	MVMEPROM_OUTSTRCRLF
d219 2
a220 3
	trap	#15
	.short	MVMEPROM_EXIT		| return to m68kbug
	/*NOTREACHED */
d224 1
a224 1
	RELOC(_mmutype, a0)		| no, we have 68030
d227 1
a227 1
	RELOC(_cputype, a0)		| no, we have 68030
d239 1
a239 1
	RELOC(_myea, a1)
d244 1
a244 1
	RELOC(_iiomapsize, a1)
d246 1
a246 1
	RELOC(_iiomapbase, a1)
d263 1
a263 1
	RELOC(_memsize162, a1)		| how much memory?
d267 1
a267 1
	RELOC(_mmutype, a0)
d270 1
a270 1
	RELOC(_cputype, a0)		| no, we have 68040
d273 1
a273 1
	RELOC(_fputype, a0)
d281 1
a281 1
|	RELOC(_needprom,a0)		| this machine needs the prom mapped!
d284 1
a284 1
	RELOC(_memsize1x7, a1)		| how much memory?
d288 1
a288 1
	RELOC(_mmutype, a0)
d291 1
a291 1
	RELOC(_cputype, a0)		| no, we have 68040
d294 1
a294 1
	RELOC(_fputype, a0)
d303 1
a303 1
	RELOC(_memsize162, a1)		| how much memory?
d312 1
a312 1
	RELOC(_mmutype, a0)
d315 1
a315 1
	RELOC(_cputype, a0)		| no, we have 68060
d318 1
a318 1
	RELOC(_fputype, a0)
d327 1
a327 1
|	RELOC(_needprom,a0)		| this machine needs the prom mapped!
d330 1
a330 1
	RELOC(_memsize1x7, a1)		| how much memory?
d339 1
a339 1
	RELOC(_mmutype, a0)
d342 1
a342 1
	RELOC(_cputype, a0)		| no, we have 68060
d345 1
a345 1
	RELOC(_fputype, a0)
a351 1
	.data
d353 1
a353 1
	.comm	_rompkt, ROMPKT_LEN
d357 1
a357 1
	RELOC(_iiomapsize, a1)
d359 1
a359 1
	RELOC(_iiomapbase, a1)
d363 1
a363 1
	RELOC(_rompkt, a0)		| build a .NETCTRL packet
d367 1
a367 1
	RELOC(_myea, a1)
d372 1
a372 2
	trap	#15
	.short	MVMEPROM_NETCTRL	| ask the rom
d380 1
a380 1
	RELOC(_rompkt, a0)
d384 1
a384 2
	trap	#15
	.short	MVMEPROM_ENVIRON	| ask the rom
d410 1
a410 2
	trap	#15
	.short	MVMEPROM_OUTSTRCRLF
d417 1
a417 1
unkmem:	.ascii	"could not figure out how much memory; assuming 4M."
d431 1
a431 1
	RELOC(_maxmem, a0)
d436 1
a436 1
	RELOC(_physmem, a0)
d438 1
a439 1
	.globl	_Sysseg, _pmap_bootstrap, _avail_start
d441 1
a441 1
	RELOC(_esym,a0)			| end of static kernel text/data/syms
d445 1
a445 1
	movl	#_end,d2		| end of static kernel text/data
d466 1
a466 1
	RELOC(_mmutype, a0)
d471 1
a471 1
	RELOC(_pmap_bootstrap060,a0)
d479 1
a479 1
	RELOC(_pmap_bootstrap,a0)
d488 1
a488 1
	RELOC(_Sysseg, a0)		| system segment table addr
d491 1
a491 1
	RELOC(_mmutype, a0)
d498 1
a498 1
	RELOC(_protorp, a0)
d504 1
a504 1
   RELOC(_mmutype, a0)
d508 1
a508 1
	RELOC(_needprom,a0)
d537 1
a537 1
	RELOC(_mmutype, a0)
d556 6
a561 2
	lea	tmpstk,sp		| temporary stack
	jbsr	_vm_set_page_size	| select software page size
d563 1
a563 1
	movl	_proc0paddr,a1		| get proc0 pcb addr
d565 2
d569 1
a569 1
	movl	a1,_curpcb		| proc0 is running
d571 1
a571 1
	tstl	_fputype		| Have an FPU?
d575 1
a575 1
	jbsr	_m68881_restore		| restore it (does not kill a1)
d579 2
a580 2
	jbsr	_TBIA			| invalidate TLB
	cmpl	#MMU_68040,_mmutype	| 68040?
d589 1
a589 1
   movl	#_vectab,d2		| set VBR
d592 6
a597 6
   movw	#PSL_LOWIPL,sr		| lower SPL
	movl	d3, _bootpart		| save bootpart
	movl	d4, _bootdevlun		| save bootdevlun
	movl	d5, _bootctrllun	| save bootctrllun
	movl	d6, _bootaddr		| save bootaddr
	movl	d7, _boothowto		| save boothowto
d613 1
a613 1
	lea	_proc0,a0		| save pointer to frame
d616 3
a618 1
	jra	_main			| main()
d620 8
a627 11
	pea	1f
	jbsr	_panic
1:
	.asciz	"main returned"
	.even

	.globl	_proc_trampoline
_proc_trampoline:
	movl	a3,sp@@-
	jbsr	a2@@
	addql	#4,sp
d632 1
a632 1
	jra	rei			| and return
a633 28
/*
 * Signal "trampoline" code (18 bytes).  Invoked from RTE setup by sendsig().
 * 
 * Stack looks like:
 *
 *	sp+0 ->	signal number
 *	sp+4	pointer to siginfo (sip)
 *	sp+8	pointer to signal context frame (scp)
 *	sp+12	address of handler
 *	sp+16	saved hardware state
 *			.
 *			.
 *	scp+0->	beginning of signal context frame
 */
	.globl	_sigcode, _esigcode, _sigcodetrap
	.data
_sigcode:
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
	jsr	a0@@			| call signal handler	(2 bytes)
	addql	#4,sp			| pop signo		(2 bytes)
_sigcodetrap:
	trap	#1			| special syscall entry	(2 bytes)
	movl	d0,sp@@(4)		| save errno		(4 bytes)
	moveq	#1,d0			| syscall == exit	(2 bytes)
	trap	#0			| exit(errno)		(2 bytes)
	.align	2
_esigcode:
	.text
a635 10
 * Do a dump.
 * Called by auto-restart.
 */
	.globl	_dumpsys
	.globl	_doadump
_doadump:
	jbsr	_dumpsys
	jbsr	_doboot
	/*NOTREACHED*/
/*
a639 1
	.globl	_trap, _nofault, _longjmp
d641 1
a641 2
	.globl _addrerr4060
_addrerr4060:
d653 2
a654 3
	.globl _buserr60
_buserr60:
	tstl	_nofault		| device probe?
d656 2
a657 2
	movl	_nofault,sp@@-		| yes,
	jbsr	_longjmp		|  longjmp(nofault)
d674 1
a674 1
                                        | we need to adjust for misaligned addresses
d690 2
a691 3
	.globl _buserr40
_buserr40:
	tstl	_nofault		| device probe?
d693 3
a695 2
	movl	_nofault,sp@@-		| yes,
	jbsr	_longjmp		|  longjmp(nofault)
d717 2
a718 6
/*
 * Trap/interrupt vector routines
 */
	.globl	_trap, _nofault, _longjmp
_buserr:
	tstl	_nofault		| device probe?
d720 3
a722 2
	movl	_nofault,sp@@-		| yes,
	jbsr	_longjmp		|  longjmp(nofault)
d725 2
a726 2
	cmpl	#MMU_68040,_mmutype	| 68040?
	jgt	_addrerr		| no, skip
d753 1
a753 1
_addrerr:
d760 1
a760 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d835 1
a835 1
	jra	Ltrapnstkadj		| and deal with it
d838 1
a838 1
	jra	Ltrapnstkadj		| and deal with it
d843 1
a843 21
Ltrapnstkadj:
	jbsr	_trap			| handle the error
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
	jne	Lstkadj			| yes, go to it
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SSP and stkadj
	jra	rei			| all done
Lstkadj:
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	jra	rei			| all done
d848 1
a848 1
_fpfline:
d850 1
a850 1
	cmpl	#FPU_68040,_fputype	| 68040 or 68060 FPU?
d853 1
a853 1
	jne	_illinst		| no, not an FP emulation
d856 1
a856 2
	.globl	fpsp_unimp
	jmp	fpsp_unimp		| yes, go handle it
d864 1
a864 1
	jra	fault			| do it
d866 1
a866 1
	jra	_illinst
d869 1
a869 1
_fpunsupp:
d871 2
a872 2
	cmpl	#FPU_68040,_fputype	| 68040 or 68060 FPU?
	jlt	_illinst		| no, treat as illinst
d874 1
a874 2
	.globl	fpsp_unsupp
	jmp	fpsp_unsupp		| yes, go handle it
d882 1
a882 1
	jra	fault			| do it
d884 1
a884 1
	jra	_illinst
d893 1
a893 2
	.globl	_fpfault
_fpfault:
d899 1
a899 1
	movl	_curpcb,a0	| current pcb
d904 1
a904 1
	cmpl	#CPU_68040,_cputype
d916 1
a916 1
	jra	Ltrapnstkadj	| call trap and deal with stack cleanup
d918 5
a922 2
	.globl	_hardtrap, _hardintr
_hardtrap:
d929 1
a929 1
	jbsr	_hardintr		| doit
d932 1
a932 1
	jra	rei			| all done
d934 1
a934 2
	.globl	_straytrap
_badtrap:
d939 1
a939 1
	jbsr	_straytrap		| report
d942 1
a942 1
	jra	rei			| all done
d944 1
a944 2
	.globl	_syscall
_trap0:
d950 1
a950 1
	jbsr	_syscall		| handle it
d952 1
a952 1
	tstl	_astpending
d954 1
a954 1
	tstb	_ssir
d957 1
a957 1
	tstb	_ssir
d969 1
a969 1
_trap1:
d975 1
a975 1
_trap2:
d983 1
a983 2
	.globl	_cachectl
_trap12:
d987 1
a987 1
	jbsr	_cachectl		| do it
d989 22
a1010 1
	jra	rei			| all done
d1014 2
a1015 1
 *	- KGDB traps
d1020 2
a1021 2
_trap15:
	clrl	sp@@-
d1023 2
a1024 1
	tstl	_promcall
d1034 1
a1034 1
	movl	_promvbr,a0
a1042 1
#ifdef KGDB
d1045 9
a1053 9
	andw	#PSL_S,d1		| from user mode?
	jeq	fault			| yes, just a regular fault
	movl	d0,sp@@-
	.globl	_kgdb_trap_glue
	jbsr	_kgdb_trap_glue		| returns if no debugger
	addl	#4,sp
#endif
	moveq	#T_TRAP15,d0
	jra	fault
d1055 25
a1079 7
/*
 * Hit a breakpoint (trap 1 or 2) instruction.
 * Push the code and treat as a normal fault.
 */
_trace:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
d1081 16
a1096 7
	moveq	#T_TRACE,d0
	movw	sp@@(FR_HW),d1		| get SSW
	andw	#PSL_S,d1		| from user mode?
	jeq	fault			| no, regular fault
	movl	d0,sp@@-
	jbsr	_kgdb_trap_glue		| returns if no debugger
	addl	#4,sp
d1098 16
a1113 2
	moveq	#T_TRACE,d0
	jra	fault
d1115 1
d1123 8
a1130 4
_spurintr:
	addql	#1,_intrcnt+0
	addql	#1,_cnt+V_INTR
	jra	rei
d1145 5
a1149 5
	.comm	_ssir,1
	.globl	_astpending
	.globl	rei
rei:
	tstl	_astpending		| AST pending?
d1163 1
a1163 1
	jbsr	_trap			| go handle it
d1184 1
a1184 1
	tstb	_ssir			| SIR pending?
d1193 1
a1193 1
	tstb	_ssir			| too late?
d1203 1
a1203 1
	jbsr	_trap			| go handle it
a1214 3
/* Use standard m68k support. */
#include <m68k/m68k/support.s>

d1216 1
a1216 6
 * The following primitives manipulate the run queues.  _whichqs tells which
 * of the 32 queues _qs have processes in them.  Setrunqueue puts processes
 * into queues, Remrq removes them from queues.  The running process is on
 * no queue, other processes are on a queue related to p->p_priority, divided
 * by 4 actually to shrink the 0-127 range of priorities into the 32 available
 * queues.
d1218 1
a1218 3

	.globl	_whichqs,_qs,_cnt,_panic
	.globl	_curproc,_want_resched
d1221 1
a1221 3
 * Setrunqueue(p)
 *
 * Call should be made at spl6(), and p->p_stat should be SRUN
d1223 1
a1223 33
ENTRY(setrunqueue)
	movl	sp@@(4),a0
#ifdef DIAGNOSTIC
	tstl	a0@@(P_BACK)
	jne	Lset1
	tstl	a0@@(P_WCHAN)
	jne	Lset1
	cmpb	#SRUN,a0@@(P_STAT)
	jne	Lset1
#endif
	clrl	d0
	movb	a0@@(P_PRIORITY),d0
	lsrb	#2,d0
	movl	_whichqs,d1
	bset	d0,d1
	movl	d1,_whichqs
	lslb	#3,d0
	addl	#_qs,d0
	movl	d0,a0@@(P_FORW)
	movl	d0,a1
	movl	a1@@(P_BACK),a0@@(P_BACK)
	movl	a0,a1@@(P_BACK)
	movl	a0@@(P_BACK),a1
	movl	a0,a1@@(P_FORW)
	rts
#ifdef DIAGNOSTIC
Lset1:
	movl	#Lset2,sp@@-
	jbsr	_panic
Lset2:
	.asciz	"setrunqueue"
	.even
#endif
d1226 1
a1226 3
 * Remrq(p)
 *
 * Call should be made at spl6().
d1228 1
a1228 36
ENTRY(remrunqueue)
	movl	sp@@(4),a0
	movb	a0@@(P_PRIORITY),d0
#ifdef DIAGNOSTIC
	lsrb	#2,d0
	movl	_whichqs,d1
	btst	d0,d1
	jeq	Lrem2
#endif
	movl	a0@@(P_BACK),a1
	clrl	a0@@(P_BACK)
	movl	a0@@(P_FORW),a0
	movl	a0,a1@@(P_FORW)
	movl	a1,a0@@(P_BACK)
	cmpal	a0,a1
	jne	Lrem1
#ifndef DIAGNOSTIC
	lsrb	#2,d0
	movl	_whichqs,d1
#endif
	bclr	d0,d1
	movl	d1,_whichqs
Lrem1:
	rts
#ifdef DIAGNOSTIC
Lrem2:
	movl	#Lrem3,sp@@-
	jbsr	_panic
Lrem3:
	.asciz	"remrunqueue"
	.even
#endif

Lsw0:
	.asciz	"switch"
	.even
a1229 2
	.globl	_curpcb
	.globl	_masterpaddr	| XXX compatibility (debuggers)
d1231 2
a1232 2
_masterpaddr:			| XXX compatibility (debuggers)
_curpcb:
d1234 2
a1235 1
mdpflag:
d1238 2
a1239 2
	.comm	nullpcb,SIZEOF_PCB
	.text
d1247 3
a1249 2
	movl	#nullpcb,_curpcb	| save state into garbage pcb
	lea	tmpstk,sp		| goto a tmp stack
d1256 1
a1256 1
	jra	_cpu_switch
d1262 1
a1262 2
	.globl	Idle
Idle:
d1265 2
a1266 2
	movl	_whichqs,d0
	jeq	Idle
d1270 1
a1270 2
	movl	#Lsw0,sp@@-
	jbsr	_panic
d1285 1
a1285 1
	movl	_curpcb,a0		| current pcb
a1286 1

d1288 1
a1288 1
	movl	_curproc,sp@@-		| remember last proc running
d1290 2
a1291 1
	clrl	_curproc
d1297 2
a1298 2
	movl	_whichqs,d0
	jeq	Idle
d1308 1
a1308 1
	addl	#_qs,d1			| locate queue (q)
d1318 1
a1318 1
	movl	_whichqs,d1
d1320 1
a1320 1
	movl	d1,_whichqs
d1322 2
a1323 2
	movl	a0,_curproc
	clrl	_want_resched
d1332 1
a1332 1
        movl	_curpcb,a1
d1337 1
a1337 1
	tstl	_fputype		| do we have any FPU?
d1343 1
a1343 1
	cmpl	#MMU_68060,_mmutype     | is 68060?
d1368 2
a1369 1
	movb	a0@@(P_MD_FLAGS+3),mdpflag | low byte of p_md.md_flags
d1371 1
a1371 1
	movl	a1,_curpcb
d1379 1
a1379 1
	jbsr	_pmap_activate		| pmap_activate(p)
d1381 3
a1383 1
	movl	_curpcb,a1		| restore p_addr
a1384 1
	lea	tmpstk,sp		| now goto a tmp stack for NMI
d1388 1
d1390 1
a1390 1
	tstl	_fputype		| do we _have_ any fpu?
d1399 1
a1399 1
	cmpl	#MMU_68060,_mmutype     | is 68060?
d1439 1
a1439 1
	tstl	_fputype
d1470 1
a1470 1
	movl	_curpcb,a1		| current pcb
d1490 1
a1490 1
	movl	_curpcb,a1		| current pcb
d1499 2
a1500 2
__TBIA:
	cmpl	#MMU_68040,_mmutype     | 68040 or 68060?
d1503 1
a1503 1
	tstl	_mmutype
d1512 1
a1512 1
	cmpl	#MMU_68060,_mmutype     | is 68060?
d1527 2
a1528 2
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush entire TLB
d1531 1
a1531 1
	cmpl	#MMU_68040,_mmutype     | 68040 or 68060 ?
d1533 1
a1533 1
	tstl	_mmutype
d1550 1
a1550 1
	cmpl	#MMU_68060,_mmutype     | is 68060?
d1564 2
a1565 2
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush everything
d1567 1
a1567 1
	cmpl	#MMU_68040,_mmutype     | 68040 or 68060 ?
d1569 1
a1569 1
	tstl	_mmutype
d1582 1
a1582 1
	cmpl	#MMU_68060,_mmutype
d1596 2
a1597 2
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush everything
d1599 1
a1599 1
	cmpl	#MMU_68040,_mmutype
d1601 1
a1601 1
	tstl	_mmutype
d1614 1
a1614 1
	cmpl	#MMU_68060,_mmutype
d1629 1
a1629 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1647 1
a1647 1
__DCIA:
d1649 1
a1649 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1658 1
a1658 1
__DCIS:
d1660 1
a1660 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1670 2
a1671 2
__DCIAS:
	cmpl	#MMU_68040,_mmutype	| 68040
d1673 1
a1673 1
	cmpl	#MMU_68060,_mmutype	| 68060
d1681 1
a1681 1
__DCIU:
d1683 1
a1683 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1724 1
a1724 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1740 2
a1741 10
/*
 * Get callers current SP value.
 * Note that simply taking the address of a local variable in a C function
 * doesn't work because callee saved registers may be outside the stack frame
 * defined by A6 (e.g. GCC generated code).
 */
	.globl	_getsp
_getsp:
	movl	sp,d0			| get current SP
	addql	#4,d0			| compensate for return address
d1744 1
a1744 5
	.globl	_getsfc, _getdfc
_getsfc:
	movc	sfc,d0
	rts
_getdfc:
d1751 1
a1751 1
ENTRY(loadustp)       /* XXX - smuprh */
d1756 1
a1756 1
	cmpl	#MMU_68060,_mmutype	| 68040 or 68060?
d1759 1
a1759 1
	cmpl	#MMU_68040,_mmutype
d1762 1
a1762 1
	lea	_protorp,a0		| CRP prototype
d1795 1
a1795 1
	tstb	_ssir			| software interrupt pending?
d1814 1
a1814 1
	cmpl	#MMU_68060,_mmutype	| 68040 or 68060?
d1839 1
a1839 1
	cmpl	#MMU_68060,_mmutype	| 68040 or 68060?
d1869 2
a1870 3
	.globl	_doboot
_doboot:
	lea	tmpstk,sp		| physical SP in case of NMI
d1872 1
a1872 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1891 1
a1891 1
	RELOC(_cputyp, a0)
d1929 1
a1929 2
3:	trap	#15
	.short	MVMEPROM_EXIT		| return to m68kbug
d1933 1
a1933 2
	.globl _intemu60, _fpiemu60, _fpdemu60, _fpeaemu60
_intemu60:
d1936 1
a1936 1
_fpiemu60:
d1939 1
a1939 1
_fpdemu60:
d1942 1
a1942 1
_fpeaemu60:
d1948 1
a1948 2
	.globl	_mmutype,_protorp,_cputype,_fputype
_mmutype:
d1950 1
a1950 1
_cputype:
d1952 1
a1952 1
_fputype:
d1954 1
a1954 1
_protorp:
d1956 1
a1956 2
	.globl	_cold
_cold:
d1958 1
a1958 2
	.globl	_want_resched
_want_resched:
d1960 1
a1960 3
	.globl	_intiobase, _intiolimit, _extiobase
	.globl	_proc0paddr
_proc0paddr:
d1962 1
a1962 1
_intiobase:
d1964 1
a1964 1
_intiolimit:
d1966 1
a1966 1
_extiobase:
d1968 1
d1970 1
a1970 2
	.globl	fulltflush, fullcflush
fulltflush:
d1972 1
a1972 1
fullcflush:
d1975 1
d1977 1
a1977 2
	.globl	_intrcnt,_eintrcnt,_intrnames,_eintrnames
_intrnames:
d1997 1
a1997 1
_eintrnames:
d1999 2
a2000 1
_intrcnt:
d2012 1
a2012 1
_eintrcnt:
@


1.23
log
@Initial code for UVM.  not tested yet...
@
text
@d491 1
a491 1
   RELOC(_protorp, a0)
d1830 1
a1830 1
ENTRY(loadustp)       /* XXX - smurph */
@


1.22
log
@Fix pmap_activate and activation of the
correct pmap.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.21 2000/06/05 11:03:01 art Exp $ */
d459 1
a459 1
   RELOC(_mmutype, a0)
d1830 1
a1830 1
ENTRY(loadustp)       /* XXX - smuprh */
@


1.21
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.20 2000/01/06 03:21:43 smurph Exp $ */
d1442 8
a1449 13
	/* see if pmap_activate needs to be called; should remove this */
	movl	a0@@(P_VMSPACE),a0	| vmspace = p->p_vmspace
#ifdef DIAGNOSTIC
	tstl	a0			| map == VM_MAP_NULL?
	jeq	Lbadsw			| panic
#endif
	lea	a0@@(VM_PMAP),a0		| pmap = &vmspace.vm_pmap
	tstl	a0@@(PM_STCHG)		| pmap->st_changed?
	jeq	Lswnochg		| no, skip
	pea	a1@@			| push pcb (at p_addr)
	pea	a0@@			| push pmap
	jbsr	_pmap_activate		| pmap_activate(pmap, pcb)
	addql	#8,sp
d1451 1
a1451 1
Lswnochg:
a1452 30
	cmpl	#MMU_68040,_mmutype     | 68040 or 68060?
	jle	Lres2                   | yes, goto Lres2
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
	pflusha				| flush entire TLB
	jra	Lres3
Lres2:
	.word	0xf518			| pflusha (68040 and 68060)
|	movl	#CACHE40_ON,d0
|	movc	d0,cacr			| invalidate cache(s)
#ifdef M68060
	cmpl	#MMU_68060,_mmutype     | is 68060?
	jne	Lres3                   | no, skip
	movc	cacr,d2
	orl	#IC60_CUBC,d2		| clear user branch cache entries
	movc	d2,cacr
#endif /* M68060 */
Lres3:
	movl	a1@@(PCB_USTP),d0	| get USTP
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to addr
	cmpl	#MMU_68040,_mmutype     | 68040 or 68060?
	jle	Lres4                   | yes, goto Lres4
	lea	_protorp,a0		| CRP prototype
	movl	d0,a0@@(4)		| stash USTP
	pmove	a0@@,crp			| load new user root pointer
	jra	Lres5
Lres4:
	.long	0x4e7b0806	        | movc d0,URP
Lres5:
d1840 1
d1844 4
a1847 3
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts				|   since pmove flushes TLB
@


1.20
log
@Added support for MVME177 (mc68060)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.19 1998/09/06 20:10:53 millert Exp $ */
d1319 4
a1322 6
	/* Free old process's resources. */
	movl	#USPACE,sp@@-		| size of u-area
	movl	a0@@(P_ADDR),sp@@-	| address of process's u-area
	movl	_kernel_map,sp@@-	| map it was allocated in
	jbsr	_kmem_free		| deallocate it
	lea	sp@@(12),sp		| pop args
@


1.20.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.24 2001/04/05 20:39:39 deraadt Exp $ */
d459 1
a459 1
	RELOC(_mmutype, a0)
d491 1
a491 1
	RELOC(_protorp, a0)
d1319 6
a1324 4
        /* Schedule the vmspace and stack to be freed. */
	movl    a0,sp@@-                 | exit2(p)
	jbsr    _C_LABEL(exit2)
	lea     sp@@(4),sp               | pop args
d1444 13
a1456 8
	/*
	 * Activate process's address space.
	 * XXX Should remember the last USTP value loaded, and call this
	 * XXX only of it has changed.
	 */
	pea	a0@@			| push proc
	jbsr	_pmap_activate		| pmap_activate(p)
	addql	#4,sp	
d1458 1
a1458 1

d1460 30
a1876 1
	pflusha				| flush entire TLB
d1880 3
a1882 4
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
	rts

@


1.20.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.20.2.1 2001/04/18 16:10:39 niklas Exp $ */
a80 16
 * Macro to relocate a symbol, used before MMU is enabled.
 */
#define	_RELOC(var, ar) \
	lea	var,ar

#define	RELOC(var, ar)		_RELOC(_C_LABEL(var), ar)
#define	ASRELOC(var, ar)	_RELOC(_ASM_LABEL(var), ar)

/*
 * Macro to invoke a BUG routine.
 */
#define BUGCALL(id) \
	trap	#15;	\
	.short	id

/*
d88 5
a92 1
ASLOCAL(tmpstk)
d101 7
a107 7
BSS(lowram, 4)
BSS(esym, 4)
BSS(emini, 4)
BSS(smini, 4)
BSS(needprom, 4)
BSS(promvbr, 4)
BSS(promcall, 4)
d110 6
a115 8
/*
GLOBAL(edata)
GLOBAL(etext)
GLOBAL(end)
*/
GLOBAL(kernel_text)

ASENTRY_NOPROFILE(start)
d126 1
a126 1
	ASRELOC(tmpstk, a0)
d129 3
a131 3
	RELOC(edata, a0)		| clear out BSS
	movl	#_C_LABEL(end)-4,d0	| (must be <= 256 kB)
	subl	#_C_LABEL(edata),d0
d137 1
a137 1
	RELOC(promvbr, a0)
d139 1
a139 1
	RELOC(esym, a0)
d143 1
a143 1
        RELOC(lowram, a0)
d147 2
a148 1
	BUGCALL(MVMEPROM_GETBRDID)
d152 1
a152 1
	RELOC(brdid, a0)
d158 1
a158 1
	RELOC(brdid, a1)
d160 1
a160 1
	RELOC(cputyp, a0)
d195 1
a195 1
notsup:	.asciz	"kernel does not support this model."
d203 2
a204 1
	BUGCALL(MVMEPROM_OUTSTRCRLF)
d207 3
a209 2
	BUGCALL(MVMEPROM_EXIT)		| return to m68kbug
	/*NOTREACHED*/
d213 1
a213 1
	RELOC(mmutype, a0)		| no, we have 68030
d216 1
a216 1
	RELOC(cputype, a0)		| no, we have 68030
d228 1
a228 1
	RELOC(myea, a1)
d233 1
a233 1
	RELOC(iiomapsize, a1)
d235 1
a235 1
	RELOC(iiomapbase, a1)
d252 1
a252 1
	RELOC(memsize162, a1)		| how much memory?
d256 1
a256 1
	RELOC(mmutype, a0)
d259 1
a259 1
	RELOC(cputype, a0)		| no, we have 68040
d262 1
a262 1
	RELOC(fputype, a0)
d270 1
a270 1
|	RELOC(needprom,a0)		| this machine needs the prom mapped!
d273 1
a273 1
	RELOC(memsize1x7, a1)		| how much memory?
d277 1
a277 1
	RELOC(mmutype, a0)
d280 1
a280 1
	RELOC(cputype, a0)		| no, we have 68040
d283 1
a283 1
	RELOC(fputype, a0)
d292 1
a292 1
	RELOC(memsize162, a1)		| how much memory?
d301 1
a301 1
	RELOC(mmutype, a0)
d304 1
a304 1
	RELOC(cputype, a0)		| no, we have 68060
d307 1
a307 1
	RELOC(fputype, a0)
d316 1
a316 1
|	RELOC(needprom,a0)		| this machine needs the prom mapped!
d319 1
a319 1
	RELOC(memsize1x7, a1)		| how much memory?
d328 1
a328 1
	RELOC(mmutype, a0)
d331 1
a331 1
	RELOC(cputype, a0)		| no, we have 68060
d334 1
a334 1
	RELOC(fputype, a0)
d341 1
d343 1
a343 1
BSS(rompkt, ROMPKT_LEN)
d347 1
a347 1
	RELOC(iiomapsize, a1)
d349 1
a349 1
	RELOC(iiomapbase, a1)
d353 1
a353 1
	RELOC(rompkt, a0)		| build a .NETCTRL packet
d357 1
a357 1
	RELOC(myea, a1)
d362 2
a363 1
	BUGCALL(MVMEPROM_NETCTRL)	| ask the rom
d371 1
a371 1
	RELOC(rompkt, a0)
d375 2
a376 1
	BUGCALL(MVMEPROM_ENVIRON)	| ask the rom
d402 2
a403 1
	BUGCALL(MVMEPROM_OUTSTRCRLF)
d410 1
a410 1
unkmem:	.asciz	"could not figure out how much memory; assuming 4M."
d424 1
a424 1
	RELOC(maxmem, a0)
d429 1
a429 1
	RELOC(physmem, a0)
a430 1

d432 1
d434 1
a434 1
	RELOC(esym,a0)			| end of static kernel text/data/syms
d438 1
a438 1
	movl	#_C_LABEL(end),d2	| end of static kernel text/data
d459 1
a459 1
	RELOC(mmutype, a0)
d464 1
a464 1
	RELOC(pmap_bootstrap060,a0)
d472 1
a472 1
	RELOC(pmap_bootstrap,a0)
d481 1
a481 1
	RELOC(Sysseg, a0)		| system segment table addr
d484 1
a484 1
	RELOC(mmutype, a0)
d491 1
a491 1
	RELOC(protorp, a0)
d497 1
a497 1
	RELOC(mmutype, a0)
d501 1
a501 1
	RELOC(needprom,a0)
d530 1
a530 1
	RELOC(mmutype, a0)
d549 2
a550 2
	lea	_ASM_LABEL(tmpstk),sp	| temporary stack
	jbsr	_C_LABEL(uvm_setpagesize) | select software page size
d552 1
a552 1
	movl	_C_LABEL(proc0paddr),a1	| get proc0 pcb addr
a553 2
	lea	_C_LABEL(proc0), a2	| initialize proc0.p_addr so that
	movl	a1,a2@@(P_ADDR)		|  we don't deref NULL in trap()
d556 1
a556 1
	movl	a1,_C_LABEL(curpcb)	| proc0 is running
d558 1
a558 1
	tstl	_C_LABEL(fputype)	| Have an FPU?
d562 1
a562 1
	jbsr	_C_LABEL(m68881_restore) | restore it (does not kill a1)
d566 2
a567 2
	jbsr	_C_LABEL(TBIA)		| invalidate TLB
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
d576 1
a576 1
	movl	#_vectab,d2		| set VBR
d579 6
a584 6
	movw	#PSL_LOWIPL,sr		| lower SPL
	movl	d3, _C_LABEL(bootpart)	| save bootpart
	movl	d4, _C_LABEL(bootdevlun) | save bootdevlun
	movl	d5, _C_LABEL(bootctrllun) | save bootctrllun
	movl	d6, _C_LABEL(bootaddr)	| save bootaddr
	movl	d7, _C_LABEL(boothowto)	| save boothowto
d600 1
a600 1
	lea	_C_LABEL(proc0),a0	| save pointer to frame
d603 1
a603 3
	jra	_C_LABEL(main)		| main()
	PANIC("main() returned")
	/* NOTREACHED */
d605 11
a615 8
/*
 * proc_trampoline: call function in register a2 with a3 as an arg
 * and then rei.
 */
GLOBAL(proc_trampoline)
	movl	a3,sp@@-			| push function arg
	jbsr	a2@@			| call function
	addql	#4,sp			| pop arg
d620 1
a620 1
	jra	_ASM_LABEL(rei)		| and return
d622 28
d652 10
d666 1
d668 2
a669 1
ENTRY_NOPROFILE(addrerr4060)
d681 3
a683 2
ENTRY_NOPROFILE(buserr60)
	tstl	_C_LABEL(nofault)	| device probe?
d685 2
a686 2
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
d703 1
a703 1
| we need to adjust for misaligned addresses
d719 3
a721 2
ENTRY_NOPROFILE(buserr40)
	tstl	_C_LABEL(nofault)	| device probe?
d723 2
a724 3
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
d746 6
a751 2
_C_LABEL(buserr):
	tstl	_C_LABEL(nofault)	| device probe?
d753 2
a754 3
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
d757 2
a758 2
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jgt	_C_LABEL(addrerr)	| no, skip
d785 1
a785 1
_C_LABEL(addrerr):
d792 1
a792 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
d867 1
a867 1
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
d870 1
a870 1
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
d875 21
a895 1
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
d900 1
a900 1
ENTRY_NOPROFILE(fpfline)
d902 1
a902 1
	cmpl	#FPU_68040,_C_LABEL(fputype) | 68040 or 68060 FPU?
d905 1
a905 1
	jne	_C_LABEL(illinst)	| no, not an FP emulation
d908 2
a909 1
	jmp	_ASM_LABEL(fpsp_unimp)	| yes, go handle it
d917 1
a917 1
	jra	_ASM_LABEL(fault)	| do it
d919 1
a919 1
	jra	_C_LABEL(illinst)
d922 1
a922 1
ENTRY_NOPROFILE(fpunsupp)
d924 2
a925 2
	cmpl	#FPU_68040,_C_LABEL(fputype) | 68040 or 68060 FPU?
	jlt	_C_LABEL(illinst)	| no, treat as illinst
d927 2
a928 1
	jmp	_ASM_LABEL(fpsp_unsupp)	| yes, go handle it
d936 1
a936 1
	jra	_ASM_LABEL(fault)		| do it
d938 1
a938 1
	jra	_C_LABEL(illinst)
d947 2
a948 1
ENTRY_NOPROFILE(fpfault)
d954 1
a954 1
	movl	_C_LABEL(curpcb),a0 | current pcb
d959 1
a959 1
	cmpl	#CPU_68040,_C_LABEL(cputype)
d971 1
a971 1
	jra	_ASM_LABEL(faultstkadj)	| call trap and deal with stack cleanup
d973 2
a974 5
/*
 * Other exceptions only cause four and six word stack frame and require
 * no post-trap stack adjustment.
 */
ENTRY_NOPROFILE(hardtrap)
d981 1
a981 1
	jbsr	_C_LABEL(hardintr)	| doit
d984 1
a984 1
	jra	_ASM_LABEL(rei)		| all done
d986 2
a987 1
ENTRY_NOPROFILE(badtrap)
d992 1
a992 1
	jbsr	_C_LABEL(straytrap)	| report
d995 1
a995 1
	jra	_ASM_LABEL(rei)		| all done
d997 2
a998 1
ENTRY_NOPROFILE(trap0)
d1004 1
a1004 1
	jbsr	_C_LABEL(syscall)	| handle it
d1006 1
a1006 1
	tstl	_C_LABEL(astpending)
d1008 1
a1008 1
	tstb	_C_LABEL(ssir)
d1011 1
a1011 1
	tstb	_C_LABEL(ssir)
d1023 1
a1023 1
ENTRY_NOPROFILE(trap1)
d1029 1
a1029 1
ENTRY_NOPROFILE(trap2)
d1037 2
a1038 1
ENTRY_NOPROFILE(trap12)
d1042 1
a1042 1
	jbsr	_C_LABEL(cachectl)	| do it
d1044 1
a1044 22
	jra	_ASM_LABEL(rei)		| all done

/*
 * Trace (single-step) trap (trap 1 or 2) instruction. Kernel-mode is
 * special. User mode traps are simply passed on to trap().
 */
ENTRY_NOPROFILE(trace)
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRACE,d0

	| Check PSW and see what happened.
	|   T=0 S=0	(should not happen)
	|   T=1 S=0	trace trap from user mode
	|   T=0 S=1	trace trap on a trap instruction
	|   T=0 S=0	trace trap from system mode (kernel breakpoint)

	movw	sp@@(FR_HW),d1		| get SSW
	notw	d1			| XXX no support for T0 on 680[234]0
	andw	#PSL_S,d1		| from system mode (T=1, S=1)?
	jeq	Lkbrkpt			| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault
d1048 1
a1048 2
 *	- GDB breakpoints (in user programs)
 *	- KGDB breakpoints (in the kernel)
d1053 2
a1054 2
ENTRY_NOPROFILE(trap15)
	clrl	sp@@-			| stack adjust count
d1056 1
a1056 2

	tstl	_C_LABEL(promcall)
d1066 1
a1066 1
	movl	_C_LABEL(promvbr),a0
d1075 1
d1078 9
a1086 3
	andw	#PSL_S,d1		| from system mode?
	jne	Lkbrkpt			| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault
d1088 7
a1094 31
Lkbrkpt: | Kernel-mode breakpoint or trace trap. (d0=trap_type)
	| Save the system sp rather than the user sp.
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	lea	sp@@(FR_SIZE),a6		| Save stack pointer
	movl	a6,sp@@(FR_SP)		|   from before trap

	| If we are not on tmpstk switch to it.
	| (so debugger can change the stack pointer)
	movl	a6,d1
	cmpl	#_ASM_LABEL(tmpstk),d1
	jls	Lbrkpt2			| already on tmpstk
	| Copy frame to the temporary stack
	movl	sp,a0			| a0=src
	lea	_ASM_LABEL(tmpstk)-96,a1 | a1=dst
	movl	a1,sp			| sp=new frame
	moveq	#FR_SIZE,d1
Lbrkpt1:
	movl	a0@@+,a1@@+
	subql	#4,d1
	bgt	Lbrkpt1

Lbrkpt2:
	| Call the trap handler for the kernel debugger.
	| Do not call trap() to do it, so that we can
	| set breakpoints in trap() if we want.  We know
	| the trap type is either T_TRACE or T_BREAKPOINT.
	| If we have both DDB and KGDB, let KGDB see it first,
	| because KGDB will just return 0 if not connected.
	| Save args in d2, a2
	movl	d0,d2			| trap type
	movl	sp,a2			| frame ptr
d1096 7
a1102 7
	| Let KGDB handle it (if connected)
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
	jbsr	_C_LABEL(kgdb_trap)	| handle the trap
	addql	#8,sp			| pop args
	cmpl	#0,d0			| did kgdb handle it?
	jne	Lbrkpt3			| yes, done
d1104 2
a1105 25
#ifdef DDB
	| Let DDB handle it
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
	jbsr	_C_LABEL(kdb_trap)	| handle the trap
	addql	#8,sp			| pop args
	cmpl	#0,d0			| did ddb handle it?
	jne	Lbrkpt3			| yes, done
#endif
	| Drop into the prom
	BUGCALL(MVMEPROM_EXIT)
Lbrkpt3:
	| The stack pointer may have been modified, or
	| data below it modified (by kgdb push call),
	| so push the hardware frame at the current sp
	| before restoring registers and returning.

	movl	sp@@(FR_SP),a0		| modified sp
	lea	sp@@(FR_SIZE),a1		| end of our frame
	movl	a1@@-,a0@@-		| copy 2 longs with
	movl	a1@@-,a0@@-		| ... predecrement
	movl	a0,sp@@(FR_SP)		| sp = h/w frame
	moveml	sp@@+,#0x7FFF		| restore all but sp
	movl	sp@@,sp			| ... and sp
	rte				| all done
a1106 1
/* Use common m68k sigreturn */
d1114 4
a1117 4
ENTRY_NOPROFILE(spurintr)
	addql	#1,_C_LABEL(intrcnt)+0
	addql	#1,_C_LABEL(uvmexp)+UVMEXP_INTRS
	jra	_ASM_LABEL(rei)		| all done
d1132 5
a1136 5

BSS(ssir,1)

ASENTRY_NOPROFILE(rei)
	tstl	_C_LABEL(astpending)	| AST pending?
d1150 1
a1150 1
	jbsr	_C_LABEL(trap)		| go handle it
d1171 1
a1171 1
	tstb	_C_LABEL(ssir)		| SIR pending?
d1180 1
a1180 1
	tstb	_C_LABEL(ssir)		| too late?
d1190 1
a1190 1
	jbsr	_C_LABEL(trap)		| go handle it
d1202 3
d1206 6
a1211 1
 * Use common m68k signal trampoline.
d1213 3
a1215 1
#include <m68k/m68k/sigcode.s>
d1218 3
a1220 1
 * Use common m68k support routines.
d1222 33
a1254 1
#include <m68k/m68k/support.s>
d1257 3
a1259 1
 * Use common m68k process manipulation routines.
d1261 36
a1296 1
#include <m68k/m68k/proc_subr.s>
d1298 2
d1301 2
a1302 2
GLOBAL(curpcb)
GLOBAL(masterpaddr)		| XXX compatibility (debuggers)
d1304 1
a1304 2

ASLOCAL(mdpflag)
d1307 2
a1308 2

ASBSS(nullpcb,SIZEOF_PCB)
d1316 2
a1317 3
	| save state into garbage pcb
	movl	#_ASM_LABEL(nullpcb),_C_LABEL(curpcb)
	lea	_ASM_LABEL(tmpstk),sp	| goto a tmp stack
d1324 1
a1324 1
	jra	_C_LABEL(cpu_switch)
d1330 2
a1331 1
ASENTRY_NOPROFILE(Idle)
d1334 2
a1335 2
	movl	_C_LABEL(whichqs),d0
	jeq	_ASM_LABEL(Idle)
d1339 2
a1340 1
	PANIC("switch")
d1355 1
a1355 1
	movl	_C_LABEL(curpcb),a0	| current pcb
d1357 1
d1359 1
a1359 1
	movl	_C_LABEL(curproc),sp@@-	| remember last proc running
d1361 1
a1361 2
	clrl	_C_LABEL(curproc)

d1367 2
a1368 2
	movl	_C_LABEL(whichqs),d0
	jeq	_ASM_LABEL(Idle)
d1378 1
a1378 1
	addl	#_C_LABEL(qs),d1	| locate queue (q)
d1388 1
a1388 1
	movl	_C_LABEL(whichqs),d1
d1390 1
a1390 1
	movl	d1,_C_LABEL(whichqs)
d1392 2
a1393 2
	movl	a0,_C_LABEL(curproc)
	clrl	_C_LABEL(want_resched)
d1402 1
a1402 1
        movl	_C_LABEL(curpcb),a1
d1407 1
a1407 1
	tstl	_C_LABEL(fputype)	| do we have any FPU?
d1413 1
a1413 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | is 68060?
d1438 1
a1438 2
	| low byte of p_md.md_flags
	movb	a0@@(P_MD_FLAGS+3),_ASM_LABEL(mdpflag)
d1440 1
a1440 1
	movl	a1,_C_LABEL(curpcb)
d1448 1
a1448 1
	jbsr	_C_LABEL(pmap_activate)	| pmap_activate(p)
d1450 1
a1450 3
	movl	_C_LABEL(curpcb),a1	| restore p_addr

	lea	_ASM_LABEL(tmpstk),sp	| now goto a tmp stack for NMI
d1452 1
a1455 1

d1457 1
a1457 1
	tstl	_C_LABEL(fputype)	| do we _have_ any fpu?
d1466 1
a1466 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | is 68060?
d1506 1
a1506 1
	tstl	_C_LABEL(fputype)
d1537 1
a1537 1
	movl	_C_LABEL(curpcb),a1	| current pcb
d1557 1
a1557 1
	movl	_C_LABEL(curpcb),a1	| current pcb
d1566 2
a1567 2
_C_LABEL(_TBIA):
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060?
d1570 1
a1570 1
	tstl	_C_LABEL(mmutype)
d1579 1
a1579 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | is 68060?
d1594 2
a1595 2
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush entire TLB
d1598 1
a1598 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060 ?
d1600 1
a1600 1
	tstl	_C_LABEL(mmutype)
d1617 1
a1617 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | is 68060?
d1631 2
a1632 2
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush everything
d1634 1
a1634 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060 ?
d1636 1
a1636 1
	tstl	_C_LABEL(mmutype)
d1649 1
a1649 1
	cmpl	#MMU_68060,_C_LABEL(mmutype)
d1663 2
a1664 2
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush everything
d1666 1
a1666 1
	cmpl	#MMU_68040,_C_LABEL(mmutype)
d1668 1
a1668 1
	tstl	_C_LABEL(mmutype)
d1681 1
a1681 1
	cmpl	#MMU_68060,_C_LABEL(mmutype)
d1696 1
a1696 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
d1714 1
a1714 1
_C_LABEL(_DCIA):
d1716 1
a1716 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
d1725 1
a1725 1
_C_LABEL(_DCIS):
d1727 1
a1727 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
d1737 2
a1738 2
_C_LABEL(_DCIAS):
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
d1740 1
a1740 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | 68060
d1748 1
a1748 1
_C_LABEL(_DCIU):
d1750 1
a1750 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
d1791 1
a1791 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
d1807 14
a1820 1
ENTRY(getsfc)
d1823 1
a1823 2

ENTRY(getdfc)
d1830 1
a1830 1
ENTRY(loadustp)       /* XXX - smurph */
d1835 1
a1835 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | 68040 or 68060?
d1838 1
a1838 1
	cmpl	#MMU_68040,_C_LABEL(mmutype)
d1841 1
a1841 1
	lea	_C_LABEL(protorp),a0	| CRP prototype
d1874 1
a1874 1
	tstb	_C_LABEL(ssir)		| software interrupt pending?
d1893 1
a1893 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | 68040 or 68060?
d1918 1
a1918 1
	cmpl	#MMU_68060,_C_LABEL(mmutype) | 68040 or 68060?
d1948 3
a1950 2
ENTRY_NOPROFILE(doboot)
	lea	_ASM_LABEL(tmpstk),sp	| physical SP in case of NMI
d1952 1
a1952 1
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
d1971 1
a1971 1
	RELOC(cputyp, a0)
d2009 2
a2010 1
3:	BUGCALL(MVMEPROM_EXIT)		| return to m68kbug
d2014 2
a2015 1
GLOBAL(intemu60)
d2018 1
a2018 1
GLOBAL(fpiemu60)
d2021 1
a2021 1
GLOBAL(fpdemu60)
d2024 1
a2024 1
GLOBAL(fpeaemu60)
d2030 2
a2031 1
GLOBAL(mmutype)
d2033 1
a2033 1
GLOBAL(cputype)
d2035 1
a2035 1
GLOBAL(fputype)
d2037 1
a2037 1
GLOBAL(protorp)
d2039 2
a2040 1
GLOBAL(cold)
d2042 2
a2043 1
GLOBAL(want_resched)
d2045 3
a2047 1
GLOBAL(proc0paddr)
d2049 1
a2049 1
GLOBAL(intiobase)
d2051 1
a2051 1
GLOBAL(intiolimit)
d2053 1
a2053 1
GLOBAL(extiobase)
a2054 1

d2056 2
a2057 1
ASGLOBAL(fulltflush)
d2059 1
a2059 1
ASGLOBAL(fullcflush)
a2061 1

d2063 2
a2064 1
GLOBAL(intrnames)
d2084 1
a2084 1
GLOBAL(eintrnames)
d2086 1
a2086 2

GLOBAL(intrcnt)
d2098 1
a2098 1
GLOBAL(eintrcnt)
@


1.20.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.20.2.2 2001/07/04 10:19:38 niklas Exp $ */
a78 1
#include <machine/trap.h>
d1724 6
@


1.20.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d468 10
d577 4
a580 2
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060?
	jle	Lnocache0		| yes, cache already on
d810 1
a810 1
					| (we dont separate data/program)
d1341 2
a1342 2
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(FPF_FPCR)	| save FP control registers
d1348 4
a1351 4
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a2@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a2@@(FPF_FPSR)
	fmovem	fpi,a2@@(FPF_FPI)
d1397 2
a1398 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1409 4
a1412 4
	fmovem	a0@@(FPF_FPCR),fpcr	| restore FP control registers
	fmovem	a0@@(FPF_FPSR),fpsr
	fmovem	a0@@(FPF_FPI),fpi
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1443 2
a1444 2
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1451 4
a1454 4
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a0@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a0@@(FPF_FPSR)
	fmovem	fpi,a0@@(FPF_FPI)
d1664 4
a1667 2
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040 or 68060
	jle	Ldciasx
d1806 2
a1807 2
	fmovem fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1815 4
a1818 4
	fmovem fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a0@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a0@@(FPF_FPSR)
	fmovem	fpi,a0@@(FPF_FPI)
d1831 2
a1832 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1841 4
a1844 4
	fmovem	a0@@(FPF_FPCR),fpcr	| restore FP control registers
	fmovem	a0@@(FPF_FPSR),fpsr
	fmovem	a0@@(FPF_FPI),fpi
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
@


1.20.2.5
log
@Sync the SMP branch with 3.3
@
text
@d287 1
d333 1
d376 27
d535 1
a535 1
        movl	#CACHE40_ON,d0
a604 51
#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined(MVME172)
/*
 * Figure out the size of onboard DRAM by querying the memory controller(s).
 * This has to be done in locore as badaddr() can not yet be used at this
 * point.
 */
GLOBAL(memsize1x7)
	movl	#0xfff43008,a0		| MEMC040/MEMECC Controller #1
	jbsr	memc040read
	movl	d0,d2

	movl	#0xfff43108,a0		| MEMC040/MEMECC Controller #2
	jbsr	memc040read
	addl	d0,d2

	rts

/*
 * Probe for a memory controller ASIC (MEMC040 or MEMECC) at the
 * address in a0. If found, return the size in bytes of any RAM
 * controller by the ASIC in d0. Otherwise return zero.
 */
ASLOCAL(memc040read)
	moveml	d1-d2/a1-a2,sp@@-	| save scratch regs
	movc	vbr,d2			| Save vbr
	RELOC(vectab,a2)		| Install our own vectab, temporarily
	movc	a2,vbr
	ASRELOC(Lmemc040berr,a1)	| get address of bus error handler
	movl	a2@@(8),sp@@-		| Save current bus error handler addr
	movl	a1,a2@@(8)		| Install our own handler
	movl	sp,d0			| Save current stack pointer value
	movql	#0x07,d1
	andb	a0@@,d1			| Access MEMC040/MEMECC
	movl	#0x400000,d0
	lsll	d1,d0			| Convert to memory size, in bytes
Lmemc040ret:
	movc	d2,vbr			| Restore original vbr
	movl	sp@@+,a2@@(8)		| Restore original bus error handler
	moveml	sp@@+,d1-d2/a1-a2
	rts
/*
 * If the memory controller doesn't exist, we get a bus error trying
 * to access a0@@ above. Control passes here, where we flag 'no bytes',
 * ditch the exception frame and return as normal.
 */
Lmemc040berr:
	movl	d0,sp			| Get rid of the exception frame
	clrl	d0			| No ASIC at this location, then!
	jbra	Lmemc040ret		| Done
#endif

d1324 1
a1324 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
d1380 1
a1380 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
d1426 1
a1426 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
d1749 1
a1749 1
	.word	0xf518			| pflusha
d1787 1
a1787 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
d1812 1
a1812 1
	cmpl	#FPU_68060,_C_LABEL(fputype) | is 68060?
@


1.20.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.20.2.5 2003/03/27 23:32:17 niklas Exp $ */
d15 6
d50 5
a54 1
 * 3. Neither the name of the University nor the names of its contributors
d1910 1
a1910 1
	orl	#0x00800000,d0		| ok, assert VME2_TCTL_SRST
@


1.20.2.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a266 4
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr40),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)

a286 4
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr40),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)

a310 4
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr60),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)

a336 4
	RELOC(vectab, a1)
	movl	#_C_LABEL(buserr60),a1@@(8)
	movl	#_C_LABEL(addrerr4060),a1@@(12)

d415 1
a415 1
	| insane pmap_bootstrap bug I cannot find (68040-specific)
d551 1
a551 1
 * main() never returns; we exit to user mode from a forked process
d651 5
a682 5
	jeq	Lbuserr60		| no, handle as usual
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lbuserr60:
	tstl	_C_LABEL(nofault)	| device probe?
d684 1
a684 2
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
d688 6
d709 1
a709 1
	jeq	Lbuserr40		| no, handle as usual
d712 3
a714 1
Lbuserr40:        
d716 1
a716 1
	jeq	Lisberr			| it is a bus error
d720 29
d750 1
a750 2

ENTRY_NOPROFILE(busaddrerr2030)
d756 8
a983 1
	movl	_C_LABEL(curproc),sp@@-	| push proc pointer
d985 1
a985 1
	lea	sp@@(16),sp		| pop args
@


1.19
log
@Preserve symbol table if ksyms is in the kernel but DDB is not.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.18 1998/03/01 00:37:41 niklas Exp $ */
d5 1
d142 2
a143 1
	RELOC(_lowram, a0)
d181 5
a185 1
	cmpw	#CPU_177, d0
d189 5
d289 24
d315 1
d318 1
a318 1

d322 5
d333 3
d340 1
a340 1
#if defined(MVME162) || defined(MVME167) || defined(MVME177)
d422 1
a422 1
	moveq	#PGSHIFT,d2
d434 1
a434 1
	RELOC(_esym,a0)			| end of static kernel test/data/syms
d457 14
a470 1
	pea	a5@@			| firstpa
d480 1
d485 2
a486 2
	cmpl	#MMU_68040,a0@@		| 68040?
	jne	Lmotommu1		| no, skip
d488 1
d491 1
a491 1
	RELOC(_protorp, a0)
d497 3
a499 3
	RELOC(_mmutype, a0)
	cmpl	#MMU_68040,a0@@		| 68040?
	jne	Lmotommu2		| no, skip
d527 1
a527 1
	movl	#0x8000,d0
d529 9
a537 1
	movl	#0x80008000,d0
d569 2
d575 2
a576 1
	movl	#_vectab,d2		| set VBR
d578 2
a579 1
	movw	#PSL_LOWIPL,sr		| lower SPL
d661 84
d748 1
a748 2
 */ 

d756 1
a756 1
#if defined(M68040)
d758 1
a758 1
	jne	_addrerr		| no, skip
d791 1
a791 1
#if defined(M68040)
d793 1
a793 1
	jne	Lbenot040		| no, skip
d901 3
a903 3
#if defined(M68040)
	cmpl	#FPU_68040,_fputype	| 68040 FPU?
	jne	Lfp_unimp		| no, skip FPSP
d912 1
a912 1
#endif/* M68040 */
d923 3
a925 3
#if defined(M68040)
	cmpl	#FPU_68040,_fputype	| 68040 FPU?
	jne	_illinst		| no, treat as illinst
d960 1
a960 1
	jle	Lfptnull
a972 74
/*
 * Coprocessor and format errors can generate mid-instruction stack
 * frames and cause signal delivery hence we need to check for potential
 * stack adjustment.
 */
_coperr:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-
	movl	usp,a0		| get and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	clrl	sp@@-		| or code arg
	movl	#T_COPERR,sp@@-	| push trap type
	jra	Ltrapnstkadj	| call trap and deal with stack adjustments

_fmterr:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-
	movl	usp,a0		| get and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	clrl	sp@@-		| or code arg
	movl	#T_FMTERR,sp@@-	| push trap type
	jra	Ltrapnstkadj	| call trap and deal with stack adjustments

/*
 * Other exceptions only cause four and six word stack frame and require
 * no post-trap stack adjustment.
 */
_illinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_ILLINST,d0
	jra	fault

_zerodiv:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_ZERODIV,d0
	jra	fault

_chkinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_CHKINST,d0
	jra	fault

_trapvinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRAPVINST,d0
	jra	fault

_privinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_PRIVINST,d0
	jra	fault

	.globl	fault
fault:
	movl	usp,a0			| get and save
	movl	a0,sp@@(FR_SP)		|   the user stack pointer
	clrl	sp@@-			| no VA arg
	clrl	sp@@-			| or code arg
	movl	d0,sp@@-			| push trap type
	jbsr	_trap			| handle trap
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most user regs
	addql	#8,sp			| pop SP and stack adjust
	jra	rei			| all done

d1359 1
a1363 1

d1404 1
a1404 1
	movl	_curpcb,a1
d1408 4
a1411 3

	tstl	_fputype		| If we don't have an FPU,
	jeq	Lswnofpsave		|  don't try to save it.
d1414 4
d1422 10
a1432 1

a1458 1

d1460 2
a1461 11
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lres1a			| no, skip
	.word	0xf518			| yes, pflusha
	movl	a1@@(PCB_USTP),d0	| get USTP
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to addr
	.long	0x4e7b0806		| movc d0,urp
	jra	Lcxswdone
Lres1a:
#endif
d1465 13
d1481 2
d1486 4
a1489 1
Lcxswdone:
d1493 8
a1500 3

	tstl	_fputype		| If we don't have an FPU,
	jeq	Lnofprest		|  don't try to restore it.
d1502 4
d1507 1
a1507 8
	jeq	Lresfprest		| yes, easy
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lresnot040		| no, skip
	clrl	sp@@-			| yes...
	frestore sp@@+			| ...magic!
Lresnot040:
#endif
d1510 1
a1510 1
Lresfprest:
a1511 1
Lnofprest:
d1516 16
d1542 4
a1545 3

	tstl	_fputype		| If we don't have an FPU,
	jeq	Lsvnofpsave		|  don't try to save it.
d1548 4
d1553 1
a1553 1
	jeq	Lsvnofpsave		| yes, all done
d1556 12
a1567 1
Lsvnofpsave:
d1571 1
a1571 1
#if defined(M68040)
d1604 4
a1607 8
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lmotommu3		| no, skip
	.word	0xf518			| yes, pflusha
	rts
Lmotommu3:
#endif
	tstl	_mmutype		| what mmu?
d1613 12
a1633 17
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lmotommu4		| no, skip
	movl	sp@@(4),a0
	movc	dfc,d1
	moveq	#1,d0			| user space
	movc	d0,dfc
	.word	0xf508			| pflush a0@@
	moveq	#5,d0			| super space
	movc	d0,dfc
	.word	0xf508			| pflush a0@@
	movc	d1,dfc
	rts
Lmotommu4:
#endif
	tstl	_mmutype		| is 68851?
	jpl	Lmc68851b		| 
d1635 4
d1646 16
d1671 10
a1680 4
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lmotommu5		| no, skip
	.word	0xf518			| yes, pflusha (for now) XXX
d1682 10
a1691 1
Lmotommu5:
a1692 3
	pflush	#4,#4			| flush supervisor TLB entries
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
d1703 4
a1706 7
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lmotommu6		| no, skip
	.word	0xf518			| yes, pflusha (for now) XXX
	rts
Lmotommu6:
#endif
d1711 15
d1731 1
a1731 1
#if defined(M68040)
d1734 1
a1734 1
	jne	Lmotommu7		| no, skip
d1752 1
a1752 1
#if defined(M68040)
d1754 1
a1754 1
	jne	Lmotommu8		| no, skip
d1763 1
a1763 1
#if defined(M68040)
d1765 1
a1765 1
	jne	Lmotommu9		| no, skip
d1777 2
d1786 1
a1786 1
#if defined(M68040)
d1788 1
a1788 1
	jne	LmotommuA		| no, skip
d1795 1
a1795 1
#if defined(M68040)
d1826 1
a1826 1
#if defined(M68040)
d1829 1
a1829 1
	jne	LmotommuB		| no, skip
d1867 1
a1867 1
ENTRY(loadustp)
d1871 3
a1873 7
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	LmotommuC		| no, skip
	.word	0xf518			| pflusha XXX TDR
	.long	0x4e7b0806		| movc d0,urp
	rts
LmotommuC:
d1875 2
a1876 1
	pflusha				| XXX TDR
d1883 10
d1921 2
d1927 4
d1938 12
d1952 4
d1964 13
d1986 1
a1986 1
#if defined(M68040)
d1988 1
a1988 1
	jne	Lbootnot040		| no, skip
d2048 16
d2109 10
d2123 10
@


1.18
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.17 1997/07/27 09:10:55 deraadt Exp $ */
d75 1
d389 1
a389 1
#ifdef DDB
@


1.17
log
@sync to use m68k code
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.16 1997/03/31 00:24:13 downsj Exp $ */
d515 3
@


1.16
log
@Modernize OpenBSD/mvme68k to match various changes in m68k and hp300 code.

Compiles, but untested for lack of hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.15 1997/02/10 17:49:12 deraadt Exp $ */
d75 1
d940 1
a940 1
	jra	sigreturn
d946 1
a946 1
	jra	_trace
a1116 21

/*
 * Primitives
 */ 

#ifdef __STDC__
#define EXPORT(name)		.globl _ ## name; _ ## name:
#else
#define EXPORT(name)		.globl _/**/name; _/**/name:
#endif
#ifdef GPROF
#if __GNUC__ >= 2
#define	ENTRY(name)		EXPORT(name) link a6,\#0; jbsr mcount; unlk a6
#else
#define	ENTRY(name)		EXPORT(name) link a6,#0; jbsr mcount; unlk a6
#endif
#define ALTENTRY(name, rname)	ENTRY(name); jra rname+12
#else
#define	ENTRY(name)		EXPORT(name)
#define ALTENTRY(name, rname) 	ENTRY(name)
#endif
@


1.15
log
@make it work
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.14 1997/02/10 11:39:25 downsj Exp $ */
d249 3
d270 3
d488 3
a490 1
#ifdef FPCOPROC
d495 1
a495 1
#endif
d743 2
d747 1
d751 4
a754 1
#else
a758 1
#endif
d765 1
a765 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d770 4
a773 1
#else
a777 1
#endif
a789 1
#ifdef FPCOPROC
d798 5
a812 3
#else
	jra	_badtrap	| treat as an unexpected trap
#endif
d936 1
a936 5
 * Routines for traps 1 and 2.  The meaning of the two traps depends
 * on whether we are an HPUX compatible process or a native 4.3 process.
 * Our native 4.3 implementation uses trap 1 as sigreturn() and trap 2
 * as a breakpoint trap.  HPUX uses trap 1 for a breakpoint, so we have
 * to make adjustments so that trap 2 is used for sigreturn.
d939 1
a939 7
#ifdef COMPAT_HPUX
	btst	#MDP_TRCB,mdpflag	| being traced by an HPUX process?
	jeq	sigreturn		| no, trap1 is sigreturn
	jra	_trace			| yes, trap1 is breakpoint
#else
	jra	sigreturn		| no, trap1 is sigreturn
#endif
d941 3
d945 1
a945 7
#ifdef COMPAT_HPUX
	btst	#MDP_TRCB,mdpflag	| being traced by an HPUX process?
	jeq	_trace			| no, trap2 is breakpoint
	jra	sigreturn		| yes, trap2 is sigreturn
#else
	jra	_trace			| no, trap2 is breakpoint
#endif
d1138 2
a1139 16
/*
 * non-local gotos
 */
ENTRY(setjmp)
	movl	sp@@(4),a0	| savearea pointer
	moveml	#0xFCFC,a0@@	| save d2-d7/a2-a7
	movl	sp@@,a0@@(48)	| and return address
	moveq	#0,d0		| return 0
	rts

ENTRY(longjmp)
	movl	sp@@(4),a0
	moveml	a0@@+,#0xFCFC
	movl	a0@@,sp@@
	moveq	#1,d0
	rts
d1284 1
a1284 1
 * NOTE: On the mc68851 (318/319/330) we attempt to avoid flushing the
d1344 3
a1346 1
#ifdef FPCOPROC
a1353 1
#endif
d1407 3
a1409 1
#ifdef FPCOPROC
d1424 1
a1424 1
#endif
d1439 3
a1441 1
#ifdef FPCOPROC
a1448 1
#endif
a1755 25
ENTRY(_insque)
	movw	sr,d0
	movw	#PSL_HIGHIPL,sr		| atomic
	movl	sp@@(8),a0		| where to insert (after)
	movl	sp@@(4),a1		| element to insert (e)
	movl	a0@@,a1@@			| e->next = after->next
	movl	a0,a1@@(4)		| e->prev = after
	movl	a1,a0@@			| after->next = e
	movl	a1@@,a0
	movl	a1,a0@@(4)		| e->next->prev = e
	movw	d0,sr
	rts

ENTRY(_remque)
	movw	sr,d0
	movw	#PSL_HIGHIPL,sr		| atomic
	movl	sp@@(4),a0		| element to remove (e)
	movl	a0@@,a1
	movl	a0@@(4),a0
	movl	a0,a1@@(4)		| e->next->prev = e->prev
	movl	a1,a0@@			| e->prev->next = e->next
	movw	d0,sr
	rts

#ifdef FPCOPROC
a1777 1
#endif
d1851 1
a1851 1
	.globl	_mmutype,_protorp, _cputype
d1856 2
@


1.14
log
@Completely untested mvme68k changes for copypage/zeropage/mappedcopy.
Doesn't really support MAPPEDCOPY.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.13 1997/02/08 10:50:36 deraadt Exp $ */
d203 3
d246 3
d264 3
d280 4
a283 1
	movl	#MMU_68040,a0@@		| XXX TDR FIX FIX with a 68060 MMU
d1884 1
a1884 1
	.globl	_mmutype,_protorp
d1887 2
@


1.13
log
@add _kernel_text
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.12 1997/02/03 15:04:57 deraadt Exp $ */
a1121 32

/*
 * copypage(fromaddr, toaddr)
 *
 * Optimized version of bcopy for a single page-aligned NBPG byte copy.
 */
ENTRY(copypage)
	movl	sp@@(4),a0		| source address
	movl	sp@@(8),a1		| destination address
	movl	#NBPG/32,d0		| number of 32 byte chunks
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lmlloop			| no, use movl
Lm16loop:
	.long	0xf6209000		| move16 a0@@+,a1@@+
	.long	0xf6209000		| move16 a0@@+,a1@@+
	subql	#1,d0
	jne	Lm16loop
	rts
#endif
Lmlloop:
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	subql	#1,d0
	jne	Lmlloop
	rts
@


1.12
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.11 1997/01/28 09:01:02 deraadt Exp $ */
d110 2
@


1.11
log
@deal with siginfo addition
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.10 1996/11/23 23:19:41 kstailey Exp $ */
d530 1
a530 1
 *	sp+4	signal specific code
d532 2
a533 3
 *	sp+12	pointer to siginfo (sip)
 *	sp+16	address of handler
 *	sp+20	saved hardware state
d541 1
a541 1
	movl	sp@@(16),a0		| signal handler addr	(4 bytes)
@


1.10
log
@remrq -> remrunqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.8 1996/05/29 16:37:17 chuck Exp $ */
d532 3
a534 2
 *	sp+12	address of handler
 *	sp+16	saved hardware state
d542 1
a542 1
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
@


1.9
log
@netbsd pr#2547, is@@beverly.rhein.de; handle bus errors correctly
@
text
@d1226 1
a1226 1
ENTRY(remrq)
d1255 1
a1255 1
	.asciz	"remrq"
@


1.8
log
@new generic boot
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d660 10
a669 1
	ptestr	#1,a0@@,#7		| do a table search
d671 13
a683 4
	btst	#7,sp@@			| bus error bit set?
	jeq	Lismerr			| no, must be MMU fault
	clrw	sp@@			| yes, re-clear pad word
	jra	Lisberr			| and process as normal bus error
d690 2
@


1.7
log
@Use generic m68k sigreturn code from arch/m68k
@
text
@d113 7
a119 8
	movl	sp@@(4),d7		| get boothowto
	movl	sp@@(8),d6		| get bootdev
	movl	sp@@(12),a4		| get _esym

	RELOC(_smini,a0)
	movl	sp@@(16),a0@@		| get _smini
	RELOC(_emini,a0)
	movl	sp@@(20),a0@@		| get _emini
d124 7
d134 5
a150 5
	RELOC(_esym, a0)
	movl	a4,a0@@			| store end of symbol table
	RELOC(_lowram, a0)
	movl	a5,a0@@			| store start of physical memory

a366 6
#ifdef MFS
	/* preserve miniroot if it exists */
	RELOC(_emini,a0)		| end of miniroot
	movl	a0@@,d5
	jne	Lstart2
#endif
d369 1
a369 1
	movl	a0@@,d5
d372 1
a372 1
	movl	#_end,d5		| end of static kernel text/data
d374 3
a376 3
	addl	#NBPG-1,d5
	andl	#PG_FRAME,d5		| round to a page
	movl	d5,a4
d485 6
a490 2
	movl	d7,_boothowto		| save reboot flags
	movl	d6,_bootdev		|   and boot device
@


1.6
log
@change to assym.h
@
text
@d981 1
a981 36
/*
 * The sigreturn() syscall comes here.  It requires special handling
 * because we must open a hole in the stack to fill in the (possibly much
 * larger) original stack frame.
 */
sigreturn:
	lea	sp@@(-84),sp		| leave enough space for largest frame
	movl	sp@@(84),sp@@		| move up current 8 byte frame
	movl	sp@@(88),sp@@(4)
	movl	#84,sp@@-		| default: adjust by 84 bytes
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	#SYS_sigreturn,sp@@-	| push syscall number
	jbsr	_syscall		| handle it
	addql	#4,sp			| pop syscall#
	movl	sp@@(FR_SP),a0		| grab and restore
	movl	a0,usp			|   user SP
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	movw	sp@@(FR_ADJ),d0		| do we need to adjust the stack?
	jeq	Lsigr1			| no, just continue
	moveq	#92,d1			| total size
	subw	d0,d1			|  - hole size = frame size
	lea	a1@@(92),a0		| destination
	addw	d1,a1			| source
	lsrw	#1,d1			| convert to word count
	subqw	#1,d1			| minus 1 for dbf
Lsigrlp:
	movw	a1@@-,a0@@-		| copy a word
	dbf	d1,Lsigrlp		| continue
	movl	a0,a1			| new HW frame base
Lsigr1:
	movl	a1,sp@@(FR_SP)		| new SP value
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	jra	rei			| all done
@


1.5
log
@bcopy & friends move to m68k tree
@
text
@d1 1
a1 1
/*	$Id: locore.s,v 1.4 1995/11/07 08:50:19 deraadt Exp $ */
d74 1
a74 1
#include "assym.s"
@


1.4
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
a1813 68
	rts

/*
 * {ov}bcopy(from, to, len)
 *
 * Works for counts up to 128K.
 */
ALTENTRY(ovbcopy, _bcopy)
ENTRY(bcopy)
	movl	sp@@(12),d0		| get count
	jeq	Lcpyexit		| if zero, return
	movl	sp@@(4),a0		| src address
	movl	sp@@(8),a1		| dest address
	cmpl	a1,a0			| src before dest?
	jlt	Lcpyback		| yes, copy backwards (avoids overlap)
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lcfeven			| no, go check dest
	movb	a0@@+,a1@@+		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lcpyexit		| exit if done
Lcfeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lcfbyte			| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lcfbyte			| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lcflloop:
	movl	a0@@+,a1@@+		| copy longwords
	dbf	d1,Lcflloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lcpyexit		| done if none
Lcfbyte:
	subql	#1,d0			| set up for dbf
Lcfbloop:
	movb	a0@@+,a1@@+		| copy bytes
	dbf	d0,Lcfbloop		| til done
Lcpyexit:
	rts
Lcpyback:
	addl	d0,a0			| add count to src
	addl	d0,a1			| add count to dest
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lcbeven			| no, go check dest
	movb	a0@@-,a1@@-		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lcpyexit		| exit if done
Lcbeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lcbbyte			| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lcbbyte			| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lcblloop:
	movl	a0@@-,a1@@-		| copy longwords
	dbf	d1,Lcblloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lcpyexit		| done if none
Lcbbyte:
	subql	#1,d0			| set up for dbf
Lcbbloop:
	movb	a0@@-,a1@@-		| copy bytes
	dbf	d0,Lcbbloop		| til done
@


1.3
log
@fixed 162 reset code from dale
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.40 1995/05/12 18:24:46 mycroft Exp $	*/
d5 28
@


1.2
log
@- bzero/strlen/bcmp
@
text
@d1930 1
a1930 1
	movl	a0@@(60),d0
d1935 1
a1935 1
	movl	d0,a0@@(60)
d1937 6
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/*	$NetBSD: locore.s,v 1.1.1.1.2.1 1995/10/12 20:00:04 chuck Exp $	*/

#undef	STACKCHECK	/* doesn't work any more */
d4 1
a45 13
/*
 * STACKCHECK enables two types of kernel stack checking:
 *	1. stack "overflow".  On every clock interrupt we ensure that
 *	   the current kernel stack has not grown into the user struct
 *	   page, i.e. size exceeded UPAGES-1 pages.
 *	2. stack "underflow".  Before every rte to user mode we ensure
 *	   that we will be exactly at the base of the stack after the
 *	   exception frame has been popped.
 * Both checks are performed at splclock since they operate on the
 * global temporary stack.
 */
/* #define	STACKCHECK */

d47 1
a47 1
#include <mvme68k/mvme68k/vectors.s>
d57 1
d60 253
d314 114
d429 1
a429 3
 * This is where we wind up if the kernel jumps to location 0.
 * (i.e. a bogus PC)  This is known to immediately follow the vector
 * table and is hence at 0x400 (see reset vector in vectors.s).
d431 45
a475 2
	.globl	_panic
	pea	Ljmp0panic
d477 2
a478 3
	/* NOTREACHED */
Ljmp0panic:
	.asciz	"kernel jump to zero"
d481 40
d544 1
a544 1
	cmpl	#-2,_mmutype		| 68040?
d579 1
a579 1
	cmpl	#-2,_mmutype		| 68040?
d686 1
a686 1
	cmpl	#-2,_mmutype		| 68040?
d806 2
a807 2
	.globl	_pcctrap
_pcctrap:
d814 2
a815 2
	jbsr	_pccintr		| doit
	lea	sp@@(12),sp		| pop value args
a850 3
#ifdef STACKCHECK
	jra	Ldorte
#else
a851 1
#endif
d896 1
d902 19
d992 1
a992 11
 * All device interrupts are auto-vectored.  Most
 * interrupt in the range IPL1 to IPL6.  Here are our assignments:
 *
 *	Level 0:	Spurious: ignored.
 *	Level 1:	networking devices (ethernet)
 *	Level 2:	bio devices (scsi)
 *	Level 3:	
 *	Level 4:	Serial (SCC)
 *	Level 5:	Clock
 *	Level 6:	
 *	Level 7:	Non-maskable (none)
a993 1
	.globl	_intrhand, _hardclock, _nmihand
a999 32
_lev1intr:
_lev2intr:
_lev3intr:
_lev4intr:
_lev5intr:
_lev6intr:
	moveml	#0xC0C0,sp@@-
	lea	_intrcnt,a0
	movw	sp@@(22),d0		| use vector offset
	andw	#0xfff,d0		|   sans frame type
	addql	#1,a0@@(-0x60,d0:w)	|     to increment apropos counter
	movw	sr,sp@@-			| push current SR value
	clrw	sp@@-			|    padded to longword
	jbsr	_intrhand		| handle interrupt
	addql	#4,sp			| pop SR
	moveml	sp@@+,#0x0303
	addql	#1,_cnt+V_INTR
	jra	rei

_lev7intr:
	addql	#1,_intrcnt+32
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-		| save registers
	movl	usp,a0			| and save
	movl	a0,sp@@(FR_SP)		|   the user stack pointer
	jbsr	_nmihand		| call handler
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| and remaining registers
	addql	#8,sp			| pop SP and stack adjust
	jra	rei			| all done

a1016 4
#ifdef STACKCHECK
	tstl	_panicstr		| have we paniced?
	jne	Ldorte1			| yes, do not make matters worse
#endif
a1038 3
#ifdef STACKCHECK
	jra	Ldorte
#else
a1039 1
#endif
a1049 3
#ifdef STACKCHECK
	jra	Ldorte
#else
a1050 1
#endif
a1076 3
#ifdef STACKCHECK
	jra	Ldorte
#else
a1077 1
#endif
a1080 36
#ifdef STACKCHECK
	movw	#SPL6,sr		| avoid trouble
	btst	#5,sp@@			| are we returning to user mode?
	jne	Ldorte1			| no, skip it
	movl	a6,tmpstk-20
	movl	d0,tmpstk-76
	moveq	#0,d0
	movb	sp@@(6),d0		| get format/vector
	lsrl	#3,d0			| convert to index
	lea	_exframesize,a6		|  into exframesize
	addl	d0,a6			|  to get pointer to correct entry
	movw	a6@@,d0			| get size for this frame
	addql	#8,d0			| adjust for unaccounted for bytes
	lea	_kstackatbase,a6	| desired stack base
	subl	d0,a6			|   - frame size == our stack
	cmpl	a6,sp			| are we where we think?
	jeq	Ldorte2			| yes, skip it
	lea	tmpstk,a6		| will be using tmpstk
	movl	sp@@(4),a6@@-		| copy common
	movl	sp@@,a6@@-		|   frame info
	clrl	a6@@-
	movl	sp,a6@@-			| save sp
	subql	#4,a6			| skip over already saved a6
	moveml	#0x7FFC,a6@@-		| push remaining regs (d0/a6/a7 done)
	lea	a6@@(-4),sp		| switch to tmpstk (skip saved d0)
	clrl	sp@@-			| is an underflow
	jbsr	_badkstack		| badkstack(0, frame)
	addql	#4,sp
	moveml	sp@@+,#0x7FFF		| restore most registers
	movl	sp@@,sp			| and SP
	rte
Ldorte2:
	movl	tmpstk-76,d0
	movl	tmpstk-20,a6
Ldorte1:
#endif
a1082 247
#ifdef STACKCHECK
/*
 * Kernel access to the current processes kernel stack is via a fixed
 * virtual address.  It is at the same address as in the users VA space.
 */
	.data
	.set	_kstack,USRSTACK
	.set	_kstackatbase,USRSTACK+USPACE-4
	.globl	_kstackatbase
	.globl	_kstack
#endif

#define	RELOC(var, ar) \
	lea	var,ar

/*
 * Initialization
 *
 * The bootstrap loader loads us in starting at 0, and VBR is non-zero.
 * On entry, args on stack are boot device, boot filename, console unit,
 * boot flags (howto), boot device name, filesystem type name.
 */
	.comm	_lowram,4
	.comm	_esym,4

	.text
	.globl	_edata
	.globl	_etext,_end
	.globl	start
start:
	movw	#PSL_HIGHIPL,sr		| no interrupts
	movl	#0,d6			| get bootdev
	movl	sp@@(4),d7		| get boothowto
	RELOC(tmpstk, a0)
	movl	a0,sp			| give ourselves a temporary stack

	lea	_edata,a0		| clear out BSS
	movl	#_end-4,d0		| (must be <= 256 kB)
	subl	#_edata,d0
	lsrl	#2,d0
1:	clrl	a0@@+
	dbra	d0,1b

	RELOC(_esym, a0)
#if 1
	movl	a4,a0@@			| store end of symbol table
#else
	clrl	a0@@			| no symbol table, yet
#endif
	movl	#0,a5			| RAM starts at 0
	RELOC(_lowram, a0)
	movl	a5,a0@@			| store start of physical memory
	movl	#CACHE_OFF,d0
	movc	d0,cacr			| clear and disable on-chip cache(s)

/* determine our CPU/MMU combo - check for all regardless of kernel config */
	movl	#0x200,d0		| data freeze bit
	movc	d0,cacr			|   only exists on 68030
	movc	cacr,d0			| read it back
	tstl	d0			| zero?
	jeq	Lnot68030		| yes, we have 68020/68040
	RELOC(_mmutype, a0)		| no, we have 68030
	movl	#-1,a0@@			| set to reflect 68030 PMMU
	jra	Lstart1
Lnot68030:
	bset	#31,d0			| data cache enable bit
	movc	d0,cacr			|   only exists on 68040
	movc	cacr,d0			| read it back
	tstl	d0			| zero?
	beq	Lis68020		| yes, we have 68020
	moveq	#0,d0			| now turn it back off
	movec	d0,cacr			|   before we access any data
	RELOC(_mmutype, a0)
	movl	#-2,a0@@			| with a 68040 MMU
	jra	Lstart1
Lis68020:
	RELOC(_mmutype, a0)
	movl	#1,a0@@			| no, we have PMMU

Lstart1:
	/* XXXCDC SHUTUP 147 CALL */
	movb	#0, 0xfffe1026		| serial interrupt off
	movb	#0, 0xfffe1018		| timer 1 off
	movb	#0, 0xfffe1028		| ethernet off
	/* XXXCDC SHUTUP 147 CALL */
/* initialize source/destination control registers for movs */
	moveq	#FC_USERD,d0		| user space
	movc	d0,sfc			|   as source
	movc	d0,dfc			|   and destination of transfers
/* initialize memory sizes (for pmap_bootstrap) */
	movl	0xfffe0774,d1		| XXXCDC -- hardwired HEX
	movl	0xfffe0778,_myea	| XXXCDC -- ethernet addr
	moveq	#PGSHIFT,d2
	lsrl	d2,d1			| convert to page (click) number
	RELOC(_maxmem, a0)
	movl	d1,a0@@			| save as maxmem
	movl	a5,d0			| lowram value from ROM via boot
	lsrl	d2,d0			| convert to page number
	subl	d0,d1			| compute amount of RAM present
	RELOC(_physmem, a0)
	movl	d1,a0@@			| and physmem
/* configure kernel and proc0 VA space so we can get going */
	.globl	_Sysseg, _pmap_bootstrap, _avail_start
#ifdef DDB
	RELOC(_esym,a0)			| end of static kernel test/data/syms
	movl	a0@@,d5
	jne	Lstart2
#endif
	movl	#_end,d5		| end of static kernel text/data
Lstart2:
	addl	#NBPG-1,d5
	andl	#PG_FRAME,d5		| round to a page
	movl	d5,a4
	addl	a5,a4			| convert to PA
	movl	#0, sp@@-		| firstpa
	pea	a4@@			| nextpa
	RELOC(_pmap_bootstrap,a0)
	jbsr	a0@@			| pmap_bootstrap(firstpa, nextpa)
	addql	#8,sp

/*
 * Enable the MMU.
 * Since the kernel is mapped logical == physical, we just turn it on.
 */
	RELOC(_Sysseg, a0)		| system segment table addr
	movl	a0@@,d1			| read value (a KVA)
	addl	a5,d1			| convert to PA
	RELOC(_mmutype, a0)
	cmpl	#-2,a0@@			| 68040?
	jne	Lmotommu1		| no, skip
	.long	0x4e7b1807		| movc d1,srp
	jra	Lstploaddone
Lmotommu1:
	RELOC(_protorp, a0)
	movl	#0x80000202,a0@@		| nolimit + share global + 4 byte PTEs
	movl	d1,a0@@(4)		| + segtable address
	pmove	a0@@,srp			| load the supervisor root pointer
	movl	#0x80000002,a0@@		| reinit upper half for CRP loads
Lstploaddone:
	RELOC(_mmutype, a0)
	cmpl	#-2,a0@@			| 68040?
	jne	Lmotommu2		| no, skip
	moveq	#0,d0			| ensure TT regs are disabled
	.long	0x4e7b0004		| movc d0,itt0
	.long	0x4e7b0005		| movc d0,itt1
	.long	0x4e7b0006		| movc d0,dtt0
	.long	0x4e7b0007		| movc d0,dtt1
	.word	0xf4d8			| cinva bc
	.word	0xf518			| pflusha
	movl	#0x8000,d0
	.long	0x4e7b0003		| movc d0,tc
	movl	#0x80008000,d0
	movc	d0,cacr			| turn on both caches
	jmp	Lenab1
Lmotommu2:
	movl	#0x82c0aa00,a2@@		| value to load TC with
	pmove	a2@@,tc			| load it
Lenab1:

/*
 * Should be running mapped from this point on
 */
/* select the software page size now */
	lea	tmpstk,sp		| temporary stack
	jbsr	_vm_set_page_size	| select software page size
/* set kernel stack, user SP, and initial pcb */
	movl	_proc0paddr,a1		| get proc0 pcb addr
	lea	a1@@(USPACE-4),sp	| set kernel stack to end of area
	movl	#USRSTACK-4,a2
	movl	a2,usp			| init user SP
	movl	a1,_curpcb		| proc0 is running
#ifdef FPCOPROC
	clrl	a1@@(PCB_FPCTX)		| ensure null FP context
	movl	a1,sp@@-
	jbsr	_m68881_restore		| restore it (does not kill a1)
	addql	#4,sp
#endif
/* flush TLB and turn on caches */
	jbsr	_TBIA			| invalidate TLB
	cmpl	#-2,_mmutype		| 68040?
	jeq	Lnocache0		| yes, cache already on
	movl	#CACHE_ON,d0
	movc	d0,cacr			| clear cache(s)
Lnocache0:
/* final setup for C code */
	movl	#0x8000,d0		| set VBR XXXCDC
	movc	d0,vbr
	jbsr	_isrinit		| be ready for stray ints
	movw	#PSL_LOWIPL,sr		| lower SPL
	movl	d7,_boothowto		| save reboot flags
	movl	d6,_bootdev		|   and boot device

/*
 * Create a fake exception frame so that cpu_fork() can copy it.
 * main() nevers returns; we exit to user mode from a forked process
 * later on.
 */
	clrw	sp@@-			| vector offset/frame type
	clrl	sp@@-			| PC - filled in by "execve"
	movw	#PSL_USER,sp@@-		| in user mode
	clrl	sp@@-			| stack adjust count and padding
	lea	sp@@(-64),sp		| construct space for D0-D7/A0-A7
	lea	_proc0,a0		| save pointer to frame
	movl	sp,a0@@(P_MD_REGS)	|   in proc0.p_md.md_regs

	jra	_main			| main()

	.globl _proc_trampoline
_proc_trampoline:
	movl	a3@@(P_MD_REGS),sp	| process' frame pointer in sp
	movl    a3,sp@@-
	jbsr    a2@@
	addql   #4,sp
	movl    sp@@(FR_SP),a0           | grab and load
	movl    a0,usp                  |   user SP
	moveml  sp@@+,#0x7FFF            | restore most user regs
	addql   #8,sp                   | toss SP and stack adjust
	jra     rei                     | and return

/*
 * Signal "trampoline" code (18 bytes).  Invoked from RTE setup by sendsig().
 * 
 * Stack looks like:
 *
 *	sp+0 ->	signal number
 *	sp+4	signal specific code
 *	sp+8	pointer to signal context frame (scp)
 *	sp+12	address of handler
 *	sp+16	saved hardware state
 *			.
 *			.
 *	scp+0->	beginning of signal context frame
 */
	.globl	_sigcode, _esigcode, _sigcodetrap
	.data
_sigcode:
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
	jsr	a0@@			| call signal handler	(2 bytes)
	addql	#4,sp			| pop signo		(2 bytes)
_sigcodetrap:
	trap	#1			| special syscall entry	(2 bytes)
	movl	d0,sp@@(4)		| save errno		(4 bytes)
	moveq	#1,d0			| syscall == exit	(2 bytes)
	trap	#0			| exit(errno)		(2 bytes)
	.align	2
_esigcode:

d1114 1
a1114 1
	cmpl	#-2,_mmutype		| 68040?
d1173 6
a1178 6
	tstl    a0@@(P_BACK)
	jne     Lset1
	tstl    a0@@(P_WCHAN)
	jne     Lset1
	cmpb    #SRUN,a0@@(P_STAT)
	jne     Lset1
d1197 2
a1198 2
	movl    #Lset2,sp@@-
	jbsr    _panic
d1200 1
a1200 1
	.asciz  "setrunqueue"
d1213 12
a1224 12
	lsrb    #2,d0
	movl    _whichqs,d1
	btst    d0,d1
	jeq     Lrem2
#endif
	movl    a0@@(P_BACK),a1
	clrl    a0@@(P_BACK)
	movl    a0@@(P_FORW),a0
	movl    a0,a1@@(P_FORW)
	movl    a1,a0@@(P_BACK)
	cmpal   a0,a1
	jne     Lrem1
d1226 2
a1227 2
	lsrb    #2,d0
	movl    _whichqs,d1
d1229 2
a1230 2
	bclr    d0,d1
	movl    d1,_whichqs
d1235 2
a1236 2
	movl    #Lrem3,sp@@-
	jbsr    _panic
d1238 1
a1238 1
	.asciz  "remrq"
d1263 3
a1265 3
	movl    sp@@(4),a0
	movl    #nullpcb,_curpcb        | save state into garbage pcb
	lea     tmpstk,sp               | goto a tmp stack
d1268 5
a1272 5
	movl    #USPACE,sp@@-            | size of u-area
	movl    a0@@(P_ADDR),sp@@-        | address of process's u-area
	movl    _kernel_map,sp@@-        | map it was allocated in
	jbsr    _kmem_free              | deallocate it
	lea     sp@@(12),sp              | pop args
d1284 2
a1285 2
	movl    _whichqs,d0
	jeq     Idle
d1316 3
a1318 3
	movw    #PSL_HIGHIPL,sr         | lock out interrupts
	movl    _whichqs,d0
	jeq     Idle
d1320 21
a1340 21
	movl    d0,d1
	negl    d0
	andl    d1,d0
	bfffo   d0{#0:#32},d1
	eorib   #31,d1

	movl    d1,d0
	lslb    #3,d1                   | convert queue number to index
	addl    #_qs,d1                 | locate queue (q)
	movl    d1,a1
	movl    a1@@(P_FORW),a0          | p = q->p_forw
	cmpal   d1,a0                   | anyone on queue?
	jeq     Lbadsw                  | no, panic
	movl    a0@@(P_FORW),a1@@(P_FORW) | q->p_forw = p->p_forw
	movl    a0@@(P_FORW),a1          | n = p->p_forw
	movl    d1,a1@@(P_BACK)          | n->p_back = q
	cmpal   d1,a1                   | anyone left on queue?
	jne     Lsw2                    | yes, skip
	movl    _whichqs,d1
	bclr    d0,d1                   | no, clear bit
	movl    d1,_whichqs
d1393 1
a1393 1
	lea     tmpstk,sp               | now goto a tmp stack for NMI
d1395 1
a1395 1
	cmpl	#-2,_mmutype		| 68040?
d1423 1
a1423 1
	cmpl	#-2,_mmutype		| 68040?
d1494 1
a1494 1
	cmpl	#-2,_mmutype		| 68040?
d1516 1
a1516 1
	cmpl	#-2,_mmutype		| 68040?
d1550 3
a1552 3
	cmpl    #-2,_mmutype            | 68040?
	jne     Lmotommu5               | no, skip
	.word   0xf518                  | yes, pflusha (for now) XXX
d1570 3
a1572 3
	cmpl    #-2,_mmutype            | 68040?
	jne     Lmotommu6               | no, skip
	.word   0xf518                  | yes, pflusha (for now) XXX
d1587 3
a1589 3
	cmpl    #-2,_mmutype            | 68040
	jne     Lmotommu7               | no, skip
	.word   0xf498                  | cinva ic
d1607 3
a1609 3
	cmpl    #-2,_mmutype            | 68040
	jne     Lmotommu8               | no, skip
	/* XXX implement */
d1618 3
a1620 3
	cmpl    #-2,_mmutype            | 68040
	jne     Lmotommu9               | no, skip
	/* XXX implement */
d1626 10
d1639 3
a1641 3
	cmpl    #-2,_mmutype            | 68040
	jne     LmotommuA               | no, skip
	/* XXX implement */
d1649 2
a1650 2
	movl    sp@@(4),a0               | address
	.word   0xf488                  | cinvl ic,a0@@
d1653 2
a1654 2
	movl    sp@@(4),a0               | address
	.word   0xf490                  | cinvp ic,a0@@
d1657 2
a1658 2
	movl    sp@@(4),a0               | address
	.word   0xf448                  | cinvl dc,a0@@
d1661 2
a1662 2
	movl    sp@@(4),a0               | address
	.word   0xf450                  | cinvp dc,a0@@
d1665 1
a1665 1
	.word   0xf458                  | cinva dc
d1668 2
a1669 2
	movl    sp@@(4),a0               | address
	.word   0xf468                  | cpushl dc,a0@@
d1672 2
a1673 2
	movl    sp@@(4),a0               | address
	.word   0xf470                  | cpushp dc,a0@@
d1680 3
a1682 3
	cmpl    #-2,_mmutype            | 68040
	jne     LmotommuB               | no, skip
	.word   0xf478                  | cpusha dc
d1721 1
a1721 1
	moveq	#PGSHIFT, d1
d1724 4
a1727 3
	cmpl    #-2,_mmutype            | 68040?
	jne     LmotommuC               | no, skip
	.long   0x4e7b0806              | movc d0,urp
d1731 1
d1884 2
d1889 1
d1891 7
a1897 2
	cmpl	#-2,_mmutype		| 68040?
	jeq	Lnocache5		| yes, skip
d1901 1
a1901 6
Lnocache5:
	movl	_boothowto,d1		| load howto
	movl	_bootdev,d0		| and devtype
	movl	sp@@(4),d1		| arg
	lea	tmpstk,sp		| physical SP in case of NMI
	movl	#0,a7@@-			| value for pmove to TC (turn off MMU)
d1903 2
a1904 1
	movl	#0, d0
d1906 39
a1944 4
	cmpl	#0, d1			| autoboot?
	jeq	Lauto			| yes
	jmp 	0x4000			| back to sboot
Lauto:	jmp	0x400a			| tell sboot to reboot us
d1949 1
a1949 1
	.long	-1		| default to MMU_68030
d1958 1
a1958 1
	.globl	_intiobase, _intiolimit, _extiobase, _RTCbase
d1992 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 3
a3 1
/*	$NetBSD: locore.s,v 1.40 1995/05/12 18:24:46 mycroft Exp $	*/
a5 1
 * Copyright (c) 1995 Theo de Raadt
d47 13
d61 1
a61 1
#include <machine/prom.h>
a70 1
	.globl	tmpstk
a72 253
#define	RELOC(var, ar) \
	lea	var,ar

/*
 * Initialization
 *
 * The bootstrap loader loads us in starting at 0, and VBR is non-zero.
 * On entry, args on stack are boot device, boot filename, console unit,
 * boot flags (howto), boot device name, filesystem type name.
 */
	.comm	_lowram,4
	.comm	_esym,4
	.comm	_emini,4
	.comm	_smini,4
	.comm	_needprom,4
	.comm	_promvbr,4
	.comm	_promcall,4

	.text
	.globl	_edata
	.globl	_etext,_end
	.globl	start
start:
	movw	#PSL_HIGHIPL,sr		| no interrupts
	movl	#0,a5			| RAM starts at 0
	movl	sp@@(4),d7		| get boothowto
	movl	sp@@(8),d6		| get bootdev
	movl	sp@@(12),a4		| get _esym

	RELOC(_smini,a0)
	movl	sp@@(16),a0@@		| get _smini
	RELOC(_emini,a0)
	movl	sp@@(20),a0@@		| get _emini

	RELOC(tmpstk, a0)
	movl	a0,sp			| give ourselves a temporary stack

	movc	vbr,d0			| save prom's trap #15 vector
	RELOC(_promvbr, a0)
	movl	d0, a0@@

	clrl	sp@@-
	trap	#15
	.short	MVMEPROM_GETBRDID
	movl	sp@@+, a1

	movl	#SIZEOF_MVMEPROM_BRDID, d0	| copy to local variables
	RELOC(_brdid, a0)
1:	movb	a1@@+, a0@@+
	subql	#1, d0
	bne	1b

	RELOC(_esym, a0)
	movl	a4,a0@@			| store end of symbol table
	RELOC(_lowram, a0)
	movl	a5,a0@@			| store start of physical memory

	clrl	d0
	RELOC(_brdid, a1)
	movw	a1@@(MVMEPROM_BRDID_MODEL), d0
	RELOC(_cputyp, a0)
	movl	d0, a0@@			| init _cputyp

#ifdef MVME147
	cmpw	#CPU_147, d0
	beq	is147
#endif

#ifdef MVME162
	cmpw	#CPU_162, d0
	beq	is162
#endif

#ifdef MVME167
	cmpw	#CPU_166, d0
	beq	is167
	cmpw	#CPU_167, d0
	beq	is167
#endif

#ifdef MVME177
	cmpw	#CPU_177, d0
	beq	is177
#endif
	
	.data
notsup:	.ascii	"kernel does not support this model."
notsupend:
	.even
	.text

	| first we bitch, then we die.
	movl	#notsupend, sp@@-
	movl	#notsup, sp@@-
	trap	#15
	.short	MVMEPROM_OUTSTRCRLF
	addql	#8,sp

	trap	#15
	.short	MVMEPROM_EXIT		| return to m68kbug
	/*NOTREACHED */

#ifdef MVME147
is147:
	RELOC(_mmutype, a0)		| no, we have 68030
	movl	#MMU_68030,a0@@		| set to reflect 68030 PMMU

	movl	#CACHE_OFF,d0
	movc	d0,cacr			| clear and disable on-chip cache(s)

	movb	#0, 0xfffe1026		| XXX serial interrupt off
	movb	#0, 0xfffe1018		| XXX timer 1 off
	movb	#0, 0xfffe1028		| XXX ethernet off

	movl	#0xfffe0000, a0		| mvme147 nvram base
	| move nvram component of etheraddr (only last 3 bytes)
	RELOC(_myea, a1)
	movw	a0@@(NVRAM_147_ETHER+0), a1@@(3+0)
	movb	a0@@(NVRAM_147_ETHER+2), a1@@(3+2)
	movl	a0@@(NVRAM_147_EMEM), d1	| pass memory size

	RELOC(_iiomapsize, a1)
	movl	#INTIOSIZE_147, a1@@
	RELOC(_iiomapbase, a1)
	movl	#INTIOBASE_147, a1@@
	bra	Lstart1
#endif

#ifdef MVME162
is162:
#if 0
	| the following 3 things are "just in case". they won't make
	| the kernel work properly, but they will at least let it get
	| far enough that you can figure out that something had an
	| interrupt pending. which the bootrom shouldn't allow, i don't
	| think..
	clrb	0xfff42002 		| XXX MCchip irq off
	clrl	0xfff42018		| XXX MCchip timers irq off
	clrb	0xfff4201d		| XXX MCchip scc irq off
#endif
	RELOC(_memsize162, a1)		| how much memory?
	jbsr	a1@@
	movl	d0, d2

	RELOC(_mmutype, a0)
	movl	#MMU_68040,a0@@		| with a 68040 MMU

	bra	is16x
#endif

#ifdef MVME167
is167:
|	RELOC(_needprom,a0)		| this machine needs the prom mapped!
|	movl	#1,a0@@

	RELOC(_memsize1x7, a1)		| how much memory?
	jbsr	a1@@
	movl	d0, d2

	RELOC(_mmutype, a0)
	movl	#MMU_68040,a0@@		| with a 68040 MMU

	bra	is16x
#endif

#ifdef MVME177
is177:
|	RELOC(_needprom,a0)		| this machine needs the prom mapped!
|	movl	#1,a0@@

	RELOC(_memsize1x7, a1)		| how much memory?
	jbsr	a1@@
	movl	d0, d2

	RELOC(_mmutype, a0)
	movl	#MMU_68040,a0@@		| XXX TDR FIX FIX with a 68060 MMU

	bra	is16x
#endif

#if defined(MVME162) || defined(MVME167) || defined(MVME177)
	.data
#define	ROMPKT_LEN	200
	.comm	_rompkt, ROMPKT_LEN
	.even
	.text
is16x:
	RELOC(_iiomapsize, a1)
	movl	#INTIOSIZE_162, a1@@
	RELOC(_iiomapbase, a1)
	movl	#INTIOBASE_162, a1@@

	/* get ethernet address */
	RELOC(_rompkt, a0)		| build a .NETCTRL packet
	movb	#0, a0@@(NETCTRL_DEV)	| onboard ethernet
	movb	#0, a0@@(NETCTRL_CTRL)	| onboard ethernet
	movl	#NETCTRLCMD_GETETHER, a0@@(NETCTRL_CMD)
	RELOC(_myea, a1)
	movl	a1, a0@@(NETCTRL_ADDR)	| where to put it
	movl	#6, a0@@(NETCTRL_LEN)	| it is 6 bytes long

	movl	a0, sp@@-
	trap	#15
	.short	MVMEPROM_NETCTRL	| ask the rom
	addl	#4, sp

#if 0
	/* 
	 * get memory size using ENVIRON. unfortunately i've not managed
	 * to get this working.
	 */
	RELOC(_rompkt, a0)
	movl	#ENVIRONCMD_READ, sp@@-	| request environment information
	movl	#ROMPKT_LEN, sp@@-	| max length
	movl	a0, sp@@-		| point to info packet
	trap	#15
	.short	MVMEPROM_ENVIRON	| ask the rom
	addl	#12, sp
	| XXX should check return values

	clrl	d2			| memsize = 0
1:	clrl	d0
	movb	a0@@+, d0		| look for a "memsize" chunk in the
	cmpb	#ENVIRONTYPE_EOL, d0	| environment
	beq	3f
	cmpb	#ENVIRONTYPE_MEMSIZE, d0
	beq	2f
	movb	a0@@+, d0
	addl	d0, a0
	bra	1b
2:	movl	a0@@(7), d2		| XXX memory size (fix @@(7) offset!)
3:
#endif

	| if memory size is unknown, print a diagnostic and make an
	| assumption
	movl	d2, d1
	cmpl	#0, d1
	bne	Lstart1

	movl	#unkmemend, sp@@-
	movl	#unkmem, sp@@-
	trap	#15
	.short	MVMEPROM_OUTSTRCRLF
	addql	#8,sp

	movl	#4*1024*1024, d1	| XXX assume 4M of ram
	bra	Lstart1

	.data
unkmem:	.ascii	"could not figure out how much memory; assuming 4M."
unkmemend:
	.even
a73 55

#endif

Lstart1:
/* initialize source/destination control registers for movs */
	moveq	#FC_USERD,d0		| user space
	movc	d0,sfc			|   as source
	movc	d0,dfc			|   and destination of transfers
	moveq	#PGSHIFT,d2
	lsrl	d2,d1			| convert to page (click) number
	RELOC(_maxmem, a0)
	movl	d1,a0@@			| save as maxmem
	movl	a5,d0			| lowram value from ROM via boot
	lsrl	d2,d0			| convert to page number
	subl	d0,d1			| compute amount of RAM present
	RELOC(_physmem, a0)
	movl	d1,a0@@			| and physmem
/* configure kernel and proc0 VA space so we can get going */
	.globl	_Sysseg, _pmap_bootstrap, _avail_start
#ifdef MFS
	/* preserve miniroot if it exists */
	RELOC(_emini,a0)		| end of miniroot
	movl	a0@@,d5
	jne	Lstart2
#endif
#ifdef DDB
	RELOC(_esym,a0)			| end of static kernel test/data/syms
	movl	a0@@,d5
	jne	Lstart2
#endif
	movl	#_end,d5		| end of static kernel text/data
Lstart2:
	addl	#NBPG-1,d5
	andl	#PG_FRAME,d5		| round to a page
	movl	d5,a4
	addl	a5,a4			| convert to PA
#if 0
	| XXX clear from end-of-kernel to 1M, as a workaround for an
	| inane pmap_bootstrap bug I cannot find (68040-specific)
	movl	a4,a0
	movl	#1024*1024,d0
	cmpl	a0,d0			| end of kernel is beyond 1M?
	jlt	2f
	subl	a0,d0
1:	clrb	a0@@+
	subql	#1,d0
	bne	1b
2:
#endif
	pea	a5@@			| firstpa
	pea	a4@@			| nextpa
	RELOC(_pmap_bootstrap,a0)
	jbsr	a0@@			| pmap_bootstrap(firstpa, nextpa)
	addql	#8,sp

d75 3
a77 2
 * Enable the MMU.
 * Since the kernel is mapped logical == physical, we just turn it on.
d79 2
a80 103
	RELOC(_Sysseg, a0)		| system segment table addr
	movl	a0@@,d1			| read value (a KVA)
	addl	a5,d1			| convert to PA
	RELOC(_mmutype, a0)
	cmpl	#MMU_68040,a0@@		| 68040?
	jne	Lmotommu1		| no, skip
	.long	0x4e7b1807		| movc d1,srp
	jra	Lstploaddone
Lmotommu1:
	RELOC(_protorp, a0)
	movl	#0x80000202,a0@@		| nolimit + share global + 4 byte PTEs
	movl	d1,a0@@(4)		| + segtable address
	pmove	a0@@,srp			| load the supervisor root pointer
	movl	#0x80000002,a0@@		| reinit upper half for CRP loads
Lstploaddone:
	RELOC(_mmutype, a0)
	cmpl	#MMU_68040,a0@@		| 68040?
	jne	Lmotommu2		| no, skip

	RELOC(_needprom,a0)
	cmpl	#0,a0@@
	beq	1f
	/*
	 * this machine needs the prom mapped. we use the translation
	 * registers to map it in.. and the ram it needs.
	 */
	movel	#0xff00a044,d0		| map top 16meg 1/1 for bug eprom exe
	.long	0x4e7b0004		| movc d0,itt0
	moveq	#0,d0			| ensure itt1 is disabled
	.long	0x4e7b0005		| movc d0,itt1
	movel	#0xff00a040,d0		| map top 16meg 1/1 for bug io access
	.long	0x4e7b0006		| movc d0,dtt0
	moveq	#0,d0			| ensure dtt1 is disabled
	.long	0x4e7b0007		| movc d0,dtt1
	bra	2f
1:
	moveq	#0,d0			| ensure TT regs are disabled
	.long	0x4e7b0004		| movc d0,itt0
	.long	0x4e7b0005		| movc d0,itt1
	.long	0x4e7b0006		| movc d0,dtt0
	.long	0x4e7b0007		| movc d0,dtt1
2:

	.word	0xf4d8			| cinva bc
	.word	0xf518			| pflusha
	movl	#0x8000,d0
	.long	0x4e7b0003		| movc d0,tc
	movl	#0x80008000,d0
	movc	d0,cacr			| turn on both caches
	jmp	Lenab1
Lmotommu2:
	movl	#0x82c0aa00,a2@@		| value to load TC with
	pmove	a2@@,tc			| load it
Lenab1:

/*
 * Should be running mapped from this point on
 */
/* select the software page size now */
	lea	tmpstk,sp		| temporary stack
	jbsr	_vm_set_page_size	| select software page size
/* set kernel stack, user SP, and initial pcb */
	movl	_proc0paddr,a1		| get proc0 pcb addr
	lea	a1@@(USPACE-4),sp	| set kernel stack to end of area
	movl	#USRSTACK-4,a2
	movl	a2,usp			| init user SP
	movl	a1,_curpcb		| proc0 is running
#ifdef FPCOPROC
	clrl	a1@@(PCB_FPCTX)		| ensure null FP context
	movl	a1,sp@@-
	jbsr	_m68881_restore		| restore it (does not kill a1)
	addql	#4,sp
#endif
/* flush TLB and turn on caches */
	jbsr	_TBIA			| invalidate TLB
	cmpl	#MMU_68040,_mmutype	| 68040?
	jeq	Lnocache0		| yes, cache already on
	movl	#CACHE_ON,d0
	movc	d0,cacr			| clear cache(s)
Lnocache0:
/* final setup for C code */
	movl	#_vectab,d2		| set VBR
	movc	d2,vbr
	movw	#PSL_LOWIPL,sr		| lower SPL
	movl	d7,_boothowto		| save reboot flags
	movl	d6,_bootdev		|   and boot device

/*
 * Create a fake exception frame so that cpu_fork() can copy it.
 * main() nevers returns; we exit to user mode from a forked process
 * later on.
 */
	clrw	sp@@-			| vector offset/frame type
	clrl	sp@@-			| PC - filled in by "execve"
	movw	#PSL_USER,sp@@-		| in user mode
	clrl	sp@@-			| stack adjust count and padding
	lea	sp@@(-64),sp		| construct space for D0-D7/A0-A7
	lea	_proc0,a0		| save pointer to frame
	movl	sp,a0@@(P_MD_REGS)	|   in proc0.p_md.md_regs

	jra	_main			| main()

	pea	1f
d82 3
a84 2
1:
	.asciz	"main returned"
a86 40
	.globl	_proc_trampoline
_proc_trampoline:
	movl	a3,sp@@-
	jbsr	a2@@
	addql	#4,sp
	movl	sp@@(FR_SP),a0		| grab and load
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most user regs
	addql	#8,sp			| toss SP and stack adjust
	jra	rei			| and return

/*
 * Signal "trampoline" code (18 bytes).  Invoked from RTE setup by sendsig().
 * 
 * Stack looks like:
 *
 *	sp+0 ->	signal number
 *	sp+4	signal specific code
 *	sp+8	pointer to signal context frame (scp)
 *	sp+12	address of handler
 *	sp+16	saved hardware state
 *			.
 *			.
 *	scp+0->	beginning of signal context frame
 */
	.globl	_sigcode, _esigcode, _sigcodetrap
	.data
_sigcode:
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
	jsr	a0@@			| call signal handler	(2 bytes)
	addql	#4,sp			| pop signo		(2 bytes)
_sigcodetrap:
	trap	#1			| special syscall entry	(2 bytes)
	movl	d0,sp@@(4)		| save errno		(4 bytes)
	moveq	#1,d0			| syscall == exit	(2 bytes)
	trap	#0			| exit(errno)		(2 bytes)
	.align	2
_esigcode:
	.text

d110 1
a110 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d145 1
a145 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d252 1
a252 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d372 2
a373 2
	.globl	_hardtrap, _hardintr
_hardtrap:
d380 2
a381 2
	jbsr	_hardintr		| doit
	lea	sp@@(12),sp		| pop args
d417 3
d421 1
a465 1
 *	- calling the prom, but only from the kernel
a470 19
	tstl	_promcall
	jeq	L_notpromcall
	moveml	sp@@+,#0xFFFF
	addql	#4, sp
	| unwind stack to put to known value
	| this routine is from the 147 BUG manual
	| currently save and restore are excessive.
	subql	#4,sp
	link	a6,#0
	moveml	#0xFFFE,sp@@-
	movl	_promvbr,a0
	movw	a6@@(14),d0
	andl	#0xfff,d0
	movl	a0@@(d0:w),a6@@(4)
	moveml	sp@@+,#0x7FFF
	unlk	a6
	rts
	| really jumps to the bug trap handler
L_notpromcall:
d542 11
a552 1
 * No device interrupts are auto-vectored.
d554 1
d561 32
d610 4
d636 3
d640 1
d651 3
d655 1
d682 3
d686 1
d690 36
d728 247
d1006 1
a1006 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1065 6
a1070 6
	tstl	a0@@(P_BACK)
	jne	Lset1
	tstl	a0@@(P_WCHAN)
	jne	Lset1
	cmpb	#SRUN,a0@@(P_STAT)
	jne	Lset1
d1089 2
a1090 2
	movl	#Lset2,sp@@-
	jbsr	_panic
d1092 1
a1092 1
	.asciz	"setrunqueue"
d1105 12
a1116 12
	lsrb	#2,d0
	movl	_whichqs,d1
	btst	d0,d1
	jeq	Lrem2
#endif
	movl	a0@@(P_BACK),a1
	clrl	a0@@(P_BACK)
	movl	a0@@(P_FORW),a0
	movl	a0,a1@@(P_FORW)
	movl	a1,a0@@(P_BACK)
	cmpal	a0,a1
	jne	Lrem1
d1118 2
a1119 2
	lsrb	#2,d0
	movl	_whichqs,d1
d1121 2
a1122 2
	bclr	d0,d1
	movl	d1,_whichqs
d1127 2
a1128 2
	movl	#Lrem3,sp@@-
	jbsr	_panic
d1130 1
a1130 1
	.asciz	"remrq"
d1155 3
a1157 3
	movl	sp@@(4),a0
	movl	#nullpcb,_curpcb	| save state into garbage pcb
	lea	tmpstk,sp		| goto a tmp stack
d1160 5
a1164 5
	movl	#USPACE,sp@@-		| size of u-area
	movl	a0@@(P_ADDR),sp@@-	| address of process's u-area
	movl	_kernel_map,sp@@-	| map it was allocated in
	jbsr	_kmem_free		| deallocate it
	lea	sp@@(12),sp		| pop args
d1176 2
a1177 2
	movl	_whichqs,d0
	jeq	Idle
d1208 3
a1210 3
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	movl	_whichqs,d0
	jeq	Idle
d1212 21
a1232 21
	movl	d0,d1
	negl	d0
	andl	d1,d0
	bfffo	d0{#0:#32},d1
	eorib	#31,d1

	movl	d1,d0
	lslb	#3,d1			| convert queue number to index
	addl	#_qs,d1			| locate queue (q)
	movl	d1,a1
	movl	a1@@(P_FORW),a0		| p = q->p_forw
	cmpal	d1,a0			| anyone on queue?
	jeq	Lbadsw			| no, panic
	movl	a0@@(P_FORW),a1@@(P_FORW)	| q->p_forw = p->p_forw
	movl	a0@@(P_FORW),a1		| n = p->p_forw
	movl	d1,a1@@(P_BACK)		| n->p_back = q
	cmpal	d1,a1			| anyone left on queue?
	jne	Lsw2			| yes, skip
	movl	_whichqs,d1
	bclr	d0,d1			| no, clear bit
	movl	d1,_whichqs
d1285 1
a1285 1
	lea	tmpstk,sp		| now goto a tmp stack for NMI
d1287 1
a1287 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1315 1
a1315 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1386 1
a1386 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1408 1
a1408 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1442 3
a1444 3
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lmotommu5		| no, skip
	.word	0xf518			| yes, pflusha (for now) XXX
d1462 3
a1464 3
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lmotommu6		| no, skip
	.word	0xf518			| yes, pflusha (for now) XXX
d1479 3
a1481 3
	cmpl	#MMU_68040,_mmutype	| 68040
	jne	Lmotommu7		| no, skip
	.word	0xf498			| cinva ic
d1499 3
a1501 3
	cmpl	#MMU_68040,_mmutype	| 68040
	jne	Lmotommu8		| no, skip
	.word	0xf478			| cpusha dc
d1510 3
a1512 3
	cmpl	#MMU_68040,_mmutype	| 68040
	jne	Lmotommu9		| no, skip
	.word	0xf478			| cpusha dc
a1517 10
| Invalid single cache line
ENTRY(DCIAS)
__DCIAS:
	cmpl	#MMU_68040,_mmutype	| 68040
	jeq	Ldciasx
	movl	sp@@(4),a0
	.word	0xf468			| cpushl dc,a0@@
Ldciasx:
	rts

d1521 3
a1523 3
	cmpl	#MMU_68040,_mmutype	| 68040
	jne	LmotommuA		| no, skip
	.word	0xf478			| cpusha dc
d1531 2
a1532 2
	movl	sp@@(4),a0		| address
	.word	0xf488			| cinvl ic,a0@@
d1535 2
a1536 2
	movl	sp@@(4),a0		| address
	.word	0xf490			| cinvp ic,a0@@
d1539 2
a1540 2
	movl	sp@@(4),a0		| address
	.word	0xf448			| cinvl dc,a0@@
d1543 2
a1544 2
	movl	sp@@(4),a0		| address
	.word	0xf450			| cinvp dc,a0@@
d1547 1
a1547 1
	.word	0xf458			| cinva dc
d1550 2
a1551 2
	movl	sp@@(4),a0		| address
	.word	0xf468			| cpushl dc,a0@@
d1554 2
a1555 2
	movl	sp@@(4),a0		| address
	.word	0xf470			| cpushp dc,a0@@
d1562 3
a1564 3
	cmpl	#MMU_68040,_mmutype	| 68040
	jne	LmotommuB		| no, skip
	.word	0xf478			| cpusha dc
d1603 1
a1603 1
	moveq	#PGSHIFT,d1
d1606 3
a1608 4
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	LmotommuC		| no, skip
	.word	0xf518			| pflusha XXX TDR
	.long	0x4e7b0806		| movc d0,urp
a1611 1
	pflusha				| XXX TDR
a1668 64
 * bzero(addr, count)
 */
ALTENTRY(blkclr, _bzero)
ENTRY(bzero)
	movl	sp@@(4),a0	| address
	movl	sp@@(8),d0	| count
	jeq	Lbzdone		| if zero, nothing to do
	movl	a0,d1
	btst	#0,d1		| address odd?
	jeq	Lbzeven		| no, can copy words
	clrb	a0@@+		| yes, zero byte to get to even boundary
	subql	#1,d0		| decrement count
	jeq	Lbzdone		| none left, all done
Lbzeven:
	movl	d0,d1
	andl	#31,d0
	lsrl	#5,d1		| convert count to 8*longword count
	jeq	Lbzbyte		| no such blocks, zero byte at a time
Lbzloop:
	clrl	a0@@+; clrl	a0@@+; clrl	a0@@+; clrl	a0@@+;
	clrl	a0@@+; clrl	a0@@+; clrl	a0@@+; clrl	a0@@+;
	subql	#1,d1		| one more block zeroed
	jne	Lbzloop		| more to go, do it
	tstl	d0		| partial block left?
	jeq	Lbzdone		| no, all done
Lbzbyte:
	clrb	a0@@+
	subql	#1,d0		| one more byte cleared
	jne	Lbzbyte		| more to go, do it
Lbzdone:
	rts

/*
 * strlen(str)
 */
ENTRY(strlen)
	moveq	#-1,d0
	movl	sp@@(4),a0	| string
Lslloop:
	addql	#1,d0		| increment count
	tstb	a0@@+		| null?
	jne	Lslloop		| no, keep going
	rts

/*
 * bcmp(s1, s2, len)
 *
 * WARNING!  This guy only works with counts up to 64K
 */
ENTRY(bcmp)
	movl	sp@@(4),a0		| string 1
	movl	sp@@(8),a1		| string 2
	moveq	#0,d0
	movw	sp@@(14),d0		| length
	jeq	Lcmpdone		| if zero, nothing to do
	subqw	#1,d0			| set up for DBcc loop
Lcmploop:
	cmpmb	a0@@+,a1@@+		| equal?
	dbne	d0,Lcmploop		| yes, keep going
	addqw	#1,d0			| +1 gives zero on match
Lcmpdone:
	rts

/*
a1763 2
 * XXX add support for rebooting -- that means looking at boothowto and doing
 * the right thing
a1766 1
	lea	tmpstk,sp		| physical SP in case of NMI
d1768 2
a1769 7
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lbootnot040		| no, skip
	movl	#0,d0
	movc	d0,cacr			| caches off
	.long	0x4e7b0003		| movc d0,tc (turn off MMU)
	bra	1f
Lbootnot040:
d1773 6
a1778 1
	movl	#0,a7@@			| value for pmove to TC (turn off MMU)
d1780 1
a1780 2

1:	movl	#0,d0
d1782 4
a1785 39

	/*
	 * We're going down. Make various sick attempts to reset the board.
	 */
	RELOC(_cputyp, a0)
	movl	a0@@,d0
	cmpw	#CPU_147,d0
	bne	not147
	movl	#0xfffe2000,a0		| MVME147: "struct vme1reg *"
	movw	a0@@,d0
	movl	d0,d1
	andw	#0x0001,d1		| is VME1_SCON_SWITCH set?
	beq	1f			| not SCON. may not use SRESET.
	orw	#0x0002,d0		| ok, assert VME1_SCON_SRESET
	movw	d0,a0@@
1:
	movl	#0xff800000,a0		| if we get here, SRESET did not work.
	movl	a0@@(4),a0		| try jumping directly to the ROM.
	jsr	a0@@
	| still alive! just return to the prom..
	bra	3f

not147:
	movl	#0xfff40000,a0		| MVME16x: "struct vme2reg *"
	movl	a0@@(60),d0
	movl	d0,d1
	andl	#0x40000000,d1		| is VME2_TCTL_SCON set?
	beq	1f			| not SCON. may not use SRESET.
	orw	#0x00800000,d0		| ok, assert VME2_TCTL_SRST
	movl	d0,a0@@(60)
1:
	movl	#0xff800000,a0		| if we get here, SRESET did not work.
	movl	a0@@(4),a0		| try jumping directly to the ROM.
	jsr	a0@@
	| still alive! just return to the prom..

3:	trap	#15
	.short	MVMEPROM_EXIT		| return to m68kbug
	/*NOTREACHED*/
d1790 1
a1790 1
	.long	MMU_68030	| default to MMU_68030
d1799 1
a1799 1
	.globl	_intiobase, _intiolimit, _extiobase
a1832 2

#include <mvme68k/mvme68k/vectors.s>
@

