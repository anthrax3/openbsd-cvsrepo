head	1.74;
access;
symbols
	OPENBSD_5_5:1.73.0.12
	OPENBSD_5_5_BASE:1.73
	OPENBSD_5_4:1.73.0.8
	OPENBSD_5_4_BASE:1.73
	OPENBSD_5_3:1.73.0.6
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.73.0.4
	OPENBSD_5_2_BASE:1.73
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.2
	OPENBSD_5_0:1.72.0.2
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.69.0.2
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.68.0.2
	OPENBSD_4_8_BASE:1.68
	OPENBSD_4_7:1.66.0.2
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.63.0.4
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.60.0.4
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.26
	UBC:1.23.0.4
	UBC_BASE:1.23
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.4
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.19
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.15.0.4
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.73;

1.73
date	2011.10.21.13.08.01;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2011.04.06.13.46.50;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2010.04.23.15.25.20;	author jsing;	state Exp;
branches;
next	1.67;

1.67
date	2010.04.05.02.09.15;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2010.02.26.23.11.57;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2009.08.13.15.23.10;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.04.21.57.56;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.12.06.58.36;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.11.12.35.42;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.18.04.31.16;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.17.00.27.29;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.14.03.37.23;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.14.03.35.29;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.12.20.57.42;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.09.23.06.46;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.09.04.33.12;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.09.00.39.25;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.08.22.17.06;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.08.05.34.28;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.07.03.41.52;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.07.00.28.17;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.06.16.42.06;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.05.02.38.37;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.05.00.38.17;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.31.22.06.02;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.31.19.57.43;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.29.05.08.20;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2006.10.21.16.01.54;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2006.09.24.22.43.00;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.15.20.20.40;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.22.00.40.01;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.11.07.22.00;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.30.07.52.32;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.17.14.16.04;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.23.22.52.40;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.03.21.09.01;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.06.15.28.26;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.21.18.59.05;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.06.20.45.07;	author miod;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2001.04.14.00.11.40;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.18.21.00.37;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.24.05.20.54;	author smurph;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	99.09.27.20.30.31;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	99.01.08.04.29.07;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.10.04.23.27.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.10.03.21.18.55;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.10.02.01.01.22;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.08.08.21.46.46;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.04.07.11.21.25;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.04.06.06.13.03;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.02.15.15.22.08;	author rahnds;	state Exp;
branches;
next	1.10;

1.10
date	97.02.15.14.47.59;	author rahnds;	state Exp;
branches;
next	1.9;

1.9
date	97.02.12.02.15.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.11.08.20.49.12;	author chuck;	state Exp;
branches;
next	1.7;

1.7
date	96.05.29.16.37.17;	author chuck;	state Exp;
branches;
next	1.6;

1.6
date	96.05.10.03.15.15;	author chuck;	state Exp;
branches;
next	1.5;

1.5
date	96.05.04.16.07.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.28.10.58.59;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.20.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.19.16.03.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.12;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.42.36;	author deraadt;	state Exp;
branches;
next	;

1.20.2.1
date	2001.04.18.16.10.38;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.10.31.03.01.17;	author nate;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2002.03.28.10.34.06;	author niklas;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2003.05.13.19.41.06;	author ho;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	1.20.2.8;

1.20.2.8
date	2004.06.05.23.10.53;	author niklas;	state Exp;
branches;
next	;

1.23.4.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	1.23.4.3;

1.23.4.3
date	2003.05.19.21.45.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: disksubr.c,v 1.73 2011/10/21 13:08:01 miod Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1995 Dale Rahn.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/disk.h>

void	bsdtocpulabel(struct disklabel *, struct mvmedisklabel *);
int	cputobsdlabel(struct disklabel *, struct mvmedisklabel *);

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl and anything required in the strategy routine
 * (e.g., sector size) must be filled in before calling us.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct buf *bp = NULL;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		goto done;

	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp)) {
		error = bp->b_error;
		goto done;
	}

	error = cputobsdlabel(lp, (struct mvmedisklabel *)bp->b_data);
	if (error == 0)
		goto done;

#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	struct buf *bp = NULL;
	int error;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	/* Read it in, slap the new label in, and write it back out */
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
		goto done;

	bsdtocpulabel(lp, (struct mvmedisklabel *)bp->b_data);

	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

void
bsdtocpulabel(struct disklabel *lp, struct mvmedisklabel *clp)
{
	char *tmot = "MOTOROLA", *id = "M88K", *mot;
	int i;
	u_short osa_u, osa_l, osl;
	u_int oss;

	/* preserve existing VID boot code information */
	osa_u = clp->vid_osa_u;
	osa_l = clp->vid_osa_l;
	osl = clp->vid_osl;
	oss = clp->vid_oss;
	bzero(clp, sizeof(*clp));
	clp->vid_osa_u = osa_u;
	clp->vid_osa_l = osa_l;
	clp->vid_osl = osl;
	clp->vid_oss = oss;
	clp->vid_cas = clp->vid_cal = 1;

	clp->magic1 = lp->d_magic;
	clp->type = lp->d_type;
	clp->subtype = lp->d_subtype;
	strncpy(clp->vid_vd, lp->d_typename, 16);
	strncpy(clp->packname, lp->d_packname, 16);
	clp->cfg_psm = lp->d_secsize;
	clp->cfg_spt = lp->d_nsectors;
	clp->cfg_trk = lp->d_ncylinders;	/* trk is really num of cyl! */
	clp->cfg_hds = lp->d_ntracks;

	clp->secpercyl = lp->d_secpercyl;
	clp->secperunit = DL_GETDSIZE(lp);
	clp->acylinders = lp->d_acylinders;

	clp->cfg_ilv = 1;
	clp->cfg_sof = 1;
	clp->cylskew = 1;
	clp->headswitch = 0;
	clp->cfg_ssr = 0;
	clp->flags = lp->d_flags;
	for (i = 0; i < NDDATA; i++)
		clp->drivedata[i] = lp->d_drivedata[i];
	for (i = 0; i < NSPARE; i++)
		clp->spare[i] = lp->d_spare[i];

	clp->magic2 = lp->d_magic2;
	clp->checksum = lp->d_checksum;
	clp->partitions = lp->d_npartitions;
	clp->bbsize = lp->d_bbsize;
	clp->sbsize = lp->d_sbsize;
	clp->checksum = lp->d_checksum;
	bcopy(&lp->d_partitions[0], clp->vid_4, sizeof(struct partition) * 4);
	bcopy(&lp->d_partitions[4], clp->cfg_4, sizeof(struct partition) * 12);
	clp->version = 2;
	bcopy(&lp->d_uid, clp->vid_4_1, sizeof(lp->d_uid));

	/* Put "MOTOROLA" in the VID. This makes it a valid boot disk. */
	for (mot = clp->vid_mot, i = 0; i < 8; i++)
		*mot++ = *tmot++;

	/* put volume id in the VID */
	for (mot = clp->vid_id, i = 0; i < 4; i++)
		*mot++ = *id++;
}

int
cputobsdlabel(struct disklabel *lp, struct mvmedisklabel *clp)
{
	int i;

	if (clp->magic1 != DISKMAGIC || clp->magic2 != DISKMAGIC)
		return (EINVAL);	/* no disk label */

	lp->d_magic = clp->magic1;
	lp->d_type = clp->type;
	lp->d_subtype = clp->subtype;
	strncpy(lp->d_typename, clp->vid_vd, sizeof lp->d_typename);
	strncpy(lp->d_packname, clp->packname, sizeof lp->d_packname);
	lp->d_secsize = clp->cfg_psm;
	lp->d_nsectors = clp->cfg_spt;
	lp->d_ncylinders = clp->cfg_trk; /* trk is really num of cyl! */
	lp->d_ntracks = clp->cfg_hds;

	lp->d_secpercyl = clp->secpercyl;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, clp->secperunit);
	lp->d_acylinders = clp->acylinders;
	lp->d_flags = clp->flags;
	for (i = 0; i < NDDATA; i++)
		lp->d_drivedata[i] = clp->drivedata[i];
	for (i = 0; i < NSPARE; i++)
		lp->d_spare[i] = clp->spare[i];

	lp->d_magic2 = clp->magic2;
	lp->d_npartitions = clp->partitions;
	lp->d_bbsize = clp->bbsize;
	lp->d_sbsize = clp->sbsize;

	bcopy(clp->vid_4, &lp->d_partitions[0], sizeof(struct partition) * 4);
	bcopy(clp->cfg_4, &lp->d_partitions[4], sizeof(struct partition) * 12);
	bcopy(clp->vid_4_1, &lp->d_uid, sizeof(lp->d_uid));

	if (clp->version < 2) {
		struct __partitionv0 *v0pp = (struct __partitionv0 *)lp->d_partitions;
		struct partition *pp = lp->d_partitions;

		for (i = 0; i < lp->d_npartitions; i++, pp++, v0pp++) {
			pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(v0pp->
			    p_fsize, v0pp->p_frag);
			pp->p_offseth = 0;
			pp->p_sizeh = 0;
		}
	}

	lp->d_version = 1;
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	return (0);
}
@


1.73
log
@Copy the DUID back and forth between the in-core label and the Motorola VID
block by using 8 unused bytes from the configuration substruct.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.68 2011/04/16 03:21:15 krw Exp $	*/
@


1.72
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.71 2011/04/15 14:57:29 krw Exp $	*/
d139 1
a139 1
	char *tmot = "MOTOROLA", *id = "M68K", *mot;
d190 1
d236 1
@


1.71
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.70 2011/04/06 13:46:50 miod Exp $	*/
d66 1
a66 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d114 1
a114 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d122 1
a122 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.70
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.69 2011/02/26 13:07:48 krw Exp $	*/
d66 2
a67 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d114 2
a115 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d122 2
a123 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.69
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.68 2010/04/23 15:25:20 jsing Exp $	*/
a44 1
 * Returns NULL on success and an error string on failure.
a45 1

@


1.68
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.66 2010/02/26 23:11:57 deraadt Exp $	*/
d95 1
d131 1
@


1.67
log
@Be sure to preserve boot code load address and size information when
writing a new VID label.
@
text
@a164 2
	clp->sparespertrack = lp->d_sparespertrack;
	clp->sparespercyl = lp->d_sparespercyl;
a165 1
	clp->rpm = lp->d_rpm;
d167 1
a167 1
	clp->cfg_ilv = lp->d_interleave;
a217 2
	lp->d_sparespertrack = clp->sparespertrack;
	lp->d_sparespercyl = clp->sparespercyl;
a218 2
	lp->d_rpm = clp->rpm;
	lp->d_interleave = clp->cfg_ilv;
@


1.66
log
@when we build a vendor label for writing, clear the memory supplied by the
buffer cache first, so that all sorts of gibble doesn't end up on the disk.
ok kettenis (for the sparc/sparc64 ones, at least)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.65 2009/08/13 15:23:10 deraadt Exp $	*/
d111 1
d138 2
d141 5
d147 6
@


1.65
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.64 2009/06/04 21:57:56 miod Exp $	*/
d138 1
@


1.64
log
@More fallback from struct disklabel changes, yawn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.63 2008/06/12 06:58:36 deraadt Exp $	*/
d36 2
a37 2
void bsdtocpulabel(struct disklabel *, struct mvmedisklabel *);
void cputobsdlabel(struct disklabel *, struct mvmedisklabel *);
d48 1
a48 1
char *
a52 1
	struct mvmedisklabel *mlp;
a53 1
	char *msg;
d55 1
a55 1
	if ((msg = initdisklabel(lp)))
d70 2
a71 9
	error = biowait(bp);
	if (error) {
		msg = "disk label read error";
		goto done;
	}

	mlp = (struct mvmedisklabel *)bp->b_data;
	if (mlp->magic1 != DISKMAGIC || mlp->magic2 != DISKMAGIC) {
		msg = "no disk label";
d75 2
a76 2
	cputobsdlabel(lp, mlp);
	if (dkcksum(lp) == 0)
a77 1
	msg = "disk label corrupted";
d80 2
a81 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a82 1
	}
d85 2
a86 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a87 1
	}
d95 1
a95 1
	return (msg);
d185 1
a185 1
void
d190 3
d240 1
@


1.63
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.61 2008/06/10 20:50:23 beck Exp $	*/
d168 4
a171 16
	clp->cfg_sof = lp->d_trackskew;
	clp->cylskew = lp->d_cylskew;
	clp->headswitch = lp->d_headswitch;

	/* this silly table is for winchester drives */
	if (lp->d_trkseek < 6)
		clp->cfg_ssr = 0;
	else if (lp->d_trkseek < 10)
		clp->cfg_ssr = 1;
	else if (lp->d_trkseek < 15)
		clp->cfg_ssr = 2;
	else if (lp->d_trkseek < 20)
		clp->cfg_ssr = 3;
	else
		clp->cfg_ssr = 4;

a219 22
	lp->d_trackskew = clp->cfg_sof;
	lp->d_cylskew = clp->cylskew;
	lp->d_headswitch = clp->headswitch;

	/* this silly table is for winchester drives */
	switch (clp->cfg_ssr) {
	case 1:
		lp->d_trkseek = 6;
		break;
	case 2:
		lp->d_trkseek = 10;
		break;
	case 3:
		lp->d_trkseek = 15;
		break;
	case 4:
		lp->d_trkseek = 20;
		break;
	default:
		lp->d_trkseek = 0;
	}

@


1.62
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.60 2007/06/20 18:15:46 deraadt Exp $	*/
d70 1
a70 1
	bp->b_flags = B_BUSY | B_READ;
d125 1
a125 1
	bp->b_flags = B_BUSY | B_READ;
d132 1
a132 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.61
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d70 1
a70 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d125 1
a125 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d132 1
a132 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.60
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.59 2007/06/18 04:31:16 deraadt Exp $	*/
d70 1
a70 1
	bp->b_flags = B_BUSY | B_READ;
d125 1
a125 1
	bp->b_flags = B_BUSY | B_READ;
d132 1
a132 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.59
log
@include not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.58 2007/06/17 00:27:29 deraadt Exp $	*/
d50 1
a50 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
a68 1
	bp->b_cylinder = 0; /* contained in block 0 */
d114 1
a114 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
a123 1
	bp->b_cylinder = 0; /* contained in block 0 */
@


1.58
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.57 2007/06/14 03:37:23 deraadt Exp $	*/
a32 1
#include <sys/device.h>
@


1.57
log
@excessive blank lines making the versions different
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.56 2007/06/14 03:35:29 deraadt Exp $	*/
d37 2
a38 2
void bsdtocpulabel(struct disklabel *, struct cpu_disklabel *);
void cputobsdlabel(struct disklabel *, struct cpu_disklabel *);
d54 3
a56 2
	char *msg = NULL;
	int error, i;
d58 1
a58 7
	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
d60 4
a63 10
	}
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;
a68 4
	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

a73 1

a74 3
	if (error == 0)
		bcopy(bp->b_data, osdep, sizeof (struct cpu_disklabel));

d80 11
a103 12
	if (osdep->magic1 != DISKMAGIC || osdep->magic2 != DISKMAGIC) {
		msg = "no disk label";
		goto done;
	}

	cputobsdlabel(lp, osdep);

	if (dkcksum(lp) != 0) {
		msg = "disk label corrupted";
		goto done;
	}

a108 1
	disklabeltokernlabel(lp);
d127 1
a129 1
	bp->b_cylinder = 0; /* contained in block 0 */
d131 1
a131 8

	if ((error = biowait(bp)) != 0) {
		/* nothing */
	} else {
		bcopy(bp->b_data, osdep, sizeof(struct cpu_disklabel));
	}

	if (error)
d134 1
a134 1
	bsdtocpulabel(lp, osdep);
d136 3
a138 14
	if (lp->d_magic == DISKMAGIC && lp->d_magic2 == DISKMAGIC &&
	    dkcksum(lp) == 0) {
		bcopy(osdep, bp->b_data, sizeof(struct cpu_disklabel));

		/* request no partition relocation by driver on I/O operations */
		bp->b_dev = dev;
		bp->b_blkno = 0; /* contained in block 0 */
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_WRITE;
		bp->b_cylinder = 0; /* contained in block 0 */
		(*strat)(bp);

		error = biowait(bp);
	}
d149 1
a149 1
bsdtocpulabel(struct disklabel *lp, struct cpu_disklabel *clp)
d214 1
a214 1
cputobsdlabel(struct disklabel *lp, struct cpu_disklabel *clp)
a264 1
	lp->d_checksum = 0;
d272 11
a282 4
	if (clp->version == 2)
		lp->d_version = 1;
	else
		lp->d_version = 0;
d284 2
@


1.56
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.55 2007/06/14 03:29:34 deraadt Exp $	*/
a131 1

@


1.55
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.54 2007/06/12 20:57:42 deraadt Exp $	*/
d74 1
@


1.54
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.53 2007/06/09 23:06:46 krw Exp $	*/
d71 3
a73 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.53
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.52 2007/06/09 04:33:12 deraadt Exp $	*/
d160 1
a160 1
		return (error);
d179 1
@


1.52
log
@various simple typo cleanups, basically making this look a lot more like
other disksubr functions without changing any of the effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.51 2007/06/09 04:08:39 deraadt Exp $	*/
a184 57

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
}

@


1.51
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.50 2007/06/09 00:39:25 krw Exp $	*/
d51 1
a51 1
    struct disklabel *lp, struct cpu_disklabel *clp, int spoofonly)
d79 1
a79 1
	/* obtain buffer to probe drive with */
d81 1
a82 2
	/* request no partition relocation by driver on I/O operations */
	bp->b_dev = dev;
d84 1
a86 1
	bp->b_cylinder = 0; /* contained in block 0 */
d91 1
a91 1
		bcopy(bp->b_data, clp, sizeof (struct cpu_disklabel));
d111 1
a111 1
	if (clp->magic1 != DISKMAGIC || clp->magic2 != DISKMAGIC) {
d116 1
a116 1
	cputobsdlabel(lp, clp);
d125 1
a125 1
		bp->b_flags = B_INVAL | B_AGE | B_READ;
d138 1
a138 1
    struct disklabel *lp, struct cpu_disklabel *clp)
d140 1
a140 1
	struct buf *bp;
d143 1
a143 1
	/* obtain buffer to read initial cpu_disklabel, for bootloader size :-) */
d145 1
a146 2
	/* request no partition relocation by driver on I/O operations */
	bp->b_dev = dev;
d156 1
a156 1
		bcopy(bp->b_data, clp, sizeof(struct cpu_disklabel));
d159 1
a159 4
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);

	if (error) {
a160 1
	}
d162 1
a162 1
	bsdtocpulabel(lp, clp);
d166 1
a166 4
		/* obtain buffer to scrozz drive with */
		bp = geteblk((int)lp->d_secsize);

		bcopy(clp, bp->b_data, sizeof(struct cpu_disklabel));
d172 1
a172 1
		bp->b_flags = B_WRITE;
d177 1
d179 2
a180 1
		bp->b_flags = B_INVAL | B_AGE | B_READ;
d186 5
d246 1
a246 3
	char *tmot = "MOTOROLA";
	char *id = "M68K";
	char *mot;
d272 1
a272 1
	if (lp->d_trkseek < 6) {
d274 1
a274 1
	} else if (lp->d_trkseek < 10) {
d276 1
a276 1
	} else if (lp->d_trkseek < 15) {
d278 1
a278 1
	} else if (lp->d_trkseek < 20) {
d280 1
a280 1
	} else {
a281 1
	}
d299 2
a300 3
	/* Put "MOTOROLA" in the VID.  This makes it a valid boot disk. */
	mot = clp->vid_mot;
	for (i = 0; i < 8; i++) {
d302 1
a302 1
	}
d304 1
a304 2
	mot = clp->vid_id;
	for (i = 0; i < 4; i++) {
a305 1
	}
d352 1
d370 1
a370 1
	else	
@


1.50
log
@Eliminate some duplicate code. No functional change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.49 2007/06/08 22:17:06 deraadt Exp $	*/
a132 52
/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *clp)
{
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	while ((i = ffs(openmask)) != 0) {
		i--;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fragblock = opp->p_fragblock;
			npp->p_cpg = opp->p_cpg;
		}
	}

	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
}
@


1.49
log
@we need a new sub-code in the VID driver to indicate new "struct partition"
fields which contain p_sizeh and such fields.  handle both kinds correctly,
we hope.  tested on mvme68k
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.48 2007/06/08 05:34:28 deraadt Exp $	*/
d373 38
a410 113
	lp->d_version = 0;
	if (clp->version == 0) {
		lp->d_magic = clp->magic1;
		lp->d_type = clp->type;
		lp->d_subtype = clp->subtype;
		strncpy(lp->d_typename, clp->vid_vd, sizeof lp->d_typename);
		strncpy(lp->d_packname, clp->packname, sizeof lp->d_packname);
		lp->d_secsize = clp->cfg_psm;
		lp->d_nsectors = clp->cfg_spt;
		lp->d_ncylinders = clp->cfg_trk; /* trk is really num of cyl! */
		lp->d_ntracks = clp->cfg_hds;

		lp->d_secpercyl = clp->secpercyl;
		if (DL_GETDSIZE(lp) == 0)
			DL_SETDSIZE(lp, clp->secperunit);
		lp->d_sparespertrack = clp->sparespertrack;
		lp->d_sparespercyl = clp->sparespercyl;
		lp->d_acylinders = clp->acylinders;
		lp->d_rpm = clp->rpm;
		lp->d_interleave = clp->cfg_ilv;
		lp->d_trackskew = clp->cfg_sof;
		lp->d_cylskew = clp->cylskew;
		lp->d_headswitch = clp->headswitch;

		/* this silly table is for winchester drives */
		switch (clp->cfg_ssr) {
		case 0:
			lp->d_trkseek = 0;
			break;
		case 1:
			lp->d_trkseek = 6;
			break;
		case 2:
			lp->d_trkseek = 10;
			break;
		case 3:
			lp->d_trkseek = 15;
			break;
		case 4:
			lp->d_trkseek = 20;
			break;
		default:
			lp->d_trkseek = 0;
		}
		lp->d_flags = clp->flags;
		for (i = 0; i < NDDATA; i++)
			lp->d_drivedata[i] = clp->drivedata[i];
		for (i = 0; i < NSPARE; i++)
			lp->d_spare[i] = clp->spare[i];

		lp->d_magic2 = clp->magic2;
		lp->d_checksum = clp->checksum;
		lp->d_npartitions = clp->partitions;
		lp->d_bbsize = clp->bbsize;
		lp->d_sbsize = clp->sbsize;
		bcopy(clp->vid_4, &lp->d_partitions[0], sizeof(struct partition) * 4);
		bcopy(clp->cfg_4, &lp->d_partitions[4], sizeof(struct partition) * 12);
	} else {
		lp->d_magic = clp->magic1;
		lp->d_type = clp->type;
		lp->d_subtype = clp->subtype;
		strncpy(lp->d_typename, clp->vid_vd, sizeof lp->d_typename);
		strncpy(lp->d_packname, clp->packname, sizeof lp->d_packname);
		lp->d_secsize = clp->cfg_psm;
		lp->d_nsectors = clp->cfg_spt;
		lp->d_ncylinders = clp->cfg_trk; /* trk is really num of cyl! */
		lp->d_ntracks = clp->cfg_hds;

		lp->d_secpercyl = clp->secpercyl;
		if (DL_GETDSIZE(lp) == 0)
			DL_SETDSIZE(lp, clp->secperunit);
		lp->d_sparespertrack = clp->sparespertrack;
		lp->d_sparespercyl = clp->sparespercyl;
		lp->d_acylinders = clp->acylinders;
		lp->d_rpm = clp->rpm;
		lp->d_interleave = clp->cfg_ilv;
		lp->d_trackskew = clp->cfg_sof;
		lp->d_cylskew = clp->cylskew;
		lp->d_headswitch = clp->headswitch;

		/* this silly table is for winchester drives */
		switch (clp->cfg_ssr) {
		case 0:
			lp->d_trkseek = 0;
			break;
		case 1:
			lp->d_trkseek = 6;
			break;
		case 2:
			lp->d_trkseek = 10;
			break;
		case 3:
			lp->d_trkseek = 15;
			break;
		case 4:
			lp->d_trkseek = 20;
			break;
		default:
			lp->d_trkseek = 0;
		}
		lp->d_flags = clp->flags;
		for (i = 0; i < NDDATA; i++)
			lp->d_drivedata[i] = clp->drivedata[i];
		for (i = 0; i < NSPARE; i++)
			lp->d_spare[i] = clp->spare[i];

		lp->d_magic2 = clp->magic2;
		lp->d_checksum = clp->checksum;
		lp->d_npartitions = clp->partitions;
		lp->d_bbsize = clp->bbsize;
		lp->d_sbsize = clp->sbsize;
		bcopy(clp->vid_4, &lp->d_partitions[0], sizeof(struct partition) * 4);
		bcopy(clp->cfg_4, &lp->d_partitions[4], sizeof(struct partition) * 12);
d412 14
d429 3
a431 1
	lp->d_checksum = 0;
@


1.48
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.47 2007/06/07 03:41:52 krw Exp $	*/
d354 1
a354 1
	clp->version = 1;
d373 1
a429 2
		lp->d_checksum = 0;
		lp->d_checksum = dkcksum(lp);
a485 2
		lp->d_checksum = 0;
		lp->d_checksum = dkcksum(lp);
d487 5
@


1.47
log
@Comment 'fixes'. All bounds_check_with_label now identical except for
vax and alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.46 2007/06/07 00:28:17 krw Exp $	*/
d385 2
a386 1
		DL_SETDSIZE(lp, clp->secperunit);
d443 2
a444 1
		DL_SETDSIZE(lp, clp->secperunit);
@


1.46
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.45 2007/06/06 16:42:06 deraadt Exp $	*/
d278 1
a278 2
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
@


1.45
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.44 2007/06/05 02:38:37 krw Exp $	*/
d251 1
a251 1
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[0]), lp) +
d267 1
a267 1
			return(0);
a280 1
#if LABELSECTOR != 0
d282 1
a282 2
#endif
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
@


1.44
log
@bounds_check_with_label() checks for i/o outside of the partition and
for overwriting the disklabel. Reorder some checks so all copies of
bounds_check_with_label do the checks in the same order. Order picked
by using the currently most popular one. Should be no functional
change.

"If it's boring, commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.43 2007/06/05 00:38:17 deraadt Exp $	*/
d6 1
a6 1
 *   
d37 2
a38 4
static void bsdtocpulabel(struct disklabel *lp,
	struct cpu_disklabel *clp);
static void cputobsdlabel(struct disklabel *lp,
	struct cpu_disklabel *clp);
d46 1
a46 1
 * Returns null on success and an error string on failure.
d50 2
a51 6
readdisklabel(dev, strat, lp, clp, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
d138 2
a139 4
setdisklabel(olp, nlp, openmask, clp)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *clp;
d159 1
a159 1
	while ((i = ffs((long)openmask)) != 0) {
d180 2
a181 2
 	nlp->d_checksum = 0;
 	nlp->d_checksum = dkcksum(nlp);
d190 2
a191 5
writedisklabel(dev, strat, lp, clp)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
d242 1
a242 1
	return (error); 
a244 1

d300 2
a301 4
static void
bsdtocpulabel(lp, clp)
	struct disklabel *lp;
	struct cpu_disklabel *clp;
d371 2
a372 80
struct cpu_disklabel_old {
	/* VID */
	u_char		vid_id[4];
	u_char		vid_0[16];
	u_int		vid_oss;
	u_short		vid_osl;
	u_char		vid_1[4];
	u_short		vid_osa_u;
	u_short		vid_osa_l;
	u_char		vid_2[2];
	u_short		partitions;
	u_char		vid_vd[16];
	u_long		bbsize;
	u_long		magic1;		/* 4 */
	u_short		type;		/* 2 */
	u_short		subtype;	/* 2 */
	u_char		packname[16];	/* 16 */
	u_long		flags;		/* 4 */
	u_long		drivedata[5];	/* 4 */
	u_long		spare[5];	/* 4 */
	u_short		checksum;	/* 2 */

	u_long		secpercyl;	/* 4 */
	u_long		secperunit;	/* 4 */
	u_long		headswitch;	/* 4 */

	u_char		vid_3[4];
	u_int		vid_cas;
	u_char		vid_cal;
	u_char		vid_4_0[3];
	u_char		vid_4[64];
	u_char		vid_4_1[28];
	u_long		sbsize;
	u_char		vid_mot[8];

	/* CFG */
	u_char		cfg_0[4];
	u_short		cfg_atm;
	u_short		cfg_prm;
	u_short		cfg_atw;
	u_short		cfg_rec;

	u_short		sparespertrack;
	u_short		sparespercyl;
	u_long		acylinders;
	u_short		rpm;
	u_short		cylskew;

	u_char		cfg_spt;
	u_char		cfg_hds;
	u_short		cfg_trk;
	u_char		cfg_ilv;
	u_char		cfg_sof;
	u_short		cfg_psm;
	u_short		cfg_shd;
	u_char		cfg_2[2];
	u_short		cfg_pcom;
	u_char		cfg_3;
	u_char		cfg_ssr;
	u_short		cfg_rwcc;
	u_short		cfg_ecc;
	u_short		cfg_eatm;
	u_short		cfg_eprm;
	u_short		cfg_eatw;
	u_char		cfg_gpb1;
	u_char		cfg_gpb2;
	u_char		cfg_gpb3;
	u_char		cfg_gpb4;
	u_char		cfg_ssc;
	u_char		cfg_runit;
	u_short		cfg_rsvc1;
	u_short		cfg_rsvc2;
	u_long		magic2;
	u_char		cfg_4[192];
};

static void
cputobsdlabel(lp, clp)
	struct disklabel *lp;
	struct cpu_disklabel *clp;
@


1.43
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.42 2007/06/02 02:35:27 krw Exp $	*/
a272 11
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
#if LABELSECTOR != 0
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
#endif
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}

d288 11
@


1.42
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.41 2007/05/31 22:06:02 krw Exp $	*/
a36 4
#ifdef DEBUG
int disksubr_debug = 0;
#endif

a41 5
#ifdef DEBUG
static void printlp(struct disklabel *lp, char *str);
static void printclp(struct cpu_disklabel *clp, char *str);
#endif

d66 2
a67 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d74 2
a75 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d77 3
a79 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
a129 6
#ifdef DEBUG
	if (disksubr_debug > 0) {
		printlp(lp, "readdisklabel:bsd label");
		printclp(clp, "readdisklabel:cpu label");
	}
#endif
a151 9
#ifdef DEBUG
	if(disksubr_debug > 0) {
		printlp(nlp, "setdisklabel:new disklabel");
		printlp(olp, "setdisklabel:old disklabel");
		printclp(clp, "setdisklabel:cpu disklabel");
	}
#endif


d174 2
a175 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
a190 5
#ifdef DEBUG
	if(disksubr_debug > 0) {
		printlp(olp, "setdisklabel:old->new disklabel");
	}
#endif
a206 6
#ifdef DEBUG
	if(disksubr_debug > 0) {
		printlp(lp, "writedisklabel: bsd label");
	}
#endif

a232 6
#ifdef DEBUG
	if (disksubr_debug > 0) {
		printclp(clp, "writedisklabel: cpu label");
	}
#endif

d263 1
a263 1
	int labelsector = blockpersec(lp->d_partitions[0].p_offset, lp) +
d275 1
a275 1
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsector &&
d277 1
a277 1
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsector &&
d285 2
a286 2
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
d302 1
a302 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
d333 1
a333 1
	clp->secperunit = lp->d_secperunit;
a468 5
#ifdef DEBUG
		if (disksubr_debug > 0) {
			printf("Reading old disklabel\n");
		}
#endif
d480 1
a480 3
		lp->d_secperunit = clp->secperunit;
		lp->d_secpercyl = clp->secpercyl;
		lp->d_secperunit = clp->secperunit;
a525 5
#ifdef DEBUG
		if (disksubr_debug > 0) {
			printf("Reading new disklabel\n");
		}
#endif
d537 1
a537 3
		lp->d_secperunit = clp->secperunit;
		lp->d_secpercyl = clp->secpercyl;
		lp->d_secperunit = clp->secperunit;
a582 30
#if DEBUG
	if (disksubr_debug > 0) {
		printlp(lp, "translated label read from disk\n");
	}
#endif
}

#ifdef DEBUG
static void
printlp(lp, str)
	struct disklabel *lp;
	char *str;
{
	int i;

	printf("%s\n", str);
	printf("magic1 %x\n", lp->d_magic);
	printf("magic2 %x\n", lp->d_magic2);
	printf("typename %s\n", lp->d_typename);
	printf("secsize %x nsect %x ntrack %x ncylinders %x\n",
	    lp->d_secsize, lp->d_nsectors, lp->d_ntracks, lp->d_ncylinders);
	printf("Num partitions %x\n", lp->d_npartitions);
	for (i = 0; i < lp->d_npartitions; i++) {
		struct partition *part = &lp->d_partitions[i];
		char *fstyp = fstypenames[part->p_fstype];
		
		printf("%c: size %10x offset %10x type %7s frag %5x cpg %3x\n",
		    'a' + i, part->p_size, part->p_offset, fstyp,
		    part->p_frag, part->p_cpg);
	}
a583 36

static void
printclp(clp, str)
	struct cpu_disklabel *clp;
	char *str;
{
	int max, i;

	printf("%s\n", str);
	printf("magic1 %x\n", clp->magic1);
	printf("magic2 %x\n", clp->magic2);
	printf("typename %s\n", clp->vid_vd);
	printf("secsize %x nsect %x ntrack %x ncylinders %x\n",
	    clp->cfg_psm, clp->cfg_spt, clp->cfg_hds, clp->cfg_trk);
	printf("Num partitions %x\n", clp->partitions);
	max = clp->partitions < 16 ? clp->partitions : 16;
	for (i = 0; i < max; i++) {
		struct partition *part;
		char *fstyp;

		if (i < 4) {
			part = (void *)&clp->vid_4[0];
			part = &part[i];
		} else {
			part = (void *)&clp->cfg_4[0];
			part = &part[i-4];
		}

		fstyp = fstypenames[part->p_fstype];
		
		printf("%c: size %10x offset %10x type %7s frag %5x cpg %3x\n",
		    'a' + i, part->p_size, part->p_offset, fstyp,
		    part->p_frag, part->p_cpg);
	}
}
#endif
@


1.41
log
@Minor bounds_check_with_label nits.

1) Use local variable 'labelsector' not 'labelsect' to be consistant (hp300,
mac68k, mvme68k, mvme88k, vax).

2) Having checked for sz == 0, the next check needs only be sz < 0, not <= 0.
(mac68k, mvme68k, mvme88k)

3) Use lp->d_partitions + DISKPART(dev), rather than
lp->d_partitions[DISKPART(dev)] (hp300).

Assuming no typos there should be no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2007/05/31 19:57:43 krw Exp $	*/
d150 1
a150 1
	cvtdisklabelv1(lp);
@


1.40
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.39 2007/05/29 06:28:15 otto Exp $	*/
d303 1
a303 1
	int labelsect = blockpersec(lp->d_partitions[0].p_offset, lp) +
d315 1
a315 1
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsect &&
d317 1
a317 1
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsect &&
d332 1
a332 1
		if (sz <= 0) {
@


1.39
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.38 2007/05/29 05:08:20 krw Exp $	*/
d298 2
a299 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
d328 1
a328 1
			/* if exactly at end of disk, return an EOF */
d333 1
d337 1
a337 1
		/* or truncate if part of it fits */
d344 1
a344 1
	return(1);
d348 1
a348 1
	return(-1);
@


1.38
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37 2006/10/21 16:01:54 krw Exp $	*/
d150 1
d206 1
a206 2
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
@


1.37
log
@Some KNF cleanup.

De-register. Move declaration to top of function for DOS MBR
processing. Indent nit in macppc.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.36 2006/09/24 22:43:00 krw Exp $	*/
d68 2
a69 1
	struct buf *bp;
d77 4
a80 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
d92 1
a92 1
		return (NULL);
a107 2
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
d109 4
a112 2
	if (error)
		return ("disk label read error");
d115 4
a118 2
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
d121 4
a124 2
	if (udf_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
d127 4
a130 2
	if (clp->magic1 != DISKMAGIC || clp->magic2 != DISKMAGIC)
		return ("no disk label");
d134 4
a137 2
	if (dkcksum(lp) != 0)
		return ("disk label corrupted");
d145 6
a150 1
	return (NULL);
@


1.36
log
@Bring hp300, mac68k and mvme68k disklabel initialization code into
line with all other archs by initializing partitions up to RAWPART the
same way. Should be no functional change.

ok martin@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.35 2006/08/17 10:34:14 krw Exp $	*/
d213 1
a213 1
	register struct disklabel *lp;
@


1.35
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.34 2006/03/15 20:20:40 miod Exp $	*/
d85 1
@


1.34
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.33 2006/01/22 00:40:01 miod Exp $	*/
d76 2
@


1.33
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2006/01/11 07:22:00 miod Exp $	*/
a49 8

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
}

@


1.32
log
@Switch to __HAVE_DEVICE_REGISTER to find the device we're booted from.
Simpler, better.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 2005/03/30 07:52:32 deraadt Exp $	*/
a36 2
#define b_cylin b_resid

d104 1
a104 1
	bp->b_cylin = 0; /* contained in block 0 */
d238 1
a238 1
	bp->b_cylin = 0; /* contained in block 0 */
d274 1
a274 1
		bp->b_cylin = 0; /* contained in block 0 */
d333 1
a333 1
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.31
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 2004/03/17 14:16:04 miod Exp $	*/
a36 5
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <machine/autoconf.h>

a57 35
	struct scsibus_softc *sbsc;
	int target, lun;

	if (bootpart == -1) /* ignore flag from controller driver? */
		return;

	/*
	 * scsi: sd,cd
	 */

	if (strncmp("sd", dev->dv_xname, 2) == 0 ||
	    strncmp("cd", dev->dv_xname, 2) == 0) {

		sbsc = (struct scsibus_softc *)dev->dv_parent;
#ifdef MVME147
		/*
		 * The 147 can only boot from the built-in scsi controller,
		 * and stores the scsi id as the controller number.
		 */
		if (cputyp == CPU_147) {
			target = bootctrllun;
			lun = 0;
		} else
#endif
		{
			target = bootdevlun >> 4;
			lun = bootdevlun & 0x0f;
		}
    		
		if (sbsc->sc_link[target][lun] != NULL &&
		    sbsc->sc_link[target][lun]->device_softc == (void *)dev) {
			bootdv = dev;
			return;
		}
	}
@


1.30
log
@Make sure disklabels use at least DEV_BSIZE as their sector size.
This allows the kernel to survive reading the disklabel off a 256-bytes/sector
scsi device...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 2003/08/23 22:52:40 deraadt Exp $	*/
d162 5
@


1.29
log
@unifiy with mvme88k
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 2003/06/03 21:09:01 deraadt Exp $	*/
d122 1
a122 1
	if (lp->d_secsize == 0)
@


1.28
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 2003/04/06 15:28:26 krw Exp $	*/
d164 1
a164 1
	
d166 1
a166 1
	
d440 2
a441 1
 	/* put "MOTOROLA" in the VID.  This makes it a valid boot disk also. xxx - smurph */
d443 1
a443 1
	for (i=0; i<8; i++) {
d448 1
a448 1
	for (i=0; i<4; i++) {
a450 1

@


1.27
log
@Some easy strcpy elimination.

a) strcpy -> strncpy for copies into disklabel fields d_packname and
d_typename.

b) '16' -> 'sizeof d_packname' or 'sizeof d_typename' in existing
strncpy's.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 2002/08/21 18:59:05 miod Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *   This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
@


1.26
log
@Get the boot device correctly if scsi id != 0 on 1[67]x boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.25 2002/04/27 23:21:05 miod Exp $	*/
d548 2
a549 2
		strncpy(lp->d_typename, clp->vid_vd, 16);
		strncpy(lp->d_packname, clp->packname, 16);
d612 2
a613 2
		strncpy(lp->d_typename, clp->vid_vd, 16);
		strncpy(lp->d_packname, clp->packname, 16);
@


1.25
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 2002/03/14 01:26:38 millert Exp $	*/
d91 2
a92 2
			target = bootdevlun / 10;
			lun = bootdevlun % 10;
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 2001/08/06 20:45:07 miod Exp $	*/
d34 1
a36 1
#define DKTYPENAMES
d188 1
a188 1
	register struct disklabel *olp, *nlp;
d192 2
a193 2
	register i;
	register struct partition *opp, *npp;
d254 1
d257 1
a257 1
	void (*strat)();
d281 1
a281 1
	if (error = biowait(bp)) {
a539 1
		struct cpu_disklabel_old *clpo = (void *) clp;
@


1.23
log
@Properly identify the boot drive on 147 if it is not scsi id #0.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 2001/04/14 00:11:40 miod Exp $	*/
d51 4
a54 4
static void bsdtocpulabel __P((struct disklabel *lp,
	struct cpu_disklabel *clp));
static void cputobsdlabel __P((struct disklabel *lp,
	struct cpu_disklabel *clp));
d57 2
a58 2
static void printlp __P((struct disklabel *lp, char *str));
static void printclp __P((struct cpu_disklabel *clp, char *str));
d116 1
a116 1
	void (*strat) __P((struct buf *));
@


1.23.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 2001/08/06 20:45:07 miod Exp $	*/
a33 1
#include <sys/systm.h>
d36 1
d51 4
a54 4
static void bsdtocpulabel(struct disklabel *lp,
	struct cpu_disklabel *clp);
static void cputobsdlabel(struct disklabel *lp,
	struct cpu_disklabel *clp);
d57 2
a58 2
static void printlp(struct disklabel *lp, char *str);
static void printclp(struct cpu_disklabel *clp, char *str);
d116 1
a116 1
	void (*strat)(struct buf *);
d188 1
a188 1
	struct disklabel *olp, *nlp;
d192 2
a193 2
	int i;
	struct partition *opp, *npp;
a253 1
int
d256 1
a256 1
	void (*strat)(struct buf *);
d280 1
a280 1
	if ((error = biowait(bp)) != 0) {
d539 1
@


1.23.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23.4.1 2002/06/11 03:36:50 art Exp $	*/
d91 2
a92 2
			target = bootdevlun >> 4;
			lun = bootdevlun & 0x0f;
@


1.23.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d548 2
a549 2
		strncpy(lp->d_typename, clp->vid_vd, sizeof lp->d_typename);
		strncpy(lp->d_packname, clp->packname, sizeof lp->d_packname);
d612 2
a613 2
		strncpy(lp->d_typename, clp->vid_vd, sizeof lp->d_typename);
		strncpy(lp->d_packname, clp->packname, sizeof lp->d_packname);
@


1.22
log
@Correctly initialize disklabel structure in readdisklabel().
Prevents kernel from panic'ing or disklabel(1) from faulting with
an empty (never labaled) disk.

Also, use LABELSECTOR instead of hardwired constant.

Tested by deraadt@@ on mvme68k and myself on mvme88k, deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 2000/10/18 21:00:37 mickey Exp $	*/
d80 14
a93 2
		target = bootdevlun / 10;
		lun = bootdevlun % 10;
@


1.21
log
@typo in comment; from gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2000/01/24 05:20:54 smurph Exp $	*/
d104 1
a104 1
	void (*strat)();
d110 1
a110 4
	char *msg = NULL;
   char *tmot = "MOTOROLA";
	char *mot;
	int t;
d118 6
a123 3
	if (lp->d_partitions[RAW_PART].p_size == 0)
		lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_offset = 0;
d134 1
a134 1
	bp->b_blkno = 0; /* contained in block 0 */
d140 2
a141 3
	if (biowait(bp)) {
		msg = "cpu_disklabel read error\n";
	} else {
a142 2
	}
	
d146 3
a148 1
	if (msg) {
d150 2
a151 2
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			msg = NULL;
d153 2
a154 7
		return (msg); 
	}
	
	if (clp->magic1 != DISKMAGIC || clp->magic2 != DISKMAGIC) {
		msg = "no disk label";
		return (msg);
	}
d158 2
a159 4
	if (dkcksum(lp) != 0){
		msg = "disk label corrupted";
		return (msg);
	}
d167 1
a167 1
	return (msg);
d262 1
a262 1
	bp->b_blkno = 0; /* contained in block 0 */
@


1.20
log
@Fixed bug in disksubr.c relating to disklabels.  Added MVME376 support to le.  Made installboot insert M68K for volume ID, not M88K.  Correctly documented installboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 1999/09/27 20:30:31 smurph Exp $	*/
d94 1
a94 1
 * using the indicated stategy routine.
@


1.20.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 2001/04/14 00:11:40 miod Exp $	*/
d94 1
a94 1
 * using the indicated strategy routine.
d104 1
a104 1
	void (*strat) __P((struct buf *));
d110 4
a113 1
	int error, i;
d121 3
a123 6
	for (i = 0; i < RAW_PART; i++) {
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
	}
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
d134 1
a134 1
	bp->b_blkno = LABELSECTOR;
d140 3
a142 2
	error = biowait(bp);
	if (error == 0)
d144 2
d149 1
a149 3
	if (error)
		return ("disk label read error");

d151 2
a152 2
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
d154 7
a160 2
	if (clp->magic1 != DISKMAGIC || clp->magic2 != DISKMAGIC)
		return ("no disk label");
d164 4
a167 2
	if (dkcksum(lp) != 0)
		return ("disk label corrupted");
d175 1
a175 1
	return (NULL);
d270 1
a270 1
	bp->b_blkno = LABELSECTOR;
@


1.20.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20.2.1 2001/04/18 16:10:38 niklas Exp $	*/
d80 2
a81 14
#ifdef MVME147
		/*
		 * The 147 can only boot from the built-in scsi controller,
		 * and stores the scsi id as the controller number.
		 */
		if (cputyp == CPU_147) {
			target = bootctrllun;
			lun = 0;
		} else
#endif
		{
			target = bootdevlun / 10;
			lun = bootdevlun % 10;
		}
@


1.20.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 4
a54 4
static void bsdtocpulabel(struct disklabel *lp,
	struct cpu_disklabel *clp);
static void cputobsdlabel(struct disklabel *lp,
	struct cpu_disklabel *clp);
d57 2
a58 2
static void printlp(struct disklabel *lp, char *str);
static void printclp(struct cpu_disklabel *clp, char *str);
d116 1
a116 1
	void (*strat)(struct buf *);
@


1.20.2.4
log
@Sync the SMP branch with 3.3
@
text
@a33 1
#include <sys/systm.h>
d36 1
d91 2
a92 2
			target = bootdevlun >> 4;
			lun = bootdevlun & 0x0f;
d188 1
a188 1
	struct disklabel *olp, *nlp;
d192 2
a193 2
	int i;
	struct partition *opp, *npp;
a253 1
int
d256 1
a256 1
	void (*strat)(struct buf *);
d280 1
a280 1
	if ((error = biowait(bp)) != 0) {
d539 1
@


1.20.2.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20.2.4 2003/03/27 23:32:17 niklas Exp $	*/
d548 2
a549 2
		strncpy(lp->d_typename, clp->vid_vd, sizeof lp->d_typename);
		strncpy(lp->d_packname, clp->packname, sizeof lp->d_packname);
d612 2
a613 2
		strncpy(lp->d_typename, clp->vid_vd, sizeof lp->d_typename);
		strncpy(lp->d_packname, clp->packname, sizeof lp->d_packname);
@


1.20.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20.2.5 2003/05/13 19:41:06 ho Exp $	*/
d15 4
a18 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.20.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 1
a164 1

d166 1
a166 1

d440 1
a440 2

	/* Put "MOTOROLA" in the VID.  This makes it a valid boot disk. */
d442 1
a442 1
	for (i = 0; i < 8; i++) {
d447 1
a447 1
	for (i = 0; i < 4; i++) {
d450 1
@


1.20.2.8
log
@Merge with the trunk
@
text
@d122 1
a122 1
	if (lp->d_secsize < DEV_BSIZE)
@


1.19
log
@This gets us to 2.6...
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1999/02/09 06:36:28 smurph Exp $	*/
d111 3
d145 1
a145 1

d156 6
d163 4
a166 4
#ifdef DEBUG
	if (disksubr_debug > 0) {
		printlp(lp, "readdisklabel:bsd label");
		printclp(clp, "readdisklabel:cpu label");
a167 3
#endif
	return (msg);
}
a168 40
#if 0
char *
readdisklabel(dev, strat, lp, clp)
	dev_t dev;
	void (*strat)();
	struct disklabel *lp;
	struct cpu_disklabel *clp;
{
	struct buf *bp;
	char *msg = NULL;

	/* obtain buffer to probe drive with */
	bp = geteblk((int)lp->d_secsize);

	/* request no partition relocation by driver on I/O operations */
	bp->b_dev = dev;
	bp->b_blkno = 0; /* contained in block 0 */
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylin = 0; /* contained in block 0 */
	(*strat)(bp);

	if (biowait(bp)) {
		msg = "cpu_disklabel read error\n";
	}else {
		bcopy(bp->b_data, clp, sizeof (struct cpu_disklabel));
	}

	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);

	if (msg || clp->magic1 != DISKMAGIC || clp->magic2 != DISKMAGIC) {
#if defined(CD9660)
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			msg = NULL;
#endif
		return (msg); 
	}

	cputobsdlabel(lp, clp);
d170 1
a170 1
	if(disksubr_debug > 0) {
a177 1
#endif /* 0 */
d383 3
d438 11
@


1.18
log
@check for lp->d_secpercyl == 0) in bounds_check_with_label()
@
text
@d1 1
a1 2
/*	$OpenBSD: disksubr.c,v 1.17 1998/10/04 23:27:27 millert Exp $ */

d3 1
d80 3
a82 12
		if (cputyp == CPU_147) {
			target = bootctrllun % 8; /* XXX: 147 only */
			lun = bootdevlun; /* XXX: 147, untested */
		} else {
			/* 
			 * XXX: on the 167: 
			 * ignore bootctrllun
			 */
			target = bootdevlun / 10;
			lun = bootdevlun % 10;
		}

d91 1
d100 1
d163 50
d332 20
a351 13
	/* obtain buffer to scrozz drive with */
	bp = geteblk((int)lp->d_secsize);
	bcopy(clp, bp->b_data, sizeof(struct cpu_disklabel));
	/* request no partition relocation by driver on I/O operations */
	bp->b_dev = dev;
	bp->b_blkno = 0; /* contained in block 0 */
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_WRITE;
	bp->b_cylin = 0; /* contained in block 0 */
	(*strat)(bp);
	error = biowait(bp);
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
d394 1
a394 1
		if (sz < 0) {
a553 2
	struct disklabel llp;
	struct disklabel *nlp = &llp;
a554 1
	bzero (&llp, sizeof (llp));
d557 28
a584 21
		nlp->d_magic = clpo->magic1;
		nlp->d_type = clpo->type;
		nlp->d_subtype = clpo->subtype;
		strncpy(nlp->d_typename, clpo->vid_vd, 16);
		strncpy(nlp->d_packname, clpo->packname, 16);
		nlp->d_secsize = clpo->cfg_psm;
		nlp->d_nsectors = clpo->cfg_spt;
		nlp->d_ncylinders = clpo->cfg_trk; /* trk is really num of cyl! */
		nlp->d_ntracks = clpo->cfg_hds;
		nlp->d_secpercyl = clpo->secpercyl;
		nlp->d_secperunit = clpo->secperunit;
		nlp->d_secpercyl = clpo->secpercyl;
		nlp->d_secperunit = clpo->secperunit;
		nlp->d_sparespertrack = clpo->sparespertrack;
		nlp->d_sparespercyl = clpo->sparespercyl;
		nlp->d_acylinders = clpo->acylinders;
		nlp->d_rpm = clpo->rpm;
		nlp->d_interleave = clpo->cfg_ilv;
		nlp->d_trackskew = clpo->cfg_sof;
		nlp->d_cylskew = clpo->cylskew;
		nlp->d_headswitch = clpo->headswitch;
d586 1
a586 1
		switch (clpo->cfg_ssr) {
d588 1
a588 1
			nlp->d_trkseek = 0;
d591 1
a591 1
			nlp->d_trkseek = 6;
d594 1
a594 1
			nlp->d_trkseek = 10;
d597 1
a597 1
			nlp->d_trkseek = 15;
d600 1
a600 1
			nlp->d_trkseek = 20;
d603 1
a603 1
			nlp->d_trkseek = 0;
d605 1
a605 1
		nlp->d_flags = clpo->flags;
d607 1
a607 1
			nlp->d_drivedata[i] = clpo->drivedata[i];
d609 1
a609 1
			nlp->d_spare[i] = clpo->spare[i];
d611 14
a624 10
		nlp->d_magic2 = clpo->magic2;
		nlp->d_checksum = clpo->checksum;
		nlp->d_npartitions = clpo->partitions;
		nlp->d_bbsize = clpo->bbsize;
		nlp->d_sbsize = clpo->sbsize;
		bcopy(clpo->vid_4, &nlp->d_partitions[0], sizeof(struct partition) * 4);
		bcopy(clpo->cfg_4, &nlp->d_partitions[4], sizeof(struct partition) * 12);
#if 0
		nlp->d_checksum = 0;
		nlp->d_checksum = dkcksum(nlp);
d626 22
a647 23
	} else {
		nlp->d_magic = clp->magic1;
		nlp->d_type = clp->type;
		nlp->d_subtype = clp->subtype;
		strncpy(nlp->d_typename, clp->vid_vd, 16);
		strncpy(nlp->d_packname, clp->packname, 16);
		nlp->d_secsize = clp->cfg_psm;
		nlp->d_nsectors = clp->cfg_spt;
		nlp->d_ncylinders = clp->cfg_trk; /* trk is really num of cyl! */
		nlp->d_ntracks = clp->cfg_hds;

		nlp->d_secpercyl = clp->secpercyl;
		nlp->d_secperunit = clp->secperunit;
		nlp->d_secpercyl = clp->secpercyl;
		nlp->d_secperunit = clp->secperunit;
		nlp->d_sparespertrack = clp->sparespertrack;
		nlp->d_sparespercyl = clp->sparespercyl;
		nlp->d_acylinders = clp->acylinders;
		nlp->d_rpm = clp->rpm;
		nlp->d_interleave = clp->cfg_ilv;
		nlp->d_trackskew = clp->cfg_sof;
		nlp->d_cylskew = clp->cylskew;
		nlp->d_headswitch = clp->headswitch;
d652 1
a652 1
			nlp->d_trkseek = 0;
d655 1
a655 1
			nlp->d_trkseek = 6;
d658 1
a658 1
			nlp->d_trkseek = 10;
d661 1
a661 1
			nlp->d_trkseek = 15;
d664 1
a664 1
			nlp->d_trkseek = 20;
d667 1
a667 1
			nlp->d_trkseek = 0;
d669 1
a669 1
		nlp->d_flags = clp->flags;
d671 1
a671 1
			nlp->d_drivedata[i] = clp->drivedata[i];
d673 1
a673 1
			nlp->d_spare[i] = clp->spare[i];
d675 9
a683 26
		nlp->d_magic2 = clp->magic2;
		nlp->d_checksum = clp->checksum;
		nlp->d_npartitions = clp->partitions;
		nlp->d_bbsize = clp->bbsize;
		nlp->d_sbsize = clp->sbsize;
		bcopy(clp->vid_4, &nlp->d_partitions[0], sizeof(struct partition) * 4);
		bcopy(clp->cfg_4, &nlp->d_partitions[4], sizeof(struct partition) * 12);
#if 0
		nlp->d_checksum = 0;
		nlp->d_checksum = dkcksum(nlp);
#endif
	}
	{
		int oldcksum;

		oldcksum = nlp->d_checksum;
		nlp->d_checksum = 0;
#ifdef DEBUG
printf("old chksum = %x new %x\n", oldcksum, dkcksum(nlp));
	printlp(nlp, "lp disklabel");
	printclp(clp, "clp disklabel");
#endif
		if ((nlp->d_magic == DISKMAGIC) && (oldcksum == dkcksum(nlp))) {
			nlp->d_checksum = oldcksum;
			bcopy (nlp, lp, sizeof (*lp));
		}
d685 1
a685 2
	
#ifdef DEBUG
a723 4
	if (clp->version == 0) {
		printf("cannot print old version cpudisklabel\n");
		return;
	}
@


1.17
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 1998/10/03 21:18:55 millert Exp $ */
d318 6
@


1.16
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 1997/10/02 01:01:22 deraadt Exp $ */
d125 3
a127 7
	for (i = 0; i < RAW_PART; i++) {
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
	}
	if (lp->d_partitions[0].p_size == 0)
		lp->d_partitions[0].p_size = 0x1fffffff;
	lp->d_partitions[0].p_offset = 0;
@


1.15
log
@just overwrite anything in that zone of the disk, for writedisklabel()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 1997/08/08 21:46:46 niklas Exp $ */
d109 1
a109 1
readdisklabel(dev, strat, lp, clp)
d114 1
d119 18
d166 1
a166 1
	if(disksubr_debug > 0) {
@


1.14
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 1997/04/07 11:21:25 deraadt Exp $ */
d274 13
a286 20
	if (lp->d_magic == DISKMAGIC && lp->d_magic2 == DISKMAGIC &&
	    dkcksum(lp) == 0) {
		/* obtain buffer to scrozz drive with */
		bp = geteblk((int)lp->d_secsize);

		bcopy(clp, bp->b_data, sizeof(struct cpu_disklabel));

		/* request no partition relocation by driver on I/O operations */
		bp->b_dev = dev;
		bp->b_blkno = 0; /* contained in block 0 */
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_WRITE;
		bp->b_cylin = 0; /* contained in block 0 */
		(*strat)(bp);

		error = biowait(bp);

		bp->b_flags = B_INVAL | B_AGE | B_READ;
		brelse(bp);
	}
@


1.13
log
@add cd9660 spoofing and repair partition offset/block offset stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 1997/04/06 06:13:03 deraadt Exp $ */
d299 1
a299 1
bounds_check_with_label(bp, lp, wlabel)
d302 1
@


1.12
log
@support cd9660 disklabel spoofing; also fix block offset confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1997/02/15 15:22:08 rahnds Exp $ */
d312 1
a312 1
	if (bp->b_blkno + p->p_offset <= labelsect &&
d314 1
a314 1
	    bp->b_blkno + p->p_offset + sz > labelsect &&
@


1.11
log
@Move the debug print into the ifdef DEBUG section.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1997/02/15 14:47:59 rahnds Exp $ */
d139 4
d304 1
d306 3
a308 3
	int labelsect = lp->d_partitions[0].p_offset;
	int maxsz = p->p_size;
	int sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d312 1
a312 1
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
d314 1
a314 1
	    bp->b_blkno + p->p_offset + sz > LABELSECTOR + labelsect &&
d322 4
a325 3
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
d329 1
a329 3
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d333 1
d338 2
a339 1
	bp->b_cylin = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
@


1.10
log
@Only copy a cpudisklabel in the disklabel structure if a valid one is found.
This allows rd disklabels to be read and should allow generic BSD disklabels.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1997/02/12 02:15:29 deraadt Exp $ */
d614 1
a615 1
#ifdef DEBUG
@


1.9
log
@The original disklabel code from dale had an unaligned-aligned problem
in it. This new code from rahnds and nivas will read either style of
disklabel and hence will work on the mvme88k as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 1996/11/08 20:49:12 chuck Exp $ */
d483 2
d486 1
d489 21
a509 21
		lp->d_magic = DISKMAGIC;
		lp->d_type = clpo->type;
		lp->d_subtype = clpo->subtype;
		strncpy(lp->d_typename, clpo->vid_vd, 16);
		strncpy(lp->d_packname, clpo->packname, 16);
		lp->d_secsize = clpo->cfg_psm;
		lp->d_nsectors = clpo->cfg_spt;
		lp->d_ncylinders = clpo->cfg_trk; /* trk is really num of cyl! */
		lp->d_ntracks = clpo->cfg_hds;
		lp->d_secpercyl = clpo->secpercyl;
		lp->d_secperunit = clpo->secperunit;
		lp->d_secpercyl = clpo->secpercyl;
		lp->d_secperunit = clpo->secperunit;
		lp->d_sparespertrack = clpo->sparespertrack;
		lp->d_sparespercyl = clpo->sparespercyl;
		lp->d_acylinders = clpo->acylinders;
		lp->d_rpm = clpo->rpm;
		lp->d_interleave = clpo->cfg_ilv;
		lp->d_trackskew = clpo->cfg_sof;
		lp->d_cylskew = clpo->cylskew;
		lp->d_headswitch = clpo->headswitch;
d513 1
a513 1
			lp->d_trkseek = 0;
d516 1
a516 1
			lp->d_trkseek = 6;
d519 1
a519 1
			lp->d_trkseek = 10;
d522 1
a522 1
			lp->d_trkseek = 15;
d525 1
a525 1
			lp->d_trkseek = 20;
d528 1
a528 1
			lp->d_trkseek = 0;
d530 1
a530 1
		lp->d_flags = clpo->flags;
d532 1
a532 1
			lp->d_drivedata[i] = clpo->drivedata[i];
d534 1
a534 1
			lp->d_spare[i] = clpo->spare[i];
d536 11
a546 9
		lp->d_magic2 = DISKMAGIC;
		lp->d_checksum = clpo->checksum;
		lp->d_npartitions = clpo->partitions;
		lp->d_bbsize = clpo->bbsize;
		lp->d_sbsize = clpo->sbsize;
		bcopy(clpo->vid_4, &lp->d_partitions[0], sizeof(struct partition) * 4);
		bcopy(clpo->cfg_4, &lp->d_partitions[4], sizeof(struct partition) * 12);
		lp->d_checksum = 0;
		lp->d_checksum = dkcksum(lp);
d548 22
a569 22
		lp->d_magic = clp->magic1;
		lp->d_type = clp->type;
		lp->d_subtype = clp->subtype;
		strncpy(lp->d_typename, clp->vid_vd, 16);
		strncpy(lp->d_packname, clp->packname, 16);
		lp->d_secsize = clp->cfg_psm;
		lp->d_nsectors = clp->cfg_spt;
		lp->d_ncylinders = clp->cfg_trk; /* trk is really num of cyl! */
		lp->d_ntracks = clp->cfg_hds;

		lp->d_secpercyl = clp->secpercyl;
		lp->d_secperunit = clp->secperunit;
		lp->d_secpercyl = clp->secpercyl;
		lp->d_secperunit = clp->secperunit;
		lp->d_sparespertrack = clp->sparespertrack;
		lp->d_sparespercyl = clp->sparespercyl;
		lp->d_acylinders = clp->acylinders;
		lp->d_rpm = clp->rpm;
		lp->d_interleave = clp->cfg_ilv;
		lp->d_trackskew = clp->cfg_sof;
		lp->d_cylskew = clp->cylskew;
		lp->d_headswitch = clp->headswitch;
d574 1
a574 1
			lp->d_trkseek = 0;
d577 1
a577 1
			lp->d_trkseek = 6;
d580 1
a580 1
			lp->d_trkseek = 10;
d583 1
a583 1
			lp->d_trkseek = 15;
d586 1
a586 1
			lp->d_trkseek = 20;
d589 1
a589 1
			lp->d_trkseek = 0;
d591 1
a591 1
		lp->d_flags = clp->flags;
d593 1
a593 1
			lp->d_drivedata[i] = clp->drivedata[i];
d595 1
a595 1
			lp->d_spare[i] = clp->spare[i];
d597 26
a622 9
		lp->d_magic2 = clp->magic2;
		lp->d_checksum = clp->checksum;
		lp->d_npartitions = clp->partitions;
		lp->d_bbsize = clp->bbsize;
		lp->d_sbsize = clp->sbsize;
		bcopy(clp->vid_4, &lp->d_partitions[0], sizeof(struct partition) * 4);
		bcopy(clp->cfg_4, &lp->d_partitions[4], sizeof(struct partition) * 12);
		lp->d_checksum = 0;
		lp->d_checksum = dkcksum(lp);
d624 1
d664 4
@


1.8
log
@apply netbsd pr#2598 from der mouse:
        everything before the beginning of the "a" partition on a disk
        is read-only except when accessed via RAW_PART.   (a problem if
        "a" isn't at the front of the disk).
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 1996/05/29 16:37:17 chuck Exp $ */
d73 2
a74 2
 	 * scsi: sd,cd
 	 */
d79 1
a79 1
        	sbsc = (struct scsibus_softc *)dev->dv_parent;
d85 5
a89 5
		 	 * XXX: on the 167: 
		 	 * ignore bootctrllun
		 	 */
		 	target = bootdevlun / 10;
		 	lun = bootdevlun % 10;
d92 2
a93 2
        	if (sbsc->sc_link[target][lun] != NULL &&
            	    sbsc->sc_link[target][lun]->device_softc == (void *)dev) {
d95 1
a95 1
                	return;
d97 1
a97 3
        }

	return;
d138 1
a138 1
	if (msg || clp->magic1 != DISKMAGIC || clp->magic2 != DISKMAGIC) {
a140 1

d301 1
d307 8
a314 7
	/* XXX this assumes everything <=LABELSECTOR is label! */
	/*      (but since LABELSECTOR is zero, this is ok) */
        if (bp->b_blkno + p->p_offset <= LABELSECTOR &&
            (bp->b_flags & B_READ) == 0 && wlabel == 0) {
                bp->b_error = EROFS;
                goto bad;
        }
d317 9
a325 9
        if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
                /* if exactly at end of disk, return an EOF */
                if (bp->b_blkno == maxsz) {
                        bp->b_resid = bp->b_bcount;
                        return(0);
                }
                /* or truncate if part of it fits */
                sz = maxsz - bp->b_blkno;
                if (sz <= 0) {
d327 1
a327 1
                        goto bad;
d329 2
a330 2
                bp->b_bcount = sz << DEV_BSHIFT;
        }
d333 1
a333 1
        bp->b_cylin = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
d398 2
d401 75
a475 17
	/*
 	 * here are the parts of the cpu_disklabel the kernel must init.
 	 * see disklabel.h for more details
 	 * [note: this used to be handled by 'wrtvid']
 	 */
	bcopy(VID_ID, clp->vid_id, sizeof(clp->vid_id));
	clp->vid_oss = VID_OSS;
	clp->vid_osl = VID_OSL;
	clp->vid_osa_u = VID_OSAU;
	clp->vid_osa_l = VID_OSAL;
	clp->vid_cas = VID_CAS;
	clp->vid_cal = VID_CAL;
	bcopy(VID_MOT, clp->vid_mot, sizeof(clp->vid_mot));
	clp->cfg_rec = CFG_REC;
	clp->cfg_psm = CFG_PSM;

}
d484 117
a600 42
	lp->d_magic = clp->magic1;
	lp->d_type = clp->type;
	lp->d_subtype = clp->subtype;
	strncpy(lp->d_typename, clp->vid_vd, 16);
	strncpy(lp->d_packname, clp->packname, 16);
	lp->d_secsize = clp->cfg_psm;
	lp->d_nsectors = clp->cfg_spt;
	lp->d_ncylinders = clp->cfg_trk; /* trk is really num of cyl! */
	lp->d_ntracks = clp->cfg_hds;

	lp->d_secpercyl = clp->secpercyl;
	lp->d_secperunit = clp->secperunit;
	lp->d_secpercyl = clp->secpercyl;
	lp->d_secperunit = clp->secperunit;
	lp->d_sparespertrack = clp->sparespertrack;
	lp->d_sparespercyl = clp->sparespercyl;
	lp->d_acylinders = clp->acylinders;
	lp->d_rpm = clp->rpm;
	lp->d_interleave = clp->cfg_ilv;
	lp->d_trackskew = clp->cfg_sof;
	lp->d_cylskew = clp->cylskew;
	lp->d_headswitch = clp->headswitch;

	/* this silly table is for winchester drives */
	switch (clp->cfg_ssr) {
	case 0:
		lp->d_trkseek = 0;
		break;
	case 1:
		lp->d_trkseek = 6;
		break;
	case 2:
		lp->d_trkseek = 10;
		break;
	case 3:
		lp->d_trkseek = 15;
		break;
	case 4:
		lp->d_trkseek = 20;
		break;
	default:
		lp->d_trkseek = 0;
d602 1
a602 16
	lp->d_flags = clp->flags;
	for (i = 0; i < NDDATA; i++)
		lp->d_drivedata[i] = clp->drivedata[i];
	for (i = 0; i < NSPARE; i++)
		lp->d_spare[i] = clp->spare[i];

	lp->d_magic2 = clp->magic2;
	lp->d_checksum = clp->checksum;
	lp->d_npartitions = clp->partitions;
	lp->d_bbsize = clp->bbsize;
	lp->d_sbsize = clp->sbsize;
	bcopy(clp->vid_4, &lp->d_partitions[0], sizeof(struct partition) * 4);
	bcopy(clp->cfg_4, &lp->d_partitions[4], sizeof(struct partition) * 12);
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
#if DEBUG
@


1.7
log
@new generic boot
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a303 1
	int labelsect = lp->d_partitions[0].p_offset;
d309 3
a311 4
        if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
#if LABELSECTOR != 0
            bp->b_blkno + p->p_offset + sz > LABELSECTOR + labelsect &&
#endif
@


1.6
log
@init more fields so that kernel can generate a valid disklabel without
any help from wrtvid.
@
text
@d35 1
d40 5
d66 34
@


1.5
log
@proto nicely
@
text
@d361 17
@


1.4
log
@add OpenBSD header
@
text
@d55 1
a55 1
int
a59 1
	return(-1);
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 2
@


1.2
log
@typo glitch repair
@
text
@d35 1
d54 3
a56 1
dk_establish()
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: disksubr.c,v 1.2 1995/08/10 19:36:41 chuck Exp $ */

d2 3
a4 8
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
d15 3
a17 17
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d19 10
a28 1
 *	@@(#)ufs_disksubr.c	8.5 (Berkeley) 1/21/94
a31 1
#include <sys/systm.h>
d33 1
a34 1
#include <sys/syslog.h>
d36 21
a56 1
#define	b_cylinder	b_resid
d59 6
a64 5
 * Attempt to read a disk label from a device using the indicated stategy
 * routine.  The label must be partly set up before this: secpercyl and
 * anything required in the strategy routine (e.g., sector size) must be
 * filled in before calling us.  Returns null on success and an error
 * string on failure.
d67 1
a67 1
readdisklabel(dev, strat, lp, osdep)
d70 2
a71 2
	register struct disklabel *lp;
	struct cpu_disklabel *osdep;
d73 1
a73 2
	register struct buf *bp;
	struct disklabel *dlp;
d76 2
a77 6
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
	lp->d_npartitions = 1;
	if (lp->d_partitions[0].p_size == 0)
		lp->d_partitions[0].p_size = 0x1fffffff;
	lp->d_partitions[0].p_offset = 0;
d79 1
a79 1
	bp = geteblk((int)lp->d_secsize);
d81 1
a81 1
	bp->b_blkno = LABELSECTOR;
d84 1
a84 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
d86 5
a90 17
	if (biowait(bp))
		msg = "I/O error";
	else for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)((char *)bp->b_data +
	    DEV_BSIZE - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
			if (msg == NULL)
				msg = "no disk label";
		} else if (dlp->d_npartitions > MAXPARTITIONS ||
			   dkcksum(dlp) != 0)
			msg = "disk label corrupted";
		else {
			*lp = *dlp;
			msg = NULL;
			break;
		}
d92 2
a93 1
	bp->b_flags = B_INVAL | B_AGE;
d95 12
d111 2
a112 1
 * Check new disk label for sensibility before setting it.
d115 1
a115 1
setdisklabel(olp, nlp, openmask, osdep)
d118 1
a118 1
	struct cpu_disklabel *osdep;
d123 20
d146 1
d167 1
d171 5
a178 5
/* encoding of disk minor numbers, should be elsewhere... */
#define dkunit(dev)		(minor(dev) >> 3)
#define dkpart(dev)		(minor(dev) & 07)
#define dkminor(unit, part)	(((unit) << 3) | (part))

d182 1
a182 2
int
writedisklabel(dev, strat, lp, osdep)
d186 1
a186 1
	struct cpu_disklabel *osdep;
d189 5
a193 9
	struct disklabel *dlp;
	int labelpart;
	int error = 0;

	labelpart = dkpart(dev);
	if (lp->d_partitions[labelpart].p_offset != 0) {
		if (lp->d_partitions[0].p_offset != 0)
			return (EXDEV);			/* not quite right */
		labelpart = 0;
d195 3
d199 4
a202 2
	bp->b_dev = makedev(major(dev), dkminor(dkunit(dev), labelpart));
	bp->b_blkno = LABELSECTOR;
d204 2
a205 1
	bp->b_flags = B_READ;
d207 5
a211 14
	if (error = biowait(bp))
		goto done;
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)
	      ((char *)bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic == DISKMAGIC && dlp->d_magic2 == DISKMAGIC &&
		    dkcksum(dlp) == 0) {
			*dlp = *lp;
			bp->b_flags = B_WRITE;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}
d213 2
a214 2
	error = ESRCH;
done:
d216 34
a249 1
	return (error);
d252 1
a252 5
/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
d259 1
a259 1
	struct partition *p = &lp->d_partitions[dkpart(bp->b_dev)];
d264 10
a273 6
	/* Overwriting disk label? */
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}
d276 9
a284 9
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		if (bp->b_blkno == maxsz) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (0);
		}
		/* ...or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d286 1
a286 1
			goto bad;
d288 2
a289 2
		bp->b_bcount = sz << DEV_BSHIFT;
	}
d292 2
a293 2
	bp->b_resid = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
	return (1);
d295 1
a295 1
 bad:
d297 192
a488 1
	return (-1);
d490 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 2
d4 8
a11 3
 * Copyright (c) 1995 Dale Rahn.
 * All rights reserved.
 *   
d22 17
a38 3
 *   This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d40 1
a40 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d44 1
a45 1
#define DKTYPENAMES
d47 1
d49 1
a49 21
#define b_cylin b_resid

#ifdef DEBUG
int disksubr_debug = 0;
#endif

static void bsdtocpulabel __P((struct disklabel *lp,
	struct cpu_disklabel *clp));
static void cputobsdlabel __P((struct disklabel *lp,
	struct cpu_disklabel *clp));

#ifdef DEBUG
static void printlp __P((struct disklabel *lp, char *str));
static void printclp __P((struct cpu_disklabel *clp, char *str));
#endif

int
dk_establish()
{
	return(-1);
}
d52 5
a56 6
 * Attempt to read a disk label from a device
 * using the indicated stategy routine.
 * The label must be partly set up before this:
 * secpercyl and anything required in the strategy routine
 * (e.g., sector size) must be filled in before calling us.
 * Returns null on success and an error string on failure.
d59 1
a59 1
readdisklabel(dev, strat, lp, clp)
d62 2
a63 2
	struct disklabel *lp;
	struct cpu_disklabel *clp;
d65 2
a66 1
	struct buf *bp;
d69 7
a75 1
	/* obtain buffer to probe drive with */
a76 2

	/* request no partition relocation by driver on I/O operations */
d78 1
a78 1
	bp->b_blkno = 0; /* contained in block 0 */
d81 1
a81 1
	bp->b_cylin = 0; /* contained in block 0 */
d83 17
a99 5

	if (biowait(bp)) {
		msg = "cpu_disklabel read error\n";
	}else {
		bcopy(bp->b_data, clp, sizeof (struct cpu_disklabel));
d101 1
a101 2

	bp->b_flags = B_INVAL | B_AGE | B_READ;
a102 12

	if (msg || clp->magic1 != DISKMAGIC || clp->magic2 != DISKMAGIC) {
		return (msg); 
	}

	cputobsdlabel(lp, clp);
#ifdef DEBUG
	if(disksubr_debug > 0) {
		printlp(lp, "readdisklabel:bsd label");
		printclp(clp, "readdisklabel:cpu label");
	}
#endif
d107 1
a107 2
 * Check new disk label for sensibility
 * before setting it.
d110 1
a110 1
setdisklabel(olp, nlp, openmask, clp)
d113 1
a113 1
	struct cpu_disklabel *clp;
a117 20
#ifdef DEBUG
	if(disksubr_debug > 0) {
		printlp(nlp, "setdisklabel:new disklabel");
		printlp(olp, "setdisklabel:old disklabel");
		printclp(clp, "setdisklabel:cpu disklabel");
	}
#endif


	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

a120 1

a140 1

a143 5
#ifdef DEBUG
	if(disksubr_debug > 0) {
		printlp(olp, "setdisklabel:old->new disklabel");
	}
#endif
d147 5
d155 2
a156 1
writedisklabel(dev, strat, lp, clp)
d160 1
a160 1
	struct cpu_disklabel *clp;
d163 9
a171 5
	int error;

#ifdef DEBUG
	if(disksubr_debug > 0) {
		printlp(lp, "writedisklabel: bsd label");
a172 3
#endif

	/* obtain buffer to read initial cpu_disklabel, for bootloader size :-) */
d174 2
a175 4

	/* request no partition relocation by driver on I/O operations */
	bp->b_dev = dev;
	bp->b_blkno = 0; /* contained in block 0 */
d177 1
a177 2
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylin = 0; /* contained in block 0 */
d179 14
a192 5

	if (error = biowait(bp)) {
		/* nothing */
	} else {
		bcopy(bp->b_data, clp, sizeof(struct cpu_disklabel));
d194 2
a195 2

	bp->b_flags = B_INVAL | B_AGE | B_READ;
d197 1
a197 34

	if (error) {
		return (error);
	}

	bsdtocpulabel(lp, clp);

#ifdef DEBUG
	if (disksubr_debug > 0) {
		printclp(clp, "writedisklabel: cpu label");
	}
#endif

	if (lp->d_magic == DISKMAGIC && lp->d_magic2 == DISKMAGIC &&
	    dkcksum(lp) == 0) {
		/* obtain buffer to scrozz drive with */
		bp = geteblk((int)lp->d_secsize);

		bcopy(clp, bp->b_data, sizeof(struct cpu_disklabel));

		/* request no partition relocation by driver on I/O operations */
		bp->b_dev = dev;
		bp->b_blkno = 0; /* contained in block 0 */
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_WRITE;
		bp->b_cylin = 0; /* contained in block 0 */
		(*strat)(bp);

		error = biowait(bp);

		bp->b_flags = B_INVAL | B_AGE | B_READ;
		brelse(bp);
	}
	return (error); 
d200 5
a204 1

d211 1
a211 1
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
d216 6
a221 10
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
        if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
#if LABELSECTOR != 0
            bp->b_blkno + p->p_offset + sz > LABELSECTOR + labelsect &&
#endif
            (bp->b_flags & B_READ) == 0 && wlabel == 0) {
                bp->b_error = EROFS;
                goto bad;
        }
d224 9
a232 9
        if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
                /* if exactly at end of disk, return an EOF */
                if (bp->b_blkno == maxsz) {
                        bp->b_resid = bp->b_bcount;
                        return(0);
                }
                /* or truncate if part of it fits */
                sz = maxsz - bp->b_blkno;
                if (sz <= 0) {
d234 1
a234 1
                        goto bad;
d236 2
a237 2
                bp->b_bcount = sz << DEV_BSHIFT;
        }
d240 2
a241 2
        bp->b_cylin = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
	return(1);
d243 1
a243 1
bad:
d245 1
a245 192
	return(-1);
}


static void
bsdtocpulabel(lp, clp)
	struct disklabel *lp;
	struct cpu_disklabel *clp;
{
	int i;

	clp->magic1 = lp->d_magic;
	clp->type = lp->d_type;
	clp->subtype = lp->d_subtype;
	strncpy(clp->vid_vd, lp->d_typename, 16);
	strncpy(clp->packname, lp->d_packname, 16);
	clp->cfg_psm = lp->d_secsize;
	clp->cfg_spt = lp->d_nsectors;
	clp->cfg_trk = lp->d_ncylinders;	/* trk is really num of cyl! */
	clp->cfg_hds = lp->d_ntracks;

	clp->secpercyl = lp->d_secpercyl;
	clp->secperunit = lp->d_secperunit;
	clp->sparespertrack = lp->d_sparespertrack;
	clp->sparespercyl = lp->d_sparespercyl;
	clp->acylinders = lp->d_acylinders;
	clp->rpm = lp->d_rpm;

	clp->cfg_ilv = lp->d_interleave;
	clp->cfg_sof = lp->d_trackskew;
	clp->cylskew = lp->d_cylskew;
	clp->headswitch = lp->d_headswitch;

	/* this silly table is for winchester drives */
	if (lp->d_trkseek < 6) {
		clp->cfg_ssr = 0;
	} else if (lp->d_trkseek < 10) {
		clp->cfg_ssr = 1;
	} else if (lp->d_trkseek < 15) {
		clp->cfg_ssr = 2;
	} else if (lp->d_trkseek < 20) {
		clp->cfg_ssr = 3;
	} else {
		clp->cfg_ssr = 4;
	}

	clp->flags = lp->d_flags;
	for (i = 0; i < NDDATA; i++)
		clp->drivedata[i] = lp->d_drivedata[i];
	for (i = 0; i < NSPARE; i++)
		clp->spare[i] = lp->d_spare[i];

	clp->magic2 = lp->d_magic2;
	clp->checksum = lp->d_checksum;
	clp->partitions = lp->d_npartitions;
	clp->bbsize = lp->d_bbsize;
	clp->sbsize = lp->d_sbsize;
	clp->checksum = lp->d_checksum;
	bcopy(&lp->d_partitions[0], clp->vid_4, sizeof(struct partition) * 4);
	bcopy(&lp->d_partitions[4], clp->cfg_4, sizeof(struct partition) * 12);
}

static void
cputobsdlabel(lp, clp)
	struct disklabel *lp;
	struct cpu_disklabel *clp;
{
	int i;

	lp->d_magic = clp->magic1;
	lp->d_type = clp->type;
	lp->d_subtype = clp->subtype;
	strncpy(lp->d_typename, clp->vid_vd, 16);
	strncpy(lp->d_packname, clp->packname, 16);
	lp->d_secsize = clp->cfg_psm;
	lp->d_nsectors = clp->cfg_spt;
	lp->d_ncylinders = clp->cfg_trk; /* trk is really num of cyl! */
	lp->d_ntracks = clp->cfg_hds;

	lp->d_secpercyl = clp->secpercyl;
	lp->d_secperunit = clp->secperunit;
	lp->d_secpercyl = clp->secpercyl;
	lp->d_secperunit = clp->secperunit;
	lp->d_sparespertrack = clp->sparespertrack;
	lp->d_sparespercyl = clp->sparespercyl;
	lp->d_acylinders = clp->acylinders;
	lp->d_rpm = clp->rpm;
	lp->d_interleave = clp->cfg_ilv;
	lp->d_trackskew = clp->cfg_sof;
	lp->d_cylskew = clp->cylskew;
	lp->d_headswitch = clp->headswitch;

	/* this silly table is for winchester drives */
	switch (clp->cfg_ssr) {
	case 0:
		lp->d_trkseek = 0;
		break;
	case 1:
		lp->d_trkseek = 6;
		break;
	case 2:
		lp->d_trkseek = 10;
		break;
	case 3:
		lp->d_trkseek = 15;
		break;
	case 4:
		lp->d_trkseek = 20;
		break;
	default:
		lp->d_trkseek = 0;
	}
	lp->d_flags = clp->flags;
	for (i = 0; i < NDDATA; i++)
		lp->d_drivedata[i] = clp->drivedata[i];
	for (i = 0; i < NSPARE; i++)
		lp->d_spare[i] = clp->spare[i];

	lp->d_magic2 = clp->magic2;
	lp->d_checksum = clp->checksum;
	lp->d_npartitions = clp->partitions;
	lp->d_bbsize = clp->bbsize;
	lp->d_sbsize = clp->sbsize;
	bcopy(clp->vid_4, &lp->d_partitions[0], sizeof(struct partition) * 4);
	bcopy(clp->cfg_4, &lp->d_partitions[4], sizeof(struct partition) * 12);
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
#if DEBUG
	if (disksubr_debug > 0) {
		printlp(lp, "translated label read from disk\n");
	}
#endif
}

#ifdef DEBUG
static void
printlp(lp, str)
	struct disklabel *lp;
	char *str;
{
	int i;

	printf("%s\n", str);
	printf("magic1 %x\n", lp->d_magic);
	printf("magic2 %x\n", lp->d_magic2);
	printf("typename %s\n", lp->d_typename);
	printf("secsize %x nsect %x ntrack %x ncylinders %x\n",
	    lp->d_secsize, lp->d_nsectors, lp->d_ntracks, lp->d_ncylinders);
	printf("Num partitions %x\n", lp->d_npartitions);
	for (i = 0; i < lp->d_npartitions; i++) {
		struct partition *part = &lp->d_partitions[i];
		char *fstyp = fstypenames[part->p_fstype];
		
		printf("%c: size %10x offset %10x type %7s frag %5x cpg %3x\n",
		    'a' + i, part->p_size, part->p_offset, fstyp,
		    part->p_frag, part->p_cpg);
	}
}

static void
printclp(clp, str)
	struct cpu_disklabel *clp;
	char *str;
{
	int max, i;

	printf("%s\n", str);
	printf("magic1 %x\n", clp->magic1);
	printf("magic2 %x\n", clp->magic2);
	printf("typename %s\n", clp->vid_vd);
	printf("secsize %x nsect %x ntrack %x ncylinders %x\n",
	    clp->cfg_psm, clp->cfg_spt, clp->cfg_hds, clp->cfg_trk);
	printf("Num partitions %x\n", clp->partitions);
	max = clp->partitions < 16 ? clp->partitions : 16;
	for (i = 0; i < max; i++) {
		struct partition *part;
		char *fstyp;

		if (i < 4) {
			part = (void *)&clp->vid_4[0];
			part = &part[i];
		} else {
			part = (void *)&clp->cfg_4[0];
			part = &part[i-4];
		}

		fstyp = fstypenames[part->p_fstype];
		
		printf("%c: size %10x offset %10x type %7s frag %5x cpg %3x\n",
		    'a' + i, part->p_size, part->p_offset, fstyp,
		    part->p_frag, part->p_cpg);
	}
a246 1
#endif
@
