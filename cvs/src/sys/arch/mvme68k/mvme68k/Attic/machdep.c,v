head	1.133;
access;
symbols
	OPENBSD_5_5:1.131.0.4
	OPENBSD_5_5_BASE:1.131
	OPENBSD_5_4:1.130.0.2
	OPENBSD_5_4_BASE:1.130
	OPENBSD_5_3:1.129.0.2
	OPENBSD_5_3_BASE:1.129
	OPENBSD_5_2:1.126.0.6
	OPENBSD_5_2_BASE:1.126
	OPENBSD_5_1_BASE:1.126
	OPENBSD_5_1:1.126.0.4
	OPENBSD_5_0:1.126.0.2
	OPENBSD_5_0_BASE:1.126
	OPENBSD_4_9:1.123.0.4
	OPENBSD_4_9_BASE:1.123
	OPENBSD_4_8:1.123.0.2
	OPENBSD_4_8_BASE:1.123
	OPENBSD_4_7:1.120.0.2
	OPENBSD_4_7_BASE:1.120
	OPENBSD_4_6:1.116.0.4
	OPENBSD_4_6_BASE:1.116
	OPENBSD_4_5:1.111.0.4
	OPENBSD_4_5_BASE:1.111
	OPENBSD_4_4:1.111.0.2
	OPENBSD_4_4_BASE:1.111
	OPENBSD_4_3:1.108.0.2
	OPENBSD_4_3_BASE:1.108
	OPENBSD_4_2:1.106.0.2
	OPENBSD_4_2_BASE:1.106
	OPENBSD_4_1:1.100.0.4
	OPENBSD_4_1_BASE:1.100
	OPENBSD_4_0:1.100.0.2
	OPENBSD_4_0_BASE:1.100
	OPENBSD_3_9:1.94.0.2
	OPENBSD_3_9_BASE:1.94
	OPENBSD_3_8:1.88.0.2
	OPENBSD_3_8_BASE:1.88
	OPENBSD_3_7:1.87.0.2
	OPENBSD_3_7_BASE:1.87
	OPENBSD_3_6:1.86.0.2
	OPENBSD_3_6_BASE:1.86
	SMP_SYNC_A:1.84
	SMP_SYNC_B:1.84
	OPENBSD_3_5:1.83.0.2
	OPENBSD_3_5_BASE:1.83
	OPENBSD_3_4:1.77.0.2
	OPENBSD_3_4_BASE:1.77
	UBC_SYNC_A:1.75
	OPENBSD_3_3:1.74.0.2
	OPENBSD_3_3_BASE:1.74
	OPENBSD_3_2:1.71.0.2
	OPENBSD_3_2_BASE:1.71
	OPENBSD_3_1:1.68.0.2
	OPENBSD_3_1_BASE:1.68
	UBC_SYNC_B:1.71
	UBC:1.61.0.2
	UBC_BASE:1.61
	OPENBSD_3_0:1.54.0.2
	OPENBSD_3_0_BASE:1.54
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_8:1.33.0.4
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.33.0.2
	OPENBSD_2_7_BASE:1.33
	SMP:1.31.0.2
	SMP_BASE:1.31
	kame_19991208:1.30
	OPENBSD_2_6:1.29.0.2
	OPENBSD_2_6_BASE:1.29
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.23.0.4
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.21.0.2
	OPENBSD_2_1_BASE:1.21
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.133
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.132;

1.132
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.131;

1.131
date	2013.09.28.12.40.31;	author miod;	state Exp;
branches;
next	1.130;

1.130
date	2013.06.11.16.42.09;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2013.02.02.13.36.06;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2012.10.22.04.26.33;	author miod;	state Exp;
branches;
next	1.127;

1.127
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.123;

1.123
date	2010.07.02.19.57.14;	author tedu;	state Exp;
branches;
next	1.122;

1.122
date	2010.06.27.12.41.23;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.120;

1.120
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.118;

1.118
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.117;

1.117
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.116;

1.116
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.115;

1.115
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.114;

1.114
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.113;

1.113
date	2009.03.01.22.08.13;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2009.03.01.21.40.49;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.110;

1.110
date	2008.06.08.20.57.19;	author miod;	state Exp;
branches;
next	1.109;

1.109
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2007.11.09.17.30.55;	author miod;	state Exp;
branches;
next	1.107;

1.107
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.106;

1.106
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2007.05.29.18.10.43;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2007.05.27.17.31.56;	author miod;	state Exp;
branches;
next	1.102;

1.102
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.101;

1.101
date	2007.05.23.20.33.46;	author pvalchev;	state Exp;
branches;
next	1.100;

1.100
date	2006.07.03.20.48.27;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2006.06.11.20.50.51;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2006.05.19.22.51.09;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2006.04.25.06.12.23;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2006.04.25.05.40.15;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2006.04.21.22.21.54;	author miod;	state Exp;
branches;
next	1.94;

1.94
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2005.12.11.17.05.35;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2005.11.24.22.43.19;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2005.11.24.22.41.29;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2005.11.06.17.59.57;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2005.09.27.21.50.39;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2004.09.29.07.34.42;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2004.07.30.22.29.48;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2004.07.30.09.50.18;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.18.17.34.17;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2004.03.10.23.02.54;	author tom;	state Exp;
branches;
next	1.82;

1.82
date	2004.03.02.22.55.55;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2004.02.19.18.46.18;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2004.01.16.23.40.17;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2003.12.20.00.34.32;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2003.11.06.21.09.35;	author mickey;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.02.23.27.51;	author millert;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2003.01.04.17.41.17;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2003.01.04.17.21.31;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.71;

1.71
date	2002.04.28.14.47.53;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2002.04.27.23.21.06;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2002.04.18.21.39.51;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2001.11.30.02.12.09;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2001.11.28.13.57.18;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.24.17.53.41;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2001.09.29.21.28.02;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2001.09.12.00.23.33;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.25.11.37.26;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.12.23.18.37;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.12.22.59.37;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.06.20.46.33;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.05.20.35.43;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.07.05.10.12.13;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.27.06.19.48;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.27.04.19.17;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.26.21.35.41;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.17.18.41.49;	author provos;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.05.22.33.58;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.05.20.56.45;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.17.04.30.46;	author aaron;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.05.20.39.39;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.12.07.38.31;	author smurph;	state Exp;
branches;
next	1.33;

1.33
date	2000.03.23.09.59.55;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2000.02.22.19.27.54;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.06.03.21.43;	author smurph;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	99.12.08.06.50.16;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	99.09.27.20.30.32;	author smurph;	state Exp;
branches;
next	1.28;

1.28
date	99.09.03.18.01.21;	author art;	state Exp;
branches;
next	1.27;

1.27
date	99.05.24.23.09.04;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	99.05.22.21.22.26;	author weingart;	state Exp;
branches;
next	1.25;

1.25
date	99.02.04.23.00.26;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	99.01.07.23.16.01;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.03.01.00.37.42;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.07.23.06.58.21;	author denny;	state Exp;
branches;
next	1.21;

1.21
date	97.03.31.00.24.14;	author downsj;	state Exp;
branches;
next	1.20;

1.20
date	97.02.14.05.10.17;	author rahnds;	state Exp;
branches;
next	1.19;

1.19
date	97.02.04.17.22.52;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.02.03.15.04.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.02.03.12.48.52;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.02.02.00.43.20;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.01.28.09.01.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.01.27.22.48.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.16.20.43.38;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	96.07.27.11.40.42;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.06.11.10.15.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.08.02.10.54;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.05.06.21.55.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.04.16.07.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.28.10.59.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.01.05.16.18.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.11.29.17.02.49;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.28.01.24.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.07.08.50.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.12.22.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.12;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.42.47;	author deraadt;	state Exp;
branches;
next	;

1.31.2.1
date	2000.03.02.07.04.31;	author niklas;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2000.03.24.09.08.07;	author niklas;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2001.04.18.16.10.39;	author niklas;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.07.04.10.19.39;	author niklas;	state Exp;
branches;
next	1.31.2.5;

1.31.2.5
date	2001.10.31.03.01.17;	author nate;	state Exp;
branches;
next	1.31.2.6;

1.31.2.6
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.31.2.7;

1.31.2.7
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.31.2.8;

1.31.2.8
date	2002.03.06.01.07.00;	author niklas;	state Exp;
branches;
next	1.31.2.9;

1.31.2.9
date	2002.03.28.10.34.06;	author niklas;	state Exp;
branches;
next	1.31.2.10;

1.31.2.10
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.31.2.11;

1.31.2.11
date	2003.05.13.19.41.06;	author ho;	state Exp;
branches;
next	1.31.2.12;

1.31.2.12
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.31.2.13;

1.31.2.13
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	1.31.2.14;

1.31.2.14
date	2004.06.05.23.10.53;	author niklas;	state Exp;
branches;
next	;

1.61.2.1
date	2002.01.31.22.55.15;	author niklas;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2003.05.19.21.45.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.133
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: machdep.c,v 1.132 2014/03/13 03:52:55 dlg Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1999 Steve Murphree, Jr. (68060 support)
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: machdep.c 1.74 92/12/20$
 *
 *	@@(#)machdep.c	8.10 (Berkeley) 4/20/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/mount.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/vnode.h>
#include <sys/sysctl.h>
#include <sys/syscallargs.h>
#include <sys/evcount.h>

#include <machine/atomic.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/kcore.h>
#include <machine/prom.h>
#include <machine/psl.h>
#include <machine/pte.h>
#include <machine/reg.h>

#ifdef MVME141
#include <mvme68k/dev/ofobioreg.h>
#endif
#ifdef MVME147
#include <mvme68k/dev/pccreg.h>
#endif
#ifdef MVME165
#include <mvme68k/dev/lrcreg.h>
#endif
 
#include <dev/cons.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#include <ddb/db_var.h>
#endif

#include <net/if.h>
#include <uvm/uvm.h>

/* the following is used externally (sysctl_hw) */
char machine[] = MACHINE;		/* cpu "architecture" */

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

extern vaddr_t avail_end;

int   physmem;			/* size of physical memory, in pages */

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = PSL_LOWIPL;

void dumpsys(void);
void initvectors(void);
void mvme68k_init(void);
void identifycpu(void);
int cpu_sysctl(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
void dumpconf(void);
void straytrap(int, u_short);
void netintr(void *);
void myetheraddr(u_char *);
int fpu_gettype(void);
int memsize162(void);
int memsize1x7(void);	/* in locore */
int memsize(void);

void
mvme68k_init()
{
	extern vaddr_t avail_start;

	/*
	 * Tell the VM system about available physical memory.  The
	 * mvme68k only has one segment.
	 */

	uvmexp.pagesize = NBPG;
	uvm_setpagesize();
	uvm_page_physload(atop(avail_start), atop(avail_end),
	    atop(avail_start), atop(avail_end), 0);

	/* 
	 * Put machine specific exception vectors in place.
	 */
	initvectors();
}

/*
 * Console initialization: called early on from main,
 * before vm init or startup, but already running virtual.
 * Do enough configuration to choose and initialize a console.
 */
void
consinit()
{
	/*
	 * Initialize the console before we print anything out.
	 */
	cninit();

#ifdef DDB
	db_machine_init();
	ddb_init();

	if (boothowto & RB_KDB)
		Debugger();
#endif
}

/*
 * cpu_startup: allocate memory for variable-sized tables,
 * initialize cpu, and do autoconfiguration.
 */
void
cpu_startup()
{
	unsigned i;
	vaddr_t minaddr, maxaddr;
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;

	pmapdebug = 0;
#endif

	/*
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in pmap_bootstrap to compensate.
	 */
	for (i = 0; i < atop(MSGBUFSIZE); i++)
		pmap_kenter_pa((vaddr_t)msgbufp + i * PAGE_SIZE,
		    avail_end + i * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE);
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf("%s", version);
	identifycpu();
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
	    ptoa(physmem) / 1024 / 1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio.
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);

#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	printf("avail mem = %u (%uMB)\n",
	    ptoa(uvmexp.free), ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * Info for CTL_HW
 */
char  cpu_model[120];

int   cputyp;
int   cpuspeed;

struct   mvmeprom_brdid brdid;

void
identifycpu()
{
	char mc;
	char speed[6];
	char suffix[30];
	int len;

	bzero(suffix, sizeof suffix);

	switch (mmutype) {
	case MMU_68060:
		mc = '6';
		break;
	case MMU_68040:
		mc = '4';
		break;
	case MMU_68030:
		mc = '3';
		break;
	default:
		mc = '2';
	}

	switch (cputyp) {
#ifdef MVME141
	case CPU_141:
		snprintf(suffix, sizeof suffix, "MVME%x", brdid.model);
#if 0
		cpuspeed = ofobiospeed((struct ofobioreg *)IIOV(0xfffb0000));
#else
		cpuspeed = 50;
#endif
		snprintf(speed, sizeof speed, "%02d", cpuspeed);
		break;
#endif
#ifdef MVME147
	case CPU_147:
		snprintf(suffix, sizeof suffix, "MVME%x", brdid.model);
		cpuspeed = pccspeed((struct pccreg *)IIOV(0xfffe1000));
		snprintf(speed, sizeof speed, "%02d", cpuspeed);
		break;
#endif
#if defined(MVME162) || defined(MVME167) || defined(MVME172) || defined(MVME177)
	case CPU_162:
	case CPU_166:
	case CPU_167:
	case CPU_172:
	case CPU_176:
	case CPU_177:
		bzero(speed, sizeof speed);
		speed[0] = brdid.speed[0];
		speed[1] = brdid.speed[1];
		if (brdid.speed[2] != '0' &&
			 brdid.speed[3] != '0') {
			speed[2] = '.';
			speed[3] = brdid.speed[2];
			speed[4] = brdid.speed[3];
		}
		cpuspeed = (speed[0] - '0') * 10 + (speed[1] - '0');
		bcopy(brdid.longname, suffix, sizeof(brdid.longname));
		for (len = strlen(suffix)-1; len; len--) {
			if (suffix[len] == ' ')
				suffix[len] = '\0';
			else
				break;
		}
		break;
#endif
#ifdef MVME165
	case CPU_165:
		snprintf(suffix, sizeof suffix, "MVME%x", brdid.model);
		cpuspeed = lrcspeed((struct lrcreg *)IIOV(0xfff90000));
		snprintf(speed, sizeof speed, "%02d", cpuspeed);
		break;
#endif
	}
	snprintf(cpu_model, sizeof cpu_model,
	    "Motorola %s: %sMHz MC680%c0 CPU", suffix, speed, mc);
	switch (mmutype) {
#if defined(M68040)
	case MMU_68040:
		/* FALLTHROUGH */
#endif
#if defined(M68060)
	case MMU_68060:
		/* FALLTHROUGH */
#endif
	case MMU_68030:
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
		break;
	case MMU_68851:
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
		break;
	default:
		printf("%s\n", cpu_model);
		panic("unknown MMU type %d", mmutype);
	}

	switch (mmutype) {
#if defined(M68060)
	case MMU_68060:
		strlcat(cpu_model,"+FPU, 8k on-chip physical I/D caches",
		    sizeof cpu_model);
		break;
#endif
#if defined(M68040)
	case MMU_68040:
		strlcat(cpu_model, "+FPU, 4k on-chip physical I/D caches",
		    sizeof cpu_model);
		break;
#endif
#if defined(M68030) || defined(M68020)
	default:
		fputype = fpu_gettype();

		switch (fputype) {
		case FPU_NONE:
			break;
		case FPU_68881:
		case FPU_68882:
			len = strlen (cpu_model);
			snprintf(cpu_model + len, sizeof cpu_model - len,
			    ", MC6888%d FPU", fputype);
			break;
		default:
			strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
			break;
		}
		break;
#endif
	}
	printf("%s\n", cpu_model);
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

int   waittime = -1;

__dead void
boot(howto)
	int howto;
{
	struct device *mainbus;

	/* If system is cold, just halt. */
	if (cold) {
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	/* take a snap shot before clobbering any registers */
	if (curproc && curproc->p_addr)
		savectx(&curproc->p_addr->u_pcb);

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		extern struct proc proc0;
		/* do that another panic fly away */
		if (curproc == NULL)
			curproc = &proc0;
		waittime = 0;
		vfs_shutdown();
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();			/* Disable interrupts. */

	/* If rebooting and a dump is requested, do it. */
	if (howto & RB_DUMP)
		dumpsys();

haltsys:
	doshutdownhooks();
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);

	if (howto & RB_HALT) {
		printf("System halted. Press any key to reboot...\n\n");
		cnpollc(1);
		cngetc();
		cnpollc(0);
	}

	doboot();

	for (;;);
	/*NOTREACHED*/
}

/*
 * These variables are needed by /sbin/savecore
 */
u_long   dumpmag = 0x8fca0101;	/* magic number */
int   dumpsize = 0;		/* pages */
long  dumplo = 0;		/* blocks */
cpu_kcore_hdr_t cpu_kcore_hdr;

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	int nblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = physmem;

	/* mvme68k only uses a single segment. */
	cpu_kcore_hdr.ram_segs[0].start = 0;
	cpu_kcore_hdr.ram_segs[0].size = ptoa(physmem);
	cpu_kcore_hdr.mmutype = mmutype;
	cpu_kcore_hdr.kernel_pa = 0;
	cpu_kcore_hdr.sysseg_pa = pmap_kernel()->pm_stpa;

	/* Always skip the first block, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize + 1 > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo) - 1;
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
void
dumpsys()
{
	int maj;
	int psize;
	daddr_t blkno;		/* current block to write */
					/* dump routine */
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int pg;				/* page being dumped */
	paddr_t maddr;			/* PA being dumped */
	int error;			/* error code from (*dump)() */
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */

	extern int msgbufmapped;

	msgbufmapped = 0;

	/* Make sure dump device is valid. */
	if (dumpdev == NODEV)
		return;
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	maj = major(dumpdev);
	if (dumplo < 0) {
		printf("\ndump to dev %u,%u not possible\n", maj,
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[maj].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", maj,
	    minor(dumpdev), dumplo);

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif

	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	/*
	 * Generate a segment header
	 */
	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));

	/*
	 * Add the md header
	 */
	*chdr_p = cpu_kcore_hdr;

	printf("dump ");
	psize = (*bdevsw[maj].d_psize)(dumpdev);
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	/* Dump the header. */
	error = (*dump) (dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	if (error != 0)
		goto abort;

	maddr = (paddr_t)0;
	for (pg = 0; pg < dumpsize; pg++) {
#define	NPGMB	(1024 * 1024 / PAGE_SIZE)
		/* print out how many MBs we have dumped */
		if (pg != 0 && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef	NPGMB
		pmap_kenter_pa((vaddr_t)vmmap, maddr, VM_PROT_READ);
		pmap_update(pmap_kernel());
		error = (*dump)(dumpdev, blkno, vmmap, PAGE_SIZE);
		pmap_kremove((vaddr_t)vmmap, PAGE_SIZE);
		pmap_update(pmap_kernel());

		if (error == 0) {
			maddr += PAGE_SIZE;
			blkno += btodb(PAGE_SIZE);
		} else
			break;
	}
abort:
	switch (error) {
	case 0:
		printf("succeeded\n");
		break;

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
}

#if defined(M68060)
int m68060_pcr_init = 0x20 | PCR_SUPERSCALAR;	/* make this patchable */
#endif

void
initvectors()
{
#if defined(M68060)
	typedef void trapfun(void);
	extern trapfun *vectab[256];
#if defined(M060SP)
	extern trapfun intemu60, fpiemu60, fpdemu60, fpeaemu60;
	extern u_int8_t FP_CALL_TOP[];
#else
	extern trapfun illinst;
#endif
	extern trapfun fpfault;
#endif
#if defined(M68040) && defined(FPSP)
	extern u_long fpvect_tab, fpvect_end, fpsp_tab;
#endif

	switch (cputype) {
#ifdef M68060
	case CPU_68060:
		asm volatile ("movl %0,%%d0; .word 0x4e7b,0x0808" : : 
						  "d"(m68060_pcr_init):"d0" );

#if defined(M060SP)
		/* integer support */
		vectab[61] = intemu60/*(trapfun *)&I_CALL_TOP[128 + 0x00]*/;

		/* floating point support */
		/*
		 * XXX maybe we really should run-time check for the
		 * stack frame format here:
		 */
		vectab[11] = fpiemu60/*(trapfun *)&FP_CALL_TOP[128 + 0x30]*/;

		vectab[55] = fpdemu60/*(trapfun *)&FP_CALL_TOP[128 + 0x38]*/;
		vectab[60] = fpeaemu60/*(trapfun *)&FP_CALL_TOP[128 + 0x40]*/;

		vectab[54] = (trapfun *)&FP_CALL_TOP[128 + 0x00];
		vectab[52] = (trapfun *)&FP_CALL_TOP[128 + 0x08];
		vectab[53] = (trapfun *)&FP_CALL_TOP[128 + 0x10];
		vectab[51] = (trapfun *)&FP_CALL_TOP[128 + 0x18];
		vectab[50] = (trapfun *)&FP_CALL_TOP[128 + 0x20];
		vectab[49] = (trapfun *)&FP_CALL_TOP[128 + 0x28];
#else
		vectab[61] = illinst;
#endif
		vectab[48] = fpfault;
		break;
#endif
#if defined(M68040) && defined(FPSP)
	case CPU_68040:
		bcopy(&fpsp_tab, &fpvect_tab,
		    (&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
		break;
#endif
	default:
		break;
	}
}

void
straytrap(pc, evec)
	int pc;
	u_short evec;
{
	printf("unexpected trap (vector 0x%x) from %x\n",
	    (evec & 0xFFF) >> 2, pc);
}

int   *nofault;

int
badpaddr(addr, size)
	paddr_t addr;
	int size;
{
	int off = (int)addr & PGOFSET;
	vaddr_t v;
	paddr_t p = trunc_page(addr);
	int x;

	v = mapiodev(p, NBPG);
	if (v == 0)
		return (1);
	x = badvaddr(v + off, size);
	unmapiodev(v, NBPG);
	return (x);
}

int
badvaddr(addr, size)
	vaddr_t addr;
	int size;
{
	int i;
	label_t  faultbuf;

	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
		return (1);
	}
	switch (size) {
		case 1:
			i = *(volatile char *)addr;
			break;
		case 2:
			i = *(volatile short *)addr;
			break;
		case 4:
			i = *(volatile long *)addr;
			break;
	}
	nofault = (int *)0;
	return (0);
}

/*
 * Level 7 interrupts are normally caused by the ABORT switch,
 * drop into ddb.
 */
void
nmihand(frame)
	void *frame;
{
	printf("Abort switch pressed\n");
#ifdef DDB
	if (db_console)
		Debugger();
#endif
}

u_char   myea[6] = { 0x08, 0x00, 0x3e, 0xff, 0xff, 0xff};

void
myetheraddr(ether)
	u_char *ether;
{
	bcopy(myea, ether, sizeof myea);
}

#if defined(M68030) || defined(M68020)
int
fpu_gettype()
{
	/*
	 * A 68881 idle frame is 28 bytes and a 68882's is 60 bytes.
	 * We, of course, need to have enough room for either.
	 */
	int   fpframe[60 / sizeof(int)];
	label_t  faultbuf;
	u_char   b;

	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
		return (0);		/* no FPU */
	}

	/*
	 * Synchronize FPU or cause a fault.
	 * This should leave the 881/882 in the IDLE state,
	 * state, so we can determine which we have by
	 * examining the size of the FP state frame
	 */
	asm("fnop");

	nofault = (int *)0;

	/*
	 * Presumably, this will not cause a fault--the fnop should
	 * have if this will.  We save the state in order to get the
	 * size of the frame.
	 */
	asm("movl %0, %%a0; fsave %%a0@@" : : "a" (fpframe) : "a0" );
	b = *((u_char *) fpframe + 1);

	/*
	 * Now, restore a NULL state to reset the FPU.
	 */
	fpframe[0] = fpframe[1] = 0;
	m68881_restore((struct fpframe *)fpframe);

	if (b == 0x18)
		return (FPU_68881);	/* The size of a 68881 IDLE frame is 0x18 */
	if (b == 0x38)
		return (FPU_68882);	/* 68882 frame is 0x38 bytes long */
	return (FPU_UNKNOWN);		/* unknown FPU type */
}
#endif


#if defined(MVME162) || defined(MVME172)
#include <mvme68k/dev/mcreg.h>
/*
 * XXX
 * used by locore.s to figure out how much memory is on the machine.
 * At this stage we only know that our machine is a 162. It is very
 * unfortunate that the MCchip's address must be encoded here.
 */
int
memsize162()
{
	struct mcreg *mc = (struct mcreg *)0xfff42000;

	switch (mc->mc_memoptions & MC_MEMOPTIONS_DRAMMASK) {
	case MC_MEMOPTIONS_DRAM1M:
		return (1*1024*1024);
	case MC_MEMOPTIONS_DRAM2M:
		return (2*1024*1024);
	case MC_MEMOPTIONS_DRAM4M:
		return (4*1024*1024);
	case MC_MEMOPTIONS_DRAM4M2:
		return (4*1024*1024);
	case MC_MEMOPTIONS_DRAM8M:
		return (8*1024*1024);
	case MC_MEMOPTIONS_DRAM16M:
		return (16*1024*1024);
	default:
		/*
		 * XXX if the machine has no MC-controlled memory,
		 * perhaps it has a MCECC or MEMC040 controller?
		 */
		return (memsize1x7());
	}
}
#endif

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	__asm __volatile ("movew %%sr,%0" : "=&d" (oldipl));

	oldipl = PSLTOIPL(oldipl);

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		_spl(PSL_S | IPLTOPSL(wantipl));
	}
}
#endif
@


1.132
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2013/09/28 12:40:31 miod Exp $ */
@


1.131
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2013/06/11 16:42:09 deraadt Exp $ */
d454 2
d498 3
a500 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.130
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2013/02/02 13:36:06 miod Exp $ */
d496 2
a497 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.129
log
@mvme68k ELF bits. Boot block updates heavily based upon the recent mvme88k
a.out->ELF transition.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2012/10/22 04:26:33 miod Exp $ */
d567 1
a567 1
	daddr64_t blkno;		/* current block to write */
d569 1
a569 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.128
log
@missing header
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2012/10/08 21:47:48 deraadt Exp $ */
d708 1
a708 1
		asm volatile ("movl %0,d0; .word 0x4e7b,0x0808" : : 
d862 1
a862 1
	asm("movl %0, a0; fsave a0@@" : : "a" (fpframe) : "a0" );
d922 1
a922 1
	__asm __volatile ("movew sr,%0" : "=&d" (oldipl));
@


1.127
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2011/06/26 22:40:00 deraadt Exp $ */
d73 1
@


1.126
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2011/06/05 19:41:07 deraadt Exp $ */
a493 1
	/* Run any shutdown hooks. */
d495 1
@


1.125
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2011/05/30 22:25:21 oga Exp $ */
d118 1
d484 1
@


1.124
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2010/07/02 19:57:14 tedu Exp $ */
a126 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef	BUFCACHEPERCENT
#define	BUFCACHEPERCENT	5
#endif

#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.123
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2010/06/27 12:41:23 miod Exp $ */
d180 1
a180 1
	    atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
@


1.122
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2010/06/27 03:03:48 thib Exp $ */
a152 4
#ifdef COMPAT_SUNOS
extern struct emul emul_sunos;
#endif

a828 24
}

/*
 * cpu_exec_aout_makecmds():
 *	cpu-dependent a.out format hook for execve().
 * 
 * Determine of the given exec package refers to something which we
 * understand and, if so, set up the vmcmds for it.
 */
int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error = ENOEXEC;

#ifdef COMPAT_SUNOS
	{
		extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
		if ((error = sunos_exec_aout_makecmds(p, epp)) == 0)
			return (0);
	}
#endif
	return (error);
@


1.121
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2009/08/11 18:46:32 miod Exp $ */
d118 1
a118 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>
@


1.120
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d144 4
@


1.119
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2009/08/09 10:40:17 blambert Exp $ */
a243 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.118
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 2009/08/02 16:28:39 beck Exp $ */
a166 1
caddr_t allocsys(caddr_t);
a218 1
	caddr_t v;
a219 1
	vsize_t size;
a245 10
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	size = (vsize_t)allocsys((caddr_t)0);
	if ((v = (caddr_t) uvm_km_zalloc(kernel_map, round_page(size))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != size)
		panic("startup: table size inconsistency");

	/*
a287 19
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * You call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(caddr_t v)
{

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name) + (num))

	return (v);
@


1.117
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2009/06/15 17:01:26 beck Exp $ */
a87 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a317 6
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.116
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2009/06/03 21:30:20 beck Exp $ */
a266 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.115
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2009/03/15 20:40:25 miod Exp $ */
d267 6
@


1.114
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2009/03/01 22:08:13 miod Exp $ */
a266 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.113
log
@Support for MVME141 boards. Tested with both VME and VSB memory boards
(and MVME327 SCSI and MVME376 Ethernet, to provide a complete system).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2009/03/01 21:40:49 miod Exp $ */
a113 2
#include <net/netisr.h>

a868 23
}

int netisr;

void
netintr(arg)
	void *arg;
{
	int n;

	while ((n = netisr) != 0) {
		atomic_clearbits_int(&netisr, n);

#define DONETISR(bit, fn)						\
		do {							\
			if (n & (1 << (bit)))				\
				(fn)();					\
		} while (0)

#include <net/netisr_dispatch.h>

#undef DONETISR
	}
@


1.112
log
@Support for MVME165 board - code written in april 2006, eventually debugged
last month.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2008/06/27 17:22:14 miod Exp $ */
d102 3
d374 11
d758 1
a760 1
#if defined(M68060)
@


1.111
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2008/06/08 20:57:19 miod Exp $ */
d105 3
d380 1
d383 1
d404 7
d890 1
d892 2
a893 5
	printf("NMI ... going to debugger\n");
	Debugger();
#else
	/* panic?? */
	printf("unexpected level 7 interrupt ignored\n");
@


1.110
log
@Make sure to cnpollc(1)/cnpollc(0) around cngetc() or getsn() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2008/04/09 16:58:10 deraadt Exp $ */
d118 1
d642 4
@


1.109
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2008/04/09 16:50:29 deraadt Exp $ */
d541 1
d543 1
@


1.108
log
@Move splassert_check() from common m68k code to each m68k-based architecture,
as its implementation may vary accross platforms (and will very soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2007/11/02 19:18:54 martin Exp $ */
d528 2
a529 2
	/* Disable interrupts. */
	splhigh();
@


1.107
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.106 2007/06/06 17:15:12 deraadt Exp $ */
d996 21
@


1.106
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2007/05/29 20:36:47 deraadt Exp $ */
d232 1
a232 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d243 2
a244 2
	printf("real mem = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem) / 1024 / 1024);
d580 1
a580 1
	cpu_kcore_hdr.ram_segs[0].size = ctob(physmem);
@


1.105
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2007/05/29 18:10:43 miod Exp $ */
d606 1
a606 1
	daddr_t blkno;			/* current block to write */
d608 1
a608 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.104
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.103 2007/05/27 17:31:56 miod Exp $ */
d566 1
a566 1
dumpconf()
a568 1
	int maj;
d570 2
a571 1
	if (dumpdev == NODEV)
a572 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
@


1.103
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2007/05/26 20:26:51 pedro Exp $ */
d93 1
d852 11
a862 7
#define DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << (bit))) { \
			netisr &= ~(1 << (bit)); \
			(fn)(); \
		} \
	} while (0)
d864 1
d866 1
@


1.102
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2007/05/23 20:33:46 pvalchev Exp $ */
d272 1
@


1.101
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2006/07/03 20:48:27 miod Exp $ */
a128 6
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a217 2
	int base, residual;
	
d256 2
a257 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d259 2
a260 13
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
d262 5
a266 27
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t)buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");

			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a291 2
	printf("using %d buffers containing %d bytes of memory\n",
			 nbuf, bufpages * PAGE_SIZE);
a326 23
	/*
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless. */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.100
log
@Repair initialization value of m68060_pcr_init, per 68060 errata I14.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2006/06/11 20:50:51 miod Exp $ */
d250 2
a251 1
	printf("real mem = %d (%dK)\n", ctob(physmem), ctob(physmem) / 1024);
d331 2
a332 2
	printf("avail mem = %d (%dK)\n",
	    ptoa(uvmexp.free), ptoa(uvmexp.free) / 1024);
@


1.99
log
@Set up FPSP exception vectors on 68040 models in initvectors(), as done for the
68060 SP, instead of in identifycpu().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2006/05/19 22:51:09 miod Exp $ */
d788 1
a788 1
int m68060_pcr_init = PCR_SUPERSCALAR;	/* make this patchable */
@


1.98
log
@Get rid of ``maxmem'' and fix the descriptive comment for ``physmem''.
Either maxmem is not used (mac68k), or the position of the physical memory
is set in stone so we don't need to know the top of the memory (MAXADDR
on hp300, physmem on mvme68k) it was pointing to.

Plus this gets rid of unused lowram on mvme68k - all the m68k world is not an
hp300, after all.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2006/04/25 06:12:23 miod Exp $ */
a152 5
extern   short exframesize[];

#ifdef COMPAT_HPUX
extern struct emul emul_hpux;
#endif
a156 1

a410 3
#ifdef FPSP
	extern u_long fpvect_tab, fpvect_end, fpsp_tab;
#endif
d465 1
a465 1
#if defined(M68060) || defined(M68040)
d467 1
a467 3
#ifdef FPSP
		bcopy(&fpsp_tab, &fpvect_tab,
		    (&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
d469 1
a469 1
		/* FALLTHROUGH */
d483 1
d788 1
a788 1
int m68060_pcr_init = 0x21;	/* make this patchable */
d795 1
a795 2

	/* XXX should init '40 vecs here, too */
a796 4
	extern trapfun *vectab[256];
	extern trapfun addrerr4060;

	extern trapfun buserr60;
a797 1
	/*extern u_int8_t I_CALL_TOP[];*/
d805 3
d809 1
d811 1
a811 1
	if (cputype == CPU_68060) {
d839 10
a849 1
#endif
@


1.97
log
@Missed an include chunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2006/04/25 05:40:15 deraadt Exp $ */
d146 1
a146 2
int   maxmem;			/* max memory per process */
int   physmem;			/* max supported memory, changes to actual */
@


1.96
log
@that extern was needed for now, miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2006/04/21 22:21:54 miod Exp $ */
d112 2
a207 2
	extern void db_machine_init(void);

@


1.95
log
@Since bugtty (and BUG routines in general) can only work if we keep the BUG
mapped, and we don't, do not bother carrying this code around - it can not
be used anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2005/12/17 07:31:26 miod Exp $ */
d206 2
@


1.94
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2005/12/11 17:05:35 miod Exp $ */
a93 1
#include <machine/bugio.h>
d101 1
d103 1
a160 21
/* 
 *  XXX this is to fake out the console routines, while 
 *  booting. New and improved! :-) smurph
 */
void bootcnprobe(struct consdev *);
void bootcninit(struct consdev *);
void bootcnputc(dev_t, int);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);

#define bootcnpollc nullcnpollc

static struct consdev bootcons = {
	NULL, 
	NULL, 
	bootcngetc, 
	bootcnputc,
	bootcnpollc, 
	NULL,
	makedev(14,0), 
	1};
d190 1
a190 1
			  atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
a195 3

	/* startup fake console driver.  It will be replaced by consinit() */
	cn_tab = &bootcons;
d200 2
a201 2
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
a205 2
	extern void db_machine_init(void);

a208 1
	cn_tab = NULL;	/* Get rid of fake console driver */
a211 1

d214 1
d1043 18
a1060 18
		case MC_MEMOPTIONS_DRAM1M:
			return (1*1024*1024);
		case MC_MEMOPTIONS_DRAM2M:
			return (2*1024*1024);
		case MC_MEMOPTIONS_DRAM4M:
			return (4*1024*1024);
		case MC_MEMOPTIONS_DRAM4M2:
			return (4*1024*1024);
		case MC_MEMOPTIONS_DRAM8M:
			return (8*1024*1024);
		case MC_MEMOPTIONS_DRAM16M:
			return (16*1024*1024);
		default:
			/*
			 * XXX if the machine has no MC-controlled memory,
			 * perhaps it has a MCECC or MEMC040 controller?
			 */
			return (memsize1x7());
a1063 38

/*
 * Boot console routines: 
 * Enables printing of boot messages before consinit().
 */

void
bootcnprobe(cp)
	struct consdev *cp;
{
	cp->cn_dev = makedev(14, 0);
	cp->cn_pri = CN_NORMAL;
}

void
bootcninit(cp)
	struct consdev *cp;
{
	/* Nothing to do */
}

int
bootcngetc(dev)
	dev_t dev;
{
	return (bug_inchr());
}

void
bootcnputc(dev, c)
	dev_t dev;
	int c;
{
	char cc = (char)c;
	if (cc == '\n')
		bug_outchr('\r');
	bug_outchr(cc);
}
@


1.93
log
@On halt, wait for a keypress on the console and reboot; allows one to have
the BUG set to auto-boot and not lose the machine upon halting.
Requested by deraadt@@ and nick@@ long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2005/11/24 22:43:19 miod Exp $ */
d121 1
a121 1
extern vm_offset_t avail_end;
d200 1
a200 1
	extern vm_offset_t avail_start, avail_end;
d258 1
a258 1
	vm_size_t size;
d271 1
a271 1
		pmap_kenter_pa((vm_offset_t)msgbufp + i * PAGE_SIZE,
d287 1
a287 1
	size = (vm_size_t)allocsys((caddr_t)0);
d322 1
a322 1
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
@


1.92
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2005/11/24 22:41:29 miod Exp $ */
d638 2
a639 3
		printf("halted\n\n");
	} else {
		doboot();
d641 3
@


1.91
log
@Peek at the correct location in badpaddr() - how could this go unnoticed before?
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2005/11/06 17:59:57 miod Exp $ */
d895 2
a896 1
	caddr_t v, p = (void *)((int)addr & ~PGOFSET);
d900 1
a900 1
	if (v == NULL)
d902 1
a902 1
	x = badvaddr((vaddr_t)v + off, size);
@


1.90
log
@Factorize setregs() code to m68k-common location.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2005/09/27 21:50:39 miod Exp $ */
a900 1
	v += off;
@


1.89
log
@Do not initialize physmem to a magic value at compile time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2005/08/06 14:26:52 miod Exp $ */
a423 49
}

/*
 * Set registers on exec.
 */
void
setregs(p, pack, stack, retval)
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct frame *frame = (struct frame *)p->p_md.md_regs;

	frame->f_sr = PSL_USERSET;
	frame->f_pc = pack->ep_entry & ~1;
	frame->f_regs[D0] = 0;
	frame->f_regs[D1] = 0;
	frame->f_regs[D2] = 0;
	frame->f_regs[D3] = 0;
	frame->f_regs[D4] = 0;
	frame->f_regs[D5] = 0;
	frame->f_regs[D6] = 0;
	frame->f_regs[D7] = 0;
	frame->f_regs[A0] = 0;
	frame->f_regs[A1] = 0;
	frame->f_regs[A2] = (int)PS_STRINGS;
	frame->f_regs[A3] = 0;
	frame->f_regs[A4] = 0;
	frame->f_regs[A5] = 0;
	frame->f_regs[A6] = 0;
	frame->f_regs[SP] = stack;

	/* restore a null state frame */
	p->p_addr->u_pcb.pcb_fpregs.fpf_null = 0;
	if (fputype)
		m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);

#ifdef COMPAT_SUNOS
	/*
	 * SunOS' ld.so does self-modifying code without knowing
	 * about the 040's cache purging needs.  So we need to uncache
	 * writeable executable pages.
	 */
	if (p->p_emul == &emul_sunos)
		p->p_md.md_flags |= MDP_UNCACHE_WX;
	else
		p->p_md.md_flags &= ~MDP_UNCACHE_WX;
#endif
@


1.88
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2004/09/29 07:34:42 miod Exp $ */
a112 2
#define	MAXMEM	64*1024	/* XXX - from cmap.h */

d144 1
a144 1
int   physmem = MAXMEM;	/* max supported memory, changes to actual */
@


1.87
log
@Do not count 060SP traps; there are too many of them, better handle them
as fast as possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2004/07/30 22:29:48 miod Exp $ */
d118 1
a118 1
char machine[] = "mvme68k";		/* cpu "architecture" */
@


1.86
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2004/07/30 09:50:18 miod Exp $ */
a161 7
/* 68060-specific event counters */
#if defined(M68060)
struct evcount ec_60bpe;
#if defined(M060SP)
struct evcount ec_60iem, ec_60fpiem, ec_60fpdem, ec_60fpeaem;
#endif
#endif
a603 11

	/* No better place to put these... */
#if defined(M68060)
	evcount_attach(&ec_60bpe, "68060bpe", NULL, &evcount_intr);
#if defined(M060SP)
	evcount_attach(&ec_60iem, "68060iem", NULL, &evcount_intr);
	evcount_attach(&ec_60fpiem, "68060fpiem", NULL, &evcount_intr);
	evcount_attach(&ec_60fpdem, "68060fpdem", NULL, &evcount_intr);
	evcount_attach(&ec_60fpeaem, "68060fpeaem", NULL, &evcount_intr);
#endif
#endif
@


1.85
log
@Switch mvme68k to evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2004/04/18 17:34:17 miod Exp $ */
a195 1
void halt_establish(void (*)(void), int);
a658 48
static struct haltvec *halts;

/* XXX insert by priority */
void
halt_establish(fn, pri)
	void (*fn)(void);
	int pri;
{
	struct haltvec *hv, *h;

	hv = (struct haltvec *)malloc(sizeof(*hv), M_TEMP, M_NOWAIT);
	if (hv == NULL)
		return;
	hv->hv_fn = fn;
	hv->hv_pri = pri;
	hv->hv_next = NULL;

	/* put higher priorities earlier in the list */
	h = halts;
	if (h == NULL) {
		halts = hv;
		return;
	}

	if (h->hv_pri < pri) {
		/* higher than first element */
		hv->hv_next = halts;
		halts = hv;
		return;
	}

	while (h) {
		if (h->hv_next == NULL) {
			/* no more elements, must be the lowest priority */
			h->hv_next = hv;
			return;
		}

		if (h->hv_next->hv_pri < pri) {
			/* next element is lower */
			hv->hv_next = h->hv_next;
			h->hv_next = hv;
			return;
		}
		h = h->hv_next;
	}
}

a708 4
		struct haltvec *hv;

		for (hv = halts; hv; hv = hv->hv_next)
			(*hv->hv_fn)();
d952 2
a953 2
	printf("unexpected trap (vector %d) from %x\n",
			 (evec & 0xFFF) >> 2, pc);
@


1.84
log
@In cpu_startup(), move the memory size computations to allocsys() instead
of unrolling the logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2004/03/10 23:02:54 tom Exp $ */
d91 1
d162 7
d612 11
@


1.83
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2004/03/02 22:55:55 miod Exp $ */
d128 1
a128 1
int   nbuf = NBUF;
d130 1
a130 1
int   nbuf = 0;
d132 5
d138 1
a138 1
int   bufpages = BUFPAGES;
d140 1
a140 1
int   bufpages = 0;
d142 2
d197 1
d255 2
a256 2
	register unsigned i;
	register caddr_t v, firstaddr;
d273 2
a274 2
		pmap_kenter_pa((vm_offset_t)msgbufp,
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE);
d281 1
a281 1
	printf(version);
d283 1
a283 1
	printf("real mem = %d\n", ctob(physmem));
d286 2
a287 33
	 * Allocate space for system data structures.
	 * The first available real memory address is in "firstaddr".
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
	 * As pages of memory are allocated and cleared,
	 * "firstaddr" is incremented.
	 * An index into the kernel page table corresponding to the
	 * virtual memory address maintained in "v" is kept in "mapaddr".
	 */
	/*
	 * Make two passes.  The first pass calculates how much memory is
	 * needed and allocates it.  The second pass assigns virtual
	 * addresses to the various data structures.
	 */
	firstaddr = 0;
again:
	v = (caddr_t)firstaddr;

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

	/*
	 * Determine how many buffers to allocate.
	 * We just allocate a flat 5%.  Insure a minimum of 16 buffers.
	 * We allocate 1/2 as many swap buffer headers as file i/o buffers.
d289 4
a292 22
	if (bufpages == 0)
		bufpages = physmem / 20;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	valloc(buf, struct buf, nbuf);
	/*
	 * End of first pass, size has been calculated so allocate memory
	 */
	if (firstaddr == 0) {
		size = (vm_size_t)(v - firstaddr);
		firstaddr = (caddr_t) uvm_km_zalloc(kernel_map, round_page(size));
		if (firstaddr == 0)
			panic("startup: no room for tables");
		goto again;
	}
	/*
	 * End of second pass, addresses have been assigned
	 */
	if ((vm_size_t)(v - firstaddr) != size)
d294 1
d300 1
a300 1
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, m68k_round_page(size),
a305 1
	
a356 3
	printf("avail mem = %ld (%d pages)\n", ptoa(uvmexp.free), uvmexp.free);
	printf("using %d buffers containing %d bytes of memory\n",
			 nbuf, bufpages * PAGE_SIZE);
d363 5
d378 48
@


1.82
log
@68040 boards would not set address error and bus error trap vectors correctly;
fix inspired by the hp300 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2004/02/19 18:46:18 miod Exp $ */
d686 3
a688 1
		howto |= RB_HALT;
@


1.81
log
@Kill <sys/clist.h> - nothing uses it since years.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2004/01/16 23:40:17 miod Exp $ */
d545 1
a545 1
				(&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
d549 1
a549 2
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
		break;
a941 3
		/* bus/addrerr vectors */
		vectab[2] = buserr60;
		vectab[3] = addrerr4060;
a942 1

@


1.80
log
@Do not switch to the fpsp exception vectors if we are not running on an
MC68040 CPU. And suddenly MC68060 feels so happier...

MVME177 now passes all libm and libc/ieeefp regress (and probably the
Perl testsuite, too...)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2003/12/20 00:34:32 miod Exp $ */
a73 1
#include <sys/clist.h>
@


1.79
log
@Passl -Wformat. Fix some blatant -Wuninitialized errors as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2003/11/06 21:09:35 mickey Exp $ */
a542 1
	case MMU_68060:
d548 2
@


1.78
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2003/06/02 23:27:51 millert Exp $ */
d399 1
a399 1
	printf("avail mem = %ld (%ld pages)\n", ptoa(uvmexp.free), uvmexp.free);
d509 1
a509 2
		bcopy(&brdid.suffix, suffix, sizeof brdid.suffix);
		snprintf(suffix, sizeof suffix, "MVME%x", brdid.model, suffix);
d683 1
a683 1
	register int howto;
@


1.77
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2003/06/02 05:09:14 deraadt Exp $ */
d1032 2
@


1.76
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2003/04/06 18:54:19 ho Exp $ */
d44 1
a44 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.75
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2003/01/04 17:41:17 miod Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.74
log
@memsize() serves no purpose anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2003/01/04 17:21:31 miod Exp $ */
d520 1
a520 1
		sprintf(suffix, "MVME%x", brdid.model, suffix);
d522 1
a522 1
		sprintf(speed, "%02d", cpuspeed);
d550 2
a551 2
	sprintf(cpu_model, "Motorola %s: %sMHz MC680%c0 CPU",
	    suffix, speed, mc);
d560 1
a560 1
		strcat(cpu_model, "+MMU");
d564 1
a564 1
		strcat(cpu_model, "+MMU");
d567 1
a567 1
		strcat(cpu_model, ", MC68851 MMU");
a572 1
	len = strlen(cpu_model);
d576 2
a577 2
		len += sprintf(cpu_model + len,
		    "+FPU, 8k on-chip physical I/D caches");
d582 2
a583 2
		len += sprintf(cpu_model + len,
		    "+FPU, 4k on-chip physical I/D caches");
d595 3
a597 2
			len += sprintf(cpu_model + len, ", MC6888%d FPU",
			    fputype);
d600 1
a600 1
			len += sprintf(cpu_model + len, ", unknown FPU", speed);
@


1.73
log
@When detecting the memory size on 167 and 177, probe both memory controllers
instead than only the first one.
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2002/12/17 23:11:32 millert Exp $ */
a1193 46

int
memsize()
{
	volatile unsigned int *look;
	unsigned int *max;
	extern char *end;
#define MAXPHYSMEM (unsigned long)0x10000000 	/* max physical memory */
#define PATTERN   0x5a5a5a5a
#define STRIDE    (4*1024) 	/* 4k at a time */
#define Roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
	/* 
	 * Put machine specific exception vectors in place.
	 */
	initvectors();
	/*
	 * count it up.
	 */
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
		 look = (int *)((unsigned)look + STRIDE)) {
		unsigned save;

		if (badvaddr((vaddr_t)look, 2)) {
#if defined(DEBUG)
			printf("%x\n", look);
#endif
			look = (int *)((int)look - STRIDE);
			break;
		}

		/*
		 * If we write a value, we expect to read the same value back.
		 * We'll do this twice, the 2nd time with the opposite bit
		 * pattern from the first, to make sure we check all bits.
		 */
		save = *look;
		if (*look = PATTERN, *look != PATTERN)
			break;
		if (*look = ~PATTERN, *look != ~PATTERN)
			break;
		*look = save;
	}
	physmem = btoc(trunc_page((unsigned)look)); /* in pages */
	return (trunc_page((unsigned)look));
}
@


1.72
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2002/04/28 14:47:53 miod Exp $ */
d199 1
a199 1
int memsize1x7(void);
a1191 19
}
#endif

#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined(MVME172)
#include <mvme68k/dev/memcreg.h>
/*
 * XXX
 * finish writing this
 * 1) it is ugly
 * 2) it only looks at the first MEMC040/MCECC controller
 */
int
memsize1x7()
{
	struct memcreg *memc = (struct memcreg *)0xfff43000;
	u_long   x;

	x = MEMC_MEMCONF_RTOB(memc->memc_memconf);
	return (x);
@


1.71
log
@A few more tweaks to let non-GENERIC kernels (MVMEfoo) build as well with -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2002/04/27 23:21:06 miod Exp $ */
a101 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a310 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.70
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2002/04/18 21:39:51 miod Exp $ */
d513 1
d515 1
d952 1
a952 1
#if defined(M68060) || defined(M68040)
a954 1
#endif
a955 1
#ifdef M68060
a964 8
#endif

#ifdef M68040
	extern trapfun buserr40;
#endif

#ifdef FPU_EMULATE
	extern trapfun fpemuli;
@


1.69
log
@Use FPU_FOO constants everywhere, and do not print the 68060 as having both
a built-in and an unknown FPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2002/03/23 13:28:34 espie Exp $ */
d109 2
d112 1
a112 1
#include <machine/autoconf.h>
a113 1
#include <machine/reg.h>
d116 4
a119 1
#include <machine/kcore.h>
d121 1
d124 5
d195 12
d240 1
d249 1
d507 1
d510 1
a510 1
	char *t, mc;
d628 1
d720 1
a720 1
		savectx(curproc->p_addr);
d1012 1
d1025 1
a1025 1
	register void *addr;
d1036 1
a1036 1
	x = badvaddr(v + off, size);
d1043 1
a1043 1
	register caddr_t addr;
d1046 1
a1046 1
	register int i;
a1048 3
#ifdef lint
	i = *addr; if (i)	return (0);
#endif
d1070 2
a1071 1
netintr()
d1088 1
d1090 1
a1090 1
struct frame *frame;
a1113 1
	struct exec *execp = epp->ep_hdr;
d1117 1
a1117 1
		extern sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
d1174 1
a1174 1
	m68881_restore(fpframe);
d1241 1
a1241 1
memsize(void)
d1262 1
a1262 1
		if (badvaddr((caddr_t)look, 2)) {
@


1.68
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2002/03/14 20:31:31 mickey Exp $ */
d485 1
a485 1
	char *t, *mc;
d494 11
a504 11
		case MMU_68060:
			mc = "60";
			break;
		case MMU_68040:
			mc = "40";
			break;
		case MMU_68030:
			mc = "30";
			break;
		default:
			mc = "20";
d506 1
d541 2
a542 2
	sprintf(cpu_model, "Motorola %s: %sMHz MC680%s CPU",
			  suffix, speed, mc);
d544 1
d553 1
d561 2
a562 2
		printf("%s\nunknown MMU type %d\n", cpu_model, mmutype);
		panic("startup");
d565 3
a567 1
	if (mmutype == MMU_68060)
d569 5
a573 2
							"+FPU, 8k on-chip physical I/D caches");
	if (mmutype == MMU_68040)
d575 3
a577 1
							"+FPU, 4k on-chip physical I/D caches");
d579 2
a580 2
	else {
		int fpu = fpu_gettype();
d582 2
a583 2
		switch (fpu) {
		case 0:
d585 4
a588 3
		case 1:
		case 2:
			len += sprintf(cpu_model + len, ", MC6888%d FPU", fpu);
d590 1
a590 1
		case 3:
d594 2
a596 1
#endif
d950 1
a950 1
	if (cputyp == CPU_177 || cputyp == CPU_172) {
d1152 1
a1152 1
		return (1);	/* The size of a 68881 IDLE frame is 0x18 */
d1154 2
a1155 2
		return (2);	/* 68882 frame is 0x38 bytes long */
	return (3);		/* unknown FPU type */
@


1.67
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2002/03/14 03:15:56 millert Exp $ */
d294 3
@


1.66
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2002/03/14 01:26:38 millert Exp $ */
a473 1
extern   char version[];
@


1.65
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2002/01/23 17:51:52 art Exp $ */
d1218 3
a1220 3
	max = (void*)MAXPHYSMEM;
	for (look = (void*)Roundup(end, STRIDE); look < max;
		 look = (int*)((unsigned)look + STRIDE)) {
@


1.64
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2002/01/23 17:35:56 art Exp $ */
d165 5
a169 5
void bootcnprobe __P((struct consdev *));
void bootcninit __P((struct consdev *));
void bootcnputc __P((dev_t, int));
int  bootcngetc __P((dev_t));
extern void nullcnpollc __P((dev_t, int));
d625 1
a625 1
	void (*fn) __P((void));
d790 1
a790 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d907 1
a907 1
	typedef void trapfun __P((void));
d1078 1
a1078 2
		extern sunos_exec_aout_makecmds
		__P((struct proc *, struct exec_package *));
@


1.63
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2002/01/16 20:50:17 miod Exp $ */
a396 2
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.62
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2001/12/08 02:24:06 art Exp $ */
a126 1
struct vm_map *mb_map = NULL;
@


1.61
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2001/11/30 02:12:09 art Exp $ */
a78 1
#include <sys/map.h>
@


1.61.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2002/01/23 17:51:52 art Exp $ */
d79 1
d128 1
d399 2
@


1.61.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61.2.1 2002/01/31 22:55:15 niklas Exp $ */
d109 1
a110 3
#include <machine/bugio.h>
#include <machine/cpu.h>
#include <machine/kcore.h>
d112 1
d115 1
a115 4
#include <machine/reg.h>

#include <mvme68k/dev/pccreg.h>
 
a116 1

a118 5
#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#endif

d165 5
a169 5
void bootcnprobe(struct consdev *);
void bootcninit(struct consdev *);
void bootcnputc(dev_t, int);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);
a184 12
void mvme68k_init(void);
void identifycpu(void);
int cpu_sysctl(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
void halt_establish(void (*)(void), int);
void dumpconf(void);
void straytrap(int, u_short);
void netintr(void *);
void myetheraddr(u_char *);
int fpu_gettype(void);
int memsize162(void);
int memsize1x7(void);
int memsize(void);
a217 1
	extern void db_machine_init(void);
a225 1

a293 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d474 1
a480 1
void
d483 1
a483 1
	char mc;
a485 1
#ifdef FPSP
a486 1
#endif
d492 11
a502 11
	case MMU_68060:
		mc = '6';
		break;
	case MMU_68040:
		mc = '4';
		break;
	case MMU_68030:
		mc = '3';
		break;
	default:
		mc = '2';
a503 1

d538 2
a539 2
	sprintf(cpu_model, "Motorola %s: %sMHz MC680%c0 CPU",
	    suffix, speed, mc);
a540 1
#if defined(M68060) || defined(M68040)
a548 1
#endif
d556 2
a557 2
		printf("%s\n", cpu_model);
		panic("unknown MMU type %d", mmutype);
d560 1
a560 3
	switch (mmutype) {
#if defined(M68060)
	case MMU_68060:
d562 2
a563 5
		    "+FPU, 8k on-chip physical I/D caches");
		break;
#endif
#if defined(M68040)
	case MMU_68040:
d565 1
a565 3
		    "+FPU, 4k on-chip physical I/D caches");
		break;
#endif
d567 2
a568 2
	default:
		fputype = fpu_gettype();
d570 2
a571 2
		switch (fputype) {
		case FPU_NONE:
d573 3
a575 4
		case FPU_68881:
		case FPU_68882:
			len += sprintf(cpu_model + len, ", MC6888%d FPU",
			    fputype);
d577 1
a577 1
		default:
d581 1
a581 1
		break;
a582 1
	}
a588 1
int
d625 1
a625 1
	void (*fn)(void);
d680 1
a680 1
		savectx(&curproc->p_addr->u_pcb);
d790 1
a790 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d907 1
a907 1
	typedef void trapfun(void);
d910 1
a910 1
#if defined(M68060)
d913 1
d915 1
d927 8
d936 1
a936 1
	if (cputype == CPU_68060) {
a971 1
void
d984 1
a984 1
	paddr_t addr;
d995 1
a995 1
	x = badvaddr((vaddr_t)v + off, size);
d1002 1
a1002 1
	vaddr_t addr;
d1005 1
a1005 1
	int i;
d1008 3
d1032 1
a1032 2
netintr(arg)
	void *arg;
a1048 1
void
d1050 1
a1050 1
	void *frame;
d1074 1
d1078 2
a1079 1
		extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
d1136 1
a1136 1
	m68881_restore((struct fpframe *)fpframe);
d1139 1
a1139 1
		return (FPU_68881);	/* The size of a 68881 IDLE frame is 0x18 */
d1141 2
a1142 2
		return (FPU_68882);	/* 68882 frame is 0x38 bytes long */
	return (FPU_UNKNOWN);		/* unknown FPU type */
d1203 1
a1203 1
memsize()
d1219 3
a1221 3
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
		 look = (int *)((unsigned)look + STRIDE)) {
d1224 1
a1224 1
		if (badvaddr((vaddr_t)look, 2)) {
@


1.61.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d102 6
d205 1
a205 1
int memsize1x7(void);	/* in locore */
d317 12
d538 1
a538 1
		snprintf(suffix, sizeof suffix, "MVME%x", brdid.model, suffix);
d540 1
a540 1
		snprintf(speed, sizeof speed, "%02d", cpuspeed);
d568 2
a569 2
	snprintf(cpu_model, sizeof cpu_model,
	    "Motorola %s: %sMHz MC680%c0 CPU", suffix, speed, mc);
d578 1
a578 1
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
d582 1
a582 1
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
d585 1
a585 1
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
d591 1
d595 2
a596 2
		strlcat(cpu_model,"+FPU, 8k on-chip physical I/D caches",
		    sizeof cpu_model);
d601 2
a602 2
		strlcat(cpu_model, "+FPU, 4k on-chip physical I/D caches",
		    sizeof cpu_model);
d614 2
a615 3
			len = strlen (cpu_model);
			snprintf(cpu_model + len, sizeof cpu_model - len,
			    ", MC6888%d FPU", fputype);
d618 1
a618 1
			strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
d1212 65
@


1.60
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2001/11/28 16:13:28 art Exp $ */
d262 1
d384 1
d861 4
a865 1
		error = (*dump)(dumpdev, blkno, vmmap, PAGE_SIZE);
@


1.59
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2001/11/28 13:57:18 art Exp $ */
d377 1
a377 1
			pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
@


1.58
log
@pmap_kenter_pgs(.., 1) is pointless. pmap_kenter_pa instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2001/11/28 13:47:38 art Exp $ */
d127 3
a129 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.57
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2001/11/24 17:53:41 miod Exp $ */
d376 3
a378 1
			pmap_kenter_pgs(curbuf, &pg, 1);
@


1.56
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2001/11/07 01:18:00 art Exp $ */
d346 1
a346 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.55
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2001/09/29 21:28:02 miod Exp $ */
d668 1
a668 1
void
d672 5
d683 1
a683 1
	if ((howto&RB_NOSYNC) == 0 && waittime < 0) {
d709 1
d713 1
a713 1
	if (howto&RB_HALT) {
@


1.54
log
@Use more PMAP_NEW facilities.
Remove obsolete&unused stuff.
A few style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2001/09/19 20:50:56 mickey Exp $ */
d344 1
a344 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.53
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2001/09/12 00:23:33 art Exp $ */
a153 1
extern   u_int lowram;
d260 2
a261 3
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
a342 1

d356 1
d381 1
d388 1
d390 1
a390 1
	 * Allocate a submap for physio
a402 19
#ifdef MFS
	/*
	 * Check to see if a mini-root was loaded into memory. It resides
	 * at the start of the next page just after the end of BSS.
	 */
	{
		extern void *smini;

		if (smini && (boothowto & RB_MINIROOT)) {
			boothowto |= RB_DFLTROOT;
			mfs_initminiroot(smini);
		}
	}
#endif

	/*
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();
d426 4
a429 4
register struct proc *p;
struct exec_package *pack;
u_long stack;
register_t *retval;
a894 4
initcpu()
{
}

d1082 1
a1082 1
u_char *ether;
a1192 2
int foodebug = 0;

a1214 2
		/* if can't access, we've reached the end */
		if (foodebug) printf("%x\n", look);
d1246 1
a1246 1
struct consdev *cp;
a1249 1
	return;
d1254 1
a1254 1
struct consdev *cp;
d1261 1
a1261 1
dev_t dev;
d1268 2
a1269 2
dev_t dev;
int c;
a1270 1
	int s;
@


1.52
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2001/08/25 11:37:26 espie Exp $ */
a120 1
#include <vm/vm_kern.h>
@


1.51
log
@One regdump to dump them all...

(moid@@ wants that commit, because it interferes with stuff he's cleaning,
and he's prepared to clean up stuff I may have forgotten, even though this
was tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2001/08/23 14:01:03 art Exp $ */
d396 1
a396 1
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
@


1.50
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2001/08/23 12:02:04 art Exp $ */
a1073 91
}

regdump(fp, sbytes)
struct frame *fp;	/* must not be register */
int sbytes;
{
	static int doingdump = 0;
	register int i;
	int s;
	extern char *hexstr();

	if (doingdump)
		return;
	s = splhigh();
	doingdump = 1;
	printf("pid = %d, pc = %s, ",
			 curproc ? curproc->p_pid : -1, hexstr(fp->f_pc, 8));
	printf("ps = %s, ", hexstr(fp->f_sr, 4));
	printf("sfc = %s, ", hexstr(getsfc(), 4));
	printf("dfc = %s\n", hexstr(getdfc(), 4));
	printf("Registers:\n     ");
	for (i = 0; i < 8; i++)
		printf("        %d", i);
	printf("\ndreg:");
	for (i = 0; i < 8; i++)
		printf(" %s", hexstr(fp->f_regs[i], 8));
	printf("\nareg:");
	for (i = 0; i < 8; i++)
		printf(" %s", hexstr(fp->f_regs[i+8], 8));
	if (sbytes > 0) {
		if (fp->f_sr & PSL_S) {
			printf("\n\nKernel stack (%s):",
					 hexstr((int)(((int *)&fp)-1), 8));
			dumpmem(((int *)&fp)-1, sbytes, 0);
		} else {
			printf("\n\nUser stack (%s):", hexstr(fp->f_regs[SP], 8));
			dumpmem((int *)fp->f_regs[SP], sbytes, 1);
		}
	}
	doingdump = 0;
	splx(s);
}

#define KSADDR	((int *)((u_int)curproc->p_addr + USPACE - NBPG))

dumpmem(ptr, sz, ustack)
register int *ptr;
int sz, ustack;
{
	register int i, val;
	extern char *hexstr();

	for (i = 0; i < sz; i++) {
		if ((i & 7) == 0)
			printf("\n%s: ", hexstr((int)ptr, 6));
		else
			printf(" ");
		if (ustack == 1) {
			if ((val = fuword(ptr++)) == -1)
				break;
		} else {
			if (ustack == 0 &&
				 (ptr < KSADDR || ptr > KSADDR+(NBPG/4-1)))
				break;
			val = *ptr++;
		}
		printf("%s", hexstr(val, 8));
	}
	printf("\n");
}

char *
hexstr(val, len)
register int val;
int len;
{
	static char nbuf[9];
	register int x, i;

	if (len > 8)
		return ("");
	nbuf[len] = '\0';
	for (i = len-1; i >= 0; --i) {
		x = val & 0xF;
		if (x > 9)
			nbuf[i] = x - 10 + 'A';
		else
			nbuf[i] = x + '0';
		val >>= 4;
	}
	return (nbuf);
@


1.49
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2001/08/12 23:18:37 miod Exp $ */
a397 5
	/*
	 * Initialize timeouts
	 */
	timeout_init();

@


1.48
log
@Oh, and STACKCHECK also is a 4.4BSDism.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2001/08/12 22:59:37 miod Exp $ */
a296 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.47
log
@BUFFERS_UNMANAGED est une grosse fumisterie.
[BUFFERS_UNMANAGED is a big hoax]
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2001/08/06 20:46:33 miod Exp $ */
a1171 18

#ifdef STACKCHECK
char oflowmsg[] = "k-stack overflow";
char uflowmsg[] = "k-stack underflow";

badkstack(oflow, fr)
int oflow;
struct frame fr;
{
	extern char kstackatbase[];

	printf("%s: sp should be %x\n", 
			 oflow ? oflowmsg : uflowmsg,
			 kstackatbase - (exframesize[fr.f_format] + 8));
	regdump(&fr, 0);
	panic(oflow ? oflowmsg : uflowmsg);
}
#endif
@


1.46
log
@Working kernel crash dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2001/08/05 20:35:43 miod Exp $ */
a249 5
#ifdef BUFFERS_UNMANAGED
	vm_offset_t bufmemp;
	caddr_t buffermem;
	int ix;
#endif
a334 5
#ifdef BUFFERS_UNMANAGED
		buffermem = (caddr_t) uvm_km_zalloc(kernel_map, bufpages*PAGE_SIZE);
		if (buffermem == 0)
			panic("startup: no room for buffers");
#endif
@


1.45
log
@Use syntaxic sugar provided by PMAP_NEW
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2001/07/25 13:25:32 art Exp $ */
d95 2
d116 1
d187 1
d762 1
d766 1
a766 1
 * Dumps always skip the first block of disk space
d788 8
a795 4
	/*
	 * XXX include the final RAM page which is not included in physmem.
	 */
	dumpsize = physmem + 1;
d802 4
a805 4
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
d813 1
d816 12
d831 2
d840 26
a865 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d868 36
a903 5
	switch ((*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {
		
		case ENXIO:
			printf("device bad\n");
			break;
d905 3
a907 3
		case EFAULT:
			printf("device not ready\n");
			break;
d909 3
a911 3
		case EINVAL:
			printf("area improper\n");
			break;
d913 3
a915 3
		case EIO:
			printf("i/o error\n");
			break;
d917 3
a919 3
		case EINTR:
			printf("aborted from console\n");
			break;
d921 3
a923 3
		default:
			printf("succeeded\n");
			break;
@


1.44
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2001/07/05 10:12:13 art Exp $ */
d386 1
a386 3
			pmap_enter(kernel_map->pmap, curbuf,
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL,
				   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.43
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2001/06/27 06:19:48 art Exp $ */
d265 1
a265 1
		    TRUE, VM_PROT_READ|VM_PROT_WRITE);
d387 2
a388 2
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
				   VM_PROT_READ|VM_PROT_WRITE);
@


1.42
log
@MNN is no longer an option.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2001/06/27 04:19:17 art Exp $ */
a297 3
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
@


1.41
log
@zap old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2001/06/26 21:35:41 miod Exp $ */
a188 1
#if defined(MACHINE_NEW_NONCONTIG)
a199 1
#endif /* MACHINE_NEW_NONCONTIG */
@


1.40
log
@A few changes to mvme68k:
+ switch to UVM
+ fix the system trace problem
+ big cleanup of locore.s (macro for BUG calls, use more common m68k
  code whenever possible, and the macros in <m68k/asm.h>)
+ better indentation on some parts (old KNF)
+ call doshutdownhooks() at shutdown
+ use <net/netisr_dispatch.h>
+ upgrade pmap.c to something very close to our current hp300 pmap.c,
  minus support for PMAP_NEW and for HP MMU
+ various tidbits I forget to mention here

work and tests by smurph@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2001/05/17 18:41:49 provos Exp $ */
a119 1
#if defined(UVM)
a120 1
#endif
a124 1
#if defined(UVM)
a127 3
#else
vm_map_t buffer_map;
#endif
a133 3
#if !defined(UVM)
int   nswbuf = 0;
#endif
a196 1
#if defined(UVM)
a200 4
#else
	vm_page_physload(atop(avail_start), atop(avail_end),
			 atop(avail_start), atop(avail_end));
#endif /* UVM */
a245 1
#if defined(UVM)
a246 3
#else
	vm_offset_t minaddr, maxaddr;
#endif 
a331 8
#if !defined(UVM)
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
	valloc(swbuf, struct buf, nswbuf);
#endif
a337 1
#if defined(UVM)
a338 3
#else
		firstaddr = (caddr_t) kmem_alloc(kernel_map, round_page(size));
#endif
a341 1
#if defined(UVM)
a342 3
#else
		buffermem = (caddr_t) kmem_alloc(kernel_map, bufpages*PAGE_SIZE);
#endif
a358 1
#if defined(UVM)
a364 8
#else
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
	    (vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif
a372 1
#if defined(UVM)
a396 17
#else
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base+1 : base);
		/* this faults in the required physical pages */
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif 
a401 1
#if defined(UVM)
a403 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
#endif
a406 1
#if defined(UVM)
a408 4
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 
				 VM_PHYS_SIZE, TRUE);
#endif
a409 1
#if defined(UVM)
a411 4
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
#endif
a419 1
#if defined(UVM)
a420 4
#else
	printf("avail mem = %ld (%ld pages)\n", ptoa(cnt.v_free_count),
	    ptoa(cnt.v_free_count)/NBPG);
#endif
@


1.39
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2001/05/05 22:33:58 art Exp $ */
d120 4
d127 5
d133 2
d140 1
d142 1
d203 1
a203 1
	 * hp300 only has one segment.
d205 1
d207 2
d210 1
a210 1
							atop(avail_start), atop(avail_end));
d213 1
a213 1
						  atop(avail_start), atop(avail_end));
d259 4
d264 1
d311 1
a311 1
	again:
d350 1
d357 1
d364 3
d368 1
d372 3
d376 1
d392 9
d402 1
a402 1
										&maxaddr, size, TRUE);
d405 1
a405 1
						 &minaddr, size, FALSE) != KERN_SUCCESS)
d407 6
d416 26
d454 1
d457 1
d463 4
d468 2
a469 1
									 16*NCARGS, TRUE);
d473 7
a479 2
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
									 VM_PHYS_SIZE, TRUE);
d481 4
d486 2
a487 1
								  VM_MBUF_SIZE, FALSE);
d496 6
a501 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
d626 6
a631 6
		case CPU_147:
			bcopy(&brdid.suffix, suffix, sizeof brdid.suffix);
			sprintf(suffix, "MVME%x", brdid.model, suffix);
			cpuspeed = pccspeed((struct pccreg *)IIOV(0xfffe1000));
			sprintf(speed, "%02d", cpuspeed);
			break;
d634 22
a655 22
		case CPU_162:
		case CPU_167:
		case CPU_172:
		case CPU_177:
			bzero(speed, sizeof speed);
			speed[0] = brdid.speed[0];
			speed[1] = brdid.speed[1];
			if (brdid.speed[2] != '0' &&
				 brdid.speed[3] != '0') {
				speed[2] = '.';
				speed[3] = brdid.speed[2];
				speed[4] = brdid.speed[3];
			}
			cpuspeed = (speed[0] - '0') * 10 + (speed[1] - '0');
			bcopy(brdid.longname, suffix, sizeof(brdid.longname));
			for (len = strlen(suffix)-1; len; len--) {
				if (suffix[len] == ' ')
					suffix[len] = '\0';
				else
					break;
			}
			break;
d661 2
a662 2
		case MMU_68060:
		case MMU_68040:
d664 2
a665 2
			bcopy(&fpsp_tab, &fpvect_tab,
					(&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
d667 11
a677 11
			strcat(cpu_model, "+MMU");
			break;
		case MMU_68030:
			strcat(cpu_model, "+MMU");
			break;
		case MMU_68851:
			strcat(cpu_model, ", MC68851 MMU");
			break;
		default:
			printf("%s\nunknown MMU type %d\n", cpu_model, mmutype);
			panic("startup");
d691 9
a699 9
			case 0:
				break;
			case 1:
			case 2:
				len += sprintf(cpu_model + len, ", MC6888%d FPU", fpu);
				break;
			case 3:
				len += sprintf(cpu_model + len, ", unknown FPU", speed);
				break;
d710 7
a716 7
int *name;
u_int namelen;
void *oldp;
size_t *oldlenp;
void *newp;
size_t newlen;
struct proc *p;
d725 9
a733 9
		case CPU_CONSDEV:
			if (cn_tab != NULL)
				consdev = cn_tab->cn_dev;
			else
				consdev = NODEV;
			return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
											sizeof consdev));
		default:
			return (EOPNOTSUPP);
d745 2
a746 2
void (*fn) __P((void));
int pri;
d790 1
a790 1
register int howto;
d816 11
a826 1
	splhigh();			/* extreme priority */
a831 2
		if (howto & RB_DUMP)
			dumpsys();
d836 1
a836 2
	while (1)
		;
d1012 2
a1013 2
int pc;
u_short evec;
d1023 2
a1024 2
register void *addr;
int size;
d1041 2
a1042 2
register caddr_t addr;
int size;
d1070 1
d1073 9
a1081 47
#ifdef INET
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
#endif
#ifdef INET6
	if (netisr & (1 << NETISR_IPV6)) {
		netisr &= ~(1 << NETISR_IPV6);
		ip6intr();
	}
#endif
#ifdef NETATALK
	if (netisr & (1 << NETISR_ATALK)) {
		netisr &= ~(1 << NETISR_ATALK);
		atintr();
	}
#endif
#ifdef NS
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
#endif
#ifdef ISO
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
#endif
#ifdef CCITT
	if (netisr & (1 << NETISR_CCITT)) {
		netisr &= ~(1 << NETISR_CCITT);
		ccittintr();
	}
#endif
#include "ppp.h"
#if NPPP > 0
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
#endif
d1216 1
d1218 2
a1219 2
struct proc *p;
struct exec_package *epp;
@


1.38
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2001/05/05 20:56:45 art Exp $ */
a396 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.37
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2001/04/17 04:30:46 aaron Exp $ */
a451 1
	configure();
@


1.36
log
@Implement cnbell(), an optional entrypoint that rings the console bell; from
NetBSD. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2001/04/05 20:39:39 deraadt Exp $ */
d117 1
a117 1
#define	MAXMEM	64*1024*CLSIZE	/* XXX - from cmap.h */
d323 1
a323 1
		bufpages = physmem / 20 / CLSIZE;
d345 1
a345 1
		buffermem = (caddr_t) kmem_alloc(kernel_map, bufpages*CLBYTES);
d381 1
a381 1
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
d401 3
a403 3
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
										M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d416 1
a416 1
			 nbuf, bufpages * CLBYTES);
d756 1
a756 1
 * Dumps always skip the first CLBYTES of disk space
d783 1
a783 1
	/* Always skip the first CLBYTES, in case there is a label there. */
@


1.35
log
@undo changes which did not even compile
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2000/03/23 09:59:55 art Exp $ */
d176 1
@


1.34
log
@Initial code for UVM.  not tested yet...
@
text
@a119 4
#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif

a122 5
#if defined(UVM)
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
#else
a123 2
#endif

a190 1

a191 2
	uvmexp.pagesize = NBPG;
	uvm_setpagesize();
d193 1
a193 1
			  atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
d196 1
a196 1
			 atop(avail_start), atop(avail_end));
a241 4
	
#if defined(UVM)
	vaddr_t minaddr, maxaddr;
#else
a242 1
#endif 
a332 1
#if !defined(UVM)
a333 1
#endif
a339 3
#if defined(UVM)
		firstaddr = (caddr_t) uvm_km_zalloc(kernel_map, round_page(size));
#else
a340 1
#endif
a343 3
#if defined(UVM)
		buffermem = (caddr_t) uvm_km_zalloc(kernel_map, bufpages*CLBYTES);
#else
a344 1
#endif
a359 9

#if defined(UVM)
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, m88k_round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("cpu_startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;
#else
d361 1
a361 1
				   &maxaddr, size, TRUE);
d364 1
a364 1
	    (vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS)
a365 6
#endif
	
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
d368 1
a368 26
#if defined(UVM)
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = CLBYTES * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");
			pmap_enter(kernel_map->pmap, curbuf,
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
				   VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
#else
a380 1
		/* this faults in the required physical pages */
a382 1
#endif 
a387 4
#if defined(UVM)
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
#else
d389 1
a389 2
				 16*NCARGS, TRUE);
#endif
d393 2
a394 7
#if defined(UVM)
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 
				 VM_PHYS_SIZE, TRUE);
#endif
a402 4
#if defined(UVM)
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
#else
d404 1
a404 2
			       VM_MBUF_SIZE, FALSE);
#endif
d413 1
a413 6
#if defined(UVM)
	printf("avail mem = %ld (%ld pages)\n", ptoa(uvmexp.free), uvmexp.free);
#else
	printf("avail mem = %ld (%ld pages)\n", ptoa(cnt.v_free_count),
	    ptoa(cnt.v_free_count)/NBPG);
#endif
@


1.33
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2000/02/22 19:27:54 deraadt Exp $ */
d120 4
d127 5
d133 2
d202 1
d204 2
d207 1
a207 1
							atop(avail_start), atop(avail_end));
d210 1
a210 1
						  atop(avail_start), atop(avail_end));
d256 4
d261 1
d352 1
d354 1
d361 3
d365 1
d369 3
d373 1
d389 9
d399 1
a399 1
										&maxaddr, size, TRUE);
d402 1
a402 1
						 &minaddr, size, FALSE) != KERN_SUCCESS)
d404 6
d412 26
a437 1
	for (i = 0; i < nbuf; i++) {
d450 1
d453 1
d459 4
d464 2
a465 1
									 16*NCARGS, TRUE);
d469 7
a475 2
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
									 VM_PHYS_SIZE, TRUE);
d484 4
d489 2
a490 1
								  VM_MBUF_SIZE, FALSE);
d499 6
a504 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
@


1.32
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2000/01/06 03:21:43 smurph Exp $ */
d86 1
a86 1
#include <sys/callout.h>
d299 1
a299 1
	valloc(callout, struct callout, ncallout);
d406 1
a406 1
	 * Initialize callouts
d408 1
a408 4
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;
@


1.31
log
@Added support for MVME177 (mc68060)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 1999/12/08 06:50:16 itojun Exp $ */
a139 1
int   msgbufmapped;		/* set when safe to use msgbuf */
d260 1
a260 1
	for (i = 0; i < btoc(sizeof (struct msgbuf)); i++)
d262 3
a264 4
					  avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
					  TRUE, VM_PROT_READ|VM_PROT_WRITE);

	msgbufmapped = 1;
d803 1
@


1.31.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d140 1
d261 1
a261 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d263 4
a266 3
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
		    TRUE, VM_PROT_READ|VM_PROT_WRITE);
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
a804 1
	extern int msgbufmapped;
@


1.31.2.2
log
@Sync with -current
@
text
@d86 1
a86 1
#include <sys/timeout.h>
d299 1
a299 1
	valloc(timeouts, struct timeout, ntimeout);
d406 1
a406 1
	 * Initialize timeouts
d408 4
a411 1
	timeout_init();
@


1.31.2.3
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2001/04/17 04:30:46 aaron Exp $ */
a175 1
	NULL,
@


1.31.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31.2.3 2001/04/18 16:10:39 niklas Exp $ */
d117 1
a117 1
#define	MAXMEM	64*1024	/* XXX - from cmap.h */
a119 2
#include <uvm/uvm_extern.h>

d123 1
a123 4
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;

d129 1
d185 1
d190 1
a190 1
	 * mvme68k only has one segment.
d192 1
a192 3

	uvmexp.pagesize = NBPG;
	uvm_setpagesize();
d194 6
a199 1
			  atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
d243 1
a243 2
	
	vaddr_t minaddr, maxaddr;
d290 1
a290 1
again:
d323 1
a323 1
		bufpages = physmem / 20;
d329 6
d341 1
a341 1
		firstaddr = (caddr_t) uvm_km_zalloc(kernel_map, round_page(size));
d345 1
a345 1
		buffermem = (caddr_t) uvm_km_zalloc(kernel_map, bufpages*PAGE_SIZE);
d361 6
a366 12

	if (uvm_map(kernel_map, (vaddr_t *) &buffers, m68k_round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("cpu_startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;
	
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
d370 2
a371 3
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;
d374 5
a378 4
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
d380 4
a383 14
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");
			pmap_enter(kernel_map->pmap, curbuf,
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
				   VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
d389 2
a390 2
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d394 2
a395 2
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);
d397 9
a405 2
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
d414 1
a414 1
	printf("avail mem = %ld (%ld pages)\n", ptoa(uvmexp.free), uvmexp.free);
d416 1
a416 1
			 nbuf, bufpages * PAGE_SIZE);
d452 1
d540 6
a545 6
	case CPU_147:
		bcopy(&brdid.suffix, suffix, sizeof brdid.suffix);
		sprintf(suffix, "MVME%x", brdid.model, suffix);
		cpuspeed = pccspeed((struct pccreg *)IIOV(0xfffe1000));
		sprintf(speed, "%02d", cpuspeed);
		break;
d548 22
a569 22
	case CPU_162:
	case CPU_167:
	case CPU_172:
	case CPU_177:
		bzero(speed, sizeof speed);
		speed[0] = brdid.speed[0];
		speed[1] = brdid.speed[1];
		if (brdid.speed[2] != '0' &&
			 brdid.speed[3] != '0') {
			speed[2] = '.';
			speed[3] = brdid.speed[2];
			speed[4] = brdid.speed[3];
		}
		cpuspeed = (speed[0] - '0') * 10 + (speed[1] - '0');
		bcopy(brdid.longname, suffix, sizeof(brdid.longname));
		for (len = strlen(suffix)-1; len; len--) {
			if (suffix[len] == ' ')
				suffix[len] = '\0';
			else
				break;
		}
		break;
d575 2
a576 2
	case MMU_68060:
	case MMU_68040:
d578 2
a579 2
		bcopy(&fpsp_tab, &fpvect_tab,
				(&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
d581 11
a591 11
		strcat(cpu_model, "+MMU");
		break;
	case MMU_68030:
		strcat(cpu_model, "+MMU");
		break;
	case MMU_68851:
		strcat(cpu_model, ", MC68851 MMU");
		break;
	default:
		printf("%s\nunknown MMU type %d\n", cpu_model, mmutype);
		panic("startup");
d605 9
a613 9
		case 0:
			break;
		case 1:
		case 2:
			len += sprintf(cpu_model + len, ", MC6888%d FPU", fpu);
			break;
		case 3:
			len += sprintf(cpu_model + len, ", unknown FPU", speed);
			break;
d624 7
a630 7
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d639 9
a647 9
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	default:
		return (EOPNOTSUPP);
d659 2
a660 2
	void (*fn) __P((void));
	int pri;
d704 1
a704 1
	register int howto;
d730 1
a730 11

	/* Disable interrupts. */
	splhigh();

	/* If rebooting and a dump is requested, do it. */
	if (howto & RB_DUMP)
		dumpsys();

	/* Run any shutdown hooks. */
	doshutdownhooks();

d736 2
d742 2
a743 1
	for (;;);
d756 1
a756 1
 * Dumps always skip the first block of disk space
d783 1
a783 1
	/* Always skip the first block, in case there is a label there. */
d919 2
a920 2
	int pc;
	u_short evec;
d930 2
a931 2
	register void *addr;
	int size;
d948 2
a949 2
	register caddr_t addr;
	int size;
a976 1
void
d979 47
a1025 9
#define DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << (bit))) { \
			netisr &= ~(1 << (bit)); \
			(fn)(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef DONETISR
a1159 1
int
d1161 2
a1162 2
	struct proc *p;
	struct exec_package *epp;
@


1.31.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31.2.4 2001/07/04 10:19:39 niklas Exp $ */
a94 2
#include <sys/core.h>
#include <sys/kcore.h>
a113 1
#include <machine/kcore.h>
d118 1
d152 1
a183 1
void dumpsys(void);
d246 5
d263 3
a265 2
		pmap_kenter_pa((vm_offset_t)msgbufp,
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE);
d298 4
d339 5
d356 1
a369 1

d389 3
a391 1
			pmap_kenter_pgs(curbuf, &pg, 1);
a395 1

a401 1

d403 1
a403 1
	 * Allocate a submap for physio.
d408 1
a408 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
d410 5
d421 19
d463 4
a466 4
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
a762 1
cpu_kcore_hdr_t cpu_kcore_hdr;
d766 1
a766 1
 * Dumps always skip the first PAGE_SIZE of disk space
d788 4
a791 8
	dumpsize = physmem;

	/* mvme68k only uses a single segment. */
	cpu_kcore_hdr.ram_segs[0].start = 0;
	cpu_kcore_hdr.ram_segs[0].size = ctob(physmem);
	cpu_kcore_hdr.mmutype = mmutype;
	cpu_kcore_hdr.kernel_pa = 0;
	cpu_kcore_hdr.sysseg_pa = pmap_kernel()->pm_stpa;
d798 4
a801 4
	if (dumpsize + 1 > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo) - 1;
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
a808 1
void
a810 12
	int maj;
	int psize;
	daddr_t blkno;			/* current block to write */
					/* dump routine */
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
	int pg;				/* page being dumped */
	paddr_t maddr;			/* PA being dumped */
	int error;			/* error code from (*dump)() */
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */

a813 2

	/* Make sure dump device is valid. */
d821 1
a821 26
	maj = major(dumpdev);
	if (dumplo < 0) {
		printf("\ndump to dev %u,%u not possible\n", maj,
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[maj].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", maj,
	    minor(dumpdev), dumplo);

	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	/*
	 * Generate a segment header
	 */
	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));

	/*
	 * Add the md header
	 */
	*chdr_p = cpu_kcore_hdr;
d824 5
a828 5
	psize = (*bdevsw[maj].d_psize)(dumpdev);
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}
d830 2
a831 19
	/* Dump the header. */
	error = (*dump) (dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	if (error != 0)
		goto abort;

	maddr = (paddr_t)0;
	for (pg = 0; pg < dumpsize; pg++) {
#define	NPGMB	(1024 * 1024 / PAGE_SIZE)
		/* print out how many MBs we have dumped */
		if (pg != 0 && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef	NPGMB
		pmap_kenter_pa((vaddr_t)vmmap, maddr, VM_PROT_READ);

		error = (*dump)(dumpdev, blkno, vmmap, PAGE_SIZE);
		if (error == 0) {
			maddr += PAGE_SIZE;
			blkno += btodb(PAGE_SIZE);
		} else
a832 6
	}
abort:
	switch (error) {
	case 0:
		printf("succeeded\n");
		break;
d834 3
a836 3
	case ENXIO:
		printf("device bad\n");
		break;
d838 3
a840 3
	case EFAULT:
		printf("device not ready\n");
		break;
d842 3
a844 3
	case EINVAL:
		printf("area improper\n");
		break;
d846 3
a848 11
	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	default:
		printf("error %d\n", error);
		break;
d856 4
d1017 109
d1156 1
a1156 1
	u_char *ether;
d1267 2
d1291 2
d1324 1
a1324 1
	struct consdev *cp;
d1328 1
d1333 1
a1333 1
	struct consdev *cp;
d1340 1
a1340 1
	dev_t dev;
d1347 2
a1348 2
	dev_t dev;
	int c;
d1350 1
@


1.31.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d344 1
a344 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
@


1.31.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31.2.6 2001/11/13 21:04:14 niklas Exp $ */
d127 3
a129 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d346 1
a346 1
				UVM_ADV_NORMAL, 0)))
d376 1
a376 3

			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
d668 1
a668 1
__dead void
a671 5
	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}
d678 1
a678 1
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
a703 1
haltsys:
d707 1
a707 1
	if (howto & RB_HALT) {
@


1.31.2.8
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d79 1
d128 1
a261 1
	pmap_update(pmap_kernel());
a382 1
	pmap_update(pmap_kernel());
d397 2
d859 1
a859 1
		pmap_update(pmap_kernel());
a860 3
		pmap_kremove((vaddr_t)vmmap, PAGE_SIZE);
		pmap_update(pmap_kernel());

@


1.31.2.9
log
@Merge in -current from about a week ago
@
text
@d165 5
a169 5
void bootcnprobe(struct consdev *);
void bootcninit(struct consdev *);
void bootcnputc(dev_t, int);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);
d474 1
d625 1
a625 1
	void (*fn)(void);
d790 1
a790 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d907 1
a907 1
	typedef void trapfun(void);
d1078 2
a1079 1
		extern sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
d1219 3
a1221 3
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
		 look = (int *)((unsigned)look + STRIDE)) {
@


1.31.2.10
log
@Sync the SMP branch with 3.3
@
text
@d102 6
d109 1
a110 3
#include <machine/bugio.h>
#include <machine/cpu.h>
#include <machine/kcore.h>
d112 1
d115 1
a115 4
#include <machine/reg.h>

#include <mvme68k/dev/pccreg.h>
 
a116 1

a118 5
#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#endif

a184 12
void mvme68k_init(void);
void identifycpu(void);
int cpu_sysctl(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
void halt_establish(void (*)(void), int);
void dumpconf(void);
void straytrap(int, u_short);
void netintr(void *);
void myetheraddr(u_char *);
int fpu_gettype(void);
int memsize162(void);
int memsize1x7(void);	/* in locore */
int memsize(void);
a217 1
	extern void db_machine_init(void);
a225 1

d293 9
a479 1
void
d482 1
a482 1
	char mc;
a484 1
#ifdef FPSP
a485 1
#endif
d491 11
a501 11
	case MMU_68060:
		mc = '6';
		break;
	case MMU_68040:
		mc = '4';
		break;
	case MMU_68030:
		mc = '3';
		break;
	default:
		mc = '2';
a502 1

d537 2
a538 2
	sprintf(cpu_model, "Motorola %s: %sMHz MC680%c0 CPU",
	    suffix, speed, mc);
a539 1
#if defined(M68060) || defined(M68040)
a547 1
#endif
d555 2
a556 2
		printf("%s\n", cpu_model);
		panic("unknown MMU type %d", mmutype);
d559 1
a559 3
	switch (mmutype) {
#if defined(M68060)
	case MMU_68060:
d561 2
a562 5
		    "+FPU, 8k on-chip physical I/D caches");
		break;
#endif
#if defined(M68040)
	case MMU_68040:
d564 1
a564 3
		    "+FPU, 4k on-chip physical I/D caches");
		break;
#endif
d566 2
a567 2
	default:
		fputype = fpu_gettype();
d569 2
a570 2
		switch (fputype) {
		case FPU_NONE:
d572 3
a574 4
		case FPU_68881:
		case FPU_68882:
			len += sprintf(cpu_model + len, ", MC6888%d FPU",
			    fputype);
d576 1
a576 1
		default:
d580 1
a580 1
		break;
a581 1
	}
a587 1
int
d679 1
a679 1
		savectx(&curproc->p_addr->u_pcb);
d909 1
a909 1
#if defined(M68060)
d912 1
d914 1
d926 8
d935 1
a935 1
	if (cputype == CPU_68060) {
a970 1
void
d983 1
a983 1
	paddr_t addr;
d994 1
a994 1
	x = badvaddr((vaddr_t)v + off, size);
d1001 1
a1001 1
	vaddr_t addr;
d1004 1
a1004 1
	int i;
d1007 3
d1031 1
a1031 2
netintr(arg)
	void *arg;
a1047 1
void
d1049 1
a1049 1
	void *frame;
d1073 1
d1077 1
a1077 1
		extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
d1134 1
a1134 1
	m68881_restore((struct fpframe *)fpframe);
d1137 1
a1137 1
		return (FPU_68881);	/* The size of a 68881 IDLE frame is 0x18 */
d1139 2
a1140 2
		return (FPU_68882);	/* 68882 frame is 0x38 bytes long */
	return (FPU_UNKNOWN);		/* unknown FPU type */
d1180 65
@


1.31.2.11
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31.2.10 2003/03/27 23:32:17 niklas Exp $ */
d520 1
a520 1
		snprintf(suffix, sizeof suffix, "MVME%x", brdid.model, suffix);
d522 1
a522 1
		snprintf(speed, sizeof speed, "%02d", cpuspeed);
d550 2
a551 2
	snprintf(cpu_model, sizeof cpu_model,
	    "Motorola %s: %sMHz MC680%c0 CPU", suffix, speed, mc);
d560 1
a560 1
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
d564 1
a564 1
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
d567 1
a567 1
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
d573 1
d577 2
a578 2
		strlcat(cpu_model,"+FPU, 8k on-chip physical I/D caches",
		    sizeof cpu_model);
d583 2
a584 2
		strlcat(cpu_model, "+FPU, 4k on-chip physical I/D caches",
		    sizeof cpu_model);
d596 2
a597 3
			len = strlen (cpu_model);
			snprintf(cpu_model + len, sizeof cpu_model - len,
			    ", MC6888%d FPU", fputype);
d600 1
a600 1
			strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
@


1.31.2.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31.2.11 2003/05/13 19:41:06 ho Exp $ */
d15 6
d50 5
a54 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.31.2.13
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d399 1
a399 1
	printf("avail mem = %ld (%d pages)\n", ptoa(uvmexp.free), uvmexp.free);
d509 2
a510 1
		snprintf(suffix, sizeof suffix, "MVME%x", brdid.model);
d544 1
a549 2
		/* FALLTHROUGH */
	case MMU_68060:
d684 1
a684 1
	int howto;
a1031 2

int netisr;
@


1.31.2.14
log
@Merge with the trunk
@
text
@d74 1
d129 1
a129 1
int	nbuf = NBUF;
d131 1
a131 1
int	nbuf = 0;
a132 5

#ifndef	BUFCACHEPERCENT
#define	BUFCACHEPERCENT	5
#endif

d134 1
a134 1
int	bufpages = BUFPAGES;
d136 1
a136 1
int	bufpages = 0;
a137 2
int	bufcachepercent = BUFCACHEPERCENT;

a190 1
caddr_t allocsys(caddr_t);
d248 2
a249 2
	unsigned i;
	caddr_t v;
d266 2
a267 2
		pmap_kenter_pa((vm_offset_t)msgbufp + i * PAGE_SIZE,
		    avail_end + i * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE);
d274 1
a274 1
	printf("%s", version);
d276 31
a306 1
	printf("real mem = %d (%dK)\n", ctob(physmem), ctob(physmem) / 1024);
d309 3
a311 2
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
d313 22
a334 4
	size = (vm_size_t)allocsys((caddr_t)0);
	if ((v = (caddr_t) uvm_km_zalloc(kernel_map, round_page(size))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != size)
a335 1

d341 1
a341 1
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
d347 1
d399 3
a407 5
	printf("avail mem = %d (%dK)\n",
	    ptoa(uvmexp.free), ptoa(uvmexp.free) / 1024);
	printf("using %d buffers containing %d bytes of memory\n",
			 nbuf, bufpages * PAGE_SIZE);

a420 48
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * You call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(caddr_t v)
{

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name) + (num))
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

	/*
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless. */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
	return (v);
}

/*
d546 1
a546 1
		    (&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
d550 2
a551 1
		/* FALLTHROUGH */
d688 1
a688 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
d944 3
d948 1
@


1.30
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 1999/09/27 20:30:32 smurph Exp $ */
d5 1
d129 1
a129 1
int	nswbuf = 0;
d131 1
a131 1
int	nbuf = NBUF;
d133 1
a133 1
int	nbuf = 0;
d136 1
a136 1
int	bufpages = BUFPAGES;
d138 1
a138 1
int	bufpages = 0;
d140 3
a142 3
int	msgbufmapped;		/* set when safe to use msgbuf */
int	maxmem;			/* max memory per process */
int	physmem = MAXMEM;	/* max supported memory, changes to actual */
d147 1
a147 1
int	safepri = PSL_LOWIPL;
d149 2
a150 2
extern	u_int lowram;
extern	short exframesize[];
d159 23
d187 1
a187 1
        
d189 3
a191 3
 	 * Tell the VM system about available physical memory.  The
 	 * hp300 only has one segment.
 	 */
d194 1
a194 1
    		atop(avail_start), atop(avail_end));
d197 1
a197 1
    		atop(avail_start), atop(avail_end));
d200 8
d222 1
d262 5
a266 5
      pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
			avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
			TRUE, VM_PROT_READ|VM_PROT_WRITE);
	
   msgbufmapped = 1;
d291 1
a291 1
again:
d317 1
a317 1
	
d363 1
a363 1
				   &maxaddr, size, TRUE);
d366 1
a366 1
			&minaddr, size, FALSE) != KERN_SUCCESS)
d391 1
a391 1
				 16*NCARGS, TRUE);
d396 1
a396 1
				 VM_PHYS_SIZE, TRUE);
d403 1
a403 1
				   M_MBUF, M_NOWAIT);
d406 1
a406 1
			       VM_MBUF_SIZE, FALSE);
d420 1
a420 1
		nbuf, bufpages * CLBYTES);
d464 4
a467 4
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
d511 2
a512 2
char	cpu_model[120];
extern	char version[];
d514 2
a515 2
int	cputyp;
int	cpuspeed;
d517 1
a517 1
struct	mvmeprom_brdid brdid;
d529 13
a541 2
	mc = (mmutype == MMU_68040 ? "40" :
	    (mmutype == MMU_68030 ? "30" : "20"));
d544 30
a573 29
	case CPU_147:
		bcopy(&brdid.suffix, suffix, sizeof brdid.suffix);
		sprintf(suffix, "MVME%x", brdid.model, suffix);
		cpuspeed = pccspeed((struct pccreg *)IIOV(0xfffe1000));
		sprintf(speed, "%02d", cpuspeed);
		break;
#endif
#if defined(MVME162) || defined(MVME167) || defined(MVME177)
	case CPU_162:
	case CPU_167:
	case CPU_177:
		bzero(speed, sizeof speed);
		speed[0] = brdid.speed[0];
		speed[1] = brdid.speed[1];
		if (brdid.speed[2] != '0' &&
		    brdid.speed[3] != '0') {
			speed[2] = '.';
			speed[3] = brdid.speed[2];
			speed[4] = brdid.speed[3];
		}
		cpuspeed = (speed[0] - '0') * 10 + (speed[1] - '0');
		bcopy(brdid.longname, suffix, sizeof(brdid.longname));
		for (len = strlen(suffix)-1; len; len--) {
			if (suffix[len] == ' ')
				suffix[len] = '\0';
			else
				break;
		}
		break;
d577 1
a577 1
	    suffix, speed, mc);
d579 2
a580 1
	case MMU_68040:
d582 2
a583 3
		bcopy(&fpsp_tab, &fpvect_tab,
			(&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));

d585 11
a595 11
		strcat(cpu_model, "+MMU");
		break;
	case MMU_68030:
		strcat(cpu_model, "+MMU");
		break;
	case MMU_68851:
		strcat(cpu_model, ", MC68851 MMU");
		break;
	default:
		printf("%s\nunknown MMU type %d\n", cpu_model, mmutype);
		panic("startup");
d598 3
d603 1
a603 1
		    "+FPU, 4k on-chip physical I/D caches");
d609 9
a617 9
		case 0:
			break;
		case 1:
		case 2:
			len += sprintf(cpu_model + len, ", MC6888%d FPU", fpu);
			break;
		case 3:
			len += sprintf(cpu_model + len, ", unknown FPU", speed);
			break;
d628 7
a634 7
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d643 9
a651 9
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	default:
		return (EOPNOTSUPP);
d656 1
a656 1
int	waittime = -1;
d663 2
a664 2
	void (*fn) __P((void));
	int pri;
d708 1
a708 1
	register int howto;
d754 3
a756 3
u_long	dumpmag = 0x8fca0101;	/* magic number */
int	dumpsize = 0;		/* pages */
long	dumplo = 0;		/* blocks */
d818 16
d835 7
a841 23
	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	default:
		printf("succeeded\n");
		break;
d845 4
d853 68
d922 2
a923 2
	int pc;
	u_short evec;
d926 1
a926 1
	    (evec & 0xFFF) >> 2, pc);
d929 1
a929 1
int	*nofault;
d933 2
a934 2
	register void *addr;
	int size;
d951 2
a952 2
	register caddr_t addr;
	int size;
d955 1
a955 1
	label_t	faultbuf;
d958 1
a958 1
	i = *addr; if (i) return(0);
d966 9
a974 9
	case 1:
		i = *(volatile char *)addr;
		break;
	case 2:
		i = *(volatile short *)addr;
		break;
	case 4:
		i = *(volatile long *)addr;
		break;
d1036 1
a1036 1
	struct frame *frame;
d1048 2
a1049 2
	struct frame *fp; /* must not be register */
	int sbytes;
d1061 1
a1061 1
	    curproc ? curproc->p_pid : -1, hexstr(fp->f_pc, 8));
d1077 1
a1077 1
			    hexstr((int)(((int *)&fp)-1), 8));
d1091 2
a1092 2
	register int *ptr;
	int sz, ustack;
d1107 1
a1107 1
			    (ptr < KSADDR || ptr > KSADDR+(NBPG/4-1)))
d1118 2
a1119 2
	register int val;
	int len;
d1125 1
a1125 1
		return("");
d1135 1
a1135 1
	return(nbuf);
d1143 2
a1144 2
	int oflow;
	struct frame fr;
d1149 2
a1150 2
	    oflow ? oflowmsg : uflowmsg,
	    kstackatbase - (exframesize[fr.f_format] + 8));
d1164 2
a1165 2
	struct proc *p;
	struct exec_package *epp;
d1173 1
a1173 1
		    __P((struct proc *, struct exec_package *));
d1175 1
a1175 1
			return(0);
d1181 1
a1181 1
u_char	myea[6] = { 0x08, 0x00, 0x3e, 0xff, 0xff, 0xff };
d1185 1
a1185 1
	u_char *ether;
d1198 3
a1200 3
	int	fpframe[60 / sizeof(int)];
	label_t	faultbuf;
	u_char	b;
d1241 1
a1241 1
#ifdef MVME162
d1255 18
a1272 18
	case MC_MEMOPTIONS_DRAM1M:
		return (1*1024*1024);
	case MC_MEMOPTIONS_DRAM2M:
		return (2*1024*1024);
	case MC_MEMOPTIONS_DRAM4M:
		return (4*1024*1024);
	case MC_MEMOPTIONS_DRAM4M2:
		return (4*1024*1024);
	case MC_MEMOPTIONS_DRAM8M:
		return (8*1024*1024);
	case MC_MEMOPTIONS_DRAM16M:
		return (16*1024*1024);
	default:
		/*
		 * XXX if the machine has no MC-controlled memory,
		 * perhaps it has a MCECC or MEMC040 controller?
		 */
		return (memsize1x7());
d1277 1
a1277 1
#if defined(MVME162) || defined(MVME167) || defined(MVME177)
d1289 1
a1289 1
	u_long	x;
d1295 90
@


1.29
log
@This gets us to 2.6...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 1999/02/04 23:00:26 niklas Exp $ */
d875 1
a875 1
		ipv6intr();
@


1.28
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 1999/05/24 23:09:04 jason Exp $ */
d229 5
a233 4
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);
	msgbufmapped = 1;
a906 7
	}
#endif
#include "bridge.h"
#if NBRIDGE > 0
	if (netisr & (1 << NETISR_BRIDGE)) {
		netisr &= ~(1 << NETISR_BRIDGE);
		bridgeintr();
@


1.27
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 1999/05/22 21:22:26 weingart Exp $ */
d230 2
a231 1
		    avail_end + i * NBPG, VM_PROT_ALL, TRUE);
@


1.26
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 1999/02/04 23:00:26 niklas Exp $ */
d905 7
@


1.25
log
@Deterministic register initalization on process startup
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1999/01/07 23:16:01 deraadt Exp $ */
a266 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.24
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1998/03/01 00:37:42 niklas Exp $ */
a426 2
 * XXX Should clear registers except sp, pc,
 * but would break init; should be fixed soon.
d437 1
d439 15
a454 1
	frame->f_regs[A2] = (int)PS_STRINGS;
@


1.23
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1997/07/23 06:58:21 denny Exp $ */
d856 6
@


1.22
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1997/03/31 00:24:14 downsj Exp $ */
d157 20
@


1.21
log
@Modernize OpenBSD/mvme68k to match various changes in m68k and hp300 code.

Compiles, but untested for lack of hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 1997/02/14 05:10:17 rahnds Exp $ */
d836 6
@


1.20
log
@Copy all of 040 fp exception vectors into table. previous structure
only copied the array size of bytes instead of the array size of ints.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 1997/02/04 17:22:52 deraadt Exp $ */
d422 1
a422 1
#ifdef FPCOPROC
d425 3
a427 2
	m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);
#endif
a438 47
#ifdef COMPAT_HPUX
	p->p_md.md_flags &= ~MDP_HPUXMMAP;
	if (p->p_emul == &emul_hpux) {
		frame->f_regs[A0] = 0; /* not 68010 (bit 31), no FPA (30) */
		retval[0] = 0;		/* no float card */
#ifdef FPCOPROC
		retval[1] = 1;		/* yes 68881 */
#else
		retval[1] = 0;		/* no 68881 */
#endif
	}
	/*
	 * XXX This doesn't have much to do with setting registers but
	 * I didn't want to muck up kern_exec.c with this code, so I
	 * stuck it here.
	 *
	 * Ensure we perform the right action on traps type 1 and 2:
	 * If our parent is an HPUX process and we are being traced, turn
	 * on HPUX style interpretation.  Else if we were using the HPUX
	 * style interpretation, revert to the BSD interpretation.
	 *
	 * Note that we do this by changing the trap instruction in the
	 * global "sigcode" array which then gets copied out to the user's
	 * sigcode in the stack.  Since we are changing it in the global
	 * array we must always reset it, even for non-HPUX processes.
	 *
	 * Note also that implementing it in this way creates a potential
	 * race where we could have tweaked it for process A which then
	 * blocks in the copyout to the stack and process B comes along
	 * and untweaks it causing A to wind up with the wrong setting
	 * when the copyout continues.  However, since we have already
	 * copied something out to this user stack page (thereby faulting
	 * it in), this scenerio is extremely unlikely.
	 */
	{
		extern short sigcodetrap[];

		if ((p->p_pptr->p_emul == &emul_hpux) &&
		    (p->p_flag & P_TRACED)) {
			p->p_md.md_flags |= MDP_HPUXTRACE;
			*sigcodetrap = 0x4E42;
		} else {
			p->p_md.md_flags &= ~MDP_HPUXTRACE;
			*sigcodetrap = 0x4E41;
		}
	}
#endif
a571 432
}

#define SS_RTEFRAME	1
#define SS_FPSTATE	2
#define SS_USERREGS	4

struct sigstate {
	int	ss_flags;		/* which of the following are valid */
	struct	frame ss_frame;		/* original exception frame */
	struct	fpframe ss_fpstate;	/* 68881/68882 state info */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigstate sf_state;	/* state of the hardware */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
};

#ifdef COMPAT_HPUX
struct	hpuxsigcontext {
	int	hsc_syscall;
	char	hsc_action;
	char	hsc_pad1;
	char	hsc_pad2;
	char	hsc_onstack;
	int	hsc_mask;
	int	hsc_sp;
	short	hsc_ps;
	int	hsc_pc;
/* the rest aren't part of the context but are included for our convenience */
	short	hsc_pad;
	u_int	hsc_magic;		/* XXX sigreturn: cookie */
	struct	sigcontext *hsc_realsc;	/* XXX sigreturn: ptr to BSD context */
};

/*
 * For an HP-UX process, a partial hpuxsigframe follows the normal sigframe.
 * Tremendous waste of space, but some HP-UX applications (e.g. LCL) need it.
 */
struct hpuxsigframe {
	int	hsf_signum;
	int	hsf_code;
	struct	sigcontext *hsf_scp;
	int	hsf_nothing;
	struct	hpuxsigcontext hsf_sc;
	int	hsf_regs[15];
};
#endif

#ifdef DEBUG
int sigdebug = 0;
int sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct sigframe *fp, *kfp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short ft;
	int oonstack, fsize;
	extern char sigcode[], esigcode[];

	frame = (struct frame *)p->p_md.md_regs;
	ft = frame->f_format;
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
#ifdef COMPAT_HPUX
	if (p->p_emul == &emul_hpux)
		fsize = sizeof(struct sigframe) + sizeof(struct hpuxsigframe);
	else
#endif
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
	} else
		fp = (struct sigframe *)(frame->f_regs[SP] - fsize);
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x ft %d\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
#endif
	if (useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): useracc failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	kfp = (struct sigframe *)malloc((u_long)fsize, M_TEMP, M_WAITOK);
	/* 
	 * Build the argument list for the signal handler.
	 */
	kfp->sf_signum = sig;
	kfp->sf_sip = NULL;
	kfp->sf_scp = &fp->sf_sc;
	kfp->sf_handler = catcher;

	/*
	 * Save necessary hardware state.  Currently this includes:
	 *	- general registers
	 *	- original exception frame (if not a "normal" frame)
	 *	- FP coprocessor state
	 */
	kfp->sf_state.ss_flags = SS_USERREGS;
	bcopy((caddr_t)frame->f_regs,
	      (caddr_t)kfp->sf_state.ss_frame.f_regs, sizeof frame->f_regs);
	if (ft >= FMT7) {
#ifdef DEBUG
		if (ft > 15 || exframesize[ft] < 0)
			panic("sendsig: bogus frame type");
#endif
		kfp->sf_state.ss_flags |= SS_RTEFRAME;
		kfp->sf_state.ss_frame.f_format = frame->f_format;
		kfp->sf_state.ss_frame.f_vector = frame->f_vector;
		bcopy((caddr_t)&frame->F_u,
		      (caddr_t)&kfp->sf_state.ss_frame.F_u, exframesize[ft]);
		/*
		 * Leave an indicator that we need to clean up the kernel
		 * stack.  We do this by setting the "pad word" above the
		 * hardware stack frame to the amount the stack must be
		 * adjusted by.
		 *
		 * N.B. we increment rather than just set f_stackadj in
		 * case we are called from syscall when processing a
		 * sigreturn.  In that case, f_stackadj may be non-zero.
		 */
		frame->f_stackadj += exframesize[ft];
		frame->f_format = frame->f_vector = 0;
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sendsig(%d): copy out %d of frame %d\n",
			       p->p_pid, exframesize[ft], ft);
#endif
	}
#ifdef FPCOPROC
	kfp->sf_state.ss_flags |= SS_FPSTATE;
	m68881_save(&kfp->sf_state.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&kfp->sf_state.ss_fpstate)
		printf("sendsig(%d): copy out FP state (%x) to %x\n",
		       p->p_pid, *(u_int *)&kfp->sf_state.ss_fpstate,
		       &kfp->sf_state.ss_fpstate);
#endif
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	kfp->sf_sc.sc_onstack = oonstack;
	kfp->sf_sc.sc_mask = mask;
	kfp->sf_sc.sc_sp = frame->f_regs[SP];
	kfp->sf_sc.sc_fp = frame->f_regs[A6];
	kfp->sf_sc.sc_ap = (int)&fp->sf_state;
	kfp->sf_sc.sc_pc = frame->f_pc;
	kfp->sf_sc.sc_ps = frame->f_sr;

	if (psp->ps_siginfo & sigmask(sig)) {
		kfp->sf_sip = &fp->sf_si;
		initsiginfo(&kfp->sf_si, sig, code, type, val);
	}

#ifdef COMPAT_HPUX
	/*
	 * Create an HP-UX style sigcontext structure and associated goo
	 */
	if (p->p_emul == &emul_hpux) {
		register struct hpuxsigframe *hkfp;

		hkfp = (struct hpuxsigframe *)&kfp[1];
		hkfp->hsf_signum = bsdtohpuxsig(kfp->sf_signum);
		hkfp->hsf_code = kfp->sf_code;
		hkfp->hsf_scp = (struct sigcontext *)
			&((struct hpuxsigframe *)(&fp[1]))->hsf_sc;
		hkfp->hsf_sc.hsc_syscall = 0;		/* XXX */
		hkfp->hsf_sc.hsc_action = 0;		/* XXX */
		hkfp->hsf_sc.hsc_pad1 = hkfp->hsf_sc.hsc_pad2 = 0;
		hkfp->hsf_sc.hsc_onstack = kfp->sf_sc.sc_onstack;
		hkfp->hsf_sc.hsc_mask = kfp->sf_sc.sc_mask;
		hkfp->hsf_sc.hsc_sp = kfp->sf_sc.sc_sp;
		hkfp->hsf_sc.hsc_ps = kfp->sf_sc.sc_ps;
		hkfp->hsf_sc.hsc_pc = kfp->sf_sc.sc_pc;
		hkfp->hsf_sc.hsc_pad = 0;
		hkfp->hsf_sc.hsc_magic = 0xdeadbeef;
		hkfp->hsf_sc.hsc_realsc = kfp->sf_scp;
		bcopy((caddr_t)frame->f_regs, (caddr_t)hkfp->hsf_regs,
		      sizeof (hkfp->hsf_regs));

		kfp->sf_signum = hkfp->hsf_signum;
		kfp->sf_scp = hkfp->hsf_scp;
	}
#endif
	/* XXX do not copy out siginfo if not needed */
	(void) copyout((caddr_t)kfp, (caddr_t)fp, fsize);
	frame->f_regs[SP] = (int)fp;
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): sig %d scp %x fp %x sc_sp %x sc_ap %x\n",
		       p->p_pid, sig, kfp->sf_scp, fp,
		       kfp->sf_sc.sc_sp, kfp->sf_sc.sc_ap);
#endif
	/*
	 * Signal trampoline code is at base of user stack.
	 */
	frame->f_pc = (int)PS_STRINGS - (esigcode - sigcode);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
	free((caddr_t)kfp, M_TEMP);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper priviledges or to cause
 * a machine fault.
 */
/* ARGSUSED */
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	register struct sigcontext *scp;
	register struct frame *frame;
	register int rf;
	struct sigcontext tsigc;
	struct sigstate tstate;
	int flags;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
#endif
	if ((int)scp & 1)
		return (EINVAL);
#ifdef COMPAT_HPUX
	/*
	 * Grab context as an HP-UX style context and determine if it
	 * was one that we contructed in sendsig.
	 */
	if (p->p_emul == &emul_hpux) {
		struct hpuxsigcontext *hscp = (struct hpuxsigcontext *)scp;
		struct hpuxsigcontext htsigc;

		if (useracc((caddr_t)hscp, sizeof (*hscp), B_WRITE) == 0 ||
		    copyin((caddr_t)hscp, (caddr_t)&htsigc, sizeof htsigc))
			return (EINVAL);
		/*
		 * If not generated by sendsig or we cannot restore the
		 * BSD-style sigcontext, just restore what we can -- state
		 * will be lost, but them's the breaks.
		 */
		hscp = &htsigc;
		if (hscp->hsc_magic != 0xdeadbeef ||
		    (scp = hscp->hsc_realsc) == 0 ||
		    useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
		    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc)) {
			if (hscp->hsc_onstack & 01)
				p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
			else
				p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
			p->p_sigmask = hscp->hsc_mask &~ sigcantmask;
			frame = (struct frame *) p->p_md.md_regs;
			frame->f_regs[SP] = hscp->hsc_sp;
			frame->f_pc = hscp->hsc_pc;
			frame->f_sr = hscp->hsc_ps &~ PSL_USERCLR;
			return (EJUSTRETURN);
		}
		/*
		 * Otherwise, overlay BSD context with possibly modified
		 * HP-UX values.
		 */
		tsigc.sc_onstack = hscp->hsc_onstack;
		tsigc.sc_mask = hscp->hsc_mask;
		tsigc.sc_sp = hscp->hsc_sp;
		tsigc.sc_ps = hscp->hsc_ps;
		tsigc.sc_pc = hscp->hsc_pc;
	} else
#endif
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	if (useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
		return (EINVAL);
	scp = &tsigc;
	if ((scp->sc_ps & (PSL_MBZ|PSL_IPL|PSL_S)) != 0)
		return (EINVAL);
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->sc_sp;
	frame->f_regs[A6] = scp->sc_fp;
	frame->f_pc = scp->sc_pc;
	frame->f_sr = scp->sc_ps;
	/*
	 * Grab pointer to hardware state information.
	 * If zero, the user is probably doing a longjmp.
	 */
	if ((rf = scp->sc_ap) == 0)
		return (EJUSTRETURN);
	/*
	 * See if there is anything to do before we go to the
	 * expense of copying in close to 1/2K of data
	 */
	flags = fuword((caddr_t)rf);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): sc_ap %x flags %x\n",
		    p->p_pid, rf, flags);
#endif
	/*
	 * fuword failed (bogus sc_ap value).
	 */
	if (flags == -1)
		return (EINVAL);
	if (flags == 0 || copyin((caddr_t)rf, (caddr_t)&tstate, sizeof tstate))
		return (EJUSTRETURN);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sigreturn(%d): ssp %x usp %x scp %x ft %d\n",
		    p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		    (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
#endif
	/*
	 * Restore most of the users registers except for A6 and SP
	 * which were handled above.
	 */
	if (flags & SS_USERREGS)
		bcopy((caddr_t)tstate.ss_frame.f_regs,
		    (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
	/*
	 * Restore long stack frames.  Note that we do not copy
	 * back the saved SR or PC, they were picked up above from
	 * the sigcontext structure.
	 */
	if (flags & SS_RTEFRAME) {
		register int sz;
		
		/* grab frame type and validate */
		sz = tstate.ss_frame.f_format;
		if (sz > 15 || (sz = exframesize[sz]) < 0)
			return (EINVAL);
		frame->f_stackadj -= sz;
		frame->f_format = tstate.ss_frame.f_format;
		frame->f_vector = tstate.ss_frame.f_vector;
		bcopy((caddr_t)&tstate.ss_frame.F_u, (caddr_t)&frame->F_u, sz);
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sigreturn(%d): copy in %d of frame type %d\n",
			    p->p_pid, sz, tstate.ss_frame.f_format);
#endif
	}
#ifdef FPCOPROC
	/*
	 * Finally we restore the original FP context
	 */
	if (flags & SS_FPSTATE)
		m68881_restore(&tstate.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&tstate.ss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %x\n",
		    p->p_pid, *(u_int *)&tstate.ss_fpstate,
		    &tstate.ss_fpstate);
#endif
#endif
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
@


1.19
log
@an important comment
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 1997/02/03 15:04:58 deraadt Exp $ */
d548 3
a550 1
		bcopy(&fpsp_tab, &fpvect_tab, &fpvect_end - &fpvect_tab);
@


1.18
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1997/02/03 12:48:52 deraadt Exp $ */
d850 1
@


1.17
log
@repair confusion over kv/uv addr for siginfo_t storage
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 1997/02/02 00:43:20 deraadt Exp $ */
d634 1
a634 1
	int	sf_code;		/* additional info for handler */
a635 1
	siginfo_t *sf_sip;
d753 1
a753 1
	kfp->sf_code = code;
a755 1
	kfp->sf_sip = NULL;
@


1.16
log
@trapsignal/sendsig type/sigval changes
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 1997/01/28 09:01:31 deraadt Exp $ */
d818 2
a819 2
		kfp->sf_sip = &kfp->sf_si;
		initsiginfo(kfp->sf_sip, sig, code, type, val);
@


1.15
log
@hp300 compat for siginfo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 1997/01/27 22:48:16 deraadt Exp $ */
d686 1
a686 1
sendsig(catcher, sig, mask, code, addr)
d690 2
a691 1
	caddr_t addr;
d819 1
a819 11
		initsiginfo(kfp->sf_sip, sig);
		fixsiginfo(kfp->sf_sip, sig, code, addr);
		if (sig == SIGSEGV) {
			/* try to be more specific about read or write */
#if 0
			if (WRFAULT(frame->f_pad))
				kfp->sf_si.si_code |= SEGV_ACCERR;
			else
				kfp->sf_si.si_code |= SEGV_MAPERR;
#endif
		}
a1048 71
}

void
fixsiginfo(si, sig, code, addr)
	siginfo_t *si;
	int sig;
	u_long code;
	caddr_t addr;
{
	si->si_addr = addr;

	switch (code) {
#if 0
	case T_PRIVINFLT:
		si->si_code = ILL_PRVOPC;
		si->si_trapno = T_PRIVINFLT;
		break;
	case T_BREAKPOINT:
		si->si_code = TRAP_BRKPT;
		si->si_trapno = T_BREAKPOINT;
		break;
	case T_ARITHTRAP:
		si->si_code = FPE_INTOVF;
		si->si_trapno = T_DIVIDE;
		break;
	case T_PROTFLT:
		si->si_code = SEGV_ACCERR;
		si->si_trapno = T_PROTFLT;
		break;
	case T_TRCTRAP:
		si->si_code = TRAP_TRACE;
		si->si_trapno = T_TRCTRAP;
		break;
	case T_PAGEFLT:
		si->si_code = SEGV_ACCERR;
		si->si_trapno = T_PAGEFLT;
		break;
	case T_ALIGNFLT:
		si->si_code = BUS_ADRALN;
		si->si_trapno = T_ALIGNFLT;
		break;
	case T_DIVIDE:
		si->si_code = FPE_FLTDIV;
		si->si_trapno = T_DIVIDE;
		break;
	case T_OFLOW:
		si->si_code = FPE_FLTOVF;
		si->si_trapno = T_DIVIDE;
		break;
	case T_BOUND:
		si->si_code = FPE_FLTSUB;
		si->si_trapno = T_BOUND;
		break;
	case T_DNA:
		si->si_code = FPE_FLTINV;
		si->si_trapno = T_DNA;
		break;
	case T_FPOPFLT:
		si->si_code = FPE_FLTINV;
		si->si_trapno = T_FPOPFLT;
		break;
	case T_SEGNPFLT:
		si->si_code = SEGV_MAPERR;
		si->si_trapno = T_SEGNPFLT;
		break;
	case T_STKFLT:
		si->si_code = ILL_BADSTK;
		si->si_trapno = T_STKFLT;
		break;
#endif
	}
@


1.14
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 1997/01/16 20:43:38 kstailey Exp $ */
d668 1
@


1.13
log
@do not call resettodr() if RB_TIMEBAD is set due to being in ddb with clock updates suspended
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1996/07/27 11:40:42 deraadt Exp $ */
d636 1
d640 1
d685 1
a685 1
sendsig(catcher, sig, mask, code)
d689 1
d755 2
d814 16
d1057 71
@


1.12
log
@handle RB_CONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 1996/06/11 10:15:54 deraadt Exp $ */
d1107 2
a1108 1
		 * will be out of synch; adjust it now.
d1110 5
a1114 1
		resettodr();
@


1.11
log
@use void * for pa/va instead of caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d395 7
@


1.10
log
@do that another panic fly away.
@
text
@d1231 1
a1231 1
	register caddr_t addr;
d1235 1
a1235 1
	caddr_t v, p = (caddr_t)((int)addr & ~PGOFSET);
@


1.9
log
@for 040, copy replacement routines over fpfault zone in trap table
@
text
@d1092 4
@


1.8
log
@proto nicely
@
text
@d496 1
d540 5
@


1.7
log
@add OpenBSD header
@
text
@d163 1
a1096 2
		while (1)
			;
d1106 2
@


1.6
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 1
a1 1
/*	$Id: machdep.c,v 1.5 1995/11/29 17:02:49 deraadt Exp $ */
@


1.5
log
@niklas pointed out the new MDP_UNCACHE_WX might break fork/exec.
always set/clear in setregs() now
@
text
@d1 1
a1 1
/*	$Id: machdep.c,v 1.4 1995/11/28 01:24:40 deraadt Exp $ */
d700 1
a700 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_base +
@


1.4
log
@delete last chunks of MAPPEDCOPY
@
text
@d1 1
a1 1
/*	$Id: machdep.c,v 1.3 1995/11/07 08:50:20 deraadt Exp $ */
d418 11
@


1.3
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
a1194 12
#ifdef MAPPEDCOPY
	extern u_int mappedcopysize;

	/*
	 * Initialize lower bound for doing copyin/copyout using
	 * page mapping (if not already set).  We don't do this on
	 * VAC machines as it loses big time.
	 */
	if (mappedcopysize == 0) {
		mappedcopysize = NBPG;
	}
#endif
@


1.2
log
@sigreturn -> sys_sigreturn
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.48 1995/05/16 14:34:19 mycroft Exp $	*/
d5 28
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.4 1995/10/07 06:25:54 mycroft Exp $	*/
d4 1
d80 2
a85 1
#include <mvme68k/mvme68k/isr.h>
a119 2
u_long myea; /* from ROM XXXCDC */

a128 3
#ifdef COMPAT_SVR4
extern struct emul emul_svr4;
#endif
a138 11
	 * Set cpuspeed immediately since cninit() called routines
	 * might use delay.  Note that we only set it if a custom value
	 * has not already been specified.
	 */
	if (cpuspeed == 0) {
		cpuspeed = MHZ_16;
		if (mmutype == MMU_68040)
			cpuspeed *= 2;	/* XXX */
	}

	/*
d144 1
a286 3
#ifdef BUFFERS_UNMANAGED
	bufmemp = (vm_offset_t) buffermem;
#endif
a299 17
#ifdef BUFFERS_UNMANAGED
		/*
		 * Move the physical pages over from buffermem.
		 */
		for (ix = 0; ix < curbufsize/CLBYTES; ix++) {
			vm_offset_t pa;

			pa = pmap_extract(pmap_kernel(), bufmemp);
			if (pa == 0)
				panic("startup: unmapped buffer");
			pmap_remove(pmap_kernel(), bufmemp, bufmemp+CLBYTES);
			pmap_enter(pmap_kernel(),
				   (vm_offset_t)(curbuf + ix * CLBYTES),
				   pa, VM_PROT_READ|VM_PROT_WRITE, TRUE);
			bufmemp += CLBYTES;
		}
#else
a301 1
#endif
a302 9
#ifdef BUFFERS_UNMANAGED
#if 0
	/*
	 * We would like to free the (now empty) original address range
	 * but too many bad things will happen if we try.
	 */
	kmem_free(kernel_map, (vm_offset_t)buffermem, bufpages*CLBYTES);
#endif
#endif
d338 15
d446 5
d454 2
d458 11
a468 3
	switch (mmutype) {
	case MMU_68851:
		t = "?";
d470 22
a491 8
	case MMU_68030:
		t = "147";
		break;
	case MMU_68040:
		t = "16[27]";
		break;
	default:
		t = "unknown";
d493 1
d495 2
a496 3
	mc = (mmutype == MMU_68040 ? "40" :
		(mmutype == MMU_68030 ? "30" : "20"));
	sprintf(cpu_model, "Motorola MVME%s MC680%s CPU", t, mc);
d513 17
a529 7
	else if (mmutype == MMU_68030)
		len += sprintf(cpu_model + len, ", %sMHz MC68882 FPU",
		       "???");
	else
		len += sprintf(cpu_model + len, ", %sMHz MC68881 FPU",
		       "???");
	strcat(cpu_model, ")");
a564 47
#ifdef USELEDS
#include <hp300/hp300/led.h>

int inledcontrol = 0;	/* 1 if we are in ledcontrol already, cheap mutex */
char *ledaddr;

/*
 * Map the LED page and setup the KVA to access it.
 */
ledinit()
{
	extern caddr_t ledbase;

	pmap_enter(pmap_kernel(), (vm_offset_t)ledbase, (vm_offset_t)LED_ADDR,
		   VM_PROT_READ|VM_PROT_WRITE, TRUE);
	ledaddr = (char *) ((int)ledbase | (LED_ADDR & PGOFSET));
}

/*
 * Do lights:
 *	`ons' is a mask of LEDs to turn on,
 *	`offs' is a mask of LEDs to turn off,
 *	`togs' is a mask of LEDs to toggle.
 * Note we don't use splclock/splx for mutual exclusion.
 * They are expensive and we really don't need to be that precise.
 * Besides we would like to be able to profile this routine.
 */
ledcontrol(ons, offs, togs)
	register int ons, offs, togs;
{
	static char currentleds;
	register char leds;

	inledcontrol = 1;
	leds = currentleds;
	if (ons)
		leds |= ons;
	if (offs)
		leds &= ~offs;
	if (togs)
		leds ^= togs;
	currentleds = leds;
	*ledaddr = ~leds;
	inledcontrol = 0;
}
#endif

d645 1
a645 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d663 1
a663 1
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
a816 1
int
d862 1
a862 1
				p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d864 1
a864 1
				p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
d897 1
a897 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d899 1
a899 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
d920 1
a920 1
		       p->p_pid, rf, flags);
d932 2
a933 2
		       p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		       (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
d941 1
a941 1
		      (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
d961 1
a961 1
			       p->p_pid, sz, tstate.ss_frame.f_format);
d973 2
a974 2
		       p->p_pid, *(u_int *)&tstate.ss_fpstate,
		       &tstate.ss_fpstate);
d987 48
d1039 1
d1057 2
a1058 2
		doboot(RB_HALT);
		/*NOTREACHED*/
d1060 2
d1064 3
a1066 2
		doboot(RB_AUTOBOOT);
		/*NOTREACHED*/
d1185 2
a1186 2
	printf("unexpected trap (vector offset %x) from %x\n",
	       evec & 0xFFF, pc);
d1191 2
a1192 1
badaddr(addr)
d1194 1
d1196 11
a1206 14
	register int i;
	label_t	faultbuf;

#ifdef lint
	i = *addr; if (i) return(0);
#endif
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *) 0;
		return(1);
	}
	i = *(volatile short *)addr;
	nofault = (int *) 0;
	return(0);
d1209 2
a1210 1
badbaddr(addr)
d1212 1
d1222 2
a1223 2
		nofault = (int *) 0;
		return(1);
d1225 13
a1237 3
	i = *(volatile char *)addr;
	nofault = (int *) 0;
	return(0);
a1278 63
intrhand(sr)
	int sr;
{
	register struct isr *isr;
	register int found = 0;
	register int ipl;
	extern struct isr isrqueue[];
	static int straycount;

	ipl = (sr >> 8) & 7;
printf("intrhand\n");
	switch (ipl) {

	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
		ipl = ISRIPL(ipl);
		isr = isrqueue[ipl].isr_forw;
		for (; isr != &isrqueue[ipl]; isr = isr->isr_forw) {
			if ((isr->isr_intr)(isr->isr_arg)) {
				found++;
				break;
			}
		}
		if (found)
			straycount = 0;
		else if (++straycount > 50)
			panic("intrhand: stray interrupt");
		else
			printf("stray interrupt, sr 0x%x\n", sr);
		break;

	case 0:
	case 7:
		if (++straycount > 50)
			panic("intrhand: unexpected sr");
		else
			printf("intrhand: unexpected sr 0x%x\n", sr);
		break;
	}
}

#if (defined(DDB) || defined(DEBUG)) && !defined(PANICBUTTON)
#define PANICBUTTON
#endif

#ifdef PANICBUTTON
int panicbutton = 1;	/* non-zero if panic buttons are enabled */
int crashandburn = 0;
int candbdelay = 50;	/* give em half a second */

void
candbtimer(arg)
	void *arg;
{

	crashandburn = 0;
}
#endif

d1280 2
a1281 1
 * Level 7 interrupts can't be caused by anything
d1284 1
a1284 1
	struct frame frame;
d1286 4
d1292 1
d1309 1
a1309 1
	       curproc ? curproc->p_pid : -1, hexstr(fp->f_pc, 8));
d1325 1
a1325 1
			       hexstr((int)(((int *)&fp)-1), 8));
d1397 2
a1398 2
	       oflow ? oflowmsg : uflowmsg,
	       kstackatbase - (exframesize[fr.f_format] + 8));
d1412 2
a1413 2
    struct proc *p;
    struct exec_package *epp;
d1415 3
a1417 1
    int error = ENOEXEC;
d1419 6
a1424 4
    extern sunos_exec_aout_makecmds
        __P((struct proc *, struct exec_package *));
    if ((error = sunos_exec_aout_makecmds(p, epp)) == 0)
        return 0;
d1426 1
a1426 1
    return error;
d1429 2
d1433 102
a1534 1
	char *ether;
d1536 2
a1537 1
	int e = myea;
d1539 2
a1540 9
	ether[0] = 0x08;
	ether[1] = 0x00;
	ether[2] = 0x3e;
	e = e >> 8;
	ether[5] = e & 0xff;
	e = e >> 8;
	ether[4] = e & 0xff;
	e = e >> 8;
	ether[3] = e;
d1542 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.48 1995/05/16 14:34:19 mycroft Exp $	*/
a3 1
 * Copyright (c) 1995 Theo de Raadt
a78 2
#include <machine/autoconf.h>
#include <machine/prom.h>
d83 1
d118 2
d129 3
d142 11
a157 1
	db_machine_init();
d300 3
d316 17
d335 1
d337 9
a380 15
#ifdef MFS
	/*
	 * Check to see if a mini-root was loaded into memory. It resides
	 * at the start of the next page just after the end of BSS.
	 */
	{
		extern void *smini;

		if (smini && (boothowto & RB_MINIROOT)) {
			boothowto |= RB_DFLTROOT;
			mfs_initminiroot(smini);
		}
	}
#endif

a473 5
int	cputyp;
int	cpuspeed;

struct	mvmeprom_brdid brdid;

a476 2
	char speed[6];
	char suffix[30];
d479 9
a487 11
	bzero(suffix, sizeof suffix);

	mc = (mmutype == MMU_68040 ? "40" :
	    (mmutype == MMU_68030 ? "30" : "20"));
	switch (cputyp) {
#ifdef MVME147
	case CPU_147:
		bcopy(&brdid.suffix, suffix, sizeof brdid.suffix);
		sprintf(suffix, "MVME%x", brdid.model, suffix);
		cpuspeed = pccspeed((struct pccreg *)IIOV(0xfffe1000));
		sprintf(speed, "%02d", cpuspeed);
d489 2
a490 22
#endif
#if defined(MVME162) || defined(MVME167) || defined(MVME177)
	case CPU_162:
	case CPU_167:
	case CPU_177:
		bzero(speed, sizeof speed);
		speed[0] = brdid.speed[0];
		speed[1] = brdid.speed[1];
		if (brdid.speed[2] != '0' &&
		    brdid.speed[3] != '0') {
			speed[2] = '.';
			speed[3] = brdid.speed[2];
			speed[4] = brdid.speed[3];
		}
		cpuspeed = (speed[0] - '0') * 10 + (speed[1] - '0');
		bcopy(brdid.longname, suffix, sizeof(brdid.longname));
		for (len = strlen(suffix)-1; len; len--) {
			if (suffix[len] == ' ')
				suffix[len] = '\0';
			else
				break;
		}
a491 1
#endif
d493 3
a495 2
	sprintf(cpu_model, "Motorola %s: %sMHz MC680%s CPU",
	    suffix, speed, mc);
d512 7
a518 17
#if defined(M68030) || defined(M68020)
	else {
		int fpu = fpu_gettype();

		switch (fpu) {
		case 0:
			break;
		case 1:
		case 2:
			len += sprintf(cpu_model + len, ", MC6888%d FPU", fpu);
			break;
		case 3:
			len += sprintf(cpu_model + len, ", unknown FPU", speed);
			break;
		}
	}
#endif
d554 47
d681 1
a681 1
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
d699 1
a699 1
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
d853 2
a854 1
sigreturn(p, uap, retval)
d856 1
a856 3
	struct sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap;
d859 3
d899 1
a899 1
				p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
d901 1
a901 1
				p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
d934 1
a934 1
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
d936 1
a936 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
d957 1
a957 1
		    p->p_pid, rf, flags);
d969 2
a970 2
		    p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		    (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
d978 1
a978 1
		    (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
d998 1
a998 1
			    p->p_pid, sz, tstate.ss_frame.f_format);
d1010 2
a1011 2
		    p->p_pid, *(u_int *)&tstate.ss_fpstate,
		    &tstate.ss_fpstate);
a1023 48
static struct haltvec *halts;

/* XXX insert by priority */
void
halt_establish(fn, pri)
	void (*fn) __P((void));
	int pri;
{
	struct haltvec *hv, *h;

	hv = (struct haltvec *)malloc(sizeof(*hv), M_TEMP, M_NOWAIT);
	if (hv == NULL)
		return;
	hv->hv_fn = fn;
	hv->hv_pri = pri;
	hv->hv_next = NULL;

	/* put higher priorities earlier in the list */
	h = halts;
	if (h == NULL) {
		halts = hv;
		return;
	}

	if (h->hv_pri < pri) {
		/* higher than first element */
		hv->hv_next = halts;
		halts = hv;
		return;
	}

	while (h) {
		if (h->hv_next == NULL) {
			/* no more elements, must be the lowest priority */
			h->hv_next = hv;
			return;
		}

		if (h->hv_next->hv_pri < pri) {
			/* next element is lower */
			hv->hv_next = h->hv_next;
			h->hv_next = hv;
			return;
		}
		h = h->hv_next;
	}
}

a1027 1

d1045 2
a1046 2
		while (1)
			;
a1047 2
		struct haltvec *hv;

d1050 2
a1051 3
		for (hv = halts; hv; hv = hv->hv_next)
			(*hv->hv_fn)();
		doboot();
d1170 2
a1171 2
	printf("unexpected trap (vector %d) from %x\n",
	    (evec & 0xFFF) >> 2, pc);
d1176 1
a1176 2
int
badpaddr(addr, size)
a1177 1
	int size;
d1179 14
a1192 11
	int off = (int)addr & PGOFSET;
	caddr_t v, p = (caddr_t)((int)addr & ~PGOFSET);
	int x;

	v = mapiodev(p, NBPG);
	if (v == NULL)
		return (1);
	v += off;
	x = badvaddr(v + off, size);
	unmapiodev(v, NBPG);
	return (x);
d1195 1
a1195 2
int
badvaddr(addr, size)
a1196 1
	int size;
d1206 2
a1207 2
		nofault = (int *)0;
		return (1);
d1209 3
a1211 13
	switch (size) {
	case 1:
		i = *(volatile char *)addr;
		break;
	case 2:
		i = *(volatile short *)addr;
		break;
	case 4:
		i = *(volatile long *)addr;
		break;
	}
	nofault = (int *)0;
	return (0);
d1253 63
d1317 1
a1317 2
 * Level 7 interrupts are normally caused by the ABORT switch,
 * drop into ddb.
d1320 1
a1320 1
	struct frame *frame;
a1321 4
#ifdef DDB
	printf("NMI ... going to debugger\n");
	Debugger();
#else
a1323 1
#endif
d1340 1
a1340 1
	    curproc ? curproc->p_pid : -1, hexstr(fp->f_pc, 8));
d1356 1
a1356 1
			    hexstr((int)(((int *)&fp)-1), 8));
d1428 2
a1429 2
	    oflow ? oflowmsg : uflowmsg,
	    kstackatbase - (exframesize[fr.f_format] + 8));
d1443 2
a1444 2
	struct proc *p;
	struct exec_package *epp;
d1446 1
a1446 3
	int error = ENOEXEC;
	struct exec *execp = epp->ep_hdr;

d1448 4
a1451 6
	{
		extern sunos_exec_aout_makecmds
		    __P((struct proc *, struct exec_package *));
		if ((error = sunos_exec_aout_makecmds(p, epp)) == 0)
			return(0);
	}
d1453 1
a1453 1
	return (error);
a1455 2
u_char	myea[6] = { 0x08, 0x00, 0x3e, 0xff, 0xff, 0xff };

d1458 1
a1458 8
	u_char *ether;
{
	bcopy(myea, ether, sizeof myea);
}

#if defined(M68030) || defined(M68020)
int
fpu_gettype()
d1460 1
a1460 37
	/*
	 * A 68881 idle frame is 28 bytes and a 68882's is 60 bytes.
	 * We, of course, need to have enough room for either.
	 */
	int	fpframe[60 / sizeof(int)];
	label_t	faultbuf;
	u_char	b;

	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *)0;
		return (0);		/* no FPU */
	}

	/*
	 * Synchronize FPU or cause a fault.
	 * This should leave the 881/882 in the IDLE state,
	 * state, so we can determine which we have by
	 * examining the size of the FP state frame
	 */
	asm("fnop");

	nofault = (int *)0;

	/*
	 * Presumably, this will not cause a fault--the fnop should
	 * have if this will.  We save the state in order to get the
	 * size of the frame.
	 */
	asm("movl %0, a0; fsave a0@@" : : "a" (fpframe) : "a0" );
	b = *((u_char *) fpframe + 1);

	/*
	 * Now, restore a NULL state to reset the FPU.
	 */
	fpframe[0] = fpframe[1] = 0;
	m68881_restore(fpframe);
d1462 9
a1470 5
	if (b == 0x18)
		return (1);	/* The size of a 68881 IDLE frame is 0x18 */
	if (b == 0x38)
		return (2);	/* 68882 frame is 0x38 bytes long */
	return (3);		/* unknown FPU type */
a1471 57
#endif


#ifdef MVME162
#include <mvme68k/dev/mcreg.h>
/*
 * XXX
 * used by locore.s to figure out how much memory is on the machine.
 * At this stage we only know that our machine is a 162. It is very
 * unfortunate that the MCchip's address must be encoded here.
 */
int
memsize162()
{
	struct mcreg *mc = (struct mcreg *)0xfff42000;

	switch (mc->mc_memoptions & MC_MEMOPTIONS_DRAMMASK) {
	case MC_MEMOPTIONS_DRAM1M:
		return (1*1024*1024);
	case MC_MEMOPTIONS_DRAM2M:
		return (2*1024*1024);
	case MC_MEMOPTIONS_DRAM4M:
		return (4*1024*1024);
	case MC_MEMOPTIONS_DRAM4M2:
		return (4*1024*1024);
	case MC_MEMOPTIONS_DRAM8M:
		return (8*1024*1024);
	case MC_MEMOPTIONS_DRAM16M:
		return (16*1024*1024);
	default:
		/*
		 * XXX if the machine has no MC-controlled memory,
		 * perhaps it has a MCECC or MEMC040 controller?
		 */
		return (memsize1x7());
	}
}
#endif

#if defined(MVME162) || defined(MVME167) || defined(MVME177)
#include <mvme68k/dev/memcreg.h>
/*
 * XXX
 * finish writing this
 * 1) it is ugly
 * 2) it only looks at the first MEMC040/MCECC controller
 */
int
memsize1x7()
{
	struct memcreg *memc = (struct memcreg *)0xfff43000;
	u_long	x;

	x = MEMC_MEMCONF_RTOB(memc->memc_memconf);
	return (x);
}
#endif
@

