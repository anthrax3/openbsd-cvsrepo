head	1.48;
access;
symbols
	OPENBSD_5_5:1.47.0.14
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.47.0.10
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.47.0.8
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.47.0.6
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.46.0.2
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.45.0.4
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.28.0.4
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.11.0.8
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.12
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.10
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.47;

1.47
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.26.20.17.27;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.01.22.08.13;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.17.22.28.41;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.15.01.19.08;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2006.07.10.19.23.25;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.24.14.04.04;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.11.07.22.00;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.27.18.31.09;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.22.22.56.31;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.27.14.17.41;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.24.22.43.19;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.30.22.29.48;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.02.17.34.23;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.04.15.27.19;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.23.22.52.30;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.24.22.13.39;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.16.23.19.31;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.10.00.58.04;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.09.19.21.32.19;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.25.00.43.13;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.05.22.33.57;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.24.05.20.54;	author smurph;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	96.11.23.21.46.04;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.11.06.01.45.34;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.06.16.10.34.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.11.10.15.49;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.29.16.37.16;	author chuck;	state Exp;
branches;
next	1.5;

1.5
date	96.04.28.10.58.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.30.09.24.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.30.22.53.55;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.50.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.12;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.42.32;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2001.07.04.10.19.33;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.10.31.03.01.17;	author nate;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.03.06.01.07.00;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.28.10.34.06;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2003.05.13.19.41.06;	author ho;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	1.11.2.9;

1.11.2.9
date	2004.06.05.23.10.53;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.15;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.21.45.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: autoconf.c,v 1.47 2011/04/07 15:30:15 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 * 	The Regents of the University of California. All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: autoconf.c 1.36 92/12/20$
 * 
 *	@@(#)autoconf.c  8.2 (Berkeley) 1/12/94
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/disklabel.h>

#include <machine/vmparam.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/pte.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <dev/cons.h>

int	mainbus_print(void *, const char *);
int	mainbus_scan(struct device *, void *, void *);

extern void init_intrs(void);
extern void dumpconf(void);

int	get_target(int *, int *, int *);

/* boot device information */
paddr_t	bootaddr;
int	bootctrllun, bootdevlun;
int	bootpart, bootbus;
struct	device *bootdv;

struct	extent *extio;
extern	vaddr_t extiobase;

/*
 * Determine mass storage and memory configuration for a machine.
 */
void
cpu_configure()
{
	init_intrs();

	extio = extent_create("extio",
	    (u_long)extiobase, (u_long)extiobase + ptoa(EIOMAPSIZE),
	    M_DEVBUF, NULL, 0, EX_NOWAIT);

	if (config_rootfound("mainbus", NULL) == NULL)
		panic("autoconfig failed, no root");

	printf("boot device: %s\n",
	    (bootdv) ? bootdv->dv_xname : "<unknown>");
	cold = 0;
}

void
diskconf(void)
{
	setroot(bootdv, bootpart, RB_USERREQ);
	dumpconf();
}

/*
 * Allocate/deallocate a cache-inhibited range of kernel virtual address
 * space mapping the indicated physical address range [pa - pa+size)
 */
vaddr_t
mapiodev(pa, size)
	paddr_t pa;
	int size;
{
	int error;
	paddr_t base;
	vaddr_t va, iova;

	if (size <= 0)
		return 0;

	base = pa & PAGE_MASK;
	pa = trunc_page(pa);
	size = round_page(base + size);

	error = extent_alloc(extio, size, EX_NOALIGN, 0, EX_NOBOUNDARY,
	    EX_NOWAIT | EX_MALLOCOK, &iova);

	if (error != 0)
	        return 0;

	va = iova;
	while (size != 0) {
		pmap_kenter_cache(va, pa, PG_RW | PG_CI);
		size -= PAGE_SIZE;
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
	return (iova + base);
}

void
unmapiodev(kva, size)
	vaddr_t kva;
	int size;
{
	int error;
	vaddr_t va;

#ifdef DEBUG
	if (kva < extiobase || kva + size >= extiobase + ptoa(EIOMAPSIZE))
	        panic("unmapiodev: bad address");
#endif

	va = trunc_page(kva);
	size = round_page(kva + size) - va;
	pmap_kremove(va, size);
	pmap_update(pmap_kernel());

	error = extent_free(extio, va, size, EX_NOWAIT);
#ifdef DIAGNOSTIC
	if (error != 0)
		printf("unmapiodev: extent_free failed\n");
#endif
}

void
device_register(struct device *dev, void *aux)
{
	if (bootpart == -1) /* ignore flag from controller driver? */
		return;

	/*
	 * scsi: sd,cd
	 */
	if (strcmp("sd", dev->dv_cfdata->cf_driver->cd_name) == 0 ||
	    strcmp("cd", dev->dv_cfdata->cf_driver->cd_name) == 0) {
		struct scsi_attach_args *sa = aux;
		int target, bus, lun;

#if defined(MVME141) || defined(MVME147)
		/*
		 * Both 141 and 147 do not use the controller number to
		 * identify the controller itself, but expect the
		 * operating system to match it with its physical address
		 * (bootaddr), which is indeed what we are doing.
		 * Then the SCSI device id may be found in the controller
		 * number, and the device number is zero (except on MVME141
		 * when booting from MVME319/320/321/322, which we
		 * do not support anyway).
		 */
		if (cputyp == CPU_141 || cputyp == CPU_147) {
			target = bootctrllun;
			bus = lun = 0;
		} else
#endif
		{
			if (get_target(&target, &bus, &lun) != 0)
				return;

			/* make sure we are on the expected scsibus */
			if (bootbus != bus)
				return;
		}
    		
		if (sa->sa_sc_link->target == target &&
		    sa->sa_sc_link->lun == lun) {
			bootdv = dev;
			return;
		}
	}

	/*
	 * ethernet: ie,le
	 */
	else if (strcmp("ie", dev->dv_cfdata->cf_driver->cd_name) == 0 ||
	    strcmp("le", dev->dv_cfdata->cf_driver->cd_name) == 0) {
		struct confargs *ca = aux;

		if (ca->ca_paddr == bootaddr) {
			bootdv = dev;
			return;
		}
	}
}

/*
 * Returns the ID of the SCSI disk based on Motorola's CLUN/DLUN stuff
 * This handles SBC SCSI and MVME32[78].
 */
int
get_target(int *target, int *bus, int *lun)
{
	switch (bootctrllun) {
	/* built-in controller */
	case 0x00:
	/* MVME327 */
	case 0x02:
	case 0x03:
		*bus = 0;
		*target = (bootdevlun & 0x70) >> 4;
		*lun = (bootdevlun & 0x07);
		return (0);
	/* MVME328 */
	case 0x06:
	case 0x07:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
		*bus = (bootdevlun & 0x40) >> 6;
		*target = (bootdevlun & 0x38) >> 3;
		*lun = (bootdevlun & 0x07);
		return (0);
	default:
		return (ENODEV);
	}
}

struct nam2blk nam2blk[] = {
	{ "sd",		4 },
	{ "st",		7 },
	{ "rd",		9 },
	{ "vnd",	6 },
	{ NULL,		-1 }
};
@


1.47
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46 2010/11/18 21:13:19 miod Exp $ */
@


1.46
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2009/10/26 20:17:27 deraadt Exp $ */
d151 1
a151 1
		return NULL;
d161 1
a161 1
	        return NULL;
@


1.45
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.44 2009/03/01 22:08:13 miod Exp $ */
a76 1
#include <sys/dkstat.h>
@


1.44
log
@Support for MVME141 boards. Tested with both VME and VSB memory boards
(and MVME327 SCSI and MVME376 Ethernet, to provide a complete system).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2009/02/17 22:28:41 miod Exp $ */
d209 2
a210 2
	if (strncmp("sd", dev->dv_xname, 2) == 0 ||
	    strncmp("cd", dev->dv_xname, 2) == 0) {
d249 2
a250 2
	else if (strncmp("ie", dev->dv_xname, 2) == 0 ||
	    strncmp("le", dev->dv_xname, 2) == 0) {
@


1.43
log
@Add real bus_space and bus_dma to mvme68k, so that it can benefit from
recent driver work; this gives us better osiop and vs drivers, vsbic
(although currently disabled on 68060 boards until more bugs are fixed),
and the ability to boot and root off vs and vsbic.

Existing code is not modified and still uses memory mapped structures;
this might change eventually as more code gets factorized and moved to
MI land.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2008/07/21 04:35:54 todd Exp $ */
a107 6
/*
 * XXX some storage space must be allocated statically because of
 * early console init
 */
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(8)];

d121 1
a121 1
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);
d214 1
a214 1
#ifdef MVME147
d216 8
a223 2
		 * The 147 can only boot from the built-in scsi controller,
		 * and stores the scsi id as the controller number.
d225 1
a225 1
		if (cputyp == CPU_147) {
@


1.42
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2007/11/02 19:18:54 martin Exp $ */
d100 2
d104 2
a105 1
int	bootctrllun, bootdevlun, bootpart;
a116 68
void mainbus_attach(struct device *, struct device *, void *);
int  mainbus_match(struct device *, void *, void *);

struct cfattach mainbus_ca = {
	sizeof(struct device), mainbus_match, mainbus_attach
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

int
mainbus_match(parent, cf, args)
	struct device *parent;
	void *cf;
	void *args;
{
	return (1);
}

int
mainbus_print(args, bus)
	void *args;
	const char *bus;
{
	struct confargs *ca = args;

	if (ca->ca_paddr != (paddr_t)-1)
		printf(" addr 0x%x", (u_int32_t)ca->ca_paddr);
	return (UNCONF);
}

int
mainbus_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	struct cfdata *cf = child;
	struct confargs oca;

	bzero(&oca, sizeof oca);
	oca.ca_paddr = cf->cf_loc[0];
	oca.ca_vaddr = (vaddr_t)-1;
	oca.ca_ipl = -1;
	oca.ca_bustype = BUS_MAIN;
	oca.ca_name = cf->cf_driver->cd_name;
	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return (0);
	config_attach(parent, cf, &oca, mainbus_print);
	return (1);
}

void
mainbus_attach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	printf("\n");

	/* XXX
	 * should have a please-attach-first list for mainbus,
	 * to ensure that the pcc/vme2/mcc chips are attached
	 * first.
	 */

	(void)config_search(mainbus_scan, self, args);
}

d218 2
a219 1
		int target, lun;
d227 1
a227 1
			lun = 0;
d231 6
a236 2
			target = bootdevlun >> 4;
			lun = bootdevlun & 0x0f;
d257 33
@


1.41
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2007/06/15 01:19:08 deraadt Exp $ */
d324 1
@


1.40
log
@no need to include machine/disklabel.h when sys/disklabel.h is already
pulled in.
look at how doing it in one architecture gets that code copied to the
derivative architectures... amazing..
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2007/06/01 19:25:10 deraadt Exp $ */
d191 1
a191 1
	    (u_long)extiobase, (u_long)extiobase + ctob(EIOMAPSIZE),
d255 1
a255 1
	if (kva < extiobase || kva + size >= extiobase + ctob(EIOMAPSIZE))
@


1.39
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2007/06/01 19:20:46 deraadt Exp $ */
a84 1
#include <machine/disklabel.h>
@


1.38
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2007/05/04 03:44:44 deraadt Exp $ */
d200 2
d203 3
a207 1
	cold = 0;
@


1.37
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2006/11/28 16:56:50 dlg Exp $ */
d317 1
a317 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d321 1
a322 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.36
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2006/07/10 19:23:25 miod Exp $ */
d93 1
a94 1
void	setroot(void);
a96 3
int	findblkmajor(struct device *);
struct	device *getdisk(char *, int, int, dev_t *);
struct	device *parsedisk(char *, int, int, dev_t *);
a188 2
	bootdv = NULL; /* set by device drivers (if found) */

d198 4
a201 1
	setroot();
a267 277
/*
 * the rest of this file was adapted from Theo de Raadt's code in the 
 * sparc port to nuke the "options GENERIC" stuff.
 */

struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "sd",		4 },
	{ "st",		7 },
	{ "rd",		9 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	register int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot()
{
	register struct swdevt *swp;
	register struct device *dv;
	register int len, majdev, unit;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	printf("boot device: %s\n",
	    (bootdv) ? bootdv->dv_xname : "<unknown>");

	/*
	 * If 'swap generic' and we could not determine the boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, bootpart);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
#if defined(FFS)
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		break;
#endif
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

d315 32
@


1.35
log
@Accept non-page-aligned addresses and sizes in mapiodev() and unmapiodev().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2006/06/24 14:04:04 miod Exp $ */
d558 1
a558 1
		struct scsibus_attach_args *sa = aux;
@


1.34
log
@Replace physaccess() usage with pmap_kenter_cache().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2006/01/11 07:22:00 miod Exp $ */
d218 1
d224 3
a226 4
#ifdef DEBUG
	if ((pa & PGOFSET) || (size & PGOFSET))
		panic("mapiodev: unaligned");
#endif
d242 1
a242 1
	return (iova);
d251 1
d254 1
a254 3
	if ((kva & PGOFSET) || (size & PGOFSET))
	        panic("unmapiodev: unaligned");
	if (kva < extiobase || kva >= extiobase + ctob(EIOMAPSIZE))
d257 4
a260 1
	pmap_kremove(kva, size);
d263 1
a263 1
	error = extent_free(extio, kva, size, EX_NOWAIT);
@


1.33
log
@Switch to __HAVE_DEVICE_REGISTER to find the device we're booted from.
Simpler, better.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2005/12/27 18:31:09 miod Exp $ */
d89 2
d218 1
a218 1
	vaddr_t kva;
d229 1
a229 1
	    EX_NOWAIT | EX_MALLOCOK, (u_long *)&kva);
d234 9
a242 2
	physaccess(kva, pa, size, PG_RW | PG_CI);
	return (kva);
d258 2
a259 3
	physunaccess(kva, size);

	error = extent_free(extio, (u_long)kva, size, EX_NOWAIT);
d261 2
d265 1
@


1.32
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2005/12/22 22:56:31 miod Exp $ */
d89 3
d532 49
@


1.31
log
@More reasonable size for fixed extent storage.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2005/11/27 14:17:41 miod Exp $ */
a89 1
void	swapconf(void);
d199 1
a199 1
	swapconf();
a251 20
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			    (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
		}
	dumpconf();
@


1.30
log
@Nuke autoconf.h commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2005/11/24 22:43:19 miod Exp $ */
d109 1
a109 1
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16)];
@


1.29
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2004/12/25 23:02:25 miod Exp $ */
d99 5
@


1.28
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2004/07/30 22:29:48 miod Exp $ */
d107 1
a107 1
extern	void *extiobase;
d136 1
a136 1
	if (ca->ca_paddr != (void *)-1)
d150 2
a151 2
	oca.ca_paddr = (void *)cf->cf_loc[0];
	oca.ca_vaddr = (void *)-1;
d203 1
a203 1
void *
d205 1
a205 1
	void *pa;
d209 1
a209 1
	void *kva;
d211 1
a211 1
	if (size == 0)
d215 1
a215 1
	if (((int)pa & PGOFSET) || (size & PGOFSET))
d225 1
a225 1
	physaccess((vaddr_t)kva, (paddr_t)pa, size, PG_RW|PG_CI);
d231 1
a231 1
	void *kva;
d237 1
a237 1
	if (((int)kva & PGOFSET) || (size & PGOFSET))
d242 1
a242 1
	physunaccess((vaddr_t)kva, size);
@


1.27
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2004/07/02 17:34:23 miod Exp $ */
d307 1
a307 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d340 1
a340 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.26
log
@Remove unused getdevunit().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2004/05/04 15:27:19 miod Exp $ */
d97 1
a97 1
extern void init_sir(void);
d185 1
a185 1
	init_sir();
@


1.25
log
@Always ask the user for the root device if we are "swap generic" and the
boot device is not known, as other arches do.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2004/01/14 20:50:48 miod Exp $ */
a93 1
struct	device *getdevunit(char *, int);
a545 28
}

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(name, unit)
	char *name;
	int unit;
{
	struct device *dev = alldevs.tqh_first;
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = dev->dv_list.tqe_next) == NULL)
			return NULL;
	}
	return dev;
@


1.24
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2003/08/23 22:52:30 deraadt Exp $ */
d389 7
@


1.23
log
@unify with mvme88k; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2003/06/02 23:27:50 millert Exp $ */
d118 1
a118 1
	NULL, "mainbus", DV_DULL, 0
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2003/06/02 05:09:14 deraadt Exp $ */
d263 1
a263 1
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
d282 1
a282 1
   { "rd",     9 },
d336 1
a336 1
	if (c >= 'a' && c <= 'h') {
d388 1
a388 1
		(bootdv) ? bootdv->dv_xname : "<unknown>");
d406 1
a406 1
				if (dv != NULL) {
d413 1
a413 1
			if (dv != NULL) {
a462 1

a463 1

a488 1

a489 1

@


1.21
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2003/04/06 18:54:19 ho Exp $ */
d43 1
a43 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2003/02/24 22:13:39 miod Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.19
log
@Use MAKEDISKDEV and DISKUNIT macros instead of rolling our own inline version
of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2002/04/27 23:21:05 miod Exp $ */
d410 1
a410 1
				strcpy(buf, bootdv->dv_xname);
d569 1
a569 1
	sprintf(num, "%d", unit);
d574 2
a575 2
	strcpy(fullname, name);
	strcat(fullname, num);
@


1.18
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2002/03/14 01:26:38 millert Exp $ */
d340 1
a340 1
	int majdev, mindev, part;
d356 1
d359 1
a359 2
			mindev = (dv->dv_unit << PARTITIONSHIFT) + part;
			*devp = makedev(majdev, mindev);
d389 1
a389 1
	register int len, majdev, mindev;
d405 2
a406 3
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? 'a' : ' ');
d440 2
a441 2
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
d450 2
a451 2
					nswapdev = makedev(major(nrootdev),
					    (minor(nrootdev) & ~ PARTITIONMASK) | 1);
d489 4
a492 5
			int part = bootpart;
			mindev = (bootdv->dv_unit << PARTITIONSHIFT) + part;
			rootdev = makedev(majdev, mindev);
			nswapdev = dumpdev = makedev(major(rootdev),
			    (minor(rootdev) & ~ PARTITIONMASK) | 1);
d522 1
a522 1
		mindev = minor(rootdev);
d524 1
a524 1
		    (mindev & PARTITIONMASK) + 'a');
d533 1
a533 1
	 * XXX: What is this doing?
a534 1
	mindev &= ~PARTITIONMASK;
d538 1
a538 1
		    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2002/01/16 23:19:31 miod Exp $ */
d99 7
d107 3
a109 1
void	setroot(void);
d236 1
a236 1
	physaccess(kva, pa, size, PG_RW|PG_CI);
d253 1
a253 1
	physunaccess(kva, size);
d264 1
d295 1
a295 1
static int
d308 1
a308 1
static struct device *
@


1.16
log
@Replace resource maps with extents. 3 files left to go...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/12/10 00:58:04 miod Exp $ */
d99 2
a100 2
struct	device *parsedisk __P((char *, int, int, dev_t *));
void	setroot __P((void));
d111 2
a112 2
void mainbus_attach __P((struct device *, struct device *, void *));
int  mainbus_match __P((struct device *, void *, void *));
@


1.15
log
@No need to include <sys/dmap.h> and define related variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/09/19 21:32:19 miod Exp $ */
a81 2
#undef TRY_EXTENT

a83 1
#ifdef TRY_EXTENT
d85 1
a85 3
#else
#include <sys/map.h>
#endif
d102 7
a108 7
/* XXX must be allocated statically because of early console init */
#ifdef TRY_EXTENT
static char iomap_space[EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16)];
struct extent *iomap_extent;
#else
struct map extiomap[EIOMAPSIZE/16];
#endif
d189 3
a191 10
#ifdef TRY_EXTENT
	iomap_extent = extent_create("iomap", &iomap_space,
	    iomap_space  + EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16),
	    M_DEVBUF, &iomap_space, EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16),
	    EX_NOWAIT);
	if (iomap_extent == NULL)
		panic("cpu_configure: extent_create failed");
#else
	rminit(extiomap, (long)EIOMAPSIZE, (long)1, "extio", EIOMAPSIZE/16);
#endif
d210 1
a210 1
	int ix, npf, offset;
a211 3
#ifdef TRY_EXTENT
	int error;
#endif
d213 2
a214 3
	size = roundup(size, NBPG);
	offset = (int)pa & PGOFSET;
	pa = (void *)((int)pa & ~PGOFSET);
d218 1
a218 1
	        panic("mapiodev: unaligned");
d220 7
a226 10
	npf = btoc(size);
#ifdef TRY_EXTENT
	error = extent_alloc(iomap_extent, npf, EX_NOALIGN, 0, EX_NOBOUNDARY,
	    EX_NOWAIT, &ix);
#else
	ix = rmalloc(extiomap, npf);
#endif
	if (ix == 0)
	        return (0);
	kva = extiobase + ctob(ix-1);
d228 1
a228 1
	return (kva + offset);
d236 1
a236 1
	int ix;
d245 5
a249 2
	ix = btoc(kva - extiobase) + 1;
	rmfree(extiomap, btoc(size), ix);
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2002/01/16 23:19:31 miod Exp $ */
d82 2
d86 1
d88 3
a90 1
#include <sys/malloc.h>
d107 7
a113 7
/*
 * XXX some storage space must be allocated statically because of
 * early console init
 */
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16)];

struct	extent *extio;
d194 10
a203 3
	extio = extent_create("extio",
	    (u_long)extiobase, (u_long)extiobase + ctob(EIOMAPSIZE),
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);
d222 3
d226 1
a226 1
	void *kva;
d228 3
a230 2
	if (size == 0)
		return NULL;
d234 8
a241 1
		panic("mapiodev: unaligned");
d243 3
a245 7

	error = extent_alloc(extio, size, EX_NOALIGN, 0, EX_NOBOUNDARY,
	    EX_NOWAIT | EX_MALLOCOK, (u_long *)&kva);

	if (error != 0)
	        return NULL;

d247 1
a247 1
	return (kva);
d255 1
a255 1
	int error;
d264 2
a265 5

	error = extent_free(extio, (u_long)kva, size, EX_NOWAIT);

	if (error != 0)
		printf("unmapiodev: extent_free failed\n");
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15.2.1 2002/01/31 22:55:15 niklas Exp $ */
d99 2
a100 11
void	setroot(void);
void	swapconf(void);
int	mainbus_print(void *, const char *);
int	mainbus_scan(struct device *, void *, void *);
int	findblkmajor(struct device *);
struct	device *getdevunit(char *, int);
struct	device *getdisk(char *, int, int, dev_t *);
struct	device *parsedisk(char *, int, int, dev_t *);

extern void init_sir(void);
extern void dumpconf(void);
d111 2
a112 2
void mainbus_attach(struct device *, struct device *, void *);
int  mainbus_match(struct device *, void *, void *);
d227 1
a227 1
	physaccess((vaddr_t)kva, (paddr_t)pa, size, PG_RW|PG_CI);
d244 1
a244 1
	physunaccess((vaddr_t)kva, size);
a254 1
void
d285 1
a285 1
int
d298 1
a298 1
struct device *
@


1.15.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d340 1
a340 1
	int majdev, unit, part;
a355 1
			unit = dv->dv_unit;
d358 2
a359 1
			*devp = MAKEDISKDEV(majdev, unit, part);
d389 1
a389 1
	register int len, majdev, unit;
d405 3
a407 2
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
d411 1
a411 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d441 2
a442 2
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
d451 2
a452 2
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
d490 5
a494 4
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, bootpart);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
d524 1
a524 1
		unit = DISKUNIT(rootdev);
d526 1
a526 1
		    DISKPART(rootdev) + 'a');
d535 1
a535 1
	 * Make the swap partition on the root drive the primary swap.
d537 1
d541 1
a541 1
		    unit == DISKUNIT(swp->sw_dev)) {
d572 1
a572 1
	snprintf(num, sizeof num, "%d", unit);
d577 2
a578 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
@


1.14
log
@Now is a good time to commit this cosmetic maxpartition-related change...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/06/25 00:43:13 mickey Exp $ */
d82 2
d86 3
d90 1
a93 1
#include <sys/dmap.h>
d108 6
a113 1
struct	map extiomap[EIOMAPSIZE/16];
d194 8
d203 1
d224 3
d237 4
d242 1
@


1.13
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/05/05 22:33:57 art Exp $ */
d300 1
a300 1
				printf(" %s[a-h]", dv->dv_xname);
@


1.12
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2000/01/24 05:20:54 smurph Exp $ */
a97 7

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
extern int cold;		/* if 1, still working on cold-start */
@


1.11
log
@Fixed bug in disksubr.c relating to disklabels.  Added MVME376 support to le.  Made installboot insert M68K for volume ID, not M88K.  Correctly documented installboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 1996/11/23 21:46:04 kstailey Exp $ */
d77 1
a77 1
 * Configure() is called at boot time.  Available
d184 2
a185 1
configure()
@


1.11.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2000/01/24 05:20:54 smurph Exp $ */
d77 1
a77 1
 * cpu_configure() is called at boot time.  Available
d99 7
d184 1
a184 2
void
cpu_configure()
@


1.11.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11.2.1 2001/07/04 10:19:33 niklas Exp $ */
d300 1
a300 1
				printf(" %s[a-p]", dv->dv_xname);
@


1.11.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d84 1
a84 2
#include <sys/extent.h>
#include <sys/malloc.h>
d88 1
d102 2
a103 7
/*
 * XXX some storage space must be allocated statically because of
 * early console init
 */
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16)];

struct	extent *extio;
d184 1
a184 3
	extio = extent_create("extio",
	    (u_long)extiobase, (u_long)extiobase + ctob(EIOMAPSIZE),
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);
d203 1
a203 1
	int error;
d206 3
a208 2
	if (size == 0)
		return NULL;
d212 1
a212 1
		panic("mapiodev: unaligned");
d214 5
a218 7

	error = extent_alloc(extio, size, EX_NOALIGN, 0, EX_NOBOUNDARY,
	    EX_NOWAIT | EX_MALLOCOK, (u_long *)&kva);

	if (error != 0)
	        return NULL;

d220 1
a220 1
	return (kva);
d228 1
a228 1
	int error;
d237 2
a238 5

	error = extent_free(extio, (u_long)kva, size, EX_NOWAIT);

	if (error != 0)
		printf("unmapiodev: extent_free failed\n");
@


1.11.2.4
log
@Merge in -current from about a week ago
@
text
@d99 2
a100 2
struct	device *parsedisk(char *, int, int, dev_t *);
void	setroot(void);
d111 2
a112 2
void mainbus_attach(struct device *, struct device *, void *);
int  mainbus_match(struct device *, void *, void *);
@


1.11.2.5
log
@Sync the SMP branch with 3.3
@
text
@d99 1
a100 10
void	swapconf(void);
int	mainbus_print(void *, const char *);
int	mainbus_scan(struct device *, void *, void *);
int	findblkmajor(struct device *);
struct	device *getdevunit(char *, int);
struct	device *getdisk(char *, int, int, dev_t *);
struct	device *parsedisk(char *, int, int, dev_t *);

extern void init_sir(void);
extern void dumpconf(void);
d227 1
a227 1
	physaccess((vaddr_t)kva, (paddr_t)pa, size, PG_RW|PG_CI);
d244 1
a244 1
	physunaccess((vaddr_t)kva, size);
a254 1
void
d285 1
a285 1
int
d298 1
a298 1
struct device *
d330 1
a330 1
	int majdev, unit, part;
a345 1
			unit = dv->dv_unit;
d348 2
a349 1
			*devp = MAKEDISKDEV(majdev, unit, part);
d379 1
a379 1
	register int len, majdev, unit;
d395 3
a397 2
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
d431 2
a432 2
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
d441 2
a442 2
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
d480 5
a484 4
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, bootpart);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
d514 1
a514 1
		unit = DISKUNIT(rootdev);
d516 1
a516 1
		    DISKPART(rootdev) + 'a');
d525 1
a525 1
	 * Make the swap partition on the root drive the primary swap.
d527 1
d531 1
a531 1
		    unit == DISKUNIT(swp->sw_dev)) {
@


1.11.2.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11.2.5 2003/03/27 23:32:17 niklas Exp $ */
d410 1
a410 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d569 1
a569 1
	snprintf(num, sizeof num, "%d", unit);
d574 2
a575 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
@


1.11.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11.2.6 2003/05/13 19:41:06 ho Exp $ */
d14 6
d49 5
a53 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d118 1
a118 1
	NULL, "mainbus", DV_DULL
d263 1
a263 1
			    (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
d282 1
a282 1
	{ "rd",		9 },
d336 1
a336 1
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
d388 1
a388 1
	    (bootdv) ? bootdv->dv_xname : "<unknown>");
d406 1
a406 1
				if (dv) {
d413 1
a413 1
			if (dv) {
d463 1
d465 1
d491 1
d493 1
@


1.11.2.9
log
@Merge with the trunk
@
text
@a389 7
	/*
	 * If 'swap generic' and we could not determine the boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

@


1.10
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 1996/11/06 01:45:34 deraadt Exp $ */
d276 2
a277 1
	{ "st",		6 },
@


1.9
log
@use dk_mountroot
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 1996/06/16 10:34:37 deraadt Exp $ */
d136 1
a136 1
	char *bus;
@


1.8
log
@use getsn() instead of private getstr()
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 1996/06/11 10:15:49 deraadt Exp $ */
a375 1
	extern int (*mountroot) __P((void *));
a378 4
	extern int nfs_mountroot __P((void *));
#endif
#if defined(FFS)
	extern int ffs_mountroot __P((void *));
d506 1
a506 1
		mountroot = ffs_mountroot;
@


1.7
log
@use void * for pa/va instead of caddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a105 1
static	int getstr __P((char *, int));
d398 1
a398 1
			len = getstr(buf, sizeof(buf));
d433 1
a433 1
			len = getstr(buf, sizeof(buf));
a546 47

static int
getstr(cp, size)
	register char *cp;
	register int size;
{
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}

@


1.6
log
@new generic boot
@
text
@d112 1
a112 1
extern	char *extiobase;
d142 1
a142 1
		printf(" addr 0x%x", ca->ca_paddr);
d155 2
a156 2
	oca.ca_paddr = (caddr_t)cf->cf_loc[0];
	oca.ca_vaddr = (caddr_t)-1;
d205 1
a205 1
caddr_t
d207 1
a207 1
	caddr_t pa;
d211 1
a211 1
	caddr_t kva;
d215 1
a215 1
	pa = (caddr_t)((int)pa & ~PGOFSET);
d232 1
a232 1
	caddr_t kva;
@


1.5
log
@cfattach/cfdriver split; config_*() function retval change
@
text
@d95 1
d106 4
d187 2
d267 4
a270 3
u_long	bootdev;

#define	PARTITIONMASK	(MAXPARTITIONS-1)
d272 1
a272 1
struct bdevnam {
d275 3
a277 4
} bdevnam[] = {
	{ "sd", 4 },
	{ "cd", 6 },
	{ "xd", 10 },
d280 78
a357 10
char *
blktonam(blk)
	int blk;
{
	int i;

	for (i = 0; i < sizeof(bdevnam)/sizeof(bdevnam[0]); i++)
		if (bdevnam[i].maj == blk)
			return (bdevnam[i].name);
	return ("??");
d364 4
d369 1
d372 7
a378 2
	int  majdev, mindev, nswapdev;
	extern int (*mountroot)();
d381 1
a381 1
	extern int nfs_mountroot();
d384 1
a384 1
	extern int ffs_mountroot();
a385 2
	int boottype = DV_DISK;
	int tmp;
d387 2
a388 11
#ifdef DEBUG
	printf("bootdev 0x%08x boothowto 0x%08x\n", bootdev, boothowto);
#endif

	/*
	 * ignore DFLTROOT in the `swap generic' case.
	 */
	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
		if (mountroot)
			return;
d391 8
a398 15
#if 0
		char *devname;

		majdev = B_TYPE(bootdev);
		mindev = B_UNIT(bootdev);
		name = searchname(majdev);
		while (mindev == 0 
			if (bootdv && bootdv->dv_class == DV_DISK)
				printf("root device (default %sa)? ",
				    name);
			else if (bootdv)
				printf("root device (default %s)? ",
				    name);
			else
				printf("root device ? ");
d400 1
a400 3
			if (len == 0) {
				if (!bootdv)
					continue;
a418 1
		/*XXXX remember to set boottype if we are a network device!! */
a422 1
		 * XXX: IS THIS STILL TRUE?
d428 6
a433 8
			if (bootdv && bootdv->dv_class == DV_DISK)
				printf("swap device (default %sb)? ",
					bootdv->dv_xname);
			else if (bootdv)
				printf("swap device (default %s)? ",
					bootdv->dv_xname);
			else
				printf("swap device ? ");
d435 1
a435 3
			if (len == 0) {
				if (!bootdv)
					continue;
d444 5
d463 2
a464 5
		/* swdevt[1].sw_dev = NODEV; */
		/* XXX should ask for devices to boot from */
#else
		panic("RB_ASKNAME not implimented");
#endif
d466 1
d468 1
a468 6
		 * `swap generic': Use the device the boot program
		 * told us to use. This is a bit messy, since the ROM
		 * doesn't give us a standard dev_t.
		 *    B_TYPE: 0 = disk, 1 = net
		 *    B_ADAPTER: major # of disk device driver XXX
		 *    B_UNIT: disk unit number
d470 5
a474 1
		if (B_TYPE(bootdev) == 0) {
d477 2
a478 2
			 * Assume that we are supposed to put root on
			 * partition a, and swap on partition b.
d480 2
a481 6
			switch (B_ADAPTOR(bootdev)) {
			case 0:
				majdev = 4;
				break;
			}
			mindev = B_UNIT(bootdev) << PARTITIONSHIFT;
a487 1
			 * XXX we don't know which network device...
a489 1
			boottype = DV_IFNET;
d492 2
a493 1
		/* swdevt[1].sw_dev = NODEV; */
d495 1
d503 1
a503 1
	switch (boottype) {
d507 2
a508 2
		nfsbootdevname = NULL;		/* XXX don't know it */
		break;
d515 1
a515 2
		printf("root on %s%d%c\n", blktonam(majdev),
		    mindev >> PARTITIONSHIFT,
d521 99
a619 1
		break;
d621 1
@


1.4
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@d1 1
a1 1
/*	$Id: autoconf.c,v 1.3 1995/11/30 22:53:55 deraadt Exp $ */
d112 6
a117 3
struct cfdriver mainbuscd = {
	NULL, "mainbus", mainbus_match, mainbus_attach,
	DV_DULL, sizeof(struct device), 0
d155 1
a155 1
	if ((*cf->cf_driver->cd_match)(parent, cf, &oca) == 0)
d186 1
a186 1
	if (!config_rootfound("mainbus", NULL))
@


1.3
log
@do not truncate swdevt[] ever
@
text
@d1 1
a1 1
/*	$Id: autoconf.c,v 1.2 1995/11/07 08:50:15 deraadt Exp $ */
a103 1
int dkn;			/* number of iostat dk numbers assigned so far */
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d397 1
a397 1
		swdevt[1].sw_dev = NODEV;
d435 1
a435 1
		swdevt[1].sw_dev = NODEV;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.1.1.1 1995/07/25 23:11:55 chuck Exp $ */
d4 29
d91 1
d94 1
a96 1
#include <mvme68k/mvme68k/isr.h>
d103 6
a108 4
int	cold;			/* if 1, still working on cold-start */
int	dkn;			/* number of iostat dk numbers assigned so far */
int	cpuspeed = MHZ_16;	/* relative cpu speed */
struct	isr isrqueue[NISR];
a112 4
struct mainbus_softc {
	struct device sc_dev;
};

d115 1
a115 1
	DV_DULL, sizeof(struct mainbus_softc), 0
d127 32
d166 7
a172 2
	while (config_found(self, NULL, NULL))
		;
d174 1
d181 2
a182 1
	isrinit();
a186 5
#if GENERIC
	if ((boothowto & RB_ASKNAME) == 0)
	    setroot();
	setconf();
#else
a187 1
#endif
d192 8
a199 1
isrinit()
d201 2
a202 1
	register int i;
d204 15
a218 2
	for (i = 0; i < NISR; i++)
		isrqueue[i].isr_forw = isrqueue[i].isr_back = &isrqueue[i];
d222 3
a224 2
isrlink(isr)
	register struct isr *isr;
d226 1
a226 1
	int i = ISRIPL(isr->isr_ipl);
d228 9
a236 5
	if (i < 0 || i >= NISR) {
		printf("bad IPL %d\n", i);
		panic("configure");
	}
	insque(isr, isrqueue[i].isr_back);
d258 3
a260 2
#define	DOSWAP			/* Change swdevt and dumpdev too */
u_long	bootdev;		/* should be dev_t, but not until 32 bits */
d262 7
a268 6
static	char devname[][2] = {
	0,0,		/* 0 = xx */
	's','d',	/* 1 = sd */
	'w','d',	/* 2 = wd */
	0,0,		/* 3 = sw */
	'i','d',	/* 4 = id */
d271 11
a281 2
#define	PARTITIONMASK	0x7
#define	PARTITIONSHIFT	3
d290 15
a304 5
	register struct hp_ctlr *hc;
	register struct hp_device *hd;
	int  majdev, mindev, unit, part, controller, adaptor;
	dev_t temp, orootdev;
	struct swdevt *swp;
d306 3
d311 42
a352 25
		return;
	majdev = (bootdev >> B_TYPESHIFT) & B_TYPEMASK;
	if (majdev > sizeof(devname) / sizeof(devname[0]))
		return;
	adaptor = (bootdev >> B_ADAPTORSHIFT) & B_ADAPTORMASK;
	part = (bootdev >> B_PARTITIONSHIFT) & B_PARTITIONMASK;
	unit = (bootdev >> B_UNITSHIFT) & B_UNITMASK;
	/*
	 * First, find the controller type which supports this device.
	 * Next, find the controller of that type corresponding to
	 * the adaptor number.
	 * Finally, find the device in question attached to that controller.
	 */
	/*
	 * Form a new rootdev
	 */
	mindev = (unit << PARTITIONSHIFT) + part;
	orootdev = rootdev;
	rootdev = makedev(majdev, mindev);
	/*
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
	 */
	if (rootdev == orootdev)
		return;
d354 38
a391 13
	printf("Changing root device to %c%c%d%c\n",
		devname[majdev][0], devname[majdev][1],
		mindev >> PARTITIONSHIFT, part + 'a');

#ifdef DOSWAP
	mindev &= ~PARTITIONMASK;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
d393 49
a442 2
	if (swp->sw_dev == NODEV)
		return;
d444 16
a459 6
	/*
	 * If dumpdev was the same as the old primary swap
	 * device, move it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
d461 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.9 1994/10/26 07:25:21 cgd Exp $ */
a61 1
#include <sys/disklabel.h>
a63 1
#include <machine/autoconf.h>
d66 1
d73 4
a76 6
extern int cold;		/* if 1, still working on cold-start */
int dkn;			/* number of iostat dk numbers assigned so far */

/* XXX must be allocated statically because of early console init */
struct	map extiomap[EIOMAPSIZE/16];
extern	char *extiobase;
d81 4
d87 1
a87 1
	DV_DULL, sizeof(struct device), 0
a98 32
int
mainbus_print(args, bus)
	void *args;
	char *bus;
{
	struct confargs *ca = args;

	if (ca->ca_paddr != (void *)-1)
		printf(" addr 0x%x", ca->ca_paddr);
	return (UNCONF);
}

int
mainbus_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	struct cfdata *cf = child;
	struct confargs oca;

	bzero(&oca, sizeof oca);
	oca.ca_paddr = (caddr_t)cf->cf_loc[0];
	oca.ca_vaddr = (caddr_t)-1;
	oca.ca_ipl = -1;
	oca.ca_bustype = BUS_MAIN;
	oca.ca_name = cf->cf_driver->cd_name;
	if ((*cf->cf_driver->cd_match)(parent, cf, &oca) == 0)
		return (0);
	config_attach(parent, cf, &oca, mainbus_print);
	return (1);
}

d106 2
a107 7
	/* XXX
	 * should have a please-attach-first list for mainbus,
	 * to ensure that the pcc/vme2/mcc chips are attached
	 * first.
	 */

	(void)config_search(mainbus_scan, self, args);
a108 1

d115 1
a115 2

	rminit(extiomap, (long)EIOMAPSIZE, (long)1, "extio", EIOMAPSIZE/16);
d120 5
d126 1
d131 1
a131 8
/*
 * Allocate/deallocate a cache-inhibited range of kernel virtual address
 * space mapping the indicated physical address range [pa - pa+size)
 */
caddr_t
mapiodev(pa, size)
	caddr_t pa;
	int size;
d133 1
a133 2
	int ix, npf, offset;
	caddr_t kva;
d135 2
a136 15
	size = roundup(size, NBPG);
	offset = (int)pa & PGOFSET;
	pa = (caddr_t)((int)pa & ~PGOFSET);

#ifdef DEBUG
	if (((int)pa & PGOFSET) || (size & PGOFSET))
	        panic("mapiodev: unaligned");
#endif
	npf = btoc(size);
	ix = rmalloc(extiomap, npf);
	if (ix == 0)
	        return (0);
	kva = extiobase + ctob(ix-1);
	physaccess(kva, pa, size, PG_RW|PG_CI);
	return (kva + offset);
d140 2
a141 3
unmapiodev(kva, size)
	caddr_t kva;
	int size;
d143 1
a143 1
	int ix;
d145 5
a149 9
#ifdef DEBUG
	if (((int)kva & PGOFSET) || (size & PGOFSET))
	        panic("unmapiodev: unaligned");
	if (kva < extiobase || kva >= extiobase + ctob(EIOMAPSIZE))
	        panic("unmapiodev: bad address");
#endif
	physunaccess(kva, size);
	ix = btoc(kva - extiobase) + 1;
	rmfree(extiomap, btoc(size), ix);
d171 2
a172 3
u_long	bootdev;

#define	PARTITIONMASK	(MAXPARTITIONS-1)
d174 6
a179 7
struct bdevnam {
	char *name;
	int maj;
} bdevnam[] = {
	{ "sd", 4 },
	{ "cd", 6 },
	{ "xd", 10 },
d182 2
a183 11
char *
blktonam(blk)
	int blk;
{
	int i;

	for (i = 0; i < sizeof(bdevnam)/sizeof(bdevnam[0]); i++)
		if (bdevnam[i].maj == blk)
			return (bdevnam[i].name);
	return ("??");
}
d192 5
a196 15
	int  majdev, mindev, nswapdev;
	extern int (*mountroot)();
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
	extern int nfs_mountroot();
#endif
#if defined(FFS)
	extern int ffs_mountroot();
#endif
	int boottype = DV_DISK;
	int tmp;

#ifdef DEBUG
	printf("bootdev 0x%08x boothowto 0x%08x\n", bootdev, boothowto);
#endif
d198 21
d220 2
a221 1
	 * ignore DFLTROOT in the `swap generic' case.
d223 2
a224 4
	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
		if (mountroot)
			return;
d226 13
a238 37
	if (boothowto & RB_ASKNAME) {
#if 0
		char *devname;

		majdev = B_TYPE(bootdev);
		mindev = B_UNIT(bootdev);
		name = searchname(majdev);
		while (mindev == 0 
			if (bootdv && bootdv->dv_class == DV_DISK)
				printf("root device (default %sa)? ",
				    name);
			else if (bootdv)
				printf("root device (default %s)? ",
				    name);
			else
				printf("root device ? ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				if (!bootdv)
					continue;
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
d240 2
a241 89
		/*XXXX remember to set boottype if we are a network device!! */

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 * XXX: IS THIS STILL TRUE?
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			if (bootdv && bootdv->dv_class == DV_DISK)
				printf("swap device (default %sb)? ",
					bootdv->dv_xname);
			else if (bootdv)
				printf("swap device (default %s)? ",
					bootdv->dv_xname);
			else
				printf("swap device ? ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				if (!bootdv)
					continue;
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = makedev(major(nrootdev),
					    (minor(nrootdev) & ~ PARTITIONMASK) | 1);
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
		/* XXX should ask for devices to boot from */
#else
		panic("RB_ASKNAME not implimented");
#endif
	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the boot program
		 * told us to use. This is a bit messy, since the ROM
		 * doesn't give us a standard dev_t.
		 *    B_TYPE: 0 = disk, 1 = net
		 *    B_ADAPTER: major # of disk device driver XXX
		 *    B_UNIT: disk unit number
		 */
		if (B_TYPE(bootdev) == 0) {
			/*
			 * Root and swap are on a disk.
			 * Assume that we are supposed to put root on
			 * partition a, and swap on partition b.
			 */
			switch (B_ADAPTOR(bootdev)) {
			case 0:
				majdev = 4;
				break;
			}
			mindev = B_UNIT(bootdev) << PARTITIONSHIFT;
			rootdev = makedev(majdev, mindev);
			nswapdev = dumpdev = makedev(major(rootdev),
			    (minor(rootdev) & ~ PARTITIONMASK) | 1);
		} else {
			/*
			 * Root and swap are on a net.
			 * XXX we don't know which network device...
			 */
			nswapdev = dumpdev = NODEV;
			boottype = DV_IFNET;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
a242 1
	}
d244 6
a249 16
	switch (boottype) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = NULL;		/* XXX don't know it */
		break;
#endif
#if defined(FFS)
	case DV_DISK:
		mountroot = ffs_mountroot;
		majdev = major(rootdev);
		mindev = minor(rootdev);
		printf("root on %s%d%c\n", blktonam(majdev),
		    mindev >> PARTITIONSHIFT,
		    (mindev & PARTITIONMASK) + 'a');
		break;
a250 4
	default:
		printf("can't figure root, hope your kernel is right\n");
		break;
	}
@
