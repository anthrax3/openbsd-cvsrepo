head	1.79;
access;
symbols
	OPENBSD_5_5:1.78.0.4
	OPENBSD_5_5_BASE:1.78
	OPENBSD_5_4:1.77.0.4
	OPENBSD_5_4_BASE:1.77
	OPENBSD_5_3:1.77.0.2
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.75.0.4
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.75
	OPENBSD_5_1:1.75.0.2
	OPENBSD_5_0:1.74.0.2
	OPENBSD_5_0_BASE:1.74
	OPENBSD_4_9:1.71.0.2
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.70.0.2
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.68.0.4
	OPENBSD_4_6_BASE:1.68
	OPENBSD_4_5:1.67.0.8
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.67.0.6
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.67.0.4
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.67.0.2
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.64.0.2
	OPENBSD_4_1_BASE:1.64
	OPENBSD_4_0:1.63.0.2
	OPENBSD_4_0_BASE:1.63
	OPENBSD_3_9:1.62.0.2
	OPENBSD_3_9_BASE:1.62
	OPENBSD_3_8:1.59.0.2
	OPENBSD_3_8_BASE:1.59
	OPENBSD_3_7:1.57.0.2
	OPENBSD_3_7_BASE:1.57
	OPENBSD_3_6:1.55.0.2
	OPENBSD_3_6_BASE:1.55
	SMP_SYNC_A:1.54
	SMP_SYNC_B:1.54
	OPENBSD_3_5:1.52.0.2
	OPENBSD_3_5_BASE:1.52
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50
	UBC_SYNC_A:1.48
	OPENBSD_3_3:1.48.0.2
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.46.0.2
	OPENBSD_3_2_BASE:1.46
	OPENBSD_3_1:1.42.0.2
	OPENBSD_3_1_BASE:1.42
	UBC_SYNC_B:1.46
	UBC:1.41.0.2
	UBC_BASE:1.41
	OPENBSD_3_0:1.35.0.2
	OPENBSD_3_0_BASE:1.35
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.23.0.4
	OPENBSD_2_7_BASE:1.23
	SMP:1.23.0.2
	SMP_BASE:1.23
	kame_19991208:1.22
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.19.0.6
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.4
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.18.0.4
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.79
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.78;

1.78
date	2013.11.02.13.49.22;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2012.12.31.06.46.13;	author guenther;	state Exp;
branches;
next	1.76;

1.76
date	2012.08.07.05.16.54;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2011.11.16.20.50.19;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	2010.07.02.19.57.14;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2010.06.29.20.30.32;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.15.20.40.25;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.15.13.46.22;	author martin;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.01.09.29.27;	author art;	state Exp;
branches;
next	1.65;

1.65
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2007.01.28.16.38.48;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2006.06.11.20.46.50;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2006.01.30.21.26.19;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2005.11.12.23.14.03;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.31.15.38.12;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.01.09.55.49;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2004.12.06.20.12.25;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2004.07.30.22.29.49;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.18.20.19.52;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2004.04.18.20.02.08;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.15.17.22.27;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.20.00.34.32;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.02.23.27.51;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2002.12.09.00.45.37;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.23.03.03.15;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.16.21.11.16;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.28.14.47.54;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2002.04.27.23.21.06;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.25.17.15.20;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.14.09.15.19;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.25.11.37.26;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.27.04.19.17;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.26.21.35.43;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.08.08.09.09;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.05.21.26.39;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.05.20.56.45;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.05.20.39.40;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.12.07.38.32;	author smurph;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.10.18.15.39;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.07.15.49.40;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.06.03.21.43;	author smurph;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	99.09.27.20.30.32;	author smurph;	state Exp;
branches;
next	1.21;

1.21
date	99.09.03.18.01.23;	author art;	state Exp;
branches;
next	1.20;

1.20
date	99.06.06.15.38.34;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.04.03.03.47.42;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.04.08.13.55.57;	author briggs;	state Exp;
branches;
next	1.17;

1.17
date	97.04.08.05.14.52;	author briggs;	state Exp;
branches;
next	1.16;

1.16
date	97.03.31.00.24.16;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.02.24.13.00.54;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.02.21.06.07.27;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.02.04.17.23.20;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.02.04.12.29.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.02.04.02.49.24;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.02.02.00.43.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.27.22.48.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.24.20.29.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.11.10.07.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.28.10.59.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.01.12.16.45.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.23.13.14.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.07.08.50.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.12.19.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.13;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.42.53;	author deraadt;	state Exp;
branches;
next	;

1.23.2.1
date	2001.04.18.16.10.41;	author niklas;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2001.07.04.10.19.42;	author niklas;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2001.10.31.03.01.17;	author nate;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.23.2.5;

1.23.2.5
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.23.2.6;

1.23.2.6
date	2002.03.06.01.07.00;	author niklas;	state Exp;
branches;
next	1.23.2.7;

1.23.2.7
date	2002.03.28.10.34.06;	author niklas;	state Exp;
branches;
next	1.23.2.8;

1.23.2.8
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.23.2.9;

1.23.2.9
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.23.2.10;

1.23.2.10
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	1.23.2.11;

1.23.2.11
date	2004.06.05.23.10.53;	author niklas;	state Exp;
branches;
next	;

1.41.2.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2003.05.19.21.45.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.79
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: trap.c,v 1.78 2013/11/02 13:49:22 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1999 Steve Murphree, Jr. (68060 support)
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: trap.c 1.37 92/12/20$
 *
 *	@@(#)trap.c	8.5 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/acct.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/resourcevar.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
#include <sys/syslog.h>
#include <sys/user.h>

#include <machine/db_machdep.h>
#include <machine/cpu.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/trap.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>

int	astpending;
int	want_resched;

char  *trap_type[] = {
	"Bus error",
	"Address error",
	"Illegal instruction",
	"Zero divide",
	"CHK instruction",
	"TRAPV instruction",
	"Privilege violation",
	"Trace trap",
	"MMU fault",
	"SSIR trap",
	"Format error",
	"68881 exception",
	"Coprocessor violation",
	"Async system trap"
};
int   trap_types = sizeof trap_type / sizeof trap_type[0];

/*
 * Size of various exception stack frames (minus the standard 8 bytes)
 */
short exframesize[] = {
	FMT0SIZE,	/* type 0 - normal (68020/030/040/060) */
	FMT1SIZE,	/* type 1 - throwaway (68020/030/040) */
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040/060) */
	FMT3SIZE,	/* type 3 - FP post-instruction (68040/060) */
	FMT4SIZE,	/* type 4 - access error/fp disabled (68060) */
	-1, -1,		/* type 5-6 - undefined */
	FMT7SIZE,	/* type 7 - access error (68040) */
	58,			/* type 8 - bus fault (68010) */
	FMT9SIZE,	/* type 9 - coprocessor mid-instruction (68020/030) */
	FMTASIZE,	/* type A - short bus fault (68020/030) */
	FMTBSIZE,	/* type B - long bus fault (68020/030) */
	-1, -1, -1, -1	/* type C-F - undefined */
};


#if defined(M68040) || defined(M68060)
#define KDFAULT(c)    (mmutype == MMU_68060 ? ((c) & FSLW_TM_SV) : \
             mmutype == MMU_68040 ? ((c) & SSW4_TMMASK) == SSW4_TMKD : \
			    ((c) & (SSW_DF|FC_SUPERD)) == (SSW_DF|FC_SUPERD))
#define WRFAULT(c)    (mmutype == MMU_68060 ? ((c) & FSLW_RW_W) : \
             mmutype == MMU_68040 ? ((c) & SSW4_RW) == 0 : \
			    ((c) & (SSW_DF|SSW_RW)) == SSW_DF)
#else
#define KDFAULT(c)	(((c) & (SSW_DF|SSW_FCMASK)) == (SSW_DF|FC_SUPERD))
#define WRFAULT(c)	(((c) & (SSW_DF|SSW_RW)) == SSW_DF)
#endif

#ifdef DEBUG
int mmudebug = 0;
int mmupid = -1;
#define MDB_FOLLOW	1
#define MDB_WBFOLLOW	2
#define MDB_WBFAILED	4
#define MDB_ISPID(p)	(p) == mmupid
#endif

void trap(int, u_int, u_int, struct frame);
void syscall(register_t, struct frame);
void init_intrs(void);
void hardintr(int, int, void *);
int writeback(struct frame *);
void wb_userret(struct proc *, struct frame *);

#ifdef M68040
/*
 * Handle writeback completion on 68040.
 */
void
wb_userret(struct proc *p, struct frame *fp)
{
	/*
	 * Deal with user mode writebacks (from trap, or from sigreturn).
	 * If any writeback fails, go back and attempt signal delivery.
	 * unless we have already been here and attempted the writeback
	 * (e.g. bad address with user ignoring SIGSEGV).  In that case
	 * we just return to the user without successfully completing
	 * the writebacks.  Maybe we should just drop the sucker?
	 */
	if (mmutype == MMU_68040 && fp->f_format == FMT7) {
		int sig;
		union sigval sv;

		if ((sig = writeback(fp)) != 0) {
			sv.sival_int = fp->f_fmt7.f_fa;
			trapsignal(p, sig, T_MMUFLT, SEGV_MAPERR, sv);

			userret(p);
		}
	}
}
#endif

/*
 * Trap is called from locore to handle most types of processor traps,
 * including events such as simulated software interrupts/AST's.
 * System calls are broken out for efficiency.
 */
/*ARGSUSED*/
void
trap(type, code, v, frame)
	int type;
	u_int code;
	register u_int v;
	struct frame frame;
{
	register struct proc *p;
	register int i;
	u_int ucode;
	int typ = 0;
	register union sigval sv;

	uvmexp.traps++;
	p = curproc;
	ucode = 0;
	if (USERMODE(frame.f_sr)) {
		type |= T_USER;
		p->p_md.md_regs = frame.f_regs;
	}
	switch (type) {
	default:
dopanic:
		printf("trap type %d, code = %x, v = %x\n", type, code, v);
#ifdef DDB
		if (kdb_trap(type, (db_regs_t *)&frame))
			return;
#endif
		regdump(&(frame.F_t), 128);
		type &= ~T_USER;
		if ((u_int)type < trap_types)
			panic(trap_type[type]);
		panic("trap");

	case T_BUSERR:		/* kernel bus error */
		if (!p || !p->p_addr->u_pcb.pcb_onfault)
			goto dopanic;
copyfault:
		/*
		 * If we have arranged to catch this fault in any of the
		 * copy to/from user space routines, set PC to return to
		 * indicated location and set flag informing buserror code
		 * that it may need to clean up stack frame.
		 */
   		frame.f_stackadj = exframesize[frame.f_format];
   		frame.f_format = frame.f_vector = 0;
   		frame.f_pc = (int) p->p_addr->u_pcb.pcb_onfault;
   		return;

	case T_BUSERR|T_USER:	/* bus error */
		typ = BUS_OBJERR;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;
	case T_ADDRERR|T_USER:	/* address error */
		typ = BUS_ADRALN;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;

	case T_COPERR:		/* kernel coprocessor violation */
	case T_FMTERR|T_USER:	/* do all RTE errors come in as T_USER? */
	case T_FMTERR:		/* ...just in case... */
		/*
		 * The user has most likely trashed the RTE or FP state info
		 * in the stack frame of a signal handler.
		 */
		printf("pid %d: kernel %s exception\n", p->p_pid,
				 type==T_COPERR ? "coprocessor" : "format");
		sigexit(p, SIGILL);
		/* NOTREACHED */
		break;

	case T_COPERR|T_USER:	/* user coprocessor violation */
		/* What is a proper response here? */
		typ = FPE_FLTINV;
		ucode = 0;
		i = SIGFPE;
		break;

	case T_FPERR|T_USER:	/* 68881 exceptions */
		typ = FPE_FLTRES;
		ucode = code;
		i = SIGFPE;
		v = frame.f_pc;
		break;

#if defined(M68040) || defined(M68060)
	case T_FPEMULI|T_USER:	/* unimplemented FP instruction */
	case T_FPEMULD|T_USER:	/* unimplemented FP data type */
		/* XXX need to FSAVE */
		printf("pid %d(%s): unimplemented FP %s at %x (EA %x)\n",
				 p->p_pid, p->p_comm,
				 frame.f_format == 2 ? "instruction" : "data type",
				 frame.f_pc, frame.f_fmt2.f_iaddr);
		/* XXX need to FRESTORE */
		typ = FPE_FLTINV;
		i = SIGFPE;
		v = frame.f_pc;
		break;
#endif

	case T_ILLINST|T_USER:	/* illegal instruction fault */
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_ILLOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;

	case T_PRIVINST|T_USER:	/* privileged instruction fault */
		ucode	= frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_PRVOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;

	case T_ZERODIV|T_USER:	/* Divide by zero */
		ucode	= frame.f_format;	/* XXX was FPE_INTDIV_TRAP */
		typ = FPE_INTDIV;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	case T_CHKINST|T_USER:	/* CHK instruction trap */
		ucode = frame.f_format;	/* XXX was FPE_SUBRNG_TRAP */
		typ = FPE_FLTSUB;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	case T_TRAPVINST|T_USER:	/* TRAPV instruction trap */
		ucode = frame.f_format;	/* XXX was FPE_INTOVF_TRAP */
		typ = ILL_ILLTRP;
		i = SIGILL;
		v = frame.f_pc;
		break;

		/*
		 * XXX: Trace traps are a nightmare.
		 *
		 *	HP-UX uses trap #1 for breakpoints,
		 *	OpenBSD/m68k uses trap #2,
		 *	SUN 3.x uses trap #15,
		 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere).
		 *
		 * OpenBSD and HP-UX traps both get mapped by locore.s into
		 * T_TRACE.
		 * SUN 3.x traps get passed through as T_TRAP15 and are not really
		 * supported yet.
		 */
	case T_TRAP15:		/* kernel breakpoint */
#ifdef DEBUG
		printf("unexpected kernel trace trap, type = %d\n", type);
		printf("program counter = 0x%x\n", frame.f_pc);
#endif
		frame.f_sr &= ~PSL_T;
		return;

	case T_TRACE|T_USER:	/* user trace trap */
	case T_TRACE:
	case T_TRAP15|T_USER:	/* SUN user trace trap */
		frame.f_sr &= ~PSL_T;
		i = SIGTRAP;
		typ = TRAP_TRACE;
		break;

	case T_ASTFLT:		/* system async trap, cannot happen */
		goto dopanic;

	case T_ASTFLT|T_USER:	/* user async trap */
		astpending = 0;
		/*
		 * We check for software interrupts first.  This is because
		 * they are at a higher level than ASTs, and on a VAX would
		 * interrupt the AST.  We assume that if we are processing
		 * an AST that we must be at IPL0 so we don't bother to
		 * check.  Note that we ensure that we are at least at SIR
		 * IPL while processing the SIR.
		 */
		splsoft();
		/* FALLTHROUGH */

	case T_SSIR:		/* software interrupt */
	case T_SSIR|T_USER:
	    {
		int sir, q, mask;

		while ((sir = softpending) != 0) {
			atomic_clearbits_int(&softpending, sir);

			for (q = SI_NQUEUES - 1, mask = 1 << (SI_NQUEUES - 1);
			    mask != 0; q--, mask >>= 1)
				if (mask & sir)
					softintr_dispatch(q);
		}
	    }

		/*
		 * If this was not an AST trap, we are all done.
		 */
		if (type != (T_ASTFLT|T_USER)) {
			uvmexp.traps--;
			return;
		}
		spl0();
		if (p->p_flag & P_OWEUPC) {
			ADDUPROF(p);
		}
		if (type == (T_ASTFLT | T_USER) && want_resched) {
			preempt(NULL);
		}
		goto out;

	case T_MMUFLT:		/* kernel mode page fault */
	case T_MMUFLT|T_USER:	/* page fault */
	    {
		vaddr_t va;
		struct vmspace *vm = NULL;
		struct vm_map *map;
		int rv;
		vm_prot_t ftype, vftype;
		extern struct vm_map *kernel_map;

		/* vmspace only significant if T_USER */
		if (p)
			vm = p->p_vmspace;

#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			printf("trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n",
			    p->p_pid, code, v, frame.f_pc, frame.f_sr);
#endif
		/*
		 * It is only a kernel address space fault iff:
		 * 	1. (type & T_USER) == 0  and
		 * 	2. pcb_onfault not set or
		 *	3. pcb_onfault set but supervisor space data fault
		 * The last can occur during an exec() copyin where the
		 * argument space is lazy-allocated.
		 */
		if (type == T_MMUFLT &&
		    ((p && !p->p_addr->u_pcb.pcb_onfault) || KDFAULT(code)))
			map = kernel_map;
		else
			map = vm ? &vm->vm_map : kernel_map;
		if (WRFAULT(code)) {
			vftype = VM_PROT_WRITE;
			ftype = VM_PROT_READ | VM_PROT_WRITE;
		} else
			vftype = ftype = VM_PROT_READ;
		va = trunc_page((vaddr_t)v);

		if (map == kernel_map && va == 0) {
			printf("trap: bad kernel access at %x\n", v);
			goto dopanic;
		}
		rv = uvm_fault(map, va, 0, ftype);
#ifdef DEBUG
		if (rv && MDB_ISPID(p->p_pid))
			printf("uvm_fault(%x, %x, 0, %x) -> %x\n",
				 map, va, ftype, rv);
#endif
		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if ((vm != NULL && (caddr_t)va >= vm->vm_maxsaddr)
		    && map != kernel_map) {
			if (rv == 0)
				uvm_grow(p, va);
			else if (rv == EACCES)
				rv = EFAULT;
		}
		if (rv == 0) {
			if (type == T_MMUFLT) {
#if defined(M68040)
				if (mmutype == MMU_68040)
					(void)writeback(&frame);
#endif
				return;
			}
			goto out;
		}
		if (type == T_MMUFLT) {
			if (p && p->p_addr->u_pcb.pcb_onfault)
				goto copyfault;
			printf("uvm_fault(%p, %lx, 0, %x) -> %x\n",
				 map, va, ftype, rv);
			printf("  type %x, code [mmu,,ssw]: %x\n",
				 type, code);
			goto dopanic;
		}
		frame.f_pad = code & 0xffff;
		ucode = vftype;
		typ = SEGV_MAPERR;
		i = SIGSEGV;
	    }
		break;
	}
	sv.sival_int = v;
	trapsignal(p, i, ucode, typ, sv);
out:
	if ((type & T_USER) == 0)
		return;
	userret(p);
#ifdef M68040
	wb_userret(p, &frame);
#endif
}

#if defined(M68040)
#ifdef DEBUG
struct writebackstats {
	int calls;
	int cpushes;
	int move16s;
	int wb1s, wb2s, wb3s;
	int wbsize[4];
} wbstats;

char *f7sz[] = { "longword", "byte", "word", "line"};
char *f7tt[] = { "normal", "MOVE16", "AFC", "ACK"};
char *f7tm[] = { "d-push", "u-data", "u-code", "M-data",
	"M-code", "k-data", "k-code", "RES"};
char wberrstr[] =
"WARNING: pid %d(%s) writeback [%s] failed, pc=%x fa=%x wba=%x wbd=%x\n";
#endif

int
writeback(struct frame *fp)
{
	struct fmt7 *f = &fp->f_fmt7;
	struct proc *p = curproc;
	int err = 0;
	u_int fa;
	paddr_t pa;
	caddr_t oonfault = p->p_addr->u_pcb.pcb_onfault;

#ifdef DEBUG
	if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid)) {
		printf(" pid=%d, fa=%x,", p->p_pid, f->f_fa);
		dumpssw(f->f_ssw);
	}
	wbstats.calls++;
#endif
	/*
	 * Deal with special cases first.
	 */
	if ((f->f_ssw & SSW4_TMMASK) == SSW4_TMDCP) {
		/*
		 * Dcache push fault.
		 * Line-align the address and write out the push data to
		 * the indicated physical address.
		 */
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid)) {
			printf(" pushing %s to PA %x, data %x",
					 f7sz[(f->f_ssw & SSW4_SZMASK) >> 5],
					 f->f_fa, f->f_pd0);
			if ((f->f_ssw & SSW4_SZMASK) == SSW4_SZLN)
				printf("/%x/%x/%x",
						 f->f_pd1, f->f_pd2, f->f_pd3);
			printf("\n");
		}
		if (f->f_wb1s & SSW4_WBSV)
			panic("writeback: cache push with WB1S valid");
		wbstats.cpushes++;
#endif
		/*
		 * XXX there are security problems if we attempt to do a
		 * cache push after a signal handler has been called.
		 */
		pmap_kenter_pa((vaddr_t)vmmap,
		    trunc_page(f->f_fa), VM_PROT_WRITE);
		pmap_update(pmap_kernel());
		fa = (u_int)&vmmap[(f->f_fa & PGOFSET) & ~0x000f];
		bcopy((caddr_t)&f->f_pd0, (caddr_t)fa, 16);
		pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa);
		DCFL(pa);
		pmap_kremove((vaddr_t)vmmap, PAGE_SIZE);
		pmap_update(pmap_kernel());
	} else if ((f->f_ssw & (SSW4_RW|SSW4_TTMASK)) == SSW4_TTM16) {
		/*
		 * MOVE16 fault.
		 * Line-align the address and write out the push data to
		 * the indicated virtual address.
		 */
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			printf(" MOVE16 to VA %x(%x), data %x/%x/%x/%x\n",
					 f->f_fa, f->f_fa & ~0xF, f->f_pd0, f->f_pd1,
					 f->f_pd2, f->f_pd3);
		if (f->f_wb1s & SSW4_WBSV)
			panic("writeback: MOVE16 with WB1S valid");
		wbstats.move16s++;
#endif
		if (KDFAULT(f->f_wb1s))
			bcopy((caddr_t)&f->f_pd0, (caddr_t)(f->f_fa & ~0xF), 16);
		else
			err = suline((caddr_t)(f->f_fa & ~0xF), (caddr_t)&f->f_pd0);
		if (err) {
			fa = f->f_fa & ~0xF;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
						 "MOVE16", fp->f_pc, f->f_fa,
						 f->f_fa & ~0xF, f->f_pd0);
#endif
		}
	} else if (f->f_wb1s & SSW4_WBSV) {
		/*
		 * Writeback #1.
		 * Position the "memory-aligned" data and write it out.
		 */
		u_int wb1d = f->f_wb1d;
		int off;

#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(1, f->f_wb1s, f->f_wb1a, f->f_wb1d);
		wbstats.wb1s++;
		wbstats.wbsize[(f->f_wb2s&SSW4_SZMASK)>>5]++;
#endif
		off = (f->f_wb1a & 3) * 8;
		switch (f->f_wb1s & SSW4_SZMASK) {
			case SSW4_SZLW:
				if (off)
					wb1d = (wb1d >> (32 - off)) | (wb1d << off);
				if (KDFAULT(f->f_wb1s))
					*(long *)f->f_wb1a = wb1d;
				else
					err = copyout(&wb1d,
					    (caddr_t)f->f_wb1a, sizeof(int));
				break;
			case SSW4_SZB:
				off = 24 - off;
				if (off)
					wb1d >>= off;
				if (KDFAULT(f->f_wb1s))
					*(char *)f->f_wb1a = wb1d;
				else {
					char tmp = wb1d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb1a, sizeof(char));
				}
				break;
			case SSW4_SZW:
				off = (off + 16) % 32;
				if (off)
					wb1d = (wb1d >> (32 - off)) | (wb1d << off);
				if (KDFAULT(f->f_wb1s))
					*(short *)f->f_wb1a = wb1d;
				else {
					short tmp = wb1d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb1a, sizeof(short));
				}
				break;
		}
		if (err) {
			fa = f->f_wb1a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
						 "#1", fp->f_pc, f->f_fa,
						 f->f_wb1a, f->f_wb1d);
#endif
		}
	}
	/*
	 * Deal with the "normal" writebacks.
	 *
	 * XXX writeback2 is known to reflect a LINE size writeback after
	 * a MOVE16 was already dealt with above.  Ignore it.
	 */
	if (err == 0 && (f->f_wb2s & SSW4_WBSV) &&
		 (f->f_wb2s & SSW4_SZMASK) != SSW4_SZLN) {
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(2, f->f_wb2s, f->f_wb2a, f->f_wb2d);
		wbstats.wb2s++;
		wbstats.wbsize[(f->f_wb2s&SSW4_SZMASK)>>5]++;
#endif
		switch (f->f_wb2s & SSW4_SZMASK) {
			case SSW4_SZLW:
				if (KDFAULT(f->f_wb2s))
					*(long *)f->f_wb2a = f->f_wb2d;
				else
					err = copyout(&f->f_wb2d,
					    (caddr_t)f->f_wb2a, sizeof(int));
				break;
			case SSW4_SZB:
				if (KDFAULT(f->f_wb2s))
					*(char *)f->f_wb2a = f->f_wb2d;
				else {
					char tmp = f->f_wb2d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb2a, sizeof(char));
				}
				break;
			case SSW4_SZW:
				if (KDFAULT(f->f_wb2s))
					*(short *)f->f_wb2a = f->f_wb2d;
				else {
					short tmp = f->f_wb2d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb2a, sizeof(short));
				}
				break;
		}
		if (err) {
			fa = f->f_wb2a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED) {
				printf(wberrstr, p->p_pid, p->p_comm,
						 "#2", fp->f_pc, f->f_fa,
						 f->f_wb2a, f->f_wb2d);
				dumpssw(f->f_ssw);
				dumpwb(2, f->f_wb2s, f->f_wb2a, f->f_wb2d);
			}
#endif
		}
	}
	if (err == 0 && (f->f_wb3s & SSW4_WBSV)) {
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(3, f->f_wb3s, f->f_wb3a, f->f_wb3d);
		wbstats.wb3s++;
		wbstats.wbsize[(f->f_wb3s&SSW4_SZMASK)>>5]++;
#endif
		switch (f->f_wb3s & SSW4_SZMASK) {
			case SSW4_SZLW:
				if (KDFAULT(f->f_wb3s))
					*(long *)f->f_wb3a = f->f_wb3d;
				else
					err = copyout(&f->f_wb3d,
					    (caddr_t)f->f_wb3a, sizeof(int));
				break;
			case SSW4_SZB:
				if (KDFAULT(f->f_wb3s))
					*(char *)f->f_wb3a = f->f_wb3d;
				else {
					char tmp = f->f_wb3d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb3a, sizeof(char));
				}
				break;
			case SSW4_SZW:
				if (KDFAULT(f->f_wb3s))
					*(short *)f->f_wb3a = f->f_wb3d;
				else {
					short tmp = f->f_wb3d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb3a, sizeof(short));
				}
				break;
#ifdef DEBUG
			case SSW4_SZLN:
				panic("writeback: wb3s indicates LINE write");
#endif
		}
		if (err) {
			fa = f->f_wb3a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
						 "#3", fp->f_pc, f->f_fa,
						 f->f_wb3a, f->f_wb3d);
#endif
		}
	}
	p->p_addr->u_pcb.pcb_onfault = oonfault;
	/*
	 * Any problems are SIGSEGV's
	 */
	if (err)
		err = SIGSEGV;
	return (err);
}

#ifdef DEBUG
void
dumpssw(ssw)
	register u_short ssw;
{
	printf(" SSW: %x: ", ssw);
	if (ssw & SSW4_CP)
		printf("CP,");
	if (ssw & SSW4_CU)
		printf("CU,");
	if (ssw & SSW4_CT)
		printf("CT,");
	if (ssw & SSW4_CM)
		printf("CM,");
	if (ssw & SSW4_MA)
		printf("MA,");
	if (ssw & SSW4_ATC)
		printf("ATC,");
	if (ssw & SSW4_LK)
		printf("LK,");
	if (ssw & SSW4_RW)
		printf("RW,");
	printf(" SZ=%s, TT=%s, TM=%s\n",
			 f7sz[(ssw & SSW4_SZMASK) >> 5],
			 f7tt[(ssw & SSW4_TTMASK) >> 3],
			 f7tm[ssw & SSW4_TMMASK]);
}

void
dumpwb(num, s, a, d)
	int num;
	u_short s;
	u_int a, d;
{
	register struct proc *p = curproc;
	paddr_t pa;
	int tmp;

	printf(" writeback #%d: VA %x, data %x, SZ=%s, TT=%s, TM=%s\n",
			 num, a, d, f7sz[(s & SSW4_SZMASK) >> 5],
			 f7tt[(s & SSW4_TTMASK) >> 3], f7tm[s & SSW4_TMMASK]);
	printf("	       PA ");
	if (pmap_extract(p->p_vmspace->vm_map.pmap, (vaddr_t)a, &pa) == FALSE)
		printf("<invalid address>");
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
	printf("\n");
}
#endif
#endif

/*
 * Process a system call.
 */
void
syscall(code, frame)
	register_t code;
	struct frame frame;
{
	register caddr_t params;
	register struct sysent *callp;
	register struct proc *p;
	int error, opc, nsys;
	size_t argsize;
	register_t args[8], rval[2];
	uvmexp.syscalls++;
	
	if (!USERMODE(frame.f_sr))
		panic("syscall");
	p = curproc;
	p->p_md.md_regs = frame.f_regs;
	opc = frame.f_pc;

	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;

	params = (caddr_t)frame.f_regs[SP] + sizeof(int);

	switch (code) {
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
		params += sizeof(int);
		/*
		 * XXX sigreturn requires special stack manipulation
		 * that is only done if entered via the sigreturn
		 * trap.  Cannot allow it here so make sure we fail.
		 */
		if (code == SYS_sigreturn)
			code = nsys;
		break;
	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
			break;
		if ((error = copyin(params + _QUAD_LOWWORD * sizeof(int),
		    &code, sizeof(register_t))))
			goto bad;
		params += sizeof(quad_t);
		break;
	default:
		break;
	}
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;		/* illegal */
	else
		callp	+= code;
	argsize = callp->sy_argsize;
	if (argsize && (error = copyin(params, args, argsize)))
		goto bad;

	rval[0] = 0;
	rval[1] = frame.f_regs[D1];

	error = mi_syscall(p, code, callp, args, rval);

	switch (error) {
	case 0:
		frame.f_regs[D0] = rval[0];
		frame.f_regs[D1] = rval[1];
		frame.f_sr &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/*
		 * We always enter through a `trap' instruction, which is 2
		 * bytes, so adjust the pc by that amount.
		 */
		frame.f_pc = opc - 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		frame.f_regs[D0] = error;
		frame.f_sr |= PSL_C;	/* carry bit */
		break;
	}

	mi_syscall_return(p, code, error, rval);
}

typedef SLIST_HEAD(,intrhand) intrhand_t;
intrhand_t intrs[NVMEINTR];

void
init_intrs()
{
	int i;
	extern void netintr(void *);

	/* hard interrupts... */
	for (i = 0; i < NVMEINTR; i++)
		SLIST_INIT(&intrs[i]);

	/* soft interrupts... */
	softintr_init();
}

void
hardintr(pc, evec, frame)
	int pc;
	int evec;
	void *frame;
{
	extern void straytrap(int, u_short);
	int vec = (evec & 0xfff) >> 2;	/* XXX should be m68k macro? */
	struct intrhand *ih;
	intrhand_t *list;
	int count = 0;
	int r;

	uvmexp.intrs++;

	list = &intrs[vec];
	if (SLIST_EMPTY(list)) {
		straytrap(pc, evec);
	} else {
		SLIST_FOREACH(ih, list, ih_link) {
			r = (*ih->ih_fn)(ih->ih_wantframe ? frame : ih->ih_arg);
			if (r != 0) {
				ih->ih_count.ec_count++;
				count++;
			}
		}

		if (count == 0) {
			printf("Unclaimed interrupt (vector %d) from %x\n",
			    evec, pc);
		}
	}
}

/*
 * find a useable interrupt vector in the range start, end. It starts at
 * the end of the range, and searches backwards (to increase the chances
 * of not conflicting with more normal users)
 */
int
intr_findvec(start, end)
	int start, end;
{
	extern u_long *vectab[], hardtrap, badtrap;
	int vec;

	if (start < 0 || end >= NVMEINTR || start > end)
		return (-1);
	for (vec = end; vec > start; --vec)
		if (vectab[vec] == &badtrap || vectab[vec] == &hardtrap)
			return (vec);
	return (-1);
}

/*
 * Chain the interrupt handler in. But first check if the vector
 * offset chosen is legal. It either must be a badtrap (not allocated
 * for a `system' purpose), or it must be a hardtrap (ie. already
 * allocated to deal with chained interrupt handlers).
 */
int
intr_establish(vec, ih, name)
	int vec;
	struct intrhand *ih;
	const char *name;
{
	extern u_long *vectab[], hardtrap, badtrap;
	struct intrhand *intr;
	intrhand_t *list;

#ifdef DIAGNOSTIC
	if (vec < 0 || vec >= NVMEINTR) {
		panic("intr_establish: vec (0x%x) out of bounds", vec);
		return (-1);
	}
#endif

	if (vectab[vec] != &badtrap && vectab[vec] != &hardtrap) {
#ifdef DIAGNOSTIC
		panic("intr_establish: vec (%x) unavailable for devices", vec);
#endif
		return (-1);
	}
	vectab[vec] = &hardtrap;

	list = &intrs[vec];
	if (!SLIST_EMPTY(list)) {
		intr = SLIST_FIRST(list);
		if (intr->ih_ipl != ih->ih_ipl) {
#ifdef DIAGNOSTIC
			panic("intr_establish: there are other handlers with "
			    "vec (0x%x) at ipl %x, but you want it at %x",
			    vec, intr->ih_ipl, ih->ih_ipl);
#endif
			return (-1);
		}
	}

	evcount_attach(&ih->ih_count, name, &ih->ih_ipl);
	SLIST_INSERT_HEAD(list, ih, ih_link);
	return (0);
}

#ifdef DDB
#include <sys/reboot.h>
#include <machine/db_machdep.h>
#include <ddb/db_command.h>

void db_prom_cmd(db_expr_t, int, db_expr_t, char *);
void db_machine_init(void);

/* ARGSUSED */
void
db_prom_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	doboot();
}

struct db_command db_machine_cmds[] = {
	{ "prom",   db_prom_cmd,   0, 0},
	{ (char *)0,}
};

void
db_machine_init()
{
	db_machine_commands_install(db_machine_cmds);
}
#endif /* DDB */
@


1.78
log
@Use sigexit() instead of rolling our own version.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.77 2012/12/31 06:46:13 guenther Exp $ */
@


1.77
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.76 2012/08/07 05:16:54 guenther Exp $ */
d258 2
a259 10
		type |= T_USER;
		p->p_sigacts->ps_sigact[SIGILL] = SIG_DFL;
		i = sigmask(SIGILL);
		p->p_sigacts->ps_sigignore &= ~i;
		p->p_sigacts->ps_sigcatch &= ~i;
		p->p_sigmask &= ~i;
		i = SIGILL;
		ucode = frame.f_format;	/* XXX was ILL_RESAD_FAULT */
		typ = ILL_COPROC;
		v = frame.f_pc;
@


1.76
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.75 2011/11/16 20:50:19 deraadt Exp $ */
a929 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
@


1.75
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.74 2011/07/05 04:48:01 guenther Exp $ */
d73 1
a75 3
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
a82 3
#include "systrace.h"
#include <dev/systrace.h>

d891 3
a893 3
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
d904 1
a904 12
	if (argsize)
		error = copyin(params, (caddr_t)args, argsize);
	else
		error	= 0;
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, argsize, args);
#endif
	if (error)
d906 1
d909 3
a911 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
d929 1
a929 1
bad:
d937 1
a937 8
#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
@


1.74
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.73 2011/04/18 21:44:55 guenther Exp $ */
a158 15
/*
 * trap and syscall both need the following work done before returning
 * to user mode.
 */
void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	curcpu()->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}

d161 1
a161 1
 * Same as above, but also handles writeback completion on 68040.
a165 8
	int sig;
	union sigval sv;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;

d175 3
d182 1
a182 3
			while ((sig = CURSIG(p)) != 0)
				postsig(sig);
			p->p_priority = p->p_usrpri;
a184 1
	curcpu()->ci_schedstate.spc_curpriority = p->p_priority;
d509 1
a511 2
#else
	userret(p);
@


1.73
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2010/09/20 06:33:47 matthew Exp $ */
d289 2
a290 2
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
@


1.72
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d289 2
a290 2
		p->p_sigacts->ps_sigignore &= ~i;
		p->p_sigacts->ps_sigcatch &= ~i;
@


1.71
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2010/07/02 19:57:14 tedu Exp $ */
d289 2
a290 2
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
@


1.70
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2010/06/29 20:30:32 guenther Exp $ */
d1104 1
a1104 1
	evcount_attach(&ih->ih_count, name, &ih->ih_ipl, &evcount_intr);
@


1.69
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.68 2009/03/15 20:40:25 miod Exp $ */
a84 5
#ifdef COMPAT_SUNOS
#include <compat/sunos/sunos_syscall.h>
extern struct emul emul_sunos;
#endif

a227 3
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
a383 13
#ifdef COMPAT_SUNOS
		/*
		 * SunOS uses Trap #2 for a "CPU cache flush"
		 * Just flush the on-chip caches and return.
		 */
		if (p->p_emul == &emul_sunos) {
			ICIA();
			DCIU();
			return;
		}
#endif
		/* FALLTHROUGH */

a883 3
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
a894 32
#ifdef COMPAT_SUNOS
	if (p->p_emul == &emul_sunos) {
		/*
		 * SunOS passes the syscall-number on the stack, whereas
		 * BSD passes it in D0. So, we have to get the real "code"
		 * from the stack, and clean up the stack, as SunOS glue
		 * code assumes the kernel pops the syscall argument the
		 * glue pushed on the stack. Sigh...
		 */
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		    sizeof(register_t)) != 0)
			code = -1;

		/*
		 * XXX
		 * Don't do this for sunos_sigreturn, as there's no stored pc
		 * on the stack to skip, the argument follows the syscall
		 * number without a gap.
		 */
		if (code != SUNOS_SYS_sigreturn) {
			frame.f_regs[SP] += sizeof (int);
			/*
			 * remember that we adjusted the SP,
			 * might have to undo this if the system call
			 * returns ERESTART.
			 */
			p->p_md.md_flags |= MDP_STACKADJ;
		} else
			p->p_md.md_flags &= ~MDP_STACKADJ;
	}
#endif

a980 5
#endif
#ifdef COMPAT_SUNOS
	/* need new p-value for this */
	if (error == ERESTART && (p->p_md.md_flags & MDP_STACKADJ))
		frame.f_regs[SP] -= sizeof (int);
@


1.68
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2007/05/15 13:46:22 martin Exp $ */
a95 4
#ifdef COMPAT_HPUX
#include <compat/hpux/hpux.h>
#endif

a232 3
#ifdef COMPAT_HPUX
	extern struct emul emul_hpux;
#endif
a335 8
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux) {
			typ = 0;
			ucode = HPUX_ILL_ILLINST_TRAP;
			i = SIGILL;
			break;
		}
#endif
a342 5
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux)
			ucode = HPUX_ILL_PRIV_TRAP;
		else
#endif
a349 5
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux)
			ucode = HPUX_FPE_INTDIV_TRAP;
		else
#endif
a356 8
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux) {
			/* handled differently under hp-ux */
			i = SIGILL;
			ucode = HPUX_ILL_CHK_TRAP;
			break;
		}
#endif
a363 8
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux) {
			/* handled differently under hp-ux */
			i = SIGILL;
			ucode = HPUX_ILL_TRAPV_TRAP;
			break;
		}
#endif
a501 13
#ifdef COMPAT_HPUX
		if (ISHPMMADDR(p, va)) {
			vaddr_t bva;

			rv = pmap_mapmulti(map->pmap, va);
			if (rv) {
				bva = HPMMBASEADDR(va);
				rv = uvm_fault(map, bva, 0, ftype);
				if (rv == 0)
					(void)pmap_mapmulti(map->pmap, va);
			}
		} else
#endif
@


1.67
log
@switch m68k to __HAVE_CPUINFO

help miod@@, art@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2007/04/01 09:29:27 art Exp $ */
a160 5
#define NSIR	8
void (*sir_routines[NSIR])(void *);
void *sir_args[NSIR];
u_char next_sir;

d236 1
a236 1
	int typ = 0, bit;
d471 10
a480 6
		while ((bit = ffs(ssir))) {
			--bit;
			ssir &= ~(1 << bit);
			uvmexp.softs++;
			if (sir_routines[bit])
				sir_routines[bit](sir_args[bit]);
d482 2
a1103 18
/*
 * Allocation routines for software interrupts.
 */
u_int8_t
allocate_sir(proc, arg)
	void (*proc)(void *);
	void *arg;
{
	int bit;

	if (next_sir >= NSIR)
		panic("allocate_sir: none left");
	bit = next_sir++;
	sir_routines[bit] = proc;
	sir_args[bit] = arg;
	return (1 << bit);
}

d1118 1
a1118 3
	sir_routines[0] = netintr;
	sir_routines[1] = (void (*)(void *))softclock;
	next_sir = 2;
@


1.66
log
@Remove some leftovers from the userret cleanups.
No need to save sticks anymore.
miod@@ ok and test
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2007/03/15 10:22:29 art Exp $ */
d185 1
a185 1
	curpriority = p->p_priority = p->p_usrpri;
d221 1
a221 1
	curpriority = p->p_priority;
@


1.65
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2007/01/28 16:38:48 miod Exp $ */
a240 1
	u_quad_t sticks;
a254 1
		sticks = p->p_sticks;
a957 1
	u_quad_t sticks;
a965 1
	sticks = p->p_sticks;
@


1.64
log
@optimize m68k writeback():
- it can really only be invoked from trap(), not from other userret() callers,
  so it is safe to hardcode its docachepush parameter to 1.
- use pmap_kenter_pa()/pmap_kremove() for the temporary mapping instead of
  pmap_enter()/pmap_remove().

optimize m68k userret():
- define PROC_PC for m68k systems.
- only check want_resched when processing T_ASTFLT traps.
- provide two version of userret(), one which will also invoke writeback()
  on 68040 if required, which is only invoked from trap(), and regular
  userret(). This speeds up system call returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2006/06/11 20:46:50 miod Exp $ */
a493 1
			p->p_flag &= ~P_OWEUPC;
@


1.63
log
@Factorize spl handling functions and software interrupt routines between
m68k-based platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2006/01/30 21:26:19 miod Exp $ */
d170 2
a171 1
int writeback(struct frame *fp, int docachepush);
d178 16
a193 6
userret(p, fp, oticks, faultaddr, fromtrap)
	register struct proc *p;
	register struct frame *fp;
	u_quad_t oticks;
	u_int faultaddr;
	int fromtrap;
d196 1
a196 2
#if defined(M68040)
	int beenhere = 0;
a197 2
again:
#endif
a201 8
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
a203 10
	 * If profiling, charge system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, fp->f_pc, 
			    (int)(p->p_sticks - oticks) * psratio);
	}
#if defined(M68040)
	/*
d212 7
a218 16
		if (beenhere) {
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(fromtrap ?
			 "pid %d(%s): writeback aborted, pc=%x, fa=%x\n" :
			 "pid %d(%s): writeback aborted in sigreturn, pc=%x\n",
				     p->p_pid, p->p_comm, fp->f_pc, faultaddr);
#endif
		} else if ((sig = writeback(fp, fromtrap))) {
			register union sigval sv;

			beenhere = 1;
			oticks = p->p_sticks;
			sv.sival_int = faultaddr;
			trapsignal(p, sig, VM_PROT_WRITE, SEGV_MAPERR, sv);
			goto again;
a220 1
#endif
d223 1
d497 3
d582 1
a582 1
					(void) writeback(&frame, 1);
d609 5
a613 1
	userret(p, &frame, sticks, v, 1);
d635 1
a635 3
writeback(fp, docachepush)
	struct frame *fp;
	int docachepush;
d637 2
a638 2
	register struct fmt7 *f = &fp->f_fmt7;
	register struct proc *p = curproc;
d641 1
d678 9
a686 16
		if (docachepush) {
			paddr_t pa;

			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
						  trunc_page(f->f_fa), VM_PROT_WRITE, VM_PROT_WRITE|PMAP_WIRED);
			pmap_update(pmap_kernel());
			fa = (u_int)&vmmap[(f->f_fa & PGOFSET) & ~0xF];
			bcopy((caddr_t)&f->f_pd0, (caddr_t)fa, 16);
			pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa);
			DCFL(pa);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
							(vaddr_t)&vmmap[NBPG]);
			pmap_update(pmap_kernel());
		} else
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
					 p->p_pid, p->p_comm, p->p_ucred->cr_uid);
d1101 1
a1101 1
	userret(p, &frame, sticks, 0, 0);
@


1.62
log
@When delivering SIGFOO, make sure the siginfo code is a FOO_xxx constant;
also deliver SIGILL/ILL_COPROC rather than SIGFPE/FPE_FLTINV for disabled
or missing floating point support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2005/12/17 07:31:26 miod Exp $ */
d1131 1
a1131 1
u_long
@


1.61
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2005/11/12 23:14:03 miod Exp $ */
a346 9
		/*
		 * We pass along the 68881 status register which locore stashed
		 * in code for us.  Note that there is a possibility that the
		 * bit pattern of this register will conflict with one of the
		 * FPE_* codes defined in signal.h.  Fortunately for us, the
		 * only such codes we use are all in the range 1-7 and the low
		 * 3 bits of the status register are defined as 0 so there is
		 * no clash.
		 */
@


1.60
log
@Pass a struct proc * to ISHPMMADDR instead of abusing curproc in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2005/07/31 15:38:12 miod Exp $ */
d530 1
a530 1
		vm_offset_t va;
d564 1
a564 1
		va = trunc_page((vm_offset_t)v);
d572 1
a572 1
			vm_offset_t bva;
d703 1
a703 1
			pmap_enter(pmap_kernel(), (vm_offset_t)vmmap,
d708 1
a708 1
			pmap_extract(pmap_kernel(), (vm_offset_t)fa, &pa);
d710 2
a711 2
			pmap_remove(pmap_kernel(), (vm_offset_t)vmmap,
							(vm_offset_t)&vmmap[NBPG]);
d956 1
a956 1
	vm_offset_t pa;
d963 1
a963 1
	if (pmap_extract(p->p_vmspace->vm_map.pmap, (vm_offset_t)a, &pa) == FALSE)
@


1.59
log
@Wrong copyout() size in writeback().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2005/05/01 09:55:49 miod Exp $ */
d529 11
a539 11
		{
			vm_offset_t va;
			struct vmspace *vm = NULL;
			struct vm_map *map;
			int rv;
			vm_prot_t ftype, vftype;
			extern struct vm_map *kernel_map;

			/* vmspace only significant if T_USER */
			if (p)
				vm = p->p_vmspace;
d542 28
a569 28
			if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
				printf("trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n",
				    p->p_pid, code, v, frame.f_pc, frame.f_sr);
#endif
			/*
			 * It is only a kernel address space fault iff:
			 * 	1. (type & T_USER) == 0  and
			 * 	2. pcb_onfault not set or
			 *	3. pcb_onfault set but supervisor space data fault
			 * The last can occur during an exec() copyin where the
			 * argument space is lazy-allocated.
			 */
			if (type == T_MMUFLT &&
			    ((p && !p->p_addr->u_pcb.pcb_onfault) || KDFAULT(code)))
				map = kernel_map;
			else
				map = vm ? &vm->vm_map : kernel_map;
			if (WRFAULT(code)) {
				vftype = VM_PROT_WRITE;
				ftype = VM_PROT_READ | VM_PROT_WRITE;
			} else
				vftype = ftype = VM_PROT_READ;
			va = trunc_page((vm_offset_t)v);

			if (map == kernel_map && va == 0) {
				printf("trap: bad kernel access at %x\n", v);
				goto dopanic;
			}
d571 2
a572 2
			if (ISHPMMADDR(va)) {
				vm_offset_t bva;
d574 8
a581 8
				rv = pmap_mapmulti(map->pmap, va);
				if (rv) {
					bva = HPMMBASEADDR(va);
					rv = uvm_fault(map, bva, 0, ftype);
					if (rv == 0)
						(void) pmap_mapmulti(map->pmap, va);
				}
			} else
d583 1
a583 1
			rv = uvm_fault(map, va, 0, ftype);
d585 20
a604 20
			if (rv && MDB_ISPID(p->p_pid))
				printf("uvm_fault(%x, %x, 0, %x) -> %x\n",
					 map, va, ftype, rv);
#endif
			/*
			 * If this was a stack access we keep track of the maximum
			 * accessed stack size.  Also, if vm_fault gets a protection
			 * failure it is due to accessing the stack region outside
			 * the current limit and we need to reflect that as an access
			 * error.
			 */
			if ((vm != NULL && (caddr_t)va >= vm->vm_maxsaddr)
			    && map != kernel_map) {
				if (rv == 0)
					uvm_grow(p, va);
				else if (rv == EACCES)
					rv = EFAULT;
			}
			if (rv == 0) {
				if (type == T_MMUFLT) {
d606 2
a607 2
					if (mmutype == MMU_68040)
						(void) writeback(&frame, 1);
d609 1
a609 3
					return;
				}
				goto out;
d611 10
a620 14
			if (type == T_MMUFLT) {
				if (p && p->p_addr->u_pcb.pcb_onfault)
					goto copyfault;
				printf("uvm_fault(%p, %lx, 0, %x) -> %x\n",
					 map, va, ftype, rv);
				printf("  type %x, code [mmu,,ssw]: %x\n",
					 type, code);
				goto dopanic;
			}
			frame.f_pad = code & 0xffff;
			ucode = vftype;
			typ = SEGV_MAPERR;
			i = SIGSEGV;
			break;
d622 6
@


1.58
log
@Bring raise-only semantics to splsoft* on m68k and m88k, as done elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2004/12/24 22:50:30 miod Exp $ */
d792 1
a792 1
					    (caddr_t)f->f_wb1a, sizeof(long));
@


1.57
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2004/12/06 20:12:25 miod Exp $ */
d501 1
a501 1
		spl1();
@


1.56
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2004/07/30 22:29:49 miod Exp $ */
a1181 1
	/*extern u_long intrcnt[];*/	/* XXX from locore */
a1187 1
/*	intrcnt[level]++; */
@


1.55
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2004/04/18 20:19:52 miod Exp $ */
d598 3
a600 7
				if (rv == 0) {
					u_int nss;

					nss = btoc(USRSTACK-(u_int)va);
					if (nss > vm->vm_ssize)
						vm->vm_ssize = nss;
				} else if (rv == EACCES)
@


1.54
log
@... and do not pass a NULL map to uvm_fault() either.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2004/04/18 20:02:08 miod Exp $ */
d168 1
a168 1
void init_sir(void);
d247 1
a247 1
 * System calls are broken out for efficiency. T_ADDRERR
d1159 3
d1163 1
a1163 1
init_sir()
d1165 1
d1168 5
a1177 7
struct intrhand *intrs[256];

/*
 * XXX
 * This is an EXTREMELY good candidate for rewriting in assembly!!
 */
#ifndef INTR_ASM
d1188 1
d1194 16
a1209 5
	for (ih = intrs[vec]; ih; ih = ih->ih_next) {
#if 0
		if (vec >= 0x70 && vec <= 0x73) {
			zscnputc(0, '[');
			zscnputc(0, '0' + (vec - 0x70));
a1210 4
#endif
		r = (*ih->ih_fn)(ih->ih_wantframe ? frame : ih->ih_arg);
		if (r > 0)
			count++;
a1211 4
	if (count != 0)
		return;

	straytrap(pc, evec);
a1212 1
#endif /* !INTR_ASM */
d1226 1
a1226 1
	if (start < 0 || end > 255 || start > end)
d1241 1
a1241 1
intr_establish(vec, ih)
d1244 1
d1247 9
a1255 1
	struct intrhand *ihx;
d1258 3
a1260 1
		printf("intr_establish: vec %d unavailable\n", vec);
d1265 12
a1276 1
	ih->ih_next = NULL;	/* just in case */
d1278 2
a1279 7
	/* attach at tail */
	if ((ihx = intrs[vec])) {
		while (ihx->ih_next)
			ihx = ihx->ih_next;
		ihx->ih_next = ih;
	} else
		intrs[vec] = ih;
@


1.53
log
@Do not dereference NULL stupidly in trap() when checking if a process needs
its stack to grow (sync with other m68k ports, which are safe).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2004/01/15 17:22:27 miod Exp $ */
d558 1
a558 1
				map = &vm->vm_map;
@


1.52
log
@instuction -> instruction
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2003/12/20 00:34:32 miod Exp $ */
d596 2
a597 1
			if ((caddr_t)va >= vm->vm_maxsaddr && map != kernel_map) {
@


1.51
log
@Passl -Wformat. Fix some blatant -Wuninitialized errors as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2003/06/02 23:27:51 millert Exp $ */
d363 1
a363 1
	case T_FPEMULI|T_USER:	/* unimplemented FP instuction */
@


1.50
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2003/06/02 05:09:14 deraadt Exp $ */
d619 1
a619 1
				printf("uvm_fault(%x, %x, 0, %x) -> %x\n",
d634 1
a636 1
out:
@


1.49
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2003/01/09 22:27:09 miod Exp $ */
d44 1
a44 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.48
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2002/12/09 00:45:37 millert Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.47
log
@From Andrushock, s/sucess/success/g
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2002/06/23 03:03:15 deraadt Exp $ */
a266 1
	extern char fubail[], subail[];
a537 9
		/*
		 * If we were doing profiling ticks or other user mode
		 * stuff from interrupt code, Just Say No.
		 */
		if (p && (p->p_addr->u_pcb.pcb_onfault == fubail ||
		    p->p_addr->u_pcb.pcb_onfault == subail))
			goto copyfault;
		/* FALLTHROUGH */

d779 2
a780 1
					err = suword((caddr_t)f->f_wb1a, wb1d);
d788 6
a793 2
				else
					err = subyte((caddr_t)f->f_wb1a, wb1d);
d801 6
a806 2
				else
					err = susword((caddr_t)f->f_wb1a, wb1d);
d838 2
a839 1
					err = suword((caddr_t)f->f_wb2a, f->f_wb2d);
d844 6
a849 2
				else
					err = subyte((caddr_t)f->f_wb2a, f->f_wb2d);
d854 6
a859 2
				else
					err = susword((caddr_t)f->f_wb2a, f->f_wb2d);
d887 2
a888 1
					err = suword((caddr_t)f->f_wb3a, f->f_wb3d);
d893 6
a898 2
				else
					err = subyte((caddr_t)f->f_wb3a, f->f_wb3d);
d903 6
a908 2
				else
					err = susword((caddr_t)f->f_wb3a, f->f_wb3d);
d970 1
d978 6
a983 2
	else
		printf("%x, current value %x", pa, fuword((caddr_t)a));
d1028 3
a1030 1
		code = fuword((caddr_t)frame.f_regs[SP]);
d1058 2
a1059 1
		code = fuword(params);
d1076 3
a1078 1
		code = fuword(params + _QUAD_LOWWORD * sizeof(int));
@


1.46
log
@uid_t is unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2002/05/16 21:11:16 miod Exp $ */
d228 1
a228 1
	 * we just return to the user without sucessfully completing
@


1.45
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2002/04/28 14:47:54 miod Exp $ */
d737 1
a737 1
			printf("WARNING: pid %d(%s) uid %d: CPUSH not done\n",
@


1.44
log
@A few more tweaks to let non-GENERIC kernels (MVMEfoo) build as well with -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2002/04/27 23:21:06 miod Exp $ */
d100 3
d1077 6
a1082 1
	error = (*callp->sy_call)(p, args, rval);
@


1.43
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2002/03/14 01:26:38 millert Exp $ */
d192 1
a192 1
#if defined(M68040) || defined(M68060)
@


1.42
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2001/12/08 02:24:06 art Exp $ */
d89 2
d92 1
a93 2
#include <machine/cpu.h>
#include <machine/reg.h>
d107 3
d169 1
a169 1
void (*sir_routines[NSIR])();
d173 5
a177 1
int  writeback(struct frame *fp, int docachepush);
d237 1
a237 1
		} else if (sig = writeback(fp, fromtrap)) {
d257 1
d260 2
a261 2
	unsigned code;
	register unsigned v;
d291 1
a291 1
		if (kdb_trap(type, &frame))
d296 1
a296 1
		if ((unsigned)type < trap_types)
d514 1
a514 1
		while (bit = ffs(ssir)) {
d615 1
a615 1
					unsigned nss;
d617 1
a617 1
					nss = btoc(USRSTACK-(unsigned)va);
d769 2
a770 2
		register u_int wb1d = f->f_wb1d;
		register int off;
d967 1
d1120 1
a1120 1
	void (*proc)();
d1136 1
a1136 1
	extern void netintr();
d1139 1
a1139 1
	sir_routines[1] = softclock;
d1150 1
a1150 1
int
d1156 1
d1158 1
a1158 1
	extern u_long intrcnt[];	/* XXX from locore */
d1172 1
a1172 1
		r = (*ih->ih_fn)(ih->ih_wantframe ? frame : ih->ih_arg, vec);
d1176 4
a1179 2
	if (count == 0)
		return (straytrap(pc, evec));
d1226 1
a1226 1
	if (ihx = intrs[vec]) {
d1240 4
d1245 5
a1249 1
db_prom_cmd()
@


1.41
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2001/11/28 16:13:28 art Exp $ */
d169 1
a169 1
int  writeback __P((struct frame *fp, int docachepush));
@


1.41.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2001/12/08 02:24:06 art Exp $ */
d89 2
a90 1
#include <machine/db_machdep.h>
a91 1
#include <machine/psl.h>
a92 1
#include <machine/trap.h>
a98 3
#include "systrace.h"
#include <dev/systrace.h>

a105 3
int	astpending;
int	want_resched;

d165 1
a165 1
void (*sir_routines[NSIR])(void *);
d169 1
a169 5
void trap(int, u_int, u_int, struct frame);
void syscall(register_t, struct frame);
void init_sir(void);
void hardintr(int, int, void *);
int writeback(struct frame *fp, int docachepush);
d184 1
a184 1
#if defined(M68040)
d229 1
a229 1
		} else if ((sig = writeback(fp, fromtrap))) {
a248 1
void
d251 2
a252 2
	u_int code;
	register u_int v;
d282 1
a282 1
		if (kdb_trap(type, (db_regs_t *)&frame))
d287 1
a287 1
		if ((u_int)type < trap_types)
d505 1
a505 1
		while ((bit = ffs(ssir))) {
d606 1
a606 1
					u_int nss;
d608 1
a608 1
					nss = btoc(USRSTACK-(u_int)va);
d760 2
a761 2
		u_int wb1d = f->f_wb1d;
		int off;
a957 1
void
d1064 1
a1064 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
d1110 1
a1110 1
	void (*proc)(void *);
d1126 1
a1126 1
	extern void netintr(void *);
d1129 1
a1129 1
	sir_routines[1] = (void (*)(void *))softclock;
d1140 1
a1140 1
void
a1145 1
	extern void straytrap(int, u_short);
d1147 1
a1147 1
	/*extern u_long intrcnt[];*/	/* XXX from locore */
d1161 1
a1161 1
		r = (*ih->ih_fn)(ih->ih_wantframe ? frame : ih->ih_arg);
d1165 2
a1166 4
	if (count != 0)
		return;

	straytrap(pc, evec);
d1213 1
a1213 1
	if ((ihx = intrs[vec])) {
a1226 4
void db_prom_cmd(db_expr_t, int, db_expr_t, char *);
void db_machine_init(void);

/* ARGSUSED */
d1228 1
a1228 5
db_prom_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
@


1.41.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41.2.1 2002/06/11 03:36:50 art Exp $ */
d737 1
a737 1
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
@


1.41.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d228 1
a228 1
	 * we just return to the user without successfully completing
d267 1
d539 9
d789 1
a789 2
					err = copyout(&wb1d,
					    (caddr_t)f->f_wb1a, sizeof(int));
d797 2
a798 6
				else {
					char tmp = wb1d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb1a, sizeof(char));
				}
d806 2
a807 6
				else {
					short tmp = wb1d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb1a, sizeof(long));
				}
d839 1
a839 2
					err = copyout(&f->f_wb2d,
					    (caddr_t)f->f_wb2a, sizeof(int));
d844 2
a845 6
				else {
					char tmp = f->f_wb2d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb2a, sizeof(char));
				}
d850 2
a851 6
				else {
					short tmp = f->f_wb2d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb2a, sizeof(short));
				}
d879 1
a879 2
					err = copyout(&f->f_wb3d,
					    (caddr_t)f->f_wb3a, sizeof(int));
d884 2
a885 6
				else {
					char tmp = f->f_wb3d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb3a, sizeof(char));
				}
d890 2
a891 6
				else {
					short tmp = f->f_wb3d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb3a, sizeof(short));
				}
a952 1
	int tmp;
d960 2
a961 6
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
d1006 1
a1006 3
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		    sizeof(register_t)) != 0)
			code = -1;
d1034 1
a1034 2
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
d1051 1
a1051 3
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
@


1.40
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2001/11/28 13:47:38 art Exp $ */
d716 1
d723 1
@


1.39
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2001/11/25 17:15:20 miod Exp $ */
d538 3
a540 3
			register vm_offset_t va;
			register struct vmspace *vm = NULL;
			register vm_map_t map;
d543 1
a543 1
			extern vm_map_t kernel_map;
@


1.38
log
@Harmonize userret() prototypes across m68k arches.
XXX The userret() code is not factorized out yet, as this will require
XXX insane amiga cleaning work.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2001/11/06 19:53:15 miod Exp $ */
d583 1
a583 1
				if (rv != KERN_SUCCESS) {
d586 1
a586 1
					if (rv == KERN_SUCCESS)
d605 1
a605 1
				if (rv == KERN_SUCCESS) {
d611 2
a612 2
				} else if (rv == KERN_PROTECTION_FAILURE)
					rv = KERN_INVALID_ADDRESS;
d614 1
a614 1
			if (rv == KERN_SUCCESS) {
@


1.37
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2001/11/06 18:41:10 art Exp $ */
a170 3
void userret __P((struct proc *p, struct frame *fp,
										  u_quad_t oticks, u_int faultaddr, int fromtrap));

d1096 1
a1096 1
	userret(p, &frame, sticks, (u_int)0, 0);
@


1.36
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2001/09/14 09:15:19 art Exp $ */
a98 2
#include <vm/vm.h>
#include <vm/pmap.h>
d100 1
@


1.35
log
@simplify userret
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2001/08/25 11:37:26 espie Exp $ */
d172 1
a172 1
static inline void userret __P((struct proc *p, struct frame *fp,
d179 1
a179 1
static inline void
a1103 17
#endif
}

void
child_return(p, frame)
	struct proc *p;
	struct frame frame;
{

	frame.f_regs[D0] = 0;
	frame.f_sr &= ~PSL_C;
	frame.f_format = FMT0;

	userret(p, &frame, 0, (u_int)0, 0);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
@


1.34
log
@One regdump to dump them all...

(moid@@ wants that commit, because it interferes with stuff he's cleaning,
and he's prepared to clean up stuff I may have forgotten, even though this
was tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/07/25 13:25:32 art Exp $ */
d187 1
a187 1
	int sig, s;
d199 1
a199 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we mi_switch()'ed, we might not be on the queue
		 * indicated by our priority.
d201 1
a201 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.33
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2001/06/27 04:19:17 art Exp $ */
d298 1
a298 1
		regdump(&frame, 128);
@


1.32
log
@zap old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/06/26 21:35:43 miod Exp $ */
d728 1
a728 1
						  trunc_page(f->f_fa), VM_PROT_WRITE, TRUE, VM_PROT_WRITE);
@


1.31
log
@A few changes to mvme68k:
+ switch to UVM
+ fix the system trace problem
+ big cleanup of locore.s (macro for BUG calls, use more common m68k
  code whenever possible, and the macros in <m68k/asm.h>)
+ better indentation on some parts (old KNF)
+ call doshutdownhooks() at shutdown
+ use <net/netisr_dispatch.h>
+ upgrade pmap.c to something very close to our current hp300 pmap.c,
  minus support for PMAP_NEW and for HP MMU
+ various tidbits I forget to mention here

work and tests by smurph@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/06/08 08:09:09 art Exp $ */
a100 1
#if defined(UVM)
a101 1
#endif
a281 1
#if defined(UVM)
a282 3
#else
	cnt.v_trap++;
#endif
a520 1
#if defined(UVM)
a521 3
#else
			cnt.v_soft++;
#endif
a528 1
#if defined(UVM)
a529 3
#else
			cnt.v_trap--;
#endif
a597 1
#if defined(UVM)
a598 3
#else
					rv = vm_fault(map, bva, ftype, FALSE);
#endif
a603 1
#if defined(UVM)
a604 3
#else
			rv = vm_fault(map, va, ftype, FALSE);
#endif 
a606 1
#if defined(UVM)
a608 4
#else
				printf("vm_fault(%x, %x, %x, 0) -> %x\n",
					 map, va, ftype, rv);
#endif 
a639 1
#if defined(UVM)
a641 4
#else
				printf("vm_fault(%x, %x, %x, 0) -> %x\n",
					 map, va, ftype, rv);
#endif 
a982 1
#if defined(UVM)
a983 3
#else
	cnt.v_syscall++;
#endif
a1179 1
#if defined(UVM)
a1180 3
#else
	cnt.v_intr++;
#endif
@


1.30
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/05/05 21:26:39 art Exp $ */
d101 3
d183 5
a187 5
register struct proc *p;
register struct frame *fp;
u_quad_t oticks;
u_int faultaddr;
int fromtrap;
d193 1
a193 1
	again:
d224 1
a224 1
						(int)(p->p_sticks - oticks) * psratio);
d240 3
a242 3
						 "pid %d(%s): writeback aborted, pc=%x, fa=%x\n" :
						 "pid %d(%s): writeback aborted in sigreturn, pc=%x\n",
						 p->p_pid, p->p_comm, fp->f_pc, faultaddr);
d265 4
a268 4
int type;
unsigned code;
register unsigned v;
struct frame frame;
d284 3
d288 1
d297 3
a299 3
		default:
			dopanic:
			printf("trap type %d, code = %x, v = %x\n", type, code, v);
d301 2
a302 2
			if (kdb_trap(type, &frame))
				return;
d304 5
a308 5
			regdump(&frame, 128);
			type &= ~T_USER;
			if ((unsigned)type < trap_types)
				panic(trap_type[type]);
			panic("trap");
d310 3
a312 9
		case T_BUSERR:		/* kernel bus error */
			if (!p || !p->p_addr->u_pcb.pcb_onfault)
				goto dopanic;
			/*
			 * If we have arranged to catch this fault in any of the
			 * copy to/from user space routines, set PC to return to
			 * indicated location and set flag informing buserror code
			 * that it may need to clean up stack frame.
			 */
d314 6
d325 38
a362 10
		case T_BUSERR|T_USER:	/* bus error */
			typ = BUS_OBJERR;
			ucode = code & ~T_USER;
			i = SIGBUS;
			break;
		case T_ADDRERR|T_USER:	/* address error */
			typ = BUS_ADRALN;
			ucode = code & ~T_USER;
			i = SIGBUS;
			break;
d364 15
a378 43
		case T_COPERR:		/* kernel coprocessor violation */
		case T_FMTERR|T_USER:	/* do all RTE errors come in as T_USER? */
		case T_FMTERR:		/* ...just in case... */
			/*
			 * The user has most likely trashed the RTE or FP state info
			 * in the stack frame of a signal handler.
			 */
			printf("pid %d: kernel %s exception\n", p->p_pid,
					 type==T_COPERR ? "coprocessor" : "format");
			type |= T_USER;
			p->p_sigacts->ps_sigact[SIGILL] = SIG_DFL;
			i = sigmask(SIGILL);
			p->p_sigignore &= ~i;
			p->p_sigcatch &= ~i;
			p->p_sigmask &= ~i;
			i = SIGILL;
			ucode = frame.f_format;	/* XXX was ILL_RESAD_FAULT */
			typ = ILL_COPROC;
			v = frame.f_pc;
			break;

		case T_COPERR|T_USER:	/* user coprocessor violation */
			/* What is a proper response here? */
			typ = FPE_FLTINV;
			ucode = 0;
			i = SIGFPE;
			break;

		case T_FPERR|T_USER:	/* 68881 exceptions */
			/*
			 * We pass along the 68881 status register which locore stashed
			 * in code for us.  Note that there is a possibility that the
			 * bit pattern of this register will conflict with one of the
			 * FPE_* codes defined in signal.h.  Fortunately for us, the
			 * only such codes we use are all in the range 1-7 and the low
			 * 3 bits of the status register are defined as 0 so there is
			 * no clash.
			 */
			typ = FPE_FLTRES;
			ucode = code;
			i = SIGFPE;
			v = frame.f_pc;
			break;
d381 12
a392 12
		case T_FPEMULI|T_USER:	/* unimplemented FP instuction */
		case T_FPEMULD|T_USER:	/* unimplemented FP data type */
			/* XXX need to FSAVE */
			printf("pid %d(%s): unimplemented FP %s at %x (EA %x)\n",
					 p->p_pid, p->p_comm,
					 frame.f_format == 2 ? "instruction" : "data type",
					 frame.f_pc, frame.f_fmt2.f_iaddr);
			/* XXX need to FRESTORE */
			typ = FPE_FLTINV;
			i = SIGFPE;
			v = frame.f_pc;
			break;
d395 1
a395 1
		case T_ILLINST|T_USER:	/* illegal instruction fault */
d397 3
a399 9
			if (p->p_emul == &emul_hpux) {
				typ = 0;
				ucode = HPUX_ILL_ILLINST_TRAP;
				i = SIGILL;
				break;
			}
#endif
			ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
			typ = ILL_ILLOPC;
a400 1
			v = frame.f_pc;
d402 7
d410 1
a410 1
		case T_PRIVINST|T_USER:	/* privileged instruction fault */
d412 3
a414 3
			if (p->p_emul == &emul_hpux)
				ucode = HPUX_ILL_PRIV_TRAP;
			else
d416 5
a420 5
				ucode	= frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
			typ = ILL_PRVOPC;
			i = SIGILL;
			v = frame.f_pc;
			break;
d422 1
a422 1
		case T_ZERODIV|T_USER:	/* Divide by zero */
d424 3
a426 3
			if (p->p_emul == &emul_hpux)
				ucode = HPUX_FPE_INTDIV_TRAP;
			else
d428 5
a432 5
				ucode	= frame.f_format;	/* XXX was FPE_INTDIV_TRAP */
			typ = FPE_INTDIV;
			i = SIGFPE;
			v = frame.f_pc;
			break;
d434 1
a434 1
		case T_CHKINST|T_USER:	/* CHK instruction trap */
d436 6
a441 6
			if (p->p_emul == &emul_hpux) {
				/* handled differently under hp-ux */
				i = SIGILL;
				ucode = HPUX_ILL_CHK_TRAP;
				break;
			}
d443 5
a447 5
			ucode = frame.f_format;	/* XXX was FPE_SUBRNG_TRAP */
			typ = FPE_FLTSUB;
			i = SIGFPE;
			v = frame.f_pc;
			break;
d449 1
a449 1
		case T_TRAPVINST|T_USER:	/* TRAPV instruction trap */
d451 2
a452 9
			if (p->p_emul == &emul_hpux) {
				/* handled differently under hp-ux */
				i = SIGILL;
				ucode = HPUX_ILL_TRAPV_TRAP;
				break;
			}
#endif
			ucode = frame.f_format;	/* XXX was FPE_INTOVF_TRAP */
			typ = ILL_ILLTRP;
d454 1
a454 1
			v = frame.f_pc;
d456 7
d464 17
a480 17
			/*
			 * XXX: Trace traps are a nightmare.
			 *
			 *	HP-UX uses trap #1 for breakpoints,
			 *	HPBSD uses trap #2,
			 *	SUN 3.x uses trap #15,
			 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere).
			 *
			 * HPBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
			 * SUN 3.x traps get passed through as T_TRAP15 and are not really
			 * supported yet.
			 */
		case T_TRACE:		/* kernel trace trap */
		case T_TRAP15:		/* SUN trace trap */
#ifdef DDB
			if (kdb_trap(type, &frame))
				return;
d482 2
a483 4
			frame.f_sr &= ~PSL_T;
			i = SIGTRAP;
			typ = TRAP_TRACE;
			break;
d485 1
a485 2
		case T_TRACE|T_USER:	/* user trace trap */
		case T_TRAP15|T_USER:	/* SUN user trace trap */
d487 9
a495 11
			/*
			 * SunOS uses Trap #2 for a "CPU cache flush"
			 * Just flush the on-chip caches and return.
			 * XXX - Too bad m68k BSD uses trap 2...
			 */
			if (p->p_emul == &emul_sunos) {
				ICIA();
				DCIU();
				/* get out fast */
				return;
			}
d497 24
a520 4
			frame.f_sr &= ~PSL_T;
			i = SIGTRAP;
			typ = TRAP_TRACE;
			break;
d522 30
a551 2
		case T_ASTFLT:		/* system async trap, cannot happen */
			goto dopanic;
d553 22
a574 12
		case T_ASTFLT|T_USER:	/* user async trap */
			astpending = 0;
			/*
			 * We check for software interrupts first.  This is because
			 * they are at a higher level than ASTs, and on a VAX would
			 * interrupt the AST.  We assume that if we are processing
			 * an AST that we must be at IPL0 so we don't bother to
			 * check.  Note that we ensure that we are at least at SIR
			 * IPL while processing the SIR.
			 */
			spl1();
			/* fall into... */
d576 5
a580 9
		case T_SSIR:		/* software interrupt */
		case T_SSIR|T_USER:
			while (bit = ffs(ssir)) {
				--bit;
				ssir &= ~(1 << bit);
				cnt.v_soft++;
				if (sir_routines[bit])
					sir_routines[bit](sir_args[bit]);
			}
d582 6
a587 1
			 * If this was not an AST trap, we are all done.
d589 11
a599 10
			if (type != (T_ASTFLT|T_USER)) {
				cnt.v_trap--;
				return;
			}
			spl0();
			if (p->p_flag & P_OWEUPC) {
				p->p_flag &= ~P_OWEUPC;
				ADDUPROF(p);
			}
			goto out;
d601 3
a603 8
		case T_MMUFLT:		/* kernel mode page fault */
			/*
			 * If we were doing profiling ticks or other user mode
			 * stuff from interrupt code, Just Say No.
			 */
			if (p && (p->p_addr->u_pcb.pcb_onfault == fubail ||
						 p->p_addr->u_pcb.pcb_onfault == subail)) {
            goto copyfault;
d605 3
a607 1
			/* fall into ... */
d609 10
a618 41
		case T_MMUFLT|T_USER:	/* page fault */
			{
				register vm_offset_t va;
				register struct vmspace *vm = NULL;
				register vm_map_t map;
				int rv;
				vm_prot_t ftype, vftype;
				extern vm_map_t kernel_map;

				/* vmspace only significant if T_USER */
				if (p)
					vm = p->p_vmspace;

#ifdef DEBUG
				if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
					printf("trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n",
							 p->p_pid, code, v, frame.f_pc, frame.f_sr);
#endif
				/*
				 * It is only a kernel address space fault iff:
				 * 	1. (type & T_USER) == 0  and
				 * 	2. pcb_onfault not set or
				 *	3. pcb_onfault set but supervisor space data fault
				 * The last can occur during an exec() copyin where the
				 * argument space is lazy-allocated.
				 */
				if (type == T_MMUFLT &&
					 ((p && !p->p_addr->u_pcb.pcb_onfault) || KDFAULT(code)))
					map = kernel_map;
				else
					map = &vm->vm_map;
				if (WRFAULT(code)) {
					vftype = VM_PROT_WRITE;
					ftype = VM_PROT_READ | VM_PROT_WRITE;
				} else
					vftype = ftype = VM_PROT_READ;
				va = trunc_page((vm_offset_t)v);

				if (map == kernel_map && va == 0) {
					printf("trap: bad kernel access at %x\n", v);
					goto dopanic;
d620 1
a620 12
#ifdef COMPAT_HPUX
				if (ISHPMMADDR(va)) {
					vm_offset_t bva;

					rv = pmap_mapmulti(map->pmap, va);
					if (rv != KERN_SUCCESS) {
						bva = HPMMBASEADDR(va);
						rv = vm_fault(map, bva, ftype, FALSE);
						if (rv == KERN_SUCCESS)
							(void) pmap_mapmulti(map->pmap, va);
					}
				} else
d622 5
a626 1
					rv	= vm_fault(map, va, ftype, FALSE);
d628 17
a644 21
				if (rv && MDB_ISPID(p->p_pid))
					printf("vm_fault(%x, %x, %x, 0) -> %x\n",
							 map, va, ftype, rv);
#endif
				/*
				 * If this was a stack access we keep track of the maximum
				 * accessed stack size.  Also, if vm_fault gets a protection
				 * failure it is due to accessing the stack region outside
				 * the current limit and we need to reflect that as an access
				 * error.
				 */
				if ((caddr_t)va >= vm->vm_maxsaddr && map != kernel_map) {
					if (rv == KERN_SUCCESS) {
						unsigned nss;

						nss = btoc(USRSTACK-(unsigned)va);
						if (nss > vm->vm_ssize)
							vm->vm_ssize = nss;
					} else if (rv == KERN_PROTECTION_FAILURE)
						rv = KERN_INVALID_ADDRESS;
				}
d646 10
a655 1
					if (type == T_MMUFLT) {
d657 2
a658 2
						if (mmutype == MMU_68040)
							(void) writeback(&frame, 1);
d660 1
a660 3
						return;
					}
					goto out;
d662 15
a676 14
				if (type == T_MMUFLT) {
					if (p && p->p_addr->u_pcb.pcb_onfault)
                  goto copyfault;
					printf("vm_fault(%x, %x, %x, 0) -> %x\n",
							 map, va, ftype, rv);
					printf("  type %x, code [mmu,,ssw]: %x\n",
							 type, code);
					goto dopanic;
				}
				frame.f_pad = code & 0xffff;
				ucode = vftype;
				typ = SEGV_MAPERR;
				i = SIGSEGV;
				break;
d678 6
d689 1
a689 1
	out:
d713 2
a714 2
struct frame *fp;
int docachepush;
d760 1
a760 1
						  trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE, TRUE, VM_PROT_WRITE);
d949 1
d951 1
a951 1
register u_short ssw;
d976 1
d978 3
a980 3
int num;
u_short s;
u_int a, d;
d1002 2
a1003 2
register_t code;
struct frame frame;
d1015 3
a1017 1

d1019 2
d1064 20
a1083 25
		case SYS_syscall:
			/*
			 * Code is first argument, followed by actual args.
			 */
			code = fuword(params);
			params += sizeof(int);
			/*
			 * XXX sigreturn requires special stack manipulation
			 * that is only done if entered via the sigreturn
			 * trap.  Cannot allow it here so make sure we fail.
			 */
			if (code == SYS_sigreturn)
				code = nsys;
			break;
		case SYS___syscall:
			/*
			 * Like syscall, but code is a quad, so as to maintain
			 * quad alignment for the rest of the arguments.
			 */
			if (callp != sysent)
				break;
			code = fuword(params + _QUAD_LOWWORD * sizeof(int));
			params += sizeof(quad_t);
			break;
		default:
d1085 5
d1113 22
a1134 22
		case 0:
			frame.f_regs[D0] = rval[0];
			frame.f_regs[D1] = rval[1];
			frame.f_sr &= ~PSL_C;	/* carry bit */
			break;
		case ERESTART:
			/*
			 * We always enter through a `trap' instruction, which is 2
			 * bytes, so adjust the pc by that amount.
			 */
			frame.f_pc = opc - 2;
			break;
		case EJUSTRETURN:
			/* nothing to do */
			break;
		default:
			bad:
			if (p->p_emul->e_errno)
				error = p->p_emul->e_errno[error];
			frame.f_regs[D0] = error;
			frame.f_sr |= PSL_C;	/* carry bit */
			break;
d1154 2
a1155 2
struct proc *p;
struct frame frame;
d1174 2
a1175 2
void (*proc)();
void *arg;
d1206 3
a1208 3
int pc;
int evec;
void *frame;
d1216 3
d1220 1
d1245 1
a1245 1
int start, end;
d1266 2
a1267 2
int vec;
struct intrhand *ih;
@


1.29
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2001/05/05 20:56:45 art Exp $ */
d726 2
d732 2
a733 1
			DCFL(pmap_extract(pmap_kernel(), (vm_offset_t)fa));
d956 1
a956 2
	pa = pmap_extract(p->p_vmspace->vm_map.pmap, (vm_offset_t)a);
	if (pa == 0)
@


1.28
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/04/05 20:39:40 deraadt Exp $ */
d727 1
a727 1
						  trunc_page(f->f_fa), VM_PROT_WRITE, TRUE, VM_PROT_WRITE);
@


1.27
log
@undo changes which did not even compile
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2000/11/10 18:15:39 art Exp $ */
d622 1
a622 1
						nss = clrnd(btoc(USRSTACK-(unsigned)va));
@


1.26
log
@Initial code for UVM.  not tested yet...
@
text
@a100 3
#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif
a280 3
#if defined(UVM)
	uvmexp.traps++;
#else
a281 1
#endif
a520 3
#if defined(UVM)
				uvmexp.softs++;
#else
a521 1
#endif
a598 3
#if defined(UVM)
						rv = uvm_fault(map, bva, 0, ftype);
#else
a599 1
#endif
d605 1
a605 5
#if defined(UVM)
					rv = uvm_fault(map, va, 0, ftype);
#else
					rv = vm_fault(map, va, ftype, FALSE);
#endif 
a607 4
#if defined(UVM)
					printf("uvm_fault(%x, %x, 0, %x) -> %x\n",
							 map, va, ftype, rv);
#else
a609 1
#endif 
d640 1
a640 5
						goto copyfault;
#if defined(UVM)
					printf("uvm_fault(%x, %x, 0, %x) -> %x\n",
							 map, va, ftype, rv);
#else
a642 1
#endif 
d980 1
a980 3
#if defined(UVM)
	uvmexp.syscalls++;
#else
a981 2
#endif
	
@


1.25
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2000/06/07 15:49:40 art Exp $ */
d101 3
d284 3
d288 1
d528 3
d532 1
d610 3
d614 1
d620 5
a624 1
					rv	= vm_fault(map, va, ftype, FALSE);
d627 4
d633 1
d664 5
a668 1
                  goto copyfault;
d671 1
d1009 3
a1011 1

d1013 2
@


1.24
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2000/01/06 03:21:43 smurph Exp $ */
d1066 1
a1066 1
		ktrsyscall(p->p_tracep, code, argsize, args);
d1109 1
a1109 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d1126 1
a1126 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.23
log
@Added support for MVME177 (mc68060)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 1999/09/27 20:30:32 smurph Exp $ */
d953 1
a953 1
	pa = pmap_extract(&p->p_vmspace->vm_pmap, (vm_offset_t)a);
@


1.23.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/04/05 20:39:40 deraadt Exp $ */
d953 1
a953 1
	pa = pmap_extract(p->p_vmspace->vm_map.pmap, (vm_offset_t)a);
d1066 1
a1066 1
		ktrsyscall(p, code, argsize, args);
d1109 1
a1109 1
		ktrsysret(p, code, error, rval[0]);
d1126 1
a1126 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.23.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23.2.1 2001/04/18 16:10:41 niklas Exp $ */
a100 1
#include <uvm/uvm_extern.h>
d180 5
a184 5
	register struct proc *p;
	register struct frame *fp;
	u_quad_t oticks;
	u_int faultaddr;
	int fromtrap;
d190 1
a190 1
again:
d221 1
a221 1
			    (int)(p->p_sticks - oticks) * psratio);
d237 3
a239 3
			 "pid %d(%s): writeback aborted, pc=%x, fa=%x\n" :
			 "pid %d(%s): writeback aborted in sigreturn, pc=%x\n",
				     p->p_pid, p->p_comm, fp->f_pc, faultaddr);
d262 4
a265 4
	int type;
	unsigned code;
	register unsigned v;
	struct frame frame;
d281 1
a281 1
	uvmexp.traps++;
d290 3
a292 3
	default:
dopanic:
		printf("trap type %d, code = %x, v = %x\n", type, code, v);
d294 2
a295 2
		if (kdb_trap(type, &frame))
			return;
d297 5
a301 5
		regdump(&frame, 128);
		type &= ~T_USER;
		if ((unsigned)type < trap_types)
			panic(trap_type[type]);
		panic("trap");
d303 9
a311 3
	case T_BUSERR:		/* kernel bus error */
		if (!p || !p->p_addr->u_pcb.pcb_onfault)
			goto dopanic;
a312 6
		/*
		 * If we have arranged to catch this fault in any of the
		 * copy to/from user space routines, set PC to return to
		 * indicated location and set flag informing buserror code
		 * that it may need to clean up stack frame.
		 */
d318 38
a355 38
	case T_BUSERR|T_USER:	/* bus error */
		typ = BUS_OBJERR;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;
	case T_ADDRERR|T_USER:	/* address error */
		typ = BUS_ADRALN;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;

	case T_COPERR:		/* kernel coprocessor violation */
	case T_FMTERR|T_USER:	/* do all RTE errors come in as T_USER? */
	case T_FMTERR:		/* ...just in case... */
		/*
		 * The user has most likely trashed the RTE or FP state info
		 * in the stack frame of a signal handler.
		 */
		printf("pid %d: kernel %s exception\n", p->p_pid,
				 type==T_COPERR ? "coprocessor" : "format");
		type |= T_USER;
		p->p_sigacts->ps_sigact[SIGILL] = SIG_DFL;
		i = sigmask(SIGILL);
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
		p->p_sigmask &= ~i;
		i = SIGILL;
		ucode = frame.f_format;	/* XXX was ILL_RESAD_FAULT */
		typ = ILL_COPROC;
		v = frame.f_pc;
		break;

	case T_COPERR|T_USER:	/* user coprocessor violation */
		/* What is a proper response here? */
		typ = FPE_FLTINV;
		ucode = 0;
		i = SIGFPE;
		break;
d357 15
a371 15
	case T_FPERR|T_USER:	/* 68881 exceptions */
		/*
		 * We pass along the 68881 status register which locore stashed
		 * in code for us.  Note that there is a possibility that the
		 * bit pattern of this register will conflict with one of the
		 * FPE_* codes defined in signal.h.  Fortunately for us, the
		 * only such codes we use are all in the range 1-7 and the low
		 * 3 bits of the status register are defined as 0 so there is
		 * no clash.
		 */
		typ = FPE_FLTRES;
		ucode = code;
		i = SIGFPE;
		v = frame.f_pc;
		break;
d374 12
a385 12
	case T_FPEMULI|T_USER:	/* unimplemented FP instuction */
	case T_FPEMULD|T_USER:	/* unimplemented FP data type */
		/* XXX need to FSAVE */
		printf("pid %d(%s): unimplemented FP %s at %x (EA %x)\n",
				 p->p_pid, p->p_comm,
				 frame.f_format == 2 ? "instruction" : "data type",
				 frame.f_pc, frame.f_fmt2.f_iaddr);
		/* XXX need to FRESTORE */
		typ = FPE_FLTINV;
		i = SIGFPE;
		v = frame.f_pc;
		break;
d388 1
a388 1
	case T_ILLINST|T_USER:	/* illegal instruction fault */
d390 9
a398 3
		if (p->p_emul == &emul_hpux) {
			typ = 0;
			ucode = HPUX_ILL_ILLINST_TRAP;
d400 1
a401 7
		}
#endif
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_ILLOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;
d403 1
a403 1
	case T_PRIVINST|T_USER:	/* privileged instruction fault */
d405 3
a407 3
		if (p->p_emul == &emul_hpux)
			ucode = HPUX_ILL_PRIV_TRAP;
		else
d409 5
a413 5
		ucode	= frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_PRVOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;
d415 1
a415 1
	case T_ZERODIV|T_USER:	/* Divide by zero */
d417 3
a419 3
		if (p->p_emul == &emul_hpux)
			ucode = HPUX_FPE_INTDIV_TRAP;
		else
d421 5
a425 5
		ucode	= frame.f_format;	/* XXX was FPE_INTDIV_TRAP */
		typ = FPE_INTDIV;
		i = SIGFPE;
		v = frame.f_pc;
		break;
d427 1
a427 1
	case T_CHKINST|T_USER:	/* CHK instruction trap */
d429 11
a439 4
		if (p->p_emul == &emul_hpux) {
			/* handled differently under hp-ux */
			i = SIGILL;
			ucode = HPUX_ILL_CHK_TRAP;
a440 7
		}
#endif
		ucode = frame.f_format;	/* XXX was FPE_SUBRNG_TRAP */
		typ = FPE_FLTSUB;
		i = SIGFPE;
		v = frame.f_pc;
		break;
d442 1
a442 1
	case T_TRAPVINST|T_USER:	/* TRAPV instruction trap */
d444 9
a452 2
		if (p->p_emul == &emul_hpux) {
			/* handled differently under hp-ux */
d454 1
a454 1
			ucode = HPUX_ILL_TRAPV_TRAP;
a455 7
		}
#endif
		ucode = frame.f_format;	/* XXX was FPE_INTOVF_TRAP */
		typ = ILL_ILLTRP;
		i = SIGILL;
		v = frame.f_pc;
		break;
d457 17
a473 17
		/*
		 * XXX: Trace traps are a nightmare.
		 *
		 *	HP-UX uses trap #1 for breakpoints,
		 *	OpenBSD/m68k uses trap #2,
		 *	SUN 3.x uses trap #15,
		 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere).
		 *
		 * OpenBSD and HP-UX traps both get mapped by locore.s into
		 * T_TRACE.
		 * SUN 3.x traps get passed through as T_TRAP15 and are not really
		 * supported yet.
		 */
	case T_TRAP15:		/* kernel breakpoint */
#ifdef DEBUG
		printf("unexpected kernel trace trap, type = %d\n", type);
		printf("program counter = 0x%x\n", frame.f_pc);
d475 4
a478 2
		frame.f_sr &= ~PSL_T;
		return;
d480 2
a481 1
	case T_TRACE|T_USER:	/* user trace trap */
d483 11
a493 9
		/*
		 * SunOS uses Trap #2 for a "CPU cache flush"
		 * Just flush the on-chip caches and return.
		 */
		if (p->p_emul == &emul_sunos) {
			ICIA();
			DCIU();
			return;
		}
d495 4
a498 1
		/* FALLTHROUGH */
d500 2
a501 6
	case T_TRACE:
	case T_TRAP15|T_USER:	/* SUN user trace trap */
		frame.f_sr &= ~PSL_T;
		i = SIGTRAP;
		typ = TRAP_TRACE;
		break;
d503 12
a514 2
	case T_ASTFLT:		/* system async trap, cannot happen */
		goto dopanic;
d516 22
a537 12
	case T_ASTFLT|T_USER:	/* user async trap */
		astpending = 0;
		/*
		 * We check for software interrupts first.  This is because
		 * they are at a higher level than ASTs, and on a VAX would
		 * interrupt the AST.  We assume that if we are processing
		 * an AST that we must be at IPL0 so we don't bother to
		 * check.  Note that we ensure that we are at least at SIR
		 * IPL while processing the SIR.
		 */
		spl1();
		/* FALLTHROUGH */
d539 10
a548 22
	case T_SSIR:		/* software interrupt */
	case T_SSIR|T_USER:
		while (bit = ffs(ssir)) {
			--bit;
			ssir &= ~(1 << bit);
			uvmexp.softs++;
			if (sir_routines[bit])
				sir_routines[bit](sir_args[bit]);
		}
		/*
		 * If this was not an AST trap, we are all done.
		 */
		if (type != (T_ASTFLT|T_USER)) {
			uvmexp.traps--;
			return;
		}
		spl0();
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		goto out;
d550 12
a561 22
	case T_MMUFLT:		/* kernel mode page fault */
		/*
		 * If we were doing profiling ticks or other user mode
		 * stuff from interrupt code, Just Say No.
		 */
		if (p && (p->p_addr->u_pcb.pcb_onfault == fubail ||
		    p->p_addr->u_pcb.pcb_onfault == subail))
			goto copyfault;
		/* FALLTHROUGH */

	case T_MMUFLT|T_USER:	/* page fault */
		{
			register vm_offset_t va;
			register struct vmspace *vm = NULL;
			register vm_map_t map;
			int rv;
			vm_prot_t ftype, vftype;
			extern vm_map_t kernel_map;

			/* vmspace only significant if T_USER */
			if (p)
				vm = p->p_vmspace;
d564 28
a591 28
			if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
				printf("trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n",
				    p->p_pid, code, v, frame.f_pc, frame.f_sr);
#endif
			/*
			 * It is only a kernel address space fault iff:
			 * 	1. (type & T_USER) == 0  and
			 * 	2. pcb_onfault not set or
			 *	3. pcb_onfault set but supervisor space data fault
			 * The last can occur during an exec() copyin where the
			 * argument space is lazy-allocated.
			 */
			if (type == T_MMUFLT &&
			    ((p && !p->p_addr->u_pcb.pcb_onfault) || KDFAULT(code)))
				map = kernel_map;
			else
				map = &vm->vm_map;
			if (WRFAULT(code)) {
				vftype = VM_PROT_WRITE;
				ftype = VM_PROT_READ | VM_PROT_WRITE;
			} else
				vftype = ftype = VM_PROT_READ;
			va = trunc_page((vm_offset_t)v);

			if (map == kernel_map && va == 0) {
				printf("trap: bad kernel access at %x\n", v);
				goto dopanic;
			}
d593 2
a594 2
			if (ISHPMMADDR(va)) {
				vm_offset_t bva;
d596 8
a603 8
				rv = pmap_mapmulti(map->pmap, va);
				if (rv != KERN_SUCCESS) {
					bva = HPMMBASEADDR(va);
					rv = uvm_fault(map, bva, 0, ftype);
					if (rv == KERN_SUCCESS)
						(void) pmap_mapmulti(map->pmap, va);
				}
			} else
d605 1
a605 1
			rv = uvm_fault(map, va, 0, ftype);
d607 21
a627 12
			if (rv && MDB_ISPID(p->p_pid))
				printf("uvm_fault(%x, %x, 0, %x) -> %x\n",
					 map, va, ftype, rv);
#endif
			/*
			 * If this was a stack access we keep track of the maximum
			 * accessed stack size.  Also, if vm_fault gets a protection
			 * failure it is due to accessing the stack region outside
			 * the current limit and we need to reflect that as an access
			 * error.
			 */
			if ((caddr_t)va >= vm->vm_maxsaddr && map != kernel_map) {
d629 1
a629 10
					unsigned nss;

					nss = btoc(USRSTACK-(unsigned)va);
					if (nss > vm->vm_ssize)
						vm->vm_ssize = nss;
				} else if (rv == KERN_PROTECTION_FAILURE)
					rv = KERN_INVALID_ADDRESS;
			}
			if (rv == KERN_SUCCESS) {
				if (type == T_MMUFLT) {
d631 2
a632 2
					if (mmutype == MMU_68040)
						(void) writeback(&frame, 1);
d634 12
a645 1
					return;
d647 5
a651 10
				goto out;
			}
			if (type == T_MMUFLT) {
				if (p && p->p_addr->u_pcb.pcb_onfault)
					goto copyfault;
				printf("uvm_fault(%x, %x, 0, %x) -> %x\n",
					 map, va, ftype, rv);
				printf("  type %x, code [mmu,,ssw]: %x\n",
					 type, code);
				goto dopanic;
a652 6
			frame.f_pad = code & 0xffff;
			ucode = vftype;
			typ = SEGV_MAPERR;
			i = SIGSEGV;
			break;
		}
d658 1
a658 1
out:
d682 2
a683 2
	struct frame *fp;
	int docachepush;
a725 2
			paddr_t pa;

d730 1
a730 2
			pmap_extract(pmap_kernel(), (vm_offset_t)fa, &pa);
			DCFL(pa);
a914 1
void
d916 1
a916 1
	register u_short ssw;
a940 1
void
d942 3
a944 3
	int num;
	u_short s;
	u_int a, d;
d953 2
a954 1
	if (pmap_extract(p->p_vmspace->vm_map.pmap, (vm_offset_t)a, &pa) == FALSE)
d967 2
a968 2
	register_t code;
	struct frame frame;
d980 2
a981 2
	uvmexp.syscalls++;
	
d1025 25
a1049 20
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		code = fuword(params);
		params += sizeof(int);
		/*
		 * XXX sigreturn requires special stack manipulation
		 * that is only done if entered via the sigreturn
		 * trap.  Cannot allow it here so make sure we fail.
		 */
		if (code == SYS_sigreturn)
			code = nsys;
		break;
	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
a1050 5
		code = fuword(params + _QUAD_LOWWORD * sizeof(int));
		params += sizeof(quad_t);
		break;
	default:
		break;
d1074 22
a1095 22
	case 0:
		frame.f_regs[D0] = rval[0];
		frame.f_regs[D1] = rval[1];
		frame.f_sr &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/*
		 * We always enter through a `trap' instruction, which is 2
		 * bytes, so adjust the pc by that amount.
		 */
		frame.f_pc = opc - 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
bad:
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		frame.f_regs[D0] = error;
		frame.f_sr |= PSL_C;	/* carry bit */
		break;
d1115 2
a1116 2
	struct proc *p;
	struct frame frame;
d1135 2
a1136 2
	void (*proc)();
	void *arg;
d1167 3
a1169 3
	int pc;
	int evec;
	void *frame;
d1177 1
a1177 1
	uvmexp.intrs++;
d1202 1
a1202 1
	int start, end;
d1223 2
a1224 2
	int vec;
	struct intrhand *ih;
@


1.23.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23.2.2 2001/07/04 10:19:42 niklas Exp $ */
d187 1
a187 1
	int sig;
d199 12
a210 3
		 * We're being preempted.
		 */
		preempt(NULL);
d298 1
a298 1
		regdump(&(frame.F_t), 128);
d728 1
a728 1
						  trunc_page(f->f_fa), VM_PROT_WRITE, VM_PROT_WRITE|PMAP_WIRED);
@


1.23.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d99 2
a101 1
#include <uvm/uvm_pmap.h>
d172 1
a172 1
void userret __P((struct proc *p, struct frame *fp,
d179 1
a179 1
void
d1104 17
@


1.23.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23.2.4 2001/11/13 21:04:14 niklas Exp $ */
d171 3
d541 3
a543 3
			vm_offset_t va;
			struct vmspace *vm = NULL;
			struct vm_map *map;
d546 1
a546 1
			extern struct vm_map *kernel_map;
d586 1
a586 1
				if (rv) {
d589 1
a589 1
					if (rv == 0)
d608 1
a608 1
				if (rv == 0) {
d614 2
a615 2
				} else if (rv == EACCES)
					rv = EFAULT;
d617 1
a617 1
			if (rv == 0) {
d1099 1
a1099 1
	userret(p, &frame, sticks, 0, 0);
@


1.23.2.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a715 1
			pmap_update(pmap_kernel());
a721 1
			pmap_update(pmap_kernel());
@


1.23.2.7
log
@Merge in -current from about a week ago
@
text
@d169 1
a169 1
int  writeback(struct frame *fp, int docachepush);
@


1.23.2.8
log
@Sync the SMP branch with 3.3
@
text
@d89 2
a90 1
#include <machine/db_machdep.h>
a91 1
#include <machine/psl.h>
a92 1
#include <machine/trap.h>
a98 3
#include "systrace.h"
#include <dev/systrace.h>

a105 3
int	astpending;
int	want_resched;

d165 1
a165 1
void (*sir_routines[NSIR])(void *);
d169 1
a169 5
void trap(int, u_int, u_int, struct frame);
void syscall(register_t, struct frame);
void init_sir(void);
void hardintr(int, int, void *);
int writeback(struct frame *fp, int docachepush);
d184 1
a184 1
#if defined(M68040)
d217 1
a217 1
	 * we just return to the user without successfully completing
d229 1
a229 1
		} else if ((sig = writeback(fp, fromtrap))) {
a248 1
void
d251 2
a252 2
	u_int code;
	register u_int v;
d255 1
d282 1
a282 1
		if (kdb_trap(type, (db_regs_t *)&frame))
d287 1
a287 1
		if ((u_int)type < trap_types)
d505 1
a505 1
		while ((bit = ffs(ssir))) {
d527 9
d606 1
a606 1
					u_int nss;
d608 1
a608 1
					nss = btoc(USRSTACK-(u_int)va);
d725 1
a725 1
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
d760 2
a761 2
		u_int wb1d = f->f_wb1d;
		int off;
d777 1
a777 2
					err = copyout(&wb1d,
					    (caddr_t)f->f_wb1a, sizeof(int));
d785 2
a786 6
				else {
					char tmp = wb1d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb1a, sizeof(char));
				}
d794 2
a795 6
				else {
					short tmp = wb1d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb1a, sizeof(long));
				}
d827 1
a827 2
					err = copyout(&f->f_wb2d,
					    (caddr_t)f->f_wb2a, sizeof(int));
d832 2
a833 6
				else {
					char tmp = f->f_wb2d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb2a, sizeof(char));
				}
d838 2
a839 6
				else {
					short tmp = f->f_wb2d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb2a, sizeof(short));
				}
d867 1
a867 2
					err = copyout(&f->f_wb3d,
					    (caddr_t)f->f_wb3a, sizeof(int));
d872 2
a873 6
				else {
					char tmp = f->f_wb3d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb3a, sizeof(char));
				}
d878 2
a879 6
				else {
					short tmp = f->f_wb3d;

					err = copyout(&tmp,
					    (caddr_t)f->f_wb3a, sizeof(short));
				}
a940 1
	int tmp;
d948 2
a949 6
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
a957 1
void
d993 1
a993 3
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		    sizeof(register_t)) != 0)
			code = -1;
d1021 1
a1021 2
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
d1038 1
a1038 3
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
d1064 1
a1064 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
d1110 1
a1110 1
	void (*proc)(void *);
d1126 1
a1126 1
	extern void netintr(void *);
d1129 1
a1129 1
	sir_routines[1] = (void (*)(void *))softclock;
d1140 1
a1140 1
void
a1145 1
	extern void straytrap(int, u_short);
d1147 1
a1147 1
	/*extern u_long intrcnt[];*/	/* XXX from locore */
d1161 1
a1161 1
		r = (*ih->ih_fn)(ih->ih_wantframe ? frame : ih->ih_arg);
d1165 2
a1166 4
	if (count != 0)
		return;

	straytrap(pc, evec);
d1213 1
a1213 1
	if ((ihx = intrs[vec])) {
a1226 4
void db_prom_cmd(db_expr_t, int, db_expr_t, char *);
void db_machine_init(void);

/* ARGSUSED */
d1228 1
a1228 5
db_prom_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
@


1.23.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23.2.8 2003/03/27 23:32:17 niklas Exp $ */
d15 6
d50 5
a54 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.23.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d363 1
a363 1
	case T_FPEMULI|T_USER:	/* unimplemented FP instruction */
d619 1
a619 1
				printf("uvm_fault(%p, %lx, 0, %x) -> %x\n",
a633 1
out:
d636 1
@


1.23.2.11
log
@Merge with the trunk
@
text
@d558 1
a558 1
				map = vm ? &vm->vm_map : kernel_map;
d596 1
a596 2
			if ((vm != NULL && (caddr_t)va >= vm->vm_maxsaddr)
			    && map != kernel_map) {
@


1.22
log
@This gets us to 2.6...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 1998/04/03 03:47:42 deraadt Exp $ */
d5 1
d106 1
a106 1
char	*trap_type[] = {
d122 1
a122 1
int	trap_types = sizeof trap_type / sizeof trap_type[0];
d127 2
a128 2
short	exframesize[] = {
	FMT0SIZE,	/* type 0 - normal (68020/030/040) */
d130 4
a133 3
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040) */
	FMT3SIZE,	/* type 3 - FP post-instruction (68040) */
	-1, -1, -1,	/* type 4-6 - undefined */
d135 1
a135 1
	58,		/* type 8 - bus fault (68010) */
d142 4
a145 3
#ifdef M68040
#define KDFAULT(c)    (mmutype == MMU_68040 ? \
			    ((c) & SSW4_TMMASK) == SSW4_TMKD : \
d147 2
a148 2
#define WRFAULT(c)    (mmutype == MMU_68040 ? \
			    ((c) & SSW4_RW) == 0 : \
d169 2
a170 1
int writeback __P((struct frame *fp, int docachepush));
d172 1
a172 1
    u_quad_t oticks, u_int faultaddr, int fromtrap));
d180 5
a184 5
	register struct proc *p;
	register struct frame *fp;
	u_quad_t oticks;
	u_int faultaddr;
	int fromtrap;
d187 1
a187 1
#ifdef M68040
d190 1
a190 1
again:
d220 2
a221 2
		addupc_task(p, fp->f_pc,
			    (int)(p->p_sticks - oticks) * psratio);
d223 1
a223 1
#ifdef M68040
d237 3
a239 3
		"pid %d(%s): writeback aborted, pc=%x, fa=%x\n" :
		"pid %d(%s): writeback aborted in sigreturn, pc=%x\n",
				    p->p_pid, p->p_comm, fp->f_pc, faultaddr);
d258 1
a258 1
 * System calls are broken out for efficiency.
d262 4
a265 4
	int type;
	unsigned code;
	register unsigned v;
	struct frame frame;
d290 3
a292 4

	default:
dopanic:
		printf("trap type %d, code = %x, v = %x\n", type, code, v);
d294 2
a295 2
		if (kdb_trap(type, &frame))
			return;
d297 52
a348 5
		regdump(&frame, 128);
		type &= ~T_USER;
		if ((unsigned)type < trap_types)
			panic(trap_type[type]);
		panic("trap");
d350 6
a355 14
	case T_BUSERR:		/* kernel bus error */
		if (!p || !p->p_addr->u_pcb.pcb_onfault)
			goto dopanic;
		/*
		 * If we have arranged to catch this fault in any of the
		 * copy to/from user space routines, set PC to return to
		 * indicated location and set flag informing buserror code
		 * that it may need to clean up stack frame.
		 */
copyfault:
		frame.f_stackadj = exframesize[frame.f_format];
		frame.f_format = frame.f_vector = 0;
		frame.f_pc = (int) p->p_addr->u_pcb.pcb_onfault;
		return;
d357 15
a371 38
	case T_BUSERR|T_USER:	/* bus error */
		typ = BUS_OBJERR;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;
	case T_ADDRERR|T_USER:	/* address error */
		typ = BUS_ADRALN;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;

	case T_COPERR:		/* kernel coprocessor violation */
	case T_FMTERR|T_USER:	/* do all RTE errors come in as T_USER? */
	case T_FMTERR:		/* ...just in case... */
	/*
	 * The user has most likely trashed the RTE or FP state info
	 * in the stack frame of a signal handler.
	 */
		printf("pid %d: kernel %s exception\n", p->p_pid,
		       type==T_COPERR ? "coprocessor" : "format");
		type |= T_USER;
		p->p_sigacts->ps_sigact[SIGILL] = SIG_DFL;
		i = sigmask(SIGILL);
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
		p->p_sigmask &= ~i;
		i = SIGILL;
		ucode = frame.f_format;	/* XXX was ILL_RESAD_FAULT */
		typ = ILL_COPROC;
		v = frame.f_pc;
		break;

	case T_COPERR|T_USER:	/* user coprocessor violation */
	/* What is a proper response here? */
		typ = FPE_FLTINV;
		ucode = 0;
		i = SIGFPE;
		break;
d373 13
a385 29
	case T_FPERR|T_USER:	/* 68881 exceptions */
	/*
	 * We pass along the 68881 status register which locore stashed
	 * in code for us.  Note that there is a possibility that the
	 * bit pattern of this register will conflict with one of the
	 * FPE_* codes defined in signal.h.  Fortunately for us, the
	 * only such codes we use are all in the range 1-7 and the low
	 * 3 bits of the status register are defined as 0 so there is
	 * no clash.
	 */
		typ = FPE_FLTRES;
		ucode = code;
		i = SIGFPE;
		v = frame.f_pc;
		break;

#ifdef M68040
	case T_FPEMULI|T_USER:	/* unimplemented FP instuction */
	case T_FPEMULD|T_USER:	/* unimplemented FP data type */
		/* XXX need to FSAVE */
		printf("pid %d(%s): unimplemented FP %s at %x (EA %x)\n",
		       p->p_pid, p->p_comm,
		       frame.f_format == 2 ? "instruction" : "data type",
		       frame.f_pc, frame.f_fmt2.f_iaddr);
		/* XXX need to FRESTORE */
		typ = FPE_FLTINV;
		i = SIGFPE;
		v = frame.f_pc;
		break;
d388 1
a388 1
	case T_ILLINST|T_USER:	/* illegal instruction fault */
d390 9
a398 3
		if (p->p_emul == &emul_hpux) {
			typ = 0;
			ucode = HPUX_ILL_ILLINST_TRAP;
d400 1
a401 7
		}
#endif
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_ILLOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;
d403 1
a403 1
	case T_PRIVINST|T_USER:	/* privileged instruction fault */
d405 3
a407 3
		if (p->p_emul == &emul_hpux)
			ucode = HPUX_ILL_PRIV_TRAP;
		else
d409 5
a413 5
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_PRVOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;
d415 1
a415 1
	case T_ZERODIV|T_USER:	/* Divide by zero */
d417 3
a419 3
		if (p->p_emul == &emul_hpux)
			ucode = HPUX_FPE_INTDIV_TRAP;
		else
d421 5
a425 5
		ucode = frame.f_format;	/* XXX was FPE_INTDIV_TRAP */
		typ = FPE_INTDIV;
		i = SIGFPE;
		v = frame.f_pc;
		break;
d427 1
a427 1
	case T_CHKINST|T_USER:	/* CHK instruction trap */
d429 11
a439 4
		if (p->p_emul == &emul_hpux) {
			/* handled differently under hp-ux */
			i = SIGILL;
			ucode = HPUX_ILL_CHK_TRAP;
a440 7
		}
#endif
		ucode = frame.f_format;	/* XXX was FPE_SUBRNG_TRAP */
		typ = FPE_FLTSUB;
		i = SIGFPE;
		v = frame.f_pc;
		break;
d442 1
a442 1
	case T_TRAPVINST|T_USER:	/* TRAPV instruction trap */
d444 9
a452 2
		if (p->p_emul == &emul_hpux) {
			/* handled differently under hp-ux */
d454 1
a454 1
			ucode = HPUX_ILL_TRAPV_TRAP;
a455 7
		}
#endif
		ucode = frame.f_format;	/* XXX was FPE_INTOVF_TRAP */
		typ = ILL_ILLTRP;
		i = SIGILL;
		v = frame.f_pc;
		break;
d457 14
a470 14
	/*
	 * XXX: Trace traps are a nightmare.
	 *
	 *	HP-UX uses trap #1 for breakpoints,
	 *	HPBSD uses trap #2,
	 *	SUN 3.x uses trap #15,
	 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere).
	 *
	 * HPBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
	 * SUN 3.x traps get passed through as T_TRAP15 and are not really
	 * supported yet.
	 */
	case T_TRACE:		/* kernel trace trap */
	case T_TRAP15:		/* SUN trace trap */
d472 2
a473 2
		if (kdb_trap(type, &frame))
			return;
d475 4
a478 4
		frame.f_sr &= ~PSL_T;
		i = SIGTRAP;
		typ = TRAP_TRACE;
		break;
d480 2
a481 2
	case T_TRACE|T_USER:	/* user trace trap */
	case T_TRAP15|T_USER:	/* SUN user trace trap */
d483 11
a493 11
		/*
		 * SunOS uses Trap #2 for a "CPU cache flush"
		 * Just flush the on-chip caches and return.
		 * XXX - Too bad m68k BSD uses trap 2...
		 */
		if (p->p_emul == &emul_sunos) {
			ICIA();
			DCIU();
			/* get out fast */
			return;
		}
d495 4
a498 4
		frame.f_sr &= ~PSL_T;
		i = SIGTRAP;
		typ = TRAP_TRACE;
		break;
d500 2
a501 2
	case T_ASTFLT:		/* system async trap, cannot happen */
		goto dopanic;
d503 35
a537 12
	case T_ASTFLT|T_USER:	/* user async trap */
		astpending = 0;
		/*
		 * We check for software interrupts first.  This is because
		 * they are at a higher level than ASTs, and on a VAX would
		 * interrupt the AST.  We assume that if we are processing
		 * an AST that we must be at IPL0 so we don't bother to
		 * check.  Note that we ensure that we are at least at SIR
		 * IPL while processing the SIR.
		 */
		spl1();
		/* fall into... */
d539 10
a548 22
	case T_SSIR:		/* software interrupt */
	case T_SSIR|T_USER:
		while (bit = ffs(ssir)) {
			--bit;
			ssir &= ~(1 << bit);
			cnt.v_soft++;
			if (sir_routines[bit])
				sir_routines[bit](sir_args[bit]);
		}
		/*
		 * If this was not an AST trap, we are all done.
		 */
		if (type != (T_ASTFLT|T_USER)) {
			cnt.v_trap--;
			return;
		}
		spl0();
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		goto out;
d550 12
a561 22
	case T_MMUFLT:		/* kernel mode page fault */
		/*
		 * If we were doing profiling ticks or other user mode
		 * stuff from interrupt code, Just Say No.
		 */
		if (p && (p->p_addr->u_pcb.pcb_onfault == fubail ||
		    p->p_addr->u_pcb.pcb_onfault == subail))
			goto copyfault;
		/* fall into ... */

	case T_MMUFLT|T_USER:	/* page fault */
	    {
		register vm_offset_t va;
		register struct vmspace *vm = NULL;
		register vm_map_t map;
		int rv;
		vm_prot_t ftype, vftype;
		extern vm_map_t kernel_map;

		/* vmspace only significant if T_USER */
		if (p)
			vm = p->p_vmspace;
d564 28
a591 28
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
		printf("trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n",
		       p->p_pid, code, v, frame.f_pc, frame.f_sr);
#endif
		/*
		 * It is only a kernel address space fault iff:
		 * 	1. (type & T_USER) == 0  and
		 * 	2. pcb_onfault not set or
		 *	3. pcb_onfault set but supervisor space data fault
		 * The last can occur during an exec() copyin where the
		 * argument space is lazy-allocated.
		 */
		if (type == T_MMUFLT &&
		    ((p && !p->p_addr->u_pcb.pcb_onfault) || KDFAULT(code)))
			map = kernel_map;
		else
			map = &vm->vm_map;
		if (WRFAULT(code)) {
			vftype = VM_PROT_WRITE;
			ftype = VM_PROT_READ | VM_PROT_WRITE;
		} else
			vftype = ftype = VM_PROT_READ;
		va = trunc_page((vm_offset_t)v);

		if (map == kernel_map && va == 0) {
			printf("trap: bad kernel access at %x\n", v);
			goto dopanic;
		}
d593 2
a594 2
		if (ISHPMMADDR(va)) {
			vm_offset_t bva;
d596 8
a603 8
			rv = pmap_mapmulti(map->pmap, va);
			if (rv != KERN_SUCCESS) {
				bva = HPMMBASEADDR(va);
				rv = vm_fault(map, bva, ftype, FALSE);
				if (rv == KERN_SUCCESS)
					(void) pmap_mapmulti(map->pmap, va);
			}
		} else
d605 1
a605 1
		rv = vm_fault(map, va, ftype, FALSE);
d607 23
a629 23
		if (rv && MDB_ISPID(p->p_pid))
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
			       map, va, ftype, rv);
#endif
		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if ((caddr_t)va >= vm->vm_maxsaddr && map != kernel_map) {
			if (rv == KERN_SUCCESS) {
				unsigned nss;

				nss = clrnd(btoc(USRSTACK-(unsigned)va));
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (rv == KERN_PROTECTION_FAILURE)
				rv = KERN_INVALID_ADDRESS;
		}
		if (rv == KERN_SUCCESS) {
			if (type == T_MMUFLT) {
d631 2
a632 2
				if (mmutype == MMU_68040)
					(void) writeback(&frame, 1);
d634 18
a651 1
				return;
a652 17
			goto out;
		}
		if (type == T_MMUFLT) {
			if (p && p->p_addr->u_pcb.pcb_onfault)
				goto copyfault;
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
			       map, va, ftype, rv);
			printf("  type %x, code [mmu,,ssw]: %x\n",
			       type, code);
			goto dopanic;
		}
		frame.f_pad = code & 0xffff;
		ucode = vftype;
		typ = SEGV_MAPERR;
		i = SIGSEGV;
		break;
	    }
d658 1
a658 1
out:
d662 1
a662 1
#ifdef M68040
d672 2
a673 2
char *f7sz[] = { "longword", "byte", "word", "line" };
char *f7tt[] = { "normal", "MOVE16", "AFC", "ACK" };
d675 1
a675 1
		 "M-code", "k-data", "k-code", "RES" };
d677 1
a677 1
	"WARNING: pid %d(%s) writeback [%s] failed, pc=%x fa=%x wba=%x wbd=%x\n";
d682 2
a683 2
	struct frame *fp;
	int docachepush;
d710 2
a711 2
			       f7sz[(f->f_ssw & SSW4_SZMASK) >> 5],
			       f->f_fa, f->f_pd0);
d714 1
a714 1
				       f->f_pd1, f->f_pd2, f->f_pd3);
d727 1
a727 1
				   trunc_page(f->f_fa), VM_PROT_WRITE, TRUE, VM_PROT_WRITE);
d732 1
a732 1
				    (vm_offset_t)&vmmap[NBPG]);
d735 1
a735 1
			       p->p_pid, p->p_comm, p->p_ucred->cr_uid);
d745 2
a746 2
			       f->f_fa, f->f_fa & ~0xF, f->f_pd0, f->f_pd1,
			       f->f_pd2, f->f_pd3);
d760 2
a761 2
				       "MOVE16", fp->f_pc, f->f_fa,
				       f->f_fa & ~0xF, f->f_pd0);
d780 26
a805 26
		case SSW4_SZLW:
			if (off)
				wb1d = (wb1d >> (32 - off)) | (wb1d << off);
			if (KDFAULT(f->f_wb1s))
				*(long *)f->f_wb1a = wb1d;
			else
				err = suword((caddr_t)f->f_wb1a, wb1d);
			break;
		case SSW4_SZB:
			off = 24 - off;
			if (off)
				wb1d >>= off;
			if (KDFAULT(f->f_wb1s))
				*(char *)f->f_wb1a = wb1d;
			else
				err = subyte((caddr_t)f->f_wb1a, wb1d);
			break;
		case SSW4_SZW:
			off = (off + 16) % 32;
			if (off)
				wb1d = (wb1d >> (32 - off)) | (wb1d << off);
			if (KDFAULT(f->f_wb1s))
				*(short *)f->f_wb1a = wb1d;
			else
				err = susword((caddr_t)f->f_wb1a, wb1d);
			break;
d812 2
a813 2
				       "#1", fp->f_pc, f->f_fa,
				       f->f_wb1a, f->f_wb1d);
d824 1
a824 1
	    (f->f_wb2s & SSW4_SZMASK) != SSW4_SZLN) {
d832 18
a849 18
		case SSW4_SZLW:
			if (KDFAULT(f->f_wb2s))
				*(long *)f->f_wb2a = f->f_wb2d;
			else
				err = suword((caddr_t)f->f_wb2a, f->f_wb2d);
			break;
		case SSW4_SZB:
			if (KDFAULT(f->f_wb2s))
				*(char *)f->f_wb2a = f->f_wb2d;
			else
				err = subyte((caddr_t)f->f_wb2a, f->f_wb2d);
			break;
		case SSW4_SZW:
			if (KDFAULT(f->f_wb2s))
				*(short *)f->f_wb2a = f->f_wb2d;
			else
				err = susword((caddr_t)f->f_wb2a, f->f_wb2d);
			break;
d856 2
a857 2
				       "#2", fp->f_pc, f->f_fa,
				       f->f_wb2a, f->f_wb2d);
d872 18
a889 18
		case SSW4_SZLW:
			if (KDFAULT(f->f_wb3s))
				*(long *)f->f_wb3a = f->f_wb3d;
			else
				err = suword((caddr_t)f->f_wb3a, f->f_wb3d);
			break;
		case SSW4_SZB:
			if (KDFAULT(f->f_wb3s))
				*(char *)f->f_wb3a = f->f_wb3d;
			else
				err = subyte((caddr_t)f->f_wb3a, f->f_wb3d);
			break;
		case SSW4_SZW:
			if (KDFAULT(f->f_wb3s))
				*(short *)f->f_wb3a = f->f_wb3d;
			else
				err = susword((caddr_t)f->f_wb3a, f->f_wb3d);
			break;
d891 2
a892 2
		case SSW4_SZLN:
			panic("writeback: wb3s indicates LINE write");
d900 2
a901 2
				       "#3", fp->f_pc, f->f_fa,
				       f->f_wb3a, f->f_wb3d);
d911 1
a911 1
	return(err);
d916 1
a916 1
	register u_short ssw;
d936 3
a938 3
	       f7sz[(ssw & SSW4_SZMASK) >> 5],
	       f7tt[(ssw & SSW4_TTMASK) >> 3],
	       f7tm[ssw & SSW4_TMMASK]);
d942 3
a944 3
	int num;
	u_short s;
	u_int a, d;
d950 2
a951 2
	       num, a, d, f7sz[(s & SSW4_SZMASK) >> 5],
	       f7tt[(s & SSW4_TTMASK) >> 3], f7tm[s & SSW4_TMMASK]);
d967 2
a968 2
	register_t code;
	struct frame frame;
d1025 25
a1049 20
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		code = fuword(params);
		params += sizeof(int);
		/*
		 * XXX sigreturn requires special stack manipulation
		 * that is only done if entered via the sigreturn
		 * trap.  Cannot allow it here so make sure we fail.
		 */
		if (code == SYS_sigreturn)
			code = nsys;
		break;
	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
a1050 5
		code = fuword(params + _QUAD_LOWWORD * sizeof(int));
		params += sizeof(quad_t);
		break;
	default:
		break;
d1055 1
a1055 1
		callp += code;
d1060 1
a1060 1
		error = 0;
d1074 22
a1095 22
	case 0:
		frame.f_regs[D0] = rval[0];
		frame.f_regs[D1] = rval[1];
		frame.f_sr &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/*
		 * We always enter through a `trap' instruction, which is 2
		 * bytes, so adjust the pc by that amount.
		 */
		frame.f_pc = opc - 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		frame.f_regs[D0] = error;
		frame.f_sr |= PSL_C;	/* carry bit */
		break;
d1115 2
a1116 2
	struct proc *p;
	struct frame frame;
d1135 2
a1136 2
	void (*proc)();
	void *arg;
d1167 3
a1169 3
	int pc;
	int evec;
	void *frame;
d1202 1
a1202 1
	int start, end;
d1223 2
a1224 2
	int vec;
	struct intrhand *ih;
d1259 2
a1260 2
	{ "prom",	db_prom_cmd,	0,	0 },
	{ (char *)0, }
@


1.21
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 1999/06/06 15:38:34 deraadt Exp $ */
d723 1
a723 2
				   trunc_page(f->f_fa), VM_PROT_WRITE, TRUE,
				   VM_PROT_WRITE);
d949 1
a949 1
	pa = pmap_extract(p->p_vmspace->vm_map.pmap, (vm_offset_t)a);
@


1.20
log
@pmap callout changes for uvm; art
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 1998/04/03 03:47:42 deraadt Exp $ */
d723 2
a724 1
				   trunc_page(f->f_fa), VM_PROT_WRITE, TRUE);
@


1.19
log
@trapsignal cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 1997/04/08 13:55:57 briggs Exp $ */
d949 1
a949 1
	pa = pmap_extract(&p->p_vmspace->vm_pmap, (vm_offset_t)a);
@


1.18
log
@Clarify comment a bit and skip userret when flushing CPU caches in SunOS emul.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1997/04/08 05:14:52 briggs Exp $ */
d238 2
d242 2
a243 2
			trapsignal(p, sig, VM_PROT_WRITE, SEGV_MAPERR,
			    (caddr_t)faultaddr);
d275 1
d650 2
a651 1
	trapsignal(p, i, ucode, typ, (caddr_t)v);
@


1.17
log
@Fix from NetBSD: flush caches on trap 2 in SunOS emulation.  Comment on
mac68k change by scottr attributes Gordon (Ross) on the change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 1997/03/31 00:24:16 downsj Exp $ */
d480 1
a480 1
		 * XXX - Too bad OpenBSD uses trap 2...
a485 1
			userret(p, &frame, sticks, v, 1);
@


1.16
log
@Modernize OpenBSD/mvme68k to match various changes in m68k and hp300 code.

Compiles, but untested for lack of hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1997/02/24 13:00:54 deraadt Exp $ */
d478 3
a480 4
		 * XXX This comment/code is not consistent XXX
		 * SunOS seems to use Trap #2 for some obscure
		 * fpu operations.  So far, just ignore it, but
		 * DONT trap on it..
d483 3
@


1.15
log
@temporarily, also pass intr() routines the vec#
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1997/02/21 06:07:27 deraadt Exp $ */
a322 1
#ifdef FPCOPROC
a323 1
#endif
a343 1
#ifdef FPCOPROC
a365 1
#endif
@


1.14
log
@do not pass up un-init vftype
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1997/02/04 17:23:20 deraadt Exp $ */
d1175 7
a1181 1
		r = (*ih->ih_fn)(ih->ih_wantframe ? frame : ih->ih_arg);
@


1.13
log
@do not accidentally pass VM_PROT_WRITE|VM_PROT_READ
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1997/02/04 12:29:20 deraadt Exp $ */
d581 1
a581 1
			ftype = VM_PROT_READ;
@


1.12
log
@pass VM_PROT_READ/VM_PROT_WRITE as si_trapno for SIGSEGV
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1997/02/04 02:49:24 deraadt Exp $ */
d552 1
a552 1
		vm_prot_t ftype;
d577 2
a578 1
		if (WRFAULT(code))
d580 1
a580 1
		else
d644 1
a644 1
		ucode = ftype;
@


1.11
log
@fix a few more SIGxxx/xxx_* and fault addr issues
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1997/02/02 00:43:21 deraadt Exp $ */
d240 2
a241 1
			trapsignal(p, sig, T_MMUFLT, SEGV_MAPERR, (caddr_t)faultaddr);
d643 1
a643 1
		ucode = T_MMUFLT;
@


1.10
log
@trapsignal/sendsig type/sigval changes
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1997/01/27 22:48:17 deraadt Exp $ */
d342 1
d366 1
d381 1
d397 1
d399 1
d409 1
d421 1
d436 1
d449 3
a451 2
		typ = FPE_FLTOVF;
		i = SIGFPE;
@


1.9
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 1996/12/24 20:29:02 deraadt Exp $ */
d240 1
a240 1
			trapsignal(p, sig, T_MMUFLT, (caddr_t)faultaddr);
d265 1
a268 1
	int bit;
d312 4
d317 1
d341 1
d347 1
d362 1
d377 1
d385 1
a389 1
		/* fall through */
d391 4
d402 1
d413 1
d427 1
d441 1
d465 1
d484 1
d634 1
d639 1
a639 1
	trapsignal(p, i, ucode, (caddr_t)v);
@


1.8
log
@call all irq routines
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1996/06/11 10:07:13 deraadt Exp $ */
d240 1
a240 1
			trapsignal(p, sig, faultaddr);
d313 1
a313 1
		ucode = v;
d613 2
a614 1
		ucode = v;
d619 1
a619 1
	trapsignal(p, i, ucode);
@


1.7
log
@delete intr_freevec(), add intr_findvec() [more flexible interface]
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1137 1
d1145 1
a1145 1
			return;
d1147 2
a1148 1
	return (straytrap(pc, evec));
@


1.6
log
@add OpenBSD header
@
text
@d1151 20
a1199 18
}

/*
 * find a useable vector for devices that don't specify one
 */
int
intr_freevec()
{
	extern u_long *vectab[], hardtrap, badtrap;
	int i;

	for (i = 255; i; --i)
		if (vectab[i] == &badtrap)
			return (i);
	for (i = 255; i; --i)
		if (vectab[i] == &hardtrap)
			return (i);
	return (-1);
@


1.5
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 1
a1 1
/*	$Id: trap.c,v 1.4 1995/11/23 13:14:31 deraadt Exp $ */
@


1.4
log
@userret() parameter botch; prototype userret(); make ddb easier to enter
@
text
@d1 1
a1 1
/*	$Id: trap.c,v 1.3 1995/11/07 08:50:27 deraadt Exp $ */
d614 1
a614 1
		i = (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV;
d870 1
a870 4
	 * Determine the cause of the failure if any translating to
	 * a signal.  If the corresponding VA is valid and RO it is
	 * a protection fault (SIGBUS) otherwise consider it an
	 * illegal reference (SIGSEGV).
d872 2
a873 11
	if (err) {
		if (vm_map_check_protection(&p->p_vmspace->vm_map,
					    trunc_page(fa), round_page(fa),
					    VM_PROT_READ) &&
		    !vm_map_check_protection(&p->p_vmspace->vm_map,
					     trunc_page(fa), round_page(fa),
					     VM_PROT_WRITE))
			err = SIGBUS;
		else
			err = SIGSEGV;
	}
@


1.3
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d166 4
a260 3
#ifdef DDB
	extern int trap0, trap1, trap2, trap12, trap15, illinst;
#endif
d443 2
a444 7
		if (type == T_TRAP15 ||
		    (frame.f_pc != trap0 && frame.f_pc != trap1 &&
		     frame.f_pc != trap2 && frame.f_pc != trap12 &&
		     frame.f_pc != trap15 && frame.f_pc != illinst)) {
			if (kdb_trap(type, &frame))
				return;
		}
d460 1
a460 1
			userret(p, frame.f_pc, sticks);
d643 1
@


1.2
log
@SUNOS_SYS_sunos_sigreturn -> SUNOS_SYS_sigreturn
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.36 1995/05/12 18:24:53 mycroft Exp $	*/
d5 28
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.2.2.1 1995/10/12 00:43:38 chuck Exp $	*/
d4 1
d65 5
a75 4
#ifdef COMPAT_SUNOS
#include <compat/sunos/sunos_syscall.h>
	extern struct emul emul_sunos;
#endif
d133 1
a133 1
#define NSIR	32
d136 1
a136 1
int next_sir;
d230 1
a230 1
	extern char trap0[], trap1[], trap2[], trap12[], trap15[], illinst[];
d240 3
d268 1
a268 1
		if (!p->p_addr->u_pcb.pcb_onfault)
d415 3
a417 6
		    ((caddr_t)frame.f_pc != trap0 &&
		     (caddr_t)frame.f_pc != trap1 &&
		     (caddr_t)frame.f_pc != trap2 &&
		     (caddr_t)frame.f_pc != trap12 &&
		     (caddr_t)frame.f_pc != trap15 &&
		     (caddr_t)frame.f_pc != illinst)) {
d428 12
a468 1

d488 2
a489 2
		if (p->p_addr->u_pcb.pcb_onfault == fubail ||
		    p->p_addr->u_pcb.pcb_onfault == subail)
d496 1
a496 1
		register struct vmspace *vm = p->p_vmspace;
d502 4
d520 1
a520 1
		    (!p->p_addr->u_pcb.pcb_onfault || KDFAULT(code)))
d529 1
a529 1
#ifdef DEBUG
a533 1
#endif
d581 1
a581 1
			if (p->p_addr->u_pcb.pcb_onfault)
d927 3
d1073 1
a1073 1
	userret(p, &frame, p->p_sticks, (u_int)0, 0);
d1090 1
a1090 1
	if( next_sir >= NSIR )
d1107 102
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.36 1995/05/12 18:24:53 mycroft Exp $	*/
a3 1
 * Copyright (c) 1995 Theo de Raadt
a63 5
#ifdef COMPAT_SUNOS
#include <compat/sunos/sunos_syscall.h>
extern struct emul emul_sunos;
#endif

d70 4
d131 1
a131 1
#define NSIR	8
d134 1
a134 1
u_char next_sir;
d228 1
a228 1
	extern int trap0, trap1, trap2, trap12, trap15, illinst;
a237 3
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
d263 1
a263 1
		if (!p || !p->p_addr->u_pcb.pcb_onfault)
d410 6
a415 3
		    (frame.f_pc != trap0 && frame.f_pc != trap1 &&
		     frame.f_pc != trap2 && frame.f_pc != trap12 &&
		     frame.f_pc != trap15 && frame.f_pc != illinst)) {
a425 12
#ifdef COMPAT_SUNOS
		/*
		 * XXX This comment/code is not consistent XXX
		 * SunOS seems to use Trap #2 for some obscure
		 * fpu operations.  So far, just ignore it, but
		 * DONT trap on it..
		 */
		if (p->p_emul == &emul_sunos) {
			userret(p, frame.f_pc, sticks);
			return;
		}
#endif
d455 1
d475 2
a476 2
		if (p && (p->p_addr->u_pcb.pcb_onfault == fubail ||
		    p->p_addr->u_pcb.pcb_onfault == subail))
d483 1
a483 1
		register struct vmspace *vm = NULL;
a488 4
		/* vmspace only significant if T_USER */
		if (p)
			vm = p->p_vmspace;

d503 1
a503 1
		    ((p && !p->p_addr->u_pcb.pcb_onfault) || KDFAULT(code)))
d512 1
a512 1

d517 1
d565 1
a565 1
			if (p && p->p_addr->u_pcb.pcb_onfault)
a910 3
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
d940 1
a940 1
		if (code != SUNOS_SYS_sunos_sigreturn) {
d1054 1
a1054 1
	userret(p, &frame, 0, (u_int)0, 0);
d1071 1
a1071 1
	if (next_sir >= NSIR)
a1087 102

struct intrhand *intrs[256];

/*
 * XXX
 * This is an EXTREMELY good candidate for rewriting in assembly!!
 */
#ifndef INTR_ASM
int
hardintr(pc, evec, frame)
	int pc;
	int evec;
	void *frame;
{
	int vec = (evec & 0xfff) >> 2;	/* XXX should be m68k macro? */
	extern u_long intrcnt[];	/* XXX from locore */
	struct intrhand *ih;
	int r;

	cnt.v_intr++;
/*	intrcnt[level]++; */
	for (ih = intrs[vec]; ih; ih = ih->ih_next) {
		r = (*ih->ih_fn)(ih->ih_wantframe ? frame : ih->ih_arg);
		if (r > 0)
			return;
	}
	return (straytrap(pc, evec));
}
#endif /* !INTR_ASM */

/*
 * Chain the interrupt handler in. But first check if the vector
 * offset chosen is legal. It either must be a badtrap (not allocated
 * for a `system' purpose), or it must be a hardtrap (ie. already
 * allocated to deal with chained interrupt handlers).
 */
int
intr_establish(vec, ih)
	int vec;
	struct intrhand *ih;
{
	extern u_long *vectab[], hardtrap, badtrap;
	struct intrhand *ihx;

	if (vectab[vec] != &badtrap && vectab[vec] != &hardtrap) {
		printf("intr_establish: vec %d unavailable\n", vec);
		return (-1);
	}
	vectab[vec] = &hardtrap;

	ih->ih_next = NULL;	/* just in case */

	/* attach at tail */
	if (ihx = intrs[vec]) {
		while (ihx->ih_next)
			ihx = ihx->ih_next;
		ihx->ih_next = ih;
	} else
		intrs[vec] = ih;
	return (0);
}

/*
 * find a useable vector for devices that don't specify one
 */
int
intr_freevec()
{
	extern u_long *vectab[], hardtrap, badtrap;
	int i;

	for (i = 255; i; --i)
		if (vectab[i] == &badtrap)
			return (i);
	for (i = 255; i; --i)
		if (vectab[i] == &hardtrap)
			return (i);
	return (-1);
}

#ifdef DDB
#include <sys/reboot.h>
#include <machine/db_machdep.h>
#include <ddb/db_command.h>

void
db_prom_cmd()
{
	doboot();
}

struct db_command db_machine_cmds[] = {
	{ "prom",	db_prom_cmd,	0,	0 },
	{ (char *)0, }
};

void
db_machine_init()
{
	db_machine_commands_install(db_machine_cmds);
}
#endif /* DDB */
@
