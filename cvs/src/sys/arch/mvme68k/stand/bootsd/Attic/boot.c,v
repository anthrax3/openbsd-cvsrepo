head	1.14;
access;
symbols
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.38
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.36
	OPENBSD_5_0:1.11.0.34
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.32
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.30
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.26
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.30
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.28
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.26
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.10.0.24
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.22
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.20
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.18
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.16
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.14
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.12
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.10
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.13;

1.13
date	2014.02.20.20.34.27;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.31.21.35.32;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.04.22.16.01.19;	author gvf;	state Exp;
branches
	1.10.14.1;
next	1.9;

1.9
date	97.04.17.19.16.39;	author gvf;	state Exp;
branches;
next	1.8;

1.8
date	96.05.16.02.46.57;	author chuck;	state Exp;
branches;
next	1.7;

1.7
date	96.04.28.10.48.17;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.02.16.00.13.18;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	95.12.06.10.54.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.07.08.50.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.22.06.56.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.20.02.00.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.44.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.44.12;	author deraadt;	state Exp;
branches;
next	;

1.10.14.1
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: boot.c,v 1.13 2014/02/20 20:34:27 miod Exp $ */
/*	$NetBSD: boot.c,v 1.2 1995/09/23 03:42:52 gwr Exp $ */

/*-
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * 	@@(#)boot.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#define _KERNEL
#include <sys/fcntl.h>
#undef _KERNEL

#include <machine/prom.h>

#include "stand.h"
#include "libsa.h"

int loadrandom(const char *, char *, size_t);

int debug;
int errno;
extern char *version;
extern char rnddata[BOOTRANDOM_MAX];
char	line[80];

int
main()
{
	char *cp, *file;
	int	flag, ret;
	int	ask = 0;
	int	rnd_loaded = 0;

	printf(">> OpenBSD MVME%x bootsd [%s]\n", bugargs.cputyp, version);

	ret = parse_args(&file, &flag);

	for (;;) {
		if (ask) {
			printf("boot: ");
			gets(line);
			if (line[0]) {
				bugargs.arg_start = line;
				cp = line;
				while (cp < (line + sizeof(line) -1) && *cp)
					cp++;
				bugargs.arg_end = cp;
				ret = parse_args(&file, &flag);
			}
		}
		if (ret) {
			printf("boot: -q returning to MVME-Bug\n");
			break;
		}

		if (rnd_loaded == 0)
			rnd_loaded = loadrandom(BOOTRANDOM, rnddata,
			    sizeof(rnddata));

		exec_mvme(file, flag);
		printf("boot: %s: %s\n", file, strerror(errno));
		ask = 1;
	}
	return(0);
}

int
loadrandom(const char *name, char *buf, size_t buflen)
{
	struct stat sb;
	int fd;
	int rc = 0;

	fd = open(name, O_RDONLY);
	if (fd == -1) {
		if (errno != EPERM)
			printf("cannot open %s: %s\n", name, strerror(errno));
		return 0;
	}
	if (fstat(fd, &sb) == -1 || sb.st_uid != 0 || !S_ISREG(sb.st_mode) ||
	    (sb.st_mode & (S_IWOTH|S_IROTH)))
		goto fail;
	(void) read(fd, buf, buflen);
	rc = 1;
fail:
	close(fd);
	return rc;
}
@


1.13
log
@Support for /etc/random.seed in bootsd (disk-only boot blocks)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2012/12/31 21:35:32 miod Exp $ */
@


1.12
log
@Switch mvme68k boot blocks to use the MI libsa loadfile routines to load
kernel images, instead of their own; gives us the ability to load ELF kernels
for free.

Fix many warnings, and generally make the code closer to the current mvme88k
boot blocks to help diffability.

Rewrite bugcrt and bugexec() as a short assembly shim around a
compiler-independent C block; this will allow compilers other than gcc2 to be
used, and removes the need for bugcrt to be compiled without optimization.

Crank all bootblocks versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 2003/06/02 23:27:51 millert Exp $ */
d37 4
d47 2
d52 1
d61 1
d84 5
d94 23
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 1997/04/22 16:01:19 gvf Exp $ */
d52 1
a52 1
	int	io, flag, ret;
@


1.10
log
@minor clean to -q
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10.14.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 1997/04/22 16:01:19 gvf Exp $ */
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9
log
@Added -q to return to Motorola bug.
Added loop to prompt for kernel name if it is not found.
@
text
@d1 1
d76 1
a76 1
		if ( ret == -1 ) {
@


1.8
log
@update to run from bootxx + major clean up
@
text
@d49 1
d55 2
a56 1
	int	io, flag;
d60 1
a60 1
	parse_args(&file, &flag);
d62 21
a82 3
	exec_mvme(file, flag);

	printf("boot: %s: %s\n", file, strerror(errno));
@


1.7
log
@add OpenBSD header
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a3 29
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d35 1
a35 1
 * from: @@(#)boot.c	8.1 (Berkeley) 6/10/93
a38 1
#include <sys/types.h>
d40 1
a40 1
#include <a.out.h>
d42 1
d44 1
a44 3

void copyunix __P((int io, char *addr));
void parse_args __P((void));
d47 2
a48 27
int netif_debug;
#define RB_NOSYM 0x400

/*
 * Boot device is derived from ROM provided information.
 */
extern char	*version;
u_long		esym;
char		*strtab;
int		strtablen;
#if 0
struct nlist  *nlp, *enlp;
#endif

struct kernel {
	void	*entry;
	void	*symtab;
	void	*esym;
	int	bflags;
	int	bdev;
	char	*kname;
	void	*smini;
	void	*emini;
	u_int	end_loaded;
} kernel;

extern struct mvmeprom_args bugargs;
d53 2
a54 38
	struct exec x;
	char *file;
	void *addr;
	int io, i;

	printf(">> OpenBSD sdboot [%s]\n", version);

	parse_args();
	file = kernel.kname;

	io = open(file, 0);
	if (io < 0) {
		printf("Can't open %s: %s\n", file, strerror(errno));
		mvmeprom_return();
	}
	i = read(io, (char *)&x, sizeof(x));
	if (i != sizeof(x) || N_BADMAG(x)) {
		printf("Bad format\n");
		return (0);
	}
	/* Make load address start of page which containes "start" */
	addr = (void *)(x.a_entry & ~0x0FFF);
	lseek(io, 0, SEEK_SET);

	/*printf("load %s to 0x%x\n", file, addr);*/
	copyunix(io, addr);
	return (0);
}

/*ARGSUSED*/
void
copyunix(io, addr)
	int io;
	char *addr;
{
	void (*entry)() = (void (*)())addr;
	struct exec x;
	int i, cnt;
d56 1
a56 5
	i = read(io, (char *)&x, sizeof(x));
	if (i != sizeof(x) || N_BADMAG(x)) {
		printf("Bad format\n");
		return;
	}
d58 1
a58 31
	printf("%x", x.a_text);
	if (N_GETMAGIC(x) == ZMAGIC) {
		kernel.entry = entry = (void *)x.a_entry;
		lseek(io, 0, SEEK_SET);
	}
	if (read(io, (char *)addr, x.a_text) != x.a_text)
		goto shread;
	addr += x.a_text;
	if (N_GETMAGIC(x) == NMAGIC)
		while ((int)addr & CLOFSET)
			*addr++ = 0;
	printf("+%x", x.a_data);
	if (read(io, addr, x.a_data) != x.a_data)
		goto shread;
	addr += x.a_data;
	printf("+%x", x.a_bss);
	for (i = 0; i < x.a_bss; i++)
		*addr++ = 0;
	if (x.a_syms != 0 && !(kernel.bflags & RB_NOSYM)) {
		bcopy(&x.a_syms, addr, sizeof(x.a_syms));
		addr += sizeof(x.a_syms);
#if 0
		nlp = (struct nlist *)addr;
#endif
		printf("+[%x+", x.a_syms);
		if (read(io, addr, x.a_syms) != x.a_syms)
			goto shread;
		addr += x.a_syms;
#if 0
		enlp = (struct nlist *)(strtab = addr);
#endif
d60 1
a60 90
		if (read(io, &strtablen, sizeof(int)) != sizeof(int))
			goto shread;

		bcopy(&strtablen, addr, sizeof(int));
		if (i = strtablen) {
			i -= sizeof(int);
			addr += sizeof(int);
			cnt = read(io, addr, i);
			if (cnt != i)
				printf("symwarn"); /* goto shread; */
			addr += i;
		}
		printf("%x]", i);
		esym = KERNBASE +
			(((int)addr + sizeof(int) - 1) & ~(sizeof(int) - 1));
		kernel.symtab = (void *) x.a_syms;
		kernel.esym = addr;
	} else {
		kernel.symtab = 0;
		kernel.esym = 0;
	}

#if 0
	while (nlp < enlp) {
		register int strx = nlp->n_un.n_strx;
		if (strx > strtablen)
			continue;
		if (strcmp(strtab+strx, "_esym") == 0) {
			*(int*)(nlp->n_value - KERNBASE) = esym;
			break;
		}
		nlp++;
	}
#endif

	kernel.bdev = 0;
	kernel.end_loaded = (u_int)addr;
	kernel.smini = 0;
	kernel.emini = 0;
	kernel.kname = 0;

	printf("=%x\n", (u_int)addr - (u_int)entry);	/* XXX wrong? */

#if 0
printf("entry %x\n",kernel.entry);
printf("symtab %x\n",kernel.symtab);
printf("esym %x\n",kernel.esym);
printf("bflags %x\n",kernel.bflags);
printf("bdev %x\n",kernel.bdev);
printf("kname %x\n",kernel.kname);
printf("smini %x\n",kernel.smini);
printf("emini %x\n",kernel.emini);
printf("end_loaded %x\n",kernel.end_loaded);
#endif

	printf("start at 0x%x\n", (int)entry);
	if (((u_long)entry &0xf) == 0x2) {
		(entry)(&bugargs, &kernel);
	} else {
		/* is type fixing anything like price fixing? */
		typedef (* kernel_start) __P((int, int, void *,void *, void *));
		kernel_start addr; 
		addr = (void *)entry;
		(addr)(kernel.bflags, 0, kernel.esym, kernel.smini, kernel.emini);
	}
	return;

shread:
	printf("short read\n");
}

struct flags {
	char c;
	short bit;
} bf[] = {
	{ 'a', RB_ASKNAME },
	{ 'b', RB_HALT },
	{ 'y', RB_NOSYM },
	{ 'd', RB_KDB },
	{ 'm', RB_MINIROOT },
	{ 'r', RB_DFLTROOT },
	{ 's', RB_SINGLE },
};

void
parse_args()
{
	char *name = "/bsd", *ptr;
	int i, howto = 0;
	char c;
d62 2
a63 25
	if (bugargs.arg_start != bugargs.arg_end) {
		ptr = bugargs.arg_start;
		while (c = *ptr) {
			while (c == ' ')
				c = *++ptr;
			if (c == '\0')
				return;
			if (c != '-') {
				name = ptr;
				while ((c = *++ptr) && c != ' ')
					;
				if (c)
					*ptr++ = 0;
				continue;
			}
			while ((c = *++ptr) && c != ' ') {
				for (i = 0; i < sizeof(bf)/sizeof(bf[0]); i++)
					if (bf[i].c == c) {
						howto |= bf[i].bit;
					}
			}
		}
	}
	kernel.bflags = howto;
	kernel.kname = name;
@


1.6
log
@Fixes for mvme68k tape and disk bootloaders.

fix argument parsing for disk and tape boot
        bootsd/boot.c
        bugcrt/m68k/Makefile.inc

tape boot was broken completely
        bootst/bootst.c

minor bug if bootloader was specific size (aout exec header is 0x20 not 0x30).
        writvid/wrtvid.c
@
text
@d1 1
a1 1
/*	$Id: boot.c,v 1.5 1995/12/06 10:54:55 deraadt Exp $ */
@


1.5
log
@various changes to once again shrink the bootblocks to a useable size.
@
text
@d1 1
a1 1
/*	$Id: boot.c,v 1.4 1995/11/07 08:50:34 deraadt Exp $ */
d277 1
a277 1
	if (bugargs.arg_start == bugargs.arg_end) {
d294 1
a294 1
					if (bf[i].c == c)
d296 1
@


1.4
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
a73 1
void reset_twiddle __P((void));
d75 1
a75 1
void parse_args __P((struct mvmeprom_args *pargs));
d89 1
a89 1
struct nlist	*nlp, *enlp;
d104 1
a104 1
struct mvmeprom_args *bugargs;
d107 1
a107 2
main(pp)
	struct mvmeprom_args *pp;
d116 1
a116 2
	bugargs = pp;
	parse_args(pp);
d119 2
a120 1
	if ((io = open(file, 0)) < 0) {
d125 1
a125 2
	if (i != sizeof(x) ||
	    N_BADMAG(x)) {
d133 1
a133 3
	reset_twiddle();

	printf("booting %s load address 0x%x\n", file, addr);
d144 1
d146 1
a146 2
	int i;
	void (*entry)() = (void (*)())addr;
d149 1
a149 2
	if (i != sizeof(x) ||
	    N_BADMAG(x)) {
a153 1
	reset_twiddle();
a164 1
	reset_twiddle();
a168 1
	reset_twiddle();
a184 1
		reset_twiddle();
a187 1
		reset_twiddle();
d193 3
a195 9
			{
				int cnt;
				cnt = read(io, addr, i);
				if (cnt != i)
				    /*
				    goto shread;
				    */printf("symwarn");
			}
			reset_twiddle();
a241 5
#if 0
	if (kernel.bflags & RB_HALT) {
		mvmeprom_return();
	}
#endif
d243 1
a243 1
		(entry)(bugargs, &kernel);
d245 5
a249 5
                /* is type fixing anything like price fixing? */
                typedef (* kernel_start)(int, int, void *,void *, void *);
                kernel_start addr; 
                addr = (void *)entry;
                (addr)(kernel.bflags,0,kernel.esym,kernel.smini,kernel.emini);
d252 1
d254 1
a254 1
	printf("Short read\n");
a255 1
#define NO_TWIDDLE_FUNC
d257 12
a268 29
#ifndef NO_TWIDDLE_FUNC
static int tw_on;
static int tw_pos;
static char tw_chars[] = "|/-\\";
#endif

void
reset_twiddle()
{
#ifndef NO_TWIDDLE_FUNC
	if (tw_on)
		putchar('\b');
	tw_on = 0;
	tw_pos = 0;
#endif
}

#ifndef NO_TWIDDLE_FUNC
void
twiddle()
{
	if (tw_on)
		putchar('\b');
	else
		tw_on = 1;
	putchar(tw_chars[tw_pos++]);
	tw_pos %= (sizeof(tw_chars) - 1);
}
#endif
a269 1
#if 0
d271 1
a271 1
_rtt()
d273 2
a274 10
	mvmeprom_return();
}
#endif

void
parse_args(pargs)
	struct mvmeprom_args *pargs;
{
	char *ptr = pargs->arg_start;
	char *name = "/bsd";
a275 1
	int howto = 0;
d277 2
a278 1
	if (pargs->arg_start != pargs->arg_end) {
d282 1
a282 1
			if (!c)
d284 1
a284 18
			if (c == '-')
				while ((c = *++ptr) && c != ' ') {
					if (c == 'a')
						howto |= RB_ASKNAME;
					else if (c == 'b')
						howto |= RB_HALT;
					else if (c == 'y')
						howto |= RB_NOSYM;
					else if (c == 'd')
						howto |= RB_KDB;
					else if (c == 'm')
						howto |= RB_MINIROOT;
					else if (c == 'r')
						howto |= RB_DFLTROOT;
					else if (c == 's')
						howto |= RB_SINGLE;
				}
			else {
d286 2
a287 1
				while ((c = *++ptr) && c != ' ');
d290 6
a297 12
#if 0
		if (RB_NOSYM & howto) printf("RB_NOSYM\n\r");
		if (RB_AUTOBOOT & howto) printf("RB_AUTOBOOT\n\r");
		if (RB_SINGLE & howto) printf("RB_SINGLE\n\r");
		if (RB_NOSYNC & howto) printf("RB_NOSYNC\n\r");
		if (RB_HALT & howto) printf("RB_HALT\n\r");
		if (RB_DFLTROOT & howto) printf("RB_DFLTROOT\n\r");
		if (RB_KDB & howto) printf("RB_KDB\n\r");
		if (RB_RDONLY & howto) printf("RB_RDONLY\n\r");
		if (RB_DUMP & howto) printf("RB_DUMP\n\r");
		if (RB_MINIROOT & howto) printf("RB_MINIROOT\n\r");
#endif
@


1.3
log
@NetBSD -> OpenBSD; kernel is called /bsd
@
text
@d1 1
a1 1
/*	$NetBSD$	*/
d4 29
@


1.2
log
@update to new libsa
@
text
@d87 1
a87 1
	printf(">> NetBSD sdboot [%s]\n", version);
d293 1
a293 1
	char *name = "/netbsd";
@


1.1
log
@Initial revision
@
text
@d280 1
d286 2
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
