head	1.10;
access;
symbols
	OPENBSD_5_5:1.9.0.8
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.7.0.38
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.36
	OPENBSD_5_0:1.7.0.34
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.32
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.30
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.26
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.30
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.28
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.26
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.24
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.22
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.20
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.9;

1.9
date	2012.12.31.21.35.32;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2012.12.05.23.20.13;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.19.10.22.30;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.04.16.36.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.29.07.58.38;	author deraadt;	state Exp;
branches
	1.5.14.1;
next	1.4;

1.4
date	96.10.16.13.50.01;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.10.49.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.51.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.44.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.44.11;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: if_le.c,v 1.9 2012/12/31 21:35:32 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1993 Adam Glass
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Adam Glass.
 * 4. The name of the Author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Adam Glass ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stand.h>
#include "sboot.h"
#include "if_lereg.h"

struct {
	struct lereg1 *sc_r1;	/* LANCE registers */
	struct lereg2 *sc_r2;	/* RAM */
	int     next_rmd;
	int     next_tmd;
}       le_softc;

void
le_error(char *str, struct lereg1 *ler1)
{
	/* ler1->ler1_rap = LE_CSRO done in caller */
	if (ler1->ler1_rdp & LE_C0_BABL) {
		printf("le0: been babbling, found by '%s'\n", str);
		callrom();
	}
	if (ler1->ler1_rdp & LE_C0_CERR) {
		ler1->ler1_rdp = LE_C0_CERR;
	}
	if (ler1->ler1_rdp & LE_C0_MISS) {
		ler1->ler1_rdp = LE_C0_MISS;
	}
	if (ler1->ler1_rdp & LE_C0_MERR) {
		printf("le0: memory error in '%s'\n", str);
		callrom();
	}
}

void
le_reset(u_char *myea)
{
	struct lereg1 *ler1 = le_softc.sc_r1;
	struct lereg2 *ler2 = le_softc.sc_r2;
	unsigned int a;
	int     timo = 100000, stat = 0, i;

	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_STOP;	/* do nothing until we are finished */

	bzero(ler2, sizeof(*ler2));

	ler2->ler2_mode = LE_MODE_NORMAL;
	ler2->ler2_padr[0] = myea[1];
	ler2->ler2_padr[1] = myea[0];
	ler2->ler2_padr[2] = myea[3];
	ler2->ler2_padr[3] = myea[2];
	ler2->ler2_padr[4] = myea[5];
	ler2->ler2_padr[5] = myea[4];

	ler2->ler2_ladrf0 = 0;
	ler2->ler2_ladrf1 = 0;

	a = (u_int) ler2->ler2_rmd;
	ler2->ler2_rlen = LE_RLEN | (a >> 16);
	ler2->ler2_rdra = a & LE_ADDR_LOW_MASK;

	a = (u_int) ler2->ler2_tmd;
	ler2->ler2_tlen = LE_TLEN | (a >> 16);
	ler2->ler2_tdra = a & LE_ADDR_LOW_MASK;

	ler1->ler1_rap = LE_CSR1;
	a = (u_int) ler2;
	ler1->ler1_rdp = a & LE_ADDR_LOW_MASK;
	ler1->ler1_rap = LE_CSR2;
	ler1->ler1_rdp = a >> 16;

	for (i = 0; i < LERBUF; i++) {
		a = (u_int) & ler2->ler2_rbuf[i];
		ler2->ler2_rmd[i].rmd0 = a & LE_ADDR_LOW_MASK;
		ler2->ler2_rmd[i].rmd1_bits = LE_R1_OWN;
		ler2->ler2_rmd[i].rmd1_hadr = a >> 16;
		ler2->ler2_rmd[i].rmd2 = -LEMTU;
		ler2->ler2_rmd[i].rmd3 = 0;
	}
	for (i = 0; i < LETBUF; i++) {
		a = (u_int) & ler2->ler2_tbuf[i];
		ler2->ler2_tmd[i].tmd0 = a & LE_ADDR_LOW_MASK;
		ler2->ler2_tmd[i].tmd1_bits = 0;
		ler2->ler2_tmd[i].tmd1_hadr = a >> 16;
		ler2->ler2_tmd[i].tmd2 = 0;
		ler2->ler2_tmd[i].tmd3 = 0;
	}

	ler1->ler1_rap = LE_CSR3;
	ler1->ler1_rdp = LE_C3_BSWP;

	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_INIT;
	do {
		if (--timo == 0) {
			printf("le0: init timeout, stat = 0x%x\n", stat);
			break;
		}
		stat = ler1->ler1_rdp;
	} while ((stat & LE_C0_IDON) == 0);

	ler1->ler1_rdp = LE_C0_IDON;
	le_softc.next_rmd = 0;
	le_softc.next_tmd = 0;
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_STRT;
}

int
le_poll(void *pkt, int len)
{
	struct lereg1 *ler1 = le_softc.sc_r1;
	struct lereg2 *ler2 = le_softc.sc_r2;
	unsigned int a;
	int     length;
	struct lermd *rmd;

	ler1->ler1_rap = LE_CSR0;
	if ((ler1->ler1_rdp & LE_C0_RINT) != 0)
		ler1->ler1_rdp = LE_C0_RINT;
	rmd = &ler2->ler2_rmd[le_softc.next_rmd];
	if (rmd->rmd1_bits & LE_R1_OWN) {
		return (0);
	}
	if (ler1->ler1_rdp & LE_C0_ERR)
		le_error("le_poll", ler1);
	if (rmd->rmd1_bits & LE_R1_ERR) {
		printf("le0_poll: rmd status 0x%x\n", rmd->rmd1_bits);
		length = 0;
		goto cleanup;
	}
	if ((rmd->rmd1_bits & (LE_R1_STP | LE_R1_ENP)) != (LE_R1_STP | LE_R1_ENP)) {
		printf("le_poll: chained packet\n");
		callrom();
	}
	length = rmd->rmd3;
	if (length >= LEMTU) {
		length = 0;
		printf("csr0 when bad things happen: %x\n", ler1->ler1_rdp);
		callrom();
		goto cleanup;
	}
	if (!length)
		goto cleanup;
	length -= 4;
	if (length > 0)
		bcopy((char *) &ler2->ler2_rbuf[le_softc.next_rmd], pkt, length);

cleanup:
	a = (u_int) & ler2->ler2_rbuf[le_softc.next_rmd];
	rmd->rmd0 = a & LE_ADDR_LOW_MASK;
	rmd->rmd1_hadr = a >> 16;
	rmd->rmd2 = -LEMTU;
	le_softc.next_rmd =
	    (le_softc.next_rmd == (LERBUF - 1)) ? 0 : (le_softc.next_rmd + 1);
	rmd->rmd1_bits = LE_R1_OWN;
	return length;
}

int
le_put(u_char *pkt, size_t len)
{
	struct lereg1 *ler1 = le_softc.sc_r1;
	struct lereg2 *ler2 = le_softc.sc_r2;
	struct letmd *tmd;
	int     timo = 100000, stat = 0;
	unsigned int a;

	ler1->ler1_rap = LE_CSR0;
	if (ler1->ler1_rdp & LE_C0_ERR)
		le_error("le_put(way before xmit)", ler1);
	tmd = &ler2->ler2_tmd[le_softc.next_tmd];
	while (tmd->tmd1_bits & LE_T1_OWN) {
		printf("le0: output buffer busy\n");
	}
	bcopy(pkt, (char *) ler2->ler2_tbuf[le_softc.next_tmd], len);
	if (len < 64)
		tmd->tmd2 = -64;
	else
		tmd->tmd2 = -len;
	tmd->tmd3 = 0;
	if (ler1->ler1_rdp & LE_C0_ERR)
		le_error("le_put(before xmit)", ler1);
	tmd->tmd1_bits = LE_T1_STP | LE_T1_ENP | LE_T1_OWN;
	a = (u_int) & ler2->ler2_tbuf[le_softc.next_tmd];
	tmd->tmd0 = a & LE_ADDR_LOW_MASK;
	tmd->tmd1_hadr = a >> 16;
	ler1->ler1_rdp = LE_C0_TDMD;
	if (ler1->ler1_rdp & LE_C0_ERR)
		le_error("le_put(after xmit)", ler1);
	do {
		if (--timo == 0) {
			printf("le0: transmit timeout, stat = 0x%x\n",
			    stat);
			if (ler1->ler1_rdp & LE_C0_ERR)
				le_error("le_put(timeout)", ler1);
			break;
		}
		stat = ler1->ler1_rdp;
	} while ((stat & LE_C0_TINT) == 0);
	ler1->ler1_rdp = LE_C0_TINT;
	if (ler1->ler1_rdp & LE_C0_ERR) {
		if ((ler1->ler1_rdp & (LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR)) !=
		    LE_C0_CERR)
			printf("le_put: xmit error, buf %d\n", le_softc.next_tmd);
		le_error("le_put(xmit error)", ler1);
	}
	le_softc.next_tmd = 0;
/*	(le_softc.next_tmd == (LETBUF - 1)) ? 0 : le_softc.next_tmd + 1;*/
	if (tmd->tmd1_bits & LE_T1_ERR) {
		printf("le0: transmit error, error = 0x%x\n",
		    tmd->tmd3);
		return -1;
	}
	return len;
}

int
le_get(u_char *pkt, size_t len, u_long timeout)
{
	int     cc;
	int     now, then;
	int     stopat = ttime() + timeout;
	then = 0;

	cc = 0;
	while ((now = ttime()) < stopat && !cc) {
		cc = le_poll(pkt, len);
		if (then != now) {
#ifdef LE_DEBUG
			printf("%d  \r", stopat - now);
#endif
			then = now;
		}
		if (cc && (pkt[0] != myea[0] || pkt[1] != myea[1] ||
			pkt[2] != myea[2] || pkt[3] != myea[3] ||
			pkt[4] != myea[4] || pkt[5] != myea[5])) {
			cc = 0;	/* ignore broadcast / multicast */
#ifdef LE_DEBUG
			printf("reject (%d sec left)\n", stopat - now);
#endif
		}
	}
#ifdef LE_DEBUG
	printf("\n");
#endif
	return cc;
}

void
le_init(void)
{
	int    *ea = (int *) LANCE_ADDR;
	u_long *eram = (u_long *) ERAM_ADDR;
	u_long  e = *ea;

	if ((e & 0x2fffff00) == 0x2fffff00) {
		printf("ERROR: ethernet address not set!  Use LSAD.\n");
		callrom();
	}
	myea[0] = 0x08;
	myea[1] = 0x00;
	myea[2] = 0x3e;
	e = e >> 8;
	myea[5] = e & 0xff;
	e = e >> 8;
	myea[4] = e & 0xff;
	e = e >> 8;
	myea[3] = e;
	printf("le0: ethernet address: %x:%x:%x:%x:%x:%x\n",
	    myea[0], myea[1], myea[2], myea[3], myea[4], myea[5]);
	bzero(&le_softc, sizeof(le_softc));
	le_softc.sc_r1 = (struct lereg1 *) LANCE_REG_ADDR;
	le_softc.sc_r2 = (struct lereg2 *) (*eram - (1024 * 1024));
	le_reset(myea);
}

void
le_end(void)
{
	struct lereg1 *ler1 = le_softc.sc_r1;

	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_STOP;
}
@


1.9
log
@Switch mvme68k boot blocks to use the MI libsa loadfile routines to load
kernel images, instead of their own; gives us the ability to load ELF kernels
for free.

Fix many warnings, and generally make the code closer to the current mvme88k
boot blocks to help diffability.

Rewrite bugcrt and bugexec() as a short assembly shim around a
compiler-independent C block; this will allow compilers other than gcc2 to be
used, and removes the need for bugcrt to be compiled without optimization.

Crank all bootblocks versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.8 2012/12/05 23:20:13 deraadt Exp $ */
@


1.8
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.7 2003/08/19 10:22:30 deraadt Exp $ */
d69 1
a69 1
static void
d89 1
a89 1
static void
d95 1
a95 1
	int     timo = 100000, stat, i;
d164 1
a164 1
static int
d221 1
a221 1
	int     timo = 100000, stat, i;
a307 1
	caddr_t addr;
@


1.7
log
@simple protos and ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.6 2003/06/04 16:36:14 deraadt Exp $ */
d57 1
a57 1
#include <sys/cdefs.h>
@


1.6
log
@more term 3 & 4 from various developers, with permission of course
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.5 1997/01/29 07:58:38 deraadt Exp $ */
d5 1
a5 1
 * 
d69 2
a70 4
void 
le_error(str, ler1)
	char   *str;
	struct lereg1 *ler1;
d89 2
a90 3
void 
le_reset(myea)
	u_char *myea;
a109 1

d164 2
a165 4
int 
le_poll(pkt, len)
	void   *pkt;
	int     len;
d215 2
a216 4
int 
le_put(pkt, len)
	u_char *pkt;
	size_t  len;
d273 2
a274 5
int 
le_get(pkt, len, timeout)
	u_char *pkt;
	size_t  len;
	u_long  timeout;
d305 2
a306 2
void 
le_init()
d312 1
d334 2
a335 2
void 
le_end()
@


1.5
log
@signal.h -> siginfo.h -> time.h fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.4 1996/10/16 13:50:01 mickey Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.5.14.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.5 1997/01/29 07:58:38 deraadt Exp $ */
d14 6
@


1.5.14.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 *
d69 4
a72 2
static void
le_error(char *str, struct lereg1 *ler1)
d91 3
a93 2
static void
le_reset(u_char *myea)
d113 1
d168 4
a171 2
static int
le_poll(void *pkt, int len)
d221 4
a224 2
int
le_put(u_char *pkt, size_t len)
d281 5
a285 2
int
le_get(u_char *pkt, size_t len, u_long timeout)
d316 2
a317 2
void
le_init(void)
a322 1

d344 2
a345 2
void
le_end(void)
@


1.4
log
@update according to the libsa changes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.3 1996/04/28 10:49:38 deraadt Exp $ */
d295 1
a295 1
	int     stopat = time() + timeout;
d299 1
a299 1
	while ((now = time()) < stopat && !cc) {
@


1.3
log
@add OpenBSD header
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d64 1
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: le_poll.c,v 1.3 1994/10/26 09:11:48 cgd Exp $	*/
d4 29
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
