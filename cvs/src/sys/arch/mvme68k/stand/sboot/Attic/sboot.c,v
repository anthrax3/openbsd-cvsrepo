head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.8
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.9.0.38
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.36
	OPENBSD_5_0:1.9.0.34
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.32
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.30
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.30
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.28
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.26
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.7.0.24
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.22
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.20
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.18
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.16
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.14
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.12;

1.12
date	2012.12.31.21.35.32;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2012.12.05.23.20.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.04.13.36.47;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.19.10.22.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.04.16.36.14;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.10.16.13.50.01;	author mickey;	state Exp;
branches
	1.7.14.1;
next	1.6;

1.6
date	96.08.20.04.01.09;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.29.15.30.44;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	96.04.28.10.49.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.07.08.51.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.22.06.56.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.16;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.43.59;	author deraadt;	state Exp;
branches;
next	;

1.7.14.1
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.7.14.2;

1.7.14.2
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: sboot.c,v 1.12 2012/12/31 21:35:32 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1995 Charles D. Cranor and Seth Widoff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor
 *	and Seth Widoff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include "stand.h"
#include "sboot.h"

int
main(int argc, char *argv[])
{
	char    buf[128], *ebuf;

	buf[0] = '0';
	printf("\nsboot: MVME147 bootstrap program\n");
	while (1) {
		printf(">>> ");
		ebuf = ngets(buf, sizeof(buf));
		do_cmd(buf, ebuf);
	}
	/* not reached */
}

/*
 * exit to rom
 */
void
callrom(void)
{
	asm("trap #15; .word 0x0063");
}

/*
 * do_cmd: do a command
 */
void
do_cmd(char *buf, char *ebuf)
{
	switch (*buf) {
	case '\0':
		break;
	case 'a':
		if (rev_arp()) {
			printf("My ip address is: %d.%d.%d.%d\n", myip[0],
			    myip[1], myip[2], myip[3]);
			printf("Server ip address is: %d.%d.%d.%d\n", servip[0],
			    servip[1], servip[2], servip[3]);
		} else {
			printf("Failed.\n");
		}
		break;
	case 'q':
		printf("exiting to ROM\n");
		callrom();
		break;
	case 'f':
		if (do_get_file() == 1) {
			printf("Download Failed\n");
		} else {
			printf("Download was a success!\n");
		}
		break;
	case 'b':
		le_init();
		if (rev_arp()) {
			printf("client IP address %d.%d.%d.%d\n", myip[0],
			    myip[1], myip[2], myip[3]);
			printf("server IP address %d.%d.%d.%d\n", servip[0],
			    servip[1], servip[2], servip[3]);
		} else {
			printf("REVARP: Failed.\n");
			return;
		}
		if (do_get_file() == 1) {
			printf("Download Failed\n");
			return;
		} else {
			printf("received secondary boot program.\n");
		}
		if (*++buf == '\0')
			buf = " bsd";
		go(STAGE2_RELOC, buf+1, ebuf);
		break;
	case 'h':
	case '?':
		printf("valid commands\n");
		printf("a - send a RARP\n");
		printf("b - boot the system\n");
		printf("q - exit to ROM\n");
		printf("f - ftp the boot file\n");
		printf("g - execute the boot file\n");
		printf("h - help\n");
		printf("i - init LANCE enet chip\n");
		break;
	case 'i':
		le_init();
		break;
	case 'g':
		go(STAGE2_RELOC, buf+1, ebuf);
		break;
	default:
		printf("sboot: %s: Unknown command\n", buf);
	}
}

/*
 * ngets: get string from console
 */
char *
ngets(char * str, int size)
{
	int i = 0;

	while ((i < size - 1) && (str[i] = getchar()) != '\r') {
		if (str[i] == '\b' || str[i] == 0x7F) {
			if (i == 0)
				continue;
			i--;
			printf("\b \b");
			continue;
		}
		putchar(str[i]);
		i++;
	}
	printf("\n");
	str[i] = '\0';
	return(&str[i]);
}
@


1.12
log
@Switch mvme68k boot blocks to use the MI libsa loadfile routines to load
kernel images, instead of their own; gives us the ability to load ELF kernels
for free.

Fix many warnings, and generally make the code closer to the current mvme88k
boot blocks to help diffability.

Rewrite bugcrt and bugexec() as a short assembly shim around a
compiler-independent C block; this will allow compilers other than gcc2 to be
used, and removes the need for bugcrt to be compiled without optimization.

Crank all bootblocks versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: sboot.c,v 1.11 2012/12/05 23:20:13 deraadt Exp $ */
@


1.11
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sboot.c,v 1.10 2012/11/04 13:36:47 miod Exp $ */
d58 1
@


1.10
log
@Make the s-records boot loader use the same stage1/stage2 addresses as the
other boot blocks. Crank stage1 from 64KB to 1MB to accomodate non-mvme147 BUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: sboot.c,v 1.9 2003/08/19 10:22:30 deraadt Exp $ */
a56 1
#include <sys/cdefs.h>
@


1.9
log
@simple protos and ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: sboot.c,v 1.8 2003/06/04 16:36:14 deraadt Exp $ */
d134 1
a134 1
		go(LOAD_ADDR, buf+1, ebuf);
d151 1
a151 1
		go(LOAD_ADDR, buf+1, ebuf);
@


1.8
log
@more term 3 & 4 from various developers, with permission of course
@
text
@d1 1
a1 1
/*	$OpenBSD: sboot.c,v 1.7 1996/10/16 13:50:01 mickey Exp $ */
d5 1
a5 1
 * 
d61 2
a62 2
void
main()
d79 2
a80 2
void 
callrom()
d88 2
a89 3
void 
do_cmd(buf, ebuf)
	char   *buf, *ebuf;
d158 2
a159 2
/* 
 * ngets: get string from console 
d161 2
a162 2
 
char *ngets ( char * str, int size )
d164 16
a179 14
  int i = 0;
  while ( (i < size - 1) && (str[i] = getchar()) != '\r') {
    if ( str[i] == '\b' || str[i] == 0x7F ) {
      if ( i == 0) continue;
      i--;
      printf("\b \b");
      continue;
    }
    putchar(str[i]);
    i++; 
  }
  printf("\n");
  str[i] = '\0';
  return(&str[i]);
@


1.7
log
@update according to the libsa changes
@
text
@d1 1
a1 1
/*	$OpenBSD: sboot.c,v 1.6 1996/08/20 04:01:09 deraadt Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7.14.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sboot.c,v 1.7 1996/10/16 13:50:01 mickey Exp $ */
d14 6
@


1.7.14.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 *
d61 2
a62 2
int
main(int argc, char *argv[])
d79 2
a80 2
void
callrom(void)
d88 3
a90 2
void
do_cmd(char *buf, char *ebuf)
d159 2
a160 2
/*
 * ngets: get string from console
d162 2
a163 2
char *
ngets(char * str, int size)
d165 14
a178 16
	int i = 0;

	while ((i < size - 1) && (str[i] = getchar()) != '\r') {
		if (str[i] == '\b' || str[i] == 0x7F) {
			if (i == 0)
				continue;
			i--;
			printf("\b \b");
			continue;
		}
		putchar(str[i]);
		i++;
	}
	printf("\n");
	str[i] = '\0';
	return(&str[i]);
@


1.6
log
@ensure whole kernel name gets passed in
@
text
@d1 1
a1 1
/*	$OpenBSD: sboot.c,v 1.5 1996/05/29 15:30:44 chuck Exp $ */
d64 1
@


1.5
log
@new arg passing
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d139 1
a139 1
			buf = "bsd";
@


1.4
log
@add OpenBSD header
@
text
@d69 1
a69 1
	char    buf[128];
d75 2
a76 2
		gets(buf);
		do_cmd(buf);
d94 2
a95 2
do_cmd(buf)
	char   *buf;
d140 1
a140 1
		go(buf);
d157 1
a157 1
		go(buf);
d164 5
a168 2
go(buf)
	char *buf;
d170 14
a183 8
	void (*entry)() = (void (*))LOAD_ADDR;

	printf("jumping to boot program at 0x%x.\n", entry);

	asm("clrl d0; clrl d1");	/* XXX network device */
	asm("movl %0, a3" : : "a" (buf) : "a3");
	asm("movl %0, a4" : : "a" (buf + strlen(buf)) : "a4");
	asm("jmp %0@@" : : "a" (entry));
@


1.3
log
@$Id$ throughout
update many copyrights
@
text
@d1 2
@


1.2
log
@NetBSD -> OpenBSD; kernel is called /bsd
@
text
@d2 28
@


1.1
log
@Initial revision
@
text
@a31 3
/*
 * main driver, plus machdep stuff
 */
d33 1
d36 4
a39 1
void sboot() 
d41 8
a48 17
{
  char * mesg;
  char buf[128];
  buf[0] = '0';
  consinit();
  printf("\nsboot: serial line bootstrap program (&end = %x)\n\n", &end);
  if (reboot) {  /* global flag from AAstart.s */
    reboot = 0;
    printf("[rebooting...]\n");
    do_cmd("b");
  }
  while (1) {
    printf(">>> ");
    ngets(buf, sizeof(buf));
    do_cmd(buf);
  }
  /* not reached */
d54 2
a55 2

void callrom () 
d57 1
a57 1
  asm("trap #15; .word 0x0063");
d63 70
d134 2
a135 4
void do_cmd(buf)

char *buf;

d137 1
a137 64
  switch (*buf) {
  case '\0':
    return;
  case 'a':
    if ( rev_arp() ) {
	printf ("My ip address is: %d.%d.%d.%d\n", myip[0],
		myip[1], myip[2], myip[3]);
	printf ("Server ip address is: %d.%d.%d.%d\n", servip[0],
		servip[1], servip[2], servip[3]);
    } else  {
	printf ("Failed.\n");
    } 
    return;
  case 'e':
    printf("exiting to ROM\n");
    callrom();
    return; 
  case 'f':
    if (do_get_file() == 1) {
      printf("Download Failed\n");
    } else {
      printf("Download was a success!\n");
    }
    return;
  case 'b':
    le_init();
    if ( rev_arp() ) {
	printf ("My ip address is: %d.%d.%d.%d\n", myip[0],
		myip[1], myip[2], myip[3]);
	printf ("Server ip address is: %d.%d.%d.%d\n", servip[0],
		servip[1], servip[2], servip[3]);
    } else  {
	printf ("REVARP: Failed.\n");
	return;
    }
    if (do_get_file() == 1) {
        printf("Download Failed\n");
        return;
    } else {
        printf("Download was a success!\n");
    }
    go(buf);
    return;
  case 'h':
  case '?':
    printf("valid commands\n");
    printf("a - send a RARP\n");
    printf("b - boot the system\n");
    printf("e - exit to ROM\n");
    printf("f - ftp the boot file\n");
    printf("g - execute the boot file\n");
    printf("h - help\n");
    printf("i - init LANCE enet chip\n");
    return;
  case 'i':
    le_init();
    return;
  case 'g':
    go(buf);
    return;
  default:
    printf("sboot: %s: Unknown command\n", buf);
  }
}
d139 1
a139 2
go(buf) 
char *buf;
d141 4
a144 4
{
  void (*entry)() =  (void (*)) LOAD_ADDR ;
  printf("Start @@ 0x%x ... \n", entry);
  (*entry)(buf);
a145 1

@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d32 3
a35 1
#include <sys/cdefs.h>
d38 2
a39 2
void
main()
d41 16
a56 10
	char    buf[128];

	buf[0] = '0';
	printf("\nsboot: MVME147 bootstrap program\n");
	while (1) {
		printf(">>> ");
		gets(buf);
		do_cmd(buf);
	}
	/* not reached */
d62 2
a63 2
void 
callrom()
d65 1
a65 1
	asm("trap #15; .word 0x0063");
d71 5
a75 3
void 
do_cmd(buf)
	char   *buf;
d77 63
a139 65
	switch (*buf) {
	case '\0':
		break;
	case 'a':
		if (rev_arp()) {
			printf("My ip address is: %d.%d.%d.%d\n", myip[0],
			    myip[1], myip[2], myip[3]);
			printf("Server ip address is: %d.%d.%d.%d\n", servip[0],
			    servip[1], servip[2], servip[3]);
		} else {
			printf("Failed.\n");
		}
		break;
	case 'q':
		printf("exiting to ROM\n");
		callrom();
		break;
	case 'f':
		if (do_get_file() == 1) {
			printf("Download Failed\n");
		} else {
			printf("Download was a success!\n");
		}
		break;
	case 'b':
		le_init();
		if (rev_arp()) {
			printf("client IP address %d.%d.%d.%d\n", myip[0],
			    myip[1], myip[2], myip[3]);
			printf("server IP address %d.%d.%d.%d\n", servip[0],
			    servip[1], servip[2], servip[3]);
		} else {
			printf("REVARP: Failed.\n");
			return;
		}
		if (do_get_file() == 1) {
			printf("Download Failed\n");
			return;
		} else {
			printf("received secondary boot program.\n");
		}
		if (*++buf == '\0')
			buf = "netbsd";
		go(buf);
		break;
	case 'h':
	case '?':
		printf("valid commands\n");
		printf("a - send a RARP\n");
		printf("b - boot the system\n");
		printf("q - exit to ROM\n");
		printf("f - ftp the boot file\n");
		printf("g - execute the boot file\n");
		printf("h - help\n");
		printf("i - init LANCE enet chip\n");
		break;
	case 'i':
		le_init();
		break;
	case 'g':
		go(buf);
		break;
	default:
		printf("sboot: %s: Unknown command\n", buf);
	}
d142 3
a144 2
go(buf)
	char *buf;
d146 4
a149 3
	void (*entry)() = (void (*))LOAD_ADDR;

	printf("jumping to boot program at 0x%x.\n", entry);
a150 5
	asm("clrl d0; clrl d1");	/* XXX network device */
	asm("movl %0, a3" : : "a" (buf) : "a3");
	asm("movl %0, a4" : : "a" (buf + strlen(buf)) : "a4");
	asm("jmp %0@@" : : "a" (entry));
}
@
