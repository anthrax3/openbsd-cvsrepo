head	1.12;
access;
symbols
	OPENBSD_5_5:1.11.0.8
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.32
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.30
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.26
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.22
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.20
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.18
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.7.0.16
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.14
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.12
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.10
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.8
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.6
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2013.02.02.13.36.06;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2012.12.31.21.35.32;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.20.00.26.00;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.01.11.05.11.41;	author millert;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	96.05.16.02.55.36;	author chuck;	state Exp;
branches;
next	1.5;

1.5
date	96.04.28.10.49.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.17.22.13.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.07.08.50.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.20.02.00.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.15;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.44.40;	author deraadt;	state Exp;
branches;
next	;

1.7.6.1
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: dev_net.c,v 1.11 2013/02/02 13:36:06 miod Exp $ */

/*
 * Copyright (c) 1995 Gordon W. Ross
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Gordon W. Ross
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This module implements a "raw device" interface suitable for
 * use by the stand-alone I/O library NFS code.  This interface
 * does not support any "block" access, and exists only for the
 * purpose of initializing the network interface, getting boot
 * parameters, and performing the NFS mount.
 *
 * At open time, this does:
 *
 * find interface      - netif_open()
 * RARP for IP address - rarp_getipaddress()
 * RPC/bootparams      - callrpc(d, RPC_BOOTPARAMS, ...)
 * RPC/mountd          - nfs_mount(sock, ip, path)
 *
 * the root file handle from mountd is saved in a global
 * for use by the NFS open code (NFS/lookup).
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/in_systm.h>

#include <machine/prom.h>

#include "stand.h"
#include "libsa.h"
#include "net.h"
#include "netif.h"
#include "config.h"
#include "bootparam.h"
#include "nfs.h"

extern int nfs_root_node[];	/* XXX - get from nfs_mount() */

struct in_addr myip, rootip, gateip, mask;

int netdev_sock = -1;
static int open_count;

int	net_mountroot(struct open_file *, char *);

/*
 * Called by devopen after it sets f->f_dev to our devsw entry.
 * This opens the low-level device and sets f->f_devdata.
 */
int
net_open(struct open_file *f, char *devname)
{
	int error = 0;

	/* On first open, do netif open, mount, etc. */
	if (open_count == 0) {
		/* Find network interface. */
		if ((netdev_sock = netif_open(devname)) < 0)
			return (error=ENXIO);
		if ((error = net_mountroot(f, devname)) != 0)
			return (error);
	}
	open_count++;
	f->f_devdata = nfs_root_node;
	return (error);
}

int
net_close(struct open_file *f)
{
	/* On last close, do netif close, etc. */
	if (open_count > 0)
		if (--open_count == 0)
			netif_close(netdev_sock);
	f->f_devdata = NULL;
	return (0);
}

int
net_ioctl(struct open_file *f, u_long cmd, void *data)
{
	return EIO;
}

int
net_strategy(void *devdata, int rw, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	return EIO;
}


int
net_mountroot(struct open_file *f, char *devname)
{
	int error;

#ifdef DEBUG
	printf("net_mountroot: %s\n", devname);
#endif

	/*
	 * Get info for NFS boot: our IP address, our hostname,
	 * server IP address, and our root path on the server.
	 * There are two ways to do this:  The old, Sun way,
	 * and the more modern, BOOTP way. (RFC951, RFC1048)
	 */

#ifdef	SUN_BOOTPARAMS
	/* Get boot info using RARP and Sun bootparams. */

	/* Get our IP address.  (rarp.c) */
	if (rarp_getipaddress(netdev_sock) == -1)
		return (EIO);
	printf("boot: client IP address: %s\n", intoa(myip.s_addr));

	/* Get our hostname, server IP address. */
	if (bp_whoami(netdev_sock))
		return (EIO);
	printf("boot: client name: %s\n", hostname);

	/* Get the root pathname. */
	if (bp_getfile(netdev_sock, "root", &rootip, rootpath))
		return (EIO);

#else

	/* Get boot info using BOOTP way. (RFC951, RFC1048) */
	bootp(netdev_sock);

	printf("Using IP address: %s\n", intoa(myip.s_addr));

	printf("myip: %s (%s)", hostname, intoa(myip));
	if (gateip)
		printf(", gateip: %s", intoa(gateip));
	if (mask)
		printf(", mask: %s", intoa(mask));
	printf("\n");

#endif

	printf("root addr=%s path=%s\n", intoa(rootip.s_addr), rootpath);

	/* Get the NFS file handle (mount). */
	error = nfs_mount(netdev_sock, rootip, rootpath);

	return (error);
}

/*
 * machdep_common_ether: get ethernet address
 */
void
machdep_common_ether(u_char *ether)
{
	u_char *ea;

	if (bugargs.cputyp == CPU_147) {
		ea = (u_char *) ETHER_ADDR_147;

		if ((*(int *) ea & 0x2fffff00) == 0x2fffff00)
			panic("ERROR: ethernet address not set!");
		ether[0] = 0x08;
		ether[1] = 0x00;
		ether[2] = 0x3e;
		ether[3] = ea[0];
		ether[4] = ea[1];
		ether[5] = ea[2];
	} else {
		ea = (u_char *) ETHER_ADDR_16X;

		if (ea[0] + ea[1] + ea[2] + ea[3] + ea[4] + ea[5] == 0)
			panic("ERROR: ethernet address not set!");
		ether[0] = ea[0];
		ether[1] = ea[1];
		ether[2] = ea[2];
		ether[3] = ea[3];
		ether[4] = ea[4];
		ether[5] = ea[5];
	}
}
@


1.11
log
@mvme68k ELF bits. Boot block updates heavily based upon the recent mvme88k
a.out->ELF transition.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_net.c,v 1.10 2012/12/31 21:35:32 miod Exp $ */
@


1.10
log
@Switch mvme68k boot blocks to use the MI libsa loadfile routines to load
kernel images, instead of their own; gives us the ability to load ELF kernels
for free.

Fix many warnings, and generally make the code closer to the current mvme88k
boot blocks to help diffability.

Rewrite bugcrt and bugexec() as a short assembly shim around a
compiler-independent C block; this will allow compilers other than gcc2 to be
used, and removes the need for bugcrt to be compiled without optimization.

Crank all bootblocks versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_net.c,v 1.9 2011/03/13 00:13:53 deraadt Exp $ */
a70 1
char rootpath[FNAME_SIZE];
@


1.9
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_net.c,v 1.8 2003/08/20 00:26:00 deraadt Exp $ */
d66 1
a66 1
#include "dev_net.h"
d76 50
a125 1
static int
a213 46

/*
 * Called by devopen after it sets f->f_dev to our devsw entry.
 * This opens the low-level device and sets f->f_devdata.
 */
int
net_open(struct open_file *f, char *devname)
{
	int error = 0;

	/* On first open, do netif open, mount, etc. */
	if (open_count == 0) {
		/* Find network interface. */
		if ((netdev_sock = netif_open(devname)) < 0)
			return (error=ENXIO);
		if ((error = net_mountroot(f, devname)) != 0)
			return (error);
	}
	open_count++;
	f->f_devdata = nfs_root_node;
	return (error);
}

int
net_close(struct open_file *f)
{
	/* On last close, do netif close, etc. */
	if (open_count > 0)
		if (--open_count == 0)
			netif_close(netdev_sock);
	f->f_devdata = NULL;
}

int
net_ioctl(struct open_file *f, u_long cmd, void *data)
{
	return EIO;
}

int
net_strategy(void *devdata, int rw, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	return EIO;
}

@


1.8
log
@ansi and protos for the rest
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_net.c,v 1.7 1999/01/11 05:11:41 millert Exp $ */
d205 1
a205 1
net_strategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
@


1.7
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_net.c,v 1.6 1996/05/16 02:55:36 chuck Exp $ */
d66 1
d76 2
a77 51
/*
 * Called by devopen after it sets f->f_dev to our devsw entry.
 * This opens the low-level device and sets f->f_devdata.
 */
int
net_open(f, devname)
	struct open_file *f;
	char *devname;		/* Device part of file name (or NULL). */
{
	int error = 0;

	/* On first open, do netif open, mount, etc. */
	if (open_count == 0) {
		/* Find network interface. */
		if ((netdev_sock = netif_open(devname)) < 0)
			return (error=ENXIO);
		if ((error = net_mountroot(f, devname)) != 0)
			return (error);
	}
	open_count++;
	f->f_devdata = nfs_root_node;
	return (error);
}

int
net_close(f)
	struct open_file *f;
{
	/* On last close, do netif close, etc. */
	if (open_count > 0)
		if (--open_count == 0)
			netif_close(netdev_sock);
	f->f_devdata = NULL;
}

int
net_ioctl()
{
	return EIO;
}

int
net_strategy()
{
	return EIO;
}

int
net_mountroot(f, devname)
	struct open_file *f;
	char *devname;		/* Device part of file name (or NULL). */
d137 1
a137 2
machdep_common_ether(ether)
	u_char *ether;
d165 46
@


1.7.6.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a65 1
#include "dev_net.h"
d75 51
a125 2
static int
net_mountroot(struct open_file *f, char *devname)
d185 2
a186 1
machdep_common_ether(u_char *ether)
a213 46

/*
 * Called by devopen after it sets f->f_dev to our devsw entry.
 * This opens the low-level device and sets f->f_devdata.
 */
int
net_open(struct open_file *f, char *devname)
{
	int error = 0;

	/* On first open, do netif open, mount, etc. */
	if (open_count == 0) {
		/* Find network interface. */
		if ((netdev_sock = netif_open(devname)) < 0)
			return (error=ENXIO);
		if ((error = net_mountroot(f, devname)) != 0)
			return (error);
	}
	open_count++;
	f->f_devdata = nfs_root_node;
	return (error);
}

int
net_close(struct open_file *f)
{
	/* On last close, do netif close, etc. */
	if (open_count > 0)
		if (--open_count == 0)
			netif_close(netdev_sock);
	f->f_devdata = NULL;
}

int
net_ioctl(struct open_file *f, u_long cmd, void *data)
{
	return EIO;
}

int
net_strategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
    size_t *rsize)
{
	return EIO;
}

@


1.6
log
@clean up and sync with changes elsewhere (use common parse_args,
bugargs.cputyp, bugcrt, etc...).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d194 1
a194 1
			panic("ERROR: ethernet address not set!\r\n");
d205 1
a205 1
			panic("ERROR: ethernet address not set!\r\n");
@


1.5
log
@add OpenBSD header
@
text
@d58 2
d61 1
a188 1
	extern int cputyp;
d190 1
a190 1
	if (cputyp == CPU_147) {
@


1.4
log
@deal with new rarp_getipaddress() semantics
@
text
@d1 1
a1 1
/*	$Id: dev_net.c,v 1.3 1995/11/07 08:50:59 deraadt Exp $ */
@


1.3
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
d141 1
a141 1
	if ((myip.s_addr = rarp_getipaddress(netdev_sock)) == 0)
@


1.2
log
@update to new libsa
@
text
@d1 1
a1 1
/*	$NetBSD: dev_net.c,v 1.1.1.1 1995/06/09 22:02:40 gwr Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dev_net.c,v 1.2.2.1 1995/10/12 20:39:02 chuck Exp $	*/
d61 1
d66 1
a66 12
/*
 * Various globals needed by the network code:
 */

/* for arp.c, rarp.c */
u_char bcea[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

struct	in_addr myip;		/* my ip address */
struct	in_addr rootip;		/* root ip address */
struct	in_addr gateip;		/* swap ip address */
n_long	netmask;		/* subnet or net mask */

d69 1
a69 10
int hostnamelen;
char hostname[FNAME_SIZE];

int domainnamelen;
char domainname[FNAME_SIZE];

/*
 * Local things...
 */
static int netdev_sock = -1;
d138 2
d141 1
a141 1
	if (rarp_getipaddress(netdev_sock))
d143 1
a143 8
#else	/* BOOTPARAMS */
	/*
	 * Get boot info using BOOTP. (RFC951, RFC1048)
	 * This also gets the server IP address, gateway,
	 * root path, etc.
	 */
	bootp(netdev_sock);	/* XXX - Error return? */
#endif	/* BOOTPARAMS */
d145 1
a145 4
	printf("boot: client addr: %s\n", inet_ntoa(myip));

#ifdef	SUN_BOOTPARAMS
	/* Get our hostname, server IP address, gateway. */
a147 2
#endif	/* BOOTPARAMS */

a148 4
	if (gateip.s_addr) {
		printf("boot: subnet mask: %s\n", intoa(netmask));
		printf("boot: net gateway: %s\n", inet_ntoa(gateip));
	}
a149 1
#ifdef	SUN_BOOTPARAMS
a152 1
#endif	/* BOOTPARAMS */
d154 17
a170 2
	printf("boot: server addr: %s\n", inet_ntoa(rootip));
	printf("boot: server path: %s\n", rootpath);
d176 35
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: dev_net.c,v 1.1.1.1 1995/06/09 22:02:40 gwr Exp $	*/
a60 1
#include "config.h"
d65 12
a76 1
u_int32_t myip, rootip, gateip, mask;
d79 10
a88 1
int netdev_sock = -1;
a156 2
	/* Get boot info using RARP and Sun bootparams. */

d158 1
a158 1
	if ((myip = rarp_getipaddress(netdev_sock)) == 0)
d160 8
a167 1
	printf("boot: client IP address: %s\n", intoa(myip));
d169 4
a172 1
	/* Get our hostname, server IP address. */
d175 2
d178 4
d183 1
d187 1
d189 2
a190 17
#else

	/* Get boot info using BOOTP way. (RFC951, RFC1048) */
	bootp(netdev_sock);

	printf("Using IP address: %s\n", intoa(myip));

	printf("myip: %s (%s)", hostname, intoa(myip));
	if (gateip)
		printf(", gateip: %s", intoa(gateip));
	if (mask)
		printf(", mask: %s", intoa(mask));
	printf("\n");

#endif

	printf("root addr=%s path=%s\n", intoa(rootip), rootpath);
a195 35
}

/*
 * machdep_common_ether: get ethernet address
 */
void
machdep_common_ether(ether)
	u_char *ether;
{
	u_char *ea;
	extern int cputyp;

	if (cputyp == CPU_147) {
		ea = (u_char *) ETHER_ADDR_147;

		if ((*(int *) ea & 0x2fffff00) == 0x2fffff00)
			panic("ERROR: ethernet address not set!\r\n");
		ether[0] = 0x08;
		ether[1] = 0x00;
		ether[2] = 0x3e;
		ether[3] = ea[0];
		ether[4] = ea[1];
		ether[5] = ea[2];
	} else {
		ea = (u_char *) ETHER_ADDR_16X;

		if (ea[0] + ea[1] + ea[2] + ea[3] + ea[4] + ea[5] == 0)
			panic("ERROR: ethernet address not set!\r\n");
		ether[0] = ea[0];
		ether[1] = ea[1];
		ether[2] = ea[2];
		ether[3] = ea[3];
		ether[4] = ea[4];
		ether[5] = ea[5];
	}
@
