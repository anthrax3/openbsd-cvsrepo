head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.16
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.14
	OPENBSD_5_0:1.13.0.12
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.22
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.20
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.18
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.16
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.14
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.12
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.12
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.10
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	theo-1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.14;

1.14
date	2012.12.31.21.35.32;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.17.18.42.06;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.20.00.26.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.04.16.36.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.28.01.37.52;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.24.05.20.56;	author smurph;	state Exp;
branches
	1.8.2.1
	1.8.12.1;
next	1.7;

1.7
date	2000.01.06.03.21.44;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	99.01.11.05.11.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.05.16.02.55.36;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	96.04.28.10.49.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.07.08.51.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.20.02.00.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.44.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.44.43;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2002.03.28.10.34.06;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	;

1.8.12.1
date	2002.06.11.03.36.51;	author art;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2003.05.19.21.45.32;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: if_ie.c,v 1.14 2012/12/31 21:35:32 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>

#define ETHER_MIN_LEN   64
#define ETHER_MAX_LEN   1518
#define ETHER_CRC_LEN	4

#define NTXBUF	1
#define NRXBUF	16
#define IE_RBUF_SIZE	ETHER_MAX_LEN

#include <machine/prom.h>

#include "stand.h"
#include "libsa.h"
#include "netif.h"
#include "config.h"
#include "net.h"

#include "i82586.h"
#include "if_iereg.h"

int     ie_debug = 0;

void ie_stop(struct netif *);
void ie_end(struct netif *);
void ie_error(struct netif *, char *, volatile struct iereg *);
int ie_get(struct iodesc *, void *, size_t, time_t);
void ie_init(struct iodesc *, void *);
int ie_match(struct netif *, void *);
int ie_poll(struct iodesc *, void *, int);
int ie_probe(struct netif *, void *);
int ie_put(struct iodesc *, void *, size_t);
void ie_reset(struct netif *, u_char *);
extern void machdep_common_ether(u_char *);

struct netif_stats ie_stats;

struct netif_dif ie0_dif = {
	0,			/* unit */
	1,			/* nsel */
	&ie_stats,
	0,
	0,
};

struct netif_driver ie_driver = {
	"ie",			/* netif_bname */
	ie_match,		/* match */
	ie_probe,		/* probe */
	ie_init,		/* init */
	ie_get,			/* get */
	ie_put,			/* put */
	ie_end,			/* end */
	&ie0_dif,		/* netif_ifs */
	1,			/* netif_nifs */
};

struct ie_configuration {
	u_int   phys_addr;
	int     used;
} ie_config[] = {
	{ INTEL_REG_ADDR, 0 }
};

int     nie_config = sizeof(ie_config) / (sizeof(ie_config[0]));

struct {
	struct iereg *sc_reg;	/* IE registers */
	struct iemem *sc_mem;	/* RAM */
}       ie_softc;

int
ie_match(struct netif *nif, void *machdep_hint)
{
	char   *name;
	int     i, val = 0;

	if (bugargs.cputyp == CPU_147)
		return (0);
	name = machdep_hint;
	if (name && !bcmp(ie_driver.netif_bname, name, 2))
		val += 10;
	for (i = 0; i < nie_config; i++) {
		if (ie_config[i].used)
			continue;
		if (ie_debug)
			printf("ie%d: ie_match --> %d\n", i, val + 1);
		ie_config[i].used++;
		return (val + 1);
	}
	if (ie_debug)
		printf("ie%d: ie_match --> 0\n", i);
	return (0);
}

int
ie_probe(struct netif *nif, void *machdep_hint)
{

	/* the set unit is the current unit */
	if (ie_debug)
		printf("ie%d: ie_probe called\n", nif->nif_unit);

	if (bugargs.cputyp != CPU_147)
		return (0);
	return (1);
}

void
ie_error(struct netif *nif, char *str, volatile struct iereg *ier)
{
	panic("ie%d: unknown error", nif->nif_unit);
}

static void
ieack(volatile struct iereg *ier, struct iemem *iem)
{
	/* ack the `interrupt' */
	iem->im_scb.ie_command = iem->im_scb.ie_status & IE_ST_WHENCE;
	ier->ie_attention = 1;	/* chan attention! */
	while (iem->im_scb.ie_command)
		;
}

void
ie_reset(struct netif *nif, u_char *myea)
{
	volatile struct iereg *ier = ie_softc.sc_reg;
	struct iemem *iem = ie_softc.sc_mem;
	int     timo = 10000, i;
	volatile int t;
	u_int   a;

	if (ie_debug)
		printf("ie%d: ie_reset called\n", nif->nif_unit);

	/*printf("ier %x iem %x\n", ier, iem);*/

	*(u_char *)0xfff4202a = 0x40;

	bzero(iem, sizeof(*iem));
	iem->im_scp.scp_sysbus = 0;
	iem->im_scp.scp_iscp_low = (int) &iem->im_iscp & 0xffff;
	iem->im_scp.scp_iscp_high = (int) &iem->im_iscp >> 16;

	iem->im_iscp.iscp_scboffset = (int) &iem->im_scb - (int) iem;
	iem->im_iscp.iscp_busy = 1;
	iem->im_iscp.iscp_base_low = (int) iem & 0xffff;
	iem->im_iscp.iscp_base_high = (int) iem >> 16;

	/*
	 * completely and utterly unlike what i expected, the
	 * "write" order is:
	 * 1st:	d15-d0 -> high address
	 * 2nd:	d31-d16 -> low address
	 */

	/* reset chip */
	a = IE_PORT_RESET;
	ier->ie_porthigh = a & 0xffff;
	t = 0;
	t = 1;
	ier->ie_portlow = a >> 16;
	for (t = timo; t--;)
		;

	/* set new SCP pointer */
	a = (int) &iem->im_scp | IE_PORT_NEWSCP;
	ier->ie_porthigh = a & 0xffff;
	t = 0;
	t = 1;
	ier->ie_portlow = a >> 16;
	for (t = timo; t--;)
		;

	ier->ie_attention = 1;	/* chan attention! */
	for (t = timo * 10; t--;)
		;

	/* send CONFIGURE command */
	iem->im_scb.ie_command = IE_CU_START;
	iem->im_scb.ie_command_list = (int) &iem->im_cc - (int) iem;
	iem->im_cc.com.ie_cmd_status = 0;
	iem->im_cc.com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;
	iem->im_cc.com.ie_cmd_link = 0xffff;
	iem->im_cc.ie_config_count = 0x0c;
	iem->im_cc.ie_fifo = 8;
	iem->im_cc.ie_save_bad = 0x40;
	iem->im_cc.ie_addr_len = 0x2e;
	iem->im_cc.ie_priority = 0;
	iem->im_cc.ie_ifs = 0x60;
	iem->im_cc.ie_slot_low = 0;
	iem->im_cc.ie_slot_high = 0xf2;
	iem->im_cc.ie_promisc = 0;
	iem->im_cc.ie_crs_cdt = 0;
	iem->im_cc.ie_min_len = 64;
	iem->im_cc.ie_junk = 0xff;

	ier->ie_attention = 1;	/* chan attention! */
	for (t = timo * 10; t--;)
		;

	ieack(ier, iem);

	/*printf("ic %x\n", &iem->im_ic);*/
	/* send IASETUP command */
	iem->im_scb.ie_command = IE_CU_START;
	iem->im_scb.ie_command_list = (int) &iem->im_ic - (int) iem;
	iem->im_ic.com.ie_cmd_status = 0;
	iem->im_ic.com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;
	iem->im_ic.com.ie_cmd_link = 0xffff;
	bcopy(myea, (void *)&iem->im_ic.ie_address, sizeof iem->im_ic.ie_address);

	ier->ie_attention = 1;	/* chan attention! */
	for (t = timo * 10; t--;)
		;

	ieack(ier, iem);

	/* setup buffers */

	for (i = 0; i < NRXBUF; i++) {
		iem->im_rfd[i].ie_fd_next = (int) &iem->im_rfd[(i+1) % NRXBUF] -
		    (int) iem;
		iem->im_rbd[i].ie_rbd_next = (int) &iem->im_rbd[(i+1) % NRXBUF] -
		    (int) iem;
		a = (int) &iem->im_rxbuf[i * IE_RBUF_SIZE];
		iem->im_rbd[i].ie_rbd_buffer_low = a & 0xffff;
		iem->im_rbd[i].ie_rbd_buffer_high = a >> 16;
		iem->im_rbd[i].ie_rbd_length = IE_RBUF_SIZE;
	}
	iem->im_rfd[NRXBUF-1].ie_fd_last |= IE_FD_LAST;
	iem->im_rbd[NRXBUF-1].ie_rbd_length |= IE_RBD_LAST;
	iem->im_rfd[0].ie_fd_buf_desc = (int) &iem->im_rbd[0] - (int) iem;

	/*printf("rfd[0] %x rbd[0] %x buf[0] %x\n", &iem->im_rfd, &iem->im_rbd,
	    &iem->im_rxbuf);*/

	/* send receiver start command */
	iem->im_scb.ie_command = IE_RU_START;
	iem->im_scb.ie_command_list = 0;
	iem->im_scb.ie_recv_list = (int) &iem->im_rfd[0] - (int) iem;
	ier->ie_attention = 1;	/* chan attention! */
	while (iem->im_scb.ie_command)
		;

	ieack(ier, iem);
}

int
ie_poll(struct iodesc *desc, void *pkt, int len)
{
	volatile struct iereg *ier = ie_softc.sc_reg;
	struct iemem *iem = ie_softc.sc_mem;
	static int slot;
	int     length = 0;
	u_short status;

	asm(".word	0xf518\n");	/* pflusha */
	status = iem->im_rfd[slot].ie_fd_status;
	if (status & IE_FD_BUSY)
		return (0);

	/* printf("slot %d: %x\n", slot, status); */
	if ((status & (IE_FD_COMPLETE | IE_FD_OK)) == (IE_FD_COMPLETE | IE_FD_OK)) {
		if (status & IE_FD_OK) {
			length = iem->im_rbd[slot].ie_rbd_actual & 0x3fff;
			if (length > len)
				length = len;
			bcopy((void *)&iem->im_rxbuf[slot * IE_RBUF_SIZE],
			    pkt, length);

			iem->im_rfd[slot].ie_fd_status = 0;
			iem->im_rfd[slot].ie_fd_last |= IE_FD_LAST;
			iem->im_rfd[(slot+NRXBUF-1)%NRXBUF].ie_fd_last &=
			    ~IE_FD_LAST;
			iem->im_rbd[slot].ie_rbd_actual = 0;
			iem->im_rbd[slot].ie_rbd_length |= IE_RBD_LAST;
			iem->im_rbd[(slot+NRXBUF-1)%NRXBUF].ie_rbd_length &=
			    ~IE_RBD_LAST;
			/*printf("S%d\n", slot);*/

		} else {
			printf("shit\n");
		}
		slot++;
		/* should move descriptor onto end of queue... */
	}
	if ((iem->im_scb.ie_status & IE_RU_READY) == 0) {
		printf("RR\n");

		for (slot = 0; slot < NRXBUF; slot++) {
			iem->im_rbd[slot].ie_rbd_length &= ~IE_RBD_LAST;
			iem->im_rfd[slot].ie_fd_last &= ~IE_FD_LAST;
		}
		iem->im_rbd[NRXBUF-1].ie_rbd_length |= IE_RBD_LAST;
		iem->im_rfd[NRXBUF-1].ie_fd_last |= IE_FD_LAST;

		iem->im_rfd[0].ie_fd_buf_desc = (int)&iem->im_rbd[0] - (int)iem;

		iem->im_scb.ie_command = IE_RU_START;
		iem->im_scb.ie_command_list = 0;
		iem->im_scb.ie_recv_list = (int)&iem->im_rfd[0] - (int)iem;
		ier->ie_attention = 1;	/* chan attention! */
		while (iem->im_scb.ie_command)
			;
		slot = 0;
	}
	slot = slot % NRXBUF;
	return (length);
}

int
ie_put(struct iodesc *desc, void *pkt, size_t len)
{
	volatile struct iereg *ier = ie_softc.sc_reg;
	struct iemem *iem = ie_softc.sc_mem;
	u_char *p = pkt;
	u_int   a;
	int     xx = 0;

	/* send transmit command */

	while (iem->im_scb.ie_command)
		;

	/* copy data */
	bcopy(p, (void *)&iem->im_txbuf[xx], len);

	if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
		bzero((char *)&iem->im_txbuf[xx] + len,
		    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
		len = ETHER_MIN_LEN - ETHER_CRC_LEN;
	}

	/* build transmit descriptor */
	iem->im_xd[xx].ie_xmit_flags = len | IE_XMIT_LAST;
	iem->im_xd[xx].ie_xmit_next = 0xffff;
	a = (int) &iem->im_txbuf[xx];
	iem->im_xd[xx].ie_xmit_buf_low = a & 0xffff;
	iem->im_xd[xx].ie_xmit_buf_high = a >> 16;

	/* transmit command */
	iem->im_xc[xx].com.ie_cmd_status = 0;
	iem->im_xc[xx].com.ie_cmd_cmd = IE_CMD_XMIT | IE_CMD_LAST;
	iem->im_xc[xx].com.ie_cmd_link = 0xffff;
	iem->im_xc[xx].ie_xmit_desc = (int) &iem->im_xd[xx] - (int) iem;
	iem->im_xc[xx].ie_xmit_length = len;
	bcopy(p, (void *)&iem->im_xc[xx].ie_xmit_addr,
	    sizeof iem->im_xc[xx].ie_xmit_addr);

	iem->im_scb.ie_command = IE_CU_START;
	iem->im_scb.ie_command_list = (int) &iem->im_xc[xx] - (int) iem;

	ier->ie_attention = 1;	/* chan attention! */

	if (ie_debug) {
		printf("ie%d: send %ld to %x:%x:%x:%x:%x:%x\n",
		    desc->io_netif->nif_unit, len,
		    p[0], p[1], p[2], p[3], p[4], p[5]);
	}
	return (len);
}

int
ie_get(struct iodesc *desc, void *pkt, size_t len, time_t timeout)
{
	time_t  t;
	int     cc;

	t = getsecs();
	cc = 0;
	while (((getsecs() - t) < timeout) && !cc) {
		cc = ie_poll(desc, pkt, len);
	}
	return (cc);
}
/*
 * init ie device.   return 0 on failure, 1 if ok.
 */
void
ie_init(struct iodesc *desc, void *machdep_hint)
{
	struct netif *nif = desc->io_netif;

	if (ie_debug)
		printf("ie%d: ie_init called\n", desc->io_netif->nif_unit);
	machdep_common_ether(desc->myea);
	bzero(&ie_softc, sizeof(ie_softc));
	ie_softc.sc_reg =
	    (struct iereg *) ie_config[desc->io_netif->nif_unit].phys_addr;
	/* use 64KB below HEAP as buffers */
	ie_softc.sc_mem = (struct iemem *)(HEAP_START - 0x10000);
	ie_reset(desc->io_netif, desc->myea);
	printf("device: %s%d attached to %s\n", nif->nif_driver->netif_bname,
	    nif->nif_unit, ether_sprintf(desc->myea));
}

void
ie_stop(struct netif *nif)
{
	volatile struct iereg *ier = ie_softc.sc_reg;
	struct iemem *iem = ie_softc.sc_mem;
	int     timo = 10000;
	volatile int t;
	u_int   a;

	iem->im_iscp.iscp_busy = 1;
	/* reset chip */
	a = IE_PORT_RESET;
	ier->ie_porthigh = a & 0xffff;
	t = 0;
	t = 1;
	ier->ie_portlow = a >> 16;
	for (t = timo; t--;)
		;

	/* reset chip again */
	a = IE_PORT_RESET;
	ier->ie_porthigh = a & 0xffff;
	t = 0;
	t = 1;
	ier->ie_portlow = a >> 16;
	for (t = timo; t--;)
		;

	/*printf("status %x busy %x\n", iem->im_scb.ie_status,
	    iem->im_iscp.iscp_busy);*/
}

void
ie_end(struct netif *nif)
{
	if (ie_debug)
		printf("ie%d: ie_end called\n", nif->nif_unit);

	ie_stop(nif);

	/* *(u_char *) 0xfff42002 = 0; */
}
@


1.14
log
@Switch mvme68k boot blocks to use the MI libsa loadfile routines to load
kernel images, instead of their own; gives us the ability to load ELF kernels
for free.

Fix many warnings, and generally make the code closer to the current mvme88k
boot blocks to help diffability.

Rewrite bugcrt and bugexec() as a short assembly shim around a
compiler-independent C block; this will allow compilers other than gcc2 to be
used, and removes the need for bugcrt to be compiled without optimization.

Crank all bootblocks versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.13 2009/02/17 18:42:06 miod Exp $ */
@


1.13
log
@Move ethernet buffers higher in memory, just below our text, to allow
larger bsd.rd to load correctly. Tested on MVME147 (if_le) and MVME167 (if_ie).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.12 2003/08/20 00:26:00 deraadt Exp $ */
d48 1
d65 1
d161 1
a161 1
	int     timo = 10000, stat, i;
a285 1
	u_char *p = pkt;
a287 1
	u_int   a;
d290 1
a290 1
	asm(".word	0xf518\n");
a349 2
	int     timo = 10000, stat, i;
	volatile int t;
d389 1
a389 1
		printf("ie%d: send %d to %x:%x:%x:%x:%x:%x\n",
d423 2
a424 2
	/* use 64KB below our code as buffers */
	ie_softc.sc_mem = (struct iemem *)(STAGE2_RELOC - 0x10000);
@


1.12
log
@ansi and protos for the rest
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.11 2003/06/04 16:36:14 deraadt Exp $ */
d425 2
a426 2
	/* printf("buffer @@0x%x\n", RELOC - 0x20000);*/
	ie_softc.sc_mem = (struct iemem *) 0x3e0000;
@


1.11
log
@more term 3 & 4 from various developers, with permission of course
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.10 2003/01/28 01:37:52 jason Exp $ */
d5 1
a5 1
 * 
d102 1
a102 3
ie_match(nif, machdep_hint)
	struct netif *nif;
	void   *machdep_hint;
d126 1
a126 3
ie_probe(nif, machdep_hint)
	struct netif *nif;
	void   *machdep_hint;
d139 1
a139 4
ie_error(nif, str, ier)
	struct netif *nif;
	char   *str;
	volatile struct iereg *ier;
d144 2
a145 3
ieack(ier, iem)
	volatile struct iereg *ier;
	struct iemem *iem;
d155 1
a155 3
ie_reset(nif, myea)
	struct netif *nif;
	u_char *myea;
d280 1
a280 4
ie_poll(desc, pkt, len)
	struct iodesc *desc;
	void   *pkt;
	int     len;
d345 1
a345 4
ie_put(desc, pkt, len)
	struct	iodesc *desc;
	void	*pkt;
	size_t	len;
d399 1
a399 5
ie_get(desc, pkt, len, timeout)
	struct	iodesc *desc;
	void	*pkt;
	size_t	len;
	time_t	timeout;
d415 1
a415 3
ie_init(desc, machdep_hint)
	struct iodesc *desc;
	void   *machdep_hint;
d433 1
a433 2
ie_stop(nif)
	struct netif *nif;
d465 1
a465 2
ie_end(nif)
	struct netif *nif;
@


1.10
log
@pad < minimal length packets with 0's; based on netbsd; tested by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.9 2002/03/14 01:26:38 millert Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.8 2000/01/24 05:20:56 smurph Exp $ */
d42 1
d385 5
a389 1
	len = MAX(len, ETHER_MIN_LEN);
@


1.8
log
@Fixed bug in disksubr.c relating to disklabels.  Added MVME376 support to le.  Made installboot insert M68K for volume ID, not M88K.  Correctly documented installboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.7 2000/01/06 03:21:44 smurph Exp $ */
d59 10
a68 10
void ie_stop __P((struct netif *));
void ie_end __P((struct netif *));
void ie_error __P((struct netif *, char *, volatile struct iereg *));
int ie_get __P((struct iodesc *, void *, size_t, time_t));
void ie_init __P((struct iodesc *, void *));
int ie_match __P((struct netif *, void *));
int ie_poll __P((struct iodesc *, void *, int));
int ie_probe __P((struct netif *, void *));
int ie_put __P((struct iodesc *, void *, size_t));
void ie_reset __P((struct netif *, u_char *));
@


1.8.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.8 2000/01/24 05:20:56 smurph Exp $ */
d59 10
a68 10
void ie_stop(struct netif *);
void ie_end(struct netif *);
void ie_error(struct netif *, char *, volatile struct iereg *);
int ie_get(struct iodesc *, void *, size_t, time_t);
void ie_init(struct iodesc *, void *);
int ie_match(struct netif *, void *);
int ie_poll(struct iodesc *, void *, int);
int ie_probe(struct netif *, void *);
int ie_put(struct iodesc *, void *, size_t);
void ie_reset(struct netif *, u_char *);
@


1.8.12.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a41 1
#define ETHER_CRC_LEN	4
d384 1
a384 5
	if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
		bzero((char *)&iem->im_txbuf[xx] + len,
		    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
		len = ETHER_MIN_LEN - ETHER_CRC_LEN;
	}
@


1.8.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d59 10
a68 10
void ie_stop(struct netif *);
void ie_end(struct netif *);
void ie_error(struct netif *, char *, volatile struct iereg *);
int ie_get(struct iodesc *, void *, size_t, time_t);
void ie_init(struct iodesc *, void *);
int ie_match(struct netif *, void *);
int ie_poll(struct iodesc *, void *, int);
int ie_probe(struct netif *, void *);
int ie_put(struct iodesc *, void *, size_t);
void ie_reset(struct netif *, u_char *);
@


1.8.2.2
log
@Sync the SMP branch with 3.3
@
text
@a41 1
#define ETHER_CRC_LEN	4
d384 1
a384 5
	if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
		bzero((char *)&iem->im_txbuf[xx] + len,
		    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
		len = ETHER_MIN_LEN - ETHER_CRC_LEN;
	}
@


1.8.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.8.2.2 2003/03/27 23:32:17 niklas Exp $ */
d14 6
@


1.8.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 *
d102 3
a104 1
ie_match(struct netif *nif, void *machdep_hint)
d128 3
a130 1
ie_probe(struct netif *nif, void *machdep_hint)
d143 4
a146 1
ie_error(struct netif *nif, char *str, volatile struct iereg *ier)
d151 3
a153 2
static void
ieack(volatile struct iereg *ier, struct iemem *iem)
d163 3
a165 1
ie_reset(struct netif *nif, u_char *myea)
d290 4
a293 1
ie_poll(struct iodesc *desc, void *pkt, int len)
d358 4
a361 1
ie_put(struct iodesc *desc, void *pkt, size_t len)
d415 5
a419 1
ie_get(struct iodesc *desc, void *pkt, size_t len, time_t timeout)
d435 3
a437 1
ie_init(struct iodesc *desc, void *machdep_hint)
d455 2
a456 1
ie_stop(struct netif *nif)
d488 2
a489 1
ie_end(struct netif *nif)
@


1.7
log
@Added support for MVME177 (mc68060)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.6 1999/01/11 05:11:41 millert Exp $ */
d448 2
a449 1
	ie_softc.sc_mem = (struct iemem *) 0x2e0000;
@


1.6
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.5 1996/05/16 02:55:36 chuck Exp $ */
d448 1
a448 1
	ie_softc.sc_mem = (struct iemem *) 0x1e0000;
@


1.5
log
@clean up and sync with changes elsewhere (use common parse_args,
bugargs.cputyp, bugcrt, etc...).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d153 1
a153 1
	panic("ie%d: unknown error\n", nif->nif_unit);
@


1.4
log
@add OpenBSD header
@
text
@d47 2
d50 1
a112 1
	extern int cputyp;
d114 1
a114 1
	if (cputyp == CPU_147)
a136 1
	extern int cputyp;
d142 1
a142 1
	if (cputyp != CPU_147)
@


1.3
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
@


1.2
log
@update to new libsa
@
text
@d1 1
a1 1
/*	$NetBSD: le_poll.c,v 1.3 1994/10/26 09:11:48 cgd Exp $	*/
d5 1
a5 2
 * All rights reserved.
 *
d16 3
a18 2
 *	This product includes software developed by Theo de Raadt
 * 4. The name of the Author may not be used to endorse or promote products
@


1.1
log
@Initial revision
@
text
@d59 1
a59 1
int ie_get __P((struct iodesc *, void *, int, time_t));
d64 1
a64 1
int ie_put __P((struct iodesc *, void *, int));
d255 1
a255 1
	bcopy(myea, &iem->im_ic.ie_address, sizeof iem->im_ic.ie_address);
d318 1
a318 1
			bcopy(&iem->im_rxbuf[slot * IE_RBUF_SIZE],
d363 3
a365 3
	struct iodesc *desc;
	void   *pkt;
	int     len;
d381 1
a381 1
	bcopy(p, &iem->im_txbuf[xx], len);
d398 2
a399 1
	bcopy(p, &iem->im_xc[xx].ie_xmit_addr, sizeof iem->im_xc[xx].ie_xmit_addr);
d416 4
a419 4
	struct iodesc *desc;
	void   *pkt;
	int     len;
	time_t  timeout;
@


1.1.1.1
log
@mvme68k port by me. some parts by dale rahn.
@
text
@@
