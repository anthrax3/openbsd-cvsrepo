head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.12.0.12
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.8
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.10
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.6
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.17;

1.17
date	2013.09.29.21.30.49;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2012.12.31.21.35.32;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.20.13.10.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.19.18.11.19;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.30.02.13.04;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.17.00.28.56;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.25.23.36.46;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.16.17.46.28;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.01.17.00.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.04.08.06.55;	author niklas;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.01.24.05.20.55;	author smurph;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.26.18.05.32;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.42.04;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.05.16.02.32.43;	author chuck;	state Exp;
branches;
next	;

1.4.2.1
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.03.28.10.34.06;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2004.02.19.10.49.05;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.36.51;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: installboot.c,v 1.17 2013/09/29 21:30:49 jmc Exp $ */
/*	$NetBSD: installboot.c,v 1.5 1995/11/17 23:23:50 gwr Exp $ */

/*
 * Copyright (c) 1994 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <err.h>
#include <a.out.h>
#include <fcntl.h>
#include <nlist.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

int	verbose, nowrite, hflag;
char	*boot, *proto, *dev;
char  cdev[80];

struct nlist nl[] = {
#define X_BLOCK_SIZE	0
	{ { "_block_size" } },
#define X_BLOCK_COUNT	1
	{ { "_block_count" } },
#define X_BLOCK_TABLE	2
	{ { "_block_table" } },
	{ { NULL } }
};

int *block_size_p;		/* block size var. in prototype image */
int *block_count_p;		/* block count var. in prototype image */
daddr32_t	*block_table;	/* block number array in prototype image */
int	maxblocknum;		/* size of this array */


char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int);
static void	devread(int, void *, daddr32_t, size_t, char *);
static void	usage(void);
int 		main(int, char *[]);
static void     vid_to_disklabel(char *, char *);

static void
usage(void)
{
	fprintf(stderr,
	    "usage: installboot [-nv] boot bootxx rawdev\n");
	exit(1);
}

int
main(argc, argv)
	int argc;
	char *argv[];
{
	int	c, devfd;
	char	*protostore;
	long	protosize;

	while ((c = getopt(argc, argv, "vnh")) != -1) {
		switch (c) {
		case 'h':
			/* Don't strip a.out header */
			hflag = 1;
			break;
		case 'n':
			/* Do not actually write the bootblock to disk */
			nowrite = 1;
			break;
		case 'v':
			/* Chat */
			verbose = 1;
			break;
		default:
			usage();
		}
	}

	if (argc - optind < 3) {
		usage();
	}

	boot = argv[optind];
	proto = argv[optind + 1];
	dev = argv[optind + 2];
	strlcpy(cdev, dev, sizeof cdev);
	cdev[strlen(cdev)-1] = 'c';

	if (verbose) {
		printf("boot: %s\n", boot);
		printf("proto: %s\n", proto);
		printf("device: %s\n", dev);
		printf("cdevice: %s\n", cdev);
	}

	/* Insert VID into disklabel */
	vid_to_disklabel(cdev, proto);

	/* Load proto blocks into core */
	if ((protostore = loadprotoblocks(proto, &protosize)) == NULL)
		exit(1);

	/* XXX - Paranoia: Make sure size is aligned! */
	if (protosize & (DEV_BSIZE - 1))
		err(1, "proto bootblock bad size=%ld", protosize);

	/* Open and check raw disk device */
	if ((devfd = open(dev, O_RDONLY, 0)) < 0)
		err(1, "open: %s", dev);

	/* Extract and load block numbers */
	if (loadblocknums(boot, devfd) != 0)
		exit(1);

	(void)close(devfd);

	if (nowrite)
		return 0;

	/* Write patched proto bootblocks into the superblock */
	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");

	if ((devfd = open(cdev, O_RDWR, 0)) < 0)
		err(1, "open: %s", dev);

	if (lseek(devfd, DEV_BSIZE, SEEK_SET) != DEV_BSIZE)
		err(1, "lseek bootstrap");

	/* Sync filesystems (to clean in-memory superblock?) */
	sync();

	if (write(devfd, protostore, protosize) != protosize)
		err(1, "write bootstrap");
	(void)close(devfd);
	return 0;
}

char *
loadprotoblocks(fname, size)
	char *fname;
	long *size;
{
	int	fd;
	size_t	tdsize;		/* text+data size */
	size_t	bbsize;		/* boot block size (block aligned) */
	char	*bp;
	struct	nlist *nlp;
	struct	exec eh;
	long	off;

	fd = -1;
	bp = NULL;

	/* Locate block number array in proto file */
	if (nlist(fname, nl) != 0) {
		warnx("nlist: %s: symbols not found", fname);
		return NULL;
	}
	/* Validate symbol types (global data). */
	for (nlp = nl; nlp->n_un.n_name; nlp++) {
		if (nlp->n_type != (N_DATA | N_EXT)) {
			warnx("nlist: %s: wrong type", nlp->n_un.n_name);
			return NULL;
		}
	}

	if ((fd = open(fname, O_RDONLY)) < 0) {
		warn("open: %s", fname);
		return NULL;
	}
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
		warn("read: %s", fname);
		goto bad;
	}
	if (N_GETMAGIC(eh) != OMAGIC) {
		warn("bad magic: 0x%x", eh.a_midmag);
		goto bad;
	}
	/*
	 * We have to include the exec header in the beginning of
	 * the buffer, and leave extra space at the end in case
	 * the actual write to disk wants to skip the header.
	 */
	tdsize = eh.a_text + eh.a_data;
	bbsize = tdsize + sizeof(eh);
	bbsize = roundup(bbsize, DEV_BSIZE);

	/*
	 * Allocate extra space here because the caller may copy
	 * the boot block starting at the end of the exec header.
	 * This prevents reading beyond the end of the buffer.
	 */
	if ((bp = calloc(bbsize + sizeof(eh), 1)) == NULL) {
		warnx("malloc: %s: no memory", fname);
		goto bad;
	}
	/* Copy the exec header and read the rest of the file. */
	memcpy(bp, &eh, sizeof(eh));
	if (read(fd, bp+sizeof(eh), tdsize) != tdsize) {
		warn("read: %s", fname);
		goto bad;
	}

	*size = bbsize;	/* aligned to DEV_BSIZE */

	/* Calculate the symbols' locations within the proto file */
	off = N_DATOFF(eh) - N_DATADDR(eh) - (eh.a_entry - N_TXTADDR(eh));
	block_size_p  =   (int *) (bp + nl[X_BLOCK_SIZE ].n_value + off);
	block_count_p =   (int *) (bp + nl[X_BLOCK_COUNT].n_value + off);
	block_table = (daddr32_t *) (bp + nl[X_BLOCK_TABLE].n_value + off);
	maxblocknum = *block_count_p;

	if (verbose) {
		printf("%s: entry point %#x\n", fname, eh.a_entry);
		printf("proto bootblock size %ld\n", *size);
		printf("room for %d filesystem blocks at %#lx\n",
		    maxblocknum, nl[X_BLOCK_TABLE].n_value);
	}

	close(fd);
	if (!hflag)
		bp += sizeof(struct exec);
	return bp;

 bad:
	if (bp)
		free(bp);
	if (fd >= 0)
		close(fd);
	return NULL;
}

static void
devread(int fd, void *buf, daddr32_t blk, size_t size, char *msg)
{
	if (lseek(fd, dbtob(blk), SEEK_SET) != dbtob(blk))
		err(1, "%s: devread: lseek", msg);

	if (read(fd, buf, size) != size)
		err(1, "%s: devread: read", msg);
}

static char sblock[SBSIZE];

int
loadblocknums(char *boot, int devfd)
{
	int		i, fd;
	struct	stat	statbuf;
	struct	statfs	statfsbuf;
	struct fs	*fs;
	char		*buf;
	daddr32_t		blk, *ap;
	struct ufs1_dinode	*ip;
	int		ndb;

	/*
	 * Open 2nd-level boot program and record the block numbers
	 * it occupies on the filesystem represented by `devfd'.
	 */

	/* Make sure the (probably new) boot file is on disk. */
	sync(); sleep(1);

	if ((fd = open(boot, O_RDONLY)) < 0)
		err(1, "open: %s", boot);

	if (fstatfs(fd, &statfsbuf) != 0)
		err(1, "statfs: %s", boot);

	if (strncmp(statfsbuf.f_fstypename, "ffs", MFSNAMELEN) &&
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) ) {
		errx(1, "%s: must be on an FFS filesystem", boot);
	}

	if (fsync(fd) != 0)
		err(1, "fsync: %s", boot);

	if (fstat(fd, &statbuf) != 0)
		err(1, "fstat: %s", boot);

	close(fd);

	/* Read superblock */
	devread(devfd, sblock, SBLOCK, SBSIZE, "superblock");
	fs = (struct fs *)sblock;

	/* Sanity-check super-block. */

	if (fs->fs_magic != FS_MAGIC)
		errx(1, "Bad magic number in superblock");

	if (fs->fs_inopb <= 0)
		err(1, "Bad inopb=%d in superblock", fs->fs_inopb);

	/* Read inode */
	if ((buf = malloc(fs->fs_bsize)) == NULL)
		errx(1, "No memory for filesystem block");

	blk = fsbtodb(fs, ino_to_fsba(fs, statbuf.st_ino));
	devread(devfd, buf, blk, fs->fs_bsize, "inode");
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);

	/*
	 * Have the inode.  Figure out how many blocks we need.
	 */
	ndb = howmany(ip->di_size, fs->fs_bsize);
	if (ndb > maxblocknum)
		errx(1, "Too many blocks");
	*block_count_p = ndb;
	*block_size_p = fs->fs_bsize;
	if (verbose)
		printf("Will load %d blocks of size %d each.\n",
			   ndb, fs->fs_bsize);

	/*
	 * Get the block numbers; we don't handle fragments
	 */
	ap = ip->di_db;
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--) {
		blk = fsbtodb(fs, *ap);
		if (verbose)
			printf("%d: %d\n", i, blk);
		block_table[i] = blk;
	}
	if (ndb == 0)
		return 0;

	/*
	 * Just one level of indirections; there isn't much room
	 * for more in the 1st-level bootblocks anyway.
	 */
	blk = fsbtodb(fs, ip->di_ib[0]);
	devread(devfd, buf, blk, fs->fs_bsize, "indirect block");
	ap = (daddr32_t *)buf;
	for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--) {
		blk = fsbtodb(fs, *ap);
		if (verbose)
			printf("%d: %d\n", i, blk);
		block_table[i] = blk;
	}

	return 0;
}

static void
vid_to_disklabel(char *dkname, char *bootproto)
{
	char *specname;
	int exe_file, f;
	struct mvmedisklabel *pcpul;
	struct stat sb;
	unsigned int exe_addr;

	pcpul = (struct mvmedisklabel *)malloc(sizeof(struct mvmedisklabel));
	bzero(pcpul, sizeof(struct mvmedisklabel));

	if (verbose)
		printf("modifying vid.\n");

	exe_file = open(bootproto, O_RDONLY, 0444);
	if (exe_file == -1) {
		perror(bootproto);
		exit(2);
	}

	f = opendev(dkname, O_RDWR, OPENDEV_PART, &specname);

	if (lseek(f, 0, SEEK_SET) < 0 ||
	    read(f, pcpul, sizeof(struct mvmedisklabel)) !=
	    sizeof(struct mvmedisklabel))
		err(4, "%s", specname);


	pcpul->version = 1;
	strncpy(pcpul->vid_id, "M68K", 4);

	if (fstat(exe_file, &sb) == -1)
		err(1, "fstat: %s", bootproto);
	if (sb.st_size < 0x20)
		errx(1, "%s is too small", bootproto);

	/* size in 256 byte blocks round up after a.out header removed */

	pcpul->vid_oss = 2;
	pcpul->vid_osl = (((sb.st_size -0x20) +511) / 512) *2;

	lseek(exe_file, 0x14, SEEK_SET);
	read(exe_file, &exe_addr, 4);

	/* check this, it may not work in both endian. */
	/* No, it doesn't.  Use a big endian machine for now. SPM */

	{
		union {
			struct s {
				unsigned short s1;
				unsigned short s2;
			} s;
			unsigned long l;
		} a;
		a.l = exe_addr;
		pcpul->vid_osa_u = a.s.s1;
		pcpul->vid_osa_l = a.s.s2;

	}
	pcpul->vid_cas = 1;
	pcpul->vid_cal = 1;

	/* do not want to write past end of structure, not null terminated */

	strncpy(pcpul->vid_mot, "MOTOROLA", 8);

	pcpul->cfg_rec = 0x100;
	pcpul->cfg_psm = 0x200;

	if (!nowrite) {
		if (lseek(f, 0, SEEK_SET) < 0 ||
		    write(f, pcpul, sizeof(struct mvmedisklabel)) <
		    sizeof(struct mvmedisklabel))
		    	err(4, "%s", specname);
	}
	free(pcpul);

	close(exe_file);
	close(f);
}
@


1.17
log
@various fixes to sync usage() with SYNOPSIS, and make these pages a bit
more consistent;

feedback/ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.16 2012/12/31 21:35:32 miod Exp $ */
@


1.16
log
@Switch mvme68k boot blocks to use the MI libsa loadfile routines to load
kernel images, instead of their own; gives us the ability to load ELF kernels
for free.

Fix many warnings, and generally make the code closer to the current mvme88k
boot blocks to help diffability.

Rewrite bugcrt and bugexec() as a short assembly shim around a
compiler-independent C block; this will allow compilers other than gcc2 to be
used, and removes the need for bugcrt to be compiled without optimization.

Crank all bootblocks versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.15 2011/03/13 00:13:53 deraadt Exp $ */
d83 1
a83 1
	    "usage: installboot [-n] [-v] [-h] <boot> <proto> <device>\n");
@


1.15
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.14 2010/11/20 13:10:41 deraadt Exp $ */
d58 1
a58 1
	{"_block_size"},
d60 1
a60 1
	{"_block_count"},
d62 2
a63 2
	{"_block_table"},
	{NULL}
d141 1
a141 1
		err(1, "proto bootblock bad size=%d", protosize);
d253 1
a253 1
		printf("room for %d filesystem blocks at %#x\n",
a390 2
	unsigned short exe_addr_u;
	unsigned short exe_addr_l;
@


1.14
log
@some more installboot cleanup from gapz@@dud-t.org
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.13 2010/11/19 18:11:19 deraadt Exp $ */
d68 1
a68 1
daddr_t	*block_table;	/* block number array in prototype image */
d74 1
a74 1
static void	devread(int, void *, daddr_t, size_t, char *);
d247 1
a247 1
	block_table = (daddr_t *) (bp + nl[X_BLOCK_TABLE].n_value + off);
d271 1
a271 1
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
d290 1
a290 1
	daddr_t		blk, *ap;
d372 1
a372 1
	ap = (daddr_t *)buf;
@


1.13
log
@gapz@@dud-t . org noted that sparc64 installboot crashes if the bootblock is
zero-sized.  Apply similar fixes to installboot for other architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.12 2008/01/30 02:13:04 krw Exp $ */
d417 1
a417 1
	if (fstat(exe_file, &sb);
@


1.12
log
@Oops. Missed one.

More read/write result checking fixes to avoid unsigned comparisons vs
-1.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.11 2007/06/17 00:28:56 deraadt Exp $ */
d389 1
a389 1
	struct stat stat;
d417 4
a420 1
	fstat(exe_file, &stat);
d425 1
a425 1
	pcpul->vid_osl = (((stat.st_size -0x20) +511) / 512) *2;
@


1.11
log
@amd64/stand
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.10 2003/08/25 23:36:46 tedu Exp $ */
d409 1
a409 1
	    read(f, pcpul, sizeof(struct mvmedisklabel)) <
@


1.10
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.9 2003/08/16 17:46:28 deraadt Exp $ */
d38 1
a50 1
#include <machine/disklabel.h>
d388 1
a388 1
	struct cpu_disklabel *pcpul;
d394 2
a395 2
	pcpul = (struct cpu_disklabel *)malloc(sizeof(struct cpu_disklabel));
	bzero(pcpul, sizeof(struct cpu_disklabel));
d409 2
a410 2
	    read(f, pcpul, sizeof(struct cpu_disklabel)) <
	    sizeof(struct cpu_disklabel))
d455 2
a456 2
		    write(f, pcpul, sizeof(struct cpu_disklabel)) <
		    sizeof(struct cpu_disklabel))
@


1.9
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.8 2003/06/01 17:00:36 deraadt Exp $ */
d291 1
a291 1
	struct dinode	*ip;
d339 1
a339 1
	ip = (struct dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
@


1.8
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.7 2002/03/14 03:15:56 millert Exp $ */
d50 1
a50 1
#include <machine/disklabel.h> 	
a78 1

d80 1
a80 1
usage()
d83 1
a83 1
		"usage: installboot [-n] [-v] [-h] <boot> <proto> <device>\n");
d92 1
a92 2
	int	c;
	int	devfd;
d124 1
a124 1
	
d131 1
a131 1
	
d134 1
a134 1
	
d254 1
a254 1
			maxblocknum, nl[X_BLOCK_TABLE].n_value);
d271 1
a271 6
devread(fd, buf, blk, size, msg)
	int	fd;
	void	*buf;
	daddr_t	blk;
	size_t	size;
	char	*msg;
d283 1
a283 3
loadblocknums(boot, devfd)
char	*boot;
int	devfd;
d326 2
a327 2
	
   if (fs->fs_magic != FS_MAGIC)
d329 2
a330 2
	
   if (fs->fs_inopb <= 0)
d384 1
a384 3
vid_to_disklabel(dkname, bootproto)
char *dkname;
char *bootproto;
d397 1
a397 1
	if (verbose) 
d409 3
a411 3
		    read(f, pcpul, sizeof(struct cpu_disklabel)) 
			< sizeof(struct cpu_disklabel))
			    err(4, "%s", specname);
d454 3
a456 3
	    if (lseek(f, 0, SEEK_SET) < 0 || 
		write(f, pcpul, sizeof(struct cpu_disklabel))
		    < sizeof(struct cpu_disklabel))
d460 1
a460 1
	
a462 1

@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.6 2002/03/14 01:26:38 millert Exp $ */
d124 1
a124 1
	strcpy(cdev, dev);
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.5 2001/07/04 08:06:55 niklas Exp $ */
d77 1
a77 1
static void     vid_to_disklabel(char *, char*);
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.5 1995/11/17 23:23:50 gwr Exp $ */
d72 6
a77 6
char		*loadprotoblocks __P((char *, long *));
int		loadblocknums __P((char *, int));
static void	devread __P((int, void *, daddr_t, size_t, char *));
static void	usage __P((void));
int 		main __P((int, char *[]));
static void     vid_to_disklabel __P((char *, char*));
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.5 2001/07/04 08:06:55 niklas Exp $ */
d72 6
a77 6
char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
int 		main(int, char *[]);
static void     vid_to_disklabel(char *, char *);
@


1.4
log
@Fixed bug in disksubr.c relating to disklabels.  Added MVME376 support to le.  Made installboot insert M68K for volume ID, not M88K.  Correctly documented installboot.
@
text
@d1 1
@


1.4.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*	$OpenBSD$ */
@


1.4.2.2
log
@Merge in -current from about a week ago
@
text
@d72 6
a77 6
char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
int 		main(int, char *[]);
static void     vid_to_disklabel(char *, char *);
@


1.4.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.4.2.2 2002/03/28 10:34:06 niklas Exp $ */
d124 1
a124 1
	strlcpy(cdev, dev, sizeof cdev);
@


1.4.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d50 1
a50 1
#include <machine/disklabel.h>
d79 1
d81 1
a81 1
usage(void)
d84 1
a84 1
	    "usage: installboot [-n] [-v] [-h] <boot> <proto> <device>\n");
d93 2
a94 1
	int	c, devfd;
d126 1
a126 1

d133 1
a133 1

d136 1
a136 1

d256 1
a256 1
		    maxblocknum, nl[X_BLOCK_TABLE].n_value);
d273 6
a278 1
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
d290 3
a292 1
loadblocknums(char *boot, int devfd)
d300 1
a300 1
	struct ufs1_dinode	*ip;
d335 2
a336 2

	if (fs->fs_magic != FS_MAGIC)
d338 2
a339 2

	if (fs->fs_inopb <= 0)
d348 1
a348 1
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
d393 3
a395 1
vid_to_disklabel(char *dkname, char *bootproto)
d408 1
a408 1
	if (verbose)
d420 3
a422 3
	    read(f, pcpul, sizeof(struct cpu_disklabel)) <
	    sizeof(struct cpu_disklabel))
		err(4, "%s", specname);
d465 3
a467 3
		if (lseek(f, 0, SEEK_SET) < 0 ||
		    write(f, pcpul, sizeof(struct cpu_disklabel)) <
		    sizeof(struct cpu_disklabel))
d471 1
a471 1

d474 1
@


1.3
log
@This fixes installboot.
@
text
@d425 1
a425 1
	strcpy(pcpul->vid_id, "M88K");
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d48 2
d53 2
d76 1
d123 3
a125 1

d130 1
d132 4
a135 1

d161 1
a161 1
	if ((devfd = open(dev, O_RDWR, 0)) < 0)
d334 2
a335 1
	if (fs->fs_magic != FS_MAGIC)
d337 2
a338 1
	if (fs->fs_inopb <= 0)
d391 84
@


1.1
log
@import installboot from sun3/sparc ports
@
text
@d92 1
a92 1
	while ((c = getopt(argc, argv, "vnh")) != EOF) {
@
