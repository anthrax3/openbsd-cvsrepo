head	1.37;
access;
symbols
	OPENBSD_5_5:1.36.0.6
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.6
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.4
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.14
	UBC:1.7.0.12
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.36;

1.36
date	2013.03.23.16.12.25;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2011.11.01.21.20.55;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.24.12.18.58;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.01.22.08.13;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.01.21.40.49;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.21.20.33.23;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.30.17.10.44;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.24.14.04.02;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.11.20.48.13;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.24.22.43.19;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.14.12.52.39;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.01.11.54.25;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.30.22.29.48;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.13.21.49.18;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.20.09.20.42;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.27.50;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.05.09.14;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.07.21.33.43;	author nordin;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.28.14.47.53;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.27.23.21.05;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.25.22.18.20;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.23.08.04.14;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.21.23.43.40;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.06.03.21.43;	author smurph;	state Exp;
branches
	1.7.2.1
	1.7.12.1;
next	1.6;

1.6
date	97.03.31.00.23.59;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.02.10.17.49.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.28.10.56.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.21.14.40.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.10;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.43.10;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2002.03.28.10.34.05;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.06.07.11.13.15;	author ho;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2004.06.05.23.10.53;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2004.06.06.05.23.39;	author tedu;	state Exp;
branches;
next	;

1.7.12.1
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: cpu.h,v 1.36 2013/03/23 16:12:25 deraadt Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: cpu.h 1.16 91/03/25$
 *
 *	@@(#)cpu.h	8.4 (Berkeley) 1/5/94
 */

#ifndef _MACHINE_CPU_H_
#define _MACHINE_CPU_H_

/*
 * Exported definitions unique to mvme68k cpu support.
 */

/*
 * Get common m68k CPU definiti÷ns.
 */
#include <m68k/cpu.h>

#ifdef _KERNEL

/*
 * Get interrupt glue.
 */
#include <machine/intr.h>

/*
 * Arguments to hardclock and gatherstats encapsulate the previous
 * machine state in an opaque clockframe.  On the m68k, we use
 * what the hardware pushes on an interrupt (frame format 0).
 */
struct clockframe {
	u_short	sr;		/* sr at time of interrupt */
	u_long	pc;		/* pc at time of interrupt */
	u_short	vo;		/* vector offset (4-word frame) */
};

#define	CLKF_USERMODE(framep)	(((framep)->sr & PSL_S) == 0)
#define	CLKF_PC(framep)		((framep)->pc)
#if 0
/* We would like to do it this way... */
#define	CLKF_INTR(framep)	(((framep)->sr & PSL_M) == 0)
#else
/* but until we start using PSL_M, we have to do this instead */
#define	CLKF_INTR(framep)	(0)	/* XXX */
#endif


/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern int want_resched;
#define	need_resched(ci)	{ want_resched = 1; aston(); }
#define clear_resched(ci) 	want_resched = 0

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the m68k, request an ast to send us
 * through trap, marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	aston()

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#define	signotify(p)	aston()

extern int astpending;
#define aston() (astpending = 1)

#endif	/* _KERNEL */

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_MAXID		2	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
}

#ifdef _KERNEL

extern	vaddr_t intiobase, intiolimit;
extern	vaddr_t iiomapbase;
extern	int iiomapsize;

/* physical memory sections for mvme141 */
#define	INTIOBASE_141	(0xfff50000)
#define	INTIOTOP_141	(0xfffc0000)
#define	INTIOSIZE_141	((INTIOTOP_141-INTIOBASE_141)/PAGE_SIZE)

/* physical memory sections for mvme147 */
#define	INTIOBASE_147	(0xfffe0000)
#define	INTIOTOP_147	(0xfffe5000)
#define	INTIOSIZE_147	((INTIOTOP_147-INTIOBASE_147)/PAGE_SIZE)

/* physical memory sections for mvme16x */
#define	INTIOBASE_162	(0xfff00000)
#define	INTIOTOP_162	(0xfffd0000)		/* was 0xfff50000 */
#define	INTIOSIZE_162	((INTIOTOP_162-INTIOBASE_162)/PAGE_SIZE)

/* physical memory sections for mvme165 */
#define	INTIOBASE_165	(0xfff90000)
#define	INTIOTOP_165	(0xffff0000)
#define	INTIOSIZE_165	((INTIOTOP_165-INTIOBASE_165)/PAGE_SIZE)

/*
 * Internal IO space (iiomapsize).
 *
 * Internal IO space is mapped in the kernel from ``intiobase'' to
 * ``intiolimit'' (defined in locore.s).  Since it is always mapped,
 * conversion between physical and kernel virtual addresses is easy.
 */
#define	ISIIOVA(va) \
	((va) >= intiobase && (va) < intiolimit)
#define	IIOV(pa)	((pa) - iiomapbase + intiobase)
#define	IIOP(va)	((va) - intiobase + iiomapbase)
#define	IIOPOFF(pa)	((pa) - iiomapbase)

extern int	cputyp;
#define CPU_141			0x141
#define CPU_147			0x147
#define CPU_162			0x162
#define CPU_165			0x165
#define CPU_166			0x166
#define CPU_167			0x167
#define CPU_172			0x172
#define CPU_176			0x176
#define CPU_177			0x177

#include <sys/evcount.h>

struct intrhand {
	SLIST_ENTRY(intrhand) ih_link;
	int	(*ih_fn)(void *);
	void	*ih_arg;
	int	ih_ipl;
	int	ih_wantframe;
	struct evcount ih_count;
};

int intr_establish(int, struct intrhand *, const char *);

#define	NVMEINTR	256

/* locore.s */
__dead void	doboot(void);

int badpaddr(paddr_t, int);
int badvaddr(vaddr_t, int);
void nmihand(void *);
int intr_findvec(int, int);

paddr_t kvtop(vaddr_t);

#endif	/* _KERNEL */
#endif	/* _MACHINE_CPU_H_ */
@


1.36
log
@refactor sys/param.h and machine/param.h.  A lot of #ifdef _KERNEL is added
to keep definitions our of user space.  The MD files now follow a consistant
order -- all namespace intrusion is at the tail can be cleaned up
independently.  locore, bootblocks, and libkvm still see enough visibility to
build.  Checked on 90% of platforms...
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2011/11/01 21:20:55 miod Exp $ */
@


1.35
log
@Drop support for the HP MMU. It was only found on two hp300 systems (models
320 and 350), which have been unsupported since a bunch of release already,
because this annoying MMU does not have TT registers (or if it does, it is
not documented) and thus went in the way of PMAP_DIRECT for hp300.
In other words: remove a bunch of code which was either #ifdef'ed out or
had no chance to run in real life.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2011/03/23 16:54:36 pirofti Exp $ */
d151 1
a151 1
#define	INTIOSIZE_141	((INTIOTOP_141-INTIOBASE_141)/NBPG)
d156 1
a156 1
#define	INTIOSIZE_147	((INTIOTOP_147-INTIOBASE_147)/NBPG)
d161 1
a161 1
#define	INTIOSIZE_162	((INTIOTOP_162-INTIOBASE_162)/NBPG)
d166 1
a166 1
#define	INTIOSIZE_165	((INTIOTOP_165-INTIOBASE_165)/NBPG)
@


1.34
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2010/07/24 12:18:58 miod Exp $ */
a73 1
#define M68K_MMU_MOTOROLA
@


1.33
log
@One the -> On the
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2009/03/26 17:24:33 oga Exp $ */
d64 2
a65 2
#ifndef _MVME68K_CPU_H_
#define _MVME68K_CPU_H_
d219 1
a219 1
#endif	/* _MVME68K_CPU_H_ */
@


1.32
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2009/03/01 22:08:13 miod Exp $ */
d86 1
a86 1
 * machine state in an opaque clockframe.  One the m68k, we use
@


1.31
log
@Support for MVME141 boards. Tested with both VME and VSB memory boards
(and MVME327 SCSI and MVME376 Ethernet, to provide a complete system).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2009/03/01 21:40:49 miod Exp $ */
a82 6

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_wait(p)			/* nothing */
@


1.30
log
@Support for MVME165 board - code written in april 2006, eventually debugged
last month.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2009/02/21 20:33:23 miod Exp $ */
d155 5
d189 1
@


1.29
log
@dma_cachectl() bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2008/07/18 23:43:31 art Exp $ */
d165 5
d190 1
@


1.28
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2007/05/30 17:10:44 miod Exp $ */
a209 1
void dma_cachectl(caddr_t, int);
@


1.27
log
@More cpuinfo vs _KERNEL fallback.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2007/03/15 10:22:29 art Exp $ */
d118 1
@


1.26
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2006/11/29 12:26:13 miod Exp $ */
d77 1
a77 1
#ifdef	_KERNEL
d135 2
d147 2
@


1.25
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2006/06/24 14:04:02 miod Exp $ */
d124 1
a124 1
#define	need_proftick(p)	{ (p)->p_flag |= P_OWEUPC; aston(); }
@


1.24
log
@Replace physaccess() usage with pmap_kenter_cache().
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2006/06/11 20:48:13 miod Exp $ */
a87 1
#define	cpu_swapin(p)			/* nothing */
a88 1
#define cpu_swapout(p)			/* nothing */
@


1.23
log
@Move common prototypes to <m68k/{cpu,param}.h> instead of incomplete
declarations in <machine/{cpu,param}.h> and elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2005/11/24 22:43:19 miod Exp $ */
a208 2
void physaccess(vaddr_t, paddr_t, size_t, int);
void physunaccess(vaddr_t, size_t);
@


1.22
log
@Prefer vaddr_t and paddr_t types in device softc, instead of void * and
heavy casts. Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2005/08/14 12:52:39 miod Exp $ */
a71 11
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_MAXID		2	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
}

/*
a82 1
#include <sys/evcount.h>
d137 11
d184 2
d199 1
a199 28
struct frame;
struct fpframe;
struct pcb;

void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
void	DCIA(void);
void	DCIS(void);
void	DCIU(void);
void	ICIA(void);
void	ICPA(void);
void	PCIA(void);
void	TBIA(void);
void	TBIS(vaddr_t);
void	TBIAS(void);
void	TBIAU(void);
#if defined(M68040) || defined(M68060)
void	DCFA(void);
void	DCFP(paddr_t);
void	DCFL(paddr_t);
void	DCPL(paddr_t);
void	DCPP(paddr_t);
void	ICPL(paddr_t);
void	ICPP(paddr_t);
#endif
int	suline(caddr_t, caddr_t);
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
a200 2
void	loadustp(int);
void	proc_trampoline(void);
@


1.21
log
@DCIAS() no more.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2005/08/01 11:54:25 miod Exp $ */
d149 2
a150 2
extern	char *intiobase, *intiolimit;
extern	char *iiomapbase;
d171 4
a174 4
	((char *)(va) >= intiobase && (char *)(va) < intiolimit)
#define	IIOV(pa)	((int)(pa)-(int)iiomapbase+(int)intiobase)
#define	IIOP(va)	((int)(va)-(int)intiobase+(int)iiomapbase)
#define	IIOPOFF(pa)	((int)(pa)-(int)iiomapbase)
@


1.20
log
@Factorize cachectl() accross m68k platforms, and make the CC_ constants
public.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2004/07/30 22:29:48 miod Exp $ */
a205 1
void	DCIAS(vaddr_t);
@


1.19
log
@Move struct evcount inside struct intrhand, and modernize intrhand
usage; similar to (and from) mvme88k.

Also remove unused haltvec structures and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2004/06/13 21:49:18 niklas Exp $ */
a235 1
int cachectl(struct proc *, int, vaddr_t, int);
@


1.18
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d94 1
d179 1
d186 1
a186 1
	struct	intrhand *ih_next;
d191 1
d194 1
a194 1
int intr_establish(int, struct intrhand *);
d196 1
a196 5
struct haltvec {
	struct haltvec *hv_next;
	void	(*hv_fn)(void);
	int	hv_pri;
};
@


1.17
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2003/06/02 23:27:50 millert Exp $ */
d130 1
a130 1
#define	need_resched()	{ want_resched = 1; aston(); }
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2003/06/02 05:09:14 deraadt Exp $ */
d237 1
@


1.15
log
@license cleanup of my files
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2002/06/07 21:33:43 nordin Exp $ */
d43 1
a43 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@Remove obsolete CLKF_BASEPRI(). ok niklas@@, miod@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2002/04/28 14:47:53 miod Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@A few more tweaks to let non-GENERIC kernels (MVMEfoo) build as well with -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2002/04/27 23:21:05 miod Exp $ */
a124 1
#define	CLKF_BASEPRI(framep)	(((framep)->sr & PSL_IPL) == 0)
@


1.12
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2002/04/25 22:18:20 miod Exp $ */
d227 1
a227 1
#if defined(M68040)
@


1.11
log
@<m68k/cpu.h> should be included when this <machine/cpu.h> is included from
userland, for example from libkvm; found the hard way be deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2002/04/23 08:04:14 miod Exp $ */
d140 1
a140 1
int want_resched;
d156 1
a156 1
int astpending;
d196 1
a196 1
	int	(*ih_fn)();
d202 2
d209 43
@


1.10
log
@Oops, unbreak; deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2002/04/21 23:43:40 miod Exp $ */
a91 2
#ifdef	_KERNEL

d97 2
@


1.9
log
@Get rid of duplicate definitions with <m68k/cpu.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2002/03/14 01:26:37 millert Exp $ */
d140 1
a140 1
extern int want_resched;
d156 1
a156 1
extern int astpending;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2000/01/06 03:21:43 smurph Exp $ */
d78 1
a78 1
 * Exported definitions unique to mvme68k/68k cpu support.
d81 16
d101 5
d140 2
a141 1
#define	need_resched()	{ want_resched++; aston(); }
d156 2
a157 30
#define aston() (astpending++)

int	astpending;		/* need to trap before returning to user mode */
int	want_resched;		/* resched() was called */

/*
 * Get interrupt glue.
 */
#include <machine/intr.h>

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_MAXID		2	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
}

/* values for mmutype (assigned for quick testing) */
#define	MMU_68040	-2	/* 68040 on-chip MMU */
#define	MMU_68030	-1	/* 68030 on-chip subset of 68851 */
#define	MMU_68851	1	/* Motorola 68851 */

/* values for ectype */
#define	EC_PHYS		-1	/* external physical address cache */
#define	EC_NONE		0	/* no external cache */
#define	EC_VIRT		1	/* external virtual address cache */
a158 2
#ifdef _KERNEL
extern	int mmutype, ectype;
a161 1
#endif
a185 61
/*
 * 68851 and 68030 MMU
 */
#define	PMMU_LVLMASK	0x0007
#define	PMMU_INV	0x0400
#define	PMMU_WP		0x0800
#define	PMMU_ALV	0x1000
#define	PMMU_SO		0x2000
#define	PMMU_LV		0x4000
#define	PMMU_BE		0x8000
#define	PMMU_FAULT	(PMMU_WP|PMMU_INV)

/*
 * 68040 MMU
 */
#define	MMU4_RES	0x001
#define	MMU4_TTR	0x002
#define	MMU4_WP		0x004
#define	MMU4_MOD	0x010
#define	MMU4_CMMASK	0x060
#define	MMU4_SUP	0x080
#define	MMU4_U0		0x100
#define	MMU4_U1		0x200
#define	MMU4_GLB	0x400
#define	MMU4_BE		0x800

/* 680X0 function codes */
#define	FC_USERD	1	/* user data space */
#define	FC_USERP	2	/* user program space */
#define	FC_SUPERD	5	/* supervisor data space */
#define	FC_SUPERP	6	/* supervisor program space */
#define	FC_CPU		7	/* CPU space */

/* fields in the 68020 cache control register */
#define	IC_ENABLE	0x0001	/* enable instruction cache */
#define	IC_FREEZE	0x0002	/* freeze instruction cache */
#define	IC_CE		0x0004	/* clear instruction cache entry */
#define	IC_CLR		0x0008	/* clear entire instruction cache */

/* additional fields in the 68030 cache control register */
#define	IC_BE		0x0010	/* instruction burst enable */
#define	DC_ENABLE	0x0100	/* data cache enable */
#define	DC_FREEZE	0x0200	/* data cache freeze */
#define	DC_CE		0x0400	/* clear data cache entry */
#define	DC_CLR		0x0800	/* clear entire data cache */
#define	DC_BE		0x1000	/* data burst enable */
#define	DC_WA		0x2000	/* write allocate */

#define	CACHE_ON	(DC_WA|DC_BE|DC_CLR|DC_ENABLE|IC_BE|IC_CLR|IC_ENABLE)
#define	CACHE_OFF	(DC_CLR|IC_CLR)
#define	CACHE_CLR	(CACHE_ON)
#define	IC_CLEAR	(DC_WA|DC_BE|DC_ENABLE|IC_BE|IC_CLR|IC_ENABLE)
#define	DC_CLEAR	(DC_WA|DC_BE|DC_CLR|DC_ENABLE|IC_BE|IC_ENABLE)

/* 68040 cache control register */
#define	IC4_ENABLE	0x00008000	/* instruction cache enable bit */
#define	DC4_ENABLE	0x80000000	/* data cache enable bit */

#define	CACHE4_ON	(IC4_ENABLE|DC4_ENABLE)
#define	CACHE4_OFF	(0)

d207 3
a209 1
#endif
@


1.7
log
@Added support for MVME177 (mc68060)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 1997/03/31 00:23:59 downsj Exp $ */
d274 1
a274 1
	void	(*hv_fn) __P((void));
@


1.7.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2000/01/06 03:21:43 smurph Exp $ */
d78 1
a78 1
 * Exported definitions unique to mvme68k cpu support.
a80 14
/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_MAXID		2	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
}

/*
 * Get common m68k CPU definiti÷ns.
 */
a83 7
#ifdef	_KERNEL

/*
 * Get interrupt glue.
 */
#include <machine/intr.h>

d104 1
d119 1
a119 2
extern int want_resched;
#define	need_resched()	{ want_resched = 1; aston(); }
d134 4
a137 2
extern int astpending;
#define aston() (astpending = 1)
d139 28
d170 1
d195 61
d266 1
a266 1
	int	(*ih_fn)(void *);
a271 2
int intr_establish(int, struct intrhand *);

d274 1
a274 1
	void	(*hv_fn)(void);
a276 26

struct frame;
struct fpframe;
struct pcb;

void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
void	DCIA(void);
void	DCIS(void);
void	DCIAS(vaddr_t);
void	DCIU(void);
void	ICIA(void);
void	ICPA(void);
void	PCIA(void);
void	TBIA(void);
void	TBIS(vaddr_t);
void	TBIAS(void);
void	TBIAU(void);
#if defined(M68040) || defined(M68060)
void	DCFA(void);
void	DCFP(paddr_t);
void	DCFL(paddr_t);
void	DCPL(paddr_t);
void	DCPP(paddr_t);
void	ICPL(paddr_t);
void	ICPP(paddr_t);
a277 19
int	suline(caddr_t, caddr_t);
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
__dead void	doboot(void);
void	loadustp(int);
void	proc_trampoline(void);

int badpaddr(paddr_t, int);
int badvaddr(vaddr_t, int);
void nmihand(void *);
int intr_findvec(int, int);

void dma_cachectl(caddr_t, int);
paddr_t kvtop(vaddr_t);
void physaccess(vaddr_t, paddr_t, size_t, int);
void physunaccess(vaddr_t, size_t);

#endif	/* _KERNEL */
#endif	/* _MVME68K_CPU_H_ */
@


1.7.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d274 1
a274 1
	void	(*hv_fn)(void);
@


1.7.2.2
log
@Sync the SMP branch with 3.3
@
text
@d78 1
a78 1
 * Exported definitions unique to mvme68k cpu support.
a80 14
/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_MAXID		2	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
}

/*
 * Get common m68k CPU definiti÷ns.
 */
a83 7
#ifdef	_KERNEL

/*
 * Get interrupt glue.
 */
#include <machine/intr.h>

d104 1
d119 1
a119 2
extern int want_resched;
#define	need_resched()	{ want_resched = 1; aston(); }
d134 4
a137 2
extern int astpending;
#define aston() (astpending = 1)
d139 28
d170 1
d195 61
d266 1
a266 1
	int	(*ih_fn)(void *);
a271 2
int intr_establish(int, struct intrhand *);

a276 26

struct frame;
struct fpframe;
struct pcb;

void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
void	DCIA(void);
void	DCIS(void);
void	DCIAS(vaddr_t);
void	DCIU(void);
void	ICIA(void);
void	ICPA(void);
void	PCIA(void);
void	TBIA(void);
void	TBIS(vaddr_t);
void	TBIAS(void);
void	TBIAU(void);
#if defined(M68040) || defined(M68060)
void	DCFA(void);
void	DCFP(paddr_t);
void	DCFL(paddr_t);
void	DCPL(paddr_t);
void	DCPP(paddr_t);
void	ICPL(paddr_t);
void	ICPP(paddr_t);
a277 19
int	suline(caddr_t, caddr_t);
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
__dead void	doboot(void);
void	loadustp(int);
void	proc_trampoline(void);

int badpaddr(paddr_t, int);
int badvaddr(vaddr_t, int);
void nmihand(void *);
int intr_findvec(int, int);

void dma_cachectl(caddr_t, int);
paddr_t kvtop(vaddr_t);
void physaccess(vaddr_t, paddr_t, size_t, int);
void physunaccess(vaddr_t, size_t);

#endif	/* _KERNEL */
#endif	/* _MVME68K_CPU_H_ */
@


1.7.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7.2.2 2003/03/27 23:32:17 niklas Exp $ */
d14 6
d49 5
a53 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.2.4
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a236 1
int cachectl(struct proc *, int, vaddr_t, int);
@


1.7.2.5
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7.2.4 2004/06/05 23:10:53 niklas Exp $ */
d130 1
a130 1
#define	need_resched(ci)	{ want_resched = 1; aston(); }
@


1.6
log
@Modernize OpenBSD/mvme68k to match various changes in m68k and hp300 code.

Compiles, but untested for lack of hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 1997/02/10 17:49:09 deraadt Exp $ */
a138 1

d140 1
a140 1
 * simulated software interrupt register
d142 1
a142 9
extern unsigned char ssir;

#define SIR_NET		0x1
#define SIR_CLOCK	0x2

#define setsoftint(x)	ssir |= (x)
#define setsoftnet()	ssir |= SIR_NET
#define setsoftclock()	ssir |= SIR_CLOCK
u_long	allocate_sir __P((void (*proc)(), void *arg));
@


1.5
log
@make it work
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d74 3
d286 1
@


1.4
log
@add OpenBSD header
@
text
@d78 3
@


1.3
log
@from netbsd; cpu_setstack() is depricated
@
text
@d1 1
a1 1
/*	$Id: cpu.h,v 1.2 1995/11/07 08:49:47 deraadt Exp $ */
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
a83 1
#define cpu_setstack(p, ap)		(p)->p_md.md_regs[SP] = ap
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.1.1.1 1995/07/25 23:12:13 chuck Exp $	*/
d4 29
d89 1
a89 1
 * machine state in an opaque clockframe.  One the mvme68k, we use
d118 1
a118 1
 * buffer pages are invalid.  On the hp300, request an ast to send us
a143 1
#define siroff(x)	ssir &= ~(x)
d146 1
a146 2

extern unsigned long allocate_sir();
a168 3
#define	MHZ_16		2	/* XXX kill */


a170 1
extern	int cpuspeed;			/* XXX kill */
d172 2
d177 8
a184 2
#define	INTIOBASE	(0xfffe0000)
#define	INTIOTOP	(0xfffe5000)
d187 1
a187 3
 * Internal IO space:
 *
 * Ranges from 0x800000 to 0x1000000 (IIOMAPSIZE).
d195 3
a197 4
#define	IIOV(pa)	((int)(pa)-INTIOBASE+(int)intiobase)
#define	IIOP(va)	((int)(va)-(int)intiobase+INTIOBASE)
#define	IIOPOFF(pa)	((int)(pa)-INTIOBASE)
#define	IIOMAPSIZE	btoc(INTIOTOP-INTIOBASE)	/* 1mb */
d254 1
a254 1
#define	IC4_ENABLE	0x8000		/* instruction cache enable bit */
d259 22
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.4 1995/03/28 18:15:31 jtc Exp $	*/
a3 1
 * Copyright (c) 1995 Theo de Raadt
d60 1
a60 1
 * machine state in an opaque clockframe.  One the m68k, we use
d89 1
a89 1
 * buffer pages are invalid.  On the m68k, request an ast to send us
d115 1
d118 2
a119 1
u_long	allocate_sir __P((void (*proc)(), void *arg));
d142 3
d147 1
a148 2
extern	char *iiomapbase;
extern	int iiomapsize;
d152 2
a153 8
#define	INTIOBASE_147	(0xfffe0000)
#define	INTIOTOP_147	(0xfffe5000)
#define	INTIOSIZE_147	((INTIOTOP_147-INTIOBASE_147)/NBPG)

/* physical memory sections for mvme16x */
#define	INTIOBASE_162	(0xfff00000)
#define	INTIOTOP_162	(0xfffd0000)		/* was 0xfff50000 */
#define	INTIOSIZE_162	((INTIOTOP_162-INTIOBASE_162)/NBPG)
d156 3
a158 1
 * Internal IO space (iiomapsize).
d166 4
a169 3
#define	IIOV(pa)	((int)(pa)-(int)iiomapbase+(int)intiobase)
#define	IIOP(va)	((int)(va)-(int)intiobase+(int)iiomapbase)
#define	IIOPOFF(pa)	((int)(pa)-(int)iiomapbase)
d226 1
a226 1
#define	IC4_ENABLE	0x00008000	/* instruction cache enable bit */
a230 22

extern int	cputyp;
#define CPU_147			0x147
#define CPU_162			0x162
#define CPU_166			0x166
#define CPU_167			0x167
#define CPU_172			0x172
#define CPU_177			0x177

struct intrhand {
	struct	intrhand *ih_next;
	int	(*ih_fn)();
	void	*ih_arg;
	int	ih_ipl;
	int	ih_wantframe;
};

struct haltvec {
	struct haltvec *hv_next;
	void	(*hv_fn) __P((void));
	int	hv_pri;
};
@
