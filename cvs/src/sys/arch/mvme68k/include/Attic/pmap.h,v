head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.52
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.48
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.46
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.44
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.42
	OPENBSD_5_0:1.12.0.40
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.38
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.36
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.32
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.34
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.30
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.28
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.26
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.24
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.22
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.20
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.18
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.16
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.14
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.12
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.10
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.10
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	theo-1:1.1.1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.22.22.45.34;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.20.19.02.29;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.30.20.58.18;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.28.15.34.16;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.06.12.56.18;	author art;	state Exp;
branches;
next	1.5;

1.5
date	98.03.01.00.37.38;	author niklas;	state Exp;
branches
	1.5.10.1;
next	1.4;

1.4
date	97.03.31.00.24.05;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.04.28.10.56.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.07.08.49.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.11;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	95.10.18.10.43.23;	author deraadt;	state Exp;
branches;
next	;

1.5.10.1
date	2001.04.18.16.10.36;	author niklas;	state Exp;
branches;
next	1.5.10.2;

1.5.10.2
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.5.10.3;

1.5.10.3
date	2002.03.28.10.34.06;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.15;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: pmap.h,v 1.12 2002/03/14 01:26:37 millert Exp $	*/

#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_

#include <m68k/pmap_motorola.h>

#ifdef	_KERNEL
void pmap_init_md(void);
#define	PMAP_INIT_MD()	pmap_init_md()
#endif

#endif	/* _MACHINE_PMAP_H_ */
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.11 2002/02/22 22:45:34 miod Exp $	*/
@


1.11
log
@Switch mvme68k to pmap_motorola again.
68060 operation tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9 2001/11/30 20:58:18 miod Exp $	*/
d9 1
a9 1
void pmap_init_md __P((void));
@


1.10
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d3 2
a4 39
/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	8.1 (Berkeley) 6/10/93
 */
d6 1
a6 2
#ifndef	_MVME68K_PMAP_H_
#define	_MVME68K_PMAP_H_
d8 3
a10 6
#include <machine/pte.h>

#if defined(M68040)
#define M68K_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
#else
#define M68K_SEG_SIZE	NBSEG
d13 1
a13 102
/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	st_entry_t		*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	long			pm_ptpages;	/* more stats: PT pages */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  8 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	8
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define	PMAP_ACTIVATE(pmap, loadhw)					\
{									\
	if ((loadhw))							\
		loadustp(m68k_btop((vm_offset_t)(pmap)->pm_stpa));	\
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry, the list is pv_table.
 */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vm_offset_t	pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
};

#define	PV_CI		0x01	/* header: all entries are cache inhibited */
#define PV_PTPAGE	0x02	/* header: entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	170

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};

#ifdef	_KERNEL

extern struct pmap	kernel_pmap_store;

#define pmap_kernel()	(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define	active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)


extern struct pv_entry	*pv_table;	/* array of entries, one per page */

#define pmap_page_index(pa)		atop(pa - vm_first_phys)

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update(pmap)			/* nothing */

extern pt_entry_t	*Sysmap;
extern char		*vmmap;		/* map for mem, dumps, etc. */
#endif /* _KERNEL */

#endif /* !_MVME68K_PMAP_H_ */
@


1.9
log
@Switch to pmap_motorola.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 39
a41 2
#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_
d43 87
a129 1
#include <m68k/pmap_motorola.h>
a131 3
void pmap_init_md __P((void));
#define	PMAP_INIT_MD()	pmap_init_md()
#endif
d133 23
a155 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.10 2001/12/20 19:02:29 miod Exp $	*/
d3 2
a4 39
/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	8.1 (Berkeley) 6/10/93
 */
d6 1
a6 2
#ifndef	_MVME68K_PMAP_H_
#define	_MVME68K_PMAP_H_
d8 3
a10 6
#include <machine/pte.h>

#if defined(M68040)
#define M68K_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
#else
#define M68K_SEG_SIZE	NBSEG
d13 1
a13 102
/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	st_entry_t		*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	long			pm_ptpages;	/* more stats: PT pages */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  8 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	8
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define	PMAP_ACTIVATE(pmap, loadhw)					\
{									\
	if ((loadhw))							\
		loadustp(m68k_btop((vm_offset_t)(pmap)->pm_stpa));	\
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry, the list is pv_table.
 */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vm_offset_t	pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
};

#define	PV_CI		0x01	/* header: all entries are cache inhibited */
#define PV_PTPAGE	0x02	/* header: entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	170

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};

#ifdef	_KERNEL

extern struct pmap	kernel_pmap_store;

#define pmap_kernel()	(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define	active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)


extern struct pv_entry	*pv_table;	/* array of entries, one per page */

#define pmap_page_index(pa)		atop(pa - vm_first_phys)

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update(pmap)			/* nothing */

extern pt_entry_t	*Sysmap;
extern char		*vmmap;		/* map for mem, dumps, etc. */
#endif /* _KERNEL */

#endif /* !_MVME68K_PMAP_H_ */
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9.2.1 2002/01/31 22:55:15 niklas Exp $	*/
d3 39
a41 2
#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_
d43 87
a129 1
#include <m68k/pmap_motorola.h>
a131 3
void pmap_init_md(void);
#define	PMAP_INIT_MD()	pmap_init_md()
#endif
d133 23
a155 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.8
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.7 2001/11/28 15:34:16 art Exp $ */
d3 2
a4 39
/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	8.1 (Berkeley) 6/10/93
 */
d6 1
a6 2
#ifndef	_MVME68K_PMAP_H_
#define	_MVME68K_PMAP_H_
d8 3
a10 6
#include <machine/pte.h>

#if defined(M68040)
#define M68K_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
#else
#define M68K_SEG_SIZE	NBSEG
d13 1
a13 105
#define m68k_trunc_seg(x)	(((unsigned)(x)) & ~(M68K_SEG_SIZE-1))
#define m68k_round_seg(x)	m68k_trunc_seg((unsigned)(x) + M68K_SEG_SIZE-1)

/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	st_entry_t		*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	long			pm_ptpages;	/* more stats: PT pages */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  8 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	8
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define	PMAP_ACTIVATE(pmap, loadhw)					\
{									\
	if ((loadhw))							\
		loadustp(m68k_btop((vm_offset_t)(pmap)->pm_stpa));	\
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry, the list is pv_table.
 */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vm_offset_t	pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
};

#define	PV_CI		0x01	/* header: all entries are cache inhibited */
#define PV_PTPAGE	0x02	/* header: entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	170

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};

#ifdef	_KERNEL

extern struct pmap	kernel_pmap_store;

#define pmap_kernel()	(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define	active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)


extern struct pv_entry	*pv_table;	/* array of entries, one per page */

#define pmap_page_index(pa)		atop(pa - vm_first_phys)

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update()			/* nothing */

extern pt_entry_t	*Sysmap;
extern char		*vmmap;		/* map for mem, dumps, etc. */
#endif /* _KERNEL */

#endif /* !_MVME68K_PMAP_H_ */
@


1.7
log
@Make pmap_update functions into nops so that we can have a consistent
pmap_update API (right now it's nop).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2000/07/06 12:56:18 art Exp $ */
d67 1
a67 1
	simple_lock_data_t	pm_lock;	/* lock on pmap */
@


1.6
log
@Fix pmap_activate and activation of the
correct pmap.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 1998/03/01 00:37:38 niklas Exp $ */
d152 1
@


1.5
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 1997/03/31 00:24:05 downsj Exp $ */
a62 1
	int			pm_stchanged;	/* ST changed */
d93 5
a97 8
#define PMAP_ACTIVATE(pmapp, pcbp, iscurproc) \
	if ((pmapp)->pm_stchanged) { \
		(pcbp)->pcb_ustp = m68k_btop((vm_offset_t)(pmapp)->pm_stpa); \
		if (iscurproc) \
			loadustp((pcbp)->pcb_ustp); \
		(pmapp)->pm_stchanged = FALSE; \
	}
#define PMAP_DEACTIVATE(pmapp, pcbp)
d141 4
@


1.5.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2000/07/06 12:56:18 art Exp $ */
d63 1
d94 8
a101 5
#define	PMAP_ACTIVATE(pmap, loadhw)					\
{									\
	if ((loadhw))							\
		loadustp(m68k_btop((vm_offset_t)(pmap)->pm_stpa));	\
}
a144 4
#define	active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

@


1.5.10.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 39
a41 2
#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_
d43 90
a132 1
#include <m68k/pmap_motorola.h>
a134 3
void pmap_init_md __P((void));
#define	PMAP_INIT_MD()	pmap_init_md()
#endif
d136 22
a157 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.5.10.3
log
@Merge in -current from about a week ago
@
text
@d9 1
a9 1
void pmap_init_md(void);
@


1.4
log
@Modernize OpenBSD/mvme68k to match various changes in m68k and hp300 code.

Compiles, but untested for lack of hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3 1996/04/28 10:56:25 deraadt Exp $ */
a148 1
#define pa_to_pvh(pa)			(&pv_table[pmap_page_index(pa)])
@


1.3
log
@add OpenBSD header
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d43 2
a44 2
#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_
d158 1
a158 1
#endif /* !_MACHINE_PMAP_H_ */
@


1.2
log
@$Id$ throughout
update many copyrights
@
text
@d1 1
a1 1
/*	$Id$ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pmap.h,v 1.1.1.1 1995/07/25 23:12:16 chuck Exp $	*/
d49 1
a49 1
#define HP_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
d51 1
a51 1
#define HP_SEG_SIZE	NBSEG
d54 2
a55 2
#define m68k_trunc_seg(x)	(((unsigned)(x)) & ~(HP_SEG_SIZE-1))
#define m68k_round_seg(x)	m68k_trunc_seg((unsigned)(x) + HP_SEG_SIZE-1)
a140 1
extern vm_offset_t	vm_first_phys, vm_num_phys;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@mvme68k port by me. some parts by dale rahn.
@
text
@d1 1
a1 1
/*	$NetBSD: pmap.h,v 1.9 1995/05/11 16:53:03 jtc Exp $	*/
d49 1
a49 1
#define M68K_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
d51 1
a51 1
#define M68K_SEG_SIZE	NBSEG
d54 2
a55 2
#define m68k_trunc_seg(x)	(((unsigned)(x)) & ~(M68K_SEG_SIZE-1))
#define m68k_round_seg(x)	m68k_trunc_seg((unsigned)(x) + M68K_SEG_SIZE-1)
d141 1
@

