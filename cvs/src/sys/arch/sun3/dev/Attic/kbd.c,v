head	1.10;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.12
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2002.12.31.16.35.40;	author miod;	state dead;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.08.08.22.42.11;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.27.05.44.51;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.02.17.50.26;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	97.08.19.23.09.35;	author kstailey;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	97.08.19.11.48.04;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.31.06.41.10;	author deraadt;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.08.51.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.52;	author deraadt;	state Exp;
branches;
next	;

1.4.12.1
date	2001.05.14.21.37.27;	author niklas;	state Exp;
branches;
next	1.4.12.2;

1.4.12.2
date	2001.07.04.10.23.55;	author niklas;	state Exp;
branches;
next	1.4.12.3;

1.4.12.3
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.4.12.4;

1.4.12.4
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.4.12.5;

1.4.12.5
date	2003.03.27.23.52.17;	author niklas;	state dead;
branches;
next	;

1.8.4.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2003.05.19.21.49.44;	author tedu;	state dead;
branches;
next	;


desc
@@


1.10
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: kbd.c,v 1.9 2002/03/14 01:26:46 millert Exp $	*/
/*	$NetBSD: kbd.c,v 1.8 1996/05/17 19:32:06 gwr Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kbd.c	8.2 (Berkeley) 10/30/93
 */

/*
 * Keyboard driver (/dev/kbd -- note that we do not have minor numbers
 * [yet?]).  Translates incoming bytes to ASCII or to `firm_events' and
 * passes them up to the appropriate reader.
 */

/*
 * Zilog Z8530 Dual UART driver (keyboard interface)
 *
 * This is the "slave" driver that will be attached to
 * the "zsc" driver for a Sun keyboard.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/signalvar.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <dev/ic/z8530reg.h>
#include <machine/z8530var.h>
#include <machine/vuid_event.h>
#include <machine/kbd.h>
#include <machine/kbio.h>

#include "../../../dev/sun/event_var.h"
#include "kbd_xlate.h"

/*
 * Ideas:
 * /dev/kbd is not a tty (plain device)
 */

/*
 * How many input characters we can buffer.
 * The port-specific var.h may override this.
 * Note: must be a power of two!
 */
#define	KBD_RX_RING_SIZE	256
#define KBD_RX_RING_MASK (KBD_RX_RING_SIZE-1)
/*
 * Output buffer.  Only need a few chars.
 */
#define	KBD_TX_RING_SIZE	16
#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)
/*
 * Keyboard serial line speed is fixed at 1200 bps.
 */
#define KBD_BPS 1200
#define KBD_RESET_TIMO 1000 /* mS. */

/*
 * XXX - Historical comment - no longer quite right...
 * Keyboard driver state.  The ascii and kbd links go up and down and
 * we just sit in the middle doing translation.  Note that it is possible
 * to get just one of the two links, in which case /dev/kbd is unavailable.
 * The downlink supplies us with `internal' open and close routines which
 * will enable dataflow across the downlink.  We promise to call open when
 * we are willing to take keystrokes, and to call close when we are not.
 * If /dev/kbd is not the console tty input source, we do this whenever
 * /dev/kbd is in use; otherwise we just leave it open forever.
 */
struct kbd_softc {
	struct	device k_dev;		/* required first: base device */
	struct	zs_chanstate *k_cs;
	struct timeout k_tmo;

	/* Flags to communicate with kbd_softint() */
	volatile int k_intr_flags;
#define	INTR_RX_OVERRUN 1
#define INTR_TX_EMPTY   2
#define INTR_ST_CHECK   4

	/* Transmit state */
	volatile int k_txflags;
#define	K_TXBUSY 1
#define K_TXWANT 2

	/*
	 * State of upper interface.
	 */
	int	k_isopen;		/* set if open has been done */
	int	k_evmode;		/* set if we should produce events */
	struct	evvar k_events;		/* event queue state */

	/*
	 * ACSI translation state
	 */
	int k_repeat_start; 	/* initial delay */
	int k_repeat_step;  	/* inter-char delay */
	int	k_repeatsym;		/* repeating symbol */
	int	k_repeating;		/* we've called timeout() */
	struct	kbd_state k_state;	/* ASCII translation state */

	/*
	 * Magic sequence stuff (L1-A)
	 */
	char k_isconsole;
	char k_magic1_down;
	u_char k_magic1;	/* L1 */
	u_char k_magic2;	/* A */

	/*
	 * The transmit ring buffer.
	 */
	volatile u_int	k_tbget;	/* transmit buffer `get' index */
	volatile u_int	k_tbput;	/* transmit buffer `put' index */
	u_char	k_tbuf[KBD_TX_RING_SIZE]; /* data */

	/*
	 * The receive ring buffer.
	 */
	u_int	k_rbget;	/* ring buffer `get' index */
	volatile u_int	k_rbput;	/* ring buffer `put' index */
	u_short	k_rbuf[KBD_RX_RING_SIZE]; /* rr1, data pairs */

};

/* Prototypes */
int 	kbd_docmd(struct kbd_softc *k, int cmd);
int 	kbd_iopen(int unit);
void	kbd_new_layout(struct kbd_softc *k);
void	kbd_output(struct kbd_softc *k, int c);
void	kbd_repeat(void *arg);
void	kbd_set_leds(struct kbd_softc *k, int leds);
void	kbd_start_tx(struct kbd_softc *k);
void	kbd_update_leds(struct kbd_softc *k);
void	kbd_was_reset(struct kbd_softc *k);

extern void kd_input(int ascii);

cdev_decl(kbd);	/* open, close, read, write, ioctl, stop, ... */

struct zsops zsops_kbd;

/****************************************************************
 * Definition of the driver for autoconfig.
 ****************************************************************/

static int	kbd_match(struct device *, void *, void *);
static void	kbd_attach(struct device *, struct device *, void *);

static int	kbd_drain_tx(struct kbd_softc *);
static void	kbd_input_string(struct kbd_softc *, char *str);
static void	kbd_input_funckey(struct kbd_softc *,register int);
static void	kbd_input_keysym(struct kbd_softc *,register int);
static void	kbd_input_raw(struct kbd_softc *,register int);
static void	kbd_rxint(register struct zs_chanstate *);
static void	kbd_txint(register struct zs_chanstate *);
static void	kbd_stint(register struct zs_chanstate *);
static void	kbd_softint(register struct zs_chanstate *);

struct cfattach kbd_ca = {
	sizeof(struct kbd_softc), kbd_match, kbd_attach
};

struct cfdriver kbd_cd = {
	NULL, "kbd", DV_DULL
};


/*
 * kbd_match: how is this zs channel configured?
 */
int 
kbd_match(parent, match, aux)
	struct device *parent;
	void   *match, *aux;
{
	struct cfdata *cf = match;
	struct zsc_attach_args *args = aux;

	/* Exact match required for keyboard. */
	if (cf->cf_loc[0] == args->channel)
		return 2;

	return 0;
}

void 
kbd_attach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;

{
	struct zsc_softc *zsc = (void *) parent;
	struct kbd_softc *k = (void *) self;
	struct zsc_attach_args *args = aux;
	struct zs_chanstate *cs;
	struct cfdata *cf;
	int channel, kbd_unit;
	int reset, s, tconst;

	cf = k->k_dev.dv_cfdata;
	kbd_unit = k->k_dev.dv_unit;
	channel = args->channel;
	cs = &zsc->zsc_cs[channel];
	cs->cs_private = k;
	cs->cs_ops = &zsops_kbd;
	k->k_cs = cs;

	if (args->hwflags & ZS_HWFLAG_CONSOLE) {
		k->k_isconsole = 1;
		printf(" (console)");
	}
	printf("\n");

	/* Initialize the speed, etc. */
	tconst = BPS_TO_TCONST(cs->cs_brg_clk, KBD_BPS);
	s = splzs();
	if (k->k_isconsole == 0) {
		/* Not the console; may need reset. */
		reset = (channel == 0) ?
			ZSWR9_A_RESET : ZSWR9_B_RESET;
		zs_write_reg(cs, 9, reset);
	}
	/* These are OK as set by zscc: WR3, WR4, WR5 */
	cs->cs_preg[5] |= ZSWR5_DTR | ZSWR5_RTS;
	cs->cs_preg[12] = tconst;
	cs->cs_preg[13] = tconst >> 8;
	zs_loadchannelregs(cs);
	splx(s);

	/* Do this before any calls to kbd_rint(). */
	kbd_xlate_init(&k->k_state);

	/* XXX - Do this in open? */
	k->k_repeat_start = hz/2;
	k->k_repeat_step = hz/20;

	/* Magic sequence. */
	k->k_magic1 = KBD_L1;
	k->k_magic2 = KBD_A;

	timeout_set(&k->k_tmo, kbd_repeat, k);

	/* Now attach the (kd) pseudo-driver. */
	kd_init(kbd_unit);
}


/****************************************************************
 *  Entry points for /dev/kbd
 *  (open,close,read,write,...)
 ****************************************************************/

/*
 * Open:
 * Check exclusion, open actual device (_iopen),
 * setup event channel, clear ASCII repeat stuff.
 */
int
kbdopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	struct kbd_softc *k;
	int error, unit;

	unit = minor(dev);
	if (unit >= kbd_cd.cd_ndevs)
		return (ENXIO);
	k = kbd_cd.cd_devs[unit];
	if (k == NULL)
		return (ENXIO);

	/* Exclusive open required for /dev/kbd */
	if (k->k_events.ev_io)
		return (EBUSY);
	k->k_events.ev_io = p;

	if ((error = kbd_iopen(unit)) != 0) {
		k->k_events.ev_io = NULL;
		return (error);
	}
	ev_init(&k->k_events);
	k->k_evmode = 1;	/* XXX: OK? */

	if (k->k_repeating) {
		k->k_repeating = 0;
		timeout_del(&k->k_tmo);
	}

	return (0);
}

/*
 * Close:
 * Turn off event mode, dump the queue, and close the keyboard
 * unless it is supplying console input.
 */
int
kbdclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	struct kbd_softc *k;

	k = kbd_cd.cd_devs[minor(dev)];
	k->k_evmode = 0;
	ev_fini(&k->k_events);
	k->k_events.ev_io = NULL;
	return (0);
}

int
kbdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct kbd_softc *k;

	k = kbd_cd.cd_devs[minor(dev)];
	return (ev_read(&k->k_events, uio, flags));
}

/* this routine should not exist, but is convenient to write here for now */
int
kbdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (EOPNOTSUPP);
}

int
kbdselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
{
	struct kbd_softc *k;

	k = kbd_cd.cd_devs[minor(dev)];
	return (ev_select(&k->k_events, rw, p));
}


static int kbd_ioccmd(struct kbd_softc *k, int *data);
static int kbd_iockeymap(struct kbd_state *ks,
	u_long cmd, struct kiockeymap *kio);

static int kbd_iocsled(struct kbd_softc *k, int *data);

#ifdef	KIOCGETKEY
static int kbd_oldkeymap(struct kbd_state *ks,
	u_long cmd, struct okiockey *okio);
#endif

int
kbdioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	register caddr_t data;
	int flag;
	struct proc *p;
{
	struct kbd_softc *k;
	struct kbd_state *ks;
	int *ip;
	int error = 0;

	k = kbd_cd.cd_devs[minor(dev)];
	ks = &k->k_state;

	switch (cmd) {

	case KIOCTRANS: 	/* Set translation mode */
		ip = (int *)data;
		/* We only support "raw" mode on /dev/kbd */
		if (*ip != TR_UNTRANS_EVENT)
			error = EINVAL;
		break;

	case KIOCGTRANS:	/* Get translation mode */
		ip = (int *)data;
		/* We only support "raw" mode on /dev/kbd */
		*ip = TR_UNTRANS_EVENT;
		break;

#ifdef	KIOCGETKEY
	case KIOCGETKEY:	/* Get keymap entry (old format) */
		error = kbd_oldkeymap(ks, cmd, (struct okiockey *)data);
		break;
#endif	/* KIOCGETKEY */

	case KIOCSKEY:  	/* Set keymap entry */
		/* Don't let just anyone hose the keyboard. */
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
			return (error);
		/* fallthrough */
	case KIOCGKEY:  	/* Get keymap entry */
		error = kbd_iockeymap(ks, cmd, (struct kiockeymap *)data);
		break;

	case KIOCCMD:	/* Send a command to the keyboard */
		error = kbd_ioccmd(k, (int *)data);
		break;

	case KIOCTYPE:	/* Get keyboard type */
		ip = (int *)data;
		*ip = ks->kbd_id;
		break;

	case KIOCSDIRECT:	/* where to send input */
		ip = (int *)data;
		k->k_evmode = *ip;
		break;

	case KIOCLAYOUT:	/* Get keyboard layout */
		*data = ks->kbd_layout;
		break;

	case KIOCSLED:
		error = kbd_iocsled(k, (int *)data);
		break;

	case KIOCGLED:
		*(char *)data = ks->kbd_leds;
		break;

	case FIONBIO:		/* we will remove this someday (soon???) */
		break;

	case FIOASYNC:
		k->k_events.ev_async = *(int *)data != 0;
		break;

	case TIOCSPGRP:
		ip = (int *)data;
		if (*ip != k->k_events.ev_io->p_pgid)
			error = EPERM;
		break;

	}

	return (error);
}

/****************************************************************
 * ioctl helpers
 ****************************************************************/

/*
 * Get/Set keymap entry
 */
static int
kbd_iockeymap(ks, cmd, kio)
	struct kbd_state *ks;
	u_long cmd;
	struct kiockeymap *kio;
{
	struct keymap *km;
	u_int station;

	switch (kio->kio_tablemask) {
	case KIOC_NOMASK:
		km = ks->kbd_k.k_normal;
		break;
	case KIOC_SHIFTMASK:
		km = ks->kbd_k.k_shifted;
		break;
	case KIOC_CTRLMASK:
		km = ks->kbd_k.k_control;
		break;
	case KIOC_UPMASK:
		km = ks->kbd_k.k_release;
		break;
	default:
		/* Silently ignore unsupported masks */
		return (0);
	}

	/* Range-check the table position. */
	station = kio->kio_station;
	if (station >= KEYMAP_SIZE)
		return (EINVAL);

	switch (cmd) {

	case KIOCGKEY:	/* Get keymap entry */
		kio->kio_entry = km->keymap[station];
		break;

	case KIOCSKEY:	/* Set keymap entry */
		km->keymap[station] = kio->kio_entry;
		break;

	default:
		return(ENOTTY);
	}
	return (0);
}

#ifdef	KIOCGETKEY
/*
 * Get/Set keymap entry,
 * old format (compatibility)
 */
int
kbd_oldkeymap(ks, cmd, kio)
	struct kbd_state *ks;
	u_long cmd;
	struct okiockey *kio;
{
	int error = 0;

	switch (cmd) {

	case KIOCGETKEY:
		if (kio->kio_station == 118) {
			/*
			 * This is X11 asking if a type 3 keyboard is
			 * really a type 3 keyboard.  Say yes, it is,
			 * by reporting key station 118 as a "hole".
			 * Note old (SunOS 3.5) definition of HOLE!
			 */
			kio->kio_entry = 0xA2;
			break;
		}
		/* fall through */

	default:
		error = ENOTTY;
		break;
	}

	return (error);
}
#endif	/* KIOCGETKEY */


/*
 * keyboard command ioctl
 * ``unimplemented commands are ignored'' (blech)
 */
static int
kbd_ioccmd(k, data)
	struct kbd_softc *k;
	int *data;
{
	struct kbd_state *ks = &k->k_state;
	int cmd, error, s;

	cmd = *data;
	switch (cmd) {

	case KBD_CMD_BELL:
	case KBD_CMD_NOBELL:
		/* Supported by type 2, 3, and 4 keyboards */
		break;

	case KBD_CMD_CLICK:
	case KBD_CMD_NOCLICK:
		/* Unsupported by type 2 keyboards */
		if (ks->kbd_id <= KB_SUN2)
			return (0);
		ks->kbd_click = (cmd == KBD_CMD_CLICK);
		break;

	default:
		return (0);
	}

	s = spltty();

	error = kbd_drain_tx(k);
	if (error == 0) {
		kbd_output(k, cmd);
		kbd_start_tx(k);
	}

	splx(s);

	return (error);
}

/*
 * Set LEDs ioctl.
 */
static int
kbd_iocsled(k, data)
	struct kbd_softc *k;
	int *data;
{
	int leds, error, s;

	leds = *data;

	s = spltty();
	error = kbd_drain_tx(k);
	if (error == 0) {
		kbd_set_leds(k, leds);
	}
	splx(s);

	return (error);
}


/****************************************************************
 * middle layers:
 *  - keysym to ASCII sequence
 *  - raw key codes to keysym
 ****************************************************************/


/*
 * Initialization done by either kdcninit or kbd_iopen
 */
void
kbd_xlate_init(ks)
	struct kbd_state *ks;
{
	struct keyboard *ktbls;
	int id;

	id = ks->kbd_id;
	if (id < KBD_MIN_TYPE)
		id = KBD_MIN_TYPE;
	if (id > kbd_max_type)
		id = kbd_max_type;
	ktbls = keyboards[id];

	ks->kbd_k = *ktbls; 	/* struct assignment */
	ks->kbd_modbits = 0;
}

/*
 * Turn keyboard up/down codes into a KEYSYM.
 * Note that the "kd" driver uses this too!
 */
int
kbd_code_to_keysym(ks, c)
	register struct kbd_state *ks;
	register int c;
{
	struct keymap *km;
	int keysym;

	/*
	 * Get keymap pointer.  One of these:
	 * release, control, shifted, normal, ...
	 */
	if (KEY_UP(c))
		km = ks->kbd_k.k_release;
	else if (ks->kbd_modbits & KBMOD_CTRL_MASK)
		km = ks->kbd_k.k_control;
	else if (ks->kbd_modbits & KBMOD_SHIFT_MASK)
		km = ks->kbd_k.k_shifted;
	else
		km = ks->kbd_k.k_normal;

	if (km == NULL) {
		/*
		 * Do not know how to translate yet.
		 * We will find out when a RESET comes along.
		 */
		return (KEYSYM_NOP);
	}
	keysym = km->keymap[KEY_CODE(c)];

	/*
	 * Post-processing for Caps-lock
	 */
	if ((ks->kbd_modbits & (1 << KBMOD_CAPSLOCK)) &&
		(KEYSYM_CLASS(keysym) == KEYSYM_ASCII) )
	{
		if (('a' <= keysym) && (keysym <= 'z'))
			keysym -= ('a' - 'A');
	}

	/*
	 * Post-processing for Num-lock
	 */
	if ((ks->kbd_modbits & (1 << KBMOD_NUMLOCK)) &&
		(KEYSYM_CLASS(keysym) == KEYSYM_FUNC) )
	{
		keysym = kbd_numlock_map[keysym & 0x3F];
	}

	return (keysym);
}

static void
kbd_input_string(k, str)
	struct kbd_softc *k;
	char *str;
{
	while (*str) {
		kd_input(*str);
		str++;
	}
}

static void
kbd_input_funckey(k, keysym)
	struct kbd_softc *k;
	register int keysym;
{
	register int n;
	char str[12];

	/*
	 * Format the F-key sequence and send as a string.
	 * XXX: Ugly compatibility mappings.
	 */
	n = 0xC0 + (keysym & 0x3F);
	sprintf(str, "\033[%dz", n);
	kbd_input_string(k, str);
}

/*
 * This is called by kbd_input_raw() or by kb_repeat()
 * to deliver ASCII input.  Called at spltty().
 */
static void
kbd_input_keysym(k, keysym)
	struct kbd_softc *k;
	register int keysym;
{
	struct kbd_state *ks = &k->k_state;
	register int data;

	switch (KEYSYM_CLASS(keysym)) {

	case KEYSYM_ASCII:
		data = KEYSYM_DATA(keysym);
		if (ks->kbd_modbits & KBMOD_META_MASK)
			data |= 0x80;
		kd_input(data);
		break;

	case KEYSYM_STRING:
		data = keysym & 0xF;
		kbd_input_string(k, kbd_stringtab[data]);
		break;

	case KEYSYM_FUNC:
		kbd_input_funckey(k, keysym);
		break;

	case KEYSYM_CLRMOD:
		data = 1 << (keysym & 0x1F);
		ks->kbd_modbits &= ~data;
		break;

	case KEYSYM_SETMOD:
		data = 1 << (keysym & 0x1F);
		ks->kbd_modbits |= data;
		break;

	case KEYSYM_INVMOD:
		data = 1 << (keysym & 0x1F);
		ks->kbd_modbits ^= data;
		kbd_update_leds(k);
		break;

	case KEYSYM_ALL_UP:
		ks->kbd_modbits &= ~0xFFFF;
		break;

	case KEYSYM_SPECIAL:
		/* 
		 * Unrecognized keys from type 4 or 5 keyboards generate
		 * KEYSYM_HOLE
		 */
		if (keysym == KEYSYM_NOP || keysym == KEYSYM_HOLE)
			break;
		/* fall through */
	default:
		log(LOG_WARNING, "%s: unexpected keysym 0x%x\n",
			k->k_dev.dv_xname, keysym);
		break;
	}
}

/*
 * This is the autorepeat timeout function.
 * Called at splsoftclock().
 */
void
kbd_repeat(void *arg)
{
	struct kbd_softc *k = (struct kbd_softc *)arg;
	int s = spltty();

	if (k->k_repeating && k->k_repeatsym >= 0) {
		kbd_input_keysym(k, k->k_repeatsym);
		timeout_add(&k->k_tmo, k->k_repeat_step);
	}
	splx(s);
}

/*
 * Called by our kbd_softint() routine on input,
 * which passes the raw hardware scan codes.
 * Called at spltty()
 */
void
kbd_input_raw(k, c)
	struct kbd_softc *k;
	register int c;
{
	struct kbd_state *ks = &k->k_state;
	struct firm_event *fe;
	int put, keysym;

	/* XXX - Input errors already handled. */

	/* Are we expecting special input? */
	if (ks->kbd_expect) {
		if (ks->kbd_expect & KBD_EXPECT_IDCODE) {
			/* We read a KBD_RESET last time. */
			ks->kbd_id = c;
			kbd_was_reset(k);
		}
		if (ks->kbd_expect & KBD_EXPECT_LAYOUT) {
			/* We read a KBD_LAYOUT last time. */
			ks->kbd_layout = c;
			kbd_new_layout(k);
		}
		ks->kbd_expect = 0;
		return;
	}

	/* Is this one of the "special" input codes? */
	if (KBD_SPECIAL(c)) {
		switch (c) {
		case KBD_RESET:
			ks->kbd_expect |= KBD_EXPECT_IDCODE;
			/* Fake an "all-up" to resync. translation. */
			c = KBD_IDLE;
			break;

		case KBD_LAYOUT:
			ks->kbd_expect |= KBD_EXPECT_LAYOUT;
			return;

		case KBD_ERROR:
			log(LOG_WARNING, "%s: received error indicator\n",
				k->k_dev.dv_xname);
			return;

		case KBD_IDLE:
			/* Let this go to the translator. */
			break;
		}
	}

	/*
	 * If /dev/kbd is not connected in event mode, 
	 * translate and send upstream (to console).
	 */
	if (!k->k_evmode) {

		/* Any input stops auto-repeat (i.e. key release). */
		if (k->k_repeating) {
			k->k_repeating = 0;
			timeout_del(&k->k_tmo);
		}

		/* Translate this code to a keysym */
		keysym = kbd_code_to_keysym(ks, c);

		/* Pass up to the next layer. */
		kbd_input_keysym(k, keysym);

		/* Does this symbol get auto-repeat? */
		if (KEYSYM_NOREPEAT(keysym))
			return;

		/* Setup for auto-repeat after initial delay. */
		k->k_repeating = 1;
		k->k_repeatsym = keysym;
		timeout_add(&k->k_tmo, k->k_repeat_start);
		return;
	}

	/*
	 * IDLEs confuse the MIT X11R4 server badly, so we must drop them.
	 * This is bad as it means the server will not automatically resync
	 * on all-up IDLEs, but I did not drop them before, and the server
	 * goes crazy when it comes time to blank the screen....
	 */
	if (c == KBD_IDLE)
		return;

	/*
	 * Keyboard is generating events.  Turn this keystroke into an
	 * event and put it in the queue.  If the queue is full, the
	 * keystroke is lost (sorry!).
	 */
	put = k->k_events.ev_put;
	fe = &k->k_events.ev_q[put];
	put = (put + 1) % EV_QSIZE;
	if (put == k->k_events.ev_get) {
		log(LOG_WARNING, "%s: event queue overflow\n",
			k->k_dev.dv_xname); /* ??? */
		return;
	}
	fe->id = KEY_CODE(c);
	fe->value = KEY_UP(c) ? VKEY_UP : VKEY_DOWN;
	fe->time = time;
	k->k_events.ev_put = put;
	EV_WAKEUP(&k->k_events);
}

/****************************************************************
 * Interface to the lower layer (zscc)
 ****************************************************************/

static void
kbd_rxint(cs)
	register struct zs_chanstate *cs;
{
	register struct kbd_softc *k;
	register int put, put_next;
	register u_char c, rr1;

	k = cs->cs_private;
	put = k->k_rbput;

	/*
	 * First read the status, because reading the received char
	 * destroys the status of this char.
	 */
	rr1 = zs_read_reg(cs, 1);
	c = zs_read_data(cs);

	if (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {
		/* Clear the receive error. */
		zs_write_csr(cs, ZSWR0_RESET_ERRORS);
	}

	/*
	 * Check NOW for a console abort sequence, so that we can
	 * abort even when interrupts are locking up the machine.
	 */
	if (k->k_magic1_down) {
		/* The last keycode was "MAGIC1" down. */
		k->k_magic1_down = 0;
		if ((c == k->k_magic2) && k->k_isconsole) {
			/* Magic "L1-A" sequence; enter debugger. */
			zs_abort();
			/* Debugger done.  Fake L1-up to finish it. */
			c = k->k_magic1 | KBD_UP;
		}
	}
	if (c == k->k_magic1) {
		k->k_magic1_down = 1;
	}

	k->k_rbuf[put] = (c << 8) | rr1;
	put_next = (put + 1) & KBD_RX_RING_MASK;

	/* Would overrun if increment makes (put==get). */
	if (put_next == k->k_rbget) {
		k->k_intr_flags |= INTR_RX_OVERRUN;
	} else {
		/* OK, really increment. */
		put = put_next;
	}

	/* Done reading. */
	k->k_rbput = put;

	/* Ask for softint() call. */
	cs->cs_softreq = 1;
}


static void
kbd_txint(cs)
	register struct zs_chanstate *cs;
{
	register struct kbd_softc *k;

	k = cs->cs_private;
	zs_write_csr(cs, ZSWR0_RESET_TXINT);
	k->k_intr_flags |= INTR_TX_EMPTY;
	/* Ask for softint() call. */
	cs->cs_softreq = 1;
}


static void
kbd_stint(cs)
	register struct zs_chanstate *cs;
{
	register struct kbd_softc *k;
	register int rr0;

	k = cs->cs_private;

	rr0 = zs_read_csr(cs);
	zs_write_csr(cs, ZSWR0_RESET_STATUS);

#if 0
	if (rr0 & ZSRR0_BREAK) {
		/* Keyboard unplugged? */
		zs_abort();
		return (0);
	}
#endif

	cs->cs_rr0_delta |= (cs->cs_rr0 ^ rr0);
	cs->cs_rr0 = rr0;
	k->k_intr_flags |= INTR_ST_CHECK;

	/* Ask for softint() call. */
	cs->cs_softreq = 1;
}

/*
 * Get input from the receive ring and pass it on.
 * Note: this is called at splsoftclock()
 */
static void
kbd_softint(cs)
	struct zs_chanstate *cs;
{
	register struct kbd_softc *k;
	register int get, c, s;
	int intr_flags;
	register u_short ring_data;

	k = cs->cs_private;

	/* Atomically get and clear flags. */
	s = splzs();
	intr_flags = k->k_intr_flags;
	k->k_intr_flags = 0;

	/* Now lower to spltty for the rest. */
	(void) spltty();

	/*
	 * Copy data from the receive ring to the event layer.
	 */
	get = k->k_rbget;
	while (get != k->k_rbput) {
		ring_data = k->k_rbuf[get];
		get = (get + 1) & KBD_RX_RING_MASK;

		/* low byte of ring_data is rr1 */
		c = (ring_data >> 8) & 0xff;

		if (ring_data & ZSRR1_DO)
			intr_flags |= INTR_RX_OVERRUN;
		if (ring_data & (ZSRR1_FE | ZSRR1_PE)) {
			/*
			 * After garbage, flush pending input, and
			 * send a reset to resync key translation.
			 */
			log(LOG_ERR, "%s: input error (0x%x)\n",
				k->k_dev.dv_xname, ring_data);
			get = k->k_rbput; /* flush */
			goto send_reset;
		}

		/* Pass this up to the "middle" layer. */
		kbd_input_raw(k, c);
	}
	if (intr_flags & INTR_RX_OVERRUN) {
		log(LOG_ERR, "%s: input overrun\n",
		    k->k_dev.dv_xname);
	send_reset:
		/* Send a reset to resync translation. */
		kbd_output(k, KBD_CMD_RESET);
		kbd_start_tx(k);
	}
	k->k_rbget = get;

	if (intr_flags & INTR_TX_EMPTY) {
		/*
		 * Transmit done.  Try to send more, or
		 * clear busy and wakeup drain waiters.
		 */
		k->k_txflags &= ~K_TXBUSY;
		kbd_start_tx(k);
	}

	if (intr_flags & INTR_ST_CHECK) {
		/*
		 * Status line change.  (Not expected.)
		 */
		log(LOG_ERR, "%s: status interrupt?\n",
		    k->k_dev.dv_xname);
		cs->cs_rr0_delta = 0;
	}

	splx(s);
}

struct zsops zsops_kbd = {
	kbd_rxint,	/* receive char available */
	kbd_stint,	/* external/status */
	kbd_txint,	/* xmit buffer empty */
	kbd_softint,	/* process software interrupt */
};

/****************************************************************
 * misc...
 ****************************************************************/

/*
 * Initialization to be done at first open.
 * This is called from kbdopen or kdopen (in kd.c)
 * Called with user context.
 */
int
kbd_iopen(unit)
	int unit;
{
	struct kbd_softc *k;
	struct kbd_state *ks;
	int error, s;

	if (unit >= kbd_cd.cd_ndevs)
		return (ENXIO);
	k = kbd_cd.cd_devs[unit];
	if (k == NULL)
		return (ENXIO);
	ks = &k->k_state;
	error = 0;

	/* Tolerate extra calls. */
	if (k->k_isopen)
		return (error);

	s = spltty();

	/* Reset the keyboard and find out its type. */
	kbd_output(k, KBD_CMD_RESET);
	kbd_start_tx(k);
	kbd_drain_tx(k);
	/* The wakeup for this is in kbd_was_reset(). */
	error = tsleep((caddr_t)&ks->kbd_id,
				   PZERO | PCATCH, devopn, hz);
	if (error == EWOULDBLOCK) { 	/* no response */
		error = 0;
		log(LOG_ERR, "%s: reset failed\n",
			k->k_dev.dv_xname);
		/*
		 * Allow the open anyway (to keep getty happy)
		 * but assume the "least common denominator".
		 */
		ks->kbd_id = KB_SUN2;
	}

	/* Earlier than type 4 does not know "layout". */
	if (ks->kbd_id < KB_SUN4)
		goto out;

	/* Ask for the layout. */
	kbd_output(k, KBD_CMD_GETLAYOUT);
	kbd_start_tx(k);
	kbd_drain_tx(k);
	/* The wakeup for this is in kbd_new_layout(). */
	error = tsleep((caddr_t)&ks->kbd_layout,
				   PZERO | PCATCH, devopn, hz);
	if (error == EWOULDBLOCK) { 	/* no response */
		error = 0;
		log(LOG_ERR, "%s: no response to get_layout\n",
			k->k_dev.dv_xname);
		ks->kbd_layout = 0;
	}

out:
	splx(s);

	if (error == 0)
		k->k_isopen = 1;

	return error;
}

/*
 * Called by kbd_input_raw, at spltty()
 */
void
kbd_was_reset(k)
	struct kbd_softc *k;
{
	struct kbd_state *ks = &k->k_state;

	/*
	 * On first identification, wake up anyone waiting for type
	 * and set up the table pointers.
	 */
	wakeup((caddr_t)&ks->kbd_id);

	/* Restore keyclick, if necessary */
	switch (ks->kbd_id) {

	case KB_SUN2:
		/* Type 2 keyboards don't support keyclick */
		break;

	case KB_SUN3:
		/* Type 3 keyboards come up with keyclick on */
		if (!ks->kbd_click) {
			/* turn off the click */
			kbd_output(k, KBD_CMD_NOCLICK);
			kbd_start_tx(k);
		}
		break;

	case KB_SUN4:
		/* Type 4 keyboards come up with keyclick off */
		if (ks->kbd_click) {
			/* turn on the click */
			kbd_output(k, KBD_CMD_CLICK);
			kbd_start_tx(k);
		}
		break;
	}

	/* LEDs are off after reset. */
	ks->kbd_leds = 0;
}

/*
 * Called by kbd_input_raw, at spltty()
 */
void
kbd_new_layout(k)
	struct kbd_softc *k;
{
	struct kbd_state *ks = &k->k_state;

	/*
	 * On first identification, wake up anyone waiting for type
	 * and set up the table pointers.
	 */
	wakeup((caddr_t)&ks->kbd_layout);

	/* XXX: switch decoding tables? */
}


/*
 * Wait for output to finish.
 * Called at spltty().  Has user context.
 */
static int
kbd_drain_tx(k)
	struct kbd_softc *k;
{
	int error;

	error = 0;

	while (k->k_txflags & K_TXBUSY) {
		k->k_txflags |= K_TXWANT;
		error = tsleep((caddr_t)&k->k_txflags,
					   PZERO | PCATCH, "kbdout", 0);
	}

	return (error);
}

/*
 * Enqueue some output for the keyboard
 * Called at spltty().
 */
void
kbd_output(k, c)
	struct kbd_softc *k;
	int c;	/* the data */
{
	int put;

	put = k->k_tbput;
	k->k_tbuf[put] = (u_char)c;
	put = (put + 1) & KBD_TX_RING_MASK;

	/* Would overrun if increment makes (put==get). */
	if (put == k->k_tbget) {
		log(LOG_WARNING, "%s: output overrun\n",
            k->k_dev.dv_xname);
	} else {
		/* OK, really increment. */
		k->k_tbput = put;
	}
}

/*
 * Start the sending data from the output queue
 * Called at spltty().
 */
void
kbd_start_tx(k)
    struct kbd_softc *k;
{
	struct zs_chanstate *cs = k->k_cs;
	int get, s;
	u_char c;

	if (k->k_txflags & K_TXBUSY)
		return;

	/* Is there anything to send? */
	get = k->k_tbget;
	if (get == k->k_tbput) {
		/* Nothing to send.  Wake drain waiters. */
		if (k->k_txflags & K_TXWANT) {
			k->k_txflags &= ~K_TXWANT;
			wakeup((caddr_t)&k->k_txflags);
		}
		return;
	}

	/* Have something to send. */
	c = k->k_tbuf[get];
	get = (get + 1) & KBD_TX_RING_MASK;
	k->k_tbget = get;
	k->k_txflags |= K_TXBUSY;

	/* Need splzs to avoid interruption of the delay. */
	s = splzs();
	zs_write_data(cs, c);
	splx(s);
}

/*
 * Called at spltty by:
 * kbd_update_leds, kbd_iocsled
 */
void
kbd_set_leds(k, new_leds)
	struct kbd_softc *k;
	int new_leds;
{
	struct kbd_state *ks = &k->k_state;

	/* Don't send unless state changes. */
	if (ks->kbd_leds == new_leds)
		return;

	ks->kbd_leds = new_leds;

	/* Only type 4 and later has LEDs anyway. */
	if (ks->kbd_id < 4)
		return;

	kbd_output(k, KBD_CMD_SETLED);
	kbd_output(k, new_leds);
	kbd_start_tx(k);
}

/*
 * Called at spltty by:
 * kbd_input_keysym
 */
void
kbd_update_leds(k)
    struct kbd_softc *k;
{
    struct kbd_state *ks = &k->k_state;
    register char leds;

	leds = ks->kbd_leds;
	leds &= ~(LED_CAPS_LOCK|LED_NUM_LOCK);

	if (ks->kbd_modbits & (1 << KBMOD_CAPSLOCK))
		leds |= LED_CAPS_LOCK;
	if (ks->kbd_modbits & (1 << KBMOD_NUMLOCK))
		leds |= LED_NUM_LOCK;

	kbd_set_leds(k, leds);
}
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.8 2001/08/12 12:03:02 heko Exp $	*/
@


1.8
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.7 2001/08/08 22:42:11 miod Exp $	*/
d193 2
a194 2
static int	kbd_match __P((struct device *, void *, void *));
static void	kbd_attach __P((struct device *, struct device *, void *));
d196 9
a204 9
static int	kbd_drain_tx __P((struct kbd_softc *));
static void	kbd_input_string __P((struct kbd_softc *, char *str));
static void	kbd_input_funckey __P((struct kbd_softc *,register int));
static void	kbd_input_keysym __P((struct kbd_softc *,register int));
static void	kbd_input_raw __P((struct kbd_softc *,register int));
static void	kbd_rxint __P((register struct zs_chanstate *));
static void	kbd_txint __P((register struct zs_chanstate *));
static void	kbd_stint __P((register struct zs_chanstate *));
static void	kbd_softint __P((register struct zs_chanstate *));
d398 2
a399 2
static int kbd_iockeymap __P((struct kbd_state *ks,
	u_long cmd, struct kiockeymap *kio));
d404 2
a405 2
static int kbd_oldkeymap __P((struct kbd_state *ks,
	u_long cmd, struct okiockey *okio));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.8 2001/08/12 12:03:02 heko Exp $	*/
d193 2
a194 2
static int	kbd_match(struct device *, void *, void *);
static void	kbd_attach(struct device *, struct device *, void *);
d196 9
a204 9
static int	kbd_drain_tx(struct kbd_softc *);
static void	kbd_input_string(struct kbd_softc *, char *str);
static void	kbd_input_funckey(struct kbd_softc *,register int);
static void	kbd_input_keysym(struct kbd_softc *,register int);
static void	kbd_input_raw(struct kbd_softc *,register int);
static void	kbd_rxint(register struct zs_chanstate *);
static void	kbd_txint(register struct zs_chanstate *);
static void	kbd_stint(register struct zs_chanstate *);
static void	kbd_softint(register struct zs_chanstate *);
d398 2
a399 2
static int kbd_iockeymap(struct kbd_state *ks,
	u_long cmd, struct kiockeymap *kio);
d404 2
a405 2
static int kbd_oldkeymap(struct kbd_state *ks,
	u_long cmd, struct okiockey *okio);
@


1.8.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.8.4.1 2002/06/11 03:39:01 art Exp $	*/
@


1.7
log
@New timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.6 2001/06/27 05:44:51 nate Exp $	*/
d443 1
a443 1
#endif	KIOCGETKEY */
@


1.6
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.5 2000/07/02 17:50:26 miod Exp $	*/
d119 1
d288 2
d335 1
a335 1
		untimeout(kbd_repeat, k);
d848 1
a848 1
		timeout(kbd_repeat, k, k->k_repeat_step);
d918 1
a918 1
			untimeout(kbd_repeat, k);
d934 1
a934 1
		timeout(kbd_repeat, k, k->k_repeat_start);
@


1.5
log
@Silence annoying warnings when using type 4 or 5 keyboards on sun3
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.4 1997/08/19 23:09:35 kstailey Exp $	*/
d1071 1
a1071 1
 * Get input from the recieve ring and pass it on.
@


1.4
log
@sun3 is back up
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.3 1997/08/19 11:48:04 kstailey Exp $	*/
d819 5
a823 1
		if (keysym == KEYSYM_NOP)
@


1.4.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.5 2000/07/02 17:50:26 miod Exp $	*/
d819 1
a819 5
		/* 
		 * Unrecognized keys from type 4 or 5 keyboards generate
		 * KEYSYM_HOLE
		 */
		if (keysym == KEYSYM_NOP || keysym == KEYSYM_HOLE)
@


1.4.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.4.12.1 2001/05/14 21:37:27 niklas Exp $	*/
d1071 1
a1071 1
 * Get input from the receive ring and pass it on.
@


1.4.12.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.4.12.2 2001/07/04 10:23:55 niklas Exp $	*/
a118 1
	struct timeout k_tmo;
a286 2
	timeout_set(&k->k_tmo, kbd_repeat, k);

d332 1
a332 1
		timeout_del(&k->k_tmo);
d440 1
a440 1
#endif	/* KIOCGETKEY */
d845 1
a845 1
		timeout_add(&k->k_tmo, k->k_repeat_step);
d915 1
a915 1
			timeout_del(&k->k_tmo);
d931 1
a931 1
		timeout_add(&k->k_tmo, k->k_repeat_start);
@


1.4.12.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d193 2
a194 2
static int	kbd_match(struct device *, void *, void *);
static void	kbd_attach(struct device *, struct device *, void *);
d196 9
a204 9
static int	kbd_drain_tx(struct kbd_softc *);
static void	kbd_input_string(struct kbd_softc *, char *str);
static void	kbd_input_funckey(struct kbd_softc *,register int);
static void	kbd_input_keysym(struct kbd_softc *,register int);
static void	kbd_input_raw(struct kbd_softc *,register int);
static void	kbd_rxint(register struct zs_chanstate *);
static void	kbd_txint(register struct zs_chanstate *);
static void	kbd_stint(register struct zs_chanstate *);
static void	kbd_softint(register struct zs_chanstate *);
d398 2
a399 2
static int kbd_iockeymap(struct kbd_state *ks,
	u_long cmd, struct kiockeymap *kio);
d404 2
a405 2
static int kbd_oldkeymap(struct kbd_state *ks,
	u_long cmd, struct okiockey *okio);
@


1.4.12.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.4.12.4 2002/03/28 11:26:45 niklas Exp $	*/
@


1.3
log
@temporary work around
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd.c,v 1.6 1997/01/15 07:09:29 kstailey Exp $	*/
d79 1
a79 1
#include "event_var.h"
@


1.2
log
@sync with netbsd
@
text
@d1 2
a2 1
/*	$NetBSD: kbd.c,v 1.11 1995/10/08 23:40:42 gwr Exp $	*/
d54 7
d62 3
d66 1
a66 1
#include <sys/device.h>
d68 2
a70 1
#include <sys/proc.h>
a71 2
#include <sys/systm.h>
#include <sys/tty.h>
d73 3
a75 1
#include <machine/autoconf.h>
a77 1
#include <machine/vuid_event.h>
d80 1
d83 2
a84 2
 * Sun keyboard definitions (from Sprite).
 * These apply to type 2, 3 and 4 keyboards.
a85 2
#define	KEY_CODE(c)	((c) & KBD_KEYMASK)	/* keyboard code index */
#define	KEY_UP(c)	((c) & KBD_UP)		/* true => key went up */
d88 11
a98 96
 * Each KEY_CODE(x) can be translated via the tables below.
 * The result is either a valid ASCII value in [0..0x7f] or is one
 * of the following `magic' values saying something interesting
 * happened.  If LSHIFT or RSHIFT has changed state the next
 * lookup should come from the appropriate table; if ALLUP is
 * sent all keys (including both shifts and the control key) are
 * now up, and the next byte is the keyboard ID code.
 *
 * These tables ignore all function keys (on the theory that if you
 * want these keys, you should use a window system).  Note that
 * `caps lock' is just mapped as `ignore' (so there!). (Only the
 * type 3 and 4 keyboards have a caps lock key anyway.)
 */
#define	KEY_MAGIC	0x80		/* flag => magic value */
#define	KEY_IGNORE	0x80
#define	KEY_L1		KEY_IGNORE
#define	KEY_CAPSLOCK	KEY_IGNORE
#define	KEY_LSHIFT	0x81
#define	KEY_RSHIFT	0x82
#define	KEY_CONTROL	0x83
#define	KEY_ALLUP	0x84		/* all keys are now up; also reset */

/*
 * Decode tables for type 2, 3, and 4 keyboards
 * (stolen from Sprite; see also kbd.h).
 */
static u_char kbd_unshifted[] = {
/*   0 */	KEY_IGNORE,	KEY_L1,		KEY_IGNORE,	KEY_IGNORE,
/*   4 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*   8 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  12 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  16 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  20 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  24 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  28 */	KEY_IGNORE,	'\033',		'1',		'2',
/*  32 */	'3',		'4',		'5',		'6',
/*  36 */	'7',		'8',		'9',		'0',
/*  40 */	'-',		'=',		'`',		'\b',
/*  44 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  48 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  52 */	KEY_IGNORE,	'\t',		'q',		'w',
/*  56 */	'e',		'r',		't',		'y',
/*  60 */	'u',		'i',		'o',		'p',
/*  64 */	'[',		']',		'\177',		KEY_IGNORE,
/*  68 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  72 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  76 */	KEY_CONTROL,	'a',		's',		'd',
/*  80 */	'f',		'g',		'h',		'j',
/*  84 */	'k',		'l',		';',		'\'',
/*  88 */	'\\',		'\r',		KEY_IGNORE,	KEY_IGNORE,
/*  92 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  96 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_LSHIFT,
/* 100 */	'z',		'x',		'c',		'v',
/* 104 */	'b',		'n',		'm',		',',
/* 108 */	'.',		'/',		KEY_RSHIFT,	'\n',
/* 112 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/* 116 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_CAPSLOCK,
/* 120 */	KEY_IGNORE,	' ',		KEY_IGNORE,	KEY_IGNORE,
/* 124 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_ALLUP,
};

static u_char kbd_shifted[] = {
/*   0 */	KEY_IGNORE,	KEY_L1,		KEY_IGNORE,	KEY_IGNORE,
/*   4 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*   8 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  12 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  16 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  20 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  24 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  28 */	KEY_IGNORE,	'\033',		'!',		'@@',
/*  32 */	'#',		'$',		'%',		'^',
/*  36 */	'&',		'*',		'(',		')',
/*  40 */	'_',		'+',		'~',		'\b',
/*  44 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  48 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  52 */	KEY_IGNORE,	'\t',		'Q',		'W',
/*  56 */	'E',		'R',		'T',		'Y',
/*  60 */	'U',		'I',		'O',		'P',
/*  64 */	'{',		'}',		'\177',		KEY_IGNORE,
/*  68 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  72 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  76 */	KEY_CONTROL,	'A',		'S',		'D',
/*  80 */	'F',		'G',		'H',		'J',
/*  84 */	'K',		'L',		':',		'"',
/*  88 */	'|',		'\r',		KEY_IGNORE,	KEY_IGNORE,
/*  92 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/*  96 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_LSHIFT,
/* 100 */	'Z',		'X',		'C',		'V',
/* 104 */	'B',		'N',		'M',		'<',
/* 108 */	'>',		'?',		KEY_RSHIFT,	'\n',
/* 112 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,
/* 116 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_CAPSLOCK,
/* 120 */	KEY_IGNORE,	' ',		KEY_IGNORE,	KEY_IGNORE,
/* 124 */	KEY_IGNORE,	KEY_IGNORE,	KEY_IGNORE,	KEY_ALLUP,
};

d100 1
a100 2
 * We need to remember the state of the keyboard's shift and control
 * keys, and we need a per-type translation table.
d102 2
a103 18
struct kbd_state {
	const u_char *kbd_unshifted;	/* unshifted keys */
	const u_char *kbd_shifted;	/* shifted keys */
	const u_char *kbd_cur;	/* current keys (either of the preceding) */
	union {
		char	c[2];	/* left and right shift keys */
		short	s;	/* true => either shift key */
	} kbd_shift;
#define	kbd_lshift	kbd_shift.c[0]
#define	kbd_rshift	kbd_shift.c[1]
#define	kbd_anyshift	kbd_shift.s
	char	kbd_control;	/* true => ctrl down */
	char	kbd_click;	/* true => keyclick enabled */
	char	kbd_takeid;	/* take next byte as ID */
	u_char	kbd_id;		/* a place to store the ID */
	char	kbd_leds;	/* LED state */
	char	_pad;
};
d106 1
d117 18
a134 4
	struct	tty *k_cons;		/* uplink for ASCII data to console */
	struct	tty *k_kbd;		/* downlink for output to keyboard */
	void	(*k_open) __P((struct tty *));	/* enable dataflow */
	void	(*k_close) __P((struct tty *));	/* disable dataflow */
a135 2
	int	k_isopen;		/* set if open has been done */
	struct	kbd_state k_state;	/* ASCII decode state */
d137 7
a143 1
	int	k_repeatc;		/* repeated character */
d145 25
a169 1
} kbd_softc;
d172 41
a212 17
void	kbd_ascii(struct tty *);
void	kbd_serial(struct tty *, void (*)(), void (*)());
int 	kbd_iopen(void);
void	kbd_reset(struct kbd_softc *);
int kbd_translate(int);
void	kbd_rint(int);
int	kbdopen(dev_t, int, int, struct proc *);
int	kbdclose(dev_t, int, int, struct proc *);
int	kbdread(dev_t, struct uio *, int);
int	kbdwrite(dev_t, struct uio *, int);
int	kbdioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	kbdselect(dev_t, int, struct proc *);
int	kbd_docmd(int, int);

/* set in kbdattach() */
int kbd_repeat_start;
int kbd_repeat_step;
d215 1
a215 1
 * Initialization done by either kdcninit or kbd_iopen
d217 4
a220 2
void
kbd_init_tables()
d222 6
a227 1
	struct kbd_state *ks;
d229 1
a229 6
	ks = &kbd_softc.k_state;
	if (ks->kbd_cur == NULL) {
		ks->kbd_cur = kbd_unshifted;
		ks->kbd_unshifted = kbd_unshifted;
		ks->kbd_shifted = kbd_shifted;
	}
d232 5
a236 7
/*
 * Attach the console keyboard ASCII (up-link) interface.
 * This is called by the "kd" (keyboard/display) driver to
 * tell this module where to send read-side data.
 */
void
kbd_ascii(struct tty *tp)
d238 51
a288 1
	kbd_softc.k_cons = tp;
d291 6
d298 3
a300 3
 * Attach the console keyboard serial (down-link) interface.
 * This is called by the "zs" driver for the keyboard port
 * to tell this module how to talk to the keyboard.
d302 5
a306 2
void
kbd_serial(struct tty *tp, void (*iopen)(), void (*iclose)())
d308 14
a321 1
	register struct kbd_softc *k;
d323 6
a328 4
	k = &kbd_softc;
	k->k_kbd = tp;
	k->k_open = iopen;
	k->k_close = iclose;
d330 4
a333 2
	/* Do this before any calls to kbd_rint(). */
	kbd_init_tables();
d335 1
a335 2
	/* Now attach the (kd) pseudo-driver. */
	kd_attach(1);	/* This calls kbd_ascii() */
d339 3
a341 2
 * Initialization to be done at first open.
 * This is called from kbdopen or kdopen (in kd.c)
d344 4
a347 1
kbd_iopen()
a349 2
	struct tty *tp;
	int error, s;
d351 14
a364 1
	k = &kbd_softc;
d366 3
a368 3
	/* Tolerate extra calls. */
	if (k->k_isopen)
		return (0);
d370 7
a376 4
	/* Make sure "down" link (to zs1a) is established. */
	tp = k->k_kbd;
	if (tp == NULL)
		return (ENXIO);
d378 2
a379 2
	kbd_repeat_start = hz/2;
	kbd_repeat_step = hz/20;
d381 7
a387 3
	/* Open the "down" link (never to be closed). */
	tp->t_ispeed = tp->t_ospeed = 1200;
	(*k->k_open)(tp);
d389 3
a391 16
	/* Reset the keyboard and find out its type. */
	s = spltty();
	(void) ttyoutput(KBD_CMD_RESET, tp);
	(*tp->t_oproc)(tp);
	/* The wakeup for this sleep is in kbd_reset(). */
	error = tsleep((caddr_t)k, PZERO | PCATCH,
				   devopn, hz);
	if (error == EWOULDBLOCK) { 	/* no response */
		log(LOG_ERR, "keyboard reset failed\n");
		/*
		 * Allow the open anyway (to keep getty happy)
		 * but assume the "least common denominator".
		 */
		k->k_state.kbd_id = KB_SUN2;
		error = 0;
	}
a392 2
	if (error == 0)
		k->k_isopen = 1;
d394 10
a403 3
	splx(s);
	return error;
}
d405 8
a412 2
void
kbd_reset(k)
a413 1
{
d415 2
d418 1
d421 55
a475 6
	/*
	 * On first identification, wake up anyone waiting for type
	 * and set up the table pointers.
	 */
	if (k->k_isopen == 0)
		wakeup((caddr_t)k);
d477 2
a478 2
	/* Restore keyclick, if necessary */
	switch (ks->kbd_id) {
d480 2
a481 2
	case KB_SUN2:
		/* Type 2 keyboards don't support keyclick */
d484 4
a487 4
	case KB_SUN3:
		/* Type 3 keyboards come up with keyclick on */
		if (!ks->kbd_click)
			(void) kbd_docmd(KBD_CMD_NOCLICK, 0);
d490 33
a522 4
	case KB_SUN4:
		/* Type 4 keyboards come up with keyclick off */
		if (ks->kbd_click)
			(void) kbd_docmd(KBD_CMD_CLICK, 0);
d524 3
d529 19
a547 2
	/* LEDs are off after reset. */
	ks->kbd_leds = 0;
d550 1
d552 2
a553 1
 * Turn keyboard up/down codes into ASCII.
d556 113
a668 1
kbd_translate(register int c)
d670 20
d691 17
a707 1
	register int down;
d709 1
a709 2
	ks = &kbd_softc.k_state;
	if (ks->kbd_cur == NULL) {
d714 34
a747 1
		return (-1);
d749 48
a796 4
	down = !KEY_UP(c);
	c = ks->kbd_cur[KEY_CODE(c)];
	if (c & KEY_MAGIC) {
		switch (c) {
d798 4
a801 3
		case KEY_LSHIFT:
			ks->kbd_lshift = down;
			break;
d803 4
a806 3
		case KEY_RSHIFT:
			ks->kbd_rshift = down;
			break;
d808 5
a812 4
		case KEY_ALLUP:
			ks->kbd_anyshift = 0;
			ks->kbd_control = 0;
			break;
d814 3
a816 3
		case KEY_CONTROL:
			ks->kbd_control = down;
			/* FALLTHROUGH */
d818 8
a825 24
		case KEY_IGNORE:
			return (-1);

		default:
			panic("kbd_translate");
		}
		if (ks->kbd_anyshift)
			ks->kbd_cur = ks->kbd_shifted;
		else
			ks->kbd_cur = ks->kbd_unshifted;
		return (-1);
	}
	if (!down)
		return (-1);
	if (ks->kbd_control) {
		/* control space and unshifted control atsign return null */
		if (c == ' ' || c == '2')
			return (0);
		/* unshifted control hat */
		if (c == '6')
			return ('^' & 0x1f);
		/* standard controls */
		if (c >= '@@' && c < 0x7f)
			return (c & 0x1f);
a826 1
	return (c);
d829 4
d839 3
a841 3
	if (k->k_repeating && k->k_repeatc >= 0 && k->k_cons != NULL) {
		ttyinput(k->k_repeatc, k->k_cons);
		timeout(kbd_repeat, k, kbd_repeat_step);
d846 5
d852 3
a854 1
kbd_rint(register int c)
d856 20
a875 7
	register struct kbd_softc *k = &kbd_softc;
	register struct firm_event *fe;
	register int put;

	if (k->k_repeating) {
		k->k_repeating = 0;
		untimeout(kbd_repeat, k);
d878 8
a885 9
	/*
	 * Reset keyboard after serial port overrun, so we can resynch.
	 */
	if (c & (TTY_FE|TTY_PE)) {
		log(LOG_ERR, "keyboard input error (0x%x)\n", c);
		(void) ttyoutput(KBD_CMD_RESET, k->k_kbd);
		(*k->k_kbd->t_oproc)(k->k_kbd);
		return;
	}
d887 8
a894 7
	/* Read the keyboard id if we read a KBD_RESET last time */
	if (k->k_state.kbd_takeid) {
		k->k_state.kbd_takeid = 0;
		k->k_state.kbd_id = c;
		kbd_reset(k);
		return;
	}
d896 4
a899 4
	/* If we have been reset, setup to grab the keyboard id next time */
	if (c == KBD_RESET) {
		k->k_state.kbd_takeid = 1;
		return;
d903 2
a904 4
	 * If /dev/kbd is not connected in event mode, but we are sending
	 * data to /dev/console, translate and send upstream.  Note that
	 * we will get this while opening /dev/kbd if it is not already
	 * open and we do not know its type.
d907 5
a911 6
		c = kbd_translate(c);
		if (c >= 0 && k->k_cons != NULL) {
			ttyinput(c, k->k_cons);
			k->k_repeating = 1;
			k->k_repeatc = c;
			timeout(kbd_repeat, k, kbd_repeat_start);
d913 15
d949 2
a950 1
		log(LOG_WARNING, "keyboard event queue overflow\n"); /* ??? */
d960 7
a966 2
int
kbdopen(dev_t dev, int flags, int mode, struct proc *p)
d968 18
a985 1
	int error;
d987 16
a1002 15
#if 1	/* XXX - temporary hack */
	/* XXX - Should make login chown devices in /etc/fbtab */
	/* Require root or same UID as the kd session leader. */
	if (p->p_ucred->cr_uid) {
		struct tty *kd_tp;
		struct proc *kd_p;
		extern struct tty *kdtty();

		/* Make sure kd is attached and open. */
		kd_tp = kdtty(0);
		if ((kd_tp == NULL) || (kd_tp->t_session == NULL))
			return (EPERM);
		kd_p = kd_tp->t_session->s_leader;
		if (p->p_ucred->cr_uid != kd_p->p_ucred->cr_uid)
			return (EACCES);
a1003 1
#endif
d1005 2
a1006 4
	/* Exclusive open required for /dev/kbd */
	if (kbd_softc.k_events.ev_io)
		return (EBUSY);
	kbd_softc.k_events.ev_io = p;
d1008 6
a1013 3
	if ((error = kbd_iopen()) != 0) {
		kbd_softc.k_events.ev_io = NULL;
		return (error);
d1015 6
a1020 2
	ev_init(&kbd_softc.k_events);
	return (0);
d1023 4
a1026 2
int
kbdclose(dev_t dev, int flags, int mode, struct proc *p)
d1028 1
d1030 5
a1034 8
	/*
	 * Turn off event mode, dump the queue, and close the keyboard
	 * unless it is supplying console input.
	 */
	kbd_softc.k_evmode = 0;
	ev_fini(&kbd_softc.k_events);
	kbd_softc.k_events.ev_io = NULL;
	return (0);
d1037 4
a1040 2
int
kbdread(dev_t dev, struct uio *uio, int flags)
d1042 19
d1062 2
a1063 1
	return (ev_read(&kbd_softc.k_events, uio, flags));
d1066 7
a1072 3
/* this routine should not exist, but is convenient to write here for now */
int
kbdwrite(dev_t dev, struct uio *uio, int flags)
d1074 11
d1086 2
a1087 2
	return (EOPNOTSUPP);
}
d1089 23
a1111 7
int
kbdioctl(dev_t dev, u_long cmd, register caddr_t data,
	int flag, struct proc *p)
{
	register struct kbd_softc *k = &kbd_softc;
	register struct kiockey *kmp;
	register u_char *tp;
d1113 12
a1124 1
	switch (cmd) {
d1126 8
a1133 4
	case KIOCTRANS:
		if (*(int *)data == TR_UNTRANS_EVENT)
			return (0);
		break;
d1135 1
a1135 1
	case KIOCGTRANS:
d1137 1
a1137 1
		 * Get translation mode
d1139 7
a1145 2
		*(int *)data = TR_UNTRANS_EVENT;
		return (0);
d1147 6
a1152 10
	case KIOCGETKEY:
		if (((struct okiockey *)data)->kio_station == 118) {
			/*
			 * This is X11 asking if a type 3 keyboard is
			 * really a type 3 keyboard.  Say yes.
			 */
			((struct okiockey *)data)->kio_entry = HOLE;
			return (0);
		}
		break;
d1154 3
a1156 2
	case KIOCSKEY:
		kmp = (struct kiockey *)data;
d1158 12
a1169 14
		switch (kmp->kio_tablemask) {
		case KIOC_NOMASK:
			tp = kbd_unshifted;
			break;
		case KIOC_SHIFTMASK:
			tp = kbd_shifted;
			break;
		default:
			/* Silently ignore unsupported masks */
			return (0);
		}
		if (kmp->kio_entry & 0xff80)
			/* Silently ignore funny entries */
			return (0);
d1171 7
a1177 2
		tp[kmp->kio_station] = kmp->kio_entry;
		return (0);
d1179 3
a1181 2
	case KIOCGKEY:
		kmp = (struct kiockey *)data;
d1183 1
a1183 12
		switch (kmp->kio_tablemask) {
		case KIOC_NOMASK:
			tp = kbd_unshifted;
			break;
		case KIOC_SHIFTMASK:
			tp = kbd_shifted;
			break;
		default:
			return (0);
		}
		kmp->kio_entry = tp[kmp->kio_station] & ~KEY_MAGIC;
		return (0);
d1185 11
a1195 1
	case KIOCCMD:
d1197 2
a1198 2
		 * ``unimplemented commands are ignored'' (blech)
		 * so cannot check return value from kbd_docmd
d1200 20
a1219 7
#ifdef notyet
		while (kbd_docmd(*(int *)data, 1) == ENOSPC) /*ERESTART?*/
			(void) sleep((caddr_t)&lbolt, TTOPRI);
#else
		(void) kbd_docmd(*(int *)data, 1);
#endif
		return (0);
d1221 2
a1222 3
	case KIOCTYPE:
		*(int *)data = k->k_state.kbd_id;
		return (0);
d1224 2
a1225 3
	case KIOCSDIRECT:
		k->k_evmode = *(int *)data;
		return (0);
d1227 2
a1228 3
	case KIOCLAYOUT:
		*data = 0;
		return (0);
d1230 8
a1237 21
	case KIOCSLED:
		if (k->k_state.kbd_id != KB_SUN4) {
			/* xxx NYI */
			k->k_state.kbd_leds = *(char*)data;
		} else {
			int s;
			char leds = *(char *)data;
			struct tty *tp = kbd_softc.k_kbd;
			s = spltty();
			if (tp->t_outq.c_cc > 120)
				(void) tsleep((caddr_t)&lbolt, TTIPRI,
					      ttyout, 0);
			splx(s);
			if (ttyoutput(KBD_CMD_SETLED, tp) >= 0)
				return (ENOSPC);	/* ERESTART? */
			k->k_state.kbd_leds = leds;
			if (ttyoutput(leds, tp) >= 0)
				return (ENOSPC);	/* ERESTART? */
			(*tp->t_oproc)(tp);
		}
		return (0);
d1239 5
a1243 3
	case KIOCGLED:
		*(char *)data = k->k_state.kbd_leds;
		return (0);
d1245 2
a1246 2
	case FIONBIO:		/* we will remove this someday (soon???) */
		return (0);
d1248 3
a1250 3
	case FIOASYNC:
		k->k_events.ev_async = *(int *)data != 0;
		return (0);
d1252 8
a1259 4
	case TIOCSPGRP:
		if (*(int *)data != k->k_events.ev_io->p_pgid)
			return (EPERM);
		return (0);
d1261 8
a1268 2
	default:
		return (ENOTTY);
d1271 13
d1285 2
a1286 1
	 * We identified the ioctl, but we do not handle it.
d1288 3
a1290 1
	return (EOPNOTSUPP);		/* misuse, but what the heck */
d1293 8
a1300 2
int
kbdselect(dev_t dev, int rw, struct proc *p)
d1302 9
d1312 1
a1312 1
	return (ev_select(&kbd_softc.k_events, rw, p));
d1316 2
a1317 3
 * Execute a keyboard command; return 0 on success.
 * If `isuser', force a small delay before output if output queue
 * is flooding.  (The keyboard runs at 1200 baud, or 120 cps.)
d1319 4
a1322 2
int
kbd_docmd(int cmd, int isuser)
d1324 1
a1324 3
	register struct tty *tp = kbd_softc.k_kbd;
	register struct kbd_softc *k = &kbd_softc;
	int s;
d1326 25
a1350 3
	if (tp == NULL)
		return (ENXIO);		/* ??? */
	switch (cmd) {
d1352 2
a1353 4
	case KBD_CMD_BELL:
	case KBD_CMD_NOBELL:
		/* Supported by type 2, 3, and 4 keyboards */
		break;
d1355 7
a1361 5
	case KBD_CMD_CLICK:
		/* Unsupported by type 2 keyboards */
		if (k->k_state.kbd_id != KB_SUN2) {
			k->k_state.kbd_click = 1;
			break;
d1363 51
a1413 1
		return (EINVAL);
d1415 2
a1416 7
	case KBD_CMD_NOCLICK:
		/* Unsupported by type 2 keyboards */
		if (k->k_state.kbd_id != KB_SUN2) {
			k->k_state.kbd_click = 0;
			break;
		}
		return (EINVAL);
d1418 4
a1421 3
	default:
		return (EINVAL);	/* ENOTTY? EOPNOTSUPP? */
	}
d1423 1
a1423 11
	if (isuser) {
		s = spltty();
		if (tp->t_outq.c_cc > 120)
			(void) tsleep((caddr_t)&lbolt, TTIPRI,
			    ttyout, 0);
		splx(s);
	}
	if (ttyoutput(cmd, tp) >= 0)
		return (ENOSPC);	/* ERESTART? */
	(*tp->t_oproc)(tp);
	return (0);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
