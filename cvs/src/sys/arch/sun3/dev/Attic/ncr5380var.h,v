head	1.5;
access;
symbols
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	UBC_SYNC_A:1.5
	UBC_SYNC_B:1.5
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.5
date	96.05.06.16.50.45;	author mickey;	state dead;
branches;
next	1.4;

1.4
date	96.05.03.16.02.41;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.05.26.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.19.13.51.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.17.25.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove unused files, conserning to the last sync
@
text
@@


1.4
log
@sync with 0430.
@
text
@@


1.3
log
@update from netbsd (verbatim)
@
text
@a0 178
/*	$NetBSD: ncr5380var.h,v 1.2 1995/11/17 23:27:49 gwr Exp $	*/

/*
 * Copyright (c) 1995 David Jones, Gordon W. Ross
 * Copyright (c) 1994 Jarle Greipsland
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by
 *      David Jones and Gordon Ross
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file defines the interface between the machine-dependent
 * module and the machine-indepenedent ncr5380sbc.c module.
 */

#define SCI_CLR_INTR(sc)	(*(sc)->sci_iack)
#define	SCI_BUSY(sc)		(*sc->sci_bus_csr & SCI_BUS_BSY)

/* These are NOT artibtrary, but map to bits in sci_tcmd */
#define PHASE_DATA_OUT	0x0
#define PHASE_DATA_IN	0x1
#define PHASE_COMMAND	0x2
#define PHASE_STATUS	0x3
#define PHASE_UNSPEC1	0x4
#define PHASE_UNSPEC2	0x5
#define PHASE_MSG_OUT	0x6
#define PHASE_MSG_IN	0x7

/*
 * This illegal phase is used to prevent the 5380 from having
 * a phase-match condition when we don't want one, such as
 * when setting up the DMA engine or whatever...
 */
#define PHASE_INVALID	PHASE_UNSPEC1


/* Per-request state.  This is required in order to support reselection. */
struct sci_req {
	struct		scsi_xfer *sr_xs;	/* Pointer to xfer struct, NULL=unused */
	int		sr_target, sr_lun;	/* For fast access */
	void		*sr_dma_hand;		/* Current DMA hnadle */
	u_char		*sr_dataptr;		/* Saved data pointer */
	int		sr_datalen;
	int		sr_flags;		/* Internal error code */
#define	SR_IMMED			1	/* Immediate command */
#define	SR_SENSE			2	/* We are getting sense */
#define	SR_OVERDUE			4	/* Timeout while not current */
#define	SR_ERROR			8	/* Error occurred */
	int		sr_status;		/* Status code from last cmd */
};
#define	SCI_OPENINGS	16		/* How many commands we can enqueue. */


struct ncr5380_softc {
	struct device	sc_dev;
	struct		scsi_link sc_link;

	/* Pointers to 5380 registers.  See ncr5380reg.h */
	volatile u_char *sci_r0;
	volatile u_char *sci_r1;
	volatile u_char *sci_r2;
	volatile u_char *sci_r3;
	volatile u_char *sci_r4;
	volatile u_char *sci_r5;
	volatile u_char *sci_r6;
	volatile u_char *sci_r7;

	/* Functions set from MD code */
	int		(*sc_pio_out) __P((struct ncr5380_softc *,
					   int, int, u_char *));
	int		(*sc_pio_in) __P((struct ncr5380_softc *,
					  int, int, u_char *));
	void		(*sc_dma_alloc) __P((struct ncr5380_softc *));
	void		(*sc_dma_free) __P((struct ncr5380_softc *));

	void		(*sc_dma_setup) __P((struct ncr5380_softc *));
	void		(*sc_dma_start) __P((struct ncr5380_softc *));
	void		(*sc_dma_poll) __P((struct ncr5380_softc *));
	void		(*sc_dma_eop) __P((struct ncr5380_softc *));
	void		(*sc_dma_stop) __P((struct ncr5380_softc *));

	void		(*sc_intr_on) __P((struct ncr5380_softc *));
	void		(*sc_intr_off) __P((struct ncr5380_softc *));

	int		sc_flags;	/* Misc. flags and capabilities */
#define	NCR5380_PERMIT_RESELECT		1  /* Allow disconnect/reselect */
#define	NCR5380_FORCE_POLLING		2  /* Do not use interrupts. */

	int 	sc_min_dma_len;	/* Smaller than this is done with PIO */

	/* Begin MI shared data */

	int		sc_state;
#define	NCR_IDLE		   0	/* Ready for new work. */
#define NCR_WORKING 	0x01	/* Some command is in progress. */
#define	NCR_ABORTING	0x02	/* Bailing out */
#define NCR_DOINGDMA	0x04	/* The FIFO data path is active! */
#define NCR_DROP_MSGIN	0x10	/* Discard all msgs (parity err detected) */

	/* The request that has the bus now. */
	struct		sci_req *sc_current;

	/* Active data pointer for current SCSI command. */
	u_char		*sc_dataptr;
	int		sc_datalen;

	/* Begin MI private data */

	/* The number of operations in progress on the bus */
	volatile int	sc_ncmds;

	/* Ring buffer of pending/active requests */
	struct		sci_req sc_ring[SCI_OPENINGS];
	int		sc_rr;		/* Round-robin scan pointer */

	/* Active requests, by target/LUN */
	struct		sci_req *sc_matrix[8][8];

	/* Message stuff */
	int	sc_prevphase;

	u_int	sc_msgpriq;	/* Messages we want to send */
	u_int	sc_msgoutq;	/* Messages sent during last MESSAGE OUT */
	u_int	sc_msgout;	/* Message last transmitted */
#define SEND_DEV_RESET		0x01
#define SEND_PARITY_ERROR	0x02
#define SEND_ABORT		0x04
#define SEND_REJECT		0x08
#define SEND_INIT_DET_ERR	0x10
#define SEND_IDENTIFY  		0x20
#define SEND_SDTR		0x40
#define	SEND_WDTR		0x80
#define NCR_MAX_MSG_LEN 8
	u_char  sc_omess[NCR_MAX_MSG_LEN];
	u_char	*sc_omp;		/* Outgoing message pointer */
	u_char	sc_imess[NCR_MAX_MSG_LEN];
	u_char	*sc_imp;		/* Incoming message pointer */

};

void	ncr5380_init __P((struct ncr5380_softc *));
void	ncr5380_reset_scsibus __P((struct ncr5380_softc *));
int 	ncr5380_intr __P((struct ncr5380_softc *));
int 	ncr5380_scsi_cmd __P((struct scsi_xfer *));
int 	ncr5380_pio_in __P((struct ncr5380_softc *, int, int, u_char *));
int 	ncr5380_pio_out __P((struct ncr5380_softc *, int, int, u_char *));

#ifdef	DEBUG
struct ncr5380_softc *ncr5380_debug_sc;
void ncr5380_trace __P((char *msg, long val));
#define	NCR_TRACE(msg, val) ncr5380_trace(msg, val)
#else
#define	NCR_TRACE(msg, val)	/* nada */
#endif
@


1.2
log
@from netbsd:
Latest, greatest version of the new NCR driver.
DMA works!  Interrupts work!  Disconnect/reselect works!
To be paranoid, leave that all disabled for now...
@
text
@d1 1
a1 1
/*	$NetBSD: ncr5380var.h,v 1.1.2.1 1995/11/18 07:08:41 gwr Exp $	*/
@


1.1
log
@gwr says:
New SCSI driver for the NCR5380, by David Jones.
Does DMA with interrupts.  Much faster than our old
driver which did only PIO transfers. (Thanks David!)
Could be used on the amiga, and probably others...
@
text
@d1 1
a1 1
/*	$NetBSD: ncr5380var.h,v 1.1 1995/10/29 21:19:10 gwr Exp $	*/
d43 1
d46 1
a46 1
#define PHASE_CMD	0x2
d53 6
a58 1
#define PHASE_INVALID	-1
a59 1
#define SCSI_PHASE(x)	((x)&0x7)
d66 1
a66 1
	u_char		*sr_data;		/* Saved data pointer */
d71 2
a72 1
#define	SR_ERROR			4	/* Error occurred */
d75 1
a75 1
#define	SCI_OPENINGS	4		/* Up to 4 commands at once */
d82 9
a90 9
	/* Pointers to 5380 registers.  MD code must set these up. */
	volatile u_char *sci_data;
	volatile u_char *sci_icmd;
	volatile u_char *sci_mode;
	volatile u_char *sci_tcmd;
	volatile u_char *sci_bus_csr;
	volatile u_char *sci_csr;
	volatile u_char *sci_idata;
	volatile u_char *sci_iack;
d99 2
d106 3
d111 1
d117 11
a127 1
	/* Active data pointer for current SCSI process */
a130 8
	void		*sc_dma_hand;	/* DMA handle */
	u_int		sc_dma_flags;
#define	DMA5380_INPROGRESS		1	/* MD: DMA is curently in progress */
#define	DMA5380_WRITE			2	/* MI: DMA is to output to SCSI */
#define	DMA5380_POLL			4	/* MI: Poll for DMA completion */
#define	DMA5380_ERROR			8	/* MD: DMA operation failed */
#define	DMA5380_PHYS			16	/* MI: Buffer has B_PHYS set */

a132 3
	/* The request that has the bus now. */
	struct		sci_req *sc_current;

d145 1
a145 4
	int	sc_msg_flags;
#define NCR_DROP_MSGIN	1
#define NCR_ABORTING	2
#define NCR_NEED_RESET	4
d167 1
a167 1
int 	ncr5380_sbc_intr __P((struct ncr5380_softc *));
d172 7
@
