head	1.12;
access;
symbols
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.6
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2002.12.31.16.35.40;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.13.00.22.21;	author miod;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	99.01.11.05.12.03;	author millert;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	97.06.23.13.40.47;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.16.04.04.00;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.12.31.06.13.00;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.07.55.00;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.11.23.06.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.16.03.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.31.06.41.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.53;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.53;	author deraadt;	state Exp;
branches;
next	;

1.9.6.1
date	2001.07.04.10.23.58;	author niklas;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2003.03.27.23.52.17;	author niklas;	state dead;
branches;
next	;

1.10.4.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2003.05.19.21.49.45;	author tedu;	state dead;
branches;
next	;


desc
@@


1.12
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: zs.c,v 1.11 2002/03/14 01:26:46 millert Exp $	*/
/*	$NetBSD: zs.c,v 1.42 1996/11/20 18:57:03 gwr Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Zilog Z8530 Dual UART driver (machine-dependent part)
 *
 * Runs two serial lines per chip using slave drivers.
 * Plain tty/async lines use the zs_async slave.
 * Sun keyboard/mouse uses the zs_kbd/zs_ms slaves.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <dev/cons.h>
#include <dev/ic/z8530reg.h>
#include <machine/z8530var.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/obio.h>
#include <machine/mon.h>

#ifdef DDB
#include <ddb/db_var.h>
#endif

/*
 * XXX: Hard code this to make console init easier...
 */
#define	NZS	2		/* XXX */


/*
 * The Sun3 provides a 4.9152 MHz clock to the ZS chips.
 */
#define PCLK	(9600 * 512)	/* PCLK pin input clock rate */

/*
 * Define interrupt levels.
 */
#define ZSHARD_PRI	6	/* Wired on the CPU board... */
#define ZSSOFT_PRI	3	/* Want tty pri (4) but this is OK. */

#define ZS_DELAY()			delay(2)

/*
 * The layout of this is hardware-dependent (padding, order).
 */
struct zschan {
	volatile u_char	zc_csr;		/* ctrl,status, and indirect access */
	u_char		zc_xxx0;
	volatile u_char	zc_data;	/* data */
	u_char		zc_xxx1;
};

struct zsdevice {
	/* Yes, they are backwards. */
	struct	zschan zs_chan_b;
	struct	zschan zs_chan_a;
};


/* Default OBIO addresses. */
static int zs_physaddr[NZS] = { OBIO_KEYBD_MS, OBIO_ZS };

/* Saved PROM mappings */
static struct zsdevice *zsaddr[NZS];	/* See zs_init() */

/* Flags from cninit() */
static int zs_hwflags[NZS][2];

/* Default speed for each channel */
static int zs_defspeed[NZS][2] = {
	{ 1200, 	/* keyboard */
	  1200 },	/* mouse */
	{ 9600, 	/* ttya */
	  9600 },	/* ttyb */
};


static struct zschan *zs_get_chan_addr(int, int);
int zs_getc(volatile void *);
static void zs_putc(volatile void *, int);

int  zscngetc(dev_t);
void zscnputc(dev_t, int);
void nullcnprobe(struct consdev *);
void zscninit(struct consdev *);

/* Find PROM mappings (for console support). */
void zs_init()
{
	int i;

	for (i = 0; i < NZS; i++) {
		zsaddr[i] = (struct zsdevice *)
			obio_find_mapping(zs_physaddr[i], OBIO_ZS_SIZE);
	}
}


static struct zschan *
zs_get_chan_addr(zsc_unit, channel)
	int zsc_unit, channel;
{
	struct zsdevice *addr;
	struct zschan *zc;

	if (zsc_unit >= NZS)
		return NULL;
	addr = zsaddr[zsc_unit];
	if (addr == NULL)
		return NULL;
	if (channel == 0) {
		zc = &addr->zs_chan_a;
	} else {
		zc = &addr->zs_chan_b;
	}
	return (zc);
}


static u_char zs_init_reg[16] = {
	0,	/* 0: CMD (reset, etc.) */
	ZSWR1_RIE | ZSWR1_TIE | ZSWR1_SIE,
	0x18 + ZSHARD_PRI,	/* IVECT */
	ZSWR3_RX_8 | ZSWR3_RX_ENABLE,
	ZSWR4_CLK_X16 | ZSWR4_ONESB | ZSWR4_EVENP,
	ZSWR5_TX_8 | ZSWR5_TX_ENABLE,
	0,	/* 6: TXSYNC/SYNCLO */
	0,	/* 7: RXSYNC/SYNCHI */
	0,	/* 8: alias for data port */
	ZSWR9_MASTER_IE,
	0,	/*10: Misc. TX/RX control bits */
	ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD,
	14,	/*12: BAUDLO (default=9600) */
	0,	/*13: BAUDHI (default=9600) */
	ZSWR14_BAUD_FROM_PCLK | ZSWR14_BAUD_ENA,
	ZSWR15_BREAK_IE | ZSWR15_DCD_IE,
};


/****************************************************************
 * Autoconfig
 ****************************************************************/

/* Definition of the driver for autoconfig. */
static int	zsc_match(struct device *, void *, void *);
static void	zsc_attach(struct device *, struct device *, void *);
static int  zsc_print(void *, const char *name);

struct cfattach zsc_ca = {
	sizeof(struct zsc_softc), zsc_match, zsc_attach
};

struct cfdriver zsc_cd = {
	NULL, "zsc", DV_DULL
};

static int zshard(void *);
static int zssoft(void *);


/*
 * Is the zs chip present?
 */
static int
zsc_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = aux;
	int pa, unit, x;
	void *va;

	unit = cf->cf_unit;
	if (unit < 0 || unit >= NZS)
		return (0);

	/*
	 * OBIO match functions may be called for every possible
	 * physical address, so match only our physical address.
	 * This driver only supports its default mappings, so
	 * non-default locators must match our defaults.
	 */
	if ((pa = cf->cf_paddr) == -1) {
		/* Use our default PA. */
		pa = zs_physaddr[unit];
	} else {
		/* Validate the given PA. */
		if (pa != zs_physaddr[unit])
			return (0);
	}
	if (pa != ca->ca_paddr)
		return (0);

	/* Make sure zs_init() found mappings. */
	va = zsaddr[unit];
	if (va == NULL)
		return (0);

	/* This returns -1 on a fault (bus error). */
	x = peek_byte(va);
	return (x != -1);
}

/*
 * Attach a found zs.
 *
 * Match slave number to zs unit number, so that misconfiguration will
 * not set up the keyboard as ttya, etc.
 */
static void
zsc_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct zsc_softc *zsc = (void *) self;
	struct cfdata *cf = self->dv_cfdata;
	struct zsc_attach_args zsc_args;
	volatile struct zschan *zc;
	struct zs_chanstate *cs;
	int zsc_unit, intpri, channel;
	int reset, s;
	static int didintr;

	zsc_unit = zsc->zsc_dev.dv_unit;

	if ((intpri = cf->cf_intpri) == -1)
		intpri = ZSHARD_PRI;

	printf(" level %d (softpri %d)\n", intpri, ZSSOFT_PRI);

	/* Use the mapping setup by the Sun PROM. */
	if (zsaddr[zsc_unit] == NULL)
		panic("zs_attach: zs%d not mapped", zsc_unit);

	/*
	 * Initialize software state for each channel.
	 */
	for (channel = 0; channel < 2; channel++) {
		cs = &zsc->zsc_cs[channel];

		zc = zs_get_chan_addr(zsc_unit, channel);
		cs->cs_reg_csr  = &zc->zc_csr;
		cs->cs_reg_data = &zc->zc_data;

		cs->cs_channel = channel;
		cs->cs_private = NULL;
		cs->cs_ops = &zsops_null;

		/* Define BAUD rate clock for the MI code. */
		cs->cs_brg_clk = PCLK / 16;

		/* XXX: get defspeed from EEPROM instead? */
		cs->cs_defspeed = zs_defspeed[zsc_unit][channel];

		bcopy(zs_init_reg, cs->cs_creg, 16);
		bcopy(zs_init_reg, cs->cs_preg, 16);

		/*
		 * Clear the master interrupt enable.
		 * The INTENA is common to both channels,
		 * so just do it on the A channel.
		 */
		if (channel == 0) {
			zs_write_reg(cs, 9, 0);
		}

		/*
		 * Look for a child driver for this channel.
		 * The child attach will setup the hardware.
		 */
		zsc_args.channel = channel;
		zsc_args.hwflags = zs_hwflags[zsc_unit][channel];
		if (config_found(self, (void *)&zsc_args, zsc_print) == NULL) {
			/* No sub-driver.  Just reset it. */
			reset = (channel == 0) ?
				ZSWR9_A_RESET : ZSWR9_B_RESET;
			s = splzs();
			zs_write_reg(cs,  9, reset);
			splx(s);
		}
	}

	/* Now safe to install interrupt handlers */
	if (!didintr) {
		didintr = 1;
		isr_add_autovect(zssoft, NULL, ZSSOFT_PRI);
		isr_add_autovect(zshard, NULL, ZSHARD_PRI);
	}

	/*
	 * Set the master interrupt enable and interrupt vector.
	 * (common to both channels, do it on A)
	 */
	cs = &zsc->zsc_cs[0];
	s = splzs();
	/* interrupt vector */
	zs_write_reg(cs, 2, zs_init_reg[2]);
	/* master interrupt control (enable) */
	zs_write_reg(cs, 9, zs_init_reg[9]);
	splx(s);
}

static int
zsc_print(aux, name)
	void *aux;
	const char *name;
{
	struct zsc_attach_args *args = aux;

	if (name != NULL)
		printf("%s: ", name);

	if (args->channel != -1)
		printf(" channel %d", args->channel);

	return UNCONF;
}

static int
zshard(arg)
	void *arg;
{
	struct zsc_softc *zsc;
	int unit, rval;

	/* Do ttya/ttyb first, because they go faster. */
	rval = 0;
	unit = zsc_cd.cd_ndevs;
	while (--unit >= 0) {
		zsc = zsc_cd.cd_devs[unit];
		if (zsc != NULL) {
			rval |= zsc_intr_hard(zsc);
		}
	}
	return (rval);
}

int zssoftpending;

void
zsc_req_softint(zsc)
	struct zsc_softc *zsc;
{
	if (zssoftpending == 0) {
		/* We are at splzs here, so no need to lock. */
		zssoftpending = ZSSOFT_PRI;
		isr_soft_request(ZSSOFT_PRI);
	}
}

static int
zssoft(arg)
	void *arg;
{
	struct zsc_softc *zsc;
	int unit;

	/* This is not the only ISR on this IPL. */
	if (zssoftpending == 0)
		return (0);

	/*
	 * The soft intr. bit will be set by zshard only if
	 * the variable zssoftpending is zero.  The order of
	 * these next two statements prevents our clearing
	 * the soft intr bit just after zshard has set it.
	 */
	isr_soft_clear(ZSSOFT_PRI);
	zssoftpending = 0;

	/* Do ttya/ttyb first, because they go faster. */
	unit = zsc_cd.cd_ndevs;
	while (--unit >= 0) {
		zsc = zsc_cd.cd_devs[unit];
		if (zsc != NULL) {
			(void) zsc_intr_soft(zsc);
		}
	}
	return (1);
}


/*
 * Read or write the chip with suitable delays.
 */

u_char
zs_read_reg(cs, reg)
	struct zs_chanstate *cs;
	u_char reg;
{
	u_char val;

	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return val;
}

void
zs_write_reg(cs, reg, val)
	struct zs_chanstate *cs;
	u_char reg, val;
{
	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	*cs->cs_reg_csr = val;
	ZS_DELAY();
}

u_char
zs_read_csr(cs)
	struct zs_chanstate *cs;
{
	register u_char v;

	v = *cs->cs_reg_csr;
	ZS_DELAY();
	return v;
}

u_char
zs_read_data(cs)
	struct zs_chanstate *cs;
{
	register u_char v;

	v = *cs->cs_reg_data;
	ZS_DELAY();
	return v;
}

void  zs_write_csr(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_csr = val;
	ZS_DELAY();
}

void
zs_write_data(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_data = val;
	ZS_DELAY();
}

/****************************************************************
 * Console support functions (Sun3 specific!)
 ****************************************************************/

/*
 * Polled input char.
 */
int
zs_getc(arg)
	volatile void *arg;
{
	register volatile struct zschan *zc = arg;
	register int s, c, rr0;

	s = splhigh();
	/* Wait for a character to arrive. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_RX_READY) == 0);

	c = zc->zc_data;
	ZS_DELAY();
	splx(s);

	/*
	 * This is used by the kd driver to read scan codes,
	 * so don't translate '\r' ==> '\n' here...
	 */
	return (c);
}

/*
 * Polled output char.
 */
static void
zs_putc(arg, c)
	volatile void *arg;
	int c;
{
	register volatile struct zschan *zc = arg;
	register int s, rr0;

	s = splhigh();
	/* Wait for transmitter to become ready. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_TX_READY) == 0);

	zc->zc_data = c;
	ZS_DELAY();
	splx(s);
}

extern struct consdev consdev_kd;	/* keyboard/display */
extern struct consdev consdev_tty;
extern struct consdev *cn_tab;	/* physical console device info */

void *zs_conschan;

/*
 * This function replaces sys/dev/cninit.c
 * Determine which device is the console using
 * the PROM "input source" and "output sink".
 */
void
cninit()
{
	MachMonRomVector *v;
	struct zschan *zc;
	struct consdev *cn;
	int zsc_unit, channel;
	char inSource;

	v = romVectorPtr;
	inSource = *(v->inSource);

	if (inSource != *(v->outSink)) {
		mon_printf("cninit: mismatched PROM output selector\n");
	}

	switch (inSource) {

	case 1:	/* ttya */
	case 2:	/* ttyb */
		zsc_unit = 1;
		channel = inSource - 1;
		cn = &consdev_tty;
		cn->cn_dev = makedev(ZSTTY_MAJOR, channel);
		cn->cn_pri = CN_REMOTE;
		break;

	case 3:	/* ttyc (rewired keyboard connector) */
	case 4:	/* ttyd (rewired mouse connector)   */
		zsc_unit = 0;
		channel = inSource - 3;
		cn = &consdev_tty;
		cn->cn_dev = makedev(ZSTTY_MAJOR, (channel+2));
		cn->cn_pri = CN_REMOTE;
		break;

	default:
		mon_printf("cninit: invalid PROM console selector\n");
		/* assume keyboard/display */
		/* fallthrough */
	case 0:	/* keyboard/display */
		zsc_unit = 0;
		channel = 0;
		cn = &consdev_kd;
		/* Set cn_dev, cn_pri in kd.c */
		break;
	}

	zc = zs_get_chan_addr(zsc_unit, channel);
	if (zc == NULL) {
		mon_printf("cninit: zs not mapped.\n");
		return;
	}
	zs_conschan = zc;
	zs_hwflags[zsc_unit][channel] = ZS_HWFLAG_CONSOLE;
	cn_tab = cn;
	(*cn->cn_init)(cn);
}


/* We never call this. */
void
nullcnprobe(cn)
	struct consdev *cn;
{
}

void
zscninit(cn)
	struct consdev *cn;
{
	int unit = minor(cn->cn_dev) & 1;

	mon_printf("console is zstty%d (tty%c)\n",
		   unit, unit + 'a');
}

/*
 * Polled console input putchar.
 */
int
zscngetc(dev)
	dev_t dev;
{
	register volatile struct zschan *zc = zs_conschan;
	register int c;

	c = zs_getc(zc);
	return (c);
}

/*
 * Polled console output putchar.
 */
void
zscnputc(dev, c)
	dev_t dev;
	int c;
{
	register volatile struct zschan *zc = zs_conschan;

	zs_putc(zc, c);
}


struct consdev consdev_tty = {
	nullcnprobe,
	zscninit,
	zscngetc,
	zscnputc,
	nullcnpollc,
};


/*
 * Handle user request to enter kernel debugger.
 */
void
zs_abort()
{
	register volatile struct zschan *zc = zs_conschan;
	int rr0;

	/* Wait for end of break to avoid PROM abort. */
	/* XXX - Limit the wait? */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while (rr0 & ZSRR0_BREAK);
#ifdef DDB
	if (db_console)
		Debugger();
#endif
}
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.10 2001/05/13 00:22:21 miod Exp $	*/
@


1.10
log
@Honor the ddb.console sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.9 1999/01/11 05:12:03 millert Exp $	*/
d127 8
a134 8
static struct zschan *zs_get_chan_addr __P((int, int));
int zs_getc __P((volatile void *));
static void zs_putc __P((volatile void *, int));

int  zscngetc __P((dev_t));
void zscnputc __P((dev_t, int));
void nullcnprobe __P((struct consdev *));
void zscninit __P((struct consdev *));
d194 3
a196 3
static int	zsc_match __P((struct device *, void *, void *));
static void	zsc_attach __P((struct device *, struct device *, void *));
static int  zsc_print __P((void *, const char *name));
@


1.10.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.10 2001/05/13 00:22:21 miod Exp $	*/
d127 8
a134 8
static struct zschan *zs_get_chan_addr(int, int);
int zs_getc(volatile void *);
static void zs_putc(volatile void *, int);

int  zscngetc(dev_t);
void zscnputc(dev_t, int);
void nullcnprobe(struct consdev *);
void zscninit(struct consdev *);
d194 3
a196 3
static int	zsc_match(struct device *, void *, void *);
static void	zsc_attach(struct device *, struct device *, void *);
static int  zsc_print(void *, const char *name);
@


1.10.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.10.4.1 2002/06/11 03:39:01 art Exp $	*/
@


1.9
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.8 1997/06/23 13:40:47 kstailey Exp $	*/
d69 4
d698 2
a699 1
	Debugger();
@


1.9.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.9 1999/01/11 05:12:03 millert Exp $	*/
a68 4
#ifdef DDB
#include <ddb/db_var.h>
#endif

d694 1
a694 2
	if (db_console)
		Debugger();
@


1.9.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d127 8
a134 8
static struct zschan *zs_get_chan_addr(int, int);
int zs_getc(volatile void *);
static void zs_putc(volatile void *, int);

int  zscngetc(dev_t);
void zscnputc(dev_t, int);
void nullcnprobe(struct consdev *);
void zscninit(struct consdev *);
d194 3
a196 3
static int	zsc_match(struct device *, void *, void *);
static void	zsc_attach(struct device *, struct device *, void *);
static int  zsc_print(void *, const char *name);
@


1.9.6.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.9.6.2 2002/03/28 11:26:45 niklas Exp $	*/
@


1.8
log
@In zs_abort, wrap a #ifdef DDB around a Debugger() invocation.
Chris Jones via Gene Skonicki.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.7 1997/01/16 04:04:00 kstailey Exp $	*/
d280 1
a280 1
		panic("zs_attach: zs%d not mapped\n", zsc_unit);
@


1.7
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d693 1
a693 2

	/* XXX - Always available, but may be the PROM monitor. */
d695 1
@


1.6
log
@sync with 17-Dec-1996
@
text
@d1 1
d75 3
a77 1
/* The Sun3 provides a 4.9152 MHz clock to the ZS chips. */
d88 3
a90 1
/* The layout of this is hardware-dependent (padding, order). */
d97 1
d107 1
d110 1
d113 1
d123 9
d141 1
a141 1
}	
d144 1
a144 1
struct zschan *
a263 1
	struct confargs *ca = aux;
d372 1
a372 1
	
d390 1
a390 1
{	
d459 2
a460 1
u_char zs_read_csr(cs)
d470 2
a471 1
u_char zs_read_data(cs)
d489 2
a490 1
void  zs_write_data(cs, val)
d507 1
a507 1
	void *arg;
d533 1
a533 1
void
d535 1
a535 1
	void *arg;
a555 1
extern void nullcnpollc();
@


1.5
log
@sync with NetBSD
@
text
@a64 1
#include <machine/isr.h>
@


1.4
log
@sync + our changes
@
text
@d1 1
a1 1
/*	$NetBSD: zs.c,v 1.38 1996/06/17 15:17:06 gwr Exp $	*/
d3 2
a4 2
/*
 * Copyright (c) 1995 Gordon W. Ross
d7 3
d18 1
a18 3
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
d20 5
a24 1
 *      This product includes software developed by Gordon Ross
d26 11
a36 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d175 1
a175 1
static int  zsc_print __P((void *, char *name));
d337 1
a337 1
	char *name;
@


1.3
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: zs.c,v 1.36 1996/04/04 06:26:15 cgd Exp $	*/
a58 1
#include <machine/eeprom.h>
d275 1
a275 1
		cs->cs_pclk_div16 = PCLK / 16;
d538 1
a538 1
 * the "console" byte from the EEPROM.
d543 1
d547 1
d549 2
a550 1
	switch (ee_console) {
d552 8
a559 2
	case EE_CONS_TTYA:
	case EE_CONS_TTYB:
d561 1
a561 1
		channel = (ee_console & 1);
d567 9
d577 1
a577 1
		mon_printf("cninit: unknown eeprom console setting\n");
d580 1
a580 3
	case EE_CONS_BW:
	case EE_CONS_COLOR:
	case EE_CONS_P4OPT:
@


1.2
log
@sync with netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: zs.c,v 1.31 1996/01/24 22:40:25 gwr Exp $	*/
d79 1
d168 3
a170 2
static int	zsc_match(struct device *, void *, void *);
static void	zsc_attach(struct device *, struct device *, void *);
d172 6
a177 3
struct cfdriver zsccd = {
	NULL, "zsc", zsc_match, zsc_attach,
	DV_DULL, sizeof(struct zsc_softc), NULL,
d190 1
a190 2
	void *vcf;
	void *aux;
d194 2
a195 2
	int unit, x;
	void *zsva;
d201 17
d219 2
a220 2
	zsva = zsaddr[unit];
	if (zsva == NULL)
a222 5
	if (ca->ca_paddr == -1)
		ca->ca_paddr = zs_physaddr[unit];
	if (ca->ca_intpri == -1)
		ca->ca_intpri = ZSHARD_PRI;

d224 1
a224 1
	x = peek_byte(zsva);
a227 16
static int
zsc_print(aux, name)
	void *aux;
	char *name;
{
	struct zsc_attach_args *args = aux;

	if (name != NULL)
		printf("%s: ", name);

	if (args->channel != -1)
		printf(" channel %d", args->channel);

	return UNCONF;
}

d241 1
d246 1
a246 1
	int zsc_unit, channel;
d252 4
a255 1
	printf(" softpri %d\n", ZSSOFT_PRI);
d290 1
a290 1
			ZS_WRITE(cs, 9, 0);
d299 1
a299 1
		if (!config_found(self, (void *) &zsc_args, zsc_print)) {
d304 1
a304 1
			ZS_WRITE(cs,  9, reset);
d323 1
a323 1
	ZS_WRITE(cs, 2, zs_init_reg[2]);
d325 1
a325 1
	ZS_WRITE(cs, 9, zs_init_reg[9]);
d330 16
d354 1
a354 1
	unit = zsccd.cd_ndevs;
d356 1
a356 1
		zsc = zsccd.cd_devs[unit];
d398 1
a398 1
	unit = zsccd.cd_ndevs;
d400 1
a400 1
		zsc = zsccd.cd_devs[unit];
d435 36
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: zs.c,v 1.30 1995/10/08 23:42:59 gwr Exp $	*/
d4 2
a5 12
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
d15 3
a17 1
 * 3. All advertising materials mentioning features or use of this software
d19 1
a19 5
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d21 10
a30 13
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)zs.c	8.1 (Berkeley) 7/19/93
d34 1
a34 4
 * Zilog Z8530 (ZSCC) driver.
 *
 * Runs two tty ports (ttya and ttyb) on zs0,
 * and runs a keyboard and mouse on zs1.
d36 3
a38 1
 * This driver knows far too much about chip to usage mappings.
a39 1
#define	NZS	2		/* XXX */
d53 4
d59 1
a62 7
#include <machine/eeprom.h>
#include <machine/kbd.h>

#include <dev/cons.h>

#include <dev/ic/z8530reg.h>
#include <sun3/dev/zsvar.h>
d65 1
a65 2
 * The default parity REALLY needs to be the same as the PROM uses,
 * or you can not see messages done with printf during boot-up...
d67 1
a67 6
#undef	TTYDEF_CFLAG
#define	TTYDEF_CFLAG	(CREAD | CS8 | HUPCL)

#ifdef KGDB
#include <machine/remote-sl.h>
#endif
a68 4
#define	ZSMAJOR	12		/* XXX */

#define	ZS_KBD		2	/* XXX */
#define	ZS_MOUSE	3	/* XXX */
d79 12
a90 8
/*
 * Software state per found chip.  This would be called `zs_softc',
 * but the previous driver had a rather different zs_softc....
 */
struct zsinfo {
	struct	device zi_dev;		/* base device */
	volatile struct zsdevice *zi_zs;/* chip registers */
	struct	zs_chanstate zi_cs[2];	/* channel A and B software state */
a92 1
static struct tty *zs_tty[NZS * 2]; 	/* XXX should be dynamic */
d94 13
a106 3
/* Definition of the driver for autoconfig. */
static int	zs_match(struct device *, void *, void *);
static void	zs_attach(struct device *, struct device *, void *);
a107 36
struct cfdriver zscd = {
	NULL, "zs", zs_match, zs_attach,
	DV_TTY, sizeof(struct zsinfo) };

/* Interrupt handlers. */
static int	zshard(int);
static int	zssoft(int);

struct zs_chanstate *zslist;

/* Routines called from other code. */
int zsopen(dev_t, int, int, struct proc *);
int zsclose(dev_t, int, int, struct proc *);
static void	zsiopen(struct tty *);
static void	zsiclose(struct tty *);
static void	zsstart(struct tty *);
void		zsstop(struct tty *, int);
static int	zsparam(struct tty *, struct termios *);

/* Routines purely local to this driver. */
static int	zs_getspeed(volatile struct zschan *);
static void	zs_reset(volatile struct zschan *, int, int);
static void	zs_modem(struct zs_chanstate *, int);
static void	zs_loadchannelregs(volatile struct zschan *, u_char *);
static u_char zs_read(volatile struct zschan *, u_char);
static u_char zs_write(volatile struct zschan *, u_char, u_char);

/* Console stuff. */
static volatile struct zschan *zs_conschan;

#ifdef KGDB
/* KGDB stuff.  Must reboot to change zs_kgdbunit. */
extern int kgdb_dev, kgdb_rate;
static int zs_kgdb_savedspeed;
static void zs_checkkgdb(int, struct zs_chanstate *, struct tty *);
#endif
d109 4
a112 11
/*
 * Console keyboard L1-A processing is done in the hardware interrupt code,
 * so we need to duplicate some of the console keyboard decode state.  (We
 * must not use the regular state as the hardware code keeps ahead of the
 * software state: the software state tracks the most recent ring input but
 * the hardware state tracks the most recent ZSCC input.)  See also kbd.h.
 */
static struct conk_state {	/* console keyboard state */
	char	conk_id;	/* true => ID coming up (console only) */
	char	conk_l1;	/* true => L1 pressed (console only) */
} zsconk_state;
d114 5
a118 2
int zshardscope;
int zsshortcuts;		/* number of "shortcut" software interrupts */
a119 1
int zssoftpending;		/* We have done isr_soft_request() */
d121 19
a139 1
static struct zsdevice *zsaddr[NZS];	/* XXX, but saves work */
a140 2
/* Default OBIO addresses. */
static int zs_physaddr[NZS] = { OBIO_ZS, OBIO_KEYBD_MS };
d152 1
a152 1
	0,	/* 9: ZSWR9_MASTER_IE (later) */
d155 2
a156 2
	0,	/*12: BAUDLO (later) */
	0,	/*13: BAUDHI (later) */
a160 4
/* Find PROM mappings (for console support). */
void zs_init()
{
	int i;
d162 16
a177 5
	for (i = 0; i < NZS; i++) {
		zsaddr[i] = (struct zsdevice *)
			obio_find_mapping(zs_physaddr[i], OBIO_ZS_SIZE);
	}
}	
d180 1
a180 2
 * Match slave number to zs unit number, so that misconfiguration will
 * not set up the keyboard as ttya, etc.
d183 4
a186 1
zs_match(struct device *parent, void *vcf, void *args)
d189 1
a189 1
	struct confargs *ca = args;
d197 1
d212 16
d231 2
a232 2
 * USE ROM PROPERTIES port-a-ignore-cd AND port-b-ignore-cd FOR
 * SOFT CARRIER, AND keyboard PROPERTY FOR KEYBOARD/MOUSE?
d235 12
a246 10
zs_attach(struct device *parent, struct device *self, void *args)
{
	struct cfdata *cf;
	struct confargs *ca;
	register int zs, unit;
	register struct zsinfo *zi;
	register struct zs_chanstate *cs;
	register volatile struct zsdevice *addr;
	register struct tty *tp, *ctp;
	int softcar;
d249 1
a249 3
	cf = self->dv_cfdata;
	zs = self->dv_unit;
	ca = args;
d253 13
a265 3
	if (zsaddr[zs] == NULL)
		panic("zs_attach: zs%d not mapped\n", zs);
	addr = zsaddr[zs];
d267 9
a275 5
	if (!didintr) {
		didintr = 1;
		isr_add_autovect(zssoft, NULL, ZSSOFT_PRI);
		isr_add_autovect(zshard, NULL, ZSHARD_PRI);
	}
d277 2
a278 47
	zi = (struct zsinfo *)self;
	zi->zi_zs = addr;
	unit = zs * 2;
	cs = zi->zi_cs;
	softcar = cf->cf_flags;

	if(!zs_tty[unit])
		zs_tty[unit] = ttymalloc();
	if(!zs_tty[unit+1])
		zs_tty[unit+1] = ttymalloc();

	/* link into interrupt list with order (A,B) (B=A+1) */
	cs[0].cs_next = &cs[1];
	cs[1].cs_next = zslist;
	zslist = cs;

	tp = zs_tty[unit];
	cs->cs_unit = unit;
	cs->cs_zc = &addr->zs_chan[ZS_CHAN_A];
	cs->cs_speed = zs_getspeed(cs->cs_zc);
#ifdef	DEBUG
	mon_printf("zs%da speed %d ",  zs, cs->cs_speed);
#endif
	cs->cs_softcar = softcar & 1;
	cs->cs_ttyp = tp;
	tp->t_dev = makedev(ZSMAJOR, unit);
	tp->t_oproc = zsstart;
	tp->t_param = zsparam;
	if (cs->cs_zc == zs_conschan) {
		/* This unit is the console. */
		cs->cs_consio = 1;
		cs->cs_brkabort = 1;
		cs->cs_softcar = 1;
		/* Call zsparam so interrupts get enabled. */
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		tp->t_cflag = TTYDEF_CFLAG;
		(void) zsparam(tp, &tp->t_termios);
	} else {
		/* Can not run kgdb on the console? */
#ifdef KGDB
		zs_checkkgdb(unit, cs, tp);
#endif
	}
#if 0
	/* XXX - Drop carrier here? -gwr */
	zs_modem(cs, cs->cs_softcar ? 1 : 0);
#endif
a279 1
	if (unit == ZS_KBD) {
d281 3
a283 1
		 * Keyboard: tell /dev/kbd driver how to talk to us.
d285 3
a287 39
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		tp->t_cflag = CS8;
		/* zsparam called by zsiopen */
		kbd_serial(tp, zsiopen, zsiclose);
		cs->cs_conk = 1;		/* do L1-A processing */
	}
	unit++;
	cs++;
	tp = zs_tty[unit];

	cs->cs_unit = unit;
	cs->cs_zc = &addr->zs_chan[ZS_CHAN_B];
	cs->cs_speed = zs_getspeed(cs->cs_zc);
#ifdef	DEBUG
	mon_printf("zs%db speed %d\n", zs, cs->cs_speed);
#endif
	cs->cs_softcar = softcar & 2;
	cs->cs_ttyp = tp;
	tp->t_dev = makedev(ZSMAJOR, unit);
	tp->t_oproc = zsstart;
	tp->t_param = zsparam;
	if (cs->cs_zc == zs_conschan) {
		/* This unit is the console. */
		cs->cs_consio = 1;
		cs->cs_brkabort = 1;
		cs->cs_softcar = 1;
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		tp->t_cflag = TTYDEF_CFLAG;
		(void) zsparam(tp, &tp->t_termios);
	} else {
		/* Can not run kgdb on the console? */
#ifdef KGDB
		zs_checkkgdb(unit, cs, tp);
#endif
	}
#if 0
	/* XXX - Drop carrier here? -gwr */
	zs_modem(cs, cs->cs_softcar ? 1 : 0);
#endif
a288 1
	if (unit == ZS_MOUSE) {
d290 2
a291 1
		 * Mouse: tell /dev/mouse driver how to talk to us.
d293 10
a302 4
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		tp->t_cflag = CS8;
		/* zsparam called by zsiopen */
		ms_serial(tp, zsiopen, zsiclose);
a303 1
}
d305 6
a310 8
/*
 * XXX - Temporary hack...
 */
struct tty *
zstty(dev)
	dev_t dev;
{
	int unit = minor(dev);
d312 11
a322 1
	return (zs_tty[unit]);
d325 3
a327 8
/*
 * Put a channel in a known state.  Interrupts may be left disabled
 * or enabled, as desired.  (Used only by kgdb)
 */
static void
zs_reset(zc, inten, speed)
	volatile struct zschan *zc;
	int inten, speed;
d329 13
a341 11
	int tconst;
	u_char reg[16];

	bcopy(zs_init_reg, reg, 16);
	if (inten)
		reg[9] |= ZSWR9_MASTER_IE;

	tconst = BPS_TO_TCONST(PCLK / 16, speed);
	reg[12] = tconst;
	reg[13] = tconst >> 8;
	zs_loadchannelregs(zc, reg);
d344 1
a344 3
/*
 * Console support
 */
d346 8
a353 9
/*
 * Used by the kd driver to find out if it can work.
 */
int
zscnprobe_kbd()
{
	if (zsaddr[1] == NULL) {
		mon_printf("zscnprobe_kbd: zs1 not yet mapped\n");
		return CN_DEAD;
a354 1
	return CN_INTERNAL;
a356 3
/*
 * This is the console probe routine for ttya and ttyb.
 */
d358 2
a359 1
zscnprobe(struct consdev *cn, int unit)
d361 6
a366 1
	int maj;
d368 8
a375 6
	if (zsaddr[0] == NULL) {
		mon_printf("zscnprobe: zs0 not mapped\n");
		cn->cn_pri = CN_DEAD;
		return 0;
	}
	/* XXX - Also try to make sure it exists? */
d377 7
a383 13
	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == (void*)zsopen)
			break;

	cn->cn_dev = makedev(maj, unit);

	/* Use EEPROM console setting to decide "remote" console. */
	/* Note: EE_CONS_TTYA + 1 == EE_CONS_TTYB */
	if (ee_console == (EE_CONS_TTYA + unit)) {
		cn->cn_pri = CN_REMOTE;
	} else {
		cn->cn_pri = CN_NORMAL;
d385 1
a385 1
	return (0);
a387 6
/* This is the constab entry for TTYA. */
int
zscnprobe_a(struct consdev *cn)
{
	return (zscnprobe(cn, 0));
}
d389 3
a391 6
/* This is the constab entry for TTYB. */
int
zscnprobe_b(struct consdev *cn)
{
	return (zscnprobe(cn, 1));
}
d393 4
a396 4
/* Called by kdcninit() or below. */
void
zs_set_conschan(unit, ab)
	int unit, ab;
d398 1
a398 1
	volatile struct zsdevice *addr;
d400 5
a404 4
	addr = zsaddr[unit];
	zs_conschan = ((ab == 0) ?
				   &addr->zs_chan[ZS_CHAN_A] :
				   &addr->zs_chan[ZS_CHAN_B] );
d407 4
a410 3
/* Attach as console.  Also set zs_conschan */
int
zscninit(struct consdev *cn)
d412 4
a415 3
	int ab = minor(cn->cn_dev) & 1;
	zs_set_conschan(0, ab);
	mon_printf("console on zs0 (tty%c)\n", 'a' + ab);
d418 3
d423 1
a423 1
 * Polled console input putchar.
d426 2
a427 2
zscngetc(dev)
	dev_t dev;
d429 1
a429 1
	register volatile struct zschan *zc = zs_conschan;
a431 3
	if (zc == NULL)
		return (0);

a432 1

a440 1

d451 1
a451 1
 * Polled console output putchar.
d453 3
a455 3
int
zscnputc(dev, c)
	dev_t dev;
d458 1
a458 1
	register volatile struct zschan *zc = zs_conschan;
a460 6
	if (zc == NULL) {
		s = splhigh();
		mon_putchar(c);
		splx(s);
		return (0);
	}
a461 1

d473 7
a479 1
#ifdef KGDB
d481 3
a483 3
 * The kgdb zs port, if any, was altered at boot time (see zs_kgdb_init).
 * Pick up the current speed and character size and restore the original
 * speed.
d485 2
a486 2
static void
zs_checkkgdb(int unit, struct zs_chanstate *cs, struct tty *tp)
d488 14
d503 12
a514 6
	if (kgdb_dev == makedev(ZSMAJOR, unit)) {
		tp->t_ispeed = tp->t_ospeed = kgdb_rate;
		tp->t_cflag = CS8;
		cs->cs_kgdb = 1;
		cs->cs_speed = zs_kgdb_savedspeed;
		(void) zsparam(tp, &tp->t_termios);
a515 2
}
#endif
d517 9
a525 12
/*
 * Compute the current baud rate given a ZSCC channel.
 */
static int
zs_getspeed(zc)
	register volatile struct zschan *zc;
{
	register int tconst;

	tconst = ZS_READ(zc, 12);
	tconst |= ZS_READ(zc, 13) << 8;
	return (TCONST_TO_BPS(PCLK / 16, tconst));
d529 4
a532 6
/*
 * Do an internal open.
 */
static void
zsiopen(tp)
	struct tty *tp;
a533 4

	(void) zsparam(tp, &tp->t_termios);
	ttsetwater(tp);
	tp->t_state = TS_ISOPEN | TS_CARR_ON;
d536 3
a538 7
/*
 * Do an internal close.  Eventually we should shut off the chip when both
 * ports on it are closed.
 */
static void
zsiclose(tp)
	struct tty *tp;
d540 1
d542 2
a543 3
	ttylclose(tp, 0);	/* ??? */
	ttyclose(tp);		/* ??? */
	tp->t_state = 0;
a545 1

d547 1
a547 2
 * Open a zs serial port.  This interface may not be used to open
 * the keyboard and mouse ports. (XXX)
d550 1
a550 1
zsopen(dev, flags, mode, p)
a551 3
	int flags;
	int mode;
	struct proc *p;
d553 2
a554 69
	register struct tty *tp;
	register struct zs_chanstate *cs;
	struct zsinfo *zi;
	int unit = minor(dev), zs = unit >> 1, error, s;

#ifdef	DEBUG
	mon_printf("zs_open\n");
#endif
	if (zs >= zscd.cd_ndevs || (zi = zscd.cd_devs[zs]) == NULL ||
	    unit == ZS_KBD || unit == ZS_MOUSE)
		return (ENXIO);
	cs = &zi->zi_cs[unit & 1];
	tp = cs->cs_ttyp;
	s = spltty();
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = cs->cs_speed;
		(void) zsparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
		splx(s);
		return (EBUSY);
	}
	error = 0;
#ifdef	DEBUG
	mon_printf("wait for carrier...\n");
#endif
	for (;;) {
		register int rr0;

		/* loop, turning on the device, until carrier present */
		zs_modem(cs, 1);
		/* May never get status intr if carrier already on. -gwr */
		rr0 = cs->cs_zc->zc_csr;
		ZS_DELAY();
		if (rr0 & ZSRR0_DCD)
			tp->t_state |= TS_CARR_ON;
		if (cs->cs_softcar)
			tp->t_state |= TS_CARR_ON;
		if (flags & O_NONBLOCK || tp->t_cflag & CLOCAL ||
		    tp->t_state & TS_CARR_ON)
			break;
		tp->t_state |= TS_WOPEN;
		if (error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0)) {
			if (!(tp->t_state & TS_ISOPEN)) {
				zs_modem(cs, 0);
				tp->t_state &= ~TS_WOPEN;
				ttwakeup(tp);
			}
			splx(s);
			return error;
		}
	}
#ifdef	DEBUG
	mon_printf("...carrier %s\n",
			   (tp->t_state & TS_CARR_ON) ? "on" : "off");
#endif
	splx(s);
	if (error == 0)
		error = linesw[tp->t_line].l_open(dev, tp);
	if (error)
		zs_modem(cs, 0);
	return (error);
}
d556 2
a557 45
/*
 * Close a zs serial port.
 */
int
zsclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	register struct zs_chanstate *cs;
	register struct tty *tp;
	struct zsinfo *zi;
	int unit = minor(dev), s;

#ifdef	DEBUG
	mon_printf("zs_close\n");
#endif
	zi = zscd.cd_devs[unit >> 1];
	cs = &zi->zi_cs[unit & 1];
	tp = cs->cs_ttyp;
	linesw[tp->t_line].l_close(tp, flags);
	if (tp->t_cflag & HUPCL || tp->t_state & TS_WOPEN ||
	    (tp->t_state & TS_ISOPEN) == 0) {
		zs_modem(cs, 0);
		/* hold low for 1 second */
		(void) tsleep((caddr_t)cs, TTIPRI, ttclos, hz);
	}
	if (cs->cs_creg[5] & ZSWR5_BREAK)
	{
		s = splzs();
		cs->cs_preg[5] &= ~ZSWR5_BREAK;
		cs->cs_creg[5] &= ~ZSWR5_BREAK;
		ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
		splx(s);
	}
	ttyclose(tp);
#ifdef KGDB
	/* Reset the speed if we're doing kgdb on this port */
	if (cs->cs_kgdb) {
		tp->t_ispeed = tp->t_ospeed = kgdb_rate;
		(void) zsparam(tp, &tp->t_termios);
	}
#endif
	return (0);
d561 1
a561 1
 * Read/write zs serial port.
d563 2
a564 2
int
zsread(dev, uio, flags)
d566 1
a566 2
	struct uio *uio;
	int flags;
d568 1
a568 1
	register struct tty *tp = zs_tty[minor(dev)];
d570 1
a570 1
	return (linesw[tp->t_line].l_read(tp, uio, flags));
a572 7
int
zswrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	register struct tty *tp = zs_tty[minor(dev)];
d574 8
a581 2
	return (linesw[tp->t_line].l_write(tp, uio, flags));
}
d584 1
a584 9
 * ZS hardware interrupt.  Scan all ZS channels.  NB: we know here that
 * channels are kept in (A,B) pairs.
 *
 * Do just a little, then get out; set a software interrupt if more
 * work is needed.
 *
 * We deliberately ignore the vectoring Zilog gives us, and match up
 * only the number of `reset interrupt under service' operations, not
 * the order.
d586 2
a587 4
/* ARGSUSED */
int
zshard(intrarg)
	int intrarg;
d589 2
a590 30
	register struct zs_chanstate *a;
#define	b (a + 1)
	register volatile struct zschan *zc;
	register int rr3, intflags = 0, v, i;
	static int zsrint(struct zs_chanstate *, volatile struct zschan *);
	static int zsxint(struct zs_chanstate *, volatile struct zschan *);
	static int zssint(struct zs_chanstate *, volatile struct zschan *);

	for (a = zslist; a != NULL; a = b->cs_next) {
		rr3 = ZS_READ(a->cs_zc, 3);

		/* XXX - This should loop to empty the on-chip fifo. */
		if (rr3 & (ZSRR3_IP_A_RX|ZSRR3_IP_A_TX|ZSRR3_IP_A_STAT)) {
			intflags |= 2;
			zc = a->cs_zc;
			i = a->cs_rbput;
			if (rr3 & ZSRR3_IP_A_RX && (v = zsrint(a, zc)) != 0) {
				a->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
				intflags |= 1;
			}
			if (rr3 & ZSRR3_IP_A_TX && (v = zsxint(a, zc)) != 0) {
				a->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
				intflags |= 1;
			}
			if (rr3 & ZSRR3_IP_A_STAT && (v = zssint(a, zc)) != 0) {
				a->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
				intflags |= 1;
			}
			a->cs_rbput = i;
		}
d592 6
a597 30
		/* XXX - This should loop to empty the on-chip fifo. */
		if (rr3 & (ZSRR3_IP_B_RX|ZSRR3_IP_B_TX|ZSRR3_IP_B_STAT)) {
			intflags |= 2;
			zc = b->cs_zc;
			i = b->cs_rbput;
			if (rr3 & ZSRR3_IP_B_RX && (v = zsrint(b, zc)) != 0) {
				b->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
				intflags |= 1;
			}
			if (rr3 & ZSRR3_IP_B_TX && (v = zsxint(b, zc)) != 0) {
				b->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
				intflags |= 1;
			}
			if (rr3 & ZSRR3_IP_B_STAT && (v = zssint(b, zc)) != 0) {
				b->cs_rbuf[i++ & ZLRB_RING_MASK] = v;
				intflags |= 1;
			}
			b->cs_rbput = i;
		}
	}
#undef b
	if (intflags & 1) {
		if (zssoftpending == 0) {
			/* We are at splzs here, so no need to lock. */
			zssoftpending = ZSSOFT_PRI;
			isr_soft_request(ZSSOFT_PRI);
		}
	}
	return (intflags & 2);
}
d599 2
a600 806
static int
zsrint(cs, zc)
	register struct zs_chanstate *cs;
	register volatile struct zschan *zc;
{
	register int c;

	c = zc->zc_data;
	ZS_DELAY();

	if (cs->cs_conk) {
		register struct conk_state *conk = &zsconk_state;

		/*
		 * Check here for console abort function, so that we
		 * can abort even when interrupts are locking up the
		 * machine.
		 */
		if (c == KBD_RESET) {
			conk->conk_id = 1;	/* ignore next byte */
			conk->conk_l1 = 0;
		} else if (conk->conk_id)
			conk->conk_id = 0;	/* stop ignoring bytes */
		else if (c == KBD_L1)
			conk->conk_l1 = 1;	/* L1 went down */
		else if (c == (KBD_L1|KBD_UP))
			conk->conk_l1 = 0;	/* L1 went up */
		else if (c == KBD_A && conk->conk_l1) {
			zsabort();
			/* Debugger done.  Send L1-up in case X is running. */
			conk->conk_l1 = 0;
			c = (KBD_L1|KBD_UP);
		}
	}
#ifdef KGDB
	if (c == FRAME_START && cs->cs_kgdb && 
	    (cs->cs_ttyp->t_state & TS_ISOPEN) == 0) {
		zskgdb(cs->cs_unit);
		c = 0;
		goto clearit;
	}
#endif
	/* compose receive character and status */
	c <<= 8;
	c |= ZS_READ(zc, 1);
	c = ZRING_MAKE(ZRING_RINT, c);

clearit:
	/* clear receive error & interrupt condition */
	zc->zc_csr = ZSWR0_RESET_ERRORS;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_CLR_INTR;
	ZS_DELAY();
	return (c);
}

static int
zsxint(cs, zc)
	register struct zs_chanstate *cs;
	register volatile struct zschan *zc;
{
	register int i = cs->cs_tbc;

	if (i == 0) {
		zc->zc_csr = ZSWR0_RESET_TXINT;
		ZS_DELAY();
		zc->zc_csr = ZSWR0_CLR_INTR;
		ZS_DELAY();
		return (ZRING_MAKE(ZRING_XINT, 0));
	}
	cs->cs_tbc = i - 1;
	zc->zc_data = *cs->cs_tba++;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_CLR_INTR;
	ZS_DELAY();
	return (0);
}

static int
zssint(cs, zc)
	register struct zs_chanstate *cs;
	register volatile struct zschan *zc;
{
	register int rr0;

	rr0 = zc->zc_csr;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_RESET_STATUS;
	ZS_DELAY();
	zc->zc_csr = ZSWR0_CLR_INTR;
	ZS_DELAY();
	/*
	 * The chip's hardware flow control is, as noted in zsreg.h,
	 * busted---if the DCD line goes low the chip shuts off the
	 * receiver (!).  If we want hardware CTS flow control but do
	 * not have it, and carrier is now on, turn HFC on; if we have
	 * HFC now but carrier has gone low, turn it off.
	 */
	if (rr0 & ZSRR0_DCD) {
		if (cs->cs_ttyp->t_cflag & CCTS_OFLOW &&
		    (cs->cs_creg[3] & ZSWR3_HFC) == 0) {
			cs->cs_creg[3] |= ZSWR3_HFC;
			ZS_WRITE(zc, 3, cs->cs_creg[3]);
		}
	} else {
		if (cs->cs_creg[3] & ZSWR3_HFC) {
			cs->cs_creg[3] &= ~ZSWR3_HFC;
			ZS_WRITE(zc, 3, cs->cs_creg[3]);
		}
	}
	if ((rr0 & ZSRR0_BREAK) && cs->cs_brkabort) {
		/* Wait for end of break to avoid PROM abort. */
		do {
			rr0 = zc->zc_csr;
			ZS_DELAY();
		} while (rr0 & ZSRR0_BREAK);
		zsabort();
		return (0);
	}
	return (ZRING_MAKE(ZRING_SINT, rr0));
}

zsabort()
{
	/* XXX - Always available, but may be the PROM monitor. */
	Debugger();
}

#ifdef KGDB
/*
 * KGDB framing character received: enter kernel debugger.  This probably
 * should time out after a few seconds to avoid hanging on spurious input.
 */
zskgdb(unit)
	int unit;
{

	printf("zs%d%c: kgdb interrupt\n", unit >> 1, (unit & 1) + 'a');
	kgdb_connect(1);
}
#endif

/*
 * Print out a ring or fifo overrun error message.
 */
static void
zsoverrun(unit, ptime, what)
	int unit;
	long *ptime;
	char *what;
{

	if (*ptime != time.tv_sec) {
		*ptime = time.tv_sec;
		log(LOG_WARNING, "zs%d%c: %s overrun\n", unit >> 1,
		    (unit & 1) + 'a', what);
	}
}

/*
 * ZS software interrupt.  Scan all channels for deferred interrupts.
 */
int
zssoft(arg)
	int arg;
{
	register struct zs_chanstate *cs;
	register volatile struct zschan *zc;
	register struct linesw *line;
	register struct tty *tp;
	register int get, n, c, cc, unit, s;

	/* This is not the only ISR on this IPL. */
	if (zssoftpending == 0)
		return (0);

	/*
	 * The soft intr. bit will be set by zshard only if
	 * the variable zssoftpending is zero.  The order of
	 * these next two statements prevents our clearing
	 * the soft intr bit just after zshard has set it.
	 */
	isr_soft_clear(ZSSOFT_PRI);
	zssoftpending = 0;	/* Now zshard may set it again. */

	for (cs = zslist; cs != NULL; cs = cs->cs_next) {
		get = cs->cs_rbget;
again:
		n = cs->cs_rbput;	/* atomic */
		if (get == n)		/* nothing more on this line */
			continue;
		unit = cs->cs_unit;	/* set up to handle interrupts */
		zc = cs->cs_zc;
		tp = cs->cs_ttyp;
		line = &linesw[tp->t_line];
		/*
		 * Compute the number of interrupts in the receive ring.
		 * If the count is overlarge, we lost some events, and
		 * must advance to the first valid one.  It may get
		 * overwritten if more data are arriving, but this is
		 * too expensive to check and gains nothing (we already
		 * lost out; all we can do at this point is trade one
		 * kind of loss for another).
		 */
		n -= get;
		if (n > ZLRB_RING_SIZE) {
			zsoverrun(unit, &cs->cs_rotime, "ring");
			get += n - ZLRB_RING_SIZE;
			n = ZLRB_RING_SIZE;
		}
		while (--n >= 0) {
			/* race to keep ahead of incoming interrupts */
			c = cs->cs_rbuf[get++ & ZLRB_RING_MASK];
			switch (ZRING_TYPE(c)) {

			case ZRING_RINT:
				c = ZRING_VALUE(c);
				if (c & ZSRR1_DO)
					zsoverrun(unit, &cs->cs_fotime, "fifo");
				cc = c >> 8;
				if (c & ZSRR1_FE)
					cc |= TTY_FE;
				if (c & ZSRR1_PE)
					cc |= TTY_PE;
				/*
				 * this should be done through
				 * bstreams	XXX gag choke
				 */
				if (unit == ZS_KBD)
					kbd_rint(cc);
				else if (unit == ZS_MOUSE)
					ms_rint(cc);
				else
					line->l_rint(cc, tp);
				break;

			case ZRING_XINT:
				/*
				 * Transmit done: change registers and resume,
				 * or clear BUSY.
				 */
				if (cs->cs_heldchange) {
					s = splzs();
					c = zc->zc_csr;
					ZS_DELAY();
					if ((c & ZSRR0_DCD) == 0)
						cs->cs_preg[3] &= ~ZSWR3_HFC;
					bcopy((caddr_t)cs->cs_preg,
					    (caddr_t)cs->cs_creg, 16);
					zs_loadchannelregs(zc, cs->cs_creg);
					splx(s);
					cs->cs_heldchange = 0;
					if (cs->cs_heldtbc &&
					    (tp->t_state & TS_TTSTOP) == 0) {
						cs->cs_tbc = cs->cs_heldtbc - 1;
						zc->zc_data = *cs->cs_tba++;
						ZS_DELAY();
						goto again;
					}
				}
				tp->t_state &= ~TS_BUSY;
				if (tp->t_state & TS_FLUSH)
					tp->t_state &= ~TS_FLUSH;
				else
					ndflush(&tp->t_outq, cs->cs_tba -
						(caddr_t) tp->t_outq.c_cf);
				line->l_start(tp);
				break;

			case ZRING_SINT:
				/*
				 * Status line change.  HFC bit is run in
				 * hardware interrupt, to avoid locking
				 * at splzs here.
				 */
				c = ZRING_VALUE(c);
				if ((c ^ cs->cs_rr0) & ZSRR0_DCD) {
					cc = (c & ZSRR0_DCD) != 0;
					if (line->l_modem(tp, cc) == 0)
						zs_modem(cs, cc);
				}
				cs->cs_rr0 = c;
				break;

			default:
				log(LOG_ERR, "zs%d%c: bad ZRING_TYPE (%x)\n",
				    unit >> 1, (unit & 1) + 'a', c);
				break;
			}
		}
		cs->cs_rbget = get;
		goto again;
	}
	return (1);
}

int
zsioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = minor(dev);
	struct zsinfo *zi = zscd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &zi->zi_cs[unit & 1];
	register struct tty *tp = cs->cs_ttyp;
	register int error, s;

	error = linesw[tp->t_line].l_ioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {

	case TIOCSBRK:
		s = splzs();
		cs->cs_preg[5] |= ZSWR5_BREAK;
		cs->cs_creg[5] |= ZSWR5_BREAK;
		ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
		splx(s);
		break;

	case TIOCCBRK:
		s = splzs();
		cs->cs_preg[5] &= ~ZSWR5_BREAK;
		cs->cs_creg[5] &= ~ZSWR5_BREAK;
		ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
		splx(s);
		break;

	case TIOCGFLAGS: {
		int bits = 0;

		if (cs->cs_softcar)
			bits |= TIOCFLAG_SOFTCAR;
		if (cs->cs_creg[15] & ZSWR15_DCD_IE)
			bits |= TIOCFLAG_CLOCAL;
		if (cs->cs_creg[3] & ZSWR3_HFC)
			bits |= TIOCFLAG_CRTSCTS;
		*(int *)data = bits;
		break;
	}

	case TIOCSFLAGS: {
		int userbits, driverbits = 0;

		error = suser(p->p_ucred, &p->p_acflag);
		if (error != 0)
			return (EPERM);

		userbits = *(int *)data;

		/*
		 * can have `local' or `softcar', and `rtscts' or `mdmbuf'
		 * defaulting to software flow control.
		 */
		if (userbits & TIOCFLAG_SOFTCAR && userbits & TIOCFLAG_CLOCAL)
			return(EINVAL);
		if (userbits & TIOCFLAG_MDMBUF)	/* don't support this (yet?) */
			return(ENXIO);

		s = splzs();
		if ((userbits & TIOCFLAG_SOFTCAR) ||
			(cs->cs_zc == zs_conschan))
		{
			cs->cs_softcar = 1;	/* turn on softcar */
			cs->cs_preg[15] &= ~ZSWR15_DCD_IE; /* turn off dcd */
			cs->cs_creg[15] &= ~ZSWR15_DCD_IE;
			ZS_WRITE(cs->cs_zc, 15, cs->cs_creg[15]);
		} else if (userbits & TIOCFLAG_CLOCAL) {
			cs->cs_softcar = 0; 	/* turn off softcar */
			cs->cs_preg[15] |= ZSWR15_DCD_IE; /* turn on dcd */
			cs->cs_creg[15] |= ZSWR15_DCD_IE;
			ZS_WRITE(cs->cs_zc, 15, cs->cs_creg[15]);
			tp->t_termios.c_cflag |= CLOCAL;
		}
		if (userbits & TIOCFLAG_CRTSCTS) {
			cs->cs_preg[15] |= ZSWR15_CTS_IE;
			cs->cs_creg[15] |= ZSWR15_CTS_IE;
			ZS_WRITE(cs->cs_zc, 15, cs->cs_creg[15]);
			cs->cs_preg[3] |= ZSWR3_HFC;
			cs->cs_creg[3] |= ZSWR3_HFC;
			ZS_WRITE(cs->cs_zc, 3, cs->cs_creg[3]);
			tp->t_termios.c_cflag |= CRTSCTS;
		} else {
			/* no mdmbuf, so we must want software flow control */
			cs->cs_preg[15] &= ~ZSWR15_CTS_IE;
			cs->cs_creg[15] &= ~ZSWR15_CTS_IE;
			ZS_WRITE(cs->cs_zc, 15, cs->cs_creg[15]);
			cs->cs_preg[3] &= ~ZSWR3_HFC;
			cs->cs_creg[3] &= ~ZSWR3_HFC;
			ZS_WRITE(cs->cs_zc, 3, cs->cs_creg[3]);
			tp->t_termios.c_cflag &= ~CRTSCTS;
		}
		splx(s);
		break;
	}

	case TIOCSDTR:
		zs_modem(cs, 1);
		break;
	case TIOCCDTR:
		zs_modem(cs, 0);
		break;

	case TIOCMSET:
	case TIOCMBIS:
	case TIOCMBIC:
	case TIOCMGET:
	default:
		return (ENOTTY);
	}
	return (0);
}

/*
 * Start or restart transmission.
 */
static void
zsstart(tp)
	register struct tty *tp;
{
	register struct zs_chanstate *cs;
	register int s, nch;
	int unit = minor(tp->t_dev);
	struct zsinfo *zi = zscd.cd_devs[unit >> 1];

	cs = &zi->zi_cs[unit & 1];
	s = spltty();

	/*
	 * If currently active or delaying, no need to do anything.
	 */
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
		goto out;

	/*
	 * If there are sleepers, and output has drained below low
	 * water mark, awaken.
	 */
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}

	nch = ndqb(&tp->t_outq, 0);	/* XXX */
	if (nch) {
		register char *p = tp->t_outq.c_cf;

		/* mark busy, enable tx done interrupts, & send first byte */
		tp->t_state |= TS_BUSY;
		(void) splzs();
		cs->cs_preg[1] |= ZSWR1_TIE;
		cs->cs_creg[1] |= ZSWR1_TIE;
		ZS_WRITE(cs->cs_zc, 1, cs->cs_creg[1]);
		cs->cs_zc->zc_data = *p;
		ZS_DELAY();
		cs->cs_tba = p + 1;
		cs->cs_tbc = nch - 1;
	} else {
		/*
		 * Nothing to send, turn off transmit done interrupts.
		 * This is useful if something is doing polled output.
		 */
		(void) splzs();
		cs->cs_preg[1] &= ~ZSWR1_TIE;
		cs->cs_creg[1] &= ~ZSWR1_TIE;
		ZS_WRITE(cs->cs_zc, 1, cs->cs_creg[1]);
	}
out:
	splx(s);
}

/*
 * Stop output, e.g., for ^S or output flush.
 */
void
zsstop(tp, flag)
	register struct tty *tp;
	int flag;
{
	register struct zs_chanstate *cs;
	register int s, unit = minor(tp->t_dev);
	struct zsinfo *zi = zscd.cd_devs[unit >> 1];

	cs = &zi->zi_cs[unit & 1];
	s = splzs();
	if (tp->t_state & TS_BUSY) {
		/*
		 * Device is transmitting; must stop it.
		 */
		cs->cs_tbc = 0;
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
}

/*
 * Set ZS tty parameters from termios.
 */
static int
zsparam(tp, t)
	register struct tty *tp;
	register struct termios *t;
{
	int unit = minor(tp->t_dev);
	struct zsinfo *zi = zscd.cd_devs[unit >> 1];
	register struct zs_chanstate *cs = &zi->zi_cs[unit & 1];
	register int tmp, tmp5, cflag, s;

	/*
	 * Because PCLK is only run at 4.9 MHz, the fastest we
	 * can go is 51200 baud (this corresponds to TC=1).
	 * This is somewhat unfortunate as there is no real
	 * reason we should not be able to handle higher rates.
	 */
	tmp = t->c_ospeed;
	if (tmp < 0 || (t->c_ispeed && t->c_ispeed != tmp))
		return (EINVAL);
	if (tmp == 0) {
		/* stty 0 => drop DTR and RTS */
		zs_modem(cs, 0);
		return (0);
	}
	tmp = BPS_TO_TCONST(PCLK / 16, tmp);
	if (tmp < 2)
		return (EINVAL);

	cflag = t->c_cflag;
	tp->t_ispeed = tp->t_ospeed = TCONST_TO_BPS(PCLK / 16, tmp);
	tp->t_cflag = cflag;

	/*
	 * Block interrupts so that state will not
	 * be altered until we are done setting it up.
	 */
	s = splzs();
	bcopy(zs_init_reg, cs->cs_preg, 16);
	cs->cs_preg[12] = tmp;
	cs->cs_preg[13] = tmp >> 8;
	cs->cs_preg[9] |= ZSWR9_MASTER_IE;
	switch (cflag & CSIZE) {
	case CS5:
		tmp = ZSWR3_RX_5;
		tmp5 = ZSWR5_TX_5;
		break;
	case CS6:
		tmp = ZSWR3_RX_6;
		tmp5 = ZSWR5_TX_6;
		break;
	case CS7:
		tmp = ZSWR3_RX_7;
		tmp5 = ZSWR5_TX_7;
		break;
	case CS8:
	default:
		tmp = ZSWR3_RX_8;
		tmp5 = ZSWR5_TX_8;
		break;
	}

	/*
	 * Output hardware flow control on the chip is horrendous: if
	 * carrier detect drops, the receiver is disabled.  Hence we
	 * can only do this when the carrier is on.
	 */
	tmp |= ZSWR3_RX_ENABLE;
	if (cflag & CCTS_OFLOW) {
		if (cs->cs_zc->zc_csr & ZSRR0_DCD)
			tmp |= ZSWR3_HFC;
		ZS_DELAY();
	}

	cs->cs_preg[3] = tmp;
	cs->cs_preg[5] = tmp5 | ZSWR5_TX_ENABLE | ZSWR5_DTR | ZSWR5_RTS;

	tmp = ZSWR4_CLK_X16 | (cflag & CSTOPB ? ZSWR4_TWOSB : ZSWR4_ONESB);
	if ((cflag & PARODD) == 0)
		tmp |= ZSWR4_EVENP;
	if (cflag & PARENB)
		tmp |= ZSWR4_PARENB;
	cs->cs_preg[4] = tmp;

	/*
	 * If nothing is being transmitted, set up new current values,
	 * else mark them as pending.
	 */
	if (cs->cs_heldchange == 0) {
		if (cs->cs_ttyp->t_state & TS_BUSY) {
			cs->cs_heldtbc = cs->cs_tbc;
			cs->cs_tbc = 0;
			cs->cs_heldchange = 1;
		} else {
			bcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);
			zs_loadchannelregs(cs->cs_zc, cs->cs_creg);
		}
	}
	splx(s);
	return (0);
}

/*
 * Raise or lower modem control (DTR/RTS) signals.  If a character is
 * in transmission, the change is deferred.
 */
static void
zs_modem(cs, onoff)
	struct zs_chanstate *cs;
	int onoff;
{
	int s, bis, and;

	if (onoff) {
		bis = ZSWR5_DTR | ZSWR5_RTS;
		and = ~0;
	} else {
		bis = 0;
		and = ~(ZSWR5_DTR | ZSWR5_RTS);
	}
	s = splzs();
	cs->cs_preg[5] = (cs->cs_preg[5] | bis) & and;
	if (cs->cs_heldchange == 0) {
		if (cs->cs_ttyp->t_state & TS_BUSY) {
			cs->cs_heldtbc = cs->cs_tbc;
			cs->cs_tbc = 0;
			cs->cs_heldchange = 1;
		} else {
			cs->cs_creg[5] = (cs->cs_creg[5] | bis) & and;
			ZS_WRITE(cs->cs_zc, 5, cs->cs_creg[5]);
		}
	}
	splx(s);
}

/*
 * Write the given register set to the given zs channel in the proper order.
 * The channel must not be transmitting at the time.  The receiver will
 * be disabled for the time it takes to write all the registers.
 */
static void
zs_loadchannelregs(zc, reg)
	volatile struct zschan *zc;
	u_char *reg;
{
	int i;

	zc->zc_csr = ZSM_RESET_ERR;	/* reset error condition */
	ZS_DELAY();

#if 1	/* XXX - Is this really a good idea? -gwr */
	i = zc->zc_data;		/* drain fifo */
	ZS_DELAY();
	i = zc->zc_data;
	ZS_DELAY();
	i = zc->zc_data;
	ZS_DELAY();
#endif

	/* baud clock divisor, stop bits, parity */
	ZS_WRITE(zc, 4, reg[4]);

	/* misc. TX/RX control bits */
	ZS_WRITE(zc, 10, reg[10]);

	/* char size, enable (RX/TX) */
	ZS_WRITE(zc, 3, reg[3] & ~ZSWR3_RX_ENABLE);
	ZS_WRITE(zc, 5, reg[5] & ~ZSWR5_TX_ENABLE);

	/* interrupt enables: TX, TX, STATUS */
	ZS_WRITE(zc, 1, reg[1]);

	/* interrupt vector */
	ZS_WRITE(zc, 2, reg[2]);

	/* master interrupt control */
	ZS_WRITE(zc, 9, reg[9]);

	/* clock mode control */
	ZS_WRITE(zc, 11, reg[11]);

	/* baud rate (lo/hi) */
	ZS_WRITE(zc, 12, reg[12]);
	ZS_WRITE(zc, 13, reg[13]);

	/* Misc. control bits */
	ZS_WRITE(zc, 14, reg[14]);

	/* which lines cause status interrupts */
	ZS_WRITE(zc, 15, reg[15]);

	/* char size, enable (RX/TX)*/
	ZS_WRITE(zc, 3, reg[3]);
	ZS_WRITE(zc, 5, reg[5]);
}

static u_char
zs_read(zc, reg)
	volatile struct zschan *zc;
	u_char reg;
{
	u_char val;

	zc->zc_csr = reg;
	ZS_DELAY();
	val = zc->zc_csr;
	ZS_DELAY();
	return val;
}

static u_char
zs_write(zc, reg, val)
	volatile struct zschan *zc;
	u_char reg, val;
{
	zc->zc_csr = reg;
	ZS_DELAY();
	zc->zc_csr = val;
	ZS_DELAY();
	return val;
}

#ifdef KGDB
/*
 * Get a character from the given kgdb channel.  Called at splhigh().
 * XXX - Add delays, or combine with zscngetc()...
 */
static int
zs_kgdb_getc(arg)
	void *arg;
{
	register volatile struct zschan *zc = (volatile struct zschan *)arg;
	register int c, rr0;

	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_RX_READY) == 0);
	c = zc->zc_data;
	ZS_DELAY();
	return (c);
}

/*
 * Put a character to the given kgdb channel.  Called at splhigh().
 */
static void
zs_kgdb_putc(arg, c)
	void *arg;
	int c;
{
	register volatile struct zschan *zc = (volatile struct zschan *)arg;
	register int c, rr0;

	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_TX_READY) == 0);
	zc->zc_data = c;
	ZS_DELAY();
}

/*
 * Set up for kgdb; called at boot time before configuration.
 * KGDB interrupts will be enabled later when zs0 is configured.
 */
void
zs_kgdb_init()
{
	volatile struct zsdevice *addr;
	volatile struct zschan *zc;
	int unit, zs;

	if (major(kgdb_dev) != ZSMAJOR)
		return;
	unit = minor(kgdb_dev);
	/*
	 * Unit must be 0 or 1 (zs0).
	 */
	if ((unsigned)unit >= ZS_KBD) {
		printf("zs_kgdb_init: bad minor dev %d\n", unit);
		return;
	}
	zs = unit >> 1;
	unit &= 1;

	if (zsaddr[0] == NULL)
		panic("kbdb_attach: zs0 not yet mapped");
	addr = zsaddr[0];

	zc = (unit == 0) ?
		&addr->zs_chan[ZS_CHAN_A] :
		&addr->zs_chan[ZS_CHAN_B];
	zs_kgdb_savedspeed = zs_getspeed(zc);
	printf("zs_kgdb_init: attaching zs%d%c at %d baud\n",
	    zs, unit + 'a', kgdb_rate);
	zs_reset(zc, 1, kgdb_rate);
	kgdb_attach(zs_kgdb_getc, zs_kgdb_putc, (void *)zc);
a601 1
#endif /* KGDB */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
