head	1.14;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.8
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.6
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.10
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.8
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.6
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2002.12.31.16.35.40;	author miod;	state dead;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.28.22.03.01;	author miod;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	98.09.16.22.41.19;	author jason;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	97.08.08.08.27.39;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.01.16.04.03.49;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.01.07.23.36.10;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.12.31.06.12.48;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.07.54.55;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.10.11.23.06.01;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.16.02.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.05.26.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.01.17.23.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.52;	author deraadt;	state Exp;
branches;
next	;

1.11.8.1
date	2001.05.14.21.37.26;	author niklas;	state Exp;
branches;
next	1.11.8.2;

1.11.8.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.11.8.3;

1.11.8.3
date	2003.03.27.23.52.17;	author niklas;	state dead;
branches;
next	;

1.12.8.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2003.05.19.21.49.44;	author tedu;	state dead;
branches;
next	;


desc
@@


1.14
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: if_le.c,v 1.13 2002/03/14 01:26:46 millert Exp $	*/
/*	$NetBSD: if_le.c,v 1.33 1996/11/20 18:56:52 gwr Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass and Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <net/if_media.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/dvma.h>
#include <machine/obio.h>
#include <machine/idprom.h>

#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>

/*
 * LANCE registers.
 * The real stuff is in dev/ic/am7990reg.h
 */
struct lereg1 {
	volatile u_int16_t	ler1_rdp;	/* data port */
	volatile u_int16_t	ler1_rap;	/* register select port */
};

/*
 * Ethernet software status per interface.
 * The real stuff is in dev/ic/am7990var.h
 */
struct	le_softc {
	struct	am7990_softc sc_am7990;	/* glue to MI code */

	struct	lereg1 *sc_r1;		/* LANCE registers */
};

static int	le_match(struct device *, void *, void *);
static void	le_attach(struct device *, struct device *, void *);

struct cfattach le_ca = {
	sizeof(struct le_softc), le_match, le_attach
};

hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);

hide void
lewrcsr(sc, port, val)
	struct am7990_softc *sc;
	u_int16_t port, val;
{
	register struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;

	ler1->ler1_rap = port;
	ler1->ler1_rdp = val;
}

hide u_int16_t
lerdcsr(sc, port)
	struct am7990_softc *sc;
	u_int16_t port;
{
	register struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
	u_int16_t val;

	ler1->ler1_rap = port;
	val = ler1->ler1_rdp;
	return (val);
}

int
le_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct confargs *ca = aux;

	/* Make sure there is something there... */
	if (bus_peek(ca->ca_bustype, ca->ca_paddr, 1) == -1)
		return (0);

	/* Default interrupt priority. */
	if (ca->ca_intpri == -1)
		ca->ca_intpri = 3;

	return (1);
}

void
le_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct le_softc *lesc = (struct le_softc *)self;
	struct am7990_softc *sc = &lesc->sc_am7990;
	struct confargs *ca = aux;

	lesc->sc_r1 = (struct lereg1 *)
	    obio_alloc(ca->ca_paddr, sizeof(struct lereg1));

	sc->sc_memsize = 0x4000;	/* 16K */
	sc->sc_mem = dvma_malloc(sc->sc_memsize);
	sc->sc_addr = (u_long)sc->sc_mem & 0xffffff;
	sc->sc_conf3 = LE_C3_BSWP;

	idprom_etheraddr(sc->sc_arpcom.ac_enaddr);

	sc->sc_copytodesc = am7990_copytobuf_contig;
	sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
	sc->sc_copytobuf = am7990_copytobuf_contig;
	sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
	sc->sc_zerobuf = am7990_zerobuf_contig;

	sc->sc_rdcsr = lerdcsr;
	sc->sc_wrcsr = lewrcsr;
	sc->sc_hwreset = NULL;
	sc->sc_hwinit = NULL;

	am7990_config(sc);

	/* Install interrupt handler. */
	isr_add_autovect(am7990_intr, (void *)sc, ca->ca_intpri);
}
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 2000/08/28 22:03:01 miod Exp $	*/
@


1.12
log
@Allocate memory for the correct size, not some forgotten constant
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.11 1998/09/16 22:41:19 jason Exp $	*/
d86 2
a87 2
static int	le_match __P((struct device *, void *, void *));
static void	le_attach __P((struct device *, struct device *, void *));
d93 2
a94 2
hide void lewrcsr __P((struct am7990_softc *, u_int16_t, u_int16_t));
hide u_int16_t lerdcsr __P((struct am7990_softc *, u_int16_t));
@


1.12.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 2000/08/28 22:03:01 miod Exp $	*/
d86 2
a87 2
static int	le_match(struct device *, void *, void *);
static void	le_attach(struct device *, struct device *, void *);
d93 2
a94 2
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
@


1.12.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12.8.1 2002/06/11 03:39:01 art Exp $	*/
@


1.11
log
@o if_media'fied am7990
o if_media'fied sun4m le.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.10 1997/08/08 08:27:39 downsj Exp $	*/
d148 1
a148 1
	    obio_alloc(ca->ca_paddr, OBIO_AMD_ETHER_SIZE);
@


1.11.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 2000/08/28 22:03:01 miod Exp $	*/
d148 1
a148 1
	    obio_alloc(ca->ca_paddr, sizeof(struct lereg1));
@


1.11.8.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 2
a87 2
static int	le_match(struct device *, void *, void *);
static void	le_attach(struct device *, struct device *, void *);
d93 2
a94 2
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
@


1.11.8.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.11.8.2 2002/03/28 11:26:45 niklas Exp $	*/
@


1.10
log
@Initialize hwreset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.9 1997/01/16 04:03:49 kstailey Exp $	*/
d55 2
@


1.9
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d163 1
@


1.8
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
a58 1
#include <machine/isr.h>
d92 1
a92 1
hide u_int16_t lerdcsr __P((struct am7990_softc *, u_int16_t));  
d116 1
a116 1
} 
a122 1
	struct cfdata *cf = vcf;
a142 1
	struct cfdata *cf = self->dv_cfdata;
@


1.7
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.34 1996/12/17 21:10:48 gwr Exp $	*/
d58 1
d144 1
@


1.6
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.33 1996/11/20 18:56:52 gwr Exp $	*/
a57 1
#include <machine/isr.h>
a142 1
	struct cfdata *cf = self->dv_cfdata;
@


1.5
log
@sync + our changes
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.29 1996/05/07 01:32:31 thorpej Exp $	*/
d4 2
a5 3
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
d7 2
a8 2
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
d20 5
a24 5
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d26 11
a36 13
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
d65 18
a82 2
#include <sun3/dev/if_lereg.h>
#include <sun3/dev/if_levar.h>
a124 1
	int pa, x;
d126 2
a127 9
	/*
	 * OBIO match functions may be called for every possible
	 * physical address, so match only our physical address.
	 */
	if ((pa = cf->cf_paddr) == -1) {
		/* Use our default PA. */
		pa = OBIO_AMD_ETHER;
	}
	if (pa != ca->ca_paddr)
d130 5
a134 3
	/* The peek returns -1 on bus error. */
	x = bus_peek(ca->ca_bustype, ca->ca_paddr, 1);
	return (x != -1);
a145 6
	int intpri;

	/* Default interrupt level. */
	if ((intpri = cf->cf_intpri) == -1)
		intpri = 3;
	printf(" level %d", intpri);
d170 1
a170 1
	isr_add_autovect(am7990_intr, (void *)sc, intpri);
@


1.4
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.28 1996/04/22 02:25:54 christos Exp $	*/
a64 2
#include <sun3/dev/if_lereg.h>
#include <sun3/dev/if_levar.h>
a65 1
#define	LE_NEED_BUF_CONTIG
d68 2
a69 2
#define	LE_SOFTC(unit)	le_cd.cd_devs[unit]
#define	LE_DELAY(x)	DELAY(x)
a72 1
int	leintr __P((void *));
d78 2
a79 9
struct	cfdriver le_cd = {
	NULL, "le", DV_IFNET
};

integrate void
lehwinit(sc)
	struct le_softc *sc;
{
}
d81 1
a81 1
integrate void
d83 1
a83 1
	struct le_softc *sc;
d86 1
a86 1
	register struct lereg1 *ler1 = sc->sc_r1;
d92 1
a92 1
integrate u_int16_t
d94 1
a94 1
	struct le_softc *sc;
d97 1
a97 1
	register struct lereg1 *ler1 = sc->sc_r1;
d135 2
a136 1
	struct le_softc *sc = (void *)self;
d146 1
a146 1
	sc->sc_r1 = (struct lereg1 *)
d162 5
a166 2
	sc->sc_arpcom.ac_if.if_name = le_cd.cd_name;
	leconfig(sc);
d169 1
a169 24
	isr_add_autovect(leintr, (void *)sc, intpri);
}

/*
 * Compare two Ether/802 addresses for equality, inlined and
 * unrolled for speed.  I'd love to have an inline assembler
 * version of this...   XXX: Who wanted that? mycroft?
 * I wrote one, but the following is just as efficient.
 * This expands to 10 short m68k instructions! -gwr
 * Note: use this like bcmp()
 */
static inline u_short
ether_cmp(one, two)
	u_char *one, *two;
{
	register u_short *a = (u_short *) one;
	register u_short *b = (u_short *) two;
	register u_short diff;

	diff  = *a++ - *b++;
	diff |= *a++ - *b++;
	diff |= *a++ - *b++;

	return (diff);
a170 4

#define	ETHER_CMP ether_cmp

#include <dev/ic/am7990.c>
@


1.3
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.24 1995/12/10 08:46:05 mycroft Exp $	*/
d71 1
a71 1
#define	LE_SOFTC(unit)	lecd.cd_devs[unit]
d74 2
a75 2
int	lematch __P((struct device *, void *, void *));
void	leattach __P((struct device *, struct device *, void *));
d78 6
a83 2
struct	cfdriver lecd = {
	NULL, "le", lematch, leattach, DV_IFNET, sizeof(struct le_softc)
d87 6
d117 1
a117 1
lematch(parent, match, aux)
d119 1
a119 1
	void *match, *aux;
d121 1
d123 1
a123 1
	int x;
d125 10
a134 4
	if (ca->ca_paddr == -1)
		ca->ca_paddr = OBIO_AMD_ETHER;
	if (ca->ca_intpri == -1)
		ca->ca_intpri = 3;
d142 1
a142 1
leattach(parent, self, aux)
d147 1
d149 6
d158 4
a161 1
	sc->sc_mem = dvma_malloc(MEMSIZE);
a162 2
	sc->sc_addr = (u_long)sc->sc_mem & 0xffffff;
	sc->sc_memsize = MEMSIZE;
d166 5
a170 5
	sc->sc_copytodesc = copytobuf_contig;
	sc->sc_copyfromdesc = copyfrombuf_contig;
	sc->sc_copytobuf = copytobuf_contig;
	sc->sc_copyfrombuf = copyfrombuf_contig;
	sc->sc_zerobuf = zerobuf_contig;
d172 1
a172 1
	sc->sc_arpcom.ac_if.if_name = lecd.cd_name;
d176 24
a199 1
	isr_add_autovect(leintr, (void *)sc, ca->ca_intpri);
d201 2
@


1.2
log
@LANCE_REVC_BUG fixes
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.22.2.1 1995/10/27 18:43:36 gwr Exp $	*/
d3 4
a6 2
/*
 * LANCE Ethernet driver
d8 2
a9 2
 * Copyright (c) 1995 Gordon W. Ross
 * Copyright (c) 1994 Charles Hannum.
d11 29
a39 6
 * Copyright (C) 1993, Paul Richards. This software may be used, modified,
 *   copied, distributed, and sold, in both source and binary form provided
 *   that the above copyright and these terms are retained. Under no
 *   circumstances is the author responsible for the proper functioning
 *   of this software, nor does the author assume any responsibility
 *   for damages incurred with its use.
a45 2
#include <sys/errno.h>
#include <sys/ioctl.h>
d47 1
a48 1
#include <sys/syslog.h>
a51 3
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/netisr.h>
a54 3
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
a57 10
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

d60 17
a76 39

/*
 * XXX - Be warned: Most Sun3/50 and many Sun3/60 machines have
 * the LANCE Rev. C bug, which we MUST avoid or suffer likely
 * NFS file corruption and worse!  That said, if you are SURE
 * your LANCE is OK, you can remove this work-around using:
 *  	options LANCE_REVC_BUG=0
 * in your kernel config file.
 */
#ifndef	LANCE_REVC_BUG
#define	LANCE_REVC_BUG 1
#endif

/* #define	LEDEBUG	1 */

#include "if_lereg.h"
#include "if_le.h"
#include "if_le_subr.h"

#define	RMD_BITS "\20\20own\17err\16fram\15oflo\14crc\13rbuf\12stp\11enp"

#define	ETHER_MIN_LEN	64
#define	ETHER_MAX_LEN	1518

/*
 * The lance has only 24 address lines.  When it accesses memory,
 * the high address lines are hard-wired to 0xFF, so we must:
 * (1) put what we want the LANCE to see above 0xFF000000, and
 * (2) mask our CPU addresses down to 24 bits for the LANCE.
 */
#define	LANCE_ADDR(sc,x)	((u_int)(x) & 0xFFffff)

#ifdef PACKETSTATS
long	lexpacketsizes[LEMTU+1];
long	lerpacketsizes[LEMTU+1];
#endif

/* autoconfiguration driver */
void	le_attach(struct device *, struct device *, void *);
d79 1
a79 2
	NULL, "le", le_md_match, le_attach,
	DV_IFNET, sizeof(struct le_softc),
d82 2
a83 25
int leioctl __P((struct ifnet *, u_long, caddr_t));
void lestart __P((struct ifnet *));
void lewatchdog __P((/* short */));
static inline void lewrcsr __P((/* struct le_softc *, u_short, u_short */));
static inline u_short lerdcsr __P((/* struct le_softc *, u_short */));
void leinit __P((struct le_softc *));
void lememinit __P((struct le_softc *));
void lereset __P((struct le_softc *));
void lestop __P((struct le_softc *));
void letint __P((struct le_softc *));
void lerint __P((struct le_softc *));
void leread __P((struct le_softc *, u_char *, int));
struct mbuf *leget __P((u_char *, int, struct ifnet *));
void lesetladrf __P((struct arpcom *, u_long *));
#ifdef LEDEBUG
void recv_print __P((struct le_softc *, int));
void xmit_print __P((struct le_softc *, int));
#endif

/*
 * Inline routines to read and write the LANCE registers.
 */

static inline void
lewrcsr(sc, regnum, value)
d85 1
a85 2
	u_short regnum;
	u_short value;
d87 1
a87 1
	volatile struct le_regs *regs = sc->sc_regs;
d89 2
a90 2
	regs->lereg_addr = regnum;
	regs->lereg_data = value;
d93 2
a94 2
static inline u_short
lerdcsr(sc, regnum)
d96 1
a96 1
	u_short regnum;
d98 2
a99 2
	volatile struct le_regs *regs = sc->sc_regs;
	u_short value;
d101 3
a103 4
	regs->lereg_addr = regnum;
	value = regs->lereg_data;
	
	return (value);
d106 4
a109 13
/*
 * The probe is done in if_le_subr.c:if_md_match()
 */

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.  We get the ethernet address here.
 */
void
le_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a110 1
	struct le_softc *sc = (void *)self;
d112 1
a112 22
	struct ifnet *ifp = &sc->sc_if;
	int pri;
	u_int a;

	le_md_attach(parent, self, aux);
	printf(" hwaddr %s\n", ether_sprintf(sc->sc_enaddr));

	/*
	 * Initialize and attach S/W interface
	 */
	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = lecd.cd_name;
	ifp->if_start = lestart;
	ifp->if_ioctl = leioctl;
	ifp->if_watchdog = lewatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;

#if LANCE_REVC_BUG == 0
	/* The work-around precludes multicast... */
	ifp->if_flags |= IFF_MULTICAST;
#endif
d114 4
a117 3
	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);
d119 3
a121 3
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
d125 3
a127 2
lereset(sc)
	struct le_softc *sc;
d129 2
d132 6
a137 544
	leinit(sc);
}

void
lewatchdog(unit)
	short unit;
{
	struct le_softc *sc = lecd.cd_devs[unit];

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_if.if_oerrors;
	lereset(sc);
}

/* LANCE initialization block set up. */
void
lememinit(sc)
	register struct le_softc *sc;
{
	struct ifnet *ifp = &sc->sc_if;
	int i;
	void *mem;
	u_long a;

	/*
	 * At this point we assume that the memory allocated to the Lance is
	 * quadword aligned.  If it isn't then the initialisation is going
	 * fail later on.
	 */
	mem = sc->sc_mem;

	sc->sc_init = mem;
#if NBPFILTER > 0
	if (ifp->if_flags & IFF_PROMISC)
		sc->sc_init->mode = LE_NORMAL | LE_PROM;
	else
#endif
		sc->sc_init->mode = LE_NORMAL;

	/* Set the Ethernet address (have to byte-swap) */
	for (i = 0; i < 6; i += 2) {
		sc->sc_init->padr[i] = sc->sc_enaddr[i+1];
		sc->sc_init->padr[i+1] = sc->sc_enaddr[i];
	}
	lesetladrf(&sc->sc_ac, sc->sc_init->ladrf);
	mem += sizeof(struct init_block);

	sc->sc_rd = mem;
	a = LANCE_ADDR(sc, mem);
	sc->sc_init->rdra = a;
	sc->sc_init->rlen = ((a >> 16) & 0xff) | (RLEN << 13);
	mem += NRBUF * sizeof(struct mds);

	sc->sc_td = mem;
	a = LANCE_ADDR(sc, mem);
	sc->sc_init->tdra = a;
	sc->sc_init->tlen = ((a >> 16) & 0xff) | (TLEN << 13);
	mem += NTBUF * sizeof(struct mds);

	/* 
	 * Set up receive ring descriptors.
	 */
	sc->sc_rbuf = mem;
	for (i = 0; i < NRBUF; i++) {
		a = LANCE_ADDR(sc, mem);
		sc->sc_rd[i].addr = a;
		sc->sc_rd[i].flags = ((a >> 16) & 0xff) | LE_OWN;
		sc->sc_rd[i].bcnt = -BUFSIZE;
		sc->sc_rd[i].mcnt = 0;
		mem += BUFSIZE;
	}

	/* 
	 * Set up transmit ring descriptors.
	 */
	sc->sc_tbuf = mem;
	for (i = 0; i < NTBUF; i++) {
		a = LANCE_ADDR(sc, mem);
		sc->sc_td[i].addr = a;
		sc->sc_td[i].flags= ((a >> 16) & 0xff);
		sc->sc_td[i].bcnt = 0xf000;
		sc->sc_td[i].mcnt = 0;
		mem += BUFSIZE;
	}

#ifdef	DIAGNOSTIC
	if (mem > (sc->sc_mem + MEMSIZE))
		panic("lememinit: used 0x%x\n", mem - sc->sc_mem);
#endif
}

void
lestop(sc)
	struct le_softc *sc;
{

	lewrcsr(sc, 0, LE_STOP);
}

/*
 * Initialization of interface; set up initialization block
 * and transmit/receive descriptor rings.
 */
void
leinit(sc)
	register struct le_softc *sc;
{
	struct ifnet *ifp = &sc->sc_if;
	int s;
	register int timo;
	u_long a;

	s = splimp();

	/* Don't want to get in a weird state. */
	lewrcsr(sc, 0, LE_STOP);
	delay(100);

	sc->sc_last_rd = sc->sc_last_td = sc->sc_no_td = 0;

	/* Set up LANCE init block. */
	lememinit(sc);

	/* Set byte swapping etc. */
	lewrcsr(sc, 3, LE_CONF3);

	/* Give LANCE the physical address of its init block. */
	a = LANCE_ADDR(sc, sc->sc_init);
	lewrcsr(sc, 1, a);
	lewrcsr(sc, 2, (a >> 16) & 0xff);

	/* Try to initialize the LANCE. */
	delay(100);
	lewrcsr(sc, 0, LE_INIT);

	/* Wait for initialization to finish. */
	for (timo = 1000; timo; timo--)
		if (lerdcsr(sc, 0) & LE_IDON)
			break;

	if (lerdcsr(sc, 0) & LE_IDON) {
		/* Start the LANCE. */
		lewrcsr(sc, 0, LE_INEA | LE_STRT | LE_IDON);
		ifp->if_flags |= IFF_RUNNING;
		ifp->if_flags &= ~IFF_OACTIVE;
		lestart(ifp);
	} else
		printf("%s: card failed to initialize\n", sc->sc_dev.dv_xname);
	
	(void) splx(s);
}

/*
 * Controller interrupt.
 */
int
leintr(vsc)
	void *vsc;
{
	register struct le_softc *sc = vsc;
	register u_short isr;

	isr = lerdcsr(sc, 0);
#ifdef LEDEBUG
	if (sc->sc_debug)
		printf("%s: leintr entering with isr=%04x\n",
		    sc->sc_dev.dv_xname, isr);
#endif
	if ((isr & LE_INTR) == 0)
		return 0;

	do {
		lewrcsr(sc, 0,
		    isr & (LE_INEA | LE_BABL | LE_MISS | LE_MERR |
			   LE_RINT | LE_TINT | LE_IDON));
		if (isr & (LE_BABL | LE_CERR | LE_MISS | LE_MERR)) {
			if (isr & LE_BABL) {
				printf("%s: babble\n", sc->sc_dev.dv_xname);
				sc->sc_if.if_oerrors++;
			}
#if 0
			if (isr & LE_CERR) {
				printf("%s: collision error\n", sc->sc_dev.dv_xname);
				sc->sc_if.if_collisions++;
			}
#endif
			if (isr & LE_MISS) {
#if 0
				printf("%s: missed packet\n", sc->sc_dev.dv_xname);
#endif
				sc->sc_if.if_ierrors++;
			}
			if (isr & LE_MERR) {
				printf("%s: memory error\n", sc->sc_dev.dv_xname);
				lereset(sc);
				goto out;
			}
		}

		if ((isr & LE_RXON) == 0) {
			printf("%s: receiver disabled\n", sc->sc_dev.dv_xname);
			sc->sc_if.if_ierrors++;
			lereset(sc);
			goto out;
		}
		if ((isr & LE_TXON) == 0) {
			printf("%s: transmitter disabled\n", sc->sc_dev.dv_xname);
			sc->sc_if.if_oerrors++;
			lereset(sc);
			goto out;
		}

		if (isr & LE_RINT) {
			/* Reset watchdog timer. */
			sc->sc_if.if_timer = 0;
			lerint(sc);
		}
		if (isr & LE_TINT) {
			/* Reset watchdog timer. */
			sc->sc_if.if_timer = 0;
			letint(sc);
		}

		isr = lerdcsr(sc, 0);
	} while ((isr & LE_INTR) != 0);

#ifdef LEDEBUG
	if (sc->sc_debug)
		printf("%s: leintr returning with isr=%04x\n",
		    sc->sc_dev.dv_xname, isr);
#endif

out:
	return 1;
}

#define NEXTTDS \
	if (++tmd == NTBUF) tmd=0, cdm=sc->sc_td; else ++cdm
	
/*
 * Setup output on interface.
 * Get another datagram to send off of the interface queue, and map it to the
 * interface before starting the output.
 * Called only at splimp or interrupt level.
 */
void
lestart(ifp)
	struct ifnet *ifp;
{
	register struct le_softc *sc = lecd.cd_devs[ifp->if_unit];
	register int tmd;
	volatile struct mds *cdm;
	struct mbuf *m0, *m;
	u_char *buffer;
	int len;

	if ((sc->sc_if.if_flags & (IFF_RUNNING | IFF_OACTIVE)) !=
	    IFF_RUNNING)
		return;

	tmd = sc->sc_last_td;
	cdm = &sc->sc_td[tmd];

	for (;;) {
		if (sc->sc_no_td >= NTBUF) {
			sc->sc_if.if_flags |= IFF_OACTIVE;
#ifdef LEDEBUG
			if (sc->sc_debug)
				printf("no_td = %d, last_td = %d\n", sc->sc_no_td,
				    sc->sc_last_td);
#endif
			break;
		}

#ifdef LEDEBUG
		if (cdm->flags & LE_OWN) {
			sc->sc_if.if_flags |= IFF_OACTIVE;
			printf("missing buffer, no_td = %d, last_td = %d\n",
			    sc->sc_no_td, sc->sc_last_td);
		}
#endif

		IF_DEQUEUE(&sc->sc_if.if_snd, m);
		if (!m)
			break;

		++sc->sc_no_td;

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		buffer = sc->sc_tbuf + (BUFSIZE * sc->sc_last_td);
		len = 0;
		for (m0 = m; m; m = m->m_next) {
			bcopy(mtod(m, caddr_t), buffer, m->m_len);
			buffer += m->m_len;
			len += m->m_len;
		}

#ifdef LEDEBUG
		if (len > ETHER_MAX_LEN)
			printf("packet length %d\n", len);
#endif

#if NBPFILTER > 0
		if (sc->sc_if.if_bpf)
			bpf_mtap(sc->sc_if.if_bpf, m0);
#endif

		m_freem(m0);
		len = max(len, ETHER_MIN_LEN);

		/*
		 * Init transmit registers, and set transmit start flag.
		 */
		cdm->bcnt = -len;
		cdm->mcnt = 0;
		cdm->flags |= LE_OWN | LE_STP | LE_ENP;

#ifdef LEDEBUG
		if (sc->sc_debug)
			xmit_print(sc, sc->sc_last_td);
#endif
		
		lewrcsr(sc, 0, LE_INEA | LE_TDMD);

		NEXTTDS;
	}

	sc->sc_last_td = tmd;
}

void
letint(sc) 
	struct le_softc *sc;
{
	register int tmd = (sc->sc_last_td - sc->sc_no_td + NTBUF) % NTBUF;
	volatile struct mds *cdm;

	cdm = &sc->sc_td[tmd];
	if (cdm->flags & LE_OWN) {
		/* Race condition with loop below. */
#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("%s: extra tint\n", sc->sc_dev.dv_xname);
#endif
		return;
	}

	sc->sc_if.if_flags &= ~IFF_OACTIVE;

	do {
		if (sc->sc_no_td <= 0)
			break;
#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("trans cdm = %x\n", cdm);
#endif
		sc->sc_if.if_opackets++;
		--sc->sc_no_td;
		if (cdm->mcnt & (LE_TBUFF | LE_UFLO | LE_LCOL | LE_LCAR | LE_RTRY)) {
			if (cdm->mcnt & LE_TBUFF)
				printf("%s: transmit buffer error\n", sc->sc_dev.dv_xname);
			if ((cdm->mcnt & (LE_TBUFF | LE_UFLO)) == LE_UFLO)
				printf("%s: underflow\n", sc->sc_dev.dv_xname);
			if (cdm->mcnt & LE_UFLO) {
				lereset(sc);
				return;
			}
#if 0
			if (cdm->mcnt & LE_LCOL) {
				printf("%s: late collision\n", sc->sc_dev.dv_xname);
				sc->sc_if.if_collisions++;
			}
			if (cdm->mcnt & LE_LCAR)
				printf("%s: lost carrier\n", sc->sc_dev.dv_xname);
			if (cdm->mcnt & LE_RTRY) {
				printf("%s: excessive collisions, tdr %d\n",
				    sc->sc_dev.dv_xname, cdm->flags & 0x1ff);
				sc->sc_if.if_collisions += 16;
			}
#endif
		} else if (cdm->flags & LE_ONE)
			sc->sc_if.if_collisions++;
		else if (cdm->flags & LE_MORE)
			/* Real number is unknown. */
			sc->sc_if.if_collisions += 2;
		NEXTTDS;
	} while ((cdm->flags & LE_OWN) == 0);

	lestart(&sc->sc_if);
}

#define NEXTRDS \
	if (++rmd == NRBUF) rmd=0, cdm=sc->sc_rd; else ++cdm
	
/* only called from one place, so may as well integrate */
void
lerint(sc)
	struct le_softc *sc;
{
	register int rmd = sc->sc_last_rd;
	volatile struct mds *cdm;

	cdm = &sc->sc_rd[rmd];
	if (cdm->flags & LE_OWN) {
		/* Race condition with loop below. */
#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("%s: extra rint\n", sc->sc_dev.dv_xname);
#endif
		return;
	}

	/* Process all buffers with valid data. */
	do {
		if (cdm->flags & LE_ERR) {
#ifdef	LEDEBUG
			/*
			 * XXX - These happen a LOT on the Sun3/50 so
			 * it is really NOT appropriate to print them.
			 */
			printf("%s: error, cdm->flags=%b\n",
				sc->sc_dev.dv_xname, cdm->flags, RMD_BITS);
#endif
			sc->sc_if.if_ierrors++;
		} else if (cdm->flags & (LE_STP | LE_ENP) != (LE_STP | LE_ENP)) {
			do {
				cdm->mcnt = 0;
				cdm->flags |= LE_OWN;
				NEXTRDS;
			} while ((cdm->flags & (LE_OWN | LE_ERR | LE_STP | LE_ENP)) == 0);
			sc->sc_last_rd = rmd;
			printf("%s: chained buffer\n", sc->sc_dev.dv_xname);
			if ((cdm->flags & (LE_OWN | LE_ERR | LE_STP | LE_ENP)) != LE_ENP) {
				lereset(sc);
				return;
			}
		} else {
#ifdef LEDEBUG
			if (sc->sc_debug)
				recv_print(sc, sc->sc_last_rd);
#endif
			leread(sc, sc->sc_rbuf + (BUFSIZE * rmd),
			    (int)cdm->mcnt);
		}

		cdm->bcnt = -BUFSIZE;
		cdm->mcnt = 0;
		cdm->flags |= LE_OWN;
		NEXTRDS;
#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("sc->sc_last_rd = %x, cdm = %x\n",
			    sc->sc_last_rd, cdm);
#endif
	} while ((cdm->flags & LE_OWN) == 0);

	sc->sc_last_rd = rmd;
}

/*
 * Pass a packet to the higher levels.
 */
void
leread(sc, buf, len)
	register struct le_softc *sc;
	u_char *buf;
	int len;
{
	struct ifnet *ifp;
	struct mbuf *m;
	struct ether_header *eh;

	ifp = &sc->sc_if;

	if ((len < ETHERMIN) || (len > ETHER_MAX_LEN)) {
		log(LOG_ERR, "%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);	
		ifp->if_ierrors++;
		return;
	}

	/* Pull packet off interface. */
	m = leget(buf, len, ifp);
	if (m == 0) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf) {
		/* Note that BPF may see garbage! (if LANCE_REVC_BUG) */
		bpf_mtap(ifp->if_bpf, m);
	}
#endif	/* NBPFILTER */

#if LANCE_REVC_BUG
	/*
	 * Check for unreported packet errors.  Rev C of the LANCE chip
	 * has a bug which can cause "random" bytes to be prepended to
	 * the start of the packet.  The work-around is to make sure that
	 * the Ethernet destination address in the packet matches our
	 * address (or the broadcast address).  Must ALWAYS check!
	 */
	if (bcmp(eh->ether_dhost, sc->sc_enaddr, 6) &&
	    bcmp(eh->ether_dhost, etherbroadcastaddr, 6))
	{
		/* Not for us. */
		m_freem(m);
		return;
	}
#else	/* LANCE_REVC_BUG */
#if NBPFILTER > 0
	if (ifp->if_bpf) {
		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(eh->ether_dhost, sc->sc_enaddr, 6) != 0)
		{
			m_freem(m);
			return;
		}
	}
#endif	/* NBPFILTER */
#endif	/* LANCE_REVC_BUG */

	/* Pass the packet up, with the ether header sort-of removed. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
}
d139 1
a139 3
/*
 * Supporting routines
 */
d141 5
a145 14
/*
 * Pull data off an interface.
 * Len is length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present
 * we copy into clusters.
 */
struct mbuf *
leget(buf, totlen, ifp)
	u_char *buf;
	int totlen;
	struct ifnet *ifp;
{
	struct mbuf *top, **mp, *m;
	int len;
d147 2
a148 30
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return 0;
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	len = MHLEN;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return 0;
			}
			len = MLEN;
		}
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy((caddr_t)buf, mtod(m, caddr_t), len);
		buf += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}
d150 2
a151 1
	return top;
d154 1
a154 234
/*
 * Process an ioctl request.
 */
int
leioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct le_softc *sc = lecd.cd_devs[ifp->if_unit];
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splimp();

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			leinit(sc);
			arp_ifinit(&sc->sc_ac, ifa);
			break;
#endif
#ifdef NS
		/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_enaddr,
				    sizeof(sc->sc_enaddr));
			/* Set new address. */
			leinit(sc);
			break;
		    }
#endif
		default:
			leinit(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		/*
		 * If interface is marked down and it is running, then stop it
		 */
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			lestop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			leinit(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			/*lestop(sc);*/
			leinit(sc);
		}
#ifdef LEDEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = 1;
		else
			sc->sc_debug = 0;
#endif
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ac):
		    ether_delmulti(ifr, &sc->sc_ac);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			leinit(sc);
			error = 0;
		}
		break;

	default:
		error = EINVAL;
	}
	(void) splx(s);
	return error;
}

#ifdef LEDEBUG
void
recv_print(sc, no)
	struct le_softc *sc;
	int no;
{
	struct mds *rmd;
	int i, printed = 0;
	u_short len;
	
	rmd = &sc->sc_rd[no];
	len = rmd->mcnt;
	printf("%s: receive buffer %d, len = %d\n", sc->sc_dev.dv_xname, no,
	    len);
	printf("%s: status %x\n", sc->sc_dev.dv_xname, lerdcsr(sc, 0));
	for (i = 0; i < len; i++) {
		if (!printed) {
			printed = 1;
			printf("%s: data: ", sc->sc_dev.dv_xname);
		}
		printf("%x ", *(sc->sc_rbuf + (BUFSIZE*no) + i));
	}
	if (printed)
		printf("\n");
}
		
void
xmit_print(sc, no)
	struct le_softc *sc;
	int no;
{
	struct mds *rmd;
	int i, printed=0;
	u_short len;
	
	rmd = &sc->sc_td[no];
	len = -rmd->bcnt;
	printf("%s: transmit buffer %d, len = %d\n", sc->sc_dev.dv_xname, no,
	    len);
	printf("%s: status %x\n", sc->sc_dev.dv_xname, lerdcsr(sc, 0));
	printf("%s: addr %x, flags %x, bcnt %x, mcnt %x\n",
	    sc->sc_dev.dv_xname, rmd->addr, rmd->flags, rmd->bcnt, rmd->mcnt);
	for (i = 0; i < len; i++)  {
		if (!printed) {
			printed = 1;
			printf("%s: data: ", sc->sc_dev.dv_xname);
		}
		printf("%x ", *(sc->sc_tbuf + (BUFSIZE*no) + i));
	}
	if (printed)
		printf("\n");
}
#endif /* LEDEBUG */

/*
 * Set up the logical address filter.
 */
void
lesetladrf(ac, af)
	struct arpcom *ac;
	u_long *af;
{
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	register u_char *cp, c;
	register u_long crc;
	register int i, len;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		af[0] = af[1] = 0xffffffff;
		return;
	}

	af[0] = af[1] = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    sizeof(enm->enm_addrlo)) != 0) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			af[0] = af[1] = 0xffffffff;
			return;
		}

		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			c = *cp++;
			for (i = 8; --i >= 0;) {
				if ((crc & 0x01) ^ (c & 0x01)) {
					crc >>= 1;
					crc ^= 0x6db88320 | 0x80000000;
				} else
					crc >>= 1;
				c >>= 1;
			}
		}
		/* Just want the 6 most significant bits. */
		crc >>= 26;

		/* Turn on the corresponding bit in the filter. */
		af[crc >> 5] |= 1 << ((crc & 0x1f) ^ 0);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.22 1995/06/27 14:34:32 gwr Exp $	*/
d54 9
a62 1
/* XXX - Yes, we DO have to deal with this bug. */
d64 1
d180 3
a182 2
#ifndef	LANCE_REVC_BUG
	/* XXX - Must be a better way... */
d189 1
a644 1
			sc->sc_if.if_ipackets++;
d674 1
a674 3
	len -= 4;
	if (len <= 0)
		return;
d676 4
a679 22
#ifdef	LANCE_REVC_BUG	/* XXX - Must be a better way... */
	/*
	 * Check for unreported packet errors.  Rev C of the LANCE chip
	 * has a bug which can cause "random" bytes to be prepended to
	 * the start of the packet.  The work-around is to make sure that
	 * the Ethernet destination address in the packet matches our
	 * address (or the broadcast address).
	 */
	{
		register short *pp, *ea;

		pp = (short *) buf;
		ea = (short *) &sc->sc_enaddr;
		if ((pp[0] == ea[0]) && (pp[1] == ea[1]) && (pp[2] == ea[2]))
			goto ok;
		if ((pp[0] == -1) && (pp[1] == -1) && (pp[2] == -1))
			goto ok;
		/* XXX - Multicast packets? */

		sc->sc_if.if_ierrors++;
		log(LOG_ERR, "%s: LANCE Rev C Extra Byte(s) bug; Packet punted\n",
			   sc->sc_dev.dv_xname);
a680 1
	ok:
a681 1
#endif	/* LANCE_REVC_BUG */
a683 1
	ifp = &sc->sc_if;
d685 2
a686 1
	if (m == 0)
d688 3
d701 1
d703 2
d706 18
d731 2
a732 2
		    bcmp(eh->ether_dhost, sc->sc_enaddr,
			    sizeof(eh->ether_dhost)) != 0) {
d737 2
a738 6
#endif

	/* We assume that the header fit entirely in one mbuf. */
	m->m_pkthdr.len -= sizeof(*eh);
	m->m_len -= sizeof(*eh);
	m->m_data += sizeof(*eh);
d740 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
