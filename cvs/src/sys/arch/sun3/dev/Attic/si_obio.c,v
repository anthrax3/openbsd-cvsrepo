head	1.12;
access;
symbols
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.6
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.14
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.12
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2002.12.31.16.35.40;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.25.03.50.49;	author todd;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	2000.06.06.20.51.41;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	97.09.11.16.09.59;	author kstailey;	state Exp;
branches
	1.8.12.1;
next	1.7;

1.7
date	97.04.29.13.09.25;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.04.03.53;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.07.23.36.12;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.31.06.12.56;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.07.54.57;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.10.11.23.06.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.03.16.03.00;	author mickey;	state Exp;
branches;
next	;

1.8.12.1
date	2001.05.14.21.37.28;	author niklas;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2003.03.27.23.52.17;	author niklas;	state dead;
branches;
next	;

1.10.6.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2003.05.19.21.49.45;	author tedu;	state dead;
branches;
next	;


desc
@@


1.12
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: si_obio.c,v 1.11 2002/03/14 01:26:46 millert Exp $	*/
/*	$NetBSD: si_obio.c,v 1.7 1996/11/20 18:57:00 gwr Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass, David Jones, and Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file contains only the machine-dependent parts of the
 * Sun3 SCSI driver.  (Autoconfig stuff and DMA functions.)
 * The machine-independent parts are in ncr5380sbc.c
 *
 * Supported hardware includes:
 * Sun SCSI-3 on OBIO (Sun3/50,Sun3/60)
 * Sun SCSI-3 on VME (Sun3/160,Sun3/260)
 *
 * Could be made to support the Sun3/E if someone wanted to.
 *
 * Note:  Both supported variants of the Sun SCSI-3 adapter have
 * some really unusual "features" for this driver to deal with,
 * generally related to the DMA engine.  The OBIO variant will
 * ignore any attempt to write the FIFO count register while the
 * SCSI bus is in DATA_IN or DATA_OUT phase.  This is dealt with
 * by setting the FIFO count early in COMMAND or MSG_IN phase.
 *
 * The VME variant has a bit to enable or disable the DMA engine,
 * but that bit also gates the interrupt line from the NCR5380!
 * Therefore, in order to get any interrupt from the 5380, (i.e.
 * for reselect) one must clear the DMA engine transfer count and
 * then enable DMA.  This has the further complication that you
 * CAN NOT touch the NCR5380 while the DMA enable bit is set, so
 * we have to turn DMA back off before we even look at the 5380.
 *
 * What wonderfully whacky hardware this is!
 *
 * Credits, history:
 *
 * David Jones wrote the initial version of this module, which
 * included support for the VME adapter only. (no reselection).
 *
 * Gordon Ross added support for the OBIO adapter, and re-worked
 * both the VME and OBIO code to support disconnect/reselect.
 * (Required figuring out the hardware "features" noted above.)
 *
 * The autoconfiguration boilerplate came from Adam Glass.
 */

/*****************************************************************
 * OBIO functions for DMA
 ****************************************************************/

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/user.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>

#include <machine/autoconf.h>
#include <machine/obio.h>
#include <machine/dvma.h>

#ifndef DDB
#define Debugger()
#endif

#define DEBUG XXX

#include <dev/ic/ncr5380reg.h>
#include <dev/ic/ncr5380var.h>

#include "sireg.h"
#include "sivar.h"
#include "am9516.h"

/*
 * How many uS. to delay after touching the am9516 UDC.
 */
#define UDC_WAIT_USEC 5

void si_obio_dma_setup(struct ncr5380_softc *);
void si_obio_dma_start(struct ncr5380_softc *);
void si_obio_dma_eop(struct ncr5380_softc *);
void si_obio_dma_stop(struct ncr5380_softc *);

static __inline__ int  si_obio_udc_read(volatile struct si_regs *, int);
static __inline__ void si_obio_udc_write(volatile struct si_regs *,
					      int, int);

/*
 * New-style autoconfig attachment
 */

static int	si_obio_match(struct device *, void *, void *);
static void	si_obio_attach(struct device *, struct device *, void *);

struct cfattach si_obio_ca = {
	sizeof(struct si_softc), si_obio_match, si_obio_attach
};

/* Options.  Interesting values are: 1,3,7 */
/* XXX: Using 1 for now to mask a (pmap?) bug not yet found... */
int si_obio_options = 1;	/* XXX */


static int
si_obio_match(parent, vcf, args)
	struct device	*parent;
	void		*vcf, *args;
{
	struct confargs *ca = args;

	/* Make sure there is something there... */
	if (bus_peek(ca->ca_bustype, ca->ca_paddr + 1, 1) == -1)
		return (0);

	/* Default interrupt priority. */
	if (ca->ca_intpri == -1)
		ca->ca_intpri = 2;

	return (1);
}

static void
si_obio_attach(parent, self, args)
	struct device	*parent, *self;
	void		*args;
{
	struct si_softc *sc = (struct si_softc *) self;
	struct ncr5380_softc *ncr_sc = &sc->ncr_sc;
	struct cfdata *cf = self->dv_cfdata;
	struct confargs *ca = args;

	/* Get options from config flags... */
	sc->sc_options = cf->cf_flags | si_obio_options;
	printf(": options=%d\n", sc->sc_options);

	sc->sc_adapter_type = ca->ca_bustype;
	sc->sc_regs = (struct si_regs *)
		obio_alloc(ca->ca_paddr, sizeof(struct si_regs));

	/*
	 * MD function pointers used by the MI code.
	 */
	ncr_sc->sc_pio_out = ncr5380_pio_out;
	ncr_sc->sc_pio_in =  ncr5380_pio_in;
	ncr_sc->sc_dma_alloc = si_dma_alloc;
	ncr_sc->sc_dma_free  = si_dma_free;
	ncr_sc->sc_dma_setup = si_obio_dma_setup;
	ncr_sc->sc_dma_start = si_obio_dma_start;
	ncr_sc->sc_dma_poll  = si_dma_poll;
	ncr_sc->sc_dma_eop   = si_obio_dma_eop;
	ncr_sc->sc_dma_stop  = si_obio_dma_stop;
	ncr_sc->sc_intr_on   = NULL;
	ncr_sc->sc_intr_off  = NULL;

	/* Need DVMA-capable memory for the UDC command block. */
	sc->sc_dmacmd = dvma_malloc(sizeof (struct udc_table));

	/* Attach interrupt handler. */
	isr_add_autovect(si_intr, (void *)sc, ca->ca_intpri);

	/* Do the common attach stuff. */
	si_attach(sc);
}


static __inline__ void
si_obio_udc_write(si, regnum, value)
	volatile struct si_regs *si;
	int regnum, value;
{
	si->udc_addr = regnum;
	delay(UDC_WAIT_USEC);
	si->udc_data = value;
	delay(UDC_WAIT_USEC);
}

static __inline__ int
si_obio_udc_read(si, regnum)
	volatile struct si_regs *si;
	int regnum;
{
	int value;

	si->udc_addr = regnum;
	delay(UDC_WAIT_USEC);
	value = si->udc_data;
	delay(UDC_WAIT_USEC);

	return (value);
}


/*
 * This function is called during the COMMAND or MSG_IN phase
 * that preceeds a DATA_IN or DATA_OUT phase, in case we need
 * to setup the DMA engine before the bus enters a DATA phase.
 *
 * The OBIO "si" IGNORES any attempt to set the FIFO count
 * register after the SCSI bus goes into any DATA phase, so
 * this function has to setup the evil FIFO logic.
 */
void
si_obio_dma_setup(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	volatile struct si_regs *si = sc->sc_regs;
	struct udc_table *cmd;
	long data_pa, cmd_pa;
	int xlen;

	/*
	 * Get the DVMA mapping for this segment.
	 * XXX - Should separate allocation and mapin.
	 */
	data_pa = dvma_kvtopa(dh->dh_dvma, sc->sc_adapter_type);
	data_pa += (ncr_sc->sc_dataptr - dh->dh_addr);
	if (data_pa & 1)
		panic("si_dma_start: bad pa=0x%lx", data_pa);
	xlen = ncr_sc->sc_datalen;
	sc->sc_reqlen = xlen; 	/* XXX: or less? */

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_setup: dh=%p, pa=0x%lx, xlen=0x%x\n",
			   dh, data_pa, xlen);
	}
#endif

	/* Reset the UDC. (In case not already reset?) */
	si_obio_udc_write(si, UDC_ADR_COMMAND, UDC_CMD_RESET);

	/* Reset the FIFO */
	si->si_csr &= ~SI_CSR_FIFO_RES; 	/* active low */
	si->si_csr |= SI_CSR_FIFO_RES;

	/* Set direction (send/recv) */
	if (dh->dh_flags & SIDH_OUT) {
		si->si_csr |= SI_CSR_SEND;
	} else {
		si->si_csr &= ~SI_CSR_SEND;
	}

	/* Set the FIFO counter. */
	si->fifo_count = xlen;

	/* Reset the UDC. */
	si_obio_udc_write(si, UDC_ADR_COMMAND, UDC_CMD_RESET);

	/*
	 * XXX: Reset the FIFO again!  Comment from Sprite:
	 * Go through reset again becuase of the bug on the 3/50
	 * where bytes occasionally linger in the DMA fifo.
	 */
	si->si_csr &= ~SI_CSR_FIFO_RES; 	/* active low */
	si->si_csr |= SI_CSR_FIFO_RES;

#ifdef	DEBUG
	/* Make sure the extra FIFO reset did not hit the count. */
	if (si->fifo_count != xlen) {
		printf("si_dma_setup: fifo_count=0x%x, xlen=0x%x\n",
			   si->fifo_count, xlen);
		Debugger();
	}
#endif

	/*
	 * Set up the DMA controller.  The DMA controller on
	 * OBIO needs a command block in DVMA space.
	 */
	cmd = sc->sc_dmacmd;
	cmd->addrh = ((data_pa & 0xFF0000) >> 8) | UDC_ADDR_INFO;
	cmd->addrl = data_pa & 0xFFFF;
	cmd->count = xlen / 2;	/* bytes -> words */
	cmd->cmrh = UDC_CMR_HIGH;
	if (dh->dh_flags & SIDH_OUT) {
		if (xlen & 1)
			cmd->count++;
		cmd->cmrl = UDC_CMR_LSEND;
		cmd->rsel = UDC_RSEL_SEND;
	} else {
		cmd->cmrl = UDC_CMR_LRECV;
		cmd->rsel = UDC_RSEL_RECV;
	}

	/* Tell the DMA chip where the control block is. */
	cmd_pa = dvma_kvtopa((long)cmd, BUS_OBIO);
	si_obio_udc_write(si, UDC_ADR_CAR_HIGH,
					  (cmd_pa & 0xff0000) >> 8);
	si_obio_udc_write(si, UDC_ADR_CAR_LOW,
					  (cmd_pa & 0xffff));

	/* Tell the chip to be a DMA master. */
	si_obio_udc_write(si, UDC_ADR_MODE, UDC_MODE);

	/* Tell the chip to interrupt on error. */
	si_obio_udc_write(si, UDC_ADR_COMMAND, UDC_CMD_CIE);

	/* Will do "start chain" command in _dma_start. */
}


void
si_obio_dma_start(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	volatile struct si_regs *si = sc->sc_regs;
	int s;

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: sr=%p\n", sr);
	}
#endif

	/* This MAY be time critical (not sure). */
	s = splhigh();

	/* Finally, give the UDC a "start chain" command. */
	si_obio_udc_write(si, UDC_ADR_COMMAND, UDC_CMD_STRT_CHN);

	/*
	 * Acknowledge the phase change.  (After DMA setup!)
	 * Put the SBIC into DMA mode, and start the transfer.
	 */
	if (dh->dh_flags & SIDH_OUT) {
		*ncr_sc->sci_tcmd = PHASE_DATA_OUT;
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_icmd = SCI_ICMD_DATA;
		*ncr_sc->sci_mode |= (SCI_MODE_DMA | SCI_MODE_DMA_IE);
		*ncr_sc->sci_dma_send = 0;	/* start it */
	} else {
		*ncr_sc->sci_tcmd = PHASE_DATA_IN;
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_icmd = 0;
		*ncr_sc->sci_mode |= (SCI_MODE_DMA | SCI_MODE_DMA_IE);
		*ncr_sc->sci_irecv = 0;	/* start it */
	}

	splx(s);
	ncr_sc->sc_state |= NCR_DOINGDMA;

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: started, flags=0x%x\n",
			   ncr_sc->sc_state);
	}
#endif
}


void
si_obio_dma_eop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{

	/* Not needed - DMA was stopped prior to examining sci_csr */
}


void
si_obio_dma_stop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	volatile struct si_regs *si = sc->sc_regs;
	int resid, ntrans, tmo, udc_cnt;

	if ((ncr_sc->sc_state & NCR_DOINGDMA) == 0) {
#ifdef	DEBUG
		printf("si_dma_stop: dma not running\n");
#endif
		return;
	}
	ncr_sc->sc_state &= ~NCR_DOINGDMA;

	NCR_TRACE("si_dma_stop: top, csr=0x%x\n", si->si_csr);

	/* OK, have either phase mis-match or end of DMA. */
	/* Set an impossible phase to prevent data movement? */
	*ncr_sc->sci_tcmd = PHASE_INVALID;

	/* Check for DMA errors. */
	if (si->si_csr & (SI_CSR_DMA_CONFLICT | SI_CSR_DMA_BUS_ERR)) {
		printf("si: DMA error, csr=0x%x, reset\n", si->si_csr);
		sr->sr_xs->error = XS_DRIVER_STUFFUP;
		ncr_sc->sc_state |= NCR_ABORTING;
		si_reset_adapter(ncr_sc);
		goto out;
	}

	/* Note that timeout may have set the error flag. */
	if (ncr_sc->sc_state & NCR_ABORTING)
		goto out;

	/*
	 * After a read, wait for the FIFO to empty.
	 * Note: this only works on the OBIO version.
	 */
	if ((dh->dh_flags & SIDH_OUT) == 0) {
		tmo = 200000;	/* X10 = 2 sec. */
		for (;;) {
			if (si->si_csr & SI_CSR_FIFO_EMPTY)
				break;
			if (--tmo <= 0) {
				printf("si: dma fifo did not empty, reset\n");
				ncr_sc->sc_state |= NCR_ABORTING;
				/* si_reset_adapter(ncr_sc); */
				goto out;
			}
			delay(10);
		}
	}

	/*
	 * Now try to figure out how much actually transferred
	 * The fifo_count might not reflect how many bytes were
	 * actually transferred.
	 */
	resid = si->fifo_count & 0xFFFF;
	ntrans = sc->sc_reqlen - resid;

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_stop: resid=0x%x ntrans=0x%x\n",
		       resid, ntrans);
	}
#endif

	/* XXX: Treat (ntrans==0) as a special, non-error case? */
	if (ntrans < MIN_DMA_LEN) {
		printf("si: fifo count: 0x%x\n", resid);
		ncr_sc->sc_state |= NCR_ABORTING;
		goto out;
	}
	if (ntrans > ncr_sc->sc_datalen)
		panic("si_dma_stop: excess transfer");

	/* Adjust data pointer */
	ncr_sc->sc_dataptr += ntrans;
	ncr_sc->sc_datalen -= ntrans;

	/*
	 * After a read, we may need to clean-up
	 * "Left-over bytes" (yuck!)
	 */
	if ((dh->dh_flags & SIDH_OUT) == 0) {
		/* If odd transfer count, grab last byte by hand. */
		if (ntrans & 1) {
			NCR_TRACE("si_dma_stop: leftover 1 at 0x%x\n",
				(int) ncr_sc->sc_dataptr - 1);
			ncr_sc->sc_dataptr[-1] =
				(si->fifo_data & 0xff00) >> 8;
			goto out;
		}
		/* UDC might not have transferred the last word. */
		udc_cnt = si_obio_udc_read(si, UDC_ADR_COUNT);
		if (((udc_cnt * 2) - resid) == 2) {
			NCR_TRACE("si_dma_stop: leftover 2 at 0x%x\n",
				(int) ncr_sc->sc_dataptr - 2);
			ncr_sc->sc_dataptr[-2] =
				(si->fifo_data & 0xff00) >> 8;
			ncr_sc->sc_dataptr[-1] =
				(si->fifo_data & 0x00ff);
		}
	}

out:
	/* Reset the UDC. */
	si_obio_udc_write(si, UDC_ADR_COMMAND, UDC_CMD_RESET);
	si->fifo_count = 0;
	si->si_csr &= ~SI_CSR_SEND;

	/* Reset the FIFO */
	si->si_csr &= ~SI_CSR_FIFO_RES;     /* active low */
	si->si_csr |= SI_CSR_FIFO_RES;

	/* Put SBIC back in PIO mode. */
	/* XXX: set tcmd to PHASE_INVALID? */
	*ncr_sc->sci_mode &= ~(SCI_MODE_DMA | SCI_MODE_DMA_IE);
	*ncr_sc->sci_icmd = 0;
}

@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: si_obio.c,v 1.10 2001/01/25 03:50:49 todd Exp $	*/
@


1.10
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: si_obio.c,v 1.8 1997/09/11 16:09:59 kstailey Exp $	*/
d120 8
a127 8
void si_obio_dma_setup __P((struct ncr5380_softc *));
void si_obio_dma_start __P((struct ncr5380_softc *));
void si_obio_dma_eop __P((struct ncr5380_softc *));
void si_obio_dma_stop __P((struct ncr5380_softc *));

static __inline__ int  si_obio_udc_read __P((volatile struct si_regs *, int));
static __inline__ void si_obio_udc_write __P((volatile struct si_regs *,
					      int, int));
d133 2
a134 2
static int	si_obio_match __P((struct device *, void *, void *));
static void	si_obio_attach __P((struct device *, struct device *, void *));
@


1.10.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: si_obio.c,v 1.10 2001/01/25 03:50:49 todd Exp $	*/
d120 8
a127 8
void si_obio_dma_setup(struct ncr5380_softc *);
void si_obio_dma_start(struct ncr5380_softc *);
void si_obio_dma_eop(struct ncr5380_softc *);
void si_obio_dma_stop(struct ncr5380_softc *);

static __inline__ int  si_obio_udc_read(volatile struct si_regs *, int);
static __inline__ void si_obio_udc_write(volatile struct si_regs *,
					      int, int);
d133 2
a134 2
static int	si_obio_match(struct device *, void *, void *);
static void	si_obio_attach(struct device *, struct device *, void *);
@


1.10.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: si_obio.c,v 1.10.6.1 2002/06/11 03:39:01 art Exp $	*/
@


1.9
log
@Make si compile with non-DDB kernels
@
text
@d504 1
a504 1
		/* UDC might not have transfered the last word. */
@


1.8
log
@activate sun3 SCSI DVMA
@
text
@d1 1
a1 1
/*	$OpenBSD: si_obio.c,v 1.7 1997/04/29 13:09:25 kstailey Exp $	*/
d101 4
@


1.8.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: si_obio.c,v 1.10 2001/01/25 03:50:49 todd Exp $	*/
a101 4
#ifndef DDB
#define Debugger()
#endif

d500 1
a500 1
		/* UDC might not have transferred the last word. */
@


1.8.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 8
a127 8
void si_obio_dma_setup(struct ncr5380_softc *);
void si_obio_dma_start(struct ncr5380_softc *);
void si_obio_dma_eop(struct ncr5380_softc *);
void si_obio_dma_stop(struct ncr5380_softc *);

static __inline__ int  si_obio_udc_read(volatile struct si_regs *, int);
static __inline__ void si_obio_udc_write(volatile struct si_regs *,
					      int, int);
d133 2
a134 2
static int	si_obio_match(struct device *, void *, void *);
static void	si_obio_attach(struct device *, struct device *, void *);
@


1.8.12.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: si_obio.c,v 1.8.12.2 2002/03/28 11:26:45 niklas Exp $	*/
@


1.7
log
@turn off DMA, it doesn't work
@
text
@d1 1
a1 1
/*	$OpenBSD: si_obio.c,v 1.6 1997/01/16 04:03:53 kstailey Exp $	*/
d138 1
a138 1
int si_obio_options = 0;	/* XXX */
d258 1
a258 1
		panic("si_dma_start: bad pa=0x%x", data_pa);
d264 1
a264 1
		printf("si_dma_setup: dh=%p, pa=0x%lx, xlen=%d\n",
@


1.6
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d138 1
a138 1
int si_obio_options = 1;	/* XXX */
@


1.5
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
a98 1
#include <machine/isr.h>
d121 4
a145 1
	struct cfdata	*cf = vcf;
d264 1
a264 1
		printf("si_dma_setup: dh=0x%x, pa=0x%x, xlen=%d\n",
d354 1
a354 1
		printf("si_dma_start: sr=0x%x\n", sr);
@


1.4
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: si_obio.c,v 1.8 1996/12/17 21:10:54 gwr Exp $	*/
d98 1
a120 6
static __inline__ void si_obio_udc_write
 __P((volatile struct si_regs *si, int regnum, int value));
static __inline__ int si_obio_udc_read
 __P((volatile struct si_regs *si, int regnum));


d140 1
a140 1
	void *vcf, *args;
d142 1
d261 1
a261 1
		printf("si_dma_setup: dh=%p, pa=0x%x, xlen=0x%x\n",
d351 1
a351 1
		printf("si_dma_start: sr=%p\n", sr);
@


1.3
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$NetBSD: si_obio.c,v 1.7 1996/11/20 18:57:00 gwr Exp $	*/
a97 1
#include <machine/isr.h>
d120 6
d145 1
a145 1
	void		*vcf, *args;
a146 1
	struct cfdata	*cf = vcf;
d265 1
a265 1
		printf("si_dma_setup: dh=0x%x, pa=0x%x, xlen=%d\n",
d355 1
a355 1
		printf("si_dma_start: sr=0x%x\n", sr);
@


1.2
log
@sync + our changes
@
text
@d1 1
a1 1
/*	$NetBSD: si_obio.c,v 1.2 1996/06/17 23:21:35 gwr Exp $	*/
d3 2
a4 3
/*
 * Copyright (c) 1995 David Jones, Gordon W. Ross
 * Copyright (c) 1994 Adam Glass
d7 3
d18 1
a18 3
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
d20 17
a36 13
 *      This product includes software developed by
 *      Adam Glass, David Jones, and Gordon Ross
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a134 3
#define SI_ENABLE_DMA	1	/* Use DMA (maybe polled) */
#define SI_DMA_INTR 	2	/* DMA completion interrupts */
#define	SI_DO_RESELECT	4	/* Allow disconnect/reselect */
a143 1
	int pa, x;
d145 2
a146 16
#ifdef	DIAGNOSTIC
	if (ca->ca_bustype != BUS_OBIO) {
		printf("si_obio_match: bustype %d?\n", ca->ca_bustype);
		return (0);
	}
#endif

	/*
	 * OBIO match functions may be called for every possible
	 * physical address, so match only our physical address.
	 */
	if ((pa = cf->cf_paddr) == -1) {
		/* Use our default PA. */
		pa = OBIO_NCR_SCSI;
	}
	if (pa != ca->ca_paddr)
d149 3
a151 8
#if 0
	if ((cpu_machine_id != SUN3_MACH_50) &&
	    (cpu_machine_id != SUN3_MACH_60) )
	{
		/* Only 3/50 and 3/60 have the obio si. */
		return (0);
	}
#endif
d153 1
a153 3
	/* Make sure there is something there... */
	x = bus_peek(ca->ca_bustype, ca->ca_paddr + 1, 1);
	return (x != -1);
a164 1
	int intpri;
d166 3
a168 13
	/* Default interrupt level. */
	if ((intpri = cf->cf_intpri) == -1)
		intpri = 2;
	printf(" level %d", intpri);

	/* XXX: Get options from flags... */
	printf(" : options=%d\n", si_obio_options);

	ncr_sc->sc_flags = 0;
	if (si_obio_options & SI_DO_RESELECT)
		ncr_sc->sc_flags |= NCR5380_PERMIT_RESELECT;
	if ((si_obio_options & SI_DMA_INTR) == 0)
		ncr_sc->sc_flags |= NCR5380_FORCE_POLLING;
a188 10
	ncr_sc->sc_min_dma_len = MIN_DMA_LEN;

#if 1	/* XXX - Temporary */
	/* XXX - In case we think DMA is completely broken... */
	if ((si_obio_options & SI_ENABLE_DMA) == 0) {
		/* Override this function pointer. */
		ncr_sc->sc_dma_alloc = NULL;
	}
#endif

d193 1
a193 1
	isr_add_autovect(si_intr, (void *)sc, intpri);
@


1.1
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: si_obio.c,v 1.1 1996/03/26 15:01:12 gwr Exp $	*/
d129 2
a130 1
int si_obio_options = 3;
a210 1

a212 2
	ncr_sc->sc_dma_poll  = si_dma_poll;

d215 2
a216 1
	ncr_sc->sc_dma_eop   = si_obio_dma_stop;
d283 2
d286 14
a299 13
	struct sci_req *sr;
	struct si_dma_handle *dh;
	int send = 0;
	int xlen = 0;

	/* Let this work even without a dma hand, for testing... */
	if ((sr = ncr_sc->sc_current) != NULL) {
		if ((dh = sr->sr_dma_hand) != NULL) {
			send = dh->dh_flags & SIDH_OUT;
			xlen = ncr_sc->sc_datalen;
			xlen &= ~1;
		}
	}
d302 3
a304 2
	if (si_debug) {
		printf("si_dma_setup: send=%d xlen=%d\n", send, xlen);
d316 1
a316 1
	if (send) {
d325 3
d329 1
a329 1
	 * XXX: Reset DMA engine again!  Comment from Sprite:
a332 5

	/* Reset the UDC. */
	si_obio_udc_write(si, UDC_ADR_COMMAND, UDC_CMD_RESET);

	/* Reset the FIFO */
d337 2
a338 1
	if ((si->fifo_count > xlen) || (si->fifo_count < (xlen - 1))) {
a343 14
}


void
si_obio_dma_start(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	volatile struct si_regs *si = sc->sc_regs;
	struct udc_table *cmd;
	long data_pa, cmd_pa;
	int xlen;
d346 2
a347 35
	 * Get the DVMA mapping for this segment.
	 * XXX - Should separate allocation and mapin.
	 */
	data_pa = dvma_kvtopa(dh->dh_dvma, sc->sc_adapter_type);
	data_pa += (ncr_sc->sc_dataptr - dh->dh_addr);
	if (data_pa & 1)
		panic("si_dma_start: bad pa=0x%x", data_pa);
	xlen = ncr_sc->sc_datalen;
	xlen &= ~1;
	sc->sc_reqlen = xlen; 	/* XXX: or less... */

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: dh=0x%x, pa=0x%x, xlen=%d\n",
			   dh, data_pa, xlen);
	}
#endif

	/*
	 * Set up the DMA controller.
	 * Already set FIFO count in dma_setup.
	 */

#ifdef	DEBUG
	if ((si->fifo_count > xlen) ||
		(si->fifo_count < (xlen - 1)))
	{
		printf("si_dma_start: fifo_count=0x%x, xlen=0x%x\n",
			   si->fifo_count, xlen);
		Debugger();
	}
#endif

	/*
	 * The OBIO controller needs a command block.
d355 2
d377 22
a398 1
	/* XXX: Move all of the above to _setup? */
d421 1
d460 7
d472 1
a499 1
	 *
d501 1
a501 1
	 * actually transferred for VME.
a502 1

d557 3
a559 3
    /* Reset the FIFO */
    si->si_csr &= ~SI_CSR_FIFO_RES;     /* active low */
    si->si_csr |= SI_CSR_FIFO_RES;
d562 1
@
