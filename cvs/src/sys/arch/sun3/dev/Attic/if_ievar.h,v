head	1.6;
access;
symbols
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.24
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.22
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.20
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.14
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2002.12.31.16.35.40;	author miod;	state dead;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.16.04.03.48;	author kstailey;	state Exp;
branches
	1.4.14.1
	1.4.24.1;
next	1.3;

1.3
date	97.01.07.23.36.09;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.12.31.06.12.46;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.03.16.02.24;	author mickey;	state Exp;
branches;
next	;

1.4.14.1
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.4.14.2;

1.4.14.2
date	2003.03.27.23.52.17;	author niklas;	state dead;
branches;
next	;

1.4.24.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.4.24.2;

1.4.24.2
date	2003.05.19.21.49.44;	author tedu;	state dead;
branches;
next	;


desc
@@


1.6
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: if_ievar.h,v 1.5 2002/03/14 01:26:46 millert Exp $	*/
/*	$NetBSD: if_ievar.h,v 1.6 1996/03/26 14:38:33 gwr Exp $	*/

/*
 * Machine-dependent glue for the Intel Ethernet (ie) driver.
 */

#define B_PER_F		3	/* number of buffers to allocate per frame */
#define	MXFRAMES	256	/* max number of frames to allow for receive */
#define	MXRXBUF (MXFRAMES*B_PER_F)	/* max number of buffers to allocate */
#define	IE_RBUF_SIZE	256	/* size of each buffer, MUST BE POWER OF TWO */
#define	NTXBUF		2	/* number of transmit buffer/command pairs */
#define	IE_TBUF_SIZE	(3*512)	/* length of transmit buffer */

enum ie_hardware {
	IE_VME,			/* multibus to VME ie card */
	IE_OBIO,		/* on board */
	IE_VME3E,		/* sun 3e VME card */
	IE_UNKNOWN
};

/*
 * Ethernet status, per interface.
 *
 * hardware addresses/sizes to know (all KVA):
 *   sc_iobase = base of chip's 24 bit address space
 *   sc_maddr  = base address of chip RAM as stored in ie_base of iscp
 *   sc_msize  = size of chip's RAM
 *   sc_reg    = address of card dependent registers
 *
 * the chip uses two types of pointers: 16 bit and 24 bit
 *   16 bit pointers are offsets from sc_maddr/ie_base
 *	KVA(16 bit offset) = offset + sc_maddr
 *   24 bit pointers are offset from sc_iobase in KVA
 *	KVA(24 bit address) = address + sc_iobase
 *
 * on the vme/multibus we have the page map to control where ram appears
 * in the address space.   we choose to have RAM start at 0 in the
 * 24 bit address space.   this means that sc_iobase == sc_maddr!
 * to get the phyiscal address of the board's RAM you must take the
 * top 12 bits of the physical address of the register address
 * and or in the 4 bits from the status word as bits 17-20 (remember that
 * the board ignores the chip's top 4 address lines).
 * For example:
 *   if the register is @@ 0xffe88000, then the top 12 bits are 0xffe00000.
 *   to get the 4 bits from the the status word just do status & IEVME_HADDR.
 *   suppose the value is "4".	 Then just shift it left 16 bits to get
 *   it into bits 17-20 (e.g. 0x40000).	   Then or it to get the
 *   address of RAM (in our example: 0xffe40000).   see the attach routine!
 *
 * In the onboard ie interface, the 24 bit address space is hardwired
 * to be 0xff000000 -> 0xffffffff of KVA.   this means that sc_iobase
 * will be 0xff000000.	 sc_maddr will be where ever we allocate RAM
 * in KVA.    note that since the SCP is at a fixed address it means
 * that we have to use some memory at a fixed KVA for the SCP.
 * The Sun PROM leaves a page for us at the end of KVA space.
 */
struct ie_softc {
	struct device sc_dev;	/* device structure */

	struct arpcom sc_arpcom;/* system arpcom structure */
#define	sc_if	sc_arpcom.ac_if			/* network-visible interface */
#define	sc_addr	sc_arpcom.ac_enaddr		/* hardware Ethernet address */

	caddr_t sc_iobase;	/* KVA of base of 24bit addr space */
	caddr_t sc_maddr;	/* KVA of base of chip's RAM */
	u_int	sc_msize;	/* how much RAM we have/use */
	caddr_t sc_reg;		/* KVA of card's register */

	enum	ie_hardware hard_type;	/* card type */
	void	(*reset_586)(struct ie_softc *); /* three card */
	void	(*chan_attn)(struct ie_softc *); /* dependant */
	void	(*run_586)(struct ie_softc *);   /* functions */
	void	(*sc_bcopy)(const void *, void *, u_int);
	void	(*sc_bzero)(void *, u_int);

	int	want_mcsetup;	/* flag for multicast setup */
	int	promisc;	/* are we in promisc mode? */

	/*
	 * pointers to the 3 major control structures
	 */
	volatile struct ie_sys_conf_ptr *scp;
	volatile struct ie_int_sys_conf_ptr *iscp;
	volatile struct ie_sys_ctl_block *scb;

	/*
	 * pointer and size of a block of KVA where the buffers
	 * are to be allocated from
	 */
	caddr_t buf_area;
	int	buf_area_sz;

	/*
	 * the actual buffers (recv and xmit)
	 */
	volatile struct ie_recv_frame_desc *rframes[MXFRAMES];
	volatile struct ie_recv_buf_desc *rbuffs[MXRXBUF];
	volatile char *cbuffs[MXRXBUF];
	int	rfhead, rftail, rbhead, rbtail;

	volatile struct ie_xmit_cmd *xmit_cmds[NTXBUF];
	volatile struct ie_xmit_buf *xmit_buffs[NTXBUF];
	u_char *xmit_cbuffs[NTXBUF];
	int xmit_busy;
	int xmit_free;
	int xchead, xctail;

	struct ie_en_addr mcast_addrs[MAXMCAST + 1];
	int	mcast_count;

	int nframes;	  /* number of frames in use */
	int nrxbuf;	  /* number of recv buffs in use */

#ifdef IEDEBUG
	int	sc_debug;
#endif
};


extern void ie_attach(struct ie_softc *);
extern int  ie_intr(void *);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ievar.h,v 1.4 1997/01/16 04:03:48 kstailey Exp $	*/
@


1.4
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 5
a75 5
	void	(*reset_586) __P((struct ie_softc *)); /* three card */
	void	(*chan_attn) __P((struct ie_softc *)); /* dependant */
	void	(*run_586) __P((struct ie_softc *));   /* functions */
	void	(*sc_bcopy) __P((const void *, void *, u_int));
	void	(*sc_bzero) __P((void *, u_int));
d121 2
a122 2
extern void ie_attach __P((struct ie_softc *));
extern int  ie_intr __P((void *));
@


1.4.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ievar.h,v 1.4 1997/01/16 04:03:48 kstailey Exp $	*/
d71 5
a75 5
	void	(*reset_586)(struct ie_softc *); /* three card */
	void	(*chan_attn)(struct ie_softc *); /* dependant */
	void	(*run_586)(struct ie_softc *);   /* functions */
	void	(*sc_bcopy)(const void *, void *, u_int);
	void	(*sc_bzero)(void *, u_int);
d121 2
a122 2
extern void ie_attach(struct ie_softc *);
extern int  ie_intr(void *);
@


1.4.24.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ievar.h,v 1.4.24.1 2002/06/11 03:39:01 art Exp $	*/
@


1.4.14.1
log
@Merge in -current from about a week ago
@
text
@d71 5
a75 5
	void	(*reset_586)(struct ie_softc *); /* three card */
	void	(*chan_attn)(struct ie_softc *); /* dependant */
	void	(*run_586)(struct ie_softc *);   /* functions */
	void	(*sc_bcopy)(const void *, void *, u_int);
	void	(*sc_bzero)(void *, u_int);
d121 2
a122 2
extern void ie_attach(struct ie_softc *);
extern int  ie_intr(void *);
@


1.4.14.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ievar.h,v 1.4.14.1 2002/03/28 11:26:45 niklas Exp $	*/
@


1.3
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
d8 1
a8 1
#define B_PER_F         3	/* number of buffers to allocate per frame */
d33 1
a33 1
 *      KVA(16 bit offset) = offset + sc_maddr
d35 1
a35 1
 *      KVA(24 bit address) = address + sc_iobase
d47 2
a48 2
 *   suppose the value is "4".   Then just shift it left 16 bits to get
 *   it into bits 17-20 (e.g. 0x40000).    Then or it to get the
d53 1
a53 1
 * will be 0xff000000.   sc_maddr will be where ever we allocate RAM
d62 1
a62 1
#define	sc_if	sc_arpcom.ac_if 		/* network-visible interface */
d67 1
a67 1
	u_int   sc_msize;	/* how much RAM we have/use */
d70 6
a75 6
	enum ie_hardware hard_type;	/* card type */
	void    (*reset_586)();	/* card dependent reset function */
	void    (*chan_attn)();	/* card dependent attn function */
	void    (*run_586)();	/* card dependent "go on-line" function */
	void (*sc_bcopy) __P((const void *, void *, u_int));
	void (*sc_bzero) __P((void *, u_int));
d77 2
a78 2
	int     want_mcsetup;	/* flag for multicast setup */
	int     promisc;	/* are we in promisc mode? */
d92 1
a92 1
	int     buf_area_sz;
d100 1
a100 1
	int     rfhead, rftail, rbhead, rbtail;
d110 1
a110 1
	int     mcast_count;
d112 2
a113 2
	int nframes;      /* number of frames in use */
	int nrxbuf;       /* number of recv buffs in use */
d116 1
a116 1
	int     sc_debug;
d121 1
a121 1
extern void    ie_attach __P((struct ie_softc *));
@


1.2
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: if_ievar.h,v 1.7 1996/12/17 21:10:47 gwr Exp $	*/
d70 3
a72 5

	/* card dependent functions: */
	void    (*reset_586) __P((struct ie_softc *));
	void    (*chan_attn) __P((struct ie_softc *));
	void    (*run_586)   __P((struct ie_softc *));
@


1.1
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: if_ievar.h,v 1.6 1996/03/26 14:38:33 gwr Exp $	*/
d70 5
a74 3
	void    (*reset_586)();	/* card dependent reset function */
	void    (*chan_attn)();	/* card dependent attn function */
	void    (*run_586)();	/* card dependent "go on-line" function */
@
