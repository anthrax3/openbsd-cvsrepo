head	1.34;
access;
symbols
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	UBC_SYNC_A:1.34
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.33
	UBC:1.31.0.2
	UBC_BASE:1.31
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.19.0.8
	SMP_BASE:1.19
	kame_19991208:1.19
	OPENBSD_2_6:1.19.0.6
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.19.0.4
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.17.0.4
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2002.12.31.16.35.42;	author miod;	state dead;
branches;
next	1.33;

1.33
date	2002.05.16.21.11.18;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.28.16.13.29;	author art;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.25.17.15.21;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.14.09.12.21;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.27.04.44.04;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.30.20.40.04;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.05.20.56.55;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.10.18.15.43;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.08.09.40.03;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.02.23.02.14;	author todd;	state Exp;
branches;
next	1.19;

1.19
date	98.08.23.16.53.00;	author kstailey;	state Exp;
branches
	1.19.8.1;
next	1.18;

1.18
date	98.08.19.23.43.28;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.07.25.20.43.27;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.04.08.17.30.23;	author briggs;	state Exp;
branches;
next	1.15;

1.15
date	97.02.21.06.07.28;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.02.06.20.03.59;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.02.04.01.31.35;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.02.03.23.32.22;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.02.03.21.46.17;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.02.03.21.30.15;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.01.19.13.53.13;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.01.16.04.04.34;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.12.24.21.34.49;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.08.26.12;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.10.11.23.07.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.12.07.05.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.16.04.56;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.12.16.45.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.02;	author deraadt;	state Exp;
branches;
next	;

1.19.8.1
date	2000.03.24.09.08.56;	author niklas;	state Exp;
branches;
next	1.19.8.2;

1.19.8.2
date	2001.05.14.21.37.36;	author niklas;	state Exp;
branches;
next	1.19.8.3;

1.19.8.3
date	2001.07.04.10.24.18;	author niklas;	state Exp;
branches;
next	1.19.8.4;

1.19.8.4
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.19.8.5;

1.19.8.5
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.19.8.6;

1.19.8.6
date	2001.12.05.00.39.14;	author niklas;	state Exp;
branches;
next	1.19.8.7;

1.19.8.7
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.19.8.8;

1.19.8.8
date	2003.03.27.23.52.19;	author niklas;	state dead;
branches;
next	;

1.31.2.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.34
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: trap.c,v 1.33 2002/05/16 21:11:18 miod Exp $	*/
/*	$NetBSD: trap.c,v 1.63-1.65ish 1997/01/16 15:41:40 gwr Exp $	*/

/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Utah Hdr: trap.c 1.37 92/12/20
 *	from: @@(#)trap.c	8.5 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/acct.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/resourcevar.h>
#include <sys/syscall.h>
#include <sys/syslog.h>
#include <sys/user.h>
#ifdef KTRACE
#include <sys/ktrace.h>
#endif

#include "systrace.h"
#include <dev/systrace.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>

#include <machine/cpu.h>
#include <machine/db_machdep.h>
#include <machine/endian.h>
#include <machine/machdep.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/trap.h>

#ifdef COMPAT_SUNOS
#include <compat/sunos/sunos_syscall.h>
extern struct emul emul_sunos;
#endif

/* Special labels in m68k/copy.s */
extern char fubail[], subail[];

/* These are called from locore.s */
void syscall(register_t code, struct frame);
void trap(int type, u_int code, u_int v, struct frame);
int  nodb_trap(int type, struct frame *);


int astpending;
int want_resched;

char	*trap_type[] = {
	"Bus error",
	"Address error",
	"Illegal instruction",
	"Zero divide",
	"CHK instruction",
	"TRAPV instruction",
	"Privilege violation",
	"Trace trap",
	"MMU fault",
	"SSIR trap",
	"Format error",
	"68881 exception",
	"Coprocessor violation",
	"Async system trap",
	"Unused? (14)",
	"Breakpoint",
	"FPU instruction",
	"FPU data format",
};
u_int trap_types = sizeof(trap_type) / sizeof(trap_type[0]);

/*
 * Size of various exception stack frames (minus the standard 8 bytes)
 */
short	exframesize[] = {
	FMT0SIZE,	/* type 0 - normal (68020/030/040/060) */
	FMT1SIZE,	/* type 1 - throwaway (68020/030/040) */
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040/060) */
	FMT3SIZE,	/* type 3 - FP post-instruction (68040/060) */
	FMT4SIZE,	/* type 4 - access error/fp disabled (68060) */
	-1, -1, 	/* type 5-6 - undefined */
	FMT7SIZE,	/* type 7 - access error (68040) */
	58,		/* type 8 - bus fault (68010) */
	FMT9SIZE,	/* type 9 - coprocessor mid-instruction (68020/030) */
	FMTASIZE,	/* type A - short bus fault (68020/030) */
	FMTBSIZE,	/* type B - long bus fault (68020/030) */
	-1, -1, -1, -1	/* type C-F - undefined */
};

#define KDFAULT(c)	(((c) & (SSW_DF|SSW_FCMASK)) == (SSW_DF|FC_SUPERD))
#define WRFAULT(c)	(((c) & (SSW_DF|SSW_RW)) == SSW_DF)

/* #define	DEBUG XXX */

#ifdef DEBUG
int mmudebug = 0;
int mmupid = -1;
#define MDB_ISPID(p)	((p) == mmupid)
#define MDB_FOLLOW	1
#define MDB_WBFOLLOW	2
#define MDB_WBFAILED	4
#define MDB_CPFAULT 	8
#endif

/*
 * trap and syscall both need the following work done before
 * returning to user mode.
 */
/*ARGSUSED*/
void
userret(p, fp, oticks, faultaddr, fromtrap)
	struct proc *p;
	struct frame *fp;
	u_quad_t oticks;
	u_int faultaddr;
	int fromtrap;
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	p->p_priority = p->p_usrpri;

	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;
		addupc_task(p, fp->f_pc,
			    (int)(p->p_sticks - oticks) * psratio);
	}

	curpriority = p->p_priority;
}

/*
 * Trap is called from locore to handle most types of processor traps,
 * including events such as simulated software interrupts/AST's.
 * System calls are broken out for efficiency.
 */
/*ARGSUSED*/
void
trap(type, code, v, frame)
	int type;
	u_int code, v;
	struct frame frame;
{
	register struct proc *p;
	register int sig, tmp;
	u_int ucode;
	u_quad_t sticks;
	int si_type;

	uvmexp.traps++;
	p = curproc;
	ucode = 0;
	sig = 0;
	si_type = 0;

	/* I have verified that this DOES happen! -gwr */
	if (p == NULL)
		p = &proc0;
#ifdef	DIAGNOSTIC
	if (p->p_addr == NULL)
		panic("trap: no pcb");
#endif

	if (USERMODE(frame.f_sr)) {
		type |= T_USER;
		sticks = p->p_sticks;
		p->p_md.md_regs = frame.f_regs;
	} else
		sticks = 0;

	switch (type) {
	default:
	dopanic:
		printf("trap type=0x%x, code=0x%x, v=0x%x\n", type, code, v);
		/*
		 * Let the kernel debugger see the trap frame that
		 * caused us to panic.  This is a convenience so
		 * one can see registers at the point of failure.
		 */
		tmp = splhigh();
#ifdef KGDB
		/* If connected, step or cont returns 1 */
		if (kgdb_trap(type, &frame))
			goto kgdb_cont;
#endif
#ifdef	DDB
		(void) kdb_trap(type, (db_regs_t *) &frame);
#endif
#ifdef KGDB
	kgdb_cont:
#endif
		splx(tmp);
		if (panicstr) {
			/*
			 * Note: panic is smart enough to do:
			 *   boot(RB_AUTOBOOT | RB_NOSYNC, NULL)
			 * if we call it again.
			 */
			panic("trap during panic!");
		}
		regdump((struct trapframe *)&frame, 128);
		type &= ~T_USER;
		if ((u_int)type < trap_types)
			panic(trap_type[type]);
		panic("trap type 0x%x", type);

	case T_BUSERR:		/* kernel bus error */
		if (p == NULL || p->p_addr->u_pcb.pcb_onfault == NULL)
			goto dopanic;
		/*FALLTHROUGH*/

	copyfault:
		/*
		 * If we have arranged to catch this fault in any of the
		 * copy to/from user space routines, set PC to return to
		 * indicated location and set flag informing buserror code
		 * that it may need to clean up stack frame.
		 */
		frame.f_stackadj = exframesize[frame.f_format];
		frame.f_format = frame.f_vector = 0;
		frame.f_pc = (int) p->p_addr->u_pcb.pcb_onfault;
		return;

	case T_BUSERR|T_USER:	/* bus error */
		si_type = BUS_OBJERR;
		ucode = code & ~T_USER;
		sig = SIGBUS;
		break;
	case T_ADDRERR|T_USER:	/* address error */
		si_type = BUS_ADRALN;
		ucode = code & ~T_USER;
		sig = SIGBUS;
		break;

	case T_COPERR:		/* kernel coprocessor violation */
	case T_FMTERR|T_USER:	/* do all RTE errors come in as T_USER? */
	case T_FMTERR:		/* ...just in case... */
		/*
		 * The user has most likely trashed the RTE or FP state info
		 * in the stack frame of a signal handler.
		 */
		printf("pid %d: kernel %s exception\n", p->p_pid,
		       type==T_COPERR ? "coprocessor" : "format");
		type |= T_USER;
		p->p_sigacts->ps_sigact[SIGILL] = SIG_DFL;
		tmp = sigmask(SIGILL);
		p->p_sigignore &= ~tmp;
		p->p_sigcatch  &= ~tmp;
		p->p_sigmask   &= ~tmp;
		sig = SIGILL;
		ucode = frame.f_format;
		si_type = ILL_COPROC;
		v = frame.f_pc;
		break;

	case T_COPERR|T_USER:	/* user coprocessor violation */
		/* What is a proper response here? */
		ucode = 0;
		sig = SIGFPE;
		si_type = FPE_FLTINV;
		v = frame.f_pc;
		break;

	case T_FPERR|T_USER:	/* 68881 exceptions */
		/*
		 * We pass along the 68881 status register which locore stashed
		 * in code for us.  Note that there is a possibility that the
		 * bit pattern of this register will conflict with one of the
		 * FPE_* codes defined in signal.h.  Fortunately for us, the
		 * only such codes we use are all in the range 1-7 and the low
		 * 3 bits of the status register are defined as 0 so there is
		 * no clash.
		 */
		ucode = code;
		sig = SIGFPE;
		si_type = FPE_FLTRES;
		v = frame.f_pc;
		break;

	case T_FPEMULI:		/* FPU faults in supervisor mode */
	case T_FPEMULD:
		if (nofault)	/* Doing FPU probe? */
			longjmp(nofault);
		goto dopanic;

	case T_FPEMULI|T_USER:	/* unimplemented FP instuction */
	case T_FPEMULD|T_USER:	/* unimplemented FP data type */
#ifdef	FPU_EMULATE
		sig = fpu_emulate(&frame, &p->p_addr->u_pcb.pcb_fpregs);
		si_type = 0;
		/* XXX - Deal with tracing? (frame.f_sr & PSL_T) */
#else
		uprintf("pid %d killed: no floating point support\n", p->p_pid);
		ucode = frame.f_format; /* XXX was ILL_PRIVIN_FAULT */
		sig = SIGILL;
		si_type = ILL_ILLOPC;
		v = frame.f_pc;
#endif
		break;

	case T_ILLINST|T_USER:	/* illegal instruction fault */
	case T_PRIVINST|T_USER:	/* privileged instruction fault */
		ucode = frame.f_format;
		sig = SIGILL;
		si_type = ILL_PRVOPC;
		v = frame.f_pc;
		break;

	case T_ZERODIV|T_USER:		/* Divide by zero */
		ucode = frame.f_format;
		sig = SIGFPE;
		si_type = FPE_INTDIV;
		v = frame.f_pc;
		break;

	case T_CHKINST|T_USER:		/* CHK instruction trap */
		ucode = frame.f_format;
		sig = SIGFPE;
		si_type = FPE_FLTSUB;
		v = frame.f_pc;
		break;

	case T_TRAPVINST|T_USER:	/* TRAPV instruction trap */
		ucode = frame.f_format;
		sig = SIGILL;
		si_type = ILL_ILLTRP;
		v = frame.f_pc;
		break;

	/*
	 * XXX: Trace traps are a nightmare.
	 *
	 *	HP-UX uses trap #1 for breakpoints,
	 *	OpenBSD/m68k uses trap #2,
	 *	SUN 3.x uses trap #15,
	 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere).
	 *
	 * OpenBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
	 * SUN 3.x traps get passed through as T_TRAP15 and are not really
	 * supported yet.
	 *
	 * XXX: We should never get kernel-mode T_TRACE or T_TRAP15
	 * XXX: because locore.s now gives them special treatment.
	 */
	case T_TRACE:		/* kernel trace trap */
	case T_TRAP15:		/* kernel breakpoint */
		frame.f_sr &= ~PSL_T;
		return;

	case T_TRACE|T_USER:	/* user trace trap */
	case T_TRAP15|T_USER:	/* SUN user trace trap */
#ifdef COMPAT_SUNOS
		/*
		 * SunOS uses Trap #2 for a "CPU cache flush"
		 * Just flush the on-chip caches and return.
		 * XXX - Too bad OpenBSD uses trap 2...
  		 */
		if (p->p_emul == &emul_sunos) {
			ICIA();
			DCIU();
			/* get out fast */
			return;
		}
#endif
		frame.f_sr &= ~PSL_T;
		sig = SIGTRAP;
		break;

	case T_ASTFLT:		/* system async trap, cannot happen */
		goto dopanic;

	case T_ASTFLT|T_USER:	/* user async trap */
		astpending = 0;
		/* T_SSIR is not used on a Sun3. */
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		goto douret;

	case T_MMUFLT:		/* kernel mode page fault */
		/*
		 * If we were doing profiling ticks or other user mode
		 * stuff from interrupt code, Just Say No.
		 */
		if (p->p_addr->u_pcb.pcb_onfault == (caddr_t)fubail ||
		    p->p_addr->u_pcb.pcb_onfault == (caddr_t)subail)
		{
#ifdef	DEBUG
			if (mmudebug & MDB_CPFAULT) {
				printf("trap: copyfault fu/su bail\n");
				Debugger();
			}
#endif
			goto copyfault;
		}
		/*FALLTHROUGH*/

	case T_MMUFLT|T_USER: { 	/* page fault */
		vm_offset_t va;
		struct vmspace *vm = NULL;
		struct vm_map *map;
		int rv;
		vm_prot_t ftype, vftype;
		extern struct vm_map *kernel_map;

		/* vmspace only significant if T_USER */
		if (p)
			vm = p->p_vmspace;

#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
		printf("trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n",
		       p->p_pid, code, v, frame.f_pc, frame.f_sr);
#endif

		/*
		 * It is only a kernel address space fault iff:
		 * 	1. (type & T_USER) == 0  and: (2 or 3)
		 * 	2. pcb_onfault not set or
		 *	3. pcb_onfault set but supervisor space data fault
		 * The last can occur during an exec() copyin where the
		 * argument space is lazy-allocated.
		 */
		map = &vm->vm_map;
		if ((type & T_USER) == 0) {
			/* supervisor mode fault */
			if ((p->p_addr->u_pcb.pcb_onfault == NULL) || KDFAULT(code))
				map = kernel_map;
		}

		if (WRFAULT(code)) {
			vftype = VM_PROT_WRITE;
			ftype = VM_PROT_READ | VM_PROT_WRITE;
		} else
			vftype = ftype = VM_PROT_READ;
		va = trunc_page((vm_offset_t)v);

		/*
		 * Need to resolve the fault.  For user maps, we
		 * can often resolve the fault with a shortcut
		 * into the pmap module to just reload a PMEG.
		 * If that does not prodce a valid mapping,
		 * call the VM code as usual.
		 */
		if (map == kernel_map) {
			/* Do not allow faults outside the "managed" space. */
			if (va < virtual_avail) {
				if (p->p_addr->u_pcb.pcb_onfault) {
					/* XXX - Can this happen? -gwr */
#ifdef	DEBUG
					if (mmudebug & MDB_CPFAULT) {
						printf("trap: copyfault kernel_map va < avail\n");
						Debugger();
					}
#endif
					goto copyfault;
				}
				goto dopanic;
			}
		} else {
			/* User map.  Try shortcut. */
			if (pmap_fault_reload(vm->vm_map.pmap, va, ftype))
				goto finish;
		}

		/* OK, let the VM code handle the fault. */
		rv = uvm_fault(map, va, 0, ftype);
#ifdef	DEBUG
		if (rv && MDB_ISPID(p->p_pid)) {
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
			       map, va, ftype, rv);
#ifdef	DDB
			if (mmudebug & MDB_WBFAILED)
				Debugger();
#endif	/* DDB */
		}
#endif	/* DEBUG */
#ifdef VMFAULT_TRACE
		printf("vm_fault(%x, %x, %x, 0) -> %x\n",
		       map, va, ftype, rv);
		printf("  type=%x, code=%x, pc=%x\n",
		       type, code, ((int *) frame.f_regs)[PC]);
#endif
		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if ((map != kernel_map) && ((caddr_t)va >= vm->vm_maxsaddr)) {
			if (rv == 0) {
				unsigned nss;

				nss = btoc((u_int)(USRSTACK-va));
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (rv == EACCES)
				rv = EFAULT;
		}
		if (rv == 0)
			goto finish;

		if ((type & T_USER) == 0) {
			/* supervisor mode fault */
			if (p->p_addr->u_pcb.pcb_onfault) {
#ifdef	DEBUG
				if (mmudebug & MDB_CPFAULT) {
					printf("trap: copyfault pcb_onfault\n");
					Debugger();
				}
#endif
				goto copyfault;
			}
			printf("vm_fault(%p, %lx, %x, 0) -> %x\n",
			       map, va, ftype, rv);
			goto dopanic;
		}
		frame.f_pad = code & 0xffff;
		ucode = vftype;
		sig = SIGSEGV;
		si_type = SEGV_MAPERR;
		break;
	} /* T_MMUFLT */
	} /* switch */

finish:
	/* If trap was from supervisor mode, just return. */
	if ((type & T_USER) == 0)
		return;
	/* Post a signal if necessary. */
	if (sig != 0) {
		union sigval sv;

		sv.sival_int = v;
		trapsignal(p, sig, ucode, si_type, sv);
	}
douret:
	userret(p, &frame, sticks, 0, 0);
}

/*
 * Process a system call.
 */
void
syscall(code, frame)
	register_t code;
	struct frame frame;
{
	register caddr_t params;
	register struct sysent *callp;
	register struct proc *p;
	int error, opc, nsys;
	size_t argsize;
	register_t args[8], rval[2];
	u_quad_t sticks;

	uvmexp.syscalls++;
	if (!USERMODE(frame.f_sr))
		panic("syscall");
	p = curproc;
	sticks = p->p_sticks;
	p->p_md.md_regs = frame.f_regs;
	opc = frame.f_pc;

	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;

#ifdef COMPAT_SUNOS
	if (p->p_emul == &emul_sunos) {
		/*
		 * SunOS passes the syscall-number on the stack, whereas
		 * BSD passes it in D0. So, we have to get the real "code"
		 * from the stack, and clean up the stack, as SunOS glue
		 * code assumes the kernel pops the syscall argument the
		 * glue pushed on the stack. Sigh...
		 */
		code = fuword((caddr_t)frame.f_regs[SP]);

		/*
		 * XXX
		 * Don't do this for sunos_sigreturn, as there's no stored pc
		 * on the stack to skip, the argument follows the syscall
		 * number without a gap.
		 */
		if (code != SUNOS_SYS_sigreturn) {
			frame.f_regs[SP] += sizeof (int);
			/*
			 * remember that we adjusted the SP,
			 * might have to undo this if the system call
			 * returns ERESTART.
			 * XXX - Use a local variable for this? -gwr
			 */
			p->p_md.md_flags |= MDP_STACKADJ;
		} else {
			/* XXX - This may be redundant (see below). */
			p->p_md.md_flags &= ~MDP_STACKADJ;
		}
	}
#endif

	params = (caddr_t)frame.f_regs[SP] + sizeof(int);

	switch (code) {
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		code = fuword(params);
		params += sizeof(int);
		/*
		 * XXX sigreturn requires special stack manipulation
		 * that is only done if entered via the sigreturn
		 * trap.  Cannot allow it here so make sure we fail.
		 */
		if (code == SYS_sigreturn)
			code = nsys;
		break;
	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
			break;
		code = fuword(params + _QUAD_LOWWORD * sizeof(int));
		params += sizeof(quad_t);
		break;
	default:
		break;
	}
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;		/* illegal */
	else
		callp += code;
	argsize = callp->sy_argsize;
	if (argsize)
		error = copyin(params, (caddr_t)args, argsize);
	else
		error = 0;
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, argsize, args);
#endif
	if (error)
		goto bad;
	rval[0] = 0;
	rval[1] = frame.f_regs[D1];
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
	switch (error) {
	case 0:
		frame.f_regs[D0] = rval[0];
		frame.f_regs[D1] = rval[1];
		frame.f_sr &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/*
		 * We always enter through a `trap' instruction, which is 2
		 * bytes, so adjust the pc by that amount.
		 */
		frame.f_pc = opc - 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		frame.f_regs[D0] = error;
		frame.f_sr |= PSL_C;	/* carry bit */
		break;
	}

#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
#ifdef COMPAT_SUNOS
	/* need new p-value for this */
	if (p->p_md.md_flags & MDP_STACKADJ) {
		p->p_md.md_flags &= ~MDP_STACKADJ;
		if (error == ERESTART)
			frame.f_regs[SP] -= sizeof (int);
	}
#endif
	userret(p, &frame, sticks, 0, 0);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
}

/*
 * This is used if we hit a kernel breakpoint or trace trap
 * when there is no debugger installed (or not attached).
 * Drop into the PROM temporarily...
 */
int
nodb_trap(type, fp)
	int type;
	struct frame *fp;
{

	if ((0 <= type) && (type < trap_types))
		printf("\r\nKernel %s,", trap_type[type]);
	else
		printf("\r\nKernel trap 0x%x,", type);
	printf(" frame=%p\r\n", fp);
	printf("\r\n*No debugger. Doing PROM abort...\r\n");
	sun3_mon_abort();
	/* OK then, just resume... */
	fp->f_sr &= ~PSL_T;
	return(1);
}
@


1.33
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2002/03/14 01:26:47 millert Exp $	*/
@


1.32
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/11/28 16:13:29 art Exp $	*/
d61 3
d710 6
a715 1
	error = (*callp->sy_call)(p, args, rval);
@


1.31
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/11/28 13:47:39 art Exp $	*/
d81 3
a83 3
void syscall __P((register_t code, struct frame));
void trap __P((int type, u_int code, u_int v, struct frame));
int  nodb_trap __P((int type, struct frame *));
@


1.31.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/11/28 16:13:29 art Exp $	*/
a60 3
#include "systrace.h"
#include <dev/systrace.h>

d81 3
a83 3
void syscall(register_t code, struct frame);
void trap(int type, u_int code, u_int v, struct frame);
int  nodb_trap(int type, struct frame *);
d707 1
a707 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
@


1.31.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.2.1 2002/06/11 03:39:01 art Exp $	*/
@


1.30
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/11/25 17:15:21 miod Exp $	*/
d454 3
a456 3
		register vm_offset_t va;
		register struct vmspace *vm = NULL;
		register vm_map_t map;
d459 1
a459 1
		extern vm_map_t kernel_map;
@


1.29
log
@Harmonize userret() prototypes across m68k arches.
XXX The userret() code is not factorized out yet, as this will require
XXX insane amiga cleaning work.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2001/11/06 19:53:16 miod Exp $	*/
d547 1
a547 1
			if (rv == KERN_SUCCESS) {
d553 2
a554 2
			} else if (rv == KERN_PROTECTION_FAILURE)
				rv = KERN_INVALID_ADDRESS;
d556 1
a556 1
		if (rv == KERN_SUCCESS)
@


1.28
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/11/06 18:41:10 art Exp $	*/
a88 2
void userret __P((struct proc *, struct frame *, u_quad_t));

d148 1
d150 3
a152 3
userret(p, fp, oticks)
	register struct proc *p;
	register struct frame *fp;
d154 2
d594 1
a594 1
	userret(p, &frame, sticks);
d744 1
a744 1
	userret(p, &frame, sticks);
@


1.27
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2001/09/14 09:12:21 art Exp $	*/
d61 2
a62 2
#include <vm/vm.h>
#include <vm/pmap.h>
@


1.26
log
@Unbreak trap(), simplify userret().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2001/06/27 04:44:04 art Exp $	*/
d89 1
a89 1
static void userret __P((struct proc *, struct frame *, u_quad_t));
d150 1
a150 1
static void
a746 26
#endif
}

/*
 * Set up return-value registers as fork() libc stub expects,
 * and do normal return-to-user-mode stuff.
 */
void
child_return(p)
	void *p;
{
	struct frame *f;

	f = (struct frame *)((struct proc *)p)->p_md.md_regs;
	f->f_regs[D0] = 0;
	f->f_sr &= ~PSL_C;
	f->f_format = FMT0;

	/*
	 * Old ticks (3rd arg) is zero so we will charge the child
	 * for any clock ticks that might happen before this point.
	 */
	userret((struct proc *)p, f, 0);
#ifdef KTRACE
	if (KTRPOINT((struct proc *)p, KTR_SYSRET))
		ktrsysret(((struct proc *)p), SYS_fork, 0, 0);
@


1.25
log
@Zap old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2001/05/30 20:40:04 miod Exp $	*/
d156 1
a156 1
	int sig, s;
d166 1
a166 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we mi_switch()'ed, we might not be on the queue
		 * indicated by our priority.
d168 1
a168 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
d254 1
a254 1
		regdump(&frame, 128);
@


1.24
log
@Preliminary UVM support. UVM kernels don't work for the moment, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2001/05/05 20:56:55 art Exp $	*/
a211 1
#ifdef UVM
a212 3
#else
	cnt.v_trap++;
#endif
a529 1
#ifdef UVM
a530 3
#else
		rv = vm_fault(map, va, ftype, FALSE);
#endif
a620 1
#ifdef UVM
a621 3
#else
	cnt.v_syscall++;
#endif
@


1.23
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2000/11/10 18:15:43 art Exp $	*/
d212 3
d216 1
d534 3
d538 1
d629 3
d633 1
@


1.22
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2000/06/08 09:40:03 art Exp $	*/
d558 1
a558 1
				nss = clrnd(btoc((u_int)(USRSTACK-va)));
@


1.21
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2000/03/02 23:02:14 todd Exp $	*/
d709 1
a709 1
		ktrsyscall(p->p_tracep, code, argsize, args);
d755 1
a755 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d781 1
a781 1
		ktrsysret(((struct proc *)p)->p_tracep, SYS_fork, 0, 0);
@


1.20
log
@sun3 is alive, thanks to Miod Vallat <miodrag@@ifrance.com>
add ksyms, proto fix, msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 1998/08/23 16:53:00 kstailey Exp $	*/
d525 1
a525 1
			if (pmap_fault_reload(&vm->vm_pmap, va, ftype))
@


1.19
log
@optimize declaration of "union sigval sv"
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 1998/08/19 23:43:28 millert Exp $	*/
d765 1
a765 1
	struct proc *p;
d769 1
a769 1
	f = (struct frame *)p->p_md.md_regs;
d778 1
a778 1
	userret(p, f, 0);
d780 2
a781 2
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.19.8.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d765 1
a765 1
	void *p;
d769 1
a769 1
	f = (struct frame *)((struct proc *)p)->p_md.md_regs;
d778 1
a778 1
	userret((struct proc *)p, f, 0);
d780 2
a781 2
	if (KTRPOINT((struct proc *)p, KTR_SYSRET))
		ktrsysret(((struct proc *)p)->p_tracep, SYS_fork, 0, 0);
@


1.19.8.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2000/11/10 18:15:43 art Exp $	*/
d525 1
a525 1
			if (pmap_fault_reload(vm->vm_map.pmap, va, ftype))
d709 1
a709 1
		ktrsyscall(p, code, argsize, args);
d755 1
a755 1
		ktrsysret(p, code, error, rval[0]);
d781 1
a781 1
		ktrsysret(((struct proc *)p), SYS_fork, 0, 0);
@


1.19.8.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19.8.2 2001/05/14 21:37:36 niklas Exp $	*/
d212 1
a212 1
	uvmexp.traps++;
d530 1
a530 1
		rv = uvm_fault(map, va, 0, ftype);
d558 1
a558 1
				nss = btoc((u_int)(USRSTACK-va));
d621 1
a621 1
	uvmexp.syscalls++;
@


1.19.8.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19.8.3 2001/07/04 10:24:18 niklas Exp $	*/
d156 1
a156 1
	int sig;
d166 6
a171 1
		 * We're being preempted.
d173 5
a177 1
		preempt(NULL);
d263 1
a263 1
		regdump((struct trapframe *)&frame, 128);
@


1.19.8.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 2
a62 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>
d89 1
a89 1
void userret __P((struct proc *, struct frame *, u_quad_t));
d150 1
a150 1
void
d747 26
@


1.19.8.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19.8.5 2001/11/13 21:04:18 niklas Exp $	*/
d89 2
a149 1
/*ARGSUSED*/
d151 3
a153 3
userret(p, fp, oticks, faultaddr, fromtrap)
	struct proc *p;
	struct frame *fp;
a154 2
	u_int faultaddr;
	int fromtrap;
d453 3
a455 3
		vm_offset_t va;
		struct vmspace *vm = NULL;
		struct vm_map *map;
d458 1
a458 1
		extern struct vm_map *kernel_map;
d546 1
a546 1
			if (rv == 0) {
d552 2
a553 2
			} else if (rv == EACCES)
				rv = EFAULT;
d555 1
a555 1
		if (rv == 0)
d593 1
a593 1
	userret(p, &frame, sticks, 0, 0);
d743 1
a743 1
	userret(p, &frame, sticks, 0, 0);
@


1.19.8.7
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 3
a83 3
void syscall(register_t code, struct frame);
void trap(int type, u_int code, u_int v, struct frame);
int  nodb_trap(int type, struct frame *);
@


1.19.8.8
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19.8.7 2002/03/28 11:26:45 niklas Exp $	*/
@


1.18
log
@union sigval; garnett@@cs.colorado.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1997/07/25 20:43:27 kstailey Exp $	*/
a210 1
	union sigval sv;
d596 3
a598 1
		sv.sival_ptr = (void *)v;
@


1.17
log
@s/NetBSD/OpenBSD/
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 1997/04/08 17:30:23 briggs Exp $	*/
d211 1
d596 4
a599 2
	if (sig != 0)
		trapsignal(p, sig, ucode, si_type, (caddr_t)v);
@


1.16
log
@SunOS uses trap 2 to clear cpu caches.  From NetBSD via scottr and gwr.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1997/02/21 06:07:28 deraadt Exp $	*/
d418 1
a418 1
		 * XXX - Too bad NetBSD uses trap 2...
@


1.15
log
@do not pass up un-init vftype
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1997/02/06 20:03:59 kstailey Exp $	*/
d416 10
a425 6
		 * SunOS seems to use Trap #2 for some obscure fpu operations.
		 * So far, just ignore it, but DONT trap on it...
		 * (i.e. do not deliver a signal for it)
		 */
		if (p->p_emul == &emul_sunos)
			goto douret;
@


1.14
log
@adjustments to SA_SIGINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1997/02/04 01:31:35 kstailey Exp $	*/
d494 1
a494 1
			ftype = VM_PROT_READ;
@


1.13
log
@NetBSD -> OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1997/02/03 23:32:22 kstailey Exp $	*/
d315 1
d323 1
d339 1
d359 1
d368 1
d375 1
d382 1
d387 3
a389 2
		sig = SIGFPE;
		si_type = FPE_FLTOVF;
d462 1
a462 1
		vm_prot_t ftype;
d490 2
a491 1
		if (WRFAULT(code))
d493 1
a493 1
		else
d579 1
a579 1
		ucode = T_MMUFLT;
@


1.12
log
@remove DDB hack
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1997/02/03 21:46:17 kstailey Exp $	*/
d388 1
a388 1
	 *	NetBSD/m68k uses trap #2,
@


1.11
log
@closer to NetBSD 1.65
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1997/02/03 21:30:15 kstailey Exp $	*/
a431 5
#ifdef DDB
		/* Hack to avoid calling VM code from DDB. */
		if (db_recover != 0)
			goto dopanic;
#endif
@


1.10
log
@First try at SA_SIGINFO support.

Some mods in trap.c to bring it closer to NetBSD 1.65.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1997/01/19 13:53:13 niklas Exp $	*/
d89 2
d120 4
a123 3
	-1,		/* type 3 - FP post-instruction (68040/060) */
	-1, -1, -1,	/* type 4-6 - undefined */
	-1,		/* type 7 - access error (68040) */
a144 3

static void userret __P((struct proc *, struct frame *, u_quad_t));

@


1.9
log
@From Gordon W Ross (NetBSD):
Use db_regs_t instead of struct mc68020_saved_state
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.8 1997/01/16 04:04:34 kstailey Exp $	*/
/*	$NetBSD: trap.c,v 1.63 1997/01/16 15:41:40 gwr Exp $	*/
d115 1
a115 1
	FMT0SIZE,	/* type 0 - normal (68020/030/040) */
d117 2
a118 2
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040) */
	-1,		/* type 3 - FP post-instruction (68040) */
d188 1
a188 1
					(int)(p->p_sticks - oticks) * psratio);
d207 1
a207 1
	register int sig;
d210 1
d216 1
d242 1
a242 1
		sig = splhigh();
d254 1
a254 1
		splx(sig);
d256 6
a261 2
			printf("trap during panic!\n");
			sun3_mon_abort();
d270 1
a270 1
		if (p->p_addr->u_pcb.pcb_onfault == NULL)
d287 4
d292 2
a293 1
		ucode = v;
d308 5
a312 6
		/* temporary use of sig as mask */
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch  &= ~sig;
		p->p_sigmask   &= ~sig;
		sig = SIGILL;	/* back to normal */
d314 1
d321 1
d336 1
d349 1
d353 1
d355 1
d363 13
a377 2
	case T_ZERODIV|T_USER:	/* Divide by zero */
	case T_CHKINST|T_USER:	/* CHK instruction trap */
d381 1
d392 1
a392 1
	 * HPBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
d413 1
a413 1
		    break;
d432 5
d456 1
a456 1
		register struct vmspace *vm = p->p_vmspace;
d462 4
d546 1
a546 1
		if ((caddr_t)va >= vm->vm_maxsaddr && map != kernel_map) {
d574 2
a575 1
		ucode = v;
d577 1
d588 1
a588 1
		trapsignal(p, sig, ucode);
a705 6
		/*
		 * Reinitialize proc pointer `p' as it may be different
		 * if this is a child returning from fork syscall.
		 * XXX - Still needed?  Not in hp300... -gwr
		 */
		p = curproc;
@


1.8
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: trap.c,v 1.62 1996/12/17 21:35:31 gwr Exp $	*/
d247 1
a247 2
		/* XXX - Yuck!  Make DDB use "struct trapframe" instead! */
		(void) kdb_trap(type, (struct mc68020_saved_state *) &frame);
@


1.7
log
@sync with NetBSD
@
text
@d1 1
d67 1
d69 1
a70 3
#include <machine/reg.h>

#include "machdep.h"
d534 1
a534 1
			printf("vm_fault(%p, %x, %x, 0) -> %x\n",
@


1.6
log
@sync with NetBSD -- copyright changes only
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.60 1996/10/13 03:47:57 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993 Adam Glass 
d64 1
d70 2
d77 2
d80 4
a83 7
/*
 * TODO:
 *        Chris's new syscall debug stuff 
 */

extern int fubail(), subail();
extern label_t *nofault;
a84 3
/* XXX - put these in some header file? */
extern vm_offset_t virtual_avail;
extern int pmap_fault_reload(pmap_t, vm_offset_t, vm_prot_t);
d143 3
d200 1
d228 2
a229 1
	}
d247 2
a248 1
		(void) kdb_trap(type, &frame);
d250 1
d252 1
d534 1
a534 1
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
d558 1
d602 1
a602 1
			 * remember that we adjusted the SP, 
d605 1
d608 2
a609 1
		} else
d611 1
d702 5
a706 2
	if (error == ERESTART && (p->p_md.md_flags & MDP_STACKADJ))
		frame.f_regs[SP] -= sizeof (int);
d708 1
a708 1
	userret(p, &frame, sticks, (u_int)0, 0);
d734 1
a734 1
	userret(p, f, 0, (u_int)0, 0);
d756 1
a756 1
	printf(" frame=0x%x\r\n", fp);
@


1.5
log
@sync + our changes
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.57 1996/06/17 15:41:05 gwr Exp $	*/
@


1.4
log
@SIGSEGV always
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.56 1996/03/21 23:03:49 gwr Exp $	*/
a226 8
#ifdef DDB
	if (type == T_TRACE || type == T_BREAKPOINT) {
		(void)splhigh();	/* XXX - return will restore it */
		if (kdb_trap(type, &frame))
			return;
	}
#endif

d231 11
d243 1
a243 2
		if (kdb_trap(type, &frame))
			return;
d245 2
d361 3
d366 1
a366 1
	case T_TRAP15:		/* SUN trace trap */
d368 1
a368 2
		sig = SIGTRAP;
		break;
d461 1
d725 23
@


1.3
log
@sync with 0430.
@
text
@d525 1
a525 1
		sig = (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV;
@


1.2
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.55 1995/10/10 21:33:33 gwr Exp $	*/
d81 1
a81 1
extern int *nofault;
d525 1
a525 1
		sig = SIGSEGV;
@


1.1
log
@Initial revision
@
text
@d525 1
a525 1
		sig = (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
