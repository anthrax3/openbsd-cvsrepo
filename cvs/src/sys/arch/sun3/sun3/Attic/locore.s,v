head	1.24;
access;
symbols
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	UBC_SYNC_A:1.24
	OPENBSD_3_2:1.23.0.8
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.6
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.23
	UBC:1.23.0.4
	UBC_BASE:1.23
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.18.0.16
	OPENBSD_2_7_BASE:1.18
	SMP:1.18.0.14
	SMP_BASE:1.18
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.12
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.10
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.8
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.18.0.6
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.18.0.4
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.24
date	2002.12.31.16.35.41;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2001.05.30.20.40.04;	author miod;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2001.01.04.22.42.07;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.09.01.27.38;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.14.14.28.11;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.05.11.03.04;	author art;	state Exp;
branches;
next	1.18;

1.18
date	97.04.05.20.22.01;	author kstailey;	state Exp;
branches
	1.18.14.1;
next	1.17;

1.17
date	97.02.20.06.30.03;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.02.20.06.17.03;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.02.19.00.03.35;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.02.14.23.50.20;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.02.14.18.15.23;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.02.14.18.01.58;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.02.10.12.24.37;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.02.04.01.31.34;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.02.03.21.30.13;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.01.16.04.04.27;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.07.23.36.30;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.12.31.06.13.52;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.07.55.08;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.11.23.07.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.16.04.44;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches;
next	;

1.18.14.1
date	2001.05.14.21.37.35;	author niklas;	state Exp;
branches;
next	1.18.14.2;

1.18.14.2
date	2001.07.04.10.24.11;	author niklas;	state Exp;
branches;
next	1.18.14.3;

1.18.14.3
date	2003.03.27.23.52.18;	author niklas;	state dead;
branches;
next	;

1.23.4.1
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.24
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: locore.s,v 1.23 2001/05/30 20:40:04 miod Exp $	*/
/*	$NetBSD: locore.s,v 1.40 1996/11/06 20:19:54 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1980, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Utah $Hdr: locore.s 1.66 92/12/22$
 *	@@(#)locore.s	8.6 (Berkeley) 5/27/94
 */

#include "assym.h"
#include <machine/asm.h>
#include <machine/trap.h>

| Remember this is a fun project!

| This is for kvm_mkdb, and should be the address of the beginning
| of the kernel text segment (not necessarily the same as kernbase).
	.text
GLOBAL(kernel_text)

| This is the entry point, as well as the end of the temporary stack
| used during process switch (one 8K page ending at start)
ASGLOBAL(tmpstk)
ASGLOBAL(start)

| First we need to set it up so we can access the sun MMU, and be otherwise
| undisturbed.  Until otherwise noted, all code must be position independent
| as the boot loader put us low in memory, but we are linked high.
	movw	#PSL_HIGHIPL, sr	| no interrupts
	moveq	#FC_CONTROL, d0		| make movs access "control"
	movc	d0, sfc			| space where the sun3 designers
	movc	d0, dfc			| put all the "useful" stuff

| Set context zero and stay there until pmap_bootstrap.
	moveq	#0, d0
	movsb	d0, CONTEXT_REG

| In order to "move" the kernel to high memory, we are going to copy the
| first 4 Mb of pmegs such that we will be mapped at the linked address.
| This is all done by copying in the segment map (top-level MMU table).
| We will unscramble which PMEGs we actually need later.

	movl	#(SEGMAP_BASE+0), a0		| src
	movl	#(SEGMAP_BASE+KERNBASE), a1	| dst
	movl	#(0x400000/NBSG), d0		| count

L_per_pmeg:
	movsb	a0@@, d1			| copy segmap entry
	movsb	d1, a1@@
	addl	#NBSG, a0		| increment pointers
	addl	#NBSG, a1
	subql	#1, d0			| decrement count
	bgt	L_per_pmeg

| Kernel is now double mapped at zero and KERNBASE.
| Force a long jump to the relocated code (high VA).
	movl	#IC_CLEAR, d0		| Flush the I-cache
	movc	d0, cacr
	jmp L_high_code:l		| long jump

L_high_code:
| We are now running in the correctly relocated kernel, so
| we are no longer restricted to position-independent code.

| Do bootstrap stuff needed before main() gets called.
| Our boot loader leaves a copy of the kernel's exec header
| just before the start of the kernel text segment, so the
| kernel can sanity-check the DDB symbols at [end...esym].
| Pass the struct exec at tmpstk-32 to sun3_bootstrap().
| Also, make sure the initial frame pointer is zero so that
| the backtrace algorithm used by KGDB terminates nicely.
	lea	_ASM_LABEL(tmpstk)-32, sp
	movl	#0, a6
	jsr	_C_LABEL(sun3_bootstrap)

| Now that sun3_bootstrap() is done using the PROM functions,
| we can safely set the sfc/dfc to something != FC_CONTROL
	moveq	#FC_USERD, d0		| make movs access "user data"
	movc	d0, sfc			| space for copyin/copyout
	movc	d0, dfc

| Setup process zero user/kernel stacks.
	movl	_C_LABEL(proc0paddr),a1	| get proc0 pcb addr
	lea	a1@@(USPACE-4),sp	| set SSP to last word
	movl	#USRSTACK-4,a2
	movl	a2,usp			| init user SP

| Note curpcb was already set in sun3_bootstrap().
| Will do fpu initialization during autoconfig (see fpu.c)
| The interrupt vector table and stack are now ready.
| Interrupts will be enabled later, AFTER autoconfiguration
| is finished, to avoid spurious interrupts.

/*
 * Final preparation for calling main.
 *
 * Create a fake exception frame that returns to user mode,
 * and save its address in p->p_md.md_regs for cpu_fork().
 * The new frames for process 1 and 2 will be adjusted by
 * cpu_set_kpc() to arrange for a call to a kernel function
 * before the new process does its rte out to user mode.
 */
  	clrw	sp@@-			| vector offset/frame type
	clrl	sp@@-			| PC - filled in by "execve"
  	movw	#PSL_USER,sp@@-		| in user mode
	clrl	sp@@-			| stack adjust count and padding
	lea	sp@@(-64),sp		| construct space for D0-D7/A0-A7
	movl	sp,a1			| a1=trapframe
	lea	_C_LABEL(proc0),a0	| proc0 in a0
	movl	a1,a0@@(P_MD_REGS)	| save frame for proc0
	movl	a2,a1@@(FR_SP)		| a2 == usp (from above)
	pea	a1@@			| push &trapframe
	jbsr	_C_LABEL(main)		| main(&trapframe)
	addql	#4,sp			| help DDB backtrace
	trap	#15			| should not get here

| This is used by cpu_fork() to return to user mode.
| It is called with SP pointing to a struct trapframe.
GLOBAL(proc_do_uret)
	movl	sp@@(FR_SP),a0		| grab and load
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| load most registers (all but SSP)
	addql	#8,sp			| pop SSP and stack adjust count
  	rte

/*
 * proc_trampoline:
 * This is used by cpu_set_kpc() to "push" a function call onto the
 * kernel stack of some process, very much like a signal delivery.
 * When we get here, the stack has:
 *
 * SP+8:	switchframe from before cpu_set_kpc
 * SP+4:	void *proc;
 * SP:  	u_long func;
 *
 * On entry, the switchframe pushed by cpu_set_kpc has already been
 * popped off the stack, so all this needs to do is pop the function
 * pointer into a register, call it, then pop the arg, and finally
 * return using the switchframe that remains on the stack.
 */
GLOBAL(proc_trampoline)
	movl	sp@@+,a0			| function pointer
	jbsr	a0@@			| (*func)(procp)
	addql	#4,sp			| toss the arg
	rts				| as cpu_switch would do

| That is all the assembly startup code we need on the sun3!
| The rest of this is like the hp300/locore.s where possible.

/*
 * Trap/interrupt vector routines
 */
#include <m68k/m68k/trap_subr.s>

GLOBAL(buserr)
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	_C_LABEL(addrerr)	| no, handle as usual
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
GLOBAL(addrerr)
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	lea	sp@@(FR_HW),a1		| grab base of HW berr frame
	moveq	#0,d0
	movw	a1@@(10),d0		| grab SSW for fault processing
	btst	#12,d0			| RB set?
	jeq	LbeX0			| no, test RC
	bset	#14,d0			| yes, must set FB
	movw	d0,a1@@(10)		| for hardware too
LbeX0:
	btst	#13,d0			| RC set?
	jeq	LbeX1			| no, skip
	bset	#15,d0			| yes, must set FC
	movw	d0,a1@@(10)		| for hardware too
LbeX1:
	btst	#8,d0			| data fault?
	jeq	Lbe0			| no, check for hard cases
	movl	a1@@(16),d1		| fault address is as given in frame
	jra	Lbe10			| thats it
Lbe0:
	btst	#4,a1@@(6)		| long (type B) stack frame?
	jne	Lbe4			| yes, go handle
	movl	a1@@(2),d1		| no, can use save PC
	btst	#14,d0			| FB set?
	jeq	Lbe3			| no, try FC
	addql	#4,d1			| yes, adjust address
	jra	Lbe10			| done
Lbe3:
	btst	#15,d0			| FC set?
	jeq	Lbe10			| no, done
	addql	#2,d1			| yes, adjust address
	jra	Lbe10			| done
Lbe4:
	movl	a1@@(36),d1		| long format, use stage B address
	btst	#15,d0			| FC set?
	jeq	Lbe10			| no, all done
	subql	#2,d1			| yes, adjust address
Lbe10:
	movl	d1,sp@@-			| push fault VA
	movl	d0,sp@@-			| and padded SSW
	movw	a1@@(6),d0		| get frame format/vector offset
	andw	#0x0FFF,d0		| clear out frame format
	cmpw	#12,d0			| address error vector?
	jeq	Lisaerr			| yes, go to it

/*
 * the sun3 specific code
 *
 * our mission: figure out whether what we are looking at is
 *              bus error in the UNIX sense, or
 *	        a memory error i.e a page fault
 *
 * [this code replaces similarly mmu specific code in the hp300 code]
 */
sun3_mmu_specific:
	clrl d0				| make sure top bits are cleard too
	movl d1, sp@@-			| save d1
	movc sfc, d1			| save sfc to d1
	moveq #FC_CONTROL, d0		| sfc = FC_CONTROL
	movc d0, sfc
	movsb BUSERR_REG, d0		| get value of bus error register
	movc d1, sfc			| restore sfc
	movl sp@@+, d1			| restore d1
	andb #BUSERR_MMU, d0 		| is this an MMU fault?
	jeq Lisberr			| non-MMU bus error
/* End of sun3 specific code. */

Lismerr:
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lisaerr:
	movl	#T_ADDRERR,sp@@-		| mark address error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lisberr:
	movl	#T_BUSERR,sp@@-		| mark bus error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it

/*
 * FP exceptions.
 */
GLOBAL(fpfline)
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save registers
	moveq	#T_FPEMULI,d0		| denote as FP emulation trap
	jra	_ASM_LABEL(fault)	| do it

GLOBAL(fpunsupp)
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save registers
	moveq	#T_FPEMULD,d0		| denote as FP emulation trap
	jra	_ASM_LABEL(fault)	| do it

/*
 * Handles all other FP coprocessor exceptions.
 * Note that since some FP exceptions generate mid-instruction frames
 * and may cause signal delivery, we need to test for stack adjustment
 * after the trap call.
 */
GLOBAL(fpfault)
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-	| save user registers
	movl	usp,a0		| and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	movl	_C_LABEL(curpcb),a0	| current pcb
	lea	a0@@(PCB_FPCTX),a0 | address of FP savearea
	fsave	a0@@		| save state
	tstb	a0@@		| null state frame?
	jeq	Lfptnull	| yes, safe
	clrw	d0		| no, need to tweak BIU
	movb	a0@@(1),d0	| get frame size
	bset	#3,a0@@(0,d0:w)	| set exc_pend bit of BIU
Lfptnull:
	fmovem	fpsr,sp@@-	| push fpsr as code argument
	frestore a0@@		| restore state
	movl	#T_FPERR,sp@@-	| push type arg
	jra	_ASM_LABEL(faultstkadj)	| call trap and deal with stack cleanup

	.globl	_straytrap
/*
 * Other exceptions only cause four and six word stack frame and require
 * no post-trap stack adjustment.
 */
GLOBAL(badtrap)
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save std frame regs
	jbsr	_C_LABEL(straytrap)	| report
	moveml	sp@@+,#0xFFFF		| restore regs
	addql	#4, sp			| stack adjust count
	jra	_ASM_LABEL(rei)		| all done

/*
 * Trap 0 is for system calls
 */
	.globl	_syscall
GLOBAL(trap0)
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	d0,sp@@-			| push syscall number
	jbsr	_C_LABEL(syscall)	| handle it
	addql	#4,sp			| pop syscall arg
	movl	sp@@(FR_SP),a0		| grab and restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most registers
	addql	#8,sp			| pop SP and stack adjust
	jra	_ASM_LABEL(rei)		| all done

/* Use common m68k sigreturn */
#include <m68k/m68k/sigreturn.s>
	
/*
 * Trace (single-step) trap.  Kernel-mode is special.
 * User mode traps are simply passed on to trap().
 */
GLOBAL(trace)
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRACE,d0
	btst	#5,sp@@(FR_HW)		| was system mode?
	jne	_ASM_LABEL(kbrkpt)	| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault

/*
 * Trap 15 is used for:
 *	- GDB breakpoints (in user programs)
 *	- KGDB breakpoints (in the kernel)
 *	- trace traps for SUN binaries (not fully supported yet)
 * User mode traps are simply passed to trap()
 */
GLOBAL(trap15)
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRAP15,d0
	btst	#5,sp@@(FR_HW)		| was system mode?
	jne	_ASM_LABEL(kbrkpt)	| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault

ASLOCAL(kbrkpt)
	| Kernel-mode breakpoint or trace trap. (d0=trap_type)
	| Save the system sp rather than the user sp.
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	lea	sp@@(CFSIZE),a6		| Save stack pointer
	movl	a6,sp@@(FR_SP)		|  from before trap

	| If we are not on tmpstk switch to it.
	| (so debugger can change the stack pointer)
	movl	a6,d1
	cmpl	#_ASM_LABEL(tmpstk),d1
	jls	Lbrkpt2 		| already on tmpstk
	| Copy frame to the temporary stack
	movl	sp,a0			| a0=src
	lea	_ASM_LABEL(tmpstk)-96,a1	| a1=dst
	movl	a1,sp			| sp=new frame
	moveq	#CFSIZE,d1
Lbrkpt1:
	movl	a0@@+,a1@@+
	subql	#4,d1
	bgt	Lbrkpt1

Lbrkpt2:
	| Call the trap handler for the kernel debugger.
	| Do not call trap() to handle it, so that we can
	| set breakpoints in trap() if we want.  We know
	| the trap type is either T_TRACE or T_BREAKPOINT.
	| If we have both DDB and KGDB, let KGDB see it first,
	| because KGDB will just return 0 if not connected.
	| Save args in d2, a2
	movl	d0,d2			| trap type
	movl	sp,a2			| frame ptr
#ifdef	KGDB
	| Let KGDB handle it (if connected)
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
	jbsr	_C_LABEL(kgdb_trap)	| handle the trap
	addql	#8,sp			| pop args
	cmpl	#0,d0			| did kgdb handle it
	jne	Lbrkpt3			| yes, done
#endif
#ifdef	DDB
	| Let DDB handle it.
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
	jbsr	_C_LABEL(kdb_trap)	| handle the trap
	addql	#8,sp			| pop args
	cmpl	#0,d0			| did ddb handle it
	jne	Lbrkpt3			| yes, done
#endif
	| Drop into the PROM temporarily...
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
	jbsr	_C_LABEL(nodb_trap)	| handle the trap
	addql	#8,sp			| pop args
Lbrkpt3:
	| The stack pointer may have been modified, or
	| data below it modified (by kgdb push call),
	| so push the hardware frame at the current sp
	| before restoring registers and returning.
	movl	sp@@(FR_SP),a0		| modified sp
	lea	sp@@(CFSIZE),a1		| end of our frame
	movl	a1@@-,a0@@-		| copy 2 longs with
	movl	a1@@-,a0@@-		| ... predecrement
	movl	a0,sp@@(FR_SP)		| sp = h/w frame
	moveml	sp@@+,#0x7FFF		| restore all but sp
	movl	sp@@,sp			| ... and sp
	rte				| all done

/*
 * Trap 12 is the entry point for the cachectl "syscall"
 *	cachectl(command, addr, length)
 * command in d0, addr in a1, length in d1
 */
GLOBAL(trap12)
	movl	d1,sp@@-			| push length
	movl	a1,sp@@-			| push addr
	movl	d0,sp@@-			| push command
	jbsr	_C_LABEL(cachectl)	| do it
	lea	sp@@(12),sp		| pop args
	jra	_ASM_LABEL(rei)		| all done

/*
 * Trap 1 is sigreturn
 */
ENTRY_NOPROFILE(trap1)
	jra	_ASM_LABEL(sigreturn)

/*
 * Trap 2 - trace trap
 *
 * XXX SunOS uses this for a cache flush!  What do we do here?
 * XXX
 * XXX  movl    #IC_CLEAR,d0
 * XXX  movc    d0,cacr
 * XXX  rte
 */
ENTRY_NOPROFILE(trap2)
	jra     _C_LABEL(trace)

/*
 * Interrupt handlers.  Most are auto-vectored,
 * and hard-wired the same way on all sun3 models.
 * Format in the stack is:
 *   d0,d1,a0,a1, sr, pc, vo
 */

#define INTERRUPT_SAVEREG \
	moveml	#0xC0C0,sp@@-

#define INTERRUPT_RESTORE \
	moveml	sp@@+,#0x0303

/*
 * This is the common auto-vector interrupt handler,
 * for which the CPU provides the vector=0x18+level.
 * These are installed in the interrupt vector table.
 */
	.align	2
GLOBAL(_isr_autovec)
	INTERRUPT_SAVEREG
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
	jbsr	_C_LABEL(isr_autovec)	| C dispatcher
	addql	#4,sp
	INTERRUPT_RESTORE
	jra	_ASM_LABEL(rei)

/* clock: see clock.c */
	.align	2
GLOBAL(_isr_clock)
	INTERRUPT_SAVEREG 	| save a0, a1, d0, d1
	movl	_clock_va, a0
	movl	_interrupt_reg, a1
	tstb a0@@(INTERSIL_INTR_OFFSET)
	andb #~IREG_CLOCK_ENAB_5, a1@@
	orb #IREG_CLOCK_ENAB_5, a1@@
	tstb a0@@(INTERSIL_INTR_OFFSET)
| used to have "timebomb" check here...
	lea	sp@@(16),a1		| a1 = &clockframe
	movl	a1,sp@@-
	jbsr	_C_LABEL(clock_intr)
	addql	#4,sp
	INTERRUPT_RESTORE
	jra	_ASM_LABEL(rei)

| Handler for all vectored interrupts (i.e. VME interrupts)
	.align	2
GLOBAL(_isr_vectored)
	INTERRUPT_SAVEREG
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
	jbsr	_C_LABEL(isr_vectored)	| C dispatcher
	addql	#4,sp			|
	INTERRUPT_RESTORE
	jra	_ASM_LABEL(rei)		| all done

#undef	INTERRUPT_SAVEREG
#undef	INTERRUPT_RESTORE

/* interrupt counters (needed by vmstat) */
GLOBAL(intrnames)
	.asciz	"spur"	| 0
	.asciz	"lev1"	| 1
	.asciz	"lev2"	| 2
	.asciz	"lev3"	| 3
	.asciz	"lev4"	| 4
	.asciz	"clock"	| 5
	.asciz	"lev6"	| 6
	.asciz	"nmi"	| 7
GLOBAL(eintrnames)

	.data
	.even
GLOBAL(intrcnt)
	.long	0,0,0,0,0,0,0,0,0,0
GLOBAL(eintrcnt)
	.text

/*
 * Emulation of VAX REI instruction.
 *
 * This code is (mostly) un-altered from the hp300 code,
 * except that sun machines do not need a simulated SIR
 * because they have a real software interrupt register.
 *
 * This code deals with checking for and servicing ASTs
 * (profiling, scheduling) and software interrupts (network, softclock).
 * We check for ASTs first, just like the VAX.  To avoid excess overhead
 * the T_ASTFLT handling code will also check for software interrupts so we
 * do not have to do it here.  After identifying that we need an AST we
 * drop the IPL to allow device interrupts.
 *
 * This code is complicated by the fact that sendsig may have been called
 * necessitating a stack cleanup.
 */

ASGLOBAL(rei)
#ifdef	DIAGNOSTIC
	tstl	_C_LABEL(panicstr)	| have we paniced?
	jne	Ldorte			| yes, do not make matters worse
#endif
	tstl	_C_LABEL(astpending)	| AST pending?
	jeq	Ldorte			| no, done
Lrei1:
	btst	#5,sp@@			| yes, are we returning to user mode?
	jne	Ldorte			| no, done
	movw	#PSL_LOWIPL,sr		| lower SPL
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_ASTFLT,sp@@-		| type == async system trap
	jbsr	_C_LABEL(trap)		| go handle it
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
	jne	Laststkadj		| yes, go to it
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SP and stack adjust
	rte				| and do real RTE
Laststkadj:
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
Ldorte:
	rte				| real return

/*
 * Initialization is at the beginning of this file, because the
 * kernel entry point needs to be at zero for compatibility with
 * the Sun boot loader.  This works on Sun machines because the
 * interrupt vector table for reset is NOT at address zero.
 * (The MMU has a "boot" bit that forces access to the PROM)
 */

/*
 * Use common m68k sigcode.
 */
#include <m68k/m68k/sigcode.s>

	.text

/*
 * Primitives
 */

/*
 * Use common m68k support routines.
 */
#include <m68k/m68k/support.s>

BSS(want_resched,4)

/*
 * Use common m68k process manipulation routines.
 */
#include <m68k/m68k/proc_subr.s>

| Message for Lbadsw panic
Lsw0:
	.asciz	"cpu_switch"
	.even

	.data
GLOBAL(masterpaddr)		| XXX compatibility (debuggers)
GLOBAL(curpcb)
	.long	0
ASBSS(nullpcb,SIZEOF_PCB)
	.text

/*
 * At exit of a process, do a cpu_switch for the last time.
 * Switch to a safe stack and PCB, and deallocate the process's resources.
 * The ipl is high enough to prevent the memory from being reallocated.
 */
ENTRY(switch_exit)
	movl	sp@@(4),a0		| struct proc *p
					| save state into garbage pcb
	movl	#_ASM_LABEL(nullpcb),_C_LABEL(curpcb)
	lea	_ASM_LABEL(tmpstk),sp	| goto a tmp stack
	movl	a0,sp@@-			| pass proc ptr down

        /* Schedule the vmspace and stack to be freed. */
	movl    a0,sp@@-                 | exit2(p)
	jbsr    _C_LABEL(exit2)
	lea     sp@@(4),sp               | pop args

	jra	_C_LABEL(cpu_switch)

/*
 * When no processes are on the runq, cpu_switch() branches to idle
 * to wait for something to come ready.
 */
	.data
GLOBAL(Idle_count)
	.long   0
	.text

Lidle:
	stop	#PSL_LOWIPL
GLOBAL(_Idle)
	movw	#PSL_HIGHIPL,sr
	addql   #1, _C_LABEL(Idle_count)
	tstl	_C_LABEL(whichqs)
	jeq	Lidle
	movw	#PSL_LOWIPL,sr
	jra	Lsw1

Lbadsw:
	movl	#Lsw0,sp@@-
	jbsr	_C_LABEL(panic)
	/*NOTREACHED*/

/*
 * cpu_switch()
 * Hacked for sun3
 * XXX - Arg 1 is a proc pointer (curproc) but this doesn't use it.
 * XXX - Sould we use p->p_addr instead of curpcb? -gwr
 */
ENTRY(cpu_switch)
	movl	_C_LABEL(curpcb),a1	| current pcb
	movw	sr,a1@@(PCB_PS)		| save sr before changing ipl
#ifdef notyet
	movl	_C_LABEL(curproc),sp@@-	| remember last proc running
#endif
	clrl	_C_LABEL(curproc)

Lsw1:
	/*
	 * Find the highest-priority queue that isn't empty,
	 * then take the first proc from that queue.
	 */
	clrl	d0
	lea	_C_LABEL(whichqs),a0
	movl	a0@@,d1
Lswchk:
	btst	d0,d1
	jne	Lswfnd
	addqb	#1,d0
	cmpb	#32,d0
	jne	Lswchk
	jra	_C_LABEL(_Idle)
Lswfnd:
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	movl	a0@@,d1			| and check again...
	bclr	d0,d1
	jeq	Lsw1			| proc moved, rescan
	movl	d1,a0@@			| update whichqs
	moveq	#1,d1			| double check for higher priority
	lsll	d0,d1			| process (which may have snuck in
	subql	#1,d1			| while we were finding this one)
	andl	a0@@,d1
	jeq	Lswok			| no one got in, continue
	movl	a0@@,d1
	bset	d0,d1			| otherwise put this one back
	movl	d1,a0@@
	jra	Lsw1			| and rescan
Lswok:
	movl	d0,d1
	lslb	#3,d1			| convert queue number to index
	addl	#_qs,d1			| locate queue (q)
	movl	d1,a1
	cmpl	a1@@(P_FORW),a1		| anyone on queue?
	jeq	Lbadsw			| no, panic
	movl	a1@@(P_FORW),a0		| p = q->p_forw
	movl	a0@@(P_FORW),a1@@(P_FORW)	| q->p_forw = p->p_forw
	movl	a0@@(P_FORW),a1		| q = p->p_forw
	movl	a0@@(P_BACK),a1@@(P_BACK)	| q->p_back = p->p_back
	cmpl	a0@@(P_FORW),d1		| anyone left on queue?
	jeq	Lsw2			| no, skip
	movl	_C_LABEL(whichqs),d1
	bset	d0,d1			| yes, reset bit
	movl	d1,_C_LABEL(whichqs)
Lsw2:
	movl	a0,_C_LABEL(curproc)
	clrl	_C_LABEL(want_resched)
#ifdef notyet
	movl	sp@@+,a1			| XXX - Make this work!
	cmpl	a0,a1			| switching to same proc?
	jeq	Lswdone			| yes, skip save and restore
#endif
	/*
	 * Save state of previous process in its pcb.
	 */
	movl	_C_LABEL(curpcb),a1
	moveml	#0xFCFC,a1@@(PCB_REGS)	| save non-scratch registers
	movl	usp,a2			| grab USP (a2 has been saved)
	movl	a2,a1@@(PCB_USP)		| and save it

	tstl	_C_LABEL(fputype)	| Do we have an fpu?
	jeq	Lswnofpsave		| No?  Then don't try save.
	lea	a1@@(PCB_FPCTX),a2	| pointer to FP save area
	fsave	a2@@			| save FP state
	tstb	a2@@			| null state frame?
	jeq	Lswnofpsave		| yes, all done
	fmovem	fp0-fp7,a2@@(FPF_REGS)		| save FP general regs
	fmovem	fpcr/fpsr/fpi,a2@@(FPF_FPCR)	| save FP control regs
Lswnofpsave:

	/*
	 * Now that we have saved all the registers that must be
	 * preserved, we are free to use those registers until
	 * we load the registers for the switched-to process.
	 * In this section, keep:  a0=curproc, a1=curpcb
	 */

#ifdef DIAGNOSTIC
	tstl	a0@@(P_WCHAN)
	jne	Lbadsw
	cmpb	#SRUN,a0@@(P_STAT)
	jne	Lbadsw
#endif
	clrl	a0@@(P_BACK)		| clear back link
	movl	a0@@(P_ADDR),a1		| get p_addr
	movl	a1,_C_LABEL(curpcb)

	/*
	 * Load the new VM context (new MMU root pointer)
	 */
	movl	a0@@(P_VMSPACE),a2	| vm = p->p_vmspace
#ifdef DIAGNOSTIC
	tstl	a2			| vm == VM_MAP_NULL?
	jeq	Lbadsw			| panic
#endif

	/*
	 * Call pmap_switch() to set the MMU context register
	 */
	movl	a2@@(VM_PMAP),a2		| pmap = &vm.vm_map.pmap
	pea	a2@@			| push pmap
	jbsr	_C_LABEL(pmap_switch)	| pmap_switch(pmap)
	addql	#4,sp
	movl	_C_LABEL(curpcb),a1	| restore p_addr
| Note: pmap_switch will clear the cache if needed.

	/*
	 * Reload the registers for the new process.
	 * After this point we can only use d0,d1,a0,a1
	 */
	moveml	a1@@(PCB_REGS),#0xFCFC	| reload registers
	movl	a1@@(PCB_USP),a0
	movl	a0,usp			| and USP

	tstl	_C_LABEL(fputype)	| If we don't have an fpu,
	jeq	Lres_skip		|  don't try to restore it.
	lea	a1@@(PCB_FPCTX),a0	| pointer to FP save area
	tstb	a0@@			| null state frame?
	jeq	Lresfprest		| yes, easy
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control regs
	fmovem	a0@@(FPF_REGS),fp0-fp7		| restore FP general regs
Lresfprest:
	frestore a0@@			| restore state
Lres_skip:
	movw	a1@@(PCB_PS),d0		| no, restore PS
#ifdef DIAGNOSTIC
	btst	#13,d0			| supervisor mode?
	jeq	Lbadsw			| no? panic!
#endif
	movw	d0,sr			| OK, restore PS
	moveq	#1,d0			| return 1 (for alternate returns)
	rts

/*
 * savectx(pcb)
 * Update pcb, saving current processor state.
 */
ENTRY(savectx)
	movl	sp@@(4),a1
	movw	sr,a1@@(PCB_PS)
	movl	usp,a0			| grab USP
	movl	a0,a1@@(PCB_USP)		| and save it
	moveml	#0xFCFC,a1@@(PCB_REGS)	| save non-scratch registers

	tstl	_C_LABEL(fputype)	| Do we have FPU?
	jeq	Lsavedone		| No?  Then don't save state.
	lea	a1@@(PCB_FPCTX),a0	| pointer to FP save area
	fsave	a0@@			| save FP state
	tstb	a0@@			| null state frame?
	jeq	Lsavedone		| yes, all done
	fmovem	fp0-fp7,a0@@(FPF_REGS)		| save FP general regs
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control regs
Lsavedone:
	moveq	#0,d0			| return 0
	rts

/* suline() */
/* TBIA, TBIS, TBIAS, TBIAU */

/*
 * Invalidate instruction cache
 */
ENTRY(ICIA)
	movl	#IC_CLEAR,d0
	movc	d0,cacr			| invalidate i-cache
	rts

/* DCIA, DCIS */

/*
 * Invalidate data cache.
 */
ENTRY(DCIU)
	rts

/* ICPL, ICPP, DCPL, DCPP, DCPA, DCFL, DCFP */
/* PCIA, ecacheon, ecacheoff */

/*
 * Get callers current SP value.
 * Note that simply taking the address of a local variable in a C function
 * doesn't work because callee saved registers may be outside the stack frame
 * defined by A6 (e.g. GCC generated code).
 *
 * [I don't think the ENTRY() macro will do the right thing with this -- glass]
 */
GLOBAL(getsp)
	movl	sp,d0			| get current SP
	addql	#4,d0			| compensate for return address
	rts

ENTRY(getsfc)
	movc	sfc,d0
	rts

ENTRY(getdfc)
	movc	dfc,d0
	rts

ENTRY(getvbr)
	movc vbr, d0
	rts

ENTRY(setvbr)
	movl sp@@(4), d0
	movc d0, vbr
	rts

/* loadustp, ptest_addr */

/*
 * Set processor priority level calls.  Most are implemented with
 * inline asm expansions.  However, we need one instantiation here
 * in case some non-optimized code makes external references.
 * Most places will use the inlined function param.h supplies.
 */

ENTRY(_getsr)
	clrl	d0
	movw	sr, d0
	rts

ENTRY(_spl)
	clrl	d0
	movw	sr,d0
	movl	sp@@(4),d1
	movw	d1,sr
	rts
	
ENTRY(_splraise)
	clrl	d0
	movw	sr,d0
	movl	d0,d1
	andl	#PSL_HIGHIPL,d1		| old &= PSL_HIGHIPL
	cmpl	sp@@(4),d1		| (old - new)
	bge	Lsplr
	movl	sp@@(4),d1
	movw	d1,sr
Lsplr:
	rts

/*
 * Save and restore 68881 state.
 */
ENTRY(m68881_save)
	movl	sp@@(4),a0		| save area pointer
	fsave	a0@@			| save state
	tstb	a0@@			| null state frame?
	jeq	Lm68881sdone		| yes, all done
	fmovem fp0-fp7,a0@@(FPF_REGS)		| save FP general regs
	fmovem fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control regs
Lm68881sdone:
	rts

ENTRY(m68881_restore)
	movl	sp@@(4),a0		| save area pointer
	tstb	a0@@			| null state frame?
	jeq	Lm68881rdone		| yes, easy
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control regs
	fmovem	a0@@(FPF_REGS),fp0-fp7		| restore FP general regs
Lm68881rdone:
	frestore a0@@			| restore state
	rts

/*
 * _delay(unsigned N)
 * Delay for at least (N/256) microseconds.
 * This routine depends on the variable:  delay_divisor
 * which should be set based on the CPU clock rate.
 * XXX: Currently this is set in sun3_startup.c based on the
 * XXX: CPU model but this should be determined at run time...
 */
GLOBAL(_delay)
	| d0 = arg = (usecs << 8)
	movl	sp@@(4),d0
	| d1 = delay_divisor;
	movl	_C_LABEL(delay_divisor),d1
L_delay:
	subl	d1,d0
	jgt	L_delay
	rts


| Define some addresses, mostly so DDB can print useful info.
| Not using C_LABEL() here because these symbols are never
| referenced by any C code, and if the leading underscore
| ever goes away, these lines turn into syntax errors...
	.set	_kernbase,KERNBASE
	.set	_dvma_base,DVMA_SPACE_START
	.set	_prom_start,MONSTART
	.set	_prom_base,PROM_BASE

|The end!
@


1.23
log
@Preliminary UVM support. UVM kernels don't work for the moment, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.22 2001/01/04 22:42:07 miod Exp $	*/
@


1.23.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.23 2001/05/30 20:40:04 miod Exp $	*/
@


1.22
log
@Sync with genassym.cf symbol name changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.21 2000/11/09 01:27:38 miod Exp $	*/
d815 1
a815 1
	 * Call pmap_activate() to set the MMU context register
d819 1
a819 1
	jbsr	_C_LABEL(pmap_activate)	| pmap_activate(pmap)
d822 1
a822 1
| Note: pmap_activate will clear the cache if needed.
@


1.21
log
@Do not use vm_pmap anymore. Requested by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.20 2000/07/14 14:28:11 miod Exp $	*/
d147 1
a147 1
	movl	a1,a0@@(P_MDREGS)	| save frame for proc0
d383 1
a383 1
	lea	sp@@(FR_SIZE),a6		| Save stack pointer
d395 1
a395 1
	moveq	#FR_SIZE,d1
d440 1
a440 1
	lea	sp@@(FR_SIZE),a1		| end of our frame
@


1.20
log
@Use generic m68k code when possible ; do not enable interrupts at
startup.
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.19 2000/06/05 11:03:04 art Exp $	*/
d817 1
a817 1
	lea	a2@@(VM_PMAP),a2		| pmap = &vm.vm_pmap
@


1.19
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.18 1997/04/05 20:22:01 kstailey Exp $	*/
d48 1
d51 1
a51 1
| Remember this is a fun project.  (Thanks, Adam.  I try! 8^)
d56 1
a56 2
	.globl	_kernel_text
_kernel_text:
d60 3
a62 4
	.globl tmpstk
tmpstk:
	.globl start
start:
d107 5
a111 2
	lea	tmpstk-32, sp
	jsr	_sun3_bootstrap
d113 1
a113 1
| Now that sun3_bootstrap is done using the PROM setcxsegmap
d120 1
a120 1
	movl	_proc0paddr,a1		| get proc0 pcb addr
d125 1
a125 1
| Note curpcb was already set in sun3_bootstrap.
d128 2
a129 1
	movw	#PSL_LOWIPL,sr		| lower SPL
d145 7
a151 5
	lea	_proc0,a0		| proc0 in a0
	movl	sp,a0@@(P_MDREGS)	| save frame for proc0
	movl	usp,a1
	movl	a1,sp@@(FR_SP)		| save user stack pointer in frame
	jbsr	_main			| main()
d156 1
a156 2
	.globl	_proc_do_uret
_proc_do_uret:
d178 1
a178 2
	.globl	_proc_trampoline
_proc_trampoline:
d190 1
d192 6
a197 12
	.globl _buserr, _addrerr, _illinst, _zerodiv, _chkinst
	.globl _trapvinst, _privinst, _trace, _badtrap, _fmterr
	.globl _trap0, _trap1, _trap2, _trap12, _trap15
	.globl _coperr, _fpfline, _fpunsupp

	.globl	_trap, _nofault, _longjmp
_buserr:
	tstl	_nofault		| device probe?
	jeq	_addrerr		| no, handle as usual
	movl	_nofault,sp@@-		| yes,
	jbsr	_longjmp		|  longjmp(nofault)
_addrerr:
d269 1
a269 1
	jra	Ltrapnstkadj		| and deal with it
d272 1
a272 1
	jra	Ltrapnstkadj		| and deal with it
d275 1
a275 21
Ltrapnstkadj:
	jbsr	_trap			| handle the error
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
	jne	Lstkadj			| yes, go to it
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SSP and stkadj
	jra	rei			| all done
Lstkadj:
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	jra	rei			| all done
d280 1
a280 1
_fpfline:
d284 1
a284 1
	jra	fault			| do it
d286 1
a286 1
_fpunsupp:
d290 1
a290 1
	jra	fault			| do it
d298 1
a298 2
	.globl	_fpfault
_fpfault:
d304 1
a304 1
	movl	_curpcb,a0	| current pcb
d316 1
a316 26
	jra	Ltrapnstkadj	| call trap and deal with stack cleanup

/*
 * Coprocessor and format errors can generate mid-instruction stack
 * frames and cause signal delivery hence we need to check for potential
 * stack adjustment.
 */
_coperr:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-
	movl	usp,a0		| get and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	clrl	sp@@-		| or code arg
	movl	#T_COPERR,sp@@-	| push trap type
	jra	Ltrapnstkadj	| call trap and deal with stack adjustments

_fmterr:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-
	movl	usp,a0		| get and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	clrl	sp@@-		| or code arg
	movl	#T_FMTERR,sp@@-	| push trap type
	jra	Ltrapnstkadj	| call trap and deal with stack adjustments
d318 1
d323 1
a323 47
_illinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_ILLINST,d0
	jra	fault

_zerodiv:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_ZERODIV,d0
	jra	fault

_chkinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_CHKINST,d0
	jra	fault

_trapvinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRAPVINST,d0
	jra	fault

_privinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_PRIVINST,d0
	jra	fault

	.globl	fault
fault:
	movl	usp,a0			| get and save
	movl	a0,sp@@(FR_SP)		|   the user stack pointer
	clrl	sp@@-			| no VA arg
	clrl	sp@@-			| or code arg
	movl	d0,sp@@-			| push trap type
	jbsr	_trap			| handle trap
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most user regs
	addql	#8,sp			| pop SP and stack adjust
	jra	rei			| all done

	.globl	_straytrap
_badtrap:
d326 1
a326 1
	jbsr	_straytrap		| report
d329 1
a329 1
	jra	rei			| all done
d335 1
a335 1
_trap0:
d341 1
a341 1
	jbsr	_syscall		| handle it
d347 1
a347 63
	jra	rei			| all done

/*
 * Trap 1 is either:
 * sigreturn (native OpenBSD executable)
 * breakpoint (HPUX executable)
 */
_trap1:
#if 0 /* COMPAT_HPUX */
	/* If process is HPUX, this is a user breakpoint. */
	jne	trap15			| breakpoint
#endif
	/* fall into sigreturn */

/*
 * The sigreturn() syscall comes here.  It requires special handling
 * because we must open a hole in the stack to fill in the (possibly much
 * larger) original stack frame.
 */
sigreturn:
	lea	sp@@(-84),sp		| leave enough space for largest frame
	movl	sp@@(84),sp@@		| move up current 8 byte frame
	movl	sp@@(88),sp@@(4)
	movl	#84,sp@@-		| default: adjust by 84 bytes
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	#SYS_sigreturn,sp@@-	| push syscall number
	jbsr	_syscall		| handle it
	addql	#4,sp			| pop syscall#
	movl	sp@@(FR_SP),a0		| grab and restore
	movl	a0,usp			|   user SP
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	movw	sp@@(FR_ADJ),d0		| do we need to adjust the stack?
	jeq	Lsigr1			| no, just continue
	moveq	#92,d1			| total size
	subw	d0,d1			|  - hole size = frame size
	lea	a1@@(92),a0		| destination
	addw	d1,a1			| source
	lsrw	#1,d1			| convert to word count
	subqw	#1,d1			| minus 1 for dbf
Lsigrlp:
	movw	a1@@-,a0@@-		| copy a word
	dbf	d1,Lsigrlp		| continue
	movl	a0,a1			| new HW frame base
Lsigr1:
	movl	a1,sp@@(FR_SP)		| new SP value
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	jra	rei			| all done

/*
 * Trap 2 is one of:
 * OpenBSD: not used (ignore)
 * SunOS:  Some obscure FPU operation
 * HPUX:   sigreturn
 */
_trap2:
#if 0 /* COMPAT_HPUX */
	/* XXX:	If HPUX, this is a user breakpoint. */
	jne	sigreturn
#endif
	/* fall into trace (OpenBSD or SunOS) */
d349 3
d356 1
a356 1
_trace:
d360 3
a362 4
	movw	sp@@(FR_HW),d1		| get PSW
	andw	#PSL_S,d1		| from system mode?
	jne	kbrkpt			| yes, kernel breakpoint
	jra	fault			| no, user-mode fault
d369 1
a369 1
 * User mode traps are passed simply passed to trap()
d371 1
a371 1
_trap15:
d375 3
a377 4
	movw	sp@@(FR_HW),d1		| get PSW
	andw	#PSL_S,d1		| from system mode?
	jne	kbrkpt			| yes, kernel breakpoint
	jra	fault			| no, user-mode fault
d379 2
a380 1
kbrkpt:	| Kernel-mode breakpoint or trace trap. (d0=trap_type)
d389 1
a389 1
	cmpl	#tmpstk,d1
d393 1
a393 1
	lea	tmpstk-96,a1		| a1=dst
d403 1
a403 1
	| Do not call trap() to do it, so that we can
d415 1
a415 1
	jbsr	_kgdb_trap		| handle the trap
d424 1
a424 1
	jbsr	_kdb_trap		| handle the trap
d432 1
a432 1
	jbsr	_nodb_trap		| handle the trap
a438 1

d453 1
a453 2
	.globl	_cachectl
_trap12:
d457 1
a457 1
	jbsr	_cachectl		| do it
d459 19
a477 1
	jra	rei			| all done
a491 1
.align 4
d497 2
a498 2
	.globl	__isr_autovec
__isr_autovec:
d502 1
a502 1
	jbsr	_isr_autovec		| C dispatcher
d505 1
a505 1
	jra rei			/* XXX - Just do rte here? */
d508 2
a509 3
.globl __isr_clock, _interrupt_reg, _clock_intr, _clock_va
.align 4
__isr_clock:
d520 1
a520 1
	jbsr	_clock_intr
d523 1
a523 1
	jra	rei
d527 1
a527 2
	.globl	__isr_vectored, _isr_vectored
__isr_vectored:
d531 1
a531 1
	jbsr	_isr_vectored		| C dispatcher
d534 1
a534 2
	jra	rei			| all done

d540 1
a540 2
	.globl	_intrcnt,_eintrcnt,_intrnames,_eintrnames
_intrnames:
d549 1
a549 1
_eintrnames:
d553 1
a553 1
_intrcnt:
d555 1
a555 1
_eintrcnt:
d576 1
a576 3
	.globl	_astpending
	.globl	rei
rei:
d578 1
a578 1
	tstl	_panicstr		| have we paniced?
d581 1
a581 1
	tstl	_astpending		| AST pending?
d594 1
a594 1
	jbsr	_trap			| go handle it
d625 1
a625 12
 * Signal "trampoline" code (18 bytes).  Invoked from RTE setup by sendsig().
 *
 * Stack looks like:
 *
 *	sp+0 ->	signal number
 *	sp+4	pointer to siginfo (sip)
 *	sp+8	pointer to signal context frame (scp)
 *	sp+12	address of handler
 *	sp+16	saved hardware state
 *			.
 *			.
 *	scp+0->	beginning of signal context frame
d627 2
a628 13
	.globl	_sigcode, _esigcode
	.data
	.align	2
_sigcode:	/* Found at address: 0x0DFFffdc */
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
	jsr	a0@@			| call signal handler	(2 bytes)
	addql	#4,sp			| pop signo		(2 bytes)
	trap	#1			| special syscall entry	(2 bytes)
	movl	d0,sp@@(4)		| save errno		(4 bytes)
	moveq	#1,d0			| syscall == exit	(2 bytes)
	trap	#0			| exit(errno)		(2 bytes)
	.align	2
_esigcode:
a630 2
/* XXX - hp300 still has icode here... */

a633 1
#include <machine/asm.h>
d636 1
a636 1
 * non-local gotos
d638 1
a638 6
ENTRY(setjmp)
	movl	sp@@(4),a0	| savearea pointer
	moveml	#0xFCFC,a0@@	| save d2-d7/a2-a7
	movl	sp@@,a0@@(48)	| and return address
	moveq	#0,d0		| return 0
	rts
d640 1
a640 6
ENTRY(longjmp)
	movl	sp@@(4),a0
	moveml	a0@@+,#0xFCFC
	movl	a0@@,sp@@
	moveq	#1,d0
	rts
d643 1
a643 6
 * The following primitives manipulate the run queues.
 * _whichqs tells which of the 32 queues _qs have processes in them.
 * Setrunqueue puts processes into queues, Remrunqueue removes them
 * from queues.  The running process is on no queue, other processes
 * are on a queue related to p->p_priority, divided by 4 actually to
 * shrink the 0-127 range of priorities into the 32 available queues.
d645 1
a645 80

	.globl	_whichqs,_qs,_cnt,_panic
	.globl	_curproc
	.comm	_want_resched,4

/*
 * setrunqueue(p)
 *
 * Call should be made at splclock(), and p->p_stat should be SRUN
 */
ENTRY(setrunqueue)
	movl	sp@@(4),a0
#ifdef DIAGNOSTIC
	tstl	a0@@(P_BACK)
	jne	Lset1
	tstl	a0@@(P_WCHAN)
	jne	Lset1
	cmpb	#SRUN,a0@@(P_STAT)
	jne	Lset1
#endif
	clrl	d0
	movb	a0@@(P_PRIORITY),d0
	lsrb	#2,d0
	movl	_whichqs,d1
	bset	d0,d1
	movl	d1,_whichqs
	lslb	#3,d0
	addl	#_qs,d0
	movl	d0,a0@@(P_FORW)
	movl	d0,a1
	movl	a1@@(P_BACK),a0@@(P_BACK)
	movl	a0,a1@@(P_BACK)
	movl	a0@@(P_BACK),a1
	movl	a0,a1@@(P_FORW)
	rts
#ifdef DIAGNOSTIC
Lset1:
	movl	#Lset2,sp@@-
	jbsr	_panic
Lset2:
	.asciz	"setrunqueue"
	.even
#endif

/*
 * remrunqueue(p)
 *
 * Call should be made at splclock().
 */
ENTRY(remrunqueue)
	movl	sp@@(4),a0		| proc *p
	clrl	d0
	movb	a0@@(P_PRIORITY),d0
	lsrb	#2,d0
	movl	_whichqs,d1
	bclr	d0,d1			| if ((d1 & (1 << d0)) == 0)
	jeq	Lrem2			|   panic (empty queue)
	movl	d1,_whichqs
	movl	a0@@(P_FORW),a1
	movl	a0@@(P_BACK),a1@@(P_BACK)
	movl	a0@@(P_BACK),a1
	movl	a0@@(P_FORW),a1@@(P_FORW)
	movl	#_qs,a1
	movl	d0,d1
	lslb	#3,d1
	addl	d1,a1
	cmpl	a1@@(P_FORW),a1
	jeq	Lrem1
	movl	_whichqs,d1
	bset	d0,d1
	movl	d1,_whichqs
Lrem1:
	clrl	a0@@(P_BACK)
	rts
Lrem2:
	movl	#Lrem3,sp@@-
	jbsr	_panic
Lrem3:
	.asciz	"remrunqueue"
	.even
a651 2
	.globl	_curpcb
	.globl	_masterpaddr	| XXX compatibility (debuggers)
d653 2
a654 2
_masterpaddr:			| XXX compatibility (debuggers)
_curpcb:
d656 1
a656 4
mdpflag:
	.byte	0		| copy of proc md_flags low byte
	.align	2
	.comm	nullpcb,SIZEOF_PCB
d666 3
a668 2
	movl	#nullpcb,_curpcb	| save state into garbage pcb
	lea	tmpstk,sp		| goto a tmp stack
d676 1
a676 1
	jra	_cpu_switch
d683 1
a683 2
	.globl _Idle_count
_Idle_count:
a686 1
	.globl	Idle
d689 1
a689 1
Idle:
d691 2
a692 2
	addql   #1, _Idle_count
	tstl	_whichqs
d699 1
a699 1
	jbsr	_panic
d709 1
a709 1
	movl	_curpcb,a1		| current pcb
d712 1
a712 1
	movl	_curproc,sp@@-		| remember last proc running
d714 1
a714 1
	clrl	_curproc
d722 1
a722 1
	lea	_whichqs,a0
d730 1
a730 1
	jra	Idle
d759 1
a759 1
	movl	_whichqs,d1
d761 1
a761 1
	movl	d1,_whichqs
d763 2
a764 2
	movl	a0,_curproc
	clrl	_want_resched
d773 1
a773 1
	movl	_curpcb,a1
d778 1
a778 1
	tstl	_fputype		| Do we have an fpu?
d803 1
a803 1
	movl	a1,_curpcb
d805 4
a808 2
	/* see if pmap_activate needs to be called; should remove this */
	movl	a0@@(P_VMSPACE),a2	| a2 = p->p_vmspace
d810 1
a810 1
	tstl	a2			| map == VM_MAP_NULL?
d814 4
a817 4
| Important note:  We MUST call pmap_activate to set the
| MMU context register (like setting a root table pointer).
| XXX - Eventually, want to do that here, inline.
	lea	a2@@(VM_PMAP),a2		| pmap = &vmspace.vm_pmap
d819 1
a819 1
	jbsr	_pmap_activate		| pmap_activate(pmap)
d821 1
a821 1
	movl	_curpcb,a1		| restore p_addr
d832 1
a832 1
	tstl	_fputype		| If we don't have an fpu,
d862 1
a862 1
	tstl	_fputype		| Do we have FPU?
d904 1
a904 2
	.globl	_getsp
_getsp:
d926 1
a926 1
/* loadustp */
d935 1
a935 2
ENTRY(_spl)
	movl	sp@@(4),d1
a936 6
	movw	sr,d0
	movw	d1,sr
	rts

ENTRY(getsr)
	moveq	#0, d0
d940 2
a941 1
ENTRY(_insque)
d943 2
a944 9
	movw	#PSL_HIGHIPL,sr		| atomic
	movl	sp@@(8),a0		| where to insert (after)
	movl	sp@@(4),a1		| element to insert (e)
	movl	a0@@,a1@@			| e->next = after->next
	movl	a0,a1@@(4)		| e->prev = after
	movl	a1,a0@@			| after->next = e
	movl	a1@@,a0
	movl	a1,a0@@(4)		| e->next->prev = e
	movw	d0,sr
d946 3
a948 2

ENTRY(_remque)
d950 7
a956 7
	movw	#PSL_HIGHIPL,sr		| atomic
	movl	sp@@(4),a0		| element to remove (e)
	movl	a0@@,a1
	movl	a0@@(4),a0
	movl	a0,a1@@(4)		| e->next->prev = e->prev
	movl	a1,a0@@			| e->prev->next = e->next
	movw	d0,sr
d990 1
a990 2
	.globl	__delay
__delay:
d994 1
a994 1
	movl	_delay_divisor,d1
d1002 3
a1004 1
	.globl	_kernbase
a1005 1
	.globl	_dvma_base
a1006 1
	.globl	_prom_start
a1007 1
	.globl	_prom_base
@


1.18
log
@fpu_type -> fputype
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.17 1997/02/20 06:30:03 kstailey Exp $	*/
d938 4
a941 6
	/* Free old process's u-area. */
	movl	#USPACE,sp@@-		| size of u-area
	movl	a0@@(P_ADDR),sp@@-	| address of process's u-area
	movl	_kernel_map,sp@@-	| map it was allocated in
	jbsr	_kmem_free		| deallocate it
	lea	sp@@(12),sp		| pop args
@


1.18.14.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.22 2001/01/04 22:42:07 miod Exp $	*/
a47 1
#include <machine/asm.h>
d50 1
a50 1
| Remember this is a fun project!
d55 2
a56 1
GLOBAL(kernel_text)
d60 4
a63 3
ASGLOBAL(tmpstk)
ASGLOBAL(start)

d108 2
a109 5
| Also, make sure the initial frame pointer is zero so that
| the backtrace algorithm used by KGDB terminates nicely.
	lea	_ASM_LABEL(tmpstk)-32, sp
	movl	#0, a6
	jsr	_C_LABEL(sun3_bootstrap)
d111 1
a111 1
| Now that sun3_bootstrap() is done using the PROM functions,
d118 1
a118 1
	movl	_C_LABEL(proc0paddr),a1	| get proc0 pcb addr
d123 1
a123 1
| Note curpcb was already set in sun3_bootstrap().
d126 1
a126 2
| Interrupts will be enabled later, AFTER autoconfiguration
| is finished, to avoid spurious interrupts.
d142 5
a146 7
	movl	sp,a1			| a1=trapframe
	lea	_C_LABEL(proc0),a0	| proc0 in a0
	movl	a1,a0@@(P_MD_REGS)	| save frame for proc0
	movl	a2,a1@@(FR_SP)		| a2 == usp (from above)
	pea	a1@@			| push &trapframe
	jbsr	_C_LABEL(main)		| main(&trapframe)
	addql	#4,sp			| help DDB backtrace
d151 2
a152 1
GLOBAL(proc_do_uret)
d174 2
a175 1
GLOBAL(proc_trampoline)
a186 1
#include <m68k/m68k/trap_subr.s>
d188 12
a199 6
GLOBAL(buserr)
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	_C_LABEL(addrerr)	| no, handle as usual
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
GLOBAL(addrerr)
d271 1
a271 1
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
d274 1
a274 1
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
d277 21
a297 1
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
d302 1
a302 1
GLOBAL(fpfline)
d306 1
a306 1
	jra	_ASM_LABEL(fault)	| do it
d308 1
a308 1
GLOBAL(fpunsupp)
d312 1
a312 1
	jra	_ASM_LABEL(fault)	| do it
d320 2
a321 1
GLOBAL(fpfault)
d327 1
a327 1
	movl	_C_LABEL(curpcb),a0	| current pcb
d339 26
a364 1
	jra	_ASM_LABEL(faultstkadj)	| call trap and deal with stack cleanup
a365 1
	.globl	_straytrap
d370 47
a416 1
GLOBAL(badtrap)
d419 1
a419 1
	jbsr	_C_LABEL(straytrap)	| report
d422 1
a422 1
	jra	_ASM_LABEL(rei)		| all done
d428 1
a428 1
GLOBAL(trap0)
d434 1
a434 1
	jbsr	_C_LABEL(syscall)	| handle it
d440 63
a502 1
	jra	_ASM_LABEL(rei)		| all done
a503 3
/* Use common m68k sigreturn */
#include <m68k/m68k/sigreturn.s>
	
d508 1
a508 1
GLOBAL(trace)
d512 4
a515 3
	btst	#5,sp@@(FR_HW)		| was system mode?
	jne	_ASM_LABEL(kbrkpt)	| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault
d522 1
a522 1
 * User mode traps are simply passed to trap()
d524 1
a524 1
GLOBAL(trap15)
d528 4
a531 3
	btst	#5,sp@@(FR_HW)		| was system mode?
	jne	_ASM_LABEL(kbrkpt)	| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault
d533 1
a533 2
ASLOCAL(kbrkpt)
	| Kernel-mode breakpoint or trace trap. (d0=trap_type)
d536 1
a536 1
	lea	sp@@(CFSIZE),a6		| Save stack pointer
d542 1
a542 1
	cmpl	#_ASM_LABEL(tmpstk),d1
d546 1
a546 1
	lea	_ASM_LABEL(tmpstk)-96,a1	| a1=dst
d548 1
a548 1
	moveq	#CFSIZE,d1
d556 1
a556 1
	| Do not call trap() to handle it, so that we can
d568 1
a568 1
	jbsr	_C_LABEL(kgdb_trap)	| handle the trap
d577 1
a577 1
	jbsr	_C_LABEL(kdb_trap)	| handle the trap
d585 1
a585 1
	jbsr	_C_LABEL(nodb_trap)	| handle the trap
d592 1
d594 1
a594 1
	lea	sp@@(CFSIZE),a1		| end of our frame
d607 2
a608 1
GLOBAL(trap12)
d612 1
a612 1
	jbsr	_C_LABEL(cachectl)	| do it
d614 1
a614 19
	jra	_ASM_LABEL(rei)		| all done

/*
 * Trap 1 is sigreturn
 */
ENTRY_NOPROFILE(trap1)
	jra	_ASM_LABEL(sigreturn)

/*
 * Trap 2 - trace trap
 *
 * XXX SunOS uses this for a cache flush!  What do we do here?
 * XXX
 * XXX  movl    #IC_CLEAR,d0
 * XXX  movc    d0,cacr
 * XXX  rte
 */
ENTRY_NOPROFILE(trap2)
	jra     _C_LABEL(trace)
d629 1
d635 2
a636 2
	.align	2
GLOBAL(_isr_autovec)
d640 1
a640 1
	jbsr	_C_LABEL(isr_autovec)	| C dispatcher
d643 1
a643 1
	jra	_ASM_LABEL(rei)
d646 3
a648 2
	.align	2
GLOBAL(_isr_clock)
d659 1
a659 1
	jbsr	_C_LABEL(clock_intr)
d662 1
a662 1
	jra	_ASM_LABEL(rei)
d666 2
a667 1
GLOBAL(_isr_vectored)
d671 1
a671 1
	jbsr	_C_LABEL(isr_vectored)	| C dispatcher
d674 2
a675 1
	jra	_ASM_LABEL(rei)		| all done
d681 2
a682 1
GLOBAL(intrnames)
d691 1
a691 1
GLOBAL(eintrnames)
d695 1
a695 1
GLOBAL(intrcnt)
d697 1
a697 1
GLOBAL(eintrcnt)
d718 3
a720 1
ASGLOBAL(rei)
d722 1
a722 1
	tstl	_C_LABEL(panicstr)	| have we paniced?
d725 1
a725 1
	tstl	_C_LABEL(astpending)	| AST pending?
d738 1
a738 1
	jbsr	_C_LABEL(trap)		| go handle it
d769 12
a780 1
 * Use common m68k sigcode.
d782 14
a795 1
#include <m68k/m68k/sigcode.s>
d797 1
a797 1
	.text
d802 1
d805 1
a805 1
 * Use common m68k support routines.
d807 6
a812 1
#include <m68k/m68k/support.s>
d814 6
a819 1
BSS(want_resched,4)
d822 6
a827 1
 * Use common m68k process manipulation routines.
d829 80
a908 1
#include <m68k/m68k/proc_subr.s>
d915 2
d918 2
a919 2
GLOBAL(masterpaddr)		| XXX compatibility (debuggers)
GLOBAL(curpcb)
d921 4
a924 1
ASBSS(nullpcb,SIZEOF_PCB)
d934 2
a935 3
					| save state into garbage pcb
	movl	#_ASM_LABEL(nullpcb),_C_LABEL(curpcb)
	lea	_ASM_LABEL(tmpstk),sp	| goto a tmp stack
d938 6
a943 4
        /* Schedule the vmspace and stack to be freed. */
	movl    a0,sp@@-                 | exit2(p)
	jbsr    _C_LABEL(exit2)
	lea     sp@@(4),sp               | pop args
d945 1
a945 1
	jra	_C_LABEL(cpu_switch)
d952 2
a953 1
GLOBAL(Idle_count)
d957 1
d960 1
a960 1
GLOBAL(_Idle)
d962 2
a963 2
	addql   #1, _C_LABEL(Idle_count)
	tstl	_C_LABEL(whichqs)
d970 1
a970 1
	jbsr	_C_LABEL(panic)
d980 1
a980 1
	movl	_C_LABEL(curpcb),a1	| current pcb
d983 1
a983 1
	movl	_C_LABEL(curproc),sp@@-	| remember last proc running
d985 1
a985 1
	clrl	_C_LABEL(curproc)
d993 1
a993 1
	lea	_C_LABEL(whichqs),a0
d1001 1
a1001 1
	jra	_C_LABEL(_Idle)
d1030 1
a1030 1
	movl	_C_LABEL(whichqs),d1
d1032 1
a1032 1
	movl	d1,_C_LABEL(whichqs)
d1034 2
a1035 2
	movl	a0,_C_LABEL(curproc)
	clrl	_C_LABEL(want_resched)
d1044 1
a1044 1
	movl	_C_LABEL(curpcb),a1
d1049 1
a1049 1
	tstl	_C_LABEL(fputype)	| Do we have an fpu?
d1074 1
a1074 1
	movl	a1,_C_LABEL(curpcb)
d1076 2
a1077 4
	/*
	 * Load the new VM context (new MMU root pointer)
	 */
	movl	a0@@(P_VMSPACE),a2	| vm = p->p_vmspace
d1079 1
a1079 1
	tstl	a2			| vm == VM_MAP_NULL?
d1083 4
a1086 4
	/*
	 * Call pmap_activate() to set the MMU context register
	 */
	movl	a2@@(VM_PMAP),a2		| pmap = &vm.vm_map.pmap
d1088 1
a1088 1
	jbsr	_C_LABEL(pmap_activate)	| pmap_activate(pmap)
d1090 1
a1090 1
	movl	_C_LABEL(curpcb),a1	| restore p_addr
d1101 1
a1101 1
	tstl	_C_LABEL(fputype)	| If we don't have an fpu,
d1131 1
a1131 1
	tstl	_C_LABEL(fputype)	| Do we have FPU?
d1173 2
a1174 1
GLOBAL(getsp)
d1196 1
a1196 1
/* loadustp, ptest_addr */
d1205 2
a1206 1
ENTRY(_getsr)
d1208 6
d1217 1
a1217 2
ENTRY(_spl)
	clrl	d0
d1219 9
a1227 2
	movl	sp@@(4),d1
	movw	d1,sr
d1229 2
a1230 3
	
ENTRY(_splraise)
	clrl	d0
d1232 7
a1238 7
	movl	d0,d1
	andl	#PSL_HIGHIPL,d1		| old &= PSL_HIGHIPL
	cmpl	sp@@(4),d1		| (old - new)
	bge	Lsplr
	movl	sp@@(4),d1
	movw	d1,sr
Lsplr:
d1272 2
a1273 1
GLOBAL(_delay)
d1277 1
a1277 1
	movl	_C_LABEL(delay_divisor),d1
d1285 1
a1285 3
| Not using C_LABEL() here because these symbols are never
| referenced by any C code, and if the leading underscore
| ever goes away, these lines turn into syntax errors...
d1287 1
d1289 1
d1291 1
@


1.18.14.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.18.14.1 2001/05/14 21:37:35 niklas Exp $	*/
d815 1
a815 1
	 * Call pmap_switch() to set the MMU context register
d819 1
a819 1
	jbsr	_C_LABEL(pmap_switch)	| pmap_switch(pmap)
d822 1
a822 1
| Note: pmap_switch will clear the cache if needed.
@


1.18.14.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.18.14.2 2001/07/04 10:24:11 niklas Exp $	*/
@


1.17
log
@gratituous compatibility with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.16 1997/02/20 06:17:03 kstailey Exp $	*/
d1049 1
a1049 1
	tstl	_fpu_type		| Do we have an fpu?
d1101 1
a1101 1
	tstl	_fpu_type		| If we don't have an fpu,
d1131 1
a1131 1
	tstl	_fpu_type		| Do we have FPU?
@


1.16
log
@more of same
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.15 1997/02/19 00:03:35 kstailey Exp $	*/
a94 1

d1037 1
a1037 1
	movl	sp@@+,a1
d1085 1
d1091 1
d1162 2
a1163 2
/* ICPL, ICPP, DCPL, DCPP, DCPA, DCFL, DCFP, PCIA */
/* ecacheon, ecacheoff */
a1242 2
 * Pretty awful looking since our assembler does not
 * recognize FP mnemonics.
@


1.15
log
@merge in some NetBSD pmap code
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.14 1997/02/14 23:50:20 kstailey Exp $	*/
d620 2
d909 1
a909 1

d1060 7
a1075 1
	movb	a0@@(P_MDFLAG+3),mdpflag	| low byte of p_md.md_flags
d1078 1
a1078 1
	movl	a0@@(P_VMSPACE),a0	| vmspace = p->p_vmspace
d1080 1
a1080 1
	tstl	a0			| map == VM_MAP_NULL?
d1086 2
a1087 2
	lea	a0@@(VM_PMAP),a0		| pmap = &vmspace.vm_pmap
	pea	a0@@			| push pmap
d1092 4
a1095 5
| XXX - Should do this in pmap_activeate only if context reg changed.
	movl	#IC_CLEAR,d0
	movc	d0,cacr

Lcxswdone:
@


1.14
log
@back out changes to rei function
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.13 1997/02/14 18:15:23 kstailey Exp $	*/
d664 2
a665 2
	.globl	_isr_vectored
	.globl	__isr_vectored
a1078 1
	pea	a1@@			| push pcb (at p_addr)
d1080 2
a1081 2
	jbsr	_pmap_activate		| pmap_activate(pmap, pcb)
	addql	#8,sp
@


1.13
log
@remove old #define of splx() and update rei funciton in locore.s
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.12 1997/02/14 18:01:58 kstailey Exp $	*/
a698 1
#if 0
a757 87
#else
/*
 * Emulation of VAX REI instruction.
 *
 * This code deals with checking for and servicing ASTs
 * (profiling, scheduling) and software interrupts (network, softclock).
 * We check for ASTs first, just like the VAX.  To avoid excess overhead
 * the T_ASTFLT handling code will also check for software interrupts so we
 * do not have to do it here.  After identifing that we need an AST we
 * drop the IPL to allow device interrupts.
 *
 * This code is complicated by the fact that sendsig may have been called
 * necessitating a stack cleanup.
 */
	.comm	_ssir,1
	.globl	_astpending
	.globl	rei
rei:
#ifdef	DIAGNOSTIC
	tstl	_panicstr		| have we paniced?
	jne	Ldorte			| yes, do not make matters worse
#endif
	tstl	_astpending		| AST pending?
	jeq	Lchksir			| no, go check for SIR
Lrei1:
	btst	#5,sp@@			| yes, are we returning to user mode?
	jne	Lchksir			| no, go check for SIR
	movw	#PSL_LOWIPL,sr		| lower SPL
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
Lrei2:
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_ASTFLT,sp@@-		| type == async system trap
	jbsr	_trap			| go handle it
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
	jne	Laststkadj		| yes, go to it
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SP and stack adjust
	rte				| and do real RTE
Laststkadj:
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	rte				| and do real RTE
Lchksir:
	tstb	_ssir			| SIR pending?
	jeq	Ldorte			| no, all done
	movl	d0,sp@@-			| need a scratch register
	movw	sp@@(4),d0		| get SR
	andw	#PSL_IPL7,d0		| mask all but IPL
	jne	Lnosir			| came from interrupt, no can do
	movl	sp@@+,d0			| restore scratch register
Lgotsir:
	movw	#SPL1,sr		| prevent others from servicing int
	tstb	_ssir			| too late?
	jeq	Ldorte			| yes, oh well...
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
Lsir1:
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_SSIR,sp@@-		| type == software interrupt
	jbsr	_trap			| go handle it
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| and all remaining registers
	addql	#8,sp			| pop SP and stack adjust
	rte
Lnosir:
	movl	sp@@+,d0			| restore scratch register
Ldorte:
	rte				| real return
a758 1
#endif
a1207 20
	rts

/*
 * Set processor priority level calls.  Most are implemented with
 * inline asm expansions.  However, spl0 requires special handling
 * as we need to check for our emulated software interrupts.
 */

ENTRY(spl0)
	moveq	#0,d0
	movw	sr,d0			| get old SR for return
	movw	#PSL_LOWIPL,sr		| restore new SR
	tstb	_ssir			| software interrupt pending?
	jeq	Lspldone		| no, all done
	subql	#4,sp			| make room for RTE frame
	movl	sp@@(4),sp@@(2)		| position return address
	clrw	sp@@(6)			| set frame type 0
	movw	#PSL_LOWIPL,sp@@		| and new SR
	jra	Lgotsir			| go handle it
Lspldone:
@


1.12
log
@change spl0 from macro to assember function in locore.s
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.11 1997/02/10 12:24:37 downsj Exp $	*/
d699 1
d759 87
d847 1
@


1.11
log
@Use copypage and zeropage.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.10 1997/02/04 01:31:34 kstailey Exp $	*/
d1208 20
@


1.10
log
@NetBSD -> OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.9 1997/02/03 21:30:13 kstailey Exp $	*/
a801 2

/* XXX copypage(fromaddr, toaddr) */
@


1.9
log
@First try at SA_SIGINFO support.

Some mods in trap.c to bring it closer to NetBSD 1.65.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.8 1997/01/16 04:04:27 kstailey Exp $	*/
d445 1
a445 1
 * sigreturn (native NetBSD executable)
d494 1
a494 1
 * NetBSD: not used (ignore)
d503 1
a503 1
	/* fall into trace (NetBSD or SunOS) */
@


1.8
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d773 1
a773 1
 *	sp+4	signal specific code
@


1.7
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
d250 1
a250 1
 *	
d255 1
a255 1
 * [this code replaces similarly mmu specific code in the hp300 code]	
d575 1
a575 1
	| Let DDB handle it.	
d976 1
a976 1
 * Hacked for sun3	
@


1.6
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.41 1996/12/17 21:11:31 gwr Exp $	*/
d137 1
a137 1
	clrw	sp@@-			| vector offset/frame type
d139 1
a139 1
	movw	#PSL_USER,sp@@-		| in user mode
d157 1
a157 1
	rte
d249 1
a249 1
 *
d254 1
a254 1
 * [this code replaces similarly mmu specific code in the hp300 code]
d574 1
a574 1
	| Let DDB handle it.
a618 2
 * Format in the stack is:
 *   d0,d1,a0,a1, sr, pc, vo
d627 1
d633 1
a633 2
	.align	2
	.globl	__isr_autovec, _isr_autovec
d636 4
a639 1
	jbsr	_isr_autovec
d641 1
a641 1
	jra	rei
d644 2
a645 2
	.align	2
	.globl	__isr_clock, _clock_intr
d647 10
a656 1
	INTERRUPT_SAVEREG
d658 1
d663 2
a664 2
	.align	2
	.globl	__isr_vectored, _isr_vectored
d667 4
a670 1
	jbsr	_isr_vectored
d672 2
a673 1
	jra	rei
d954 1
a954 1
	.long	0
d962 1
a962 1
	addql	#1, _Idle_count
d975 1
a975 1
 * Hacked for sun3
d1237 2
@


1.5
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.40 1996/11/06 20:19:54 cgd Exp $	*/
d137 1
a137 1
  	clrw	sp@@-			| vector offset/frame type
d139 1
a139 1
  	movw	#PSL_USER,sp@@-		| in user mode
d157 1
a157 1
  	rte
d249 1
a249 1
 *	
d254 1
a254 1
 * [this code replaces similarly mmu specific code in the hp300 code]	
d574 1
a574 1
	| Let DDB handle it.	
d619 2
a628 1
.align 4
d634 2
a635 1
	.globl	__isr_autovec
d638 1
a638 4
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
	jbsr	_isr_autovec		| C dispatcher
	addql	#4,sp
d640 1
a640 1
	jra rei			/* XXX - Just do rte here? */
d643 2
a644 2
.globl __isr_clock, _interrupt_reg, _clock_intr, _clock_va
.align 4
d646 1
a646 10
	INTERRUPT_SAVEREG 	| save a0, a1, d0, d1
	movl	_clock_va, a0
	movl	_interrupt_reg, a1
	tstb a0@@(INTERSIL_INTR_OFFSET)
	andb #~IREG_CLOCK_ENAB_5, a1@@
	orb #IREG_CLOCK_ENAB_5, a1@@
	tstb a0@@(INTERSIL_INTR_OFFSET)
| used to have "timebomb" check here...
	lea	sp@@(16),a1		| a1 = &clockframe
	movl	a1,sp@@-
a647 1
	addql	#4,sp
d652 2
a653 2
	.globl	_isr_vectored
	.globl	__isr_vectored
d656 1
a656 4
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
	jbsr	_isr_vectored		| C dispatcher
	addql	#4,sp			|
d658 1
a658 2
	jra	rei			| all done

d939 1
a939 1
	.long   0
d947 1
a947 1
	addql   #1, _Idle_count
d960 1
a960 1
 * Hacked for sun3	
a1221 2
 * Pretty awful looking since our assembler does not
 * recognize FP mnemonics.
@


1.4
log
@sync + our changes
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.39 1996/06/17 15:40:52 gwr Exp $	*/
d874 1
a874 1
 * remrq(p)
d878 1
a878 1
ENTRY(remrq)
d907 1
a907 1
	.asciz	"remrq"
@


1.3
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.38 1996/04/07 05:42:17 gwr Exp $	*/
d533 3
a535 2
kbrkpt:	| Kernel-mode breakpoint or trace trap.
	| Save system sp rather than user sp.
d540 1
a540 1
	| (allows debugger to frob the stack)
d555 33
a587 7
	| Now call the trap handler as usual.
	clrl	sp@@-			| no VA arg
	clrl	sp@@-			| or code arg
	movl	d0,sp@@-			| push trap type
	jbsr	_trap			| handle trap
	lea	sp@@(12),sp		| pop value args

@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.34 1995/12/11 02:38:13 thorpej Exp $	*/
d46 1
a46 1
#include "assym.s"
d424 3
d443 3
a445 2
 * Our native 4.3 implementation uses trap 1 as sigreturn() and trap 2
 * as a breakpoint trap.
d448 3
a450 37
	jra	sigreturn

_trap2:
	jra	_trace

/*
 * Trap 12 is the entry point for the cachectl "syscall"
 *	cachectl(command, addr, length)
 * command in d0, addr in a1, length in d1
 */
	.globl	_cachectl
_trap12:
	movl	d1,sp@@-			| push length
	movl	a1,sp@@-			| push addr
	movl	d0,sp@@-			| push command
	jbsr	_cachectl		| do it
	lea	sp@@(12),sp		| pop args
	jra	rei			| all done

/*
 * Trap 15 is used for:
 *	- KGDB traps
 *	- trace traps for SUN binaries (not fully supported yet)
 * We just pass it on and let trap() sort it all out
 */
_trap15:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
#ifdef KGDB
	moveq	#T_TRAP15,d0
	movw	sp@@(FR_HW),d1		| get PSW
	andw	#PSL_S,d1		| from user mode?
	jeq	fault			| yes, just a regular fault
	movl	d0,sp@@-
	.globl	_kgdb_trap_glue
	jbsr	_kgdb_trap_glue		| returns if no debugger
	addl	#4,sp
d452 1
a452 21
	moveq	#T_TRAP15,d0
	jra	fault

/*
 * Hit a breakpoint (trap 1 or 2) instruction.
 * Push the code and treat as a normal fault.
 */
_trace:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
#ifdef KGDB
	moveq	#T_TRACE,d0
	movw	sp@@(FR_HW),d1		| get SSW
	andw	#PSL_S,d1		| from user mode?
	jeq	fault			| no, regular fault
	movl	d0,sp@@-
	jbsr	_kgdb_trap_glue		| returns if no debugger
	addl	#4,sp
#endif
	moveq	#T_TRACE,d0
	jra	fault
d492 98
d1233 15
a1247 15
| delay(int usecs)
| Delay for "usec" microseconds.  Minimum delay is about 5 uS.
|
| This routine depends on the variable "cpuspeed"
| which should be set based on the CPU clock rate.
| XXX - Currently this is set in sun3_startup.c based on the
| CPU model but this should be determined at run time...
|
	.globl	_delay
_delay:
	| d0 = (cpuspeed * usecs)
	movel	_cpuspeed,d0
	mulsl	sp@@(4),d0
	| subtract some overhead
	moveq	#80,d1
d1249 1
a1249 4
| This loop takes 8 clocks per cycle.
Ldelay:
	subql	#8,d0
	jgt	Ldelay
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.33 1995/10/10 21:35:42 gwr Exp $	*/
a1157 76
	rts

/*
 * {ov}bcopy(from, to, len)
 * memcpy(to, from, len)
 *
 * Works for counts up to 128K.
 */
ENTRY(memcpy)
	movl	sp@@(12),d0		| get count
	jeq	Lcpyexit		| if zero, return
	movl	sp@@(8), a0		| src address
	movl	sp@@(4), a1		| dest address
	jra	Ldocopy			| jump into bcopy
ALTENTRY(ovbcopy, _bcopy)
ENTRY(bcopy)
	movl	sp@@(12),d0		| get count
	jeq	Lcpyexit		| if zero, return
	movl	sp@@(4),a0		| src address
	movl	sp@@(8),a1		| dest address
Ldocopy:
	cmpl	a1,a0			| src before dest?
	jlt	Lcpyback		| yes, copy backwards (avoids overlap)
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lcfeven			| no, go check dest
	movb	a0@@+,a1@@+		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lcpyexit		| exit if done
Lcfeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lcfbyte			| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lcfbyte			| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lcflloop:
	movl	a0@@+,a1@@+		| copy longwords
	dbf	d1,Lcflloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lcpyexit		| done if none
Lcfbyte:
	subql	#1,d0			| set up for dbf
Lcfbloop:
	movb	a0@@+,a1@@+		| copy bytes
	dbf	d0,Lcfbloop		| til done
Lcpyexit:
	rts
Lcpyback:
	addl	d0,a0			| add count to src
	addl	d0,a1			| add count to dest
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lcbeven			| no, go check dest
	movb	a0@@-,a1@@-		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lcpyexit		| exit if done
Lcbeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lcbbyte			| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lcbbyte			| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lcblloop:
	movl	a0@@-,a1@@-		| copy longwords
	dbf	d1,Lcblloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lcpyexit		| done if none
Lcbbyte:
	subql	#1,d0			| set up for dbf
Lcbbloop:
	movb	a0@@-,a1@@-		| copy bytes
	dbf	d0,Lcbbloop		| til done
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
