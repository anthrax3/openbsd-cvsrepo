head	1.24;
access;
symbols
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	UBC_SYNC_A:1.24
	OPENBSD_3_2:1.23.0.4
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.23
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2002.12.31.16.35.42;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.08.02.24.07;	author art;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.12.21.55.52;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.27.04.44.04;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.08.08.09.30;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.30.20.40.04;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.05.20.56.55;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.08.22.25.23;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.05.11.03.04;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.02.23.02.15;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	99.11.09.14.30.39;	author art;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.08.17.10.32.18;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.01.10.13.34.19;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	98.07.28.00.13.54;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.04.04.36;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.07.23.36.37;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.31.06.14.10;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.16.05.00;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.02;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.03.24.09.08.56;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.05.14.21.37.37;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.07.04.10.24.18;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2003.03.27.23.52.19;	author niklas;	state dead;
branches;
next	;

1.22.2.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.24
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.23 2002/03/14 03:16:01 millert Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.35 1996/04/26 18:38:06 gwr Exp $	*/

/*
 * Copyright (c) 1994, 1995 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Utah $Hdr: vm_machdep.c 1.21 91/04/06$
 *	from: @@(#)vm_machdep.c	8.6 (Berkeley) 1/12/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/ptrace.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/core.h>
#include <sys/exec.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/machdep.h>
#include <machine/pmap.h>
#include <machine/pte.h>
#include <machine/reg.h>


/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.  Returns 1 in the child process, 0 in the parent.
 */
void
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
{
	struct pcb *p1pcb = &p1->p_addr->u_pcb;
	struct pcb *p2pcb = &p2->p_addr->u_pcb;
	struct trapframe *p2tf;
	struct switchframe *p2sf;
	struct ksigframe {
		struct switchframe sf;
		void (*func) (void *);
		void *arg;
	} *ksfp;

	/*
	 * Before copying the PCB from the current process,
	 * make sure it is up-to-date.  (p1 == curproc)
	 */
	if (p1 == curproc)
		savectx(p1pcb);

	/* copy over the machdep part of struct proc */
	p2->p_md.md_flags = p1->p_md.md_flags;

	/* Copy pcb from proc p1 to p2. */
	bcopy(p1pcb, p2pcb, sizeof(*p2pcb));

	/* Child can start with low IPL (XXX - right?) */
	p2pcb->pcb_ps = PSL_LOWIPL;

	/*
	 * Our cpu_switch MUST always call PMAP_ACTIVATE on a
	 * process switch so there is no need to do it here.
	 * (Our PMAP_ACTIVATE call allocates an MMU context.)
	 */

	/*
	 * Create the child's kernel stack, from scratch.
	 * Pick a stack pointer, leaving room for a trapframe;
	 * copy trapframe from parent so return to user mode
	 * will be to right address, with correct registers.
	 * Leave one word unused at the end of the kernel stack
	 * so the system stack pointer stays within its stack.
	 */
	p2tf = (struct trapframe *)((char *)p2->p_addr + USPACE-4) - 1;
	p2->p_md.md_regs = (int *)p2tf;
	bcopy(p1->p_md.md_regs, p2tf, sizeof(*p2tf));

	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL)
		p2tf->tf_regs[15] = (u_int)stack + stacksize;

	/*
	 * Create a "switch frame" such that when cpu_switch returns,
	 * this process will be in proc_do_uret() going to user mode.
	 */
	p2sf = (struct switchframe *)p2tf - 1;
	p2sf->sf_pc = (u_int)proc_do_uret;
	p2pcb->pcb_regs[11] = (int)p2sf;		/* SSP */

	/* Push a ksig frame onto the kernel stack. */
	ksfp = (struct ksigframe *)p2pcb->pcb_regs[11] - 1;
	p2pcb->pcb_regs[11] = (int)ksfp;

	/* Now fill it in for proc_trampoline. */
	ksfp->sf.sf_pc = (u_int)proc_trampoline;
	ksfp->func = func;
	ksfp->arg = arg;
}

/*
 * cpu_exit is called as the last action during exit.
 * We release the address space and machine-dependent resources,
 * including the memory for the user structure and kernel stack.
 * Once finished, we call switch_exit, which switches to a temporary
 * pcb and stack and never returns.  We block memory allocation
 * until switch_exit has made things safe again.
 */
void
cpu_exit(p)
	struct proc *p;
{

	(void) splimp();
	uvmexp.swtch++;
	switch_exit(p);
	/* NOTREACHED */
}

/*
 * Do any additional state-saving necessary before swapout.
 */
void
cpu_swapout(p)
	register struct proc *p;
{

	/*
	 * This will have real work to do when we implement the
	 * context-switch optimization of not switching FPU state
	 * until the new process actually uses FPU instructions.
	 */
}

/*
 * Dump the machine specific segment at the start of a core dump.
 * This means the CPU and FPU registers.  The format used here is
 * the same one ptrace uses, so gdb can be machine independent.
 *
 * XXX - Generate Sun format core dumps for Sun executables?
 */
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	struct md_core md_core;
	struct coreseg cseg;
	int error;

	/* XXX: Make sure savectx() was done? */

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_M68K, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

	/* Save floating point registers. */
	error = process_read_fpregs(p, &md_core.freg);
	if (error)
		return error;

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_M68K, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return (0);
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the kernel map,
 * and size must be a multiple of CLSIZE.
 */
void
pagemove(from, to, size)
	register caddr_t from, to;
	size_t size;
{
	vm_offset_t pa;

#ifdef DIAGNOSTIC
	if ((size & PAGE_MASK) != 0 ||
	    ((vaddr_t)from & PAGE_MASK) != 0 ||
	    ((vaddr_t)to & PAGE_MASK) != 0)
		panic("pagemove 1");
#endif
	while (size > 0) {
		if (pmap_extract(pmap_kernel(), (vm_offset_t)from, &pa) == FALSE)
			panic("pagemove 2");
		/* this does the cache flush work itself */
		pmap_remove(pmap_kernel(),
			(vm_offset_t)from, (vm_offset_t)from + NBPG);
		pmap_enter(pmap_kernel(),
			(vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE,
			VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
		from += NBPG;
		to += NBPG;
		size -= NBPG;
	}
	pmap_update(pmap_kernel());
}

/*
 * Map an IO request into kernel virtual address space.
 * Requests fall into one of five catagories:
 *
 *	B_PHYS|B_UAREA:	User u-area swap.
 *			Address is relative to start of u-area (p_addr).
 *	B_PHYS|B_PAGET:	User page table swap.
 *			Address is a kernel VA in usrpt (Usrptmap).
 *	B_PHYS|B_DIRTY:	Dirty page push.
 *			Address is a VA in proc2's address space.
 *	B_PHYS|B_PGIN:	Kernel pagein of user pages.
 *			Address is VA in user's address space.
 *	B_PHYS:		User "raw" IO request.
 *			Address is VA in user's address space.
 *
 * All requests are (re)mapped into kernel VA space via the kernel_map
 *
 * This routine has user context and can sleep
 * (called only by physio).
 *
 * XXX we allocate KVA space by using kmem_alloc_wait which we know
 * allocates space without backing physical memory.  This implementation
 * is a total crock, the multiple mappings of these physical pages should
 * be reflected in the higher-level VM structures to avoid problems.
 */
void
vmapbuf(bp, sz)
	register struct buf *bp;
	vm_size_t sz;
{
	register vm_offset_t addr, kva;
	vm_offset_t pa;
	register vm_size_t size, off;
	register int npf;
	struct proc *p;
	register struct vm_map *map;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
	p = bp->b_proc;
	map = &p->p_vmspace->vm_map;
	bp->b_saveaddr = bp->b_data;
	addr = (vm_offset_t)bp->b_saveaddr;
	off = addr & PGOFSET;
	addr = trunc_page(addr);
	size = round_page(bp->b_bcount + off);
	kva = uvm_km_valloc_wait(kernel_map, size);
	bp->b_data = (caddr_t)(kva + off);

	npf = btoc(size);
	while (npf--) {
		if (pmap_extract(vm_map_pmap(map), (vm_offset_t)addr,
		    &pa) == FALSE)
			panic("vmapbuf: null page frame");
		pa = trunc_page(pa);	/* page type in low bits? */
#ifdef	HAVECACHE
		/* flush write-back on old mappings */
		if (cache_size)
			cache_flush_page((vm_offset_t)addr);
#endif
		pmap_enter(pmap_kernel(), kva,
			pa | PMAP_NC,
			VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
		addr += NBPG;
		kva  += NBPG;
	}
}

/*
 * Free the io mappings associated with this I/O operation.
 * The mappings in the I/O map (phys_map) were non-cached,
 * so there are no write-back modifications to flush.
 * Also note, kmem_free_wakeup will remove the mappings.
 *
 * This routine has user context and can sleep
 * (called only by physio).
 */
void
vunmapbuf(bp, sz)
	register struct buf *bp;
	vm_size_t sz;
{
	register vm_offset_t kva, pgva;
	register vm_size_t size, off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");

	kva = (vm_offset_t)bp->b_data;
	off = kva & PGOFSET;
	pgva = trunc_page(kva);
	size = round_page(bp->b_bcount + off);

	/* Actually remove mappings, which does cache flush. */
	pmap_remove(pmap_kernel(), pgva, pgva + size);
	pmap_update(pmap_kernel());

	/*
	 * Now remove the map entry, which may also call
	 * pmap_remove but that will do nothing since we
	 * already removed the actual mappings.
	 */
	uvm_km_free_wakeup(kernel_map, pgva, size);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
}

@


1.23
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/12/08 02:24:07 art Exp $	*/
@


1.22
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/11/06 18:41:10 art Exp $	*/
d122 1
a122 1
	p2tf = (struct trapframe *)((char*)p2->p_addr + USPACE-4) - 1;
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/12/08 02:24:07 art Exp $	*/
d122 1
a122 1
	p2tf = (struct trapframe *)((char *)p2->p_addr + USPACE-4) - 1;
@


1.22.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22.2.1 2002/06/11 03:39:01 art Exp $	*/
@


1.21
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/09/19 20:50:57 mickey Exp $	*/
d274 1
d372 1
@


1.20
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/08/12 21:55:52 mickey Exp $	*/
d75 2
a76 2
cpu_fork(p1, p2, stack, stacksize)
	register struct proc *p1, *p2;
d79 2
d82 9
a90 4
	register struct pcb *p1pcb = &p1->p_addr->u_pcb;
	register struct pcb *p2pcb = &p2->p_addr->u_pcb;
	register struct trapframe *p2tf;
	register struct switchframe *p2sf;
a139 44
	/*
	 * This will "push a call" to an arbitrary kernel function
	 * onto the stack of p2, very much like signal delivery.
	 * When p2 runs, it will find itself in child_return().
	 */
	cpu_set_kpc(p2, child_return, p2);
}

/*
 * cpu_set_kpc:
 *
 * Arrange for in-kernel execution of a process to continue in the
 * named function, as if that function were called with one argument,
 * the current process's process pointer.
 *
 * Note that it's assumed that when the named process returns,
 * rei() should be invoked, to return to user mode.  That is
 * accomplished by having cpu_fork set the initial frame with a
 * return address pointing to proc_do_uret() which does the rte.
 *
 * The design allows this function to be implemented as a general
 * "kernel sendsig" utility, that can "push" a call to a kernel
 * function onto any other process kernel stack, in a way very
 * similar to how signal delivery works on a user stack.  When
 * the named process is switched to, it will call the function
 * we "pushed" and then proc_trampoline will pop the args that
 * were pushed here and return to where it would have returned
 * before we "pushed" this call.
 */
void
cpu_set_kpc(prc, func, arg)
	struct proc *prc;
	void (*func) (void *);
	void *arg;
{
	struct pcb *pcbp;
	struct ksigframe {
		struct switchframe sf;
		void (*func) (void *);
		void *arg;
	} *ksfp;

	pcbp = &prc->p_addr->u_pcb;

d141 2
a142 2
	ksfp = (struct ksigframe *)pcbp->pcb_regs[11] - 1;
	pcbp->pcb_regs[11] = (int)ksfp;
@


1.19
log
@less includes
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2001/07/25 13:25:33 art Exp $	*/
a58 1
#include <vm/vm_kern.h>
@


1.18
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2001/06/27 04:44:04 art Exp $	*/
a58 1
#include <vm/vm.h>
a59 2
/* #include <vm/vm_map.h> */

@


1.17
log
@Zap old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2001/06/08 08:09:30 art Exp $	*/
d309 2
a310 2
			(vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1,
			VM_PROT_READ|VM_PROT_WRITE);
d379 1
a379 1
			VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
@


1.16
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2001/05/30 20:40:04 miod Exp $	*/
a62 1
#ifdef UVM
a63 1
#endif
a204 1
#ifdef UVM
a205 3
#else
	cnt.v_swtch++;
#endif
a362 1
#ifdef UVM
a363 3
#else
	kva = kmem_alloc_wait(kernel_map, size);
#endif
a417 1
#ifdef UVM
a418 3
#else
	kmem_free_wakeup(kernel_map, pgva, size);
#endif
@


1.15
log
@Preliminary UVM support. UVM kernels don't work for the moment, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2001/05/05 20:56:55 art Exp $	*/
d300 1
a300 1
	register vm_offset_t pa;
d309 1
a309 3
		pa = pmap_extract(pmap_kernel(), (vm_offset_t)from);
#ifdef DIAGNOSTIC
		if (pa == 0)
a310 1
#endif
d353 2
a354 1
	register vm_offset_t addr, kva, pa;
d378 3
a380 1
		pa = pmap_extract(vm_map_pmap(map), (vm_offset_t)addr);
a381 2
		if (pa == 0)
			panic("vmapbuf: null page frame");
@


1.14
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2000/06/08 22:25:23 niklas Exp $	*/
d63 4
d207 3
d211 1
d371 3
d375 1
d430 3
d434 1
@


1.13
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2000/06/08 21:12:08 niklas Exp $	*/
d295 3
a297 1
	if (size & CLOFSET || (int)from & CLOFSET || (int)to & CLOFSET)
@


1.12
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2000/03/02 23:02:15 todd Exp $	*/
d50 1
@


1.11
log
@sun3 is alive, thanks to Miod Vallat <miodrag@@ifrance.com>
add ksyms, proto fix, msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1999/08/17 10:32:18 niklas Exp $	*/
a199 2

	vmspace_free(p->p_vmspace);
@


1.10
log
@Adapt to pmap_enter changes.
@
text
@d164 3
a166 3
cpu_set_kpc(proc, func, arg)
	struct proc *proc;
	void (*func) __P((void *));
d172 1
a172 1
		void (*func)(void *);
d176 1
a176 1
	pcbp = &proc->p_addr->u_pcb;
@


1.10.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 3
a166 3
cpu_set_kpc(prc, func, arg)
	struct proc *prc;
	void (*func) (void *);
d172 1
a172 1
		void (*func) (void *);
d176 1
a176 1
	pcbp = &prc->p_addr->u_pcb;
@


1.10.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2000/06/08 22:25:23 niklas Exp $	*/
a49 1
#include <sys/signalvar.h>
d200 2
@


1.10.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10.2.2 2001/05/14 21:37:37 niklas Exp $	*/
a62 2
#include <uvm/uvm_extern.h>

d203 1
a203 1
	uvmexp.swtch++;
d292 1
a292 1
	vm_offset_t pa;
d295 1
a295 3
	if ((size & PAGE_MASK) != 0 ||
	    ((vaddr_t)from & PAGE_MASK) != 0 ||
	    ((vaddr_t)to & PAGE_MASK) != 0)
d299 3
a301 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)from, &pa) == FALSE)
d303 1
d346 1
a346 2
	register vm_offset_t addr, kva;
	vm_offset_t pa;
d361 1
a361 1
	kva = uvm_km_valloc_wait(kernel_map, size);
d366 3
a368 2
		if (pmap_extract(vm_map_pmap(map), (vm_offset_t)addr,
		    &pa) == FALSE)
a369 1
		pa = trunc_page(pa);	/* page type in low bits? */
d416 1
a416 1
	uvm_km_free_wakeup(kernel_map, pgva, size);
@


1.10.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10.2.3 2001/07/04 10:24:18 niklas Exp $	*/
d59 4
d309 2
a310 2
			(vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE,
			VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d379 1
a379 1
			VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
@


1.10.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 2
a76 2
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
a78 2
	void (*func)(void *);
	void *arg;
d80 4
a83 9
	struct pcb *p1pcb = &p1->p_addr->u_pcb;
	struct pcb *p2pcb = &p2->p_addr->u_pcb;
	struct trapframe *p2tf;
	struct switchframe *p2sf;
	struct ksigframe {
		struct switchframe sf;
		void (*func) (void *);
		void *arg;
	} *ksfp;
d133 44
d178 2
a179 2
	ksfp = (struct ksigframe *)p2pcb->pcb_regs[11] - 1;
	p2pcb->pcb_regs[11] = (int)ksfp;
@


1.10.2.6
log
@Merge in trunk
@
text
@a273 1
	pmap_update(pmap_kernel());
a370 1
	pmap_update(pmap_kernel());
@


1.10.2.7
log
@Merge in -current from about a week ago
@
text
@d122 1
a122 1
	p2tf = (struct trapframe *)((char *)p2->p_addr + USPACE-4) - 1;
@


1.10.2.8
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10.2.7 2002/03/28 11:26:45 niklas Exp $	*/
@


1.9
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 1999/01/10 13:34:19 niklas Exp $	*/
d166 1
a166 1
	void (*func)(void *);
d309 2
a310 1
			(vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1);
d378 1
a378 1
			VM_PROT_READ|VM_PROT_WRITE, TRUE);
@


1.8
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 1998/07/28 00:13:54 millert Exp $	*/
d76 1
a76 1
cpu_fork(p1, p2)
d78 2
d119 6
@


1.7
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 1997/01/16 04:04:36 kstailey Exp $	*/
d131 1
a131 1
	cpu_set_kpc(p2, child_return);
d156 1
a156 1
cpu_set_kpc(proc, func)
d158 2
a159 1
	void (*func)(struct proc *);
d164 2
a165 2
		void (*func)(struct proc *);
		void *proc;
d177 1
a177 1
	ksfp->proc = proc;
@


1.6
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d260 1
a260 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)0, p);
d266 1
a266 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)0, p);
@


1.5
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
d6 1
a6 1
 * Copyright (c) 1993 Adam Glass 
d50 1
d63 3
a66 6
#include <machine/pte.h>
#include <machine/pmap.h>

#include "cache.h"

extern int fpu_type;
d79 2
a80 1
	register struct pcb *pcb2 = &p2->p_addr->u_pcb;
a82 1
	extern void proc_do_uret(), child_return();
d88 2
a89 1
	savectx(curproc->p_addr);
d95 1
a95 1
	bcopy(&p1->p_addr->u_pcb, pcb2, sizeof(*pcb2));
d98 1
a98 1
	pcb2->pcb_ps = PSL_LOWIPL;
d124 1
a124 1
	pcb2->pcb_regs[11] = (int)p2sf;		/* SSP */
a160 2
	struct switchframe *sf;
	extern void proc_trampoline();
a235 1
	register i;
@


1.4
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.36 1996/12/17 21:11:45 gwr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993 Adam Glass
d65 1
a65 1
#include "machdep.h"
a68 2
extern void proc_do_uret __P((void));
extern void proc_trampoline __P((void));
d80 1
a80 2
	register struct pcb *p1pcb = &p1->p_addr->u_pcb;
	register struct pcb *p2pcb = &p2->p_addr->u_pcb;
d83 1
d89 1
a89 2
	if (p1 == curproc)
		savectx(p1pcb);
d95 1
a95 1
	bcopy(p1pcb, p2pcb, sizeof(*p2pcb));
d98 1
a98 1
	p2pcb->pcb_ps = PSL_LOWIPL;
d112 1
a112 1
	 * so the system stack pointer stays within the page.
d114 1
a114 1
	p2tf = (struct trapframe *)((char*)p2pcb + USPACE-4) - 1;
d124 1
a124 1
	p2pcb->pcb_regs[11] = (int)p2sf;		/* SSP */
d161 2
a217 13
 * Do any additional state-restoration after swapin.
 */
void
cpu_swapin(p)
	register struct proc *p;
{

	/*
	 * XXX - Just for debugging... (later).
	 */
}

/*
d238 1
@


1.3
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.35 1996/04/26 18:38:06 gwr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993 Adam Glass 
d65 1
a65 1
#include "cache.h"
d69 2
d82 2
a83 1
	register struct pcb *pcb2 = &p2->p_addr->u_pcb;
a85 1
	extern void proc_do_uret(), child_return();
d91 2
a92 1
	savectx(curproc->p_addr);
d98 1
a98 1
	bcopy(&p1->p_addr->u_pcb, pcb2, sizeof(*pcb2));
d101 1
a101 1
	pcb2->pcb_ps = PSL_LOWIPL;
d115 1
a115 1
	 * so the system stack pointer stays within its stack.
d117 1
a117 1
	p2tf = (struct trapframe *)((char*)p2->p_addr + USPACE-4) - 1;
d127 1
a127 1
	pcb2->pcb_regs[11] = (int)p2sf;		/* SSP */
a163 2
	struct switchframe *sf;
	extern void proc_trampoline();
d219 13
a251 1
	register i;
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.32 1995/12/09 04:37:58 mycroft Exp $	*/
a68 3
/* XXX - Put this in some header file? */
void cpu_set_kpc __P((struct proc *p, u_long func));

d131 1
a131 1
	cpu_set_kpc(p2, (long)child_return);
d158 1
a158 1
	u_long func;
d165 1
a165 1
		u_long func;
d282 1
d285 1
a285 1
	int size;
a309 2
extern vm_map_t phys_map;

d325 1
a325 2
 * All requests are (re)mapped into kernel VA space via the phys_map
 * (a name with only slightly more meaning than "kernelmap")
d335 2
a336 1
vmapbuf(bp)
d338 1
d340 2
a342 2
	register caddr_t addr;
	register long flags = bp->b_flags;
d344 1
a344 3
	int off;
	vm_offset_t kva;
	register vm_offset_t pa;
d346 1
a346 1
	if ((flags & B_PHYS) == 0)
a347 2
	addr = bp->b_saveaddr = bp->b_data;
	off = (int)addr & PGOFSET;
d349 10
a358 3
	npf = btoc(round_page(bp->b_bcount + off));
	kva = kmem_alloc_wait(phys_map, ctob(npf));
	bp->b_data = (caddr_t) (kva + off);
d360 2
a361 2
		pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    (vm_offset_t)addr);
d369 2
a370 2
		pmap_enter(vm_map_pmap(phys_map), kva,
			trunc_page(pa) | PMAP_NC,
d372 2
a373 2
		addr += PAGE_SIZE;
		kva += PAGE_SIZE;
d378 1
a378 1
 * Free the io map PTEs associated with this I/O operation.
d386 2
a387 1
vunmapbuf(bp)
d389 1
d391 2
a392 3
	register caddr_t addr;
	vm_offset_t pgva;
	register int off, npf;
a395 3
	addr = bp->b_data;
	off = (int)addr & PGOFSET;
	pgva = (vm_offset_t)((int)addr & ~PGOFSET);
d397 14
a410 2
	npf = btoc(round_page(bp->b_bcount + off));
	kmem_free_wakeup(phys_map, pgva, ctob(npf));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.31 1995/09/26 04:02:30 gwr Exp $	*/
d79 1
a79 1
int
a134 2

	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
