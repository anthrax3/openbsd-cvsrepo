head	1.57;
access;
symbols
	SMP_SYNC_A:1.57
	SMP_SYNC_B:1.57
	UBC_SYNC_A:1.57
	OPENBSD_3_2:1.55.0.4
	OPENBSD_3_2_BASE:1.55
	OPENBSD_3_1:1.55.0.2
	OPENBSD_3_1_BASE:1.55
	UBC_SYNC_B:1.55
	UBC:1.47.0.2
	UBC_BASE:1.47
	OPENBSD_3_0:1.42.0.2
	OPENBSD_3_0_BASE:1.42
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.4
	OPENBSD_2_8:1.28.0.2
	OPENBSD_2_8_BASE:1.28
	OPENBSD_2_7:1.27.0.2
	OPENBSD_2_7_BASE:1.27
	SMP:1.24.0.2
	SMP_BASE:1.24
	kame_19991208:1.24
	OPENBSD_2_6:1.23.0.2
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.20.0.6
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.20.0.4
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.20.0.2
	OPENBSD_2_1_BASE:1.20
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2002.12.31.16.35.41;	author miod;	state dead;
branches;
next	1.56;

1.56
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.08.02.24.07;	author art;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2001.11.28.16.13.29;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.14.09.07.50;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.12.00.23.34;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.25.11.37.26;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.23.12.02.05;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.08.11.23.21.14;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.05.10.12.17;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.27.04.44.03;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.30.20.40.04;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.17.18.41.50;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.05.22.34.24;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.05.20.56.54;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.27.00.16.20;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.29.20.37.31;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.23.09.59.56;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.02.23.02.14;	author todd;	state Exp;
branches;
next	1.24;

1.24
date	99.11.09.14.30.39;	author art;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	99.05.22.21.22.31;	author weingart;	state Exp;
branches;
next	1.22;

1.22
date	99.02.04.23.00.26;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	98.08.19.23.40.20;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.04.05.20.48.58;	author kstailey;	state Exp;
branches;
next	1.19;

1.19
date	97.04.05.20.44.25;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	97.04.05.20.32.49;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	97.02.06.20.00.43;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.02.03.23.22.38;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.02.03.21.30.14;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.01.19.13.53.14;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.01.16.08.08.40;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.01.16.04.22.49;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.01.16.04.04.28;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.01.07.23.36.31;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.12.31.06.13.54;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.11.24.16.04.48;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.07.55.09;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.07.27.11.42.01;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.08.08.52.32;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.16.04.45;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.16.18.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches;
next	;

1.24.2.1
date	2000.03.24.09.08.55;	author niklas;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2001.05.14.21.37.35;	author niklas;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2001.07.04.10.24.12;	author niklas;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.24.2.5;

1.24.2.5
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.24.2.6;

1.24.2.6
date	2001.12.05.00.39.14;	author niklas;	state Exp;
branches;
next	1.24.2.7;

1.24.2.7
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.24.2.8;

1.24.2.8
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.24.2.9;

1.24.2.9
date	2003.03.27.23.52.19;	author niklas;	state dead;
branches;
next	;

1.47.2.1
date	2002.01.31.22.55.26;	author niklas;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.47.2.3;

1.47.2.3
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.57
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: machdep.c,v 1.56 2002/12/17 23:11:32 millert Exp $	*/
/*	$NetBSD: machdep.c,v 1.77 1996/10/13 03:47:51 christos Exp $	*/

/*
 * Copyright (c) 1994, 1995 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Utah Hdr: machdep.c 1.74 92/12/20
 *	from: @@(#)machdep.c	8.10 (Berkeley) 4/20/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/clist.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/mount.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/vnode.h>
#include <sys/sysctl.h>
#include <sys/syscallargs.h>
#ifdef SYSVMSG
#include <sys/msg.h>
#endif

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <machine/cpu.h>
#include <machine/db_machdep.h>
#include <machine/dvma.h>
#include <machine/kcore.h>
#include <machine/machdep.h>
#include <machine/mon.h> 
#include <machine/psl.h>
#include <machine/pte.h>
#include <machine/reg.h>

extern char *cpu_string;
extern short exframesize[];

int physmem;
int fputype;
label_t *nofault;
vm_offset_t vmmap;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = PSL_LOWIPL;

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

/*
 * Declare these as initialized data so we can patch them.
 */
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif
#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;

static caddr_t allocsys(caddr_t);
static void identifycpu(void);
static void initcpu(void);
static void reboot_sync(void);
int  reboot2(int, char *); /* share with sunos_misc.c */

void straytrap(struct trapframe);	/* called from locore.s */

/*
 * Console initialization: called early on from main,
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
 */
void
consinit()
{

	cninit();

#ifdef KGDB
	/* XXX - Ask on console for kgdb_dev? */
	zs_kgdb_init();		/* XXX */
	/* Note: kgdb_connect() will just return if kgdb_dev<0 */
	if (boothowto & RB_KDB)
		kgdb_connect(1);
#endif
#ifdef DDB
	/* Now that we have a console, we can stop in DDB. */
	db_machine_init();
	ddb_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif
}

/*
 * allocsys() - Private routine used by cpu_startup() below.
 *
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */

#define	valloc(name, type, num) \
	v = (caddr_t)(((name) = (type *)v) + (num))

static caddr_t
allocsys(v)
	register caddr_t v;
{

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

	/*
	 * Determine how many buffers to allocate. By default we allocate
	 * the BSD standard of use 10% of memory for the first 2 Meg,
	 * 5% of remaining.  But this might cause systems with large 
	 * core (32MB) to fail to boot due to small KVM space.  Reduce
	 * BUFCACHEPERCENT in this case.
	 * Insure a minimum of 16 buffers.
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0) {
		/* We always have more than 2MB of memory. */
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    bufcachepercent / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
			MAXBSIZE * 7 / 10;
	
	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
	valloc(buf, struct buf, nbuf);
	return v;
}
#undef	valloc

/*
 * cpu_startup: allocate memory for variable-sized tables,
 * initialize cpu, and do autoconfiguration.
 *
 * This is called early in init_main.c:main(), after the
 * kernel memory allocator is ready for use, but before
 * the creation of processes 1,2, and mountroot, etc.
 */
void
cpu_startup()
{
	caddr_t v;
	int sz, i;
	vm_size_t size;	
	int base, residual;
	vm_offset_t minaddr, maxaddr;
	
	/*
	 * The msgbuf was set up earlier (in sun3_startup.c)
	 * just because it was more convenient to do there.
	 */
	
	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	identifycpu();
	initfpu();	/* also prints FPU type */

	printf("real mem = %d\n", ctob(physmem));

	/*
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	                UVM_ADV_NORMAL, 0)))
		panic("startup: cannot allocate buffers");
	minaddr = (vm_offset_t)buffers;
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize != 0) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL,
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(kernel_map->pmap);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * We don't use a submap for physio, and use a separate map
	 * for DVMA allocations.  Our vmapbuf just maps pages into
	 * the kernel map (any kernel mapping is OK) and then the
	 * device drivers clone the kernel mappings into DVMA space.
	 */

	printf("avail mem = %ld\n", ptoa(uvmexp.free));
	printf("using %d buffers containing %d bytes of memory\n",
		   nbuf, bufpages * PAGE_SIZE);

	/*
	 * Allocate a virtual page (for use by /dev/mem)
	 * This page is handed to pmap_enter() therefore
	 * it has to be in the normal kernel VA range.
	 */
	vmmap = uvm_km_valloc_wait(kernel_map, NBPG);

	/*
	 * Create the DVMA maps.
	 */
	dvma_init();

	/*
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * Set registers on exec.
 */
void
setregs(p, pack, stack, retval)
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct frame *frame = (struct frame *)p->p_md.md_regs;

	frame->f_sr = PSL_USERSET;
	frame->f_pc = pack->ep_entry & ~1;
	frame->f_regs[D0] = 0;
	frame->f_regs[D1] = 0;
	frame->f_regs[D2] = 0;
	frame->f_regs[D3] = 0;
	frame->f_regs[D4] = 0;
	frame->f_regs[D5] = 0;
	frame->f_regs[D6] = 0;
	frame->f_regs[D7] = 0;
	frame->f_regs[A0] = 0;
	frame->f_regs[A1] = 0;
	frame->f_regs[A2] = (int)PS_STRINGS;
	frame->f_regs[A3] = 0;
	frame->f_regs[A4] = 0;
	frame->f_regs[A5] = 0;
	frame->f_regs[A6] = 0;
	frame->f_regs[SP] = stack;

	/* restore a null state frame */
	p->p_addr->u_pcb.pcb_fpregs.fpf_null = 0;
	if (fputype) {
		m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);
	}
	/* XXX - HPUX sigcode hack would go here... */
}

/*
 * Info for CTL_HW
 */
char	machine[] = "sun3";		/* cpu "architecture" */
char	cpu_model[120];
extern	long hostid;

void
identifycpu()
{
	/*
	 * actual identification done earlier because i felt like it,
	 * and i believe i will need the info to deal with some VAC, and awful
	 * framebuffer placement problems.  could be moved later.
	 */
	strcpy(cpu_model, "Sun 3/");

	/*
	 * should eventually include whether it has a VAC, mc6888x
	 * version, etc
	 */
	strcat(cpu_model, cpu_string);

	printf("Model: %s (hostid %lx)\n", cpu_model, hostid);
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

#define SS_RTEFRAME	1
#define SS_FPSTATE	2
#define SS_USERREGS	4

struct sigstate {
	int	ss_flags;		/* which of the following are valid */
	struct	frame ss_frame;		/* original exception frame */
	struct	fpframe ss_fpstate;	/* 68881/68882 state info */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;		/* values for SA_SIGINFO */
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigstate sf_state;	/* state of the hardware */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
int sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Do a sync in preparation for a reboot.
 * XXX - This could probably be common code.
 * XXX - And now, most of it is in vfs_shutdown()
 * XXX - Put waittime checks in there too?
 */
int waittime = -1;	/* XXX - Who else looks at this? -gwr */
void
reboot_sync()
{
	extern struct proc proc0;

	/* Check waittime here to localize its use to this function. */
	if (waittime >= 0)
		return;
	/* fix curproc */
	if (curproc == NULL)
		curproc = &proc0;
	waittime = 0;
	vfs_shutdown();
}

/*
 * Common part of the BSD and SunOS reboot system calls.
 */
__dead int
reboot2(howto, user_boot_string)
	int howto;
	char *user_boot_string;
{
	char *bs, *p;
	char default_boot_string[8];

	/* If system is cold, just halt. (early panic?) */
	if (cold)
		goto haltsys;

	if ((howto & RB_NOSYNC) == 0) {
		reboot_sync();
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}

	/* Disable interrupts. */
	splhigh();

	/* Write out a crash dump if asked. */
	if (howto & RB_DUMP)
		dumpsys();

	/* run any shutdown hooks */
	doshutdownhooks();

	if (howto & RB_HALT) {
	haltsys:
		printf("Kernel halted.\n");
		sun3_mon_halt();
	}

	/*
	 * Automatic reboot.
	 */
	bs = user_boot_string;
	if (bs == NULL) {
		/*
		 * Build our own boot string with an empty
		 * boot device/file and (maybe) some flags.
		 * The PROM will supply the device/file name.
		 */
		bs = default_boot_string;
		*bs = '\0';
		if (howto & (RB_KDB|RB_ASKNAME|RB_SINGLE)) {
			/* Append the boot flags. */
			p = bs;
			*p++ = ' ';
			*p++ = '-';
			if (howto & RB_KDB)
				*p++ = 'd';
			if (howto & RB_ASKNAME)
				*p++ = 'a';
			if (howto & RB_SINGLE)
				*p++ = 's';
			*p = '\0';
		}
	}
	printf("Kernel rebooting...\n");
	sun3_mon_reboot(bs);
	for (;;) ;
	/*NOTREACHED*/
}

/*
 * BSD reboot system call
 * XXX - Should be named: cpu_reboot maybe? -gwr
 * XXX - It would be nice to allow a second argument
 * that specifies a machine-dependent boot string that
 * is passed to the boot program if RB_STRING is set.
 */
__dead void
boot(howto)
	int howto;
{
	(void) reboot2(howto, NULL);
	for(;;);
	/* NOTREACHED */
}

/*
 * These variables are needed by /sbin/savecore
 */
u_long	dumpmag = 0x8fca0101;	/* magic number */
int 	dumpsize = 0;		/* pages */
long	dumplo = 0; 		/* blocks */

/* Our private scratch page for dumping the MMU. */
vm_offset_t dumppage_va;
vm_offset_t dumppage_pa;

#define		DUMP_EXTRA	3	/* CPU-dependent extra pages */

/*
 * This is called by cpu_startup to set dumplo, dumpsize.
 * Dumps always skip the first block of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf()
{
	int nblks;	/* size of dump area */
	int maj;
	int (*getsize)(dev_t);

	if (dumpdev == NODEV)
		return;

	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	getsize = bdevsw[maj].d_psize;
	if (getsize == NULL)
		return;
	nblks = (*getsize)(dumpdev);
	if (nblks <= ctod(1))
		return;

	/* Position dump image near end of space, page aligned. */
	dumpsize = physmem + DUMP_EXTRA; /* pages */
	dumplo = nblks - ctod(dumpsize);
	dumplo &= ~(ctod(1)-1);

	/* If it does not fit, truncate it by moving dumplo. */
	/* Note: Must force signed comparison (fixes PR#887) */
	if (dumplo < ((long)ctod(1))) {
		dumplo = ctod(1);
		dumpsize = dtoc(nblks - dumplo);
	}
}

struct pcb dumppcb;
extern vm_offset_t avail_start;

/*
 * Write a crash dump.  The format while in swap is:
 *   kcore_seg_t cpu_hdr;
 *   cpu_kcore_hdr_t cpu_data;
 *   padding (NBPG-sizeof(kcore_seg_t))
 *   pagemap (2*NBPG)
 *   physical memory...
 */
void
dumpsys()
{
	struct bdevsw *dsw;
	kcore_seg_t	*kseg_p;
	cpu_kcore_hdr_t	*chdr_p;
	char *vaddr;
	vm_offset_t paddr;
	int psize, todo, chunk;
	daddr_t blkno;
	int error = 0;

	if (dumpdev == NODEV)
		return;
	if (dumppage_va == 0)
		return;

	/* 
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo <= 0)
		return;
	savectx(&dumppcb);

	dsw = &bdevsw[major(dumpdev)];
	psize = (*(dsw->d_psize))(dumpdev);
	if (psize == -1) {
		printf("dump area unavailable\n");
		return;
	}

	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);

	/*
	 * Write the dump header, including MMU state.
	 */
	blkno = dumplo;
	todo = dumpsize - DUMP_EXTRA;	/* pages */
	vaddr = (char *)dumppage_va;
	bzero(vaddr, NBPG);

	/* kcore header */
	kseg_p = (kcore_seg_t *)vaddr;
	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = (ctob(DUMP_EXTRA) - sizeof(kcore_seg_t));

	/* MMU state */
	chdr_p = (cpu_kcore_hdr_t *) (kseg_p + 1);
	pmap_get_ksegmap(chdr_p->ksegmap);
	error = (*dsw->d_dump)(dumpdev, blkno, vaddr, NBPG);
	if (error)
		goto fail;
	blkno += btodb(NBPG);

	/* translation RAM (page zero) */
	pmap_get_pagemap((int *)vaddr, 0);
	error = (*dsw->d_dump)(dumpdev, blkno, vaddr, NBPG);
	if (error)
		goto fail;
	blkno += btodb(NBPG);

	/* translation RAM (page one) */
	pmap_get_pagemap((int *)vaddr, NBPG);
	error = (*dsw->d_dump)(dumpdev, blkno, vaddr, NBPG);
	if (error)
		goto fail;
	blkno += btodb(NBPG);

	/*
	 * Now dump physical memory.  Have to do it in two chunks.
	 * The first chunk is "unmanaged" (by the VM code) and its
	 * range of physical addresses is not allow in pmap_enter.
	 * However, that segment is mapped linearly, so we can just
	 * use the virtual mappings already in place.  The second
	 * chunk is done the normal way, using pmap_enter.
	 *
	 * Note that vaddr==(paddr+KERNBASE) for paddr=0 through etext.
	 */

	/* Do the first chunk (0 <= PA < avail_start) */
	paddr = 0;
	chunk = btoc(avail_start);
	if (chunk > todo)
		chunk = todo;
	do {
		if ((todo & 0xf) == 0)
			printf("\r%4d", todo);
		vaddr = (char *)(paddr + KERNBASE);
		error = (*dsw->d_dump)(dumpdev, blkno, vaddr, NBPG);
		if (error)
			goto fail;
		paddr += NBPG;
		blkno += btodb(NBPG);
		--todo;
	} while (--chunk > 0);

	/* Do the second chunk (avail_start <= PA < dumpsize) */
	vaddr = (char *)vmmap;	/* Borrow /dev/mem VA */
	do {
		if ((todo & 0xf) == 0)
			printf("\r%4d", todo);
		pmap_enter(pmap_kernel(), vmmap, paddr | PMAP_NC,
			VM_PROT_READ, VM_PROT_READ);
		pmap_update(pmap_kernel());
		error = (*dsw->d_dump)(dumpdev, blkno, vaddr, NBPG);
		pmap_remove(pmap_kernel(), vmmap, vmmap + NBPG);
		pmap_update(pmap_kernel());
		if (error)
			goto fail;
		paddr += NBPG;
		blkno += btodb(NBPG);
	} while (--todo > 0);

	printf("\rdump succeeded\n");
	return;
fail:
	printf(" dump error=%d\n", error);
}

void
initcpu()
{
	/* XXX: Enable RAM parity/ECC checking? */
	/* XXX: parityenable(); */

	nofault = NULL;	/* XXX - needed? */

#ifdef	HAVECACHE
	cache_enable();
#endif
}

void
straytrap(frame)
	struct trapframe frame;
{
	printf("unexpected trap; vector offset 0x%x from 0x%x\n",
		frame.tf_vector, frame.tf_pc);
#ifdef	DDB
	kdb_trap(-1, (db_regs_t *) &frame);
#endif
}

/* XXX: parityenable() ? */

/*
 * cpu_exec_aout_makecmds():
 *	cpu-dependent a.out format hook for execve().
 * 
 * Determine if the given exec package refers to something which we
 * understand and, if so, set up the vmcmds for it.
 */
int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error = ENOEXEC;

#ifdef COMPAT_SUNOS
	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
	if ((error = sunos_exec_aout_makecmds(p, epp)) == 0)
		return 0;
#endif
	return error;
}
@


1.56
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2002/03/23 13:28:34 espie Exp $	*/
@


1.55
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2002/03/14 20:31:31 mickey Exp $	*/
a73 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a179 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.54
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2002/03/14 03:16:01 millert Exp $	*/
d187 3
@


1.53
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2002/03/14 01:26:47 millert Exp $	*/
a95 1
extern char version[];
@


1.52
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2002/02/17 22:59:53 maja Exp $	*/
d773 1
a773 1
		vaddr = (char*)(paddr + KERNBASE);
d783 1
a783 1
	vaddr = (char*)vmmap;	/* Borrow /dev/mem VA */
@


1.51
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2002/01/23 17:51:52 art Exp $	*/
d132 5
a136 5
static caddr_t allocsys __P((caddr_t));
static void identifycpu __P((void));
static void initcpu __P((void));
static void reboot_sync __P((void));
int  reboot2 __P((int, char *)); /* share with sunos_misc.c */
d138 1
a138 1
void straytrap __P((struct trapframe));	/* called from locore.s */
d644 1
a644 1
	int (*getsize) __P((dev_t));
d846 1
a846 2
	extern int sunos_exec_aout_makecmds
		__P((struct proc *, struct exec_package *));
@


1.50
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2002/01/23 17:35:56 art Exp $	*/
d113 4
d130 1
a202 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
d215 1
a215 1
		    BUFCACHEPERCENT / 100;
@


1.49
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2002/01/16 20:50:17 miod Exp $	*/
a332 3

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.48
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2001/12/08 02:24:07 art Exp $	*/
a104 1
struct vm_map *mb_map = NULL;
@


1.47
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2001/11/28 16:13:29 art Exp $	*/
a50 1
#include <sys/map.h>
@


1.47.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2002/01/23 17:51:52 art Exp $	*/
d51 1
d106 1
d335 3
@


1.47.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47.2.1 2002/01/31 22:55:26 niklas Exp $	*/
d96 1
a112 4
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a125 1
int	bufcachepercent = BUFCACHEPERCENT;
d127 5
a131 5
static caddr_t allocsys(caddr_t);
static void identifycpu(void);
static void initcpu(void);
static void reboot_sync(void);
int  reboot2(int, char *); /* share with sunos_misc.c */
d133 1
a133 1
void straytrap(struct trapframe);	/* called from locore.s */
a182 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d198 3
d213 1
a213 1
		    bufcachepercent / 100;
d642 1
a642 1
	int (*getsize)(dev_t);
d771 1
a771 1
		vaddr = (char *)(paddr + KERNBASE);
d781 1
a781 1
	vaddr = (char *)vmmap;	/* Borrow /dev/mem VA */
d844 2
a845 1
	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
@


1.47.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47.2.2 2002/06/11 03:39:01 art Exp $	*/
@


1.46
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2001/11/28 13:47:39 art Exp $	*/
d320 1
d792 1
d795 1
@


1.45
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2001/11/07 01:18:00 art Exp $	*/
d105 3
a107 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.44
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2001/11/06 19:53:16 miod Exp $	*/
d285 1
a285 1
	                UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.43
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2001/09/19 20:50:57 mickey Exp $	*/
d283 1
a283 1
	    NULL, UVM_UNKNOWN_OFFSET,
@


1.42
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2001/09/14 09:07:50 art Exp $	*/
a80 2

#include <vm/vm.h>
@


1.41
log
@Fix compilation errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2001/09/12 00:23:34 art Exp $	*/
a82 1
#include <vm/vm_kern.h>
@


1.40
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2001/08/25 11:37:26 espie Exp $	*/
a134 2
static void dumpmem __P((int *, int, int));
static char *hexstr __P((int, int));
@


1.39
log
@One regdump to dump them all...

(moid@@ wants that commit, because it interferes with stuff he's cleaning,
and he's prepared to clean up stuff I may have forgotten, even though this
was tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2001/08/23 14:01:03 art Exp $	*/
d340 1
a340 1
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
@


1.38
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2001/08/23 12:02:05 art Exp $	*/
a834 92

/*
 * Print a register and stack dump.
 */
void
regdump(fp, sbytes)
	struct frame *fp; /* must not be register */
	int sbytes;
{
	static int doingdump = 0;
	register int i;
	int s;

	if (doingdump)
		return;
	s = splhigh();
	doingdump = 1;
	printf("pid = %d, pc = %s, ",
	       curproc ? curproc->p_pid : -1, hexstr(fp->f_pc, 8));
	printf("ps = %s, ", hexstr(fp->f_sr, 4));
	printf("sfc = %s, ", hexstr(getsfc(), 4));
	printf("dfc = %s\n", hexstr(getdfc(), 4));
	printf("Registers:\n     ");
	for (i = 0; i < 8; i++)
		printf("        %d", i);
	printf("\ndreg:");
	for (i = 0; i < 8; i++)
		printf(" %s", hexstr(fp->f_regs[i], 8));
	printf("\nareg:");
	for (i = 0; i < 8; i++)
		printf(" %s", hexstr(fp->f_regs[i+8], 8));
	if (sbytes > 0) {
		if (fp->f_sr & PSL_S) {
			printf("\n\nKernel stack (%s):",
			       hexstr((int)(((int *)&fp)-1), 8));
			dumpmem(((int *)&fp)-1, sbytes, 0);
		} else {
			printf("\n\nUser stack (%s):", hexstr(fp->f_regs[SP], 8));
			dumpmem((int *)fp->f_regs[SP], sbytes, 1);
		}
	}
	doingdump = 0;
	splx(s);
}

#define KSADDR	((int *)((u_int)curproc->p_addr + USPACE - NBPG))

void
dumpmem(ptr, sz, ustack)
	register int *ptr;
	int sz, ustack;
{
	register int i, val;

	for (i = 0; i < sz; i++) {
		if ((i & 7) == 0)
			printf("\n%s: ", hexstr((int)ptr, 6));
		else
			printf(" ");
		if (ustack == 1) {
			if ((val = fuword(ptr++)) == -1)
				break;
		} else {
			if (ustack == 0 &&
			    (ptr < KSADDR || ptr > KSADDR+(NBPG/4-1)))
				break;
			val = *ptr++;
		}
		printf("%s", hexstr(val, 8));
	}
	printf("\n");
}

char *
hexstr(val, len)
	register int val;
	int len;
{
	static char nbuf[9];
	register int x, i;

	if (len > 8)
		return("");
	nbuf[len] = '\0';
	for (i = len-1; i >= 0; --i) {
		x = val & 0xF;
		/* Isn't this a cool trick? */
		nbuf[i] = "0123456789ABCDEF"[x];
		val >>= 4;
	}
	return(nbuf);
}
@


1.37
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2001/08/11 23:21:14 art Exp $	*/
a341 5

	/*
	 * Initialize timeouts
	 */
	timeout_init();
@


1.36
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2001/07/25 13:25:33 art Exp $	*/
a188 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.35
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2001/07/05 10:12:17 art Exp $	*/
a82 1
#include <vm/vm_map.h>
a83 1
#include <vm/vm_page.h>
@


1.34
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2001/06/27 04:44:03 art Exp $	*/
d322 2
a323 2
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
			    VM_PROT_READ|VM_PROT_WRITE);
d803 1
a803 1
			VM_PROT_READ, FALSE, VM_PROT_READ);
@


1.33
log
@Zap old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2001/05/30 20:40:04 miod Exp $	*/
a190 3
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
@


1.32
log
@Preliminary UVM support. UVM kernels don't work for the moment, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2001/05/17 18:41:50 provos Exp $	*/
a86 1
#ifdef UVM
a87 1
#endif
a109 1
#ifdef UVM
a112 3
#else
vm_map_t buffer_map = NULL;
#endif
a122 3
#ifndef UVM
int	nswbuf = 0;
#endif
a241 8
#ifndef UVM
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
	valloc(swbuf, struct buf, nswbuf);
#endif
a282 1
#ifdef UVM
a283 3
#else
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
#endif
a292 1
#ifdef UVM
a298 8
#else
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif
a307 1
#ifdef UVM
a329 13
#else
		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base+1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif
a335 1
#ifdef UVM
a337 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
#endif
a345 1
#ifdef UVM
a347 4
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
#endif
a353 1
#ifdef UVM
a354 3
#else
	printf("avail mem = %ld\n", ptoa(cnt.v_free_count));
#endif
a362 1
#ifdef UVM
a363 3
#else
	vmmap = kmem_alloc_wait(kernel_map, NBPG);
#endif
@


1.31
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2001/05/05 22:34:24 art Exp $	*/
d87 4
a105 1
extern vm_offset_t vmmap;	/* XXX - poor name.  See mem.c */
d112 8
d129 1
d131 1
d251 1
d258 1
d300 3
d304 1
d314 8
d328 1
d336 4
a339 2
		vm_size_t curbufsize;
		vm_offset_t curbuf;
d342 21
d373 1
d380 4
d386 1
d395 4
d401 1
d408 3
d412 1
d421 3
d425 1
d500 1
a500 1
static void
d503 5
a507 5
    /*
     * actual identification done earlier because i felt like it,
     * and i believe i will need the info to deal with some VAC, and awful
     * framebuffer placement problems.  could be moved later.
     */
d510 4
a513 1
    /* should eventually include whether it has a VAC, mc6888x version, etc */
d591 1
a591 1
static void
d609 1
a609 1
int
d690 1
a690 1
void
d955 1
a955 1
static void
@


1.30
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2001/05/05 20:56:54 art Exp $	*/
a337 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.29
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2000/10/27 00:16:20 mickey Exp $	*/
a388 1
	configure();
@


1.28
log
@more precise BUFCACHEPERCENT calculations.
from gluk@@ptci.ru; deraadt@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2000/04/29 20:37:31 miod Exp $	*/
d222 1
a222 1
		    BUFCACHEPERCENT / (100 * CLSIZE);
d236 2
a237 2
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;
d319 1
a319 1
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
d342 1
a342 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d344 1
a344 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d355 1
a355 1
		   nbuf, bufpages * CLBYTES);
d649 1
a649 1
 * Dumps always skip the first CLBYTES of disk space
@


1.27
log
@Fixed a tyop
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2000/03/23 09:59:56 art Exp $	*/
d221 2
a222 2
		bufpages = (btoc(2 * 1024 * 1024) + physmem) /
			((100/BUFCACHEPERCENT) * CLSIZE);
@


1.26
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2000/03/02 23:02:14 todd Exp $	*/
d190 1
a190 1
	valloc(timeouts, struct timeoutout, ntimeout);
@


1.25
log
@sun3 is alive, thanks to Miod Vallat <miodrag@@ifrance.com>
add ksyms, proto fix, msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1999/11/09 14:30:39 art Exp $	*/
d58 1
a58 1
#include <sys/callout.h>
d190 1
a190 1
	valloc(callout, struct callout, ncallout);
d349 1
a349 1
	 * Initialize callouts
d351 1
a351 4
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;
@


1.24
log
@Adapt to pmap_enter changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1999/05/22 21:22:31 weingart Exp $	*/
a105 1
int msgbufmapped;
a712 1
	msgbufmapped = 0;
@


1.24.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
#include <sys/timeout.h>
d106 1
d191 1
a191 1
	valloc(timeouts, struct timeoutout, ntimeout);
d350 1
a350 1
	 * Initialize timeouts
d352 4
a355 1
	timeout_init();
d714 1
@


1.24.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2000/10/27 00:16:20 mickey Exp $	*/
d190 1
a190 1
	valloc(timeouts, struct timeout, ntimeout);
d221 2
a222 2
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    BUFCACHEPERCENT / (100 * CLSIZE);
@


1.24.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24.2.2 2001/05/14 21:37:35 niklas Exp $	*/
a86 2
#include <uvm/uvm_extern.h>

d102 1
a108 4
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;

d118 1
d222 1
a222 1
		    BUFCACHEPERCENT / 100;
d236 8
a243 2
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
d285 1
a285 1
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
d295 5
a299 4
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET,
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	                UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
a300 1
	minaddr = (vm_offset_t)buffers;
d308 2
a309 3
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;
d312 5
a316 4
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
d318 4
a321 14
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize != 0) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
			    VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
d328 2
a329 2
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d338 9
a346 2
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
d353 1
a353 1
	printf("avail mem = %ld\n", ptoa(uvmexp.free));
d355 1
a355 1
		   nbuf, bufpages * PAGE_SIZE);
d362 1
a362 1
	vmmap = uvm_km_valloc_wait(kernel_map, NBPG);
d389 1
d438 1
a438 1
void
d441 5
a445 5
	/*
	 * actual identification done earlier because i felt like it,
	 * and i believe i will need the info to deal with some VAC, and awful
	 * framebuffer placement problems.  could be moved later.
	 */
d448 1
a448 4
	/*
	 * should eventually include whether it has a VAC, mc6888x
	 * version, etc
	 */
d526 1
a526 1
void
d544 1
a544 1
__dead int
d625 1
a625 1
__dead void
d649 1
a649 1
 * Dumps always skip the first block of disk space
d890 1
a890 1
void
@


1.24.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24.2.3 2001/07/04 10:24:12 niklas Exp $	*/
d83 3
d137 2
d191 4
d325 2
a326 2
			    VM_PAGE_TO_PHYS(pg), VM_PROT_ALL,
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d346 1
a346 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
d349 5
d806 1
a806 1
			VM_PROT_READ, VM_PROT_READ);
d846 92
@


1.24.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 2
d285 1
a285 1
	    NULL, UVM_UNKNOWN_OFFSET, 0,
@


1.24.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24.2.5 2001/11/13 21:04:18 niklas Exp $	*/
d105 3
a107 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d285 1
a285 1
	                UVM_ADV_NORMAL, 0)))
@


1.24.2.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
d106 1
a114 4
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a127 1
int	bufcachepercent = BUFCACHEPERCENT;
d200 3
d215 1
a215 1
		    bufcachepercent / 100;
a319 1
	pmap_update(kernel_map->pmap);
d335 3
a790 1
		pmap_update(pmap_kernel());
a792 1
		pmap_update(pmap_kernel());
@


1.24.2.8
log
@Merge in -current from about a week ago
@
text
@d96 1
d132 5
a136 5
static caddr_t allocsys(caddr_t);
static void identifycpu(void);
static void initcpu(void);
static void reboot_sync(void);
int  reboot2(int, char *); /* share with sunos_misc.c */
d138 1
a138 1
void straytrap(struct trapframe);	/* called from locore.s */
d644 1
a644 1
	int (*getsize)(dev_t);
d773 1
a773 1
		vaddr = (char *)(paddr + KERNBASE);
d783 1
a783 1
	vaddr = (char *)vmmap;	/* Borrow /dev/mem VA */
d846 2
a847 1
	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
@


1.24.2.9
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24.2.8 2002/03/28 11:26:45 niklas Exp $	*/
@


1.23
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1999/02/04 23:00:26 niklas Exp $	*/
d808 1
a808 1
			VM_PROT_READ, FALSE);
@


1.22
log
@Deterministic register initalization on process startup
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1998/08/19 23:40:20 millert Exp $	*/
a191 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.21
log
@please gcc 2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 1997/04/05 20:48:58 kstailey Exp $	*/
a398 2
 * XXX Should clear registers except sp, pc,
 * but would break init; should be fixed soon.
d409 1
d411 15
a426 1
	frame->f_regs[A2] = (int)PS_STRINGS;
@


1.20
log
@removed conditional code
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 1997/04/05 20:44:25 kstailey Exp $	*/
d944 1
a944 1
	extern sunos_exec_aout_makecmds
@


1.19
log
@sendsig and sys_sigreturn are in m68k area now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 1997/04/05 20:32:49 kstailey Exp $	*/
a509 291

#if 0				/* in m68k */
/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct sigframe *fp, *kfp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short ft;
	int oonstack, fsize;
	extern char sigcode[], esigcode[];

	frame = (struct frame *)p->p_md.md_regs;
	ft = frame->f_format;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)(frame->f_regs[SP] - fsize);
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x ft %d\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
#endif
	if (useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): useracc failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	kfp = (struct sigframe *)malloc((u_long)fsize, M_TEMP, M_WAITOK);
	/* 
	 * Build the argument list for the signal handler.
	 */
	kfp->sf_signum = sig;
	kfp->sf_sip = NULL;
	kfp->sf_scp = &fp->sf_sc;
	kfp->sf_handler = catcher;
	/*
	 * Save necessary hardware state.  Currently this includes:
	 *	- general registers
	 *	- original exception frame (if not a "normal" frame)
	 *	- FP coprocessor state
	 */
	kfp->sf_state.ss_flags = SS_USERREGS;
	bcopy((caddr_t)frame->f_regs,
	      (caddr_t)kfp->sf_state.ss_frame.f_regs, sizeof frame->f_regs);
	if (ft >= FMT7) {
#ifdef DEBUG
		if (ft > 15 || exframesize[ft] < 0)
			panic("sendsig: bogus frame type");
#endif
		kfp->sf_state.ss_flags |= SS_RTEFRAME;
		kfp->sf_state.ss_frame.f_format = frame->f_format;
		kfp->sf_state.ss_frame.f_vector = frame->f_vector;
		bcopy((caddr_t)&frame->F_u,
		      (caddr_t)&kfp->sf_state.ss_frame.F_u,
			  (size_t) exframesize[ft]);
		/*
		 * Leave an indicator that we need to clean up the kernel
		 * stack.  We do this by setting the "pad word" above the
		 * hardware stack frame to the amount the stack must be
		 * adjusted by.
		 *
		 * N.B. we increment rather than just set f_stackadj in
		 * case we are called from syscall when processing a
		 * sigreturn.  In that case, f_stackadj may be non-zero.
		 */
		frame->f_stackadj += exframesize[ft];
		frame->f_format = frame->f_vector = 0;
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sendsig(%d): copy out %d of frame %d\n",
			       p->p_pid, exframesize[ft], ft);
#endif
	}

	if (fputype) {
		kfp->sf_state.ss_flags |= SS_FPSTATE;
		m68881_save(&kfp->sf_state.ss_fpstate);
	}
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&kfp->sf_state.ss_fpstate)
		printf("sendsig(%d): copy out FP state (%x) to %x\n",
		       p->p_pid, *(u_int *)&kfp->sf_state.ss_fpstate,
		       &kfp->sf_state.ss_fpstate);
#endif

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	kfp->sf_sc.sc_onstack = oonstack;
	kfp->sf_sc.sc_mask = mask;
	kfp->sf_sc.sc_sp = frame->f_regs[SP];
	kfp->sf_sc.sc_fp = frame->f_regs[A6];
	kfp->sf_sc.sc_ap = (int)&fp->sf_state;
	kfp->sf_sc.sc_pc = frame->f_pc;
	kfp->sf_sc.sc_ps = frame->f_sr;
	if (psp->ps_siginfo & sigmask(sig)) {
		kfp->sf_sip = &fp->sf_si;
		initsiginfo(&kfp->sf_si, sig, code, type, val);
	}
	/* XXX do not copy out siginfo if not needed */
	(void) copyout((caddr_t)kfp, (caddr_t)fp, fsize);
	frame->f_regs[SP] = (int)fp;
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): sig %d scp %x fp %x sc_sp %x sc_ap %x\n",
		       p->p_pid, sig, kfp->sf_scp, fp,
		       kfp->sf_sc.sc_sp, kfp->sf_sc.sc_ap);
#endif
	/*
	 * Signal trampoline code is at base of user stack.
	 */
	frame->f_pc = (int)PS_STRINGS - (esigcode - sigcode);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
	free((caddr_t)kfp, M_TEMP);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper priviledges or to cause
 * a machine fault.
 */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args *uap = v;
	register struct sigcontext *scp;
	register struct frame *frame;
	register int rf;
	struct sigcontext tsigc;
	struct sigstate tstate;
	int flags;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
#endif
	if ((int)scp & 1)
		return (EINVAL);

	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	if (useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
		return (EINVAL);
	scp = &tsigc;
	if ((scp->sc_ps & (PSL_MBZ|PSL_IPL|PSL_S)) != 0)
		return (EINVAL);
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->sc_sp;
	frame->f_regs[A6] = scp->sc_fp;
	frame->f_pc = scp->sc_pc;
	frame->f_sr = scp->sc_ps;

	/*
	 * Grab pointer to hardware state information.
	 * If zero, the user is probably doing a longjmp.
	 */
	if ((rf = scp->sc_ap) == 0)
		return (EJUSTRETURN);
	/*
	 * See if there is anything to do before we go to the
	 * expense of copying in close to 1/2K of data
	 */
	flags = fuword((caddr_t)rf);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): sc_ap %x flags %x\n",
		       p->p_pid, rf, flags);
#endif
	/*
	 * fuword failed (bogus sc_ap value).
	 */
	if (flags == -1)
		return (EINVAL);
	if (flags == 0 || copyin((caddr_t)rf, (caddr_t)&tstate, sizeof tstate))
		return (EJUSTRETURN);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sigreturn(%d): ssp %x usp %x scp %x ft %d\n",
		       p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		       (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
#endif
	/*
	 * Restore most of the users registers except for A6 and SP
	 * which were handled above.
	 */
	if (flags & SS_USERREGS)
		bcopy((caddr_t)tstate.ss_frame.f_regs,
		      (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
	/*
	 * Restore long stack frames.  Note that we do not copy
	 * back the saved SR or PC, they were picked up above from
	 * the sigcontext structure.
	 */
	if (flags & SS_RTEFRAME) {
		register int sz;
		
		/* grab frame type and validate */
		sz = tstate.ss_frame.f_format;
		if (sz > 15 || (sz = exframesize[sz]) < 0)
			return (EINVAL);
		frame->f_stackadj -= sz;
		frame->f_format = tstate.ss_frame.f_format;
		frame->f_vector = tstate.ss_frame.f_vector;
		bcopy((caddr_t)&tstate.ss_frame.F_u, (caddr_t)&frame->F_u, sz);
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sigreturn(%d): copy in %d of frame type %d\n",
			       p->p_pid, sz, tstate.ss_frame.f_format);
#endif
	}

	/*
	 * Finally we restore the original FP context
	 */
	if (flags & SS_FPSTATE)
		m68881_restore(&tstate.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&tstate.ss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %x\n",
		       p->p_pid, *(u_int *)&tstate.ss_fpstate,
		       &tstate.ss_fpstate);
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
}
#endif

@


1.18
log
@fpu_type -> fputype
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1997/02/06 20:00:43 kstailey Exp $	*/
d511 1
d799 1
@


1.17
log
@support for BUFCACHEPERCENT
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 1997/02/03 23:22:38 kstailey Exp $	*/
d105 1
a105 1
int fpu_type;
d417 1
a417 1
	if (fpu_type) {
d621 1
a621 1
	if (fpu_type) {
@


1.16
log
@add siginfo member to struct sigframe
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 1997/02/03 21:30:14 kstailey Exp $	*/
d209 3
d213 1
a213 1
	 * Determine how many buffers to allocate. We allocate
d215 4
a218 1
	 * 5% of remaining. Insure a minimum of 16 buffers.
d223 2
a224 2
		bufpages = ((btoc(2 * 1024 * 1024) + physmem) /
		            (20 * CLSIZE));
d231 9
d646 1
@


1.15
log
@First try at SA_SIGINFO support.

Some mods in trap.c to bring it closer to NetBSD 1.65.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 1997/01/19 13:53:14 niklas Exp $	*/
d485 1
@


1.14
log
@From Gordon W Ross (NetBSD):
Use db_regs_t instead of struct mc68020_saved_state
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 1997/01/16 08:08:40 kstailey Exp $	*/
d480 1
a480 1
	int	sf_code;		/* additional info for handler */
d499 1
a499 1
sendsig(catcher, sig, mask, code)
d503 2
d563 1
a563 1
	kfp->sf_code = code;
d626 4
@


1.13
log
@Use RB_TIMEBAD in boot() to know not to update the battery backed up clock
via resettodr().  Make Sun3-only command "machine reboot" only print
a warning that the command is obsolete and that you should use the "boot"
command instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1997/01/16 04:22:49 kstailey Exp $	*/
d1097 1
a1097 2
	/* XXX - Yuck!  Make DDB use "struct trapframe" instead! */
	kdb_trap(-1, (struct mc68020_saved_state *) &frame);
@


1.12
log
@machdep.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 1997/01/16 04:04:28 kstailey Exp $	*/
d823 3
@


1.11
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d818 2
a819 5
		 * will be out of synch; adjust it now.
		 *
		 * XXX - However, if the kernel has been sitting in ddb,
		 * the time will be way off, so don't set the HW clock!
		 * XXX - Should do sanity check against HW clock. -gwr
d821 2
a822 1
		/* resettodr(); */
@


1.10
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
a81 10
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/pte.h>
#include <machine/mon.h> 
#include <machine/isr.h>
#include <machine/kcore.h>

#include <dev/cons.h>

d87 1
a87 1
#include <net/netisr.h>
d89 9
a97 1
#include "cache.h"
a102 1
extern int cold;
d107 2
a129 1
long *nofault;
d131 9
a139 1
void identifycpu();
d146 2
a147 1
void consinit()
d149 2
a150 2
    extern void cninit();
    cninit();
d179 1
d182 1
d343 1
a343 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
d415 1
a415 1
void
d428 1
a428 1
	printf("Model: %s (hostid %x)\n", cpu_model, hostid);
d434 1
d784 2
a785 1
static void reboot_sync()
a787 2
	struct buf *bp;
	int iter, nbusy;
d802 2
a803 1
int reboot2(howto, user_boot_string)
d882 2
a883 1
void boot(howto)
d916 1
a916 1
	int (*getsize)();
d955 1
d990 1
a990 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d997 1
a997 1
	vaddr = (char*)dumppage_va;
d1014 1
a1014 1
	pmap_get_pagemap(vaddr, 0);
d1021 1
a1021 1
	pmap_get_pagemap(vaddr, NBPG);
d1076 1
d1089 1
d1091 1
a1091 1
	struct frame frame;
d1094 1
a1094 1
		frame.f_vector, frame.f_pc);
d1096 2
a1097 1
	kdb_trap(-1, &frame);
a1100 36
/* from hp300: badaddr() */
int
peek_word(addr)
	register caddr_t addr;
{
	label_t		faultbuf;
	register int x;

	nofault = (long*)&faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = NULL;
		return(-1);
	}
	x = *(volatile u_short *)addr;
	nofault = NULL;
	return(x);
}

/* from hp300: badbaddr() */
int
peek_byte(addr)
	register caddr_t addr;
{
	label_t 	faultbuf;
	register int x;

	nofault = (long*)&faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = NULL;
		return(-1);
	}
	x = *(volatile u_char *)addr;
	nofault = NULL;
	return(x);
}

d1106 1
a1113 1
	extern char *hexstr();
d1149 1
a1154 1
	extern char *hexstr();
d1202 1
@


1.9
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.79 1996/12/17 21:35:30 gwr Exp $	*/
d81 10
d96 1
a96 10
#include <dev/cons.h>

#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/pte.h>
#include <machine/mon.h>
#include <machine/dvma.h>
#include <machine/kcore.h>
#include <machine/db_machdep.h>
d98 1
a98 1
#include "machdep.h"
d103 2
d106 3
a108 5
int	physmem;
int	fpu_type;
int	msgbufmapped;

vm_offset_t vmmap;
d130 1
a130 1
label_t *nofault;
d132 1
a132 2
static void identifycpu __P((void));
static void initcpu __P((void));
d141 2
a142 1
	cninit();
d157 1
a157 1
#endif DDB
a172 1
static caddr_t allocsys __P((caddr_t));
a214 2
	if (nbuf > 200)		/* XXX Sorry, our kvm space is too small */
		nbuf = 200;
d239 1
a239 1
	vm_size_t size;
d242 1
a242 1

d247 1
a247 1

a394 1
	p->p_md.md_flags = 0;
a423 1
int
a432 1
	int error;
d445 2
a446 14
		error = sysctl_rdstruct(oldp, oldlenp, newp,
		    &consdev, sizeof consdev);
		break;

#if 0	/* XXX - Not yet... */
	case CPU_ROOT_DEVICE:
		error = sysctl_rdstring(oldp, oldlenp, newp, root_device);
		break;

	case CPU_BOOTED_KERNEL:
		error = sysctl_rdstring(oldp, oldlenp, newp, booted_kernel);
		break;
#endif

d448 1
a448 1
		error = EOPNOTSUPP;
d450 1
a450 1
	return (error);
d520 1
a520 1
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
d546 1
a546 1
	/*
d732 1
a732 1

d773 1
a773 2
static void
reboot_sync __P((void))
a790 1
 * Warning: OpenBSD doesn't use a second arg to boot()
d890 1
a890 1
#define	DUMP_EXTRA 	3	/* CPU-dependent extra pages */
d904 1
a904 1
	int (*getsize)__P((dev_t));
d920 1
a920 1
	dumpsize = physmem + DUMP_EXTRA;	/* pages */
a942 1
void
d947 1
a947 1
	cpu_kcore_hdr_t *chdr_p;
d960 1
a960 1
	/*
d1001 1
a1001 1
	pmap_get_pagemap((int*)vaddr, 0);
d1008 1
a1008 1
	pmap_get_pagemap((int*)vaddr, NBPG);
a1062 1
static void
a1074 3
/* called from locore.s */
void straytrap __P((struct trapframe));
void
d1076 1
a1076 1
	struct trapframe frame;
d1078 2
a1079 2
	printf("unexpected trap; vector=0x%x at pc=0x%x\n",
		frame.tf_vector, frame.tf_pc);
d1081 1
a1081 2
	/* XXX - Yuck!  Make DDB use "struct trapframe" instead! */
	kdb_trap(-1, (struct mc68020_saved_state *) &frame);
d1086 34
a1119 1
/* peek_byte(), peek_word() moved to autoconf.c */
a1122 3
static void dumpmem __P((int *, int, int));
static char *hexstr __P((int, int));

a1125 1
void
d1133 1
a1168 1
static void
d1174 1
d1195 1
a1195 1
static char *
d1218 1
a1218 1
 *
a1221 1
int
@


1.8
log
@sync w/NetBSD modulo two-arg boot(); adds dump
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.77 1996/10/13 03:47:51 christos Exp $	*/
d81 7
d92 2
a93 2
#include <machine/mon.h> 
#include <machine/isr.h>
d95 1
d97 1
a97 10
#include <dev/cons.h>

#include <vm/vm.h>
#include <vm/vm_map.h>
#include <vm/vm_kern.h>
#include <vm/vm_page.h>

#include <net/netisr.h>

#include "cache.h"
a101 2
extern vm_offset_t vmmap;	/* XXX - poor name.  See mem.c */
extern int cold;
d103 5
a107 3
int physmem;
int fpu_type;
int msgbufmapped;
d129 1
a129 1
long *nofault;
d131 2
a132 1
void identifycpu();
d141 1
a141 2
    extern void cninit();
    cninit();
d156 1
a156 1
#endif
d172 1
d215 2
d241 1
a241 1
	vm_size_t size;	
d244 1
a244 1
	
d249 1
a249 1
	
d397 1
d427 1
d437 1
d450 14
a463 2
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
d465 1
a465 1
		return (EOPNOTSUPP);
d467 1
a467 1
	/* NOTREACHED */
d537 1
a537 1
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
d563 1
a563 1
	/* 
d749 1
a749 1
		
d790 2
a791 1
static void reboot_sync()
d809 1
d909 1
a909 1
#define		DUMP_EXTRA	3	/* CPU-dependent extra pages */
d923 1
a923 1
	int (*getsize)();
d939 1
a939 1
	dumpsize = physmem + DUMP_EXTRA; /* pages */
d962 1
d967 1
a967 1
	cpu_kcore_hdr_t	*chdr_p;
d980 1
a980 1
	/* 
d1021 1
a1021 1
	pmap_get_pagemap(vaddr, 0);
d1028 1
a1028 1
	pmap_get_pagemap(vaddr, NBPG);
d1083 1
d1096 3
d1100 1
a1100 1
	struct frame frame;
d1102 2
a1103 2
	printf("unexpected trap; vector offset 0x%x from 0x%x\n",
		frame.f_vector, frame.f_pc);
d1105 2
a1106 1
	kdb_trap(-1, &frame);
d1111 1
a1111 6
int
peek_word(addr)
	register caddr_t addr;
{
	label_t		faultbuf;
	register int x;
d1113 1
a1113 9
	nofault = (long*)&faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = NULL;
		return(-1);
	}
	x = *(volatile u_short *)addr;
	nofault = NULL;
	return(x);
}
d1115 2
a1116 19
/* from hp300: badbaddr() */
int
peek_byte(addr)
	register caddr_t addr;
{
	label_t 	faultbuf;
	register int x;

	nofault = (long*)&faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = NULL;
		return(-1);
	}
	x = *(volatile u_char *)addr;
	nofault = NULL;
	return(x);
}

/* XXX: parityenable() ? */
d1121 1
a1128 1
	extern char *hexstr();
d1164 1
a1169 1
	extern char *hexstr();
d1190 1
a1190 1
char *
d1213 1
a1213 1
 * 
d1217 1
@


1.7
log
@sync with NetBSD
@
text
@d108 1
a108 1
int	msgbufmapped;
d141 2
a142 2
	extern void cninit();
	cninit();
d157 1
a157 1
#endif DDB
d242 1
a242 1

d247 1
a247 1

d362 7
d775 1
d782 3
d792 1
a792 2
__dead void
boot(howto, user_boot_string)
d865 15
d890 1
a890 1
#define	DUMP_EXTRA 	3	/* CPU-dependent extra pages */
d920 1
a920 1
	dumpsize = physmem + DUMP_EXTRA;	/* pages */
d925 1
a925 1
	/* Note: Must force signed comparison. */
d947 1
a947 1
	cpu_kcore_hdr_t *chdr_p;
d960 1
a960 1
	/*
@


1.5
log
@handle RB_CONFIG
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.71 1996/03/26 15:16:53 gwr Exp $	*/
d66 2
d87 1
d108 1
d141 2
a142 2
    extern void cninit();
    cninit();
d144 7
d242 1
a242 1
	
d247 1
a247 1
	
a361 7
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
a767 1
	extern struct proc proc0;
a773 3
	/* fix curproc */
	if (curproc == NULL)
		curproc = &proc0;
a777 2
struct pcb dumppcb;

d781 2
a782 1
int reboot2(howto, user_boot_string)
d810 1
a810 2
	if (howto & RB_DUMP) {
		savectx(&dumppcb);
a811 1
	}
d850 1
a854 15
 * BSD reboot system call
 * XXX - Should be named: cpu_reboot maybe? -gwr
 * XXX - It would be nice to allow a second argument
 * that specifies a machine-dependent boot string that
 * is passed to the boot program if RB_STRING is set.
 */
void boot(howto)
	int howto;
{
	(void) reboot2(howto, NULL);
	for(;;);
	/* NOTREACHED */
}

/*
d861 6
d895 1
a895 1
	dumpsize = physmem; /* pages */
d900 1
a900 1
	/* Note: Must force signed comparison (fixes PR#887) */
d907 3
d911 6
a916 1
 * Write a crash dump.
d920 9
a928 3
#if 1
    printf("dumping not supported yet :)\n");
#else
d932 8
a939 1
	if (dumpsize == 0) {
d941 9
a949 2
		if (dumpsize == 0)
			return;
d951 1
d953 83
a1035 2
	/* XXX - todo... */
#endif
@


1.4
log
@avoid panics at reboot.
@
text
@d351 7
@


1.3
log
@sync with 0430.
@
text
@d757 1
d764 3
@


1.2
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.67 1996/01/04 22:22:54 jtc Exp $	*/
a94 2
#include <setjmp.h>

d101 1
d223 2
a224 1
void cpu_startup()
d242 2
d298 4
a301 1
	 * Allocate a submap for physio
a302 2
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);
d385 1
d400 1
a400 1
	printf("Model: %s\n", cpu_model);
d767 2
d779 3
a781 3
	/* take a snap shot before clobbering any registers */
	if (curproc && curproc->p_addr)
		savectx(curproc->p_addr);
d796 3
d800 2
a801 2
	splhigh();
	if (howto & RB_DUMP)
d803 4
d809 1
d856 2
d955 1
a955 1
	jmp_buf		faultbuf;
d959 1
a959 1
	if (setjmp(nofault)) {
d973 1
a973 1
	jmp_buf 	faultbuf;
d977 1
a977 1
	if (setjmp(nofault)) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.66 1995/10/07 06:26:13 mycroft Exp $	*/
d493 1
a493 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_base +
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
