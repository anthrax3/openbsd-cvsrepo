head	1.18;
access;
symbols
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2002.12.31.16.35.41;	author miod;	state dead;
branches;
next	1.17;

1.17
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.06.27.04.44.02;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.30.20.40.03;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.04.22.33.52;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.28.22.05.26;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.05.24.23.09.08;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	99.01.11.05.12.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.23.06.58.30;	author denny;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.04.04.24;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.07.23.36.29;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.31.06.13.48;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.08.26.07;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.03.16.04.41;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.14.21.37.35;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.07.04.10.24.10;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2003.03.27.23.52.18;	author niklas;	state dead;
branches;
next	;

1.15.2.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.18
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: isr.c,v 1.17 2002/03/14 03:16:01 millert Exp $	*/
/*	$NetBSD: isr.c,v 1.25 1996/11/20 18:57:32 gwr Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass and Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This handles multiple attach of autovectored interrupts,
 * and the handy software interrupt request register.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/vmmeter.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/machdep.h>
#include <machine/mon.h>
#include <machine/obio.h>

#include <uvm/uvm_extern.h>

#include "vector.h"

extern int intrcnt[];	/* statistics */

#define NUM_LEVELS 8

struct isr {
	struct isr *isr_next;
	isr_func_t isr_intr;
	void	   *isr_arg;
	int	   isr_ipl;
};

void set_vector_entry(int, void (*handler)(void));
unsigned int get_vector_entry(int);

void    isr_autovec(int);
void    isr_vectored(int);

void
isr_add_custom(level, handler)
	int level;
	void *handler;
{
	set_vector_entry(AUTOVEC_BASE + level, handler);
}

static struct isr *isr_autovec_list[NUM_LEVELS];

/*
 * This is called by the assembly routines
 * for handling auto-vectored interupts.
 */
void
isr_autovec(evec)
	int evec;		/* format | vector offset */
{
	struct isr *isr;
	register int n, ipl, vec;

	vec = (evec & 0xFFF) >> 2;
	if ((vec < AUTOVEC_BASE) || (vec >= (AUTOVEC_BASE+8)))
		panic("isr_autovec: bad vec");
	ipl = vec - AUTOVEC_BASE;

	n = intrcnt[ipl];
	intrcnt[ipl] = n+1;
	uvmexp.intrs++;

	isr = isr_autovec_list[ipl];
	if (isr == NULL) {
		if (n == 0)
			printf("isr_autovec: ipl %d unexpected\n", ipl);
		return;
	}

	/* Give all the handlers a chance. */
	n = 0;
	while (isr) {
		n |= isr->isr_intr(isr->isr_arg);
		isr = isr->isr_next;
	}
	if (!n)
		printf("isr_autovec: ipl %d not claimed\n", ipl);
}

/*
 * Establish an interrupt handler.
 * Called by driver attach functions.
 */
void
isr_add_autovect(handler, arg, level)
	isr_func_t handler;
	void *arg;
	int level;
{
	struct isr *new_isr;

	if ((level < 0) || (level >= NUM_LEVELS))
		panic("isr_add: bad level=%d", level);
	new_isr = (struct isr *)
		malloc(sizeof(struct isr), M_DEVBUF, M_NOWAIT);
	if (!new_isr)
		panic("isr_add: malloc failed");

	new_isr->isr_intr = handler;
	new_isr->isr_arg = arg;
	new_isr->isr_ipl = level;
	new_isr->isr_next = isr_autovec_list[level];
	isr_autovec_list[level] = new_isr;
}

struct vector_handler {
	isr_func_t func;
	void *arg;
};
static struct vector_handler isr_vector_handlers[192];

/*
 * This is called by the assembly glue
 * for handling vectored interupts.
 */
void
isr_vectored(evec)
	int evec;		/* format | vector offset */
{
	struct vector_handler *vh;
	register int ipl, vec;

	vec = (evec & 0xFFF) >> 2;
	ipl = getsr();
	ipl = (ipl >> 8) & 7;

	intrcnt[ipl]++;
	uvmexp.intrs++;

	if (vec < 64 || vec >= 256) {
		printf("isr_vectored: vector=0x%x (invalid)\n", vec);
		return;
	}
	vh = &isr_vector_handlers[vec - 64];
	if (vh->func == NULL) {
		printf("isr_vectored: vector=0x%x (nul func)\n", vec);
		set_vector_entry(vec, badtrap);
		return;
	}

	/* OK, call the isr function. */
	if (vh->func(vh->arg) == 0)
		printf("isr_vectored: vector=0x%x (not claimed)\n", vec);
}

/*
 * Establish an interrupt handler.
 * Called by driver attach functions.
 */

extern void _isr_vectored(void);

void
isr_add_vectored(func, arg, level, vec)
	isr_func_t func;
	void *arg;
	int level, vec;
{
	struct vector_handler *vh;

	if (vec < 64 || vec >= 256) {
		printf("isr_add_vectored: vect=0x%x (invalid)\n", vec);
		return;
	}
	vh = &isr_vector_handlers[vec - 64];
	if (vh->func) {
		printf("isr_add_vectored: vect=0x%x (in use)\n", vec);
		return;
	}
	vh->func = func;
	vh->arg = arg;
	set_vector_entry(vec, _isr_vectored);
}

/*
 * XXX - could just kill these...
 */
void
set_vector_entry(entry, handler)
	int entry;
	void (*handler)(void);
{
	if ((entry <0) || (entry >= NVECTORS))
		panic("set_vector_entry: setting vector too high or low");
	vector_table[entry] =  handler;
}

unsigned int
get_vector_entry(entry)
	int entry;
{
	if ((entry <0) || (entry >= NVECTORS))
		panic("get_vector_entry: setting vector too high or low");
	return (unsigned int) vector_table[entry];
}
@


1.17
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.16 2002/03/14 01:26:47 millert Exp $	*/
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.15 2001/11/06 19:53:16 miod Exp $	*/
d72 1
a72 1
void set_vector_entry __P((int, void (*handler)(void)));
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.14 2001/06/27 04:44:02 art Exp $	*/
d72 2
a73 2
void set_vector_entry __P((int, void (*handler) __P((void))));
unsigned int get_vector_entry __P((int));
d75 2
a76 2
void    isr_autovec  __P((int));
void    isr_vectored __P((int));
d196 1
a196 1
extern void _isr_vectored __P((void));
d226 1
a226 1
	void (*handler) __P((void));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.15 2001/11/06 19:53:16 miod Exp $	*/
d72 2
a73 2
void set_vector_entry(int, void (*handler)(void));
unsigned int get_vector_entry(int);
d75 2
a76 2
void    isr_autovec(int);
void    isr_vectored(int);
d196 1
a196 1
extern void _isr_vectored(void);
d226 1
a226 1
	void (*handler)(void);
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.15.2.1 2002/06/11 03:39:01 art Exp $	*/
@


1.14
log
@Zap old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.13 2001/05/30 20:40:03 miod Exp $	*/
a55 2

#include <vm/vm.h>
@


1.13
log
@Preliminary UVM support. UVM kernels don't work for the moment, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.12 2001/01/04 22:33:52 miod Exp $	*/
a58 1
#ifdef UVM
a59 1
#endif
a107 1
#ifdef UVM
a108 3
#else
	cnt.v_intr++;
#endif
a174 1
#ifdef UVM
a175 3
#else
	cnt.v_intr++;
#endif
@


1.12
log
@Remove netintr().
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.11 2000/08/28 22:05:26 miod Exp $	*/
d57 6
d110 3
d114 1
d181 3
d185 1
@


1.11
log
@Less magic numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.10 1999/12/08 06:50:17 itojun Exp $	*/
a50 2
#include <net/netisr.h>

a58 4
#include "ether.h"	/* for NETHER */
#include "ppp.h"	/* for NPPP */
#include "bridge.h"	/* for NBRIDGE */

a82 74

/*
 * XXX - This really belongs in some common file,
 *	i.e.  src/sys/net/netisr.c
 * Also, should use an array of chars instead of
 * a bitmask to avoid atomicity locking issues.
 */

/*
 * Declarations for the netisr functions...
 * They are in the header files, but that's not
 * really a good reason to drag all those in.
 */
void arpintr __P((void));
void ipintr __P((void));
void ip6intr __P((void));
void atintr __P((void));
void nsintr __P((void));
void clnlintr __P((void));
void ccittintr __P((void));
void pppintr __P((void));
void bridgeintr __P((void));

void
netintr()
{
	int n, s;

	s = splhigh();
	n = netisr;
	netisr = 0;
	splx(s);

#if	NETHER > 0
	if (n & (1 << NETISR_ARP))
		arpintr();
#endif
#ifdef INET
	if (n & (1 << NETISR_IP))
		ipintr();
#endif
#ifdef INET6
	if (n & (1 << NETISR_IPV6))
		ip6intr();
#endif
#ifdef NETATALK
	if (n & (1 << NETISR_ATALK))
		atintr();
#endif
#ifdef NS
	if (n & (1 << NETISR_NS))
		nsintr();
#endif
#ifdef ISO
	if (n & (1 << NETISR_ISO))
		clnlintr();
#endif
#ifdef CCITT
	if (n & (1 << NETISR_CCITT)) {
		ccittintr();
	}
#endif
#if NPPP > 0
	if (n & (1 << NETISR_PPP)) {
		pppintr();
	}
#endif
#if NBRIDGE > 0
	if (n & (1 << NETISR_BRIDGE)) {
		bridgeintr();
	}
#endif
}

@


1.10
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.9 1999/05/24 23:09:08 jason Exp $	*/
d180 1
a180 1
	ipl = vec - 0x18;
@


1.10.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.12 2001/01/04 22:33:52 miod Exp $	*/
d51 2
d61 4
d90 74
d180 1
a180 1
	ipl = vec - AUTOVEC_BASE;
@


1.10.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.10.2.1 2001/05/14 21:37:35 niklas Exp $	*/
a56 4
#include <vm/vm.h>

#include <uvm/uvm_extern.h>

d104 1
a104 1
	uvmexp.intrs++;
d171 1
a171 1
	uvmexp.intrs++;
@


1.10.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 2
@


1.10.2.4
log
@Merge in -current from about a week ago
@
text
@d72 2
a73 2
void set_vector_entry(int, void (*handler)(void));
unsigned int get_vector_entry(int);
d75 2
a76 2
void    isr_autovec(int);
void    isr_vectored(int);
d196 1
a196 1
extern void _isr_vectored(void);
d226 1
a226 1
	void (*handler)(void);
@


1.10.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.10.2.4 2002/03/28 11:26:45 niklas Exp $	*/
@


1.9
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.8 1999/01/11 05:12:06 millert Exp $	*/
d104 1
d129 4
@


1.8
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.7 1997/07/23 06:58:30 denny Exp $	*/
d63 1
d109 1
d149 5
@


1.7
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: isr.c,v 1.6 1997/01/16 04:04:24 kstailey Exp $	*/
d295 1
a295 1
		panic("set_vector_entry: setting vector too high or low\n");
d304 1
a304 1
		panic("get_vector_entry: setting vector too high or low\n");
@


1.6
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
d126 4
@


1.5
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
d47 1
d53 1
d55 1
a57 1
#include <machine/isr.h>
d62 1
d69 4
a72 4
	struct	isr *isr_next;
	int	(*isr_intr)();
	void *isr_arg;
	int	isr_ipl;
d75 1
a75 1
void set_vector_entry __P((int, void (*handler)()));
d78 5
a82 1
void isr_add_custom(level, handler)
d84 1
a84 1
	void (*handler)();
d95 15
a109 1
void netintr()
a138 1
#include "ppp.h"
d153 2
a154 1
void isr_autovec(evec)
d190 3
a192 2
void isr_add_autovect(handler, arg, level)
	int (*handler)();
a211 1
extern void badtrap();
d213 1
a213 1
	int (*func)();
d256 6
a261 3
extern void _isr_vectored();
void isr_add_vectored(func, arg, level, vec)
	int (*func)();
d284 2
a285 1
void set_vector_entry(entry, handler)
d287 1
a287 1
	void (*handler)();
d290 1
a290 1
	panic("set_vector_entry: setting vector too high or low\n");
d293 3
a295 1
unsigned int get_vector_entry(entry)
d299 1
a299 1
	panic("get_vector_entry: setting vector too high or low\n");
@


1.4
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: isr.c,v 1.26 1996/12/17 21:11:29 gwr Exp $	*/
a45 1
#include <sys/device.h>
a50 1
#include <machine/autoconf.h>
d54 1
a55 1
#include "machdep.h"
d58 2
d66 1
a66 1
	isr_func_t isr_intr;
d71 2
a72 11
void set_vector_entry __P((int, void *));
void * get_vector_entry __P((int));

/*
 * These are called from locore.  The "struct clockframe" arg
 * is really just the normal H/W interrupt frame format.
 * (kern_clock really wants it to be named that...)
 */
void	isr_autovec  __P((struct clockframe));
void	isr_vectored __P((struct clockframe));

d74 1
a74 2
void
isr_add_custom(level, handler)
d76 1
a76 1
	void *handler;
a80 1

a81 1
 * netisr junk...
a86 16

#include "ether.h"	/* for NETHER */
#include "ppp.h"

/*
 * Declarations for the netisr functions...
 * They are in the header files, but that's not
 * really a good reason to drag all those in.
 */
void arpintr __P((void));
void ipintr __P((void));
void nsintr __P((void));
void clnlintr __P((void));
void ccittintr __P((void));
void pppintr __P((void));

d117 1
d132 2
a133 2
void isr_autovec(cf)
	struct clockframe cf;
d138 1
a138 1
	vec = (cf.cf_vo & 0xFFF) >> 2;
d169 1
a169 1
	isr_func_t handler;
d189 1
d191 1
a191 1
	isr_func_t func;
d201 2
a202 2
isr_vectored(cf)
	struct clockframe cf;
d207 1
a207 1
	vec = (cf.cf_vo & 0xFFF) >> 2;
d221 1
a221 1
		set_vector_entry(vec, (void *)badtrap);
d234 3
a236 4
extern void _isr_vectored __P((void));
void
isr_add_vectored(func, arg, level, vec)
	isr_func_t func;
d253 1
a253 1
	set_vector_entry(vec, (void *)_isr_vectored);
d259 1
a259 2
void
set_vector_entry(entry, handler)
d261 1
a261 1
	void *handler;
d265 1
a265 1
	vector_table[entry] = handler;
d267 1
a267 3

void *
get_vector_entry(entry)
d272 1
a272 1
	return ((void *) vector_table[entry]);
@


1.3
log
@sync with NetBSD -- copyright changes only
@
text
@d1 1
a1 1
/*	$NetBSD: isr.c,v 1.25 1996/11/20 18:57:32 gwr Exp $	*/
d46 1
d52 1
a55 1
#include <machine/isr.h>
d57 1
a59 2
#include "ether.h"	/* for NETHER */

d66 1
a66 1
	int	(*isr_intr)();
d71 11
a81 2
void set_vector_entry __P((int, void (*handler)()));
unsigned int get_vector_entry __P((int));
d83 2
a84 1
void isr_add_custom(level, handler)
d86 1
a86 1
	void (*handler)();
d91 1
d93 1
d99 16
a144 1
#include "ppp.h"
d159 2
a160 2
void isr_autovec(evec)
	int evec;		/* format | vector offset */
d165 1
a165 1
	vec = (evec & 0xFFF) >> 2;
d196 1
a196 1
	int (*handler)();
a215 1
extern void badtrap();
d217 1
a217 1
	int (*func)();
d227 2
a228 2
isr_vectored(evec)
	int evec;		/* format | vector offset */
d233 1
a233 1
	vec = (evec & 0xFFF) >> 2;
d247 1
a247 1
		set_vector_entry(vec, badtrap);
d260 4
a263 3
extern void _isr_vectored();
void isr_add_vectored(func, arg, level, vec)
	int (*func)();
d280 1
a280 1
	set_vector_entry(vec, _isr_vectored);
d286 2
a287 1
void set_vector_entry(entry, handler)
d289 1
a289 1
	void (*handler)();
d293 1
a293 1
	vector_table[entry] =  handler;
d295 3
a297 1
unsigned int get_vector_entry(entry)
d302 1
a302 1
	return (unsigned int) vector_table[entry];
@


1.2
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: isr.c,v 1.22 1996/03/26 15:16:47 gwr Exp $	*/
d3 2
a4 3
/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
d7 3
d20 5
a24 3
 *	This product includes software developed by Adam Glass.
 * 4. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d26 11
a36 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: isr.c,v 1.21 1995/10/08 23:47:34 gwr Exp $	*/
a51 1
#include "interreg.h"
a65 1

a67 21
static int nmi_intr();
static int soft1intr();

volatile u_char *interrupt_reg;

/* called early (by internal_configure) */
void isr_init()
{
	interrupt_reg = obio_find_mapping(OBIO_INTERREG, 1);
	if (!interrupt_reg)
		mon_panic("interrupt reg VA not found\n");
	/* Turn off all interrupts until clock_attach */
	*interrupt_reg = 0;
}

/* called later, by configure */
void isr_config()
{
	isr_add_autovect(nmi_intr, 0, 7);
	isr_add_autovect(soft1intr, 0, 1);
}
a75 47
static int isr_soft_pending;
void isr_soft_request(level)
	int level;
{
	u_char bit, reg_val;
	int s;

	if ((level < 1) || (level > 3))
		panic("isr_soft_request");

	bit = 1 << level;

	/* XXX - Should do this in the callers... */
	if (isr_soft_pending & bit)
		return;

	s = splhigh();
	isr_soft_pending |= bit;
	reg_val = *interrupt_reg;
	*interrupt_reg &= ~IREG_ALL_ENAB;

	*interrupt_reg |= bit;
	*interrupt_reg |= IREG_ALL_ENAB;
	splx(s);
}

void isr_soft_clear(level)
	int level;
{
	u_char bit, reg_val;
	int s;

	if ((level < 1) || (level > 3))
		panic("isr_soft_clear");

	bit = 1 << level;

	s = splhigh();
	isr_soft_pending &= ~bit;
	reg_val = *interrupt_reg;
	*interrupt_reg &= ~IREG_ALL_ENAB;

	*interrupt_reg &= ~bit;
	*interrupt_reg |= IREG_ALL_ENAB;
	splx(s);
}

a117 57
}


/*
 * Level 1 software interrupt.
 * Possible reasons:
 *	Network software interrupt
 *	Soft clock interrupt
 */
int soft1intr(arg)
	void *arg;
{
	union sun3sir sir;
	int n, s;

	s = splhigh();
	sir.sir_any = sun3sir.sir_any;
	sun3sir.sir_any = 0;
	isr_soft_clear(1);
	splx(s);

	if (sir.sir_any) {
		cnt.v_soft++;
		if (sir.sir_which[SIR_NET]) {
			sir.sir_which[SIR_NET] = 0;
			netintr();
		}
		if (sir.sir_which[SIR_CLOCK]) {
			sir.sir_which[SIR_CLOCK] = 0;
			softclock();
		}
		if (sir.sir_which[SIR_SPARE2]) {
			sir.sir_which[SIR_SPARE2] = 0;
			/* spare2intr(); */
		}
		if (sir.sir_which[SIR_SPARE3]) {
			sir.sir_which[SIR_SPARE3] = 0;
			/* spare3intr(); */
		}
		return (1);
	}
	return(0);
}

/*
 * Generic handler for the non-maskable interrupt.
 * XXX: Should check memory error register here!
 */
int nmi_intr(arg)
	void *arg;
{
	static int nmi_cnt;
	if (!nmi_cnt++) {
		printf("nmi interrupt received\n");
		Debugger();
	}
	return 1;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
