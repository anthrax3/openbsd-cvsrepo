head	1.20;
access;
symbols
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2002.12.31.16.35.42;	author miod;	state dead;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.08.02.24.07;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.11.23.21.14;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.04.44.03;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.30.20.40.04;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.05.20.56.54;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.02.23.02.14;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	99.11.22.19.22.03;	author matthieu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	98.08.31.17.42.42;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.02.10.11.53.11;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.16.04.04.30;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.13.00.29.25;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.01.07.23.36.31;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.12.31.06.13.57;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2000.03.24.09.08.55;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.24.14;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2003.03.27.23.52.19;	author niklas;	state dead;
branches;
next	;

1.18.2.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.20
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: mem.c,v 1.19 2002/03/14 01:26:47 millert Exp $	*/
/*	$NetBSD: mem.c,v 1.19 1995/08/08 21:09:01 gwr Exp $	*/

/*
 * Copyright (c) 1994, 1995 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass 
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)mem.c	8.3 (Berkeley) 1/12/94
 */

/*
 * Memory special file
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/uio.h>

#include <uvm/uvm_extern.h>

#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/eeprom.h>
#include <machine/machdep.h>
#include <machine/pte.h>
#include <machine/pmap.h>

extern int ledrw(struct uio *);

static caddr_t devzeropage;

/*ARGSUSED*/
int
mmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	switch (minor(dev)) {
		case 0:
		case 1:
		case 2:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
			return (0);
		default:
			return (ENXIO);
	}
}

/*ARGSUSED*/
int
mmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	return (0);
}

/*ARGSUSED*/
int
mmrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	register vm_offset_t o, v;
	register int c;
	register struct iovec *iov;
	int error = 0;
	static int physlock;

	if (minor(dev) == 0) {
		if (vmmap == 0)
			return (EIO);
		/* lock against other uses of shared vmmap */
		while (physlock > 0) {
			physlock++;
			error = tsleep((caddr_t)&physlock, PZERO | PCATCH,
			    "mmrw", 0);
			if (error)
				return (error);
		}
		physlock = 1;
	}
	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("mmrw");
			continue;
		}
		switch (minor(dev)) {

/* minor device 0 is physical memory */
		case 0:
			v = uio->uio_offset;
			/* allow reads only in RAM */
			if (v < 0 || v >= avail_end) {
				error = EFAULT;
				goto unlock;
			}
			/*
			 * If the offset (physical address) is outside the
			 * region of physical memory that is "managed" by
			 * the pmap system, then we are not allowed to
			 * call pmap_enter with that physical address.
			 * Everything from zero to avail_start is mapped
			 * linearly with physical zero at virtual KERNBASE,
			 * so redirect the access to /dev/kmem instead.
			 * This is a better alternative than hacking the
			 * pmap to deal with requests on unmanaged memory.
			 * Also note: unlock done at end of function.
			 */
			if (v < avail_start) {
				v += KERNBASE;
				goto use_kmem;
			}
			/* Temporarily map the memory at vmmap. */
			pmap_enter(pmap_kernel(), vmmap,
			    trunc_page(v), uio->uio_rw == UIO_READ ?
			    VM_PROT_READ : VM_PROT_WRITE, PMAP_WIRED);
			pmap_update(pmap_kernel());
			o = uio->uio_offset & PGOFSET;
			c = min(uio->uio_resid, (int)(NBPG - o));
			error = uiomove((caddr_t)vmmap + o, c, uio);
			pmap_remove(pmap_kernel(), vmmap, vmmap + NBPG);
			pmap_update(pmap_kernel());
			continue;

/* minor device 1 is kernel memory */
		/* XXX - Allow access to the PROM? */
		case 1:
			v = uio->uio_offset;
		use_kmem:
			/*
			 * Watch out!  You might assume it is OK to copy
			 * up to MAXPHYS bytes here, but that is wrong.
			 * The next page might NOT be part of the range:
			 *   	(KERNBASE..(KERNBASE+avail_start))
			 * which is asked for here via the goto in the
			 * /dev/mem case above.  The consequence is that
			 * we copy one page at a time.  Big deal.
			 * Most requests are small anyway. -gwr
			 */
			o = v & PGOFSET;
			c = min(uio->uio_resid, (int)(NBPG - o));
			if (!uvm_kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE)) {
				error = EFAULT;
				goto unlock;
			}
			error = uiomove((caddr_t)v, c, uio);
			continue;

/* minor device 2 is EOF/RATHOLE */
		case 2:
			if (uio->uio_rw == UIO_WRITE)
				uio->uio_resid = 0;
			return (0);

/* minor device 11 (/dev/eeprom) accesses Non-Volatile RAM */
		case 11:
			error = eeprom_uio(uio);
			return (error);

/* minor device 12 (/dev/zero) is source of nulls on read, rathole on write */
		case 12:
			if (uio->uio_rw == UIO_WRITE) {
				c = iov->iov_len;
				break;
			}
			/*
			 * On the first call, allocate and zero a page
			 * of memory for use with /dev/zero.
			 */
			if (devzeropage == NULL) {
				devzeropage = (caddr_t)
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(devzeropage, PAGE_SIZE);
			}
			c = min(iov->iov_len, PAGE_SIZE);
			error = uiomove(devzeropage, c, uio);
			continue;

/* minor device 13 (/dev/leds) accesses the blinkenlights */
		case 13:
			error = ledrw(uio);
			return(error);

		default:
			return (ENXIO);
		}
		if (error)
			break;
		iov->iov_base += c;
		iov->iov_len -= c;
		uio->uio_offset += c;
		uio->uio_resid -= c;
	}

	/*
	 * Note the different location of this label, compared with
	 * other ports.  This is because the /dev/mem to /dev/kmem
	 * redirection above jumps here on error to do its unlock.
	 */
unlock:
	if (minor(dev) == 0) {
		if (physlock > 1)
			wakeup((caddr_t)&physlock);
		physlock = 0;
	}
	return (error);
}

paddr_t
mmmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	register int v = off;

	/*
	 * Check address validity.
	 */
	if (v & PGOFSET)
		return (-1);

	switch (minor(dev)) {

	case 0:		/* dev/mem */
		/* Allow access only in "managed" RAM. */
		if (v < avail_start || v >= avail_end)
			break;
		return (v);

	case 5: 	/* dev/vme16d16 */
		if (v & 0xffff0000)
			break;
		v |= 0xff0000;
		/* fall through */
	case 6: 	/* dev/vme24d16 */
		if (v & 0xff000000)
			break;
		v |= 0xff000000;
		/* fall through */
	case 7: 	/* dev/vme32d16 */
		return (v | PMAP_VME16);

	case 8: 	/* dev/vme16d32 */
		if (v & 0xffff0000)
			break;
		v |= 0xff0000;
		/* fall through */
	case 9: 	/* dev/vme24d32 */
		if (v & 0xff000000)
			break;
		v |= 0xff000000;
		/* fall through */
	case 10:	/* dev/vme32d32 */
		return (v | PMAP_VME32);
	}

	return (-1);
}

/*ARGSUSED*/
int
mmioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{
	return (EOPNOTSUPP);
}
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.18 2001/12/08 02:24:07 art Exp $	*/
@


1.18
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.17 2001/11/06 19:53:16 miod Exp $	*/
d67 1
a67 1
extern int ledrw __P((struct uio *));
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.18 2001/12/08 02:24:07 art Exp $	*/
d67 1
a67 1
extern int ledrw(struct uio *);
@


1.18.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.18.2.1 2002/06/11 03:39:01 art Exp $	*/
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.16 2001/11/01 12:13:46 art Exp $	*/
d174 1
d179 1
@


1.16
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.15 2001/09/11 20:05:24 miod Exp $	*/
d58 1
a58 1
#include <vm/vm.h>
@


1.15
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.14 2001/08/11 23:21:14 art Exp $	*/
d265 1
a265 1
int
d268 2
a269 1
	int off, prot;
@


1.14
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.13 2001/07/25 13:25:33 art Exp $	*/
a58 1
#include <vm/vm_kern.h>
@


1.13
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.12 2001/06/27 04:44:03 art Exp $	*/
a59 1
#include <vm/vm_map.h>
@


1.12
log
@Zap old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.11 2001/05/30 20:40:04 miod Exp $	*/
d175 1
a175 1
			    VM_PROT_READ : VM_PROT_WRITE, TRUE, 0);
@


1.11
log
@Preliminary UVM support. UVM kernels don't work for the moment, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.10 2001/05/05 20:56:54 art Exp $	*/
a198 1
#ifdef UVM
d200 1
a200 6
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE))
#else
			if (!kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE))
#endif
			{
@


1.10
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.9 2000/03/02 23:02:14 todd Exp $	*/
d199 4
d205 1
@


1.9
log
@sun3 is alive, thanks to Miod Vallat <miodrag@@ifrance.com>
add ksyms, proto fix, msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8 1999/11/22 19:22:03 matthieu Exp $	*/
d231 2
a232 2
				    malloc(CLBYTES, M_TEMP, M_WAITOK);
				bzero(devzeropage, CLBYTES);
d234 1
a234 1
			c = min(iov->iov_len, CLBYTES);
@


1.8
log
@add empty mmioctl() implementation for new /dev/mem interface for all
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.7 1998/08/31 17:42:42 millert Exp $	*/
d175 1
a175 1
			    VM_PROT_READ : VM_PROT_WRITE, TRUE);
@


1.8.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d175 1
a175 1
			    VM_PROT_READ : VM_PROT_WRITE, TRUE, 0);
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8.2.1 2000/03/24 09:08:55 niklas Exp $	*/
d199 3
a201 2
			if (!uvm_kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE)) {
d231 2
a232 2
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(devzeropage, PAGE_SIZE);
d234 1
a234 1
			c = min(iov->iov_len, PAGE_SIZE);
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8.2.2 2001/07/04 10:24:14 niklas Exp $	*/
d59 2
d175 1
a175 1
			    VM_PROT_READ : VM_PROT_WRITE, PMAP_WIRED);
@


1.8.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
#include <uvm/uvm_extern.h>
d265 1
a265 1
paddr_t
d268 1
a268 2
	off_t off;
	int prot;
@


1.8.2.5
log
@Merge in trunk
@
text
@a173 1
			pmap_update(pmap_kernel());
a177 1
			pmap_update(pmap_kernel());
@


1.8.2.6
log
@Merge in -current from about a week ago
@
text
@d67 1
a67 1
extern int ledrw(struct uio *);
@


1.8.2.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8.2.6 2002/03/28 11:26:45 niklas Exp $	*/
@


1.7
log
@Return ENXIO on open of /dev/mem minor devs that don't exist
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.6 1997/02/10 11:53:11 downsj Exp $	*/
d317 12
@


1.6
log
@zeropage -> devzeropage
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.5 1997/01/16 04:04:30 kstailey Exp $	*/
d81 17
a97 1
	return (0);
@


1.5
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 1
caddr_t zeropage;
d213 2
a214 2
			if (zeropage == NULL) {
				zeropage = (caddr_t)
d216 1
a216 1
				bzero(zeropage, CLBYTES);
d219 1
a219 1
			error = uiomove(zeropage, c, uio);
@


1.4
log
@back-panel LED control device derived from code by der Mouse
@
text
@d1 1
d51 2
d54 2
a55 2
#include <sys/buf.h>
#include <sys/systm.h>
a56 1
#include <sys/malloc.h>
d62 1
d64 2
d69 1
a69 2
extern int eeprom_uio();
extern vm_offset_t avail_start, avail_end;
a70 3
vm_offset_t vmmap;	/* XXX - poor name...
                     * It is a virtual page, not a map.
                     */
a72 1

d75 1
a75 1
mmopen(dev, flag, mode)
d78 1
d86 1
a86 1
mmclose(dev, flag, mode)
d89 1
@


1.3
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d220 5
@


1.2
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: mem.c,v 1.20 1996/12/17 21:11:36 gwr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993 Adam Glass
d50 2
d53 1
a53 2
#include <sys/buf.h>
#include <sys/conf.h>
a54 2
#include <sys/proc.h>
#include <sys/uio.h>
a60 1
#include <machine/eeprom.h>
d64 2
a65 1
#include "machdep.h"
d67 4
a70 2
#define	mmread	mmrw
cdev_decl(mm);
a71 1
static caddr_t zeropage;
d75 1
a75 1
mmopen(dev, flag, mode, p)
a77 1
	struct proc *p;
d85 1
a85 1
mmclose(dev, flag, mode, p)
a87 1
	struct proc *p;
d134 1
a134 1
			if (v >= avail_end) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mem.c,v 1.19 1995/08/08 21:09:01 gwr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993 Adam Glass 
d50 2
d53 2
a54 2
#include <sys/buf.h>
#include <sys/systm.h>
a55 1
#include <sys/malloc.h>
d62 1
d66 1
a66 2
extern int eeprom_uio();
extern vm_offset_t avail_start, avail_end;
d68 2
a69 4
vm_offset_t vmmap;	/* XXX - poor name...
                     * It is a virtual page, not a map.
                     */
caddr_t zeropage;
d71 1
d75 1
a75 1
mmopen(dev, flag, mode)
d78 1
d86 1
a86 1
mmclose(dev, flag, mode)
d89 1
d136 1
a136 1
			if (v < 0 || v >= avail_end) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
