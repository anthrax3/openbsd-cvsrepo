head	1.23;
access;
symbols
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	UBC_SYNC_A:1.23
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2002.12.31.16.35.41;	author miod;	state dead;
branches;
next	1.22;

1.22
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.10.00.58.05;	author miod;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.12.08.02.24.07;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.11.23.21.14;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.04.44.02;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.11.01.30.13;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.30.20.37.54;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.05.22.34.24;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.14.14.28.56;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	99.11.09.14.30.39;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	97.09.07.14.05.19;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.04.04.11;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.07.23.36.22;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.31.06.13.29;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.07.55.05;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.03.16.04.24;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.00;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.21.37.33;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.24.06;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2003.03.27.23.52.18;	author niklas;	state dead;
branches;
next	;

1.19.2.1
date	2002.01.31.22.55.25;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.05.19.21.49.45;	author tedu;	state dead;
branches;
next	;


desc
@@


1.23
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: autoconf.c,v 1.22 2002/03/14 03:16:01 millert Exp $	*/
/*	$NetBSD: autoconf.c,v 1.37 1996/11/20 18:57:22 gwr Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass and Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/dkstat.h>
#include <sys/reboot.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/control.h>
#include <machine/disklabel.h>
#include <machine/cpu.h>
#include <machine/machdep.h>
#include <machine/mon.h>
#include <machine/pte.h>
#include <machine/pmap.h>

#include <dev/cons.h>

/* Want compile-time initialization here. */
int cold = 1;

void setroot(void);
void swapconf(void);
int findblkmajor(struct device *);
struct device *getdisk(char *, int, int, dev_t *);
struct device *parsedisk(char *, int, int, dev_t *);
int getstr(char *, int);

void
cpu_configure()
{
	struct device *mainbus;

	/* General device autoconfiguration. */
	mainbus = config_rootfound("mainbus", NULL);
	if (mainbus == NULL)
		panic("cpu_configure: mainbus not found");

	/*
	 * Now that device autoconfiguration is finished,
	 * we can safely enable interrupts.
	 */
	printf("enabling interrupts\n");
	(void)spl0();

	/*
	 * Configure swap area and related system
	 * parameters based on device(s) used.
	 */
	setroot();
	swapconf();
	
	cold = 0;
}

/*
 * Generic "bus" support functions.
 *
 * bus_scan:
 * This function is passed to config_search() by the attach function
 * for each of the "bus" drivers (obctl, obio, obmem, vmes, vmel).
 * The purpose of this function is to copy the "locators" into our
 * confargs structure, so child drivers may use the confargs both
 * as match parameters and as temporary storage for the defaulted
 * locator values determined in the child_match and preserved for
 * the child_attach function.  If the bus attach functions just
 * used config_found, then we would not have an opportunity to
 * setup the confargs for each child match and attach call.
 *
 * bus_print:
 * Just prints out the final (non-default) locators.
 */
int
bus_scan(parent, child, aux)
	struct device *parent;
	void *child, *aux;
{
	struct cfdata *cf = child;
	struct confargs *ca = aux;
	cfmatch_t mf;

#ifdef	DIAGNOSTIC
	if (parent->dv_cfdata->cf_driver->cd_indirect)
		panic("bus_scan: indirect?");
	if (cf->cf_fstate == FSTATE_STAR)
		panic("bus_scan: FSTATE_STAR");
#endif

	/* ca->ca_bustype set by parent */
	ca->ca_paddr  = cf->cf_loc[0];
	ca->ca_intpri = cf->cf_loc[1];
	ca->ca_intvec = -1;

	if ((ca->ca_bustype == BUS_VME16) ||
	    (ca->ca_bustype == BUS_VME32)) {
		ca->ca_intvec = cf->cf_loc[2];
	}

	/*
	 * Note that this allows the match function to save
	 * defaulted locators in the confargs that will be
	 * preserved for the related attach call.
	 */
	mf = cf->cf_attach->ca_match;
	if ((*mf)(parent, cf, ca) > 0) {
		config_attach(parent, cf, ca, bus_print);
	}
	return (0);
}

/*
 * Print out the confargs.  The parent name is non-NULL
 * when there was no match found by config_found().
 */
int
bus_print(args, name)
	void *args;
	const char *name;
{
	struct confargs *ca = args;

	if (name)
		printf("%s:", name);

	if (ca->ca_paddr != -1)
		printf(" addr 0x%x", ca->ca_paddr);
	if (ca->ca_intpri != -1)
		printf(" level %d", ca->ca_intpri);
	if (ca->ca_intvec != -1)
		printf(" vector 0x%x", ca->ca_intvec);

	return(UNCONF);
}

extern vm_offset_t tmp_vpages[];
static const int bustype_to_ptetype[4] = {
	PGT_OBMEM,
	PGT_OBIO,
	PGT_VME_D16,
	PGT_VME_D32,
};

/*
 * Read addr with size len (1,2,4) into val.
 * If this generates a bus error, return -1
 *
 *	Create a temporary mapping,
 *	Try the access using peek_*
 *	Clean up temp. mapping
 */
int
bus_peek(bustype, paddr, sz)
	int bustype, paddr, sz;
{
	int off, pte, rv;
	vm_offset_t pgva;
	caddr_t va;

	if (bustype & ~3)
		return -1;

	off = paddr & PGOFSET;
	paddr -= off;
	pte = PA_PGNUM(paddr);
	pte |= bustype_to_ptetype[bustype];
	pte |= (PG_VALID | PG_WRITE | PG_SYSTEM | PG_NC);

	pgva = tmp_vpages[0];
	va = (caddr_t)pgva + off;

	/* All mappings in tmp_vpages are non-cached, so no flush. */
	set_pte(pgva, pte);

	/*
	 * OK, try the access using one of the assembly routines
	 * that will set pcb_onfault and catch any bus errors.
	 */
	switch (sz) {
	case 1:
		rv = peek_byte(va);
		break;
	case 2:
		rv = peek_word(va);
		break;
	default:
		printf(" bus_peek: invalid size=%d\n", sz);
		rv = -1;
	}

	/* All mappings in tmp_vpages are non-cached, so no flush. */
	set_pte(pgva, PG_INVAL);

	return rv;
}

static const int bustype_to_pmaptype[4] = {
	0,
	PMAP_OBIO,
	PMAP_VME16,
	PMAP_VME32,
};

char *
bus_mapin(bustype, paddr, sz)
	int bustype, paddr, sz;
{
	int off, pa, pmt;
	vm_offset_t va, retval;

	if (bustype & ~3)
		return (NULL);

	off = paddr & PGOFSET;
	pa = paddr - off;
	sz += off;
	sz = round_page(sz);

	pmt = bustype_to_pmaptype[bustype];
	pmt |= PMAP_NC;	/* non-cached */

	/* Get some kernel virtual address space. */
	va = uvm_km_valloc_wait(kernel_map, sz);
	if (va == 0)
		panic("bus_mapin");
	retval = va + off;

	/* Map it to the specified bus. */
#if 0	/* XXX */
	/* This has a problem with wrap-around... */
	pmap_map((int)va, pa | pmt, pa + sz, VM_PROT_ALL);
#else
	do {
		pmap_enter(pmap_kernel(), va, pa | pmt, VM_PROT_ALL, 0);
		va += NBPG;
		pa += NBPG;
	} while ((sz -= NBPG) > 0);
#endif
	pmap_update(pmap_kernel());

	return ((char *)retval);
}

/* from hp300: badaddr() */
int
peek_word(addr)
	register caddr_t addr;
{
	label_t		faultbuf;
	register int	x;

	nofault = &faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = NULL;
		return(-1);
	}
	x = *(volatile u_short *)addr;
	nofault = NULL;
	return(x);
}

/* from hp300: badbaddr() */
int
peek_byte(addr)
	register caddr_t addr;
{
	label_t		faultbuf;
	register int	x;

	nofault = &faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = NULL;
		return(-1);
	}
	x = *(volatile u_char *)addr;
	nofault = NULL;
	return(x);
}

/****************************************************************/

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	dumpconf();
}

struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "xy",		3 },
	{ "sd",		7 },
	{ "xd",		10 },
	{ "st",		11 },
	{ "rd",		17 },
	{ "cd",		18 },
};

/* This takes the args: name, ctlr, unit */
typedef struct device *(*findfunc_t)(char *, int, int);

struct device *find_dev_byname(char *);
struct device *net_find(char *, int, int);
struct device *scsi_find(char *, int, int);
struct device *xx_find(char *, int, int);

struct prom_n2f {
	char name[4];
	findfunc_t func;
} prom_dev_table[] = {
	{ "ie",	net_find },
	{ "le",	net_find },
	{ "sd",	scsi_find },
	{ "xy",	xx_find },
	{ "xd",	xx_find },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	register int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-%c]", dv->dv_xname,
				    'a' + MAXPARTITIONS - 1);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot()
{
	MachMonBootParam *bp;
	struct prom_n2f *nf;
	char promname[3];
	findfunc_t find;
	struct swdevt *swp;
	struct device *bootdv;
	int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	/* PROM boot parameters. */
	bp = *romp->bootParam;

	/*
	 * Copy PROM boot device name (two letters)
	 * to a normal, null terminated string.
	 * (No terminating null in bp->devName)
	 */
	promname[0] = bp->devName[0];
	promname[1] = bp->devName[1];
	promname[2] = '\0';

	/* Default to "unknown" */
	bootdv = NULL;
	part = 0;
	find = NULL;

	/* Do we know anything about the PROM boot device? */
	for (nf = prom_dev_table; nf->func; nf++)
		if (strcmp(nf->name, promname) == 0) {
			find = nf->func;
			break;
		}
	if (find != NULL)
		bootdv = (*find)(promname, bp->ctlrNum, bp->unitNum);
	if (bootdv != NULL) {
		if (bootdv->dv_class == DV_DISK)
			part = bp->partNum;
	}

	/*
	 * If `swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? part + 'a' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				bootdv = getdisk(buf, len, 1, &nrootdev);
				if (bootdv != NULL) {
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			bootdv = getdisk(buf, len, part, &nrootdev);
			if (bootdv != NULL) {
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			bootdv = getdisk(buf, len, 1, &nswapdev);
			if (bootdv != NULL) {
				if (bootdv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else if (mountroot == NULL) {

		/*
		 * `swap generic': Use the device the PROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * part is the partition number.
			 * Assume swap is on partition b.
			 */
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
}

int
getstr(cp, size)
	register char *cp;
	register int size;
{
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}

/*
 * Functions to find devices using PROM boot parameters.
 */

/*
 * Network device:  Just use controller number.
 */
struct device *
net_find(name, ctlr, unit)
	char *name;
	int ctlr, unit;
{
	char tname[16];

	sprintf(tname, "%s%d", name, ctlr);
	return (find_dev_byname(tname));
}

/*
 * SCSI device:  The controller number corresponds to the
 * scsibus number, and the unit number is (targ*8 + LUN).
 */
struct device *
scsi_find(name, ctlr, unit)
	char *name;
	int ctlr, unit;
{
	struct device *scsibus;
	struct scsibus_softc *sbsc;
	struct scsi_link *sc_link;
	int target, lun;
	char tname[16];

	sprintf(tname, "scsibus%d", ctlr);
	scsibus = find_dev_byname(tname);
	if (scsibus == NULL)
		return (NULL);

	/* Compute SCSI target/LUN from PROM unit. */
	target = (unit >> 3) & 7;
	lun = unit & 7;

	/* Find the device at this target/LUN */
	sbsc = (struct scsibus_softc *)scsibus;
	sc_link = sbsc->sc_link[target][lun];
	if (sc_link == NULL)
		return (NULL);

	return (sc_link->device_softc);
}

/*
 * Xylogics SMD disk: (xy, xd)
 * Assume wired-in unit numbers for now...
 */
struct device *
xx_find(name, ctlr, unit)
	char *name;
	int ctlr, unit;
{
	int diskunit;
	char tname[16];

	diskunit = (ctlr * 2) + unit;
	sprintf(tname, "%s%d", name, diskunit);
	return (find_dev_byname(tname));
}

/*
 * Given a device name, find its struct device
 * XXX - Move this to some common file?
 */
struct device *
find_dev_byname(name)
	char *name;
{
	struct device *dv;

	for (dv = alldevs.tqh_first; dv != NULL;
	    dv = dv->dv_list.tqe_next) {
		if (strcmp(dv->dv_xname, name) == 0) {
			return(dv);
		}
	}
	return (NULL);
}
@


1.22
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2002/03/14 01:26:47 millert Exp $	*/
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2002/01/16 20:50:17 miod Exp $	*/
d294 1
a294 1
	return ((char*)retval);
@


1.20
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2001/12/10 00:58:05 miod Exp $	*/
d76 6
a81 6
void setroot __P((void));
void swapconf __P((void));
int findblkmajor __P((struct device *));
struct device *getdisk __P((char *, int, int, dev_t *));
struct device *parsedisk __P((char *, int, int, dev_t *));
int getstr __P((char *, int));
d369 1
a369 1
typedef struct device *(*findfunc_t) __P((char *, int, int));
d371 4
a374 4
struct device *find_dev_byname __P((char *));
struct device *net_find __P((char *, int, int));
struct device *scsi_find __P((char *, int, int));
struct device *xx_find __P((char *, int, int));
@


1.19
log
@No need to include <sys/dmap.h> and define related variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2001/12/08 02:24:07 art Exp $	*/
a54 1
#include <sys/map.h>
@


1.19.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2002/01/16 20:50:17 miod Exp $	*/
d55 1
@


1.19.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19.2.1 2002/01/31 22:55:25 niklas Exp $	*/
d76 6
a81 6
void setroot(void);
void swapconf(void);
int findblkmajor(struct device *);
struct device *getdisk(char *, int, int, dev_t *);
struct device *parsedisk(char *, int, int, dev_t *);
int getstr(char *, int);
d294 1
a294 1
	return ((char *)retval);
d369 1
a369 1
typedef struct device *(*findfunc_t)(char *, int, int);
d371 4
a374 4
struct device *find_dev_byname(char *);
struct device *net_find(char *, int, int);
struct device *scsi_find(char *, int, int);
struct device *xx_find(char *, int, int);
@


1.19.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19.2.2 2002/06/11 03:39:01 art Exp $	*/
@


1.18
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2001/11/06 19:53:16 miod Exp $	*/
a54 1
#include <sys/dmap.h>
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2001/09/19 20:50:57 mickey Exp $	*/
d294 1
@


1.16
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/08/11 23:21:14 art Exp $	*/
a61 1
#include <vm/vm.h>
@


1.15
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/07/25 13:25:33 art Exp $	*/
a62 2
#include <vm/vm_kern.h>

@


1.14
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/06/27 04:44:02 art Exp $	*/
a63 1
#include <vm/vm_map.h>
@


1.13
log
@Zap old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/06/11 01:30:13 miod Exp $	*/
d293 1
a293 1
		pmap_enter(pmap_kernel(), va, pa | pmt, VM_PROT_ALL, FALSE, 0);
@


1.12
log
@Use MI {trunc,round}_page macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2001/05/30 20:37:54 miod Exp $	*/
a65 1
#ifdef UVM
a66 1
#endif
a281 1
#ifdef UVM
a282 3
#else
	va = kmem_alloc_wait(kernel_map, sz);
#endif
@


1.11
log
@Bring the root device selection code up-to-date with modern standards
(and other ports).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2001/05/05 22:34:24 art Exp $	*/
d278 1
a278 1
	sz = m68k_round_page(sz);
@


1.10
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2000/07/14 14:28:56 miod Exp $	*/
d50 2
d53 1
a53 2
#include <sys/map.h>
#include <sys/buf.h>
a54 1
#include <sys/conf.h>
d56 1
d59 3
d66 4
d72 1
d75 1
d79 11
a89 1
int cold;
a100 5
	/* Choose root and swap devices. */
	swapgeneric();
	swapconf();
	dumpconf();
	
d107 8
a118 26
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	u_int maj;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {

		maj = major(swp->sw_dev);
		if (maj > nblkdev) /* paranoid? */
			break;

		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks > 0 &&
				(swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
}

/*
d213 2
a214 1
int bus_peek(bustype, paddr, sz)
d284 3
d288 1
d342 481
@


1.9
log
@Enable interrupts after configuration phase.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 1999/11/09 14:30:39 art Exp $	*/
d43 1
a43 1
 * Configure() is called at boot time.  Available
d72 1
a72 1
configure()
d79 1
a79 1
		panic("configure: mainbus not found");
@


1.8
log
@Adapt to pmap_enter changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 1997/09/07 14:05:19 kstailey Exp $	*/
d85 7
@


1.8.2.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2000/07/14 14:28:56 miod Exp $	*/
a84 7
	
	/*
	 * Now that device autoconfiguration is finished,
	 * we can safely enable interrupts.
	 */
	printf("enabling interrupts\n");
	(void)spl0();
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8.2.1 2001/05/14 21:37:33 niklas Exp $	*/
d43 1
a43 1
 * cpu_configure() is called at boot time.  Available
d50 2
d53 1
a54 3
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/dkstat.h>
a55 1
#include <sys/map.h>
a57 3
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

a61 2
#include <uvm/uvm_extern.h>

a63 1
#include <machine/disklabel.h>
a65 1
#include <machine/mon.h>
d69 1
a69 11
#include <dev/cons.h>

/* Want compile-time initialization here. */
int cold = 1;

void setroot __P((void));
void swapconf __P((void));
int findblkmajor __P((struct device *));
struct device *getdisk __P((char *, int, int, dev_t *));
struct device *parsedisk __P((char *, int, int, dev_t *));
int getstr __P((char *, int));
d72 1
a72 1
cpu_configure()
d79 1
a79 1
		panic("cpu_configure: mainbus not found");
d81 5
d92 14
d107 12
a118 8
	/*
	 * Configure swap area and related system
	 * parameters based on device(s) used.
	 */
	setroot();
	swapconf();
	
	cold = 0;
d216 1
a216 2
int
bus_peek(bustype, paddr, sz)
d280 1
a280 1
	sz = round_page(sz);
d286 1
a286 1
	va = uvm_km_valloc_wait(kernel_map, sz);
a339 481
}

/****************************************************************/

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	dumpconf();
}

struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "xy",		3 },
	{ "sd",		7 },
	{ "xd",		10 },
	{ "st",		11 },
	{ "rd",		17 },
	{ "cd",		18 },
};

/* This takes the args: name, ctlr, unit */
typedef struct device *(*findfunc_t) __P((char *, int, int));

struct device *find_dev_byname __P((char *));
struct device *net_find __P((char *, int, int));
struct device *scsi_find __P((char *, int, int));
struct device *xx_find __P((char *, int, int));

struct prom_n2f {
	char name[4];
	findfunc_t func;
} prom_dev_table[] = {
	{ "ie",	net_find },
	{ "le",	net_find },
	{ "sd",	scsi_find },
	{ "xy",	xx_find },
	{ "xd",	xx_find },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	register int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-%c]", dv->dv_xname,
				    'a' + MAXPARTITIONS - 1);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot()
{
	MachMonBootParam *bp;
	struct prom_n2f *nf;
	char promname[3];
	findfunc_t find;
	struct swdevt *swp;
	struct device *bootdv;
	int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	/* PROM boot parameters. */
	bp = *romp->bootParam;

	/*
	 * Copy PROM boot device name (two letters)
	 * to a normal, null terminated string.
	 * (No terminating null in bp->devName)
	 */
	promname[0] = bp->devName[0];
	promname[1] = bp->devName[1];
	promname[2] = '\0';

	/* Default to "unknown" */
	bootdv = NULL;
	part = 0;
	find = NULL;

	/* Do we know anything about the PROM boot device? */
	for (nf = prom_dev_table; nf->func; nf++)
		if (strcmp(nf->name, promname) == 0) {
			find = nf->func;
			break;
		}
	if (find != NULL)
		bootdv = (*find)(promname, bp->ctlrNum, bp->unitNum);
	if (bootdv != NULL) {
		if (bootdv->dv_class == DV_DISK)
			part = bp->partNum;
	}

	/*
	 * If `swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? part + 'a' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				bootdv = getdisk(buf, len, 1, &nrootdev);
				if (bootdv != NULL) {
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			bootdv = getdisk(buf, len, part, &nrootdev);
			if (bootdv != NULL) {
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			bootdv = getdisk(buf, len, 1, &nswapdev);
			if (bootdv != NULL) {
				if (bootdv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else if (mountroot == NULL) {

		/*
		 * `swap generic': Use the device the PROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * part is the partition number.
			 * Assume swap is on partition b.
			 */
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
}

int
getstr(cp, size)
	register char *cp;
	register int size;
{
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}

/*
 * Functions to find devices using PROM boot parameters.
 */

/*
 * Network device:  Just use controller number.
 */
struct device *
net_find(name, ctlr, unit)
	char *name;
	int ctlr, unit;
{
	char tname[16];

	sprintf(tname, "%s%d", name, ctlr);
	return (find_dev_byname(tname));
}

/*
 * SCSI device:  The controller number corresponds to the
 * scsibus number, and the unit number is (targ*8 + LUN).
 */
struct device *
scsi_find(name, ctlr, unit)
	char *name;
	int ctlr, unit;
{
	struct device *scsibus;
	struct scsibus_softc *sbsc;
	struct scsi_link *sc_link;
	int target, lun;
	char tname[16];

	sprintf(tname, "scsibus%d", ctlr);
	scsibus = find_dev_byname(tname);
	if (scsibus == NULL)
		return (NULL);

	/* Compute SCSI target/LUN from PROM unit. */
	target = (unit >> 3) & 7;
	lun = unit & 7;

	/* Find the device at this target/LUN */
	sbsc = (struct scsibus_softc *)scsibus;
	sc_link = sbsc->sc_link[target][lun];
	if (sc_link == NULL)
		return (NULL);

	return (sc_link->device_softc);
}

/*
 * Xylogics SMD disk: (xy, xd)
 * Assume wired-in unit numbers for now...
 */
struct device *
xx_find(name, ctlr, unit)
	char *name;
	int ctlr, unit;
{
	int diskunit;
	char tname[16];

	diskunit = (ctlr * 2) + unit;
	sprintf(tname, "%s%d", name, diskunit);
	return (find_dev_byname(tname));
}

/*
 * Given a device name, find its struct device
 * XXX - Move this to some common file?
 */
struct device *
find_dev_byname(name)
	char *name;
{
	struct device *dv;

	for (dv = alldevs.tqh_first; dv != NULL;
	    dv = dv->dv_list.tqe_next) {
		if (strcmp(dv->dv_xname, name) == 0) {
			return(dv);
		}
	}
	return (NULL);
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8.2.2 2001/07/04 10:24:06 niklas Exp $	*/
d63 3
d293 1
a293 1
		pmap_enter(pmap_kernel(), va, pa | pmt, VM_PROT_ALL, 0);
@


1.8.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
@


1.8.2.5
log
@Merge in trunk
@
text
@d55 2
a293 1
	pmap_update(pmap_kernel());
@


1.8.2.6
log
@Merge in -current from about a week ago
@
text
@d76 6
a81 6
void setroot(void);
void swapconf(void);
int findblkmajor(struct device *);
struct device *getdisk(char *, int, int, dev_t *);
struct device *parsedisk(char *, int, int, dev_t *);
int getstr(char *, int);
d294 1
a294 1
	return ((char *)retval);
d369 1
a369 1
typedef struct device *(*findfunc_t)(char *, int, int);
d371 4
a374 4
struct device *find_dev_byname(char *);
struct device *net_find(char *, int, int);
struct device *scsi_find(char *, int, int);
struct device *xx_find(char *, int, int);
@


1.8.2.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8.2.6 2002/03/28 11:26:45 niklas Exp $	*/
@


1.7
log
@switch from private Mach derived conversion macros to m68k ones
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 1997/01/16 04:04:11 kstailey Exp $	*/
d290 1
a290 1
		pmap_enter(pmap_kernel(), va, pa | pmt, VM_PROT_ALL, FALSE);
@


1.6
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d273 1
a273 1
	sz = sun3_round_page(sz);
@


1.5
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
d63 1
d65 1
a65 1
#include <machine/isr.h>
a68 5
extern int soft1intr();

void swapgeneric();
void swapconf(), dumpconf();

d71 2
a72 1
void configure()
d97 1
a97 1
	
d103 1
a103 1
		
d131 2
a132 1
int bus_scan(parent, child, aux)
d153 1
a153 2
		(ca->ca_bustype == BUS_VME32))
	{
d264 1
a264 1
	int off, pa, pgs, pmt;
d297 37
a333 1
}	
@


1.4
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.38 1996/12/17 21:11:14 gwr Exp $	*/
a48 1
#include <sys/conf.h>
d51 1
d53 1
d63 1
a63 1
#include <machine/control.h>
d67 4
a70 1
#include "machdep.h"
d99 1
a99 1

d105 1
a105 1

d142 2
d266 1
a266 1
	int off, pa, pmt;
d299 1
a299 36
}

int
peek_word(addr)
	register caddr_t addr;
{
	label_t		faultbuf;
	register int x;

	nofault = &faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = NULL;
		return(-1);
	}
	x = *(volatile u_short *)addr;
	nofault = NULL;
	return(x);
}

/* from hp300: badbaddr() */
int
peek_byte(addr)
	register caddr_t addr;
{
	label_t 	faultbuf;
	register int x;

	nofault = &faultbuf;
	if (setjmp(&faultbuf)) {
		nofault = NULL;
		return(-1);
	}
	x = *(volatile u_char *)addr;
	nofault = NULL;
	return(x);
}
@


1.3
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.37 1996/11/20 18:57:22 gwr Exp $	*/
d49 1
a51 1
#include <sys/buf.h>
a52 1
#include <sys/conf.h>
d62 1
a62 1
#include <machine/isr.h>
d66 1
a66 4
extern int soft1intr();

void swapgeneric();
void swapconf(), dumpconf();
d95 1
a95 1
	
d101 1
a101 1
		
a137 2
	if (parent->dv_cfdata->cf_driver->cd_indirect)
		panic("bus_scan: indirect?");
d260 1
a260 1
	int off, pa, pgs, pmt;
d293 36
a328 1
}	
@


1.2
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.33 1996/04/07 05:45:08 gwr Exp $	*/
d3 2
a4 3
/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
d7 3
d20 17
a36 14
 *	This product includes software developed by Adam Glass.
 * 4. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d178 1
a178 1
	char *name;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.27 1995/09/26 04:02:14 gwr Exp $	*/
a63 1
void mainbusattach __P((struct device *, struct device *, void *));
a68 23
struct mainbus_softc {
	struct device mainbus_dev;
};
	
struct cfdriver mainbuscd = 
{ NULL, "mainbus", always_match, mainbusattach, DV_DULL,
	sizeof(struct mainbus_softc), 0};

void mainbusattach(parent, self, args)
	struct device *parent;
	struct device *self;
	void *args;
{
	struct cfdata *new_match;
	
	printf("\n");
	while (1) {
		new_match = config_search(NULL, self, NULL);
		if (!new_match) break;
		config_attach(self, new_match, NULL, NULL);
	}
}

d71 1
a71 4
	int root_found;

	/* Install non-device interrupt handlers. */
	isr_config();
d74 2
a75 2
	root_found = config_rootfound("mainbus", NULL);
	if (!root_found)
a77 1
#ifdef	GENERIC
a79 1
#endif
a110 8
int always_match(parent, cf, args)
	struct device *parent;
	void *cf;
	void *args;
{
	return 1;
}

d113 14
d128 1
a128 1
void bus_scan(parent, child, bustype)
d130 1
a130 2
	void *child;
	int bustype;
d133 2
a134 2
	struct confargs ca;
	cfmatch_t match;
d143 9
a151 8
	ca.ca_bustype = bustype;
	ca.ca_paddr  = cf->cf_loc[0];
	ca.ca_intpri = cf->cf_loc[1];

	if ((bustype == BUS_VME16) || (bustype == BUS_VME32)) {
		ca.ca_intvec = cf->cf_loc[2];
	} else {
		ca.ca_intvec = -1;
d154 8
a161 3
	match = cf->cf_driver->cd_match;
	if ((*match)(parent, cf, &ca) > 0) {
		config_attach(parent, cf, &ca, bus_print);
d163 1
d166 4
d177 3
d186 2
a187 2
	/* XXXX print flags? */
	return(QUIET);
d262 1
a262 1
	vm_offset_t va;
d279 1
d282 2
d285 7
d293 1
a293 1
	return ((char*)(va + off));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
