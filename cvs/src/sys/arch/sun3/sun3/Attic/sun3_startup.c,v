head	1.23;
access;
symbols
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	UBC_SYNC_A:1.23
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.10.0.12
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.10
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.8
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2002.12.31.16.35.42;	author miod;	state dead;
branches;
next	1.22;

1.22
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.09.14.09.09.45;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.20.19.59.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.25.00.43.18;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.11.01.30.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.30.20.35.43;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.29.02.25.30;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.06.20.54.12;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.30.15.30.29;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.02.23.02.14;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	97.09.07.14.05.21;	author kstailey;	state Exp;
branches
	1.10.12.1;
next	1.9;

1.9
date	97.01.16.08.08.41;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.01.16.04.04.33;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.07.23.36.34;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.12.31.06.14.02;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.08.26.11;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.11.23.07.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.16.04.55;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.15.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.02;	author deraadt;	state Exp;
branches;
next	;

1.10.12.1
date	2000.03.24.09.08.56;	author niklas;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2001.05.14.21.37.36;	author niklas;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2001.07.04.10.24.16;	author niklas;	state Exp;
branches;
next	1.10.12.4;

1.10.12.4
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.10.12.5;

1.10.12.5
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.10.12.6;

1.10.12.6
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.10.12.7;

1.10.12.7
date	2003.03.27.23.52.19;	author niklas;	state dead;
branches;
next	;

1.20.2.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.23
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: sun3_startup.c,v 1.22 2002/03/14 03:16:01 millert Exp $	*/
/*	$NetBSD: sun3_startup.c,v 1.55 1996/11/20 18:57:38 gwr Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass and Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/user.h>
#include <sys/exec_aout.h>
#include <sys/msgbuf.h>

#include <uvm/uvm_extern.h>

#include <machine/control.h>
#include <machine/cpu.h>
#include <machine/dvma.h>
#include <machine/idprom.h>
#include <machine/machdep.h>
#include <machine/mon.h>
#include <machine/obio.h>
#include <machine/obmem.h>
#include <machine/pmap.h>
#include <machine/pte.h>

#include "vector.h"
#include "interreg.h"

#include "ksyms.h"

/* This is defined in locore.s */
extern char kernel_text[];

/* These are defined by the linker */
extern char etext[], edata[], end[];
#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
char *esym;
#endif

/*
 * Globals shared with the pmap code.
 * XXX - should reexamine this...
 */
vm_offset_t virtual_avail, virtual_end;
vm_offset_t avail_start, avail_end;
/* used to skip the Sun3/50 video RAM */
vm_offset_t hole_start, hole_size;
int cache_size;

/*
 * Now our own stuff.
 */
void **old_vector_table;

unsigned char cpu_machine_id = 0;
char *cpu_string = NULL;
int cpu_has_vme = 0;

vm_offset_t high_segment_free_start = 0;
vm_offset_t high_segment_free_end = 0;

struct msgbuf *msgbufp = NULL;
extern vm_offset_t tmp_vpages[];
extern int physmem;
unsigned char *interrupt_reg;

vm_offset_t proc0_user_pa;
struct user *proc0paddr;	/* proc[0] pcb address (u-area VA) */
extern struct pcb *curpcb;

extern vm_offset_t dumppage_pa;
extern vm_offset_t dumppage_va;

void sun3_bootstrap(struct exec);

static void sun3_mode_monitor(void);
static void sun3_mode_normal(void);
static void sun3_mon_init(vm_offset_t sva, vm_offset_t eva, int keep);
static void sun3_monitor_hooks(void);
static void sun3_context_equiv(void);
#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
static void sun3_save_symtab(struct exec *kehp);
#endif
static void sun3_verify_hardware(void);
static void sun3_vm_init(struct exec *kehp);
static void tracedump(int);
static void v_handler(int addr, char *str);

static void internal_configure(void);

vm_offset_t
high_segment_alloc(npages)
	int npages;
{
	vm_offset_t va, tmp;

	if (npages == 0)
		mon_panic("panic: request for high segment allocation of 0 pages");
	if (high_segment_free_start == high_segment_free_end) return NULL;

	va = high_segment_free_start + (npages*NBPG);
	if (va > high_segment_free_end) return NULL;
	tmp = high_segment_free_start;
	high_segment_free_start = va;
	return tmp;
}

/*
 * Prepare for running the PROM monitor
 */
static void
sun3_mode_monitor()
{
	/* Install PROM vector table and enable NMI clock. */
	/* XXX - Disable watchdog action? */
	set_clk_mode(0, IREG_CLOCK_ENAB_5, 0);
	setvbr(old_vector_table);
	set_clk_mode(IREG_CLOCK_ENAB_7, 0, 1);
}

/*
 * Prepare for running the kernel
 */
static void
sun3_mode_normal()
{
	/* Install our vector table and disable the NMI clock. */
	set_clk_mode(0, IREG_CLOCK_ENAB_7, 0);
	setvbr((void **) vector_table);
	set_clk_mode(IREG_CLOCK_ENAB_5, 0, 1);
}

/*
 * This function takes care of restoring enough of the
 * hardware state to allow the PROM to run normally.
 * The PROM needs: NMI enabled, it's own vector table.
 * In case of a temporary "drop into PROM", this will
 * also put our hardware state back into place after
 * the PROM "c" (continue) command is given.
 */
void
sun3_mon_abort()
{
	int s = splhigh();

	sun3_mode_monitor();
	mon_printf("kernel stop: enter c to continue or g0 to panic\n");
	delay(100000);

	/*
	 * Drop into the PROM in a way that allows a continue.
	 * That's what the PROM function (romp->abortEntry) is for,
	 * but that wants to be entered as a trap hander, so just
	 * stuff it into the PROM interrupt vector for trap zero
	 * and then do a trap.  Needs PROM vector table in RAM.
	 */
	old_vector_table[32] = (void *)romp->abortEntry;
	asm(" trap #0 ; _sun3_mon_continued: nop");

	/* We have continued from a PROM abort! */

	sun3_mode_normal();
	splx(s);
}

void
sun3_mon_halt()
{
	(void) splhigh();
	sun3_mode_monitor();
	mon_exit_to_mon();
	/*NOTREACHED*/
}

__dead void
sun3_mon_reboot(bootstring)
	char *bootstring;
{
	(void) splhigh();
	sun3_mode_monitor();
	mon_reboot(bootstring);
	mon_exit_to_mon();
	for (;;);	/* appease gcc */
	/*NOTREACHED*/
}

/*
 * Duplicate all mappings in the current context into
 * every other context.  We have to let the PROM do the
 * actual segmap manipulation because we can only switch
 * the MMU context after we are sure that the kernel text
 * is identically mapped in all contexts.  The PROM can
 * do the job using hardware-dependent tricks...
 */
static void
sun3_context_equiv()
{
	unsigned int sme;
	int x;
	vm_offset_t va;

#ifdef	DIAGNOSTIC
	/* Near the beginning of locore.s we set context zero. */
	if (get_context() != 0)
		mon_panic("sun3_context_equiv: not in context zero?\n");
	/* Note: PROM setcxsegmap function needs sfc=dfs=FC_CONTROL */
	if (getsfc() != FC_CONTROL)
		mon_panic("sun3_context_equiv: sfc != FC_CONTROL?\n");
	if (getdfc() != FC_CONTROL)
		mon_panic("sun3_context_equiv: dfc != FC_CONTROL?\n");
#endif

	for (x = 1; x < NCONTEXT; x++) {
		for (va = 0; va < (vm_offset_t) (NBSG * NSEGMAP); va += NBSG) {
			sme = get_segmap(va);
			mon_setcxsegmap(x, va, sme);
		}
	}
}

static void
sun3_mon_init(sva, eva, keep)
vm_offset_t sva, eva;
int keep;	/* true: steal, false: clear */
{
	vm_offset_t pgva, endseg;
	int pte, valid;
	unsigned char sme;

	sva &= ~(NBSG-1);

	while (sva < eva) {
		sme = get_segmap(sva);
		if (sme != SEGINV) {
#ifdef	DEBUG
			mon_printf("mon va=0x%x seg=0x%x\n", sva, sme);
#endif
			valid = 0;
			endseg = sva + NBSG;
			for (pgva = sva; pgva < endseg; pgva += NBPG) {
				pte = get_pte(pgva);
				if (pte & PG_VALID) {
					valid++;
#ifdef	DEBUG
					mon_printf("mon va=0x%x pte=0x%x\n", pgva, pte);
#endif
				}
			}
			if (keep && valid)
				sun3_reserve_pmeg(sme);
			else set_segmap(sva, SEGINV);
		}
		sva += NBSG;
	}
}

#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
/*
 * Preserve DDB symbols and strings by setting esym.
 */
void
sun3_save_symtab(kehp)
	struct exec *kehp;	/* kernel exec header */
{
	int x, *symsz, *strsz;
	char *endp;
	char *errdesc = "?";

	/*
	 * First, sanity-check the exec header.
	 */
	mon_printf("sun3_save_symtab: ");
	if ((kehp->a_midmag & 0xFFF0) != 0x100) {
		errdesc = "magic";
		goto err;
	}
	/* Boundary between text and data varries a little. */
	x = kehp->a_text + kehp->a_data;
	if (x != (edata - kernel_text)) {
		errdesc = "a_text+a_data";
		goto err;
	}
	if (kehp->a_bss != (end - edata)) {
		errdesc = "a_bss";
		goto err;
	}
	if (kehp->a_entry != (int)kernel_text) {
		errdesc = "a_entry";
		goto err;
	}
	if (kehp->a_trsize || kehp->a_drsize) {
		errdesc = "a_Xrsize";
		goto err;
	}
	/* The exec header looks OK... */

	/* Check the symtab length word. */
	endp = end;
	symsz = (int *)endp;
	if (kehp->a_syms != *symsz) {
		errdesc = "a_syms";
		goto err;
	}
	endp += sizeof(int);	/* past length word */
	endp += *symsz;			/* past nlist array */

	/* Check the string table length. */
	strsz = (int *)endp;
	if ((*strsz < 4) || (*strsz > 0x80000)) {
		errdesc = "strsize";
		goto err;
	}

	/* Success!  We have a valid symbol table! */
	endp += *strsz;			/* past strings */
	esym = endp;
	mon_printf(" found %d + %d\n", *symsz, *strsz);
	return;

 err:
	mon_printf(" no symbols (bad %s)\n", errdesc);
}
#endif	/* DDB && !SYMTAB_SPACE */

/*
 * This is called just before pmap_bootstrap()
 * (from sun3_bootstrap(), below) to initialize enough
 * to allow the VM system to run normally.  This involves
 * allocating some physical pages and virtual space for
 * special purposes, etc. by advancing avail_start and
 * virtual_avail past the "stolen" pages.  Note that
 * the kernel should never take a fault on any page
 * between [ KERNBASE .. virtual_avail ] and this is
 * checked in trap.c for kernel-mode MMU faults.
 */
void
sun3_vm_init(kehp)
	struct exec *kehp;	/* kernel exec header */
{
	vm_offset_t va, eva, pte;
	unsigned int sme;

	/*
	 * Determine the range of kernel virtual space available.
	 * This is just page-aligned for now, so we can allocate
	 * some special-purpose pages before rounding to a segment.
	 */
#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
	esym = end;
	/* This will advance esym past the symbols. */
	sun3_save_symtab(kehp);
	virtual_avail = round_page((vaddr_t)esym);
#else
	virtual_avail = round_page(end);
#endif
	virtual_end = VM_MAX_KERNEL_ADDRESS;

	/*
	 * Determine the range of physical memory available.
	 * Physical memory at zero was remapped to KERNBASE.
	 */
	avail_start = virtual_avail - KERNBASE;
	if (romp->romvecVersion < 1) {
		mon_printf("WARNING: ancient PROM version=%d\n",
				   romp->romvecVersion);
		/* Guess that PROM version 0.X used two pages. */
		avail_end = *romp->memorySize - (2*NBPG);
	} else {
		/* PROM version 1 or later. */
		avail_end = *romp->memoryAvail;
	}
	avail_end = trunc_page(avail_end);

	/*
	 * Steal some special-purpose, already mapped pages.
	 * First take pages that are already mapped as
	 * VA -> PA+KERNBASE since that's convenient.
	 */

	/*
	 * Message buffer page (msgbuf).
	 * This is put in physical page zero so it
	 * is always in the same place after reboot.
	 */
	va = KERNBASE;
	/* Make it non-cached. */
	pte = get_pte(va);
	pte |= PG_NC;
	set_pte(va, pte);
	/* offset by half a page to avoid PROM scribbles */
	msgbufp = (struct msgbuf *)(va + MSGBUFOFF);
	initmsgbuf((caddr_t)msgbufp, MSGBUFSIZE);

	/*
	 * Virtual and physical pages for proc[0] u-area (already mapped)
	 */
	proc0paddr = (struct user *) virtual_avail;
	proc0_user_pa = avail_start;
	virtual_avail += UPAGES*NBPG;
	avail_start   += UPAGES*NBPG;

	/*
	 * Virtual and physical page used by dumpsys()
	 */
	dumppage_va = virtual_avail;
	dumppage_pa = avail_start;
	virtual_avail += NBPG;
	avail_start   += NBPG;

	/*
	 * XXX - Make sure avail_start is within the low 1M range
	 * that the Sun PROM guarantees will be mapped in?
	 * Make sure it is below avail_end as well?
	 */

	/*
	 * Now steal some virtual addresses, but
	 * not the physical pages behind them.
	 */
	va = virtual_avail;	/* will clear PTEs from here */

	/*
	 * vpages array:  just some virtual addresses for
	 * temporary mappings in the pmap module (two pages)
	 */
	tmp_vpages[0] = virtual_avail;
	virtual_avail += NBPG;
	tmp_vpages[1] = virtual_avail;
	virtual_avail += NBPG;

	/*
	 * Done allocating PAGES of virtual space, so
	 * clean out the rest of the last used segment.
	 * After this point, virtual_avail is seg-aligned.
	 */
	virtual_avail = m68k_round_seg(virtual_avail);
	while (va < virtual_avail) {
		set_pte(va, PG_INVAL);
		va += NBPG;
	}

	/*
	 * Now that we are done stealing physical pages, etc.
	 * figure out which PMEGs are used by those mappings
	 * and reserve them -- but first, init PMEG management.
	 */
	sun3_pmeg_init();

	/*
	 * Reserve PMEGS for kernel text/data/bss
	 * and the misc pages taken above.
	 */
	va = VM_MIN_KERNEL_ADDRESS;
	while (va < virtual_avail) {
		sme = get_segmap(va);
		if (sme == SEGINV)
			mon_panic("kernel text/data/bss not mapped\n");
		sun3_reserve_pmeg(sme);
		va += NBSG;
	}

	/*
	 * Unmap kernel virtual space (only segments.  if it squished ptes,
	 * bad things might happen).  Also, make sure to leave no valid
	 * segmap entries in the MMU unless pmeg_array records them.
	 */
	va = virtual_avail;
	while (va < virtual_end) {
		set_segmap(va, SEGINV);
		va += NBSG;
	}

	/*
	 * Clear-out pmegs left in DVMA space by the PROM.
	 * DO NOT kill the last one! (owned by the PROM!)
	 */
	va  = m68k_trunc_seg(DVMA_SPACE_START);
	eva = m68k_trunc_seg(DVMA_SPACE_END);  /* Yes trunc! */
	while (va < eva) {
		set_segmap(va, SEGINV);
		va += NBSG;
	}

	/*
	 * Reserve PMEGs used by the PROM monitor:
	 *   need to preserve/protect mappings between
	 *		MONSTART, MONEND.
	 *   free up any pmegs in this range which have no mappings
	 *   deal with the awful MONSHORTSEG/MONSHORTPAGE
	 */
	sun3_mon_init(MONSTART, MONEND, TRUE);

	/*
	 * Make sure the hole between MONEND, MONSHORTSEG is clear.
	 */
	sun3_mon_init(MONEND, MONSHORTSEG, FALSE);

	/*
	 * MONSHORTSEG contains MONSHORTPAGE which is some stupid page
	 * allocated by the PROM monitor.  (PROM data)
	 * We use some of the segment for our u-area mapping.
	 */
	sme = get_segmap(MONSHORTSEG);
	sun3_reserve_pmeg(sme);
	high_segment_free_start = MONSHORTSEG;
	high_segment_free_end = MONSHORTPAGE;

	for (va = high_segment_free_start;
		 va < high_segment_free_end;
		 va += NBPG)
		set_pte(va, PG_INVAL);

	/*
	 * Initialize the "u-area" pages.
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 */
	bzero((caddr_t)proc0paddr, USPACE);
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;

	/*
	 * XXX  It might be possible to move much of what is
	 * XXX  done after this point into pmap_bootstrap...
	 */

	/*
	 * unmap user virtual segments
	 */
	va = 0;
	while (va < KERNBASE) {	/* starts and ends on segment boundries */
		set_segmap(va, SEGINV);
		va += NBSG;
	}

	/*
	 * Verify protection bits on kernel text/data/bss
	 * All of kernel text, data, and bss are cached.
	 * Text is read-only (except in db_write_ktext).
	 *
	 * Note that the Sun PROM initialized the memory
	 * mapping with everything non-cached...
	 */

	/* text */
	va = (vm_offset_t) kernel_text;
	eva = trunc_page((vaddr_t)etext);
	while (va < eva) {
		pte = get_pte(va);
		if ((pte & (PG_VALID|PG_TYPE)) != PG_VALID) {
			mon_printf("invalid page at 0x%x\n", va);
		}
		pte &= ~(PG_WRITE|PG_NC);
		/* Kernel text is read-only */
		pte |= (PG_SYSTEM);
		set_pte(va, pte);
		va += NBPG;
	}

	/* data and bss */
	eva = round_page((vaddr_t)end);
	while (va < eva) {
		pte = get_pte(va);
		if ((pte & (PG_VALID|PG_TYPE)) != PG_VALID) {
			mon_printf("invalid page at 0x%x\n", va);
		}
		pte &= ~(PG_NC);
		pte |= (PG_SYSTEM | PG_WRITE);
		set_pte(va, pte);
		va += NBPG;
	}

	/* Finally, duplicate the mappings into all contexts. */
	sun3_context_equiv();
}


/*
 * XXX - Should empirically estimate the divisor...
 * Note that the value of delay_divisor is roughly
 * 2048 / cpuclock	(where cpuclock is in MHz).
 */
int delay_divisor = 82;		/* assume the fastest (3/260) */

void
sun3_verify_hardware()
{
	unsigned char machtype;
	int cpu_match = 0;

	if (idprom_init())
		mon_panic("idprom_init failed\n");

	machtype = identity_prom.idp_machtype;
	if ((machtype & CPU_ARCH_MASK) != SUN3_ARCH)
		mon_panic("not a sun3?\n");

	cpu_machine_id = machtype & SUN3_IMPL_MASK;
	switch (cpu_machine_id) {

	case SUN3_MACH_50 :
		cpu_match++;
		hole_start = OBMEM_BW50_ADDR;
		hole_size  = OBMEM_BW2_SIZE;
		cpu_string = "50";
		delay_divisor = 128;	/* 16 MHz */
		break;

	case SUN3_MACH_60 :
		cpu_match++;
		cpu_string = "60";
		delay_divisor = 102;	/* 20 MHz */
		break;

	case SUN3_MACH_110:
		cpu_match++;
		cpu_string = "110";
		delay_divisor = 120;	/* 17 MHz */
		cpu_has_vme = TRUE;
		break;

	case SUN3_MACH_160:
		cpu_match++;
		cpu_string = "160";
		delay_divisor = 120;	/* 17 MHz */
		cpu_has_vme = TRUE;
		break;

	case SUN3_MACH_260:
		cpu_match++;
		cpu_string = "260";
		delay_divisor = 82; 	/* 25 MHz */
		cpu_has_vme = TRUE;
#ifdef	HAVECACHE
		cache_size = 0x10000;	/* 64K */
#endif
		break;

	case SUN3_MACH_E  :
		cpu_match++;
		cpu_string = "E";
		delay_divisor = 102;	/* 20 MHz  XXX: Correct? */
		cpu_has_vme = TRUE;
		break;

	default:
		mon_panic("unknown sun3 model\n");
	}
	if (!cpu_match)
		mon_panic("kernel not configured for the Sun 3 model\n");
}

/*
 * Print out a traceback for the caller - can be called anywhere
 * within the kernel or from the monitor by typing "g4" (for sun-2
 * compatibility) or "w trace".  This causes the monitor to call
 * the v_handler() routine which will call tracedump() for these cases.
 */
struct funcall_frame {
	struct funcall_frame *fr_savfp;
	int fr_savpc;
	int fr_arg[1];
};
/*VARARGS0*/
void
tracedump(x1)
	int x1;
{
	struct funcall_frame *fp = (struct funcall_frame *)(&x1 - 2);
	u_int stackpage = ((u_int)fp) & ~PGOFSET;

	mon_printf("Begin traceback...fp = %x\n", fp);
	do {
		if (fp == fp->fr_savfp) {
			mon_printf("FP loop at %x", fp);
			break;
		}
		mon_printf("Called from %x, fp=%x, args=%x %x %x %x\n",
				   fp->fr_savpc, fp->fr_savfp,
				   fp->fr_arg[0], fp->fr_arg[1], fp->fr_arg[2], fp->fr_arg[3]);
		fp = fp->fr_savfp;
	} while ( (((u_int)fp) & ~PGOFSET) == stackpage);
	mon_printf("End traceback...\n");
}

/*
 * Handler for monitor vector cmd -
 * For now we just implement the old "g0" and "g4"
 * commands and a printf hack.  [lifted from freed cmu mach3 sun3 port]
 */
void
v_handler(addr, str)
	int addr;
	char *str;
{

	switch (*str) {
	case '\0':
		/*
		 * No (non-hex) letter was specified on
		 * command line, use only the number given
		 */
		switch (addr) {
		case 0:			/* old g0 */
		case 0xd:		/* 'd'ump short hand */
			sun3_mode_normal();
			panic("zero");
			/*NOTREACHED*/

		case 4:			/* old g4 */
			goto do_trace;
			break;

		default:
			goto err;
		}
		break;

	case 'p':			/* 'p'rint string command */
	case 'P':
		mon_printf("%s\n", (char *)addr);
		break;

	case '%':			/* p'%'int anything a la printf */
		mon_printf(str, addr);
		mon_printf("\n");
		break;

	do_trace:
	case 't':			/* 't'race kernel stack */
	case 'T':
		tracedump(addr);
		break;

	case 'u':			/* d'u'mp hack ('d' look like hex) */
	case 'U':
		goto err;
		break;

	default:
	err:
		mon_printf("Don't understand 0x%x '%s'\n", addr, str);
	}
}

/*
 * Set the PROM vector handler (for g0, g4, etc.)
 * and set boothowto from the PROM arg strings.
 *
 * Note, args are always:
 * argv[0] = boot_device	(i.e. "sd(0,0,0)")
 * argv[1] = options	(i.e. "-ds" or NULL)
 * argv[2] = NULL
 */
void
sun3_monitor_hooks()
{
	MachMonBootParam *bpp;
	char **argp;
	char *p;

	if (romp->romvecVersion >= 2)
		*romp->vector_cmd = v_handler;

	/* Set boothowto flags from PROM args. */
	bpp = *romp->bootParam;
	argp = bpp->argPtr;

	/* Skip argp[0] (the device string) */
	argp++;

	/* Have options? */
	if (*argp == NULL)
		return;
	p = *argp;
	if (*p == '-') {
		/* yes, parse options */
#ifdef	DEBUG
		mon_printf("boot option: %s\n", p);
#endif
		for (++p; *p; p++) {
			switch (*p) {
			case 'a':
				boothowto |= RB_ASKNAME;
				break;
			case 'b':
				boothowto |= RB_HALT;
				break;
			case 'c':
				boothowto |= RB_CONFIG;
				break;
			case 's':
				boothowto |= RB_SINGLE;
				break;
			case 'd':
				boothowto |= RB_KDB;
				break;
			}
		}
		argp++;
	}

#ifdef	DEBUG
	/* Have init name? */
	if (*argp == NULL)
		return;
	p = *argp;
	mon_printf("boot initpath: %s\n", p);
#endif
}

/*
 * Find mappings for devices that are needed before autoconfiguration.
 * First the obio module finds and records useful PROM mappings, then
 * the necessary drivers are given a chance to use those recorded.
 */
static void
internal_configure()
{
	obio_init();	/* find and record PROM mappings in OBIO space */
	/* Drivers that use those OBIO mappings from the PROM */
	zs_init();
	eeprom_init();
	intreg_init();
	clock_init();
}

/*
 * This is called from locore.s just after the kernel is remapped
 * to its proper address, but before the call to main().
 */
void
sun3_bootstrap(keh)
	struct exec keh;	/* kernel exec header */
{
	/* First, Clear BSS. */
	bzero(edata, end - edata);

	cold = 1;

	sun3_monitor_hooks();	/* set v_handler, get boothowto */

	sun3_verify_hardware();	/* get CPU type, etc. */

	sun3_vm_init(&keh);		/* handle kernel mapping, etc. */

	pmap_bootstrap();		/* bootstrap pmap module */

	internal_configure();	/* stuff that can't wait for configure() */

	/*
	 * Point interrupts/exceptions to our table.
	 * This is done after internal_configure/isr_init finds
	 * the interrupt register and disables the NMI clock so
	 * it will not cause "spurrious level 7" complaints.
	 */
	old_vector_table = getvbr();
	setvbr((void **) vector_table);

	/* Interrupts are enabled in locore.s just after this return. */
}
@


1.22
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.21 2002/03/14 01:26:47 millert Exp $	*/
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.20 2001/11/06 19:53:16 miod Exp $	*/
d334 1
a334 1
	symsz = (int*)endp;
d343 1
a343 1
	strsz = (int*)endp;
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.19 2001/09/14 09:09:45 art Exp $	*/
d109 1
a109 1
void sun3_bootstrap __P((struct exec));
d111 5
a115 5
static void sun3_mode_monitor __P((void));
static void sun3_mode_normal __P((void));
static void sun3_mon_init __P((vm_offset_t sva, vm_offset_t eva, int keep));
static void sun3_monitor_hooks __P((void));
static void sun3_context_equiv __P((void));
d117 1
a117 1
static void sun3_save_symtab __P((struct exec *kehp));
d119 4
a122 4
static void sun3_verify_hardware __P((void));
static void sun3_vm_init __P((struct exec *kehp));
static void tracedump __P((int));
static void v_handler __P((int addr, char *str));
d124 1
a124 1
static void internal_configure __P((void));
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.20 2001/11/06 19:53:16 miod Exp $	*/
d109 1
a109 1
void sun3_bootstrap(struct exec);
d111 5
a115 5
static void sun3_mode_monitor(void);
static void sun3_mode_normal(void);
static void sun3_mon_init(vm_offset_t sva, vm_offset_t eva, int keep);
static void sun3_monitor_hooks(void);
static void sun3_context_equiv(void);
d117 1
a117 1
static void sun3_save_symtab(struct exec *kehp);
d119 4
a122 4
static void sun3_verify_hardware(void);
static void sun3_vm_init(struct exec *kehp);
static void tracedump(int);
static void v_handler(int addr, char *str);
d124 1
a124 1
static void internal_configure(void);
d334 1
a334 1
	symsz = (int *)endp;
d343 1
a343 1
	strsz = (int *)endp;
@


1.20.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.20.2.1 2002/06/11 03:39:01 art Exp $	*/
@


1.19
log
@Fix fallout from round_page fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.18 2001/08/20 19:59:45 miod Exp $	*/
d48 1
a48 1
#include <vm/vm.h>
@


1.18
log
@silence gcc for __dead function.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.17 2001/06/25 00:43:18 mickey Exp $	*/
d387 1
a387 1
	virtual_avail = round_page(esym);
d583 1
a583 1
	eva = trunc_page(etext);
d597 1
a597 1
	eva = round_page(end);
@


1.17
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.16 2001/06/11 01:30:13 miod Exp $	*/
d218 1
@


1.16
log
@Use MI {trunc,round}_page macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.15 2001/05/30 20:35:43 miod Exp $	*/
a870 2
	extern int cold;

@


1.15
log
@Define msgbuf area size better, gets rid of occasionnal noise in dmesg
ouptput.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.14 2000/06/29 02:25:30 miod Exp $	*/
d386 1
a386 1
	virtual_avail = m68k_round_page(esym);
d388 1
a388 1
	virtual_avail = m68k_round_page(end);
d406 1
a406 1
	avail_end = m68k_trunc_page(avail_end);
d582 1
a582 1
	eva = m68k_trunc_page(etext);
d596 1
a596 1
	eva = m68k_round_page(end);
@


1.14
log
@Enable UKC
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.13 2000/06/06 20:54:12 miod Exp $	*/
d146 2
a147 1
static void sun3_mode_monitor()
d210 1
a210 1
void
d425 2
a426 2
	msgbufp = (struct msgbuf *)(va + (NBPG >> 1));
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
a434 13
#if 0
	/* Make them non-cached.
	 * XXX - Make these non-cached at their full-time mapping address.
	 * XXX - Still need to do that? -gwr
	 */
	va = (vm_offset_t) proc0paddr;
	while (va < virtual_avail) {
		pte = get_pte(va);
		pte |= PG_NC;
		set_pte(va, pte);
		va += NBPG;
	}
#endif
d728 2
a729 2
int addr;
char *str;
@


1.13
log
@include ksyms.h to have correct NKSYMS value (oops)
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.12 2000/04/30 15:30:29 miod Exp $	*/
d832 6
@


1.12
log
@Fix kernel msgbuf size and position
Ensure ksyms work properly when DDB isn't defined
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.11 2000/03/02 23:02:14 todd Exp $	*/
d64 2
d116 1
d118 1
@


1.11
log
@sun3 is alive, thanks to Miod Vallat <miodrag@@ifrance.com>
add ksyms, proto fix, msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.10 1997/09/07 14:05:21 kstailey Exp $	*/
d69 3
a71 1
char *esym;	/* DDB */
d286 1
a286 1
#if defined(DDB) && !defined(SYMTAB_SPACE)
d377 1
a378 1
#if defined(DDB) && !defined(SYMTAB_SPACE)
d381 3
a384 1
	virtual_avail = m68k_round_page(esym);
d420 1
a420 1
	msgbufp = (struct msgbuf *)(va + 0x1000);
@


1.10
log
@switch from private Mach derived conversion macros to m68k ones
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.9 1997/01/16 08:08:41 kstailey Exp $	*/
d46 1
a92 1
int msgbufmapped = 0;
d417 1
a417 1
	msgbufmapped = 1;
@


1.10.12.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a45 1
#include <sys/msgbuf.h>
d92 1
d417 1
a417 1
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
@


1.10.12.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.14 2000/06/29 02:25:30 miod Exp $	*/
a63 2
#include "ksyms.h"

d69 1
a69 3
#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
char *esym;
#endif
a111 1
#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
a112 1
#endif
d284 1
a284 1
#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
a374 1
#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
d376 1
d379 1
a380 3
#else
	virtual_avail = m68k_round_page(end);
#endif
d416 1
a416 1
	msgbufp = (struct msgbuf *)(va + (NBPG >> 1));
a823 6
				break;
			case 'b':
				boothowto |= RB_HALT;
				break;
			case 'c':
				boothowto |= RB_CONFIG;
@


1.10.12.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.10.12.2 2001/05/14 21:37:36 niklas Exp $	*/
d146 1
a146 2
static void
sun3_mode_monitor()
d209 1
a209 1
__dead void
d385 1
a385 1
	virtual_avail = round_page(esym);
d387 1
a387 1
	virtual_avail = round_page(end);
d405 1
a405 1
	avail_end = trunc_page(avail_end);
d424 2
a425 2
	msgbufp = (struct msgbuf *)(va + MSGBUFOFF);
	initmsgbuf((caddr_t)msgbufp, MSGBUFSIZE);
d434 13
d594 1
a594 1
	eva = trunc_page(etext);
d608 1
a608 1
	eva = round_page(end);
d740 2
a741 2
	int addr;
	char *str;
d883 2
@


1.10.12.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.10.12.3 2001/07/04 10:24:16 niklas Exp $	*/
a217 1
	for (;;);	/* appease gcc */
d386 1
a386 1
	virtual_avail = round_page((vaddr_t)esym);
d582 1
a582 1
	eva = trunc_page((vaddr_t)etext);
d596 1
a596 1
	eva = round_page((vaddr_t)end);
@


1.10.12.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#include <uvm/uvm_extern.h>
@


1.10.12.6
log
@Merge in -current from about a week ago
@
text
@d109 1
a109 1
void sun3_bootstrap(struct exec);
d111 5
a115 5
static void sun3_mode_monitor(void);
static void sun3_mode_normal(void);
static void sun3_mon_init(vm_offset_t sva, vm_offset_t eva, int keep);
static void sun3_monitor_hooks(void);
static void sun3_context_equiv(void);
d117 1
a117 1
static void sun3_save_symtab(struct exec *kehp);
d119 4
a122 4
static void sun3_verify_hardware(void);
static void sun3_vm_init(struct exec *kehp);
static void tracedump(int);
static void v_handler(int addr, char *str);
d124 1
a124 1
static void internal_configure(void);
d334 1
a334 1
	symsz = (int *)endp;
d343 1
a343 1
	strsz = (int *)endp;
@


1.10.12.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.10.12.6 2002/03/28 11:26:45 niklas Exp $	*/
@


1.9
log
@Use RB_TIMEBAD in boot() to know not to update the battery backed up clock
via resettodr().  Make Sun3-only command "machine reboot" only print
a warning that the command is obsolete and that you should use the "boot"
command instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun3_startup.c,v 1.8 1997/01/16 04:04:33 kstailey Exp $	*/
d380 1
a380 1
	virtual_avail = sun3_round_page(esym);
d397 1
a397 1
	avail_end = sun3_trunc_page(avail_end);
d474 1
a474 1
	virtual_avail = sun3_round_seg(virtual_avail);
d515 2
a516 2
	va  = sun3_trunc_seg(DVMA_SPACE_START);
	eva = sun3_trunc_seg(DVMA_SPACE_END);  /* Yes trunc! */
d586 1
a586 1
	eva = sun3_trunc_page(etext);
d600 1
a600 1
	eva = sun3_round_page(end);
@


1.8
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d389 1
a389 1
		mon_printf("Warning: ancient PROM version=%d\n",
@


1.7
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
a49 1
#include <machine/cpufunc.h>
d52 2
a54 3
#include <machine/pte.h>
#include <machine/pmap.h>
#include <machine/idprom.h>
d57 2
d73 1
a73 1
 */ 
d83 1
a83 1
unsigned int *old_vector_table;
d105 14
a118 8
/*
 * Switch to our own interrupt vector table.
 */
static void initialize_vector_table()
{
	old_vector_table = getvbr();
	setvbr((unsigned int *) vector_table);
}
d120 2
a121 1
vm_offset_t high_segment_alloc(npages)
a123 1
	int i;
d125 1
a125 1
	
d129 1
a129 1
	
d152 2
a153 1
static void sun3_mode_normal()
d157 1
a157 1
	setvbr((unsigned int *) vector_table);
d169 2
a170 1
void sun3_mon_abort()
d185 1
a185 1
	old_vector_table[32] = (int)romp->abortEntry;
d194 2
a195 1
void sun3_mon_halt()
d203 2
a204 1
void sun3_mon_reboot(bootstring)
d222 2
a223 1
void sun3_context_equiv()
d225 1
a225 1
	unsigned int i, sme;
d256 1
a256 1
	
d258 1
a258 1
	
d288 1
d363 2
a364 1
void sun3_vm_init(kehp)
d367 1
a367 1
	vm_offset_t va, eva, sva, pte, temp_seg;
d506 1
a506 1
	while (va < virtual_end) {	
d624 2
a625 1
void sun3_verify_hardware()
d704 1
d706 1
a706 1
	caddr_t x1;
d735 1
a735 1
	
d748 1
a748 1
			
d750 1
a750 1
			tracedump();
d752 1
a752 1
			
d757 1
a757 1
		
d762 1
a762 1
		
d767 2
a768 1
		
d771 1
a771 1
		tracedump();
d773 1
a773 1
		
d778 1
a778 1
		
d794 2
a795 1
void sun3_monitor_hooks()
d850 2
a851 1
void internal_configure()
d853 1
a853 1
    obio_init();	/* find and record PROM mappings in OBIO space */
a868 1
	int i;
d892 2
a893 1
	initialize_vector_table();
@


1.6
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: sun3_startup.c,v 1.56 1996/12/17 21:11:39 gwr Exp $	*/
d49 1
a50 1
#include <machine/db_machdep.h>
a60 1
#include "machdep.h"
a68 1

d70 3
a72 4
 * Globals shared between pmap.c and sun3_startup.c (sigh).
 * For simplicity, this interface retains the variables
 * that were used in the old interface (without NONCONTIG).
 */
d82 1
a82 2
int cold = 1;
void **old_vector_table;
d95 1
d104 8
a111 9
void sun3_bootstrap __P((struct exec));

static void sun3_mon_init __P((vm_offset_t sva, vm_offset_t eva, int keep));
static void sun3_monitor_hooks __P((void));
static void sun3_save_symtab __P((struct exec *kehp));
static void sun3_verify_hardware __P((void));
static void sun3_vm_init __P((struct exec *kehp));
static void tracedump __P((int));
static void v_handler __P((int addr, char *str));
d113 1
a113 3

vm_offset_t
high_segment_alloc(npages)
d116 1
d118 1
a118 1

d122 1
a122 1

d133 1
a133 2
static void
sun3_mode_monitor __P((void))
d145 1
a145 2
static void
sun3_mode_normal __P((void))
d149 1
a149 1
	setvbr((void**)vector_table);
d176 1
a176 1
	old_vector_table[32] = (void*) romp->abortEntry;
d211 1
a211 2
void
sun3_context_equiv __P((void))
d213 1
a213 1
	unsigned int sme;
d238 2
a239 2
	vm_offset_t sva, eva;
	int keep;	/* true: steal, false: clear */
d244 1
a244 1

d246 1
a246 1

a275 1
static void
d350 1
a350 2
static void
sun3_vm_init(kehp)
d353 1
a353 1
	vm_offset_t va, eva, pte;
d492 1
a492 1
	while (va < virtual_end) {
d610 1
a610 2
static void
sun3_verify_hardware()
a688 1
static void
d690 1
a690 1
	int x1;
d714 1
a714 1
static void
d716 2
a717 2
	int addr;
	char *str;
d719 1
a719 1

d732 1
a732 1

d734 3
a736 2
			goto do_trace;

d741 1
a741 1

d746 1
a746 1

d751 1
a751 2

	do_trace:
d754 1
a754 1
		tracedump(addr);
d756 1
a756 1

d761 1
a761 1

d777 1
a777 2
static void
sun3_monitor_hooks()
d828 15
d850 2
d856 1
a856 1
	/* cold = 1; (now at compile time) */
d866 1
a866 1
    obio_init();		/* stuff that can't wait for configure() */
d869 2
a870 4
	 * Point interrupts/exceptions to our vector table.
	 * (Until now, we use the one setup by the PROM.)
	 *
	 * This is done after obio_init() / intreg_init() finds
d874 1
a874 2
	old_vector_table = getvbr();
	setvbr((void **)vector_table);
@


1.5
log
@sync with NetBSD -- copyright changes only
@
text
@d1 1
a1 1
/*	$NetBSD: sun3_startup.c,v 1.55 1996/11/20 18:57:38 gwr Exp $	*/
a48 1
#include <machine/cpufunc.h>
d50 1
d61 1
d70 1
d72 4
a75 3
 * Globals shared with the pmap code.
 * XXX - should reexamine this...
 */ 
d85 2
a86 1
unsigned int *old_vector_table;
a98 1
unsigned char *interrupt_reg;
d107 10
a116 8
/*
 * Switch to our own interrupt vector table.
 */
static void initialize_vector_table()
{
	old_vector_table = getvbr();
	setvbr((unsigned int *) vector_table);
}
d118 2
a119 1
vm_offset_t high_segment_alloc(npages)
a121 1
	int i;
d123 1
a123 1
	
d127 1
a127 1
	
d138 2
a139 1
static void sun3_mode_monitor()
d151 2
a152 1
static void sun3_mode_normal()
d156 1
a156 1
	setvbr((unsigned int *) vector_table);
d183 1
a183 1
	old_vector_table[32] = (int)romp->abortEntry;
d218 2
a219 1
void sun3_context_equiv()
d221 1
a221 1
	unsigned int i, sme;
d246 2
a247 2
vm_offset_t sva, eva;
int keep;	/* true: steal, false: clear */
d252 1
a252 1
	
d254 1
a254 1
	
d284 1
d359 2
a360 1
void sun3_vm_init(kehp)
d363 1
a363 1
	vm_offset_t va, eva, sva, pte, temp_seg;
d502 1
a502 1
	while (va < virtual_end) {	
d620 2
a621 1
void sun3_verify_hardware()
d700 1
d702 1
a702 1
	caddr_t x1;
d726 1
a726 1
void
d728 2
a729 2
int addr;
char *str;
d731 1
a731 1
	
d744 1
a744 1
			
d746 2
a747 3
			tracedump();
			break;
			
d752 1
a752 1
		
d757 1
a757 1
		
d762 2
a763 1
		
d766 1
a766 1
		tracedump();
d768 1
a768 1
		
d773 1
a773 1
		
d789 2
a790 1
void sun3_monitor_hooks()
a840 15
 * Find mappings for devices that are needed before autoconfiguration.
 * First the obio module finds and records useful PROM mappings, then
 * the necessary drivers are given a chance to use those recorded.
 */
void internal_configure()
{
    obio_init();	/* find and record PROM mappings in OBIO space */
	/* Drivers that use those OBIO mappings from the PROM */
	zs_init();
	eeprom_init();
	intreg_init();
	clock_init();
}

/*
a847 2
	int i;
	extern int cold;
d852 1
a852 1
	cold = 1;
d862 1
a862 1
	internal_configure();	/* stuff that can't wait for configure() */
d865 4
a868 2
	 * Point interrupts/exceptions to our table.
	 * This is done after internal_configure/isr_init finds
d872 2
a873 1
	initialize_vector_table();
@


1.4
log
@sync + our changes
@
text
@d1 1
a1 1
/*	$NetBSD: sun3_startup.c,v 1.52 1996/05/05 06:02:37 gwr Exp $	*/
d3 2
a4 3
/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
d7 3
d20 5
a24 3
 *	This product includes software developed by Adam Glass and Gordon Ross
 * 4. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d26 11
a36 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.3
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: sun3_startup.c,v 1.51 1996/03/26 15:16:59 gwr Exp $	*/
d96 3
a401 2
	 * XXX - Make these non-cached at their full-time mapping address.
	 * XXX - Still need to do that? -gwr
d406 6
a411 2
	avail_start += UPAGES*NBPG;
	/* Make them non-cached. */
d419 9
d766 5
d775 1
a776 1
	int i;
d783 4
a786 2
	for (i = 0; i < 8; i++) {
		p = bpp->argPtr[i];
d788 6
a793 3
		/* Null arg?  We're done. */
		if (p == NULL || *p == '\0')
			break;
d795 1
a795 1
		mon_printf("arg[%d]=\"%s\"\n", i, p);
d797 2
a798 7

		/* Not switches?  Skip it. */
		if (*p++ != '-')
			continue;

		while (*p) {
			switch (*p++) {
d810 1
d812 1
d814 5
a818 1
	mon_printf("boothowto=0x%x\n", boothowto);
a819 12
}

void set_interrupt_reg(value)
	unsigned int value;
{
	*interrupt_reg = (unsigned char) value;
}

unsigned int get_interrupt_reg()
{
	vm_offset_t pte;
	return (unsigned int) *interrupt_reg;
@


1.2
log
@update from netbsd tree
@
text
@d1 1
a1 1
/*	$NetBSD: sun3_startup.c,v 1.48 1995/10/17 23:16:40 gwr Exp $	*/
a194 12
#ifndef DDB
/*
 * When DDB is included, Debugger() comes from db_interface.c
 * otherwise provide this function.  This will just stop in
 * the Sun PROM monitor.  (You can look around, or continue.)
 */
void Debugger()
{
	sun3_mon_abort();
}
#endif	/* DDB */

d480 1
d482 3
a484 2
	va = sun3_trunc_seg(DVMA_SEGMAP_BASE);
	while (va < DVMA_SEGMAP_END) {
d584 7
a590 2
/* XXX - Should just estimate this instead... */
int cpuspeed = 25;	/* initial guess */
d611 1
a611 1
		cpuspeed = 16; /* MHz */
d617 1
a617 1
		cpuspeed = 20; /* MHz */
d623 1
a623 1
		cpuspeed = 17; /* MHz */
d630 1
a630 1
		cpuspeed = 17; /* MHz */
d637 1
a637 1
		cpuspeed = 25; /* MHz */
d647 1
a647 1
		cpuspeed = 20; /* MHz */	/* XXX - Correct? */
d820 1
a820 1
	isr_init();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sun3_startup.c,v 1.47 1995/09/26 04:02:27 gwr Exp $	*/
d207 8
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
