head	1.12;
access;
symbols
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.6
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.14
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2002.12.31.16.35.41;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.04.22.34.48;	author miod;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2000.04.11.02.44.31;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	97.01.16.04.04.14;	author kstailey;	state Exp;
branches
	1.7.14.1;
next	1.6;

1.6
date	97.01.13.00.29.23;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.07.23.36.23;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.31.06.13.32;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.07.55.05;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.03.16.04.25;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.00;	author deraadt;	state Exp;
branches;
next	;

1.7.14.1
date	2001.05.14.21.37.33;	author niklas;	state Exp;
branches;
next	1.7.14.2;

1.7.14.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.7.14.3;

1.7.14.3
date	2003.03.27.23.52.18;	author niklas;	state dead;
branches;
next	;

1.9.6.1
date	2002.06.11.03.39.01;	author art;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.12
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: clock.c,v 1.11 2002/03/14 03:16:01 millert Exp $	*/
/*	$NetBSD: clock.c,v 1.31 1996/10/30 00:24:42 gwr Exp $	*/

/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Utah Hdr: clock.c 1.18 91/01/21$
 *	from: @@(#)clock.c	8.2 (Berkeley) 1/12/94
 */

/*
 * Machine-dependent clock routines for the Intersil 7170:
 * Original by Adam Glass;  partially rewritten by Gordon Ross.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/control.h>
#include <machine/cpu.h>
#include <machine/machdep.h>
#include <machine/mon.h>
#include <machine/obio.h>

#include "intersil7170.h"
#include "interreg.h"
#include "ledsvar.h"

#define	CLOCK_PRI	5

void cpu_initclocks(void);
void clock_intr(struct clockframe *);

extern volatile u_char *interrupt_reg;
volatile char *clock_va;

#define intersil_clock ((volatile struct intersil7170 *) clock_va)

#define intersil_command(run, interrupt) \
	(run | interrupt | INTERSIL_CMD_FREQ_32K | INTERSIL_CMD_24HR_MODE | \
	 INTERSIL_CMD_NORMAL_MODE)

#define intersil_clear() (void)intersil_clock->clk_intr_reg

static int  clock_match(struct device *, void *vcf, void *args);
static void clock_attach(struct device *, struct device *, void *);

struct cfattach clock_ca = {
	sizeof(struct device), clock_match, clock_attach
};

struct cfdriver clock_cd = {
	NULL, "clock", DV_DULL
};

static int
clock_match(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = args;

	/* This driver only supports one unit. */
	if (cf->cf_unit != 0)
		return (0);

	/* Validate the given address. */
	if (ca->ca_paddr != OBIO_CLOCK)
		return (0);

	/* Default interrupt priority. */
	if (ca->ca_intpri == -1)
		ca->ca_intpri = CLOCK_PRI;

	return (1);
}

static void
clock_attach(parent, self, args)
	struct device *parent;
	struct device *self;
	void *args;
{

	printf("\n");

	/*
	 * Can not hook up the ISR until cpu_initclock()
	 * because hardclock is not ready until then.
	 */
}

/*
 * Set and/or clear the desired clock bits in the interrupt
 * register.  We have to be extremely careful that we do it
 * in such a manner that we don't get ourselves lost.
 */
void
set_clk_mode(on, off, enable)
	u_char on, off;
	int enable;
{
	register u_char interreg;
	register int s;

	s = getsr();
	if ((s & PSL_IPL) < PSL_IPL7)
		panic("set_clk_mode: ipl");

	if (!intersil_clock)
		panic("set_clk_mode: map");

	/*
	 * make sure that we are only playing w/
	 * clock interrupt register bits
	 */
	on &= (IREG_CLOCK_ENAB_7 | IREG_CLOCK_ENAB_5);
	off &= (IREG_CLOCK_ENAB_7 | IREG_CLOCK_ENAB_5);

	/*
	 * Get a copy of current interrupt register,
	 * turning off any undesired bits (aka `off')
	 */
	interreg = *interrupt_reg & ~(off | IREG_ALL_ENAB);
	*interrupt_reg &= ~IREG_ALL_ENAB;

	/*
	 * Next we turns off the CLK5 and CLK7 bits to clear
	 * the flip-flops, then we disable clock interrupts.
	 * Now we can read the clock's interrupt register
	 * to clear any pending signals there.
	 */
	*interrupt_reg &= ~(IREG_CLOCK_ENAB_7 | IREG_CLOCK_ENAB_5);
	intersil_clock->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IDISABLE);
	intersil_clear();

	/*
	 * Now we set all the desired bits
	 * in the interrupt register, then
	 * we turn the clock back on and
	 * finally we can enable all interrupts.
	 */
	*interrupt_reg |= (interreg | on);		/* enable flip-flops */

	if (enable)
		intersil_clock->clk_cmd_reg =
			intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);

	*interrupt_reg |= IREG_ALL_ENAB;		/* enable interrupts */
}

/* Called very early by internal_configure. */
void
clock_init()
{
	clock_va = obio_find_mapping(OBIO_CLOCK, OBIO_CLOCK_SIZE);

	if (!clock_va)
		mon_panic("clock_init: clock_va\n");
	if (!interrupt_reg)
		mon_panic("clock_init: interrupt_reg\n");

	/* Turn off clock interrupts until cpu_initclocks() */
	/* isr_init() already set the interrupt reg to zero. */
	intersil_clock->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IDISABLE);
	intersil_clear();
}

#ifdef	DIAGNOSTIC
static int clk_intr_ready;
#endif

/*
 * Set up the real-time clock (enable clock interrupts).
 * Leave stathz 0 since there is no secondary clock available.
 * Note that clock interrupts MUST STAY DISABLED until here.
 */
void
cpu_initclocks()
{
	int s;
	extern void _isr_clock(void);	/* in locore.s */

	if (!intersil_clock)
		panic("cpu_initclocks");
	s = splhigh();

	isr_add_custom(5, _isr_clock);
#ifdef	DIAGNOSTIC
	clk_intr_ready = 1;
#endif

	/* Set the clock to interrupt 100 time per second. */
	intersil_clock->clk_intr_reg = INTERSIL_INTER_CSECONDS;

	*interrupt_reg |= IREG_CLOCK_ENAB_5;	/* enable clock */
	intersil_clock->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
	*interrupt_reg |= IREG_ALL_ENAB;		/* enable interrupts */
	splx(s);
}

/*
 * This doesn't need to do anything, as we have only one timer and
 * profhz==stathz==hz.
 */
void
setstatclockrate(newhz)
	int newhz;
{
	/* nothing */
}

/*
 * This is is called by the "custom" interrupt handler
 * after it has reset the pending bit in the clock.
 */
void clock_intr(frame)
	struct clockframe *frame;
{
	unsigned int i;

#ifdef	DIAGNOSTIC
	if (!clk_intr_ready)
		panic("clock_intr");
#endif

	/* XXX - Move this LED frobbing to the idle loop? */
	i = led_countdown;
	if (i == 0) {
		led_countdown = led_countmax;
		i = led_px;
		set_control_byte((char *) DIAG_REG, led_patterns[i]);
		if (i == 0)
			i = led_n_patterns;
		led_px = i - 1;
	} else
		led_countdown = i - 1;
	hardclock(frame);
}


/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt.
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for
 * fun, we guarantee that the time will be greater than the value
 * obtained by a previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
{
	int s = splhigh();
	static struct timeval lasttime;

	*tvp = time;
	tvp->tv_usec++; 	/* XXX */
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
		tvp->tv_usec <= lasttime.tv_usec &&
		(tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000)
	{
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
}


/*
 * Machine-dependent clock routines.
 *
 * Inittodr initializes the time of day hardware which provides
 * date functions.
 *
 * Resettodr restores the time of day hardware after a time change.
 */
#define SECDAY		86400L
#define SECYR		(SECDAY * 365)

static void clk_get_dt(struct date_time *);
static void clk_set_dt(struct date_time *);
void gmt_to_dt(long *, struct date_time *);
void dt_to_gmt(struct date_time *, long *);
static long clk_get_secs(void);
static void clk_set_secs(long);

/*
 * Initialize the time of day register, based on the time base
 * which is, e.g. from a filesystem.
 */
void inittodr(fs_time)
	time_t fs_time;
{
	long diff, clk_time;
	long long_ago = (5 * SECYR);
	int clk_bad = 0;

	/*
	 * Sanity check time from file system.
	 * If it is zero,assume filesystem time is just unknown
	 * instead of preposterous.  Don't bark.
	 */
	if (fs_time < long_ago) {
		/*
		 * If fs_time is zero, assume filesystem time is just
		 * unknown instead of preposterous.  Don't bark.
		 */
		if (fs_time != 0)
			printf("WARNING: preposterous time in file system\n");
		/* 1991/07/01  12:00:00 */
		fs_time = 21*SECYR + 186*SECDAY + SECDAY/2;
	}

	clk_time = clk_get_secs();

	/* Sanity check time from clock. */
	if (clk_time < long_ago) {
		printf("WARNING: bad date in battery clock");
		clk_bad = 1;
		clk_time = fs_time;
	} else {
		/* Does the clock time jive with the file system? */
		diff = clk_time - fs_time;
		if (diff < 0)
			diff = -diff;
		if (diff >= (SECDAY*2)) {
			printf("WARNING: clock %s %ld days",
				   (clk_time < fs_time) ? "lost" : "gained",
				   diff / SECDAY);
			clk_bad = 1;
		}
	}
	if (clk_bad)
		printf(" -- CHECK AND RESET THE DATE!\n");
	time.tv_sec = clk_time;
}

/*
 * Resettodr restores the time of day hardware after a time change.
 */
void
resettodr()
{
	clk_set_secs(time.tv_sec);
}

/*
 * Machine dependent base year:
 * Note: must be < 1970
 */
#define	CLOCK_BASE_YEAR	1968


/*
 * Routine to copy state into and out of the clock.
 * The clock registers have to be read or written
 * in sequential order (or so it appears). -gwr
 */
static void
clk_get_dt(dt)
	struct date_time *dt;
{
	int s;
	register volatile char *src, *dst;

	src = (char *) &intersil_clock->counters;

	s = splhigh();
	intersil_clock->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

	dst = (char *) dt;
	dt++;	/* end marker */
	do {
		*dst++ = *src++;
	} while (dst < (char *)dt);

	intersil_clock->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
	splx(s);
}

static void
clk_set_dt(dt)
	struct date_time *dt;
{
	int s;
	register volatile char *src, *dst;

	dst = (char *) &intersil_clock->counters;

	s = splhigh();
	intersil_clock->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_STOP, INTERSIL_CMD_IENABLE);

	src = (char *) dt;
	dt++;	/* end marker */
	do {
		*dst++ = *src++;
	} while (src < (char *)dt);

	intersil_clock->clk_cmd_reg =
		intersil_command(INTERSIL_CMD_RUN, INTERSIL_CMD_IENABLE);
	splx(s);
}



/*
 * Generic routines to convert to or from a POSIX date
 * (seconds since 1/1/1970) and  yr/mo/day/hr/min/sec
 *
 * These are organized this way mostly to so the code
 * can easily be tested in an independent user program.
 * (These are derived from the hp300 code.)
 */

/* Traditional UNIX base year */
#define	POSIX_BASE_YEAR	1970
#define FEBRUARY	2

#define	leapyear(year)		((year) % 4 == 0)
#define	days_in_year(a) 	(leapyear(a) ? 366 : 365)
#define	days_in_month(a) 	(month_days[(a) - 1])

static int month_days[12] = {
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

void
gmt_to_dt(tp, dt)
	long *tp;
	struct date_time *dt;
{
	register int i;
	register long days, secs;

	days = *tp / SECDAY;
	secs = *tp % SECDAY;

	/* Hours, minutes, seconds are easy */
	dt->dt_hour = secs / 3600;
	secs = secs % 3600;
	dt->dt_min  = secs / 60;
	secs = secs % 60;
	dt->dt_sec  = secs;

	/* Day of week (Note: 1/1/1970 was a Thursday) */
	dt->dt_dow = (days + 4) % 7;

	/* Number of years in days */
	i = POSIX_BASE_YEAR;
	while (days >= days_in_year(i)) {
		days -= days_in_year(i);
		i++;
	}
	dt->dt_year = i - CLOCK_BASE_YEAR;

	/* Number of months in days left */
	if (leapyear(i))
		days_in_month(FEBRUARY) = 29;
	for (i = 1; days >= days_in_month(i); i++)
		days -= days_in_month(i);
	days_in_month(FEBRUARY) = 28;
	dt->dt_month = i;

	/* Days are what is left over (+1) from all that. */
	dt->dt_day = days + 1;
}

void
dt_to_gmt(dt, tp)
	struct date_time *dt;
	long *tp;
{
	register int i;
	register long tmp;
	int year;

	/*
	 * Hours are different for some reason. Makes no sense really.
	 */

	tmp = 0;

	if (dt->dt_hour >= 24) goto out;
	if (dt->dt_day  >  31) goto out;
	if (dt->dt_month > 12) goto out;

	year = dt->dt_year + CLOCK_BASE_YEAR;

	/*
	 * Compute days since start of time
	 * First from years, then from months.
	 */
	for (i = POSIX_BASE_YEAR; i < year; i++)
		tmp += days_in_year(i);
	if (leapyear(year) && dt->dt_month > FEBRUARY)
		tmp++;

	/* Months */
	for (i = 1; i < dt->dt_month; i++)
	  	tmp += days_in_month(i);
	tmp += (dt->dt_day - 1);

	/* Now do hours */
	tmp = tmp * 24 + dt->dt_hour;

	/* Now do minutes */
	tmp = tmp * 60 + dt->dt_min;

	/* Now do seconds */
	tmp = tmp * 60 + dt->dt_sec;

 out:
	*tp = tmp;
}

/*
 * Now routines to get and set clock as POSIX time.
 */

static long
clk_get_secs()
{
	struct date_time dt;
	long gmt;

	clk_get_dt(&dt);
	dt_to_gmt(&dt, &gmt);
	return (gmt);
}

static void
clk_set_secs(secs)
	long secs;
{
	struct date_time dt;
	long gmt;

	gmt = secs;
	gmt_to_dt(&gmt, &dt);
	clk_set_dt(&dt);
}


#ifdef	DEBUG
/* Call this from DDB or whatever... */
int
clkdebug()
{
	struct date_time dt;
	long gmt;
	long *lp;

	bzero((char *)&dt, sizeof(dt));
	clk_get_dt(&dt);
	lp = (long *)&dt;
	printf("clkdebug: dt=[%x,%x]\n", lp[0], lp[1]);

	dt_to_gmt(&dt, &gmt);
	printf("clkdebug: gmt=%x\n", gmt);
}
#endif
@


1.11
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2002/03/14 01:26:47 millert Exp $	*/
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2001/01/04 22:34:48 miod Exp $	*/
d428 1
a428 1
	} while (dst < (char*)dt);
d608 1
a608 1
	bzero((char*)&dt, sizeof(dt));
d610 1
a610 1
	lp = (long*)&dt;
@


1.9
log
@KNF, add prototypes to compile with -Wmissing-prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2000/04/11 02:44:31 pjanzen Exp $	*/
d71 2
a72 2
void cpu_initclocks __P((void));
void clock_intr __P((struct clockframe *));
d85 2
a86 2
static int  clock_match __P((struct device *, void *vcf, void *args));
static void clock_attach __P((struct device *, struct device *, void *));
d225 1
a225 1
	extern void _isr_clock __P((void));	/* in locore.s */
d332 6
a337 6
static void clk_get_dt __P((struct date_time *));
static void clk_set_dt __P((struct date_time *));
void gmt_to_dt __P((long *, struct date_time *));
void dt_to_gmt __P((struct date_time *, long *));
static long clk_get_secs __P((void));
static void clk_set_secs __P((long));
@


1.9.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2001/01/04 22:34:48 miod Exp $	*/
d71 2
a72 2
void cpu_initclocks(void);
void clock_intr(struct clockframe *);
d85 2
a86 2
static int  clock_match(struct device *, void *vcf, void *args);
static void clock_attach(struct device *, struct device *, void *);
d225 1
a225 1
	extern void _isr_clock(void);	/* in locore.s */
d332 6
a337 6
static void clk_get_dt(struct date_time *);
static void clk_set_dt(struct date_time *);
void gmt_to_dt(long *, struct date_time *);
void dt_to_gmt(struct date_time *, long *);
static long clk_get_secs(void);
static void clk_set_secs(long);
d428 1
a428 1
	} while (dst < (char *)dt);
d608 1
a608 1
	bzero((char *)&dt, sizeof(dt));
d610 1
a610 1
	lp = (long *)&dt;
@


1.9.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9.6.1 2002/06/11 03:39:01 art Exp $	*/
@


1.8
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 1997/01/16 04:04:14 kstailey Exp $	*/
a73 1

d195 2
a196 1
void clock_init()
d222 1
a222 1
cpu_initclocks(void)
d332 6
a337 2
static long clk_get_secs(void);
static void clk_set_secs(long);
d412 2
a413 1
clk_get_dt(struct date_time *dt)
d436 2
a437 1
clk_set_dt(struct date_time *dt)
d483 3
a485 1
gmt_to_dt(long *tp, struct date_time *dt)
d524 3
a526 1
dt_to_gmt(struct date_time *dt, long *tp)
d587 2
a588 1
clk_set_secs(long secs)
@


1.7
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 1997/01/13 00:29:23 kstailey Exp $	*/
d305 1
a305 1
	while (tvp->tv_usec > 1000000) {
d311 1
a311 1
		(tvp->tv_usec = lasttime.tv_usec + 1) > 1000000)
@


1.7.14.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2001/01/04 22:34:48 miod Exp $	*/
d74 1
d196 1
a196 2
void
clock_init()
d222 1
a222 1
cpu_initclocks()
d305 1
a305 1
	while (tvp->tv_usec >= 1000000) {
d311 1
a311 1
		(tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000)
d332 2
a333 6
static void clk_get_dt __P((struct date_time *));
static void clk_set_dt __P((struct date_time *));
void gmt_to_dt __P((long *, struct date_time *));
void dt_to_gmt __P((struct date_time *, long *));
static long clk_get_secs __P((void));
static void clk_set_secs __P((long));
d408 1
a408 2
clk_get_dt(dt)
	struct date_time *dt;
d431 1
a431 2
clk_set_dt(dt)
	struct date_time *dt;
d477 1
a477 3
gmt_to_dt(tp, dt)
	long *tp;
	struct date_time *dt;
d516 1
a516 3
dt_to_gmt(dt, tp)
	struct date_time *dt;
	long *tp;
d577 1
a577 2
clk_set_secs(secs)
	long secs;
@


1.7.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 2
a72 2
void cpu_initclocks(void);
void clock_intr(struct clockframe *);
d85 2
a86 2
static int  clock_match(struct device *, void *vcf, void *args);
static void clock_attach(struct device *, struct device *, void *);
d225 1
a225 1
	extern void _isr_clock(void);	/* in locore.s */
d332 6
a337 6
static void clk_get_dt(struct date_time *);
static void clk_set_dt(struct date_time *);
void gmt_to_dt(long *, struct date_time *);
void dt_to_gmt(struct date_time *, long *);
static long clk_get_secs(void);
static void clk_set_secs(long);
d428 1
a428 1
	} while (dst < (char *)dt);
d608 1
a608 1
	bzero((char *)&dt, sizeof(dt));
d610 1
a610 1
	lp = (long *)&dt;
@


1.7.14.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7.14.2 2002/03/28 11:26:45 niklas Exp $	*/
@


1.6
log
@back-panel LED control device derived from code by der Mouse
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 1
#include <machine/psl.h>
d61 1
a61 1

a63 1
#include <machine/control.h>
d71 4
d99 2
a100 2
    struct device *parent;
    void *vcf, *args;
d102 1
a102 1
    struct cfdata *cf = vcf;
a103 1
	int pa;
a125 2
	struct cfdata *cf = self->dv_cfdata;
	struct confargs *ca = args;
d140 1
d156 1
a156 1
	 * make sure that we are only playing w/ 
d225 1
a225 1
	extern void _isr_clock();
d375 1
a375 1
			printf("WARNING: clock %s %d days",
d386 1
a386 1
/*   
d389 2
a390 1
void resettodr()
d407 2
a408 1
static void clk_get_dt(struct date_time *dt)
d430 2
a431 1
static void clk_set_dt(struct date_time *dt)
d476 2
a477 1
void gmt_to_dt(long *tp, struct date_time *dt)
d512 1
a512 1
	dt->dt_day = days + 1;  
d515 2
a516 1
void dt_to_gmt(struct date_time *dt, long *tp)
d565 2
a566 1
static long clk_get_secs()
d576 2
a577 1
static void clk_set_secs(long secs)
d590 2
a591 1
int clkdebug()
@


1.5
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
d68 1
a259 1
int clock_count = 0;
d263 1
a263 1
	static unsigned char led_pattern = 0xFE;
d271 10
a280 7
	clock_count++;
	if ((clock_count & 7) == 0) {
		led_pattern = (led_pattern << 1) | 1;
		if (led_pattern == 0xFF)
			led_pattern = 0xFE;
		set_control_byte((char *) DIAG_REG, led_pattern);
	}
@


1.4
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.32 1996/12/17 21:11:17 gwr Exp $	*/
d58 1
a58 1
#include <machine/control.h>
d60 1
d63 1
a66 1
#include "machdep.h"
d70 2
a71 6
void _isr_clock __P((void));	/* in locore.s */
void clock_intr __P((struct clockframe));
static void frob_leds __P((struct clockframe *));

/* Note: this is used by locore.s:__isr_clock */
static volatile char *clock_va;
d81 1
a81 1
static int  clock_match __P((struct device *, void *, void *));
d97 1
a97 1
	struct cfdata *cf = vcf;
d99 1
d122 2
d128 1
a128 1
	 * Can not hook up the ISR until cpu_initclocks()
a129 2
	 * For now, the handler is _isr_autovec(), which
	 * will complain if it gets clock interrupts.
a137 1
void
d153 1
a153 1
	 * make sure that we are only playing w/
d209 4
d222 1
d228 4
a231 2
	/* Install isr (in locore.s) that calls clock_intr(). */
	isr_add_custom(5, (void*)_isr_clock);
d258 3
a260 3
void
clock_intr(cf)
	struct clockframe cf;
d262 1
a262 2
	register volatile struct intersil7170 *clk = intersil_clock;
	extern int ticks;
d264 4
a267 7
	/* Read the clock interrupt register. */
	(void) clk->clk_intr_reg;
	/* Pulse the clock intr. enable low. */
	*interrupt_reg &= ~IREG_CLOCK_ENAB_5;
	*interrupt_reg |=  IREG_CLOCK_ENAB_5;
	/* Read the clock intr. reg AGAIN! */
	(void) clk->clk_intr_reg;
d269 9
a277 4
	hardclock(&cf);

	if ((ticks & 7) == 0)
		frob_leds(&cf);
a279 12
static void
frob_leds(cf)
	struct clockframe *cf;
{
	static unsigned char led_pattern = 0xFE;

	/* XXX - Move this LED frobbing to the idle loop? */
	led_pattern = (led_pattern << 1) | 1;
	if (led_pattern == 0xFF)
		led_pattern = 0xFE;
	set_control_byte((char *) DIAG_REG, led_pattern);
}
d381 1
a381 1
/*
d503 1
a503 1
	dt->dt_day = days + 1;
@


1.3
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.31 1996/10/30 00:24:42 gwr Exp $	*/
d58 1
a58 1
#include <machine/psl.h>
a59 1

a61 1
#include <machine/control.h>
d65 1
d69 6
a74 2
extern volatile u_char *interrupt_reg;
volatile char *clock_va;
d84 1
a84 1
static int  clock_match __P((struct device *, void *vcf, void *args));
d100 1
a100 1
    struct cfdata *cf = vcf;
a101 1
	int pa;
a123 2
	struct cfdata *cf = self->dv_cfdata;
	struct confargs *ca = args;
d128 1
a128 1
	 * Can not hook up the ISR until cpu_initclock()
d130 2
d140 1
d156 1
a156 1
	 * make sure that we are only playing w/ 
a211 4
#ifdef	DIAGNOSTIC
static int clk_intr_ready;
#endif

a220 1
	extern void _isr_clock();
d226 2
a227 4
	isr_add_custom(5, _isr_clock);
#ifdef	DIAGNOSTIC
	clk_intr_ready = 1;
#endif
d254 24
a277 3
int clock_count = 0;
void clock_intr(frame)
	struct clockframe *frame;
a280 5
#ifdef	DIAGNOSTIC
	if (!clk_intr_ready)
		panic("clock_intr");
#endif

d282 4
a285 8
	clock_count++;
	if ((clock_count & 7) == 0) {
		led_pattern = (led_pattern << 1) | 1;
		if (led_pattern == 0xFF)
			led_pattern = 0xFE;
		set_control_byte((char *) DIAG_REG, led_pattern);
	}
	hardclock(frame);
a287 1

d388 1
a388 1
/*   
d510 1
a510 1
	dt->dt_day = days + 1;  
@


1.2
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.28 1996/03/26 15:16:42 gwr Exp $	*/
d105 2
a106 9
	if ((pa = cf->cf_paddr) == -1) {
		/* Use our default PA. */
		pa = OBIO_CLOCK;
	} else {
		/* Validate the given PA. */
		if (pa != OBIO_CLOCK)
			panic("clock: wrong address");
	}
	if (pa != ca->ca_paddr)
d109 4
a123 8
	int pri;

	if ((pri = cf->cf_intpri) == -1) {
		pri = CLOCK_PRI;
	} else {
		if (pri != CLOCK_PRI)
			panic("clock: level != %d", CLOCK_PRI);
	}
d125 1
a125 1
	printf(" level %d\n", pri);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.26 1995/08/21 21:37:36 gwr Exp $	*/
d68 2
d81 2
a82 2
int clockmatch __P((struct device *, void *vcf, void *args));
void clockattach __P((struct device *, struct device *, void *));
d84 7
a90 3
struct cfdriver clockcd = {
	NULL, "clock", clockmatch, clockattach,
	DV_DULL, sizeof(struct device), 0 };
d92 2
a93 1
int clockmatch(parent, vcf, args)
d99 1
d104 12
a115 4
	if (ca->ca_paddr == -1)
		ca->ca_paddr = OBIO_CLOCK;
	if (ca->ca_intpri == -1)
		ca->ca_intpri = 5;
d119 2
a120 1
void clockattach(parent, self, args)
d125 1
d127 10
a137 3
	printf("\n");
	if (ca->ca_intpri != 5)
		panic("clock: level != 5");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
