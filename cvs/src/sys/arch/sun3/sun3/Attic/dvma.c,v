head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2002.12.31.16.35.41;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2002.11.10.21.23.09;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.17.01.10.11;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.11.23.21.14;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.27.04.44.02;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.11.01.30.13;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.30.20.40.03;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	99.01.11.05.12.05;	author millert;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	97.09.07.14.05.20;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.04.04.19;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.07.23.36.26;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.31.06.13.39;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.08.26.05;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.03.16.04.33;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.01;	author deraadt;	state Exp;
branches;
next	;

1.8.6.1
date	2001.07.04.10.24.09;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.8.6.4;

1.8.6.4
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.8.6.5;

1.8.6.5
date	2003.03.27.23.52.18;	author niklas;	state dead;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.26;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2003.05.19.21.49.46;	author tedu;	state dead;
branches;
next	;


desc
@@


1.17
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: dvma.c,v 1.16 2002/11/10 21:23:09 miod Exp $	*/
/*	$NetBSD: dvma.c,v 1.5 1996/11/20 18:57:29 gwr Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/extent.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/core.h>
#include <sys/exec.h>

#include <uvm/uvm.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/control.h>
#include <machine/dvma.h>
#include <machine/machdep.h>
#include <machine/pte.h>
#include <machine/pmap.h>
#include <machine/reg.h>


/* Resource map used by dvma_mapin/dvma_mapout */
#define	NUM_DVMA_SEGS 10
struct	extent *dvma_segmap;

/* XXX: Might need to tune this... */
vm_size_t dvma_segmap_size = 6 * NBSG;

/* Using phys_map to manage DVMA scratch-memory pages. */
/* Note: Could use separate pagemap for obio if needed. */

void
dvma_init()
{
	vm_offset_t segmap_addr;

	/*
	 * Create phys_map covering the entire DVMA space,
	 * then allocate the segment pool from that.  The
	 * remainder will be used as the DVMA page pool.
	 */
	phys_map = uvm_map_create(pmap_kernel(),
	    DVMA_SPACE_START, DVMA_SPACE_END, VM_MAP_INTRSAFE);
	if (phys_map == NULL)
		panic("unable to create DVMA map");

	/*
	 * Reserve the DVMA space used for segment remapping.
	 * The remainder of phys_map is used for DVMA scratch
	 * memory pages (i.e. driver control blocks, etc.)
	 */
	segmap_addr = uvm_km_valloc_wait(phys_map, dvma_segmap_size);
	if (segmap_addr != DVMA_SPACE_START)
		panic("dvma_init: unable to allocate DVMA segments");

	/*
	 * Create the VM pool used for mapping whole segments
	 * into DVMA space for the purpose of data transfer.
	 */
	dvma_segmap = extent_create("dvma_segmap",
	    (u_long)segmap_addr, (u_long)segmap_addr + NUM_DVMA_SEGS * NBSG,
	    M_DEVBUF, NULL, 0, EX_NOWAIT);
}

/*
 * Allocate actual memory pages in DVMA space.
 * (idea for implementation borrowed from Chris Torek.)
 */
caddr_t
dvma_malloc(bytes)
	size_t bytes;
{
    caddr_t new_mem;
    vm_size_t new_size;

    if (!bytes)
		return NULL;
    new_size = round_page(bytes);
    new_mem = (caddr_t) uvm_km_alloc(phys_map, new_size);
    if (!new_mem)
		panic("dvma_malloc: no space in phys_map");
    /* The pmap code always makes DVMA pages non-cached. */
    return new_mem;
}

/*
 * Free pages from dvma_malloc()
 */
void
dvma_free(addr, size)
	caddr_t	addr;
	size_t	size;
{
	vm_size_t sz = round_page(size);

	uvm_km_free(phys_map, (vm_offset_t)addr, sz);
}

/*
 * Given a DVMA address, return the physical address that
 * would be used by some OTHER bus-master besides the CPU.
 * (Examples: on-board ie/le, VME xy board).
 */
long
dvma_kvtopa(kva, bustype)
	long kva;
	int bustype;
{
	long mask;

	if (kva < DVMA_SPACE_START || kva >= DVMA_SPACE_END)
		panic("dvma_kvtopa: bad dmva addr=0x%x", kva);

	switch (bustype) {
	case BUS_OBIO:
		mask = DVMA_OBIO_SLAVE_MASK;
		break;
	case BUS_VME16:
	case BUS_VME32:
		mask = DVMA_VME_SLAVE_MASK;
		break;
	default:
		panic("dvma_kvtopa: bad bus type %d", bustype);
	}

	return(kva & mask);
}

/*
 * Given a range of kernel virtual space, remap all the
 * pages found there into the DVMA space (dup mappings).
 * This IS safe to call at interrupt time.
 * (Typically called at SPLBIO)
 */
caddr_t
dvma_mapin(kva, len)
	char *kva;
	int len;
{
	vm_offset_t seg_kva, seg_dma, seg_len, seg_off;
	register vm_offset_t v, x;
	register int sme;
	int s, error;

	/* Get seg-aligned address and length. */
	seg_kva = (vm_offset_t)kva;
	seg_len = (vm_offset_t)len;
	/* seg-align beginning */
	seg_off = seg_kva & SEGOFSET;
	seg_kva -= seg_off;
	seg_len += seg_off;
	/* seg-align length */
	seg_len = m68k_round_seg(seg_len);

	s = splimp();

	/* Allocate the DVMA segment(s) */
	error = extent_alloc(dvma_segmap, seg_len, NBSG,
	    0, EX_NOBOUNDARY, EX_NOWAIT, (u_long *)&seg_dma);
	if (error != 0)
		seg_dma = NULL;

#ifdef	DIAGNOSTIC
	if (seg_dma & SEGOFSET)
		panic("dvma_mapin: seg not aligned");
#endif

	if (seg_dma != NULL) {
		/* Duplicate the mappings into DMA space. */
		v = seg_kva;
		x = seg_dma;
		while (seg_len > 0) {
			sme = get_segmap(v);
#ifdef	DIAGNOSTIC
			if (sme == SEGINV)
				panic("dvma_mapin: seg not mapped");
#endif
#ifdef	HAVECACHE
			/* flush write-back on old mappings */
			if (cache_size)
				cache_flush_segment(v);
#endif
			set_segmap_allctx(x, sme);
			v += NBSG;
			x += NBSG;
			seg_len -= NBSG;
		}
		seg_dma += seg_off;
	}

	splx(s);
	return ((caddr_t)seg_dma);
}

/*
 * Free some DVMA space allocated by the above.
 * This IS safe to call at interrupt time.
 * (Typically called at SPLBIO)
 */
void
dvma_mapout(dma, len)
	char *dma;
	int len;
{
	vm_offset_t seg_dma, seg_len, seg_off;
	register vm_offset_t v, x;
	register int sme;
	int s, error;

	/* Get seg-aligned address and length. */
	seg_dma = (vm_offset_t)dma;
	seg_len = (vm_offset_t)len;
	/* seg-align beginning */
	seg_off = seg_dma & SEGOFSET;
	seg_dma -= seg_off;
	seg_len += seg_off;
	/* seg-align length */
	seg_len = m68k_round_seg(seg_len);

	s = splimp();

	/* Flush cache and remove DVMA mappings. */
	v = seg_dma;
	x = v + seg_len;
	while (v < x) {
		sme = get_segmap(v);
#ifdef	DIAGNOSTIC
		if (sme == SEGINV)
			panic("dvma_mapout: seg not mapped");
#endif
#ifdef	HAVECACHE
		/* flush write-back on the DVMA mappings */
		if (cache_size)
			cache_flush_segment(v);
#endif
		set_segmap_allctx(v, SEGINV);
		v += NBSG;
	}

	error = extent_free(dvma_segmap, (u_long)seg_dma, seg_len, EX_NOWAIT);

	if (error != 0)
		printf("dvma_mapout: extent_free failed\n");

	splx(s);
}
@


1.16
log
@Use appropriate VM_MAP constants rather than hardcoded values in
uvm_map_create() and uvm_km_suballoc().
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.15 2002/01/17 01:10:11 miod Exp $	*/
@


1.15
log
@Replace resource maps with extents.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.14 2001/11/06 19:53:16 miod Exp $	*/
d85 1
a85 1
		DVMA_SPACE_START, DVMA_SPACE_END, 1);
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.13 2001/09/19 20:50:57 mickey Exp $	*/
d45 1
a45 1
#include <sys/map.h>
d66 1
a66 1
struct map dvma_segmap[NUM_DVMA_SEGS];
d102 3
a104 2
	rminit(dvma_segmap, dvma_segmap_size, segmap_addr,
		   "dvma_segmap", NUM_DVMA_SEGS);
d185 1
a185 1
	int s;
d200 4
a203 1
	seg_dma = rmalloc(dvma_segmap, seg_len);
d210 1
a210 1
	if (seg_dma != 0) {
d250 1
a250 1
	int s;
d282 5
a286 1
	rmfree(dvma_segmap, seg_len, seg_dma);
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.15 2002/01/17 01:10:11 miod Exp $	*/
d45 1
a45 1
#include <sys/extent.h>
d66 1
a66 1
struct	extent *dvma_segmap;
d102 2
a103 3
	dvma_segmap = extent_create("dvma_segmap",
	    (u_long)segmap_addr, (u_long)segmap_addr + NUM_DVMA_SEGS * NBSG,
	    M_DEVBUF, NULL, 0, EX_NOWAIT);
d184 1
a184 1
	int s, error;
d199 1
a199 4
	error = extent_alloc(dvma_segmap, seg_len, NBSG,
	    0, EX_NOBOUNDARY, EX_NOWAIT, (u_long *)&seg_dma);
	if (error != 0)
		seg_dma = NULL;
d206 1
a206 1
	if (seg_dma != NULL) {
d246 1
a246 1
	int s, error;
d278 1
a278 5
	error = extent_free(dvma_segmap, (u_long)seg_dma, seg_len, EX_NOWAIT);

	if (error != 0)
		printf("dvma_mapout: extent_free failed\n");

@


1.14.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.14.2.1 2002/01/31 22:55:26 niklas Exp $	*/
@


1.13
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.12 2001/08/11 23:21:14 art Exp $	*/
a50 2

#include <vm/vm.h>
@


1.12
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.11 2001/06/27 04:44:02 art Exp $	*/
a52 1
#include <vm/vm_kern.h>
@


1.11
log
@Zap old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.10 2001/06/11 01:30:13 miod Exp $	*/
a53 1
#include <vm/vm_map.h>
@


1.10
log
@Use MI {trunc,round}_page macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.9 2001/05/30 20:40:03 miod Exp $	*/
a55 1
#ifdef UVM
a56 1
#endif
a87 1
#ifdef UVM
a89 4
#else
	phys_map = vm_map_create(pmap_kernel(),
		DVMA_SPACE_START, DVMA_SPACE_END, 1);
#endif
a97 1
#ifdef UVM
a98 3
#else
	segmap_addr = kmem_alloc_wait(phys_map, dvma_segmap_size);
#endif
a123 1
#ifdef UVM
a124 3
#else
    new_mem = (caddr_t) kmem_alloc(phys_map, new_size);
#endif
a140 1
#ifdef UVM
a141 3
#else
	kmem_free(phys_map, (vm_offset_t)addr, sz);
#endif
@


1.9
log
@Preliminary UVM support. UVM kernels don't work for the moment, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.8 1999/01/11 05:12:05 millert Exp $	*/
d134 1
a134 1
    new_size = m68k_round_page(bytes);
d154 1
a154 1
	vm_size_t sz = m68k_round_page(size);
@


1.8
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.7 1997/09/07 14:05:20 kstailey Exp $	*/
d56 4
d90 4
d96 1
d105 3
d109 1
d135 3
d139 1
d156 3
d160 1
@


1.8.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.8 1999/01/11 05:12:05 millert Exp $	*/
a55 2
#include <uvm/uvm.h>

d86 1
a86 1
	phys_map = uvm_map_create(pmap_kernel(),
d96 1
a96 1
	segmap_addr = uvm_km_valloc_wait(phys_map, dvma_segmap_size);
d121 2
a122 2
    new_size = round_page(bytes);
    new_mem = (caddr_t) uvm_km_alloc(phys_map, new_size);
d137 1
a137 1
	vm_size_t sz = round_page(size);
d139 1
a139 1
	uvm_km_free(phys_map, (vm_offset_t)addr, sz);
@


1.8.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.8.6.1 2001/07/04 10:24:09 niklas Exp $	*/
d53 2
@


1.8.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 2
@


1.8.6.4
log
@Merge in trunk
@
text
@d45 1
a45 1
#include <sys/extent.h>
d66 1
a66 1
struct	extent *dvma_segmap;
d102 2
a103 3
	dvma_segmap = extent_create("dvma_segmap",
	    (u_long)segmap_addr, (u_long)segmap_addr + NUM_DVMA_SEGS * NBSG,
	    M_DEVBUF, NULL, 0, EX_NOWAIT);
d184 1
a184 1
	int s, error;
d199 1
a199 4
	error = extent_alloc(dvma_segmap, seg_len, NBSG,
	    0, EX_NOBOUNDARY, EX_NOWAIT, (u_long *)&seg_dma);
	if (error != 0)
		seg_dma = NULL;
d206 1
a206 1
	if (seg_dma != NULL) {
d246 1
a246 1
	int s, error;
d278 1
a278 5
	error = extent_free(dvma_segmap, (u_long)seg_dma, seg_len, EX_NOWAIT);

	if (error != 0)
		printf("dvma_mapout: extent_free failed\n");

@


1.8.6.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.8.6.4 2002/03/06 02:04:47 niklas Exp $	*/
@


1.7
log
@switch from private Mach derived conversion macros to m68k ones
@
text
@d1 1
a1 1
/*	$OpenBSD: dvma.c,v 1.6 1997/01/16 04:04:19 kstailey Exp $	*/
d155 1
a155 1
		panic("dvma_kvtopa: bad dmva addr=0x%x\n", kva);
d166 1
a166 1
		panic("dvma_kvtopa: bad bus type %d\n", bustype);
@


1.6
log
@all modified code can now compile with -Werror -Wall -Wstrict-prototypes
CAVEAT: turning off -O2 produces warnings about "defined but not used"
        functions from libkern.h

removed internal copy of gets() replaced with call to getsn()

fixed #ifdef ... #endif mismatch in swapgeneric.c

fixed printf() in if_ie.c that was missing an argument

fixed si.c so that it compiles

added tags to all edited files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 1
a121 1
    new_size = sun3_round_page(bytes);
d137 1
a137 1
	vm_size_t sz = sun3_round_page(size);
d196 1
a196 1
	seg_len = sun3_round_seg(seg_len);
d258 1
a258 1
	seg_len = sun3_round_seg(seg_len);
@


1.5
log
@backed out prev. netbsd merge except for smaller proc table
@
text
@d1 1
d58 3
a60 1
#include <machine/reg.h>
d63 1
a63 1
#include <machine/dvma.h>
a64 1
#include "cache.h"
d76 2
a77 1
void dvma_init()
d112 2
a113 1
caddr_t dvma_malloc(bytes)
d132 2
a133 1
void dvma_free(addr, size)
d147 2
a148 1
long dvma_kvtopa(kva, bustype)
d178 4
a181 1
caddr_t dvma_mapin(char *kva, int len)
d240 4
a243 1
void dvma_mapout(char *dma, int len)
@


1.4
log
@sync with 17-Dec-1996
@
text
@d1 1
a1 1
/*	$NetBSD: dvma.c,v 1.6 1996/12/17 21:11:23 gwr Exp $	*/
a56 1
#include <machine/control.h>
d62 1
a62 1
#include "machdep.h"
d74 1
a74 2
void
dvma_init()
d146 1
a146 1
	long mask = 0;
@


1.3
log
@sync with NetBSD -- copyright changes only
@
text
@d1 1
a1 1
/*	$NetBSD: dvma.c,v 1.5 1996/11/20 18:57:29 gwr Exp $	*/
d57 1
d63 1
a63 1
#include "cache.h"
d75 2
a76 1
void dvma_init()
d148 1
a148 1
	long mask;
@


1.2
log
@sync with 0430.
@
text
@d1 1
a1 1
/*	$NetBSD: dvma.c,v 1.4 1996/02/20 22:05:32 gwr Exp $	*/
d3 2
a4 2
/*
 * Copyright (c) 1995 Gordon W. Ross
d7 3
d18 1
a18 3
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
d20 5
a24 1
 *      This product includes software developed by Gordon W. Ross
d26 11
a36 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dvma.c,v 1.3 1995/10/10 21:37:29 gwr Exp $	*/
d59 1
a59 1
#define	NUM_DVMA_SEGS ((DVMA_SEGMAP_SIZE / NBSG) + 1)
d62 4
a65 2
/* DVMA page map managed with help from the VM system. */
vm_map_t dvma_pgmap;
d70 1
a70 1
	int size;
d73 3
a75 3
	 * Create the map used for small, permanent DVMA page
	 * allocations, such as may be needed by drivers for
	 * control structures shared with the device.
d77 13
a89 4
	dvma_pgmap = vm_map_create(pmap_kernel(),
	    DVMA_PAGEMAP_BASE, DVMA_PAGEMAP_END, TRUE);
	if (dvma_pgmap == NULL)
		panic("dvma_init: unable to create DVMA page map.");
d95 2
a96 5
	rminit(dvma_segmap,
		   DVMA_SEGMAP_SIZE,
		   DVMA_SEGMAP_BASE,
		   "dvma_segmap",
		   NUM_DVMA_SEGS);
d112 1
a112 1
    new_mem = (caddr_t) kmem_alloc(dvma_pgmap, new_size);
d114 1
a114 1
		panic("dvma_malloc: no space in dvma_pgmap");
d126 3
a128 1
	kmem_free(dvma_pgmap, (vm_offset_t)addr, (vm_size_t)size);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
