head	1.24;
access;
symbols
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.12
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2006.07.26.21.35.09;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2006.06.05.08.46.29;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.20.23.27.26;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.04.16.59.31;	author grange;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.10.21.56.11;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.18.02.09.27;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.10.00.11.14;	author nordin;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.27.03.14.51;	author bjc;	state Exp;
branches;
next	1.8;

1.8
date	97.05.29.00.05.09;	author niklas;	state Exp;
branches
	1.8.12.1;
next	1.7;

1.7
date	97.01.15.23.25.00;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.21.46.26;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.03.09.09.59;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	95.12.30.09.24.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.14.00.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches;
next	;

1.8.12.1
date	2001.05.14.21.38.36;	author niklas;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.8.12.4;

1.8.12.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.8.12.5;

1.8.12.5
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.8.12.6;

1.8.12.6
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.8.12.7;

1.8.12.7
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	1.8.12.8;

1.8.12.8
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	1.8.12.9;

1.8.12.9
date	2004.06.05.23.11.02;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.01.31.22.55.27;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@More files which have changed name or location since some time already and
are only confusing things.
@
text
@/*	$OpenBSD: uba.c,v 1.23 2006/06/05 08:46:29 miod Exp $	   */
/*	$NetBSD: uba.c,v 1.43 2000/01/24 02:40:36 matt Exp $	   */
/*
 * Copyright (c) 1996 Jonathan Stone.
 * Copyright (c) 1994, 1996 Ludd, University of Lule}, Sweden.
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uba.c	7.10 (Berkeley) 12/16/90
 *	@@(#)autoconf.c	7.20 (Berkeley) 5/9/91
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/extent.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/conf.h>
#include <sys/dkstat.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/mtpr.h>
#include <machine/nexus.h>
#include <machine/sid.h>
#include <machine/scb.h>
#include <machine/trap.h>
#include <machine/frame.h>

#include <vax/uba/ubareg.h>
#include <vax/uba/ubavar.h>

volatile int /* rbr, rcvec,*/ svec;

static	int ubasearch(struct device *, struct cfdata *, void *);
static	int ubaprint(void *, const char *);
#if 0
static	void ubastray(int);
#endif
static	void ubainitmaps(struct uba_softc *, int);

extern struct cfdriver uba_cd;

#define spluba	spl7

#if defined(DW780) || defined(DW750)

int	dw_match(struct device *, struct cfdata *, void *);

int
dw_match(parent, cf, aux)
	struct	device *parent;
	struct cfdata *cf;
	void *aux;
{
	struct sbi_attach_args *sa = (struct sbi_attach_args *)aux;

	if ((cf->cf_loc[0] != sa->nexnum) && (cf->cf_loc[0] > -1 ))
		return 0;

	/*
	 * The uba type is actually only telling where the uba 
	 * space is in nexus space.
	 */
	if ((sa->type & ~3) != NEX_UBA0)
		return 0;

	return 1;
}
#endif

#ifdef DW780
/*
 * The DW780 are directly connected to the SBI on 11/780 and 8600.
 */
void	dw780_attach(struct device *, struct device *, void *);
void	dw780_beforescan(struct uba_softc *);
void	dw780_afterscan(struct uba_softc *);
int	dw780_errchk(struct uba_softc *);
void	dw780_init(struct uba_softc *);
void	dw780_purge(struct uba_softc *, int);
void	uba_dw780int(int);
static	void ubaerror(struct uba_softc *, int *, int *);

struct	cfattach uba_sbi_ca = {
	sizeof(struct uba_softc), dw_match, dw780_attach
};

char	ubasr_bits[] = UBASR_BITS;

void
dw780_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct uba_softc *sc = (void *)self;
	struct sbi_attach_args *sa = aux;
	int ubaddr = sa->type & 3;
	int i;

	printf(": DW780\n");

	/*
	 * Fill in bus specific data.
	 */
	sc->uh_uba = (void *)sa->nexaddr;
	sc->uh_nbdp = NBDP780;
	sc->uh_nr = sa->nexnum * (parent->dv_unit + 1);
	sc->uh_beforescan = dw780_beforescan;
	sc->uh_afterscan = dw780_afterscan;
	sc->uh_errchk = dw780_errchk;
	sc->uh_ubapurge = dw780_purge;
	sc->uh_ubainit = dw780_init;
	sc->uh_type = DW780;
	sc->uh_memsize = UBAPAGES;
	sc->uh_ibase = VAX_NBPG + ubaddr * VAX_NBPG;
	sc->uh_mr = sc->uh_uba->uba_map;

	for (i = 0; i < 4; i++)
		scb_vecalloc(256 + i * 64 + sa->nexnum * 4, uba_dw780int,
		    sc->uh_dev.dv_unit, SCB_ISTACK);

	uba_attach(sc, (parent->dv_unit ? UMEMB8600(ubaddr) :
	    UMEMA8600(ubaddr)) + (UBAPAGES * VAX_NBPG));
}

void
dw780_beforescan(sc)
	struct uba_softc *sc;
{
	volatile int *hej = &sc->uh_uba->uba_sr;

	*hej = *hej;
	sc->uh_uba->uba_cr = UBACR_IFS|UBACR_BRIE;
}

void
dw780_afterscan(sc)
	struct uba_softc *sc;
{
	sc->uh_uba->uba_cr = UBACR_IFS | UBACR_BRIE |
	    UBACR_USEFIE | UBACR_SUEFIE |
	    (sc->uh_uba->uba_cr & 0x7c000000);
}

/*
 * On DW780 badaddr() in uba space sets a bit in uba_sr instead of
 * doing a machine check.
 */
int
dw780_errchk(sc)
	struct uba_softc *sc;
{
	volatile int *hej = &sc->uh_uba->uba_sr;

	if (*hej) {
		*hej = *hej;
		return 1;
	}
	return 0;
}

void
uba_dw780int(uba)
	int	uba;
{
	int	br, vec;
	struct	uba_softc *sc = uba_cd.cd_devs[uba];
	struct	uba_regs *ur = sc->uh_uba;

	br = mfpr(PR_IPL);
	vec = ur->uba_brrvr[br - 0x14];
	if (vec <= 0) {
		ubaerror(sc, &br, (int *)&vec);
		if (svec == 0)
			return;
	}
	if (cold)
		scb_fake(vec + sc->uh_ibase, br);
	else {
		struct ivec_dsp *scb_vec = (struct ivec_dsp *)((int)scb + 512 + vec * 4);
		(*scb_vec->hoppaddr)(scb_vec->pushlarg);

	}
}

void
dw780_init(sc)
	struct uba_softc *sc;
{
	sc->uh_uba->uba_cr = UBACR_ADINIT;
	sc->uh_uba->uba_cr = UBACR_IFS|UBACR_BRIE|UBACR_USEFIE|UBACR_SUEFIE;
	while ((sc->uh_uba->uba_cnfgr & UBACNFGR_UBIC) == 0)
		;
}

void
dw780_purge(sc, bdp)
	struct uba_softc *sc;
	int bdp;
{
	sc->uh_uba->uba_dpr[bdp] |= UBADPR_BNE;
}

int	ubawedgecnt = 10;
int	ubacrazy = 500;
int	zvcnt_max = 5000;	/* in 8 sec */
int	ubaerrcnt;
/*
 * This routine is called by the locore code to process a UBA
 * error on an 11/780 or 8600.	The arguments are passed
 * on the stack, and value-result (through some trickery).
 * In particular, the uvec argument is used for further
 * uba processing so the result aspect of it is very important.
 * It must not be declared register.
 */
/*ARGSUSED*/
void
ubaerror(uh, ipl, uvec)
	register struct uba_softc *uh;
	int *ipl, *uvec;
{
	struct	uba_regs *uba = uh->uh_uba;
	register int sr, s;

	if (*uvec == 0) {
		/*
		 * Declare dt as unsigned so that negative values
		 * are handled as >8 below, in case time was set back.
		 */
		u_long	dt = time.tv_sec - uh->uh_zvtime;

		uh->uh_zvtotal++;
		if (dt > 8) {
			uh->uh_zvtime = time.tv_sec;
			uh->uh_zvcnt = 0;
		}
		if (++uh->uh_zvcnt > zvcnt_max) {
			printf("%s: too many zero vectors (%d in <%d sec)\n",
				uh->uh_dev.dv_xname, uh->uh_zvcnt, (int)dt + 1);
			printf("\tIPL 0x%x\n\tcnfgr: %b	 Adapter Code: 0x%x\n",
				*ipl, uba->uba_cnfgr&(~0xff), UBACNFGR_BITS,
				uba->uba_cnfgr&0xff);
			printf("\tsr: %b\n\tdcr: %x (MIC %sOK)\n",
				uba->uba_sr, ubasr_bits, uba->uba_dcr,
				(uba->uba_dcr&0x8000000)?"":"NOT ");
			ubareset(uh->uh_dev.dv_unit);
		}
		return;
	}
	if (uba->uba_cnfgr & NEX_CFGFLT) {
		printf("%s: sbi fault sr=%b cnfgr=%b\n",
		    uh->uh_dev.dv_xname, uba->uba_sr, ubasr_bits,
		    uba->uba_cnfgr, NEXFLT_BITS);
		ubareset(uh->uh_dev.dv_unit);
		*uvec = 0;
		return;
	}
	sr = uba->uba_sr;
	s = spluba();
	printf("%s: uba error sr=%b fmer=%x fubar=%o\n", uh->uh_dev.dv_xname,
	    uba->uba_sr, ubasr_bits, uba->uba_fmer, 4*uba->uba_fubar);
	splx(s);
	uba->uba_sr = sr;
	*uvec &= UBABRRVR_DIV;
	if (++ubaerrcnt % ubawedgecnt == 0) {
		if (ubaerrcnt > ubacrazy)
			panic("uba crazy");
		printf("ERROR LIMIT ");
		ubareset(uh->uh_dev.dv_unit);
		*uvec = 0;
		return;
	}
	return;
}
#endif

#ifdef DW750
/*
 * The DW780 and DW750 are quite similar to their function from
 * a programmers point of view. Differencies are number of BDP's
 * and bus status/command registers, the latter are (partly) IPR's
 * on 750.
 */
void	dw750_attach(struct device *, struct device *, void *);
void	dw750_init(struct uba_softc *);
void	dw750_purge(struct uba_softc *, int);

struct	cfattach uba_cmi_ca = {
	sizeof(struct uba_softc), dw_match, dw750_attach
};

void
dw750_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct uba_softc *sc = (void *)self;
	struct sbi_attach_args *sa = aux;
	int ubaddr = sa->nexinfo & 1;

	printf(": DW750\n");

	/*
	 * Fill in bus specific data.
	 */
	sc->uh_uba = (void *)sa->nexaddr;
	sc->uh_nbdp = NBDP750;
	sc->uh_nr = sa->nexnum;
	sc->uh_ubapurge = dw750_purge;
	sc->uh_ubainit = dw750_init;
	sc->uh_type = DW750;
	sc->uh_memsize = UBAPAGES;
	sc->uh_mr = sc->uh_uba->uba_map;

	uba_attach(sc, UMEM750(ubaddr) + (UBAPAGES * VAX_NBPG));
}

void
dw750_init(sc)
	struct uba_softc *sc;
{
	mtpr(0, PR_IUR);
	DELAY(500000);
}

void
dw750_purge(sc, bdp)
	struct uba_softc *sc;
	int bdp;
{
	sc->uh_uba->uba_dpr[bdp] |= UBADPR_PURGE | UBADPR_NXM | UBADPR_UCE;
}
#endif

#ifdef QBA
/*
 * The Q22 bus is the main IO bus on MicroVAX II/MicroVAX III systems.
 * It has an address space of 4MB (22 address bits), therefore the name,
 * and is hardware compatible with all 16 and 18 bits Q-bus devices.
 * This driver can only handle map registers up to 1MB due to map info
 * storage, but that should be enough for normal purposes.
 */
int	qba_match(struct device *, struct cfdata *, void *);
void	qba_attach(struct device *, struct device *, void *);
void	qba_beforescan(struct uba_softc*);
void	qba_init(struct uba_softc*);

struct	cfattach uba_mainbus_ca = {
	sizeof(struct uba_softc), qba_match, qba_attach
};

int
qba_match(parent, vcf, aux)
	struct device *parent;
	struct cfdata *vcf;
	void *aux;
{
	struct	bp_conf *bp = aux;

	if (strcmp(bp->type, "uba"))
		return 0;

	return 1;
}

void
qba_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct uba_softc *sc = (void *)self;

	printf(": Q22\n");
	/*
	 * Fill in bus specific data.
	 */
/*	sc->uh_uba not used; no regs */
/*	sc->uh_nbdp is 0; Qbus has no BDP's */
/*	sc->uh_nr is 0; there can be only one! */
/*	sc->uh_afterscan; not used */
/*	sc->uh_errchk; not used */
	sc->uh_beforescan = qba_beforescan;
	sc->uh_ubainit = qba_init;
	sc->uh_type = QBA;
	sc->uh_memsize = QBAPAGES;
	/*
	 * Map in the UBA page map into kernel space. On other UBAs,
	 * the map registers are in the bus IO space.
	 */
	sc->uh_mr = (void *)vax_map_physmem(QBAMAP,
	    (QBAPAGES * sizeof(pt_entry_t)) / VAX_NBPG);

	uba_attach(sc, QIOPAGE);
}

/*
 * Called when the QBA is set up; to enable DMA access from
 * QBA devices to main memory.
 */
void
qba_beforescan(sc)
	struct uba_softc *sc;
{
	*((u_short *)(sc->uh_iopage + QIPCR)) = Q_LMEAE;
}

void
qba_init(sc)
	struct uba_softc *sc;
{
	mtpr(0, PR_IUR);
	DELAY(500000);
	qba_beforescan(sc);
}
#endif
#ifdef DW730
struct	cfattach uba_dw730_ca = {
	sizeof(struct uba_softc), dw730_match, dw730_attach
};
#endif
#if 0
/* 
 * Stray interrupt vector handler, used when nowhere else to go to.
 */
void
ubastray(arg)
	int arg;
{
	struct	callsframe *cf = FRAMEOFFSET(arg);
	struct	uba_softc *sc = uba_cd.cd_devs[arg];
	int	vektor;

	rbr = mfpr(PR_IPL);
#ifdef DW780
	if (sc->uh_type == DW780)
		vektor = svec >> 2;
	else
#endif
		vektor = (cf->ca_pc - (unsigned)&sc->uh_idsp[0]) >> 4;

	if (cold) {
#ifdef DW780
		if (sc->uh_type != DW780)
#endif
			rcvec = vektor;
	} else 
		printf("uba%d: unexpected interrupt, vector 0x%x, br 0x%x\n",
		    arg, svec, rbr);
}
#endif
/*
 * Do transfer on device argument.  The controller
 * and uba involved are implied by the device.
 * We queue for resource wait in the uba code if necessary.
 * We return 1 if the transfer was started, 0 if it was not.
 *
 * The onq argument must be zero iff the device is not on the
 * queue for this UBA.	If onq is set, the device must be at the
 * head of the queue.  In any case, if the transfer is started,
 * the device will be off the queue, and if not, it will be on.
 *
 * Drivers that allocate one BDP and hold it for some time should
 * set ud_keepbdp.  In this case um_bdp tells which BDP is allocated
 * to the controller, unless it is zero, indicating that the controller
 * does not now have a BDP.
 */
int
ubaqueue(uu, bp)
	register struct uba_unit *uu;
	struct buf *bp;
{
	register struct uba_softc *uh;
	register int s;

	uh = (void *)((struct device *)(uu->uu_softc))->dv_parent;
	s = spluba();
	/*
	 * Honor exclusive BDP use requests.
	 */
	if ((uu->uu_xclu && uh->uh_users > 0) || uh->uh_xclu)
		goto rwait;
	if (uu->uu_keepbdp) {
		/*
		 * First get just a BDP (though in fact it comes with
		 * one map register too).
		 */
		if (uu->uu_bdp == 0) {
			uu->uu_bdp = uballoc(uh, (caddr_t)0, 0,
			    UBA_NEEDBDP|UBA_CANTWAIT);
			if (uu->uu_bdp == 0)
				goto rwait;
		}
		/* now share it with this transfer */
		uu->uu_ubinfo = ubasetup(uh, bp,
		    uu->uu_bdp|UBA_HAVEBDP|UBA_CANTWAIT);
	} else
		uu->uu_ubinfo = ubasetup(uh, bp, UBA_NEEDBDP|UBA_CANTWAIT);
	if (uu->uu_ubinfo == 0)
		goto rwait;
	uh->uh_users++;
	if (uu->uu_xclu)
		uh->uh_xclu = 1;

	splx(s);
	return (1);

rwait:
	SIMPLEQ_INSERT_TAIL(&uh->uh_resq, uu, uu_resq);
	splx(s);
	return (0);
}

void
ubadone(uu)
	struct uba_unit *uu;
{
	struct uba_softc *uh = (void *)((struct device *)
	    (uu->uu_softc))->dv_parent;

	if (uu->uu_xclu)
		uh->uh_xclu = 0;
	uh->uh_users--;
	if (uu->uu_keepbdp)
		uu->uu_ubinfo &= ~BDPMASK;	/* keep BDP for misers */
	ubarelse(uh, &uu->uu_ubinfo);
}

/*
 * Allocate and setup UBA map registers, and bdp's
 * Flags says whether bdp is needed, whether the caller can't
 * wait (e.g. if the caller is at interrupt level).
 * Return value encodes map register plus page offset,
 * bdp number and number of map registers.
 */
int
ubasetup(uh, bp, flags)
	struct	uba_softc *uh;
	struct	buf *bp;
	int	flags;
{
	int npf;
	int temp;
	int reg, bdp;
	int a, o, ubinfo;
	vaddr_t addr;

	if (uh->uh_nbdp == 0)
		flags &= ~UBA_NEEDBDP;

	o = (int)bp->b_data & VAX_PGOFSET;
	npf = vax_btoc(bp->b_bcount + o) + 1;
	if (npf > UBA_MAXNMR)
		panic("uba xfer too big");
	a = spluba();

	error = extent_alloc(uh->uh_ext, npf * VAX_NBPG, VAX_NBPG, 0,
	    EX_NOBOUNDARY, (flags & UBA_CANTWAIT) ? EX_NOWAIT : EX_WAITOK,
	    (u_long *)addr);

	if (error != 0) {
		splx(a);
		return (0);
	}

	reg = vax_btoc(addr);
	if ((flags & UBA_NEED16) && reg + npf > 128) {
		/*
		 * Could hang around and try again (if we can ever succeed).
		 * Won't help any current device...
		 */
		extent_free(uh->uh_ext, (u_long)addr, npf * VAX_NBPG,
		    EX_NOWAIT);
		splx(a);
		return (0);
	}
	bdp = 0;
	if (flags & UBA_NEEDBDP) {
		while ((bdp = ffs((long)uh->uh_bdpfree)) == 0) {
			if (flags & UBA_CANTWAIT) {
				extent_free(uh->uh_ext, (u_long)addr,
				    npf * VAX_NBPG, EX_NOWAIT);
				splx(a);
				return (0);
			}
			uh->uh_bdpwant++;
			tsleep((caddr_t)&uh->uh_bdpwant, PSWP, "ubasetup", 0);
		}
		uh->uh_bdpfree &= ~(1 << (bdp-1));
	} else if (flags & UBA_HAVEBDP)
		bdp = (flags >> 28) & 0xf;
	splx(a);
	reg--;
	ubinfo = UBAI_INFO(o, reg, npf, bdp);
	temp = (bdp << 21) | UBAMR_MRV;
	if (bdp && (o & 01))
		temp |= UBAMR_BO;

	disk_reallymapin(bp, uh->uh_mr, reg, temp | PG_V);

	return (ubinfo);
}

/*
 * Non buffer setup interface... set up a buffer and call ubasetup.
 */
int
uballoc(uh, addr, bcnt, flags)
	struct	uba_softc *uh;
	caddr_t addr;
	int	bcnt, flags;
{
	struct buf ubabuf;

	ubabuf.b_data = addr;
	ubabuf.b_flags = B_BUSY;
	ubabuf.b_bcount = bcnt;
	/* that's all the fields ubasetup() needs */
	return (ubasetup(uh, &ubabuf, flags));
}
 
/*
 * Release resources on uba uban, and then unblock resource waiters.
 * The map register parameter is by value since we need to block
 * against uba resets on 11/780's.
 */
void
ubarelse(uh, amr)
	struct	uba_softc *uh;
	int	*amr;
{
	struct uba_unit *uu;
	register int bdp, reg, npf, s;
	int mr;
 
	/*
	 * Carefully see if we should release the space, since
	 * it may be released asynchronously at uba reset time.
	 */
	s = spluba();
	mr = *amr;
	if (mr == 0) {
		/*
		 * A ubareset() occurred before we got around
		 * to releasing the space... no need to bother.
		 */
		splx(s);
		return;
	}
	*amr = 0;
	bdp = UBAI_BDP(mr);
	if (bdp) {
		if (uh->uh_ubapurge)
			(*uh->uh_ubapurge)(uh, bdp);

		uh->uh_bdpfree |= 1 << (bdp-1);		/* atomic */
		if (uh->uh_bdpwant) {
			uh->uh_bdpwant = 0;
			wakeup((caddr_t)&uh->uh_bdpwant);
		}
	}
	/*
	 * Put back the registers in the resource map.
	 * The map code must not be reentered,
	 * nor can the registers be freed twice.
	 * Unblock interrupts once this is done.
	 */
	npf = UBAI_NMR(mr);
	reg = UBAI_MR(mr) + 1;
	extent_free(uh->uh_ext, reg * VAX_NBPG, npf * VAX_NBPG, EX_NOWAIT);
	splx(s);

	/*
	 * Wakeup sleepers for map registers,
	 * and also, if there are processes blocked in dgo(),
	 * give them a chance at the UNIBUS.
	 */
	if (uh->uh_mrwant) {
		uh->uh_mrwant = 0;
		wakeup((caddr_t)&uh->uh_mrwant);
	}
	while ((uu = SIMPLEQ_FIRST(&uh->uh_resq)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&uh->uh_resq, uu_resq);
		if ((*uu->uu_ready)(uu) == 0)
			break;
	}
}

void
ubainitmaps(uhp, reset)
	struct uba_softc *uhp;
	int reset;
{
	int error;

	if (uhp->uh_memsize > UBA_MAXMR)
		uhp->uh_memsize = UBA_MAXMR;
	if (reset)
		extent_destroy(uhp->uh_ext);
	uhp->uh_ext = extent_create("uba", 0, uhp->uh_memsize * VAX_NBPG,
	    M_DEVBUF, uhp->uh_extspace, EXTENT_FIXED_STORAGE_SIZE(UAMSIZ),
	    EX_NOWAIT);
	uhp->uh_bdpfree = (1 << uhp->uh_nbdp) - 1;
}

/*
 * Generate a reset on uba number uban.	 Then
 * call each device that asked to be called during attach,
 * giving it a chance to clean up so as to be able to continue.
 */
void
ubareset(uban)
	int uban;
{
	register struct uba_softc *uh = uba_cd.cd_devs[uban];
	int s, i;

	s = spluba();
	uh->uh_users = 0;
	uh->uh_zvcnt = 0;
	uh->uh_xclu = 0;
	SIMPLEQ_INIT(&uh->uh_resq);
	uh->uh_bdpwant = 0;
	uh->uh_mrwant = 0;
	ubainitmaps(uh, 1);
	wakeup((caddr_t)&uh->uh_bdpwant);
	wakeup((caddr_t)&uh->uh_mrwant);
	printf("%s: reset", uh->uh_dev.dv_xname);
	(*uh->uh_ubainit)(uh);

	for (i = 0; i < uh->uh_resno; i++)
		(*uh->uh_reset[i])(uh->uh_resarg[i]);
	printf("\n");
	splx(s);
}

#ifdef notyet
/*
 * Determine the interrupt priority of a Q-bus
 * peripheral.	The device probe routine must spl6(),
 * attempt to make the device request an interrupt,
 * delaying as necessary, then call this routine
 * before resetting the device.
 */
int
qbgetpri()
{
	int pri;

	for (pri = 0x17; pri > 0x14; ) {
		if (rcvec && rcvec != 0x200)	/* interrupted at pri */
			break;
		pri--;
		splx(pri - 1);
	}
	spl0();
	return (pri);
}
#endif

/*
 * The common attach routines:
 *   Allocates interrupt vectors.
 *   Puts correct values in uba_softc.
 *   Calls the scan routine to search for uba devices.
 */
void
uba_attach(sc, iopagephys)
	struct uba_softc *sc;
	paddr_t iopagephys;
{

	/*
	 * Set last free interrupt vector for devices with
	 * programmable interrupt vectors.  Use is to decrement
	 * this number and use result as interrupt vector.
	 */
	sc->uh_lastiv = 0x200;
	SIMPLEQ_INIT(&sc->uh_resq);

	/*
	 * Allocate place for unibus memory in virtual space.
	 */
	sc->uh_iopage = (caddr_t)vax_map_physmem(iopagephys, UBAIOPAGES);
	if (sc->uh_iopage == 0)
		return;	/* vax_map_physmem() will complain for us */
	/*
	 * Initialize the UNIBUS, by freeing the map
	 * registers and the buffered data path registers
	 */
	sc->uh_extspace = (char *)malloc(EXTENT_FIXED_STORAGE_SIZE(UAMSIZ),
	    M_DEVBUF, M_NOWAIT);
	if (sc->uh_extspace == NULL)
		panic("uba_attach");
	ubainitmaps(sc, 0);

	/*
	 * Map the first page of UNIBUS i/o space to the first page of memory
	 * for devices which will need to dma to produce an interrupt.
	 */
	*(int *)(&sc->uh_mr[0]) = UBAMR_MRV;

	if (sc->uh_beforescan)
		(*sc->uh_beforescan)(sc);
	/*
	 * Now start searching for devices.
	 */
	config_search(ubasearch,(struct device *)sc, NULL);

	if (sc->uh_afterscan)
		(*sc->uh_afterscan)(sc);
}

int
ubasearch(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
{
	struct	uba_softc *sc = (struct uba_softc *)parent;
	struct	uba_attach_args ua;
	int	i, vec, br;

	ua.ua_addr = (caddr_t)((int)sc->uh_iopage + ubdevreg(cf->cf_loc[0]));
	ua.ua_reset = NULL;

	if (badaddr(ua.ua_addr, 2) || (sc->uh_errchk ? (*sc->uh_errchk)(sc):0))
		goto forgetit;

	scb_vecref(0, 0); /* Clear vector ref */
	i = (*cf->cf_attach->ca_match) (parent, cf, &ua);

	if (sc->uh_errchk)
		if ((*sc->uh_errchk)(sc))
			goto forgetit;
	if (i == 0)
		goto forgetit;

	i = scb_vecref(&vec, &br);
	if (i == 0)
		goto fail;
	if (vec == 0)
		goto fail;
		
	scb_vecalloc(vec, ua.ua_ivec, cf->cf_unit, SCB_ISTACK);
	if (ua.ua_reset) { /* device wants ubareset */
		if (sc->uh_resno == 0) {
			sc->uh_reset = malloc(1024, M_DEVBUF, M_NOWAIT);
			if (sc->uh_reset == NULL)
				panic("ubasearch");
			sc->uh_resarg = (int *)sc->uh_reset + 128;
		}
#ifdef DIAGNOSTIC
		if (sc->uh_resno > 127) {
			printf("%s: Expand reset table, skipping reset %s%d\n",
			    sc->uh_dev.dv_xname, cf->cf_driver->cd_name,
			    cf->cf_unit);
		} else
#endif
		{
			sc->uh_resarg[sc->uh_resno] = cf->cf_unit;
			sc->uh_reset[sc->uh_resno++] = ua.ua_reset;
		}
	}
	ua.ua_br = br;
	ua.ua_cvec = vec;
	ua.ua_iaddr = cf->cf_loc[0];

	config_attach(parent, cf, &ua, ubaprint);
	return 0;

fail:
	printf("%s%d at %s csr %o %s\n",
	    cf->cf_driver->cd_name, cf->cf_unit, parent->dv_xname,
	    cf->cf_loc[0], (i ? "zero vector" : "didn't interrupt"));

forgetit:
	return 0;
}

/*
 * Print out some interesting info common to all unibus devices.
 */
int
ubaprint(aux, uba)
	void *aux;
	const char *uba;
{
	struct uba_attach_args *ua = aux;

	printf(" csr %o vec %d ipl %x", ua->ua_iaddr,
	    ua->ua_cvec & 511, ua->ua_br);
	return UNCONF;
}
@


1.23
log
@In ubareset(), be sure to destroy the uba extent before recreating it, to
avoid a diagnostic assertion failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.22 2006/01/20 23:27:26 miod Exp $	   */
@


1.22
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.21 2004/12/25 23:02:25 miod Exp $	   */
d72 1
a72 1
static	void ubainitmaps(struct uba_softc *);
d722 3
a724 2
ubainitmaps(uhp)
	register struct uba_softc *uhp;
d730 2
d757 1
a757 1
	ubainitmaps(uh);
d827 1
a827 1
	ubainitmaps(sc);
@


1.21
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.20 2004/07/07 23:10:46 deraadt Exp $	   */
d583 1
a583 1
	o = (int)bp->b_un.b_addr & VAX_PGOFSET;
d647 1
a647 1
	ubabuf.b_un.b_addr = addr;
@


1.20
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.19 2004/05/04 16:59:31 grange Exp $	   */
d714 1
a714 1
	while ((uu = uh->uh_resq.sqh_first)) {
@


1.19
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.18 2003/11/10 21:05:06 miod Exp $	   */
d920 1
a920 1
	printf(" csr %o vec %o ipl %x", ua->ua_iaddr,
@


1.18
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.17 2003/06/02 23:27:58 millert Exp $	   */
d715 1
a715 1
		SIMPLEQ_REMOVE_HEAD(&uh->uh_resq, uu, uu_resq);
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.16 2002/06/10 21:56:11 miod Exp $	   */
d424 1
a424 1
	    (QBAPAGES * sizeof(struct pte)) / VAX_NBPG);
@


1.16
log
@sleep() -> tsleep()
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.15 2002/03/14 01:26:48 millert Exp $	   */
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.14 2002/01/18 02:09:27 miod Exp $	   */
d623 1
a623 1
			sleep((caddr_t)&uh->uh_bdpwant, PSWP);
@


1.14
log
@Replace resource maps with extents.
This is completely untested due to lack of access to such hardware.
cvs: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.13 2002/01/10 00:11:14 nordin Exp $	   */
d71 2
a72 2
static	int ubasearch __P((struct device *, struct cfdata *, void *));
static	int ubaprint __P((void *, const char *));
d74 1
a74 1
static	void ubastray __P((int));
d76 1
a76 1
static	void ubainitmaps __P((struct uba_softc *));
d84 1
a84 1
int	dw_match __P((struct device *, struct cfdata *, void *));
d112 8
a119 8
void	dw780_attach __P((struct device *, struct device *, void *));
void	dw780_beforescan __P((struct uba_softc *));
void	dw780_afterscan __P((struct uba_softc *));
int	dw780_errchk __P((struct uba_softc *));
void	dw780_init __P((struct uba_softc *));
void	dw780_purge __P((struct uba_softc *, int));
void	uba_dw780int __P((int));
static	void ubaerror __P((struct uba_softc *, int *, int *));
d321 3
a323 3
void	dw750_attach __P((struct device *, struct device *, void *));
void	dw750_init __P((struct uba_softc *));
void	dw750_purge __P((struct uba_softc *, int));
d380 4
a383 4
int	qba_match __P((struct device *, struct cfdata *, void *));
void	qba_attach __P((struct device *, struct device *, void *));
void	qba_beforescan __P((struct uba_softc*));
void	qba_init __P((struct uba_softc*));
@


1.13
log
@Check result from malloc(9) when using M_NOWAIT. hugh@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.12 2001/11/06 19:53:17 miod Exp $	   */
d45 1
a45 1
#include <sys/map.h>
d582 1
d592 8
a599 7
	while ((reg = rmalloc(uh->uh_map, (long)npf)) == 0) {
		if (flags & UBA_CANTWAIT) {
			splx(a);
			return (0);
		}
		uh->uh_mrwant++;
		sleep((caddr_t)&uh->uh_mrwant, PSWP);
d601 2
d608 2
a609 1
		rmfree(uh->uh_map, (long)npf, (long)reg);
d617 2
a618 1
				rmfree(uh->uh_map, (long)npf, (long)reg);
d706 1
a706 1
	rmfree(uh->uh_map, (long)npf, (long)reg);
d729 1
d733 3
a735 1
	rminit(uhp->uh_map, (long)uhp->uh_memsize, (long)1, "uba", UAMSIZ);
d824 3
a826 3
	sc->uh_map = (struct map *)malloc((u_long)
	    (UAMSIZ * sizeof(struct map)), M_DEVBUF, M_NOWAIT);
	if (sc->uh_map == NULL)
a827 1
	bzero((caddr_t)sc->uh_map, (unsigned)(UAMSIZ * sizeof (struct map)));
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.11 2001/09/11 20:05:25 miod Exp $	   */
d817 2
d874 2
@


1.12.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.14 2002/01/18 02:09:27 miod Exp $	   */
d45 1
a45 1
#include <sys/extent.h>
a581 1
	vaddr_t addr;
d591 7
a597 8

	error = extent_alloc(uh->uh_ext, npf * VAX_NBPG, VAX_NBPG, 0,
	    EX_NOBOUNDARY, (flags & UBA_CANTWAIT) ? EX_NOWAIT : EX_WAITOK,
	    (u_long *)addr);

	if (error != 0) {
		splx(a);
		return (0);
a598 2

	reg = vax_btoc(addr);
d604 1
a604 2
		extent_free(uh->uh_ext, (u_long)addr, npf * VAX_NBPG,
		    EX_NOWAIT);
d612 1
a612 2
				extent_free(uh->uh_ext, (u_long)addr,
				    npf * VAX_NBPG, EX_NOWAIT);
d700 1
a700 1
	extent_free(uh->uh_ext, reg * VAX_NBPG, npf * VAX_NBPG, EX_NOWAIT);
a722 1
	int error;
d726 1
a726 3
	uhp->uh_ext = extent_create("uba", 0, uhp->uh_memsize * VAX_NBPG,
	    M_DEVBUF, uhp->uh_extspace, EXTENT_FIXED_STORAGE_SIZE(UAMSIZ),
	    EX_NOWAIT);
d815 3
a817 4
	sc->uh_extspace = (char *)malloc(EXTENT_FIXED_STORAGE_SIZE(UAMSIZ),
	    M_DEVBUF, M_NOWAIT);
	if (sc->uh_extspace == NULL)
		panic("uba_attach");
a871 2
			if (sc->uh_reset == NULL)
				panic("ubasearch");
@


1.12.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.12.2.1 2002/01/31 22:55:27 niklas Exp $	   */
d71 2
a72 2
static	int ubasearch(struct device *, struct cfdata *, void *);
static	int ubaprint(void *, const char *);
d74 1
a74 1
static	void ubastray(int);
d76 1
a76 1
static	void ubainitmaps(struct uba_softc *);
d84 1
a84 1
int	dw_match(struct device *, struct cfdata *, void *);
d112 8
a119 8
void	dw780_attach(struct device *, struct device *, void *);
void	dw780_beforescan(struct uba_softc *);
void	dw780_afterscan(struct uba_softc *);
int	dw780_errchk(struct uba_softc *);
void	dw780_init(struct uba_softc *);
void	dw780_purge(struct uba_softc *, int);
void	uba_dw780int(int);
static	void ubaerror(struct uba_softc *, int *, int *);
d321 3
a323 3
void	dw750_attach(struct device *, struct device *, void *);
void	dw750_init(struct uba_softc *);
void	dw750_purge(struct uba_softc *, int);
d380 4
a383 4
int	qba_match(struct device *, struct cfdata *, void *);
void	qba_attach(struct device *, struct device *, void *);
void	qba_beforescan(struct uba_softc*);
void	qba_init(struct uba_softc*);
@


1.12.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.12.2.2 2002/06/11 03:39:19 art Exp $	   */
d623 1
a623 1
			tsleep((caddr_t)&uh->uh_bdpwant, PSWP, "ubasetup", 0);
@


1.11
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.10 2001/08/25 13:33:37 hugh Exp $	   */
d55 1
a55 1
#include <vm/vm.h>
@


1.10
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.9 2000/04/27 03:14:51 bjc Exp $	   */
a55 1
#include <vm/vm_kern.h>
@


1.9
log
@sync w/netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: uba.c,v 1.8 1997/05/29 00:05:09 niklas Exp $	   */
/*	$NetBSD: uba.c,v 1.42 1999/02/02 18:37:20 ragge Exp $	   */
d204 1
a204 1
	int	br, vec, arg;
a206 1
	void	(*func) __P((int));
d218 3
a220 4
		struct ivec_dsp *scb_vec = (struct ivec_dsp *)((int)scb + 512);
		func = scb_vec[vec/4].hoppaddr;
		arg = scb_vec[vec/4].pushlarg;
		(*func)(arg);
@


1.8
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: uba.c,v 1.29 1996/10/13 03:35:24 christos Exp $	   */
/*	$NetBSD: uba.c,v 1.29 1996/10/13 03:35:24 christos Exp $	   */
d70 1
a70 1
volatile int rbr, rcvec, svec;
d72 1
a72 1
static	void ubascan __P((struct device *, void *));
d74 1
d76 1
a77 3
static	void uba_attach __P((struct uba_softc *, unsigned long));
static	int ubasetup __P((struct uba_softc *, struct buf *, int));

d79 1
a79 3
struct	cfdriver uba_cd = {
	NULL, "uba", DV_DULL, 1
};
d85 1
a85 1
int	dw_match __P((struct device *, void *, void *));
d88 1
a88 1
dw_match(parent, vcf, aux)
d90 2
a91 1
	void *vcf, *aux;
a93 1
	struct cfdata *cf = vcf;
d136 1
d153 1
a153 1
	sc->uh_iarea = (void *)scb + NBPG + ubaddr * NBPG;
d156 3
a158 6
	bcopy(&idsptch, &sc->uh_dw780, sizeof(struct ivec_dsp));
	sc->uh_dw780.pushlarg = sc->uh_dev.dv_unit;
	sc->uh_dw780.hoppaddr = uba_dw780int;
	scb->scb_nexvec[0][sa->nexnum] = scb->scb_nexvec[1][sa->nexnum]
	    = scb->scb_nexvec[2][sa->nexnum]
	    = scb->scb_nexvec[3][sa->nexnum] = &sc->uh_dw780;
d161 1
a161 1
	    UMEMA8600(ubaddr)) + (UBAPAGES * NBPG));
d170 2
a171 4
	if (sc->uh_type == DW780) {
		*hej = *hej;
		sc->uh_uba->uba_cr = UBACR_IFS|UBACR_BRIE;
	}
d178 3
a180 4
	if (sc->uh_type == DW780)
		sc->uh_uba->uba_cr = UBACR_IFS | UBACR_BRIE |
		    UBACR_USEFIE | UBACR_SUEFIE |
		    (sc->uh_uba->uba_cr & 0x7c000000);
d193 1
a193 1
	if (sc->uh_type == DW780 && *hej) {
d210 3
a212 3
	svec = ur->uba_brrvr[br - 0x14];
	if (svec <= 0) {
		ubaerror(sc, &br, (int *)&svec);
a215 1
	vec = svec >> 2;
d217 7
a223 4
		rcvec = vec;
	func = sc->uh_idsp[vec].hoppaddr;
	arg = sc->uh_idsp[vec].pushlarg;
	(*func)(arg);
d263 1
a263 1
	register sr, s;
a352 1
	sc->uh_iarea = (void *)scb + NBPG + ubaddr * NBPG;
d355 1
a355 1
	uba_attach(sc, UMEM750(ubaddr) + (UBAPAGES * NBPG));
d383 1
a383 1
int	qba_match __P((struct device *, void *, void *));
d388 1
a388 1
struct	cfattach uba_backplane_ca = {
d395 2
a396 1
	void *vcf, *aux;
a411 1
	vm_offset_t mini, maxi;
a413 2


a425 1
	sc->uh_iarea = (void *)scb + NBPG;
d430 2
a431 5
	(void)kmem_suballoc(kernel_map, &mini, &maxi,
	    QBAPAGES * sizeof(struct pte), FALSE);
	pmap_map(mini,	QBAMAP, QBAMAP + QBAPAGES * sizeof(struct pte),
	    VM_PROT_READ | VM_PROT_WRITE);
	sc->uh_mr = (void *)mini;
a455 25
#ifdef DWBUA
int	bua_match __P((struct device *, void *, void *));
void	bua_attach __P((struct device *, struct device *, void *));

struct	cfattach uba_bi_ca = {
	sizeof(struct uba_softc), bua_match, bua_attach
};

bua_beforescan(sc)
	struct uba_softc *sc;
{
	if (sc->uh_type == DWBUA)
		BUA(ubar)->bua_offset = (int)sc->uh_vec - (int)&scb[0];
}

void
bua_init(sc)
	struct uba_softc *sc;
{
	BUA(uba)->bua_csr |= BUACSR_UPI;
	/* give devices time to recover from power fail */
	DELAY(500000);
	break;
}
#endif
d461 1
d490 1
a490 1

d589 2
a590 2
	o = (int)bp->b_un.b_addr & PGOFSET;
	npf = btoc(bp->b_bcount + o) + 1;
d797 1
a797 1
	unsigned long iopagephys;
a798 2
	vm_offset_t	mini, maxi;
	extern	struct	ivec_dsp idsptch;
a808 20
	 * Create interrupt dispatchers for this uba.
	 */
#define NO_IVEC 128
	{
		vm_offset_t	iarea;
		int	i;

		iarea = kmem_alloc(kernel_map,
		    NO_IVEC * sizeof(struct ivec_dsp));
		sc->uh_idsp = (struct ivec_dsp *)iarea;

		for (i = 0; i < NO_IVEC; i++) {
			bcopy(&idsptch, &sc->uh_idsp[i],
			    sizeof(struct ivec_dsp));
			sc->uh_idsp[i].pushlarg = sc->uh_dev.dv_unit;
			sc->uh_idsp[i].hoppaddr = ubastray;
			sc->uh_iarea[i] = (unsigned int)&sc->uh_idsp[i];
		}
	}
	/*
a809 2
	 * This is done with kmem_suballoc() but after that
	 * never used in the vm system. Is it OK to do so?
d811 3
a813 4
	(void)kmem_suballoc(kernel_map, &mini, &maxi, UBAIOPAGES * NBPG, FALSE);
	pmap_map(mini, iopagephys, iopagephys + UBAIOPAGES * NBPG,
	    VM_PROT_READ|VM_PROT_WRITE);
	sc->uh_iopage = (void *)mini;
d834 1
a834 1
	config_scan(ubascan,(struct device *)sc);
d840 2
a841 2
void
ubascan(parent, match)
d843 2
a844 1
	void *match;
a845 2
	struct	device *dev = match;
	struct	cfdata *cf = dev->dv_cfdata;
d848 1
a848 1
	int	i;
d856 2
a857 2
	rcvec = 0x200;
	i = (*cf->cf_attach->ca_match) (parent, dev, &ua);
d865 4
a868 1
	if (rcvec == 0 || rcvec == 0x200)
d871 2
a872 3
	sc->uh_idsp[rcvec].hoppaddr = ua.ua_ivec;
	sc->uh_idsp[rcvec].pushlarg = dev->dv_unit;
	if (ua.ua_reset) { /* device wants ubraeset */
d879 3
a881 2
			printf("%s: Expand reset table, skipping reset %s\n",
			    sc->uh_dev.dv_xname, dev->dv_xname);
d885 1
a885 1
			sc->uh_resarg[sc->uh_resno] = dev->dv_unit;
d889 3
a891 3
	ua.ua_br = rbr;
	ua.ua_cvec = rcvec;
	ua.ua_iaddr = dev->dv_cfdata->cf_loc[0];
d893 2
a894 2
	config_attach(parent, dev, &ua, ubaprint);
	return;
d897 3
a899 3
	printf("%s at %s csr %o %s\n", dev->dv_cfdata->cf_driver->cd_name, 
	    parent->dv_xname, dev->dv_cfdata->cf_loc[0], 
	    rcvec ? "didn't interrupt\n" : "zero vector\n");
d902 1
a902 18
	free(dev, M_DEVBUF);
}

/*
 * Called when a device needs more than one interrupt vector.
 * (Like DHU11, DMF32). Argument is the device's softc, vector
 * number and a function pointer to the interrupt catcher.
 */
void
ubasetvec(dev, vec, func)
	struct	device *dev;
	int	vec;
	void	(*func) __P((int));
{
	struct	uba_softc *sc = (void *)dev->dv_parent;

	sc->uh_idsp[vec].hoppaddr = func;
	sc->uh_idsp[vec].pushlarg = dev->dv_unit;
d916 1
a916 1
	    ua->ua_cvec << 2, ua->ua_br);
@


1.8.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: uba.c,v 1.9 2000/04/27 03:14:51 bjc Exp $	   */
/*	$NetBSD: uba.c,v 1.42 1999/02/02 18:37:20 ragge Exp $	   */
d70 1
a70 1
volatile int /* rbr, rcvec,*/ svec;
d72 1
a72 1
static	int ubasearch __P((struct device *, struct cfdata *, void *));
a73 1
#if 0
a74 1
#endif
d76 3
d80 3
a82 1
extern struct cfdriver uba_cd;
d88 1
a88 1
int	dw_match __P((struct device *, struct cfdata *, void *));
d91 1
a91 1
dw_match(parent, cf, aux)
d93 1
a93 2
	struct cfdata *cf;
	void *aux;
d96 1
a138 1
	int i;
d155 1
a155 1
	sc->uh_ibase = VAX_NBPG + ubaddr * VAX_NBPG;
d158 6
a163 3
	for (i = 0; i < 4; i++)
		scb_vecalloc(256 + i * 64 + sa->nexnum * 4, uba_dw780int,
		    sc->uh_dev.dv_unit, SCB_ISTACK);
d166 1
a166 1
	    UMEMA8600(ubaddr)) + (UBAPAGES * VAX_NBPG));
d175 4
a178 2
	*hej = *hej;
	sc->uh_uba->uba_cr = UBACR_IFS|UBACR_BRIE;
d185 4
a188 3
	sc->uh_uba->uba_cr = UBACR_IFS | UBACR_BRIE |
	    UBACR_USEFIE | UBACR_SUEFIE |
	    (sc->uh_uba->uba_cr & 0x7c000000);
d201 1
a201 1
	if (*hej) {
d218 3
a220 3
	vec = ur->uba_brrvr[br - 0x14];
	if (vec <= 0) {
		ubaerror(sc, &br, (int *)&vec);
d224 1
d226 4
a229 7
		scb_fake(vec + sc->uh_ibase, br);
	else {
		struct ivec_dsp *scb_vec = (struct ivec_dsp *)((int)scb + 512);
		func = scb_vec[vec/4].hoppaddr;
		arg = scb_vec[vec/4].pushlarg;
		(*func)(arg);
	}
d269 1
a269 1
	register int sr, s;
d359 1
d362 1
a362 1
	uba_attach(sc, UMEM750(ubaddr) + (UBAPAGES * VAX_NBPG));
d390 1
a390 1
int	qba_match __P((struct device *, struct cfdata *, void *));
d395 1
a395 1
struct	cfattach uba_mainbus_ca = {
d402 1
a402 2
	struct cfdata *vcf;
	void *aux;
d418 1
d421 2
d435 1
d440 5
a444 2
	sc->uh_mr = (void *)vax_map_physmem(QBAMAP,
	    (QBAPAGES * sizeof(struct pte)) / VAX_NBPG);
d469 25
a498 1
#if 0
d527 1
a527 1
#endif
d626 2
a627 2
	o = (int)bp->b_un.b_addr & VAX_PGOFSET;
	npf = vax_btoc(bp->b_bcount + o) + 1;
d834 1
a834 1
	paddr_t iopagephys;
d836 2
d848 20
d869 2
d872 4
a875 3
	sc->uh_iopage = (caddr_t)vax_map_physmem(iopagephys, UBAIOPAGES);
	if (sc->uh_iopage == 0)
		return;	/* vax_map_physmem() will complain for us */
d896 1
a896 1
	config_search(ubasearch,(struct device *)sc, NULL);
d902 2
a903 2
int
ubasearch(parent, cf, aux)
d905 1
a905 2
	struct cfdata *cf;
	void *aux;
d907 2
d911 1
a911 1
	int	i, vec, br;
d919 2
a920 2
	scb_vecref(0, 0); /* Clear vector ref */
	i = (*cf->cf_attach->ca_match) (parent, cf, &ua);
d928 1
a928 4
	i = scb_vecref(&vec, &br);
	if (i == 0)
		goto fail;
	if (vec == 0)
d931 3
a933 2
	scb_vecalloc(vec, ua.ua_ivec, cf->cf_unit, SCB_ISTACK);
	if (ua.ua_reset) { /* device wants ubareset */
d940 2
a941 3
			printf("%s: Expand reset table, skipping reset %s%d\n",
			    sc->uh_dev.dv_xname, cf->cf_driver->cd_name,
			    cf->cf_unit);
d945 1
a945 1
			sc->uh_resarg[sc->uh_resno] = cf->cf_unit;
d949 3
a951 3
	ua.ua_br = br;
	ua.ua_cvec = vec;
	ua.ua_iaddr = cf->cf_loc[0];
d953 2
a954 2
	config_attach(parent, cf, &ua, ubaprint);
	return 0;
d957 3
a959 3
	printf("%s%d at %s csr %o %s\n",
	    cf->cf_driver->cd_name, cf->cf_unit, parent->dv_xname,
	    cf->cf_loc[0], (i ? "zero vector" : "didn't interrupt"));
d962 18
a979 1
	return 0;
d993 1
a993 1
	    ua->ua_cvec & 511, ua->ua_br);
@


1.8.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: uba.c,v 1.8.12.1 2001/05/14 21:38:36 niklas Exp $	   */
/*	$NetBSD: uba.c,v 1.43 2000/01/24 02:40:36 matt Exp $	   */
d56 1
d204 1
a204 1
	int	br, vec;
d207 1
d219 4
a222 3
		struct ivec_dsp *scb_vec = (struct ivec_dsp *)((int)scb + 512 + vec * 4);
		(*scb_vec->hoppaddr)(scb_vec->pushlarg);

@


1.8.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	   */
d55 1
a55 1
#include <uvm/uvm_extern.h>
@


1.8.12.4
log
@Merge in trunk
@
text
@d45 1
a45 1
#include <sys/extent.h>
a581 1
	vaddr_t addr;
d591 7
a597 8

	error = extent_alloc(uh->uh_ext, npf * VAX_NBPG, VAX_NBPG, 0,
	    EX_NOBOUNDARY, (flags & UBA_CANTWAIT) ? EX_NOWAIT : EX_WAITOK,
	    (u_long *)addr);

	if (error != 0) {
		splx(a);
		return (0);
a598 2

	reg = vax_btoc(addr);
d604 1
a604 2
		extent_free(uh->uh_ext, (u_long)addr, npf * VAX_NBPG,
		    EX_NOWAIT);
d612 1
a612 2
				extent_free(uh->uh_ext, (u_long)addr,
				    npf * VAX_NBPG, EX_NOWAIT);
d700 1
a700 1
	extent_free(uh->uh_ext, reg * VAX_NBPG, npf * VAX_NBPG, EX_NOWAIT);
a722 1
	int error;
d726 1
a726 3
	uhp->uh_ext = extent_create("uba", 0, uhp->uh_memsize * VAX_NBPG,
	    M_DEVBUF, uhp->uh_extspace, EXTENT_FIXED_STORAGE_SIZE(UAMSIZ),
	    EX_NOWAIT);
d815 3
a817 4
	sc->uh_extspace = (char *)malloc(EXTENT_FIXED_STORAGE_SIZE(UAMSIZ),
	    M_DEVBUF, M_NOWAIT);
	if (sc->uh_extspace == NULL)
		panic("uba_attach");
a871 2
			if (sc->uh_reset == NULL)
				panic("ubasearch");
@


1.8.12.5
log
@Merge in -current from about a week ago
@
text
@d71 2
a72 2
static	int ubasearch(struct device *, struct cfdata *, void *);
static	int ubaprint(void *, const char *);
d74 1
a74 1
static	void ubastray(int);
d76 1
a76 1
static	void ubainitmaps(struct uba_softc *);
d84 1
a84 1
int	dw_match(struct device *, struct cfdata *, void *);
d112 8
a119 8
void	dw780_attach(struct device *, struct device *, void *);
void	dw780_beforescan(struct uba_softc *);
void	dw780_afterscan(struct uba_softc *);
int	dw780_errchk(struct uba_softc *);
void	dw780_init(struct uba_softc *);
void	dw780_purge(struct uba_softc *, int);
void	uba_dw780int(int);
static	void ubaerror(struct uba_softc *, int *, int *);
d321 3
a323 3
void	dw750_attach(struct device *, struct device *, void *);
void	dw750_init(struct uba_softc *);
void	dw750_purge(struct uba_softc *, int);
d380 4
a383 4
int	qba_match(struct device *, struct cfdata *, void *);
void	qba_attach(struct device *, struct device *, void *);
void	qba_beforescan(struct uba_softc*);
void	qba_init(struct uba_softc*);
@


1.8.12.6
log
@Sync the SMP branch with 3.3
@
text
@d623 1
a623 1
			tsleep((caddr_t)&uh->uh_bdpwant, PSWP, "ubasetup", 0);
@


1.8.12.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.8.12.6 2003/03/27 23:52:20 niklas Exp $	   */
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.12.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	   */
d424 1
a424 1
	    (QBAPAGES * sizeof(pt_entry_t)) / VAX_NBPG);
@


1.8.12.9
log
@Merge with the trunk
@
text
@d715 1
a715 1
		SIMPLEQ_REMOVE_HEAD(&uh->uh_resq, uu_resq);
@


1.7
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.6
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 2
/*      $NetBSD: uba.c,v 1.22 1996/04/08 18:37:34 ragge Exp $      */

d3 2
a5 1
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
d37 1
a37 1
 *      @@(#)autoconf.c  7.20 (Berkeley) 5/9/91
d69 30
a98 1
extern int cold;
d100 6
a105 1
volatile int rbr,rcvec;
d107 14
a120 4
int	uba_match __P((struct device *, void *, void *));
void	uba_attach __P((struct device *, struct device *, void *));
void	ubascan __P((struct device *, void *));
int	ubaprint __P((void *, const char *));
d122 249
a370 10
void	ubaerror __P((int, struct uba_softc *, int *, int *,
	    struct uba_regs *));
void	ubainit __P((struct uba_softc *));
void	ubastray __P((int));
void	unifind __P((struct uba_softc *, caddr_t));
void	ubapurge __P((struct uba_ctlr *));
void	ubainitmaps __P((struct uba_softc *));
int	qbgetpri __P((void));
int	ubamem __P((int, int, int, int));
void    uba_dw780int __P((int));
d372 8
d381 15
a395 2
struct	cfdriver uba_cd = {
	NULL, "uba", DV_DULL, 1
d398 76
a473 2
struct	cfattach uba_ca = {
	sizeof(struct uba_softc), uba_match, uba_attach
d476 22
a506 1
	struct  uba_regs *ur = sc->uh_uba;
d512 1
a512 1
		vektor = ur->uba_brrvr[rbr - 0x14] >> 2;
d523 2
a524 116
		printf("uba%d: unexpected interrupt, vector %o, br %d\n",
		    arg, vektor << 2, rbr - 20);
}

/*
 * Find devices on a UNIBUS.
 * Uses per-driver routine to set <br,cvec> into <r11,r10>,
 * and then fills in the tables, with help from a per-driver
 * slave initialization routine.
 */
void
unifind(uhp0, pumem)
	struct uba_softc *uhp0;
	caddr_t pumem;
{
	register struct uba_device *ui;
	register struct uba_ctlr *um;
	register struct uba_softc *uhp = uhp0;
	volatile struct uba_regs *ubar = uhp->uh_uba;
	u_short *reg, *ap, addr;
	struct uba_driver *udp;
	int i;
	volatile extern int rbr, rcvec;

#define	ubaddr(uhp, off)    (u_short *)((int)(uhp)->uh_iopage + ubdevreg(off))
	/*
	 * Check each unibus mass storage controller.
	 * For each one which is potentially on this uba,
	 * see if it is really there, and if it is record it and
	 * then go looking for slaves.
	 */
	for (um = ubminit; (udp = um->um_driver); um++) {
		if ((um->um_ubanum != uhp->uh_dev.dv_unit &&
		    um->um_ubanum != '?') || um->um_alive)
			continue;
		addr = (u_short)(u_long)um->um_addr;
		/*
		 * use the particular address specified first,
		 * or if it is given as "0", of there is no device
		 * at that address, try all the standard addresses
		 * in the driver til we find it
		 */
	    for (ap = udp->ud_addr; addr || (addr = *ap++); addr = 0) {
		reg = ubaddr(uhp, addr);
		if (badaddr((caddr_t)reg, 2))
			continue;

#if DW780
		if (uhp->uh_type == DW780 && ubar->uba_sr) {
			ubar->uba_sr = ubar->uba_sr;
			continue;
		}
#endif
		rcvec = 0x200;
		i = (*udp->ud_probe)((caddr_t)reg, um->um_ctlr, um, uhp);
#if DW780
		if (uhp->uh_type == DW780 && ubar->uba_sr) {
			ubar->uba_sr = ubar->uba_sr;
			continue;
		}
#endif
		if (i == 0)
			continue;
		printf("%s%d at uba%d csr %o ",
		    udp->ud_mname, um->um_ctlr, uhp->uh_dev.dv_unit, addr);
		if (rcvec == 0) {
			printf("zero vector\n");
			continue;
		}
		if (rcvec == 0x200) {
			printf("didn't interrupt\n");
			continue;
		}
		printf("vec %o, ipl %x\n", rcvec << 2, rbr);
		um->um_alive = 1;
		um->um_ubanum = uhp->uh_dev.dv_unit;
		um->um_hd = uhp;
		um->um_addr = (caddr_t)reg;
		udp->ud_minfo[um->um_ctlr] = um;
		uhp->uh_idsp[rcvec].hoppaddr = um->um_intr;
		uhp->uh_idsp[rcvec].pushlarg = um->um_ctlr;
		for (ui = ubdinit; ui->ui_driver; ui++) {
			int t;

			if (ui->ui_driver != udp || ui->ui_alive ||
			    (ui->ui_ctlr != um->um_ctlr && ui->ui_ctlr != '?') ||
			    (ui->ui_ubanum != uhp->uh_dev.dv_unit &&
			    ui->ui_ubanum != '?'))
				continue;
			t = ui->ui_ctlr;
			ui->ui_ctlr = um->um_ctlr;
			if ((*udp->ud_slave)(ui, (caddr_t)reg) == 0)
				ui->ui_ctlr = t;
			else {
				ui->ui_alive = 1;
				ui->ui_ubanum = uhp->uh_dev.dv_unit;
				ui->ui_hd = uhp;
				ui->ui_addr = (caddr_t)reg;
				ui->ui_physaddr = pumem + ubdevreg(addr);
				if (ui->ui_dk && dkn < DK_NDRIVE)
					ui->ui_dk = dkn++;
				else
					ui->ui_dk = -1;
				ui->ui_mi = um;
				/* ui_type comes from driver */
				udp->ud_dinfo[ui->ui_unit] = ui;
				printf("%s%d at %s%d slave %d",
				    udp->ud_dname, ui->ui_unit,
				    udp->ud_mname, um->um_ctlr, ui->ui_slave);
				(*udp->ud_attach)(ui);
				printf("\n");
			}
		}
		break;
	    }
	}
a526 7

#ifdef DW780
char	ubasr_bits[] = UBASR_BITS;
#endif

#define	spluba	splbio		/* IPL 17 */

d534 1
a534 1
 * queue for this UBA.  If onq is set, the device must be at the
d544 3
a546 3
ubaqueue(ui, onq)
	register struct uba_device *ui;
	int onq;
a547 1
	register struct uba_ctlr *um = ui->ui_mi;
d549 1
a549 2
	register struct uba_driver *ud;
	register int s, unit;
d551 1
a551 2
	uh = uba_cd.cd_devs[um->um_ubanum];
	ud = um->um_driver;
d556 1
a556 1
	if ((ud->ud_xclu && uh->uh_users > 0) || uh->uh_xclu)
d558 1
a558 1
	if (ud->ud_keepbdp) {
d563 4
a566 4
		if (um->um_bdp == 0) {
			um->um_bdp = uballoc(um->um_ubanum,
				(caddr_t)0, 0, UBA_NEEDBDP|UBA_CANTWAIT);
			if (um->um_bdp == 0)
d570 2
a571 3
		um->um_ubinfo = ubasetup(um->um_ubanum,
			um->um_tab.b_actf->b_actf,
			um->um_bdp|UBA_HAVEBDP|UBA_CANTWAIT);
d573 2
a574 3
		um->um_ubinfo = ubasetup(um->um_ubanum,
			um->um_tab.b_actf->b_actf, UBA_NEEDBDP|UBA_CANTWAIT);
	if (um->um_ubinfo == 0)
d577 1
a577 1
	if (ud->ud_xclu)
d579 1
a580 9
	if (ui->ui_dk >= 0) {
		unit = ui->ui_dk;
		dk_busy |= 1<<unit;
		dk_xfer[unit]++;
		dk_wds[unit] += um->um_tab.b_actf->b_actf->b_bcount>>6;
	}
	if (onq)
		uh->uh_actf = ui->ui_forw;
	(*ud->ud_dgo)(um);
d582 1
d584 1
a584 8
	if (!onq) {
		ui->ui_forw = NULL;
		if (uh->uh_actf == NULL)
			uh->uh_actf = ui;
		else
			uh->uh_actl->ui_forw = ui;
		uh->uh_actl = ui;
	}
d590 2
a591 2
ubadone(um)
	struct uba_ctlr *um;
d593 2
a594 1
	struct uba_softc *uh = uba_cd.cd_devs[um->um_ubanum];
d596 1
a596 1
	if (um->um_driver->ud_xclu)
d599 3
a601 3
	if (um->um_driver->ud_keepbdp)
		um->um_ubinfo &= ~BDPMASK;	/* keep BDP for misers */
	ubarelse(um->um_ubanum, &um->um_ubinfo);
d612 2
a613 1
ubasetup(uban, bp, flags)
d615 1
a615 1
	int	uban, flags;
a616 2
	struct uba_softc *uh = uba_cd.cd_devs[uban];
	struct pte *pte, *io;
d618 1
a618 1
	int pfnum, temp;
a619 2
	unsigned v;
	struct proc *rp;
d622 1
a622 2
#ifdef DW730
	if (uh->uh_type == DW730)
d624 1
a624 5
#endif
#ifdef QBA
	if (uh->uh_type == QBA)
		flags &= ~UBA_NEEDBDP;
#endif
a666 5
	if ((bp->b_flags & B_PHYS) == 0)
		pte = (struct pte *)kvtopte(bp->b_un.b_addr);
	else {
		struct	pte *hej;
		int	i;
d668 1
a668 2
		rp = bp->b_proc;
		v = btop((u_int)bp->b_un.b_addr&0x3fffffff);
a669 32
		/*
		 * It may be better to use pmap_extract() here
		 * somewhere, but so far we do it "the hard way" :)
		 */
		if (((u_int)bp->b_un.b_addr < 0x40000000) ||
		    ((u_int)bp->b_un.b_addr > 0x7fffffff))
			hej = rp->p_vmspace->vm_pmap.pm_pcb->P0BR;
		else
			hej = rp->p_vmspace->vm_pmap.pm_pcb->P1BR;

		pte = &hej[v];
		for (i = 0; i < (npf - 1); i++) {
			if ((pte + i)->pg_pfn == 0) {
				int rv;

				rv = vm_fault(&rp->p_vmspace->vm_map,
				    (u_int)bp->b_un.b_addr + i * NBPG,
				    VM_PROT_READ, FALSE);
				if (rv)
					panic("DMA to nonexistent page");
			}
		}
	}
	io = &uh->uh_mr[reg];
	while (--npf > 0) {
		pfnum = pte->pg_pfn;
		if (pfnum == 0)
			panic("uba zero uentry");
		pte++;
		*(int *)io++ = pfnum | temp;
	}
	*(int *)io = 0;
d677 2
a678 1
uballoc(uban, addr, bcnt, flags)
d680 1
a680 1
	int	uban, bcnt, flags;
d688 1
a688 1
	return (ubasetup(uban, &ubabuf, flags));
d697 3
a699 2
ubarelse(uban, amr)
	int uban, *amr;
d701 1
a701 1
	register struct uba_softc *uh = uba_cd.cd_devs[uban];
d722 3
a724 20
		switch (uh->uh_type) {
#ifdef DWBUA
		case DWBUA:
			BUA(uh->uh_uba)->bua_dpr[bdp] |= BUADPR_PURGE;
			break;
#endif
#ifdef DW780
		case DW780:
			uh->uh_uba->uba_dpr[bdp] |= UBADPR_BNE;
			break;
#endif
#ifdef DW750
		case DW750:
			uh->uh_uba->uba_dpr[bdp] |=
			    UBADPR_PURGE|UBADPR_NXM|UBADPR_UCE;
			break;
#endif
		default:
			break;
		}
d751 4
a754 29
	while (uh->uh_actf && ubaqueue(uh->uh_actf, 1))
		;
}

void
ubapurge(um)
	register struct uba_ctlr *um;
{
	register struct uba_softc *uh = um->um_hd;
	register int bdp = UBAI_BDP(um->um_ubinfo);

	switch (uh->uh_type) {
#ifdef DWBUA
	case DWBUA:
		BUA(uh->uh_uba)->bua_dpr[bdp] |= BUADPR_PURGE;
		break;
#endif
#ifdef DW780
	case DW780:
		uh->uh_uba->uba_dpr[bdp] |= UBADPR_BNE;
		break;
#endif
#ifdef DW750
	case DW750:
		uh->uh_uba->uba_dpr[bdp] |= UBADPR_PURGE|UBADPR_NXM|UBADPR_UCE;
		break;
#endif
	default:
		break;
d766 1
a766 19
	switch (uhp->uh_type) {
#ifdef DWBUA
	case DWBUA:
		uhp->uh_bdpfree = (1<<NBDPBUA) - 1;
		break;
#endif
#ifdef DW780
	case DW780:
		uhp->uh_bdpfree = (1<<NBDP780) - 1;
		break;
#endif
#ifdef DW750
	case DW750:
		uhp->uh_bdpfree = (1<<NBDP750) - 1;
		break;
#endif
	default:
		break;
	}
d770 1
a770 1
 * Generate a reset on uba number uban.  Then
d785 1
a785 1
	uh->uh_actf = uh->uh_actl = 0;
d792 2
a793 4
	ubainit(uh);
#ifdef notyet
	ubameminit(uban);
#endif
d800 1
a800 56
/*
 * Init a uba.
 */
void
ubainit(uhp)
	struct uba_softc *uhp;
{
	volatile struct uba_regs *ur = uhp->uh_uba;

	switch (uhp->uh_type) {
#ifdef DWBUA
	case DWBUA:
		BUA(uba)->bua_csr |= BUACSR_UPI;
		/* give devices time to recover from power fail */
		DELAY(500000);
		break;
#endif
#if DW780
	case DW780:
		ur->uba_cr = UBACR_ADINIT;
		ur->uba_cr = UBACR_IFS|UBACR_BRIE|UBACR_USEFIE|UBACR_SUEFIE;
		while ((ur->uba_cnfgr & UBACNFGR_UBIC) == 0)
			;
		break;
#endif
#ifdef DW750
	case DW750:
#endif
#ifdef DW730
	case DW730:
#endif
#ifdef QBA
	case QBA:
#endif
#if DW750 || DW730 || QBA
		mtpr(0, PR_IUR);
		/* give devices time to recover from power fail */

/* THIS IS PROBABLY UNNECESSARY */
		DELAY(500000);
/* END PROBABLY UNNECESSARY */

#ifdef QBA
		/*
		 * Re-enable local memory access
		 * from the Q-bus.
		 */
		if (uhp->uh_type == QBA)
			*((u_short *)(uhp->uh_iopage + QIPCR)) = Q_LMEAE;
#endif QBA
		break;
#endif DW750 || DW730 || QBA
	}
}

#ifdef QBA
d803 1
a803 1
 * peripheral.  The device probe routine must spl6(),
a810 1
#ifdef notyet
a811 1
	extern int cvec;
a812 1
	panic("qbgetpri");
d814 1
a814 1
		if (cvec && cvec != 0x200)	/* interrupted at pri */
d819 1
a819 1
	(void) spl0();
a820 237
#else
	return 0x17;
#endif
}
#endif

#ifdef DW780
int	ubawedgecnt = 10;
int	ubacrazy = 500;
int	zvcnt_max = 5000;	/* in 8 sec */
/*
 * This routine is called by the locore code to process a UBA
 * error on an 11/780 or 8600.  The arguments are passed
 * on the stack, and value-result (through some trickery).
 * In particular, the uvec argument is used for further
 * uba processing so the result aspect of it is very important.
 * It must not be declared register.
 */
/*ARGSUSED*/
void
ubaerror(uban, uh, ipl, uvec, uba)
	register int uban;
	register struct uba_softc *uh;
	int *ipl, *uvec;
	register struct uba_regs *uba;
{
	register sr, s;

	if (*uvec == 0) {
		/*
		 * Declare dt as unsigned so that negative values
		 * are handled as >8 below, in case time was set back.
		 */
		u_long	dt = time.tv_sec - uh->uh_zvtime;

		uh->uh_zvtotal++;
		if (dt > 8) {
			uh->uh_zvtime = time.tv_sec;
			uh->uh_zvcnt = 0;
		}
		if (++uh->uh_zvcnt > zvcnt_max) {
			printf("uba%d: too many zero vectors (%d in <%d sec)\n",
				uban, uh->uh_zvcnt, (int)dt + 1);
			printf("\tIPL 0x%x\n\tcnfgr: %b  Adapter Code: 0x%x\n",
				*ipl, uba->uba_cnfgr&(~0xff), UBACNFGR_BITS,
				uba->uba_cnfgr&0xff);
			printf("\tsr: %b\n\tdcr: %x (MIC %sOK)\n",
				uba->uba_sr, ubasr_bits, uba->uba_dcr,
				(uba->uba_dcr&0x8000000)?"":"NOT ");
			ubareset(uban);
		}
		return;
	}
	if (uba->uba_cnfgr & NEX_CFGFLT) {
		printf("uba%d: sbi fault sr=%b cnfgr=%b\n",
		    uban, uba->uba_sr, ubasr_bits,
		    uba->uba_cnfgr, NEXFLT_BITS);
		ubareset(uban);
		*uvec = 0;
		return;
	}
	sr = uba->uba_sr;
	s = spluba();
	printf("uba%d: uba error sr=%b fmer=%x fubar=%o\n",
	    uban, uba->uba_sr, ubasr_bits, uba->uba_fmer, 4*uba->uba_fubar);
	splx(s);
	uba->uba_sr = sr;
	*uvec &= UBABRRVR_DIV;
	if (++uh->uh_errcnt % ubawedgecnt == 0) {
		if (uh->uh_errcnt > ubacrazy)
			panic("uba crazy");
		printf("ERROR LIMIT ");
		ubareset(uban);
		*uvec = 0;
		return;
	}
	return;
}
#endif

/*
 * Look for devices with unibus memory, allow them to configure, then disable
 * map registers as necessary.  Called during autoconfiguration and ubareset.
 * The device ubamem routine returns 0 on success, 1 on success if it is fully
 * configured (has no csr or interrupt, so doesn't need to be probed),
 * and -1 on failure.
 */
#ifdef notyet
ubameminit(uban)
{
	register struct uba_device *ui;
	register struct uba_softc *uh = uba_cd.cd_devs[uban];
	caddr_t umembase, addr;
#define	ubaoff(off)	((int)(off) & 0x1fff)

	umembase = uh->uh_iopage;
	uh->uh_lastmem = 0;
	for (ui = ubdinit; ui->ui_driver; ui++) {
		if (ui->ui_ubanum != uban && ui->ui_ubanum != '?')
			continue;
		if (ui->ui_driver->ud_ubamem) {
			/*
			 * During autoconfiguration, need to fudge ui_addr.
			 */
			addr = ui->ui_addr;
			ui->ui_addr = umembase + ubaoff(addr);
			switch ((*ui->ui_driver->ud_ubamem)(ui, uban)) {
			case 1:
				ui->ui_alive = 1;
				/* FALLTHROUGH */
			case 0:
				ui->ui_ubanum = uban;
				break;
			}
			ui->ui_addr = addr;
		}
	}
#ifdef DW780
jdhfgsjdkfhgsdjkfghak
	/*
	 * On a DW780, throw away any map registers disabled by rounding
	 * the map disable in the configuration register
	 * up to the next 8K boundary, or below the last unibus memory.
	 */
	if (uh->uh_type == DW780) {
		register i;

		i = btop(((uh->uh_lastmem + 8191) / 8192) * 8192);
		while (i)
			(void) rmget(uh->uh_map, 1, i--);
	}
#endif
}
#endif

/*
 * Allocate UNIBUS memory.  Allocates and initializes
 * sufficient mapping registers for access.  On a 780,
 * the configuration register is setup to disable UBA
 * response on DMA transfers to addresses controlled
 * by the disabled mapping registers.
 * On a DW780, should only be called from ubameminit, or in ascending order
 * from 0 with 8K-sized and -aligned addresses; freeing memory that isn't
 * the last unibus memory would free unusable map registers.
 * Doalloc is 1 to allocate, 0 to deallocate.
 */
int
ubamem(uban, addr, npg, doalloc)
	int uban, addr, npg, doalloc;
{
	register struct uba_softc *uh = uba_cd.cd_devs[uban];
	register int a;
	int s;

	a = (addr >> 9) + 1;
	s = spluba();
	if (doalloc)
		panic("uba: rmget");
/*		a = rmget(uh->uh_map, npg, a); */
	else
		rmfree(uh->uh_map, (long)npg, (long)a);
	splx(s);
	if (a) {
		register int i, *m;

		m = (int *)&uh->uh_mr[a - 1];
		for (i = 0; i < npg; i++)
			*m++ = 0;	/* All off, especially 'valid' */
		i = addr + npg * 512;
		if (doalloc && i > uh->uh_lastmem)
			uh->uh_lastmem = i;
		else if (doalloc == 0 && i == uh->uh_lastmem)
			uh->uh_lastmem = addr;
#ifdef DW780
		/*
		 * On a 780, set up the map register disable
		 * field in the configuration register.  Beware
		 * of callers that request memory ``out of order''
		 * or in sections other than 8K multiples.
		 * Ubameminit handles such requests properly, however.
		 */
		if (uh->uh_type == DW780) {
			i = uh->uh_uba->uba_cr &~ 0x7c000000;
			i |= ((uh->uh_lastmem + 8191) / 8192) << 26;
			uh->uh_uba->uba_cr = i;
		}
#endif
	}
	return (a);
}

#include "ik.h"
#include "vs.h"
#if NIK > 0 || NVS > 0
/*
 * Map a virtual address into users address space. Actually all we
 * do is turn on the user mode write protection bits for the particular
 * page of memory involved.
 */
maptouser(vaddress)
	caddr_t vaddress;
{

	kvtopte(vaddress)->pg_prot = (PG_UW >> 27);
}

unmaptouser(vaddress)
	caddr_t vaddress;
{

	kvtopte(vaddress)->pg_prot = (PG_KW >> 27);
}
#endif

#ifdef DW780
void
uba_dw780int(uba)
	int	uba;
{
	int	br, svec, vec, arg;
	struct	uba_softc *sc = uba_cd.cd_devs[uba];
	struct	uba_regs *ur = sc->uh_uba;
	void	(*func) __P((int));

	br = mfpr(PR_IPL);
	svec = ur->uba_brrvr[br - 0x14];
	if (svec < 0) {
		ubaerror(uba, sc, &br, &svec, ur);
		if (svec == 0)
			return;
	}
	vec = svec >> 2;
	if (cold)
		rcvec = vec;
	func = sc->uh_idsp[vec].hoppaddr;
	arg = sc->uh_idsp[vec].pushlarg;
	(*func)(arg);
d825 1
a825 36
 * The match routine checks which UBA adapter number it is, to
 * be sure to use correct interrupt vectors.
 */
int
uba_match(parent, vcf, aux)
	struct	device *parent;
	void *vcf, *aux;
{
	struct sbi_attach_args *sa = (struct sbi_attach_args *)aux;
	struct cfdata *cf = vcf;

	if ((cf->cf_loc[0] != sa->nexnum) && (cf->cf_loc[0] > -1 ))
		return 0;

	switch (sa->type) {
	case NEX_UBA0:
		sa->nexinfo = 0;
		break;
	case NEX_UBA1:
		sa->nexinfo = 1;
		break;
	case NEX_UBA2:
		sa->nexinfo = 2;
		break;
	case NEX_UBA3:
		sa->nexinfo = 3;
		break;
	
	default:
		return 0;
	}
	return 1;
}

/*
 * The attach routines:
d827 1
a827 1
 *   Puts correct (cpu-specific) addresses in uba_softc.
d831 3
a833 3
uba_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d835 1
a835 4
	struct sbi_attach_args *sa = (struct sbi_attach_args *)aux;
	struct uba_regs *ubar = (struct uba_regs *)sa->nexaddr;
	struct uba_softc *sc = (struct uba_softc *)self;
	vm_offset_t	min, max, ubaphys, ubaiophys;
a837 1
	printf("\n");
d839 3
a841 3
	 * Allocate place for unibus memory in virtual space.
	 * This is done with kmem_suballoc() but after that
	 * never used in the vm system. Is it OK to do so?
d843 3
a845 8
	(void)kmem_suballoc(kernel_map, &min, &max,
	    (UBAPAGES + UBAIOPAGES) * NBPG, FALSE);
	sc->uh_mem = (caddr_t)min;
	sc->uh_uba = (void*)ubar;
	sc->uh_memsize = UBAPAGES;
	sc->uh_iopage = (void *)min + (sc->uh_memsize * NBPG);
	sc->uh_iarea = (void *)scb + NBPG + sa->nexinfo * NBPG;
	sc->uh_resno = 0;
d849 1
a849 1
#define	NO_IVEC	128
a865 63

	switch (cpunumber) {
#if VAX780 || VAX8600
	case VAX_780:
	case VAX_8600:
		sc->uh_mr = (void *)ubar->uba_map;
		sc->uh_type = DW780;
		sc->uh_physuba = (struct uba_regs *)kvtophys(sa->nexaddr);
		if (parent->dv_unit == 0) {
			ubaphys = UMEMA8600(sa->nexinfo);
			ubaiophys = UMEMA8600(sa->nexinfo) + (UBAPAGES * NBPG);
		} else {
			ubaphys = UMEMB8600(sa->nexinfo);
			ubaiophys = UMEMB8600(sa->nexinfo) + (UBAPAGES * NBPG);
		}
		bcopy(&idsptch, &sc->uh_dw780, sizeof(struct ivec_dsp));
		sc->uh_dw780.pushlarg = sc->uh_dev.dv_unit;
		sc->uh_dw780.hoppaddr = uba_dw780int;
		scb->scb_nexvec[0][sa->nexnum] = scb->scb_nexvec[1][sa->nexnum]
		    = scb->scb_nexvec[2][sa->nexnum]
		    = scb->scb_nexvec[3][sa->nexnum] = &sc->uh_dw780;
		break;
#endif
#if VAX750
	case VAX_750:
		sc->uh_mr = (void *)ubar->uba_map;
		sc->uh_type = DW750;
		sc->uh_physuba = (struct uba_regs *)kvtophys(sa->nexaddr);
		ubaphys = UMEM750(sa->nexinfo);
		ubaiophys = UMEM750(sa->nexinfo) + (UBAPAGES * NBPG);
		break;
#endif
#if VAX630 || VAX410
	case VAX_78032:
		switch (cpu_type) {
#if VAX630
		case VAX_630:
			sc->uh_mr = (void *)sa->nexaddr;
			sc->uh_type = QBA;
			sc->uh_physuba = (void*)QBAMAP630;
			ubaphys = QMEM630;
			ubaiophys = QIOPAGE630;
			break;
#endif
		default:
			ubaphys = QMEM630;
			ubaiophys = QIOPAGE630;
		};
		break;
#endif
#if VAX650
	case VAX_650:
		sc->uh_mr = (void *)sa->nexaddr;
		sc->uh_type = QBA;
		sc->uh_physuba = (void*)QBAMAP630; /* XXX */
		ubaphys = QMEM630; /* XXX */
		ubaiophys = QIOPAGE630; /* XXX */
		break;
#endif
	default:
		printf("Bad luck, this cputype does not support UBA's\n");
		return;
	};
d867 3
a869 1
	 * Map uba space in kernel virtual; especially i/o space.
d871 2
a872 1
	pmap_map(min, ubaphys, ubaphys + (UBAPAGES * NBPG),
d874 1
a874 7
	pmap_map(min + (UBAPAGES * NBPG), ubaiophys, ubaiophys + 
	    (UBAIOPAGES * NBPG), VM_PROT_READ|VM_PROT_WRITE);
#if VAX630 || VAX650
	/* Enable access to local memory. */
	if (cpu_type == VAX_630 || cpunumber == VAX_650)
		*((u_short *)(sc->uh_iopage + QIPCR)) = Q_LMEAE;
#endif
a884 25
	 * Set last free interrupt vector for devices with
	 * programmable interrupt vectors.  Use is to decrement
	 * this number and use result as interrupt vector.
	 */
	sc->uh_lastiv = 0x200;

#ifdef DWBUA
        if (sc->uh_type == DWBUA)
                BUA(ubar)->bua_offset = (int)sc->uh_vec - (int)&scb[0];
#endif

#ifdef DW780
        if (sc->uh_type == DW780) {
                ubar->uba_sr = ubar->uba_sr;
                ubar->uba_cr = UBACR_IFS|UBACR_BRIE;
        }
#endif
#ifdef notyet
	/*
	 * First configure devices that have unibus memory,
	 * allowing them to allocate the correct map registers.
	 */
	ubameminit(uhp->uh_dev.dv_unit);
#endif
	/*
d886 1
a886 2
	 * for devices which will need to dma output to produce an interrupt.
	 * ??? - Why? This is rpb page... /ragge
d890 2
d895 1
a895 9
	unifind(sc, (caddr_t)ubaiophys);/* Some devices are not yet converted */
	config_scan(ubascan,self);

#ifdef DW780
	if (sc->uh_type == DW780)
		ubar->uba_cr = UBACR_IFS | UBACR_BRIE |
		    UBACR_USEFIE | UBACR_SUEFIE |
		    (ubar->uba_cr & 0x7c000000);
#endif
d897 2
a908 1
	volatile struct	uba_regs *ubar = sc->uh_uba;
d912 1
a912 1
	ua.ua_addr = (caddr_t)ubaddr(sc, cf->cf_loc[0]);
d915 1
a915 1
	if (badaddr(ua.ua_addr, 2))
a917 6
#ifdef DW780
	if (sc->uh_type == DW780 && ubar->uba_sr) {
	        ubar->uba_sr = ubar->uba_sr;
	        goto forgetit;
	}
#endif
d921 3
a923 6
#ifdef DW780
	if (sc->uh_type == DW780 && ubar->uba_sr) {
	        ubar->uba_sr = ubar->uba_sr;
	        goto forgetit;
	}
#endif
d932 1
a932 1
	if (ua.ua_reset) { /* device wants ubaeset */
d935 11
a945 1
			sc->uh_resarg = malloc(256, M_DEVBUF, M_NOWAIT);
a946 2
		sc->uh_resarg[sc->uh_resno] = dev->dv_unit;
		sc->uh_reset[sc->uh_resno++] = ua.ua_reset;
@


1.5
log
@sync w/ 0430
@
text
@d76 1
a76 1
int	ubaprint __P((void *, char *));
d1270 1
a1270 1
	char *uba;
@


1.4
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@d1 1
a1 1
/*      $NetBSD: uba.c,v 1.12 1995/12/28 19:17:07 thorpej Exp $      */
d40 25
a64 25
#include "sys/param.h"
#include "sys/types.h"
#include "sys/time.h"
#include "sys/systm.h"
#include "sys/map.h"
#include "sys/buf.h"
#include "sys/proc.h"
#include "sys/user.h"
#include "sys/conf.h"
#include "sys/dkstat.h"
#include "sys/kernel.h"
#include "sys/malloc.h"
#include "sys/device.h"

#include "vm/vm.h"
#include "vm/vm_kern.h"

#include "machine/pte.h"
#include "machine/cpu.h"
#include "machine/mtpr.h"
#include "machine/nexus.h"
#include "machine/sid.h"
#include "machine/scb.h"
#include "machine/trap.h"
#include "machine/frame.h"
d66 2
a67 2
#include "ubareg.h"
#include "ubavar.h"
d77 11
d89 3
a91 3
struct	cfdriver ubacd = {
	NULL, "uba", uba_match, uba_attach, DV_DULL,
	sizeof(struct uba_softc), 1
d94 3
a97 26
#ifdef 0
/*
 * Mark addresses starting at "addr" and continuing
 * "size" bytes as allocated in the map "ualloc".
 * Warn if the new allocation overlaps a previous allocation.
 */
static
csralloc(ualloc, addr, size)
	caddr_t ualloc;
	u_short addr;
	register int size;
{
	register caddr_t p;
	int warned = 0;

	p = &ualloc[ubdevreg(addr+size)];
	while (--size >= 0) {
		if (*--p && !warned) {
			printf(
	"WARNING: device registers overlap those for a previous device!\n");
			warned = 1;
		}
		*p = 1;
	}
}
#endif
d99 1
a99 2
 * Stray interrupt vector handler, used when nowhere else to 
 * go to.
d106 2
a107 1
	struct	uba_softc *sc = ubacd.cd_devs[arg];
d110 7
a116 1
	vektor = (cf->ca_pc - (unsigned)&sc->uh_idsp[0]) >> 4;
d118 8
a125 7
	if(cold){
		rbr = mfpr(PR_IPL);
		rcvec = vektor;
	} else {
		printf("uba%d: unexpected interrupt, vector %o, level %d",
		    arg, vektor << 2, mfpr(PR_IPL));
	}
d134 1
a134 1

d142 1
a145 2
	caddr_t ualloc;
	volatile extern int br, cvec;
a146 22
#if DW780 || DWBUA
	struct uba_regs *vubp = uhp->uh_uba;
#endif
#if 0
	/*
	 * Initialize the UNIBUS, by freeing the map
	 * registers and the buffered data path registers
	 */
	uhp->uh_map = (struct map *)
		malloc((u_long)(UAMSIZ * sizeof (struct map)), M_DEVBUF,
		    M_NOWAIT);
	if (uhp->uh_map == 0)
		panic("no mem for unibus map");
	bzero((caddr_t)uhp->uh_map, (unsigned)(UAMSIZ * sizeof (struct map)));
	ubainitmaps(uhp);

	/*
	 * Set last free interrupt vector for devices with
	 * programmable interrupt vectors.  Use is to decrement
	 * this number and use result as interrupt vector.
	 */
	uhp->uh_lastiv = 0x200;
a147 40
#ifdef DWBUA
	if (uhp->uh_type == DWBUA)
		BUA(vubp)->bua_offset = (int)uhp->uh_vec - (int)&scb[0];
#endif

#ifdef DW780
	if (uhp->uh_type == DW780) {
		vubp->uba_sr = vubp->uba_sr;
		vubp->uba_cr = UBACR_IFS|UBACR_BRIE;
	}
#endif
	/*
	 * First configure devices that have unibus memory,
	 * allowing them to allocate the correct map registers.
	 */
	ubameminit(uhp->uh_dev.dv_unit);
	/*
	 * Grab some memory to record the umem address space we allocate,
	 * so we can be sure not to place two devices at the same address.
	 *
	 * We could use just 1/8 of this (we only want a 1 bit flag) but
	 * we are going to give it back anyway, and that would make the
	 * code here bigger (which we can't give back), so ...
	 *
	 * One day, someone will make a unibus with something other than
	 * an 8K i/o address space, & screw this totally.
	 */
	ualloc = (caddr_t)malloc((u_long)(8 * 1024), M_TEMP, M_NOWAIT);
	if (ualloc == (caddr_t)0)
		panic("no mem for unifind");
	bzero(ualloc, 8*1024);

	/*
	 * Map the first page of UNIBUS i/o
	 * space to the first page of memory
	 * for devices which will need to dma
	 * output to produce an interrupt.
	 */
	*(int *)(&uhp->uh_mr[0]) = UBAMR_MRV;
#endif
d155 3
a157 3
	for (um = ubminit; udp = um->um_driver; um++) {
		if (um->um_ubanum != uhp->uh_dev.dv_unit &&
		    um->um_ubanum != '?' || um->um_alive)
a166 4
#if 0
		if (ualloc[ubdevreg(addr)])
			continue;
#endif
a167 1

d171 3
a173 3
#ifdef DW780
		if (uhp->uh_type == DW780 && vubp->uba_sr) {
			vubp->uba_sr = vubp->uba_sr;
d178 4
a181 4
		i = (*udp->ud_probe)(reg, um->um_ctlr, um);
#ifdef DW780
		if (uhp->uh_type == DW780 && vubp->uba_sr) {
			vubp->uba_sr = vubp->uba_sr;
a197 3
#if 0
		csralloc(ualloc, addr, i);
#endif
d209 3
a211 3
			    ui->ui_ctlr != um->um_ctlr && ui->ui_ctlr != '?' ||
			    ui->ui_ubanum != uhp->uh_dev.dv_unit &&
			    ui->ui_ubanum != '?')
d215 1
a215 1
			if ((*udp->ud_slave)(ui, reg) == 0)
a239 3
#if 0
	free(ualloc, M_TEMP);
#endif
d265 1
d275 1
a275 1
	uh = ubacd.cd_devs[um->um_ubanum];
d281 1
a281 1
	if (ud->ud_xclu && uh->uh_users > 0 || uh->uh_xclu)
d330 1
d334 1
a334 1
	struct uba_softc *uh = ubacd.cd_devs[um->um_ubanum];
d351 1
d356 1
a356 1
	struct uba_softc *uh = ubacd.cd_devs[uban];
d418 2
a419 1
		u_int *hej, i;
d434 1
a434 1
		pte = (struct pte *)&hej[v];
d462 1
d481 1
d485 1
a485 1
	register struct uba_softc *uh = ubacd.cd_devs[uban];
a512 1
sdjhfgsadjkfhgasj
d556 1
d584 1
d615 1
a615 1
 * call each device in the character device table,
d618 1
d622 2
a623 3
	register struct cdevsw *cdp;
	register struct uba_softc *uh = ubacd.cd_devs[uban];
	int s;
d635 1
a635 1
	printf("uba%d: reset", uban);
d640 2
a641 12
	/* XXX - ???
	 * Intressant, vi m}ste l|sa det h{r med ubareset() p} n}t smart
	 * s{tt. En l{nkad lista som s{tts upp vid autoconfiggen? Kanske.
	 * N{r anv{nds dom? Jag vet faktiskt inte; det verkar vara en
	 * ren sm|rja den gamla koden. F}r peturba lite mer docs...
	 * 950428/Ragge
	 */
	udareset(0); /* XXX */
/*	for (cdp = cdevsw; cdp < cdevsw + nchrdev; cdp++)
		(*cdp->d_reset)(uban); 
	ifubareset(uban);
 */
d647 1
a647 6
 * Init a uba.  This is called with a pointer
 * rather than a virtual address since it is called
 * by code which runs with memory mapping disabled.
 * In these cases we really don't need the interrupts
 * enabled, but since we run with ipl high, we don't care
 * if they are, they will never happen anyways.
d653 2
d663 1
a663 1
#ifdef DW780
d665 3
a667 3
		uba->uba_cr = UBACR_ADINIT;
		uba->uba_cr = UBACR_IFS|UBACR_BRIE|UBACR_USEFIE|UBACR_SUEFIE;
		while ((uba->uba_cnfgr & UBACNFGR_UBIC) == 0)
d709 1
d712 1
a716 1
#if 0
d725 2
d744 1
d748 1
a748 1
	int ipl, uvec;
d753 1
a753 1
	if (uvec == 0) {
d767 1
a767 1
				uban, uh->uh_zvcnt, dt + 1);
d769 1
a769 1
				ipl, uba->uba_cnfgr&(~0xff), UBACNFGR_BITS,
d783 1
a783 1
		uvec = 0;
d792 1
a792 1
	uvec &= UBABRRVR_DIV;
d798 1
a798 1
		uvec = 0;
d816 1
a816 1
	register struct uba_softc *uh = ubacd.cd_devs[uban];
a859 5
rmget(){
	showstate(curproc);
	panic("rmget() not implemented. (in uba.c)");
}

d871 1
d875 1
a875 1
	register struct uba_softc *uh = ubacd.cd_devs[uban];
d882 2
a883 1
		a = rmget(uh->uh_map, npg, a);
d939 4
a942 1
resuba()
d944 18
a961 2
	showstate(curproc);
	panic("resuba");
d963 1
d965 4
d1000 6
d1015 1
a1015 4
#if DW780 || DWBUA
	struct uba_regs *vubp = sc->uh_uba;
#endif
	void ubascan();
d1030 1
a1036 1
		extern	struct	ivec_dsp idsptch;
d1046 1
a1046 1
			sc->uh_idsp[i].pushlarg = sa->nexinfo;
d1053 21
d1095 3
d1110 3
d1143 2
a1144 2
        if (uhp->uh_type == DWBUA)
                BUA(vubp)->bua_offset = (int)uhp->uh_vec - (int)&scb[0];
d1148 3
a1150 3
        if (uhp->uh_type == DW780) {
                vubp->uba_sr = vubp->uba_sr;
                vubp->uba_cr = UBACR_IFS|UBACR_BRIE;
d1170 1
a1170 1
	unifind(sc, ubaiophys);	/* Some devices are not yet converted */
d1174 2
a1175 2
	if (uhp->uh_type == DW780)
		uhp->uh_uba->uba_cr = UBACR_IFS | UBACR_BRIE |
d1177 1
a1177 1
		    (uhp->uh_uba->uba_cr & 0x7c000000);
d1190 1
d1195 1
d1201 3
a1203 3
	if (uhp->uh_type == DW780 && vubp->uba_sr) {
	        vubp->uba_sr = vubp->uba_sr;
	        continue;
d1207 1
a1207 1
	i = (*cf->cf_driver->cd_match) (parent, dev, &ua);
d1210 3
a1212 3
	if (uhp->uh_type == DW780 && vubp->uba_sr) {
	        vubp->uba_sr = vubp->uba_sr;
	        continue;
d1222 9
a1230 1
	sc->uh_idsp[rcvec].pushlarg = ua.ua_iarg;
d1240 1
a1240 1
	    parent->dv_xname, dev->dv_cfdata->cf_loc[0] << 2, 
d1247 20
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*      $NetBSD: uba.c,v 1.11 1995/12/13 19:02:57 ragge Exp $      */
a68 1
int dkn;
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*      $NetBSD: uba.c,v 1.10 1995/12/01 19:22:56 ragge Exp $      */
d1135 9
d1152 1
a1152 1
#if VAX630
d1154 1
a1154 1
	if (cpu_type == VAX_630)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: uba.c,v 1.8 1995/06/16 15:26:11 ragge Exp $      */
a39 2
 /* All bugs are subject to removal without further notice */

d54 3
d62 4
a65 4
#if VAX630
#include "machine/uvaxII.h"
#endif
#include "uba.h"
a68 2
int	(*vekmatris[NUBA][128])();
int	interinfo[NUBA][128];
a70 1
struct uba_hd uba_hd[NUBA];
a71 2
/* F|r att f} genom kompilatorn :( Nollpekare f|r interrupt... */
int cvec=0;
a72 6
#if VAX630 || VAX410
extern struct uvaxIIcpu *uvaxIIcpu_ptr;
#endif
#if VAX630
extern struct ka630clock *ka630clk_ptr;
#endif
d74 12
d110 4
a113 4

/*
 * Make an IO register area accessible at physical address physa
 * by mapping kernel ptes starting at pte.
d115 3
a117 4
ioaccess(physa, pte, size)
	u_int physa;
	u_int *pte;
	u_int size;
d119 3
a121 2
	u_int i = (size>>PG_SHIFT);
	u_int v = (physa>>PG_SHIFT);
d123 1
a123 7
	do {
		*pte = PG_V|PG_KW|v;
		pte++;
		v++;
	} while (--i > 0);
	mtpr(0, PR_TBIA);
}
a124 13
/*
 * General uba interrupt handler.
 */
ubainterrupt(level, uba,vektor){
/*printf("ubainterrupt: level %x, uba %x, vektor %x\n",level, uba,vektor); */
	(*vekmatris[uba][vektor])(vektor,level,uba,interinfo[uba][vektor]);
}

/* 
 * Stray interrupt vector handler, used when nowhere else to 
 * go to.
 */
ubastray(vektor, level,uba){
d126 2
a127 2
		rbr=level;
		rcvec=vektor;
d129 2
a130 2
	printf("uba%d: unexpected interrupt at vector %d on level %d",
		uba, vektor, level);
a138 3
 *
 * Changed this ugly written code assuming special registers
 * from the C compiler :( 940516/ragge
d142 1
a142 1
	struct uba_hd *uhp0;
d147 1
a147 1
	register struct uba_hd *uhp = uhp0;
d150 1
a150 1
	int i, (*ivec)();
d157 1
a157 1

a170 15
	 * Initialize space for the UNIBUS interrupt vectors.
	 * On the 8600, can't use first slot in UNIvec
	 * (the vectors for the second SBI overlap it);
	 * move each set of vectors forward.
	 */
#if	VAX8600
	if (cpu == VAX_8600)
		uhp->uh_vec = UNIvec[numuba + 1];
	else
#endif
		uhp->Nuh_vec = vekmatris[numuba];
	for (i = 0; i < 128; i++)
		uhp->Nuh_vec[i] = ubastray;

	/*
d192 1
a192 1
	ubameminit(numuba);
d216 1
a216 1

d225 2
a226 2
		if (um->um_ubanum != numuba && um->um_ubanum != '?' ||
		    um->um_alive)
d236 1
a236 1

d239 1
a250 1
		cvec = 0x200;
d262 1
a262 1
		    udp->ud_mname, um->um_ctlr, numuba, addr);
d271 2
a272 2
		interinfo[numuba][rcvec]=um->um_ctlr;
		printf("vec %o, ipl %x\n", rcvec, rbr);
d274 1
d276 1
a276 1
		um->um_ubanum = numuba;
d280 2
a281 1
		uhp->Nuh_vec[rcvec] = um->um_intr;
d287 2
a288 1
			    ui->ui_ubanum != numuba && ui->ui_ubanum != '?')
d296 1
a296 1
				ui->ui_ubanum = numuba;
d317 2
a318 65
	/*
	 * Now look for non-mass storage peripherals.
	 */
	for (ui = ubdinit; udp = ui->ui_driver; ui++) {
		if (ui->ui_ubanum != numuba && ui->ui_ubanum != '?' ||
		    ui->ui_alive || ui->ui_slave != -1)
			continue;
		addr = (u_short)(u_long)ui->ui_addr;

	    for (ap = udp->ud_addr; addr || (addr = *ap++); addr = 0) {
		
		if (ualloc[ubdevreg(addr)])
			continue;
		reg = ubaddr(uhp, addr);
		if (badaddr((caddr_t)reg, 2))
			continue;
#ifdef DW780
		if (uhp->uh_type == DW780 && vubp->uba_sr) {
			vubp->uba_sr = vubp->uba_sr;
			continue;
		}
#endif
		rcvec = 0x200;
		cvec = 0x200;
		i = (*udp->ud_probe)(reg, ui);
#ifdef DW780
		if (uhp->uh_type == DW780 && vubp->uba_sr) {
			vubp->uba_sr = vubp->uba_sr;
			continue;
		}
#endif
		if (i == 0)
			continue;
		printf("%s%d at uba%d csr %o ",
		    ui->ui_driver->ud_dname, ui->ui_unit, numuba, addr);
		if (rcvec == 0) {
			printf("zero vector\n");
			continue;
		}
		if (rcvec == 0x200) {
			printf("didn't interrupt\n");
			continue;
		}
		interinfo[numuba][rcvec]=ui->ui_unit;
		printf("vec %o, ipl %x\n", rcvec, rbr);
		csralloc(ualloc, addr, i);
		ui->ui_hd = uhp;
		uhp->Nuh_vec[rcvec] = ui->ui_intr;
		ui->ui_alive = 1;
		ui->ui_ubanum = numuba;
		ui->ui_addr = (caddr_t)reg;
		ui->ui_physaddr = pumem + ubdevreg(addr);
		ui->ui_dk = -1;
		/* ui_type comes from driver */
		udp->ud_dinfo[ui->ui_unit] = ui;
		(*udp->ud_attach)(ui);
		break;
	    }
	}

#ifdef DW780
	if (uhp->uh_type == DW780)
		uhp->uh_uba->uba_cr = UBACR_IFS | UBACR_BRIE |
		    UBACR_USEFIE | UBACR_SUEFIE |
		    (uhp->uh_uba->uba_cr & 0x7c000000);
a319 28
	numuba++;

#ifdef	AUTO_DEBUG
	printf("Unibus allocation map");
	for (i = 0; i < 8*1024; ) {
		register n, m;

		if ((i % 128) == 0) {
			printf("\n%6o:", i);
			for (n = 0; n < 128; n++)
				if (ualloc[i+n])
					break;
			if (n == 128) {
				i += 128;
				continue;
			}
		}

		for (n = m = 0; n < 16; n++) {
			m <<= 1;
			m |= ualloc[i++];
		}

		printf(" %4x", m);
	}
	printf("\n");
#endif
	free(ualloc, M_TEMP);
d350 1
a350 1
	register struct uba_hd *uh;
d354 1
a354 1
	uh = &uba_hd[um->um_ubanum];
d410 1
a410 1
	register struct uba_ctlr *um;
d412 1
a412 1
	register struct uba_hd *uh = &uba_hd[um->um_ubanum];
d429 5
a433 2
ubasetup(int uban,struct buf *bp,int flags) {
	struct uba_hd *uh = &uba_hd[uban];
d494 15
a508 18
	else if (bp->b_flags & B_PAGET) {
		panic("ubasetup: B_PAGET");
	} else {
		if( bp->b_flags&B_DIRTY){
			rp=&pageproc[2];
			panic("ubasetup: B_DIRTY");
		} else {
			rp =bp->b_proc;
		}
		v = vax_btop((u_int)bp->b_un.b_addr&0x3fffffff);
		if (bp->b_flags & B_UAREA){
			panic("ubasetup: B_UAREA");
		} else {
/*
 * It may be better to use pmap_extract() here somewhere,
 * but so far we do it "the hard way" :)
 */
			u_int *hej;
d510 10
a519 5
			if(((u_int)bp->b_un.b_addr<0x40000000)||
				((u_int)bp->b_un.b_addr>0x7fffffff)){
				hej=rp->p_vmspace->vm_pmap.pm_pcb->P0BR;
			} else {
				hej=rp->p_vmspace->vm_pmap.pm_pcb->P1BR;
a520 1
			pte=(struct pte*)&hej[v];
d538 4
a541 1
uballoc(int uban,caddr_t addr,int bcnt,int flags) {
d557 1
a557 1
	int *amr;
d559 1
a559 1
	register struct uba_hd *uh = &uba_hd[uban];
d634 1
a634 1
	register struct uba_hd *uh = um->um_hd;
d659 1
a659 1
	register struct uba_hd *uhp;
d695 1
a695 1
	register struct uba_hd *uh = &uba_hd[uban];
d709 2
a710 1
	ubainit(uh->uh_uba);
d712 9
a720 6
/* XXX Intressant, vi m}ste l|sa det h{r med ubareset() p} n}t smart
 *     s{tt. En l{nkad lista som s{tts upp vid autoconfiggen? Kanske.
 *     N{r anv{nds dom? Jag vet faktiskt inte; det verkar vara en
 *     ren sm|rja den gamla koden. F}r peturba lite mer docs...
 *     950428/Ragge
 */
a735 1
 * SHOULD GET POINTER TO UBA_HD INSTEAD OF UBA.
d737 3
a739 2
ubainit(uba)
	register struct uba_regs *uba;
a740 20
	register struct uba_hd *uhp;
#ifdef QBA
	int isphys = 0;
#endif

	for (uhp = uba_hd; uhp < uba_hd + numuba; uhp++) {
		if (uhp->uh_uba == uba)
			break;
		if (uhp->uh_physuba == uba) {
#ifdef QBA
			isphys++;
#endif
			break;
		}
	}
	if (uhp >= uba_hd + numuba) {
		printf("init unknown uba\n");
		return;
	}

d746 1
a746 1
		waitabit(500);
d769 1
a769 1
#if 0
d771 1
a771 1
		waitabit(50);
d773 1
a773 1
#endif
d779 2
a780 6
		if (uhp->uh_type == QBA) {
			if (isphys)
				*((char *)QIOPAGE630 + QIPCR) = Q_LMEAE;
			else
				*(uhp->uh_iopage + QIPCR) = Q_LMEAE;
		}
d800 2
d810 1
d829 1
a829 1
	register struct uba_hd *uh;
d894 1
d898 2
a899 2
	register struct uba_hd *uh = &uba_hd[uban];
	caddr_t umembase = Tumem(uban) + 0x3e000, addr;
d902 1
d934 1
a934 1
		i = vax_btop(((uh->uh_lastmem + 8191) / 8192) * 8192);
d940 1
d961 1
a961 1
	register struct uba_hd *uh = &uba_hd[uban];
d1031 1
a1031 1
uba_match(parent, cf, aux)
d1033 1
a1033 2
	struct cfdata *cf;
	void *aux;
d1035 2
a1036 3
	struct sbi_attach_args *sa=(struct sbi_attach_args *)aux;
	extern int numuba;
	int ubanr;
d1038 2
a1039 13
#if VAX630
	/*
	 * The MicroVAXII always has a single QBA.
	 */
	if (cpu_type == VAX_630)
		if (numuba == 0)
			return 1;
		else
			return 0;
#endif
	if(numuba) return 0;
	if((cf->cf_loc[0]!=sa->nexnum)&&(cf->cf_loc[0]>-1))
		return 0; /* UBA doesn't match spec's */
d1041 1
a1041 1
	switch(sa->type){
d1043 2
d1046 2
d1049 2
d1052 2
a1053 1
		return 1;
d1058 1
d1066 7
a1072 4
	struct sbi_attach_args *sa=(struct sbi_attach_args *)aux;
	extern struct uba_hd uba_hd[];
	struct uba_regs *ubar=(struct uba_regs *)sa->nexaddr;
	struct uba_hd *uhp = &uba_hd[numuba];
d1076 34
d1113 6
a1118 16
	uhp->uh_mr = (void *)ubar->uba_map;
	uhp->uh_type = DW750;
	uhp->uh_uba = (void*)ubar;
	uhp->uh_physuba = (void*)0xf20000+sa->nexnum*0x2000;
	uhp->uh_memsize = UBAPAGES;
	uhp->uh_mem = Tumem(numuba);
	uhp->uh_iopage = Tumem(numuba) + (uhp->uh_memsize * NBPG);
	ioaccess(UMEM750(numuba), UMEMmap[numuba], (UBAPAGES+UBAIOPAGES)*NBPG);
/* Now everything should be set up (I hope...) */
#ifdef notyet
	config_scan(ubascan,self);

#else
	unifind(uhp, UMEM750(numuba) + (uhp->uh_memsize * NBPG));
#endif
	break;
d1122 1
a1122 1
	switch (cpu_type) {
d1124 32
a1155 8
	case VAX_630:
		uhp->uh_mr = (void *)sa->nexaddr;
		uhp->uh_type = QBA;
		uhp->uh_uba = (void*)ubar;
		uhp->uh_physuba = (void*)QBAMAP630;
		uhp->uh_memsize = QBAPAGES;
		uhp->uh_mem = Numem;
		uhp->uh_iopage = Numem + (uhp->uh_memsize * NBPG);
d1157 6
a1162 14
		/*
		 * For the MicroVAXII, the qbus address space is not contiguous
		 * in physical address space. I also map the page that has the
		 * memory error registers and the watch chip here and init them,
		 * for want of a better place to do it.
		 */
		ioaccess(QMEM630, UMEMmap[0], QBAPAGES * NBPG);
		ioaccess(QIOPAGE630, UMEMmap[0] + QBAPAGES, UBAIOPAGES * NBPG);
		ioaccess(UVAXIICPU, UMEMmap[0] + QBAPAGES + UBAIOPAGES, NBPG);
		uvaxIIcpu_ptr =
			(struct uvaxIIcpu *)(Numem+(QBAPAGES+UBAIOPAGES)*NBPG);
		ioaccess(KA630CLK,UMEMmap[0] + QBAPAGES + UBAIOPAGES + 1,NBPG);
		ka630clk_ptr =
		    (struct ka630clock *)(Numem+(QBAPAGES+UBAIOPAGES+1)*NBPG);
d1164 4
a1167 4
		/*
		 * Clear restart and boot in progress flags in the CPMBX.
		 */
		ka630clk_ptr->cpmbx = (ka630clk_ptr->cpmbx & KA630CLK_LANG);
d1169 19
a1187 5
		/*
		 * Enable memory parity error detection and clear error bits.
		 */
		uvaxIIcpu_ptr->uvaxII_mser = (UVAXIIMSER_PEN|UVAXIIMSER_MERR|
			UVAXIIMSER_LEB);
d1189 5
a1193 8
		/*
		 * Now that QBus space is mapped, set the local memory external
		 * access enable.
		 */
		*((u_short *)(uhp->uh_iopage + QIPCR)) = Q_LMEAE;
/* Now everything should be set up (I hope...) */
#ifdef notyet
		config_scan(ubascan,self);
d1195 5
a1199 2
#else
		unifind(uhp, QIOPAGE630);
d1201 24
a1224 1
		break;
d1226 8
a1233 2
	};
	break;
d1235 2
a1236 3
	};
	numuba++;
}
d1238 8
d1247 2
d1250 4
a1253 2
struct	cfdriver ubacd=
	{ NULL, "uba", uba_match, uba_attach, DV_CPU, sizeof(struct device),1,0};
d1255 3
d1259 6
d1266 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
