head	1.15;
access;
symbols
	OPENBSD_3_9:1.14.0.10
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2006.07.26.21.35.09;	author miod;	state dead;
branches;
next	1.14;

1.14
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.18.02.09.27;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2000.04.27.03.14.52;	author bjc;	state Exp;
branches;
next	1.7;

1.7
date	97.05.29.00.05.10;	author niklas;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.01.15.23.25.01;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.06.12.08.20.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.10.00.13;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.10.01;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.05.14.21.38.40;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.7.12.5;

1.7.12.5
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	1.7.12.6;

1.7.12.6
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.01.31.22.55.27;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@More files which have changed name or location since some time already and
are only confusing things.
@
text
@/*	$OpenBSD: ubavar.h,v 1.14 2003/11/10 21:05:06 miod Exp $	*/
/*	$NetBSD: ubavar.h,v 1.21 1999/01/19 21:04:48 ragge Exp $	*/

/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ubavar.h	7.7 (Berkeley) 6/28/90
 */

/*
 * This file contains definitions related to the kernel structures
 * for dealing with the unibus adapters.
 *
 * Each uba has a uba_softc structure.
 * Each unibus controller which is not a device has a uba_ctlr structure.
 * Each unibus device has a uba_device structure.
 */

#include <sys/buf.h>
#include <sys/device.h>

#include <machine/trap.h> /* For struct ivec_dsp */
/*
 * Per-uba structure.
 *
 * This structure holds the interrupt vector for the uba,
 * and its address in physical and virtual space.  At boot time
 * we determine the devices attached to the uba's and their
 * interrupt vectors, filling in uh_vec.  We free the map
 * register and bdp resources of the uba into the structures
 * defined here.
 *
 * During normal operation, resources are allocated and returned
 * to the structures here.  We watch the number of passive releases
 * on each uba, and if the number is excessive may reset the uba.
 * 
 * When uba resources are needed and not available, or if a device
 * which can tolerate no other uba activity (rk07) gets on the bus,
 * then device drivers may have to wait to get to the bus and are
 * queued here.  It is also possible for processes to block in
 * the unibus driver in resource wait (mrwant, bdpwant); these
 * wait states are also recorded here.
 */
struct extent;
struct	uba_softc {
	struct	device uh_dev;		/* Device struct, autoconfig */
	SIMPLEQ_HEAD(, uba_unit) uh_resq;	/* resource wait chain */
	int	uh_type;		/* type of adaptor */
	struct	uba_regs *uh_uba;	/* virt addr of uba adaptor regs */
	pt_entry_t *uh_mr;		/* start of page map */
	int	uh_memsize;		/* size of uba memory, pages */
	caddr_t	uh_iopage;		/* start of uba io page */
	void	(**uh_reset)(int);	/* UBA reset function array */
	int	*uh_resarg;		/* array of ubareset args */
	int	uh_resno;		/* Number of devices to reset */
	short	uh_mrwant;		/* someone is waiting for map reg */
	short	uh_bdpwant;		/* someone awaits bdp's */
	int	uh_bdpfree;		/* free bdp's */
	int	uh_zvcnt;		/* number of recent 0 vectors */
	long	uh_zvtime;		/* time over which zvcnt accumulated */
	int	uh_zvtotal;		/* total number of 0 vectors */
	int	uh_lastiv;		/* last free interrupt vector */
	short	uh_users;		/* transient bdp use count */
	short	uh_xclu;		/* an rk07 is using this uba! */
	int	uh_lastmem;		/* limit of any unibus memory */
	struct	extent *uh_ext;		/* register free map */
	char	*uh_extspace;		/* storage space for uh_ext */
	int	(*uh_errchk)(struct uba_softc *);
	void	(*uh_beforescan)(struct uba_softc *);
	void	(*uh_afterscan)(struct uba_softc *);
	void	(*uh_ubainit)(struct uba_softc *);
	void	(*uh_ubapurge)(struct uba_softc *, int);
	short	uh_nr;			/* Unibus sequential number */
	short	uh_nbdp;		/* # of BDP's */
	int	uh_ibase;		/* Base address for vectors */
};

#define	UAMSIZ	100

/*
 * Per-controller structure.
 * The unit struct is common to both the adapter and the controller
 * to which it belongs. It is only used on controllers that handles
 * BDP's, and calls the adapter queueing subroutines.
 */
struct	uba_unit {
	SIMPLEQ_ENTRY(uba_unit) uu_resq;/* Queue while waiting for resources */
	void	*uu_softc;	/* Pointer to units softc */
	int	uu_ubinfo;	/* save unibus registers, etc */
	int	uu_bdp;		/* for controllers that hang on to bdp's */
	int    (*uu_ready)(struct uba_unit *);
	short   uu_xclu;        /* want exclusive use of bdp's */
	short   uu_keepbdp;     /* hang on to bdp's once allocated */
};

/*
 * uba_attach_args is used during autoconfiguration. It is sent
 * from ubascan() to each (possible) device.
 */
struct uba_attach_args {
	caddr_t	ua_addr;
	    /* Pointer to int routine, filled in by probe*/
	void	(*ua_ivec)(int);
	    /* UBA reset routine, filled in by probe */
	void	(*ua_reset)(int);
	int	ua_iaddr;
	int	ua_br;
	int	ua_cvec;
};

/*
 * Flags to UBA map/bdp allocation routines
 */
#define	UBA_NEEDBDP	0x01		/* transfer needs a bdp */
#define	UBA_CANTWAIT	0x02		/* don't block me */
#define	UBA_NEED16	0x04		/* need 16 bit addresses only */
#define	UBA_HAVEBDP	0x08		/* use bdp specified in high bits */

/*
 * Macros to bust return word from map allocation routines.
 * SHOULD USE STRUCTURE TO STORE UBA RESOURCE ALLOCATION:
 */
#ifdef notyet
struct ubinfo {
	long	ub_addr;	/* unibus address: mr + boff */
	int	ub_nmr;		/* number of registers, 0 if empty */
	int	ub_bdp;		/* bdp number, 0 if none */
};
#define	UBAI_MR(i)	(((i) >> 9) & 0x7ff)	/* starting map register */
#define	UBAI_BOFF(i)	((i)&0x1ff)		/* page offset */
#else
#define	UBAI_BDP(i)	((int)(((unsigned)(i)) >> 28))
#define	BDPMASK		0xf0000000
#define	UBAI_NMR(i)	((int)((i) >> 20) & 0xff)	/* max 255 (=127.5K) */
#define	UBA_MAXNMR	255
#define	UBAI_MR(i)	((int)((i) >> 9) & 0x7ff)	/* max 2047 */
#define	UBA_MAXMR	2047
#define	UBAI_BOFF(i)	((int)((i) & 0x1ff))
#define	UBAI_ADDR(i)	((int)((i) & 0xfffff))	/* uba addr (boff+mr) */
#define	UBAI_INFO(off, mr, nmr, bdp) \
	(((bdp) << 28) | ((nmr) << 20) | ((mr) << 9) | (off))
#endif

#ifndef _LOCORE
#ifdef _KERNEL
#define	ubago(ui)	ubaqueue(ui)
#define b_forw  b_hash.le_next	/* Nice to have when handling uba queues */

void	uba_attach(struct uba_softc *, unsigned long);
int	uballoc(struct uba_softc *, caddr_t, int, int);
void	ubarelse(struct uba_softc *, int *);
int	ubaqueue(struct uba_unit *, struct buf *);
void	ubadone(struct uba_unit *);
void	ubareset(int);
int	ubasetup(struct uba_softc *, struct buf *, int);

#endif /* _KERNEL */
#endif /* !_LOCORE */
@


1.14
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.13 2003/06/02 23:27:58 millert Exp $	*/
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.12 2002/03/15 01:20:04 millert Exp $	*/
d75 1
a75 1
	struct	pte *uh_mr;		/* start of page map */
@


1.12
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.11 2002/03/14 01:26:48 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.10 2002/01/18 02:09:27 miod Exp $	*/
d82 1
a82 1
	void	(**uh_reset)(int);/* UBA reset function array */
@


1.10
log
@Replace resource maps with extents.
This is completely untested due to lack of access to such hardware.
cvs: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.9 2001/08/12 12:03:03 heko Exp $	*/
d82 1
a82 1
	void	(**uh_reset) __P((int));/* UBA reset function array */
d97 5
a101 5
	int	(*uh_errchk) __P((struct uba_softc *));
	void	(*uh_beforescan) __P((struct uba_softc *));
	void	(*uh_afterscan) __P((struct uba_softc *));
	void	(*uh_ubainit) __P((struct uba_softc *));
	void	(*uh_ubapurge) __P((struct uba_softc *, int));
d120 1
a120 1
	int    (*uu_ready) __P((struct uba_unit *));
d132 1
a132 1
	void	(*ua_ivec) __P((int));
d134 1
a134 1
	void	(*ua_reset) __P((int));
d178 7
a184 7
void	uba_attach __P((struct uba_softc *, unsigned long));
int	uballoc __P((struct uba_softc *, caddr_t, int, int));
void	ubarelse __P((struct uba_softc *, int *));
int	ubaqueue __P((struct uba_unit *, struct buf *));
void	ubadone __P((struct uba_unit *));
void	ubareset __P((int));
int	ubasetup __P((struct uba_softc *, struct buf *, int));
@


1.9
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.8 2000/04/27 03:14:52 bjc Exp $	*/
d73 1
d95 2
a96 1
	struct	map *uh_map;		/* register free map */
@


1.9.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.10 2002/01/18 02:09:27 miod Exp $	*/
a72 1
struct extent;
d94 1
a94 2
	struct	extent *uh_ext;		/* register free map */
	char	*uh_extspace;		/* storage space for uh_ext */
@


1.9.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.9.4.1 2002/01/31 22:55:27 niklas Exp $	*/
d82 1
a82 1
	void	(**uh_reset)(int);	/* UBA reset function array */
d97 5
a101 5
	int	(*uh_errchk)(struct uba_softc *);
	void	(*uh_beforescan)(struct uba_softc *);
	void	(*uh_afterscan)(struct uba_softc *);
	void	(*uh_ubainit)(struct uba_softc *);
	void	(*uh_ubapurge)(struct uba_softc *, int);
d120 1
a120 1
	int    (*uu_ready)(struct uba_unit *);
d132 1
a132 1
	void	(*ua_ivec)(int);
d134 1
a134 1
	void	(*ua_reset)(int);
d178 7
a184 7
void	uba_attach(struct uba_softc *, unsigned long);
int	uballoc(struct uba_softc *, caddr_t, int, int);
void	ubarelse(struct uba_softc *, int *);
int	ubaqueue(struct uba_unit *, struct buf *);
void	ubadone(struct uba_unit *);
void	ubareset(int);
int	ubasetup(struct uba_softc *, struct buf *, int);
@


1.8
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.7 1997/05/29 00:05:10 niklas Exp $	*/
d185 1
a185 1
#endif !_LOCORE
@


1.7
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: ubavar.h,v 1.18 1996/08/20 13:38:04 ragge Exp $	*/
/*	$NetBSD: ubavar.h,v 1.18 1996/08/20 13:38:04 ragge Exp $	*/
a83 2
	struct	ivec_dsp *uh_idsp;	/* Interrupt dispatch area */
	u_int	*uh_iarea;		/* Interrupt vector array */
a99 3
#ifdef DW780
	struct	ivec_dsp uh_dw780;	/* Interrupt handles for DW780 */
#endif
d102 1
a106 4
/* given a pointer to uba_regs, find DWBUA registers */
/* this should be replaced with a union in uba_softc */
#define	BUA(uba)	((struct dwbua_regs *)(uba))

d176 1
a176 3
extern	struct cfdriver	uba_cd;

void    ubasetvec __P((struct device *, int, void (*) __P((int))));
d182 1
@


1.7.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: ubavar.h,v 1.8 2000/04/27 03:14:52 bjc Exp $	*/
/*	$NetBSD: ubavar.h,v 1.21 1999/01/19 21:04:48 ragge Exp $	*/
d84 2
d102 3
a106 1
	int	uh_ibase;		/* Base address for vectors */
d111 4
d184 3
a186 1
void	uba_attach __P((struct uba_softc *, unsigned long));
a191 1
int	ubasetup __P((struct uba_softc *, struct buf *, int));
@


1.7.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.7.12.1 2001/05/14 21:38:40 niklas Exp $	*/
d185 1
a185 1
#endif /* !_LOCORE */
@


1.7.12.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a72 1
struct extent;
d94 1
a94 2
	struct	extent *uh_ext;		/* register free map */
	char	*uh_extspace;		/* storage space for uh_ext */
@


1.7.12.4
log
@Merge in -current from about a week ago
@
text
@d82 1
a82 1
	void	(**uh_reset)(int);	/* UBA reset function array */
d97 5
a101 5
	int	(*uh_errchk)(struct uba_softc *);
	void	(*uh_beforescan)(struct uba_softc *);
	void	(*uh_afterscan)(struct uba_softc *);
	void	(*uh_ubainit)(struct uba_softc *);
	void	(*uh_ubapurge)(struct uba_softc *, int);
d120 1
a120 1
	int    (*uu_ready)(struct uba_unit *);
d132 1
a132 1
	void	(*ua_ivec)(int);
d134 1
a134 1
	void	(*ua_reset)(int);
d178 7
a184 7
void	uba_attach(struct uba_softc *, unsigned long);
int	uballoc(struct uba_softc *, caddr_t, int, int);
void	ubarelse(struct uba_softc *, int *);
int	ubaqueue(struct uba_unit *, struct buf *);
void	ubadone(struct uba_unit *);
void	ubareset(int);
int	ubasetup(struct uba_softc *, struct buf *, int);
@


1.7.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.7.12.4 2002/03/28 11:26:46 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.12.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 1
a75 1
	pt_entry_t *uh_mr;		/* start of page map */
@


1.6
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.5
log
@sync to 0611
@
text
@d1 1
a1 1
/*	$NetBSD: ubavar.h,v 1.15 1996/04/08 18:37:36 ragge Exp $	*/
d74 1
a76 1
	struct	uba_regs *uh_physuba;	/* phys addr of uba adaptor regs */
a78 1
	caddr_t	uh_mem;			/* start of uba memory address space */
a84 2
	struct	uba_device *uh_actf;	/* head of queue to transfer */
	struct	uba_device *uh_actl;	/* tail of queue to transfer */
a87 1
	int	uh_hangcnt;		/* number of ticks hung */
a90 1
	int	uh_errcnt;		/* number of errors */
a94 1
#define	UAMSIZ	100
d96 6
d103 3
d108 2
d116 12
a127 86
 * (E.g. one for each disk and tape controller, and other things
 * which use and release buffered data paths.)
 *
 * If a controller has devices attached, then there are
 * cross-referenced uba_drive structures.
 * This structure is the one which is queued in unibus resource wait,
 * and saves the information about unibus resources which are used.
 * The queue of devices waiting to transfer is also attached here.
 */
struct uba_ctlr {
	struct	uba_driver *um_driver;
	short	um_ctlr;	/* controller index in driver */
	short	um_ubanum;	/* the uba it is on */
	short	um_alive;	/* controller exists */
	void	(*um_intr) __P((int));	/* interrupt handler(s) XXX */
	caddr_t	um_addr;	/* address of device in i/o space */
	struct	uba_softc *um_hd;
/* the driver saves the prototype command here for use in its go routine */
	int	um_cmd;		/* communication to dgo() */
	int	um_ubinfo;	/* save unibus registers, etc */
	int	um_bdp;		/* for controllers that hang on to bdp's */
	struct	buf um_tab;	/* queue of devices for this controller */
};

/*
 * Per ``device'' structure.
 * (A controller has devices or uses and releases buffered data paths).
 * (Everything else is a ``device''.)
 *
 * If a controller has many drives attached, then there will
 * be several uba_device structures associated with a single uba_ctlr
 * structure.
 *
 * This structure contains all the information necessary to run
 * a unibus device such as a dz or a dh.  It also contains information
 * for slaves of unibus controllers as to which device on the slave
 * this is.  A flags field here can also be given in the system specification
 * and is used to tell which dz lines are hard wired or other device
 * specific parameters.
 */
struct uba_device {
	struct	uba_driver *ui_driver;
	short	ui_unit;	/* unit number on the system */
	short	ui_ctlr;	/* mass ctlr number; -1 if none */
	short	ui_ubanum;	/* the uba it is on */
	short	ui_slave;	/* slave on controller */
	void	(*ui_intr) __P((int));	/* interrupt handler(s) XXX */
	caddr_t	ui_addr;	/* address of device in i/o space */
	short	ui_dk;		/* if init 1 set to number for iostat */
	int	ui_flags;	/* parameter from system specification */
	short	ui_alive;	/* device exists */
	short	ui_type;	/* driver specific type information */
	caddr_t	ui_physaddr;	/* phys addr, for standalone (dump) code */
/* this is the forward link in a list of devices on a controller */
	struct	uba_device *ui_forw;
/* if the device is connected to a controller, this is the controller */
	struct	uba_ctlr *ui_mi;
	struct	uba_softc *ui_hd;
};

/*
 * Per-driver structure.
 *
 * Each unibus driver defines entries for a set of routines
 * as well as an array of types which are acceptable to it.
 * These are used at boot time by the configuration program.
 */
struct uba_driver {
	    /* see if a driver is really there XXX*/
	int	(*ud_probe) __P((caddr_t, int, struct uba_ctlr *,
	    struct  uba_softc *));
	    /* see if a slave is there XXX */
	int	(*ud_slave) __P((struct uba_device *, caddr_t));
	    /* setup driver for a slave XXX */
	void	(*ud_attach) __P((struct uba_device *));
	    /* fill csr/ba to start transfer XXX */
	void	(*ud_dgo) __P((struct uba_ctlr *));
	u_short	*ud_addr;		/* device csr addresses */
	char	*ud_dname;		/* name of a device */
	struct	uba_device **ud_dinfo;	/* backpointers to ubdinit structs */
	char	*ud_mname;		/* name of a controller */
	struct	uba_ctlr **ud_minfo;	/* backpointers to ubminit structs */
	short	ud_xclu;		/* want exclusive use of bdp's */
	short	ud_keepbdp;		/* hang on to bdp's once allocated */
	int	(*ud_ubamem) __P((struct uba_device *, int));
	    /* see if dedicated memory is present */
d180 2
a181 8
#define	ubago(ui)	ubaqueue(ui, 0)

/*
 * Ubminit and ubdinit initialize the mass storage controller and
 * device tables specifying possible devices.
 */
extern	struct	uba_ctlr ubminit[];
extern	struct	uba_device ubdinit[];
a184 1
void	ubainit __P((struct uba_softc *));
d186 4
a189 4
int	uballoc __P((int, caddr_t, int, int));
void	ubarelse __P((int, int *));
int	ubaqueue __P((struct uba_device *, int));
void	ubadone __P((struct uba_ctlr *));
a190 1
int	ubasetup __P((int, struct buf *, int));
@


1.4
log
@fix LOCORE->_LOCORE changes.
@
text
@d270 1
a270 1
#endif /* !_LOCORE */
@


1.3
log
@sync w/ 0430
@
text
@d247 1
a247 1
#ifndef LOCORE
d270 1
a270 1
#endif !LOCORE
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: ubavar.h,v 1.8 1995/12/01 19:23:01 ragge Exp $	*/
d47 4
a50 2
#include "sys/buf.h"
#include "sys/device.h"
d81 3
a83 1
	void	(**Nuh_vec)();		/* interrupt vector */
d102 1
d125 1
a125 1
	void	(*um_intr)();	/* interrupt handler(s) */
d157 1
a157 1
	void	(*ui_intr)();	/* interrupt handler(s) */
d179 9
a187 4
	int	(*ud_probe)();		/* see if a driver is really there */
	int	(*ud_slave)();		/* see if a slave is there */
	int	(*ud_attach)();		/* setup driver for a slave */
	int	(*ud_dgo)();		/* fill csr/ba to start transfer */
d195 2
a196 1
	int	(*ud_ubamem)();		/* see if dedicated memory is present */
d205 4
a208 2
	void	(*ua_ivec)();
	int	ua_iarg;
d258 1
a258 1
extern	struct cfdriver	ubacd;
d261 7
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ubavar.h,v 1.6 1995/05/11 16:53:17 jtc Exp $	*/
d42 1
a42 1
 * Each uba has a uba_hd structure.
a46 2
#ifndef LOCORE

d48 1
d70 2
a71 1
struct	uba_hd {
d79 3
a81 1
	int	(**Nuh_vec)();		/* interrupt vector */
d101 1
a101 1
/* this should be replaced with a union in uba_hd */
d120 1
a120 1
	int	(*um_intr)();	/* interrupt handler(s) */
d122 1
a122 1
	struct	uba_hd *um_hd;
d152 1
a152 1
	int	(*ui_intr)();	/* interrupt handler(s) */
d163 1
a163 1
	struct	uba_hd *ui_hd;
d187 13
a199 1
#endif
a238 6
 * UBA related kernel variables
 */
int	numuba;					/* number of uba's */
struct	uba_hd uba_hd[];

/*
d245 1
a245 10
/*
 * UNIBUS device address space is mapped by UMEMmap
 * into virtual address umem[][].
 * The IO page is mapped to the last 8K of each.
 * This should be enlarged for the Q22 bus.
 */
extern	struct pte *UMEMmap[];	/* uba device addr pte's */
/* extern	char umem[][512*NBPG];		/* uba device addr space */
extern char *Numem;
#define	Tumem(x)	(Numem+(UBAPAGES+UBAIOPAGES)*NBPG*x)
d247 1
a247 8
/*
 * Since some VAXen vector their unibus interrupts
 * just adjacent to the system control block, we must
 * allocate space there when running on ``any'' cpu.  This space is
 * used for the vectors for all ubas.
 */
extern	int (*UNIvec[][128])();			/* unibus vec for ubas */
extern	int (*eUNIvec)();			/* end of unibus vec */
a248 8
#if defined(VAX780) || defined(VAX8600)
/*
 * On DW780's, we must set the scb vectors for the nexus of the
 * UNIbus adaptors to vector to locore unibus adaptor interrupt dispatchers
 * which make 780's look like the other VAXen.
 */
extern	Xua0int(), Xua1int(), Xua2int(), Xua3int();
#endif VAX780
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
