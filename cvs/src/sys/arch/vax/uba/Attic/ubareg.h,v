head	1.16;
access;
symbols
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.16
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.14
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.11.0.20
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.18
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.16
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.14
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.12
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.10
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.15;
commitid	OSDG2O3Cgeifnf1W;

1.15
date	2015.02.01.15.27.12;	author miod;	state Exp;
branches;
next	1.14;
commitid	vfuvVKDlohAznQIf;

1.14
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2008.08.18.23.19.27;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.18.23.10.39;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.27.03.14.51;	author bjc;	state Exp;
branches;
next	1.7;

1.7
date	97.05.29.00.05.10;	author niklas;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.01.15.23.25.01;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.06.12.08.20.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.10.00.07;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.10.00;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.05.14.21.38.40;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: ubareg.h,v 1.15 2015/02/01 15:27:12 miod Exp $ */
/*	$NetBSD: ubareg.h,v 1.11 2000/01/24 02:40:36 matt Exp $ */

/*-
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ubareg.h	7.8 (Berkeley) 5/9/91
 */

/*
 * VAX UNIBUS adapter registers
 */

/*
 * Size of unibus memory address space in pages
 * (also number of map registers).
 */
#define UBAPAGES	496
#define UBAIOADDR	0760000	 /* start of I/O page */
#define UBAIOPAGES	16
#define	UBAIOSIZE	(UBAIOPAGES * VAX_NBPG)	/* 8K I/O space */

/* Some Qbus-specific defines */
#define	QBAPAGES	8192
#define	QBASIZE		(QBAPAGES * VAX_NBPG)
#define	QBAMAP		0x20088000
#define	QIOPAGE		0x20000000

/*
 * Q-bus control registers
 */
#define QIPCR		0x1f40		/* from start of iopage */
/* bits in QIPCR */
#define Q_DBIRQ		0x0001		/* doorbell interrupt request */
#define Q_LMEAE		0x0020		/* local mem external access enable */
#define Q_DBIIE		0x0040		/* doorbell interrupt enable */
#define Q_AUXHLT	0x0100		/* auxiliary processor halt */
#define Q_DMAQPE	0x8000		/* Q22 bus address space parity error */
@


1.15
log
@Gather the scattered (and sometimes duplicated) qbus address and size defines
to a single place. Get rid of the unused defines pertaining to older vax
models we dropped support for years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubareg.h,v 1.14 2011/07/06 18:32:59 miod Exp $ */
@


1.14
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubareg.h,v 1.13 2008/08/18 23:19:27 miod Exp $ */
a46 7
 * QBAPAGES should be 8192, but we don't need nearly that much
 * address space, and the return from the allocation routine
 * can accommodate at most 2047 (ubavar.h: UBA_MAXMR);
 * QBAPAGES must be at least UBAPAGES.	Choose pragmatically.
 * 
 * Is there ever any need to have QBAPAGES != UBAPAGES???
 * Wont work now anyway, QBAPAGES _must_ be .eq. UBAPAGES.
d49 1
a49 3
#define NUBMREG		496
#define	QBAPAGES	1024
#define UBAIOADDR	0760000		/* start of I/O page */
d51 1
d53 5
a57 34
#if !defined(_LOCORE) && !defined(UBA_REGS_DEFINED)
/*
 * DW780/DW750 hardware registers
 */
struct uba_regs {
	int	uba_cnfgr;		/* configuration register */
	int	uba_cr;			/* control register */
	int	uba_sr;			/* status register */
	int	uba_dcr;		/* diagnostic control register */
	int	uba_fmer;		/* failed map entry register */
	int	uba_fubar;		/* failed UNIBUS address register */
	int	pad1[2];
	int	uba_brsvr[4];
	int	uba_brrvr[4];		/* receive vector registers */
	int	uba_dpr[16];		/* buffered data path register */
	int	pad2[480];
	pt_entry_t uba_map[UBAPAGES];	/* unibus map register */
	int	pad3[UBAIOPAGES];	/* no maps for device address space */
};
#endif

/* uba_mr[] */
#define UBAMR_MRV	0x80000000	/* map register valid */
#define UBAMR_BO	0x02000000	/* byte offset bit */
#define UBAMR_DPDB	0x01e00000	/* data path designator field */
#define UBAMR_SBIPFN	0x001fffff	/* SBI page address field */

#define UBAMR_DPSHIFT	21		/* shift to data path designator */

/*
 * Number of unibus buffered data paths and possible uba's per cpu type.
 */
#define NBDPBUA		5
#define MAXNBDP		15
a59 8
 * Symbolic BUS addresses for UBAs.
 */

#if VAX630 || VAX650 || VAX60
#define QBAMAP	0x20088000
#define QMEM	0x30000000
#define QIOPAGE	0x20000000
/*
a68 8
#endif

/*
 * Macro to offset a UNIBUS device address, often expressed as
 * something like 0172520, by forcing it into the last 8K
 * of UNIBUS memory space.
 */
#define ubdevreg(addr)	((addr) & 017777)
@


1.13
log
@Add support for the ``Firefox'' VAXstation 3520/3540/3820/3840 workstations,
currently limited to serial console and a single processor working.

All ``on-board'' devices, including the Q-bus adapter, but except for
the frame buffer, are supported. The machine will boot over the network
or from SCSI devices.

Lots of thanks to Al Kossow for www.bitsavers.org, on which I found the
technical documentation allowing me to complete this port (which was
lacking at the time I got that machine...).
@
text
@d1 1
a1 1
/*	$OpenBSD: ubareg.h,v 1.12 2008/08/18 23:10:39 miod Exp $ */
a44 26
 * "UNIBUS" adaptor types.
 * This code is used for both UNIBUSes and Q-buses
 * with different types of adaptors.
 * Definition of a type includes support code for that type.
 */

#if VAX780 || VAX8600
#define DW780	1		/* has adaptor regs, sr: 780/785/8600 */
#else
#undef DW780
#endif


#if VAX750
#define DW750	2		/* has adaptor regs, no sr: 750, 730 */
#endif

#if VAX730
#define DW730	3		/* has adaptor regs, no sr: 750, 730 */
#endif

#if VAX630 || VAX650 || VAX660 || VAX670 || VAX60
#define QBA	4		/* 22-bit Q-bus, no adaptor regs: uVAX II */
#endif

/*
a81 63
#ifdef DW780
/* uba_cnfgr */
#define UBACNFGR_UBINIT 0x00040000	/* unibus init asserted */
#define UBACNFGR_UBPDN	0x00020000	/* unibus power down */
#define UBACNFGR_UBIC	0x00010000	/* unibus init complete */

#define UBACNFGR_BITS \
"\40\40PARFLT\37WSQFLT\36URDFLT\35ISQFLT\34MXTFLT\33XMTFLT\30ADPDN\27ADPUP\23UBINIT\22UBPDN\21UBIC"

/* uba_cr */
#define UBACR_MRD16	0x40000000	/* map reg disable bit 4 */
#define UBACR_MRD8	0x20000000	/* map reg disable bit 3 */
#define UBACR_MRD4	0x10000000	/* map reg disable bit 2 */
#define UBACR_MRD2	0x08000000	/* map reg disable bit 1 */
#define UBACR_MRD1	0x04000000	/* map reg disable bit 0 */
#define UBACR_IFS	0x00000040	/* interrupt field switch */
#define UBACR_BRIE	0x00000020	/* BR interrupt enable */
#define UBACR_USEFIE	0x00000010	/* UNIBUS to SBI error field IE */
#define UBACR_SUEFIE	0x00000008	/* SBI to UNIBUS error field IE */
#define UBACR_CNFIE	0x00000004	/* configuration IE */
#define UBACR_UPF	0x00000002	/* UNIBUS power fail */
#define UBACR_ADINIT	0x00000001	/* adapter init */

/* uba_sr */
#define UBASR_BR7FULL	0x08000000	/* BR7 receive vector reg full */
#define UBASR_BR6FULL	0x04000000	/* BR6 receive vector reg full */
#define UBASR_BR5FULL	0x02000000	/* BR5 receive vector reg full */
#define UBASR_BR4FULL	0x01000000	/* BR4 receive vector reg full */
#define UBASR_RDTO	0x00000400	/* UNIBUS to SBI read data timeout */
#define UBASR_RDS	0x00000200	/* read data substitute */
#define UBASR_CRD	0x00000100	/* corrected read data */
#define UBASR_CXTER	0x00000080	/* command transmit error */
#define UBASR_CXTMO	0x00000040	/* command transmit timeout */
#define UBASR_DPPE	0x00000020	/* data path parity error */
#define UBASR_IVMR	0x00000010	/* invalid map register */
#define UBASR_MRPF	0x00000008	/* map register parity failure */
#define UBASR_LEB	0x00000004	/* lost error */
#define UBASR_UBSTO	0x00000002	/* UNIBUS select timeout */
#define UBASR_UBSSYNTO	0x00000001	/* UNIBUS slave sync timeout */

#define UBASR_BITS \
"\20\13RDTO\12RDS\11CRD\10CXTER\7CXTMO\6DPPE\5IVMR\4MRPF\3LEB\2UBSTO\1UBSSYNTO"

/* uba_brrvr[] */
#define UBABRRVR_AIRI	0x80000000	/* adapter interrupt request */
#define UBABRRVR_DIV	0x0000ffff	/* device interrupt vector field */
#endif
 
/* uba_dpr */
#ifdef DW780
#define UBADPR_BNE	0x80000000	/* buffer not empty - purge */
#define UBADPR_BTE	0x40000000	/* buffer transfer error */
#define UBADPR_DPF	0x20000000	/* DP function (RO) */
#define UBADPR_BS	0x007f0000	/* buffer state field */
#define UBADPR_BUBA	0x0000ffff	/* buffered UNIBUS address */
#endif
#ifdef DW750
#define UBADPR_ERROR	0x80000000	/* error occurred */
#define UBADPR_NXM	0x40000000	/* nxm from memory */
#define UBADPR_UCE	0x20000000	/* uncorrectable error */
#define UBADPR_PURGE	0x00000001	/* purge bdp */
#endif

a92 2
#define NBDP8600	15
#define NBDP780		15
a93 2
#define NBDP750		3
#define NBDP730		0
a113 21
#endif

#if VAX730
#define UMEM730		0xfc0000
#endif

#if VAX750
#define UMEM750(i)	(0xfc0000-(i)*0x40000)
#endif

#if VAX780
#define UMEM780(i)	(0x20100000+(i)*0x40000)
#endif

#if VAX8200		/* BEWARE, argument is node, not ubanum */
#define UMEM8200(i)	(0x20400000+(i)*0x40000)
#endif

#if VAX8600 || VAX780
#define UMEMA8600(i)	(0x20100000+(i)*0x40000)
#define UMEMB8600(i)	(0x22100000+(i)*0x40000)
@


1.12
log
@Some uglyness to allow both uba_common.h and ubareg.h to be included;
temporary until they get merged for good (or split differently).
@
text
@d1 1
a1 1
/*	$OpenBSD: ubareg.h,v 1.11 2003/11/10 21:05:06 miod Exp $ */
d66 1
a66 1
#if VAX630 || VAX650 || VAX660 || VAX670
d193 1
a193 1
#if VAX630 || VAX650
@


1.11
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubareg.h,v 1.10 2003/06/02 23:27:58 millert Exp $ */
d87 1
a87 1
#ifndef _LOCORE
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubareg.h,v 1.9 2001/08/25 13:33:37 hugh Exp $ */
d103 1
a103 1
	struct pte uba_map[UBAPAGES];	/* unibus map register */
@


1.9
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubareg.h,v 1.8 2000/04/27 03:14:51 bjc Exp $ */
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@sync w/netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: ubareg.h,v 1.7 1997/05/29 00:05:10 niklas Exp $ */
/*	$NetBSD: ubareg.h,v 1.10 1998/10/18 18:51:30 ragge Exp $ */
d70 1
a70 1
#if VAX630 || VAX650
@


1.7
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: ubareg.h,v 1.9 1996/08/20 13:38:02 ragge Exp $ */
/*	$NetBSD: ubareg.h,v 1.9 1996/08/20 13:38:02 ragge Exp $ */
a73 4
#if 0 /* XXX  VAX8200 || VAX8500 || VAX8800 */
#define DWBUA	5		/* BI UNIBUS adaptor: 8200/8500/8800 */
#endif

a91 51
/*
 * DWBUA hardware registers.
 */
struct dwbua_regs {
	int	pad1[456];		/* actually bii regs + pad */
	int	bua_csr;		/* control and status register */
	int	bua_offset;		/* vector offset register */
	int	bua_fubar;		/* failed UNIBUS address register */
	int	bua_bifar;		/* BI failed address register */
	int	bua_udiag[5];		/* micro diagnostics (R/O) */
	int	pad2[3];
/* dpr[0] is for DDP; dpr's 1 through 5 are for BPD's 1 through 5 */
	int	bua_dpr[6];		/* data path registers */
	int	pad3[10];
	int	bua_bdps[20];		/* buffered data path space *//*???*/
	int	pad4[8];
	struct pte bua_map[UBAPAGES];	/* unibus map registers */
	int	pad5[UBAIOPAGES];	/* no maps for device address space */
};

#ifdef DWBUA
/* bua_csr */
#define BUACSR_ERR	0x80000000	/* composite error */
#define BUACSR_BIF	0x10000000	/* BI failure */
#define BUACSR_SSYNTO	0x08000000	/* slave sync timeout */
#define BUACSR_UIE	0x04000000	/* unibus interlock error */
#define BUACSR_IVMR	0x02000000	/* invalid map register */
#define BUACSR_BADBDP	0x01000000	/* bad BDP select */
#define BUACSR_BUAEIE	0x00100000	/* bua error interrupt enable (?) */
#define BUACSR_UPI	0x00020000	/* unibus power init */
#define BUACSR_UREGDUMP 0x00010000	/* microdiag register dump */
#define BUACSR_IERRNO	0x000000ff	/* mask for internal errror number */

/* bua_offset */
#define BUAOFFSET_MASK	0x00003e00	/* hence max offset = 15872 */

/* bua_dpr */
#define BUADPR_DPSEL	0x00e00000	/* data path select (?) */
#define BUADPR_PURGE	0x00000001	/* purge bdp */

/* bua_map -- in particular, those bits that are not in DW780s & DW750s */
#define BUAMR_IOADR	0x40000000	/* I/O address space */
#define BUAMR_LAE	0x04000000	/* longword access enable */
	/* I see no reason to use either one, though ... act 6 Aug 1987 */

#define UBA_PURGEBUA(uba, bdp) \
	(((struct dwbua_regs *)(uba))->bua_dpr[bdp] |= BUADPR_PURGE)
#else
#define UBA_PURGEBUA(uba, bdp)
#endif

@


1.7.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: ubareg.h,v 1.8 2000/04/27 03:14:51 bjc Exp $ */
/*	$NetBSD: ubareg.h,v 1.10 1998/10/18 18:51:30 ragge Exp $ */
d74 4
d96 51
@


1.7.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ubareg.h,v 1.7.12.1 2001/05/14 21:38:40 niklas Exp $ */
/*	$NetBSD: ubareg.h,v 1.11 2000/01/24 02:40:36 matt Exp $ */
d70 1
a70 1
#if VAX630 || VAX650 || VAX660 || VAX670
@


1.7.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubareg.h,v 1.7.12.2 2001/10/31 03:08:01 nate Exp $ */
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.12.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d103 1
a103 1
	pt_entry_t uba_map[UBAPAGES];	/* unibus map register */
@


1.6
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.5
log
@sync to 0611
@
text
@d1 1
a1 1
/*	$NetBSD: ubareg.h,v 1.7 1996/04/08 18:37:35 ragge Exp $	*/
d55 1
a55 1
#define	DW780	1		/* has adaptor regs, sr: 780/785/8600 */
d62 1
a62 1
#define	DW750	2		/* has adaptor regs, no sr: 750, 730 */
d66 1
a66 1
#define	DW730	3		/* has adaptor regs, no sr: 750, 730 */
d70 1
a70 1
#define	QBA	4		/* 22-bit Q-bus, no adaptor regs: uVAX II */
d73 2
a74 2
#if VAX8200 || VAX8500 || VAX8800
#define	DWBUA	5		/* BI UNIBUS adaptor: 8200/8500/8800 */
d83 1
a83 1
 * QBAPAGES must be at least UBAPAGES.  Choose pragmatically.
d88 5
a92 9
#define	UBAPAGES	496
#define	NUBMREG		496
/* #if defined(GATEWAY) && !defined(QNIVERT) */
/* #define	QBAPAGES	1024 */
/* #else */
#define	QBAPAGES	UBAPAGES
/* #endif */
#define	UBAIOADDR	0760000		/* start of I/O page */
#define	UBAIOPAGES	16
d111 1
a111 1
	pt_entry_t bua_map[UBAPAGES];	/* unibus map registers */
d117 10
a126 10
#define	BUACSR_ERR	0x80000000	/* composite error */
#define	BUACSR_BIF	0x10000000	/* BI failure */
#define	BUACSR_SSYNTO	0x08000000	/* slave sync timeout */
#define	BUACSR_UIE	0x04000000	/* unibus interlock error */
#define	BUACSR_IVMR	0x02000000	/* invalid map register */
#define	BUACSR_BADBDP	0x01000000	/* bad BDP select */
#define	BUACSR_BUAEIE	0x00100000	/* bua error interrupt enable (?) */
#define	BUACSR_UPI	0x00020000	/* unibus power init */
#define	BUACSR_UREGDUMP	0x00010000	/* microdiag register dump */
#define	BUACSR_IERRNO	0x000000ff	/* mask for internal errror number */
d129 1
a129 1
#define	BUAOFFSET_MASK	0x00003e00	/* hence max offset = 15872 */
d132 2
a133 2
#define	BUADPR_DPSEL	0x00e00000	/* data path select (?) */
#define	BUADPR_PURGE	0x00000001	/* purge bdp */
d136 2
a137 2
#define	BUAMR_IOADR	0x40000000	/* I/O address space */
#define	BUAMR_LAE	0x04000000	/* longword access enable */
d140 1
a140 1
#define	UBA_PURGEBUA(uba, bdp) \
d143 1
a143 1
#define	UBA_PURGEBUA(uba, bdp)
d161 1
a161 1
	pt_entry_t uba_map[UBAPAGES];	/* unibus map register */
d168 3
a170 3
#define	UBACNFGR_UBINIT	0x00040000	/* unibus init asserted */
#define	UBACNFGR_UBPDN	0x00020000	/* unibus power down */
#define	UBACNFGR_UBIC	0x00010000	/* unibus init complete */
d176 12
a187 12
#define	UBACR_MRD16	0x40000000	/* map reg disable bit 4 */
#define	UBACR_MRD8	0x20000000	/* map reg disable bit 3 */
#define	UBACR_MRD4	0x10000000	/* map reg disable bit 2 */
#define	UBACR_MRD2	0x08000000	/* map reg disable bit 1 */
#define	UBACR_MRD1	0x04000000	/* map reg disable bit 0 */
#define	UBACR_IFS	0x00000040	/* interrupt field switch */
#define	UBACR_BRIE	0x00000020	/* BR interrupt enable */
#define	UBACR_USEFIE	0x00000010	/* UNIBUS to SBI error field IE */
#define	UBACR_SUEFIE	0x00000008	/* SBI to UNIBUS error field IE */
#define	UBACR_CNFIE	0x00000004	/* configuration IE */
#define	UBACR_UPF	0x00000002	/* UNIBUS power fail */
#define	UBACR_ADINIT	0x00000001	/* adapter init */
d190 15
a204 15
#define	UBASR_BR7FULL	0x08000000	/* BR7 receive vector reg full */
#define	UBASR_BR6FULL	0x04000000	/* BR6 receive vector reg full */
#define	UBASR_BR5FULL	0x02000000	/* BR5 receive vector reg full */
#define	UBASR_BR4FULL	0x01000000	/* BR4 receive vector reg full */
#define	UBASR_RDTO	0x00000400	/* UNIBUS to SBI read data timeout */
#define	UBASR_RDS	0x00000200	/* read data substitute */
#define	UBASR_CRD	0x00000100	/* corrected read data */
#define	UBASR_CXTER	0x00000080	/* command transmit error */
#define	UBASR_CXTMO	0x00000040	/* command transmit timeout */
#define	UBASR_DPPE	0x00000020	/* data path parity error */
#define	UBASR_IVMR	0x00000010	/* invalid map register */
#define	UBASR_MRPF	0x00000008	/* map register parity failure */
#define	UBASR_LEB	0x00000004	/* lost error */
#define	UBASR_UBSTO	0x00000002	/* UNIBUS select timeout */
#define	UBASR_UBSSYNTO	0x00000001	/* UNIBUS slave sync timeout */
d206 1
a206 1
#define	UBASR_BITS \
d210 2
a211 2
#define	UBABRRVR_AIRI	0x80000000	/* adapter interrupt request */
#define	UBABRRVR_DIV	0x0000ffff	/* device interrupt vector field */
d216 5
a220 9
#define	UBADPR_BNE	0x80000000	/* buffer not empty - purge */
#define	UBADPR_BTE	0x40000000	/* buffer transfer error */
#define	UBADPR_DPF	0x20000000	/* DP function (RO) */
#define	UBADPR_BS	0x007f0000	/* buffer state field */
#define	UBADPR_BUBA	0x0000ffff	/* buffered UNIBUS address */
#define	UBA_PURGE780(uba, bdp) \
    ((uba)->uba_dpr[(int)bdp] |= UBADPR_BNE)
#else
#define UBA_PURGE780(uba, bdp)
d223 4
a226 11
#define	UBADPR_ERROR	0x80000000	/* error occurred */
#define	UBADPR_NXM	0x40000000	/* nxm from memory */
#define	UBADPR_UCE	0x20000000	/* uncorrectable error */
#define	UBADPR_PURGE	0x00000001	/* purge bdp */
/* the DELAY is for a hardware problem */
#define	UBA_PURGE750(uba, bdp) { \
    ((uba)->uba_dpr[(int)bdp] |= (UBADPR_PURGE|UBADPR_NXM|UBADPR_UCE)); \
    {volatile int N=8;while(N--);} \
}
#else
#define UBA_PURGE750(uba, bdp)
a228 22
/*
 * Macros for fast buffered data path purging in time-critical routines.
 *
 * Too bad C pre-processor doesn't have the power of LISP in macro
 * expansion...
 */

/* THIS IS WRONG, should use pointer to uba_hd */
#if DWBUA || DW780 || DW750
#define	UBAPURGE(uba, bdp) { \
	switch (MACHID(cpu_type)) { \
	case VAX_8200: UBA_PURGEBUA(uba, bdp); break; \
	case VAX_8600: case VAX_780: UBA_PURGE780((uba), (bdp)); break; \
	case VAX_750: UBA_PURGE750((uba), (bdp)); break; \
	} \
}
#else
#define	UBAPURGE(uba, bdp)
#endif



d230 4
a233 4
#define	UBAMR_MRV	0x80000000	/* map register valid */
#define	UBAMR_BO	0x02000000	/* byte offset bit */
#define	UBAMR_DPDB	0x01e00000	/* data path designator field */
#define	UBAMR_SBIPFN	0x001fffff	/* SBI page address field */
d235 1
a235 1
#define	UBAMR_DPSHIFT	21		/* shift to data path designator */
d240 6
a245 6
#define	NBDP8600	15
#define	NBDP780		15
#define	NBDPBUA		5
#define	NBDP750		3
#define	NBDP730		0
#define	MAXNBDP		15
d252 3
a254 3
#define	QBAMAP630	((struct pte *)0x20088000)
#define	QMEM630		0x30000000
#define	QIOPAGE630	0x20000000
d258 1
a258 1
#define	QIPCR		0x1f40		/* from start of iopage */
d260 5
a264 5
#define	Q_DBIRQ		0x0001		/* doorbell interrupt request */
#define	Q_LMEAE		0x0020		/* local mem external access enable */
#define	Q_DBIIE		0x0040		/* doorbell interrupt enable */
#define	Q_AUXHLT	0x0100		/* auxiliary processor halt */
#define	Q_DMAQPE	0x8000		/* Q22 bus address space parity error */
d268 1
a268 1
#define	UMEM730		0xfc0000
d272 1
a272 1
#define	UMEM750(i)	(0xfc0000-(i)*0x40000)
d276 1
a276 1
#define	UMEM780(i)	(0x20100000+(i)*0x40000)
d280 1
a280 1
#define	UMEM8200(i)	(0x20400000+(i)*0x40000)
d284 2
a285 2
#define	UMEMA8600(i)	(0x20100000+(i)*0x40000)
#define	UMEMB8600(i)	(0x22100000+(i)*0x40000)
d293 1
a293 1
#define	ubdevreg(addr)	((addr) & 017777)
@


1.4
log
@fix LOCORE->_LOCORE changes.
@
text
@d1 1
a1 1
/*	$NetBSD: ubareg.h,v 1.4 1995/11/10 19:25:50 ragge Exp $	*/
@


1.3
log
@sync w/ 0430
@
text
@d98 1
a98 1
#ifndef LOCORE
@


1.2
log
@update from netbsd (verbatim)
@
text
@d226 1
a226 1
    ((uba)->uba_dpr[bdp] |= UBADPR_BNE)
d237 2
a238 2
    ((uba)->uba_dpr[bdp] |= (UBADPR_PURGE|UBADPR_NXM|UBADPR_UCE)); \
    {int N=8;while(N--);} \
d320 1
a320 1
#if VAX8600
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ubareg.h,v 1.3 1995/02/13 00:44:23 ragge Exp $	*/
d84 3
d90 3
a92 3
#if defined(GATEWAY) && !defined(QNIVERT)
#define	QBAPAGES	1024
#else
d94 1
a94 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
