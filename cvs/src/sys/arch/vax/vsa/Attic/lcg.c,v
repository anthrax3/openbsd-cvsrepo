head	1.24;
access;
symbols
	OPENBSD_5_9:1.23.0.4
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.19.0.8
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.6
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9;
locks; strict;
comment	@ * @;


1.24
date	2016.03.09.16.28.50;	author deraadt;	state dead;
branches;
next	1.23;
commitid	OSDG2O3Cgeifnf1W;

1.23
date	2014.12.23.21.39.12;	author miod;	state Exp;
branches;
next	1.22;
commitid	foSDoFEw0OUhYWGt;

1.22
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.21;
commitid	uKVPYMN2MLxdZxzH;

1.21
date	2013.10.21.10.36.21;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.20.20.07.28;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2011.09.19.21.53.02;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2011.09.11.14.00.34;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2011.08.26.21.50.16;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.21.21.39.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.28.20.44.39;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.18.19.39.27;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.01.16.11.19;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.22.21.05.03;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.06.15.04.22;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.05.22.04.53;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.03.18.46.50;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.01.18.49.42;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.29.15.11.57;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.29.14.18.57;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.24.22.18.09;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.07.24.20.35.08;	author miod;	state Exp;
branches;
next	;


desc
@@


1.24
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: lcg.c,v 1.23 2014/12/23 21:39:12 miod Exp $	*/
/*
 * Copyright (c) 2006 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2003, 2004 Blaz Antonic
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the abovementioned copyrights
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/conf.h>
#include <sys/kernel.h>

#include <machine/vsbus.h>
#include <machine/scb.h>
#include <machine/sid.h>
#include <machine/cpu.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <vax/vsa/lcgreg.h>

#define	LCG_CONFIG_ADDR	0x200f0010	/* configuration register */
#define	LCG_REG_ADDR	0x20100000	/* registers */
#define	LCG_REG_SIZE	0x4000
#define	LCG_LUT_ADDR	0x21800000	/* colormap */
#define	LCG_LUT_OFFSET	0x0800
#define	LCG_LUT_SIZE	0x0800
#define	LCG_FB_ADDR	0x21801000	/* frame buffer */

int	lcg_match(struct device *, void *, void *);
void	lcg_attach(struct device *, struct device *, void *);

struct	lcg_screen {
	struct rasops_info ss_ri;
	u_int32_t	ss_cfg;
	u_int		ss_width, ss_height, ss_depth;
	u_int		ss_fbsize;		/* visible part only */
	caddr_t		ss_addr;		/* frame buffer address */
	vaddr_t		ss_reg;
	volatile u_int8_t *ss_lut;
	u_int8_t	ss_cmap[256 * 3];
};

/* for console */
struct lcg_screen lcg_consscr;

struct	lcg_softc {
	struct device sc_dev;
	struct lcg_screen *sc_scr;
	int	sc_nscreens;
};

struct cfattach lcg_ca = {
	sizeof(struct lcg_softc), lcg_match, lcg_attach,
};

struct	cfdriver lcg_cd = {
	NULL, "lcg", DV_DULL
};

struct wsscreen_descr lcg_stdscreen = {
	"std",
};

const struct wsscreen_descr *_lcg_scrlist[] = {
	&lcg_stdscreen,
};

const struct wsscreen_list lcg_screenlist = {
	sizeof(_lcg_scrlist) / sizeof(struct wsscreen_descr *),
	_lcg_scrlist,
};

int	lcg_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	lcg_mmap(void *, off_t, int);
int	lcg_alloc_screen(void *, const struct wsscreen_descr *,
	    void **, int *, int *, long *);
void	lcg_free_screen(void *, void *);
int	lcg_show_screen(void *, void *, int,
	    void (*) (void *, int, int), void *);
int	lcg_load_font(void *, void *, struct wsdisplay_font *);
int	lcg_list_font(void *, struct wsdisplay_font *);
void	lcg_burner(void *, u_int, u_int);

const struct wsdisplay_accessops lcg_accessops = {
	.ioctl = lcg_ioctl,
	.mmap = lcg_mmap,
	.alloc_screen = lcg_alloc_screen,
	.free_screen = lcg_free_screen,
	.show_screen = lcg_show_screen,
	.load_font = lcg_load_font,
	.list_font = lcg_list_font,
	.burn_screen = lcg_burner
};

int	lcg_alloc_attr(void *, int, int, int, long *);
int	lcg_getcmap(struct lcg_screen *, struct wsdisplay_cmap *);
void	lcg_loadcmap(struct lcg_screen *, int, int);
int	lcg_probe_screen(u_int32_t, u_int *, u_int *);
int	lcg_putcmap(struct lcg_screen *, struct wsdisplay_cmap *);
void	lcg_resetcmap(struct lcg_screen *);
int	lcg_setup_screen(struct lcg_screen *);

#define	lcg_read_reg(ss, regno) \
	*(volatile u_int32_t *)((ss)->ss_reg + (regno))
#define	lcg_write_reg(ss, regno, val) \
	*(volatile u_int32_t *)((ss)->ss_reg + (regno)) = (val)

int
lcg_match(struct device *parent, void *vcf, void *aux)
{
	struct vsbus_softc *sc = (void *)parent;
	struct vsbus_attach_args *va = aux;
	vaddr_t cfgreg;
	int depth;
#ifdef PARANOIA
	int missing;
	volatile u_int8_t *ch;
#endif

	if (va->va_paddr != LCG_REG_ADDR)
		return (0);

	switch (vax_boardtype) {
	default:
		return (0);

	case VAX_BTYP_46:
		if ((vax_confdata & 0x40) == 0)
			return (0);
		break;
	case VAX_BTYP_48:
		if (vax_cpustype != VAX_STYP_48)
			return (0);
		/* KA48 can't boot without the frame buffer board */
		break;
	}

	/*
	 * Check the configuration register. The frame buffer might not be
	 * an lcg board.
	 */
	cfgreg = vax_map_physmem(LCG_CONFIG_ADDR, 1);
	depth = lcg_probe_screen(*(volatile u_int32_t *)cfgreg, NULL, NULL);
	vax_unmap_physmem(cfgreg, 1);
	if (depth < 0)	/* no lcg frame buffer */
		return (0);

#ifdef PARANOIA
	/*
	 * Check for video memory.
	 * We can not use badaddr() on these models.
	 */
	missing = 0;
	ch = (volatile u_int8_t *)vax_map_physmem(LCG_FB_ADDR, 1);
	*ch = 0x01;
	if ((*ch & 0x01) == 0)
		missing = 1;
	else {
		*ch = 0x00;
		if ((*ch & 0x01) != 0)
			missing = 1;
	}
	vax_unmap_physmem((vaddr_t)ch, 1);
	if (missing != 0)
		return (0);
#endif

	sc->sc_mask = 0x04;	/* XXX - should be generated */
	scb_fake(0x120, 0x15);
	return (20);
}

void
lcg_attach(struct device *parent, struct device *self, void *aux)
{
	struct lcg_softc *sc = (struct lcg_softc *)self;
	struct lcg_screen *ss;
	struct wsemuldisplaydev_attach_args aa;
	vaddr_t tmp;
	u_int32_t cfg;
	int console;
	extern struct consdev wsdisplay_cons;

	console = (vax_confdata & 0x100) == 0 && cn_tab == &wsdisplay_cons;

	/*
	 * Check for a recognized configuration register.
	 * If we do not recognize it, print it and do not attach - so that
	 * this gets noticed...
	 */
	if (!console) {
		tmp = vax_map_physmem(LCG_CONFIG_ADDR, 1);
		if (tmp == 0) {
			printf("\n%s: can not map configuration register\n",
			    self->dv_xname);
			return;
		}
		cfg = *(volatile u_int32_t *)tmp;
		vax_unmap_physmem(tmp, 1);

		if (lcg_probe_screen(cfg, NULL, NULL) <= 0) {
			printf("\n%s:"
			    " unrecognized configuration register %08x\n",
			    self->dv_xname, cfg);
			return;
		}
	}

	if (console) {
		ss = &lcg_consscr;
		sc->sc_nscreens = 1;
	} else {
		ss = malloc(sizeof(*ss), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (ss == NULL) {
			printf(": can not allocate memory\n");
			return;
		}

		ss->ss_cfg = cfg;
		ss->ss_depth = lcg_probe_screen(ss->ss_cfg,
		    &ss->ss_width, &ss->ss_height);
		ss->ss_fbsize =
		    roundup(ss->ss_width * ss->ss_height, PAGE_SIZE);

		ss->ss_addr = (caddr_t)vax_map_physmem(LCG_FB_ADDR,
		    ss->ss_fbsize / VAX_NBPG);
		if (ss->ss_addr == NULL) {
			printf(": can not map frame buffer\n");
			goto fail1;
		}

		ss->ss_reg = vax_map_physmem(LCG_REG_ADDR,
		    LCG_REG_SIZE / VAX_NBPG);
		if (ss->ss_reg == 0L) {
			printf(": can not map registers\n");
			goto fail2;
		}

		ss->ss_lut = (volatile u_int8_t *)vax_map_physmem(LCG_LUT_ADDR +
		    LCG_LUT_OFFSET, LCG_LUT_SIZE / VAX_NBPG);
		if (ss->ss_lut == NULL) {
			printf(": can not map color LUT\n");
			goto fail3;
		}

		if (lcg_setup_screen(ss) != 0) {
			printf(": initialization failed\n");
			goto fail4;
		}
	}
	sc->sc_scr = ss;

	printf(": %dx%dx%d frame buffer\n",
	    ss->ss_width, ss->ss_height, ss->ss_depth);

	aa.console = console;
	aa.scrdata = &lcg_screenlist;
	aa.accessops = &lcg_accessops;
	aa.accesscookie = sc;
	aa.defaultscreens = 0;

	config_found(self, &aa, wsemuldisplaydevprint);
	return;

fail4:
	vax_unmap_physmem((vaddr_t)ss->ss_lut, LCG_LUT_SIZE / VAX_NBPG);
fail3:
	vax_unmap_physmem(ss->ss_reg, LCG_REG_SIZE / VAX_NBPG);
fail2:
	vax_unmap_physmem((vaddr_t)ss->ss_addr, ss->ss_fbsize / VAX_NBPG);
fail1:
	free(ss, M_DEVBUF, sizeof(*ss));
}

/*
 * Determine if we have a recognized frame buffer, its resolution and
 * color depth.
 */
int
lcg_probe_screen(u_int32_t cfg, u_int *width, u_int *height)
{
	u_int w, h, d = 8;

	switch (vax_boardtype) {
	case VAX_BTYP_46:
		switch (cfg & 0xf0) {
		case 0x00:
			return (-1);	/* no hardware */
		case 0x20:
		case 0x60:
			w = 1024; h = 864;
			break;
		case 0x40:
			w = 1024; h = 768;
			break;
		case 0x80:
			d = 4;
			/* FALLTHROUGH */
		case 0x90:
		case 0xb0:
			w = 1280; h = 1024;
			break;
		default:
			return (0);	/* unknown configuration, please help */
		}
		break;
	case VAX_BTYP_48:
		switch (cfg & 0x07) {
		case 0x00:
			return (-1);	/* no hardware */
		case 0x05:
			w = 1280; h = 1024;
			break;
		case 0x06:
			if (vax_confdata & 0x80) {
				w = 1024; h = 768;
			} else {
				w = 640; h = 480;
			}
			break;
		case 0x07:
			if (vax_confdata & 0x80) {
				w = 1024; h = 768;
			} else {
				w = 1024; h = 864;
			}
			break;
		default:
			return (0);	/* unknown configuration, please help */
		}
		break;
	}

	if (width != NULL)
		*width = w;
	if (height != NULL)
		*height = h;

	return (d);
}

/*
 * Initialize anything necessary for an emulating wsdisplay to work (i.e.
 * pick a font, initialize a rasops structure, setup the accessops callbacks.)
 */
int
lcg_setup_screen(struct lcg_screen *ss)
{
	struct rasops_info *ri = &ss->ss_ri;

	bzero(ri, sizeof(*ri));
	/*
	 * Since the frame buffer memory is byte addressed, even in low-bpp
	 * mode, initialize a 8bpp rasops engine. We will report a shorter
	 * colormap if necessary, which will allow X to do TRT.
	 */
	ri->ri_depth = 8;
	ri->ri_width = ss->ss_width;
	ri->ri_height = ss->ss_height;
	ri->ri_stride = ss->ss_width;
	ri->ri_flg = RI_CLEAR | RI_CENTER;
	ri->ri_bits = (void *)ss->ss_addr;
	ri->ri_hw = ss;

	/*
	 * Ask for an unholy big display, rasops will trim this to more
	 * reasonable values.
	 */
	if (rasops_init(ri, 160, 160) != 0)
		return (-1);

	if (ss->ss_depth < 8) {
		ri->ri_ops.alloc_attr = lcg_alloc_attr;
		ri->ri_caps &= ~WSSCREEN_HILIT;
	}

	lcg_stdscreen.ncols = ri->ri_cols;
	lcg_stdscreen.nrows = ri->ri_rows;
	lcg_stdscreen.textops = &ri->ri_ops;
	lcg_stdscreen.fontwidth = ri->ri_font->fontwidth;
	lcg_stdscreen.fontheight = ri->ri_font->fontheight;
	lcg_stdscreen.capabilities = ri->ri_caps;

	lcg_resetcmap(ss);

	return (0);
}

int
lcg_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct lcg_softc *sc = v;
	struct lcg_screen *ss = sc->sc_scr;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_LCG;
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = ss->ss_height;
		wdf->width = ss->ss_width;
		wdf->depth = 8;
		wdf->cmsize = 1 << ss->ss_depth;
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = ss->ss_ri.ri_stride;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = lcg_getcmap(ss, cm);
		if (error != 0)
			return (error);
		break;
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = lcg_putcmap(ss, cm);
		if (error != 0)
			return (error);
		lcg_loadcmap(ss, cm->index, cm->count);
		break;

	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		break;

	default:
		return (-1);
	}

	return (0);
}

paddr_t
lcg_mmap(void *v, off_t offset, int prot)
{
	struct lcg_softc *sc = v;
	struct lcg_screen *ss = sc->sc_scr;

	if (offset >= ss->ss_fbsize || offset < 0)
		return (-1);

	return (LCG_FB_ADDR + offset);
}

int
lcg_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *defattrp)
{
	struct lcg_softc *sc = v;
	struct lcg_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = ri;
	*curxp = *curyp = 0;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, defattrp);
	sc->sc_nscreens++;

	return (0);
}

void
lcg_free_screen(void *v, void *cookie)
{
	struct lcg_softc *sc = v;

	sc->sc_nscreens--;
}

int
lcg_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

int
lcg_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct lcg_softc *sc = v;
	struct lcg_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	return rasops_load_font(ri, emulcookie, font);
}

int
lcg_list_font(void *v, struct wsdisplay_font *font)
{
	struct lcg_softc *sc = v;
	struct lcg_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	return rasops_list_font(ri, font);
}

void
lcg_burner(void *v, u_int on, u_int flags)
{
	struct lcg_softc *sc = v;
	struct lcg_screen *ss = sc->sc_scr;
	u_int32_t vidcfg;

	vidcfg = lcg_read_reg(ss, LCG_REG_VIDEO_CONFIG);
	if (on)
		vidcfg |= VIDEO_ENABLE_VIDEO | VIDEO_SYNC_ENABLE;
	else {
		vidcfg &= ~VIDEO_ENABLE_VIDEO;
		if (flags & WSDISPLAY_BURN_VBLANK)
			vidcfg &= ~VIDEO_SYNC_ENABLE;
	}
	lcg_write_reg(ss, LCG_REG_VIDEO_CONFIG, vidcfg);
}

/*
 * Attribute allocator for 4bpp frame buffers.
 * In such modes, highlighting is not available.
 */
int
lcg_alloc_attr(void *cookie, int fg, int bg, int flg, long *attr)
{
	extern int rasops_alloc_cattr(void *, int, int, int, long *);

	if ((flg & (WSATTR_BLINK | WSATTR_HILIT)) != 0)
		return (EINVAL);

	return (rasops_alloc_cattr(cookie, fg, bg, flg, attr));
}

/*
 * Colormap handling routines
 */

int
lcg_getcmap(struct lcg_screen *ss, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index, count = cm->count, i;
	u_int colcount = 1 << ss->ss_depth;
	int error;
	u_int8_t ramp[256], *c, *r;

	if (index >= colcount || count > colcount - index)
		return (EINVAL);

	/* extract reds */
	c = ss->ss_cmap + 0 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->red, count)) != 0)
		return (error);

	/* extract greens */
	c = ss->ss_cmap + 1 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->green, count)) != 0)
		return (error);

	/* extract blues */
	c = ss->ss_cmap + 2 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->blue, count)) != 0)
		return (error);

	return (0);
}

int
lcg_putcmap(struct lcg_screen *ss, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index, count = cm->count;
	u_int colcount = 1 << ss->ss_depth;
	int i, error;
	u_int8_t r[256], g[256], b[256], *nr, *ng, *nb, *c;

	if (index >= colcount || count > colcount - index)
		return (EINVAL);

	if ((error = copyin(cm->red, r, count)) != 0)
		return (error);
	if ((error = copyin(cm->green, g, count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, b, count)) != 0)
		return (error);

	nr = r, ng = g, nb = b;
	c = ss->ss_cmap + index * 3;
	for (i = count; i != 0; i--) {
		*c++ = *nr++;
		*c++ = *ng++;
		*c++ = *nb++;
	}

	return (0);
}

/* Fill the given colormap (LUT) entry.  */
#define lcg_set_lut_entry(lutptr, cmap, idx, shift)			\
do {									\
	*(lutptr)++ = LUT_ADRS_REG;					\
	*(lutptr)++ = (idx);						\
	*(lutptr)++ = LUT_COLOR_AUTOINC;				\
	*(lutptr)++ = (*(cmap)++) >> (shift);				\
	*(lutptr)++ = LUT_COLOR_AUTOINC;				\
	*(lutptr)++ = (*(cmap)++) >> (shift);				\
	*(lutptr)++ = LUT_COLOR_AUTOINC;				\
	*(lutptr)++ = (*(cmap)++) >> (shift);				\
} while (0)

void
lcg_loadcmap(struct lcg_screen *ss, int from, int count)
{
	const u_int8_t *cmap;
	u_int i;
	volatile u_int8_t *lutptr;
	u_int32_t vidcfg;

	/* partial updates ignored for now */
	cmap = ss->ss_cmap;
	lutptr = ss->ss_lut;
	if (ss->ss_depth == 8) {
		for (i = 0; i < 256; i++) {
			lcg_set_lut_entry(lutptr, cmap, i, 0);
		}
	} else {
		for (i = 0; i < 16; i++) {
			lcg_set_lut_entry(lutptr, cmap, i, 4);
		}
	}

	/*
	 * Wait for retrace
	 */
	while (((vidcfg = lcg_read_reg(ss, LCG_REG_VIDEO_CONFIG)) &
	    VIDEO_VSTATE) != VIDEO_VSYNC)
		DELAY(1);

	vidcfg &= ~(VIDEO_SHIFT_SEL | VIDEO_MEM_REFRESH_SEL_MASK |
	    VIDEO_LUT_SHIFT_SEL);
	/* Do full loads if width is 1024 or 2048, split loads otherwise. */
	if (ss->ss_width == 1024 || ss->ss_width == 2048)
		vidcfg |= VIDEO_SHIFT_SEL | (1 << VIDEO_MEM_REFRESH_SEL_SHIFT) |
		    VIDEO_LUT_SHIFT_SEL;
	else
		vidcfg |= (2 << VIDEO_MEM_REFRESH_SEL_SHIFT);
	vidcfg |= VIDEO_LUT_LOAD_SIZE;	/* 2KB lut */
	lcg_write_reg(ss, LCG_REG_VIDEO_CONFIG, vidcfg);
	lcg_write_reg(ss, LCG_REG_LUT_CONSOLE_SEL, LUT_SEL_COLOR);
	lcg_write_reg(ss, LCG_REG_LUT_COLOR_BASE_W, LCG_LUT_OFFSET);
	/* Wait for end of retrace */
	while (((vidcfg = lcg_read_reg(ss, LCG_REG_VIDEO_CONFIG)) &
	    VIDEO_VSTATE) == VIDEO_VSYNC)
		DELAY(1);
	lcg_write_reg(ss, LCG_REG_LUT_CONSOLE_SEL, LUT_SEL_CONSOLE);
}

void
lcg_resetcmap(struct lcg_screen *ss)
{
	if (ss->ss_depth == 8)
		bcopy(rasops_cmap, ss->ss_cmap, sizeof(ss->ss_cmap));
	else {
		bcopy(rasops_cmap, ss->ss_cmap, 8 * 3);
		bcopy(rasops_cmap + 0xf8 * 3, ss->ss_cmap + 8 * 3, 8 * 3);
	}
	lcg_loadcmap(ss, 0, 1 << ss->ss_depth);
}

/*
 * Console support code
 */

int	lcgcnprobe(void);
int	lcgcninit(void);

int
lcgcnprobe()
{
	extern vaddr_t virtual_avail;
	u_int32_t cfg;
	vaddr_t tmp;
#ifdef PARANOIA
	volatile u_int8_t *ch;
	int rc;
#endif

	switch (vax_boardtype) {
	case VAX_BTYP_46:
		if ((vax_confdata & 0x40) == 0)
			return (0);	/* no frame buffer */
		break;
	case VAX_BTYP_48:
		if (vax_cpustype != VAX_STYP_48)
			return (0);
		break;
	default:
		return (0);
	}

	if ((vax_confdata & 0x100) != 0)
		return (0); /* doesn't use graphics console */

	tmp = virtual_avail;
	ioaccess(tmp, vax_trunc_page(LCG_CONFIG_ADDR), 1);
	cfg = *(volatile u_int32_t *)(tmp + (LCG_CONFIG_ADDR & VAX_PGOFSET));
	iounaccess(tmp, 1);

	if (lcg_probe_screen(cfg, NULL, NULL) <= 0)
		return (0);	/* no lcg or unsupported configuration */

#ifdef PARANOIA
	/*
	 * Check for video memory.
	 * We can not use badaddr() on these models.
	 */
	rc = 0;
	ioaccess(tmp, LCG_FB_ADDR, 1);
	ch = (volatile u_int8_t *)tmp;
	*ch = 0x01;
	if ((*ch & 0x01) != 0) {
		*ch = 0x00;
		if ((*ch & 0x01) == 0)
			rc = 1;
	}
	iounaccess(tmp, 1);
	if (rc == 0)
		return (0);
#endif

	return (1);
}

/*
 * Called very early to setup the glass tty as console.
 * Because it's called before the VM system is initialized, virtual memory
 * for the framebuffer can be stolen directly without disturbing anything.
 */
int
lcgcninit()
{
	struct lcg_screen *ss = &lcg_consscr;
	extern vaddr_t virtual_avail;
	vaddr_t ova;
	long defattr;
	struct rasops_info *ri;

	ova = virtual_avail;
	ioaccess(virtual_avail, vax_trunc_page(LCG_CONFIG_ADDR), 1);
	ss->ss_cfg = *(volatile u_int32_t *)
	    (virtual_avail + (LCG_CONFIG_ADDR & VAX_PGOFSET));
	iounaccess(virtual_avail, 1);

	ss->ss_depth = lcg_probe_screen(ss->ss_cfg,
	    &ss->ss_width, &ss->ss_height);

	ss->ss_fbsize = roundup(ss->ss_width * ss->ss_height, PAGE_SIZE);

	ss->ss_addr = (caddr_t)virtual_avail;
	ioaccess(virtual_avail, LCG_FB_ADDR, ss->ss_fbsize / VAX_NBPG);
	virtual_avail += ss->ss_fbsize;

	ss->ss_reg = virtual_avail;
	ioaccess(virtual_avail, LCG_REG_ADDR, LCG_REG_SIZE / VAX_NBPG);
	virtual_avail += LCG_REG_SIZE;

	ss->ss_lut = (volatile u_int8_t *)virtual_avail;
	ioaccess(virtual_avail, LCG_LUT_ADDR + LCG_LUT_OFFSET,
	    LCG_LUT_SIZE / VAX_NBPG);
	virtual_avail += LCG_LUT_SIZE;

	virtual_avail = round_page(virtual_avail);

	/* this had better not fail */
	if (lcg_setup_screen(ss) != 0) {
		iounaccess((vaddr_t)ss->ss_lut, LCG_LUT_SIZE / VAX_NBPG);
		iounaccess((vaddr_t)ss->ss_reg, LCG_REG_SIZE / VAX_NBPG);
		iounaccess((vaddr_t)ss->ss_addr, ss->ss_fbsize / VAX_NBPG);
		virtual_avail = ova;
		return (1);
	}

	ri = &ss->ss_ri;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&lcg_stdscreen, ri, 0, 0, defattr);

	return (0);
}
@


1.23
log
@Pass real sizes to free()
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.22 2014/07/12 18:44:43 tedu Exp $	*/
@


1.22
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.21 2013/10/21 10:36:21 miod Exp $	*/
d320 1
a320 1
	free(ss, M_DEVBUF, 0);
@


1.21
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.20 2013/10/20 20:07:28 miod Exp $	*/
d320 1
a320 1
	free(ss, M_DEVBUF);
@


1.20
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.19 2011/09/19 21:53:02 miod Exp $	*/
d128 2
d138 2
d532 20
@


1.19
log
@Try and clean system type constants a bit:
- save the second byte of vax_siedata into a new variable, vax_cpustype,
  and use it instead of (vax_siedata >> 8) & 0xff or other similar
  constructs.
- the VAX_SIE_KAxxx constants are duplicates of the VAX_STYP_xx constants.
  Standardize on the latter and kill the former.
- only keep VAX_VTYP_xx constants for KA46 and KA47, those are the only
  systems which use these constants and are told apart by a different
  SIE byte.

No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.18 2011/09/11 14:00:34 miod Exp $	*/
d131 6
a136 9
	lcg_ioctl,
	lcg_mmap,
	lcg_alloc_screen,
	lcg_free_screen,
	lcg_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	lcg_burner
@


1.18
log
@Fix inverted test when selecting resolution on the 1024x864 VLC frame buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.17 2011/08/26 21:50:16 miod Exp $	*/
d179 1
a179 1
		if (((vax_siedata >> 8) & 0xff) != VAX_STYP_48)
d730 1
a730 1
		if (((vax_siedata >> 8) & 0xff) != VAX_STYP_48)
@


1.17
log
@Be sure not to try to match lcg, and to bail out early in cnprobe as well,
if we are running on a KA45 system. These share the KA48 board type but,
unlike KA48, can not sport frame buffers.
Prevents a bogus lcg device from attaching on KA45, and also repairs console
operation if the S3 switch is down (console on serial #0).
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.16 2011/04/07 15:30:16 miod Exp $	*/
d370 2
a372 2
			} else {
				w = 1024; h = 768;
@


1.16
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.15 2010/12/26 15:41:00 miod Exp $	*/
d179 2
d727 2
a728 2
			break;	/* no frame buffer */
		/* FALLTHROUGH */
d730 9
a738 2
		if ((vax_confdata & 0x100) != 0)
			break; /* doesn't use graphics console */
d740 4
a743 5
		tmp = virtual_avail;
		ioaccess(tmp, vax_trunc_page(LCG_CONFIG_ADDR), 1);
		cfg = *(volatile u_int32_t *)
		    (tmp + (LCG_CONFIG_ADDR & VAX_PGOFSET));
		iounaccess(tmp, 1);
d745 2
a746 2
		if (lcg_probe_screen(cfg, NULL, NULL) <= 0)
			break;	/* no lcg or unsupported configuration */
d749 16
a764 16
		/*
		 * Check for video memory.
		 * We can not use badaddr() on these models.
		 */
		rc = 0;
		ioaccess(tmp, LCG_FB_ADDR, 1);
		ch = (volatile u_int8_t *)tmp;
		*ch = 0x01;
		if ((*ch & 0x01) != 0) {
			*ch = 0x00;
			if ((*ch & 0x01) == 0)
				rc = 1;
		}
		iounaccess(tmp, 1);
		if (rc == 0)
			break;
d767 1
a767 7
		return (1);

	default:
		break;
	}

	return (0);
@


1.15
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.14 2008/12/21 21:39:50 miod Exp $	*/
d238 1
a238 1
		if (tmp == NULL) {
@


1.14
log
@During early device probes, make sure to iounaccess() address ranges when
they are no longer necessary. No good reason to do so but correctness, and
then leaving correct mappings after probe might hide bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.13 2007/12/28 20:44:39 miod Exp $	*/
d494 1
a494 1
	return (LCG_FB_ADDR + offset) >> PGSHIFT;
@


1.13
log
@If initializing a frame buffer as glass console fails, instead of an invisible
panic (for you ichc fans out there), disable the wscons console and force a
console device reselection, which ends up in picking a serial console.

This should not happen, but just in case, it's a less rude behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.12 2007/12/18 19:39:27 miod Exp $	*/
d719 1
d735 1
d745 1
d749 7
a755 4
		if ((*ch & 0x01) == 0)
			break;
		*ch = 0x00;
		if ((*ch & 0x01) != 0)
d778 1
a778 1
	vaddr_t tmp;
d782 2
a783 2
	tmp = virtual_avail;
	ioaccess(tmp, vax_trunc_page(LCG_CONFIG_ADDR), 1);
d785 2
a786 1
	    (tmp + (LCG_CONFIG_ADDR & VAX_PGOFSET));
d794 1
a795 1
	ioaccess((vaddr_t)ss->ss_addr, LCG_FB_ADDR, ss->ss_fbsize / VAX_NBPG);
d798 1
a799 1
	ioaccess(ss->ss_reg, LCG_REG_ADDR, LCG_REG_SIZE / VAX_NBPG);
d802 2
a804 2
	ioaccess((vaddr_t)ss->ss_lut, LCG_LUT_ADDR + LCG_LUT_OFFSET,
	    LCG_LUT_SIZE / VAX_NBPG);
d809 5
a813 1
	if (lcg_setup_screen(ss) != 0)
d815 1
@


1.12
log
@Better probe routine for lcg, now that I found the magic bit on KA46.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.11 2007/10/01 16:11:19 krw Exp $	*/
d709 1
a709 1
void	lcgcninit(void);
d767 1
a767 1
void
d801 1
a801 1
	/* this had better not fail as we can't recover there */
d803 1
a803 1
		panic(__func__);
d808 2
@


1.11
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.10 2006/11/29 12:13:54 miod Exp $	*/
d161 3
a163 1
	int depth, missing;
d165 4
d175 3
d179 1
a179 3
		if (va->va_paddr != LCG_REG_ADDR)
			return (0);

d184 2
a185 3
	 * Check the configuration register.
	 * This is done to sort out empty frame buffer slots, since the video
	 * memory test sometimes passes!
d190 1
a190 1
	if (depth < 0)	/* no frame buffer */
d193 1
d211 1
d717 1
d719 1
d723 3
d736 1
a736 1
			break;	/* unsupported configuration */
d738 1
d751 1
@


1.10
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.9 2006/08/22 21:05:03 miod Exp $	*/
d250 1
a250 1
		ss = malloc(sizeof(struct lcg_screen), M_DEVBUF, M_NOWAIT);
a254 1
		bzero(ss, sizeof(struct lcg_screen));
@


1.9
log
@More register defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.8 2006/08/06 15:04:22 miod Exp $	*/
d298 1
@


1.8
log
@Replace magic numbers with adequate #defines, support vsync disabling in the
burner routine, and do the colormap updates during vertical retrace, instead
of using a fixed delay.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.7 2006/08/05 22:04:53 miod Exp $	*/
d69 1
d72 1
a72 2
#define	LCG_CONFIG_ADDR	0x200f0010	/* configuration register */
#define	LCG_LUT_ADDR	0x21800800	/* colormap */
d277 2
a278 2
		ss->ss_lut = (u_int8_t *)vax_map_physmem(LCG_LUT_ADDR,
		    LCG_LUT_SIZE / VAX_NBPG);
a413 2
	lcg_resetcmap(ss);

d421 2
d779 1
a779 1
	ss->ss_lut = (u_int8_t *)virtual_avail;
d781 2
a782 1
	ioaccess((vaddr_t)ss->ss_lut, LCG_LUT_ADDR, LCG_LUT_SIZE / VAX_NBPG);
@


1.7
log
@Colormap ioctls, at last.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.6 2006/08/03 18:46:50 miod Exp $	*/
d532 6
a537 3
		vidcfg |= 1 << 1;
	else
		vidcfg &= ~(1 << 1);
d627 1
a627 1
	(lutptr)++;							\
d629 1
a629 1
	*(lutptr)++ = 1;						\
d631 1
a631 1
	*(lutptr)++ = 1;						\
d633 1
a633 1
	*(lutptr)++ = 1;						\
a645 1
	vidcfg = lcg_read_reg(ss, LCG_REG_VIDEO_CONFIG);
d657 14
a670 3
	vidcfg &= ~((1 << 5) | (3 << 8) | (1 << 11));
	if (ss->ss_width == 1280)	/* XXX is this right? */
		vidcfg |= (0 << 5) | (2 << 8) | (0 << 11);
d672 2
a673 1
		vidcfg |= (1 << 5) | (1 << 8) | (1 << 11);
d675 1
a675 1
	lcg_write_reg(ss, LCG_REG_LUT_CONSOLE_SEL, 1);
d677 5
a681 2
	DELAY(1000);	/* XXX should wait on a status bit */
	lcg_write_reg(ss, LCG_REG_LUT_CONSOLE_SEL, 0);
@


1.6
log
@A more reliable way to find out that the card is not there.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.5 2006/08/01 18:49:42 miod Exp $	*/
d88 1
d143 2
d146 1
a147 1
void	lcg_set_lut_entry(volatile u_int8_t *, const u_char *, u_int, u_int);
a402 6
	 * We can let rasops select our font here, as we do not need to
	 * use a font with a different bit order than rasops' defaults,
	 * unlike smg.
	 */

	/*
d432 2
d453 5
d459 6
a464 1
		break;	/* XXX TBD */
d554 1
a554 1
 * Fill the given colormap (LUT) entry.
d556 38
a593 3
void
lcg_set_lut_entry(volatile u_int8_t *lutptr, const u_char *cmap, u_int idx,
    u_int shift)
d595 24
a618 8
	lutptr++;
	*lutptr++ = idx;
	*lutptr++ = 1;
	*lutptr++ = (*cmap++) >> shift;
	*lutptr++ = 1;
	*lutptr++ = (*cmap++) >> shift;
	*lutptr++ = 1;
	*lutptr++ = (*cmap++) >> shift;
d621 13
d635 1
a635 1
lcg_resetcmap(struct lcg_screen *ss)
d637 1
a637 1
	const u_char *color;
d642 1
d644 1
a644 1
	color = rasops_cmap;
d648 1
a648 3
			lcg_set_lut_entry(lutptr, color, i, 0);
			lutptr += 8;
			color += 3;
d651 2
a652 10
		for (i = 0; i < 8; i++) {
			lcg_set_lut_entry(lutptr, color, i, 4);
			lutptr += 8;
			color += 3;
		}
		color = rasops_cmap + 0xf8 * 3;
		for (i = 0xf8; i < 0x100; i++) {
			lcg_set_lut_entry(lutptr, color, i & 0x0f, 4);
			lutptr += 8;
			color += 3;
d665 12
@


1.5
log
@If there is VRAM at the lcg address, but we can't make sense of the
configuration register, match anyway and bail out during attach, printing
the configuration register value, so that this gets noticed and the code
can be made aware of this particular model.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.4 2006/07/29 15:11:57 miod Exp $	*/
d142 1
a142 1
u_int	lcg_probe_screen(u_int32_t, u_int *, u_int *);
a156 1
#if 0
d158 1
a158 2
	int depth;
#endif
a172 1
#if 0	/* better match and report unrecognized models for now */
d174 3
a176 1
	 * Check for a recognized configuration.
d181 1
a181 1
	if (depth == 0)
a182 1
#endif
d188 2
a189 1
	ch = (volatile u_int8_t *)va->va_addr;
d192 8
a199 3
		return (0);
	*ch = 0x00;
	if ((*ch & 0x01) != 0)
d228 2
a229 1
			printf(": can not map configuration register\n");
d235 4
a238 3
		if (lcg_probe_screen(cfg, NULL, NULL) == 0) {
			printf(": unrecognized configuration register %08x\n",
			    cfg);
d313 1
a313 1
u_int
d321 2
d338 1
a338 1
			return (0);
d343 2
d363 1
a363 1
			return (0);
d629 1
a629 1
		if (lcg_probe_screen(cfg, NULL, NULL) == 0)
@


1.4
log
@At attach() time, do not simply trust the L3 switch to know if we are the
console, check for cn_tab pointing to wsdisplay as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.3 2006/07/29 14:18:57 miod Exp $	*/
d157 1
d160 1
d175 1
d184 1
d210 1
d215 22
d248 1
a248 8
		tmp = vax_map_physmem(LCG_CONFIG_ADDR, 1);
		if (tmp == NULL) {
			printf(": can not map configuration register\n");
			goto fail1;
		}
		ss->ss_cfg = *(volatile u_int32_t *)tmp;
		vax_unmap_physmem(tmp, 1);

@


1.3
log
@Rewrite glass console detection and initialization code, it's simpler and
will not allocate frame buffer resources at probe time. A few buglets fixed
while doing so.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.2 2006/07/24 22:18:09 miod Exp $	*/
d61 2
d207 1
d209 1
a209 1
	console = (vax_confdata & 0x100) == 0;
@


1.2
log
@Make sure the mapped frame buffer area is a multiple of the logical page
size, for mmap to be happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.1 2006/07/24 20:35:08 miod Exp $	*/
d59 2
a61 1
#include <dev/wscons/wscons_callbacks.h>
a378 1
	lcg_resetcmap(ss);
d384 2
d570 3
a572 2
#include <dev/cons.h>
cons_decl(lcg);
d574 2
a575 1
#include "dzkbd.h"
d577 2
a578 13
#include <vax/qbus/dzreg.h>
#include <vax/qbus/dzvar.h>
#include <vax/dec/dzkbdvar.h>


/*
 * Called very early to setup the glass tty as console.
 * Because it's called before the VM system is initialized, virtual memory
 * for the framebuffer can be stolen directly without disturbing anything.
 */
void
lcgcnprobe(cndev)
	struct  consdev *cndev;
a579 1
	struct lcg_screen *ss = &lcg_consscr;
d581 1
a581 1
	extern int getmajor(void *);	/* conf.c */
d583 1
d592 3
a594 2
		ioaccess(tmp, LCG_CONFIG_ADDR, 1);
		ss->ss_cfg = *(volatile u_int32_t *)tmp;
d596 1
a596 3
		ss->ss_depth = lcg_probe_screen(ss->ss_cfg,
		    &ss->ss_width, &ss->ss_height);
		if (ss->ss_depth == 0)
d599 12
a610 2
		ss->ss_fbsize =
		    roundup(ss->ss_width * ss->ss_height, VAX_NBPG);
d612 1
a612 18
		ss->ss_addr = (caddr_t)virtual_avail;
		virtual_avail += ss->ss_fbsize;
		ioaccess((vaddr_t)ss->ss_addr, LCG_FB_ADDR,
		    ss->ss_fbsize / VAX_NBPG);

		ss->ss_reg = virtual_avail;
		virtual_avail += LCG_REG_SIZE;
		ioaccess(ss->ss_reg, LCG_REG_ADDR,
		    LCG_REG_SIZE / VAX_NBPG);

		ss->ss_lut = (u_int8_t *)virtual_avail;
		virtual_avail += LCG_LUT_SIZE;
		ioaccess((vaddr_t)ss->ss_lut, LCG_LUT_ADDR,
		    LCG_LUT_SIZE / VAX_NBPG);

		cndev->cn_pri = CN_INTERNAL;
		cndev->cn_dev = makedev(getmajor(wsdisplayopen), 0);
		break;
d617 2
d621 5
d627 1
a627 1
lcgcninit(struct consdev *cndev)
d630 2
a633 3
	extern void lkccninit(struct consdev *);
	extern int lkccngetc(dev_t);
	extern int dz_vsbus_lk201_cnattach(int);
d635 25
a659 1
	/* mappings have been done in lcgcnprobe() */
d661 1
a661 1
		return;
a665 4

#if NDZKBD > 0
	dzkbd_cnattach(0); /* Connect keyboard and screen together */
#endif
@


1.1
log
@Add a wsdisplay driver for the frame buffer found on VS4000/60 and VLC
systems, based on Blaz Antonic's work and adjusted to fit modern wscons
requirements; currently running as a dumb frame buffer, acceleration code
going in soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcg.c,v 1.10 2006/07/23 19:17:23 miod Exp $	*/
d228 1
a228 1
		    roundup(ss->ss_width * ss->ss_height, VAX_NBPG);
@

