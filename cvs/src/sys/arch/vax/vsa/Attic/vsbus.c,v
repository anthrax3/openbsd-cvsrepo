head	1.25;
access;
symbols
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.18
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.10
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.14
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.12
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.8
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.6
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.4
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.03.09.16.28.50;	author deraadt;	state dead;
branches;
next	1.24;
commitid	OSDG2O3Cgeifnf1W;

1.24
date	2015.09.13.12.31.35;	author miod;	state Exp;
branches;
next	1.23;
commitid	crsKIfL2CNapLk7x;

1.23
date	2011.09.11.19.29.01;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.26.21.47.25;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.30.20.45.31;	author martin;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.15.22.40.07;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.13.21.12.06;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.20.19.08.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.16.22.40.44;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.04.16.59.31;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.26.13.06.26;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.02.23.42.13;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.11.06.34.38;	author hugh;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.11.06.19.19;	author bjc;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.27.00.52.07;	author bjc;	state Exp;
branches;
next	1.3;

1.3
date	97.09.10.12.08.37;	author maja;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	97.05.29.00.05.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.25.33;	author maja;	state Exp;
branches;
next	;

1.3.12.1
date	2001.05.14.21.39.22;	author niklas;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2001.11.13.21.04.19;	author niklas;	state Exp;
branches;
next	1.3.12.4;

1.3.12.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.3.12.5;

1.3.12.5
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.3.12.6;

1.3.12.6
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	1.3.12.7;

1.3.12.7
date	2004.06.05.23.11.03;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.28;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.05.19.21.46.10;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: vsbus.c,v 1.24 2015/09/13 12:31:35 miod Exp $ */
/*	$NetBSD: vsbus.c,v 1.29 2000/06/29 07:14:37 mrg Exp $ */
/*
 * Copyright (c) 1996, 1999 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by Bertram Barth.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/syslog.h>
#include <sys/stat.h>

#include <uvm/uvm_extern.h>

#define _VAX_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <machine/pte.h>
#include <machine/sid.h>
#include <machine/scb.h>
#include <machine/cpu.h>
#include <machine/trap.h>
#include <machine/nexus.h>

#include <machine/uvax.h>
#include <machine/ka410.h>
#include <machine/ka420.h>

#include <machine/vsbus.h>

int	vsbus_match(struct device *, struct cfdata *, void *);
void	vsbus_attach(struct device *, struct device *, void *);
int	vsbus_print(void *, const char *);
int	vsbus_search(struct device *, void *, void *);

static struct vax_bus_dma_tag vsbus_bus_dma_tag = {
	NULL,
	0,
	0,
	0,
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};

extern struct vax_bus_space vax_mem_bus_space;
static SIMPLEQ_HEAD(, vsbus_dma) vsbus_dma;

struct	cfattach vsbus_ca = { 
	sizeof(struct vsbus_softc), (cfmatch_t)vsbus_match, vsbus_attach
};

struct  cfdriver vsbus_cd = {
	    NULL, "vsbus", DV_DULL
};

int	oldvsbus;

int
vsbus_print(aux, name)
	void *aux;
	const char *name;
{
	struct vsbus_attach_args *va = aux;

	printf(" csr 0x%lx vec %d ipl %x maskbit %d", va->va_paddr,
	    va->va_cvec & 511, va->va_br, va->va_maskno - 1);
	return(UNCONF); 
}

int
vsbus_match(parent, cf, aux)
	struct	device	*parent;
	struct	cfdata	*cf;
	void	*aux;
{
	struct mainbus_attach_args *maa = aux;

	if (maa->maa_bustype == VAX_VSBUS)
		return 1;
	return 0;
}

void
vsbus_attach(parent, self, aux)
	struct	device	*parent, *self;
	void	*aux;
{
	struct	vsbus_softc *sc = (void *)self;
	int dbase, dsize;

	printf("\n");

	sc->sc_dmatag = vsbus_bus_dma_tag;

	switch (vax_boardtype) {
#if VAX49 || VAX53
	case VAX_BTYP_1303:
	case VAX_BTYP_49:
		sc->sc_vsregs = vax_map_physmem(VS_REGS_KA49, 1);
		sc->sc_intreq = (char *)sc->sc_vsregs + 12;
		sc->sc_intclr = (char *)sc->sc_vsregs + 12;
		sc->sc_intmsk = (char *)sc->sc_vsregs + 8;
		vsbus_dma_init(sc, 8192);
		break;
#endif

#if VAX46 || VAX48
	case VAX_BTYP_48:
	case VAX_BTYP_46:
		sc->sc_vsregs = vax_map_physmem(VS_REGS, 1);
		sc->sc_intreq = (char *)sc->sc_vsregs + 15;
		sc->sc_intclr = (char *)sc->sc_vsregs + 15;
		sc->sc_intmsk = (char *)sc->sc_vsregs + 12;
		vsbus_dma_init(sc, 32768);
		break;
#endif

	default:
		sc->sc_vsregs = vax_map_physmem(VS_REGS, 1);
		sc->sc_intreq = (char *)sc->sc_vsregs + 15;
		sc->sc_intclr = (char *)sc->sc_vsregs + 15;
		sc->sc_intmsk = (char *)sc->sc_vsregs + 12;
		if (vax_boardtype == VAX_BTYP_410) {
			dbase = KA410_DMA_BASE;
			dsize = KA410_DMA_SIZE;
		} else {
			dbase = KA420_DMA_BASE;
			dsize = KA420_DMA_SIZE;
			*(char *)(sc->sc_vsregs + 0xe0) = 1; /* Big DMA */
		}
		sc->sc_dmasize = dsize;
		sc->sc_dmaaddr = uvm_km_valloc(kernel_map, dsize);
		ioaccess(sc->sc_dmaaddr, dbase, dsize/VAX_NBPG);
		break;
	}

	SIMPLEQ_INIT(&vsbus_dma);
	/*
	 * First: find which interrupts we won't care about.
	 * There are interrupts that interrupt on a periodic basic
	 * that we don't want to interfere with the rest of the 
	 * interrupt probing.
	 */
	*sc->sc_intmsk = 0;
	*sc->sc_intclr = 0xff;
	DELAY(1000000); /* Wait a second */
	sc->sc_mask = *sc->sc_intreq;

#if VAX48
	/*
	 * It's possible for the 4000/VLC to generate an DZ-11 rx interrupt
	 * (0x20) during the delay period, unmask that bit.
	 */
	if (vax_boardtype == VAX_BTYP_48)
		sc->sc_mask &= ~0x20;
#endif

	printf("%s: interrupt mask %x\n", self->dv_xname, sc->sc_mask);

	/*
	 * now check for all possible devices on this "bus"
	 */
	config_search(vsbus_search, self, NULL);

	/* Autoconfig finished, enable interrupts */
	*sc->sc_intmsk = ~sc->sc_mask;
}

int
vsbus_search(parent, cfd, aux)
	struct device *parent;
	void *cfd;
	void *aux;
{
	struct	vsbus_softc *sc = (void *)parent;
	struct	vsbus_attach_args va;
	struct	cfdata *cf = cfd;
	int rc, i, vec, br;
	u_char c;

	va.va_paddr = cf->cf_loc[0];
	va.va_addr = vax_map_physmem(va.va_paddr, 1);
	va.va_dmat = &sc->sc_dmatag;
	va.va_iot = &vax_mem_bus_space;

	*sc->sc_intmsk = 0;
	*sc->sc_intclr = 0xff;
	scb_vecref(0, 0); /* Clear vector ref */

	rc = (*cf->cf_attach->ca_match) (parent, cf, &va);
	vax_unmap_physmem(va.va_addr, 1);
	c = *sc->sc_intreq & ~sc->sc_mask;

	if (rc == 0)
		goto forgetit;
	if (rc > 10)
		c = sc->sc_mask; /* Fooling interrupt */
	else if (c == 0)
		goto forgetit;

	*sc->sc_intmsk = c;
	DELAY(1000);
	*sc->sc_intmsk = 0;
	va.va_maskno = ffs((u_int)c);
	i = scb_vecref(&vec, &br);
	if (i == 0)
		goto fail;
	if (vec == 0)
		goto fail;

	/*
	 * For proper splassert operation, we need to know if we are on
	 * a vsbus system where its devices interrupt at level 0x14 instead
	 * of 0x15.
	 */
	if (br == 0x14)
		oldvsbus = 1;

	va.va_br = br;
	va.va_cvec = vec;
	va.va_dmaaddr = sc->sc_dmaaddr;
	va.va_dmasize = sc->sc_dmasize;
	*sc->sc_intmsk = c; /* Allow interrupts during attach */
	config_attach(parent, cf, &va, vsbus_print);
	*sc->sc_intmsk = 0;
	return rc;

fail:
	printf("%s%d at %s csr 0x%lx %s\n",
	    cf->cf_driver->cd_name, cf->cf_unit, parent->dv_xname,
	    cf->cf_loc[0], (i ? "zero vector" : "didn't interrupt"));
forgetit:
	return 0;
}

/*
 * Sets a new interrupt mask. Returns the old one.
 * Works like spl functions.
 */
unsigned char
vsbus_setmask(mask)
	unsigned char mask;
{
	struct vsbus_softc *sc;
	unsigned char ch;

	if (vsbus_cd.cd_ndevs == 0)
		return 0;
	sc = vsbus_cd.cd_devs[0];

	ch = *sc->sc_intmsk;
	*sc->sc_intmsk = mask;
	return ch;
}

/*
 * Clears the interrupts in mask.
 */
void
vsbus_clrintr(mask)
	unsigned char mask;
{
	struct vsbus_softc *sc;

	if (vsbus_cd.cd_ndevs == 0)
		return;
	sc = vsbus_cd.cd_devs[0];

	*sc->sc_intclr = mask;
}

/*
 * Copy data from/to a user process' space from the DMA area.
 * Use the physical memory directly.
 */
void
vsbus_copytoproc(struct proc *p, caddr_t from, caddr_t to, int len)
{
	pt_entry_t *pte;
	paddr_t pa;

	if ((vaddr_t)to & KERNBASE) { /* In kernel space */
		bcopy(from, to, len);
		return;
	}
	pte = uvtopte(trunc_page((vaddr_t)to), (&p->p_addr->u_pcb));
	if ((vaddr_t)to & PGOFSET) {
		int cz = round_page((vaddr_t)to) - (vaddr_t)to;

		pa = ((*pte & PG_FRAME) << VAX_PGSHIFT) |
		    (NBPG - cz) | KERNBASE;
		bcopy(from, (caddr_t)pa, min(cz, len));
		from += cz;
		to += cz;
		len -= cz;
		pte += 8; /* XXX */
	}
	while (len > 0) {
		pa = ((*pte & PG_FRAME) << VAX_PGSHIFT) | KERNBASE;
		bcopy(from, (caddr_t)pa, min(NBPG, len));
		from += NBPG;
		to += NBPG;
		len -= NBPG;
		pte += 8; /* XXX */
	}
}

void
vsbus_copyfromproc(struct proc *p, caddr_t from, caddr_t to, int len)
{
	pt_entry_t *pte;
	paddr_t pa;

	if ((vaddr_t)from & KERNBASE) { /* In kernel space */
		bcopy(from, to, len);
		return;
	}
	pte = uvtopte(trunc_page((vaddr_t)from), (&p->p_addr->u_pcb));
	if ((vaddr_t)from & PGOFSET) {
		int cz = round_page((vaddr_t)from) - (vaddr_t)from;

		pa = ((*pte & PG_FRAME) << VAX_PGSHIFT) |
		    (NBPG - cz) | KERNBASE;
		bcopy((caddr_t)pa, to, min(cz, len));
		from += cz;
		to += cz;
		len -= cz;
		pte += 8; /* XXX */
	}
	while (len > 0) {
		pa = ((*pte & PG_FRAME) << VAX_PGSHIFT) | KERNBASE;
		bcopy((caddr_t)pa, to, min(NBPG, len));
		from += NBPG;
		to += NBPG;
		len -= NBPG;
		pte += 8; /* XXX */
	}
}

/* 
 * There can only be one user of the DMA area on VS2k/VS3100 at one
 * time, so keep track of it here.
 */ 
static int vsbus_active = 0;

void
vsbus_dma_start(struct vsbus_dma *vd)
{
 
	SIMPLEQ_INSERT_TAIL(&vsbus_dma, vd, vd_q);

	if (vsbus_active == 0)
		vsbus_dma_intr();
}
 
void
vsbus_dma_intr(void)
{	
	struct vsbus_dma *vd;
	
	vd = SIMPLEQ_FIRST(&vsbus_dma); 
	if (vd == NULL) {
		vsbus_active = 0;
		return;
	}
	vsbus_active = 1;
	SIMPLEQ_REMOVE_HEAD(&vsbus_dma, vd_q);
	(*vd->vd_go)(vd->vd_arg);
}

@


1.24
log
@Locators are long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.23 2011/09/11 19:29:01 miod Exp $ */
@


1.23
log
@Define symbolic constants for the addresses of the vsbus devices on
512KB PROM systems (e.g. KA49), or 256KB PROM systems built after KA49
(e.g. KA5[234]), and use them instead of pouring magic numbers all over the (md)
tree.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.22 2011/08/26 21:47:25 miod Exp $ */
d276 1
a276 1
	printf("%s%d at %s csr 0x%x %s\n",
@


1.22
log
@Make vsbus_search() return the value of the cf_match function it is a wrapper
for, instead of zero. Makes verbose autoconf output meaningful again.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.21 2010/11/18 21:13:19 miod Exp $ */
d146 1
a146 1
		sc->sc_vsregs = vax_map_physmem(0x25c00000, 1);
@


1.21
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.20 2008/08/30 20:45:31 martin Exp $ */
d225 1
a225 1
	int i, vec, br;
d237 1
a237 1
	i = (*cf->cf_attach->ca_match) (parent, cf, &va);
d241 1
a241 1
	if (i == 0)
d243 1
a243 1
	if (i > 10)
d273 1
a273 1
	return 0;
@


1.20
log
@replace TRUNC_PAGE by trunc_page and ROUND_PAGE by round_page
plus cast to vaddr_t where necassary

from Miod's todo list

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.19 2008/08/15 22:40:07 miod Exp $ */
a44 1
#include <sys/dkstat.h>
@


1.19
log
@Remove unused and incomplete vax_bus_t enum, and unused vaxbus_dma_get_tag()
macro and related function pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.18 2006/12/13 21:12:06 miod Exp $ */
d334 1
a334 1
	pte = uvtopte(TRUNC_PAGE(to), (&p->p_addr->u_pcb));
d336 1
a336 1
		int cz = ROUND_PAGE(to) - (vaddr_t)to;
d366 1
a366 1
	pte = uvtopte(TRUNC_PAGE(from), (&p->p_addr->u_pcb));
d368 1
a368 1
		int cz = ROUND_PAGE(from) - (vaddr_t)from;
@


1.18
log
@Missing "break;" for the KA46/KA48 case, fortunately caused no harm but a
waste of 128KB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.17 2006/07/20 19:08:15 miod Exp $ */
d73 1
d77 1
a77 3
	0,
	0,
	0,
@


1.17
log
@Kill an autoconf abuse introduced with Cheetah support, and pass real
attachment information to mainbus children. Makes it much cleaner to
attach both ibus and vsbus on those machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.16 2006/07/16 22:40:44 miod Exp $ */
a63 1
#include <machine/ka43.h>
a71 3
void	ka410_attach(struct device *, struct device *, void *);
void	ka43_attach(struct device *, struct device *, void *);

d164 1
@


1.16
log
@Fix splassert false positives on older VAXstation with devices wired to
ipl 0x14 instead of the expected 0x15.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.15 2004/07/07 23:10:46 deraadt Exp $ */
d129 3
a131 6
#if VAX53
	/* Kludge: VAX53 is... special */
	if (vax_boardtype == VAX_BTYP_1303 && (int)aux == 1)
		return 1; /* Hack */
#endif
	if (vax_bustype == VAX_VSBUS)
@


1.15
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.14 2004/05/04 16:59:31 grange Exp $ */
d109 2
d265 8
@


1.14
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.13 2003/11/10 21:05:06 miod Exp $ */
d116 1
a116 1
	printf(" csr 0x%lx vec 0x%x ipl %x maskbit %d", va->va_paddr,
@


1.13
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.12 2003/06/26 13:06:26 miod Exp $ */
d412 1
a412 1
	SIMPLEQ_REMOVE_HEAD(&vsbus_dma, vd, vd_q);
@


1.12
log
@Compile the vax kernel with -Wmissing-prototypes -Wstrict-prototypes now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.11 2003/04/02 23:42:13 jason Exp $ */
d324 1
a324 1
	struct pte *pte;
d335 2
a336 1
		pa = (pte->pg_pfn << VAX_PGSHIFT) | (NBPG - cz) | KERNBASE;
d344 1
a344 1
		pa = (pte->pg_pfn << VAX_PGSHIFT) | KERNBASE;
d356 1
a356 1
	struct pte *pte;
d367 2
a368 1
		pa = (pte->pg_pfn << VAX_PGSHIFT) | (NBPG - cz) | KERNBASE;
d376 1
a376 1
		pa = (pte->pg_pfn << VAX_PGSHIFT) | KERNBASE;
@


1.11
log
@Don't allow the DZ-11 RX interrupt to be masked (if a DZ-11 interrupt was seen
during the "wait for a second looking for annoying interrupts" period, it
would mask it off... oops =)
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.10 2002/01/16 20:50:17 miod Exp $ */
a107 8

/* dummy interrupt handler for use during autoconf */
void
vsbus_intr(arg)
	void *arg;
{
	return;
}
@


1.10
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.9 2001/11/06 19:53:17 miod Exp $ */
d209 10
d220 1
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.8 2001/09/19 20:50:57 mickey Exp $ */
a43 1
#include <sys/map.h>
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.10 2002/01/16 20:50:17 miod Exp $ */
d44 1
@


1.9.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a208 10

#if VAX48
	/*
	 * It's possible for the 4000/VLC to generate an DZ-11 rx interrupt
	 * (0x20) during the delay period, unmask that bit.
	 */
	if (vax_boardtype == VAX_BTYP_48)
		sc->sc_mask &= ~0x20;
#endif

a209 1

@


1.8
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.7 2001/08/25 13:33:37 hugh Exp $ */
a50 1
#include <vm/vm.h>
@


1.7
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.6 2001/02/11 06:34:38 hugh Exp $ */
d52 1
a52 1
#include <vm/vm_kern.h>
@


1.6
log
@Pick up a NetBSD hack to attach Cheetah to vsbus as well as ibus.
High kludge factor, but the payoff is vsbus scsi for free.
Most of the work is by Michael Kukat and ragge, with a few other
synchronisations thrown in.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.5 2000/10/11 06:19:19 bjc Exp $ */
d70 4
a73 4
int	vsbus_match	__P((struct device *, struct cfdata *, void *));
void	vsbus_attach	__P((struct device *, struct device *, void *));
int	vsbus_print	__P((void *, const char *));
int	vsbus_search	__P((struct device *, void *, void *));
d75 2
a76 2
void	ka410_attach	__P((struct device *, struct device *, void *));
void	ka43_attach	__P((struct device *, struct device *, void *));
@


1.5
log
@update these to work with cleaner vsbus dma; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.4 2000/04/27 00:52:07 bjc Exp $ */
d54 1
a54 1
#define	_VAX_BUS_DMA_PRIVATE
d70 1
a70 1
int		vsbus_match		__P((struct device *, struct cfdata *, void *));
d72 2
a73 2
int		vsbus_print		__P((void *, const char *));
int		vsbus_search	__P((struct device *, void *, void *));
d78 1
a78 1
struct vax_bus_dma_tag vsbus_bus_dma_tag = {
d134 1
a134 1
	struct 	cfdata	*cf;
d137 5
a153 1
	int		discard;
d160 2
a161 1
#if VAX49
d172 7
a178 7
    case VAX_BTYP_48:
    case VAX_BTYP_46:
        sc->sc_vsregs = vax_map_physmem(VS_REGS, 1);
        sc->sc_intreq = (char *)sc->sc_vsregs + 15;
        sc->sc_intclr = (char *)sc->sc_vsregs + 15;
        sc->sc_intmsk = (char *)sc->sc_vsregs + 12;
        vsbus_dma_init(sc, 32768);
a180 1
		
d210 2
a211 3
	sc->sc_mask = discard = *sc->sc_intreq;
	printf("%s: interrupt mask %x\n", self->dv_xname, discard);

d217 2
a218 1
	*sc->sc_intmsk = sc->sc_mask ^ discard;
d223 3
a225 3
	struct device	*parent;
	void 	*cfd;
	void 	*aux;
d227 5
a231 5
	struct	vsbus_softc 		*sc = (void *)parent;
	struct	vsbus_attach_args 	va;
	struct 	cfdata	*cf = cfd;
	int 	i, vec, br;
	u_char	c;
a241 1
	va.va_ivec = vsbus_intr;
d245 1
a252 2
	va.va_maskno = ffs((u_int)c);

d256 1
a256 1

d262 1
a262 2
	
	scb_vecalloc(vec, va.va_ivec, va.va_vecarg, SCB_ISTACK);
a264 1
	va.confargs = aux;		
d267 1
a267 1

d269 2
a270 1
	return 1;
d273 1
a273 1
	printf("%s%d at %s csr %x %s\n",
a279 51
#if 0
static volatile struct dma_lock {
    int dl_locked;
    int dl_wanted;
    void    *dl_owner;
    int dl_count;
} dmalock = { 0, 0, NULL, 0 };

int
vsbus_lockDMA(ca)
    struct confargs *ca;
{
    while (dmalock.dl_locked) {
        dmalock.dl_wanted++;
        sleep((caddr_t)&dmalock, PRIBIO);   /* PLOCK or PRIBIO ? */
        dmalock.dl_wanted--;
    }
    dmalock.dl_locked++;
    dmalock.dl_owner = ca;

    /*
     * no checks yet, no timeouts, nothing...
     */

#ifdef DEBUG
    if ((++dmalock.dl_count % 1000) == 0)
        printf("%d locks, owner: %s\n", dmalock.dl_count, ca->ca_name);
#endif
    return (0);
}

int
vsbus_unlockDMA(ca)
    struct confargs *ca;
{
    if (dmalock.dl_locked != 1 || dmalock.dl_owner != ca) {
        printf("locking-problem: %d, %s\n", dmalock.dl_locked,
               (dmalock.dl_owner ? dmalock.dl_owner : "null"));
        dmalock.dl_locked = 0;
        return (-1);
    }
    dmalock.dl_owner = NULL;
    dmalock.dl_locked = 0;
    if (dmalock.dl_wanted) {
        wakeup((caddr_t)&dmalock);
    }
    return (0);
}
#endif


d288 1
a288 1
	struct vsbus_softc *sc = vsbus_cd.cd_devs[0];
d291 4
d307 5
a311 1
	struct vsbus_softc *sc = vsbus_cd.cd_devs[0];
d321 1
a321 4
vsbus_copytoproc(p, from, to, len)
	struct proc *p;
	caddr_t from, to;
	int len;
d326 4
a329 4
    if ((long)to & KERNBASE) { /* In kernel space */
        bcopy(from, to, len);
        return;
    }
d352 1
a352 4
vsbus_copyfromproc(p, from, to, len)
	struct proc *p;
	caddr_t from, to;
	int len;
d357 4
a360 4
    if ((long)from & KERNBASE) { /* In kernel space */
        bcopy(from, to, len);
        return;
    }
d391 1
@


1.4
log
@sync with netbsd; working ncr5380 driver, saner vsbus code
@
text
@d1 2
a2 2
/*	$OpenBSD: vsbus.c,v 1.3 1997/09/10 12:08:37 maja Exp $ */
/*	$NetBSD: vsbus.c,v 1.20 1999/10/22 21:10:12 ragge Exp $ */
d52 1
d100 3
d148 1
a149 1
	vaddr_t temp;
d153 2
d156 1
d158 5
a162 4
		temp = vax_map_physmem(0x25c00000, 1);
		sc->sc_intreq = (char *)temp + 12;
		sc->sc_intclr = (char *)temp + 12;
		sc->sc_intmsk = (char *)temp + 8;
d164 11
d176 1
d178 15
a192 4
		temp = vax_map_physmem(VS_REGS, 1);
		sc->sc_intreq = (char *)temp + 15;
		sc->sc_intclr = (char *)temp + 15;
		sc->sc_intmsk = (char *)temp + 12;
d196 1
d231 2
a232 1
	va.va_dmat = &vsbus_bus_dma_tag;
d265 2
d279 1
d327 1
d371 4
d405 4
d429 31
@


1.3
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: vsbus.c,v 1.2 1997/05/29 00:05:36 niklas Exp $ */
/*	$NetBSD: vsbus.c,v 1.6 1997/03/22 23:05:31 ragge Exp $ */
d4 1
a4 1
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
d51 4
d64 1
d69 1
a69 4
#define trace(x)
#define debug(x)

int	vsbus_match	__P((struct device *, void *, void *));
d71 2
a72 1
int	vsbus_print	__P((void *, const char *));
d77 20
a96 2
struct	cfdriver vsbus_cd = { 
	NULL, "vsbus", DV_DULL 
d98 1
d100 1
a100 1
	sizeof(struct device), vsbus_match, vsbus_attach
d103 2
a104 35
/*
void	vsbus_intr_register __P((struct confargs *ca, int (*)(void*), void*));
void	vsbus_intr_unregister __P((struct confargs *));
*/

void	vsbus_intr_dispatch __P((int i));

#define VSBUS_MAXDEVS	8
#define VSBUS_MAXINTR	8

struct confargs *vsbus_devs = NULL;

#ifdef VAX410
struct confargs ka410_devs[] = {
	/* name		intslot intpri intvec	intbit	ioaddr	*/
	{ "dc",		7,	7,	0x2C0,	(1<<7), KA410_SER_BASE, 
			6,	6,	0x2C4,	(1<<6), 0x01,		},
	{ "dc (xmit)",	6,	6,	0x2C4,	(1<<6), KA410_SER_BASE, },
	{ "le",		5,	5,	0x250,	(1<<5), KA410_LAN_BASE, 
			KA410_NWA_BASE, 0x00,				},
	{ "ncr",	1,	1,	0x3F8,	(1<<1), KA410_SCS_BASE,
			KA410_SCS_DADR, KA410_SCS_DCNT, KA410_SCS_DDIR,
			KA410_DMA_BASE, KA410_DMA_SIZE, 0x00,	0x07,	},
	{ "hdc",	0,	0,	0x3FC,	(1<<0), KA410_DKC_BASE, 
			0, 0, 0, 
			KA410_DMA_BASE, KA410_DMA_SIZE, 0x00,		},
#if 0
	{ "dc (recv)",	7,	7,	0x2C0,	(1<<7), KA410_SER_BASE, },
	{ "dc (xmit)",	6,	6,	0x2C4,	(1<<6), KA410_SER_BASE, },
	{ "hdc9224",	0,	0,	0x3FC,	(1<<0), KA410_DKC_BASE, },
	{ "ncr5380",	1,	1,	0x3F8,	(1<<1), KA410_SCS_BASE, },
	{ "am7990",	5,	5,	0x250,	(1<<5), KA410_LAN_BASE, },
	{ "NETOPT",	4,	4,	0x254,	(1<<4), KA410_LAN_BASE, },
#endif
	{ "" },
d107 7
a113 38
/*
 * It would be better if we could use the (provided) system config
 * information for each CPU instead of this.
 */
struct confargs ka420_devs[] = {
	{ "le",		5,	5,	0x250,	(1<<5),	KA410_LAN_BASE,
		KA410_NWA_BASE,	0x00,					},
	{ "ncr",	1,	1,	0x3F8,	(1<<1),	KA410_SCS_BASE,
			KA410_SCS_DADR,	KA410_SCS_DCNT,	KA410_SCS_DDIR,
			KA410_DMA_BASE,	KA410_DMA_SIZE,	0x00,	0x07,	},
	{ "ncr",	0,	0,	0x3FC,	(1<<0),	0x200C0180,
			0x200C01A0,	0x200C01C0,	0x200C01C4,
			KA410_DMA_BASE,	KA410_DMA_SIZE,	0x00,	0x07,	},
	{ "" },
};
#endif

#ifdef VAX43
struct confargs ka43_devs[] = {
	/* name		intslot intpri intvec	intbit	ioaddr	*/
	{ "dc",		7,	7,	0x2C0,	(1<<7), KA43_SER_BASE,	
			6,	6,	0x2C4,	(1<<6), 0x01,		},
	{ "dc (xmit)",	6,	6,	0x2C4,	(1<<6), KA43_SER_BASE,	},
	{ "le",		5,	5,	0x250,	(1<<5), KA43_LAN_BASE,	
			KA43_NWA_BASE,	0x00,				},
	{ "ncr",	1,	1,	0x3F8,	(1<<1), KA43_SC1_BASE,
			KA43_SC1_DADR,	KA43_SC1_DCNT,	KA43_SC1_DDIR,	
			KA43_DMA_BASE,	KA43_DMA_SIZE,	0x01,	0x06,	},
	{ "ncr",	0,	0,	0x3FC,	(1<<0), KA43_SC2_BASE,
			KA43_SC2_DADR,	KA43_SC2_DCNT,	KA43_SC2_DDIR,
			KA43_DMA_BASE,	KA43_DMA_SIZE,	0x01,	0x06,	},
#if 0
	{ "le (2nd)",	4,	4,	0x254,	(1<<4), 0x???,		},
	{ "NETOPT",	4,	4,	0x254,	(1<<4), 0x???,		},
#endif
	{ "" },
};
#endif
d120 1
a120 3
	struct confargs *ca = aux;

	trace(("vsbus_print(%x, %s)\n", ca->ca_name, name));
d122 3
a124 5
	if (name) {
		printf ("device %s at %s", ca->ca_name, name);
		return (UNSUPP);
	}
	return (UNCONF); 
d130 1
a130 1
	void	*cf;
d133 3
a135 59
	struct bp_conf *bp = aux;
	
	trace(("vsbus_match: bp->type = \"%s\"\n", bp->type));

	if (strcmp(bp->type, "vsbus"))
		return 0;
	/*
	 * on machines which can have it, the vsbus is always there
	 */
	if ((vax_bustype & VAX_VSBUS) == 0)
		return (0);

	return (1);
}

#if 1	/*------------------------------------------------------------*/
#if 1
#define REG(name)	short name; short X##name##X;
#else
#define REG(name)	int name;
#endif
static volatile struct {/* base address of DZ-controller: 0x200A0000 */
  REG(csr);		/* 00 Csr: control/status register */
  REG(rbuf);		/* 04 Rbuf/Lpr: receive buffer/line param reg. */
  REG(tcr);		/* 08 Tcr: transmit console register */
  REG(tdr);		/* 0C Msr/Tdr: modem status reg/transmit data reg */
  REG(lpr0);		/* 10 Lpr0: */
  REG(lpr1);		/* 14 Lpr0: */
  REG(lpr2);		/* 18 Lpr0: */
  REG(lpr3);		/* 1C Lpr0: */
} *dz = (void*)0x200A0000; 
extern int dzcnrint();
extern int dzcntint();
int hardclock_count = 0;
int
ka410_consintr_enable()
{
	vsbus_intr_enable(&ka410_devs[0]);
	vsbus_intr_enable(&ka410_devs[1]);
}

int
ka410_consRecv_intr(p)
	void *p;
{
  /* printf("ka410_consRecv_intr: hc-count=%d\n", hardclock_count); */
  dzcnrint();
  /* printf("gencnrint() returned.\n"); */
  return(0);
}

int
ka410_consXmit_intr(p)
	void *p;
{
  /* printf("ka410_consXmit_intr: hc-count=%d\n", hardclock_count); */
  dzcntint();
  /* printf("gencntint() returned.\n"); */
  return(0);
a136 1
#endif	/*------------------------------------------------------------*/
d143 3
a145 2
	struct confargs *ca;
	int i;
a147 1
	trace (("vsbus_attach()\n"));
a149 10
	case VAX_BTYP_420:
		vsbus_devs = ka420_devs;
		break;

	case VAX_BTYP_410:
		vsbus_devs = ka410_devs;
		break;

	case VAX_BTYP_43:
	case VAX_BTYP_46:
d151 4
a154 3
#ifdef VAX43
		vsbus_devs = ka43_devs;
#endif
d158 5
a162 3
		printf ("unsupported boardtype 0x%x in vsbus_attach()\n",
			vax_boardtype);
		return;
d166 10
a175 4
	 * first setup interrupt-table, so that devices can register
	 * their interrupt-routines...
	 */
	vsbus_intr_setup();	
d180 1
a180 6
	for (i=0; i<VSBUS_MAXDEVS; i++) {
		ca = &vsbus_devs[i];
		if (*ca->ca_name == '\0')
			break;
		config_found(self, (void*)ca, vsbus_print);
	}
d182 1
a182 5
	/*
	 * as long as there's no working DZ-driver, we use this dummy
	 */
	vsbus_intr_register(&ka410_devs[0], ka410_consRecv_intr, NULL);
	vsbus_intr_register(&ka410_devs[1], ka410_consXmit_intr, NULL);
a184 22
#define VSBUS_MAX_INTR	8	/* 64? */
/*
 * interrupt service routines are given an int as argument, which is
 * pushed onto stack as LITERAL. Thus the value is between 0-63.
 * This array of 64 might be oversized for now, but it's all which 
 * ever will be possible.
 */
struct vsbus_ivec {
	struct ivec_dsp intr_vec;		/* this is referenced in SCB */
	int		intr_count;		/* keep track of interrupts */
	int		intr_flags;		/* valid, etc. */
	void		(*enab)(int);		/* enable interrupt */
	void		(*disab)(int);		/* disable interrupt */
	void		(*prep)(int);		/* need pre-processing? */
	int		(*handler)(void*);	/* isr-routine to call */
	void		*hndlarg;		/* args to this routine */
	void		(*postp)(int);		/* need post-processing? */
} vsbus_ivtab[VSBUS_MAX_INTR];

/*
 * 
 */
d186 56
a241 30
vsbus_intr_setup()
{
	int i;
	struct vsbus_ivec *ip;
	extern struct ivec_dsp idsptch;		/* subr.s */

	for (i=0; i<VSBUS_MAX_INTR; i++) {
		ip = &vsbus_ivtab[i];
		bcopy(&idsptch, &ip->intr_vec, sizeof(struct ivec_dsp));
		ip->intr_vec.pushlarg = i;
		ip->intr_vec.hoppaddr = vsbus_intr_dispatch;
		ip->intr_count = 0;
		ip->intr_flags = 0;
		ip->enab = NULL;
		ip->disab = NULL;
		ip->postp = NULL;
	}
	switch (vax_boardtype) {
	case VAX_BTYP_410:
	case VAX_BTYP_420:
	case VAX_BTYP_43:
	case VAX_BTYP_46:
	case VAX_BTYP_49:
		ka410_intr_setup();
		return(0);
	default:
		printf("unsupported board-type 0x%x in vsbus_intr_setup()\n",
			vax_boardtype);
		return(1);
	}
d244 6
a249 15
int
vsbus_intr_register(ca, handler, arg)
	struct confargs *ca;
	int (*handler)(void*);
	void *arg;
{
	/* struct device *dev = arg; */
	int i = ca->ca_intslot;
	struct vsbus_ivec *ip = &vsbus_ivtab[i];

	trace (("vsbus_intr_register(%s/%d)\n", ca->ca_name, ca->ca_intslot));

	ip->handler = handler;
	ip->hndlarg = arg;
}
d252 2
a253 2
vsbus_intr_enable(ca)
	struct confargs *ca;
d255 11
a265 2
	int i = ca->ca_intslot;
	struct vsbus_ivec *ip = &vsbus_ivtab[i];
d267 5
a271 10
	trace (("vsbus_intr_enable(%s/%d)\n", ca->ca_name, ca->ca_intslot));

	/* XXX check for valid handler etc. !!! */
	if (ip->handler == NULL) {
		printf("interrupts for \"%s\"(%d) not enabled: null-handler\n",
		      ca->ca_name, ca->ca_intslot);
		return;
	}

	ip->enab(i);
d275 2
a276 14
vsbus_intr_disable(ca)
	struct confargs *ca;
{
	int i = ca->ca_intslot;
	struct vsbus_ivec *ip = &vsbus_ivtab[i];

	trace (("vsbus_intr_disable(%s/%d)\n", ca->ca_name, i));

	ip->disab(i);
}

int 
vsbus_intr_unregister(ca)
	struct confargs *ca;
d278 12
a289 7
	int i = ca->ca_intslot;
	struct vsbus_ivec *ip = &vsbus_ivtab[i];

	trace (("vsbus_intr_unregister(%s/%d)\n", ca->ca_name, i));

	ip->handler = NULL;
	ip->hndlarg = NULL;
a291 27
void
vsbus_intr_dispatch(i)
	register int i;
{
	register struct vsbus_ivec *ip = &vsbus_ivtab[i];

	trace (("vsbus_intr_dispatch(%d)", i));
	
	if (i < VSBUS_MAX_INTR && ip->handler != NULL) {
		ip->intr_count++;
		debug (("intr-count[%d] = %d\n", i, ip->intr_count));
		(ip->handler)(ip->hndlarg);
		if (ip->postp)
			(ip->postp)(i);
		return;
	}

	if (i < 0 || i >= VSBUS_MAX_INTR) {
		printf ("stray interrupt %d on vsbus.\n", i);
		return;
	}

	if (!ip->handler) {
		printf ("unhandled interrupt %d on vsbus.\n", i);
		return;
	}
}
d294 2
a295 2
 * These addresses are invalid and will be updated/corrected by
 * ka410_intr_setup(), but having them this way helps debugging
d297 10
a306 63
static volatile u_char *ka410_intmsk = (void*)KA410_INTMSK;
static volatile u_char *ka410_intreq = (void*)KA410_INTREQ;
static volatile u_char *ka410_intclr = (void*)KA410_INTCLR;

static void
ka410_intr_enable(i)
	int i;
{
	trace (("ka410_intr_enable(%d)\n", i));
	*ka410_intmsk |= (1<<i);
}

static void
ka410_intr_disable(i)
	int i;
{
	trace (("ka410_intr_disable(%d)\n", i));
	*ka410_intmsk &= ~(1<<i);
}

static void
ka410_intr_clear(i)
	int i;
{
	trace (("ka410_intr_clear(%d)\n", i));
	*ka410_intclr = (1<<i);
}

ka410_intr_setup()
{
	int i;
	struct vsbus_ivec *ip;
	void **scbP = (void*)scb;

	trace (("ka410_intr_setup()\n"));

	ka410_intmsk = (void*)uvax_phys2virt(KA410_INTMSK);
	ka410_intreq = (void*)uvax_phys2virt(KA410_INTREQ);
	ka410_intclr = (void*)uvax_phys2virt(KA410_INTCLR);

	*ka410_intmsk = 0;		/* disable all interrupts */
	*ka410_intclr = 0xFF;		/* clear all old interrupts */

	/*
	 * insert the VS2000-specific routines into ivec-table...
	 */
	for (i=0; i<8; i++) {
		ip = &vsbus_ivtab[i];
		ip->enab  = ka410_intr_enable;
		ip->disab = ka410_intr_disable;
		/* ip->postp = ka410_intr_clear; bertram XXX */
	}
	/*
	 * ...and register the interrupt-vectors in SCB
	 */
	scbP[IVEC_DC/4] = &vsbus_ivtab[0].intr_vec;
	scbP[IVEC_SC/4] = &vsbus_ivtab[1].intr_vec;
	scbP[IVEC_VS/4] = &vsbus_ivtab[2].intr_vec;
	scbP[IVEC_VF/4] = &vsbus_ivtab[3].intr_vec;
	scbP[IVEC_NS/4] = &vsbus_ivtab[4].intr_vec;
	scbP[IVEC_NP/4] = &vsbus_ivtab[5].intr_vec;
	scbP[IVEC_ST/4] = &vsbus_ivtab[6].intr_vec;
	scbP[IVEC_SR/4] = &vsbus_ivtab[7].intr_vec;
d310 1
a310 2
 *
 *
d312 3
a314 11

static volatile struct dma_lock {
	int	dl_locked;
	int	dl_wanted;
	void	*dl_owner;
	int	dl_count;
} dmalock = { 0, 0, NULL, 0 };

int
vsbus_lockDMA(ca)
	struct confargs *ca;
d316 1
a316 18
	while (dmalock.dl_locked) {
		dmalock.dl_wanted++;
		sleep((caddr_t)&dmalock, PRIBIO);	/* PLOCK or PRIBIO ? */
		dmalock.dl_wanted--;
	}
	dmalock.dl_locked++;
	dmalock.dl_owner = ca;

	/*
	 * no checks yet, no timeouts, nothing...
	 */

#ifdef DEBUG
	if ((++dmalock.dl_count % 1000) == 0)
		printf("%d locks, owner: %s\n", dmalock.dl_count, ca->ca_name);
#endif
	return (0);
}
d318 1
a318 16
int 
vsbus_unlockDMA(ca)
	struct confargs *ca;
{
	if (dmalock.dl_locked != 1 || dmalock.dl_owner != ca) {
		printf("locking-problem: %d, %s\n", dmalock.dl_locked,
		       (dmalock.dl_owner ? dmalock.dl_owner : "null"));
		dmalock.dl_locked = 0;
		return (-1);
	}
	dmalock.dl_owner = NULL;
	dmalock.dl_locked = 0;
	if (dmalock.dl_wanted) {
		wakeup((caddr_t)&dmalock);
	}
	return (0);
a320 2
/*----------------------------------------------------------------------*/
#if 0
d322 2
a323 6
 * small set of routines needed for mapping when doing pseudo-DMA,
 * quasi-DMA or virtual-DMA (choose whatever name you like).
 *
 * Once I know how VS3100 is doing real DMA (I hope it does), this
 * should be rewritten to present a general interface...
 *
d325 4
a328 6

extern u_long uVAX_physmap;

u_long
vsdma_mapin(bp, len)
	struct buf *bp;
d331 2
a332 41
	pt_entry_t *pte;	/* pointer to Page-Table-Entry */
	struct pcb *pcb;	/* pointer to Process-Controll-Block */
	pt_entry_t *xpte;
	caddr_t addr;
	int pgoff;		/* offset into 1st page */
	int pgcnt;		/* number of pages needed */
	int pfnum;
	int i;

	trace(("mapin(bp=%x, bp->data=%x)\n", bp, bp->b_data));

	addr = bp->b_data;
	pgoff = (int)bp->b_data & PGOFSET;	/* get starting offset */
	pgcnt = btoc(bp->b_bcount + pgoff) + 1; /* one more than needed */
	
	/*
	 * Get a pointer to the pte pointing out the first virtual address.
	 * Use different ways in kernel and user space.
	 */
	if ((bp->b_flags & B_PHYS) == 0) {
		pte = kvtopte(addr);
	} else {
		pcb = bp->b_proc->p_vmspace->vm_pmap.pm_pcb;
		pte = uvtopte(addr, pcb);
	}

	/*
	 * When we are doing DMA to user space, be sure that all pages
	 * we want to transfer to are mapped. WHY DO WE NEED THIS???
	 * SHOULDN'T THEY ALWAYS BE MAPPED WHEN DOING THIS???
	 */
	for (i=0; i<(pgcnt-1); i++) {
		if ((pte + i)->pg_pfn == 0) {
			int rv;
			rv = vm_fault(&bp->b_proc->p_vmspace->vm_map,
				      (unsigned)addr + i * NBPG,
				      VM_PROT_READ|VM_PROT_WRITE, FALSE);
			if (rv)
				panic("vs-DMA to nonexistent page, %d", rv);
		}
	}
d334 18
a351 10
	/*
	 * now insert new mappings for this memory area into kernel's
	 * mapping-table
	 */
	xpte = kvtopte(uVAX_physmap);
	while (--pgcnt > 0) {
		pfnum = pte->pg_pfn;
		if (pfnum == 0)
			panic("vsbus: zero entry");
		*(int *)xpte++ = *(int *)pte++;
a352 5
	*(int *)xpte = 0;	/* mark last mapped page as invalid! */

	debug(("uVAX: 0x%x\n", uVAX_physmap + pgoff));

	return (uVAX_physmap + pgoff);	/* ??? */
a353 5
#endif
/*----------------------------------------------------------------------*/
/*
 * Here follows some currently(?) unused stuff. Someday this should be removed
 */
a354 4
#if 0
/*
 * Configure devices on VS2000/KA410 directly attached to vsbus
 */
d356 4
a359 4
ka410_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d361 2
a362 2
	struct confargs *ca;
	int i;
d364 18
a381 5
	for (i=0; i<KA410_MAXDEVS; i++) {
		ca = &ka410_devs[i];
		if (*ca->ca_name == '\0')
			break;
		config_found(self, (void*)ca, vsbus_print);
a382 5
	/*
	 * as long as there's no real DZ-driver, we used this dummy
	 */
	vsbus_intr_register(&ka410_devs[0], ka410_consRecv_intr, NULL);
	vsbus_intr_register(&ka410_devs[1], ka410_consXmit_intr, NULL);
a383 2

#endif
@


1.3.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: vsbus.c,v 1.6 2001/02/11 06:34:38 hugh Exp $ */
/*	$NetBSD: vsbus.c,v 1.29 2000/06/29 07:14:37 mrg Exp $ */
d4 1
a4 1
 * Copyright (c) 1996, 1999 Ludd, University of Lule}, Sweden.
a50 5
#include <vm/vm.h>
#include <vm/vm_kern.h>

#define _VAX_BUS_DMA_PRIVATE
#include <machine/bus.h>
a59 1
#include <machine/ka420.h>
d64 4
a67 1
int	vsbus_match	__P((struct device *, struct cfdata *, void *));
a69 1
int	vsbus_search	__P((struct device *, void *, void *));
d74 5
a78 20
static struct vax_bus_dma_tag vsbus_bus_dma_tag = {
	0,
	0,
	0,
	0,
	0,
	0,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
d81 36
a116 2
extern struct vax_bus_space vax_mem_bus_space;
static SIMPLEQ_HEAD(, vsbus_dma) vsbus_dma;
d118 14
a131 2
struct	cfattach vsbus_ca = { 
	sizeof(struct vsbus_softc), (cfmatch_t)vsbus_match, vsbus_attach
d133 1
d135 19
a153 2
struct  cfdriver vsbus_cd = {
	    NULL, "vsbus", DV_DULL
d155 1
a155 8

/* dummy interrupt handler for use during autoconf */
void
vsbus_intr(arg)
	void *arg;
{
	return;
}
d162 3
a164 1
	struct vsbus_attach_args *va = aux;
d166 5
a170 3
	printf(" csr 0x%lx vec 0x%x ipl %x maskbit %d", va->va_paddr,
	    va->va_cvec & 511, va->va_br, va->va_maskno - 1);
	return(UNCONF); 
d176 1
a176 1
	struct	cfdata	*cf;
d179 20
a198 4
#if VAX53
	/* Kludge: VAX53 is... special */
	if (vax_boardtype == VAX_BTYP_1303 && (int)aux == 1)
		return 1; /* Hack */
d200 18
a217 3
	if (vax_bustype == VAX_VSBUS)
		return 1;
	return 0;
d220 21
d246 2
a247 2
	struct	vsbus_softc *sc = (void *)self;
	int dbase, dsize;
d250 1
d252 4
a255 1
	sc->sc_dmatag = vsbus_bus_dma_tag;
d257 2
a258 9
	switch (vax_boardtype) {
#if VAX49 || VAX53
	case VAX_BTYP_1303:
	case VAX_BTYP_49:
		sc->sc_vsregs = vax_map_physmem(0x25c00000, 1);
		sc->sc_intreq = (char *)sc->sc_vsregs + 12;
		sc->sc_intclr = (char *)sc->sc_vsregs + 12;
		sc->sc_intmsk = (char *)sc->sc_vsregs + 8;
		vsbus_dma_init(sc, 8192);
a259 1
#endif
d261 1
a261 2
#if VAX46 || VAX48
	case VAX_BTYP_48:
d263 3
a265 5
		sc->sc_vsregs = vax_map_physmem(VS_REGS, 1);
		sc->sc_intreq = (char *)sc->sc_vsregs + 15;
		sc->sc_intclr = (char *)sc->sc_vsregs + 15;
		sc->sc_intmsk = (char *)sc->sc_vsregs + 12;
		vsbus_dma_init(sc, 32768);
d267 1
d270 3
a272 16
		sc->sc_vsregs = vax_map_physmem(VS_REGS, 1);
		sc->sc_intreq = (char *)sc->sc_vsregs + 15;
		sc->sc_intclr = (char *)sc->sc_vsregs + 15;
		sc->sc_intmsk = (char *)sc->sc_vsregs + 12;
		if (vax_boardtype == VAX_BTYP_410) {
			dbase = KA410_DMA_BASE;
			dsize = KA410_DMA_SIZE;
		} else {
			dbase = KA420_DMA_BASE;
			dsize = KA420_DMA_SIZE;
			*(char *)(sc->sc_vsregs + 0xe0) = 1; /* Big DMA */
		}
		sc->sc_dmasize = dsize;
		sc->sc_dmaaddr = uvm_km_valloc(kernel_map, dsize);
		ioaccess(sc->sc_dmaaddr, dbase, dsize/VAX_NBPG);
		break;
a274 1
	SIMPLEQ_INIT(&vsbus_dma);
d276 5
a280 10
	 * First: find which interrupts we won't care about.
	 * There are interrupts that interrupt on a periodic basic
	 * that we don't want to interfere with the rest of the 
	 * interrupt probing.
	 */
	*sc->sc_intmsk = 0;
	*sc->sc_intclr = 0xff;
	DELAY(1000000); /* Wait a second */
	sc->sc_mask = *sc->sc_intreq;
	printf("%s: interrupt mask %x\n", self->dv_xname, sc->sc_mask);
d284 80
a363 1
	config_search(vsbus_search, self, NULL);
d365 2
a366 2
	/* Autoconfig finished, enable interrupts */
	*sc->sc_intmsk = ~sc->sc_mask;
d370 21
a390 4
vsbus_search(parent, cfd, aux)
	struct device *parent;
	void *cfd;
	void *aux;
d392 6
a397 51
	struct	vsbus_softc *sc = (void *)parent;
	struct	vsbus_attach_args va;
	struct	cfdata *cf = cfd;
	int i, vec, br;
	u_char c;

	va.va_paddr = cf->cf_loc[0];
	va.va_addr = vax_map_physmem(va.va_paddr, 1);
	va.va_dmat = &sc->sc_dmatag;
	va.va_iot = &vax_mem_bus_space;

	*sc->sc_intmsk = 0;
	*sc->sc_intclr = 0xff;
	scb_vecref(0, 0); /* Clear vector ref */

	i = (*cf->cf_attach->ca_match) (parent, cf, &va);
	vax_unmap_physmem(va.va_addr, 1);
	c = *sc->sc_intreq & ~sc->sc_mask;

	if (i == 0)
		goto forgetit;
	if (i > 10)
		c = sc->sc_mask; /* Fooling interrupt */
	else if (c == 0)
		goto forgetit;

	*sc->sc_intmsk = c;
	DELAY(1000);
	*sc->sc_intmsk = 0;
	va.va_maskno = ffs((u_int)c);
	i = scb_vecref(&vec, &br);
	if (i == 0)
		goto fail;
	if (vec == 0)
		goto fail;

	va.va_br = br;
	va.va_cvec = vec;
	va.va_dmaaddr = sc->sc_dmaaddr;
	va.va_dmasize = sc->sc_dmasize;
	*sc->sc_intmsk = c; /* Allow interrupts during attach */
	config_attach(parent, cf, &va, vsbus_print);
	*sc->sc_intmsk = 0;
	return 0;

fail:
	printf("%s%d at %s csr 0x%x %s\n",
	    cf->cf_driver->cd_name, cf->cf_unit, parent->dv_xname,
	    cf->cf_loc[0], (i ? "zero vector" : "didn't interrupt"));
forgetit:
	return 0;
d400 3
a402 7
/*
 * Sets a new interrupt mask. Returns the old one.
 * Works like spl functions.
 */
unsigned char
vsbus_setmask(mask)
	unsigned char mask;
d404 2
a405 2
	struct vsbus_softc *sc;
	unsigned char ch;
d407 1
a407 3
	if (vsbus_cd.cd_ndevs == 0)
		return 0;
	sc = vsbus_cd.cd_devs[0];
d409 2
a410 3
	ch = *sc->sc_intmsk;
	*sc->sc_intmsk = mask;
	return ch;
a412 3
/*
 * Clears the interrupts in mask.
 */
d414 2
a415 2
vsbus_clrintr(mask)
	unsigned char mask;
d417 1
a417 1
	struct vsbus_softc *sc;
d419 8
a426 1
	if (vsbus_cd.cd_ndevs == 0)
d428 1
a428 1
	sc = vsbus_cd.cd_devs[0];
d430 9
a438 1
	*sc->sc_intclr = mask;
d442 2
a443 2
 * Copy data from/to a user process' space from the DMA area.
 * Use the physical memory directly.
d445 29
a473 2
void
vsbus_copytoproc(struct proc *p, caddr_t from, caddr_t to, int len)
d475 12
a486 2
	struct pte *pte;
	paddr_t pa;
d488 8
a495 3
	if ((vaddr_t)to & KERNBASE) { /* In kernel space */
		bcopy(from, to, len);
		return;
d497 33
a529 18
	pte = uvtopte(TRUNC_PAGE(to), (&p->p_addr->u_pcb));
	if ((vaddr_t)to & PGOFSET) {
		int cz = ROUND_PAGE(to) - (vaddr_t)to;

		pa = (pte->pg_pfn << VAX_PGSHIFT) | (NBPG - cz) | KERNBASE;
		bcopy(from, (caddr_t)pa, min(cz, len));
		from += cz;
		to += cz;
		len -= cz;
		pte += 8; /* XXX */
	}
	while (len > 0) {
		pa = (pte->pg_pfn << VAX_PGSHIFT) | KERNBASE;
		bcopy(from, (caddr_t)pa, min(NBPG, len));
		from += NBPG;
		to += NBPG;
		len -= NBPG;
		pte += 8; /* XXX */
d531 12
d545 3
a547 2
void
vsbus_copyfromproc(struct proc *p, caddr_t from, caddr_t to, int len)
d549 5
a553 6
	struct pte *pte;
	paddr_t pa;

	if ((vaddr_t)from & KERNBASE) { /* In kernel space */
		bcopy(from, to, len);
		return;
d555 4
a558 18
	pte = uvtopte(TRUNC_PAGE(from), (&p->p_addr->u_pcb));
	if ((vaddr_t)from & PGOFSET) {
		int cz = ROUND_PAGE(from) - (vaddr_t)from;

		pa = (pte->pg_pfn << VAX_PGSHIFT) | (NBPG - cz) | KERNBASE;
		bcopy((caddr_t)pa, to, min(cz, len));
		from += cz;
		to += cz;
		len -= cz;
		pte += 8; /* XXX */
	}
	while (len > 0) {
		pa = (pte->pg_pfn << VAX_PGSHIFT) | KERNBASE;
		bcopy((caddr_t)pa, to, min(NBPG, len));
		from += NBPG;
		to += NBPG;
		len -= NBPG;
		pte += 8; /* XXX */
d560 1
d563 10
a572 5
/* 
 * There can only be one user of the DMA area on VS2k/VS3100 at one
 * time, so keep track of it here.
 */ 
static int vsbus_active = 0;
d574 6
a579 2
void
vsbus_dma_start(struct vsbus_dma *vd)
d581 56
a636 2
 
	SIMPLEQ_INSERT_TAIL(&vsbus_dma, vd, vd_q);
d638 1
a638 2
	if (vsbus_active == 0)
		vsbus_dma_intr();
d640 10
a649 1
 
d651 13
a663 8
vsbus_dma_intr(void)
{	
	struct vsbus_dma *vd;
	
	vd = SIMPLEQ_FIRST(&vsbus_dma); 
	if (vd == NULL) {
		vsbus_active = 0;
		return;
d665 5
a669 3
	vsbus_active = 1;
	SIMPLEQ_REMOVE_HEAD(&vsbus_dma, vd, vd_q);
	(*vd->vd_go)(vd->vd_arg);
d672 1
@


1.3.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.3.12.1 2001/05/14 21:39:22 niklas Exp $ */
d52 1
a52 1
#include <uvm/uvm_extern.h>
d70 4
a73 4
int	vsbus_match(struct device *, struct cfdata *, void *);
void	vsbus_attach(struct device *, struct device *, void *);
int	vsbus_print(void *, const char *);
int	vsbus_search(struct device *, void *, void *);
d75 2
a76 2
void	ka410_attach(struct device *, struct device *, void *);
void	ka43_attach(struct device *, struct device *, void *);
@


1.3.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d51 1
@


1.3.12.4
log
@Merge in trunk
@
text
@d44 1
@


1.3.12.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.c,v 1.3.12.4 2002/03/06 02:04:48 niklas Exp $ */
a208 10

#if VAX48
	/*
	 * It's possible for the 4000/VLC to generate an DZ-11 rx interrupt
	 * (0x20) during the delay period, unmask that bit.
	 */
	if (vax_boardtype == VAX_BTYP_48)
		sc->sc_mask &= ~0x20;
#endif

a209 1

@


1.3.12.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d109 8
d332 1
a332 1
	pt_entry_t *pte;
d343 1
a343 2
		pa = ((*pte & PG_FRAME) << VAX_PGSHIFT) |
		    (NBPG - cz) | KERNBASE;
d351 1
a351 1
		pa = ((*pte & PG_FRAME) << VAX_PGSHIFT) | KERNBASE;
d363 1
a363 1
	pt_entry_t *pte;
d374 1
a374 2
		pa = ((*pte & PG_FRAME) << VAX_PGSHIFT) |
		    (NBPG - cz) | KERNBASE;
d382 1
a382 1
		pa = ((*pte & PG_FRAME) << VAX_PGSHIFT) | KERNBASE;
@


1.3.12.7
log
@Merge with the trunk
@
text
@d412 1
a412 1
	SIMPLEQ_REMOVE_HEAD(&vsbus_dma, vd_q);
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: vsbus.c,v 1.4 1996/10/13 03:36:17 christos Exp $ */
/*	$NetBSD: vsbus.c,v 1.4 1996/10/13 03:36:17 christos Exp $ */
d93 1
a93 1
#ifdef VAX410	/* also: KA420 */
d117 16
d252 4
a255 1
	printf("vsbus_attach: boardtype = %x\n", vax_boardtype);
a256 1
	switch (vax_boardtype) {
a257 1
	case VAX_BTYP_420:
d264 1
d266 1
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
