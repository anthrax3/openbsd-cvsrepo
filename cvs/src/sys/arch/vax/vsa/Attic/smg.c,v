head	1.29;
access;
symbols
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.12
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.10
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.8
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.6
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.03.09.16.28.50;	author deraadt;	state dead;
branches;
next	1.28;
commitid	OSDG2O3Cgeifnf1W;

1.28
date	2014.12.23.21.39.12;	author miod;	state Exp;
branches;
next	1.27;
commitid	foSDoFEw0OUhYWGt;

1.27
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.26;
commitid	uKVPYMN2MLxdZxzH;

1.26
date	2013.10.21.10.36.21;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.20.20.07.28;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.21.21.39.50;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.28.20.44.39;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.01.16.11.19;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.05.16.57.42;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.05.10.00.30;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.03.18.44.32;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.02.20.10.19;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.29.15.11.57;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.29.14.18.57;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.28.21.06.00;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.23.19.17.23;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.17.20.26.16;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.09.22.27.11;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.03.19.49.02;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.19.23.54.22;	author miod;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.06.15.22.45.34;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.16.22.15.19;	author hugh;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.11.06.34.38;	author hugh;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.27.02.34.50;	author bjc;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.21.39.22;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.24.50;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2002.03.28.11.26.47;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.01.31.22.55.28;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.06.11.03.39.20;	author art;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.05.19.21.46.10;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: smg.c,v 1.28 2014/12/23 21:39:12 miod Exp $	*/
/*	$NetBSD: smg.c,v 1.21 2000/03/23 06:46:44 thorpej Exp $ */
/*
 * Copyright (c) 2006, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1998 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1991 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Mark Davies of the Department of Computer
 * Science, Victoria University of Wellington, New Zealand.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: grf_hy.c 1.2 93/08/13$
 *
 *	@@(#)grf_hy.c	8.4 (Berkeley) 1/12/94
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/conf.h>
#include <sys/kernel.h>

#include <machine/vsbus.h>
#include <machine/sid.h>
#include <machine/cpu.h>
#include <machine/ka420.h>
#include <machine/scb.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <dev/ic/dc503reg.h>

#include <vax/qbus/dzreg.h>
#include <vax/qbus/dzvar.h>
#include <vax/dec/dzkbdvar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <dev/rasops/rasops_masks.h>

/* Screen hardware defs */
#define SM_XWIDTH	1024
#define SM_YWIDTH	864

#define CUR_XBIAS	216	/* Add to cursor position */
#define CUR_YBIAS	33

int	smg_match(struct device *, void *, void *);
void	smg_attach(struct device *, struct device *, void *);

struct	smg_screen {
	struct rasops_info ss_ri;
	caddr_t		ss_addr;		/* frame buffer address */
	struct dc503reg	*ss_cursor;		/* cursor registers */
	u_int16_t	ss_curcmd;
	struct wsdisplay_curpos ss_curpos, ss_curhot;
	u_int16_t	ss_curimg[PCC_CURSOR_SIZE];
	u_int16_t	ss_curmask[PCC_CURSOR_SIZE];
};

/* for console */
struct smg_screen smg_consscr;

struct	smg_softc {
	struct device sc_dev;
	struct smg_screen *sc_scr;
	int	sc_nscreens;
};

struct cfattach smg_ca = {
	sizeof(struct smg_softc), smg_match, smg_attach,
};

struct	cfdriver smg_cd = {
	NULL, "smg", DV_DULL
};

struct wsscreen_descr smg_stdscreen = {
	"std",
};

const struct wsscreen_descr *_smg_scrlist[] = {
	&smg_stdscreen,
};

const struct wsscreen_list smg_screenlist = {
	sizeof(_smg_scrlist) / sizeof(struct wsscreen_descr *),
	_smg_scrlist,
};

int	smg_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	smg_mmap(void *, off_t, int);
int	smg_alloc_screen(void *, const struct wsscreen_descr *,
	    void **, int *, int *, long *);
void	smg_free_screen(void *, void *);
int	smg_show_screen(void *, void *, int,
	    void (*) (void *, int, int), void *);
int	smg_load_font(void *, void *, struct wsdisplay_font *);
int	smg_list_font(void *, struct wsdisplay_font *);
void	smg_burner(void *, u_int, u_int);

const struct wsdisplay_accessops smg_accessops = {
	.ioctl = smg_ioctl,
	.mmap = smg_mmap,
	.alloc_screen = smg_alloc_screen,
	.free_screen = smg_free_screen,
	.show_screen = smg_show_screen,
	.load_font = smg_load_font,
	.list_font = smg_list_font,
	.burn_screen = smg_burner
};

void	smg_blockmove(struct rasops_info *, u_int, u_int, u_int, u_int, u_int,
	    int);
int	smg_copycols(void *, int, int, int, int);
int	smg_erasecols(void *, int, int, int, long);

int	smg_getcursor(struct smg_screen *, struct wsdisplay_cursor *);
int	smg_setup_screen(struct smg_screen *);
int	smg_setcursor(struct smg_screen *, struct wsdisplay_cursor *);
void	smg_updatecursor(struct smg_screen *, u_int);

int
smg_match(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct vsbus_attach_args *va = aux;
	volatile short *curcmd;
	volatile short *cfgtst;
	short tmp, tmp2;
	extern struct consdev wsdisplay_cons;

	switch (vax_boardtype) {
	default:
		return (0);

	case VAX_BTYP_410:
	case VAX_BTYP_420:
	case VAX_BTYP_43:
		if (va->va_paddr != KA420_CUR_BASE)
			return (0);

		/* not present on microvaxes */
		if ((vax_confdata & KA420_CFG_MULTU) != 0)
			return (0);

		/*
		 * If the color option board is present, do not attach
		 * unless we are explicitely asked to via device flags.
		 */
		if ((vax_confdata & KA420_CFG_VIDOPT) != 0 &&
		    (cf->cf_flags & 1) == 0)
			return (0);
		break;
	}

	/* when already running as console, always fake things */
	if ((vax_confdata & (KA420_CFG_L3CON | KA420_CFG_VIDOPT)) == 0 &&
	    cn_tab == &wsdisplay_cons) {
		struct vsbus_softc *sc = (void *)parent;
		extern int oldvsbus;

		sc->sc_mask = 0x08;
		scb_fake(0x44, oldvsbus ? 0x14 : 0x15);
		return (20);
	} else {
		/*
		 * Try to find the cursor chip by testing the flip-flop.
		 * If nonexistent, no glass tty.
		 */
		curcmd = (short *)va->va_addr;
		cfgtst = (short *)vax_map_physmem(VS_CFGTST, 1);
		curcmd[0] = PCCCMD_HSHI | PCCCMD_FOPB;
		DELAY(300000);
		tmp = cfgtst[0];
		curcmd[0] = PCCCMD_TEST | PCCCMD_HSHI;
		DELAY(300000);
		tmp2 = cfgtst[0];
		vax_unmap_physmem((vaddr_t)cfgtst, 1);

		if (tmp2 != tmp)
			return (20); /* Using periodic interrupt */
		else
			return (0);
	}
}

void
smg_attach(struct device *parent, struct device *self, void *aux)
{
	struct smg_softc *sc = (struct smg_softc *)self;
	struct smg_screen *scr;
	struct wsemuldisplaydev_attach_args aa;
	int console;
	extern struct consdev wsdisplay_cons;

	console = (vax_confdata & (KA420_CFG_L3CON | KA420_CFG_VIDOPT)) == 0 &&
	    cn_tab == &wsdisplay_cons;
	if (console) {
		scr = &smg_consscr;
		sc->sc_nscreens = 1;
	} else {
		scr = malloc(sizeof(*scr), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (scr == NULL) {
			printf(": can not allocate memory\n");
			return;
		}

		scr->ss_addr =
		    (caddr_t)vax_map_physmem(SMADDR, SMSIZE / VAX_NBPG);
		if (scr->ss_addr == NULL) {
			printf(": can not map frame buffer\n");
			free(scr, M_DEVBUF, sizeof(*scr));
			return;
		}

		scr->ss_cursor =
		    (struct dc503reg *)vax_map_physmem(KA420_CUR_BASE, 1);
		if (scr->ss_cursor == NULL) {
			printf(": can not map cursor chip\n");
			vax_unmap_physmem((vaddr_t)scr->ss_addr,
			    SMSIZE / VAX_NBPG);
			free(scr, M_DEVBUF, sizeof(*scr));
			return;
		}

		if (smg_setup_screen(scr) != 0) {
			printf(": initialization failed\n");
			vax_unmap_physmem((vaddr_t)scr->ss_cursor, 1);
			vax_unmap_physmem((vaddr_t)scr->ss_addr,
			    SMSIZE / VAX_NBPG);
			free(scr, M_DEVBUF, sizeof(*scr));
			return;
		}
	}
	sc->sc_scr = scr;

	printf("\n%s: %dx%d on-board monochrome framebuffer\n",
	    self->dv_xname, SM_XWIDTH, SM_YWIDTH);

	aa.console = console;
	aa.scrdata = &smg_screenlist;
	aa.accessops = &smg_accessops;
	aa.accesscookie = sc;
	aa.defaultscreens = 0;

	config_found(self, &aa, wsemuldisplaydevprint);
}

/*
 * Initialize anything necessary for an emulating wsdisplay to work (i.e.
 * pick a font, initialize a rasops structure, setup the accessops callbacks.)
 */
int
smg_setup_screen(struct smg_screen *ss)
{
	struct rasops_info *ri = &ss->ss_ri;

	bzero(ri, sizeof(*ri));
	ri->ri_depth = 1;
	ri->ri_width = SM_XWIDTH;
	ri->ri_height = SM_YWIDTH;
	ri->ri_stride = SM_XWIDTH >> 3;
	ri->ri_flg = RI_CLEAR | RI_CENTER;
	ri->ri_bits = (void *)ss->ss_addr;
	ri->ri_hw = ss;

	/*
	 * Ask for an unholy big display, rasops will trim this to more
	 * reasonable values.
	 */
	if (rasops_init(ri, 160, 160) != 0)
		return (-1);

	ri->ri_ops.copycols = smg_copycols;
	ri->ri_ops.erasecols = smg_erasecols;

	smg_stdscreen.ncols = ri->ri_cols;
	smg_stdscreen.nrows = ri->ri_rows;
	smg_stdscreen.textops = &ri->ri_ops;
	smg_stdscreen.fontwidth = ri->ri_font->fontwidth;
	smg_stdscreen.fontheight = ri->ri_font->fontheight;
	smg_stdscreen.capabilities = ri->ri_caps;

	ss->ss_curcmd = PCCCMD_HSHI;
	ss->ss_cursor->cmdr = ss->ss_curcmd;

	return (0);
}

int
smg_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct smg_softc *sc = v;
	struct smg_screen *ss = sc->sc_scr;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_curpos *pos;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_VAX_MONO;
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = ss->ss_ri.ri_height;
		wdf->width = ss->ss_ri.ri_width;
		wdf->depth = ss->ss_ri.ri_depth;
		wdf->cmsize = 0;
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = ss->ss_ri.ri_stride;
		break;

	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = ss->ss_curpos.x;
		pos->y = ss->ss_curpos.y;
		break;
	case WSDISPLAYIO_SCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		ss->ss_curpos.x = pos->x;
		ss->ss_curpos.y = pos->y;
		smg_updatecursor(ss, WSDISPLAY_CURSOR_DOPOS);
		break;
	case WSDISPLAYIO_GCURMAX:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = pos->y = PCC_CURSOR_SIZE;
	case WSDISPLAYIO_GCURSOR:
		return (smg_getcursor(ss, (struct wsdisplay_cursor *)data));
	case WSDISPLAYIO_SCURSOR:
		return (smg_setcursor(ss, (struct wsdisplay_cursor *)data));
		break;

	default:
		return (-1);
	}

	return (0);
}

paddr_t
smg_mmap(void *v, off_t offset, int prot)
{
	if (offset >= SMSIZE || offset < 0)
		return (-1);

	return (SMADDR + offset);
}

int
smg_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *defattrp)
{
	struct smg_softc *sc = v;
	struct smg_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = ri;
	*curxp = *curyp = 0;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, defattrp);
	sc->sc_nscreens++;

	return (0);
}

void
smg_free_screen(void *v, void *cookie)
{
	struct smg_softc *sc = v;

	sc->sc_nscreens--;
}

int
smg_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

int
smg_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct smg_softc *sc = v;
	struct smg_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	return rasops_load_font(ri, emulcookie, font);
}

int
smg_list_font(void *v, struct wsdisplay_font *font)
{
	struct smg_softc *sc = v;
	struct smg_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	return rasops_list_font(ri, font);
}

void
smg_burner(void *v, u_int on, u_int flags)
{
	struct smg_softc *sc = v;
	struct smg_screen *ss = sc->sc_scr;

	ss->ss_cursor->cmdr = on ? ss->ss_curcmd :
	    (ss->ss_curcmd & ~(PCCCMD_FOPA | PCCCMD_ENPA)) | PCCCMD_FOPB;
}

int
smg_getcursor(struct smg_screen *ss, struct wsdisplay_cursor *wdc)
{
	int error;

	if (wdc->which & WSDISPLAY_CURSOR_DOCUR)
		wdc->enable = ss->ss_curcmd & PCCCMD_ENPA ? 1 : 0;
	if (wdc->which & WSDISPLAY_CURSOR_DOPOS) {
		wdc->pos.x = ss->ss_curpos.x;
		wdc->pos.y = ss->ss_curpos.y;
	}
	if (wdc->which & WSDISPLAY_CURSOR_DOHOT) {
		wdc->hot.x = ss->ss_curhot.x;
		wdc->hot.y = ss->ss_curhot.y;
	}
	if (wdc->which & WSDISPLAY_CURSOR_DOCMAP) {
		wdc->cmap.index = 0;
		wdc->cmap.count = 0;
	}
	if (wdc->which & WSDISPLAY_CURSOR_DOSHAPE) {
		wdc->size.x = wdc->size.y = PCC_CURSOR_SIZE;
		error = copyout(ss->ss_curimg, wdc->image,
		    sizeof(ss->ss_curimg));
		if (error != 0)
			return (error);
		error = copyout(ss->ss_curmask, wdc->mask,
		    sizeof(ss->ss_curmask));
		if (error != 0)
			return (error);
	}

	return (0);
}

int
smg_setcursor(struct smg_screen *ss, struct wsdisplay_cursor *wdc)
{
	u_int16_t curfg[PCC_CURSOR_SIZE], curmask[PCC_CURSOR_SIZE];
	int error;

	if (wdc->which & WSDISPLAY_CURSOR_DOCMAP) {
		/* No cursor colormap since we are a B&W device. */
		if (wdc->cmap.count != 0)
			return (EINVAL);
	}

	/*
	 * First, do the userland-kernel data transfers, so that we can fail
	 * if necessary before altering anything.
	 */
	if (wdc->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (wdc->size.x != PCC_CURSOR_SIZE ||
		    wdc->size.y != PCC_CURSOR_SIZE)
			return (EINVAL);
		error = copyin(wdc->image, curfg, sizeof(curfg));
		if (error != 0)
			return (error);
		error = copyin(wdc->mask, curmask, sizeof(curmask));
		if (error != 0)
			return (error);
	}

	/*
	 * Now update our variables...
	 */
	if (wdc->which & WSDISPLAY_CURSOR_DOCUR) {
		if (wdc->enable)
			ss->ss_curcmd |= PCCCMD_ENPB | PCCCMD_ENPA;
		else
			ss->ss_curcmd &= ~(PCCCMD_ENPB | PCCCMD_ENPA);
	}
	if (wdc->which & WSDISPLAY_CURSOR_DOPOS) {
		ss->ss_curpos.x = wdc->pos.x;
		ss->ss_curpos.y = wdc->pos.y;
	}
	if (wdc->which & WSDISPLAY_CURSOR_DOHOT) {
		ss->ss_curhot.x = wdc->hot.x;
		ss->ss_curhot.y = wdc->hot.y;
	}
	if (wdc->which & WSDISPLAY_CURSOR_DOSHAPE) {
		bcopy(curfg, ss->ss_curimg, sizeof ss->ss_curimg);
		bcopy(curmask, ss->ss_curmask, sizeof ss->ss_curmask);
	}

	/*
	 * ...and update the cursor
	 */
	smg_updatecursor(ss, wdc->which);
	
	return (0);
}

void
smg_updatecursor(struct smg_screen *ss, u_int which)
{
	u_int i;

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		ss->ss_cursor->xpos =
		    ss->ss_curpos.x - ss->ss_curhot.x + CUR_XBIAS;
		ss->ss_cursor->ypos =
		    ss->ss_curpos.y - ss->ss_curhot.y + CUR_YBIAS;
	}
	if (which & WSDISPLAY_CURSOR_DOSHAPE) {
		ss->ss_cursor->cmdr = ss->ss_curcmd | PCCCMD_LODSA;
		for (i = 0; i < PCC_CURSOR_SIZE; i++)
			ss->ss_cursor->load = ss->ss_curimg[i];
		for (i = 0; i < PCC_CURSOR_SIZE; i++)
			ss->ss_cursor->load = ss->ss_curmask[i];
		ss->ss_cursor->cmdr = ss->ss_curcmd;
	} else
	if (which & WSDISPLAY_CURSOR_DOCUR)
		ss->ss_cursor->cmdr = ss->ss_curcmd;
}

/*
 * Faster console operations
 */

#include <vax/vsa/maskbits.h>

void
smg_blockmove(struct rasops_info *ri, u_int sx, u_int y, u_int dx, u_int cx,
    u_int cy, int rop)
{
	int width;		/* add to get to same position in next line */

	unsigned int *psrcLine, *pdstLine;
				/* pointers to line with current src and dst */
	unsigned int *psrc;	/* pointer to current src longword */
	unsigned int *pdst;	/* pointer to current dst longword */

				/* following used for looping through a line */
	unsigned int startmask, endmask;  /* masks for writing ends of dst */
	int nlMiddle;		/* whole longwords in dst */
	int nl;			/* temp copy of nlMiddle */
	int xoffSrc;		/* offset (>= 0, < 32) from which to
				   fetch whole longwords fetched in src */
	int nstart;		/* number of ragged bits at start of dst */
	int nend;		/* number of ragged bits at end of dst */
	int srcStartOver;	/* pulling nstart bits from src
				   overflows into the next word? */

	width = SM_XWIDTH >> 5;

	/* start at first scanline */
	psrcLine = pdstLine = ((u_int *)ri->ri_bits) + (y * width);

	/* x direction doesn't matter for < 1 longword */
	if (cx <= 32) {
		int srcBit, dstBit;	/* bit offset of src and dst */

		pdstLine += (dx >> 5);
		psrcLine += (sx >> 5);
		psrc = psrcLine;
		pdst = pdstLine;

		srcBit = sx & 0x1f;
		dstBit = dx & 0x1f;

		while (cy--) {
			getandputrop(psrc, srcBit, dstBit, cx, pdst, rop);
			pdst += width;
			psrc += width;
		}
	} else {
		maskbits(dx, cx, startmask, endmask, nlMiddle);
		if (startmask)
			nstart = 32 - (dx & 0x1f);
		else
			nstart = 0;
		if (endmask)
			nend = (dx + cx) & 0x1f;
		else
			nend = 0;

		xoffSrc = ((sx & 0x1f) + nstart) & 0x1f;
		srcStartOver = ((sx & 0x1f) + nstart) > 31;

		if (sx >= dx) {	/* move left to right */
			pdstLine += (dx >> 5);
			psrcLine += (sx >> 5);

			while (cy--) {
				psrc = psrcLine;
				pdst = pdstLine;

				if (startmask) {
					getandputrop(psrc, (sx & 0x1f),
					    (dx & 0x1f), nstart, pdst, rop);
					pdst++;
					if (srcStartOver)
						psrc++;
				}

				/* special case for aligned operations */
				if (xoffSrc == 0) {
					nl = nlMiddle;
					while (nl--) {
						switch (rop) {
						case RR_CLEAR:
							*pdst = 0;
							break;
						case RR_SET:
							*pdst = ~0;
							break;
						default:
							*pdst = *psrc;
							break;
						}
						psrc++;
						pdst++;
					}
				} else {
					nl = nlMiddle + 1;
					while (--nl) {
						switch (rop) {
						case RR_CLEAR:
							*pdst = 0;
							break;
						case RR_SET:
							*pdst = ~0;
							break;
						default:
							getunalignedword(psrc,
							    xoffSrc, *pdst);
							break;
						}
						pdst++;
						psrc++;
					}
				}

				if (endmask) {
					getandputrop(psrc, xoffSrc, 0, nend,
					    pdst, rop);
				}

				pdstLine += width;
				psrcLine += width;
			}
		} else {	/* move right to left */
			pdstLine += ((dx + cx) >> 5);
			psrcLine += ((sx + cx) >> 5);
			/*
			 * If fetch of last partial bits from source crosses
			 * a longword boundary, start at the previous longword
			 */
			if (xoffSrc + nend >= 32)
				--psrcLine;

			while (cy--) {
				psrc = psrcLine;
				pdst = pdstLine;

				if (endmask) {
					getandputrop(psrc, xoffSrc, 0, nend,
					    pdst, rop);
				}

				nl = nlMiddle + 1;
				while (--nl) {
					--psrc;
					--pdst;
					switch (rop) {
					case RR_CLEAR:
						*pdst = 0;
						break;
					case RR_SET:
						*pdst = ~0;
						break;
					default:
						getunalignedword(psrc, xoffSrc,
						    *pdst);
						break;
					}
				}

				if (startmask) {
					if (srcStartOver)
						--psrc;
					--pdst;
					getandputrop(psrc, (sx & 0x1f),
					    (dx & 0x1f), nstart, pdst, rop);
				}

				pdstLine += width;
				psrcLine += width;
			}
		}
	}
}

int
smg_copycols(void *cookie, int row, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;

	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	smg_blockmove(ri, src, row, dst, n, ri->ri_font->fontheight,
	    RR_COPY);

	return 0;
}

int
smg_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	int fg, bg;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	num *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	smg_blockmove(ri, col, row, col, num, ri->ri_font->fontheight,
	    bg == 0 ? RR_CLEAR : RR_SET);

	return 0;
}

/*
 * Console support code
 */

int	smgcnprobe(void);
int	smgcninit(void);

int
smgcnprobe()
{
	switch (vax_boardtype) {
	case VAX_BTYP_410:
	case VAX_BTYP_420:
	case VAX_BTYP_43:
		if ((vax_confdata & (KA420_CFG_L3CON | KA420_CFG_MULTU)) != 0)
			break; /* doesn't use graphics console */

		if ((vax_confdata & KA420_CFG_VIDOPT) != 0)
			break;	/* there is a color option */

		return (1);

	default:
		break;
	}

	return (0);
}

/*
 * Called very early to setup the glass tty as console.
 * Because it's called before the VM system is initialized, virtual memory
 * for the framebuffer can be stolen directly without disturbing anything.
 */
int
smgcninit()
{
	struct smg_screen *ss = &smg_consscr;
	extern vaddr_t virtual_avail;
	vaddr_t ova;
	long defattr;
	struct rasops_info *ri;

	ova = virtual_avail;

	ss->ss_addr = (caddr_t)virtual_avail;
	ioaccess(virtual_avail, SMADDR, SMSIZE / VAX_NBPG);
	virtual_avail += SMSIZE;

	ss->ss_cursor = (struct dc503reg *)virtual_avail;
	ioaccess(virtual_avail, KA420_CUR_BASE, 1);
	virtual_avail += VAX_NBPG;

	virtual_avail = round_page(virtual_avail);

	/* this had better not fail */
	if (smg_setup_screen(ss) != 0) {
		iounaccess((vaddr_t)ss->ss_addr, SMSIZE / VAX_NBPG);
		iounaccess((vaddr_t)ss->ss_cursor, 1);
		virtual_avail = ova;
		return (1);
	}

	ri = &ss->ss_ri;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&smg_stdscreen, ri, 0, 0, defattr);

	return (0);
}
@


1.28
log
@Pass real sizes to free()
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.27 2014/07/12 18:44:43 tedu Exp $	*/
@


1.27
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.26 2013/10/21 10:36:21 miod Exp $	*/
d297 1
a297 1
			free(scr, M_DEVBUF, 0);
d307 1
a307 1
			free(scr, M_DEVBUF, 0);
d316 1
a316 1
			free(scr, M_DEVBUF, 0);
@


1.26
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.25 2013/10/20 20:07:28 miod Exp $	*/
d297 1
a297 1
			free(scr, M_DEVBUF);
d307 1
a307 1
			free(scr, M_DEVBUF);
d316 1
a316 1
			free(scr, M_DEVBUF);
@


1.25
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.24 2010/12/26 15:41:00 miod Exp $	*/
d182 2
d192 2
d474 20
@


1.24
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.23 2009/09/05 14:09:35 miod Exp $	*/
d185 6
a190 9
	smg_ioctl,
	smg_mmap,
	smg_alloc_screen,
	smg_free_screen,
	smg_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	smg_burner
@


1.23
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.22 2008/12/21 21:39:50 miod Exp $	*/
d438 1
a438 1
	return (SMADDR + offset) >> PGSHIFT;
@


1.22
log
@During early device probes, make sure to iounaccess() address ranges when
they are no longer necessary. No good reason to do so but correctness, and
then leaving correct mappings after probe might hide bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.21 2007/12/28 20:44:39 miod Exp $	*/
d198 2
a199 2
void	smg_copycols(void *, int, int, int, int);
void	smg_erasecols(void *, int, int, int, long);
d778 1
a778 1
void
d790 2
d794 1
a794 1
void
d808 2
@


1.21
log
@If initializing a frame buffer as glass console fails, instead of an invisible
panic (for you ichc fans out there), disable the wscons console and force a
console device reselection, which ends up in picking a serial console.

This should not happen, but just in case, it's a less rude behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.20 2007/10/01 16:11:19 krw Exp $	*/
d847 1
d851 2
d854 1
a855 1
	ioaccess((vaddr_t)ss->ss_addr, SMADDR, SMSIZE / VAX_NBPG);
d858 1
a859 1
	ioaccess((vaddr_t)ss->ss_cursor, KA420_CUR_BASE, 1);
d864 4
a867 1
	if (smg_setup_screen(ss) != 0)
d869 1
@


1.20
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.19 2006/11/29 19:08:22 miod Exp $	*/
d813 1
a813 1
void	smgcninit(void);
d842 1
a842 1
void
d860 1
a860 1
	/* this had better not fail as we can't recover there */
d862 1
a862 1
		panic(__func__);
d867 2
@


1.19
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.18 2006/11/29 12:13:54 miod Exp $	*/
d286 1
a286 1
		scr = malloc(sizeof(struct smg_screen), M_DEVBUF, M_NOWAIT);
a290 1
		bzero(scr, sizeof(struct smg_screen));
@


1.18
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.17 2006/08/05 16:57:42 miod Exp $	*/
d799 1
a799 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
@


1.17
log
@Make sure smg will not pretend being a console on smg+gpx hardware with
smg forced to attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.16 2006/08/05 10:00:30 miod Exp $	*/
d329 1
@


1.16
log
@Use faster {copy,erase}cols routines for smg, with ad hoc vax assembly,
adapted from X11 via hp300.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.15 2006/08/03 18:44:32 miod Exp $	*/
a214 1
	extern int oldvsbus;
d240 2
a241 1
	if ((vax_confdata & KA420_CFG_L3CON) == 0 &&
a242 1
		/* when already running as console, always fake things */
d244 2
d280 1
a280 1
	console = (vax_confdata & KA420_CFG_L3CON) == 0 &&
d824 3
@


1.15
log
@No need to force a 8-bit font anymore, welcome to the 12x22 font.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.14 2006/08/02 20:10:19 miod Exp $	*/
d57 39
d123 1
a123 3
#include <dev/wsfont/wsfont.h>

#include "dzkbd.h"
d196 5
d357 3
d597 208
@


1.14
log
@Provide the usual 8x16 font, instead of the qvss 8x15 font, for low-res vax
frame buffers (and smg until it can use non-8bit wide fonts), as the latter
has too many symbols in the 8-bit range stubbed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.13 2006/07/29 15:11:57 miod Exp $	*/
a306 11

	/*
	 * We can not let rasops select our font, because we need to use
	 * a font with right-to-left bit order on this frame buffer.
	 */
	wsfont_init();
	if ((ri->ri_wsfcookie = wsfont_find(NULL, 8, 0, 0)) <= 0)
		return (-1);
	if (wsfont_lock(ri->ri_wsfcookie, &ri->ri_font,
	    WSDISPLAY_FONTORDER_R2L, WSDISPLAY_FONTORDER_L2R) <= 0)
		return (-1);
@


1.13
log
@At attach() time, do not simply trust the L3 switch to know if we are the
console, check for cn_tab pointing to wsdisplay as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.12 2006/07/29 14:18:57 miod Exp $	*/
d69 1
d172 2
d199 27
a225 18
	/*
	 * Try to find the cursor chip by testing the flip-flop.
	 * If nonexistent, no glass tty.
	 */
	curcmd = (short *)va->va_addr;
	cfgtst = (short *)vax_map_physmem(VS_CFGTST, 1);
	curcmd[0] = PCCCMD_HSHI | PCCCMD_FOPB;
	DELAY(300000);
	tmp = cfgtst[0];
	curcmd[0] = PCCCMD_TEST | PCCCMD_HSHI;
	DELAY(300000);
	tmp2 = cfgtst[0];
	vax_unmap_physmem((vaddr_t)cfgtst, 1);

	if (tmp2 != tmp)
		return (20); /* Using periodic interrupt */
	else
		return (0);
d313 1
a313 1
	if ((ri->ri_wsfcookie = wsfont_find(NULL, 8, 15, 0)) <= 0)
@


1.12
log
@Rewrite glass console detection and initialization code, it's simpler and
will not allocate frame buffer resources at probe time. A few buglets fixed
while doing so.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.11 2006/07/28 21:06:00 miod Exp $	*/
d72 2
d223 1
d225 2
a226 1
	console = (vax_confdata & KA420_CFG_L3CON) == 0;
@


1.11
log
@Better dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.10 2006/07/23 19:17:23 miod Exp $	*/
d70 2
a78 1
#include <dev/wscons/wscons_callbacks.h>
a548 3
#include <dev/cons.h>
cons_decl(smg);

d550 1
a550 3
 * Called very early to setup the glass tty as console.
 * Because it's called before the VM system is initialized, virtual memory
 * for the framebuffer can be stolen directly without disturbing anything.
d552 6
a557 3
void
smgcnprobe(cndev)
	struct  consdev *cndev;
a558 4
	struct smg_screen *ss = &smg_consscr;
	extern vaddr_t virtual_avail;
	extern int getmajor(void *);	/* conf.c */

d566 1
a566 11
		ss->ss_addr = (caddr_t)virtual_avail;
		virtual_avail += SMSIZE;
		ioaccess((vaddr_t)ss->ss_addr, SMADDR, SMSIZE / VAX_NBPG);

		ss->ss_cursor = (struct dc503reg *)virtual_avail;
		virtual_avail += PAGE_SIZE; /* VAX_NBPG */
		ioaccess((vaddr_t)ss->ss_cursor, KA420_CUR_BASE, 1);

		cndev->cn_pri = CN_INTERNAL;
		cndev->cn_dev = makedev(getmajor(wsdisplayopen), 0);
		break;
d571 2
d575 5
d581 1
a581 1
smgcninit(struct consdev *cndev)
d584 1
a586 3
	extern void lkccninit(struct consdev *);
	extern int lkccngetc(dev_t);
	extern int dz_vsbus_lk201_cnattach(int);
d588 11
a598 1
	/* ss_addr and ss_cursor initialized in smgcnprobe() */
d600 1
a600 1
		return;
a604 4

#if NDZKBD > 0
	dzkbd_cnattach(0); /* Connect keyboard and screen together */
#endif
@


1.10
log
@Make smg(4) on par with the current state of wsdisplay drivers: make it use
a rasops backend and wsfont, better ioctl conformance, and too many other
changes to mention.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.9 2006/01/17 20:26:16 miod Exp $	*/
d262 2
a263 1
	printf("\n");
@


1.9
log
@Use angle bracket and no relative paths for all include files which are not
created by config(8); no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.8 2003/01/09 22:27:11 miod Exp $	*/
d4 24
a60 1
#include <sys/time.h>
a63 1
#include <sys/timeout.h>
d70 1
a70 1
#include <dev/cons.h>
a75 1
#include <dev/wscons/wsdisplayvar.h>
d78 3
a83 5
/* Safety guard */
#ifndef FONT_QVSS8x15
#include <dev/wsfont/qvss8x15.h>
#endif

d85 1
a85 4
#define SM_COLS		128	/* char width of screen */
#define SM_ROWS		57	/* rows of char on screen */
#define SM_CHEIGHT	15	/* lines a char consists of */
#define SM_NEXTROW	(SM_COLS * SM_CHEIGHT)
a86 32
#define SM_XWIDTH	1024

/* Cursor register definitions */
#define CUR_CMD		0
#define CUR_XPOS	4
#define CUR_YPOS	8
#define CUR_XMIN_1	12
#define CUR_XMAX_1	16
#define CUR_YMIN_1	20
#define CUR_YMAX_1	24
#define CUR_XMIN_2	28
#define CUR_XMAX_2	32
#define CUR_YMIN_2	36
#define CUR_YMAX_2	40
#define CUR_LOAD	44

#define CUR_CMD_TEST	0x8000
#define CUR_CMD_HSHI	0x4000
#define CUR_CMD_VBHI	0x2000
#define CUR_CMD_LODSA	0x1000
#define CUR_CMD_FORG2	0x0800
#define CUR_CMD_ENRG2	0x0400
#define CUR_CMD_FORG1	0x0200
#define CUR_CMD_ENRG1	0x0100
#define CUR_CMD_XHWID	0x0080
#define CUR_CMD_XHCL1	0x0040
#define CUR_CMD_XHCLP	0x0020
#define CUR_CMD_XHAIR	0x0010
#define CUR_CMD_FOPB	0x0008
#define CUR_CMD_ENPB	0x0004
#define CUR_CMD_FOPA	0x0002
#define CUR_CMD_ENPA	0x0001
d91 12
a102 4
#define	WRITECUR(addr, val)	*(volatile short *)(curaddr + (addr)) = (val)
static	caddr_t	curaddr;
static	short curcmd, curx, cury, hotX, hotY;
static	int bgmask, fgmask; 
d104 2
a105 2
static	int smg_match(struct device *, struct cfdata *, void *);
static	void smg_attach(struct device *, struct device *, void *);
d108 3
a110 1
	struct	device ss_dev;
d114 1
a114 1
	sizeof(struct smg_softc), (cfmatch_t)smg_match, smg_attach,
d121 2
a122 25
static void	smg_cursor(void *, int, int, int);
static int	smg_mapchar(void *, int, unsigned int *);
static void	smg_putchar(void *, int, int, u_int, long);
static void	smg_copycols(void *, int, int, int,int);
static void	smg_erasecols(void *, int, int, int, long);
static void	smg_copyrows(void *, int, int, int);
static void	smg_eraserows(void *, int, int, long);
static int	smg_alloc_attr(void *, int, int, int, long *);

const struct wsdisplay_emulops smg_emulops = {
	smg_cursor,
	smg_mapchar,
	smg_putchar,
	smg_copycols,
	smg_erasecols,
	smg_copyrows,
	smg_eraserows,
	smg_alloc_attr
};

const struct wsscreen_descr smg_stdscreen = {
	"128x57", SM_COLS, SM_ROWS,
	&smg_emulops,
	8, SM_CHEIGHT,
	WSSCREEN_UNDERLINE|WSSCREEN_REVERSE,
d134 8
a141 19
static	caddr_t	sm_addr;

extern struct wsdisplay_font qvss8x15;
static u_char *qf;

#define QCHAR(c) (c < 32 ? 32 : (c > 127 ? c - 66 : c - 32))
#define QFONT(c,line)	qf[QCHAR(c) * 15 + line]
#define	SM_ADDR(row, col, line) \
	sm_addr[col + (row * SM_CHEIGHT * SM_COLS) + line * SM_COLS]


static int	smg_ioctl(void *, u_long, caddr_t, int, struct proc *);
static paddr_t	smg_mmap(void *, off_t, int);
static int	smg_alloc_screen(void *, const struct wsscreen_descr *,
				      void **, int *, int *, long *);
static void	smg_free_screen(void *, void *);
static int	smg_show_screen(void *, void *, int,
				     void (*) (void *, int, int), void *);
static void	smg_crsr_blink(void *);
d149 4
a152 8
	0 /* load_font */
};

struct	smg_screen {
	int	ss_curx;
	int	ss_cury;
	u_char	ss_image[SM_ROWS][SM_COLS];	/* Image of current screen */
	u_char	ss_attr[SM_ROWS][SM_COLS];	/* Reversed etc... */
d155 4
a158 6
static	struct smg_screen smg_conscreen;
static	struct smg_screen *curscr;

static	struct timeout smg_blink_timeout;

extern int getmajor(void *);	/* conf.c */
d161 1
a161 1
smg_match(struct device *parent, struct cfdata *match, void *aux)
d163 1
d169 23
a191 2
	if (vax_boardtype == VAX_BTYP_49 || vax_boardtype == VAX_BTYP_1303)
		return 0;
a192 2
	curcmd = (short *)va->va_addr;
	cfgtst = (short *)vax_map_physmem(VS_CFGTST, 1);
d197 3
a199 1
	curcmd[0] = CUR_CMD_HSHI|CUR_CMD_FOPB;
d202 1
a202 1
	curcmd[0] = CUR_CMD_TEST|CUR_CMD_HSHI;
d208 1
a208 1
		return 20; /* Using periodic interrupt */
d210 1
a210 1
		return 0;
d216 2
d219 1
d221 11
a231 16
	printf("\n");
	sm_addr = (caddr_t)vax_map_physmem(SMADDR, (SMSIZE/VAX_NBPG));
	curaddr = (caddr_t)vax_map_physmem(KA420_CUR_BASE, 1);
	if (sm_addr == 0) {
		printf("%s: Couldn't alloc graphics memory.\n", self->dv_xname);
		return;
	}
	curscr = &smg_conscreen;
	aa.console = !(vax_confdata & 0x20);
	aa.scrdata = &smg_screenlist;
	aa.accessops = &smg_accessops;
	timeout_set(&smg_blink_timeout, smg_crsr_blink, NULL);
	timeout_add(&smg_blink_timeout, hz / 2);
	curcmd = CUR_CMD_HSHI;
	WRITECUR(CUR_CMD, curcmd);
	qf = qvss8x15.data;
d233 7
a239 2
	config_found(self, &aa, wsemuldisplaydevprint);
}
d241 9
a249 2
static	u_char *cursor;
static	int cur_on;
d251 8
a258 19
static void
smg_crsr_blink(void *arg)
{
	if (cur_on)
		*cursor ^= 255;
	timeout_add(&smg_blink_timeout, hz / 2);
}

void
smg_cursor(void *id, int on, int row, int col)
{
	struct smg_screen *ss = id;

	if (ss == curscr) {
		SM_ADDR(ss->ss_cury, ss->ss_curx, 14) =
		    QFONT(ss->ss_image[ss->ss_cury][ss->ss_curx], 14);
		cursor = &SM_ADDR(row, col, 14);
		if ((cur_on = on))
			*cursor ^= 255;
d260 1
a260 3
	ss->ss_curx = col;
	ss->ss_cury = row;
}
d262 1
a262 10
int
smg_mapchar(void *id, int uni, unsigned int *index)
{
	if (uni < 256) {
		*index = uni;
		return (5);
	}
	*index = ' ';
	return (0);
}
d264 4
a267 5
static void
smg_putchar(void *id, int row, int col, u_int c, long attr)
{
	struct smg_screen *ss = id;
	int i;
d269 1
a269 14
	c &= 0xff;

	ss->ss_image[row][col] = c;
	ss->ss_attr[row][col] = attr;
	if (ss != curscr)
		return;
	for (i = 0; i < 15; i++) {
		unsigned char ch = QFONT(c, i);

		SM_ADDR(row, col, i) = (attr & WSATTR_REVERSE ? ~ch : ch);
		
	}
	if (attr & WSATTR_UNDERLINE)
		SM_ADDR(row, col, 14) ^= SM_ADDR(row, col, 14);
d273 2
a274 1
 * copies columns inside a row.
d276 2
a277 2
static void
smg_copycols(void *id, int row, int srccol, int dstcol, int ncols)
d279 1
a279 2
	struct smg_screen *ss = id;
	int i;
d281 8
a288 7
	bcopy(&ss->ss_image[row][srccol], &ss->ss_image[row][dstcol], ncols);
	bcopy(&ss->ss_attr[row][srccol], &ss->ss_attr[row][dstcol], ncols);
	if (ss != curscr)
		return;
	for (i = 0; i < SM_CHEIGHT; i++)
		bcopy(&SM_ADDR(row,srccol, i), &SM_ADDR(row, dstcol, i),ncols);
}
d290 10
a299 8
/*
 * Erases a bunch of chars inside one row.
 */
static void
smg_erasecols(void *id, int row, int startcol, int ncols, long fillattr)
{
	struct smg_screen *ss = id;
	int i;
d301 6
a306 7
	bzero(&ss->ss_image[row][startcol], ncols);
	bzero(&ss->ss_attr[row][startcol], ncols);
	if (ss != curscr)
		return;
	for (i = 0; i < SM_CHEIGHT; i++)
		bzero(&SM_ADDR(row, startcol, i), ncols);
}
d308 6
a313 5
static void
smg_copyrows(void *id, int srcrow, int dstrow, int nrows)
{
	struct smg_screen *ss = id;
	int frows;
d315 2
a316 27
	bcopy(&ss->ss_image[srcrow][0], &ss->ss_image[dstrow][0],
	    nrows * SM_COLS);
	bcopy(&ss->ss_attr[srcrow][0], &ss->ss_attr[dstrow][0],
	    nrows * SM_COLS);
	if (ss != curscr)
		return;
	if (nrows > 25) {
		frows = nrows >> 1;
		if (srcrow > dstrow) {
			bcopy(&sm_addr[(srcrow * SM_NEXTROW)],
			    &sm_addr[(dstrow * SM_NEXTROW)],
			    frows * SM_NEXTROW);
			bcopy(&sm_addr[((srcrow + frows) * SM_NEXTROW)],
			    &sm_addr[((dstrow + frows) * SM_NEXTROW)],
			    (nrows - frows) * SM_NEXTROW);
		} else {
			bcopy(&sm_addr[((srcrow + frows) * SM_NEXTROW)],
			    &sm_addr[((dstrow + frows) * SM_NEXTROW)],
			    (nrows - frows) * SM_NEXTROW);
			bcopy(&sm_addr[(srcrow * SM_NEXTROW)],
			    &sm_addr[(dstrow * SM_NEXTROW)],
			    frows * SM_NEXTROW);
		}
	} else
		bcopy(&sm_addr[(srcrow * SM_NEXTROW)],
		    &sm_addr[(dstrow * SM_NEXTROW)], nrows * SM_NEXTROW);
}
d318 1
a318 70
static void
smg_eraserows(void *id, int startrow, int nrows, long fillattr)
{
	struct smg_screen *ss = id;
	int frows;

	bzero(&ss->ss_image[startrow][0], nrows * SM_COLS);
	bzero(&ss->ss_attr[startrow][0], nrows * SM_COLS);
	if (ss != curscr)
		return;
	if (nrows > 25) {
		frows = nrows >> 1;
		bzero(&sm_addr[(startrow * SM_NEXTROW)], frows * SM_NEXTROW);
		bzero(&sm_addr[((startrow + frows) * SM_NEXTROW)],
		    (nrows - frows) * SM_NEXTROW);
	} else
		bzero(&sm_addr[(startrow * SM_NEXTROW)], nrows * SM_NEXTROW);
}

static int
smg_alloc_attr(void *id, int fg, int bg, int flags, long *attrp)
{
	*attrp = flags;
	return 0;
}

static void
setcursor(struct wsdisplay_cursor *v)
{
	u_short red, green, blue, curfg[16], curmask[16];
	int i;

	/* Enable cursor */
	if (v->which & WSDISPLAY_CURSOR_DOCUR) {
		if (v->enable)
			curcmd |= CUR_CMD_ENPB|CUR_CMD_ENPA;
		else
			curcmd &= ~(CUR_CMD_ENPB|CUR_CMD_ENPA);
		WRITECUR(CUR_CMD, curcmd);
	}
	if (v->which & WSDISPLAY_CURSOR_DOHOT) {
		hotX = v->hot.x;
		hotY = v->hot.y;
	}
	if (v->which & WSDISPLAY_CURSOR_DOCMAP) {
		/* First background */
		copyin(v->cmap.red, &red, sizeof(u_short));
		copyin(v->cmap.green, &green, sizeof(u_short));
		copyin(v->cmap.blue, &blue, sizeof(u_short));
		bgmask = (((30L * red + 59L * green + 11L * blue) >> 8) >=
		    (((1<<8)-1)*50)) ? ~0 : 0;
		copyin(v->cmap.red + 2, &red, sizeof(u_short));
		copyin(v->cmap.green + 2, &green, sizeof(u_short));
		copyin(v->cmap.blue + 2, &blue, sizeof(u_short));
		fgmask = (((30L * red + 59L * green + 11L * blue) >> 8) >=
		    (((1<<8)-1)*50)) ? ~0 : 0;
	}
	if (v->which & WSDISPLAY_CURSOR_DOSHAPE) {
		WRITECUR(CUR_CMD, curcmd | CUR_CMD_LODSA);
		copyin(v->image, curfg, sizeof(curfg));
		copyin(v->mask, curmask, sizeof(curmask));
		for (i = 0; i < sizeof(curfg)/2; i++) {
			WRITECUR(CUR_LOAD, (curfg[i] & fgmask) |
			    ((curmask[i] & ~curfg[i]) & bgmask));
		}
		for (i = 0; i < sizeof(curmask)/2; i++) {
			WRITECUR(CUR_LOAD, curmask[i]);
		}
		WRITECUR(CUR_CMD, curcmd);
	}
d324 4
a327 2
	struct wsdisplay_fbinfo *fb = (void *)data;
	static short curc;
d335 5
a339 4
		fb->height = SM_YWIDTH;
		fb->width = SM_XWIDTH;
		fb->depth = 1;
		fb->cmsize = 2;
d342 2
a343 9
	case WSDISPLAYIO_SVIDEO:
		if (*(u_int *)data == WSDISPLAYIO_VIDEO_ON) {
			curcmd = curc;
		} else {
			curc = curcmd;
			curcmd &= ~(CUR_CMD_FOPA|CUR_CMD_ENPA);
			curcmd |= CUR_CMD_FOPB;
		}
		WRITECUR(CUR_CMD, curcmd);
d346 2
d349 1
a349 2
		*(u_int *)data = (curcmd & CUR_CMD_FOPB ?
		    WSDISPLAYIO_VIDEO_OFF : WSDISPLAYIO_VIDEO_ON);
d352 4
a355 2
	case WSDISPLAYIO_SCURSOR:
		setcursor((struct wsdisplay_cursor *)data);
a356 1

d358 4
a361 4
		curx = ((struct wsdisplay_curpos *)data)->x;
		cury = ((struct wsdisplay_curpos *)data)->y;
		WRITECUR(CUR_XPOS, curx + CUR_XBIAS);
		WRITECUR(CUR_YPOS, cury + CUR_YBIAS);
d363 7
a369 4

	case WSDISPLAYIO_GCURPOS:
		((struct wsdisplay_curpos *)data)->x = curx;
		((struct wsdisplay_curpos *)data)->y = cury;
d373 1
a373 1
		return ENOTTY;
d375 2
a376 1
	return 0;
d379 1
a379 1
static paddr_t
d383 2
a384 1
		return -1;
d392 13
a404 4
	*cookiep = malloc(sizeof(struct smg_screen), M_DEVBUF, M_WAITOK);
	bzero(*cookiep, sizeof(struct smg_screen));
	*curxp = *curyp = *defattrp = 0;
	return 0;
d410 3
d419 17
a435 2
	struct smg_screen *ss = cookie;
	int row, col, line;
d437 25
a461 2
	if (ss == curscr)
		return (0);
a462 18
	for (row = 0; row < SM_ROWS; row++)
		for (line = 0; line < SM_CHEIGHT; line++) {
			for (col = 0; col < SM_COLS; col++) {
				u_char s, c = ss->ss_image[row][col];

				if (c < 32)
					c = 32;
				s = QFONT(c, line);
				if (ss->ss_attr[row][col] & WSATTR_REVERSE)
					s ^= 255;
				SM_ADDR(row, col, line) = s;
			}
			if (ss->ss_attr[row][col] & WSATTR_UNDERLINE)
				SM_ADDR(row, col, line) = 255;
		}
	cursor = &sm_addr[(ss->ss_cury * SM_CHEIGHT * SM_COLS) + ss->ss_curx +
	    ((SM_CHEIGHT - 1) * SM_COLS)];
	curscr = ss;
d466 57
a522 1
cons_decl(smg);
d525 1
a525 2
smgcninit(cndev)
	struct	consdev *cndev;
d527 1
a527 5
	extern void lkccninit(struct consdev *);
	extern int lkccngetc(dev_t);
	extern int dz_vsbus_lk201_cnattach(int);
	/* Clear screen */
	memset(sm_addr, 0, 128*864);
d529 17
a545 4
	curscr = &smg_conscreen;
	wsdisplay_cnattach(&smg_stdscreen, &smg_conscreen, 0, 0, 0);
	cn_tab->cn_pri = CN_INTERNAL;
	qf = qvss8x15.data;
d547 2
a548 4
#if NDZKBD > 0
	dzkbd_cnattach(0); /* Connect keyboard and screen together */
#endif
}
d552 1
a552 1
 * Because it's called before the VM system is inited, virtual memory
d559 1
d561 1
d567 1
a567 2
		if ((vax_confdata & KA420_CFG_L3CON) ||
		    (vax_confdata & KA420_CFG_MULTU))
d569 2
a570 1
		sm_addr = (caddr_t)virtual_avail;
d572 6
a577 1
		ioaccess((vaddr_t)sm_addr, SMADDR, (SMSIZE/VAX_NBPG));
d585 23
@


1.8
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.7 2002/03/14 01:26:49 millert Exp $	*/
d50 3
a52 3
#include "../qbus/dzreg.h"
#include "../qbus/dzvar.h"
#include "../dec/dzkbdvar.h"
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.6 2002/01/03 19:49:02 miod Exp $	*/
d436 3
a438 3
		red = fuswintr(v->cmap.red);
		green = fuswintr(v->cmap.green);
		blue = fuswintr(v->cmap.blue);
d441 3
a443 3
		red = fuswintr(v->cmap.red+2);
		green = fuswintr(v->cmap.green+2);
		blue = fuswintr(v->cmap.blue+2);
@


1.6
log
@cdev_decl(wsdisplay) is already done in <sys/conf.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.5 2001/08/19 23:54:22 miod Exp $	*/
d204 1
a204 1
extern int getmajor __P((void *));	/* conf.c */
d580 1
a580 1
	extern int dz_vsbus_lk201_cnattach __P((int));
@


1.5
log
@The end of old timeouts is near...
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.4 2001/06/15 22:45:34 miod Exp $	*/
a572 1
cdev_decl(wsdisplay);
@


1.5.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.6 2002/01/03 19:49:02 miod Exp $	*/
d573 1
@


1.5.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.5.4.1 2002/01/31 22:55:28 niklas Exp $	*/
d204 1
a204 1
extern int getmajor(void *);	/* conf.c */
d580 1
a580 1
	extern int dz_vsbus_lk201_cnattach(int);
@


1.5.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d436 3
a438 3
		copyin(v->cmap.red, &red, sizeof(u_short));
		copyin(v->cmap.green, &green, sizeof(u_short));
		copyin(v->cmap.blue, &blue, sizeof(u_short));
d441 3
a443 3
		copyin(v->cmap.red + 2, &red, sizeof(u_short));
		copyin(v->cmap.green + 2, &green, sizeof(u_short));
		copyin(v->cmap.blue + 2, &blue, sizeof(u_short));
@


1.4
log
@Compile kernel with -Wall, and fix a few issues for this to work.
ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.3 2001/05/16 22:15:19 hugh Exp $	*/
d41 1
d202 2
d253 2
a254 1
	timeout(smg_crsr_blink, 0, hz/2);
d270 1
a270 1
	timeout(smg_crsr_blink, 0, hz/2);
@


1.3
log
@Blind merge of wscons support from NetBSD/vax. Perhaps someone with a
supported framebuffer (simple monochrome) can finish this off.
If anyone has run across docs for LCG or SPGFX, please get in touch.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.2 2001/02/11 06:34:38 hugh Exp $	*/
d201 2
d432 3
a434 3
		red = fusword(v->cmap.red);
		green = fusword(v->cmap.green);
		blue = fusword(v->cmap.blue);
d437 3
a439 3
		red = fusword(v->cmap.red+2);
		green = fusword(v->cmap.green+2);
		blue = fusword(v->cmap.blue+2);
@


1.2
log
@Pick up a NetBSD hack to attach Cheetah to vsbus as well as ibus.
High kludge factor, but the payoff is vsbus scsi for free.
Most of the work is by Michael Kukat and ragge, with a few other
synchronisations thrown in.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.1 2000/04/27 02:34:50 bjc Exp $	*/
a36 1
#include <sys/callout.h>
d42 5
d49 4
d57 1
a57 4
#include <machine/vsbus.h>
#include <machine/sid.h>
#include <machine/cpu.h>
#include <machine/ka420.h>
d59 4
a62 1
#include "lkc.h"
d64 1
d69 41
d111 2
a112 2
static	int smg_match __P((struct device *, struct cfdata *, void *));
static	void smg_attach __P((struct device *, struct device *, void *));
d119 1
a119 1
	sizeof(struct smg_softc), smg_match, smg_attach,
d122 12
a133 8
static void	smg_cursor __P((void *, int, int, int));
static int	smg_mapchar __P((void *, int, unsigned int *));
static void	smg_putchar __P((void *, int, int, u_int, long));
static void	smg_copycols __P((void *, int, int, int,int));
static void	smg_erasecols __P((void *, int, int, int, long));
static void	smg_copyrows __P((void *, int, int, int));
static void	smg_eraserows __P((void *, int, int, long));
static int	smg_alloc_attr __P((void *, int, int, int, long *));
d164 3
a166 1
extern char q_font[];
d168 1
a168 1
#define QFONT(c,line)	q_font[QCHAR(c) * 15 + line]
d173 8
a180 8
static int	smg_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
static int	smg_mmap __P((void *, off_t, int));
static int	smg_alloc_screen __P((void *, const struct wsscreen_descr *,
				      void **, int *, int *, long *));
static void	smg_free_screen __P((void *, void *));
static int	smg_show_screen __P((void *, void *, int,
				     void (*) (void *, int, int), void *));
static void	smg_crsr_blink __P((void *));
a200 2
static	struct callout smg_cursor_ch = CALLOUT_INITIALIZER;

d202 1
a202 4
smg_match(parent, match, aux)
	struct device *parent;
	struct cfdata *match;
	void *aux;
d218 1
a218 1
	curcmd[0] = 0x7fff;
d221 1
a221 1
	curcmd[0] = 0x8000;
d233 1
a233 3
smg_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d239 1
d248 4
a251 1
	callout_reset(&smc_cursor_ch, hz / 2, smg_crsr_blink, NULL);
d260 1
a260 2
smg_crsr_blink(arg)
	void *arg;
d264 1
a264 1
	callout_reset(&smg_cursor_ch, hz / 2, smg_crsr_blink, NULL);
d268 1
a268 3
smg_cursor(id, on, row, col)
	void *id;
	int on, row, col;
d284 1
a284 4
smg_mapchar(id, uni, index)
	void *id;
	int uni;
	unsigned int *index;
d295 1
a295 5
smg_putchar(id, row, col, c, attr)
	void *id;
	int row, col;
	u_int c;
	long attr;
d320 1
a320 3
smg_copycols(id, row, srccol, dstcol, ncols)
	void *id;
	int row, srccol, dstcol, ncols;
d337 1
a337 4
smg_erasecols(id, row, startcol, ncols, fillattr)
	void *id;
	int row, startcol, ncols;
	long fillattr;
d351 1
a351 3
smg_copyrows(id, srcrow, dstrow, nrows)
	void *id;
	int srcrow, dstrow, nrows;
d385 1
a385 4
smg_eraserows(id, startrow, nrows, fillattr)
	void *id;
	int startrow, nrows;
	long fillattr;
d404 1
a404 5
smg_alloc_attr(id, fg, bg, flags, attrp)
	void *id;
	int fg, bg;
	int flags;
	long *attrp;
d410 46
d457 1
a457 6
smg_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d459 2
a460 1
	struct wsdisplay_fbinfo fb;
d464 1
a464 1
		*(u_int *)data = WSDISPLAY_TYPE_PM_MONO;
d468 37
a504 3
		fb.height = 864;
		fb.width = 1024;
		return copyout(&fb, data, sizeof(struct wsdisplay_fbinfo));
a505 1
	
d507 1
a507 1
		return -1;
d512 2
a513 5
static int
smg_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d521 2
a522 6
smg_alloc_screen(v, type, cookiep, curxp, curyp, defattrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *defattrp;
d531 1
a531 3
smg_free_screen(v, cookie)
	void *v;
	void *cookie;
d536 2
a537 6
smg_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb) __P((void *, int, int));
	void *cbarg;
d567 1
a567 2

#define WSCONSOLEMAJOR 68
d573 3
a575 2
	extern void lkccninit __P((struct consdev *));
	extern int lkccngetc __P((dev_t));
d582 4
a585 3
#if 0
	lkccninit(cndev);
	wsdisplay_set_cons_kbd(lkccngetc, nullcnpollc);
d611 1
a611 1
		cndev->cn_dev = makedev(WSCONSOLEMAJOR, 0);
@


1.2.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.2 2001/02/11 06:34:38 hugh Exp $	*/
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.2.4.1 2001/05/14 21:39:22 niklas Exp $	*/
d37 1
a42 5
#include <machine/vsbus.h>
#include <machine/sid.h>
#include <machine/cpu.h>
#include <machine/ka420.h>

a44 4
#include "../qbus/dzreg.h"
#include "../qbus/dzvar.h"
#include "../dec/dzkbdvar.h"

d49 4
a52 1
#include "dzkbd.h"
d54 1
a54 4
/* Safety guard */
#ifndef FONT_QVSS8x15
#include <dev/wsfont/qvss8x15.h>
#endif
a55 1
/* Screen hardware defs */
a59 2
#define SM_YWIDTH	864
#define SM_XWIDTH	1024
d61 2
a62 41
/* Cursor register definitions */
#define CUR_CMD		0
#define CUR_XPOS	4
#define CUR_YPOS	8
#define CUR_XMIN_1	12
#define CUR_XMAX_1	16
#define CUR_YMIN_1	20
#define CUR_YMAX_1	24
#define CUR_XMIN_2	28
#define CUR_XMAX_2	32
#define CUR_YMIN_2	36
#define CUR_YMAX_2	40
#define CUR_LOAD	44

#define CUR_CMD_TEST	0x8000
#define CUR_CMD_HSHI	0x4000
#define CUR_CMD_VBHI	0x2000
#define CUR_CMD_LODSA	0x1000
#define CUR_CMD_FORG2	0x0800
#define CUR_CMD_ENRG2	0x0400
#define CUR_CMD_FORG1	0x0200
#define CUR_CMD_ENRG1	0x0100
#define CUR_CMD_XHWID	0x0080
#define CUR_CMD_XHCL1	0x0040
#define CUR_CMD_XHCLP	0x0020
#define CUR_CMD_XHAIR	0x0010
#define CUR_CMD_FOPB	0x0008
#define CUR_CMD_ENPB	0x0004
#define CUR_CMD_FOPA	0x0002
#define CUR_CMD_ENPA	0x0001

#define CUR_XBIAS	216	/* Add to cursor position */
#define CUR_YBIAS	33

#define	WRITECUR(addr, val)	*(volatile short *)(curaddr + (addr)) = (val)
static	caddr_t	curaddr;
static	short curcmd, curx, cury, hotX, hotY;
static	int bgmask, fgmask; 

static	int smg_match(struct device *, struct cfdata *, void *);
static	void smg_attach(struct device *, struct device *, void *);
d69 1
a69 5
	sizeof(struct smg_softc), (cfmatch_t)smg_match, smg_attach,
};

struct	cfdriver smg_cd = {
	NULL, "smg", DV_DULL
d72 8
a79 8
static void	smg_cursor(void *, int, int, int);
static int	smg_mapchar(void *, int, unsigned int *);
static void	smg_putchar(void *, int, int, u_int, long);
static void	smg_copycols(void *, int, int, int,int);
static void	smg_erasecols(void *, int, int, int, long);
static void	smg_copyrows(void *, int, int, int);
static void	smg_eraserows(void *, int, int, long);
static int	smg_alloc_attr(void *, int, int, int, long *);
d110 1
a110 3
extern struct wsdisplay_font qvss8x15;
static u_char *qf;

d112 1
a112 1
#define QFONT(c,line)	qf[QCHAR(c) * 15 + line]
d117 8
a124 8
static int	smg_ioctl(void *, u_long, caddr_t, int, struct proc *);
static paddr_t	smg_mmap(void *, off_t, int);
static int	smg_alloc_screen(void *, const struct wsscreen_descr *,
				      void **, int *, int *, long *);
static void	smg_free_screen(void *, void *);
static int	smg_show_screen(void *, void *, int,
				     void (*) (void *, int, int), void *);
static void	smg_crsr_blink(void *);
d145 1
a145 1
extern int getmajor __P((void *));	/* conf.c */
d148 4
a151 1
smg_match(struct device *parent, struct cfdata *match, void *aux)
d167 1
a167 1
	curcmd[0] = CUR_CMD_HSHI|CUR_CMD_FOPB;
d170 1
a170 1
	curcmd[0] = CUR_CMD_TEST|CUR_CMD_HSHI;
d182 3
a184 1
smg_attach(struct device *parent, struct device *self, void *aux)
a189 1
	curaddr = (caddr_t)vax_map_physmem(KA420_CUR_BASE, 1);
d198 1
a198 4
	timeout(smg_crsr_blink, 0, hz/2);
	curcmd = CUR_CMD_HSHI;
	WRITECUR(CUR_CMD, curcmd);
	qf = qvss8x15.data;
d207 2
a208 1
smg_crsr_blink(void *arg)
d212 1
a212 1
	timeout(smg_crsr_blink, 0, hz/2);
d216 3
a218 1
smg_cursor(void *id, int on, int row, int col)
d234 4
a237 1
smg_mapchar(void *id, int uni, unsigned int *index)
d248 5
a252 1
smg_putchar(void *id, int row, int col, u_int c, long attr)
d277 3
a279 1
smg_copycols(void *id, int row, int srccol, int dstcol, int ncols)
d296 4
a299 1
smg_erasecols(void *id, int row, int startcol, int ncols, long fillattr)
d313 3
a315 1
smg_copyrows(void *id, int srcrow, int dstrow, int nrows)
d349 4
a352 1
smg_eraserows(void *id, int startrow, int nrows, long fillattr)
d371 5
a375 1
smg_alloc_attr(void *id, int fg, int bg, int flags, long *attrp)
a380 46
static void
setcursor(struct wsdisplay_cursor *v)
{
	u_short red, green, blue, curfg[16], curmask[16];
	int i;

	/* Enable cursor */
	if (v->which & WSDISPLAY_CURSOR_DOCUR) {
		if (v->enable)
			curcmd |= CUR_CMD_ENPB|CUR_CMD_ENPA;
		else
			curcmd &= ~(CUR_CMD_ENPB|CUR_CMD_ENPA);
		WRITECUR(CUR_CMD, curcmd);
	}
	if (v->which & WSDISPLAY_CURSOR_DOHOT) {
		hotX = v->hot.x;
		hotY = v->hot.y;
	}
	if (v->which & WSDISPLAY_CURSOR_DOCMAP) {
		/* First background */
		red = fuswintr(v->cmap.red);
		green = fuswintr(v->cmap.green);
		blue = fuswintr(v->cmap.blue);
		bgmask = (((30L * red + 59L * green + 11L * blue) >> 8) >=
		    (((1<<8)-1)*50)) ? ~0 : 0;
		red = fuswintr(v->cmap.red+2);
		green = fuswintr(v->cmap.green+2);
		blue = fuswintr(v->cmap.blue+2);
		fgmask = (((30L * red + 59L * green + 11L * blue) >> 8) >=
		    (((1<<8)-1)*50)) ? ~0 : 0;
	}
	if (v->which & WSDISPLAY_CURSOR_DOSHAPE) {
		WRITECUR(CUR_CMD, curcmd | CUR_CMD_LODSA);
		copyin(v->image, curfg, sizeof(curfg));
		copyin(v->mask, curmask, sizeof(curmask));
		for (i = 0; i < sizeof(curfg)/2; i++) {
			WRITECUR(CUR_LOAD, (curfg[i] & fgmask) |
			    ((curmask[i] & ~curfg[i]) & bgmask));
		}
		for (i = 0; i < sizeof(curmask)/2; i++) {
			WRITECUR(CUR_LOAD, curmask[i]);
		}
		WRITECUR(CUR_CMD, curcmd);
	}
}

d382 6
a387 1
smg_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
d389 1
a389 2
	struct wsdisplay_fbinfo *fb = (void *)data;
	static short curc;
d393 1
a393 1
		*(u_int *)data = WSDISPLAY_TYPE_VAX_MONO;
d397 3
a399 37
		fb->height = SM_YWIDTH;
		fb->width = SM_XWIDTH;
		fb->depth = 1;
		fb->cmsize = 2;
		break;

	case WSDISPLAYIO_SVIDEO:
		if (*(u_int *)data == WSDISPLAYIO_VIDEO_ON) {
			curcmd = curc;
		} else {
			curc = curcmd;
			curcmd &= ~(CUR_CMD_FOPA|CUR_CMD_ENPA);
			curcmd |= CUR_CMD_FOPB;
		}
		WRITECUR(CUR_CMD, curcmd);
		break;

	case WSDISPLAYIO_GVIDEO:
		*(u_int *)data = (curcmd & CUR_CMD_FOPB ?
		    WSDISPLAYIO_VIDEO_OFF : WSDISPLAYIO_VIDEO_ON);
		break;

	case WSDISPLAYIO_SCURSOR:
		setcursor((struct wsdisplay_cursor *)data);
		break;

	case WSDISPLAYIO_SCURPOS:
		curx = ((struct wsdisplay_curpos *)data)->x;
		cury = ((struct wsdisplay_curpos *)data)->y;
		WRITECUR(CUR_XPOS, curx + CUR_XBIAS);
		WRITECUR(CUR_YPOS, cury + CUR_YBIAS);
		break;

	case WSDISPLAYIO_GCURPOS:
		((struct wsdisplay_curpos *)data)->x = curx;
		((struct wsdisplay_curpos *)data)->y = cury;
		break;
d401 1
d403 1
a403 1
		return ENOTTY;
d408 5
a412 2
static paddr_t
smg_mmap(void *v, off_t offset, int prot)
d420 6
a425 2
smg_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *defattrp)
d434 3
a436 1
smg_free_screen(void *v, void *cookie)
d441 6
a446 2
smg_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
d476 2
a477 1
cdev_decl(wsdisplay);
d483 2
a484 3
	extern void lkccninit(struct consdev *);
	extern int lkccngetc(dev_t);
	extern int dz_vsbus_lk201_cnattach __P((int));
d491 3
a493 4
	qf = qvss8x15.data;

#if NDZKBD > 0
	dzkbd_cnattach(0); /* Connect keyboard and screen together */
d519 1
a519 1
		cndev->cn_dev = makedev(getmajor(wsdisplayopen), 0);
@


1.2.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: smg.c,v 1.2.4.2 2001/07/04 10:24:50 niklas Exp $	*/
a40 1
#include <sys/timeout.h>
a200 2
static	struct timeout smg_blink_timeout;

d250 1
a250 2
	timeout_set(&smg_blink_timeout, smg_crsr_blink, NULL);
	timeout_add(&smg_blink_timeout, hz / 2);
d266 1
a266 1
	timeout_add(&smg_blink_timeout, hz / 2);
@


1.2.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d573 1
@


1.2.4.5
log
@Merge in -current from about a week ago
@
text
@d204 1
a204 1
extern int getmajor(void *);	/* conf.c */
d580 1
a580 1
	extern int dz_vsbus_lk201_cnattach(int);
@


1.2.4.6
log
@Sync the SMP branch with 3.3
@
text
@d436 3
a438 3
		copyin(v->cmap.red, &red, sizeof(u_short));
		copyin(v->cmap.green, &green, sizeof(u_short));
		copyin(v->cmap.blue, &blue, sizeof(u_short));
d441 3
a443 3
		copyin(v->cmap.red + 2, &red, sizeof(u_short));
		copyin(v->cmap.green + 2, &green, sizeof(u_short));
		copyin(v->cmap.blue + 2, &blue, sizeof(u_short));
@


1.1
log
@forgot these, oops
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 1
a158 1
	if (vax_boardtype == VAX_BTYP_49)
@

