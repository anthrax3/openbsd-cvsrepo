head	1.18;
access;
symbols
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.17;
commitid	OSDG2O3Cgeifnf1W;

1.17
date	2015.02.09.22.38.18;	author miod;	state Exp;
branches;
next	1.16;
commitid	vb6OXfOs7ZuXjp4A;

1.16
date	2014.01.21.03.42.21;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2012.12.05.23.20.15;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.11.19.29.01;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.01.16.32.30;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.11.19.20.26;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.18.09.49.23;	author hugh;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.02.11.06.34.37;	author hugh;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.02.06.04.27.45;	author hugh;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.11.05.45.30;	author bjc;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.21.39.15;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2003.05.19.21.46.10;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: asc_vsbus.c,v 1.17 2015/02/09 22:38:18 miod Exp $	*/
/*	$NetBSD: asc_vsbus.c,v 1.22 2001/02/04 20:36:32 ragge Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/queue.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <machine/bus.h>
#include <machine/vmparam.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>

#include <machine/cpu.h>
#include <machine/sid.h>
#include <machine/scb.h>
#include <machine/vsbus.h>
#include <machine/clock.h>	/* for SCSI ctlr ID# XXX */

struct asc_vsbus_softc {
	struct ncr53c9x_softc sc_ncr53c9x;	/* Must be first */
	struct evcount sc_intrcnt;		/* count interrupts */
	int	sc_cvec;			/* vector */
	bus_space_tag_t sc_bst;			/* bus space tag */
	bus_space_handle_t sc_bsh;		/* bus space handle */
	bus_space_handle_t sc_dirh;		/* scsi direction handle */
	bus_space_handle_t sc_adrh;		/* scsi address handle */
	bus_space_handle_t sc_ncrh;		/* ncr bus space handle */
	bus_dma_tag_t sc_dmat;			/* bus dma tag */
	bus_dmamap_t sc_dmamap;
	caddr_t *sc_dmaaddr;
	size_t *sc_dmalen;
	size_t sc_dmasize;
	unsigned int sc_flags;
#define	ASC_FROMMEMORY		0x0001		/* Must be 1 */
#define	ASC_DMAACTIVE		0x0002
#define	ASC_MAPLOADED		0x0004
	unsigned long sc_xfers;
};

#define	ASC_REG_KA46_ADR	0x0000
#define	ASC_REG_KA46_DIR	0x000C
#define	ASC_REG_KA49_ADR	0x0000
#define	ASC_REG_KA49_DIR	0x0004
#define	ASC_REG_NCR		0x0080
#define	ASC_REG_END		0x00B0

#define	ASC_MAXXFERSIZE		65536
#define	ASC_FREQUENCY		25000000

extern struct cfdriver sd_cd;

int asc_vsbus_match(struct device *, void *, void *);
void asc_vsbus_attach(struct device *, struct device *, void *);

struct cfattach asc_vsbus_ca = {
	sizeof(struct asc_vsbus_softc), asc_vsbus_match, asc_vsbus_attach
};

struct cfdriver asc_cd = {
	NULL, "asc", DV_DULL
};

/*
 * Functions and the switch for the MI code
 */
u_char	asc_vsbus_read_reg(struct ncr53c9x_softc *, int);
void	asc_vsbus_write_reg(struct ncr53c9x_softc *, int, u_char);
int	asc_vsbus_dma_isintr(struct ncr53c9x_softc *);
void	asc_vsbus_dma_reset(struct ncr53c9x_softc *);
int	asc_vsbus_dma_intr(struct ncr53c9x_softc *);
int	asc_vsbus_dma_setup(struct ncr53c9x_softc *, caddr_t *,
	    size_t *, int, size_t *);
void	asc_vsbus_dma_go(struct ncr53c9x_softc *);
void	asc_vsbus_dma_stop(struct ncr53c9x_softc *);
int	asc_vsbus_dma_isactive(struct ncr53c9x_softc *);
int	asc_vsbus_controller_id(void);

static struct ncr53c9x_glue asc_vsbus_glue = {
	asc_vsbus_read_reg,
	asc_vsbus_write_reg,
	asc_vsbus_dma_isintr,
	asc_vsbus_dma_reset,
	asc_vsbus_dma_intr,
	asc_vsbus_dma_setup,
	asc_vsbus_dma_go,
	asc_vsbus_dma_stop,
	asc_vsbus_dma_isactive,
	NULL,
};

static u_int8_t asc_attached;		/* can't have more than one asc */

int
asc_vsbus_match(struct device *parent, void *conf, void *aux)
{
	struct vsbus_attach_args *va = aux;
	struct cfdata *cf = conf;
	volatile u_int8_t *ncr_regs;
	volatile int dummy;

	if (asc_attached)
		return 0;

	switch (vax_boardtype) {
	case VAX_BTYP_46:
	case VAX_BTYP_48:
		if (cf->cf_loc[0] != (SCA_REGS | 0x80))
			return 0;
		break;
	case VAX_BTYP_49:
	case VAX_BTYP_1303:
		if (cf->cf_loc[0] != (SCA_REGS_KA49 | 0x80))
			return 0;
		break;
	default:
		return 0;
	}

	ncr_regs = (volatile u_int8_t *) va->va_addr;

	/*  *** need to generate an interrupt here
	 * From trial and error, I've determined that an INT is generated
	 * only when the following sequence of events occurs:
	 *   1) The interrupt status register (0x05) must be read.
	 *   2) SCSI bus reset interrupt must be enabled
	 *   3) SCSI bus reset command must be sent
	 *   4) NOP command must be sent
	 */

	dummy = ncr_regs[NCR_INTR << 2] & 0xFF;
        ncr_regs[NCR_CFG1 << 2] = asc_vsbus_controller_id(); /* turn on INT
							   for SCSI reset */
        ncr_regs[NCR_CMD << 2] = NCRCMD_RSTSCSI;	/* send the reset */
        ncr_regs[NCR_CMD << 2] = NCRCMD_NOP;		/* send a NOP */
	DELAY(10000);

	dummy = ncr_regs[NCR_INTR << 2] & 0xFF;
	return (dummy & NCRINTR_SBR) != 0;
}


/*
 * Attach this instance, and then all the sub-devices
 */
void
asc_vsbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct vsbus_attach_args *va = aux;
	struct asc_vsbus_softc *asc = (void *)self;
	struct ncr53c9x_softc *sc = &asc->sc_ncr53c9x;
	int error;

	asc_attached = 1;
	/*
	 * Set up glue for MI code early; we use some of it here.
	 */
	sc->sc_glue = &asc_vsbus_glue;

	asc->sc_bst = va->va_iot;
	asc->sc_dmat = va->va_dmat;

	error = bus_space_map(asc->sc_bst, va->va_paddr - ASC_REG_NCR,
	    ASC_REG_END, 0, &asc->sc_bsh);
	if (error) {
		printf(": failed to map registers: error=%d\n", error);
		return;
	}
	error = bus_space_subregion(asc->sc_bst, asc->sc_bsh, ASC_REG_NCR,
	    ASC_REG_END - ASC_REG_NCR, &asc->sc_ncrh);
	if (error) {
		printf(": failed to map ncr registers: error=%d\n", error);
		return;
	}
	if (vax_boardtype == VAX_BTYP_46 || vax_boardtype == VAX_BTYP_48) {
		error = bus_space_subregion(asc->sc_bst, asc->sc_bsh,
		    ASC_REG_KA46_ADR, sizeof(u_int32_t), &asc->sc_adrh);
		if (error) {
			printf(": failed to map adr register: error=%d\n",
			     error);
			return;
		}
		error = bus_space_subregion(asc->sc_bst, asc->sc_bsh,
		    ASC_REG_KA46_DIR, sizeof(u_int32_t), &asc->sc_dirh);
		if (error) {
			printf(": failed to map dir register: error=%d\n",
			     error);
			return;
		}
	} else {
		/* This is a gross and disgusting kludge but it'll
		 * save a bunch of ugly code.  Unlike the VS4000/60,
		 * the SCSI Address and direction registers are not
		 * near the SCSI NCR registers and are inside the 
		 * block of general VAXstation registers.  So we grab
		 * them from there and knowing the internals of the 
		 * bus_space implementation, we cast to bus_space_handles.
		 */
		struct vsbus_softc *vsc = (struct vsbus_softc *) parent;
		asc->sc_adrh = (bus_space_handle_t) (vsc->sc_vsregs + ASC_REG_KA49_ADR);
		asc->sc_dirh = (bus_space_handle_t) (vsc->sc_vsregs + ASC_REG_KA49_DIR);
#if 0
		printf("\n%s: adrh=0x%08lx dirh=0x%08lx", self->dv_xname,
		       asc->sc_adrh, asc->sc_dirh);
		ncr53c9x_debug = NCR_SHOWDMA|NCR_SHOWINTS|NCR_SHOWCMDS|NCR_SHOWPHASE|NCR_SHOWSTART|NCR_SHOWMSGS;
#endif
	}
	error = bus_dmamap_create(asc->sc_dmat, ASC_MAXXFERSIZE, 1, 
	    ASC_MAXXFERSIZE, 0, BUS_DMA_NOWAIT, &asc->sc_dmamap);

	sc->sc_id = asc_vsbus_controller_id();
	sc->sc_freq = ASC_FREQUENCY;

	/* gimme MHz */
	sc->sc_freq /= 1000000;

	scb_vecalloc(va->va_cvec, (void (*)(void *)) ncr53c9x_intr,
	    &asc->sc_ncr53c9x, SCB_ISTACK, &asc->sc_intrcnt);
	asc->sc_cvec = va->va_cvec;
	evcount_attach(&asc->sc_intrcnt, self->dv_xname, &asc->sc_cvec);

	/*
	 * XXX More of this should be in ncr53c9x_attach(), but
	 * XXX should we really poke around the chip that much in
	 * XXX the MI code?  Think about this more...
	 */

	/*
	 * Set up static configuration info.
	 */
	sc->sc_cfg1 = sc->sc_id | NCRCFG1_PARENB;
	sc->sc_cfg2 = NCRCFG2_SCSI2;
	sc->sc_cfg3 = 0;
	sc->sc_rev = NCR_VARIANT_NCR53C94;

	/*
	 * XXX minsync and maxxfer _should_ be set up in MI code,
	 * XXX but it appears to have some dependency on what sort
	 * XXX of DMA we're hooked up to, etc.
	 */

	/*
	 * This is the value used to start sync negotiations
	 * Note that the NCR register "SYNCTP" is programmed
	 * in "clocks per byte", and has a minimum value of 4.
	 * The SCSI period used in negotiation is one-fourth
	 * of the time (in nanoseconds) needed to transfer one byte.
	 * Since the chip's clock is given in MHz, we have the following
	 * formula: 4 * period = (1000 / freq) * 4
	 */
	sc->sc_minsync = (1000 / sc->sc_freq);
	sc->sc_maxxfer = 64 * 1024;

	/* Do the common parts of attachment. */
	ncr53c9x_attach(sc);
}

/*
 * Return the host controllers SCSI ID.
 * The factory default is 6 (unlike most vendors who use 7), but this can
 * be changed in the prom.
 */
int
asc_vsbus_controller_id()
{
	switch (vax_boardtype) {
#if defined(VAX46) || defined(VAX48) || defined(VAX49)
	case VAX_BTYP_46:
	case VAX_BTYP_48:
	case VAX_BTYP_49:
		return (clk_page[0xbc / 2] >> clk_tweak) & 7;
#endif
	default:
		return 6;	/* XXX need to get this from VMB */
	}
}

/*
 * Glue functions.
 */

u_char
asc_vsbus_read_reg(struct ncr53c9x_softc *sc, int reg)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;

	return bus_space_read_1(asc->sc_bst, asc->sc_ncrh,
	    reg * sizeof(u_int32_t));
}

void
asc_vsbus_write_reg(struct ncr53c9x_softc *sc, int reg, u_char val)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;

	bus_space_write_1(asc->sc_bst, asc->sc_ncrh,
	    reg * sizeof(u_int32_t), val);
}

int
asc_vsbus_dma_isintr(struct ncr53c9x_softc *sc)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;
	return bus_space_read_1(asc->sc_bst, asc->sc_ncrh,
	    NCR_STAT * sizeof(u_int32_t)) & NCRSTAT_INT;
}

void
asc_vsbus_dma_reset(struct ncr53c9x_softc *sc)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;

	if (asc->sc_flags & ASC_MAPLOADED)
		bus_dmamap_unload(asc->sc_dmat, asc->sc_dmamap);
	asc->sc_flags &= ~(ASC_DMAACTIVE|ASC_MAPLOADED);
}

int
asc_vsbus_dma_intr(struct ncr53c9x_softc *sc)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;
	u_int tcl, tcm;
	int trans, resid;
	
	if ((asc->sc_flags & ASC_DMAACTIVE) == 0)
		panic("asc_vsbus_dma_intr: DMA wasn't active");

	asc->sc_flags &= ~ASC_DMAACTIVE;

	if (asc->sc_dmasize == 0) {
		/* A "Transfer Pad" operation completed */
		tcl = NCR_READ_REG(sc, NCR_TCL); 
		tcm = NCR_READ_REG(sc, NCR_TCM);
		NCR_DMA(("asc_vsbus_intr: discarded %d bytes (tcl=%d, tcm=%d)\n",
		    tcl | (tcm << 8), tcl, tcm));
		return 0;
	}

	resid = 0;
	if ((resid = (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF)) != 0) {
		NCR_DMA(("asc_vsbus_intr: empty FIFO of %d ", resid));
		DELAY(1);
	}
	if (asc->sc_flags & ASC_MAPLOADED) {
		bus_dmamap_sync(asc->sc_dmat, asc->sc_dmamap,
				0, asc->sc_dmasize,
				asc->sc_flags & ASC_FROMMEMORY
					? BUS_DMASYNC_POSTWRITE
					: BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(asc->sc_dmat, asc->sc_dmamap);
	}
	asc->sc_flags &= ~ASC_MAPLOADED;

	resid += (tcl = NCR_READ_REG(sc, NCR_TCL));
	resid += (tcm = NCR_READ_REG(sc, NCR_TCM)) << 8;

	trans = asc->sc_dmasize - resid;
	if (trans < 0) {			/* transferred < 0 ? */
		printf("%s: xfer (%d) > req (%lu)\n",
		    __func__, trans, (u_long) asc->sc_dmasize);
		trans = asc->sc_dmasize;
	}
	NCR_DMA(("asc_vsbus_intr: tcl=%d, tcm=%d; trans=%d, resid=%d\n",
	    tcl, tcm, trans, resid));

	*asc->sc_dmalen -= trans;
	*asc->sc_dmaaddr += trans;
	
	asc->sc_xfers++;
	return 0;
}

int
asc_vsbus_dma_setup(struct ncr53c9x_softc *sc, caddr_t *addr, size_t *len,
		    int datain, size_t *dmasize)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;

	asc->sc_dmaaddr = addr;
	asc->sc_dmalen = len;
	if (datain) {
		asc->sc_flags &= ~ASC_FROMMEMORY;
	} else {
		asc->sc_flags |= ASC_FROMMEMORY;
	}
#ifdef DIAGNOSTIC
	if ((vaddr_t) *asc->sc_dmaaddr < VM_MIN_KERNEL_ADDRESS)
		panic("asc_vsbus_dma_setup: dma address (%p) outside of kernel",
		    *asc->sc_dmaaddr);
#endif

        NCR_DMA(("%s: start %d@@%p,%d\n", sc->sc_dev.dv_xname,
                (int)*asc->sc_dmalen, *asc->sc_dmaaddr, (asc->sc_flags & ASC_FROMMEMORY)));
	*dmasize = asc->sc_dmasize = min(*dmasize, ASC_MAXXFERSIZE);

	if (asc->sc_dmasize) {
		if (bus_dmamap_load(asc->sc_dmat, asc->sc_dmamap,
				*asc->sc_dmaaddr, asc->sc_dmasize,
				NULL /* kernel address */,   
				BUS_DMA_NOWAIT|VAX_BUS_DMA_SPILLPAGE))
			panic("%s: cannot load dma map", sc->sc_dev.dv_xname);
		bus_dmamap_sync(asc->sc_dmat, asc->sc_dmamap,
				0, asc->sc_dmasize,
				asc->sc_flags & ASC_FROMMEMORY
					? BUS_DMASYNC_PREWRITE
					: BUS_DMASYNC_PREREAD);
		bus_space_write_4(asc->sc_bst, asc->sc_adrh, 0,
				  asc->sc_dmamap->dm_segs[0].ds_addr);
		bus_space_write_4(asc->sc_bst, asc->sc_dirh, 0,
				  asc->sc_flags & ASC_FROMMEMORY);
		NCR_DMA(("%s: dma-load %lu@@0x%08lx\n", sc->sc_dev.dv_xname,
			asc->sc_dmamap->dm_segs[0].ds_len,
			asc->sc_dmamap->dm_segs[0].ds_addr));
		asc->sc_flags |= ASC_MAPLOADED;
	}

	return 0;
}

void
asc_vsbus_dma_go(struct ncr53c9x_softc *sc)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;

	asc->sc_flags |= ASC_DMAACTIVE;
}

void
asc_vsbus_dma_stop(struct ncr53c9x_softc *sc)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;

	if (asc->sc_flags & ASC_MAPLOADED) {
		bus_dmamap_sync(asc->sc_dmat, asc->sc_dmamap,
				0, asc->sc_dmasize,
				asc->sc_flags & ASC_FROMMEMORY
					? BUS_DMASYNC_POSTWRITE
					: BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(asc->sc_dmat, asc->sc_dmamap);
	}

	asc->sc_flags &= ~(ASC_DMAACTIVE|ASC_MAPLOADED);
}

int
asc_vsbus_dma_isactive(struct ncr53c9x_softc *sc)
{
	struct asc_vsbus_softc *asc = (struct asc_vsbus_softc *)sc;

	return (asc->sc_flags & ASC_DMAACTIVE) != 0;
}
@


1.17
log
@Move consistency check within #ifdef DIAGNOSTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.16 2014/01/21 03:42:21 dlg Exp $	*/
@


1.16
log
@dtucker@@ pointed out i suck at grep.

fix ncr53c9x fallout.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.15 2012/12/05 23:20:15 deraadt Exp $	*/
d427 1
d431 1
@


1.15
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.14 2011/09/11 19:29:01 miod Exp $	*/
a104 7
struct scsi_adapter	asc_vsbus_ops = {
	ncr53c9x_scsi_cmd,	
	scsi_minphys,
	NULL,
	NULL
};

d296 1
a296 1
	ncr53c9x_attach(sc, &asc_vsbus_ops);
@


1.14
log
@Define symbolic constants for the addresses of the vsbus devices on
512KB PROM systems (e.g. KA49), or 256KB PROM systems built after KA49
(e.g. KA5[234]), and use them instead of pouring magic numbers all over the (md)
tree.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.13 2010/09/20 06:33:48 matthew Exp $	*/
a31 2

#include <sys/cdefs.h>			/* RCS ID & Copyright macro defns */
@


1.13
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.12 2010/06/28 18:31:01 krw Exp $	*/
d155 4
a158 2
	if (vax_boardtype == VAX_BTYP_46 || vax_boardtype == VAX_BTYP_48) {
		if (cf->cf_loc[0] != 0x200c0080)
d160 4
a163 3
	} else if (vax_boardtype == VAX_BTYP_49 ||
	    vax_boardtype == VAX_BTYP_1303) {
		if (cf->cf_loc[0] != 0x26000080)
d165 2
a166 1
	} else {
@


1.12
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.11 2010/06/26 23:24:44 guenther Exp $	*/
d266 1
a266 2
	evcount_attach(&asc->sc_intrcnt, self->dv_xname,
	    (void *)&asc->sc_cvec, &evcount_intr);
@


1.11
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.10 2009/02/16 21:19:06 miod Exp $	*/
a113 8
static struct scsi_device asc_vsbus_dev = {
	NULL,			/* Use the default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* use the default done handler */
};


d302 1
a302 1
	ncr53c9x_attach(sc, &asc_vsbus_ops, &asc_vsbus_dev);
@


1.10
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.9 2008/06/26 05:42:14 ray Exp $	*/
a43 1
#include <sys/user.h>
@


1.9
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.8 2007/08/01 16:32:30 miod Exp $	*/
d110 1
a110 1
	minphys,
@


1.8
log
@Figure out the host SCSI controller ID on KA48 (VLC) and KA49 (VS4k/9x) from
the nvram settings, as already done on KA46 (VS4k/6x); from Hans Rosenfeld
on port-vax@@netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.7 2004/07/07 23:10:46 deraadt Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	  This product includes software developed by the NetBSD
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.7
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.6 2003/02/11 19:20:26 mickey Exp $	*/
d104 2
a105 2
static int asc_vsbus_match(struct device *, void *, void *);
static void asc_vsbus_attach(struct device *, struct device *, void *);
d133 11
a143 10
static u_char	asc_vsbus_read_reg(struct ncr53c9x_softc *, int);
static void	asc_vsbus_write_reg(struct ncr53c9x_softc *, int, u_char);
static int	asc_vsbus_dma_isintr(struct ncr53c9x_softc *);
static void	asc_vsbus_dma_reset(struct ncr53c9x_softc *);
static int	asc_vsbus_dma_intr(struct ncr53c9x_softc *);
static int	asc_vsbus_dma_setup(struct ncr53c9x_softc *, caddr_t *,
		    size_t *, int, size_t *);
static void	asc_vsbus_dma_go(struct ncr53c9x_softc *);
static void	asc_vsbus_dma_stop(struct ncr53c9x_softc *);
static int	asc_vsbus_dma_isactive(struct ncr53c9x_softc *);
d160 2
a161 2
static int
asc_vsbus_match( struct device *parent, void *conf, void *aux)
d166 1
a166 1
	int dummy;
d194 4
a197 3
        ncr_regs[NCR_CFG1 << 2] = 0x06; /* we're ID 6, turn on INT for SCSI reset */
        ncr_regs[NCR_CMD << 2] = NCRCMD_RSTSCSI; /* send the reset */
        ncr_regs[NCR_CMD << 2] = NCRCMD_NOP; /* send a NOP */
d208 1
a208 1
static void
d273 1
a273 11
	switch (vax_boardtype) {
#if defined(VAX46)
	case VAX_BTYP_46:
		sc->sc_id = (clk_page[0xbc/2] >> clk_tweak) & 7;
		break;
#endif
	default:
		sc->sc_id = 6;	/* XXX need to get this from VMB */
		break;
	}

d322 20
d345 1
a345 1
static u_char
d354 2
a355 5
static void
asc_vsbus_write_reg(sc, reg, val)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char val;
d363 2
a364 3
static int
asc_vsbus_dma_isintr(sc)
	struct ncr53c9x_softc *sc;
d371 2
a372 3
static void
asc_vsbus_dma_reset(sc)
	struct ncr53c9x_softc *sc;
d381 2
a382 3
static int
asc_vsbus_dma_intr(sc)
	struct ncr53c9x_softc *sc;
d422 2
a423 2
		printf("asc_vsbus_intr: xfer (%d) > req (%lu)\n",
		    trans, (u_long) asc->sc_dmasize);
d436 1
a436 1
static int
d481 1
a481 1
static void
d489 1
a489 1
static void
d506 1
a506 1
static int
@


1.6
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.5 2002/09/18 09:49:23 hugh Exp $	*/
d73 2
a74 1
	struct evcnt sc_intrcnt;		/* count interrupts */
d289 3
a291 1
	evcnt_attach(self, "intr", &asc->sc_intrcnt);
a323 2

	printf("\n%s", self->dv_xname);	/* Pretty print */
@


1.5
log
@From NetBSD and in line with recent local changes:
:  date: 2002/09/13 03:00:18;  author: chuck;  state: Exp;  lines: +3 -3
:  increase sc_maxxfer from 63K to 64K.   otherwise fsck fails for
:  file systems with larger block sizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.4 2001/08/25 13:33:37 hugh Exp $	*/
d283 1
a283 1
	/* gimme Mhz */
@


1.4
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.3 2001/02/11 06:34:37 hugh Exp $	*/
d320 1
a320 1
	sc->sc_maxxfer = 63 * 1024;
@


1.4.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.4 2001/08/25 13:33:37 hugh Exp $	*/
d320 1
a320 1
	sc->sc_maxxfer = 64 * 1024;
@


1.4.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d283 1
a283 1
	/* gimme MHz */
@


1.3
log
@Pick up a NetBSD hack to attach Cheetah to vsbus as well as ibus.
High kludge factor, but the payoff is vsbus scsi for free.
Most of the work is by Michael Kukat and ragge, with a few other
synchronisations thrown in.
@
text
@d1 2
a2 2
/*	$OpenBSD: asc_vsbus.c,v 1.2 2001/02/06 04:27:45 hugh Exp $	*/
/*	$NetBSD: asc_vsbus.c,v 1.20 2000/07/26 21:50:48 matt Exp $	*/
d287 2
a288 1
	    &asc->sc_ncr53c9x, SCB_ISTACK);
@


1.3.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.3 2001/02/11 06:34:37 hugh Exp $	*/
@


1.3.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: asc_vsbus.c,v 1.3.4.1 2001/05/14 21:39:15 niklas Exp $	*/
/*	$NetBSD: asc_vsbus.c,v 1.22 2001/02/04 20:36:32 ragge Exp $	*/
d287 1
a287 2
	    &asc->sc_ncr53c9x, SCB_ISTACK, &asc->sc_intrcnt);
	evcnt_attach(self, "intr", &asc->sc_intrcnt);
@


1.3.4.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d283 1
a283 1
	/* gimme MHz */
d320 1
a320 1
	sc->sc_maxxfer = 64 * 1024;
@


1.2
log
@Pick up work by matt@@netbsd.org to get scsi working on vaxstation 4000/90.
Is it working? I don't know.. Anyone have a machine to spare?
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_vsbus.c,v 1.1 2000/10/11 05:45:30 bjc Exp $	*/
d172 2
a173 2
#if 1
	} else if (vax_boardtype == VAX_BTYP_49) {
a175 1
#endif
a209 1
	struct vsbus_softc *vsc = (struct vsbus_softc *) parent;
d258 1
a322 1
	vsc->sc_mask |= 1 << (va->va_maskno-1);
a504 1

@


1.1
log
@asc* (ncr53c9x on 4000/60 and others) and new dma code;
both from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d172 1
a172 1
#if 0
@

