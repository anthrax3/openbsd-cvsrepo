head	1.43;
access;
symbols
	OPENBSD_5_9:1.42.0.8
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.10
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.6
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.38.0.6
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.4
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.2
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.5.0.22
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.20
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.12
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.43
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.42;
commitid	OSDG2O3Cgeifnf1W;

1.42
date	2013.11.20.00.13.54;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2013.10.14.23.26.22;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2013.07.06.18.31.46;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2011.09.19.21.23.42;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.28.13.20.50;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.22.06.40.25;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.08.14.47.10;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.22.17.10.23;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.05.15.37.04;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.05.00.48.39;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.13.15.23.13;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.04.21.38.10;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.01.12.45.42;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.20.20.13.41;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.09.01.02.28;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.08.05.35.32;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.07.05.22.32;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.05.00.38.19;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.06.20.28.23;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.17.23.49.25;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.03.07.06.17;	author david;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.08.08.50.26;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.16.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	97.10.08.07.09.56;	author niklas;	state Exp;
branches
	1.5.12.1
	1.5.22.1;
next	1.4;

1.4
date	97.09.20.13.54.23;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	97.09.10.12.08.36;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.00.05.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.25.31;	author maja;	state Exp;
branches;
next	;

1.5.12.1
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2002.03.28.11.26.47;	author niklas;	state Exp;
branches;
next	1.5.12.3;

1.5.12.3
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.5.12.4;

1.5.12.4
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.5.12.5;

1.5.12.5
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;

1.5.22.1
date	2002.01.31.22.55.27;	author niklas;	state Exp;
branches;
next	1.5.22.2;

1.5.22.2
date	2002.06.11.03.39.20;	author art;	state Exp;
branches;
next	1.5.22.3;

1.5.22.3
date	2003.05.19.21.46.10;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.43
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: hdc9224.c,v 1.42 2013/11/20 00:13:54 dlg Exp $	*/
/*	$NetBSD: hdc9224.c,v 1.16 2001/07/26 15:05:09 wiz Exp $ */
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by Bertram Barth.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * with much help from (in alphabetical order):
 *	Jeremy
 *	Roger Ivie
 *	Rick Macklem
 *	Mike Young
 *
 * Rewritten by Ragge 25 Jun 2000. New features:
 *	- Uses interrupts instead of polling to signal ready.
 *	- Can cooperate with the SCSI routines WRT. the DMA area.
 *
 * TODO:
 *	- Floppy support missing.
 *	- Bad block forwarding missing.
 *	- Statistics collection.
 */
#undef	HDDEBUG

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h> 
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>
#include <sys/reboot.h>

#include <uvm/uvm_extern.h>

#include <ufs/ufs/dinode.h> /* For BBSIZE */
#include <ufs/ffs/fs.h>

#include <machine/pte.h>
#include <machine/sid.h>
#include <machine/cpu.h>
#include <machine/uvax.h>
#include <machine/ka410.h>
#include <machine/vsbus.h>
#include <machine/scb.h>

#include <arch/vax/mscp/mscp.h> /* For DEC disk encoding */

#include <vax/vsa/hdc9224.h>

/* 
 * on-disk geometry block 
 */
struct hdgeom {
	char mbz[10];		/* 10 bytes of zero */
	long xbn_count;		/* number of XBNs */
	long dbn_count;		/* number of DBNs */
	long lbn_count;		/* number of LBNs (Logical-Block-Numbers) */
	long rbn_count;		/* number of RBNs (Replacement-Block-Numbers) */
	short nspt;		/* number of sectors per track */
	short ntracks;		/* number of tracks */
	short ncylinders;	/* number of cylinders */
	short precomp;		/* first cylinder for write precompensation */
	short reduced;		/* first cylinder for reduced write current */
	short seek_rate;	/* seek rate or zero for buffered seeks */
	short crc_eec;		/* 0 if CRC, 1 if ECC is being used */
	short rct;		/* "replacement control table" (RCT) */
	short rct_ncopies;	/* number of copies of the RCT */
	long	media_id;	/* media identifier */
	short interleave;	/* sector-to-sector interleave */
	short headskew;		/* head-to-head skew */
	short cylskew;		/* cylinder-to-cylinder skew */
	short gap0_size;	/* size of GAP 0 in the MFM format */
	short gap1_size;	/* size of GAP 1 in the MFM format */
	short gap2_size;	/* size of GAP 2 in the MFM format */
	short gap3_size;	/* size of GAP 3 in the MFM format */
	short sync_value;	/* sync value used when formatting */
	char	reserved[32];	/* reserved for use by the RQDX formatter */
	short serial_number;	/* serial number */
#if 0	/* we don't need these 412 useless bytes ... */
	char	fill[412-2];	/* Filler bytes to the end of the block */
	short checksum;	/* checksum over the XBN */
#endif
} __packed;

/*
 * Software status
 */
struct	hdsoftc {
	struct device sc_dev;		/* must be here! (pseudo-OOP:) */
	struct disk sc_disk;		/* disklabel etc. */
	struct hdgeom sc_xbn;		/* on-disk geometry information */
	int sc_drive;			/* physical unit number */
};

struct	hdcsoftc {
	struct device sc_dev;		/* must be here (pseudo-OOP:) */
	struct evcount sc_intrcnt;
	struct vsbus_dma sc_vd;
	vaddr_t sc_regs;		/* register addresses */
	struct bufq sc_bufq;
	struct buf *sc_active;
	struct hdc9224_UDCreg sc_creg;	/* (command) registers to be written */
	struct hdc9224_UDCreg sc_sreg;	/* (status) registers being read */
	caddr_t	sc_dmabase;		/* */
	int	sc_dmasize;
	caddr_t sc_bufaddr;		/* Current in-core address */
	daddr_t sc_diskblk;		/* Current block on disk */
	int sc_bytecnt;			/* How much left to transfer */
	int sc_xfer;			/* Current transfer size */
	int sc_retries;
	volatile u_char sc_status;	/* last status from interrupt */
	char sc_intbit;
};

struct hdc_attach_args {
	int ha_drive;
};

/*
 * prototypes for (almost) all the internal routines
 */
int hdcmatch(struct device *, void *, void *);
void hdcattach(struct device *, struct device *, void *);
int hdcprint(void *, const char *);
int hdmatch(struct device *, void *, void *);
void hdattach(struct device *, struct device *, void *);
void hdcintr(void *);
int hdc_command(struct hdcsoftc *, int);
void hd_readgeom(struct hdcsoftc *, struct hdsoftc *);
int hdgetdisklabel(dev_t, struct hdsoftc *, struct disklabel *, int);
#ifdef HDDEBUG
void hdc_printgeom(struct hdgeom *);
#endif
void hdc_writeregs(struct hdcsoftc *);
void hdcstart(struct hdcsoftc *, struct buf *);
int hdc_hdselect(struct hdcsoftc *, int);
void hdmakelabel(struct disklabel *, struct hdgeom *);
void hdc_writeregs(struct hdcsoftc *);
void hdc_readregs(struct hdcsoftc *);
void hdc_qstart(void *);
 
bdev_decl(hd);
cdev_decl(hd);

const struct	cfattach hdc_ca = {
	sizeof(struct hdcsoftc), hdcmatch, hdcattach
};

struct cfdriver hdc_cd = {
	NULL, "hdc", DV_DULL
};

const struct	cfattach hd_ca = {
	sizeof(struct hdsoftc), hdmatch, hdattach
};

struct cfdriver hd_cd = {
	NULL, "hd", DV_DISK
};

/* At least 0.7 uS between register accesses */
static int hd_dmasize, inq = 0;	/* XXX should be in softc... but only 1 ctrl */
static int u;
#define	WAIT	asm("movl %0,%0;movl %0,%0;movl %0,%0; movl %0,%0" :: "m"(u))

#define	HDC_WREG(x)	*(volatile char *)(sc->sc_regs) = (x)
#define	HDC_RREG	*(volatile char *)(sc->sc_regs)
#define	HDC_WCMD(x)	*(volatile char *)(sc->sc_regs + 4) = (x)
#define	HDC_RSTAT	*(volatile char *)(sc->sc_regs + 4)

/*
 * new-config's hdcmatch() is similar to old-config's hdcprobe(), 
 * thus we probe for the existence of the controller and reset it.
 * NB: we can't initialize the controller yet, since space for hdcsoftc 
 *     is not yet allocated. Thus we do this in hdcattach()...
 */
int
hdcmatch(struct device *parent, void *vcf, void *aux)
{
	static int matched = 0;
	struct vsbus_attach_args *va = aux;
	volatile char *hdc_csr = (char *)va->va_addr;
	int i;

	if (vax_boardtype == VAX_BTYP_49 || vax_boardtype == VAX_BTYP_46 ||
	    vax_boardtype == VAX_BTYP_48 || vax_boardtype == VAX_BTYP_1303)
		return (0);

	/* Can only match once due to DMA setup. This should not be an issue. */
	if (matched != 0)
		return (0);

	hdc_csr[4] = DKC_CMD_RESET; /* reset chip */
	for (i = 0; i < 1000; i++) {
		DELAY(1000);
		if (hdc_csr[4] & DKC_ST_DONE)
			break;
	}
	if (i == 100)
		return 0; /* No response to reset */

	hdc_csr[4] = DKC_CMD_SETREGPTR|UDC_TERM;
	WAIT;
	hdc_csr[0] = UDC_TC_CRCPRE|UDC_TC_INTDONE;
	WAIT;
	hdc_csr[4] = DKC_CMD_DRDESELECT; /* Should be harmless */
	DELAY(1000);
	return (matched = 1);
}

int
hdcprint(void *aux, const char *pnp)
{
	struct hdc_attach_args *ha = aux;

	if (pnp != NULL)
		printf("%s at %s drive %d",
		    ha->ha_drive == 2 ? "ry" : "hd", pnp, ha->ha_drive);

	return (UNCONF);
}

/*
 * hdc_attach() probes for all possible devices
 */
void 
hdcattach(struct device *parent, struct device *self, void *aux)
{
	struct vsbus_attach_args *va = aux;
	struct hdcsoftc *sc = (void *)self;
	struct hdc_attach_args ha;
	int status, i;

	u = 0; /* !!! - GCC */

	printf("\n");

	/*
	 * Get interrupt vector, enable instrumentation.
	 */
	scb_vecalloc(va->va_cvec, hdcintr, sc, SCB_ISTACK, &sc->sc_intrcnt);
	evcount_attach(&sc->sc_intrcnt, self->dv_xname, (void *)va->va_cvec);

	sc->sc_regs = vax_map_physmem(va->va_paddr, 1);
	sc->sc_dmabase = (caddr_t)va->va_dmaaddr;
	sc->sc_dmasize = va->va_dmasize;
	sc->sc_intbit = va->va_maskno;
	hd_dmasize = min(MAXPHYS, sc->sc_dmasize); /* Used in hd_minphys */

	sc->sc_vd.vd_go = hdc_qstart;
	sc->sc_vd.vd_arg = sc;

	/*
	 * Reset controller.
	 */
	HDC_WCMD(DKC_CMD_RESET);
	DELAY(1000);
	status = HDC_RSTAT;
	if (status != (DKC_ST_DONE|DKC_TC_SUCCESS)) {
		printf("%s: RESET failed,  status 0x%x\n",
		    sc->sc_dev.dv_xname, status);
		return;
	}

	/*
	 * now probe for all possible hard drives
	 */
	for (i = 0; i < 4; i++) {
		if (i == 2) /* Floppy, needs special handling */
			continue;
		HDC_WCMD(DKC_CMD_DRSELECT | i);
		DELAY(1000);
		status = HDC_RSTAT;
		ha.ha_drive = i;
		if ((status & DKC_ST_TERMCOD) == DKC_TC_SUCCESS)
			config_found(self, (void *)&ha, hdcprint);
	}
}

/*
 * hdmatch() probes for the existence of a HD-type disk/floppy
 */
int
hdmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct hdc_attach_args *ha = aux;
	struct cfdata *cf = vcf;

	if (cf->cf_loc[0] != -1 &&
	    cf->cf_loc[0] != ha->ha_drive)
		return 0;

	if (ha->ha_drive == 2) /* Always floppy, not supported */
		return 0;

	return 1;
}

#define	HDMAJOR 19

int
hdgetdisklabel(dev_t dev, struct hdsoftc *hd, struct disklabel *lp,
    int spoofonly)
{
	hdmakelabel(lp, &hd->sc_xbn);

	return readdisklabel(dev, hdstrategy, lp, spoofonly);
}

void
hdattach(struct device *parent, struct device *self, void *aux)
{
	struct hdcsoftc *sc = (void*)parent;
	struct hdsoftc *hd = (void*)self;
	struct hdc_attach_args *ha = aux;
	struct disklabel *dl;
	int error;

	hd->sc_drive = ha->ha_drive;
	/*
	 * Initialize and attach the disk structure.
	 */
	hd->sc_disk.dk_name = hd->sc_dev.dv_xname;
	disk_attach(&hd->sc_dev, &hd->sc_disk);

	/*
	 * if it's not a floppy then evaluate the on-disk geometry.
	 * if necessary correct the label...
	 */
	hd_readgeom(sc, hd);
	disk_printtype(hd->sc_drive, hd->sc_xbn.media_id);
	dl = hd->sc_disk.dk_label;
	error = hdgetdisklabel(MAKEDISKDEV(HDMAJOR, hd->sc_dev.dv_unit, RAW_PART),
	    hd, dl, 0);
	printf("%s: %lluMB, %llu sectors\n",
	    hd->sc_dev.dv_xname, DL_GETDSIZE(dl) / (1048576 / DEV_BSIZE),
	    DL_GETDSIZE(dl));
#ifdef HDDEBUG
	hdc_printgeom(&hd->sc_xbn);
#endif
}

void
hdcintr(void *arg)
{
	struct hdcsoftc *sc = arg;
	struct buf *bp;

	sc->sc_status = HDC_RSTAT;
	if (sc->sc_active == NULL)
		return; /* Complain? */

	if ((sc->sc_status & (DKC_ST_INTPEND | DKC_ST_DONE)) !=
	    (DKC_ST_INTPEND | DKC_ST_DONE))
		return; /* Why spurious ints sometimes??? */

	bp = sc->sc_active;
	sc->sc_active = NULL;
	if ((sc->sc_status & DKC_ST_TERMCOD) != DKC_TC_SUCCESS) {
		int i;
		u_char *g = (u_char *)&sc->sc_sreg;

		if (sc->sc_retries++ < 3) { /* Allow 3 retries */
			hdcstart(sc, bp);
			return;
		}
		printf("%s: failed, status 0x%x\n",
		    sc->sc_dev.dv_xname, sc->sc_status);
		hdc_readregs(sc);
		for (i = 0; i < 10; i++)
			printf("%i: %x\n", i, g[i]);
		bp->b_flags |= B_ERROR;
		bp->b_error = ENXIO;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		vsbus_dma_intr();
		return;
	}

	if (bp->b_flags & B_READ) {
		vsbus_copytoproc(bp->b_proc, sc->sc_dmabase, sc->sc_bufaddr,
		    sc->sc_xfer);
	}
	sc->sc_diskblk += (sc->sc_xfer/DEV_BSIZE);
	sc->sc_bytecnt -= sc->sc_xfer;
	sc->sc_bufaddr += sc->sc_xfer;

	if (sc->sc_bytecnt == 0) { /* Finished transfer */
		biodone(bp);
		vsbus_dma_intr();
	} else
		hdcstart(sc, bp);
}

/*
 *
 */
void
hdstrategy(struct buf *bp)
{
	struct hdsoftc *hd;
	struct hdcsoftc *sc;
	int unit, s;

	unit = DISKUNIT(bp->b_dev);
	if (unit > hd_cd.cd_ndevs || (hd = hd_cd.cd_devs[unit]) == NULL) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		goto done;
	}
	sc = (void *)hd->sc_dev.dv_parent;

	/* Validate the request. */
	if (bounds_check_with_label(bp, hd->sc_disk.dk_label) == -1)
		goto done;

	bufq_queue(&sc->sc_bufq, bp);

	s = splbio();
	if (inq == 0) {
		inq = 1;
		vsbus_dma_start(&sc->sc_vd);
	}
	splx(s);
	return;

done:
	s = splbio();
	biodone(bp);
	splx(s);
}

void
hdc_qstart(void *arg)
{
	struct hdcsoftc *sc = arg;

	inq = 0;

	hdcstart(sc, NULL);
	if (bufq_peek(&sc->sc_bufq)) {
		vsbus_dma_start(&sc->sc_vd); /* More to go */
		inq = 1;
	}
}

void
hdcstart(struct hdcsoftc *sc, struct buf *ob)
{
	struct hdc9224_UDCreg *p = &sc->sc_creg;
	struct disklabel *lp;
	struct hdsoftc *hd;
	struct buf *bp;
	int cn, sn, tn, blks;
	volatile char ch;
	daddr_t bn;

	splassert(IPL_BIO);

	if (sc->sc_active != NULL)
		return; /* Already doing something */

	if (ob == NULL) {
		bp = bufq_dequeue(&sc->sc_bufq);
		if (bp == NULL)
			return; /* Nothing to do */

		sc->sc_bufaddr = bp->b_data;
		sc->sc_bytecnt = bp->b_bcount;
		sc->sc_retries = 0;
		bp->b_resid = 0;
	} else
		bp = ob;

	hd = hd_cd.cd_devs[DISKUNIT(bp->b_dev)];
	lp = hd->sc_disk.dk_label;
	hdc_hdselect(sc, hd->sc_drive);
	sc->sc_active = bp;

	if (ob == NULL) {
		sc->sc_diskblk = bp->b_blkno +
		    DL_GETPOFFSET(&lp->d_partitions[DISKPART(bp->b_dev)]);
	}
	bn = sc->sc_diskblk;

        if (bn != 0) {
                cn = bn / lp->d_secpercyl;
                sn = bn % lp->d_secpercyl;
                tn = sn / lp->d_nsectors;
                sn = sn % lp->d_nsectors;
        } else
                cn = sn = tn = 0;

	cn++; /* first cylinder is reserved */

	bzero(p, sizeof(struct hdc9224_UDCreg));

	/*
	 * Tricky thing: the controller itself only increases the sector
	 * number, not the track or cylinder number. Therefore the driver
	 * is not allowed to have transfers that crosses track boundaries.
	 */
	blks = sc->sc_bytecnt / DEV_BSIZE;
	if ((sn + blks) > lp->d_nsectors)
		blks = lp->d_nsectors - sn;

	p->udc_dsect = sn;
	p->udc_dcyl = cn & 0xff;
	p->udc_dhead = ((cn >> 4) & 0x70) | tn;
	p->udc_scnt = blks;

	p->udc_rtcnt = UDC_RC_RTRYCNT;
	p->udc_mode = UDC_MD_HDD;
	p->udc_term = UDC_TC_CRCPRE|UDC_TC_INTDONE|UDC_TC_TDELDAT|UDC_TC_TWRFLT;
	hdc_writeregs(sc);

	/* Count up vars */
	sc->sc_xfer = blks * DEV_BSIZE;

	ch = HDC_RSTAT; /* Avoid pending interrupts */
	WAIT;
	vsbus_clrintr(sc->sc_intbit); /* Clear pending int's */

	if (bp->b_flags & B_READ) {
		HDC_WCMD(DKC_CMD_READ_HDD);
	} else {
		vsbus_copyfromproc(bp->b_proc, sc->sc_bufaddr, sc->sc_dmabase,
		    sc->sc_xfer);
		HDC_WCMD(DKC_CMD_WRITE_HDD);
	}
}

void
hd_readgeom(struct hdcsoftc *sc, struct hdsoftc *hd)
{
	struct hdc9224_UDCreg *p = &sc->sc_creg;

	hdc_hdselect(sc, hd->sc_drive);		/* select drive right now */

	bzero(p, sizeof(struct hdc9224_UDCreg));

	p->udc_scnt  = 1;
	p->udc_rtcnt = UDC_RC_RTRYCNT;
	p->udc_mode  = UDC_MD_HDD;
	p->udc_term  = UDC_TC_CRCPRE|UDC_TC_INTDONE|UDC_TC_TDELDAT|UDC_TC_TWPROT;
	hdc_writeregs(sc);
	sc->sc_status = 0;
	HDC_WCMD(DKC_CMD_READ_HDD|2);
	while ((sc->sc_status & DKC_ST_INTPEND) == 0)
		;
	bcopy(sc->sc_dmabase, &hd->sc_xbn, sizeof(struct hdgeom));
}

#ifdef HDDEBUG
/*
 * display the contents of the on-disk geometry structure
 */
void
hdc_printgeom(p)
	struct hdgeom *p;
{
	printf("**DiskData**	 XBNs: %ld, DBNs: %ld, LBNs: %ld, RBNs: %ld\n",
	    p->xbn_count, p->dbn_count, p->lbn_count, p->rbn_count);
	printf("sec/track: %d, tracks: %d, cyl: %d, precomp/reduced: %d/%d\n",
	    p->nspt, p->ntracks, p->ncylinders, p->precomp, p->reduced);
	printf("seek-rate: %d, crc/eec: %s, RCT: %d, RCT-copies: %d\n",
	    p->seek_rate, p->crc_eec?"EEC":"CRC", p->rct, p->rct_ncopies);
	printf("media-ID: %lx, interleave: %d, headskew: %d, cylskew: %d\n",
	    p->media_id, p->interleave, p->headskew, p->cylskew);
	printf("gap0: %d, gap1: %d, gap2: %d, gap3: %d, sync-value: %d\n",
	    p->gap0_size, p->gap1_size, p->gap2_size, p->gap3_size, 
	    p->sync_value);
}
#endif

/*
 * Return the size of a partition, if known, or -1 if not.
 */
daddr_t
hdsize(dev_t dev)
{
	struct hdsoftc *hd;
	int unit = DISKUNIT(dev);
	daddr_t size;

	if (unit >= hd_cd.cd_ndevs || hd_cd.cd_devs[unit] == 0)
		return -1;
	hd = hd_cd.cd_devs[unit];
	size = DL_GETPSIZE(&hd->sc_disk.dk_label->d_partitions[DISKPART(dev)]) *
	    (hd->sc_disk.dk_label->d_secsize / DEV_BSIZE);

	return (size);
}

/*
 *
 */
int
hdopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct hdsoftc *hd;
	int unit, part;

	unit = DISKUNIT(dev);
	if (unit >= hd_cd.cd_ndevs)
		return ENXIO;
	hd = hd_cd.cd_devs[unit];
	if (hd == 0)
		return ENXIO;

	part = DISKPART(dev);
	if (part >= hd->sc_disk.dk_label->d_npartitions)
		return ENXIO;

	switch (fmt) {
	case S_IFCHR:
		hd->sc_disk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		hd->sc_disk.dk_bopenmask |= (1 << part);
		break;
	}
	hd->sc_disk.dk_openmask =
	    hd->sc_disk.dk_copenmask | hd->sc_disk.dk_bopenmask;

	return 0;
}

/*
 *
 */
int
hdclose(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct hdsoftc *hd;
	int part;

	hd = hd_cd.cd_devs[DISKUNIT(dev)];
	part = DISKPART(dev);

	switch (fmt) {
	case S_IFCHR:
		hd->sc_disk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		hd->sc_disk.dk_bopenmask &= ~(1 << part);
		break;
	}
	hd->sc_disk.dk_openmask =
	    hd->sc_disk.dk_copenmask | hd->sc_disk.dk_bopenmask;

	return (0);
}

/*
 *
 */
int
hdioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct hdsoftc *hd = hd_cd.cd_devs[DISKUNIT(dev)];
	struct disklabel *lp = hd->sc_disk.dk_label;
	int error = 0;

	switch (cmd) {
	case DIOCGPDINFO:
		hdgetdisklabel(dev, hd, (struct disklabel *)addr, 1);
		break;

	case DIOCGDINFO:
		bcopy(lp, addr, sizeof (struct disklabel));
		break;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = lp;
		((struct partinfo *)addr)->part =
		  &lp->d_partitions[DISKPART(dev)];
		break;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return EBADF;
		error = setdisklabel(lp, (struct disklabel *)addr, 0);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(dev, hdstrategy, lp);
		}
		break;

	default:
		error = ENOTTY;
		break;
	}
	return error;
}

/*
 * 
 */
int
hdread(dev_t dev, struct uio *uio, int flag)
{
	return (physio(hdstrategy, dev, B_READ, minphys, uio));
}

/*
 *
 */
int
hdwrite(dev_t dev, struct uio *uio, int flag)
{
	return (physio(hdstrategy, dev, B_WRITE, minphys, uio));
}

/*
 *
 */
int
hddump(dev_t dev, daddr_t daddr, caddr_t addr, size_t size)
{
	return 0;
}

/*
 * we have to wait 0.7 usec between two accesses to any of the
 * dkc-registers, on a VS2000 with 1 MIPS, this is roughly one
 * instruction. Thus the loop-overhead will be enough...
 */
void
hdc_readregs(struct hdcsoftc *sc)
{
	int i;
	char *p;

	HDC_WCMD(DKC_CMD_SETREGPTR);
	WAIT;
	p = (void *)&sc->sc_sreg;	
	for (i = 0; i < 10; i++) {
		*p++ = HDC_RREG;	/* dkc_reg auto-increments */
		WAIT;
	}
}

void
hdc_writeregs(struct hdcsoftc *sc)
{
	int i;
	char *p;

	HDC_WCMD(DKC_CMD_SETREGPTR);
	p = (void *)&sc->sc_creg;	
	for (i = 0; i < 10; i++) {
		HDC_WREG(*p++);	/* dkc_reg auto-increments */
		WAIT;
	}
}

/*
 * hdc_command() issues a command and polls the intreq-register
 * to find when command has completed
 */
int
hdc_command(struct hdcsoftc *sc, int cmd)
{
	hdc_writeregs(sc);		/* write the prepared registers */
	HDC_WCMD(cmd);
	WAIT;
	return (0);
}

int
hdc_hdselect(struct hdcsoftc *sc, int unit)
{
	struct hdc9224_UDCreg *p = &sc->sc_creg;
	int error;

	/*
	 * bring "creg" in some known-to-work state and
	 * select the drive with the DRIVE SELECT command.
	 */
	bzero(p, sizeof(struct hdc9224_UDCreg));

	p->udc_rtcnt = UDC_RC_HDD_READ;
	p->udc_mode  = UDC_MD_HDD;
	p->udc_term  = UDC_TC_HDD;

	error = hdc_command(sc, DKC_CMD_DRSEL_HDD | unit);

	return (error);
}

void
hdmakelabel(struct disklabel *dl, struct hdgeom *g)
{
	int n, p = 0;

	dl->d_bbsize = BBSIZE;
	dl->d_sbsize = SBSIZE;
	dl->d_typename[p++] = MSCP_MID_CHAR(2, g->media_id);
	dl->d_typename[p++] = MSCP_MID_CHAR(1, g->media_id);
	if (MSCP_MID_ECH(0, g->media_id))
		dl->d_typename[p++] = MSCP_MID_CHAR(0, g->media_id);
	n = MSCP_MID_NUM(g->media_id);
	if (n > 99) {
		dl->d_typename[p++] = '1';
		n -= 100;
	}
	if (n > 9) {
		dl->d_typename[p++] = (n / 10) + '0';
		n %= 10;
	}
	dl->d_typename[p++] = n + '0';
	dl->d_typename[p] = 0;
	dl->d_type = DTYPE_MSCP; /* XXX - what to use here??? */
	dl->d_secsize = DEV_BSIZE;

	DL_SETDSIZE(dl, g->lbn_count);
	dl->d_nsectors = g->nspt;
	dl->d_ntracks = g->ntracks;
	dl->d_secpercyl = dl->d_nsectors * dl->d_ntracks;
	dl->d_ncylinders = DL_GETDSIZE(dl) / dl->d_secpercyl;

	dl->d_npartitions = MAXPARTITIONS;
	DL_SETPSIZE(&dl->d_partitions[0], DL_GETDSIZE(dl));
	DL_SETPSIZE(&dl->d_partitions[2], DL_GETDSIZE(dl));
	    
	DL_SETPOFFSET(&dl->d_partitions[0], 0);
	DL_SETPOFFSET(&dl->d_partitions[2], 0);
	dl->d_version = 1;
	dl->d_magic = dl->d_magic2 = DISKMAGIC;
	dl->d_checksum = dkcksum(dl);
}
@


1.42
log
@replace bare use of disksort with bufqs.

go ahead miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.41 2013/10/14 23:26:22 krw Exp $	*/
@


1.41
log
@XXsize() returns daddr_t, so calculate the return value in a daddr_t
variable and not (usually) an int.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.40 2013/07/06 18:31:46 miod Exp $	*/
d137 1
a137 1
	struct buf sc_buf_queue;
d390 1
a390 1
	if (sc->sc_active == 0)
d398 1
a398 1
	sc->sc_active = 0;
d458 2
a460 1
	disksort(&sc->sc_buf_queue, bp);
a477 1
	struct buf *dp;
d482 1
a482 2
	dp = &sc->sc_buf_queue;
	if (dp->b_actf != NULL) {
d494 1
a494 1
	struct buf *dp, *bp;
d501 1
a501 1
	if (sc->sc_active)
d505 2
a506 2
		dp = &sc->sc_buf_queue;
		if ((bp = dp->b_actf) == NULL)
a508 1
		dp->b_actf = bp->b_actf;
@


1.40
log
@Forgot to commit this file during the a.out->ELF transition.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.39 2013/06/11 16:42:13 deraadt Exp $	*/
d627 1
a627 1
	int size;
@


1.39
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.38 2011/09/19 21:23:42 miod Exp $	*/
d201 1
a201 1
#define	WAIT	asm("movl _u,_u;movl _u,_u;movl _u,_u; movl _u,_u")
@


1.38
log
@Print 64 bit values with %ll to get a meaningful message at attach time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.37 2011/07/06 04:49:36 matthew Exp $	*/
d144 1
a144 1
	daddr64_t sc_diskblk;		/* Current block on disk */
d498 1
a498 1
	daddr64_t bn;
d622 1
a622 1
daddr64_t
d763 1
a763 1
hddump(dev_t dev, daddr64_t daddr, caddr_t addr, size_t size)
@


1.37
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.36 2011/06/05 18:40:33 matthew Exp $	*/
d375 1
a375 1
	printf("%s: %luMB, %lu sectors\n",
@


1.36
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.35 2011/06/03 21:14:11 matthew Exp $	*/
a442 1
	struct disklabel *lp;
d449 1
d454 2
a455 5
	lp = hd->sc_disk.dk_label;
	if ((bounds_check_with_label(bp, hd->sc_disk.dk_label)) <= 0)
		goto done;

	if (bp->b_bcount == 0)
@


1.35
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.34 2010/09/28 13:20:50 miod Exp $	*/
a734 5
		break;

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
@


1.34
log
@Make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.33 2010/09/22 06:40:25 krw Exp $	*/
d455 1
a455 1
	if ((bounds_check_with_label(bp, hd->sc_disk.dk_label, 1)) <= 0)
@


1.33
log
@Add DIOCGPDINFO to drivers that were lacking it. Where there
is no easily available physical information outside of the stored
disklabel just make it a synonym for DIOCGDINFO.

Commit on the theory it is unlikely to harm, and fallout can be
addressed in the mass re-compile that will follow j2k10.

Should allow auto-allocation of disks to work with all devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.32 2010/09/22 01:18:57 matthew Exp $	*/
d167 1
a167 1
int hdgetdisklabel(dev_t, hdsoftc *, struct disklabel *, int);
d169 1
a169 1
void hdc_printgeom( struct hdgeom *);
d279 1
a279 1
	evcount_attach(&sc->sc_intrcnt, self->dv_xname, va->va_cvec);
d342 2
a343 1
hdgetdisklabel(dev_t dev, hdsoftc *sc, struct disklabel *lp, int spoofonly)
d347 1
a347 1
	return readdisklabel(DISKLABEL(dev), hdstrategy, lp, spoofonly);
@


1.32
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.31 2010/09/20 06:33:48 matthew Exp $	*/
d167 1
d341 8
d372 2
a373 3
	hdmakelabel(dl, &hd->sc_xbn);
	error = readdisklabel(MAKEDISKDEV(HDMAJOR, hd->sc_dev.dv_unit, RAW_PART),
	    hdstrategy, dl, 0);
d711 4
@


1.31
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.30 2010/09/08 14:47:10 jsing Exp $	*/
d742 1
a742 1
	return (physio(hdstrategy, NULL, dev, B_READ, minphys, uio));
d751 1
a751 1
	return (physio(hdstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.30
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.29 2010/06/26 23:24:44 guenther Exp $	*/
d278 1
a278 2
	evcount_attach(&sc->sc_intrcnt, self->dv_xname, (void *)va->va_cvec,
	    &evcount_intr);
@


1.29
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.28 2010/05/22 17:10:23 deraadt Exp $	*/
d355 1
a355 1
	disk_attach(&hd->sc_disk);
@


1.28
log
@missing dkio.h includes
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.27 2010/04/23 15:25:21 jsing Exp $	*/
a63 1
#include <sys/user.h>
@


1.27
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.25 2009/09/05 00:48:39 krw Exp $	*/
d61 1
@


1.26
log
@fix typos
@
text
@a854 1
	dl->d_rpm = 3600;
a868 1
	dl->d_interleave = 1;
@


1.25
log
@Make DIOCSDINFO code consistant everywhere.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.24 2009/08/13 15:23:13 deraadt Exp $	*/
d701 1
a701 1
	int err = 0;
d718 1
a718 1
		error = setdisklabel(lp, (struct disklabel *)addr, 0) :
d721 1
a721 1
			    error = writedisklabel(dev, hdstrategy, lp));
d727 1
a727 1
			err = EBADF;
d731 1
a731 1
		err = ENOTTY;
d734 1
a734 1
	return err;
@


1.24
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.23 2009/06/04 21:38:10 miod Exp $	*/
d718 5
a722 4
		else
			err = (cmd == DIOCSDINFO ?
			    setdisklabel(lp, (struct disklabel *)addr, 0) :
			    writedisklabel(dev, hdstrategy, lp));
@


1.23
log
@Fix fallback from struct disklabel changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.22 2007/09/01 12:45:42 miod Exp $	*/
d348 1
a348 1
	char *msg;
d365 1
a365 1
	msg = readdisklabel(MAKEDISKDEV(HDMAJOR, hd->sc_dev.dv_unit, RAW_PART),
a369 3
	if (msg) {
		/*printf("%s: %s\n", hd->sc_dev.dv_xname, msg);*/
	}
@


1.22
log
@Do not include <machine/rpb.h> unless necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.21 2007/06/20 20:13:41 miod Exp $	*/
d872 1
a872 1
	dl->d_interleave = dl->d_headswitch = 1;
@


1.21
log
@These drivers were abusing b_cylinder to store device-specific information
in strategy(), and were reusing it in start().
I first considered introducing a b_rawblkno field in struct buf, as has been
done in NetBSD, to stop this abuse.
However, it does not cost more to simply move the device-specific
``was-b_cylinder'' computation to the start() routine. Plus we get type fixes
(daddr64_t) for free, although this does not really matter for these
pedro-sized devices. Thus we do not need to grow struct buf for these
devices which really ought to live in your Attic (and my machineroom, of
course).

hp300 HP-IB tested, vax mfm not, but the logic is the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.20 2007/06/20 18:15:46 deraadt Exp $	*/
a80 1
#include <machine/rpb.h>
@


1.20
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.19 2007/06/09 01:02:28 deraadt Exp $	*/
d145 1
a145 1
	int sc_diskblk;			/* Current block on disk */
a440 1
	daddr64_t bn;
a456 11
	/*
	 * XXX Since we need to know blkno in hdcstart() and do not have a
	 * b_rawblkno field in struct buf (yet), abuse b_cylinder to store
	 * the block number instead of the cylinder number.
	 * This will be suboptimal in disksort(), but not harmful. Of course,
	 * this also truncates the block number at 4G, but there shouldn't be
	 * any MFM disk that large.
	 */
	bn = bp->b_blkno + DL_GETPOFFSET(&lp->d_partitions[DISKPART(bp->b_dev)]);
	bp->b_cylinder = bn;

d495 1
a495 1
	int cn, sn, tn, bn, blks;
d497 1
d504 1
a504 1
	if (ob == 0) {
d508 1
a510 2
		/* XXX see hdstrategy() comments regarding b_cylinder usage */
		sc->sc_diskblk = bp->b_cylinder;
d518 1
d522 4
d527 2
a528 2
	lp = hd->sc_disk.dk_label;
        if (bn) {
@


1.19
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.18 2007/06/08 05:35:32 deraadt Exp $	*/
d367 1
a367 1
	    hdstrategy, dl, NULL, 0);
d452 1
a452 2
	if ((bounds_check_with_label(bp, hd->sc_disk.dk_label,
	    hd->sc_disk.dk_cpulabel, 1)) <= 0)
d731 2
a732 2
			    setdisklabel(lp, (struct disklabel *)addr, 0, 0) :
			    writedisklabel(dev, hdstrategy, lp, 0));
@


1.18
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.17 2007/06/07 05:22:32 deraadt Exp $	*/
d882 1
a882 1
	lp->d_version = 1;
@


1.17
log
@more XXsize() functions not fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.16 2007/06/06 17:15:13 deraadt Exp $	*/
d882 1
@


1.16
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.15 2007/06/05 00:38:19 deraadt Exp $	*/
d629 1
a629 1
int
@


1.15
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.14 2007/02/15 00:53:26 krw Exp $	*/
d441 1
a441 1
	daddr_t bn;
d770 1
a770 1
hddump(dev_t dev, daddr_t daddr, caddr_t addr, size_t size)
@


1.14
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.13 2006/11/06 20:28:23 miod Exp $	*/
d369 2
a370 2
	    hd->sc_dev.dv_xname, dl->d_secperunit / (1048576 / DEV_BSIZE),
	    dl->d_secperunit);
d467 1
a467 1
	bn = bp->b_blkno + lp->d_partitions[DISKPART(bp->b_dev)].p_offset;
d639 1
a639 1
	size = hd->sc_disk.dk_label->d_partitions[DISKPART(dev)].p_size *
d869 1
a869 1
	dl->d_secperunit = g->lbn_count;
d873 1
a873 1
	dl->d_ncylinders = dl->d_secperunit / dl->d_secpercyl;
d876 5
a880 3
	dl->d_partitions[0].p_size = dl->d_partitions[2].p_size =
	    dl->d_secperunit;
	dl->d_partitions[0].p_offset = dl->d_partitions[2].p_offset = 0;
@


1.13
log
@Sync the VS2000 (and some VS3100) MFM controller driver with NetBSD, and
enable it in GENERIC and RAMDISK.
Completely untested due to lack of hardware (both my VS3100 are dual-SCSI),
but it hopefully can't hurt.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d371 3
a373 2
	if (msg)
		printf("%s: %s\n", hd->sc_dev.dv_xname, msg);
@


1.12
log
@== has a higher priority than &, so put braces wherever necessary; from cloder@@
@
text
@d1 2
a2 2
/*	$OpenBSD: hdc9224.c,v 1.11 2003/11/03 07:06:17 david Exp $ */
/*	$NetBSD: hdc9224.c,v 1.6 1997/03/15 16:32:22 ragge Exp $ */
d42 9
d52 1
a52 14

/* #define DEBUG	/* */
/* #define TRACE	/* */
static int haveLock = 0;
static int keepLock = 0;

#define F_READ	11
#define F_WRITE 12

#define trace(x)
#define debug(x)

#include "hdc.h"
#if NHDC > 0
a64 1
#include <sys/dkstat.h> 
d70 5
d82 3
a87 17

/*
 * some definitions 
 */
#define CTLRNAME  "hdc"
#define UNITNAME  "hd"
#define HDC_PRI	  LOG_INFO

/* Bits in minor device */ 
#define HDCUNIT(dev)	DISKUNIT(dev)
#define HDCPART(dev)	DISKPART(dev)
#define HDCCTLR(dev)	0
#define HDCLABELDEV(dev)	(MAKEDISKDEV(major(dev),HDCUNIT(dev),RAW_PART))

#define MAX_WAIT	(1000*1000)	/* # of loop-instructions in seconds */


a90 1
#define _aP	__attribute__ ((packed))	/* force byte-alignment */
d92 25
a116 25
  char mbz[10];		/* 10 bytes of zero */
  long xbn_count _aP;	/* number of XBNs */
  long dbn_count _aP;	/* number of DBNs */
  long lbn_count _aP;	/* number of LBNs (Logical-Block-Numbers) */
  long rbn_count _aP;	/* number of RBNs (Replacement-Block-Numbers) */
  short nspt;		/* number of sectors per track */
  short ntracks;	/* number of tracks */
  short ncylinders;	/* number of cylinders */
  short precomp;	/* first cylinder for write precompensation */
  short reduced;	/* first cylinder for reduced write current */
  short seek_rate;	/* seek rate or zero for buffered seeks */
  short crc_eec;	/* 0 if CRC is being used or 1 if ECC is being used */
  short rct;		/* "replacement control table" (RCT) */
  short rct_ncopies;	/* number of copies of the RCT */
  long	media_id _aP;	/* media identifier */
  short interleave;	/* sector-to-sector interleave */
  short headskew;	/* head-to-head skew */
  short cylskew;	/* cylinder-to-cylinder skew */
  short gap0_size;	/* size of GAP 0 in the MFM format */
  short gap1_size;	/* size of GAP 1 in the MFM format */
  short gap2_size;	/* size of GAP 2 in the MFM format */
  short gap3_size;	/* size of GAP 3 in the MFM format */
  short sync_value;	/* sync value used to start a track when formatting */
  char	reserved[32];	/* reserved for use by the RQDX1/2/3 formatter */
  short serial_number;	/* serial number */
d118 2
a119 2
  char	fill[412-2];	/* Filler bytes to the end of the block */
  short checksum;	/* checksum over the XBN */
d121 1
a121 1
};
d127 4
a130 17
	struct device	sc_dev;		/* must be here! (pseudo-OOP:) */
	struct disk	sc_dk;		/* disklabel etc. */
	struct hdgeom	sc_xbn;		/* on-disk geometry information */
	struct hdparams {
		u_short cylinders;	/* number of cylinders */
		u_char	heads;		/* number of heads (tracks) */
		u_char	sectors;	/* number of sectors/track */
		u_long	diskblks;	/* number of sectors/disk */
		u_long	disklbns;	/* number of available sectors */
		u_long	blksize;	/* number of bytes/sector */
		u_long	diskbytes;	/* number of bytes/disk */
		char	diskname[8];
	} sc_param;
	int	sc_drive;		/* physical unit number */
	int	sc_flags;
	int	sc_state;
	int	sc_mode;
d135 5
a139 1
	struct hdc9224_DKCreg *sc_dkc;	/* I/O address of the controller */
d142 13
a154 10
	struct confargs *sc_cfargs;	/* remember args being probed with */
	char	*sc_dmabase;		/* */
	long	sc_dmasize;		/* */
	long	sc_ioaddr;		/* unmapped I/O address */
	long	sc_ivec;		/* interrupt vector address */
	short	sc_ibit;		/* bit-value in interrupt register */
	short	sc_status;		/* copy of status register */
	short	sc_state;
	short	sc_flags;
	short	sc_errors;
d158 1
a158 1
 * Device definition for (new) autoconfiguration.
d160 21
a180 3
int	hdcmatch(struct device *parent, void *cfdata, void *aux);
void	hdcattach(struct device *parent, struct device *self, void *aux);
int	hdcprint(void *aux, const char *name);
d182 1
a182 4
struct	cfdriver hdc_cd = {
	NULL, "hdc", DV_DULL
};
struct	cfattach hdc_ca = {
d186 3
a188 4
int	hdmatch(struct device *parent, void *cfdata, void *aux);
void	hdattach(struct device *parent, struct device *self, void *aux);
int	hdprint(void *aux, const char *name);
void	hdstrategy(struct buf *bp);
d190 1
a190 4
struct	cfdriver hd_cd = {
	NULL, "hd", DV_DISK
};
struct	cfattach hd_ca = {
d194 3
a196 8
struct dkdriver hddkdriver = { hdstrategy };

/*
 * prototypes for (almost) all the internal routines
 */
int hdc_reset(struct hdcsoftc *sc);
int hdc_select(struct hdcsoftc *sc, int drive);
int hdc_command(struct hdcsoftc *sc, int cmd);
d198 9
a206 4
int hdc_getdata(struct hdcsoftc *hdc, struct hdsoftc *hd, int drive);
int hdc_getlabel(struct hdcsoftc *hdc, struct hdsoftc *hd, int drive);

void hdgetlabel(struct hdsoftc *sc);
d215 1
a215 3
hdcmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d217 4
a220 2
	struct cfdata *cf = match;
	struct confargs *ca = aux;
d222 3
a224 1
	trace(("hdcmatch(0x%x, %d, %s)\n", parent, cf->cf_unit, ca->ca_name));
d226 2
a227 3
	if (strcmp(ca->ca_name, "hdc") &&
	    strcmp(ca->ca_name, "hdc9224") &&
	    strcmp(ca->ca_name, "HDC9224"))
d230 5
a234 7
	/*
	 * only(?) VS2000/KA410 has exactly one HDC9224 controller
	 */
	if (vax_boardtype != VAX_BTYP_410) {
		printf("unexpected boardtype 0x%x in hdcmatch()\n", 
		    vax_boardtype);
		return (0);
d236 2
a237 2
	if (cf->cf_unit != 0)
		return (0);
d239 7
a245 1
	return (1);
a247 4
struct hdc_attach_args {
	int ha_drive;
};

d249 1
a249 3
hdprint(aux, name)
	void *aux;
	const char *name;
d253 3
a255 1
	trace(("hdprint(%d, %s)\n", ha->ha_drive, name));
d257 1
a257 3
	if (!name)
		printf(" drive %d", ha->ha_drive);
	return (QUIET);
d264 1
a264 3
hdcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d266 1
a267 1
	struct confargs *ca = aux;
d269 1
d271 1
a271 1
	trace(("hdcattach(0x%x, 0x%x, %s)\n", parent, self, ca->ca_name));
d274 1
d276 1
a276 1
	 * first reset/initialize the controller
d278 9
a286 1
	sc->sc_cfargs = ca;
d288 2
a289 18
	sc->sc_ioaddr = ca->ca_ioaddr;
	sc->sc_dkc = (void *)uvax_phys2virt(sc->sc_ioaddr);
	sc->sc_ibit = ca->ca_intbit;
	sc->sc_ivec = ca->ca_intvec;
	sc->sc_status = 0;
	sc->sc_state = 0;
	sc->sc_flags = 0;
	sc->sc_errors = 0;

	sc->sc_dkc     = (void *)uvax_phys2virt(KA410_DKC_BASE);
	sc->sc_dmabase = (void *)uvax_phys2virt(KA410_DMA_BASE);
	sc->sc_dmasize = KA410_DMA_SIZE;
					      
	if (hdc_reset(sc) != 0) {
		delay(500*1000);	/* wait .5 seconds */
		if (hdc_reset(sc) != 0)
			printf("problems with hdc_reset()...\n");
	}
d292 1
a292 1
	 * now probe for all possible disks
d294 8
a301 2
	for (ha.ha_drive=0; ha.ha_drive<3; ha.ha_drive++)
		(void)config_found(self, (void *)&ha, hdprint);
a302 1
#ifdef notyet
d304 1
a304 1
	 * now that probing is done, we can register and enable interrupts
d306 10
a315 3
	vsbus_intr_register(XXX);
	vsbus_intr_enable(XXX);
#endif
d319 1
a319 1
 * hdmatch() probes for the existence of a RD-type disk/floppy
d322 1
a322 1
hdmatch(parent, match, aux)
d324 2
a325 1
	void *match, *aux;
a326 2
	struct hdcsoftc *hdc = (void *)parent;
	struct cfdata *cf = match;
d328 1
a328 2
	int drive = ha->ha_drive;
	int res;
d330 3
a332 1
	trace(("hdmatch(%d, %d)\n", cf->cf_unit, drive));
d334 2
a335 2
	if (cf->cf_unit != ha->ha_drive)
		return (0);
d337 2
a338 15
	switch (drive) {
	case 0:
	case 1:
	case 2:
		res = hdc_select(hdc, drive);
		break;
	default:
		printf("hdmatch: invalid unit-number %d\n", drive);
		return (0);
	}

	debug (("cstat: %x dstat: %x\n", hdc->sc_sreg.udc_cstat,
		hdc->sc_sreg.udc_dstat));
	if (drive == 1) 
	  return (0);	/* XXX */
d340 1
a340 2
	return (1);
}
d343 1
a343 3
hdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d345 2
a346 2
	struct hdcsoftc *hdc = (void *)parent;
	struct hdsoftc *hd = (void *)self;
d348 2
a349 3
	struct hdparams *hp = &hd->sc_param;

	trace(("hdattach(%d)\n", ha->ha_drive));
d355 3
a357 3
	hd->sc_dk.dk_driver = &hddkdriver;
	hd->sc_dk.dk_name = hd->sc_dev.dv_xname;
	disk_attach(&hd->sc_dk);
d362 66
a427 15
	printf("\n%s: ", hd->sc_dev.dv_xname);
	if (hd->sc_drive == 2) {
		printf("floppy (RX33)\n");
	}
	else {
		hdc_getdata(hdc, hd, hd->sc_drive);
		printf("%s, %d MB, %d LBN, %d cyl, %d head, %d sect/track\n",
		    hp->diskname, hp->diskblks / 2048, hp->disklbns, 
		    hp->cylinders, hp->heads, hp->sectors);
	}
	/*
	 * Know where we booted from.
	 */
	if ((B_TYPE(bootdev) == BDEV_RD) && (hd->sc_drive == B_UNIT(bootdev)))
		booted_from = self;
d431 1
a431 2
 * Read/write routine for a buffer.  For now we poll the controller, 
 * thus this routine waits for the transfer to complete.
d434 1
a434 2
hdstrategy(bp)
	struct buf *bp;
d436 13
a448 4
	struct hdsoftc *hd = hd_cd.cd_devs[HDCUNIT(bp->b_dev)];
	struct hdcsoftc *hdc = (void *)hd->sc_dev.dv_parent;
	struct partition *p;
	int blkno, i, s;
d450 4
a453 1
	trace (("hdstrategy(#%d/%d)\n", bp->b_blkno, bp->b_bcount));
a454 5
	/* XXX		should make some checks... */

	/*
	 * If it's a null transfer, return immediatly
	 */
d457 1
a457 1
	
d459 6
a464 1
	 * what follows now should not be here but in hdstart...
d466 12
a477 14
	/*------------------------------*/
	blkno = bp->b_blkno / (hd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
	p = &hd->sc_dk.dk_label->d_partitions[HDCPART(bp->b_dev)];
	blkno += p->p_offset;

	/* nblks = howmany(bp->b_bcount, sd->sc_dk.dk_label->d_secsize); */

	if (hdc_strategy(hdc, hd, HDCUNIT(bp->b_dev), 
			 ((bp->b_flags & B_READ) ? F_READ : F_WRITE),
			 blkno, bp->b_bcount, bp->b_data) == 0)
		goto done;
	/*------------------------------*/
bad:
	bp->b_flags |= B_ERROR;
a478 4
	/*
	 * Correctly set the buf to indicate a completed xfer
	 */
	bp->b_resid = 0;	/* ??? bertram */
d484 2
a485 9
int
hdc_strategy(hdc, hd, unit, func, dblk, size, buf)
	struct hdcsoftc *hdc;
	struct hdsoftc *hd;
	int unit;
	int func;
	int dblk;
	int size;
	char *buf;
d487 2
a488 5
	struct hdc9224_UDCreg *p = &hdc->sc_creg;
	struct disklabel *lp = hd->sc_dk.dk_label;
	int sect, head, cyl;
	int scount;
	int cmd, res = 0;
d490 1
a490 2
	trace (("hdc_strategy(%d, %d, %d, %d, 0x%x)\n",
		unit, func, dblk, size, buf));
d492 7
a498 1
	hdc_select(hdc, unit);		/* select drive right now */
d500 81
a580 1
	if (unit != 2 && dblk == -1) {	/* read the on-disk geometry */
d582 4
a585 3
	  p->udc_dma7  = 0;
	  p->udc_dma15 = 0;
	  p->udc_dma23 = 0;
d587 1
a587 3
	  p->udc_dsect = 0;
	  p->udc_dhead = 0;
	  p->udc_dcyl  = 0;
d589 1
a589 4
	  p->udc_scnt  = size/512; 
	  p->udc_rtcnt = 0xF0;
	  p->udc_mode  = 0xC0;
	  p->udc_term  = 0xB4;
d591 10
a600 98
	  vsbus_lockDMA(hdc->sc_cfargs);		/* bertram XXX */
	  haveLock = 1;
	  keepLock = 1;

#ifdef PARANOID
	  bzero (hdc->sc_dmabase, size);	/* clear disk buffer */
#endif
	  cmd = 0x5C | 0x03;			/* bypass bad sectors */
	  cmd = 0x5C | 0x01;			/* terminate if bad sector */

	  res = hdc_command (hdc, cmd);
	  /* hold the locking ! */
	  bcopy (hdc->sc_dmabase, buf, size);	/* copy to buf */
	  /* now release the locking */

	  vsbus_unlockDMA(hdc->sc_cfargs);
	  haveLock = 0;
	  keepLock = 0;

	  return (res);
	}
	
	scount = size / 512;
	while (scount) {
	  /*
	   * prepare drive/operation parameter
	   */
	  cyl  = dblk / lp->d_secpercyl;
	  sect = dblk % lp->d_secpercyl;
	  head = sect / lp->d_nsectors;
	  sect = sect % lp->d_nsectors;
	  if (unit == 2) 
		sect++;
	  else
		cyl++;		/* first cylinder is reserved */

	  size = 512 * min(scount, lp->d_nsectors - sect);

	  debug (("hdc_strategy: block #%d ==> s/t/c=%d/%d/%d (%d/%d)\n",
		  dblk, sect, head, cyl, scount, size));

	  /*
	   * now initialize the register values ...
	   */
	  p->udc_dma7  = 0;
	  p->udc_dma15 = 0;
	  p->udc_dma23 = 0;

	  p->udc_dsect = sect;
	  head |= (cyl >> 4) & 0x70;
	  p->udc_dhead = head;
	  p->udc_dcyl  = cyl;

	  p->udc_scnt  = size/512; 

	  if (unit == 2) {	/* floppy */
	    p->udc_rtcnt = 0xF2;
	    p->udc_mode	 = 0x81;	/* RX33 with RX50 media */
	    p->udc_mode	 = 0x82;	/* RX33 with RX33 media */
	    p->udc_term	 = 0xB4;	
	  } else {		 /* disk */
	    p->udc_rtcnt = 0xF0;
	    p->udc_mode	 = 0xC0;
	    p->udc_term	 = 0xB4;
	  }
	  
	  vsbus_lockDMA(hdc->sc_cfargs);
	  haveLock = 1;
	  keepLock = 1;

	  if (func == F_WRITE) {
	    bcopy (buf, hdc->sc_dmabase, size); /* copy from buf */
	    cmd = 0xA0 | (unit==2 ? 1 : 0);
	    res = hdc_command (hdc, cmd);
	  }
	  else {
#ifdef PARANOID
	    bzero (hdc->sc_dmabase, size);		/* clear disk buffer */
#endif
	    cmd = 0x5C | 0x03;	/* bypass bad sectors */
	    cmd = 0x5C | 0x01;	/* terminate if bad sector */
	    res = hdc_command (hdc, cmd);
	    bcopy (hdc->sc_dmabase, buf, size); /* copy to buf */
	  }

	  vsbus_unlockDMA(hdc->sc_cfargs);
	  haveLock = 0;
	  keepLock = 0;

	  scount -= size/512;
	  dblk += size/512;
	  buf += size;
	}

	if (unit != 2)		/* deselect drive, if not floppy */
	  hdc_command (hdc, DKC_CMD_DRDESELECT);

	return 0;
d603 1
a603 3
char hdc_iobuf[17*512];		/* we won't need more */

#ifdef DEBUG
d607 1
a607 1
int
d611 1
a611 4
	char dname[8];
	hdc_mid2str(p->media_id, dname, sizeof dname);

	printf("**DiskData**	 XBNs: %d, DBNs: %d, LBNs: %d, RBNs: %d\n",
d617 2
a618 2
	printf("media-ID: %s, interleave: %d, headskew: %d, cylskew: %d\n",
	    dname, p->interleave, p->headskew, p->cylskew);
d626 1
a626 1
 * Convert media_id to string/name (encoding is documented in mscp.h)
d629 1
a629 24
hdc_mid2str(media_id, name)
	long media_id;
	char *name;
	size_t len;
{
	struct {			/* For RD32 this struct holds: */
		u_long mt:7;		/* number in name: 0x20 == 32 */
		u_long a2:5;		/* ' ' encoded as 0x0 */
		u_long a1:5;		/* 'D' encoded with base '@@' */
		u_long a0:5;		/* 'R' encoded with base '@@' */
		u_long d1:5;		/* 'U' encoded with base '@@' */
		u_long d0:5;		/* 'D' encoded with base '@@' */
	} *p = (void *)&media_id;

#define MIDCHR(x)	(x ? x + '@@' : ' ')

	snprintf(name, len, "%c%c%d", MIDCHR(p->a0), MIDCHR(p->a1), p->mt);
}

int
hdc_getdata(hdc, hd, unit)
	struct hdcsoftc *hdc;
	struct hdsoftc *hd;
	int unit;
a630 45
	struct disklabel *lp = hd->sc_dk.dk_label;
	struct hdparams *hp = &hd->sc_param;
	int res;

	trace (("hdc_getdata(%d)\n", unit));

	bzero(hd->sc_dk.dk_label, sizeof(struct disklabel));
	bzero(hd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));

	if (unit == 2) {
		lp->d_secsize = DEV_BSIZE;
		lp->d_ntracks = 2;
		lp->d_nsectors = 15;
		lp->d_ncylinders = 80;
		lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;

		return (0);
	}

	res = hdc_strategy(hdc, hd, unit, F_READ, -1, 4096, hdc_iobuf);
	bcopy (hdc_iobuf, &hd->sc_xbn, sizeof(struct hdgeom));
#ifdef DEBUG
	hdc_printgeom(&hd->sc_xbn);
#endif
	lp->d_secsize = DEV_BSIZE;
	lp->d_ntracks = hd->sc_xbn.ntracks;
	lp->d_nsectors = hd->sc_xbn.nspt;
	lp->d_ncylinders = hd->sc_xbn.ncylinders;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;

	hp->cylinders = hd->sc_xbn.ncylinders;
	hp->heads = hd->sc_xbn.ntracks;
	hp->sectors = hd->sc_xbn.nspt;
	hp->diskblks = hp->cylinders * hp->heads * hp->sectors;
	hp->disklbns = hd->sc_xbn.lbn_count;
	hp->blksize = DEV_BSIZE;
	hp->diskbytes = hp->disklbns * hp->blksize;
	hdc_mid2str(hd->sc_xbn.media_id, hp->diskname, sizeof hp->diskname);

	return (0);
}

int
hdc_getlabel(hdc, hd, unit)
	struct hdcsoftc *hdc;
d632 1
a632 38
	int unit;
{
	struct disklabel *lp = hd->sc_dk.dk_label;
	struct disklabel *xp = (void *)(hdc_iobuf + 64);
	int res;

	trace(("hdc_getlabel(%d)\n", unit));

#ifdef DEBUG
#define LBL_CHECK(x)					\
	if (xp->x != lp->x) {				\
		printf("%d-->%d\n", xp->x, lp->x);	\
		xp->x = lp->x;				\
	}
#else
#define LBL_CHECK(x)	xp->x = lp->x
#endif

	res = hdc_strategy(hdc, hd, unit, F_READ, 0, DEV_BSIZE, hdc_iobuf);
	LBL_CHECK(d_secsize);
	LBL_CHECK(d_ntracks);
	LBL_CHECK(d_nsectors);
	LBL_CHECK(d_ncylinders);
	LBL_CHECK(d_secpercyl);
	bcopy(xp, lp, sizeof(struct disklabel));

	return (0);
}

/*
 * Return the size of a partition, if known, or -1 if not.
 */
hdcsize(dev)
	dev_t dev;
{
	int unit = HDCUNIT(dev);
	int part = HDCPART(dev);
	struct hdsoftc *hd = hd_cd.cd_devs[unit];
d635 5
a639 1
	trace (("hdcsize(%x == %d/%d)\n", dev, unit, part));
a640 11
	if (hdcopen(dev, 0, S_IFBLK) != 0)
		return (-1);
#if 0
	if (hd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;
	else
#endif
		size = hd->sc_dk.dk_label->d_partitions[part].p_size;
	if (hdcclose(dev, 0, S_IFBLK) != 0)
		return (-1);
	debug (("hdcsize: size=%d\n", size));
d648 2
a649 8
hdcopen (dev, flag, fmt)
	dev_t dev;
	int flag;
	int fmt;
{
	int unit = HDCUNIT(dev);
	int part = HDCPART(dev);
	struct hdcsoftc *hdc;
d651 1
a651 1
	int res, error;
d653 6
a658 1
	trace (("hdcopen(0x%x = %d/%d)\n", dev, unit, part));
d660 11
a670 8
	if (unit >= hd_cd.cd_ndevs) {
		printf("hdcopen: invalid unit %d\n", unit);
		return (ENXIO);
	}
	hd = hd_cd.cd_devs[unit];
	if (!hd) {
		printf("hdcopen: null-pointer in hdsoftc.\n");
		return (ENXIO);
d672 2
a673 3
	hdc = (void *)hd->sc_dev.dv_parent;
	
	/* XXX here's much more to do! XXX */
d675 1
a675 4
	hdc_getdata (hdc, hd, unit);
	hdc_getlabel (hdc, hd, unit);

	return (0);
d682 1
a682 3
hdcclose (dev, flag)
	dev_t dev;
	int flag;
d684 17
a700 1
	trace (("hdcclose()\n"));
a706 12
void
hdcstrategy(bp)
	register struct buf *bp;
{
	trace (("hdcstrategy()\n"));
	hdstrategy(bp);
	debug (("hdcstrategy done.\n"));
}

/*
 *
 */
d708 1
a708 6
hdcioctl(dev, cmd, data, flag, p)
	dev_t dev;
	int cmd;
	caddr_t data;	/* aka: addr */
	int flag;
	struct proc *p;
d710 3
a712 10
	struct hdsoftc *hd = hd_cd.cd_devs[HDCUNIT(dev)];
	struct hdcsoftc *hdc = (void *)hd->sc_dev.dv_parent;
	int error;

	trace (("hdcioctl(%x, %x)\n", dev, cmd));

	/*
	 * If the device is not valid.. abandon ship
	 */
	/* XXX */
d716 2
a717 2
		*(struct disklabel *)data = *(hd->sc_dk.dk_label);
		return (0);
d720 4
a723 4
		((struct partinfo *)data)->disklab = hd->sc_dk.dk_label;
		((struct partinfo *)data)->part =
		  &hd->sc_dk.dk_label->d_partitions[HDCPART(dev)];
		return (0);
a726 1
/* XXX
d729 5
a733 18

		if ((error = sdlock(sd)) != 0)
			return error;
		sd->flags |= SDF_LABELLING;
*/
		error = setdisklabel(hd->sc_dk.dk_label,
		     (struct disklabel *)data, 0, hd->sc_dk.dk_cpulabel);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(HDCLABELDEV(dev),
					hdstrategy, hd->sc_dk.dk_label,
					hd->sc_dk.dk_cpulabel);
		}
/* XXX
		sd->flags &= ~SDF_LABELLING;
		sdunlock(sd);
*/
		return (error);
d737 3
a739 9
			return (EBADF);
/* XXX
		if (*(int *)data)
			sd->flags |= SDF_WLABEL;
		else
			sd->flags &= ~SDF_WLABEL;
*/
		return (0);
	      
d741 2
a742 4
		if (HDCPART(dev) != RAW_PART)
			return (ENOTTY);
		printf("IOCTL %x not implemented.\n", cmd);
		return (-1);
d744 1
a744 9
}

/*
 *
 */
int 
hdcintr() 
{
	trace (("hdcintr()\n"));
d751 1
a751 3
hdcread (dev, uio)
	dev_t dev;
	struct uio *uio;
d753 1
a753 2
	trace (("hdcread()\n"));
	return (physio (hdcstrategy, NULL, dev, B_READ, minphys, uio));
d760 1
a760 3
hdcwrite (dev, uio)
	dev_t dev;
	struct uio *uio;
d762 1
a762 2
	trace (("hdcwrite()\n"));
	return (physio (hdcstrategy, NULL, dev, B_WRITE, minphys, uio));
d769 1
a769 2
hdcdump(dev)
	dev_t dev;
d771 1
a771 1
	trace (("hdcdump (%x)\n", dev));
d780 1
a780 2
hdc_readregs(sc)
	struct hdcsoftc *sc;
d785 2
a786 3
	trace(("hdc_readregs()\n"));

	sc->sc_dkc->dkc_cmd = 0x40;	/* set internal counter to zero */
d788 4
a791 2
	for (i=0; i<10; i++)
		*p++ = sc->sc_dkc->dkc_reg;	/* dkc_reg auto-increments */
d795 1
a795 2
hdc_writeregs(sc)
	struct hdcsoftc *sc;
d800 1
a800 3
	trace(("hdc_writeregs()\n"));

	sc->sc_dkc->dkc_cmd = 0x40;	/* set internal counter to zero */
d802 4
a805 2
	for (i=0; i<10; i++)
		sc->sc_dkc->dkc_reg = *p++;	/* dkc_reg auto-increments */
d813 1
a813 3
hdc_command(sc, cmd)
	struct hdcsoftc *sc;
	int cmd;
a814 13
	volatile u_char *intreq = (void *)uvax_phys2virt(KA410_INTREQ);
	volatile u_char *intclr = (void *)uvax_phys2virt(KA410_INTCLR);
	volatile u_char *intmsk = (void *)uvax_phys2virt(KA410_INTMSK);
	int i, c;

	trace (("hdc_command(%x)\n", cmd));
	debug (("intr-state: %x %x %x\n", *intreq, *intclr, *intmsk));

	if (!haveLock) {
	  vsbus_lockDMA(sc->sc_cfargs);
	  haveLock = 1;
	}

d816 2
a817 44
	*intclr = INTR_DC;		/* clear any old interrupt */
	sc->sc_dkc->dkc_cmd = cmd;	/* issue the command */
	for (i=0; i<MAX_WAIT; i++) {
		if ((c = *intreq) & INTR_DC)
			break;
	}
	if ((c & INTR_DC) == 0) {
		printf("hdc_command: timeout in command 0x%x\n", cmd);
	}
	hdc_readregs(sc);		/* read the status registers */
	sc->sc_status = sc->sc_dkc->dkc_stat;

	if (!keepLock) {
	  vsbus_unlockDMA(sc->sc_cfargs);
	  haveLock = 0;
	}

	if (sc->sc_status != DKC_ST_DONE|DKC_TC_SUCCESS) {
		printf("command 0x%x completed with status 0x%x\n",
			cmd, sc->sc_status);
		return (-1);
	}
	return (0);
}

/*
 * writing zero into the command-register will reset the controller.
 * This will not interrupt data-transfer commands!
 * Also no interrupt is generated, thus we don't use hdc_command()
 */
int 
hdc_reset(sc)
	struct hdcsoftc *sc;
{
	trace (("hdc_reset()\n"));
	
	sc->sc_dkc->dkc_cmd = DKC_CMD_RESET;	/* issue RESET command */
	hdc_readregs(sc);			/* read the status registers */
	sc->sc_status = sc->sc_dkc->dkc_stat;
	if (sc->sc_status != DKC_ST_DONE|DKC_TC_SUCCESS) {
		printf("RESET command completed with status 0x%x\n",
		    sc->sc_status);
		return (-1);
	}
d822 1
a822 3
hdc_rxselect(sc, unit)
	struct hdcsoftc *sc;
	int unit;
d824 1
a824 73
	register struct hdc9224_UDCreg *p = &sc->sc_creg;
	register struct hdc9224_UDCreg *q = &sc->sc_sreg;
	int error;

	/*
	 * bring command-regs in some known-to-work state and
	 * select the drive with the DRIVE SELECT command.
	 */
	p->udc_dma7  = 0;
	p->udc_dma15 = 0;
	p->udc_dma23 = 0;
	p->udc_dsect = 1;	/* sectors are numbered 1..15 !!! */
	p->udc_dhead = 0;
	p->udc_dcyl  = 0;
	p->udc_scnt  = 0;

	p->udc_rtcnt = UDC_RC_RX33READ;
	p->udc_mode  = UDC_MD_RX33;
	p->udc_term  = UDC_TC_FDD;

	/*
	 * this is ...
	 */
	error = hdc_command (sc, DKC_CMD_DRSEL_RX33 | unit);

	if ((error != 0) || ((q->udc_dstat & UDC_DS_READY) == 0)) {
		printf("\nfloppy-drive not ready (new floppy inserted?)\n\n");
		p->udc_rtcnt &= ~UDC_RC_INVRDY;	/* clear INVRDY-flag */
		error = hdc_command(sc, DKC_CMD_DRSEL_RX33 | unit);
		if ((error != 0) || ((q->udc_dstat & UDC_DS_READY) == 0)) {
			printf("diskette not ready(1): %x/%x\n", error,
			    q->udc_dstat);
			printf("floppy-drive offline?\n");
			return (-1);
		}

		if (q->udc_dstat & UDC_DS_TRK00)		/* track-0: */
			error = hdc_command(sc, DKC_CMD_STEPIN_FDD);
								/* step in */
		else
	  		error = hdc_command(sc, DKC_CMD_STEPOUT_FDD);
								/* step out */

		if ((error != 0) || ((q->udc_dstat & UDC_DS_READY) == 1)) {
			printf("diskette not ready(2): %x/%x\n", error,
			    q->udc_dstat);
			printf("No floppy inserted or drive offline\n");
			/* return (-1); */
		}

		p->udc_rtcnt |= UDC_RC_INVRDY;
		error = hdc_command(sc, DKC_CMD_DRSEL_RX33 | unit);
		if ((error != 0) || ((q->udc_dstat & UDC_DS_READY) == 0)) {
			printf("diskette not ready(3): %x/%x\n", error,
			    q->udc_dstat);
			printf("no floppy inserted or floppy-door open\n");
			return(-1);
		}
		printf("floppy-drive reselected.\n");
	}
	if (error)
		error = hdc_command (sc, DKC_CMD_DRSEL_RX33 | unit);

	return (error);
}

int
hdc_hdselect(sc, unit)
	struct hdcsoftc *sc;
	int unit;
{
	register struct hdc9224_UDCreg *p = &sc->sc_creg;
	register struct hdc9224_UDCreg *q = &sc->sc_sreg;
d831 1
a831 7
	p->udc_dma7  = 0;
	p->udc_dma15 = 0;
	p->udc_dma23 = 0;
	p->udc_dsect = 0;		/* sectors are numbered 0..16 */
	p->udc_dhead = 0;
	p->udc_dcyl  = 0;
	p->udc_scnt  = 0;
d837 2
a838 4
	error = hdc_command (sc, DKC_CMD_DRSEL_HDD | unit);
	if (error)
		error = hdc_command (sc, DKC_CMD_DRSEL_HDD | unit);
	
d842 2
a843 8
/*
 * bring command-regs into some known-to-work state and select
 * the drive with the DRIVE SELECT command.
 */
int 
hdc_select(sc, unit)
	struct hdcsoftc *sc;
	int unit;
d845 1
a845 17
	int error;

	trace (("hdc_select(%x,%d)\n", sc, unit));

	switch (unit) {
	case 0:
	case 1:
		error = hdc_hdselect(sc, unit);
		break;
	case 2:
		error = hdc_rxselect(sc, unit);
		/* bertram: delay ??? XXX */
		break;
	default:
		printf("invalid unit %d in hdc_select()\n", unit);
		error = -1;
	}
d847 34
a880 1
	return (error);
a881 1
#endif	/* NHDC > 0 */
@


1.11
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.10 2003/05/11 19:41:12 deraadt Exp $ */
d1061 1
a1061 1
	if ((error != 0) || (q->udc_dstat & UDC_DS_READY == 0)) {
d1065 1
a1065 1
		if ((error != 0) || (q->udc_dstat & UDC_DS_READY == 0)) {
d1079 1
a1079 1
		if ((error != 0) || (q->udc_dstat & UDC_DS_READY == 1)) {
d1088 1
a1088 1
		if ((error != 0) || (q->udc_dstat & UDC_DS_READY == 0)) {
@


1.10
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.9 2002/06/08 08:50:26 art Exp $ */
d219 1
a219 1
 * new-config's hdcmatch() is similiar to old-config's hdcprobe(), 
d384 1
a384 1
	 * if neccessary correct the label...
@


1.9
log
@protect biodone with splbio
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.8 2002/03/14 03:16:02 millert Exp $ */
d600 1
a600 1
	hdc_mid2str(p->media_id, dname);
d623 1
d636 1
a636 1
	sprintf(name, "%c%c%d", MIDCHR(p->a0), MIDCHR(p->a1), p->mt);
d682 1
a682 1
	hdc_mid2str(hd->sc_xbn.media_id, hp->diskname);
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.7 2002/03/14 01:26:49 millert Exp $ */
d448 1
d450 1
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.6 2002/01/16 20:50:17 miod Exp $ */
d279 1
a279 1
	struct hdcsoftc *sc = (void*)self;
d292 1
a292 1
	sc->sc_dkc = (void*)uvax_phys2virt(sc->sc_ioaddr);
d300 2
a301 2
	sc->sc_dkc     = (void*)uvax_phys2virt(KA410_DKC_BASE);
	sc->sc_dmabase = (void*)uvax_phys2virt(KA410_DMA_BASE);
d314 1
a314 1
		(void)config_found(self, (void*)&ha, hdprint);
d333 1
a333 1
	struct hdcsoftc *hdc = (void*)parent;
d368 2
a369 2
	struct hdcsoftc *hdc = (void*)parent;
	struct hdsoftc *hd = (void*)self;
d629 1
a629 1
	} *p = (void*)&media_id;
d691 1
a691 1
	struct disklabel *xp = (void*)(hdc_iobuf + 64);
d938 1
a938 1
	p = (void*)&sc->sc_sreg;	
d953 1
a953 1
	p = (void*)&sc->sc_creg;	
d967 3
a969 3
	volatile u_char *intreq = (void*)uvax_phys2virt(KA410_INTREQ);
	volatile u_char *intclr = (void*)uvax_phys2virt(KA410_INTCLR);
	volatile u_char *intmsk = (void*)uvax_phys2virt(KA410_INTMSK);
@


1.6
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.5 1997/10/08 07:09:56 niklas Exp $ */
d181 3
a183 3
int	hdcmatch  __P((struct device *parent, void *cfdata, void *aux));
void	hdcattach __P((struct device *parent, struct device *self, void *aux));
int	hdcprint  __P((void *aux, const char *name));
d192 4
a195 4
int	hdmatch __P((struct device *parent, void *cfdata, void *aux));
void	hdattach __P((struct device *parent, struct device *self, void *aux));
int	hdprint __P((void *aux, const char *name));
void	hdstrategy __P((struct buf *bp));
d209 3
a211 3
int hdc_reset	__P((struct hdcsoftc *sc));
int hdc_select	__P((struct hdcsoftc *sc, int drive));
int hdc_command __P((struct hdcsoftc *sc, int cmd));
d213 2
a214 2
int hdc_getdata	 __P((struct hdcsoftc *hdc, struct hdsoftc *hd, int drive));
int hdc_getlabel __P((struct hdcsoftc *hdc, struct hdsoftc *hd, int drive));
d216 1
a216 1
void hdgetlabel __P((struct hdsoftc *sc));
@


1.5
log
@Move some debugging output inside #ifdef DEBUG. KNF!
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.4 1997/09/20 13:54:23 maja Exp $ */
a67 1
#include <sys/map.h>
@


1.5.12.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d68 1
@


1.5.12.2
log
@Merge in -current from about a week ago
@
text
@d181 3
a183 3
int	hdcmatch(struct device *parent, void *cfdata, void *aux);
void	hdcattach(struct device *parent, struct device *self, void *aux);
int	hdcprint(void *aux, const char *name);
d192 4
a195 4
int	hdmatch(struct device *parent, void *cfdata, void *aux);
void	hdattach(struct device *parent, struct device *self, void *aux);
int	hdprint(void *aux, const char *name);
void	hdstrategy(struct buf *bp);
d209 3
a211 3
int hdc_reset(struct hdcsoftc *sc);
int hdc_select(struct hdcsoftc *sc, int drive);
int hdc_command(struct hdcsoftc *sc, int cmd);
d213 2
a214 2
int hdc_getdata(struct hdcsoftc *hdc, struct hdsoftc *hd, int drive);
int hdc_getlabel(struct hdcsoftc *hdc, struct hdsoftc *hd, int drive);
d216 1
a216 1
void hdgetlabel(struct hdsoftc *sc);
d279 1
a279 1
	struct hdcsoftc *sc = (void *)self;
d292 1
a292 1
	sc->sc_dkc = (void *)uvax_phys2virt(sc->sc_ioaddr);
d300 2
a301 2
	sc->sc_dkc     = (void *)uvax_phys2virt(KA410_DKC_BASE);
	sc->sc_dmabase = (void *)uvax_phys2virt(KA410_DMA_BASE);
d314 1
a314 1
		(void)config_found(self, (void *)&ha, hdprint);
d333 1
a333 1
	struct hdcsoftc *hdc = (void *)parent;
d368 2
a369 2
	struct hdcsoftc *hdc = (void *)parent;
	struct hdsoftc *hd = (void *)self;
d629 1
a629 1
	} *p = (void *)&media_id;
d691 1
a691 1
	struct disklabel *xp = (void *)(hdc_iobuf + 64);
d938 1
a938 1
	p = (void *)&sc->sc_sreg;	
d953 1
a953 1
	p = (void *)&sc->sc_creg;	
d967 3
a969 3
	volatile u_char *intreq = (void *)uvax_phys2virt(KA410_INTREQ);
	volatile u_char *intclr = (void *)uvax_phys2virt(KA410_INTCLR);
	volatile u_char *intmsk = (void *)uvax_phys2virt(KA410_INTMSK);
@


1.5.12.3
log
@Sync the SMP branch with 3.3
@
text
@a447 1
	s = splbio();
a448 1
	splx(s);
@


1.5.12.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.5.12.3 2003/03/27 23:52:20 niklas Exp $ */
d600 1
a600 1
	hdc_mid2str(p->media_id, dname, sizeof dname);
a622 1
	size_t len;
d635 1
a635 1
	snprintf(name, len, "%c%c%d", MIDCHR(p->a0), MIDCHR(p->a1), p->mt);
d681 1
a681 1
	hdc_mid2str(hd->sc_xbn.media_id, hp->diskname, sizeof hp->diskname);
@


1.5.12.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d219 1
a219 1
 * new-config's hdcmatch() is similar to old-config's hdcprobe(), 
d384 1
a384 1
	 * if necessary correct the label...
@


1.5.22.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.6 2002/01/16 20:50:17 miod Exp $ */
d68 1
@


1.5.22.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.5.22.1 2002/01/31 22:55:27 niklas Exp $ */
d181 3
a183 3
int	hdcmatch(struct device *parent, void *cfdata, void *aux);
void	hdcattach(struct device *parent, struct device *self, void *aux);
int	hdcprint(void *aux, const char *name);
d192 4
a195 4
int	hdmatch(struct device *parent, void *cfdata, void *aux);
void	hdattach(struct device *parent, struct device *self, void *aux);
int	hdprint(void *aux, const char *name);
void	hdstrategy(struct buf *bp);
d209 3
a211 3
int hdc_reset(struct hdcsoftc *sc);
int hdc_select(struct hdcsoftc *sc, int drive);
int hdc_command(struct hdcsoftc *sc, int cmd);
d213 2
a214 2
int hdc_getdata(struct hdcsoftc *hdc, struct hdsoftc *hd, int drive);
int hdc_getlabel(struct hdcsoftc *hdc, struct hdsoftc *hd, int drive);
d216 1
a216 1
void hdgetlabel(struct hdsoftc *sc);
d279 1
a279 1
	struct hdcsoftc *sc = (void *)self;
d292 1
a292 1
	sc->sc_dkc = (void *)uvax_phys2virt(sc->sc_ioaddr);
d300 2
a301 2
	sc->sc_dkc     = (void *)uvax_phys2virt(KA410_DKC_BASE);
	sc->sc_dmabase = (void *)uvax_phys2virt(KA410_DMA_BASE);
d314 1
a314 1
		(void)config_found(self, (void *)&ha, hdprint);
d333 1
a333 1
	struct hdcsoftc *hdc = (void *)parent;
d368 2
a369 2
	struct hdcsoftc *hdc = (void *)parent;
	struct hdsoftc *hd = (void *)self;
a447 1
	s = splbio();
a448 1
	splx(s);
d629 1
a629 1
	} *p = (void *)&media_id;
d691 1
a691 1
	struct disklabel *xp = (void *)(hdc_iobuf + 64);
d938 1
a938 1
	p = (void *)&sc->sc_sreg;	
d953 1
a953 1
	p = (void *)&sc->sc_creg;	
d967 3
a969 3
	volatile u_char *intreq = (void *)uvax_phys2virt(KA410_INTREQ);
	volatile u_char *intclr = (void *)uvax_phys2virt(KA410_INTCLR);
	volatile u_char *intmsk = (void *)uvax_phys2virt(KA410_INTMSK);
@


1.5.22.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d600 1
a600 1
	hdc_mid2str(p->media_id, dname, sizeof dname);
a622 1
	size_t len;
d635 1
a635 1
	snprintf(name, len, "%c%c%d", MIDCHR(p->a0), MIDCHR(p->a1), p->mt);
d681 1
a681 1
	hdc_mid2str(hd->sc_xbn.media_id, hp->diskname, sizeof hp->diskname);
@


1.4
log
@Rename rd to hd. OpenBSD uses rd for ramdisk. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.3 1997/09/10 12:08:36 maja Exp $ */
d244 2
a245 2
		printf ("unexpected boardtype 0x%x in hdcmatch()\n", 
			vax_boardtype);
d268 1
a268 1
		printf (" drive %d", ha->ha_drive);
d286 1
a286 1
	printf ("\n");
d308 1
a308 1
			printf ("problems with hdc_reset()...\n");
d352 1
a352 1
		printf ("hdmatch: invalid unit-number %d\n", drive);
d394 2
a395 2
		       hp->diskname, hp->diskblks/2048, hp->disklbns, 
		       hp->cylinders, hp->heads, hp->sectors);
d601 11
a611 11
	printf ("**DiskData**	 XBNs: %d, DBNs: %d, LBNs: %d, RBNs: %d\n",
		p->xbn_count, p->dbn_count, p->lbn_count, p->rbn_count);
	printf ("sec/track: %d, tracks: %d, cyl: %d, precomp/reduced: %d/%d\n",
		p->nspt, p->ntracks, p->ncylinders, p->precomp, p->reduced);
	printf ("seek-rate: %d, crc/eec: %s, RCT: %d, RCT-copies: %d\n",
		p->seek_rate, p->crc_eec?"EEC":"CRC", p->rct, p->rct_ncopies);
	printf ("media-ID: %s, interleave: %d, headskew: %d, cylskew: %d\n",
		dname, p->interleave, p->headskew, p->cylskew);
	printf ("gap0: %d, gap1: %d, gap2: %d, gap3: %d, sync-value: %d\n",
		p->gap0_size, p->gap1_size, p->gap2_size, p->gap3_size, 
		p->sync_value);
d634 1
a634 1
	sprintf (name, "%c%c%d", MIDCHR(p->a0), MIDCHR(p->a1), p->mt);
d695 11
a705 1
	trace (("hdc_getlabel(%d)\n", unit));
a706 4
#define LBL_CHECK(x)	if (xp->x != lp->x) {			\
			  printf ("%d-->%d\n", xp->x, lp->x);	\
			  xp->x = lp->x;			\
			}
d763 2
a764 2
		printf ("hdcopen: invalid unit %d\n", unit);
		return ENXIO;
d875 2
a876 2
			return ENOTTY;
		printf ("IOCTL %x not implemented.\n", cmd);
d989 1
a989 1
		printf ("hdc_command: timeout in command 0x%x\n", cmd);
d1000 1
a1000 1
		printf ("command 0x%x completed with status 0x%x\n",
d1022 2
a1023 2
		printf ("RESET command completed with status 0x%x\n",
			sc->sc_status);
d1060 16
a1075 8
	  printf("\nfloppy-drive not ready (new floppy inserted?)\n\n");
	  p->udc_rtcnt &= ~UDC_RC_INVRDY;	/* clear INVRDY-flag */
	  error = hdc_command(sc, DKC_CMD_DRSEL_RX33 | unit);
	  if ((error != 0) || (q->udc_dstat & UDC_DS_READY == 0)) {
	    printf("diskette not ready(1): %x/%x\n", error, q->udc_dstat);
	    printf("floppy-drive offline?\n");
	    return (-1);
	  }
d1077 6
a1082 10
	  if (q->udc_dstat & UDC_DS_TRK00)		    /* if track-0 */
	    error = hdc_command(sc, DKC_CMD_STEPIN_FDD);   /* step inwards */
	  else						    /* else */
	    error = hdc_command(sc, DKC_CMD_STEPOUT_FDD);  /* step outwards */

	  if ((error != 0) || (q->udc_dstat & UDC_DS_READY == 1)) {
	    printf("diskette not ready(2): %x/%x\n", error, q->udc_dstat);
	    printf("No floppy inserted or drive offline\n");
	    /* return (-1); */
	  }
d1084 9
a1092 8
	  p->udc_rtcnt |= UDC_RC_INVRDY;
	  error = hdc_command(sc, DKC_CMD_DRSEL_RX33 | unit);
	  if ((error != 0) || (q->udc_dstat & UDC_DS_READY == 0)) {
	    printf("diskette not ready(3): %x/%x\n", error, q->udc_dstat);
	    printf("no floppy inserted or floppy-door open\n");
	    return(-1);
	  }
	  printf("floppy-drive reselected.\n");
@


1.3
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: hdc9224.c,v 1.2 1997/05/29 00:05:32 niklas Exp $ */
d91 1
a91 1
#define UNITNAME  "rd"
d107 1
a107 1
struct rdgeom {
d142 1
a142 1
struct	rdsoftc {
d145 2
a146 2
	struct rdgeom	sc_xbn;		/* on-disk geometry information */
	struct rdparams {
d193 4
a196 4
int	rdmatch __P((struct device *parent, void *cfdata, void *aux));
void	rdattach __P((struct device *parent, struct device *self, void *aux));
int	rdprint __P((void *aux, const char *name));
void	rdstrategy __P((struct buf *bp));
d198 2
a199 2
struct	cfdriver rd_cd = {
	NULL, "rd", DV_DISK
d201 2
a202 2
struct	cfattach rd_ca = {
	sizeof(struct rdsoftc), rdmatch, rdattach
d205 1
a205 1
struct dkdriver rddkdriver = { rdstrategy };
d214 2
a215 2
int hdc_getdata	 __P((struct hdcsoftc *hdc, struct rdsoftc *rd, int drive));
int hdc_getlabel __P((struct hdcsoftc *hdc, struct rdsoftc *rd, int drive));
d217 1
a217 1
void rdgetlabel __P((struct rdsoftc *sc));
d259 1
a259 1
rdprint(aux, name)
d265 1
a265 1
	trace(("rdprint(%d, %s)\n", ha->ha_drive, name));
d315 1
a315 1
		(void)config_found(self, (void*)&ha, rdprint);
d327 1
a327 1
 * rdmatch() probes for the existence of a RD-type disk/floppy
d330 1
a330 1
rdmatch(parent, match, aux)
d340 1
a340 1
	trace(("rdmatch(%d, %d)\n", cf->cf_unit, drive));
d352 1
a352 1
		printf ("rdmatch: invalid unit-number %d\n", drive);
d365 1
a365 1
rdattach(parent, self, aux)
d370 1
a370 1
	struct rdsoftc *rd = (void*)self;
d372 1
a372 1
	struct rdparams *rp = &rd->sc_param;
d374 1
a374 1
	trace(("rdattach(%d)\n", ha->ha_drive));
d376 1
a376 1
	rd->sc_drive = ha->ha_drive;
d380 3
a382 3
	rd->sc_dk.dk_driver = &rddkdriver;
	rd->sc_dk.dk_name = rd->sc_dev.dv_xname;
	disk_attach(&rd->sc_dk);
d387 2
a388 2
	printf("\n%s: ", rd->sc_dev.dv_xname);
	if (rd->sc_drive == 2) {
d392 1
a392 1
		hdc_getdata(hdc, rd, rd->sc_drive);
d394 2
a395 2
		       rp->diskname, rp->diskblks/2048, rp->disklbns, 
		       rp->cylinders, rp->heads, rp->sectors);
d400 1
a400 1
	if ((B_TYPE(bootdev) == BDEV_RD) && (rd->sc_drive == B_UNIT(bootdev)))
d409 1
a409 1
rdstrategy(bp)
d412 2
a413 2
	struct rdsoftc *rd = rd_cd.cd_devs[HDCUNIT(bp->b_dev)];
	struct hdcsoftc *hdc = (void *)rd->sc_dev.dv_parent;
d417 1
a417 1
	trace (("rdstrategy(#%d/%d)\n", bp->b_blkno, bp->b_bcount));
d428 1
a428 1
	 * what follows now should not be here but in rdstart...
d431 2
a432 2
	blkno = bp->b_blkno / (rd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
	p = &rd->sc_dk.dk_label->d_partitions[HDCPART(bp->b_dev)];
d437 1
a437 1
	if (hdc_strategy(hdc, rd, HDCUNIT(bp->b_dev), 
d453 1
a453 1
hdc_strategy(hdc, rd, unit, func, dblk, size, buf)
d455 1
a455 1
	struct rdsoftc *rd;
d463 1
a463 1
	struct disklabel *lp = rd->sc_dk.dk_label;
d596 1
a596 1
	struct rdgeom *p;
d638 1
a638 1
hdc_getdata(hdc, rd, unit)
d640 1
a640 1
	struct rdsoftc *rd;
d643 2
a644 2
	struct disklabel *lp = rd->sc_dk.dk_label;
	struct rdparams *rp = &rd->sc_param;
d649 2
a650 2
	bzero(rd->sc_dk.dk_label, sizeof(struct disklabel));
	bzero(rd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d662 2
a663 2
	res = hdc_strategy(hdc, rd, unit, F_READ, -1, 4096, hdc_iobuf);
	bcopy (hdc_iobuf, &rd->sc_xbn, sizeof(struct rdgeom));
d665 1
a665 1
	hdc_printgeom(&rd->sc_xbn);
d668 3
a670 3
	lp->d_ntracks = rd->sc_xbn.ntracks;
	lp->d_nsectors = rd->sc_xbn.nspt;
	lp->d_ncylinders = rd->sc_xbn.ncylinders;
d673 8
a680 8
	rp->cylinders = rd->sc_xbn.ncylinders;
	rp->heads = rd->sc_xbn.ntracks;
	rp->sectors = rd->sc_xbn.nspt;
	rp->diskblks = rp->cylinders * rp->heads * rp->sectors;
	rp->disklbns = rd->sc_xbn.lbn_count;
	rp->blksize = DEV_BSIZE;
	rp->diskbytes = rp->disklbns * rp->blksize;
	hdc_mid2str(rd->sc_xbn.media_id, rp->diskname);
d686 1
a686 1
hdc_getlabel(hdc, rd, unit)
d688 1
a688 1
	struct rdsoftc *rd;
d691 1
a691 1
	struct disklabel *lp = rd->sc_dk.dk_label;
d701 1
a701 1
	res = hdc_strategy(hdc, rd, unit, F_READ, 0, DEV_BSIZE, hdc_iobuf);
d720 1
a720 1
	struct rdsoftc *rd = rd_cd.cd_devs[unit];
d728 1
a728 1
	if (rd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
d732 1
a732 1
		size = rd->sc_dk.dk_label->d_partitions[part].p_size;
d751 1
a751 1
	struct rdsoftc *rd;
d756 1
a756 1
	if (unit >= rd_cd.cd_ndevs) {
d760 3
a762 3
	rd = rd_cd.cd_devs[unit];
	if (!rd) {
		printf("hdcopen: null-pointer in rdsoftc.\n");
d765 1
a765 1
	hdc = (void *)rd->sc_dev.dv_parent;
d769 2
a770 2
	hdc_getdata (hdc, rd, unit);
	hdc_getlabel (hdc, rd, unit);
d795 1
a795 1
	rdstrategy(bp);
d810 2
a811 2
	struct rdsoftc *rd = rd_cd.cd_devs[HDCUNIT(dev)];
	struct hdcsoftc *hdc = (void *)rd->sc_dev.dv_parent;
d823 1
a823 1
		*(struct disklabel *)data = *(rd->sc_dk.dk_label);
d827 1
a827 1
		((struct partinfo *)data)->disklab = rd->sc_dk.dk_label;
d829 1
a829 1
		  &rd->sc_dk.dk_label->d_partitions[HDCPART(dev)];
d842 2
a843 2
		error = setdisklabel(rd->sc_dk.dk_label,
		     (struct disklabel *)data, 0, rd->sc_dk.dk_cpulabel);
d847 2
a848 2
					rdstrategy, rd->sc_dk.dk_label,
					rd->sc_dk.dk_cpulabel);
d1090 1
a1090 1
hdc_rdselect(sc, unit)
d1137 1
a1137 1
		error = hdc_rdselect(sc, unit);
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: hdc9224.c,v 1.4 1996/10/13 03:36:11 christos Exp $ */
/*	$NetBSD: hdc9224.c,v 1.4 1996/10/13 03:36:11 christos Exp $ */
d74 1
d82 1
d397 5
d432 3
a434 4
	if (HDCPART(bp->b_dev) != RAW_PART) {
		p = &rd->sc_dk.dk_label->d_partitions[HDCPART(bp->b_dev)];
		blkno += p->p_offset;
	}
a1149 1

@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
