head	1.9;
access;
symbols
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.18
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.16
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.12
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.10
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.8
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.10
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.12
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.10
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.8
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.2.0.4
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.03.09.16.28.50;	author deraadt;	state dead;
branches;
next	1.8;
commitid	OSDG2O3Cgeifnf1W;

1.8
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.7;
commitid	5gdEnqVoJuTuwdTu;

1.7
date	2014.11.05.07.09.04;	author jsg;	state Exp;
branches;
next	1.6;
commitid	ANf4pDZ9nvP0MIpf;

1.6
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.22.17.09.08;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.30.19.28.13;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.02.34.50;	author bjc;	state Exp;
branches
	1.1.8.1;
next	;

1.1.8.1
date	2001.05.14.21.39.19;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.9
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: if_ze_vsbus.c,v 1.8 2015/11/24 17:11:39 mpi Exp $	*/
/*      $NetBSD: if_ze_vsbus.c,v 1.5 2000/07/26 21:50:49 matt Exp $ */
/*
 * Copyright (c) 1999 Ludd, University of Lule}, Sweden. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/sockio.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/vsbus.h>
#include <machine/cpu.h>
#include <machine/scb.h>
#include <machine/sid.h>

#include <arch/vax/if/sgecreg.h>
#include <arch/vax/if/sgecvar.h>

/*
 * Addresses.
 */
#define SGECADDR        0x20008000
#define NISA_ROM        0x27800000
#define	SGECVEC		0x108

static	int	zematch(struct device *, void *, void *);
static	void	zeattach(struct device *, struct device *, void *);

struct	cfattach ze_vsbus_ca = {
	sizeof(struct ze_softc), zematch, zeattach
};

/*
 * Check for present SGEC.
 */
int
zematch(parent, cf, aux)
	struct	device *parent;
	void	*cf;
	void	*aux;
{
	/*
	 * Should some more intelligent checking be done???
	 * Should for sure force an interrupt instead...
	 */
	if (vax_boardtype != VAX_BTYP_49)
		return 0;

	/* Fool the interrupt system. */
	scb_fake(SGECVEC, 0x15);
	return 12;
}

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
void
zeattach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
{
	struct ze_softc *sc = (struct ze_softc *)self;
	struct vsbus_attach_args *va = aux;
	extern struct vax_bus_dma_tag vax_bus_dma_tag;
	int *ea, i;

	/*
	 * Map in SGEC registers.
	 */
	sc->sc_ioh = vax_map_physmem(SGECADDR, 1);
	sc->sc_iot = 0; /* :-) */
	sc->sc_dmat = &vax_bus_dma_tag;

	sc->sc_intvec = SGECVEC;
	scb_vecalloc(va->va_cvec, (void (*)(void *)) sgec_intr,
	    sc, SCB_ISTACK, &sc->sc_intrcnt);
	evcount_attach(&sc->sc_intrcnt, sc->sc_dev.dv_xname, &sc->sc_intvec);

	/*
	 * Map in, read and release ethernet rom address.
	 */
	ea = (int *)vax_map_physmem(NISA_ROM, 1);
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc->sc_ac.ac_enaddr[i] = ea[i] & 0377;
	vax_unmap_physmem((vaddr_t)ea, 1);

	sgec_attach(sc);
}
@


1.8
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ze_vsbus.c,v 1.7 2014/11/05 07:09:04 jsg Exp $	*/
@


1.7
log
@remove uneeded bpf includes
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ze_vsbus.c,v 1.6 2010/09/20 06:33:48 matthew Exp $	*/
a39 1
#include <net/if_dl.h>
@


1.6
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ze_vsbus.c,v 1.5 2008/08/22 17:09:08 deraadt Exp $	*/
a44 5

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif
@


1.5
log
@Instead of spewing error messages about link status, support link status
like all drivers should
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ze_vsbus.c,v 1.4 2006/08/30 19:28:13 miod Exp $	*/
d120 1
a120 2
	evcount_attach(&sc->sc_intrcnt, sc->sc_dev.dv_xname,
	    (void *)&sc->sc_intvec, &evcount_intr);
@


1.4
log
@Teach the SGEC driver about the Real World:
- check for error bits in descriptors, and count and report errors
  accordingly; make sure we do not pass up known-to-be-bad packets up the
  receive path.
- check for various error conditions which would cause the transmit process
  to go to suspended state, and recover from them, before the timeout expires.
- finally, on the VXT2000, the transmit process for some reason will reset
  its ring position to the beginning of the ring every time it completes a
  transmission burst, while we don't, so play with the head of ring register
  behind its back. This makes my VXT2000+ (net)boot multiuser.

Tested on VXT2000 (ze@@vxtbus), KA49 (ze@@vsbus) and KA53 (ze@@ibus); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ze_vsbus.c,v 1.3 2003/11/07 10:16:45 jmc Exp $	*/
d41 1
@


1.3
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ze_vsbus.c,v 1.2 2001/08/25 13:33:37 hugh Exp $	*/
d119 2
@


1.2
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ze_vsbus.c,v 1.1 2000/04/27 02:34:50 bjc Exp $	*/
d60 1
a60 1
 * Adresses.
@


1.1
log
@forgot these, oops
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*      $NetBSD: if_ze_vsbus.c,v 1.2 2000/01/24 02:40:35 matt Exp $ */
d66 2
a67 2
static	int	zematch __P((struct device *, void *, void *));
static	void	zeattach __P((struct device *, struct device *, void *));
d106 1
d114 1
a114 1
	sc->sc_dmat = va->va_dmat;
d117 2
a118 1
	scb_vecalloc(va->va_cvec, (void (*)(void *)) sgec_intr, sc, SCB_ISTACK);
@


1.1.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ze_vsbus.c,v 1.1 2000/04/27 02:34:50 bjc Exp $	*/
@


1.1.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ze_vsbus.c,v 1.1.8.1 2001/05/14 21:39:19 niklas Exp $	*/
/*      $NetBSD: if_ze_vsbus.c,v 1.5 2000/07/26 21:50:49 matt Exp $ */
d66 2
a67 2
static	int	zematch(struct device *, void *, void *);
static	void	zeattach(struct device *, struct device *, void *);
a105 1
	extern struct vax_bus_dma_tag vax_bus_dma_tag;
d113 1
a113 1
	sc->sc_dmat = &vax_bus_dma_tag;
d116 1
a116 2
	scb_vecalloc(va->va_cvec, (void (*)(void *)) sgec_intr,
	    sc, SCB_ISTACK, &sc->sc_intrcnt);
@


1.1.8.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
a60 1
 * Addresses.
@


