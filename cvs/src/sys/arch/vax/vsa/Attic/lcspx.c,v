head	1.22;
access;
symbols
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.8
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10;
locks; strict;
comment	@ * @;


1.22
date	2016.03.09.16.28.50;	author deraadt;	state dead;
branches;
next	1.21;
commitid	OSDG2O3Cgeifnf1W;

1.21
date	2014.12.23.21.39.12;	author miod;	state Exp;
branches;
next	1.20;
commitid	foSDoFEw0OUhYWGt;

1.20
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.19;
commitid	uKVPYMN2MLxdZxzH;

1.19
date	2013.10.21.10.36.21;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.20.20.07.28;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2011.09.20.21.11.33;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.21.21.39.50;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.28.20.44.39;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.09.21.54.00;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.01.16.11.19;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.27.16.55.41;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.26.17.39.53;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.26.17.27.02;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.22.21.04.51;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.15.20.26.30;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.05.22.04.53;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.03.18.46.07;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.29.15.11.57;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.29.14.18.57;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.07.24.22.19.54;	author miod;	state Exp;
branches;
next	;


desc
@@


1.22
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: lcspx.c,v 1.21 2014/12/23 21:39:12 miod Exp $	*/
/*
 * Copyright (c) 2006 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2004 Blaz Antonic
 * All rights reserved.
 *
 * This software contains code written by Michael L. Hitch.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the abovementioned copyrights
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/conf.h>
#include <sys/kernel.h>

#include <machine/nexus.h>
#include <machine/vsbus.h>
#include <machine/scb.h>
#include <machine/sid.h>
#include <machine/cpu.h>
#include <machine/ka420.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <dev/ic/bt463reg.h>	/* actually it's a 459 here... */

#define	GPXADDR			0x3c000000	/* XXX */
#define	GPX_ADDER_OFFSET	0x0000		/* XXX */
#include <vax/qbus/qdreg.h>			/* XXX */

#define	LCSPX_REG_ADDR		0x39302000	/* registers */
#define	LCSPX_REG_SIZE		    0x2000
#define	LCSPX_REG1_ADDR		0x39b00000	/* more registers */
#define	LCSPX_RAMDAC_ADDR	0x39b10000	/* RAMDAC */
#define	LCSPX_RAMDAC_INTERLEAVE	0x00004000
#define	LCSPX_FB_ADDR		0x38000000	/* frame buffer */

void	lcspx_attach(struct device *, struct device *, void *);
int	lcspx_vsbus_match(struct device *, void *, void *);
int	lcspx_vxtbus_match(struct device *, void *, void *);

struct	lcspx_screen {
	struct rasops_info ss_ri;
	u_int		ss_fbsize;
	caddr_t		ss_addr;		/* frame buffer address */
	volatile u_int8_t *ss_ramdac[4];
	vaddr_t		ss_reg;
	u_int8_t	ss_cmap[256 * 3];
};

#define	lcspx_reg_read(ss, reg) \
	*(volatile u_int32_t *)((ss)->ss_reg + (reg))
#define	lcspx_reg_write(ss, reg, val) \
	*(volatile u_int32_t *)((ss)->ss_reg + (reg)) = (val)

/* for console */
struct lcspx_screen lcspx_consscr;

struct	lcspx_softc {
	struct device sc_dev;
	struct lcspx_screen *sc_scr;
	int	sc_nscreens;
};

struct cfattach lcspx_vsbus_ca = {
	sizeof(struct lcspx_softc), lcspx_vsbus_match, lcspx_attach,
};

struct cfattach lcspx_vxtbus_ca = {
	sizeof(struct lcspx_softc), lcspx_vxtbus_match, lcspx_attach,
};

struct	cfdriver lcspx_cd = {
	NULL, "lcspx", DV_DULL
};

struct wsscreen_descr lcspx_stdscreen = {
	"std",
};

const struct wsscreen_descr *_lcspx_scrlist[] = {
	&lcspx_stdscreen,
};

const struct wsscreen_list lcspx_screenlist = {
	sizeof(_lcspx_scrlist) / sizeof(struct wsscreen_descr *),
	_lcspx_scrlist,
};

int	lcspx_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	lcspx_mmap(void *, off_t, int);
int	lcspx_alloc_screen(void *, const struct wsscreen_descr *,
	    void **, int *, int *, long *);
void	lcspx_free_screen(void *, void *);
int	lcspx_show_screen(void *, void *, int,
	    void (*) (void *, int, int), void *);
int	lcspx_load_font(void *, void *, struct wsdisplay_font *);
int	lcspx_list_font(void *, struct wsdisplay_font *);

const struct wsdisplay_accessops lcspx_accessops = {
	.ioctl = lcspx_ioctl,
	.mmap = lcspx_mmap,
	.alloc_screen = lcspx_alloc_screen,
	.free_screen = lcspx_free_screen,
	.show_screen = lcspx_show_screen,
	.load_font = lcspx_load_font,
	.list_font = lcspx_list_font
};

int	lcspx_getcmap(struct lcspx_screen *, struct wsdisplay_cmap *);
void	lcspx_loadcmap(struct lcspx_screen *, int, int);
int	lcspx_putcmap(struct lcspx_screen *, struct wsdisplay_cmap *);
static __inline__
void	lcspx_ramdac_wraddr(struct lcspx_screen *, u_int);
void	lcspx_resetcmap(struct lcspx_screen *);
int	lcspx_setup_screen(struct lcspx_screen *, u_int, u_int);

int
lcspx_vsbus_match(struct device *parent, void *vcf, void *aux)
{
	extern int oldvsbus;
	struct vsbus_softc *sc = (void *)parent;
	struct vsbus_attach_args *va = aux;
	volatile struct adder *adder;
	u_short status;

	if (va->va_paddr != LCSPX_REG_ADDR)
		return (0);

	switch (vax_boardtype) {
	default:
		return (0);

	case VAX_BTYP_420:
	case VAX_BTYP_43:
		/* not present on microvaxes */
		if ((vax_confdata & KA420_CFG_MULTU) != 0)
			return (0);

		if ((vax_confdata & KA420_CFG_VIDOPT) == 0)
			return (0);

		/*
		 * We can not check for video memory at the SPX address,
		 * because if no SPX board is installed, the probe will
		 * just hang.
		 * Instead, check for a GPX board and skip probe if the
		 * video option really is a GPX.
		 */
		adder = (volatile struct adder *)
		    vax_map_physmem(GPXADDR + GPX_ADDER_OFFSET, 1);
		if (adder == NULL)
			return (0);
		adder->status = 0;
		status = adder->status;
		vax_unmap_physmem((vaddr_t)adder, 1);
		if (status != offsetof(struct adder, status))
			return (0);

		/* XXX do not attach if not console... yet */
		if ((vax_confdata & KA420_CFG_L3CON) != 0)
			return (0);

		break;

	case VAX_BTYP_49:
		if ((vax_confdata & 0x12) != 0x02)
			return (0);

		break;
	}

	sc->sc_mask = 0x04;	/* XXX - should be generated */
	scb_fake(0x120, oldvsbus ? 0x14 : 0x15);
	return (20);
}

int
lcspx_vxtbus_match(struct device *parent, void *vcf, void *aux)
{
	struct bp_conf *bp = aux;
	int missing;
	volatile u_int8_t *ch;

	if (strcmp(bp->type, lcspx_cd.cd_name) != 0)
		return (0);

	/*
	 * Check for video memory at SPX address.
	 */
	missing = 0;
	ch = (volatile u_int8_t *)vax_map_physmem(LCSPX_FB_ADDR, 1);
	*ch = 0x01;
	if ((*ch & 0x01) == 0)
		missing = 1;
	else {
		*ch = 0x00;
		if ((*ch & 0x01) != 0)
			missing = 1;
	}
	vax_unmap_physmem((vaddr_t)ch, 1);

	return (missing ? 0 : 1);
}

void
lcspx_attach(struct device *parent, struct device *self, void *aux)
{
	struct lcspx_softc *sc = (struct lcspx_softc *)self;
	struct lcspx_screen *ss;
	struct wsemuldisplaydev_attach_args aa;
	int i, console;
	vaddr_t reg1;
	u_int32_t magic;
	u_int width, height;
	extern struct consdev wsdisplay_cons;

	if (cn_tab == &wsdisplay_cons) {
		switch (vax_boardtype) {
		case VAX_BTYP_420:
		case VAX_BTYP_43:
			console = (vax_confdata & KA420_CFG_L3CON) == 0;
			break;
		case VAX_BTYP_49:
			console = (vax_confdata & 8) == 0;
			break;
		default: /* VXT2000 */
			console = (vax_confdata & 2) != 0;
			break;
		}
	} else
		console = 0;
	if (console) {
		ss = &lcspx_consscr;
		sc->sc_nscreens = 1;
	} else {
		ss = malloc(sizeof(*ss), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (ss == NULL) {
			printf(": can not allocate memory\n");
			return;
		}

		switch (vax_boardtype) {
		case VAX_BTYP_420:
		case VAX_BTYP_43:
			/*
			 * See ``EVIL KLUGE ALERT!'' comments in
			 * lcspxcninit() at the end of this file
			 * for meaningless details.
			 */
			reg1 = vax_map_physmem(LCSPX_REG1_ADDR, 1);
			if (reg1 == 0L) {
				printf(": can not map registers\n");
				goto fail1;
			}
			magic = *(u_int32_t *)(reg1 + 0x11c);
			vax_unmap_physmem(reg1, 1);

			if (magic & 0x80) {
				width = 1280;
				height = 1024;
			} else {
				width = 1024;
				height = 864;
			}
			break;
		default:
			width = 1280;
			height = 1024;
			break;
		}

		ss->ss_reg = vax_map_physmem(LCSPX_REG_ADDR,
		    LCSPX_REG_SIZE / VAX_NBPG);
		if (ss->ss_reg == 0L) {
			printf(": can not map registers\n");
			goto fail1;
		}

		for (i = 0; i < 4; i++) {
			ss->ss_ramdac[i] = (volatile u_int8_t *)vax_map_physmem(
			    LCSPX_RAMDAC_ADDR + i * LCSPX_RAMDAC_INTERLEAVE, 1);
			if (ss->ss_ramdac[i] == NULL) {
				printf(": can not map RAMDAC registers\n");
				goto fail2;
			}
		}

		ss->ss_fbsize = width * height;
		ss->ss_addr = (caddr_t)vax_map_physmem(LCSPX_FB_ADDR,
		    ss->ss_fbsize / VAX_NBPG);
		if (ss->ss_addr == NULL) {
			printf(": can not map frame buffer\n");
			goto fail3;
		}

		if (lcspx_setup_screen(ss, width, height) != 0) {
			printf(": initialization failed\n");
			goto fail3;
		}
	}
	sc->sc_scr = ss;

	printf("\n%s: %dx%dx8 frame buffer\n", self->dv_xname,
	    ss->ss_ri.ri_width, ss->ss_ri.ri_height);

	aa.console = console;
	aa.scrdata = &lcspx_screenlist;
	aa.accessops = &lcspx_accessops;
	aa.accesscookie = sc;
	aa.defaultscreens = 0;

	config_found(self, &aa, wsemuldisplaydevprint);
	return;

fail3:
	vax_unmap_physmem((vaddr_t)ss->ss_addr, ss->ss_fbsize / VAX_NBPG);
fail2:
	for (i = 0; i < 4; i++)
		if (ss->ss_ramdac[i] != NULL)
			vax_unmap_physmem((vaddr_t)ss->ss_ramdac[i], 1);
	vax_unmap_physmem(ss->ss_reg, LCSPX_REG_SIZE / VAX_NBPG);
fail1:
	free(ss, M_DEVBUF, sizeof(*ss));
}

static __inline__ void
lcspx_ramdac_wraddr(struct lcspx_screen *ss, u_int addr)
{
	*(ss->ss_ramdac[BT463_REG_ADDR_LOW]) = addr & 0xff;
	*(ss->ss_ramdac[BT463_REG_ADDR_HIGH]) = (addr >> 8) & 0xff;
}

/*
 * Initialize anything necessary for an emulating wsdisplay to work (i.e.
 * pick a font, initialize a rasops structure, setup the accessops callbacks.)
 */
int
lcspx_setup_screen(struct lcspx_screen *ss, u_int width, u_int height)
{
	struct rasops_info *ri = &ss->ss_ri;

	bzero(ri, sizeof(*ri));
	ri->ri_depth = 8;
	ri->ri_width = width;
	ri->ri_height = height;
	ri->ri_stride = width;
	ri->ri_flg = RI_CLEAR | RI_CENTER;
	ri->ri_bits = (void *)ss->ss_addr;
	ri->ri_hw = ss;

	/*
	 * Enable all planes for reading and writing
	 */
	lcspx_reg_write(ss, 0x1170, 0xffffffff);
	lcspx_reg_write(ss, 0x1174, 0xffffffff);
	lcspx_ramdac_wraddr(ss, 0x0204);	/* plane mask */
	*(ss->ss_ramdac[BT463_REG_IREG_DATA]) = 0xff;

	/*
	 * Ask for an unholy big display, rasops will trim this to more
	 * reasonable values.
	 */
	if (rasops_init(ri, 160, 160) != 0)
		return (-1);

	lcspx_resetcmap(ss);

	lcspx_stdscreen.ncols = ri->ri_cols;
	lcspx_stdscreen.nrows = ri->ri_rows;
	lcspx_stdscreen.textops = &ri->ri_ops;
	lcspx_stdscreen.fontwidth = ri->ri_font->fontwidth;
	lcspx_stdscreen.fontheight = ri->ri_font->fontheight;
	lcspx_stdscreen.capabilities = ri->ri_caps;

	return (0);
}

int
lcspx_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct lcspx_softc *sc = v;
	struct lcspx_screen *ss = sc->sc_scr;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_LCSPX;
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = ss->ss_ri.ri_height;
		wdf->width = ss->ss_ri.ri_width;
		wdf->depth = 8;
		wdf->cmsize = 256;
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = ss->ss_ri.ri_stride;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = lcspx_getcmap(ss, cm);
		if (error != 0)
			return (error);
		break;
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = lcspx_putcmap(ss, cm);
		if (error != 0)
			return (error);
		lcspx_loadcmap(ss, cm->index, cm->count);
		break;

	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		break;

	default:
		return (-1);
	}

	return (0);
}

paddr_t
lcspx_mmap(void *v, off_t offset, int prot)
{
	struct lcspx_softc *sc = v;
	struct lcspx_screen *ss = sc->sc_scr;

	if (offset >= ss->ss_fbsize || offset < 0)
		return (-1);

	return (LCSPX_FB_ADDR + offset);
}

int
lcspx_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *defattrp)
{
	struct lcspx_softc *sc = v;
	struct lcspx_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = ri;
	*curxp = *curyp = 0;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, defattrp);
	sc->sc_nscreens++;

	return (0);
}

void
lcspx_free_screen(void *v, void *cookie)
{
	struct lcspx_softc *sc = v;

	sc->sc_nscreens--;
}

int
lcspx_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

int
lcspx_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct lcspx_softc *sc = v;
	struct lcspx_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	return rasops_load_font(ri, emulcookie, font);
}

int
lcspx_list_font(void *v, struct wsdisplay_font *font)
{
	struct lcspx_softc *sc = v;
	struct lcspx_screen *ss = sc->sc_scr;
	struct rasops_info *ri = &ss->ss_ri;

	return rasops_list_font(ri, font);
}

/*
 * Colormap handling routines
 */

int
lcspx_getcmap(struct lcspx_screen *ss, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index, count = cm->count, i;
	int error;
	u_int8_t ramp[256], *c, *r;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	/* extract reds */
	c = ss->ss_cmap + 0 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->red, count)) != 0)
		return (error);

	/* extract greens */
	c = ss->ss_cmap + 1 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->green, count)) != 0)
		return (error);

	/* extract blues */
	c = ss->ss_cmap + 2 + index * 3;
	for (i = count, r = ramp; i != 0; i--)
		*r++ = *c, c += 3;
	if ((error = copyout(ramp, cm->blue, count)) != 0)
		return (error);

	return (0);
}

int
lcspx_putcmap(struct lcspx_screen *ss, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index, count = cm->count;
	int i, error;
	u_int8_t r[256], g[256], b[256], *nr, *ng, *nb, *c;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if ((error = copyin(cm->red, r, count)) != 0)
		return (error);
	if ((error = copyin(cm->green, g, count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, b, count)) != 0)
		return (error);

	nr = r, ng = g, nb = b;
	c = ss->ss_cmap + index * 3;
	for (i = count; i != 0; i--) {
		*c++ = *nr++;
		*c++ = *ng++;
		*c++ = *nb++;
	}

	return (0);
}

void
lcspx_loadcmap(struct lcspx_screen *ss, int from, int count)
{
	u_int8_t *cmap = ss->ss_cmap;
	int i;

	cmap += from * 3;
	for (i = from; i < from + count; i++) {
		/*
		 * Reprogram the index every iteration, because the RAMDAC
		 * may not be in autoincrement mode. XXX fix this
		 */
		lcspx_ramdac_wraddr(ss, i);
		*(ss->ss_ramdac[BT463_REG_CMAP_DATA]) = *cmap++;
		*(ss->ss_ramdac[BT463_REG_CMAP_DATA]) = *cmap++;
		*(ss->ss_ramdac[BT463_REG_CMAP_DATA]) = *cmap++;
	}
}

void
lcspx_resetcmap(struct lcspx_screen *ss)
{
	bcopy(rasops_cmap, ss->ss_cmap, sizeof(ss->ss_cmap));
	lcspx_loadcmap(ss, 0, 256);
}

/*
 * Console support code
 */

int	lcspxcnprobe(void);
int	lcspxcninit(void);

int
lcspxcnprobe()
{
	extern vaddr_t virtual_avail;
	volatile struct adder *adder;
	volatile u_int8_t *ch;
	u_short status;
	int rc;

	switch (vax_boardtype) {
	case VAX_BTYP_420:
	case VAX_BTYP_43:
		if ((vax_confdata & KA420_CFG_L3CON) != 0)
			break; /* doesn't use graphics console */

		/* not present on microvaxes */
		if ((vax_confdata & KA420_CFG_MULTU) != 0)
			break;

		if ((vax_confdata & KA420_CFG_VIDOPT) == 0)
			break;

		/*
		 * We can not check for video memory at the SPX address,
		 * because if no SPX board is installed, the probe will
		 * just hang.
		 * Instead, check for a GPX board and skip probe if the
		 * video option really is a GPX.
		 */
		ioaccess(virtual_avail, GPXADDR + GPX_ADDER_OFFSET, 1);
		adder = (volatile struct adder *)virtual_avail;
		adder->status = 0;
		status = adder->status;
		iounaccess(virtual_avail, 1);
		if (status != offsetof(struct adder, status))
			break;

		return (1);

	case VAX_BTYP_49:
		if ((vax_confdata & 8) != 0)
			break; /* doesn't use graphics console */

		if ((vax_confdata & 0x12) != 0x02)
			break;

		return (1);

	case VAX_BTYP_VXT:
		if ((vax_confdata & 2) == 0)
			break; /* doesn't use graphics console */

		/*
		 * Check for video memory at SPX address.
		 */
		rc = 0;
		ioaccess(virtual_avail, LCSPX_FB_ADDR, 1);
		ch = (volatile u_int8_t *)virtual_avail;
		*ch = 0x01;
		if ((*ch & 0x01) != 0) {
			*ch = 0x00;
			if ((*ch & 0x01) == 0)
				rc = 1;
		}
		iounaccess(virtual_avail, 1);

		if (rc == 0)
			break;

		return (1);

	default:
		break;
	}

	return (0);
}

/*
 * Called very early to setup the glass tty as console.
 * Because it's called before the VM system is initialized, virtual memory
 * for the framebuffer can be stolen directly without disturbing anything.
 */
int
lcspxcninit()
{
	struct lcspx_screen *ss = &lcspx_consscr;
	extern vaddr_t virtual_avail;
	int i;
	u_int width, height;
	vaddr_t ova, reg1;
	u_int32_t magic;
	long defattr;
	struct rasops_info *ri;

	ova = virtual_avail;

	switch (vax_boardtype) {
	case VAX_BTYP_420:
	case VAX_BTYP_43:
		/*
		 * XXX EVIL KLUGE ALERT!
		 *
		 * The spx jumper settings do not show up in vax_confdata.
		 * I don't know which spx register sports their values,
		 * but I have noticed that, after the ROM has initialized
		 * the board, bit 0x80 at 39b0011c will reflect the
		 * resolution setting.
		 *
		 * This register is not read-only, so one could DEPOSIT
		 * a bogus value in it from the console before starting
		 * OpenBSD.  If you do this, you deserve to be bitten
		 * if things go wrong.
		 */
		reg1 = virtual_avail;
		ioaccess(virtual_avail, LCSPX_REG1_ADDR, 1);
		magic = *(u_int32_t *)(reg1 + 0x11c);
		iounaccess(virtual_avail, 1);

		if (magic & 0x80) {
			width = 1280;
			height = 1024;
		} else {
			width = 1024;
			height = 864;
		}
		break;
	default:
		width = 1280;
		height = 1024;
		break;
	}

	ss->ss_fbsize = width * height;
	ss->ss_addr = (caddr_t)virtual_avail;
	ioaccess(virtual_avail, LCSPX_FB_ADDR, ss->ss_fbsize / VAX_NBPG);
	virtual_avail += ss->ss_fbsize;

	ss->ss_reg = virtual_avail;
	ioaccess(virtual_avail, LCSPX_REG_ADDR, LCSPX_REG_SIZE / VAX_NBPG);
	virtual_avail += LCSPX_REG_SIZE;

	for (i = 0; i < 4; i++) {
		ss->ss_ramdac[i] = (volatile u_int8_t *)virtual_avail;
		ioaccess(virtual_avail,
		    LCSPX_RAMDAC_ADDR + i * LCSPX_RAMDAC_INTERLEAVE, 1);
		virtual_avail += VAX_NBPG;
	}

	virtual_avail = round_page(virtual_avail);

	/* this had better not fail */
	if (lcspx_setup_screen(ss, width, height) != 0) {
		for (i = 3; i >= 0; i--)
			iounaccess((vaddr_t)ss->ss_ramdac[i], 1);
		iounaccess(ss->ss_reg, LCSPX_REG_SIZE / VAX_NBPG);
		iounaccess((vaddr_t)ss->ss_addr, ss->ss_fbsize / VAX_NBPG);
		virtual_avail = ova;
		return (1);
	}

	ri = &ss->ss_ri;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&lcspx_stdscreen, ri, 0, 0, defattr);

	return (0);
}
@


1.21
log
@Pass real sizes to free()
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.20 2014/07/12 18:44:43 tedu Exp $	*/
@


1.20
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.19 2013/10/21 10:36:21 miod Exp $	*/
d370 1
a370 1
	free(ss, M_DEVBUF, 0);
@


1.19
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.18 2013/10/20 20:07:28 miod Exp $	*/
d370 1
a370 1
	free(ss, M_DEVBUF);
@


1.18
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.17 2011/09/20 21:11:33 miod Exp $	*/
d143 2
d151 3
a153 1
	.show_screen = lcspx_show_screen
d520 20
@


1.17
log
@Don't bother checking for SPX on KA410 (VS2000), since the only colour option
for this machine is good'ol'GPX.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.16 2010/12/26 15:41:00 miod Exp $	*/
d145 5
a149 9
	lcspx_ioctl,
	lcspx_mmap,
	lcspx_alloc_screen,
	lcspx_free_screen,
	lcspx_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	NULL	/* burner */
@


1.16
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.15 2008/12/21 21:39:50 miod Exp $	*/
a179 1
	case VAX_BTYP_410:
a265 1
		case VAX_BTYP_410:
a289 1
		case VAX_BTYP_410:
a630 1
	case VAX_BTYP_410:
a718 1
	case VAX_BTYP_410:
@


1.15
log
@During early device probes, make sure to iounaccess() address ranges when
they are no longer necessary. No good reason to do so but correctness, and
then leaving correct mappings after probe might hide bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.14 2007/12/28 20:44:39 miod Exp $	*/
d488 1
a488 1
	return (LCSPX_FB_ADDR + offset) >> PGSHIFT;
@


1.14
log
@If initializing a frame buffer as glass console fails, instead of an invisible
panic (for you ichc fans out there), disable the wscons console and force a
console device reselection, which ends up in picking a serial console.

This should not happen, but just in case, it's a less rude behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.13 2007/12/09 21:54:00 miod Exp $	*/
d630 2
d657 3
a659 1
		if (adder->status != offsetof(struct adder, status))
d680 1
d684 8
a691 4
		if ((*ch & 0x01) == 0)
			break;
		*ch = 0x00;
		if ((*ch & 0x01) != 0)
d715 1
a715 1
	vaddr_t reg1;
d720 2
d741 1
a741 1
		ioaccess(reg1, LCSPX_REG1_ADDR, 1);
d743 1
d761 1
a762 1
	ioaccess((vaddr_t)ss->ss_addr, LCSPX_FB_ADDR, ss->ss_fbsize / VAX_NBPG);
d765 1
a766 1
	ioaccess(ss->ss_reg, LCSPX_REG_ADDR, LCSPX_REG_SIZE / VAX_NBPG);
d770 2
a772 2
		ioaccess((vaddr_t)ss->ss_ramdac[i],
		    LCSPX_RAMDAC_ADDR + i * LCSPX_RAMDAC_INTERLEAVE, 1);
d778 6
a783 1
	if (lcspx_setup_screen(ss, width, height) != 0)
d785 1
@


1.13
log
@Attach lcspx to SPX option boards on VAXstation 3100. Tested on model 38 (KA42)
only, should work on model 76 (KA43) as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.12 2007/10/01 16:11:19 krw Exp $	*/
d173 3
a182 3
		if (va->va_paddr != LCSPX_REG_ADDR)
			return (0);

a213 3
		if (va->va_paddr != LCSPX_REG_ADDR)
			return (0);

d622 1
a622 1
void	lcspxcninit(void);
d699 1
a699 1
void
d765 1
a765 1
	/* this had better not fail as we can't recover there */
d767 1
a767 1
		panic(__func__);
d772 2
@


1.12
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.11 2006/11/29 12:13:54 miod Exp $	*/
d61 1
d73 4
a83 4
#define	LCSPX_WIDTH	1280
#define	LCSPX_HEIGHT	1024
#define	LCSPX_FBSIZE	(LCSPX_WIDTH * LCSPX_HEIGHT)

d90 1
d162 1
a162 1
int	lcspx_setup_screen(struct lcspx_screen *);
d167 1
d170 2
d177 36
d224 1
a224 1
	scb_fake(0x120, 0x15);
d263 3
d269 7
a275 1
		if (vax_boardtype == VAX_BTYP_49)
d277 2
a278 1
		else /* VXT2000 */
d280 2
d294 29
a322 5
		ss->ss_addr = (caddr_t)vax_map_physmem(LCSPX_FB_ADDR,
		    LCSPX_FBSIZE / VAX_NBPG);
		if (ss->ss_addr == NULL) {
			printf(": can not map frame buffer\n");
			goto fail1;
d329 1
a329 1
			goto fail2;
d337 1
a337 1
				goto fail3;
d341 9
a349 1
		if (lcspx_setup_screen(ss) != 0) {
d356 2
a357 1
	printf("\n%s: 1280x1024x8 frame buffer\n", self->dv_xname);
d369 2
a374 2
fail2:
	vax_unmap_physmem((vaddr_t)ss->ss_addr, LCSPX_FBSIZE / VAX_NBPG);
d391 1
a391 1
lcspx_setup_screen(struct lcspx_screen *ss)
d397 3
a399 3
	ri->ri_width = LCSPX_WIDTH;
	ri->ri_height = LCSPX_HEIGHT;
	ri->ri_stride = LCSPX_WIDTH;
d447 2
a448 2
		wdf->height = LCSPX_HEIGHT;
		wdf->width = LCSPX_WIDTH;
d485 4
a488 1
	if (offset >= LCSPX_FBSIZE || offset < 0)
d631 1
d635 28
d668 1
a668 1
			return (0);
d708 3
d714 37
d752 2
a753 2
	virtual_avail += LCSPX_FBSIZE;
	ioaccess((vaddr_t)ss->ss_addr, LCSPX_FB_ADDR, LCSPX_FBSIZE / VAX_NBPG);
d769 1
a769 1
	if (lcspx_setup_screen(ss) != 0)
@


1.11
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.10 2006/08/27 16:55:41 miod Exp $	*/
d235 1
a235 1
		ss = malloc(sizeof(struct lcspx_screen), M_DEVBUF, M_NOWAIT);
a239 1
		bzero(ss, sizeof(struct lcspx_screen));
@


1.10
log
@Work-in-progress VXT2000 support (commented out in GENERIC so far). Glass
console works on color model, serial console works, ethernet attaches but
does not work correctly yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.9 2006/08/26 17:39:53 miod Exp $	*/
d278 1
@


1.9
log
@Doh, compile before commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.8 2006/08/26 17:27:02 miod Exp $	*/
d56 1
a82 1
int	lcspx_match(struct device *, void *, void *);
d84 2
d109 6
a114 2
struct cfattach lcspx_ca = {
	sizeof(struct lcspx_softc), lcspx_match, lcspx_attach,
d163 1
a163 1
lcspx_match(struct device *parent, void *vcf, void *aux)
d187 28
d224 7
a230 1
	console = (vax_confdata & 8) == 0 && cn_tab == &wsdisplay_cons;
d541 3
d551 18
@


1.8
log
@Enable all planes in the ramdac as well, so that color really works.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.7 2006/08/22 21:04:51 miod Exp $	*/
d151 1
d283 1
a283 1
	lcspx_ramdac_wraddr(0x0204);	/* plane mask */
d477 1
a477 1
		lcspx_ramdac_wraddr(i);
@


1.7
log
@Wrap dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.6 2006/08/15 20:26:30 miod Exp $	*/
d151 1
d252 7
d282 2
d476 1
a476 3
		*(ss->ss_ramdac[BT463_REG_ADDR_LOW]) = i & 0xff;
		*(ss->ss_ramdac[BT463_REG_ADDR_HIGH]) = i >> 8;

@


1.6
log
@A more reliable LCSPX probe, based on information from Blaz Antonic, tested
by aanriot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.5 2006/08/05 22:04:53 miod Exp $	*/
d230 1
a230 1
	printf(": 1280x1024x8 frame buffer\n");
@


1.5
log
@Colormap ioctls, at last.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.4 2006/08/03 18:46:07 miod Exp $	*/
a158 2
	volatile u_int8_t *ch;
	int rc;
d168 3
a173 14
	/*
	 * Check for video memory.
	 * We can not use badaddr() on these models.
	 */
	ch = (volatile u_int8_t *)vax_map_physmem(LCSPX_FB_ADDR, 1);
	rc = 1;
	*ch = 0x01;
	if ((*ch & 0x01) == 0)
		rc = 0;
	*ch = 0x00;
	if ((*ch & 0x01) != 0)
		rc = 0;
	vax_unmap_physmem((vaddr_t)ch, 1);

a491 4
	extern vaddr_t virtual_avail;
	vaddr_t tmp;
	volatile u_int8_t *ch;

d497 2
a498 13
		/*
		 * Check for video memory.
		 * We can not use badaddr() on these models.
		 */
		tmp = virtual_avail;
		ch = (volatile u_int8_t *)tmp;
		ioaccess(tmp, LCSPX_FB_ADDR, 1);
		*ch = 0x01;
		if ((*ch & 0x01) == 0)
			break;
		*ch = 0x00;
		if ((*ch & 0x01) != 0)
			break;
@


1.4
log
@Enable all planes, so that color has a real chance to work; still untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.3 2006/07/29 15:11:57 miod Exp $	*/
d90 1
d148 3
d283 1
a283 3
	 * We can let rasops select our font here, as we do not need to
	 * use a font with a different bit order than rasops' defaults,
	 * unlike smg.
d285 2
a294 6
	/*
	 * Enable all planes for reading and writing
	 */
	lcspx_reg_write(ss, 0x1170, 0xffffffff);
	lcspx_reg_write(ss, 0x1174, 0xffffffff);

d313 2
d334 5
d340 6
a345 1
		break;	/* XXX TBD */
d401 66
d468 1
a468 1
lcspx_resetcmap(struct lcspx_screen *ss)
d470 2
a471 2
	const u_char *color;
	u_int i;
d473 2
a474 2
	color = rasops_cmap;
	for (i = 0; i < 256; i++) {
d482 3
a484 3
		*(ss->ss_ramdac[BT463_REG_CMAP_DATA]) = *color++;
		*(ss->ss_ramdac[BT463_REG_CMAP_DATA]) = *color++;
		*(ss->ss_ramdac[BT463_REG_CMAP_DATA]) = *color++;
d486 7
@


1.3
log
@At attach() time, do not simply trust the L3 switch to know if we are the
console, check for cn_tab pointing to wsdisplay as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.2 2006/07/29 14:18:57 miod Exp $	*/
d72 1
d89 1
d92 5
d216 7
d228 1
a228 1
				goto fail2;
d234 1
a234 1
			goto fail2;
d249 1
a249 1
fail2:
d253 2
d291 6
d471 4
@


1.2
log
@Rewrite glass console detection and initialization code, it's simpler and
will not allocate frame buffer resources at probe time. A few buglets fixed
while doing so.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.1 2006/07/24 22:19:54 miod Exp $	*/
d63 2
d188 1
d190 1
a190 1
	console = (vax_confdata & 8) == 0;
@


1.1
log
@Driver for the VS4000/90 frame buffer, adapted from NetBSD (ragge) and
Blaz Antonic's work, no acceleration yet, untested due to the lack of
hardware, but enough sacrifices were made to the RAMDAC Gods.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcspx.c,v 1.1 2006/07/24 20:35:08 miod Exp $	*/
d61 2
a63 1
#include <dev/wscons/wscons_callbacks.h>
d387 3
a389 2
#include <dev/cons.h>
cons_decl(lcspx);
d391 2
a392 1
#include "dzkbd.h"
d394 2
a395 13
#include <vax/qbus/dzreg.h>
#include <vax/qbus/dzvar.h>
#include <vax/dec/dzkbdvar.h>


/*
 * Called very early to setup the glass tty as console.
 * Because it's called before the VM system is initialized, virtual memory
 * for the framebuffer can be stolen directly without disturbing anything.
 */
void
lcspxcnprobe(cndev)
	struct  consdev *cndev;
a396 1
	struct lcspx_screen *ss = &lcspx_consscr;
d398 2
a399 2
	extern int getmajor(void *);	/* conf.c */
	int i;
d406 13
a418 4
		ss->ss_addr = (caddr_t)virtual_avail;
		virtual_avail += LCSPX_FBSIZE;
		ioaccess((vaddr_t)ss->ss_addr, LCSPX_FB_ADDR,
		    LCSPX_FBSIZE / VAX_NBPG);
d420 1
a420 10
		for (i = 0; i < 4; i++) {
			ss->ss_ramdac[i] = (volatile u_int8_t *)virtual_avail;
			virtual_avail += VAX_NBPG;
			ioaccess((vaddr_t)ss->ss_ramdac[i],
			    LCSPX_RAMDAC_ADDR + i * LCSPX_RAMDAC_INTERLEAVE, 1);
		}

		cndev->cn_pri = CN_INTERNAL;
		cndev->cn_dev = makedev(getmajor(wsdisplayopen), 0);
		break;
d425 2
d429 5
d435 1
a435 1
lcspxcninit(struct consdev *cndev)
d438 2
a441 3
	extern void lkccninit(struct consdev *);
	extern int lkccngetc(dev_t);
	extern int dz_vsbus_lk201_cnattach(int);
d443 14
a456 1
	/* mappings have been done in lcspxcnprobe() */
d458 1
a458 1
		return;
a462 4

#if NDZKBD > 0
	dzkbd_cnattach(0); /* Connect keyboard and screen together */
#endif
@

