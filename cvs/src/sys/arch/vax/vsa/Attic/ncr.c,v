head	1.29;
access;
symbols
	OPENBSD_5_9:1.28.0.20
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.22
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.14
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.18
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.16
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.12
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.25.0.4
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.8
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.6
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.03.09.16.28.50;	author deraadt;	state dead;
branches;
next	1.28;
commitid	OSDG2O3Cgeifnf1W;

1.28
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.30.18.08.04;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.29.03.04.19;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.13.21.12.58;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.05.14.40.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.19.20.22.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.12.18.09.56;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.12.03.44.24;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.24.21.01.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.12.12.29.15;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.15.13.15.03;	author hugh;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.11.06.34.38;	author hugh;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.11.06.19.19;	author bjc;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.21.17.45.12;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.27.00.52.07;	author bjc;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.12.09;	author millert;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.09.10.12.08.37;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	97.05.28.23.35.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.25.32;	author maja;	state Exp;
branches;
next	;

1.4.6.1
date	2001.05.14.21.39.20;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2001.11.13.21.04.19;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/* $OpenBSD: ncr.c,v 1.28 2010/09/20 06:33:48 matthew Exp $ */
/*	$NetBSD: ncr.c,v 1.32 2000/06/25 16:00:43 ragge Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass, David Jones, Gordon W. Ross, and Jens A. Nilsson.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file contains the machine-dependent parts of the NCR-5380
 * controller. The machine-independent parts are in ncr5380sbc.c.
 *
 * Jens A. Nilsson.
 *
 * Credits:
 * 
 * This code is based on arch/sun3/dev/si*
 * Written by David Jones, Gordon Ross, and Adam Glass.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/disk.h>
#include <sys/proc.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>
#include <scsi/sdvar.h>

#include <dev/ic/ncr5380reg.h>
#include <dev/ic/ncr5380var.h>

#include <machine/cpu.h>
#include <machine/vsbus.h>
#include <machine/bus.h>
#include <machine/sid.h>
#include <machine/scb.h>
#include <machine/clock.h>

#define MIN_DMA_LEN 128

struct si_dma_handle {
	int	dh_flags;
#define SIDH_BUSY	1
#define SIDH_OUT	2
	caddr_t dh_addr;
	int	dh_len;
	struct	proc *dh_proc;
};

struct si_softc {
	struct	ncr5380_softc	ncr_sc;
	struct	evcount		ncr_intrcnt;
	int			ncr_cvec;
	caddr_t ncr_addr;
	int	ncr_off;
	int	ncr_dmaaddr;
	int	ncr_dmacount;
	int	ncr_dmadir;

	/* Pointers to bus_space */
	bus_space_tag_t     sc_regt;
	bus_space_handle_t  sc_regh;

	struct	si_dma_handle ncr_dma[SCI_OPENINGS];
	struct	vsbus_dma sc_vd;
	int	onlyscsi;	/* This machine needs no queueing */
};

static int ncr_dmasize;

static	int si_match(struct device *, void *, void *);
static	void si_attach(struct device *, struct device *, void *);
static	void si_minphys(struct buf *, struct scsi_link *);

static	void si_dma_alloc(struct ncr5380_softc *);
static	void si_dma_free(struct ncr5380_softc *);
static	void si_dma_setup(struct ncr5380_softc *);
static	void si_dma_start(struct ncr5380_softc *);
static	void si_dma_poll(struct ncr5380_softc *);
static	void si_dma_stop(struct ncr5380_softc *);
static	void si_dma_go(void *);

#define NCR5380_READ(sc, reg)	bus_space_read_1(sc->sc_regt,		\
	0, sc->ncr_sc.reg)
#define NCR5380_WRITE(sc, reg, val)	bus_space_write_1(sc->sc_regt,	\
	0, sc->ncr_sc.reg, val)

struct scsi_adapter	si_ops = {
	ncr5380_scsi_cmd,	/* scsi_cmd() */
	si_minphys,		/* scsi_minphys() */
	NULL,			/* probe_dev() */
	NULL			/* free_dev() */
};

struct cfattach ncr_ca = {
	sizeof(struct si_softc), si_match, si_attach
};

struct cfdriver ncr_cd = {
	NULL, "ncr", DV_DULL
};

static int
si_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct vsbus_attach_args *va = aux;
	volatile char *si_csr = (char *) va->va_addr;

	if (vax_boardtype == VAX_BTYP_49 || vax_boardtype == VAX_BTYP_46
	    || vax_boardtype == VAX_BTYP_48 || vax_boardtype == VAX_BTYP_1303)
		return 0;
	/* This is the way Linux autoprobes the interrupt MK-990321 */
	si_csr[12] = 0;
	si_csr[16] = 0x80;
	si_csr[0] = 0x80;
	si_csr[4] = 5; /* 0xcf */
	DELAY(100000);
	return 1;
}

static void
si_attach(parent, self, aux)
	struct device	*parent, *self;
	void		*aux;
{
	struct vsbus_attach_args *va = aux;
	struct si_softc *sc = (struct si_softc *) self;
	struct ncr5380_softc *ncr_sc = &sc->ncr_sc;
	struct scsibus_attach_args saa;
	int tweak, target;

	printf("\n");

	/* enable interrupts on vsbus too */
	scb_vecalloc(va->va_cvec, (void (*)(void *)) ncr5380_intr, sc,
	    SCB_ISTACK, &sc->ncr_intrcnt);
	sc->ncr_cvec = va->va_cvec;
	evcount_attach(&sc->ncr_intrcnt, self->dv_xname, &sc->ncr_cvec);

	/*
	 * DMA area mapin.
	 * On VS3100, split the 128K block between the two devices.
	 * On VS2000, don't care for now.
	 */
#define DMASIZE (64*1024)
	if (va->va_paddr & 0x100) { /* Secondary SCSI controller */
		sc->ncr_off = DMASIZE;
		sc->onlyscsi = 1;
	}
	sc->ncr_addr = (caddr_t)va->va_dmaaddr;
	ncr_dmasize = min(va->va_dmasize, MAXPHYS);

	/*
	 * MD function pointers used by the MI code.
	 */
	ncr_sc->sc_dma_alloc = si_dma_alloc;
	ncr_sc->sc_dma_free  = si_dma_free;
	ncr_sc->sc_dma_setup = si_dma_setup;
	ncr_sc->sc_dma_start = si_dma_start;
	ncr_sc->sc_dma_poll  = si_dma_poll;
	ncr_sc->sc_dma_stop  = si_dma_stop;

	/* DMA control register offsets */
	sc->ncr_dmaaddr = 32;	/* DMA address in buffer, longword */
	sc->ncr_dmacount = 64;	/* DMA count register */
	sc->ncr_dmadir = 68;	/* Direction of DMA transfer */

	ncr_sc->sc_pio_out = ncr5380_pio_out;
	ncr_sc->sc_pio_in =  ncr5380_pio_in;

	ncr_sc->sc_min_dma_len = MIN_DMA_LEN;

	/*
	 * Initialize fields used by the MI code.
	 */
/*	sc->sc_regt =  Unused on VAX */
	sc->sc_regh = vax_map_physmem(va->va_paddr, 1);

	/* Register offsets */
	ncr_sc->sci_r0 = (void *)sc->sc_regh+0;
	ncr_sc->sci_r1 = (void *)sc->sc_regh+4;
	ncr_sc->sci_r2 = (void *)sc->sc_regh+8;
	ncr_sc->sci_r3 = (void *)sc->sc_regh+12;
	ncr_sc->sci_r4 = (void *)sc->sc_regh+16;
	ncr_sc->sci_r5 = (void *)sc->sc_regh+20;
	ncr_sc->sci_r6 = (void *)sc->sc_regh+24;
	ncr_sc->sci_r7 = (void *)sc->sc_regh+28;

	ncr_sc->sc_no_disconnect = 0xff;

	/*
	 * Get the SCSI chip target address out of NVRAM.
	 * This do not apply to the VS2000.
	 */
	tweak = clk_tweak + (va->va_paddr & 0x100 ? 3 : 0);
	if (vax_boardtype == VAX_BTYP_410)
		target = 7;
	else
		target = (clk_page[0xbc/2] >> tweak) & 7;

	ncr_sc->sc_link.adapter_softc =	sc;
	ncr_sc->sc_link.adapter_target = target;
	ncr_sc->sc_link.adapter = &si_ops;
	ncr_sc->sc_link.openings = 4;

	/*
	 * Init the vsbus DMA resource queue struct */
	sc->sc_vd.vd_go = si_dma_go;
	sc->sc_vd.vd_arg = sc;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &(ncr_sc->sc_link);

	/*
	 * Initialize si board itself.
	 */
	ncr5380_init(ncr_sc);
	ncr5380_reset_scsibus(ncr_sc);
	DELAY(2000000);
	config_found(&(ncr_sc->sc_dev), &saa, scsiprint);

}

/*
 * Adjust the max transfer size. The DMA buffer is only 16k on VS2000.
 */
static void
si_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ncr_dmasize)
		bp->b_bcount = ncr_dmasize;
	minphys(bp);
}

void
si_dma_alloc(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct scsi_xfer *xs = sr->sr_xs;
	struct si_dma_handle *dh;
	struct buf *bp;
	int xlen, i;

#ifdef DIAGNOSTIC
	if (sr->sr_dma_hand != NULL)
		panic("si_dma_alloc: already have DMA handle");
#endif

	/* Polled transfers shouldn't allocate a DMA handle. */
	if (sr->sr_flags & SR_IMMED)
		return;

	xlen = ncr_sc->sc_datalen;

	/* Make sure our caller checked sc_min_dma_len. */
	if (xlen < MIN_DMA_LEN)
		panic("si_dma_alloc: len=0x%x", xlen);

	/*
	 * Find free PDMA handle.  Guaranteed to find one since we
	 * have as many PDMA handles as the driver has processes.
	 * (instances?)
	 */
	 for (i = 0; i < SCI_OPENINGS; i++) {
		if ((sc->ncr_dma[i].dh_flags & SIDH_BUSY) == 0)
			goto found;
	}
	panic("ncr: no free PDMA handles");
found:
	dh = &sc->ncr_dma[i];
	dh->dh_flags = SIDH_BUSY;
	dh->dh_addr = ncr_sc->sc_dataptr;
	dh->dh_len = xlen;
	bp = xs->bp;
	if (bp != NULL)
		dh->dh_proc = (bp->b_flags & B_PHYS ? bp->b_proc : NULL);
	else
		dh->dh_proc = NULL;

	/* Remember dest buffer parameters */
	if (xs->flags & SCSI_DATA_OUT)
		dh->dh_flags |= SIDH_OUT;

	sr->sr_dma_hand = dh;
}

void
si_dma_free(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;

#ifdef DIAGNOSTIC
	if (dh == NULL)
		panic("si_dma_free: no DMA handle");
#endif

	if (ncr_sc->sc_state & NCR_DOINGDMA)
		panic("si_dma_free: free while DMA in progress");

	if (dh->dh_flags & SIDH_BUSY)
		dh->dh_flags = 0;
	else
		printf("si_dma_free: free'ing unused buffer\n");

	sr->sr_dma_hand = NULL;
}

void
si_dma_setup(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	/* Do nothing here */
}

void
si_dma_start(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;

	/* Just put on queue; will call go() from below */
	if (sc->onlyscsi)
		si_dma_go(ncr_sc);
	else
		vsbus_dma_start(&sc->sc_vd);
}

/*
 * go() routine called when another transfer somewhere is finished.
 */
void
si_dma_go(arg)
	void *arg;
{
	struct ncr5380_softc *ncr_sc = arg;
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;

	/*
	 * Set the VAX-DMA-specific registers, and copy the data if
	 * it is directed "outbound".
	 */
	if (dh->dh_flags & SIDH_OUT) {
		vsbus_copyfromproc(dh->dh_proc, dh->dh_addr,
		    sc->ncr_addr + sc->ncr_off, dh->dh_len);
		bus_space_write_1(sc->sc_regt, sc->sc_regh,
		    sc->ncr_dmadir, 0);
	} else {
		bus_space_write_1(sc->sc_regt, sc->sc_regh,
		    sc->ncr_dmadir, 1);
	}
	bus_space_write_4(sc->sc_regt, sc->sc_regh,
	    sc->ncr_dmacount, -dh->dh_len);
	bus_space_write_4(sc->sc_regt, sc->sc_regh,
	    sc->ncr_dmaaddr, sc->ncr_off);
	/*
	 * Now from the 5380-internal DMA registers.
	 */
	if (dh->dh_flags & SIDH_OUT) {
		NCR5380_WRITE(sc, sci_tcmd, PHASE_DATA_OUT);
		NCR5380_WRITE(sc, sci_icmd, SCI_ICMD_DATA);
		NCR5380_WRITE(sc, sci_mode, NCR5380_READ(sc, sci_mode)
		    | SCI_MODE_DMA | SCI_MODE_DMA_IE);
		NCR5380_WRITE(sc, sci_dma_send, 0);
	} else {
		NCR5380_WRITE(sc, sci_tcmd, PHASE_DATA_IN);
		NCR5380_WRITE(sc, sci_icmd, 0);
		NCR5380_WRITE(sc, sci_mode, NCR5380_READ(sc, sci_mode)
		    | SCI_MODE_DMA | SCI_MODE_DMA_IE);
		NCR5380_WRITE(sc, sci_irecv, 0);
	}
	ncr_sc->sc_state |= NCR_DOINGDMA;
}

/*
 * When?
 */
void
si_dma_poll(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	printf("si_dma_poll\n");
}

void
si_dma_stop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	int count, i;

	if (ncr_sc->sc_state & NCR_DOINGDMA) 
		ncr_sc->sc_state &= ~NCR_DOINGDMA;

	/*
	 * Sometimes the FIFO buffer isn't drained when the
	 * interrupt is posted. Just loop here and hope that
	 * it will drain soon.
	 */
	for (i = 0; i < 20000; i++) {
		count = bus_space_read_4(sc->sc_regt,
		    sc->sc_regh, sc->ncr_dmacount);
		if (count == 0)
			break;
		DELAY(100);
	}
	if (count == 0) {
		if (((dh->dh_flags & SIDH_OUT) == 0)) {
			vsbus_copytoproc(dh->dh_proc,
			    sc->ncr_addr + sc->ncr_off,
			    dh->dh_addr, dh->dh_len);
		}
		ncr_sc->sc_dataptr += dh->dh_len;
		ncr_sc->sc_datalen -= dh->dh_len;
	}

	NCR5380_WRITE(sc, sci_mode, NCR5380_READ(sc, sci_mode) &
	    ~(SCI_MODE_DMA | SCI_MODE_DMA_IE));
	NCR5380_WRITE(sc, sci_icmd, 0);
	if (sc->onlyscsi == 0)
		vsbus_dma_intr(); /* Try to start more transfers */
}
@


1.28
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.27 2010/06/28 18:31:01 krw Exp $ */
@


1.27
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.26 2010/06/26 23:24:44 guenther Exp $ */
d174 1
a174 2
	evcount_attach(&sc->ncr_intrcnt, self->dv_xname,
	    (void *)&sc->ncr_cvec, &evcount_intr);
@


1.26
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.25 2009/02/16 21:19:06 miod Exp $ */
a127 7
struct scsi_device	si_dev = {
	NULL,		/* use default error handler */
	NULL,		/* no start function */
	NULL,		/* no async handler */
	NULL		/* use default done routine */
};

a240 1
	ncr_sc->sc_link.device = &si_dev;
@


1.25
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.24 2008/07/30 18:08:04 miod Exp $ */
a53 1
#include <sys/user.h>
@


1.24
log
@Do not print adapter target id on the attachment line, now that scsibus(4)
prints it. These should be the last offenders.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.23 2008/06/26 05:42:14 ray Exp $ */
d107 1
a107 1
static	void si_minphys(struct buf *);
d274 1
a274 2
si_minphys(bp)
	struct buf *bp;
d278 1
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.22 2007/12/29 03:04:19 dlg Exp $ */
d176 2
a244 2

	printf(": SCSI ID %d\n", target);
@


1.22
log
@fix comments after the members of scsi_adapter were changed.

prompted by krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.21 2006/12/13 21:12:58 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	  This product includes software developed by the NetBSD
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@Remove the dma_eop callback in the ncr5380 driver md attachment, it was always
doing nothing and the mi code does not use it anymore anyway. No functional
change.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.20 2006/11/28 23:59:45 dlg Exp $ */
d130 4
a133 4
	ncr5380_scsi_cmd,       /* scsi_cmd()       */
	si_minphys,         /* scsi_minphys()   */
	NULL,               /* open_target_lu() */
	NULL,               /* close_target_lu()    */
@


1.20
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.19 2006/11/05 14:40:33 miod Exp $ */
a120 1
static	void si_dma_eop(struct ncr5380_softc *);
a210 1
	ncr_sc->sc_dma_eop   = si_dma_eop;
a440 10
}

/*
 * When?
 */
void
si_dma_eop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	printf("si_dma_eop\n");
@


1.19
log
@Wait two seconds after reset before probing devices, lets RX23 get detected
again.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.18 2006/07/19 20:22:38 miod Exp $ */
d181 1
d266 3
d275 1
a275 1
	config_found(&(ncr_sc->sc_dev), &(ncr_sc->sc_link), scsiprint);
@


1.18
log
@Remove long dead meat and irrelevant defines. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.17 2006/07/12 18:09:56 miod Exp $ */
d270 1
@


1.17
log
@Shorten the dmesg one line.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.16 2005/11/12 03:44:24 pedro Exp $ */
a150 2

extern struct cfdriver sd_cd;
@


1.16
log
@Make sure we only touch associated processes of physical buffers.
Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.15 2005/08/24 21:01:35 deraadt Exp $ */
d254 1
a254 1
	printf("\n%s: NCR5380, SCSI ID %d\n", ncr_sc->sc_dev.dv_xname, target);
@


1.15
log
@some scsi xs transactions can come in without a buffer pointer obviously; tested by unpronounceable
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.14 2004/07/07 23:10:46 deraadt Exp $ */
d295 1
d328 3
a330 2
	if (xs->bp)
		dh->dh_proc = xs->bp->b_proc;
@


1.14
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.13 2002/06/12 12:29:15 hugh Exp $ */
d327 4
a330 1
	dh->dh_proc = xs->bp->b_proc;
@


1.13
log
@No longer need these getdev routines.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.12 2001/11/06 19:53:17 miod Exp $ */
d93 2
a94 1
	struct	evcnt		ncr_intrcnt;
d188 3
a190 1
	evcnt_attach(self, "intr", &sc->ncr_intrcnt);
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.11 2001/09/11 20:05:25 miod Exp $ */
a483 24

int 
sd_getdev (adaptor, controller, part, unit, uname) 
	int adaptor, controller, part, unit;
	char **uname;
{
	struct sd_softc *sd;
	struct scsi_link *sl;
	int i;

	for (i = 0; i < sd_cd.cd_ndevs; i++) {
		if ((sd = sd_cd.cd_devs[i]) == 0)
			continue;

		sl = sd->sc_link;
		if (sl->target == unit && sl->scsibus == adaptor && 
			sl->lun == part) {
			*uname = sd->sc_dev.dv_xname;
			return i;
		}
	}
	return -1;
}

@


1.12.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.12 2001/11/06 19:53:17 miod Exp $ */
d484 24
@


1.11
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.10 2001/08/25 13:33:37 hugh Exp $ */
d63 1
a63 1
#include <vm/vm.h>
@


1.10
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.9 2001/02/15 13:15:03 hugh Exp $ */
a63 1
#include <vm/vm_kern.h>
@


1.9
log
@Pick up a two liner from netbsd to set offset for SCSI chain B properly.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.8 2001/02/11 06:34:38 hugh Exp $ */
d94 1
d112 12
a123 12
static	int si_match __P((struct device *, void *, void *));
static	void si_attach __P((struct device *, struct device *, void *));
static	void si_minphys __P((struct buf *));

static	void si_dma_alloc __P((struct ncr5380_softc *));
static	void si_dma_free __P((struct ncr5380_softc *));
static	void si_dma_setup __P((struct ncr5380_softc *));
static	void si_dma_start __P((struct ncr5380_softc *));
static	void si_dma_poll __P((struct ncr5380_softc *));
static	void si_dma_eop __P((struct ncr5380_softc *));
static	void si_dma_stop __P((struct ncr5380_softc *));
static	void si_dma_go __P((void *));
d186 3
a188 1
	scb_vecalloc(va->va_cvec, (void (*)(void *)) ncr5380_intr, sc, SCB_ISTACK);
@


1.8
log
@Pick up a NetBSD hack to attach Cheetah to vsbus as well as ibus.
High kludge factor, but the payoff is vsbus scsi for free.
Most of the work is by Michael Kukat and ragge, with a few other
synchronisations thrown in.
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.7 2000/10/11 06:19:19 bjc Exp $ */
d392 1
a392 1
			    sc->ncr_addr, dh->dh_len);
d468 2
a469 1
			vsbus_copytoproc(dh->dh_proc, sc->ncr_addr,
@


1.7
log
@update these to work with cleaner vsbus dma; from netbsd
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d163 1
a163 1
	    || vax_boardtype == VAX_BTYP_48)
a179 1
	struct vsbus_softc *vsc = (struct vsbus_softc *)parent;
a185 1
	vsc->sc_mask |= 1 << (va->va_maskno-1);	
@


1.6
log
@initialize sc_link.openings to it's (currently) default value of 4
@
text
@d1 2
a2 1
/*	$NetBSD: ncr.c,v 1.26 2000/03/25 15:27:57 tsutsui Exp $	*/
a43 3
 * Note: Only PIO transfers for now which implicates very bad
 * performance. DMA support will come soon.
 *
d79 1
d105 2
d109 2
d122 1
d162 2
a163 1
	if (vax_boardtype == VAX_BTYP_49)
d183 1
a183 2

	printf("\n");
d195 3
a197 23
	if (vax_boardtype != VAX_BTYP_410) {
		if (va->va_paddr & 0x100) /* Magic */
			sc->ncr_off = DMASIZE;
		sc->ncr_addr = (caddr_t)uvm_km_valloc(kernel_map, DMASIZE);
		
		ioaccess((vaddr_t)sc->ncr_addr,
		    0x202d0000 + sc->ncr_off, DMASIZE/VAX_NBPG);

		/*
		 * MD function pointers used by the MI code.
		 */
		ncr_sc->sc_dma_alloc = si_dma_alloc;
		ncr_sc->sc_dma_free  = si_dma_free;
		ncr_sc->sc_dma_setup = si_dma_setup;
		ncr_sc->sc_dma_start = si_dma_start;
		ncr_sc->sc_dma_poll  = si_dma_poll;
		ncr_sc->sc_dma_eop   = si_dma_eop;
		ncr_sc->sc_dma_stop  = si_dma_stop;

		/* DMA control register offsets */
		sc->ncr_dmaaddr = 32;	/* DMA address in buffer, longword */
		sc->ncr_dmacount = 64;	/* DMA count register */
		sc->ncr_dmadir = 68;	/* Direction of DMA transfer */
d199 19
d230 1
a230 1
	ncr_sc->sci_r0 = (void *)sc->sc_regh;
d241 12
d254 1
a254 1
	ncr_sc->sc_link.adapter_target = 7;
d260 5
d270 1
d280 2
a281 4
	if ((vax_boardtype == VAX_BTYP_410) && (bp->b_bcount > (16*1024)))
		bp->b_bcount = (16*1024);
	else if (bp->b_bcount > MAXPHYS)
		bp->b_bcount = MAXPHYS;
d307 1
a307 1
		panic("si_dma_alloc: len=0x%x\n", xlen);
d318 1
a318 1
	panic("sbc: no free PDMA handles");
d340 8
d368 17
d393 1
a393 4
		if ((vaddr_t)dh->dh_addr & KERNBASE)
			bcopy(dh->dh_addr, sc->ncr_addr, dh->dh_len);
		else
			vsbus_copyfromproc(dh->dh_proc, dh->dh_addr,
d470 2
a471 6
			if ((vaddr_t)dh->dh_addr & KERNBASE)
				bcopy(sc->ncr_addr, dh->dh_addr, dh->dh_len);
			else
				vsbus_copytoproc(dh->dh_proc, sc->ncr_addr,
				    dh->dh_addr, dh->dh_len);

d480 2
@


1.5
log
@sync with netbsd; working ncr5380 driver, saner vsbus code
@
text
@d242 1
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 2
/*	$OpenBSD: ncr.c,v 1.3 1997/09/10 12:08:37 maja Exp $	*/
/*	$NetBSD: ncr.c,v 1.8 1997/02/26 22:29:12 gwr Exp $	*/
d3 2
a4 8
/* #define DEBUG	/* */
/* #define TRACE	/* */
/* #define POLL_MODE	/* */
#define USE_VMAPBUF

/*
 * Copyright (c) 1995 David Jones, Gordon W. Ross
 * Copyright (c) 1994 Adam Glass
d7 3
d18 1
a18 3
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
d20 17
a36 13
 *	This product includes software developed by
 *	Adam Glass, David Jones, and Gordon Ross
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d40 12
a51 39
 * This file contains only the machine-dependent parts of the
 * Sun3 SCSI driver.  (Autoconfig stuff and DMA functions.)
 * The machine-independent parts are in ncr5380sbc.c
 *
 * Supported hardware includes:
 * Sun SCSI-3 on OBIO (Sun3/50,Sun3/60)
 * Sun SCSI-3 on VME (Sun3/160,Sun3/260)
 *
 * Could be made to support the Sun3/E if someone wanted to.
 *
 * Note:  Both supported variants of the Sun SCSI-3 adapter have
 * some really unusual "features" for this driver to deal with,
 * generally related to the DMA engine.	 The OBIO variant will
 * ignore any attempt to write the FIFO count register while the
 * SCSI bus is in DATA_IN or DATA_OUT phase.  This is dealt with
 * by setting the FIFO count early in COMMAND or MSG_IN phase.
 *
 * The VME variant has a bit to enable or disable the DMA engine,
 * but that bit also gates the interrupt line from the NCR5380!
 * Therefore, in order to get any interrupt from the 5380, (i.e.
 * for reselect) one must clear the DMA engine transfer count and
 * then enable DMA.  This has the further complication that you
 * CAN NOT touch the NCR5380 while the DMA enable bit is set, so
 * we have to turn DMA back off before we even look at the 5380.
 *
 * What wonderfully whacky hardware this is!
 *
 * Credits, history:
 *
 * David Jones wrote the initial version of this module, which
 * included support for the VME adapter only. (no reselection).
 *
 * Gordon Ross added support for the OBIO adapter, and re-worked
 * both the VME and OBIO code to support disconnect/reselect.
 * (Required figuring out the hardware "features" noted above.)
 *
 * The autoconfiguration boilerplate came from Adam Glass.
 *
 * VS2000:
d56 1
d58 2
a59 4
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h> 
#include <sys/ioctl.h>
d61 1
a63 6
#include <sys/map.h>
#include <sys/device.h>
#include <sys/dkstat.h> 
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>
d65 2
a66 1
/* #include <sys/errno.h> */
d71 1
a71 5

#include <machine/uvax.h>
#include <machine/ka410.h>
#include <machine/ka43.h>
#include <machine/vsbus.h>	/* struct confargs */
d76 5
a80 14
#define trace(x)
#define debug(x)

#ifndef NCR5380_CSRBITS
#define NCR5380_CSRBITS \
	"\020\010DEND\007DREQ\006PERR\005IREQ\004MTCH\003DCON\002ATN\001ACK"
#endif

#ifndef NCR5380_BUSCSRBITS
#define NCR5380_BUSCSRBITS \
	"\020\010RST\007BSY\006REQ\005MSG\004C/D\003I/O\002SEL\001DBP"
#endif

#include "ncr.h"
d82 1
a82 5
#ifdef DDB
#define integrate
#else
#define integrate static
#endif
a83 35
/*
 * Transfers smaller than this are done using PIO
 * (on assumption they're not worth DMA overhead)
 */
#define MIN_DMA_LEN 128 

/*
 * Transfers lager than 65535 bytes need to be split-up.
 * (Some of the FIFO logic has only 16 bits counters.)
 * Make the size an integer multiple of the page size
 * to avoid buf/cluster remap problems.	 (paranoid?)
 *
 * bertram: VS2000 has an DMA-area which is 16KB, thus
 * have a maximum DMA-size of 16KB...
 */
#ifdef DMA_SHARED
#define MAX_DMA_LEN	0x2000		/* (8 * 1024) */
#define DMA_ADDR_HBYTE	0x20
#define DMA_ADDR_LBYTE	0x00
#else
#define MAX_DMA_LEN	0x4000		/* (16 * 1024) */
#define DMA_ADDR_HBYTE	0x00
#define DMA_ADDR_LBYTE	0x00
#endif

#ifdef	DEBUG
int si_debug = 3;
static int si_link_flags = 0 /* | SDEV_DB2 */ ;
#endif

/*
 * This structure is used to keep track of mappedpwd DMA requests.
 * Note: combined the UDC command block with this structure, so
 * the array of these has to be in DVMA space.
 */
d85 6
a90 9
	int		dh_flags;
#define SIDH_BUSY	1		/* This DH is in use */
#define SIDH_OUT	2		/* DMA does data out (write) */
#define SIDH_PHYS	4
#define SIDH_DONE	8
	u_char *	dh_addr;	/* KVA of start of buffer */
	int		dh_maplen;	/* Length of KVA mapping. */
	u_char *	dh_dvma;	/* VA of buffer in DVMA space */
	int		dh_xlen;
a92 4
/*
 * The first structure member has to be the ncr5380_softc
 * so we can just cast to go back and fourth between them.
 */
d94 10
a103 2
	struct ncr5380_softc	ncr_sc;
	volatile struct si_regs *sc_regs;	/* do we really need this? */
d105 2
a106 2
	struct si_dma_handle	*sc_dma;
	struct confargs		*sc_cfargs;	
d108 22
a129 28
	int	sc_xflags;	/* ka410/ka43: resid, sizeof(areg) */

	char	*sc_dbase;
	int	sc_dsize;
	
	volatile char	*sc_dareg;
	volatile short	*sc_dcreg;
	volatile char	*sc_ddreg;
	volatile int	sc_dflags;
	
#define VSDMA_LOCKED	0x80	/* */
#define VSDMA_WANTED	0x40	/* */
#define VSDMA_IWANTED	0x20
#define VSDMA_BLOCKED	0x10
#define VSDMA_DMABUSY	0x08	/* DMA in progress */
#define VSDMA_REGBUSY	0x04	/* accessing registers */
#define VSDMA_WRBUF	0x02	/* writing to bounce-buffer */
#define VSDMA_RDBUF	0x01	/* reading from bounce-buffer */

#define VSDMA_STATUS	0xF0
#define VSDMA_LCKTYPE	0x0F

#ifdef POLL_MODE
	volatile u_char *intreq;
	volatile u_char *intclr;
	volatile u_char *intmsk;
	volatile int	intbit;
#endif
d132 5
a136 43
extern int cold;	/* enable polling while cold-flag set */

/* Options.  Interesting values are: 1,3,7 */
int si_options = 3;	/* bertram: 3 or 7 ??? */
#define SI_ENABLE_DMA	1	/* Use DMA (maybe polled) */
#define SI_DMA_INTR	2	/* DMA completion interrupts */
#define SI_DO_RESELECT	4	/* Allow disconnect/reselect */

#define DMA_DIR_IN  1
#define DMA_DIR_OUT 0

/* How long to wait for DMA before declaring an error. */
int si_dma_intr_timo = 500;	/* ticks (sec. X 100) */

integrate char si_name[] = "ncr";
integrate int	si_match();
integrate void	si_attach();
integrate int	si_intr __P((void *));

integrate void	si_minphys __P((struct buf *bp));
integrate void	si_reset_adapter __P((struct ncr5380_softc *sc));

void si_dma_alloc __P((struct ncr5380_softc *));
void si_dma_free __P((struct ncr5380_softc *));
void si_dma_poll __P((struct ncr5380_softc *));

void si_intr_on __P((struct ncr5380_softc *));
void si_intr_off __P((struct ncr5380_softc *));

int si_dmaLockBus __P((struct ncr5380_softc *, int));
int si_dmaToggleLock __P((struct ncr5380_softc *, int, int));
int si_dmaReleaseBus __P((struct ncr5380_softc *, int));

void si_dma_setup __P((struct ncr5380_softc *));
void si_dma_start __P((struct ncr5380_softc *));
void si_dma_eop __P((struct ncr5380_softc *));
void si_dma_stop __P((struct ncr5380_softc *));

static struct scsi_adapter	si_ops = {
	ncr5380_scsi_cmd,		/* scsi_cmd()		*/
	si_minphys,			/* scsi_minphys()	*/
	NULL,				/* open_target_lu()	*/
	NULL,				/* close_target_lu()	*/
d139 2
a140 7
/* This is copied from julian's bt driver */
/* "so we have a default dev struct for our link struct." */
static struct scsi_device si_dev = {
	NULL,		/* Use default error handler.	    */
	NULL,		/* Use default start handler.		*/
	NULL,		/* Use default async handler.	    */
	NULL,		/* Use default "done" routine.	    */
a142 1

d144 1
a144 4
	NULL, si_name, DV_DULL
};
struct cfattach ncr_ca = {
	sizeof(struct si_softc), si_match, si_attach,
d147 1
a147 9
void
dk_establish(p,q)
	struct disk *p;
	struct device *q;
{
#if 0
	printf ("faking dk_establish()...\n");
#endif
}
d149 18
a166 20

integrate int
si_match(parent, match, aux)
	struct device	*parent;
	void		*match, *aux;
{
	struct cfdata	*cf = match;
	struct confargs *ca = aux;

	trace(("ncr_match(0x%x, %d, %s)\n", parent, cf->cf_unit, ca->ca_name));

	if (strcmp(ca->ca_name, "ncr") &&
	    strcmp(ca->ca_name, "ncr5380") &&
	    strcmp(ca->ca_name, "NCR5380"))
		return (0);

	/*
	 * we just define it being there ...
	 */
	return (1);
d169 1
a169 35
integrate void
si_set_portid(pid,port)
	int pid;
	int port;
{
	struct {
	  u_long    :2;
	  u_long id0:3;
	  u_long id1:3;
	  u_long    :26;
	} *p;

#ifdef DEBUG
	int *ip;
	ip = (void*)uvax_phys2virt(KA410_SCSIPORT);
	p = (void*)uvax_phys2virt(KA410_SCSIPORT);
	printf("scsi-id: (%x/%d) %d / %d\n", *ip, *ip, p->id0, p->id1);
#endif

	p = (void*)uvax_phys2virt(KA410_SCSIPORT);
	switch (port) {
	case 0:
		p->id0 = pid;
		printf(": scsi-id %d\n", p->id0);
		break;
	case 1:
		p->id1 = pid;
		printf(": scsi-id %d\n", p->id1);
		break;
	default:
		printf("invalid port-number %d\n", port);
	}
}

integrate void
d174 2
d177 1
a177 5
	struct ncr5380_softc *ncr_sc = (struct ncr5380_softc *)sc;
	volatile struct si_regs *regs;
	struct confargs *ca = aux;
	int i;
	int *ip = aux;;
d179 1
a179 1
	trace (("ncr_attach(0x%x, 0x%x, %s)\n", parent, self, ca->ca_name));
d181 17
a197 9
	/*
	 *
	 */
#ifdef POLL_MODE
	sc->intreq = (void*)uvax_phys2virt(KA410_INTREQ);
	sc->intmsk = (void*)uvax_phys2virt(KA410_INTMSK);
	sc->intclr = (void*)uvax_phys2virt(KA410_INTCLR);
	sc->intbit = ca->ca_intbit;
#endif
d199 18
a216 1
	sc->sc_cfargs = ca;	/* needed for interrupt-setup */
d218 1
a218 1
	regs = (void*)uvax_phys2virt(ca->ca_ioaddr);
a219 7
	sc->sc_dareg = (void*)uvax_phys2virt(ca->ca_dareg);
	sc->sc_dcreg = (void*)uvax_phys2virt(ca->ca_dcreg);
	sc->sc_ddreg = (void*)uvax_phys2virt(ca->ca_ddreg);
	sc->sc_dbase = (void*)uvax_phys2virt(ca->ca_dbase);
	sc->sc_dsize = ca->ca_dsize;
	sc->sc_dflags = 4;	/* XXX */
	sc->sc_xflags = ca->ca_dflag;	/* should/will be renamed */
d221 1
a221 1
	 * Fill in the prototype scsi_link.
d223 2
a224 7
#ifndef __OpenBSD__
	ncr_sc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;
#endif
	ncr_sc->sc_link.adapter_softc = sc;
	ncr_sc->sc_link.adapter_target = ca->ca_idval;
	ncr_sc->sc_link.adapter = &si_ops;
	ncr_sc->sc_link.device = &si_dev;
d226 9
a234 1
	si_set_portid(ca->ca_idval, ncr_sc->sc_dev.dv_unit);
d236 1
a236 11
	/*
	 * Initialize fields used by the MI code
	 */
	ncr_sc->sci_r0 = (void*)&regs->sci.sci_r0;
	ncr_sc->sci_r1 = (void*)&regs->sci.sci_r1;
	ncr_sc->sci_r2 = (void*)&regs->sci.sci_r2;
	ncr_sc->sci_r3 = (void*)&regs->sci.sci_r3;
	ncr_sc->sci_r4 = (void*)&regs->sci.sci_r4;
	ncr_sc->sci_r5 = (void*)&regs->sci.sci_r5;
	ncr_sc->sci_r6 = (void*)&regs->sci.sci_r6;
	ncr_sc->sci_r7 = (void*)&regs->sci.sci_r7;
d238 4
a241 24
	/*
	 * MD function pointers used by the MI code.
	 */
	ncr_sc->sc_pio_out = ncr5380_pio_out;
	ncr_sc->sc_pio_in =  ncr5380_pio_in;
	ncr_sc->sc_dma_alloc = si_dma_alloc;
	ncr_sc->sc_dma_free  = si_dma_free;
	ncr_sc->sc_dma_poll  = si_dma_poll;	/* si_dma_poll not used! */
	ncr_sc->sc_intr_on   = si_intr_on;	/* vsbus_unlockDMA; */
	ncr_sc->sc_intr_off  = si_intr_off;	/* vsbus_lockDMA; */

	ncr_sc->sc_dma_setup = NULL;		/* si_dma_setup not used! */
	ncr_sc->sc_dma_start = si_dma_start;
	ncr_sc->sc_dma_eop   = NULL;	
	ncr_sc->sc_dma_stop  = si_dma_stop;

	ncr_sc->sc_flags = 0;
#ifndef __OpenBSD__
	if ((si_options & SI_DO_RESELECT) == 0)
		ncr_sc->sc_no_disconnect = 0xff;
#endif
	if ((si_options & SI_DMA_INTR) == 0)
		ncr_sc->sc_flags |= NCR5380_FORCE_POLLING;
	ncr_sc->sc_min_dma_len = MIN_DMA_LEN;
d244 1
a244 1
	 * Initialize fields used only here in the MD code.
a245 19
	i = SCI_OPENINGS * sizeof(struct si_dma_handle);
	sc->sc_dma = (struct si_dma_handle *) malloc(i);
	if (sc->sc_dma == NULL)
		panic("si: dvma_malloc failed");
	for (i = 0; i < SCI_OPENINGS; i++)
		sc->sc_dma[i].dh_flags = 0;

	sc->sc_regs = regs;
	
#ifdef	DEBUG
	if (si_debug)
		printf("si: Set TheSoftC=%x TheRegs=%x\n", sc, regs);
	ncr_sc->sc_link.flags |= si_link_flags;
#endif

	/*
	 *  Initialize si board itself.
	 */
	si_reset_adapter(ncr_sc);
d248 1
a248 7
	config_found(self, &(ncr_sc->sc_link), scsiprint);

	/* 
	 * Now ready for interrupts. 
	 */
	vsbus_intr_register(sc->sc_cfargs, si_intr, (void *)sc);
	vsbus_intr_enable(sc->sc_cfargs);
d251 6
a256 2
integrate void
si_minphys(struct buf *bp)
d258 4
a261 15
	debug(("minphys: blkno=%d, bcount=%d, data=0x%x, flags=%x\n",
	      bp->b_blkno, bp->b_bcount, bp->b_data, bp->b_flags));

	if (bp->b_bcount > MAX_DMA_LEN) {
#ifdef	DEBUG
		if (si_debug) {
			printf("si_minphys len = 0x%x.\n", bp->b_bcount);
#ifdef DDB
			Debugger();
#endif
		}
#endif
		bp->b_bcount = MAX_DMA_LEN;
	}
	return (minphys(bp));
a263 135

#define CSR_WANT (SI_CSR_SBC_IP | SI_CSR_DMA_IP | \
	SI_CSR_DMA_CONFLICT | SI_CSR_DMA_BUS_ERR )

static int si_intrCount = 0;
static int lastCSR = 0;

integrate int
si_intr(arg)
	void *arg; 
{
	struct ncr5380_softc *ncr_sc = arg;
	struct si_softc *sc = arg;
	int count, claimed;

	count = ++si_intrCount;
	trace(("%s: si-intr(%d).....\n", ncr_sc->sc_dev.dv_xname, count));

#ifdef DEBUG
	/*
	 * Each DMA interrupt is followed by one spurious(?) interrupt.
	 * if (ncr_sc->sc_state & NCR_WORKING == 0) we know, that the
	 * interrupt was not claimed by the higher-level routine, so that
	 * it might be save to ignore these...
	 */
	if ((ncr_sc->sc_state & NCR_DOINGDMA) == 0) {
		printf("spurious(%d): %x, %d, status=%b\n", count,
		       sc->sc_dflags, ncr_sc->sc_ncmds,
		       *ncr_sc->sci_csr, NCR5380_CSRBITS);
	}
#endif
	/*
	 * If there was a DMA operation in progress, now it's no longer
	 * active, since whatever caused the interrupt also interrupted
	 * the DMA operation. Thus accessing the registers now doesn't
	 * harm anything which is not yet broken...
	 */
	debug(("si_intr(status: %x, dma-count: %d)\n", 
	       *ncr_sc->sci_csr, *sc->sc_dcreg));

	/*
	 * First check for DMA errors / incomplete transfers
	 * If operation was read/data-in, the copy data from buffer
	 */
	if (ncr_sc->sc_state & NCR_DOINGDMA) {
		struct sci_req *sr = ncr_sc->sc_current;
		struct si_dma_handle *dh = sr->sr_dma_hand;
		int resid, ntrans;

		resid = *sc->sc_dcreg;
		if (resid == 1 && sc->sc_xflags) {
		  debug(("correcting resid...\n"));
		  resid = 0;
		}
		ntrans = dh->dh_xlen + resid;
		if (resid == 0) {
			if ((dh->dh_flags & SIDH_OUT) == 0) {
				si_dmaToggleLock(ncr_sc,
						 VSDMA_DMABUSY, VSDMA_RDBUF);
				bcopy(sc->sc_dbase, dh->dh_dvma, ntrans);
				si_dmaToggleLock(ncr_sc,
						 VSDMA_RDBUF, VSDMA_DMABUSY);
				dh->dh_flags |= SIDH_DONE;
			}
		}
		else {
#ifdef DEBUG
			int csr = *ncr_sc->sci_csr;
			printf("DMA incomplete (%d/%d) status = %b\n",
			       ntrans, resid, csr, NCR5380_CSRBITS);
			if(csr != lastCSR) {
				int k = (csr & ~lastCSR) | (~csr & lastCSR);
				debug(("Changed status bits: %b\n",
				       k, NCR5380_CSRBITS));
				lastCSR = csr & 0xFF;
			}
#endif
			printf("DMA incomplete: ntrans=%d/%d, lock=%x\n", 
			       ntrans, dh->dh_xlen, sc->sc_dflags);
			ncr_sc->sc_state |= NCR_ABORTING;
		}

		if ((sc->sc_dflags & VSDMA_BLOCKED) == 0) {
			printf("not blocked during DMA.\n");
		}
		sc->sc_dflags &= ~VSDMA_BLOCKED;
		si_dmaReleaseBus(ncr_sc, VSDMA_DMABUSY);
	}
	if ((sc->sc_dflags & VSDMA_BLOCKED) != 0) {
		printf("blocked while not doing DMA.\n");
		sc->sc_dflags &= ~VSDMA_BLOCKED;
	}

	/*
	 * Now, whatever it was, let the ncr5380sbc routine handle it...
	 */
	claimed = ncr5380_intr(ncr_sc);
#ifdef	DEBUG
	if (!claimed) {
		printf("si_intr: spurious from SBC\n");
		if (si_debug & 4) {
			Debugger();	/* XXX */
		}
	}
#endif
	trace(("%s: si-intr(%d) done, claimed=%d\n", 
	       ncr_sc->sc_dev.dv_xname, count, claimed));
	return (claimed);
}


integrate void
si_reset_adapter(struct ncr5380_softc *ncr_sc)
{
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	volatile struct si_regs *si = sc->sc_regs;

#ifdef	DEBUG
	if (si_debug) {
		printf("si_reset_adapter\n");
	}
#endif
	SCI_CLR_INTR(ncr_sc);
}


/*****************************************************************
 * Common functions for DMA
 ****************************************************************/

/*
 * Allocate a DMA handle and put it in sc->sc_dma.  Prepare
 * for DMA transfer.  On the Sun3, this means mapping the buffer
 * into DVMA space.  dvma_mapin() flushes the cache for us.
 */
a270 1
	struct buf *bp = sr->sr_xs->bp;
d272 1
a272 4
	int i, xlen;
	u_long addr;

	trace (("si_dma_alloc()\n"));
d274 1
a274 1
#ifdef	DIAGNOSTIC
d279 4
a282 2
	addr = (u_long) ncr_sc->sc_dataptr;
	debug(("addr=%x, dataptr=%x\n", addr, ncr_sc->sc_dataptr));
d287 1
a287 1
		panic("si_dma_alloc: xlen=0x%x", xlen);
d290 3
a292 4
	 * Never attempt single transfers of more than 63k, because
	 * our count register may be only 16 bits (an OBIO adapter).
	 * This should never happen since already bounded by minphys().
	 * XXX - Should just segment these...
d294 2
a295 12
	if (xlen > MAX_DMA_LEN) {
#ifdef DEBUG
		printf("si_dma_alloc: excessive xlen=0x%x\n", xlen);
		Debugger();
#endif
		ncr_sc->sc_datalen = xlen = MAX_DMA_LEN;
	}

	/* Find free DMA handle.  Guaranteed to find one since we have
	   as many DMA handles as the driver has processes. */
	for (i = 0; i < SCI_OPENINGS; i++) {
		if ((sc->sc_dma[i].dh_flags & SIDH_BUSY) == 0)
d298 1
a298 1
	panic("si: no free DMA handles.");
d300 1
a300 2

	dh = &sc->sc_dma[i];
d302 3
a304 4
	dh->dh_addr = (u_char*) addr;
	dh->dh_maplen  = xlen;
	dh->dh_xlen  = xlen;
	dh->dh_dvma = 0;
d306 1
a306 1
	/* Copy the "write" flag for convenience. */
a309 49
#if 1
	/*
	 * If the buffer has the flag B_PHYS, the the address specified
	 * in the buffer is a user-space address and we need to remap
	 * this address into kernel space so that using this buffer
	 * within the interrupt routine will work.
	 * If it's already a kernel space address, we need to make sure
	 * that all pages are in-core. the mapin() routine takes care
	 * of that.
	 */
	if (bp && (bp->b_flags & B_PHYS))
		dh->dh_flags |= SIDH_PHYS;
#endif
	
	if (!bp) {
		printf("ncr.c: struct buf *bp is null-pointer.\n");
		dh->dh_flags = 0;
		return;
	}
	if (bp->b_bcount < 0 || bp->b_bcount > MAX_DMA_LEN) {
		printf("ncr.c: invalid bcount %d (0x%x)\n", 
		       bp->b_bcount, bp->b_bcount);
		dh->dh_flags = 0;
		return;
	}
	dh->dh_dvma = bp->b_data;
#if 0
	/*
	 * mapping of user-space addresses is no longer neccessary, now
	 * that the vmapbuf/vunmapbuf routines exist. Now the higher-level
	 * driver already cares for the mapping!
	 */
	if (bp->b_flags & B_PHYS) {
		xdebug(("not mapping in... %x/%x %x\n", bp->b_saveaddr, 
			bp->b_data, bp->b_bcount));
#ifdef USE_VMAPBUF
		dh->dh_addr = bp->b_data;
		dh->dh_maplen = bp->b_bcount;
		vmapbuf(bp, bp->b_bcount);
		dh->dh_dvma = bp->b_data;
#else
		dh->dh_dvma = (u_char*)vsdma_mapin(bp);
#endif
		xdebug(("addr %x, maplen %d, dvma %x, bcount %d, dir %s\n", 
		       dh->dh_addr, dh->dh_maplen, dh->dh_dvma, bp->b_bcount,
		       (dh->dh_flags & SIDH_OUT ? "OUT" : "IN")));
	}
#endif
	/* success */
a310 2

	return;
a312 1

a316 1
	struct si_softc *sc = (struct si_softc *)ncr_sc;
a317 2
	struct scsi_xfer *xs = sr->sr_xs;
	struct buf *bp = sr->sr_xs->bp;
d320 1
a320 25
	trace (("si_dma_free()\n"));

#ifdef	DIAGNOSTIC
	if (dh == NULL)
		panic("si_dma_free: no DMA handle");
#endif

	if (ncr_sc->sc_state & NCR_DOINGDMA)
		panic("si_dma_free: free while in progress");

	if (dh->dh_flags & SIDH_BUSY) {
#if 0
		debug(("bp->b_flags=0x%x\n", bp->b_flags));
		if (bp->b_flags & B_PHYS) {
#ifdef USE_VMAPBUF
			printf("not unmapping(%x/%x %x/%x %d/%d)...\n", 
			       dh->dh_addr, dh->dh_dvma,
			       bp->b_saveaddr, bp->b_data,
			       bp->b_bcount, dh->dh_maplen);
			/* vunmapbuf(bp, dh->dh_maplen); */
			printf("done.\n");
#endif
			dh->dh_dvma = 0;
		}
#endif
a321 138
	}
	sr->sr_dma_hand = NULL;
}


/*
 * REGBUSY and DMABUSY won't collide since the higher-level driver
 * issues intr_on/intr_off before/after doing DMA. The only problem
 * is to handle RDBUF/WRBUF wrt REGBUSY/DMABUSY
 *
 * There might be race-conditions, but for now we don't care for them...
 */
int 
si_dmaLockBus(ncr_sc, lt)
	struct ncr5380_softc *ncr_sc;
	int lt;			/* Lock-Type */
{
	struct si_softc *sc = (void*)ncr_sc;
	int timeout = 200;	/* wait .2 seconds max. */

	trace(("si_dmaLockBus(%x), cold: %d, current: %x\n", 
	       lt, cold, sc->sc_dflags));

#ifdef POLL_MODE
	if (cold)
		return (0);
#endif

	if ((ncr_sc->sc_current != NULL) && (lt == VSDMA_REGBUSY)) {
		printf("trying to use regs while sc_current is set.\n");
		printf("lt=%x, fl=%x, cur=%x\n", 
		       lt, sc->sc_dflags, ncr_sc->sc_current);
	}
	if ((ncr_sc->sc_current == NULL) && (lt != VSDMA_REGBUSY)) {
		printf("trying to use/prepare DMA without current.\n");
		printf("lt=%x, fl=%x, cur=%x\n", 
		       lt, sc->sc_dflags, ncr_sc->sc_current);
	}

	if ((sc->sc_dflags & VSDMA_LOCKED) == 0) {
		struct si_softc *sc = (struct si_softc *)ncr_sc;
		sc->sc_dflags |= VSDMA_WANTED;
		vsbus_lockDMA(sc->sc_cfargs);
		sc->sc_dflags = VSDMA_LOCKED | lt;
		return (0);
	}

#if 1
	while ((sc->sc_dflags & VSDMA_LCKTYPE) != lt) {
		debug(("busy wait(1)...\n"));
		if (--timeout == 0) {
			printf("timeout in busy-wait(%x %x)\n",
			       lt, sc->sc_dflags);
			sc->sc_dflags &= ~VSDMA_LCKTYPE;
			break;
		}
		delay(1000);
	}
	debug(("busy wait(1) done.\n"));
	sc->sc_dflags |= lt;

#else
	if ((sc->sc_dflags & VSDMA_LCKTYPE) != lt) {
		switch (lt) {

		case VSDMA_RDBUF:
			/* sc->sc_dflags |= VSDMA_IWANTED; */
			debug(("busy wait(1)...\n"));
			while (sc->sc_dflags & 
			       (VSDMA_WRBUF | VSDMA_DMABUSY)) {
				if (--timeout == 0) {
					printf("timeout in busy-wait(1)\n");
					sc->sc_dflags &= ~VSDMA_WRBUF;
					sc->sc_dflags &= ~VSDMA_DMABUSY;
				}
				delay(1000);
			}
			/* sc->sc_dflags &= ~VSDMA_IWANTED; */
			debug(("busy wait(1) done.\n"));
			sc->sc_dflags |= lt;
			break;

		case VSDMA_WRBUF:
			/* sc->sc_dflags |= VSDMA_IWANTED; */
			debug(("busy wait(2)...\n"));
			while (sc->sc_dflags & 
			       (VSDMA_RDBUF | VSDMA_DMABUSY)) {
				if (--timeout == 0) {
					printf("timeout in busy-wait(2)\n");
					sc->sc_dflags &= ~VSDMA_RDBUF;
					sc->sc_dflags &= ~VSDMA_DMABUSY;
				}
				delay(1000);
			}
			/* sc->sc_dflags &= ~VSDMA_IWANTED; */
			debug(("busy wait(2) done.\n"));
			sc->sc_dflags |= lt;
			break;

		case VSDMA_DMABUSY:
			/* sc->sc_dflags |= VSDMA_IWANTED; */
			debug(("busy wait(3)...\n"));
			while (sc->sc_dflags & 
			       (VSDMA_RDBUF | VSDMA_WRBUF)) {
				if (--timeout == 0) {
					printf("timeout in busy-wait(3)\n");
					sc->sc_dflags &= ~VSDMA_RDBUF;
					sc->sc_dflags &= ~VSDMA_WRBUF;
				}
				delay(1000);
			}
			/* sc->sc_dflags &= ~VSDMA_IWANTED; */
			debug(("busy wait(3) done.\n"));
			sc->sc_dflags |= lt;
			break;

		case VSDMA_REGBUSY:
			/* sc->sc_dflags |= VSDMA_IWANTED; */
			debug(("busy wait(4)...\n"));
			while (sc->sc_dflags & 
			       (VSDMA_RDBUF | VSDMA_WRBUF | VSDMA_DMABUSY)) {
				if (--timeout == 0) {
					printf("timeout in busy-wait(4)\n");
					sc->sc_dflags &= ~VSDMA_RDBUF;
					sc->sc_dflags &= ~VSDMA_WRBUF;
					sc->sc_dflags &= ~VSDMA_DMABUSY;
				}
				delay(1000);
			}
			/* sc->sc_dflags &= ~VSDMA_IWANTED; */
			debug(("busy wait(4) done.\n"));
			sc->sc_dflags |= lt;
			break;

		default:
			printf("illegal lockType %x in si_dmaLockBus()\n");
		}
	}
d323 1
a323 4
		printf("already locked. (%x/%x)\n", lt, sc->sc_dflags);
#endif
	if (sc->sc_dflags & lt) /* successfully locked for this type */
		return (0);
d325 1
a325 1
	printf("spurious %x in si_dmaLockBus(%x)\n", lt, sc->sc_dflags);
a327 108
/*
 * the lock of this type is no longer needed. If all (internal) locks are
 * released, release the DMA bus.
 */
int 
si_dmaReleaseBus(ncr_sc, lt)
	struct ncr5380_softc *ncr_sc;
	int lt;			/* Lock-Type */
{
	struct si_softc *sc = (void*)ncr_sc;

	trace(("si_dmaReleaseBus(%x), cold: %d, current: %x\n", 
	       lt, cold, sc->sc_dflags));

#ifdef POLL_MODE
	if (cold)
		return (0);
#endif

	if ((sc->sc_dflags & VSDMA_LCKTYPE) == lt) {
		sc->sc_dflags &= ~lt;
	}
	else
		printf("trying to release %x while flags = %x\n", lt,
		       sc->sc_dflags);

	if (sc->sc_dflags == VSDMA_LOCKED) {	/* no longer needed */
		struct si_softc *sc = (struct si_softc *)ncr_sc;
		vsbus_unlockDMA(sc->sc_cfargs);
		sc->sc_dflags = 0;
		return (0);
	}
}

/*
 * Just toggle the type of lock without releasing the lock...
 * This is usually needed before/after bcopy() to/from DMA-buffer
 */
int 
si_dmaToggleLock(ncr_sc, lt1, lt2)
	struct ncr5380_softc *ncr_sc;
	int lt1, lt2;		/* Lock-Type */
{
	struct si_softc *sc = (void*)ncr_sc;

#ifdef POLL_MODE
	if (cold)
		return (0);
#endif

	if (((sc->sc_dflags & lt1) != 0) &&
	    ((sc->sc_dflags & lt2) == 0)) {
		sc->sc_dflags |= lt2;
		sc->sc_dflags &= ~lt1;
		return (0);
	}
	printf("cannot toggle locking from %x to %x (current = %x)\n",
	       lt1, lt2, sc->sc_dflags);
}

/*
 * This is called when the bus is going idle,
 * so we want to enable the SBC interrupts.
 * That is controlled by the DMA enable!
 * Who would have guessed!
 * What a NASTY trick!
 */
void
si_intr_on(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	si_dmaReleaseBus(ncr_sc, VSDMA_REGBUSY);
}

/*
 * This is called when the bus is idle and we are
 * about to start playing with the SBC chip.
 *
 * VS2000 note: we have four kinds of access which are mutually exclusive: 
 * - access to the NCR5380 registers
 * - access to the HDC9224 registers
 * - access to the DMA area 
 * - doing DMA
 */
void
si_intr_off(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	si_dmaLockBus(ncr_sc, VSDMA_REGBUSY);
}

/*****************************************************************
 * VME functions for DMA
 ****************************************************************/


/*
 * This function is called during the COMMAND or MSG_IN phase
 * that preceeds a DATA_IN or DATA_OUT phase, in case we need
 * to setup the DMA engine before the bus enters a DATA phase.
 *
 * XXX: The VME adapter appears to suppress SBC interrupts
 * when the FIFO is not empty or the FIFO count is non-zero!
 *
 * On the VME version we just clear the DMA count and address
 * here (to make sure it stays idle) and do the real setup
 * later, in dma_start.
 */
d332 1
a332 5
	trace (("si_dma_setup(ncr_sc) !!!\n"));

	/*
	 * VS2000: nothing to do ...
	 */
a334 1

a341 15
	volatile struct si_regs *si = sc->sc_regs;
	long data_pa;
	int xlen;

	trace(("si_dma_start(%x)\n", sr->sr_dma_hand));

	/*
	 * we always transfer from/to base of DMA-area,
	 * thus the DMA-address is always the same, only size
	 * and direction matter/differ on VS2000
	 */

	debug(("ncr_sc->sc_datalen = %d\n", ncr_sc->sc_datalen));
	xlen = ncr_sc->sc_datalen;
	dh->dh_xlen = xlen;
d344 2
a345 4
	 * VS2000 has a fixed 16KB-area where DMA is restricted to. 
	 * All DMA-addresses are relative to this base: KA410_DMA_BASE
	 * Thus we need to copy the data into this area when writing,
	 * or copy from this area when reading. (kind of bounce-buffer)
a346 2

	/* Set direction (send/recv) */
d348 10
a357 35
		/*
		 * We know that we are called while intr_off (regs locked)
		 * thus we toggle the lock from REGBUSY to WRBUF
		 * also we set the BLOCKIT flag, so that the locking of
		 * the DMA bus won't be released to the HDC9224...
		 */
		debug(("preparing msg-out (bcopy)\n"));
		si_dmaToggleLock(ncr_sc, VSDMA_REGBUSY, VSDMA_WRBUF);
		bcopy(dh->dh_dvma, sc->sc_dbase, xlen);
		si_dmaToggleLock(ncr_sc, VSDMA_WRBUF, VSDMA_REGBUSY);
		*sc->sc_ddreg = DMA_DIR_OUT;
	} 
	else {
		debug(("preparing data-in (bzero)\n"));
		/* bzero(sc->sc_dbase, xlen); */
		*sc->sc_ddreg = DMA_DIR_IN;
	}
	sc->sc_dflags |= VSDMA_BLOCKED;

	*sc->sc_dareg = DMA_ADDR_HBYTE; /* high byte (6 bits) */
	*sc->sc_dareg = DMA_ADDR_LBYTE; /* low byte */
	*sc->sc_dcreg = 0 - xlen; /* bertram XXX */

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: dh=0x%x, pa=0x%x, xlen=%d, creg=0x%x\n",
			   dh, data_pa, xlen, *sc->sc_dcreg);
	}
#endif

#ifdef POLL_MODE
	debug(("dma_start: cold=%d\n", cold));
	if (cold) {
		*sc->intmsk &= ~sc->intbit;
		*sc->intclr = sc->intbit;
d359 4
a362 3
	else
		*sc->intmsk |= sc->intbit;
#endif
d364 1
a364 2
	 * Acknowledge the phase change.  (After DMA setup!)
	 * Put the SBIC into DMA mode, and start the transfer.
a365 1
	si_dmaToggleLock(ncr_sc, VSDMA_REGBUSY, VSDMA_DMABUSY);
d367 5
a371 5
		*ncr_sc->sci_tcmd = PHASE_DATA_OUT;
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_icmd = SCI_ICMD_DATA;
		*ncr_sc->sci_mode |= (SCI_MODE_DMA | SCI_MODE_DMA_IE);
		*ncr_sc->sci_dma_send = 0;	/* start it */
d373 5
a377 5
		*ncr_sc->sci_tcmd = PHASE_DATA_IN;
		SCI_CLR_INTR(ncr_sc);
		*ncr_sc->sci_icmd = 0;
		*ncr_sc->sci_mode |= (SCI_MODE_DMA | SCI_MODE_DMA_IE);
		*ncr_sc->sci_irecv = 0; /* start it */
a379 21
	/*
	 * having a delay (eg. printf) here, seems to solve the problem.
	 * Isn't that strange ????
	 * Maybe the higher-level driver accesses one of the registers of
	 * the controller while DMA is in progress. Having a long enough
	 * delay here might prevent/delay this access until DMA bus is
	 * free again...
	 *
	 * The instruction ++++ printf("DMA started.\n"); ++++ 
	 * is long/slow enough, to make the SSCI driver work. Thus we
	 * try to find a delay() long/slow enough to do the same. The
	 * argument to this delay is relative to the transfer-count.
	 */
	delay(3*xlen/4);		/* XXX solve this problem!!! XXX */

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_start: started, flags=0x%x\n",
			   ncr_sc->sc_state);
	}
#endif
d382 3
a384 1

d386 1
a386 1
si_vme_dma_eop(ncr_sc)
d389 1
a389 2
	trace (("si_vme_dma_eop() !!!\n"));
	/* Not needed - DMA was stopped prior to examining sci_csr */
d393 1
a393 2
 * si_dma_stop() has now become almost a nop-routine, since DMA-buffer
 * has already been read within si_intr(), so there's nothing left to do.
d396 7
d409 1
a409 2
	volatile struct si_regs *si = sc->sc_regs;
	int resid, ntrans;
d411 2
a412 13
	if ((ncr_sc->sc_state & NCR_DOINGDMA) == 0) {
#ifdef	DEBUG
		printf("si_dma_stop: dma not running\n");
#endif
		return;
	}
	ncr_sc->sc_state &= ~NCR_DOINGDMA;

	/* Note that timeout may have set the error flag. */
	if (ncr_sc->sc_state & NCR_ABORTING) {
		printf("si_dma_stop: timeout?\n");
		goto out;
	}
d415 3
a417 1
	 * Now try to figure out how much actually transferred
d419 6
a424 18
	si_dmaLockBus(ncr_sc, VSDMA_DMABUSY);
	si_dmaToggleLock(ncr_sc, VSDMA_DMABUSY, VSDMA_REGBUSY);
	resid = *sc->sc_dcreg;
	/* 
	 * XXX: don't correct at two places !!! 
	 */
	if (resid == 1 && sc->sc_xflags) {	
		resid = 0;
	}
	ntrans = dh->dh_xlen + resid;
	if (resid != 0) 
		printf("resid=%d, xlen=%d, ntrans=%d\n", 
		       resid, dh->dh_xlen, ntrans);

#ifdef	DEBUG
	if (si_debug & 2) {
		printf("si_dma_stop: resid=0x%x ntrans=0x%x\n",
		       resid, ntrans);
d426 7
a432 1
#endif
d434 3
a436 18
	if (ntrans < MIN_DMA_LEN) {
		printf("si: fifo count: 0x%x\n", resid);
		ncr_sc->sc_state |= NCR_ABORTING;
		goto out;
	}
	if (ntrans > ncr_sc->sc_datalen)
		panic("si_dma_stop: excess transfer");

	/*
	 * On VS2000 in case of a READ-operation, we must now copy 
	 * the buffer-contents to the destination-address!
	 */
	if ((dh->dh_flags & SIDH_OUT) == 0 &&
	    (dh->dh_flags & SIDH_DONE) == 0) {
		printf("DMA buffer not yet copied.\n");
		si_dmaToggleLock(ncr_sc, VSDMA_REGBUSY, VSDMA_RDBUF);
		bcopy(sc->sc_dbase, dh->dh_dvma, ntrans);
		si_dmaToggleLock(ncr_sc, VSDMA_RDBUF, VSDMA_REGBUSY);
a437 8
	si_dmaReleaseBus(ncr_sc, VSDMA_REGBUSY);

	/* Adjust data pointer */
	ncr_sc->sc_dataptr += ntrans;
	ncr_sc->sc_datalen -= ntrans;

out:
	si_dmaLockBus(ncr_sc, VSDMA_DMABUSY);
d439 3
a441 5
	/* Put SBIC back in PIO mode. */
	*ncr_sc->sci_mode &= ~(SCI_MODE_DMA | SCI_MODE_DMA_IE);
	*ncr_sc->sci_icmd = 0;

	si_dmaReleaseBus(ncr_sc, VSDMA_DMABUSY);
d444 4
a447 8
/*
 * Poll (spin-wait) for DMA completion.
 * Called right after xx_dma_start(), and
 * xx_dma_stop() will be called next.
 */
void
si_dma_poll(ncr_sc)
	struct ncr5380_softc *ncr_sc;
d449 3
a451 4
	struct si_softc *sc = (struct si_softc *)ncr_sc;
	struct sci_req *sr = ncr_sc->sc_current;
	struct si_dma_handle *dh = sr->sr_dma_hand;
	int i, timeout;
d453 10
a462 23
	if (! cold) 
		printf("spurious call of DMA-poll ???");

#ifdef POLL_MODE

	delay(10000);
	trace(("si_dma_poll(%x)\n", *sc->sc_dcreg));

	/*
	 * interrupt-request has been cleared by dma_start, thus
	 * we do nothing else but wait for the intreq to reappear...
	 */

	timeout = 5000;
	for (i=0; i<timeout; i++) {
		if (*sc->intreq & sc->intbit)
			break;
		delay(100);
	}
	if ((*sc->intreq & sc->intbit) == 0) {
		printf("si: DMA timeout (while polling)\n");
		/* Indicate timeout as MI code would. */
		sr->sr_flags |= SR_OVERDUE;
d464 1
a464 2
#endif
	return;
d466 1
@


1.4.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/* $OpenBSD: ncr.c,v 1.9 2001/02/15 13:15:03 hugh Exp $ */
/*	$NetBSD: ncr.c,v 1.32 2000/06/25 16:00:43 ragge Exp $	*/
d4 8
a11 2
/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
a13 3
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass, David Jones, Gordon W. Ross, and Jens A. Nilsson.
 *
d22 3
a24 1
 * 3. All advertising materials mentioning features or use of this software
d26 13
a38 17
 *	  This product includes software developed by the NetBSD
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d42 39
a80 9
 * This file contains the machine-dependent parts of the NCR-5380
 * controller. The machine-independent parts are in ncr5380sbc.c.
 *
 * Jens A. Nilsson.
 *
 * Credits:
 * 
 * This code is based on arch/sun3/dev/si*
 * Written by David Jones, Gordon Ross, and Adam Glass.
a84 1
#include <sys/errno.h>
d86 4
a89 2
#include <sys/malloc.h>
#include <sys/device.h>
a90 1
#include <sys/disk.h>
d93 6
d100 1
a100 2
#include <vm/vm.h>
#include <vm/vm_kern.h>
d105 5
a109 1
#include <scsi/sdvar.h>
d114 2
a115 6
#include <machine/cpu.h>
#include <machine/vsbus.h>
#include <machine/bus.h>
#include <machine/sid.h>
#include <machine/scb.h>
#include <machine/clock.h>
d117 4
a120 1
#define MIN_DMA_LEN 128
d122 48
d171 9
a179 6
	int	dh_flags;
#define SIDH_BUSY	1
#define SIDH_OUT	2
	caddr_t dh_addr;
	int	dh_len;
	struct	proc *dh_proc;
d182 4
d187 34
a220 14
	struct	ncr5380_softc	ncr_sc;
	caddr_t ncr_addr;
	int	ncr_off;
	int	ncr_dmaaddr;
	int	ncr_dmacount;
	int	ncr_dmadir;

	/* Pointers to bus_space */
	bus_space_tag_t     sc_regt;
	bus_space_handle_t  sc_regh;

	struct	si_dma_handle ncr_dma[SCI_OPENINGS];
	struct	vsbus_dma sc_vd;
	int	onlyscsi;	/* This machine needs no queueing */
d223 1
a223 1
static int ncr_dmasize;
d225 41
a265 23
static	int si_match __P((struct device *, void *, void *));
static	void si_attach __P((struct device *, struct device *, void *));
static	void si_minphys __P((struct buf *));

static	void si_dma_alloc __P((struct ncr5380_softc *));
static	void si_dma_free __P((struct ncr5380_softc *));
static	void si_dma_setup __P((struct ncr5380_softc *));
static	void si_dma_start __P((struct ncr5380_softc *));
static	void si_dma_poll __P((struct ncr5380_softc *));
static	void si_dma_eop __P((struct ncr5380_softc *));
static	void si_dma_stop __P((struct ncr5380_softc *));
static	void si_dma_go __P((void *));

#define NCR5380_READ(sc, reg)	bus_space_read_1(sc->sc_regt,		\
	0, sc->ncr_sc.reg)
#define NCR5380_WRITE(sc, reg, val)	bus_space_write_1(sc->sc_regt,	\
	0, sc->ncr_sc.reg, val)

struct scsi_adapter	si_ops = {
	ncr5380_scsi_cmd,       /* scsi_cmd()       */
	si_minphys,         /* scsi_minphys()   */
	NULL,               /* open_target_lu() */
	NULL,               /* close_target_lu()    */
d268 7
a274 5
struct scsi_device	si_dev = {
	NULL,		/* use default error handler */
	NULL,		/* no start function */
	NULL,		/* no async handler */
	NULL		/* use default done routine */
d277 4
d282 1
a282 1
	sizeof(struct si_softc), si_match, si_attach
d285 20
a304 3
struct cfdriver ncr_cd = {
	NULL, "ncr", DV_DULL
};
d306 4
a309 1
extern struct cfdriver sd_cd;
d311 4
a314 19
static int
si_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct vsbus_attach_args *va = aux;
	volatile char *si_csr = (char *) va->va_addr;

	if (vax_boardtype == VAX_BTYP_49 || vax_boardtype == VAX_BTYP_46
	    || vax_boardtype == VAX_BTYP_48 || vax_boardtype == VAX_BTYP_1303)
		return 0;
	/* This is the way Linux autoprobes the interrupt MK-990321 */
	si_csr[12] = 0;
	si_csr[16] = 0x80;
	si_csr[0] = 0x80;
	si_csr[4] = 5; /* 0xcf */
	DELAY(100000);
	return 1;
d317 35
a351 1
static void
a355 1
	struct vsbus_attach_args *va = aux;
d357 21
a377 2
	struct ncr5380_softc *ncr_sc = &sc->ncr_sc;
	int tweak, target;
d379 19
a397 2
	/* enable interrupts on vsbus too */
	scb_vecalloc(va->va_cvec, (void (*)(void *)) ncr5380_intr, sc, SCB_ISTACK);
d400 1
a400 3
	 * DMA area mapin.
	 * On VS3100, split the 128K block between the two devices.
	 * On VS2000, don't care for now.
d402 8
a409 7
#define DMASIZE (64*1024)
	if (va->va_paddr & 0x100) { /* Secondary SCSI controller */
		sc->ncr_off = DMASIZE;
		sc->onlyscsi = 1;
	}
	sc->ncr_addr = (caddr_t)va->va_dmaaddr;
	ncr_dmasize = min(va->va_dmasize, MAXPHYS);
d414 2
d418 5
a422 1
	ncr_sc->sc_dma_setup = si_dma_setup;
d424 1
a424 2
	ncr_sc->sc_dma_poll  = si_dma_poll;
	ncr_sc->sc_dma_eop   = si_dma_eop;
d427 8
a434 4
	/* DMA control register offsets */
	sc->ncr_dmaaddr = 32;	/* DMA address in buffer, longword */
	sc->ncr_dmacount = 64;	/* DMA count register */
	sc->ncr_dmadir = 68;	/* Direction of DMA transfer */
d436 17
a452 2
	ncr_sc->sc_pio_out = ncr5380_pio_out;
	ncr_sc->sc_pio_in =  ncr5380_pio_in;
d454 7
a460 1
	ncr_sc->sc_min_dma_len = MIN_DMA_LEN;
d462 2
a463 2
	/*
	 * Initialize fields used by the MI code.
d465 9
a473 2
/*	sc->sc_regt =  Unused on VAX */
	sc->sc_regh = vax_map_physmem(va->va_paddr, 1);
d475 20
a494 21
	/* Register offsets */
	ncr_sc->sci_r0 = (void *)sc->sc_regh+0;
	ncr_sc->sci_r1 = (void *)sc->sc_regh+4;
	ncr_sc->sci_r2 = (void *)sc->sc_regh+8;
	ncr_sc->sci_r3 = (void *)sc->sc_regh+12;
	ncr_sc->sci_r4 = (void *)sc->sc_regh+16;
	ncr_sc->sci_r5 = (void *)sc->sc_regh+20;
	ncr_sc->sci_r6 = (void *)sc->sc_regh+24;
	ncr_sc->sci_r7 = (void *)sc->sc_regh+28;

	ncr_sc->sc_no_disconnect = 0xff;

	/*
	 * Get the SCSI chip target address out of NVRAM.
	 * This do not apply to the VS2000.
	 */
	tweak = clk_tweak + (va->va_paddr & 0x100 ? 3 : 0);
	if (vax_boardtype == VAX_BTYP_410)
		target = 7;
	else
		target = (clk_page[0xbc/2] >> tweak) & 7;
d496 7
a502 1
	printf("\n%s: NCR5380, SCSI ID %d\n", ncr_sc->sc_dev.dv_xname, target);
d504 2
a505 5
	ncr_sc->sc_link.adapter_softc =	sc;
	ncr_sc->sc_link.adapter_target = target;
	ncr_sc->sc_link.adapter = &si_ops;
	ncr_sc->sc_link.device = &si_dev;
	ncr_sc->sc_link.openings = 4;
d507 13
d521 7
a527 3
	 * Init the vsbus DMA resource queue struct */
	sc->sc_vd.vd_go = si_dma_go;
	sc->sc_vd.vd_arg = sc;
d530 2
a531 1
	 * Initialize si board itself.
d533 48
a580 3
	ncr5380_init(ncr_sc);
	ncr5380_reset_scsibus(ncr_sc);
	config_found(&(ncr_sc->sc_dev), &(ncr_sc->sc_link), scsiprint);
d582 15
d599 3
a601 6
/*
 * Adjust the max transfer size. The DMA buffer is only 16k on VS2000.
 */
static void
si_minphys(bp)
	struct buf *bp;
d603 9
a611 2
	if (bp->b_bcount > ncr_dmasize)
		bp->b_bcount = ncr_dmasize;
d614 10
d631 1
d633 2
a634 1
	int xlen, i;
d636 3
a638 1
#ifdef DIAGNOSTIC
d643 2
a644 4
	/* Polled transfers shouldn't allocate a DMA handle. */
	if (sr->sr_flags & SR_IMMED)
		return;

d649 1
a649 1
		panic("si_dma_alloc: len=0x%x", xlen);
d652 4
a655 3
	 * Find free PDMA handle.  Guaranteed to find one since we
	 * have as many PDMA handles as the driver has processes.
	 * (instances?)
d657 12
a668 2
	 for (i = 0; i < SCI_OPENINGS; i++) {
		if ((sc->ncr_dma[i].dh_flags & SIDH_BUSY) == 0)
d671 1
a671 1
	panic("ncr: no free PDMA handles");
d673 2
a674 1
	dh = &sc->ncr_dma[i];
d676 4
a679 3
	dh->dh_addr = ncr_sc->sc_dataptr;
	dh->dh_len = xlen;
	dh->dh_proc = xs->bp->b_proc;
d681 1
a681 1
	/* Remember dest buffer parameters */
d685 49
d735 2
d739 1
d744 1
d746 2
d750 3
a752 1
#ifdef DIAGNOSTIC
d758 1
a758 1
		panic("si_dma_free: free while DMA in progress");
d760 15
a774 1
	if (dh->dh_flags & SIDH_BUSY)
d776 138
d915 7
a921 1
		printf("si_dma_free: free'ing unused buffer\n");
d923 58
a980 1
	sr->sr_dma_hand = NULL;
d983 7
d991 1
a991 1
si_dma_setup(ncr_sc)
d994 1
a994 1
	/* Do nothing here */
d997 10
d1008 1
a1008 1
si_dma_start(ncr_sc)
d1011 6
a1016 1
	struct si_softc *sc = (struct si_softc *)ncr_sc;
a1017 6
	/* Just put on queue; will call go() from below */
	if (sc->onlyscsi)
		si_dma_go(ncr_sc);
	else
		vsbus_dma_start(&sc->sc_vd);
}
d1020 10
a1029 1
 * go() routine called when another transfer somewhere is finished.
d1032 14
a1045 2
si_dma_go(arg)
	void *arg;
a1046 1
	struct ncr5380_softc *ncr_sc = arg;
d1050 15
d1067 4
a1070 2
	 * Set the VAX-DMA-specific registers, and copy the data if
	 * it is directed "outbound".
d1072 2
d1075 35
a1109 7
		vsbus_copyfromproc(dh->dh_proc, dh->dh_addr,
		    sc->ncr_addr + sc->ncr_off, dh->dh_len);
		bus_space_write_1(sc->sc_regt, sc->sc_regh,
		    sc->ncr_dmadir, 0);
	} else {
		bus_space_write_1(sc->sc_regt, sc->sc_regh,
		    sc->ncr_dmadir, 1);
d1111 3
a1113 4
	bus_space_write_4(sc->sc_regt, sc->sc_regh,
	    sc->ncr_dmacount, -dh->dh_len);
	bus_space_write_4(sc->sc_regt, sc->sc_regh,
	    sc->ncr_dmaaddr, sc->ncr_off);
d1115 2
a1116 1
	 * Now from the 5380-internal DMA registers.
d1118 1
d1120 5
a1124 5
		NCR5380_WRITE(sc, sci_tcmd, PHASE_DATA_OUT);
		NCR5380_WRITE(sc, sci_icmd, SCI_ICMD_DATA);
		NCR5380_WRITE(sc, sci_mode, NCR5380_READ(sc, sci_mode)
		    | SCI_MODE_DMA | SCI_MODE_DMA_IE);
		NCR5380_WRITE(sc, sci_dma_send, 0);
d1126 5
a1130 5
		NCR5380_WRITE(sc, sci_tcmd, PHASE_DATA_IN);
		NCR5380_WRITE(sc, sci_icmd, 0);
		NCR5380_WRITE(sc, sci_mode, NCR5380_READ(sc, sci_mode)
		    | SCI_MODE_DMA | SCI_MODE_DMA_IE);
		NCR5380_WRITE(sc, sci_irecv, 0);
d1133 21
d1156 1
a1156 3
/*
 * When?
 */
d1158 1
a1158 1
si_dma_poll(ncr_sc)
d1161 2
a1162 1
	printf("si_dma_poll\n");
d1166 2
a1167 1
 * When?
a1169 7
si_dma_eop(ncr_sc)
	struct ncr5380_softc *ncr_sc;
{
	printf("si_dma_eop\n");
}

void
d1176 2
a1177 1
	int count, i;
d1179 13
a1191 2
	if (ncr_sc->sc_state & NCR_DOINGDMA) 
		ncr_sc->sc_state &= ~NCR_DOINGDMA;
d1194 7
a1200 3
	 * Sometimes the FIFO buffer isn't drained when the
	 * interrupt is posted. Just loop here and hope that
	 * it will drain soon.
d1202 19
a1220 6
	for (i = 0; i < 20000; i++) {
		count = bus_space_read_4(sc->sc_regt,
		    sc->sc_regh, sc->ncr_dmacount);
		if (count == 0)
			break;
		DELAY(100);
d1222 13
a1234 8
	if (count == 0) {
		if (((dh->dh_flags & SIDH_OUT) == 0)) {
			vsbus_copytoproc(dh->dh_proc,
			    sc->ncr_addr + sc->ncr_off,
			    dh->dh_addr, dh->dh_len);
		}
		ncr_sc->sc_dataptr += dh->dh_len;
		ncr_sc->sc_datalen -= dh->dh_len;
d1236 8
d1245 5
a1249 5
	NCR5380_WRITE(sc, sci_mode, NCR5380_READ(sc, sci_mode) &
	    ~(SCI_MODE_DMA | SCI_MODE_DMA_IE));
	NCR5380_WRITE(sc, sci_icmd, 0);
	if (sc->onlyscsi == 0)
		vsbus_dma_intr(); /* Try to start more transfers */
d1252 8
a1259 4
int 
sd_getdev (adaptor, controller, part, unit, uname) 
	int adaptor, controller, part, unit;
	char **uname;
d1261 17
a1277 3
	struct sd_softc *sd;
	struct scsi_link *sl;
	int i;
d1279 10
a1288 10
	for (i = 0; i < sd_cd.cd_ndevs; i++) {
		if ((sd = sd_cd.cd_devs[i]) == 0)
			continue;

		sl = sd->sc_link;
		if (sl->target == unit && sl->scsibus == adaptor && 
			sl->lun == part) {
			*uname = sd->sc_dev.dv_xname;
			return i;
		}
d1290 2
a1291 1
	return -1;
a1292 1

@


1.4.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: ncr.c,v 1.4.6.1 2001/05/14 21:39:20 niklas Exp $ */
d64 1
a93 1
	struct	evcnt		ncr_intrcnt;
d111 12
a122 12
static	int si_match(struct device *, void *, void *);
static	void si_attach(struct device *, struct device *, void *);
static	void si_minphys(struct buf *);

static	void si_dma_alloc(struct ncr5380_softc *);
static	void si_dma_free(struct ncr5380_softc *);
static	void si_dma_setup(struct ncr5380_softc *);
static	void si_dma_start(struct ncr5380_softc *);
static	void si_dma_poll(struct ncr5380_softc *);
static	void si_dma_eop(struct ncr5380_softc *);
static	void si_dma_stop(struct ncr5380_softc *);
static	void si_dma_go(void *);
d185 1
a185 3
	scb_vecalloc(va->va_cvec, (void (*)(void *)) ncr5380_intr, sc,
	    SCB_ISTACK, &sc->ncr_intrcnt);
	evcnt_attach(self, "intr", &sc->ncr_intrcnt);
@


1.4.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d63 1
a63 1
#include <uvm/uvm_extern.h>
@


1.4.6.4
log
@Sync the SMP branch with 3.3
@
text
@d484 24
@


1.3
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.2 1997/05/28 23:35:51 niklas Exp $	*/
d442 1
a442 1
		panic("si: dvma_malloc failed\n");
d649 1
a649 1
		panic("si_dma_alloc: xlen=0x%x\n", xlen);
@


1.2
log
@We do not have sc_link.channel
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr.c,v 1.5 1996/10/13 03:36:14 christos Exp $	*/
/*	$NetBSD: ncr.c,v 1.5 1996/10/13 03:36:14 christos Exp $	*/
d428 4
a431 2
	if (si_options & SI_DO_RESELECT)
		ncr_sc->sc_flags |= NCR5380_PERMIT_RESELECT;
d479 1
d481 1
d658 1
d661 1
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
d389 1
d391 1
@
