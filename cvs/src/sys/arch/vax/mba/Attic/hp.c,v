head	1.27;
access;
symbols
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.12
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.10
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.8
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.10.0.10
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.8
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.8
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2011.07.06.18.32.59;	author miod;	state dead;
branches;
next	1.26;

1.26
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.06.18.12.47;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.22.06.40.25;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.08.14.47.10;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.05.00.48.39;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.01.12.45.42;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.07.05.22.32;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.05.00.38.19;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.06.22.01.41;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.06.03.02.44;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.08.08.50.26;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.27.03.14.44;	author bjc;	state Exp;
branches
	1.10.10.1;
next	1.9;

1.9
date	98.10.03.21.18.59;	author millert;	state Exp;
branches
	1.9.8.1;
next	1.8;

1.8
date	97.09.12.09.23.59;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.09.10.11.52.26;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	97.08.08.21.46.56;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.00.04.58;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.24.47;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.06.12.08.20.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.03.09.09.49;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.08;	author deraadt;	state Exp;
branches;
next	;

1.9.8.1
date	2001.05.14.21.38.11;	author niklas;	state Exp;
branches;
next	1.9.8.2;

1.9.8.2
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.9.8.3;

1.9.8.3
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.9.8.4;

1.9.8.4
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.9.8.5;

1.9.8.5
date	2004.06.05.23.11.02;	author niklas;	state Exp;
branches;
next	;

1.10.10.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@/*	$OpenBSD: hp.c,v 1.26 2011/06/05 18:40:33 matthew Exp $ */
/*	$NetBSD: hp.c,v 1.22 2000/02/12 16:09:33 ragge Exp $ */
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Simple device driver routine for massbuss disks.
 * TODO:
 *  Fix support for Standard DEC BAD144 bad block forwarding.
 *  Be able to to handle soft/hard transfer errors.
 *  Handle non-data transfer interrupts.
 *  Autoconfiguration of disk drives 'on the fly'.
 *  Handle disk media changes.
 *  Dual-port operations should be supported.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/dkio.h>
#include <sys/buf.h>
#include <sys/stat.h>
#include <sys/ioccom.h>
#include <sys/fcntl.h>
#include <sys/syslog.h>
#include <sys/reboot.h>
#include <sys/conf.h>

#include <machine/trap.h>
#include <machine/pte.h>
#include <machine/mtpr.h>
#include <machine/cpu.h>

#include <vax/mba/mbavar.h>
#include <vax/mba/mbareg.h>
#include <vax/mba/hpreg.h>

#define	HPMASK 0xffff

struct	hp_softc {
	struct	device	sc_dev;
	struct	disk sc_disk;
	struct	mba_device sc_md;	/* Common struct used by mbaqueue. */
	int	sc_physnr;		/* Physical disk number */
};

int     hpmatch(struct device *, struct cfdata *, void *);
void    hpattach(struct device *, struct device *, void *);
void	hpstart(struct mba_device *);
int	hpattn(struct mba_device *);
enum	xfer_action hpfinish(struct mba_device *, int, int *);
bdev_decl(hp);
int	hpread(dev_t, struct uio *);
int	hpwrite(dev_t, struct uio *);

struct	cfattach hp_ca = {
	sizeof(struct hp_softc), hpmatch, hpattach
};

extern struct cfdriver hp_cd;

/*
 * Check if this is a disk drive; done by checking type from mbaattach.
 */
int
hpmatch(parent, cf, aux)
	struct	device *parent;
	struct	cfdata *cf;
	void	*aux;
{
	struct	mba_attach_args *ma = aux;

	if (cf->cf_loc[MBACF_DRIVE] != MBACF_DRIVE_DEFAULT &&
	    cf->cf_loc[MBACF_DRIVE] != ma->unit)
		return 0;

	if (ma->devtyp != MB_RP)
		return 0;

	return 1;
}

/*
 * Disk drive found; fake a disklabel and try to read the real one.
 * If the on-disk label can't be read; we lose.
 */
void
hpattach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
{
	struct	hp_softc *sc = (void *)self;
	struct	mba_softc *ms = (void *)parent;
	struct	disklabel *dl;
	struct  mba_attach_args *ma = aux;
	char	*msg;

	/*
	 * Init the common struct for both the adapter and its slaves.
	 */
	BUFQ_INIT(&sc->sc_md.md_q);
	sc->sc_md.md_softc = (void *)sc;	/* Pointer to this softc */
	sc->sc_md.md_mba = (void *)parent;	/* Pointer to parent softc */
	sc->sc_md.md_start = hpstart;		/* Disk start routine */
	sc->sc_md.md_attn = hpattn;		/* Disk attention routine */
	sc->sc_md.md_finish = hpfinish;		/* Disk xfer finish routine */

	ms->sc_md[ma->unit] = &sc->sc_md;	/* Per-unit backpointer */

	sc->sc_physnr = ma->unit;
	/*
	 * Init and attach the disk structure.
	 */
	sc->sc_disk.dk_name = sc->sc_dev.dv_xname;
	disk_attach(&sc->sc_dev, &sc->sc_disk);

	/*
	 * Fake a disklabel to be able to read in the real label.
	 */
	dl = sc->sc_disk.dk_label;

	dl->d_secsize = DEV_BSIZE;
	dl->d_ntracks = 1;
	dl->d_nsectors = 32;
	dl->d_secpercyl = 32;

	/*
	 * Read in label.
	 */
	if ((msg = readdisklabel(makedev(0, self->dv_unit * 8), hpstrategy,
	    dl, NULL)) != NULL) {
		/*printf(": %s", msg);*/
	}
	printf(": %.*s, size = %d sectors\n",
	    (int)sizeof(dl->d_typename), dl->d_typename, DL_GETDSIZE(dl));
	/*
	 * check if this was what we booted from.
	 */
	if ((B_TYPE(bootdev) == BDEV_HP) && (ma->unit == B_UNIT(bootdev)) &&
	    (ms->sc_physnr == B_ADAPTOR(bootdev)))
		booted_from = self;
}


void
hpstrategy(bp)
	struct buf *bp;
{
	struct	hp_softc *sc;
	struct	buf *gp;
	int	unit, s;
	struct disklabel *lp;

	unit = DISKUNIT(bp->b_dev);
	sc = hp_cd.cd_devs[unit];
	lp = sc->sc_disk.dk_label;

	if (bounds_check_with_label(bp, lp) <= 0)
		goto done;

	bp->b_rawblkno =
	    bp->b_blkno + DL_GETPOFFSET(&lp->d_partitions[DISKPART(bp->b_dev)]);
	bp->b_cylinder = bp->b_rawblkno / lp->d_secpercyl;

	s = splbio();

	gp = BUFQ_FIRST(&sc->sc_md.md_q);
	disksort_cylinder(&sc->sc_md.md_q, bp);
	if (gp == 0)
		mbaqueue(&sc->sc_md);

	splx(s);
	return;

done:
	bp->b_resid = bp->b_bcount;
	s = splbio();
	biodone(bp);
	splx(s);
}

/*
 * Start transfer on given disk. Called from mbastart().
 */
void
hpstart(md)
	struct	mba_device *md;
{
	struct	hp_softc *sc = md->md_softc;
	struct	mba_regs *mr = md->md_mba->sc_mbareg;
	volatile struct	hp_regs *hr;
	struct	disklabel *lp = sc->sc_disk.dk_label;
	struct	buf *bp = BUFQ_FIRST(&md->md_q);
	unsigned bn, cn, sn, tn;

	/*
	 * Collect statistics.
	 */
	disk_busy(&sc->sc_disk);
	sc->sc_disk.dk_seek++;

	hr = (void *)&mr->mba_md[DISKUNIT(bp->b_dev)];

	bn = bp->b_rawblkno;
	if (bn) {
		cn = bn / lp->d_secpercyl;
		sn = bn % lp->d_secpercyl;
		tn = sn / lp->d_nsectors;
		sn = sn % lp->d_nsectors;
	} else
		cn = sn = tn = 0;

	hr->hp_dc = cn;
	hr->hp_da = (tn << 8) | sn;
	if (bp->b_flags & B_READ)
		hr->hp_cs1 = HPCS_READ;		/* GO */
	else
		hr->hp_cs1 = HPCS_WRITE;
}

int
hpopen(dev, flag, fmt)
	dev_t	dev;
	int	flag, fmt;
{
	struct	hp_softc *sc;
	int	unit, part;

	unit = DISKUNIT(dev);
	if (unit >= hp_cd.cd_ndevs)
		return ENXIO;
	sc = hp_cd.cd_devs[unit];
	if (sc == 0)
		return ENXIO;

	part = DISKPART(dev);

	if (part >= sc->sc_disk.dk_label->d_npartitions)
		return ENXIO;

	switch (fmt) {
	case 	S_IFCHR:
		sc->sc_disk.dk_copenmask |= (1 << part);
		break;

	case	S_IFBLK:
		sc->sc_disk.dk_bopenmask |= (1 << part);
		break;
	}
	sc->sc_disk.dk_openmask =
	    sc->sc_disk.dk_copenmask | sc->sc_disk.dk_bopenmask;

	return 0;
}

int
hpclose(dev, flag, fmt)
	dev_t	dev;
	int	flag, fmt;
{
	struct	hp_softc *sc;
	int	unit, part;

	unit = DISKUNIT(dev);
	sc = hp_cd.cd_devs[unit];

	part = DISKPART(dev);

	switch (fmt) {
	case 	S_IFCHR:
		sc->sc_disk.dk_copenmask &= ~(1 << part);
		break;

	case	S_IFBLK:
		sc->sc_disk.dk_bopenmask &= ~(1 << part);
		break;
	}
	sc->sc_disk.dk_openmask =
	    sc->sc_disk.dk_copenmask | sc->sc_disk.dk_bopenmask;

	return 0;
}

int
hpioctl(dev, cmd, addr, flag, p)
	dev_t	dev;
	u_long	cmd;
	caddr_t	addr;
	int	flag;
	struct	proc *p;
{
	struct	hp_softc *sc = hp_cd.cd_devs[DISKUNIT(dev)];
	struct	disklabel *lp = sc->sc_disk.dk_label;
	int	error;

	switch (cmd) {
	case	DIOCGDINFO:
	case	DIOCGPDINFO:	/* no separate 'physical' info available. */
		bcopy(lp, addr, sizeof (struct disklabel));
		return 0;

	case	DIOCGPART:
		((struct partinfo *)addr)->disklab = lp;
		((struct partinfo *)addr)->part =
		    &lp->d_partitions[DISKPART(dev)];
		break;

	case	DIOCWDINFO:
	case	DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return EBADF;

		error = setdisklabel(lp, (struct disklabel *)addr, 0);
		if (error == 0) {
			if (cmd == DIOCWDINFO) {
				error = writedisklabel(dev, hpstrategy, lp, 0);
			}
		}
		return error;

	default:
		printf("hpioctl: command %x\n", (unsigned int)cmd);
		return ENOTTY;
	}
	return 0;
}

/*
 * Called when a transfer is finished. Check if transfer went OK,
 * Return info about what-to-do-now.
 */
enum xfer_action
hpfinish(md, mbasr, attn)
	struct	mba_device *md;
	int	mbasr, *attn;
{
	struct	hp_softc *sc = md->md_softc;
	struct	buf *bp = BUFQ_FIRST(&md->md_q);
	volatile struct  mba_regs *mr = md->md_mba->sc_mbareg;
	volatile struct	hp_regs *hr = (void *)&mr->mba_md[DISKUNIT(bp->b_dev)];
	int	er1, er2;
	volatile int bc; /* to get GCC read whole longword */
	unsigned byte;

	er1 = hr->hp_er1 & HPMASK;
	er2 = hr->hp_er2 & HPMASK;
	hr->hp_er1 = hr->hp_er2 = 0;
hper1:
	switch (ffs(er1) - 1) {
	case -1:
		hr->hp_er1 = 0;
		goto hper2;
		
	case HPER1_DCK: /* Corrected? data read. Just notice. */
		bc = mr->mba_bc;
		byte = ~(bc >> 16);
		diskerr(buf, hp_cd.cd_name, "soft ecc", LOG_PRINTF,
		    btodb(bp->b_bcount - byte), sc->sc_disk.dk_label);
		er1 &= ~(1<<HPER1_DCK);
		er1 &= HPMASK;
		break;

	default:
		printf("drive error :%s er1 %x er2 %x\n",
		    sc->sc_dev.dv_xname, er1, er2);
		hr->hp_er1 = hr->hp_er2 = 0;
		goto hper2;
	}
	goto hper1;

hper2:
	mbasr &= ~(MBASR_DTBUSY|MBASR_DTCMP|MBASR_ATTN);
	if (mbasr)
		printf("massbuss error :%s %x\n",
		    sc->sc_dev.dv_xname, mbasr);

	BUFQ_FIRST(&md->md_q)->b_resid = 0;
	disk_unbusy(&sc->sc_disk, BUFQ_FIRST(&md->md_q)->b_bcount,
	    (BUFQ_FIRST(&md->md_q)->b_flags & B_READ));
	return XFER_FINISH;
}

/*
 * Non-data transfer interrupt; like volume change.
 */
int
hpattn(md)
	struct	mba_device *md;
{
	struct	hp_softc *sc = md->md_softc;
	struct	mba_softc *ms = (void *)sc->sc_dev.dv_parent;
	struct  mba_regs *mr = ms->sc_mbareg;
	struct  hp_regs *hr = (void *)&mr->mba_md[sc->sc_dev.dv_unit];
	int	er1, er2;

        er1 = hr->hp_er1 & HPMASK;
        er2 = hr->hp_er2 & HPMASK;

	printf("%s: Attention! er1 %x er2 %x\n",
		sc->sc_dev.dv_xname, er1, er2);
	return 0;
}


daddr64_t
hpsize(dev)
	dev_t	dev;
{
	int	size, unit = DISKUNIT(dev);
	struct  hp_softc *sc;

	if (unit >= hp_cd.cd_ndevs || hp_cd.cd_devs[unit] == 0)
		return -1;

	sc = hp_cd.cd_devs[unit];
	size = DL_GETPSIZE(&sc->sc_disk.dk_label->d_partitions[DISKPART(dev)]) *
	    (sc->sc_disk.dk_label->d_secsize / DEV_BSIZE);

	return size;
}

int
hpdump(dev, a1, a2, size)
	dev_t	dev;
	daddr64_t a1;
	caddr_t a2;
	size_t	size;
{
	printf("hpdump: Not implemented yet.\n");
	return 0;
}

int
hpread(dev, uio)
	dev_t dev;
	struct uio *uio;
{
	return (physio(hpstrategy, dev, B_READ, minphys, uio));
}

int
hpwrite(dev, uio)
	dev_t dev;
	struct uio *uio;
{
	return (physio(hpstrategy, dev, B_WRITE, minphys, uio));
}
@


1.26
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.25 2011/06/03 21:14:11 matthew Exp $ */
@


1.25
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.24 2011/04/06 18:12:47 miod Exp $ */
a72 1
	int	sc_wlabel;		/* Disklabel area is writable */
a344 1
				sc->sc_wlabel = 1;
a345 1
				sc->sc_wlabel = 0;
a348 5
	case	DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return EBADF;
		sc->sc_wlabel = 1;
		break;
@


1.24
log
@Use bdev_decl() to get block device function prototypes instead of rolling
our own (sometimes incorrect).
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.23 2010/09/22 06:40:25 krw Exp $ */
d188 1
a188 1
	if (bounds_check_with_label(bp, lp, sc->sc_wlabel) <= 0)
@


1.23
log
@Add DIOCGPDINFO to drivers that were lacking it. Where there
is no easily available physical information outside of the stored
disklabel just make it a synonym for DIOCGDINFO.

Commit on the theory it is unlikely to harm, and fallout can be
addressed in the mass re-compile that will follow j2k10.

Should allow auto-allocation of disks to work with all devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.22 2010/09/22 01:18:57 matthew Exp $ */
d56 1
a78 1
void	hpstrategy(struct buf *);
d82 1
a82 4
int	hpopen(dev_t, int, int);
int	hpclose(dev_t, int, int);
int	hpioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	hpdump(dev_t, daddr64_t, caddr_t, size_t);
a84 1
daddr64_t hpsize(dev_t);
@


1.22
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.21 2010/09/08 14:47:10 jsing Exp $ */
d332 1
@


1.21
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.19 2007/09/01 12:45:42 miod Exp $ */
d478 1
a478 1
	return (physio(hpstrategy, NULL, dev, B_READ, minphys, uio));
d486 1
a486 1
	return (physio(hpstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.20
log
@Make DIOCSDINFO code consistant everywhere.

ok miod@@ deraadt@@
@
text
@d149 1
a149 1
	disk_attach(&sc->sc_disk);
@


1.19
log
@Do not include <machine/rpb.h> unless necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.18 2007/06/07 05:22:32 deraadt Exp $ */
d341 1
d346 7
a352 9
		return setdisklabel(lp, (struct disklabel *)addr, 0, 0);

	case	DIOCWDINFO:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			sc->sc_wlabel = 1;
			error = writedisklabel(dev, hpstrategy, lp, 0);
			sc->sc_wlabel = 0;
@


1.18
log
@more XXsize() functions not fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.17 2007/06/05 00:38:19 deraadt Exp $ */
a60 1
#include <machine/rpb.h>
@


1.17
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.16 2007/02/15 00:53:26 krw Exp $ */
d86 1
a86 1
int	hpdump(dev_t, caddr_t, caddr_t, size_t);
d89 1
a89 1
int	hpsize(dev_t);
d447 1
a447 1
int
d467 2
a468 1
	caddr_t	a1, a2;
@


1.16
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.15 2004/02/15 02:45:46 tedu Exp $ */
d170 1
a170 1
	    (int)sizeof(dl->d_typename), dl->d_typename, dl->d_secperunit);
d197 1
a197 1
	    bp->b_blkno + lp->d_partitions[DISKPART(bp->b_dev)].p_offset;
d458 1
a458 1
	size = sc->sc_disk.dk_label->d_partitions[DISKPART(dev)].p_size *
@


1.15
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.14 2003/04/06 22:01:41 miod Exp $ */
d166 3
a168 2
	    dl, NULL)) != NULL)
		printf(": %s", msg);
@


1.14
log
@The return value for bounds_check_with_label() is not set in stone, and it
turns out that some arches will return (-1) in case of error, while others
will return (0).

Until we make our minds on this, make sure that callers of this function
properly handle 0 or (-1) as failure.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.13 2003/04/06 03:02:44 krw Exp $ */
d419 2
a420 1
	disk_unbusy(&sc->sc_disk, BUFQ_FIRST(&md->md_q)->b_bcount);
@


1.13
log
@The disklabel fields d_packname and d_typename are not null terminated strings
and should not be created or used as such.

This fixes some instances of both behaviours, and sets the stage for some
strcpy -> strncpy fixup.

ok tdeval@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.12 2002/06/08 08:50:26 art Exp $ */
d185 1
a185 1
	int	unit, s, err;
d192 1
a192 2
	err = bounds_check_with_label(bp, lp, sc->sc_wlabel);
	if (err < 0)
@


1.12
log
@protect biodone with splbio
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.11 2002/03/14 01:26:48 millert Exp $ */
d168 2
a169 1
	printf(": %s, size = %d sectors\n", dl->d_typename, dl->d_secperunit);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.10 2000/04/27 03:14:44 bjc Exp $ */
d211 1
d213 1
@


1.10
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.9 1998/10/03 21:18:59 millert Exp $ */
d77 13
a89 13
int     hpmatch __P((struct device *, struct cfdata *, void *));
void    hpattach __P((struct device *, struct device *, void *));
void	hpstrategy __P((struct buf *));
void	hpstart __P((struct mba_device *));
int	hpattn __P((struct mba_device *));
enum	xfer_action hpfinish __P((struct mba_device *, int, int *));
int	hpopen __P((dev_t, int, int));
int	hpclose __P((dev_t, int, int));
int	hpioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	hpdump __P((dev_t, caddr_t, caddr_t, size_t));
int	hpread __P((dev_t, struct uio *));
int	hpwrite __P((dev_t, struct uio *));
int	hpsize __P((dev_t));
@


1.10.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.10 2000/04/27 03:14:44 bjc Exp $ */
d77 13
a89 13
int     hpmatch(struct device *, struct cfdata *, void *);
void    hpattach(struct device *, struct device *, void *);
void	hpstrategy(struct buf *);
void	hpstart(struct mba_device *);
int	hpattn(struct mba_device *);
enum	xfer_action hpfinish(struct mba_device *, int, int *);
int	hpopen(dev_t, int, int);
int	hpclose(dev_t, int, int);
int	hpioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	hpdump(dev_t, caddr_t, caddr_t, size_t);
int	hpread(dev_t, struct uio *);
int	hpwrite(dev_t, struct uio *);
int	hpsize(dev_t);
a210 1
	s = splbio();
a211 1
	splx(s);
@


1.10.10.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d168 1
a168 2
	printf(": %.*s, size = %d sectors\n",
	    (int)sizeof(dl->d_typename), dl->d_typename, dl->d_secperunit);
d184 1
a184 1
	int	unit, s;
d191 2
a192 1
	if (bounds_check_with_label(bp, lp, sc->sc_wlabel) <= 0)
@


1.9
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 2
a2 2
/*	$OpenBSD: hp.c,v 1.8 1997/09/12 09:23:59 maja Exp $ */
/*	$NetBSD: hp.c,v 1.15 1997/06/24 01:09:37 thorpej Exp $ */
d77 1
a77 1
int     hpmatch __P((struct device *, void *, void *));
a90 4
struct	cfdriver hp_cd = {
	NULL, "hp", DV_DISK
};

d95 2
d101 1
a101 1
hpmatch(parent, match, aux)
d103 2
a104 1
	void	*match, *aux;
a105 1
	struct	cfdata *cf = match;
d108 2
a109 1
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != ma->unit)
d136 1
d166 1
a166 1
	    dl, NULL, 0)) != NULL)
d184 2
a185 1
	int	unit, s;
d189 1
d191 2
a192 2
	if (bounds_check_with_label(bp, sc->sc_disk.dk_label,
	    sc->sc_disk.dk_cpulabel, sc->sc_wlabel) <= 0)
d194 5
d201 2
a202 2
	gp = sc->sc_md.md_q.b_actf;
	disksort(&sc->sc_md.md_q, bp);
d225 1
a225 1
	struct	buf *bp = md->md_q.b_actf;
a226 1
	int	part = DISKPART(bp->b_dev);
d236 1
a236 1
	bn = bp->b_blkno + lp->d_partitions[part].p_offset;
d377 1
a377 1
	struct	buf *bp = md->md_q.b_actf;
d416 2
a417 2
	md->md_q.b_actf->b_resid = 0;
	disk_unbusy(&sc->sc_disk, md->md_q.b_actf->b_bcount);
d454 2
a455 1
	size = sc->sc_disk.dk_label->d_partitions[DISKPART(dev)].p_size;
a483 26
}

/*
 * Convert physical adapternr and unit to the unit number used by kernel.
 */
int
hp_getdev(mbanr, unit, uname)
	int	mbanr, unit;
	char **uname;
{
	struct	mba_softc *ms;
	struct	hp_softc *sc;
	int i;

	for (i = 0; i < hp_cd.cd_ndevs; i++) {
		if (hp_cd.cd_devs[i] == 0)
			continue;

		sc = hp_cd.cd_devs[i];
		ms = (void *)sc->sc_dev.dv_parent;
		if (ms->sc_physnr == mbanr && sc->sc_physnr == unit) {
			*uname = sc->sc_dev.dv_xname;
			return i;
		}
	}
	return -1;
@


1.9.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: hp.c,v 1.10 2000/04/27 03:14:44 bjc Exp $ */
/*	$NetBSD: hp.c,v 1.22 2000/02/12 16:09:33 ragge Exp $ */
d77 1
a77 1
int     hpmatch __P((struct device *, struct cfdata *, void *));
d91 4
a98 2
extern struct cfdriver hp_cd;

d103 1
a103 1
hpmatch(parent, cf, aux)
d105 1
a105 2
	struct	cfdata *cf;
	void	*aux;
d107 1
d110 1
a110 2
	if (cf->cf_loc[MBACF_DRIVE] != MBACF_DRIVE_DEFAULT &&
	    cf->cf_loc[MBACF_DRIVE] != ma->unit)
a136 1
	BUFQ_INIT(&sc->sc_md.md_q);
d166 1
a166 1
	    dl, NULL)) != NULL)
d184 1
a184 2
	int	unit, s, err;
	struct disklabel *lp;
a187 1
	lp = sc->sc_disk.dk_label;
d189 2
a190 2
	err = bounds_check_with_label(bp, lp, sc->sc_wlabel);
	if (err < 0)
a191 5

	bp->b_rawblkno =
	    bp->b_blkno + lp->d_partitions[DISKPART(bp->b_dev)].p_offset;
	bp->b_cylinder = bp->b_rawblkno / lp->d_secpercyl;

d194 2
a195 2
	gp = BUFQ_FIRST(&sc->sc_md.md_q);
	disksort_cylinder(&sc->sc_md.md_q, bp);
d218 1
a218 1
	struct	buf *bp = BUFQ_FIRST(&md->md_q);
d220 1
d230 1
a230 1
	bn = bp->b_rawblkno;
d371 1
a371 1
	struct	buf *bp = BUFQ_FIRST(&md->md_q);
d410 2
a411 2
	BUFQ_FIRST(&md->md_q)->b_resid = 0;
	disk_unbusy(&sc->sc_disk, BUFQ_FIRST(&md->md_q)->b_bcount);
d448 1
a448 2
	size = sc->sc_disk.dk_label->d_partitions[DISKPART(dev)].p_size *
	    (sc->sc_disk.dk_label->d_secsize / DEV_BSIZE);
d477 26
@


1.9.8.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d77 13
a89 13
int     hpmatch(struct device *, struct cfdata *, void *);
void    hpattach(struct device *, struct device *, void *);
void	hpstrategy(struct buf *);
void	hpstart(struct mba_device *);
int	hpattn(struct mba_device *);
enum	xfer_action hpfinish(struct mba_device *, int, int *);
int	hpopen(dev_t, int, int);
int	hpclose(dev_t, int, int);
int	hpioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	hpdump(dev_t, caddr_t, caddr_t, size_t);
int	hpread(dev_t, struct uio *);
int	hpwrite(dev_t, struct uio *);
int	hpsize(dev_t);
@


1.9.8.3
log
@Sync the SMP branch with 3.3
@
text
@a210 1
	s = splbio();
a211 1
	splx(s);
@


1.9.8.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.9.8.3 2003/03/27 23:52:19 niklas Exp $ */
d168 1
a168 2
	printf(": %.*s, size = %d sectors\n",
	    (int)sizeof(dl->d_typename), dl->d_typename, dl->d_secperunit);
d184 1
a184 1
	int	unit, s;
d191 2
a192 1
	if (bounds_check_with_label(bp, lp, sc->sc_wlabel) <= 0)
@


1.9.8.5
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d419 1
a419 2
	disk_unbusy(&sc->sc_disk, BUFQ_FIRST(&md->md_q)->b_bcount,
	    (BUFQ_FIRST(&md->md_q)->b_flags & B_READ));
@


1.8
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.7 1997/09/10 11:52:26 maja Exp $ */
d166 1
a166 1
	    dl, NULL)) != NULL)
@


1.7
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: hp.c,v 1.6 1997/08/08 21:46:56 niklas Exp $ */
/*	$NetBSD: hp.c,v 1.14 1997/03/15 16:32:18 ragge Exp $ */
@


1.6
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 2
a2 2
/*	$OpenBSD: hp.c,v 1.5 1997/05/29 00:04:58 niklas Exp $ */
/*	$NetBSD: hp.c,v 1.12 1996/10/13 03:34:58 christos Exp $ */
d55 1
d61 1
d169 6
a503 1

@


1.5
log
@RCS tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: hp.c,v 1.12 1996/10/13 03:34:58 christos Exp $ */
d181 2
a182 2
	if (bounds_check_with_label(bp, sc->sc_disk.dk_label, sc->sc_wlabel)
	    <= 0)
@


1.4
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.3
log
@sync to 0611
@
text
@d1 1
a1 1
/*	$NetBSD: hp.c,v 1.9 1996/05/19 16:43:34 ragge Exp $ */
d474 1
a474 1
hp_getdev(mbanr, unit)
d476 1
d488 2
a489 1
		if (ms->sc_physnr == mbanr && sc->sc_physnr == unit)
d491 1
@


1.2
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: hp.c,v 1.8 1996/04/08 18:38:58 ragge Exp $ */
a53 1
#include <sys/cpu.h>
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: hp.c,v 1.1 1995/02/13 00:43:59 ragge Exp $ */
d3 1
a3 1
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
d16 2
a17 1
 *     This product includes software developed at Ludd, University of Lule}.
d33 41
a73 5
 /* All bugs are subject to removal without further notice */
		


/* hp.c - drivrutiner f|r massbussdiskar 940325/ragge */
d75 13
a87 15
#include "param.h"
#include "types.h"
#include "fcntl.h"
#include "syslog.h"
#include "disklabel.h"
#include "buf.h"
#include "vax/mba/mbareg.h"
#include "vax/mba/mbavar.h"
#include "vax/mba/hpdefs.h"
#include "hp.h"

struct	mba_device	*hpinfo[NHP];
struct	hp_info		hp_info[NHP];
struct	disklabel	hplabel[NHP];
int hpslave(), hpattach();
d89 2
a90 2
char hptypes[]={
	0x22,0
d93 2
a94 2
struct mba_driver hpdriver={
	hpslave, 0, "hp", hptypes, hpattach, hpinfo
d97 10
a106 4
hpslave(){
	printf("Hpslave.\n");
	asm("halt");
};
d108 2
a109 4
hpopen(){
	printf("hpopen");
	        asm("halt");
};
d111 2
a112 4
hpclose(){
	printf("hpclose\n");
        asm("halt");
};
d114 1
a114 3
hpioctl(){
	printf("hpioctl\n");
	asm("halt");
d117 37
a153 4
hpdump(){
	printf("hpdump\n");
        asm("halt");
};
d155 4
a158 4
hpsize(){
	printf("hpsize");
        asm("halt");
};
d160 8
d170 3
a172 2
hpattach(mi)
	struct mba_device *mi;
d174 24
a197 1
	struct mba_drv *md;
d200 1
a200 2
 * We check status of the drive first; to see if there is any idea
 * to try to read the label.
d202 65
a266 4
	md=&(mi->mi_mba->mba_drv[mi->drive]);
	if(!md->rmcs1&HPCS1_DVA){
		printf(": Drive not available");
		return;
d268 27
a294 3
	if(!md->rmds&HPDS_MOL){
		printf(": Drive offline");
		return;
d296 2
a297 8
	if (hpinit(mi, 0))
                printf(": offline");
/*        else if (ra_info[unit].ra_state == OPEN) {
                printf(": %s, size = %d sectors",
                    udalabel[unit].d_typename, ra_info[unit].ra_dsize);
*/	
	printf("rmcs1: %x, rmds: %x, rmdt: %x rmsn: %x\n",
		md->rmcs1, md->rmds, md->rmdt, md->rmsn);
d299 2
d302 49
a350 16
/*        asm("halt"); */
/*
        if (MSCP_MID_ECH(1, ra_info[unit].ra_mediaid) == 'X' - '@@') {
                printf(": floppy");
                return;
        }
        if (ui->ui_dk >= 0)
                dk_wpms[ui->ui_dk] = (60 * 31 * 256); 
        udaip[ui->ui_ctlr][ui->ui_slave] = ui;

        if (uda_rainit(ui, 0))
                printf(": offline");
        else if (ra_info[unit].ra_state == OPEN) {
                printf(": %s, size = %d sectors",
                    udalabel[unit].d_typename, ra_info[unit].ra_dsize);
        }*/
a352 1

d354 2
a355 3
 * Initialise a drive.  If it is not already, bring it on line,
 * and set a timeout on it in case it fails to respond.
 * When on line, read in the pack label.
d357 4
a360 2
hpinit(mi, flags)
        struct mba_device *mi;
d362 33
a394 8
/*        struct uda_softc *sc = &uda_softc[ui->ui_ctlr]; */
	struct disklabel *lp;
	struct hp_info *hp;
/*         struct mscp *mp; */
        int unit = mi->unit;
	char *msg, *readdisklabel();
	int s, i, hpstrategy();
	extern int cold;
d396 9
a404 68
        hp = &hp_info[unit];
/*
        if ((ui->ui_flags & UNIT_ONLINE) == 0) {
                mp = mscp_getcp(&sc->sc_mi, MSCP_WAIT);
                mp->mscp_opcode = M_OP_ONLINE;
                mp->mscp_unit = ui->ui_slave;
                mp->mscp_cmdref = (long)&ui->ui_flags;
                *mp->mscp_addr |= MSCP_OWN | MSCP_INT;
                ra->ra_state = WANTOPEN;
                if (!cold)
                        s = spl5();
                i = ((struct udadevice *)ui->ui_addr)->udaip;

                if (cold) {
                        i = todr() + 1000;
                        while ((ui->ui_flags & UNIT_ONLINE) == 0)
                                if (todr() > i)
                                        break;
                } else {
                        timeout(wakeup, (caddr_t)&ui->ui_flags, 10 * hz);
                        sleep((caddr_t)&ui->ui_flags, PSWP + 1);
                        splx(s);
                        untimeout(wakeup, (caddr_t)&ui->ui_flags);
                }
                if (ra->ra_state != OPENRAW) {
                        ra->ra_state = CLOSED;
                        wakeup((caddr_t)ra);
                        return (EIO);
                }
        }
*/
        lp = &hplabel[unit];
        lp->d_secsize = DEV_BSIZE;

        lp->d_secsize = DEV_BSIZE;
        lp->d_secperunit = 15 /*ra->ra_dsize*/;

        if (flags & O_NDELAY)
                return (0);
        hp->hp_state = RDLABEL;
        /*
         * Set up default sizes until we have the label, or longer
         * if there is none.  Set secpercyl, as readdisklabel wants
         * to compute b_cylin (although we do not need it), and set
         * nsectors in case diskerr is called.
         */
        lp->d_secpercyl = 1;
        lp->d_npartitions = 1;
        lp->d_secsize = 512;
/*        lp->d_secperunit = ra->ra_dsize; */
        lp->d_nsectors = 15 /*ra->ra_geom.rg_nsectors*/;
        lp->d_partitions[0].p_size = lp->d_secperunit;
        lp->d_partitions[0].p_offset = 0;

        /*
         * Read pack label.
         */
        if ((msg = readdisklabel(hpminor(unit, 0), hpstrategy, lp)) != NULL) {
                if (cold)
                        printf(": %s", msg);
                else
                        log(LOG_ERR, "hp%d: %s", unit, msg);
/*                ra->ra_state = OPENRAW; */
/*                uda_makefakelabel(ra, lp); */
        } else
/*                ra->ra_state = OPEN; */
/*        wakeup((caddr_t)hp); */
        return (0);
d408 1
a408 5
 * Queue a transfer request, and if possible, hand it to the controller.
 *
 * This routine is broken into two so that the internal version
 * udastrat1() can be called by the (nonexistent, as yet) bad block
 * revectoring routine.
d410 22
a431 2
hpstrategy(bp)
        register struct buf *bp;
d433 2
a434 6
	register int unit;
	register struct uba_device *ui;
	register struct hp_info *hp;
	struct partition *pp;
	int p;
	daddr_t sz, maxsz;
d436 18
a453 16
	/*
	 * Make sure this is a reasonable drive to use.
	 */
/*	bp->b_error = ENXIO;
	goto bad;
*/
	unit = hpunit(bp->b_dev);

        /*
         * If drive is open `raw' or reading label, let it at it.
         */

	if (hp->hp_state < OPEN) {
		hpstrat1(bp);
		return;
	}
d455 7
d463 6
a468 63
/*	if ((unit = udaunit(bp->b_dev)) >= NRA ||
	    (ui = udadinfo[unit]) == NULL || ui->ui_alive == 0 ||
            (ra = &ra_info[unit])->ra_state == CLOSED) {
                bp->b_error = ENXIO;
                goto bad;
        }
*/
        /*
         * If drive is open `raw' or reading label, let it at it.
         */
/*
        if (ra->ra_state < OPEN) {
                udastrat1(bp);
                return;
        }
        p = udapart(bp->b_dev);
        if ((ra->ra_openpart & (1 << p)) == 0) {
                bp->b_error = ENODEV;
                goto bad;
        }
*/
        /*
         * Determine the size of the transfer, and make sure it is
         * within the boundaries of the partition.
         */
/*
        pp = &udalabel[unit].d_partitions[p];
        maxsz = pp->p_size;
        if (pp->p_offset + pp->p_size > ra->ra_dsize)
                maxsz = ra->ra_dsize - pp->p_offset;
        sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
        if (bp->b_blkno + pp->p_offset <= LABELSECTOR &&
#if LABELSECTOR != 0
            bp->b_blkno + pp->p_offset + sz > LABELSECTOR &&
#endif
            (bp->b_flags & B_READ) == 0 && ra->ra_wlabel == 0) {
                bp->b_error = EROFS;
                goto bad;
        }
        if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
                /* if exactly at end of disk, return an EOF */
/*
                if (bp->b_blkno == maxsz) {
                        bp->b_resid = bp->b_bcount;
                        biodone(bp);
                        return;
                }
                /* or truncate if part of it fits */
/*
                sz = maxsz - bp->b_blkno;
                if (sz <= 0) {
                        bp->b_error = EINVAL;   /* or hang it up */
/*
                        goto bad;
                }
                bp->b_bcount = sz << DEV_BSHIFT;
        }
        udastrat1(bp);
        return;
*/
bad:
        bp->b_flags |= B_ERROR;
        biodone(bp);
d472 1
a472 1
 * Work routine for udastrategy.
d474 3
a476 2
hpstrat1(bp)
        register struct buf *bp;
d478 14
a491 32
        register int unit = hpunit(bp->b_dev);
        register struct hp_ctlr *um;
        register struct buf *dp;
        struct hp_device *ui;
/*        int s = spl5(); */

	asm("halt");
        /*
         * Append the buffer to the drive queue, and if it is not
         * already there, the drive to the controller queue.  (However,
         * if the drive queue is marked to be requeued, we must be
         * awaiting an on line or get unit status command; in this
         * case, leave it off the controller queue.)
         */
/*
        um = (ui = udadinfo[unit])->ui_mi;
        dp = &udautab[unit];
        APPEND(bp, dp, av_forw);
        if (dp->b_active == 0 && (ui->ui_flags & UNIT_REQUEUE) == 0) {
                APPEND(dp, &um->um_tab, b_forw);
                dp->b_active++;
        }

        /*
         * Start activity on the controller.  Note that unlike other
         * Unibus drivers, we must always do this, not just when the
         * controller is not active.
         */
/*
        udastart(um);
        splx(s);
*/
d493 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
