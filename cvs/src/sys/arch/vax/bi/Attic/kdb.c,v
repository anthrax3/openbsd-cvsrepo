head	1.13;
access;
symbols
	OPENBSD_4_9:1.12.0.8
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.14
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.12
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.10
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.12
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2011.07.06.18.32.59;	author miod;	state dead;
branches;
next	1.12;

1.12
date	2009.06.02.20.58.38;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.11.10.06.55;	author pedro;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.10.17.59.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.17.20.26.14;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.09.20.26.44;	author jsyn;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.11.09.36.23;	author hugh;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.08.12.33.10;	author art;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.00.04.17;	author niklas;	state Exp;
branches
	1.2.12.1;
next	1.1;

1.1
date	97.01.15.23.24.14;	author maja;	state Exp;
branches;
next	;

1.2.12.1
date	2001.05.14.21.37.38;	author niklas;	state Exp;
branches;
next	1.2.12.2;

1.2.12.2
date	2001.10.31.03.08.00;	author nate;	state Exp;
branches;
next	1.2.12.3;

1.2.12.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.2.12.4;

1.2.12.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.2.12.5;

1.2.12.5
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.39.18;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@/*	$OpenBSD: kdb.c,v 1.12 2009/06/02 20:58:38 miod Exp $ */
/*	$NetBSD: kdb.c,v 1.26 2001/11/13 12:51:34 lukem Exp $ */
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * KDB50 disk device driver
 */
/*
 * TODO
 *   Implement node reset routine.
 *   Nices hardware error handling.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/sched.h>

#include <uvm/uvm_extern.h>

#ifdef __vax__
#include <machine/pte.h>
#include <machine/pcb.h>
#endif
#include <machine/bus.h>

#include <dev/bi/bireg.h>
#include <dev/bi/bivar.h>
#include <dev/bi/kdbreg.h>

#include <dev/mscp/mscp.h>
#include <dev/mscp/mscpreg.h>
#include <dev/mscp/mscpvar.h>

#define KDB_WL(adr, val) bus_space_write_4(sc->sc_iot, sc->sc_ioh, adr, val)
#define KDB_RL(adr) bus_space_read_4(sc->sc_iot, sc->sc_ioh, adr)
#define KDB_RS(adr) bus_space_read_2(sc->sc_iot, sc->sc_ioh, adr)

/*
 * Software status, per controller.
 */
struct	kdb_softc {
	struct	device sc_dev;		/* Autoconfig info */
	caddr_t	sc_kdb;			/* Struct for kdb communication */
	struct	mscp_softc *sc_softc;	/* MSCP info (per mscpvar.h) */
	bus_dma_tag_t sc_dmat;
	bus_dmamap_t sc_cmap;		/* Control structures */
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
};

int	kdbmatch(struct device *, struct cfdata *, void *);
void	kdbattach(struct device *, struct device *, void *);
void	kdbreset(int);
void	kdbintr(void *);
void	kdbctlrdone(struct device *);
int	kdbprint(void *, const char *);
void	kdbsaerror(struct device *, int);
void	kdbgo(struct device *, struct mscp_xi *);

struct	cfattach kdb_ca = {
	sizeof(struct kdb_softc), kdbmatch, kdbattach
};

/*
 * More driver definitions, for generic MSCP code.
 */
struct	mscp_ctlr kdb_mscp_ctlr = {
	kdbctlrdone,
	kdbgo,
	kdbsaerror,
};

int
kdbprint(aux, name)
	void	*aux;
	const char	*name;
{
	if (name)
		printf("%s: mscpbus", name);
	return UNCONF;
}

/*
 * Poke at a supposed KDB to see if it is there.
 */
int
kdbmatch(parent, cf, aux)
	struct	device *parent;
	struct	cfdata *cf;
	void	*aux;
{
	struct bi_attach_args *ba = aux;

	if (bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) != BIDT_KDB50)
		return 0;

	if (cf->cf_loc[BICF_NODE] != BICF_NODE_DEFAULT &&
	    cf->cf_loc[BICF_NODE] != ba->ba_nodenr)
		return 0;

	return 1;
}

void
kdbattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct	kdb_softc *sc = (void *)self;
	struct	bi_attach_args *ba = aux;
	struct	mscp_attach_args ma;
	volatile int i = 10000;
	int error, rseg;
	bus_dma_segment_t seg;

	printf("\n");
	bi_intr_establish(ba->ba_icookie, ba->ba_ivec, kdbintr, sc);

	sc->sc_iot = ba->ba_iot;
	sc->sc_ioh = ba->ba_ioh;
	sc->sc_dmat = ba->ba_dmat;

	/*
	 * Map the communication area and command and
	 * response packets into Unibus space.
	 */
	if ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct mscp_pack),
	    NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("Alloc ctrl area %d\n", error);
		return;
	}
	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
	    sizeof(struct mscp_pack), &sc->sc_kdb,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("Map ctrl area %d\n", error);
err:		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	if ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct mscp_pack),
	    1, sizeof(struct mscp_pack), 0, BUS_DMA_NOWAIT, &sc->sc_cmap))) {
		printf("Create DMA map %d\n", error);
err2:		bus_dmamem_unmap(sc->sc_dmat, sc->sc_kdb,
		    sizeof(struct mscp_pack));
		goto err;
	}
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_cmap, 
	    sc->sc_kdb, sizeof(struct mscp_pack), 0, BUS_DMA_NOWAIT))) {
		printf("Load ctrl map %d\n", error);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_cmap);
		goto err2;
	}
	memset(sc->sc_kdb, 0, sizeof(struct mscp_pack));

	ma.ma_mc = &kdb_mscp_ctlr;
	ma.ma_type = MSCPBUS_DISK|MSCPBUS_KDB;
	ma.ma_uda = (struct mscp_pack *)sc->sc_kdb;
	ma.ma_softc = &sc->sc_softc;
	ma.ma_iot = sc->sc_iot;
	ma.ma_iph = sc->sc_ioh + KDB_IP;
	ma.ma_sah = sc->sc_ioh + KDB_SA;
	ma.ma_swh = sc->sc_ioh + KDB_SW;
	ma.ma_dmat = sc->sc_dmat;
	ma.ma_dmam = sc->sc_cmap;
	ma.ma_ivec = ba->ba_ivec;
	ma.ma_ctlrnr = ba->ba_nodenr;
	ma.ma_adapnr = ba->ba_busnr;

	KDB_WL(BIREG_VAXBICSR, KDB_RL(BIREG_VAXBICSR) | BICSR_NRST);
	while (i--) /* Need delay??? */
		;
	KDB_WL(BIREG_INTRDES, ba->ba_intcpu); /* Interrupt on CPU # */
	KDB_WL(BIREG_BCICSR, KDB_RL(BIREG_BCICSR) |
	    BCI_STOPEN | BCI_IDENTEN | BCI_UINTEN | BCI_INTEN);
	KDB_WL(BIREG_UINTRCSR, ba->ba_ivec);
	config_found(&sc->sc_dev, &ma, kdbprint);
}

void
kdbgo(usc, mxi)
	struct device *usc;
	struct mscp_xi *mxi;
{
	struct kdb_softc *sc = (void *)usc;
	struct buf *bp = mxi->mxi_bp;
	struct mscp *mp = mxi->mxi_mp;
	u_int32_t addr = (u_int32_t)bp->b_data;
	u_int32_t mapaddr;
	int err;

	/*
	 * The KDB50 wants to read VAX Page tables directly, therefore
	 * the result from bus_dmamap_load() is uninteresting. (But it
	 * should never fail!).
	 *
	 * On VAX, point to the corresponding page tables. (user/sys)
	 * On other systems, do something else... 
	 */
	err = bus_dmamap_load(sc->sc_dmat, mxi->mxi_dmam, bp->b_data,
	    bp->b_bcount, (bp->b_flags & B_PHYS ? bp->b_proc : 0),
	    BUS_DMA_NOWAIT);

	if (err) /* Shouldn't happen */
		panic("kdbgo: bus_dmamap_load: error %d", err);

#ifdef __vax__
	/*
	 * Get a pointer to the pte pointing out the first virtual address.
	 * Use different ways in kernel and user space.
	 */
	if ((bp->b_flags & B_PHYS) == 0) {
		mapaddr = ((u_int32_t)kvtopte(addr)) & ~KERNBASE;
	} else {
		struct pcb *pcb;
		u_int32_t eaddr;

		/*
		 * We check if the PTE's needed crosses a page boundary.
		 * If they do; only transfer the amount of data that is
		 * mapped by the first PTE page and led the system handle
		 * the rest of the data.
		 */
		pcb = &bp->b_proc->p_addr->u_pcb;
		mapaddr = (u_int32_t)uvtopte(addr, pcb);
		eaddr = (u_int32_t)uvtopte(addr + (bp->b_bcount - 1), pcb);
		if (trunc_page(mapaddr) != trunc_page(eaddr)) {
			mp->mscp_seq.seq_bytecount =
			    (((round_page(mapaddr) - mapaddr)/4) * 512);
		}
		mapaddr = kvtophys(mapaddr);
	}
#else
#error Must write code to handle KDB50 on non-vax.
#endif

	mp->mscp_seq.seq_mapbase = mapaddr;
	mxi->mxi_dmam->dm_segs[0].ds_addr = (addr & 511) | KDB_MAP;
	mscp_dgo(sc->sc_softc, mxi);
}

void
kdbsaerror(usc, doreset)
	struct device *usc;
	int doreset;
{
	struct	kdb_softc *sc = (void *)usc;

	if ((KDB_RS(KDB_SA) & MP_ERR) == 0)
		return;
	printf("%s: controller error, sa=0x%x\n", sc->sc_dev.dv_xname,
	    KDB_RS(KDB_SA));
	/* What to do now??? */
}

/*
 * Interrupt routine.  Depending on the state of the controller,
 * continue initialisation, or acknowledge command and response
 * interrupts, and process responses.
 */
void
kdbintr(void *arg)
{
	struct kdb_softc *sc = arg;

	if (KDB_RS(KDB_SA) & MP_ERR) {	/* ctlr fatal error */
		kdbsaerror(&sc->sc_dev, 1);
		return;
	}
	KERNEL_LOCK();
	mscp_intr(sc->sc_softc);
	KERNEL_UNLOCK();
}

#ifdef notyet
/*
 * The KDB50 has been reset.  Reinitialise the controller
 * and requeue outstanding I/O.
 */
void
kdbreset(ctlr)
	int ctlr;
{
	struct kdb_softc *sc;

	sc = kdb_cd.cd_devs[ctlr];
	printf(" kdb%d", ctlr);


	/* reset queues and requeue pending transfers */
	mscp_requeue(sc->sc_softc);

	/*
	 * If it fails to initialise we will notice later and
	 * try again (and again...).  Do not call kdbstart()
	 * here; it will be done after the controller finishes
	 * initialisation.
	 */
	if (kdbinit(sc))
		printf(" (hung)");
}
#endif

void
kdbctlrdone(usc)
	struct device *usc;
{
}
@


1.12
log
@Remove unused b_forw defines which make beck@@ scream like a little girl
and disturb everyone's peace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.11 2007/05/11 10:06:55 pedro Exp $ */
@


1.11
log
@Don't use LK_CANRECURSE for the kernel lock, okay miod@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.10 2007/05/10 17:59:26 deraadt Exp $ */
a72 1
#define	    b_forw  b_hash.le_next
@


1.10
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.9 2006/01/17 20:26:14 miod Exp $ */
d304 1
a304 1
	KERNEL_LOCK(LK_CANRECURSE|LK_EXCLUSIVE);
@


1.9
log
@Use angle bracket and no relative paths for all include files which are not
created by config(8); no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.8 2002/08/09 20:26:44 jsyn Exp $ */
a78 1
	struct	evcnt sc_intrcnt;	/* Interrupt counting */
d153 1
a153 4
	bi_intr_establish(ba->ba_icookie, ba->ba_ivec,
		kdbintr, sc, &sc->sc_intrcnt);
	evcnt_attach_dynamic(&sc->sc_intrcnt, EVCNT_TYPE_INTR, NULL,
		sc->sc_dev.dv_xname, "intr");
@


1.8
log
@Get rid of remaining __P usage (except for imported code);
ok millert@@, rogue ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.7 2002/06/11 09:36:23 hugh Exp $ */
a42 3
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: kdb.c,v 1.26 2001/11/13 12:51:34 lukem Exp $");

a67 2

#include "locators.h"
@


1.7
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d93 8
a100 8
int	kdbmatch __P((struct device *, struct cfdata *, void *));
void	kdbattach __P((struct device *, struct device *, void *));
void	kdbreset __P((int));
void	kdbintr __P((void *));
void	kdbctlrdone __P((struct device *));
int	kdbprint __P((void *, const char *));
void	kdbsaerror __P((struct device *, int));
void	kdbgo __P((struct device *, struct mscp_xi *));
@


1.6
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: kdb.c,v 1.5 2001/11/06 19:53:17 miod Exp $ */
/*	$NetBSD: kdb.c,v 1.5 1997/01/11 11:34:39 ragge Exp $ */
d17 2
a18 2
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
d43 3
d51 1
d53 2
d58 1
a58 1
#include <machine/sid.h>
d61 10
a70 2
#include <machine/trap.h>
#include <machine/scb.h>
d72 1
a72 7
#include <vax/bi/bireg.h>
#include <vax/bi/bivar.h>
#include <vax/bi/kdbreg.h>

#include <vax/mscp/mscp.h>
#include <vax/mscp/mscpvar.h>
#include <vax/mscp/mscpreg.h>
d74 5
a78 1
#define     b_forw  b_hash.le_next
d84 2
a85 2
	struct	ivec_dsp sc_ivec;	/* Interrupt vector handler */
	struct	mscp_pack sc_kdb;	/* Struct for kdb communication */
d87 4
a90 2
	struct	kdb_regs *sc_kr;	/* KDB controller registers */
	struct	mscp *sc_mscp;		/* Keep pointer to active mscp */
d93 8
a100 12
int	kdbmatch(struct device *, void *, void *);
void	kdbattach(struct device *, struct device *, void *);
void	kdbreset(int);
void	kdbintr(int);
void	kdbctlrdone(struct device *, int);
int	kdbprint(void *, const char *);
void	kdbsaerror(struct device *, int);
int	kdbgo(struct device *, struct buf *);

struct	cfdriver kdb_cd = {
	NULL, "kdb", DV_DULL
};
d129 1
a129 1
kdbmatch(parent, match, aux)
d131 2
a132 1
	void	*match, *aux;
a133 1
	struct  cfdata *cf = match;
d136 2
a137 2
        if (ba->ba_node->biic.bi_dtype != BIDT_KDB50)
                return 0;
d139 3
a141 2
        if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != ba->ba_nodenr)
                return 0;
d143 1
a143 1
        return 1;
a153 1
	extern  struct ivec_dsp idsptch;
d155 2
d159 8
a166 5
	bcopy(&idsptch, &sc->sc_ivec, sizeof(struct ivec_dsp));
	scb->scb_nexvec[1][ba->ba_nodenr] = &sc->sc_ivec;
	sc->sc_ivec.hoppaddr = kdbintr;
	sc->sc_ivec.pushlarg = self->dv_unit;
	sc->sc_kr = (void *)ba->ba_node;
d168 30
a197 1
	bzero(&sc->sc_kdb, sizeof (struct mscp_pack));
d201 1
a201 5
	ma.ma_uuda = (struct mscp_pack *)kvtophys(&sc->sc_kdb);
	ma.ma_uda = &sc->sc_kdb;
	ma.ma_ip = &sc->sc_kr->kdb_ip;
	ma.ma_sa = &sc->sc_kr->kdb_sa;
	ma.ma_sw = &sc->sc_kr->kdb_sw;
d203 7
a209 1
	ma.ma_ivec = (int)&scb->scb_nexvec[1][ba->ba_nodenr] - (int)scb;
d211 3
a213 1
	sc->sc_kr->kdb_bi.bi_csr |= BICSR_NRST;
d216 4
a219 4
	sc->sc_kr->kdb_bi.bi_intrdes = ba->ba_intcpu;
	sc->sc_kr->kdb_bi.bi_bcicsr |= BCI_STOPEN | BCI_IDENTEN | BCI_UINTEN |
	    BCI_INTEN;
	sc->sc_kr->kdb_bi.bi_uintrcsr = ma.ma_ivec;
d223 2
a224 2
int
kdbgo(usc, bp)
d226 1
a226 1
	struct buf *bp;
d229 22
a250 38
	struct mscp_softc *mi = sc->sc_softc;
	struct mscp *mp = (void *)bp->b_actb;
        struct  pcb *pcb;
        pt_entry_t *pte;
        int     pfnum, npf, o, i;
	unsigned info = 0;
        caddr_t addr;

	o = (int)bp->b_un.b_addr & PGOFSET;
	npf = btoc(bp->b_bcount + o) + 1;
	addr = bp->b_un.b_addr;

        /*
         * Get a pointer to the pte pointing out the first virtual address.
         * Use different ways in kernel and user space.
         */
        if ((bp->b_flags & B_PHYS) == 0) {
                pte = kvtopte(addr);
        } else {
                pcb = bp->b_proc->p_vmspace->vm_map.pmap->pm_pcb;
                pte = uvtopte(addr, pcb);
        }

        /*
         * When we are doing DMA to user space, be sure that all pages
         * we want to transfer to is mapped. WHY DO WE NEED THIS???
         * SHOULDN'T THEY ALWAYS BE MAPPED WHEN DOING THIS???
         */
        for (i = 0; i < (npf - 1); i++) {
                if ((pte + i)->pg_pfn == 0) {
                        int rv;
                        rv = vm_fault(&bp->b_proc->p_vmspace->vm_map,
                            (unsigned)addr + i * NBPG,
                            VM_PROT_READ|VM_PROT_WRITE, FALSE);
                        if (rv)
                                panic("KDB DMA to nonexistent page, %d", rv);
                }
        }
d252 2
a253 5
	 * pte's for userspace isn't necessary positioned
	 * in consecutive physical pages. We check if they 
	 * are, otherwise we need to copy the pte's to a
	 * physically contigouos page area.
	 * XXX some copying here may be unneccessary. Subject to fix.
d255 18
a272 9
	if (bp->b_flags & B_PHYS) {
		int i = kvtophys(pte);
		unsigned k;

		if (trunc_page(i) != trunc_page(kvtophys(pte) + npf * 4)) {
			info = (unsigned)malloc(2 * NBPG, M_DEVBUF, M_WAITOK);
			k = (info + PGOFSET) & ~PGOFSET;
			bcopy(pte, (void *)k, NBPG);
			i = kvtophys(k);
d274 9
a282 5
		mp->mscp_seq.seq_mapbase = i;
	} else
		mp->mscp_seq.seq_mapbase = (unsigned)pte;
	mscp_dgo(mi, KDB_MAP | o, info, bp);
	return 1;
a290 1
	register int code = sc->sc_kr->kdb_sa;
d292 1
a292 1
	if ((code & MP_ERR) == 0)
d294 2
a295 1
	printf("%s: controller error, sa=0x%x\n", sc->sc_dev.dv_xname, code);
d305 1
a305 2
kdbintr(ctlr)
	int	ctlr;
d307 1
a307 3
	struct kdb_softc *sc = kdb_cd.cd_devs[ctlr];
	struct	uba_softc *uh;
	struct mscp_pack *ud;
d309 1
a309 1
	if (sc->sc_kr->kdb_sa & MP_ERR) {	/* ctlr fatal error */
d313 1
d315 1
d327 1
a327 1
	register struct kdb_softc *sc;
d348 1
a348 1
kdbctlrdone(usc, info)
a349 1
	int info;
a350 2
	if (info)
		free((void *)info, NBPG * 2);
@


1.5
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.4 2001/09/11 20:05:25 miod Exp $ */
d79 8
a86 8
int	kdbmatch __P((struct device *, void *, void *));
void	kdbattach __P((struct device *, struct device *, void *));
void	kdbreset __P((int));
void	kdbintr __P((int));
void	kdbctlrdone __P((struct device *, int));
int	kdbprint __P((void *, const char *));
void	kdbsaerror __P((struct device *, int));
int	kdbgo __P((struct device *, struct buf *));
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.5 2001/11/06 19:53:17 miod Exp $ */
d79 8
a86 8
int	kdbmatch(struct device *, void *, void *);
void	kdbattach(struct device *, struct device *, void *);
void	kdbreset(int);
void	kdbintr(int);
void	kdbctlrdone(struct device *, int);
int	kdbprint(void *, const char *);
void	kdbsaerror(struct device *, int);
int	kdbgo(struct device *, struct buf *);
@


1.5.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: kdb.c,v 1.26 2001/11/13 12:51:34 lukem Exp $ */
d17 2
a18 2
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
a42 3
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: kdb.c,v 1.26 2001/11/13 12:51:34 lukem Exp $");

a47 1
#include <sys/user.h>
a48 2
#include <sys/systm.h>
#include <sys/sched.h>
d52 1
a52 1
#ifdef __vax__
d55 2
a56 10
#endif
#include <machine/bus.h>

#include <dev/bi/bireg.h>
#include <dev/bi/bivar.h>
#include <dev/bi/kdbreg.h>

#include <dev/mscp/mscp.h>
#include <dev/mscp/mscpreg.h>
#include <dev/mscp/mscpvar.h>
d58 7
a64 1
#include "locators.h"
d66 1
a66 5
#define KDB_WL(adr, val) bus_space_write_4(sc->sc_iot, sc->sc_ioh, adr, val)
#define KDB_RL(adr) bus_space_read_4(sc->sc_iot, sc->sc_ioh, adr)
#define KDB_RS(adr) bus_space_read_2(sc->sc_iot, sc->sc_ioh, adr)

#define	    b_forw  b_hash.le_next
d72 2
a73 2
	struct	evcnt sc_intrcnt;	/* Interrupt counting */
	caddr_t	sc_kdb;			/* Struct for kdb communication */
d75 2
a76 4
	bus_dma_tag_t sc_dmat;
	bus_dmamap_t sc_cmap;		/* Control structures */
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
d79 1
a79 1
int	kdbmatch(struct device *, struct cfdata *, void *);
d82 2
a83 2
void	kdbintr(void *);
void	kdbctlrdone(struct device *);
d86 5
a90 1
void	kdbgo(struct device *, struct mscp_xi *);
d119 1
a119 1
kdbmatch(parent, cf, aux)
d121 1
a121 2
	struct	cfdata *cf;
	void	*aux;
d123 1
d126 2
a127 2
	if (bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) != BIDT_KDB50)
		return 0;
d129 2
a130 3
	if (cf->cf_loc[BICF_NODE] != BICF_NODE_DEFAULT &&
	    cf->cf_loc[BICF_NODE] != ba->ba_nodenr)
		return 0;
d132 1
a132 1
	return 1;
d143 1
a144 2
	int error, rseg;
	bus_dma_segment_t seg;
d147 5
a151 8
	bi_intr_establish(ba->ba_icookie, ba->ba_ivec,
		kdbintr, sc, &sc->sc_intrcnt);
	evcnt_attach_dynamic(&sc->sc_intrcnt, EVCNT_TYPE_INTR, NULL,
		sc->sc_dev.dv_xname, "intr");

	sc->sc_iot = ba->ba_iot;
	sc->sc_ioh = ba->ba_ioh;
	sc->sc_dmat = ba->ba_dmat;
d153 1
a153 30
	/*
	 * Map the communication area and command and
	 * response packets into Unibus space.
	 */
	if ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct mscp_pack),
	    NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("Alloc ctrl area %d\n", error);
		return;
	}
	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
	    sizeof(struct mscp_pack), &sc->sc_kdb,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("Map ctrl area %d\n", error);
err:		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	if ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct mscp_pack),
	    1, sizeof(struct mscp_pack), 0, BUS_DMA_NOWAIT, &sc->sc_cmap))) {
		printf("Create DMA map %d\n", error);
err2:		bus_dmamem_unmap(sc->sc_dmat, sc->sc_kdb,
		    sizeof(struct mscp_pack));
		goto err;
	}
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_cmap, 
	    sc->sc_kdb, sizeof(struct mscp_pack), 0, BUS_DMA_NOWAIT))) {
		printf("Load ctrl map %d\n", error);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_cmap);
		goto err2;
	}
	memset(sc->sc_kdb, 0, sizeof(struct mscp_pack));
d157 5
a161 1
	ma.ma_uda = (struct mscp_pack *)sc->sc_kdb;
d163 1
a163 7
	ma.ma_iot = sc->sc_iot;
	ma.ma_iph = sc->sc_ioh + KDB_IP;
	ma.ma_sah = sc->sc_ioh + KDB_SA;
	ma.ma_swh = sc->sc_ioh + KDB_SW;
	ma.ma_dmat = sc->sc_dmat;
	ma.ma_dmam = sc->sc_cmap;
	ma.ma_ivec = ba->ba_ivec;
d165 1
a165 3
	ma.ma_adapnr = ba->ba_busnr;

	KDB_WL(BIREG_VAXBICSR, KDB_RL(BIREG_VAXBICSR) | BICSR_NRST);
d168 4
a171 4
	KDB_WL(BIREG_INTRDES, ba->ba_intcpu); /* Interrupt on CPU # */
	KDB_WL(BIREG_BCICSR, KDB_RL(BIREG_BCICSR) |
	    BCI_STOPEN | BCI_IDENTEN | BCI_UINTEN | BCI_INTEN);
	KDB_WL(BIREG_UINTRCSR, ba->ba_ivec);
d175 2
a176 2
void
kdbgo(usc, mxi)
d178 1
a178 1
	struct mscp_xi *mxi;
d181 38
a218 22
	struct buf *bp = mxi->mxi_bp;
	struct mscp *mp = mxi->mxi_mp;
	u_int32_t addr = (u_int32_t)bp->b_data;
	u_int32_t mapaddr;
	int err;

	/*
	 * The KDB50 wants to read VAX Page tables directly, therefore
	 * the result from bus_dmamap_load() is uninteresting. (But it
	 * should never fail!).
	 *
	 * On VAX, point to the corresponding page tables. (user/sys)
	 * On other systems, do something else... 
	 */
	err = bus_dmamap_load(sc->sc_dmat, mxi->mxi_dmam, bp->b_data,
	    bp->b_bcount, (bp->b_flags & B_PHYS ? bp->b_proc : 0),
	    BUS_DMA_NOWAIT);

	if (err) /* Shouldn't happen */
		panic("kdbgo: bus_dmamap_load: error %d", err);

#ifdef __vax__
d220 5
a224 2
	 * Get a pointer to the pte pointing out the first virtual address.
	 * Use different ways in kernel and user space.
d226 9
a234 18
	if ((bp->b_flags & B_PHYS) == 0) {
		mapaddr = ((u_int32_t)kvtopte(addr)) & ~KERNBASE;
	} else {
		struct pcb *pcb;
		u_int32_t eaddr;

		/*
		 * We check if the PTE's needed crosses a page boundary.
		 * If they do; only transfer the amount of data that is
		 * mapped by the first PTE page and led the system handle
		 * the rest of the data.
		 */
		pcb = &bp->b_proc->p_addr->u_pcb;
		mapaddr = (u_int32_t)uvtopte(addr, pcb);
		eaddr = (u_int32_t)uvtopte(addr + (bp->b_bcount - 1), pcb);
		if (trunc_page(mapaddr) != trunc_page(eaddr)) {
			mp->mscp_seq.seq_bytecount =
			    (((round_page(mapaddr) - mapaddr)/4) * 512);
d236 5
a240 9
		mapaddr = kvtophys(mapaddr);
	}
#else
#error Must write code to handle KDB50 on non-vax.
#endif

	mp->mscp_seq.seq_mapbase = mapaddr;
	mxi->mxi_dmam->dm_segs[0].ds_addr = (addr & 511) | KDB_MAP;
	mscp_dgo(sc->sc_softc, mxi);
d249 1
d251 1
a251 1
	if ((KDB_RS(KDB_SA) & MP_ERR) == 0)
d253 1
a253 2
	printf("%s: controller error, sa=0x%x\n", sc->sc_dev.dv_xname,
	    KDB_RS(KDB_SA));
d263 2
a264 1
kdbintr(void *arg)
d266 3
a268 1
	struct kdb_softc *sc = arg;
d270 1
a270 1
	if (KDB_RS(KDB_SA) & MP_ERR) {	/* ctlr fatal error */
a273 1
	KERNEL_LOCK(LK_CANRECURSE|LK_EXCLUSIVE);
a274 1
	KERNEL_UNLOCK();
d286 1
a286 1
	struct kdb_softc *sc;
d307 1
a307 1
kdbctlrdone(usc)
d309 1
d311 2
@


1.4
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.3 2000/06/08 12:33:10 art Exp $ */
d50 1
a50 1
#include <vm/vm.h>
@


1.3
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.2 1997/05/29 00:04:17 niklas Exp $ */
a50 1
#include <vm/vm_kern.h>
@


1.2
log
@RCS tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.5 1997/01/11 11:34:39 ragge Exp $ */
d201 1
a201 1
                pcb = bp->b_proc->p_vmspace->vm_pmap.pm_pcb;
@


1.2.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.3 2000/06/08 12:33:10 art Exp $ */
d201 1
a201 1
                pcb = bp->b_proc->p_vmspace->vm_map.pmap->pm_pcb;
@


1.2.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kdb.c,v 1.2.12.1 2001/05/14 21:37:38 niklas Exp $ */
d51 1
@


1.2.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d50 1
a50 1
#include <uvm/uvm_extern.h>
@


1.2.12.4
log
@Merge in -current from about a week ago
@
text
@d79 8
a86 8
int	kdbmatch(struct device *, void *, void *);
void	kdbattach(struct device *, struct device *, void *);
void	kdbreset(int);
void	kdbintr(int);
void	kdbctlrdone(struct device *, int);
int	kdbprint(void *, const char *);
void	kdbsaerror(struct device *, int);
int	kdbgo(struct device *, struct buf *);
@


1.2.12.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: kdb.c,v 1.26 2001/11/13 12:51:34 lukem Exp $ */
d17 2
a18 2
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
a42 3
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: kdb.c,v 1.26 2001/11/13 12:51:34 lukem Exp $");

a47 1
#include <sys/user.h>
a48 2
#include <sys/systm.h>
#include <sys/sched.h>
d52 1
a52 1
#ifdef __vax__
d55 2
a56 10
#endif
#include <machine/bus.h>

#include <dev/bi/bireg.h>
#include <dev/bi/bivar.h>
#include <dev/bi/kdbreg.h>

#include <dev/mscp/mscp.h>
#include <dev/mscp/mscpreg.h>
#include <dev/mscp/mscpvar.h>
d58 7
a64 1
#include "locators.h"
d66 1
a66 5
#define KDB_WL(adr, val) bus_space_write_4(sc->sc_iot, sc->sc_ioh, adr, val)
#define KDB_RL(adr) bus_space_read_4(sc->sc_iot, sc->sc_ioh, adr)
#define KDB_RS(adr) bus_space_read_2(sc->sc_iot, sc->sc_ioh, adr)

#define	    b_forw  b_hash.le_next
d72 2
a73 2
	struct	evcnt sc_intrcnt;	/* Interrupt counting */
	caddr_t	sc_kdb;			/* Struct for kdb communication */
d75 2
a76 4
	bus_dma_tag_t sc_dmat;
	bus_dmamap_t sc_cmap;		/* Control structures */
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
d79 1
a79 1
int	kdbmatch(struct device *, struct cfdata *, void *);
d82 2
a83 2
void	kdbintr(void *);
void	kdbctlrdone(struct device *);
d86 5
a90 1
void	kdbgo(struct device *, struct mscp_xi *);
d119 1
a119 1
kdbmatch(parent, cf, aux)
d121 1
a121 2
	struct	cfdata *cf;
	void	*aux;
d123 1
d126 2
a127 2
	if (bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) != BIDT_KDB50)
		return 0;
d129 2
a130 3
	if (cf->cf_loc[BICF_NODE] != BICF_NODE_DEFAULT &&
	    cf->cf_loc[BICF_NODE] != ba->ba_nodenr)
		return 0;
d132 1
a132 1
	return 1;
d143 1
a144 2
	int error, rseg;
	bus_dma_segment_t seg;
d147 5
a151 8
	bi_intr_establish(ba->ba_icookie, ba->ba_ivec,
		kdbintr, sc, &sc->sc_intrcnt);
	evcnt_attach_dynamic(&sc->sc_intrcnt, EVCNT_TYPE_INTR, NULL,
		sc->sc_dev.dv_xname, "intr");

	sc->sc_iot = ba->ba_iot;
	sc->sc_ioh = ba->ba_ioh;
	sc->sc_dmat = ba->ba_dmat;
d153 1
a153 30
	/*
	 * Map the communication area and command and
	 * response packets into Unibus space.
	 */
	if ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct mscp_pack),
	    NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("Alloc ctrl area %d\n", error);
		return;
	}
	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
	    sizeof(struct mscp_pack), &sc->sc_kdb,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("Map ctrl area %d\n", error);
err:		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	if ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct mscp_pack),
	    1, sizeof(struct mscp_pack), 0, BUS_DMA_NOWAIT, &sc->sc_cmap))) {
		printf("Create DMA map %d\n", error);
err2:		bus_dmamem_unmap(sc->sc_dmat, sc->sc_kdb,
		    sizeof(struct mscp_pack));
		goto err;
	}
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_cmap, 
	    sc->sc_kdb, sizeof(struct mscp_pack), 0, BUS_DMA_NOWAIT))) {
		printf("Load ctrl map %d\n", error);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_cmap);
		goto err2;
	}
	memset(sc->sc_kdb, 0, sizeof(struct mscp_pack));
d157 5
a161 1
	ma.ma_uda = (struct mscp_pack *)sc->sc_kdb;
d163 1
a163 7
	ma.ma_iot = sc->sc_iot;
	ma.ma_iph = sc->sc_ioh + KDB_IP;
	ma.ma_sah = sc->sc_ioh + KDB_SA;
	ma.ma_swh = sc->sc_ioh + KDB_SW;
	ma.ma_dmat = sc->sc_dmat;
	ma.ma_dmam = sc->sc_cmap;
	ma.ma_ivec = ba->ba_ivec;
d165 1
a165 3
	ma.ma_adapnr = ba->ba_busnr;

	KDB_WL(BIREG_VAXBICSR, KDB_RL(BIREG_VAXBICSR) | BICSR_NRST);
d168 4
a171 4
	KDB_WL(BIREG_INTRDES, ba->ba_intcpu); /* Interrupt on CPU # */
	KDB_WL(BIREG_BCICSR, KDB_RL(BIREG_BCICSR) |
	    BCI_STOPEN | BCI_IDENTEN | BCI_UINTEN | BCI_INTEN);
	KDB_WL(BIREG_UINTRCSR, ba->ba_ivec);
d175 2
a176 2
void
kdbgo(usc, mxi)
d178 1
a178 1
	struct mscp_xi *mxi;
d181 38
a218 22
	struct buf *bp = mxi->mxi_bp;
	struct mscp *mp = mxi->mxi_mp;
	u_int32_t addr = (u_int32_t)bp->b_data;
	u_int32_t mapaddr;
	int err;

	/*
	 * The KDB50 wants to read VAX Page tables directly, therefore
	 * the result from bus_dmamap_load() is uninteresting. (But it
	 * should never fail!).
	 *
	 * On VAX, point to the corresponding page tables. (user/sys)
	 * On other systems, do something else... 
	 */
	err = bus_dmamap_load(sc->sc_dmat, mxi->mxi_dmam, bp->b_data,
	    bp->b_bcount, (bp->b_flags & B_PHYS ? bp->b_proc : 0),
	    BUS_DMA_NOWAIT);

	if (err) /* Shouldn't happen */
		panic("kdbgo: bus_dmamap_load: error %d", err);

#ifdef __vax__
d220 5
a224 2
	 * Get a pointer to the pte pointing out the first virtual address.
	 * Use different ways in kernel and user space.
d226 9
a234 18
	if ((bp->b_flags & B_PHYS) == 0) {
		mapaddr = ((u_int32_t)kvtopte(addr)) & ~KERNBASE;
	} else {
		struct pcb *pcb;
		u_int32_t eaddr;

		/*
		 * We check if the PTE's needed crosses a page boundary.
		 * If they do; only transfer the amount of data that is
		 * mapped by the first PTE page and led the system handle
		 * the rest of the data.
		 */
		pcb = &bp->b_proc->p_addr->u_pcb;
		mapaddr = (u_int32_t)uvtopte(addr, pcb);
		eaddr = (u_int32_t)uvtopte(addr + (bp->b_bcount - 1), pcb);
		if (trunc_page(mapaddr) != trunc_page(eaddr)) {
			mp->mscp_seq.seq_bytecount =
			    (((round_page(mapaddr) - mapaddr)/4) * 512);
d236 5
a240 9
		mapaddr = kvtophys(mapaddr);
	}
#else
#error Must write code to handle KDB50 on non-vax.
#endif

	mp->mscp_seq.seq_mapbase = mapaddr;
	mxi->mxi_dmam->dm_segs[0].ds_addr = (addr & 511) | KDB_MAP;
	mscp_dgo(sc->sc_softc, mxi);
d249 1
d251 1
a251 1
	if ((KDB_RS(KDB_SA) & MP_ERR) == 0)
d253 1
a253 2
	printf("%s: controller error, sa=0x%x\n", sc->sc_dev.dv_xname,
	    KDB_RS(KDB_SA));
d263 2
a264 1
kdbintr(void *arg)
d266 3
a268 1
	struct kdb_softc *sc = arg;
d270 1
a270 1
	if (KDB_RS(KDB_SA) & MP_ERR) {	/* ctlr fatal error */
a273 1
	KERNEL_LOCK(LK_CANRECURSE|LK_EXCLUSIVE);
a274 1
	KERNEL_UNLOCK();
d286 1
a286 1
	struct kdb_softc *sc;
d307 1
a307 1
kdbctlrdone(usc)
d309 1
d311 2
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
