head	1.16;
access;
symbols
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.6
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	SMP:1.3.0.6
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	UBC:1.3.0.2
	UBC_SYNC_B:1.3
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2011.07.06.18.32.58;	author miod;	state dead;
branches;
next	1.15;

1.15
date	2010.09.20.07.40.41;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.08.23.53.08;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.11.10.06.55;	author pedro;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.10.17.59.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.17.20.26.14;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.07.23.10.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.13.25.48;	author miod;	state Exp;
branches
	1.3.2.1
	1.3.6.1;
next	1.2;

1.2
date	2002.08.09.20.26.44;	author jsyn;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.11.09.36.23;	author hugh;	state Exp;
branches;
next	;

1.3.2.1
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;

1.3.6.1
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@/*	$OpenBSD: if_ni.c,v 1.15 2010/09/20 07:40:41 deraadt Exp $ */
/*	$NetBSD: if_ni.c,v 1.15 2002/05/22 16:03:14 wiz Exp $ */
/*
 * Copyright (c) 2000 Ludd, University of Lule}, Sweden. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for DEBNA/DEBNT/DEBNK ethernet cards.
 * Things that is still to do:
 *	Collect statistics.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/sched.h>

#include <net/if.h>
#include <net/if_ether.h>
#include <net/if_dl.h>

#include <netinet/in.h>
#include <netinet/if_inarp.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

#include <machine/bus.h>
#ifdef __vax__
#include <machine/mtpr.h>
#include <machine/pte.h>
#endif

#include <dev/bi/bireg.h>
#include <dev/bi/bivar.h>

/*
 * Tunable buffer parameters. Good idea to have them as power of 8; then
 * they will fit into a logical VAX page.
 */
#define NMSGBUF		8	/* Message queue entries */
#define NTXBUF		16	/* Transmit queue entries */
#define NTXFRAGS	8	/* Number of transmit buffer fragments */
#define NRXBUF		24	/* Receive queue entries */
#define NBDESCS		(NTXBUF * NTXFRAGS + NRXBUF)
#define NQUEUES		3	/* RX + TX + MSG */
#define PKTHDR		18	/* Length of (control) packet header */
#define RXADD		18	/* Additional length of receive datagram */
#define TXADD		(10+NTXFRAGS*8) /*	""	transmit   ""	 */
#define MSGADD		134	/*		""	message	   ""	 */

#include <dev/bi/if_nireg.h>	/* XXX include earlier */

/*
 * Macros for (most cases of) insqti/remqhi.
 * Retry NRETRIES times to do the operation, if it still fails assume
 * a lost lock and panic.
 */
#define	NRETRIES	100
#define	INSQTI(e, h)	({						\
	int ret, i;							\
	for (i = 0; i < NRETRIES; i++) {				\
		if ((ret = insqti(e, h)) != ILCK_FAILED)		\
			break;						\
	}								\
	if (i == NRETRIES)						\
		panic("ni: insqti failed at %d", __LINE__);		\
	ret;								\
})
#define	REMQHI(h)	({						\
	int i;void *ret;						\
	for (i = 0; i < NRETRIES; i++) {				\
		if ((ret = remqhi(h)) != (void *)ILCK_FAILED)		\
			break;						\
	}								\
	if (i == NRETRIES)						\
		panic("ni: remqhi failed at %d", __LINE__);		\
	ret;								\
})


#define nipqb	(&sc->sc_gvppqb->nc_pqb)
#define gvp	sc->sc_gvppqb
#define fqb	sc->sc_fqb
#define bbd	sc->sc_bbd

struct	ni_softc {
	struct device	sc_dev;		/* Configuration common part	*/
	struct ethercom sc_ec;		/* Ethernet common part		*/
#define sc_if	sc_ec.ec_if		/* network-visible interface	*/
	bus_space_tag_t sc_iot;
	bus_addr_t	sc_ioh;
	bus_dma_tag_t	sc_dmat;
	struct ni_gvppqb *sc_gvppqb;	/* Port queue block		*/
	struct ni_gvppqb *sc_pgvppqb;	/* Phys address of PQB		*/
	struct ni_fqb	*sc_fqb;	/* Free Queue block		*/
	struct ni_bbd	*sc_bbd;	/* Buffer descriptors		*/
	u_int8_t	sc_enaddr[ETHER_ADDR_LEN];
};

static	int	nimatch(struct device *, struct cfdata *, void *);
static	void	niattach(struct device *, struct device *, void *);
static	void	niinit(struct ni_softc *);
static	void	nistart(struct ifnet *);
static	void	niintr(void *);
static	int	niioctl(struct ifnet *, u_long, caddr_t);
static	int	ni_add_rxbuf(struct ni_softc *, struct ni_dg *, int);
static	void	ni_setup(struct ni_softc *);
static	void	nitimeout(struct ifnet *);
static	void ni_getpgs(struct ni_softc *sc, int size, caddr_t *v, paddr_t *p);
static	int failtest(struct ni_softc *, int, int, int, char *);

volatile int endwait, retry;	/* Used during autoconfig */

struct	cfattach ni_ca = {
	sizeof(struct ni_softc), nimatch, niattach
};

#define NI_WREG(csr, val) \
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, csr, val)
#define NI_RREG(csr) \
	bus_space_read_4(sc->sc_iot, sc->sc_ioh, csr)

#define WAITREG(csr,val) while (NI_RREG(csr) & val);
/*
 * Check for present device.
 */
int
nimatch(parent, cf, aux)
	struct	device *parent;
	struct	cfdata *cf;
	void	*aux;
{
	struct bi_attach_args *ba = aux;
	u_short type;

	type = bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE);
	if (type != BIDT_DEBNA && type != BIDT_DEBNT && type != BIDT_DEBNK)
		return 0;

	if (cf->cf_loc[BICF_NODE] != BICF_NODE_DEFAULT &&
	    cf->cf_loc[BICF_NODE] != ba->ba_nodenr)
		return 0;

	return 1;
}

/*
 * Allocate a bunch of descriptor-safe memory.
 * We need to get the structures from the beginning of its own pages.
 */
static void
ni_getpgs(struct ni_softc *sc, int size, caddr_t *v, paddr_t *p)
{
	bus_dma_segment_t seg;
	int nsegs, error;

	if ((error = bus_dmamem_alloc(sc->sc_dmat, size, NBPG, 0, &seg, 1,
	    &nsegs, BUS_DMA_NOWAIT)) != 0)
		panic(" can't allocate memory: error %d", error);

	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, nsegs, size, v,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0)
		panic(" can't map mem space: error %d", error);

	if (p)
		*p = seg.ds_addr;
	memset(*v, 0, size);
}

static int
failtest(struct ni_softc *sc, int reg, int mask, int test, char *str)
{
	int i = 100;

	do {
		DELAY(100000);
	} while (((NI_RREG(reg) & mask) != test) && --i);

	if (i == 0) {
		printf("%s: %s\n", sc->sc_dev.dv_xname, str);
		return 1;
	}
	return 0;
}


/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
void
niattach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
{
	struct bi_attach_args *ba = aux;
	struct ni_softc *sc = (struct ni_softc *)self;
	struct ifnet *ifp = (struct ifnet *)&sc->sc_if;
	struct ni_msg *msg;
	struct ni_ptdb *ptdb;
	caddr_t va;
	int i, j, s, res;
	u_short type;

	type = bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE);
	printf(": DEBN%c\n", type == BIDT_DEBNA ? 'A' : type == BIDT_DEBNT ?
	    'T' : 'K');
	sc->sc_iot = ba->ba_iot;
	sc->sc_ioh = ba->ba_ioh;
	sc->sc_dmat = ba->ba_dmat;

	bi_intr_establish(ba->ba_icookie, ba->ba_ivec, niintr, sc);

	ni_getpgs(sc, sizeof(struct ni_gvppqb), (caddr_t *)&sc->sc_gvppqb, 
	    (paddr_t *)&sc->sc_pgvppqb);
	ni_getpgs(sc, sizeof(struct ni_fqb), (caddr_t *)&sc->sc_fqb, 0);
	ni_getpgs(sc, NBDESCS * sizeof(struct ni_bbd),
	    (caddr_t *)&sc->sc_bbd, 0);
	/*
	 * Zero the newly allocated memory.
	 */

	nipqb->np_veclvl = (ba->ba_ivec << 2) + 2;
	nipqb->np_node = ba->ba_intcpu;
	nipqb->np_vpqb = (u_int32_t)gvp;
#ifdef __vax__
	nipqb->np_spt = nipqb->np_gpt = mfpr(PR_SBR);
	nipqb->np_sptlen = nipqb->np_gptlen = mfpr(PR_SLR);
#else
#error Must fix support for non-vax.
#endif
	nipqb->np_bvplvl = 1;
	nipqb->np_vfqb = (u_int32_t)fqb;
	nipqb->np_vbdt = (u_int32_t)bbd;
	nipqb->np_nbdr = NBDESCS;

	/* Free queue block */
	nipqb->np_freeq = NQUEUES;
	fqb->nf_mlen = PKTHDR+MSGADD;
	fqb->nf_dlen = PKTHDR+TXADD;
	fqb->nf_rlen = PKTHDR+RXADD;

	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = nistart;
	ifp->if_ioctl = niioctl;
	ifp->if_watchdog = nitimeout;
	IFQ_SET_READY(&ifp->if_snd);

	/*
	 * Start init sequence.
	 */

	/* Reset the node */
	NI_WREG(BIREG_VAXBICSR, NI_RREG(BIREG_VAXBICSR) | BICSR_NRST);
	DELAY(500000);
	i = 20;
	while ((NI_RREG(BIREG_VAXBICSR) & BICSR_BROKE) && --i)
		DELAY(500000);
	if (i == 0) {
		printf("%s: BROKE bit set after reset\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Check state */
	if (failtest(sc, NI_PSR, PSR_STATE, PSR_UNDEF, "not undefined state"))
		return;

	/* Clear owner bits */
	NI_WREG(NI_PSR, NI_RREG(NI_PSR) & ~PSR_OWN);
	NI_WREG(NI_PCR, NI_RREG(NI_PCR) & ~PCR_OWN);

	/* kick off init */
	NI_WREG(NI_PCR, (u_int32_t)sc->sc_pgvppqb | PCR_INIT | PCR_OWN);
	while (NI_RREG(NI_PCR) & PCR_OWN)
		DELAY(100000);

	/* Check state */
	if (failtest(sc, NI_PSR, PSR_INITED, PSR_INITED, "failed initialize"))
		return;

	NI_WREG(NI_PSR, NI_RREG(NI_PSR) & ~PSR_OWN);

	WAITREG(NI_PCR, PCR_OWN);
	NI_WREG(NI_PCR, PCR_OWN|PCR_ENABLE);
	WAITREG(NI_PCR, PCR_OWN);
	WAITREG(NI_PSR, PSR_OWN);

	/* Check state */
	if (failtest(sc, NI_PSR, PSR_STATE, PSR_ENABLED, "failed enable"))
		return;

	NI_WREG(NI_PSR, NI_RREG(NI_PSR) & ~PSR_OWN);

	/*
	 * The message queue packets must be located on the beginning
	 * of a page. A VAX page is 512 bytes, but it clusters 8 pages.
	 * This knowledge is used here when allocating pages.
	 * !!! How should this be done on MIPS and Alpha??? !!!
	 */
#if NBPG < 4096
#error pagesize too small
#endif
	s = splvm();
	/* Set up message free queue */
	ni_getpgs(sc, NMSGBUF * 512, &va, 0);
	for (i = 0; i < NMSGBUF; i++) {
		struct ni_msg *msg;

		msg = (void *)(va + i * 512);

		res = INSQTI(msg, &fqb->nf_mforw);
	}
	WAITREG(NI_PCR, PCR_OWN);
	NI_WREG(NI_PCR, PCR_FREEQNE|PCR_MFREEQ|PCR_OWN);
	WAITREG(NI_PCR, PCR_OWN);

	/* Set up xmit queue */
	ni_getpgs(sc, NTXBUF * 512, &va, 0);
	for (i = 0; i < NTXBUF; i++) {
		struct ni_dg *data;

		data = (void *)(va + i * 512);
		data->nd_status = 0;
		data->nd_len = TXADD;
		data->nd_ptdbidx = 1;
		data->nd_opcode = BVP_DGRAM;
		for (j = 0; j < NTXFRAGS; j++) {
			data->bufs[j]._offset = 0;
			data->bufs[j]._key = 1;
			bbd[i * NTXFRAGS + j].nb_key = 1;
			bbd[i * NTXFRAGS + j].nb_status = 0;
			data->bufs[j]._index = i * NTXFRAGS + j;
		}
		res = INSQTI(data, &fqb->nf_dforw);
	}
	WAITREG(NI_PCR, PCR_OWN);
	NI_WREG(NI_PCR, PCR_FREEQNE|PCR_DFREEQ|PCR_OWN);
	WAITREG(NI_PCR, PCR_OWN);

	/* recv buffers */
	ni_getpgs(sc, NRXBUF * 512, &va, 0);
	for (i = 0; i < NRXBUF; i++) {
		struct ni_dg *data;
		int idx;

		data = (void *)(va + i * 512);
		data->nd_len = RXADD;
		data->nd_opcode = BVP_DGRAMRX;
		data->nd_ptdbidx = 2;
		data->bufs[0]._key = 1;

		idx = NTXBUF * NTXFRAGS + i;
		if (ni_add_rxbuf(sc, data, idx))
			panic("niattach: ni_add_rxbuf: out of mbufs");

		res = INSQTI(data, &fqb->nf_rforw);
	}
	WAITREG(NI_PCR, PCR_OWN);
	NI_WREG(NI_PCR, PCR_FREEQNE|PCR_RFREEQ|PCR_OWN);
	WAITREG(NI_PCR, PCR_OWN);

	splx(s);

	/* Set initial parameters */
	msg = REMQHI(&fqb->nf_mforw);

	msg->nm_opcode = BVP_MSG;
	msg->nm_status = 0;
	msg->nm_len = sizeof(struct ni_param) + 6;
	msg->nm_opcode2 = NI_WPARAM;
	((struct ni_param *)&msg->nm_text[0])->np_flags = NP_PAD;

	endwait = retry = 0;
	res = INSQTI(msg, &gvp->nc_forw0);

retry:	WAITREG(NI_PCR, PCR_OWN);
	NI_WREG(NI_PCR, PCR_CMDQNE|PCR_CMDQ0|PCR_OWN);
	WAITREG(NI_PCR, PCR_OWN);
	i = 1000;
	while (endwait == 0 && --i)
		DELAY(10000);

	if (endwait == 0) {
		if (++retry < 3)
			goto retry;
		printf("%s: no response to set params\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Clear counters */
	msg = REMQHI(&fqb->nf_mforw);
	msg->nm_opcode = BVP_MSG;
	msg->nm_status = 0;
	msg->nm_len = sizeof(struct ni_param) + 6;
	msg->nm_opcode2 = NI_RCCNTR;

	res = INSQTI(msg, &gvp->nc_forw0);

	WAITREG(NI_PCR, PCR_OWN);
	NI_WREG(NI_PCR, PCR_CMDQNE|PCR_CMDQ0|PCR_OWN);
	WAITREG(NI_PCR, PCR_OWN);

	/* Enable transmit logic */
	msg = REMQHI(&fqb->nf_mforw);

	msg->nm_opcode = BVP_MSG;
	msg->nm_status = 0;
	msg->nm_len = 18;
	msg->nm_opcode2 = NI_STPTDB;
	ptdb = (struct ni_ptdb *)&msg->nm_text[0];
	memset(ptdb, 0, sizeof(struct ni_ptdb));
	ptdb->np_index = 1;
	ptdb->np_fque = 1;

	res = INSQTI(msg, &gvp->nc_forw0);

	WAITREG(NI_PCR, PCR_OWN);
	NI_WREG(NI_PCR, PCR_CMDQNE|PCR_CMDQ0|PCR_OWN);
	WAITREG(NI_PCR, PCR_OWN);

	/* Wait for everything to finish */
	WAITREG(NI_PSR, PSR_OWN);

	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_enaddr));

	/*
	 * Attach the interface.
	 */
	if_attach(ifp);
	ether_ifattach(ifp, sc->sc_enaddr);
}

/*
 * Initialization of interface.
 */
void
niinit(sc)
	struct ni_softc *sc;
{
	struct ifnet *ifp = (struct ifnet *)&sc->sc_if;

	/*
	 * Set flags (so ni_setup() do the right thing).
	 */
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	/*
	 * Send setup messages so that the rx/tx locic starts.
	 */
	ni_setup(sc);

}

/*
 * Start output on interface.
 */
void
nistart(ifp)
	struct ifnet *ifp;
{
	struct ni_softc *sc = ifp->if_softc;
	struct ni_dg *data;
	struct ni_bbd *bdp;
	struct mbuf *m, *m0;
	int i, cnt, res, mlen;

	if (ifp->if_flags & IFF_OACTIVE)
		return;
#ifdef DEBUG
	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: nistart\n", sc->sc_dev.dv_xname);
#endif

	while (fqb->nf_dforw) {
		IFQ_POLL(&ifp->if_snd, m);
		if (m == 0)
			break;

		data = REMQHI(&fqb->nf_dforw);
		if ((int)data == Q_EMPTY) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);

		/*
		 * Count number of mbufs in chain.
		 * Always do DMA directly from mbufs, therefore the transmit
		 * ring is really big.
		 */
		for (m0 = m, cnt = 0; m0; m0 = m0->m_next)
			if (m0->m_len)
				cnt++;
		if (cnt > NTXFRAGS)
			panic("nistart"); /* XXX */

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		bdp = &bbd[(data->bufs[0]._index & 0x7fff)];
		for (m0 = m, i = 0, mlen = 0; m0; m0 = m0->m_next) {
			if (m0->m_len == 0)
				continue;
			bdp->nb_status = (mtod(m0, u_int32_t) & NIBD_OFFSET) |
			    NIBD_VALID;
			bdp->nb_pte = (u_int32_t)kvtopte(mtod(m0, void *));
			bdp->nb_len = m0->m_len;
			data->bufs[i]._offset = 0;
			data->bufs[i]._len = bdp->nb_len;
			data->bufs[i]._index |= NIDG_CHAIN;
			mlen += bdp->nb_len;
			bdp++;
			i++;
		}
		data->nd_opcode = BVP_DGRAM;
		data->nd_pad3 = 1;
		data->nd_ptdbidx = 1;
		data->nd_len = 10 + i * 8;
		data->bufs[i - 1]._index &= ~NIDG_CHAIN;
		if (mlen < 64)
			data->bufs[i - 1]._len = bdp[-1].nb_len += (64 - mlen);
		data->nd_cmdref = (u_int32_t)m;
#ifdef DEBUG
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: sending %d bytes (%d segments)\n",
			    sc->sc_dev.dv_xname, mlen, i);
#endif

		res = INSQTI(data, &gvp->nc_forw0);
		if (res == Q_EMPTY) {
			WAITREG(NI_PCR, PCR_OWN);
			NI_WREG(NI_PCR, PCR_CMDQNE|PCR_CMDQ0|PCR_OWN);
		}
	}
}

void
niintr(void *arg)
{
	struct ni_softc *sc = arg;
	struct ni_dg *data;
	struct ni_msg *msg;
	struct ifnet *ifp = &sc->sc_if;
	struct ni_bbd *bd;
	struct mbuf *m;
	int idx, res;

	if ((NI_RREG(NI_PSR) & PSR_STATE) != PSR_ENABLED)
		return;

	if ((NI_RREG(NI_PSR) & PSR_ERR))
		printf("%s: PSR %x\n", sc->sc_dev.dv_xname, NI_RREG(NI_PSR));

	KERNEL_LOCK();
	/* Got any response packets?  */
	while ((NI_RREG(NI_PSR) & PSR_RSQ) && (data = REMQHI(&gvp->nc_forwr))) {

		switch (data->nd_opcode) {
		case BVP_DGRAMRX: /* Receive datagram */
			idx = data->bufs[0]._index;
			bd = &bbd[idx];
			m = (void *)data->nd_cmdref;
			m->m_pkthdr.len = m->m_len =
			    data->bufs[0]._len - ETHER_CRC_LEN;
			m->m_pkthdr.rcvif = ifp;
			if (ni_add_rxbuf(sc, data, idx)) {
				bd->nb_len = (m->m_ext.ext_size - 2);
				bd->nb_pte =
				    (long)kvtopte(m->m_ext.ext_buf);
				bd->nb_status = 2 | NIBD_VALID;
				bd->nb_key = 1;
			}
			data->nd_len = RXADD;
			data->nd_status = 0;
			res = INSQTI(data, &fqb->nf_rforw);
			if (res == Q_EMPTY) {
				WAITREG(NI_PCR, PCR_OWN);
				NI_WREG(NI_PCR, PCR_FREEQNE|PCR_RFREEQ|PCR_OWN);
			}
			if (m == (void *)data->nd_cmdref)
				break; /* Out of mbufs */

#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
			(*ifp->if_input)(ifp, m);
			break;

		case BVP_DGRAM:
			m = (struct mbuf *)data->nd_cmdref;
			ifp->if_flags &= ~IFF_OACTIVE;
			m_freem(m);
			res = INSQTI(data, &fqb->nf_dforw);
			if (res == Q_EMPTY) {
				WAITREG(NI_PCR, PCR_OWN);
				NI_WREG(NI_PCR, PCR_FREEQNE|PCR_DFREEQ|PCR_OWN);
			}
			break;

		case BVP_MSGRX:
			msg = (struct ni_msg *)data;
			switch (msg->nm_opcode2) {
				case NI_WPARAM:
					memcpy(sc->sc_enaddr, ((struct ni_param *)&msg->nm_text[0])->np_dpa, ETHER_ADDR_LEN);
					endwait = 1;
					break;

				case NI_RCCNTR:
				case NI_CLPTDB:
				case NI_STPTDB:
					break;

				default:
					printf("Unkn resp %d\n", 
					    msg->nm_opcode2);
					break;
			}
			res = INSQTI(data, &fqb->nf_mforw);
			if (res == Q_EMPTY) {
				WAITREG(NI_PCR, PCR_OWN);
				NI_WREG(NI_PCR, PCR_FREEQNE|PCR_MFREEQ|PCR_OWN);
			}
			break;

		default:
			printf("Unknown opcode %d\n", data->nd_opcode);
			res = INSQTI(data, &fqb->nf_mforw);
			if (res == Q_EMPTY) {
				WAITREG(NI_PCR, PCR_OWN);
				NI_WREG(NI_PCR, PCR_FREEQNE|PCR_MFREEQ|PCR_OWN);
			}
		}
	}

	/* Try to kick on the start routine again */
	nistart(ifp);

	NI_WREG(NI_PSR, NI_RREG(NI_PSR) & ~(PSR_OWN|PSR_RSQ));
	KERNEL_UNLOCK();
}

/*
 * Process an ioctl request.
 */
int
niioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ni_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		switch(ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			niinit(sc);
			arp_ifinit(ifp, ifa);
			break;
#endif
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running,
			 * stop it.
			 */
			ifp->if_flags &= ~IFF_RUNNING;
			ni_setup(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface it marked up and it is stopped, then
			 * start it.
			 */
			niinit(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0) {
			/*
			 * Send a new setup packet to match any new changes.
			 * (Like IFF_PROMISC etc)
			 */
			ni_setup(sc);
		}
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ec, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			ni_setup(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

/*
 * Add a receive buffer to the indicated descriptor.
 */
int
ni_add_rxbuf(struct ni_softc *sc, struct ni_dg *data, int idx) 
{
	struct ni_bbd *bd = &bbd[idx];
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}

	m->m_data += 2;
	bd->nb_len = (m->m_ext.ext_size - 2);
	bd->nb_pte = (long)kvtopte(m->m_ext.ext_buf);
	bd->nb_status = 2 | NIBD_VALID;
	bd->nb_key = 1;

	data->bufs[0]._offset = 0;
	data->bufs[0]._len = bd->nb_len;
	data->bufs[0]._index = idx;
	data->nd_cmdref = (long)m;

	return (0);
}

/*
 * Create setup packet and put in queue for sending.
 */
void
ni_setup(struct ni_softc *sc)
{
	struct ifnet *ifp = &sc->sc_if;
	struct ni_msg *msg;
	struct ni_ptdb *ptdb;
	struct ether_multi *enm;
	struct ether_multistep step;
	int i, res;

	msg = REMQHI(&fqb->nf_mforw);
	if ((int)msg == Q_EMPTY)
		return; /* What to do? */

	ptdb = (struct ni_ptdb *)&msg->nm_text[0];
	memset(ptdb, 0, sizeof(struct ni_ptdb));

	msg->nm_opcode = BVP_MSG;
	msg->nm_len = 18;
	ptdb->np_index = 2; /* definition type index */
	ptdb->np_fque = 2; /* Free queue */
	if (ifp->if_flags & IFF_RUNNING) {
		msg->nm_opcode2 = NI_STPTDB;
		ptdb->np_type = ETHERTYPE_IP;
		ptdb->np_flags = PTDB_UNKN|PTDB_BDC;
		if (ifp->if_flags & IFF_PROMISC)
			ptdb->np_flags |= PTDB_PROMISC;
		memset(ptdb->np_mcast[0], 0xff, ETHER_ADDR_LEN); /* Broadcast */
		ptdb->np_adrlen = 1;
		msg->nm_len += 8;
		ifp->if_flags &= ~IFF_ALLMULTI;
		if ((ifp->if_flags & IFF_PROMISC) == 0) {
			ETHER_FIRST_MULTI(step, &sc->sc_ec, enm);
			i = 1;
			while (enm != NULL) {
				if (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6)) {
					ifp->if_flags |= IFF_ALLMULTI;
					ptdb->np_flags |= PTDB_AMC;
					break;
				}
				msg->nm_len += 8;
				ptdb->np_adrlen++;
				memcpy(ptdb->np_mcast[i++], enm->enm_addrlo,
				    ETHER_ADDR_LEN);
				ETHER_NEXT_MULTI(step, enm);
			}
		}
	} else
		msg->nm_opcode2 = NI_CLPTDB;

	res = INSQTI(msg, &gvp->nc_forw0);
	if (res == Q_EMPTY) {
		WAITREG(NI_PCR, PCR_OWN);
		NI_WREG(NI_PCR, PCR_CMDQNE|PCR_CMDQ0|PCR_OWN);
	}
}

/*
 * Check for dead transmit logic. Not uncommon.
 */
void
nitimeout(ifp)
	struct ifnet *ifp;
{
#if 0
	struct ni_softc *sc = ifp->if_softc;

	if (sc->sc_inq == 0)
		return;

	printf("%s: xmit logic died, resetting...\n", sc->sc_dev.dv_xname);
	/*
	 * Do a reset of interface, to get it going again.
	 * Will it work by just restart the transmit logic?
	 */
	niinit(sc);
#endif
}
@


1.15
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.14 2009/03/29 21:53:52 sthen Exp $ */
@


1.14
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.13 2008/11/28 02:44:17 brad Exp $ */
a142 1
static	void	ni_shutdown(void *);
a468 3
	if (shutdownhook_establish(ni_shutdown, sc) == 0)
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    sc->sc_dev.dv_xname);
a864 17

/*
 * Shutdown hook.  Make sure the interface is stopped at reboot.
 */
void
ni_shutdown(arg)
	void *arg;
{
	struct ni_softc *sc = arg;

        WAITREG(NI_PCR, PCR_OWN);
        NI_WREG(NI_PCR, PCR_OWN|PCR_SHUTDOWN);
        WAITREG(NI_PCR, PCR_OWN);
        WAITREG(NI_PSR, PSR_OWN);

}

@


1.13
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.12 2008/10/08 23:53:08 brad Exp $ */
d194 1
a194 1
		panic(" unable to allocate memory: error %d", error);
d198 1
a198 1
		panic(" unable to map memory: error %d", error);
@


1.12
log
@cosmetic change for ioctl funtions.. move splnet out from variable declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.11 2008/10/02 20:21:13 brad Exp $ */
a697 1
	struct ifreq *ifr = (struct ifreq *)data;
a740 20
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/*
		 * Update our multicast list.
		 */
		error = (cmd == SIOCADDMULTI) ?
			ether_addmulti(ifr, &sc->sc_ec):
			ether_delmulti(ifr, &sc->sc_ec);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				ni_setup(sc);
			error = 0;
		}
		break;

d743 6
@


1.11
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.10 2007/05/11 10:06:55 pedro Exp $ */
d700 3
a702 1
	int s = splnet(), error = 0;
@


1.10
log
@Don't use LK_CANRECURSE for the kernel lock, okay miod@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.9 2007/05/10 17:59:26 deraadt Exp $ */
a702 1

d761 2
a762 1
		error = EINVAL;
a763 1
	}
@


1.9
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.8 2006/03/25 22:41:41 djm Exp $ */
d599 1
a599 1
	KERNEL_LOCK(LK_CANRECURSE|LK_EXCLUSIVE);
@


1.8
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.7 2006/01/17 20:26:14 miod Exp $ */
a121 1
	struct evcnt	sc_intrcnt;	/* Interrupt counting		*/
d248 1
a248 4
	bi_intr_establish(ba->ba_icookie, ba->ba_ivec,
		niintr, sc, &sc->sc_intrcnt);
	evcnt_attach_dynamic(&sc->sc_intrcnt, EVCNT_TYPE_INTR, NULL,
		sc->sc_dev.dv_xname, "intr");
@


1.7
log
@Use angle bracket and no relative paths for all include files which are not
created by config(8); no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.6 2005/01/15 05:24:10 brad Exp $ */
d547 1
a547 1
			bpf_mtap(ifp->if_bpf, m);
d634 1
a634 1
				bpf_mtap(ifp->if_bpf, m);
@


1.6
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.5 2004/07/07 23:10:43 deraadt Exp $ */
a38 4
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: if_ni.c,v 1.15 2002/05/22 16:03:14 wiz Exp $");

#include "opt_inet.h"
a68 3

#include "ioconf.h"
#include "locators.h"
@


1.5
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.4 2003/05/11 19:41:12 deraadt Exp $ */
d766 2
a767 1
			ni_setup(sc);
@


1.4
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.3 2002/10/27 13:25:48 miod Exp $ */
d473 1
a473 1
	printf("%s: hardware address %s\n", sc->sc_dev.dv_xname,
@


1.3
log
@Typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.2 2002/08/09 20:26:44 jsyn Exp $ */
d290 1
a290 1
	strcpy(ifp->if_xname, sc->sc_dev.dv_xname);
@


1.3.6.1
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.3 2002/10/27 13:25:48 miod Exp $ */
d290 1
a290 1
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
@


1.3.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.3.2.2
log
@sync
@
text
@d290 1
a290 1
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
@


1.2
log
@Get rid of remaining __P usage (except for imported code);
ok millert@@, rogue ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ni.c,v 1.1 2002/06/11 09:36:23 hugh Exp $ */
d129 1
a129 1
	struct evcnt	sc_intrcnt;	/* Interrupt coounting		*/
@


1.1
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d142 6
a147 6
static	int	nimatch __P((struct device *, struct cfdata *, void *));
static	void	niattach __P((struct device *, struct device *, void *));
static	void	niinit __P((struct ni_softc *));
static	void	nistart __P((struct ifnet *));
static	void	niintr __P((void *));
static	int	niioctl __P((struct ifnet *, u_long, caddr_t));
d149 2
a150 2
static	void	ni_setup __P((struct ni_softc *));
static	void	nitimeout __P((struct ifnet *));
@

