head	1.17;
access;
symbols
	OPENBSD_5_9:1.16.0.10
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.12
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.14
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.10
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.16
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.14
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.12
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.10
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.16;
commitid	OSDG2O3Cgeifnf1W;

1.16
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.07.01.28.53;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2012.12.05.23.20.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2012.11.25.22.13.46;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.06.18.12.47;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.15.20.04.36;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.08.08.50.26;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.05.03.04.38;	author hugh;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.07.04.05.12.58;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.27.03.14.46;	author bjc;	state Exp;
branches;
next	1.3;

1.3
date	97.09.12.09.25.52;	author maja;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	97.05.29.00.05.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.24.52;	author maja;	state Exp;
branches;
next	;

1.3.12.1
date	2001.05.14.21.38.14;	author niklas;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.3.12.4;

1.3.12.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.3.12.5;

1.3.12.5
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: mscp_tape.c,v 1.16 2013/06/11 16:42:13 deraadt Exp $ */
/*	$NetBSD: mscp_tape.c,v 1.16 2001/11/13 07:38:28 lukem Exp $ */
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * MSCP tape device driver
 */

/*
 * TODO
 *	Write status handling code.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/buf.h>
#include <sys/ioccom.h>
#include <sys/mtio.h>
#include <sys/fcntl.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/conf.h>

#include <machine/bus.h>
#include <machine/cpu.h>

#include <arch/vax/mscp/mscp.h>
#include <arch/vax/mscp/mscpreg.h>
#include <arch/vax/mscp/mscpvar.h>

/*
 * Drive status, per drive
 */
struct mt_softc {
	struct	device mt_dev;	/* Autoconf struct */
	int	mt_state;	/* open/closed state */
	int	mt_hwunit;	/* Hardware unit number */
	int	mt_inuse;	/* Locks the tape drive for others */
	int	mt_waswrite;	/* Last operation was a write op */
	int	mt_serex;	/* Got serious exception */
	int	mt_ioctlerr;	/* Error after last ioctl */
};

#define MT_OFFLINE	0
#define MT_ONLINE	1

int	mtmatch(struct device *, struct cfdata *, void *);
void	mtattach(struct device *, struct device *, void *);
void	mtdgram(struct device *, struct mscp *, struct mscp_softc *);
void	mtiodone(struct device *, struct buf *);
int	mtonline(struct device *, struct mscp *);
int	mtgotstatus(struct device *, struct mscp *);
int	mtioerror(struct device *, struct mscp *, struct buf *);
void	mtfillin(struct buf *, struct mscp *);
int	mtread(dev_t, struct uio *);
int	mtwrite(dev_t, struct uio *);
int	mtcmd(struct mt_softc *, int, int, int);
void	mtcmddone(struct device *, struct mscp *);
int	mt_putonline(struct mt_softc *);
bdev_decl(mt);

struct	mscp_device mt_device = {
	mtdgram,
	mtiodone,
	mtonline,
	mtgotstatus,
	0,
	mtioerror,
	0,
	mtfillin,
	mtcmddone,
};

/* This is not good, should allow more than 4 tapes/device type */
#define mtunit(dev)	(minor(dev) & T_UNIT)
#define mtnorewind(dev) (dev & T_NOREWIND)
#define mthdensity(dev) (dev & T_1600BPI)

struct	cfattach mt_ca = {
	sizeof(struct mt_softc), (cfmatch_t)mtmatch, mtattach
};

struct cfdriver mt_cd = {
	NULL, "mt", DV_TAPE
};

/*
 * More driver definitions, for generic MSCP code.
 */

int
mtmatch(parent, cf, aux)
	struct	device *parent;
	struct	cfdata *cf;
	void	*aux;
{
	struct	drive_attach_args *da = aux;
	struct	mscp *mp = da->da_mp;

	if ((da->da_typ & MSCPBUS_TAPE) == 0)
		return 0;
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != mp->mscp_unit)
		return 0;
	return 1;
}

/*
 * The attach routine only checks and prints drive type.
 */
void
mtattach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux; 
{
	struct	mt_softc *mt = (void *)self;
	struct	drive_attach_args *da = aux;
	struct	mscp *mp = da->da_mp;
	struct	mscp_softc *mi = (void *)parent;

	mt->mt_hwunit = mp->mscp_unit;
	mi->mi_dp[mp->mscp_unit] = self;

	disk_printtype(mp->mscp_unit, mp->mscp_guse.guse_mediaid);
}

/* 
 * (Try to) put the drive online. This is done the first time the
 * drive is opened, or if it has fallen offline.
 */
int
mt_putonline(mt)
	struct mt_softc *mt;
{
	struct	mscp *mp;
	struct	mscp_softc *mi = (struct mscp_softc *)mt->mt_dev.dv_parent;
	volatile int i;

	mt->mt_state = MT_OFFLINE;
	mp = mscp_getcp(mi, MSCP_WAIT);
	mp->mscp_opcode = M_OP_ONLINE;
	mp->mscp_unit = mt->mt_hwunit;
	mp->mscp_cmdref = (long)&mt->mt_state;
	*mp->mscp_addr |= MSCP_OWN | MSCP_INT;

	/* Poll away */
	i = bus_space_read_2(mi->mi_iot, mi->mi_iph, 0);
	if (tsleep(&mt->mt_state, PRIBIO, "mtonline", 240 * hz))
		return MSCP_FAILED;

	if ((volatile int)mt->mt_state != MT_ONLINE)
		return MSCP_FAILED;

	return MSCP_DONE;
}
/*
 * Open a drive.
 */
/*ARGSUSED*/
int
mtopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct	proc *p;
{
	struct mt_softc *mt;
	int unit;

	/*
	 * Make sure this is a reasonable open request.
	 */
	unit = mtunit(dev);
	if (unit >= mt_cd.cd_ndevs)
		return ENXIO;
	mt = mt_cd.cd_devs[unit];
	if (mt == 0)
		return ENXIO;

	if (mt->mt_inuse)
			return EBUSY;
	mt->mt_inuse = 1;

	if (mt_putonline(mt) == MSCP_FAILED) {
		mt->mt_inuse = 0;
		return EIO;
	}

	return 0;
}

/* ARGSUSED */
int
mtclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct	proc *p;
{
	int unit = mtunit(dev);
	struct mt_softc *mt = mt_cd.cd_devs[unit];

	/*
	 * If we just have finished a writing, write EOT marks.
	 */
	if ((flags & FWRITE) && mt->mt_waswrite) {
		mtcmd(mt, MTWEOF, 0, 0);
		mtcmd(mt, MTWEOF, 0, 0);
		mtcmd(mt, MTBSR, 1, 0);
	}
	if (mtnorewind(dev) == 0)
		mtcmd(mt, MTREW, 0, 1);
	if (mt->mt_serex)
		mtcmd(mt, -1, 0, 0);

	mt->mt_inuse = 0; /* Release the tape */
	return 0;
}

void
mtstrategy(bp)
	struct buf *bp;
{
	int unit;
	struct mt_softc *mt;
	int s;

	/*
	 * Make sure this is a reasonable drive to use.
	 */
	unit = mtunit(bp->b_dev);
	if (unit >= mt_cd.cd_ndevs || (mt = mt_cd.cd_devs[unit]) == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

	mt->mt_waswrite = bp->b_flags & B_READ ? 0 : 1;
	mscp_strategy(bp, mt->mt_dev.dv_parent);
	return;

bad:
	bp->b_flags |= B_ERROR;
	s = splbio();
	biodone(bp);
	splx(s);
}

int
mtread(dev, uio)
	dev_t dev;
	struct uio *uio;
{

	return (physio(mtstrategy, dev, B_READ, minphys, uio));
}

int
mtwrite(dev, uio)
	dev_t dev;
	struct uio *uio;
{

	return (physio(mtstrategy, dev, B_WRITE, minphys, uio));
}

void
mtiodone(usc, bp)
	struct device *usc;
	struct buf *bp;
{
	int s;

	s = splbio();
	biodone(bp);
	splx(s);
}

/*
 * Fill in drive addresses in a mscp packet waiting for transfer.
 */
void
mtfillin(bp, mp)
	struct buf *bp;
	struct mscp *mp;
{
	int unit = mtunit(bp->b_dev);
	struct mt_softc *mt = mt_cd.cd_devs[unit];

	mp->mscp_unit = mt->mt_hwunit;
	if (mt->mt_serex == 2) {
		mp->mscp_modifier = M_MD_CLSEX;
		mt->mt_serex = 0;
	} else
		mp->mscp_modifier = 0;

	mp->mscp_seq.seq_bytecount = bp->b_bcount;
}

/*
 * Handle an error datagram.
 */
void
mtdgram(usc, mp, mi)
	struct device *usc;
	struct mscp *mp;
	struct mscp_softc *mi;
{
	if (mscp_decodeerror(usc == NULL?"unconf mt" : usc->dv_xname, mp, mi))
		return;
}

/*
 * A drive came on line, make sure it really _is_ on line before
 * trying to use it.
 */
int
mtonline(usc, mp)
	struct device *usc;
	struct mscp *mp;
{
	struct mt_softc *mt = (void *)usc;

	wakeup((caddr_t)&mt->mt_state);
	if ((mp->mscp_status & M_ST_MASK) == M_ST_SUCCESS) 
		mt->mt_state = MT_ONLINE;

	return (MSCP_DONE);
}

/*
 * We got some (configured) unit's status.  Return DONE.
 */
int
mtgotstatus(usc, mp)
	struct device *usc;
	struct mscp *mp;
{
	return (MSCP_DONE);
}

static char *mt_ioerrs[] = {
	"invalid command",	/* 1 M_ST_INVALCMD */
	"command aborted",	/* 2 M_ST_ABORTED */
	"unit offline",		/* 3 M_ST_OFFLINE */
	"unknown",		/* 4 M_ST_AVAILABLE */
	"unknown",		/* 5 M_ST_MFMTERR */
	"unit write protected", /* 6 M_ST_WRPROT */
	"compare error",	/* 7 M_ST_COMPERR */
	"data error",		/* 8 M_ST_DATAERR */
	"host buffer access error",	/* 9 M_ST_HOSTBUFERR */
	"controller error",	/* 10 M_ST_CTLRERR */
	"drive error",		/* 11 M_ST_DRIVEERR */
	"formatter error",	/* 12 M_ST_FORMATTERR */
	"BOT encountered",	/* 13 M_ST_BOT */
	"tape mark encountered",/* 14 M_ST_TAPEMARK */
	"unknown",		/* 15 */
	"record data truncated",/* 16 M_ST_RDTRUNC */
};

/*
 * An I/O error, may be because of a tapemark encountered.
 * Check that before failing.
 */
/*ARGSUSED*/
int
mtioerror(usc, mp, bp)
	struct device *usc;
	struct mscp *mp;
	struct buf *bp;
{
	struct mt_softc *mt = (void *)usc;
	int st = mp->mscp_status & M_ST_MASK;

	if (mp->mscp_flags & M_EF_SEREX)
		mt->mt_serex = 1;
	if (st == M_ST_TAPEMARK)
		mt->mt_serex = 2;
	else {
		if (st && st < 17)
			printf("%s: error %d (%s)\n", mt->mt_dev.dv_xname, st,
			    mt_ioerrs[st-1]);
		else
			printf("%s: error %d\n", mt->mt_dev.dv_xname, st);
		bp->b_flags |= B_ERROR;
		bp->b_error = EROFS;
	}

	return (MSCP_DONE);
}

/*
 * I/O controls.
 */
int
mtioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = mtunit(dev);
	struct mt_softc *mt = mt_cd.cd_devs[unit];
	struct	mtop *mtop;
	struct	mtget *mtget;
	int error = 0;

	switch (cmd) {

	case MTIOCTOP:
		mtop = (void *)data;
		if (mtop->mt_op == MTWEOF) {
			while (mtop->mt_count-- > 0)
				if ((error = mtcmd(mt, mtop->mt_op, 0, 0)))
					break;
		} else
			error = mtcmd(mt, mtop->mt_op, mtop->mt_count, 0);

	case MTIOCGET:
		mtget = (void *)data;
		mtget->mt_type = MT_ISTMSCP;
		/* XXX we need to fill in more fields here */
		break;

	default:
		error = ENXIO;
		break;
	}
	return (error);
}

/*
 * No crash dump support...
 */
int
mtdump(dev, blkno, va, size)
	dev_t	dev;
	daddr_t blkno;
	caddr_t va;
	size_t	size;
{
	return -1;
}

/*
 * Send a command to the tape drive. Wait until the command is
 * finished before returning.
 * This routine must only be called when there are no data transfer
 * active on this device. Can we be sure of this? Or does the ctlr
 * queue up all command packets and take them in sequential order?
 * It sure would be nice if my manual stated this... /ragge
 */
int
mtcmd(mt, cmd, count, complete)
	struct mt_softc *mt;
	int cmd, count, complete;
{
	struct mscp *mp;
	struct mscp_softc *mi = (void *)mt->mt_dev.dv_parent;
	volatile int i;

	mp = mscp_getcp(mi, MSCP_WAIT);

	mt->mt_ioctlerr = 0;
	mp->mscp_unit = mt->mt_hwunit;
	mp->mscp_cmdref = -1;
	*mp->mscp_addr |= MSCP_OWN | MSCP_INT;

	switch (cmd) {
	case MTWEOF:
		mp->mscp_opcode = M_OP_WRITM;
		break;

	case MTBSF:
		mp->mscp_modifier = M_MD_REVERSE;
	case MTFSF:
		mp->mscp_opcode = M_OP_POS;
		mp->mscp_seq.seq_buffer = count;
		break;

	case MTBSR:
		mp->mscp_modifier = M_MD_REVERSE;
	case MTFSR:
		mp->mscp_opcode = M_OP_POS;
		mp->mscp_modifier |= M_MD_OBJCOUNT;
		mp->mscp_seq.seq_bytecount = count;
		break;

	case MTREW:
		mp->mscp_opcode = M_OP_POS;
		mp->mscp_modifier = M_MD_REWIND | M_MD_CLSEX;
		if (complete)
			mp->mscp_modifier |= M_MD_IMMEDIATE;
		mt->mt_serex = 0;
		break;

	case MTOFFL:
		mp->mscp_opcode = M_OP_AVAILABLE;
		mp->mscp_modifier = M_MD_UNLOAD | M_MD_CLSEX;
		mt->mt_serex = 0;
		break;

	case MTNOP:
		mp->mscp_opcode = M_OP_GETUNITST;
		break;

	case -1: /* Clear serious exception only */
		mp->mscp_opcode = M_OP_POS;
		mp->mscp_modifier = M_MD_CLSEX;
		mt->mt_serex = 0;
		break;

	default:
		printf("Bad ioctl %x\n", cmd);
		mp->mscp_opcode = M_OP_POS;
		break;
	}

	i = bus_space_read_2(mi->mi_iot, mi->mi_iph, 0);
	tsleep(&mt->mt_inuse, PRIBIO, "mtioctl", 0);
	return mt->mt_ioctlerr;
}

/*
 * Called from bus routines whenever a non-data transfer is finished.
 */
void
mtcmddone(usc, mp)
	struct device *usc;
	struct mscp *mp;
{
	struct mt_softc *mt = (void *)usc;

	if (mp->mscp_status) {
		mt->mt_ioctlerr = EIO;
		printf("%s: bad status %x\n", mt->mt_dev.dv_xname,
		    mp->mscp_status);
	}
	wakeup(&mt->mt_inuse);
}
@


1.16
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.15 2013/05/07 01:28:53 jsg Exp $ */
@


1.15
log
@remove an unreferenced var that accessed uninitialised memory
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.14 2012/12/05 23:20:15 deraadt Exp $ */
d467 1
a467 1
	daddr64_t blkno;
@


1.14
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.13 2012/11/25 22:13:46 jsg Exp $ */
d435 1
a435 3
	int error = 0, count;

	count = mtop->mt_count;
@


1.13
log
@remove the use of cast as lvalue which is verboten with newer gcc
tweaks from/tested by/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.12 2011/04/06 18:12:47 miod Exp $ */
a42 2

#include <sys/cdefs.h>
@


1.12
log
@Use bdev_decl() to get block device function prototypes instead of rolling
our own (sometimes incorrect).
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.11 2010/09/22 01:18:57 matthew Exp $ */
d172 1
a172 1
	(volatile int)mt->mt_state = MT_OFFLINE;
@


1.11
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.10 2007/06/06 17:15:13 deraadt Exp $ */
d56 1
a88 3
int	mtopen(dev_t, int, int, struct proc *);
int	mtclose(dev_t, int, int, struct proc *);
void	mtstrategy(struct buf *);
a90 2
int	mtioctl(dev_t, int, caddr_t, int, struct proc *);
int	mtdump(dev_t, daddr64_t, caddr_t, size_t);
d94 1
d428 1
a428 1
	int cmd;
@


1.10
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.9 2006/03/15 20:04:36 miod Exp $ */
d288 1
a288 1
	return (physio(mtstrategy, NULL, dev, B_READ, minphys, uio));
d297 1
a297 1
	return (physio(mtstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.9
log
@Correct checks against cd_ndevs - valid numbers are strictly inferior to
cd_ndevs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.8 2002/06/08 08:50:26 art Exp $ */
d94 1
a94 1
int	mtdump(dev_t, daddr_t, caddr_t, size_t);
d474 1
a474 1
	daddr_t blkno;
@


1.8
log
@protect biodone with splbio
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.7 2002/03/14 01:26:48 millert Exp $ */
d266 1
a266 1
	if (unit > mt_cd.cd_ndevs || (mt = mt_cd.cd_devs[unit]) == NULL) {
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.6 2001/12/05 03:04:38 hugh Exp $ */
d260 1
d277 1
d279 1
d305 1
d307 1
d309 1
@


1.6
log
@sync with netbsd. untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.5 2001/07/04 05:12:58 csapuntz Exp $ */
d80 18
a97 18
int	mtmatch __P((struct device *, struct cfdata *, void *));
void	mtattach __P((struct device *, struct device *, void *));
void	mtdgram __P((struct device *, struct mscp *, struct mscp_softc *));
void	mtiodone __P((struct device *, struct buf *));
int	mtonline __P((struct device *, struct mscp *));
int	mtgotstatus __P((struct device *, struct mscp *));
int	mtioerror __P((struct device *, struct mscp *, struct buf *));
void	mtfillin __P((struct buf *, struct mscp *));
int	mtopen __P((dev_t, int, int, struct proc *));
int	mtclose __P((dev_t, int, int, struct proc *));
void	mtstrategy __P((struct buf *));
int	mtread __P((dev_t, struct uio *));
int	mtwrite __P((dev_t, struct uio *));
int	mtioctl __P((dev_t, int, caddr_t, int, struct proc *));
int	mtdump __P((dev_t, daddr_t, caddr_t, size_t));
int	mtcmd __P((struct mt_softc *, int, int, int));
void	mtcmddone __P((struct device *, struct mscp *));
int	mt_putonline __P((struct mt_softc *));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.6 2001/12/05 03:04:38 hugh Exp $ */
d80 18
a97 18
int	mtmatch(struct device *, struct cfdata *, void *);
void	mtattach(struct device *, struct device *, void *);
void	mtdgram(struct device *, struct mscp *, struct mscp_softc *);
void	mtiodone(struct device *, struct buf *);
int	mtonline(struct device *, struct mscp *);
int	mtgotstatus(struct device *, struct mscp *);
int	mtioerror(struct device *, struct mscp *, struct buf *);
void	mtfillin(struct buf *, struct mscp *);
int	mtopen(dev_t, int, int, struct proc *);
int	mtclose(dev_t, int, int, struct proc *);
void	mtstrategy(struct buf *);
int	mtread(dev_t, struct uio *);
int	mtwrite(dev_t, struct uio *);
int	mtioctl(dev_t, int, caddr_t, int, struct proc *);
int	mtdump(dev_t, daddr_t, caddr_t, size_t);
int	mtcmd(struct mt_softc *, int, int, int);
void	mtcmddone(struct device *, struct mscp *);
int	mt_putonline(struct mt_softc *);
a259 1
	int s;
a275 1
	s = splbio();
a276 1
	splx(s);
a301 1
	int s;
a302 1
	s = splbio();
a303 1
	splx(s);
@


1.5
log
@Fix off-by-one error in unit checking
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_tape.c,v 1.4 2000/04/27 03:14:46 bjc Exp $ */
/*	$NetBSD: mscp_tape.c,v 1.14 1999/06/06 19:16:18 ragge Exp $ */
d44 2
d120 1
a120 1
struct	cfdriver mt_cd = {
d202 1
a202 1
	register struct mt_softc *mt;
d256 1
a256 1
	register struct buf *bp;
d258 2
a259 2
	register int unit;
	register struct mt_softc *mt;
d265 1
a265 1
	if (unit >= mt_cd.cd_ndevs || (mt = mt_cd.cd_devs[unit]) == NULL) {
d349 1
a349 1
	register struct mt_softc *mt = (void *)usc;
d363 2
a364 2
	register struct device *usc;
	register struct mscp *mp;
d395 2
a396 2
	register struct device *usc;
	register struct mscp *mp;
d430 2
a431 2
	register int unit = mtunit(dev);
	register struct mt_softc *mt = mt_cd.cd_devs[unit];
@


1.4
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.3 1997/09/12 09:25:52 maja Exp $ */
d263 1
a263 1
	if (unit > mt_cd.cd_ndevs || (mt = mt_cd.cd_devs[unit]) == NULL) {
@


1.3
log
@Sync with NetBSD 970827. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_tape.c,v 1.2 1997/05/29 00:05:03 niklas Exp $ */
/*	$NetBSD: mscp_tape.c,v 1.5 1997/07/04 11:58:22 ragge Exp $ */
d17 2
a18 2
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
d55 6
a60 2
#include <vax/mscp/mscp.h>
#include <vax/mscp/mscpvar.h>
d75 2
a76 2
#define	MT_OFFLINE	0
#define	MT_ONLINE	1
d78 1
a78 1
int	mtmatch __P((struct device *, void *, void *));
d95 1
d110 3
a112 3
#define	mtunit(dev)	(minor(dev) & T_UNIT)
#define	mtnorewind(dev)	(dev & T_NOREWIND)
#define	mthdensity(dev)	(dev & T_1600BPI)
d114 2
a115 2
struct	cfdriver mt_cd = {
	NULL, "mt", DV_DULL
d118 2
a119 2
struct	cfattach mt_ca = {
	sizeof(struct mt_softc), mtmatch, mtattach
d127 1
a127 1
mtmatch(parent, match, aux)
d129 2
a130 1
	void	*match, *aux;
a131 1
	struct	cfdata *cf = match;
d173 1
a173 1
	(volatile)mt->mt_state = MT_OFFLINE;
d181 1
a181 1
	i = *mi->mi_ip;
d185 1
a185 1
	if ((volatile)mt->mt_state != MT_ONLINE)
d217 2
a218 1
	if (mt_putonline(mt) == MSCP_FAILED)
d220 1
d279 2
a280 2
        dev_t dev;
        struct uio *uio;
d283 1
a283 1
        return (physio(mtstrategy, NULL, dev, B_READ, minphys, uio));
d288 2
a289 2
        dev_t dev;
        struct uio *uio;
d292 1
a292 1
        return (physio(mtstrategy, NULL, dev, B_WRITE, minphys, uio));
d373 1
a373 1
	"unit write protected",	/* 6 M_ST_WRPROT */
d375 2
a376 2
	"data error", 		/* 8 M_ST_DATAERR */
	"host buffer access error", 	/* 9 M_ST_HOSTBUFERR */
d378 1
a378 1
	"drive error", 		/* 11 M_ST_DRIVEERR */
d411 1
d432 1
a432 1
	int error = 0, i, count;
d466 2
a467 2
	daddr_t	blkno;
	caddr_t	va;
d547 1
a547 1
	i = *mi->mi_ip;
@


1.3.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_tape.c,v 1.4 2000/04/27 03:14:46 bjc Exp $ */
/*	$NetBSD: mscp_tape.c,v 1.14 1999/06/06 19:16:18 ragge Exp $ */
d17 2
a18 2
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
d55 2
a56 6
#include <machine/bus.h>
#include <machine/cpu.h>

#include <arch/vax/mscp/mscp.h>
#include <arch/vax/mscp/mscpreg.h>
#include <arch/vax/mscp/mscpvar.h>
d71 2
a72 2
#define MT_OFFLINE	0
#define MT_ONLINE	1
d74 1
a74 1
int	mtmatch __P((struct device *, struct cfdata *, void *));
a90 1
int	mt_putonline __P((struct mt_softc *));
d105 3
a107 3
#define mtunit(dev)	(minor(dev) & T_UNIT)
#define mtnorewind(dev) (dev & T_NOREWIND)
#define mthdensity(dev) (dev & T_1600BPI)
d109 2
a110 2
struct	cfattach mt_ca = {
	sizeof(struct mt_softc), (cfmatch_t)mtmatch, mtattach
d113 2
a114 2
struct	cfdriver mt_cd = {
	NULL, "mt", DV_TAPE
d122 1
a122 1
mtmatch(parent, cf, aux)
d124 1
a124 2
	struct	cfdata *cf;
	void	*aux;
d126 1
d168 1
a168 1
	(volatile int)mt->mt_state = MT_OFFLINE;
d176 1
a176 1
	i = bus_space_read_2(mi->mi_iot, mi->mi_iph, 0);
d180 1
a180 1
	if ((volatile int)mt->mt_state != MT_ONLINE)
d212 1
a212 2
	if (mt_putonline(mt) == MSCP_FAILED) {
		mt->mt_inuse = 0;
a213 1
	}
d272 2
a273 2
	dev_t dev;
	struct uio *uio;
d276 1
a276 1
	return (physio(mtstrategy, NULL, dev, B_READ, minphys, uio));
d281 2
a282 2
	dev_t dev;
	struct uio *uio;
d285 1
a285 1
	return (physio(mtstrategy, NULL, dev, B_WRITE, minphys, uio));
d366 1
a366 1
	"unit write protected", /* 6 M_ST_WRPROT */
d368 2
a369 2
	"data error",		/* 8 M_ST_DATAERR */
	"host buffer access error",	/* 9 M_ST_HOSTBUFERR */
d371 1
a371 1
	"drive error",		/* 11 M_ST_DRIVEERR */
a403 1
		bp->b_error = EROFS;
d424 1
a424 1
	int error = 0, count;
d458 2
a459 2
	daddr_t blkno;
	caddr_t va;
d539 1
a539 1
	i = bus_space_read_2(mi->mi_iot, mi->mi_iph, 0);
@


1.3.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_tape.c,v 1.3.12.1 2001/05/14 21:38:14 niklas Exp $ */
d263 1
a263 1
	if (unit >= mt_cd.cd_ndevs || (mt = mt_cd.cd_devs[unit]) == NULL) {
@


1.3.12.3
log
@Merge in trunk
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: mscp_tape.c,v 1.16 2001/11/13 07:38:28 lukem Exp $ */
a43 2
#include <sys/cdefs.h>

d118 1
a118 1
struct cfdriver mt_cd = {
d200 1
a200 1
	struct mt_softc *mt;
d254 1
a254 1
	struct buf *bp;
d256 2
a257 2
	int unit;
	struct mt_softc *mt;
d263 1
a263 1
	if (unit > mt_cd.cd_ndevs || (mt = mt_cd.cd_devs[unit]) == NULL) {
d347 1
a347 1
	struct mt_softc *mt = (void *)usc;
d361 2
a362 2
	struct device *usc;
	struct mscp *mp;
d393 2
a394 2
	struct device *usc;
	struct mscp *mp;
d428 2
a429 2
	int unit = mtunit(dev);
	struct mt_softc *mt = mt_cd.cd_devs[unit];
@


1.3.12.4
log
@Merge in -current from about a week ago
@
text
@d80 18
a97 18
int	mtmatch(struct device *, struct cfdata *, void *);
void	mtattach(struct device *, struct device *, void *);
void	mtdgram(struct device *, struct mscp *, struct mscp_softc *);
void	mtiodone(struct device *, struct buf *);
int	mtonline(struct device *, struct mscp *);
int	mtgotstatus(struct device *, struct mscp *);
int	mtioerror(struct device *, struct mscp *, struct buf *);
void	mtfillin(struct buf *, struct mscp *);
int	mtopen(dev_t, int, int, struct proc *);
int	mtclose(dev_t, int, int, struct proc *);
void	mtstrategy(struct buf *);
int	mtread(dev_t, struct uio *);
int	mtwrite(dev_t, struct uio *);
int	mtioctl(dev_t, int, caddr_t, int, struct proc *);
int	mtdump(dev_t, daddr_t, caddr_t, size_t);
int	mtcmd(struct mt_softc *, int, int, int);
void	mtcmddone(struct device *, struct mscp *);
int	mt_putonline(struct mt_softc *);
@


1.3.12.5
log
@Sync the SMP branch with 3.3
@
text
@a259 1
	int s;
a275 1
	s = splbio();
a276 1
	splx(s);
a301 1
	int s;
a302 1
	s = splbio();
a303 1
	splx(s);
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_tape.c,v 1.4 1997/01/11 11:20:35 ragge Exp $ */
/*	$NetBSD: mscp_tape.c,v 1.4 1997/01/11 11:20:35 ragge Exp $ */
d68 1
d89 1
a89 1
void	mtcmd __P((struct mt_softc *, int));
d232 3
a234 3
		mtcmd(mt, MTWEOF);
		mtcmd(mt, MTWEOF);
		mtcmd(mt, MTBSR);
d237 1
a237 1
		mtcmd(mt, MTREW);
d239 1
a239 1
		mtcmd(mt, -1);
d261 1
d424 1
a424 1
	int error = 0, i;
d426 1
d432 6
a437 4
		i = mtop->mt_count;
		while (i-- > 0)
			mtcmd(mt, mtop->mt_op);
		break;
d468 4
d473 2
a474 2
void
mtcmd(mt, cmd)
d476 1
a476 1
	int cmd;
d484 1
d498 1
a498 2
		mp->mscp_modifier |= M_MD_OBJCOUNT;
		mp->mscp_seq.seq_buffer = 1;
d506 1
a506 1
		mp->mscp_seq.seq_bytecount = 1;
d512 2
d517 10
d541 1
d554 2
a555 1
	if (mp->mscp_status)
d558 1
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
