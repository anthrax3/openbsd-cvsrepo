head	1.42;
access;
symbols
	OPENBSD_5_9:1.41.0.6
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.8
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.6
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.4
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.2
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.8
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.12
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.8
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.41;
commitid	OSDG2O3Cgeifnf1W;

1.41
date	2014.05.08.19.06.07;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.01.20.27.21;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2011.11.01.20.52.17;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.05.21.39.08;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.06.18.12.47;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.22.06.40.25;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.08.14.47.10;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.22.17.10.23;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.08.22.19.46;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.13.15.23.13;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.04.21.38.10;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.08.05.35.31;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.07.05.22.32;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.05.00.38.19;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.13.21.05.24;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.12.19.56.18;	author thib;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.15.20.04.36;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.24.19.29.11;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.12.12.29.15;	author hugh;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.08.08.50.26;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.05.03.04.38;	author hugh;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.07.04.05.12.57;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.27.03.14.46;	author bjc;	state Exp;
branches;
next	1.6;

1.6
date	98.10.03.21.18.59;	author millert;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	97.09.12.09.25.51;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	97.09.10.11.54.42;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	97.08.08.21.46.56;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.00.05.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.24.51;	author maja;	state Exp;
branches;
next	;

1.6.8.1
date	2001.05.14.21.38.13;	author niklas;	state Exp;
branches;
next	1.6.8.2;

1.6.8.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.6.8.3;

1.6.8.3
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.6.8.4;

1.6.8.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.6.8.5;

1.6.8.5
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.6.8.6;

1.6.8.6
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	1.6.8.7;

1.6.8.7
date	2004.06.05.23.11.02;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.42
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: mscp_disk.c,v 1.41 2014/05/08 19:06:07 miod Exp $	*/
/*	$NetBSD: mscp_disk.c,v 1.30 2001/11/13 07:38:28 lukem Exp $	*/
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * Copyright (c) 1988 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uda.c	7.32 (Berkeley) 2/13/91
 */

/*
 * RA disk device driver
 * RX MSCP floppy disk device driver
 */

/*
 * TODO
 *	write bad block forwarding code
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/stat.h>
#include <sys/fcntl.h>
#include <sys/reboot.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/conf.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>

#include <machine/bus.h>
#include <machine/cpu.h>

#include <arch/vax/mscp/mscp.h>
#include <arch/vax/mscp/mscpreg.h>
#include <arch/vax/mscp/mscpvar.h>

#include "ra.h"

struct cfdriver ra_cd = {
	NULL, "ra", DV_DISK
};

struct cfdriver rx_cd = {
	NULL, "rx", DV_DISK
};

#define RAMAJOR 9	/* RA major device number XXX */

/*
 * Drive status, per drive
 */
struct ra_softc {
	struct device ra_dev;		/* autoconf struct */
	struct disk ra_disk;
	struct mscpv_guse ra_guse;	/* status information */
	u_long	ra_unitsize;		/* unit size in sectors */
	int	ra_state;		/* open/closed state */
	int	ra_hwunit;		/* Hardware unit number */
};

#define rx_softc ra_softc

void	rxattach(struct device *, struct device *, void *);
int	rx_putonline(struct rx_softc *);

#if NRA

int	ramatch(struct device *, struct cfdata *, void *);
int	raread(dev_t, struct uio *);
int	rawrite(dev_t, struct uio *);
int	ra_putonline(struct ra_softc *);
int	ragetdisklabel(dev_t, struct ra_softc *, struct disklabel *, int);
bdev_decl(ra);

const struct cfattach ra_ca = {
	sizeof(struct ra_softc), (cfmatch_t)ramatch, rxattach
};

/*
 * More driver definitions, for generic MSCP code.
 */

int
ramatch(struct device *parent, struct cfdata *cf, void *aux)
{
	struct drive_attach_args *da = aux;
	struct mscp *mp = da->da_mp;

	if ((da->da_typ & MSCPBUS_DISK) == 0)
		return 0;
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != mp->mscp_unit)
		return 0;
	/*
	 * Check if this disk is a floppy; then don't configure it.
	 * Seems to be a safe way to test it per Chris Torek.
	 */
	if (MSCP_MID_ECH(1, mp->mscp_guse.guse_mediaid) == 'X' - '@@')
		return 0;
	return 1;
}

/*
 * Read the label from the drive.
 */
int
ragetdisklabel(dev_t dev, struct ra_softc *ra, struct disklabel *lp,
    int spoofonly)
{
	int n, p = 0;

	bzero(lp, sizeof(struct disklabel));
	lp->d_secsize = DEV_BSIZE;
	lp->d_nsectors = ra->ra_guse.guse_nspt;
	lp->d_ntracks = ra->ra_guse.guse_ngpc * ra->ra_guse.guse_group;
	lp->d_secpercyl = lp->d_nsectors * lp->d_ntracks;
	DL_SETDSIZE(lp, ra->ra_unitsize);	/* XXX might be zero */

	if (lp->d_secpercyl) {
		lp->d_ncylinders = ra->ra_unitsize / lp->d_secpercyl;
		lp->d_type = DTYPE_MSCP;
	} else {
		lp->d_type = DTYPE_FLOPPY;
	}

	lp->d_bbsize = BBSIZE;
	lp->d_sbsize = SBSIZE;

	/* Create the disk name for disklabel. Phew... */
	lp->d_typename[p++] = MSCP_MID_CHAR(2, ra->ra_guse.guse_mediaid);
	lp->d_typename[p++] = MSCP_MID_CHAR(1, ra->ra_guse.guse_mediaid);
	if (MSCP_MID_ECH(0, ra->ra_guse.guse_mediaid))
		lp->d_typename[p++] =
		    MSCP_MID_CHAR(0, ra->ra_guse.guse_mediaid);
	n = MSCP_MID_NUM(ra->ra_guse.guse_mediaid);
	if (n > 99) {
		lp->d_typename[p++] = '1';
		n -= 100;
	}
	if (n > 9) {
		lp->d_typename[p++] = (n / 10) + '0';
		n %= 10;
	}
	lp->d_typename[p++] = n + '0';
	lp->d_typename[p] = 0;

	lp->d_version = 1;
	lp->d_magic = lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	return readdisklabel(DISKLABELDEV(dev), rastrategy, lp, spoofonly);
}

/*
 * (Try to) put the drive online. This is done the first time the
 * drive is opened, or if it has fallen offline.
 */
int
ra_putonline(struct ra_softc *ra)
{
	struct disklabel *dl;
	int rc;

	ra->ra_state = DK_RDLABEL;
	if (rx_putonline(ra) != MSCP_DONE)
		return MSCP_FAILED;

	dl = ra->ra_disk.dk_label;
	rc = ragetdisklabel(MAKEDISKDEV(RAMAJOR, ra->ra_dev.dv_unit, RAW_PART),
	    ra, dl, 0);
	if (rc != EIO)
		ra->ra_state = DK_OPEN;

	printf("%s: %luMB, %u bytes/sector, %lu sectors\n",
	    ra->ra_dev.dv_xname,
	    ra->ra_unitsize / (1048576 / dl->d_secsize),
	    dl->d_secsize, ra->ra_unitsize);

	return MSCP_DONE;
}

/*
 * Open a drive.
 */
/*ARGSUSED*/
int
raopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct ra_softc *ra;
	int part, unit, mask;

	/*
	 * Make sure this is a reasonable open request.
	 */
	unit = DISKUNIT(dev);
	if (unit >= ra_cd.cd_ndevs)
		return ENXIO;
	ra = ra_cd.cd_devs[unit];
	if (ra == 0)
		return ENXIO;

	/*
	 * If this is the first open; we must first try to put
	 * the disk online (and read the label).
	 */
	if (ra->ra_state == DK_CLOSED)
		if (ra_putonline(ra) == MSCP_FAILED)
			return ENXIO;

	part = DISKPART(dev);
	if (part >= ra->ra_disk.dk_label->d_npartitions)
		return ENXIO;

	/*
	 * Wait for the state to settle
	 */
#if notyet
	while (ra->ra_state != DK_OPEN)
		if ((error = tsleep((caddr_t)ra, (PZERO + 1) | PCATCH,
		    "devopen", 0))) {
			splx(s);
			return (error);
		}
#endif

	mask = 1 << part;

	switch (fmt) {
	case S_IFCHR:
		ra->ra_disk.dk_copenmask |= mask;
		break;
	case S_IFBLK:
		ra->ra_disk.dk_bopenmask |= mask;
		break;
	}
	ra->ra_disk.dk_openmask |= mask;
	return 0;
}

/* ARGSUSED */
int
raclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct ra_softc *ra = ra_cd.cd_devs[unit];
	int mask = (1 << DISKPART(dev));

	switch (fmt) {
	case S_IFCHR:
		ra->ra_disk.dk_copenmask &= ~mask;
		break;
	case S_IFBLK:
		ra->ra_disk.dk_bopenmask &= ~mask;
		break;
	}
	ra->ra_disk.dk_openmask =
	    ra->ra_disk.dk_copenmask | ra->ra_disk.dk_bopenmask;

	/*
	 * Should wait for I/O to complete on this partition even if
	 * others are open, but wait for work on blkflush().
	 */
#if notyet
	if (ra->ra_openpart == 0) {
		s = spluba();
		while (BUFQ_FIRST(&udautab[unit]) != NULL)
			(void) tsleep(&udautab[unit], PZERO - 1,
			    "raclose", 0);
		splx(s);
		ra->ra_state = DK_CLOSED;
	}
#endif
	return (0);
}

/*
 * Queue a transfer request, and if possible, hand it to the controller.
 */
void
rastrategy(struct buf *bp)
{
	int unit;
	struct ra_softc *ra;
	int s;

	/*
	 * Make sure this is a reasonable drive to use.
	 */
	unit = DISKUNIT(bp->b_dev);
	if (unit >= ra_cd.cd_ndevs || (ra = ra_cd.cd_devs[unit]) == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}
	/*
	 * If drive is open `raw' or reading label, let it at it.
	 */
	if (ra->ra_state == DK_RDLABEL) {
		s = splbio();
		disk_busy(&ra->ra_disk);
		splx(s);
		mscp_strategy(bp, ra->ra_dev.dv_parent);
		return;
	}

	/* If disk is not online, try to put it online */
	if (ra->ra_state == DK_CLOSED)
		if (ra_putonline(ra) == MSCP_FAILED) {
			bp->b_error = EIO;
			goto bad;
		}

	/* Validate the request. */
	if (bounds_check_with_label(bp, ra->ra_disk.dk_label) == -1)
		goto done;

	/* Make some statistics... /bqt */
	s = splbio();
	disk_busy(&ra->ra_disk);
	splx(s);
	mscp_strategy(bp, ra->ra_dev.dv_parent);
	return;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
}

int
raread(dev_t dev, struct uio *uio)
{

	return (physio(rastrategy, dev, B_READ, minphys, uio));
}

int
rawrite(dev_t dev, struct uio *uio)
{

	return (physio(rastrategy, dev, B_WRITE, minphys, uio));
}

/*
 * I/O controls.
 */
int
raioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct disklabel *lp, *tp;
	struct ra_softc *ra = ra_cd.cd_devs[unit];
	int error = 0;

	lp = ra->ra_disk.dk_label;

	switch (cmd) {
	case DIOCGPDINFO:
		ragetdisklabel(dev, ra, (struct disklabel *)data, 1);
		break;

	case DIOCGDINFO:
		bcopy(lp, data, sizeof (struct disklabel));
		break;

	case DIOCGPART:
		((struct partinfo *)data)->disklab = lp;
		((struct partinfo *)data)->part =
		    &lp->d_partitions[DISKPART(dev)];
		break;

	case DIOCWDINFO:
	case DIOCSDINFO:
		tp = (struct disklabel *)data;

		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			error = setdisklabel(lp, tp, 0);
			if (error == 0 && cmd == DIOCWDINFO) {
				error = writedisklabel(dev, rastrategy, lp);
			}
		}
		break;

	default:
		error = ENOTTY;
		break;
	}
	return (error);
}


int
radump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	return ENXIO;
}

/*
 * Return the size of a partition, if known, or -1 if not.
 */
daddr_t
rasize(dev_t dev)
{
	int unit = DISKUNIT(dev), part = DISKPART(dev);
	struct ra_softc *ra;
	struct disklabel *lp;

	if (unit >= ra_cd.cd_ndevs || ra_cd.cd_devs[unit] == NULL)
		return -1;

	ra = ra_cd.cd_devs[unit];

	if (ra->ra_state == DK_CLOSED)
		if (ra_putonline(ra) == MSCP_FAILED)
			return -1;

	lp = ra->ra_disk.dk_label;
	if (part >= lp->d_npartitions ||
	    lp->d_partitions[part].p_fstype != FS_SWAP)
		return -1;
	else
		return DL_GETPSIZE(&lp->d_partitions[part]) *
		    (lp->d_secsize / DEV_BSIZE);
}

#endif /* NRA */

#if NRX

int	rxmatch(struct device *, struct cfdata *, void *);
int	rxopen(dev_t, int, int, struct proc *);
int	rxclose(dev_t, int, int, struct proc *);
void	rxstrategy(struct buf *);
int	rxread(dev_t, struct uio *);
int	rxwrite(dev_t, struct uio *);
int	rxioctl(dev_t, int, caddr_t, int, struct proc *);
int	rxdump(dev_t, daddr_t, caddr_t, size_t);
daddr_t	rxsize(dev_t);

const struct cfattach rx_ca = {
	sizeof(struct rx_softc), (cfmatch_t)rxmatch, rxattach
};

/*
 * More driver definitions, for generic MSCP code.
 */

int
rxmatch(struct device *parent, struct cfdata *cf, void *aux)
{
	struct drive_attach_args *da = aux;
	struct mscp *mp = da->da_mp;

	if ((da->da_typ & MSCPBUS_DISK) == 0)
		return 0;
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != mp->mscp_unit)
		return 0;
	/*
	 * Check if this disk is a floppy; then configure it.
	 * Seems to be a safe way to test it per Chris Torek.
	 */
	if (MSCP_MID_ECH(1, mp->mscp_guse.guse_mediaid) == 'X' - '@@')
		return 1;
	return 0;
}

#endif /* NRX */

/*
 * The attach routine only checks and prints drive type.
 * Bringing the disk online is done when the disk is accessed
 * the first time.
 */
void
rxattach(struct device *parent, struct device *self, void *aux)
{
	struct rx_softc *rx = (void *)self;
	struct drive_attach_args *da = aux;
	struct mscp *mp = da->da_mp;
	struct mscp_softc *mi = (void *)parent;

	bcopy(&mp->mscp_guse, &rx->ra_guse, sizeof(struct mscpv_guse));
	rx->ra_state = DK_CLOSED;
	rx->ra_hwunit = mp->mscp_unit;
	mi->mi_dp[mp->mscp_unit] = self;

	rx->ra_disk.dk_name = rx->ra_dev.dv_xname;
	disk_attach(&rx->ra_dev, &rx->ra_disk);

	disk_printtype(mp->mscp_unit, mp->mscp_guse.guse_mediaid);
#ifdef DEBUG
	printf("%s: nspt %d group %d ngpc %d rct %d nrpt %d nrct %d\n",
	    self->dv_xname, mp->mscp_guse.guse_nspt, mp->mscp_guse.guse_group,
	    mp->mscp_guse.guse_ngpc, mp->mscp_guse.guse_rctsize,
	    mp->mscp_guse.guse_nrpt, mp->mscp_guse.guse_nrct);
#endif
}

/*
 * (Try to) put the drive online. This is done the first time the
 * drive is opened, or if it has fallen offline.
 */
int
rx_putonline(struct rx_softc *rx)
{
	struct mscp *mp;
	struct mscp_softc *mi = (struct mscp_softc *)rx->ra_dev.dv_parent;
	volatile int i;

	/* caller may be in DK_RDLABEL state */
	if (rx->ra_state == DK_OPEN)
		rx->ra_state = DK_CLOSED;
	mp = mscp_getcp(mi, MSCP_WAIT);
	mp->mscp_opcode = M_OP_ONLINE;
	mp->mscp_unit = rx->ra_hwunit;
	mp->mscp_cmdref = 1;
	*mp->mscp_addr |= MSCP_OWN | MSCP_INT;
	DELAY(10000);		/* XXX SIMH needs this. */

	/* Poll away */
	i = bus_space_read_2(mi->mi_iot, mi->mi_iph, 0);
	if (tsleep(&rx->ra_dev.dv_unit, PRIBIO, "rxonline", 100*100) != 0) {
		rx->ra_state = DK_CLOSED;
		return MSCP_FAILED;
	}

	return MSCP_DONE;
}

#if NRX

/*
 * Open a drive.
 */
/*ARGSUSED*/
int
rxopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct rx_softc *rx;
	int unit;

	/*
	 * Make sure this is a reasonable open request.
	 */
	unit = DISKUNIT(dev);
	if (unit >= rx_cd.cd_ndevs)
		return ENXIO;
	rx = rx_cd.cd_devs[unit];
	if (rx == 0)
		return ENXIO;

	/*
	 * If this is the first open; we must first try to put
	 * the disk online (and read the label).
	 */
	if (rx->ra_state == DK_CLOSED)
		if (rx_putonline(rx) == MSCP_FAILED)
			return ENXIO;

	return 0;
}

/* ARGSUSED */
int
rxclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	return (0);
}

/*
 * Queue a transfer request, and if possible, hand it to the controller.
 *
 * This routine is broken into two so that the internal version
 * udastrat1() can be called by the (nonexistent, as yet) bad block
 * revectoring routine.
 */
void
rxstrategy(struct buf *bp)
{
	int unit;
	struct rx_softc *rx;
	int s;

	/*
	 * Make sure this is a reasonable drive to use.
	 */
	unit = DISKUNIT(bp->b_dev);
	if (unit >= rx_cd.cd_ndevs || (rx = rx_cd.cd_devs[unit]) == NULL) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		goto done;
	}

	/* If disk is not online, try to put it online */
	if (rx->ra_state == DK_CLOSED)
		if (rx_putonline(rx) == MSCP_FAILED) {
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
			goto done;
		}

	/*
	 * Determine the size of the transfer, and make sure it is
	 * within the boundaries of the partition.
	 */
	if (bp->b_blkno >= DL_GETDSIZE(rx->ra_disk.dk_label)) {
		bp->b_resid = bp->b_bcount;
		goto done;
	}

	/* Make some statistics... /bqt */
	s = splbio();
	disk_busy(&rx->ra_disk);
	splx(s);
	mscp_strategy(bp, rx->ra_dev.dv_parent);
	return;

done:
	s = splbio();
	biodone(bp);
	splx(s);
}

int
rxread(dev_t dev, struct uio *uio)
{

	return (physio(rxstrategy, dev, B_READ, minphys, uio));
}

int
rxwrite(dev_t dev, struct uio *uio)
{

	return (physio(rxstrategy, dev, B_WRITE, minphys, uio));
}

/*
 * I/O controls.
 */
int
rxioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct disklabel *lp;
	struct rx_softc *rx = rx_cd.cd_devs[unit];
	int error = 0;

	lp = rx->ra_disk.dk_label;

	switch (cmd) {

	case DIOCGDINFO:
	case DIOCGPDINFO:	/* no separate 'physical' info available. */
		bcopy(lp, data, sizeof (struct disklabel));
		break;

	case DIOCGPART:
		((struct partinfo *)data)->disklab = lp;
		((struct partinfo *)data)->part =
		    &lp->d_partitions[DISKPART(dev)];
		break;


	case DIOCWDINFO:
	case DIOCSDINFO:
		break;

	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

int
rxdump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{

	/* Not likely. */
	return ENXIO;
}

daddr_t
rxsize(dev_t dev)
{

	return -1;
}

#endif /* NRX */

void	rrdgram(struct device *, struct mscp *, struct mscp_softc *);
void	rriodone(struct device *, struct buf *);
int	rronline(struct device *, struct mscp *);
int	rrgotstatus(struct device *, struct mscp *);
void	rrreplace(struct device *, struct mscp *);
int	rrioerror(struct device *, struct mscp *, struct buf *);
void	rrfillin(struct buf *, struct mscp *);
void	rrbb(struct device *, struct mscp *, struct buf *);

struct mscp_device ra_device = {
	rrdgram,
	rriodone,
	rronline,
	rrgotstatus,
	rrreplace,
	rrioerror,
	rrbb,
	rrfillin,
};

/*
 * Handle an error datagram.
 * This can come from an unconfigured drive as well.
 */
void
rrdgram(struct device *usc, struct mscp *mp, struct mscp_softc *mi)
{
	if (mscp_decodeerror(usc == NULL?"unconf disk" : usc->dv_xname, mp, mi))
		return;
	/*
	 * SDI status information bytes 10 and 11 are the microprocessor
	 * error code and front panel code respectively.  These vary per
	 * drive type and are printed purely for field service information.
	 */
	if (mp->mscp_format == M_FM_SDI)
		printf("\tsdi uproc error code 0x%x, front panel code 0x%x\n",
			mp->mscp_erd.erd_sdistat[10],
			mp->mscp_erd.erd_sdistat[11]);
}

void
rriodone(struct device *usc, struct buf *bp)
{
	int s;
	struct rx_softc *rx = NULL; /* Wall */

	int unit = DISKUNIT(bp->b_dev);
#if NRA
	if (major(bp->b_dev) == RAMAJOR)
		rx = ra_cd.cd_devs[unit];
#endif
#if NRX
	if (major(bp->b_dev) != RAMAJOR)
		rx = rx_cd.cd_devs[unit];
#endif

	s = splbio();
	disk_unbusy(&rx->ra_disk, bp->b_bcount - bp->b_resid,
	    bp->b_flags & B_READ);
	biodone(bp);
	splx(s);
}

/*
 * A drive came on line.  Check its type and size.  Return DONE if
 * we think the drive is truly on line.	 In any case, awaken anyone
 * sleeping on the drive on-line-ness.
 */
int
rronline(struct device *usc, struct mscp *mp)
{
	struct rx_softc *rx = (struct rx_softc *)usc;

	wakeup((caddr_t)&usc->dv_unit);
	if ((mp->mscp_status & M_ST_MASK) != M_ST_SUCCESS) {
		printf("%s: attempt to bring on line failed: ", usc->dv_xname);
		mscp_printevent(mp);
		return (MSCP_FAILED);
	}

	rx->ra_state = DK_OPEN;
	rx->ra_unitsize = mp->mscp_onle.onle_unitsize;

	return (MSCP_DONE);
}

/*
 * We got some (configured) unit's status.  Return DONE if it succeeded.
 */
int
rrgotstatus(struct device *usc, struct mscp *mp)
{
	if ((mp->mscp_status & M_ST_MASK) != M_ST_SUCCESS) {
		printf("%s: attempt to get status failed: ", usc->dv_xname);
		mscp_printevent(mp);
		return (MSCP_FAILED);
	}
	/* record for (future) bad block forwarding and whatever else */
#ifdef notyet
	uda_rasave(ui->ui_unit, mp, 1);
#endif
	return (MSCP_DONE);
}

/*
 * A replace operation finished.
 */
/*ARGSUSED*/
void
rrreplace(struct device *usc, struct mscp *mp)
{

	panic("udareplace");
}

/*
 * A transfer failed.  We get a chance to fix or restart it.
 * Need to write the bad block forwaring code first....
 */
/*ARGSUSED*/
int
rrioerror(struct device *usc, struct mscp *mp, struct buf *bp)
{
	struct ra_softc *ra = (void *)usc;
	int code = mp->mscp_event;

	switch (code & M_ST_MASK) {
	/* The unit has fallen offline. Try to figure out why. */
	case M_ST_OFFLINE:
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
		ra->ra_state = DK_CLOSED;
		if (code & M_OFFLINE_UNMOUNTED)
			printf("%s: not mounted/spun down\n", usc->dv_xname);
		if (code & M_OFFLINE_DUPLICATE)
			printf("%s: duplicate unit number!!!\n", usc->dv_xname);
		return MSCP_DONE;

	case M_ST_AVAILABLE:
		ra->ra_state = DK_CLOSED; /* Force another online */
		return MSCP_DONE;

	default:
		printf("%s:", usc->dv_xname);
		break;
	}
	return (MSCP_FAILED);
}

/*
 * Fill in disk addresses in a mscp packet waiting for transfer.
 */
void
rrfillin(struct buf *bp, struct mscp *mp)
{
	struct rx_softc *rx = 0; /* Wall */
	struct disklabel *lp;
	int unit = DISKUNIT(bp->b_dev);
	int part = DISKPART(bp->b_dev);

#if NRA
	if (major(bp->b_dev) == RAMAJOR)
		rx = ra_cd.cd_devs[unit];
#endif
#if NRX
	if (major(bp->b_dev) != RAMAJOR)
		rx = rx_cd.cd_devs[unit];
#endif
	lp = rx->ra_disk.dk_label;

	mp->mscp_seq.seq_lbn = DL_GETPOFFSET(&lp->d_partitions[part]) + bp->b_blkno;
	mp->mscp_unit = rx->ra_hwunit;
	mp->mscp_seq.seq_bytecount = bp->b_bcount;
}

/*
 * A bad block related operation finished.
 */
/*ARGSUSED*/
void
rrbb(struct device *usc, struct mscp *mp, struct buf *bp)
{

	panic("udabb");
}
@


1.41
log
@Format string fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.40 2013/11/01 20:27:21 krw Exp $	*/
@


1.40
log
@Use %lu to print u_long, not %lld.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.39 2013/06/11 16:42:13 deraadt Exp $	*/
d208 1
a208 1
	printf("%s: %luMB, %lu bytes/sector, %lu sectors\n",
@


1.39
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.38 2011/11/01 20:52:17 miod Exp $	*/
d208 1
a208 1
	printf("%s: %luMB, %lu bytes/sector, %lld sectors\n",
@


1.38
log
@Rework disklabel handling to correctly support label spoofing, and thus
fix DIOCGPDINFO ioctl behaviour in the process.
Tested in SIMH only due to the lack of MSCP disks, RX02 floppies untested
but shouldn't be affected by this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.37 2011/07/06 04:49:36 matthew Exp $	*/
d431 1
a431 1
radump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
d439 1
a439 1
daddr64_t
d475 2
a476 2
int	rxdump(dev_t, daddr64_t, caddr_t, size_t);
daddr64_t	rxsize(dev_t);
d715 1
a715 1
rxdump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
d722 1
a722 1
daddr64_t
@


1.37
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.36 2011/07/05 21:39:08 krw Exp $	*/
a47 2
#include <sys/cdefs.h>

d88 6
a93 6
	struct	device ra_dev;	/* Autoconf struct */
	struct	disk ra_disk;
	int	ra_state;	/* open/closed state */
	u_long	ra_mediaid;	/* media id */
	int	ra_hwunit;	/* Hardware unit number */
	int	ra_havelabel;	/* true if we have a label */
a99 1
void	rrmakelabel(struct disklabel *, long);
a103 1
void	raattach(struct device *, struct device *, void *);
d107 1
d110 1
a110 1
struct	cfattach ra_ca = {
d119 1
a119 4
ramatch(parent, cf, aux)
	struct	device *parent;
	struct	cfdata *cf;
	void	*aux;
d121 2
a122 2
	struct	drive_attach_args *da = aux;
	struct	mscp *mp = da->da_mp;
d137 52
a188 1
/* 
d190 1
a190 1
 * drive is opened, or if it har fallen offline.
d193 1
a193 2
ra_putonline(ra)
	struct ra_softc *ra;
d195 2
a196 1
	struct	disklabel *dl;
d198 1
d203 3
a205 8

	ra->ra_state = DK_RDLABEL;
	printf("%s", ra->ra_dev.dv_xname);
	if ((readdisklabel(MAKEDISKDEV(RAMAJOR, ra->ra_dev.dv_unit,
	    RAW_PART), rastrategy, dl, 0)) != 0) {
		/* EIO and others */
	} else {
		ra->ra_havelabel = 1;
a206 1
	}
d208 4
a211 1
	printf(": size %lld sectors\n", DL_GETDSIZE(dl));
d221 1
a221 4
raopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct	proc *p;
d225 1
d276 1
a276 4
raclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct	proc *p;
d304 1
a304 1
		ra->ra_state = CLOSED;
d314 1
a314 2
rastrategy(bp)
	struct buf *bp;
d367 1
a367 3
raread(dev, uio)
	dev_t dev;
	struct uio *uio;
d374 1
a374 3
rawrite(dev, uio)
	dev_t dev;
	struct uio *uio;
d384 1
a384 6
raioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d394 3
a398 1
	case DIOCGPDINFO:	/* no separate 'physical' info available. */
d431 1
a431 5
radump(dev, blkno, va, size)
	dev_t	dev;
	daddr64_t blkno;
	caddr_t va;
	size_t	size;
d440 1
a440 2
rasize(dev)
	dev_t dev;
d442 1
a442 1
	int unit = DISKUNIT(dev);
d444 1
d446 1
a446 1
	if (unit >= ra_cd.cd_ndevs || ra_cd.cd_devs[unit] == 0)
d455 7
a461 2
	return DL_GETPSIZE(&ra->ra_disk.dk_label->d_partitions[DISKPART(dev)]) *
	    (ra->ra_disk.dk_label->d_secsize / DEV_BSIZE);
d478 1
a478 1
struct	cfattach rx_ca = {
d487 1
a487 4
rxmatch(parent, cf, aux)
	struct	device *parent;
	struct	cfdata *cf;
	void	*aux;
d489 2
a490 2
	struct	drive_attach_args *da = aux;
	struct	mscp *mp = da->da_mp;
d510 1
a510 1
 * the first time. 
d513 6
a518 9
rxattach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux; 
{
	struct	rx_softc *rx = (void *)self;
	struct	drive_attach_args *da = aux;
	struct	mscp *mp = da->da_mp;
	struct	mscp_softc *mi = (void *)parent;
	struct	disklabel *dl;
d520 1
a520 1
	rx->ra_mediaid = mp->mscp_guse.guse_mediaid;
a527 7
	/* Fill in what we know. The actual size is gotten later */
	dl = rx->ra_disk.dk_label;

	dl->d_secsize = DEV_BSIZE;
	dl->d_nsectors = mp->mscp_guse.guse_nspt;
	dl->d_ntracks = mp->mscp_guse.guse_ngpc * mp->mscp_guse.guse_group;
	dl->d_secpercyl = dl->d_nsectors * dl->d_ntracks;
d537 1
a537 1
/* 
d539 1
a539 1
 * drive is opened, or if it har fallen offline.
d542 1
a542 2
rx_putonline(rx)
	struct rx_softc *rx;
d544 2
a545 2
	struct	mscp *mp;
	struct	mscp_softc *mi = (struct mscp_softc *)rx->ra_dev.dv_parent;
d548 3
a550 1
	rx->ra_state = DK_CLOSED;
d560 1
a560 1
	if (tsleep(&rx->ra_dev.dv_unit, PRIBIO, "rxonline", 100*100))
a561 2

	if (rx->ra_state == DK_CLOSED)
d563 1
d575 1
a575 4
rxopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct	proc *p;
d603 1
a603 4
rxclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct	proc *p;
d616 1
a616 2
rxstrategy(bp)
	struct buf *bp;
d663 1
a663 3
rxread(dev, uio)
	dev_t dev;
	struct uio *uio;
d670 1
a670 3
rxwrite(dev, uio)
	dev_t dev;
	struct uio *uio;
d680 1
a680 6
rxioctl(dev, cmd, data, flag, p)
	dev_t dev;
	int cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d715 1
a715 5
rxdump(dev, blkno, va, size)
	dev_t dev;
	daddr64_t blkno;
	caddr_t va;
	size_t size;
d723 1
a723 2
rxsize(dev)
	dev_t dev;
d740 1
a740 2

struct	mscp_device ra_device = {
d754 4
a757 7
 */	
void	    
rrdgram(usc, mp, mi)
	struct device *usc;
	struct mscp *mp; 
	struct mscp_softc *mi;
{	 
d759 1
a759 1
		return;	 
d765 1
a765 1
	if (mp->mscp_format == M_FM_SDI) 
d771 2
a772 4
void	
rriodone(usc, bp)
	struct device *usc;
	struct buf *bp;
d800 1
a800 3
rronline(usc, mp)
	struct device *usc;
	struct mscp *mp;
a802 1
	struct disklabel *dl;
d812 1
a812 11
 
	dl = rx->ra_disk.dk_label;
	DL_SETDSIZE(dl, mp->mscp_onle.onle_unitsize);

	if (dl->d_secpercyl) {
		dl->d_ncylinders = DL_GETDSIZE(dl) / dl->d_secpercyl;
		dl->d_type = DTYPE_MSCP;
	} else {
		dl->d_type = DTYPE_FLOPPY;
	}
	rrmakelabel(dl, rx->ra_mediaid);
d817 1
a817 37
void
rrmakelabel(dl, type)
	struct disklabel *dl;
	long type;
{
	int n, p = 0;

	dl->d_bbsize = BBSIZE;
	dl->d_sbsize = SBSIZE;

	/* Create the disk name for disklabel. Phew... */
	dl->d_typename[p++] = MSCP_MID_CHAR(2, type);
	dl->d_typename[p++] = MSCP_MID_CHAR(1, type);
	if (MSCP_MID_ECH(0, type))
		dl->d_typename[p++] = MSCP_MID_CHAR(0, type);
	n = MSCP_MID_NUM(type);
	if (n > 99) {
		dl->d_typename[p++] = '1';
		n -= 100;
	}
	if (n > 9) {
		dl->d_typename[p++] = (n / 10) + '0';
		n %= 10;
	}
	dl->d_typename[p++] = n + '0';
	dl->d_typename[p] = 0;
	dl->d_npartitions = MAXPARTITIONS;
	DL_SETPSIZE(&dl->d_partitions[0], DL_GETDSIZE(dl));
	DL_SETPSIZE(&dl->d_partitions[2], DL_GETDSIZE(dl));
	DL_SETPOFFSET(&dl->d_partitions[0], 0);
	DL_SETPOFFSET(&dl->d_partitions[2], 0);
	dl->d_version = 1;
	dl->d_magic = dl->d_magic2 = DISKMAGIC;
	dl->d_checksum = dkcksum(dl);
}

/*	
d821 2
a822 4
rrgotstatus(usc, mp)
	struct device *usc;
	struct mscp *mp;
{	
d835 1
a835 1
/*	
d839 2
a840 4
void	
rrreplace(usc, mp)
	struct device *usc;
	struct mscp *mp;
d851 2
a852 5
int 
rrioerror(usc, mp, bp)
	struct device *usc;
	struct mscp *mp;
	struct buf *bp;
d884 1
a884 3
rrfillin(bp, mp)
	struct buf *bp;
	struct mscp *mp;
d911 1
a911 4
rrbb(usc, mp, bp)
	struct device *usc;
	struct mscp *mp;
	struct buf *bp;
@


1.36
log
@Add DIOCGPDINFO to rxioctl(), as a synonym for DIOCGDINFO, the last
place it was missing. Delete now redundant calls to DIOCGDINFO when
getting physical disk info in disklabel(8) and fdisk(8).

Reminded by a fdisk discussion with Andres Perera on tech@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.35 2011/06/05 18:40:33 matthew Exp $	*/
d289 1
a289 2
		bp->b_flags |= B_ERROR;
		goto done;
a304 1
			bp->b_flags |= B_ERROR;
d306 1
a306 1
			goto done;
d309 2
a310 5
	/*
	 * Determine the size of the transfer, and make sure it is
	 * within the boundaries of the partition.
	 */
	if (bounds_check_with_label(bp, ra->ra_disk.dk_label) <= 0)
d320 4
a323 1
done:
@


1.35
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.34 2011/06/03 21:14:11 matthew Exp $	*/
d692 1
@


1.34
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.33 2011/04/06 18:12:47 miod Exp $	*/
a95 1
	int	ra_wlabel;	/* label sector is currently writable */
a202 4
	/* If the disk has no label; allow writing everywhere */
	if (ra->ra_havelabel == 0)
		ra->ra_wlabel = 1;

a266 1
		ra->ra_wlabel = 0;
a388 1
				ra->ra_wlabel = 1;
a389 1
				ra->ra_wlabel = 0;
a393 7
	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			ra->ra_wlabel = 1;
		break;

a703 1
	case DIOCWLABEL:
@


1.33
log
@Use bdev_decl() to get block device function prototypes instead of rolling
our own (sometimes incorrect).
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.32 2010/09/22 06:40:25 krw Exp $	*/
d321 1
a321 2
	if (bounds_check_with_label(bp, ra->ra_disk.dk_label,
	    ra->ra_wlabel) <= 0)
@


1.32
log
@Add DIOCGPDINFO to drivers that were lacking it. Where there
is no easily available physical information outside of the stored
disklabel just make it a synonym for DIOCGDINFO.

Commit on the theory it is unlikely to harm, and fallout can be
addressed in the mass re-compile that will follow j2k10.

Should allow auto-allocation of disks to work with all devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.31 2010/09/22 01:18:57 matthew Exp $	*/
d62 1
a108 3
int	raopen(dev_t, int, int, struct proc *);
int	raclose(dev_t, int, int, struct proc *);
void	rastrategy(struct buf *);
a110 3
int	raioctl(dev_t, int, caddr_t, int, struct proc *);
int	radump(dev_t, daddr64_t, caddr_t, size_t);
daddr64_t	rasize(dev_t);
d112 1
d362 1
a362 1
	int cmd;
@


1.31
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.30 2010/09/08 14:47:10 jsing Exp $	*/
d381 1
@


1.30
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.28 2010/05/08 22:19:46 miod Exp $	*/
d348 1
a348 1
	return (physio(rastrategy, NULL, dev, B_READ, minphys, uio));
d357 1
a357 1
	return (physio(rastrategy, NULL, dev, B_WRITE, minphys, uio));
d678 1
a678 1
	return (physio(rxstrategy, NULL, dev, B_READ, minphys, uio));
d687 1
a687 1
	return (physio(rxstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.29
log
@missing dkio.h includes
@
text
@d522 1
a522 1
	disk_attach((struct disk *)&rx->ra_disk);
@


1.28
log
@disk_busy()/disk_unbusy() dance; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.27 2010/04/23 15:25:21 jsing Exp $	*/
d56 1
@


1.27
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.25 2009/06/04 21:38:10 miod Exp $	*/
d305 3
d804 11
d817 2
@


1.26
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@a834 1
		dl->d_rpm = 3600;
a836 1
		dl->d_rpm = 300;
a873 1
	dl->d_interleave = 1;
@


1.25
log
@Fix fallback from struct disklabel changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.24 2007/06/20 18:15:46 deraadt Exp $	*/
a155 1
	char *msg;
d164 3
a166 3
	if ((msg = readdisklabel(MAKEDISKDEV(RAMAJOR, ra->ra_dev.dv_unit,
	    RAW_PART), rastrategy, dl, 0)) != NULL) {
		/*printf(": %s", msg);*/
@


1.24
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.23 2007/06/08 05:35:31 deraadt Exp $	*/
d877 1
a877 1
	dl->d_interleave = dl->d_headswitch = 1;
@


1.23
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.22 2007/06/07 05:22:32 deraadt Exp $	*/
d166 1
a166 1
	    RAW_PART), rastrategy, dl, NULL, 0)) != NULL) {
d323 1
a323 1
	    ra->ra_disk.dk_cpulabel, ra->ra_wlabel) <= 0)
d394 1
a394 1
			error = setdisklabel(lp, tp, 0, 0);
d397 1
a397 1
				error = writedisklabel(dev, rastrategy, lp,0);
@


1.22
log
@more XXsize() functions not fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.21 2007/06/06 17:15:13 deraadt Exp $	*/
d878 1
@


1.21
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.20 2007/06/05 00:38:19 deraadt Exp $	*/
d114 1
a114 1
int	rasize(dev_t);
d431 1
a431 1
int
d463 1
a463 1
int	rxsize(dev_t);
d742 1
a742 1
int
@


1.20
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.19 2007/03/13 21:05:24 miod Exp $	*/
d113 1
a113 1
int	radump(dev_t, daddr_t, caddr_t, size_t);
d421 1
a421 1
	daddr_t blkno;
d462 1
a462 1
int	rxdump(dev_t, daddr_t, caddr_t, size_t);
d733 1
a733 1
	daddr_t blkno;
d831 1
a831 1
	DL_SETDSIZE(dl, (daddr_t)mp->mscp_onle.onle_unitsize);
@


1.19
log
@Nuke __HAVE_OLD_DISKLABEL code, this was never defined anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.18 2007/02/15 00:53:26 krw Exp $	*/
d173 1
a173 1
	printf(": size %d sectors\n", dl->d_secperunit);
d447 1
a447 1
	return ra->ra_disk.dk_label->d_partitions[DISKPART(dev)].p_size *
d651 1
a651 1
	if (bp->b_blkno >= rx->ra_disk.dk_label->d_secperunit) {
d831 1
a831 1
	dl->d_secperunit = (daddr_t)mp->mscp_onle.onle_unitsize;
d834 1
a834 1
		dl->d_ncylinders = dl->d_secperunit/dl->d_secpercyl;
d873 4
a876 3
	dl->d_partitions[0].p_size = dl->d_partitions[2].p_size =
	    dl->d_secperunit;
	dl->d_partitions[0].p_offset = dl->d_partitions[2].p_offset = 0;
d975 1
a975 1
	mp->mscp_seq.seq_lbn = lp->d_partitions[part].p_offset + bp->b_blkno;
@


1.18
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.17 2006/07/12 19:56:18 thib Exp $	*/
a371 3
#ifdef __HAVE_OLD_DISKLABEL
	struct disklabel newlabel;
#endif
a379 8
#ifdef __HAVE_OLD_DISKLABEL
	case ODIOCGDINFO:
		bcopy(lp, &newlabel, sizeof disklabel);
		if (newlabel.d_npartitions > OLDMAXPARTITIONS)
			return ENOTTY;
		bcopy(&newlabel, data, sizeof (struct olddisklabel));
		break;
#endif
a388 9
#ifdef __HAVE_OLD_DISKLABEL
	case ODIOCWDINFO:
	case ODIOCSDINFO:
		if (cmd == ODIOCSDINFO || xfer == ODIOCWDINFO) {
			memset(&newlabel, 0, sizeof newlabel);
			memcpy(&newlabel, data, sizeof (struct olddisklabel));
			tp = &newlabel;
		} else
#endif
d395 1
a395 6
			if ((error == 0) && (cmd == DIOCWDINFO
#ifdef __HAVE_OLD_DISKLABEL
			    || cmd == ODIOCWDINFO
#else
			    )) {
#endif
a408 30

#ifdef __NetBSD__
	case DIOCGDEFLABEL:
#ifdef __HAVE_OLD_DISKLABEL
	case ODIOCGDEFLABEL:
		if (cmd == ODIOCGDEFLABEL)
			tp = &newlabel;
		else
#else
		tp = (struct disklabel *)data;
#endif
		bzero(tp, sizeof(struct disklabel));
		tp->d_secsize = lp->d_secsize;
		tp->d_nsectors = lp->d_nsectors;
		tp->d_ntracks = lp->d_ntracks;
		tp->d_ncylinders = lp->d_ncylinders;
		tp->d_secpercyl = lp->d_secpercyl;
		tp->d_secperunit = lp->d_secperunit;
		tp->d_type = DTYPE_MSCP;
		tp->d_rpm = 3600;
		rrmakelabel(tp, ra->ra_mediaid);
#ifdef __HAVE_OLD_DISKLABEL
		if (cmd == ODIOCGDEFLABEL) {
			if (tp->d_npartitions > OLDMAXPARTITIONS)
				return ENOTTY;
			memcpy(data, tp, sizeof (struct olddisklabel));
		}
#endif
		break;
#endif /* __NetBSD__ */
@


1.17
log
@zap some unused variables.
the only use was in an #if notyet chunk since '97.

ok miod@@
'no objections' pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.16 2006/03/15 20:04:36 miod Exp $	*/
d166 3
a168 3
	    RAW_PART), rastrategy, dl, NULL, 0)) != NULL)
		printf(": %s", msg);
	else {
@


1.16
log
@Correct checks against cd_ndevs - valid numbers are strictly inferior to
cd_ndevs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.15 2004/09/24 19:29:11 kettenis Exp $	*/
d222 1
a222 1
		    devopn, 0))) {
@


1.15
log
@Add DELAY in rx_putonline() such that we can boot on the SIMH VAX simulator.
ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.14 2004/02/15 02:45:46 tedu Exp $	*/
d297 1
a297 1
	if (unit > ra_cd.cd_ndevs || (ra = ra_cd.cd_devs[unit]) == NULL) {
d688 1
a688 1
	if (unit > rx_cd.cd_ndevs || (rx = rx_cd.cd_devs[unit]) == NULL) {
@


1.14
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.13 2003/06/02 23:27:57 millert Exp $	*/
d610 1
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.12 2002/06/12 12:29:15 hugh Exp $	*/
d327 3
a329 2
	ra->ra_disk.dk_xfer++;
	ra->ra_disk.dk_bytes += bp->b_bcount;
d711 3
a713 2
	rx->ra_disk.dk_xfer++;
	rx->ra_disk.dk_bytes += bp->b_bcount;
@


1.12
log
@No longer need these getdev routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.11 2002/06/08 08:50:26 art Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@protect biodone with splbio
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.10 2002/03/14 01:26:48 millert Exp $	*/
a506 22
}

int ra_getdev(adaptor, controller, unit, uname)
    int adaptor, controller, unit;
    char **uname;
{
    struct mscp_softc *mi;
    struct ra_softc *ra;
    int i;

    for (i = 0; i < ra_cd.cd_ndevs; i++) {
        if ((ra = ra_cd.cd_devs[i]) == 0)
            continue;

        mi = (void *)ra->ra_dev.dv_parent;
        if (mi->mi_ctlrnr == controller && mi->mi_adapnr == adaptor &&
            ra->ra_hwunit == unit) {
            *uname = ra->ra_dev.dv_xname;
            return i;
        }
    }
    return -1;
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.9 2001/12/05 03:04:38 hugh Exp $	*/
d295 2
d337 1
d339 1
d706 1
d742 1
d744 1
d879 1
d881 1
d883 1
@


1.9
log
@sync with netbsd. untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.8 2001/07/04 05:12:57 csapuntz Exp $	*/
d103 3
a105 3
void	rxattach __P((struct device *, struct device *, void *));
int	rx_putonline __P((struct rx_softc *));
void	rrmakelabel __P((struct disklabel *, long));
d109 11
a119 11
int	ramatch __P((struct device *, struct cfdata *, void *));
void	raattach __P((struct device *, struct device *, void *));
int	raopen __P((dev_t, int, int, struct proc *));
int	raclose __P((dev_t, int, int, struct proc *));
void	rastrategy __P((struct buf *));
int	raread __P((dev_t, struct uio *));
int	rawrite __P((dev_t, struct uio *));
int	raioctl __P((dev_t, int, caddr_t, int, struct proc *));
int	radump __P((dev_t, daddr_t, caddr_t, size_t));
int	rasize __P((dev_t));
int	ra_putonline __P((struct ra_softc *));
d531 9
a539 9
int	rxmatch __P((struct device *, struct cfdata *, void *));
int	rxopen __P((dev_t, int, int, struct proc *));
int	rxclose __P((dev_t, int, int, struct proc *));
void	rxstrategy __P((struct buf *));
int	rxread __P((dev_t, struct uio *));
int	rxwrite __P((dev_t, struct uio *));
int	rxioctl __P((dev_t, int, caddr_t, int, struct proc *));
int	rxdump __P((dev_t, daddr_t, caddr_t, size_t));
int	rxsize __P((dev_t));
d823 8
a830 8
void	rrdgram __P((struct device *, struct mscp *, struct mscp_softc *));
void	rriodone __P((struct device *, struct buf *));
int	rronline __P((struct device *, struct mscp *));
int	rrgotstatus __P((struct device *, struct mscp *));
void	rrreplace __P((struct device *, struct mscp *));
int	rrioerror __P((struct device *, struct mscp *, struct buf *));
void	rrfillin __P((struct buf *, struct mscp *));
void	rrbb __P((struct device *, struct mscp *, struct buf *));
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.9 2001/12/05 03:04:38 hugh Exp $	*/
d103 3
a105 3
void	rxattach(struct device *, struct device *, void *);
int	rx_putonline(struct rx_softc *);
void	rrmakelabel(struct disklabel *, long);
d109 11
a119 11
int	ramatch(struct device *, struct cfdata *, void *);
void	raattach(struct device *, struct device *, void *);
int	raopen(dev_t, int, int, struct proc *);
int	raclose(dev_t, int, int, struct proc *);
void	rastrategy(struct buf *);
int	raread(dev_t, struct uio *);
int	rawrite(dev_t, struct uio *);
int	raioctl(dev_t, int, caddr_t, int, struct proc *);
int	radump(dev_t, daddr_t, caddr_t, size_t);
int	rasize(dev_t);
int	ra_putonline(struct ra_softc *);
a294 2
	int s;

a334 1
	s = splbio();
a335 1
	splx(s);
d531 9
a539 9
int	rxmatch(struct device *, struct cfdata *, void *);
int	rxopen(dev_t, int, int, struct proc *);
int	rxclose(dev_t, int, int, struct proc *);
void	rxstrategy(struct buf *);
int	rxread(dev_t, struct uio *);
int	rxwrite(dev_t, struct uio *);
int	rxioctl(dev_t, int, caddr_t, int, struct proc *);
int	rxdump(dev_t, daddr_t, caddr_t, size_t);
int	rxsize(dev_t);
a701 1
	int s;
a736 1
	s = splbio();
a737 1
	splx(s);
d823 8
a830 8
void	rrdgram(struct device *, struct mscp *, struct mscp_softc *);
void	rriodone(struct device *, struct buf *);
int	rronline(struct device *, struct mscp *);
int	rrgotstatus(struct device *, struct mscp *);
void	rrreplace(struct device *, struct mscp *);
int	rrioerror(struct device *, struct mscp *, struct buf *);
void	rrfillin(struct buf *, struct mscp *);
void	rrbb(struct device *, struct mscp *, struct buf *);
a871 1
	int s;
a872 1
	s = splbio();
a873 1
	splx(s);
@


1.9.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.9.2.1 2002/06/11 03:39:19 art Exp $	*/
d507 22
@


1.8
log
@Fix off-by-one error in unit checking
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_disk.c,v 1.7 2000/04/27 03:14:46 bjc Exp $	*/
/*	$NetBSD: mscp_disk.c,v 1.21 1999/06/06 19:16:18 ragge Exp $	*/
d52 2
a70 1
#include <machine/rpb.h>
d122 1
a122 1
	sizeof(struct ra_softc), (cfmatch_t)ramatch, raattach
d141 1
a141 1
	   	return 0;
a150 23
/*
 * The attach routine only checks and prints drive type.
 * Bringing the disk online is done when the disk is accessed
 * the first time. 
 */
void
raattach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux; 
{
	struct	ra_softc *ra = (void *)self;
	struct	mscp_softc *mi = (void *)parent;

	rxattach(parent, self, aux);
	/*
	 * Find out if we booted from this disk.
	 */
	if ((B_TYPE(bootdev) == BDEV_UDA) && (ra->ra_hwunit == B_UNIT(bootdev))
	    && (mi->mi_ctlrnr == B_CONTROLLER(bootdev))
	    && (mi->mi_adapnr == B_ADAPTOR(bootdev)))
		booted_from = self;
}

d192 1
a192 1
	register struct ra_softc *ra;
d253 2
a254 2
	register int unit = DISKUNIT(dev);
	register struct ra_softc *ra = ra_cd.cd_devs[unit];
d274 4
a277 3
		s = splimp();
		while (udautab[unit].b_actf)
			sleep((caddr_t)&udautab[unit], PZERO - 1);
d291 1
a291 1
	register struct buf *bp;
d293 2
a294 2
	register int unit;
	register struct ra_softc *ra;
d299 1
a299 1
	if (unit >= ra_cd.cd_ndevs || (ra = ra_cd.cd_devs[unit]) == NULL) {
d367 3
a369 3
	register int unit = DISKUNIT(dev);
	register struct disklabel *lp, *tp;
	register struct ra_softc *ra = ra_cd.cd_devs[unit];
d371 3
d382 8
d399 11
d413 7
a419 2
			error = setdisklabel(lp, (struct disklabel *)data,0,0);
			if ((error == 0) && (cmd == DIOCWDINFO)) {
d436 6
d443 2
a444 1
		bzero(data, sizeof(struct disklabel));
d454 7
d462 1
a462 1
#endif
d489 1
a489 1
	register int unit = DISKUNIT(dev);
d505 1
a505 2
int
ra_getdev(adaptor, controller, unit, uname)
d561 1
a561 1
   		return 0;
d655 1
a655 1
	register struct rx_softc *rx;
d698 1
a698 1
	register struct buf *bp;
d700 2
a701 2
	register int unit;
	register struct rx_softc *rx;
d707 1
a707 1
	if (unit >= rx_cd.cd_ndevs || (rx = rx_cd.cd_devs[unit]) == NULL) {
d769 3
a771 3
	register int unit = DISKUNIT(dev);
	register struct disklabel *lp;
	register struct rx_softc *rx = rx_cd.cd_devs[unit];
d954 2
a955 2
	register struct device *usc;
	register struct mscp *mp;
d989 2
a990 2
	register struct device *usc;
	register struct mscp *mp;
@


1.7
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.6 1998/10/03 21:18:59 millert Exp $	*/
d320 1
a320 1
	if (unit > ra_cd.cd_ndevs || (ra = ra_cd.cd_devs[unit]) == NULL) {
d688 1
a688 1
	if (unit > rx_cd.cd_ndevs || (rx = rx_cd.cd_devs[unit]) == NULL) {
@


1.6
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_disk.c,v 1.5 1997/09/12 09:25:51 maja Exp $	*/
/*	$NetBSD: mscp_disk.c,v 1.13 1997/06/24 01:12:40 thorpej Exp $	*/
d44 1
a49 1
 *	split the file into a separate floppy file
d60 1
a62 1
#include <sys/reboot.h>
d64 4
d71 13
a83 1
#include <ufs/ffs/fs.h> /* For some disklabel stuff */
d85 1
a85 2
#include <vax/mscp/mscp.h>
#include <vax/mscp/mscpvar.h>
a97 1
	int	ra_isafloppy;	/* unit is a floppy disk */
d100 9
a108 1
int	ramatch __P((struct device *, void *, void *));
a109 8
void	radgram __P((struct device *, struct mscp *, struct mscp_softc *));
void	raiodone __P((struct device *, struct buf *));
int	raonline __P((struct device *, struct mscp *));
int	ragotstatus __P((struct device *, struct mscp *));
void	rareplace __P((struct device *, struct mscp *));
int	raioerror __P((struct device *, struct mscp *, struct buf *));
void	rafillin __P((struct buf *, struct mscp *));
void	rabb __P((struct device *, struct mscp *, struct buf *));
a112 1
void	rastrat1 __P((struct buf *));
a119 25

struct	mscp_device ra_device = {
	radgram,
	raiodone,
	raonline,
	ragotstatus,
	rareplace,
	raioerror,
	rabb,
	rafillin,
};

/*
 * Device to unit number and partition and back
 */
#define	UNITSHIFT	3
#define	UNITMASK	7
#define	raunit(dev)	(minor(dev) >> UNITSHIFT)
#define	rapart(dev)	(minor(dev) & UNITMASK)
#define	raminor(u, p)	(((u) << UNITSHIFT) | (p))

struct	cfdriver ra_cd = {
	NULL, "ra", DV_DISK
};

d121 1
a121 1
	sizeof(struct ra_softc), ramatch, raattach
a124 7
 * Software state, per drive
 */
#define	RA_OFFLINE	0
#define	RA_WANTOPEN	1
#define	RA_ONLINE	3

/*
a126 1
extern int cold;
d129 1
a129 1
ramatch(parent, match, aux)
d131 2
a132 1
	void	*match, *aux;
a133 1
	struct	cfdata *cf = match;
d140 6
a160 2
	struct	drive_attach_args *da = aux;
	struct	mscp *mp = da->da_mp;
a161 7
	struct	disklabel *dl;

	ra->ra_mediaid = mp->mscp_guse.guse_mediaid;
	ra->ra_state = RA_OFFLINE;
	ra->ra_havelabel = 0;
	ra->ra_hwunit = mp->mscp_unit;
	mi->mi_dp[mp->mscp_unit] = self;
d163 1
a163 11
	ra->ra_disk.dk_name = ra->ra_dev.dv_xname;
	disk_attach((struct disk *)&ra->ra_disk);

	/* Fill in what we know. The actual size is gotten later */
	dl = ra->ra_disk.dk_label;

	dl->d_secsize = DEV_BSIZE;
	dl->d_nsectors = mp->mscp_guse.guse_nspt;
	dl->d_ntracks = mp->mscp_guse.guse_ngpc;
	dl->d_secpercyl = dl->d_nsectors * dl->d_ntracks;
	disk_printtype(mp->mscp_unit, mp->mscp_guse.guse_mediaid);
a180 2
	struct	mscp *mp;
	struct	mscp_softc *mi = (struct mscp_softc *)ra->ra_dev.dv_parent;
a181 1
	volatile int i;
d184 1
a184 13
	dl = ra->ra_disk.dk_label;

	ra->ra_state = RA_WANTOPEN;
	mp = mscp_getcp(mi, MSCP_WAIT);
	mp->mscp_opcode = M_OP_ONLINE;
	mp->mscp_unit = ra->ra_hwunit;
	mp->mscp_cmdref = (long)&ra->ra_state;
	*mp->mscp_addr |= MSCP_OWN | MSCP_INT;

	/* Poll away */
	i = *mi->mi_ip;
	if (tsleep(&ra->ra_state, PRIBIO, "raonline", 100*100)) {
		ra->ra_state = RA_OFFLINE;
a185 1
	}
d187 1
a187 4
	if (ra->ra_state == RA_OFFLINE)
		return MSCP_FAILED;
	if (ra->ra_isafloppy)
		return MSCP_DONE;
d189 1
d191 2
a192 2
	if ((msg = readdisklabel(raminor(ra->ra_dev.dv_unit, 0),
	    rastrategy, dl, NULL, 0)) != NULL)
d194 1
a194 1
	else
d196 2
a197 1
	ra->ra_state = RA_ONLINE;
d203 1
a215 1

d219 1
a219 1
	unit = raunit(dev);
d230 1
a230 1
	if (ra->ra_state == RA_OFFLINE)
d232 1
a232 1
			return EIO;
d238 3
a240 4
	part = rapart(dev);
	if (ra->ra_isafloppy == 0)
	        if (part >= ra->ra_disk.dk_label->d_npartitions)
			return ENXIO;
d246 1
a246 1
	while (ra->ra_state != RA_ONLINE)
d275 1
a275 1
	register int unit = raunit(dev);
d277 1
a277 1
	int mask = (1 << rapart(dev));
d296 1
a296 1
		s = splbio();
a308 4
 *
 * This routine is broken into two so that the internal version
 * udastrat1() can be called by the (nonexistent, as yet) bad block
 * revectoring routine.
a315 1
	int p;
d319 1
a319 1
	unit = raunit(bp->b_dev);
d328 1
a328 1
	if (ra->ra_state < RA_ONLINE) {
d332 8
a339 1
	p = rapart(bp->b_dev);
d345 3
a347 9
	if (ra->ra_isafloppy) {
		if (bp->b_blkno >= ra->ra_disk.dk_label->d_secperunit) {
			bp->b_resid = bp->b_bcount;
			goto done;
		}
	} else
		if (bounds_check_with_label(bp, ra->ra_disk.dk_label,
		    ra->ra_disk.dk_cpulabel, ra->ra_wlabel) <= 0)
			goto done;
d361 2
a362 2
        dev_t dev;
        struct uio *uio;
d365 1
a365 1
        return (physio(rastrategy, NULL, dev, B_READ, minphys, uio));
d370 2
a371 204
        dev_t dev;
        struct uio *uio;
{

        return (physio(rastrategy, NULL, dev, B_WRITE, minphys, uio));
}

void
raiodone(usc, bp)
	struct device *usc;
	struct buf *bp;
{

	biodone(bp);
}

/*
 * Fill in disk addresses in a mscp packet waiting for transfer.
 */
void
rafillin(bp, mp)
	struct buf *bp;
	struct mscp *mp;
{
	int unit = raunit(bp->b_dev);
	int part = rapart(bp->b_dev);
	struct ra_softc *ra = ra_cd.cd_devs[unit];
	struct disklabel *lp = ra->ra_disk.dk_label;

	
	/* XXX more checks needed */
	mp->mscp_unit = ra->ra_hwunit;
	mp->mscp_seq.seq_lbn = bp->b_blkno + lp->d_partitions[part].p_offset;
	mp->mscp_seq.seq_bytecount = bp->b_bcount;
}

/*
 * Handle an error datagram.
 * This can come from an unconfigured drive as well.
 */
void
radgram(usc, mp, mi)
	struct device *usc;
	struct mscp *mp;
	struct mscp_softc *mi;
{
	if (mscp_decodeerror(usc == NULL?"unconf ra" : usc->dv_xname, mp, mi))
		return;
	/*
	 * SDI status information bytes 10 and 11 are the microprocessor
	 * error code and front panel code respectively.  These vary per
	 * drive type and are printed purely for field service information.
	 */
	if (mp->mscp_format == M_FM_SDI)
		printf("\tsdi uproc error code 0x%x, front panel code 0x%x\n",
			mp->mscp_erd.erd_sdistat[10],
			mp->mscp_erd.erd_sdistat[11]);
}

/*
 * A drive came on line.  Check its type and size.  Return DONE if
 * we think the drive is truly on line.  In any case, awaken anyone
 * sleeping on the drive on-line-ness.
 */
int
raonline(usc, mp)
	struct device *usc;
	struct mscp *mp;
{
	register struct ra_softc *ra = (void *)usc;
	struct disklabel *dl;
	int p = 0, d, n;

	wakeup((caddr_t)&ra->ra_state);
	if ((mp->mscp_status & M_ST_MASK) != M_ST_SUCCESS) {
		printf("%s: attempt to bring on line failed: ", 
		    ra->ra_dev.dv_xname);
		mscp_printevent(mp);
		ra->ra_state = RA_OFFLINE;
		return (MSCP_FAILED);
	}

	/*
	 * Fill in the rest of disk size.
	 */
	ra->ra_state = RA_WANTOPEN;
	dl = ra->ra_disk.dk_label;
	dl->d_secperunit = (daddr_t)mp->mscp_onle.onle_unitsize;

	if (dl->d_secpercyl != 0)
		dl->d_ncylinders = dl->d_secperunit/dl->d_secpercyl;
	else
		ra->ra_isafloppy = 1;
	dl->d_type = DTYPE_MSCP;
	dl->d_rpm = 3600;
	dl->d_bbsize = BBSIZE;
	dl->d_sbsize = SBSIZE;

	/* Create the disk name for disklabel. Phew... */
	d = ra->ra_mediaid;
	dl->d_typename[p++] = MSCP_MID_CHAR(2, d);
	dl->d_typename[p++] = MSCP_MID_CHAR(1, d);
	if (MSCP_MID_ECH(0, d))
		dl->d_typename[p++] = MSCP_MID_CHAR(0, d);
	n = MSCP_MID_NUM(d);
	if (n > 99) {
		dl->d_typename[p++] = '1';
		n -= 100;
	}
	if (n > 9) {
		dl->d_typename[p++] = (n / 10) + '0';
		n %= 10;
	}
	dl->d_typename[p++] = n + '0';
	dl->d_typename[p] = 0;
	dl->d_npartitions = MAXPARTITIONS;
	dl->d_partitions[0].p_size = dl->d_partitions[2].p_size =
	    dl->d_secperunit;
	dl->d_partitions[0].p_offset = dl->d_partitions[2].p_offset = 0;
	dl->d_interleave = dl->d_headswitch = 1;
	dl->d_magic = dl->d_magic2 = DISKMAGIC;
	dl->d_checksum = dkcksum(dl);

	return (MSCP_DONE);
}

/*
 * We got some (configured) unit's status.  Return DONE if it succeeded.
 */
int
ragotstatus(usc, mp)
	register struct device *usc;
	register struct mscp *mp;
{
	if ((mp->mscp_status & M_ST_MASK) != M_ST_SUCCESS) {
		printf("%s: attempt to get status failed: ", usc->dv_xname);
		mscp_printevent(mp);
		return (MSCP_FAILED);
	}
	/* record for (future) bad block forwarding and whatever else */
#ifdef notyet
	uda_rasave(ui->ui_unit, mp, 1);
#endif
	return (MSCP_DONE);
}

/*
 * A transfer failed.  We get a chance to fix or restart it.
 * Need to write the bad block forwaring code first....
 */
/*ARGSUSED*/
int
raioerror(usc, mp, bp)
	register struct device *usc;
	register struct mscp *mp;
	struct buf *bp;
{
printf("raioerror\n");
#if 0
	if (mp->mscp_flags & M_EF_BBLKR) {
		/*
		 * A bad block report.  Eventually we will
		 * restart this transfer, but for now, just
		 * log it and give up.
		 */
		log(LOG_ERR, "ra%d: bad block report: %d%s\n",
			ui->ui_unit, (int)mp->mscp_seq.seq_lbn,
			mp->mscp_flags & M_EF_BBLKU ? " + others" : "");
	} else {
		/*
		 * What the heck IS a `serious exception' anyway?
		 * IT SURE WOULD BE NICE IF DEC SOLD DOCUMENTATION
		 * FOR THEIR OWN CONTROLLERS.
		 */
		if (mp->mscp_flags & M_EF_SEREX)
			log(LOG_ERR, "ra%d: serious exception reported\n",
				ui->ui_unit);
	}
#endif
	return (MSCP_FAILED);
}

/*
 * A replace operation finished.
 */
/*ARGSUSED*/
void
rareplace(usc, mp)
	struct device *usc;
	struct mscp *mp;
{

	panic("udareplace");
}

/*
 * A bad block related operation finished.
 */
/*ARGSUSED*/
void
rabb(usc, mp, bp)
	struct device *usc;
	struct mscp *mp;
	struct buf *bp;
d374 1
a374 1
	panic("udabb");
a376 1

d388 2
a389 2
	register int unit = raunit(dev);
	register struct disklabel *lp;
d404 1
a404 1
		    &lp->d_partitions[rapart(dev)];
d428 16
a450 13
#if 0
/*
 * Do a panic dump.  We set up the controller for one command packet
 * and one response packet, for which we use `struct uda1'.
 */
struct	uda1 {
	struct	uda1ca uda1_ca;	/* communications area */
	struct	mscp uda1_rsp;	/* response packet */
	struct	mscp uda1_cmd;	/* command packet */
} uda1;
#endif

#define	DBSIZE	32		/* dump 16K at a time */
d455 2
a456 2
	daddr_t	blkno;
	caddr_t	va;
d459 1
a459 226
#if 0
	struct udadevice *udaddr;
	struct uda1 *ud_ubaddr;
	char *start;
	int num, blk, unit, maxsz, blkoff, reg;
	struct partition *pp;
	struct uba_regs *uba;
	struct uba_device *ui;
	struct uda1 *ud;
	struct pte *io;
	int i;

	/*
	 * Make sure the device is a reasonable place on which to dump.
	 */
	unit = udaunit(dev);
	if (unit >= NRA)
		return (ENXIO);
#define	phys(cast, addr)	((cast) ((int)addr & 0x7fffffff))
	ui = phys(struct uba_device *, udadinfo[unit]);
	if (ui == NULL || ui->ui_alive == 0)
		return (ENXIO);

	/*
	 * Find and initialise the UBA; get the physical address of the
	 * device registers, and of communications area and command and
	 * response packet.
	 */
	uba = phys(struct uba_softc *, ui->ui_hd)->uh_physuba;
	ubainit(ui->ui_hd);
	udaddr = (struct udadevice *)ui->ui_physaddr;
	ud = phys(struct uda1 *, &uda1);
	/*
	 * Map the ca+packets into Unibus I/O space so the UDA50 can get
	 * at them.  Use the registers at the end of the Unibus map (since
	 * we will use the registers at the beginning to map the memory
	 * we are dumping).
	 */
	num = btoc(sizeof(struct uda1)) + 1;
	reg = NUBMREG - num;
	io = (void *)&uba->uba_map[reg];
	for (i = 0; i < num; i++)
		*(int *)io++ = UBAMR_MRV | (btop(ud) + i);
	ud_ubaddr = (struct uda1 *)(((int)ud & PGOFSET) | (reg << 9));

	/*
	 * Initialise the controller, with one command and one response
	 * packet.
	 */
	udaddr->udaip = 0;
	if (udadumpwait(udaddr, UDA_STEP1))
		return (EFAULT);
	udaddr->udasa = UDA_ERR;
	if (udadumpwait(udaddr, UDA_STEP2))
		return (EFAULT);
	udaddr->udasa = (int)&ud_ubaddr->uda1_ca.ca_rspdsc;
	if (udadumpwait(udaddr, UDA_STEP3))
		return (EFAULT);
	udaddr->udasa = ((int)&ud_ubaddr->uda1_ca.ca_rspdsc) >> 16;
	if (udadumpwait(udaddr, UDA_STEP4))
		return (EFAULT);
	((struct uda_softc *)uda_cd.cd_devs[ui->ui_ctlr])->sc_micro = udaddr->udasa & 0xff;
	udaddr->udasa = UDA_GO;

	/*
	 * Set up the command and response descriptor, then set the
	 * controller characteristics and bring the drive on line.
	 * Note that all uninitialised locations in uda1_cmd are zero.
	 */
	ud->uda1_ca.ca_rspdsc = (long)&ud_ubaddr->uda1_rsp.mscp_cmdref;
	ud->uda1_ca.ca_cmddsc = (long)&ud_ubaddr->uda1_cmd.mscp_cmdref;
	/* ud->uda1_cmd.mscp_sccc.sccc_ctlrflags = 0; */
	/* ud->uda1_cmd.mscp_sccc.sccc_version = 0; */
	if (udadumpcmd(M_OP_SETCTLRC, ud, ui))
		return (EFAULT);
	ud->uda1_cmd.mscp_unit = ui->ui_slave;
	if (udadumpcmd(M_OP_ONLINE, ud, ui))
		return (EFAULT);

	pp = phys(struct partition *,
	    &udalabel[unit].d_partitions[udapart(dev)]);
	maxsz = pp->p_size;
	blkoff = pp->p_offset;

	/*
	 * Dump all of physical memory, or as much as will fit in the
	 * space provided.
	 */
	start = 0;
	printf("Dumpar {r inte implementerade {n :) \n");
	asm("halt");
/*	num = maxfree; */
	if (dumplo + num >= maxsz)
		num = maxsz - dumplo;
	blkoff += dumplo;

	/*
	 * Write out memory, DBSIZE pages at a time.
	 * N.B.: this code depends on the fact that the sector
	 * size == the page size.
	 */
	while (num > 0) {
		blk = num > DBSIZE ? DBSIZE : num;
		io = (void *)uba->uba_map;
		/*
		 * Map in the pages to write, leaving an invalid entry
		 * at the end to guard against wild Unibus transfers.
		 * Then do the write.
		 */
		for (i = 0; i < blk; i++)
			*(int *)io++ = UBAMR_MRV | (btop(start) + i);
		*(int *)io = 0;
		ud->uda1_cmd.mscp_unit = ui->ui_slave;
		ud->uda1_cmd.mscp_seq.seq_lbn = btop(start) + blkoff;
		ud->uda1_cmd.mscp_seq.seq_bytecount = blk << PGSHIFT;
		if (udadumpcmd(M_OP_WRITE, ud, ui))
			return (EIO);
		start += blk << PGSHIFT;
		num -= blk;
	}
	return (0);		/* made it! */
}

/*
 * Wait for some of the bits in `bits' to come on.  If the error bit
 * comes on, or ten seconds pass without response, return true (error).
 */
int
udadumpwait(udaddr, bits)
	struct udadevice *udaddr;
	register int bits;
{
	register int timo = todr() + 1000;

	while ((udaddr->udasa & bits) == 0) {
		if (udaddr->udasa & UDA_ERR) {
			char bits[64];
			printf("udasa=%s\ndump ",
			    bitmask_snprintf(udaddr->udasa, udasr_bits,
			    bits, sizeof(bits)));
			return (1);
		}
		if (todr() >= timo) {
			printf("timeout\ndump ");
			return (1);
		}
	}
	return (0);
}

/*
 * Feed a command to the UDA50, wait for its response, and return
 * true iff something went wrong.
 */
int
udadumpcmd(op, ud, ui)
	int op;
	struct uda1 *ud;
	struct uba_device *ui;
{
	volatile struct udadevice *udaddr;
	volatile int n;
#define mp (&ud->uda1_rsp)

	udaddr = (struct udadevice *)ui->ui_physaddr;
	ud->uda1_cmd.mscp_opcode = op;
	ud->uda1_cmd.mscp_msglen = MSCP_MSGLEN;
	ud->uda1_rsp.mscp_msglen = MSCP_MSGLEN;
	ud->uda1_ca.ca_rspdsc |= MSCP_OWN | MSCP_INT;
	ud->uda1_ca.ca_cmddsc |= MSCP_OWN | MSCP_INT;
	if (udaddr->udasa & UDA_ERR) {
		char bits[64];
		printf("udasa=%s\ndump ", bitmask_snprintf(udaddr->udasa,
		    udasr_bits, bits, sizeof(bits)));
		return (1);
	}
	n = udaddr->udaip;
	n = todr() + 1000;
	for (;;) {
		if (todr() > n) {
			printf("timeout\ndump ");
			return (1);
		}
		if (ud->uda1_ca.ca_cmdint)
			ud->uda1_ca.ca_cmdint = 0;
		if (ud->uda1_ca.ca_rspint == 0)
			continue;
		ud->uda1_ca.ca_rspint = 0;
		if (mp->mscp_opcode == (op | M_OP_END))
			break;
		printf("\n");
		switch (MSCP_MSGTYPE(mp->mscp_msgtc)) {

		case MSCPT_SEQ:
			printf("sequential");
			break;

		case MSCPT_DATAGRAM:
			mscp_decodeerror("uda", ui->ui_ctlr, mp);
			printf("datagram");
			break;

		case MSCPT_CREDITS:
			printf("credits");
			break;

		case MSCPT_MAINTENANCE:
			printf("maintenance");
			break;

		default:
			printf("unknown (type 0x%x)",
				MSCP_MSGTYPE(mp->mscp_msgtc));
			break;
		}
		printf(" ignored\ndump ");
		ud->uda1_ca.ca_rspdsc |= MSCP_OWN | MSCP_INT;
	}
	if ((mp->mscp_status & M_ST_MASK) != M_ST_SUCCESS) {
		printf("error: op 0x%x => 0x%x status 0x%x\ndump ", op,
			mp->mscp_opcode, mp->mscp_status);
		return (1);
	}
#endif
	return (0);
#undef mp
d469 1
a469 1
	register int unit = raunit(dev);
d477 1
a477 1
	if (ra->ra_state == RA_OFFLINE)
d479 1
a479 1
                        return -1;
d481 2
a482 1
	return ra->ra_disk.dk_label->d_partitions[rapart(dev)].p_size;
d487 48
a534 2
	int adaptor, controller, unit;
	char **uname;
d536 2
a537 3
	struct mscp_softc *mi;
	struct ra_softc *ra;
	int i;
d539 161
a699 9
	for (i = 0; i < ra_cd.cd_ndevs; i++) {
		if ((ra = ra_cd.cd_devs[i]) == 0)
			continue;

		mi = (void *)ra->ra_dev.dv_parent;
		if (mi->mi_ctlrnr == controller && mi->mi_adapnr == adaptor &&
		    ra->ra_hwunit == unit) {
			*uname = ra->ra_dev.dv_xname;
			return i;
d701 8
d710 89
d800 240
@


1.6.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_disk.c,v 1.7 2000/04/27 03:14:46 bjc Exp $	*/
/*	$NetBSD: mscp_disk.c,v 1.21 1999/06/06 19:16:18 ragge Exp $	*/
a43 1
 * RX MSCP floppy disk device driver
d49 1
a59 1
#include <sys/reboot.h>
d62 1
a63 4
#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>

#include <machine/bus.h>
d67 1
a67 13
#include <arch/vax/mscp/mscp.h>
#include <arch/vax/mscp/mscpreg.h>
#include <arch/vax/mscp/mscpvar.h>

#include "ra.h"

struct cfdriver ra_cd = {
	NULL, "ra", DV_DISK
};

struct cfdriver rx_cd = {
	NULL, "rx", DV_DISK
};
d69 2
a70 1
#define RAMAJOR 9	/* RA major device number XXX */
d83 1
d86 1
a86 9
#define rx_softc ra_softc

void	rxattach __P((struct device *, struct device *, void *));
int	rx_putonline __P((struct rx_softc *));
void	rrmakelabel __P((struct disklabel *, long));

#if NRA

int	ramatch __P((struct device *, struct cfdata *, void *));
d88 8
d99 1
d107 25
d133 1
a133 1
	sizeof(struct ra_softc), (cfmatch_t)ramatch, raattach
d137 7
d146 1
d149 1
a149 1
ramatch(parent, cf, aux)
d151 1
a151 2
	struct	cfdata *cf;
	void	*aux;
d153 1
a159 6
	   	return 0;
	/*
	 * Check if this disk is a floppy; then don't configure it.
	 * Seems to be a safe way to test it per Chris Torek.
	 */
	if (MSCP_MID_ECH(1, mp->mscp_guse.guse_mediaid) == 'X' - '@@')
d175 2
d178 7
d186 11
a196 1
	rxattach(parent, self, aux);
d214 2
d217 1
d220 13
a232 1
	if (rx_putonline(ra) != MSCP_DONE)
d234 1
d236 4
a239 1
	dl = ra->ra_disk.dk_label;
a240 1
	ra->ra_state = DK_RDLABEL;
d242 2
a243 2
	if ((msg = readdisklabel(MAKEDISKDEV(RAMAJOR, ra->ra_dev.dv_unit,
	    RAW_PART), rastrategy, dl, NULL, 0)) != NULL)
d245 1
a245 1
	else {
d247 1
a247 2
		ra->ra_state = DK_OPEN;
	}
a252 1

d265 1
d269 1
a269 1
	unit = DISKUNIT(dev);
d280 1
a280 1
	if (ra->ra_state == DK_CLOSED)
d282 1
a282 1
			return ENXIO;
d288 4
a291 3
	part = DISKPART(dev);
	if (part >= ra->ra_disk.dk_label->d_npartitions)
		return ENXIO;
d297 1
a297 1
	while (ra->ra_state != DK_OPEN)
d326 1
a326 1
	register int unit = DISKUNIT(dev);
d328 1
a328 1
	int mask = (1 << DISKPART(dev));
d347 1
a347 1
		s = splimp();
d360 4
d371 1
d375 1
a375 1
	unit = DISKUNIT(bp->b_dev);
d384 1
a384 1
	if (ra->ra_state == DK_RDLABEL) {
d388 1
a388 8

	/* If disk is not online, try to put it online */
	if (ra->ra_state == DK_CLOSED)
		if (ra_putonline(ra) == MSCP_FAILED) {
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
			goto done;
		}
d394 9
a402 3
	if (bounds_check_with_label(bp, ra->ra_disk.dk_label,
	    ra->ra_disk.dk_cpulabel, ra->ra_wlabel) <= 0)
		goto done;
d416 2
a417 2
	dev_t dev;
	struct uio *uio;
d420 1
a420 1
	return (physio(rastrategy, NULL, dev, B_READ, minphys, uio));
d425 204
a628 2
	dev_t dev;
	struct uio *uio;
d631 1
a631 1
	return (physio(rastrategy, NULL, dev, B_WRITE, minphys, uio));
d634 1
d646 2
a647 2
	register int unit = DISKUNIT(dev);
	register struct disklabel *lp, *tp;
d662 1
a662 1
		    &lp->d_partitions[DISKPART(dev)];
a685 16
#ifdef __NetBSD__
	case DIOCGDEFLABEL:
		tp = (struct disklabel *)data;
		bzero(data, sizeof(struct disklabel));
		tp->d_secsize = lp->d_secsize;
		tp->d_nsectors = lp->d_nsectors;
		tp->d_ntracks = lp->d_ntracks;
		tp->d_ncylinders = lp->d_ncylinders;
		tp->d_secpercyl = lp->d_secpercyl;
		tp->d_secperunit = lp->d_secperunit;
		tp->d_type = DTYPE_MSCP;
		tp->d_rpm = 3600;
		rrmakelabel(tp, ra->ra_mediaid);
		break;
#endif

d693 13
d710 2
a711 2
	daddr_t blkno;
	caddr_t va;
d714 226
a939 1
	return ENXIO;
d949 1
a949 1
	register int unit = DISKUNIT(dev);
d957 1
a957 1
	if (ra->ra_state == DK_CLOSED)
d959 1
a959 1
			return -1;
d961 1
a961 2
	return ra->ra_disk.dk_label->d_partitions[DISKPART(dev)].p_size *
	    (ra->ra_disk.dk_label->d_secsize / DEV_BSIZE);
d966 2
a967 2
    int adaptor, controller, unit;
    char **uname;
d969 3
a971 31
    struct mscp_softc *mi;
    struct ra_softc *ra;
    int i;

    for (i = 0; i < ra_cd.cd_ndevs; i++) {
        if ((ra = ra_cd.cd_devs[i]) == 0)
            continue;

        mi = (void *)ra->ra_dev.dv_parent;
        if (mi->mi_ctlrnr == controller && mi->mi_adapnr == adaptor &&
            ra->ra_hwunit == unit) {
            *uname = ra->ra_dev.dv_xname;
            return i;
        }
    }
    return -1;
}

#endif /* NRA */

#if NRX

int	rxmatch __P((struct device *, struct cfdata *, void *));
int	rxopen __P((dev_t, int, int, struct proc *));
int	rxclose __P((dev_t, int, int, struct proc *));
void	rxstrategy __P((struct buf *));
int	rxread __P((dev_t, struct uio *));
int	rxwrite __P((dev_t, struct uio *));
int	rxioctl __P((dev_t, int, caddr_t, int, struct proc *));
int	rxdump __P((dev_t, daddr_t, caddr_t, size_t));
int	rxsize __P((dev_t));
d973 12
a984 518
struct	cfattach rx_ca = {
	sizeof(struct rx_softc), (cfmatch_t)rxmatch, rxattach
};

/*
 * More driver definitions, for generic MSCP code.
 */

int
rxmatch(parent, cf, aux)
	struct	device *parent;
	struct	cfdata *cf;
	void	*aux;
{
	struct	drive_attach_args *da = aux;
	struct	mscp *mp = da->da_mp;

	if ((da->da_typ & MSCPBUS_DISK) == 0)
		return 0;
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != mp->mscp_unit)
   		return 0;
	/*
	 * Check if this disk is a floppy; then configure it.
	 * Seems to be a safe way to test it per Chris Torek.
	 */
	if (MSCP_MID_ECH(1, mp->mscp_guse.guse_mediaid) == 'X' - '@@')
		return 1;
	return 0;
}

#endif /* NRX */

/*
 * The attach routine only checks and prints drive type.
 * Bringing the disk online is done when the disk is accessed
 * the first time. 
 */
void
rxattach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux; 
{
	struct	rx_softc *rx = (void *)self;
	struct	drive_attach_args *da = aux;
	struct	mscp *mp = da->da_mp;
	struct	mscp_softc *mi = (void *)parent;
	struct	disklabel *dl;

	rx->ra_mediaid = mp->mscp_guse.guse_mediaid;
	rx->ra_state = DK_CLOSED;
	rx->ra_hwunit = mp->mscp_unit;
	mi->mi_dp[mp->mscp_unit] = self;

	rx->ra_disk.dk_name = rx->ra_dev.dv_xname;
	disk_attach((struct disk *)&rx->ra_disk);

	/* Fill in what we know. The actual size is gotten later */
	dl = rx->ra_disk.dk_label;

	dl->d_secsize = DEV_BSIZE;
	dl->d_nsectors = mp->mscp_guse.guse_nspt;
	dl->d_ntracks = mp->mscp_guse.guse_ngpc * mp->mscp_guse.guse_group;
	dl->d_secpercyl = dl->d_nsectors * dl->d_ntracks;
	disk_printtype(mp->mscp_unit, mp->mscp_guse.guse_mediaid);
#ifdef DEBUG
	printf("%s: nspt %d group %d ngpc %d rct %d nrpt %d nrct %d\n",
	    self->dv_xname, mp->mscp_guse.guse_nspt, mp->mscp_guse.guse_group,
	    mp->mscp_guse.guse_ngpc, mp->mscp_guse.guse_rctsize,
	    mp->mscp_guse.guse_nrpt, mp->mscp_guse.guse_nrct);
#endif
}

/* 
 * (Try to) put the drive online. This is done the first time the
 * drive is opened, or if it har fallen offline.
 */
int
rx_putonline(rx)
	struct rx_softc *rx;
{
	struct	mscp *mp;
	struct	mscp_softc *mi = (struct mscp_softc *)rx->ra_dev.dv_parent;
	volatile int i;

	rx->ra_state = DK_CLOSED;
	mp = mscp_getcp(mi, MSCP_WAIT);
	mp->mscp_opcode = M_OP_ONLINE;
	mp->mscp_unit = rx->ra_hwunit;
	mp->mscp_cmdref = 1;
	*mp->mscp_addr |= MSCP_OWN | MSCP_INT;

	/* Poll away */
	i = bus_space_read_2(mi->mi_iot, mi->mi_iph, 0);
	if (tsleep(&rx->ra_dev.dv_unit, PRIBIO, "rxonline", 100*100))
		rx->ra_state = DK_CLOSED;

	if (rx->ra_state == DK_CLOSED)
		return MSCP_FAILED;

	return MSCP_DONE;
}

#if NRX

/*
 * Open a drive.
 */
/*ARGSUSED*/
int
rxopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct	proc *p;
{
	register struct rx_softc *rx;
	int unit;

	/*
	 * Make sure this is a reasonable open request.
	 */
	unit = DISKUNIT(dev);
	if (unit >= rx_cd.cd_ndevs)
		return ENXIO;
	rx = rx_cd.cd_devs[unit];
	if (rx == 0)
		return ENXIO;

	/*
	 * If this is the first open; we must first try to put
	 * the disk online (and read the label).
	 */
	if (rx->ra_state == DK_CLOSED)
		if (rx_putonline(rx) == MSCP_FAILED)
			return ENXIO;

	return 0;
}

/* ARGSUSED */
int
rxclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct	proc *p;
{
	return (0);
}

/*
 * Queue a transfer request, and if possible, hand it to the controller.
 *
 * This routine is broken into two so that the internal version
 * udastrat1() can be called by the (nonexistent, as yet) bad block
 * revectoring routine.
 */
void
rxstrategy(bp)
	register struct buf *bp;
{
	register int unit;
	register struct rx_softc *rx;

	/*
	 * Make sure this is a reasonable drive to use.
	 */
	unit = DISKUNIT(bp->b_dev);
	if (unit > rx_cd.cd_ndevs || (rx = rx_cd.cd_devs[unit]) == NULL) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		goto done;
	}

	/* If disk is not online, try to put it online */
	if (rx->ra_state == DK_CLOSED)
		if (rx_putonline(rx) == MSCP_FAILED) {
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
			goto done;
		}

	/*
	 * Determine the size of the transfer, and make sure it is
	 * within the boundaries of the partition.
	 */
	if (bp->b_blkno >= rx->ra_disk.dk_label->d_secperunit) {
		bp->b_resid = bp->b_bcount;
		goto done;
	}

	/* Make some statistics... /bqt */
	rx->ra_disk.dk_xfer++;
	rx->ra_disk.dk_bytes += bp->b_bcount;
	mscp_strategy(bp, rx->ra_dev.dv_parent);
	return;

done:
	biodone(bp);
}

int
rxread(dev, uio)
	dev_t dev;
	struct uio *uio;
{

	return (physio(rxstrategy, NULL, dev, B_READ, minphys, uio));
}

int
rxwrite(dev, uio)
	dev_t dev;
	struct uio *uio;
{

	return (physio(rxstrategy, NULL, dev, B_WRITE, minphys, uio));
}

/*
 * I/O controls.
 */
int
rxioctl(dev, cmd, data, flag, p)
	dev_t dev;
	int cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	register int unit = DISKUNIT(dev);
	register struct disklabel *lp;
	register struct rx_softc *rx = rx_cd.cd_devs[unit];
	int error = 0;

	lp = rx->ra_disk.dk_label;

	switch (cmd) {

	case DIOCGDINFO:
		bcopy(lp, data, sizeof (struct disklabel));
		break;

	case DIOCGPART:
		((struct partinfo *)data)->disklab = lp;
		((struct partinfo *)data)->part =
		    &lp->d_partitions[DISKPART(dev)];
		break;


	case DIOCWDINFO:
	case DIOCSDINFO:
	case DIOCWLABEL:
		break;

	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

int
rxdump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{

	/* Not likely. */
	return ENXIO;
}

int
rxsize(dev)
	dev_t dev;
{

	return -1;
}

#endif /* NRX */

void	rrdgram __P((struct device *, struct mscp *, struct mscp_softc *));
void	rriodone __P((struct device *, struct buf *));
int	rronline __P((struct device *, struct mscp *));
int	rrgotstatus __P((struct device *, struct mscp *));
void	rrreplace __P((struct device *, struct mscp *));
int	rrioerror __P((struct device *, struct mscp *, struct buf *));
void	rrfillin __P((struct buf *, struct mscp *));
void	rrbb __P((struct device *, struct mscp *, struct buf *));


struct	mscp_device ra_device = {
	rrdgram,
	rriodone,
	rronline,
	rrgotstatus,
	rrreplace,
	rrioerror,
	rrbb,
	rrfillin,
};

/*
 * Handle an error datagram.
 * This can come from an unconfigured drive as well.
 */	
void	    
rrdgram(usc, mp, mi)
	struct device *usc;
	struct mscp *mp; 
	struct mscp_softc *mi;
{	 
	if (mscp_decodeerror(usc == NULL?"unconf disk" : usc->dv_xname, mp, mi))
		return;	 
	/*
	 * SDI status information bytes 10 and 11 are the microprocessor
	 * error code and front panel code respectively.  These vary per
	 * drive type and are printed purely for field service information.
	 */
	if (mp->mscp_format == M_FM_SDI) 
		printf("\tsdi uproc error code 0x%x, front panel code 0x%x\n",
			mp->mscp_erd.erd_sdistat[10],
			mp->mscp_erd.erd_sdistat[11]);
}

void	
rriodone(usc, bp)
	struct device *usc;
	struct buf *bp;
{

	biodone(bp);
}

/*
 * A drive came on line.  Check its type and size.  Return DONE if
 * we think the drive is truly on line.	 In any case, awaken anyone
 * sleeping on the drive on-line-ness.
 */
int
rronline(usc, mp)
	struct device *usc;
	struct mscp *mp;
{
	struct rx_softc *rx = (struct rx_softc *)usc;
	struct disklabel *dl;

	wakeup((caddr_t)&usc->dv_unit);
	if ((mp->mscp_status & M_ST_MASK) != M_ST_SUCCESS) {
		printf("%s: attempt to bring on line failed: ", usc->dv_xname);
		mscp_printevent(mp);
		return (MSCP_FAILED);
	}

	rx->ra_state = DK_OPEN;
 
	dl = rx->ra_disk.dk_label;
	dl->d_secperunit = (daddr_t)mp->mscp_onle.onle_unitsize;

	if (dl->d_secpercyl) {
		dl->d_ncylinders = dl->d_secperunit/dl->d_secpercyl;
		dl->d_type = DTYPE_MSCP;
		dl->d_rpm = 3600;
	} else {
		dl->d_type = DTYPE_FLOPPY;
		dl->d_rpm = 300;
	}
	rrmakelabel(dl, rx->ra_mediaid);

	return (MSCP_DONE);
}

void
rrmakelabel(dl, type)
	struct disklabel *dl;
	long type;
{
	int n, p = 0;

	dl->d_bbsize = BBSIZE;
	dl->d_sbsize = SBSIZE;

	/* Create the disk name for disklabel. Phew... */
	dl->d_typename[p++] = MSCP_MID_CHAR(2, type);
	dl->d_typename[p++] = MSCP_MID_CHAR(1, type);
	if (MSCP_MID_ECH(0, type))
		dl->d_typename[p++] = MSCP_MID_CHAR(0, type);
	n = MSCP_MID_NUM(type);
	if (n > 99) {
		dl->d_typename[p++] = '1';
		n -= 100;
	}
	if (n > 9) {
		dl->d_typename[p++] = (n / 10) + '0';
		n %= 10;
	}
	dl->d_typename[p++] = n + '0';
	dl->d_typename[p] = 0;
	dl->d_npartitions = MAXPARTITIONS;
	dl->d_partitions[0].p_size = dl->d_partitions[2].p_size =
	    dl->d_secperunit;
	dl->d_partitions[0].p_offset = dl->d_partitions[2].p_offset = 0;
	dl->d_interleave = dl->d_headswitch = 1;
	dl->d_magic = dl->d_magic2 = DISKMAGIC;
	dl->d_checksum = dkcksum(dl);
}

/*	
 * We got some (configured) unit's status.  Return DONE if it succeeded.
 */
int
rrgotstatus(usc, mp)
	register struct device *usc;
	register struct mscp *mp;
{	
	if ((mp->mscp_status & M_ST_MASK) != M_ST_SUCCESS) {
		printf("%s: attempt to get status failed: ", usc->dv_xname);
		mscp_printevent(mp);
		return (MSCP_FAILED);
	}
	/* record for (future) bad block forwarding and whatever else */
#ifdef notyet
	uda_rasave(ui->ui_unit, mp, 1);
#endif
	return (MSCP_DONE);
}

/*	
 * A replace operation finished.
 */
/*ARGSUSED*/
void	
rrreplace(usc, mp)
	struct device *usc;
	struct mscp *mp;
{

	panic("udareplace");
}

/*
 * A transfer failed.  We get a chance to fix or restart it.
 * Need to write the bad block forwaring code first....
 */
/*ARGSUSED*/
int 
rrioerror(usc, mp, bp)
	register struct device *usc;
	register struct mscp *mp;
	struct buf *bp;
{
	struct ra_softc *ra = (void *)usc;
	int code = mp->mscp_event;

	switch (code & M_ST_MASK) {
	/* The unit has fallen offline. Try to figure out why. */
	case M_ST_OFFLINE:
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
		ra->ra_state = DK_CLOSED;
		if (code & M_OFFLINE_UNMOUNTED)
			printf("%s: not mounted/spun down\n", usc->dv_xname);
		if (code & M_OFFLINE_DUPLICATE)
			printf("%s: duplicate unit number!!!\n", usc->dv_xname);
		return MSCP_DONE;

	case M_ST_AVAILABLE:
		ra->ra_state = DK_CLOSED; /* Force another online */
		return MSCP_DONE;

	default:
		printf("%s:", usc->dv_xname);
		break;
	}
	return (MSCP_FAILED);
}

/*
 * Fill in disk addresses in a mscp packet waiting for transfer.
 */
void
rrfillin(bp, mp)
	struct buf *bp;
	struct mscp *mp;
{
	struct rx_softc *rx = 0; /* Wall */
	struct disklabel *lp;
	int unit = DISKUNIT(bp->b_dev);
	int part = DISKPART(bp->b_dev);

#if NRA
	if (major(bp->b_dev) == RAMAJOR)
		rx = ra_cd.cd_devs[unit];
#endif
#if NRX
	if (major(bp->b_dev) != RAMAJOR)
		rx = rx_cd.cd_devs[unit];
#endif
	lp = rx->ra_disk.dk_label;

	mp->mscp_seq.seq_lbn = lp->d_partitions[part].p_offset + bp->b_blkno;
	mp->mscp_unit = rx->ra_hwunit;
	mp->mscp_seq.seq_bytecount = bp->b_bcount;
}

/*
 * A bad block related operation finished.
 */
/*ARGSUSED*/
void
rrbb(usc, mp, bp)
	struct device *usc;
	struct mscp *mp;
	struct buf *bp;
{

	panic("udabb");
@


1.6.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.6.8.1 2001/05/14 21:38:13 niklas Exp $	*/
d320 1
a320 1
	if (unit >= ra_cd.cd_ndevs || (ra = ra_cd.cd_devs[unit]) == NULL) {
d688 1
a688 1
	if (unit >= rx_cd.cd_ndevs || (rx = rx_cd.cd_devs[unit]) == NULL) {
@


1.6.8.3
log
@Merge in trunk
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mscp_disk.c,v 1.30 2001/11/13 07:38:28 lukem Exp $	*/
a51 2
#include <sys/cdefs.h>

d69 1
d121 1
a121 1
	sizeof(struct ra_softc), (cfmatch_t)ramatch, rxattach
d140 1
a140 1
		return 0;
d150 23
d214 1
a214 1
	struct ra_softc *ra;
d275 2
a276 2
	int unit = DISKUNIT(dev);
	struct ra_softc *ra = ra_cd.cd_devs[unit];
d296 3
a298 4
		s = spluba();
		while (BUFQ_FIRST(&udautab[unit]) != NULL)
			(void) tsleep(&udautab[unit], PZERO - 1,
			    "raclose", 0);
d312 1
a312 1
	struct buf *bp;
d314 2
a315 2
	int unit;
	struct ra_softc *ra;
d320 1
a320 1
	if (unit > ra_cd.cd_ndevs || (ra = ra_cd.cd_devs[unit]) == NULL) {
d388 3
a390 3
	int unit = DISKUNIT(dev);
	struct disklabel *lp, *tp;
	struct ra_softc *ra = ra_cd.cd_devs[unit];
a391 3
#ifdef __HAVE_OLD_DISKLABEL
	struct disklabel newlabel;
#endif
a399 8
#ifdef __HAVE_OLD_DISKLABEL
	case ODIOCGDINFO:
		bcopy(lp, &newlabel, sizeof disklabel);
		if (newlabel.d_npartitions > OLDMAXPARTITIONS)
			return ENOTTY;
		bcopy(&newlabel, data, sizeof (struct olddisklabel));
		break;
#endif
a408 11
#ifdef __HAVE_OLD_DISKLABEL
	case ODIOCWDINFO:
	case ODIOCSDINFO:
		if (cmd == ODIOCSDINFO || xfer == ODIOCWDINFO) {
			memset(&newlabel, 0, sizeof newlabel);
			memcpy(&newlabel, data, sizeof (struct olddisklabel));
			tp = &newlabel;
		} else
#endif
		tp = (struct disklabel *)data;

d412 2
a413 7
			error = setdisklabel(lp, tp, 0, 0);
			if ((error == 0) && (cmd == DIOCWDINFO
#ifdef __HAVE_OLD_DISKLABEL
			    || cmd == ODIOCWDINFO
#else
			    )) {
#endif
a429 6
#ifdef __HAVE_OLD_DISKLABEL
	case ODIOCGDEFLABEL:
		if (cmd == ODIOCGDEFLABEL)
			tp = &newlabel;
		else
#else
d431 1
a431 2
#endif
		bzero(tp, sizeof(struct disklabel));
d441 1
a441 6
#ifdef __HAVE_OLD_DISKLABEL
		if (cmd == ODIOCGDEFLABEL) {
			if (tp->d_npartitions > OLDMAXPARTITIONS)
				return ENOTTY;
			memcpy(data, tp, sizeof (struct olddisklabel));
		}
a442 2
		break;
#endif /* __NetBSD__ */
d469 1
a469 1
	int unit = DISKUNIT(dev);
d485 2
a486 1
int ra_getdev(adaptor, controller, unit, uname)
d542 1
a542 1
		return 0;
d636 1
a636 1
	struct rx_softc *rx;
d679 1
a679 1
	struct buf *bp;
d681 2
a682 2
	int unit;
	struct rx_softc *rx;
d688 1
a688 1
	if (unit > rx_cd.cd_ndevs || (rx = rx_cd.cd_devs[unit]) == NULL) {
d750 3
a752 3
	int unit = DISKUNIT(dev);
	struct disklabel *lp;
	struct rx_softc *rx = rx_cd.cd_devs[unit];
d935 2
a936 2
	struct device *usc;
	struct mscp *mp;
d970 2
a971 2
	struct device *usc;
	struct mscp *mp;
@


1.6.8.4
log
@Merge in -current from about a week ago
@
text
@d103 3
a105 3
void	rxattach(struct device *, struct device *, void *);
int	rx_putonline(struct rx_softc *);
void	rrmakelabel(struct disklabel *, long);
d109 11
a119 11
int	ramatch(struct device *, struct cfdata *, void *);
void	raattach(struct device *, struct device *, void *);
int	raopen(dev_t, int, int, struct proc *);
int	raclose(dev_t, int, int, struct proc *);
void	rastrategy(struct buf *);
int	raread(dev_t, struct uio *);
int	rawrite(dev_t, struct uio *);
int	raioctl(dev_t, int, caddr_t, int, struct proc *);
int	radump(dev_t, daddr_t, caddr_t, size_t);
int	rasize(dev_t);
int	ra_putonline(struct ra_softc *);
d531 9
a539 9
int	rxmatch(struct device *, struct cfdata *, void *);
int	rxopen(dev_t, int, int, struct proc *);
int	rxclose(dev_t, int, int, struct proc *);
void	rxstrategy(struct buf *);
int	rxread(dev_t, struct uio *);
int	rxwrite(dev_t, struct uio *);
int	rxioctl(dev_t, int, caddr_t, int, struct proc *);
int	rxdump(dev_t, daddr_t, caddr_t, size_t);
int	rxsize(dev_t);
d823 8
a830 8
void	rrdgram(struct device *, struct mscp *, struct mscp_softc *);
void	rriodone(struct device *, struct buf *);
int	rronline(struct device *, struct mscp *);
int	rrgotstatus(struct device *, struct mscp *);
void	rrreplace(struct device *, struct mscp *);
int	rrioerror(struct device *, struct mscp *, struct buf *);
void	rrfillin(struct buf *, struct mscp *);
void	rrbb(struct device *, struct mscp *, struct buf *);
@


1.6.8.5
log
@Sync the SMP branch with 3.3
@
text
@a294 2
	int s;

a334 1
	s = splbio();
a335 1
	splx(s);
d505 22
a701 1
	int s;
a736 1
	s = splbio();
a737 1
	splx(s);
a871 1
	int s;
a872 1
	s = splbio();
a873 1
	splx(s);
@


1.6.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.6.8.5 2003/03/27 23:52:20 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.8.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d327 2
a328 3
	s = splbio();
	disk_busy(&ra->ra_disk);
	splx(s);
d710 2
a711 3
	s = splbio();
	disk_busy(&rx->ra_disk);
	splx(s);
@


1.5
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.4 1997/09/10 11:54:42 maja Exp $	*/
d243 1
a243 1
	    rastrategy, dl, NULL)) != NULL)
@


1.4
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_disk.c,v 1.3 1997/08/08 21:46:56 niklas Exp $	*/
/*	$NetBSD: mscp_disk.c,v 1.10 1997/03/15 16:32:19 ragge Exp $	*/
d49 1
d185 2
a239 3
	dl->d_partitions[0].p_size = dl->d_partitions[2].p_size =
	    dl->d_secperunit;
	dl->d_partitions[0].p_offset = dl->d_partitions[2].p_offset = 0;
d284 5
a288 1
	part = raunit(dev);
d345 1
a345 1
#if 0
d378 2
a379 1
		goto bad;
d401 2
a402 4
		    ra->ra_disk.dk_cpulabel, ra->ra_wlabel) <= 0) {
			bp->b_error = ENXIO;
			goto bad;
		}
d404 3
a409 2
bad:
	bp->b_flags |= B_ERROR;
d541 6
d665 1
d669 1
a669 1
		else
d671 6
a683 10
		break;

	case DIOCWDINFO:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			ra->ra_wlabel = 1;
			error = writedisklabel(dev, rastrategy, lp,0);
			ra->ra_wlabel = 0;
		}
@


1.3
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 2
a2 2
/*	$OpenBSD: mscp_disk.c,v 1.2 1997/05/29 00:05:02 niklas Exp $	*/
/*	$NetBSD: mscp_disk.c,v 1.7 1997/01/11 11:20:32 ragge Exp $	*/
d61 4
d128 1
a128 1
	NULL, "ra", DV_DULL
d194 7
@


1.2
log
@RCS tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: mscp_disk.c,v 1.7 1997/01/11 11:20:32 ragge Exp $	*/
d385 1
a385 1
		    ra->ra_wlabel) <= 0) {
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
