head	1.9;
access;
symbols
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.10
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.14
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.12
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.8
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.3.0.10
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.12
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.8;
commitid	OSDG2O3Cgeifnf1W;

1.8
date	2015.07.04.10.27.05;	author dlg;	state Exp;
branches;
next	1.7;
commitid	p2UGwwDorFF21Uzt;

1.7
date	2011.11.01.20.50.11;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.27.03.14.46;	author bjc;	state Exp;
branches
	1.3.10.1;
next	1.2;

1.2
date	97.05.29.00.05.04;	author niklas;	state Exp;
branches
	1.2.12.1;
next	1.1;

1.1
date	97.01.15.23.24.53;	author maja;	state Exp;
branches;
next	;

1.2.12.1
date	2001.05.14.21.38.15;	author niklas;	state Exp;
branches;
next	1.2.12.2;

1.2.12.2
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.2.12.3;

1.2.12.3
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	;

1.3.10.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: mscpvar.h,v 1.8 2015/07/04 10:27:05 dlg Exp $	*/
/*	$NetBSD: mscpvar.h,v 1.7 1999/06/06 19:16:18 ragge Exp $	*/
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * Copyright (c) 1988 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mscpvar.h	7.3 (Berkeley) 6/28/90
 */

/*
 * MSCP generic driver configuration
 */

/*
 * Enabling MSCP_PARANOIA makes the response code perform various checks
 * on the hardware.  (Right now it verifies only the buffer pointer in
 * mscp_cmdref.)
 *
 * Enabling AVOID_EMULEX_BUG selects an alternative method of identifying
 * transfers in progress, which gets around a rather peculiar bug in the
 * SC41/MS.  Enabling MSCP_PARANOIA instead should work, but will cause
 * `extra' Unibus resets.
 *
 * Either of these flags can simply be included as an `options' line in
 * your configuration file.
 */

/* #define MSCP_PARANOIA */
/* #define AVOID_EMULEX_BUG */

/*
 * Ring information, per ring (one each for commands and responses).
 */
struct mscp_ri {
	int	mri_size;		/* ring size */
	int	mri_next;		/* next (expected|free) */
	long	*mri_desc;		/* base address of descriptors */
	struct	mscp *mri_ring;		/* base address of packets */
};

/*
 * Transfer info, one per command packet.
 */
struct mscp_xi {
	bus_dmamap_t	mxi_dmam;	/* Allocated DMA map for this entry */
	struct buf *	mxi_bp;		/* Buffer used in this command */
	struct mscp *	mxi_mp;		/* Packet used in this command */
	int		mxi_inuse;
};

struct	mscp_ctlr {
					/* controller operation complete */
	void	(*mc_ctlrdone)(struct device *);
					/* device-specific start routine */
	void	(*mc_go)(struct device *, struct mscp_xi *);
					/* ctlr error handling */
	void	(*mc_saerror)(struct device *, int);
};

struct mscp_softc;

struct	mscp_device {
				/* error datagram */
	void	(*me_dgram)(struct device *, struct mscp *, struct mscp_softc *);
				/* normal I/O is done */
	void	(*me_iodone)(struct device *, struct buf *);
				/* drive on line */
	int	(*me_online)(struct device *, struct mscp *);
				/* got unit status */
	int	(*me_gotstatus)(struct device *, struct mscp *);
				/* replace done */
	void	(*me_replace)(struct device *, struct mscp *);
				/* read or write failed */
	int	(*me_ioerr)(struct device *, struct mscp *, struct buf *);
				/* B_BAD io done */
	void	(*me_bb)(struct device *, struct mscp *, struct buf *);
				/* Fill in mscp info for this drive */
	void	(*me_fillin)(struct buf *,struct mscp *);
				/* Non-data transfer operation is done */
	void	(*me_cmddone)(struct device *, struct mscp *);
};

/*
 * This struct is used when attaching a mscpbus.
 */
struct	mscp_attach_args {
	struct	mscp_ctlr *ma_mc;	/* Pointer to ctlr's mscp_ctlr */
	int	ma_type;		/* disk/tape bus type */
	struct	mscp_pack *ma_uda;	/* comm area virtual */
	struct	mscp_softc **ma_softc;	/* backpointer to bus softc */
	bus_dmamap_t	   ma_dmam;	/* This comm area dma info */
	bus_dma_tag_t	   ma_dmat;
	bus_space_tag_t	   ma_iot;
	bus_space_handle_t ma_iph;	/* initialisation and polling */
	bus_space_handle_t ma_sah;	/* status & address (read part) */
	bus_space_handle_t ma_swh;	/* status & address (write part) */
	short	ma_ivec;		/* Interrupt vector to use */
	char	ma_ctlrnr;		/* Phys ctlr nr */
	char	ma_adapnr;		/* Phys adapter nr */
};
#define MSCPBUS_DISK	001	/* Bus is used for disk mounts */
#define MSCPBUS_TAPE	002	/* Bus is used for tape mounts */
#define MSCPBUS_UDA	004	/* ctlr is disk on unibus/qbus */
#define MSCPBUS_KDB	010	/* ctlr is disk on BI */
#define MSCPBUS_KLE	020	/* ctlr is tape on unibus/qbus */

/*
 * Used when going for child devices.
 */
struct	drive_attach_args {
	struct	mscp *da_mp;	/* this devices response struct */
	int	da_typ;		/* Parent of type */
};

/*
 * Return values from functions.
 * MSCP_RESTARTED is peculiar to I/O errors.
 */
#define MSCP_DONE	0		/* all ok */
#define MSCP_FAILED	1		/* no go */
#define MSCP_RESTARTED	2		/* transfer restarted */

/*
 * Per device information.
 *
 * mi_ip is a pointer to the inverting pointers (things that get `ui's
 * given unit numbers) FOR THIS CONTROLLER (NOT the whole set!).
 *
 * b_actf holds a queue of those transfers that were started but have
 * not yet finished.  Other Unibus drivers do not need this as they hand
 * out requests one at a time.	MSCP devices, however, take a slew of
 * requests and pick their own order to execute them.  This means that
 * we have to have a place to move transfers that were given to the
 * controller, so we can tell those apart from those that have not yet
 * been handed out; b_actf is that place.
 */
struct mscp_softc {
	struct	device mi_dev;		/* Autoconf stuff */
	struct	mscp_ri mi_cmd;		/* MSCP command ring info */
	struct	mscp_ri mi_rsp;		/* MSCP response ring info */
	bus_dma_tag_t	mi_dmat;
	bus_dmamap_t	mi_dmam;
	struct	mscp_xi mi_xi[NCMD];
	int	mi_mxiuse;		/* Bitfield of inuse mxi packets */
	short	mi_credits;		/* transfer credits */
	char	mi_wantcmd;		/* waiting for command packet */
	char	mi_wantcredits;		/* waiting for transfer credits */
	struct	mscp_ctlr *mi_mc;	/* Pointer to parent's mscp_ctlr */
	struct	mscp_device *mi_me;	/* Pointer to child's mscp_device */
	struct	device **mi_dp;		/* array of backpointers */
	int	mi_driveno;		/* Max physical drive number found */
	char	mi_ctlrnr;		/* Phys ctlr nr */
	char	mi_adapnr;		/* Phys adapter nr */
	int	mi_flags;
	struct	mscp_pack *mi_uda;	/* virtual address */
	int	mi_type;
	short	mi_ivec;		/* Interrupt vector to use */
	short	mi_ierr;		/* Init err counter */
	bus_space_tag_t	   mi_iot;
	bus_space_handle_t mi_iph;	/* initialisation and polling */
	bus_space_handle_t mi_sah;	/* status & address (read part) */
	bus_space_handle_t mi_swh;	/* status & address (write part) */
	struct bufq mi_bufq;		/* While waiting for packets */
};

/* mi_flags */
#define MSC_STARTPOLL	1
#define MSC_INSTART	2
#define MSC_IGNOREINTR	4
#define MSC_READY	8

/*
 * We have run out of credits when mi_credits is <= MSCP_MINCREDITS.
 * It is still possible to issue one command in this case, but it must
 * not be a data transfer.  E.g., `get command status' or `abort command'
 * is legal, while `read' is not.
 */
#define MSCP_MINCREDITS 1

/*
 * Flags for mscp_getcp().
 */
#define MSCP_WAIT	1
#define MSCP_DONTWAIT	0

/*
 * Unit flags
 */
#define UNIT_ONLINE	0x01	/* drive is on line */
#define UNIT_HAVESTATUS 0x02	/* got unit status */
#define UNIT_REQUEUE	0x04	/* requeue after response */

/*
 * Handle a command ring transition: wake up sleepers for command packets.
 * This is too simple to bother with a function call.
 */
#define MSCP_DOCMD(mi) { \
	if ((mi)->mi_wantcmd) { \
		(mi)->mi_wantcmd = 0; \
		wakeup((caddr_t) &(mi)->mi_wantcmd); \
	} \
}

/* Prototypes */
struct	mscp *mscp_getcp(struct mscp_softc *, int);
void	mscp_printevent(struct mscp *);
void	mscp_go(struct mscp_softc *, struct mscp *, int);
void	mscp_requeue(struct mscp_softc *);
void	mscp_dorsp(struct mscp_softc *);
int	mscp_decodeerror(char *, struct mscp *, struct mscp_softc *);
int	mscp_print(void *, const char *);
void	mscp_hexdump(struct mscp *);
void	mscp_strategy(struct buf *, struct device *);
void	mscp_printtype(int, int);
int	mscp_waitstep(struct mscp_softc *, int, int);
void	mscp_dgo(struct mscp_softc *, struct mscp_xi *);
void	mscp_intr(struct mscp_softc *);
@


1.8
log
@replace the manual buf list management with a fifo bufq. it simplifies
the code in some cases and makes it generally more readable.

this has been tested in simh, real hardware may or may not work anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mscpvar.h,v 1.7 2011/11/01 20:50:11 miod Exp $	*/
@


1.7
log
@Remove orphaned comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscpvar.h,v 1.6 2003/06/02 23:27:57 millert Exp $	*/
d191 1
a191 1
	SIMPLEQ_HEAD(, buf) mi_resq;	/* While waiting for packets */
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscpvar.h,v 1.5 2002/03/15 01:20:04 millert Exp $	*/
a212 2

	/* get a command packet */
@


1.5
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: mscpvar.h,v 1.4 2002/03/14 01:26:48 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mscpvar.h,v 1.3 2000/04/27 03:14:46 bjc Exp $	*/
d84 6
a89 3
	void	(*mc_ctlrdone)		/* controller operation complete */(struct device *);
	void	(*mc_go)		/* device-specific start routine */(struct device *, struct mscp_xi *);
	void	(*mc_saerror)		/* ctlr error handling */(struct device *, int);
d95 18
a112 9
	void	(*me_dgram)	/* error datagram */(struct device *, struct mscp *, struct mscp_softc *);
	void	(*me_iodone)	/* normal I/O is done */(struct device *, struct buf *);
	int	(*me_online)	/* drive on line */(struct device *, struct mscp *);
	int	(*me_gotstatus) /* got unit status */(struct device *, struct mscp *);
	void	(*me_replace)	/* replace done */(struct device *, struct mscp *);
	int	(*me_ioerr)	/* read or write failed */(struct device *, struct mscp *, struct buf *);
	void	(*me_bb)	/* B_BAD io done */(struct device *, struct mscp *, struct buf *);
	void	(*me_fillin)	/* Fill in mscp info for this drive */(struct buf *,struct mscp *);
	void	(*me_cmddone)	/* Non-data transfer operation is done */(struct device *, struct mscp *);
@


1.3
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: mscpvar.h,v 1.2 1997/05/29 00:05:04 niklas Exp $	*/
d84 3
a86 6
	void	(*mc_ctlrdone)		/* controller operation complete */
	    __P((struct device *));
	void	(*mc_go)		/* device-specific start routine */
	    __P((struct device *, struct mscp_xi *));
	void	(*mc_saerror)		/* ctlr error handling */
	    __P((struct device *, int));
d92 9
a100 18
	void	(*me_dgram)	/* error datagram */
	    __P((struct device *, struct mscp *, struct mscp_softc *));
	void	(*me_iodone)	/* normal I/O is done */
	    __P((struct device *, struct buf *));
	int	(*me_online)	/* drive on line */
	    __P((struct device *, struct mscp *));
	int	(*me_gotstatus) /* got unit status */
	    __P((struct device *, struct mscp *));
	void	(*me_replace)	/* replace done */
	    __P((struct device *, struct mscp *));
	int	(*me_ioerr)	/* read or write failed */
	    __P((struct device *, struct mscp *, struct buf *));
	void	(*me_bb)	/* B_BAD io done */
	    __P((struct device *, struct mscp *, struct buf *));
	void	(*me_fillin)	/* Fill in mscp info for this drive */
	    __P((struct buf *,struct mscp *));
	void	(*me_cmddone)	/* Non-data transfer operation is done */
	    __P((struct device *, struct mscp *));
d227 13
a239 13
struct	mscp *mscp_getcp __P((struct mscp_softc *, int));
void	mscp_printevent __P((struct mscp *));
void	mscp_go __P((struct mscp_softc *, struct mscp *, int));
void	mscp_requeue __P((struct mscp_softc *));
void	mscp_dorsp __P((struct mscp_softc *));
int	mscp_decodeerror __P((char *, struct mscp *, struct mscp_softc *));
int	mscp_print __P((void *, const char *));
void	mscp_hexdump __P((struct mscp *));
void	mscp_strategy __P((struct buf *, struct device *));
void	mscp_printtype __P((int, int));
int	mscp_waitstep __P((struct mscp_softc *, int, int));
void	mscp_dgo __P((struct mscp_softc *, struct mscp_xi *));
void	mscp_intr __P((struct mscp_softc *));
@


1.3.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mscpvar.h,v 1.3 2000/04/27 03:14:46 bjc Exp $	*/
d84 6
a89 6
					/* controller operation complete */
	void	(*mc_ctlrdone)(struct device *);
					/* device-specific start routine */
	void	(*mc_go)(struct device *, struct mscp_xi *);
					/* ctlr error handling */
	void	(*mc_saerror)(struct device *, int);
d95 18
a112 18
				/* error datagram */
	void	(*me_dgram)(struct device *, struct mscp *, struct mscp_softc *);
				/* normal I/O is done */
	void	(*me_iodone)(struct device *, struct buf *);
				/* drive on line */
	int	(*me_online)(struct device *, struct mscp *);
				/* got unit status */
	int	(*me_gotstatus)(struct device *, struct mscp *);
				/* replace done */
	void	(*me_replace)(struct device *, struct mscp *);
				/* read or write failed */
	int	(*me_ioerr)(struct device *, struct mscp *, struct buf *);
				/* B_BAD io done */
	void	(*me_bb)(struct device *, struct mscp *, struct buf *);
				/* Fill in mscp info for this drive */
	void	(*me_fillin)(struct buf *,struct mscp *);
				/* Non-data transfer operation is done */
	void	(*me_cmddone)(struct device *, struct mscp *);
d239 13
a251 13
struct	mscp *mscp_getcp(struct mscp_softc *, int);
void	mscp_printevent(struct mscp *);
void	mscp_go(struct mscp_softc *, struct mscp *, int);
void	mscp_requeue(struct mscp_softc *);
void	mscp_dorsp(struct mscp_softc *);
int	mscp_decodeerror(char *, struct mscp *, struct mscp_softc *);
int	mscp_print(void *, const char *);
void	mscp_hexdump(struct mscp *);
void	mscp_strategy(struct buf *, struct device *);
void	mscp_printtype(int, int);
int	mscp_waitstep(struct mscp_softc *, int, int);
void	mscp_dgo(struct mscp_softc *, struct mscp_xi *);
void	mscp_intr(struct mscp_softc *);
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: mscpvar.h,v 1.4 1997/01/11 11:20:36 ragge Exp $	*/
/*	$NetBSD: mscpvar.h,v 1.4 1997/01/11 11:20:36 ragge Exp $	*/
d73 10
d85 3
a87 3
	    __P((struct device *, int));
	int	(*mc_go)		/* device-specific start routine */
	    __P((struct device *, struct buf *));
d101 1
a101 1
	int	(*me_gotstatus)	/* got unit status */
a121 1
	struct	mscp_pack *ma_uuda;	/* comm area on bus */
d123 6
a128 3
	short	*ma_ip;			/* initialisation and polling */
	short	*ma_sa;			/* status & address (read part) */
	short	*ma_sw;			/* status & address (write part) */
d135 3
a137 3
#define	MSCPBUS_UDA	004	/* ctlr is disk on unibus/qbus */
#define	MSCPBUS_KDB	010	/* ctlr is disk on BI */
#define	MSCPBUS_KLE	020	/* ctlr is tape on unibus/qbus */
d173 4
a179 2
	struct	buf *mi_actf;		/* Pointer to buffers in */
	struct	buf *mi_actb;		/*  circular wait queue */
a187 1
	struct	mscp_pack *mi_uuda;	/* (device-specific) address */
d191 5
a195 4
	volatile short *mi_ip;        	/* initialisation and polling */
	volatile short *mi_sa;        	/* status & address (read part) */
	volatile short *mi_sw;        	/* status & address (write part) */
	struct	buf *mi_w;		/* While waiting for packets */
d199 4
a202 4
#define	MSC_STARTPOLL	1
#define	MSC_INSTART	2
#define	MSC_IGNOREINTR	4
#define	MSC_READY	8
a237 18
/*
 * The following macro appends a buffer to a drive queue or a drive to
 * a controller queue, given the name of the forward link.  Use as
 * `APPEND(dp, &um->um_tab, b_forw)' or `APPEND(bp, dp, av_forw)',
 * where `bp' is a transfer request, `dp' is a drive queue, and `um_tab'
 * is a controller queue.  (That is, the forward link for controller
 * queues is `b_forw'; for drive queues, it is `av_forw'.)
 */

#define	MSCP_APPEND(bp, queue, link) {			\
	(bp)->link = NULL;				\
	if ((queue)->link == NULL)			\
		(queue)->link = (bp);			\
	else						\
		*(queue)->b_actb = (bp);		\
	(queue)->b_actb = &(bp)->link;			\
}

d250 1
a250 1
void	mscp_dgo __P((struct mscp_softc *, long, long, struct buf *));
@


1.2.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: mscpvar.h,v 1.3 2000/04/27 03:14:46 bjc Exp $	*/
/*	$NetBSD: mscpvar.h,v 1.7 1999/06/06 19:16:18 ragge Exp $	*/
a72 10
/*
 * Transfer info, one per command packet.
 */
struct mscp_xi {
	bus_dmamap_t	mxi_dmam;	/* Allocated DMA map for this entry */
	struct buf *	mxi_bp;		/* Buffer used in this command */
	struct mscp *	mxi_mp;		/* Packet used in this command */
	int		mxi_inuse;
};

d75 3
a77 3
	    __P((struct device *));
	void	(*mc_go)		/* device-specific start routine */
	    __P((struct device *, struct mscp_xi *));
d91 1
a91 1
	int	(*me_gotstatus) /* got unit status */
d112 1
d114 3
a116 6
	bus_dmamap_t	   ma_dmam;	/* This comm area dma info */
	bus_dma_tag_t	   ma_dmat;
	bus_space_tag_t	   ma_iot;
	bus_space_handle_t ma_iph;	/* initialisation and polling */
	bus_space_handle_t ma_sah;	/* status & address (read part) */
	bus_space_handle_t ma_swh;	/* status & address (write part) */
d123 3
a125 3
#define MSCPBUS_UDA	004	/* ctlr is disk on unibus/qbus */
#define MSCPBUS_KDB	010	/* ctlr is disk on BI */
#define MSCPBUS_KLE	020	/* ctlr is tape on unibus/qbus */
a160 4
	bus_dma_tag_t	mi_dmat;
	bus_dmamap_t	mi_dmam;
	struct	mscp_xi mi_xi[NCMD];
	int	mi_mxiuse;		/* Bitfield of inuse mxi packets */
d164 2
d174 1
d178 4
a181 5
	bus_space_tag_t	   mi_iot;
	bus_space_handle_t mi_iph;	/* initialisation and polling */
	bus_space_handle_t mi_sah;	/* status & address (read part) */
	bus_space_handle_t mi_swh;	/* status & address (write part) */
	SIMPLEQ_HEAD(, buf) mi_resq;	/* While waiting for packets */
d185 4
a188 4
#define MSC_STARTPOLL	1
#define MSC_INSTART	2
#define MSC_IGNOREINTR	4
#define MSC_READY	8
d224 18
d254 1
a254 1
void	mscp_dgo __P((struct mscp_softc *, struct mscp_xi *));
@


1.2.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 6
a89 6
					/* controller operation complete */
	void	(*mc_ctlrdone)(struct device *);
					/* device-specific start routine */
	void	(*mc_go)(struct device *, struct mscp_xi *);
					/* ctlr error handling */
	void	(*mc_saerror)(struct device *, int);
d95 18
a112 18
				/* error datagram */
	void	(*me_dgram)(struct device *, struct mscp *, struct mscp_softc *);
				/* normal I/O is done */
	void	(*me_iodone)(struct device *, struct buf *);
				/* drive on line */
	int	(*me_online)(struct device *, struct mscp *);
				/* got unit status */
	int	(*me_gotstatus)(struct device *, struct mscp *);
				/* replace done */
	void	(*me_replace)(struct device *, struct mscp *);
				/* read or write failed */
	int	(*me_ioerr)(struct device *, struct mscp *, struct buf *);
				/* B_BAD io done */
	void	(*me_bb)(struct device *, struct mscp *, struct buf *);
				/* Fill in mscp info for this drive */
	void	(*me_fillin)(struct buf *,struct mscp *);
				/* Non-data transfer operation is done */
	void	(*me_cmddone)(struct device *, struct mscp *);
d239 13
a251 13
struct	mscp *mscp_getcp(struct mscp_softc *, int);
void	mscp_printevent(struct mscp *);
void	mscp_go(struct mscp_softc *, struct mscp *, int);
void	mscp_requeue(struct mscp_softc *);
void	mscp_dorsp(struct mscp_softc *);
int	mscp_decodeerror(char *, struct mscp *, struct mscp_softc *);
int	mscp_print(void *, const char *);
void	mscp_hexdump(struct mscp *);
void	mscp_strategy(struct buf *, struct device *);
void	mscp_printtype(int, int);
int	mscp_waitstep(struct mscp_softc *, int, int);
void	mscp_dgo(struct mscp_softc *, struct mscp_xi *);
void	mscp_intr(struct mscp_softc *);
@


1.2.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mscpvar.h,v 1.2.12.2 2002/03/28 11:26:46 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
