head	1.49;
access;
symbols
	OPENBSD_5_9:1.48.0.4
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.46.0.6
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.40.0.4
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.2
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.6
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.6
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.48;
commitid	OSDG2O3Cgeifnf1W;

1.48
date	2015.02.07.00.20.53;	author miod;	state Exp;
branches;
next	1.47;
commitid	BIE3jnBRJHBXZ78c;

1.47
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.46;
commitid	CaCLs5fTSVpJlqFi;

1.46
date	2013.06.30.17.04.46;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2012.12.05.23.20.15;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.15.00.48.24;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.06.20.42.05;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.28.20.27.56;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.20.18.39.30;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.15.23.23.50;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.10.08.36.28;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.09.08.43.43;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.18.23.05.37;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2008.08.15.22.38.20;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.16.05.19.13;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.05.17.32.37;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.29.12.26.14;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.20.19.15.34;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.04.15.41.29;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.02.18.09.25;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.07.23.10.45;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.13.21.49.21;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.12.12.36.13;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.05.22.34.26;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2000.04.26.03.08.40;	author bjc;	state Exp;
branches;
next	1.9;

1.9
date	99.01.10.13.34.20;	author niklas;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	97.09.12.09.21.19;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.09.10.11.47.05;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	97.05.29.00.04.37;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.24.37;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.06.12.08.20.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.09.36;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.13.59.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.06;	author deraadt;	state Exp;
branches;
next	;

1.9.6.1
date	2001.05.14.21.37.58;	author niklas;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2001.07.04.10.24.26;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.9.6.4;

1.9.6.4
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.9.6.5;

1.9.6.5
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.9.6.6;

1.9.6.6
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	1.9.6.7;

1.9.6.7
date	2004.06.06.05.23.39;	author tedu;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.49
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: cpu.h,v 1.48 2015/02/07 00:20:53 miod Exp $	*/
/*	$NetBSD: cpu.h,v 1.41 1999/10/21 20:01:36 ragge Exp $	*/

/*
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed at Ludd, University of Lule}
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_CPU_H_
#define _MACHINE_CPU_H_
#ifdef _KERNEL

#include <sys/device.h>
#include <sys/evcount.h>

#include <machine/mtpr.h>
#include <machine/pte.h>
#include <machine/pcb.h>
#include <machine/uvax.h>
#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/intr.h>

#include <sys/sched.h>
struct cpu_info {
	struct proc *ci_curproc;

	struct schedstate_percpu ci_schedstate; /* scheduler state */
	u_int32_t 		ci_randseed;
#ifdef DIAGNOSTIC
	int	ci_mutex_level;
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
};

extern struct cpu_info cpu_info_store;
#define	curcpu()	(&cpu_info_store)
#define cpu_number()	0
#define CPU_IS_PRIMARY(ci)	1
#define CPU_INFO_ITERATOR	int
#define CPU_INFO_FOREACH(cii, ci) \
	for (cii = 0, ci = curcpu(); ci != NULL; ci = NULL)
#define CPU_INFO_UNIT(ci)	0
#define MAXCPUS	1
#define cpu_unidle(ci)

#define CPU_BUSY_CYCLE()	do {} while (0)

struct clockframe {
	int	pc;
	int	ps;
};

/*
 * All cpu-dependent info is kept in this struct. Pointer to the
 * struct for the current cpu is set up in locore.c.
 */
struct	cpu_dep {
	void	(*cpu_init)(void);	/* pmap init before mm is on */
	int	(*cpu_mchk)(caddr_t);	/* Machine check handling */
	void	(*cpu_memerr)(void);	/* Memory subsystem errors */
	void	(*cpu_conf)(void);	/* Autoconfiguration */
	int	(*cpu_clkread)(struct timespec *, time_t); /* Read cpu clock time */
	void	(*cpu_clkwrite)(void);	/* Write system time to cpu */
	short	cpu_vups;	/* speed of cpu */
	short	cpu_scbsz;	/* (estimated) size of system control block */
	void	(*cpu_halt)(void); /* Cpu dependent halt call */
	void	(*cpu_reboot)(int); /* Cpu dependent reboot call */
	void	(*cpu_clrf)(void); /* Clear cold/warm start flags */
	void	(*cpu_hardclock)(struct clockframe *);	/* hardclock handler */
};

extern struct cpu_dep *dep_call; /* Holds pointer to current CPU struct. */

extern struct device *booted_from;
extern int mastercpu;
extern int bootdev;

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */

#define need_resched(ci){ \
	want_resched++; \
	mtpr(AST_OK,PR_ASTLVL); \
	}
#define clear_resched(ci) 	want_resched = 0

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */

#define signotify(p)		mtpr(AST_OK,PR_ASTLVL);

extern	int	want_resched;	/* resched() was called */

/*
 * This is used during profiling to integrate system time.
 */
#define	PROC_PC(p)	(((struct trapframe *)((p)->p_addr->u_pcb.framep))->pc)
#define	PROC_STACK(p)	(((struct trapframe *)((p)->p_addr->u_pcb.framep))->sp)

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the vax, request an ast to send us
 * through trap, marking the proc as needing a profiling tick.
 */
#define need_proftick(p) mtpr(AST_OK,PR_ASTLVL)

/*
 * Temporarily switching to ipl 1 when the kernel is idle allows SIMH
 * to recognize the system is idle, and relinquish CPU time as well.
 */
#define	cpu_idle_enter()	do { /* nothing */ } while (0)
#define	cpu_idle_leave()	do { /* nothing */ } while (0)
#define	cpu_idle_cycle() \
do { \
	mtpr(0x01, PR_IPL); \
	mtpr(0x00, PR_IPL); \
} while (0)

/*
 * This defines the I/O device register space size in pages.
 */
#define	IOSPSZ	((16*1024) / VAX_NBPG)	/* 16Kb == 32 pages */

struct device;

extern char cpu_model[100];

/* Some low-level prototypes */
int	badaddr(caddr_t, int);
void	dumpconf(void);
void	dumpsys(void);
void	swapconf(void);
void	disk_printtype(int, int);
vaddr_t	vax_map_physmem(paddr_t, int);
void	vax_unmap_physmem(vaddr_t, int);
void	ioaccess(vaddr_t, paddr_t, int);
void	iounaccess(vaddr_t, int);
void	findcpu(void);
#ifdef DDB
int	kdbrint(int);
#endif
#endif /* _KERNEL */

/*
 * CTL_MACHDEP definitions.
 */
#define CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_LED_BLINK		2	/* int: display led patterns */
#define CPU_MAXID		3	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ "led_blink", CTLTYPE_INT } \
}

#endif /* _MACHINE_CPU_H_ */
@


1.48
log
@Shrink the I/O map from 64KB to 16KB. This map is only used for
smaller-than-a-logical-page allocations, while logical page size and larger
are passed to uvm.

So in the worst case, the kernel will end up needing about 20 vax pages out
of it: 1 for non-console serial chips, up to 2 per Ethernet controller,
1 per SCSI controller, up to 3 for the clock or SSC chip, 1 for the cpmbox,
up to 3 for model-specific mappings (VS_REGS, KA650 stuff), 1 for the leds,
and up to 3 for frame buffer registers.

Thus shrinking from 128 pages to 32 is still large enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.47 2014/07/11 10:53:07 uebayasi Exp $	*/
@


1.47
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d154 1
a154 1
#define	IOSPSZ	((64*1024) / VAX_NBPG)	/* 64k == 128 pages */
@


1.46
log
@Shortly run at ipl 1 in cpu_idle_cycle(), to let SIMH recognize the system
is idle; adapted from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.45 2013/03/12 09:37:16 mpi Exp $	*/
d73 2
@


1.45
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.44 2013/02/12 08:06:22 mpi Exp $	*/
d137 4
a141 1
#define	cpu_idle_cycle()	do { /* nothing */ } while (0)
d143 5
@


1.44
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.43 2013/02/11 17:05:25 mpi Exp $	*/
d57 3
@


1.43
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.42 2012/12/05 23:20:15 deraadt Exp $	*/
a56 3
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
@


1.42
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.41 2012/12/02 07:03:31 guenther Exp $	*/
d57 3
@


1.41
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2011/09/15 00:48:24 miod Exp $	*/
a37 1
#include <sys/cdefs.h>
@


1.40
log
@Switch vax to timecounters. There are three different clock sources:
- ICR/NICR on most systems (1MHz counter resolution).
- diagnostic timer on KA46/KA48 (1kHz counter resolution, counter is actually
  running at around 1024 kHz but is not guaranteed to be monotonic at this
  rate).
- 100Hz clock on VXT (nothing but the 100Hz clock interrupt).

Tested on KA49 (ICR style), KA46, KA48 (diagtmr style), VXT2000+ (VXT
{empty,hopeless}ness'r'us style).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.39 2011/07/06 20:42:05 miod Exp $	*/
d126 1
@


1.39
log
@Drop cpu_dep.cpu_subconf routine, which is no longer used after KA820 support
removal.
@
text
@d1 2
a2 2
/*      $OpenBSD: cpu.h,v 1.38 2011/07/06 18:32:59 miod Exp $      */
/*      $NetBSD: cpu.h,v 1.41 1999/10/21 20:01:36 ragge Exp $      */
d73 2
a74 2
        int     pc;
        int     ps;
d82 5
a86 6
	void	(*cpu_init)(void); /* pmap init before mm is on */
	int	(*cpu_mchk)(caddr_t);   /* Machine check handling */
	void	(*cpu_memerr)(void); /* Memory subsystem errors */
	    /* Autoconfiguration */
	void	(*cpu_conf)(void);
	int	(*cpu_clkread)(time_t);	/* Read cpu clock time */
d118 1
a118 1
#define signotify(p)     mtpr(AST_OK,PR_ASTLVL);
d120 1
a120 1
extern	int     want_resched;   /* resched() was called */
@


1.38
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.37 2011/03/23 16:54:37 pirofti Exp $      */
a93 1
	void	(*cpu_subconf)(struct device *);/*config cpu dep. devs */
@


1.37
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.36 2010/09/28 20:27:56 miod Exp $      */
a154 1
void	disk_reallymapin(struct buf *, pt_entry_t *, int, int);
@


1.36
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.35 2009/03/26 17:24:33 oga Exp $      */
d34 2
a35 2
#ifndef _VAX_CPU_H_
#define _VAX_CPU_H_
d179 1
a179 1
#endif /* _VAX_CPU_H_ */
@


1.35
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.34 2009/03/20 18:39:30 miod Exp $      */
d56 3
@


1.34
log
@Switch vax to __HAVE_GENERIC_SOFT_INTERRUPTS.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.33 2008/10/15 23:23:50 deraadt Exp $      */
a48 2

#define	cpu_wait(p)
@


1.33
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.32 2008/10/10 08:36:28 art Exp $      */
a102 2
#define	setsoftnet()	mtpr(IPL_SOFTNET,PR_SIRR)
#define setsoftclock()	mtpr(IPL_SOFTCLOCK,PR_SIRR)
@


1.32
log
@Add empty cpu_unidle() macros for architectures that currently don't do
anything special to prod a cpu to leave the idle loop in signotify.
powerpc, i386, amd64 and sparc64 will follow soon so that everyone has
the same interface to wake an idling cpu.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.31 2008/10/10 08:05:45 art Exp $      */
d57 1
@


1.31
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.30 2008/10/09 08:43:43 art Exp $      */
d68 1
@


1.30
log
@Implement CPU_INFO_UNIT for everyone, not just MP kernels.
ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.29 2008/08/18 23:05:37 miod Exp $      */
d67 1
@


1.29
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.28 2008/08/15 22:38:20 miod Exp $      */
d66 1
@


1.28
log
@Rename the cpu_dep hook ``steal_pages'' to ``init'', as it serves as an
early initialization routine (to enable caches, etc) while still running
physical, and does not allocate memory anymore.

(The irony in this is that forthcoming KA60 support actually steals pages
 in its init function...)
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.27 2008/07/18 23:43:31 art Exp $      */
d67 5
d90 1
a93 5

struct clockframe {
        int     pc;
        int     ps;
};
@


1.27
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.26 2007/10/10 15:53:53 art Exp $      */
d72 1
a72 1
	void	(*cpu_steal_pages)(void); /* pmap init before mm is on */
a99 1
#define	todr()		mfpr(PR_TODR)
@


1.26
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.25 2007/05/16 05:19:13 miod Exp $      */
d110 1
@


1.25
log
@Switch vax to __HAVE_CPUINFO, based on an incomplete diff from art.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.24 2007/04/05 17:32:37 miod Exp $      */
d131 4
@


1.24
log
@Reuse symbolic values for splsoftXXX() inlines, instead of hardcoding them.
No functional change.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.23 2007/03/15 10:22:30 art Exp $      */
d51 15
a65 1
#define	cpu_number()			0
@


1.23
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.22 2006/12/24 20:30:35 miod Exp $      */
d48 1
d84 2
a85 2
#define	setsoftnet()	mtpr(12,PR_SIRR)
#define setsoftclock()	mtpr(8,PR_SIRR)
@


1.22
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.21 2006/11/29 12:26:14 miod Exp $      */
d115 1
a115 1
#define need_proftick(p) {(p)->p_flag |= P_OWEUPC; mtpr(AST_OK,PR_ASTLVL); }
@


1.21
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.20 2006/07/20 19:15:34 miod Exp $      */
d47 1
d106 5
d112 1
a112 1
 * buffer pages are invalid.  On the hp300, request an ast to send us
@


1.20
log
@Here cometh the blinkenlichten on VAXens.
Register information from NetBSD (except for KA53), logic from OpenBSD/sparc.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.19 2006/01/04 15:41:29 martin Exp $      */
a48 1
#define	cpu_swapout(p)
a121 1
void	cpu_swapin(struct proc *);
@


1.19
log
@add sysctl machdep.console_device support
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.18 2006/01/02 18:09:25 miod Exp $      */
d143 2
a144 1
#define CPU_MAXID		2	/* number of valid machdep ids */
d149 1
@


1.18
log
@Kill enablertclock.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.17 2004/07/07 23:10:45 deraadt Exp $      */
d138 12
@


1.17
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.16 2004/06/13 21:49:21 niklas Exp $      */
a47 1
#define enablertclock()
@


1.16
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*      $OpenBSD$      */
d40 1
@


1.15
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.14 2003/05/11 19:41:12 deraadt Exp $      */
d91 1
a91 1
#define need_resched(){ \
@


1.14
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.13 2002/06/12 12:36:13 hugh Exp $      */
d42 1
d128 1
a128 1
void	disk_reallymapin(struct buf *, struct pte *, int, int);
@


1.13
log
@bdevtomaj worked well, but is no longer needed.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.12 2002/03/14 01:26:48 millert Exp $      */
d117 2
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.11 2001/05/05 22:34:26 art Exp $      */
a120 4
int	hp_getdev(int, int, struct device **);
int	sd_getdev(int, int, int, int, char **);
int	ra_getdev(int, int, int, char **);
int	bdevtomaj(int);
@


1.11
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.10 2000/04/26 03:08:40 bjc Exp $      */
d56 3
a58 3
	void	(*cpu_steal_pages) __P((void)); /* pmap init before mm is on */
	int	(*cpu_mchk) __P((caddr_t));   /* Machine check handling */
	void	(*cpu_memerr) __P((void)); /* Memory subsystem errors */
d60 3
a62 3
	void	(*cpu_conf) __P((void));
	int	(*cpu_clkread) __P((time_t));	/* Read cpu clock time */
	void	(*cpu_clkwrite) __P((void));	/* Write system time to cpu */
d65 4
a68 4
	void	(*cpu_halt) __P((void)); /* Cpu dependent halt call */
	void	(*cpu_reboot) __P((int)); /* Cpu dependent reboot call */
	void	(*cpu_clrf) __P((void)); /* Clear cold/warm start flags */
	void	(*cpu_subconf) __P((struct device *));/*config cpu dep. devs */
d119 16
a134 16
int	badaddr __P((caddr_t, int));
void	cpu_swapin __P((struct proc *));
int	hp_getdev __P((int, int, struct device **));
int	sd_getdev __P((int, int, int, int, char **));
int	ra_getdev __P((int, int, int, char **));
int	bdevtomaj __P((int));
void	dumpconf __P((void));
void	dumpsys __P((void));
void	swapconf __P((void));
void	disk_printtype __P((int, int));
void	disk_reallymapin __P((struct buf *, struct pte *, int, int));
vaddr_t	vax_map_physmem __P((paddr_t, int));
void	vax_unmap_physmem __P((vaddr_t, int));
void	ioaccess __P((vaddr_t, paddr_t, int));
void	iounaccess __P((vaddr_t, int));
void	findcpu __P((void));
d136 1
a136 1
int	kdbrint __P((int));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.11 2001/05/05 22:34:26 art Exp $      */
d56 3
a58 3
	void	(*cpu_steal_pages)(void); /* pmap init before mm is on */
	int	(*cpu_mchk)(caddr_t);   /* Machine check handling */
	void	(*cpu_memerr)(void); /* Memory subsystem errors */
d60 3
a62 3
	void	(*cpu_conf)(void);
	int	(*cpu_clkread)(time_t);	/* Read cpu clock time */
	void	(*cpu_clkwrite)(void);	/* Write system time to cpu */
d65 4
a68 4
	void	(*cpu_halt)(void); /* Cpu dependent halt call */
	void	(*cpu_reboot)(int); /* Cpu dependent reboot call */
	void	(*cpu_clrf)(void); /* Clear cold/warm start flags */
	void	(*cpu_subconf)(struct device *);/*config cpu dep. devs */
d119 16
a134 16
int	badaddr(caddr_t, int);
void	cpu_swapin(struct proc *);
int	hp_getdev(int, int, struct device **);
int	sd_getdev(int, int, int, int, char **);
int	ra_getdev(int, int, int, char **);
int	bdevtomaj(int);
void	dumpconf(void);
void	dumpsys(void);
void	swapconf(void);
void	disk_printtype(int, int);
void	disk_reallymapin(struct buf *, struct pte *, int, int);
vaddr_t	vax_map_physmem(paddr_t, int);
void	vax_unmap_physmem(vaddr_t, int);
void	ioaccess(vaddr_t, paddr_t, int);
void	iounaccess(vaddr_t, int);
void	findcpu(void);
d136 1
a136 1
int	kdbrint(int);
@


1.11.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.11.4.1 2002/06/11 03:39:19 art Exp $      */
d121 4
@


1.11.4.3
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$      */
a116 2

extern char cpu_model[100];
@


1.10
log
@vax resurrection, part 1: sync with early-april netbsd

many changes here, notable:  uvm, ansi.h, more (and cleaner) vsbus support
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.9 1999/01/10 13:34:20 niklas Exp $      */
a49 2

void configure       __P((void));
@


1.9
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 2
a2 2
/*      $OpenBSD: cpu.h,v 1.8 1997/09/12 09:21:19 maja Exp $      */
/*      $NetBSD: cpu.h,v 1.24 1997/07/26 10:12:40 ragge Exp $      */
d34 4
d44 1
d49 3
a58 1
	void	(*cpu_clock) __P((void)); /* CPU dep RT clock start */
d62 1
a62 1
	void	(*cpu_conf) __P((struct device *, struct device *, void *));
d65 2
a66 5
	int	cpu_vups;	/* speed of cpu */
	u_char  *cpu_intreq;	/* Used on some VAXstations */
	u_char  *cpu_intclr;	/* Used on some VAXstations */
	u_char  *cpu_intmsk;	/* Used on some VAXstations */
	struct	uc_map *cpu_map; /* Map containing important addresses */
d69 2
a80 1
extern int cold;
d113 7
d123 2
a124 1
int	hp_getdev __P((int, int, char **));
d126 1
a126 1
void	configure __P((void));
a128 2
void	setroot __P((void));
void	setconf __P((void));
d130 7
d140 2
@


1.9.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*      $OpenBSD: cpu.h,v 1.10 2000/04/26 03:08:40 bjc Exp $      */
/*      $NetBSD: cpu.h,v 1.41 1999/10/21 20:01:36 ragge Exp $      */
a33 4
#ifndef _VAX_CPU_H_
#define _VAX_CPU_H_
#ifdef _KERNEL

a39 1
#include <machine/psl.h>
a43 3
#define	cpu_number()			0

void configure       __P((void));
d51 1
d55 1
a55 1
	void	(*cpu_conf) __P((void));
d58 5
a62 2
	short	cpu_vups;	/* speed of cpu */
	short	cpu_scbsz;	/* (estimated) size of system control block */
a64 2
	void	(*cpu_clrf) __P((void)); /* Clear cold/warm start flags */
	void	(*cpu_subconf) __P((struct device *));/*config cpu dep. devs */
d75 1
a107 7
/*
 * This defines the I/O device register space size in pages.
 */
#define	IOSPSZ	((64*1024) / VAX_NBPG)	/* 64k == 128 pages */

struct device;

d111 1
a111 2
int	hp_getdev __P((int, int, struct device **));
int	sd_getdev __P((int, int, int, int, char **));
d113 1
a113 1
int	bdevtomaj __P((int));
d116 2
a118 7
void	disk_printtype __P((int, int));
void	disk_reallymapin __P((struct buf *, struct pte *, int, int));
vaddr_t	vax_map_physmem __P((paddr_t, int));
void	vax_unmap_physmem __P((vaddr_t, int));
void	ioaccess __P((vaddr_t, paddr_t, int));
void	iounaccess __P((vaddr_t, int));
void	findcpu __P((void));
a121 2
#endif /* _KERNEL */
#endif /* _VAX_CPU_H_ */
@


1.9.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.9.6.1 2001/05/14 21:37:58 niklas Exp $      */
d50 2
@


1.9.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*      $OpenBSD$      */
d56 3
a58 3
	void	(*cpu_steal_pages)(void); /* pmap init before mm is on */
	int	(*cpu_mchk)(caddr_t);   /* Machine check handling */
	void	(*cpu_memerr)(void); /* Memory subsystem errors */
d60 3
a62 3
	void	(*cpu_conf)(void);
	int	(*cpu_clkread)(time_t);	/* Read cpu clock time */
	void	(*cpu_clkwrite)(void);	/* Write system time to cpu */
d65 4
a68 4
	void	(*cpu_halt)(void); /* Cpu dependent halt call */
	void	(*cpu_reboot)(int); /* Cpu dependent reboot call */
	void	(*cpu_clrf)(void); /* Clear cold/warm start flags */
	void	(*cpu_subconf)(struct device *);/*config cpu dep. devs */
d119 16
a134 16
int	badaddr(caddr_t, int);
void	cpu_swapin(struct proc *);
int	hp_getdev(int, int, struct device **);
int	sd_getdev(int, int, int, int, char **);
int	ra_getdev(int, int, int, char **);
int	bdevtomaj(int);
void	dumpconf(void);
void	dumpsys(void);
void	swapconf(void);
void	disk_printtype(int, int);
void	disk_reallymapin(struct buf *, struct pte *, int, int);
vaddr_t	vax_map_physmem(paddr_t, int);
void	vax_unmap_physmem(vaddr_t, int);
void	ioaccess(vaddr_t, paddr_t, int);
void	iounaccess(vaddr_t, int);
void	findcpu(void);
d136 1
a136 1
int	kdbrint(int);
@


1.9.6.4
log
@Sync the SMP branch with 3.3
@
text
@d121 4
@


1.9.6.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.9.6.4 2003/03/27 23:52:19 niklas Exp $      */
a116 2

extern char cpu_model[100];
@


1.9.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD$      */
a41 1
#include <machine/pte.h>
d127 1
a127 1
void	disk_reallymapin(struct buf *, pt_entry_t *, int, int);
@


1.9.6.7
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.9.6.6 2004/02/19 10:50:02 niklas Exp $      */
d91 1
a91 1
#define need_resched(ci){ \
@


1.8
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*      $OpenBSD: cpu.h,v 1.7 1997/09/10 11:47:05 maja Exp $      */
a109 1
void	cpu_set_kpc __P((struct proc *, void (*)(struct proc *)));
@


1.7
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*      $OpenBSD: cpu.h,v 1.6 1997/05/29 00:04:37 niklas Exp $      */
/*      $NetBSD: cpu.h,v 1.23 1997/03/15 15:09:41 ragge Exp $      */
d63 2
@


1.6
log
@RCS tagging
@
text
@d1 2
a2 2
/*      $OpenBSD: cpu.h,v 1.19 1996/07/20 17:58:12 ragge Exp $      */
/*      $NetBSD: cpu.h,v 1.19 1996/07/20 17:58:12 ragge Exp $      */
a33 2
 /* All bugs are subject to removal without further notice */

d39 1
d45 4
a48 2
extern struct cpu_dep cpu_calls[];

d58 5
d65 2
d72 1
d75 1
@


1.5
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.4
log
@sync to 0611
@
text
@d1 1
a1 1
/*      $NetBSD: cpu.h,v 1.17 1996/05/19 16:43:16 ragge Exp $      */
a44 2

extern int cpunumber, cpu_type;
d49 1
a49 1
	int	(*cpu_clock) __P((void)); /* CPU dependent clock handling */
d54 2
d63 3
d68 1
a68 1

d99 2
a100 1
int	hp_getdev __P((int, int));
@


1.3
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*      $NetBSD: cpu.h,v 1.16 1996/04/08 18:35:46 ragge Exp $      */
d36 2
d54 2
a55 1
	void	(*cpu_conf) __P((void *, void *, void *)); /* Autoconfiguration */
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
/*      $NetBSD: cpu.h,v 1.13 1995/12/13 18:57:57 ragge Exp $      */
d35 3
a37 3
#include "sys/cdefs.h"
#include "machine/mtpr.h"
#include "machine/pcb.h"
d48 5
a52 6
	int	(*cpu_steal_pages)(); /* Pmap init before mm is on */
	int	(*cpu_clock)();	 /* CPU dependent clock handling */
	int	(*cpu_mchk)();   /* Machine check handling */
	int	(*cpu_memerr)(); /* Memory subsystem errors */
	int	(*cpu_conf)();	 /* Autoconfiguration */
/*	int	(*cpu_cmrerr)(); /* Memory parity errors */
d89 14
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: cpu.h,v 1.12 1995/06/05 17:17:57 ragge Exp $      */
d44 1
a44 1
extern volatile int cpunumber;
d48 1
a48 1
	int	(*cpu_loinit)(); /* Locore init before everything else */
d53 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
