head	1.12;
access;
symbols
	OPENBSD_5_9:1.11.0.16
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.18
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.10
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.14
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.12
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.8
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.18
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.16
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.12
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.2.0.12
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.11;
commitid	OSDG2O3Cgeifnf1W;

1.11
date	2011.09.11.19.29.01;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.13.21.11.23;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.07.23.10.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.25.13.33.36;	author hugh;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2000.10.09.23.11.57;	author bjc;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.27.07.19.57;	author bjc;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.03.08.43;	author bjc;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.00.04.57;	author niklas;	state Exp;
branches
	1.2.12.1;
next	1.1;

1.1
date	97.01.15.23.24.46;	author maja;	state Exp;
branches;
next	;

1.2.12.1
date	2001.05.14.21.38.10;	author niklas;	state Exp;
branches;
next	1.2.12.2;

1.2.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.2.12.3;

1.2.12.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: vsbus.h,v 1.11 2011/09/11 19:29:01 miod Exp $ */
/*	$NetBSD: vsbus.h,v 1.13 2000/06/25 16:00:46 ragge Exp $ */
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by Bertram Barth.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Generic definitions for the (virtual) vsbus. contains common info
 * used by all VAXstations.
 */

#ifndef _MACHINE_VSBUS_H_
#define _MACHINE_VSBUS_H_

#include <machine/bus.h>
#include <machine/sgmap.h>

struct	vsbus_attach_args {
	vaddr_t	va_addr;		/* virtual CSR address */
	paddr_t	va_paddr;		/* physical CSR address */

	short	va_br;			/* Interrupt level */
	int	va_cvec;		/* Interrupt vector address */
	u_char	va_maskno;		/* Interrupt vector in mask */
	vaddr_t	va_dmaaddr;		/* DMA area address */
	vsize_t	va_dmasize;		/* DMA area size */
	bus_space_tag_t va_iot;
	bus_dma_tag_t va_dmat;
};

/*
 * Some chip addresses and constants, same on all VAXstations.
 */
#define VS_CFGTST	0x20020000      /* config register */
#define VS_REGS		0x20080000      /* Misc cpu internal regs */
#define VS_REGS_KA49	0x25c00000      /* ... same, on 512KB ROM systems */
#define NI_ADDR		0x20090000      /* Ethernet address */
#define DZ_CSR		0x200a0000      /* DZ11-compatible chip csr */
#define DZ_CSR_KA49	0x25000000      /* ... same, on 512KB ROM systems */
#define VS_CLOCK	0x200b0000      /* clock chip address */
#define SCA_REGS	0x200c0000      /* disk device addresses */
#define SCA_REGS_KA49	0x26000000      /* ... same, on 512KB ROM systems */
#define NI_BASE         0x200e0000      /* LANCE CSRs */
#define NI_IOSIZE       (128 * VAX_NBPG)    /* IO address size */

#define	KA49_SCSIMAP	0x27000000	/* KA49 SCSI SGMAP */
/*
 * Small monochrome graphics framebuffer, present on all machines.
 */
#define	SMADDR		0x30000000
#define	SMSIZE		0x20000		/* Actually 256k, only 128k used */

struct	vsbus_softc {
	struct	device sc_dev;
	u_char	*sc_intmsk;	/* Mask register */
	u_char	*sc_intclr;	/* Clear interrupt register */
	u_char	*sc_intreq;	/* Interrupt request register */
	u_char	sc_mask;	/* Interrupts to enable after autoconf */
	vaddr_t	sc_vsregs;	/* Where the VS_REGS are mapped */
	vaddr_t sc_dmaaddr;	/* Mass storage virtual DMA area */
	vsize_t sc_dmasize;	/* Size of the DMA area */

	struct vax_bus_dma_tag sc_dmatag;
	struct vax_sgmap sc_sgmap;
};

struct vsbus_dma {
	SIMPLEQ_ENTRY(vsbus_dma) vd_q;
	void (*vd_go)(void *);
	void *vd_arg;
};

#ifdef _KERNEL
void	vsbus_dma_init(struct vsbus_softc *, unsigned ptecnt);
u_char	vsbus_setmask(int);
void	vsbus_clrintr(int);
void	vsbus_copytoproc(struct proc *, caddr_t, caddr_t, int);
void	vsbus_copyfromproc(struct proc *, caddr_t, caddr_t, int);
void	vsbus_dma_start(struct vsbus_dma *);
void	vsbus_dma_intr(void);
#endif
#endif /* _MACHINE_VSBUS_H_ */
@


1.11
log
@Define symbolic constants for the addresses of the vsbus devices on
512KB PROM systems (e.g. KA49), or 256KB PROM systems built after KA49
(e.g. KA5[234]), and use them instead of pouring magic numbers all over the (md)
tree.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.10 2011/03/23 16:54:37 pirofti Exp $ */
@


1.10
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.9 2006/12/13 21:11:23 miod Exp $ */
d64 8
a71 5
#define VS_REGS         0x20080000      /* Misc cpu internal regs */
#define NI_ADDR         0x20090000      /* Ethernet address */
#define DZ_CSR          0x200a0000      /* DZ11-compatible chip csr */
#define VS_CLOCK        0x200b0000      /* clock chip address */
#define SCA_REGS        0x200c0000      /* disk device addresses */
@


1.9
log
@Remove unused parts of vsbus_attach_args structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.8 2004/07/07 23:10:45 deraadt Exp $ */
d41 2
a42 2
#ifndef _VAX_VSBUS_H_
#define _VAX_VSBUS_H_
d108 1
a108 1
#endif /* _VAX_VSBUS_H_ */
@


1.8
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.7 2002/03/14 01:26:48 millert Exp $ */
a46 40
struct confargs {
    char    ca_name[16];        /* device name */
    int ca_intslot;     /* device interrupt-slot */
    int ca_intpri;      /* device interrupt "priority" */
    int ca_intvec;      /* interrup-vector offset */
    int ca_intbit;      /* bit in interrupt-register */
    int ca_ioaddr;      /* device hardware I/O address */

    int ca_aux1;        /* additional info (DMA, etc.) */
    int ca_aux2;
    int ca_aux3;
    int ca_aux4;
    int ca_aux5;
    int ca_aux6;
    int ca_aux7;
    int ca_aux8;

#define ca_recvslot ca_intslot  /* DC/DZ: Receiver configuration */
#define ca_recvpri  ca_intpri
#define ca_recvvec  ca_intvec
#define ca_recvbit  ca_intbit
#define ca_xmitslot ca_aux1     /* DC/DZ: transmitter configuration */
#define ca_xmitpri  ca_aux2     /* DC/DZ:  */
#define ca_xmitvec  ca_aux3
#define ca_xmitbit  ca_aux4
#define ca_dcflags  ca_aux5

#define ca_dareg    ca_aux1     /* SCSI: DMA address register */
#define ca_dcreg    ca_aux2     /* SCSI: DMA byte count register */
#define ca_ddreg    ca_aux3     /* SCSI: DMA transfer direction */
#define ca_dbase    ca_aux4     /* SCSI: DMA buffer address */
#define ca_dsize    ca_aux5     /* SCSI: DMA buffer size */
#define ca_dflag    ca_aux6     /* SCSI: DMA flags (eg. shared) */
#define ca_idval    ca_aux7     /* SCSI: host-ID to use/set */
#define ca_idreg    ca_aux8     /* SCSI: host-ID port register */

#define ca_enaddr   ca_aux1     /* LANCE: Ethernet address in ROM */
#define ca_leflags  ca_aux2
};

a50 3
	void	(*va_ivec)(void *);	/* Interrupt routine */
	void	*va_vecarg;		/* Interrupt routine argument */

a57 1
	struct 	confargs *confargs;
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.6 2001/08/25 13:33:36 hugh Exp $ */
d95 1
a95 1
	short	va_cvec;		/* Interrupt vector address */
@


1.6
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.5 2000/10/09 23:11:57 bjc Exp $ */
d91 1
a91 1
	void	(*va_ivec) __P((void *));	/* Interrupt routine */
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.6 2001/08/25 13:33:36 hugh Exp $ */
d91 1
a91 1
	void	(*va_ivec)(void *);	/* Interrupt routine */
@


1.5
log
@code to get asc* (ncr 53c9x) working; most of this from netbsd
also, write the correct stuff in cpu_coredump (vm_machdep.c)
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.4 2000/04/27 07:19:57 bjc Exp $ */
a46 23
struct	vsbus_softc {
	struct	device sc_dev;
#if 0
	volatile struct vs_cpu *sc_cpu;
#endif
	u_char	*sc_intmsk;	/* Mask register */
	u_char	*sc_intclr;	/* Clear interrupt register */
	u_char	*sc_intreq;	/* Interrupt request register */
	u_char	sc_mask;	/* Interrupts to enable after autoconf */
	vaddr_t	sc_vsregs;	/* Where the VS_REGS are mapped */
	vaddr_t sc_dmaaddr;	/* Mass storage virtual DMA area */
	vsize_t sc_dmasize;	/* Size of the DMA area */

	struct vax_bus_dma_tag sc_dmatag;
	struct vax_sgmap sc_sgmap;
};

struct vsbus_dma {
	SIMPLEQ_ENTRY(vsbus_dma) vd_q;
	void (*vd_go)(void *);
	void *vd_arg;
};

d123 20
d144 7
a150 8
void	vsbus_dma_init __P((struct vsbus_softc *, unsigned ptecnt));
u_char	vsbus_setmask __P((unsigned char));
void	vsbus_clrintr __P((unsigned char));
void	vsbus_intr	__P((void *));
void	vsbus_copytoproc __P((struct proc *, caddr_t, caddr_t, int));
void	vsbus_copyfromproc __P((struct proc *, caddr_t, caddr_t, int));
void	vsbus_dma_start __P((struct vsbus_dma *));
void	vsbus_dma_intr __P((void));
@


1.4
log
@put vsbus_intr() prototype here so other vsbus devices can avail themselves
of its intentional uselessness; also some __P()
@
text
@d1 2
a2 2
/*	$OpenBSD: vsbus.h,v 1.3 2000/04/26 03:08:43 bjc Exp $ */
/*	$NetBSD: vsbus.h,v 1.9 1999/10/22 21:10:13 ragge Exp $ */
d45 1
d56 12
d120 3
d139 1
d146 2
d153 3
@


1.3
log
@vax resurrection, part 1: sync with early-april netbsd

many changes here, notable:  uvm, ansi.h, more (and cleaner) vsbus support
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.2 1997/05/29 00:04:57 niklas Exp $ */
d131 3
a133 2
void	vsbus_copytoproc(struct proc *, caddr_t, caddr_t, int);
void	vsbus_copyfromproc(struct proc *, caddr_t, caddr_t, int);
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: vsbus.h,v 1.1 1996/07/20 17:58:28 ragge Exp $ */
/*	$NetBSD: vsbus.h,v 1.1 1996/07/20 17:58:28 ragge Exp $ */
d40 17
d58 34
a91 34
	char	ca_name[16];		/* device name */
	int	ca_intslot;		/* device interrupt-slot */
	int	ca_intpri;		/* device interrupt "priority" */
	int	ca_intvec;		/* interrup-vector offset */
	int	ca_intbit;		/* bit in interrupt-register */
	int	ca_ioaddr;		/* device hardware I/O address */

	int	ca_aux1;		/* additional info (DMA, etc.) */
	int	ca_aux2;
	int	ca_aux3;
	int	ca_aux4;
	int	ca_aux5;
	int	ca_aux6;
	int	ca_aux7;
	int	ca_aux8;

#define ca_recvslot	ca_intslot	/* DC/DZ: Receiver configuration */
#define ca_recvpri	ca_intpri
#define ca_recvvec	ca_intvec
#define ca_recvbit	ca_intbit
#define ca_xmitslot	ca_aux1		/* DC/DZ: transmitter configuration */
#define ca_xmitpri	ca_aux2		/* DC/DZ:  */
#define ca_xmitvec	ca_aux3
#define ca_xmitbit	ca_aux4
#define ca_dcflags	ca_aux5

#define ca_dareg	ca_aux1		/* SCSI: DMA address register */
#define ca_dcreg	ca_aux2		/* SCSI: DMA byte count register */
#define ca_ddreg	ca_aux3		/* SCSI: DMA transfer direction */
#define ca_dbase	ca_aux4		/* SCSI: DMA buffer address */
#define ca_dsize	ca_aux5		/* SCSI: DMA buffer size */
#define ca_dflag	ca_aux6		/* SCSI: DMA flags (eg. shared) */
#define ca_idval	ca_aux7		/* SCSI: host-ID to use/set */
#define ca_idreg	ca_aux8		/* SCSI: host-ID port register */
d93 2
a94 2
#define ca_enaddr	ca_aux1		/* LANCE: Ethernet address in ROM */
#define ca_leflags	ca_aux2
d97 13
a109 4
int vsbus_intr_register __P((struct confargs *, int(*)(void*), void*));
int vsbus_intr_enable __P((struct confargs *));
int vsbus_intr_disable  __P((struct confargs *));
int vsbus_intr_unregister __P((struct confargs *));
d111 17
a127 2
int vsbus_lockDMA __P((struct confargs *));
int vsbus_unlockDMA __P((struct confargs *));
d129 5
@


1.2.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: vsbus.h,v 1.5 2000/10/09 23:11:57 bjc Exp $ */
/*	$NetBSD: vsbus.h,v 1.13 2000/06/25 16:00:46 ragge Exp $ */
a39 30

#ifndef _VAX_VSBUS_H_
#define _VAX_VSBUS_H_

#include <machine/bus.h>
#include <machine/sgmap.h>

struct	vsbus_softc {
	struct	device sc_dev;
#if 0
	volatile struct vs_cpu *sc_cpu;
#endif
	u_char	*sc_intmsk;	/* Mask register */
	u_char	*sc_intclr;	/* Clear interrupt register */
	u_char	*sc_intreq;	/* Interrupt request register */
	u_char	sc_mask;	/* Interrupts to enable after autoconf */
	vaddr_t	sc_vsregs;	/* Where the VS_REGS are mapped */
	vaddr_t sc_dmaaddr;	/* Mass storage virtual DMA area */
	vsize_t sc_dmasize;	/* Size of the DMA area */

	struct vax_bus_dma_tag sc_dmatag;
	struct vax_sgmap sc_sgmap;
};

struct vsbus_dma {
	SIMPLEQ_ENTRY(vsbus_dma) vd_q;
	void (*vd_go)(void *);
	void *vd_arg;
};

d41 34
a74 34
    char    ca_name[16];        /* device name */
    int ca_intslot;     /* device interrupt-slot */
    int ca_intpri;      /* device interrupt "priority" */
    int ca_intvec;      /* interrup-vector offset */
    int ca_intbit;      /* bit in interrupt-register */
    int ca_ioaddr;      /* device hardware I/O address */

    int ca_aux1;        /* additional info (DMA, etc.) */
    int ca_aux2;
    int ca_aux3;
    int ca_aux4;
    int ca_aux5;
    int ca_aux6;
    int ca_aux7;
    int ca_aux8;

#define ca_recvslot ca_intslot  /* DC/DZ: Receiver configuration */
#define ca_recvpri  ca_intpri
#define ca_recvvec  ca_intvec
#define ca_recvbit  ca_intbit
#define ca_xmitslot ca_aux1     /* DC/DZ: transmitter configuration */
#define ca_xmitpri  ca_aux2     /* DC/DZ:  */
#define ca_xmitvec  ca_aux3
#define ca_xmitbit  ca_aux4
#define ca_dcflags  ca_aux5

#define ca_dareg    ca_aux1     /* SCSI: DMA address register */
#define ca_dcreg    ca_aux2     /* SCSI: DMA byte count register */
#define ca_ddreg    ca_aux3     /* SCSI: DMA transfer direction */
#define ca_dbase    ca_aux4     /* SCSI: DMA buffer address */
#define ca_dsize    ca_aux5     /* SCSI: DMA buffer size */
#define ca_dflag    ca_aux6     /* SCSI: DMA flags (eg. shared) */
#define ca_idval    ca_aux7     /* SCSI: host-ID to use/set */
#define ca_idreg    ca_aux8     /* SCSI: host-ID port register */
d76 2
a77 2
#define ca_enaddr   ca_aux1     /* LANCE: Ethernet address in ROM */
#define ca_leflags  ca_aux2
d80 4
a83 16
struct	vsbus_attach_args {
	vaddr_t	va_addr;		/* virtual CSR address */
	paddr_t	va_paddr;		/* physical CSR address */

	void	(*va_ivec) __P((void *));	/* Interrupt routine */
	void	*va_vecarg;		/* Interrupt routine argument */

	short	va_br;			/* Interrupt level */
	short	va_cvec;		/* Interrupt vector address */
	u_char	va_maskno;		/* Interrupt vector in mask */
	vaddr_t	va_dmaaddr;		/* DMA area address */
	vsize_t	va_dmasize;		/* DMA area size */
	bus_space_tag_t va_iot;
	bus_dma_tag_t va_dmat;
	struct 	confargs *confargs;
};
d85 2
a86 18
/*
 * Some chip addresses and constants, same on all VAXstations.
 */
#define VS_CFGTST	0x20020000      /* config register */
#define VS_REGS         0x20080000      /* Misc cpu internal regs */
#define NI_ADDR         0x20090000      /* Ethernet address */
#define DZ_CSR          0x200a0000      /* DZ11-compatible chip csr */
#define VS_CLOCK        0x200b0000      /* clock chip address */
#define SCA_REGS        0x200c0000      /* disk device addresses */
#define NI_BASE         0x200e0000      /* LANCE CSRs */
#define NI_IOSIZE       (128 * VAX_NBPG)    /* IO address size */

#define	KA49_SCSIMAP	0x27000000	/* KA49 SCSI SGMAP */
/*
 * Small monochrome graphics framebuffer, present on all machines.
 */
#define	SMADDR		0x30000000
#define	SMSIZE		0x20000		/* Actually 256k, only 128k used */
a87 11
#ifdef _KERNEL
void	vsbus_dma_init __P((struct vsbus_softc *, unsigned ptecnt));
u_char	vsbus_setmask __P((unsigned char));
void	vsbus_clrintr __P((unsigned char));
void	vsbus_intr	__P((void *));
void	vsbus_copytoproc __P((struct proc *, caddr_t, caddr_t, int));
void	vsbus_copyfromproc __P((struct proc *, caddr_t, caddr_t, int));
void	vsbus_dma_start __P((struct vsbus_dma *));
void	vsbus_dma_intr __P((void));
#endif
#endif /* _VAX_VSBUS_H_ */
@


1.2.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vsbus.h,v 1.2.12.1 2001/05/14 21:38:10 niklas Exp $ */
d47 23
a145 20
struct	vsbus_softc {
	struct	device sc_dev;
	u_char	*sc_intmsk;	/* Mask register */
	u_char	*sc_intclr;	/* Clear interrupt register */
	u_char	*sc_intreq;	/* Interrupt request register */
	u_char	sc_mask;	/* Interrupts to enable after autoconf */
	vaddr_t	sc_vsregs;	/* Where the VS_REGS are mapped */
	vaddr_t sc_dmaaddr;	/* Mass storage virtual DMA area */
	vsize_t sc_dmasize;	/* Size of the DMA area */

	struct vax_bus_dma_tag sc_dmatag;
	struct vax_sgmap sc_sgmap;
};

struct vsbus_dma {
	SIMPLEQ_ENTRY(vsbus_dma) vd_q;
	void (*vd_go)(void *);
	void *vd_arg;
};

d147 8
a154 7
void	vsbus_dma_init(struct vsbus_softc *, unsigned ptecnt);
u_char	vsbus_setmask(int);
void	vsbus_clrintr(int);
void	vsbus_copytoproc(struct proc *, caddr_t, caddr_t, int);
void	vsbus_copyfromproc(struct proc *, caddr_t, caddr_t, int);
void	vsbus_dma_start(struct vsbus_dma *);
void	vsbus_dma_intr(void);
@


1.2.12.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d91 1
a91 1
	void	(*va_ivec)(void *);	/* Interrupt routine */
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
