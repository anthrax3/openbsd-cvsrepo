head	1.39;
access;
symbols
	OPENBSD_5_9:1.38.0.8
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.10
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.8
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.4
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.6
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.4
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.10
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.8
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.38;
commitid	OSDG2O3Cgeifnf1W;

1.38
date	2014.01.30.18.16.41;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2013.11.24.22.08.23;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2013.07.05.21.10.50;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2013.07.01.19.45.26;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.26.04.58.05;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2012.11.25.22.13.46;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.30.20.45.31;	author martin;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.15.17.24.07;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.22.10.05.51;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.01.01.08.57;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.06.22.21.30;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.29.06.07.04;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.06.22.39.14;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.13.14.51.29;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.09.20.17.24;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.20.09.20.42;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.12.12.50.47;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.10.18.29.44;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.04.23.22.42;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.28.15.34.17;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.18.20.50.18;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.15.22.45.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.16.17.29.40;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.26.03.08.42;	author bjc;	state Exp;
branches;
next	1.8;

1.8
date	98.03.01.12.09.02;	author maja;	state Exp;
branches
	1.8.10.1;
next	1.7;

1.7
date	98.03.01.00.37.49;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.09.12.09.21.22;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.00.04.46;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.24.43;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.09.43;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.07;	author deraadt;	state Exp;
branches;
next	;

1.8.10.1
date	2001.05.14.21.38.03;	author niklas;	state Exp;
branches;
next	1.8.10.2;

1.8.10.2
date	2001.07.04.10.24.28;	author niklas;	state Exp;
branches;
next	1.8.10.3;

1.8.10.3
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.8.10.4;

1.8.10.4
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.8.10.5;

1.8.10.5
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.8.10.6;

1.8.10.6
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.8.10.7;

1.8.10.7
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	1.8.10.8;

1.8.10.8
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	1.8.10.9;

1.8.10.9
date	2004.06.05.23.11.02;	author niklas;	state Exp;
branches;
next	1.8.10.10;

1.8.10.10
date	2004.06.10.11.40.31;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.39
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*      $OpenBSD: pmap.h,v 1.38 2014/01/30 18:16:41 miod Exp $     */
/*	$NetBSD: pmap.h,v 1.37 1999/08/01 13:48:07 ragge Exp $	   */

/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991 Regents of the University of California.
 * All rights reserved.
 *
 * Changed for the VAX port. /IC
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	7.6 (Berkeley) 5/10/91
 */


#ifndef _MACHINE_PMAP_H_
#define _MACHINE_PMAP_H_

#ifdef _KERNEL

#include <machine/pte.h>
#include <machine/mtpr.h>
#include <machine/pcb.h>

/*
 * Some constants to make life easier.
 */
#define LTOHPS		(PAGE_SHIFT - VAX_PGSHIFT)
#define LTOHPN		(1 << LTOHPS)

/*
 * Pmap structure
 */

struct pmap {
	pt_entry_t	*pm_p1ap;	/* Base of alloced p1 pte space */
	u_int		 pm_count;	/* reference count */
	struct pcb	*pm_pcbs;	/* PCBs using this pmap */
	pt_entry_t	*pm_p0br;	/* page 0 base register */
	u_long		 pm_p0lr;	/* page 0 length register */
	pt_entry_t	*pm_p1br;	/* page 1 base register */
	u_long		 pm_p1lr;	/* page 1 length register */
	struct pmap_statistics	 pm_stats;	/* Some statistics */
};

typedef struct pmap *pmap_t;

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry_t.
 */

struct pv_entry {
	struct pv_entry *pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap this entry belongs to */
	vaddr_t		 pv_va;		/* address of the virtual mapping */
};

extern	struct pmap kernel_pmap_store;

#define pmap_kernel()			(&kernel_pmap_store)

/*
 * Real nice (fast) routines to get the virtual address of a physical page
 * (and vice versa).
 */
#define pmap_map_direct(pg)	(VM_PAGE_TO_PHYS(pg) | KERNBASE)
#define pmap_unmap_direct(va)	PHYS_TO_VM_PAGE((va) & ~KERNBASE)
#define	__HAVE_PMAP_DIRECT

#define PMAP_STEAL_MEMORY

/*
 * This is the by far most used pmap routine. Make it inline.
 */

/* Routines that are best to define as macros */
#define pmap_copy(a,b,c,d,e)		/* Dont do anything */
#define pmap_collect(pm)		/* nothing */
#define pmap_update(pm)			/* nothing */
#define pmap_remove(pmap, start, slut)	pmap_protect(pmap, start, slut, 0)
#define pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_reference(pmap)		(pmap)->pm_count++

/* These can be done as efficient inline macros */
#define pmap_copy_page(srcpg, dstpg) do {				\
	paddr_t __src = VM_PAGE_TO_PHYS(srcpg);				\
	paddr_t __dst = VM_PAGE_TO_PHYS(dstpg);				\
	__asm__("addl3 $0x80000000,%0,%%r0;addl3 $0x80000000,%1,%%r1;	\
	    movc3 $4096,(%%r0),(%%r1)"					\
	    :: "r"(__src),"r"(__dst):"r0","r1","r2","r3","r4","r5");	\
} while (0)

#define pmap_zero_page(pg) do {						\
	paddr_t __pa = VM_PAGE_TO_PHYS(pg);				\
	__asm__("addl3 $0x80000000,%0,%%r0;movc5 $0,(%%r0),$0,$4096,(%%r0)" \
	    :: "r"(__pa): "r0","r1","r2","r3","r4","r5");		\
} while (0)

#define pmap_proc_iflush(p,va,len)	/* nothing */
#define pmap_unuse_final(p)		/* nothing */

/* Prototypes */
void	pmap_bootstrap(void);
vaddr_t pmap_map(vaddr_t, paddr_t, paddr_t, int);
void	pmap_pinit(pmap_t);

#endif	/* _KERNEL */

struct vm_page_md {
	struct pv_entry *pv_head;
	int		 pv_attr;	/* write/modified bits */
};

#define	VM_MDPAGE_INIT(pg) \
	do { \
		(pg)->mdpage.pv_head = NULL; \
		(pg)->mdpage.pv_attr = 0; \
	} while (0)

#endif /* _MACHINE_PMAP_H_ */
@


1.38
log
@Move declaration of struct vm_page_md from <machine/vmparam.h> to
<machine/pmap.h> where it belongs, and compensate in <uvm/uvm_extern.h>
by including <uvm/uvm_pmap.h> before <uvm/uvm_page.h>. Tested on all
MACHINE_ARCH but amd64 and i386 (and hppa64).
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.37 2013/11/24 22:08:23 miod Exp $     */
@


1.37
log
@Rework pmap to use dynamic P0 and P1 region allocation, instead of allocating
the largest possible page table for every pmap; from NetBSD. This allows the
kernel to use much less memory for page tables.

Significant differences against the NetBSD code are:
- allocation of page table pages is done with a pool instead of allocating
  whole logical pages from uvm and managing the freelist within pmap, never
  releasing allocated pages.
- try to use pt_entry_t * rather than int * whenever possible.
- growth of P0 and P1 regions is allowed to fail, if invoked from
  pmap_enter with the PMAP_CANFAIL flag. This will stall processes until
  memory for the page tables can be obtained, rather than panicing, in
  most cases.
- keep management of mappings for managed pages using pv lists tied to the
  vm_page (using __HAVE_VM_PAGE_MD), rather than a global pv_list head.
- bound check against Sysmap[] in pmap_extract() when asked for a kernel
  address.

As a result of this, bsd.rd can now install a working system on a 12MB machine
without needing to enable swap.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.36 2013/07/05 21:10:50 miod Exp $     */
d137 11
@


1.36
log
@VAX ELF userland bits. Consists mostly of register prefix additions.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.35 2013/07/01 19:45:26 miod Exp $     */
a56 2
#define USRPTSIZE ((MAXTSIZ + MAXDSIZ + BRKSIZ + MAXSSIZ) / VAX_NBPG)
#define	NPTEPGS	(USRPTSIZE / (sizeof(pt_entry_t) * LTOHPN))
a59 1
 *  pm_stack holds lowest allocated memory for the process stack.
d62 4
a65 3
typedef struct pmap {
	vaddr_t	pm_stack;	/* Base of alloced p1 pte space */
	int		 ref_count;	/* reference count	  */
d67 1
a67 1
	long		 pm_p0lr;	/* page 0 length register */
d69 1
a69 2
	long		 pm_p1lr;	/* page 1 length register */
	int		 pm_lock;	/* Lock entry in MP environment */
d71 3
a73 2
	u_char		 pm_refcnt[NPTEPGS];	/* Refcount per pte page */
} *pmap_t;
a81 1
	pt_entry_t	*pv_pte;	/* pte for this physical page */
d83 1
a85 9
/* Mapping macros used when allocating SPT */
#define MAPVIRT(ptr, count)					\
	ptr = virtual_avail;				\
	virtual_avail += (count) * VAX_NBPG;

#define MAPPHYS(ptr, count, perm)				\
	ptr = avail_start + KERNBASE;			\
	avail_start += (count) * VAX_NBPG;

d95 1
a95 1
#define pmap_unmap_direct(va) PHYS_TO_VM_PAGE((va) & ~KERNBASE)
d106 1
a107 1
#define pmap_collect(pmap)		/* No need so far */
d110 2
a111 2
#define pmap_deactivate(p)		/* Dont do anything */
#define pmap_reference(pmap)		(pmap)->ref_count++
@


1.35
log
@Replace magic number in USRPTSIZE with the proper computation based upon
various userland size limits.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.34 2013/03/26 04:58:05 deraadt Exp $     */
d128 2
a129 2
	__asm__("addl3 $0x80000000,%0,r0;addl3 $0x80000000,%1,r1;	\
	    movc3 $4096,(r0),(r1)"					\
d135 1
a135 1
	__asm__("addl3 $0x80000000,%0,r0;movc5 $0,(r0),$0,$4096,(r0)"	\
@


1.34
log
@maybe the last PGSHIFT -> PAGE_SHIFT
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.33 2012/11/25 22:13:46 jsg Exp $     */
d57 1
a57 1
#define USRPTSIZE ((MAXTSIZ + 40*1024*1024 + MAXSSIZ) / VAX_NBPG)
@


1.33
log
@remove the use of cast as lvalue which is verboten with newer gcc
tweaks from/tested by/ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.32 2011/03/23 16:54:37 pirofti Exp $     */
d55 1
a55 1
#define LTOHPS		(PGSHIFT - VAX_PGSHIFT)
@


1.32
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.31 2010/12/26 15:41:00 miod Exp $     */
d90 1
a90 1
	(vaddr_t)ptr = virtual_avail;				\
d94 1
a94 1
	(paddr_t)ptr = avail_start + KERNBASE;			\
@


1.31
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.30 2008/08/30 20:45:31 martin Exp $     */
d43 2
a44 2
#ifndef PMAP_H
#define PMAP_H
d149 1
a149 1
#endif /* PMAP_H */
@


1.30
log
@replace TRUNC_PAGE by trunc_page and ROUND_PAGE by round_page
plus cast to vaddr_t where necassary

from Miod's todo list

ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.29 2007/12/15 17:24:07 deraadt Exp $     */
a115 1
#define pmap_phys_address(phys)		((u_int)(phys) << PGSHIFT)
@


1.29
log
@Remove a lot of symbols from the namespace, otherwise sys/sysctl.h and
rpc/pmap_prot.h collide.. "struct pmap" from the kernel should not make
it out to userland.
ok miod
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.28 2007/04/22 10:05:51 miod Exp $     */
a86 4

/* ROUND_PAGE used before vm system is initialized */
#define ROUND_PAGE(x)	(((uint)(x) + PGOFSET) & ~PGOFSET)
#define TRUNC_PAGE(x)	((uint)(x) & ~PGOFSET)
@


1.28
log
@Switch the vax pmap to __HAVE_VM_PAGE_MD.

pv_entry head of lists are no longer preallocated at boot, and will only be
allocated for managed pages (instead of all physical memory pages, including
those containing the kernel).

pmap and pv_entry will now be allocated from a pool, instead of malloc for the
former and a homegrown allocator which never relinquishes unused elements to
the VM system for the latter.

The net result is a slight decrease in memory usage, and better behaviour in
low-memory conditions.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.27 2006/01/01 01:08:57 millert Exp $     */
d46 2
a99 2

#ifdef	_KERNEL
@


1.27
log
@Don't need to include machine/types.h here.  OK and tested by miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.26 2005/11/06 22:21:30 miod Exp $     */
d77 1
a77 1
 * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.
a83 1
	int		 pv_attr;	/* write/modified bits */
@


1.26
log
@Kill deprecated vm_offset_t and vm_size_t types on vax.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.25 2005/06/29 06:07:04 deraadt Exp $     */
a45 1
#include <machine/types.h>
@


1.25
log
@40MB virtual address space in p0; start mmap's 8MB into the data segment
ok tdeval
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.24 2004/08/06 22:39:14 deraadt Exp $     */
d94 1
a94 1
	(vm_offset_t)ptr = virtual_avail;			\
d98 1
a98 1
	(vm_offset_t)ptr = avail_start + KERNBASE;		\
d151 1
a151 1
vaddr_t pmap_map(vm_offset_t, vm_offset_t, vm_offset_t, int);
@


1.24
log
@rename sparc kill_user_windows() to pmap_unuse_final().  provide empty stubs
on all other architectures.  remove last architecture dependent #ifdef from
uvm code.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.23 2004/07/13 14:51:29 tedu Exp $     */
d56 1
a56 1
#define USRPTSIZE ((MAXTSIZ + MAXDSIZ + MAXSSIZ + MMAPSPACE) / VAX_NBPG)
@


1.23
log
@#define __HAVE_PMAP_DIRECT and use it.  requested by art
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.22 2004/06/09 20:17:24 tedu Exp $     */
d147 1
@


1.22
log
@rename POOLPAGE macros to pmap_map_direct
break out uvm_km_page bits for this case, no thread here
lots of testing tech@@, deraadt@@, naddy@@, mickey@@, ...
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.21 2004/05/20 09:20:42 kettenis Exp $     */
d113 1
@


1.21
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.20 2003/11/10 21:05:06 miod Exp $     */
d111 2
a112 2
#define PMAP_MAP_POOLPAGE(pg)	(VM_PAGE_TO_PHYS(pg) | KERNBASE)
#define PMAP_UNMAP_POOLPAGE(va) PHYS_TO_VM_PAGE((va) & ~KERNBASE)
@


1.20
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.19 2003/06/02 23:27:57 millert Exp $     */
d144 2
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.18 2002/09/12 12:50:47 art Exp $     */
d57 1
a57 1
#define	NPTEPGS	(USRPTSIZE / (sizeof(struct pte) * LTOHPN))
d67 1
a67 1
	struct pte	*pm_p0br;	/* page 0 base register */
d69 1
a69 1
	struct pte	*pm_p1br;	/* page 1 base register */
d83 1
a83 1
	struct pte	*pv_pte;	/* pte for this physical page */
@


1.18
log
@Change the PMAP_{MAP,UNMAP}_POOLPAGE api to take a vm_page as argument
and return a VM_PAGE. This is to allow sparc64 to cheaply record the
VAC color for those pages.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.17 2002/09/10 18:29:44 art Exp $     */
d23 1
a23 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@Change the pmap_zero_page and pmap_copy_page API to take the struct vm_page *
instead of the pa. Most callers already had it handy and those who didn't
only called it for managed pages and were outside time-critical code.

This will allow us to make those functions clean and fast on sparc and
sparc64 letting us to avoid unnecessary cache flushes.

deraadt@@ miod@@ drahn@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.16 2002/03/14 01:26:48 millert Exp $     */
d115 2
a116 2
#define PMAP_MAP_POOLPAGE(pa)	((pa) | KERNBASE)
#define PMAP_UNMAP_POOLPAGE(va) ((va) & ~KERNBASE)
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.15 2001/12/04 23:22:42 art Exp $     */
d135 3
a137 1
#define pmap_copy_page(src, dst)				\
d139 9
a147 6
	    movc3 $4096,(r0),(r1)"				\
	    :: "r"(src),"r"(dst):"r0","r1","r2","r3","r4","r5");

#define pmap_zero_page(phys)					\
	__asm__("addl3 $0x80000000,%0,r0;movc5 $0,(r0),$0,$4096,(r0)" \
	    :: "r"(phys): "r0","r1","r2","r3","r4","r5");
@


1.15
log
@Yet another sync to NetBSD uvm.
Today we add a pmap argument to pmap_update() and allocate map entries for
kernel_map from kmem_map instead of using the static entries. This should
get rid of MAX_KMAPENT panics. Also some uvm_loan problems are fixed.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.14 2001/11/28 15:34:17 art Exp $     */
d145 3
a147 3
void	pmap_bootstrap __P((void));
vaddr_t pmap_map __P((vm_offset_t, vm_offset_t, vm_offset_t, int));
void	pmap_pinit __P((pmap_t));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.15 2001/12/04 23:22:42 art Exp $     */
d145 3
a147 3
void	pmap_bootstrap(void);
vaddr_t pmap_map(vm_offset_t, vm_offset_t, vm_offset_t, int);
void	pmap_pinit(pmap_t);
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.15.2.1 2002/06/11 03:39:19 art Exp $     */
d115 2
a116 2
#define PMAP_MAP_POOLPAGE(pg)	(VM_PAGE_TO_PHYS(pg) | KERNBASE)
#define PMAP_UNMAP_POOLPAGE(va) PHYS_TO_VM_PAGE((va) & ~KERNBASE)
d135 1
a135 3
#define pmap_copy_page(srcpg, dstpg) do {				\
	paddr_t __src = VM_PAGE_TO_PHYS(srcpg);				\
	paddr_t __dst = VM_PAGE_TO_PHYS(dstpg);				\
d137 6
a142 9
	    movc3 $4096,(r0),(r1)"					\
	    :: "r"(__src),"r"(__dst):"r0","r1","r2","r3","r4","r5");	\
} while (0)

#define pmap_zero_page(pg) do {						\
	paddr_t __pa = VM_PAGE_TO_PHYS(pg);				\
	__asm__("addl3 $0x80000000,%0,r0;movc5 $0,(r0),$0,$4096,(r0)"	\
	    :: "r"(__pa): "r0","r1","r2","r3","r4","r5");		\
} while (0)
@


1.14
log
@Make pmap_update functions into nops so that we can have a consistent
pmap_update API (right now it's nop).
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.13 2001/08/18 20:50:18 art Exp $     */
d127 1
a127 1
#define pmap_update()			/* nothing */
@


1.13
log
@Move pmap_{de,}activate to vm/pmap.h, it's same on all archs.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.12 2001/08/12 12:03:03 heko Exp $     */
d127 1
a127 1
#define pmap_update()	mtpr(0,PR_TBIA) /* Update buffes */
@


1.12
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.11 2001/06/15 22:45:33 miod Exp $     */
a147 1
void	pmap_activate __P((struct proc *));
@


1.11
log
@Compile kernel with -Wall, and fix a few issues for this to work.
ok hugh@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.10 2001/05/16 17:29:40 hugh Exp $     */
d152 1
a152 1
#endif PMAP_H
@


1.10
log
@Fix vax to work with recent pmap_change_wiring() -> pmap_unwire()
changes. Mostly from NetBSD.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.9 2000/04/26 03:08:42 bjc Exp $     */
d148 1
@


1.9
log
@vax resurrection, part 1: sync with early-april netbsd

many changes here, notable:  uvm, ansi.h, more (and cleaner) vsbus support
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.8 1998/03/01 12:09:02 maja Exp $     */
a125 1
#define pmap_unwire(pmap, v)		/* no need */
@


1.8
log
@Make kernel compilable. -moj
@
text
@d1 2
a2 2
/*      $OpenBSD: pmap.h,v 1.7 1998/03/01 00:37:49 niklas Exp $     */
/*      $NetBSD: pmap.h,v 1.19 1997/07/06 22:38:29 ragge Exp $     */
d47 2
a48 2
#ifndef	PMAP_H
#define	PMAP_H
d50 2
d53 1
d55 7
a61 3

#define VAX_PAGE_SIZE	NBPG
#define VAX_SEG_SIZE	NBSEG
d64 2
a65 4
 *  Pmap structure
 *
 * p0br == PR_P0BR in user struct, p0br is also == SBR in pmap_kernel()
 * p1br is the same for stack space, stack is base of alloced pte mem
d69 9
a77 5
	vm_offset_t		 pm_stack; /* Base of alloced p1 pte space */
	struct pcb		*pm_pcb; /* Pointer to PCB for this pmap */
	int                      ref_count;   /* reference count        */
	struct pmap_statistics   stats;       /* statistics             */
	simple_lock_data_t       pm_lock;     /* lock on pmap           */
d85 6
a90 10
typedef struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;/* if not NULL, pmap where mapping lies */
	vm_offset_t	 pv_va;		/* virtual address for mapping */
	int		 pv_flags;	/* flags */
} *pv_entry_t;

#define	PV_REF	0x00000001	/* Simulated phys ref bit */

#define PHYS_TO_PV(phys_page) (&pv_table[((phys_page)>>PAGE_SHIFT)])
d93 2
a94 2
#define ROUND_PAGE(x)   (((uint)(x) + PAGE_SIZE-1)& ~(PAGE_SIZE - 1))
#define	TRUNC_PAGE(x)	((uint)(x) & ~(PAGE_SIZE - 1))
d97 1
a97 1
#define	MAPVIRT(ptr, count)					\
d99 1
a99 1
	virtual_avail += (count) * NBPG;
d101 3
a103 6
#define	MAPPHYS(ptr, count, perm)				\
	pmap_map(virtual_avail, avail_start, avail_start +	\
	    (count) * NBPG, perm);				\
	(vm_offset_t)ptr = virtual_avail;			\
	virtual_avail += (count) * NBPG;				\
	avail_start += (count) * NBPG;
a105 2
#define pa_index(pa)	                atop(pa)
#define pa_to_pvh(pa)	                (&pv_table[atop(pa)])
d109 1
a109 1
#define	pmap_kernel()			(&kernel_pmap_store)
d111 12
a122 1
#endif	/* _KERNEL */
d125 19
a143 7
#define	pmap_copy(a,b,c,d,e) 		/* Dont do anything */
#define	pmap_update()	mtpr(0,PR_TBIA)	/* Update buffes */
#define	pmap_pageable(a,b,c,d)		/* Dont do anything */
#define	pmap_collect(pmap)		/* No need so far */
#define	pmap_reference(pmap)	if(pmap) (pmap)->ref_count++
#define	pmap_pinit(pmap)	(pmap)->ref_count=1;
#define	pmap_phys_address(phys) ((u_int)(phys)<<PAGE_SHIFT)
d147 5
a151 3
vm_offset_t pmap_map __P((vm_offset_t, vm_offset_t, vm_offset_t, int));
void	pmap_expandp0 __P((struct pmap *, int));
void	pmap_expandp1 __P((struct pmap *));
@


1.8.10.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*      $OpenBSD: pmap.h,v 1.9 2000/04/26 03:08:42 bjc Exp $     */
/*	$NetBSD: pmap.h,v 1.37 1999/08/01 13:48:07 ragge Exp $	   */
d47 2
a48 2
#ifndef PMAP_H
#define PMAP_H
a49 2
#include <machine/types.h>
#include <machine/pte.h>
a50 1
#include <machine/pcb.h>
d52 3
a54 7
/*
 * Some constants to make life easier.
 */
#define LTOHPS		(PGSHIFT - VAX_PGSHIFT)
#define LTOHPN		(1 << LTOHPS)
#define USRPTSIZE ((MAXTSIZ + MAXDSIZ + MAXSSIZ + MMAPSPACE) / VAX_NBPG)
#define	NPTEPGS	(USRPTSIZE / (sizeof(struct pte) * LTOHPN))
d57 4
a60 2
 * Pmap structure
 *  pm_stack holds lowest allocated memory for the process stack.
d64 5
a68 9
	vaddr_t	pm_stack;	/* Base of alloced p1 pte space */
	int		 ref_count;	/* reference count	  */
	struct pte	*pm_p0br;	/* page 0 base register */
	long		 pm_p0lr;	/* page 0 length register */
	struct pte	*pm_p1br;	/* page 1 base register */
	long		 pm_p1lr;	/* page 1 length register */
	int		 pm_lock;	/* Lock entry in MP environment */
	struct pmap_statistics	 pm_stats;	/* Some statistics */
	u_char		 pm_refcnt[NPTEPGS];	/* Refcount per pte page */
d76 10
a85 6
struct pv_entry {
	struct pv_entry *pv_next;	/* next pv_entry */
	struct pte	*pv_pte;	/* pte for this physical page */
	struct pmap	*pv_pmap;	/* pmap this entry belongs to */
	int		 pv_attr;	/* write/modified bits */
};
d88 2
a89 2
#define ROUND_PAGE(x)	(((uint)(x) + PGOFSET) & ~PGOFSET)
#define TRUNC_PAGE(x)	((uint)(x) & ~PGOFSET)
d92 1
a92 1
#define MAPVIRT(ptr, count)					\
d94 1
a94 1
	virtual_avail += (count) * VAX_NBPG;
d96 6
a101 3
#define MAPPHYS(ptr, count, perm)				\
	(vm_offset_t)ptr = avail_start + KERNBASE;		\
	avail_start += (count) * VAX_NBPG;
d104 2
d109 1
a109 1
#define pmap_kernel()			(&kernel_pmap_store)
d111 1
a111 12
/*
 * Real nice (fast) routines to get the virtual address of a physical page
 * (and vice versa).
 */
#define PMAP_MAP_POOLPAGE(pa)	((pa) | KERNBASE)
#define PMAP_UNMAP_POOLPAGE(va) ((va) & ~KERNBASE)

#define PMAP_STEAL_MEMORY

/*
 * This is the by far most used pmap routine. Make it inline.
 */
d114 7
a120 19
#define pmap_phys_address(phys)		((u_int)(phys) << PGSHIFT)
#define pmap_unwire(pmap, v)		/* no need */
#define pmap_copy(a,b,c,d,e)		/* Dont do anything */
#define pmap_update()	mtpr(0,PR_TBIA) /* Update buffes */
#define pmap_collect(pmap)		/* No need so far */
#define pmap_remove(pmap, start, slut)	pmap_protect(pmap, start, slut, 0)
#define pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define pmap_deactivate(p)		/* Dont do anything */
#define pmap_reference(pmap)		(pmap)->ref_count++

/* These can be done as efficient inline macros */
#define pmap_copy_page(src, dst)				\
	__asm__("addl3 $0x80000000,%0,r0;addl3 $0x80000000,%1,r1;	\
	    movc3 $4096,(r0),(r1)"				\
	    :: "r"(src),"r"(dst):"r0","r1","r2","r3","r4","r5");

#define pmap_zero_page(phys)					\
	__asm__("addl3 $0x80000000,%0,r0;movc5 $0,(r0),$0,$4096,(r0)" \
	    :: "r"(phys): "r0","r1","r2","r3","r4","r5");
d124 3
a126 5
vaddr_t pmap_map __P((vm_offset_t, vm_offset_t, vm_offset_t, int));
void	pmap_pinit __P((pmap_t));

#endif	/* _KERNEL */

@


1.8.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.8.10.1 2001/05/14 21:38:03 niklas Exp $     */
d126 1
a148 1
void	pmap_activate __P((struct proc *));
@


1.8.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.8.10.2 2001/07/04 10:24:28 niklas Exp $     */
d148 1
d152 1
a152 1
#endif /* PMAP_H */
@


1.8.10.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d127 1
a127 1
#define pmap_update(pm)			/* nothing */
@


1.8.10.5
log
@Merge in -current from about a week ago
@
text
@d145 3
a147 3
void	pmap_bootstrap(void);
vaddr_t pmap_map(vm_offset_t, vm_offset_t, vm_offset_t, int);
void	pmap_pinit(pmap_t);
@


1.8.10.6
log
@Sync the SMP branch with 3.3
@
text
@d115 2
a116 2
#define PMAP_MAP_POOLPAGE(pg)	(VM_PAGE_TO_PHYS(pg) | KERNBASE)
#define PMAP_UNMAP_POOLPAGE(va) PHYS_TO_VM_PAGE((va) & ~KERNBASE)
d135 1
a135 3
#define pmap_copy_page(srcpg, dstpg) do {				\
	paddr_t __src = VM_PAGE_TO_PHYS(srcpg);				\
	paddr_t __dst = VM_PAGE_TO_PHYS(dstpg);				\
d137 2
a138 3
	    movc3 $4096,(r0),(r1)"					\
	    :: "r"(__src),"r"(__dst):"r0","r1","r2","r3","r4","r5");	\
} while (0)
d140 3
a142 5
#define pmap_zero_page(pg) do {						\
	paddr_t __pa = VM_PAGE_TO_PHYS(pg);				\
	__asm__("addl3 $0x80000000,%0,r0;movc5 $0,(r0),$0,$4096,(r0)"	\
	    :: "r"(__pa): "r0","r1","r2","r3","r4","r5");		\
} while (0)
@


1.8.10.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.8.10.6 2003/03/27 23:52:19 niklas Exp $     */
d23 5
a27 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.10.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d57 1
a57 1
#define	NPTEPGS	(USRPTSIZE / (sizeof(pt_entry_t) * LTOHPN))
d67 1
a67 1
	pt_entry_t	*pm_p0br;	/* page 0 base register */
d69 1
a69 1
	pt_entry_t	*pm_p1br;	/* page 1 base register */
d83 1
a83 1
	pt_entry_t	*pv_pte;	/* pte for this physical page */
@


1.8.10.9
log
@Merge with the trunk
@
text
@a144 2
#define pmap_proc_iflush(p,va,len)	/* nothing */

@


1.8.10.10
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d111 2
a112 2
#define pmap_map_direct(pg)	(VM_PAGE_TO_PHYS(pg) | KERNBASE)
#define pmap_unmap_direct(va) PHYS_TO_VM_PAGE((va) & ~KERNBASE)
@


1.7
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.6 1997/09/12 09:21:22 maja Exp $     */
d68 1
a68 1
	simple_lock_data_t       lock;        /* lock on pmap           */
@


1.6
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*      $OpenBSD: pmap.h,v 1.5 1997/05/29 00:04:46 niklas Exp $     */
d124 1
@


1.5
log
@RCS tagging
@
text
@d1 2
a2 2
/*      $OpenBSD: pmap.h,v 1.17 1996/07/20 17:58:22 ragge Exp $     */
/*      $NetBSD: pmap.h,v 1.17 1996/07/20 17:58:22 ragge Exp $     */
@


1.4
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.3
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*      $NetBSD: pmap.h,v 1.16 1996/04/08 18:35:51 ragge Exp $     */
d88 1
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*      $NetBSD: pmap.h,v 1.11 1995/11/12 14:41:41 ragge Exp $     */
d49 1
a49 1
#include "machine/mtpr.h"
a101 4
pv_entry_t	pv_table;		/* array of entries, 
					   one per LOGICAL page */
struct pmap	kernel_pmap_store;

d105 2
d118 1
a118 1
#define	pmap_phys_address(phys) ((u_int)(phys)<<PAGE_SIZE)
d120 4
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: pmap.h,v 1.10 1995/05/11 16:53:14 jtc Exp $     */
d85 15
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

