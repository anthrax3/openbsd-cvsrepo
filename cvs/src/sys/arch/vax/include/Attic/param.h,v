head	1.43;
access;
symbols
	OPENBSD_5_9:1.42.0.8
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.10
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.6
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.37.0.6
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.4
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.2
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.34.0.10
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.8
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.4
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.33.0.6
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.24
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.12
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.10
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.8
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.6
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.42;
commitid	OSDG2O3Cgeifnf1W;

1.42
date	2013.11.24.22.15.24;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2013.06.13.05.12.51;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.26.05.04.10;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.25.17.46.24;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.23.16.12.28;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2011.09.08.03.40.32;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.07.15.45.18;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.14.11.41.30;	author martin;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.28.21.02.49;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.30.21.25.28;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.19.01.47.24;	author martin;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.12.03.14.37;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.08.15.05.56;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.19.15.29.48;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.06.22.31.31;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.19.22.55.51;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.06.21.38.26;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.29.07.35.24;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.05.01.57.15;	author provos;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.07.06.02.07.44;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.24.17.05.39;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.13.07.38.47;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.13.02.37.30;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.10.22.46.52;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.09.15.31.27;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.05.20.56.56;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.09.22.55.35;	author bjc;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.26.03.08.42;	author bjc;	state Exp;
branches;
next	1.11;

1.11
date	97.10.02.22.55.43;	author niklas;	state Exp;
branches
	1.11.12.1;
next	1.10;

1.10
date	97.10.02.15.44.40;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.09.12.09.21.22;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	97.09.10.11.47.09;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.01.16.14.26.25;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.24.42;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.12.11.11.13.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.09.09.42;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.13.38.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.07;	author deraadt;	state Exp;
branches;
next	;

1.11.12.1
date	2001.05.14.21.38.02;	author niklas;	state Exp;
branches;
next	1.11.12.2;

1.11.12.2
date	2001.07.04.10.24.27;	author niklas;	state Exp;
branches;
next	1.11.12.3;

1.11.12.3
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.11.12.4;

1.11.12.4
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.11.12.5;

1.11.12.5
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.11.12.6;

1.11.12.6
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.11.12.7;

1.11.12.7
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	1.11.12.8;

1.11.12.8
date	2004.06.05.23.11.02;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.43
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: param.h,v 1.42 2013/11/24 22:15:24 miod Exp $ */

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef	_MACHINE_PARAM_H_
#define	_MACHINE_PARAM_H_

#define	_MACHINE	vax
#define	MACHINE		"vax"
#define	_MACHINE_ARCH	vax
#define	MACHINE_ARCH	"vax"
#define	MID_MACHINE	MID_VAX

#define	PAGE_SHIFT	12
#define	PAGE_SIZE	(1 << PAGE_SHIFT)
#define	PAGE_MASK	(PAGE_SIZE - 1)

#define	VAX_PGSHIFT	9
#define	VAX_NBPG	(1 << VAX_PGSHIFT)
#define	VAX_PGOFSET	(VAX_NBPG - 1)
#define	VAX_NPTEPG	(VAX_NBPG / 4)

#define	KERNBASE	0x80000000		/* start of kernel virtual */

#ifdef _KERNEL

#define	NBPG		PAGE_SIZE		/* bytes/page */
#define	PGSHIFT		PAGE_SHIFT		/* LOG2(PAGE_SIZE) */
#define	PGOFSET		PAGE_MASK		/* byte offset into page */

#define	UPAGES		2			/* pages of u-area */
#define	USPACE		(UPAGES * PAGE_SIZE)
#define	USPACE_ALIGN	(0)			/* u-area alignment 0-none */
#define	REDZONEADDR	(VAX_NBPG*3)		/* Must be > sizeof(struct user) */

#define	NMBCLUSTERS	1024			/* map size, max cluster allocation */

#ifndef	MSGBUFSIZE
#define	MSGBUFSIZE	(2 * PAGE_SIZE)		/* default message buffer size */
#endif

/*
 * Maximum size of the kernel malloc arena in PAGE_SIZE-sized
 * logical pages.
 */
#define	NKMEMPAGES_MAX_DEFAULT	((4 * 1024 * 1024) >> PAGE_SHIFT)

/* MD conversion macros */
#define	vax_atop(x)	(((unsigned)(x) + VAX_PGOFSET) >> VAX_PGSHIFT)
#define	vax_btop(x)	(((unsigned)(x)) >> VAX_PGSHIFT)

#include <machine/intr.h>

/* Prototype needed for delay() */
#ifndef	_LOCORE
#include <machine/cpu.h>

void	delay(int);
/* inline macros used inside kernel */
#include <machine/macros.h>
#endif

#define	DELAY(x) delay(x)
#endif /* _KERNEL */

#endif /* _MACHINE_PARAM_H_ */
@


1.42
log
@Increase NMBCLUSTERS a bit. Riding upon the kernel memory saved by the pmap
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.41 2013/06/13 05:12:51 deraadt Exp $ */
@


1.41
log
@ovbcopy begone
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.40 2013/03/26 05:04:10 deraadt Exp $ */
d66 1
a66 1
#define	NMBCLUSTERS	768			/* map size, max cluster allocation */
@


1.40
log
@PGSHIFT and PGOFSET are now contained inside the kernel namespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.39 2013/03/25 17:46:24 deraadt Exp $ */
a80 2

#define	ovbcopy(x,y,z)	bcopy(x, y, z)
@


1.39
log
@ALIGNBYTES/ALIGN/ALIGNED_POINTER can move to the MI file.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.38 2013/03/23 16:12:28 deraadt Exp $ */
a46 2
#define	PGSHIFT		PAGE_SHIFT		/* LOG2(PAGE_SIZE) */
#define	PGOFSET		PAGE_MASK		/* byte offset into page */
d58 2
@


1.38
log
@refactor sys/param.h and machine/param.h.  A lot of #ifdef _KERNEL is added
to keep definitions our of user space.  The MD files now follow a consistant
order -- all namespace intrusion is at the tail can be cleaned up
independently.  locore, bootblocks, and libkvm still see enough visibility to
build.  Checked on 90% of platforms...
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.37 2011/09/08 03:40:32 guenther Exp $ */
a42 4

#define	ALIGNBYTES		_ALIGNBYTES
#define	ALIGN(p)		_ALIGN(p)
#define	ALIGNED_POINTER(p,t)	_ALIGNED_POINTER(p,t)
@


1.37
log
@Provide namespace-safe alignment macros in <machine/_types.h>, with
compat names kept in <machine/param.h>.  In <sys/socket.h>, pull
in <sys/_types.h> instead of the namespace polluting <machine/param.h>
and completely eliminate __CMSG_ALIGN, replaced by _ALIGN

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: param.h,v 1.36 2011/04/07 15:45:18 miod Exp $ */
/*      $NetBSD: param.h,v 1.39 1999/10/22 21:14:34 ragge Exp $    */
a32 2
 *
 *	@@(#)param.h	5.8 (Berkeley) 6/28/91
d35 2
a36 6
#ifndef _MACHINE_PARAM_H_
#define _MACHINE_PARAM_H_

/*
 * Machine dependent constants for VAX.
 */
a47 4
#define	PGSHIFT		12			/* LOG2(NBPG) */
#define	NBPG		(1 << PGSHIFT)		/* (1 << PGSHIFT) bytes/page */
#define	PGOFSET		(NBPG - 1)               /* byte offset into page */

d51 2
d61 8
a68 2
#define	DEV_BSHIFT	9		               /* log2(DEV_BSIZE) */
#define	DEV_BSIZE	(1 << DEV_BSHIFT)
d70 1
a70 8
#define BLKDEV_IOSIZE	2048
#define	MAXPHYS		(64 * 1024)	/* max raw I/O transfer size */
#define	MAXBSIZE	0x4000		/* max FS block size - XXX */

#define	UPAGES		2		/* pages of u-area */
#define USPACE		(NBPG*UPAGES)
#define	USPACE_ALIGN	(0)		/* u-area alignment 0-none */
#define	REDZONEADDR	(VAX_NBPG*3)	/* Must be > sizeof(struct user) */
d72 2
a73 2
#ifndef MSGBUFSIZE
#define MSGBUFSIZE	8192		/* default message buffer size */
d77 1
a77 6
 * Constants related to network buffer management.
 */
#define	NMBCLUSTERS	768		/* map size, max cluster allocation */

/*
 * Minimum and maximum sizes of the kernel malloc arena in PAGE_SIZE-sized
a79 1
#define	NKMEMPAGES_MIN_DEFAULT	((4 * 1024 * 1024) >> PAGE_SHIFT)
a81 12
/*
 * Some macros for units conversion
 */

/* pages ("clicks") to disk blocks */
#define	ctod(x)		((x) << (PGSHIFT - DEV_BSHIFT))
#define	dtoc(x)		((x) >> (PGSHIFT - DEV_BSHIFT))

/* bytes to disk blocks */
#define	btodb(x)	((x) >> DEV_BSHIFT)
#define	dbtob(x)	((x) << DEV_BSHIFT)

d86 1
a86 3
#define       ovbcopy(x,y,z)  bcopy(x, y, z)

#ifdef _KERNEL
@


1.36
log
@Make sure the ALIGN() macro uses u_long on all platforms for consistency, and
update the comment block accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.35 2011/03/23 16:54:37 pirofti Exp $ */
d50 3
a52 15
/*
 * Round p (pointer or byte index) up to a correctly-aligned value
 * for all data types (int, long, ...).   The result is u_long and
 * must be cast to any desired pointer type.
 *
 * ALIGNED_POINTER is a boolean macro that checks whether an address
 * is valid to fetch data elements of type t from on this architecture.
 * This does not reflect the optimal alignment, just the possibility
 * (within reasonable limits). 
 *
 */

#define ALIGNBYTES		(sizeof(int) - 1)
#define ALIGN(p)		(((u_long)(p) + ALIGNBYTES) &~ ALIGNBYTES)
#define ALIGNED_POINTER(p,t)	((((u_long)(p)) & (sizeof(t)-1)) == 0)
@


1.35
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.34 2008/08/14 11:41:30 martin Exp $ */
d52 1
a52 1
 * for all data types (int, long, ...).   The result is u_int and
d63 1
a63 1
#define ALIGN(p)		(((u_int)(p) + ALIGNBYTES) &~ ALIGNBYTES)
@


1.34
log
@convert the last traces of btoc/ctob macros

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.33 2007/05/28 21:02:49 thib Exp $ */
d37 2
a38 2
#ifndef _VAX_PARAM_H_
#define _VAX_PARAM_H_
d143 1
a143 1
#endif /* _VAX_PARAM_H_ */
@


1.33
log
@Move the MSIZE, MCLSHIFT, MCLBYTES and the MCLOFSET
mbuf constants from MD param.h to MI param.h.
Besides being the same on every arch, things will
most probly break if any arch has different values
then the others.

The NMBCLUSTERS constants needs to be MD though;

ok miod@@,krw@@,claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.32 2006/05/30 21:25:28 miod Exp $ */
a116 4
/* clicks to bytes */
#define	ctob(x)		((x) << PGSHIFT)
#define	btoc(x)		(((unsigned)(x) + PGOFSET) >> PGSHIFT)

d122 1
a122 1
#define	vax_btoc(x)	(((unsigned)(x) + VAX_PGOFSET) >> VAX_PGSHIFT)
@


1.32
log
@Define meaningful values for IPL_ levels, which directly map to the spl
operation. Will allow a vax implementation of splassert().
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.31 2006/03/19 01:47:24 martin Exp $ */
a98 4
 * MCLBYTES must be no larger than NBPG (the software page size), and,
 * on machines that exchange pages of input or output buffers with mbuf
 * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
 * of the hardware page size.
a99 10

#ifndef	MSIZE
#define	MSIZE		256		/* size of an mbuf */
#endif	/* MSIZE */

#ifndef	MCLSHIFT
#define	MCLSHIFT	11		/* convert bytes to m_buf clusters */
#endif	/* MCLSHIFT */
#define	MCLBYTES	(1 << MCLSHIFT)	/* size of an m_buf cluster */
#define	MCLOFSET	(MCLBYTES - 1)	/* offset within an m_buf cluster */
@


1.31
log
@remove unused bdbtofsb(bn) macro

found by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.30 2006/03/12 03:14:37 brad Exp $ */
d147 1
a147 45
/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

#ifndef lint
#define splx(reg)						\
({								\
	register int val;					\
	__asm __volatile ("mfpr $0x12,%0;mtpr %1,$0x12"		\
				: "=&g" (val)			\
				: "g" (reg));			\
	val;							\
})

#define	_splraise(reg)						\
({								\
	register int val;					\
	__asm __volatile ("mfpr $0x12,%0"			\
				: "=&g" (val)			\
				: );				\
	if ((reg) > val) {					\
		__asm __volatile ("mtpr %0,$0x12"		\
				:				\
				: "g" (reg));			\
	}							\
	val;							\
})
#endif

#define	spl0()		splx(0)		/* IPL0  */
#define splsoftclock()	_splraise(8)	/* IPL08 */
#define splsoftnet()	_splraise(0xc)	/* IPL0C */
#define	splddb()	_splraise(0xf)	/* IPL0F */
#define splbio()	_splraise(0x15)	/* IPL15 */
#define splnet()	_splraise(0x15)	/* IPL15 */
#define spltty()	_splraise(0x15)	/* IPL15 */
#define splvm()		_splraise(0x17)	/* IPL17 */
#define splclock()	_splraise(0x18)	/* IPL18 */
#define splhigh()	_splraise(0x1f)	/* IPL1F */
#define	splstatclock()	splclock()

/* These are better to use when playing with VAX buses */
#define	spl4()		splx(0x14)
#define	spl5()		splx(0x15)
#define	spl6()		splx(0x16)
#define	spl7()		splx(0x17)
@


1.30
log
@remove splimp.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.29 2005/11/08 15:05:56 martin Exp $ */
a141 9

/*
 * Map a ``block device block'' to a file system block.
 * This should be device dependent, and will be if we
 * add an entry to cdevsw/bdevsw for that purpose.
 * For now though just use DEV_BSIZE.
 */

#define	bdbtofsb(bn)	((bn) / (BLKDEV_IOSIZE/DEV_BSIZE))
@


1.29
log
@use atop()
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.28 2005/04/19 15:29:48 mickey Exp $ */
a190 1
#define splimp()	_splraise(0x17)	/* IPL17 */
@


1.28
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.27 2004/08/06 22:31:31 mickey Exp $ */
a133 1
#define	btop(x)		(((unsigned)(x)) >> PGSHIFT)
@


1.27
log
@provide md USPACE_ALIGN zero on all but mips; deradat@@ pefo@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.26 2004/04/19 22:55:51 deraadt Exp $ */
a185 1
#define spllowersoftclock() splx(8)	/* IPL08 */
@


1.26
log
@remove the GATEWAY junk thingy; at the same time, select a new fat
cluster value that noone will really need to crank.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.25 2003/06/02 23:27:57 millert Exp $ */
d90 1
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.24 2002/05/06 21:38:26 millert Exp $ */
d113 1
a113 9

#ifndef NMBCLUSTERS

#ifdef GATEWAY
#define	NMBCLUSTERS	512		/* map size, max cluster allocation */
#else
#define	NMBCLUSTERS	256		/* map size, max cluster allocation */
#endif	/* GATEWAY */
#endif	/* NMBCLUSTERS */
@


1.24
log
@Increase MAXPHYS from 63K to 64K which brings it in line with all our
other architectures and matches NetBSD-current.  hugh@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.23 2002/04/29 07:35:24 miod Exp $ */
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@Define placeholders for art's splassert() debugging stuff on all arches.
Currently as no-ops everywhere.

ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.22 2002/03/14 01:26:48 millert Exp $ */
d89 1
a89 1
#define	MAXPHYS		(63 * 1024)	/* max raw I/O transfer size */
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.21 2001/12/05 01:57:15 provos Exp $ */
d167 4
@


1.21
log
@make nkmempages dynamic based on memory. okay art@@ from netbsd:
date: 2000/02/11 19:22:52;  author: thorpej;
Add some very simple code to auto-size the kmem_map.  We take the
amount of physical memory, divide it by 4, and then allow machine
dependent code to place upper and lower bounds on the size.  Export
the computed value to userspace via the new "vm.nkmempages" sysctl.

NKMEMCLUSTERS is now deprecated and will generate an error if you
attempt to use it.  The new option, should you choose to use it,
is called NKMEMPAGES, and two new options NKMEMPAGES_MIN and
NKMEMPAGES_MAX allow the user to configure the bounds in the kernel
config file.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.19 2001/06/24 17:05:39 miod Exp $ */
d216 1
a216 1
void	delay __P((int));
@


1.21.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.21 2001/12/05 01:57:15 provos Exp $ */
d89 1
a89 1
#define	MAXPHYS		(64 * 1024)	/* max raw I/O transfer size */
a166 4

/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

d216 1
a216 1
void	delay(int);
@


1.20
log
@change MSIZE to 256, okay @@deraadt
@
text
@d128 5
a132 6
 * Size of kernel malloc arena in NBPG-sized logical pages
 */ 

#ifndef NKMEMCLUSTERS
#define	NKMEMCLUSTERS	(4096*1024/NBPG)
#endif
@


1.19
log
@Define splvm() for arches who don't already provide it, with the same
definition as splimp().
art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.18 2001/06/13 07:38:47 miod Exp $ */
d109 1
a109 1
#define	MSIZE		128		/* size of an mbuf */
@


1.18
log
@Recent changes in sys/netinet/ assume you get setsoftnet() via
<machine/param.h>, which was not the case for these arches.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.17 2001/05/13 02:37:30 millert Exp $ */
d202 1
@


1.17
log
@PAGE_MASK is (PAGE_SIZE - 1), *not* (PAGE_SHIFT - 1)
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.16 2001/05/10 22:46:52 miod Exp $ */
d214 2
@


1.16
log
@Provide PAGE_{MASK,SHIFT,SIZE} constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.15 2001/05/09 15:31:27 art Exp $ */
d76 1
a76 1
#define	PAGE_MASK	(PAGE_SHIFT - 1)
@


1.15
log
@More sync to NetBSD.

 - Change pmap_change_wiring to pmap_unwire because it's only called that way.
 - Remove pmap_pageable because it's seldom implemented and when it is, it's
   either almost useless or incorrect. The same information is already passed
   to the pmap anyway by pmap_enter and pmap_unwire.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.14 2001/05/05 20:56:56 art Exp $ */
d73 4
@


1.14
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.13 2000/10/09 22:55:35 bjc Exp $ */
a163 1
#define        pmap_pageable(a,b,c,d)          /* Dont do anything */
@


1.13
log
@- remove vmapbuf/vunmapbuf dummy macros (we have these now)

also define VAX_NPTEPG (used by vmparam.h)
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.12 2000/04/26 03:08:42 bjc Exp $ */
a86 3

#define	CLSIZELOG2	0		
#define	CLSIZE		1		
@


1.12
log
@vax resurrection, part 1: sync with early-april netbsd

many changes here, notable:  uvm, ansi.h, more (and cleaner) vsbus support
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.11 1997/10/02 22:55:43 niklas Exp $ */
d77 1
a210 3

#define vmapbuf(p,q)
#define vunmapbuf(p,q)
@


1.11
log
@indent and removal of #if 0 MAXPHYS setting.  No semantic diffs, so you can
touch it back to its previous mtime after cvs updating if you want to
@
text
@d1 2
a2 2
/*	$OpenBSD: param.h,v 1.10 1997/10/02 15:44:40 niklas Exp $ */
/*      $NetBSD: param.h,v 1.24 1997/08/05 13:28:51 ragge Exp $    */
a43 3
#include <machine/macros.h>
#include <machine/psl.h>

d66 11
a76 8
#define ALIGNBYTES		(sizeof (int) - 1)
#define ALIGN(p)		(((u_int)(p) + ALIGNBYTES) & ~ALIGNBYTES)
#define ALIGNED_POINTER(p,t)	((((u_long)(p)) & (sizeof (t) - 1)) == 0)

#define	PGSHIFT	 9				/* log2(NBPG) */
#define	NBPG     (1 << PGSHIFT)			/* (1 << PGSHIFT) bytes/page */
#define	PGOFSET	 (NBPG - 1)			/* byte offset into page */
#define	NPTEPG	 (NBPG / (sizeof (struct pte)))
a78 1
#define	BTOPKERNBASE	((u_long)KERNBASE >> PGSHIFT)
d80 1
a80 1
#define	DEV_BSHIFT	9			/* log2(DEV_BSIZE) */
d83 10
a92 2
#define BLKDEV_IOSIZE 2048
#define	MAXPHYS		(63 * 1024)		/* max raw I/O transfer size */
d94 3
a96 9
#define	CLSIZELOG2	1
#define	CLSIZE		2

/* NOTE: SSIZE, SINCR and UPAGES must be multiples of CLSIZE */
#define	SSIZE	4		/* initial stack size/NBPG */
#define	SINCR	4		/* increment of stack/NBPG */

#define	UPAGES	16		/* pages of u-area */
#define USPACE  (NBPG * UPAGES)
d100 1
a100 1
 * MCLBYTES must be no larger than CLBYTES (the software page size), and,
d111 1
a111 1
#define	MCLSHIFT	10		/* convert bytes to m_buf clusters */
d117 1
d126 1
a126 1
 * Size of kernel malloc arena in CLBYTES-sized logical pages
d130 1
a130 1
#define	NKMEMCLUSTERS	(2048 * 1024 / CLBYTES)
d143 1
a143 1
#define	btoc(x)		(((x) + PGOFSET) >> PGSHIFT)
d150 4
d161 3
a163 1
#define	bdbtofsb(bn)	((bn) / (BLKDEV_IOSIZE / DEV_BSIZE))
d165 10
a174 7
#define splx(reg)					\
({							\
        int val;					\
							\
        asm __volatile ("mfpr $0x12,%0; mtpr %1,$0x12"	\
                        : "&=g" (val) : "g" (reg));	\
        val;						\
d177 14
d193 10
a202 9
#define splsoftclock()  splx(8)		/* IPL08 */
#define splsoftnet()    splx(0xc)	/* IPL0C */
#define	splddb()	splx(0xf)	/* IPL0F */
#define splbio()        splx(0x15)	/* IPL15 */
#define splnet()        splx(0x15)	/* IPL15 */
#define spltty()        splx(0x15)	/* IPL15 */
#define splimp()        splx(0x17)	/* IPL17 */
#define splclock()      splx(0x18)	/* IPL18 */
#define splhigh()       splx(0x1f)	/* IPL1F */
a210 3
#define	ovbcopy(x,y,z)	bcopy(x, y, z)

#if !defined(VAX410) && !defined(VAX43)
a212 1
#endif
a213 1
#ifdef _KERNEL
d217 2
@


1.11.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: param.h,v 1.13 2000/10/09 22:55:35 bjc Exp $ */
/*      $NetBSD: param.h,v 1.39 1999/10/22 21:14:34 ragge Exp $    */
d44 3
d69 8
a76 12
#define ALIGNBYTES		(sizeof(int) - 1)
#define ALIGN(p)		(((u_int)(p) + ALIGNBYTES) &~ ALIGNBYTES)
#define ALIGNED_POINTER(p,t)	((((u_long)(p)) & (sizeof(t)-1)) == 0)

#define	PGSHIFT		12			/* LOG2(NBPG) */
#define	NBPG		(1 << PGSHIFT)		/* (1 << PGSHIFT) bytes/page */
#define	PGOFSET		(NBPG - 1)               /* byte offset into page */

#define	VAX_PGSHIFT	9
#define	VAX_NBPG	(1 << VAX_PGSHIFT)
#define	VAX_PGOFSET	(VAX_NBPG - 1)
#define	VAX_NPTEPG	(VAX_NBPG / 4)
d79 1
d81 1
a81 1
#define	DEV_BSHIFT	9		               /* log2(DEV_BSIZE) */
d84 9
a92 10
#define BLKDEV_IOSIZE	2048
#define	MAXPHYS		(63 * 1024)	/* max raw I/O transfer size */
#define	MAXBSIZE	0x4000		/* max FS block size - XXX */

#define	CLSIZELOG2	0		
#define	CLSIZE		1		

#define	UPAGES		2		/* pages of u-area */
#define USPACE		(NBPG*UPAGES)
#define	REDZONEADDR	(VAX_NBPG*3)	/* Must be > sizeof(struct user) */
d94 2
a95 3
#ifndef MSGBUFSIZE
#define MSGBUFSIZE	8192		/* default message buffer size */
#endif
d99 1
a99 1
 * MCLBYTES must be no larger than NBPG (the software page size), and,
d110 1
a110 1
#define	MCLSHIFT	11		/* convert bytes to m_buf clusters */
a115 1

d124 1
a124 1
 * Size of kernel malloc arena in NBPG-sized logical pages
d128 1
a128 1
#define	NKMEMCLUSTERS	(4096*1024/NBPG)
d141 1
a141 1
#define	btoc(x)		(((unsigned)(x) + PGOFSET) >> PGSHIFT)
a147 4
/* MD conversion macros */
#define	vax_btoc(x)	(((unsigned)(x) + VAX_PGOFSET) >> VAX_PGSHIFT)
#define	vax_btop(x)	(((unsigned)(x)) >> VAX_PGSHIFT)

d155 1
a155 3
#define	bdbtofsb(bn)	((bn) / (BLKDEV_IOSIZE/DEV_BSIZE))

#define       ovbcopy(x,y,z)  bcopy(x, y, z)
d157 7
a163 10
#ifdef _KERNEL
#define        pmap_pageable(a,b,c,d)          /* Dont do anything */
#ifndef lint
#define splx(reg)						\
({								\
	register int val;					\
	__asm __volatile ("mfpr $0x12,%0;mtpr %1,$0x12"		\
				: "=&g" (val)			\
				: "g" (reg));			\
	val;							\
a165 14
#define	_splraise(reg)						\
({								\
	register int val;					\
	__asm __volatile ("mfpr $0x12,%0"			\
				: "=&g" (val)			\
				: );				\
	if ((reg) > val) {					\
		__asm __volatile ("mtpr %0,$0x12"		\
				:				\
				: "g" (reg));			\
	}							\
	val;							\
})
#endif
d168 9
a176 10
#define spllowersoftclock() splx(8)	/* IPL08 */
#define splsoftclock()	_splraise(8)	/* IPL08 */
#define splsoftnet()	_splraise(0xc)	/* IPL0C */
#define	splddb()	_splraise(0xf)	/* IPL0F */
#define splbio()	_splraise(0x15)	/* IPL15 */
#define splnet()	_splraise(0x15)	/* IPL15 */
#define spltty()	_splraise(0x15)	/* IPL15 */
#define splimp()	_splraise(0x17)	/* IPL17 */
#define splclock()	_splraise(0x18)	/* IPL18 */
#define splhigh()	_splraise(0x1f)	/* IPL1F */
d185 8
a195 2
/* inline macros used inside kernel */
#include <machine/macros.h>
@


1.11.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.11.12.1 2001/05/14 21:38:02 niklas Exp $ */
a73 4
#define	PAGE_SHIFT	12
#define	PAGE_SIZE	(1 << PAGE_SHIFT)
#define	PAGE_MASK	(PAGE_SIZE - 1)

d88 3
d167 1
a201 1
#define splvm()		_splraise(0x17)	/* IPL17 */
a213 2
#include <machine/cpu.h>

@


1.11.12.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.11.12.2 2001/07/04 10:24:27 niklas Exp $ */
d109 1
a109 1
#define	MSIZE		256		/* size of an mbuf */
@


1.11.12.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d128 6
a133 5
 * Minimum and maximum sizes of the kernel malloc arena in PAGE_SIZE-sized
 * logical pages.
 */
#define	NKMEMPAGES_MIN_DEFAULT	((4 * 1024 * 1024) >> PAGE_SHIFT)
#define	NKMEMPAGES_MAX_DEFAULT	((4 * 1024 * 1024) >> PAGE_SHIFT)
@


1.11.12.5
log
@Merge in -current from about a week ago
@
text
@d216 1
a216 1
void	delay(int);
@


1.11.12.6
log
@Sync the SMP branch with 3.3
@
text
@d89 1
a89 1
#define	MAXPHYS		(64 * 1024)	/* max raw I/O transfer size */
a166 4

/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

@


1.11.12.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.11.12.6 2003/03/27 23:52:19 niklas Exp $ */
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.12.8
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d113 9
a121 1
#define	NMBCLUSTERS	768		/* map size, max cluster allocation */
@


1.10
log
@We cannot deal with MCLBYTES > CLBYTES. Lower MCLSHIFT to 10 again
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.9 1997/09/12 09:21:22 maja Exp $ */
d69 8
a76 8
#define ALIGNBYTES		(sizeof(int) - 1)
#define ALIGN(p)		(((u_int)(p) + ALIGNBYTES) &~ ALIGNBYTES)
#define ALIGNED_POINTER(p,t)	((((u_long)(p)) & (sizeof(t)-1)) == 0)

#define	PGSHIFT	 9                             /* LOG2(NBPG) */
#define	NBPG     (1<<PGSHIFT)                  /* (1 << PGSHIFT) bytes/page */
#define	PGOFSET	 (NBPG-1)	               /* byte offset into page */
#define	NPTEPG	 (NBPG/(sizeof (struct pte)))
d78 2
a79 2
#define	KERNBASE     0x80000000	               /* start of kernel virtual */
#define	BTOPKERNBASE ((u_long)KERNBASE >> PGSHIFT)
d81 2
a82 2
#define	DEV_BSHIFT   9		               /* log2(DEV_BSIZE) */
#define	DEV_BSIZE    (1 << DEV_BSHIFT)
d85 1
a85 4
#define	MAXPHYS		(63 * 1024)	/* max raw I/O transfer size */
#ifdef 0
#define	MAXBSIZE	0x4000		/* max FS block size - XXX */
#endif
d87 2
a88 2
#define	CLSIZELOG2    1
#define	CLSIZE	      2
d95 1
a95 1
#define USPACE  (NBPG*UPAGES)
d128 1
a128 1
#define	NKMEMCLUSTERS	(2048*1024/CLBYTES)
d155 1
a155 1
#define	bdbtofsb(bn)	((bn) / (BLKDEV_IOSIZE/DEV_BSIZE))
d157 7
a163 7
#define splx(reg)                                       \
({                                                      \
        register int val;                               \
        asm __volatile ("mfpr $0x12,%0;mtpr %1,$0x12"	\
                        : "&=g" (val)                   \
                        : "g" (reg));                   \
        val;                                            \
d185 1
a185 1
#define	ovbcopy(x,y,z)	bcopy(x,y,z)
@


1.9
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: param.h,v 1.8 1997/09/10 11:47:09 maja Exp $ */
d113 1
a113 1
#define	MCLSHIFT	11		/* convert bytes to m_buf clusters */
@


1.8
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: param.h,v 1.7 1997/01/16 14:26:25 maja Exp $ */
/*      $NetBSD: param.h,v 1.23 1997/02/24 23:23:06 fvdl Exp $    */
d195 1
d202 1
@


1.7
log
@Don't define MAXBSIZE here. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: param.h,v 1.6 1997/01/15 23:24:42 maja Exp $ */
/*      $NetBSD: param.h,v 1.22 1997/01/11 11:06:17 ragge Exp $    */
d61 6
d69 3
a71 2
#define ALIGNBYTES	(sizeof(int) - 1)
#define ALIGN(p)	(((u_int)(p) + ALIGNBYTES) &~ ALIGNBYTES)
@


1.6
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d79 1
d81 1
@


1.5
log
@MCLSHIFT=11, and calc MCLBYTES in such terms. found by pefo
@
text
@d1 2
a2 1
/*      $NetBSD: param.h,v 1.19 1996/03/04 05:04:43 cgd Exp $    */
d78 2
a79 1
#define	MAXPHYS	      (63 * 1024)     /* max raw I/O transfer size */
a164 1
#define spl4()          splx(0x14)	/* IPL14 */
d173 6
d181 1
d184 1
@


1.4
log
@sync w/ 0430
@
text
@d102 1
a102 1
#define	MCLSHIFT	10		/* convert bytes to m_buf clusters */
@


1.3
log
@from ragge:
An '&' missing in splx macro; causing that sometimes didn't
the interrupt level get set.
@
text
@d1 1
a1 2
/*      $NetBSD: param.h,v 1.14 1995/12/30 21:37:31 ragge Exp $    */

d43 2
a44 2
#include "machine/macros.h"
#include "machine/psl.h"
d50 3
a52 1
#define MACHINE		"vax"
d54 1
a54 1
#define MID_MACHINE	MID_VAX
d167 1
a167 1
#define splimp()        splx(0x16)	/* IPL16 */
d176 5
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*      $NetBSD: param.h,v 1.13 1995/12/04 22:32:53 ragge Exp $    */
d152 1
a152 1
                        : "=g" (val)                    \
d171 1
a171 1
#define	ovbcopy(x,y,z)	bcopy(x,y,z)	/* This should work i hope... */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: param.h,v 1.12 1995/08/13 00:45:21 mycroft Exp $    */
a6 2
 * Modified for VAX 940213/Ragge
 *
d45 1
a45 1
#include "psl.h"
d52 1
a53 1
#define UNIX		"vmunix"
d133 1
a147 13
/*
 * Mach derived conversion macros
 */

#define vax_round_pdr(x)	((((unsigned)(x)) + NBPDR - 1) & ~(NBPDR-1))
#define vax_trunc_pdr(x)	((unsigned)(x) & ~(NBPDR-1))
#define vax_round_page(x)	((((unsigned)(x)) + NBPG - 1) & ~(NBPG-1))
#define vax_trunc_page(x)	((unsigned)(x) & ~(NBPG-1))
#define vax_btod(x)		((unsigned)(x) >> PDRSHIFT)
#define vax_dtob(x)		((unsigned)(x) << PDRSHIFT)
#define vax_btop(x)		((unsigned)(x) >> PGSHIFT)
#define vax_ptob(x)		((unsigned)(x) << PGSHIFT)

d176 1
a176 4
#if !defined(VAX630) && !defined(VAX410)
#define todr()          mfpr(PR_TODR)
#endif
#define	DELAY(x) {int N=todr()+(x/1000)+1;while(todr()!=N);}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
