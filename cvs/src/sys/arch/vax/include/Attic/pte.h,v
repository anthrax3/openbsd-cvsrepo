head	1.13;
access;
symbols
	OPENBSD_5_9:1.12.0.8
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.10
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.10
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.20
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.18
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.14
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.12
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.12
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.12;
commitid	OSDG2O3Cgeifnf1W;

1.12
date	2013.11.24.22.08.23;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.25.21.05.31;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.06.22.54.29;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.26.03.08.42;	author bjc;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.00.04.48;	author niklas;	state Exp;
branches
	1.5.12.1;
next	1.4;

1.4
date	96.05.03.09.09.44;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.31.08.33.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.07;	author deraadt;	state Exp;
branches;
next	;

1.5.12.1
date	2001.05.14.21.38.04;	author niklas;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.5.12.3;

1.5.12.3
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.13
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*      $OpenBSD: pte.h,v 1.12 2013/11/24 22:08:23 miod Exp $      */
/*	$NetBSD: pte.h,v 1.21 2005/12/24 22:45:40 perry Exp $	  */

/*
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_PTE_H_
#define _MACHINE_PTE_H_

#ifndef _LOCORE

typedef u_int32_t	pt_entry_t;	/* page table entry */

#endif /* _LOCORE */

#define	PG_V		0x80000000
#define	PG_NV		0x00000000
#define	PG_PROT		0x78000000
#define	PG_RW		0x20000000
#define	PG_KW		0x10000000
#define	PG_KR		0x18000000
#define	PG_URKW		0x70000000
#define	PG_RO		0x78000000
#define	PG_NONE		0x00000000
#define	PG_M		0x04000000
#define	PG_W		0x01000000
#define	PG_SREF		0x00800000
#define	PG_ILLEGAL	0x00600000
#define	PG_FRAME	0x001fffff
#define	PG_PFNUM(x)	(((unsigned long)(x) & 0x3ffffe00) >> VAX_PGSHIFT)

#ifndef _LOCORE
/*
 * Kernel virtual address to page table entry and to physical address.
 */
extern pt_entry_t *Sysmap;
#endif

#ifdef __GNUC__
static inline pt_entry_t *
kvtopte(vaddr_t va)
{
	pt_entry_t *pte;

	__asm(
		"extzv $9,$21,%1,%0\n\t"
		"moval *Sysmap[%0],%0\n\t"
	    : "=r"(pte)
	    : "g"(va));
	return pte;
}
static inline paddr_t
kvtophys(vaddr_t va)
{
	paddr_t pa;

	__asm(
		"extzv $9,$21,%1,%0\n\t"
		"ashl $9,*Sysmap[%0],%0\n\t"
		"insv %1,$0,$9,%0\n\t"
	    : "=&r"(pa)
	    : "g"(va) : "cc");
	return pa;
}
#else /* __GNUC__ */
#define kvtopte(va) (&Sysmap[PG_PFNUM(va)])
#define kvtophys(va) \
    (((*kvtopte(va) & PG_FRAME) << VAX_PGSHIFT) | ((paddr_t)(va) & VAX_PGOFSET))
#endif /* __GNUC__ */
#define uvtopte(va, pcb) \
	(((vaddr_t)(va) < 0x40000000) ? \
	&(((pcb)->P0BR)[PG_PFNUM(va)]) : \
	&(((pcb)->P1BR)[PG_PFNUM(va)]))

#endif
@


1.12
log
@Rework pmap to use dynamic P0 and P1 region allocation, instead of allocating
the largest possible page table for every pmap; from NetBSD. This allows the
kernel to use much less memory for page tables.

Significant differences against the NetBSD code are:
- allocation of page table pages is done with a pool instead of allocating
  whole logical pages from uvm and managing the freelist within pmap, never
  releasing allocated pages.
- try to use pt_entry_t * rather than int * whenever possible.
- growth of P0 and P1 regions is allowed to fail, if invoked from
  pmap_enter with the PMAP_CANFAIL flag. This will stall processes until
  memory for the page tables can be obtained, rather than panicing, in
  most cases.
- keep management of mappings for managed pages using pv lists tied to the
  vm_page (using __HAVE_VM_PAGE_MD), rather than a global pv_list head.
- bound check against Sysmap[] in pmap_extract() when asked for a kernel
  address.

As a result of this, bsd.rd can now install a working system on a 12MB machine
without needing to enable swap.
@
text
@d1 1
a1 1
/*      $OpenBSD: pte.h,v 1.11 2011/03/23 16:54:37 pirofti Exp $      */
@


1.11
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: pte.h,v 1.10 2006/07/25 21:05:31 miod Exp $      */
d39 1
a39 1
typedef u_int32_t	pt_entry_t;	/* Mach page table entry */
a42 2
#define	PT_ENTRY_NULL	((pt_entry_t *) 0)

a59 1
extern pt_entry_t *Sysmap;
d63 1
a63 6
#endif

#ifdef __ELF__
#define VAX_SYSMAP	"Sysmap"
#else
#define VAX_SYSMAP	"_Sysmap"
d67 25
a91 11
#define kvtopte(va) ({ \
	pt_entry_t *r; \
	__asm("extzv $9,$21,%1,%0;moval *" VAX_SYSMAP "[%0],%0" : "=r"(r) : "g"(va)); \
	r; \
})
#define kvtophys(va) ({ \
	paddr_t r; \
	__asm("extzv $9,$21,%1,%0;ashl $9,*" VAX_SYSMAP "[%0],%0;insv %1,$0,$9,%0" \
	    : "=&r"(r) : "g"(va) : "cc"); \
	r; \
})
d95 1
a95 1
	(((*kvtopte(va) & PG_FRAME) << VAX_PGSHIFT) | ((int)(va) & VAX_PGOFSET))
@


1.10
log
@Assembly versions of kvtopte() and kvtophys(), better than what gcc
outputs; from NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: pte.h,v 1.9 2003/11/10 21:05:06 miod Exp $      */
d34 2
a35 2
#ifndef _VAX_PTE_H_
#define _VAX_PTE_H_
@


1.9
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 2
a2 2
/*      $OpenBSD: pte.h,v 1.8 2003/11/06 22:54:29 miod Exp $      */
/*      $NetBSD: pte.h,v 1.13 1999/08/03 19:53:23 ragge Exp $      */
d68 21
a88 4
#define	kvtopte(va) (&Sysmap[PG_PFNUM(va)])
#define	ptetokv(pt) \
	((((pt_entry_t *)(pt) - Sysmap) << VAX_PGSHIFT) + 0x80000000)
#define	kvtophys(va) \
d90 5
a94 4
#define	uvtopte(va, pcb) \
	(((unsigned)va < 0x40000000) ? \
	&((pcb->P0BR)[PG_PFNUM(va)]) : \
	&((pcb->P1BR)[PG_PFNUM(va)]))
@


1.8
log
@Do not use a reserved PTE bit as the wired bit, this can bite you.

From NetBSD (PR #11121)
@
text
@d1 1
a1 1
/*      $OpenBSD: pte.h,v 1.7 2001/08/12 12:03:03 heko Exp $      */
a37 14
/*
 * VAX page table entries
 */
struct pte {
	unsigned int	pg_pfn:21;	/* Page Frame Number or 0 */
	unsigned int	pg_illegal:2;	/* Don't use these bits */
	unsigned int	pg_sref:1;	/* Help for ref simulation */
	unsigned int	pg_w:1;         /* Wired bit */
	unsigned int	pg_z:1;		/* Zero DIGITAL = 0 */
	unsigned int	pg_m:1;		/* Modify DIGITAL */
	unsigned int	pg_prot:4;	/* reserved at zero */
	unsigned int	pg_v:1;		/* valid bit */
};

d39 1
a39 1
typedef struct pte	pt_entry_t;	/* Mach page table entry */
d72 1
a72 1
	(((kvtopte(va))->pg_pfn << VAX_PGSHIFT) | ((int)(va) & VAX_PGOFSET))
@


1.7
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: pte.h,v 1.6 2000/04/26 03:08:42 bjc Exp $      */
d43 2
a44 1
	unsigned int	pg_u:1;         /* Uniform bit, does WHAT?? XXX */
a45 2
	unsigned int	pg_sref:1;	/* Help for ref simulation */
	unsigned int	pg_ref:1;	/* Simulated reference bit */
d47 2
a48 2
	unsigned int	pg_m:1;	        /* Modify DIGITAL */
	unsigned int	pg_prot:4;     	/* reserved at zero */
d59 6
a64 6
#define PG_V            0x80000000
#define PG_NV           0x00000000
#define PG_PROT         0x78000000
#define PG_RW           0x20000000
#define PG_KW           0x10000000
#define PG_KR           0x18000000
d66 7
a72 8
#define PG_RO           0x78000000
#define PG_NONE         0x00000000
#define PG_M            0x04000000
#define PG_REF          0x01000000
#define PG_SREF         0x00800000
#define PG_W            0x00400000
#define PG_U            0x00200000
#define PG_FRAME        0x001fffff
@


1.6
log
@vax resurrection, part 1: sync with early-april netbsd

many changes here, notable:  uvm, ansi.h, more (and cleaner) vsbus support
@
text
@d1 1
a1 1
/*      $OpenBSD: pte.h,v 1.5 1997/05/29 00:04:48 niklas Exp $      */
d56 1
a56 1
#endif _LOCORE
@


1.5
log
@RCS tagging
@
text
@d1 2
a2 2
/*      $OpenBSD: pte.h,v 1.10 1996/02/23 17:54:33 ragge Exp $      */
/*      $NetBSD: pte.h,v 1.10 1996/02/23 17:54:33 ragge Exp $      */
d34 2
a35 1
#include <machine/param.h>
a37 1

d75 1
a75 1
#define	PG_PFNUM(x)	((x) >> PGSHIFT)
d84 1
a84 2
#define	kvtopte(va) \
	(&Sysmap[((unsigned)(va) & ~KERNBASE) >> PGSHIFT])
d86 1
a86 1
	((((pt_entry_t *)(pt) - Sysmap) << PGSHIFT) + 0x80000000)
d88 1
a88 1
	(((kvtopte(va))->pg_pfn << PGSHIFT) | ((int)(va) & PGOFSET))
d90 5
a94 3
	(((unsigned)va < 0x40000000) || ((unsigned)va > 0x80000000) ? \
	&((pcb->P0BR)[(unsigned)va >> PGSHIFT]) : \
	&((pcb->P1BR)[((unsigned)va & 0x3fffffff) >> PGSHIFT]))
@


1.5.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*      $OpenBSD: pte.h,v 1.6 2000/04/26 03:08:42 bjc Exp $      */
/*      $NetBSD: pte.h,v 1.13 1999/08/03 19:53:23 ragge Exp $      */
d34 1
a34 2
#ifndef _VAX_PTE_H_
#define _VAX_PTE_H_
d37 1
d75 1
a75 1
#define	PG_PFNUM(x)	(((unsigned long)(x) & 0x3ffffe00) >> VAX_PGSHIFT)
d84 2
a85 1
#define	kvtopte(va) (&Sysmap[PG_PFNUM(va)])
d87 1
a87 1
	((((pt_entry_t *)(pt) - Sysmap) << VAX_PGSHIFT) + 0x80000000)
d89 1
a89 1
	(((kvtopte(va))->pg_pfn << VAX_PGSHIFT) | ((int)(va) & VAX_PGOFSET))
d91 3
a93 5
	(((unsigned)va < 0x40000000) ? \
	&((pcb->P0BR)[PG_PFNUM(va)]) : \
	&((pcb->P1BR)[PG_PFNUM(va)]))

#endif
@


1.5.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: pte.h,v 1.5.12.1 2001/05/14 21:38:04 niklas Exp $      */
d56 1
a56 1
#endif /* _LOCORE */
@


1.5.12.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD$      */
d38 15
d54 1
a54 1
typedef u_int32_t	pt_entry_t;	/* Mach page table entry */
d60 6
a65 6
#define	PG_V		0x80000000
#define	PG_NV		0x00000000
#define	PG_PROT		0x78000000
#define	PG_RW		0x20000000
#define	PG_KW		0x10000000
#define	PG_KR		0x18000000
d67 8
a74 7
#define	PG_RO		0x78000000
#define	PG_NONE		0x00000000
#define	PG_M		0x04000000
#define	PG_W		0x01000000
#define	PG_SREF		0x00800000
#define	PG_ILLEGAL	0x00600000
#define	PG_FRAME	0x001fffff
d88 1
a88 1
	(((*kvtopte(va) & PG_FRAME) << VAX_PGSHIFT) | ((int)(va) & VAX_PGOFSET))
@


1.4
log
@sync w/ 0430
@
text
@d1 1
@


1.3
log
@from ragge; add uvtopte() macro, to get user pte address easily
@
text
@d1 1
a1 1
/*      $NetBSD: pte.h,v 1.7 1996/01/28 12:31:24 ragge Exp $      */
d33 1
a33 1
#include "machine/param.h"
d35 1
a35 1
#ifndef ASSEMBLER
d55 1
a55 1
#endif ASSEMBLER
d76 1
a76 1
#ifndef ASSEMBLER
d90 1
a90 1
	(((unsigned)va < 0x40000000) || ((unsigned)va > 0x40000000) ? \
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*      $NetBSD: pte.h,v 1.6 1995/11/12 14:40:26 ragge Exp $      */
d89 4
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: pte.h,v 1.5 1995/08/21 03:28:50 ragge Exp $      */
d33 1
a33 4
 /* All bugs are subject to removal without further notice */
		

#include "vax/include/param.h"
d41 9
a49 9
  unsigned int	pg_pfn:21;	/* Page Frame Number or 0 */
  unsigned int	pg_u:1;         /* Uniform bit, does WHAT?? XXX */
  unsigned int	pg_w:1;         /* Wired bit */
  unsigned int	pg_sref:1;	/* Help for ref simulation */
  unsigned int	pg_ref:1;	/* Simulated reference bit */
  unsigned int	pg_z:1;		/* Zero DIGITAL = 0 */
  unsigned int	pg_m:1;	        /* Modify DIGITAL */
  unsigned int	pg_prot:4;     	/* reserved at zero */
  unsigned int	pg_v:1;		/* valid bit */
d53 1
a53 1
typedef unsigned int	pt_entry_t;	/* Mach page table entry */
d74 1
a74 5
#define PG_SHIFT        9
#define	PG_PFNUM(x)	((x) >> PG_SHIFT)


#define VAX_MAX_KPTSIZE VM_KERNEL_PT_PAGES
d84 1
a84 1
	(&Sysmap[((unsigned)(va) - KERNBASE) >> PGSHIFT])
d88 1
a88 1
	((kvtopte(va)->pg_pfnum << PGSHIFT) | ((int)(va) & PGOFSET))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
