head	1.13;
access;
symbols
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.12
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.8
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.7.0.26
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.24
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.22
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.20
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.18
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.16
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.14
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.12;
commitid	OSDG2O3Cgeifnf1W;

1.12
date	2014.05.17.12.13.44;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.19.21.53.02;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.06.20.42.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.15.22.38.23;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.21.19.28.50;	author hugh;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.10.01.12.56.43;	author hugh;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.26.11.48.06;	author hugh;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.01.10.10;	author bjc;	state Exp;
branches
	1.1.8.1;
next	;

1.1.8.1
date	2001.05.14.21.38.56;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.1.8.5;

1.1.8.5
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: ka46.c,v 1.12 2014/05/17 12:13:44 miod Exp $	*/
/*	$NetBSD: ka46.c,v 1.12 2000/03/04 07:27:49 matt Exp $ */
/*
 * Copyright (c) 1998 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by Bertram Barth.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/pmap.h>
#include <machine/uvax.h>
#include <machine/ka410.h>
#include <machine/ka420.h>
#include <machine/ka46.h>
#include <machine/clock.h>
#include <machine/vsbus.h>

static	void	ka46_conf(void);
static	void	ka46_init(void);
static	void	ka46_memerr(void);
static	int	ka46_mchk(caddr_t);
static	void	ka46_halt(void);
static	void	ka46_reboot(int);
static	void	ka46_cache_enable(void);
static	void	ka46_hardclock(struct clockframe *);

struct	vs_cpu *ka46_cpu;

/* 
 * Declaration of 46-specific calls.
 */
struct	cpu_dep ka46_calls = {
	ka46_init,
	ka46_mchk,
	ka46_memerr, 
	ka46_conf,
	chip_clkread,
	chip_clkwrite,
	8,      /* ~VUPS */
	2,	/* SCB pages */
	ka46_halt,
	ka46_reboot,
	NULL,
	ka46_hardclock
};


void
ka46_conf()
{
        switch (vax_siedata & 0xFF) {
	case VAX_VTYP_47:
		printf("cpu: KA47\n");
		break;
	case VAX_VTYP_46:
		printf("cpu: KA46\n");
		break;
	default:
		printf("cpu: Unknown Mariah\n");
	}

	ka46_cpu = (void *)vax_map_physmem(VS_REGS, 1);
	printf("cpu: turning on floating point chip\n");
	mtpr(2, PR_ACCS); /* Enable floating points */
	/*
	 * Setup parameters necessary to read time from clock chip.
	 */
	clk_adrshift = 1;       /* Addressed at long's... */
	clk_tweak = 2;          /* ...and shift two */
	clk_page = (short *)vax_map_physmem(VS_CLOCK, 1);
}

void
ka46_cache_enable()
{
	int i, *tmp;

	/* Disable caches */
	*(int *)KA46_CCR &= ~CCR_SPECIO;/* secondary */
	mtpr(PCSTS_FLUSH, PR_PCSTS);	/* primary */
	*(int *)KA46_BWF0 &= ~BWF0_FEN; /* invalidate filter */

	/* Clear caches */
	tmp = (void *)KA46_INVFLT;	/* inv filter */
	for (i = 0; i < 32768; i++)
		tmp[i] = 0;

	/* Write valid parity to all primary cache entries */
	for (i = 0; i < 256; i++) {
		mtpr(i << 3, PR_PCIDX);
		mtpr(PCTAG_PARITY, PR_PCTAG);
	}

	/* Secondary cache */
	tmp = (void *)KA46_TAGST;
	for (i = 0; i < KA46_TAGSZ*2; i+=2)
		tmp[i] = 0;

	/* Enable cache */
	*(int *)KA46_BWF0 |= BWF0_FEN; /* invalidate filter */
	mtpr(PCSTS_ENABLE, PR_PCSTS);
	*(int *)KA46_CCR = CCR_SPECIO | CCR_CENA;
}

void
ka46_memerr()
{
	printf("Memory err!\n");
}

int
ka46_mchk(addr)
	caddr_t addr;
{
	panic("Machine check");
	return 0;
}

void
ka46_init()
{

	/* Turn on caches (to speed up execution a bit) */
	ka46_cache_enable();
}

#define	KA46_CPMBX	0x38
#define	KA46_HLT_HALT	0xcf
#define	KA46_HLT_BOOT	0x8b

static void
ka46_halt()
{
	if (((u_int8_t *) clk_page)[KA46_CPMBX] != KA46_HLT_HALT)
		((u_int8_t *) clk_page)[KA46_CPMBX] = KA46_HLT_HALT;
	asm("halt");
}

static void
ka46_reboot(arg)
	int arg;
{
	if (((u_int8_t *) clk_page)[KA46_CPMBX] != KA46_HLT_BOOT)
		((u_int8_t *) clk_page)[KA46_CPMBX] = KA46_HLT_BOOT;
	asm("halt");
}

static void
ka46_hardclock(struct clockframe *cf)
{
	ka46_cpu->vc_diagtimu = 0;
	hardclock(cf);
}
@


1.12
log
@Lower VUPS value for delay() to behave closer to the intent.

This is temporary until vax grows code to compute a proper delay const
at runtime, but will help a bit, especially on KA46 where cd(4) end up
detected as sd(4) due to too short delays.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.11 2011/09/19 21:53:02 miod Exp $	*/
@


1.11
log
@Try and clean system type constants a bit:
- save the second byte of vax_siedata into a new variable, vax_cpustype,
  and use it instead of (vax_siedata >> 8) & 0xff or other similar
  constructs.
- the VAX_SIE_KAxxx constants are duplicates of the VAX_STYP_xx constants.
  Standardize on the latter and kill the former.
- only keep VAX_VTYP_xx constants for KA46 and KA47, those are the only
  systems which use these constants and are told apart by a different
  SIE byte.

No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.10 2011/07/06 20:42:05 miod Exp $	*/
d77 1
a77 1
	12,      /* ~VUPS */
@


1.10
log
@Drop cpu_dep.cpu_subconf routine, which is no longer used after KA820 support
removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.9 2008/08/18 23:05:38 miod Exp $	*/
d89 1
a89 1
        switch(vax_siedata & 0xFF) {
@


1.9
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.8 2008/08/15 22:38:23 miod Exp $	*/
a48 1
#include <machine/nexus.h>
a80 1
	NULL,
@


1.8
log
@Rename the cpu_dep hook ``steal_pages'' to ``init'', as it serves as an
early initialization routine (to enable caches, etc) while still running
physical, and does not allocate memory anymore.

(The irony in this is that forthcoming KA60 support actually steals pages
 in its init function...)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.7 2002/07/21 19:28:50 hugh Exp $	*/
d64 1
d82 3
d186 7
@


1.7
log
@Support OS selectable halt action on the VAXstation 4000's.
Info from NetBSD, testing by pval and millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.6 2002/03/14 01:26:48 millert Exp $	*/
d58 1
a58 1
static	void	ka46_steal_pages(void);
d71 1
a71 1
	ka46_steal_pages,
d156 1
a156 1
ka46_steal_pages()
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.5 2001/11/06 19:53:17 miod Exp $	*/
d163 4
d170 2
d179 2
@


1.5
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.4 2001/10/01 12:56:43 hugh Exp $	*/
d57 7
a63 7
static	void	ka46_conf __P((void));
static	void	ka46_steal_pages __P((void));
static	void	ka46_memerr __P((void));
static	int	ka46_mchk __P((caddr_t));
static	void	ka46_halt __P((void));
static	void	ka46_reboot __P((int));
static	void	ka46_cache_enable __P((void));
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.5 2001/11/06 19:53:17 miod Exp $	*/
d57 7
a63 7
static	void	ka46_conf(void);
static	void	ka46_steal_pages(void);
static	void	ka46_memerr(void);
static	int	ka46_mchk(caddr_t);
static	void	ka46_halt(void);
static	void	ka46_reboot(int);
static	void	ka46_cache_enable(void);
@


1.5.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.5.2.1 2002/06/11 03:39:19 art Exp $	*/
a162 4
#define	KA46_CPMBX	0x38
#define	KA46_HLT_HALT	0xcf
#define	KA46_HLT_BOOT	0x8b

a165 2
	if (((u_int8_t *) clk_page)[KA46_CPMBX] != KA46_HLT_HALT)
		((u_int8_t *) clk_page)[KA46_CPMBX] = KA46_HLT_HALT;
a172 2
	if (((u_int8_t *) clk_page)[KA46_CPMBX] != KA46_HLT_BOOT)
		((u_int8_t *) clk_page)[KA46_CPMBX] = KA46_HLT_BOOT;
@


1.4
log
@Use system variant types rather than 0x80 on the configuration and
test register to tell VAXstation 4000/60 from MicroVAX 3100m80.
This seems to produce more reliable results (should work for both
Norm's and Solar's 3100m80's).
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.3 2001/09/11 20:05:25 miod Exp $	*/
d42 1
a42 1
#include <vm/vm.h>
@


1.3
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.2 2001/08/26 11:48:06 hugh Exp $	*/
d87 2
a88 1
	if (vax_confdata & 0x80)
d90 2
a91 1
	else
d93 4
@


1.2
log
@Attempt to use the configuration and test register to tell a
VS4000 60 KA46 from a MV 3100/80 KA47. Apparently does not work
on all 3100/80's, but better than nothing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.1 2000/04/27 01:10:10 bjc Exp $	*/
a42 1
#include <vm/vm_kern.h>
@


1.1
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 5
a92 1
	printf("cpu: KA46\n");
@


1.1.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.1 2000/04/27 01:10:10 bjc Exp $	*/
@


1.1.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ka46.c,v 1.1.8.1 2001/05/14 21:38:56 niklas Exp $	*/
d43 1
d88 1
a88 11
        switch(vax_siedata & 0xFF) {
	case VAX_VTYP_47:
		printf("cpu: KA47\n");
		break;
	case VAX_VTYP_46:
		printf("cpu: KA46\n");
		break;
	default:
		printf("cpu: Unknown Mariah\n");
	}

@


1.1.8.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
#include <uvm/uvm_extern.h>
@


1.1.8.4
log
@Merge in -current from about a week ago
@
text
@d57 7
a63 7
static	void	ka46_conf(void);
static	void	ka46_steal_pages(void);
static	void	ka46_memerr(void);
static	int	ka46_mchk(caddr_t);
static	void	ka46_halt(void);
static	void	ka46_reboot(int);
static	void	ka46_cache_enable(void);
@


1.1.8.5
log
@Sync the SMP branch with 3.3
@
text
@a162 4
#define	KA46_CPMBX	0x38
#define	KA46_HLT_HALT	0xcf
#define	KA46_HLT_BOOT	0x8b

a165 2
	if (((u_int8_t *) clk_page)[KA46_CPMBX] != KA46_HLT_HALT)
		((u_int8_t *) clk_page)[KA46_CPMBX] = KA46_HLT_HALT;
a172 2
	if (((u_int8_t *) clk_page)[KA46_CPMBX] != KA46_HLT_BOOT)
		((u_int8_t *) clk_page)[KA46_CPMBX] = KA46_HLT_BOOT;
@


