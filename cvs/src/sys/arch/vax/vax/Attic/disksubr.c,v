head	1.68;
access;
symbols
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.66.0.20
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.66.0.12
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.66.0.16
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.66.0.14
	OPENBSD_5_5_BASE:1.66
	OPENBSD_5_4:1.66.0.10
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.66.0.8
	OPENBSD_5_3_BASE:1.66
	OPENBSD_5_2:1.66.0.6
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.66
	OPENBSD_5_1:1.66.0.4
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.62.0.2
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.61.0.4
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.59.0.4
	OPENBSD_4_6_BASE:1.59
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.54.0.4
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.6
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.4
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.68
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.67;
commitid	OSDG2O3Cgeifnf1W;

1.67
date	2015.09.28.15.17.08;	author krw;	state Exp;
branches;
next	1.66;
commitid	F5VKEQmoSNbQb8HV;

1.66
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2011.04.06.13.46.51;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.13.15.23.13;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2009.06.04.21.13.02;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2008.08.14.11.41.30;	author martin;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.12.06.58.38;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.11.12.35.44;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.54;

1.54
date	2007.07.13.20.24.44;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.17.00.27.29;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.14.03.37.23;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.14.03.35.30;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.12.20.57.43;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.09.23.06.46;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.08.05.34.28;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.07.05.22.18;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.07.00.28.17;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.06.16.42.07;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.05.02.38.37;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.05.00.38.19;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.31.22.31.04;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.31.22.06.03;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.31.19.57.44;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.29.05.08.20;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.18.11.43.19;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.10.21.16.01.54;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.04.03.23.01;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.11.21.32.40;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.19.20.19.59;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.20.23.27.26;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.22.02.51.25;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.12.03.44.24;	author pedro;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.30.07.52.32;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.17.14.16.04;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.26.13.06.26;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.29.19.12.31;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.25.01.20.39;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.18.21.00.40;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.27.01.10.11;	author bjc;	state Exp;
branches;
next	1.11;

1.11
date	99.01.08.04.29.10;	author millert;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	98.10.03.21.18.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.09.12.09.30.54;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	97.08.08.21.46.57;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.05.29.00.05.16;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.04.08.09.02.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.25.09;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.06.12.08.20.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.10.10;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.31.05.10.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2001.05.14.21.38.49;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.11.6.5;

1.11.6.5
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.11.6.6;

1.11.6.6
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.11.6.7;

1.11.6.7
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	1.11.6.8;

1.11.6.8
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	1.11.6.9;

1.11.6.9
date	2004.06.05.23.11.03;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.27;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.68
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: disksubr.c,v 1.67 2015/09/28 15:17:08 krw Exp $	*/
/*	$NetBSD: disksubr.c,v 1.21 1999/06/30 18:48:06 ragge Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/syslog.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/disk.h>

#include <uvm/uvm_extern.h>

#include <machine/macros.h>
#include <machine/pte.h>
#include <machine/pcb.h>
#include <machine/cpu.h>

#include <vax/mscp/mscp.h> /* For disk encoding scheme */

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl and anything required in the strategy routine
 * (e.g., sector size) must be filled in before calling us.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct buf *bp = NULL;
	char error;

	if ((error = initdisklabel(lp)))
		goto done;

	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	DL_SETBSTART(lp, 16);

	if (spoofonly)
		goto done;

	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, LABELSECTOR));
	if (error)
		goto done;

	error = checkdisklabel(bp->b_data + LABELOFFSET, lp,
	    16, DL_GETDSIZE(lp));
	if (error == 0)
		goto done;

#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 * Always allow writing of disk label; even if the disk is unlabeled.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	struct buf *bp = NULL;
	struct disklabel *dlp;
	int error = 0;

	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	/* Read it in, slap the new label in, and write it back out */
	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, LABELSECTOR));
	if (error)
		goto done;

	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
	*dlp = *lp;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Print out the name of the device; ex. TK50, RA80. DEC uses a common
 * disk type encoding scheme for most of its disks.
 */
void
disk_printtype(int unit, int type)
{
	printf(" drive %d: %c%c", unit, (int)MSCP_MID_CHAR(2, type),
	    (int)MSCP_MID_CHAR(1, type));
	if (MSCP_MID_ECH(0, type))
		printf("%c", (int)MSCP_MID_CHAR(0, type));
	printf("%d\n", MSCP_MID_NUM(type));
}
@


1.67
log
@Mechanical changes from manual buf set up to readdisksector().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.66 2011/07/06 18:32:59 miod Exp $	*/
@


1.66
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.65 2011/04/16 03:21:15 krw Exp $	*/
d76 2
a77 7
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp)) {
		error = bp->b_error;
a78 1
	}
d120 2
a121 6
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
@


1.65
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.64 2011/04/15 14:57:29 krw Exp $	*/
a50 2
#include "mba.h"

a162 47

#if NMBA > 0
/*
 * Be sure that the pages we want to do DMA to is actually there
 * by faking page-faults if necessary. If given a map-register address,
 * also map it in.
 */
void
disk_reallymapin(struct buf *bp, pt_entry_t *map, int reg, int flag)
{
	struct proc *p;
	volatile pt_entry_t *io;
	pt_entry_t *pte;
	struct pcb *pcb;
	int pfnum, npf, o;
	caddr_t addr;

	o = (int)bp->b_data & VAX_PGOFSET;
	npf = vax_atop(bp->b_bcount + o) + 1;
	addr = bp->b_data;
	p = bp->b_proc;

	/*
	 * Get a pointer to the pte pointing out the first virtual address.
	 * Use different ways in kernel and user space.
	 */
	if ((bp->b_flags & B_PHYS) == 0) {
		pte = kvtopte(addr);
		p = &proc0;
	} else {
		pcb = &p->p_addr->u_pcb;
		pte = uvtopte(addr, pcb);
	}

	if (map) {
		io = &map[reg];
		while (--npf > 0) {
			pfnum = (*pte & PG_FRAME);
			if (pfnum == 0)
				panic("mapin zero entry");
			pte++;
			*(int *)io++ = pfnum | flag;
		}
		*(int *)io = 0;
	}
}
#endif
@


1.64
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.63 2011/04/06 13:46:51 miod Exp $	*/
d80 1
a80 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d130 1
a130 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d138 1
a138 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.63
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.62 2011/02/26 13:07:48 krw Exp $	*/
d80 2
a81 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d130 2
a131 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d138 2
a139 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.62
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.61 2009/08/13 15:23:13 deraadt Exp $	*/
a58 1
 * Returns null on success and an error string on failure.
@


1.61
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.60 2009/08/13 15:23:11 deraadt Exp $	*/
d109 1
d146 1
@


1.60
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.59 2009/06/04 21:13:02 deraadt Exp $	*/
@


1.59
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.58 2008/08/14 11:41:30 martin Exp $	*/
d61 1
a61 1
char *
d66 1
a66 1
	char *msg;
d68 1
a68 1
	if ((msg = initdisklabel(lp)))
d84 1
a84 1
		msg = "I/O error";
d88 3
a90 2
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp, 16, DL_GETDSIZE(lp));
	if (msg == NULL)
d94 2
a95 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a96 1
	}
d99 2
a100 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a101 1
	}
d109 1
a109 1
	return (msg);
@


1.58
log
@convert the last traces of btoc/ctob macros

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.57 2008/06/12 06:58:38 deraadt Exp $	*/
d74 2
d88 1
a88 1
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp);
@


1.57
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.55 2008/06/10 20:50:23 beck Exp $	*/
d178 1
a178 1
	npf = vax_btoc(bp->b_bcount + o) + 1;
@


1.56
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.54 2007/07/13 20:24:44 miod Exp $	*/
d79 1
a79 1
	bp->b_flags = B_BUSY | B_READ;
d128 1
a128 1
	bp->b_flags = B_BUSY | B_READ;
d135 1
a135 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.55
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d79 1
a79 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d128 1
a128 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d135 1
a135 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.54
log
@Do not compile disk_reallymapin() unless it is really needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.53 2007/06/20 18:15:46 deraadt Exp $	*/
d79 1
a79 1
	bp->b_flags = B_BUSY | B_READ;
d128 1
a128 1
	bp->b_flags = B_BUSY | B_READ;
d135 1
a135 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.53
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.52 2007/06/17 00:27:29 deraadt Exp $	*/
d51 2
d161 1
d206 1
@


1.52
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.51 2007/06/14 03:37:23 deraadt Exp $	*/
d61 1
a61 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
a77 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
d114 1
a114 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
a124 1
	bp->b_cylinder = bp->b_blkno / lp->d_secpercyl;
@


1.51
log
@excessive blank lines making the versions different
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.50 2007/06/14 03:35:30 deraadt Exp $	*/
a30 2
 *
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
d64 1
a64 3
	struct disklabel *dlp;
	char *msg = NULL;
	int i;
d66 1
a66 7
	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
a67 12
	}
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64 * 1024;
d69 3
a71 1
	/* don't read the on-disk label if we are in spoofed-only mode */
a74 2
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;
d82 1
a82 11
	} else {
		dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
			msg = "no disk label";
		} else if (dlp->d_npartitions > MAXPARTITIONS ||
		    dkcksum(dlp) != 0)
			msg = "disk label corrupted";
		else {
			DL_SETDSIZE(dlp, DL_GETDSIZE(lp));
			*lp = *dlp;
		}
d85 4
d90 1
a90 1
	if (msg && iso_disklabelspoof(dev, strat, lp) == 0)
d92 2
d96 1
a96 1
	if (msg && udf_disklabelspoof(dev, strat, lp) == 0)
d98 2
a106 1
	disklabeltokernlabel(lp);
d123 3
a125 1
	bp->b_dev = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);
d127 1
a127 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
d135 1
a135 1
	bcopy(lp, dlp, sizeof(struct disklabel));
@


1.50
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.49 2007/06/14 03:29:34 deraadt Exp $	*/
a133 1

@


1.49
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.48 2007/06/12 20:57:43 deraadt Exp $	*/
d87 1
@


1.48
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.47 2007/06/09 23:06:46 krw Exp $	*/
d84 3
a86 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.47
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.46 2007/06/09 04:08:39 deraadt Exp $	*/
d127 1
a127 1
		bp->b_flags = B_INVAL | B_AGE | B_READ;
d143 1
a143 1
	struct buf *bp;
d152 1
a152 1
	bp->b_flags = B_READ;
d159 1
a159 1
	bp->b_flags = B_WRITE;
d164 4
a167 1
	brelse(bp);
@


1.46
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.45 2007/06/08 05:34:28 deraadt Exp $	*/
a51 55

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = DL_GETPOFFSET(&lp->d_partitions[RAW_PART]);
	int maxsz = DL_GETPSIZE(p);
	int sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return EOF. */
		if (bp->b_blkno == maxsz) {
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		/* Otherwise, truncate request. */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* overwriting disk label ? */
	if (bp->b_blkno + DL_GETPOFFSET(p) <= LABELSECTOR + labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + DL_GETPOFFSET(p)) / lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
}
@


1.45
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.44 2007/06/07 05:22:18 deraadt Exp $	*/
a188 51
/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *osdep)
{
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	while ((i = ffs(openmask)) != 0) {
		i--;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fragblock = opp->p_fragblock;
			npp->p_cpg = opp->p_cpg;
		}
	}
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
}
@


1.44
log
@best if this compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.43 2007/06/07 00:28:17 krw Exp $	*/
d166 1
@


1.43
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.42 2007/06/06 16:42:07 deraadt Exp $	*/
d62 1
@


1.42
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.41 2007/06/05 02:38:37 krw Exp $	*/
d78 1
a78 1
			return(0);
d92 2
a93 1
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
@


1.41
log
@bounds_check_with_label() checks for i/o outside of the partition and
for overwriting the disklabel. Reorder some checks so all copies of
bounds_check_with_label do the checks in the same order. Order picked
by using the currently most popular one. Should be no functional
change.

"If it's boring, commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2007/06/05 00:38:19 deraadt Exp $	*/
d98 1
a98 1
	bp->b_cylinder = (bp->b_blkno + DL_GETPOFFSET(p)) / lp->d_secpercyl;	
d115 2
a116 6
readdisklabel(dev, strat, lp, osdep, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int spoofonly;
d191 2
a192 4
setdisklabel(olp, nlp, openmask, osdep)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *osdep;
d207 1
a207 1
		
d212 1
a212 1
	while ((i = ffs((long)openmask)) != 0) {
d243 2
a244 5
writedisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
d271 1
a271 1
/*	
d274 3
a276 4
 */   
void  
disk_printtype(unit, type)
	int unit, type;
d291 1
a291 4
disk_reallymapin(bp, map, reg, flag)
	struct buf *bp;
	pt_entry_t *map;
	int reg, flag;
@


1.40
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.39 2007/06/02 02:35:27 krw Exp $	*/
a72 7
	/* overwriting disk label ? */
	if (bp->b_blkno + DL_GETPOFFSET(p) <= LABELSECTOR + labelsector &&
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}

d88 7
@


1.39
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.38 2007/05/31 22:31:04 krw Exp $	*/
d63 3
a65 3
	int labelsector = lp->d_partitions[RAW_PART].p_offset;
	int maxsz = p->p_size,
		sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d74 1
a74 1
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsector &&
d98 1
a98 1
	bp->b_cylinder = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;	
d130 2
a131 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d138 2
a139 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d141 3
a143 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
d225 2
a226 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
@


1.38
log
@RAW_PART is defined to be 2 in vax (like elsewhere) so use it rather
than 2.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37 2007/05/31 22:06:03 krw Exp $	*/
d186 1
a186 1
	cvtdisklabelv1(lp);
@


1.37
log
@Minor bounds_check_with_label nits.

1) Use local variable 'labelsector' not 'labelsect' to be consistant (hp300,
mac68k, mvme68k, mvme88k, vax).

2) Having checked for sz == 0, the next check needs only be sz < 0, not <= 0.
(mac68k, mvme68k, mvme88k)

3) Use lp->d_partitions + DISKPART(dev), rather than
lp->d_partitions[DISKPART(dev)] (hp300).

Assuming no typos there should be no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.36 2007/05/31 19:57:44 krw Exp $	*/
d63 1
a63 1
	int labelsector = lp->d_partitions[2].p_offset;
@


1.36
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.35 2007/05/29 06:28:15 otto Exp $	*/
d63 1
a63 1
	int labelsect = lp->d_partitions[2].p_offset;
d74 1
a74 1
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
@


1.35
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.34 2007/05/29 05:08:20 krw Exp $	*/
d59 2
a60 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct	buf *bp;
	struct	disklabel *lp;
	struct	cpu_disklabel *osdep;
	int	wlabel;
d82 1
a82 1
		/* if exactly at end of disk, return an EOF */
d87 1
a87 1
		/* or truncate if part of it fits */
d93 1
d99 1
a99 1
	return(1);
d103 1
a103 1
	return(-1);
@


1.34
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.33 2007/02/18 11:43:19 miod Exp $	*/
d188 1
d235 1
a235 2
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
@


1.33
log
@In writedisklabel(), read the disklabel sector before rewriting it, to
preserve the non-disklabel contents; otherwise altering your disklabel may
render your machine unbootable.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2006/10/21 16:01:54 krw Exp $	*/
d124 1
a124 1
	struct buf *bp;
d134 4
a137 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
d151 1
a151 1
		return (NULL);
d183 5
a187 2
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
@


1.32
log
@Some KNF cleanup.

De-register. Move declaration to top of function for DOS MBR
processing. Indent nit in macppc.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 2006/10/04 03:23:01 krw Exp $	*/
a255 4

	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
	bcopy(lp, dlp, sizeof(struct disklabel));

d260 7
d270 2
a272 1

@


1.31
log
@More tidying up after bad144. Remove references in comments and
don't include dkbad.h when nothing in it is used. Missed
arm/include/disklabel.h first time around.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 2006/08/17 10:34:14 krw Exp $	*/
d120 1
a120 1
	register struct disklabel *lp;
d124 1
a124 1
	register struct buf *bp;
d192 1
a192 1
	register struct disklabel *olp, *nlp;
d196 2
a197 2
	register int i;
	register struct partition *opp, *npp;
d248 1
a248 1
	register struct disklabel *lp;
@


1.30
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 2006/08/11 21:32:40 krw Exp $	*/
a37 1
#include <sys/dkbad.h>
@


1.29
log
@Use d_secperunit rather than 0x1fffffff as the default value for
RAW_PART's p_size. Since d_secperunit is initialized to 0x1fffffff if
not specified there should be no need to use the magic number again.
And if d_secperunit was specified then that value should be used
instead of the magic number.

This was already being done for hp300, luna88k, mac68k, mvme68k,
mvme88k.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 2006/07/19 20:19:59 miod Exp $	*/
d135 2
@


1.28
log
@Remove code checking for memory residence of pages in disk_reallymapin(),
it is not needed; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 2006/03/15 20:20:41 miod Exp $	*/
d141 1
a141 1
		lp->d_partitions[i].p_size = 0x1fffffff;
@


1.27
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 2006/01/20 23:27:26 miod Exp $	*/
d301 1
a301 1
	int pfnum, npf, o, i;
a320 15
	/*
	 * When we are doing DMA to user space, be sure that all pages
	 * we want to transfer to is mapped. WHY DO WE NEED THIS???
	 * SHOULDN'T THEY ALWAYS BE MAPPED WHEN DOING THIS???
	 */
	for (i = 0; i < (npf - 1); i++) {
		if ((pte[i] & PG_FRAME) == 0) {
			int rv;
			rv = uvm_fault(&p->p_vmspace->vm_map,
			    (unsigned)addr + i * VAX_NBPG, 0,
			    VM_PROT_READ|VM_PROT_WRITE);
			if (rv)
				panic("DMA to nonexistent page, %d", rv);
		}
	}
@


1.26
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.25 2005/12/22 02:51:25 krw Exp $	*/
a182 7
}

void 
dk_establish(p, q)
	struct disk *p;
	struct device *q;
{
@


1.25
log
@Set correct partition offset to 0 when initializing RAW_PART.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 2005/11/12 03:44:24 pedro Exp $	*/
d160 1
a160 1
		dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
d263 1
a263 1
	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
d311 1
a311 1
	o = (int)bp->b_un.b_addr & VAX_PGOFSET;
d313 1
a313 1
	addr = bp->b_un.b_addr;
@


1.24
log
@Make sure we only touch associated processes of physical buffers.
Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 2005/03/30 07:52:32 deraadt Exp $	*/
d142 1
a142 1
	lp->d_partitions[0].p_offset = 0;
@


1.23
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 2004/03/17 14:16:04 miod Exp $	*/
d322 1
a322 2
		if (p == 0)
			p = &proc0;
@


1.22
log
@Make sure disklabels use at least DEV_BSIZE as their sector size.
This allows the kernel to survive reading the disklabel off a 256-bytes/sector
scsi device...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 2003/11/10 21:05:06 miod Exp $	*/
d173 4
@


1.21
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2003/06/26 13:06:26 miod Exp $	*/
d131 2
@


1.20
log
@Compile the vax kernel with -Wmissing-prototypes -Wstrict-prototypes now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 2003/06/02 23:27:58 millert Exp $	*/
d295 1
a295 1
	struct pte *map;
d329 1
a329 1
		if ((pte + i)->pg_pfn == 0) {
d341 1
a341 1
			pfnum = pte->pg_pfn;
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 2002/04/29 19:12:31 miod Exp $	*/
d43 1
@


1.18
log
@Do not forget to invoke iso_disklabelspoof() to deal correctly with cd-rom.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 2002/03/14 01:26:48 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 2002/01/25 01:20:39 miod Exp $	*/
d171 6
@


1.16
log
@Bring disklabel code on par with other arches: recognize specific situations,
correctly initialize the label for a virgin disk with no existing
disklabel, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2001/11/06 19:53:17 miod Exp $	*/
d123 1
a123 1
	void (*strat) __P((struct buf *));
d244 1
a244 1
	void (*strat) __P((struct buf *));
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 2001/09/11 20:05:25 miod Exp $	*/
d131 1
d133 2
a134 1
	if (lp->d_npartitions == 0) { /* Assume no label */
d136 4
a139 3
		lp->d_npartitions = 3;
		lp->d_partitions[2].p_size = 0x1fffffff;
		lp->d_partitions[2].p_offset = 0;
d141 5
d171 1
a171 1
	bp->b_flags = B_INVAL | B_AGE;
d196 11
d210 1
d253 4
d259 1
a260 6
	bp->b_flags = B_READ;
	(*strat)(bp);
	if ((error = biowait(bp)))
		goto done;
	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
	bcopy(lp, dlp, sizeof(struct disklabel));
d264 1
a265 2
done:
	brelse(bp);
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 2002/01/25 01:20:39 miod Exp $	*/
a130 1
	int i;
d132 1
a132 2
	/* minimal requirements for archetypal disk label */
	if (lp->d_secperunit == 0)
d134 3
a136 4
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
a137 5
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = 0x1fffffff;
	lp->d_partitions[0].p_offset = 0;
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64 * 1024;
d163 1
a163 1
	bp->b_flags = B_INVAL | B_AGE | B_READ;
a187 11
	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}
		
a190 1

a232 4

	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
	bcopy(lp, dlp, sizeof(struct disklabel));

a234 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
d236 6
d245 2
a247 1

@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15.2.1 2002/01/31 22:55:27 niklas Exp $	*/
d123 1
a123 1
	void (*strat)(struct buf *);
a170 6

#if defined(CD9660)
	if (msg && iso_disklabelspoof(dev, strat, lp) == 0)
		msg = NULL;
#endif

d244 1
a244 1
	void (*strat)(struct buf *);
@


1.14
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 2000/10/18 21:00:40 mickey Exp $	*/
d48 1
a48 1
#include <vm/vm.h>
@


1.13
log
@typo in comment; from gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 2000/04/27 01:10:11 bjc Exp $	*/
a48 1
#include <vm/vm_kern.h>
@


1.12
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1999/01/08 04:29:10 millert Exp $	*/
d115 1
a115 1
 * using the indicated stategy routine.
@


1.11
log
@check for lp->d_secpercyl == 0) in bounds_check_with_label()
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.10 1998/10/03 21:18:56 millert Exp $	*/
/*	$NetBSD: disksubr.c,v 1.13 1997/07/06 22:38:26 ragge Exp $	*/
d46 1
d54 1
d56 1
a56 3
#include <arch/vax/mscp/mscp.h> /* For disk encoding scheme */

#define b_cylin b_resid
a69 1
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
d71 3
a73 3
	int labelsect = blockpersec(lp->d_partitions[2].p_offset, lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);
d82 1
a82 4
	if (bp->b_blkno + p->p_offset <= labelsect &&
#if LABELSECTOR != 0
	    bp->b_blkno + p->p_offset + sz > labelsect &&
#endif
d89 3
a91 4
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
		if (sz == 0) {
			/* if exactly at end of disk, return an EOF */
d95 3
a97 1
		if (sz < 0) {
a100 1
		/* or truncate if part of it fits */
d105 1
a105 2
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
	    lp->d_secpercyl;
d149 1
a149 1
	bp->b_cylin = LABELSECTOR / lp->d_secpercyl;
d153 2
a154 3
	} else for (dlp = (struct disklabel *)bp->b_un.b_addr;
	    dlp <= (struct disklabel *)(bp->b_un.b_addr+DEV_BSIZE-sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
d156 1
a156 6
			if (msg == NULL) {
#if defined(CD9660)
				if (iso_disklabelspoof(dev, strat, lp) != 0)
#endif
					msg = "no disk label";
			}
d158 1
a158 1
			   dkcksum(dlp) != 0)
a161 2
			msg = NULL;
			break;
d169 7
d186 1
a186 1
	register i;
d260 2
a261 2
	printf(" drive %d: %c%c", unit, MSCP_MID_CHAR(2, type),
	    MSCP_MID_CHAR(1, type));
d263 1
a263 1
		printf("%c", MSCP_MID_CHAR(0, type));
d278 1
d285 2
a286 2
	o = (int)bp->b_un.b_addr & PGOFSET;
	npf = btoc(bp->b_bcount + o) + 1;
d288 1
d296 2
d299 1
a299 1
		pcb = bp->b_proc->p_vmspace->vm_pmap.pm_pcb;
d311 3
a313 3
			rv = vm_fault(&bp->b_proc->p_vmspace->vm_map,
			    (unsigned)addr + i * NBPG,
			    VM_PROT_READ|VM_PROT_WRITE, FALSE);
@


1.11.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.13 2000/10/18 21:00:40 mickey Exp $	*/
/*	$NetBSD: disksubr.c,v 1.21 1999/06/30 18:48:06 ragge Exp $	*/
a45 1
#include <sys/user.h>
a52 1
#include <machine/cpu.h>
d54 3
a56 1
#include <vax/mscp/mscp.h> /* For disk encoding scheme */
d70 1
d72 3
a74 3
	int labelsect = lp->d_partitions[2].p_offset;
	int maxsz = p->p_size,
		sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d83 4
a86 1
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
d93 4
a96 3
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
d100 1
a100 3
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d104 1
d109 2
a110 1
	bp->b_cylinder = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;	
d120 1
a120 1
 * using the indicated strategy routine.
d154 1
a154 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
d158 3
a160 2
	} else {
		dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
d162 6
a167 1
			msg = "no disk label";
d169 1
a169 1
		    dkcksum(dlp) != 0)
d173 2
a181 7
void 
dk_establish(p, q)
	struct disk *p;
	struct device *q;
{
}

d192 1
a192 1
	register int i;
d266 2
a267 2
	printf(" drive %d: %c%c", unit, (int)MSCP_MID_CHAR(2, type),
	    (int)MSCP_MID_CHAR(1, type));
d269 1
a269 1
		printf("%c", (int)MSCP_MID_CHAR(0, type));
a283 1
	struct proc *p;
d290 2
a291 2
	o = (int)bp->b_un.b_addr & VAX_PGOFSET;
	npf = vax_btoc(bp->b_bcount + o) + 1;
a292 1
	p = bp->b_proc;
a299 2
		if (p == 0)
			p = &proc0;
d301 1
a301 1
		pcb = &p->p_addr->u_pcb;
d313 3
a315 3
			rv = uvm_fault(&p->p_vmspace->vm_map,
			    (unsigned)addr + i * VAX_NBPG, 0,
			    VM_PROT_READ|VM_PROT_WRITE);
@


1.11.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11.6.1 2001/05/14 21:38:49 niklas Exp $	*/
d49 1
@


1.11.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#include <uvm/uvm_extern.h>
@


1.11.6.4
log
@Merge in trunk
@
text
@a130 1
	int i;
d132 1
a132 2
	/* minimal requirements for archetypal disk label */
	if (lp->d_secperunit == 0)
d134 3
a136 4
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
a137 5
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = 0x1fffffff;
	lp->d_partitions[0].p_offset = 0;
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64 * 1024;
d163 1
a163 1
	bp->b_flags = B_INVAL | B_AGE | B_READ;
a187 11
	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}
		
a190 1

a232 4

	dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
	bcopy(lp, dlp, sizeof(struct disklabel));

a234 1
	bp->b_cylinder = LABELSECTOR / lp->d_secpercyl;
d236 6
d245 2
a247 1

@


1.11.6.5
log
@Merge in -current from about a week ago
@
text
@d123 1
a123 1
	void (*strat)(struct buf *);
d244 1
a244 1
	void (*strat)(struct buf *);
@


1.11.6.6
log
@Sync the SMP branch with 3.3
@
text
@a170 6

#if defined(CD9660)
	if (msg && iso_disklabelspoof(dev, strat, lp) == 0)
		msg = NULL;
#endif

@


1.11.6.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11.6.6 2003/03/27 23:52:20 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.6.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a42 1
#include <sys/disk.h>
d294 1
a294 1
	pt_entry_t *map;
d328 1
a328 1
		if ((pte[i] & PG_FRAME) == 0) {
d340 1
a340 1
			pfnum = (*pte & PG_FRAME);
@


1.11.6.9
log
@Merge with the trunk
@
text
@a130 2
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
@


1.10
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1997/09/12 09:30:54 maja Exp $	*/
d75 6
@


1.9
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 1997/08/08 21:46:57 niklas Exp $	*/
d121 1
a121 1
readdisklabel(dev, strat, lp, osdep)
d126 1
d138 4
@


1.8
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.7 1997/05/29 00:05:16 niklas Exp $	*/
/*	$NetBSD: disksubr.c,v 1.11 1997/01/11 11:24:51 ragge Exp $	*/
a57 5
int	cpu_setdisklabel __P((struct disklabel *, struct disklabel *, u_long,
	    struct cpu_disklabel *));
int	cpu_writedisklabel __P((dev_t, void (*)(struct buf *),
	    struct disklabel *, struct cpu_disklabel *));

a112 30
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(olp, nlp, openmask, osdep)
	register struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *osdep;
{
	return cpu_setdisklabel(olp, nlp, openmask, osdep);
}


/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat) __P((struct buf *));
	register struct disklabel *lp;
	struct cpu_disklabel *osdep;
{
	return cpu_writedisklabel(dev, strat, lp, osdep);
}
/*
 *	from: @@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
 */

/*
d131 1
a131 1
	if (lp->d_secperunit == 0)
d133 4
a136 4
	lp->d_npartitions = 1;
	if (lp->d_partitions[0].p_size == 0)
		lp->d_partitions[0].p_size = 0x1fffffff;
	lp->d_partitions[0].p_offset = 0;
d176 1
a176 1
cpu_setdisklabel(olp, nlp, openmask, osdep)
d215 1
d218 1
a218 1
cpu_writedisklabel(dev, strat, lp, osdep)
a225 1
	int labelpart;
a227 6
	labelpart = DISKPART(dev);
	if (lp->d_partitions[labelpart].p_offset != 0) {
		if (lp->d_partitions[0].p_offset != 0)
			return (EXDEV);			/* not quite right */
		labelpart = 0;
	}
d229 1
a229 1
	bp->b_dev = MAKEDISKDEV(major(dev), DISKUNIT(dev), labelpart);
d236 6
a241 14
	for (dlp = (struct disklabel *)bp->b_un.b_addr;
	    dlp <= (struct disklabel *)
	      (bp->b_un.b_addr + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic == DISKMAGIC && dlp->d_magic2 == DISKMAGIC &&
		    dkcksum(dlp) == 0) {
			*dlp = *lp;
			bp->b_flags = B_WRITE;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}
	}
	error = ESRCH;
@


1.7
log
@RCS tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1997/01/11 11:24:51 ragge Exp $	*/
d69 1
a69 1
bounds_check_with_label(bp, lp, wlabel)
d72 1
@


1.6
log
@attempt cd9660 & part/nblks fix
@
text
@d1 1
@


1.5
log
@sync with NetBSD 970112 -moj
@
text
@d73 1
d75 4
a78 3
	int labelsect = lp->d_partitions[2].p_offset;
	int maxsz = p->p_size,
		sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d80 1
a80 1
	if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
d82 1
a82 1
	    bp->b_blkno + p->p_offset + sz > LABELSECTOR + labelsect &&
d90 4
a93 3
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
d97 1
a97 3
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d101 1
d106 2
a107 1
	bp->b_cylin = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
d184 6
a189 2
			if (msg == NULL)
				msg = "no disk label";
@


1.4
log
@sync to 0611
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.10 1996/05/19 16:44:02 ragge Exp $	*/
d44 4
d50 2
d53 1
a53 4
/* XXX encoding of disk minor numbers, should be elsewhere... */
#define dkunit(dev)		(minor(dev) >> 3)
#define dkpart(dev)		(minor(dev) & 7)
#define dkminor(unit, part)	(((unit) << 3) | (part))
d55 1
a55 1
#define	b_cylin	b_resid
d73 1
a73 1
	struct partition *p = lp->d_partitions + dkpart(bp->b_dev);
d78 1
a78 1
        if (bp->b_blkno + p->p_offset <= LABELSECTOR + labelsect &&
d80 1
a80 1
            bp->b_blkno + p->p_offset + sz > LABELSECTOR + labelsect &&
d82 4
a85 4
            (bp->b_flags & B_READ) == 0 && wlabel == 0) {
                bp->b_error = EROFS;
                goto bad;
        }
d88 9
a96 9
        if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
                /* if exactly at end of disk, return an EOF */
                if (bp->b_blkno == maxsz) {
                        bp->b_resid = bp->b_bcount;
                        return(0);
                }
                /* or truncate if part of it fits */
                sz = maxsz - bp->b_blkno;
                if (sz <= 0) {
d98 1
a98 1
                        goto bad;
d100 2
a101 2
                bp->b_bcount = sz << DEV_BSHIFT;
        }
d104 1
a104 1
        bp->b_cylin = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
d233 2
a234 2
 	nlp->d_checksum = 0;
 	nlp->d_checksum = dkcksum(nlp);
a238 4
/* encoding of disk minor numbers, should be elsewhere... */
#define dkunit(dev)		(minor(dev) >> 3)
#define dkminor(unit, part)	(((unit) << 3) | (part))

d254 1
a254 1
	labelpart = dkpart(dev);
d261 1
a261 1
	bp->b_dev = makedev(major(dev), dkminor(dkunit(dev), labelpart));
d285 75
@


1.3
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.9 1996/04/08 18:32:35 ragge Exp $	*/
a43 1
#include <sys/cpu.h>
@


1.2
log
@from ragge; rip i386 code
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.7 1996/01/28 12:14:48 ragge Exp $	*/
d38 9
a46 7
#include "param.h"
#include "systm.h"
#include "buf.h"
#include "dkbad.h"
#include "disklabel.h"
#include "syslog.h"
#include "machine/macros.h"
d55 5
d114 1
d127 1
d130 1
a130 1
	void (*strat)();
d151 1
a151 1
	void (*strat)();
d199 1
d244 1
d247 1
a247 1
	int (*strat)();
d268 1
a268 1
	if (error = biowait(bp))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.6 1995/05/08 19:10:53 ragge Exp $	*/
a52 2
#define		RAW_PART	3

d59 4
a62 1
bounds_check_with_label(struct buf *bp, struct disklabel *lp, int wlabel)
d65 1
a65 1
	int labelsect = lp->d_partitions[0].p_offset;
a67 1

a68 1
	/* XXX should also protect bootstrap in first 8K */
a77 9
#if	defined(DOSBBSECTOR) && defined(notyet)
	/* overwriting master boot record? */
        if (bp->b_blkno + p->p_offset <= DOSBBSECTOR &&
            (bp->b_flags & B_READ) == 0 && wlabel == 0) {
                bp->b_error = EROFS;
                goto bad;
        }
#endif

a101 7

/* NYFIL */

/* encoding of disk minor numbers, should be elsewhere... */
#define dkunit(dev)		(minor(dev) >> 3)
#define dkpart(dev)		(minor(dev) & 7)
#define dkminor(unit, part)	(((unit) << 3) | (part))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
