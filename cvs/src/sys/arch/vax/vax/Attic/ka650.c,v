head	1.23;
access;
symbols
	OPENBSD_5_9:1.22.0.6
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.8
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.12
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.8
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.6
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.4
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.10
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.8
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.13.0.20
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.18
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.16
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.14
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.12
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.10
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.8
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.23
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.22;
commitid	OSDG2O3Cgeifnf1W;

1.22
date	2014.05.08.19.06.07;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2011.09.19.21.53.02;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2011.09.15.00.48.24;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.06.20.42.05;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.18.23.07.26;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.15.22.47.45;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.15.22.38.23;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.08.14.11.41.30;	author martin;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.29.21.34.17;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.27.01.10.12;	author bjc;	state Exp;
branches;
next	1.6;

1.6
date	97.09.12.09.30.55;	author maja;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	97.09.10.12.04.47;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	97.05.29.00.05.21;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.25.13;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	96.05.03.09.10.14;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.14.00.09;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2001.05.14.21.39.00;	author niklas;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.6.12.3;

1.6.12.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.6.12.4;

1.6.12.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.6.12.5;

1.6.12.5
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	1.6.12.6;

1.6.12.6
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: ka650.c,v 1.22 2014/05/08 19:06:07 miod Exp $	*/
/*	$NetBSD: ka650.c,v 1.25 2001/04/27 15:02:37 ragge Exp $	*/
/*
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mt. Xinu.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ka650.c	7.7 (Berkeley) 12/16/90
 */

/*
 * vax650-specific code.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <uvm/uvm_extern.h>

#include <machine/cvax.h>
#include <machine/ka650.h>
#include <machine/clock.h>
#include <machine/cpu.h>
#include <machine/psl.h>
#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/nexus.h>

struct	ka650_merr *ka650merr_ptr;
struct	ka650_cbd *ka650cbd_ptr;
struct	ka650_ipcr *ka650ipcr_ptr;
int	*KA650_CACHE_ptr;

#define	CACHEOFF	0
#define	CACHEON		1

static	void	ka650setcache(int);
static	void    uvaxIII_conf(void);
static	void    uvaxIII_memerr(void);
static	int     uvaxIII_mchk(caddr_t);

struct	cpu_dep	ka650_calls = {
	NULL,
	uvaxIII_mchk,
	uvaxIII_memerr,
	uvaxIII_conf,
	generic_clkread,
	generic_clkwrite,
	4,      /* ~VUPS */
	2,	/* SCB pages */
	cvax_halt,
	cvax_reboot,
	NULL,
	icr_hardclock
};

/*
 * uvaxIII_conf() is called by cpu_attach to do the cpu_specific setup.
 */
void
uvaxIII_conf()
{
	/*
	 * MicroVAX III: We map in memory error registers,
	 * cache control registers, SSC registers,
	 * interprocessor registers and cache diag space.
	 */
	ka650merr_ptr = (void *)vax_map_physmem(KA650_MERR, 1);
	ka650cbd_ptr = (void *)vax_map_physmem(KA650_CBD, 1);
	cvax_ssc_ptr = (void *)vax_map_physmem(CVAX_SSC, 3);
	ka650ipcr_ptr = (void *)vax_map_physmem(KA650_IPCR, 1);
	KA650_CACHE_ptr = (void *)vax_map_physmem(KA650_CACHE,
	    (KA650_CACHESIZE/VAX_NBPG));

	printf("cpu: KA6%d%d, CVAX microcode rev %d Firmware rev %d\n",
	    vax_cpustype == VAX_STYP_640 ? 4 : 5,
	    vax_cpustype == VAX_STYP_655 ? 5 : 0,
	    (vax_cpudata & 0xff), GETFRMREV(vax_siedata));
	ka650setcache(CACHEON);
	if (ptoa(physmem) > ka650merr_ptr->merr_qbmbr) {
		printf("physmem(0x%lx) > qbmbr(0x%lx)\n",
		    ptoa(physmem), ka650merr_ptr->merr_qbmbr);
		panic("qbus map unprotected");
	}
	if (mfpr(PR_TODR) == 0)
		mtpr(1, PR_TODR);
}

void
uvaxIII_memerr()
{
	printf("memory err!\n");
#if 0 /* XXX Fix this */
	register char *cp = (char *)0;
	register int m;
	extern u_int cache2tag;

	if (ka650cbd.cbd_cacr & CACR_CPE) {
		printf("cache 2 tag parity error: ");
		if (time_second - cache2tag < 7) {
			ka650setcache(CACHEOFF);
			printf("caching disabled\n");
		} else {
			cache2tag = time_second;
			printf("flushing cache\n");
			ka650setcache(CACHEON);
		}
	}
	m = ka650merr.merr_errstat;
	ka650merr.merr_errstat = MEM_EMASK;
	if (m & MEM_CDAL) {
		cp = "Bus Parity";
	} else if (m & MEM_RDS) {
		cp = "Hard ECC";
	} else if (m & MEM_CRD) {
		cp = "Soft ECC";
	}
	if (cp) {
		printf("%sMemory %s Error: page 0x%x\n",
			(m & MEM_DMA) ? "DMA " : "", cp,
			(m & MEM_PAGE) >> MEM_PAGESHFT);
	}
#endif
}

u_int	cache1tag;
u_int	cache1data;
u_int	cdalerr;
u_int	cache2tag;

int
uvaxIII_mchk(cmcf)
	caddr_t cmcf;
{
	struct cvax_mchk_frame *mcf = (struct cvax_mchk_frame *)cmcf;
	u_int type = mcf->cvax_summary;
	const char *descr;
	u_int i;

	printf("machine check %x", type);
	descr = cvax_mchk_descr(type);
	if (descr != NULL)
		printf(": %s", descr);
	printf("\n\tvap %x istate1 %x istate2 %x pc %x psl %x\n",
	    mcf->cvax_mrvaddr, mcf->cvax_istate1, mcf->cvax_istate2,
	    mcf->cvax_pc, mcf->cvax_psl);
	printf("dmaser=0x%lb qbear=0x%lx dmaear=0x%lx\n",
	    ka650merr_ptr->merr_dser, DMASER_BITS, 
	    ka650merr_ptr->merr_qbear,
	    ka650merr_ptr->merr_dear);
	ka650merr_ptr->merr_dser = DSER_CLEAR;

	i = mfpr(PR_CAER);
	mtpr(CAER_MCC | CAER_DAT | CAER_TAG, PR_CAER);
	if (i & CAER_MCC) {
		printf("cache 1 ");
		if (i & CAER_DAT) {
			printf("data");
			i = cache1data;
			cache1data = time_second;
		}
		if (i & CAER_TAG) {
			printf("tag");
			i = cache1tag;
			cache1tag = time_second;
		}
	} else if ((i & CAER_MCD) || (ka650merr_ptr->merr_errstat & MEM_CDAL)) {
		printf("CDAL");
		i = cdalerr;
		cdalerr = time_second;
	}
	if (time_second - i < 7) {
		ka650setcache(CACHEOFF);
		printf(" parity error:	caching disabled\n");
	} else {
		printf(" parity error:	flushing cache\n");
		ka650setcache(CACHEON);
	}
	/*
	 * May be able to recover if type is 1-4, 0x80 or 0x81, but
	 * only if FPD is set in the saved PSL, or bit VCR in Istate2
	 * is clear.
	 */
	if ((type > 0 && type < 5) || type == 0x80 || type == 0x81) {
		if ((mcf->cvax_psl & PSL_FPD)
		    || !(mcf->cvax_istate2 & IS2_VCR)) {
			uvaxIII_memerr();
			return MCHK_RECOVERED;
		}
	}
	return MCHK_PANIC;
}

/*
 * Make sure both caches are off and not in diagnostic mode.  Clear the
 * 2nd level cache (by writing to each quadword entry), then enable it.
 * Enable 1st level cache too.
 */
void
ka650setcache(int state)
{
	int i;

	/*
	 * Before doing anything, disable the cache.
	 */
	mtpr(0, PR_CADR);
	if (vax_cpustype != VAX_STYP_640)
		ka650cbd_ptr->cbd_cacr = CACR_CPE;

	/*
	 * Check what we want to do, enable or disable.
	 */
	if (state == CACHEON) {
		mtpr(CADR_SEN2 | CADR_SEN1 | CADR_CENI | CADR_CEND, PR_CADR);
		if (vax_cpustype != VAX_STYP_640) {
			for (i = 0;
			    i < (KA650_CACHESIZE / sizeof(KA650_CACHE_ptr[0]));
			    i += 2)
				KA650_CACHE_ptr[i] = 0;
			ka650cbd_ptr->cbd_cacr = CACR_CEN;
		}
	}
}
@


1.22
log
@Format string fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.21 2011/09/19 21:53:02 miod Exp $	*/
@


1.21
log
@Try and clean system type constants a bit:
- save the second byte of vax_siedata into a new variable, vax_cpustype,
  and use it instead of (vax_siedata >> 8) & 0xff or other similar
  constructs.
- the VAX_SIE_KAxxx constants are duplicates of the VAX_STYP_xx constants.
  Standardize on the latter and kill the former.
- only keep VAX_VTYP_xx constants for KA46 and KA47, those are the only
  systems which use these constants and are told apart by a different
  SIE byte.

No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.20 2011/09/15 00:48:24 miod Exp $	*/
d109 2
a110 2
		printf("physmem(0x%x) > qbmbr(0x%x)\n",
		    ptoa(physmem), (int)ka650merr_ptr->merr_qbmbr);
d175 1
a175 1
	printf("dmaser=0x%b qbear=0x%x dmaear=0x%x\n",
d177 2
a178 2
	    (int)ka650merr_ptr->merr_qbear,
	    (int)ka650merr_ptr->merr_dear);
@


1.20
log
@Switch vax to timecounters. There are three different clock sources:
- ICR/NICR on most systems (1MHz counter resolution).
- diagnostic timer on KA46/KA48 (1kHz counter resolution, counter is actually
  running at around 1024 kHz but is not guaranteed to be monotonic at this
  rate).
- 100Hz clock on VXT (nothing but the 100Hz clock interrupt).

Tested on KA49 (ICR style), KA46, KA48 (diagtmr style), VXT2000+ (VXT
{empty,hopeless}ness'r'us style).
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.19 2011/07/06 20:42:05 miod Exp $	*/
a90 2
	int syssub = GETSYSSUBT(vax_siedata);

d104 2
a105 2
	    syssub == VAX_SIE_KA640 ? 4 : 5,
	    syssub == VAX_SIE_KA655 ? 5 : 0,
a229 1
	int syssub = GETSYSSUBT(vax_siedata);
d236 1
a236 1
	if (syssub != VAX_SIE_KA640)
d244 1
a244 1
		if (syssub != VAX_SIE_KA640) {
@


1.19
log
@Drop cpu_dep.cpu_subconf routine, which is no longer used after KA820 support
removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.18 2008/08/18 23:07:26 miod Exp $	*/
d82 1
a82 1
	hardclock
d130 1
a130 1
		if (time.tv_sec - cache2tag < 7) {
d134 1
a134 1
			cache2tag = time.tv_sec;
d190 1
a190 1
			cache1data = time.tv_sec;
d195 1
a195 1
			cache1tag = time.tv_sec;
d200 1
a200 1
		cdalerr = time.tv_sec;
d202 1
a202 1
	if (time.tv_sec - i < 7) {
@


1.18
log
@Move common CVAX defines and code (internal cache IPR, SSC layout, machine
check frame format...) to a single place. Get rid of duplicated KAxx_FOO
constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.17 2008/08/18 23:05:38 miod Exp $	*/
a80 1
	NULL,
@


1.17
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.16 2008/08/15 22:47:45 miod Exp $	*/
d48 1
d55 1
a58 1
struct	ka650_ssc *ka650ssc_ptr;
a65 2
static	void	ka650_halt(void);
static	void	ka650_reboot(int);
d79 2
a80 2
	ka650_halt,
	ka650_reboot,
d101 1
a101 1
	ka650ssc_ptr = (void *)vax_map_physmem(KA650_SSC, 3);
a156 8
#define NMC650	15
char *mc650[] = {
	0,			"FPA proto err",	"FPA resv inst",
	"FPA Ill Stat 2",	"FPA Ill Stat 1",	"PTE in P0, TB miss",
	"PTE in P1, TB miss",	"PTE in P0, Mod",	"PTE in P1, Mod",
	"Illegal intr IPL",	"MOVC state error",	"bus read error",
	"SCB read error",	"bus write error",	"PCB write error"
};
a161 10
struct mc650frame {
	int	mc65_bcnt;		/* byte count == 0xc */
	int	mc65_summary;		/* summary parameter */
	int	mc65_mrvaddr;		/* most recent vad */
	int	mc65_istate1;		/* internal state */
	int	mc65_istate2;		/* internal state */
	int	mc65_pc;		/* trapped pc */
	int	mc65_psl;		/* trapped psl */
};

d166 4
a169 3
	register struct mc650frame *mcf = (struct mc650frame *)cmcf;
	register u_int type = mcf->mc65_summary;
	register u_int i;
d172 3
a174 4
	if (type >= 0x80 && type <= 0x83)
		type -= 0x80 - 11;
	if (type < NMC650 && mc650[type])
		printf(": %s", mc650[type]);
d176 2
a177 2
	    mcf->mc65_mrvaddr, mcf->mc65_istate1, mcf->mc65_istate2,
	    mcf->mc65_pc, mcf->mc65_psl);
d215 3
a217 3
	if ((type > 0 && type < 5) || type == 11 || type == 12) {
		if ((mcf->mc65_psl & PSL_FPD)
		    || !(mcf->mc65_istate2 & IS2_VCR)) {
d219 1
a219 1
			return 0;
d222 1
a222 1
	return -1;
a255 14
}

static void
ka650_halt()
{
	ka650ssc_ptr->ssc_cpmbx = CPMB650_DOTHIS | CPMB650_HALT;
	asm("halt");
}

static void
ka650_reboot(arg)
	int arg;
{
	ka650ssc_ptr->ssc_cpmbx = CPMB650_DOTHIS | CPMB650_REBOOT;
@


1.16
log
@Fix array index computation in the machine check handler. Gives fatal bus errors
a chance to be reported correctly...
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.15 2008/08/15 22:38:23 miod Exp $	*/
d82 3
@


1.15
log
@Rename the cpu_dep hook ``steal_pages'' to ``init'', as it serves as an
early initialization routine (to enable caches, etc) while still running
physical, and does not allocate memory anymore.

(The irony in this is that forthcoming KA60 support actually steals pages
 in its init function...)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.14 2008/08/14 11:41:30 martin Exp $	*/
d188 1
a188 1
		type -= (0x80 + 11);
@


1.14
log
@convert the last traces of btoc/ctob macros

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.13 2004/01/29 21:34:17 deraadt Exp $	*/
d72 1
a72 1
	0, /* No special page stealing anymore */
@


1.13
log
@typos; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.12 2003/06/02 23:27:59 millert Exp $	*/
d109 1
a109 1
	if (ctob(physmem) > ka650merr_ptr->merr_qbmbr) {
d111 1
a111 1
		    ctob(physmem), (int)ka650merr_ptr->merr_qbmbr);
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.11 2002/03/14 01:26:48 millert Exp $	*/
d131 1
a131 1
			printf("cacheing disabled\n");
d221 1
a221 1
		printf(" parity error:	cacheing disabled\n");
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.10 2001/11/06 19:53:17 miod Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.9 2001/09/11 20:05:25 miod Exp $	*/
d68 6
a73 6
static	void	ka650setcache __P((int));
static	void	ka650_halt __P((void));
static	void	ka650_reboot __P((int));
static	void    uvaxIII_conf __P((void));
static	void    uvaxIII_memerr __P((void));
static	int     uvaxIII_mchk __P((caddr_t));
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.10 2001/11/06 19:53:17 miod Exp $	*/
d68 6
a73 6
static	void	ka650setcache(int);
static	void	ka650_halt(void);
static	void	ka650_reboot(int);
static	void    uvaxIII_conf(void);
static	void    uvaxIII_memerr(void);
static	int     uvaxIII_mchk(caddr_t);
@


1.9
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.8 2001/08/25 13:33:37 hugh Exp $	*/
d50 1
a50 1
#include <vm/vm.h>
@


1.8
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.7 2000/04/27 01:10:12 bjc Exp $	*/
a50 1
#include <vm/vm_kern.h>
@


1.7
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 2
a2 2
/*	$OpenBSD: ka650.c,v 1.6 1997/09/12 09:30:55 maja Exp $	*/
/*	$NetBSD: ka650.c,v 1.20 1999/08/07 10:36:49 ragge Exp $	*/
d113 1
a113 2
	if (syssub != VAX_SIE_KA640)
		ka650setcache(CACHEON);
d252 1
a252 1
ka650setcache(state)
d254 2
a255 1
	register int i;
d261 2
a262 1
	ka650cbd_ptr->cbd_cacr = CACR_CPE;
a267 4
		for (i = 0; i < (KA650_CACHESIZE / sizeof(KA650_CACHE_ptr[0]));
		    i += 2)
			KA650_CACHE_ptr[i] = 0;
		ka650cbd_ptr->cbd_cacr = CACR_CEN;
d269 7
@


1.6
log
@Sync with NetBSD 970827. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: ka650.c,v 1.5 1997/09/10 12:04:47 maja Exp $	*/
/*	$NetBSD: ka650.c,v 1.10 1997/07/26 10:12:48 ragge Exp $	*/
a57 1
#include <machine/nexus.h>
a59 2
#include <vax/vax/gencons.h>

a64 1
static	int subtyp;
d69 6
a74 3
void	ka650setcache __P((int));
static void ka650_halt __P((void));
static void ka650_reboot __P((int));
d77 1
a77 2
	uvaxIII_steal_pages,
	no_nicr_clock,
d84 1
a84 4
	0,      /* Used by vaxstation */
	0,      /* Used by vaxstation */
	0,      /* Used by vaxstation */
	0,
d93 1
a93 3
uvaxIII_conf(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
d95 1
a95 3
	extern	char cpu_model[];
	int syssub = GETSYSSUBT(subtyp);
	char *str;
d98 3
a100 3
	 * There are lots of different MicroVAX III models, we should
	 * check which hereas there are some differences in the setup code
	 * that depends on this.
d102 13
a114 23
	strcpy(cpu_model,"MicroVAX ");
	switch (syssub) {
	case VAX_SIE_KA640:
		str = "3300/3400";
		break;

	case VAX_SIE_KA650:
		str = "3500/3600";
		break;

	case VAX_SIE_KA655:
		str = "3800/3900";
		break;

	default:
		str = "III";
		break;
	}
	strcat(cpu_model, str);
	printf(": %s\n",cpu_model);
	printf("%s: CVAX microcode rev %d Firmware rev %d\n", self->dv_xname,
	    (vax_cpudata & 0xff), GETFRMREV(subtyp));
	ka650setcache(CACHEON);
d120 2
a121 43
}

void
uvaxIII_steal_pages()
{
	extern	vm_offset_t avail_start, virtual_avail, avail_end;
	int	junk, *jon;

	/*
	 * MicroVAX III: We steal away 64 pages from top of memory,
	 * map in SCB, interrupt vectors, Qbus map registers, memory
	 * error registers, cache control registers, SSC registers,
	 * interprocessor registers and cache diag space.
	 */
	avail_end -= 64 * NBPG;

	MAPPHYS(junk, 2, VM_PROT_READ|VM_PROT_WRITE); /* SCB & vectors */
	MAPVIRT(nexus, btoc(0x400000)); /* Qbus map registers */
	pmap_map((vm_offset_t)nexus, 0x20088000, 0x20090000,
	    VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(ka650merr_ptr, 1); /* mem err & mem config regs */
	pmap_map((vm_offset_t)ka650merr_ptr, (vm_offset_t)KA650_MERR,
	    KA650_MERR + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(ka650cbd_ptr, 1); /* cache control & boot/diag regs */
	pmap_map((vm_offset_t)ka650cbd_ptr, (vm_offset_t)KA650_CBD,
	    KA650_CBD + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(ka650ssc_ptr, 3); /* SSC regs (& console prog mail box) */
	pmap_map((vm_offset_t)ka650ssc_ptr, (vm_offset_t)KA650_SSC,
	    KA650_SSC + NBPG * 3, VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(ka650ipcr_ptr, 1); /* InterProcessor Com Regs */
	pmap_map((vm_offset_t)ka650ipcr_ptr, (vm_offset_t)KA650_IPCR,
	    KA650_IPCR + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(KA650_CACHE_ptr, 128); /* Cache Diagnostic space (for flush) */
	pmap_map((vm_offset_t)KA650_CACHE_ptr, (vm_offset_t)KA650_CACHE,
	    KA650_CACHE + KA650_CACHESIZE, VM_PROT_READ|VM_PROT_WRITE);

	jon = (int *)0x20040004;
	subtyp = *jon;
a286 2
	mtpr(GC_BOOT, PR_TXDB);
	asm("movl %0,r5;halt"::"g"(arg));
a287 1

@


1.6.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: ka650.c,v 1.7 2000/04/27 01:10:12 bjc Exp $	*/
/*	$NetBSD: ka650.c,v 1.20 1999/08/07 10:36:49 ragge Exp $	*/
d58 1
d61 2
d68 1
d73 3
a75 6
static	void	ka650setcache __P((int));
static	void	ka650_halt __P((void));
static	void	ka650_reboot __P((int));
static	void    uvaxIII_conf __P((void));
static	void    uvaxIII_memerr __P((void));
static	int     uvaxIII_mchk __P((caddr_t));
d78 2
a79 1
	0, /* No special page stealing anymore */
d86 4
a89 1
	2,	/* SCB pages */
d98 3
a100 1
uvaxIII_conf()
d102 3
a104 1
	int syssub = GETSYSSUBT(vax_siedata);
d107 3
a109 3
	 * MicroVAX III: We map in memory error registers,
	 * cache control registers, SSC registers,
	 * interprocessor registers and cache diag space.
d111 23
a133 13
	ka650merr_ptr = (void *)vax_map_physmem(KA650_MERR, 1);
	ka650cbd_ptr = (void *)vax_map_physmem(KA650_CBD, 1);
	ka650ssc_ptr = (void *)vax_map_physmem(KA650_SSC, 3);
	ka650ipcr_ptr = (void *)vax_map_physmem(KA650_IPCR, 1);
	KA650_CACHE_ptr = (void *)vax_map_physmem(KA650_CACHE,
	    (KA650_CACHESIZE/VAX_NBPG));

	printf("cpu: KA6%d%d, CVAX microcode rev %d Firmware rev %d\n",
	    syssub == VAX_SIE_KA640 ? 4 : 5,
	    syssub == VAX_SIE_KA655 ? 5 : 0,
	    (vax_cpudata & 0xff), GETFRMREV(vax_siedata));
	if (syssub != VAX_SIE_KA640)
		ka650setcache(CACHEON);
d139 43
a181 2
	if (mfpr(PR_TODR) == 0)
		mtpr(1, PR_TODR);
d347 2
d350 1
@


1.6.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ka650.c,v 1.6.12.1 2001/05/14 21:39:00 niklas Exp $	*/
/*	$NetBSD: ka650.c,v 1.25 2001/04/27 15:02:37 ragge Exp $	*/
d51 1
d113 2
a114 1
	ka650setcache(CACHEON);
d253 1
a253 1
ka650setcache(int state)
d255 1
a255 2
	int syssub = GETSYSSUBT(vax_siedata);
	int i;
d261 1
a261 2
	if (syssub != VAX_SIE_KA640)
		ka650cbd_ptr->cbd_cacr = CACR_CPE;
d267 4
a271 7
		if (syssub != VAX_SIE_KA640) {
			for (i = 0;
			    i < (KA650_CACHESIZE / sizeof(KA650_CACHE_ptr[0]));
			    i += 2)
				KA650_CACHE_ptr[i] = 0;
			ka650cbd_ptr->cbd_cacr = CACR_CEN;
		}
@


1.6.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
#include <uvm/uvm_extern.h>
@


1.6.12.4
log
@Merge in -current from about a week ago
@
text
@d68 6
a73 6
static	void	ka650setcache(int);
static	void	ka650_halt(void);
static	void	ka650_reboot(int);
static	void    uvaxIII_conf(void);
static	void    uvaxIII_memerr(void);
static	int     uvaxIII_mchk(caddr_t);
@


1.6.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka650.c,v 1.6.12.4 2002/03/28 11:26:46 niklas Exp $	*/
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.12.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d131 1
a131 1
			printf("caching disabled\n");
d221 1
a221 1
		printf(" parity error:	caching disabled\n");
@


1.5
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: ka650.c,v 1.4 1997/05/29 00:05:21 niklas Exp $	*/
/*	$NetBSD: ka650.c,v 1.9 1997/02/19 10:04:16 ragge Exp $	*/
d61 2
d74 2
d89 3
a91 1

d168 1
a168 1
	MAPVIRT(ka650ssc_ptr, 1); /* SSC regs (& console prog mail box) */
d170 1
a170 1
	    KA650_SSC + NBPG, VM_PROT_READ|VM_PROT_WRITE);
d334 17
@


1.4
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: ka650.c,v 1.7 1997/01/11 11:31:57 ragge Exp $	*/
/*	$NetBSD: ka650.c,v 1.7 1997/01/11 11:31:57 ragge Exp $	*/
d54 1
d59 1
d68 19
a86 2
void	ka650encache __P((void));
void	ka650discache __P((void));
d97 2
d102 2
a103 1
	 * check which here. but that later...
d105 23
a127 3
	strcpy(cpu_model,"MicroVAX III");
	printf(": %s\n", cpu_model);
	ka650encache();
d190 1
a190 1
			ka650discache();
d195 1
a195 1
			ka650encache();
d280 1
a280 1
		ka650discache();
d284 1
a284 1
		ka650encache();
d307 1
a307 1
ka650encache()
d311 3
a313 10
	ka650discache();
	for (i = 0; i < (KA650_CACHESIZE / sizeof(KA650_CACHE_ptr[0])); i += 2)
		KA650_CACHE_ptr[i] = 0;
	ka650cbd_ptr->cbd_cacr = CACR_CEN;
	mtpr(CADR_SEN2 | CADR_SEN1 | CADR_CENI | CADR_CEND, PR_CADR);
}

void
ka650discache()
{
d316 11
@


1.3
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.2
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: ka650.c,v 1.3 1996/04/08 18:32:41 ragge Exp $	*/
d83 1
a134 7
int
uvaxIII_clock()
{
	mtpr(0x40, PR_ICCS); /* Start clock and enable interrupt */
	return 1;
}

d238 1
a238 1
		printf(" parity error:  cacheing disabled\n");
d240 1
a240 1
		printf(" parity error:  flushing cache\n");
@


1.1
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: ka650.c,v 1.1 1995/12/13 18:45:52 ragge Exp $	*/
d44 13
a56 13
#include "sys/param.h"
#include "sys/time.h"
#include "sys/kernel.h"
#include "sys/systm.h"
#include "sys/device.h"
#include "vm/vm.h"
#include "vm/vm_kern.h"

#include "machine/ka650.h"
#include "machine/cpu.h"
#include "machine/psl.h"
#include "machine/mtpr.h"
#include "machine/nexus.h"
d65 3
d86 1
a86 1
		    ctob(physmem), ka650merr_ptr->merr_qbmbr);
d91 1
a131 1
	return 0;
d134 1
d141 1
d201 1
d218 3
a220 2
	    ka650merr_ptr->merr_dser, DMASER_BITS, ka650merr_ptr->merr_qbear,
	    ka650merr_ptr->merr_dear);
d269 1
d281 1
@
