head	1.20;
access;
symbols
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.14
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2007.05.04.03.44.44;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2006.11.06.20.28.23;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.27.18.31.11;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.25.23.02.26;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.17.02.37.20;	author hugh;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.11.10.12.46;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.11.09.36.24;	author hugh;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.15.22.45.33;	author miod;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.04.09.00.59.30;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.09.23.11.57;	author bjc;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.27.01.10.13;	author bjc;	state Exp;
branches;
next	1.7;

1.7
date	97.09.27.17.04.11;	author niklas;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.09.10.12.04.51;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.00.05.24;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.25.22;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.10.23;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.31.05.26.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.05.14.21.39.09;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2001.07.04.10.24.42;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.7.12.5;

1.7.12.5
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	;

1.11.4.1
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@/*	$OpenBSD: rootfil.c,v 1.19 2006/11/06 20:28:23 miod Exp $	*/
/*	$NetBSD: rootfil.c,v 1.14 1996/10/13 03:35:58 christos Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: machdep.c 1.63 91/04/24
 *
 *	@@(#)machdep.c	7.16 (Berkeley) 6/3/91
 */
 /* All bugs are subject to removal without further notice */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/mbuf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disklabel.h>

#include <dev/cons.h>

#include <machine/macros.h>
#include <machine/nexus.h>
#include <machine/sid.h>
#include <machine/disklabel.h>
#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/rpb.h>

#include "hp.h"
#include "ra.h"
#include "sd.h"
#include "asc.h"

void    setroot(void);
void    diskconf(void);
static  int getstr(char *, int);
struct  device *parsedisk(char *, int, int, dev_t *);
static  struct device *getdisk(char *, int, int, dev_t *);
int     findblkmajor(struct device *);
char    *findblkname(int);

struct  ngcconf {
        struct  cfdriver *ng_cf;
        dev_t   ng_root;
};

int	findblkmajor(struct device *);

struct device *bootdv = NULL;
int booted_partition;	/* defaults to 0 (aka 'a' partition */

extern dev_t rootdev, dumpdev;

#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
setroot()
{
	struct swdevt *swp;
	int  len, majdev, unit, part = 0;
	dev_t nrootdev, nswapdev, temp;
	extern int boothowto;
	struct device *dv;
	char buf[128];
#if defined(NFSCLIENT)
        extern char *nfsbootdevname;
#endif

	if (rpb.rpb_base != (void *)-1) {
#if DEBUG
		printf("booted from type %d unit %d csr 0x%lx adapter %lx slave %d\n",
		    rpb.devtyp, rpb.unit, rpb.csrphy, rpb.adpphy, rpb.slave);
#endif
		bootdev = MAKEBOOTDEV(rpb.devtyp, 0, 0, rpb.unit, 0);
	}

#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#endif

	printf("booted from device: %s\n",
	    bootdv ? bootdv->dv_xname : "<unknown>");

	if (bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK
					? booted_partition + 'a' : ' ');
			printf(": ");
                        len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, booted_partition, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
                        len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			part = booted_partition;
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname, part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
}

struct nam2blk {
        char *name;
        int maj;
} nam2blk[] = {
        { "ra",          9 },
        { "rx",         12 },
        { "rl",         14 },
	{ "hd",		19 },
        { "sd",         20 },
        { "rd",         23 },
        { "raid",       25 },
        { "cd",         61 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
        int maj;
{
        int i;

        for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
                if (nam2blk[i].maj == maj)
                        return (nam2blk[i].name);
        return (NULL);
}


static struct device *
getdisk(str, len, defpart, devp)
        char *str;
        int len, defpart;
        dev_t *devp;
{
        struct device *dv;

        if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
                printf("use one of:");
#ifdef RAMDISK_HOOKS
                printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
                        if (dv->dv_class == DV_DISK)
                                printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
                        if (dv->dv_class == DV_IFNET)
                                printf(" %s", dv->dv_xname);
#endif
                }
                printf("\n");
        }
        return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
        char *str;
        int len, defpart;
        dev_t *devp;
{
        struct device *dv;
        char *cp, c;
        int majdev, unit, part;

        if (len == 0)
                return (NULL);
        cp = str + len - 1;
        c = *cp;
        if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
                part = c - 'a';
                *cp = '\0';
        } else
                part = defpart;

#ifdef RAMDISK_HOOKS
        if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
                dv = &fakerdrootdev;
                goto gotdisk;
        }
#endif

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
                if (dv->dv_class == DV_DISK &&
                    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
                        majdev = findblkmajor(dv);
                        unit = dv->dv_unit;
                        if (majdev < 0)
                                panic("parsedisk");
                        *devp = MAKEDISKDEV(majdev, unit, part);
                        break;
                }
#ifdef NFSCLIENT
                if (dv->dv_class == DV_IFNET &&
                    strcmp(str, dv->dv_xname) == 0) {
                        *devp = NODEV;
                        break;
                }
#endif
        }

        *cp = c;
        return (dv);
}

static int
getstr(char *buf, int size) {
	int len;
	cnpollc(1);
	len = getsn(buf, size);
	cnpollc(0);
	return (len);
}
@


1.19
log
@Sync the VS2000 (and some VS3100) MFM controller driver with NetBSD, and
enable it in GENERIC and RAMDISK.
Completely untested due to lack of hardware (both my VS3100 are dual-SCSI),
but it hopefully can't hurt.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.18 2005/12/27 18:31:11 miod Exp $	*/
@


1.18
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.17 2004/12/25 23:02:26 miod Exp $	*/
d292 1
@


1.17
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.16 2003/06/02 23:27:59 millert Exp $	*/
a409 26
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	u_int maj;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {

		maj = major(swp->sw_dev);
		if (maj > nblkdev) /* paranoid? */
			break;

		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks > 0 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.15 2003/05/11 19:41:12 deraadt Exp $	*/
d337 1
a337 2
                for (dv = alldevs.tqh_first; dv != NULL;
                    dv = dv->dv_list.tqe_next) {        
d377 1
a377 1
        for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.15
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.14 2002/09/17 02:37:20 hugh Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@Switch device register routine from last match to first match. Fixes
problems one of my machines was having with phantom scsi luns and no
way to discern which one was the boot device.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.13 2002/06/11 10:12:46 hugh Exp $	*/
d143 1
a143 1
				strcpy(buf, bootdv->dv_xname);
@


1.13
log
@Nuke unused function.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.12 2002/06/11 09:36:24 hugh Exp $	*/
d87 1
a87 1
struct device *bootdv;
@


1.12
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.11 2001/06/15 22:45:33 miod Exp $	*/
a415 49

#if 0
static int
getstr(cp, size)
        char *cp;
        int size;
{
        char *lp;
        int c;
        int len;

        lp = cp;
        len = 0;
        for (;;) {
                c = cngetc();
                switch (c) {
                case '\n':
                case '\r':
                        printf("\n");
                        *lp++ = '\0';
                        return (len);
                case '\b':
                case '\177':
                case '#':
                        if (len) {
                                --len;
                                --lp;
                                printf("\b \b");
                        }
                        continue;
                case '@@':
                case 'u'&037:
                        len = 0;
                        lp = cp;
                        printf("\n");
                        continue;
                default:
                        if (len + 1 >= size || c < ' ') {
                                printf("\007");
                                continue;
                        }
                        printf("%c", c);
                        ++len;
                        *lp++ = c;
                }
        }
}

#endif
@


1.11
log
@Compile kernel with -Wall, and fix a few issues for this to work.
ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.10 2001/04/09 00:59:30 hugh Exp $	*/
d55 3
d72 7
a78 1
extern dev_t rootdev, dumpdev;
d85 11
d104 3
a106 2
	int  majdev, mindev, unit, part, controller, adaptor;
	dev_t orootdev;
d108 17
a124 1
	char *uname;
d126 4
a129 2
	if ((bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC) {
		printf("RPB data looks bogus, prompting user\n");
d131 114
d247 16
a262 2
	if (((boothowto & RB_DFLTROOT) || (rootdev != NODEV))
	    && !(boothowto & RB_ASKNAME))
d264 1
d266 20
a285 2
	if (boothowto & RB_ASKNAME) {
		printf("root device selection is not currently supported\n");
d287 14
d302 38
a339 12
        majdev = bdevtomaj(B_TYPE(bootdev));
        if (majdev >= nblkdev || majdev == -1)
                return;
        adaptor = B_ADAPTOR(bootdev);
        controller = B_CONTROLLER(bootdev);
        part = B_PARTITION(bootdev);
        unit = B_UNIT(bootdev);

	switch (majdev) {
	case 0:	/* MBA disk */
#if NHP
		if ((mindev = hp_getdev(adaptor, unit, &uname)) < 0)
d341 13
a353 2
			return;
		break;
d355 25
a379 3
	case 9:	/* MSCP disk */
#if NRA
		if ((mindev = ra_getdev(adaptor, controller, unit, &uname)) < 0)
a380 2
			return;
		break;
d382 5
a386 3
	case 20:	/* SCSI disk */
#if NASC || NSD
		if((mindev = sd_getdev(adaptor, controller, part, unit, &uname)) < 0)
d388 19
a406 2
			return;
		break;
d408 8
a415 3
	default:
		return;
	}
d417 45
a461 15
	mindev *= MAXPARTITIONS;
	mindev += part;
        orootdev = rootdev;
        rootdev = makedev(majdev, mindev);

	swdevt[0].sw_dev = dumpdev = makedev(major(rootdev), 1);

        /*
         * If the original rootdev is the same as the one
         * just calculated, don't need to adjust the swap configuration.
         */
        if (rootdev == orootdev)
		printf("Setting root device to %s%c\n", uname, part + 'a');
	else
		printf("Changing root device to %s%c\n", uname, part + 'a');
d463 2
@


1.11.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.11 2001/06/15 22:45:33 miod Exp $	*/
a54 3
#include <sys/disklabel.h>

#include <dev/cons.h>
d69 1
a69 7
void    setroot(void);
void    diskconf(void);
static  int getstr(char *, int);
struct  device *parsedisk(char *, int, int, dev_t *);
static  struct device *getdisk(char *, int, int, dev_t *);
int     findblkmajor(struct device *);
char    *findblkname(int);
a75 11
int	findblkmajor(struct device *);

struct device *bootdv = NULL;
int booted_partition;	/* defaults to 0 (aka 'a' partition */

extern dev_t rootdev, dumpdev;

#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

d84 2
a85 3
	struct swdevt *swp;
	int  len, majdev, unit, part = 0;
	dev_t nrootdev, nswapdev, temp;
d87 1
a87 5
	struct device *dv;
	char buf[128];
#if defined(NFSCLIENT)
        extern char *nfsbootdevname;
#endif
d89 3
a91 6
	if (rpb.rpb_base != (void *)-1) {
#if DEBUG
		printf("booted from type %d unit %d csr 0x%lx adapter %lx slave %d\n",
		    rpb.devtyp, rpb.unit, rpb.csrphy, rpb.adpphy, rpb.slave);
#endif
		bootdev = MAKEBOOTDEV(rpb.devtyp, 0, 0, rpb.unit, 0);
d94 3
a96 9
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#endif

	printf("booted from device: %s\n",
	    bootdv ? bootdv->dv_xname : "<unknown>");

	if (bootdv == NULL)
		boothowto |= RB_ASKNAME;
d99 1
a99 112
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK
					? booted_partition + 'a' : ' ');
			printf(": ");
                        len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, booted_partition, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
                        len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			part = booted_partition;
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		return;
d102 12
a113 6
	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
d115 1
a115 6
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname, part + 'a');
a116 65
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
}

struct nam2blk {
        char *name;
        int maj;
} nam2blk[] = {
        { "ra",          9 },
        { "rx",         12 },
        { "rl",         14 },
        { "sd",         20 },
        { "rd",         23 },
        { "raid",       25 },
        { "cd",         61 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
        int maj;
{
        int i;

        for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
                if (nam2blk[i].maj == maj)
                        return (nam2blk[i].name);
        return (NULL);
}
d118 6
d125 3
a127 52
static struct device *
getdisk(str, len, defpart, devp)
        char *str;
        int len, defpart;
        dev_t *devp;
{
        struct device *dv;

        if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
                printf("use one of:");
#ifdef RAMDISK_HOOKS
                printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
                for (dv = alldevs.tqh_first; dv != NULL;
                    dv = dv->dv_list.tqe_next) {        
                        if (dv->dv_class == DV_DISK)
                                printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
                        if (dv->dv_class == DV_IFNET)
                                printf(" %s", dv->dv_xname);
#endif
                }
                printf("\n");
        }
        return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
        char *str;
        int len, defpart;
        dev_t *devp;
{
        struct device *dv;
        char *cp, c;
        int majdev, unit, part;

        if (len == 0)
                return (NULL);
        cp = str + len - 1;
        c = *cp;
        if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
                part = c - 'a';
                *cp = '\0';
        } else
                part = defpart;

#ifdef RAMDISK_HOOKS
        if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
                dv = &fakerdrootdev;
                goto gotdisk;
        }
d129 2
d132 3
a134 21
        for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
                if (dv->dv_class == DV_DISK &&
                    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
                        majdev = findblkmajor(dv);
                        unit = dv->dv_unit;
                        if (majdev < 0)
                                panic("parsedisk");
                        *devp = MAKEDISKDEV(majdev, unit, part);
                        break;
                }
#ifdef NFSCLIENT
                if (dv->dv_class == DV_IFNET &&
                    strcmp(str, dv->dv_xname) == 0) {
                        *devp = NODEV;
                        break;
                }
#endif
        }
d136 15
a150 11
        *cp = c;
        return (dv);
}

static int
getstr(char *buf, int size) {
	int len;
	cnpollc(1);
	len = getsn(buf, size);
	cnpollc(0);
	return (len);
@


1.11.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d143 1
a143 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
@


1.10
log
@Amputate some dead and broken code and rework the rest to do the
right thing if booting off something other than sd0a.
RB_ASKNAME will be reimplemented later.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.9 2000/10/09 23:11:57 bjc Exp $	*/
d85 1
a85 3
	dev_t temp = 0, orootdev;
	struct ngcconf *nc;
	extern struct ngcconf ngcconf[];
a86 1
	char name[128];
@


1.9
log
@code to get asc* (ncr 53c9x) working; most of this from netbsd
also, write the correct stuff in cpu_coredump (vm_machdep.c)
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.8 2000/04/27 01:10:13 bjc Exp $	*/
a68 4
#define DOSWAP                  /* Change swdevt, argdev, and dumpdev too */
#ifdef MAJA
u_long  bootdev;                /* should be dev_t, but not until 32 bits */
#endif
d71 4
a74 2
#define PARTITIONMASK   0x7
#define PARTITIONSHIFT  3
d86 2
a87 1
	struct swdevt *swp;
d89 1
d92 13
a104 3
        if (boothowto & RB_DFLTROOT ||
           (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
                return;
d139 2
d143 3
a145 2
	swdevt[0].sw_dev = dumpdev =
		makedev(major(rootdev), 1);
d151 3
a153 25
                return;

        printf("Changing root device to %s%c\n", uname, part + 'a');

#ifdef DOSWAP
        mindev &= ~PARTITIONMASK;
        for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
                if (majdev == major(swp->sw_dev) &&
                    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
                        temp = swdevt[0].sw_dev;
                        swdevt[0].sw_dev = swp->sw_dev;
                        swp->sw_dev = temp;
                        break;
                }
        }
        if (swp->sw_dev == NODEV)
                return;

        /*
         * If argdev and dumpdev were the same as the old primary swap
         * device, move them to the new primary swap device.
         */
        if (temp == dumpdev)
                dumpdev = swdevt[0].sw_dev;
#endif
a180 2


@


1.8
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.7 1997/09/27 17:04:11 niklas Exp $	*/
d62 1
d67 1
d93 1
a93 1
            (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
d119 2
a120 2
#if NSD
		if((mindev = sd_getdev(adaptor, controller, part, unit, &uname)) < 0) 
d131 2
d144 1
a144 1
        for (swp = swdevt; swp->sw_dev; swp++) {
d153 1
a153 1
        if (swp->sw_dev == 0)
d190 2
@


1.7
log
@Fix swapconf.c so it will not crash swap on nfs envs
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.6 1997/09/10 12:04:51 maja Exp $	*/
d59 1
d65 1
d84 3
a86 3
        int  majdev, mindev, unit, part, controller, adaptor;
        dev_t temp = 0, orootdev;
        struct swdevt *swp;
d93 2
a94 2
        majdev = B_TYPE(bootdev);
        if (majdev >= nblkdev)
d116 7
a126 1
        mindev = (mindev << PARTITIONSHIFT) + part;
@


1.7.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.10 2001/04/09 00:59:30 hugh Exp $	*/
a58 1
#include <machine/disklabel.h>
a60 1
#include <machine/rpb.h>
a63 2
#include "sd.h"
#include "asc.h"
d65 4
d71 2
a72 4
struct  ngcconf {
        struct  cfdriver *ng_cf;
        dev_t   ng_root;
};
d82 3
a84 4
	int  majdev, mindev, unit, part, controller, adaptor;
	dev_t temp = 0, orootdev;
	struct ngcconf *nc;
	extern struct ngcconf ngcconf[];
a85 1
	char name[128];
d88 5
a92 15
	if ((bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC) {
		printf("RPB data looks bogus, prompting user\n");
		boothowto |= RB_ASKNAME;
	}

	if (((boothowto & RB_DFLTROOT) || (rootdev != NODEV))
	    && !(boothowto & RB_ASKNAME))
		return;

	if (boothowto & RB_ASKNAME) {
		printf("root device selection is not currently supported\n");
	}

        majdev = bdevtomaj(B_TYPE(bootdev));
        if (majdev >= nblkdev || majdev == -1)
a113 7
	case 20:	/* SCSI disk */
#if NASC || NSD
		if((mindev = sd_getdev(adaptor, controller, part, unit, &uname)) < 0)
#endif
			return;
		break;

d118 1
a118 2
	mindev *= MAXPARTITIONS;
	mindev += part;
a120 3

	swdevt[0].sw_dev = dumpdev = makedev(major(rootdev), 1);

d126 25
a150 3
		printf("Setting root device to %s%c\n", uname, part + 'a');
	else
		printf("Changing root device to %s%c\n", uname, part + 'a');
@


1.7.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.7.12.1 2001/05/14 21:39:09 niklas Exp $	*/
d85 3
a87 1
	dev_t orootdev;
d89 1
@


1.7.12.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a54 3
#include <sys/disklabel.h>

#include <dev/cons.h>
d69 1
a69 7
void    setroot(void);
void    diskconf(void);
static  int getstr(char *, int);
struct  device *parsedisk(char *, int, int, dev_t *);
static  struct device *getdisk(char *, int, int, dev_t *);
int     findblkmajor(struct device *);
char    *findblkname(int);
a75 11
int	findblkmajor(struct device *);

struct device *bootdv = NULL;
int booted_partition;	/* defaults to 0 (aka 'a' partition */

extern dev_t rootdev, dumpdev;

#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

d84 2
a85 3
	struct swdevt *swp;
	int  len, majdev, unit, part = 0;
	dev_t nrootdev, nswapdev, temp;
d87 1
a87 5
	struct device *dv;
	char buf[128];
#if defined(NFSCLIENT)
        extern char *nfsbootdevname;
#endif
d89 3
a91 6
	if (rpb.rpb_base != (void *)-1) {
#if DEBUG
		printf("booted from type %d unit %d csr 0x%lx adapter %lx slave %d\n",
		    rpb.devtyp, rpb.unit, rpb.csrphy, rpb.adpphy, rpb.slave);
#endif
		bootdev = MAKEBOOTDEV(rpb.devtyp, 0, 0, rpb.unit, 0);
d94 3
a96 9
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#endif

	printf("booted from device: %s\n",
	    bootdv ? bootdv->dv_xname : "<unknown>");

	if (bootdv == NULL)
		boothowto |= RB_ASKNAME;
d99 1
a99 112
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK
					? booted_partition + 'a' : ' ');
			printf(": ");
                        len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, booted_partition, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
                        len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			part = booted_partition;
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		return;
d102 12
a113 6
	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
d115 1
a115 6
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname, part + 'a');
a116 65
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
}

struct nam2blk {
        char *name;
        int maj;
} nam2blk[] = {
        { "ra",          9 },
        { "rx",         12 },
        { "rl",         14 },
        { "sd",         20 },
        { "rd",         23 },
        { "raid",       25 },
        { "cd",         61 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
        int maj;
{
        int i;

        for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
                if (nam2blk[i].maj == maj)
                        return (nam2blk[i].name);
        return (NULL);
}
d118 6
d125 3
a127 52
static struct device *
getdisk(str, len, defpart, devp)
        char *str;
        int len, defpart;
        dev_t *devp;
{
        struct device *dv;

        if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
                printf("use one of:");
#ifdef RAMDISK_HOOKS
                printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
                for (dv = alldevs.tqh_first; dv != NULL;
                    dv = dv->dv_list.tqe_next) {        
                        if (dv->dv_class == DV_DISK)
                                printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
                        if (dv->dv_class == DV_IFNET)
                                printf(" %s", dv->dv_xname);
#endif
                }
                printf("\n");
        }
        return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
        char *str;
        int len, defpart;
        dev_t *devp;
{
        struct device *dv;
        char *cp, c;
        int majdev, unit, part;

        if (len == 0)
                return (NULL);
        cp = str + len - 1;
        c = *cp;
        if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
                part = c - 'a';
                *cp = '\0';
        } else
                part = defpart;

#ifdef RAMDISK_HOOKS
        if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
                dv = &fakerdrootdev;
                goto gotdisk;
        }
d129 2
d132 3
a134 21
        for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
                if (dv->dv_class == DV_DISK &&
                    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
                        majdev = findblkmajor(dv);
                        unit = dv->dv_unit;
                        if (majdev < 0)
                                panic("parsedisk");
                        *devp = MAKEDISKDEV(majdev, unit, part);
                        break;
                }
#ifdef NFSCLIENT
                if (dv->dv_class == DV_IFNET &&
                    strcmp(str, dv->dv_xname) == 0) {
                        *devp = NODEV;
                        break;
                }
#endif
        }
d136 15
a150 11
        *cp = c;
        return (dv);
}

static int
getstr(char *buf, int size) {
	int len;
	cnpollc(1);
	len = getsn(buf, size);
	cnpollc(0);
	return (len);
@


1.7.12.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.7.12.3 2003/03/27 23:52:20 niklas Exp $	*/
d143 1
a143 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
@


1.7.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.7.12.4 2003/05/13 19:41:10 ho Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.5 1997/05/29 00:05:24 niklas Exp $	*/
d159 18
a176 12
        register struct swdevt *swp;
        register int nblks;

        for (swp = swdevt; swp->sw_dev; swp++)
		if (swp->sw_dev != NODEV &&bdevsw[major(swp->sw_dev)].d_psize){
                        nblks =
                          (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
                        if (nblks != -1 &&
                            (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
                                swp->sw_nblks = nblks;
                }
        dumpconf();
@


1.5
log
@RCS tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: rootfil.c,v 1.14 1996/10/13 03:35:58 christos Exp $	*/
d66 1
d68 1
@


1.4
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.3
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: rootfil.c,v 1.11 1996/04/08 18:32:54 ragge Exp $	*/
a60 3
#include <vax/uba/ubavar.h>

#include "uda.h"
d62 1
a67 20
static  char devname[][2] = {
        {'h','p'},        /* 0 = hp */
        {0,0},            /* 1 = ht */
        {'u','p'},        /* 2 = up */
        {'r','k'},        /* 3 = hk */
        {0,0},            /* 4 = sw */
        {0,0},            /* 5 = tm */
        {0,0},            /* 6 = ts */
        {0,0},            /* 7 = mt */
        {0,0},            /* 8 = tu */
        {'r','a'},        /* 9 = ra */
        {0,0},            /* 10 = ut */
        {'r','b'},        /* 11 = rb */
        {0,0},            /* 12 = uu */
        {0,0},            /* 13 = rx */
        {'r','l'},        /* 14 = rl */
        {0,0},            /* 15 = tmscp */
        {'k','r'},        /* 16 = ra on kdb50 */
};

a80 3
#if NUDA > 0
	extern struct uba_device ubdinit[];
#endif
d83 1
d89 1
a89 1
        if (majdev >= sizeof(devname) / sizeof(devname[0]))
d95 6
a100 4
        if (majdev == 0) {      /* MBA device */
#if NHP > 0
		mindev = hp_getdev(adaptor, unit);
		if (mindev < 0)
d102 5
a106 2
#else
                return;
d108 6
a113 2
        } else {
                register struct uba_device *ubap;
a114 12
                for (ubap = ubdinit; ubap->ui_driver; ubap++){
                        if (ubap->ui_alive && ubap->ui_slave == unit &&
                           ubap->ui_ctlr == controller &&
                           ubap->ui_ubanum == adaptor &&
                           ubap->ui_driver->ud_dname[0] == devname[majdev][0] &&
                           ubap->ui_driver->ud_dname[1] == devname[majdev][1])
                                break;
		}
                if (ubap->ui_driver == 0)
                        return;
                mindev = ubap->ui_unit;
        }
d125 1
a125 3
        printf("Changing root device to %c%c%d%c\n",
                devname[majdev][0], devname[majdev][1],
                mindev >> PARTITIONSHIFT, part + 'a');
a146 3
        panic("autoconf.c: argdev\n");
/*      if (temp == argdev)
                argdev = swdevt[0].sw_dev; */
@


1.2
log
@from ragge;
Make use of the new disk struct when attaching disks.
Don't rely on UBA's; we do not always want them.
@
text
@d1 1
a1 1
/*	$NetBSD: rootfil.c,v 1.7 1996/01/28 12:09:34 ragge Exp $	*/
d47 16
a62 5
#include "param.h"
#include "vax/include/sid.h"
#include "buf.h"
#include "mbuf.h"
#include "vax/include/pte.h"
d64 1
a64 5
#include "reboot.h"
#include "conf.h"
#include "vax/include/macros.h"
#include "vax/include/nexus.h"
#include "vax/uba/ubavar.h"
d71 17
a87 17
        'h','p',        /* 0 = hp */
        0,0,            /* 1 = ht */
        'u','p',        /* 2 = up */
        'r','k',        /* 3 = hk */
        0,0,            /* 4 = sw */
        0,0,            /* 5 = tm */
        0,0,            /* 6 = ts */
        0,0,            /* 7 = mt */
        0,0,            /* 8 = tu */
        'r','a',        /* 9 = ra */
        0,0,            /* 10 = ut */
        'r','b',        /* 11 = rb */
        0,0,            /* 12 = uu */
        0,0,            /* 13 = rx */
        'r','l',        /* 14 = rl */
        0,0,            /* 15 = tmscp */
        'k','r',        /* 16 = ra on kdb50 */
d98 1
d102 1
a102 1
        dev_t temp, orootdev;
d120 4
a123 37
#if NMBA > 0
                register struct mba_device *mbap;
                int mask;

/*
 * The MBA number used at boot time is not necessarily the same as the
 * MBA number used by the kernel.  In order to change the rootdev we need to
 * convert the boot MBA number to the kernel MBA number.  The address space
 * for an MBA used by the boot code is 0x20010000 + 0x2000 * MBA_number
 * on the 78? and 86?0, 0xf28000 + 0x2000 * MBA_number on the 750.
 * Therefore we can search the mba_hd table for the MBA that has the physical
 * address corresponding to the boot MBA number.
 */
#define PHYSADRSHFT     13
#define PHYSMBAMASK780  0x7
#define PHYSMBAMASK750  0x3

                switch (MACHID(cpu_type)) {

                case VAX_780:
/*              case VAX_8600: */
                default:
                        mask = PHYSMBAMASK780;
                        break;

                case VAX_750:
                        mask = PHYSMBAMASK750;
                        break;
                }
                for (mbap = mbdinit; mbap->driver; mbap++)
                        if (mbap->alive && mbap->drive == unit &&
                            (((long)mbap->hd->mh_physmba >> PHYSADRSHFT)
                              & mask) == adaptor)
                                break;
                if (mbap->driver == 0)
                        return;
                mindev = mbap->unit;
a130 1
			printf("ubap %x\n",ubap);
a140 1
		printf("mindev %x, majdev %x\n",mindev,majdev);
d185 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: rootfil.c,v 1.6 1995/04/12 15:35:04 ragge Exp $	*/
a52 1
#include "uba.h"
a151 1
#if NUBA > 0
a167 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
