head	1.26;
access;
symbols
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.14
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.12
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.8
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.6
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.8
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.4
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.19.0.10
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.8
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.8.0.12
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.25;
commitid	OSDG2O3Cgeifnf1W;

1.25
date	2015.02.07.00.09.09;	author miod;	state Exp;
branches;
next	1.24;
commitid	Qe3vArVvKm8Wjnss;

1.24
date	2011.09.15.00.48.24;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.18.23.19.29;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.15.22.41.48;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.27.16.55.41;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.21.18.39.57;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.19.21.27.07;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.14.21.35.50;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.11.06.34.37;	author hugh;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.27.01.10.11;	author bjc;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.11.02.44.32;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	97.09.10.12.04.42;	author maja;	state Exp;
branches
	1.8.12.1;
next	1.7;

1.7
date	97.05.29.00.05.13;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.25.05;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.06.12.08.20.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.09.10.05;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.14.00.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches;
next	;

1.8.12.1
date	2001.05.14.21.38.43;	author niklas;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.8.12.4;

1.8.12.4
date	2002.03.30.08.27.12;	author niklas;	state Exp;
branches;
next	1.8.12.5;

1.8.12.5
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.8.12.6;

1.8.12.6
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	1.8.12.7;

1.8.12.7
date	2004.06.05.23.11.03;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: clock.c,v 1.25 2015/02/07 00:09:09 miod Exp $	 */
/*	$NetBSD: clock.c,v 1.35 2000/06/04 06:16:58 matt Exp $	 */
/*
 * Copyright (c) 1995 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timetc.h>

#include <dev/clock_subr.h>

#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/clock.h>
#include <machine/cpu.h>
#include <machine/uvax.h>

struct evcount clock_intrcnt;
uint32_t icr_count;

#if defined(VAX46) || defined(VAX48)
u_int	vax_diagtmr_get_tc(struct timecounter *);

/*
 * This counter is only reliable in millisecond units.  See comments in
 * vax_diagtmr_get_tc() for details.
 */
struct timecounter vax_diagtmr_tc = {
	.tc_get_timecount = vax_diagtmr_get_tc,
	.tc_counter_mask = 0xffff,	/* 16 bits */
	.tc_frequency = 1000,		/* 1kHz */
	/* tc_name will be filled in */
	.tc_quality = 100
};
#endif

#ifdef VXT
u_int	vax_vxt_get_tc(struct timecounter *);

struct timecounter vax_vxt_tc = {
	.tc_get_timecount = vax_vxt_get_tc,
	.tc_counter_mask = 0xffffffff,
	.tc_frequency = 100,		/* 100Hz */
	.tc_name = "vxt",
	.tc_quality = 0
};
#endif

u_int	vax_icr_get_tc(struct timecounter *);

struct timecounter vax_icr_tc = {
	.tc_get_timecount = vax_icr_get_tc,
	.tc_counter_mask = 0xffffffff,
	.tc_frequency = 1000000,	/* 1MHz */
	.tc_name = "icr",
	.tc_quality = 100
};

/*
 * Sets year to the year in fs_time and then calculates the number of
 * 100th of seconds in the current year and saves that info in year_len.
 * fs_time contains the time set in the superblock in the root filesystem.
 * If the clock is started, it then checks if the time is valid
 * compared with the time in fs_time. If the clock is stopped, an
 * alert is printed and the time is temporary set to the time in fs_time.
 */

void
inittodr(time_t fs_time)
{
	int rv, deltat;
	struct timespec ts;

	rv = (*dep_call->cpu_clkread)(&ts, fs_time);
	if (rv != 0) {
		/* No useable information from system clock */
		ts.tv_sec = fs_time;
		ts.tv_nsec = 0;
		resettodr();
	} else {
		/* System clock OK, no warning if we don't want to. */
		deltat = ts.tv_sec - fs_time;

		if (deltat < 0)
			deltat = -deltat;
		if (deltat >= 2 * SEC_PER_DAY) {
			printf("clock has %s %d days",
			    ts.tv_sec < fs_time ? "lost" : "gained",
			    deltat / SEC_PER_DAY);
			rv = EINVAL;
		}
	}

	if (rv != 0)
		printf(" -- CHECK AND RESET THE DATE!\n");

	tc_setclock(&ts);
}

/*   
 * Resettodr restores the time of day hardware after a time change.
 */

void
resettodr()
{
	(*dep_call->cpu_clkwrite)();
}

/*
 * A delayloop that delays about the number of milliseconds that is
 * given as argument.
 */
void
delay(int i)
{
	asm ("1: sobgtr %0, 1b" : : "r" (dep_call->cpu_vups * i));
}

/*
 * On all VAXen there are a microsecond clock that should
 * be used for interval interrupts. We have to be wary of the few CPUs
 * which don't implement the ICR interval register.
 */
void
cpu_initclocks()
{
	switch (vax_boardtype) {
#ifdef VAX46
	/* VAXstation 4000/60: no ICR register but a specific timer */
	case VAX_BTYP_46:
	    {
		extern struct vs_cpu *ka46_cpu;

		vax_diagtmr_tc.tc_priv = ka46_cpu;
		vax_diagtmr_tc.tc_name = "KA46";
		tc_init(&vax_diagtmr_tc);
	    }
		break;
#endif
#ifdef VAX48
	/* VAXstation 4000/VLC: no ICR register but a specific timer */
	case VAX_BTYP_48:
	    {
		extern struct vs_cpu *ka48_cpu;

		vax_diagtmr_tc.tc_priv = ka48_cpu;
		vax_diagtmr_tc.tc_name = "KA48";
		tc_init(&vax_diagtmr_tc);
	    }
		break;
#endif
#ifdef VXT
	/* VXT2000: neither NICR nor ICR registers, no known other timer. */
	case VAX_BTYP_VXT:
		tc_init(&vax_vxt_tc);
		break;
#endif
	/* all other systems: NICR+ICR registers implementing a 1MHz timer. */
	default:
		tc_init(&vax_icr_tc);
		break;
	}

	evcount_attach(&clock_intrcnt, "clock", NULL);
	if (vax_boardtype != VAX_BTYP_VXT)
		mtpr(-tick, PR_NICR); /* Load in count register */
	mtpr(ICCS_ERR | ICCS_OFLOW | ICCS_INTENA | ICCS_RESET | ICCS_RUN,
	    PR_ICCS); /* Reset errors, start clock and enable interrupt */
}

void
icr_hardclock(struct clockframe *cf)
{
	icr_count += 10000;	/* tick */
	hardclock(cf);
}

/*
 * There are two types of real-time battery-backed up clocks on
 * VAX computers, one with a register that counts up every 1/100 second,
 * one with a clock chip that delivers time. For the register clock
 * we have a generic version, and for the chip clock there are 
 * support routines for time conversion.
 */
/*
 * Converts a year to corresponding number of ticks.
 */
int
yeartonum(int y)
{
	int n;

	for (n = 0, y -= 1; y > 69; y--)
		n += SECPERYEAR(y);
	return n;
}

/* 
 * Converts tick number to a year 70 ->
 */
int
numtoyear(int num)
{
	int y = 70, j;
	while (num >= (j = SECPERYEAR(y))) {
		y++;
		num -= j;
	}
	return y;
}

#if VAX650 || VAX660 || VAX670 || VAX680 || VAX53
/*
 * Reads the TODR register; returns 0 if a valid time has been found, EINVAL
 * otherwise.  The year is based on the argument year; the TODR doesn't hold
 * years.
 */
int
generic_clkread(struct timespec *ts, time_t base)
{
	uint32_t klocka = mfpr(PR_TODR);

	/*
	 * Sanity check.
	 */
	if (klocka < TODRBASE) {
		if (klocka == 0)
			printf("TODR stopped");
		else
			printf("TODR too small");
		return EINVAL;
	}

	ts->tv_sec =
	    yeartonum(numtoyear(base)) + (klocka - TODRBASE) / 100;
	ts->tv_nsec = 0;
	return 0;
}

/*
 * Takes the current system time and writes it to the TODR.
 */
void
generic_clkwrite()
{
	uint32_t tid = time_second, bastid;

	bastid = tid - yeartonum(numtoyear(tid));
	mtpr((bastid * 100) + TODRBASE, PR_TODR);
}
#endif

#if VAX630 || VAX410 || VAX43 || VAX46 || VAX48 || VAX49

volatile short *clk_page;	/* where the chip is mapped in virtual memory */
int	clk_adrshift;	/* how much to multiply the in-page address with */
int	clk_tweak;	/* Offset of time into word. */

#define	REGPEEK(off)	(clk_page[off << clk_adrshift] >> clk_tweak)
#define	REGPOKE(off, v)	(clk_page[off << clk_adrshift] = ((v) << clk_tweak))

int
chip_clkread(struct timespec *ts, time_t base)
{
	struct clock_ymdhms c;
	int timeout = 1<<15, s;

#ifdef DIAGNOSTIC
	if (clk_page == 0)
		panic("trying to use unset chip clock page");
#endif

	if ((REGPEEK(CSRD_OFF) & CSRD_VRT) == 0) {
		printf("WARNING: TOY clock not marked valid");
		return EINVAL;
	}
	while (REGPEEK(CSRA_OFF) & CSRA_UIP)
		if (--timeout == 0) {
			printf ("TOY clock timed out");
			return EINVAL;
		}

	s = splhigh();
	c.dt_year = ((u_char)REGPEEK(YR_OFF)) + 1970;
	c.dt_mon = REGPEEK(MON_OFF);
	c.dt_day = REGPEEK(DAY_OFF);
	c.dt_wday = REGPEEK(WDAY_OFF);
	c.dt_hour = REGPEEK(HR_OFF);
	c.dt_min = REGPEEK(MIN_OFF);
	c.dt_sec = REGPEEK(SEC_OFF);
	splx(s);

	ts->tv_sec = clock_ymdhms_to_secs(&c);
	ts->tv_nsec = 0;
	return 0;
}

void
chip_clkwrite()
{
	struct clock_ymdhms c;

#ifdef DIAGNOSTIC
	if (clk_page == 0)
		panic("trying to use unset chip clock page");
#endif

	REGPOKE(CSRB_OFF, CSRB_SET);

	clock_secs_to_ymdhms(time_second, &c);

	REGPOKE(YR_OFF, ((u_char)(c.dt_year - 1970)));
	REGPOKE(MON_OFF, c.dt_mon);
	REGPOKE(DAY_OFF, c.dt_day);
	REGPOKE(WDAY_OFF, c.dt_wday);
	REGPOKE(HR_OFF, c.dt_hour);
	REGPOKE(MIN_OFF, c.dt_min);
	REGPOKE(SEC_OFF, c.dt_sec);

	REGPOKE(CSRB_OFF, CSRB_DM|CSRB_24);
};
#endif

#if defined(VAX46) || defined(VAX48)
u_int
vax_diagtmr_get_tc(struct timecounter *tc)
{
	/*
	 * The diagnostic timer runs at about 1024kHz.
	 * The microsecond counter counts from 0 to 1023 inclusive (so it
	 * really is a 1/1024th millisecond counter) and increments the
	 * millisecond counter, which is a free-running 16 bit counter.
	 *
	 * To compensate for the timer not running at exactly 1024kHz,
	 * the microsecond counter is reset (to zero) every clock interrupt,
	 * i.e. every 10 millisecond.
	 *
	 * Without resetting the microsecond counter, experiments show that,
	 * on KA48, the millisecond counter increments of 960 in a second,
	 * instead of the expected 1000 (i.e. a 24/25 ratio).  But resetting
	 * the microsecond counter (which does not affect the millisecond
	 * counter value) ought to make it __slower__ - who can explain
	 * this behaviour?
	 *
	 * Because we reset the ``binary microsecond'' counter and can not
	 * afford time moving backwards, we only return the millisecond
	 * counter here.
	 */
	struct vs_cpu *vscpu;

	vscpu = (struct vs_cpu *)tc->tc_priv;
	return *(volatile uint16_t *)&vscpu->vc_diagtimm;
}
#endif

#ifdef VXT
u_int
vax_vxt_get_tc(struct timecounter *tc)
{
	return (u_int)clock_intrcnt.ec_count;
}
#endif

u_int
vax_icr_get_tc(struct timecounter *tc)
{
	return icr_count + (u_int)(tick + (int)mfpr(PR_ICR));
}
@


1.25
log
@Provide symbolic defines for the ICCS register magic bits, and use them
rather than hardcoded values.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.24 2011/09/15 00:48:24 miod Exp $	 */
@


1.24
log
@Switch vax to timecounters. There are three different clock sources:
- ICR/NICR on most systems (1MHz counter resolution).
- diagnostic timer on KA46/KA48 (1kHz counter resolution, counter is actually
  running at around 1024 kHz but is not guaranteed to be monotonic at this
  rate).
- 100Hz clock on VXT (nothing but the 100Hz clock interrupt).

Tested on KA49 (ICR style), KA46, KA48 (diagtmr style), VXT2000+ (VXT
{empty,hopeless}ness'r'us style).
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.23 2011/07/06 18:32:59 miod Exp $	 */
d198 2
a199 1
	mtpr(0x800000d1, PR_ICCS); /* Start clock and enable interrupt */
d252 1
a252 1
	unsigned klocka = mfpr(PR_TODR);
@


1.23
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2010/09/20 06:33:48 matthew Exp $	 */
d38 1
d49 4
d55 2
a56 3
 * microtime() should return number of usecs in struct timeval.
 * We may get wrap-arounds, but that will be fixed with lasttime
 * check. This may fault within 10 msecs.
d58 8
a65 6
void
microtime(tvp)
	struct timeval *tvp;
{
	int s, i;
	static struct timeval lasttime;
d67 2
a68 2
	s = splhigh();
	bcopy((caddr_t)&time, tvp, sizeof(struct timeval));
d70 7
a76 9
	switch (vax_boardtype) {
#ifdef VAX46
	case VAX_BTYP_46:
	    {
		extern struct vs_cpu *ka46_cpu;
		i = *(volatile int *)(&ka46_cpu->vc_diagtimu);
		i = (i >> 16) * 1024 + (i & 0x3ff);
	    }
		break;
d78 10
a87 30
#if defined(VAX48) || defined(VXT)
	case VAX_BTYP_48:
	case VAX_BTYP_VXT:
		/*
		 * PR_ICR doesn't exist.  We could use the vc_diagtimu
		 * counter, saving the value on the timer interrupt and
		 * subtracting that from the current value.
		 */
		i = 0;
		break;
#endif
	default:
		i = mfpr(PR_ICR);
		break;
	}
	i += tick; /* Get current interval count */
	tvp->tv_usec += i;
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	bcopy(tvp, &lasttime, sizeof(struct timeval));
	splx(s);
}
d99 1
a99 2
inittodr(fs_time) 
	time_t fs_time;
d102 1
d104 5
a108 5
	rv = (*dep_call->cpu_clkread) (fs_time);
	switch (rv) {

	case CLKREAD_BAD: /* No useable information from system clock */
		time.tv_sec = fs_time;
d110 3
a112 7
		break;

	case CLKREAD_WARN: /* Just give the warning */
		break;

	default: /* System clock OK, no warning if we don't want to. */
		deltat = time.tv_sec - fs_time;
d117 2
a118 2
			printf("Clock has %s %d days",
			    time.tv_sec < fs_time ? "lost" : "gained",
d120 1
a120 1
			rv = CLKREAD_WARN;
a121 1
		break;
d124 1
a124 1
	if (rv < CLKREAD_OK)
d126 2
d139 1
d145 1
a145 2
delay(i)
	int i;
d152 2
a153 2
 * be used for interval interrupts. Some CPUs don't use the ICR interval
 * register but it doesn't hurt to load it anyway.
d158 38
d197 1
a197 1
		mtpr(-10000, PR_NICR); /* Load in count register */
d199 7
a205 1
	evcount_attach(&clock_intrcnt, "clock", NULL);
d219 1
a219 2
yeartonum(y)
	int y;
d232 1
a232 2
numtoyear(num)
	int num;
d244 3
a246 3
 * Reads the TODR register; returns a (probably) true tick value,
 * or CLKREAD_BAD if failed. The year is based on the argument
 * year; the TODR doesn't hold years.
d249 1
a249 2
generic_clkread(base)
	time_t base;
d261 1
a261 1
		return CLKREAD_BAD;
d264 4
a267 2
	time.tv_sec = yeartonum(numtoyear(base)) + (klocka - TODRBASE) / 100;
	return CLKREAD_OK;
d276 1
a276 1
	unsigned tid = time.tv_sec, bastid;
d293 1
a293 2
chip_clkread(base)
	time_t base;
d305 1
a305 1
		return CLKREAD_BAD;
d310 1
a310 1
			return CLKREAD_BAD;
d323 3
a325 2
	time.tv_sec = clock_ymdhms_to_secs(&c);
	return CLKREAD_OK;
d340 1
a340 1
	clock_secs_to_ymdhms(time.tv_sec, &c);
d353 46
@


1.22
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.21 2008/08/18 23:19:29 miod Exp $	 */
d219 1
a219 2
#if VAX750 || VAX780 || VAX8600 || VAX650 || \
    VAX660 || VAX670 || VAX680 || VAX53
d259 1
a259 1
#if VAX630 || VAX410 || VAX43 || VAX8200 || VAX46 || VAX48 || VAX49
@


1.21
log
@Add support for the ``Firefox'' VAXstation 3520/3540/3820/3840 workstations,
currently limited to serial console and a single processor working.

All ``on-board'' devices, including the Q-bus adapter, but except for
the frame buffer, are supported. The machine will boot over the network
or from SCSI devices.

Lots of thanks to Al Kossow for www.bitsavers.org, on which I found the
technical documentation allowing me to complete this port (which was
lacking at the time I got that machine...).
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2008/08/15 22:41:48 miod Exp $	 */
d180 1
a180 1
	evcount_attach(&clock_intrcnt, "clock", NULL, &evcount_intr);
@


1.20
log
@Move the vxt-specific clock functions frow clock.c to the cpu-specific support
file, fewer #ifdef this way.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2006/08/27 16:55:41 miod Exp $	 */
a45 3

int	yeartonum(int);
int	numtoyear(int);
@


1.19
log
@Work-in-progress VXT2000 support (commented out in GENERIC so far). Glass
console works on color model, serial console works, ethernet attaches but
does not work correctly yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2004/07/07 23:10:46 deraadt Exp $	 */
a331 15
#endif

#if VXT
int
missing_clkread(base)
	time_t base;
{
	printf("WARNING: no TOY clock");
	return CLKREAD_BAD;
}

void
missing_clkwrite()
{
}
@


1.18
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2004/04/21 18:39:57 mickey Exp $	 */
d69 2
a70 1
	case VAX_BTYP_46: {
d74 1
a75 1
		}
d77 3
a79 2
#ifdef VAX48
	case VAX_BTYP_48: {
a86 1
		}
d180 2
a181 1
	mtpr(-10000, PR_NICR); /* Load in count register */
d215 1
a215 1
	while(num >= (j = SECPERYEAR(y))) {
d332 15
@


1.17
log
@allow VAX48- and VAX49-only kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2003/12/19 21:27:07 miod Exp $	 */
d50 1
a50 1
struct evcnt clock_intrcnt;
a178 7
	/*
	 * The current evcnt mechanism sucks, so provide a struct
	 * device for vmstat's sake, until it can be replaced.
	 */
	static struct device clockdev;
	strlcpy(clockdev.dv_xname, "clock", sizeof clockdev.dv_xname);

d181 1
a181 1
	evcnt_attach(&clockdev, "intr", &clock_intrcnt);
@


1.16
log
@Pass -Wformat.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2003/05/11 19:41:12 deraadt Exp $	 */
d268 1
a268 1
#if VAX630 || VAX410 || VAX43 || VAX8200 || VAX46
@


1.15
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2002/03/14 01:26:48 millert Exp $	 */
d139 1
a139 1
			printf("Clock has %s %ld days",
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2001/11/14 21:35:50 miod Exp $	 */
d184 1
a184 1
	strcpy(clockdev.dv_xname, "clock");
@


1.13
log
@Don't yell about clock drift for ridiculous (less than 48 hours) deltas.
hugh@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2001/08/25 13:33:37 hugh Exp $	 */
d47 2
a48 2
int	yeartonum __P((int));
int	numtoyear __P((int));
@


1.13.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2001/11/14 21:35:50 miod Exp $	 */
d47 2
a48 2
int	yeartonum(int);
int	numtoyear(int);
@


1.13.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d184 1
a184 1
	strlcpy(clockdev.dv_xname, "clock", sizeof clockdev.dv_xname);
@


1.12
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2001/02/11 06:34:37 hugh Exp $	 */
d120 1
a120 1
	int rv;
d134 8
a141 7
		if (time.tv_sec > fs_time + 3 * SEC_PER_DAY) {
			printf("Clock has gained %ld days",
			    (time.tv_sec - fs_time) / SEC_PER_DAY);
			rv = CLKREAD_WARN;
		} else if (time.tv_sec + SEC_PER_DAY < fs_time) {
			printf("Clock has lost %ld day(s)",
			    (fs_time - time.tv_sec) / SEC_PER_DAY);
d148 1
a148 1
		printf(" - CHECK AND RESET THE DATE.\n");
@


1.11
log
@Pick up a NetBSD hack to attach Cheetah to vsbus as well as ibus.
High kludge factor, but the payoff is vsbus scsi for free.
Most of the work is by Michael Kukat and ragge, with a few other
synchronisations thrown in.
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.10 2000/04/27 01:10:11 bjc Exp $	 */
/*	$NetBSD: clock.c,v 1.28 1999/05/01 16:13:43 ragge Exp $	 */
d50 2
d76 11
d178 7
d187 1
@


1.10
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2000/04/11 02:44:32 pjanzen Exp $	 */
d205 2
a206 1
#if VAX750 || VAX780 || VAX8600 || VAX650
@


1.9
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.8 1997/09/10 12:04:42 maja Exp $	 */
/*	$NetBSD: clock.c,v 1.20 1997/04/18 18:49:37 ragge Exp $	 */
d45 1
d47 2
a48 2
static unsigned long year;     /*  start of current year in seconds */
static unsigned long year_len; /* length of current year in 100th of seconds */
a58 1
	u_int int_time, tmp_year;
d63 1
a63 1
	int_time = mfpr(PR_TODR);
d65 14
a78 6
	asm ("movc3 %0,(%1),(%2)" 
		:
		: "r" (sizeof(struct timeval)),"r" (&time),"r"(tvp)
		:"r0","r1","r2","r3","r4","r5"); 

	i = mfpr(PR_ICR) + tick; /* Get current interval count */
a90 7
	if (int_time > year_len) {
		mtpr(mfpr(PR_TODR) - year_len, PR_TODR);
		year += year_len / 100;
		tmp_year = year / SEC_PER_DAY / 365 + 2;
		year_len = 100 * SEC_PER_DAY *
		    ((tmp_year % 4 && tmp_year != 32) ? 365 : 366);
	}
d122 1
a122 1
			printf("Clock has gained %d days",
d126 1
a126 1
			printf("Clock has lost %d day(s)",
a156 1
#if VAX750 || VAX780 || VAX8200 || VAX8600 || VAX8800
d158 3
a160 2
 * On most VAXen there are a microsecond clock that should
 * be used for interval interrupts. Have a generic version here.
d163 1
a163 1
generic_clock()
a167 12
#endif

#if VAX650 || VAX630 || VAX410 || VAX43
/*
 * Most microvaxen don't have a interval count register.
 */
void
no_nicr_clock()
{
	mtpr(0x800000d1, PR_ICCS); /* Start clock and enable interrupt */
}
#endif
d245 1
a245 1
#if VAX630 || VAX410 || VAX43 || VAX8200
d277 1
a277 1
	c.dt_year = REGPEEK(YR_OFF) + 1970;
d304 1
a304 1
	REGPOKE(YR_OFF, c.dt_year - 1970);
@


1.8
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 1997/05/29 00:05:13 niklas Exp $	 */
d72 1
a72 1
	while (tvp->tv_usec > 1000000) {
d78 1
a78 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
@


1.8.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.11 2001/02/11 06:34:37 hugh Exp $	 */
/*	$NetBSD: clock.c,v 1.28 1999/05/01 16:13:43 ragge Exp $	 */
a44 1
#include <machine/uvax.h>
d46 2
a47 2
int	yeartonum __P((int));
int	numtoyear __P((int));
d58 1
d63 1
a63 1
	bcopy((caddr_t)&time, tvp, sizeof(struct timeval));
d65 6
a70 14
	switch (vax_boardtype) {
#ifdef VAX46
	case VAX_BTYP_46: {
		extern struct vs_cpu *ka46_cpu;
		i = *(volatile int *)(&ka46_cpu->vc_diagtimu);
		i = (i >> 16) * 1024 + (i & 0x3ff);
		break;
		}
#endif
	default:
		i = mfpr(PR_ICR);
		break;
	}
	i += tick; /* Get current interval count */
d72 1
a72 1
	while (tvp->tv_usec >= 1000000) {
d78 1
a78 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
d83 7
d121 1
a121 1
			printf("Clock has gained %ld days",
d125 1
a125 1
			printf("Clock has lost %ld day(s)",
d156 1
d158 2
a159 3
 * On all VAXen there are a microsecond clock that should
 * be used for interval interrupts. Some CPUs don't use the ICR interval
 * register but it doesn't hurt to load it anyway.
d162 1
a162 1
cpu_initclocks()
d167 12
d216 1
a216 2
#if VAX750 || VAX780 || VAX8600 || VAX650 || \
    VAX660 || VAX670 || VAX680 || VAX53
d256 1
a256 1
#if VAX630 || VAX410 || VAX43 || VAX8200 || VAX46
d288 1
a288 1
	c.dt_year = ((u_char)REGPEEK(YR_OFF)) + 1970;
d315 1
a315 1
	REGPOKE(YR_OFF, ((u_char)(c.dt_year - 1970)));
@


1.8.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.8.12.1 2001/05/14 21:38:43 niklas Exp $	 */
/*	$NetBSD: clock.c,v 1.35 2000/06/04 06:16:58 matt Exp $	 */
a49 2
struct evcnt clock_intrcnt;

a73 11
#ifdef VAX48
	case VAX_BTYP_48: {
		/*
		 * PR_ICR doesn't exist.  We could use the vc_diagtimu
		 * counter, saving the value on the timer interrupt and
		 * subtracting that from the current value.
		 */
		i = 0;
		break;
		}
#endif
a164 7
	/*
	 * The current evcnt mechanism sucks, so provide a struct
	 * device for vmstat's sake, until it can be replaced.
	 */
	static struct device clockdev;
	strcpy(clockdev.dv_xname, "clock");

a166 1
	evcnt_attach(&clockdev, "intr", &clock_intrcnt);
@


1.8.12.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d47 2
a48 2
int	yeartonum(int);
int	numtoyear(int);
@


1.8.12.4
log
@manually merge stuff cvs missed long ago
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2002/03/14 01:26:48 millert Exp $	 */
d120 1
a120 1
	int rv, deltat;
d134 7
a140 8
		deltat = time.tv_sec - fs_time;

		if (deltat < 0)
			deltat = -deltat;
		if (deltat >= 2 * SEC_PER_DAY) {
			printf("Clock has %s %ld days",
			    time.tv_sec < fs_time ? "lost" : "gained",
			    deltat / SEC_PER_DAY);
d147 1
a147 1
		printf(" -- CHECK AND RESET THE DATE!\n");
@


1.8.12.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8.12.4 2002/03/30 08:27:12 niklas Exp $	 */
d184 1
a184 1
	strlcpy(clockdev.dv_xname, "clock", sizeof clockdev.dv_xname);
@


1.8.12.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d139 1
a139 1
			printf("Clock has %s %d days",
@


1.8.12.7
log
@Merge with the trunk
@
text
@d268 1
a268 1
#if VAX630 || VAX410 || VAX43 || VAX8200 || VAX46 || VAX48 || VAX49
@


1.7
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.18 1996/10/13 03:35:33 christos Exp $	 */
/*	$NetBSD: clock.c,v 1.18 1996/10/13 03:35:33 christos Exp $	 */
d39 2
a42 1
#include <machine/uvax.h>
d108 1
a108 1
	rv = (*cpu_calls[vax_cputype].cpu_clkread) (fs_time);
d143 1
a143 1
	(*cpu_calls[vax_cputype].cpu_clkwrite)();
d153 1
a153 26
	int	mul;

	switch (vax_cputype) {
#if VAX750 || VAX630 || VAX410
	case VAX_750:
	case VAX_78032:
		mul = 1; /* <= 1 VUPS */
		break;
#endif
#if VAX780 || VAX8200
	case VAX_780:
	case VAX_8200:
		mul = 2; /* <= 2 VUPS */
		break;
#endif
#if VAX650
	case VAX_650:
		mul = 3; /* <= 3 VUPS */
		break;
#endif
	default:	/* Would be enough... */
	case VAX_8600:
		mul = 6; /* <= 6 VUPS */
		break;
	}
	asm ("1: sobgtr %0, 1b" : : "r" (mul * i));
d258 6
a263 1
static int dagar[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
a264 3
/*
 * Returns the number of days in month based on the current year.
 */
d266 2
a267 2
daysinmonth(m, y)
	int m, y;
d269 17
a285 5
	if (m == 2 && IS_LEAPYEAR(y))
		return 29;
	else
		return dagar[m - 1];
}
d287 9
a295 16
/*
 * Converts chiptime (year/month/day/hour/min/sek) and returns ticks.
 */
long
chiptotime(c)
	struct chiptime *c;
{
	int num, i;

	num = c->sec;
	num += c->min * SEC_PER_MIN;
	num += c->hour * SEC_PER_HOUR;
	num += (c->day - 1) * SEC_PER_DAY;
	for(i = c->mon - 1; i > 0; i--)
		num += daysinmonth(i, c->year) * SEC_PER_DAY;
	num += yeartonum(c->year);
d297 2
a298 1
	return num;
a300 3
/*
 * Reads the system time and puts it into a chiptime struct.
 */
d302 1
a302 2
timetochip(c)
	struct chiptime *c;
d304 1
a304 1
	int tid = time.tv_sec, i, j;
d306 6
a311 2
	c->year = numtoyear(tid);
	tid -= yeartonum(c->year);
d313 1
a313 7
	c->mon = 1;
	while(tid >= (j = (daysinmonth(c->mon, c->year) * SEC_PER_DAY))) {
		c->mon++;
		tid -= j;
	}
	c->day = (tid / SEC_PER_DAY) + 1;
	tid %= SEC_PER_DAY;
d315 7
a321 2
	c->hour = tid / SEC_PER_HOUR;
	tid %= SEC_PER_HOUR;
d323 2
a324 3
	c->min = tid / SEC_PER_MIN;
	c->sec = tid % SEC_PER_MIN;
}
@


1.6
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.5
log
@sync to 0611
@
text
@d1 1
a1 1
/*      $NetBSD: clock.c,v 1.14 1996/05/19 16:43:57 ragge Exp $  */
d40 3
a42 5
#include <machine/uvaxII.h>

#define SEC_PER_DAY (60*60*24)

extern int todrstopped;
d63 4
a66 4
        asm ("movc3 %0,(%1),(%2)" 
                :
                : "r" (sizeof(struct timeval)),"r" (&time),"r"(tvp)
                :"r0","r1","r2","r3","r4","r5"); 
d104 1
d106 2
a107 2
	unsigned long tmp_year, sluttid, year_ticks;
	int clock_stopped = 0;
d109 4
a112 5
	sluttid = fs_time;
	year = (fs_time / SEC_PER_DAY / 365) * 365 * SEC_PER_DAY;
	tmp_year = year / SEC_PER_DAY / 365 + 2;
	year_len = 100 * SEC_PER_DAY *
	    ((tmp_year % 4 && tmp_year != 32) ? 365 : 366);
d114 1
a114 6
	switch (cpunumber) {
#if VAX750 || VAX650
	case VAX_750:
	case VAX_650:
		year_ticks = mfpr(PR_TODR);
		clock_stopped = todrstopped;
d116 11
a126 4
#endif
#if VAX630 || VAX410
	case VAX_78032:
		year_ticks = uvaxII_gettodr(&clock_stopped);
d128 4
a131 41
#endif
#if VAX780 || VAX8600
	case VAX_780:
	case VAX_8600:
		year_ticks = mfpr(PR_TODR);
		break;
#endif
	default:
		year_ticks = 0;
		clock_stopped = 1;
	};

	if (clock_stopped){
		printf(
	"Internal clock not started. Using time from file system.\n");
		switch (cpunumber) {
#if VAX750 || VAX650
		case VAX_750:
		case VAX_650:
			/* +1 so the clock won't be stopped */
			mtpr((fs_time - year) * 100 + 1, PR_TODR);
			break;
#endif
#if VAX630 || VAX410
		case VAX_78032:
			uvaxII_settodr((fs_time - year) * 100 + 1);
			break;
#endif
		};
		todrstopped = 0;
	} else if (year_ticks / 100 > fs_time - year + SEC_PER_DAY * 3) {
		printf(
	"WARNING: Clock has gained %d days - CHECK AND RESET THE DATE.\n",
		    (int)(year_ticks / 100 - (fs_time - year)) / SEC_PER_DAY);
		sluttid = year + (year_ticks / 100);
	} else if (year_ticks / 100 < fs_time - year) {
		printf(
		"WARNING: Clock has lost time - CHECK AND RESET THE DATE.\n");
	} else
		sluttid = year + (year_ticks / 100);
	time.tv_sec = sluttid;
d141 1
a141 22

	unsigned long tmp_year;

	year = (time.tv_sec / SEC_PER_DAY / 365) * 365 * SEC_PER_DAY;
	tmp_year = year / SEC_PER_DAY / 365 + 2;
	year_len = 100 * SEC_PER_DAY *
	    ((tmp_year % 4 && tmp_year != 32) ? 365 : 366);
	switch (cpunumber) {
#if VAX750
	case VAX_750:
		mtpr((time.tv_sec - year) * 100 + 1, PR_TODR);
		break;
#endif
#if VAX630 || VAX410
	case VAX_78032:
		uvaxII_settodr((time.tv_sec - year) * 100 + 1);
		break;
#endif
	default:
		mtpr((time.tv_sec - year) * 100, PR_TODR);
	};
	todrstopped = 0;
a142 1

d153 2
a154 2
	switch (cpunumber) {
#if VAX750 || VAX630 || VAX780
d157 4
d162 2
a163 1
		mul = 1; /* <= 1 VUPS */
d178 165
@


1.4
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*      $NetBSD: clock.c,v 1.13 1996/04/08 18:32:27 ragge Exp $  */
d36 1
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*      $NetBSD: clock.c,v 1.9 1995/12/13 18:45:56 ragge Exp $  */
d35 1
d37 3
a39 2
#include "machine/mtpr.h"
#include "machine/sid.h"
d107 1
a107 1
	int clock_stopped;
d128 6
d160 1
a160 1
		    (year_ticks / 100 - (fs_time - year)) / SEC_PER_DAY);
d195 2
d202 2
a203 4
 * Unfortunately the 78032 cpu chip (MicroVAXII cpu) does not have a functional
 * todr register, so this function is necessary.
 * (the x and y variables are used to confuse the optimizer enough to ensure
 *  that the code actually loops:-)
d209 1
a209 1
	volatile int n;
d211 19
a229 6
	n = i;

	while (--n)
		;

	return;
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.8 1995/11/30 00:59:32 jtc Exp $	*/
d114 1
a114 1
#if VAX750
d116 1
d135 1
a135 1
#if VAX750
d137 2
a138 1
			/*+1 so the clock won't be stopped */
d157 2
a158 1
	} else sluttid = year + (year_ticks / 100);
d197 3
a199 2
int
todr()
d201 3
a203 2
      int delaycnt, x = 4, y = 4;
      static int todr_val;
d205 2
a206 2
      if (cpunumber != VAX_78032)
	      return (mfpr(PR_TODR));
d208 1
a208 7
      /*
       * Loop for approximately 10msec and then return todr_val + 1.
       */
      delaycnt = 5000;
      while (delaycnt > 0)
	      delaycnt = delaycnt - x + 3 + y - 4;
      return (++todr_val);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.7.2.1 1995/10/15 14:17:17 ragge Exp $	*/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
