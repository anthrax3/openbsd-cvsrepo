head	1.151;
access;
symbols
	OPENBSD_5_9:1.150.0.2
	OPENBSD_5_9_BASE:1.150
	OPENBSD_5_8:1.149.0.4
	OPENBSD_5_8_BASE:1.149
	OPENBSD_5_7:1.148.0.2
	OPENBSD_5_7_BASE:1.148
	OPENBSD_5_6:1.143.0.4
	OPENBSD_5_6_BASE:1.143
	OPENBSD_5_5:1.130.0.4
	OPENBSD_5_5_BASE:1.130
	OPENBSD_5_4:1.126.0.2
	OPENBSD_5_4_BASE:1.126
	OPENBSD_5_3:1.123.0.2
	OPENBSD_5_3_BASE:1.123
	OPENBSD_5_2:1.121.0.2
	OPENBSD_5_2_BASE:1.121
	OPENBSD_5_1_BASE:1.120
	OPENBSD_5_1:1.120.0.2
	OPENBSD_5_0:1.119.0.2
	OPENBSD_5_0_BASE:1.119
	OPENBSD_4_9:1.111.0.2
	OPENBSD_4_9_BASE:1.111
	OPENBSD_4_8:1.110.0.2
	OPENBSD_4_8_BASE:1.110
	OPENBSD_4_7:1.106.0.2
	OPENBSD_4_7_BASE:1.106
	OPENBSD_4_6:1.102.0.4
	OPENBSD_4_6_BASE:1.102
	OPENBSD_4_5:1.99.0.2
	OPENBSD_4_5_BASE:1.99
	OPENBSD_4_4:1.96.0.2
	OPENBSD_4_4_BASE:1.96
	OPENBSD_4_3:1.94.0.2
	OPENBSD_4_3_BASE:1.94
	OPENBSD_4_2:1.92.0.2
	OPENBSD_4_2_BASE:1.92
	OPENBSD_4_1:1.84.0.4
	OPENBSD_4_1_BASE:1.84
	OPENBSD_4_0:1.84.0.2
	OPENBSD_4_0_BASE:1.84
	OPENBSD_3_9:1.76.0.2
	OPENBSD_3_9_BASE:1.76
	OPENBSD_3_8:1.73.0.2
	OPENBSD_3_8_BASE:1.73
	OPENBSD_3_7:1.71.0.2
	OPENBSD_3_7_BASE:1.71
	OPENBSD_3_6:1.70.0.4
	OPENBSD_3_6_BASE:1.70
	SMP_SYNC_A:1.70
	SMP_SYNC_B:1.70
	OPENBSD_3_5:1.70.0.2
	OPENBSD_3_5_BASE:1.70
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	UBC_SYNC_A:1.66
	OPENBSD_3_3:1.63.0.2
	OPENBSD_3_3_BASE:1.63
	OPENBSD_3_2:1.61.0.2
	OPENBSD_3_2_BASE:1.61
	OPENBSD_3_1:1.58.0.2
	OPENBSD_3_1_BASE:1.58
	UBC_SYNC_B:1.61
	UBC:1.49.0.2
	UBC_BASE:1.49
	OPENBSD_3_0:1.41.0.2
	OPENBSD_3_0_BASE:1.41
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.20
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.17.0.8
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.17.0.6
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.17.0.4
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.151
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.150;
commitid	OSDG2O3Cgeifnf1W;

1.150
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.149;
commitid	XglPgGQ8qaiL0M4l;

1.149
date	2015.05.13.08.01.21;	author mpi;	state Exp;
branches;
next	1.148;
commitid	WyNvGCXjmg4hQtRk;

1.148
date	2015.02.07.23.30.13;	author miod;	state Exp;
branches;
next	1.147;
commitid	p8Oa9OhNPSCHzNsV;

1.147
date	2014.12.22.02.26.54;	author tedu;	state Exp;
branches;
next	1.146;
commitid	2Ez9mHW0jDzojG4V;

1.146
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.145;
commitid	qHQiR2HLROzvZr7B;

1.145
date	2014.11.18.20.51.01;	author krw;	state Exp;
branches;
next	1.144;
commitid	G35ycnLxaVis5TX9;

1.144
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.143;
commitid	IFRB8AkvBMXMTAKW;

1.143
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.142;
commitid	7QO4UJr3EKVAMc8t;

1.142
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.141;
commitid	wsdp3qtXGjMj98oD;

1.141
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.140;
commitid	qYPOd6Qi4aRBKldK;

1.140
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.139;
commitid	iYq3Z1ZWDKR3sS9G;

1.139
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.138;
commitid	YzvTa4t6mddz7Mh4;

1.138
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.137;
commitid	xpsLTYRIkonFtkr1;

1.137
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.136;
commitid	aofvn6ceiucgjg4N;

1.136
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.135;
commitid	eA4Y0YE1IUzj6hpW;

1.135
date	2014.05.30.13.46.17;	author mpi;	state Exp;
branches;
next	1.134;

1.134
date	2014.05.25.13.57.48;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.132;

1.132
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.131;

1.131
date	2014.03.13.03.52.56;	author dlg;	state Exp;
branches;
next	1.130;

1.130
date	2013.11.24.22.08.25;	author miod;	state Exp;
branches;
next	1.129;

1.129
date	2013.11.20.23.57.07;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2013.11.13.02.23.33;	author uebayasi;	state Exp;
branches;
next	1.127;

1.127
date	2013.09.28.12.40.32;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2013.07.05.21.11.57;	author miod;	state Exp;
branches;
next	1.125;

1.125
date	2013.06.29.13.00.35;	author miod;	state Exp;
branches;
next	1.124;

1.124
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2012.12.02.07.03.32;	author guenther;	state Exp;
branches;
next	1.122;

1.122
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2012.03.24.19.09.20;	author guenther;	state Exp;
branches;
next	1.120;

1.120
date	2011.09.19.21.53.02;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.118;

1.118
date	2011.07.06.20.42.52;	author miod;	state Exp;
branches;
next	1.117;

1.117
date	2011.07.06.18.33.00;	author miod;	state Exp;
branches;
next	1.116;

1.116
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.115;

1.115
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2011.06.05.19.41.08;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.112;

1.112
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.111;

1.111
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2010.06.29.18.46.34;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2010.06.27.12.41.23;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2010.05.26.16.35.29;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2009.08.11.19.17.17;	author miod;	state Exp;
branches;
next	1.105;

1.105
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.104;

1.104
date	2009.08.09.10.40.18;	author blambert;	state Exp;
branches;
next	1.103;

1.103
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.102;

1.102
date	2009.06.20.21.02.15;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.99;

1.99
date	2008.08.18.23.19.29;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2008.08.18.23.08.57;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.14.11.41.30;	author martin;	state Exp;
branches;
next	1.96;

1.96
date	2008.06.27.17.22.15;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.16.22.59.34;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2007.12.28.20.41.56;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.29.20.36.48;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.27.17.31.57;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.25.14.50.38;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2007.05.23.20.33.47;	author pvalchev;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.16.16.30.42;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2007.05.16.05.19.15;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2006.07.20.19.15.35;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2006.07.19.20.41.34;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2006.07.19.20.38.33;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2006.07.16.22.40.42;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2006.06.11.22.09.33;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.02.17.39.59;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.30.21.24.28;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.07.20.20.30;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2006.01.04.15.41.29;	author martin;	state Exp;
branches;
next	1.75;

1.75
date	2006.01.02.18.15.55;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2005.11.06.22.21.33;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2005.06.08.17.03.03;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.12.02.19.40.46;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.10.23.02.54;	author tom;	state Exp;
branches;
next	1.69;

1.69
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.68;

1.68
date	2003.06.26.13.06.26;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2003.05.14.00.20.37;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2003.04.16.16.54.17;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2003.04.08.14.53.11;	author hugh;	state Exp;
branches;
next	1.63;

1.63
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.08.01.33.28;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2002.09.21.13.42.43;	author hugh;	state Exp;
branches;
next	1.60;

1.60
date	2002.07.20.19.24.57;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.16.07.37.44;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.05.18.14.53;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.14.00.42.24;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.18.02.10.00;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.18.11.17.26;	author hugh;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2001.12.08.02.24.07;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.28.16.13.29;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.24.17.53.41;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.09.15.25.56;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.04.00.21.12;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.12.00.23.34;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.23.12.02.05;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.05.10.12.20;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.15.22.45.33;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.11.01.33.48;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.17.18.41.50;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.05.22.34.29;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.05.20.56.56;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.11.12.59.40;	author bjc;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.28.02.24.24;	author hugh;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.27.00.16.22;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.17.19.57.55;	author hugh;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.10.18.25.00;	author bjc;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.08.22.25.23;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.30.10.23.34;	author bjc;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.27.01.10.13;	author bjc;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.23.09.59.56;	author art;	state Exp;
branches;
next	1.20;

1.20
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	99.05.24.23.09.09;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	99.05.22.21.22.32;	author weingart;	state Exp;
branches;
next	1.17;

1.17
date	97.10.02.19.53.20;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.09.12.09.30.56;	author maja;	state Exp;
branches;
next	1.15;

1.15
date	97.09.10.12.04.50;	author maja;	state Exp;
branches;
next	1.14;

1.14
date	97.08.30.09.50.28;	author maja;	state Exp;
branches;
next	1.13;

1.13
date	97.07.23.06.58.31;	author denny;	state Exp;
branches;
next	1.12;

1.12
date	97.05.28.23.27.33;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.01.16.20.43.45;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.01.15.23.25.17;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	96.07.27.11.40.51;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.06.12.08.20.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.08.09.47.40;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.05.03.09.10.17;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.01.31.05.15.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.05.16.18.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.14.00.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches;
next	;

1.20.2.1
date	2000.03.24.09.08.58;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.05.14.21.39.05;	author niklas;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.07.04.10.24.39;	author niklas;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2002.03.28.11.26.47;	author niklas;	state Exp;
branches;
next	1.20.2.8;

1.20.2.8
date	2002.03.30.08.27.12;	author niklas;	state Exp;
branches;
next	1.20.2.9;

1.20.2.9
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.20.2.10;

1.20.2.10
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.20.2.11;

1.20.2.11
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	1.20.2.12;

1.20.2.12
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	1.20.2.13;

1.20.2.13
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	1.20.2.14;

1.20.2.14
date	2004.06.05.23.11.03;	author niklas;	state Exp;
branches;
next	;

1.49.2.1
date	2002.01.31.22.55.27;	author niklas;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	1.49.2.4;

1.49.2.4
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.151
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/* $OpenBSD: machdep.c,v 1.150 2015/10/21 07:59:18 mpi Exp $ */
/* $NetBSD: machdep.c,v 1.108 2000/09/13 15:00:23 thorpej Exp $	 */

/*
 * Copyright (c) 2002, Hugh Graham.
 * Copyright (c) 2002, Miodrag Vallat.
 * Copyright (c) 1994, 1996, 1998 Ludd, University of Lule}, Sweden.
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 * 
 * Changed for the VAX port (and for readability) /IC
 * 
 * This code is derived from software contributed to Ludd by
 * Bertram Barth.
 *
 * This code is derived from software contributed to Berkeley by the Systems
 * Programming Group of the University of Utah Computer Science Department.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * from: Utah Hdr: machdep.c 1.63 91/04/24
 * 
 * @@(#)machdep.c	7.16 (Berkeley) 6/3/91
 */

#include <sys/signal.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/msgbuf.h>
#include <sys/buf.h>
#include <sys/mbuf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <sys/exec.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/core.h>
#include <sys/kcore.h>

#include <dev/cons.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include <netinet/in.h>
#include <netinet/ip_var.h>
#include "ppp.h"	/* For NPPP */
#if NPPP > 0
#include <net/ppp_defs.h>
#include <net/if_ppp.h>
#endif

#include <machine/sid.h>
#include <machine/db_machdep.h>
#include <machine/kcore.h>
#include <vax/vax/gencons.h>
#include <machine/rpb.h>
#include <machine/cca.h>

#ifdef DDB
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif
#include <vax/vax/db_disasm.h>

#include "led.h"

extern int virtual_avail, virtual_end;
/*
 * We do these external declarations here, maybe they should be done
 * somewhere else...
 */
int		want_resched;
char		machine[] = MACHINE;		/* from <machine/param.h> */
int		physmem;
int		cold = 1; /* coldstart */
struct cpmbx	*cpmbx;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

/*
 * XXX some storage space must be allocated statically because of
 * early console init
 */
#define	IOMAPSZ	100
char extiospace[EXTENT_FIXED_STORAGE_SIZE(IOMAPSZ)];

struct extent *extio;
extern vaddr_t iospace;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

#ifdef DEBUG
int iospace_inited = 0;
#endif

/* sysctl settable */
#if NLED > 0
int	vax_led_blink = 1;
#endif

struct cpu_info cpu_info_store;

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

void dumpconf(void);

void
cpu_startup()
{
	vaddr_t		minaddr, maxaddr;
	extern char	cpu_model[];

	/*
	 * Initialize error message buffer.
	 */
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
	 * Good {morning,afternoon,evening,night}.
	 * Also call CPU init on systems that need that.
	 */
	printf("%s%s [%08X %08X]\n", version,
	    cpu_model, vax_cpudata, vax_siedata);
        if (dep_call->cpu_conf)
                (*dep_call->cpu_conf)();

	printf("real mem = %lu (%luMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);
	mtpr(AST_NO, PR_ASTLVL);
	spl0();

	/*
	 * Allocate a submap for exec arguments.  This map effectively limits
	 * the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

#if VAX46 || VAX48 || VAX49 || VAX53 || VAX60
	/*
	 * Allocate a submap for physio.  This map effectively limits the
	 * number of processes doing physio at any one time.
	 *
	 * Note that machines on which all mass storage I/O controllers 
	 * can perform address translation, do not need this.
	 */
	if (vax_boardtype == VAX_BTYP_46 || vax_boardtype == VAX_BTYP_48 ||
	    vax_boardtype == VAX_BTYP_49 || vax_boardtype == VAX_BTYP_1303 ||
	    vax_boardtype == VAX_BTYP_60)
		phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
		    VM_PHYS_SIZE, 0, FALSE, NULL);
#endif

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */

	bufinit();
#ifdef DDB
	if (boothowto & RB_KDB)
		Debugger();
#endif

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

long	dumpmag = 0x8fca0101;
int	dumpsize = 0;
long	dumplo = 0;
cpu_kcore_hdr_t cpu_kcore_hdr;

void
dumpconf(void)
{
	int nblks;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = physmem;
	if (dumpsize > atop(dbtob(nblks - dumplo)))
		dumpsize = atop(dbtob(nblks - dumplo));
	else if (dumplo == 0)
		dumplo = nblks - btodb(ptoa(dumpsize));

	/*
	 * Don't dump on the first block in case the dump
	 * device includes a disk label.
	 */
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);

	/* Put dump at the end of partition, and make it fit. */
	if (dumpsize + 1 > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo) - 1;
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;

	/* memory is contiguous on vax */
	cpu_kcore_hdr.ram_segs[0].start = 0;
	cpu_kcore_hdr.ram_segs[0].size = ptoa(physmem);
	cpu_kcore_hdr.sysmap = (vaddr_t)Sysmap;
}

int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
#if NLED > 0
	int oldval, ret;
#endif
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	case CPU_LED_BLINK:
#if NLED > 0
		oldval = vax_led_blink;
		ret =  sysctl_int(oldp, oldlenp, newp, newlen, &vax_led_blink);
		if (oldval != vax_led_blink) {
			extern void led_blink(void *);
			led_blink(NULL);
		}
		return (ret);
#else
		return (EOPNOTSUPP);
#endif
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

void
setstatclockrate(hzrate)
	int hzrate;
{
	/* nothing to do */
}

void
consinit()
{
	/*
	 * Init I/O memory extent. Must be done before cninit()
	 * is called; we may want to use iospace in the console routines.
	 *
	 * XXX console code uses the first page at iospace, so do not make
	 * the extent start at iospace.
	 */
	extio = extent_create("extio",
	    (u_long)iospace + VAX_NBPG, (u_long)iospace + IOSPSZ * VAX_NBPG,
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);
#ifdef DEBUG
	iospace_inited = 1;
#endif
	cninit();
#ifdef DDB
	ddb_init();
#ifdef DEBUG
	if (sizeof(struct user) > REDZONEADDR)
		panic("struct user inside red zone");
#endif
#endif
}

/*
 * Old sigcontext structure, still used by userland until setjmp is fixed.
 */
struct	osigcontext {
	int	__sc_unused;
	int	sc_mask;		/* signal mask to restore */
	int	sc_sp;			/* sp to restore */
	int	sc_fp;			/* fp to restore */
	int	sc_ap;			/* ap to restore */
	int	sc_pc;			/* pc to restore */
	int	sc_ps;			/* psl to restore */
};

/*
 * Internal flags in the low order bits of sc_ap, to know whether this
 * is an osigcontext or a sigcontext.
 */
#define	SIGCONTEXT_NEW		0x01

int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args { 
		syscallarg(struct sigcontext *) sigcntxp;
	} *uap = v;
	struct trapframe *scf;
	struct sigcontext *cntx;
	struct sigcontext ksc;
	int error;

	scf = p->p_addr->u_pcb.framep;
	cntx = SCARG(uap, sigcntxp);

	error = copyin((caddr_t)cntx, (caddr_t)&ksc,
	    sizeof(struct osigcontext));
	if (error == 0 && (ksc.sc_ap & SIGCONTEXT_NEW)) {
		error = copyin((caddr_t)cntx + sizeof(struct osigcontext),
		    (caddr_t)&ksc.sc_r,
		    sizeof(struct sigcontext) - sizeof(struct osigcontext));
	}
	if (error != 0)
		return (error);

	/* Compatibility mode? */
	if ((ksc.sc_ps & (PSL_IPL | PSL_IS)) ||
	    ((ksc.sc_ps & (PSL_U | PSL_PREVU)) != (PSL_U | PSL_PREVU)) ||
	    (ksc.sc_ps & PSL_CM)) {
		return (EINVAL);
	}
	/* Restore signal mask. */
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;

	scf->fp = ksc.sc_fp;
	scf->ap = ksc.sc_ap & ~SIGCONTEXT_NEW;
	scf->sp = ksc.sc_sp;
	if (ksc.sc_ap & SIGCONTEXT_NEW) {
		scf->r0 = ksc.sc_r[0];
		scf->r1 = ksc.sc_r[1];
		scf->r2 = ksc.sc_r[2];
		scf->r3 = ksc.sc_r[3];
		scf->r4 = ksc.sc_r[4];
		scf->r5 = ksc.sc_r[5];
		scf->r6 = ksc.sc_r[6];
		scf->r7 = ksc.sc_r[7];
		scf->r8 = ksc.sc_r[8];
		scf->r9 = ksc.sc_r[9];
		scf->r10 = ksc.sc_r[10];
		scf->r11 = ksc.sc_r[11];
	}
	scf->pc = ksc.sc_pc;
	scf->psl = ksc.sc_ps;
	return (EJUSTRETURN);
}

struct sigframe {
	/* arguments of the signal handler */
	int		 sf_signum;
	siginfo_t 	*sf_sip;
	struct sigcontext *sf_scp;
	/* address of the signal handler */
	register_t 	 sf_pc;
	/* sigcontext pointer for sigreturn */
	register_t	 sf_arg;

	siginfo_t 	 sf_si;
	struct sigcontext sf_sc;
};

void
sendsig(catcher, sig, mask, code, type, val)
	sig_t		catcher;
	int		sig, mask;
	u_long		code;
	int 		type;
	union sigval 	val;
{
	struct	proc	*p = curproc;
	struct	sigacts *psp = p->p_p->ps_sigacts;
	struct	trapframe *syscf;
	struct	sigframe *sigf, gsigf;
	unsigned int	cursp;

	syscf = p->p_addr->u_pcb.framep;

	/* Allocate space for the signal handler context. */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(syscf->sp) && (psp->ps_sigonstack & sigmask(sig)))
		cursp = ((int)p->p_sigstk.ss_sp + p->p_sigstk.ss_size);
	else
		cursp = syscf->sp;

	/* Set up positions for structs on stack */
	sigf = (struct sigframe *) (cursp - sizeof(struct sigframe));

	bzero(&gsigf, sizeof gsigf);
	gsigf.sf_pc = (register_t)catcher;
	gsigf.sf_scp = &sigf->sf_sc;
	gsigf.sf_arg = (register_t)&sigf->sf_sc;
	gsigf.sf_signum = sig;

	if (psp->ps_siginfo & sigmask(sig)) {
		gsigf.sf_sip = &sigf->sf_si;
		initsiginfo(&gsigf.sf_si, sig, code, type, val);
	}

	gsigf.sf_sc.sc_mask = mask;
	gsigf.sf_sc.sc_sp = syscf->sp; 
	gsigf.sf_sc.sc_fp = syscf->fp; 
	gsigf.sf_sc.sc_ap = syscf->ap | SIGCONTEXT_NEW;
	gsigf.sf_sc.sc_pc = syscf->pc;
	gsigf.sf_sc.sc_ps = syscf->psl;
	gsigf.sf_sc.sc_r[0] = syscf->r0;
	gsigf.sf_sc.sc_r[1] = syscf->r1;
	gsigf.sf_sc.sc_r[2] = syscf->r2;
	gsigf.sf_sc.sc_r[3] = syscf->r3;
	gsigf.sf_sc.sc_r[4] = syscf->r4;
	gsigf.sf_sc.sc_r[5] = syscf->r5;
	gsigf.sf_sc.sc_r[6] = syscf->r6;
	gsigf.sf_sc.sc_r[7] = syscf->r7;
	gsigf.sf_sc.sc_r[8] = syscf->r8;
	gsigf.sf_sc.sc_r[9] = syscf->r9;
	gsigf.sf_sc.sc_r[10] = syscf->r10;
	gsigf.sf_sc.sc_r[11] = syscf->r11;

	if (copyout(&gsigf, sigf, sizeof(gsigf)))
		sigexit(p, SIGILL);

	syscf->pc = p->p_p->ps_sigcode;
	syscf->psl = PSL_U | PSL_PREVU;
	/*
	 * Place sp at the beginning of sigf; this ensures that possible
	 * further calls to sendsig won't overwrite this struct
	 * sigframe/struct sigcontext pair with their own. Also, set up
	 * ap for the sigreturn call from sigcode.
	 */
	syscf->sp = (unsigned)sigf;
	syscf->ap = (unsigned)sigf + offsetof(struct sigframe, sf_pc);
}

int	waittime = -1;
static	volatile int showto; /* Must be volatile to survive MM on -> MM off */

__dead void
boot(int howto)
{
	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0) {
		if (dep_call->cpu_halt)
			(*dep_call->cpu_halt) ();
		printf("halting (in tight loop); hit\n\t^P\n\tHALT\n\n");
		for (;;) ;
	} else {
		showto = howto;
#ifdef notyet
		/*
		 * If we are provided with a bootstring, parse it and send
		 * it to the boot program.
		 */
		if (b)
			while (*b) {
				showto |= (*b == 'a' ? RB_ASKBOOT : (*b == 'd' ?
				    RB_DEBUG : (*b == 's' ? RB_SINGLE : 0)));
				b++;
			}
#endif
		/*
		 * Now it's time to:
		 *  0. Save some registers that are needed in new world.
		 *  1. Change stack to somewhere that will survive MM off.
		 * (RPB page is good page to save things in).
		 *  2. Actually turn MM off.
		 *  3. Dump away memory to disk, if asked.
		 *  4. Reboot as asked.
		 * The RPB page is _always_ first page in memory, we can
		 * rely on that.
		 */
#ifdef notyet
		asm("	movl	sp, (0x80000200);"
		"	movl	0x80000200, sp;"
		"	mfpr	$0x10, -(sp);	# PR_PCBB"
		"	mfpr	$0x11, -(sp);	# PR_SCBB"
		"	mfpr	$0xc, -(sp);	# PR_SBR"
		"	mfpr	$0xd, -(sp);	# PR_SLR"
		"	mtpr	$0, $0x38;	# PR_MAPEN"
		);
#endif

		if (dep_call->cpu_reboot)
			(*dep_call->cpu_reboot)(showto);

		/* cpus that don't handle reboots get the standard reboot. */
		while ((mfpr(PR_TXCS) & GC_RDY) == 0)
			;

		mtpr(GC_CONS|GC_BTFL, PR_TXDB);
	}
	asm("movl %0, %%r5":: "g" (showto)); /* How to boot */
	asm("movl %0, %%r11":: "r"(showto)); /* ??? */
	asm("halt");
	for (;;) ;
	/* NOTREACHED */
}

void
dumpsys()
{
	int maj, psize, pg;
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	paddr_t maddr;
	int error;
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */
	extern int msgbufmapped;

	msgbufmapped = 0;
	if (dumpdev == NODEV)
		return;
	/*
	 * For dumps during autoconfiguration, if dump device has already
	 * configured...
	 */
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	maj = major(dumpdev);
	if (dumplo <= 0) {
		printf("\ndump to dev %u,%u not possible\n", maj,
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[maj].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);

	/* Setup the dump header */
	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));
	*chdr_p = cpu_kcore_hdr;

	printf("dump ");
	psize = (*bdevsw[maj].d_psize)(dumpdev);
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	/* Dump the header. */
	error = (*dump)(dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	if (error != 0)
		goto abort;

	maddr = (paddr_t)0;
	for (pg = 0; pg < dumpsize; pg++) {
#define	NPGMB	(1024 * 1024 / PAGE_SIZE)
		/* print out how many MBs we have dumped */
		if (pg != 0 && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		error = (*dump)(dumpdev, blkno, (caddr_t)maddr + KERNBASE,
		    PAGE_SIZE);
		if (error == 0) {
			maddr += PAGE_SIZE;
			blkno += btodb(PAGE_SIZE);
		} else
			break;
	}
abort:
	switch (error) {
	case 0:
		printf("succeeded\n");
		break;

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
}

int
process_read_regs(p, regs)
	struct proc    *p;
	struct reg     *regs;
{
	struct trapframe *tf = p->p_addr->u_pcb.framep;

	bcopy(&tf->r0, &regs->r0, 12 * sizeof(int));
	regs->ap = tf->ap;
	regs->fp = tf->fp;
	regs->sp = tf->sp;
	regs->pc = tf->pc;
	regs->psl = tf->psl;
	return 0;
}

#ifdef PTRACE

int
process_write_regs(p, regs)
	struct proc    *p;
	struct reg     *regs;
{
	struct trapframe *tf = p->p_addr->u_pcb.framep;

	bcopy(&regs->r0, &tf->r0, 12 * sizeof(int));
	tf->ap = regs->ap;
	tf->fp = regs->fp;
	tf->sp = regs->sp;
	tf->pc = regs->pc;
	tf->psl = (regs->psl|PSL_U|PSL_PREVU) &
		~(PSL_MBZ|PSL_IS|PSL_IPL1F|PSL_CM);
	return 0;
}

int
process_set_pc(p, addr)
	struct	proc *p;
	caddr_t addr;
{
	struct	trapframe *tf;
	void	*ptr;

	ptr = (char *) p->p_addr->u_pcb.framep;
	tf = ptr;

	tf->pc = (unsigned) addr;

	return (0);
}

int
process_sstep(p, sstep)
	struct proc    *p;
{
	void	       *ptr;
	struct trapframe *tf;

	ptr = p->p_addr->u_pcb.framep;
	tf = ptr;

	if (sstep)
		tf->psl |= PSL_T;
	else
		tf->psl &= ~PSL_T;

	return (0);
}

#endif	/* PTRACE */

#undef PHYSMEMDEBUG
/*
 * Allocates a virtual range suitable for mapping in physical memory.
 * This differs from the bus_space routines in that it allocates on
 * physical page sizes instead of logical sizes. This implementation
 * uses an extent to manage allocated space from the IOMAP submap.
 * The implementation is similar to the uba resource map handling. Size
 * is given in pages.
 * If the page requested is bigger than a logical page, space is
 * allocated from the kernel map instead.
 *
 * It is known that the first page in the iospace area is unused; it may
 * be use by console device drivers (before the map system is initted).
 */
vaddr_t
vax_map_physmem(phys, size)
	paddr_t phys;
	int size;
{
	vaddr_t addr;
	int error;
	static int warned = 0;

#ifdef DEBUG
	if (!iospace_inited)
		panic("vax_map_physmem: called before rminit()?!?");
#endif
	if (size >= LTOHPN) {
		addr = uvm_km_valloc(kernel_map, size * VAX_NBPG);
		if (addr == 0)
			panic("vax_map_physmem: kernel map full");
	} else {
		error = extent_alloc(extio, size * VAX_NBPG, VAX_NBPG, 0,
		    EX_NOBOUNDARY, EX_NOWAIT | EX_MALLOCOK, (u_long *)&addr);
		if (error != 0) {
			if (warned++ == 0) /* Warn only once */
				printf("vax_map_physmem: iomap too small");
			return 0;
		}
	}
	ioaccess(addr, phys, size);
#ifdef PHYSMEMDEBUG
	printf("vax_map_physmem: alloc'ed %d pages for paddr %lx, at %lx\n",
	    size, phys, addr);
#endif
	return addr | (phys & VAX_PGOFSET);
}

/*
 * Unmaps the previous mapped (addr, size) pair.
 */
void
vax_unmap_physmem(addr, size)
	vaddr_t addr;
	int size;
{
#ifdef PHYSMEMDEBUG
	printf("vax_unmap_physmem: unmapping %d pages at addr %lx\n", 
	    size, addr);
#endif
	iounaccess(addr, size);
	if (size >= LTOHPN)
		uvm_km_free(kernel_map, addr, size * VAX_NBPG);
	else
		extent_free(extio, (u_long)addr & ~VAX_PGOFSET,
		    size * VAX_NBPG, EX_NOWAIT);
}

/*
 * The following is a very stripped-down db_disasm.c, with only the logic
 * to skip instructions.
 */

long skip_operand(long, int);
long skip_opcode(long);

static u_int8_t get_byte(long);

static __inline__ u_int8_t
get_byte(ib)
	long    ib;
{
	return *((u_int8_t *)ib);
}

long
skip_opcode(ib)
	long    ib;
{
	u_int opc;
	int size;
	char *argp;	/* pointer into argument-list */

	opc = get_byte(ib++);
	if (opc >= 0xfd) {
		/* two byte op-code */
		opc = opc << 8;
		opc += get_byte(ib++);
		argp = vax_inst2[INDEX_OPCODE(opc)].argdesc;
	} else
		argp = vax_inst[opc].argdesc;

	if (argp == NULL)
		return ib;

	while (*argp) {
		switch (*argp) {

		case 'b':	/* branch displacement */
			switch (*(++argp)) {
			case 'b':
				ib++;
				break;
			case 'w':
				ib += 2;
				break;
			case 'l':
				ib += 4;
				break;
			}
			break;

		case 'a':	/* absolute addressing mode */
			/* FALLTHROUGH */
		default:
			switch (*(++argp)) {
			case 'b':	/* Byte */
				size = 1;
				break;
			case 'w':	/* Word */
				size = 2;
				break;
			case 'l':	/* Long-Word */
			case 'f':	/* F_Floating */
				size = 4;
				break;
			case 'q':	/* Quad-Word */
			case 'd':	/* D_Floating */
			case 'g':	/* G_Floating */
				size = 8;
				break;
			case 'o':	/* Octa-Word */
			case 'h':	/* H_Floating */
				size = 16;
				break;
			default:
				size = 0;
			}
			ib = skip_operand(ib, size);
		}

		if (!*argp || !*++argp)
			break;
		if (*argp++ != ',')
			break;
	}

	return ib;
}

long
skip_operand(ib, size)
	long    ib;
	int	size;
{
	int c = get_byte(ib++);

	switch (c >> 4) { /* mode */
	case 4:		/* indexed */
		ib = skip_operand(ib, 0);
		break;

	case 9:		/* autoincrement deferred */
		if (c == 0x9f) {	/* pc: immediate deferred */
			/*
			 * addresses are always longwords!
			 */
			ib += 4;
		}
		break;
	case 8:		/* autoincrement */
		if (c == 0x8f) {	/* pc: immediate ==> special syntax */
			ib += size;
		}
		break;

	case 11:	/* byte displacement deferred/ relative deferred  */
	case 10:	/* byte displacement / relative mode */
		ib++;
		break;

	case 13:		/* word displacement deferred */
	case 12:		/* word displacement */
		ib += 2;
		break;

	case 15:		/* long displacement referred */
	case 14:		/* long displacement */
		ib += 4;
		break;
	}

	return ib;
}

void
generic_halt()
{
	if (cpmbx->user_halt != UHALT_DEFAULT) {
		if (cpmbx->mbox_halt != 0)
			cpmbx->mbox_halt = 0;	/* let console override */
	} else if (cpmbx->mbox_halt != MHALT_HALT)
		cpmbx->mbox_halt = MHALT_HALT;	/* the os decides */

	asm("halt");
}

void
generic_reboot(int arg)
{
	if (cpmbx->user_halt != UHALT_DEFAULT) {
		if (cpmbx->mbox_halt != 0)
			cpmbx->mbox_halt = 0;
	} else if (cpmbx->mbox_halt != MHALT_REBOOT)
		cpmbx->mbox_halt = MHALT_REBOOT;

	asm("halt");
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	extern int oldvsbus;
	int oldipl = mfpr(PR_IPL);

	/*
	 * Do not complain for older vsbus systems where vsbus interrupts
	 * at 0x14, instead of the expected 0x15. Since these systems are
	 * not expandable and all their devices interrupt at the same
	 * level, there is no risk of them interrupting each other while
	 * they are servicing an interrupt, even at level 0x14.
	 */
	if (oldvsbus != 0 && oldipl == 0x14)
		oldipl = 0x15;

	/*
	 * ... and then, IPL_TYY is now 0x16 because of KA60 interrupt
	 * assignments, so we should not mind if splassert(IPL_TTY) and
	 * IPL 0x15 on other machines.
	 */
	if (wantipl == IPL_TTY && oldipl == 0x15) {
#ifdef VAX60
		if (vax_boardtype != VAX_BTYP_60)
#endif
			oldipl = 0x16;
	}
		
	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		mtpr(wantipl, PR_IPL);
	}
}
#endif

void	_start(struct rpb *);
void	main(void);

extern	paddr_t avail_end;
extern	int physmem;
paddr_t	esym;
u_int	proc0paddr;
char	cpu_model[100];

/*
 * The strict cpu-dependent information is set up here, in
 * form of a pointer to a struct that is specific for each cpu.
 */
extern struct cpu_dep ka43_calls;
extern struct cpu_dep ka46_calls;
extern struct cpu_dep ka48_calls;
extern struct cpu_dep ka49_calls;
extern struct cpu_dep ka53_calls;
extern struct cpu_dep ka410_calls;
extern struct cpu_dep ka630_calls;
extern struct cpu_dep ka650_calls;
extern struct cpu_dep ka660_calls;
extern struct cpu_dep ka670_calls;
extern struct cpu_dep ka680_calls;
extern struct cpu_dep ka60_calls;
extern struct cpu_dep vxt_calls;

/*
 * Start is called from boot; the first routine that is called
 * in kernel. Kernel stack is setup somewhere in a safe place;
 * but we need to move it to a better known place. Memory
 * management is disabled, and no interrupt system is active.
 */
void
_start(struct rpb *prpb)
{
	extern vaddr_t scratch;
	int preserve_cca = 0;

	mtpr(AST_NO, PR_ASTLVL); /* Turn off ASTs */

	findcpu(); /* Set up the CPU identifying variables */

	if (vax_confdata & 0x80)
		strlcpy(cpu_model, "MicroVAX ", sizeof cpu_model);
	else
		strlcpy(cpu_model, "VAXstation ", sizeof cpu_model);

	switch (vax_boardtype) {
#if VAX410
	case VAX_BTYP_420: /* They are very similar */
		dep_call = &ka410_calls;
		strlcat(cpu_model, "3100", sizeof cpu_model);
		switch (vax_cpustype) {
		case 0x00:
			strlcat(cpu_model, "/m{30,40}", sizeof cpu_model);
			break;
		case 0x01:
			strlcat(cpu_model, "/m{38,48}", sizeof cpu_model);
			break;
		case 0x02:
			strlcat(cpu_model, "/m{10,20}{,e}", sizeof cpu_model);
			break;
		}
		break;

	case VAX_BTYP_410:
		dep_call = &ka410_calls;
		strlcat(cpu_model, "2000", sizeof cpu_model);
		break;
#endif
#if VAX43
	case VAX_BTYP_43:
		dep_call = &ka43_calls;
		strlcat(cpu_model, "3100/m76", sizeof cpu_model);
		break;
#endif
#if VAX46
	case VAX_BTYP_46:
		dep_call = &ka46_calls;
		switch (vax_siedata & 0xff) {
		case VAX_VTYP_47:
			strlcpy(cpu_model, "MicroVAX 3100 m80", sizeof cpu_model);
			break;
		case VAX_VTYP_46:
			strlcpy(cpu_model, "VAXstation 4000/60", sizeof cpu_model);
			break;
		default:
			strlcat(cpu_model, " - Unknown Mariah", sizeof cpu_model);
		}
		break;
#endif
#ifdef VXT
	case VAX_BTYP_VXT:
		dep_call = &vxt_calls;
		strlcpy(cpu_model, "VXT2000", sizeof cpu_model);
		break;
#endif
#if VAX48
	case VAX_BTYP_48:
		dep_call = &ka48_calls;
		switch (vax_cpustype) {
		case VAX_STYP_45:
			strlcpy(cpu_model, "MicroVAX 3100/m{30,40}", sizeof cpu_model);
			break;
		case VAX_STYP_48:
			strlcpy(cpu_model, "VAXstation 4000/VLC", sizeof cpu_model);
			break;
		default:
			strlcat(cpu_model, " - Unknown SOC", sizeof cpu_model);
		}
		break;
#endif
#if VAX49
	case VAX_BTYP_49:
		dep_call = &ka49_calls;
		strlcpy(cpu_model, "VAXstation 4000/90", sizeof cpu_model);
		break;
#endif
#if VAX53
	case VAX_BTYP_1303:	
		dep_call = &ka53_calls;
		switch (vax_cpustype) {
		case VAX_STYP_50:
			strlcpy(cpu_model, "MicroVAX 3100 model 85 or 90", sizeof cpu_model);
			break;
		case VAX_STYP_51:
			strlcpy(cpu_model, "MicroVAX 3100 model 90 or 95", sizeof cpu_model);
			break;
		case VAX_STYP_52:
			strlcpy(cpu_model, "VAX 4000 100", sizeof cpu_model);
			break;
		case VAX_STYP_53:
			strlcpy(cpu_model, "VAX 4000 105A", sizeof cpu_model);
			break;
		default:
			strlcpy(cpu_model, "VAX - Unknown Cheetah Class", sizeof cpu_model);
		}
		break;
#endif
#if VAX630
	case VAX_BTYP_630:
		dep_call = &ka630_calls;
		strlcpy(cpu_model,"MicroVAX II", sizeof cpu_model);
		break;
#endif
#if VAX650
	case VAX_BTYP_650:
		dep_call = &ka650_calls;
		strlcpy(cpu_model,"MicroVAX ", sizeof cpu_model);
		switch (vax_cpustype) {
		case VAX_STYP_640:
			strlcat(cpu_model, "3300/3400", sizeof cpu_model);
			break;

		case VAX_STYP_650:
			strlcat(cpu_model, "3500/3600", sizeof cpu_model);
			break;

		case VAX_STYP_655:
			strlcat(cpu_model, "3800/3900", sizeof cpu_model);
			break;

		default:
			strlcat(cpu_model, "III", sizeof cpu_model);
			break;
		}
		break;
#endif
#if VAX660
	case VAX_BTYP_660:
		dep_call = &ka660_calls;
		strlcpy(cpu_model,"VAX 4000 200", sizeof cpu_model);
		break;
#endif
#if VAX670
	case VAX_BTYP_670:
		dep_call = &ka670_calls;
		strlcpy(cpu_model,"VAX 4000 300", sizeof cpu_model);
		break;
#endif
#if VAX680
	case VAX_BTYP_1301:
		dep_call = &ka680_calls;
		strlcpy(cpu_model,"VAX 4000 ", sizeof cpu_model);
		switch (vax_cpustype) {
		case VAX_STYP_675:
			strlcat(cpu_model,"400", sizeof cpu_model);
			break;
		case VAX_STYP_680:
			strlcat(cpu_model,"500", sizeof cpu_model);
			break;
		case VAX_STYP_690:
			strlcat(cpu_model,"600", sizeof cpu_model);
			break;
		default:
			strlcat(cpu_model,"- Unknown Omega Class", sizeof cpu_model);
		}
		break;
	case VAX_BTYP_1305:
		dep_call = &ka680_calls;
		strlcpy(cpu_model,"VAX 4000 ", sizeof cpu_model);
		switch (vax_cpustype) {
		case VAX_STYP_681:
			strlcat(cpu_model,"500A", sizeof cpu_model);
			break;
		case VAX_STYP_691:
			strlcat(cpu_model,"605A", sizeof cpu_model);
			break;
		case VAX_STYP_694:
			if (vax_cpudata & 0x1000)
				strlcat(cpu_model,"705A", sizeof cpu_model);
			else
				strlcat(cpu_model,"700A", sizeof cpu_model);
			break;
		default:
			strlcat(cpu_model,"- Unknown Legacy Class", sizeof cpu_model);
		}
		break;
#endif
#ifdef VAX60
	case VAX_BTYP_60:
		dep_call = &ka60_calls;
		preserve_cca = 1;
		/* cpu_model will be set in ka60_init */
		break;
#endif
	default:
		/* CPU not supported, just give up */
		asm("halt");
	}

	/*
	 * Machines older than MicroVAX II have their boot blocks
	 * loaded directly or the boot program loaded from console
	 * media, so we need to figure out their memory size.
	 * This is not easily done on MicroVAXen, so we get it from
	 * VMB instead.
	 *
	 * In post-1.4 a RPB is always provided from the boot blocks.
	 */
#if 1 /* compat with old bootblocks */
	if (prpb == 0) {
		bzero((caddr_t)proc0paddr + REDZONEADDR, sizeof(struct rpb));
		prpb = (struct rpb *)(proc0paddr + REDZONEADDR);
		prpb->pfncnt = avail_end >> VAX_PGSHIFT;
		prpb->rpb_base = (void *)-1;    /* RPB is fake */
	} else
#endif
	bcopy(prpb, (caddr_t)proc0paddr + REDZONEADDR, sizeof(struct rpb));
	if (prpb->pfncnt)
		avail_end = prpb->pfncnt << VAX_PGSHIFT;
	else
		while (badaddr((caddr_t)avail_end, 4) == 0)
			avail_end += VAX_NBPG * 128;
	boothowto = prpb->rpb_bootr5;

	physmem = atop(avail_end);

	/*
	 * If we need to use the Console Communication Area, make sure
	 * we will not stomp over it.
	 *
	 * On KA60 systems, the PROM apparently forgets to keep the CCA
	 * out of the reported memory size.  It's no real surprise, as
	 * the memory bitmap pointed to by the CCA reports all physical
	 * memory (including itself and the CCA) as available!
	 * (which means the bitmap is not worth looking at either)
	 */

	if (preserve_cca) {
		if (prpb->cca_addr != 0 && avail_end > prpb->cca_addr) {
			struct cca *cca = (struct cca *)prpb->cca_addr;

			/*
			 * XXX Should validate the CCA image here.
			 */

			avail_end = prpb->cca_addr;
			if (cca->cca_bitmap != 0 && avail_end > cca->cca_bitmap)
				avail_end = cca->cca_bitmap;
		}
	}

        avail_end = trunc_page(avail_end); /* be sure */

	proc0.p_addr = (struct user *)proc0paddr; /* XXX */
	bzero((struct user *)proc0paddr, sizeof(struct user));
	proc0.p_addr->u_pcb.pcb_paddr = (paddr_t)proc0paddr - KERNBASE;

	pmap_bootstrap();

	/* Now running virtual. set red zone for proc0 */
	*kvtopte((u_int)proc0.p_addr + REDZONEADDR) &= ~PG_V;

	((struct pcb *)proc0paddr)->framep = (void *)scratch;

	/*
	 * Change mode down to userspace is done by faking a stack
	 * frame that is setup in cpu_set_kpc(). Not done by returning
	 * from main anymore.
	 */
	main();
	/* NOTREACHED */
}
@


1.150
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.149 2015/05/13 08:01:21 mpi Exp $ */
@


1.149
log
@Remove useless "bridge.h" include.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.148 2015/02/07 23:30:13 miod Exp $ */
a629 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.148
log
@typos
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.147 2014/12/22 02:26:54 tedu Exp $ */
a82 1
#include "bridge.h"	/* For NBRIDGE */
@


1.147
log
@unifdef INET
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.146 2014/12/10 15:29:53 mikeb Exp $ */
d787 1
a787 1
 * be use by console device drivers (before the map system is inied).
@


1.146
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.145 2014/11/18 20:51:01 krw Exp $ */
a79 1
#ifdef INET
a81 1
#endif
@


1.145
log
@Nuke some obvious #include duplications.

ok espie@@ deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.144 2014/09/20 09:28:24 kettenis Exp $ */
a537 1
	doshutdownhooks();
@


1.144
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.143 2014/07/21 17:25:47 uebayasi Exp $ */
a78 2

#include <net/if.h>
@


1.143
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a513 2
	struct device *mainbus;

d541 1
a541 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.142
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d538 1
a538 1
	if (howto & RB_DUMP)
d547 1
a547 1
	if (howto & RB_HALT) {
@


1.141
log
@Cosmetic changes to reduce diffs.
@
text
@a540 1

@


1.140
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.139 2014/07/10 20:15:27 uebayasi Exp $ */
d535 1
a535 1
	splhigh();		/* Disable interrupts. */
a537 1
	/* If rebooting and a dump is requested, do it. */
@


1.139
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d535 2
a536 1
	splhigh();		/* extreme priority */
@


1.138
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a515 1
	/* If system is cold, just halt. */
a516 1
		/* (Unless the user explicitly asked for reboot.) */
@


1.137
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d527 1
a527 4
		/*
		 * If we've been adjusting the clock, the todr will be out of
		 * synch; adjust it now.
		 */
@


1.136
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.135 2014/05/30 13:46:17 mpi Exp $ */
d511 2
a512 3
void
boot(howto)
	register int howto;
@


1.135
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.134 2014/05/25 13:57:48 deraadt Exp $ */
d541 1
a541 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.134
log
@Turn on blinky things by default, very useful here
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.133 2014/03/26 05:23:42 guenther Exp $ */
d541 2
a542 1
	splhigh();		/* extreme priority */
@


1.133
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.132 2014/03/22 06:05:45 guenther Exp $ */
d144 1
a144 1
int	vax_led_blink = 0;
@


1.132
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.131 2014/03/13 03:52:56 dlg Exp $ */
d496 1
a496 1
	syscf->pc = p->p_sigcode;
@


1.131
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.130 2013/11/24 22:08:25 miod Exp $ */
d446 1
a446 1
	struct	sigacts *psp = p->p_sigacts;
@


1.130
log
@Rework pmap to use dynamic P0 and P1 region allocation, instead of allocating
the largest possible page table for every pmap; from NetBSD. This allows the
kernel to use much less memory for page tables.

Significant differences against the NetBSD code are:
- allocation of page table pages is done with a pool instead of allocating
  whole logical pages from uvm and managing the freelist within pmap, never
  releasing allocated pages.
- try to use pt_entry_t * rather than int * whenever possible.
- growth of P0 and P1 regions is allowed to fail, if invoked from
  pmap_enter with the PMAP_CANFAIL flag. This will stall processes until
  memory for the page tables can be obtained, rather than panicing, in
  most cases.
- keep management of mappings for managed pages using pv lists tied to the
  vm_page (using __HAVE_VM_PAGE_MD), rather than a global pv_list head.
- bound check against Sysmap[] in pmap_extract() when asked for a kernel
  address.

As a result of this, bsd.rd can now install a working system on a 12MB machine
without needing to enable swap.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.129 2013/11/20 23:57:07 miod Exp $ */
d515 2
d550 3
a552 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.129
log
@Update comments mentioning `resource maps' to mention `extents' instead.
Resource maps have been removed more than 10 years ago, it's about time to
update comments to better match reality.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.128 2013/11/13 02:23:33 uebayasi Exp $ */
d169 2
a170 1
	printf("%s%s [%08X %08X]\n", version, cpu_model, vax_cpudata, vax_siedata);
d174 1
a174 1
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
d1345 1
@


1.128
log
@Honor RB_TIMEBAD on vax too as other ports.

OK miod@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d323 1
a323 1
	 * Init I/O memory resource map. Must be done before cninit()
d792 3
a794 3
 * uses resource maps when allocating space, which is allocated from 
 * the IOMAP submap. The implementation is similar to the uba resource
 * map handling. Size is given in pages.
@


1.127
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.126 2013/07/05 21:11:57 miod Exp $ */
d529 5
a533 1
		resettodr();
@


1.126
log
@VAX ELF kernel bits.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.125 2013/06/29 13:00:35 miod Exp $ */
d543 2
a544 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.125
log
@Minor fixes to let this build with gcc 3.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.124 2013/06/11 16:42:13 deraadt Exp $ */
d595 2
a596 2
	asm("movl %0, r5":: "g" (showto)); /* How to boot */
	asm("movl %0, r11":: "r"(showto)); /* ??? */
d1051 1
a1051 1
void	start(struct rpb *);
d1085 1
a1085 1
start(struct rpb *prpb)
@


1.124
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.123 2012/12/02 07:03:32 guenther Exp $ */
d576 8
a583 8
		asm("	movl	sp, (0x80000200)
			movl	0x80000200, sp
			mfpr	$0x10, -(sp)	# PR_PCBB
			mfpr	$0x11, -(sp)	# PR_SCBB
			mfpr	$0xc, -(sp)	# PR_SBR
			mfpr	$0xd, -(sp)	# PR_SLR
			mtpr	$0, $0x38	# PR_MAPEN
		");
@


1.123
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.122 2012/10/08 21:47:50 deraadt Exp $ */
d606 2
a607 2
	daddr64_t blkno;
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.122
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.121 2012/03/24 19:09:20 guenther Exp $ */
d349 1
a349 1
	int	sc_onstack;		/* sigstack state to restore */
a396 4
	if (ksc.sc_onstack & 01)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
a448 1
	int	onstack;
a450 1
	onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d453 2
a454 1
	if (onstack)
a472 1
	gsigf.sf_sc.sc_onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
a504 3

	if (onstack)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
@


1.121
log
@Missed a reference to the u_stats member when struct pstats was removed
from struct user.  Nothing left to zero-out here so the line goes.

pointed out by deraaadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.120 2011/09/19 21:53:02 miod Exp $ */
d549 2
a550 1
	/* Run any shutdown hooks. */
d552 1
a553 1
haltsys:
@


1.120
log
@Try and clean system type constants a bit:
- save the second byte of vax_siedata into a new variable, vax_cpustype,
  and use it instead of (vax_siedata >> 8) & 0xff or other similar
  constructs.
- the VAX_SIE_KAxxx constants are duplicates of the VAX_STYP_xx constants.
  Standardize on the latter and kill the former.
- only keep VAX_VTYP_xx constants for KA46 and KA47, those are the only
  systems which use these constants and are told apart by a different
  SIE byte.

No functional change intended.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.119 2011/07/09 00:47:18 henning Exp $ */
a1346 3

	/* Clear the used parts of the uarea except for the pcb */
	bzero(&proc0.p_addr->u_stats, sizeof(struct user) - sizeof(struct pcb));
@


1.119
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.118 2011/07/06 20:42:52 miod Exp $ */
d1112 1
a1112 1
		switch ((vax_siedata >> 8) & 0xff) {
d1139 1
a1139 1
		switch(vax_siedata & 0xff) {
d1160 1
a1160 1
		switch ((vax_siedata >> 8) & 0xff) {
d1181 1
a1181 1
		switch ((vax_siedata >> 8) & 0xff) {
d1209 2
a1210 2
		switch ((vax_siedata >> 8) & 255) {
		case VAX_SIE_KA640:
d1214 1
a1214 1
		case VAX_SIE_KA650:
d1218 1
a1218 1
		case VAX_SIE_KA655:
d1244 1
a1244 1
		switch ((vax_siedata >> 8) & 0xff) {
d1261 1
a1261 1
		switch ((vax_siedata >> 8) & 0xff) {
@


1.118
log
@These files no longer need to include <machine/nexus.h>
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.117 2011/07/06 18:33:00 miod Exp $ */
a84 3
#endif
#ifdef NETATALK
#include <netatalk/at_extern.h>
@


1.117
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.116 2011/07/05 04:48:02 guenther Exp $ */
a96 1
#include <machine/nexus.h>
@


1.116
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.115 2011/06/26 22:40:00 deraadt Exp $ */
a1075 4
extern struct cpu_dep ka780_calls;
extern struct cpu_dep ka750_calls;
extern struct cpu_dep ka860_calls;
extern struct cpu_dep ka820_calls;
a1111 22
#if VAX780
	case VAX_BTYP_780:
		dep_call = &ka780_calls;
		strlcpy(cpu_model,"VAX 11/780", sizeof cpu_model);
		if (vax_cpudata & 0x100)
			cpu_model[9] = '5';
		break;
#endif
#if VAX750
	case VAX_BTYP_750:
		dep_call = &ka750_calls;
		strlcpy(cpu_model, "VAX 11/750", sizeof cpu_model);
		break;
#endif
#if VAX8600
	case VAX_BTYP_790:
		dep_call = &ka860_calls;
		strlcpy(cpu_model,"VAX 8600", sizeof cpu_model);
		if (vax_cpudata & 0x100)
			cpu_model[6] = '5';
		break;
#endif
a1280 7
		break;
#endif
#if VAX8200
	case VAX_BTYP_8000:
		mastercpu = mfpr(PR_BINID);
		dep_call = &ka820_calls;
		strlcpy(cpu_model, "VAX 8200", sizeof cpu_model);
@


1.115
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.114 2011/06/05 19:41:08 deraadt Exp $ */
d402 1
a402 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d404 1
a404 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
d460 1
a460 1
	onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d464 1
a464 1
		cursp = ((int)psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size);
d482 1
a482 1
	gsigf.sf_sc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d517 1
a517 1
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
@


1.114
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.113 2011/04/18 21:44:56 guenther Exp $ */
d77 1
d544 1
@


1.113
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.111 2010/12/21 14:56:24 claudio Exp $ */
a109 11

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef	BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.112
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d412 1
a412 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d414 1
a414 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
d470 1
a470 1
	onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d474 1
a474 1
		cursp = ((int)p->p_sigstk.ss_sp + p->p_sigstk.ss_size);
d492 1
a492 1
	gsigf.sf_sc.sc_onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d527 1
a527 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
@


1.111
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.110 2010/06/29 18:46:34 tedu Exp $ */
d412 1
a412 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d414 1
a414 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
d470 1
a470 1
	onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d474 1
a474 1
		cursp = ((int)psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size);
d492 1
a492 1
	gsigf.sf_sc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d527 1
a527 1
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
@


1.110
log
@COMPAT_ULTRIX is not used, time to retire it.  ok deraadt miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.109 2010/06/27 12:41:23 miod Exp $ */
a78 1
#include <net/netisr.h>
@


1.109
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.108 2010/06/10 17:54:13 deraadt Exp $ */
a511 4

#if defined(COMPAT_ULTRIX)
	native_sigset_to_sigset13(mask, &gsigf.sf_sc.__sc_mask13);
#endif
@


1.108
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.107 2010/05/26 16:35:29 deraadt Exp $ */
d77 1
a77 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>
d163 3
@


1.107
log
@rename intvec.s to locore.S, and add the guts of locore.C to machdep.c
ok miod ragge
We cannot yet get at vax/subr.s via files.vax because rdsetroot doesn't
like it when the "start" symbol isn't in the first page of the executable.
subr.s will have to be merged into locore.S later on, when other problems
with ENTRY() are solved (says Miod)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.106 2009/08/11 19:17:17 miod Exp $ */
d134 6
@


1.106
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.105 2009/08/11 18:46:32 miod Exp $ */
a97 4
#include <machine/pte.h>
#include <machine/mtpr.h>
#include <machine/cpu.h>
#include <machine/macros.h>
a98 2
#include <machine/trap.h>
#include <machine/reg.h>
d102 2
d1068 341
@


1.105
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.104 2009/08/09 10:40:18 blambert Exp $ */
a187 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.104
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.103 2009/08/02 16:28:39 beck Exp $ */
a116 2
caddr_t allocsys(caddr_t);

a167 2
	caddr_t		v;
	int		sz;
a189 11
	 * Find out how much space we need, allocate it, and then give
	 * everything true virtual addresses.
	 */

	sz = (int) allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (((unsigned long)allocsys(v) - (unsigned long)v) != sz)
		panic("startup: table size inconsistency");

	/*
a876 19
}

/*
 * Allocate space for system data structures.  We are given a starting
 * virtual address and we return a final virtual address; along the way we
 * set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want, allocate that
 * much and fill it with zeroes, and then call allocsys() again with the
 * correct base virtual address.
 */
#define VALLOC(name, type, num) v = (caddr_t)(((name) = (type *)v) + (num))

caddr_t
allocsys(v)
    register caddr_t v;
{

    return (v);
@


1.103
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.102 2009/06/20 21:02:15 miod Exp $ */
a79 4
#ifdef SYSVMSG
#include <sys/msg.h>
#endif

a908 7

#ifdef SYSVMSG
    VALLOC(msgpool, char, msginfo.msgmax);
    VALLOC(msgmaps, struct msgmap, msginfo.msgseg);
    VALLOC(msghdrs, struct msg, msginfo.msgtql);
    VALLOC(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.102
log
@Preserve more registers in sigcontext, and restore them in sigreturn. This
makes the sigreturn regress test pass, as well as todd@@'s ``run
sh -c "trap exit 2 3;while :; do sleep 120; done", then press ^C'' test pass.

Since userland setjmp uses sigcontext, the kernel will still support the
old layout for a while (until libc is fixed and a reasonable grace period
is over).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.101 2009/06/15 17:01:26 beck Exp $ */
a213 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.101
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.100 2009/06/03 21:30:20 beck Exp $ */
d388 19
d419 1
d424 9
a432 2
	if (copyin((caddr_t)cntx, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);
d448 16
a463 1
	scf->ap = ksc.sc_ap;
a464 1
	scf->sp = ksc.sc_sp;
d470 1
d474 1
a474 1
	register_t 	 sf_r0, sf_r1, sf_r2, sf_r3, sf_r4, sf_r5;
d476 3
a478 1
	register_t 	 sf_arg;
a510 1
	gsigf.sf_arg = (register_t)&sigf->sf_sc;
d513 1
d521 5
d528 12
a539 5
	gsigf.sf_sc.sc_ap = syscf->ap;
	gsigf.sf_sc.sc_fp = syscf->fp; 
	gsigf.sf_sc.sc_sp = syscf->sp; 
	gsigf.sf_sc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	gsigf.sf_sc.sc_mask = mask;
d553 2
a554 1
	 * sigframe/struct sigcontext pair with their own.
d556 2
a557 2
	syscf->sp = syscf->ap =
	    (unsigned) sigf + offsetof(struct sigframe, sf_pc);
@


1.100
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.99 2008/08/18 23:19:29 miod Exp $ */
d214 6
@


1.99
log
@Add support for the ``Firefox'' VAXstation 3520/3540/3820/3840 workstations,
currently limited to serial console and a single processor working.

All ``on-board'' devices, including the Q-bus adapter, but except for
the frame buffer, are supported. The machine will boot over the network
or from SCSI devices.

Lots of thanks to Al Kossow for www.bitsavers.org, on which I found the
technical documentation allowing me to complete this port (which was
lacking at the time I got that machine...).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.98 2008/08/18 23:08:57 miod Exp $ */
a213 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.98
log
@Preparing for KA60 support, crank IPL_TTY to level 0x16 (since it is
hardwired this way on KA60...), and compensate in splassert_check() when
serial device interrupts will remain at 0x14 or 0x15.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.97 2008/08/14 11:41:30 martin Exp $ */
a176 1
	extern unsigned int avail_end;
d192 2
a193 3
	printf("real mem = %u (%uMB)\n", avail_end,
	    avail_end/1024/1024);
	physmem = atop(avail_end);
d229 1
a229 1
#if VAX46 || VAX48 || VAX49 || VAX53
d238 2
a239 1
	    vax_boardtype == VAX_BTYP_49 || vax_boardtype == VAX_BTYP_1303)
d285 1
a285 4
	/*
	 * XXX include the final RAM page which is not included in physmem.
	 */
	dumpsize = physmem + 1;
@


1.97
log
@convert the last traces of btoc/ctob macros

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.96 2008/06/27 17:22:15 miod Exp $ */
d1054 12
@


1.96
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.95 2008/04/09 16:58:10 deraadt Exp $ */
d195 1
a195 1
	physmem = btoc(avail_end);
d290 2
a291 2
	if (dumpsize > btoc(dbtob(nblks - dumplo)))
		dumpsize = btoc(dbtob(nblks - dumplo));
d293 1
a293 1
		dumplo = nblks - btodb(ctob(dumpsize));
@


1.95
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.95 2008/04/09 16:50:30 deraadt Exp $ */
d78 1
d639 4
@


1.94
log
@Only create phys_map on systems which need it, and test for phys_map being
non-null instead of for a variety of vax_boardtype values in vmapbuf() and
vunmapbuf().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.93 2007/12/28 20:41:56 miod Exp $ */
d533 2
@


1.93
log
@There is no need, and no point, to initialize panicstr here.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.92 2007/06/06 17:15:13 deraadt Exp $ */
d230 1
d234 9
a242 3
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);
@


1.92
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.91 2007/05/29 20:36:48 deraadt Exp $ */
a194 1
	panicstr = NULL;
@


1.91
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.90 2007/05/27 17:31:57 miod Exp $ */
d598 2
a599 2
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.90
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.89 2007/05/26 20:26:51 pedro Exp $ */
d269 1
a269 1
dumpconf()
d273 6
d283 4
a286 7
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
		nblks = (*bdevsw[major(dumpdev)].d_psize) (dumpdev);
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo == 0)
			dumplo = nblks - btodb(ctob(dumpsize));
	}
@


1.89
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.88 2007/05/25 14:50:38 deraadt Exp $ */
d227 1
@


1.88
log
@rename cpu_dumpconf() to dumpconf(); no need to be different from other architectures
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.87 2007/05/23 20:33:47 pvalchev Exp $ */
a125 5
#ifdef	NBUF
int nbuf = NBUF;
#else
int nbuf = 0;
#endif
d174 1
a174 1
	int		base, residual, i, sz;
a175 1
	vsize_t		size;
d209 1
d211 2
a212 2
	 * Now allocate buffers proper.	 They are different than the above in
	 * that they usually occupy more virtual memory than physical.
d214 2
a215 1
	size = MAXBSIZE * nbuf;		/* # bytes for buffers */
d217 5
a221 41
	/* allocate VM for buffers... area is not managed by VM system */
	if (uvm_map(kernel_map, (vaddr_t *)&buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
			UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");

	minaddr = (vaddr_t)buffers;
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	/* now allocate RAM for buffers */
	for (i = 0; i < nbuf; i++) {
		vaddr_t curbuf;
		vsize_t curbufsize;
		struct vm_page *pg;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.	The rest get (base) physical pages.
		 * 
		 * The rest of each buffer occupies virtual space, but has no
		 * physical memory allocated for it.
		 */
		curbuf = (vaddr_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base + 1 : base);
		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: "
				    "not enough RAM for buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ | VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(kernel_map->pmap);
a238 1
	printf("using %d buffers containing %d bytes of memory\n", nbuf, bufpages * PAGE_SIZE);
a856 22
	/*
	 * Determine how many buffers to allocate.  We make sure we allocate
	 * at least 16 buffers.  	 
	 */
	if (bufpages == 0) {
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    bufcachepercent / 100;
	}
    if (nbuf == 0) 
        nbuf = bufpages < 16 ? 16 : bufpages;

    /* Restrict to at most 70% filled kvm */
    if (nbuf * MAXBSIZE >
        (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
        nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
            MAXBSIZE * 7 / 10;

    /* More buffer pages than fits into the buffers is senseless.  */
    if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
        bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

    VALLOC(buf, struct buf, nbuf);
@


1.87
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.86 2007/05/16 16:30:42 deraadt Exp $ */
d173 1
a173 1
void cpu_dumpconf(void);
d309 1
a309 1
cpu_dumpconf()
d652 1
a652 1
		cpu_dumpconf();
@


1.86
log
@we need a cpu_info_store; how did miod miss this?
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.85 2007/05/16 05:19:15 miod Exp $ */
d198 2
a199 1
	printf("total memory = %d\n", avail_end);
d277 2
a278 1
	printf("avail memory = %ld\n", ptoa(uvmexp.free));
@


1.85
log
@Switch vax to __HAVE_CPUINFO, based on an incomplete diff from art.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.84 2006/07/20 19:15:35 miod Exp $ */
d170 2
@


1.84
log
@Here cometh the blinkenlichten on VAXens.
Register information from NetBSD (except for KA53), logic from OpenBSD/sparc.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.83 2006/07/19 20:41:34 miod Exp $ */
d389 1
a389 1
	panic("setstatclockrate");
@


1.83
log
@Actually we can optimize further an assignment in sendsig().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.82 2006/07/19 20:38:33 miod Exp $ */
d118 1
a118 1
#include "smg.h"
d166 5
d350 3
d367 12
@


1.82
log
@Trivial simplification in the signal delivery code; shave one instruction
from sigcode and one computation from sendsig(), isn't life great?
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.81 2006/07/16 22:40:42 miod Exp $ */
a475 7
	/*
	 * Place sp at the beginning of sigf; this ensures that possible
	 * further calls to sendsig won't overwrite this struct
	 * sigframe/struct sigcontext pair with their own.
	 */
	cursp = (unsigned) sigf;

d504 5
@


1.81
log
@Fix splassert false positives on older VAXstation with devices wired to
ipl 0x14 instead of the expected 0x15.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.80 2006/06/11 22:09:33 miod Exp $ */
d511 2
a512 2
	syscf->ap = (unsigned) sigf + offsetof(struct sigframe, sf_pc);
	syscf->sp = cursp;
@


1.80
log
@Working kernel crash dumps.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.79 2006/06/02 17:39:59 miod Exp $ */
d1066 1
d1069 10
@


1.79
log
@Implement splassert() on vax.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.78 2006/05/30 21:24:28 miod Exp $ */
d72 2
d109 1
a145 1
int		dumpsize = 0;
a196 2
	dumpsize = physmem + 1;

d294 2
d297 1
a297 1
long	dumpmag = 0x8fca0101;
d302 1
a302 1
	int		nblks;
d315 1
d322 11
d612 8
d629 1
a629 1
	if (dumpsize == 0)
d631 4
d636 1
a636 1
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
d640 3
d645 10
d656 31
a686 1
	switch ((*bdevsw[major(dumpdev)].d_dump) (dumpdev, 0, 0, 0)) {
d704 4
d709 1
a709 1
		printf("succeeded\n");
@


1.78
log
@Map buffers with pmap_kenter_pa() instead of pmap_enter().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.77 2006/03/07 20:20:30 miod Exp $ */
d988 17
@


1.77
log
@Remove COMPAT_1x stuff inherited from NetBSD, which does not apply to us.
ok uwe@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.76 2006/01/04 15:41:29 martin Exp $ */
d247 2
a248 3
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE,
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.76
log
@add sysctl machdep.console_device support
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.75 2006/01/02 18:15:55 miod Exp $ */
d489 1
a489 1
#if defined(COMPAT_13) || defined(COMPAT_ULTRIX)
@


1.75
log
@No need to check for P_INMEM in process_set_pc() and process_sstep(), as these
function are only invoked between PHOLD and PRELE.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.74 2005/11/06 22:21:33 miod Exp $ */
d323 8
a330 6
cpu_sysctl(a, b, c, d, e, f, g)
	int	*a;
	u_int	b;
	void	*c, *e;
	size_t	*d, f;
	struct	proc *g;
d332 18
a349 1
	return (EOPNOTSUPP);
@


1.74
log
@Kill deprecated vm_offset_t and vm_size_t types on vax.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.73 2005/08/06 14:26:52 miod Exp $ */
a665 3
	if ((p->p_flag & P_INMEM) == 0)
		return (EIO);

a679 3

	if ((p->p_flag & P_INMEM) == 0)
		return (EIO);
@


1.73
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.72 2005/06/08 17:03:03 henning Exp $ */
d171 2
a172 2
	vm_offset_t	minaddr, maxaddr;
	vm_size_t	size;
d214 1
a214 1
	if (uvm_map(kernel_map, (vm_offset_t *) &buffers, round_page(size),
d220 1
a220 1
	minaddr = (vm_offset_t) buffers;
d229 2
a230 2
		vm_offset_t curbuf;
		vm_size_t curbufsize;
d240 1
a240 1
		curbuf = (vm_offset_t) buffers + i * MAXBSIZE;
@


1.72
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.71 2004/12/02 19:40:46 miod Exp $ */
a141 1
char		machine_arch[] = MACHINE_ARCH;	/* from <machine/param.h> */
@


1.71
log
@We do not support 2MB machines, so don't bother taking them into account
in allocsys().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.70 2004/03/10 23:02:54 tom Exp $ */
a89 3
#endif
#ifdef NS
#include <netns/ns_var.h>
@


1.70
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.69 2003/11/07 10:16:45 jmc Exp $ */
a799 3
	    if (physmem < btoc(2 * 1024 * 1024))
	        bufpages = physmem / 10;
	    else
@


1.69
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.68 2003/06/26 13:06:26 miod Exp $ */
d499 3
a501 1
		howto |= RB_HALT;
@


1.68
log
@Compile the vax kernel with -Wmissing-prototypes -Wstrict-prototypes now.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.67 2003/06/02 23:27:59 millert Exp $ */
d875 1
a875 1
		case 'a':	/* absolute adressing mode */
@


1.67
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.66 2003/05/14 00:20:37 tedu Exp $ */
d168 2
d826 4
a829 1
long skip_operand(long ib, int size);
@


1.66
log
@add {b,c}devsw_lookup convenience functions.
move chrtoblk and blktochr into MI code.
tested on several archs and ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.65 2003/04/16 16:54:17 miod Exp $ */
d29 1
a29 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.65
log
@siginfo support for vax.
machdep.c changes by me, trap.c changes by deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.64 2003/04/08 14:53:11 hugh Exp $ */
a141 1
extern int *chrtoblktbl;
@


1.64
log
@Move definition of storage for cpu_model to locore.c so sizeof has
something meaningful to chew on. Shine on you crazy diamond.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.63 2002/12/17 23:11:32 millert Exp $ */
d413 9
a421 9
struct trampframe {
	unsigned	sig;	/* Signal number */
	unsigned	code;	/* Info code */
	unsigned	scp;	/* Pointer to struct sigcontext */
	unsigned	r0, r1, r2, r3, r4, r5; /* Registers saved when
						 * interrupt */
	unsigned	pc;	/* Address of signal handler */
	unsigned	arg;	/* Pointer to first (and only) sigreturn
				 * argument */
a423 3
/*
 * XXX no siginfo implementation!!!!
 */
d429 1
a429 1
	int 	type;
d435 2
a436 3
	struct	sigcontext *sigctx, gsigctx;
	struct	trampframe *trampf, gtrampf;
	unsigned	cursp;
a438 3
#if 0
printf("sendsig: signal %x  catcher %x\n", sig, catcher);
#endif
a439 1

d449 1
a449 3
	sigctx = (struct sigcontext *) (cursp - sizeof(struct sigcontext));
	trampf = (struct trampframe *) ((unsigned)sigctx -
	    sizeof(struct trampframe));
d452 1
a452 1
	 * Place sp at the beginning of trampf; this ensures that possible
d454 1
a454 1
	 * trampframe/struct sigcontext pair with their own.
d456 12
a467 1
	cursp = (unsigned) trampf;
d469 7
a475 13
	gtrampf.arg = (int) sigctx;
	gtrampf.pc = (unsigned) catcher;
	gtrampf.scp = (int) sigctx;
	gtrampf.code = code;
	gtrampf.sig = sig;

	gsigctx.sc_pc = syscf->pc;
	gsigctx.sc_ps = syscf->psl;
	gsigctx.sc_ap = syscf->ap;
	gsigctx.sc_fp = syscf->fp; 
	gsigctx.sc_sp = syscf->sp; 
	gsigctx.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	gsigctx.sc_mask = mask;
d478 1
a478 1
	native_sigset_to_sigset13(mask, &gsigctx.__sc_mask13);
d481 1
a481 2
	if (copyout(&gtrampf, trampf, sizeof(gtrampf)) ||
	    copyout(&gsigctx, sigctx, sizeof(gsigctx)))
d486 1
a486 1
	syscf->ap = (unsigned) sigctx-8;
@


1.63
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.62 2002/11/08 01:33:28 miod Exp $ */
a150 1
char		cpu_model[100];
d181 1
@


1.62
log
@Don't uvm_useracc the user sigcontext in sys_sigreturn and then access
the user addresses directly from the kernel. copyin is faster and can
correctly deal properly with mappings that uvm_useracc thinks are
correct but will fault anyway (to figure out how to generate such
mappings is left as en excercise for the reader).

Blatantly stolen from art@@'s similar fix to sparc.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.61 2002/09/21 13:42:43 hugh Exp $ */
a83 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a794 13
#ifdef SYSVSHM
    shminfo.shmmax = shmmaxpgs;
    shminfo.shmall = shmmaxpgs;
    shminfo.shmseg = shmseg;
    VALLOC(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
    VALLOC(sema, struct semid_ds, seminfo.semmni);
    VALLOC(sem, struct sem, seminfo.semmns);

    /* This is pretty disgusting! */
    VALLOC(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.61
log
@Add support for OS defined halt action on Cheetah and Omega.
Should also work on Legacy, but tester hasn't reported back yet...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.60 2002/07/20 19:24:57 art Exp $ */
d390 1
d395 3
a397 2
	if (uvm_useracc((caddr_t)cntx, sizeof (*cntx), B_READ) == 0)
		return EINVAL;
d399 3
a401 3
	if ((cntx->sc_ps & (PSL_IPL | PSL_IS)) ||
	    ((cntx->sc_ps & (PSL_U | PSL_PREVU)) != (PSL_U | PSL_PREVU)) ||
	    (cntx->sc_ps & PSL_CM)) {
d404 1
a404 1
	if (cntx->sc_onstack & 01)
d409 1
a409 1
    p->p_sigmask = cntx->sc_mask & ~sigcantmask;
d411 5
a415 5
	scf->fp = cntx->sc_fp;
	scf->ap = cntx->sc_ap;
	scf->pc = cntx->sc_pc;
	scf->sp = cntx->sc_sp;
	scf->psl = cntx->sc_ps;
@


1.60
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.59 2002/05/16 07:37:44 miod Exp $ */
d5 1
d161 1
d979 24
@


1.59
log
@Fix a long standing problem on vax: on "arithmetic fault" exceptions,
we schedule a SIGFPE signal delivery to the faulting process.

However, arithmetic faults come in two flavors: "traps" that are "regular"
exceptions, and "faults" that are restartable exceptions.
In the "fault" case, the frame pc points to the faulting instruction, instead
of the next instruction, in case we could save the world by tweaking memory
and make the instruction not fault again when restarted.

In practice, this led to processes blocked in a SIGFPE loop madness.

To avoid this, add a skip_opcode() routine to compute the address of the
next opcode, effectively skipping the offending instruction ; this routine
is a very stripped-down db_disasm().

While there, enhance the ddb disassembler to correctly recognize and
disassemble two-byte opcodes.

ok hugh@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.58 2002/04/05 18:14:53 deraadt Exp $ */
a441 1
	extern	char sigcode[], esigcode[];
d492 1
a492 1
	syscf->pc = (unsigned) (((char *) PS_STRINGS) - (esigcode - sigcode));
@


1.58
log
@mark that there is no siginfo code here.  Damn it, geez
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.57 2002/03/23 13:28:34 espie Exp $ */
d5 2
a6 1
 * Copyright (c) 1994, 1998 Ludd, University of Lule}, Sweden.
d14 3
d125 1
d846 133
@


1.57
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.56 2002/03/14 20:31:31 mickey Exp $ */
d421 3
@


1.56
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.55 2002/03/14 01:26:48 millert Exp $ */
d791 3
@


1.55
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.54 2002/03/14 00:42:24 miod Exp $ */
a176 1
	extern char	version[];
@


1.54
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.53 2002/02/17 22:59:53 maja Exp $ */
d124 1
a124 1
caddr_t allocsys __P((caddr_t));
@


1.53
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.52 2002/01/23 17:51:52 art Exp $ */
d646 2
d704 2
@


1.52
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.51 2002/01/23 17:35:56 art Exp $ */
d140 1
d813 1
a813 1
		    BUFCACHEPERCENT / 100;
@


1.51
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.50 2002/01/18 02:10:00 miod Exp $ */
a275 3
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr, 
		VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
	
@


1.50
log
@Replace resource maps with extents.
This one was tricky but the light came at 3am.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.49 2001/12/18 11:17:26 hugh Exp $ */
a165 1
struct vm_map *mb_map = NULL;
@


1.49
log
@Delay Debugger(). Noticed by NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.48 2001/12/08 02:24:07 art Exp $ */
d52 2
a53 1
#include <sys/map.h>
d155 4
d160 4
a163 1
static	struct map iomap[IOMAPSZ];
d356 7
a362 2
	 */
	rminit(iomap, IOSPSZ, (long)1, "iomap", IOMAPSZ);
a724 1
	extern vaddr_t iospace;
d726 1
a726 1
	int pageno;
d738 3
a740 2
		pageno = rmalloc(iomap, size);
		if (pageno == 0) {
a744 1
		addr = iospace + (pageno * VAX_NBPG);
a761 2
	extern vaddr_t iospace;
	int pageno = (addr - iospace) / VAX_NBPG;
d770 2
a771 1
		rmfree(iomap, size, pageno);
@


1.49.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.52 2002/01/23 17:51:52 art Exp $ */
d52 1
a52 2
#include <sys/extent.h>
#include <sys/malloc.h>
a153 4
/*
 * XXX some storage space must be allocated statically because of
 * early console init
 */
d155 1
a155 4
char extiospace[EXTENT_FIXED_STORAGE_SIZE(IOMAPSZ)];

struct extent *extio;
extern vaddr_t iospace;
d158 1
d269 3
d348 2
a349 7
	 *
	 * XXX console code uses the first page at iospace, so do not make
	 * the extent start at iospace.
	 */
	extio = extent_create("extio",
	    (u_long)iospace + VAX_NBPG, (u_long)iospace + IOSPSZ * VAX_NBPG,
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);
d712 1
d714 1
a714 1
	int error;
d726 2
a727 3
		error = extent_alloc(extio, size * VAX_NBPG, VAX_NBPG, 0,
		    EX_NOBOUNDARY, EX_NOWAIT | EX_MALLOCOK, (u_long *)&addr);
		if (error != 0) {
d732 1
d750 2
d760 1
a760 2
		extent_free(extio, (u_long)addr & ~VAX_PGOFSET,
		    size * VAX_NBPG, EX_NOWAIT);
@


1.49.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.49.2.1 2002/01/31 22:55:27 niklas Exp $ */
d5 1
a5 2
 * Copyright (c) 2002, Miodrag Vallat.
 * Copyright (c) 1994, 1996, 1998 Ludd, University of Lule}, Sweden.
a12 3
 * This code is derived from software contributed to Ludd by
 * Bertram Barth.
 *
a120 1
#include <vax/vax/db_disasm.h>
d124 1
a124 1
caddr_t allocsys(caddr_t);
a139 1
int bufcachepercent = BUFCACHEPERCENT;
d176 1
a420 3
/*
 * XXX no siginfo implementation!!!!
 */
a644 2
#ifdef PTRACE

a701 2
#endif	/* PTRACE */

a786 3
    shminfo.shmmax = shmmaxpgs;
    shminfo.shmall = shmmaxpgs;
    shminfo.shmseg = shmseg;
d812 1
a812 1
		    bufcachepercent / 100;
a830 133
/*
 * The following is a very stripped-down db_disasm.c, with only the logic
 * to skip instructions.
 */

long skip_operand(long ib, int size);

static __inline__ u_int8_t
get_byte(ib)
	long    ib;
{
	return *((u_int8_t *)ib);
}

long
skip_opcode(ib)
	long    ib;
{
	u_int opc;
	int size;
	char *argp;	/* pointer into argument-list */

	opc = get_byte(ib++);
	if (opc >= 0xfd) {
		/* two byte op-code */
		opc = opc << 8;
		opc += get_byte(ib++);
		argp = vax_inst2[INDEX_OPCODE(opc)].argdesc;
	} else
		argp = vax_inst[opc].argdesc;

	if (argp == NULL)
		return ib;

	while (*argp) {
		switch (*argp) {

		case 'b':	/* branch displacement */
			switch (*(++argp)) {
			case 'b':
				ib++;
				break;
			case 'w':
				ib += 2;
				break;
			case 'l':
				ib += 4;
				break;
			}
			break;

		case 'a':	/* absolute adressing mode */
			/* FALLTHROUGH */
		default:
			switch (*(++argp)) {
			case 'b':	/* Byte */
				size = 1;
				break;
			case 'w':	/* Word */
				size = 2;
				break;
			case 'l':	/* Long-Word */
			case 'f':	/* F_Floating */
				size = 4;
				break;
			case 'q':	/* Quad-Word */
			case 'd':	/* D_Floating */
			case 'g':	/* G_Floating */
				size = 8;
				break;
			case 'o':	/* Octa-Word */
			case 'h':	/* H_Floating */
				size = 16;
				break;
			default:
				size = 0;
			}
			ib = skip_operand(ib, size);
		}

		if (!*argp || !*++argp)
			break;
		if (*argp++ != ',')
			break;
	}

	return ib;
}

long
skip_operand(ib, size)
	long    ib;
	int	size;
{
	int c = get_byte(ib++);

	switch (c >> 4) { /* mode */
	case 4:		/* indexed */
		ib = skip_operand(ib, 0);
		break;

	case 9:		/* autoincrement deferred */
		if (c == 0x9f) {	/* pc: immediate deferred */
			/*
			 * addresses are always longwords!
			 */
			ib += 4;
		}
		break;
	case 8:		/* autoincrement */
		if (c == 0x8f) {	/* pc: immediate ==> special syntax */
			ib += size;
		}
		break;

	case 11:	/* byte displacement deferred/ relative deferred  */
	case 10:	/* byte displacement / relative mode */
		ib++;
		break;

	case 13:		/* word displacement deferred */
	case 12:		/* word displacement */
		ib += 2;
		break;

	case 15:		/* long displacement referred */
	case 14:		/* long displacement */
		ib += 4;
		break;
	}

	return ib;
}
@


1.49.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.49.2.2 2002/06/11 03:39:19 art Exp $ */
a4 1
 * Copyright (c) 2002, Hugh Graham.
a159 1
struct cpmbx	*cpmbx;
d442 1
d493 1
a493 1
	syscf->pc = p->p_sigcode;
a977 24
}

void
generic_halt()
{
	if (cpmbx->user_halt != UHALT_DEFAULT) {
		if (cpmbx->mbox_halt != 0)
			cpmbx->mbox_halt = 0;	/* let console override */
	} else if (cpmbx->mbox_halt != MHALT_HALT)
		cpmbx->mbox_halt = MHALT_HALT;	/* the os decides */

	asm("halt");
}

void
generic_reboot(int arg)
{
	if (cpmbx->user_halt != UHALT_DEFAULT) {
		if (cpmbx->mbox_halt != 0)
			cpmbx->mbox_halt = 0;
	} else if (cpmbx->mbox_halt != MHALT_REBOOT)
		cpmbx->mbox_halt = MHALT_REBOOT;

	asm("halt");
@


1.49.2.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d84 6
d148 1
d157 1
a187 1
	extern char	cpu_model[];
a389 1
	struct sigcontext ksc;
d394 2
a395 3
	if (copyin((caddr_t)cntx, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);

d397 3
a399 3
	if ((ksc.sc_ps & (PSL_IPL | PSL_IS)) ||
	    ((ksc.sc_ps & (PSL_U | PSL_PREVU)) != (PSL_U | PSL_PREVU)) ||
	    (ksc.sc_ps & PSL_CM)) {
d402 1
a402 1
	if (ksc.sc_onstack & 01)
d407 1
a407 1
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;
d409 5
a413 5
	scf->fp = ksc.sc_fp;
	scf->ap = ksc.sc_ap;
	scf->pc = ksc.sc_pc;
	scf->sp = ksc.sc_sp;
	scf->psl = ksc.sc_ps;
d417 9
a425 9
struct sigframe {
	int		 sf_signum;
	siginfo_t 	*sf_sip;
	struct sigcontext *sf_scp;
	register_t 	 sf_r0, sf_r1, sf_r2, sf_r3, sf_r4, sf_r5;
	register_t 	 sf_pc;
	register_t 	 sf_arg;
	siginfo_t 	 sf_si;
	struct sigcontext sf_sc;
d428 3
d436 1
a436 1
	int 		type;
d442 3
a444 2
	struct	sigframe *sigf, gsigf;
	unsigned int	cursp;
d447 3
d451 1
d461 3
a463 1
	sigf = (struct sigframe *) (cursp - sizeof(struct sigframe));
d466 1
a466 1
	 * Place sp at the beginning of sigf; this ensures that possible
d468 1
a468 1
	 * sigframe/struct sigcontext pair with their own.
d470 1
a470 1
	cursp = (unsigned) sigf;
d472 13
a484 18
	bzero(&gsigf, sizeof gsigf);
	gsigf.sf_arg = (register_t)&sigf->sf_sc;
	gsigf.sf_pc = (register_t)catcher;
	gsigf.sf_scp = &sigf->sf_sc;
	gsigf.sf_signum = sig;

	if (psp->ps_siginfo & sigmask(sig)) {
		gsigf.sf_sip = &sigf->sf_si;
		initsiginfo(&gsigf.sf_si, sig, code, type, val);
	}

	gsigf.sf_sc.sc_pc = syscf->pc;
	gsigf.sf_sc.sc_ps = syscf->psl;
	gsigf.sf_sc.sc_ap = syscf->ap;
	gsigf.sf_sc.sc_fp = syscf->fp; 
	gsigf.sf_sc.sc_sp = syscf->sp; 
	gsigf.sf_sc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	gsigf.sf_sc.sc_mask = mask;
d487 1
a487 1
	native_sigset_to_sigset13(mask, &gsigf.sf_sc.__sc_mask13);
d490 2
a491 1
	if (copyout(&gsigf, sigf, sizeof(gsigf)))
d496 1
a496 1
	syscf->ap = (unsigned) sigf + offsetof(struct sigframe, sf_pc);
d799 13
@


1.48
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.47 2001/11/28 16:13:29 art Exp $ */
d280 4
a358 4
#endif
#ifdef donotworkbyunknownreason
	if (boothowto & RB_KDB)
		Debugger();
@


1.47
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.46 2001/11/28 13:47:39 art Exp $ */
d253 1
@


1.46
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.45 2001/11/24 17:53:41 miod Exp $ */
d157 3
a159 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.45
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.44 2001/11/09 15:25:56 art Exp $ */
d216 1
a216 1
			UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.44
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.43 2001/11/07 01:18:00 art Exp $ */
d491 6
d507 9
d520 1
a520 2
		for (;;)
			;
a556 7
		/* If rebooting and a dump is requested, do it. */
		if (showto & RB_DUMP)
			dumpsys();

		/* Run any shutdown hooks. */
		doshutdownhooks();

d569 2
a570 1
	panic("Halt sket sej");
@


1.43
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.42 2001/11/06 19:53:17 miod Exp $ */
a810 6
    /* Allocate 1/2 as many swap buffer headers as file i/o buffers.  */
    if (nswbuf == 0) {
        nswbuf = (nbuf / 2) & ~1;   /* force even */
        if (nswbuf > 256)
            nswbuf = 256;       /* sanity */
    }
@


1.42
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.41 2001/10/04 00:21:12 miod Exp $ */
d214 1
a214 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.41
log
@UKC on vax.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.40 2001/09/19 20:50:57 mickey Exp $ */
a68 1
#include <vm/vm.h>
a72 1
#include <vm/vm.h>
@


1.40
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.39 2001/09/12 00:23:34 art Exp $ */
d281 11
@


1.39
log
@mbutl no more
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.38 2001/08/23 14:01:03 art Exp $ */
d75 1
a75 1
#include <vm/vm_kern.h>
@


1.38
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.37 2001/08/23 12:02:05 art Exp $ */
d270 1
a270 1
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr, 
@


1.37
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.36 2001/07/25 13:25:33 art Exp $ */
a272 2
	timeout_init();

@


1.36
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.35 2001/07/05 10:12:20 art Exp $ */
a762 1
    VALLOC(timeouts, struct timeout, ntimeout);
@


1.35
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.34 2001/06/15 22:45:33 miod Exp $ */
d249 2
a250 2
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE, TRUE, 
			    VM_PROT_READ|VM_PROT_WRITE);
@


1.34
log
@Compile kernel with -Wall, and fix a few issues for this to work.
ok hugh@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.33 2001/06/11 01:33:48 miod Exp $ */
a762 3
#ifdef REAL_CLISTS
    VALLOC(cfree, struct cblock, nclist);
#endif
@


1.33
log
@Call doshutdownhooks() during shutdown.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.32 2001/05/17 18:41:50 provos Exp $ */
d343 1
a343 6
	{
		extern int end; /* Contains pointer to symsize also */
		extern int *esym;

		ddb_init();
	}
@


1.32
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.31 2001/05/05 22:34:29 art Exp $ */
d541 1
d544 4
@


1.31
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.30 2001/05/05 20:56:56 art Exp $ */
a269 3
    mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
        M_MBUF, M_NOWAIT);
    bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.30
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.29 2001/02/11 12:59:40 bjc Exp $ */
a285 1
	configure();
@


1.29
log
@Previously, when sendsig() set up the current process's context to run
sigcode to call a handler, SP was set in the middle of the struct
trapframe/struct sigcontext pair placed on the stack.  This was adequate
when only one signal is being delivered at a time, but when two signals are
delivered in one syscall, the second invocation of sendsig() overwrote
some of the first sendsig() invocation's stack data.

The result was that under certain circumstances, (e.g., sending signals to
backgrounded processes from ksh) the argument passed to signal handlers
when the second signal (the one corresponding to the first sendsig()
invocation) was delivered was bogus data from the stack.  Therefore,
programs that depended on the "sigraised" argument to be accurate
blew up.

This fix ensures that sendsig() always leaves a process's SP out of the way
of structures that will be used.  AP is not moved, though, so sigreturn
can find the args correctly.  Also, sigcode is changed to compensate for the
SP change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.28 2001/01/28 02:24:24 hugh Exp $ */
d242 1
a242 1
		curbufsize = CLBYTES * (i < residual ? base + 1 : base);
d270 1
a270 1
    mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d272 1
a272 1
    bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d279 1
a279 1
	printf("using %d buffers containing %d bytes of memory\n", nbuf, bufpages * CLBYTES);
d309 1
a309 1
	 * Don't dump on the first CLBYTES (why CLBYTES?) in case the dump
d312 2
a313 2
	if (dumplo < btodb(CLBYTES))
		dumplo = btodb(CLBYTES);
d794 1
a794 1
	        bufpages = physmem / (10 * CLSIZE);
d797 1
a797 1
		    BUFCACHEPERCENT / (100 * CLSIZE);
d809 2
a810 2
    if (bufpages > nbuf * MAXBSIZE / CLBYTES)
        bufpages = nbuf * MAXBSIZE / CLBYTES;
@


1.28
log
@Print contents of the SID and extension as well as findcpu's guess.
Doesn't take up much space, and provides unequivocal information.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.27 2000/10/27 00:16:22 mickey Exp $ */
d448 6
a453 2
	 /* Place for pointer to arg list in sigreturn */
	cursp = (unsigned)sigctx - 8;
d479 1
a479 1
	syscf->ap = cursp;
d693 1
a693 1
 * be use by console device drivers (before the map system is inited).
@


1.27
log
@more precise BUFCACHEPERCENT calculations.
from gluk@@ptci.ru; deraadt@@ and niklas@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.26 2000/10/17 19:57:55 hugh Exp $ */
d186 1
a186 1
	printf("%s%s\n", version, cpu_model);
@


1.26
log
@remove extra newline from printf
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.25 2000/10/10 18:25:00 bjc Exp $ */
d792 2
a793 2
	        bufpages = (btoc(2 * 1024 * 1024) + physmem) /
	            ((100 / BUFCACHEPERCENT) * CLSIZE);
@


1.25
log
@bring in stuff from recent netbsd -- correct number of buffers now being
allocated
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.24 2000/06/08 22:25:23 niklas Exp $ */
d186 1
a186 1
	printf("%s\n%s\n", version, cpu_model);
@


1.24
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 2
a2 2
/* $OpenBSD: machdep.c,v 1.24 2000/06/08 21:12:08 niklas Exp $ */
/* $NetBSD: machdep.c,v 1.96 2000/03/19 14:56:53 ragge Exp $	 */
d127 15
d161 1
d218 1
a218 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
d229 1
a229 1
	for (i = 0 ; i < nbuf ; i++) {
d263 7
d279 1
a279 1
	printf("using %d buffers containing %d of memory\n", nbuf, bufpages * CLBYTES);
d430 3
d756 2
a761 1
#define valloc(name, type, num) v = (caddr_t)(((name) = (type *)v) + (num))
d764 1
a764 1
    valloc(cfree, struct cblock, nclist);
d766 1
a766 1
    valloc(timeouts, struct timeout, ntimeout);
d768 1
a768 1
    valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
d771 2
a772 2
    valloc(sema, struct semid_ds, seminfo.semmni);
    valloc(sem, struct sem, seminfo.semmns);
d775 1
a775 1
    valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
d778 4
a781 4
    valloc(msgpool, char, msginfo.msgmax);
    valloc(msgmaps, struct msgmap, msginfo.msgseg);
    valloc(msghdrs, struct msg, msginfo.msgtql);
    valloc(msqids, struct msqid_ds, msginfo.msgmni);
d784 14
a797 17
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
    /*
     * Determine how many buffers to allocate (enough to
     * hold 5% of total physical memory, but at least 16).
     * Allocate 1/2 as many swap buffer headers as file i/o buffers.
     */
    if (bufpages == 0)
        bufpages = (physmem / ((100/BUFCACHEPERCENT) / CLSIZE));
    if (nbuf == 0) {
        nbuf = bufpages;
        if (nbuf < 16)
            nbuf = 16;
    }
    if (nbuf > 200)
        nbuf = 200; /* or we run out of PMEGS */
d800 2
a801 2
        (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
        nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
d814 1
a814 1
    valloc(buf, struct buf, nbuf);
@


1.23
log
@prevent messing with critical psl flags -- from netbsd
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.22 2000/04/27 01:10:13 bjc Exp $ */
d54 1
@


1.22
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.21 2000/03/23 09:59:56 art Exp $ */
d605 2
a606 1
	tf->psl = regs->psl;
@


1.21
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 2
a2 2
/* $OpenBSD: machdep.c,v 1.20 1999/12/08 06:50:17 itojun Exp $ */
/* $NetBSD: machdep.c,v 1.45 1997/07/26 10:12:49 ragge Exp $	 */
d5 1
a5 1
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
d49 1
a55 1
#include <sys/signal.h>
a56 1
#include <sys/reboot.h>
d68 8
a85 2
#include <vm/vm_kern.h>

a90 1
#include <netinet/if_ether.h>
d93 3
d99 2
a100 2
#include "ppp.h"	/* For NERISR_PPP */
#include "bridge.h"	/* For NERISR_BRIDGE */
d122 1
a122 4
void	netintr __P((void));
void	machinecheck __P((caddr_t));
void	cmrerr __P((void));
int	bufcalc __P((void));
d124 1
a124 2
extern vm_offset_t avail_end;
extern vm_offset_t virtual_avail, virtual_end;
d126 2
a131 3
int		nmcr, nmba, numuba, cold = 1;
caddr_t		mcraddr[MAXNMCR];
int		astpending;
a135 2
int		msgbufmapped = 0;
struct msgbuf  *msgbufp;
a136 2
struct cfdriver nexuscd;
int		todrstopped = 0, glurg;
d138 1
d140 2
a141 1
caddr_t allocsys __P((caddr_t));
d143 2
a144 2
#define valloclim(name, type, num, lim) \
    (name) = (type *)v; v = (caddr_t)((lim) = ((name) + (num)))
d146 2
a147 10
#ifdef	BUFPAGES
int		bufpages = BUFPAGES;
#else
int		bufpages = 0;
#endif
int		nswbuf = 0;
#ifdef	NBUF
int		nbuf = NBUF;
#else
int		nbuf = 0;
d158 1
d163 1
a163 1
	msgbufmapped = 1;
a164 5
#if VAX750 || VAX650
	if (vax_cputype == VAX_750 || vax_cputype == VAX_650)
		if (!mfpr(PR_TODR))
			mtpr(todrstopped = 1, PR_TODR);
#endif
d167 1
d169 5
a173 2
	printf("%s\n", version);
	printf("realmem = %d\n", avail_end);
d185 3
a187 2
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
d189 1
a189 1
	if (allocsys(v) - v != sz)
a190 1

d195 9
a203 3
	size = MAXBSIZE * nbuf;
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
	    &maxaddr, size, TRUE);
a204 3
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
	    &minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
d211 5
a215 3
	for (i = 0; i < nbuf; i++) {
		vm_size_t	curbufsize;
		vm_offset_t	curbuf;
d224 1
a224 1
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
d226 11
a236 3
		vm_map_pageable(buffer_map, curbuf, curbuf + curbufsize,
		    FALSE);
		vm_map_simplify(buffer_map, curbuf);
d243 2
a244 18
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
	    TRUE);

	/*
	 * Finally, allocate mbuf pool.	 Since mclrefcnt is an off-size we
	 * use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS + CLBYTES / MCLBYTES, M_MBUF,
	    M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS + CLBYTES / MCLBYTES);
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, TRUE);
d246 6
d254 2
a255 3
	printf("avail mem = %d\n", (int)ptoa(cnt.v_free_count));
	printf("Using %d buffers containing %d bytes of memory.\n", nbuf,
	    bufpages * CLBYTES);
d260 1
a261 11

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
a264 87
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

int
bufcalc()
{
	/*
	 * Determine how many buffers to allocate. By default we allocate
	 * the BSD standard of use 10% of memory for the first 2 Meg,
	 * 5% of remaining.  But this might cause systems with large
	 * core (32MB) to fail to boot due to small KVM space.  Reduce
	 * BUFCACHEPERCENT in this case.  Insure a minimum of 16 buffers.
	 */
	if (bufpages == 0) {
		/* We always have more than 2MB of memory. */
		bufpages = btoc(avail_end + 2 * 1024 * 1024) /
		    ((100 / BUFCACHEPERCENT) * CLSIZE);
	}
	if (nbuf == 0)
		nbuf = bufpages;

	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* We really need some buffers.  */
	if (nbuf < 16)
		nbuf = 16;

	/* More buffer pages than fits into the buffer is senseless. */
	if (bufpages > nbuf * MAXBSIZE / CLBYTES) {
		bufpages = nbuf * MAXBSIZE / CLBYTES;
		return (bufpages * CLSIZE);
	}
	return (nbuf * MAXBSIZE / NBPG);
}

/*
 * Allocate space for system data structures.  We are given a starting
 * virtual address and we return a final virtual address; along the way we
 * set each data structure pointer.
 * 
 * We call allocsys() with 0 to find out how much space we want, allocate that
 * much and fill it with zeroes, and then call allocsys() again with the
 * correct base virtual address.
 */
caddr_t
allocsys(v)
	register caddr_t v;
{
#define valloc(name, type, num) v = (caddr_t)(((name) = (type *)v) + (num))

#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
	valloc(timeouts, struct timeout, ntimeout);
#ifdef SYSVSHM
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);

	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

	/* Allocate 1/2 as many swap buffer headers as file i/o buffers.  */
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) & ~1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
	valloc(swbuf, struct buf, nswbuf);
	valloc(buf, struct buf, nbuf);
	return (v);
}

d269 1
a269 1
dumpconf()
a271 1
	extern int	dumpdev;
a291 6
void
cpu_initclocks()
{
	(*dep_call->cpu_clock)();
}

d313 8
d323 10
a332 2
/*	db_machine_init(); */
	ddb_init();
d346 1
a346 1
	struct sys_sigreturn_args /* {
d348 1
a348 1
	} */ *uap = v;
d355 2
d367 2
a368 1
	p->p_sigmask = cntx->sc_mask & ~sigcantmask;
d394 2
a395 2
	int		type;
	union sigval	val;
d397 8
a404 10
	struct proc *p = curproc;
	struct sigacts *psp = p->p_sigacts;
	struct trapframe *syscf;
	struct sigcontext *sigctx;
	struct trampframe *trampf;
	unsigned cursp;
	int oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	extern char sigcode[], esigcode[];
	int fsize, rndfsize, kscsize;
	siginfo_t *sip, ksi;
a405 7
	/*
	 * Allocate and validate space for the signal handler context. Note
	 * that if the stack is in P0 space, the call to grow() is a nop, and
	 * the useracc() check will fail if the process has not already
	 * allocated the space with a `brk'. We shall allocate space on the
	 * stack for both struct sigcontext and struct calls...
	 */
a406 7
	fsize = sizeof *sigctx;
	rndfsize = ((fsize + 7) / 8) * 8;		/* XXX */
	kscsize = rndfsize;
	if (psp->ps_siginfo & sigmask(sig)) {
		fsize += sizeof ksi;
		rndfsize = ((fsize + 7) / 8) * 8;	/* XXX */
	}
d408 7
a414 10
	/* First check what stack to work on */
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		cursp = (int)(psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size - 
		    rndfsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		cursp = syscf->sp - rndfsize;
	if (cursp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void)grow(p, cursp);
d417 2
a418 2
	sigctx = (struct sigcontext *)(cursp - sizeof(struct sigcontext));
	trampf = (struct trampframe *)((unsigned)sigctx -
d424 21
a444 28
	if (useracc((caddr_t)cursp, fsize, B_WRITE) == 0) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}

	/* Set up pointers for sigreturn args */
	trampf->arg = (int) sigctx;
	trampf->pc = (unsigned) catcher;
	trampf->scp = (int) sigctx;
	trampf->code = code;
	trampf->sig = sig;

	sigctx->sc_pc = syscf->pc;
	sigctx->sc_ps = syscf->psl;
	sigctx->sc_ap = syscf->ap;
	sigctx->sc_fp = syscf->fp;
	sigctx->sc_sp = syscf->sp;
	sigctx->sc_onstack = oonstack;
	sigctx->sc_mask = mask;
d451 2
a452 5
	if (psp->ps_siginfo & sigmask(sig)) {
		initsiginfo(&ksi, sig, code, type, val);
		sip = (void *)cursp + kscsize;
		copyout((caddr_t)&ksi, (caddr_t)sip, fsize - kscsize);
	}
d459 2
a460 3
boot(howto /* , bootstr */)
	register howto;
/*	char *bootstr; */
a461 1
	showto = howto;
d469 1
a469 10
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
d474 1
a474 1
			(*dep_call->cpu_halt)();
d487 2
a488 3
				showto |= (*b == 'a' ? RB_ASKBOOT :
				    (*b == 'd' ? RB_DEBUG :
				    (*b == 's' ? RB_SINGLE : 0)));
d504 8
a511 7
		__asm volatile("movl	sp, (0x80000200);"
		    "movl	0x80000200, sp;"
		    "mfpr	$0x10, -(sp)	# PR_PCBB;"
		    "mfpr	$0x11, -(sp)	# PR_SCBB;"
		    "mfpr	$0xc, -(sp)	# PR_SBR;"
		    "mfpr	$0xd, -(sp)	# PR_SLR;"
		    "mtpr	$0, $0x38	# PR_MAPEN;");
d519 3
a521 18
		switch (vax_cputype) {
			int	state;

#if VAX750 || VAX780
		case VAX_780:
		case VAX_750:
			mtpr(GC_BOOT, PR_TXDB); /* boot command */
			break;
#endif
#if VAX8600
		case VAX_8600:
			state = mfpr(PR_TXCS);
			gencnputc(0, GC_LT | GC_WRT);
			mtpr(0x2, PR_TXDB); /* XXX */
			gencnputc(0, state | GC_WRT);
			break;
#endif
		}
d523 1
d525 4
a528 71

	/* How to boot */
	__asm volatile ("movl %0, r5" : : "g" (showto));
	__asm volatile ("movl %0, r11" : : "r" (showto));	/* ??? */
	__asm volatile ("halt");
	panic("Halt failed");
}

void
netintr()
{
#ifdef INET
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
#endif
#ifdef INET6
	if (netisr & (1 << NETISR_IPV6)) {
		netisr &= ~(1 << NETISR_IPV6);
		ip6intr();
	}
#endif
#ifdef NETATALK
	if (netisr & (1 << NETISR_ATALK)) {
		netisr &= ~(1 << NETISR_ATALK);
		atintr();
	}
#endif
#ifdef NS
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
#endif
#ifdef ISO
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
#endif
#ifdef CCITT
	if (netisr & (1 << NETISR_CCITT)) {
		netisr &= ~(1 << NETISR_CCITT);
		ccittintr();
	}
#endif
#if NPPP > 0
	if (netisr & (1 << NETISR_PPP)) {
		pppintr();
	}
#endif
#if NBRIDGE > 0
	if (netisr & (1 << NETISR_BRIDGE)) {
		bridgeintr();
	}
#endif
}

void
machinecheck(frame)
	caddr_t frame;
{
	if ((*dep_call->cpu_mchk)(frame) == 0)
		return;
	(*dep_call->cpu_memerr)();
	panic("machine check");
d534 1
a534 1
	extern int	dumpdev;
d544 4
a547 2
		dumpconf();
	if (dumplo < 0)
d549 3
a551 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, (int)dumplo);
d553 1
a553 1
	switch ((*bdevsw[major(dumpdev)].d_dump)(dumpdev, 0, 0, 0)) {
a577 26
fuswintr(addr)
	caddr_t addr;
{
	panic("fuswintr: need to be implemented");
	return (0);
}

int
suibyte(base, byte)
	void *base;
	short byte;
{
	panic("suibyte: need to be implemented");
	return (0);
}

int
suswintr(addr, cnt)
	caddr_t	addr;
	u_int cnt;
{
	panic("suswintr: need to be implemented");
	return (0);
}

int
d590 1
a590 1
	return (0);
d606 1
a606 1
	return (0);
d620 1
a620 1
	ptr = (char *)p->p_addr->u_pcb.framep;
d623 1
a623 1
	tf->pc = (unsigned)addr;
d649 52
d702 29
a730 1
cmrerr()
d732 58
a789 1
	(*dep_call->cpu_memerr)();
d791 1
@


1.20
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.19 1999/05/24 23:09:09 jason Exp $ */
d63 1
a63 1
#include <sys/callout.h>
d257 1
a257 7
	/*
	 * Initialize callouts
	 */
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i - 1].c_next = &callout[i];
	callout[i - 1].c_next = NULL;
d339 1
a339 1
	valloc(callout, struct callout, ncallout);
@


1.20.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d63 1
a63 1
#include <sys/timeout.h>
d257 7
a263 1
	timeout_init();
d345 1
a345 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.20.2.2
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/* $OpenBSD: machdep.c,v 1.29 2001/02/11 12:59:40 bjc Exp $ */
/* $NetBSD: machdep.c,v 1.108 2000/09/13 15:00:23 thorpej Exp $	 */
d5 1
a5 1
 * Copyright (c) 1994, 1998 Ludd, University of Lule}, Sweden.
a48 1
#include <sys/signal.h>
a52 1
#include <sys/signalvar.h>
d55 1
d57 1
a68 8
#include <vm/vm.h>
#include <sys/sysctl.h>

#include <dev/cons.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>

d79 2
d86 1
a88 3
#ifdef NETATALK
#include <netatalk/at_extern.h>
#endif
d92 2
a93 2
#include "ppp.h"	/* For NPPP */
#include "bridge.h"	/* For NBRIDGE */
d115 4
a118 7
#include "smg.h"

caddr_t allocsys __P((caddr_t));

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
d120 2
a121 10
#ifdef	NBUF
int nbuf = NBUF;
#else
int nbuf = 0;
#endif
#ifdef	BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
a122 2
extern int *chrtoblktbl;
extern int virtual_avail, virtual_end;
d127 3
d134 2
d137 2
a139 1
int		cold = 1; /* coldstart */
d141 1
a141 2
#define	IOMAPSZ	100
static	struct map iomap[IOMAPSZ];
d143 2
a144 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
d146 10
a155 2
#ifdef DEBUG
int iospace_inited = 0;
a165 1
	extern unsigned int avail_end;
d170 1
a170 1
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
d172 5
a178 1
	 * Also call CPU init on systems that need that.
d180 2
a181 5
	printf("%s%s [%08X %08X]\n", version, cpu_model, vax_cpudata, vax_siedata);
        if (dep_call->cpu_conf)
                (*dep_call->cpu_conf)();

	printf("total memory = %d\n", avail_end);
d193 2
a194 3

	sz = (int) allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
d196 1
a196 1
	if (((unsigned long)allocsys(v) - (unsigned long)v) != sz)
d198 1
d203 3
a205 9
	size = MAXBSIZE * nbuf;		/* # bytes for buffers */

	/* allocate VM for buffers... area is not managed by VM system */
	if (uvm_map(kernel_map, (vm_offset_t *) &buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
			UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("cpu_startup: cannot allocate VM for buffers");

d207 3
a215 1
	/* now allocate RAM for buffers */
d217 2
a218 3
		vm_offset_t curbuf;
		vm_size_t curbufsize;
		struct vm_page *pg;
d227 1
a227 1
		curbuf = (vm_offset_t) buffers + i * MAXBSIZE;
d229 3
a231 11
		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: "
				    "not enough RAM for buffer cache");
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE, TRUE, 
			    VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
d238 12
a249 2
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d252 1
a252 2
	 * Allocate a submap for physio.  This map effectively limits the
	 * number of processes doing physio at any one time.
d254 3
a256 9
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);

    mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
        M_MBUF, M_NOWAIT);
    bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr, 
		VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
	
d259 3
a261 2
	printf("avail memory = %ld\n", ptoa(uvmexp.free));
	printf("using %d buffers containing %d bytes of memory\n", nbuf, bufpages * CLBYTES);
d266 1
d268 10
a277 1
	bufinit();
d281 87
d372 1
a372 1
cpu_dumpconf()
d375 1
d396 6
a422 8
	/*
	 * Init I/O memory resource map. Must be done before cninit()
	 * is called; we may want to use iospace in the console routines.
	 */
	rminit(iomap, IOSPSZ, (long)1, "iomap", IOMAPSZ);
#ifdef DEBUG
	iospace_inited = 1;
#endif
d425 2
a426 10
	{
		extern int end; /* Contains pointer to symsize also */
		extern int *esym;

		ddb_init();
	}
#ifdef DEBUG
	if (sizeof(struct user) > REDZONEADDR)
		panic("struct user inside red zone");
#endif
d440 1
a440 1
	struct sys_sigreturn_args { 
d442 1
a442 1
	} *uap = v;
a448 2
	if (uvm_useracc((caddr_t)cntx, sizeof (*cntx), B_READ) == 0)
		return EINVAL;
d459 1
a459 2
	/* Restore signal mask. */
    p->p_sigmask = cntx->sc_mask & ~sigcantmask;
d485 2
a486 2
	int 	type;
	union sigval 	val;
d488 18
a505 12
	struct	proc	*p = curproc;
	struct	sigacts *psp = p->p_sigacts;
	struct	trapframe *syscf;
	struct	sigcontext *sigctx, gsigctx;
	struct	trampframe *trampf, gtrampf;
	extern	char sigcode[], esigcode[];
	unsigned	cursp;
	int	onstack;

#if 0
printf("sendsig: signal %x  catcher %x\n", sig, catcher);
#endif
d507 7
d515 10
a524 7
	onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/* Allocate space for the signal handler context. */
	if (onstack)
		cursp = ((int)psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size);
	else
		cursp = syscf->sp;
d527 2
a528 2
	sigctx = (struct sigcontext *) (cursp - sizeof(struct sigcontext));
	trampf = (struct trampframe *) ((unsigned)sigctx -
d531 31
a561 28
	/*
	 * Place sp at the beginning of trampf; this ensures that possible
	 * further calls to sendsig won't overwrite this struct
	 * trampframe/struct sigcontext pair with their own.
	 */
	cursp = (unsigned) trampf;

	gtrampf.arg = (int) sigctx;
	gtrampf.pc = (unsigned) catcher;
	gtrampf.scp = (int) sigctx;
	gtrampf.code = code;
	gtrampf.sig = sig;

	gsigctx.sc_pc = syscf->pc;
	gsigctx.sc_ps = syscf->psl;
	gsigctx.sc_ap = syscf->ap;
	gsigctx.sc_fp = syscf->fp; 
	gsigctx.sc_sp = syscf->sp; 
	gsigctx.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	gsigctx.sc_mask = mask;

#if defined(COMPAT_13) || defined(COMPAT_ULTRIX)
	native_sigset_to_sigset13(mask, &gsigctx.__sc_mask13);
#endif

	if (copyout(&gtrampf, trampf, sizeof(gtrampf)) ||
	    copyout(&gsigctx, sigctx, sizeof(gsigctx)))
		sigexit(p, SIGILL);
d565 1
a565 1
	syscf->ap = (unsigned) sigctx-8;
d568 5
a572 2
	if (onstack)
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d579 3
a581 2
boot(howto)
	register int howto;
d583 1
d591 10
a600 1
		resettodr();
d605 1
a605 1
			(*dep_call->cpu_halt) ();
d618 3
a620 2
				showto |= (*b == 'a' ? RB_ASKBOOT : (*b == 'd' ?
				    RB_DEBUG : (*b == 's' ? RB_SINGLE : 0)));
d636 7
a642 8
		asm("	movl	sp, (0x80000200)
			movl	0x80000200, sp
			mfpr	$0x10, -(sp)	# PR_PCBB
			mfpr	$0x11, -(sp)	# PR_SCBB
			mfpr	$0xc, -(sp)	# PR_SBR
			mfpr	$0xd, -(sp)	# PR_SLR
			mtpr	$0, $0x38	# PR_MAPEN
		");
d650 18
a667 3
		/* cpus that don't handle reboots get the standard reboot. */
		while ((mfpr(PR_TXCS) & GC_RDY) == 0)
			;
a668 1
		mtpr(GC_CONS|GC_BTFL, PR_TXDB);
d670 71
a740 4
	asm("movl %0, r5":: "g" (showto)); /* How to boot */
	asm("movl %0, r11":: "r"(showto)); /* ??? */
	asm("halt");
	panic("Halt sket sej");
d746 1
a746 1
	extern int msgbufmapped;
d756 2
a757 4
		cpu_dumpconf();
	if (dumplo <= 0) {
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
		    minor(dumpdev));
d759 1
a759 3
	}
	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);
d761 1
a761 1
	switch ((*bdevsw[major(dumpdev)].d_dump) (dumpdev, 0, 0, 0)) {
d786 26
d824 1
a824 1
	return 0;
d839 2
a840 3
	tf->psl = (regs->psl|PSL_U|PSL_PREVU) &
		~(PSL_MBZ|PSL_IS|PSL_IPL1F|PSL_CM);
	return 0;
d854 1
a854 1
	ptr = (char *) p->p_addr->u_pcb.framep;
d857 1
a857 1
	tf->pc = (unsigned) addr;
a882 52
#undef PHYSMEMDEBUG
/*
 * Allocates a virtual range suitable for mapping in physical memory.
 * This differs from the bus_space routines in that it allocates on
 * physical page sizes instead of logical sizes. This implementation
 * uses resource maps when allocating space, which is allocated from 
 * the IOMAP submap. The implementation is similar to the uba resource
 * map handling. Size is given in pages.
 * If the page requested is bigger than a logical page, space is
 * allocated from the kernel map instead.
 *
 * It is known that the first page in the iospace area is unused; it may
 * be use by console device drivers (before the map system is inied).
 */
vaddr_t
vax_map_physmem(phys, size)
	paddr_t phys;
	int size;
{
	extern vaddr_t iospace;
	vaddr_t addr;
	int pageno;
	static int warned = 0;

#ifdef DEBUG
	if (!iospace_inited)
		panic("vax_map_physmem: called before rminit()?!?");
#endif
	if (size >= LTOHPN) {
		addr = uvm_km_valloc(kernel_map, size * VAX_NBPG);
		if (addr == 0)
			panic("vax_map_physmem: kernel map full");
	} else {
		pageno = rmalloc(iomap, size);
		if (pageno == 0) {
			if (warned++ == 0) /* Warn only once */
				printf("vax_map_physmem: iomap too small");
			return 0;
		}
		addr = iospace + (pageno * VAX_NBPG);
	}
	ioaccess(addr, phys, size);
#ifdef PHYSMEMDEBUG
	printf("vax_map_physmem: alloc'ed %d pages for paddr %lx, at %lx\n",
	    size, phys, addr);
#endif
	return addr | (phys & VAX_PGOFSET);
}

/*
 * Unmaps the previous mapped (addr, size) pair.
 */
d884 1
a884 31
vax_unmap_physmem(addr, size)
	vaddr_t addr;
	int size;
{
	extern vaddr_t iospace;
	int pageno = (addr - iospace) / VAX_NBPG;
#ifdef PHYSMEMDEBUG
	printf("vax_unmap_physmem: unmapping %d pages at addr %lx\n", 
	    size, addr);
#endif
	iounaccess(addr, size);
	if (size >= LTOHPN)
		uvm_km_free(kernel_map, addr, size * VAX_NBPG);
	else
		rmfree(iomap, size, pageno);
}

/*
 * Allocate space for system data structures.  We are given a starting
 * virtual address and we return a final virtual address; along the way we
 * set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want, allocate that
 * much and fill it with zeroes, and then call allocsys() again with the
 * correct base virtual address.
 */
#define VALLOC(name, type, num) v = (caddr_t)(((name) = (type *)v) + (num))

caddr_t
allocsys(v)
    register caddr_t v;
d886 1
a886 54

#ifdef REAL_CLISTS
    VALLOC(cfree, struct cblock, nclist);
#endif
    VALLOC(timeouts, struct timeout, ntimeout);
#ifdef SYSVSHM
    VALLOC(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
    VALLOC(sema, struct semid_ds, seminfo.semmni);
    VALLOC(sem, struct sem, seminfo.semmns);

    /* This is pretty disgusting! */
    VALLOC(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
    VALLOC(msgpool, char, msginfo.msgmax);
    VALLOC(msgmaps, struct msgmap, msginfo.msgseg);
    VALLOC(msghdrs, struct msg, msginfo.msgtql);
    VALLOC(msqids, struct msqid_ds, msginfo.msgmni);
#endif

	/*
	 * Determine how many buffers to allocate.  We make sure we allocate
	 * at least 16 buffers.  	 
	 */
	if (bufpages == 0) {
	    if (physmem < btoc(2 * 1024 * 1024))
	        bufpages = physmem / (10 * CLSIZE);
	    else
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    BUFCACHEPERCENT / (100 * CLSIZE);
	}
    if (nbuf == 0) 
        nbuf = bufpages < 16 ? 16 : bufpages;

    /* Restrict to at most 70% filled kvm */
    if (nbuf * MAXBSIZE >
        (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
        nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
            MAXBSIZE * 7 / 10;

    /* More buffer pages than fits into the buffers is senseless.  */
    if (bufpages > nbuf * MAXBSIZE / CLBYTES)
        bufpages = nbuf * MAXBSIZE / CLBYTES;

    /* Allocate 1/2 as many swap buffer headers as file i/o buffers.  */
    if (nswbuf == 0) {
        nswbuf = (nbuf / 2) & ~1;   /* force even */
        if (nswbuf > 256)
            nswbuf = 256;       /* sanity */
    }
    VALLOC(buf, struct buf, nbuf);
    return (v);
a887 1

@


1.20.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.20.2.2 2001/05/14 21:39:05 niklas Exp $ */
d242 1
a242 1
		curbufsize = PAGE_SIZE * (i < residual ? base + 1 : base);
d270 3
d279 1
a279 1
	printf("using %d buffers containing %d bytes of memory\n", nbuf, bufpages * PAGE_SIZE);
d286 1
d309 1
a309 1
	 * Don't dump on the first block in case the dump
d312 2
a313 2
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
d347 6
a352 1
	ddb_init();
a544 1
		/* If rebooting and a dump is requested, do it. */
a546 4

		/* Run any shutdown hooks. */
		doshutdownhooks();

d794 1
a794 1
	        bufpages = physmem / 10;
d797 1
a797 1
		    BUFCACHEPERCENT / 100;
d809 2
a810 2
    if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
        bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
@


1.20.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.20.2.3 2001/07/04 10:24:39 niklas Exp $ */
d75 1
a75 1
#include <uvm/uvm_extern.h>
d249 2
a250 2
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE,
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d270 1
a270 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr, 
d273 2
a282 11

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
d763 4
@


1.20.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d69 1
d74 1
d216 1
a216 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
d813 6
@


1.20.2.6
log
@Merge in trunk
@
text
@d52 1
a52 2
#include <sys/extent.h>
#include <sys/malloc.h>
a138 1
int bufcachepercent = BUFCACHEPERCENT;
a153 4
/*
 * XXX some storage space must be allocated statically because of
 * early console init
 */
d155 1
a155 4
char extiospace[EXTENT_FIXED_STORAGE_SIZE(IOMAPSZ)];

struct extent *extio;
extern vaddr_t iospace;
d157 3
a159 2
struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;
a252 1
	pmap_update(kernel_map->pmap);
d268 3
a278 4
#ifdef DDB
	if (boothowto & RB_KDB)
		Debugger();
#endif
d343 2
a344 7
	 *
	 * XXX console code uses the first page at iospace, so do not make
	 * the extent start at iospace.
	 */
	extio = extent_create("extio",
	    (u_long)iospace + VAX_NBPG, (u_long)iospace + IOSPSZ * VAX_NBPG,
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);
d355 4
d703 1
d705 1
a705 1
	int error;
d717 2
a718 3
		error = extent_alloc(extio, size * VAX_NBPG, VAX_NBPG, 0,
		    EX_NOBOUNDARY, EX_NOWAIT | EX_MALLOCOK, (u_long *)&addr);
		if (error != 0) {
d723 1
d741 2
d751 1
a751 2
		extent_free(extio, (u_long)addr & ~VAX_PGOFSET,
		    size * VAX_NBPG, EX_NOWAIT);
d796 1
a796 1
		    bufcachepercent / 100;
@


1.20.2.7
log
@Merge in -current from about a week ago
@
text
@d124 1
a124 1
caddr_t allocsys(caddr_t);
d177 1
a637 2
#ifdef PTRACE

a693 2

#endif	/* PTRACE */
@


1.20.2.8
log
@manually merge stuff cvs missed long ago
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.57 2002/03/23 13:28:34 espie Exp $ */
d223 1
a223 1
			UVM_ADV_NORMAL, 0)))
a500 6
	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}

a510 9

	/* If rebooting and a dump is requested, do it. */
	if (howto & RB_DUMP)
		dumpsys();

	/* Run any shutdown hooks. */
	doshutdownhooks();

haltsys:
d515 2
a516 1
		for (;;) ;
d553 7
d572 1
a572 2
	for (;;) ;
	/* NOTREACHED */
a782 3
    shminfo.shmmax = shmmaxpgs;
    shminfo.shmall = shmmaxpgs;
    shminfo.shmseg = shmseg;
@


1.20.2.9
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d5 1
a5 3
 * Copyright (c) 2002, Hugh Graham.
 * Copyright (c) 2002, Miodrag Vallat.
 * Copyright (c) 1994, 1996, 1998 Ludd, University of Lule}, Sweden.
a12 3
 * This code is derived from software contributed to Ludd by
 * Bertram Barth.
 *
d79 6
a120 1
#include <vax/vax/db_disasm.h>
a154 1
struct cpmbx	*cpmbx;
a382 1
	struct sigcontext ksc;
d387 2
a388 3
	if (copyin((caddr_t)cntx, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);

d390 3
a392 3
	if ((ksc.sc_ps & (PSL_IPL | PSL_IS)) ||
	    ((ksc.sc_ps & (PSL_U | PSL_PREVU)) != (PSL_U | PSL_PREVU)) ||
	    (ksc.sc_ps & PSL_CM)) {
d395 1
a395 1
	if (ksc.sc_onstack & 01)
d400 1
a400 1
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;
d402 5
a406 5
	scf->fp = ksc.sc_fp;
	scf->ap = ksc.sc_ap;
	scf->pc = ksc.sc_pc;
	scf->sp = ksc.sc_sp;
	scf->psl = ksc.sc_ps;
a420 3
/*
 * XXX no siginfo implementation!!!!
 */
d434 1
d485 1
a485 1
	syscf->pc = p->p_sigcode;
d790 13
a837 157
/*
 * The following is a very stripped-down db_disasm.c, with only the logic
 * to skip instructions.
 */

long skip_operand(long ib, int size);

static __inline__ u_int8_t
get_byte(ib)
	long    ib;
{
	return *((u_int8_t *)ib);
}

long
skip_opcode(ib)
	long    ib;
{
	u_int opc;
	int size;
	char *argp;	/* pointer into argument-list */

	opc = get_byte(ib++);
	if (opc >= 0xfd) {
		/* two byte op-code */
		opc = opc << 8;
		opc += get_byte(ib++);
		argp = vax_inst2[INDEX_OPCODE(opc)].argdesc;
	} else
		argp = vax_inst[opc].argdesc;

	if (argp == NULL)
		return ib;

	while (*argp) {
		switch (*argp) {

		case 'b':	/* branch displacement */
			switch (*(++argp)) {
			case 'b':
				ib++;
				break;
			case 'w':
				ib += 2;
				break;
			case 'l':
				ib += 4;
				break;
			}
			break;

		case 'a':	/* absolute adressing mode */
			/* FALLTHROUGH */
		default:
			switch (*(++argp)) {
			case 'b':	/* Byte */
				size = 1;
				break;
			case 'w':	/* Word */
				size = 2;
				break;
			case 'l':	/* Long-Word */
			case 'f':	/* F_Floating */
				size = 4;
				break;
			case 'q':	/* Quad-Word */
			case 'd':	/* D_Floating */
			case 'g':	/* G_Floating */
				size = 8;
				break;
			case 'o':	/* Octa-Word */
			case 'h':	/* H_Floating */
				size = 16;
				break;
			default:
				size = 0;
			}
			ib = skip_operand(ib, size);
		}

		if (!*argp || !*++argp)
			break;
		if (*argp++ != ',')
			break;
	}

	return ib;
}

long
skip_operand(ib, size)
	long    ib;
	int	size;
{
	int c = get_byte(ib++);

	switch (c >> 4) { /* mode */
	case 4:		/* indexed */
		ib = skip_operand(ib, 0);
		break;

	case 9:		/* autoincrement deferred */
		if (c == 0x9f) {	/* pc: immediate deferred */
			/*
			 * addresses are always longwords!
			 */
			ib += 4;
		}
		break;
	case 8:		/* autoincrement */
		if (c == 0x8f) {	/* pc: immediate ==> special syntax */
			ib += size;
		}
		break;

	case 11:	/* byte displacement deferred/ relative deferred  */
	case 10:	/* byte displacement / relative mode */
		ib++;
		break;

	case 13:		/* word displacement deferred */
	case 12:		/* word displacement */
		ib += 2;
		break;

	case 15:		/* long displacement referred */
	case 14:		/* long displacement */
		ib += 4;
		break;
	}

	return ib;
}

void
generic_halt()
{
	if (cpmbx->user_halt != UHALT_DEFAULT) {
		if (cpmbx->mbox_halt != 0)
			cpmbx->mbox_halt = 0;	/* let console override */
	} else if (cpmbx->mbox_halt != MHALT_HALT)
		cpmbx->mbox_halt = MHALT_HALT;	/* the os decides */

	asm("halt");
}

void
generic_reboot(int arg)
{
	if (cpmbx->user_halt != UHALT_DEFAULT) {
		if (cpmbx->mbox_halt != 0)
			cpmbx->mbox_halt = 0;
	} else if (cpmbx->mbox_halt != MHALT_REBOOT)
		cpmbx->mbox_halt = MHALT_REBOOT;

	asm("halt");
}
@


1.20.2.10
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.20.2.9 2003/03/27 23:52:20 niklas Exp $ */
d151 1
a181 1
	extern char	cpu_model[];
d413 9
a421 9
struct sigframe {
	int		 sf_signum;
	siginfo_t 	*sf_sip;
	struct sigcontext *sf_scp;
	register_t 	 sf_r0, sf_r1, sf_r2, sf_r3, sf_r4, sf_r5;
	register_t 	 sf_pc;
	register_t 	 sf_arg;
	siginfo_t 	 sf_si;
	struct sigcontext sf_sc;
d424 3
d432 1
a432 1
	int 		type;
d438 3
a440 2
	struct	sigframe *sigf, gsigf;
	unsigned int	cursp;
d443 3
d447 1
d457 3
a459 1
	sigf = (struct sigframe *) (cursp - sizeof(struct sigframe));
d462 1
a462 1
	 * Place sp at the beginning of sigf; this ensures that possible
d464 1
a464 1
	 * sigframe/struct sigcontext pair with their own.
d466 1
a466 12
	cursp = (unsigned) sigf;

	bzero(&gsigf, sizeof gsigf);
	gsigf.sf_arg = (register_t)&sigf->sf_sc;
	gsigf.sf_pc = (register_t)catcher;
	gsigf.sf_scp = &sigf->sf_sc;
	gsigf.sf_signum = sig;

	if (psp->ps_siginfo & sigmask(sig)) {
		gsigf.sf_sip = &sigf->sf_si;
		initsiginfo(&gsigf.sf_si, sig, code, type, val);
	}
d468 13
a480 7
	gsigf.sf_sc.sc_pc = syscf->pc;
	gsigf.sf_sc.sc_ps = syscf->psl;
	gsigf.sf_sc.sc_ap = syscf->ap;
	gsigf.sf_sc.sc_fp = syscf->fp; 
	gsigf.sf_sc.sc_sp = syscf->sp; 
	gsigf.sf_sc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	gsigf.sf_sc.sc_mask = mask;
d483 1
a483 1
	native_sigset_to_sigset13(mask, &gsigf.sf_sc.__sc_mask13);
d486 2
a487 1
	if (copyout(&gsigf, sigf, sizeof(gsigf)))
d492 1
a492 1
	syscf->ap = (unsigned) sigf + offsetof(struct sigframe, sf_pc);
@


1.20.2.11
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d142 1
@


1.20.2.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.20.2.11 2003/05/16 00:29:41 niklas Exp $ */
d29 5
a33 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.20.2.13
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a167 2
void cpu_dumpconf(void);

d824 1
a824 4
long skip_operand(long, int);
long skip_opcode(long);

static u_int8_t get_byte(long);
d870 1
a870 1
		case 'a':	/* absolute addressing mode */
@


1.20.2.14
log
@Merge with the trunk
@
text
@d499 1
a499 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
@


1.19
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.18 1999/05/22 21:22:32 weingart Exp $ */
d695 6
@


1.18
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.17 1997/10/02 19:53:20 niklas Exp $ */
d93 1
d724 5
@


1.17
log
@Factor out the bufpages and nbuf calculation so that pmap_boststrap can get
at the values early on.  Also some KNF, this is our code now.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.16 1997/09/12 09:30:56 maja Exp $ */
a344 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.16
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.15 1997/09/10 12:04:50 maja Exp $ */
d117 4
a121 1
extern int virtual_avail, virtual_end;
d143 1
a143 1
		(name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
a164 1
	extern unsigned int avail_end;
d192 2
a193 3

	sz = (int) allocsys((caddr_t) 0);
	if ((v = (caddr_t) kmem_alloc(kernel_map, round_page(sz))) == 0)
d203 2
a204 2
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *) & buffers,
				   &maxaddr, size, TRUE);
d206 2
a207 2
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t) 0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
d226 1
a226 1
		curbuf = (vm_offset_t) buffers + i * MAXBSIZE;
d228 2
a229 1
		vm_map_pageable(buffer_map, curbuf, curbuf + curbufsize, FALSE);
d237 2
a238 2
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16 * NCARGS, TRUE);
d244 2
a245 2
	mclrefcnt = (char *) malloc(NMBCLUSTERS + CLBYTES / MCLBYTES,
				    M_MBUF, M_NOWAIT);
d247 2
a248 2
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *) & mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
a258 1

d265 2
a266 2
	printf("Using %d buffers containing %d bytes of memory.\n",
	       nbuf, bufpages * CLBYTES);
a270 1

d286 40
d339 1
a339 3

#define valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))
d352 1
d363 1
a363 33
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
	/*
	 * Determine how many buffers to allocate. By default we allocate
	 * the BSD standard of use 10% of memory for the first 2 Meg,
	 * 5% of remaining.  But this might cause systems with large
	 * core (32MB) to fail to boot due to small KVM space.  Reduce
	 * BUFCACHEPERCENT in this case.
	 * Insure a minimum of 16 buffers.
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0) {
		/* We always have more than 2MB of memory. */
		bufpages = (btoc(2 * 1024 * 1024) + physmem) /
			((100/BUFCACHEPERCENT) * CLSIZE);
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 70% filled kvm */
#ifdef 0
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
			MAXBSIZE * 7 / 10;
#endif
	
	/* More buffer pages than fits into the buffer is senseless. */
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;
d367 1
a367 1
			nswbuf = 256;	/* sanity */
d371 1
a371 1
	return v;
d405 1
a405 1
	(*dep_call->cpu_clock) ();
d530 1
a530 1
		(void) grow(p, cursp);
d533 2
a534 2
	sigctx = (struct sigcontext *) (cursp - sizeof(struct sigcontext));
	trampf = (struct trampframe *) ((unsigned)sigctx -
d611 1
a611 1
			(*dep_call->cpu_halt) ();
d624 3
a626 2
				showto |= (*b == 'a' ? RB_ASKBOOT : (*b == 'd' ?
				    RB_DEBUG : (*b == 's' ? RB_SINGLE : 0)));
d642 7
a648 8
		asm("	movl	sp, (0x80000200)
			movl	0x80000200, sp
			mfpr	$0x10, -(sp)	# PR_PCBB
			mfpr	$0x11, -(sp)	# PR_SCBB
			mfpr	$0xc, -(sp)	# PR_SBR
			mfpr	$0xd, -(sp)	# PR_SLR
			mtpr	$0, $0x38	# PR_MAPEN
		");
d676 6
a681 4
	asm("movl %0,r5":: "g" (showto)); /* How to boot */
	asm("movl %0, r11":: "r"(showto)); /* ??? */
	asm("halt");
	panic("Halt sket sej");
d732 1
a732 1
	if ((*dep_call->cpu_mchk) (frame) == 0)
d734 1
a734 1
	(*dep_call->cpu_memerr) ();
d756 1
a756 1
	switch ((*bdevsw[major(dumpdev)].d_dump) (dumpdev, 0, 0, 0)) {
d785 1
a785 1
	return 0;
d794 1
a794 1
	return 0;
d803 1
a803 1
	return 0;
d819 1
a819 1
	return 0;
d835 1
a835 1
	return 0;
d849 1
a849 1
	ptr = (char *) p->p_addr->u_pcb.framep;
d852 1
a852 1
	tf->pc = (unsigned) addr;
d881 1
a881 1
	(*dep_call->cpu_memerr) ();
@


1.15
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/* $OpenBSD: machdep.c,v 1.14 1997/08/30 09:50:28 maja Exp $ */
/* $NetBSD: machdep.c,v 1.41 1997/04/19 15:02:31 ragge Exp $	 */
d127 2
a128 1
char		machine[] = "vax";
d603 2
d606 1
a606 1
		for ( ; ; )
d609 13
d633 1
d642 2
d646 2
a647 2

		asm("movl %0,r5":: "g" (showto)); /* How to boot */
d652 1
a652 1
#if VAX750 || VAX780 || VAX630
a654 1
		case VAX_TYP_UV2:
d669 2
a670 1
	asm("movl %0, r11":: "r"(showto));
@


1.14
log
@Since the previous one died...
Some code to get my MV3600 to work. -moj
@
text
@d1 2
a2 2
/* $OpenBSD: machdep.c,v 1.13 1997/07/23 06:58:31 denny Exp $ */
/* $NetBSD: machdep.c,v 1.35 1997/01/11 11:31:26 ragge Exp $  */
d397 1
a397 1
	(cpu_calls[vax_cputype].cpu_clock) ();
d421 1
d704 1
a704 1
	if ((*cpu_calls[vax_cputype].cpu_mchk) (frame) == 0)
d706 1
a706 1
	(*cpu_calls[vax_cputype].cpu_memerr) ();
d853 1
a853 1
	(*cpu_calls[vax_cputype].cpu_memerr) ();
@


1.13
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.12 1997/05/28 23:27:33 niklas Exp $ */
d323 3
d327 13
a339 9
	 * Determine how many buffers to allocate (enough to hold 5% of total
	 * physical memory, but at least 16). Allocate 1/2 as many swap
	 * buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = (physmem / 10) / CLSIZE;
		else
			bufpages = (physmem / 20) / CLSIZE;
d345 11
@


1.12
log
@First stab att siginfo handling, needs more work.  Proto fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.11 1997/01/16 20:43:45 kstailey Exp $ */
d648 6
@


1.11
log
@do not call resettodr() if RB_TIMEBAD is set due to being in ddb with clock updates suspended
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.10 1997/01/15 23:25:17 maja Exp $ */
d460 1
a460 1
sendsig(catcher, sig, mask, code)
d464 2
d467 11
a477 8
	struct	proc	*p = curproc;
	struct	sigacts *psp = p->p_sigacts;
	struct	trapframe *syscf;
	struct	sigcontext *sigctx;
	struct	trampframe *trampf;
	unsigned	cursp;
	int	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	extern	char sigcode[], esigcode[];
d486 7
d497 2
a498 1
		cursp = (int)(psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size);
d501 1
a501 1
		cursp = syscf->sp;
d513 1
a513 2
	if (useracc((caddr_t) cursp, sizeof(struct sigcontext) +
		    sizeof(struct trampframe), B_WRITE) == 0) {
d526 1
a533 1

d546 6
d558 1
a558 1
boot(howto, bootstr)
d560 1
a560 1
	char *bootstr;
d729 1
a729 1
	const void *addr;
a732 1

d746 2
a747 2
	void *addr;
	short	cnt;
@


1.10
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d552 10
a561 1
		resettodr();
@


1.9
log
@handle RB_CONFIG
@
text
@d1 2
a2 1
/* $NetBSD: machdep.c,v 1.30 1996/05/19 16:44:13 ragge Exp $  */
d27 1
a27 1
 *      California, Berkeley and its contributors.
d123 7
a129 7
int             nmcr, nmba, numuba, cold = 1;
caddr_t         mcraddr[MAXNMCR];
int             astpending;
int             want_resched;
char            machine[] = "vax";
char            cpu_model[100];
int             msgbufmapped = 0;
d131 1
a131 1
int             physmem;
d133 2
a134 2
int             todrstopped = 0, glurg;
int             dumpsize = 0;
d141 2
a142 2
#ifdef  BUFPAGES
int             bufpages = BUFPAGES;
d144 1
a144 1
int             bufpages = 0;
d146 3
a148 3
int             nswbuf = 0;
#ifdef  NBUF
int             nbuf = NBUF;
d150 1
a150 1
int             nbuf = 0;
d156 5
a160 6
	caddr_t         v;
	extern char     version[];
	int             base, residual, i, sz;
	vm_offset_t     minaddr, maxaddr;
	vm_size_t       size;
	extern int      cpu_type, boothowto;
d169 1
a169 1
	if (cpunumber == VAX_750 || cpunumber == VAX_650)
d197 1
a197 1
	 * Now allocate buffers proper.  They are different than the above in
d214 2
a215 2
		vm_size_t       curbufsize;
		vm_offset_t     curbuf;
d219 1
a219 1
		 * allocated for them.  The rest get (base) physical pages.
d238 1
a238 1
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size we
d246 7
d300 1
a300 1
            v = (caddr_t)(((name) = (type *)v) + (num))
d348 1
a348 1
long    dumplo = 0;
d354 2
a355 2
	int             nblks;
	extern int      dumpdev;
d379 1
a379 1
	(cpu_calls[cpunumber].cpu_clock) ();
a389 1
	printf("cpu_sysctl:\n");
d452 1
a452 1
	unsigned	r0, r1, r2, r3, r4, r5;	/* Registers saved when
d461 3
a463 3
	sig_t           catcher;
	int             sig, mask;
	u_long          code;
d465 1
a465 1
	struct	proc    *p = curproc;
d471 1
a471 1
	int     oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d540 1
a540 1
boot(howto)
d542 1
d584 1
a584 1
		switch (cpunumber) {
d590 2
a591 2
		case VAX_630:
			mtpr(GC_BOOT, PR_TXDB);	/* boot command */
d652 1
a652 1
	if ((*cpu_calls[cpunumber].cpu_mchk) (frame) == 0)
d654 1
a654 1
	(*cpu_calls[cpunumber].cpu_memerr) ();
d661 1
a661 1
	extern int      dumpdev;
d702 1
a702 1
	caddr_t	addr;
a710 1
	int byte;
d712 1
d720 2
a721 2
	caddr_t	addr;
	u_int	cnt;
d782 1
a782 1
	void           *ptr;
d802 1
a802 1
	(*cpu_calls[cpunumber].cpu_memerr) ();
@


1.8
log
@sync to 0611
@
text
@d268 7
@


1.7
log
@fix panic at reboot.
@
text
@d1 1
a1 1
/* $NetBSD: machdep.c,v 1.29 1996/04/08 18:32:47 ragge Exp $  */
a65 1
#include <sys/cpu.h>
d114 1
a114 1
void	machinecheck __P((u_int));
a531 4
		extern struct proc proc0;
		/* allow safe curproc referencies */
		if (curproc == NULL)
			curproc = &proc0;
d636 1
a636 1
	u_int           frame;
@


1.6
log
@sync w/ 0430
@
text
@d533 4
@


1.5
log
@from ragge;
save usp when trapping from userspace
change register save structs according to this
handle old init register passing convention
@
text
@d1 1
a1 1
/* $NetBSD: machdep.c,v 1.23 1996/01/28 12:22:54 ragge Exp $  */
d48 21
a68 18
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/map.h"
#include "sys/proc.h"
#include "sys/user.h"
#include "sys/time.h"
#include "sys/signal.h"
#include "sys/kernel.h"
#include "sys/reboot.h"
#include "sys/msgbuf.h"
#include "sys/buf.h"
#include "sys/mbuf.h"
#include "sys/reboot.h"
#include "sys/conf.h"
#include "sys/callout.h"
#include "sys/device.h"
#include "sys/exec.h"
#include "sys/mount.h"
d70 1
a70 1
#include "sys/msg.h"
d73 1
a73 1
#include "sys/sem.h"
d76 1
a76 1
#include "sys/shm.h"
a77 11
#include "machine/sid.h"
#include "machine/pte.h"
#include "machine/mtpr.h"
#include "machine/cpu.h"
#include "machine/macros.h"
#include "machine/nexus.h"
#include "machine/trap.h"
#include "machine/reg.h"
#include "machine/../vax/gencons.h"
#include "vm/vm_kern.h"
#include "net/netisr.h"
d79 4
a82 1
#include <sys/syscallargs.h>
d84 8
d93 25
d153 1
d156 1
a156 1
	caddr_t         v, tempaddr;
d161 2
a162 2
	extern int      cpu_type, boothowto, startpmapdebug;
	extern unsigned int avail_start, avail_end;
d256 1
a256 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
d336 1
d338 1
d363 1
d369 7
a375 1
cpu_sysctl()
d388 1
d459 1
a459 1
	int     oonstack;
d524 2
a525 1
int             waittime = -1;
d527 1
d529 1
a529 1
	int             howto;
d531 1
d544 2
a545 1
		for (;;);
d547 20
a566 1
		if (howto & RB_DUMP)
d568 27
a594 4
		asm("movl %0,r5":: "g" (howto)); /* How to boot */
		mtpr(GC_BOOT, PR_TXDB);	/* boot command */
		asm("halt");
	}
d597 1
d635 1
d645 1
d661 1
a661 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d663 1
a663 1
	switch ((*bdevsw[major(dumpdev)].d_dump) (dumpdev)) {
d687 3
a689 1
fuswintr()
d692 2
d696 1
d702 1
d705 4
a708 1
suswintr()
d711 1
d786 1
a786 5
ns_cksum()
{
	panic("ns_cksum");
}

d789 1
a789 6
#if 0
	switch (cpunumber) {
	case VAX_750:
		ka750_memerr();
	}
#endif
@


1.4
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 1
a1 1
/* $NetBSD: machdep.c,v 1.22 1996/01/04 22:22:58 jtc Exp $  */
d353 1
a353 1
	db_machine_init();
d355 4
d392 1
a393 1
	mtpr(cntx->sc_sp, PR_USP);
d398 4
a401 4
	u_int           sig;	/* Signal number */
	u_int           code;	/* Info code */
	u_int           scp;	/* Pointer to struct sigcontext */
	u_int           r0, r1, r2, r3, r4, r5;	/* Registers saved when
d403 2
a404 2
	u_int           pc;	/* Address of signal handler */
	u_int           arg;	/* Pointer to first (and only) sigreturn
d414 8
a421 8
	struct proc    *p = curproc;
	struct sigacts *psp = p->p_sigacts;
	struct trapframe *syscf;
	struct sigcontext *sigctx;
	struct trampframe *trampf;
	u_int          *cursp;
	int             oonstack;
	extern char     sigcode[], esigcode[];
d429 2
d434 1
a434 2
		cursp = (u_int *) (psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size);
d437 3
a439 3
		cursp = (u_int *) mfpr(PR_USP);
	if ((u_int) cursp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void) grow(p, (u_int) cursp);
d442 2
a443 3
	sigctx = (struct sigcontext *) ((u_int) cursp -
	    sizeof(struct sigcontext));
	trampf = (struct trampframe *) ((u_int) sigctx -
a444 2
	cursp = (u_int *) sigctx - 2;	/* Place for pointer to arg list in
					 * sigreturn */
d446 3
a448 1
	syscf = p->p_addr->u_pcb.framep;
d465 1
a465 1
	trampf->pc = (u_int) catcher;
d475 1
a475 1
	sigctx->sc_sp = mfpr(PR_USP);
d479 1
a479 1
	syscf->pc = (u_int) (((char *) PS_STRINGS) - (esigcode - sigcode));
d481 2
a482 2
	syscf->ap = (u_int) cursp;
	mtpr(cursp, PR_USP);
d623 1
a623 12
	regs->r0 = tf->r0;
	regs->r1 = tf->r1;
	regs->r2 = tf->r2;
	regs->r3 = tf->r3;
	regs->r4 = tf->r4;
	regs->r5 = tf->r5;
	regs->r6 = tf->r6;
	regs->r7 = tf->r7;
	regs->r8 = tf->r8;
	regs->r9 = tf->r9;
	regs->r10 = tf->r10;
	regs->r11 = tf->r11;
d626 1
a626 1
	regs->sp = mfpr(PR_USP);
d639 1
a639 12
	tf->r0 = regs->r0;
	tf->r1 = regs->r1;
	tf->r2 = regs->r2;
	tf->r3 = regs->r3;
	tf->r4 = regs->r4;
	tf->r5 = regs->r5;
	tf->r6 = regs->r6;
	tf->r7 = regs->r7;
	tf->r8 = regs->r8;
	tf->r9 = regs->r9;
	tf->r10 = regs->r10;
	tf->r11 = regs->r11;
d642 1
a642 1
	mtpr(regs->sp, PR_USP);
d650 2
a651 2
	struct proc    *p;
	caddr_t         addr;
d653 2
a654 2
	void           *ptr;
	struct trapframe *tf;
d662 1
a662 1
	tf->pc = (u_int) addr;
a687 6
#undef setsoftnet
setsoftnet()
{
	panic("setsoftnet");
}

d695 1
d700 1
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/* $NetBSD: machdep.c,v 1.21 1995/12/13 18:45:54 ragge Exp $  */
d428 1
a428 1
		cursp = (u_int *) (psp->ps_sigstk.ss_base +
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/* $NetBSD: machdep.c,v 1.20 1995/11/10 19:05:49 ragge Exp $  */
d90 1
a90 1

d133 1
a133 1
	extern unsigned int avail_end;
d140 2
a141 2
#ifdef VAX750
	if (cpunumber == VAX_750)
d161 1
a212 1

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $NetBSD: machdep.c,v 1.19.2.1 1995/10/15 14:06:18 ragge Exp $  */
d715 8
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
