head	1.21;
access;
symbols
	OPENBSD_5_9:1.19.0.6
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.8
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.26
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.22
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.20
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.18
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.16
	OPENBSD_5_0:1.18.0.14
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.12.0.14
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.12
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.10
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.8
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.6
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.6
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.20;
commitid	OSDG2O3Cgeifnf1W;

1.20
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.19;
commitid	hnv9KfQtxhCytAnd;

1.19
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.18;
commitid	XHZxhpAa5R1Ymp1z;

1.18
date	2008.03.30.18.24.04;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.05.17.31.49;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.14.15.22.55;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.02.21.44.52;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.24.04.55.49;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.06.22.21.33;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.18.09.49.17;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.10.11.06.13.40;	author bjc;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.27.01.10.11;	author bjc;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.15.12.58;	author niklas;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.05.29.00.05.16;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.03.21.02.10.50;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.25.08;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.10.09;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.31.05.21.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.05.14.21.38.49;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: db_machdep.c,v 1.20 2016/02/27 13:08:07 mpi Exp $	*/
/*	$NetBSD: db_machdep.c,v 1.17 1999/06/20 00:58:23 ragge Exp $	*/

/* 
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 *
 *	db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 *
 * VAX enhancements by cmcmanis@@mcmanis.com no rights reserved :-)
 *
 */

/*
 * Interface to new debugger.
 * Taken from i386 port and modified for vax.
 */
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/reboot.h>
#include <sys/systm.h> /* just for boothowto --eichin */

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <machine/db_machdep.h>
#include <machine/trap.h>
#include <machine/frame.h>
#include <machine/pcb.h>
#include <machine/cpu.h>
#include <machine/../vax/gencons.h>

#include <ddb/db_sym.h>
#include <ddb/db_command.h>
#include <ddb/db_output.h>
#include <ddb/db_extern.h>
#include <ddb/db_access.h>
#include <ddb/db_interface.h>
#include <ddb/db_var.h>
#include <ddb/db_variables.h>

extern	label_t	*db_recover;

void	kdbprinttrap(int, int);

int	db_active = 0;
db_regs_t	ddb_regs;	/* register state */

extern int qdpolling;
static	int splsave; /* IPL before entering debugger */

/*
 * VAX Call frame on the stack, this from
 * "Computer Programming and Architecture, The VAX-11"
 *		Henry Levy & Richard Eckhouse Jr.
 *			ISBN 0-932376-07-X
 */
typedef struct __vax_frame {
	u_int	vax_cond;				/* condition handler               */
	u_int	vax_psw:16;				/* 16 bit processor status word    */
	u_int	vax_regs:12;			/* Register save mask.             */
	u_int	vax_zero:1;				/* Always zero                     */
	u_int	vax_calls:1;			/* True if CALLS, false if CALLG   */
	u_int	vax_spa:2;				/* Stack pointer alignment         */
	u_int	*vax_ap;				/* argument pointer                */
	struct __vax_frame	*vax_fp;	/* frame pointer of previous frame */
	u_int	vax_pc;					/* program counter                 */
	u_int	vax_args[1];			/* 0 or more arguments             */
} VAX_CALLFRAME;

/*
 * DDB is called by either <ESC> - D on keyboard, via a TRACE or
 * BPT trap or from kernel, normally as a result of a panic.
 * If it is the result of a panic, set the ddb register frame to
 * contain the registers when panic was called. (easy to debug).
 */
void
db_ktrap(frame)
	struct trapframe *frame;
{
	int s;

	switch (frame->trap) {
	case T_BPTFLT:	/* breakpoint */
	case T_TRCTRAP:	/* single_step */
		break;

	/* XXX todo: should be migrated to use VAX_CALLFRAME at some point */
	case T_KDBTRAP:
		if (panicstr) {
			struct	callsframe *pf, *df;

			df = (void *)frame->fp; /* start of debug's calls */
			pf = (void *)df->ca_fp;	/* start of panic's calls */
			bcopy(&pf->ca_argno, &ddb_regs.r0, sizeof(int) * 12);
			ddb_regs.fp = pf->ca_fp;
			ddb_regs.pc = pf->ca_pc;
			ddb_regs.ap = pf->ca_ap;
			ddb_regs.sp = (unsigned)pf;
			ddb_regs.psl = frame->psl & ~0x1fffe0;
			ddb_regs.psl |= pf->ca_maskpsw & 0xffe0;
			ddb_regs.psl |= (splsave << 16);
		}
		break;

	default:
		if ((boothowto & RB_KDB) == 0)
			return;

		kdbprinttrap(frame->trap, frame->code);
		if (db_recover != 0) {
			db_error("Faulted in DDB; continuing...\n");
			/*NOTREACHED*/
		}
	}

	if (!panicstr)
		bcopy(frame, &ddb_regs, sizeof(struct trapframe));

	/* XXX Should switch to interrupt stack here, if needed. */

	s = splhigh();
	db_active++;
	cnpollc(TRUE);
	db_trap(frame->trap, frame->code);
	cnpollc(FALSE);
	db_active--;
	splx(s);

	if (!panicstr)
		bcopy(&ddb_regs, frame, sizeof(struct trapframe));
	frame->sp = mfpr(PR_USP);
}

extern char *traptypes[];
extern int no_traps;

/*
 * Print trap reason.
 */
void
kdbprinttrap(type, code)
	int type, code;
{
	db_printf("kernel: ");
	if (type >= no_traps || type < 0)
		db_printf("type %d", type);
	else
		db_printf("%s", traptypes[type]);
	db_printf(" trap, code=%x\n", code);
}

/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(addr, size, data)
	db_addr_t addr;
	size_t	size;
	char	*data;
{
	bcopy((caddr_t)addr, data, size);
}

/*
 * Write bytes to kernel address space for debugger.
 */
void
db_write_bytes(addr, size, data)
	db_addr_t addr;
	size_t	size;
	char	*data;
{
	memcpy((caddr_t)addr, data, size);
}

void
Debugger()
{
	splsave = _splset(0xe);
	mtpr(0xf, PR_SIRR); /* beg for debugger */
	splx(splsave);
}

/*
 * Machine register set.
 */
struct db_variable db_regs[] = {
	{"r0",	(long *)&ddb_regs.r0,	FCN_NULL},
	{"r1",	(long *)&ddb_regs.r1,	FCN_NULL},
	{"r2",	(long *)&ddb_regs.r2,	FCN_NULL},
	{"r3",	(long *)&ddb_regs.r3,	FCN_NULL},
	{"r4",	(long *)&ddb_regs.r4,	FCN_NULL},
	{"r5",	(long *)&ddb_regs.r5,	FCN_NULL},
	{"r6",	(long *)&ddb_regs.r6,	FCN_NULL},
	{"r7",	(long *)&ddb_regs.r7,	FCN_NULL},
	{"r8",	(long *)&ddb_regs.r8,	FCN_NULL},
	{"r9",	(long *)&ddb_regs.r9,	FCN_NULL},
	{"r10",	(long *)&ddb_regs.r10,	FCN_NULL},
	{"r11",	(long *)&ddb_regs.r11,	FCN_NULL},
	{"ap",	(long *)&ddb_regs.ap,	FCN_NULL},
	{"fp",	(long *)&ddb_regs.fp,	FCN_NULL},
	{"sp",	(long *)&ddb_regs.sp,	FCN_NULL},
	{"pc",	(long *)&ddb_regs.pc,	FCN_NULL},
	{"psl",	(long *)&ddb_regs.psl,	FCN_NULL},
};
struct db_variable *db_eregs = db_regs + nitems(db_regs);

#define IN_USERLAND(x)	(((u_int)(x) & 0x80000000) == 0)

/*
 * Dump a stack traceback. Takes two arguments:
 *	fp - CALL FRAME pointer
 *	stackbase - Lowest stack value
 */
static void
db_dump_stack(VAX_CALLFRAME *fp, u_int stackbase, int (*pr)(const char *, ...))
{
	u_int nargs, arg_base, regs;
	VAX_CALLFRAME *tmp_frame;
	db_expr_t	diff;
	db_sym_t	sym;
	char		*symname;

	(*pr)("Stack traceback : \n");
	if (IN_USERLAND(fp)) {
		(*pr)("  Process is executing in user space.\n");
		return;
	}

	while ((u_int)(fp->vax_fp) > stackbase &&
	    (u_int)(fp->vax_fp) <= (stackbase + USPACE)) {
		diff = INT_MAX;
		symname = NULL;
		sym = db_search_symbol(fp->vax_pc, DB_STGY_ANY, &diff);
		db_symbol_values(sym, &symname, 0);
		(*pr)("%s+0x%lx(", symname, diff);

		/*
		 * Figure out the arguments by using a bit of subtlety.
		 * As the argument pointer may have been used as a temporary
		 * by the callee ... recreate what it would have pointed to
		 * as follows:
		 *  The vax_regs value has a 12 bit bitmask of the registers
		 *    that were saved on the stack.
		 *	Store that in 'regs' and then for every bit that is
		 *    on (indicates the register contents are on the stack)
		 *    increment the argument base (arg_base) by one.
		 *  When that is done, args[arg_base] points to the longword
		 *    that identifies the number of arguments.
		 *	arg_base+1 - arg_base+n are the argument pointers/contents.
		 */

		/* First get the frame that called this function ... */
		tmp_frame = fp->vax_fp;

		/* Isolate the saved register bits, and count them */
		regs = tmp_frame->vax_regs;
		for (arg_base = 0; regs != 0; regs >>= 1) {
			if (regs & 1)
				arg_base++;
		}

		/* number of arguments is then pointed to by vax_args[arg_base] */
		nargs = tmp_frame->vax_args[arg_base];
		if (nargs) {
			nargs--; /* reduce by one for formatting niceties */
			arg_base++; /* skip past the actual number of arguments */
			while (nargs--)
				(*pr)("0x%x,", tmp_frame->vax_args[arg_base++]);

			/* now print out the last arg with closing brace and \n */
			(*pr)("0x%x)\n", tmp_frame->vax_args[arg_base]);
		} else
			(*pr)("void)\n");
		/* move to the next frame */
		fp = fp->vax_fp;
	}
}

/*
 * Implement the trace command which has the form:
 *
 *	trace				<-- Trace panic (same as before)
 *	trace	0x88888 	<-- Trace process whose address is 888888
 *	trace/t				<-- Trace current process (0 if no current proc)
 *	trace/t	0tnn		<-- Trace process nn (0t for decimal)
 */
void
db_stack_trace_print(addr, have_addr, count, modif, pr)
        db_expr_t       addr;		/* Address parameter */
        boolean_t       have_addr;	/* True if addr is valid */
        db_expr_t       count;		/* Optional count */
        char            *modif;		/* pointer to flag modifier 't' */
	int		(*pr)(const char *, ...);
{
	extern vaddr_t 	proc0paddr, istack;
	struct proc	*p = curproc;
	struct user	*uarea;
	int		trace_proc;
	pid_t	curpid;
	char	*s;
 
	/* Check to see if we're tracing a process */
	trace_proc = 0;
	s = modif;
	while (!trace_proc && *s) {
		if (*s++ == 't')
			trace_proc++;	/* why yes we are */
	}

	/* Trace a panic */
	if (! trace_proc) {
		if (have_addr == 0)
			db_dump_stack((VAX_CALLFRAME *)ddb_regs.fp,
			    ddb_regs.ap, pr);
		else
			db_dump_stack((VAX_CALLFRAME *)addr, istack, pr);
		return;
	}

	/* 
	 * If user typed an address its either a PID, or a Frame 
	 * if no address then either current proc or panic
	 */
	if (have_addr) {
		p = pfind((int)addr);
		/* Try to be helpful by looking at it as if it were decimal */
		if (p == NULL) {
			u_int	tpid = 0;
			u_int	foo = addr;

			while (foo != 0) {
				int digit = (foo >> 28) & 0xf;
				if (digit > 9) {
					(*pr)("  No such process.\n");
					return;
				}
				tpid = tpid * 10 + digit;
				foo = foo << 4;
			}
			p = pfind(tpid);
			if (p == NULL) {
				(*pr)("  No such process.\n");
				return;
			}
		}
	} else {
		p = curproc;
		if (p == NULL) {
			(*pr)("trace: no current process! (ignored)\n");
			return;
		}
	}
	if (p == NULL) {
		uarea = (struct user *)proc0paddr;
		curpid = 0;
	} else {
		uarea = p->p_addr;
		curpid = p->p_pid;
	}
	(*pr)("Process %d\n", curpid);
	(*pr)("  PCB contents:\n");
	(*pr)("	KSP = 0x%x\n", (unsigned int)(uarea->u_pcb.KSP));
	(*pr)("	ESP = 0x%x\n", (unsigned int)(uarea->u_pcb.ESP));
	(*pr)("	SSP = 0x%x\n", (unsigned int)(uarea->u_pcb.SSP));
	(*pr)("	USP = 0x%x\n", (unsigned int)(uarea->u_pcb.USP));
	(*pr)("	R[00] = 0x%08x    R[06] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[0]), (unsigned int)(uarea->u_pcb.R[6]));
	(*pr)("	R[01] = 0x%08x    R[07] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[1]), (unsigned int)(uarea->u_pcb.R[7]));
	(*pr)("	R[02] = 0x%08x    R[08] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[2]), (unsigned int)(uarea->u_pcb.R[8]));
	(*pr)("	R[03] = 0x%08x    R[09] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[3]), (unsigned int)(uarea->u_pcb.R[9]));
	(*pr)("	R[04] = 0x%08x    R[10] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[4]), (unsigned int)(uarea->u_pcb.R[10]));
	(*pr)("	R[05] = 0x%08x    R[11] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[5]), (unsigned int)(uarea->u_pcb.R[11]));
	(*pr)("	AP = 0x%x\n", (unsigned int)(uarea->u_pcb.AP));
	(*pr)("	FP = 0x%x\n", (unsigned int)(uarea->u_pcb.FP));
	(*pr)("	PC = 0x%x\n", (unsigned int)(uarea->u_pcb.PC));
	(*pr)("	PSL = 0x%x\n", (unsigned int)(uarea->u_pcb.PSL));
	(*pr)("	Trap frame pointer: 0x%x\n", 
							(unsigned int)(uarea->u_pcb.framep));
	db_dump_stack((VAX_CALLFRAME *)(uarea->u_pcb.FP),
	    (u_int)uarea->u_pcb.KSP, pr);
}

static int ddbescape = 0;

int
kdbrint(tkn)
	int tkn;
{

	if (ddbescape && ((tkn & 0x7f) == 'D')) {
		if (db_console)
			mtpr(0xf, PR_SIRR);
		ddbescape = 0;
		return 1;
	}

	if ((ddbescape == 0) && ((tkn & 0x7f) == 27)) {
		ddbescape = 1;
		return 1;
	}

	if (ddbescape) {
		ddbescape = 0;
		return 2;
	}
	
	ddbescape = 0;
	return 0;
}

@


1.20
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.19 2014/07/13 12:11:01 jasper Exp $	*/
@


1.19
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.18 2008/03/30 18:24:04 miod Exp $	*/
d101 1
a101 1
kdb_trap(frame)
@


1.18
log
@Nuke common.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.17 2007/04/05 17:31:49 miod Exp $	*/
d230 1
a230 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.17
log
@splx() does not need to return a value.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.16 2006/07/14 15:22:55 miod Exp $	*/
d70 1
@


1.16
log
@Allow tracebacks of the kernel stack even when the kernel did not panic,
gives us meaningful splassert tracebacks whenever necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.15 2006/01/02 21:44:52 miod Exp $	*/
d202 1
a202 1
	splsave = splx(0xe);
@


1.15
log
@Check db_console before entering ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.14 2005/11/24 04:55:49 brad Exp $	*/
a154 2

	return;
d239 2
a240 1
db_dump_stack(VAX_CALLFRAME *fp, u_int stackbase, int (*pr)(const char *, ...)) {
d253 2
a254 3
	while (((u_int)(fp->vax_fp) > stackbase) && 
			((u_int)(fp->vax_fp) < (stackbase + USPACE))) {

d319 1
a319 1
	extern vaddr_t 	proc0paddr;
d336 5
a340 7
		if (! panicstr) {
			(*pr)("Not a panic, use trace/t to trace a process.\n");
			return;
		}
		(*pr)("panic: %s\n", panicstr);
		/* xxx ? where did we panic and whose stack are we using? */
		db_dump_stack((VAX_CALLFRAME *)(ddb_regs.fp), ddb_regs.ap, pr);
d349 9
a357 18
		if (trace_proc) {
			p = pfind((int)addr);
			/* Try to be helpful by looking at it as if it were decimal */
			if (p == NULL) {
				u_int	tpid = 0;
				u_int	foo = addr;

				while (foo != 0) {
					int digit = (foo >> 28) & 0xf;
					if (digit > 9) {
						(*pr)("  No such process.\n");
						return;
					}
					tpid = tpid * 10 + digit;
					foo = foo << 4;
				}
				p = pfind(tpid);
				if (p == NULL) {
d361 2
d364 3
a366 4
		} else {
			p = (struct proc *)(addr);
			if (pfind(p->p_pid) != p) {
				(*pr)("  This address does not point to a valid process.\n");
d371 4
a374 11
		if (trace_proc) {
			p = curproc;
			if (p == NULL) {
				(*pr)("trace: no current process! (ignored)\n");
				return;
			}
		} else {
			if (! panicstr) {
				(*pr)("Not a panic, no active process, ignored.\n");
				return;
			}
d408 2
a409 74
	db_dump_stack((VAX_CALLFRAME *)(uarea->u_pcb.FP), (u_int) uarea->u_pcb.KSP, pr);
	return;
#if 0
	while (((u_int)(cur_frame->vax_fp) > stackbase) && 
			((u_int)(cur_frame->vax_fp) < (stackbase + USPACE))) {
		u_int nargs;
		VAX_CALLFRAME *tmp_frame;

		diff = INT_MAX;
		symname = NULL;
		sym = db_search_symbol(cur_frame->vax_pc, DB_STGY_ANY, &diff);
		db_symbol_values(sym, &symname, 0);
		(*pr)("%s+0x%lx(", symname, diff);

		/*
		 * Figure out the arguments by using a bit of subterfuge
		 * since the argument pointer may have been used as a temporary
		 * by the callee ... recreate what it would have pointed to
		 * as follows:
		 *  The vax_regs value has a 12 bit bitmask of the registers
		 *    that were saved on the stack.
		 *	Store that in 'regs' and then for every bit that is
		 *    on (indicates the register contents are on the stack)
		 *    increment the argument base (arg_base) by one.
		 *  When that is done, args[arg_base] points to the longword
		 *    that identifies the number of arguments.
		 *	arg_base+1 - arg_base+n are the argument pointers/contents.
		 */

		/* First get the frame that called this function ... */
		tmp_frame = cur_frame->vax_fp;

		/* Isolate the saved register bits, and count them */
		regs = tmp_frame->vax_regs;
		for (arg_base = 0; regs != 0; regs >>= 1) {
			if (regs & 1)
				arg_base++;
		}

		/* number of arguments is then pointed to by vax_args[arg_base] */
		nargs = tmp_frame->vax_args[arg_base];
		if (nargs) {
			nargs--; /* reduce by one for formatting niceties */
			arg_base++; /* skip past the actual number of arguments */
			while (nargs--)
				(*pr)("0x%x,", tmp_frame->vax_args[arg_base++]);

			/* now print out the last arg with closing brace and \n */
			(*pr)("0x%x)\n", tmp_frame->vax_args[++arg_base]);
		} else
			(*pr)("void)\n");
		/* move to the next frame */
		cur_frame = cur_frame->vax_fp;
	}

	/*
	 * DEAD CODE, previous panic tracing code.
	 */
	if (! have_addr) {
		printf("Trace default\n");
		if (panicstr) {
			cf = (int *)ddb_regs.sp;
		} else {
			printf("Don't know what to do without panic\n");
			return;
		}
		if (p)
			paddr = (u_int)p->p_addr;
		else
			paddr = proc0paddr;

		stackbase = (ddb_regs.psl & PSL_IS ? istack : paddr);
 	}
#endif
@


1.14
log
@splimp -> splhigh

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.13 2005/11/06 22:21:33 miod Exp $	*/
d62 1
d511 2
a512 1
		mtpr(0xf, PR_SIRR);
@


1.13
log
@Kill deprecated vm_offset_t and vm_size_t types on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.12 2002/05/18 09:49:17 art Exp $	*/
d143 1
a143 1
	s = splimp();
@


1.12
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.11 2002/03/14 01:26:48 millert Exp $	*/
d181 1
a181 1
	vm_offset_t	addr;
d193 1
a193 1
	vm_offset_t	addr;
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.10 2001/11/06 19:53:17 miod Exp $	*/
d240 1
a240 1
db_dump_stack(VAX_CALLFRAME *fp, u_int stackbase) {
d247 1
a247 1
	db_printf("Stack traceback : \n");
d249 1
a249 1
		db_printf("  Process is executing in user space.\n");
d260 1
a260 1
		db_printf("%s+0x%lx(", symname, diff);
d293 1
a293 1
				db_printf("0x%x,", tmp_frame->vax_args[arg_base++]);
d296 1
a296 1
			db_printf("0x%x)\n", tmp_frame->vax_args[arg_base]);
d298 1
a298 1
			db_printf("void)\n");
d313 1
a313 1
db_stack_trace_cmd(addr, have_addr, count, modif)
d318 1
d338 1
a338 1
			db_printf("Not a panic, use trace/t to trace a process.\n");
d341 1
a341 1
		db_printf("panic: %s\n", panicstr);
d343 1
a343 1
		db_dump_stack((VAX_CALLFRAME *)(ddb_regs.fp), ddb_regs.ap);
d362 1
a362 1
						db_printf("  No such process.\n");
d370 1
a370 1
					db_printf("  No such process.\n");
d377 1
a377 1
				db_printf("  This address does not point to a valid process.\n");
d385 1
a385 1
				db_printf("trace: no current process! (ignored)\n");
d390 1
a390 1
				db_printf("Not a panic, no active process, ignored.\n");
d402 7
a408 7
	db_printf("Process %d\n", curpid);
	db_printf("  PCB contents:\n");
	db_printf("	KSP = 0x%x\n", (unsigned int)(uarea->u_pcb.KSP));
	db_printf("	ESP = 0x%x\n", (unsigned int)(uarea->u_pcb.ESP));
	db_printf("	SSP = 0x%x\n", (unsigned int)(uarea->u_pcb.SSP));
	db_printf("	USP = 0x%x\n", (unsigned int)(uarea->u_pcb.USP));
	db_printf("	R[00] = 0x%08x    R[06] = 0x%08x\n", 
d410 1
a410 1
	db_printf("	R[01] = 0x%08x    R[07] = 0x%08x\n", 
d412 1
a412 1
	db_printf("	R[02] = 0x%08x    R[08] = 0x%08x\n", 
d414 1
a414 1
	db_printf("	R[03] = 0x%08x    R[09] = 0x%08x\n", 
d416 1
a416 1
	db_printf("	R[04] = 0x%08x    R[10] = 0x%08x\n", 
d418 1
a418 1
	db_printf("	R[05] = 0x%08x    R[11] = 0x%08x\n", 
d420 5
a424 5
	db_printf("	AP = 0x%x\n", (unsigned int)(uarea->u_pcb.AP));
	db_printf("	FP = 0x%x\n", (unsigned int)(uarea->u_pcb.FP));
	db_printf("	PC = 0x%x\n", (unsigned int)(uarea->u_pcb.PC));
	db_printf("	PSL = 0x%x\n", (unsigned int)(uarea->u_pcb.PSL));
	db_printf("	Trap frame pointer: 0x%x\n", 
d426 1
a426 1
	db_dump_stack((VAX_CALLFRAME *)(uarea->u_pcb.FP), (u_int) uarea->u_pcb.KSP);
d438 1
a438 1
		db_printf("%s+0x%lx(", symname, diff);
d471 1
a471 1
				db_printf("0x%x,", tmp_frame->vax_args[arg_base++]);
d474 1
a474 1
			db_printf("0x%x)\n", tmp_frame->vax_args[++arg_base]);
d476 1
a476 1
			db_printf("void)\n");
@


1.10
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.9 2000/10/11 06:13:40 bjc Exp $	*/
d66 1
a66 1
void	kdbprinttrap __P((int, int));
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.10 2001/11/06 19:53:17 miod Exp $	*/
d66 1
a66 1
void	kdbprinttrap(int, int);
d240 1
a240 1
db_dump_stack(VAX_CALLFRAME *fp, u_int stackbase, int (*pr)(const char *, ...)) {
d247 1
a247 1
	(*pr)("Stack traceback : \n");
d249 1
a249 1
		(*pr)("  Process is executing in user space.\n");
d260 1
a260 1
		(*pr)("%s+0x%lx(", symname, diff);
d293 1
a293 1
				(*pr)("0x%x,", tmp_frame->vax_args[arg_base++]);
d296 1
a296 1
			(*pr)("0x%x)\n", tmp_frame->vax_args[arg_base]);
d298 1
a298 1
			(*pr)("void)\n");
d313 1
a313 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a317 1
	int		(*pr)(const char *, ...);
d337 1
a337 1
			(*pr)("Not a panic, use trace/t to trace a process.\n");
d340 1
a340 1
		(*pr)("panic: %s\n", panicstr);
d342 1
a342 1
		db_dump_stack((VAX_CALLFRAME *)(ddb_regs.fp), ddb_regs.ap, pr);
d361 1
a361 1
						(*pr)("  No such process.\n");
d369 1
a369 1
					(*pr)("  No such process.\n");
d376 1
a376 1
				(*pr)("  This address does not point to a valid process.\n");
d384 1
a384 1
				(*pr)("trace: no current process! (ignored)\n");
d389 1
a389 1
				(*pr)("Not a panic, no active process, ignored.\n");
d401 7
a407 7
	(*pr)("Process %d\n", curpid);
	(*pr)("  PCB contents:\n");
	(*pr)("	KSP = 0x%x\n", (unsigned int)(uarea->u_pcb.KSP));
	(*pr)("	ESP = 0x%x\n", (unsigned int)(uarea->u_pcb.ESP));
	(*pr)("	SSP = 0x%x\n", (unsigned int)(uarea->u_pcb.SSP));
	(*pr)("	USP = 0x%x\n", (unsigned int)(uarea->u_pcb.USP));
	(*pr)("	R[00] = 0x%08x    R[06] = 0x%08x\n", 
d409 1
a409 1
	(*pr)("	R[01] = 0x%08x    R[07] = 0x%08x\n", 
d411 1
a411 1
	(*pr)("	R[02] = 0x%08x    R[08] = 0x%08x\n", 
d413 1
a413 1
	(*pr)("	R[03] = 0x%08x    R[09] = 0x%08x\n", 
d415 1
a415 1
	(*pr)("	R[04] = 0x%08x    R[10] = 0x%08x\n", 
d417 1
a417 1
	(*pr)("	R[05] = 0x%08x    R[11] = 0x%08x\n", 
d419 5
a423 5
	(*pr)("	AP = 0x%x\n", (unsigned int)(uarea->u_pcb.AP));
	(*pr)("	FP = 0x%x\n", (unsigned int)(uarea->u_pcb.FP));
	(*pr)("	PC = 0x%x\n", (unsigned int)(uarea->u_pcb.PC));
	(*pr)("	PSL = 0x%x\n", (unsigned int)(uarea->u_pcb.PSL));
	(*pr)("	Trap frame pointer: 0x%x\n", 
d425 1
a425 1
	db_dump_stack((VAX_CALLFRAME *)(uarea->u_pcb.FP), (u_int) uarea->u_pcb.KSP, pr);
d437 1
a437 1
		(*pr)("%s+0x%lx(", symname, diff);
d470 1
a470 1
				(*pr)("0x%x,", tmp_frame->vax_args[arg_base++]);
d473 1
a473 1
			(*pr)("0x%x)\n", tmp_frame->vax_args[++arg_base]);
d475 1
a475 1
			(*pr)("void)\n");
@


1.9
log
@fix argument printing in stack trace
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.8 2000/04/27 01:10:11 bjc Exp $	*/
d45 1
a45 1
#include <vm/vm.h>
@


1.8
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.7 1997/10/06 15:12:58 niklas Exp $	*/
d296 1
a296 1
			db_printf("0x%x)\n", tmp_frame->vax_args[++arg_base]);
d342 1
a342 1
		db_dump_stack((VAX_CALLFRAME *)(ddb_regs.sp), ddb_regs.ap);
@


1.7
log
@db_{read,write}_bytes loop end condition bad (unsigned >= 0 -> always TRUE)
some KNF.  Now you can examine memory from ddb
@
text
@d1 2
a2 2
/*	$OpenBSD: db_machdep.c,v 1.6 1997/05/29 00:05:16 niklas Exp $	*/
/*	$NetBSD: db_machdep.c,v 1.8 1996/10/13 03:35:39 christos Exp $	*/
d15 1
a15 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d30 3
d41 1
d47 2
d52 1
d70 22
d109 1
d121 3
a123 2
			ddb_regs.psl = frame->psl & ~0xffe0;
			ddb_regs.psl = pf->ca_maskpsw & 0xffe0;
d143 1
a143 3
	s = splddb();
	mtpr(0, PR_RXCS);
	mtpr(0, PR_TXCS);
d145 1
d147 1
a148 2
	mtpr(GC_RIE, PR_RXCS);
	mtpr(GC_TIE, PR_TXCS);
d182 2
a183 2
	size_t		size;
	char	       *data;
d185 1
a185 6
	char   *src;
	size_t	i;

	src = (char *)addr;
	for (i = 0; i < size; i++)
		*data++ = *src++;
d194 2
a195 2
	size_t		size;
	char	       *data;
d197 1
a197 6
	char   *dst;
	size_t	i;

	dst = (char *)addr;
	for (i = 0; i < size; i++)
		*dst++ = *data++;
d203 1
a203 1
	int s = splx(0xe); /* Is this good? We must lower anyway... */
d205 1
a205 1
	splx(s);
d232 80
d314 4
a317 4
        db_expr_t       addr;
        boolean_t       have_addr;
        db_expr_t       count;
        char            *modif;
d319 180
a498 1
	printf("db_stack_trace_cmd - addr %x, have_addr %x, count %x, modif %x\n",addr, have_addr, count, (int)modif);
d527 1
@


1.7.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: db_machdep.c,v 1.9 2000/10/11 06:13:40 bjc Exp $	*/
/*	$NetBSD: db_machdep.c,v 1.17 1999/06/20 00:58:23 ragge Exp $	*/
d15 1
a15 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
a29 3
 *
 * VAX enhancements by cmcmanis@@mcmanis.com no rights reserved :-)
 *
a37 1
#include <sys/user.h>
a42 2
#include <dev/cons.h>

a45 1
#include <machine/pcb.h>
a62 22
extern int qdpolling;
static	int splsave; /* IPL before entering debugger */

/*
 * VAX Call frame on the stack, this from
 * "Computer Programming and Architecture, The VAX-11"
 *		Henry Levy & Richard Eckhouse Jr.
 *			ISBN 0-932376-07-X
 */
typedef struct __vax_frame {
	u_int	vax_cond;				/* condition handler               */
	u_int	vax_psw:16;				/* 16 bit processor status word    */
	u_int	vax_regs:12;			/* Register save mask.             */
	u_int	vax_zero:1;				/* Always zero                     */
	u_int	vax_calls:1;			/* True if CALLS, false if CALLG   */
	u_int	vax_spa:2;				/* Stack pointer alignment         */
	u_int	*vax_ap;				/* argument pointer                */
	struct __vax_frame	*vax_fp;	/* frame pointer of previous frame */
	u_int	vax_pc;					/* program counter                 */
	u_int	vax_args[1];			/* 0 or more arguments             */
} VAX_CALLFRAME;

a79 1
	/* XXX todo: should be migrated to use VAX_CALLFRAME at some point */
d91 2
a92 3
			ddb_regs.psl = frame->psl & ~0x1fffe0;
			ddb_regs.psl |= pf->ca_maskpsw & 0xffe0;
			ddb_regs.psl |= (splsave << 16);
d112 3
a114 1
	s = splimp();
a115 1
	cnpollc(TRUE);
a116 1
	cnpollc(FALSE);
d118 2
d153 2
a154 2
	size_t	size;
	char	*data;
d156 6
a161 1
	bcopy((caddr_t)addr, data, size);
d170 2
a171 2
	size_t	size;
	char	*data;
d173 6
a178 1
	memcpy((caddr_t)addr, data, size);
d184 1
a184 1
	splsave = splx(0xe);
d186 1
a186 1
	splx(splsave);
a212 80
#define IN_USERLAND(x)	(((u_int)(x) & 0x80000000) == 0)

/*
 * Dump a stack traceback. Takes two arguments:
 *	fp - CALL FRAME pointer
 *	stackbase - Lowest stack value
 */
static void
db_dump_stack(VAX_CALLFRAME *fp, u_int stackbase) {
	u_int nargs, arg_base, regs;
	VAX_CALLFRAME *tmp_frame;
	db_expr_t	diff;
	db_sym_t	sym;
	char		*symname;

	db_printf("Stack traceback : \n");
	if (IN_USERLAND(fp)) {
		db_printf("  Process is executing in user space.\n");
		return;
	}

	while (((u_int)(fp->vax_fp) > stackbase) && 
			((u_int)(fp->vax_fp) < (stackbase + USPACE))) {

		diff = INT_MAX;
		symname = NULL;
		sym = db_search_symbol(fp->vax_pc, DB_STGY_ANY, &diff);
		db_symbol_values(sym, &symname, 0);
		db_printf("%s+0x%lx(", symname, diff);

		/*
		 * Figure out the arguments by using a bit of subtlety.
		 * As the argument pointer may have been used as a temporary
		 * by the callee ... recreate what it would have pointed to
		 * as follows:
		 *  The vax_regs value has a 12 bit bitmask of the registers
		 *    that were saved on the stack.
		 *	Store that in 'regs' and then for every bit that is
		 *    on (indicates the register contents are on the stack)
		 *    increment the argument base (arg_base) by one.
		 *  When that is done, args[arg_base] points to the longword
		 *    that identifies the number of arguments.
		 *	arg_base+1 - arg_base+n are the argument pointers/contents.
		 */

		/* First get the frame that called this function ... */
		tmp_frame = fp->vax_fp;

		/* Isolate the saved register bits, and count them */
		regs = tmp_frame->vax_regs;
		for (arg_base = 0; regs != 0; regs >>= 1) {
			if (regs & 1)
				arg_base++;
		}

		/* number of arguments is then pointed to by vax_args[arg_base] */
		nargs = tmp_frame->vax_args[arg_base];
		if (nargs) {
			nargs--; /* reduce by one for formatting niceties */
			arg_base++; /* skip past the actual number of arguments */
			while (nargs--)
				db_printf("0x%x,", tmp_frame->vax_args[arg_base++]);

			/* now print out the last arg with closing brace and \n */
			db_printf("0x%x)\n", tmp_frame->vax_args[arg_base]);
		} else
			db_printf("void)\n");
		/* move to the next frame */
		fp = fp->vax_fp;
	}
}

/*
 * Implement the trace command which has the form:
 *
 *	trace				<-- Trace panic (same as before)
 *	trace	0x88888 	<-- Trace process whose address is 888888
 *	trace/t				<-- Trace current process (0 if no current proc)
 *	trace/t	0tnn		<-- Trace process nn (0t for decimal)
 */
d215 4
a218 4
        db_expr_t       addr;		/* Address parameter */
        boolean_t       have_addr;	/* True if addr is valid */
        db_expr_t       count;		/* Optional count */
        char            *modif;		/* pointer to flag modifier 't' */
d220 1
a220 180
	extern vaddr_t 	proc0paddr;
	struct proc	*p = curproc;
	struct user	*uarea;
	int		trace_proc;
	pid_t	curpid;
	char	*s;
 
	/* Check to see if we're tracing a process */
	trace_proc = 0;
	s = modif;
	while (!trace_proc && *s) {
		if (*s++ == 't')
			trace_proc++;	/* why yes we are */
	}

	/* Trace a panic */
	if (! trace_proc) {
		if (! panicstr) {
			db_printf("Not a panic, use trace/t to trace a process.\n");
			return;
		}
		db_printf("panic: %s\n", panicstr);
		/* xxx ? where did we panic and whose stack are we using? */
		db_dump_stack((VAX_CALLFRAME *)(ddb_regs.fp), ddb_regs.ap);
		return;
	}

	/* 
	 * If user typed an address its either a PID, or a Frame 
	 * if no address then either current proc or panic
	 */
	if (have_addr) {
		if (trace_proc) {
			p = pfind((int)addr);
			/* Try to be helpful by looking at it as if it were decimal */
			if (p == NULL) {
				u_int	tpid = 0;
				u_int	foo = addr;

				while (foo != 0) {
					int digit = (foo >> 28) & 0xf;
					if (digit > 9) {
						db_printf("  No such process.\n");
						return;
					}
					tpid = tpid * 10 + digit;
					foo = foo << 4;
				}
				p = pfind(tpid);
				if (p == NULL) {
					db_printf("  No such process.\n");
					return;
				}
			}
		} else {
			p = (struct proc *)(addr);
			if (pfind(p->p_pid) != p) {
				db_printf("  This address does not point to a valid process.\n");
				return;
			}
		}
	} else {
		if (trace_proc) {
			p = curproc;
			if (p == NULL) {
				db_printf("trace: no current process! (ignored)\n");
				return;
			}
		} else {
			if (! panicstr) {
				db_printf("Not a panic, no active process, ignored.\n");
				return;
			}
		}
	}
	if (p == NULL) {
		uarea = (struct user *)proc0paddr;
		curpid = 0;
	} else {
		uarea = p->p_addr;
		curpid = p->p_pid;
	}
	db_printf("Process %d\n", curpid);
	db_printf("  PCB contents:\n");
	db_printf("	KSP = 0x%x\n", (unsigned int)(uarea->u_pcb.KSP));
	db_printf("	ESP = 0x%x\n", (unsigned int)(uarea->u_pcb.ESP));
	db_printf("	SSP = 0x%x\n", (unsigned int)(uarea->u_pcb.SSP));
	db_printf("	USP = 0x%x\n", (unsigned int)(uarea->u_pcb.USP));
	db_printf("	R[00] = 0x%08x    R[06] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[0]), (unsigned int)(uarea->u_pcb.R[6]));
	db_printf("	R[01] = 0x%08x    R[07] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[1]), (unsigned int)(uarea->u_pcb.R[7]));
	db_printf("	R[02] = 0x%08x    R[08] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[2]), (unsigned int)(uarea->u_pcb.R[8]));
	db_printf("	R[03] = 0x%08x    R[09] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[3]), (unsigned int)(uarea->u_pcb.R[9]));
	db_printf("	R[04] = 0x%08x    R[10] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[4]), (unsigned int)(uarea->u_pcb.R[10]));
	db_printf("	R[05] = 0x%08x    R[11] = 0x%08x\n", 
		(unsigned int)(uarea->u_pcb.R[5]), (unsigned int)(uarea->u_pcb.R[11]));
	db_printf("	AP = 0x%x\n", (unsigned int)(uarea->u_pcb.AP));
	db_printf("	FP = 0x%x\n", (unsigned int)(uarea->u_pcb.FP));
	db_printf("	PC = 0x%x\n", (unsigned int)(uarea->u_pcb.PC));
	db_printf("	PSL = 0x%x\n", (unsigned int)(uarea->u_pcb.PSL));
	db_printf("	Trap frame pointer: 0x%x\n", 
							(unsigned int)(uarea->u_pcb.framep));
	db_dump_stack((VAX_CALLFRAME *)(uarea->u_pcb.FP), (u_int) uarea->u_pcb.KSP);
	return;
#if 0
	while (((u_int)(cur_frame->vax_fp) > stackbase) && 
			((u_int)(cur_frame->vax_fp) < (stackbase + USPACE))) {
		u_int nargs;
		VAX_CALLFRAME *tmp_frame;

		diff = INT_MAX;
		symname = NULL;
		sym = db_search_symbol(cur_frame->vax_pc, DB_STGY_ANY, &diff);
		db_symbol_values(sym, &symname, 0);
		db_printf("%s+0x%lx(", symname, diff);

		/*
		 * Figure out the arguments by using a bit of subterfuge
		 * since the argument pointer may have been used as a temporary
		 * by the callee ... recreate what it would have pointed to
		 * as follows:
		 *  The vax_regs value has a 12 bit bitmask of the registers
		 *    that were saved on the stack.
		 *	Store that in 'regs' and then for every bit that is
		 *    on (indicates the register contents are on the stack)
		 *    increment the argument base (arg_base) by one.
		 *  When that is done, args[arg_base] points to the longword
		 *    that identifies the number of arguments.
		 *	arg_base+1 - arg_base+n are the argument pointers/contents.
		 */

		/* First get the frame that called this function ... */
		tmp_frame = cur_frame->vax_fp;

		/* Isolate the saved register bits, and count them */
		regs = tmp_frame->vax_regs;
		for (arg_base = 0; regs != 0; regs >>= 1) {
			if (regs & 1)
				arg_base++;
		}

		/* number of arguments is then pointed to by vax_args[arg_base] */
		nargs = tmp_frame->vax_args[arg_base];
		if (nargs) {
			nargs--; /* reduce by one for formatting niceties */
			arg_base++; /* skip past the actual number of arguments */
			while (nargs--)
				db_printf("0x%x,", tmp_frame->vax_args[arg_base++]);

			/* now print out the last arg with closing brace and \n */
			db_printf("0x%x)\n", tmp_frame->vax_args[++arg_base]);
		} else
			db_printf("void)\n");
		/* move to the next frame */
		cur_frame = cur_frame->vax_fp;
	}

	/*
	 * DEAD CODE, previous panic tracing code.
	 */
	if (! have_addr) {
		printf("Trace default\n");
		if (panicstr) {
			cf = (int *)ddb_regs.sp;
		} else {
			printf("Don't know what to do without panic\n");
			return;
		}
		if (p)
			paddr = (u_int)p->p_addr;
		else
			paddr = proc0paddr;

		stackbase = (ddb_regs.psl & PSL_IS ? istack : paddr);
 	}
#endif
a248 1

@


1.7.12.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
#include <uvm/uvm_extern.h>
@


1.7.12.3
log
@Merge in -current from about a week ago
@
text
@d66 1
a66 1
void	kdbprinttrap(int, int);
@


1.7.12.4
log
@Sync the SMP branch with 3.3
@
text
@d240 1
a240 1
db_dump_stack(VAX_CALLFRAME *fp, u_int stackbase, int (*pr)(const char *, ...)) {
d247 1
a247 1
	(*pr)("Stack traceback : \n");
d249 1
a249 1
		(*pr)("  Process is executing in user space.\n");
d260 1
a260 1
		(*pr)("%s+0x%lx(", symname, diff);
d293 1
a293 1
				(*pr)("0x%x,", tmp_frame->vax_args[arg_base++]);
d296 1
a296 1
			(*pr)("0x%x)\n", tmp_frame->vax_args[arg_base]);
d298 1
a298 1
			(*pr)("void)\n");
d313 1
a313 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a317 1
	int		(*pr)(const char *, ...);
d337 1
a337 1
			(*pr)("Not a panic, use trace/t to trace a process.\n");
d340 1
a340 1
		(*pr)("panic: %s\n", panicstr);
d342 1
a342 1
		db_dump_stack((VAX_CALLFRAME *)(ddb_regs.fp), ddb_regs.ap, pr);
d361 1
a361 1
						(*pr)("  No such process.\n");
d369 1
a369 1
					(*pr)("  No such process.\n");
d376 1
a376 1
				(*pr)("  This address does not point to a valid process.\n");
d384 1
a384 1
				(*pr)("trace: no current process! (ignored)\n");
d389 1
a389 1
				(*pr)("Not a panic, no active process, ignored.\n");
d401 7
a407 7
	(*pr)("Process %d\n", curpid);
	(*pr)("  PCB contents:\n");
	(*pr)("	KSP = 0x%x\n", (unsigned int)(uarea->u_pcb.KSP));
	(*pr)("	ESP = 0x%x\n", (unsigned int)(uarea->u_pcb.ESP));
	(*pr)("	SSP = 0x%x\n", (unsigned int)(uarea->u_pcb.SSP));
	(*pr)("	USP = 0x%x\n", (unsigned int)(uarea->u_pcb.USP));
	(*pr)("	R[00] = 0x%08x    R[06] = 0x%08x\n", 
d409 1
a409 1
	(*pr)("	R[01] = 0x%08x    R[07] = 0x%08x\n", 
d411 1
a411 1
	(*pr)("	R[02] = 0x%08x    R[08] = 0x%08x\n", 
d413 1
a413 1
	(*pr)("	R[03] = 0x%08x    R[09] = 0x%08x\n", 
d415 1
a415 1
	(*pr)("	R[04] = 0x%08x    R[10] = 0x%08x\n", 
d417 1
a417 1
	(*pr)("	R[05] = 0x%08x    R[11] = 0x%08x\n", 
d419 5
a423 5
	(*pr)("	AP = 0x%x\n", (unsigned int)(uarea->u_pcb.AP));
	(*pr)("	FP = 0x%x\n", (unsigned int)(uarea->u_pcb.FP));
	(*pr)("	PC = 0x%x\n", (unsigned int)(uarea->u_pcb.PC));
	(*pr)("	PSL = 0x%x\n", (unsigned int)(uarea->u_pcb.PSL));
	(*pr)("	Trap frame pointer: 0x%x\n", 
d425 1
a425 1
	db_dump_stack((VAX_CALLFRAME *)(uarea->u_pcb.FP), (u_int) uarea->u_pcb.KSP, pr);
d437 1
a437 1
		(*pr)("%s+0x%lx(", symname, diff);
d470 1
a470 1
				(*pr)("0x%x,", tmp_frame->vax_args[arg_base++]);
d473 1
a473 1
			(*pr)("0x%x)\n", tmp_frame->vax_args[++arg_base]);
d475 1
a475 1
			(*pr)("void)\n");
@


1.6
log
@RCS tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.8 1996/10/13 03:35:39 christos Exp $	*/
d153 2
a154 2
	register size_t	size;
	register char	*data;
d156 2
a157 1
	register char	*src;
d160 1
a160 1
	while (--size >= 0)
d170 2
a171 2
	register size_t	size;
	register char	*data;
d173 2
a174 1
	register char	*dst;
d177 1
a177 1
	for (;size;size--)
a248 2


@


1.5
log
@Yet more DDB type correctness
@
text
@d1 1
@


1.4
log
@sync with NetBSD 970112 -moj
@
text
@d190 17
a206 17
	{"r0",	&ddb_regs.r0,	FCN_NULL},
	{"r1",	&ddb_regs.r1,	FCN_NULL},
	{"r2",	&ddb_regs.r2,	FCN_NULL},
	{"r3",	&ddb_regs.r3,	FCN_NULL},
	{"r4",	&ddb_regs.r4,	FCN_NULL},
	{"r5",	&ddb_regs.r5,	FCN_NULL},
	{"r6",	&ddb_regs.r6,	FCN_NULL},
	{"r7",	&ddb_regs.r7,	FCN_NULL},
	{"r8",	&ddb_regs.r8,	FCN_NULL},
	{"r9",	&ddb_regs.r9,	FCN_NULL},
	{"r10",	&ddb_regs.r10,	FCN_NULL},
	{"r11",	&ddb_regs.r11,	FCN_NULL},
	{"ap",	&ddb_regs.ap,	FCN_NULL},
	{"fp",	&ddb_regs.fp,	FCN_NULL},
	{"sp",	&ddb_regs.sp,	FCN_NULL},
	{"pc",	&ddb_regs.pc,	FCN_NULL},
	{"psl",	&ddb_regs.psl,	FCN_NULL},
@


1.3
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: db_machdep.c,v 1.6 1996/04/08 18:32:33 ragge Exp $	*/
@


1.2
log
@from ragge;
Handle DDB traps different when we get a panic.
It's more interesting to know the CPU state when panic was called
than in the Debugger() function.
@
text
@d1 1
a1 1
/*	$NetBSD: db_machdep.c,v 1.3 1996/01/28 12:05:55 ragge Exp $	*/
a39 2
#include <ddb/db_variables.h>

d45 1
d48 9
a56 1
#include <setjmp.h>
d58 1
a58 1
extern jmp_buf	*db_recover;
d68 1
a68 1
int
d97 1
a97 1
			return 0;
d125 1
a125 1
	return (1);
d134 1
d152 1
a152 1
	register int	size;
d168 1
a168 1
	register int	size;
d178 1
a178 1
int
d190 17
a206 17
	"r0",	&ddb_regs.r0,	FCN_NULL,
	"r1",	&ddb_regs.r1,	FCN_NULL,
	"r2",	&ddb_regs.r2,	FCN_NULL,
	"r3",	&ddb_regs.r3,	FCN_NULL,
	"r4",	&ddb_regs.r4,	FCN_NULL,
	"r5",	&ddb_regs.r5,	FCN_NULL,
	"r6",	&ddb_regs.r6,	FCN_NULL,
	"r7",	&ddb_regs.r7,	FCN_NULL,
	"r8",	&ddb_regs.r8,	FCN_NULL,
	"r9",	&ddb_regs.r9,	FCN_NULL,
	"r10",	&ddb_regs.r10,	FCN_NULL,
	"r11",	&ddb_regs.r11,	FCN_NULL,
	"ap",	&ddb_regs.ap,	FCN_NULL,
	"fp",	&ddb_regs.fp,	FCN_NULL,
	"sp",	&ddb_regs.sp,	FCN_NULL,
	"pc",	&ddb_regs.pc,	FCN_NULL,
	"psl",	&ddb_regs.psl,	FCN_NULL,
d217 1
a217 1
	printf("db_stack_trace_cmd - addr %x, have_addr %x, count %x, modif %x\n",addr, have_addr, count, modif);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: db_machdep.c,v 1.2 1995/07/05 09:54:09 ragge Exp $	*/
d46 1
d56 4
a59 1
 *  kdb_trap - field a TRACE or BPT trap
a66 5
#if 0
	if ((boothowto&RB_KDB) == 0)
		return(0);
#endif

d71 17
d89 3
a97 1
	bcopy(frame, &ddb_regs, sizeof(struct trapframe));
d99 2
a100 1
	/* XXX Should switch to interrupt stack here. */
d102 1
d114 3
a116 1
	bcopy(&ddb_regs, frame, sizeof(struct trapframe));
d165 1
a165 1
	dst = addr;
a179 1
 * XXX - lost stackpointer.
d196 1
d221 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
