head	1.17;
access;
symbols
	OPENBSD_5_9:1.16.0.28
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.30
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.22
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.26
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.24
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.20
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.18
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.16
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.14
	OPENBSD_5_0:1.16.0.12
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.10
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.8
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.8
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.8
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.6
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.16;
commitid	OSDG2O3Cgeifnf1W;

1.16
date	2008.08.15.22.41.02;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.14.00.53.47;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.11.22.49.52;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.10.21.11.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.16.07.37.44;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.01.20.16.47;	author hugh;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2000.04.27.01.10.11;	author bjc;	state Exp;
branches;
next	1.7;

1.7
date	97.05.29.00.05.15;	author niklas;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.01.15.23.25.08;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.05.03.09.10.08;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.31.05.05.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.05.27.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.01.17.16.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.05.14.21.38.48;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.7.12.5;

1.7.12.5
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;

1.9.6.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: db_disasm.c,v 1.16 2008/08/15 22:41:02 miod Exp $ */
/*	$NetBSD: db_disasm.c,v 1.10 1998/04/13 12:10:27 ragge Exp $ */
/*
 * Copyright (c) 2002, Miodrag Vallat.
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by
 * Bertram Barth.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/param.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>

#include <vax/vax/db_disasm.h>

#ifdef VMS_MODE
#define DEFERRED   "@@"
#define LITERAL	   "#"
#else
#define DEFERRED   "*"
#define LITERAL	   "$"
#endif
/*
 * disassembling vax instructions works as follows:
 *
 * 1.	get first byte as opcode (check for two-byte opcodes!)
 * 2.	lookup in op-table for mnemonic and operand-list
 * 2.a	store the mnemonic
 * 3.	for each operand in list: get the size/type
 * 3.a	evaluate addressing mode for this operand
 * 3.b	store each operand(s)
 * 4.	db_printf the opcode and the (value of the) operands
 * 5.	return the start of the next instruction
 *
 * - if jump/branch calculate (and display) the target-address
 */

/* 
#define BROKEN_DB_REGS
*/
#ifdef	BROKEN_DB_REGS
struct {		/* Due to order and contents of db_regs[], we can't */
	char *name;	/* use this array to extract register-names. */
	void *valuep;	/* eg. "psl" vs "pc", "pc" vs "sp" */
} my_db_regs[16] = {
	{ "r0",		NULL },
	{ "r1",		NULL },
	{ "r2",		NULL },
	{ "r3",		NULL },
	{ "r4",		NULL },
	{ "r5",		NULL },
	{ "r6",		NULL },
	{ "r7",		NULL },
	{ "r8",		NULL },
	{ "r9",		NULL },
	{ "r10",	NULL },
	{ "r11",	NULL },
	{ "ap",		NULL },		/* aka "r12" */
	{ "fp",		NULL },		/* aka "r13" */
	{ "sp",		NULL },		/* aka "r14" */
	{ "pc",		NULL },		/* aka "r15" */
};
#else
#define my_db_regs db_regs
#endif

typedef struct {
	char		dasm[256];	/* disassembled instruction as text */
	char	       *ppc;	/* pseudo PC */
	u_int		opc;	/* op-code */
	char	       *argp;	/* pointer into argument-list */
	int		off;	/* offset specified by last argument */
	int		addr;	/* address specified by last argument */
} inst_buffer;

int get_byte(inst_buffer * ib);
int get_word(inst_buffer * ib);
int get_long(inst_buffer * ib);

int get_opcode(inst_buffer * ib);
int get_operands(inst_buffer * ib);
int get_operand(inst_buffer * ib, int size);

void add_str(inst_buffer * ib, char *s);
void add_int(inst_buffer * ib, int i);
void add_xint(inst_buffer * ib, int i);
void add_sym(inst_buffer * ib, int i);
void add_off(inst_buffer * ib, int i);

#define err_print  printf

/*
 * Disassemble instruction at 'loc'.  'altfmt' specifies an
 * (optional) alternate format (altfmt for vax: don't assume
 * that each external label is a procedure entry mask).
 * Return address of start of next instruction.
 * Since this function is used by 'examine' and by 'step'
 * "next instruction" does NOT mean the next instruction to
 * be executed but the 'linear' next instruction.
 */
db_addr_t
db_disasm(loc, altfmt)
	db_addr_t	loc;
	boolean_t	altfmt;
{
	db_expr_t	diff;
	db_sym_t	sym;
	char	       *symname;

	inst_buffer	ib;

	bzero(&ib, sizeof(ib));
	ib.ppc = (void *)loc;

	if (!altfmt) {		/* ignore potential entry masks in altfmt */
		diff = INT_MAX;
		symname = NULL;
		sym = db_search_symbol(loc, DB_STGY_PROC, &diff);
		db_symbol_values(sym, &symname, 0);

		if (symname && diff == 0) { /* symbol at loc */
			db_printf("function \"%s()\", entry-mask 0x%x\n",
				  symname, (unsigned short) get_word(&ib));
			db_printsym((db_addr_t)ib.ppc, DB_STGY_ANY, db_printf);
			db_printf(":\t");
		}
	}

	get_opcode(&ib);
	get_operands(&ib);
	db_printf("%s\n", ib.dasm);

	return ((u_int) ib.ppc);
}

int
get_opcode(ib)
	inst_buffer    *ib;
{
	ib->opc = get_byte(ib);
	if (ib->opc >= 0xfd) {
		/* two byte op-code */
		ib->opc = ib->opc << 8;
		ib->opc += get_byte(ib);
	}

	if (ib->opc > 0xffff) {
		add_str(ib, "invalid opcode ");
		add_xint(ib, ib->opc);
	} else {
		if (ib->opc > 0xff)
			add_str(ib, vax_inst2[INDEX_OPCODE(ib->opc)].mnemonic);
		else
			add_str(ib, vax_inst[ib->opc].mnemonic);
		add_str(ib, "\t");
	}
	return (ib->opc);
}

int
get_operands(ib)
	inst_buffer    *ib;
{
	int		aa = 0; /* absolute address mode ? */
	int		size;

	if (ib->opc > 0xffff) {
		/* invalid opcode */
		ib->argp = NULL;
		return (-1);
	} else if (ib->opc > 0xff) {
		/* two-byte opcode */
		ib->argp = vax_inst2[INDEX_OPCODE(ib->opc)].argdesc;
	} else
		ib->argp = vax_inst[ib->opc].argdesc;

	if (ib->argp == NULL)
		return (0);

	while (*ib->argp) {
		switch (*ib->argp) {

		case 'b':	/* branch displacement */
			switch (*(++ib->argp)) {
			case 'b':
				ib->off = (signed char) get_byte(ib);
				break;
			case 'w':
				ib->off = (short) get_word(ib);
				break;
			case 'l':
				ib->off = get_long(ib);
				break;
			default:
				err_print("invalid branch-type %X (%c) found.\n",
					  *ib->argp, *ib->argp);
			}
			/* add_int(ib, ib->off); */
			ib->addr = (u_int) ib->ppc + ib->off;
			add_off(ib, ib->addr);
			break;

		case 'a':	/* absolute addressing mode */
			aa = 1;
			/* FALLTHROUGH */

		default:
			switch (*(++ib->argp)) {
			case 'b':	/* Byte */
				size = SIZE_BYTE;
				break;
			case 'w':	/* Word */
				size = SIZE_WORD;
				break;
			case 'l':	/* Long-Word */
			case 'f':	/* F_Floating */
				size = SIZE_LONG;
				break;
			case 'q':	/* Quad-Word */
			case 'd':	/* D_Floating */
			case 'g':	/* G_Floating */
				size = SIZE_QWORD;
				break;
			case 'o':	/* Octa-Word */
			case 'h':	/* H_Floating */
				size = SIZE_OWORD;
				break;
			default:
				err_print("invalid op-type %X (%c) found.\n",
					  *ib->argp, *ib->argp);
				size = 0;
			}
			if (aa) {
				/* get the address */
				ib->addr = get_operand(ib, size);
				add_sym(ib, ib->addr);
			} else {
				/* get the operand */
				ib->addr = get_operand(ib, size);
				add_off(ib, ib->addr);
			}
		}

		if (!*ib->argp || !*++ib->argp)
			break;
		if (*ib->argp++ == ',') {
			add_str(ib, ", ");
		} else {
			err_print("error in opcodes.c\n");
			return (-1);
		}
	}

	return (0);
}

int
get_operand(ib, size)
	inst_buffer    *ib;
	int		size;
{
	int		c = get_byte(ib);
	int		mode = c >> 4;
	int		reg = c & 0x0F;
	int		lit = c & 0x3F;
	int		tmp = 0;
	char		buf[16];

	switch (mode) {
	case 0:		/* literal */
	case 1:		/* literal */
	case 2:		/* literal */
	case 3:		/* literal */
		add_str(ib, LITERAL);
		add_int(ib, lit);
		tmp = lit;
		break;

	case 4:		/* indexed */
		snprintf(buf, sizeof buf, "[%s]", my_db_regs[reg].name);
		get_operand(ib, 0);
		add_str(ib, buf);
		break;

	case 5:		/* register */
		add_str(ib, my_db_regs[reg].name);
		break;

	case 6:		/* register deferred */
		add_str(ib, "(");
		add_str(ib, my_db_regs[reg].name);
		add_str(ib, ")");
		break;

	case 7:		/* autodecrement */
		add_str(ib, "-(");
		add_str(ib, my_db_regs[reg].name);
		add_str(ib, ")");
		if (reg == 0x0F) {	/* pc is not allowed in this mode */
			err_print("autodecrement not allowed for PC.\n");
		}
		break;

	case 9:		/* autoincrement deferred */
		add_str(ib, DEFERRED);
		if (reg == 0x0F) {	/* pc: immediate deferred */
			/*
			 * addresses are always longwords!
			 */
			tmp = get_long(ib);
			add_off(ib, tmp);
			break;
		}
		/* FALLTHROUGH */
	case 8:		/* autoincrement */
		if (reg == 0x0F) {	/* pc: immediate ==> special syntax */
			switch (size) {
			case SIZE_BYTE:
				tmp = (signed char) get_byte(ib);
				break;
			case SIZE_WORD:
				tmp = (signed short) get_word(ib);
				break;
			case SIZE_LONG:
				tmp = get_long(ib);
				break;
			default:
				err_print("illegal op-type %d\n", size);
				tmp = -1;
			}
			if (mode == 8)
				add_str(ib, LITERAL);
			add_int(ib, tmp);
			break;
		}
		add_str(ib, "(");
		add_str(ib, my_db_regs[reg].name);
		add_str(ib, ")+");
		break;

	case 11:	/* byte displacement deferred/ relative deferred  */
		add_str(ib, DEFERRED);
	case 10:	/* byte displacement / relative mode */
		tmp = (signed char) get_byte(ib);
		if (reg == 0x0F) {
			add_off(ib, (u_int) ib->ppc + tmp);
			break;
		}
		/* add_str (ib, "b^"); */
		add_int(ib, tmp);
		add_str(ib, "(");
		add_str(ib, my_db_regs[reg].name);
		add_str(ib, ")");
		break;

	case 13:		/* word displacement deferred */
		add_str(ib, DEFERRED);
	case 12:		/* word displacement */
		tmp = (signed short) get_word(ib);
		if (reg == 0x0F) {
			add_off(ib, (u_int) ib->ppc + tmp);
			break;
		}
		/* add_str (ib, "w^"); */
		add_int(ib, tmp);
		add_str(ib, "(");
		add_str(ib, my_db_regs[reg].name);
		add_str(ib, ")");
		break;

	case 15:		/* long displacement deferred */
		add_str(ib, DEFERRED);
	case 14:		/* long displacement */
		tmp = get_long(ib);
		if (reg == 0x0F) {
			add_off(ib, (u_int) ib->ppc + tmp);
			break;
		}
		/* add_str (ib, "l^"); */
		add_int(ib, tmp);
		add_str(ib, "(");
		add_str(ib, my_db_regs[reg].name);
		add_str(ib, ")");
		break;

	default:
		err_print("can\'t evaluate operand (%02X).\n", lit);
		break;
	}

	return (0);
}

int
get_byte(ib)
	inst_buffer    *ib;
{
	return ((unsigned char) *(ib->ppc++));
}

int
get_word(ib)
	inst_buffer    *ib;
{
	int		tmp;
	char	       *p = (void *) &tmp;

	*p++ = get_byte(ib);
	*p++ = get_byte(ib);
	return (tmp);
}

int
get_long(ib)
	inst_buffer    *ib;
{
	int		tmp;
	char	       *p = (void *) &tmp;

	*p++ = get_byte(ib);
	*p++ = get_byte(ib);
	*p++ = get_byte(ib);
	*p++ = get_byte(ib);
	return (tmp);
}

void
add_str(ib, s)
	inst_buffer    *ib;
	char	       *s;
{

	if (s == NULL)
		s = "-reserved-";

	strlcat(ib->dasm, s, sizeof(ib->dasm));
}

void
add_int(ib, i)
	inst_buffer    *ib;
	int		i;
{
	char		buf[32];

	if (i < 100 && i > -100)
		snprintf(buf, sizeof buf, "%d", i);
	else
		snprintf(buf, sizeof buf, "0x%x", i);
	add_str(ib, buf);
}

void
add_xint(ib, val)
	inst_buffer    *ib;
	int		val;
{
	char		buf[32];

	snprintf(buf, sizeof buf, "0x%x", val);
	add_str(ib, buf);
}

void
add_sym(ib, loc)
	inst_buffer    *ib;
	int		loc;
{
	db_expr_t	diff;
	db_sym_t	sym;
	char	       *symname;

	if (!loc)
		return;

	diff = INT_MAX;
	symname = NULL;
	sym = db_search_symbol(loc, DB_STGY_ANY, &diff);
	db_symbol_values(sym, &symname, 0);

	if (symname && !diff) {
		/* add_str(ib, "<"); */
		add_str(ib, symname);
		/* add_str(ib, ">"); */
	}
	else
		add_xint(ib, loc);
}

void
add_off(ib, loc)
	inst_buffer    *ib;
	int		loc;
{
	db_expr_t	diff;
	db_sym_t	sym;
	char	       *symname;

	if (!loc)
		return;
	  
	diff = INT_MAX;
	symname = NULL;
	sym = db_search_symbol(loc, DB_STGY_ANY, &diff);
	db_symbol_values(sym, &symname, 0);

	if (symname) {
		/* add_str(ib, "<"); */
		add_str(ib, symname);
		if (diff) {
			add_str(ib, "+");
			add_xint(ib, diff);
		}
		/* add_str(ib, ">"); */
	}
	else
		add_xint(ib, loc);
}
@


1.16
log
@Correct disassembly of the start of a function: fix display layout and skip
only the 2 bytes of the procedure entry mask, not 4 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.15 2007/02/14 00:53:47 jsg Exp $ */
@


1.15
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.14 2006/01/11 22:49:52 miod Exp $ */
d149 1
a149 1
	ib.ppc = (void *) loc;
d157 2
a158 2
		if (symname && !diff) { /* symbol at loc */
			db_printf("function \"%s()\", entry-mask 0x%x\n\t\t",
d160 2
a161 1
			ib.ppc += 2;
d164 1
@


1.14
log
@Use bounded string functions while constructing the disassembly lines; plus
this compiles into smaller code!
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.13 2003/11/07 10:16:45 jmc Exp $ */
d348 1
a348 1
		/* fall through */
@


1.13
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.12 2003/05/10 21:11:14 deraadt Exp $ */
d53 2
a54 2
#define DEFERRED   '@@'
#define LITERAL	   '#'
d56 2
a57 2
#define DEFERRED   '*'
#define LITERAL	   '$'
d104 1
a104 2
	char		dasm[256];	/* disassebled instruction as text */
	char	       *curp;	/* pointer into result */
a119 1
void add_char(inst_buffer * ib, int c);
a149 1
	ib.curp = ib.dasm;
d189 1
a189 1
		add_char(ib, '\t');
d281 1
a281 2
			add_char(ib, ',');
			add_char(ib, ' ');
a283 1
			add_char(ib, '\0');
a287 1
	add_char(ib, '\0');
d308 1
a308 1
		add_char(ib, LITERAL);
d324 1
a324 1
		add_char(ib, '(');
d326 1
a326 1
		add_char(ib, ')');
d330 1
a330 2
		add_char(ib, '-');
		add_char(ib, '(');
d332 1
a332 1
		add_char(ib, ')');
d339 1
a339 1
		add_char(ib, DEFERRED);
d366 1
a366 1
				add_char(ib, LITERAL);
d370 1
a370 1
		add_char(ib, '(');
d372 1
a372 2
		add_char(ib, ')');
		add_char(ib, '+');
d376 1
a376 1
		add_char(ib, DEFERRED);
d385 1
a385 1
		add_char(ib, '(');
d387 1
a387 1
		add_char(ib, ')');
d391 1
a391 1
		add_char(ib, DEFERRED);
d400 1
a400 1
		add_char(ib, '(');
d402 1
a402 1
		add_char(ib, ')');
d405 2
a406 2
	case 15:		/* long displacement referred */
		add_char(ib, DEFERRED);
d415 1
a415 1
		add_char(ib, '(');
d417 1
a417 1
		add_char(ib, ')');
a461 8
add_char(ib, c)
	inst_buffer    *ib;
	int		c;
{
	*ib->curp++ = c;
}

void
d470 1
a470 2
	while ((*ib->curp++ = *s++));
	*--ib->curp = '\0';
d516 1
a516 1
		/* add_char(ib, '<'); */
d518 1
a518 1
		/* add_char(ib, '>'); */
d542 1
a542 1
		/* add_char(ib, '<'); */
d545 1
a545 1
			add_char(ib, '+');
d548 1
a548 1
		/* add_char(ib, '>'); */
@


1.12
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.11 2002/05/16 07:37:44 miod Exp $ */
d240 1
a240 1
		case 'a':	/* absolute adressing mode */
@


1.11
log
@Fix a long standing problem on vax: on "arithmetic fault" exceptions,
we schedule a SIGFPE signal delivery to the faulting process.

However, arithmetic faults come in two flavors: "traps" that are "regular"
exceptions, and "faults" that are restartable exceptions.
In the "fault" case, the frame pc points to the faulting instruction, instead
of the next instruction, in case we could save the world by tweaking memory
and make the instruction not fault again when restarted.

In practice, this led to processes blocked in a SIGFPE loop madness.

To avoid this, add a skip_opcode() routine to compute the address of the
next opcode, effectively skipping the offending instruction ; this routine
is a very stripped-down db_disasm().

While there, enhance the ddb disassembler to correctly recognize and
disassemble two-byte opcodes.

ok hugh@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.10 2002/03/14 01:26:48 millert Exp $ */
d320 1
a320 1
		sprintf(buf, "[%s]", my_db_regs[reg].name);
d498 1
a498 1
		sprintf(buf, "%d", i);
d500 1
a500 1
		sprintf(buf, "0x%x", i);
d511 1
a511 1
	sprintf(buf, "0x%x", val);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2001/04/01 20:16:47 hugh Exp $ */
d4 1
d107 1
a107 1
	int		opc;	/* op-code */
a108 2
	int		itype;	/* instruction-type, eg. branch, call, unspec */
	int		atype;	/* argument-type, eg. byte, long, address */
d111 1
a111 6
}	inst_buffer;

#define ITYPE_INVALID  -1
#define ITYPE_UNSPEC	0
#define ITYPE_BRANCH	1
#define ITYPE_CALL	2
d178 2
a179 1
	if (ib->opc >> 2 == 0x3F) {	/* two byte op-code */
d183 3
a185 15
	switch (ib->opc) {
	case 0xFA:		/* CALLG */
	case 0xFB:		/* CALLS */
	case 0xFC:		/* XFC */
		ib->itype = ITYPE_CALL;
		break;
	case 0x16:		/* JSB */
	case 0x17:		/* JMP */
		ib->itype = ITYPE_BRANCH;
		break;
	default:
		ib->itype = ITYPE_UNSPEC;
	}
	if (ib->opc < 0 || ib->opc > 0xFF) {
		add_str(ib, "invalid or two-byte opcode ");
a186 1
		ib->itype = ITYPE_INVALID;
d188 4
a191 1
		add_str(ib, vax_inst[ib->opc].mnemonic);
d204 2
a205 2
	if (ib->opc < 0 || ib->opc > 0xFF) {
		/* invalid or two-byte opcode */
d208 8
a215 2
	}
	ib->argp = vax_inst[ib->opc].argdesc;
d232 2
a233 1
				err_print("XXX eror\n");
d241 2
a242 1
			aa = 1; /* do not break here ! */
d287 1
a287 1
			err_print("XXX error\n");
d449 1
d461 1
d482 4
d496 1
d510 1
d524 1
a524 1
	if (! loc)
@


1.9
log
@spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.8 2000/04/27 01:10:11 bjc Exp $ */
d119 14
a132 14
int get_byte	__P((inst_buffer * ib));
int get_word	__P((inst_buffer * ib));
int get_long	__P((inst_buffer * ib));

int get_opcode	__P((inst_buffer * ib));
int get_operands __P((inst_buffer * ib));
int get_operand __P((inst_buffer * ib, int size));

void add_char	__P((inst_buffer * ib, int c));
void add_str	__P((inst_buffer * ib, char *s));
void add_int	__P((inst_buffer * ib, int i));
void add_xint	__P((inst_buffer * ib, int i));
void add_sym	__P((inst_buffer * ib, int i));
void add_off	__P((inst_buffer * ib, int i));
@


1.9.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2001/04/01 20:16:47 hugh Exp $ */
a3 1
 * Copyright (c) 2002, Miodrag Vallat.
d106 1
a106 1
	u_int		opc;	/* op-code */
d108 2
d112 1
a112 1
} inst_buffer;
d114 19
a132 14
int get_byte(inst_buffer * ib);
int get_word(inst_buffer * ib);
int get_long(inst_buffer * ib);

int get_opcode(inst_buffer * ib);
int get_operands(inst_buffer * ib);
int get_operand(inst_buffer * ib, int size);

void add_char(inst_buffer * ib, int c);
void add_str(inst_buffer * ib, char *s);
void add_int(inst_buffer * ib, int i);
void add_xint(inst_buffer * ib, int i);
void add_sym(inst_buffer * ib, int i);
void add_off(inst_buffer * ib, int i);
d184 1
a184 2
	if (ib->opc >= 0xfd) {
		/* two byte op-code */
d188 15
a202 3

	if (ib->opc > 0xffff) {
		add_str(ib, "invalid opcode ");
d204 1
d206 1
a206 4
		if (ib->opc > 0xff)
			add_str(ib, vax_inst2[INDEX_OPCODE(ib->opc)].mnemonic);
		else
			add_str(ib, vax_inst[ib->opc].mnemonic);
d219 2
a220 2
	if (ib->opc > 0xffff) {
		/* invalid opcode */
d223 2
a224 8
	} else if (ib->opc > 0xff) {
		/* two-byte opcode */
		ib->argp = vax_inst2[INDEX_OPCODE(ib->opc)].argdesc;
	} else
		ib->argp = vax_inst[ib->opc].argdesc;

	if (ib->argp == NULL)
		return (0);
d241 1
a241 2
				err_print("invalid branch-type %X (%c) found.\n",
					  *ib->argp, *ib->argp);
d249 1
a249 2
			aa = 1;
			/* FALLTHROUGH */
d294 1
a294 1
			err_print("error in opcodes.c\n");
a455 1

a466 1

a486 4

	if (s == NULL)
		s = "-reserved-";

a496 1

a509 1

d523 1
a523 1
	if (!loc)
@


1.9.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d320 1
a320 1
		snprintf(buf, sizeof buf, "[%s]", my_db_regs[reg].name);
d498 1
a498 1
		snprintf(buf, sizeof buf, "%d", i);
d500 1
a500 1
		snprintf(buf, sizeof buf, "0x%x", i);
d511 1
a511 1
	snprintf(buf, sizeof buf, "0x%x", val);
@


1.8
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.7 1997/05/29 00:05:15 niklas Exp $ */
d348 1
a348 1
			err_print("autodecrement not allowd for PC.\n");
@


1.7
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: db_disasm.c,v 1.9 1996/10/13 03:35:38 christos Exp $ */
/*	$NetBSD: db_disasm.c,v 1.9 1996/10/13 03:35:38 christos Exp $ */
d41 1
d46 2
d487 1
a487 1
	while (*ib->curp++ = *s++);
@


1.7.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: db_disasm.c,v 1.9 2001/04/01 20:16:47 hugh Exp $ */
/*	$NetBSD: db_disasm.c,v 1.10 1998/04/13 12:10:27 ragge Exp $ */
a40 1
#include <sys/systm.h>
a44 2
#include <ddb/db_interface.h>
#include <ddb/db_output.h>
d345 1
a345 1
			err_print("autodecrement not allowed for PC.\n");
d484 1
a484 1
	while ((*ib->curp++ = *s++));
@


1.7.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d119 14
a132 14
int get_byte(inst_buffer * ib);
int get_word(inst_buffer * ib);
int get_long(inst_buffer * ib);

int get_opcode(inst_buffer * ib);
int get_operands(inst_buffer * ib);
int get_operand(inst_buffer * ib, int size);

void add_char(inst_buffer * ib, int c);
void add_str(inst_buffer * ib, char *s);
void add_int(inst_buffer * ib, int i);
void add_xint(inst_buffer * ib, int i);
void add_sym(inst_buffer * ib, int i);
void add_off(inst_buffer * ib, int i);
@


1.7.12.3
log
@Sync the SMP branch with 3.3
@
text
@a3 1
 * Copyright (c) 2002, Miodrag Vallat.
d106 1
a106 1
	u_int		opc;	/* op-code */
d108 2
d112 6
a117 1
} inst_buffer;
d184 1
a184 2
	if (ib->opc >= 0xfd) {
		/* two byte op-code */
d188 15
a202 3

	if (ib->opc > 0xffff) {
		add_str(ib, "invalid opcode ");
d204 1
d206 1
a206 4
		if (ib->opc > 0xff)
			add_str(ib, vax_inst2[INDEX_OPCODE(ib->opc)].mnemonic);
		else
			add_str(ib, vax_inst[ib->opc].mnemonic);
d219 2
a220 2
	if (ib->opc > 0xffff) {
		/* invalid opcode */
d223 2
a224 8
	} else if (ib->opc > 0xff) {
		/* two-byte opcode */
		ib->argp = vax_inst2[INDEX_OPCODE(ib->opc)].argdesc;
	} else
		ib->argp = vax_inst[ib->opc].argdesc;

	if (ib->argp == NULL)
		return (0);
d241 1
a241 2
				err_print("invalid branch-type %X (%c) found.\n",
					  *ib->argp, *ib->argp);
d249 1
a249 2
			aa = 1;
			/* FALLTHROUGH */
d294 1
a294 1
			err_print("error in opcodes.c\n");
a455 1

a466 1

a486 4

	if (s == NULL)
		s = "-reserved-";

a496 1

a509 1

d523 1
a523 1
	if (!loc)
@


1.7.12.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.7.12.3 2003/03/27 23:52:20 niklas Exp $ */
d320 1
a320 1
		snprintf(buf, sizeof buf, "[%s]", my_db_regs[reg].name);
d498 1
a498 1
		snprintf(buf, sizeof buf, "%d", i);
d500 1
a500 1
		snprintf(buf, sizeof buf, "0x%x", i);
d511 1
a511 1
	snprintf(buf, sizeof buf, "0x%x", val);
@


1.7.12.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d240 1
a240 1
		case 'a':	/* absolute addressing mode */
@


1.6
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.5
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: db_disasm.c,v 1.6 1996/04/08 18:32:32 ragge Exp $ */
d19 2
a20 2
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
a37 1
#include <sys/systm.h>
a42 2
#include <ddb/db_output.h>
#include <ddb/db_interface.h>
d49 1
a49 1
#define LITERAL    '#'
d52 1
a52 1
#define LITERAL    '$'
d57 8
a64 6
 * - get first byte as opcode (check for two-byte opcodes!)
 * - evaluate (variable length) argument list
 * - for each argument get type (byte, long, address etc.)
 * - evaluate addressing mode for this argument
 * - db_printf the opcode and the (value of the) arguments
 * - return the start of the next instruction
d72 4
a75 4
#ifdef  BROKEN_DB_REGS
struct {                /* Due to order and contents of db_regs[], we can't */
        char *name;     /* use this array to extract register-names. */
        void *valuep;   /* eg. "psl" vs "pc", "pc" vs "sp" */
d77 16
a92 16
        { "r0",         NULL },
        { "r1",         NULL },
        { "r2",         NULL },
        { "r3",         NULL },
        { "r4",         NULL },
        { "r5",         NULL },
        { "r6",         NULL },
        { "r7",         NULL },
        { "r8",         NULL },
        { "r9",         NULL },
        { "r10",        NULL },
        { "r11",        NULL },
        { "ap",         NULL },         /* aka "r12" */
        { "fp",         NULL },         /* aka "r13" */
        { "sp",         NULL },         /* aka "r14" */
        { "pc",         NULL },         /* aka "r15" */
d99 10
a108 10
	char            dasm[256];	/* disassebled instruction as text */
	char           *curp;	/* pointer into result */
	char           *ppc;	/* pseudo PC */
	int             opc;	/* op-code */
	char           *argp;	/* pointer into argument-list */
	int             itype;	/* instruction-type, eg. branch, call, unspec */
	int             atype;	/* argument-type, eg. byte, long, address */
	int             off;	/* offset specified by last argument */
	int             addr;	/* address specified by last argument */
}       inst_buffer;
d111 7
a117 7
#define ITYPE_UNSPEC    0
#define ITYPE_BRANCH    1
#define ITYPE_CALL      2

int get_byte    __P((inst_buffer * ib));
int get_word    __P((inst_buffer * ib));
int get_long    __P((inst_buffer * ib));
d119 1
a119 1
int get_opcode  __P((inst_buffer * ib));
d123 6
a128 6
void add_char   __P((inst_buffer * ib, int c));
void add_str    __P((inst_buffer * ib, char *s));
void add_int    __P((inst_buffer * ib, int i));
void add_xint   __P((inst_buffer * ib, int i));
void add_sym    __P((inst_buffer * ib, int i));
void add_off    __P((inst_buffer * ib, int i));
d143 2
a144 2
	db_addr_t       loc;
	boolean_t       altfmt;
d146 3
a148 3
	db_expr_t       diff;
	db_sym_t        sym;
	char           *symname;
d150 1
a150 1
	inst_buffer     ib;
d162 1
a162 1
		if (symname && !diff) {	/* symbol at loc */
d212 2
a213 2
	int             aa = 0;	/* absolute address mode ? */
	int             size;
d245 1
a245 1
			aa = 1;	/* do not break here ! */
d303 1
a303 1
	int             size;
d305 6
a310 6
	int             c = get_byte(ib);
	int             mode = c >> 4;
	int             reg = c & 0x0F;
	int             lit = c & 0x3F;
	int             tmp = 0;
	char            buf[16];
d350 9
d450 2
a451 2
	int             tmp;
	char           *p = (void *) &tmp;
d461 2
a462 2
	int             tmp;
	char           *p = (void *) &tmp;
d473 1
a473 1
	int             c;
d481 1
a481 1
	char           *s;
d483 1
a483 1
	while ((*ib->curp++ = *s++));
d490 1
a490 1
	int             i;
d492 1
a492 1
	char            buf[32];
d503 1
a503 1
	int             val;
d505 1
a505 1
	char            buf[32];
d513 1
a513 1
	int             loc;
d515 3
a517 3
	db_expr_t       diff;
	db_sym_t        sym;
	char           *symname;
d539 1
a539 1
	int             loc;
d541 3
a543 3
	db_expr_t       diff;
	db_sym_t        sym;
	char           *symname;
@


1.4
log
@from ragge;
DDB disassembly is fixed and now works good. Code written and
contributed to Ludd by Bertram Barth.
@
text
@d1 1
a1 1
/*	$NetBSD: db_disasm.c,v 1.3 1996/01/28 11:31:25 ragge Exp $ */
d38 1
a41 1
#include <ddb/db_variables.h>
d44 3
d48 1
a48 1
#include "vax/vax/db_disasm.h"
d475 1
a475 1
	while (*ib->curp++ = *s++);
@


1.3
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: db_disasm.c,v 1.2 1995/11/30 00:59:34 jtc Exp $ */
d3 1
a3 1
 * Copyright (c) 1995 Ludd, University of Lule}, Sweden.
d6 3
a41 1

d43 1
d45 1
d47 19
d67 24
a90 276
struct vax_insn {
	char	*insn;
	int 	nargs;
} instr[] = {
	"halt",	0,
	"nop",	0,
	"rei",	0,
	"bpt",	0,
	"ret",	0,
	"rsb",	0,
	"ldpctx",	0,
	"svpctx",	0,
	"cvtps",	4,
	"cvtsp",	4,
	"index",	6,
	"crc",	4,
	"prober",	3,
	"probew",	3,
	"insque",	2,
	"remque",	2,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
	"",	-1,
d92 35
d128 1
d132 6
a137 2
 * (optional) alternate format.  Return address of start of
 * next instruction.
d141 2
a142 2
        db_addr_t       loc;
        boolean_t       altfmt;
d144 25
a168 2
	char *i_pl;
	int inr, i;
d170 2
a171 2
	i_pl = (char *)loc;
	inr = *i_pl;
d173 26
a198 3
	if (instr[*i_pl].nargs < 0) {
		printf("Ok{nd instruktion: %2x",*i_pl&0xff);
		i_pl++;
d200 17
a216 7
		printf("\t%s\t",instr[inr].insn);
		i_pl++;
		for (i=0;i<instr[inr].nargs;i++) {
			i_pl = (char *)argprint(i_pl);
			if (i<instr[inr].nargs-1)
				printf(",");
		}
d218 4
d223 58
d282 11
d294 2
a295 1
        return (int)i_pl;
d298 4
a301 2
argprint(plats)
	char *plats;
d303 109
a411 14
	switch (*plats&0xf0) {
	case 0x00:
	case 0x10:
	case 0x20:
	case 0x30:
		printf("$%x",*plats++);
		break;
		
	case 0xe0:
		if (*plats++&15 == 15) {
			printf("%8x",*(unsigned *)plats + plats);
			plats += 4;
		} else {
			printf("Oinpl. s{tt.");
d413 5
d419 1
d421 129
a549 1
		printf("Oinpl. s{tt.");
d551 2
a552 1
	return (int)plats;
@


1.2
log
@Copyright stuff
@
text
@d1 1
a1 1
/*	$NetBSD: db_disasm.c,v 1.1.2.1 1995/10/28 15:30:22 ragge Exp $ */
@


1.1
log
@Initial revision
@
text
@d1 33
d336 1
a336 1
	i_pl = loc;
d346 1
a346 1
			i_pl = argprint(i_pl);
d354 1
a354 1
        return i_pl;
d379 1
a379 1
	return plats;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
