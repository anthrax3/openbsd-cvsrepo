head	1.11;
access;
symbols
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.8
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2006.07.19.20.22.37;	author miod;	state dead;
branches;
next	1.10;

1.10
date	2005.11.06.22.21.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.12.01.07.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.12.01.07.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.05.21.26.42;	author art;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.12.08;	author millert;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.09.10.12.04.52;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.00.05.27;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.25.24;	author maja;	state Exp;
branches;
next	;

1.4.6.1
date	2001.07.04.10.24.48;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Remove long dead meat and irrelevant defines. No functional change.
@
text
@/*	$OpenBSD: uvax.c,v 1.10 2005/11/06 22:21:33 miod Exp $ */
/*	$NetBSD: uvax.c,v 1.4 1997/02/19 10:04:27 ragge Exp $ */
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * Copyright (c) 1982, 1988, 1990, 1993
 * 	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * generic(?) MicroVAX and VAXstation support
 *
 * There are similarities to struct cpu_calls[] in autoconf.c
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/device.h>
#include <uvm/uvm_extern.h>

#include <machine/pte.h>
#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/pmap.h>
#include <machine/nexus.h>
#include <machine/uvax.h>
#include <machine/cpu.h>

/*
 * NB: mapping should/must be done in chunks of PAGE_SIZE (ie. 1024), 
 *     while pmap_map() expects size to be in chunks of NBPG (ie. 512).
 * 
 * Thus we round down the start-address to be aligned wrt PAGE_SIZE and
 * the end-address up to be just beyond the next multiple of PAGE_SIZE.
 * size is the number of bytes between start and end expressed in NBPG.
 */
void 
uvax_fillmap()
{
	extern  vaddr_t avail_start, virtual_avail, avail_end;
	register struct uc_map *p;
	register u_int base, end, off, size;

	for (p = dep_call->cpu_map; p->um_base != 0; p++) {
		base = TRUNC_PAGE(p->um_base);		/* round base down */
		off = p->um_base - base;
		size = ROUND_PAGE(off + p->um_size);
		if (size < PAGE_SIZE) {
			printf("invalid size %d in uVAX_fillmap\n", size);
			size = PAGE_SIZE;
		}
		end = base + size - 1;
		MAPVIRT(p->um_virt, size/NBPG);
		pmap_map((vaddr_t)p->um_virt, base, end, 
		    VM_PROT_READ|VM_PROT_WRITE);

	}
}

u_long
uvax_phys2virt(phys)
	u_long phys;
{
	register struct uc_map *p;
	u_long virt = 0;

	for (p = dep_call->cpu_map; p->um_base != 0; p++) {
		if (p->um_base > phys || p->um_end < phys)
			continue;
		virt = p->um_virt + (phys - trunc_page((vaddr_t)p->um_base));
		break;
	}

#ifdef DIAGNOSTIC
	if (virt == 0)
		panic("invalid argument %p to uvax_phys2virt()", phys);
#endif
	return (virt);
}
@


1.10
log
@Kill deprecated vm_offset_t and vm_size_t types on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.9 2003/06/12 01:07:31 deraadt Exp $ */
@


1.9
log
@final bits of obvious UCB term 3 removal
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.8 2003/06/12 01:07:27 deraadt Exp $ */
d61 1
a61 1
	extern  vm_offset_t avail_start, virtual_avail, avail_end;
d75 1
a75 1
		pmap_map((vm_offset_t)p->um_virt, base, end, 
@


1.8
log
@final bits of obvious UCB term 3 removal
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.7 2001/11/06 19:53:17 miod Exp $ */
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.6 2001/09/11 20:05:25 miod Exp $ */
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
@


1.6
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.5 2001/05/05 21:26:42 art Exp $ */
d44 1
a44 1
#include <vm/vm.h>
@


1.5
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.4 1999/01/11 05:12:08 millert Exp $ */
a44 1
#include <vm/vm_kern.h>
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.3 1997/09/10 12:04:52 maja Exp $ */
d96 1
a96 1
		virt = p->um_virt + (phys - trunc_page(p->um_base));
@


1.4.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.4 1999/01/11 05:12:08 millert Exp $ */
d96 1
a96 1
		virt = p->um_virt + (phys - trunc_page((vaddr_t)p->um_base));
@


1.4.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.4.6.1 2001/07/04 10:24:48 niklas Exp $ */
d45 1
@


1.4.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d44 1
a44 1
#include <uvm/uvm_extern.h>
@


1.4.6.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d16 5
a20 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.3
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: uvax.c,v 1.2 1997/05/29 00:05:27 niklas Exp $ */
d102 1
a102 1
		panic("invalid argument %p to uvax_phys2virt()\n", phys);
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: uvax.c,v 1.3 1996/10/13 03:36:03 christos Exp $ */
/*	$NetBSD: uvax.c,v 1.3 1996/10/13 03:36:03 christos Exp $ */
d5 2
a6 3
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by Bertram Barth.
d18 2
a19 2
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
d53 1
a53 145

#define xtrace(x)
#define xdebug(x)


struct uvax_calls guc;			/* Generic uVAX Calls */
/* struct uvax_calls *ucp = &guc;	/* not yet public !!! */
static int uvax_callsSetup = 0;		/* not yet setup */

u_long	uVAX_phys2virt __P((u_long, struct uc_map *));

/* u_long	uVAX_physmap;	/* XXX  another ugly hack... */
int 
uvax_notavail(s)
	char *s;
{
	printf("\"%s()\" not available for uVAX (%s)\n", s, guc.uc_name);
	/*
	 * should we panic() here???
	 */
	return(0);
}

int
uvax_setup(flags)
	int flags;
{
	/*
	 * insert some defaults here !!!
	 */

	/*
	 * Now call the specific routines to overwrite these defaults
	 */
	switch (vax_boardtype) {
#ifdef VAX630
	case VAX_BTYP_630:
		ka630_setup(&guc, flags);
		break;
#endif
#ifdef VAX410
	case VAX_BTYP_410:
		ka410_setup(&guc, flags);
		break;
#endif
#ifdef VAX43
	case VAX_BTYP_43:
		ka43_setup(&guc, flags);
		break;
#endif
	default:
		printf("don't know how to handle 0x%x\n", vax_boardtype);
		printf("Let's try using the defaults...\n");
	}
	uvax_callsSetup = 1;
}

/*
 * XXX_steal_pages() is the first cpu/board specific function to be called.
 * Thus we use this call to setup the dispatch structure for further use.
 *
 * We should have a special setup-routine !!!
 */
void
uvax_steal_pages()
{
	if (uvax_callsSetup == 0)
		uvax_setup(0);

	/*
	 * now that specific functions are inserted, we can call 'em
	 */
	if (guc.uc_steal_pages) {
		(guc.uc_steal_pages)(); 
		return;
	}
	uvax_notavail("uc_steal_pages");
}

u_long	
uvax_phys2virt(paddr)
	u_long paddr;
{
	if (guc.uc_phys2virt)
		return ((guc.uc_phys2virt)(paddr));
	if (guc.uc_physmap)
		return (uVAX_phys2virt(paddr, guc.uc_physmap));
	uvax_notavail("uc_phys2virt");
	return (0);
}

void
uvax_conf(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
{
	if (guc.uc_conf) {
		(guc.uc_conf)(parent, self, aux);
		return;
	}
	uvax_notavail("uc_conf");
}

void
uvax_memerr()
{
	xtrace(("uvax_memerr()\n"));

	if (guc.uc_memerr) {
		(guc.uc_memerr)(); 
		return;
	}
	uvax_notavail("uc_memerr");
}

int
uvax_mchk(addr)
	caddr_t addr;
{
	xtrace(("uvax_mchk(0x%x)\n", addr));

	if (guc.uc_mchk)
		return ((guc.uc_mchk)(addr));
	uvax_notavail("uc_mchk");
	return (-1);
}

int
uvax_clkread(base)
	time_t base;
{
	if (guc.uc_clkread)
		return ((guc.uc_clkread)(base));
	uvax_notavail("uc_clkread");
}

void
uvax_clkwrite()
{
	if (guc.uc_clkwrite)
		(guc.uc_clkwrite)();
	else
		uvax_notavail("uc_clkwrite");
	return;
}
d63 2
a64 34
int 
uVAX_old_fillmap(um)
	struct uc_map *um;
{
	extern  vm_offset_t avail_start, virtual_avail, avail_end;
	register struct uc_map *p;
	register u_int base, end, size;

	for (p = um; p->um_base != 0; p++) {
		base = p->um_base & ~PAGE_SIZE;		/* round base down */
		end = ROUND_PAGE(p->um_end + 1) - 1;	/* round end up */
		size = (end - base + 1) / NBPG;		/* size in pages */
		MAPVIRT(p->um_virt, size);
		pmap_map((vm_offset_t)p->um_virt, base, end, 
			 VM_PROT_READ|VM_PROT_WRITE);

		xdebug(("uVAX_fillmap: %x:%x[%x] (%x:%x[%x]) --> %x\n", 
			p->um_base, p->um_end, p->um_size, 
			base, end, size, p->um_virt));

	}
}

/*
 * NB: mapping should/must be done in chunks of PAGE_SIZE (ie. 1024), 
 *     while pmap_map() expects size to be in chunks of NBPG (ie. 512).
 * 
 * Thus we round down the start-address to be aligned wrt PAGE_SIZE and
 * the end-address up to be just beyond the next multiple of PAGE_SIZE.
 * size is the number of bytes between start and end expressed in NBPG.
 */
int 
uVAX_fillmap(um)
	struct uc_map *um;
d70 1
a70 1
	for (p = um; p->um_base != 0; p++) {
d81 1
a81 5
			 VM_PROT_READ|VM_PROT_WRITE);

		xdebug(("uVAX_fillmap: %x:%x[%x] (%x:%x[%x]) --> %x\n", 
			p->um_base, p->um_end, p->um_size, 
			base, end, size, p->um_virt));
d87 1
a87 1
uVAX_phys2virt(phys,um)
a88 1
	struct uc_map *um;
d93 1
a93 1
	for (p = um; p->um_base != 0; p++) {
d100 4
a103 5
	if (virt == 0) {
		printf("invalid argument 0x%x to uvax_phys2virt()\n", phys);
		/* should we panic() here ??? */
	}

@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
