head	1.41;
access;
symbols
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.36.0.6
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.8
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.6
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.4
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.32.0.8
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.6
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.14
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.12
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.10
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.8
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.6
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.19
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.12
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.10
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.40;
commitid	OSDG2O3Cgeifnf1W;

1.40
date	2015.07.04.10.27.05;	author dlg;	state Exp;
branches;
next	1.39;
commitid	p2UGwwDorFF21Uzt;

1.39
date	2015.02.01.15.27.12;	author miod;	state Exp;
branches;
next	1.38;
commitid	vfuvVKDlohAznQIf;

1.38
date	2014.10.31.10.54.39;	author jsg;	state Exp;
branches;
next	1.37;
commitid	1Mi9nj0WIvfszUVI;

1.37
date	2014.05.17.12.08.37;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.21.21.55.09;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2011.07.10.17.31.40;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.06.20.42.05;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.20.18.39.30;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.18.23.19.29;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.01.17.10.00;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.25.14.50.38;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.23.19.23.09;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.20.19.15.35;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.20.19.08.15;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.27.18.31.11;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.17.02.37.20;	author hugh;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.11.09.36.24;	author hugh;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.04.23.47.33;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.06.25.00.43.19;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.15.22.45.33;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.05.22.34.28;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.11.06.34.37;	author hugh;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.27.01.10.11;	author bjc;	state Exp;
branches;
next	1.9;

1.9
date	97.10.02.19.54.14;	author niklas;	state Exp;
branches
	1.9.12.1;
next	1.8;

1.8
date	97.09.10.12.04.42;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.05.29.00.05.12;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.25.04;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.46.27;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.06.12.08.20.35;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.10.04;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.14.00.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.09;	author deraadt;	state Exp;
branches;
next	;

1.9.12.1
date	2001.05.14.21.38.41;	author niklas;	state Exp;
branches;
next	1.9.12.2;

1.9.12.2
date	2001.07.04.10.24.32;	author niklas;	state Exp;
branches;
next	1.9.12.3;

1.9.12.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.9.12.4;

1.9.12.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.9.12.5;

1.9.12.5
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	;


desc
@@


1.41
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: autoconf.c,v 1.40 2015/07/04 10:27:05 dlg Exp $	*/
/*	$NetBSD: autoconf.c,v 1.45 1999/10/23 14:56:05 ragge Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/buf.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/sid.h>
#include <machine/vmparam.h>
#include <machine/nexus.h>
#include <machine/clock.h>
#include <machine/rpb.h>
#ifdef VAX60
#include <vax/mbus/mbusreg.h>
#endif

#include <dev/cons.h>

#include "led.h"

#include <vax/vax/gencons.h>

void	dumpconf(void);	/* machdep.c */

struct cpu_dep *dep_call;

int	mastercpu;	/* chief of the system */

struct device *bootdv;
int booted_partition;	/* defaults to 0 (aka 'a' partition) */

void
cpu_configure(void)
{
	softintr_init();

	if (config_rootfound("mainbus", NULL) == NULL)
		panic("mainbus not configured");

	/*
	 * We're ready to start up. Clear CPU cold start flag.
	 */
	cold = 0;

	if (dep_call->cpu_clrf) 
		(*dep_call->cpu_clrf)();
}

void
diskconf(void)
{
	if (bootdv == NULL)
		printf("boot device: unknown (rpb %d/%d)\n",
		    rpb.devtyp, rpb.unit);
	else
		printf("boot device: %s\n", bootdv->dv_xname);

	setroot(bootdv, booted_partition, RB_USERREQ);
	dumpconf();
}

int	mainbus_print(void *, const char *);
int	mainbus_match(struct device *, struct cfdata *, void *);
void	mainbus_attach(struct device *, struct device *, void *);

int
mainbus_print(void *aux, const char *hej)
{
	struct mainbus_attach_args *maa = aux;

	if (maa->maa_bustype == VAX_LEDS)
		return (QUIET);

	if (hej) {
		printf("nothing at %s", hej);
	}
	return (UNCONF);
}

int
mainbus_match(struct device *parent, struct cfdata *cf, void *aux)
{
	if (cf->cf_unit == 0 &&
	    strcmp(cf->cf_driver->cd_name, "mainbus") == 0)
		return 1; /* First (and only) mainbus */

	return (0);
}

void
mainbus_attach(struct device *parent, struct device *self, void *hej)
{
	struct mainbus_attach_args maa;

	printf("\n");

	maa.maa_bustype = vax_bustype;
	config_found(self, &maa, mainbus_print);

#if VAX53
	/* These models have both vsbus and ibus */
	if (vax_boardtype == VAX_BTYP_1303) {
		maa.maa_bustype = VAX_VSBUS;
		config_found(self, &maa, mainbus_print);
	}
#endif

#if NLED > 0
	maa.maa_bustype = VAX_LEDS;
	config_found(self, &maa, mainbus_print);
#endif

#if 1 /* boot blocks too old */
        if (rpb.rpb_base == (void *)-1)
                printf("\nWARNING: you must update your boot blocks.\n\n");
#endif

}

struct	cfattach mainbus_ca = {
	sizeof(struct device), (cfmatch_t) mainbus_match, mainbus_attach
};

struct  cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

#include "sd.h"
#include "cd.h"
#include "ra.h"

static int ubtest(void *);
static int jmfr(char *, struct device *, int);
static int booted_qe(struct device *, void *);
static int booted_le(struct device *, void *);
static int booted_ze(struct device *, void *);
static int booted_de(struct device *, void *);
#if NSD > 0 || NCD > 0
static int booted_sd(struct device *, void *);
#endif
#if NRA
static int booted_ra(struct device *, void *);
#endif
#if NRD
static int booted_rd(struct device *, void *);
#endif

int (*devreg[])(struct device *, void *) = {
	booted_qe,
	booted_le,
	booted_ze,
	booted_de,
#if NSD > 0 || NCD > 0
	booted_sd,
#endif
#if NRA
	booted_ra,
#endif
#if NRD
	booted_hd,
#endif
	0,
};

void
device_register(struct device *dev, void *aux)
{
	int (**dp)(struct device *, void *) = devreg;

	/* If there's a synthetic RPB, we can't trust it */
	if (rpb.rpb_base == (void *)-1)
		return;

	while (*dp) {
		if ((*dp)(dev, aux)) {
			if (bootdv == NULL)
				bootdv = dev;
			break;
		}
		dp++;
	}
}

/*
 * Simple checks. Return 1 on fail.
 */
int
jmfr(char *n, struct device *dev, int nr)
{
	if (rpb.devtyp != nr)
		return 1;
	return strcmp(n, dev->dv_cfdata->cf_driver->cd_name);
}

#include <arch/vax/qbus/ubavar.h>
int
ubtest(void *aux)
{
	paddr_t p;

	p = kvtophys(((struct uba_attach_args *)aux)->ua_ioh);
	if (rpb.csrphy != p)
		return 1;
	return 0;
}

#if 1 /* NDE */
int
booted_de(struct device *dev, void *aux)
{

	if (jmfr("de", dev, BDEV_DE) || ubtest(aux))
		return 0;

	return 1;
}
#endif /* NDE */

int
booted_le(struct device *dev, void *aux)
{
	if (jmfr("le", dev, BDEV_LE))
		return 0;
	return 1;
}

int
booted_ze(struct device *dev, void *aux)
{
	if (jmfr("ze", dev, BDEV_ZE))
		return 0;
	return 1;
}

#if 1 /* NQE */
int
booted_qe(struct device *dev, void *aux)
{
	if (jmfr("qe", dev, BDEV_QE) || ubtest(aux))
		return 0;

	return 1;
}
#endif /* NQE */

#if NSD > 0 || NCD > 0
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
int
booted_sd(struct device *dev, void *aux)
{
	struct scsi_attach_args *sa = aux;
	struct device *ppdev;

	/* Is this a SCSI device? */
	if (jmfr("sd", dev, BDEV_SD) && jmfr("cd", dev, BDEV_SD) &&
	    jmfr("sd", dev, BDEV_SDN) && jmfr("cd", dev, BDEV_SDN) &&
	    jmfr("sd", dev, BDEV_SDS) && jmfr("cd", dev, BDEV_SDS))
		return 0;

	if (sa->sa_sc_link->target != rpb.unit)
		return 0; /* Wrong unit */

	ppdev = dev->dv_parent->dv_parent;

	/* VS3100 NCR 53C80 (si) & VS4000 NCR 53C94 (asc) */
	if (((jmfr("ncr", ppdev, BDEV_SD) == 0) ||	/* old name */
	    (jmfr("asc", ppdev, BDEV_SD) == 0) ||
	    (jmfr("asc", ppdev, BDEV_SDN) == 0)) &&
	    (ppdev->dv_cfdata->cf_loc[0] == rpb.csrphy))
			return 1;

#ifdef VAX60
	/* VS35x0 (sii) */
	if (jmfr("sii", ppdev, BDEV_SDS) == 0 && rpb.csrphy ==
	    MBUS_SLOT_BASE(ppdev->dv_parent->dv_cfdata->cf_loc[0]))
		return 1;
#endif

	return 0; /* Where did we come from??? */
}
#endif

#if NRA
#include <arch/vax/mscp/mscp.h>
#include <arch/vax/mscp/mscpreg.h>
#include <arch/vax/mscp/mscpvar.h>
int
booted_ra(struct device *dev, void *aux)
{
	struct drive_attach_args *da = aux;
	struct mscp_softc *pdev = (void *)dev->dv_parent;
	paddr_t ioaddr;

	if (jmfr("ra", dev, BDEV_UDA))
		return 0;

	if (da->da_mp->mscp_unit != rpb.unit)
		return 0; /* Wrong unit number */

	ioaddr = kvtophys(pdev->mi_iph); /* Get phys addr of CSR */
	if (rpb.devtyp == BDEV_UDA && rpb.csrphy == ioaddr)
		return 1; /* Did match CSR */

	return 0;
}
#endif
#if NHD
int     
booted_hd(struct device *dev, void *aux)
{
	int *nr = aux; /* XXX - use the correct attach struct */

	if (jmfr("hd", dev, BDEV_RD))
		return 0;

	if (*nr != rpb.unit)
		return 0;

	return 1;
}
#endif

struct nam2blk nam2blk[] = {
	{ "ra",          9 },
	{ "rx",         12 },
	{ "hd",		19 },
	{ "sd",         20 },
	{ "cd",         22 },
	{ "rd",         23 },
	{ "raid",       25 },
	{ "vnd",	18 },
	{ NULL,		-1 }
};
@


1.40
log
@replace the manual buf list management with a fifo bufq. it simplifies
the code in some cases and makes it generally more readable.

this has been tested in simh, real hardware may or may not work anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2015/02/01 15:27:12 miod Exp $	*/
@


1.39
log
@Gather the scattered (and sometimes duplicated) qbus address and size defines
to a single place. Get rid of the unused defines pertaining to older vax
models we dropped support for years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2014/10/31 10:54:39 jsg Exp $	*/
d43 1
@


1.38
log
@The config logic with "rl needs-flag" got
removed back in 2011.  Remove code under #if NRL > 0.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2014/05/17 12:08:37 miod Exp $	*/
a202 2

#define	ubreg(x) ((x) & 017777)
@


1.37
log
@Print the rpb device type and unit values if the root device can't be found
by the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2013/03/21 21:55:09 deraadt Exp $	*/
a179 3
#if NRL > 0
static int booted_rl(struct device *, void *);
#endif
a194 3
#if NRL > 0
	booted_rl,
#endif
a321 19
}
#endif
#if NRL > 0
#include <dev/qbus/rlvar.h>
int
booted_rl(struct device *dev, void *aux)
{
	struct rlc_attach_args *raa = aux;
	static int ub;

	if (jmfr("rlc", dev, BDEV_RL) == 0)
		ub = ubtest(aux);
	if (ub)
		return 0;
	if (jmfr("rl", dev, BDEV_RL))
		return 0;
	if (raa->hwid != rpb.unit)
		return 0; /* Wrong unit number */
	return 1;
@


1.36
log
@Already have sys/param.h, don't need machine/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2011/07/10 17:31:40 deraadt Exp $	*/
d91 5
a95 2
	printf("boot device: %s\n",
	    bootdv ? bootdv->dv_xname : "<unknown>");
@


1.35
log
@Move the vax/boot code to vax/stand.  A cvs 'mv' with de-tagging has been
done behind the scenes to retain history.  Having all the bootblocks in the
same architecture sub-directory satisfies several principles.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2011/07/06 20:42:05 miod Exp $	*/
a47 1
#include <machine/param.h>
@


1.34
log
@Drop cpu_dep.cpu_subconf routine, which is no longer used after KA820 support
removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2011/07/06 18:32:59 miod Exp $	*/
d73 1
a73 1
cpu_configure()
d104 1
a104 3
mainbus_print(aux, hej)
	void *aux;
	const char *hej;
d118 1
a118 4
mainbus_match(parent, cf, aux)
	struct	device	*parent;
	struct cfdata *cf;
	void	*aux;
d128 1
a128 3
mainbus_attach(parent, self, hej)
	struct	device	*parent, *self;
	void	*hej;
@


1.33
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2009/03/20 18:39:30 miod Exp $	*/
a150 3

	if (dep_call->cpu_subconf)
		(*dep_call->cpu_subconf)(self);
@


1.32
log
@Switch vax to __HAVE_GENERIC_SOFT_INTERRUPTS.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2008/08/18 23:19:29 miod Exp $	*/
a50 3
#include <machine/ioa.h>
#include <machine/ka820.h>
#include <machine/ka750.h>
a62 2
#include <vax/bi/bireg.h>

a176 3
#if NRL > 0
#include "rl.h"
#endif
a177 4
#include "hp.h"
#if NRY > 0
#include "ry.h"
#endif
a184 1
static int booted_ni(struct device *, void *);
a193 3
#if NHP
static int booted_hp(struct device *, void *);
#endif
a202 1
	booted_ni,
a211 3
#if NHP
	booted_hp,
#endif
a261 14
#if 1 /* NNI */
#include <arch/vax/bi/bivar.h>
int
booted_ni(struct device *dev, void *aux)
{
	struct bi_attach_args *ba = aux;

	if (jmfr("ni", dev, BDEV_NI) || (kvtophys(ba->ba_ioh) != rpb.csrphy))
		return 0;

	return 1;
}
#endif /* NNI */

a381 27
#if NHP
#include <vax/mba/mbavar.h>
int
booted_hp(struct device *dev, void *aux)
{
	static int mbaaddr;

	/* Save last adapter address */
	if (jmfr("mba", dev, BDEV_HP) == 0) {
		struct sbi_attach_args *sa = aux;

		mbaaddr = kvtophys(sa->sa_ioh);
		return 0;
	}

	if (jmfr("hp", dev, BDEV_HP))
		return 0;

	if (((struct mba_attach_args *)aux)->ma_unit != rpb.unit)
		return 0;

	if (mbaaddr != rpb.adpphy)
		return 0;

	return 1;
}
#endif
a397 5
struct  ngcconf {
        struct  cfdriver *ng_cf;
        dev_t   ng_root;
};

a400 3
#ifdef notyet
	{ "rl",         14 },
#endif
@


1.31
log
@Add support for the ``Firefox'' VAXstation 3520/3540/3820/3840 workstations,
currently limited to serial console and a single processor working.

All ``on-board'' devices, including the Q-bus adapter, but except for
the frame buffer, are supported. The machine will boot over the network
or from SCSI devices.

Lots of thanks to Al Kossow for www.bitsavers.org, on which I found the
technical documentation allowing me to complete this port (which was
lacking at the time I got that machine...).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2008/07/21 04:35:54 todd Exp $	*/
d80 2
@


1.30
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2007/06/01 19:25:10 deraadt Exp $	*/
a53 1
#include <machine/ka650.h>
d56 3
a68 1
void	gencnslask(void);
d75 1
a75 1
int booted_partition;	/* defaults to 0 (aka 'a' partition */
d344 2
a345 1
	    jmfr("sd", dev, BDEV_SDN) && jmfr("cd", dev, BDEV_SDN))
a347 6
#ifdef __NetBSD__
	if (sa->sa_periph->periph_channel->chan_bustype->bustype_type !=
	    SCSIPI_BUSTYPE_SCSI)
		return 0; /* ``Cannot happen'' */
#endif

d354 1
a354 1
	if (((jmfr("ncr",  ppdev, BDEV_SD) == 0) ||	/* old name */
d359 7
@


1.29
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2007/06/01 19:20:47 deraadt Exp $	*/
d470 1
@


1.28
log
@Fix cd block major number
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2007/05/25 14:50:38 deraadt Exp $	*/
a67 1
void    diskconf(void);
a81 6
	printf("boot device: %s\n",
	    bootdv ? bootdv->dv_xname : "<unknown>");

	setroot(bootdv, booted_partition, RB_USERREQ);
	dumpconf();

a84 1

d89 10
@


1.27
log
@rename cpu_dumpconf() to dumpconf(); no need to be different from other architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2007/05/04 19:30:55 deraadt Exp $	*/
d458 5
a462 3
        { "ra",          9 },
        { "rx",         12 },
        { "rl",         14 },
d464 4
a467 4
        { "sd",         20 },
        { "rd",         23 },
        { "raid",       25 },
        { "cd",         61 },
@


1.26
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2007/05/04 03:44:44 deraadt Exp $	*/
d66 1
a66 1
void	cpu_dumpconf(void);	/* machdep.c */
d87 1
a87 1
	cpu_dumpconf();
@


1.25
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2006/11/28 16:56:50 dlg Exp $	*/
d457 1
a457 4
struct nam2blk {
        char *name;
        int maj;
} nam2blk[] = {
d466 1
a467 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.24
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2006/07/23 19:23:09 miod Exp $	*/
d5 2
d41 1
d58 2
d68 1
a68 1
void	setroot(void);		/* rootfil.c */
a70 1
extern struct device *bootdv;
d74 3
d83 4
a86 1
	setroot();
d451 42
@


1.23
log
@Do not print an odd message on machines where led0 is configured but did
not attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2006/07/20 19:15:35 miod Exp $	*/
d326 1
a326 1
	struct scsibus_attach_args *sa = aux;
@


1.22
log
@Here cometh the blinkenlichten on VAXens.
Register information from NetBSD (except for KA53), logic from OpenBSD/sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2006/07/20 19:08:15 miod Exp $	*/
d98 6
a103 1
	if (hej)
d105 1
@


1.21
log
@Kill an autoconf abuse introduced with Cheetah support, and pass real
attachment information to mainbus children. Makes it much cleaner to
attach both ibus and vsbus on those machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2005/12/27 18:31:11 miod Exp $	*/
d55 1
d138 5
@


1.20
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2002/09/17 02:37:20 hugh Exp $	*/
a54 2
#include "sd.h"
#include "cd.h"
a68 3

#define MAINBUS	0

d120 2
d124 2
a125 5
	/*
	 * Hopefully there a master bus?
	 * Maybe should have this as master instead of mainbus.
	 */
	config_found(self, NULL, mainbus_print);
d128 5
a132 3
	/* Kludge: To have two master buses */
	if (vax_boardtype == VAX_BTYP_1303)
		config_found(self, (void *)1, mainbus_print);
@


1.19
log
@Switch device register routine from last match to first match. Fixes
problems one of my machines was having with phantom scsi luns and no
way to discern which one was the boot device.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2002/06/11 09:36:24 hugh Exp $	*/
a80 5
	/*	
	 * Configure swap area and related system
	 * parameter based on device(s) used.
	 */
	swapconf();
@


1.18
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2002/04/04 23:47:33 deraadt Exp $	*/
d233 2
a234 1
			bootdv = dev;
@


1.17
log
@permit compiling without NFS
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2002/03/14 01:26:48 millert Exp $	*/
d67 2
d70 1
a70 1
struct device *booted_from;
a93 9
	if (mountroot == NULL) {
		if (B_TYPE(bootdev) >= BDEV_NET) {
#ifdef NFSCLIENT
			mountroot = nfs_mountroot;
#endif
		} else
			mountroot = dk_mountroot;
	}

d146 6
d162 126
d289 148
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/11/06 19:53:17 miod Exp $	*/
d93 2
a94 1
		if (B_TYPE(bootdev) >= BDEV_NET) 
d96 2
a97 1
		else
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/06/25 00:43:19 mickey Exp $	*/
d62 3
a64 3
void	cpu_dumpconf __P((void));	/* machdep.c */
void	gencnslask __P((void));
void	setroot __P((void));		/* rootfil.c */
d103 3
a105 3
int	mainbus_print __P((void *, const char *));
int	mainbus_match __P((struct device *, struct cfdata *, void *));
void	mainbus_attach __P((struct device *, struct device *, void *));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/11/06 19:53:17 miod Exp $	*/
d62 3
a64 3
void	cpu_dumpconf(void);	/* machdep.c */
void	gencnslask(void);
void	setroot(void);		/* rootfil.c */
d93 1
a93 2
		if (B_TYPE(bootdev) >= BDEV_NET) {
#ifdef NFSCLIENT
d95 1
a95 2
#endif
		} else
d103 3
a105 3
int	mainbus_print(void *, const char *);
int	mainbus_match(struct device *, struct cfdata *, void *);
void	mainbus_attach(struct device *, struct device *, void *);
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15.2.1 2002/06/11 03:39:19 art Exp $	*/
a66 2
extern struct device *bootdv;

d68 1
a68 1

d92 9
a152 6

#if 1 /* boot blocks too old */
        if (rpb.rpb_base == (void *)-1)
                printf("\nWARNING: you must update your boot blocks.\n\n");
#endif

a162 127
#include "sd.h"
#include "cd.h"
#if NRL > 0
#include "rl.h"
#endif
#include "ra.h"
#include "hp.h"
#if NRY > 0
#include "ry.h"
#endif

static int ubtest(void *);
static int jmfr(char *, struct device *, int);
static int booted_qe(struct device *, void *);
static int booted_le(struct device *, void *);
static int booted_ze(struct device *, void *);
static int booted_de(struct device *, void *);
static int booted_ni(struct device *, void *);
#if NSD > 0 || NCD > 0
static int booted_sd(struct device *, void *);
#endif
#if NRL > 0
static int booted_rl(struct device *, void *);
#endif
#if NRA
static int booted_ra(struct device *, void *);
#endif
#if NHP
static int booted_hp(struct device *, void *);
#endif
#if NRD
static int booted_rd(struct device *, void *);
#endif

int (*devreg[])(struct device *, void *) = {
	booted_qe,
	booted_le,
	booted_ze,
	booted_de,
	booted_ni,
#if NSD > 0 || NCD > 0
	booted_sd,
#endif
#if NRL > 0
	booted_rl,
#endif
#if NRA
	booted_ra,
#endif
#if NHP
	booted_hp,
#endif
#if NRD
	booted_hd,
#endif
	0,
};

#define	ubreg(x) ((x) & 017777)

void
device_register(struct device *dev, void *aux)
{
	int (**dp)(struct device *, void *) = devreg;

	/* If there's a synthetic RPB, we can't trust it */
	if (rpb.rpb_base == (void *)-1)
		return;

	while (*dp) {
		if ((*dp)(dev, aux)) {
			if (bootdv == NULL)
				bootdv = dev;
			break;
		}
		dp++;
	}
}

/*
 * Simple checks. Return 1 on fail.
 */
int
jmfr(char *n, struct device *dev, int nr)
{
	if (rpb.devtyp != nr)
		return 1;
	return strcmp(n, dev->dv_cfdata->cf_driver->cd_name);
}

#include <arch/vax/qbus/ubavar.h>
int
ubtest(void *aux)
{
	paddr_t p;

	p = kvtophys(((struct uba_attach_args *)aux)->ua_ioh);
	if (rpb.csrphy != p)
		return 1;
	return 0;
}

#if 1 /* NNI */
#include <arch/vax/bi/bivar.h>
int
booted_ni(struct device *dev, void *aux)
{
	struct bi_attach_args *ba = aux;

	if (jmfr("ni", dev, BDEV_NI) || (kvtophys(ba->ba_ioh) != rpb.csrphy))
		return 0;

	return 1;
}
#endif /* NNI */

#if 1 /* NDE */
int
booted_de(struct device *dev, void *aux)
{

	if (jmfr("de", dev, BDEV_DE) || ubtest(aux))
		return 0;

	return 1;
}
#endif /* NDE */
a163 148
int
booted_le(struct device *dev, void *aux)
{
	if (jmfr("le", dev, BDEV_LE))
		return 0;
	return 1;
}

int
booted_ze(struct device *dev, void *aux)
{
	if (jmfr("ze", dev, BDEV_ZE))
		return 0;
	return 1;
}

#if 1 /* NQE */
int
booted_qe(struct device *dev, void *aux)
{
	if (jmfr("qe", dev, BDEV_QE) || ubtest(aux))
		return 0;

	return 1;
}
#endif /* NQE */

#if NSD > 0 || NCD > 0
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
int
booted_sd(struct device *dev, void *aux)
{
	struct scsibus_attach_args *sa = aux;
	struct device *ppdev;

	/* Is this a SCSI device? */
	if (jmfr("sd", dev, BDEV_SD) && jmfr("cd", dev, BDEV_SD) &&
	    jmfr("sd", dev, BDEV_SDN) && jmfr("cd", dev, BDEV_SDN))
		return 0;

#ifdef __NetBSD__
	if (sa->sa_periph->periph_channel->chan_bustype->bustype_type !=
	    SCSIPI_BUSTYPE_SCSI)
		return 0; /* ``Cannot happen'' */
#endif

	if (sa->sa_sc_link->target != rpb.unit)
		return 0; /* Wrong unit */

	ppdev = dev->dv_parent->dv_parent;

	/* VS3100 NCR 53C80 (si) & VS4000 NCR 53C94 (asc) */
	if (((jmfr("ncr",  ppdev, BDEV_SD) == 0) ||	/* old name */
	    (jmfr("asc", ppdev, BDEV_SD) == 0) ||
	    (jmfr("asc", ppdev, BDEV_SDN) == 0)) &&
	    (ppdev->dv_cfdata->cf_loc[0] == rpb.csrphy))
			return 1;

	return 0; /* Where did we come from??? */
}
#endif
#if NRL > 0
#include <dev/qbus/rlvar.h>
int
booted_rl(struct device *dev, void *aux)
{
	struct rlc_attach_args *raa = aux;
	static int ub;

	if (jmfr("rlc", dev, BDEV_RL) == 0)
		ub = ubtest(aux);
	if (ub)
		return 0;
	if (jmfr("rl", dev, BDEV_RL))
		return 0;
	if (raa->hwid != rpb.unit)
		return 0; /* Wrong unit number */
	return 1;
}
#endif

#if NRA
#include <arch/vax/mscp/mscp.h>
#include <arch/vax/mscp/mscpreg.h>
#include <arch/vax/mscp/mscpvar.h>
int
booted_ra(struct device *dev, void *aux)
{
	struct drive_attach_args *da = aux;
	struct mscp_softc *pdev = (void *)dev->dv_parent;
	paddr_t ioaddr;

	if (jmfr("ra", dev, BDEV_UDA))
		return 0;

	if (da->da_mp->mscp_unit != rpb.unit)
		return 0; /* Wrong unit number */

	ioaddr = kvtophys(pdev->mi_iph); /* Get phys addr of CSR */
	if (rpb.devtyp == BDEV_UDA && rpb.csrphy == ioaddr)
		return 1; /* Did match CSR */

	return 0;
}
#endif
#if NHP
#include <vax/mba/mbavar.h>
int
booted_hp(struct device *dev, void *aux)
{
	static int mbaaddr;

	/* Save last adapter address */
	if (jmfr("mba", dev, BDEV_HP) == 0) {
		struct sbi_attach_args *sa = aux;

		mbaaddr = kvtophys(sa->sa_ioh);
		return 0;
	}

	if (jmfr("hp", dev, BDEV_HP))
		return 0;

	if (((struct mba_attach_args *)aux)->ma_unit != rpb.unit)
		return 0;

	if (mbaaddr != rpb.adpphy)
		return 0;

	return 1;
}
#endif
#if NHD
int     
booted_hd(struct device *dev, void *aux)
{
	int *nr = aux; /* XXX - use the correct attach struct */

	if (jmfr("hd", dev, BDEV_RD))
		return 0;

	if (*nr != rpb.unit)
		return 0;

	return 1;
}
#endif
@


1.14
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/06/15 22:45:33 miod Exp $	*/
d41 1
a41 1
#include <vm/vm.h>
@


1.13
log
@Compile kernel with -Wall, and fix a few issues for this to work.
ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/05/05 22:34:28 art Exp $	*/
a68 2

extern int cold; 	/* cold-start flag */
@


1.12
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2001/02/11 06:34:37 hugh Exp $	*/
d62 1
d64 1
a76 2
	extern int boothowto;

@


1.11
log
@Pick up a NetBSD hack to attach Cheetah to vsbus as well as ibus.
High kludge factor, but the payoff is vsbus scsi for free.
Most of the work is by Michael Kukat and ragge, with a few other
synchronisations thrown in.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2000/04/27 01:10:11 bjc Exp $	*/
d73 1
a73 1
configure()
d80 7
a86 7
    setroot();
    /*
     * Configure swap area and related system
     * parameter based on device(s) used.
     */
    swapconf();
    cpu_dumpconf();
@


1.10
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 1997/10/02 19:54:14 niklas Exp $	*/
d144 6
@


1.9
log
@dumpconf after swapconf, and remove some swedish
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.8 1997/09/10 12:04:42 maja Exp $	*/
/*	$NetBSD: autoconf.c,v 1.25 1997/03/22 12:51:00 ragge Exp $	*/
d53 4
d60 4
a64 1
struct nexus *nexus;
d68 3
a70 1
#define BACKPLANE	0
d77 2
d80 7
a86 2
	if (config_rootfound("backplane", NULL) == NULL)
		panic("backplane not configured");
a87 7
#if GENERIC
	if ((boothowto & RB_ASKNAME) == 0)
		setroot();
	setconf();
#else
	setroot();
#endif
d89 1
a89 2
	 * Configure swap area and related system
	 * parameter based on device(s) used.
d91 1
a91 2
	swapconf();
	dumpconf();
d93 10
a102 1
	mtpr(GC_CCF, PR_TXDB);	/* Clear cold start flag in cpu */
d105 3
a107 3
int	printut __P((void *, const char *));
int	backplane_match __P((struct device *, void *, void *));
void	backplane_attach __P((struct device *, struct device *, void *));
d110 1
a110 1
printut(aux, msg)
d112 1
a112 1
	const char *msg;
d114 3
a116 5
	struct bp_conf *bp = aux;

	if (msg)
		printf("printut %s %s %d\n", msg, bp->type, bp->num);
	return (UNSUPP);
d120 1
a120 1
backplane_match(parent, gcf, aux)
d122 2
a123 1
	void	*gcf, *aux;
a124 2
	struct	cfdata	*cf = gcf;

d126 2
a127 2
	    strcmp(cf->cf_driver->cd_name, "backplane") == 0)
		return 1; /* First (and only) backplane */
a131 4
static	void find_sbi __P((struct device *, struct bp_conf *,
	    int (*) __P((void *, const char *))));


d133 1
a133 1
backplane_attach(parent, self, hej)
a136 2
	struct bp_conf bp;

a137 1
	bp.partyp = BACKPLANE;
d139 5
a143 67
	if (vax_bustype & VAX_CPUBUS) {
		bp.type = "cpu";
		bp.num = 0;
		config_found(self, &bp, printut);
	}
	if (vax_bustype & VAX_VSBUS) {
		bp.type = "vsbus";
		bp.num = 0;
		config_found(self, &bp, printut);
	}
	if (vax_bustype & VAX_SBIBUS) {
		bp.type = "sbi";
		bp.num = 0;
		config_found(self, &bp, printut);
	}
	if (vax_bustype & VAX_CMIBUS) {
		bp.type = "cmi";
		bp.num = 0;
		config_found(self, &bp, printut);
	}
	if (vax_bustype & VAX_UNIBUS) {
		bp.type = "uba";
		bp.num = 0;
		config_found(self, &bp, printut);
	}
#if VAX8600
	if (vax_bustype & VAX_MEMBUS) {
		bp.type = "mem";
		bp.num = 0;
		config_found(self, &bp, printut);
	}
	if (vax_cputype == VAX_8600)
		find_sbi(self, &bp, printut);
#endif

#if VAX8200 || VAX8800
	bp.type = "bi";
	if (vax_bustype & VAX_BIBUS) {

		switch (vax_cputype) {
#if VAX8200
		case VAX_8200: {
			extern void *bi_nodebase;

			bp.bp_addr = (int)bi_nodebase;
			config_found(self, &bp, printut);
			break;
		}
#endif
#ifdef notyet
		case VAX_8800: {
			int bi, biaddr;

			for (bi = 0; bi < MAXNBI; bi++) {
				biaddr = BI_BASE(bi) + BI_PROBE;
				if (badaddr((caddr_t)biaddr, 4))
					continue;

				bp.bp_addr = BI_BASE(bi);
				config_found(self, &bp, printut);
			}
			break;
		}
#endif
		}
	}
#endif
d145 2
d149 2
a150 155
#if VAX8600
void
find_sbi(self, bp, print)
	struct	device *self;
	struct	bp_conf *bp;
	int	(*print) __P((void *, const char *));
{
	volatile int tmp;
	volatile struct sbia_regs *sbiar;
	extern	struct ioa *ioa;
	int	type, i;

	for (i = 0; i < MAXNIOA; i++) {
		if (badaddr((caddr_t)&ioa[i], 4))
			continue;
		tmp = ioa[i].ioacsr.ioa_csr;
		type = tmp & IOA_TYPMSK;

		switch (type) {

		case IOA_SBIA:
			bp->type = "sbi";
			bp->num = i;
			config_found(self, bp, printut);
			sbiar = (void *)&ioa[i];
			sbiar->sbi_errsum = -1;
			sbiar->sbi_error = 0x1000;
			sbiar->sbi_fltsts = 0xc0000;
			break;

		default:
			printf("IOAdapter %x unsupported\n", type);
			break;
		}
	}
}
#endif

int	cpu_match __P((struct  device  *, void *, void *));
void	cpu_attach __P((struct	device	*, struct  device  *, void *));


int
cpu_match(parent, gcf, aux)
	struct	device	*parent;
	void	*gcf, *aux;
{
	struct	cfdata	*cf = gcf;
	struct bp_conf *bp = aux;

	if (strcmp(bp->type, "cpu"))
		return 0;

	switch (vax_cputype) {
#if VAX750 || VAX630 || VAX650 || VAX780 || VAX8600 || VAX410
	case VAX_750:
	case VAX_78032:
	case VAX_650:
	case VAX_780:
	case VAX_8600:
	default:
		if(cf->cf_unit == 0 && bp->partyp == BACKPLANE)
			return 1;
		break;
#endif
	};

	return 0;
}

void
cpu_attach(parent, self, aux)
	struct	device	*parent, *self;
	void	*aux;
{
	(*dep_call->cpu_conf)(parent, self, aux);
}

int	mem_match __P((struct  device  *, void	*, void *));
void	mem_attach __P((struct	device	*, struct  device  *, void *));

int
mem_match(parent, gcf, aux)
	struct	device	*parent;
	void	*gcf, *aux;
{
	struct	cfdata	*cf = gcf;
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;
	struct	bp_conf *bp = aux;

#if VAX8600
	if (vax_cputype == VAX_8600 && !strcmp(parent->dv_xname, "backplane0")) {
		if (strcmp(bp->type, "mem"))
			return 0;
		return 1;
	}
#endif
	if ((cf->cf_loc[0] != sa->nexnum) && (cf->cf_loc[0] > -1))
		return 0;

	switch (sa->type) {
	case NEX_MEM4:
	case NEX_MEM4I:
	case NEX_MEM16:
	case NEX_MEM16I:
		sa->nexinfo = M780C;
		break;

	case NEX_MEM64I:
	case NEX_MEM64L:
	case NEX_MEM64LI:
	case NEX_MEM256I:
	case NEX_MEM256L:
	case NEX_MEM256LI:
		sa->nexinfo = M780EL;
		break;

	case NEX_MEM64U:
	case NEX_MEM64UI:
	case NEX_MEM256U:
	case NEX_MEM256UI:
		sa->nexinfo = M780EU;
		break;

	default:
		return 0;
	}
	return 1;
}

void
mem_attach(parent, self, aux)
	struct	device	*parent, *self;
	void	*aux;
{
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;
	struct	mem_softc *sc = (void *)self;

#if VAX8600
	if (vax_cputype == VAX_8600) {
		ka86_memenable(0, 0);
		printf("\n");
		return;
	}
#endif
	sc->sc_memaddr = sa->nexaddr;
	sc->sc_memtype = sa->nexinfo;
	sc->sc_memnr = sa->type;
#ifdef VAX780
	ka780_memenable(sa, sc);
#endif
}

struct	cfdriver backplane_cd = {
	NULL, "backplane", DV_DULL
d153 2
a154 2
struct	cfattach backplane_ca = {
	sizeof(struct device), backplane_match, backplane_attach
a156 15
struct	cfdriver cpu_cd = {
	NULL, "cpu", DV_CPU
};

struct	cfattach cpu_backplane_ca = {
	sizeof(struct device), cpu_match, cpu_attach
};

struct	cfdriver mem_cd = {
	NULL, "mem", DV_CPU
};

struct	cfattach mem_backplane_ca = {
	sizeof(struct mem_softc), mem_match, mem_attach
};
a157 3
struct	cfattach mem_sbi_ca = {
	sizeof(struct mem_softc), mem_match, mem_attach
};
@


1.9.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.11 2001/02/11 06:34:37 hugh Exp $	*/
/*	$NetBSD: autoconf.c,v 1.45 1999/10/23 14:56:05 ragge Exp $	*/
a52 4
#include <machine/rpb.h>

#include "sd.h"
#include "cd.h"
a55 4
#include <vax/bi/bireg.h>

void	gencnslask __P((void));

d57 1
d61 1
a61 3
extern int cold; 	/* cold-start flag */

#define MAINBUS	0
a67 2
	if (config_rootfound("mainbus", NULL) == NULL)
		panic("mainbus not configured");
d69 2
a70 7
    setroot();
    /*
     * Configure swap area and related system
     * parameter based on device(s) used.
     */
    swapconf();
    cpu_dumpconf();
d72 7
d80 2
a81 1
	 * We're ready to start up. Clear CPU cold start flag.
d83 2
a84 1

d86 1
a86 10

	if (mountroot == NULL) {
		if (B_TYPE(bootdev) >= BDEV_NET) 
			mountroot = nfs_mountroot;
		else
			mountroot = dk_mountroot;
	}

	if (dep_call->cpu_clrf) 
		(*dep_call->cpu_clrf)();
d89 3
a91 3
int	mainbus_print __P((void *, const char *));
int	mainbus_match __P((struct device *, struct cfdata *, void *));
void	mainbus_attach __P((struct device *, struct device *, void *));
d94 1
a94 1
mainbus_print(aux, hej)
d96 1
a96 1
	const char *hej;
d98 5
a102 3
	if (hej)
		printf("nothing at %s", hej);
	return (UNCONF);
d106 1
a106 1
mainbus_match(parent, cf, aux)
d108 1
a108 2
	struct cfdata *cf;
	void	*aux;
d110 2
d113 2
a114 2
	    strcmp(cf->cf_driver->cd_name, "mainbus") == 0)
		return 1; /* First (and only) mainbus */
d119 4
d124 1
a124 1
mainbus_attach(parent, self, hej)
d128 2
d131 71
d203 52
a254 5
	/*
	 * Hopefully there a master bus?
	 * Maybe should have this as master instead of mainbus.
	 */
	config_found(self, NULL, mainbus_print);
d256 11
a266 4
#if VAX53
	/* Kludge: To have two master buses */
	if (vax_boardtype == VAX_BTYP_1303)
		config_found(self, (void *)1, mainbus_print);
d268 4
d273 6
a278 2
	if (dep_call->cpu_subconf)
		(*dep_call->cpu_subconf)(self);
d281 77
a357 2
struct	cfattach mainbus_ca = {
	sizeof(struct device), (cfmatch_t) mainbus_match, mainbus_attach
d360 2
a361 2
struct  cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
d364 3
d368 15
@


1.9.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9.12.1 2001/05/14 21:38:41 niklas Exp $	*/
a61 1
void	cpu_dumpconf __P((void));	/* machdep.c */
a62 1
void	setroot __P((void));		/* rootfil.c */
d68 2
d73 1
a73 1
cpu_configure()
d75 2
d80 7
a86 7
	setroot();
	/*	
	 * Configure swap area and related system
	 * parameter based on device(s) used.
	 */
	swapconf();
	cpu_dumpconf();
@


1.9.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
#include <uvm/uvm_extern.h>
@


1.9.12.4
log
@Merge in -current from about a week ago
@
text
@d62 3
a64 3
void	cpu_dumpconf(void);	/* machdep.c */
void	gencnslask(void);
void	setroot(void);		/* rootfil.c */
d103 3
a105 3
int	mainbus_print(void *, const char *);
int	mainbus_match(struct device *, struct cfdata *, void *);
void	mainbus_attach(struct device *, struct device *, void *);
@


1.9.12.5
log
@Sync the SMP branch with 3.3
@
text
@a66 2
extern struct device *bootdv;

d68 1
a68 1

d92 7
a150 6

#if 1 /* boot blocks too old */
        if (rpb.rpb_base == (void *)-1)
                printf("\nWARNING: you must update your boot blocks.\n\n");
#endif

a160 244
#include "sd.h"
#include "cd.h"
#if NRL > 0
#include "rl.h"
#endif
#include "ra.h"
#include "hp.h"
#if NRY > 0
#include "ry.h"
#endif

static int ubtest(void *);
static int jmfr(char *, struct device *, int);
static int booted_qe(struct device *, void *);
static int booted_le(struct device *, void *);
static int booted_ze(struct device *, void *);
static int booted_de(struct device *, void *);
static int booted_ni(struct device *, void *);
#if NSD > 0 || NCD > 0
static int booted_sd(struct device *, void *);
#endif
#if NRL > 0
static int booted_rl(struct device *, void *);
#endif
#if NRA
static int booted_ra(struct device *, void *);
#endif
#if NHP
static int booted_hp(struct device *, void *);
#endif
#if NRD
static int booted_rd(struct device *, void *);
#endif

int (*devreg[])(struct device *, void *) = {
	booted_qe,
	booted_le,
	booted_ze,
	booted_de,
	booted_ni,
#if NSD > 0 || NCD > 0
	booted_sd,
#endif
#if NRL > 0
	booted_rl,
#endif
#if NRA
	booted_ra,
#endif
#if NHP
	booted_hp,
#endif
#if NRD
	booted_hd,
#endif
	0,
};

#define	ubreg(x) ((x) & 017777)

void
device_register(struct device *dev, void *aux)
{
	int (**dp)(struct device *, void *) = devreg;

	/* If there's a synthetic RPB, we can't trust it */
	if (rpb.rpb_base == (void *)-1)
		return;

	while (*dp) {
		if ((*dp)(dev, aux)) {
			if (bootdv == NULL)
				bootdv = dev;
			break;
		}
		dp++;
	}
}

/*
 * Simple checks. Return 1 on fail.
 */
int
jmfr(char *n, struct device *dev, int nr)
{
	if (rpb.devtyp != nr)
		return 1;
	return strcmp(n, dev->dv_cfdata->cf_driver->cd_name);
}

#include <arch/vax/qbus/ubavar.h>
int
ubtest(void *aux)
{
	paddr_t p;

	p = kvtophys(((struct uba_attach_args *)aux)->ua_ioh);
	if (rpb.csrphy != p)
		return 1;
	return 0;
}

#if 1 /* NNI */
#include <arch/vax/bi/bivar.h>
int
booted_ni(struct device *dev, void *aux)
{
	struct bi_attach_args *ba = aux;

	if (jmfr("ni", dev, BDEV_NI) || (kvtophys(ba->ba_ioh) != rpb.csrphy))
		return 0;

	return 1;
}
#endif /* NNI */

#if 1 /* NDE */
int
booted_de(struct device *dev, void *aux)
{

	if (jmfr("de", dev, BDEV_DE) || ubtest(aux))
		return 0;

	return 1;
}
#endif /* NDE */

int
booted_le(struct device *dev, void *aux)
{
	if (jmfr("le", dev, BDEV_LE))
		return 0;
	return 1;
}

int
booted_ze(struct device *dev, void *aux)
{
	if (jmfr("ze", dev, BDEV_ZE))
		return 0;
	return 1;
}

#if 1 /* NQE */
int
booted_qe(struct device *dev, void *aux)
{
	if (jmfr("qe", dev, BDEV_QE) || ubtest(aux))
		return 0;

	return 1;
}
#endif /* NQE */

#if NSD > 0 || NCD > 0
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
int
booted_sd(struct device *dev, void *aux)
{
	struct scsibus_attach_args *sa = aux;
	struct device *ppdev;

	/* Is this a SCSI device? */
	if (jmfr("sd", dev, BDEV_SD) && jmfr("cd", dev, BDEV_SD) &&
	    jmfr("sd", dev, BDEV_SDN) && jmfr("cd", dev, BDEV_SDN))
		return 0;

#ifdef __NetBSD__
	if (sa->sa_periph->periph_channel->chan_bustype->bustype_type !=
	    SCSIPI_BUSTYPE_SCSI)
		return 0; /* ``Cannot happen'' */
#endif

	if (sa->sa_sc_link->target != rpb.unit)
		return 0; /* Wrong unit */

	ppdev = dev->dv_parent->dv_parent;

	/* VS3100 NCR 53C80 (si) & VS4000 NCR 53C94 (asc) */
	if (((jmfr("ncr",  ppdev, BDEV_SD) == 0) ||	/* old name */
	    (jmfr("asc", ppdev, BDEV_SD) == 0) ||
	    (jmfr("asc", ppdev, BDEV_SDN) == 0)) &&
	    (ppdev->dv_cfdata->cf_loc[0] == rpb.csrphy))
			return 1;

	return 0; /* Where did we come from??? */
}
#endif
#if NRL > 0
#include <dev/qbus/rlvar.h>
int
booted_rl(struct device *dev, void *aux)
{
	struct rlc_attach_args *raa = aux;
	static int ub;

	if (jmfr("rlc", dev, BDEV_RL) == 0)
		ub = ubtest(aux);
	if (ub)
		return 0;
	if (jmfr("rl", dev, BDEV_RL))
		return 0;
	if (raa->hwid != rpb.unit)
		return 0; /* Wrong unit number */
	return 1;
}
#endif

#if NRA
#include <arch/vax/mscp/mscp.h>
#include <arch/vax/mscp/mscpreg.h>
#include <arch/vax/mscp/mscpvar.h>
int
booted_ra(struct device *dev, void *aux)
{
	struct drive_attach_args *da = aux;
	struct mscp_softc *pdev = (void *)dev->dv_parent;
	paddr_t ioaddr;

	if (jmfr("ra", dev, BDEV_UDA))
		return 0;

	if (da->da_mp->mscp_unit != rpb.unit)
		return 0; /* Wrong unit number */

	ioaddr = kvtophys(pdev->mi_iph); /* Get phys addr of CSR */
	if (rpb.devtyp == BDEV_UDA && rpb.csrphy == ioaddr)
		return 1; /* Did match CSR */

	return 0;
}
#endif
#if NHP
#include <vax/mba/mbavar.h>
int
booted_hp(struct device *dev, void *aux)
{
	static int mbaaddr;

	/* Save last adapter address */
	if (jmfr("mba", dev, BDEV_HP) == 0) {
		struct sbi_attach_args *sa = aux;
a161 31
		mbaaddr = kvtophys(sa->sa_ioh);
		return 0;
	}

	if (jmfr("hp", dev, BDEV_HP))
		return 0;

	if (((struct mba_attach_args *)aux)->ma_unit != rpb.unit)
		return 0;

	if (mbaaddr != rpb.adpphy)
		return 0;

	return 1;
}
#endif
#if NHD
int     
booted_hd(struct device *dev, void *aux)
{
	int *nr = aux; /* XXX - use the correct attach struct */

	if (jmfr("hd", dev, BDEV_RD))
		return 0;

	if (*nr != rpb.unit)
		return 0;

	return 1;
}
#endif
@


1.8
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 1997/05/29 00:05:12 niklas Exp $	*/
d84 1
d94 1
a94 1
printut(aux, hej)
d96 1
a96 1
	const char *hej;
d99 3
a101 2
	if (hej)
		printf("printut %s %s %d\n",hej, bp->type, bp->num);
@


1.7
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.20 1997/01/11 13:50:20 ragge Exp $	*/
/*	$NetBSD: autoconf.c,v 1.20 1997/01/11 13:50:20 ragge Exp $	*/
a33 3
 /* All bugs are subject to removal without further notice */
		

d41 2
a51 1
#include <machine/uvax.h>
d56 1
a56 2
#include <vm/vm.h>

d58 2
a61 90
#define BIBUSS		1
#define SBIBUSS		2
#define VSBUSS		4

int	mastercpu;	/* chief of the system */

#if defined(VAX630) || defined(VAX410) || defined(VAX43) || defined(VAX46)
#define VAX_uVAX
#endif

#ifdef VAX8600 /* XXX These are in ka860 also */
void	ka86_conf __P((struct device *, struct device *, void *));
void	ka86_memenable __P((struct sbi_attach_args *, struct device *));
void	ka86_memerr __P((void));
int	ka86_mchk __P((caddr_t));
void	ka86_steal_pages __P((void));
#endif
#ifdef VAX780 /* XXX These are in ka780 also */
void	ka780_conf __P((struct device *, struct device *, void *));
void	ka780_memenable __P((struct sbi_attach_args *, void *));
void	ka780_memerr __P((void));
int	ka780_mchk __P((caddr_t));
void	ka780_steal_pages __P((void));
#endif

struct	cpu_dep cpu_calls[]={
		/* Type 0,noexist */
	{NULL, NULL, NULL, NULL, NULL },
#ifdef	VAX780	/* Type 1, 11/{780,782,785} */
	{ka780_steal_pages,generic_clock, ka780_mchk, ka780_memerr, ka780_conf,
	    generic_clkread, generic_clkwrite},
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
#ifdef	VAX750	/* Type 2, 11/750 */
	{ka750_steal_pages,generic_clock, ka750_mchk, ka750_memerr, ka750_conf,
	    generic_clkread, generic_clkwrite},
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
#ifdef	VAX730	/* Type 3, 11/{730,725}, ceauciesco-vax */
	{NULL, NULL, NULL, NULL, NULL },
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
#ifdef	VAX8600 /* Type 4, 8600/8650 (11/{790,795}) */
	{ka86_steal_pages, generic_clock, ka86_mchk, ka86_memerr, ka86_conf,
	    generic_clkread, generic_clkwrite},
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
#ifdef	VAX8200 /* Type 5, 8200, 8300, 8350 */
	{ka820_steal_pages, generic_clock, ka820_mchk, ka820_memerr, NULL,
	    ka820_clkread, ka820_clkwrite},
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
#ifdef	VAX8800 /* Type 6, 85X0, 8700, 88X0 */
	{NULL, generic_clock, NULL, NULL, NULL },
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
#ifdef	VAX610	/* Type 7, KA610 */
	{NULL, NULL, NULL, NULL, NULL },
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
#ifdef	VAX630	/* Type 8, KA630 or KA410 (uVAX II) */
	{uvax_steal_pages, no_nicr_clock, uvax_mchk, uvax_memerr, uvax_conf,
	    uvax_clkread, uvax_clkwrite},
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
		/* Type 9, not used */
	{NULL, NULL, NULL, NULL, NULL },
#ifdef	VAX650	/* Type 10, KA65X (uVAX III) */
	{uvaxIII_steal_pages, no_nicr_clock, uvaxIII_mchk, uvaxIII_memerr,
	    uvaxIII_conf, generic_clkread, generic_clkwrite},
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
#ifdef VAX_uVAX /* Type 11, RIGEL */
	{uvax_steal_pages, no_nicr_clock, uvax_mchk, uvax_memerr, uvax_conf,
	    uvax_clkread, uvax_clkwrite},
#else
	{NULL, NULL, NULL, NULL, NULL },
#endif
};

void	gencnslask __P((void));
a82 4
	gencnslask(); /* XXX inte g|ras h{r */
#if VAX410 || VAX43
	dzcnslask(); /* XXX inte g|ras h{r */
#endif
d91 1
d276 1
a276 1
	(*cpu_calls[vax_cputype].cpu_conf)(parent, self, aux);
@


1.6
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*      $NetBSD: autoconf.c,v 1.13 1996/05/19 16:43:53 ragge Exp $      */
d49 1
d52 2
a53 1
#include <machine/uvaxII.h>
d59 1
a59 9
#define	BACKPLANE	0
#define	BIBUSS		1
#define	SBIBUSS		2

struct bp_conf {
	char *type;
	int num;
	int partyp;
};
d61 4
a64 1
extern int cold;
d66 1
a66 1
void    notsupp_steal_pages __P((void));
d68 3
d73 5
a77 6
void    ka86_conf __P((struct device *, struct device *, void *));
int     ka86_clock __P((void));
void    ka86_memenable __P((struct sbi_attach_args *, struct device *));
void    ka86_memerr __P((void));
int     ka86_mchk __P((caddr_t));
void    ka86_steal_pages __P((void));
d80 5
a84 18
void    ka780_conf __P((struct device *, struct device *, void *));
int     ka780_clock __P((void));
void    ka780_memenable __P((struct sbi_attach_args *, void *));
void    ka780_memerr __P((void));
int     ka780_mchk __P((caddr_t));
void    ka780_steal_pages __P((void));
#endif
#ifdef	VAX750
int	nexty750[]={ NEX_MEM16,	NEX_MEM16,	NEX_MEM16,	NEX_MEM16,
		NEX_MBA,	NEX_MBA, 	NEX_MBA,	NEX_MBA,
		NEX_UBA0,	NEX_UBA1,	NEX_ANY,	NEX_ANY,
		NEX_ANY,	NEX_ANY,	NEX_ANY,	NEX_ANY};
#endif
#if VAX730
int   nexty730[NNEX730] = {
	NEX_MEM16,      NEX_ANY,	NEX_ANY,	NEX_ANY,
	NEX_ANY,	NEX_ANY,	NEX_ANY,	NEX_ANY,
};
d87 1
a87 1
struct	cpu_dep	cpu_calls[VAX_MAX+1]={
d89 1
a89 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d91 2
a92 1
	{ka780_steal_pages, ka780_clock, ka780_mchk, ka780_memerr, ka780_conf},
d94 1
a94 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d96 3
a98 2
#ifdef  VAX750	/* Type 2, 11/750 */
	{ka750_steal_pages, ka750_clock, ka750_mchk, ka750_memerr, ka750_conf},
d100 1
a100 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d103 1
a103 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d105 1
a105 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d107 3
a109 2
#ifdef	VAX8600	/* Type 4, 8600/8650 (11/{790,795}) */
	{ka86_steal_pages, ka86_clock, ka86_mchk, ka86_memerr, ka86_conf},
d111 1
a111 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d113 3
a115 2
#ifdef	VAX8200	/* Type 5, 8200, 8300, 8350 */
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d117 1
a117 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d119 2
a120 2
#ifdef	VAX8800	/* Type 6, 85X0, 8700, 88X0 */
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d122 1
a122 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d125 1
a125 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d127 1
a127 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d129 3
a131 3
#ifdef  VAX630  /* Type 8, KA630 or KA410 (uVAX II) */
	{uvaxII_steal_pages, uvaxII_clock, uvaxII_mchk, uvaxII_memerr,
	    uvaxII_conf},
d133 1
a133 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
d136 10
a145 4
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
#ifdef	VAX650  /* Type 10, KA65X (uVAX III) */
	{uvaxIII_steal_pages, uvaxIII_clock, uvaxIII_mchk, uvaxIII_memerr,
	    uvaxIII_conf},
d147 1
a147 1
	{notsupp_steal_pages, NULL, NULL, NULL, NULL },
a150 7
void
notsupp_steal_pages()
{
	printf("This cputype not supported.\n");
	asm("halt");
}

d174 3
d201 1
a201 1
	struct  cfdata  *cf = gcf;
d210 2
a211 2
static  void find_sbi __P((struct device *, struct bp_conf *,
	    int (*) __P((void *, char *))));
a219 1
	int i, ccpu, cmem, cbi, csbi;
d222 1
d224 4
a227 15
	switch (cpunumber) {
	case VAX_750:
	case VAX_650:
	case VAX_78032:
	case VAX_780:
		cmem = cbi = 0;
		ccpu = csbi = 1;
		break;

	case VAX_8600:
		cmem = ccpu = 1;
		cbi = csbi = 0;
		break;
	default:
		cmem = ccpu = cbi = csbi = 0;
d229 3
a231 5

	bp.partyp = BACKPLANE;
	bp.type = "cpu";
	for (i = 0; i < ccpu; i++) {
		bp.num = i;
d234 3
a236 3
	bp.type = "mem";
	for (i = 0; i < cmem; i++) {
		bp.num = i;
d239 3
a241 3
	bp.type = "bi";
	for (i = 0; i < cbi; i++) {
		bp.num = i;
d244 3
a246 3
	bp.type = "sbi";
	for(i = 0; i < csbi; i++) {
		bp.num = i;
d250 6
a255 1
	if (cpunumber == VAX_8600)
d258 34
d299 1
a299 1
	int	(*print) __P((void *, char *));
d302 1
a302 1
	volatile struct	sbia_regs *sbiar;
d332 2
a333 2
int     cpu_match __P((struct  device  *, void *, void *));
void	cpu_attach __P((struct  device  *, struct  device  *, void *));
d338 2
a339 2
	struct  device  *parent;
	void    *gcf, *aux;
d341 1
a341 1
	struct  cfdata  *cf = gcf;
d347 2
a348 2
	switch (cpunumber) {
#if VAX750 || VAX630 || VAX650 || VAX780 || VAX8600
d354 1
d366 2
a367 2
	struct  device  *parent, *self;
	void    *aux;
d369 1
a369 1
	(*cpu_calls[cpunumber].cpu_conf)(parent, self, aux);
d372 2
a373 2
int     mem_match __P((struct  device  *, void  *, void *));
void	mem_attach __P((struct  device  *, struct  device  *, void *));
d377 2
a378 2
	struct  device  *parent;
	void    *gcf, *aux;
d380 1
a380 1
	struct  cfdata  *cf = gcf;
d382 1
a382 1
	struct	bp_conf	*bp = aux;
d385 1
a385 1
	if (cpunumber == VAX_8600 && !strcmp(parent->dv_xname, "backplane0")) {
d426 2
a427 2
	struct  device  *parent, *self;
	void    *aux;
d433 1
a433 1
	if (cpunumber == VAX_8600) {
a441 7

	switch (cpunumber) {
#ifdef VAX750
	case VAX_750:
		ka750_memenable(sa, (void *)sc);
		break;
#endif
d443 1
a443 3
	case VAX_780:
		ka780_memenable(sa, sc);
		break;
a444 4
	default:
		break;
	}

d463 1
a463 1
struct  cfdriver mem_cd = {
d468 1
a468 1
	sizeof(struct device), mem_match, mem_attach
d472 1
a472 1
	sizeof(struct device), mem_match, mem_attach
@


1.4
log
@sync to 0611
@
text
@d190 1
a190 1
int	printut __P((void *, char *));
d196 1
a196 1
	char *hej;
@


1.3
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*      $NetBSD: autoconf.c,v 1.12 1996/04/08 18:32:26 ragge Exp $      */
a68 4
void    notsupp_conf __P((void *, void *, void *));
int     notsupp_clock __P((void));
void    notsupp_memerr __P((void));
int     notsupp_mchk __P((caddr_t));
d73 1
a73 1
void    ka86_conf __P((void *, void *, void *));
d81 1
a81 1
void    ka780_conf __P((void *, void *, void *));
d103 1
a103 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d107 1
a107 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d112 1
a112 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d115 1
a115 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d117 1
a117 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d122 1
a122 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d125 1
a125 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d127 1
a127 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d130 1
a130 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d132 1
a132 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d135 1
a135 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d137 1
a137 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d143 1
a143 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d146 1
a146 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
d151 1
a151 2
	{notsupp_steal_pages, notsupp_clock, notsupp_mchk, notsupp_memerr,
	    notsupp_conf},
a159 24
}

void
notsupp_conf(dev, dev2, a)
	void *dev, *dev2, *a;
{
}

int
notsupp_clock()
{
	return 0;
}

void
notsupp_memerr()
{
}

int
notsupp_mchk(a)
	caddr_t a;
{
	return 0;
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
/*      $NetBSD: autoconf.c,v 1.5 1995/12/13 18:45:57 ragge Exp $      */
d36 20
a55 13
#include "sys/param.h"
#include "machine/cpu.h"
#include "machine/sid.h"
#include "sys/types.h"
#include "sys/device.h"
#include "sys/reboot.h"
#include "sys/conf.h"
#include "machine/param.h"
#include "machine/vmparam.h"
#include "machine/nexus.h"
#include "machine/ka750.h"
#include "machine/../vax/gencons.h"
#include "vm/vm.h"
d69 23
a91 1
int	cpu_notsupp(),cpu_notgen();
a92 2
int	ka750_mchk(),ka750_memerr(),ka750_clock(),ka750_conf();
int	ka750_steal_pages();
a98 1
int	ka750_steal_pages();
a103 8
#if VAX630
int	uvaxII_steal_pages();
int     uvaxII_mchk(), uvaxII_memerr(), uvaxII_clock(), uvaxII_conf();
#endif
#if VAX650
int	uvaxIII_steal_pages();
int     uvaxIII_mchk(), uvaxIII_memerr(), uvaxIII_clock(), uvaxIII_conf();
#endif
d107 2
a108 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d110 1
a110 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d112 2
a113 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d116 1
a116 1
	ka750_steal_pages,ka750_clock,ka750_mchk,ka750_memerr,ka750_conf,
d118 2
a119 1
	cpu_notgen,cpu_notgen,cpu_notgen,cpu_notgen,cpu_notgen,
d122 2
a123 1
	ka730_steal_pages,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d125 2
a126 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d129 1
a129 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d131 2
a132 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d135 2
a136 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d138 2
a139 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d142 2
a143 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d145 2
a146 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d149 2
a150 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d152 2
a153 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d156 2
a157 2
	uvaxII_steal_pages, uvaxII_clock, uvaxII_mchk, uvaxII_memerr,
	    uvaxII_conf,
d159 2
a160 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d163 2
a164 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d166 2
a167 2
	uvaxIII_steal_pages, uvaxIII_clock, uvaxIII_mchk, uvaxIII_memerr,
	    uvaxIII_conf,
d169 2
a170 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d174 2
a175 1
cpu_notgen()
d177 1
a177 1
	conout("This cputype not generated.\n");
d180 4
a183 1
cpu_notsupp()
a184 2
	conout("This cputype not supported.\n");
	asm("halt");
d187 21
d213 1
a213 1
	if (!config_rootfound("backplane", NULL))
d233 3
a235 1

d241 1
d243 1
a243 1
		printf("printut %s\n",hej);
d248 1
a248 1
backplane_match(parent, cf, aux)
d250 1
a250 2
	struct	cfdata	*cf;
	void	*aux;
d252 2
d261 4
d275 1
a275 1
	switch(cpunumber){
d279 1
d283 7
d313 41
d355 5
d362 1
a362 1
cpu_match(parent, cf, aux)
d364 1
a364 2
	struct  cfdata  *cf;
	void    *aux;
d366 1
d369 1
a369 1
	if (strcmp(cf->cf_driver->cd_name, "cpu"))
d373 1
a373 1
#if VAX750 || VAX630 || VAX650
d377 2
d396 2
a397 1
int nmcr = 0;
d400 1
a400 1
mem_match(parent, cf, aux)
d402 1
a402 2
	struct  cfdata  *cf;
	void    *aux;
d404 13
a416 1
	struct sbi_attach_args *sa = (struct sbi_attach_args *)aux;
a417 2
	if ((cf->cf_loc[0] != sa->nexnum) && (cf->cf_loc[0] > -1))
		return 0; /* memory doesn't match spec's */
d419 2
d422 22
a443 1
		return 1;
d445 1
a445 1
	return 0;
d453 13
a465 1
	struct sbi_attach_args *sa = (struct sbi_attach_args *)aux;
d470 6
a475 1
		ka750_memenable(sa, self);
a477 1

d484 3
a486 3
struct	cfdriver backplanecd =
	{ 0, "backplane", backplane_match, backplane_attach,
		DV_DULL, sizeof(struct device) };
d488 3
a490 2
struct	cfdriver cpucd =
	{ 0, "cpu", cpu_match, cpu_attach, DV_CPU, sizeof(struct device) };
d492 3
d496 3
a498 2
struct  cfdriver memcd =
	{ 0, "mem", mem_match, mem_attach, DV_CPU, sizeof(struct device) };
d500 7
d508 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: autoconf.c,v 1.4 1995/06/05 16:26:23 ragge Exp $      */
a38 1
#include "machine/loconf.h"
d46 1
d53 1
d65 1
d72 1
d79 1
d82 4
d96 1
a96 1
	cpu_notgen,ka750_clock,ka750_mchk,ka750_memerr,ka750_conf,
d101 1
a101 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d126 2
a127 1
	cpu_notgen,uvaxII_clock,uvaxII_mchk,uvaxII_memerr,uvaxII_conf,
d134 2
a135 1
	cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,cpu_notsupp,
d173 1
a173 1
	cold=0;
d183 3
a185 2
	if(hej) printf("printut %s\n",hej);
	return(UNSUPP);
d194 2
a195 1
	if(cf->cf_unit==0&&strcmp(cf->cf_driver->cd_name,"backplane")==0)
d198 1
a198 1
	return(0);
d207 1
a207 1
	int i,ccpu,cmem,cbi,csbi;
d213 1
d215 2
a216 2
		cmem=cbi=0;
		ccpu=csbi=1;
d220 4
a223 4
	bp.partyp=BACKPLANE;
	bp.type="cpu";
	for(i=0;i<ccpu;i++){
		bp.num=i;
d226 3
a228 3
	bp.type="mem";
	for(i=0;i<cmem;i++){
		bp.num=i;
d231 3
a233 3
	bp.type="bi";
	for(i=0;i<cbi;i++){
		bp.num=i;
d236 3
a238 3
	bp.type="sbi";
	for(i=0;i<csbi;i++){
		bp.num=i;
d249 1
a249 1
	struct bp_conf *bp=aux;
d251 1
a251 1
	if(strcmp(cf->cf_driver->cd_name,"cpu"))
d255 1
a255 1
#ifdef VAX750
a256 5
		if(cf->cf_unit==0&&bp->partyp==BACKPLANE)
			return 1;
		break;
#endif
#ifdef VAX630
d258 2
a259 1
		if(cf->cf_unit==0&&bp->partyp==BACKPLANE)
d273 1
a273 23
	extern int cpu_type;
	extern char cpu_model[];

	switch (cpunumber) {
#ifdef	VAX750
	case VAX_750:
		printf(": 11/750, hardware rev %d, ucode rev %d\n",
		V750HARDW(cpu_type), V750UCODE(cpu_type));
		printf("cpu0 at backplane0: ");
		if(mfpr(PR_ACCS)&0xff){
			printf("FPA present, enabling\n");
			mtpr(0x8000,PR_ACCS);
		} else printf("no FPA\n");
		strcpy(cpu_model,"VAX 11/750");
		break;
#endif
#if VAX630
	case VAX_78032:
		printf(": MicroVAXII CPU\n");
		strcpy(cpu_model, "MicroVAX 78032/78132");
		break;
#endif
	};
d276 1
a276 1
int nmcr=0;
d284 1
a284 1
	struct sbi_attach_args *sa=(struct sbi_attach_args *)aux;
d286 1
a286 1
	if((cf->cf_loc[0]!=sa->nexnum)&&(cf->cf_loc[0]>-1))
d288 1
a288 1
	switch(sa->type){
d300 1
a300 1
	struct sbi_attach_args *sa=(struct sbi_attach_args *)aux;
d302 1
a302 1
	switch(cpunumber){
d305 1
a305 1
		ka750_memenable(sa,self);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
