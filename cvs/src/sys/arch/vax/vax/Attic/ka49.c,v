head	1.13;
access;
symbols
	OPENBSD_5_9:1.12.0.10
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.12
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.7.0.26
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.24
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.22
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.20
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.18
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.16
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.14
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.12;
commitid	OSDG2O3Cgeifnf1W;

1.12
date	2013.07.05.21.11.57;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.15.00.48.24;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.06.20.42.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.15.22.38.23;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.21.19.28.51;	author hugh;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.21.06.12.28;	author hugh;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.11.09.36.24;	author hugh;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.06.25.00.43.19;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.01.10.10;	author bjc;	state Exp;
branches
	1.1.8.1;
next	;

1.1.8.1
date	2001.05.14.21.38.57;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2001.07.04.10.24.35;	author niklas;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.1.8.5;

1.1.8.5
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: ka49.c,v 1.12 2013/07/05 21:11:57 miod Exp $	*/
/*
 * Copyright (c) 1999 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/kernel.h>

#include <machine/clock.h>
#include <machine/cpu.h>
#include <machine/scb.h>

static	void	ka49_conf(void);
static	void	ka49_memerr(void);
static	int	ka49_mchk(caddr_t);
static	void	ka49_halt(void);
static	void	ka49_reboot(int);
static	void	ka49_softmem(void *);
static	void	ka49_hardmem(void *);
static	void	ka49_init(void);
static	void	ka49_cache_enable(void);
static	void	ka49_halt(void);

/* 
 * Declaration of 49-specific calls.
 */
struct	cpu_dep ka49_calls = {
	ka49_init,
	ka49_mchk,
	ka49_memerr, 
	ka49_conf,
	chip_clkread,
	chip_clkwrite,
	32,      /* ~VUPS */
	2,	/* SCB pages */
	ka49_halt,
	ka49_reboot,
	NULL,
	icr_hardclock
};


void
ka49_conf()
{
	printf("cpu0: KA49\n");

/* Why??? */
{ volatile int *hej = (void *)mfpr(PR_ISP); *hej = *hej; hej[-1] = hej[-1];}

	/* This vector shows up during shutdown, ignore it for now. */
	scb_vecalloc(0x0, (void *)nullop, NULL, SCB_ISTACK, NULL);

	/*
	 * Setup parameters necessary to read time from clock chip.
	 */
	clk_adrshift = 1;       /* Addressed at long's... */
	clk_tweak = 2;          /* ...and shift two */
	clk_page = (short *)vax_map_physmem(0x25400000, 1);
}

/*
 * Why may we get memory errors during startup???
 */
void
ka49_hardmem(arg)
	void *arg;
{
	if (cold == 0)
		printf("Hard memory error\n");
	splhigh();
}

void
ka49_softmem(arg)
	void *arg;
{
	if (cold == 0)
		printf("Soft memory error\n");
	splhigh();
}

/*
 * KA49-specific IPRs. KA49 has the funny habit to control all caches
 * via IPRs.
 */
#define	PR_CCTL		0xa0
#define	CCTL_ENABLE	0x00000001
#define	CCTL_SSIZE	0x00000002
#define	CCTL_VSIZE	0x00000004
#define	CCTL_SW_ETM	0x40000000
#define	CCTL_HW_ETM	0x80000000

#define	PR_BCETSTS	0xa3
#define	PR_BCEDSTS	0xa6
#define	PR_NESTS	0xae

#define	PR_VMAR		0xd0
#define	PR_VTAG		0xd1
#define	PR_ICSR		0xd3
#define	ICSR_ENABLE	0x01

#define	PR_PCCTL	0xf8
#define	PCCTL_P_EN	0x10
#define	PCCTL_I_EN	0x02
#define	PCCTL_D_EN	0x01

void
ka49_cache_enable()
{
	int start, slut;

	/*
	 * Turn caches off.
	 */
	mtpr(0, PR_ICSR);
	mtpr(0, PR_PCCTL);
	mtpr(mfpr(PR_CCTL) | CCTL_SW_ETM, PR_CCTL);

	/*
	 * Invalidate caches.
	 */
	mtpr(mfpr(PR_CCTL) | 0x10, PR_CCTL);	/* Set cache size */
	mtpr(mfpr(PR_BCETSTS), PR_BCETSTS);	/* Clear error bits */
	mtpr(mfpr(PR_BCEDSTS), PR_BCEDSTS);	/* Clear error bits */
	mtpr(mfpr(PR_NESTS), PR_NESTS);		/* Clear error bits */

	start = 0x01400000;
	slut  = 0x01440000;

	/* Flush cache lines */
	for (; start < slut; start += 0x20)
		mtpr(0, start);

	mtpr((mfpr(PR_CCTL) & ~(CCTL_SW_ETM|CCTL_ENABLE)) | CCTL_HW_ETM,
	    PR_CCTL);

	start = 0x01000000;
	slut  = 0x01040000;

	/* clear tag and valid */
	for (; start < slut; start += 0x20)
		mtpr(0, start);

	mtpr(mfpr(PR_CCTL) | 0x10 | CCTL_ENABLE, PR_CCTL); /* enab. bcache */

	start = 0x01800000;
	slut  = 0x01802000;

	/* Clear primary cache */
	for (; start < slut; start += 0x20)
		mtpr(0, start);

	/* Flush the pipes (via REI) */
	asm("movpsl -(%sp); movab 1f,-(%sp); rei; 1:;");

	/* Enable primary cache */
	mtpr(PCCTL_P_EN|PCCTL_I_EN|PCCTL_D_EN, PR_PCCTL);

	/* Enable the VIC */
	start = 0;
	slut  = 0x800;
	for (; start < slut; start += 0x20) {
		mtpr(start, PR_VMAR);
		mtpr(0, PR_VTAG);
	}
	mtpr(ICSR_ENABLE, PR_ICSR);
}

void
ka49_memerr()
{
	printf("Memory err!\n");
}

int
ka49_mchk(addr)
	caddr_t addr;
{
	panic("Machine check");
	return 0;
}

void
ka49_init()
{
	/*
	 * Get the soft and hard memory error vectors now.
	 */
	scb_vecalloc(0x54, ka49_softmem, NULL, 0, NULL);
	scb_vecalloc(0x60, ka49_hardmem, NULL, 0, NULL);

	/* Turn on caches (to speed up execution a bit) */
	ka49_cache_enable();
}

#define	KA49_CPMBX	0x38
#define	KA49_HLT_HALT	0xcf
#define	KA49_HLT_BOOT	0x8b

static void
ka49_halt()
{
	if (((u_int8_t *) clk_page)[KA49_CPMBX] != KA49_HLT_HALT)
		((u_int8_t *) clk_page)[KA49_CPMBX] = KA49_HLT_HALT;
	asm("halt");
}

static void
ka49_reboot(arg)
	int arg;
{
	if (((u_int8_t *) clk_page)[KA49_CPMBX] != KA49_HLT_BOOT)
		((u_int8_t *) clk_page)[KA49_CPMBX] = KA49_HLT_BOOT;
	asm("halt");
}
@


1.12
log
@VAX ELF kernel bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.11 2011/09/15 00:48:24 miod Exp $	*/
@


1.11
log
@Switch vax to timecounters. There are three different clock sources:
- ICR/NICR on most systems (1MHz counter resolution).
- diagnostic timer on KA46/KA48 (1kHz counter resolution, counter is actually
  running at around 1024 kHz but is not guaranteed to be monotonic at this
  rate).
- 100Hz clock on VXT (nothing but the 100Hz clock interrupt).

Tested on KA49 (ICR style), KA46, KA48 (diagtmr style), VXT2000+ (VXT
{empty,hopeless}ness'r'us style).
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.10 2011/07/06 20:42:05 miod Exp $	*/
d184 1
a184 1
	asm("movpsl -(sp); movab 1f,-(sp); rei; 1:;");
@


1.10
log
@Drop cpu_dep.cpu_subconf routine, which is no longer used after KA820 support
removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.9 2008/08/18 23:05:38 miod Exp $	*/
d68 1
a68 1
	hardclock
@


1.9
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.8 2008/08/15 22:38:23 miod Exp $	*/
a66 1
	NULL,
@


1.8
log
@Rename the cpu_dep hook ``steal_pages'' to ``init'', as it serves as an
early initialization routine (to enable caches, etc) while still running
physical, and does not allocate memory anymore.

(The irony in this is that forthcoming KA60 support actually steals pages
 in its init function...)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.7 2002/07/21 19:28:51 hugh Exp $	*/
d67 3
@


1.7
log
@Support OS selectable halt action on the VAXstation 4000's.
Info from NetBSD, testing by pval and millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.6 2002/07/21 06:12:28 hugh Exp $	*/
d49 1
a49 1
static	void	ka49_steal_pages(void);
d57 1
a57 1
	ka49_steal_pages,
d212 1
a212 1
ka49_steal_pages()
@


1.6
log
@Vector 0x0 doesn't seem to be useful, so ignore it for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.5 2002/06/11 09:36:24 hugh Exp $	*/
d224 4
d231 2
d240 2
@


1.5
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.4 2002/03/14 01:26:48 millert Exp $	*/
d77 3
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.3 2001/08/25 13:33:37 hugh Exp $	*/
a150 1

@


1.3
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.2 2001/06/25 00:43:19 mickey Exp $	*/
d42 10
a51 10
static	void	ka49_conf __P((void));
static	void	ka49_memerr __P((void));
static	int	ka49_mchk __P((caddr_t));
static	void	ka49_halt __P((void));
static	void	ka49_reboot __P((int));
static	void	ka49_softmem __P((void *));
static	void	ka49_hardmem __P((void *));
static	void	ka49_steal_pages __P((void));
static	void	ka49_cache_enable __P((void));
static	void	ka49_halt __P((void));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.3 2001/08/25 13:33:37 hugh Exp $	*/
d42 10
a51 10
static	void	ka49_conf(void);
static	void	ka49_memerr(void);
static	int	ka49_mchk(caddr_t);
static	void	ka49_halt(void);
static	void	ka49_reboot(int);
static	void	ka49_softmem(void *);
static	void	ka49_hardmem(void *);
static	void	ka49_steal_pages(void);
static	void	ka49_cache_enable(void);
static	void	ka49_halt(void);
@


1.3.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.3.4.1 2002/06/11 03:39:19 art Exp $	*/
a77 3
	/* This vector shows up during shutdown, ignore it for now. */
	scb_vecalloc(0x0, (void *)nullop, NULL, SCB_ISTACK, NULL);

d152 1
a221 4
#define	KA49_CPMBX	0x38
#define	KA49_HLT_HALT	0xcf
#define	KA49_HLT_BOOT	0x8b

a224 2
	if (((u_int8_t *) clk_page)[KA49_CPMBX] != KA49_HLT_HALT)
		((u_int8_t *) clk_page)[KA49_CPMBX] = KA49_HLT_HALT;
a231 2
	if (((u_int8_t *) clk_page)[KA49_CPMBX] != KA49_HLT_BOOT)
		((u_int8_t *) clk_page)[KA49_CPMBX] = KA49_HLT_BOOT;
@


1.2
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.1 2000/04/27 01:10:10 bjc Exp $	*/
d63 1
a63 1
	16,      /* ~VUPS */
a211 1

d215 2
a216 2
	scb_vecalloc(0x54, ka49_softmem, 0, 0);
	scb_vecalloc(0x60, ka49_hardmem, 0, 0);
@


1.1
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a51 2

extern int cold;		/* cold-start flag */
@


1.1.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.1 2000/04/27 01:10:10 bjc Exp $	*/
@


1.1.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.1.8.1 2001/05/14 21:38:57 niklas Exp $	*/
d52 2
@


1.1.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ka49.c,v 1.1.8.2 2001/07/04 10:24:35 niklas Exp $	*/
d63 1
a63 1
	32,      /* ~VUPS */
d212 1
d216 2
a217 2
	scb_vecalloc(0x54, ka49_softmem, NULL, 0, NULL);
	scb_vecalloc(0x60, ka49_hardmem, NULL, 0, NULL);
@


1.1.8.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 10
a51 10
static	void	ka49_conf(void);
static	void	ka49_memerr(void);
static	int	ka49_mchk(caddr_t);
static	void	ka49_halt(void);
static	void	ka49_reboot(int);
static	void	ka49_softmem(void *);
static	void	ka49_hardmem(void *);
static	void	ka49_steal_pages(void);
static	void	ka49_cache_enable(void);
static	void	ka49_halt(void);
@


1.1.8.5
log
@Sync the SMP branch with 3.3
@
text
@a77 3
	/* This vector shows up during shutdown, ignore it for now. */
	scb_vecalloc(0x0, (void *)nullop, NULL, SCB_ISTACK, NULL);

d152 1
a221 4
#define	KA49_CPMBX	0x38
#define	KA49_HLT_HALT	0xcf
#define	KA49_HLT_BOOT	0x8b

a224 2
	if (((u_int8_t *) clk_page)[KA49_CPMBX] != KA49_HLT_HALT)
		((u_int8_t *) clk_page)[KA49_CPMBX] = KA49_HLT_HALT;
a231 2
	if (((u_int8_t *) clk_page)[KA49_CPMBX] != KA49_HLT_BOOT)
		((u_int8_t *) clk_page)[KA49_CPMBX] = KA49_HLT_BOOT;
@


