head	1.14;
access;
symbols
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.20
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.18
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.16
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.14
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.12
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2011.07.06.18.32.59;	author miod;	state dead;
branches;
next	1.13;

1.13
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.16.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.27.01.10.12;	author bjc;	state Exp;
branches;
next	1.3;

1.3
date	97.09.10.12.04.49;	author maja;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	97.05.29.00.05.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.25.16;	author maja;	state Exp;
branches;
next	;

1.3.12.1
date	2001.05.14.21.39.03;	author niklas;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.3.12.4;

1.3.12.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.3.12.5;

1.3.12.5
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.3.12.6;

1.3.12.6
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	1.3.12.7;

1.3.12.7
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@/*	$OpenBSD: ka820.c,v 1.13 2008/08/18 23:05:38 miod Exp $	*/
/*	$NetBSD: ka820.c,v 1.22 2000/06/04 02:19:27 matt Exp $	*/
/*
 * Copyright (c) 1988 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ka820.c	7.4 (Berkeley) 12/16/90
 */

/*
 * KA820 specific CPU code.  (Note that the VAX8200 uses a KA820, not
 * a KA8200.  Sigh.)
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h> 

#include <machine/ka820.h>
#include <machine/cpu.h>
#include <machine/mtpr.h>
#include <machine/nexus.h>
#include <machine/clock.h>
#include <machine/scb.h>
#include <machine/bus.h>

#include <vax/bi/bireg.h>
#include <vax/bi/bivar.h>

#include <vax/vax/crx.h>

struct ka820port *ka820port_ptr;
struct rx50device *rx50device_ptr;
static volatile struct ka820clock *ka820_clkpage;

static int ka820_match(struct device *, struct cfdata *, void *);
static void ka820_attach(struct device *, struct device *, void *);
static void ka820_memerr(void);
static void ka820_conf(void);
static int ka820_mchk(caddr_t);
static int ka820_clkread(time_t base);
static void ka820_clkwrite(void);
static void rxcdintr(void *);
static void vaxbierr(void *);

struct	cpu_dep ka820_calls = {
	0,
	ka820_mchk,
	ka820_memerr,
	ka820_conf,
	ka820_clkread,
	ka820_clkwrite,
	3,      /* ~VUPS */
	5,	/* SCB pages */
	NULL,
	NULL,
	NULL,
	NULL,
	hardclock
};

struct cfattach cpu_bi_ca = {
	sizeof(struct device), ka820_match, ka820_attach
};

#ifdef notyet
extern pt_entry_t BRAMmap[];
extern pt_entry_t EEPROMmap[];
char bootram[KA820_BRPAGES * VAX_NBPG];
char eeprom[KA820_EEPAGES * VAX_NBPG];
#endif

int
ka820_match(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void	*aux;
{
	struct bi_attach_args *ba = aux;

	if (bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) != BIDT_KA820)
		return 0;

	if (ba->ba_nodenr != mastercpu)
		return 0;

	if (cf->cf_loc[BICF_NODE] != BICF_NODE_DEFAULT &&
	    cf->cf_loc[BICF_NODE] != ba->ba_nodenr)
		return 0;

	return 1;
}

void
ka820_attach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
{
	struct bi_attach_args *ba = aux;
	register int csr;
	u_short rev;

	rev = bus_space_read_4(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) >> 16;
	strlcpy(cpu_model, "VAX 8200", sizeof cpu_model);
	cpu_model[6] = rev & 0x8000 ? '5' : '0';
	printf(": ka82%c (%s) cpu rev %d, u patch rev %d, sec patch %d\n",
	    cpu_model[6], mastercpu == ba->ba_nodenr ? "master" : "slave",
	    ((rev >> 11) & 15), ((rev >> 1) &1023), rev & 1);

	/* reset the console and enable the RX50 */
	ka820port_ptr = (void *)vax_map_physmem(KA820_PORTADDR, 1);
	csr = ka820port_ptr->csr;
	csr &= ~KA820PORT_RSTHALT;	/* ??? */
	csr |= KA820PORT_CONSCLR | KA820PORT_CRDCLR | KA820PORT_CONSEN |
		KA820PORT_RXIE;
	ka820port_ptr->csr = csr;
	bus_space_write_4(ba->ba_iot, ba->ba_ioh,
	    BIREG_INTRDES, ba->ba_intcpu);
	bus_space_write_4(ba->ba_iot, ba->ba_ioh, BIREG_VAXBICSR,
	    bus_space_read_4(ba->ba_iot, ba->ba_ioh, BIREG_VAXBICSR) |
	    BICSR_SEIE | BICSR_HEIE);

}

void
ka820_conf()
{
	/*
	 * Setup parameters necessary to read time from clock chip.
	 */
	ka820_clkpage = (void *)vax_map_physmem(KA820_CLOCKADDR, 1);

	/* Steal the interrupt vectors that are unique for us */
	scb_vecalloc(KA820_INT_RXCD, rxcdintr, NULL, SCB_ISTACK, NULL);
	scb_vecalloc(0x50, vaxbierr, NULL, SCB_ISTACK, NULL);

	/* XXX - should be done somewhere else */
	scb_vecalloc(SCB_RX50, crxintr, NULL, SCB_ISTACK, NULL);
	rx50device_ptr = (void *)vax_map_physmem(KA820_RX50ADDR, 1);
}

void
vaxbierr(void *arg)
{
	if (cold == 0)
		panic("vaxbierr");
}

#ifdef notdef
/*
 * MS820 support.
 */
struct ms820regs {
	struct	biiregs biic;		/* BI interface chip */
	u_long	ms_gpr[4];		/* the four gprs (unused) */
	int	ms_csr1;		/* control/status register 1 */
	int	ms_csr2;		/* control/status register 2 */
};
#endif

#define	MEMRD(reg) bus_space_read_4(sc->sc_iot, sc->sc_ioh, (reg))
#define MEMWR(reg, val) bus_space_write_4(sc->sc_iot, sc->sc_ioh, (reg), (val))

#define	MSREG_CSR1	0x100
#define	MSREG_CSR2	0x104
/*
 * Bits in CSR1.
 */
#define MS1_ERRSUM	0x80000000	/* error summary (ro) */
#define MS1_ECCDIAG	0x40000000	/* ecc diagnostic (rw) */
#define MS1_ECCDISABLE	0x20000000	/* ecc disable (rw) */
#define MS1_MSIZEMASK	0x1ffc0000	/* mask for memory size (ro) */
#define MS1_RAMTYMASK	0x00030000	/* mask for ram type (ro) */
#define MS1_RAMTY64K	0x00000000	/* 64K chips */
#define MS1_RAMTY256K	0x00010000	/* 256K chips */
#define MS1_RAMTY1MB	0x00020000	/* 1MB chips */
					/* type 3 reserved */
#define MS1_CRDINH	0x00008000	/* inhibit crd interrupts (rw) */
#define MS1_MEMVALID	0x00004000	/* memory has been written (ro) */
#define MS1_INTLK	0x00002000	/* interlock flag (ro) */
#define MS1_BROKE	0x00001000	/* broken (rw) */
#define MS1_MBZ		0x00000880	/* zero */
#define MS1_MWRITEERR	0x00000400	/* rds during masked write (rw) */
#define MS1_CNTLERR	0x00000200	/* internal timing busted (rw) */
#define MS1_INTLV	0x00000100	/* internally interleaved (ro) */
#define MS1_DIAGC	0x0000007f	/* ecc diagnostic bits (rw) */

/*
 * Bits in CSR2.
 */
#define MS2_RDSERR	0x80000000	/* rds error (rw) */
#define MS2_HIERR	0x40000000	/* high error rate (rw) */
#define MS2_CRDERR	0x20000000	/* crd error (rw) */
#define MS2_ADRSERR	0x10000000	/* rds due to addr par err (rw) */
#define MS2_MBZ		0x0f000080	/* zero */
#define MS2_ADDR	0x00fffe00	/* address in error (relative) (ro) */
#define MS2_INTLVADDR	0x00000100	/* error was in bank 1 (ro) */
#define MS2_SYN		0x0000007f	/* error syndrome (ro, rw diag) */

static int ms820_match(struct device *, struct cfdata *, void *);
static void ms820_attach(struct device *, struct device *, void *);

struct mem_bi_softc {
	struct device sc_dev;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
};

struct cfattach mem_bi_ca = {
	sizeof(struct mem_bi_softc), ms820_match, ms820_attach
};

static int
ms820_match(parent, cf, aux)
	struct	device	*parent;
	struct cfdata *cf;
	void	*aux;
{
	struct bi_attach_args *ba = aux;

	if (bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) != BIDT_MS820)
		return 0;

	if (cf->cf_loc[BICF_NODE] != BICF_NODE_DEFAULT &&
	    cf->cf_loc[BICF_NODE] != ba->ba_nodenr)
		return 0;

	return 1;
}

static void
ms820_attach(parent, self, aux)
	struct	device	*parent, *self;
	void	*aux;
{
	struct mem_bi_softc *sc = (void *)self;
	struct bi_attach_args *ba = aux;

	sc->sc_iot = ba->ba_iot;
	sc->sc_ioh = ba->ba_ioh;

	if ((MEMRD(BIREG_VAXBICSR) & BICSR_STS) == 0)
		printf(": failed self test\n");
	else
		printf(": size %dMB, %s chips\n", ((MEMRD(MSREG_CSR1) & 
		    MS1_MSIZEMASK) >> 20), (MEMRD(MSREG_CSR1) & MS1_RAMTYMASK
		    ? MEMRD(MSREG_CSR1) & MS1_RAMTY256K ? "256K":"1M":"64K"));

	MEMWR(BIREG_INTRDES, ba->ba_intcpu);
	MEMWR(BIREG_VAXBICSR, MEMRD(BIREG_VAXBICSR) | BICSR_SEIE | BICSR_HEIE);

	MEMWR(MSREG_CSR1, MS1_MWRITEERR | MS1_CNTLERR);
	MEMWR(MSREG_CSR2, MS2_RDSERR | MS2_HIERR | MS2_CRDERR | MS2_ADRSERR);
}

void
ka820_memerr()
{
	struct mem_bi_softc *sc;
	int m, hard, csr1, csr2;
	char *type;
static char b1[] = "\20\40ERRSUM\37ECCDIAG\36ECCDISABLE\20CRDINH\17VALID\
\16INTLK\15BROKE\13MWRITEERR\12CNTLERR\11INTLV";
static char b2[] = "\20\40RDS\37HIERR\36CRD\35ADRS";

	for (m = 0; m < mem_cd.cd_ndevs; m++) {
		sc = mem_cd.cd_devs[m];
		if (sc == NULL)
			continue;
		csr1 = MEMRD(MSREG_CSR1);
		csr2 = MEMRD(MSREG_CSR2);
		printf("%s: csr1=%b csr2=%b\n", sc->sc_dev.dv_xname,
		    csr1, b1, csr2, b2);
		if ((csr1 & MS1_ERRSUM) == 0)
			continue;
		hard = 1;
		if (csr1 & MS1_BROKE)
			type = "broke";
		else if (csr1 & MS1_CNTLERR)
			type = "cntl err";
		else if (csr2 & MS2_ADRSERR)
			type = "address parity err";
		else if (csr2 & MS2_RDSERR)
			type = "rds err";
		else if (csr2 & MS2_CRDERR) {
			hard = 0;
			type = "";
		} else
			type = "mysterious error";
		printf("%s: %s%s%s addr %x bank %x syn %x\n",
		    sc->sc_dev.dv_xname, hard ? "hard error: " : "soft ecc",
		    type, csr2 & MS2_HIERR ?  " (+ other rds or crd err)" : "",
		    ((csr2 & MS2_ADDR) + MEMRD(BIREG_SADR)) >> 9,
		    (csr2 & MS2_INTLVADDR) != 0, csr2 & MS2_SYN);
		MEMWR(MSREG_CSR1, csr1 | MS1_CRDINH);
		MEMWR(MSREG_CSR2, csr2);
	}
}

/* these are bits 0 to 6 in the summary field */
char *mc8200[] = {
	"cpu bad ipl",		"ucode lost err",
	"ucode par err",	"DAL par err",
	"BI bus err",		"BTB tag par",
	"cache tag par",
};
#define MC8200_BADIPL	0x01
#define MC8200_UERR	0x02
#define MC8200_UPAR	0x04
#define MC8200_DPAR	0x08
#define MC8200_BIERR	0x10
#define MC8200_BTAGPAR	0x20
#define MC8200_CTAGPAR	0x40

struct mc8200frame {
	int	mc82_bcnt;		/* byte count == 0x20 */
	int	mc82_summary;		/* summary parameter */
	int	mc82_param1;		/* parameter 1 */
	int	mc82_va;		/* va register */
	int	mc82_vap;		/* va prime register */
	int	mc82_ma;		/* memory address */
	int	mc82_status;		/* status word */
	int	mc82_epc;		/* error pc */
	int	mc82_upc;		/* micro pc */
	int	mc82_pc;		/* current pc */
	int	mc82_psl;		/* current psl */
};

int
ka820_mchk(cmcf)
	caddr_t cmcf;
{
	register struct mc8200frame *mcf = (struct mc8200frame *)cmcf;
	register int i, type = mcf->mc82_summary;

	/* ignore BI bus errors during configuration */
	if (cold && type == MC8200_BIERR) {
		mtpr(PR_MCESR, 0xf);
		return (MCHK_RECOVERED);
	}

	/*
	 * SOME ERRORS ARE RECOVERABLE
	 * do it later
	 */
	printf("machine check %x: ", type);
	for (i = 0; i < sizeof (mc8200) / sizeof (mc8200[0]); i++)
		if (type & (1 << i))
			printf(" %s,", mc8200[i]);
	printf(" param1 %x\n", mcf->mc82_param1);
	printf(
"\tva %x va' %x ma %x pc %x psl %x\n\tstatus %x errpc %x upc %x\n",
		mcf->mc82_va, mcf->mc82_vap, mcf->mc82_ma,
		mcf->mc82_pc, mcf->mc82_psl,
		mcf->mc82_status, mcf->mc82_epc, mcf->mc82_upc);
	return (MCHK_PANIC);
}

/*
 * Receive a character from logical console.
 */
void
rxcdintr(arg)
	void *arg;
{
	register int c = mfpr(PR_RXCD);

	/* not sure what (if anything) to do with these */
	printf("rxcd node %x c=0x%x\n", (c >> 8) & 0xf, c & 0xff);
}

int
ka820_clkread(time_t base)
{
	struct clock_ymdhms c;
	int s;

	while (ka820_clkpage->csr0 & KA820CLK_0_BUSY)
		;
	s = splhigh();
	c.dt_sec = ka820_clkpage->sec;
	c.dt_min = ka820_clkpage->min;
	c.dt_hour = ka820_clkpage->hr;
	c.dt_wday = ka820_clkpage->dayofwk;
	c.dt_day = ka820_clkpage->day;
	c.dt_mon = ka820_clkpage->mon;
	c.dt_year = ka820_clkpage->yr;
	splx(s);

	/* strange conversion */
	c.dt_sec = ((c.dt_sec << 7) | (c.dt_sec >> 1)) & 0377;
	c.dt_min = ((c.dt_min << 7) | (c.dt_min >> 1)) & 0377;
	c.dt_hour = ((c.dt_hour << 7) | (c.dt_hour >> 1)) & 0377;
	c.dt_wday = ((c.dt_wday << 7) | (c.dt_wday >> 1)) & 0377;
	c.dt_day = ((c.dt_day << 7) | (c.dt_day >> 1)) & 0377;
	c.dt_mon = ((c.dt_mon << 7) | (c.dt_mon >> 1)) & 0377;
	c.dt_year = ((c.dt_year << 7) | (c.dt_year >> 1)) & 0377;

	time.tv_sec = clock_ymdhms_to_secs(&c);
	return CLKREAD_OK;
}

void
ka820_clkwrite(void)
{
	struct clock_ymdhms c;

	clock_secs_to_ymdhms(time.tv_sec, &c);

	ka820_clkpage->csr1 = KA820CLK_1_SET;
	ka820_clkpage->sec = ((c.dt_sec << 1) | (c.dt_sec >> 7)) & 0377;
	ka820_clkpage->min = ((c.dt_min << 1) | (c.dt_min >> 7)) & 0377;
	ka820_clkpage->hr = ((c.dt_hour << 1) | (c.dt_hour >> 7)) & 0377;
	ka820_clkpage->dayofwk = ((c.dt_wday << 1) | (c.dt_wday >> 7)) & 0377;
	ka820_clkpage->day = ((c.dt_day << 1) | (c.dt_day >> 7)) & 0377;
	ka820_clkpage->mon = ((c.dt_mon << 1) | (c.dt_mon >> 7)) & 0377;
	ka820_clkpage->yr = ((c.dt_year << 1) | (c.dt_year >> 7)) & 0377;

	ka820_clkpage->csr1 = KA820CLK_1_GO;
}
@


1.13
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.12 2003/11/10 21:05:06 miod Exp $	*/
@


1.12
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.11 2003/06/02 23:27:59 millert Exp $	*/
d86 5
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.10 2003/05/11 19:41:12 deraadt Exp $	*/
d93 2
a94 2
extern struct pte BRAMmap[];
extern struct pte EEPROMmap[];
@


1.10
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.9 2002/03/14 03:16:02 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.8 2002/03/14 01:26:48 millert Exp $	*/
d134 1
a134 1
	strcpy(cpu_model, "VAX 8200");
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.7 2001/11/06 19:53:17 miod Exp $	*/
d72 1
a72 1
static void ka820_attach(struct device *, struct device *, void*);
d231 1
a231 1
static void ms820_attach(struct device *, struct device *, void*);
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.6 2001/09/11 20:05:25 miod Exp $	*/
d71 5
a75 5
static int ka820_match __P((struct device *, struct cfdata *, void *));
static void ka820_attach __P((struct device *, struct device *, void*));
static void ka820_memerr __P((void));
static void ka820_conf __P((void));
static int ka820_mchk __P((caddr_t));
d78 1
a78 1
static void rxcdintr __P((void *));
d230 2
a231 2
static int ms820_match __P((struct device *, struct cfdata *, void *));
static void ms820_attach __P((struct device *, struct device *, void*));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.7 2001/11/06 19:53:17 miod Exp $	*/
d71 5
a75 5
static int ka820_match(struct device *, struct cfdata *, void *);
static void ka820_attach(struct device *, struct device *, void *);
static void ka820_memerr(void);
static void ka820_conf(void);
static int ka820_mchk(caddr_t);
d78 1
a78 1
static void rxcdintr(void *);
d230 2
a231 2
static int ms820_match(struct device *, struct cfdata *, void *);
static void ms820_attach(struct device *, struct device *, void *);
@


1.7.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 1
a134 1
	strlcpy(cpu_model, "VAX 8200", sizeof cpu_model);
@


1.6
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.5 2001/08/25 13:33:37 hugh Exp $	*/
d52 1
a52 1
#include <vm/vm.h> 
@


1.5
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.4 2000/04/27 01:10:12 bjc Exp $	*/
a52 1
#include <vm/vm_kern.h>
@


1.4
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 2
a2 2
/*	$OpenBSD: ka820.c,v 1.3 1997/09/10 12:04:49 maja Exp $	*/
/*	$NetBSD: ka820.c,v 1.17 1999/09/06 19:52:52 ragge Exp $	*/
d70 1
d72 9
a80 4
static	int ka820_match __P((struct device *, struct cfdata *, void *));
static	void ka820_attach __P((struct device *, struct device *, void*));
static	void rxcdintr __P((int));
void crxintr __P((int));
d86 3
a88 3
	NULL,
	chip_clkread,
	chip_clkwrite,
a132 1
	extern	char cpu_model[];
d135 1
a135 1
	strcpy(cpu_model,"VAX 8200");
d142 1
d154 1
a154 2
	/* XXX - should be done somewhere else */
	scb_vecalloc(SCB_RX50, crxintr, 0, SCB_ISTACK);
d156 7
a162 3
	clk_adrshift = 0;	/* clk regs are addressed at short's */
	clk_tweak = 1; 		/* ...but not exactly in each short */
	clk_page = (short *)vax_map_physmem((paddr_t)KA820_CLOCKADDR, 1);
d165 2
a166 1
	scb_vecalloc(KA820_INT_RXCD, rxcdintr, 0, SCB_ISTACK);
d168 2
d171 7
a177 1
	ka820port_ptr = (void *)vax_map_physmem(KA820_PORTADDR, 1);
d395 1
a395 1
	int arg;
d401 50
@


1.3
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: ka820.c,v 1.2 1997/05/29 00:05:22 niklas Exp $	*/
/*	$NetBSD: ka820.c,v 1.5 1997/04/18 18:49:34 ragge Exp $	*/
d50 1
d61 1
d63 4
a66 2
#include <arch/vax/bi/bireg.h>
#include <arch/vax/bi/bivar.h>
a69 1
void *bi_nodebase;	/* virtual base address for all possible bi nodes */
d71 4
a74 2
static int ka820_match __P((struct device *, void *, void *));
static void ka820_attach __P((struct device *, struct device *, void*));
d77 1
a77 2
	ka820_steal_pages,
	generic_clock,
d84 1
a84 4
	0,      /* Used by vaxstation */
	0,      /* Used by vaxstation */
	0,      /* Used by vaxstation */

d94 2
a95 2
char bootram[KA820_BRPAGES * NBPG];
char eeprom[KA820_EEPAGES * NBPG];
a97 54
struct ivec_dsp nollhanterare;

static void
hant(arg)
	int arg;
{
	if (cold == 0)
		printf("stray interrupt from vaxbi bus\n");
}

void
ka820_steal_pages()
{
	extern	vm_offset_t avail_start, virtual_avail, avail_end;
	extern	struct ivec_dsp idsptch;
	extern	short *clk_page;
	extern	int clk_adrshift, clk_tweak;
	struct scb *sb;
	int	junk, i, j;

	/*
	 * On the ka820, we map in the port CSR, the clock registers
	 * and the console RX50 register. We also map in the BI nodespace
	 * for all possible (16) nodes. It would only be needed with
	 * the existent nodes, but we only loose 1K so...
	 */
	sb = (void *)avail_start;
	MAPPHYS(junk, j, VM_PROT_READ|VM_PROT_WRITE); /* SCB & vectors */
	clk_adrshift = 0;	/* clk regs are addressed at short's */
	clk_tweak = 1; 		/* ...but not exactly in each short */
	MAPVIRT(clk_page, 1);
	pmap_map((vm_offset_t)clk_page, (vm_offset_t)KA820_CLOCKADDR,
	    KA820_CLOCKADDR + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(ka820port_ptr, 1);
	pmap_map((vm_offset_t)ka820port_ptr, (vm_offset_t)KA820_PORTADDR,
	    KA820_PORTADDR + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(rx50device_ptr, 1);
	pmap_map((vm_offset_t)rx50device_ptr, (vm_offset_t)KA820_RX50ADDR,
	    KA820_RX50ADDR + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(bi_nodebase, NNODEBI * (sizeof(struct bi_node) / NBPG));
	pmap_map((vm_offset_t)bi_nodebase, (vm_offset_t)BI_BASE(0),
	    BI_BASE(0) + sizeof(struct bi_node) * NNODEBI,
	    VM_PROT_READ|VM_PROT_WRITE);
	bcopy(&idsptch, &nollhanterare, sizeof(struct ivec_dsp));
	nollhanterare.hoppaddr = hant;
	for (i = 0; i < 4; i++)
		for (j = 0; j < 16; j++)
			sb->scb_nexvec[i][j] = &nollhanterare;

}

d99 1
a99 1
ka820_match(parent, match, aux)
d101 2
a102 1
	void	*match, *aux;
a103 1
	struct	cfdata *cf = match;
d106 1
a106 1
	if (ba->ba_node->biic.bi_dtype != BIDT_KA820)
d112 2
a113 1
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != ba->ba_nodenr)
d126 1
a126 1
	u_short rev = ba->ba_node->biic.bi_revs;
d129 1
d142 18
a159 2
	ba->ba_node->biic.bi_intrdes = ba->ba_intcpu;
	ba->ba_node->biic.bi_csr |= BICSR_SEIE | BICSR_HEIE;
d162 1
d172 1
d174 5
d213 1
a213 1
static int ms820_match __P((struct device *, void *, void *));
d217 3
a219 2
	struct device mem_dev;
	struct ms820regs *mem_regs;
d227 1
a227 1
ms820_match(parent, match, aux)
d229 2
a230 1
	void	*match, *aux;
a231 1
	struct	cfdata *cf = match;
d234 1
a234 1
	if (ba->ba_node->biic.bi_dtype != BIDT_MS820)
d237 2
a238 1
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != ba->ba_nodenr)
d249 1
a249 1
	struct mem_bi_softc *ms = (void *)self;
d252 2
a253 1
	ms->mem_regs = (void *)ba->ba_node;
d255 1
a255 1
	if ((ms->mem_regs->biic.bi_csr & BICSR_STS) == 0)
d258 9
a266 10
		printf(": size %dMB, %s chips\n", ((ms->mem_regs->ms_csr1 & 
		    MS1_MSIZEMASK) >> 20), (ms->mem_regs->ms_csr1&MS1_RAMTYMASK
		    ?ms->mem_regs->ms_csr1 & MS1_RAMTY256K?"256K":"1M":"64K"));

	ms->mem_regs->biic.bi_intrdes = ba->ba_intcpu;
	ms->mem_regs->biic.bi_csr |= BICSR_SEIE | BICSR_HEIE;

	ms->mem_regs->ms_csr1 = MS1_MWRITEERR | MS1_CNTLERR;
	ms->mem_regs->ms_csr2 = MS2_RDSERR | MS2_HIERR |
	    MS2_CRDERR | MS2_ADRSERR;
d272 3
a274 5
	register struct ms820regs *mcr;
	struct mem_bi_softc *mc;
	extern struct cfdriver mem_cd;
	register int m, hard;
	register char *type;
d280 2
a281 2
		mc = mem_cd.cd_devs[m];
		if (mc == NULL)
d283 5
a287 4
		mcr = mc->mem_regs;
		printf("%s: csr1=%b csr2=%b\n", mc->mem_dev.dv_xname,
		    mcr->ms_csr1, b1, mcr->ms_csr2, b2);
		if ((mcr->ms_csr1 & MS1_ERRSUM) == 0)
d290 1
a290 1
		if (mcr->ms_csr1 & MS1_BROKE)
d292 1
a292 1
		else if (mcr->ms_csr1 & MS1_CNTLERR)
d294 1
a294 1
		else if (mcr->ms_csr2 & MS2_ADRSERR)
d296 1
a296 1
		else if (mcr->ms_csr2 & MS2_RDSERR)
d298 1
a298 1
		else if (mcr->ms_csr2 & MS2_CRDERR) {
d304 6
a309 9
		    mc->mem_dev.dv_xname,
		    hard ? "hard error: " : "soft ecc",
		    type, mcr->ms_csr2 & MS2_HIERR ?
		    " (+ other rds or crd err)" : "",
		    ((mcr->ms_csr2 & MS2_ADDR) + mcr->biic.bi_sadr) >> 9,
		    (mcr->ms_csr2 & MS2_INTLVADDR) != 0,
		    mcr->ms_csr2 & MS2_SYN);
		mcr->ms_csr1 = mcr->ms_csr1 | MS1_CRDINH;
		mcr->ms_csr2 = mcr->ms_csr2;
d375 3
a377 1
rxcdintr()
@


1.3.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: ka820.c,v 1.4 2000/04/27 01:10:12 bjc Exp $	*/
/*	$NetBSD: ka820.c,v 1.17 1999/09/06 19:52:52 ragge Exp $	*/
a49 1
#include <sys/systm.h>
a59 1
#include <machine/bus.h>
d61 2
a62 4
#include <vax/bi/bireg.h>
#include <vax/bi/bivar.h>

#include <vax/vax/crx.h>
d66 1
d68 2
a69 4
static	int ka820_match __P((struct device *, struct cfdata *, void *));
static	void ka820_attach __P((struct device *, struct device *, void*));
static	void rxcdintr __P((int));
void crxintr __P((int));
d72 2
a73 1
	0,
d80 4
a83 1
	5,	/* SCB pages */
d93 2
a94 2
char bootram[KA820_BRPAGES * VAX_NBPG];
char eeprom[KA820_EEPAGES * VAX_NBPG];
d97 54
d152 1
a152 1
ka820_match(parent, cf, aux)
d154 1
a154 2
	struct cfdata *cf;
	void	*aux;
d156 1
d159 1
a159 1
	if (bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) != BIDT_KA820)
d165 1
a165 2
	if (cf->cf_loc[BICF_NODE] != BICF_NODE_DEFAULT &&
	    cf->cf_loc[BICF_NODE] != ba->ba_nodenr)
d178 1
a178 1
	u_short rev;
a180 1
	rev = bus_space_read_4(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) >> 16;
d193 2
a194 18
	bus_space_write_4(ba->ba_iot, ba->ba_ioh,
	    BIREG_INTRDES, ba->ba_intcpu);
	bus_space_write_4(ba->ba_iot, ba->ba_ioh, BIREG_VAXBICSR,
	    bus_space_read_4(ba->ba_iot, ba->ba_ioh, BIREG_VAXBICSR) |
	    BICSR_SEIE | BICSR_HEIE);

	/* XXX - should be done somewhere else */
	scb_vecalloc(SCB_RX50, crxintr, 0, SCB_ISTACK);

	clk_adrshift = 0;	/* clk regs are addressed at short's */
	clk_tweak = 1; 		/* ...but not exactly in each short */
	clk_page = (short *)vax_map_physmem((paddr_t)KA820_CLOCKADDR, 1);

	/* Steal the interrupt vectors that are unique for us */
	scb_vecalloc(KA820_INT_RXCD, rxcdintr, 0, SCB_ISTACK);

	rx50device_ptr = (void *)vax_map_physmem(KA820_RX50ADDR, 1);
	ka820port_ptr = (void *)vax_map_physmem(KA820_PORTADDR, 1);
a196 1
#ifdef notdef
a205 1
#endif
a206 5
#define	MEMRD(reg) bus_space_read_4(sc->sc_iot, sc->sc_ioh, (reg))
#define MEMWR(reg, val) bus_space_write_4(sc->sc_iot, sc->sc_ioh, (reg), (val))

#define	MSREG_CSR1	0x100
#define	MSREG_CSR2	0x104
d241 1
a241 1
static int ms820_match __P((struct device *, struct cfdata *, void *));
d245 2
a246 3
	struct device sc_dev;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
d254 1
a254 1
ms820_match(parent, cf, aux)
d256 1
a256 2
	struct cfdata *cf;
	void	*aux;
d258 1
d261 1
a261 1
	if (bus_space_read_2(ba->ba_iot, ba->ba_ioh, BIREG_DTYPE) != BIDT_MS820)
d264 1
a264 2
	if (cf->cf_loc[BICF_NODE] != BICF_NODE_DEFAULT &&
	    cf->cf_loc[BICF_NODE] != ba->ba_nodenr)
d275 1
a275 1
	struct mem_bi_softc *sc = (void *)self;
d278 1
a278 2
	sc->sc_iot = ba->ba_iot;
	sc->sc_ioh = ba->ba_ioh;
d280 1
a280 1
	if ((MEMRD(BIREG_VAXBICSR) & BICSR_STS) == 0)
d283 10
a292 9
		printf(": size %dMB, %s chips\n", ((MEMRD(MSREG_CSR1) & 
		    MS1_MSIZEMASK) >> 20), (MEMRD(MSREG_CSR1) & MS1_RAMTYMASK
		    ? MEMRD(MSREG_CSR1) & MS1_RAMTY256K ? "256K":"1M":"64K"));

	MEMWR(BIREG_INTRDES, ba->ba_intcpu);
	MEMWR(BIREG_VAXBICSR, MEMRD(BIREG_VAXBICSR) | BICSR_SEIE | BICSR_HEIE);

	MEMWR(MSREG_CSR1, MS1_MWRITEERR | MS1_CNTLERR);
	MEMWR(MSREG_CSR2, MS2_RDSERR | MS2_HIERR | MS2_CRDERR | MS2_ADRSERR);
d298 5
a302 3
	struct mem_bi_softc *sc;
	int m, hard, csr1, csr2;
	char *type;
d308 2
a309 2
		sc = mem_cd.cd_devs[m];
		if (sc == NULL)
d311 4
a314 5
		csr1 = MEMRD(MSREG_CSR1);
		csr2 = MEMRD(MSREG_CSR2);
		printf("%s: csr1=%b csr2=%b\n", sc->sc_dev.dv_xname,
		    csr1, b1, csr2, b2);
		if ((csr1 & MS1_ERRSUM) == 0)
d317 1
a317 1
		if (csr1 & MS1_BROKE)
d319 1
a319 1
		else if (csr1 & MS1_CNTLERR)
d321 1
a321 1
		else if (csr2 & MS2_ADRSERR)
d323 1
a323 1
		else if (csr2 & MS2_RDSERR)
d325 1
a325 1
		else if (csr2 & MS2_CRDERR) {
d331 9
a339 6
		    sc->sc_dev.dv_xname, hard ? "hard error: " : "soft ecc",
		    type, csr2 & MS2_HIERR ?  " (+ other rds or crd err)" : "",
		    ((csr2 & MS2_ADDR) + MEMRD(BIREG_SADR)) >> 9,
		    (csr2 & MS2_INTLVADDR) != 0, csr2 & MS2_SYN);
		MEMWR(MSREG_CSR1, csr1 | MS1_CRDINH);
		MEMWR(MSREG_CSR2, csr2);
d405 1
a405 3
void
rxcdintr(arg)
	int arg;
@


1.3.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ka820.c,v 1.3.12.1 2001/05/14 21:39:03 niklas Exp $	*/
/*	$NetBSD: ka820.c,v 1.22 2000/06/04 02:19:27 matt Exp $	*/
d53 1
a69 1
static volatile struct ka820clock *ka820_clkpage;
d71 4
a74 9
static int ka820_match __P((struct device *, struct cfdata *, void *));
static void ka820_attach __P((struct device *, struct device *, void*));
static void ka820_memerr __P((void));
static void ka820_conf __P((void));
static int ka820_mchk __P((caddr_t));
static int ka820_clkread(time_t base);
static void ka820_clkwrite(void);
static void rxcdintr __P((void *));
static void vaxbierr(void *);
d80 3
a82 3
	ka820_conf,
	ka820_clkread,
	ka820_clkwrite,
d127 1
d130 1
a130 1
	strcpy(cpu_model, "VAX 8200");
a136 1
	ka820port_ptr = (void *)vax_map_physmem(KA820_PORTADDR, 1);
d148 2
a149 1
}
d151 3
a153 7
void
ka820_conf()
{
	/*
	 * Setup parameters necessary to read time from clock chip.
	 */
	ka820_clkpage = (void *)vax_map_physmem(KA820_CLOCKADDR, 1);
d156 1
a156 2
	scb_vecalloc(KA820_INT_RXCD, rxcdintr, NULL, SCB_ISTACK, NULL);
	scb_vecalloc(0x50, vaxbierr, NULL, SCB_ISTACK, NULL);
a157 2
	/* XXX - should be done somewhere else */
	scb_vecalloc(SCB_RX50, crxintr, NULL, SCB_ISTACK, NULL);
d159 1
a159 7
}

void
vaxbierr(void *arg)
{
	if (cold == 0)
		panic("vaxbierr");
d377 1
a377 1
	void *arg;
a382 50
}

int
ka820_clkread(time_t base)
{
	struct clock_ymdhms c;
	int s;

	while (ka820_clkpage->csr0 & KA820CLK_0_BUSY)
		;
	s = splhigh();
	c.dt_sec = ka820_clkpage->sec;
	c.dt_min = ka820_clkpage->min;
	c.dt_hour = ka820_clkpage->hr;
	c.dt_wday = ka820_clkpage->dayofwk;
	c.dt_day = ka820_clkpage->day;
	c.dt_mon = ka820_clkpage->mon;
	c.dt_year = ka820_clkpage->yr;
	splx(s);

	/* strange conversion */
	c.dt_sec = ((c.dt_sec << 7) | (c.dt_sec >> 1)) & 0377;
	c.dt_min = ((c.dt_min << 7) | (c.dt_min >> 1)) & 0377;
	c.dt_hour = ((c.dt_hour << 7) | (c.dt_hour >> 1)) & 0377;
	c.dt_wday = ((c.dt_wday << 7) | (c.dt_wday >> 1)) & 0377;
	c.dt_day = ((c.dt_day << 7) | (c.dt_day >> 1)) & 0377;
	c.dt_mon = ((c.dt_mon << 7) | (c.dt_mon >> 1)) & 0377;
	c.dt_year = ((c.dt_year << 7) | (c.dt_year >> 1)) & 0377;

	time.tv_sec = clock_ymdhms_to_secs(&c);
	return CLKREAD_OK;
}

void
ka820_clkwrite(void)
{
	struct clock_ymdhms c;

	clock_secs_to_ymdhms(time.tv_sec, &c);

	ka820_clkpage->csr1 = KA820CLK_1_SET;
	ka820_clkpage->sec = ((c.dt_sec << 1) | (c.dt_sec >> 7)) & 0377;
	ka820_clkpage->min = ((c.dt_min << 1) | (c.dt_min >> 7)) & 0377;
	ka820_clkpage->hr = ((c.dt_hour << 1) | (c.dt_hour >> 7)) & 0377;
	ka820_clkpage->dayofwk = ((c.dt_wday << 1) | (c.dt_wday >> 7)) & 0377;
	ka820_clkpage->day = ((c.dt_day << 1) | (c.dt_day >> 7)) & 0377;
	ka820_clkpage->mon = ((c.dt_mon << 1) | (c.dt_mon >> 7)) & 0377;
	ka820_clkpage->yr = ((c.dt_year << 1) | (c.dt_year >> 7)) & 0377;

	ka820_clkpage->csr1 = KA820CLK_1_GO;
@


1.3.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
#include <uvm/uvm_extern.h> 
@


1.3.12.4
log
@Merge in -current from about a week ago
@
text
@d71 5
a75 5
static int ka820_match(struct device *, struct cfdata *, void *);
static void ka820_attach(struct device *, struct device *, void *);
static void ka820_memerr(void);
static void ka820_conf(void);
static int ka820_mchk(caddr_t);
d78 1
a78 1
static void rxcdintr(void *);
d230 2
a231 2
static int ms820_match(struct device *, struct cfdata *, void *);
static void ms820_attach(struct device *, struct device *, void *);
@


1.3.12.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.3.12.4 2002/03/28 11:26:46 niklas Exp $	*/
d134 1
a134 1
	strlcpy(cpu_model, "VAX 8200", sizeof cpu_model);
@


1.3.12.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka820.c,v 1.3.12.5 2003/05/13 19:41:10 ho Exp $	*/
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.12.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 2
a94 2
extern pt_entry_t BRAMmap[];
extern pt_entry_t EEPROMmap[];
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: ka820.c,v 1.3 1996/10/13 03:35:51 christos Exp $	*/
/*	$NetBSD: ka820.c,v 1.3 1996/10/13 03:35:51 christos Exp $	*/
a63 1
struct ka820clock *ka820clock_ptr;
d71 15
d112 2
d125 4
a128 2
	MAPVIRT(ka820clock_ptr, 1);
	pmap_map((vm_offset_t)ka820clock_ptr, (vm_offset_t)KA820_CLOCKADDR,
a194 74
}

/* Set system time from clock */
/* ARGSUSED */
ka820_clkread(base)
	time_t base;
{
	struct chiptime c;
	int s, rv;

	rv = CLKREAD_OK;
	/* I wish I knew the differences between these */
	if ((ka820clock_ptr->csr3 & KA820CLK_3_VALID) == 0) {
		printf("WARNING: TOY clock not marked valid\n");
		rv = CLKREAD_WARN;
	}
	if ((ka820clock_ptr->csr1 & KA820CLK_1_GO) != KA820CLK_1_GO) {
		printf("WARNING: TOY clock stopped\n");
		rv = CLKREAD_WARN;
	}
	/* THIS IS NOT RIGHT (clock may change on us) */
	s = splhigh();
	while (ka820clock_ptr->csr0 & KA820CLK_0_BUSY)
		/* void */;
	c.sec = ka820clock_ptr->sec;
	c.min = ka820clock_ptr->min;
	c.hour = ka820clock_ptr->hr;
	c.day = ka820clock_ptr->day;
	c.mon = ka820clock_ptr->mon;
	c.year = ka820clock_ptr->yr;
	splx(s);

	/* the darn thing needs tweaking! */
	c.sec >>= 1;		/* tweak */
	c.min >>= 1;		/* tweak */
	c.hour >>= 1;		/* tweak */
	c.day >>= 1;		/* tweak */
	c.mon >>= 1;		/* tweak */
	c.year >>= 1;		/* tweak */

	time.tv_sec = chiptotime(&c);
	return (time.tv_sec ? rv : CLKREAD_BAD);
}

/* store time into clock */
void
ka820_clkwrite()
{
	struct chiptime c;
	int s;

	timetochip(&c);

	/* play it again, sam (or mike or kirk or ...) */
	c.sec <<= 1;		/* tweak */
	c.min <<= 1;		/* tweak */
	c.hour <<= 1;		/* tweak */
	c.day <<= 1;		/* tweak */
	c.mon <<= 1;		/* tweak */
	c.year <<= 1;		/* tweak */

	s = splhigh();
	ka820clock_ptr->csr1 = KA820CLK_1_SET;
	while (ka820clock_ptr->csr0 & KA820CLK_0_BUSY)
		/* void */;
	ka820clock_ptr->sec = c.sec;
	ka820clock_ptr->min = c.min;
	ka820clock_ptr->hr = c.hour;
	ka820clock_ptr->day = c.day;
	ka820clock_ptr->mon = c.mon;
	ka820clock_ptr->yr = c.year;
	/* should we set a `rate'? */
	ka820clock_ptr->csr1 = KA820CLK_1_GO;
	splx(s);
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
