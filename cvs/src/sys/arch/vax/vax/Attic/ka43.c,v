head	1.17;
access;
symbols
	OPENBSD_5_9:1.16.0.6
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.12
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.10
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.18
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.16
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.16;
commitid	OSDG2O3Cgeifnf1W;

1.16
date	2014.05.08.19.06.07;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.15.00.48.24;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.13.21.25.23;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.06.20.42.05;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.15.22.38.23;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.30.16.14.31;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.16.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.27.01.10.12;	author bjc;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.12.08;	author millert;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.09.10.12.04.46;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.00.05.20;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.25.12;	author maja;	state Exp;
branches;
next	;

1.4.6.1
date	2001.05.14.21.38.54;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: ka43.c,v 1.16 2014/05/08 19:06:07 miod Exp $ */
/*	$NetBSD: ka43.c,v 1.19 1999/09/06 19:52:53 ragge Exp $ */
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by Bertram Barth.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/pmap.h>
#include <machine/uvax.h>
#include <machine/vsbus.h>
#include <machine/ka43.h>
#include <machine/clock.h>

static	void ka43_conf(void);
static	void ka43_init(void);

static	int ka43_mchk(caddr_t);
static	void ka43_memerr(void);
#if 0
static	void ka43_clear_errors(void);
#endif
static	int ka43_cache_init(void);	/* "int mapen" as argument? */
static	int ka43_cache_reset(int);
static	int ka43_cache_enable(void);
static	int ka43_cache_disable(void);
static	int ka43_cache_invalidate(void);
static  void ka43_halt(void);
static  void ka43_reboot(int);
static  void ka43_clrf(void);


struct	cpu_dep ka43_calls = {
	ka43_init,
	ka43_mchk,
	ka43_memerr,
	ka43_conf,
	chip_clkread,
	chip_clkwrite,
	7,	/* 7.6 VUP */
	2,	/* SCB pages */
	ka43_halt,
	ka43_reboot,
	ka43_clrf,
	icr_hardclock
};

static	volatile struct	ka43_cpu   *ka43_cpu	= (void *)KA43_CPU_BASE;
static	volatile u_int	*ka43_creg = (void *)KA43_CH2_CREG;
static	volatile u_int	*ka43_ctag = (void *)KA43_CT2_BASE;

#define KA43_MC_RESTART	0x00008000	/* Restart possible*/
#define KA43_PSL_FPDONE	0x00010000	/* First Part Done */

struct ka43_mcframe {		/* Format of RigelMAX machine check frame: */
	int	mc43_bcnt;	/* byte count, always 24 (0x18) */
	int	mc43_code;	/* machine check type code and restart bit */
	int	mc43_addr;	/* most recent (faulting?) virtual address */
	int	mc43_viba;	/* contents of VIBA register */
	int	mc43_sisr;	/* ICCS bit 6 and SISR bits 15:0 */
	int	mc43_istate;	/* internal state */
	int	mc43_sc;	/* shift count register */
	int	mc43_pc;	/* trapped PC */
	int	mc43_psl;	/* trapped PSL */
};

static char *ka43_mctype[] = {
	"no error (0)",			/* Code 0: No error */
	"FPA: protocol error",		/* Code 1-5: FPA errors */
	"FPA: illegal opcode",
	"FPA: operand parity error",
	"FPA: unknown status",
	"FPA: result parity error",
	"unused (6)",			/* Code 6-7: Unused */
	"unused (7)",
	"MMU error (TLB miss)",		/* Code 8-9: MMU errors */
	"MMU error (TLB hit)",
	"HW interrupt at unused IPL",	/* Code 10: Interrupt error */
	"MOVCx impossible state",	/* Code 11-13: Microcode errors */
	"undefined trap code (i-box)",
	"undefined control store address",
	"unused (14)",			/* Code 14-15: Unused */
	"unused (15)",
	"PC tag or data parity error",	/* Code 16: Cache error */
	"data bus parity error",	/* Code 17: Read error */
	"data bus error (NXM)",		/* Code 18: Write error */
	"undefined data bus state",	/* Code 19: Bus error */
};
#define MC43_MAX	19

static int ka43_error_count = 0;

int
ka43_mchk(addr)
	caddr_t addr;
{
	register struct ka43_mcframe *mcf = (void *)addr;

	mtpr(0x00, PR_MCESR);	/* Acknowledge the machine check */
	printf("machine check %d (0x%x)\n", mcf->mc43_code, mcf->mc43_code);
	printf("reason: %s\n", ka43_mctype[mcf->mc43_code & 0xff]);
	if (++ka43_error_count > 10) {
		printf("error_count exceeded: %d\n", ka43_error_count);
		return (-1);
	}

	/*
	 * If either the Restart flag is set or the First-Part-Done flag
	 * is set, and the TRAP2 (double error) bit is not set, then the
	 * error is recoverable.
	 */
	if (mfpr(PR_PCSTS) & KA43_PCS_TRAP2) {
		printf("TRAP2 (double error) in ka43_mchk.\n");
		panic("unrecoverable state in ka43_mchk.");
		return (-1);
	}
	if ((mcf->mc43_code & KA43_MC_RESTART) || 
	    (mcf->mc43_psl & KA43_PSL_FPDONE)) {
		printf("ka43_mchk: recovering from machine-check.\n");
		ka43_cache_reset(0);	/* reset caches */
		return (0);		/* go on; */
	}

	/*
	 * Unknown error state, panic/halt the machine!
	 */
	printf("ka43_mchk: unknown error state!\n");
	return (-1);
}

void
ka43_memerr()
{
	/*
	 * Don\'t know what to do here. So just print some messages
	 * and try to go on...
	 */
	printf("memory error!\n");
	printf("primary cache status: %lb\n", mfpr(PR_PCSTS), KA43_PCSTS_BITS);
	printf("secondary cache status: %b\n", *ka43_creg, KA43_SESR_BITS);
}

int
ka43_cache_init()
{
	return (ka43_cache_reset(1));
}

#if 0
void
ka43_clear_errors()
{
	int val = *ka43_creg;
	val |= KA43_SESR_SERR | KA43_SESR_LERR | KA43_SESR_CERR;
	*ka43_creg = val;
}
#endif

int
ka43_cache_reset(int silent)
{
	/*
	 * resetting primary and secondary caches is done in three steps:
	 *	1. disable both caches
	 *	2. manually clear secondary cache
	 *	3. enable both caches
	 */
	ka43_cache_disable();
	ka43_cache_invalidate();
	ka43_cache_enable();

	if (silent == 0) {
		printf("primary cache status: %lb\n", mfpr(PR_PCSTS),
		    KA43_PCSTS_BITS);
		printf("secondary cache status: %b\n", *ka43_creg,
		    KA43_SESR_BITS);
	}

	return (0);
}

int
ka43_cache_disable()
{
	int val;

	/*
	 * first disable primary cache and clear error flags
	 */
	mtpr(KA43_PCS_REFRESH, PR_PCSTS);	/* disable primary cache */
	val = mfpr(PR_PCSTS);
	mtpr(val, PR_PCSTS);			/* clear error flags */

	/*
	 * now disable secondary cache and clear error flags
	 */
	val = *ka43_creg & ~KA43_SESR_CENB;	/* BICL !!! */
	*ka43_creg = val;			/* disable secondary cache */
	val = KA43_SESR_SERR | KA43_SESR_LERR | KA43_SESR_CERR;
	*ka43_creg = val;			/* clear error flags */

	return (0);
}

int
ka43_cache_invalidate()
{
	int i, val;

	val = KA43_PCTAG_PARITY;	/* clear valid flag, set parity bit */
	for (i = 0; i < 256; i++) {	/* 256 Quadword entries */
		mtpr(i*8, PR_PCIDX);	/* write index of tag */
		mtpr(val, PR_PCTAG);	/* write value into tag */
	}
	val = KA43_PCS_FLUSH | KA43_PCS_REFRESH;
	mtpr(val, PR_PCSTS);		/* flush primary cache */

	/*
	 * Rigel\'s secondary cache doesn\'t implement a valid-flag.
	 * Thus we initialize all entries with out-of-range/dummy
	 * addresses which will never be referenced (ie. never hit).
	 * After enabling cache we also access 128K of memory starting
	 * at 0x00 so that secondary cache will be filled with these
	 * valid addresses...
	 */
	val = 0xff;
	/* if (memory > 28 MB) val = 0x55; */
	for (i = 0; i < KA43_CT2_SIZE; i+= 4) {	/* Quadword entries ?? */
		ka43_ctag[i/4] = val;		/* reset upper and lower */
	}

	return (0);
}


int
ka43_cache_enable()
{
	volatile char *membase = (void *)0x80000000;	/* physical 0x00 */
	int i, val;

	val = KA43_PCS_FLUSH | KA43_PCS_REFRESH;
	mtpr(val, PR_PCSTS);		/* flush primary cache */

	/*
	 * now we enable secondary cache and access first 128K of memory
	 * so that secondary cache gets really initialized and holds
	 * valid addresses/data...
	 */
	*ka43_creg = KA43_SESR_CENB;	/* enable secondary cache */
	for (i=0; i<128*1024; i++) {
		val += membase[i];	/* some dummy operation... */
	}

	val = KA43_PCS_ENABLE | KA43_PCS_REFRESH;
	mtpr(val, PR_PCSTS);		/* enable primary cache */

	return (0);
}

void
ka43_conf()
{
	printf("cpu: KA43\n");
	ka43_cpu = (void *)vax_map_physmem(VS_REGS, 1);

	ka43_creg = (void *)vax_map_physmem(KA43_CH2_CREG, 1);
	ka43_ctag = (void *)vax_map_physmem(KA43_CT2_BASE,
	    (KA43_CT2_SIZE/VAX_NBPG));

	/*
	 * ka43_conf() gets called with MMU enabled, now it's safe to
	 * init/reset the caches.
	 */
	ka43_cache_init();

	clk_adrshift = 1;       /* Addressed at long's... */
	clk_tweak = 2;		/* ...and shift two */
	clk_page = (short *)vax_map_physmem(VS_CLOCK, 1);
}


void
ka43_init()
{
	int	val;


	/*
	 * if LANCE\'s io-buffer is above 16 MB, then the appropriate flag
	 * in the parity control register has to be set (it works as an
	 * additional address bit). In any case, don\'t enable CPEN and
	 * DPEN in the PARCTL register, somewhow they are internally managed
	 * by the RIGEL chip itself!?!
	 */
	val = ka43_cpu->parctl & 0x03;	/* read the old value */
	ka43_cpu->parctl = val;		/* and write new value */
}

static void
ka43_clrf()
{
	volatile struct ka43_clock *clk = (void *)clk_page;

	/*
	 * Clear restart and boot in progress flags in the CPMBX.
	 * The cpmbx is split into two 4-bit fields.
	 * One for the current restart/boot in progress flags, and
	 * one for the permanent halt flag.
	 * The restart/boot in progress flag is also used as the action request
	 * for the CPU at a halt. /BQT
	 */
	clk->req = 0;
}

static void
ka43_halt()
{
	volatile struct ka43_clock *clk = (void *)clk_page;

	clk->req = 3;		/* 3 is halt. */
	asm("halt");
}

static void
ka43_reboot(arg)
	int arg;
{
	volatile struct ka43_clock *clk = (void *)clk_page;

	clk->req = 2;		/* 2 is reboot. */
	asm("halt");
}

@


1.16
log
@Format string fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.15 2011/09/15 00:48:24 miod Exp $ */
@


1.15
log
@Switch vax to timecounters. There are three different clock sources:
- ICR/NICR on most systems (1MHz counter resolution).
- diagnostic timer on KA46/KA48 (1kHz counter resolution, counter is actually
  running at around 1024 kHz but is not guaranteed to be monotonic at this
  rate).
- 100Hz clock on VXT (nothing but the 100Hz clock interrupt).

Tested on KA49 (ICR style), KA46, KA48 (diagtmr style), VXT2000+ (VXT
{empty,hopeless}ness'r'us style).
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.14 2011/09/13 21:25:23 miod Exp $ */
d178 1
a178 1
	printf("primary cache status: %b\n", mfpr(PR_PCSTS), KA43_PCSTS_BITS);
d212 1
a212 1
		printf("primary cache status: %b\n", mfpr(PR_PCSTS),
@


1.14
log
@On KA43:
- silence noisy print of cache control registers at cache initialization time
  (but not during memory errors or machine checks).
- correctly access the prom mailbox register, so that halt and reboot work
  as intended (from NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.13 2011/07/06 20:42:05 miod Exp $ */
d84 1
a84 1
	hardclock
@


1.13
log
@Drop cpu_dep.cpu_subconf routine, which is no longer used after KA820 support
removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.12 2008/08/18 23:05:38 miod Exp $ */
d63 1
a63 1
static	int ka43_cache_reset(void);
d81 3
a83 3
        ka43_halt,
        ka43_reboot,
        ka43_clrf,
d159 1
a159 1
		ka43_cache_reset();	/* reset caches */
d185 1
a185 1
	return (ka43_cache_reset());
d199 1
a199 1
ka43_cache_reset()
d211 6
a216 2
	printf("primary cache status: %b\n", mfpr(PR_PCSTS), KA43_PCSTS_BITS);
	printf("secondary cache status: %b\n", *ka43_creg, KA43_SESR_BITS);
d316 2
a317 2
        clk_adrshift = 1;       /* Addressed at long's... */
        clk_tweak = 2;          /* ...and shift two */
d342 1
a342 1
        struct ka43_clock *clk = (void *)clk_page;
d344 9
a352 4
        /*
         * Clear restart and boot in progress flags in the CPMBX.
         */
        clk->cpmbx = (clk->cpmbx & ~0xf0);
d358 4
a361 2
        asm("movl $0xc, (%0)"::"r"((int)clk_page + 0x38)); /* Don't ask */
        asm("halt");
d366 1
a366 1
        int arg;
d368 4
a371 2
        asm("movl $0xc, (%0)"::"r"((int)clk_page + 0x38)); /* Don't ask */
        asm("halt");
@


1.12
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.11 2008/08/15 22:38:23 miod Exp $ */
a48 1
#include <machine/nexus.h>
a83 1
	NULL,
@


1.11
log
@Rename the cpu_dep hook ``steal_pages'' to ``init'', as it serves as an
early initialization routine (to enable caches, etc) while still running
physical, and does not allocate memory anymore.

(The irony in this is that forthcoming KA60 support actually steals pages
 in its init function...)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.10 2006/06/30 16:14:31 miod Exp $ */
d85 2
@


1.10
log
@Old typos bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.9 2002/03/14 03:16:02 millert Exp $ */
d56 1
a56 1
static	void ka43_steal_pages(void);
d74 1
a74 1
	ka43_steal_pages,
a86 5
/*
 * ka43_steal_pages() is called with MMU disabled, after that call MMU gets
 * enabled. Thus we initialize these four pointers with physical addresses,
 * but before leving ka43_steal_pages() we reset them to virtual addresses.
 */
a317 6
/*
 * The interface for communication with the LANCE ethernet controller
 * is setup in the xxx_steal_pages() routine. We decrease highest
 * available address by 64K and use this area as communication buffer.
 */

d319 1
a319 1
ka43_steal_pages()
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.8 2002/03/14 01:26:48 millert Exp $ */
d312 1
a312 1
	 * ka43_conf() gets called with MMU enabled, now it's save to
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.7 2001/11/06 19:53:17 miod Exp $ */
d92 3
a94 3
static	volatile struct	ka43_cpu   *ka43_cpu	= (void*)KA43_CPU_BASE;
static	volatile u_int	*ka43_creg = (void*)KA43_CH2_CREG;
static	volatile u_int	*ka43_ctag = (void*)KA43_CT2_BASE;
d141 1
a141 1
	register struct ka43_mcframe *mcf = (void*)addr;
d279 1
a279 1
	volatile char *membase = (void*)0x80000000;	/* physical 0x00 */
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.6 2001/09/11 20:05:25 miod Exp $ */
d55 2
a56 2
static	void ka43_conf __P((void));
static	void ka43_steal_pages __P((void));
d58 2
a59 2
static	int ka43_mchk __P((caddr_t));
static	void ka43_memerr __P((void));
d61 1
a61 1
static	void ka43_clear_errors __P((void));
d63 8
a70 8
static	int ka43_cache_init __P((void));	/* "int mapen" as argument? */
static	int ka43_cache_reset __P((void));
static	int ka43_cache_enable __P((void));
static	int ka43_cache_disable __P((void));
static	int ka43_cache_invalidate __P((void));
static  void ka43_halt __P((void));
static  void ka43_reboot __P((int));
static  void ka43_clrf __P((void));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.7 2001/11/06 19:53:17 miod Exp $ */
d55 2
a56 2
static	void ka43_conf(void);
static	void ka43_steal_pages(void);
d58 2
a59 2
static	int ka43_mchk(caddr_t);
static	void ka43_memerr(void);
d61 1
a61 1
static	void ka43_clear_errors(void);
d63 8
a70 8
static	int ka43_cache_init(void);	/* "int mapen" as argument? */
static	int ka43_cache_reset(void);
static	int ka43_cache_enable(void);
static	int ka43_cache_disable(void);
static	int ka43_cache_invalidate(void);
static  void ka43_halt(void);
static  void ka43_reboot(int);
static  void ka43_clrf(void);
d92 3
a94 3
static	volatile struct	ka43_cpu   *ka43_cpu	= (void *)KA43_CPU_BASE;
static	volatile u_int	*ka43_creg = (void *)KA43_CH2_CREG;
static	volatile u_int	*ka43_ctag = (void *)KA43_CT2_BASE;
d141 1
a141 1
	register struct ka43_mcframe *mcf = (void *)addr;
d279 1
a279 1
	volatile char *membase = (void *)0x80000000;	/* physical 0x00 */
@


1.6
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.5 2000/04/27 01:10:12 bjc Exp $ */
d42 1
a42 1
#include <vm/vm.h>
@


1.5
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.4 1999/01/11 05:12:08 millert Exp $ */
a42 1
#include <vm/vm_kern.h>
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 2
a2 2
/*	$OpenBSD: ka43.c,v 1.3 1997/09/10 12:04:46 maja Exp $ */
/*	$NetBSD: ka43.c,v 1.5 1997/04/18 18:53:38 ragge Exp $ */
d40 1
d52 1
d56 2
a57 2
void	ka43_conf __P((struct device*, struct device*, void*));
void	ka43_steal_pages __P((void));
d59 13
a71 2
int	ka43_mchk __P((caddr_t));
void	ka43_memerr __P((void));
a72 27
int	ka43_clear_errors __P((void));

int	ka43_cache_init __P((void));	/* "int mapen" as argument? */
int	ka43_cache_reset __P((void));
int	ka43_cache_enable __P((void));
int	ka43_cache_disable __P((void));
int	ka43_cache_invalidate __P((void));

static struct uc_map ka43_map[] = {
	{ KA43_CFGTST,		KA43_CFGTST,	4,		0 },
	{ KA43_ROM_BASE,	KA43_ROM_END,	KA43_ROM_SIZE,	0 },
	{ KA43_CPU_BASE,	KA43_CPU_END,	KA43_CPU_SIZE,	0 },
	{ KA43_CT2_BASE,	KA43_CT2_END,	KA43_CT2_SIZE,	0 },
	{ KA43_CH2_CREG,	KA43_CH2_CREG,	4,		0 },
	{ KA43_NWA_BASE,	KA43_NWA_END,	KA43_NWA_SIZE,	0 },
	{ KA43_SER_BASE,	KA43_SER_END,	KA43_SER_SIZE,	0 },
	{ KA43_WAT_BASE,	KA43_WAT_END,	KA43_WAT_SIZE,	0 },
	{ KA43_SCS_BASE,	KA43_SCS_END,	KA43_SCS_SIZE,	0 },
	{ KA43_LAN_BASE,	KA43_LAN_END,	KA43_LAN_SIZE,	0 },
	{ KA43_CUR_BASE,	KA43_CUR_END,	KA43_CUR_SIZE,	0 },
	{ KA43_DMA_BASE,	KA43_DMA_END,	KA43_DMA_SIZE,	0 },
	{ KA43_VME_BASE,	KA43_VME_END,	KA43_VME_SIZE,	0 },
	/*
	 * there's more to come, eg. framebuffers (GPX/SPX)
	 */
	{0, 0, 0, 0},
};
a75 1
	no_nicr_clock,
d82 4
a85 4
	(void*)KA43_INTREQ,
	(void*)KA43_INTCLR,
	(void*)KA43_INTMSK,
	ka43_map,
d93 3
a95 4
struct	ka43_cpu   *ka43_cpu	= (void*)KA43_CPU_BASE;

u_int	*ka43_creg = (void*)KA43_CH2_CREG;
u_int	*ka43_ctag = (void*)KA43_CT2_BASE;
d154 1
a154 1
	 * is set, and the TRAP2 (double error) bit is not set, the the
d194 2
a195 1
int
d202 1
a218 2
	printf("cpu status: parctl=0x%x, hltcod=0x%x\n", 
	       ka43_cpu->parctl, ka43_cpu->hltcod);
d226 1
a226 1
	int i, val;
a268 1
	printf("clearing tags...\n");
d303 4
a306 13
ka43_conf(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
{
	extern char cpu_model[];
	extern int vax_siedata;

	if (vax_siedata & 0x02)		/* "single-user" flag */
		strcpy(cpu_model,"VAXstation 3100 model 76");
	else if (vax_siedata & 0x01)	/* "multiuser" flag */
		strcpy(cpu_model,"MicroVAX 3100 model 76(?)");
	else
		strcpy(cpu_model, "unknown KA43 board");
d308 3
a310 1
	printf(": %s\n", cpu_model);
d317 4
a328 2
u_long le_iomem;		/* base addr of RAM -- CPU's view */
u_long le_ioaddr;		/* base addr of RAM -- LANCE's view */
d333 1
a333 15
	extern	vm_offset_t avail_start, virtual_avail, avail_end;
        extern  short *clk_page;
        extern  int clk_adrshift, clk_tweak;
	int	junk, val;
	int	i;

	printf ("ka43_steal_pages: avail_end=0x%x\n", avail_end);

	/* 
	 * SCB is already copied/initialized at addr avail_start
	 * by pmap_bootstrap(), but it's not yet mapped. Thus we use
	 * the MAPPHYS() macro to reserve these two pages and to
	 * perform the mapping. The mapped address is assigned to junk.
	 */
	MAPPHYS(junk, 2, VM_PROT_READ|VM_PROT_WRITE);
a334 44
        clk_adrshift = 1;       /* Addressed at long's... */
        clk_tweak = 2;          /* ...and shift two */
        MAPVIRT(clk_page, 2);
        pmap_map((vm_offset_t)clk_page, (vm_offset_t)KA43_WAT_BASE,
            (vm_offset_t)KA43_WAT_BASE + NBPG, VM_PROT_READ|VM_PROT_WRITE);

#if 0
	/*
	 * At top of physical memory there are some console-prom and/or
	 * restart-specific data. Make this area unavailable.
	 */
	avail_end -= 64 * NBPG;		/* scratch RAM ??? */
	avail_end = 0x00FC0000;		/* XXX: for now from ">>> show mem" */

This is no longer neccessary since the memsize in RPB does not include
these unavailable pages. Only valid/available pages are counted in RPB.

#endif

	/*
	 * If we need to map physical areas also, we can decrease avail_end
	 * (the highest available memory-address), copy the stuff into the
	 * gap between and use pmap_map to map it. This is done for LANCE's
	 * 64K communication area.
	 *
	 * Don't use the MAPPHYS macro here, since this uses and changes(!)
	 * the value of avail_start. Use MAPVIRT even if it's name misleads.
	 */
	avail_end -= (64 * 1024);	/* reserve 64K */
	avail_end &= ~0xffff;		/* force proper (quad?) alignment */

	/*
	 * Oh holy shit! It took me over one year(!) to find out that
	 * the 3100/76 has to use diag-mem instead of physical memory
	 * for communication with LANCE (using phys-mem results in
	 * parity errors and mchk exceptions with code 17 (0x11)).
	 *
	 * Many thanks to Matt Thomas, without his help it could have
	 * been some more years...  ;-)
	 */
	le_ioaddr = avail_end | KA43_DIAGMEM;	/* ioaddr in diag-mem!!! */
	MAPVIRT(le_iomem, (64 * 1024)/NBPG);
	pmap_map((vm_offset_t)le_iomem, le_ioaddr, le_ioaddr + 0xffff,
		 VM_PROT_READ|VM_PROT_WRITE);
a343 2
	if (le_ioaddr & (1 << 24))	/* if RAM above 16 MB */
		val |= KA43_PCTL_DMA;	/* set LANCE DMA flag */
d345 1
a345 1
	le_ioaddr &= 0xffffff;		/* Lance uses 24-bit addresses */
d347 4
a350 4
	/*
	 * now map in anything listed in ka43_map...
	 */
	uvax_fillmap();
d352 5
a356 5
	/*
	 * Clear restart and boot in progress flags in the CPMBX. 
	 */
	((struct ka43_clock *)KA43_WAT_BASE)->cpmbx =
	    ((struct ka43_clock *)KA43_WAT_BASE)->cpmbx & 0xF0;
d358 6
a363 7
#if 0
	/*
	 * Clear all error flags, not really neccessary here, this will
	 * be done by ka43_cache_init() anyway...
	 */
	ka43_clear_errors();
#endif
d365 6
a370 7
	/*
	 * MM is not yet enabled, thus we still used the physical addresses,
	 * but before leaving this routine, we need to reset them to virtual.
	 */
	ka43_cpu    = (void*)uvax_phys2virt(KA43_CPU_BASE);
	ka43_creg   = (void*)uvax_phys2virt(KA43_CH2_CREG);
	ka43_ctag   = (void*)uvax_phys2virt(KA43_CT2_BASE);
d372 1
@


1.4.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: ka43.c,v 1.5 2000/04/27 01:10:12 bjc Exp $ */
/*	$NetBSD: ka43.c,v 1.19 1999/09/06 19:52:53 ragge Exp $ */
a39 1
#include <sys/systm.h>
a50 1
#include <machine/vsbus.h>
d54 2
a55 2
static	void ka43_conf __P((void));
static	void ka43_steal_pages __P((void));
d57 2
a58 13
static	int ka43_mchk __P((caddr_t));
static	void ka43_memerr __P((void));
#if 0
static	void ka43_clear_errors __P((void));
#endif
static	int ka43_cache_init __P((void));	/* "int mapen" as argument? */
static	int ka43_cache_reset __P((void));
static	int ka43_cache_enable __P((void));
static	int ka43_cache_disable __P((void));
static	int ka43_cache_invalidate __P((void));
static  void ka43_halt __P((void));
static  void ka43_reboot __P((int));
static  void ka43_clrf __P((void));
d60 27
d90 1
d97 4
a100 4
	2,	/* SCB pages */
        ka43_halt,
        ka43_reboot,
        ka43_clrf,
d108 4
a111 3
static	volatile struct	ka43_cpu   *ka43_cpu	= (void*)KA43_CPU_BASE;
static	volatile u_int	*ka43_creg = (void*)KA43_CH2_CREG;
static	volatile u_int	*ka43_ctag = (void*)KA43_CT2_BASE;
d170 1
a170 1
	 * is set, and the TRAP2 (double error) bit is not set, then the
d210 1
a210 2
#if 0
void
a216 1
#endif
d233 2
d242 1
a242 1
	int val;
d285 1
d320 13
a332 4
ka43_conf()
{
	printf("cpu: KA43\n");
	ka43_cpu = (void *)vax_map_physmem(VS_REGS, 1);
d334 1
a334 3
	ka43_creg = (void *)vax_map_physmem(KA43_CH2_CREG, 1);
	ka43_ctag = (void *)vax_map_physmem(KA43_CT2_BASE,
	    (KA43_CT2_SIZE/VAX_NBPG));
a340 4

        clk_adrshift = 1;       /* Addressed at long's... */
        clk_tweak = 2;          /* ...and shift two */
	clk_page = (short *)vax_map_physmem(VS_CLOCK, 1);
d349 2
d355 15
a369 1
	int	val;
d371 44
d424 2
d427 1
a427 1
}
d429 4
a432 4
static void
ka43_clrf()
{
        struct ka43_clock *clk = (void *)clk_page;
d434 5
a438 5
        /*
         * Clear restart and boot in progress flags in the CPMBX.
         */
        clk->cpmbx = (clk->cpmbx & ~0xf0);
}
d440 7
a446 6
static void
ka43_halt()
{
        asm("movl $0xc, (%0)"::"r"((int)clk_page + 0x38)); /* Don't ask */
        asm("halt");
}
d448 7
a454 6
static void
ka43_reboot(arg)
        int arg;
{
        asm("movl $0xc, (%0)"::"r"((int)clk_page + 0x38)); /* Don't ask */
        asm("halt");
a455 1

@


1.4.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.4.6.1 2001/05/14 21:38:54 niklas Exp $ */
d43 1
@


1.4.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d42 1
a42 1
#include <uvm/uvm_extern.h>
@


1.4.6.4
log
@Merge in -current from about a week ago
@
text
@d55 2
a56 2
static	void ka43_conf(void);
static	void ka43_steal_pages(void);
d58 2
a59 2
static	int ka43_mchk(caddr_t);
static	void ka43_memerr(void);
d61 1
a61 1
static	void ka43_clear_errors(void);
d63 8
a70 8
static	int ka43_cache_init(void);	/* "int mapen" as argument? */
static	int ka43_cache_reset(void);
static	int ka43_cache_enable(void);
static	int ka43_cache_disable(void);
static	int ka43_cache_invalidate(void);
static  void ka43_halt(void);
static  void ka43_reboot(int);
static  void ka43_clrf(void);
d92 3
a94 3
static	volatile struct	ka43_cpu   *ka43_cpu	= (void *)KA43_CPU_BASE;
static	volatile u_int	*ka43_creg = (void *)KA43_CH2_CREG;
static	volatile u_int	*ka43_ctag = (void *)KA43_CT2_BASE;
d141 1
a141 1
	register struct ka43_mcframe *mcf = (void *)addr;
d279 1
a279 1
	volatile char *membase = (void *)0x80000000;	/* physical 0x00 */
@


1.3
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ka43.c,v 1.2 1997/05/29 00:05:20 niklas Exp $ */
d175 1
a175 1
		panic("unrecoverable state in ka43_mchk.\n");
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: ka43.c,v 1.3 1996/10/13 03:35:43 christos Exp $ */
/*	$NetBSD: ka43.c,v 1.3 1996/10/13 03:35:43 christos Exp $ */
d19 2
a20 2
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
d45 1
a52 3
#include <machine/ka650.h>	/* cache ??? */

#define	xtrace(x)
d57 1
a58 1
int	ka43_mchk __P((caddr_t));
d60 1
a60 2
struct	ka43_cpu   *ka43_cpuptr = (void*)KA43_CPU_BASE;
struct	ka43_clock *ka43_clkptr = (void*)KA43_WAT_BASE;
d62 5
a66 1
extern int uVAX_fillmap __P((struct uc_map *));
d68 1
a68 1
struct uc_map ka43_map[] = {
d88 14
a101 3
#define CH1_BITS \
	"\020\015BCHIT\014BUSERR\013PPERR\012DPERR\011TPERR\010TRAP1" \
	"\007TRAP2\006INTR\005HIT\004REFRESH\003FLUSH\002ENABLE\001FORCEHIT"
d103 6
a108 2
#define CH2_BITS \
	"\020\010TPE\007DPE\006MISS\005DIRTY\004CERR\003LERR\002SERR\001ENAB"
d110 2
a111 5
void
ka43_memerr()
{
	int mapen;
	int *ch2reg;
d113 2
a114 2
	printf("memory error!\n");
	printf("primary cache status: %b\n", mfpr(PR_PCSTS), CH1_BITS);
d116 11
a126 7
	mapen = mfpr(PR_MAPEN);
	if (mapen) 
		ch2reg = (void*)uvax_phys2virt(KA43_CH2_CREG);
	else 
		ch2reg = (void*)KA43_CH2_CREG;
	printf("secondary cache status: %b\n", *ch2reg, CH2_BITS);
}
d128 8
a135 8
static char *mcc43[] = {
	"no error (0)",
	"FPA signalled protocoll error",
	"FPA signalled illegal opcode",
	"FPA detected parity error",
	"FPA returned unknown status",
	"FPA result has parity error",
	"unused (6)",
d137 1
a137 1
	"MMU error (TLB miss)",
d139 2
a140 2
	"HW interrupt at unused IPL",
	"impossible microcode state",
d143 1
a143 1
	"unused (14)",
d145 4
a148 4
	"PC tag or data parity error",
	"data bus parity error",
	"data bus error (NXM)",
	"undefined data bus state",
d150 3
d158 9
a166 19
	struct {
	  int bcount;	/* byte count (0x18) */
	  int mcc;	/* "R"-flag and machine check code */
	  int mrva;	/* most recent virtual address */
	  int viba;	/* contents of VIBA register */
	  int sisr;	/* ICCS bit 6 and SISR bits 15:0 */
	  int isd;	/* internal state */
	  int scr;	/* shift count register */
	  int pc;	/* program counter */
	  int psl;	/* processor status longword */
	} *p = (void*)addr;

	printf("machine check: 0x%x\n", p->mcc);
	printf("reason: %s\n", mcc43[p->mcc & 0xff]);

	printf("bcount:0x%x, check-code:0x%x, virtaddr:0x%x\n",
	       p->bcount, p->mcc, p->mrva);
	printf("pc:0x%x, psl:0x%x, viba: %x, state: %x\n",
	       p->pc, p->psl, p->viba, p->isd);
d168 21
d192 12
d205 1
a205 3
ka43_setup(uc,flags)
	struct uvax_calls *uc;
	int flags;
d207 2
a208 1
	uc->uc_name = "ka43";
d210 7
a216 2
	uc->uc_phys2virt = NULL;
	uc->uc_physmap = ka43_map;
d218 20
a237 4
	uc->uc_steal_pages = ka43_steal_pages;
	uc->uc_conf = ka43_conf;
	uc->uc_clkread = ka43_clkread;
	uc->uc_clkwrite = ka43_clkwrite;
d239 4
a242 2
	uc->uc_memerr = ka43_memerr;
	uc->uc_mchk = ka43_mchk;
d244 14
a257 3
	uc->uc_intreq = (void*)KA43_INTREQ;
	uc->uc_intclr = (void*)KA43_INTCLR;
	uc->uc_intmsk = (void*)KA43_INTMSK;
d259 1
a259 1
	uc->uc_busTypes = VAX_VSBUS;
d262 2
a263 1
ka43_discache()
d265 1
a265 4
	int *ctag;
	int *creg;
	int mapen;
	int i;
d267 7
a273 2
	xtrace(("ka43_discache()\n"));
	return (0);
d276 12
a287 22
	 * first disable primary cache
	 */
#if 0
	mtpr(0, PR_PCSTS);
	mtpr(0, PR_PCERR);
	mtpr(0, PR_PCIDX);
	mtpr(0, PR_PCTAG);
#else
	i = mfpr(PR_PCSTS);
	mtpr((i & ~2), PR_PCSTS);
	printf("pcsts: %x --> %x\n", i, mfpr(PR_PCSTS));
#endif
	/*
	 * now secondary cache
	 */
	mapen = mfpr(PR_MAPEN);
	if (mapen) {
		ctag = (void*)uvax_phys2virt(KA43_CT2_BASE);
		creg = (void*)uvax_phys2virt(KA43_CH2_CREG);
	} else {
		ctag = (void*)KA43_CT2_BASE;
		creg = (void*)KA43_CH2_CREG;
d289 2
a290 5
	i = *creg;
	*creg = (i & ~1);
	printf("creg: %x --> %x\n", i, *creg);
	
	xtrace(("ka43_discache() done.\n"));
d293 3
a295 1
ka43_encache()
d297 5
a301 23
	int *ctag;
	int *creg;
	int mapen;
	int i;

	xtrace(("ka43_encache()\n"));

	ka43_discache();

	/*
	 * first enable primary cache
	 */
	printf("P-0");
	i = mfpr(PR_PCSTS);
	mtpr((i & ~2), PR_PCSTS);
	mtpr(0, PR_PCSTS);
	printf("P-1");
#if 1
	mtpr(KA43_PCS_ENABLE | KA43_PCS_FLUSH | KA43_PCS_REFRESH, PR_PCSTS);
#else
	mtpr(KA43_PCS_ENABLE, PR_PCSTS);
#endif
	printf("P-2");
d304 3
a306 1
	 * now secondary cache
d308 3
a310 7
	mapen = mfpr(PR_MAPEN);
	if (mapen) {
		ctag = (void*)uvax_phys2virt(KA43_CT2_BASE);
		creg = (void*)uvax_phys2virt(KA43_CH2_CREG);
	} else {
		ctag = (void*)KA43_CT2_BASE;
		creg = (void*)KA43_CH2_CREG;
a311 20
	printf("ctag: %x, creg: %x\n", ctag, creg);
	printf("S-1");
	i = *creg;
	printf("creg=[%x] ", *creg);
#if 0
	*creg = (i & ~1);
	printf("creg=[%x] ", *creg);
	printf("S-2");
	for (i = 0; i < KA43_CT2_SIZE; i += 4)		/* Quadword entries */
		ctag[i/4] = 0;				/* reset lower half */
	printf("S-3");
	i = *creg;
	printf("creg=[%x] ", *creg);
	*creg = (i & ~1);
	printf("creg=[%x] ", *creg);
	printf("S-4");
	/* *creg = 1; */
	printf("S-5");
#endif
	xtrace(("ka43_encache() done.\n"));
d313 4
a316 2
	printf("primary cache status: %b\n", mfpr(PR_PCSTS), CH1_BITS);
	printf("secondary cache status: %b\n", *creg, CH2_BITS);
d336 5
a340 1
	ka43_encache();
d345 3
a347 1
 *
d355 4
a358 2
	extern  vm_offset_t avail_start, virtual_avail, avail_end;
	int	junk;
a359 40
	struct {
	  u_long     :2;
	  u_long data:8;
	  u_long     :22;
	} *p;
	int *srp;	/* Scratch Ram */
	int *pctl;	/* parity control register */
	char *q = (void*)&srp;
	char line[20];

	ka43_encache();

	pctl = (void*)KA43_PARCTL;
	printf("parctl: 0x%x\n", *pctl);
#if 0
	*pctl = KA43_PCTL_DPEN | KA43_PCTL_CPEN;
#else
	*pctl = KA43_PCTL_CPEN;
#endif
	printf("new value for parctl: ");
	gets(line);
	*pctl = *line - '0';
	printf("parctl: 0x%x\n", *pctl);

	srp = NULL;
	p = (void*)KA43_SCR;
	for (i=0; i<4; i++) {
	  printf("p[%d] = %x, ", i, p[i].data);
	  q[i]  = p[i].data;
	}
	p = (void*)KA43_SCRLEN;
	printf("\nlen = %d\n", p->data);
	printf("srp = 0x%x\n", srp);

	for (i=0; i<0x2; i++) {
	  printf("%x:0x%x ", i*4, srp[i]);
	  if ((i & 0x07) == 0x07)
	    printf("\n");
 	}
	printf("\n");
d371 7
d382 6
a387 2
#if 1
	avail_end -= 10 * NBPG;
d393 2
a394 1
	 * gap between and use pmap_map to map it...
d399 2
a400 5
	avail_end &= ~0xffff;
	avail_end -= (64 * 1024);

	avail_end = 0xf00000;
	le_ioaddr = 0xf40000;
d402 10
d416 12
a427 6
	if (1 || le_ioaddr > 0xffffff) {
		le_ioaddr &= 0xffffff;
		*pctl |= KA43_PCTL_DMA;
	}
	printf("le_iomem: %x, le_ioaddr: %x, parctl:%x\n",
	       le_iomem, le_ioaddr, *pctl);
d432 1
a432 1
	uVAX_fillmap(ka43_map);
d437 2
a438 1
	ka43_clkptr->cpmbx = ka43_clkptr->cpmbx & 0xF0;
d440 1
d442 2
a443 1
	 * Enable memory parity error detection and clear error bits.
d445 2
a446 2
	ka43_cpuptr->ka43_mser = 0x01; 
	/* (UVAXIIMSER_PEN | UVAXIIMSER_MERR | UVAXIIMSER_LEB); */
d452 3
a454 4
	ka43_cpuptr = (void*)uvax_phys2virt(KA43_CPU_BASE);
	ka43_clkptr = (void*)uvax_phys2virt(KA43_WAT_BASE);

	printf ("steal_pages done.\n");
a455 15

/*
 * define what we need and overwrite the uVAX_??? names
 */

#define NEED_UVAX_GENCLOCK
#define NEED_UVAX_PROTOCLOCK

#define uVAX_clock	ka43_clock
#define uVAX_clkptr	ka43_clkptr
#define uVAX_clkread	ka43_clkread
#define uVAX_clkwrite	ka43_clkwrite
#define uVAX_genclock	ka43_genclock

#include <arch/vax/vax/uvax_proto.c>
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
