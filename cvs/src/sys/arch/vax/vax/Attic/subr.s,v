head	1.31;
access;
symbols
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.4
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.4
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.17
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.31
date	2010.05.29.14.08.22;	author deraadt;	state dead;
branches;
next	1.30;

1.30
date	2009.08.19.19.47.53;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.20.21.02.15;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.21.19.42.07;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.16.05.19.15;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.10.17.59.27;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.06.21.31.37;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.19.20.38.33;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.06.18.55.02;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.13.21.49.22;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.09.22.27.11;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.11.09.36.24;	author hugh;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.23.23.24.40;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.06.15.22.45.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.16.22.15.18;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.16.03.11.00;	author bjc;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.11.12.59.40;	author bjc;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.08.04.25.13;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.10.18.25.27;	author bjc;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.05.11.03.05;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.27.01.10.13;	author bjc;	state Exp;
branches;
next	1.6;

1.6
date	97.09.10.12.04.52;	author maja;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	97.05.29.00.05.25;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.09.10.24;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.31.05.15.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2001.05.14.21.39.11;	author niklas;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2001.07.04.10.24.46;	author niklas;	state Exp;
branches;
next	1.6.12.3;

1.6.12.3
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.6.12.4;

1.6.12.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.6.12.5;

1.6.12.5
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.6.12.6;

1.6.12.6
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	1.6.12.7;

1.6.12.7
date	2004.06.07.15.58.33;	author tedu;	state Exp;
branches;
next	;

1.15.4.1
date	2002.01.31.22.55.27;	author niklas;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@merge subr.s into locore.S, which requires a fairly complicated dance
mixing and matching the various styles of *ENTRY* macros
prescribed by miod, ok ragge, tested by jasper
@
text
@/*	$OpenBSD: subr.s,v 1.30 2009/08/19 19:47:53 miod Exp $     */
/*	$NetBSD: subr.s,v 1.32 1999/03/25 00:41:48 mrg Exp $	   */

/*
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <machine/asm.h>

#include "assym.h"
#ifdef COMPAT_ULTRIX
#include <compat/ultrix/ultrix_syscall.h>
#endif

#define JSBENTRY(x)	.globl x ; .align 2 ; x :

		.text

/*
 * First entry routine from boot. This should be in a file called locore.
 */
ASENTRY(start, 0)
	bisl3	$0x80000000,r9,_esym		# End of loaded code
	pushl	$0x1f0000			# Push a nice PSL
	pushl	$to				# Address to jump to
	rei					# change to kernel stack
to:	movw	$0xfff,_panic			# Save all regs in panic
	moval	_end, r0			# Get kernel end address
	addl2	$0x3ff, r0			# Round it up
	cmpl	_esym, r0			# Compare with symbol table end
	bleq	eskip				# Symbol table not present
	addl3	_esym, $0x3ff, r0		# Use symbol end and round
eskip:
	bicl3	$0x3ff,r0,_proc0paddr		# save proc0 uarea pointer
	bicl3	$0x80000000,_proc0paddr,r0	# get phys proc0 uarea addr
	mtpr	r0,$PR_PCBB			# Save in IPR PCBB
	addl3	$USPACE,_proc0paddr,r0		# Get kernel stack top
	mtpr	r0,$PR_KSP			# put in IPR KSP
	movl	r0,_Sysmap			# SPT start addr after KSP

# Set some registers in known state
	movl	_proc0paddr,r0
	clrl	P0LR(r0)
	clrl	P1LR(r0)
	mtpr	$0,$PR_P0LR
	mtpr	$0,$PR_P1LR
	movl	$0x80000000,r1
	movl	r1,P0BR(r0)
	movl	r1,P1BR(r0)
	mtpr	r1,$PR_P0BR
	mtpr	r1,$PR_P1BR
	clrl	IFTRAP(r0)
	mtpr	$0,$PR_SCBB

# Copy the RPB to its new position
#if 1 /* compat with old bootblocks */
	tstl	(ap)				# Any arguments?
	bneq	1f				# Yes, called from new boot
	movl	r11,_boothowto			# Howto boot (single etc...)
#	movl	r10,_bootdev			# uninteresting, will complain
	movl	r8,_avail_end			# Usable memory (from VMB)
	clrl	-(sp)				# Have no RPB
	brb	2f
#endif

1:	pushl	4(ap)				# Address of old rpb
2:	calls	$1,_start			# Jump away.
	/* NOTREACHED */


/*
 * Signal handler code.
 */

		.globl	_sigcode,_esigcode
_sigcode:	
		movl	0x0c(sp),r0	/* get signal handler */
		calls	$3,(r0)		/* and call it */
		chmk	$SYS_sigreturn	/* sigreturn frame set up by sendsig */
		chmk	$SYS_exit
		halt	
		.align	2
_esigcode:

#ifdef COMPAT_ULTRIX
		.globl	_ultrix_sigcode,_ultrix_esigcode
_ultrix_sigcode:	pushr	$0x3f
		subl2	$0xc,sp
		movl	0x24(sp),r0
		calls	$3,(r0)
		popr	$0x3f
		chmk	$ULTRIX_SYS_sigreturn
		chmk	$SYS_exit
		halt	
		.align	2
_ultrix_esigcode:
#endif

		.globl	_idsptch, _eidsptch
_idsptch:	pushr	$0x3f
		.word	0x9f16		# jsb to absolute address
		.long	_cmn_idsptch	# the absolute address
		.long	0		# the callback interrupt routine
		.long	0		# its argument
		.long	0		# ptr to correspond evcount struct
_eidsptch:

_cmn_idsptch:
		movl	(sp)+,r0	# get pointer to idspvec
		movl	8(r0),r1	# get evcount pointer
		beql	1f		# no ptr, skip increment
		incl	EC_COUNT(r1)	# increment low longword
		adwc	$0,EC_COUNT+4(r1) # add any carry to hi longword
1:		pushl	4(r0)		# push argument
		calls	$1,*(r0)	# call interrupt routine
		popr	$0x3f		# pop registers
		rei			# return from interrut

ENTRY(badaddr,R2|R3)			# Called with addr,b/w/l
		mfpr	$0x12,r0	# splhigh()
		mtpr	$0x1f,$0x12
		movl	4(ap),r2	# First argument, the address
		movl	8(ap),r1	# Sec arg, b,w,l
		pushl	r0		# Save old IPL
		clrl	r3
		movab	4f,_memtest	# Set the return address

		caseb	r1,$1,$4	# What is the size
1:		.word	1f-1b		
		.word	2f-1b
		.word	3f-1b		# This is unused
		.word	3f-1b
		
1:		movb	(r2),r1		# Test a byte
		brb	5f

2:		movw	(r2),r1		# Test a word
		brb	5f

3:		movl	(r2),r1		# Test a long
		brb	5f

4:		incl	r3		# Got machine chk => addr bad
5:		mtpr	(sp)+,$0x12
		movl	r3,r0
		ret

#ifdef DDB
/*
 * DDB is the only routine that uses setjmp/longjmp.
 */
ENTRY(setjmp, 0)
	movl	4(ap), r0
	movl	8(fp), (r0)
	movl	12(fp), 4(r0)
	movl	16(fp), 8(r0)
	addl3	fp,$28,12(r0)
	clrl	r0
	ret

ENTRY(longjmp, 0)
	movl	4(ap), r1
	movl	$1, r0
	movl	(r1), ap
	movl	4(r1), fp
	movl	12(r1), sp
	jmp	*8(r1)
#endif 

#
# void
# cpu_switchto(struct proc *oldproc = r0, struct proc *newproc = r1);
#

#define CURPROC _cpu_info_store + CI_CURPROC

JSBENTRY(__cpu_switchto)
	svpctx

	movb	$SONPROC,P_STAT(r1)	# p->p_stat = SONPROC
	movl	r1, CURPROC		# set new process running

	movl	P_ADDR(r1),r0		# Get pointer to new pcb.
	addl3	r0,$IFTRAP,pcbtrap	# Save for copy* functions.

	# inline kvtophys
	extzv	$9,$21,r0,r1		# extract offset
	movl	*_Sysmap[r1],r2		# get pte
	ashl	$9,r2,r3		# shift to get phys address.

#
# Do the actual process switch. pc + psl are already on stack, from
# the beginning of this routine.
#
	mtpr	r3,$PR_PCBB

	pushl	CURPROC
	calls	$1, _C_LABEL(pmap_activate)

	ldpctx
	rei

#
# copy/fetch/store routines. 
#
	.align 2,1
ENTRY(copyin, R2|R3|R4|R5|R6)
	movl	4(ap), r0
	blss	3f		# kernel space
	movl	8(ap), r1
	brb	2f

ENTRY(copyout, R2|R3|R4|R5|R6)
	movl	8(ap), r1
	blss	3f		# kernel space
	movl	4(ap), r0
2:	movab	1f,*pcbtrap
	movzwl	12(ap), r2
	movzwl	14(ap), r6

	movc3	r2, (r0), (r1)
	
	tstl	r6
	bleq	1f
0:	movb	(r1)+, (r3)+
	movc3	$0xffff, (r1), (r3)
	sobgtr	r6,0b
	
1:	clrl	*pcbtrap
	ret

3:	movl	$EFAULT, r0
	ret

/* kcopy:  just like bcopy, except return -1 upon failure */	
ENTRY(kcopy,R2|R3|R4|R5|R6)
	movl	*pcbtrap,-(sp)
	movab	2f,*pcbtrap
	movl	4(ap), r0
	movl	8(ap), r1
	movzwl	12(ap), r2
	movzwl	14(ap), r6

	movc3	r2, (r0), (r1)
	
	tstl	r6
	bleq	1f
0:	movb	(r1)+, (r3)+
	movc3	$0xffff, (r1), (r3)
	sobgtr	r6, 0b
	
	/* 
	 * If there is a failure, trap.c will set r1 to -1, and jump
	 * to the following 2.  If not, we return 0.  We duplicate a 
	 * minuscule amount of code in the interest of speed; movc3
	 * sets r0 to 0 anyway.
	 */
1:
	movl	(sp)+,*pcbtrap
	ret
	
2:	movl	(sp)+,*pcbtrap
	movl	r1,r0
	ret

ENTRY(copyinstr,0)
	tstl	4(ap)		# is from a kernel address?
	bgeq	8f		# no, continue

6:	movl	$EFAULT,r0
	ret

ENTRY(copyoutstr,0)
	tstl	8(ap)		# is to a kernel address?
	bgeq	8f		# no, continue
	brb	6b

ENTRY(copystr,0)
8:	movl	4(ap),r4	# from
	movl	8(ap),r5	# to
	movl	16(ap),r3	# copied
	movl	12(ap),r2	# len

	bneq	1f		# nothing to copy?
	movl	$ENAMETOOLONG,r0
	tstl	r3
	beql	0f
	movl	$0,(r3)
0:	ret

1:	movab	2f,*pcbtrap

/*
 * This routine consists of two parts: One is for MV2 that doesn't have
 * locc in hardware, the other is a fast version with locc. But because
 * locc only handles <64k strings, we default to the slow version if the
 * string is longer.
 */
	cmpl	_vax_cputype,$VAX_TYP_UV2
	bneq	4f		# Check if locc emulated

9:	movl	r2,r0
7:	movb	(r4)+,(r5)+
	beql	6f		# end of string
	sobgtr	r0,7b		# no null byte in the len first bytes?
	brb 1f

6:	tstl	r3
	beql	5f
	incl	r2
	subl3	r0,r2,(r3)
5:	clrl	r0
	clrl	*pcbtrap
	ret

4:	cmpl	r2,$65535	# maxlen < 64k?
	blss	8f		# then use fast code.

	locc	$0,$65535,(r4)	# is strlen < 64k?
	beql	9b		# No, use slow code
	subl3	r0,$65535,r1	# Get string len
	brb	0f		# do the copy

8:	locc	$0,r2,(r4)	# check for null byte
	beql	1f

	subl3	r0,r2,r1	# Calculate len to copy
0:	incl	r1		# Copy null byte also
	tstl	r3
	beql	3f
	movl	r1,(r3)		# save len copied
3:	movc3	r1,(r4),(r5)
	brb	4f

1:	movl	$ENAMETOOLONG,r0
2:	movab	4f,*pcbtrap	# if we fault again, don't resume there
	subl3	8(ap),r5,r1	# did we write to the string?
	beql	3f
	decl	r5
3:	movb	$0,(r5)		# null terminate the output string
	tstl	r3
	beql	4f
	incl	r1		# null byte accounts for outlen...
	movl	r1,(r3)		# save len copied
4:	clrl	*pcbtrap
	ret

#
# data department
#
	.data

_memtest:	.long 0 ; .globl _memtest	# Memory test in progress.
pcbtrap:	.long 0x800001fc; .globl pcbtrap	# Safe place
_bootdev:	.long 0; .globl _bootdev
@


1.30
log
@<machine/macros.h> would provide inline version of a few of the functions
traditionnaly found in libkern. However, the memcmp() flavour would behave
as bcmp() with only two possible return values: zero and positive non-zero.

This broke the name cache RB trees which now rely upon proper memcmp()
semantics(negative value, zero, or positive value).

Just give up on these macros and provide the same code as libc, in libkern.
As a side effect, this no longer uses the cmpc3 instruction, which is not
implemented and requires (slow) kernel emulation, on the original uVax.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.29 2009/06/20 21:02:15 miod Exp $     */
@


1.29
log
@Preserve more registers in sigcontext, and restore them in sigreturn. This
makes the sigreturn regress test pass, as well as todd@@'s ``run
sh -c "trap exit 2 3;while :; do sleep 120; done", then press ^C'' test pass.

Since userland setjmp uses sigcontext, the kernel will still support the
old layout for a while (until libc is fixed and a reasonable grace period
is over).
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.28 2008/05/21 19:42:07 miod Exp $     */
a173 44
# Have bcopy and bzero here to be sure that system files that not gets
# macros.h included will not complain.
ENTRY(bcopy,R2|R3|R4|R5|R6)
	movl	4(ap), r0
	movl	8(ap), r1
	movzwl	12(ap), r2
	movzwl	14(ap), r6

	movc3	r2, (r0), (r1)
	
	tstl	r6
	bleq	1f
0:	movb	(r1)+, (r3)+
	movc3	$0xffff, (r1), (r3)
	sobgtr	r6, 0b
	
1:	ret	

ENTRY(bzero,R2|R3|R4|R5|R6)
	movl	4(ap), r0
	movzwl	8(ap), r1
	movzwl	10(ap), r6
	
	movc5	$0, (r0), $0, r1, (r0)
	
	tstl	r6
	bleq	1f
0:	clrb	(r3)+
	movc5	$0, (r3), $0, $0xffff, (r3)
	sobgtr	r6, 0b
	
1:	ret

# cmpc3 is sometimes emulated; we cannot use it
ENTRY(bcmp, R2);
    movl    4(ap), r2
    movl    8(ap), r1
    movl    12(ap), r0
2:  cmpb    (r2)+, (r1)+
    bneq    1f
    decl    r0
    bneq    2b
1:  ret

a381 16

/*
 * Fill more than 64k of memory (used by bzero and memset).
 */
ENTRY(blkfill,R2|R3|R4|R5|R6|R7)
	movl	4(ap), r3
	movl	8(ap), r7
	movl	12(ap), r6
	jbr	2f
1:	subl2	r0, r6
	movc5	$0,(r3),r7,r0,(r3)
2:	movzwl	$65535,r0
	cmpl	r6, r0
	jgtr	1b
	movc5	$0,(r3),r7,r6,(r3)
	ret
@


1.28
log
@ddb expects the kernel longjmp() to only take a single parameter and always
return 1 since 12+ years, it's about time to fix the offending ports.

Reported by Pierre Riteau (firstname.lastname at gmail)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.27 2007/10/10 15:53:53 art Exp $     */
d102 4
a105 6
_sigcode:	pushr	$0x3f
		subl2	$0xc,sp
		movl	0x24(sp),r0
		calls	$3,(r0)
		popr	$0x3f
		chmk	$SYS_sigreturn
@


1.27
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.26 2007/05/16 05:19:15 miod Exp $     */
d235 1
a235 1
	movl	8(ap), r0
@


1.26
log
@Switch vax to __HAVE_CPUINFO, based on an incomplete diff from art.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.25 2007/05/10 17:59:27 deraadt Exp $     */
d243 2
a244 1
# setrunqueue/remrunqueue fast variants.
d247 1
a247 27
JSBENTRY(Setrq)
#ifdef DIAGNOSTIC
	tstl	4(r0)	# Check that process actually are off the queue
	beql	1f
	pushab	setrq
	calls	$1,_panic
setrq:	.asciz	"setrunqueue"
#endif
1:	extzv	$2,$6,P_PRIORITY(r0),r1 # get priority
	movaq	_qs[r1],r2		# get address of queue
	insque	(r0),*4(r2)		# put proc last in queue
	bbss	r1,_whichqs,1f		# set queue bit.
1:	rsb

JSBENTRY(Remrq)
	extzv	$2,$6,P_PRIORITY(r0),r1
#ifdef DIAGNOSTIC
	bbs	r1,_whichqs,1f
	pushab	remrq
	calls	$1,_panic
remrq:	.asciz	"remrunqueue"
#endif
1:	remque	(r0),r2
	bneq	1f		# Not last process on queue
	bbsc	r1,_whichqs,1f
1:	clrl	4(r0)		# saftey belt
	rsb
d249 2
a250 8
#
# Idle loop. Here we could do something fun, maybe, like calculating
# pi or something.
#
idle:	mtpr	$0,$PR_IPL		# Enable all types of interrupts
1:	tstl	_whichqs		# Anything ready to run?
	beql	1b			# no, continue to loop
	brb	Swtch			# Yes, goto switch again.
d252 2
a253 4
#
# cpu_switch, cpu_exit and the idle loop implemented in assembler 
# for efficiency. r0 contains pointer to last process.
#
d255 1
a255 28
#define CURPROC _cpu_info_store + CI_CURPROC

JSBENTRY(Swtch)
	clrl	CURPROC			# Stop process accounting
#bpt
	mtpr	$0x1f,$PR_IPL		# block all interrupts
	ffs	$0,$32,_whichqs,r3	# Search for bit set
	beql	idle			# no bit set, go to idle loop

	movaq	_qs[r3],r1		# get address of queue head
	remque	*(r1),r2		# remove proc pointed to by queue head
#ifdef DIAGNOSTIC
	bvc	1f			# check if something on queue
	pushab	noque
	calls	$1,_panic
noque:	.asciz	"swtch"
#endif
1:	bneq	2f			# more processes on queue?
	bbsc	r3,_whichqs,2f		# no, clear bit in whichqs
2:	clrl	4(r2)			# clear proc backpointer
	clrl	_want_resched		# we are now changing process
	movb	$SONPROC,P_STAT(r2)	# p->p_stat = SONPROC
	movl	r2,CURPROC		# set new process running
	cmpl	r0,r2			# Same process?
	bneq	1f			# No, continue
	rsb
xxd:	
1:	movl	P_ADDR(r2),r0		# Get pointer to new pcb.
d258 1
a258 3
#
# Nice routine to get physical from virtual addresses.
#
d265 1
a265 1
# the calling routine.
a266 1
	svpctx
d268 4
a273 18

#
# the last routine called by a process.
#

ENTRY(cpu_exit,0)
	movl	4(ap),r6	# Process pointer in r6
	mtpr	$0x18,$PR_IPL	# Block almost everything
	addl3	$512,_scratch,sp # Change stack, and schedule it to be freed

	pushl	r6		
	calls	$1,_exit2

	clrl	r0		# No process to switch from
	bicl3	$0xc0000000,_scratch,r1
	mtpr	r1,$PR_PCBB
	brw	Swtch

@


1.25
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.24 2006/11/06 21:31:37 miod Exp $     */
d287 3
a289 1
	
d291 1
a291 1
	clrl	_curproc		# Stop process accounting
d310 1
a310 1
	movl	r2,_curproc		# set new process running
@


1.24
log
@Let CISCoholic memset() do not behave as bzero for a length over 64KB.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.23 2006/07/19 20:38:33 miod Exp $     */
d133 1
a133 1
		.long	0		# ptr to correspond evcnt struct
d138 1
a138 1
		movl	8(r0),r1	# get evcnt pointer
@


1.23
log
@Trivial simplification in the signal delivery code; shave one instruction
from sigcode and one computation from sendsig(), isn't life great?
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.22 2005/05/06 18:55:02 miod Exp $     */
d402 1
a402 1
	 * miniscule amount of code in the interest of speed; movc3
d505 1
a505 1
 * Copy/zero more than 64k of memory (as opposite of bcopy/bzero).
d507 1
a507 14
ENTRY(blkcpy,R2|R3|R4|R5|R6)
	movl	4(ap),r1
	movl	8(ap),r3
	movl	12(ap),r6
	jbr 2f
1:	subl2	r0,r6
	movc3	r0,(r1),(r3)
2:	movzwl	$65535,r0
	cmpl	r6,r0
	jgtr	1b
	movc3	r6,(r1),(r3)
	ret

ENTRY(blkclr,R2|R3|R4|R5|R6)
d509 2
a510 1
	movl	8(ap), r6
d513 1
a513 1
	movc5	$0,(r3),$0,r0,(r3)
d517 1
a517 1
	movc5	$0,(r3),$0,r6,(r3)
@


1.22
log
@Use *ENTRY() macros for function prologues, rather than providing the
register save mask as a number.

ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.21 2004/07/07 23:10:46 deraadt Exp $     */
d102 1
a102 2
_sigcode:	addl2	$0x24, sp
		pushr	$0x3f
@


1.21
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.20 2004/06/13 21:49:22 niklas Exp $     */
d225 1
a225 2
	.globl	_setjmp, _longjmp
_setjmp:.word	0
d234 1
a234 1
_longjmp:.word	0
@


1.20
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$     */
d141 2
a142 2
		incl	EV_COUNT(r1)	# increment low longword
#		adwc	$0,EV_COUNT+4(r1) # add any carry to hi longword
@


1.19
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.18 2003/01/09 22:27:11 miod Exp $     */
d309 1
@


1.18
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.17 2002/06/11 09:36:24 hugh Exp $     */
d318 1
a318 1
# Nice routine to get physical from virtual adresses.
@


1.17
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.16 2002/01/23 23:24:40 miod Exp $     */
a493 42
	ret

ENTRY(subyte,0)
	movl	4(ap),r0
	blss	3f		# illegal space
	movab	1f,*pcbtrap
	movb	8(ap),(r0)
	clrl	r1
1:	clrl	*pcbtrap
	movl	r1,r0
	ret

ENTRY(suword,0)
	movl	4(ap),r0
	blss	3f		# illegal space
	movab	1f,*pcbtrap
	movl	8(ap),(r0)
	clrl	r1
1:	clrl	*pcbtrap
	movl	r1,r0
	ret

ENTRY(suswintr,0)
	movl	4(ap),r0
	blss	3f		# illegal space
	movab	1f,*pcbtrap
	movw	8(ap),(r0)
	clrl	r1
1:	clrl	*pcbtrap
	movl	r1,r0
	ret

3:	mnegl	$1,r0
	ret

ENTRY(fuswintr,0)
	movl	4(ap),r0
	blss	3b		# illegal space
	movab	1f,*pcbtrap
	movzwl	(r0),r1
1:	clrl	*pcbtrap
	movl	r1,r0
@


1.16
log
@copy*str() fixes for vax. Also includes some fixes from NetBSD PR #7838.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.15 2001/08/25 13:33:37 hugh Exp $     */
a48 2
	movl	r11,_boothowto			# Howto boot (single etc...)
	movl	r10,_bootdev			# From where? (see rpb.h)
a49 1
	movl	r8,_avail_end			# Usable memory (from VMB)
d81 13
a93 1
	calls	$0,_start			# Jump away.
@


1.15
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.14 2001/06/15 22:45:34 miod Exp $     */
d346 6
a351 1
ALTENTRY(copyin)
d353 2
a354 1
	movab	1f,*pcbtrap
d356 1
a356 1
	movl	8(ap), r1
d371 3
d405 14
a418 5
_copystr:	.globl	_copystr
_copyinstr:	.globl	_copyinstr
_copyoutstr:	.globl	_copyoutstr
	.word	0
	movl	4(ap),r4	# from
d420 1
a421 1
	movl	16(ap),r3	# copied
d423 8
a430 1
	movab	2f,*pcbtrap
d443 2
a444 2
	beql	6f
	sobgtr	r0,7b
d472 1
a472 1
	brb	2f
d475 10
a484 1
2:	clrl	*pcbtrap
d488 2
a490 1
	movl	4(ap),r0
d498 2
a500 1
	movl	4(ap),r0
d508 2
a510 1
	movl	4(ap),r0
d517 3
d521 2
a523 1
	movl	4(ap),r0
@


1.15.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.16 2002/01/23 23:24:40 miod Exp $     */
d346 3
a348 1
ENTRY(copyin, R2|R3|R4|R5|R6)
a349 5
	blss	3f		# kernel space
	movl	8(ap), r1
	brb	2f

ENTRY(copyout, R2|R3|R4|R5|R6)
a350 3
	blss	3f		# kernel space
	movl	4(ap), r0
2:	movab	1f,*pcbtrap
a364 3
3:	movl	$EFAULT, r0
	ret

d396 5
a400 14
ENTRY(copyinstr,0)
	tstl	4(ap)		# is from a kernel address?
	bgeq	8f		# no, continue

6:	movl	$EFAULT,r0
	ret

ENTRY(copyoutstr,0)
	tstl	8(ap)		# is to a kernel address?
	bgeq	8f		# no, continue
	brb	6b

ENTRY(copystr,0)
8:	movl	4(ap),r4	# from
d402 1
a403 1
	movl	12(ap),r2	# len
d405 1
a405 8
	bneq	1f		# nothing to copy?
	movl	$ENAMETOOLONG,r0
	tstl	r3
	beql	0f
	movl	$0,(r3)
0:	ret

1:	movab	2f,*pcbtrap
d418 2
a419 2
	beql	6f		# end of string
	sobgtr	r0,7b		# no null byte in the len first bytes?
d447 1
a447 1
	brb	4f
d450 1
a450 10
2:	movab	4f,*pcbtrap	# if we fault again, don't resume there
	subl3	8(ap),r5,r1	# did we write to the string?
	beql	3f
	decl	r5
3:	movb	$0,(r5)		# null terminate the output string
	tstl	r3
	beql	4f
	incl	r1		# null byte accounts for outlen...
	movl	r1,(r3)		# save len copied
4:	clrl	*pcbtrap
d454 1
a455 2
	blss	3f		# illegal space
	movab	1f,*pcbtrap
d463 1
a464 2
	blss	3f		# illegal space
	movab	1f,*pcbtrap
d472 1
a473 2
	blss	3f		# illegal space
	movab	1f,*pcbtrap
a479 3
3:	mnegl	$1,r0
	ret

d481 1
a482 2
	blss	3b		# illegal space
	movab	1f,*pcbtrap
@


1.15.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.15.4.1 2002/01/31 22:55:27 niklas Exp $     */
d49 2
d52 1
d84 1
a84 13
# Copy the RPB to its new position
#if 1 /* compat with old bootblocks */
	tstl	(ap)				# Any arguments?
	bneq	1f				# Yes, called from new boot
	movl	r11,_boothowto			# Howto boot (single etc...)
#	movl	r10,_bootdev			# uninteresting, will complain
	movl	r8,_avail_end			# Usable memory (from VMB)
	clrl	-(sp)				# Have no RPB
	brb	2f
#endif

1:	pushl	4(ap)				# Address of old rpb
2:	calls	$1,_start			# Jump away.
@


1.15.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$     */
d494 42
@


1.14
log
@Compile kernel with -Wall, and fix a few issues for this to work.
ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.13 2001/05/16 22:15:18 hugh Exp $     */
d121 5
a125 4
		.word	0x9f16
		.long	_cmn_idsptch
		.long	0
		.long	0
d129 9
a137 5
        movl    (sp)+,r0
        pushl   4(r0)
        calls   $1,*(r0)
        popr    $0x3f
        rei
d140 1
a140 1
		mfpr	$0x12,r0
@


1.13
log
@Blind merge of wscons support from NetBSD/vax. Perhaps someone with a
supported framebuffer (simple monochrome) can finish this off.
If anyone has run across docs for LCG or SPGFX, please get in touch.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.12 2001/03/16 03:11:00 bjc Exp $     */
a474 1
ALTENTRY(fusword)
@


1.12
log
@The length fields of MOVC3 and MOVC5 have an upper limit of 65535 bytes.
This fixes bcopy, copyin/copyout, and kcopy.  Much testing was done by hugh@@
and me to find the fastest replacement out of half a dozen candidates.

Also, correct register masks in numerous places.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.11 2001/02/11 12:59:40 bjc Exp $     */
d475 1
@


1.11
log
@Previously, when sendsig() set up the current process's context to run
sigcode to call a handler, SP was set in the middle of the struct
trapframe/struct sigcontext pair placed on the stack.  This was adequate
when only one signal is being delivered at a time, but when two signals are
delivered in one syscall, the second invocation of sendsig() overwrote
some of the first sendsig() invocation's stack data.

The result was that under certain circumstances, (e.g., sending signals to
backgrounded processes from ksh) the argument passed to signal handlers
when the second signal (the one corresponding to the first sendsig()
invocation) was delivered was bogus data from the stack.  Therefore,
programs that depended on the "sigraised" argument to be accurate
blew up.

This fix ensures that sendsig() always leaves a process's SP out of the way
of structures that will be used.  AP is not moved, though, so sigreturn
can find the args correctly.  Also, sigcode is changed to compensate for the
SP change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.10 2001/01/08 04:25:13 hugh Exp $     */
d134 1
a134 1
ENTRY(badaddr,0)			# Called with addr,b/w/l
d165 1
a165 1
ENTRY(bcopy,R2)
d168 3
a170 1
	movl	0xc(ap), r2
d172 8
a179 1
	ret
d181 1
a181 1
ENTRY(bzero,0)
d183 3
a185 1
	movl	8(ap), r1
d187 8
a194 1
	ret
d340 8
d349 8
a356 7
	.globl	_copyin, _copyout
_copyout:
_copyin:.word 0
	movab	1f,*pcbtrap
	movl	4(ap),r1
	movl	8(ap),r2
	movc3	12(ap),(r1), (r2)
d360 2
a361 1
ENTRY(kcopy,0)
d363 25
a387 6
	movab	1f,*pcbtrap
	movl	4(ap),r1
	movl	8(ap),r2
	movc3	12(ap),(r1), (r2)
	clrl	r1
1:	movl	(sp)+,*pcbtrap
d495 1
a495 1
ENTRY(blkcpy,R6)
d508 1
a508 1
ENTRY(blkclr,R6)
@


1.10
log
@Compare the end of symbol table as passed from boot with the address
of _end in the kernel, and base Sysmap on whichever is higher. This
permits stripped kernels to load despite unexpected values from libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.9 2000/10/10 18:25:27 bjc Exp $     */
d93 2
a94 1
_sigcode:	pushr	$0x3f
@


1.9
log
@correct register masks
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.8 2000/06/05 11:03:05 art Exp $     */
d57 6
a62 1
	addl3	_esym,$0x3ff,r0			# Round symbol table end
@


1.8
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.7 2000/04/27 01:10:13 bjc Exp $     */
d159 1
a159 1
ENTRY(bcopy,0)
d173 1
a173 1
ENTRY(bcmp, 0);
@


1.7
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.6 1997/09/10 12:04:52 maja Exp $     */
d304 2
a305 2
	pushl	P_VMSPACE(r6)		
	calls	$1,_uvmspace_free	
@


1.6
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*      $OpenBSD: subr.s,v 1.5 1997/05/29 00:05:25 niklas Exp $     */
/*      $NetBSD: subr.s,v 1.18 1997/03/22 23:02:13 ragge Exp $     */
d34 10
a43 2
 /* All bugs are subject to removal without further notice */
		
d45 33
a77 2
#include <sys/syscall.h>
#include <sys/errno.h>
d79 2
a80 4
#include <machine/mtpr.h>
#include <machine/vmparam.h>
#include <machine/pte.h>
#include <machine/nexus.h>
d83 3
a85 1
		.text
d94 1
d99 14
d115 4
a118 5
		pushl	$1
		nop
		calls	$1, *$0x12345678
		popr	$0x3f
		rei
d121 6
a126 8
		.globl	_subyte
_subyte:	.word 0x0
		movl	4(ap),r0
#		probew	$3,$1,(r0)
#		beql	suerr
		movb	8(ap),(r0)
		clrl	r0
		ret
d128 1
a128 15
suerr:		movl	$-1,r0
		ret

                .globl  _fubyte
_fubyte:        .word 0x0
                movl    4(ap),r0
#                prober  $3,$1,(r0)
#                beql    suerr
                movzbl	(r0),r0
                ret


		.globl _badaddr
_badaddr:	.word	0x0
					# Called with addr,b/w/l
d131 2
a132 2
		movl	4(ap),r2 	# First argument, the address
		movl	8(ap),r1 	# Sec arg, b,w,l
d135 1
a135 1
		movl	$4f,_memtest	# Set the return adress
d157 49
d207 31
a237 1
# Speeded up locopyin/locopyout written by Ken Wellsch.
d239 2
a240 2
# locopyin (from, to, len, addr) copies from userspace to kernelspace.
#       addr is iftrap addr for faulting.
d242 4
a245 2
	.globl  _locopyin
	.align  2
d247 31
a277 1
_locopyin:      .word   0x3c    # save R2|R3|R4|R5
d279 6
a284 2
	movl     4(ap),r4       # stash userspace address
	movl    12(ap),r3       # and length in case of fault?
d286 8
a293 1
	brb     copyio
d296 1
a296 2
# locopyout (from, to, len, addr) copies from kernelspace to userspace.
#       addr is iftrap addr for faulting.
a297 2
	.globl  _locopyout
	.align  2
d299 13
a311 1
_locopyout:     .word   0x3c    # save R2|R3|R4|R5
d313 3
a315 2
	movl    8(ap),r4	# stash userspace address
	movl    12(ap),r3       # and length in case of fault?
d317 9
a325 1
copyio:
d327 10
a336 2
	movl    12(ap),r2       # len
	beql    5f
d338 8
a345 2
	movl    16(ap),r0       # Get fault pointer flag
	movl    $cio,(r0)       # and stuff return address into it
d347 1
a347 2
	movl    4(ap),r0	# from
	movl    8(ap),r1	# to
d349 21
a369 19
	ashl    $-3,r2,r5       # convert length to quad words
	beql    2f
1: 
	movq    (r0)+,(r1)+     # do the copying in large hunks
	sobgtr  r5,1b	   	# (although movc3 is twice as fast
				# alas movc5 clobbers [r0-r5] thus
				# damaging the magic r3/r4 pair)
2:
	bicl3   $-8,r2,r5       # compute trailing bytes (<=7)
	beql    4f
3:
	movb    (r0)+,(r1)+
	sobgtr  r5,3b
4:
	movl    16(ap),r0	# remove fault address
	clrl    (r0)
5:
	clrl    r0		# flag the successful operation
cio:
d372 2
d375 4
a378 11
#
# copystr(from, to, maxlen, *copied, addr)
# Only used in kernel mode, doesnt check accessability.
#

	.globl	_copystr
_copystr:	.word 0x7c
        movl    4(ap),r4        # from
        movl    8(ap),r5        # to
        movl    12(ap),r2       # len
	movl	16(ap),r3	# copied
d380 1
a380 14
#if VAX630 || VAX650 || VAX410
        movl    r4, r1          # (3) string address == r1
        movl    r2, r0          # (2) string length == r0
        jeql    Llocc_out       # forget zero length strings
Llocc_loop:
        tstb    (r1)
        jeql    Llocc_out
        incl    r1
        sobgtr  r0,Llocc_loop
Llocc_out:
        tstl    r0              # be sure of condition codes
#else
        locc    $0, r2, (r4)    # check for null byte
#endif
d383 2
a384 2
	subl3	r0, r2, r6	# Len to copy.
	incl	r6
d386 17
a402 5
	beql	7f
	movl	r6,(r3)
7:	movc3	r6,(r4),(r5)
	movl	$0,r0
cs:	ret
d404 7
a410 2
1:	movc3	r2,(r4),(r5)
	movl	$ENAMETOOLONG, r0
d413 8
d422 7
a428 6
_loswtch:	.globl	_loswtch
	mtpr	_curpcb,$PR_PCBB
	svpctx
	mtpr	_nypcb,$PR_PCBB
	ldpctx
	rei
d430 3
d436 2
a438 18
# Have bcopy and bzero here to be sure that system files that not gets
# macros.h included will not complain.
_bcopy:	.globl _bcopy
	.word	0x0
	movl	4(ap), r0
	movl	8(ap), r1
	movl	0xc(ap), r2
	movc3	r2, (r0), (r1)
	ret

_bzero:	.globl	_bzero
	.word	0x0
	movl	4(ap), r0
	movl	8(ap), r1
	movc5	$0, (r0), $0, r1, (r0)
	ret

#ifdef DDB
d440 1
a440 1
 * DDB is the only routine that uses setjmp/longjmp.
d442 11
a452 8
	.globl	_setjmp, _longjmp
_setjmp:.word	0
	movl	4(ap), r0
	movl	8(fp), (r0)
	movl	12(fp),	4(r0)
	movl	16(fp), 8(r0)
	addl3	fp,$28,12(r0)
	clrl	r0
d455 11
a465 8
_longjmp:.word	0
	movl	4(ap), r1
	movl	8(ap), r0
	movl	(r1), ap
	movl	4(r1), fp
	movl	12(r1), sp
	jmp	*8(r1)
#endif 
@


1.6.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: subr.s,v 1.12 2001/03/16 03:11:00 bjc Exp $     */
/*	$NetBSD: subr.s,v 1.32 1999/03/25 00:41:48 mrg Exp $	   */
d34 5
a38 1
#include <machine/asm.h>
d40 4
a43 4
#include "assym.h"
#ifdef COMPAT_ULTRIX
#include <compat/ultrix/ultrix_syscall.h>
#endif
a44 1
#define JSBENTRY(x)	.globl x ; .align 2 ; x :
a47 47
/*
 * First entry routine from boot. This should be in a file called locore.
 */
ASENTRY(start, 0)
	movl	r11,_boothowto			# Howto boot (single etc...)
	movl	r10,_bootdev			# From where? (see rpb.h)
	bisl3	$0x80000000,r9,_esym		# End of loaded code
	movl	r8,_avail_end			# Usable memory (from VMB)
	pushl	$0x1f0000			# Push a nice PSL
	pushl	$to				# Address to jump to
	rei					# change to kernel stack
to:	movw	$0xfff,_panic			# Save all regs in panic
	moval	_end, r0			# Get kernel end address
	addl2	$0x3ff, r0			# Round it up
	cmpl	_esym, r0			# Compare with symbol table end
	bleq	eskip				# Symbol table not present
	addl3	_esym, $0x3ff, r0		# Use symbol end and round
eskip:
	bicl3	$0x3ff,r0,_proc0paddr		# save proc0 uarea pointer
	bicl3	$0x80000000,_proc0paddr,r0	# get phys proc0 uarea addr
	mtpr	r0,$PR_PCBB			# Save in IPR PCBB
	addl3	$USPACE,_proc0paddr,r0		# Get kernel stack top
	mtpr	r0,$PR_KSP			# put in IPR KSP
	movl	r0,_Sysmap			# SPT start addr after KSP

# Set some registers in known state
	movl	_proc0paddr,r0
	clrl	P0LR(r0)
	clrl	P1LR(r0)
	mtpr	$0,$PR_P0LR
	mtpr	$0,$PR_P1LR
	movl	$0x80000000,r1
	movl	r1,P0BR(r0)
	movl	r1,P1BR(r0)
	mtpr	r1,$PR_P0BR
	mtpr	r1,$PR_P1BR
	clrl	IFTRAP(r0)
	mtpr	$0,$PR_SCBB

	calls	$0,_start			# Jump away.
	/* NOTREACHED */


/*
 * Signal handler code.
 */

d49 1
a49 2
_sigcode:	addl2	$0x24, sp
		pushr	$0x3f
a54 1
		chmk	$SYS_exit
a58 14
#ifdef COMPAT_ULTRIX
		.globl	_ultrix_sigcode,_ultrix_esigcode
_ultrix_sigcode:	pushr	$0x3f
		subl2	$0xc,sp
		movl	0x24(sp),r0
		calls	$3,(r0)
		popr	$0x3f
		chmk	$ULTRIX_SYS_sigreturn
		chmk	$SYS_exit
		halt	
		.align	2
_ultrix_esigcode:
#endif

d61 5
a65 4
		.word	0x9f16
		.long	_cmn_idsptch
		.long	0
		.long	0
d68 8
a75 6
_cmn_idsptch:
        movl    (sp)+,r0
        pushl   4(r0)
        calls   $1,*(r0)
        popr    $0x3f
        rei
d77 15
a91 1
ENTRY(badaddr,R2|R3)			# Called with addr,b/w/l
d94 2
a95 2
		movl	4(ap),r2	# First argument, the address
		movl	8(ap),r1	# Sec arg, b,w,l
d98 1
a98 1
		movab	4f,_memtest	# Set the return address
d120 8
a127 17
# Have bcopy and bzero here to be sure that system files that not gets
# macros.h included will not complain.
ENTRY(bcopy,R2|R3|R4|R5|R6)
	movl	4(ap), r0
	movl	8(ap), r1
	movzwl	12(ap), r2
	movzwl	14(ap), r6

	movc3	r2, (r0), (r1)
	
	tstl	r6
	bleq	1f
0:	movb	(r1)+, (r3)+
	movc3	$0xffff, (r1), (r3)
	sobgtr	r6, 0b
	
1:	ret	
d129 1
a129 25
ENTRY(bzero,R2|R3|R4|R5|R6)
	movl	4(ap), r0
	movzwl	8(ap), r1
	movzwl	10(ap), r6
	
	movc5	$0, (r0), $0, r1, (r0)
	
	tstl	r6
	bleq	1f
0:	clrb	(r3)+
	movc5	$0, (r3), $0, $0xffff, (r3)
	sobgtr	r6, 0b
	
1:	ret

# cmpc3 is sometimes emulated; we cannot use it
ENTRY(bcmp, R2);
    movl    4(ap), r2
    movl    8(ap), r1
    movl    12(ap), r0
2:  cmpb    (r2)+, (r1)+
    bneq    1f
    decl    r0
    bneq    2b
1:  ret
d131 2
a132 13
#ifdef DDB
/*
 * DDB is the only routine that uses setjmp/longjmp.
 */
	.globl	_setjmp, _longjmp
_setjmp:.word	0
	movl	4(ap), r0
	movl	8(fp), (r0)
	movl	12(fp), 4(r0)
	movl	16(fp), 8(r0)
	addl3	fp,$28,12(r0)
	clrl	r0
	ret
d134 1
a134 8
_longjmp:.word	0
	movl	4(ap), r1
	movl	8(ap), r0
	movl	(r1), ap
	movl	4(r1), fp
	movl	12(r1), sp
	jmp	*8(r1)
#endif 
d137 2
a138 1
# setrunqueue/remrunqueue fast variants.
d140 2
d143 1
a143 27
JSBENTRY(Setrq)
#ifdef DIAGNOSTIC
	tstl	4(r0)	# Check that process actually are off the queue
	beql	1f
	pushab	setrq
	calls	$1,_panic
setrq:	.asciz	"setrunqueue"
#endif
1:	extzv	$2,$6,P_PRIORITY(r0),r1 # get priority
	movaq	_qs[r1],r2		# get address of queue
	insque	(r0),*4(r2)		# put proc last in queue
	bbss	r1,_whichqs,1f		# set queue bit.
1:	rsb

JSBENTRY(Remrq)
	extzv	$2,$6,P_PRIORITY(r0),r1
#ifdef DIAGNOSTIC
	bbs	r1,_whichqs,1f
	pushab	remrq
	calls	$1,_panic
remrq:	.asciz	"remrunqueue"
#endif
1:	remque	(r0),r2
	bneq	1f		# Not last process on queue
	bbsc	r1,_whichqs,1f
1:	clrl	4(r0)		# saftey belt
	rsb
d145 2
a146 8
#
# Idle loop. Here we could do something fun, maybe, like calculating
# pi or something.
#
idle:	mtpr	$0,$PR_IPL		# Enable all types of interrupts
1:	tstl	_whichqs		# Anything ready to run?
	beql	1b			# no, continue to loop
	brb	Swtch			# Yes, goto switch again.
d148 1
a148 31
#
# cpu_switch, cpu_exit and the idle loop implemented in assembler 
# for efficiency. r0 contains pointer to last process.
#
	
JSBENTRY(Swtch)
	clrl	_curproc		# Stop process accounting
#bpt
	mtpr	$0x1f,$PR_IPL		# block all interrupts
	ffs	$0,$32,_whichqs,r3	# Search for bit set
	beql	idle			# no bit set, go to idle loop

	movaq	_qs[r3],r1		# get address of queue head
	remque	*(r1),r2		# remove proc pointed to by queue head
#ifdef DIAGNOSTIC
	bvc	1f			# check if something on queue
	pushab	noque
	calls	$1,_panic
noque:	.asciz	"swtch"
#endif
1:	bneq	2f			# more processes on queue?
	bbsc	r3,_whichqs,2f		# no, clear bit in whichqs
2:	clrl	4(r2)			# clear proc backpointer
	clrl	_want_resched		# we are now changing process
	movl	r2,_curproc		# set new process running
	cmpl	r0,r2			# Same process?
	bneq	1f			# No, continue
	rsb
xxd:	
1:	movl	P_ADDR(r2),r0		# Get pointer to new pcb.
	addl3	r0,$IFTRAP,pcbtrap	# Save for copy* functions.
d150 2
a151 6
#
# Nice routine to get physical from virtual adresses.
#
	extzv	$9,$21,r0,r1		# extract offset
	movl	*_Sysmap[r1],r2		# get pte
	ashl	$9,r2,r3		# shift to get phys address.
d153 2
a154 8
#
# Do the actual process switch. pc + psl are already on stack, from
# the calling routine.
#
	svpctx
	mtpr	r3,$PR_PCBB
	ldpctx
	rei
d156 2
a157 3
#
# the last routine called by a process.
#
d159 20
a178 12
ENTRY(cpu_exit,0)
	movl	4(ap),r6	# Process pointer in r6
	mtpr	$0x18,$PR_IPL	# Block almost everything
	addl3	$512,_scratch,sp # Change stack, and schedule it to be freed

	pushl	r6		
	calls	$1,_exit2

	clrl	r0		# No process to switch from
	bicl3	$0xc0000000,_scratch,r1
	mtpr	r1,$PR_PCBB
	brw	Swtch
d182 2
a183 1
# copy/fetch/store routines. 
a184 50
	.align 2,1
ALTENTRY(copyin)
ENTRY(copyout, R2|R3|R4|R5|R6)
	movab	1f,*pcbtrap
	movl	4(ap), r0
	movl	8(ap), r1
	movzwl	12(ap), r2
	movzwl	14(ap), r6

	movc3	r2, (r0), (r1)
	
	tstl	r6
	bleq	1f
0:	movb	(r1)+, (r3)+
	movc3	$0xffff, (r1), (r3)
	sobgtr	r6,0b
	
1:	clrl	*pcbtrap
	ret

/* kcopy:  just like bcopy, except return -1 upon failure */	
ENTRY(kcopy,R2|R3|R4|R5|R6)
	movl	*pcbtrap,-(sp)
	movab	2f,*pcbtrap
	movl	4(ap), r0
	movl	8(ap), r1
	movzwl	12(ap), r2
	movzwl	14(ap), r6

	movc3	r2, (r0), (r1)
	
	tstl	r6
	bleq	1f
0:	movb	(r1)+, (r3)+
	movc3	$0xffff, (r1), (r3)
	sobgtr	r6, 0b
	
	/* 
	 * If there is a failure, trap.c will set r1 to -1, and jump
	 * to the following 2.  If not, we return 0.  We duplicate a 
	 * miniscule amount of code in the interest of speed; movc3
	 * sets r0 to 0 anyway.
	 */
1:
	movl	(sp)+,*pcbtrap
	ret
	
2:	movl	(sp)+,*pcbtrap
	movl	r1,r0
	ret
d186 5
a190 7
_copystr:	.globl	_copystr
_copyinstr:	.globl	_copyinstr
_copyoutstr:	.globl	_copyoutstr
	.word	0
	movl	4(ap),r4	# from
	movl	8(ap),r5	# to
	movl	12(ap),r2	# len
d193 15
a207 1
	movab	2f,*pcbtrap
d209 8
a216 8
/*
 * This routine consists of two parts: One is for MV2 that doesn't have
 * locc in hardware, the other is a fast version with locc. But because
 * locc only handles <64k strings, we default to the slow version if the
 * string is longer.
 */
	cmpl	_vax_cputype,$VAX_TYP_UV2
	bneq	4f		# Check if locc emulated
d218 2
a219 12
9:	movl	r2,r0
7:	movb	(r4)+,(r5)+
	beql	6f
	sobgtr	r0,7b
	brb 1f

6:	tstl	r3
	beql	5f
	incl	r2
	subl3	r0,r2,(r3)
5:	clrl	r0
	clrl	*pcbtrap
a221 2
4:	cmpl	r2,$65535	# maxlen < 64k?
	blss	8f		# then use fast code.
d223 6
a228 4
	locc	$0,$65535,(r4)	# is strlen < 64k?
	beql	9b		# No, use slow code
	subl3	r0,$65535,r1	# Get string len
	brb	0f		# do the copy
d230 1
a230 2
8:	locc	$0,r2,(r4)	# check for null byte
	beql	1f
d232 1
a232 7
	subl3	r0,r2,r1	# Calculate len to copy
0:	incl	r1		# Copy null byte also
	tstl	r3
	beql	3f
	movl	r1,(r3)		# save len copied
3:	movc3	r1,(r4),(r5)
	brb	2f
d234 8
a241 2
1:	movl	$ENAMETOOLONG,r0
2:	clrl	*pcbtrap
d244 5
a248 7
ENTRY(subyte,0)
	movab	1f,*pcbtrap
	movl	4(ap),r0
	movb	8(ap),(r0)
	clrl	r1
1:	clrl	*pcbtrap
	movl	r1,r0
d251 1
a251 35
ENTRY(suword,0)
	movab	1f,*pcbtrap
	movl	4(ap),r0
	movl	8(ap),(r0)
	clrl	r1
1:	clrl	*pcbtrap
	movl	r1,r0
	ret

ENTRY(suswintr,0)
	movab	1f,*pcbtrap
	movl	4(ap),r0
	movw	8(ap),(r0)
	clrl	r1
1:	clrl	*pcbtrap
	movl	r1,r0
	ret

ENTRY(fuswintr,0)
	movab	1f,*pcbtrap
	movl	4(ap),r0
	movzwl	(r0),r1
1:	clrl	*pcbtrap
	movl	r1,r0
	ret

#
# data department
#
	.data

_memtest:	.long 0 ; .globl _memtest	# Memory test in progress.
pcbtrap:	.long 0x800001fc; .globl pcbtrap	# Safe place
_bootdev:	.long 0; .globl _bootdev

d253 1
a253 1
 * Copy/zero more than 64k of memory (as opposite of bcopy/bzero).
d255 8
a262 11
ENTRY(blkcpy,R2|R3|R4|R5|R6)
	movl	4(ap),r1
	movl	8(ap),r3
	movl	12(ap),r6
	jbr 2f
1:	subl2	r0,r6
	movc3	r0,(r1),(r3)
2:	movzwl	$65535,r0
	cmpl	r6,r0
	jgtr	1b
	movc3	r6,(r1),(r3)
d265 8
a272 11
ENTRY(blkclr,R2|R3|R4|R5|R6)
	movl	4(ap), r3
	movl	8(ap), r6
	jbr	2f
1:	subl2	r0, r6
	movc5	$0,(r3),$0,r0,(r3)
2:	movzwl	$65535,r0
	cmpl	r6, r0
	jgtr	1b
	movc5	$0,(r3),$0,r6,(r3)
	ret
@


1.6.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.6.12.1 2001/05/14 21:39:11 niklas Exp $     */
@


1.6.12.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.6.12.2 2001/07/04 10:24:46 niklas Exp $     */
d121 4
a124 5
		.word	0x9f16		# jsb to absolute address
		.long	_cmn_idsptch	# the absolute address
		.long	0		# the callback interrupt routine
		.long	0		# its argument
		.long	0		# ptr to correspond evcnt struct
d128 5
a132 9
		movl	(sp)+,r0	# get pointer to idspvec
		movl	8(r0),r1	# get evcnt pointer
		beql	1f		# no ptr, skip increment
		incl	EV_COUNT(r1)	# increment low longword
#		adwc	$0,EV_COUNT+4(r1) # add any carry to hi longword
1:		pushl	4(r0)		# push argument
		calls	$1,*(r0)	# call interrupt routine
		popr	$0x3f		# pop registers
		rei			# return from interrut
d135 1
a135 1
		mfpr	$0x12,r0	# splhigh()
@


1.6.12.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$     */
d346 3
a348 1
ENTRY(copyin, R2|R3|R4|R5|R6)
a349 5
	blss	3f		# kernel space
	movl	8(ap), r1
	brb	2f

ENTRY(copyout, R2|R3|R4|R5|R6)
a350 3
	blss	3f		# kernel space
	movl	4(ap), r0
2:	movab	1f,*pcbtrap
a364 3
3:	movl	$EFAULT, r0
	ret

d396 5
a400 14
ENTRY(copyinstr,0)
	tstl	4(ap)		# is from a kernel address?
	bgeq	8f		# no, continue

6:	movl	$EFAULT,r0
	ret

ENTRY(copyoutstr,0)
	tstl	8(ap)		# is to a kernel address?
	bgeq	8f		# no, continue
	brb	6b

ENTRY(copystr,0)
8:	movl	4(ap),r4	# from
d402 1
a403 1
	movl	12(ap),r2	# len
d405 1
a405 8
	bneq	1f		# nothing to copy?
	movl	$ENAMETOOLONG,r0
	tstl	r3
	beql	0f
	movl	$0,(r3)
0:	ret

1:	movab	2f,*pcbtrap
d418 2
a419 2
	beql	6f		# end of string
	sobgtr	r0,7b		# no null byte in the len first bytes?
d447 1
a447 1
	brb	4f
d450 1
a450 10
2:	movab	4f,*pcbtrap	# if we fault again, don't resume there
	subl3	8(ap),r5,r1	# did we write to the string?
	beql	3f
	decl	r5
3:	movb	$0,(r5)		# null terminate the output string
	tstl	r3
	beql	4f
	incl	r1		# null byte accounts for outlen...
	movl	r1,(r3)		# save len copied
4:	clrl	*pcbtrap
d454 1
a455 2
	blss	3f		# illegal space
	movab	1f,*pcbtrap
d463 1
a464 2
	blss	3f		# illegal space
	movab	1f,*pcbtrap
d472 1
a473 2
	blss	3f		# illegal space
	movab	1f,*pcbtrap
a479 3
3:	mnegl	$1,r0
	ret

d481 1
a482 2
	blss	3b		# illegal space
	movab	1f,*pcbtrap
@


1.6.12.5
log
@Sync the SMP branch with 3.3
@
text
@d49 2
d52 1
d84 1
a84 13
# Copy the RPB to its new position
#if 1 /* compat with old bootblocks */
	tstl	(ap)				# Any arguments?
	bneq	1f				# Yes, called from new boot
	movl	r11,_boothowto			# Howto boot (single etc...)
#	movl	r10,_bootdev			# uninteresting, will complain
	movl	r8,_avail_end			# Usable memory (from VMB)
	clrl	-(sp)				# Have no RPB
	brb	2f
#endif

1:	pushl	4(ap)				# Address of old rpb
2:	calls	$1,_start			# Jump away.
d485 42
@


1.6.12.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d318 1
a318 1
# Nice routine to get physical from virtual addresses.
@


1.6.12.7
log
@set SONPROC. tested millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr.s,v 1.6.12.6 2004/02/19 10:50:03 niklas Exp $     */
a308 1
	movb	$SONPROC,P_STAT(r2)	# p->p_stat = SONPROC
@


1.5
log
@RCS tagging
@
text
@d1 2
a2 2
/*      $OpenBSD: subr.s,v 1.16 1996/03/17 22:56:18 ragge Exp $     */
/*      $NetBSD: subr.s,v 1.16 1996/03/17 22:56:18 ragge Exp $     */
d193 1
a193 1
#if VAX630
@


1.4
log
@sync w/ 0430
@
text
@d1 1
@


1.3
log
@from ragge;
save usp when trapping from userspace
change register save structs according to this
handle old init register passing convention
@
text
@d1 1
a1 1
/*      $NetBSD: subr.s,v 1.13 1996/01/28 12:22:52 ragge Exp $     */
d36 2
a37 2
#include "sys/syscall.h"
#include "sys/errno.h"
d39 4
a42 4
#include "machine/mtpr.h"
#include "machine/vmparam.h"
#include "machine/pte.h"
#include "machine/nexus.h"
d120 1
a120 1
# copyin(from, to, len) copies from userspace to kernelspace.
d122 5
d128 1
a128 8
	.globl	_locopyin
_locopyin:.word	0x1c
	movl    16(ap),r0       # Get fault pointer flag
	movl	$ci,(r0)

	movl	4(ap),r0	# from
	movl	8(ap),r1	# to
	movl	12(ap),r2	# len
d130 2
a131 2
	movl	r0,r4
	movl	r2,r3
d133 1
a133 9
	tstl	r2
	beql	3f
2:      movb    (r0)+,(r1)+       # XXX Should be done in a faster way.
        decl    r2              
        bneq    2b
3:      movl	16(ap),r0
	clrl	(r0)
	clrl    r0
ci:	ret
d136 2
a137 2
# locopyout(from, to, len, addr) in the same manner as copyin()
#	addr is iftrap addr for faulting.
d139 12
d152 2
a153 4
	.globl	_locopyout
_locopyout:.word   0x1c
	movl	16(ap),r0	# Get fault pointer flag
	movl	$co,(r0)	# and save ret addr
d155 2
a156 3
        movl    4(ap),r0        # from
        movl    8(ap),r1        # to
        movl    12(ap),r2       # len
d158 20
a177 2
        movl    r1,r4
        movl    r2,r3
a178 9
	tstl	r2
	beql	3f
2:	movb	(r0)+,(r1)+	# XXX Should be done in a faster way.
	decl	r2
	bneq	2b
3:	movl    16(ap),r0
	clrl	(r0)
	clrl	r0
co:	ret
d232 17
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*      $NetBSD: subr.s,v 1.12 1995/11/10 19:08:59 ragge Exp $     */
d214 1
a214 1
_loswtch:	.globl	_loswtch,_rei
d219 1
a219 1
_rei:	rei
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: subr.s,v 1.11 1995/06/16 15:36:50 ragge Exp $     */
a35 7

#include "vax/include/mtpr.h"
#include "vax/include/param.h"
#include "vax/include/loconf.h"
#include "vax/include/vmparam.h"
#include "vax/include/pte.h"
#include "vax/include/nexus.h"
d39 5
d58 9
a87 30





		.globl _physcopypage
_physcopypage:	.word 0x7
		movl	4(ap),r0
		ashl	$-PGSHIFT,r0,r0
		bisl2	$(PG_V|PG_RO),r0

		movl	8(ap),r1
		ashl    $-PGSHIFT,r1,r1
		bisl2   $(PG_V|PG_KW),r1

		movl	r0,*(_pte_cmap)
		movl	r1,*$4+(_pte_cmap)

		movl	_vmmap,r2
		addl3	$0x200,r2,r1
		mtpr	r1,$PR_TBIS
		mtpr	r2,$PR_TBIS

		movl	r1,r0
1:		movl	(r2)+,(r1)+
		cmpl	r0,r2
		bneq	1b
		ret


a221 10

mbanum:		.long 0
	

/*** DATA ********************************************************************/



_pte_cmap:	.long 0 ; .globl _pte_cmap	/* Address of PTE 
						   corresponding to cmap    */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
