head	1.12;
access;
symbols
	OPENBSD_4_9:1.11.0.10
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.22
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.10
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.8
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2011.07.06.18.32.59;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.27.01.10.12;	author bjc;	state Exp;
branches
	1.8.10.1;
next	1.7;

1.7
date	97.09.10.12.04.48;	author maja;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.05.28.23.25.51;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.25.14;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.09.10.14;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.14.00.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.40;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.05.14.21.39.02;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	;

1.8.10.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@/*	$OpenBSD: ka750.c,v 1.11 2008/08/18 23:05:38 miod Exp $ */
/*	$NetBSD: ka750.c,v 1.30 1999/08/14 11:30:48 ragge Exp $ */
/*
 * Copyright (c) 1982, 1986, 1988 The Regents of the University of California.
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ka750.c	7.4 (Berkeley) 5/9/91
 *	@@(#)autoconf.c	7.20 (Berkeley) 5/9/91
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <machine/ka750.h>
#include <machine/mtpr.h>
#include <machine/cpu.h>
#include <machine/clock.h>
#include <machine/sid.h>

#include <vax/vax/gencons.h>

void	ctuattach(void);
static	void	ka750_clrf(void);
static	void	ka750_conf(void);
static	void    ka750_memerr(void);
static	int     ka750_mchk(caddr_t);


struct	cpu_dep ka750_calls = {
	0,
	ka750_mchk,
	ka750_memerr,
	ka750_conf,
	generic_clkread,
	generic_clkwrite,
	1,	/* ~VUPS */
	4,	/* SCB pages */
	NULL,	/* halt call */
	NULL,	/* Reboot call */
	ka750_clrf,
	NULL,
	NULL,
	hardclock
};

static	caddr_t mcraddr[4];	/* XXX */

void
ka750_conf()
{
	printf("cpu0: KA750, hardware rev %d, ucode rev %d, ",
	    V750HARDW(vax_cpudata), V750UCODE(vax_cpudata));
	if (mfpr(PR_ACCS) & 255) {
		printf("FPA present, enabling.\n");
		mtpr(0x8000, PR_ACCS);
	} else
		printf("no FPA\n");

	if (mfpr(PR_TODR) == 0) { /* Check for failing battery */
		mtpr(1, PR_TODR);
		printf("WARNING: TODR battery broken\n");
	}

	/* Call ctuattach() here so it can setup its vectors. */
	ctuattach();
}

int ka750_memmatch(struct  device  *, struct cfdata	 *, void *);
void ka750_memenable(struct	 device	 *, struct  device  *, void *);

struct	cfattach mem_cmi_ca = {
	sizeof(struct device), ka750_memmatch, ka750_memenable
};

int
ka750_memmatch(parent, cf, aux)
	struct	device	*parent;
	struct cfdata *cf;
	void	*aux;
{
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;

	if (cf->cf_loc[CMICF_TR] != sa->nexnum && cf->cf_loc[CMICF_TR] > -1)
		return 0;

	if (sa->type != NEX_MEM16)
		return 0;

	return 1;
}

struct	mcr750 {
	int	mc_err;			/* error bits */
	int	mc_inh;			/* inhibit crd */
	int	mc_inf;			/* info bits */
};

#define M750_ICRD	0x10000000	/* inhibit crd interrupts, in [1] */
#define M750_UNCORR	0xc0000000	/* uncorrectable error, in [0] */
#define M750_CORERR	0x20000000	/* correctable error, in [0] */

#define M750_INH(mcr)	((mcr)->mc_inh = 0)
#define M750_ENA(mcr)	((mcr)->mc_err = (M750_UNCORR|M750_CORERR), \
			 (mcr)->mc_inh = M750_ICRD)
#define M750_ERR(mcr)	((mcr)->mc_err & (M750_UNCORR|M750_CORERR))

#define M750_SYN(err)	((err) & 0x7f)
#define M750_ADDR(err)	(((err) >> 9) & 0x7fff)

/* enable crd interrupts */
void
ka750_memenable(parent, self, aux)
	struct	device	*parent, *self;
	void	*aux;
{
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;
	struct mcr750 *mcr = (struct mcr750 *)sa->nexaddr;
	int k, l, m, cardinfo;
	
	mcraddr[self->dv_unit] = (caddr_t)sa->nexaddr;

	/* We will use this info for error reporting - later! */
	cardinfo = mcr->mc_inf;
	switch ((cardinfo >> 24) & 3) {
	case 0: printf(": L0011 ");
		break;

	case 1: printf(": L0016 ");
		m = cardinfo & 0xaaaa;
		for (k = l = 0; k < 16; k++){
			if (m & 1)
				l++;
			m >>= 1;
		}
		printf("with %d M8750",l);
		break;

	case 3: printf(": L0022 ");
		m = cardinfo & 0x5555;
		for (k = l = 0; k < 16; k++) {
			if (m & 1)
				l++;
			m>>=1;
		}
		printf("with %d M7199",l);
		m = cardinfo & 0xaaaa;
		if (m) {
			for (k = l = 0; k < 16; k++) {
				if (m & 1)
					l++;
				m >>= 1;
			}
			printf(" and %d M8750",l);
		}
		break;
	}
	printf("\n");


	M750_ENA((struct mcr750 *)mcraddr[0]);
}

/* log crd errors */
void
ka750_memerr()
{
	register struct mcr750 *mcr = (struct mcr750 *)mcraddr[0];
	register int err;

	if (M750_ERR(mcr)) {
		err = mcr->mc_err;	/* careful with i/o space refs */
		printf("mcr0: %s", err & M750_UNCORR ?
		    "hard error" : "soft ecc");
		printf(" addr %x syn %x\n", M750_ADDR(err), M750_SYN(err));
		M750_INH(mcr);
	}
}

char *mc750[]={"0","1","2","3","4","5","6","7","8","9","10","11","12","13",
	"14","15"};

struct mc750frame {
	int	mc5_bcnt;		/* byte count == 0x28 */
	int	mc5_summary;		/* summary parameter (as above) */
	int	mc5_va;			/* virtual address register */
	int	mc5_errpc;		/* error pc */
	int	mc5_mdr;
	int	mc5_svmode;		/* saved mode register */
	int	mc5_rdtimo;		/* read lock timeout */
	int	mc5_tbgpar;		/* tb group parity error register */
	int	mc5_cacherr;		/* cache error register */
	int	mc5_buserr;		/* bus error register */
	int	mc5_mcesr;		/* machine check status register */
	int	mc5_pc;			/* trapped pc */
	int	mc5_psl;		/* trapped psl */
};

#define MC750_TBERR	2		/* type code of cp tbuf par */
#define MC750_TBPAR	4		/* tbuf par bit in mcesr */

int
ka750_mchk(cmcf)
	caddr_t cmcf;
{
	register struct mc750frame *mcf = (struct mc750frame *)cmcf;
	register int type = mcf->mc5_summary;
	int mcsr = mfpr(PR_MCSR);

	printf("machine check %x: %s%s\n", type, mc750[type&0xf],
	    (type&0xf0) ? " abort" : " fault"); 
	printf(
"\tva %x errpc %x mdr %x smr %x rdtimo %x tbgpar %x cacherr %x\n",
	    mcf->mc5_va, mcf->mc5_errpc, mcf->mc5_mdr, mcf->mc5_svmode,
	    mcf->mc5_rdtimo, mcf->mc5_tbgpar, mcf->mc5_cacherr);
	printf("\tbuserr %x mcesr %x pc %x psl %x mcsr %x\n",
	    mcf->mc5_buserr, mcf->mc5_mcesr, mcf->mc5_pc, mcf->mc5_psl,
	    mcsr);
	mtpr(0, PR_TBIA);
	mtpr(0xf, PR_MCESR);
	if (type == MC750_TBERR && (mcf->mc5_mcesr&0xe) == MC750_TBPAR) {
		printf("tbuf par: flushing and returning\n");
		return (MCHK_RECOVERED);
	}
	return (MCHK_PANIC);
}

void
ka750_clrf()
{
	int s = splhigh();

#define WAIT	while ((mfpr(PR_TXCS) & GC_RDY) == 0) ;

	WAIT;

	mtpr(GC_CWFL|GC_CONS, PR_TXDB);

	WAIT;
	mtpr(GC_CCFL|GC_CONS, PR_TXDB);

	WAIT;
	splx(s);
}
@


1.11
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka750.c,v 1.10 2003/06/02 23:27:59 millert Exp $ */
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka750.c,v 1.9 2002/03/14 01:26:48 millert Exp $ */
d64 2
a65 2
	0,	/* halt call */
	0,	/* Reboot call */
d67 3
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka750.c,v 1.8 2000/04/27 01:10:12 bjc Exp $ */
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ka750.c,v 1.7 1997/09/10 12:04:48 maja Exp $ */
d52 5
a56 5
void	ctuattach __P((void));
static	void	ka750_clrf __P((void));
static	void	ka750_conf __P((void));
static	void    ka750_memerr __P((void));
static	int     ka750_mchk __P((caddr_t));
d95 2
a96 2
int ka750_memmatch __P((struct  device  *, struct cfdata	 *, void *));
void ka750_memenable __P((struct	 device	 *, struct  device  *, void *));
@


1.8.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka750.c,v 1.8 2000/04/27 01:10:12 bjc Exp $ */
d52 5
a56 5
void	ctuattach(void);
static	void	ka750_clrf(void);
static	void	ka750_conf(void);
static	void    ka750_memerr(void);
static	int     ka750_mchk(caddr_t);
d95 2
a96 2
int ka750_memmatch(struct  device  *, struct cfdata	 *, void *);
void ka750_memenable(struct	 device	 *, struct  device  *, void *);
@


1.7
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: ka750.c,v 1.6 1997/05/28 23:25:51 niklas Exp $ */
/*	$NetBSD: ka750.c,v 1.18 1997/02/19 10:04:17 ragge Exp $ */
a40 1
#include <sys/types.h>
a43 3
#include <vm/vm.h>
#include <vm/vm_kern.h>

d45 2
a47 2
#include <machine/pte.h>
#include <machine/cpu.h>
a48 2
#include <machine/mtpr.h>
#include <machine/scb.h>
d50 1
a50 2
#include <vax/uba/ubavar.h>
#include <vax/uba/ubareg.h>
d53 4
d58 3
a60 3
struct	cpu_dep	ka750_calls = {
	ka750_steal_pages,
	generic_clock,
d66 6
a71 4
	1,      /* ~VUPS */
	0,      /* Used by vaxstation */
	0,      /* Used by vaxstation */
	0,      /* Used by vaxstation */
d73 1
a73 1
};
a74 3
/*
 * ka750_conf() is called by cpu_attach to do the cpu_specific setup.
 */
d76 1
a76 3
ka750_conf(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d78 1
a78 4
	extern	char cpu_model[];

	strcpy(cpu_model,"VAX 11/750");
	printf(": 11/750, hardware rev %d, ucode rev %d\n",
a79 1
	printf("%s: ", self->dv_xname);
d86 5
d95 2
a96 2
int ka750_memmatch __P((struct  device  *, void  *, void *));
void ka750_memenable __P((struct  device  *, struct  device  *, void *));
d98 2
a99 2
struct  cfattach mem_cmi_ca = {
        sizeof(struct device), ka750_memmatch, ka750_memenable
d103 4
a106 3
ka750_memmatch(parent, gcf, aux)
        struct  device  *parent;
        void    *gcf, *aux;
d108 1
a108 2
	struct  sbi_attach_args *sa = (struct sbi_attach_args *)aux;
	struct  cfdata  *cf = gcf;
d110 2
a111 2
        if ((cf->cf_loc[0] != sa->nexnum) && (cf->cf_loc[0] > -1))
                return 0;
a118 2
extern volatile caddr_t mcraddr[];

d140 2
a141 2
        struct  device  *parent, *self;
        void    *aux;
d143 1
a143 1
	struct  sbi_attach_args *sa = (struct sbi_attach_args *)aux;
d255 1
a255 47
ka750_steal_pages()
{
	extern	vm_offset_t avail_start, virtual_avail;
	int	junk;

	/*
	 * We take away the pages we need, one for SCB and the rest
	 * for UBA vectors == 1 + 2 will alloc all needed space.
	 * We also set up virtual area for SBI.
	 */
	MAPPHYS(junk, V750PGS, VM_PROT_READ|VM_PROT_WRITE);
	MAPVIRT(nexus, btoc(NEX750SZ));
	pmap_map((vm_offset_t)nexus, NEX750, NEX750 + NEX750SZ,
	    VM_PROT_READ|VM_PROT_WRITE);
}

static  int cmi_print __P((void *, const char *));
static  int cmi_match __P((struct device *, void *, void *));
static  void cmi_attach __P((struct device *, struct device *, void*));

struct  cfdriver cmi_cd = {
        NULL, "cmi", DV_DULL
};      

struct  cfattach cmi_ca = {
        sizeof(struct device), cmi_match, cmi_attach
};

int
cmi_print(aux, name)
        void *aux;
        const char *name;
{
        struct sbi_attach_args *sa = (struct sbi_attach_args *)aux;

        if (name)
		printf("unknown device 0x%x at %s", sa->type, name);

        printf(" tr%d", sa->nexnum);
        return (UNCONF);
}


int
cmi_match(parent, cf, aux)
        struct  device  *parent;
        void    *cf, *aux;
d257 1
a257 1
        struct bp_conf *bp = aux;
d259 1
a259 4
        if (strcmp(bp->type, "cmi"))
                return 0;
        return 1;
}
d261 1
a261 20
void
cmi_attach(parent, self, aux)
        struct  device  *parent, *self;
        void    *aux;
{
        u_int   nexnum, maxnex, minnex;
        struct  sbi_attach_args sa;

	printf("I\n");
	/*
	 * Probe for memory, can be in the first 4 slots.
	 */
	for (sa.nexnum = 0; sa.nexnum < 4; sa.nexnum++) {
		if (badaddr((caddr_t)&nexus[sa.nexnum], 4))
			continue;

		sa.nexaddr = nexus + sa.nexnum;
		sa.type = NEX_MEM16;
		config_found(self, (void*)&sa, cmi_print);
	}
d263 1
a263 11
	/*
	 * Probe for mba's, can be in slot 4 - 7.
	 */
	for (sa.nexnum = 4; sa.nexnum < 7; sa.nexnum++) {
		if (badaddr((caddr_t)&nexus[sa.nexnum], 4))
			continue;

		sa.nexaddr = nexus + sa.nexnum;
		sa.type = NEX_MBA;
		config_found(self, (void*)&sa, cmi_print);
	}
d265 2
a266 10
	/*
	 * There are always one generic UBA, and maybe an optional.
	 */
	sa.nexnum = 8;
	sa.nexaddr = nexus + sa.nexnum;
	sa.type = NEX_UBA0;
	config_found(self, (void*)&sa, cmi_print);
	sa.type = NEX_UBA1;
	if (badaddr((caddr_t)&nexus[++sa.nexnum], 4) == 0)
		config_found(self, (void*)&sa, cmi_print);
d268 2
@


1.7.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: ka750.c,v 1.8 2000/04/27 01:10:12 bjc Exp $ */
/*	$NetBSD: ka750.c,v 1.30 1999/08/14 11:30:48 ragge Exp $ */
d41 1
d45 3
d49 2
a50 1
#include <machine/mtpr.h>
a51 1
#include <machine/clock.h>
d53 2
d56 2
a57 1
#include <vax/vax/gencons.h>
a59 4
static	void	ka750_clrf __P((void));
static	void	ka750_conf __P((void));
static	void    ka750_memerr __P((void));
static	int     ka750_mchk __P((caddr_t));
d61 3
a63 3

struct	cpu_dep ka750_calls = {
	0,
d69 5
a73 5
	1,	/* ~VUPS */
	4,	/* SCB pages */
	0,	/* halt call */
	0,	/* Reboot call */
	ka750_clrf,
d76 3
a78 2
static	caddr_t mcraddr[4];	/* XXX */

d80 3
a82 1
ka750_conf()
d84 4
a87 1
	printf("cpu0: KA750, hardware rev %d, ucode rev %d, ",
d89 1
a95 5
	if (mfpr(PR_TODR) == 0) { /* Check for failing battery */
		mtpr(1, PR_TODR);
		printf("WARNING: TODR battery broken\n");
	}

d100 2
a101 2
int ka750_memmatch __P((struct  device  *, struct cfdata	 *, void *));
void ka750_memenable __P((struct	 device	 *, struct  device  *, void *));
d103 2
a104 2
struct	cfattach mem_cmi_ca = {
	sizeof(struct device), ka750_memmatch, ka750_memenable
d108 3
a110 4
ka750_memmatch(parent, cf, aux)
	struct	device	*parent;
	struct cfdata *cf;
	void	*aux;
d112 2
a113 1
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;
d115 2
a116 2
	if (cf->cf_loc[CMICF_TR] != sa->nexnum && cf->cf_loc[CMICF_TR] > -1)
		return 0;
d124 2
d147 2
a148 2
	struct	device	*parent, *self;
	void	*aux;
d150 1
a150 1
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;
d262 47
a308 1
ka750_clrf()
d310 1
a310 1
	int s = splhigh();
d312 4
a315 1
#define WAIT	while ((mfpr(PR_TXCS) & GC_RDY) == 0) ;
d317 20
a336 1
	WAIT;
d338 11
a348 1
	mtpr(GC_CWFL|GC_CONS, PR_TXDB);
d350 10
a359 2
	WAIT;
	mtpr(GC_CCFL|GC_CONS, PR_TXDB);
a360 2
	WAIT;
	splx(s);
@


1.7.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d52 5
a56 5
void	ctuattach(void);
static	void	ka750_clrf(void);
static	void	ka750_conf(void);
static	void    ka750_memerr(void);
static	int     ka750_mchk(caddr_t);
d95 2
a96 2
int ka750_memmatch(struct  device  *, struct cfdata	 *, void *);
void ka750_memenable(struct	 device	 *, struct  device  *, void *);
@


1.7.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka750.c,v 1.7.12.2 2002/03/28 11:26:46 niklas Exp $ */
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@remove some statics
@
text
@d1 3
a3 4
/*	$OpenBSD: ka750.c,v 1.17 1996/10/13 03:35:48 christos Exp $ */
/*	$NetBSD: ka750.c,v 1.17 1996/10/13 03:35:48 christos Exp $ */

/*-
d49 1
d60 15
@


1.5
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
d85 2
a86 2
static int ka750_memmatch __P((struct  device  *, void  *, void *));
static void ka750_memenable __P((struct  device  *, struct  device  *, void *));
@


1.4
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: ka750.c,v 1.12 1996/04/08 18:32:42 ragge Exp $	*/
d37 1
a37 1
 *      @@(#)autoconf.c  7.20 (Berkeley) 5/9/91
d51 1
d54 1
d65 2
a66 2
	struct	device *parent, *self;
	void	*aux;
d72 1
a72 1
	    V750HARDW(cpu_type), V750UCODE(cpu_type));
d84 7
a90 4
/*
 * ka750_clock() makes the 11/750 interrupt clock and todr
 * register start counting.
 */
d92 3
a94 1
ka750_clock()
d96 2
d99 4
a102 4
	mtpr(-10000, PR_NICR); /* Load in count register */
	mtpr(0x800000d1, PR_ICCS); /* Start clock and enable interrupt */
	if (mfpr(PR_TODR)) {
		/* todr running */
a103 5
	} else {
		/* Start TODR register. */
		mtpr(1, PR_TODR);
		return 1;
	}
d105 1
a107 1

d116 3
a118 3
#define	M750_ICRD	0x10000000	/* inhibit crd interrupts, in [1] */
#define	M750_UNCORR	0xc0000000	/* uncorrectable error, in [0] */
#define	M750_CORERR	0x20000000	/* correctable error, in [0] */
d120 2
a121 2
#define	M750_INH(mcr)	((mcr)->mc_inh = 0)
#define	M750_ENA(mcr)	((mcr)->mc_err = (M750_UNCORR|M750_CORERR), \
d123 1
a123 1
#define	M750_ERR(mcr)	((mcr)->mc_err & (M750_UNCORR|M750_CORERR))
d125 2
a126 2
#define	M750_SYN(err)	((err) & 0x7f)
#define	M750_ADDR(err)	(((err) >> 9) & 0x7fff)
d130 3
a132 3
ka750_memenable(sa,self)
	struct sbi_attach_args *sa;
	struct device *self;
d134 2
a136 1
	struct mcr750 *mcr = (struct mcr750 *)sa->nexaddr;
d217 1
a217 1
#define	MC750_TBPAR	4		/* tbuf par bit in mcesr */
a248 1
	extern	struct nexus *nexus;
d262 84
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: ka750.c,v 1.8 1995/12/13 18:50:34 ragge Exp $	*/
d40 17
a56 12
#include "sys/param.h"
#include "sys/types.h"
#include "sys/device.h"
#include "vm/vm.h"
#include "vm/vm_kern.h"

#include "machine/ka750.h"
#include "machine/pte.h"
#include "machine/cpu.h"
#include "machine/mtpr.h"
#include "vax/uba/ubavar.h"
#include "vax/uba/ubareg.h"
d66 1
a66 1
	extern char cpu_model[];
d77 3
d125 1
d130 2
a131 3
	extern int nmcr;
	int k,l,m,cardinfo;
	struct mcr750 *mcr=(struct mcr750 *)sa->nexaddr;
d133 1
a133 1
	mcraddr[self->dv_unit]=(caddr_t)sa->nexaddr;
d136 2
a137 2
	cardinfo=mcr->mc_inf;
	switch((cardinfo>>24)&3){
d140 1
d142 6
a147 2
		m=cardinfo&0xaaaa;
		for(k=l=0;k<16;k++){if(m&1)l++;m>>=1;}
d150 1
d152 6
a157 2
		m=cardinfo&0x5555;
		for(k=l=0;k<16;k++){if(m&1)l++;m>>=1;}
d159 8
a166 4
		m=cardinfo&0xaaaa;
		if(m){
		for(k=l=0;k<16;k++){if(m&1)l++;m>>=1;}
		printf(" and %d M8750",l);
d177 1
d214 1
d235 1
a235 1
		return (0);
d237 1
a237 1
	return (-1);
d240 1
a255 2

	return 0;
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: ka750.c,v 1.7 1995/11/30 00:59:35 jtc Exp $	*/
d45 1
d48 1
d53 7
a59 5
#include "mba.h"
#include "uba.h"

int
ka750_conf()
a63 7
	config_rootfound("backplane",(void *)75);
}

int
conf_750(){
	extern int cpu_type;

d65 7
a71 1
		V750HARDW(cpu_type), V750UCODE(cpu_type));
d79 2
a80 1
ka750_clock() {
a94 10
#if NMBA < 1
/*
 * Dummy routine; should never be called.
 * Should also be somewhere else, but it doesn't matter right now :)
 */
mbainterrupt(){return;}
#endif


#include "sys/param.h"
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ka750.c,v 1.5.2.1 1995/10/15 14:18:49 ragge Exp $	*/
a39 4
/* All bugs are subject to removal without further notice */

#if VAX750

d43 2
a45 1
#include "machine/nexus.h"
a53 6
#include "vm/vm.h"
#include "vm/vm_kern.h"
#include "vax/include/pmap.h"

struct nexus *nexus;

d65 1
a65 1
	extern int cpu_type, nmba, numuba;
a70 2
ka750_clock(){
	u_int i;
d72 2
a73 1
 * It's time to start clocks in system...
d75 6
a80 4
	i=~10000; /* Complement of 10000 milliseconds */
	mtpr(i,PR_NICR); /* Load in count register */
	mtpr(0x51,PR_ICCS); /* Start clock and enable interrupt */
	if(mfpr(PR_TODR)){
d85 1
a85 1
		mtpr(1,PR_TODR);
a99 5
/*
 * 750-specific code.
 */


a101 2
/* #include "mem.h" */

d221 20
a240 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
