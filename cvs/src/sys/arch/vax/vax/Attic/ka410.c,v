head	1.14;
access;
symbols
	OPENBSD_5_9:1.13.0.16
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.18
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.10
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.14
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.12
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.8
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.6
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.4
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.10
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.9.0.28
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.26
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.24
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.22
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.20
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.18
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.16
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.12
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.13;
commitid	OSDG2O3Cgeifnf1W;

1.13
date	2011.09.15.00.48.24;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.06.20.42.05;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.18.23.07.26;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.27.01.10.12;	author bjc;	state Exp;
branches;
next	1.5;

1.5
date	97.09.20.14.04.31;	author maja;	state Exp;
branches
	1.5.12.1;
next	1.4;

1.4
date	97.09.12.09.30.55;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	97.09.10.12.04.46;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.00.05.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.25.12;	author maja;	state Exp;
branches;
next	;

1.5.12.1
date	2001.05.14.21.38.54;	author niklas;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.5.12.3;

1.5.12.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.5.12.4;

1.5.12.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: ka410.c,v 1.13 2011/09/15 00:48:24 miod Exp $ */
/*	$NetBSD: ka410.c,v 1.21 1999/09/06 19:52:53 ragge Exp $ */
/*
 * Copyright (c) 1996 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by Bertram Barth.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/pmap.h>
#include <machine/uvax.h>
#include <machine/ka410.h>
#include <machine/ka420.h>
#include <machine/cvax.h>
#include <machine/clock.h>
#include <machine/vsbus.h>

static	void	ka410_conf(void);
static	void	ka410_memerr(void);
static	int	ka410_mchk(caddr_t);
static	void	ka410_halt(void);
static	void	ka410_reboot(int);
static	void	ka41_cache_enable(void);
static	void	ka410_clrf(void);

static	caddr_t	l2cache;	/* mapped in address */
static	long 	*cacr;		/* l2csche ctlr reg */

/* 
 * Declaration of 410-specific calls.
 */
struct	cpu_dep ka410_calls = {
	0,
	ka410_mchk,
	ka410_memerr, 
	ka410_conf,
	chip_clkread,
	chip_clkwrite,
	1,      /* ~VUPS */
	2,	/* SCB pages */
	ka410_halt,
	ka410_reboot,
	ka410_clrf,
	icr_hardclock
};


void
ka410_conf()
{
	struct vs_cpu *ka410_cpu;

	ka410_cpu = (struct vs_cpu *)vax_map_physmem(VS_REGS, 1);

	switch (vax_cputype) {
	case VAX_TYP_UV2:
		ka410_cpu->vc_410mser = 1;
		printf("cpu: KA410\n");
		break;

	case VAX_TYP_CVAX:
		printf("cpu: KA41/42\n");
		ka410_cpu->vc_vdcorg = 0; /* XXX */
		ka410_cpu->vc_parctl = PARCTL_CPEN | PARCTL_DPEN ;
		printf("cpu: Enabling primary cache, ");
		mtpr(CADR_SEN2 | CADR_SEN1 | CADR_CENI | CADR_CEND, PR_CADR);
		if (vax_confdata & KA420_CFG_CACHPR) {
			l2cache = (void *)vax_map_physmem(KA420_CH2_BASE,
			    (KA420_CH2_SIZE / VAX_NBPG));
			cacr = (void *)vax_map_physmem(KA420_CACR, 1);
			printf("secondary cache\n");
			ka41_cache_enable();
		} else
			printf("no secondary cache present\n");
	}
	/* Done with ka410_cpu - release it */
	vax_unmap_physmem((vaddr_t)ka410_cpu, 1);
	/*
	 * Setup parameters necessary to read time from clock chip.
	 */
	clk_adrshift = 1;       /* Addressed at long's... */
	clk_tweak = 2;          /* ...and shift two */
	clk_page = (short *)vax_map_physmem(KA420_WAT_BASE, 1);
}

void
ka41_cache_enable()
{
	*cacr = KA420_CACR_TPE; 	/* Clear any error, disable cache */
	bzero(l2cache, KA420_CH2_SIZE); /* Clear whole cache */
	*cacr = KA420_CACR_CEN;		/* Enable cache */
}

void
ka410_memerr()
{
	printf("Memory err!\n");
}

int
ka410_mchk(addr)
	caddr_t addr;
{
	panic("Machine check");
	return 0;
}

static void
ka410_halt()
{
	asm("movl $0xc, (%0)"::"r"((int)clk_page + 0x38)); /* Don't ask */
	asm("halt");
}

static void
ka410_reboot(arg)
	int arg;
{
	asm("movl $0xc, (%0)"::"r"((int)clk_page + 0x38)); /* Don't ask */
	asm("halt");
}

static void
ka410_clrf()
{
	struct ka410_clock *clk = (void *)clk_page;

	/*
	 * Clear restart and boot in progress flags
	 * in the CPMBX. (ie. clear bits 4 and 5)
	 */
	clk->cpmbx = (clk->cpmbx & ~0x30);
}
@


1.13
log
@Switch vax to timecounters. There are three different clock sources:
- ICR/NICR on most systems (1MHz counter resolution).
- diagnostic timer on KA46/KA48 (1kHz counter resolution, counter is actually
  running at around 1024 kHz but is not guaranteed to be monotonic at this
  rate).
- 100Hz clock on VXT (nothing but the 100Hz clock interrupt).

Tested on KA49 (ICR style), KA46, KA48 (diagtmr style), VXT2000+ (VXT
{empty,hopeless}ness'r'us style).
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.12 2011/07/06 20:42:05 miod Exp $ */
@


1.12
log
@Drop cpu_dep.cpu_subconf routine, which is no longer used after KA820 support
removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.11 2008/08/18 23:07:26 miod Exp $ */
d82 1
a82 1
	hardclock
@


1.11
log
@Move common CVAX defines and code (internal cache IPR, SSC layout, machine
check frame format...) to a single place. Get rid of duplicated KAxx_FOO
constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.10 2008/08/18 23:05:38 miod Exp $ */
a48 1
#include <machine/nexus.h>
a81 1
	NULL,
@


1.10
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.9 2002/03/14 01:26:48 millert Exp $ */
d53 1
d106 1
a106 2
		mtpr(KA420_CADR_S2E|KA420_CADR_S1E|KA420_CADR_ISE|KA420_CADR_DSE, 
			PR_CADR);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.8 2001/11/06 19:53:17 miod Exp $ */
d82 2
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.7 2001/09/11 20:05:25 miod Exp $ */
d56 7
a62 7
static	void	ka410_conf __P((void));
static	void	ka410_memerr __P((void));
static	int	ka410_mchk __P((caddr_t));
static	void	ka410_halt __P((void));
static	void	ka410_reboot __P((int));
static	void	ka41_cache_enable __P((void));
static	void	ka410_clrf __P((void));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.8 2001/11/06 19:53:17 miod Exp $ */
d56 7
a62 7
static	void	ka410_conf(void);
static	void	ka410_memerr(void);
static	int	ka410_mchk(caddr_t);
static	void	ka410_halt(void);
static	void	ka410_reboot(int);
static	void	ka41_cache_enable(void);
static	void	ka410_clrf(void);
@


1.7
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.6 2000/04/27 01:10:12 bjc Exp $ */
d42 1
a42 1
#include <vm/vm.h>
@


1.6
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.5 1997/09/20 14:04:31 maja Exp $ */
a42 1
#include <vm/vm_kern.h>
@


1.5
log
@The only CVAX to reach this module is a VAXstation 3100 model 10-48.
Let cpu_model be correct. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: ka410.c,v 1.4 1997/09/12 09:30:55 maja Exp $ */
/*	$NetBSD: ka410.c,v 1.7 1997/07/26 10:12:45 ragge Exp $ */
d40 2
d53 1
d55 1
d57 1
a57 3
static	void	ka410_conf __P((struct device*, struct device*, void*));
static	void	ka410_memenable __P((struct sbi_attach_args*, struct device *));
static	void	ka410_steal_pages __P((void));
d62 2
d65 2
a66 22
extern  short *clk_page;

static	struct uc_map ka410_map[] = {
	{ KA410_CFGTST,		KA410_CFGTST+1023,	1024,	0 },
	{ KA410_ROM_BASE,	KA410_ROM_END,	KA410_ROM_SIZE, 0 },
	{ (int)KA410_CPU_BASE,	KA410_CPU_END,	KA410_CPU_SIZE, 0 },
	{ KA410_NWA_BASE,	KA410_NWA_END,	KA410_NWA_SIZE, 0 },
	{ KA410_SER_BASE,	KA410_SER_END,	KA410_SER_SIZE, 0 },
	{ (int)KA410_WAT_BASE,	KA410_WAT_END,	KA410_WAT_SIZE, 0 },
#if 0
	{ KA410_SCS_BASE,	KA410_SCS_END,	KA410_SCS_SIZE, 0 },
#else
	{ 0x200C0000,		0x200C01FF,	0x200,		0 },
#endif
	{ KA410_LAN_BASE,	KA410_LAN_END,	KA410_LAN_SIZE, 0 },
	{ KA410_CUR_BASE,	KA410_CUR_END,	KA410_CUR_SIZE, 0 },
	{ KA410_DMA_BASE,	KA410_DMA_END,	KA410_DMA_SIZE, 0 },
	/*
	 * there's more to come, eg. framebuffers (mono + GPX)
	 */
	{0, 0, 0, 0},
};
d72 1
a72 2
	ka410_steal_pages,
	no_nicr_clock,
d79 1
a79 4
	(void*)KA410_INTREQ,      /* Used by vaxstation */
	(void*)KA410_INTCLR,      /* Used by vaxstation */
	(void*)KA410_INTMSK,      /* Used by vaxstation */
	ka410_map,
d82 1
d87 1
a87 3
ka410_conf(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
d89 3
a91 1
	extern char cpu_model[];
d95 2
a96 4
		if (vax_confdata & 0x80)	/* MSB in CFGTST */
			strcpy(cpu_model,"MicroVAX 2000");
		else
			strcpy(cpu_model,"VAXstation 2000");
d100 14
a113 3
		/* if (((vax_siedata >> 8) & 0xff) == 2) */
		strcpy(cpu_model,"VAXstation 3100 model 10-48");
		/* ka41_cache_enable(); */
d115 9
d125 6
a130 1
	printf(": %s\n", cpu_model);
d144 1
a144 104
}

u_long le_iomem;			/* base addr of RAM -- CPU's view */
u_long le_ioaddr;			/* base addr of RAM -- LANCE's view */

void
ka410_steal_pages()
{
	extern	vm_offset_t avail_start, virtual_avail, avail_end;
        extern  int clk_adrshift, clk_tweak;
	int	junk;

	int	i;
	struct {
		u_long     :2;
		u_long data:8;
		u_long     :22;
	} *p;
	int *srp;	/* Scratch Ram */
	char *q = (void*)&srp;

	srp = NULL;
	p = (void*)KA410_SCR;
	for (i=0; i<4; i++) {
	  printf("p[%d] = %x, ", i, p[i].data);
	  q[i]	= p[i].data;
	}
	p = (void*)KA410_SCRLEN;
	printf("\nlen = %d\n", p->data);
	printf("srp = 0x%x\n", srp);

	for (i=0; i<0x2; i++) {
		printf("%x:0x%x ", i*4, srp[i]);
		if ((i & 0x07) == 0x07)
			printf("\n");
	}
	printf("\n");

	/* 
	 * SCB is already copied/initialized at addr avail_start
	 * by pmap_bootstrap(), but it's not yet mapped. Thus we use
	 * the MAPPHYS() macro to reserve these two pages and to
	 * perform the mapping. The mapped address is assigned to junk.
	 */
	MAPPHYS(junk, 2, VM_PROT_READ|VM_PROT_WRITE);

	clk_adrshift = 1;       /* Addressed at long's... */
	clk_tweak = 2;          /* ...and shift two */
	MAPVIRT(clk_page, 2);
	pmap_map((vm_offset_t)clk_page, (vm_offset_t)KA410_WAT_BASE,
	    (vm_offset_t)KA410_WAT_BASE + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	/*
	 * At top of physical memory there are some console-prom and/or
	 * restart-specific data. Make this area unavailable.
	 */
	avail_end -= 10 * NBPG;

	/*
	 * If we need to map physical areas also, we can decrease avail_end
	 * (the highest available memory-address), copy the stuff into the
	 * gap between and use pmap_map to map it...
	 *
	 * Don't use the MAPPHYS macro here, since this uses and changes(!)
	 * the value of avail_start. Use MAPVIRT even if it's name misleads.
	 */
	avail_end -= 10 * NBPG;		/* paranoid: has been done before */

	avail_end = (int)srp;

	avail_end &= ~0xffff;		/* make avail_end 64K-aligned */
	avail_end -= (64 * 1024);	/* steal 64K for LANCE's iobuf */
	le_ioaddr = avail_end;		/* ioaddr=phys, iomem=virt */
	MAPVIRT(le_iomem, (64 * 1024)/NBPG);
	pmap_map((vm_offset_t)le_iomem, le_ioaddr, le_ioaddr + 0xffff,
		 VM_PROT_READ|VM_PROT_WRITE);

	printf("le_iomem: %x, le_ioaddr: %x, srp: %x, avail_end: %x\n",
	       le_iomem, le_ioaddr, srp, avail_end);

	/*
	 * VAXstation 2000 and MicroVAX 2000: 
	 * since there's no bus, we have to map in anything which 
	 * could be neccessary/used/interesting...
	 * 
	 * MAPVIRT(ptr,count) reserves a virtual area with the requested size
	 *			and initializes ptr to point at this location
	 * pmap_map(ptr,...)  inserts a pair of virtual/physical addresses
	 *			into the system maptable (Sysmap)
	 */
	uvax_fillmap();

	/*
	 * Clear restart and boot in progress flags
	 * in the CPMBX. (ie. clear bits 4 and 5)
	 */
	KA410_WAT_BASE->cpmbx = (KA410_WAT_BASE->cpmbx & ~0x30);

	/*
	 * Enable memory parity error detection and clear error bits.
	 */
	KA410_CPU_BASE->ka410_mser = 1; 
	/* (UVAXIIMSER_PEN | UVAXIIMSER_MERR | UVAXIIMSER_LEB); */

d160 12
@


1.5.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: ka410.c,v 1.6 2000/04/27 01:10:12 bjc Exp $ */
/*	$NetBSD: ka410.c,v 1.21 1999/09/06 19:52:53 ragge Exp $ */
a39 2
#include <sys/systm.h>

a50 1
#include <machine/ka420.h>
a51 1
#include <machine/vsbus.h>
d53 3
a55 1
static	void	ka410_conf __P((void));
a59 2
static	void	ka41_cache_enable __P((void));
static	void	ka410_clrf __P((void));
d61 22
a82 2
static	caddr_t	l2cache;	/* mapped in address */
static	long 	*cacr;		/* l2csche ctlr reg */
d88 2
a89 1
	0,
d96 4
a99 1
	2,	/* SCB pages */
a101 1
	ka410_clrf,
d106 3
a108 1
ka410_conf()
d110 1
a110 3
	struct vs_cpu *ka410_cpu;

	ka410_cpu = (struct vs_cpu *)vax_map_physmem(VS_REGS, 1);
d114 4
a117 2
		ka410_cpu->vc_410mser = 1;
		printf("cpu: KA410\n");
d121 3
a123 14
		printf("cpu: KA41/42\n");
		ka410_cpu->vc_vdcorg = 0; /* XXX */
		ka410_cpu->vc_parctl = PARCTL_CPEN | PARCTL_DPEN ;
		printf("cpu: Enabling primary cache, ");
		mtpr(KA420_CADR_S2E|KA420_CADR_S1E|KA420_CADR_ISE|KA420_CADR_DSE, 
			PR_CADR);
		if (vax_confdata & KA420_CFG_CACHPR) {
			l2cache = (void *)vax_map_physmem(KA420_CH2_BASE,
			    (KA420_CH2_SIZE / VAX_NBPG));
			cacr = (void *)vax_map_physmem(KA420_CACR, 1);
			printf("secondary cache\n");
			ka41_cache_enable();
		} else
			printf("no secondary cache present\n");
a124 9
	/* Done with ka410_cpu - release it */
	vax_unmap_physmem((vaddr_t)ka410_cpu, 1);
	/*
	 * Setup parameters necessary to read time from clock chip.
	 */
	clk_adrshift = 1;       /* Addressed at long's... */
	clk_tweak = 2;          /* ...and shift two */
	clk_page = (short *)vax_map_physmem(KA420_WAT_BASE, 1);
}
d126 1
a126 6
void
ka41_cache_enable()
{
	*cacr = KA420_CACR_TPE; 	/* Clear any error, disable cache */
	bzero(l2cache, KA420_CH2_SIZE); /* Clear whole cache */
	*cacr = KA420_CACR_CEN;		/* Enable cache */
d140 104
a243 1
	return 0;
a258 12
}

static void
ka410_clrf()
{
	struct ka410_clock *clk = (void *)clk_page;

	/*
	 * Clear restart and boot in progress flags
	 * in the CPMBX. (ie. clear bits 4 and 5)
	 */
	clk->cpmbx = (clk->cpmbx & ~0x30);
@


1.5.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.5.12.1 2001/05/14 21:38:54 niklas Exp $ */
d43 1
@


1.5.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d42 1
a42 1
#include <uvm/uvm_extern.h>
@


1.5.12.4
log
@Merge in -current from about a week ago
@
text
@d56 7
a62 7
static	void	ka410_conf(void);
static	void	ka410_memerr(void);
static	int	ka410_mchk(caddr_t);
static	void	ka410_halt(void);
static	void	ka410_reboot(int);
static	void	ka41_cache_enable(void);
static	void	ka410_clrf(void);
@


1.4
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ka410.c,v 1.3 1997/09/10 12:04:46 maja Exp $ */
d122 1
a122 1
		strcpy(cpu_model,"MicroVAX 3100 (KA41)");
@


1.3
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: ka410.c,v 1.2 1997/05/29 00:05:19 niklas Exp $ */
/*	$NetBSD: ka410.c,v 1.6 1997/04/18 18:49:35 ragge Exp $ */
d58 4
d100 2
a148 1
        extern  short *clk_page;
d244 15
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: ka410.c,v 1.3 1996/10/13 03:35:42 christos Exp $ */
/*	$NetBSD: ka410.c,v 1.3 1996/10/13 03:35:42 christos Exp $ */
d19 2
a20 2
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
a35 2


d44 1
d53 5
a57 11
/*
 * Maybe all these variables/functions should be static or "integrate"
 */
void	ka410_conf __P((struct device*, struct device*, void*));
void	ka410_memenable __P((struct sbi_attach_args *, struct device *));
void	ka410_steal_pages __P((void));

#ifdef notyet
void	ka410_memerr __P((void));
int	ka410_mchk __P((caddr_t));
#endif
d59 1
a59 6
struct  ka410_cpu   *ka410_cpuptr = (void*)KA410_CPU_BASE;
struct  ka410_clock *ka410_clkptr = (void*)KA410_WAT_BASE;

extern int uVAX_fillmap __P((struct uc_map *));

struct uc_map ka410_map[] = {
d61 5
a65 5
	{ KA410_ROM_BASE,	KA410_ROM_END,	KA410_ROM_SIZE,	0 },
	{ KA410_CPU_BASE,	KA410_CPU_END,	KA410_CPU_SIZE,	0 },
	{ KA410_NWA_BASE,	KA410_NWA_END,	KA410_NWA_SIZE,	0 },
	{ KA410_SER_BASE,	KA410_SER_END,	KA410_SER_SIZE,	0 },
	{ KA410_WAT_BASE,	KA410_WAT_END,	KA410_WAT_SIZE,	0 },
d67 1
a67 1
	{ KA410_SCS_BASE,	KA410_SCS_END,	KA410_SCS_SIZE,	0 },
d71 3
a73 3
	{ KA410_LAN_BASE,	KA410_LAN_END,	KA410_LAN_SIZE,	0 },
	{ KA410_CUR_BASE,	KA410_CUR_END,	KA410_CUR_SIZE,	0 },
	{ KA410_DMA_BASE,	KA410_DMA_END,	KA410_DMA_SIZE,	0 },
d80 17
a96 19
int
ka410_setup(uc,flags)
	struct uvax_calls *uc;
	int flags;
{
	uc->uc_name = "ka410";

	uc->uc_phys2virt = NULL;	/* ka410_mapaddr; */
	uc->uc_physmap = ka410_map;	/* ptv_map ? p2v_map */

	uc->uc_steal_pages = ka410_steal_pages;
	uc->uc_conf = ka410_conf;
	uc->uc_clkread = ka410_clkread;
	uc->uc_clkwrite = ka410_clkwrite;

#ifdef notyet
	uc->uc_memerr = ka410_memerr;
	uc->uc_mchk = ka410_mchk;
#endif
a97 6
	uc->uc_intreq = (void*)KA410_INTREQ;
	uc->uc_intclr = (void*)KA410_INTCLR;
	uc->uc_intmsk = (void*)KA410_INTMSK;

	uc->uc_busTypes = VAX_VSBUS;
}
d106 13
a118 4
	if (vax_confdata & 0x80)	/* MSB in CFGTST */
		strcpy(cpu_model,"MicroVAX 2000");
	else
		strcpy(cpu_model,"VAXstation 2000");
d123 12
a135 3
/*
 *
 */
d142 3
a144 1
	extern  vm_offset_t avail_start, virtual_avail, avail_end;
d149 3
a151 3
	  u_long     :2;
	  u_long data:8;
	  u_long     :22;
d160 1
a160 1
	  q[i]  = p[i].data;
d167 4
a170 4
	  printf("%x:0x%x ", i*4, srp[i]);
	  if ((i & 0x07) == 0x07)
	    printf("\n");
 	}
d181 6
d225 1
a225 1
	uVAX_fillmap(ka410_map);
d231 1
a231 1
	ka410_clkptr->cpmbx = (ka410_clkptr->cpmbx & ~0x30);
d236 1
a236 1
	ka410_cpuptr->ka410_mser = 1; 
a238 7
	/*
	 * MM is not yet enabled, thus we still used the physical addresses,
	 * but before leaving this routine, we need to reset them to virtual.
	 */
	ka410_cpuptr = (void*)uvax_phys2virt(KA410_CPU_BASE);
	ka410_clkptr = (void*)uvax_phys2virt(KA410_WAT_BASE);

a239 10
/*
 * define what we need and overwrite the uVAX_??? names
 */

#define uVAX_clock	ka410_clock
#define uVAX_clkptr	ka410_clkptr
#define uVAX_clkread	ka410_clkread
#define uVAX_clkwrite	ka410_clkwrite

#include <arch/vax/vax/uvax_proto.c>
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
