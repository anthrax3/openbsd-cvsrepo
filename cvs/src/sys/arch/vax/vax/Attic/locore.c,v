head	1.37;
access;
symbols
	OPENBSD_4_7:1.35.0.4
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.8
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.29.0.10
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.8
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.6
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.4
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.25
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.12
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.10
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2010.05.26.16.35.28;	author deraadt;	state dead;
branches;
next	1.36;

1.36
date	2010.04.21.03.11.28;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.30.20.45.31;	author martin;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.18.23.19.29;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.03.30.18.25.13;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.27.16.55.41;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.15.20.27.41;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.30.18.31.49;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.08.14.53.11;	author hugh;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.06.18.54.20;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.15.01.51.13;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.21.09.17.14;	author hugh;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.11.09.36.24;	author hugh;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.31.11.44.53;	author hugh;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.31.11.42.52;	author hugh;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.10.01.12.56.43;	author hugh;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.26.11.48.06;	author hugh;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.01.17.15.22;	author hugh;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.16.22.46.26;	author hugh;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.12.11.45.38;	author hugh;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.25.15.52.21;	author hugh;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.24.10.31.58;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.30.17.10.05;	author hugh;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.10.18.21.28;	author bjc;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.27.01.10.13;	author bjc;	state Exp;
branches;
next	1.9;

1.9
date	97.09.10.12.04.50;	author maja;	state Exp;
branches
	1.9.12.1;
next	1.8;

1.8
date	97.05.29.00.05.23;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.01.15.23.25.17;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	96.06.12.08.20.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.03.09.10.17;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.31.05.16.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.14.00.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches;
next	;

1.9.12.1
date	2001.05.14.21.39.04;	author niklas;	state Exp;
branches;
next	1.9.12.2;

1.9.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.9.12.3;

1.9.12.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.9.12.4;

1.9.12.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.9.12.5;

1.9.12.5
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.9.12.6;

1.9.12.6
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.9.12.7;

1.9.12.7
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.9.12.8;

1.9.12.8
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.01.31.22.55.27;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@rename intvec.s to locore.S, and add the guts of locore.C to machdep.c
ok miod ragge
We cannot yet get at vax/subr.s via files.vax because rdsetroot doesn't
like it when the "start" symbol isn't in the first page of the executable.
subr.s will have to be merged into locore.S later on, when other problems
with ENTRY() are solved (says Miod)
@
text
@/*	$OpenBSD: locore.c,v 1.36 2010/04/21 03:11:28 deraadt Exp $	*/
/*	$NetBSD: locore.c,v 1.43 2000/03/26 11:39:45 ragge Exp $	*/
/*
 * Copyright (c) 1994, 1998 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

 /* All bugs are subject to removal without further notice */
		

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/sid.h>
#include <machine/param.h>
#include <machine/vmparam.h>
#include <machine/pcb.h>
#include <machine/pte.h>
#include <machine/pmap.h>
#include <machine/nexus.h>
#include <machine/rpb.h>
#include <machine/cca.h>

void	start(struct rpb *);
void	main(void);

extern	paddr_t avail_end;
extern	int physmem;
paddr_t	esym;
u_int	proc0paddr;
char	cpu_model[100];

/*
 * The strict cpu-dependent information is set up here, in
 * form of a pointer to a struct that is specific for each cpu.
 */
extern struct cpu_dep ka780_calls;
extern struct cpu_dep ka750_calls;
extern struct cpu_dep ka860_calls;
extern struct cpu_dep ka820_calls;
extern struct cpu_dep ka43_calls;
extern struct cpu_dep ka46_calls;
extern struct cpu_dep ka48_calls;
extern struct cpu_dep ka49_calls;
extern struct cpu_dep ka53_calls;
extern struct cpu_dep ka410_calls;
extern struct cpu_dep ka630_calls;
extern struct cpu_dep ka650_calls;
extern struct cpu_dep ka660_calls;
extern struct cpu_dep ka670_calls;
extern struct cpu_dep ka680_calls;
extern struct cpu_dep ka60_calls;
extern struct cpu_dep vxt_calls;

/*
 * Start is called from boot; the first routine that is called
 * in kernel. Kernel stack is setup somewhere in a safe place;
 * but we need to move it to a better known place. Memory
 * management is disabled, and no interrupt system is active.
 */
void
start(struct rpb *prpb)
{
	extern vaddr_t scratch;
	int preserve_cca = 0;

	mtpr(AST_NO, PR_ASTLVL); /* Turn off ASTs */

	findcpu(); /* Set up the CPU identifying variables */

	if (vax_confdata & 0x80)
		strlcpy(cpu_model, "MicroVAX ", sizeof cpu_model);
	else
		strlcpy(cpu_model, "VAXstation ", sizeof cpu_model);

	switch (vax_boardtype) {
#if VAX780
	case VAX_BTYP_780:
		dep_call = &ka780_calls;
		strlcpy(cpu_model,"VAX 11/780", sizeof cpu_model);
		if (vax_cpudata & 0x100)
			cpu_model[9] = '5';
		break;
#endif
#if VAX750
	case VAX_BTYP_750:
		dep_call = &ka750_calls;
		strlcpy(cpu_model, "VAX 11/750", sizeof cpu_model);
		break;
#endif
#if VAX8600
	case VAX_BTYP_790:
		dep_call = &ka860_calls;
		strlcpy(cpu_model,"VAX 8600", sizeof cpu_model);
		if (vax_cpudata & 0x100)
			cpu_model[6] = '5';
		break;
#endif
#if VAX410
	case VAX_BTYP_420: /* They are very similar */
		dep_call = &ka410_calls;
		strlcat(cpu_model, "3100", sizeof cpu_model);
		switch ((vax_siedata >> 8) & 0xff) {
		case 0x00:
			strlcat(cpu_model, "/m{30,40}", sizeof cpu_model);
			break;
		case 0x01:
			strlcat(cpu_model, "/m{38,48}", sizeof cpu_model);
			break;
		case 0x02:
			strlcat(cpu_model, "/m{10,20}{,e}", sizeof cpu_model);
			break;
		}
		break;

	case VAX_BTYP_410:
		dep_call = &ka410_calls;
		strlcat(cpu_model, "2000", sizeof cpu_model);
		break;
#endif
#if VAX43
	case VAX_BTYP_43:
		dep_call = &ka43_calls;
		strlcat(cpu_model, "3100/m76", sizeof cpu_model);
		break;
#endif
#if VAX46
	case VAX_BTYP_46:
		dep_call = &ka46_calls;
		switch(vax_siedata & 0xff) {
		case VAX_VTYP_47:
			strlcpy(cpu_model, "MicroVAX 3100 m80", sizeof cpu_model);
			break;
		case VAX_VTYP_46:
			strlcpy(cpu_model, "VAXstation 4000/60", sizeof cpu_model);
			break;
		default:
			strlcat(cpu_model, " - Unknown Mariah", sizeof cpu_model);
		}
		break;
#endif
#ifdef VXT
	case VAX_BTYP_VXT:
		dep_call = &vxt_calls;
		strlcpy(cpu_model, "VXT2000", sizeof cpu_model);
		break;
#endif
#if VAX48
	case VAX_BTYP_48:
		dep_call = &ka48_calls;
		switch ((vax_siedata >> 8) & 0xff) {
		case VAX_STYP_45:
			strlcpy(cpu_model, "MicroVAX 3100/m{30,40}", sizeof cpu_model);
			break;
		case VAX_STYP_48:
			strlcpy(cpu_model, "VAXstation 4000/VLC", sizeof cpu_model);
			break;
		default:
			strlcat(cpu_model, " - Unknown SOC", sizeof cpu_model);
		}
		break;
#endif
#if VAX49
	case VAX_BTYP_49:
		dep_call = &ka49_calls;
		strlcpy(cpu_model, "VAXstation 4000/90", sizeof cpu_model);
		break;
#endif
#if VAX53
	case VAX_BTYP_1303:	
		dep_call = &ka53_calls;
		switch ((vax_siedata >> 8) & 0xff) {
		case VAX_STYP_50:
			strlcpy(cpu_model, "MicroVAX 3100 model 85 or 90", sizeof cpu_model);
			break;
		case VAX_STYP_51:
			strlcpy(cpu_model, "MicroVAX 3100 model 90 or 95", sizeof cpu_model);
			break;
		case VAX_STYP_52:
			strlcpy(cpu_model, "VAX 4000 100", sizeof cpu_model);
			break;
		case VAX_STYP_53:
			strlcpy(cpu_model, "VAX 4000 105A", sizeof cpu_model);
			break;
		default:
			strlcpy(cpu_model, "VAX - Unknown Cheetah Class", sizeof cpu_model);
		}
		break;
#endif
#if VAX630
	case VAX_BTYP_630:
		dep_call = &ka630_calls;
		strlcpy(cpu_model,"MicroVAX II", sizeof cpu_model);
		break;
#endif
#if VAX650
	case VAX_BTYP_650:
		dep_call = &ka650_calls;
		strlcpy(cpu_model,"MicroVAX ", sizeof cpu_model);
		switch ((vax_siedata >> 8) & 255) {
		case VAX_SIE_KA640:
			strlcat(cpu_model, "3300/3400", sizeof cpu_model);
			break;

		case VAX_SIE_KA650:
			strlcat(cpu_model, "3500/3600", sizeof cpu_model);
			break;

		case VAX_SIE_KA655:
			strlcat(cpu_model, "3800/3900", sizeof cpu_model);
			break;

		default:
			strlcat(cpu_model, "III", sizeof cpu_model);
			break;
		}
		break;
#endif
#if VAX660
	case VAX_BTYP_660:
		dep_call = &ka660_calls;
		strlcpy(cpu_model,"VAX 4000 200", sizeof cpu_model);
		break;
#endif
#if VAX670
	case VAX_BTYP_670:
		dep_call = &ka670_calls;
		strlcpy(cpu_model,"VAX 4000 300", sizeof cpu_model);
		break;
#endif
#if VAX680
	case VAX_BTYP_1301:
		dep_call = &ka680_calls;
		strlcpy(cpu_model,"VAX 4000 ", sizeof cpu_model);
		switch ((vax_siedata >> 8) & 0xff) {
		case VAX_STYP_675:
			strlcat(cpu_model,"400", sizeof cpu_model);
			break;
		case VAX_STYP_680:
			strlcat(cpu_model,"500", sizeof cpu_model);
			break;
		case VAX_STYP_690:
			strlcat(cpu_model,"600", sizeof cpu_model);
			break;
		default:
			strlcat(cpu_model,"- Unknown Omega Class", sizeof cpu_model);
		}
		break;
	case VAX_BTYP_1305:
		dep_call = &ka680_calls;
		strlcpy(cpu_model,"VAX 4000 ", sizeof cpu_model);
		switch ((vax_siedata >> 8) & 0xff) {
		case VAX_STYP_681:
			strlcat(cpu_model,"500A", sizeof cpu_model);
			break;
		case VAX_STYP_691:
			strlcat(cpu_model,"605A", sizeof cpu_model);
			break;
		case VAX_STYP_694:
			if (vax_cpudata & 0x1000)
				strlcat(cpu_model,"705A", sizeof cpu_model);
			else
				strlcat(cpu_model,"700A", sizeof cpu_model);
			break;
		default:
			strlcat(cpu_model,"- Unknown Legacy Class", sizeof cpu_model);
		}
		break;
#endif
#if VAX8200
	case VAX_BTYP_8000:
		mastercpu = mfpr(PR_BINID);
		dep_call = &ka820_calls;
		strlcpy(cpu_model, "VAX 8200", sizeof cpu_model);
		break;
#endif
#ifdef VAX60
	case VAX_BTYP_60:
		dep_call = &ka60_calls;
		preserve_cca = 1;
		/* cpu_model will be set in ka60_init */
		break;
#endif
	default:
		/* CPU not supported, just give up */
		asm("halt");
	}

	/*
	 * Machines older than MicroVAX II have their boot blocks
	 * loaded directly or the boot program loaded from console
	 * media, so we need to figure out their memory size.
	 * This is not easily done on MicroVAXen, so we get it from
	 * VMB instead.
	 *
	 * In post-1.4 a RPB is always provided from the boot blocks.
	 */
#if 1 /* compat with old bootblocks */
	if (prpb == 0) {
		bzero((caddr_t)proc0paddr + REDZONEADDR, sizeof(struct rpb));
		prpb = (struct rpb *)(proc0paddr + REDZONEADDR);
		prpb->pfncnt = avail_end >> VAX_PGSHIFT;
		prpb->rpb_base = (void *)-1;    /* RPB is fake */
	} else
#endif
	bcopy(prpb, (caddr_t)proc0paddr + REDZONEADDR, sizeof(struct rpb));
	if (prpb->pfncnt)
		avail_end = prpb->pfncnt << VAX_PGSHIFT;
	else
		while (badaddr((caddr_t)avail_end, 4) == 0)
			avail_end += VAX_NBPG * 128;
	boothowto = prpb->rpb_bootr5;

	physmem = atop(avail_end);

	/*
	 * If we need to use the Console Communication Area, make sure
	 * we will not stomp over it.
	 *
	 * On KA60 systems, the PROM apparently forgets to keep the CCA
	 * out of the reported memory size.  It's no real surprise, as
	 * the memory bitmap pointed to by the CCA reports all physical
	 * memory (including itself and the CCA) as available!
	 * (which means the bitmap is not worth looking at either)
	 */

	if (preserve_cca) {
		if (prpb->cca_addr != 0 && avail_end > prpb->cca_addr) {
			struct cca *cca = (struct cca *)prpb->cca_addr;

			/*
			 * XXX Should validate the CCA image here.
			 */

			avail_end = prpb->cca_addr;
			if (cca->cca_bitmap != 0 && avail_end > cca->cca_bitmap)
				avail_end = cca->cca_bitmap;
		}
	}

        avail_end = trunc_page(avail_end); /* be sure */

	proc0.p_addr = (struct user *)proc0paddr; /* XXX */
	bzero((struct user *)proc0paddr, sizeof(struct user));

	/* Clear the used parts of the uarea except for the pcb */
	bzero(&proc0.p_addr->u_stats, sizeof(struct user) - sizeof(struct pcb));

	pmap_bootstrap();

	/* Now running virtual. set red zone for proc0 */
	*kvtopte((u_int)proc0.p_addr + REDZONEADDR) &= ~PG_V;

	((struct pcb *)proc0paddr)->framep = (void *)scratch;

	/*
	 * Change mode down to userspace is done by faking a stack
	 * frame that is setup in cpu_set_kpc(). Not done by returning
	 * from main anymore.
	 */
	main();
	/* NOTREACHED */
}
@


1.36
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.35 2008/08/30 20:45:31 martin Exp $	*/
@


1.35
log
@replace TRUNC_PAGE by trunc_page and ROUND_PAGE by round_page
plus cast to vaddr_t where necassary

from Miod's todo list

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.34 2008/08/18 23:19:29 miod Exp $	*/
d40 1
@


1.34
log
@Add support for the ``Firefox'' VAXstation 3520/3540/3820/3840 workstations,
currently limited to serial console and a single processor working.

All ``on-board'' devices, including the Q-bus adapter, but except for
the frame buffer, are supported. The machine will boot over the network
or from SCSI devices.

Lots of thanks to Al Kossow for www.bitsavers.org, on which I found the
technical documentation allowing me to complete this port (which was
lacking at the time I got that machine...).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.33 2008/03/30 18:25:13 miod Exp $	*/
d372 1
a372 1
        avail_end = TRUNC_PAGE(avail_end); /* be sure */
@


1.33
log
@Use vaddr_t instead of void * for some initial virtual memory layout arithmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.32 2006/08/27 16:55:41 miod Exp $	*/
d53 1
d59 1
d83 1
d96 1
d308 7
d344 27
@


1.32
log
@Work-in-progress VXT2000 support (commented out in GENERIC so far). Glass
console works on color model, serial console works, ethernet attaches but
does not work correctly yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.31 2006/08/15 20:27:41 miod Exp $	*/
d92 1
a92 1
	extern void *scratch;
d347 1
a347 1
	((struct pcb *)proc0paddr)->framep = scratch;
@


1.31
log
@Some VS4k/90 have the uVAX bit set in confdata, do not report them as uVAXens.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.30 2006/07/30 18:31:49 miod Exp $	*/
d81 1
d167 6
@


1.30
log
@Report MicroVAX 3100 m{10,20}{,e} as such instead of bare ``MicroVAX 3100'';
ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.29 2003/11/10 21:05:06 miod Exp $	*/
d186 1
a186 1
		strlcat(cpu_model, "4000/90", sizeof cpu_model);
@


1.29
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.28 2003/04/08 14:53:11 hugh Exp $	*/
d129 5
a133 1
		if (((vax_siedata >> 8) & 0xff) == 1)
d135 5
a139 2
		else if (((vax_siedata >> 8) & 0xff) == 0)
			strlcat(cpu_model, "/m{30,40}", sizeof cpu_model);
d156 1
a156 1
		switch(vax_siedata & 0xFF) {
d171 1
a171 1
		switch((vax_siedata >> 8) & 0xFF) {
d192 1
a192 1
		switch((vax_siedata >> 8) & 0xFF) {
d255 1
a255 1
		switch((vax_siedata & 0xff00) >> 8) {
d272 1
a272 1
		switch((vax_siedata & 0xff00) >> 8) {
@


1.28
log
@Move definition of storage for cpu_model to locore.c so sizeof has
something meaningful to chew on. Shine on you crazy diamond.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.27 2003/04/06 18:54:20 ho Exp $	*/
a91 1
	struct pte *pt;
d331 1
a331 2
	pt = kvtopte((u_int)proc0.p_addr + REDZONEADDR);
        pt->pg_v = 0;
@


1.27
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.26 2002/12/15 01:51:13 miod Exp $	*/
d60 1
a90 1
	extern char cpu_model[];
@


1.26
log
@Correctly report MicroVAX-30 as a MicroVAX, not a VAXstation.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.25 2002/07/21 09:17:14 hugh Exp $	*/
d99 1
a99 1
		strcpy(cpu_model, "MicroVAX ");
d101 1
a101 1
		strcpy(cpu_model, "VAXstation ");
d107 1
a107 1
		strcpy(cpu_model,"VAX 11/780");
d115 1
a115 1
		strcpy(cpu_model, "VAX 11/750");
d121 1
a121 1
		strcpy(cpu_model,"VAX 8600");
d129 1
a129 1
		strcat(cpu_model, "3100");
d131 1
a131 1
			strcat(cpu_model, "/m{38,48}");
d133 1
a133 1
			strcat(cpu_model, "/m{30,40}");
d138 1
a138 1
		strcat(cpu_model, "2000");
d144 1
a144 1
		strcat(cpu_model, "3100/m76");
d152 1
a152 1
			strcpy(cpu_model, "MicroVAX 3100 m80");
d155 1
a155 1
			strcpy(cpu_model, "VAXstation 4000/60");
d158 1
a158 1
			strcat(cpu_model, " - Unknown Mariah");
d167 1
a167 1
			strcpy(cpu_model, "MicroVAX 3100/m{30,40}");
d170 1
a170 1
			strcpy(cpu_model, "VAXstation 4000/VLC");
d173 1
a173 1
			strcat(cpu_model, " - Unknown SOC");
d180 1
a180 1
		strcat(cpu_model, "4000/90");
d188 1
a188 1
			strcpy(cpu_model, "MicroVAX 3100 model 85 or 90");
d191 1
a191 1
			strcpy(cpu_model, "MicroVAX 3100 model 90 or 95");
d194 1
a194 1
			strcpy(cpu_model, "VAX 4000 100");
d197 1
a197 1
			strcpy(cpu_model, "VAX 4000 105A");
d200 1
a200 1
			strcpy(cpu_model, "VAX - Unknown Cheetah Class");
d207 1
a207 1
		strcpy(cpu_model,"MicroVAX II");
d213 1
a213 1
		strcpy(cpu_model,"MicroVAX ");
d216 1
a216 1
			strcat(cpu_model, "3300/3400");
d220 1
a220 1
			strcat(cpu_model, "3500/3600");
d224 1
a224 1
			strcat(cpu_model, "3800/3900");
d228 1
a228 1
			strcat(cpu_model, "III");
d236 1
a236 1
		strcpy(cpu_model,"VAX 4000 200");
d242 1
a242 1
		strcpy(cpu_model,"VAX 4000 300");
d248 1
a248 1
		strcpy(cpu_model,"VAX 4000 ");
d251 1
a251 1
			strcat(cpu_model,"400");
d254 1
a254 1
			strcat(cpu_model,"500");
d257 1
a257 1
			strcat(cpu_model,"600");
d260 1
a260 1
			strcat(cpu_model,"- Unknown Omega Class");
d265 1
a265 1
		strcpy(cpu_model,"VAX 4000 ");
d268 1
a268 1
			strcat(cpu_model,"500A");
d271 1
a271 1
			strcat(cpu_model,"605A");
d275 1
a275 1
				strcat(cpu_model,"705A");
d277 1
a277 1
				strcat(cpu_model,"700A");
d280 1
a280 1
			strcat(cpu_model,"- Unknown Legacy Class");
d288 1
a288 1
		strcpy(cpu_model, "VAX 8200");
@


1.25
log
@Attempt to distinguish 4000 700A from 4000 705A. Results are so far
consistent with SID/XSID data from Mats O Jansson, Chuck McManis,
Antonio Carlini, Fred van Kempen, and Kees Stravers.
Tested by Fred van Kempen.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.24 2002/06/11 09:36:24 hugh Exp $	*/
d167 1
a167 1
			strcat(cpu_model, "3100/m{30,40}");
@


1.24
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.23 2002/03/14 01:26:48 millert Exp $	*/
d236 1
a236 1
		strcpy(cpu_model,"VAX 4000/200");
d242 1
a242 1
		strcpy(cpu_model,"VAX 4000/300");
d248 1
d251 1
a251 1
			strcpy(cpu_model,"VAX 4000 400");
d254 1
a254 1
			strcpy(cpu_model,"VAX 4000 500");
d257 1
a257 1
			strcpy(cpu_model,"VAX 4000 600");
d260 1
a260 1
			strcpy(cpu_model,"VAX - Unknown Omega Class");
d265 1
d268 1
a268 1
			strcpy(cpu_model,"VAX 4000 500A");
d271 1
a271 1
			strcpy(cpu_model,"VAX 4000 605A");
d274 4
a277 1
			strcpy(cpu_model,"VAX 4000 705A");
d280 1
a280 1
			strcpy(cpu_model,"VAX - Unknown Legacy Class");
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.22 2002/01/31 11:44:53 hugh Exp $	*/
d52 1
d54 1
a54 1
void	start(void);
d88 1
a88 1
start()
d291 24
a314 10
        /*
         * Machines older than MicroVAX II have their boot blocks
         * loaded directly or the boot program loaded from console
         * media, so we need to figure out their memory size.
         * This is not easily done on MicroVAXen, so we get it from
         * VMB instead.
         */
        if (avail_end == 0)
                while (badaddr((caddr_t)avail_end, 4) == 0)
                        avail_end += VAX_NBPG * 128;
@


1.22
log
@A little KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.21 2002/01/31 11:42:52 hugh Exp $	*/
d53 2
a54 2
void	start __P((void));
void	main __P((void));
@


1.21
log
@Add support for VAX 4000 500A.
Thanks to kernel testing by Andrew Reynolds.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.20 2001/11/06 19:53:17 miod Exp $	*/
d249 2
a250 1
			strcpy(cpu_model,"VAX 4000 400"); break;
d252 2
a253 3
			strcpy(cpu_model,"VAX 4000 500"); break;
		case VAX_STYP_681:
			strcpy(cpu_model,"VAX 4000 500A"); break;
d255 2
a256 3
			strcpy(cpu_model,"VAX 4000 600"); break;
		case VAX_STYP_691:
			strcpy(cpu_model,"VAX 4000 605A"); break;
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.19 2001/10/01 12:56:43 hugh Exp $	*/
d260 16
@


1.20.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.22 2002/01/31 11:44:53 hugh Exp $	*/
d249 1
a249 2
			strcpy(cpu_model,"VAX 4000 400");
			break;
d251 3
a253 2
			strcpy(cpu_model,"VAX 4000 500");
			break;
d255 3
a257 2
			strcpy(cpu_model,"VAX 4000 600");
			break;
a259 16
		}
		break;
	case VAX_BTYP_1305:
		dep_call = &ka680_calls;
		switch((vax_siedata & 0xff00) >> 8) {
		case VAX_STYP_681:
			strcpy(cpu_model,"VAX 4000 500A");
			break;
		case VAX_STYP_691:
			strcpy(cpu_model,"VAX 4000 605A");
			break;
		case VAX_STYP_694:
			strcpy(cpu_model,"VAX 4000 705A");
			break;
		default:
			strcpy(cpu_model,"VAX - Unknown Legacy Class");
@


1.20.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.20.2.1 2002/01/31 22:55:27 niklas Exp $	*/
d53 2
a54 2
void	start(void);
void	main(void);
@


1.20.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.20.2.2 2002/06/11 03:39:19 art Exp $	*/
a51 1
#include <machine/rpb.h>
d53 1
a53 1
void	start(struct rpb *);
d87 1
a87 1
start(struct rpb *prpb)
d235 1
a235 1
		strcpy(cpu_model,"VAX 4000 200");
d241 1
a241 1
		strcpy(cpu_model,"VAX 4000 300");
a246 1
		strcpy(cpu_model,"VAX 4000 ");
d249 1
a249 1
			strcat(cpu_model,"400");
d252 1
a252 1
			strcat(cpu_model,"500");
d255 1
a255 1
			strcat(cpu_model,"600");
d258 1
a258 1
			strcat(cpu_model,"- Unknown Omega Class");
a262 1
		strcpy(cpu_model,"VAX 4000 ");
d265 1
a265 1
			strcat(cpu_model,"500A");
d268 1
a268 1
			strcat(cpu_model,"605A");
d271 1
a271 4
			if (vax_cpudata & 0x1000)
				strcat(cpu_model,"705A");
			else
				strcat(cpu_model,"700A");
d274 1
a274 1
			strcat(cpu_model,"- Unknown Legacy Class");
d290 10
a299 24
	/*
	 * Machines older than MicroVAX II have their boot blocks
	 * loaded directly or the boot program loaded from console
	 * media, so we need to figure out their memory size.
	 * This is not easily done on MicroVAXen, so we get it from
	 * VMB instead.
	 *
	 * In post-1.4 a RPB is always provided from the boot blocks.
	 */
#if 1 /* compat with old bootblocks */
	if (prpb == 0) {
		bzero((caddr_t)proc0paddr + REDZONEADDR, sizeof(struct rpb));
		prpb = (struct rpb *)(proc0paddr + REDZONEADDR);
		prpb->pfncnt = avail_end >> VAX_PGSHIFT;
		prpb->rpb_base = (void *)-1;    /* RPB is fake */
	} else
#endif
	bcopy(prpb, (caddr_t)proc0paddr + REDZONEADDR, sizeof(struct rpb));
	if (prpb->pfncnt)
		avail_end = prpb->pfncnt << VAX_PGSHIFT;
	else
		while (badaddr((caddr_t)avail_end, 4) == 0)
			avail_end += VAX_NBPG * 128;
	boothowto = prpb->rpb_bootr5;
@


1.20.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a59 1
char	cpu_model[100];
d90 1
d99 1
a99 1
		strlcpy(cpu_model, "MicroVAX ", sizeof cpu_model);
d101 1
a101 1
		strlcpy(cpu_model, "VAXstation ", sizeof cpu_model);
d107 1
a107 1
		strlcpy(cpu_model,"VAX 11/780", sizeof cpu_model);
d115 1
a115 1
		strlcpy(cpu_model, "VAX 11/750", sizeof cpu_model);
d121 1
a121 1
		strlcpy(cpu_model,"VAX 8600", sizeof cpu_model);
d129 1
a129 1
		strlcat(cpu_model, "3100", sizeof cpu_model);
d131 1
a131 1
			strlcat(cpu_model, "/m{38,48}", sizeof cpu_model);
d133 1
a133 1
			strlcat(cpu_model, "/m{30,40}", sizeof cpu_model);
d138 1
a138 1
		strlcat(cpu_model, "2000", sizeof cpu_model);
d144 1
a144 1
		strlcat(cpu_model, "3100/m76", sizeof cpu_model);
d152 1
a152 1
			strlcpy(cpu_model, "MicroVAX 3100 m80", sizeof cpu_model);
d155 1
a155 1
			strlcpy(cpu_model, "VAXstation 4000/60", sizeof cpu_model);
d158 1
a158 1
			strlcat(cpu_model, " - Unknown Mariah", sizeof cpu_model);
d167 1
a167 1
			strlcpy(cpu_model, "MicroVAX 3100/m{30,40}", sizeof cpu_model);
d170 1
a170 1
			strlcpy(cpu_model, "VAXstation 4000/VLC", sizeof cpu_model);
d173 1
a173 1
			strlcat(cpu_model, " - Unknown SOC", sizeof cpu_model);
d180 1
a180 1
		strlcat(cpu_model, "4000/90", sizeof cpu_model);
d188 1
a188 1
			strlcpy(cpu_model, "MicroVAX 3100 model 85 or 90", sizeof cpu_model);
d191 1
a191 1
			strlcpy(cpu_model, "MicroVAX 3100 model 90 or 95", sizeof cpu_model);
d194 1
a194 1
			strlcpy(cpu_model, "VAX 4000 100", sizeof cpu_model);
d197 1
a197 1
			strlcpy(cpu_model, "VAX 4000 105A", sizeof cpu_model);
d200 1
a200 1
			strlcpy(cpu_model, "VAX - Unknown Cheetah Class", sizeof cpu_model);
d207 1
a207 1
		strlcpy(cpu_model,"MicroVAX II", sizeof cpu_model);
d213 1
a213 1
		strlcpy(cpu_model,"MicroVAX ", sizeof cpu_model);
d216 1
a216 1
			strlcat(cpu_model, "3300/3400", sizeof cpu_model);
d220 1
a220 1
			strlcat(cpu_model, "3500/3600", sizeof cpu_model);
d224 1
a224 1
			strlcat(cpu_model, "3800/3900", sizeof cpu_model);
d228 1
a228 1
			strlcat(cpu_model, "III", sizeof cpu_model);
d236 1
a236 1
		strlcpy(cpu_model,"VAX 4000 200", sizeof cpu_model);
d242 1
a242 1
		strlcpy(cpu_model,"VAX 4000 300", sizeof cpu_model);
d248 1
a248 1
		strlcpy(cpu_model,"VAX 4000 ", sizeof cpu_model);
d251 1
a251 1
			strlcat(cpu_model,"400", sizeof cpu_model);
d254 1
a254 1
			strlcat(cpu_model,"500", sizeof cpu_model);
d257 1
a257 1
			strlcat(cpu_model,"600", sizeof cpu_model);
d260 1
a260 1
			strlcat(cpu_model,"- Unknown Omega Class", sizeof cpu_model);
d265 1
a265 1
		strlcpy(cpu_model,"VAX 4000 ", sizeof cpu_model);
d268 1
a268 1
			strlcat(cpu_model,"500A", sizeof cpu_model);
d271 1
a271 1
			strlcat(cpu_model,"605A", sizeof cpu_model);
d275 1
a275 1
				strlcat(cpu_model,"705A", sizeof cpu_model);
d277 1
a277 1
				strlcat(cpu_model,"700A", sizeof cpu_model);
d280 1
a280 1
			strlcat(cpu_model,"- Unknown Legacy Class", sizeof cpu_model);
d288 1
a288 1
		strlcpy(cpu_model, "VAX 8200", sizeof cpu_model);
@


1.19
log
@Use system variant types rather than 0x80 on the configuration and
test register to tell VAXstation 4000/60 from MicroVAX 3100m80.
This seems to produce more reliable results (should work for both
Norm's and Solar's 3100m80's).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.18 2001/08/26 11:48:06 hugh Exp $	*/
d42 1
a42 1
#include <vm/vm.h>
@


1.18
log
@Attempt to use the configuration and test register to tell a
VS4000 60 KA46 from a MV 3100/80 KA47. Apparently does not work
on all 3100/80's, but better than nothing.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.17 2001/04/01 17:15:22 hugh Exp $	*/
d149 10
a158 4
		if (vax_confdata & 0x80)
			strcat(cpu_model, "3100/80");
		else
			strcat(cpu_model, "4000/60");
@


1.17
log
@Call VAX_STYP_50 a MicroVAX 3100/85, even though this machine is KA55.
Ambiguity is because DEC's docs differ from observed values.
Only cosmetic, at any rate.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.16 2001/03/16 22:46:26 hugh Exp $	*/
d149 4
a152 1
		strcat(cpu_model, "4000/60");
@


1.16
log
@Add some more model subtypes from Antonio Carlini.
Won't try to match VAX_STYP_692 until we can find a 4000 70x and learn
more about this model.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.15 2001/03/12 11:45:38 hugh Exp $	*/
d177 3
a188 1
		case VAX_STYP_50:
@


1.15
log
@Omega is now VAX_BTYP_1301. Also add an STYP for 4000 600.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.14 2001/02/25 15:52:21 hugh Exp $	*/
d241 2
d245 2
@


1.14
log
@Use the system subtype field on the SIE to determine if a machine is
VS4000/vlc or MV3100/{3,4}0. This seems to produce more consistent
detection than checking the configuration and test register.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.13 2001/02/24 10:31:58 hugh Exp $	*/
d234 1
a234 1
	case VAX_BTYP_680:
d238 1
a238 1
			strcpy(cpu_model,"VAX 4000/400"); break;
d240 3
a242 1
			strcpy(cpu_model,"VAX 4000/500"); break;
@


1.13
log
@Support for VAX 4000/{2,4,5}00 from Michael Kukat. untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.12 2001/01/30 17:10:05 hugh Exp $	*/
d155 2
a156 1
		if (vax_confdata & 0x80)
d158 7
a164 2
		else
			strcat(cpu_model, "4000 VLC");
@


1.12
log
@Improve printing of various NVAX models. Similar to work by Michael Kukat.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.11 2000/10/10 18:21:28 bjc Exp $	*/
d78 1
d225 13
@


1.11
log
@- add some cases for ka52/53 (VAX_BTYP_1303), tested by hugh
- things depend on proc0paddr being zero'd out, so do it
- also forgot a "3100" in a cpu_model
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.10 2000/04/27 01:10:13 bjc Exp $	*/
d169 14
a182 1
		strcat(cpu_model, "4000/{100,105A}");
@


1.10
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.9 1997/09/10 12:04:50 maja Exp $	*/
d72 1
d127 1
d154 4
a157 1
		strcat(cpu_model, "4000 VLC");
d166 6
d238 2
a239 1
	proc0.p_addr = (void *)proc0paddr; /* XXX */
@


1.9
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.c,v 1.8 1997/05/29 00:05:23 niklas Exp $	*/
/*	$NetBSD: locore.c,v 1.21 1997/04/06 20:37:05 ragge Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
a36 1
#include <sys/types.h>
d40 1
a43 2
#include <dev/cons.h>

d49 1
d56 3
a58 2
u_int	proc0paddr, esym;
int	*Sysmap, bootdev;
a59 14
/* 
 * We set up some information about the machine we're
 * running on and thus initializes/uses vax_cputype and vax_boardtype.
 * There should be no need to change/reinitialize these variables
 * outside of this routine, they should be read only!
 */
int vax_cputype;	/* highest byte of SID register */
int vax_bustype;	/* holds/defines all busses on this machine */
int vax_boardtype;	/* machine dependend, combination of SID and SIE */
int vax_systype;	/* machine dependend identification of the system */
 
int vax_cpudata;	/* contents of the SID register */
int vax_siedata;	/* contents of the SIE register */
int vax_confdata;	/* machine dependend, configuration/setup data */
d61 1
a61 1
 * Also; the strict cpu-dependent information is set up here, in
d69 3
d75 2
d87 3
a89 31
	register __boothowto asm ("r11");
	register __bootdev asm ("r10");
	register __esym asm ("r9");
	register __physmem asm ("r8");
	extern vm_offset_t avail_end;
	extern	u_int *end;
	extern	void *scratch;
	register tmpptr;

	/*
	 * We get parameters passed in registers from boot, put
	 * them in memory to save.
	 */
	boothowto = __boothowto;
	bootdev = __bootdev;
	esym = __esym | 0x80000000;
	avail_end = __physmem; /* Better to take from RPB, if available */

	asm("pushl $0x001f0000;pushl $to;rei;to:movw $0xfff, _panic");

	/*
	 * FIRST we must set up kernel stack, directly after end.
	 * This is the only thing we have to setup here, rest in pmap.
	 */
	PAGE_SIZE = NBPG * 2; /* Set logical page size */
#ifdef DDB
	if ((boothowto & RB_KDB) != 0)
		proc0paddr = ROUND_PAGE(esym);
	else
#endif
		proc0paddr = ROUND_PAGE(&end);
d91 1
a91 23
	tmpptr = proc0paddr & 0x7fffffff;
	mtpr(tmpptr, PR_PCBB); /* must be set before ksp for some cpus */
	mtpr(proc0paddr + UPAGES * NBPG, PR_KSP); /* new kernel stack */

	/*
	 * Set logical page size and put Sysmap on its place.
	 */
	Sysmap = (u_int *)ROUND_PAGE(mfpr(PR_KSP));

	/* Be sure some important internal registers have safe values */
	((struct pcb *)proc0paddr)->P0LR = 0;
	((struct pcb *)proc0paddr)->P0BR = (void *)0x80000000;
	((struct pcb *)proc0paddr)->P1LR = 0;
	((struct pcb *)proc0paddr)->P1BR = (void *)0x80000000;
	((struct pcb *)proc0paddr)->iftrap = NULL;
	mtpr(0, PR_P0LR);
	mtpr(0x80000000, PR_P0BR);
	mtpr(0, PR_P1LR);
	mtpr(0x80000000, PR_P1BR);

	mtpr(0, PR_SCBB); /* SCB at physical addr  */
	mtpr(0, PR_ESP); /* Must be zero, used in page fault routine */
	mtpr(AST_NO, PR_ASTLVL);
d93 1
a93 2
	/* Count up memory etc... early machine dependent routines */
	vax_cputype = ((vax_cpudata = mfpr(PR_SID)) >> 24);
d95 6
a100 1
	switch (vax_cputype) {
d102 1
a102 3
	case VAX_TYP_780:
		vax_bustype = VAX_SBIBUS | VAX_CPUBUS;
		vax_boardtype = VAX_BTYP_780;
d104 3
d110 1
a110 3
	case VAX_TYP_750:
		vax_bustype = VAX_CMIBUS | VAX_CPUBUS;
		vax_boardtype = VAX_BTYP_750;
d112 1
d116 1
a116 3
	case VAX_TYP_790:
		vax_bustype = VAX_CPUBUS | VAX_MEMBUS;
		vax_boardtype = VAX_BTYP_790;
d118 3
d123 8
a130 6
#if VAX630 || VAX650 || VAX410 || VAX43
	case VAX_TYP_UV2:
	case VAX_TYP_CVAX:
	case VAX_TYP_RIGEL:
		vax_siedata = *(int *)(0x20040004);	/* SIE address */
		vax_boardtype = (vax_cputype<<24) | ((vax_siedata>>24)&0xFF);
d132 4
a135 8
		switch (vax_boardtype) {
#if VAX410
		case VAX_BTYP_420: /* They are very similar */
		case VAX_BTYP_410:
			dep_call = &ka410_calls;
			vax_confdata = *(int *)(0x20020000);
			vax_bustype = VAX_VSBUS | VAX_CPUBUS;
			break;
d138 22
a159 5
		case VAX_BTYP_43:
			vax_confdata = *(int *)(0x20020000);
			vax_bustype = VAX_VSBUS | VAX_CPUBUS;
			dep_call = &ka43_calls;
			break;
d162 4
a165 4
		case VAX_BTYP_630:
			dep_call = &ka630_calls;
			vax_bustype = VAX_UNIBUS | VAX_CPUBUS;
			break;
d168 10
a177 3
		case VAX_BTYP_650:
			vax_bustype = VAX_UNIBUS | VAX_CPUBUS;
			dep_call = &ka650_calls;
d179 5
a183 1
#endif
d185 1
d190 12
d203 1
a203 3
	case VAX_TYP_8SS:
		vax_boardtype = VAX_BTYP_8000;
		vax_bustype = VAX_BIBUS;
d206 1
d214 18
d233 4
@


1.9.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.c,v 1.17 2001/04/01 17:15:22 hugh Exp $	*/
/*	$NetBSD: locore.c,v 1.43 2000/03/26 11:39:45 ragge Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1998 Ludd, University of Lule}, Sweden.
d37 1
a40 1
#include <sys/user.h>
d44 2
a50 1
#include <machine/pte.h>
d57 2
a58 3
extern	paddr_t avail_end;
paddr_t	esym;
u_int	proc0paddr;
d60 14
d75 1
a75 1
 * The strict cpu-dependent information is set up here, in
a82 4
extern struct cpu_dep ka46_calls;
extern struct cpu_dep ka48_calls;
extern struct cpu_dep ka49_calls;
extern struct cpu_dep ka53_calls;
a85 3
extern struct cpu_dep ka660_calls;
extern struct cpu_dep ka670_calls;
extern struct cpu_dep ka680_calls;
d96 31
a126 3
	extern char cpu_model[];
	extern void *scratch;
	struct pte *pt;
d128 23
a150 1
	mtpr(AST_NO, PR_ASTLVL); /* Turn off ASTs */
d152 2
a153 1
	findcpu(); /* Set up the CPU identifying variables */
d155 1
a155 6
	if (vax_confdata & 0x80)
		strcpy(cpu_model, "MicroVAX ");
	else
		strcpy(cpu_model, "VAXstation ");

	switch (vax_boardtype) {
d157 3
a159 1
	case VAX_BTYP_780:
a160 3
		strcpy(cpu_model,"VAX 11/780");
		if (vax_cpudata & 0x100)
			cpu_model[9] = '5';
d164 3
a166 1
	case VAX_BTYP_750:
a167 1
		strcpy(cpu_model, "VAX 11/750");
d171 3
a173 1
	case VAX_BTYP_790:
a174 3
		strcpy(cpu_model,"VAX 8600");
		if (vax_cpudata & 0x100)
			cpu_model[6] = '5';
d177 8
d186 6
a191 13
	case VAX_BTYP_420: /* They are very similar */
		dep_call = &ka410_calls;
		strcat(cpu_model, "3100");
		if (((vax_siedata >> 8) & 0xff) == 1)
			strcat(cpu_model, "/m{38,48}");
		else if (((vax_siedata >> 8) & 0xff) == 0)
			strcat(cpu_model, "/m{30,40}");
		break;

	case VAX_BTYP_410:
		dep_call = &ka410_calls;
		strcat(cpu_model, "2000");
		break;
d194 4
a197 20
	case VAX_BTYP_43:
		dep_call = &ka43_calls;
		strcat(cpu_model, "3100/m76");
		break;
#endif
#if VAX46
	case VAX_BTYP_46:
		dep_call = &ka46_calls;
		strcat(cpu_model, "4000/60");
		break;
#endif
#if VAX48
	case VAX_BTYP_48:
		dep_call = &ka48_calls;
		switch((vax_siedata >> 8) & 0xFF) {
		case VAX_STYP_45:
			strcat(cpu_model, "3100/m{30,40}");
			break;
		case VAX_STYP_48:
			strcpy(cpu_model, "VAXstation 4000/VLC");
a198 4
		default:
			strcat(cpu_model, " - Unknown SOC");
		}
		break;
d200 4
a203 21
#if VAX49
	case VAX_BTYP_49:
		dep_call = &ka49_calls;
		strcat(cpu_model, "4000/90");
		break;
#endif
#if VAX53
	case VAX_BTYP_1303:	
		dep_call = &ka53_calls;
		switch((vax_siedata >> 8) & 0xFF) {
		case VAX_STYP_50:
			strcpy(cpu_model, "MicroVAX 3100 model 85 or 90");
			break;
		case VAX_STYP_51:
			strcpy(cpu_model, "MicroVAX 3100 model 90 or 95");
			break;
		case VAX_STYP_52:
			strcpy(cpu_model, "VAX 4000 100");
			break;
		case VAX_STYP_53:
			strcpy(cpu_model, "VAX 4000 105A");
a204 10
		default:
			strcpy(cpu_model, "VAX - Unknown Cheetah Class");
		}
		break;
#endif
#if VAX630
	case VAX_BTYP_630:
		dep_call = &ka630_calls;
		strcpy(cpu_model,"MicroVAX II");
		break;
d207 3
a209 6
	case VAX_BTYP_650:
		dep_call = &ka650_calls;
		strcpy(cpu_model,"MicroVAX ");
		switch ((vax_siedata >> 8) & 255) {
		case VAX_SIE_KA640:
			strcat(cpu_model, "3300/3400");
d211 1
a211 9

		case VAX_SIE_KA650:
			strcat(cpu_model, "3500/3600");
			break;

		case VAX_SIE_KA655:
			strcat(cpu_model, "3800/3900");
			break;

a212 1
			strcat(cpu_model, "III");
a216 31
#if VAX660
	case VAX_BTYP_660:
		dep_call = &ka660_calls;
		strcpy(cpu_model,"VAX 4000/200");
		break;
#endif
#if VAX670
	case VAX_BTYP_670:
		dep_call = &ka670_calls;
		strcpy(cpu_model,"VAX 4000/300");
		break;
#endif
#if VAX680
	case VAX_BTYP_1301:
		dep_call = &ka680_calls;
		switch((vax_siedata & 0xff00) >> 8) {
		case VAX_STYP_675:
			strcpy(cpu_model,"VAX 4000 400"); break;
		case VAX_STYP_680:
			strcpy(cpu_model,"VAX 4000 500"); break;
		case VAX_STYP_681:
			strcpy(cpu_model,"VAX 4000 500A"); break;
		case VAX_STYP_690:
			strcpy(cpu_model,"VAX 4000 600"); break;
		case VAX_STYP_691:
			strcpy(cpu_model,"VAX 4000 605A"); break;
		default:
			strcpy(cpu_model,"VAX - Unknown Omega Class");
		}
		break;
#endif
d218 3
a220 1
	case VAX_BTYP_8000:
a222 1
		strcpy(cpu_model, "VAX 8200");
a229 19
        /*
         * Machines older than MicroVAX II have their boot blocks
         * loaded directly or the boot program loaded from console
         * media, so we need to figure out their memory size.
         * This is not easily done on MicroVAXen, so we get it from
         * VMB instead.
         */
        if (avail_end == 0)
                while (badaddr((caddr_t)avail_end, 4) == 0)
                        avail_end += VAX_NBPG * 128;

        avail_end = TRUNC_PAGE(avail_end); /* be sure */

	proc0.p_addr = (struct user *)proc0paddr; /* XXX */
	bzero((struct user *)proc0paddr, sizeof(struct user));

	/* Clear the used parts of the uarea except for the pcb */
	bzero(&proc0.p_addr->u_stats, sizeof(struct user) - sizeof(struct pcb));

a230 4

	/* Now running virtual. set red zone for proc0 */
	pt = kvtopte((u_int)proc0.p_addr + REDZONEADDR);
        pt->pg_v = 0;
@


1.9.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.9.12.1 2001/05/14 21:39:04 niklas Exp $	*/
d149 1
a149 10
		switch(vax_siedata & 0xFF) {
		case VAX_VTYP_47:
			strcpy(cpu_model, "MicroVAX 3100 m80");
			break;
		case VAX_VTYP_46:
			strcpy(cpu_model, "VAXstation 4000/60");
			break;
		default:
			strcat(cpu_model, " - Unknown Mariah");
		}
@


1.9.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
#include <uvm/uvm_extern.h>
@


1.9.12.4
log
@Merge in trunk
@
text
@d249 1
a249 2
			strcpy(cpu_model,"VAX 4000 400");
			break;
d251 3
a253 2
			strcpy(cpu_model,"VAX 4000 500");
			break;
d255 3
a257 2
			strcpy(cpu_model,"VAX 4000 600");
			break;
a259 16
		}
		break;
	case VAX_BTYP_1305:
		dep_call = &ka680_calls;
		switch((vax_siedata & 0xff00) >> 8) {
		case VAX_STYP_681:
			strcpy(cpu_model,"VAX 4000 500A");
			break;
		case VAX_STYP_691:
			strcpy(cpu_model,"VAX 4000 605A");
			break;
		case VAX_STYP_694:
			strcpy(cpu_model,"VAX 4000 705A");
			break;
		default:
			strcpy(cpu_model,"VAX - Unknown Legacy Class");
@


1.9.12.5
log
@Merge in -current from about a week ago
@
text
@d53 2
a54 2
void	start(void);
void	main(void);
@


1.9.12.6
log
@Sync the SMP branch with 3.3
@
text
@a51 1
#include <machine/rpb.h>
d53 1
a53 1
void	start(struct rpb *);
d87 1
a87 1
start(struct rpb *prpb)
d166 1
a166 1
			strcpy(cpu_model, "MicroVAX 3100/m{30,40}");
d235 1
a235 1
		strcpy(cpu_model,"VAX 4000 200");
d241 1
a241 1
		strcpy(cpu_model,"VAX 4000 300");
a246 1
		strcpy(cpu_model,"VAX 4000 ");
d249 1
a249 1
			strcat(cpu_model,"400");
d252 1
a252 1
			strcat(cpu_model,"500");
d255 1
a255 1
			strcat(cpu_model,"600");
d258 1
a258 1
			strcat(cpu_model,"- Unknown Omega Class");
a262 1
		strcpy(cpu_model,"VAX 4000 ");
d265 1
a265 1
			strcat(cpu_model,"500A");
d268 1
a268 1
			strcat(cpu_model,"605A");
d271 1
a271 4
			if (vax_cpudata & 0x1000)
				strcat(cpu_model,"705A");
			else
				strcat(cpu_model,"700A");
d274 1
a274 1
			strcat(cpu_model,"- Unknown Legacy Class");
d290 10
a299 24
	/*
	 * Machines older than MicroVAX II have their boot blocks
	 * loaded directly or the boot program loaded from console
	 * media, so we need to figure out their memory size.
	 * This is not easily done on MicroVAXen, so we get it from
	 * VMB instead.
	 *
	 * In post-1.4 a RPB is always provided from the boot blocks.
	 */
#if 1 /* compat with old bootblocks */
	if (prpb == 0) {
		bzero((caddr_t)proc0paddr + REDZONEADDR, sizeof(struct rpb));
		prpb = (struct rpb *)(proc0paddr + REDZONEADDR);
		prpb->pfncnt = avail_end >> VAX_PGSHIFT;
		prpb->rpb_base = (void *)-1;    /* RPB is fake */
	} else
#endif
	bcopy(prpb, (caddr_t)proc0paddr + REDZONEADDR, sizeof(struct rpb));
	if (prpb->pfncnt)
		avail_end = prpb->pfncnt << VAX_PGSHIFT;
	else
		while (badaddr((caddr_t)avail_end, 4) == 0)
			avail_end += VAX_NBPG * 128;
	boothowto = prpb->rpb_bootr5;
@


1.9.12.7
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.c,v 1.9.12.6 2003/03/27 23:52:20 niklas Exp $	*/
a59 1
char	cpu_model[100];
d90 1
d99 1
a99 1
		strlcpy(cpu_model, "MicroVAX ", sizeof cpu_model);
d101 1
a101 1
		strlcpy(cpu_model, "VAXstation ", sizeof cpu_model);
d107 1
a107 1
		strlcpy(cpu_model,"VAX 11/780", sizeof cpu_model);
d115 1
a115 1
		strlcpy(cpu_model, "VAX 11/750", sizeof cpu_model);
d121 1
a121 1
		strlcpy(cpu_model,"VAX 8600", sizeof cpu_model);
d129 1
a129 1
		strlcat(cpu_model, "3100", sizeof cpu_model);
d131 1
a131 1
			strlcat(cpu_model, "/m{38,48}", sizeof cpu_model);
d133 1
a133 1
			strlcat(cpu_model, "/m{30,40}", sizeof cpu_model);
d138 1
a138 1
		strlcat(cpu_model, "2000", sizeof cpu_model);
d144 1
a144 1
		strlcat(cpu_model, "3100/m76", sizeof cpu_model);
d152 1
a152 1
			strlcpy(cpu_model, "MicroVAX 3100 m80", sizeof cpu_model);
d155 1
a155 1
			strlcpy(cpu_model, "VAXstation 4000/60", sizeof cpu_model);
d158 1
a158 1
			strlcat(cpu_model, " - Unknown Mariah", sizeof cpu_model);
d167 1
a167 1
			strlcpy(cpu_model, "MicroVAX 3100/m{30,40}", sizeof cpu_model);
d170 1
a170 1
			strlcpy(cpu_model, "VAXstation 4000/VLC", sizeof cpu_model);
d173 1
a173 1
			strlcat(cpu_model, " - Unknown SOC", sizeof cpu_model);
d180 1
a180 1
		strlcat(cpu_model, "4000/90", sizeof cpu_model);
d188 1
a188 1
			strlcpy(cpu_model, "MicroVAX 3100 model 85 or 90", sizeof cpu_model);
d191 1
a191 1
			strlcpy(cpu_model, "MicroVAX 3100 model 90 or 95", sizeof cpu_model);
d194 1
a194 1
			strlcpy(cpu_model, "VAX 4000 100", sizeof cpu_model);
d197 1
a197 1
			strlcpy(cpu_model, "VAX 4000 105A", sizeof cpu_model);
d200 1
a200 1
			strlcpy(cpu_model, "VAX - Unknown Cheetah Class", sizeof cpu_model);
d207 1
a207 1
		strlcpy(cpu_model,"MicroVAX II", sizeof cpu_model);
d213 1
a213 1
		strlcpy(cpu_model,"MicroVAX ", sizeof cpu_model);
d216 1
a216 1
			strlcat(cpu_model, "3300/3400", sizeof cpu_model);
d220 1
a220 1
			strlcat(cpu_model, "3500/3600", sizeof cpu_model);
d224 1
a224 1
			strlcat(cpu_model, "3800/3900", sizeof cpu_model);
d228 1
a228 1
			strlcat(cpu_model, "III", sizeof cpu_model);
d236 1
a236 1
		strlcpy(cpu_model,"VAX 4000 200", sizeof cpu_model);
d242 1
a242 1
		strlcpy(cpu_model,"VAX 4000 300", sizeof cpu_model);
d248 1
a248 1
		strlcpy(cpu_model,"VAX 4000 ", sizeof cpu_model);
d251 1
a251 1
			strlcat(cpu_model,"400", sizeof cpu_model);
d254 1
a254 1
			strlcat(cpu_model,"500", sizeof cpu_model);
d257 1
a257 1
			strlcat(cpu_model,"600", sizeof cpu_model);
d260 1
a260 1
			strlcat(cpu_model,"- Unknown Omega Class", sizeof cpu_model);
d265 1
a265 1
		strlcpy(cpu_model,"VAX 4000 ", sizeof cpu_model);
d268 1
a268 1
			strlcat(cpu_model,"500A", sizeof cpu_model);
d271 1
a271 1
			strlcat(cpu_model,"605A", sizeof cpu_model);
d275 1
a275 1
				strlcat(cpu_model,"705A", sizeof cpu_model);
d277 1
a277 1
				strlcat(cpu_model,"700A", sizeof cpu_model);
d280 1
a280 1
			strlcat(cpu_model,"- Unknown Legacy Class", sizeof cpu_model);
d288 1
a288 1
		strlcpy(cpu_model, "VAX 8200", sizeof cpu_model);
@


1.9.12.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
d332 2
a333 1
	*kvtopte((u_int)proc0.p_addr + REDZONEADDR) &= ~PG_V;
@


1.8
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.c,v 1.17 1996/08/20 14:13:54 ragge Exp $	*/
/*	$NetBSD: locore.c,v 1.17 1996/08/20 14:13:54 ragge Exp $	*/
d40 1
d57 2
a58 4
u_int	proc0paddr;
int	*Sysmap, boothowto;
char	*esym;
extern	int bootdev;
d74 12
a91 1
 * We shall be at kernel stack when called; not interrupt stack.
d96 5
a104 2
	mtpr(0x1f, PR_IPL); /* No interrupts before istack is ok, please */

d106 2
a107 3
	 * We can be running either in system or user space when
	 * getting here. Need to figure out which and take care
	 * of it. We also save all registers if panic gets called.
d109 6
a114 15
	asm("
	bisl2	$0x80000000, r9
	movl	r9, _esym
	movl	r10, _bootdev
	movl	r11, _boothowto
	jsb	ett
ett:	cmpl	(sp)+, $0x80000000
	bleq	tvo	# New boot
	pushl	$0x001f0000
	pushl	$tokmem
	rei
tvo:	movl	(sp)+,_boothowto
	movl	(sp)+,_bootdev
tokmem: movw	$0xfff, _panic
	");
d123 1
a123 1
		proc0paddr = ROUND_PAGE(esym) | 0x80000000;
d160 1
d167 1
d174 1
d185 2
d188 6
d197 1
d199 2
a200 1

d202 5
d209 1
d211 1
a211 1

d222 1
a228 8

	/*
	 * before doing anything else, we need to setup the console
	 * so that output (eg. debug and error messages) are visible.
	 * They way console-output is done is different for different
	 * VAXen, thus vax_cputype and vax_boardtype are setup/used.
	 */
	cninit();
@


1.7
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.6
log
@sync to 0611
@
text
@d1 1
a1 2
/*	$NetBSD: locore.c,v 1.15 1996/05/19 16:44:07 ragge Exp $	*/

d50 1
d56 1
a56 1
int	cpunumber, *Sysmap, boothowto, cpu_type;
d60 15
d134 5
a138 5
        ((struct pcb *)proc0paddr)->P0LR = 0;
        ((struct pcb *)proc0paddr)->P0BR = (void *)0x80000000;
        ((struct pcb *)proc0paddr)->P1LR = 0;
        ((struct pcb *)proc0paddr)->P1BR = (void *)0x80000000;
        ((struct pcb *)proc0paddr)->iftrap = NULL;
d147 65
a211 1
	
a213 4
	/* Count up memory etc... early machine dependent routines */
	if ((cpunumber = MACHID(mfpr(PR_SID))) > VAX_MAX)
		cpunumber = 0;
	cpu_type = mfpr(PR_SID);
@


1.5
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: locore.c,v 1.14 1996/04/08 18:32:46 ragge Exp $	*/
d39 1
a46 1
#include <machine/uvaxII.h>
@


1.4
log
@from ragge;
fix bug causing kernel symbol not to be loaded;
save all registers on panic()
@
text
@d1 1
a1 1
/*	$NetBSD: locore.c,v 1.11 1996/01/28 12:18:06 ragge Exp $	*/
d36 18
a53 12
#include "sys/param.h"
#include "sys/types.h"
#include "sys/reboot.h"

#include "vm/vm.h"

#include "machine/cpu.h"
#include "machine/sid.h"
#include "machine/uvaxII.h"
#include "machine/param.h"
#include "machine/vmparam.h"
#include "machine/pcb.h"
d72 1
a72 1
	register curtop;
a100 1

d109 2
a110 1
	mtpr(proc0paddr, PR_PCBB); /* must be set before ksp for some cpus */
d120 1
a120 1
        ((struct pcb *)proc0paddr)->P0BR = 0;
d125 1
a125 1
	mtpr(0, PR_P0BR);
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: locore.c,v 1.10 1995/12/13 18:50:30 ragge Exp $	*/
d73 1
a73 1
	 * of it.
d76 4
a79 3
	movl	r9,_esym
	movl	r10,_bootdev
	movl	r11,_boothowto
d81 1
a81 1
ett:	cmpl	(sp)+,$0x80000000
d84 1
a84 1
	pushl	$to_kmem
d88 1
a88 1
to_kmem:
d96 1
a96 1
	PAGE_SIZE = NBPG*2; /* Set logical page size */
d130 2
a131 1
	if((cpunumber = MACHID(mfpr(PR_SID)))>VAX_MAX) cpunumber=0;
d138 1
a138 1
	 * change mode down to userspace is done by faking an stack
a142 1

@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: locore.c,v 1.9 1995/11/10 19:05:47 ragge Exp $	*/
a44 1
#include "machine/loconf.h"
d50 3
a52 3
volatile int	cpunumber, *Sysmap, boothowto, cpu_type;
volatile char *esym;
extern volatile int bootdev;
d61 2
a62 2

start(how, dev)
d64 2
a65 2
	extern u_int *end;
	extern void *scratch;
d68 1
a68 1
	mtpr(0x1f,PR_IPL); /* No interrupts before istack is ok, please */
d104 1
a104 1
	mtpr(proc0paddr+UPAGES*NBPG,PR_KSP); /* new kernel stack */
d109 1
a109 1
	Sysmap=(u_int *)ROUND_PAGE(mfpr(PR_KSP));
d117 4
a120 4
	mtpr(0,PR_P0LR);
	mtpr(0,PR_P0BR);
	mtpr(0,PR_P1LR);
	mtpr(0x80000000,PR_P1BR);
d123 2
a124 2
	mtpr(0,PR_ESP); /* Must be zero, used in page fault routine */
	mtpr(AST_NO,PR_ASTLVL);
d129 2
a130 6
	if((cpunumber=MACHID(mfpr(PR_SID)))>VAX_MAX) cpunumber=0;
	cpu_type=mfpr(PR_SID);
#if VAX630 || VAX410
        if (cpunumber == VAX_78032)
                cpu_type=(((*UVAXIISID) >> 24) & 0xff)|(cpu_type & 0xff000000);
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: locore.c,v 1.8 1995/06/16 15:36:42 ragge Exp $	*/
a49 2
#define ROUND_PAGE(x)   (((uint)(x)+PAGE_SIZE-1)& ~(PAGE_SIZE-1))

d70 6
a75 1
#ifdef COMPAT_RENO
a89 4
#else
	bootdev=dev;
	boothowto=how;
#endif
d91 4
a94 4
/*
 * FIRST we must set up kernel stack, directly after end.
 * This is the only thing we have to setup here, rest in pmap.
 */
d123 1
a123 1
	mtpr(512,PR_SCBB); /* SCB at physical addr 512 */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
