head	1.25;
access;
symbols
	OPENBSD_5_9:1.24.0.18
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.20
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.12
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.16
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.14
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.10
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.24;
commitid	OSDG2O3Cgeifnf1W;

1.24
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.28.14.13.31;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.19.20.21.08;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.01.11.59.40;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.26.13.06.26;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.31.11.42.51;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.06.15.22.45.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.12.11.45.38;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.24.10.31.58;	author hugh;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.10.18.21.28;	author bjc;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.27.01.10.12;	author bjc;	state Exp;
branches;
next	1.6;

1.6
date	97.09.10.12.04.45;	author maja;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	97.05.29.00.05.18;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.25.10;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.10.11;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.31.05.11.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2001.05.14.21.38.51;	author niklas;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2001.07.04.10.24.34;	author niklas;	state Exp;
branches;
next	1.6.12.3;

1.6.12.3
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.6.12.4;

1.6.12.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.6.12.5;

1.6.12.5
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.6.12.6;

1.6.12.6
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.01.31.22.55.27;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: gencons.c,v 1.24 2011/07/06 18:32:59 miod Exp $	*/
/*	$NetBSD: gencons.c,v 1.22 2000/01/24 02:40:33 matt Exp $	*/

/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	kd.c,v 1.2 1994/05/05 04:46:51 gwr Exp $
 */

 /* All bugs are subject to removal without further notice */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <dev/cons.h>

#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/cpu.h>
#include <machine/scb.h>
#include <machine/../vax/gencons.h>

struct tty *gencn_tty[4];

int consopened = 0;
int maxttys = 1;

int pr_txcs[4] = {PR_TXCS, PR_TXCS1, PR_TXCS2, PR_TXCS3};
int pr_rxcs[4] = {PR_RXCS, PR_RXCS1, PR_RXCS2, PR_RXCS3};
int pr_txdb[4] = {PR_TXDB, PR_TXDB1, PR_TXDB2, PR_TXDB3};
int pr_rxdb[4] = {PR_RXDB, PR_RXDB1, PR_RXDB2, PR_RXDB3};

cons_decl(gen);
cdev_decl(gencn);

int gencnparam(struct tty *, struct termios *);
void gencnstart(struct tty *);
void gencnrint(void *);
void gencntint(void *);

int
gencnopen(dev, flag, mode, p)
	dev_t	dev;
	int	flag, mode;
	struct proc *p;
{
	int unit;
	struct tty *tp;

	unit = minor(dev);
	if (unit >= maxttys)
		return ENXIO;

	if (gencn_tty[unit] == NULL)
		gencn_tty[unit] = ttymalloc(0);

	tp = gencn_tty[unit];

	tp->t_oproc = gencnstart;
	tp->t_param = gencnparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		gencnparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0)
		return EBUSY;
	tp->t_state |= TS_CARR_ON;
	if (unit == 0)
		consopened = 1;
	mtpr(GC_RIE, pr_rxcs[unit]); /* Turn on interrupts */
	mtpr(GC_TIE, pr_txcs[unit]);

        return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

int
gencnclose(dev, flag, mode, p)
        dev_t dev;
        int flag, mode;
        struct proc *p;
{
	struct tty *tp = gencn_tty[minor(dev)];

	if (minor(dev) == 0)
		consopened = 0;
	(*linesw[tp->t_line].l_close)(tp, flag, p);
	ttyclose(tp);
	return (0);
}

struct tty *
gencntty(dev_t dev)
{
	return gencn_tty[minor(dev)];
}

int
gencnread(dev_t dev, struct uio *uio, int flag)
{
	struct tty *tp = gencn_tty[minor(dev)];

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
gencnwrite(dev_t dev, struct uio *uio, int flag)
{
	struct tty *tp = gencn_tty[minor(dev)];

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

int
gencnioctl(dev, cmd, data, flag, p)
        dev_t dev;
        u_long cmd;
        caddr_t data;
        int flag;
        struct proc *p;
{
	struct tty *tp = gencn_tty[minor(dev)];
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
 
	return ENOTTY;
}

void
gencnstart(struct tty *tp)
{
	struct clist *cl;
	int s, ch;

	s = spltty();
	if (tp->t_state & (TS_BUSY|TS_TTSTOP|TS_TIMEOUT))
		goto out;
	cl = &tp->t_outq;

	if(cl->c_cc){
		tp->t_state |= TS_BUSY;
		ch = getc(cl);
		mtpr(ch, pr_txdb[minor(tp->t_dev)]);
	} else {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)cl);
		}
		selwakeup(&tp->t_wsel);
	}

out:	splx(s);
}

void
gencnrint(void *arg)
{
	struct tty *tp = *(struct tty **) arg;
	int unit = (struct tty **) arg - gencn_tty;
	int i;

	i = mfpr(pr_rxdb[unit]) & 0377; /* Mask status flags etc... */

#ifdef DDB
	if (tp->t_dev == cn_tab->cn_dev) {
		int j = kdbrint(i);

		if (j == 1)	/* Escape received, just return */
			return;

		if (j == 2)	/* Second char wasn't 'D' */
			(*linesw[tp->t_line].l_rint)(27, tp);
	}
#endif

	(*linesw[tp->t_line].l_rint)(i, tp);
	return;
}

int
gencnstop(struct tty *tp, int flag)
{
	return 0;
}

void
gencntint(void *arg)
{
	struct tty *tp = *(struct tty **) arg;

	tp->t_state &= ~TS_BUSY;

	gencnstart(tp);
}

int
gencnparam(struct tty *tp, struct termios *t)
{
	/* XXX - These are ignored... */
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	return 0;
}

void
gencnprobe(struct consdev *cndev)
{
	if ((vax_cputype < VAX_TYP_UV2) || /* All older has MTPR console */
	    (vax_boardtype == VAX_BTYP_9RR) ||
	    (vax_boardtype == VAX_BTYP_630) ||
	    (vax_boardtype == VAX_BTYP_650) ||
	    (vax_boardtype == VAX_BTYP_660) ||
	    (vax_boardtype == VAX_BTYP_670) ||
	    (vax_boardtype == VAX_BTYP_1301) ||
	    (vax_boardtype == VAX_BTYP_1305)) {
		cndev->cn_dev = makedev(25, 0);
		cndev->cn_pri = CN_LOWPRI;
	}
}

void
gencninit(struct consdev *cndev)
{

	/* Allocate interrupt vectors */
	scb_vecalloc(SCB_G0R, gencnrint, &gencn_tty[0], SCB_ISTACK, NULL);
	scb_vecalloc(SCB_G0T, gencntint, &gencn_tty[0], SCB_ISTACK, NULL);

	if (vax_cputype == VAX_TYP_8SS) {
		maxttys = 4;
		scb_vecalloc(SCB_G1R, gencnrint, &gencn_tty[1], SCB_ISTACK, NULL);
		scb_vecalloc(SCB_G1T, gencntint, &gencn_tty[1], SCB_ISTACK, NULL);

		scb_vecalloc(SCB_G2R, gencnrint, &gencn_tty[2], SCB_ISTACK, NULL);
		scb_vecalloc(SCB_G2T, gencntint, &gencn_tty[2], SCB_ISTACK, NULL);

		scb_vecalloc(SCB_G3R, gencnrint, &gencn_tty[3], SCB_ISTACK, NULL);
		scb_vecalloc(SCB_G3T, gencntint, &gencn_tty[3], SCB_ISTACK, NULL);
	}
	mtpr(0, PR_RXCS);
	mtpr(0, PR_TXCS);
	mtpr(0, PR_TBIA); /* ??? */
}

void
gencnputc(dev_t dev, int ch)
{
	while ((mfpr(PR_TXCS) & GC_RDY) == 0) /* Wait until xmit ready */
		;
	mtpr(ch, PR_TXDB);	/* xmit character */
	if(ch == 10)
		gencnputc(dev, 13); /* CR/LF */

}

int
gencngetc(dev_t dev)
{
	int i;

	while ((mfpr(PR_RXCS) & GC_DON) == 0) /* Receive chr */
		;
	i = mfpr(PR_RXDB) & 0x7f;
	if (i == 13)
		i = 10;
	return i;
}

void 
gencnpollc(dev_t dev, int pollflag)
{
	if (pollflag)  {
		mtpr(0, PR_RXCS);
		mtpr(0, PR_TXCS); 
	} else if (consopened) {
		mtpr(GC_RIE, PR_RXCS);
		mtpr(GC_TIE, PR_TXCS);
	}
}
@


1.24
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.23 2010/06/28 14:13:31 deraadt Exp $	*/
@


1.23
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.22 2010/04/12 12:57:52 tedu Exp $	*/
a293 24
#ifdef VAX8800
	/*
	 * On KA88 we may get C-S/C-Q from the console.
	 * XXX - this will cause a loop at spltty() in kernel and will
	 * interfere with other console communication. Fortunately
	 * kernel printf's are uncommon.
	 */
	if (vax_cputype == VAX_TYP_8NN) {
		int s = spltty();

		while (mfpr(PR_RXCS) & GC_DON) {
			if ((mfpr(PR_RXDB) & 0x7f) == 19) {
				while (1) {
					while ((mfpr(PR_RXCS) & GC_DON) == 0)
						;
					if ((mfpr(PR_RXDB) & 0x7f) == 17)
						break;
				}
			}
		}
		splx(s);
	}
#endif

@


1.22
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.21 2009/11/09 17:53:39 nicm Exp $	*/
d89 1
a89 1
		gencn_tty[unit] = ttymalloc();
@


1.21
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.20 2009/10/31 12:00:07 fgsch Exp $	*/
d113 1
a113 1
        return ((*linesw[tp->t_line].l_open)(dev, tp));
d126 1
a126 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.20
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.19 2009/10/31 06:40:16 deraadt Exp $	*/
a194 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.19
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.18 2008/01/23 16:37:57 jsing Exp $	*/
d105 1
a105 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
@


1.18
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.17 2006/07/19 20:21:08 miod Exp $	*/
d195 1
@


1.17
log
@Cheetah machines can use dz as a console since a long time already, thus do
not allow the mtpr console to work on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.16 2006/01/01 11:59:40 miod Exp $	*/
d263 1
a263 1
		cndev->cn_pri = CN_NORMAL;
@


1.16
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.15 2003/06/26 13:06:26 miod Exp $	*/
a260 1
	    (vax_boardtype == VAX_BTYP_1303) ||
@


1.15
log
@Compile the vax kernel with -Wmissing-prototypes -Wstrict-prototypes now.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.14 2002/03/14 01:26:48 millert Exp $	*/
d265 1
a265 2
	} else
		cndev->cn_pri = CN_DEAD;
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.13 2002/01/31 11:42:51 hugh Exp $	*/
d57 1
a57 1
static	struct tty *gencn_tty[4];
d59 2
a60 2
static	int consopened = 0;
static	int maxttys = 1;
d62 4
a65 4
static	int pr_txcs[4] = {PR_TXCS, PR_TXCS1, PR_TXCS2, PR_TXCS3};
static	int pr_rxcs[4] = {PR_RXCS, PR_RXCS1, PR_RXCS2, PR_RXCS3};
static	int pr_txdb[4] = {PR_TXDB, PR_TXDB1, PR_TXDB2, PR_TXDB3};
static	int pr_rxdb[4] = {PR_RXDB, PR_RXDB1, PR_RXDB2, PR_RXDB3};
d70 4
a73 2
static	int gencnparam(struct tty *, struct termios *);
static	void gencnstart(struct tty *);
@


1.13
log
@Add support for VAX 4000 500A.
Thanks to kernel testing by Andrew Reynolds.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.12 2001/08/25 13:33:37 hugh Exp $	*/
d70 2
a71 2
static	int gencnparam __P((struct tty *, struct termios *));
static	void gencnstart __P((struct tty *));
@


1.12
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.11 2001/06/15 22:45:33 miod Exp $	*/
d259 2
a260 1
	    (vax_boardtype == VAX_BTYP_1303)) {
@


1.12.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.13 2002/01/31 11:42:51 hugh Exp $	*/
d259 1
a259 2
	    (vax_boardtype == VAX_BTYP_1303) ||
	    (vax_boardtype == VAX_BTYP_1305)) {
@


1.12.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.12.4.1 2002/01/31 22:55:27 niklas Exp $	*/
d70 2
a71 2
static	int gencnparam(struct tty *, struct termios *);
static	void gencnstart(struct tty *);
@


1.11
log
@Compile kernel with -Wall, and fix a few issues for this to work.
ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.10 2001/03/12 11:45:38 hugh Exp $	*/
a67 3
#ifdef DYNAMIC_DEVSW
bcdev_decl(gencn);
#else
a68 1
#endif
a71 2
void	gencnrint __P((void *));
void	gencntint __P((void *));
d79 2
a80 2
        int unit;
        struct tty *tp;
d82 2
a83 2
        unit = minor(dev);
        if (unit >= maxttys)
d91 15
a105 15
        tp->t_oproc = gencnstart;
        tp->t_param = gencnparam;
        tp->t_dev = dev;
        if ((tp->t_state & TS_ISOPEN) == 0) {
                ttychars(tp);
                tp->t_iflag = TTYDEF_IFLAG;
                tp->t_oflag = TTYDEF_OFLAG;
                tp->t_cflag = TTYDEF_CFLAG;
                tp->t_lflag = TTYDEF_LFLAG;
                tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
                gencnparam(tp, &tp->t_termios);
                ttsetwater(tp);
        } else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
                return EBUSY;
        tp->t_state |= TS_CARR_ON;
d120 1
a120 1
        struct tty *tp = gencn_tty[minor(dev)];
d124 3
a126 3
        (*linesw[tp->t_line].l_close)(tp, flag);
        ttyclose(tp);
        return (0);
d130 1
a130 2
gencntty(dev)
	dev_t dev;
d136 1
a136 4
gencnread(dev, uio, flag)
        dev_t dev;
        struct uio *uio;
        int flag;
d138 1
a138 1
        struct tty *tp = gencn_tty[minor(dev)];
d140 1
a140 1
        return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d144 1
a144 4
gencnwrite(dev, uio, flag)
        dev_t dev;
        struct uio *uio;
        int flag;
d146 1
a146 1
        struct tty *tp = gencn_tty[minor(dev)];
d148 1
a148 1
        return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d159 2
a160 2
        struct tty *tp = gencn_tty[minor(dev)];
        int error;
d162 5
a166 5
        error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
        if (error >= 0)
                return error;
        error = ttioctl(tp, cmd, data, flag, p);
        if (error >= 0)
d173 1
a173 2
gencnstart(tp)
        struct tty *tp;
d175 2
a176 2
        struct clist *cl;
        int s, ch;
d178 4
a181 4
        s = spltty();
        if (tp->t_state & (TS_BUSY|TS_TTSTOP|TS_TIMEOUT))
                goto out;
        cl = &tp->t_outq;
d184 1
a184 1
        	tp->t_state |= TS_BUSY;
d199 1
a199 2
gencnrint(arg)
	void *arg;
d224 1
a224 3
gencnstop(tp, flag)
        struct tty *tp;
        int flag;
d230 1
a230 2
gencntint(arg)
	void *arg;
d240 1
a240 3
gencnparam(tp, t)
	struct tty *tp;
	struct termios *t;
d242 4
a245 4
        /* XXX - These are ignored... */
        tp->t_ispeed = t->c_ispeed;
        tp->t_ospeed = t->c_ospeed;
        tp->t_cflag = t->c_cflag;
d250 1
a250 2
gencnprobe(cndev)
	struct	consdev *cndev;
d252 2
a253 1
	if ((vax_cputype < VAX_TYP_UV1) || /* All older has MTPR console */
d267 1
a267 2
gencninit(cndev)
	struct	consdev *cndev;
d271 2
a272 2
	scb_vecalloc(SCB_G0R, gencnrint, &gencn_tty[0], SCB_ISTACK);
	scb_vecalloc(SCB_G0T, gencntint, &gencn_tty[0], SCB_ISTACK);
d276 2
a277 2
		scb_vecalloc(SCB_G1R, gencnrint, &gencn_tty[1], SCB_ISTACK);
		scb_vecalloc(SCB_G1T, gencntint, &gencn_tty[1], SCB_ISTACK);
d279 2
a280 2
		scb_vecalloc(SCB_G2R, gencnrint, &gencn_tty[2], SCB_ISTACK);
		scb_vecalloc(SCB_G2T, gencntint, &gencn_tty[2], SCB_ISTACK);
d282 2
a283 2
		scb_vecalloc(SCB_G3R, gencnrint, &gencn_tty[3], SCB_ISTACK);
		scb_vecalloc(SCB_G3T, gencntint, &gencn_tty[3], SCB_ISTACK);
d285 2
d291 1
a291 3
gencnputc(dev,ch)
	dev_t	dev;
	int	ch;
d293 24
d326 1
a326 2
gencngetc(dev)
	dev_t	dev;
d339 1
a339 3
gencnpollc(dev, pollflag)
        dev_t dev;
        int pollflag;
d341 3
a343 3
        if (pollflag)  {
                mtpr(0, PR_RXCS);
	        mtpr(0, PR_TXCS); 
d345 2
a346 2
	        mtpr(GC_RIE, PR_RXCS);
	        mtpr(GC_TIE, PR_TXCS);
@


1.10
log
@Omega is now VAX_BTYP_1301. Also add an STYP for 4000 600.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.9 2001/02/24 10:31:58 hugh Exp $	*/
d243 1
@


1.9
log
@Support for VAX 4000/{2,4,5}00 from Michael Kukat. untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.8 2000/10/10 18:21:28 bjc Exp $	*/
d277 1
a277 1
	    (vax_boardtype == VAX_BTYP_680) ||
@


1.8
log
@- add some cases for ka52/53 (VAX_BTYP_1303), tested by hugh
- things depend on proc0paddr being zero'd out, so do it
- also forgot a "3100" in a cpu_model
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.7 2000/04/27 01:10:12 bjc Exp $	*/
d274 2
d277 2
a278 2
		(vax_boardtype == VAX_BTYP_1303) ||
	    (vax_boardtype == VAX_BTYP_650)) {
@


1.7
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.6 1997/09/10 12:04:45 maja Exp $	*/
d275 1
@


1.6
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: gencons.c,v 1.5 1997/05/29 00:05:18 niklas Exp $	*/
/*	$NetBSD: gencons.c,v 1.13 1997/03/15 16:36:19 ragge Exp $	*/
d54 1
d57 1
a57 1
struct	tty *gencn_tty[1];
d59 2
a60 1
int	consinied = 0;
d62 16
a77 14
int	gencnparam __P((struct tty *, struct termios *));
void	gencnstart __P((struct tty *));
int	gencnopen __P((dev_t, int, int, struct proc *));
int	gencnclose __P((dev_t, int, int, struct proc *));
int	gencnread __P((dev_t, struct uio *, int));
int	gencnwrite __P((dev_t, struct uio *, int));
int	gencnioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	gencngetc __P((dev_t));
void	gencnprobe __P((struct consdev *));
void	gencninit __P((struct consdev *));
struct tty *gencntty __P((dev_t));
void	gencnrint __P((void));
void	gencntint __P((void));
void	gencnstop __P((struct tty *, int));
d89 1
a89 1
        if (unit)
d92 2
a93 2
	if (gencn_tty[0] == NULL)
		gencn_tty[0] = ttymalloc();
d95 1
a95 1
	tp = gencn_tty[0];
a100 1
                tp->t_state |= TS_WOPEN;
d112 4
a115 2
	mtpr(GC_RIE, PR_RXCS); /* Turn on interrupts */
	mtpr(GC_TIE, PR_TXCS);
d126 1
a126 1
        struct tty *tp = gencn_tty[0];
d128 2
d139 1
a139 1
	return gencn_tty[0]; /* XXX */
d148 1
a148 1
        struct tty *tp = gencn_tty[0];
d159 2
a160 1
        struct tty *tp = gencn_tty[0];
d172 1
a173 1
        struct tty *tp = gencn_tty[0];
d179 2
a180 1
        if (error >= 0) return error;
d200 1
a200 1
		mtpr(ch, PR_TXDB);
d213 2
a214 1
gencnrint()
d216 3
a218 2
	struct tty *tp;
	int i, j;
d220 1
a220 2
	tp = gencn_tty[0];
	i = mfpr(PR_RXDB) & 0377; /* Mask status flags etc... */
d223 2
a224 1
	j = kdbrint(i);
d226 2
a227 2
	if (j == 1)	/* Escape received, just return */
		return;
d229 3
a231 2
	if (j == 2)	/* Second char wasn't 'D' */
		(*linesw[tp->t_line].l_rint)(27, tp);
d234 1
a234 1
	(*linesw[tp->t_line].l_rint)(i,tp);
d238 1
a238 1
void
d246 2
a247 1
gencntint()
d249 1
a249 1
	struct tty *tp;
a250 1
	tp = gencn_tty[0];
a271 2
	int i;

d274 1
d286 17
d330 14
@


1.6.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: gencons.c,v 1.10 2001/03/12 11:45:38 hugh Exp $	*/
/*	$NetBSD: gencons.c,v 1.22 2000/01/24 02:40:33 matt Exp $	*/
a53 1
#include <machine/scb.h>
d56 1
a56 1
static	struct tty *gencn_tty[4];
d58 1
a58 2
static	int consopened = 0;
static	int maxttys = 1;
d60 14
a73 16
static	int pr_txcs[4] = {PR_TXCS, PR_TXCS1, PR_TXCS2, PR_TXCS3};
static	int pr_rxcs[4] = {PR_RXCS, PR_RXCS1, PR_RXCS2, PR_RXCS3};
static	int pr_txdb[4] = {PR_TXDB, PR_TXDB1, PR_TXDB2, PR_TXDB3};
static	int pr_rxdb[4] = {PR_RXDB, PR_RXDB1, PR_RXDB2, PR_RXDB3};

cons_decl(gen);
#ifdef DYNAMIC_DEVSW
bcdev_decl(gencn);
#else
cdev_decl(gencn);
#endif

static	int gencnparam __P((struct tty *, struct termios *));
static	void gencnstart __P((struct tty *));
void	gencnrint __P((void *));
void	gencntint __P((void *));
d85 1
a85 1
        if (unit >= maxttys)
d88 2
a89 2
	if (gencn_tty[unit] == NULL)
		gencn_tty[unit] = ttymalloc();
d91 1
a91 1
	tp = gencn_tty[unit];
d97 1
d109 2
a110 4
	if (unit == 0)
		consopened = 1;
	mtpr(GC_RIE, pr_rxcs[unit]); /* Turn on interrupts */
	mtpr(GC_TIE, pr_txcs[unit]);
d121 1
a121 1
        struct tty *tp = gencn_tty[minor(dev)];
a122 2
	if (minor(dev) == 0)
		consopened = 0;
d132 1
a132 1
	return gencn_tty[minor(dev)];
d141 1
a141 1
        struct tty *tp = gencn_tty[minor(dev)];
d152 1
a152 2
        struct tty *tp = gencn_tty[minor(dev)];

a163 1
        struct tty *tp = gencn_tty[minor(dev)];
d165 1
d171 1
a171 2
        if (error >= 0)
		return error;
d191 1
a191 1
		mtpr(ch, pr_txdb[minor(tp->t_dev)]);
d204 1
a204 2
gencnrint(arg)
	void *arg;
d206 2
a207 3
	struct tty *tp = *(struct tty **) arg;
	int unit = (struct tty **) arg - gencn_tty;
	int i;
d209 2
a210 1
	i = mfpr(pr_rxdb[unit]) & 0377; /* Mask status flags etc... */
d213 1
a213 2
	if (tp->t_dev == cn_tab->cn_dev) {
		int j = kdbrint(i);
d215 2
a216 2
		if (j == 1)	/* Escape received, just return */
			return;
d218 2
a219 3
		if (j == 2)	/* Second char wasn't 'D' */
			(*linesw[tp->t_line].l_rint)(27, tp);
	}
d222 1
a222 1
	(*linesw[tp->t_line].l_rint)(i, tp);
d226 1
a226 1
int
d234 1
a234 2
gencntint(arg)
	void *arg;
d236 1
a236 1
	struct tty *tp = *(struct tty **) arg;
d238 1
d260 2
d264 1
a264 5
	    (vax_boardtype == VAX_BTYP_650) ||
	    (vax_boardtype == VAX_BTYP_660) ||
	    (vax_boardtype == VAX_BTYP_670) ||
	    (vax_boardtype == VAX_BTYP_1301) ||
	    (vax_boardtype == VAX_BTYP_1303)) {
a274 17

	/* Allocate interrupt vectors */
	scb_vecalloc(SCB_G0R, gencnrint, &gencn_tty[0], SCB_ISTACK);
	scb_vecalloc(SCB_G0T, gencntint, &gencn_tty[0], SCB_ISTACK);

	if (vax_cputype == VAX_TYP_8SS) {
		maxttys = 4;
		scb_vecalloc(SCB_G1R, gencnrint, &gencn_tty[1], SCB_ISTACK);
		scb_vecalloc(SCB_G1T, gencntint, &gencn_tty[1], SCB_ISTACK);

		scb_vecalloc(SCB_G2R, gencnrint, &gencn_tty[2], SCB_ISTACK);
		scb_vecalloc(SCB_G2T, gencntint, &gencn_tty[2], SCB_ISTACK);

		scb_vecalloc(SCB_G3R, gencnrint, &gencn_tty[3], SCB_ISTACK);
		scb_vecalloc(SCB_G3T, gencntint, &gencn_tty[3], SCB_ISTACK);
	}
	mtpr(0, PR_TBIA); /* ??? */
a301 14
}

void 
gencnpollc(dev, pollflag)
        dev_t dev;
        int pollflag;
{
        if (pollflag)  {
                mtpr(0, PR_RXCS);
	        mtpr(0, PR_TXCS); 
	} else if (consopened) {
	        mtpr(GC_RIE, PR_RXCS);
	        mtpr(GC_TIE, PR_TXCS);
	}
@


1.6.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.6.12.1 2001/05/14 21:38:51 niklas Exp $	*/
a242 1
	return 0;
@


1.6.12.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: gencons.c,v 1.6.12.2 2001/07/04 10:24:34 niklas Exp $	*/
d68 3
d72 1
d76 2
d85 2
a86 2
	int unit;
	struct tty *tp;
d88 2
a89 2
	unit = minor(dev);
	if (unit >= maxttys)
d97 15
a111 15
	tp->t_oproc = gencnstart;
	tp->t_param = gencnparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		gencnparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
		return EBUSY;
	tp->t_state |= TS_CARR_ON;
d126 1
a126 1
	struct tty *tp = gencn_tty[minor(dev)];
d130 3
a132 3
	(*linesw[tp->t_line].l_close)(tp, flag);
	ttyclose(tp);
	return (0);
d136 2
a137 1
gencntty(dev_t dev)
d143 4
a146 1
gencnread(dev_t dev, struct uio *uio, int flag)
d148 1
a148 1
	struct tty *tp = gencn_tty[minor(dev)];
d150 1
a150 1
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d154 4
a157 1
gencnwrite(dev_t dev, struct uio *uio, int flag)
d159 1
a159 1
	struct tty *tp = gencn_tty[minor(dev)];
d161 1
a161 1
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d172 2
a173 2
	struct tty *tp = gencn_tty[minor(dev)];
	int error;
d175 5
a179 5
	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
d186 2
a187 1
gencnstart(struct tty *tp)
d189 2
a190 2
	struct clist *cl;
	int s, ch;
d192 4
a195 4
	s = spltty();
	if (tp->t_state & (TS_BUSY|TS_TTSTOP|TS_TIMEOUT))
		goto out;
	cl = &tp->t_outq;
d198 1
a198 1
		tp->t_state |= TS_BUSY;
d213 2
a214 1
gencnrint(void *arg)
d239 3
a241 1
gencnstop(struct tty *tp, int flag)
d247 2
a248 1
gencntint(void *arg)
d258 3
a260 1
gencnparam(struct tty *tp, struct termios *t)
d262 4
a265 4
	/* XXX - These are ignored... */
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
d270 2
a271 1
gencnprobe(struct consdev *cndev)
d273 1
a273 2
	if ((vax_cputype < VAX_TYP_UV2) || /* All older has MTPR console */
	    (vax_boardtype == VAX_BTYP_9RR) ||
d287 2
a288 1
gencninit(struct consdev *cndev)
d292 2
a293 2
	scb_vecalloc(SCB_G0R, gencnrint, &gencn_tty[0], SCB_ISTACK, NULL);
	scb_vecalloc(SCB_G0T, gencntint, &gencn_tty[0], SCB_ISTACK, NULL);
d297 2
a298 2
		scb_vecalloc(SCB_G1R, gencnrint, &gencn_tty[1], SCB_ISTACK, NULL);
		scb_vecalloc(SCB_G1T, gencntint, &gencn_tty[1], SCB_ISTACK, NULL);
d300 2
a301 2
		scb_vecalloc(SCB_G2R, gencnrint, &gencn_tty[2], SCB_ISTACK, NULL);
		scb_vecalloc(SCB_G2T, gencntint, &gencn_tty[2], SCB_ISTACK, NULL);
d303 2
a304 2
		scb_vecalloc(SCB_G3R, gencnrint, &gencn_tty[3], SCB_ISTACK, NULL);
		scb_vecalloc(SCB_G3T, gencntint, &gencn_tty[3], SCB_ISTACK, NULL);
a305 2
	mtpr(0, PR_RXCS);
	mtpr(0, PR_TXCS);
d310 3
a312 1
gencnputc(dev_t dev, int ch)
a313 24
#ifdef VAX8800
	/*
	 * On KA88 we may get C-S/C-Q from the console.
	 * XXX - this will cause a loop at spltty() in kernel and will
	 * interfere with other console communication. Fortunately
	 * kernel printf's are uncommon.
	 */
	if (vax_cputype == VAX_TYP_8NN) {
		int s = spltty();

		while (mfpr(PR_RXCS) & GC_DON) {
			if ((mfpr(PR_RXDB) & 0x7f) == 19) {
				while (1) {
					while ((mfpr(PR_RXCS) & GC_DON) == 0)
						;
					if ((mfpr(PR_RXDB) & 0x7f) == 17)
						break;
				}
			}
		}
		splx(s);
	}
#endif

d323 2
a324 1
gencngetc(dev_t dev)
d337 3
a339 1
gencnpollc(dev_t dev, int pollflag)
d341 3
a343 3
	if (pollflag)  {
		mtpr(0, PR_RXCS);
		mtpr(0, PR_TXCS); 
d345 2
a346 2
		mtpr(GC_RIE, PR_RXCS);
		mtpr(GC_TIE, PR_TXCS);
@


1.6.12.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d259 1
a259 2
	    (vax_boardtype == VAX_BTYP_1303) ||
	    (vax_boardtype == VAX_BTYP_1305)) {
@


1.6.12.5
log
@Merge in -current from about a week ago
@
text
@d70 2
a71 2
static	int gencnparam(struct tty *, struct termios *);
static	void gencnstart(struct tty *);
@


1.6.12.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d57 1
a57 1
struct tty *gencn_tty[4];
d59 2
a60 2
int consopened = 0;
int maxttys = 1;
d62 4
a65 4
int pr_txcs[4] = {PR_TXCS, PR_TXCS1, PR_TXCS2, PR_TXCS3};
int pr_rxcs[4] = {PR_RXCS, PR_RXCS1, PR_RXCS2, PR_RXCS3};
int pr_txdb[4] = {PR_TXDB, PR_TXDB1, PR_TXDB2, PR_TXDB3};
int pr_rxdb[4] = {PR_RXDB, PR_RXDB1, PR_RXDB2, PR_RXDB3};
d70 2
a71 4
int gencnparam(struct tty *, struct termios *);
void gencnstart(struct tty *);
void gencnrint(void *);
void gencntint(void *);
@


1.5
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: gencons.c,v 1.11 1996/09/02 06:44:32 mycroft Exp $	*/
/*	$NetBSD: gencons.c,v 1.11 1996/09/02 06:44:32 mycroft Exp $	*/
d52 1
a73 1
void	gencnslask __P((void));
d85 5
a89 1
        if (unit) return ENXIO;
a230 1

d262 7
a268 6
	for (i = 0; i < nchrdev; i++)
		if (cdevsw[i].d_open == gencnopen) {
			cndev->cn_dev = makedev(i,0);
			cndev->cn_pri = CN_NORMAL;
			break;
		}
a274 6
}

void
gencnslask()
{
	gencn_tty[0] = ttymalloc();
@


1.4
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.3
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: gencons.c,v 1.10 1996/04/08 18:32:36 ragge Exp $	*/
d71 1
a71 1
int	gencnstop __P((struct tty *, int));
d221 1
a221 1
int
d226 1
a226 1
	return 0;
@


1.2
log
@from ragge; make ^] not be sent on return from ddb
@
text
@d1 1
a1 1
/*	$NetBSD: gencons.c,v 1.7 1996/01/28 12:11:57 ragge Exp $	*/
d38 15
a52 14
#include "sys/param.h"
#include "sys/proc.h"
#include "sys/systm.h"
#include "sys/ioctl.h"
#include "sys/tty.h"
#include "sys/file.h"
#include "sys/conf.h"
#include "sys/device.h"
#include "sys/reboot.h"

#include "dev/cons.h"

#include "machine/mtpr.h"
#include "machine/../vax/gencons.h"
d56 1
a56 1
int consinied = 0;
d58 15
a72 2
int	gencnparam();
void	gencnstart();
a115 1
        int unit = minor(dev);
a135 1
        int unit = minor(dev);
a146 1
        int unit = minor(dev);
d154 1
a154 1
        int cmd;
a159 1
        int unit = minor(dev);
d198 1
d205 1
a205 1
	i = mfpr(PR_RXDB);
d226 1
d229 1
d252 1
a252 1
int
a263 1
	return 0;
d266 1
a266 1
int
d272 1
d278 1
a278 1
int
a302 7
}

conout(str)
	char *str;
{
	while (*str)
		gencnputc(0, *str++);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: gencons.c,v 1.6 1995/08/21 03:24:46 ragge Exp $	*/
d282 2
d286 4
a289 1
	return mfpr(PR_RXDB) & 0x7f;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
