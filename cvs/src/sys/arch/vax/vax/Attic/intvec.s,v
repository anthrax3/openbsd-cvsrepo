head	1.24;
access;
symbols
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.10
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.8
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.6
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.8
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.6
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.24
date	2010.05.26.16.35.28;	author deraadt;	state dead;
branches;
next	1.23;

1.23
date	2009.03.20.18.39.30;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.10.17.59.27;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.24.22.50.31;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.18.00.25.22;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.06.21.09.35;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.29.19.13.24;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2000.10.24.01.50.19;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.27.01.10.12;	author bjc;	state Exp;
branches;
next	1.11;

1.11
date	98.05.11.16.24.43;	author niklas;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	98.05.11.15.55.17;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	98.05.11.15.40.34;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.09.12.09.30.54;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.09.10.12.04.45;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	97.05.28.23.20.17;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.25.11;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.09.10.13;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.31.05.15.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.10;	author deraadt;	state Exp;
branches;
next	;

1.11.8.1
date	2001.05.14.21.38.53;	author niklas;	state Exp;
branches;
next	1.11.8.2;

1.11.8.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.11.8.3;

1.11.8.3
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.11.8.4;

1.11.8.4
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	1.11.8.5;

1.11.8.5
date	2004.06.05.23.11.03;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@rename intvec.s to locore.S, and add the guts of locore.C to machdep.c
ok miod ragge
We cannot yet get at vax/subr.s via files.vax because rdsetroot doesn't
like it when the "start" symbol isn't in the first page of the executable.
subr.s will have to be merged into locore.S later on, when other problems
with ENTRY() are solved (says Miod)
@
text
@/*	$OpenBSD: intvec.s,v 1.23 2009/03/20 18:39:30 miod Exp $   */
/*	$NetBSD: intvec.s,v 1.39 1999/06/28 08:20:48 itojun Exp $   */

/*
 * Copyright (c) 1994, 1997 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include "assym.h"

#include <net/netisr.h>

#define ENTRY(name) \
	.text			; \
	.align 2		; \
	.globl name		; \
name /**/:

#define TRAPCALL(namn, typ) \
ENTRY(namn)			; \
	pushl $0		; \
	pushl $typ		; \
	jbr trap

#define TRAPARGC(namn, typ) \
ENTRY(namn)			; \
	pushl $typ		; \
	jbr trap

#define FASTINTR(namn, rutin) \
ENTRY(namn)			; \
	pushr $0x3f		; \
	calls $0,_/**/rutin	; \
	popr $0x3f		; \
	rei

#define	PUSHR	pushr	$0x3f
#define	POPR	popr	$0x3f

#define KSTACK 0
#define ISTACK 1
#define	NOVEC	.long 0
#define INTVEC(label,stack)	\
	.long	label+stack;
		.text

	.globl	_kernbase, _rpb, _kernel_text
	.set	_kernel_text,KERNBASE
_kernbase:
_rpb:	
/*
 * First page in memory we have rpb; so that we know where
 * (must be on a 64k page boundary, easiest here). We use it
 * to store SCB vectors generated when compiling the kernel,
 * and move the SCB later to somewhere else.
 */

	NOVEC;				# Unused, 0
	INTVEC(mcheck, ISTACK)		# Machine Check., 4
	INTVEC(invkstk, ISTACK) 	# Kernel Stack Invalid., 8
	NOVEC;			 	# Power Failed., C
	INTVEC(privinflt, KSTACK)	# Privileged/Reserved Instruction.
	INTVEC(xfcflt, KSTACK)		# Customer Reserved Instruction, 14
	INTVEC(resopflt, KSTACK)	# Reserved Operand/Boot Vector(?), 18
	INTVEC(resadflt, KSTACK)	# Reserved Address Mode., 1C
	INTVEC(access_v, KSTACK)	# Access Control Violation, 20
	INTVEC(transl_v, KSTACK)	# Translation Invalid, 24
	INTVEC(tracep, KSTACK)		# Trace Pending, 28
	INTVEC(breakp, KSTACK)		# Breakpoint Instruction, 2C
	NOVEC;			 	# Compatibility Exception, 30
	INTVEC(arithflt, KSTACK)	# Arithmetic Fault, 34
	NOVEC;			 	# Unused, 38
	NOVEC;			 	# Unused, 3C
	INTVEC(syscall, KSTACK)		# main syscall trap, chmk, 40
	INTVEC(resopflt, KSTACK)	# chme, 44
	INTVEC(resopflt, KSTACK)	# chms, 48
	INTVEC(resopflt, KSTACK)	# chmu, 4C
	NOVEC;				# System Backplane Exception/BIerror, 50
	INTVEC(cmrerr, ISTACK)		# Corrected Memory Read, 54
	NOVEC;				# System Backplane Alert/RXCD, 58
	INTVEC(sbiflt, ISTACK)		# System Backplane Fault, 5C
	NOVEC;				# Memory Write Timeout, 60
	NOVEC;				# Unused, 64
	NOVEC;				# Unused, 68
	NOVEC;				# Unused, 6C
	NOVEC;				# Unused, 70
	NOVEC;				# Unused, 74
	NOVEC;				# Unused, 78
	NOVEC;				# Unused, 7C
	NOVEC;				# Unused, 80
	NOVEC;				# Unused, 84
	INTVEC(astintr,	KSTACK)		# Asynchronous System Trap, AST
	NOVEC;				# Unused, 8C
	NOVEC;				# Unused, 90
	NOVEC;				# Unused, 94
	NOVEC;				# Unused, 98
	NOVEC;				# Unused, 9C
	INTVEC(softintr,ISTACK)		# Software interrupts (IPL_SOFT)
	INTVEC(softintr,ISTACK)		# Software interrupts (IPL_SOFTCLOCK)
	INTVEC(softintr,ISTACK)		# Software interrupts (IPL_SOFTNET)
	INTVEC(softintr,ISTACK)		# Software interrupts (IPL_SOFTTTY)
	NOVEC;				# Unused, B0
	NOVEC;				# Unused, B4
	NOVEC;				# Unused, B8
	INTVEC(ddbtrap, ISTACK) 	# Kernel debugger trap, BC
	INTVEC(hardclock,ISTACK)	# Interval Timer
	NOVEC;				# Unused, C4
	INTVEC(emulate, KSTACK)		# Subset instruction emulation, C8
	NOVEC;				# Unused, CC
	NOVEC;				# Unused, D0
	NOVEC;				# Unused, D4
	NOVEC;				# Unused, D8
	NOVEC;				# Unused, DC
	NOVEC;				# Unused, E0
	NOVEC;				# Unused, E4
	NOVEC;				# Unused, E8
	NOVEC;				# Unused, EC
	NOVEC;		
	NOVEC;		
	NOVEC;		
	NOVEC;		

	/* space for adapter vectors */
	.space 0x100

		.align 2
#
# mcheck is the badaddress trap, also called when referencing
# a invalid address (busserror)
# _memtest (memtest in C) holds the address to continue execution
# at when returning from a intentional test.
#
mcheck: .globl	mcheck
	tstl	_cold		# Are we still in coldstart?
	bneq	L4		# Yes.

	pushr	$0x7f
	pushab	24(sp)
	movl	_dep_call,r6	# CPU dependent mchk handling
	calls	$1,*MCHK(r6)
	tstl	r0		# If not machine check, try memory error
	beql	1f
	calls	$0,*MEMERR(r6)
	pushab	2f
	calls	$1,_panic
2:	.asciz	"mchk"
1:	popr	$0x7f
	addl2	(sp)+,sp

	rei

L4:	addl2	(sp)+,sp	# remove info pushed on stack
	cmpl	_vax_cputype,$1 # Is it a 11/780?
	bneq	1f		# No...

	mtpr	$0, $PR_SBIFS	# Clear SBI fault register
	brb	2f

1:	cmpl	_vax_cputype,$4 # Is it a 8600?
	bneq	3f

	mtpr	$0, $PR_EHSR	# Clear Error status register
	brb	2f

3:	mtpr	$0xF,$PR_MCESR	# clear the bus error bit
2:	movl	_memtest,(sp)	# REI to new address
	rei

TRAPCALL(invkstk, T_KSPNOTVAL)

ENTRY(privinflt)	# Privileged/unimplemented instruction
#ifdef INSN_EMULATE
	jsb	unimemu	# do not return if insn emulated
#endif
	pushl $0
	pushl $T_PRIVINFLT
	jbr trap

TRAPCALL(xfcflt, T_XFCFLT);
TRAPCALL(resopflt, T_RESOPFLT)
TRAPCALL(resadflt, T_RESADFLT)

/*
 * Translation fault, used only when simulating page reference bit.
 * Therefore it is done a fast revalidation of the page if it is
 * referenced. Trouble here is the hardware bug on KA650 CPUs that
 * put in a need for an extra check when the fault is gotten during
 * PTE reference. Handled in pmap.c.
 */
	.align	2
	.globl	transl_v	# 20: Translation violation
transl_v:
	PUSHR
	pushl	28(sp)
	pushl	28(sp)
	calls	$2,_pmap_simulref
	tstl	r0
	bneq	1f
	POPR
	addl2	$8,sp
	rei
1:	POPR
	brb	access_v

	.align	2
	.globl	access_v	# 24: Access cntrl viol fault
access_v:
	blbs	(sp), ptelen
	pushl	$T_ACCFLT
	bbc	$1,4(sp),1f
	bisl2	$T_PTEFETCH,(sp)
1:	bbc	$2,4(sp),2f
	bisl2	$T_WRITE,(sp)
2:	movl	(sp), 4(sp)
	addl2	$4, sp
	jbr	trap

ptelen: movl	$T_PTELEN, (sp)		# PTE must expand (or send segv)
	jbr trap;

TRAPCALL(tracep, T_TRCTRAP)
TRAPCALL(breakp, T_BPTFLT)

TRAPARGC(arithflt, T_ARITHFLT)

ENTRY(syscall)			# Main system call
	pushl	$T_SYSCALL
	pushr	$0xfff
	mfpr	$PR_USP, -(sp)
	pushl	ap
	pushl	fp
	pushl	sp		# pointer to syscall frame; defined in trap.h
	calls	$1, _syscall
	movl	(sp)+, fp
	movl	(sp)+, ap
	mtpr	(sp)+, $PR_USP
	popr	$0xfff
	addl2	$8, sp
	mtpr	$0x1f, $PR_IPL	# Be sure we can REI
	rei


ENTRY(cmrerr)
	PUSHR
	movl	_dep_call,r0
	calls	$0,*MEMERR(r0)
	POPR
	rei

ENTRY(sbiflt)
	pushab	sbifltmsg
	calls	$1, _panic

TRAPCALL(astintr, T_ASTFLT)

FASTINTR(softintr,softintr_dispatch)

	.data
	.global _netisr
_netisr:
	.long	0	# scheduling bits for network

TRAPCALL(ddbtrap, T_KDBTRAP)

ENTRY(hardclock)
	mtpr	$0xc1,$PR_ICCS		# Reset interrupt flag
	PUSHR
	pushl	sp
	addl2	$24,(sp)
	movl	_dep_call,r0
	calls	$1,*HARDCLOCK(r0)
	incl	_clock_intrcnt+EC_COUNT		# increment low longword
	adwc	$0,_clock_intrcnt+EC_COUNT+4	# add any carry to hi longword
	POPR
	rei

/*
 * Main routine for traps; all go through this.
 * Note that we put USP on the frame here, which sometimes should
 * be KSP to be correct, but because we only alters it when we are 
 * called from user space it doesn't care.
 * _sret is used in cpu_set_kpc to jump out to user space first time.
 */
	.globl	_sret
trap:	pushr	$0xfff
	mfpr	$PR_USP, -(sp)
	pushl	ap
	pushl	fp
	pushl	sp
	calls	$1, _arithflt
_sret:	movl	(sp)+, fp
	movl	(sp)+, ap
	mtpr	(sp)+, $PR_USP
	popr	$0xfff
	addl2	$8, sp
	mtpr	$0x1f, $PR_IPL	# Be sure we can REI
	rei

sbifltmsg:
	.asciz	"SBI fault"

#if INSN_EMULATE
/*
 * Table of emulated Microvax instructions supported by emulate.s.
 * Use noemulate to convert unimplemented ones to reserved instruction faults.
 */
	.globl	_emtable
_emtable:
/* f8 */ .long _EMashp; .long _EMcvtlp; .long noemulate; .long noemulate
/* fc */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 00 */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 04 */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 08 */ .long _EMcvtps; .long _EMcvtsp; .long noemulate; .long _EMcrc
/* 0c */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 10 */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 14 */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 18 */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 1c */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 20 */ .long _EMaddp4; .long _EMaddp6; .long _EMsubp4; .long _EMsubp6
/* 24 */ .long _EMcvtpt; .long _EMmulp; .long _EMcvttp; .long _EMdivp
/* 28 */ .long noemulate; .long _EMcmpc3; .long _EMscanc; .long _EMspanc
/* 2c */ .long noemulate; .long _EMcmpc5; .long _EMmovtc; .long _EMmovtuc
/* 30 */ .long noemulate; .long noemulate; .long noemulate; .long noemulate
/* 34 */ .long _EMmovp; .long _EMcmpp3; .long _EMcvtpl; .long _EMcmpp4
/* 38 */ .long _EMeditpc; .long _EMmatchc; .long _EMlocc; .long _EMskpc
#endif
/*
 * The following is called with the stack set up as follows:
 *
 *	  (sp): Opcode
 *	 4(sp): Instruction PC
 *	 8(sp): Operand 1
 *	12(sp): Operand 2
 *	16(sp): Operand 3
 *	20(sp): Operand 4
 *	24(sp): Operand 5
 *	28(sp): Operand 6
 *	32(sp): Operand 7 (unused)
 *	36(sp): Operand 8 (unused)
 *	40(sp): Return PC
 *	44(sp): Return PSL
 *	48(sp): TOS before instruction
 *
 * Each individual routine is called with the stack set up as follows:
 *
 *	  (sp): Return address of trap handler
 *	 4(sp): Opcode (will get return PSL)
 *	 8(sp): Instruction PC
 *	12(sp): Operand 1
 *	16(sp): Operand 2
 *	20(sp): Operand 3
 *	24(sp): Operand 4
 *	28(sp): Operand 5
 *	32(sp): Operand 6
 *	36(sp): saved register 11
 *	40(sp): saved register 10
 *	44(sp): Return PC
 *	48(sp): Return PSL
 *	52(sp): TOS before instruction
 *	See the VAX Architecture Reference Manual, Section B-5 for more
 *	information.
 */

	.align	2
	.globl	emulate
emulate:
#if INSN_EMULATE
	movl	r11,32(sp)		# save register r11 in unused operand
	movl	r10,36(sp)		# save register r10 in unused operand
	cvtbl	(sp),r10		# get opcode
	addl2	$8,r10			# shift negative opcodes
	subl3	r10,$0x43,r11		# forget it if opcode is out of range
	bcs	noemulate
	movl	_emtable[r10],r10	# call appropriate emulation routine
	jsb	(r10)		# routines put return values into regs 0-5
	movl	32(sp),r11		# restore register r11
	movl	36(sp),r10		# restore register r10
	insv	(sp),$0,$4,44(sp)	# and condition codes in Opcode spot
	addl2	$40,sp			# adjust stack for return
	rei
noemulate:
	addl2	$48,sp			# adjust stack for
#endif
	.word	0xffff			# "reserved instruction fault"

	.data
_scb:	.long 0
	.globl _scb

@


1.23
log
@Switch vax to __HAVE_GENERIC_SOFT_INTERRUPTS.
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.22 2008/08/18 23:05:38 miod Exp $   */
@


1.22
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.21 2007/05/10 17:59:27 deraadt Exp $   */
d124 5
a128 5
	INTVEC(softclock,ISTACK)	# Software clock interrupt
	NOVEC;				# Unused, A4
	NOVEC;				# Unused, A8
	NOVEC;				# Unused, AC
	INTVEC(netint,	ISTACK)		# Network interrupt
d195 1
a195 1
	TRAPCALL(invkstk, T_KSPNOTVAL)
d205 3
a207 3
	TRAPCALL(xfcflt, T_XFCFLT);
	TRAPCALL(resopflt, T_RESOPFLT)
	TRAPCALL(resadflt, T_RESADFLT)
d247 2
a248 2
	TRAPCALL(tracep, T_TRCTRAP)
	TRAPCALL(breakp, T_BPTFLT)
d250 1
a250 1
	TRAPARGC(arithflt, T_ARITHFLT)
d280 1
a280 1
	TRAPCALL(astintr, T_ASTFLT)
d282 1
a282 1
	FASTINTR(softclock,softclock)
d289 1
a289 11
ENTRY(netint)
	PUSHR
/* XXX this relies on -traditional-cpp, since we can't use _C_LABEL here */
#define	DONETISR(bit, fn) \
	bbcc	$bit,_netisr,1f; calls $0,_/**/fn; 1:
#include <net/netisr_dispatch.h>
#undef	DONETISR
	POPR
	rei

	TRAPCALL(ddbtrap, T_KDBTRAP)
@


1.21
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.20 2004/12/24 22:50:31 miod Exp $   */
d160 1
a160 1
	tstl	_cold		# Ar we still in coldstart?
d219 1
a219 1
	pushr	$0x3f
d225 1
a225 1
	popr	$0x3f
d228 1
a228 1
1:	popr	$0x3f
d276 1
a276 1
ENTRY(sbiflt);
d301 11
a311 15
		.align	2
		.globl	hardclock
hardclock:	mtpr	$0xc1,$PR_ICCS		# Reset interrupt flag
		pushr	$0x3f
#ifdef VAX46
		cmpl	_vax_boardtype,$VAX_BTYP_46
		bneq	1f
		movl	_ka46_cpu,r0
		clrl	0x1c(r0)
#endif
1:		pushl	sp
		addl2	$24,(sp)
		calls	$1,_hardclock
		popr	$0x3f
		rei
@


1.20
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.19 2004/07/07 23:10:46 deraadt Exp $   */
a304 2
	incl	_clock_intrcnt+EC_COUNT	# count the number of clock interrupts
	adwc	$0,_clock_intrcnt+EC_COUNT+4
@


1.19
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.18 2004/04/18 00:25:22 mickey Exp $   */
a426 8

	.globl	_intrnames, _eintrnames, _intrcnt, _eintrcnt
_intrnames:
	.long	0
_eintrnames:
_intrcnt:
	.long	0
_eintrcnt:
@


1.18
log
@typo in a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.17 2003/11/07 10:16:45 jmc Exp $   */
d305 2
a306 2
	incl	_clock_intrcnt+EV_COUNT	# count the number of clock interrupts
#	adwc	$0,_clock_intrcnt+EV_COUNT+4
@


1.17
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.16 2003/11/06 21:09:35 mickey Exp $   */
d118 1
a118 1
	INTVEC(astintr,	KSTACK)		# Asynchronous Sustem Trap, AST
@


1.16
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.15 2002/04/29 19:13:24 miod Exp $   */
d192 1
a192 1
2:	movl	_memtest,(sp)	# REI to new adress
@


1.15
log
@Use netisr_dispatch.
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.14 2001/08/25 13:33:37 hugh Exp $   */
d283 5
@


1.14
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.13 2000/10/24 01:50:19 hugh Exp $   */
d37 1
a37 2
#include "ppp.h"
#include "bridge.h"
d286 5
a290 25
#ifdef INET
	bbcc	$NETISR_ARP,_netisr,1f; calls $0,_arpintr; 1:
	bbcc	$NETISR_IP,_netisr,1f; calls $0,_ipintr; 1:
#endif
#ifdef INET6
	bbcc	$NETISR_IPV6,_netisr,1f; calls $0,_ip6intr; 1:
#endif
#ifdef NETATALK
	bbcc	$NETISR_ATALK,_netisr,1f; calls $0,_atintr; 1:
#endif
#ifdef NS
	bbcc	$NETISR_NS,_netisr,1f; calls $0,_nsintr; 1:
#endif
#ifdef ISO
	bbcc	$NETISR_ISO,_netisr,1f; calls $0,_clnlintr; 1:
#endif
#ifdef CCITT
	bbcc	$NETISR_CCITT,_netisr,1f; calls $0,_ccittintr; 1:
#endif
#if NPPP > 0
	bbcc	$NETISR_PPP,_netisr,1f; calls $0,_pppintr; 1:
#endif
#if NBRIDGE > 0
	bbcc	$NETISR_BRIDGE,_netisr,1f; calls $0, _bridgeintr; 1:
#endif
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.14 2001/08/25 13:33:37 hugh Exp $   */
d37 2
a38 1
#include <net/netisr.h>
d287 25
a311 5
/* XXX this relies on -traditional-cpp, since we can't use _C_LABEL here */
#define	DONETISR(bit, fn) \
	bbcc	$bit,_netisr,1f; calls $0,_/**/fn; 1:
#include <net/netisr_dispatch.h>
#undef	DONETISR
@


1.13
log
@Code to emulate instructions trapped by a privinflt.
Currently only one instruction emulated (mostly): polyd
Obtained from: NetBSD; Cleared with Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.12 2000/04/27 01:10:12 bjc Exp $   */
d217 3
a219 2
		.align	2
transl_v: .globl transl_v	# Translation violation, 20
d232 3
a234 2
		.align	2
access_v:.globl access_v	# Access cntrl viol fault,	24
d278 1
a278 1
	movab	sbifltmsg, -(sp)
d321 2
@


1.12
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.11 1998/05/11 16:24:43 niklas Exp $   */
d198 8
a205 1
	TRAPCALL(privinflt, T_PRIVINFLT)
d356 1
a356 1
#if VAX630 || VAX650 || VAX410
d421 1
a421 1
#if VAX630 || VAX650 || VAX410
@


1.11
log
@Revert to 1.8, the corruption prob I had was local, and cvs did
not notice it, thus I thought it was in the repos
@
text
@d1 2
a2 2
/*	$OpenBSD: intvec.s,v 1.8 1997/09/12 09:30:54 maja Exp $   */
/*	$NetBSD: intvec.s,v 1.23 1997/07/28 21:48:35 ragge Exp $   */
d5 1
a5 1
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
a33 2
 /* All bugs are subject to removal without further notice */
		
d35 1
d37 2
a38 3
#include <machine/mtpr.h>
#include <machine/pte.h>
#include <machine/trap.h>
d64 2
a65 8
#define STRAY(scbnr, vecnr) \
ENTRY(stray/**/vecnr)		; \
	pushr $0x3f		; \
	pushl $/**/0x/**/vecnr	; \
	pushl $scbnr		; \
	calls $2,_stray		; \
	popr $0x3f		; \
	rei
d69 1
d74 2
a75 2
	.globl	_kernel_text, _kernbase, _rpb
_kernel_text:
d85 1
a85 1
	INTVEC(stray00, ISTACK) # Unused., 0
d87 2
a88 2
	INTVEC(invkstk, ISTACK) # Kernel Stack Invalid., 8
	INTVEC(stray0C, ISTACK) # Power Failed., C
d92 1
a92 1
	INTVEC(resadflt, KSTACK)	# # Reserved Address Mode., 1C
d95 3
a97 3
	INTVEC(tracep, KSTACK)	# Trace Pending, 28
	INTVEC(breakp, KSTACK)	# Breakpoint Instruction, 2C
	INTVEC(stray30, ISTACK) # Compatibility Exception, 30
d99 2
a100 2
	INTVEC(stray38, ISTACK) # Unused, 38
	INTVEC(stray3C, ISTACK) # Unused, 3C
d105 20
a124 20
	INTVEC(sbiexc, ISTACK)	# System Backplane Exception/BIerror, 50
	INTVEC(cmrerr, ISTACK)	# Corrected Memory Read, 54
	INTVEC(rxcs, ISTACK)	# System Backplane Alert/RXCD, 58
	INTVEC(sbiflt, ISTACK)	# System Backplane Fault, 5C
	INTVEC(stray60, ISTACK) # Memory Write Timeout, 60
	INTVEC(stray64, ISTACK) # Unused, 64
	INTVEC(stray68, ISTACK) # Unused, 68
	INTVEC(stray6C, ISTACK) # Unused, 6C
	INTVEC(stray70, ISTACK) # Unused, 70
	INTVEC(stray74, ISTACK) # Unused, 74
	INTVEC(stray78, ISTACK) # Unused, 78
	INTVEC(stray7C, ISTACK) # Unused, 7C
	INTVEC(stray80, ISTACK) # Unused, 80
	INTVEC(stray84, ISTACK) # Unused, 84
	INTVEC(astintr,	 KSTACK)	# Asynchronous Sustem Trap, AST
	INTVEC(stray8C, ISTACK) # Unused, 8C
	INTVEC(stray90, ISTACK) # Unused, 90
	INTVEC(stray94, ISTACK) # Unused, 94
	INTVEC(stray98, ISTACK) # Unused, 98
	INTVEC(stray9C, ISTACK) # Unused, 9C
d126 7
a132 7
	INTVEC(strayA4, ISTACK) # Unused, A4
	INTVEC(strayA8, ISTACK) # Unused, A8
	INTVEC(strayAC, ISTACK) # Unused, AC
	INTVEC(netint,	 ISTACK)	# Network interrupt
	INTVEC(strayB4, ISTACK) # Unused, B4
	INTVEC(strayB8, ISTACK) # Unused, B8
	INTVEC(ddbtrap, ISTACK) # Kernel debugger trap, BC
d134 15
a148 20
	INTVEC(strayC4, ISTACK) # Unused, C4
	INTVEC(emulate, KSTACK) # Subset instruction emulation
	INTVEC(strayCC, ISTACK) # Unused, CC
	INTVEC(strayD0, ISTACK) # Unused, D0
	INTVEC(strayD4, ISTACK) # Unused, D4
	INTVEC(strayD8, ISTACK) # Unused, D8
	INTVEC(strayDC, ISTACK) # Unused, DC
	INTVEC(strayE0, ISTACK) # Unused, E0
	INTVEC(strayE4, ISTACK) # Unused, E4
	INTVEC(strayE8, ISTACK) # Unused, E8
	INTVEC(strayEC, ISTACK) # Unused, EC
	INTVEC(strayF0, ISTACK)
	INTVEC(strayF4, ISTACK)
#if VAX8600 || VAX8200 || VAX750 || VAX780 || VAX630 || VAX650
	INTVEC(consrint, ISTACK)	# Console Terminal Recieve Interrupt
	INTVEC(constint, ISTACK)	# Console Terminal Transmit Interrupt
#else
	INTVEC(strayF8, ISTACK)
	INTVEC(strayFC, ISTACK)
#endif
a152 2
	STRAY(0,00)

d164 1
a164 1
	pushr	$0x3f
d166 9
a174 2
	calls	$1, _machinecheck
	popr	$0x3f
a196 1
	STRAY(0,0C)
d203 7
d211 12
a222 10
transl_v:	.globl	transl_v	# Translation violation, 20
	pushl	$T_TRANSFLT
L3:	bbc	$1,4(sp),L1
	bisl2	$T_PTEFETCH, (sp)
L1:	bbc	$2,4(sp),L2
	bisl2	$T_WRITE, (sp)
L2:	movl	(sp), 4(sp)
	addl2	$4, sp
	jbr	trap

d228 7
a234 1
	jbr	L3
a240 1
	STRAY(0,30)
d244 1
a244 10
	STRAY(0,38)
	STRAY(0,3C)





	.align 2		# Main system call 
	.globl	syscall
syscall:
a259 3
	STRAY(0,44)
	STRAY(0,48)
	STRAY(0,4C)
d261 5
a265 24
ENTRY(sbiexc)
	tstl	_cold	/* Is it ok to get errs during boot??? */
	bneq	1f
	pushr	$0x3f
	pushl	$0x50
	pushl	$0
	calls	$2,_stray
	popr	$0x3f
1:	rei

	FASTINTR(cmrerr,cmrerr)

ENTRY(rxcs);	/* console interrupt from some other processor */
	pushr	$0x3f
#if VAX8200
	cmpl	$5,_vax_cputype
	bneq	1f
	calls	$0,_rxcdintr
	brb	2f
#endif
1:	pushl	$0x58
	pushl	$0
	calls	$2,_stray
2:	popr	$0x3f
d268 2
a269 2
	ENTRY(sbiflt);
	moval	sbifltmsg, -(sp)
a271 11
	STRAY(0,60)
	STRAY(0,64)
	STRAY(0,68)
	STRAY(0,6C)
	STRAY(0,70)
	STRAY(0,74)
	STRAY(0,78)
	STRAY(0,7C)
	STRAY(0,80)
	STRAY(0,84)

a273 6
	STRAY(0,8C)
	STRAY(0,90)
	STRAY(0,94)
	STRAY(0,98)
	STRAY(0,9C)

d276 29
a304 5
	STRAY(0,A4)
	STRAY(0,A8)
	STRAY(0,AC)

	FASTINTR(netint,netintr)	#network packet interrupt
a305 2
	STRAY(0,B4)
	STRAY(0,B8)
d312 7
a318 1
		pushl	sp
a323 20
	STRAY(0,C4)
	STRAY(0,CC)
	STRAY(0,D0)
	STRAY(0,D4)
	STRAY(0,D8)
	STRAY(0,DC)
	STRAY(0,E0)
	STRAY(0,E4)
	STRAY(0,E8)
	STRAY(0,EC)
	STRAY(0,F0)
	STRAY(0,F4)
#if VAX8600 || VAX8200 || VAX750 || VAX780 || VAX630 || VAX650
	FASTINTR(consrint,gencnrint)
	FASTINTR(constint,gencntint)
#else
	STRAY(0,F8)
	STRAY(0,FC)
#endif

d347 1
a347 1
	.asciz	"SBI fault",0
@


1.11.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: intvec.s,v 1.13 2000/10/24 01:50:19 hugh Exp $   */
/*	$NetBSD: intvec.s,v 1.39 1999/06/28 08:20:48 itojun Exp $   */
d5 1
a5 1
 * Copyright (c) 1994, 1997 Ludd, University of Lule}, Sweden.
d34 2
a36 1
#include "assym.h"
d38 3
a40 2
#include "ppp.h"
#include "bridge.h"
d66 8
a73 2
#define	PUSHR	pushr	$0x3f
#define	POPR	popr	$0x3f
a76 1
#define	NOVEC	.long 0
d81 2
a82 2
	.globl	_kernbase, _rpb, _kernel_text
	.set	_kernel_text,KERNBASE
d92 1
a92 1
	NOVEC;				# Unused, 0
d94 2
a95 2
	INTVEC(invkstk, ISTACK) 	# Kernel Stack Invalid., 8
	NOVEC;			 	# Power Failed., C
d99 1
a99 1
	INTVEC(resadflt, KSTACK)	# Reserved Address Mode., 1C
d102 3
a104 3
	INTVEC(tracep, KSTACK)		# Trace Pending, 28
	INTVEC(breakp, KSTACK)		# Breakpoint Instruction, 2C
	NOVEC;			 	# Compatibility Exception, 30
d106 2
a107 2
	NOVEC;			 	# Unused, 38
	NOVEC;			 	# Unused, 3C
d112 20
a131 20
	NOVEC;				# System Backplane Exception/BIerror, 50
	INTVEC(cmrerr, ISTACK)		# Corrected Memory Read, 54
	NOVEC;				# System Backplane Alert/RXCD, 58
	INTVEC(sbiflt, ISTACK)		# System Backplane Fault, 5C
	NOVEC;				# Memory Write Timeout, 60
	NOVEC;				# Unused, 64
	NOVEC;				# Unused, 68
	NOVEC;				# Unused, 6C
	NOVEC;				# Unused, 70
	NOVEC;				# Unused, 74
	NOVEC;				# Unused, 78
	NOVEC;				# Unused, 7C
	NOVEC;				# Unused, 80
	NOVEC;				# Unused, 84
	INTVEC(astintr,	KSTACK)		# Asynchronous Sustem Trap, AST
	NOVEC;				# Unused, 8C
	NOVEC;				# Unused, 90
	NOVEC;				# Unused, 94
	NOVEC;				# Unused, 98
	NOVEC;				# Unused, 9C
d133 7
a139 7
	NOVEC;				# Unused, A4
	NOVEC;				# Unused, A8
	NOVEC;				# Unused, AC
	INTVEC(netint,	ISTACK)		# Network interrupt
	NOVEC;				# Unused, B4
	NOVEC;				# Unused, B8
	INTVEC(ddbtrap, ISTACK) 	# Kernel debugger trap, BC
d141 20
a160 15
	NOVEC;				# Unused, C4
	INTVEC(emulate, KSTACK)		# Subset instruction emulation, C8
	NOVEC;				# Unused, CC
	NOVEC;				# Unused, D0
	NOVEC;				# Unused, D4
	NOVEC;				# Unused, D8
	NOVEC;				# Unused, DC
	NOVEC;				# Unused, E0
	NOVEC;				# Unused, E4
	NOVEC;				# Unused, E8
	NOVEC;				# Unused, EC
	NOVEC;		
	NOVEC;		
	NOVEC;		
	NOVEC;		
d165 2
d178 1
a178 1
	pushr	$0x7f
d180 2
a181 9
	movl	_dep_call,r6	# CPU dependent mchk handling
	calls	$1,*MCHK(r6)
	tstl	r0		# If not machine check, try memory error
	beql	1f
	calls	$0,*MEMERR(r6)
	pushab	2f
	calls	$1,_panic
2:	.asciz	"mchk"
1:	popr	$0x7f
d204 1
d206 1
a206 8
ENTRY(privinflt)	# Privileged/unimplemented instruction
#ifdef INSN_EMULATE
	jsb	unimemu	# do not return if insn emulated
#endif
	pushl $0
	pushl $T_PRIVINFLT
	jbr trap

a210 7
/*
 * Translation fault, used only when simulating page reference bit.
 * Therefore it is done a fast revalidation of the page if it is
 * referenced. Trouble here is the hardware bug on KA650 CPUs that
 * put in a need for an extra check when the fault is gotten during
 * PTE reference. Handled in pmap.c.
 */
d212 10
a221 12
transl_v: .globl transl_v	# Translation violation, 20
	pushr	$0x3f
	pushl	28(sp)
	pushl	28(sp)
	calls	$2,_pmap_simulref
	tstl	r0
	bneq	1f
	popr	$0x3f
	addl2	$8,sp
	rei
1:	popr	$0x3f
	brb	access_v
d227 1
a227 7
	bbc	$1,4(sp),1f
	bisl2	$T_PTEFETCH,(sp)
1:	bbc	$2,4(sp),2f
	bisl2	$T_WRITE,(sp)
2:	movl	(sp), 4(sp)
	addl2	$4, sp
	jbr	trap
d234 1
d238 10
a247 1
ENTRY(syscall)			# Main system call
d263 3
d267 24
a290 5
ENTRY(cmrerr)
	PUSHR
	movl	_dep_call,r0
	calls	$0,*MEMERR(r0)
	POPR
d293 2
a294 2
ENTRY(sbiflt);
	movab	sbifltmsg, -(sp)
d297 11
d310 6
d318 5
a322 29
ENTRY(netint)
	PUSHR
#ifdef INET
	bbcc	$NETISR_ARP,_netisr,1f; calls $0,_arpintr; 1:
	bbcc	$NETISR_IP,_netisr,1f; calls $0,_ipintr; 1:
#endif
#ifdef INET6
	bbcc	$NETISR_IPV6,_netisr,1f; calls $0,_ip6intr; 1:
#endif
#ifdef NETATALK
	bbcc	$NETISR_ATALK,_netisr,1f; calls $0,_atintr; 1:
#endif
#ifdef NS
	bbcc	$NETISR_NS,_netisr,1f; calls $0,_nsintr; 1:
#endif
#ifdef ISO
	bbcc	$NETISR_ISO,_netisr,1f; calls $0,_clnlintr; 1:
#endif
#ifdef CCITT
	bbcc	$NETISR_CCITT,_netisr,1f; calls $0,_ccittintr; 1:
#endif
#if NPPP > 0
	bbcc	$NETISR_PPP,_netisr,1f; calls $0,_pppintr; 1:
#endif
#if NBRIDGE > 0
	bbcc	$NETISR_BRIDGE,_netisr,1f; calls $0, _bridgeintr; 1:
#endif
	POPR
	rei
d324 2
d332 1
a332 7
#ifdef VAX46
		cmpl	_vax_boardtype,$VAX_BTYP_46
		bneq	1f
		movl	_ka46_cpu,r0
		clrl	0x1c(r0)
#endif
1:		pushl	sp
d338 20
d381 1
a381 1
	.asciz	"SBI fault"
d383 1
a383 1
#if INSN_EMULATE
d448 1
a448 1
#if INSN_EMULATE
@


1.11.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.11.8.1 2001/05/14 21:38:53 niklas Exp $   */
d217 2
a218 3
	.align	2
	.globl	transl_v	# 20: Translation violation
transl_v:
d231 2
a232 3
	.align	2
	.globl	access_v	# 24: Access cntrl viol fault
access_v:
d276 1
a276 1
	pushab	sbifltmsg
a318 2
	incl	_clock_intrcnt+EV_COUNT	# count the number of clock interrupts
#	adwc	$0,_clock_intrcnt+EV_COUNT+4
@


1.11.8.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$   */
d37 2
a38 1
#include <net/netisr.h>
d287 25
a311 5
/* XXX this relies on -traditional-cpp, since we can't use _C_LABEL here */
#define	DONETISR(bit, fn) \
	bbcc	$bit,_netisr,1f; calls $0,_/**/fn; 1:
#include <net/netisr_dispatch.h>
#undef	DONETISR
@


1.11.8.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d192 1
a192 1
2:	movl	_memtest,(sp)	# REI to new address
a282 5

	.data
	.global _netisr
_netisr:
	.long	0	# scheduling bits for network
@


1.11.8.5
log
@Merge with the trunk
@
text
@d118 1
a118 1
	INTVEC(astintr,	KSTACK)		# Asynchronous System Trap, AST
@


1.10
log
@Added som new defines needed
@
text
@a74 3
#define	PUSHR	pushr	$0x3f
#define	POPR	popr	$0x3f

d322 1
a322 25
ENTRY(netint)
	PUSHR
#ifdef INET
#if NARP > 0
	bbcc	$NETISR_ARP,_netisr,1f; calls $0,_arpintr; 1:
#endif
	bbcc	$NETISR_IP,_netisr,1f; calls $0,_ipintr; 1:
#endif
#ifdef NETATALK
	bbcc	$NETISR_ATALK,_netisr,1f; calls $0,_atintr; 1:
#endif
#ifdef NS
	bbcc	$NETISR_NS,_netisr,1f; calls $0,_nsintr; 1:
#endif
#ifdef ISO
	bbcc	$NETISR_ISO,_netisr,1f; calls $0,_clnlintr; 1:
#endif
#ifdef CCITT
	bbcc	$NETISR_CCITT,_netisr,1f; calls $0,_ccittintr; 1:
#endif
#if NPPP > 0
	bbcc	$NETISR_PPP,_netisr,1f; calls $0,_pppintr; 1:
#endif
	POPR
	rei
@


1.9
log
@Hmm another corrupt file, updated lost tail from NetBSD
@
text
@d75 3
@


1.8
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: intvec.s,v 1.7 1997/09/10 12:04:45 maja Exp $   */
d322 25
a346 1
	FASTINTR(netint,netintr)	#network packet interrupt
@


1.7
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: intvec.s,v 1.6 1997/05/28 23:20:17 niklas Exp $   */
/*	$NetBSD: intvec.s,v 1.22 1997/03/22 23:02:07 ragge Exp $   */
d97 1
a97 1
	INTVEC(stray14, ISTACK) # Customer Reserved Instruction, 14
d207 1
a207 1
	STRAY(0,14)
@


1.6
log
@Add kernel_text sym
@
text
@d1 2
a2 2
/*	$OpenBSD: intvec.s,v 1.20 1996/07/20 18:20:44 ragge Exp $   */
/*	$NetBSD: intvec.s,v 1.20 1996/07/20 18:20:44 ragge Exp $   */
d154 1
d157 4
d350 1
a350 1

d353 4
d383 1
a383 1
#if VAX630 || VAX650
d448 1
a448 1
#if VAX630 || VAX650
@


1.5
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
d81 2
a82 1
	.globl	_kernbase, _rpb
@


1.4
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: intvec.s,v 1.19 1996/03/09 23:36:40 ragge Exp $   */
d41 1
a41 1
#define	ENTRY(name) \
d47 1
a47 1
#define	TRAPCALL(namn, typ) \
d53 1
a53 1
#define	TRAPARGC(namn, typ) \
d58 1
a58 1
#define	FASTINTR(namn, rutin) \
d65 1
a65 1
#define	STRAY(scbnr, vecnr) \
d74 1
a74 1
#define	KSTACK 0
d90 1
a90 1
	INTVEC(stray00, ISTACK)	# Unused., 0
d92 2
a93 2
	INTVEC(invkstk, ISTACK)	# Kernel Stack Invalid., 8
	INTVEC(stray0C, ISTACK)	# Power Failed., C
d95 1
a95 1
	INTVEC(stray14, ISTACK)	# Customer Reserved Instruction, 14
d102 1
a102 1
	INTVEC(stray30, ISTACK)	# Compatibility Exception, 30
d104 2
a105 2
	INTVEC(stray38, ISTACK)	# Unused, 38
	INTVEC(stray3C, ISTACK)	# Unused, 3C
d110 1
a110 1
	INTVEC(stray50, ISTACK)	# System Backplane Exception, 50
d112 1
a112 1
	INTVEC(stray58, ISTACK)	# System Backplane Alert, 58
d114 10
a123 10
	INTVEC(stray60, ISTACK)	# Memory Write Timeout, 60
	INTVEC(stray64, ISTACK)	# Unused, 64
	INTVEC(stray68, ISTACK)	# Unused, 68
	INTVEC(stray6C, ISTACK)	# Unused, 6C
	INTVEC(stray70, ISTACK)	# Unused, 70
	INTVEC(stray74, ISTACK)	# Unused, 74
	INTVEC(stray78, ISTACK)	# Unused, 78
	INTVEC(stray7C, ISTACK)	# Unused, 7C
	INTVEC(stray80, ISTACK)	# Unused, 80
	INTVEC(stray84, ISTACK)	# Unused, 84
d125 5
a129 5
	INTVEC(stray8C, ISTACK)	# Unused, 8C
	INTVEC(stray90, ISTACK)	# Unused, 90
	INTVEC(stray94, ISTACK)	# Unused, 94
	INTVEC(stray98, ISTACK)	# Unused, 98
	INTVEC(stray9C, ISTACK)	# Unused, 9C
d131 7
a137 7
	INTVEC(strayA4, ISTACK)	# Unused, A4
	INTVEC(strayA8, ISTACK)	# Unused, A8
	INTVEC(strayAC, ISTACK)	# Unused, AC
	INTVEC(netint,   ISTACK)	# Network interrupt
	INTVEC(strayB4, ISTACK)	# Unused, B4
	INTVEC(strayB8, ISTACK)	# Unused, B8
	INTVEC(ddbtrap, ISTACK)	# Kernel debugger trap, BC
d139 1
a139 1
	INTVEC(strayC4, ISTACK)	# Unused, C4
d141 9
a149 9
	INTVEC(strayCC, ISTACK)	# Unused, CC
	INTVEC(strayD0, ISTACK)	# Unused, D0
	INTVEC(strayD4, ISTACK)	# Unused, D4
	INTVEC(strayD8, ISTACK)	# Unused, D8
	INTVEC(strayDC, ISTACK)	# Unused, DC
	INTVEC(strayE0, ISTACK)	# Unused, E0
	INTVEC(strayE4, ISTACK)	# Unused, E4
	INTVEC(strayE8, ISTACK)	# Unused, E8
	INTVEC(strayEC, ISTACK)	# Unused, EC
d167 1
a167 1
mcheck:	.globl	mcheck
d177 1
a177 1
        rei
d180 1
a180 1
	cmpl	_cpunumber, $1	# Is it a 11/780?
d186 1
a186 1
1:	cmpl	_cpunumber, $4	# Is it a 8600?
d216 2
a217 2
		.align  2
access_v:.globl	access_v	# Access cntrl viol fault, 	24
d222 1
a222 1
ptelen:	movl	$T_PTELEN, (sp)		# PTE must expand (or send segv)
d259 11
a269 1
	STRAY(0,50)
d271 15
a285 1
	STRAY(0,58)
d400 12
a411 12
 *	  (sp):	Opcode
 *	 4(sp):	Instruction PC
 *	 8(sp):	Operand 1
 *	12(sp):	Operand 2
 *	16(sp):	Operand 3
 *	20(sp):	Operand 4
 *	24(sp):	Operand 5
 *	28(sp):	Operand 6
 *	32(sp):	Operand 7 (unused)
 *	36(sp):	Operand 8 (unused)
 *	40(sp):	Return PC
 *	44(sp):	Return PSL
d416 13
a428 13
 *	  (sp):	Return address of trap handler
 *	 4(sp):	Opcode (will get return PSL)
 *	 8(sp):	Instruction PC
 *	12(sp):	Operand 1
 *	16(sp):	Operand 2
 *	20(sp):	Operand 3
 *	24(sp):	Operand 4
 *	28(sp):	Operand 5
 *	32(sp):	Operand 6
 *	36(sp):	saved register 11
 *	40(sp):	saved register 10
 *	44(sp):	Return PC
 *	48(sp):	Return PSL
d456 1
a456 1
        .globl  _intrnames, _eintrnames, _intrcnt, _eintrcnt
d458 1
a458 1
        .long   0
d461 1
a461 1
        .long   0
@


1.3
log
@from ragge;
save usp when trapping from userspace
change register save structs according to this
handle old init register passing convention
@
text
@d1 1
a1 1
/*	$NetBSD: intvec.s,v 1.13 1996/01/28 12:22:55 ragge Exp $   */
d37 37
a73 16
#include "machine/mtpr.h"
#include "machine/pte.h"
#include "machine/trap.h"

#define	TRAPCALL(namn, typ)	\
	.align 2; namn ## :;.globl namn ;pushl $0; pushl $typ; jbr trap;

#define	TRAPARGC(namn, typ)	\
	.align 2; namn ## :;.globl namn ; pushl $typ; jbr trap;

#define	FASTINTR(namn, rutin)	\
	.align 2; namn ## :;.globl namn ;pushr $0x3f; \
	calls $0,_ ## rutin ;popr $0x3f;rei
#define	STRAY(scbnr,vecnr) \
	.align 2;stray ## vecnr ## :;pushr $0x3f;pushl $ ## 0x ## vecnr; \
	pushl $scbnr; calls $2,_stray ; popr $0x3f; rei;
d113 1
a113 1
	INTVEC(stray5C, ISTACK)	# System Backplane Fault, 5C
a149 4
#ifdef VAX750
	INTVEC(cstrint, ISTACK)	# Console Storage Recieve Interrupt
	INTVEC(csttint, ISTACK)	# Console Storage Transmit Interrupt
#else
a151 1
#endif
d158 1
a158 1
	STRAY(0, 00)
d180 14
a193 2
	mtpr	$0xF,$PR_MCESR	# clear the bus error bit
	movl	_memtest,(sp)	# REI to new adress
d197 1
a197 1
	STRAY(0, 0C)
d200 1
a200 1
	STRAY(0, 14)
d227 1
a227 1
	STRAY(0, 30)
d231 2
a232 2
	STRAY(0, 38)
	STRAY(0, 3C)
d256 20
a275 17
	STRAY(0, 44)
	STRAY(0, 48)
	STRAY(0, 4C)
	STRAY(0, 50)
	FASTINTR(cmrerr, cmrerr)
	STRAY(0, 58)
	STRAY(0, 5C)
	STRAY(0, 60)
	STRAY(0, 64)
	STRAY(0, 68)
	STRAY(0, 6C)
	STRAY(0, 70)
	STRAY(0, 74)
	STRAY(0, 78)
	STRAY(0, 7C)
	STRAY(0, 80)
	STRAY(0, 84)
d279 11
a289 11
	STRAY(0, 8C)
	STRAY(0, 90)
	STRAY(0, 94)
	STRAY(0, 98)
	STRAY(0, 9C)

	FASTINTR(softclock, softclock)

	STRAY(0, A4)
	STRAY(0, A8)
	STRAY(0, AC)
d291 1
a291 1
	FASTINTR(netint, netintr)	#network packet interrupt
d293 2
a294 2
	STRAY(0, B4)
	STRAY(0, B8)
d307 12
a318 18
	STRAY(0, C4)
	STRAY(0, CC)
	STRAY(0, D0)
	STRAY(0, D4)
	STRAY(0, D8)
	STRAY(0, DC)
	STRAY(0, E0)
	STRAY(0, E4)
	STRAY(0, E8)
	STRAY(0, EC)

#ifdef VAX750
	FASTINTR(cstrint, cturintr)
	FASTINTR(csttint, ctutintr)
#else
	STRAY(0, F0)
	STRAY(0, F4)
#endif
d320 2
a321 2
	FASTINTR(consrint, gencnrint)
	FASTINTR(constint, gencntint)
d344 3
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: intvec.s,v 1.12 1995/11/10 19:05:46 ragge Exp $   */
d59 1
a59 1
	.globl	_kernbase,_rpb
d215 1
d219 4
a222 3
	calls	$1,_syscall
	movl	(sp)+,fp
	movl	(sp)+,ap
d224 2
a225 2
	addl2	$8,sp
	mtpr	$0x1f,$PR_IPL	# Be sure we can REI
d264 1
a264 1
	TRAPCALL(ddbtrap,T_KDBTRAP)
d298 8
d307 1
d311 7
a317 6
	calls	$1,_arithflt
	movl	(sp)+,fp
	movl	(sp)+,ap
        popr	$0xfff
	addl2	$8,sp
	mtpr	$0x1f,$PR_IPL	# Be sure we can REI
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: intvec.s,v 1.11 1995/06/16 15:36:40 ragge Exp $   */
d37 3
a39 4
#include "vax/include/mtpr.h"
#include "vax/include/pte.h"
#include "vax/include/trap.h"
#include "uba.h"
d63 4
a66 3
 * First page in memory we have rpb; so that we know where :-)
 * Second page contain scb, and thereafter uba vectors.
 * Virtual adress is 0x80000000.
a67 1
	.space	512	/* rpb takes one page */
d90 1
a90 1
	INTVEC(stray54, ISTACK)	# Corrected Memory Read, 54
d129 7
a135 2
	INTVEC(strayF0, ISTACK)	# Console Storage Recieve Interrupt
	INTVEC(strayF4, ISTACK)	# Console Storage Transmit Interrupt
d139 2
a140 11

		.globl _V_DEVICE_VEC
_V_DEVICE_VEC:  .space 0x100

#if NUBA
#include "vax/uba/ubavec.s"
#endif

#if NUBA>4 /* Safety belt */
#error "Number of bus adapters must be increased in ubavec.s"
#endif
d230 1
a230 1
	STRAY(0, 54)
d284 5
d291 1
d399 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
