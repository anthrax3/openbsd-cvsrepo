head	1.44;
access;
symbols
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.39.0.4
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.38.0.16
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.14
	OPENBSD_5_0:1.38.0.12
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.10
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.8
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.4
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.37.0.4
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.30.0.10
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.8
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.10
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.29.0.8
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.29.0.6
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.29.0.4
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.29
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	SMP:1.15.0.4
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.43;
commitid	OSDG2O3Cgeifnf1W;

1.43
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.42;
commitid	dNPv28CJI5BxtRGW;

1.42
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	yv0ECmCdICvq576h;

1.41
date	2013.11.24.22.08.25;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2013.10.17.08.02.18;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.18.23.19.29;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.16.22.59.34;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.13.07.18.02;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.20.17.29.36;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.27.20.59.26;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.29.12.26.14;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.24.17.26.29;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.10.21.05.06;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.08.02.24.07;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.17.05.07.55;	author hugh;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.06.23.57.54;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.06.02.49.23;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.21.02.11.58;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.25.13.25.33;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.08.08.09.33;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.05.21.26.42;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.11.06.34.37;	author hugh;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.09.23.11.57;	author bjc;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.08.22.25.23;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.27.01.10.14;	author bjc;	state Exp;
branches;
next	1.15;

1.15
date	99.08.17.10.32.18;	author niklas;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	99.01.10.13.34.19;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	98.07.28.00.13.56;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.10.08.07.15.57;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.09.12.09.30.57;	author maja;	state Exp;
branches;
next	1.10;

1.10
date	97.09.10.12.04.53;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	97.05.28.23.31.16;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.01.15.23.25.26;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.23.19.50;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.06.12.08.20.41;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.03.09.10.28;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.31.05.15.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.14.00.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches;
next	;

1.15.4.1
date	2001.05.14.21.39.13;	author niklas;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2001.07.04.10.24.49;	author niklas;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.15.4.4;

1.15.4.4
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.15.4.5;

1.15.4.5
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.15.4.6;

1.15.4.6
date	2002.03.30.08.27.12;	author niklas;	state Exp;
branches;
next	1.15.4.7;

1.15.4.7
date	2004.02.19.10.50.03;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.44
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.43 2015/05/05 02:13:47 guenther Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.67 2000/06/29 07:14:34 mrg Exp $	     */

/*
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/vmparam.h>
#include <machine/mtpr.h>
#include <machine/pmap.h>
#include <machine/pte.h>
#include <machine/macros.h>
#include <machine/trap.h>
#include <machine/pcb.h>
#include <machine/frame.h>
#include <machine/cpu.h>
#include <machine/sid.h>

#include <sys/syscallargs.h>

void
cpu_exit(struct proc *p)
{
	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the pcb and trap frame, making the child ready to run.
 * 
 * Rig the child's kernel stack so that it will start out in
 * proc_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
 *
 * p1 is the process being forked;
 *
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
 * accordingly.
 *
 * cpu_fork() copies parent process trapframe directly into child PCB
 * so that when we swtch() to the child process it will go directly
 * back to user mode without any need to jump back through kernel.
 * We also take away mapping for the second page after pcb, so that
 * we get something like a "red zone".
 * No need for either double-map kernel stack or relocate it when
 * forking.
 */
void
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
{
	struct pcb *pcb;
	struct trapframe *tf;
	struct callsframe *cf;
	extern int sret; /* Return address in trap routine */

#ifdef DIAGNOSTIC
	/*
	 * if p1 != curproc && p1 == &proc0, we're creating a kernel thread.
	 */
	if (p1 != curproc && p1 != &proc0)
		panic("cpu_fork: curproc");
#endif

	/*
	 * Clear new pcb
	 */
	pcb = &p2->p_addr->u_pcb;
	bzero(pcb, sizeof (*pcb));

	/*
	 * Copy the trap frame.
	 */
	tf = (struct trapframe *)((u_int)p2->p_addr + USPACE) - 1;
	p2->p_addr->u_pcb.framep = tf;
	bcopy(p1->p_addr->u_pcb.framep, tf, sizeof(*tf));

	/*
	 * Activate address space for the new process.
	 * This writes the page table registers to the PCB.
	 */
	pcb->pcb_pm = NULL;
	pmap_activate(p2);

	/* Mark guard page invalid in kernel stack */
	*kvtopte((u_int)p2->p_addr + REDZONEADDR) &= ~PG_V;

	/*
	 * Set up the calls frame above (below) the trapframe
	 * and populate it with something good.
	 * This is so that we can simulate that we were called by a
	 * CALLS insn in the function given as argument.
	 */
	cf = (struct callsframe *)tf - 1;
	cf->ca_cond = 0;
	cf->ca_maskpsw = 0x20000000;	/* CALLS stack frame, no registers */
	cf->ca_pc = (unsigned)&sret;	/* return PC; userspace trampoline */
	cf->ca_argno = 1;
	cf->ca_arg1 = (int)arg;

	/*
	 * Set up internal defs in PCB. This matches the "fake" CALLS frame
	 * that we constructed earlier.
	 */
	pcb->iftrap = NULL;
	pcb->KSP = (long)cf;
	pcb->FP = (long)cf;
	pcb->AP = (long)&cf->ca_argno;
	pcb->PC = (int)func + 2;	/* Skip save mask */
	pcb->pcb_paddr = kvtophys((vaddr_t)pcb);

	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL)
		tf->sp = (u_long)stack + stacksize;

	tf->r0 = p1->p_pid; /* parent pid. (shouldn't be needed) */
	tf->r1 = 1;
	tf->psl = PSL_U|PSL_PREVU;
}

int
sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	return (ENOSYS);
};

/*
 * Map in a bunch of pages read/writeable for the kernel.
 */
void
ioaccess(vaddr, paddr, npgs)
	vaddr_t vaddr;
	paddr_t paddr;
	int npgs;
{
	u_int *pte = (u_int *)kvtopte(vaddr), template;

	template = PG_V | PG_KW | PG_PFNUM(paddr);
	while (npgs-- != 0)
		*pte++ = template++;
	mtpr(0, PR_TBIA);
}

/*
 * Opposite to the above: just forget their mapping.
 */
void
iounaccess(vaddr, npgs)
	vaddr_t vaddr;
	int npgs;
{
	u_int *pte = (u_int *)kvtopte(vaddr);

	while (npgs-- != 0)
		*pte++ = PG_NV;
	mtpr(0, PR_TBIA);
}

/*
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().
 */
void
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
#if VAX46 || VAX48 || VAX49 || VAX53 || VAX60
	vaddr_t faddr, taddr, off;
	paddr_t pa;
	struct proc *p;

	if (phys_map == NULL)
		return;
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
	p = bp->b_proc;
	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(taddr + off);
	len = atop(len);
	while (len--) {
		if (pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map), faddr,
				&pa) == FALSE)
			panic("vmapbuf: null page frame");
		pmap_enter(vm_map_pmap(phys_map), taddr, trunc_page(pa),
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
	}
	pmap_update(vm_map_pmap(phys_map));
#endif
}

/*
 * Unmap a previously-mapped user I/O request.
 */
void
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
#if VAX46 || VAX48 || VAX49 || VAX53 || VAX60
	vaddr_t addr, off;

	if (phys_map == NULL)
		return;
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	pmap_remove(vm_map_pmap(phys_map), addr, addr + len);
	pmap_update(vm_map_pmap(phys_map));
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
#endif
}
@


1.43
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.42 2014/11/16 12:30:59 deraadt Exp $	*/
@


1.42
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.41 2013/11/24 22:08:25 miod Exp $	*/
a41 1
#include <sys/core.h>
a178 50

/*
 * Dump the machine specific header information at the start of a core dump.
 * First put all regs in PCB for debugging purposes. This is not an good
 * way to do this, but good for my purposes so far.
 */
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	struct trapframe *tf;
	struct md_coredump state;
	struct reg *regs = &state.md_reg;
	struct coreseg cseg;
	int error;

	tf = p->p_addr->u_pcb.framep;
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = sizeof(struct core);
	chdr->c_seghdrsize = sizeof(struct coreseg);
	chdr->c_cpusize = sizeof(struct md_coredump);

	bcopy(&tf->r0, &regs->r0, 12 * sizeof(int));
	regs->ap = tf->ap;
	regs->fp = tf->fp;
	regs->sp = tf->sp;
	regs->pc = tf->pc;
	regs->psl = tf->psl;

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&state, sizeof(state),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);

	if (!error)
		chdr->c_nseg++;

	return error;
}
@


1.41
log
@Rework pmap to use dynamic P0 and P1 region allocation, instead of allocating
the largest possible page table for every pmap; from NetBSD. This allows the
kernel to use much less memory for page tables.

Significant differences against the NetBSD code are:
- allocation of page table pages is done with a pool instead of allocating
  whole logical pages from uvm and managing the freelist within pmap, never
  releasing allocated pages.
- try to use pt_entry_t * rather than int * whenever possible.
- growth of P0 and P1 regions is allowed to fail, if invoked from
  pmap_enter with the PMAP_CANFAIL flag. This will stall processes until
  memory for the page tables can be obtained, rather than panicing, in
  most cases.
- keep management of mappings for managed pages using pv lists tied to the
  vm_page (using __HAVE_VM_PAGE_MD), rather than a global pv_list head.
- bound check against Sysmap[] in pmap_extract() when asked for a kernel
  address.

As a result of this, bsd.rd can now install a working system on a 12MB machine
without needing to enable swap.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.40 2013/10/17 08:02:18 deraadt Exp $	*/
d294 2
a295 1
		    VM_PROT_READ|VM_PROT_WRITE, VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.40
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.39 2013/01/16 19:04:43 miod Exp $	*/
d114 6
d126 7
a152 1
	pcb = &p2->p_addr->u_pcb;
d158 1
@


1.39
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.38 2008/08/18 23:19:29 miod Exp $	*/
a155 8
}

int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	return ENOEXEC;
@


1.38
log
@Add support for the ``Firefox'' VAXstation 3520/3540/3820/3840 workstations,
currently limited to serial console and a single processor working.

All ``on-board'' devices, including the Q-bus adapter, but except for
the frame buffer, are supported. The machine will boot over the network
or from SCSI devices.

Lots of thanks to Al Kossow for www.bitsavers.org, on which I found the
technical documentation allowing me to complete this port (which was
lacking at the time I got that machine...).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.37 2008/02/16 22:59:34 miod Exp $	*/
d212 1
a212 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d218 1
a218 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.37
log
@Only create phys_map on systems which need it, and test for phys_map being
non-null instead of for a variety of vax_boardtype values in vmapbuf() and
vunmapbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.36 2007/10/13 07:18:02 miod Exp $	*/
d269 1
a269 1
#if VAX46 || VAX48 || VAX49 || VAX53
d306 1
a306 1
#if VAX46 || VAX48 || VAX49 || VAX53
@


1.36
log
@Do not splhigh() before invoking sched_exit(), sched_exit() will do it better.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.35 2007/10/10 15:53:53 art Exp $	*/
d274 1
a274 4
	if (vax_boardtype != VAX_BTYP_46
	    && vax_boardtype != VAX_BTYP_48
	    && vax_boardtype != VAX_BTYP_49
	    && vax_boardtype != VAX_BTYP_1303)
d309 1
a309 4
	if (vax_boardtype != VAX_BTYP_46
	    && vax_boardtype != VAX_BTYP_48
	    && vax_boardtype != VAX_BTYP_49
	    && vax_boardtype != VAX_BTYP_1303)
@


1.35
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2007/06/20 17:29:36 miod Exp $	*/
a63 3
	int s;
	s = splhigh();	/* splclock(); */

@


1.34
log
@In vunmapbuf(), explicitely remove mappings before invoking uvm_km_free().
Even if the latter would end up removing the mappings by itself, it would
do so using pmap_remove() because phys_map is not intrsafe; but some
platforms use pmap_kenter_pa() in vmapbuf(). By removing the mappings
ourselves, we can ensure the remove function used matches the enter function
which has been used.
Discussed and theoretical ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2007/05/27 20:59:26 miod Exp $	*/
d61 10
a121 7

	/*
	 * Activate address space for the new process.	The PTEs have
	 * already been allocated by way of pmap_create().
	 * This writes the page table registers to the PCB.
	 */
	pmap_activate(p2);
@


1.33
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2006/11/29 12:26:14 miod Exp $	*/
d322 2
@


1.32
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2006/07/24 17:26:29 miod Exp $	*/
a59 23

volatile int whichqs;

/*
 * pagemove - moves pages at virtual address from to virtual address to,
 * block moved of size size. Using fast insn bcopy for pte move.
 */
void
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
{
	pt_entry_t *fpte, *tpte;
	int	stor;

	fpte = kvtopte(from);
	tpte = kvtopte(to);

	stor = (size >> VAX_PGSHIFT) * sizeof(pt_entry_t);
	bcopy(fpte, tpte, stor);
	bzero(fpte, stor);
	mtpr(0, PR_TBIA);
}
@


1.31
log
@Simplify ioaccess() by computing the pte template outside the loop, and
modify iounaccess() loop style accordingly for consistency.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2003/11/10 21:05:06 miod Exp $	*/
a247 17
}

/*
 * Kernel stack red zone need to be set when a process is swapped in.
 * Be sure that all pages are valid.
 */
void
cpu_swapin(p)
	struct proc *p;
{
	pt_entry_t *pte;
	int i;

	pte = kvtopte((vaddr_t)p->p_addr);
	for (i = 0; i < (USPACE/VAX_NBPG); i ++)
		pte[i] |= PG_V;
	*kvtopte((vaddr_t)p->p_addr + REDZONEADDR) &= ~PG_V;
@


1.30
log
@Get rid of the "struct pte" bitfield, and use straight integers.

Makes the code slightly more readble, removes casts, and makes some
specific constants defined for the bitfields disappear in pmap.c...

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2001/12/08 02:24:07 art Exp $	*/
d276 1
a276 2
	u_int *pte = (u_int *)kvtopte(vaddr);
	int i;
d278 3
a280 2
	for (i = 0; i < npgs; i++)
		pte[i] = PG_V | PG_KW | (PG_PFNUM(paddr) + i);
a292 1
	int i;
d294 2
a295 2
	for (i = 0; i < npgs; i++)
		pte[i] = 0;
@


1.29
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/11/17 05:07:55 hugh Exp $	*/
d78 1
a78 1
	stor = (size >> VAX_PGSHIFT) * sizeof(struct pte);
d144 1
a144 1
	kvtopte((u_int)p2->p_addr + REDZONEADDR)->pg_v = 0;
d258 1
a258 1
	struct pte *pte;
d263 2
a264 2
		pte[i].pg_v = 1;
	kvtopte((vaddr_t)p->p_addr + REDZONEADDR)->pg_v = 0;
@


1.28
log
@Pick up changes made in NetBSD to work with ubc.
Unbreaks art's mergings on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2001/11/06 23:57:54 miod Exp $	*/
d338 1
@


1.27
log
@Update and unbreak cpu_fork() - from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2001/11/06 18:41:10 art Exp $	*/
d252 1
d258 6
@


1.26
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2001/11/06 02:49:23 art Exp $	*/
d116 1
a116 2
	struct pte *pt;
	struct pcb *nyproc;
d118 2
a119 1
	struct pmap *pmap, *opmap;
d129 6
a134 8
	nyproc = &p2->p_addr->u_pcb;
	tf = p1->p_addr->u_pcb.framep;
	opmap = p1->p_vmspace->vm_map.pmap;
	pmap = p2->p_vmspace->vm_map.pmap;

	/* Mark page invalid */
	pt = kvtopte((u_int)p2->p_addr + REDZONEADDR);
	pt->pg_v = 0; 
d139 1
d143 26
a168 7
	/* Set up internal defs in PCB. */
	nyproc->iftrap = NULL;
	nyproc->KSP = (u_int)p2->p_addr + USPACE;

	/* General registers as taken from userspace */
	/* trapframe should be synced with pcb */
	bcopy(&tf->r2,&nyproc->R[2],10*sizeof(int));
d176 3
a178 46
	nyproc->AP = tf->ap;
	nyproc->FP = tf->fp;
	nyproc->USP = tf->sp;
	nyproc->PC = tf->pc;
	nyproc->PSL = tf->psl & ~PSL_C;
	nyproc->R[0] = p1->p_pid; /* parent pid. (shouldn't be needed) */
	nyproc->R[1] = 1;

	return; /* Child is ready. Parent, return! */
}

/*
 * cpu_set_kpc() sets up pcb for the new kernel process so that it will
 * start at the procedure pointed to by pc next time swtch() is called.
 * When that procedure returns, it will pop off everything from the
 * faked calls frame on the kernel stack, do an REI and go down to
 * user mode.
 */
void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	struct pcb *nyproc;
	struct {
		struct	callsframe cf;
		struct	trapframe tf;
	} *kc;
	extern int sret, boothowto;

	nyproc = &p->p_addr->u_pcb;
	(unsigned)kc = nyproc->FP = nyproc->KSP =
	    (unsigned)p->p_addr + USPACE - sizeof(*kc);
	kc->cf.ca_cond = 0;
	kc->cf.ca_maskpsw = 0x20000000;
	kc->cf.ca_pc = (unsigned)&sret;
	kc->cf.ca_argno = 1;
	kc->cf.ca_arg1 = (unsigned)arg;
	kc->tf.r11 = boothowto; /* If we have old init */
	kc->tf.psl = 0x3c00000;

	nyproc->framep = (void *)&kc->tf;
	nyproc->AP = (unsigned)&kc->cf.ca_argno;
	nyproc->FP = nyproc->KSP = (unsigned)kc;
	nyproc->PC = (unsigned)pc + 2;
@


1.25
log
@remove the last uses of vm/vm_page.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2001/09/21 02:11:58 miod Exp $	*/
d94 1
a94 2
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path will later be changed in cpu_set_kpc.
d109 1
a109 1
cpu_fork(p1, p2, stack, stacksize)
d113 2
@


1.24
log
@phys_map declaration comes from <vm/vm.h>, no need to declare it locally.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/09/19 20:50:57 mickey Exp $	*/
a44 3

#include <vm/vm.h>
#include <vm/vm_page.h>
@


1.23
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/07/25 13:25:33 art Exp $	*/
a318 2

extern vm_map_t phys_map;
@


1.22
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/06/08 08:09:33 art Exp $	*/
a46 1
#include <vm/vm_kern.h>
d48 2
@


1.21
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/05/05 21:26:42 art Exp $	*/
d355 1
a355 1
		    VM_PROT_READ|VM_PROT_WRITE, TRUE, VM_PROT_READ|VM_PROT_WRITE);
@


1.20
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/02/11 06:34:37 hugh Exp $	*/
d351 2
a352 2
		if ((pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map), faddr))
		  == FALSE)
@


1.19
log
@Pick up a NetBSD hack to attach Cheetah to vsbus as well as ibus.
High kludge factor, but the payoff is vsbus scsi for free.
Most of the work is by Michael Kukat and ragge, with a few other
synchronisations thrown in.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2000/10/09 23:11:57 bjc Exp $	*/
d344 1
a344 1
	faddr = trunc_page((vaddr_t)bp->b_saveaddr = bp->b_data);
@


1.18
log
@code to get asc* (ncr 53c9x) working; most of this from netbsd
also, write the correct stuff in cpu_coredump (vm_machdep.c)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2000/06/08 22:25:23 niklas Exp $	*/
d331 1
a331 1
#if VAX46 || VAX48 || VAX49
d338 2
a339 1
	    && vax_boardtype != VAX_BTYP_49)
d370 1
a370 1
#if VAX46 || VAX48 || VAX49
d375 2
a376 1
	    && vax_boardtype != VAX_BTYP_49)
@


1.17
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.17 2000/06/08 21:12:09 niklas Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.56 2000/01/20 22:19:00 sommerfeld Exp $	     */
d239 1
d249 6
a254 1
	bcopy(tf, &state, sizeof(struct md_coredump));
d300 1
d317 68
@


1.16
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 1999/08/17 10:32:18 niklas Exp $	*/
d38 1
@


1.15
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 2
a2 2
/*      $OpenBSD: vm_machdep.c,v 1.14 1999/01/10 13:34:19 niklas Exp $       */
/*      $NetBSD: vm_machdep.c,v 1.33 1997/07/06 22:38:22 ragge Exp $       */
a33 2
 /* All bugs are subject to removal without further notice */
		
d79 1
a79 1
	stor = (size >> PGSHIFT) * sizeof(struct pte);
a84 4
#define VIRT2PHYS(x) \
	(((*(int *)((((((int)x) & 0x7fffffff) >> 9) * 4) + \
		(unsigned int)Sysmap)) & 0x1fffff) << 9)

d86 16
d116 1
d121 8
d131 2
a132 3
	opmap = &p1->p_vmspace->vm_pmap;
	pmap = &p2->p_vmspace->vm_pmap;
	pmap->pm_pcb = nyproc;
a133 1
#ifdef notyet
d135 8
a142 3
	p2pte = kvtopte((u_int *)p2->p_addr + 2 * NBPG);
	*p2pte = 0; 
#endif
d144 1
a144 14
#ifdef notyet
	/* Set up internal defs in PCB, and alloc PTEs. */
	nyproc->P0BR = kmem_alloc_wait(pte_map,
	    (opmap->pm_pcb->P0LR & ~AST_MASK) * 4);
	nyproc->P1BR = kmem_alloc_wait(pte_map,
	    (0x800000 - (pmap->pm_pcb->P1LR * 4))) - 0x800000;
	nyproc->P0LR = opmap->pm_pcb->P0LR;
	nyproc->P1LR = opmap->pm_pcb->P1LR;
#else
	nyproc->P0BR = (void *)0x80000000;
	nyproc->P1BR = (void *)0x80000000;
	nyproc->P0LR = AST_PCB;
	nyproc->P1LR = 0x200000;
#endif
a166 1

d197 1
a197 1
	kc->tf.r11 = boothowto;	/* If we have old init */
a205 167
/*
 * Put in a process on the correct run queue based on it's priority
 * and set the bit corresponding to the run queue.
 */
void 
setrunqueue(p)
	struct proc *p;
{
	struct	prochd *q;
	int	knummer;

	if (p->p_back) 
		panic("sket sig i setrunqueue");

	knummer = (p->p_priority >> 2);
	bitset(knummer, whichqs);
	q = &qs[knummer];

	_insque(p, q);

	return;
}

/*
 * Remove a process from the run queue. If this is the last process
 * on that queue, clear the queue bit in whichqs.
 */
void
remrunqueue(p)
	struct proc *p;
{
	struct	proc *qp;
	int	bitnr;

	bitnr = (p->p_priority >> 2);
	if (bitisclear(bitnr, whichqs))
		panic("remrunqueue: Process not in queue");

	_remque(p);

	qp = (struct proc *)&qs[bitnr];
	if (qp->p_forw == qp)
		bitclear(bitnr, whichqs);
}

volatile caddr_t curpcb, nypcb;

/*
 * Machine dependent part of switch function. Find the next process 
 * with the highest priority to run. If the process queues are empty,
 * sleep waiting for something to happen. The idle loop resides here.
 */
void
cpu_switch(pp)
	struct proc *pp;
{
	int	i,s;
	struct	proc *p, *q;
	extern	unsigned int scratch;

again:	
	/* First: Search for a queue. */
	s = splhigh();
	if ((i = ffs(whichqs) - 1) < 0)
		goto idle;

	/*
	 * A queue with runnable processes found.
	 * Get first process from queue. 
	 */
	asm(".data;savpsl:	.long	0;.text;movpsl savpsl");
	q = (struct proc *)&qs[i];
	if (q->p_forw == q)
		panic("swtch: no process queued");

	/* Remove process from queue */
	bitclear(i, whichqs);
	p = q->p_forw;
	_remque(p);

	if (q->p_forw != q)
		bitset(i, whichqs);
	if (curproc)
		(u_int)curpcb = VIRT2PHYS(&curproc->p_addr->u_pcb);
	else
		(u_int)curpcb = scratch & 0x7fffffff;
	(u_int)nypcb = VIRT2PHYS(&p->p_addr->u_pcb);

	if (p == 0)
		panic("switch: null proc pointer");
	want_resched = 0;
	curproc = p;

	/* Don't change process if it's the same that we'r already running */
	if (curpcb == nypcb)
		return;

	asm("pushl savpsl");
	asm("jsb _loswtch");

	return; /* New process! */

idle:	
	p = curproc;
	curproc = NULL;		/* This is nice. /BQT */
	spl0();
	while (whichqs == 0)
		;
	curproc = p;
	goto again;
}

/* Should check that values is in bounds XXX */
int
copyinstr(from, to, maxlen, lencopied)
	const void *from;
	void *to;
	size_t *lencopied;
	size_t maxlen;
{
	u_int i;
	void *addr=&curproc->p_addr->u_pcb.iftrap;
	const char *gfrom = from;
	char *gto = to;

	asm("movl $Lstr,(%0)":: "r"(addr));
	for(i=0;i<maxlen;i++){
		*(gto +i )=*(gfrom + i);
		if(!(*(gto+i))) goto ok;
	}

	return(ENAMETOOLONG);
ok:
	if(lencopied) *lencopied=i+1;
	return(0);
}

asm("Lstr:	ret");

/* Should check that values is in bounds XXX */
int
copyoutstr(from, to, maxlen, lencopied)
	const	void *from;
	void	*to;
	size_t	*lencopied;
	size_t	maxlen;
{
	u_int i;
	const char *gfrom=from;
	char *gto=to;
        void *addr=&curproc->p_addr->u_pcb.iftrap;

        asm("movl $Lstr,(%0)":: "r"(addr));
	for(i=0;i<maxlen;i++){
		*(gto+i)=*(gfrom+i);
		if(!(*(gto+i))) goto ok;
	}

	return(ENAMETOOLONG);
ok:
	if(lencopied) *lencopied=i+1;
	return 0;
}

int	reno_zmagic __P((struct proc *, struct exec_package *));


d211 1
a211 22
	int error;
	struct exec *ep;
	/*
	 * Compatibility with reno programs.
	 */
	ep=epp->ep_hdr;
	switch (ep->a_midmag) {
	case 0x10b: /* ZMAGIC in 4.3BSD Reno programs */
		error = reno_zmagic(p, epp);
		break;
	case 0x108:
printf("Warning: reno_nmagic\n");
		error = exec_aout_prep_nmagic(p, epp);
		break;
	case 0x107:
printf("Warning: reno_omagic\n");
		error = exec_aout_prep_omagic(p, epp);
		break;
	default:
		error = ENOEXEC;
	}
	return(error);
a223 85
#ifdef COMPAT_ULTRIX
extern struct emul emul_ultrix;
#endif
/*
 * 4.3BSD Reno programs have an 1K header first in the executable
 * file, containing a.out header. Otherwise programs are identical.
 *
 *      from: exec_aout.c,v 1.9 1994/01/28 23:46:59 jtc Exp $
 */

int
reno_zmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	struct exec *execp = epp->ep_hdr;

	epp->ep_taddr = 0;
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = epp->ep_taddr + execp->a_text;
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

#ifdef COMPAT_ULTRIX
	epp->ep_emul = &emul_ultrix;
#endif

	/*
	 * check if vnode is in open for writing, because we want to
	 * demand-page out of it.  if it is, don't do it, for various
	 * reasons
	 */
	if ((execp->a_text != 0 || execp->a_data != 0) &&
	    epp->ep_vp->v_writecount != 0) {
		return ETXTBSY;
	}
	epp->ep_vp->v_flag |= VTEXT;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_text,
	    epp->ep_taddr, epp->ep_vp, 0x400, VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_data,
	    epp->ep_daddr, epp->ep_vp, execp->a_text+0x400,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, execp->a_bss,
	    epp->ep_daddr + execp->a_data, NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return exec_setup_stack(p, epp);
}

void
cpu_exit(p)
	struct	proc *p;
{
	extern	unsigned int scratch;

	if (p == 0)
		panic("cpu_exit from null process");
	vmspace_free(p->p_vmspace);

	(void) splimp();
	/* Must change kernel stack before freeing */
	mtpr(scratch + NBPG, PR_KSP);
	kmem_free(kernel_map, (vm_offset_t)p->p_addr, ctob(UPAGES));
	cpu_switch(0);
	/* NOTREACHED */
}

int
suword(ptr, val)
	void *ptr;
	long val;
{
        void *addr=&curproc->p_addr->u_pcb.iftrap;

        asm("movl $Lstr,(%0)":: "r"(addr));
	*(int *)ptr=val;
	return 0;
}

d242 1
a242 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_VAX, 0);
d249 1
a249 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_VAX, CORE_CPU);
d259 3
a261 3
        error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&state, sizeof(state),
            (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
            IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d263 2
a264 2
        if (!error)
                chdr->c_nseg++;
d266 1
a266 26
        return error;
}

int	locopyout __P((const void *, void *, size_t, void *));
int	locopyin __P((const void *, void *, size_t, void *));

int
copyout(from, to, len)
	const	void *from;
	void	*to;
	size_t	len;
{
	void *addr=&curproc->p_addr->u_pcb.iftrap;

	return locopyout(from, to, len, addr);
}

int
copyin(from, to, len)
	const	void *from;
	void	*to;
	size_t	len;
{
	void *addr = &curproc->p_addr->u_pcb.iftrap;

	return locopyin(from, to, len, addr);
d270 1
a270 5
 * cpu_swapin() is called just before a process shall be swapped in.
 * Kernel stack and pcb must be mapped when we swtch() to this new
 * process, to guarantee that we frob all pages here to ensure that
 * they actually are in-core. Kernel stack red zone is also updated
 * here.
d276 1
a276 17
	u_int uarea, i, *j, rv;

	uarea = (u_int)p->p_addr;

	for (i = uarea;i < uarea + USPACE;i += PAGE_SIZE) {
		j = (u_int *)kvtopte(i);
		if ((*j & PG_V) == 0) {
			rv = vm_fault(kernel_map, i,
			    VM_PROT_WRITE|VM_PROT_READ, FALSE);
			if (rv != KERN_SUCCESS)
				panic("cpu_swapin: rv %d",rv);
		}
	}
#ifdef notyet
	j = (u_int *)kvtopte(uarea + 2 * NBPG);
	*j = 0; /* Set kernel stack red zone */
#endif
a278 1
#if VAX410 || VAX43
d280 1
a280 3
 * vmapbuf()/vunmapbuf() only used on some vaxstations without
 * any busadapter with MMU.
 * XXX - This must be reworked to be effective.
d283 4
a286 3
vmapbuf(bp, len)
        struct buf *bp;
        vm_size_t len;
d288 2
a289 2
        vm_offset_t faddr, taddr, off, pa;
        pmap_t fmap, tmap;
d291 2
a292 22
	if ((vax_boardtype != VAX_BTYP_43) && (vax_boardtype != VAX_BTYP_410))
		return;
        faddr = trunc_page(bp->b_saveaddr = bp->b_data);
        off = (vm_offset_t)bp->b_data - faddr;
        len = round_page(off + len);
        taddr = kmem_alloc_wait(phys_map, len);
        bp->b_data = (caddr_t)(taddr + off);
        fmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
        tmap = vm_map_pmap(phys_map);
        len = len >> PGSHIFT;
        while (len--) {
		volatile int i = *(int *)faddr;

                pa = pmap_extract(fmap, faddr);
                if (pa == 0)
                       	panic("vmapbuf: null page frame for %x", faddr);

                pmap_enter(tmap, taddr, pa & ~(NBPG - 1),
                           VM_PROT_READ|VM_PROT_WRITE, TRUE);
                faddr += NBPG;
                taddr += NBPG;
        }
d296 1
a296 2
 * Free the io map PTEs associated with this IO operation.
 * We also invalidate the TLB entries and restore the original b_addr.
d299 3
a301 3
vunmapbuf(bp, len)
        struct buf *bp;
        vm_size_t len;
d303 2
a304 1
        vm_offset_t addr, off;
d306 3
a308 8
	if ((vax_boardtype != VAX_BTYP_43) && (vax_boardtype != VAX_BTYP_410))
		return;
        addr = trunc_page(bp->b_data);
        off = (vm_offset_t)bp->b_data - addr;
        len = round_page(off + len);
        kmem_free_wakeup(phys_map, addr, len);
        bp->b_data = bp->b_saveaddr;
        bp->b_saveaddr = 0;
a309 1
#endif
@


1.15.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/02/11 06:34:37 hugh Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.67 2000/06/29 07:14:34 mrg Exp $	     */
d34 2
a39 1
#include <sys/signalvar.h>
d81 1
a81 1
	stor = (size >> VAX_PGSHIFT) * sizeof(struct pte);
d87 4
a91 16
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the pcb and trap frame, making the child ready to run.
 * 
 * Rig the child's kernel stack so that it will start out in
 * proc_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
 *
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path will later be changed in cpu_set_kpc.
 *
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
 * accordingly.
 *
a105 1
	struct pte *pt;
a109 8
#ifdef DIAGNOSTIC
	/*
	 * if p1 != curproc && p1 == &proc0, we're creating a kernel thread.
	 */
	if (p1 != curproc && p1 != &proc0)
		panic("cpu_fork: curproc");
#endif

d112 3
a114 2
	opmap = p1->p_vmspace->vm_map.pmap;
	pmap = p2->p_vmspace->vm_map.pmap;
d116 1
d118 3
a120 2
	pt = kvtopte((u_int)p2->p_addr + REDZONEADDR);
	pt->pg_v = 0; 
d122 14
a135 7
	/*
	 * Activate address space for the new process.	The PTEs have
	 * already been allocated by way of pmap_create().
	 */
	pmap_activate(p2);

	/* Set up internal defs in PCB. */
d158 1
d189 1
a189 1
	kc->tf.r11 = boothowto; /* If we have old init */
d198 167
d370 22
a391 1
	return ENOEXEC;
d404 85
a502 1
	struct reg *regs = &state.md_reg;
d507 1
a507 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
d512 1
a512 6
	bcopy(&tf->r0, &regs->r0, 12 * sizeof(int));
	regs->ap = tf->ap;
	regs->fp = tf->fp;
	regs->sp = tf->sp;
	regs->pc = tf->pc;
	regs->psl = tf->psl;
d514 1
a514 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
d524 3
a526 3
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&state, sizeof(state),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d528 2
a529 2
	if (!error)
		chdr->c_nseg++;
d531 1
a531 1
	return error;
d534 8
a541 6
/*
 * Kernel stack red zone need to be set when a process is swapped in.
 */
void
cpu_swapin(p)
	struct proc *p;
d543 3
a545 1
	kvtopte((vaddr_t)p->p_addr + REDZONEADDR)->pg_v = 0;
d548 5
a552 8
/*
 * Map in a bunch of pages read/writeable for the kernel.
 */
void
ioaccess(vaddr, paddr, npgs)
	vaddr_t vaddr;
	paddr_t paddr;
	int npgs;
d554 1
a554 2
	u_int *pte = (u_int *)kvtopte(vaddr);
	int i;
d556 1
a556 3
	for (i = 0; i < npgs; i++)
		pte[i] = PG_V | PG_KW | (PG_PFNUM(paddr) + i);
	mtpr(0, PR_TBIA);
d560 5
a564 1
 * Opposite to the above: just forget their mapping.
d567 2
a568 3
iounaccess(vaddr, npgs)
	vaddr_t vaddr;
	int npgs;
d570 1
a570 2
	u_int *pte = (u_int *)kvtopte(vaddr);
	int i;
d572 15
a586 3
	for (i = 0; i < npgs; i++)
		pte[i] = 0;
	mtpr(0, PR_TBIA);
d589 1
a589 2
extern vm_map_t phys_map;

d591 3
a593 3
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().
d597 2
a598 2
	struct buf *bp;
	vsize_t len;
d600 2
a601 4
#if VAX46 || VAX48 || VAX49 || VAX53
	vaddr_t faddr, taddr, off;
	paddr_t pa;
	struct proc *p;
d603 1
a603 4
	if (vax_boardtype != VAX_BTYP_46
	    && vax_boardtype != VAX_BTYP_48
	    && vax_boardtype != VAX_BTYP_49
	    && vax_boardtype != VAX_BTYP_1303)
d605 20
a624 19
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
	p = bp->b_proc;
	faddr = trunc_page((vaddr_t)bp->b_saveaddr = bp->b_data);
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(taddr + off);
	len = atop(len);
	while (len--) {
		if ((pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map), faddr))
		  == FALSE)
			panic("vmapbuf: null page frame");
		pmap_enter(vm_map_pmap(phys_map), taddr, trunc_page(pa),
		    VM_PROT_READ|VM_PROT_WRITE, TRUE, VM_PROT_READ|VM_PROT_WRITE);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
	}
#endif
d628 2
a629 1
 * Unmap a previously-mapped user I/O request.
d633 2
a634 2
	struct buf *bp;
	vsize_t len;
d636 1
a636 2
#if VAX46 || VAX48 || VAX49 || VAX53
	vaddr_t addr, off;
d638 1
a638 4
	if (vax_boardtype != VAX_BTYP_46
	    && vax_boardtype != VAX_BTYP_48
	    && vax_boardtype != VAX_BTYP_49
	    && vax_boardtype != VAX_BTYP_1303)
d640 7
a646 8
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
a647 1
}
@


1.15.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15.4.1 2001/05/14 21:39:13 niklas Exp $	*/
d344 1
a344 1
	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
d351 2
a352 2
		if (pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map), faddr,
				&pa) == FALSE)
@


1.15.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15.4.2 2001/07/04 10:24:49 niklas Exp $	*/
d47 1
a49 2
#include <uvm/uvm_extern.h>

d319 2
d355 1
a355 1
		    VM_PROT_READ|VM_PROT_WRITE, VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.15.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 3
d97 2
a98 1
 * p1 is the process being forked;
d113 1
a113 1
cpu_fork(p1, p2, stack, stacksize, func, arg)
a116 2
	void (*func)(void *);
	void *arg;
d118 2
a119 1
	struct pcb *pcb;
d121 1
a121 2
	struct callsframe *cf;
	extern int sret; /* Return address in trap routine */
d131 8
a138 6
	/*
	 * Copy the trap frame.
	 */
	tf = (struct trapframe *)((u_int)p2->p_addr + USPACE) - 1;
	p2->p_addr->u_pcb.framep = tf;
	bcopy(p1->p_addr->u_pcb.framep, tf, sizeof(*tf));
a142 1
	 * This writes the page table registers to the PCB.
d146 7
a152 26
	/* Mark guard page invalid in kernel stack */
	kvtopte((u_int)p2->p_addr + REDZONEADDR)->pg_v = 0;

	/*
	 * Set up the calls frame above (below) the trapframe
	 * and populate it with something good.
	 * This is so that we can simulate that we were called by a
	 * CALLS insn in the function given as argument.
	 */
	cf = (struct callsframe *)tf - 1;
	cf->ca_cond = 0;
	cf->ca_maskpsw = 0x20000000;	/* CALLS stack frame, no registers */
	cf->ca_pc = (unsigned)&sret;	/* return PC; userspace trampoline */
	cf->ca_argno = 1;
	cf->ca_arg1 = (int)arg;

	/*
	 * Set up internal defs in PCB. This matches the "fake" CALLS frame
	 * that we constructed earlier.
	 */
	pcb = &p2->p_addr->u_pcb;
	pcb->iftrap = NULL;
	pcb->KSP = (long)cf;
	pcb->FP = (long)cf;
	pcb->AP = (long)&cf->ca_argno;
	pcb->PC = (int)func + 2;	/* Skip save mask */
d160 46
a205 3
	tf->r0 = p1->p_pid; /* parent pid. (shouldn't be needed) */
	tf->r1 = 1;
	tf->psl = PSL_U|PSL_PREVU;
@


1.15.4.5
log
@Merge in trunk
@
text
@a330 1
	pmap_update(vm_map_pmap(phys_map));
@


1.15.4.6
log
@manually merge stuff cvs missed long ago
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2001/12/08 02:24:07 art Exp $	*/
a251 1
 * Be sure that all pages are valid.
a256 6
	struct pte *pte;
	int i;

	pte = kvtopte((vaddr_t)p->p_addr);
	for (i = 0; i < (USPACE/VAX_NBPG); i ++)
		pte[i].pg_v = 1;
@


1.15.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
	stor = (size >> VAX_PGSHIFT) * sizeof(pt_entry_t);
d144 1
a144 1
	*kvtopte((u_int)p2->p_addr + REDZONEADDR) &= ~PG_V;
d258 1
a258 1
	pt_entry_t *pte;
d263 2
a264 2
		pte[i] |= PG_V;
	*kvtopte((vaddr_t)p->p_addr + REDZONEADDR) &= ~PG_V;
@


1.14
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: vm_machdep.c,v 1.13 1998/07/28 00:13:56 millert Exp $       */
d101 1
a101 1
cpu_fork(p1, p2)
d103 2
d142 7
@


1.13
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*      $OpenBSD: vm_machdep.c,v 1.12 1997/10/08 07:15:57 niklas Exp $       */
d160 1
a160 1
cpu_set_kpc(p, pc)
d162 2
a163 1
	void (*pc) __P((struct proc *));
d179 1
a179 1
	kc->cf.ca_arg1 = (unsigned)p;
@


1.12
log
@Style nit
@
text
@d1 1
a1 1
/*      $OpenBSD: vm_machdep.c,v 1.11 1997/09/12 09:30:57 maja Exp $       */
d510 1
a510 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
d516 1
a516 1
            IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
@


1.11
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*      $OpenBSD: vm_machdep.c,v 1.10 1997/09/10 12:04:53 maja Exp $       */
d251 1
a251 1
	if ((i = ffs(whichqs) -1 ) < 0)
@


1.10
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*      $OpenBSD: vm_machdep.c,v 1.9 1997/05/28 23:31:16 niklas Exp $       */
/*      $NetBSD: vm_machdep.c,v 1.31 1997/03/09 16:00:06 ragge Exp $       */
d291 2
d296 1
@


1.9
log
@use exec_setup_stack instead
@
text
@d1 2
a2 2
/*      $OpenBSD: vm_machdep.c,v 1.30 1997/01/11 11:23:09 ragge Exp $       */
/*      $NetBSD: vm_machdep.c,v 1.30 1997/01/11 11:23:09 ragge Exp $       */
d601 2
d605 2
a606 1
                        panic("vmapbuf: null page frame for %x", faddr);
@


1.8
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
d443 1
a443 1
	return exec_aout_setup_stack(p, epp);
@


1.7
log
@remrq -> remrunqueue
@
text
@d1 1
a1 1
/*      $NetBSD: vm_machdep.c,v 1.25 1996/05/19 16:44:33 ragge Exp $       */
d59 1
d299 4
a302 2
	void *from, *to;
	u_int *lencopied,maxlen;
d306 2
a307 1
	char *gfrom=from, *gto=to;
d311 1
a311 1
		*(gto+i)=*(gfrom+i);
d326 4
a329 2
	void *from, *to;
	u_int *lencopied,maxlen;
d332 2
a333 1
	char *gfrom=from, *gto=to;
d520 2
a521 2
int	locopyout __P((void *, void *, size_t, void *));
int	locopyin __P((void *, void *, size_t, void *));
d525 3
a527 2
	void *from, *to;
	size_t len;
d536 3
a538 2
	void *from, *to;
	size_t len;
d574 57
@


1.6
log
@sync to 0611
@
text
@d214 1
a214 1
remrq(p)
d222 1
a222 1
		panic("remrq: Process not in queue");
@


1.5
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*      $NetBSD: vm_machdep.c,v 1.24 1996/04/08 18:33:01 ragge Exp $       */
d44 1
a44 1
#include <sys/cpu.h>
@


1.4
log
@from ragge;
save usp when trapping from userspace
change register save structs according to this
handle old init register passing convention
@
text
@d1 1
a1 1
/*      $NetBSD: vm_machdep.c,v 1.19 1996/01/28 12:22:49 ragge Exp $       */
a2 1
#undef SWDEBUG
d35 24
a58 19
#include "sys/types.h"
#include "sys/param.h"
#include "sys/proc.h"
#include "sys/user.h"
#include "sys/exec.h"
#include "sys/vnode.h"
#include "sys/core.h"
#include "sys/mount.h"
#include "vm/vm.h"
#include "vm/vm_kern.h"
#include "vm/vm_page.h"
#include "machine/vmparam.h"
#include "machine/mtpr.h"
#include "machine/pmap.h"
#include "machine/pte.h"
#include "machine/macros.h"
#include "machine/trap.h"
#include "machine/pcb.h"
#include "machine/frame.h"
d71 1
a71 1
	int size;
d86 2
a87 2
	(((*(int *)((((((int)x)&0x7fffffff)>>9)*4)+ \
		(unsigned int)Sysmap))&0x1fffff)<<9)
d98 1
a98 1
int
a104 2
	u_int *p2pte;
	extern vm_map_t pte_map;
d127 1
a127 1
	nyproc->P0BR = (void *)0;
d146 1
a146 1
	return 0; /* Child is ready. Parent, return! */
d159 2
a160 2
        struct proc *p;
        u_int pc;
d183 1
a183 1
	nyproc->PC = pc + 2;
d186 4
d194 2
a195 2
	struct prochd *q;
	int knummer;
d197 2
a198 5
	if(p->p_back) 
		panic("sket sig i setrunqueue\n");
	knummer=(p->p_priority>>2);
	bitset(knummer,whichqs);
	q=&qs[knummer];
d200 5
a204 1
	_insque(p,q);
d209 4
d217 2
a218 2
	struct proc *qp;
	int bitnr;
d220 3
a222 3
	bitnr=(p->p_priority>>2);
	if(bitisclear(bitnr,whichqs))
		panic("remrq: Process not in queue\n");
d226 3
a228 3
	qp=(struct proc *)&qs[bitnr];
	if(qp->p_forw==qp)
		bitclear(bitnr,whichqs);
d231 1
a231 1
volatile caddr_t curpcb,nypcb;
d233 18
a250 5
cpu_switch(){
	int i,j,s;
	struct proc *p;
	volatile struct proc *q;
	extern unsigned int want_resched,scratch;
d252 4
a255 6
hej:	
	/* F|rst: Hitta en k|. */
	s=splhigh();
	if((i=ffs(whichqs)-1)<0) goto idle;

found:
d257 2
a258 2
	q=(struct proc *)&qs[i];
	if(q->p_forw==q)
d261 3
a263 2
	bitclear(i,whichqs);
	p=q->p_forw;
d266 16
a281 9
	if(q->p_forw!=q) bitset(i,whichqs);
	if(curproc) (u_int)curpcb=VIRT2PHYS(&curproc->p_addr->u_pcb);
	else (u_int)curpcb=scratch;
	(u_int)nypcb=VIRT2PHYS(&p->p_addr->u_pcb);

	if(!p) panic("switch: null proc pointer\n");
	want_resched=0;
	curproc=p;
	if(curpcb==nypcb) return;
d290 3
a292 2
	while(!whichqs);
	goto hej;
d296 1
d298 2
a299 2
void *from, *to;
u_int *lencopied,maxlen;
d320 1
d322 2
a323 2
void *from, *to;
u_int *lencopied,maxlen;
d341 4
d351 3
a353 3
/*
 * Compatibility with reno programs.
 */
d440 1
a440 1
	struct proc *p;
d442 1
a442 1
	extern unsigned int scratch;
d444 2
a445 1
	if(!p) panic("cpu_exit from null process");
d449 2
a450 1
	mtpr(scratch+NBPG,PR_KSP);/* Must change kernel stack before freeing */
d452 1
a452 1
	cpu_switch();
d456 2
a457 1
suword(ptr,val)
d459 1
a459 1
	int val;
d513 4
d519 1
d526 1
d529 1
d531 1
a531 1
	void *addr=&curproc->p_addr->u_pcb.iftrap;
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*      $NetBSD: vm_machdep.c,v 1.18 1995/12/13 18:47:59 ragge Exp $       */
d54 1
a129 1
	nyproc->USP = mfpr(PR_USP);
d138 1
d162 2
a163 9
		u_int	chand;
		u_int	mask;
		u_int	ap;
		u_int	fp;
		u_int	pc;
		u_int	nargs;
		u_int	pp;
		u_int	rpc;
		u_int	rpsl;
d165 1
a165 9
	extern int rei;

	kc = (void *)p->p_addr + USPACE - sizeof(*kc);
	kc->chand = 0;
	kc->mask = 0x20000000;
	kc->pc = (u_int)&rei;
	kc->nargs = 1;
	kc->pp = (u_int)p;
	kc->rpsl = 0x3c00000;
d168 13
a180 3
	nyproc->framep = (void *)p->p_addr + USPACE - sizeof(struct trapframe);
	nyproc->AP = (u_int)&kc->nargs;
	nyproc->FP = nyproc->KSP = (u_int)kc;
a451 1
	state.md_tf.code = mfpr(PR_USP); /* XXX */
d504 1
a504 1
	for(i = uarea;i < uarea + USPACE;i += PAGE_SIZE) {
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*      $NetBSD: vm_machdep.c,v 1.17 1995/11/10 19:07:16 ragge Exp $       */
d68 2
a69 1
	u_int *fpte, *tpte,stor;
d74 4
a77 4
	stor = (size/NBPG) * sizeof(struct pte);
	bcopy(fpte,tpte,stor);
	bzero(fpte,stor);
	mtpr(0,PR_TBIA);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: vm_machdep.c,v 1.16.2.1 1995/10/15 14:01:06 ragge Exp $       */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
