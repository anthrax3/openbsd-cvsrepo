head	1.16;
access;
symbols
	OPENBSD_5_9:1.15.0.6
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.12
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.8
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.6
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.8.0.26
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.24
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.22
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.20
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.18
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.16
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.14
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.12
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.10
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.15;
commitid	OSDG2O3Cgeifnf1W;

1.15
date	2014.05.17.12.13.44;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.19.21.53.02;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2011.09.15.00.48.24;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2011.08.31.21.32.44;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.06.20.42.05;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.15.22.38.23;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.21.19.28.51;	author hugh;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.10.01.12.57.19;	author hugh;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.01.19.17.38;	author hugh;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.02.25.15.55.27;	author hugh;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.01.10.10;	author bjc;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.21.38.57;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: ka48.c,v 1.15 2014/05/17 12:13:44 miod Exp $	*/
/*
 * Copyright (c) 1998 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * This code is derived from software contributed to Ludd by Bertram Barth.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed at Ludd, University of 
 *	Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*** needs to be completed MK-990306 ***/

#include <sys/param.h>
#include <sys/types.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/pmap.h>
#include <machine/uvax.h>
#include <machine/ka410.h>
#include <machine/ka420.h>
#include <machine/ka48.h>
#include <machine/clock.h>
#include <machine/vsbus.h>

static	void	ka48_conf(void);
static	void	ka48_init(void);
static	void	ka48_memerr(void);
static	int	ka48_mchk(caddr_t);
static	void	ka48_halt(void);
static	void	ka48_reboot(int);
static	void	ka48_cache_enable(void);
static	void	ka48_hardclock(struct clockframe *);

struct	vs_cpu *ka48_cpu;

/* 
 * Declaration of 48-specific calls.
 */
struct	cpu_dep ka48_calls = {
	ka48_init,
	ka48_mchk,
	ka48_memerr, 
	ka48_conf,
	chip_clkread,
	chip_clkwrite,
	4,      /* ~VUPS */
	2,	/* SCB pages */
	ka48_halt,
	ka48_reboot,
	NULL,
	ka48_hardclock
};


void
ka48_conf()
{
	char *cpuname;
	switch (vax_cpustype) {
	case VAX_STYP_45:
		cpuname = "KA45";
		break;
	case VAX_STYP_48:
		cpuname = "KA48";
		break;
	default:
		cpuname = "Unknown SOC";
	}
	printf("cpu: %s\n", cpuname);
	ka48_cpu = (void *)vax_map_physmem(VS_REGS, 1);
	/*
	 * Setup parameters necessary to read time from clock chip.
	 */
	clk_adrshift = 1;       /* Addressed at long's... */
	clk_tweak = 2;          /* ...and shift two */
	clk_page = (short *)vax_map_physmem(VS_CLOCK, 1);
}

void
ka48_cache_enable()
{
	int i, *tmp;
	long *par_ctl = (long *)KA48_PARCTL;

	/* Disable cache */
	mtpr(0, PR_CADR);		/* disable */
	*par_ctl &= ~KA48_PARCTL_INVENA;	/* clear ? invalid enable */
	mtpr(2, PR_CADR);		/* flush */

	/* Clear caches */
	tmp = (void *)KA48_INVFLT;	/* inv filter */
	for (i = 0; i < KA48_INVFLTSZ / sizeof(int); i++)
		tmp[i] = 0;
	*par_ctl |= KA48_PARCTL_INVENA;	/* Enable ???? */
	mtpr(4, PR_CADR);		/* enable cache */
	*par_ctl |= (KA48_PARCTL_AGS |	/* AGS? */
	    KA48_PARCTL_NPEN |		/* N? Parity Enable */
	    KA48_PARCTL_CPEN);		/* Cpu parity enable */
}

void
ka48_memerr()
{
	printf("Memory err!\n");
}

int
ka48_mchk(addr)
	caddr_t addr;
{
	panic("Machine check");
	return 0;
}

void
ka48_init()
{
	/* Turn on caches (to speed up execution a bit) */
	ka48_cache_enable();
}

#define	KA48_CPMBX	0x38
#define	KA48_HLT_HALT	0xcf	/* 11001111 */
#define	KA48_HLT_BOOT	0x8b	/* 10001011 */

static void
ka48_halt()
{
	if (((u_int8_t *) clk_page)[KA48_CPMBX] != KA48_HLT_HALT)
		((u_int8_t *) clk_page)[KA48_CPMBX] = KA48_HLT_HALT;
	asm("halt");
}

static void
ka48_reboot(arg)
	int arg;
{
	if (((u_int8_t *) clk_page)[KA48_CPMBX] != KA48_HLT_BOOT)
		((u_int8_t *) clk_page)[KA48_CPMBX] = KA48_HLT_BOOT;
	asm("halt");
}

static void
ka48_hardclock(struct clockframe *cf)
{
	ka48_cpu->vc_diagtimu = 0;
	hardclock(cf);
}
@


1.15
log
@Lower VUPS value for delay() to behave closer to the intent.

This is temporary until vax grows code to compute a proper delay const
at runtime, but will help a bit, especially on KA46 where cd(4) end up
detected as sd(4) due to too short delays.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.14 2011/09/19 21:53:02 miod Exp $	*/
@


1.14
log
@Try and clean system type constants a bit:
- save the second byte of vax_siedata into a new variable, vax_cpustype,
  and use it instead of (vax_siedata >> 8) & 0xff or other similar
  constructs.
- the VAX_SIE_KAxxx constants are duplicates of the VAX_STYP_xx constants.
  Standardize on the latter and kill the former.
- only keep VAX_VTYP_xx constants for KA46 and KA47, those are the only
  systems which use these constants and are told apart by a different
  SIE byte.

No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.13 2011/09/15 00:48:24 miod Exp $	*/
d78 1
a78 1
	6,      /* ~VUPS */
@


1.13
log
@Switch vax to timecounters. There are three different clock sources:
- ICR/NICR on most systems (1MHz counter resolution).
- diagnostic timer on KA46/KA48 (1kHz counter resolution, counter is actually
  running at around 1024 kHz but is not guaranteed to be monotonic at this
  rate).
- 100Hz clock on VXT (nothing but the 100Hz clock interrupt).

Tested on KA49 (ICR style), KA46, KA48 (diagtmr style), VXT2000+ (VXT
{empty,hopeless}ness'r'us style).
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.12 2011/08/31 21:32:44 miod Exp $	*/
d91 1
a91 1
	switch((vax_siedata >> 8) & 0xFF) {
@


1.12
log
@Don't pretend to `enable floating point' and fiddle with PR_ACCS register on
KA45 and KA48. The FPU is built-in, and PR_ACCS is not implemented (as the
PROM will tell you if you try to EX it). This was copied from KA46 and for
some reason KA45 and KA48 ignore writes to PR_ACCS (unlike VXT which hangs).

Tested on KA45 and KA48.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.11 2011/07/06 20:42:05 miod Exp $	*/
d64 1
d83 1
a83 1
	hardclock
d173 7
@


1.11
log
@Drop cpu_dep.cpu_subconf routine, which is no longer used after KA820 support
removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.10 2008/08/18 23:05:38 miod Exp $	*/
a101 2
	printf("cpu: turning on floating point chip\n");
	mtpr(2, PR_ACCS); /* Enable floating points */
@


1.10
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.9 2008/08/15 22:38:23 miod Exp $	*/
a49 1
#include <machine/nexus.h>
a80 1
	NULL,
@


1.9
log
@Rename the cpu_dep hook ``steal_pages'' to ``init'', as it serves as an
early initialization routine (to enable caches, etc) while still running
physical, and does not allocate memory anymore.

(The irony in this is that forthcoming KA60 support actually steals pages
 in its init function...)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.8 2002/07/21 19:28:51 hugh Exp $	*/
d82 3
@


1.8
log
@Support OS selectable halt action on the VAXstation 4000's.
Info from NetBSD, testing by pval and millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.7 2002/03/14 01:26:48 millert Exp $	*/
d59 1
a59 1
static	void	ka48_steal_pages(void);
d72 1
a72 1
	ka48_steal_pages,
d148 1
a148 1
ka48_steal_pages()
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.6 2001/11/06 19:53:17 miod Exp $	*/
d154 4
d161 2
d170 2
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.5 2001/10/01 12:57:19 hugh Exp $	*/
d58 7
a64 7
static	void	ka48_conf __P((void));
static	void	ka48_steal_pages __P((void));
static	void	ka48_memerr __P((void));
static	int	ka48_mchk __P((caddr_t));
static	void	ka48_halt __P((void));
static	void	ka48_reboot __P((int));
static	void	ka48_cache_enable __P((void));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.6 2001/11/06 19:53:17 miod Exp $	*/
d58 7
a64 7
static	void	ka48_conf(void);
static	void	ka48_steal_pages(void);
static	void	ka48_memerr(void);
static	int	ka48_mchk(caddr_t);
static	void	ka48_halt(void);
static	void	ka48_reboot(int);
static	void	ka48_cache_enable(void);
@


1.6.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.6.2.1 2002/06/11 03:39:19 art Exp $	*/
a153 4
#define	KA48_CPMBX	0x38
#define	KA48_HLT_HALT	0xcf	/* 11001111 */
#define	KA48_HLT_BOOT	0x8b	/* 10001011 */

a156 2
	if (((u_int8_t *) clk_page)[KA48_CPMBX] != KA48_HLT_HALT)
		((u_int8_t *) clk_page)[KA48_CPMBX] = KA48_HLT_HALT;
a163 2
	if (((u_int8_t *) clk_page)[KA48_CPMBX] != KA48_HLT_BOOT)
		((u_int8_t *) clk_page)[KA48_CPMBX] = KA48_HLT_BOOT;
@


1.5
log
@consistent casing
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.4 2001/09/11 20:05:25 miod Exp $	*/
d43 1
a43 1
#include <vm/vm.h>
@


1.4
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.3 2001/04/01 19:17:38 hugh Exp $	*/
d97 1
a97 1
		cpuname = "unknown SOC";
@


1.3
log
@Print KA48 or KA45 as appropriate. Someone with a 4000/vlc or 3100/{3,4}0
could test this in the next snapshot.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.2 2001/02/25 15:55:27 hugh Exp $	*/
a43 1
#include <vm/vm_kern.h>
@


1.3.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.3 2001/04/01 19:17:38 hugh Exp $	*/
@


1.3.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.3.4.1 2001/05/14 21:38:57 niklas Exp $	*/
d44 1
d98 1
a98 1
		cpuname = "Unknown SOC";
@


1.3.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
#include <uvm/uvm_extern.h>
@


1.3.4.4
log
@Merge in -current from about a week ago
@
text
@d58 7
a64 7
static	void	ka48_conf(void);
static	void	ka48_steal_pages(void);
static	void	ka48_memerr(void);
static	int	ka48_mchk(caddr_t);
static	void	ka48_halt(void);
static	void	ka48_reboot(int);
static	void	ka48_cache_enable(void);
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@a153 4
#define	KA48_CPMBX	0x38
#define	KA48_HLT_HALT	0xcf	/* 11001111 */
#define	KA48_HLT_BOOT	0x8b	/* 10001011 */

a156 2
	if (((u_int8_t *) clk_page)[KA48_CPMBX] != KA48_HLT_HALT)
		((u_int8_t *) clk_page)[KA48_CPMBX] = KA48_HLT_HALT;
a163 2
	if (((u_int8_t *) clk_page)[KA48_CPMBX] != KA48_HLT_BOOT)
		((u_int8_t *) clk_page)[KA48_CPMBX] = KA48_HLT_BOOT;
@


1.2
log
@Code to enable the cache on VS4000/VLC. From mhitch@@netbsd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka48.c,v 1.1 2000/04/27 01:10:10 bjc Exp $	*/
d89 12
a100 1
	printf("cpu: KA48\n");
@


1.1
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d105 1
a105 1
	return; /*** not yet MK-990306 ***/
d107 4
a110 4
	/* Disable caches */
	*(int *)KA48_CCR &= ~CCR_SPECIO;/* secondary */
	mtpr(PCSTS_FLUSH, PR_PCSTS);	/* primary */
	*(int *)KA48_BWF0 &= ~BWF0_FEN; /* invalidate filter */
d114 1
a114 1
	for (i = 0; i < 32768; i++)
d116 5
a120 16

	/* Write valid parity to all primary cache entries */
	for (i = 0; i < 256; i++) {
		mtpr(i << 3, PR_PCIDX);
		mtpr(PCTAG_PARITY, PR_PCTAG);
	}

	/* Secondary cache */
	tmp = (void *)KA48_TAGST;
	for (i = 0; i < KA48_TAGSZ*2; i+=2)
		tmp[i] = 0;

	/* Enable cache */
	*(int *)KA48_BWF0 |= BWF0_FEN; /* invalidate filter */
	mtpr(PCSTS_ENABLE, PR_PCSTS);
	*(int *)KA48_CCR = CCR_SPECIO | CCR_CENA;
@

