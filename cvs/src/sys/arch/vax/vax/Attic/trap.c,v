head	1.58;
access;
symbols
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.55.0.6
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.47.0.2
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.14
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.10
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.12
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.8
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.6
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.34.0.4
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.25
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.57;
commitid	OSDG2O3Cgeifnf1W;

1.57
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.56;
commitid	hnv9KfQtxhCytAnd;

1.56
date	2015.09.13.12.30.52;	author miod;	state Exp;
branches;
next	1.55;
commitid	e6GBWadagvYbXux5;

1.55
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.54;
commitid	Fn841MmVYz2JHvBP;

1.54
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	yv0ECmCdICvq576h;

1.53
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2014.03.30.21.54.49;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.24.22.08.25;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2013.07.13.17.28.36;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2012.08.08.04.11.09;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2012.08.07.05.16.54;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2012.04.23.19.04.07;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.42;

1.42
date	2011.11.16.20.50.19;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2010.11.27.18.04.23;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.16.05.19.15;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.01.09.29.27;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.24.20.29.19;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.30.21.26.19;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.23.19.49.00;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.15.21.14.27;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.15.21.09.30;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.06.17.09.10;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.06.20.12.25;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.09.22.29.01;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.27.23.05.41;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.16.16.54.17;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.23.03.03.15;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.16.21.11.19;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.16.07.37.44;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.03.16.02;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.28.16.13.29;	author art;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.06.23.57.54;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.02.49.23;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.14.14.57.43;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.05.21.26.41;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.10.18.15.43;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.27.01.10.14;	author bjc;	state Exp;
branches;
next	1.11;

1.11
date	99.01.11.05.12.08;	author millert;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	98.05.11.16.19.13;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.10.08.07.12.08;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.09.12.09.30.57;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.05.28.23.29.43;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.25.24;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.06.12.08.20.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.09.10.26;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.31.05.12.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2001.05.14.21.39.12;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.07.04.10.24.46;	author niklas;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.11.6.5;

1.11.6.5
date	2002.03.28.11.26.47;	author niklas;	state Exp;
branches;
next	1.11.6.6;

1.11.6.6
date	2002.03.30.08.27.12;	author niklas;	state Exp;
branches;
next	1.11.6.7;

1.11.6.7
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.11.6.8;

1.11.6.8
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.11.6.9;

1.11.6.9
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	1.11.6.10;

1.11.6.10
date	2004.06.05.23.11.03;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.39.20;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.10.29.00.28.14;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.58
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: trap.c,v 1.57 2016/02/27 13:08:07 mpi Exp $     */
/*	$NetBSD: trap.c,v 1.47 1999/08/21 19:26:20 matt Exp $     */
/*
 * Copyright (c) 1994 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

 /* All bugs are subject to removal without further notice */
#include <sys/types.h>
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/systm.h>
#include <sys/syscall_mi.h>
#include <sys/signalvar.h>
#include <sys/exec.h>

#include <uvm/uvm_extern.h>

#include <machine/mtpr.h>
#include <machine/pte.h>
#include <machine/pcb.h>
#include <machine/trap.h>
#include <machine/pmap.h>
#include <machine/cpu.h>

#ifdef DDB
#include <machine/db_machdep.h>
#endif
#include <kern/syscalls.c>

#ifdef TRAPDEBUG
volatile int startsysc = 0, faultdebug = 0;
#endif

void	arithflt(struct trapframe *);
void	syscall(struct trapframe *);

char *traptypes[]={
	"reserved addressing",
	"privileged instruction",
	"reserved operand",
	"breakpoint instruction",
	"XFC instruction",
	"system call ",
	"arithmetic trap",
	"asynchronous system trap",
	"page table length fault",
	"translation violation fault",
	"trace trap",
	"compatibility mode fault",
	"access violation fault",
	"",
	"",
	"KSP invalid",
	"",
	"kernel debugger trap"
};
int no_traps = 18;

#define USERMODE(framep)   ((((framep)->psl) & (PSL_U)) == PSL_U)
#define FAULTCHK						\
	do if (p->p_addr->u_pcb.iftrap) {			\
		frame->pc = (unsigned)p->p_addr->u_pcb.iftrap;	\
		frame->psl &= ~PSL_FPD;				\
		frame->r0 = EFAULT;				\
		return;						\
	} while (0)

void
arithflt(frame)
	struct trapframe *frame;
{
	u_int	sig = 0, type = frame->trap, trapsig = 1;
	u_int	rv, addr, umode;
	struct	proc *p = curproc;
	struct vm_map *map;
	vm_prot_t ftype;
	int typ;
	union sigval sv;
	
	sv.sival_int = frame->pc;
	uvmexp.traps++;
	if ((umode = USERMODE(frame))) {
		type |= T_USER;
		p->p_addr->u_pcb.framep = frame;
		refreshcreds(p);
	}

	type&=~(T_WRITE|T_PTEFETCH);


#ifdef TRAPDEBUG
if(frame->trap==7) goto fram;
if(faultdebug)printf("Trap: type %lx, code %lx, pc %lx, psl %lx\n",
		frame->trap, frame->code, frame->pc, frame->psl);
fram:
#endif
	switch (type){

	default:
#ifdef DDB
		db_ktrap(frame);
#endif
		printf("Trap: type %x, code %x, pc %x, psl %x\n",
		    (u_int)frame->trap, (u_int)frame->code,
		    (u_int)frame->pc, (u_int)frame->psl);
		panic("trap");

	case T_KSPNOTVAL:
		panic("kernel stack invalid");

	case T_TRANSFLT|T_USER:
	case T_TRANSFLT:
		/*
		 * BUG! BUG! BUG! BUG! BUG!
		 * Due to a hardware bug (at in least KA65x CPUs) a double
		 * page table fetch trap will cause a translation fault
		 * even if access in the SPT PTE entry specifies 'no access'.
		 * In for example section 6.4.2 in VAX Architecture
		 * Reference Manual it states that if a page both are invalid
		 * and have no access set, a 'access violation fault' occurs.
		 * Therefore, we must fall through here...
		 */
#ifdef nohwbug
		panic("translation fault");
#endif
	case T_PTELEN|T_USER:	/* Page table length exceeded */
	case T_ACCFLT|T_USER:
		if (frame->code < 0) { /* Check for kernel space */
			sv.sival_int = frame->code;
			sig = SIGSEGV;
			typ = SEGV_ACCERR;
			break;
		}
		/* FALLTHROUGH */

	case T_PTELEN:
	case T_ACCFLT:
#ifdef TRAPDEBUG
if(faultdebug)printf("trap accflt type %lx, code %lx, pc %lx, psl %lx\n",
			frame->trap, frame->code, frame->pc, frame->psl);
#endif
#ifdef DIAGNOSTIC
		if (p == 0)
			panic("trap: access fault: addr %lx code %lx",
			    frame->pc, frame->code);
#endif

		/*
		 * Page tables are allocated in pmap_enter(). We get
		 * info from below if it is a page table fault, but
		 * UVM may want to map in pages without faults, so
		 * because we must check for PTE pages anyway we don't
		 * bother doing it here.
		 */
		sv.sival_int = frame->code;
		if ((umode == 0) && (frame->code < 0))
			map = kernel_map;
		else
			map = &p->p_vmspace->vm_map;

		if (frame->trap & T_WRITE)
			ftype = PROT_READ | PROT_WRITE;
		else
			ftype = PROT_READ;

		addr = trunc_page((vaddr_t)frame->code);
		rv = uvm_fault(map, addr, 0, ftype);
		if (rv) {
			if (umode == 0) {
				FAULTCHK;
				panic("Segv in kernel mode: pc %x addr %x",
				    (u_int)frame->pc, (u_int)frame->code);
			}
			if (rv == ENOMEM) {
				printf("UVM: pid %d (%s), uid %d killed: "
			           "out of swap\n", p->p_pid, p->p_comm,
			           p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
				sig = SIGKILL;
				typ = 0;
			} else {
				sig = SIGSEGV;
				typ = SEGV_MAPERR;
			}
		} else {
			trapsig = 0;
			if (umode != 0)
				uvm_grow(p, addr);
		}
		break;

	case T_BPTFLT|T_USER:
		typ = TRAP_BRKPT;
		sig = SIGTRAP;
		frame->psl &= ~PSL_T;
		break;

	case T_TRCTRAP|T_USER:
		typ = TRAP_TRACE;
		sig = SIGTRAP;
		frame->psl &= ~PSL_T;
		break;

	case T_PRIVINFLT|T_USER:
	case T_RESOPFLT|T_USER:
		typ = ILL_ILLOPC;
		sig = SIGILL;
		break;

	case T_RESADFLT|T_USER:
		typ = ILL_ILLADR;
		sig = SIGILL;
		break;

	case T_XFCFLT|T_USER:
		typ = EMT_TAGOVF;
		sig = SIGEMT;
		break;

	case T_ARITHFLT|T_USER:
		sv.sival_int = frame->code;
		typ = FPE_FLTINV;
		sig = SIGFPE;
		break;

	case T_ASTFLT|T_USER:
		mtpr(AST_NO,PR_ASTLVL);
		trapsig = 0;
		uvmexp.softs++;
		mi_ast(p, want_resched);
		break;

#ifdef DDB
	case T_BPTFLT: /* Kernel breakpoint */
	case T_KDBTRAP:
	case T_KDBTRAP|T_USER:
	case T_TRCTRAP:
		db_ktrap(frame);
		return;
#endif
	}

	if (trapsig) {
		/*
		 * Arithmetic exceptions can be of two kinds:
		 * - traps (codes 1..7), where pc points to the
		 *   next instruction to execute.
		 * - faults (codes 8..10), where pc points to the
		 *   faulting instruction.
		 * In the latter case, we need to advance pc by ourselves
		 * to prevent a signal loop.
		 *
		 * XXX this is gross -- miod
		 */
		if (type == (T_ARITHFLT | T_USER) && frame->code >= 8) {
			extern long skip_opcode(long);

			frame->pc = skip_opcode(frame->pc);
		}

		trapsignal(p, sig, frame->code, typ, sv);
	}

	if (umode == 0)
		return;

	userret(p);
}

void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct trapframe *exptr;

	exptr = p->p_addr->u_pcb.framep;
	exptr->pc = pack->ep_entry + 2;
	exptr->sp = stack;
	exptr->r6 = stack;			/* for ELF */
	exptr->r7 = 0;				/* for ELF */
	exptr->r8 = 0;				/* for ELF */
	exptr->r9 = p->p_p->ps_strings;		/* for ELF */

	retval[1] = 0;
}

void
syscall(frame)
	struct	trapframe *frame;
{
	struct sysent *callp;
	int nsys, err;
	long rval[2], args[8];
	struct trapframe *exptr;
	struct proc *p = curproc;

#ifdef TRAPDEBUG
if(startsysc)printf("trap syscall %s pc %lx, psl %lx, sp %lx, pid %d, frame %p\n",
	       syscallnames[frame->code], frame->pc, frame->psl,frame->sp,
		curproc->p_pid,frame);
#endif
	uvmexp.syscalls++;

	exptr = p->p_addr->u_pcb.framep = frame;
	callp = p->p_p->ps_emul->e_sysent;
	nsys = p->p_p->ps_emul->e_nsysent;

	if(frame->code == SYS___syscall){
		int g = *(int *)(frame->ap);

		frame->code = *(int *)(frame->ap + 4);
		frame->ap += 8;
		*(int *)(frame->ap) = g - 2;
	}

	if(frame->code < 0 || frame->code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;
	else
		callp += frame->code;

	rval[0] = 0;
	rval[1] = frame->r1;
	if(callp->sy_narg) {
		if ((err = copyin((char *)frame->ap + 4, args,
		    callp->sy_argsize)))
			goto bad;
	}

	err = mi_syscall(p, frame->code, callp, args, rval);

#ifdef TRAPDEBUG
if(startsysc)
	printf("retur %s pc %lx, psl %lx, sp %lx, pid %d, v{rde %d r0 %d, r1 %d, frame %p\n",
	       syscallnames[exptr->code], exptr->pc, exptr->psl,exptr->sp,
		curproc->p_pid,err,rval[0],rval[1],exptr);
#endif

	switch (err) {
	case 0:
		exptr->r1 = rval[1];
		exptr->r0 = rval[0];
		exptr->psl &= ~PSL_C;
		break;

	case EJUSTRETURN:
		return;

	case ERESTART:
		exptr->pc -= (exptr->code > 63 ? 4 : 2);
		break;

	default:
	bad:
		exptr->r0 = err;
		exptr->psl |= PSL_C;
		break;
	}

	mi_syscall_return(p, frame->code, err, rval);
}

void
child_return(arg)
	void *arg;
{
	struct proc *p = arg;
	struct trapframe *frame;

	frame = p->p_addr->u_pcb.framep;
	frame->r1 = frame->r0 = 0;
	frame->psl &= ~PSL_C;

	mi_child_return(p);
}
@


1.57
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2015/09/13 12:30:52 miod Exp $     */
@


1.56
log
@Needs <sys/systm.h> before <sys/syscall_mi.h> now.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2015/01/20 19:43:21 kettenis Exp $     */
d129 1
a129 1
		kdb_trap(frame);
d265 1
a265 1
		kdb_trap(frame);
@


1.55
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2014/11/16 12:30:59 deraadt Exp $     */
d39 1
a40 1
#include <sys/systm.h>
d125 1
a125 1
	switch(type){
@


1.54
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2014/05/11 00:12:44 guenther Exp $     */
d312 1
a312 1
	exptr->r9 = (u_long) PS_STRINGS;	/* for ELF */
@


1.53
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2014/05/10 05:33:00 guenther Exp $     */
d190 1
a190 1
			ftype = VM_PROT_WRITE|VM_PROT_READ;
d192 1
a192 1
			ftype = VM_PROT_READ;
@


1.52
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2014/04/18 11:51:17 guenther Exp $     */
d256 1
@


1.51
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2014/03/30 21:54:49 guenther Exp $     */
d256 1
a256 5
		if (p->p_flag & P_OWEUPC) {
			ADDUPROF(p);
		}
		if (want_resched)
			preempt(NULL);
@


1.50
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2014/03/26 05:23:42 guenther Exp $     */
d113 1
@


1.49
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2013/11/24 22:08:25 miod Exp $     */
d202 3
a204 5
				printf("UVM: pid %d (%s), uid %u killed: "
				       "out of swap\n",
				       p->p_pid, p->p_comm,
				       p->p_cred && p->p_ucred ?
				       p->p_ucred->cr_uid : -1);
@


1.48
log
@Rework pmap to use dynamic P0 and P1 region allocation, instead of allocating
the largest possible page table for every pmap; from NetBSD. This allows the
kernel to use much less memory for page tables.

Significant differences against the NetBSD code are:
- allocation of page table pages is done with a pool instead of allocating
  whole logical pages from uvm and managing the freelist within pmap, never
  releasing allocated pages.
- try to use pt_entry_t * rather than int * whenever possible.
- growth of P0 and P1 regions is allowed to fail, if invoked from
  pmap_enter with the PMAP_CANFAIL flag. This will stall processes until
  memory for the page tables can be obtained, rather than panicing, in
  most cases.
- keep management of mappings for managed pages using pv lists tied to the
  vm_page (using __HAVE_VM_PAGE_MD), rather than a global pv_list head.
- bound check against Sysmap[] in pmap_extract() when asked for a kernel
  address.

As a result of this, bsd.rd can now install a working system on a 12MB machine
without needing to enable swap.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2013/07/13 17:28:36 deraadt Exp $     */
d339 2
a340 2
	callp = p->p_emul->e_sysent;
	nsys = p->p_emul->e_nsysent;
d351 1
a351 1
		callp += p->p_emul->e_nosys;
@


1.47
log
@unify register_t to long on all platforms
ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2012/08/08 04:11:09 miod Exp $     */
d153 1
d161 3
a217 12
		break;

	case T_PTELEN:
		if (p && p->p_addr)
			FAULTCHK;
		panic("ptelen fault in system space: addr %lx pc %lx",
		    frame->code, frame->pc);

	case T_PTELEN|T_USER:	/* Page table length exceeded */
		sv.sival_int = frame->code;
		sig = SIGSEGV;
		typ = SEGV_MAPERR;
@


1.46
log
@Make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2012/08/07 05:16:54 guenther Exp $     */
d334 2
a335 2
	int nsys;
	int err, rval[2], args[8];
@


1.45
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2012/04/23 19:04:07 miod Exp $     */
d366 1
a366 1
		if ((error = copyin((char *)frame->ap + 4, args,
a379 1
bad:
@


1.44
log
@When handling SIGFPE, do the `advance pc if exception is a fault (as opposed
to a trap)' dance before invoking trapsignal(), which will mess with the pc
too. My bug initially, can't believe I never noticed; fixed first in NetBSD.
This makes libsqlite3 build.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2012/04/11 14:38:55 mikeb Exp $     */
d39 1
a43 3
#include "systrace.h"
#include <dev/systrace.h>

a56 3
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
d366 2
a367 7
		err = copyin((char *)frame->ap + 4, args, callp->sy_argsize);
		if (err) {
#ifdef KTRACE
			if (KTRPOINT(p, KTR_SYSCALL))
				ktrsyscall(p, frame->code,
				    callp->sy_argsize, args);
#endif
a368 1
		}
d371 1
a371 10
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, frame->code, callp->sy_argsize, args);
#endif
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		err = systrace_redirect(frame->code, curproc, args, rval);
	else
#endif
		err = (*callp->sy_call)(curproc, args, rval);
d396 1
d402 1
a402 6
	userret(p);

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, frame->code, err, rval[0]);
#endif
d416 1
a416 9
	userret(p);

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
#endif
@


1.43
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2011/11/16 20:50:19 deraadt Exp $     */
d117 1
a117 1
		p->p_addr->u_pcb.framep = frame; 
d150 1
a150 1
		 * In for example section 6.4.2 in VAX Architecture 
d177 1
a177 1
		 * Page tables are allocated in pmap_enter(). We get 
d287 1
a287 3
	if (trapsig) { 
		trapsignal(p, sig, frame->code, typ, sv);

d304 2
d350 1
a350 1
 
@


1.42
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2011/04/03 14:56:28 guenther Exp $     */
d445 1
a445 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.41
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2010/11/27 18:04:23 miod Exp $     */
a66 2
static __inline void userret(struct proc *);

a99 18

/*
 * userret:
 *
 *	Common code used by various exception handlers to
 *	return to usermode.
 */
static __inline void
userret(struct proc *p)
{
	int sig;

	/* Take pending signals. */
	while ((sig = CURSIG(p)) !=0)
		postsig(sig);

	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}
@


1.40
log
@Make sure kcopy() returns EFAULT instead of -1 upon failure on vax, and
fix outdated comments suggesting kcopy() will return -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2007/05/16 05:19:15 miod Exp $     */
d465 3
a467 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.39
log
@Switch vax to __HAVE_CPUINFO, based on an incomplete diff from art.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2007/04/01 09:29:27 art Exp $     */
d99 1
a99 2
		frame->r0 = EFAULT;/* for copyin/out */		\
		frame->r1 = -1; /* for fetch/store */		\
@


1.38
log
@Remove some leftovers from the userret cleanups.
No need to save sticks anymore.
miod@@ ok and test
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2007/03/15 10:22:30 art Exp $     */
d119 1
a119 1
	curpriority = p->p_priority = p->p_usrpri;
@


1.37
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2006/12/24 20:30:35 miod Exp $     */
a128 1
	u_quad_t oticks = 0;
a137 1
		oticks = p->p_sticks;
a359 1
	u_quad_t oticks;
a374 1
	oticks = p->p_sticks;
@


1.36
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2006/12/24 20:29:19 miod Exp $     */
a293 1
			p->p_flag &= ~P_OWEUPC;
@


1.35
log
@Check for want_resched when processing AST and nowhere else. But then, when
doing so, do not check for signals - userret() will do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2006/01/30 21:26:19 miod Exp $     */
d67 1
a67 1
static __inline void userret(struct proc *, struct trapframe *, u_quad_t);
d111 1
a111 4
userret(p, frame, oticks)
	struct proc *p;
	struct trapframe *frame;
	u_quad_t oticks;
a117 9
	p->p_priority = p->p_usrpri;
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
d119 1
a119 10
	/*
	 * If profiling, charge system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) { 
		extern int psratio;

		addupc_task(p, frame->pc,
		    (int)(p->p_sticks - oticks) * psratio);
	}
	curpriority = p->p_priority;
d335 1
a335 1
	userret(p, frame, oticks);
d447 1
a447 1
	userret(p, frame, oticks);
d466 1
a466 1
	userret(p, frame, 0);
@


1.34
log
@When delivering SIGFOO, make sure the siginfo code is a FOO_xxx constant;
also deliver SIGILL/ILL_COPROC rather than SIGFPE/FPE_FLTINV for disabled
or missing floating point support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2005/12/23 19:49:00 miod Exp $     */
d314 6
@


1.33
log
@Make sure child_return() returns with carry clear and r0 = r1 = 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2005/09/15 21:14:27 miod Exp $     */
d301 1
a301 1
		typ = ILL_ILLOPC;		/* XXX hmm */
d307 1
a307 1
		typ = 0;				/* XXX */
@


1.32
log
@In syscall(), do not recompute the struct proc * after the syscall has
succeeded. This used to be necessary for fork(), when returning in the child,
but we return in the child in child_return() which does TRT.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2005/09/15 21:09:30 miod Exp $     */
d475 5
d481 1
a481 1
	userret(p, p->p_addr->u_pcb.framep, 0);
@


1.31
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2005/08/06 17:09:10 miod Exp $     */
a432 1
	exptr = curproc->p_addr->u_pcb.framep;
@


1.30
log
@Remove 16 bit mode_t leftover in syscall processing.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2004/12/06 20:12:25 miod Exp $     */
d481 2
a482 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.29
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2004/03/09 22:29:01 miod Exp $     */
a420 21
	}
	/*
	 * XXX ***TAKE THIS OUT SOON***
	 * this is an evil hack to get around incongruities in (some) syscall 
	 * argument types
	 */ 
	switch(frame->code) {
		case SYS_open:
			args[2] &= 0xffff;
			break;

		case SYS_mkdir:
		case SYS_chmod:
		case SYS_fchmod:
		case SYS_mkfifo:
		case SYS_mknod:
			args[1] &= 0xffff;
			break;

		case SYS_umask:
			args[0] &= 0xffff;
@


1.28
log
@Turn FAULTCHK in a real statement-like macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2003/05/27 23:05:41 miod Exp $     */
d258 1
a258 1
		} else
d260 3
@


1.27
log
@Fix siginfo contents in the T_ACCFLT case, fixes libpthread siginfo regression
test.
Some stylistic input from marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2003/04/16 16:54:17 miod Exp $     */
d96 1
a96 1
	if (p->p_addr->u_pcb.iftrap) {				\
d102 1
a102 1
	}
@


1.26
log
@siginfo support for vax.
machdep.c changes by me, trap.c changes by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2002/06/23 03:03:15 deraadt Exp $     */
d227 1
a227 2
		addr = trunc_page((vaddr_t)frame->code);
		sv.sival_int = addr;
d238 1
@


1.25
log
@uid_t is unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2002/05/16 21:11:19 miod Exp $     */
d156 1
d204 1
d228 1
d253 1
a253 1
				typ = 0; 		/* XXX what goes here? (does it matter?) */
d269 1
d303 1
a323 1
		sv.sival_ptr = (caddr_t)frame->pc;
@


1.24
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2002/05/16 07:37:44 miod Exp $     */
d244 1
a244 1
				printf("UVM: pid %d (%s), uid %d killed: "
@


1.23
log
@Fix a long standing problem on vax: on "arithmetic fault" exceptions,
we schedule a SIGFPE signal delivery to the faulting process.

However, arithmetic faults come in two flavors: "traps" that are "regular"
exceptions, and "faults" that are restartable exceptions.
In the "fault" case, the frame pc points to the faulting instruction, instead
of the next instruction, in case we could save the world by tweaking memory
and make the instruction not fault again when restarted.

In practice, this led to processes blocked in a SIGFPE loop madness.

To avoid this, add a skip_opcode() routine to compute the address of the
next opcode, effectively skipping the offending instruction ; this routine
is a very stripped-down db_disasm().

While there, enhance the ddb disassembler to correctly recognize and
disassemble two-byte opcodes.

ok hugh@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2002/03/14 03:16:02 millert Exp $     */
d43 3
d441 6
a446 1
	err = (*callp->sy_call)(curproc, args, rval);
@


1.22
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2002/03/14 01:26:49 millert Exp $     */
d316 1
a316 1
		sv.sival_ptr = (caddr_t)frame->pc;		
d318 17
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2001/11/28 16:13:29 art Exp $     */
d385 1
a385 1
		err = copyin((char*)frame->ap + 4, args, callp->sy_argsize);
@


1.20
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2001/11/28 13:47:39 art Exp $     */
d64 1
a64 1
static __inline void userret __P((struct proc *, struct trapframe *, u_quad_t));
d66 2
a67 2
void	arithflt __P((struct trapframe *));
void	syscall __P((struct trapframe *));
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2001/11/28 16:13:29 art Exp $     */
a42 3
#include "systrace.h"
#include <dev/systrace.h>

d64 1
a64 1
static __inline void userret(struct proc *, struct trapframe *, u_quad_t);
d66 2
a67 2
void	arithflt(struct trapframe *);
void	syscall(struct trapframe *);
d316 1
a316 1
		sv.sival_ptr = (caddr_t)frame->pc;
a317 17

		/*
		 * Arithmetic exceptions can be of two kinds:
		 * - traps (codes 1..7), where pc points to the
		 *   next instruction to execute.
		 * - faults (codes 8..10), where pc points to the
		 *   faulting instruction.
		 * In the latter case, we need to advance pc by ourselves
		 * to prevent a signal loop.
		 *
		 * XXX this is gross -- miod
		 */
		if (type == (T_ARITHFLT | T_USER) && frame->code >= 8) {
			extern long skip_opcode(long);

			frame->pc = skip_opcode(frame->pc);
		}
d385 1
a385 1
		err = copyin((char *)frame->ap + 4, args, callp->sy_argsize);
d421 1
a421 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		err = systrace_redirect(frame->code, curproc, args, rval);
	else
#endif
		err = (*callp->sy_call)(curproc, args, rval);
@


1.20.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20.2.1 2002/06/11 03:39:20 art Exp $     */
d244 1
a244 1
				printf("UVM: pid %d (%s), uid %u killed: "
@


1.20.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$     */
a155 1
	sv.sival_int = frame->pc;
a202 1
			sv.sival_int = frame->code;
a225 1
		sv.sival_int = addr;
d250 1
a250 1
				typ = 0;
a265 1
		sv.sival_int = frame->code;
a298 1
		sv.sival_int = frame->code;
d319 1
@


1.19
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2001/11/06 23:57:54 miod Exp $     */
d148 1
a148 1
	vm_map_t map;
@


1.18
log
@Update and unbreak cpu_fork() - from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2001/11/06 02:49:23 art Exp $     */
d234 1
a234 1
		if (rv != KERN_SUCCESS) {
d240 1
a240 1
			if (rv == KERN_RESOURCE_SHORTAGE) {
@


1.17
log
@remove the last uses of vm/vm_page.h
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2001/09/19 20:50:57 mickey Exp $     */
d64 2
d101 39
d323 1
a323 16
	while ((sig = CURSIG(p)) !=0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
	if (p->p_flag & P_PROFIL) { 
		extern int psratio;
		addupc_task(p, frame->pc, (int)(p->p_sticks-oticks) * psratio);
	}
	curpriority = p->p_priority;
d352 1
a352 1
	int nsys, sig;
d451 3
a453 16
	p = curproc;
	while ((sig = CURSIG(p)) !=0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
	if (p->p_flag & P_PROFIL) { 
		extern int psratio;
		addupc_task(p, frame->pc, (int)(p->p_sticks-oticks) * psratio);
	}
d457 14
@


1.16
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2001/09/14 14:57:43 art Exp $     */
a41 3

#include <vm/vm.h>
#include <vm/vm_page.h>
@


1.15
log
@Simplify what should be userret, but is inlined instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2001/05/05 21:26:41 art Exp $     */
a43 1
#include <vm/vm_kern.h>
d45 2
@


1.14
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2000/11/10 18:15:43 art Exp $     */
d289 1
a289 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we setrunqueue ourselves but before
		 * we swtch()'ed, we might not be on the queue indicated by
		 * our priority.
d291 1
a291 3
		splstatclock();
		setrunqueue(p);
		mi_switch();
d433 1
a433 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we setrunqueue ourselves but before
		 * we swtch()'ed, we might not be on the queue indicated by
		 * our priority.
d435 1
a435 3
		splstatclock();
		setrunqueue(p);
		mi_switch();
@


1.13
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2000/04/27 01:10:14 bjc Exp $     */
d183 1
a183 1
		addr = trunc_page(frame->code);
@


1.12
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1999/01/11 05:12:08 millert Exp $     */
d372 1
a372 1
				ktrsyscall(p->p_tracep, frame->code,
d402 1
a402 1
		ktrsyscall(p->p_tracep, frame->code, callp->sy_argsize, args);
d459 1
a459 1
		ktrsysret(p->p_tracep, frame->code, err, rval[0]);
@


1.11
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 2
a2 3
/*      $OpenBSD: trap.c,v 1.10 1998/05/11 16:19:13 niklas Exp $     */
/*      $NetBSD: trap.c,v 1.28 1997/07/28 21:48:33 ragge Exp $     */

a33 3
		


d52 1
a61 1
extern 	int want_resched,whichqs;
d63 1
a63 1
volatile int startsysc=0,faultdebug=0;
a65 1
static	void userret __P((struct proc *, u_int, u_int));
a67 34
void	showregs __P((struct trapframe *));
void	showstate __P((struct proc *));
void	stray __P((int, int));
void	printstack __P((u_int *, u_int *));

void
userret(p, pc, psl)
	struct proc *p;
	u_int pc, psl;
{
	int s,sig;

        while ((sig = CURSIG(p)) !=0)
                postsig(sig);
        p->p_priority = p->p_usrpri;
        if (want_resched) {
                /*
                 * Since we are curproc, clock will normally just change
                 * our priority without moving us from one queue to another
                 * (since the running process is not on a queue.)
                 * If that happened after we setrunqueue ourselves but before
		 * we swtch()'ed, we might not be on the queue indicated by
                 * our priority.
                 */
                s=splstatclock();
                setrunqueue(curproc);
                mi_switch();
                splx(s);
                while ((sig = CURSIG(curproc)) != 0)
                        postsig(sig);
        }

        curpriority = curproc->p_priority;
}
d91 10
d105 2
a106 2
	u_int	sig, type = frame->trap, trapsig=1, s;
	u_int	rv, addr;
d108 1
a108 1
	struct	pmap *pm;
d111 1
a111 3
	extern vm_map_t	pte_map;
	int	typ;
	caddr_t	v;
d113 3
a115 2

	if ((frame->psl & PSL_U) == PSL_U) {
d117 1
d121 1
a121 1
	type &= ~(T_WRITE|T_PTEFETCH);
d125 3
a127 5
	if (frame->trap == 7)
		goto fram;
	if (faultdebug)
		printf("Trap: type %x, code %x, pc %x, psl %x\n",
		    frame->trap, frame->code, frame->pc, frame->psl);
d130 1
a130 1
	switch (type) {
a132 1
faulter:
d137 4
a140 3
		    frame->trap, frame->code, frame->pc, frame->psl);
		showregs(frame);
		panic("trap: adr %x", frame->code);
d142 1
a142 1
		goto faulter;
d145 19
a163 46
	case T_TRANSFLT: /* Translation invalid - may be simul page ref */
		if (frame->trap & T_PTEFETCH) {
			u_int	*ptep, *pte, *pte1;

			if (frame->code < 0x40000000)
				ptep = (u_int *)p->p_addr->u_pcb.P0BR;
			else
				ptep = (u_int *)p->p_addr->u_pcb.P1BR;
			pte1 = (u_int *)trunc_page(&ptep[(frame->code &
			    0x3fffffff) >> PGSHIFT]);
			pte = (u_int*)&Sysmap[((u_int)pte1 & 0x3fffffff) >>
			    PGSHIFT];	
			if (*pte & PG_SREF) { /* Yes, simulated */
				s = splhigh();

				*pte |= PG_REF|PG_V; *pte &= ~PG_SREF; pte++;
				*pte |= PG_REF|PG_V; *pte &= ~PG_SREF;
				mtpr(0, PR_TBIA);
				splx(s);
				goto uret;
			}
		} else {
			u_int   *ptep, *pte;

			frame->code = trunc_page(frame->code);
			if (frame->code < 0x40000000) {
				ptep = (u_int *)p->p_addr->u_pcb.P0BR;
				pte = &ptep[(frame->code >> PGSHIFT)];
			} else if (frame->code > 0x7fffffff) {
				pte = (u_int *)&Sysmap[((u_int)frame->code &
				    0x3fffffff) >> PGSHIFT];
			} else {
				ptep = (u_int *)p->p_addr->u_pcb.P1BR;
				pte = &ptep[(frame->code & 0x3fffffff) >>
				    PGSHIFT];
			}
			if (*pte & PG_SREF) {
				s = splhigh();
				*pte |= PG_REF|PG_V; *pte &= ~PG_SREF; pte++;
				*pte |= PG_REF|PG_V; *pte &= ~PG_SREF;
			/*	mtpr(frame->code, PR_TBIS); */
			/*	mtpr(frame->code + NBPG, PR_TBIS); */
				mtpr(0, PR_TBIA);
				splx(s);
				goto uret;
			}
a164 1
		/* Fall into... */
a165 1
	case T_ACCFLT|T_USER:
d167 18
a184 41
		if (faultdebug)
			printf("trap accflt type %x, code %x, pc %x, psl %x\n",
                            frame->trap, frame->code, frame->pc, frame->psl);
#endif
		if (!p)
			panic("trap: access fault without process");
		pm = &p->p_vmspace->vm_pmap;
		if (frame->trap&T_PTEFETCH) {
			u_int faultaddr;
			u_int testaddr = (u_int)frame->code & 0x3fffffff;
			int P0 = 0, P1 = 0, SYS = 0;

			if (frame->code == testaddr)
				P0++;
			else if (frame->code > 0x7fffffff)
				SYS++;
			else
				P1++;

			if (P0) {
				faultaddr = (u_int)pm->pm_pcb->P0BR +
				    ((testaddr >> PGSHIFT) << 2);
			} else if (P1) {
				faultaddr = (u_int)pm->pm_pcb->P1BR +
				    ((testaddr >> PGSHIFT) << 2);
			} else
				panic("pageflt: PTE fault in SPT");

			rv = vm_fault(pte_map, faultaddr & ~PAGE_MASK, 
			    VM_PROT_WRITE|VM_PROT_READ, FALSE);
			if (rv != KERN_SUCCESS) {
				typ = SEGV_MAPERR;
				v = (caddr_t)faultaddr;
				sig = SIGSEGV;
				goto bad;
			} else
				trapsig = 0;
		}
		addr = (frame->code & ~PAGE_MASK);
		if ((frame->pc >= (u_int)KERNBASE) &&
		    (frame->code >= (u_int)KERNBASE)) {
d186 1
a186 1
		} else {
d188 1
a188 1
		}
d194 1
a194 1
		rv = vm_fault(map, addr, ftype, FALSE);
d196 16
a211 8
			if (frame->pc >= (u_int)KERNBASE) {
				if (p->p_addr->u_pcb.iftrap) {
					frame->pc =
					    (int)p->p_addr->u_pcb.iftrap;
					return;
				}
				printf("Segv in kernel mode: rv %d\n", rv);
				goto faulter;
a212 3
			typ = SEGV_MAPERR;
			v = (caddr_t)frame->code;
			sig = SIGSEGV;
d214 1
a214 1
			trapsig=0;
d218 5
d224 3
a226 28
		pm = &p->p_vmspace->vm_pmap;
#ifdef TRAPDEBUG
		if (faultdebug)
			printf("trap ptelen type %x, code %x, pc %x, psl %x\n",
                            frame->trap, frame->code, frame->pc, frame->psl);
#endif
		if (frame->code < 0x40000000) { /* P0 */
			int i;

			if (p->p_vmspace == 0) {
				printf("no vmspace in fault\n");
				goto faulter;
			}
			i = p->p_vmspace->vm_tsize + p->p_vmspace->vm_dsize;
			if (i > (frame->code >> PAGE_SHIFT)) {
				pmap_expandp0(pm, i << 1);
				trapsig = 0;
			} else {
				typ = SEGV_MAPERR;
				v = (caddr_t)0xdeadbeef;	/* XXX */
				sig = SIGSEGV;
			}
		} else if (frame->code > 0x7fffffff) { /* System, segv */
			typ = SEGV_MAPERR;
			v = (caddr_t)0xdeadbeef;		/* XXX */
			sig = SIGSEGV;
		} else { /* P1 */
			int i;
d228 4
a231 10
			i = (u_int)(p->p_vmspace->vm_maxsaddr);
			if (frame->code < i) {
				typ = SEGV_MAPERR;
				v = (caddr_t)0xdeadbeef;	/* XXX */
				sig = SIGSEGV;
			} else {
				pmap_expandp1(pm);
				trapsig = 0;
			}
		}
a233 1
	case T_BPTFLT|T_USER:
d235 1
a235 2
		typ = TRAP_BRKPT;
		v = (caddr_t)0xdeadbeef;		/* XXX */
a240 1
	case T_RESADFLT|T_USER:
d243 5
a247 1
		v = (caddr_t)0xdeadbeef;		/* XXX */
d252 1
a252 2
		typ = 0; 				/* XXX/MAJA */
		v = (caddr_t)0;				/* XXX/MAJA */
d257 1
a257 2
		typ = FPE_FLTINV;			/* XXX? */
		v = (caddr_t)0;
d262 1
a262 1
		mtpr(AST_NO, PR_ASTLVL);
d267 1
d269 2
d275 4
a278 4
bad:
	if (trapsig) {
		sv.sival_ptr = v;
		trapsignal(curproc, sig, frame->code, typ, sv);
a279 3
uret:
	userret(curproc, frame->pc, frame->psl);
};
d281 26
a306 21
void
showstate(p)
	struct proc *p;
{
if(p){
	printf("\npid %d, command %s\n",p->p_pid, p->p_comm);
	printf("text size %x, data size %x, stack size %x\n",
		p->p_vmspace->vm_tsize, p->p_vmspace->vm_dsize,p->p_vmspace->
		vm_ssize);
	printf("virt text %x, virt data %x, max stack %x\n",
		(u_int)p->p_vmspace->vm_taddr, (u_int)p->p_vmspace->vm_daddr,
		(u_int)p->p_vmspace->vm_maxsaddr);
	printf("kernel uarea %x, end uarea %x\n",(u_int)p->p_addr, 
		(u_int)p->p_addr + USPACE);
} else {
	printf("No process\n");
}
	printf("kernel stack: %x, interrupt stack %x\n",
		mfpr(PR_KSP),mfpr(PR_ISP));
	printf("P0BR %x, P0LR %x, P1BR %x, P1LR %x\n",
		mfpr(PR_P0BR),mfpr(PR_P0LR),mfpr(PR_P1BR),mfpr(PR_P1LR));
d311 1
a311 1
        struct proc *p;
d313 2
a314 2
        u_long stack;
        register_t retval[2];
d321 6
a326 1
	retval[0] = retval[1] = 0;
d334 2
a335 1
	int nsys;
d341 2
a342 2
if(startsysc)printf("trap syscall %s pc %x, psl %x, sp %x, pid %d, frame %x\n",
               syscallnames[frame->code], frame->pc, frame->psl,frame->sp,
d345 2
a346 1

d350 1
d355 3
a357 3
		frame->code=*(int *)(frame->ap+4);
		frame->ap+=8;
		*(int *)(frame->ap)=g-2;
d360 1
a360 1
	if(frame->code<0||frame->code>=nsys)
d365 2
a366 2
	rval[0]=0;
	rval[1]=frame->r1;
d368 1
a368 1
		err = copyin((char*)frame->ap+4, args, callp->sy_argsize);
d378 22
d404 1
a404 1
	err=(*callp->sy_call)(curproc,args,rval);
d409 3
a411 3
	printf("retur %s pc %x, psl %x, sp %x, pid %d, v{rde %d r0 %d, r1 %d, frame %x\n",
               syscallnames[exptr->code], exptr->pc, exptr->psl,exptr->sp,
                curproc->p_pid,err,rval[0],rval[1],exptr);
d426 1
a426 1
		exptr->pc = exptr->pc-2;
d434 23
a456 1
	userret(curproc, exptr->pc, exptr->psl);
a460 38
}

void
stray(scb, vec)
	int scb, vec;
{
	printf("stray interrupt scb %d, vec 0x%x\n", scb, vec);
}

void
printstack(loaddr, highaddr)
	u_int *loaddr, *highaddr;
{
	u_int *tmp;

	(u_int)tmp = 0xfffffffc & (u_int)loaddr; /* Easy align */

	for (;tmp < highaddr;tmp += 4)
		printf("%8x:  %8x  %8x  %8x  %8x\n",
		    (int)tmp, *tmp, *(tmp + 1), *(tmp + 2), *(tmp + 3));
}

void
showregs(frame)
	struct trapframe *frame;
{
	printf("P0BR %8x   P1BR %8x   P0LR %8x   P1LR %8x\n",
	    mfpr(PR_P0BR), mfpr(PR_P1BR), mfpr(PR_P0LR), mfpr(PR_P1LR));
	printf("KSP  %8x   ISP  %8x   USP  %8x\n",
	    mfpr(PR_KSP), mfpr(PR_ISP), mfpr(PR_USP));
	printf("R0   %8x   R1   %8x   R2   %8x   R3   %8x\n",
	    frame->r0, frame->r1, frame->r2, frame->r3);
	printf("R4   %8x   R5   %8x   R6   %8x   R7   %8x\n",
	    frame->r4, frame->r5, frame->r6, frame->r7);
	printf("R8   %8x   R9   %8x   R10  %8x   R11  %8x\n",
	    frame->r8, frame->r9, frame->r10, frame->r11);
	printf("FP   %8x   AP   %8x   PC   %8x   PSL  %8x\n",
	    frame->fp, frame->ap, frame->pc, frame->psl);
@


1.11.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 3
a3 2
/*	$OpenBSD: trap.c,v 1.13 2000/11/10 18:15:43 art Exp $     */
/*	$NetBSD: trap.c,v 1.47 1999/08/21 19:26:20 matt Exp $     */
d35 3
a55 1
#include <machine/cpu.h>
d65 1
d67 1
a67 1
volatile int startsysc = 0, faultdebug = 0;
d70 1
d73 34
a129 10
#define USERMODE(framep)   ((((framep)->psl) & (PSL_U)) == PSL_U)
#define FAULTCHK						\
	if (p->p_addr->u_pcb.iftrap) {				\
		frame->pc = (unsigned)p->p_addr->u_pcb.iftrap;	\
		frame->psl &= ~PSL_FPD;				\
		frame->r0 = EFAULT;/* for copyin/out */		\
		frame->r1 = -1; /* for fetch/store */		\
		return;						\
	}

d134 2
a135 2
	u_int	sig = 0, type = frame->trap, trapsig = 1;
	u_int	rv, addr, umode;
d137 1
a137 1
	u_quad_t oticks = 0;
d140 3
a142 1
	int typ;
d144 2
a145 3
	
	uvmexp.traps++;
	if ((umode = USERMODE(frame))) {
a146 1
		oticks = p->p_sticks;
d150 1
a150 1
	type&=~(T_WRITE|T_PTEFETCH);
d154 5
a158 3
if(frame->trap==7) goto fram;
if(faultdebug)printf("Trap: type %lx, code %lx, pc %lx, psl %lx\n",
		frame->trap, frame->code, frame->pc, frame->psl);
d161 1
a161 1
	switch(type){
d164 1
d169 3
a171 4
		    (u_int)frame->trap, (u_int)frame->code,
		    (u_int)frame->pc, (u_int)frame->psl);
		panic("trap");

d173 1
a173 1
		panic("kernel stack invalid");
d176 46
a221 19
	case T_TRANSFLT:
		/*
		 * BUG! BUG! BUG! BUG! BUG!
		 * Due to a hardware bug (at in least KA65x CPUs) a double
		 * page table fetch trap will cause a translation fault
		 * even if access in the SPT PTE entry specifies 'no access'.
		 * In for example section 6.4.2 in VAX Architecture 
		 * Reference Manual it states that if a page both are invalid
		 * and have no access set, a 'access violation fault' occurs.
		 * Therefore, we must fall through here...
		 */
#ifdef nohwbug
		panic("translation fault");
#endif
	case T_ACCFLT|T_USER:
		if (frame->code < 0) { /* Check for kernel space */
			sig = SIGSEGV;
			typ = SEGV_ACCERR;
			break;
d223 1
d225 1
d227 41
a267 18
if(faultdebug)printf("trap accflt type %lx, code %lx, pc %lx, psl %lx\n",
			frame->trap, frame->code, frame->pc, frame->psl);
#endif
#ifdef DIAGNOSTIC
		if (p == 0)
			panic("trap: access fault: addr %lx code %lx",
			    frame->pc, frame->code);
#endif

		/*
		 * Page tables are allocated in pmap_enter(). We get 
		 * info from below if it is a page table fault, but
		 * UVM may want to map in pages without faults, so
		 * because we must check for PTE pages anyway we don't
		 * bother doing it here.
		 */
		addr = trunc_page(frame->code);
		if ((umode == 0) && (frame->code < 0))
d269 1
a269 1
		else
d271 1
a271 1

d277 1
a277 1
		rv = uvm_fault(map, addr, 0, ftype);
d279 8
a286 16
			if (umode == 0) {
				FAULTCHK;
				panic("Segv in kernel mode: pc %x addr %x",
				    (u_int)frame->pc, (u_int)frame->code);
			}
			if (rv == KERN_RESOURCE_SHORTAGE) {
				printf("UVM: pid %d (%s), uid %d killed: "
				       "out of swap\n",
				       p->p_pid, p->p_comm,
				       p->p_cred && p->p_ucred ?
				       p->p_ucred->cr_uid : -1);
				sig = SIGKILL;
				typ = 0; 		/* XXX what goes here? (does it matter?) */
			} else {
				sig = SIGSEGV;
				typ = SEGV_MAPERR;
d288 3
d292 1
a292 1
			trapsig = 0;
d296 29
a324 4
		if (p && p->p_addr)
			FAULTCHK;
		panic("ptelen fault in system space: addr %lx pc %lx",
		    frame->code, frame->pc);
d326 10
a335 3
	case T_PTELEN|T_USER:	/* Page table length exceeded */
		sig = SIGSEGV;
		typ = SEGV_MAPERR;
d339 1
d341 1
a341 6
		sig = SIGTRAP;
		frame->psl &= ~PSL_T;
		break;

	case T_TRCTRAP|T_USER:
		typ = TRAP_TRACE;
d347 1
d350 1
a350 5
		sig = SIGILL;
		break;

	case T_RESADFLT|T_USER:
		typ = ILL_ILLADR;
d355 2
a356 1
		typ = ILL_ILLOPC;		/* XXX hmm */
d361 2
a362 1
		typ = 0;				/* XXX */
d367 1
a367 1
		mtpr(AST_NO,PR_ASTLVL);
a371 1
	case T_BPTFLT: /* Kernel breakpoint */
a372 2
	case T_KDBTRAP|T_USER:
	case T_TRCTRAP:
d377 4
a380 4

	if (trapsig) { 
		sv.sival_ptr = (caddr_t)frame->pc;		
		trapsignal(p, sig, frame->code, typ, sv);
d382 3
d386 21
a406 26
	if (umode == 0)
		return;

	while ((sig = CURSIG(p)) !=0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	if (want_resched) {
		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we setrunqueue ourselves but before
		 * we swtch()'ed, we might not be on the queue indicated by
		 * our priority.
		 */
		splstatclock();
		setrunqueue(p);
		mi_switch();
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
	if (p->p_flag & P_PROFIL) { 
		extern int psratio;
		addupc_task(p, frame->pc, (int)(p->p_sticks-oticks) * psratio);
	}
	curpriority = p->p_priority;
d411 1
a411 1
	struct proc *p;
d413 2
a414 2
	u_long stack;
	register_t *retval;
d421 1
a421 6
	exptr->r6 = stack;			/* for ELF */
	exptr->r7 = 0;				/* for ELF */
	exptr->r8 = 0;				/* for ELF */
	exptr->r9 = (u_long) PS_STRINGS;	/* for ELF */

	retval[1] = 0;
d429 1
a429 2
	u_quad_t oticks;
	int nsys, sig;
d435 2
a436 2
if(startsysc)printf("trap syscall %s pc %lx, psl %lx, sp %lx, pid %d, frame %p\n",
	       syscallnames[frame->code], frame->pc, frame->psl,frame->sp,
d439 1
a439 2
	uvmexp.syscalls++;
 
a442 1
	oticks = p->p_sticks;
d447 3
a449 3
		frame->code = *(int *)(frame->ap + 4);
		frame->ap += 8;
		*(int *)(frame->ap) = g - 2;
d452 1
a452 1
	if(frame->code < 0 || frame->code >= nsys)
d457 2
a458 2
	rval[0] = 0;
	rval[1] = frame->r1;
d460 1
a460 1
		err = copyin((char*)frame->ap + 4, args, callp->sy_argsize);
d464 1
a464 1
				ktrsyscall(p, frame->code,
a469 22
	/*
	 * XXX ***TAKE THIS OUT SOON***
	 * this is an evil hack to get around incongruities in (some) syscall 
	 * argument types
	 */ 
	switch(frame->code) {
		case SYS_open:
			args[2] &= 0xffff;
			break;

		case SYS_mkdir:
		case SYS_chmod:
		case SYS_fchmod:
		case SYS_mkfifo:
		case SYS_mknod:
			args[1] &= 0xffff;
			break;

		case SYS_umask:
			args[0] &= 0xffff;
	}

d472 1
a472 1
		ktrsyscall(p, frame->code, callp->sy_argsize, args);
d474 1
a474 1
	err = (*callp->sy_call)(curproc, args, rval);
d479 3
a481 3
	printf("retur %s pc %lx, psl %lx, sp %lx, pid %d, v{rde %d r0 %d, r1 %d, frame %p\n",
	       syscallnames[exptr->code], exptr->pc, exptr->psl,exptr->sp,
		curproc->p_pid,err,rval[0],rval[1],exptr);
d496 1
a496 1
		exptr->pc -= (exptr->code > 63 ? 4 : 2);
d504 1
a504 23
	p = curproc;
	while ((sig = CURSIG(p)) !=0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	if (want_resched) {
		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we setrunqueue ourselves but before
		 * we swtch()'ed, we might not be on the queue indicated by
		 * our priority.
		 */
		splstatclock();
		setrunqueue(p);
		mi_switch();
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
	if (p->p_flag & P_PROFIL) { 
		extern int psratio;
		addupc_task(p, frame->pc, (int)(p->p_sticks-oticks) * psratio);
	}
d507 1
a507 1
		ktrsysret(p, frame->code, err, rval[0]);
d509 38
@


1.11.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11.6.1 2001/05/14 21:39:12 niklas Exp $     */
d183 1
a183 1
		addr = trunc_page((vaddr_t)frame->code);
@


1.11.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11.6.2 2001/07/04 10:24:46 niklas Exp $     */
d44 1
a46 2
#include <uvm/uvm_extern.h>

d289 6
a294 1
		 * We're being preempted.
d296 3
a298 1
		preempt(NULL);
d440 6
a445 1
		 * We're being preempted.
d447 3
a449 1
		preempt(NULL);
@


1.11.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$     */
d43 3
a66 2
static __inline void userret __P((struct proc *, struct trapframe *, u_quad_t));

a101 39
/*
 * userret:
 *
 *	Common code used by various exception handlers to
 *	return to usermode.
 */
static __inline void
userret(p, frame, oticks)
	struct proc *p;
	struct trapframe *frame;
	u_quad_t oticks;
{
	int sig;

	/* Take pending signals. */
	while ((sig = CURSIG(p)) !=0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) { 
		extern int psratio;

		addupc_task(p, frame->pc,
		    (int)(p->p_sticks - oticks) * psratio);
	}
	curpriority = p->p_priority;
}

d285 16
a300 1
	userret(p, frame, oticks);
d329 1
a329 1
	int nsys;
d428 16
a443 3

	userret(p, frame, oticks);

a446 14
#endif
}

void
child_return(arg)
	void *arg;
{
	struct proc *p = arg;

	userret(p, p->p_addr->u_pcb.framep, 0);

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
@


1.11.6.5
log
@Merge in -current from about a week ago
@
text
@d64 1
a64 1
static __inline void userret(struct proc *, struct trapframe *, u_quad_t);
d66 2
a67 2
void	arithflt(struct trapframe *);
void	syscall(struct trapframe *);
d385 1
a385 1
		err = copyin((char *)frame->ap + 4, args, callp->sy_argsize);
@


1.11.6.6
log
@manually merge stuff cvs missed long ago
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2002/03/14 03:16:02 millert Exp $     */
d148 1
a148 1
	struct vm_map *map;
d234 1
a234 1
		if (rv) {
d240 1
a240 1
			if (rv == ENOMEM) {
@


1.11.6.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$     */
a42 3
#include "systrace.h"
#include <dev/systrace.h>

d241 1
a241 1
				printf("UVM: pid %d (%s), uid %u killed: "
d316 1
a316 1
		sv.sival_ptr = (caddr_t)frame->pc;
a317 17

		/*
		 * Arithmetic exceptions can be of two kinds:
		 * - traps (codes 1..7), where pc points to the
		 *   next instruction to execute.
		 * - faults (codes 8..10), where pc points to the
		 *   faulting instruction.
		 * In the latter case, we need to advance pc by ourselves
		 * to prevent a signal loop.
		 *
		 * XXX this is gross -- miod
		 */
		if (type == (T_ARITHFLT | T_USER) && frame->code >= 8) {
			extern long skip_opcode(long);

			frame->pc = skip_opcode(frame->pc);
		}
d421 1
a421 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		err = systrace_redirect(frame->code, curproc, args, rval);
	else
#endif
		err = (*callp->sy_call)(curproc, args, rval);
@


1.11.6.8
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11.6.7 2003/03/27 23:52:20 niklas Exp $     */
a155 1
	sv.sival_int = frame->pc;
a202 1
			sv.sival_int = frame->code;
a225 1
		sv.sival_int = addr;
d250 1
a250 1
				typ = 0;
a265 1
		sv.sival_int = frame->code;
a298 1
		sv.sival_int = frame->code;
d319 1
@


1.11.6.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11.6.8 2003/05/13 19:41:10 ho Exp $     */
d227 2
a228 1
		sv.sival_int = frame->code;
a238 1
		addr = trunc_page((vaddr_t)frame->code);
@


1.11.6.10
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$     */
d96 1
a96 1
	do if (p->p_addr->u_pcb.iftrap) {			\
d102 1
a102 1
	} while (0)
@


1.10
log
@Type correctness for GCC 2.8.1
@
text
@d1 1
a1 1
/*      $OpenBSD: trap.c,v 1.9 1997/10/08 07:12:08 niklas Exp $     */
d253 1
a253 1
				panic("pageflt: PTE fault in SPT\n");
@


1.9
log
@Use KERNBASE where appropriate. KNF!
@
text
@d1 1
a1 1
/*      $OpenBSD: trap.c,v 1.8 1997/09/12 09:30:57 maja Exp $     */
d143 1
d378 4
a381 2
	if (trapsig)
		trapsignal(curproc, sig, frame->code, typ, v);
@


1.8
log
@Sync with NetBSD 970827. -moj
@
text
@d1 1
a1 1
/*      $OpenBSD: trap.c,v 1.7 1997/05/28 23:29:43 niklas Exp $     */
d145 1
a145 1
		type|=T_USER;
d153 5
a157 3
if(frame->trap==7) goto fram;
if(faultdebug)printf("Trap: type %x, code %x, pc %x, psl %x\n",
		frame->trap, frame->code, frame->pc, frame->psl);
d179 1
a179 1
			if (frame->code<0x40000000)
d182 1
a182 1
				ptep=(u_int *)p->p_addr->u_pcb.P1BR;
d184 1
a184 1
			     0x3fffffff)>>PGSHIFT]);
d186 1
a186 1
			     PGSHIFT];	
d199 2
a200 2
			frame->code=trunc_page(frame->code);
			if (frame->code<0x40000000) {
d203 1
a203 1
			} else if(frame->code > 0x7fffffff) {
d226 3
a228 2
if(faultdebug)printf("trap accflt type %x, code %x, pc %x, psl %x\n",
                        frame->trap, frame->code, frame->pc, frame->psl);
d232 1
a232 1
		pm=&p->p_vmspace->vm_pmap;
d236 1
a236 1
			int P0=0, P1=0, SYS=0;
d238 1
a238 1
			if (frame->code==testaddr)
d262 1
a262 1
				trapsig=0;
d265 2
a266 2
		if ((frame->pc > (unsigned)0x80000000) &&
		    (frame->code > (unsigned)0x80000000)) {
d278 1
a278 1
			if (frame->pc > (u_int)0x80000000) {
d298 3
a300 2
if(faultdebug)printf("trap ptelen type %x, code %x, pc %x, psl %x\n",
                        frame->trap, frame->code, frame->pc, frame->psl);
d320 1
a320 1
			v = (caddr_t)0xdeadbeef;	/* XXX */
d360 1
a360 1
		typ = FPE_FLTINV;	/* XXX? */
@


1.7
log
@First stab att siginfo handling, needs more work. KNF.
@
text
@d1 2
a2 2
/*      $OpenBSD: trap.c,v 1.24 1996/11/06 20:19:55 cgd Exp $     */
/*      $NetBSD: trap.c,v 1.24 1996/11/06 20:19:55 cgd Exp $     */
d99 1
a99 1
                cpu_switch(0);
d113 1
a113 1
	"Nothing",
d347 6
@


1.6
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
d134 1
a134 1
	u_int	sig, type=frame->trap,trapsig=1,s;
d136 1
a136 1
	struct	proc *p=curproc;
d141 4
a144 2
	
	if((frame->psl & PSL_U) == PSL_U) {
d149 1
a149 1
	type&=~(T_WRITE|T_PTEFETCH);
d158 1
a158 1
	switch(type){
d168 1
a168 1
		panic("trap: adr %x",frame->code);
d174 1
a174 1
		if(frame->trap&T_PTEFETCH){
d177 2
a178 2
			if(frame->code<0x40000000)
				ptep=(u_int *)p->p_addr->u_pcb.P0BR;
d181 10
a190 9
			pte1=(u_int *)trunc_page(&ptep[(frame->code
				&0x3fffffff)>>PGSHIFT]);
			pte=(u_int*)&Sysmap[((u_int)pte1&0x3fffffff)>>PGSHIFT];	
			if(*pte&PG_SREF){ /* Yes, simulated */
				s=splhigh();

				*pte|=PG_REF|PG_V;*pte&=~PG_SREF;pte++;
				*pte|=PG_REF|PG_V;*pte&=~PG_SREF;
				mtpr(0,PR_TBIA);
d198 6
a203 6
			if(frame->code<0x40000000){
				ptep=(u_int *)p->p_addr->u_pcb.P0BR;
				pte=&ptep[(frame->code>>PGSHIFT)];
			} else if(frame->code>0x7fffffff){
				pte=(u_int *)&Sysmap[((u_int)frame->code&
					0x3fffffff)>>PGSHIFT];
d205 3
a207 2
				ptep=(u_int *)p->p_addr->u_pcb.P1BR;
				pte=&ptep[(frame->code&0x3fffffff)>>PGSHIFT];
d209 7
a215 7
			if(*pte&PG_SREF){
				s=splhigh();
				*pte|=PG_REF|PG_V;*pte&=~PG_SREF;pte++;
				*pte|=PG_REF|PG_V;*pte&=~PG_SREF;
			/*	mtpr(frame->code,PR_TBIS); */
			/*	mtpr(frame->code+NBPG,PR_TBIS); */
				mtpr(0,PR_TBIA);
d230 23
a252 19
		if(frame->trap&T_PTEFETCH){
			u_int faultaddr,testaddr=(u_int)frame->code&0x3fffffff;
			int P0=0,P1=0,SYS=0;

			if(frame->code==testaddr) P0++;
			else if(frame->code>0x7fffffff) SYS++;
			else P1++;

			if(P0){
				faultaddr=(u_int)pm->pm_pcb->P0BR+
					((testaddr>>PGSHIFT)<<2);
			} else if(P1){
				faultaddr=(u_int)pm->pm_pcb->P1BR+
					((testaddr>>PGSHIFT)<<2);
			} else panic("pageflt: PTE fault in SPT\n");
	
			faultaddr&=~PAGE_MASK;
			rv = vm_fault(pte_map, faultaddr, 
				VM_PROT_WRITE|VM_PROT_READ, FALSE);
d254 3
a256 2
	
				sig=SIGSEGV;
d261 4
a264 4
		addr=(frame->code& ~PAGE_MASK);
		if((frame->pc>(unsigned)0x80000000)&&
			(frame->code>(unsigned)0x80000000)){
			map=kernel_map;
d266 1
a266 1
			map= &p->p_vmspace->vm_map;
d268 4
a271 2
		if(frame->trap&T_WRITE) ftype=VM_PROT_WRITE|VM_PROT_READ;
		else ftype = VM_PROT_READ;
d275 4
a278 3
			if(frame->pc>(u_int)0x80000000){
				if(p->p_addr->u_pcb.iftrap){
					frame->pc=(int)p->p_addr->u_pcb.iftrap;
d281 1
a281 1
				printf("Segv in kernel mode: rv %d\n",rv);
d284 5
a288 2
			sig=SIGSEGV;
		} else trapsig=0;
d293 1
a293 1
		pm=&p->p_vmspace->vm_pmap;
d298 1
a298 1
		if(frame->code<0x40000000){ /* P0 */
d301 1
a301 1
			if (p->p_vmspace == 0){
d306 1
a306 1
			if (i > (frame->code >> PAGE_SHIFT)){
d310 2
d314 3
a316 1
		} else if (frame->code > 0x7fffffff){ /* System, segv */
d322 3
a324 1
			if (frame->code < i){
d335 2
d344 3
a346 1
		sig=SIGILL;
d350 3
a352 1
		sig=SIGFPE;
d356 2
a357 2
		mtpr(AST_NO,PR_ASTLVL);
		trapsig=0;
d368 1
a368 1
		trapsignal(curproc, sig, frame->code);
@


1.5
log
@sync to 0611
@
text
@d1 1
a1 1
/*      $NetBSD: trap.c,v 1.21 1996/05/19 16:44:27 ragge Exp $     */
d92 2
a93 2
                 * If that happened after we setrq ourselves but before we
                 * swtch()'ed, we might not be on the queue indicated by
@


1.4
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*      $NetBSD: trap.c,v 1.20 1996/04/08 18:32:58 ragge Exp $     */
a44 1
#include <sys/cpu.h>
@


1.3
log
@from ragge; handle debugger traps from kernel
@
text
@d1 1
a1 1
/*      $NetBSD: trap.c,v 1.15 1996/01/28 12:24:33 ragge Exp $     */
d37 19
a55 17
#include "sys/types.h"
#include "sys/param.h"
#include "sys/proc.h"
#include "sys/user.h"
#include "sys/syscall.h"
#include "sys/systm.h"
#include "sys/signalvar.h"
#include "sys/exec.h"
#include "vm/vm.h"
#include "vm/vm_kern.h"
#include "vm/vm_page.h"
#include "vax/include/mtpr.h"
#include "vax/include/pte.h"
#include "vax/include/pcb.h"
#include "vax/include/trap.h"
#include "vax/include/pmap.h"
#include "kern/syscalls.c"
d57 7
d66 3
a68 1
volatile int startsysc=0,ovalidstart=0,faultdebug=0,haltfault=0;
d70 7
d78 1
d99 1
a99 1
                cpu_switch();
d130 1
d135 1
a135 1
	u_int	rv, addr,*i,j;
d150 1
a150 1

d155 1
d219 1
d222 3
a224 2

		if(!p) panic("trap: access fault without process");
d249 2
a250 3
			} else trapsig=0;
/*			return; /* We don't know if it was a trap only for PTE*/
/*			break; */
d279 1
d282 1
d333 1
d337 1
d346 1
d356 3
a358 3
		p->p_vmspace->vm_taddr,p->p_vmspace->vm_daddr,
		p->p_vmspace->vm_maxsaddr);
	printf("kernel uarea %x, end uarea %x\n",p->p_addr, 
d384 1
d390 1
a390 1
	int err,rval[2],args[8],sig;
d392 1
a392 1
	struct proc *p=curproc;
d394 1
d398 1
d400 1
a400 1
	p->p_addr->u_pcb.framep = frame;
d419 15
a433 3
	if(callp->sy_narg)
		copyin((char*)frame->ap+4, args, callp->sy_argsize);

d435 1
a435 1
	exptr=curproc->p_addr->u_pcb.framep;
d437 1
d442 1
d444 2
a445 1
	switch(err){
d447 2
a448 2
		exptr->r1=rval[1];
		exptr->r0=rval[0];
d451 1
d454 1
d456 1
a456 1
		exptr->pc=exptr->pc-2;
d458 1
d460 1
a460 1
		exptr->r0=err;
d465 4
d471 4
a474 1
stray(scb, vec){
d478 1
d488 1
a488 1
		    tmp, *tmp, *(tmp + 1), *(tmp + 2), *(tmp + 3));
d491 1
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*      $NetBSD: trap.c,v 1.14 1995/11/12 14:33:13 ragge Exp $     */
d140 1
a140 2
		if (kdb_trap(frame))
			return;
a144 1
asm("halt");
d308 4
d314 2
a315 1
	if(trapsig) trapsignal(curproc, sig, frame->code);
d353 1
a353 1
	mtpr(stack, PR_USP);
d366 2
a367 2
if(startsysc)printf("trap syscall %s pc %x, psl %x, ap %x, pid %d, frame %x\n",
               syscallnames[frame->code], frame->pc, frame->psl,frame->ap,
d396 2
a397 2
	printf("retur %s pc %x, psl %x, ap %x, pid %d, v{rde %d r0 %d, r1 %d, frame %x\n",
               syscallnames[exptr->code], exptr->pc, exptr->psl,exptr->ap,
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*      $NetBSD: trap.c,v 1.13 1995/07/05 08:39:48 ragge Exp $     */
d143 4
d161 2
a162 2
				&0x3fffffff)>>PG_SHIFT]);
			pte=(u_int*)&Sysmap[((u_int)pte1&0x3fffffff)>>PG_SHIFT];	
d178 1
a178 1
				pte=&ptep[(frame->code>>PG_SHIFT)];
d181 1
a181 1
					0x3fffffff)>>PG_SHIFT];
d184 1
a184 1
				pte=&ptep[(frame->code&0x3fffffff)>>PG_SHIFT];
d215 1
a215 1
					((testaddr>>PG_SHIFT)<<2);
d218 1
a218 1
					((testaddr>>PG_SHIFT)<<2);
a417 25
}

struct inta {
	char pushr[2];	/* pushr $3f */
	char pushl[2];	/* pushl $? */
	char nop;	/* nop, for foolish gcc */
	char calls[3];	/* $1,? */
	u_int hoppaddr; /* jump for calls */
	char popr[2];	/* popr $0x3f */
	char rei;	/* rei */
} intasm = {0xbb, 0x3f, 0xdd, 0, 1, 0xfb, 1, 0xef, 0, 0xba, 0x3f, 2};

u_int
settrap(plats, nyrut,arg)
	u_int plats;  /* Pointer to place to copy interrupt routine */
	u_int nyrut;  /* Pointer to new routine to jump to */
	u_int arg;    /* arg number to pass to routine. */
{
	struct inta *introut;

	introut=(void *)((plats&0xfffffffc)+4);
	bcopy(&intasm, introut, sizeof(struct inta));
	introut->pushl[1]=arg;
	introut->hoppaddr=nyrut-(u_int)&introut->popr[0];
	return (u_int)introut;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
