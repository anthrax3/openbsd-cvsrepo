head	1.14;
access;
symbols
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.18
	OPENBSD_2_8:1.7.0.16
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.14
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2006.01.11.22.49.09;	author miod;	state dead;
branches;
next	1.13;

1.13
date	2005.11.06.22.21.33;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	97.05.29.00.05.28;	author niklas;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.01.15.23.25.25;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.05.03.09.10.27;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.31.05.22.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.14.00.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.11;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.10.31.03.08.02;	author nate;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2002.03.28.11.26.47;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.7.12.5;

1.7.12.5
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.39.20;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Let's move the orphans to the Attic.
@
text
@/*	$OpenBSD: uvaxII.c,v 1.13 2005/11/06 22:21:33 miod Exp $	*/
/*	$NetBSD: uvaxII.c,v 1.10 1996/10/13 03:36:04 christos Exp $	*/

/*-
 * Copyright (c) 1994 Gordon W. Ross 
 * Copyright (c) 1993 Adam Glass 
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1988, 1990, 1993
 * 	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)ka630.c     7.8 (Berkeley) 5/9/91
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <uvm/uvm_extern.h>

#include <machine/uvaxII.h>
#include <machine/pte.h>
#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/pmap.h>
#include <machine/nexus.h>

struct uvaxIIcpu *uvaxIIcpu_ptr;

#if VAX630
struct	ka630clock *ka630clk_ptr;
static	time_t	ka630_clkread(int *);
static	void	ka630_clkwrite(time_t);

struct watclk {
    u_short wat_sec;
    u_short wat_min;
    u_short wat_hour;
    u_short wat_dow;
    u_short wat_day;
    u_short wat_month;
    u_short wat_year;
};

void gmt_to_wat (time_t *tp, struct watclk *wt);
void wat_to_gmt (struct watclk *wt, time_t *tp);
#endif

/*
 * uvaxII_conf() is called by cpu_attach to do the cpu_specific setup.
 */
void
uvaxII_conf(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
{
	switch (cpu_type) {
	case VAX_630:
		strlcpy(cpu_model,"MicroVAX II", sizeof cpu_model);
		break;
	case VAX_410:
		strlcpy(cpu_model,"MicroVAX 2000", sizeof cpu_model);
		break;
	default:
		strlcpy(cpu_model, "MicroVAX 78032/78132", sizeof cpu_model);
		break;
	};
	printf(": %s\n", cpu_model);
}

int
uvaxII_clock()
{
	mtpr(0x40, PR_ICCS); /* Start clock and enable interrupt */
	return 1;
}

/* log crd errors */
void
uvaxII_memerr()
{
	printf("memory err!\n");
}

#define NMC78032 10
char *mc78032[] = {
	0,		"immcr (fsd)",	"immcr (ssd)",	"fpu err 0",
	"fpu err 7",	"mmu st(tb)",	"mmu st(m=0)",	"pte in p0",
	"pte in p1",	"un intr id",
};

struct mc78032frame {
	int	mc63_bcnt;		/* byte count == 0xc */
	int	mc63_summary;		/* summary parameter */
	int	mc63_mrvaddr;		/* most recent vad */
	int	mc63_istate;		/* internal state */
	int	mc63_pc;		/* trapped pc */
	int	mc63_psl;		/* trapped psl */
};

int
uvaxII_mchk(cmcf)
	caddr_t cmcf;
{
	register struct mc78032frame *mcf = (struct mc78032frame *)cmcf;
	register u_int type = mcf->mc63_summary;

	printf("machine check %x", type);
	if (type < NMC78032 && mc78032[type])
		printf(": %s", mc78032[type]);
	printf("\n\tvap %x istate %x pc %x psl %x\n",
	    mcf->mc63_mrvaddr, mcf->mc63_istate,
	    mcf->mc63_pc, mcf->mc63_psl);
	if (uvaxIIcpu_ptr && uvaxIIcpu_ptr->uvaxII_mser & UVAXIIMSER_MERR) {
		printf("\tmser=0x%x ", (int)uvaxIIcpu_ptr->uvaxII_mser);
		if (uvaxIIcpu_ptr->uvaxII_mser & UVAXIIMSER_CPUE)
			printf("page=%d", (int)uvaxIIcpu_ptr->uvaxII_cear);
		if (uvaxIIcpu_ptr->uvaxII_mser & UVAXIIMSER_DQPE)
			printf("page=%d", (int)uvaxIIcpu_ptr->uvaxII_dear);
		printf("\n");
	}
	return (-1);
}

/*
 * Handle the watch chip used by the ka630 and ka410 mother boards.
 */
u_long
uvaxII_gettodr(stopped_flag)
	int	*stopped_flag;
{
	register time_t year_secs;

	switch (cpu_type) {
#if VAX630
	case VAX_630:
		year_secs = ka630_clkread(stopped_flag);
		break;
#endif
	default:
		year_secs = 0;
		*stopped_flag = 1;
	};
	return (year_secs * 100);
}

void
uvaxII_settodr(year_ticks)
	time_t year_ticks;
{
	register time_t year_secs;

	year_secs = year_ticks / 100;
	switch (cpu_type) {
#if VAX630
	case VAX_630:
		ka630_clkwrite(year_secs);
		break;
#endif
	};
}

#if VAX630
/* init system time from tod clock */
/* ARGSUSED */
time_t
ka630_clkread(stopped_flag)
	int	*stopped_flag;
{
	register struct ka630clock *claddr = ka630clk_ptr;
	struct watclk wt;
	time_t year_secs;

	*stopped_flag = 0;

	claddr->csr1 = KA630CLK_SET;
	while ((claddr->csr0 & KA630CLK_UIP) != 0)
		;

	wt.wat_sec   = claddr->sec;
	wt.wat_min   = claddr->min;
	wt.wat_hour  = claddr->hr;
	wt.wat_day   = claddr->day;
	wt.wat_month = claddr->mon;
	wt.wat_year  = claddr->yr;

	/* If the clock is valid, use it. */
	if ((claddr->csr3 & KA630CLK_VRT) != 0 &&
	    (claddr->csr1 & KA630CLK_ENABLE) == KA630CLK_ENABLE) {
		/* simple sanity checks */
		if (wt.wat_month < 1 || wt.wat_month > 12 ||
		    wt.wat_day < 1 || wt.wat_day > 31) {
			printf("WARNING: preposterous clock chip time.\n");
			year_secs = 0;
		} else
			wat_to_gmt (&wt, &year_secs);

		claddr->csr0 = KA630CLK_RATE;
		claddr->csr1 = KA630CLK_ENABLE;

		return (year_secs);
	}

	printf("WARNING: TOY clock invalid.\n");
	return (0);
}

/* Set the time of day clock, called via. stime system call.. */
void
ka630_clkwrite(year_secs)
	time_t year_secs;
{
	register struct ka630clock *claddr = ka630clk_ptr;
	struct watclk wt;
	int s;

	gmt_to_wat (&year_secs, &wt);

	s = splhigh();

	claddr->csr1 = KA630CLK_SET;
	while ((claddr->csr0 & KA630CLK_UIP) != 0)
		;
 
	claddr->sec = wt.wat_sec;
	claddr->min = wt.wat_min;
	claddr->hr  = wt.wat_hour;
	claddr->day = wt.wat_day;
	claddr->mon = wt.wat_month;
	claddr->yr  = wt.wat_year;

	claddr->csr0 = KA630CLK_RATE;
	claddr->csr1 = KA630CLK_ENABLE;

	splx(s);
}
#endif

void
uvaxII_steal_pages()
{
	extern  vaddr_t avail_start, virtual_avail, avail_end;
	int	junk;

	/*
	 * MicroVAX II: get 10 pages from top of memory,
	 * map in Qbus map registers, cpu and clock registers.
	 */
	avail_end -= 10;

	MAPPHYS(junk, 2, VM_PROT_READ|VM_PROT_WRITE);
	MAPVIRT(nexus, btoc(0x400000));
	pmap_map((vaddr_t)nexus, 0x20088000, 0x20090000,
	    VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(uvaxIIcpu_ptr, 1);
	pmap_map((vaddr_t)uvaxIIcpu_ptr, (paddr_t)UVAXIICPU,
	    (paddr_t)UVAXIICPU + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	MAPVIRT(ka630clk_ptr, 1);
	pmap_map((vaddr_t)ka630clk_ptr, (paddr_t)KA630CLK,
	    (paddr_t)KA630CLK + NBPG, VM_PROT_READ|VM_PROT_WRITE);

	/*
	 * Clear restart and boot in progress flags
	 * in the CPMBX.
	 */
	ka630clk_ptr->cpmbx = (ka630clk_ptr->cpmbx & KA630CLK_LANG);

	/*
	 * Enable memory parity error detection and clear error bits.
	 */
	uvaxIIcpu_ptr->uvaxII_mser = (UVAXIIMSER_PEN | UVAXIIMSER_MERR |
	    UVAXIIMSER_LEB);

	/*
	 * Set up cpu_type so that we can differ between 630 and 420.
	 */
        if (cpunumber == VAX_78032)
                cpu_type = (((*UVAXIISID) >> 24) & 0xff) |
		    (cpu_type & 0xff000000);
}

#if VAX630
/*
 * Generic routines to convert to or from a POSIX date
 * (seconds since 1/1/1970) and  yr/mo/day/hr/min/sec
 * (These are derived from the sun3 clock chip code.)
 */

/*
 * Machine dependent base year:
 * Note: must be < 1970
 */
#define	CLOCK_BASE_YEAR	1900

/* Traditional UNIX base year */
#define	POSIX_BASE_YEAR	1970
#define FEBRUARY	2

#define SECDAY		86400L
#define SECYR		(SECDAY * 365)

#define	leapyear(year)		((year) % 4 == 0)
#define	days_in_year(a) 	(leapyear(a) ? 366 : 365)
#define	days_in_month(a) 	(month_days[(a) - 1])

static int month_days[12] = {
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

void
gmt_to_wat(tp, wt)
	time_t	*tp;
	struct	watclk *wt;
{
	register int i;
	register long days, secs;

	days = *tp / SECDAY;
	secs = *tp % SECDAY;

	/* Hours, minutes, seconds are easy */
	wt->wat_hour = secs / 3600;
	secs = secs % 3600;
	wt->wat_min  = secs / 60;
	secs = secs % 60;
	wt->wat_sec  = secs;

	/* Day of week (Note: 1/1/1970 was a Thursday) */
	wt->wat_dow = (days + 4) % 7;

	/* Number of years in days */
	i = POSIX_BASE_YEAR;
	while (days >= days_in_year(i)) {
		days -= days_in_year(i);
		i++;
	}
	wt->wat_year = i - CLOCK_BASE_YEAR;

	/* Number of months in days left */
	if (leapyear(i))
		days_in_month(FEBRUARY) = 29;
	for (i = 1; days >= days_in_month(i); i++)
		days -= days_in_month(i);
	days_in_month(FEBRUARY) = 28;
	wt->wat_month = i;

	/* Days are what is left over (+1) from all that. */
	wt->wat_day = days + 1;  
}

void
wat_to_gmt(wt, tp)
	time_t	*tp;
	struct	watclk *wt;
{
	register int i;
	register long tmp;
	int year;

	/*
	 * Hours are different for some reason. Makes no sense really.
	 */

	tmp = 0;

	if (wt->wat_hour >= 24) goto out;
	if (wt->wat_day  >  31) goto out;
	if (wt->wat_month > 12) goto out;

	year = wt->wat_year + CLOCK_BASE_YEAR;

	/*
	 * Compute days since start of time
	 * First from years, then from months.
	 */
	for (i = POSIX_BASE_YEAR; i < year; i++)
		tmp += days_in_year(i);
	if (leapyear(year) && wt->wat_month > FEBRUARY)
		tmp++;

	/* Months */
	for (i = 1; i < wt->wat_month; i++)
	  	tmp += days_in_month(i);
	tmp += (wt->wat_day - 1);

	/* Now do hours */
	tmp = tmp * 24 + wt->wat_hour;

	/* Now do minutes */
	tmp = tmp * 60 + wt->wat_min;

	/* Now do seconds */
	tmp = tmp * 60 + wt->wat_sec;

 out:
	*tp = tmp;
}
#endif /* VAX630 */

@


1.13
log
@Kill deprecated vm_offset_t and vm_size_t types on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.12 2003/06/02 23:27:59 millert Exp $	*/
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.11 2003/05/11 19:41:12 deraadt Exp $	*/
d265 1
a265 1
	extern  vm_offset_t avail_start, virtual_avail, avail_end;
d276 1
a276 1
	pmap_map((vm_offset_t)nexus, 0x20088000, 0x20090000,
d280 2
a281 2
	pmap_map((vm_offset_t)uvaxIIcpu_ptr, (vm_offset_t)UVAXIICPU,
	    (vm_offset_t)UVAXIICPU + NBPG, VM_PROT_READ|VM_PROT_WRITE);
d284 2
a285 2
	pmap_map((vm_offset_t)ka630clk_ptr, (vm_offset_t)KA630CLK,
	    (vm_offset_t)KA630CLK + NBPG, VM_PROT_READ|VM_PROT_WRITE);
@


1.11
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.10 2002/03/14 01:26:49 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.9 2001/11/06 19:53:17 miod Exp $	*/
a83 2
	extern char cpu_model[];

d86 1
a86 1
		strcpy(cpu_model,"MicroVAX II");
d89 1
a89 1
		strcpy(cpu_model,"MicroVAX 2000");
d92 1
a92 1
		strcpy(cpu_model, "MicroVAX 78032/78132");
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.8 2001/09/11 20:05:25 miod Exp $	*/
d59 2
a60 2
static	time_t	ka630_clkread __P((int *));
static	void	ka630_clkwrite __P((time_t));
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.9 2001/11/06 19:53:17 miod Exp $	*/
d59 2
a60 2
static	time_t	ka630_clkread(int *);
static	void	ka630_clkwrite(time_t);
@


1.9.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 2
d88 1
a88 1
		strlcpy(cpu_model,"MicroVAX II", sizeof cpu_model);
d91 1
a91 1
		strlcpy(cpu_model,"MicroVAX 2000", sizeof cpu_model);
d94 1
a94 1
		strlcpy(cpu_model, "MicroVAX 78032/78132", sizeof cpu_model);
@


1.8
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.7 1997/05/29 00:05:28 niklas Exp $	*/
d46 1
a46 1
#include <vm/vm.h>
@


1.7
log
@RCS tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.10 1996/10/13 03:36:04 christos Exp $	*/
a46 1
#include <vm/vm_kern.h>
@


1.7.12.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.7 1997/05/29 00:05:28 niklas Exp $	*/
d47 1
@


1.7.12.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
#include <uvm/uvm_extern.h>
@


1.7.12.3
log
@Merge in -current from about a week ago
@
text
@d59 2
a60 2
static	time_t	ka630_clkread(int *);
static	void	ka630_clkwrite(time_t);
@


1.7.12.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.7.12.3 2002/03/28 11:26:47 niklas Exp $	*/
d84 2
d88 1
a88 1
		strlcpy(cpu_model,"MicroVAX II", sizeof cpu_model);
d91 1
a91 1
		strlcpy(cpu_model,"MicroVAX 2000", sizeof cpu_model);
d94 1
a94 1
		strlcpy(cpu_model, "MicroVAX 78032/78132", sizeof cpu_model);
@


1.7.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvaxII.c,v 1.7.12.4 2003/05/13 19:41:10 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.5
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: uvaxII.c,v 1.8 1996/04/08 18:32:59 ragge Exp $	*/
@


1.4
log
@from ragge; print cpu model
@
text
@d1 1
a1 1
/*	$NetBSD: uvaxII.c,v 1.5 1996/01/28 11:45:07 ragge Exp $	*/
d4 5
a8 2
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
d41 13
a53 12
#include "sys/param.h"
#include "sys/types.h"
#include "sys/device.h"
#include "vm/vm.h"
#include "vm/vm_kern.h"

#include "machine/uvaxII.h"
#include "machine/pte.h"
#include "machine/mtpr.h"
#include "machine/sid.h"
#include "machine/pmap.h"
#include "machine/nexus.h"
d59 15
a73 2
u_long	ka630_clkread();
void	ka630_clkwrite();
d93 3
a96 1
	strcpy(cpu_model, "MicroVAX 78032/78132");
d100 1
d108 1
d130 1
d144 1
a144 1
		printf("\tmser=0x%x ", uvaxIIcpu_ptr->uvaxII_mser);
d146 1
a146 1
			printf("page=%d", uvaxIIcpu_ptr->uvaxII_cear);
d148 1
a148 1
			printf("page=%d", uvaxIIcpu_ptr->uvaxII_dear);
d159 1
a159 1
	int *stopped_flag;
d161 1
a161 1
	register u_long year_secs;
d178 1
a178 1
	u_long year_ticks;
d180 1
a180 1
	register u_long year_secs;
a192 1
static short dayyr[12] = { 0,31,59,90,120,151,181,212,243,273,304,334 };
d195 1
a195 1
u_long
d197 1
a197 1
	int *stopped_flag;
d200 2
a201 2
	register int days, yr;
	register u_long year_secs;
d204 1
d208 8
d220 2
a221 2
		if (claddr->mon < 1 || claddr->mon > 12 ||
		    claddr->day < 1 || claddr->day > 31) {
d224 3
a226 9
		} else {
			days = dayyr[claddr->mon - 1] + claddr->day - 1;
			year_secs = days * DAYSEC + claddr->hr * HRSEC +
				claddr->min * MINSEC + claddr->sec;
		}
		claddr->yr = 70;	/* any non-leap year */
#ifndef lint
		{ volatile int t = claddr->csr2; }	/* ??? */
#endif
d232 1
d240 1
a240 1
	u_long year_secs;
d243 1
a243 1
	register int t, t2;
d246 2
d249 1
d253 7
a259 1
	claddr->yr = 70;	/* any non-leap year is ok */
a260 20
	/* t = month + day; separate */
	t = year_secs % YEARSEC;
	for (t2 = 1; t2 < 12; t2++)
		if (t < dayyr[t2])
			break;

	/* t2 is month */
	claddr->mon = t2;
	claddr->day = t - dayyr[t2 - 1] + 1;

	/* the rest is easy */
	t = year_secs % DAYSEC;
	claddr->hr = t / HRSEC;
	t %= HRSEC;
	claddr->min = t / MINSEC;
	claddr->sec = t % MINSEC;
#ifndef lint
	{ volatile int t = claddr->csr2; }	/* ??? */
	{ volatile int t = claddr->csr3; }	/* ??? */
#endif
d263 1
d268 1
d296 1
a296 1
	 /
d312 119
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: uvaxII.c,v 1.4 1995/12/13 18:50:11 ragge Exp $	*/
d78 1
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: uvaxII.c,v 1.3 1995/11/10 18:52:58 ragge Exp $	*/
a37 2
/* All bugs are subject to removal without further notice */

d59 7
a65 4
extern int cpu_type;

int
uvaxII_conf()
d71 1
a71 1
		strcpy(cpu_model,"MicroVAXII");
d77 1
a77 1
	config_rootfound("backplane",(void*)75);
d80 3
a82 9
int
conf_uvaxII(){

	printf(": UvaxII CPU (78032/78132)\n");
}

uvaxII_clock(){

	mtpr(0x40,PR_ICCS); /* Start clock and enable interrupt */
d287 7
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: uvaxII.c,v 1.2 1995/04/18 22:08:25 ragge Exp $	*/
a39 2
#if VAX630 || VAX410

d43 3
a46 1
#include "machine/nexus.h"
d50 2
a51 2
#include "vax/uba/ubavar.h"
#include "vax/uba/ubareg.h"
d53 1
a53 2
#include "mba.h"
#include "uba.h"
a54 6
#include "vm/vm.h"
#include "vm/vm_kern.h"
#include "vax/include/pmap.h"

struct nexus *nexus;
struct uvaxIIcpu *uvaxIIcpu_ptr;
d56 3
a58 3
struct ka630clock *ka630clk_ptr;
u_long ka630_clkread();
void ka630_clkwrite();
d60 2
a61 1
extern int cpu_type, nmba, numuba;
d248 2
a249 2
	{ int t = claddr->csr2; }	/* ??? */
	{ int t = claddr->csr3; }	/* ??? */
d256 37
a292 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
