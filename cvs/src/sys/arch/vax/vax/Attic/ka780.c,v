head	1.11;
access;
symbols
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.12
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2011.07.06.18.32.59;	author miod;	state dead;
branches;
next	1.10;

1.10
date	2008.08.18.23.05.38;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.16.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2000.04.27.01.10.12;	author bjc;	state Exp;
branches;
next	1.4;

1.4
date	97.09.10.12.04.48;	author maja;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	97.05.29.00.05.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.25.15;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	96.05.03.09.10.15;	author mickey;	state Exp;
branches;
next	;

1.4.12.1
date	2001.05.14.21.39.03;	author niklas;	state Exp;
branches;
next	1.4.12.2;

1.4.12.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.4.12.3;

1.4.12.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.4.12.4;

1.4.12.4
date	2003.06.07.11.14.48;	author ho;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@/*	$OpenBSD: ka780.c,v 1.10 2008/08/18 23:05:38 miod Exp $	*/
/*	$NetBSD: ka780.c,v 1.14 1999/08/07 10:36:49 ragge Exp $ */
/*-
 * Copyright (c) 1982, 1986, 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ka780.c	7.4 (Berkeley) 5/9/91
 */

/*
 * 780-specific code.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <machine/nexus.h>
#include <machine/sid.h>
#include <machine/cpu.h>
#include <machine/clock.h>

static	void	ka780_memerr(void);
static	int	ka780_mchk(caddr_t);
static	void	ka780_conf(void);
static	int mem_sbi_match(struct device *, struct cfdata *, void *);
static	void mem_sbi_attach(struct device *, struct device *, void *);

struct	cfattach mem_sbi_ca = {
	sizeof(struct mem_softc), mem_sbi_match, mem_sbi_attach
};

int	
mem_sbi_match(parent, cf, aux)
	struct	device	*parent;
	struct cfdata *cf;
	void	*aux;
{
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;

	if (cf->cf_loc[SBICF_TR] != sa->nexnum && cf->cf_loc[SBICF_TR] > -1)
		return 0;

	switch (sa->type) {
	case NEX_MEM4:
	case NEX_MEM4I:
	case NEX_MEM16:
	case NEX_MEM16I:
		sa->nexinfo = M780C;
		break;

	case NEX_MEM64I:
	case NEX_MEM64L:
	case NEX_MEM64LI:
	case NEX_MEM256I:
	case NEX_MEM256L:
	case NEX_MEM256LI:
		sa->nexinfo = M780EL;
		break;

	case NEX_MEM64U:
	case NEX_MEM64UI:
	case NEX_MEM256U:
	case NEX_MEM256UI:
		sa->nexinfo = M780EU;
		break;
 
	default:
		return 0;
	}
	return 1;
}


/*
 * Declaration of 780-specific calls.
 */
struct	cpu_dep ka780_calls = {
	0,
	ka780_mchk,
	ka780_memerr,
	ka780_conf,
	generic_clkread,
	generic_clkwrite,
	2,	/* ~VUPS */
	5,	/* SCB pages */
	NULL,
	NULL,
	NULL,
	NULL,
	hardclock
};

/*
 * Memory controller register usage varies per controller.
 */
struct	mcr780 {
	int	mc_reg[4];
};

#define M780_ICRD	0x40000000	/* inhibit crd interrupts, in [2] */
#define M780_HIER	0x20000000	/* high error rate, in reg[2] */
#define M780_ERLOG	0x10000000	/* error log request, in reg[2] */
/* on a 780, memory crd's occur only when bit 15 is set in the SBIER */
/* register; bit 14 there is an error bit which we also clear */
/* these bits are in the back of the ``red book'' (or in the VMS code) */

#define M780C_INH(mcr)	\
	((mcr)->mc_reg[2] = (M780_ICRD|M780_HIER|M780_ERLOG)); \
	    mtpr(0, PR_SBIER);
#define M780C_ENA(mcr)	\
	((mcr)->mc_reg[2] = (M780_HIER|M780_ERLOG)); mtpr(3<<14, PR_SBIER);
#define M780C_ERR(mcr)	\
	((mcr)->mc_reg[2] & (M780_ERLOG))

#define M780C_SYN(mcr)	((mcr)->mc_reg[2] & 0xff)
#define M780C_ADDR(mcr) (((mcr)->mc_reg[2] >> 8) & 0xfffff)

#define M780EL_INH(mcr) \
	((mcr)->mc_reg[2] = (M780_ICRD|M780_HIER|M780_ERLOG)); \
	    mtpr(0, PR_SBIER);
#define M780EL_ENA(mcr) \
	((mcr)->mc_reg[2] = (M780_HIER|M780_ERLOG)); mtpr(3<<14, PR_SBIER);
#define M780EL_ERR(mcr) \
	((mcr)->mc_reg[2] & (M780_ERLOG))

#define M780EL_SYN(mcr)		((mcr)->mc_reg[2] & 0x7f)
#define M780EL_ADDR(mcr)	(((mcr)->mc_reg[2] >> 11) & 0x1ffff)

#define M780EU_INH(mcr) \
	((mcr)->mc_reg[3] = (M780_ICRD|M780_HIER|M780_ERLOG)); \
	    mtpr(0, PR_SBIER);
#define M780EU_ENA(mcr) \
	((mcr)->mc_reg[3] = (M780_HIER|M780_ERLOG)); mtpr(3<<14, PR_SBIER);
#define M780EU_ERR(mcr) \
	((mcr)->mc_reg[3] & (M780_ERLOG))

#define M780EU_SYN(mcr)		((mcr)->mc_reg[3] & 0x7f)
#define M780EU_ADDR(mcr)	(((mcr)->mc_reg[3] >> 11) & 0x1ffff)

/* enable crd interrrupts */
void
mem_sbi_attach(parent, self, aux)
	struct	device	*parent, *self;
	void	*aux;
{
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;
	struct	mem_softc *sc = (void *)self;
	struct mcr780 *mcr = (void *)sa->nexaddr;

	sc->sc_memaddr = sa->nexaddr;
	sc->sc_memtype = sa->nexinfo;
	sc->sc_memnr = sa->type;

	printf(": ");
	switch (sc->sc_memtype) {

	case M780C:
		printf("standard");
		M780C_ENA(mcr);
		break;

	case M780EL:
		printf("(el) ");
		M780EL_ENA(mcr);
		if (sc->sc_memnr != NEX_MEM64I && sc->sc_memnr != NEX_MEM256I)
			break;

	case M780EU:
		printf("(eu)");
		M780EU_ENA(mcr);
		break;
	}
	printf("\n");
}

/* log crd errors */
void
ka780_memerr()
{
	extern struct cfdriver mem_cd;
	struct	mem_softc *sc;
	register struct mcr780 *mcr;
	register int m;

	for (m = 0; m < mem_cd.cd_ndevs; m++) {
		if (mem_cd.cd_devs[m] == 0)
			continue;

		sc = (void *)mem_cd.cd_devs[m];
		mcr = (struct mcr780 *)sc->sc_memaddr;
		switch (sc->sc_memtype) {

		case M780C:
			if (M780C_ERR(mcr)) {
				printf("%s: soft ecc addr %x syn %x\n",
				    sc->sc_dev.dv_xname, M780C_ADDR(mcr),
				    M780C_SYN(mcr));
#ifdef TRENDATA
				memlog(m, mcr);
#endif
				M780C_INH(mcr);
			}
			break;

		case M780EL:
			if (M780EL_ERR(mcr)) {
				printf("%s: soft ecc addr %x syn %x\n",
				    sc->sc_dev.dv_xname, M780EL_ADDR(mcr),
				    M780EL_SYN(mcr));
				M780EL_INH(mcr);
			}
			if (sc->sc_memnr != NEX_MEM64I &&
			    sc->sc_memnr != NEX_MEM256I)
				break;

		case M780EU:
			if (M780EU_ERR(mcr)) {
				printf("%s: soft ecc addr %x syn %x\n",
				    sc->sc_dev.dv_xname, M780EU_ADDR(mcr),
				    M780EU_SYN(mcr));
				M780EU_INH(mcr);
			}
			break;
		}
	}
}

#ifdef TRENDATA
/*
 * Figure out what chip to replace on Trendata boards.
 * Assumes all your memory is Trendata or the non-Trendata
 * memory never fails..
 */
struct {
	u_char	m_syndrome;
	char	m_chip[4];
} memlogtab[] = {
	0x01,	"C00",	0x02,	"C01",	0x04,	"C02",	0x08,	"C03",
	0x10,	"C04",	0x19,	"L01",	0x1A,	"L02",	0x1C,	"L04",
	0x1F,	"L07",	0x20,	"C05",	0x38,	"L00",	0x3B,	"L03",
	0x3D,	"L05",	0x3E,	"L06",	0x40,	"C06",	0x49,	"L09",
	0x4A,	"L10",	0x4c,	"L12",	0x4F,	"L15",	0x51,	"L17",
	0x52,	"L18",	0x54,	"L20",	0x57,	"L23",	0x58,	"L24",
	0x5B,	"L27",	0x5D,	"L29",	0x5E,	"L30",	0x68,	"L08",
	0x6B,	"L11",	0x6D,	"L13",	0x6E,	"L14",	0x70,	"L16",
	0x73,	"L19",	0x75,	"L21",	0x76,	"L22",	0x79,	"L25",
	0x7A,	"L26",	0x7C,	"L28",	0x7F,	"L31",	0x80,	"C07",
	0x89,	"U01",	0x8A,	"U02",	0x8C,	"U04",	0x8F,	"U07",
	0x91,	"U09",	0x92,	"U10",	0x94,	"U12",	0x97,	"U15",
	0x98,	"U16",	0x9B,	"U19",	0x9D,	"U21",	0x9E,	"U22",
	0xA8,	"U00",	0xAB,	"U03",	0xAD,	"U05",	0xAE,	"U06",
	0xB0,	"U08",	0xB3,	"U11",	0xB5,	"U13",	0xB6,	"U14",
	0xB9,	"U17",	0xBA,	"U18",	0xBC,	"U20",	0xBF,	"U23",
	0xC1,	"U25",	0xC2,	"U26",	0xC4,	"U28",	0xC7,	"U31",
	0xE0,	"U24",	0xE3,	"U27",	0xE5,	"U29",	0xE6,	"U30"
};

memlog(m, mcr)
	int m;
	struct mcr780 *mcr;
{
	register i;

	for (i = 0; i < (sizeof (memlogtab) / sizeof (memlogtab[0])); i++)
		if ((u_char)(M780C_SYN(mcr)) == memlogtab[i].m_syndrome) {
			printf (
	"mcr%d: replace %s chip in %s bank of memory board %d (0-15)\n",
				m,
				memlogtab[i].m_chip,
				(M780C_ADDR(mcr) & 0x8000) ? "upper" : "lower",
				(M780C_ADDR(mcr) >> 16));
			return;
		}
	printf ("mcr%d: multiple errors, not traceable\n", m);
	break;
}
#endif /* TRENDATA */

char *mc780[]={"0","1","2","3","4","5","6","7","8","9","10","11","12","13",
	"14","15"};

struct mc780frame {
	int	mc8_bcnt;		/* byte count == 0x28 */
	int	mc8_summary;		/* summary parameter (as above) */
	int	mc8_cpues;		/* cpu error status */
	int	mc8_upc;		/* micro pc */
	int	mc8_vaviba;		/* va/viba register */
	int	mc8_dreg;		/* d register */
	int	mc8_tber0;		/* tbuf error reg 0 */
	int	mc8_tber1;		/* tbuf error reg 1 */
	int	mc8_timo;		/* timeout address divided by 4 */
	int	mc8_parity;		/* parity */
	int	mc8_sbier;		/* sbi error register */
	int	mc8_pc;			/* trapped pc */
	int	mc8_psl;		/* trapped psl */
};

int
ka780_mchk(cmcf)
	caddr_t cmcf;
{
	register struct mc780frame *mcf = (struct mc780frame *)cmcf;
	register int type = mcf->mc8_summary;
	register int sbifs;

	printf("machine check %x: %s%s\n", type, mc780[type&0xf],
	    (type&0xf0) ? " abort" : " fault"); 
	printf("\tcpues %x upc %x va/viba %x dreg %x tber %x %x\n",
	   mcf->mc8_cpues, mcf->mc8_upc, mcf->mc8_vaviba,
	   mcf->mc8_dreg, mcf->mc8_tber0, mcf->mc8_tber1);
	sbifs = mfpr(PR_SBIFS);
	printf("\ttimo %x parity %x sbier %x pc %x psl %x sbifs %x\n",
	   mcf->mc8_timo*4, mcf->mc8_parity, mcf->mc8_sbier,
	   mcf->mc8_pc, mcf->mc8_psl, sbifs);
	/* THE FUNNY BITS IN THE FOLLOWING ARE FROM THE ``BLACK BOOK'' */
	/* AND SHOULD BE PUT IN AN ``sbi.h'' */
	mtpr(sbifs &~ 0x2000000, PR_SBIFS);
	mtpr(mfpr(PR_SBIER) | 0x70c0, PR_SBIER);
	return (MCHK_PANIC);
}

struct ka78x {
	unsigned snr:12,
		 plant:3,
		 eco:8,
		 v785:1,
		 type:8;
};

void
ka780_conf()
{
	extern	char cpu_model[];
	struct	ka78x *ka78 = (void *)&vax_cpudata;

	/* Enable cache */
	mtpr(0x200000, PR_SBIMT);

	printf("cpu: %s, serial number %d(%d), hardware ECO level %d(%d)\n",
	    &cpu_model[4], ka78->snr, ka78->plant, ka78->eco >> 4, ka78->eco);
	if (mfpr(PR_ACCS) & 255) {
		printf("cpu: FPA present, enabling.\n");
		mtpr(0x8000, PR_ACCS);
	} else
		printf("cpu: no FPA\n");

}
@


1.10
log
@Make hardclock() a cpu_dep member. Most machines will use the generic
hardclock() here, except for KA46 which needs to reset the diagnostic
timer.

This gives us working clock interrupt counters for vmstat -i in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.9 2003/06/02 23:27:59 millert Exp $	*/
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.8 2002/03/14 03:16:02 millert Exp $	*/
d111 5
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.7 2002/03/14 01:26:48 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.6 2001/08/12 12:03:03 heko Exp $	*/
d55 1
a55 1
static	void mem_sbi_attach(struct device *, struct device *, void*);
@


1.6
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.5 2000/04/27 01:10:12 bjc Exp $	*/
d51 5
a55 5
static	void	ka780_memerr __P((void));
static	int	ka780_mchk __P((caddr_t));
static	void	ka780_conf __P((void));
static	int mem_sbi_match __P((struct device *, struct cfdata *, void *));
static	void mem_sbi_attach __P((struct device *, struct device *, void*));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.6 2001/08/12 12:03:03 heko Exp $	*/
d51 5
a55 5
static	void	ka780_memerr(void);
static	int	ka780_mchk(caddr_t);
static	void	ka780_conf(void);
static	int mem_sbi_match(struct device *, struct cfdata *, void *);
static	void mem_sbi_attach(struct device *, struct device *, void *);
@


1.5
log
@sync with netbsd of early april; some archs still untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.4 1997/09/10 12:04:48 maja Exp $	*/
d301 1
a301 1
#endif TRENDATA
@


1.4
log
@Sync with NetBSD 970516. -moj
@
text
@d1 2
a2 2
/*	$OpenBSD: ka780.c,v 1.3 1997/05/29 00:05:21 niklas Exp $	*/
/*	$NetBSD: ka780.c,v 1.7 1997/02/19 10:04:18 ragge Exp $	*/
a42 1
#include <sys/types.h>
a45 8
#include <vm/vm.h>
#include <vm/vm_kern.h>

#include <machine/pte.h>
#include <machine/clock.h>
#include <machine/cpu.h>
#include <machine/mtpr.h>
#include <machine/scb.h>
d48 2
a50 5
#include <vax/uba/ubavar.h>
#include <vax/uba/ubareg.h>

static	void	ka780_conf __P((struct device *, struct device *, void *));
void	ka780_memenable __P((struct sbi_attach_args *, void *));
d53 49
a101 1
static	void	ka780_steal_pages __P((void));
d107 1
a107 2
	ka780_steal_pages,
	generic_clock,
d114 1
a114 3
	0,	/* Used by vaxstation */
	0,	/* Used by vaxstation */
	0,	/* Used by vaxstation */
d166 3
a168 3
ka780_memenable(sa, osc)
	struct	sbi_attach_args *sa;
	void *osc;
d170 7
a176 2
	struct	mem_softc *sc = osc;
	register struct mcr780 *mcr = (void *)sc->sc_memaddr;
d204 1
a204 1
	extern	struct cfdriver mem_cd;
d355 1
a355 3
ka780_conf(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
d363 1
a363 4
	strcpy(cpu_model,"VAX 11/780");
	if (ka78->v785)
		cpu_model[9] = '5';
	printf(": %s, serial number %d(%d), hardware ECO level %d(%d)\n",
a364 1
	printf("%s: ", self->dv_xname);
d366 1
a366 1
		printf("FPA present, enabling.\n");
d369 1
a369 3
		printf("no FPA\n");

}
a370 11
void
ka780_steal_pages()
{
	extern	vm_offset_t avail_start, virtual_avail;
	extern	struct nexus *nexus;
	int	junk;

	MAPPHYS(junk, 4, VM_PROT_READ|VM_PROT_WRITE);
	MAPVIRT(nexus, btoc(8192*16));
	pmap_map((vm_offset_t)nexus, 0x20000000, 0x20020000,
	    VM_PROT_READ|VM_PROT_WRITE);
@


1.4.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: ka780.c,v 1.5 2000/04/27 01:10:12 bjc Exp $	*/
/*	$NetBSD: ka780.c,v 1.14 1999/08/07 10:36:49 ragge Exp $ */
d43 1
d47 8
a56 2
#include <machine/cpu.h>
#include <machine/clock.h>
d58 5
d65 1
a65 49
static	void	ka780_conf __P((void));
static	int mem_sbi_match __P((struct device *, struct cfdata *, void *));
static	void mem_sbi_attach __P((struct device *, struct device *, void*));

struct	cfattach mem_sbi_ca = {
	sizeof(struct mem_softc), mem_sbi_match, mem_sbi_attach
};

int	
mem_sbi_match(parent, cf, aux)
	struct	device	*parent;
	struct cfdata *cf;
	void	*aux;
{
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;

	if (cf->cf_loc[SBICF_TR] != sa->nexnum && cf->cf_loc[SBICF_TR] > -1)
		return 0;

	switch (sa->type) {
	case NEX_MEM4:
	case NEX_MEM4I:
	case NEX_MEM16:
	case NEX_MEM16I:
		sa->nexinfo = M780C;
		break;

	case NEX_MEM64I:
	case NEX_MEM64L:
	case NEX_MEM64LI:
	case NEX_MEM256I:
	case NEX_MEM256L:
	case NEX_MEM256LI:
		sa->nexinfo = M780EL;
		break;

	case NEX_MEM64U:
	case NEX_MEM64UI:
	case NEX_MEM256U:
	case NEX_MEM256UI:
		sa->nexinfo = M780EU;
		break;
 
	default:
		return 0;
	}
	return 1;
}

d71 2
a72 1
	0,
d79 3
a81 1
	5,	/* SCB pages */
d133 3
a135 3
mem_sbi_attach(parent, self, aux)
	struct	device	*parent, *self;
	void	*aux;
d137 2
a138 7
	struct	sbi_attach_args *sa = (struct sbi_attach_args *)aux;
	struct	mem_softc *sc = (void *)self;
	struct mcr780 *mcr = (void *)sa->nexaddr;

	sc->sc_memaddr = sa->nexaddr;
	sc->sc_memtype = sa->nexinfo;
	sc->sc_memnr = sa->type;
d166 1
a166 1
	extern struct cfdriver mem_cd;
d317 3
a319 1
ka780_conf()
d327 4
a330 1
	printf("cpu: %s, serial number %d(%d), hardware ECO level %d(%d)\n",
d332 1
d334 1
a334 1
		printf("cpu: FPA present, enabling.\n");
d337 3
a339 1
		printf("cpu: no FPA\n");
d341 11
@


1.4.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.4.12.1 2001/05/14 21:39:03 niklas Exp $	*/
d301 1
a301 1
#endif /* TRENDATA */
@


1.4.12.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 5
a55 5
static	void	ka780_memerr(void);
static	int	ka780_mchk(caddr_t);
static	void	ka780_conf(void);
static	int mem_sbi_match(struct device *, struct cfdata *, void *);
static	void mem_sbi_attach(struct device *, struct device *, void *);
@


1.4.12.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ka780.c,v 1.4.12.3 2002/03/28 11:26:46 niklas Exp $	*/
d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: ka780.c,v 1.6 1996/10/13 03:35:50 christos Exp $	*/
/*	$NetBSD: ka780.c,v 1.6 1996/10/13 03:35:50 christos Exp $	*/
d51 1
d61 1
a61 2
/* Prototypes. XXX These should be somewhere else */
void	ka780_conf __P((struct device *, struct device *, void *));
d63 20
a82 3
void	ka780_memerr __P((void));
int	ka780_mchk __P((caddr_t));
void	ka780_steal_pages __P((void));
@


1.2
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.1
log
@sync w/ 0430
@
text
@d1 1
a1 1
/*	$NetBSD: ka780.c,v 1.3 1996/04/08 18:32:43 ragge Exp $	*/
d54 2
a60 1
int	ka780_clock __P((void));
d73 3
a75 3
#define	M780_ICRD	0x40000000	/* inhibit crd interrupts, in [2] */
#define	M780_HIER	0x20000000	/* high error rate, in reg[2] */
#define	M780_ERLOG	0x10000000	/* error log request, in reg[2] */
d80 1
a80 1
#define	M780C_INH(mcr)	\
d83 1
a83 1
#define	M780C_ENA(mcr)	\
d85 1
a85 1
#define	M780C_ERR(mcr)	\
d88 2
a89 2
#define	M780C_SYN(mcr)	((mcr)->mc_reg[2] & 0xff)
#define	M780C_ADDR(mcr)	(((mcr)->mc_reg[2] >> 8) & 0xfffff)
d91 1
a91 1
#define	M780EL_INH(mcr)	\
d94 1
a94 1
#define	M780EL_ENA(mcr)	\
d96 1
a96 1
#define	M780EL_ERR(mcr)	\
d99 2
a100 2
#define	M780EL_SYN(mcr)		((mcr)->mc_reg[2] & 0x7f)
#define	M780EL_ADDR(mcr)	(((mcr)->mc_reg[2] >> 11) & 0x1ffff)
d102 1
a102 1
#define	M780EU_INH(mcr)	\
d105 1
a105 1
#define	M780EU_ENA(mcr)	\
d107 1
a107 1
#define	M780EU_ERR(mcr)	\
d110 2
a111 2
#define	M780EU_SYN(mcr)		((mcr)->mc_reg[3] & 0x7f)
#define	M780EU_ADDR(mcr)	(((mcr)->mc_reg[3] >> 11) & 0x1ffff)
d217 2
a218 2
	0x91,	"U09",	0x92,	"U10",	0x94,	"U12",	0x97, 	"U15",
	0x98,	"U16",	0x9B,	"U19",	0x9D,	"U21",	0x9E, 	"U22",
d248 1
a248 1
        "14","15"};
d300 2
a301 2
	struct  device *parent, *self;
	void    *aux;
d303 2
a304 2
	extern  char cpu_model[];
	struct	ka78x *ka78 = (void *)&cpu_type;
a320 8
}

int
ka780_clock()
{
	mtpr(-10000, PR_NICR); /* Load in count register */
	mtpr(0x800000d1, PR_ICCS); /* Start clock and enable interrupt */
	return 0;
@
