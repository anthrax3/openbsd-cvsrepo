head	1.23;
access;
symbols
	OPENBSD_5_9:1.22.0.22
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.24
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.16
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.20
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.18
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.14
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.12
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.22;
commitid	OSDG2O3Cgeifnf1W;

1.22
date	2010.06.28.14.13.31;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.24.14.51.22;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.15.22.50.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.05.16.58.47;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.29.17.06.27;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.19.21.34.42;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.02.23.45.29;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.08.19.23.54.27;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.15.22.45.33;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.16.22.15.18;	author hugh;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.28.01.19.59;	author hugh;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.27.03.14.47;	author bjc;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.21.38.20;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.24.31;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	;

1.6.4.1
date	2002.01.31.22.55.26;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: dz.c,v 1.22 2010/06/28 14:13:31 deraadt Exp $	*/
/*	$NetBSD: dz.c,v 1.23 2000/06/04 02:14:12 matt Exp $	*/
/*
 * Copyright (c) 1996  Ken C. Wellsch.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/timeout.h>

#ifdef DDB
#include <dev/cons.h>
#endif

#include <machine/bus.h>
#include <machine/pte.h>
#include <machine/trap.h>
#include <machine/cpu.h>

#include <arch/vax/qbus/dzreg.h>
#include <arch/vax/qbus/dzvar.h>

/* Flags used to monitor modem bits, make them understood outside driver */

#define DML_DTR		TIOCM_DTR
#define DML_DCD		TIOCM_CD
#define DML_RI		TIOCM_RI
#define DML_BRK		0100000		/* no equivalent, we will mask */

static const struct speedtab dzspeedtab[] =
{
  {       0,	0		},
  {      50,	DZ_LPR_B50	},
  {      75,	DZ_LPR_B75	},
  {     110,	DZ_LPR_B110	},
  {     134,	DZ_LPR_B134	},
  {     150,	DZ_LPR_B150	},
  {     300,	DZ_LPR_B300	},
  {     600,	DZ_LPR_B600	},
  {    1200,	DZ_LPR_B1200	},
  {    1800,	DZ_LPR_B1800	},
  {    2000,	DZ_LPR_B2000	},
  {    2400,	DZ_LPR_B2400	},
  {    3600,	DZ_LPR_B3600	},
  {    4800,	DZ_LPR_B4800	},
  {    7200,	DZ_LPR_B7200	},
  {    9600,	DZ_LPR_B9600	},
  {   19200,	DZ_LPR_B19200	},
  {      -1,	-1		}
};

static	void	dzstart(struct tty *);
static	int	dzparam(struct tty *, struct termios *);
static	unsigned	dzmctl(struct dz_softc *, int, int, int);
static	void	dzscan(void *);
static	void	dzdrain(struct dz_softc *);

struct	cfdriver dz_cd = {
	NULL, "dz", DV_TTY
};

cdev_decl(dz);

/*
 * The DZ series doesn't interrupt on carrier transitions,
 * so we have to use a timer to watch it.
 */
int	dz_timer = 0;	/* true if timer started */

struct timeout dz_timeout;

void
dzattach(struct dz_softc *sc)
{
	int n;

	sc->sc_rxint = sc->sc_brk = 0;

	sc->sc_dr.dr_tcrw = sc->sc_dr.dr_tcr;
	DZ_WRITE_WORD(sc, dr_csr, DZ_CSR_MSE | DZ_CSR_RXIE | DZ_CSR_TXIE);
	dzdrain(sc);
	DZ_WRITE_BYTE(sc, dr_dtr, 0);
	DZ_WRITE_BYTE(sc, dr_break, 0);

	/* Initialize our softc structure. Should be done in open? */

	for (n = 0; n < sc->sc_type; n++) {
		sc->sc_dz[n].dz_sc = sc;
		sc->sc_dz[n].dz_line = n;
		sc->sc_dz[n].dz_tty = ttymalloc(0);
	}

	/* Alas no interrupt on modem bit changes, so we manually scan */

	if (dz_timer == 0) {
		dz_timer = 1;
		timeout_set(&dz_timeout, dzscan, NULL);
		timeout_add_sec(&dz_timeout, 1);
	}
	printf("\n");
}

/* Receiver Interrupt */

void
dzrint(void *arg)
{
	struct dz_softc *sc = arg;
	struct tty *tp;
	int cc, line;
	unsigned c;
	int overrun = 0;

	sc->sc_rxint++;

	while ((c = DZ_READ_WORD(sc, dr_rbuf)) & DZ_RBUF_DATA_VALID) {
		cc = c & 0xFF;
		line = DZ_PORT(c>>8);
		tp = sc->sc_dz[line].dz_tty;

		/* Must be caught early */
		if (sc->sc_dz[line].dz_catch &&
		    (*sc->sc_dz[line].dz_catch)(sc->sc_dz[line].dz_private, cc))
			continue;

		if (!(tp->t_state & TS_ISOPEN)) {
			wakeup((caddr_t)&tp->t_rawq);
			continue;
		}

		if ((c & DZ_RBUF_OVERRUN_ERR) && overrun == 0) {
			log(LOG_WARNING, "%s: silo overflow, line %d\n",
			    sc->sc_dev.dv_xname, line);
			overrun = 1;
		}

		/* A BREAK key will appear as a NULL with a framing error */
		if (c & DZ_RBUF_FRAMING_ERR)
			cc |= TTY_FE;
		if (c & DZ_RBUF_PARITY_ERR)
			cc |= TTY_PE;

#if defined(DDB) && (defined(VAX410) || defined(VAX43) || defined(VAX46) || defined(VAX48) || defined(VAX49) || defined(VAX53) || defined(VAX60))
		if (tp->t_dev == cn_tab->cn_dev) {
			int j = kdbrint(cc);

			if (j == 1)	/* Escape received, just return */
				continue;

			if (j == 2)	/* Second char wasn't 'D' */
				(*linesw[tp->t_line].l_rint)(27, tp);
		}
#endif

		(*linesw[tp->t_line].l_rint)(cc, tp);
	}
}

/* Transmitter Interrupt */

void
dzxint(void *arg)
{
	struct dz_softc *sc = arg;
	struct tty *tp;
	struct clist *cl;
	int line, ch, csr;
	u_char tcr;

	/*
	 * Switch to POLLED mode.
	 *   Some simple measurements indicated that even on
	 *  one port, by freeing the scanner in the controller
	 *  by either providing a character or turning off
	 *  the port when output is complete, the transmitter
	 *  was ready to accept more output when polled again.
	 *   With just two ports running the game "worms,"
	 *  almost every interrupt serviced both transmitters!
	 *   Each UART is double buffered, so if the scanner
	 *  is quick enough and timing works out, we can even
	 *  feed the same port twice.
	 *
	 * Ragge 980517:
	 * Do not need to turn off interrupts, already at interrupt level.
	 * Remove the pdma stuff; no great need of it right now.
	 */

	while (((csr = DZ_READ_WORD(sc, dr_csr)) & DZ_CSR_TX_READY) != 0) {

		line = DZ_PORT(csr>>8);

		tp = sc->sc_dz[line].dz_tty;
		cl = &tp->t_outq;
		tp->t_state &= ~TS_BUSY;

		/* Just send out a char if we have one */
		/* As long as we can fill the chip buffer, we just loop here */
		if (cl->c_cc) {
			tp->t_state |= TS_BUSY;
			ch = getc(cl);
			DZ_WRITE_BYTE(sc, dr_tbuf, ch);
			continue;
		} 
		/* Nothing to send; clear the scan bit */
		/* Clear xmit scanner bit; dzstart may set it again */
		tcr = DZ_READ_WORD(sc, dr_tcrw);
		tcr &= 255;
		tcr &= ~(1 << line);
		DZ_WRITE_BYTE(sc, dr_tcr, tcr);
		if (sc->sc_dz[line].dz_catch)
			continue;

		if (tp->t_state & TS_FLUSH)
			tp->t_state &= ~TS_FLUSH;
		else
			ndflush(&tp->t_outq, cl->c_cc);

		(*linesw[tp->t_line].l_start)(tp);
	}
}

int
dzopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tty *tp;
	int unit, line;
	struct	dz_softc *sc;
	int s, error = 0;

	unit = DZ_I2C(minor(dev));
	line = DZ_PORT(minor(dev));
	if (unit >= dz_cd.cd_ndevs ||  dz_cd.cd_devs[unit] == NULL)
		return (ENXIO);

	sc = dz_cd.cd_devs[unit];

	if (line >= sc->sc_type)
		return ENXIO;

	/* if some other device is using the line, it's not available */
	if (sc->sc_dz[line].dz_catch)
		return ENXIO;

	if (sc->sc_openings++ == 0)
		dzdrain(sc);

	tp = sc->sc_dz[line].dz_tty;
	if (tp == NULL)
		return (ENODEV);
	tp->t_oproc   = dzstart;
	tp->t_param   = dzparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		}
		(void) dzparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if ((tp->t_state & TS_XCLUDE) && suser(p, 0) != 0)
		return (EBUSY);
	/* Use DMBIS and *not* DMSET or else we clobber incoming bits */
	if (dzmctl(sc, line, DML_DTR, DMBIS) & DML_DCD)
		tp->t_state |= TS_CARR_ON;
	s = spltty();
	while (!(flag & O_NONBLOCK) && !(tp->t_cflag & CLOCAL) &&
	       !(tp->t_state & TS_CARR_ON)) {
		error = ttysleep(tp, (caddr_t)&tp->t_rawq,
				TTIPRI | PCATCH, ttopen, 0);
		if (error)
			break;
	}
	splx(s);
	if (error)
		return (error);
	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

/*ARGSUSED*/
int
dzclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct	dz_softc *sc;
	struct tty *tp;
	int unit, line;

	
	unit = DZ_I2C(minor(dev));
	line = DZ_PORT(minor(dev));
	sc = dz_cd.cd_devs[unit];

	tp = sc->sc_dz[line].dz_tty;

	(*linesw[tp->t_line].l_close)(tp, flag, p);

	/* Make sure a BREAK state is not left enabled. */
	(void) dzmctl(sc, line, DML_BRK, DMBIC);

	/* Do a hangup if so required. */
	if ((tp->t_cflag & HUPCL) || !(tp->t_state & TS_ISOPEN))
		(void) dzmctl(sc, line, 0, DMSET);

	sc->sc_openings--;
	return (ttyclose(tp));
}

int
dzread(dev_t dev, struct uio *uio, int flag)
{
	struct tty *tp;
	struct	dz_softc *sc;

	sc = dz_cd.cd_devs[DZ_I2C(minor(dev))];

	tp = sc->sc_dz[DZ_PORT(minor(dev))].dz_tty;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
dzwrite(dev_t dev, struct uio *uio, int flag)
{
	struct tty *tp;
	struct	dz_softc *sc;

	sc = dz_cd.cd_devs[DZ_I2C(minor(dev))];

	tp = sc->sc_dz[DZ_PORT(minor(dev))].dz_tty;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

/*ARGSUSED*/
int
dzioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct	dz_softc *sc;
	struct tty *tp;
	int unit, line;
	int error;

	unit = DZ_I2C(minor(dev));
	line = DZ_PORT(minor(dev));
	sc = dz_cd.cd_devs[unit];
	tp = sc->sc_dz[line].dz_tty;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {

	case TIOCSBRK:
		(void) dzmctl(sc, line, DML_BRK, DMBIS);
		break;

	case TIOCCBRK:
		(void) dzmctl(sc, line, DML_BRK, DMBIC);
		break;

	case TIOCSDTR:
		(void) dzmctl(sc, line, DML_DTR, DMBIS);
		break;

	case TIOCCDTR:
		(void) dzmctl(sc, line, DML_DTR, DMBIC);
		break;

	case TIOCMSET:
		(void) dzmctl(sc, line, *(int *)data, DMSET);
		break;

	case TIOCMBIS:
		(void) dzmctl(sc, line, *(int *)data, DMBIS);
		break;

	case TIOCMBIC:
		(void) dzmctl(sc, line, *(int *)data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = (dzmctl(sc, line, 0, DMGET) & ~DML_BRK);
		break;

	default:
		return (ENOTTY);
	}
	return (0);
}

struct tty *
dztty(dev_t dev)
{
	struct	dz_softc *sc = dz_cd.cd_devs[DZ_I2C(minor(dev))];
        struct tty *tp = sc->sc_dz[DZ_PORT(minor(dev))].dz_tty;

        return (tp);
}

/*ARGSUSED*/
int
dzstop(struct tty *tp, int flag)
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY)
		if (!(tp->t_state & TS_TTSTOP))
			tp->t_state |= TS_FLUSH;
	splx(s);
	return(0);
}

void
dzstart(struct tty *tp)
{
	struct dz_softc *sc;
	struct clist *cl;
	int unit, line, s;
	char state;

	unit = DZ_I2C(minor(tp->t_dev));
	line = DZ_PORT(minor(tp->t_dev));
	sc = dz_cd.cd_devs[unit];

	s = spltty();
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP)) {
		splx(s);
		return;
	}
	cl = &tp->t_outq;
	if (cl->c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)cl);
		}
		selwakeup(&tp->t_wsel);
	}
	if (cl->c_cc == 0) {
		splx(s);
		return;
	}

	tp->t_state |= TS_BUSY;

	state = DZ_READ_WORD(sc, dr_tcrw) & 255;
	if ((state & (1 << line)) == 0) {
		DZ_WRITE_BYTE(sc, dr_tcr, state | (1 << line));
	}
	dzxint(sc);
	splx(s);
}

static int
dzparam(struct tty *tp, struct termios *t)
{
	struct	dz_softc *sc;
	int cflag = t->c_cflag;
	int unit, line;
	int ispeed = ttspeedtab(t->c_ispeed, dzspeedtab);
	int ospeed = ttspeedtab(t->c_ospeed, dzspeedtab);
	unsigned lpr;
	int s;

	unit = DZ_I2C(minor(tp->t_dev));
	line = DZ_PORT(minor(tp->t_dev));
	sc = dz_cd.cd_devs[unit];

	/* check requested parameters */
        if (ospeed < 0 || ispeed < 0 || ispeed != ospeed)
                return (EINVAL);

        tp->t_ispeed = t->c_ispeed;
        tp->t_ospeed = t->c_ospeed;
        tp->t_cflag = cflag;

	if (ospeed == 0) {
		(void) dzmctl(sc, line, 0, DMSET);	/* hang up line */
		return (0);
	}

	s = spltty();

	lpr = DZ_LPR_RX_ENABLE | ((ispeed&0xF)<<8) | line;

	switch (cflag & CSIZE)
	{
	  case CS5:
		lpr |= DZ_LPR_5_BIT_CHAR;
		break;
	  case CS6:
		lpr |= DZ_LPR_6_BIT_CHAR;
		break;
	  case CS7:
		lpr |= DZ_LPR_7_BIT_CHAR;
		break;
	  default:
		lpr |= DZ_LPR_8_BIT_CHAR;
		break;
	}
	if (cflag & PARENB)
		lpr |= DZ_LPR_PARENB;
	if (cflag & PARODD)
		lpr |= DZ_LPR_OPAR;
	if (cflag & CSTOPB)
		lpr |= DZ_LPR_2_STOP;

	DZ_WRITE_WORD(sc, dr_lpr, lpr);

	splx(s);
	return (0);
}

static unsigned
dzmctl(struct dz_softc *sc, int line, int bits, int how)
{
	unsigned status;
	unsigned mbits;
	unsigned bit;
	int8_t tcr;
	int s;

	s = spltty();

	tcr = DZ_READ_BYTE(sc, dr_tcr);
	bit = (1 << line);

	mbits = 0;

	/* external signals as seen from the port */

	status = DZ_READ_BYTE(sc, dr_dcd) | sc->sc_dsr;

	if (status & bit)
		mbits |= DML_DCD;

	status = DZ_READ_BYTE(sc, dr_ring);

	if (status & bit)
		mbits |= DML_RI;

	/* internal signals/state delivered to port */

	status = DZ_READ_BYTE(sc, dr_dtr);

	if (status & bit)
		mbits |= DML_DTR;

	if (sc->sc_brk & bit)
		mbits |= DML_BRK;

	switch (how)
	{
	  case DMSET:
		mbits = bits;
		break;

	  case DMBIS:
		mbits |= bits;
		break;

	  case DMBIC:
		mbits &= ~bits;
		break;

	  case DMGET:
		splx(s);
		return (mbits);
	}

	if (mbits & DML_DTR) {
		DZ_WRITE_BYTE(sc, dr_dtr, DZ_READ_BYTE(sc, dr_dtr) | bit);
	} else {
		DZ_WRITE_BYTE(sc, dr_dtr, DZ_READ_BYTE(sc, dr_dtr) & ~bit);
	}

	if (mbits & DML_BRK) {
		sc->sc_brk |= bit;
		DZ_WRITE_BYTE(sc, dr_break, sc->sc_brk);
	} else {
		sc->sc_brk &= ~bit;
		DZ_WRITE_BYTE(sc, dr_break, sc->sc_brk);
	}

	/*
	 * On VAXstation 35x0/38x0, writing to the DTR register apparently
	 * affects the TCR register.  Restore its value unconditionally.
	 */
	DZ_WRITE_BYTE(sc, dr_tcr, tcr);

	splx(s);
	return (mbits);
}

/*
 * This is called by timeout() periodically.
 * Check to see if modem status bits have changed.
 */
static void
dzscan(void *arg)
{
	struct dz_softc *sc;
	struct tty *tp;
	int n, bit, port;
	unsigned csr;
	int s;

	s = spltty();

	for (n = 0; n < dz_cd.cd_ndevs; n++) {

		if (dz_cd.cd_devs[n] == NULL)
			continue;

		sc = dz_cd.cd_devs[n];

		for (port = 0; port < sc->sc_type; port++) {

			tp = sc->sc_dz[port].dz_tty;
			bit = (1 << port);
	
			if ((DZ_READ_BYTE(sc, dr_dcd) | sc->sc_dsr) & bit) {
				if (!(tp->t_state & TS_CARR_ON))
					(*linesw[tp->t_line].l_modem) (tp, 1);
			} else if ((tp->t_state & TS_CARR_ON) &&
			    (*linesw[tp->t_line].l_modem)(tp, 0) == 0) {
				DZ_WRITE_BYTE(sc, dr_tcr, 
				    (DZ_READ_WORD(sc, dr_tcrw) & 255) & ~bit);
			}
	    	}

		/*
		 *  If the RX interrupt rate is this high, switch
		 *  the controller to Silo Alarm - which means don't
	 	 *  interrupt until the RX silo has 16 characters in
	 	 *  it (the silo is 64 characters in all).
		 *  Avoid oscillating SA on and off by not turning
		 *  if off unless the rate is appropriately low.
		 */

		csr = DZ_READ_WORD(sc, dr_csr);

		if (sc->sc_rxint > (16*10)) {
			if ((csr & DZ_CSR_SAE) == 0)
				DZ_WRITE_WORD(sc, dr_csr, csr | DZ_CSR_SAE);
	    	} else if ((csr & DZ_CSR_SAE) != 0)
			if (sc->sc_rxint < 10)
				DZ_WRITE_WORD(sc, dr_csr, csr & ~(DZ_CSR_SAE));

		sc->sc_rxint = 0;
	}
	splx(s);
	timeout_add_sec(&dz_timeout, 1);
}

/*
 * Called after an ubareset. The DZ card is reset, but the only thing
 * that must be done is to start the receiver and transmitter again.
 * No DMA setup to care about.
 */
void
dzreset(struct device *dev)
{
	struct dz_softc *sc = (void *)dev;
	struct tty *tp;
	int i;

	for (i = 0; i < sc->sc_type; i++) {
		tp = sc->sc_dz[i].dz_tty;

		if ((tp->t_state & TS_ISOPEN) == 0)
			continue;

		dzparam(tp, &tp->t_termios);
		dzmctl(sc, i, DML_DTR, DMSET);
		tp->t_state &= ~TS_BUSY;
		dzstart(tp);    /* Kick off transmitter again */
	}
}

/*
 * Drain RX fifo.
 */
static void
dzdrain(struct dz_softc *sc)
{
	while (DZ_READ_WORD(sc, dr_rbuf) & DZ_RBUF_DATA_VALID)
		/*EMPTY*/;
}
@


1.22
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.21 2010/04/12 12:57:52 tedu Exp $	*/
@


1.21
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.20 2009/11/09 17:53:39 nicm Exp $	*/
d129 1
a129 1
		sc->sc_dz[n].dz_tty = ttymalloc();
@


1.20
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.19 2009/10/31 12:00:07 fgsch Exp $	*/
d319 1
a319 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d337 1
a337 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.19
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.18 2009/10/31 06:40:16 deraadt Exp $	*/
a482 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.18
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.17 2008/10/15 19:12:19 blambert Exp $	*/
d303 1
a303 1
	} else if ((tp->t_state & TS_XCLUDE) && p->p_ucred->cr_uid != 0)
@


1.17
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.16 2008/08/24 14:51:22 miod Exp $	*/
d483 1
@


1.16
log
@Writing to the DTR register on KA60 resets the TCR register behind our back.
Preserve it explicitely in dzmctl() and restore it after the DTR update.
(This problem was a real PITA to track down)
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.15 2008/08/15 22:50:25 miod Exp $	*/
d137 1
a137 1
		timeout_add(&dz_timeout, hz);
d698 1
a698 1
	timeout_add(&dz_timeout, hz);
@


1.15
log
@Make the DZ_{READ,WRITE}_{BYTE,WORD} macros visible outside of dz.c, for
other dz attachments to be able to use them (soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.14 2006/08/05 16:58:47 miod Exp $	*/
d255 1
a255 1
			ndflush (&tp->t_outq, cl->c_cc);
d257 1
a257 4
		if (tp->t_line)
			(*linesw[tp->t_line].l_start)(tp);
		else
			dzstart(tp);
d449 3
d455 1
d565 1
d570 3
a574 2
	bit = (1 << line);

d629 6
@


1.14
log
@If a dz child driver has taken over a line, it will never be accessible
as /dev/tty0X, period. So return ENXIO instead of EBUSY in dzopen().
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.13 2006/07/29 17:06:27 miod Exp $	*/
a61 10
#define	DZ_READ_BYTE(adr) \
	bus_space_read_1(sc->sc_iot, sc->sc_ioh, sc->sc_dr.adr)
#define	DZ_READ_WORD(adr) \
	bus_space_read_2(sc->sc_iot, sc->sc_ioh, sc->sc_dr.adr)
#define	DZ_WRITE_BYTE(adr, val) \
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, sc->sc_dr.adr, val)
#define	DZ_WRITE_WORD(adr, val) \
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, sc->sc_dr.adr, val)


d119 1
a119 1
	DZ_WRITE_WORD(dr_csr, DZ_CSR_MSE | DZ_CSR_RXIE | DZ_CSR_TXIE);
d121 2
a122 2
	DZ_WRITE_BYTE(dr_dtr, 0);
	DZ_WRITE_BYTE(dr_break, 0);
d155 1
a155 1
	while ((c = DZ_READ_WORD(dr_rbuf)) & DZ_RBUF_DATA_VALID) {
d182 1
a182 1
#if defined(DDB) && (defined(VAX410) || defined(VAX43) || defined(VAX46) || defined(VAX48) || defined(VAX49) || defined(VAX53))
d193 1
d227 1
a227 1
	while (((csr = DZ_READ_WORD(dr_csr)) & DZ_CSR_TX_READY) != 0) {
d240 1
a240 1
			DZ_WRITE_BYTE(dr_tbuf, ch);
d245 1
a245 1
		tcr = DZ_READ_WORD(dr_tcrw);
d248 1
a248 1
		DZ_WRITE_BYTE(dr_tcr, tcr);
d490 1
a490 1
	state = DZ_READ_WORD(dr_tcrw) & 255;
d492 1
a492 1
		DZ_WRITE_BYTE(dr_tcr, state | (1 << line));
d552 1
a552 1
	DZ_WRITE_WORD(dr_lpr, lpr);
d574 1
a574 1
	status = DZ_READ_BYTE(dr_dcd) | sc->sc_dsr;
d579 1
a579 1
	status = DZ_READ_BYTE(dr_ring);
d586 1
a586 1
	status = DZ_READ_BYTE(dr_dtr);
d614 1
a614 1
		DZ_WRITE_BYTE(dr_dtr, DZ_READ_BYTE(dr_dtr) | bit);
d616 1
a616 1
		DZ_WRITE_BYTE(dr_dtr, DZ_READ_BYTE(dr_dtr) & ~bit);
d621 1
a621 1
		DZ_WRITE_BYTE(dr_break, sc->sc_brk);
d624 1
a624 1
		DZ_WRITE_BYTE(dr_break, sc->sc_brk);
d658 1
a658 1
			if ((DZ_READ_BYTE(dr_dcd) | sc->sc_dsr) & bit) {
d663 2
a664 2
				DZ_WRITE_BYTE(dr_tcr, 
				    (DZ_READ_WORD(dr_tcrw) & 255) & ~bit);
d677 1
a677 1
		csr = DZ_READ_WORD(dr_csr);
d681 1
a681 1
				DZ_WRITE_WORD(dr_csr, csr | DZ_CSR_SAE);
d684 1
a684 1
				DZ_WRITE_WORD(dr_csr, csr & ~(DZ_CSR_SAE));
d723 1
a723 1
	while (DZ_READ_WORD(dr_rbuf) & DZ_RBUF_DATA_VALID)
@


1.13
log
@Sync dz and lk{kbd,ms} code with NetBSD, this allows keyboards to work when
initialized by the PROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.12 2004/09/19 21:34:42 mickey Exp $	*/
d291 1
a291 1
	/* if some other device is using the line, it's busy */
d293 1
a293 1
		return EBUSY;
@


1.12
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.11 2004/07/07 23:10:46 deraadt Exp $	*/
a70 7
/* A DZ-11 has 8 ports while a DZV/DZQ-11 has only 4. We use 8 by default */

#define	NDZLINE 	8

#define DZ_C2I(c)	((c)<<3)	/* convert controller # to index */
#define DZ_I2C(c)	((c)>>3)	/* convert minor to controller # */
#define DZ_PORT(u)	((u)&07)	/* extract the port # */
a120 3
#define DZ_DZ	8		/* Unibus DZ-11 board linecount */
#define DZ_DZV	4		/* Q-bus DZV-11 or DZQ-11 */

d136 3
a138 1
	for (n = 0; n < sc->sc_type; n++)
d140 1
a149 1
	return;
d192 1
a192 1
#if defined(DDB) && (defined(VAX410) || defined(VAX43) || defined(VAX46) || defined(VAX53))
d258 2
d288 7
a297 3
	if (line >= sc->sc_type)
		return ENXIO;

d403 1
d480 2
a481 1
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
d483 1
d492 2
a493 1
	if (cl->c_cc == 0)
d495 1
a698 1
	return;
d716 1
a716 1
		if (((tp->t_state & TS_ISOPEN) == 0))
d730 2
a731 1
dzdrain(struct dz_softc *sc) {
@


1.11
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.10 2003/06/02 23:27:58 millert Exp $	*/
d86 1
a86 1
static struct speedtab dzspeedtab[] =
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.9 2003/04/02 23:45:29 jason Exp $	*/
a147 3

	evcnt_attach(&sc->sc_dev, "rintr", &sc->sc_rintrcnt);
	evcnt_attach(&sc->sc_dev, "tintr", &sc->sc_tintrcnt);
@


1.9
log
@DZ-11 (or the DZ-11 alike in the VS4000/VLC anyway) only interrupts when
the RX fifo goes from 0 -> 1 characters.  If the FIFO is filled (eg. during
autoconf where interrupts are cleared), the dz will never interrupt for
rx again.  Solution: drain the fifo on first open.  ok hugh
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.8 2002/02/15 20:45:30 nordin Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.7 2002/01/16 20:50:17 miod Exp $	*/
d116 1
d144 1
d301 3
d367 1
d729 9
@


1.7
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.6 2001/08/25 13:33:37 hugh Exp $	*/
d332 1
a332 1
	(void) splx(s);
d561 1
a561 1
	(void) splx(s);
d616 1
a616 1
		(void) splx(s);
d634 1
a634 1
	(void) splx(s);
d695 1
a695 1
	(void) splx(s);
@


1.6
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.5 2001/08/19 23:54:27 miod Exp $	*/
a44 1
#include <sys/map.h>
@


1.6.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.7 2002/01/16 20:50:17 miod Exp $	*/
d45 1
@


1.6.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.6.4.1 2002/01/31 22:55:26 niklas Exp $	*/
d332 1
a332 1
	splx(s);
d561 1
a561 1
	splx(s);
d616 1
a616 1
		splx(s);
d634 1
a634 1
	splx(s);
d695 1
a695 1
	splx(s);
@


1.6.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a115 1
static	void	dzdrain(struct dz_softc *);
a142 1
	dzdrain(sc);
a298 3
	if (sc->sc_openings++ == 0)
		dzdrain(sc);

a361 1
	sc->sc_openings--;
a722 9
}

/*
 * Drain RX fifo.
 */
static void
dzdrain(struct dz_softc *sc) {
	while (DZ_READ_WORD(dr_rbuf) & DZ_RBUF_DATA_VALID)
		/*EMPTY*/;
@


1.5
log
@The end of old timeouts is near...
@
text
@d1 2
a2 2
/*	$OpenBSD: dz.c,v 1.4 2001/06/15 22:45:33 miod Exp $	*/
/*	$NetBSD: dz.c,v 1.19 2000/01/24 02:40:29 matt Exp $	*/
d113 4
a116 4
static	void	dzstart __P((struct tty *));
static	int	dzparam __P((struct tty *, struct termios *));
static unsigned	dzmctl __P((struct dz_softc *, int, int, int));
static	void	dzscan __P((void *));
d136 1
a136 2
dzattach(sc)
        struct dz_softc *sc;
d138 1
a138 1
	register int n;
d152 3
d169 1
a169 2
dzrint(arg)
	void *arg;
d172 3
a174 3
	register struct tty *tp;
	register int cc, line;
	register unsigned c;
d224 1
a224 2
dzxint(arg)
	void *arg;
d226 4
a229 4
	register struct dz_softc *sc = arg;
	register struct tty *tp;
	register struct clist *cl;
	register int line, ch, csr;
a272 3
		if (sc->sc_dz[line].dz_catch)
			continue;

d286 1
a286 4
dzopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d288 2
a289 2
	register struct tty *tp;
	register int unit, line;
d341 1
a341 4
dzclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d344 2
a345 2
	register struct tty *tp;
	register int unit, line;
d367 1
a367 3
dzread (dev, uio, flag)
	dev_t dev;
	struct uio *uio;
d369 1
a369 1
	register struct tty *tp;
d379 1
a379 3
dzwrite (dev, uio, flag)
	dev_t dev;
	struct uio *uio;
d381 1
a381 1
	register struct tty *tp;
d392 1
a392 6
dzioctl (dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d395 2
a396 2
	register struct tty *tp;
	register int unit, line;
d452 1
a452 2
dztty (dev)
        dev_t dev;
d462 1
a462 2
dzstop(tp, flag)
	register struct tty *tp;
a463 3
	int s;

	s = spltty();
d467 1
a467 3
	splx(s);

	return 0;
d471 1
a471 2
dzstart(tp)
	register struct tty *tp;
d473 3
a475 3
	register struct dz_softc *sc;
	register struct clist *cl;
	register int unit, line, s;
d507 1
a507 3
dzparam(tp, t)
	register struct tty *tp;
	register struct termios *t;
d510 1
a510 1
	register int cflag = t->c_cflag;
d514 1
a514 1
	register unsigned lpr;
d567 5
a571 7
dzmctl(sc, line, bits, how)
	register struct dz_softc *sc;
	int line, bits, how;
{
	register unsigned status;
	register unsigned mbits;
	register unsigned bit;
d644 1
a644 2
dzscan(arg)
	void *arg;
d646 3
a648 3
	register struct dz_softc *sc;
	register struct tty *tp;
	register int n, bit, port;
d699 25
@


1.4
log
@Compile kernel with -Wall, and fix a few issues for this to work.
ok hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.3 2001/05/16 22:15:18 hugh Exp $	*/
d53 1
d130 2
d157 2
a158 1
		timeout(dzscan, (void *)0, hz);
d728 1
a728 1
	timeout(dzscan, (void *)0, hz);
@


1.3
log
@Blind merge of wscons support from NetBSD/vax. Perhaps someone with a
supported framebuffer (simple monochrome) can finish this off.
If anyone has run across docs for LCG or SPGFX, please get in touch.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.2 2001/01/28 01:19:59 hugh Exp $	*/
d480 3
d486 3
@


1.2
log
@Basic support for boardtype 1303 (Cheetah) machines.
Layout of the DZ's registers (among other things) determined
by a massive amount of trial and error.
Work by Brandon and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.1 2000/04/27 03:14:47 bjc Exp $	*/
d180 2
a181 1
		if (sc->sc_catch && (*sc->sc_catch)(line, cc))
d268 3
@


1.2.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.2 2001/01/28 01:19:59 hugh Exp $	*/
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.2.4.1 2001/05/14 21:38:20 niklas Exp $	*/
d180 1
a180 2
		if (sc->sc_dz[line].dz_catch &&
		    (*sc->sc_dz[line].dz_catch)(sc->sc_dz[line].dz_private, cc))
a267 3
		if (sc->sc_dz[line].dz_catch)
			continue;

a475 3
	int s;

	s = spltty();
a478 3
	splx(s);

	return 0;
@


1.2.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: dz.c,v 1.2.4.2 2001/07/04 10:24:31 niklas Exp $	*/
/*	$NetBSD: dz.c,v 1.23 2000/06/04 02:14:12 matt Exp $	*/
a52 1
#include <sys/timeout.h>
d112 4
a115 4
static	void	dzstart(struct tty *);
static	int	dzparam(struct tty *, struct termios *);
static	unsigned	dzmctl(struct dz_softc *, int, int, int);
static	void	dzscan(void *);
a128 2
struct timeout dz_timeout;

d133 2
a134 1
dzattach(struct dz_softc *sc)
d136 1
a136 1
	int n;
a149 3
	evcnt_attach(&sc->sc_dev, "rintr", &sc->sc_rintrcnt);
	evcnt_attach(&sc->sc_dev, "tintr", &sc->sc_tintrcnt);

d154 1
a154 2
		timeout_set(&dz_timeout, dzscan, NULL);
		timeout_add(&dz_timeout, hz);
d163 2
a164 1
dzrint(void *arg)
d167 3
a169 3
	struct tty *tp;
	int cc, line;
	unsigned c;
d219 2
a220 1
dzxint(void *arg)
d222 4
a225 4
	struct dz_softc *sc = arg;
	struct tty *tp;
	struct clist *cl;
	int line, ch, csr;
d269 3
d285 4
a288 1
dzopen(dev_t dev, int flag, int mode, struct proc *p)
d290 2
a291 2
	struct tty *tp;
	int unit, line;
d343 4
a346 1
dzclose(dev_t dev, int flag, int mode, struct proc *p)
d349 2
a350 2
	struct tty *tp;
	int unit, line;
d372 3
a374 1
dzread(dev_t dev, struct uio *uio, int flag)
d376 1
a376 1
	struct tty *tp;
d386 3
a388 1
dzwrite(dev_t dev, struct uio *uio, int flag)
d390 1
a390 1
	struct tty *tp;
d401 6
a406 1
dzioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d409 2
a410 2
	struct tty *tp;
	int unit, line;
d466 2
a467 1
dztty(dev_t dev)
d477 2
a478 1
dzstop(struct tty *tp, int flag)
d480 3
d486 3
a488 1
	return(0);
d492 2
a493 1
dzstart(struct tty *tp)
d495 3
a497 3
	struct dz_softc *sc;
	struct clist *cl;
	int unit, line, s;
d529 3
a531 1
dzparam(struct tty *tp, struct termios *t)
d534 1
a534 1
	int cflag = t->c_cflag;
d538 1
a538 1
	unsigned lpr;
d591 7
a597 5
dzmctl(struct dz_softc *sc, int line, int bits, int how)
{
	unsigned status;
	unsigned mbits;
	unsigned bit;
d670 2
a671 1
dzscan(void *arg)
d673 3
a675 3
	struct dz_softc *sc;
	struct tty *tp;
	int n, bit, port;
d724 1
a724 1
	timeout_add(&dz_timeout, hz);
a725 25
}

/*
 * Called after an ubareset. The DZ card is reset, but the only thing
 * that must be done is to start the receiver and transmitter again.
 * No DMA setup to care about.
 */
void
dzreset(struct device *dev)
{
	struct dz_softc *sc = (void *)dev;
	struct tty *tp;
	int i;

	for (i = 0; i < sc->sc_type; i++) {
		tp = sc->sc_dz[i].dz_tty;

		if (((tp->t_state & TS_ISOPEN) == 0))
			continue;

		dzparam(tp, &tp->t_termios);
		dzmctl(sc, i, DML_DTR, DMSET);
		tp->t_state &= ~TS_BUSY;
		dzstart(tp);    /* Kick off transmitter again */
	}
@


1.2.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
d333 1
a333 1
	splx(s);
d562 1
a562 1
	splx(s);
d617 1
a617 1
		splx(s);
d635 1
a635 1
	splx(s);
d696 1
a696 1
	splx(s);
@


1.2.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.2.4.4 2002/03/06 02:04:48 niklas Exp $	*/
a115 1
static	void	dzdrain(struct dz_softc *);
a142 1
	dzdrain(sc);
a298 3
	if (sc->sc_openings++ == 0)
		dzdrain(sc);

a361 1
	sc->sc_openings--;
a722 9
}

/*
 * Drain RX fifo.
 */
static void
dzdrain(struct dz_softc *sc) {
	while (DZ_READ_WORD(dr_rbuf) & DZ_RBUF_DATA_VALID)
		/*EMPTY*/;
@


1.2.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.2.4.5 2003/05/13 19:41:10 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dz.c,v 1.3 1997/05/29 00:05:06 niklas Exp $	*/
d200 1
a200 1
#if defined(DDB) && (defined(VAX410) || defined(VAX43) || defined(VAX46))
@

