head	1.13;
access;
symbols
	OPENBSD_5_9:1.12.0.22
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.24
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.16
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.20
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.18
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.14
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.12
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.10
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.12;
commitid	OSDG2O3Cgeifnf1W;

1.12
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.28.14.13.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.03.14.47;	author bjc;	state Exp;
branches
	1.1.8.1
	1.1.12.1;
next	;

1.1.8.1
date	2001.05.14.21.38.18;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	1.1.8.5;

1.1.8.5
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.01.31.22.55.26;	author niklas;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: dl.c,v 1.12 2010/07/02 17:27:01 nicm Exp $	*/
/*	$NetBSD: dl.c,v 1.11 2000/01/24 02:40:29 matt Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997  Ben Harris.  All rights reserved.
 * Copyright (c) 1996  Ken C. Wellsch.  All rights reserved.
 * Copyright (c) 1982, 1986, 1990, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * dl.c -- Device driver for the DL11 and DLV11 serial cards.
 *
 * OS-interface code derived from the dz and dca (hp300) drivers.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/scb.h>

#include <arch/vax/qbus/ubavar.h>
#include <arch/vax/qbus/dlreg.h>

struct dl_softc {
	struct device	sc_dev;
	bus_space_tag_t	sc_iot;
	bus_space_handle_t sc_ioh;
	struct tty	*sc_tty;
};

static	int	dl_match(struct device *, struct cfdata *, void *);
static	void	dl_attach(struct device *, struct device *, void *);
static	void	dlrint(void *);
static	void	dlxint(void *);
static	void	dlstart(struct tty *);
static	int	dlparam(struct tty *, struct termios *);
static	void	dlbrk(struct dl_softc *, int);
struct	tty *	dltty(dev_t);
	int	dlopen(dev_t, int, int, struct proc *);
	int	dlclose(dev_t, int, int, struct proc *);
	int	dlread(dev_t, struct uio *, int);
	int	dlwrite(dev_t, struct uio *, int);
	int	dlioctl(dev_t, int, caddr_t, int, struct proc *);
	void	dlstop(struct tty *, int);

struct cfattach dl_ca = {
	sizeof(struct dl_softc), (cfmatch_t)dl_match, dl_attach
};

struct	cfdriver dl_cd = {
	NULL, "dl", DV_TTY
};

#define	DL_READ_WORD(reg) \
	bus_space_read_2(sc->sc_iot, sc->sc_ioh, reg)
#define	DL_WRITE_WORD(reg, val) \
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, reg, val)
#define	DL_WRITE_BYTE(reg, val) \
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, reg, val)

/* Autoconfig handles: setup the controller to interrupt, */
/* then complete the housecleaning for full operation */

static int
dl_match (parent, cf, aux)
	struct device * parent;
	struct cfdata *cf;
	void *aux;
{
	struct uba_attach_args *ua = aux;

#ifdef DL_DEBUG
	printf("Probing for dl at %lo ... ", (long)ua->ua_iaddr);
#endif

	bus_space_write_2(ua->ua_iot, ua->ua_ioh, DL_UBA_XCSR, DL_XCSR_TXIE);
	if (bus_space_read_2(ua->ua_iot, ua->ua_ioh, DL_UBA_XCSR) !=
	    (DL_XCSR_TXIE | DL_XCSR_TX_READY)) {
#ifdef DL_DEBUG
	        printf("failed (step 1; XCSR = %.4b)\n", 
		    bus_space_read_2(ua->ua_iot, ua->ua_ioh, DL_UBA_XCSR), 
		    DL_XCSR_BITS);
#endif
		return 0;
	}
	
	/*
	 * We have to force an interrupt so the uba driver can work
	 * out where we are.  Unfortunately, the only way to make a
	 * DL11 interrupt is to get it to send or receive a
	 * character.  We'll send a NUL and hope it doesn't hurt
	 * anything.
	 */

	bus_space_write_1(ua->ua_iot, ua->ua_ioh, DL_UBA_XBUFL, '\0');
#if 0 /* This test seems to fail 2/3 of the time :-( */
	if (dladdr->dl_xcsr != (DL_XCSR_TXIE)) {
#ifdef DL_DEBUG
	        printf("failed (step 2; XCSR = %.4b)\n", dladdr->dl_xcsr,
		       DL_XCSR_BITS);
#endif
		return 0;
	}
#endif
	DELAY(100000); /* delay 1/10 s for character to transmit */
	if (bus_space_read_2(ua->ua_iot, ua->ua_ioh, DL_UBA_XCSR) !=
	    (DL_XCSR_TXIE | DL_XCSR_TX_READY)) {
#ifdef DL_DEBUG
	        printf("failed (step 3; XCSR = %.4b)\n", 
		    bus_space_read_2(ua->ua_iot, ua->ua_ioh, DL_UBA_XCSR),
		    DL_XCSR_BITS);
#endif
		return 0;
	}


        /* What else do I need to do? */

	return 1;

}

static void
dl_attach (parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct dl_softc *sc = (void *)self;
	register struct uba_attach_args *ua = aux;

	sc->sc_iot = ua->ua_iot;
	sc->sc_ioh = ua->ua_ioh;
	
	/* Tidy up the device */

	DL_WRITE_WORD(DL_UBA_RCSR, DL_RCSR_RXIE);
	DL_WRITE_WORD(DL_UBA_XCSR, DL_XCSR_TXIE);

	/* Initialize our softc structure. Should be done in open? */
	
	sc->sc_tty = ttymalloc(0);

	/* Now register the TX & RX interrupt handlers */
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec    , dlxint, sc);
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec - 4, dlrint, sc);

	printf("\n");
}

/* Receiver Interrupt Handler */

static void
dlrint(arg)
	void *arg;
{
	struct	dl_softc *sc = arg;
	register struct tty *tp;
	register int cc;
	register unsigned c;

	if (DL_READ_WORD(DL_UBA_RCSR) & DL_RCSR_RX_DONE) {
	        c = DL_READ_WORD(DL_UBA_RBUF);
		cc = c & 0xFF;
		tp = sc->sc_tty;

		if (!(tp->t_state & TS_ISOPEN)) {
			wakeup((caddr_t)&tp->t_rawq);
			return;
		}

		if (c & DL_RBUF_OVERRUN_ERR)
			/*
			 * XXX: This should really be logged somwhere
			 * else where we can afford the time.
			 */
			log(LOG_WARNING, "%s: rx overrun\n",
			    sc->sc_dev.dv_xname);
		if (c & DL_RBUF_FRAMING_ERR)
			cc |= TTY_FE;
		if (c & DL_RBUF_PARITY_ERR)
			cc |= TTY_PE;

		(*linesw[tp->t_line].l_rint)(cc, tp);
	} else
		log(LOG_WARNING, "%s: stray rx interrupt\n",
		    sc->sc_dev.dv_xname);
	return;
}

/* Transmitter Interrupt Handler */

static void
dlxint(arg)
	void *arg;
{
	struct dl_softc *sc = arg;
	register struct tty *tp;
	
	tp = sc->sc_tty;
	tp->t_state &= ~(TS_BUSY | TS_FLUSH);
	if (tp->t_line)
		(*linesw[tp->t_line].l_start)(tp);
	else
		dlstart(tp);
       
	return;
}

int
dlopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct tty *tp;
	register int unit;
	struct dl_softc *sc;

	unit = minor(dev);

	if (unit >= dl_cd.cd_ndevs || dl_cd.cd_devs[unit] == NULL)
		return ENXIO;
	sc = dl_cd.cd_devs[unit];

	tp = sc->sc_tty;
	if (tp == NULL)
		return ENODEV;
	tp->t_oproc = dlstart;
	tp->t_param = dlparam;
	tp->t_dev = dev;

	if (!(tp->t_state & TS_ISOPEN)) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		/* No modem control, so set CLOCAL. */
		tp->t_cflag = TTYDEF_CFLAG | CLOCAL;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		
		dlparam(tp, &tp->t_termios);
		ttsetwater(tp);
		
	} else if ((tp->t_state & TS_XCLUDE) && suser(p, 0) != 0)
		return EBUSY;

	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

/*ARGSUSED*/
int
dlclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct dl_softc *sc;
	register struct tty *tp;
	register int unit;

	unit = minor(dev);
	sc = dl_cd.cd_devs[unit];
      	tp = sc->sc_tty;

	(*linesw[tp->t_line].l_close)(tp, flag, p);

	/* Make sure a BREAK state is not left enabled. */
	dlbrk(sc, 0);

	return (ttyclose(tp));
}

int
dlread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	register struct tty *tp;
	struct dl_softc *sc;
	register int unit;

	unit = minor(dev);
	sc = dl_cd.cd_devs[unit];
	tp = sc->sc_tty;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
dlwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	register struct tty *tp;
	struct dl_softc *sc;
	register int unit;

	unit = minor(dev);
	sc = dl_cd.cd_devs[unit];
	tp = sc->sc_tty;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

int
dlioctl(dev, cmd, data, flag, p)
	dev_t dev;
        int cmd;
        caddr_t data;
        int flag;
        struct proc *p;
{
	struct dl_softc *sc;
        register struct tty *tp;
        register int unit;
        int error;

	unit = minor(dev);
	sc = dl_cd.cd_devs[unit];
	tp = sc->sc_tty;

        error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
        if (error >= 0)
                return (error);
        error = ttioctl(tp, cmd, data, flag, p);
        if (error >= 0)
                return (error);

	switch (cmd) {
	       
        case TIOCSBRK:
                dlbrk(sc, 1);
                break;

        case TIOCCBRK:
                dlbrk(sc, 0);
                break;

        case TIOCMGET:
		/* No modem control, assume they're all low. */
                *(int *)data = 0;
                break;

        default:
                return (ENOTTY);
        }
        return (0);
}

struct tty *
dltty(dev)
	dev_t dev;
{
	register struct dl_softc* sc;
	
	sc = dl_cd.cd_devs[minor(dev)];
	return sc->sc_tty;
}

void
dlstop(tp, flag)
	register struct tty *tp;
	int flag;
{
	register struct dl_softc *sc;
	int unit, s;

	unit = minor(tp->t_dev);
	sc = dl_cd.cd_devs[unit];

	s = spltty();

	if (tp->t_state & TS_BUSY)
                if (!(tp->t_state & TS_TTSTOP))
                        tp->t_state |= TS_FLUSH;
        splx(s);
}

static void
dlstart(tp)
	register struct tty *tp;
{
	register struct dl_softc *sc;
	register int unit;
	int s;

	unit = minor(tp->t_dev);
	sc = dl_cd.cd_devs[unit];

	s = spltty();
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
		goto out;
	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto out;

	if (DL_READ_WORD(DL_UBA_XCSR) & DL_XCSR_TX_READY) {
		tp->t_state |= TS_BUSY;
		DL_WRITE_BYTE(DL_UBA_XBUFL, getc(&tp->t_outq));
	}
out:
	splx(s);
	return;
}

/*ARGSUSED*/
static int
dlparam(tp, t)
        register struct tty *tp;
        register struct termios *t;
{
	/*
	 * All this kind of stuff (speed, character format, whatever)
	 * is set by jumpers on the card.  Changing it is thus rather
	 * tricky for a mere device driver.
	 */
	return 0;
}

static void
dlbrk(sc, state)
	register struct dl_softc *sc;
	int state;
{
	int s = spltty();

	if (state) {
		DL_WRITE_WORD(DL_UBA_XCSR, DL_READ_WORD(DL_UBA_XCSR) |
		    DL_XCSR_TX_BREAK);
	} else {
		DL_WRITE_WORD(DL_UBA_XCSR, DL_READ_WORD(DL_UBA_XCSR) &
		    ~DL_XCSR_TX_BREAK);
	}
	splx(s);
}
@


1.12
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.11 2010/06/28 14:13:31 deraadt Exp $	*/
@


1.11
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.10 2010/04/12 12:57:52 tedu Exp $	*/
d459 5
a463 12
        if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
                goto out;
        if (tp->t_outq.c_cc <= tp->t_lowat) {
                if (tp->t_state & TS_ASLEEP) {
                        tp->t_state &= ~TS_ASLEEP;
                        wakeup((caddr_t)&tp->t_outq);
                }
                selwakeup(&tp->t_wsel);
        }
        if (tp->t_outq.c_cc == 0)
                goto out;

@


1.10
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.9 2009/11/09 17:53:39 nicm Exp $	*/
d209 1
a209 1
	sc->sc_tty = ttymalloc();
@


1.9
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.8 2009/10/31 12:00:07 fgsch Exp $	*/
d315 1
a315 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d333 1
a333 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.8
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.7 2009/10/31 06:40:16 deraadt Exp $	*/
a466 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.7
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.6 2008/06/26 05:42:14 ray Exp $	*/
d312 1
a312 1
	} else if ((tp->t_state & TS_XCLUDE) && p->p_ucred->cr_uid != 0)
@


1.6
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.5 2003/10/03 16:44:50 miod Exp $	*/
d467 1
@


1.5
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.4 2003/06/02 23:27:58 millert Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.3 2002/03/14 01:26:48 millert Exp $	*/
a216 1
	tty_attach(sc->sc_tty);
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.2 2002/01/16 20:50:17 miod Exp $	*/
d57 1
a57 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.1 2000/04/27 03:14:47 bjc Exp $	*/
d110 14
a123 14
static	int	dl_match __P((struct device *, struct cfdata *, void *));
static	void	dl_attach __P((struct device *, struct device *, void *));
static	void	dlrint __P((void *));
static	void	dlxint __P((void *));
static	void	dlstart __P((struct tty *));
static	int	dlparam __P((struct tty *, struct termios *));
static	void	dlbrk __P((struct dl_softc *, int));
struct	tty *	dltty __P((dev_t));
	int	dlopen __P((dev_t, int, int, struct proc *));
	int	dlclose __P((dev_t, int, int, struct proc *));
	int	dlread __P((dev_t, struct uio *, int));
	int	dlwrite __P((dev_t, struct uio *, int));
	int	dlioctl __P((dev_t, int, caddr_t, int, struct proc *));
	void	dlstop __P((struct tty *, int));
@


1.1
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.2 1998/05/11 14:59:05 niklas Exp $	*/
a88 1
#include <sys/map.h>
@


1.1.12.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.2 2002/01/16 20:50:17 miod Exp $	*/
d89 1
@


1.1.12.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.1.12.1 2002/01/31 22:55:26 niklas Exp $	*/
d110 14
a123 14
static	int	dl_match(struct device *, struct cfdata *, void *);
static	void	dl_attach(struct device *, struct device *, void *);
static	void	dlrint(void *);
static	void	dlxint(void *);
static	void	dlstart(struct tty *);
static	int	dlparam(struct tty *, struct termios *);
static	void	dlbrk(struct dl_softc *, int);
struct	tty *	dltty(dev_t);
	int	dlopen(dev_t, int, int, struct proc *);
	int	dlclose(dev_t, int, int, struct proc *);
	int	dlread(dev_t, struct uio *, int);
	int	dlwrite(dev_t, struct uio *, int);
	int	dlioctl(dev_t, int, caddr_t, int, struct proc *);
	void	dlstop(struct tty *, int);
@


1.1.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.1 2000/04/27 03:14:47 bjc Exp $	*/
@


1.1.8.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 1
@


1.1.8.3
log
@Merge in -current from about a week ago
@
text
@d110 14
a123 14
static	int	dl_match(struct device *, struct cfdata *, void *);
static	void	dl_attach(struct device *, struct device *, void *);
static	void	dlrint(void *);
static	void	dlxint(void *);
static	void	dlstart(struct tty *);
static	int	dlparam(struct tty *, struct termios *);
static	void	dlbrk(struct dl_softc *, int);
struct	tty *	dltty(dev_t);
	int	dlopen(dev_t, int, int, struct proc *);
	int	dlclose(dev_t, int, int, struct proc *);
	int	dlread(dev_t, struct uio *, int);
	int	dlwrite(dev_t, struct uio *, int);
	int	dlioctl(dev_t, int, caddr_t, int, struct proc *);
	void	dlstop(struct tty *, int);
@


1.1.8.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.1.8.3 2002/03/28 11:26:46 niklas Exp $	*/
d57 5
a61 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.8.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d217 1
@


