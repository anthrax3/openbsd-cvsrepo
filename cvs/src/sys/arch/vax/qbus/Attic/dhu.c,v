head	1.20;
access;
symbols
	OPENBSD_5_9:1.19.0.20
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.22
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.14
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.18
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.16
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.12.0.22
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.18
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.16
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.19;
commitid	OSDG2O3Cgeifnf1W;

1.19
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.28.14.13.31;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.19.21.34.42;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.07.23.10.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.06.01.34.56;	author hugh;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.06.01.33.32;	author hugh;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.03.22.47.27;	author hugh;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.27.19.20.49;	author hugh;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.19.22.40.44;	author hugh;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.03.14.47;	author bjc;	state Exp;
branches
	1.1.8.1
	1.1.12.1;
next	;

1.1.8.1
date	2001.05.14.21.38.16;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.1.8.5;

1.1.8.5
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	1.1.8.6;

1.1.8.6
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	;

1.1.12.1
date	2002.01.31.22.55.26;	author niklas;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.1.12.3;

1.1.12.3
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	1.1.12.4;

1.1.12.4
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: dhu.c,v 1.19 2010/09/20 06:33:48 matthew Exp $	*/
/*	$NetBSD: dhu.c,v 1.19 2000/06/04 06:17:01 matt Exp $	*/
/*
 * Copyright (c) 2003, Hugh Graham.
 * Copyright (c) 1996  Ken C. Wellsch.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/scb.h>

#include <arch/vax/qbus/ubavar.h>
#include <arch/vax/qbus/dhureg.h>

#define	NDHULINE 	16

#define DHU_M2U(c)	((c)>>4)	/* convert minor(dev) to unit # */
#define DHU_LINE(u)	((u)&0xF)	/* extract line # from minor(dev) */

struct	dhu_softc {
	struct	device	sc_dev;		/* Device struct used by config */
	struct	evcount	sc_rintrcnt;	/* Interrupt statistics */
	struct	evcount	sc_tintrcnt;	/* Interrupt statistics */
	int	sc_rcvec, sc_tcvec;
	int		sc_type;	/* controller type, DHU or DHV */
	int		sc_lines;	/* number of lines */
	bus_space_tag_t	sc_iot;
	bus_space_handle_t sc_ioh;
	bus_dma_tag_t	sc_dmat;
	struct {
		struct	tty *dhu_tty;	/* what we work on */
		bus_dmamap_t dhu_dmah;
		int	dhu_state;	/* to manage TX output status */
		short	dhu_cc;		/* character count on TX */
		short	dhu_modem;	/* modem bits state */
	} sc_dhu[NDHULINE];
};

#define IS_DHU			16	/* Unibus DHU-11 board linecount */
#define IS_DHV			 8	/* Q-bus DHV-11 or DHQ-11 */

#define STATE_IDLE		000	/* no current output in progress */
#define STATE_DMA_RUNNING	001	/* DMA TX in progress */
#define STATE_DMA_STOPPED	002	/* DMA TX was aborted */
#define STATE_TX_ONE_CHAR	004	/* did a single char directly */

/* Flags used to monitor modem bits, make them understood outside driver */

#define DML_DTR		TIOCM_DTR
#define DML_RTS		TIOCM_RTS
#define DML_CTS		TIOCM_CTS
#define DML_DCD		TIOCM_CD
#define DML_RI		TIOCM_RI
#define DML_DSR		TIOCM_DSR
#define DML_BRK		0100000		/* no equivalent, we will mask */

#define DHU_READ_WORD(reg) \
	bus_space_read_2(sc->sc_iot, sc->sc_ioh, reg)
#define DHU_WRITE_WORD(reg, val) \
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, reg, val)
#define DHU_READ_BYTE(reg) \
	bus_space_read_1(sc->sc_iot, sc->sc_ioh, reg)
#define DHU_WRITE_BYTE(reg, val) \
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, reg, val)


/*  On a stock DHV, channel pairs (0/1, 2/3, etc.) must use */
/* a baud rate from the same group.  So limiting to B is likely */
/* best, although clone boards like the ABLE QHV allow all settings. */

static const struct speedtab dhuspeedtab[] = {
  {       0,	0		},	/* Groups  */
  {      50,	DHU_LPR_B50	},	/* A	   */
  {      75,	DHU_LPR_B75	},	/* 	 B */
  {     110,	DHU_LPR_B110	},	/* A and B */
  {     134,	DHU_LPR_B134	},	/* A and B */
  {     150,	DHU_LPR_B150	},	/* 	 B */
  {     300,	DHU_LPR_B300	},	/* A and B */
  {     600,	DHU_LPR_B600	},	/* A and B */
  {    1200,	DHU_LPR_B1200	},	/* A and B */
  {    1800,	DHU_LPR_B1800	},	/* 	 B */
  {    2000,	DHU_LPR_B2000	},	/* 	 B */
  {    2400,	DHU_LPR_B2400	},	/* A and B */
  {    4800,	DHU_LPR_B4800	},	/* A and B */
  {    7200,	DHU_LPR_B7200	},	/* A	   */
  {    9600,	DHU_LPR_B9600	},	/* A and B */
  {   19200,	DHU_LPR_B19200	},	/* 	 B */
  {   38400,	DHU_LPR_B38400	},	/* A	   */
  {      -1,	-1		}
};

static int	dhu_match(struct device *, struct cfdata *, void *);
static void	dhu_attach(struct device *, struct device *, void *);
static	void	dhurint(void *);
static	void	dhuxint(void *);
static	void	dhustart(struct tty *);
static	int	dhuparam(struct tty *, struct termios *);
static	int	dhuiflow(struct tty *, int);
static unsigned	dhumctl(struct dhu_softc *,int, int, int);
	int	dhuopen(dev_t, int, int, struct proc *);
	int	dhuclose(dev_t, int, int, struct proc *);
	int	dhuread(dev_t, struct uio *, int);
	int	dhuwrite(dev_t, struct uio *, int);
	int	dhuioctl(dev_t, u_long, caddr_t, int, struct proc *);
	void	dhustop(struct tty *, int);
struct tty *	dhutty(dev_t);

struct	cfattach dhu_ca = {
	sizeof(struct dhu_softc), (cfmatch_t)dhu_match, dhu_attach
};

struct	cfdriver dhu_cd = {
	NULL, "dhu", DV_TTY
};

/* Autoconfig handles: setup the controller to interrupt, */
/* then complete the housecleaning for full operation */

static int
dhu_match(parent, cf, aux)
        struct device *parent;
	struct cfdata *cf;
        void *aux;
{
	struct uba_attach_args *ua = aux;
	int n;

	/* Reset controller to initialize, enable TX/RX interrupts */
	/* to catch floating vector info elsewhere when completed */

	bus_space_write_2(ua->ua_iot, ua->ua_ioh, DHU_UBA_CSR,
	    DHU_CSR_MASTER_RESET | DHU_CSR_RXIE | DHU_CSR_TXIE);

	/* Now wait up to 3 seconds for self-test to complete. */

	for (n = 0; n < 300; n++) {
		DELAY(10000);
		if ((bus_space_read_2(ua->ua_iot, ua->ua_ioh, DHU_UBA_CSR) &
		    DHU_CSR_MASTER_RESET) == 0)
			break;
	}

	/* If the RESET did not clear after 3 seconds, */
	/* the controller must be broken. */

	if (n >= 300)
		return 0;

	/* Check whether diagnostic run has signalled a failure. */

	if ((bus_space_read_2(ua->ua_iot, ua->ua_ioh, DHU_UBA_CSR) &
	    DHU_CSR_DIAG_FAIL) != 0)
		return 0;

       	return 1;
}

static void
dhu_attach(parent, self, aux)
        struct device *parent, *self;
        void *aux;
{
	struct dhu_softc *sc = (void *)self;
	struct uba_attach_args *ua = aux;
	unsigned c;
	int n, i;

	sc->sc_iot = ua->ua_iot;
	sc->sc_ioh = ua->ua_ioh;
	sc->sc_dmat = ua->ua_dmat;
	/* Process the 8 bytes of diagnostic info put into */
	/* the FIFO following the master reset operation. */

	printf("\n%s:", self->dv_xname);
	for (n = 0; n < 8; n++) {
		c = DHU_READ_WORD(DHU_UBA_RBUF);

		if ((c&DHU_DIAG_CODE) == DHU_DIAG_CODE) {
			if ((c&0200) == 0000)
				printf(" rom(%d) version %d",
					((c>>1)&01), ((c>>2)&037));
			else if (((c>>2)&07) != 0)
				printf(" diag-error(proc%d)=%x",
					((c>>1)&01), ((c>>2)&07));
		}
	}

	c = DHU_READ_WORD(DHU_UBA_STAT);

	sc->sc_type = (c & DHU_STAT_DHU) ? IS_DHU : IS_DHV;

	if (sc->sc_type == IS_DHU) {
		if (c & DHU_STAT_MDL)
			sc->sc_lines = 16;	/* "Modem Low" */
		else
			sc->sc_lines = 8;	/* Has modem support */
	} else
		sc->sc_lines = 8;

	printf("\n%s: DH%s-11 %d lines\n", self->dv_xname,
	    (sc->sc_type == IS_DHU) ? "U" : "V", sc->sc_lines);

	for (i = 0; i < sc->sc_lines; i++) {
		struct tty *tp;
		tp = sc->sc_dhu[i].dhu_tty = ttymalloc(0);
		sc->sc_dhu[i].dhu_state = STATE_IDLE;
		bus_dmamap_create(sc->sc_dmat, tp->t_outq.c_cn, 1, 
		    tp->t_outq.c_cn, 0, BUS_DMA_ALLOCNOW|BUS_DMA_NOWAIT,
		    &sc->sc_dhu[i].dhu_dmah);
		bus_dmamap_load(sc->sc_dmat, sc->sc_dhu[i].dhu_dmah,
		    tp->t_outq.c_cs, tp->t_outq.c_cn, 0, BUS_DMA_NOWAIT);
			
	}

	/* Now establish RX & TX interrupt handlers */

	uba_intr_establish(ua->ua_icookie, ua->ua_cvec,
	    dhurint, sc, &sc->sc_rintrcnt);
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec + 4,
	    dhuxint, sc, &sc->sc_tintrcnt);

	sc->sc_rcvec = ua->ua_cvec;
	evcount_attach(&sc->sc_rintrcnt, sc->sc_dev.dv_xname, &sc->sc_rcvec);
	sc->sc_tcvec = ua->ua_cvec + 4;
	evcount_attach(&sc->sc_tintrcnt, sc->sc_dev.dv_xname, &sc->sc_tcvec);
}

/* Receiver Interrupt */

static void
dhurint(arg)
	void *arg;
{
	struct	dhu_softc *sc = arg;
	struct tty *tp;
	int cc, line;
	unsigned c, delta;
	int overrun = 0;

	while ((c = DHU_READ_WORD(DHU_UBA_RBUF)) & DHU_RBUF_DATA_VALID) {

		/* Ignore diagnostic FIFO entries. */

		if ((c & DHU_DIAG_CODE) == DHU_DIAG_CODE)
			continue;

		cc = c & 0xFF;
		line = DHU_LINE(c>>8);
		tp = sc->sc_dhu[line].dhu_tty;

		/* LINK.TYPE is set so we get modem control FIFO entries */

		if ((c & DHU_DIAG_CODE) == DHU_MODEM_CODE) {
			c = (c << 8);
			/* Do MDMBUF flow control, wakeup sleeping opens */
			if (c & DHU_STAT_DCD) {
				if (!(tp->t_state & TS_CARR_ON))
				    (void)(*linesw[tp->t_line].l_modem)(tp, 1);
			}
			else if ((tp->t_state & TS_CARR_ON) &&
			    (*linesw[tp->t_line].l_modem)(tp, 0) == 0)
				(void) dhumctl(sc, line, 0, DMSET);

			/* Do CRTSCTS flow control */
			delta = c ^ sc->sc_dhu[line].dhu_modem;
			sc->sc_dhu[line].dhu_modem = c;
			if ((delta & DHU_STAT_CTS) &&
			    (tp->t_state & TS_ISOPEN) &&
			    (tp->t_cflag & CRTSCTS)) {
				if (c & DHU_STAT_CTS) {
					tp->t_state &= ~TS_TTSTOP;
					ttstart(tp);
				} else {
					tp->t_state |= TS_TTSTOP;
					dhustop(tp, 0);
				}
			}
			continue;
		}

		if (!(tp->t_state & TS_ISOPEN)) {
			wakeup((caddr_t)&tp->t_rawq);
			continue;
		}

		if ((c & DHU_RBUF_OVERRUN_ERR) && overrun == 0) {
			log(LOG_WARNING, "%s: silo overflow, line %d\n",
				sc->sc_dev.dv_xname, line);
			overrun = 1;
		}
		/* A BREAK key will appear as a NULL with a framing error */
		if (c & DHU_RBUF_FRAMING_ERR)
			cc |= TTY_FE;
		if (c & DHU_RBUF_PARITY_ERR)
			cc |= TTY_PE;

		(*linesw[tp->t_line].l_rint)(cc, tp);
	}
}

/* Transmitter Interrupt */

static void
dhuxint(arg)
	void *arg;
{
	struct	dhu_softc *sc = arg;
	struct tty *tp;
	int line, i;

	while ((i = DHU_READ_BYTE(DHU_UBA_CSR_HI)) & (DHU_CSR_TX_ACTION >> 8)) {

		line = DHU_LINE(i);

		tp = sc->sc_dhu[line].dhu_tty;

		if (i & (DHU_CSR_TX_DMA_ERROR >> 8))
			printf("dhu%d: DMA ERROR on line: %d\n",
			    DHU_M2U(minor(tp->t_dev)), line);

		if (i & (DHU_CSR_DIAG_FAIL >> 8))
			printf("dhu%d: DIAG FAIL on line: %d\n",
			    DHU_M2U(minor(tp->t_dev)), line);

		tp->t_state &= ~TS_BUSY;

		if (tp->t_state & TS_FLUSH)
			tp->t_state &= ~TS_FLUSH;
		else {
			if (sc->sc_dhu[line].dhu_state == STATE_DMA_STOPPED)
				sc->sc_dhu[line].dhu_cc -= 
				DHU_READ_WORD(DHU_UBA_TBUFCNT);
			ndflush(&tp->t_outq, sc->sc_dhu[line].dhu_cc);
			sc->sc_dhu[line].dhu_cc = 0;
		}

		sc->sc_dhu[line].dhu_state = STATE_IDLE;

		if (tp->t_line)
			(*linesw[tp->t_line].l_start)(tp);
		else
			dhustart(tp);
	}
}

int
dhuopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct tty *tp;
	int unit, line;
	struct dhu_softc *sc;
	int s, error = 0;

	unit = DHU_M2U(minor(dev));
	line = DHU_LINE(minor(dev));

	if (unit >= dhu_cd.cd_ndevs || dhu_cd.cd_devs[unit] == NULL)
		return (ENXIO);

	sc = dhu_cd.cd_devs[unit];

	if (line >= sc->sc_lines)
		return ENXIO;

	if (sc->sc_type == IS_DHU) {
		s = spltty();		/* CSR 3:0 must be 0 */
		DHU_WRITE_BYTE(DHU_UBA_CSR, DHU_CSR_RXIE);
		DHU_WRITE_BYTE(DHU_UBA_RXTIME, 10);
		splx(s);		/* RX int delay 10ms */
	}

	s = spltty();
	DHU_WRITE_BYTE(DHU_UBA_CSR, DHU_CSR_RXIE | line);
	sc->sc_dhu[line].dhu_modem = DHU_READ_WORD(DHU_UBA_STAT);
	splx(s);

	tp = sc->sc_dhu[line].dhu_tty;

	tp->t_oproc   = dhustart;
	tp->t_param   = dhuparam;
	tp->t_hwiflow = dhuiflow;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN; /* XXX */
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		}
		(void) dhuparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if ((tp->t_state & TS_XCLUDE) && suser(curproc, 0) != 0)
		return (EBUSY);
	/* Use DMBIS and *not* DMSET or else we clobber incoming bits */
	if (dhumctl(sc, line, DML_DTR|DML_RTS, DMBIS) & DML_DCD)
		tp->t_state |= TS_CARR_ON;
	s = spltty();
	while (!(flag & O_NONBLOCK) && !(tp->t_cflag & CLOCAL) &&
	       !(tp->t_state & TS_CARR_ON)) {
		tp->t_state |= TS_WOPEN; /* XXX */
		error = ttysleep(tp, (caddr_t)&tp->t_rawq,
				TTIPRI | PCATCH, ttopen, 0);
		if (error)
			break;
	}
	splx(s);
	if (error)
		return (error);
	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

/*ARGSUSED*/
int
dhuclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct tty *tp;
	int unit, line;
	struct dhu_softc *sc;

	unit = DHU_M2U(minor(dev));
	line = DHU_LINE(minor(dev));

	sc = dhu_cd.cd_devs[unit];

	tp = sc->sc_dhu[line].dhu_tty;

	(*linesw[tp->t_line].l_close)(tp, flag, p);

	/* Make sure a BREAK state is not left enabled. */

	(void) dhumctl(sc, line, DML_BRK, DMBIC);

	/* Do a hangup if so required. */

	if ((tp->t_cflag & HUPCL) || (tp->t_state & TS_WOPEN) || /* XXX */
	    !(tp->t_state & TS_ISOPEN))
		(void) dhumctl(sc, line, 0, DMSET);

	return (ttyclose(tp));
}

int
dhuread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
{
	struct dhu_softc *sc;
	struct tty *tp;

	sc = dhu_cd.cd_devs[DHU_M2U(minor(dev))];

	tp = sc->sc_dhu[DHU_LINE(minor(dev))].dhu_tty;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
dhuwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
{
	struct dhu_softc *sc;
	struct tty *tp;

	sc = dhu_cd.cd_devs[DHU_M2U(minor(dev))];

	tp = sc->sc_dhu[DHU_LINE(minor(dev))].dhu_tty;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

/*ARGSUSED*/
int
dhuioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct dhu_softc *sc;
	struct tty *tp;
	int unit, line;
	int error;

	unit = DHU_M2U(minor(dev));
	line = DHU_LINE(minor(dev));
	sc = dhu_cd.cd_devs[unit];
	tp = sc->sc_dhu[line].dhu_tty;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {

	case TIOCSBRK:
		(void) dhumctl(sc, line, DML_BRK, DMBIS);
		break;

	case TIOCCBRK:
		(void) dhumctl(sc, line, DML_BRK, DMBIC);
		break;

	case TIOCSDTR:
		(void) dhumctl(sc, line, DML_DTR|DML_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) dhumctl(sc, line, DML_DTR|DML_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) dhumctl(sc, line, *(int *)data, DMSET);
		break;

	case TIOCMBIS:
		(void) dhumctl(sc, line, *(int *)data, DMBIS);
		break;

	case TIOCMBIC:
		(void) dhumctl(sc, line, *(int *)data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = (dhumctl(sc, line, 0, DMGET) & ~DML_BRK);
		break;

	default:
		return (ENOTTY);
	}
	return (0);
}

struct tty *
dhutty(dev)
        dev_t dev;
{
	struct dhu_softc *sc = dhu_cd.cd_devs[DHU_M2U(minor(dev))];
	struct tty *tp = sc->sc_dhu[DHU_LINE(minor(dev))].dhu_tty;
        return (tp);
}

/*ARGSUSED*/
void
dhustop(tp, flag)
	struct tty *tp;
{
	struct dhu_softc *sc;
	int line;
	int s;

	s = spltty();

	if (tp->t_state & TS_BUSY) {

		sc = dhu_cd.cd_devs[DHU_M2U(minor(tp->t_dev))];
		line = DHU_LINE(minor(tp->t_dev));

		if (sc->sc_dhu[line].dhu_state == STATE_DMA_RUNNING) {

			sc->sc_dhu[line].dhu_state = STATE_DMA_STOPPED;

			DHU_WRITE_BYTE(DHU_UBA_CSR, DHU_CSR_RXIE | line);
			DHU_WRITE_WORD(DHU_UBA_LNCTRL, 
			    DHU_READ_WORD(DHU_UBA_LNCTRL) | 
			    DHU_LNCTRL_DMA_ABORT);
		}

		if (!(tp->t_state & TS_TTSTOP))
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
}

static void
dhustart(tp)
	struct tty *tp;
{
	struct dhu_softc *sc;
	int line, cc;
	int addr;
	int s;

	s = spltty();

	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
		goto out;
	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto out;
	cc = ndqb(&tp->t_outq, 0);
	if (cc == 0) 
		goto out;

	tp->t_state |= TS_BUSY;

	sc = dhu_cd.cd_devs[DHU_M2U(minor(tp->t_dev))];

	line = DHU_LINE(minor(tp->t_dev));

	DHU_WRITE_BYTE(DHU_UBA_CSR, DHU_CSR_RXIE | line);

	sc->sc_dhu[line].dhu_cc = cc;

	if (cc == 1 && sc->sc_type == IS_DHV) {

		sc->sc_dhu[line].dhu_state = STATE_TX_ONE_CHAR;
		
		DHU_WRITE_WORD(DHU_UBA_TXCHAR, 
		    DHU_TXCHAR_DATA_VALID | *tp->t_outq.c_cf);
	} else {
		sc->sc_dhu[line].dhu_state = STATE_DMA_RUNNING;

		addr = sc->sc_dhu[line].dhu_dmah->dm_segs[0].ds_addr +
			(tp->t_outq.c_cf - tp->t_outq.c_cs);

		DHU_WRITE_WORD(DHU_UBA_TBUFCNT, cc);
		DHU_WRITE_WORD(DHU_UBA_TBUFAD1, addr & 0xFFFF);
		DHU_WRITE_WORD(DHU_UBA_TBUFAD2, ((addr>>16) & 0x3F) |
		    DHU_TBUFAD2_TX_ENABLE);
		DHU_WRITE_WORD(DHU_UBA_LNCTRL, 
		    DHU_READ_WORD(DHU_UBA_LNCTRL) & ~DHU_LNCTRL_DMA_ABORT);
		DHU_WRITE_WORD(DHU_UBA_TBUFAD2,
		    DHU_READ_WORD(DHU_UBA_TBUFAD2) | DHU_TBUFAD2_DMA_START);
	}
out:
	splx(s);
	return;
}

static int
dhuparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct dhu_softc *sc;
	int cflag = t->c_cflag;
	int ispeed = ttspeedtab(t->c_ispeed, dhuspeedtab);
	int ospeed = ttspeedtab(t->c_ospeed, dhuspeedtab);
	unsigned lpr, lnctrl;
	int unit, line;
	int s;

	unit = DHU_M2U(minor(tp->t_dev));
	line = DHU_LINE(minor(tp->t_dev));

	sc = dhu_cd.cd_devs[unit];

	/* check requested parameters */
        if (ospeed < 0 || ispeed < 0)
                return (EINVAL);

        tp->t_ispeed = t->c_ispeed;
        tp->t_ospeed = t->c_ospeed;
        tp->t_cflag = cflag;

	if (ospeed == 0) {
		(void) dhumctl(sc, line, 0, DMSET);	/* hang up line */
		return (0);
	}

	s = spltty();
	DHU_WRITE_BYTE(DHU_UBA_CSR, DHU_CSR_RXIE | line);

	lpr = ((ispeed&017)<<8) | ((ospeed&017)<<12) ;

	switch (cflag & CSIZE) {

	case CS5:
		lpr |= DHU_LPR_5_BIT_CHAR;
		break;

	case CS6:
		lpr |= DHU_LPR_6_BIT_CHAR;
		break;

	case CS7:
		lpr |= DHU_LPR_7_BIT_CHAR;
		break;

	default:
		lpr |= DHU_LPR_8_BIT_CHAR;
		break;
	}

	if (cflag & PARENB)
		lpr |= DHU_LPR_PARENB;
	if (!(cflag & PARODD))
		lpr |= DHU_LPR_EPAR;
	if (cflag & CSTOPB)
		lpr |= DHU_LPR_2_STOP;

	DHU_WRITE_WORD(DHU_UBA_LPR, lpr);

	DHU_WRITE_WORD(DHU_UBA_TBUFAD2, 
	    DHU_READ_WORD(DHU_UBA_TBUFAD2) | DHU_TBUFAD2_TX_ENABLE);

	lnctrl = DHU_READ_WORD(DHU_UBA_LNCTRL);

	/* Setting LINK.TYPE enables modem signal change interrupts. */

	lnctrl |= (DHU_LNCTRL_RX_ENABLE | DHU_LNCTRL_LINK_TYPE);

	/* Enable the auto XON/XOFF feature on the controller */

	if (t->c_iflag & IXON)
		lnctrl |= DHU_LNCTRL_OAUTO;
	else
		lnctrl &= ~DHU_LNCTRL_OAUTO;

	if (t->c_iflag & IXOFF)
		lnctrl |= DHU_LNCTRL_IAUTO;
	else
		lnctrl &= ~DHU_LNCTRL_IAUTO;

	DHU_WRITE_WORD(DHU_UBA_LNCTRL, lnctrl);

	splx(s);
	return (0);
}

static int
dhuiflow(tp, flag)
	struct tty *tp;
	int flag;
{
	struct dhu_softc *sc;
	int line = DHU_LINE(minor(tp->t_dev));

	if (tp->t_cflag & CRTSCTS) {
		sc = dhu_cd.cd_devs[DHU_M2U(minor(tp->t_dev))];
		(void) dhumctl(sc, line, DML_RTS, ((flag)? DMBIC: DMBIS));
		return (1);
	}
	return (0);
}

static unsigned
dhumctl(sc, line, bits, how)
	struct dhu_softc *sc;
	int line, bits, how;
{
	unsigned status;
	unsigned lnctrl;
	unsigned mbits;
	int s;

	s = spltty();

	DHU_WRITE_BYTE(DHU_UBA_CSR, DHU_CSR_RXIE | line);

	mbits = 0;

	/* external signals as seen from the port */

	status = DHU_READ_WORD(DHU_UBA_STAT);

	if (status & DHU_STAT_CTS)
		mbits |= DML_CTS;

	if (status & DHU_STAT_DCD)
		mbits |= DML_DCD;

	if (status & DHU_STAT_DSR)
		mbits |= DML_DSR;

	if (status & DHU_STAT_RI)
		mbits |= DML_RI;

	/* internal signals/state delivered to port */

	lnctrl = DHU_READ_WORD(DHU_UBA_LNCTRL);

	if (lnctrl & DHU_LNCTRL_RTS)
		mbits |= DML_RTS;

	if (lnctrl & DHU_LNCTRL_DTR)
		mbits |= DML_DTR;

	if (lnctrl & DHU_LNCTRL_BREAK)
		mbits |= DML_BRK;

	switch (how) {

	case DMSET:
		mbits = bits;
		break;

	case DMBIS:
		mbits |= bits;
		break;

	case DMBIC:
		mbits &= ~bits;
		break;

	case DMGET:
		splx(s);
		return (mbits);
	}

	if (mbits & DML_RTS)
		lnctrl |= DHU_LNCTRL_RTS;
	else
		lnctrl &= ~DHU_LNCTRL_RTS;

	if (mbits & DML_DTR)
		lnctrl |= DHU_LNCTRL_DTR;
	else
		lnctrl &= ~DHU_LNCTRL_DTR;

	if (mbits & DML_BRK)
		lnctrl |= DHU_LNCTRL_BREAK;
	else
		lnctrl &= ~DHU_LNCTRL_BREAK;

	DHU_WRITE_WORD(DHU_UBA_LNCTRL, lnctrl);

	splx(s);
	return (mbits);
}
@


1.19
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.18 2010/07/02 17:27:01 nicm Exp $	*/
@


1.18
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.17 2010/06/28 14:13:31 deraadt Exp $	*/
d264 1
a264 2
	evcount_attach(&sc->sc_rintrcnt, sc->sc_dev.dv_xname,
	    (void *)&sc->sc_rcvec, &evcount_intr);
d266 1
a266 2
	evcount_attach(&sc->sc_tintrcnt, sc->sc_dev.dv_xname,
	    (void *)&sc->sc_tcvec, &evcount_intr);
@


1.17
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.16 2010/04/12 12:57:52 tedu Exp $	*/
d642 1
a642 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.16
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.15 2009/11/09 17:53:39 nicm Exp $	*/
d246 1
a246 1
		tp = sc->sc_dhu[i].dhu_tty = ttymalloc();
@


1.15
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.14 2009/10/31 12:00:07 fgsch Exp $	*/
d458 1
a458 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d479 1
a479 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.14
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.13 2009/10/31 06:40:16 deraadt Exp $	*/
a647 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.13
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.12 2004/09/19 21:34:42 mickey Exp $	*/
d441 1
a441 1
	} else if ((tp->t_state & TS_XCLUDE) && curproc->p_ucred->cr_uid != 0)
@


1.12
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.11 2004/07/07 23:10:45 deraadt Exp $	*/
d648 1
@


1.11
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.10 2003/06/02 23:27:58 millert Exp $	*/
d112 1
a112 1
static struct speedtab dhuspeedtab[] = {
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.9 2003/04/06 01:34:56 hugh Exp $	*/
d63 3
a65 2
	struct	evcnt	sc_rintrcnt;	/* Interrupt statistics */
	struct	evcnt	sc_tintrcnt;	/* Interrupt statistics */
d262 7
a268 2
	evcnt_attach(&sc->sc_dev, "rintr", &sc->sc_rintrcnt);
	evcnt_attach(&sc->sc_dev, "tintr", &sc->sc_tintrcnt);
@


1.9
log
@remove an erroneous comment
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.8 2003/04/06 01:33:32 hugh Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Significant DHU driver fixups:
.  immediately service all available action reports in the transmit
.  interrupt handler so we don't exhaust the action report fifo and
.  hang the device when under high load
.
.  set receive interrupt delay to 10ms if the hardware supports it,
.  vastly reducing interrupts by allowing the receive fifo to fill
.
.  always use dma when in DHU11 mode
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.7 2003/04/03 22:47:27 hugh Exp $	*/
a58 2

/* A DHU-11 has 16 ports while a DHV-11 has only 8. We use 16 by default */
@


1.7
log
@Real DHUs don't have a TXCHAR register, so write directly to the fifo
instead. Driver now transmits successfully in both DHV and DHU mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.6 2002/12/27 19:20:49 hugh Exp $	*/
d4 1
d304 2
a305 2
				(*linesw[tp->t_line].l_modem)(tp, 0) == 0)
					(void) dhumctl(sc, line, 0, DMSET);
d352 3
a354 1
	int line;
d356 1
a356 1
	line = DHU_LINE(DHU_READ_BYTE(DHU_UBA_CSR_HI));
d358 1
a358 1
	tp = sc->sc_dhu[line].dhu_tty;
d360 19
a378 10
	tp->t_state &= ~TS_BUSY;
	if (tp->t_state & TS_FLUSH)
		tp->t_state &= ~TS_FLUSH;
	else {
		if (sc->sc_dhu[line].dhu_state == STATE_DMA_STOPPED)
			sc->sc_dhu[line].dhu_cc -= 
			DHU_READ_WORD(DHU_UBA_TBUFCNT);
		ndflush(&tp->t_outq, sc->sc_dhu[line].dhu_cc);
		sc->sc_dhu[line].dhu_cc = 0;
	}
d380 1
a380 1
	sc->sc_dhu[line].dhu_state = STATE_IDLE;
d382 5
a386 4
	if (tp->t_line)
		(*linesw[tp->t_line].l_start)(tp);
	else
		dhustart(tp);
d411 7
d639 1
d665 1
a665 1
	if (cc == 1) {
d669 2
a670 6
		if (sc->sc_type == IS_DHU) {
			/* should check for room in fifo first */
			DHU_WRITE_BYTE(DHU_UBA_FIFO, *tp->t_outq.c_cf);
		} else
			DHU_WRITE_WORD(DHU_UBA_TXCHAR, 
			    DHU_TXCHAR_DATA_VALID | *tp->t_outq.c_cf);
a671 1

@


1.6
log
@Use model control capability to distinguish 8 from 16 line models,
and don't ttymalloc lines we don't have. CXA16 in DHV-11 mode is
probably still not correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.5 2002/10/19 22:40:44 hugh Exp $	*/
d71 1
d235 1
a235 1
	sc->sc_type = (c & DHU_STAT_DHU)? IS_DHU: IS_DHV;
d239 1
a239 1
			i = 16;		/* "Modem Low" */
d241 1
a241 1
			i = 8;		/* Has modem support */
d243 1
a243 1
		i = 8;
d246 1
a246 1
	    (sc->sc_type == IS_DHU) ? "U" : "V", i);
d248 1
a248 3
	sc->sc_type = i;

	for (i = 0; i < sc->sc_type; i++) {
d395 1
a395 1
	if (line >= sc->sc_type)
d648 6
a653 3
		DHU_WRITE_WORD(DHU_UBA_TXCHAR, 
		    DHU_TXCHAR_DATA_VALID | *tp->t_outq.c_cf);

@


1.5
log
@Kill register.
Add intvec counting.
Adapt to openbsd WOPEN handling.
All untested but does compile...
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.4 2002/03/14 01:26:48 millert Exp $	*/
d235 13
a247 1
	printf("\n%s: DH%s-11\n", self->dv_xname, (c & DHU_STAT_DHU)?"U":"V");
@


1.4
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: dhu.c,v 1.3 2002/02/15 20:45:30 nordin Exp $	*/
/*	$NetBSD: dhu.c,v 1.17 2000/01/24 02:40:28 matt Exp $	*/
d68 2
d170 1
a170 1
	register int n;
d207 4
a210 4
	register struct dhu_softc *sc = (void *)self;
	register struct uba_attach_args *ua = aux;
	register unsigned c;
	register int n, i;
d251 6
a256 2
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec    , dhurint, sc);
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec + 4, dhuxint, sc);
d266 3
a268 3
	register struct tty *tp;
	register int cc, line;
	register unsigned c, delta;
d338 3
a340 3
	register struct	dhu_softc *sc = arg;
	register struct tty *tp;
	register int line;
d371 2
a372 2
	register struct tty *tp;
	register int unit, line;
d399 1
d418 1
d437 2
a438 2
	register struct tty *tp;
	register int unit, line;
d456 3
a458 2
	if ((tp->t_cflag & HUPCL) || !(tp->t_state & TS_ISOPEN))
   		(void) dhumctl(sc, line, 0, DMSET);
d468 2
a469 2
	register struct dhu_softc *sc;
	register struct tty *tp;
d482 2
a483 2
	register struct dhu_softc *sc;
	register struct tty *tp;
d500 3
a502 3
	register struct dhu_softc *sc;
	register struct tty *tp;
	register int unit, line;
d569 1
a569 1
	register struct tty *tp;
d571 2
a572 2
	register struct dhu_softc *sc;
	register int line;
d600 1
a600 1
	register struct tty *tp;
d602 3
a604 3
	register struct dhu_softc *sc;
	register int line, cc;
	register int addr;
d663 2
a664 2
	register struct tty *tp;
	register struct termios *t;
d667 1
a667 1
	register int cflag = t->c_cflag;
d670 1
a670 1
	register unsigned lpr, lnctrl;
d757 2
a758 2
	register struct dhu_softc *sc;
	register int line = DHU_LINE(minor(tp->t_dev));
d773 3
a775 3
	register unsigned status;
	register unsigned lnctrl;
	register unsigned mbits;
@


1.3
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.2 2002/01/16 20:50:17 miod Exp $	*/
d134 15
a148 15
static int	dhu_match __P((struct device *, struct cfdata *, void *));
static void	dhu_attach __P((struct device *, struct device *, void *));
static	void	dhurint __P((void *));
static	void	dhuxint __P((void *));
static	void	dhustart __P((struct tty *));
static	int	dhuparam __P((struct tty *, struct termios *));
static	int	dhuiflow __P((struct tty *, int));
static unsigned	dhumctl __P((struct dhu_softc *,int, int, int));
	int	dhuopen __P((dev_t, int, int, struct proc *));
	int	dhuclose __P((dev_t, int, int, struct proc *));
	int	dhuread __P((dev_t, struct uio *, int));
	int	dhuwrite __P((dev_t, struct uio *, int));
	int	dhuioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
	void	dhustop __P((struct tty *, int));
struct tty *	dhutty __P((dev_t));
@


1.2
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.1 2000/04/27 03:14:47 bjc Exp $	*/
d384 1
a384 1
	(void) splx(s);
d416 1
a416 1
	(void) splx(s);
d586 1
a586 1
	(void) splx(s);
d648 1
a648 1
	(void) splx(s);
d739 1
a739 1
	(void) splx(s);
d819 1
a819 1
		(void) splx(s);
d840 1
a840 1
	(void) splx(s);
@


1.1
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.4 1997/05/29 00:05:05 niklas Exp $	*/
a44 1
#include <sys/map.h>
@


1.1.12.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.2 2002/01/16 20:50:17 miod Exp $	*/
d45 1
@


1.1.12.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.1.12.1 2002/01/31 22:55:26 niklas Exp $	*/
d134 15
a148 15
static int	dhu_match(struct device *, struct cfdata *, void *);
static void	dhu_attach(struct device *, struct device *, void *);
static	void	dhurint(void *);
static	void	dhuxint(void *);
static	void	dhustart(struct tty *);
static	int	dhuparam(struct tty *, struct termios *);
static	int	dhuiflow(struct tty *, int);
static unsigned	dhumctl(struct dhu_softc *,int, int, int);
	int	dhuopen(dev_t, int, int, struct proc *);
	int	dhuclose(dev_t, int, int, struct proc *);
	int	dhuread(dev_t, struct uio *, int);
	int	dhuwrite(dev_t, struct uio *, int);
	int	dhuioctl(dev_t, u_long, caddr_t, int, struct proc *);
	void	dhustop(struct tty *, int);
struct tty *	dhutty(dev_t);
d384 1
a384 1
	splx(s);
d416 1
a416 1
	splx(s);
d586 1
a586 1
	splx(s);
d648 1
a648 1
	splx(s);
d739 1
a739 1
	splx(s);
d819 1
a819 1
		splx(s);
d840 1
a840 1
	splx(s);
@


1.1.12.3
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: dhu.c,v 1.19 2000/06/04 06:17:01 matt Exp $	*/
a67 2
	struct	evcnt	sc_rintrcnt;	/* Interrupt statistics */
	struct	evcnt	sc_tintrcnt;	/* Interrupt statistics */
d168 1
a168 1
	int n;
d205 4
a208 4
	struct dhu_softc *sc = (void *)self;
	struct uba_attach_args *ua = aux;
	unsigned c;
	int n, i;
d249 2
a250 6
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec,
	    dhurint, sc, &sc->sc_rintrcnt);
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec + 4,
	    dhuxint, sc, &sc->sc_tintrcnt);
	evcnt_attach(&sc->sc_dev, "rintr", &sc->sc_rintrcnt);
	evcnt_attach(&sc->sc_dev, "tintr", &sc->sc_tintrcnt);
d260 3
a262 3
	struct tty *tp;
	int cc, line;
	unsigned c, delta;
d332 3
a334 3
	struct	dhu_softc *sc = arg;
	struct tty *tp;
	int line;
d365 2
a366 2
	struct tty *tp;
	int unit, line;
a392 1
		tp->t_state |= TS_WOPEN; /* XXX */
a410 1
		tp->t_state |= TS_WOPEN; /* XXX */
d429 2
a430 2
	struct tty *tp;
	int unit, line;
d448 2
a449 3
	if ((tp->t_cflag & HUPCL) || (tp->t_state & TS_WOPEN) || /* XXX */
	    !(tp->t_state & TS_ISOPEN))
		(void) dhumctl(sc, line, 0, DMSET);
d459 2
a460 2
	struct dhu_softc *sc;
	struct tty *tp;
d473 2
a474 2
	struct dhu_softc *sc;
	struct tty *tp;
d491 3
a493 3
	struct dhu_softc *sc;
	struct tty *tp;
	int unit, line;
d560 1
a560 1
	struct tty *tp;
d562 2
a563 2
	struct dhu_softc *sc;
	int line;
d591 1
a591 1
	struct tty *tp;
d593 3
a595 3
	struct dhu_softc *sc;
	int line, cc;
	int addr;
d654 2
a655 2
	struct tty *tp;
	struct termios *t;
d658 1
a658 1
	int cflag = t->c_cflag;
d661 1
a661 1
	unsigned lpr, lnctrl;
d748 2
a749 2
	struct dhu_softc *sc;
	int line = DHU_LINE(minor(tp->t_dev));
d764 3
a766 3
	unsigned status;
	unsigned lnctrl;
	unsigned mbits;
@


1.1.12.4
log
@sync
@
text
@a3 1
 * Copyright (c) 2003, Hugh Graham.
d59 2
a70 1
	int		sc_lines;	/* number of lines */
d234 2
a235 9
	sc->sc_type = (c & DHU_STAT_DHU) ? IS_DHU : IS_DHV;

	if (sc->sc_type == IS_DHU) {
		if (c & DHU_STAT_MDL)
			sc->sc_lines = 16;	/* "Modem Low" */
		else
			sc->sc_lines = 8;	/* Has modem support */
	} else
		sc->sc_lines = 8;
d237 1
a237 4
	printf("\n%s: DH%s-11 %d lines\n", self->dv_xname,
	    (sc->sc_type == IS_DHU) ? "U" : "V", sc->sc_lines);

	for (i = 0; i < sc->sc_lines; i++) {
d292 2
a293 2
			    (*linesw[tp->t_line].l_modem)(tp, 0) == 0)
				(void) dhumctl(sc, line, 0, DMSET);
d340 1
a340 1
	int line, i;
d342 1
a342 1
	while ((i = DHU_READ_BYTE(DHU_UBA_CSR_HI)) & (DHU_CSR_TX_ACTION >> 8)) {
d344 1
a344 1
		line = DHU_LINE(i);
d346 10
a355 1
		tp = sc->sc_dhu[line].dhu_tty;
d357 1
a357 19
		if (i & (DHU_CSR_TX_DMA_ERROR >> 8))
			printf("dhu%d: DMA ERROR on line: %d\n",
			    DHU_M2U(minor(tp->t_dev)), line);

		if (i & (DHU_CSR_DIAG_FAIL >> 8))
			printf("dhu%d: DIAG FAIL on line: %d\n",
			    DHU_M2U(minor(tp->t_dev)), line);

		tp->t_state &= ~TS_BUSY;

		if (tp->t_state & TS_FLUSH)
			tp->t_state &= ~TS_FLUSH;
		else {
			if (sc->sc_dhu[line].dhu_state == STATE_DMA_STOPPED)
				sc->sc_dhu[line].dhu_cc -= 
				DHU_READ_WORD(DHU_UBA_TBUFCNT);
			ndflush(&tp->t_outq, sc->sc_dhu[line].dhu_cc);
			sc->sc_dhu[line].dhu_cc = 0;
		}
d359 4
a362 7
		sc->sc_dhu[line].dhu_state = STATE_IDLE;

		if (tp->t_line)
			(*linesw[tp->t_line].l_start)(tp);
		else
			dhustart(tp);
	}
d384 1
a384 1
	if (line >= sc->sc_lines)
a386 7
	if (sc->sc_type == IS_DHU) {
		s = spltty();		/* CSR 3:0 must be 0 */
		DHU_WRITE_BYTE(DHU_UBA_CSR, DHU_CSR_RXIE);
		DHU_WRITE_BYTE(DHU_UBA_RXTIME, 10);
		splx(s);		/* RX int delay 10ms */
	}

a607 1

d633 1
a633 1
	if (cc == 1 && sc->sc_type == IS_DHV) {
d639 1
d641 1
@


1.1.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.1 2000/04/27 03:14:47 bjc Exp $	*/
@


1.1.8.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
d385 1
a385 1
	splx(s);
d417 1
a417 1
	splx(s);
d587 1
a587 1
	splx(s);
d649 1
a649 1
	splx(s);
d740 1
a740 1
	splx(s);
d820 1
a820 1
		splx(s);
d841 1
a841 1
	splx(s);
@


1.1.8.3
log
@Merge in -current from about a week ago
@
text
@d134 15
a148 15
static int	dhu_match(struct device *, struct cfdata *, void *);
static void	dhu_attach(struct device *, struct device *, void *);
static	void	dhurint(void *);
static	void	dhuxint(void *);
static	void	dhustart(struct tty *);
static	int	dhuparam(struct tty *, struct termios *);
static	int	dhuiflow(struct tty *, int);
static unsigned	dhumctl(struct dhu_softc *,int, int, int);
	int	dhuopen(dev_t, int, int, struct proc *);
	int	dhuclose(dev_t, int, int, struct proc *);
	int	dhuread(dev_t, struct uio *, int);
	int	dhuwrite(dev_t, struct uio *, int);
	int	dhuioctl(dev_t, u_long, caddr_t, int, struct proc *);
	void	dhustop(struct tty *, int);
struct tty *	dhutty(dev_t);
@


1.1.8.4
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: dhu.c,v 1.19 2000/06/04 06:17:01 matt Exp $	*/
a67 2
	struct	evcnt	sc_rintrcnt;	/* Interrupt statistics */
	struct	evcnt	sc_tintrcnt;	/* Interrupt statistics */
d168 1
a168 1
	int n;
d205 4
a208 4
	struct dhu_softc *sc = (void *)self;
	struct uba_attach_args *ua = aux;
	unsigned c;
	int n, i;
d233 1
a233 13

	if (sc->sc_type == IS_DHU) {
		if (c & DHU_STAT_MDL)
			i = 16;		/* "Modem Low" */
		else
			i = 8;		/* Has modem support */
	} else
		i = 8;

	printf("\n%s: DH%s-11 %d lines\n", self->dv_xname,
	    (sc->sc_type == IS_DHU) ? "U" : "V", i);

	sc->sc_type = i;
d249 2
a250 6
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec,
	    dhurint, sc, &sc->sc_rintrcnt);
	uba_intr_establish(ua->ua_icookie, ua->ua_cvec + 4,
	    dhuxint, sc, &sc->sc_tintrcnt);
	evcnt_attach(&sc->sc_dev, "rintr", &sc->sc_rintrcnt);
	evcnt_attach(&sc->sc_dev, "tintr", &sc->sc_tintrcnt);
d260 3
a262 3
	struct tty *tp;
	int cc, line;
	unsigned c, delta;
d332 3
a334 3
	struct	dhu_softc *sc = arg;
	struct tty *tp;
	int line;
d365 2
a366 2
	struct tty *tp;
	int unit, line;
a392 1
		tp->t_state |= TS_WOPEN; /* XXX */
a410 1
		tp->t_state |= TS_WOPEN; /* XXX */
d429 2
a430 2
	struct tty *tp;
	int unit, line;
d448 2
a449 3
	if ((tp->t_cflag & HUPCL) || (tp->t_state & TS_WOPEN) || /* XXX */
	    !(tp->t_state & TS_ISOPEN))
		(void) dhumctl(sc, line, 0, DMSET);
d459 2
a460 2
	struct dhu_softc *sc;
	struct tty *tp;
d473 2
a474 2
	struct dhu_softc *sc;
	struct tty *tp;
d491 3
a493 3
	struct dhu_softc *sc;
	struct tty *tp;
	int unit, line;
d560 1
a560 1
	struct tty *tp;
d562 2
a563 2
	struct dhu_softc *sc;
	int line;
d591 1
a591 1
	struct tty *tp;
d593 3
a595 3
	struct dhu_softc *sc;
	int line, cc;
	int addr;
d654 2
a655 2
	struct tty *tp;
	struct termios *t;
d658 1
a658 1
	int cflag = t->c_cflag;
d661 1
a661 1
	unsigned lpr, lnctrl;
d748 2
a749 2
	struct dhu_softc *sc;
	int line = DHU_LINE(minor(tp->t_dev));
d764 3
a766 3
	unsigned status;
	unsigned lnctrl;
	unsigned mbits;
@


1.1.8.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.1.8.4 2003/03/27 23:52:20 niklas Exp $	*/
a3 1
 * Copyright (c) 2003, Hugh Graham.
d59 2
a70 1
	int		sc_lines;	/* number of lines */
d234 1
a234 1
	sc->sc_type = (c & DHU_STAT_DHU) ? IS_DHU : IS_DHV;
d238 1
a238 1
			sc->sc_lines = 16;	/* "Modem Low" */
d240 1
a240 1
			sc->sc_lines = 8;	/* Has modem support */
d242 1
a242 1
		sc->sc_lines = 8;
d245 3
a247 1
	    (sc->sc_type == IS_DHU) ? "U" : "V", sc->sc_lines);
d249 1
a249 1
	for (i = 0; i < sc->sc_lines; i++) {
d304 2
a305 2
			    (*linesw[tp->t_line].l_modem)(tp, 0) == 0)
				(void) dhumctl(sc, line, 0, DMSET);
d352 1
a352 1
	int line, i;
d354 1
a354 1
	while ((i = DHU_READ_BYTE(DHU_UBA_CSR_HI)) & (DHU_CSR_TX_ACTION >> 8)) {
d356 1
a356 1
		line = DHU_LINE(i);
d358 10
a367 21
		tp = sc->sc_dhu[line].dhu_tty;

		if (i & (DHU_CSR_TX_DMA_ERROR >> 8))
			printf("dhu%d: DMA ERROR on line: %d\n",
			    DHU_M2U(minor(tp->t_dev)), line);

		if (i & (DHU_CSR_DIAG_FAIL >> 8))
			printf("dhu%d: DIAG FAIL on line: %d\n",
			    DHU_M2U(minor(tp->t_dev)), line);

		tp->t_state &= ~TS_BUSY;

		if (tp->t_state & TS_FLUSH)
			tp->t_state &= ~TS_FLUSH;
		else {
			if (sc->sc_dhu[line].dhu_state == STATE_DMA_STOPPED)
				sc->sc_dhu[line].dhu_cc -= 
				DHU_READ_WORD(DHU_UBA_TBUFCNT);
			ndflush(&tp->t_outq, sc->sc_dhu[line].dhu_cc);
			sc->sc_dhu[line].dhu_cc = 0;
		}
d369 1
a369 1
		sc->sc_dhu[line].dhu_state = STATE_IDLE;
d371 4
a374 5
		if (tp->t_line)
			(*linesw[tp->t_line].l_start)(tp);
		else
			dhustart(tp);
	}
d396 1
a396 1
	if (line >= sc->sc_lines)
a398 7
	if (sc->sc_type == IS_DHU) {
		s = spltty();		/* CSR 3:0 must be 0 */
		DHU_WRITE_BYTE(DHU_UBA_CSR, DHU_CSR_RXIE);
		DHU_WRITE_BYTE(DHU_UBA_RXTIME, 10);
		splx(s);		/* RX int delay 10ms */
	}

a619 1

d645 1
a645 1
	if (cc == 1 && sc->sc_type == IS_DHV) {
d651 1
d653 1
@


1.1.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dhu.c,v 1.1.8.5 2003/05/13 19:41:10 ho Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


