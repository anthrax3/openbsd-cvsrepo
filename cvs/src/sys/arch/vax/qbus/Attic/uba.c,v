head	1.16;
access;
symbols
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.18
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.16
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.16
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.18
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.14
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.12
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.10
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.15;
commitid	OSDG2O3Cgeifnf1W;

1.15
date	2015.09.13.12.31.35;	author miod;	state Exp;
branches;
next	1.14;
commitid	crsKIfL2CNapLk7x;

1.14
date	2015.02.01.15.27.11;	author miod;	state Exp;
branches;
next	1.13;
commitid	vfuvVKDlohAznQIf;

1.13
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.24.04.52.26;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.04.16.59.31;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.03.19.43.24;	author hugh;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.10.00.11.14;	author nordin;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.03.14.49;	author bjc;	state Exp;
branches
	1.1.8.1;
next	;

1.1.8.1
date	2001.05.14.21.38.29;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2002.03.06.02.04.48;	author niklas;	state Exp;
branches;
next	1.1.8.5;

1.1.8.5
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.1.8.6;

1.1.8.6
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	1.1.8.7;

1.1.8.7
date	2004.06.05.23.11.02;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.01.31.22.55.26;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: uba.c,v 1.15 2015/09/13 12:31:35 miod Exp $	*/
/*	$NetBSD: uba.c,v 1.57 2001/04/26 19:16:07 ragge Exp $	*/
/*
 * Copyright (c) 1996 Jonathan Stone.
 * Copyright (c) 1994, 1996 Ludd, University of Lule}, Sweden.
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uba.c	7.10 (Berkeley) 12/16/90
 *	@@(#)autoconf.c	7.20 (Berkeley) 5/9/91
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/scb.h>
#include <machine/cpu.h>

#include <arch/vax/uba/ubareg.h>
#include <arch/vax/qbus/ubavar.h>

static int ubasearch (struct device *, struct cfdata *, void *);
static int ubaprint (void *, const char *);

struct 	cfdriver uba_cd = {
	NULL, "uba", DV_DULL
};

/*
 * If we failed to allocate uba resources, put us on a queue to wait
 * until there is available resources. Resources to compete about
 * are map registers and BDPs. This is normally only a problem on
 * Unibus systems, Qbus systems have more map registers than usable.
 */
void
uba_enqueue(struct uba_unit *uu)
{
	struct uba_softc *uh;
	int s;

	uh = (void *)((struct device *)(uu->uu_softc))->dv_parent;

	s = splvm();
	SIMPLEQ_INSERT_TAIL(&uh->uh_resq, uu, uu_resq);
	splx(s);
}

/*
 * When a routine that uses resources is finished, the next device
 * in queue for map registers etc is called. If it succeeds to get
 * resources, call next, and next, and next...
 * This routine must be called at splvm.
 */
void
uba_done(struct uba_softc *uh)
{
	struct uba_unit *uu;
 
	while ((uu = SIMPLEQ_FIRST(&uh->uh_resq))) {
		SIMPLEQ_REMOVE_HEAD(&uh->uh_resq, uu_resq);
		if ((*uu->uu_ready)(uu) == 0) {
			SIMPLEQ_INSERT_HEAD(&uh->uh_resq, uu, uu_resq);
			break;
		}
	}
}

/*
 * Each device that needs some handling if an ubareset occurs must
 * register for reset first through this routine.
 */
void
uba_reset_establish(void (*reset)(struct device *), struct device *dev)
{
	struct uba_softc *uh = (void *)dev->dv_parent;
	struct uba_reset *ur;

	ur = malloc(sizeof(struct uba_reset), M_DEVBUF, M_NOWAIT);
	if (ur == NULL)
		panic("uba_reset_establish");
	ur->ur_dev = dev;
	ur->ur_reset = reset;

	SIMPLEQ_INSERT_TAIL(&uh->uh_resetq, ur, ur_resetq);
}

/*
 * Allocate a bunch of map registers and map them to the given address.
 */
int
uballoc(struct uba_softc *uh, struct ubinfo *ui, int flags)
{
	int waitok = (flags & UBA_CANTWAIT) == 0;
	int error;

	if ((error = bus_dmamap_create(uh->uh_dmat, ui->ui_size, 1,
	    ui->ui_size, 0, (waitok ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT),
	    &ui->ui_dmam)))
		return error;

	if ((error = bus_dmamap_load(uh->uh_dmat, ui->ui_dmam, ui->ui_vaddr,
	    ui->ui_size, NULL, (waitok ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT)))) {
		bus_dmamap_destroy(uh->uh_dmat, ui->ui_dmam);
		return error;
	}
	ui->ui_baddr = ui->ui_dmam->dm_segs[0].ds_addr;
	return 0;
}

/*
 * Allocate DMA-able memory and map it on the unibus.
 */
int
ubmemalloc(struct uba_softc *uh, struct ubinfo *ui, int flags)
{
	int waitok = (flags & UBA_CANTWAIT ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	int error;

	if ((error = bus_dmamem_alloc(uh->uh_dmat, ui->ui_size, NBPG, 0,
	    &ui->ui_seg, 1, &ui->ui_rseg, waitok)))
		return error;
	if ((error = bus_dmamem_map(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg,
	    ui->ui_size, &ui->ui_vaddr, waitok|BUS_DMA_COHERENT))) {
		bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
		return error;
	}
	if ((error = uballoc(uh, ui, flags))) {
		bus_dmamem_unmap(uh->uh_dmat, ui->ui_vaddr, ui->ui_size);
		bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
	}
	return error;
}

void
ubfree(struct uba_softc *uh, struct ubinfo *ui)
{
	bus_dmamap_unload(uh->uh_dmat, ui->ui_dmam);
	bus_dmamap_destroy(uh->uh_dmat, ui->ui_dmam);
}

void
ubmemfree(struct uba_softc *uh, struct ubinfo *ui)
{
	bus_dmamem_unmap(uh->uh_dmat, ui->ui_vaddr, ui->ui_size);
	bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
	ubfree(uh, ui);
}

/*
 * Generate a reset on uba number uban.	 Then
 * call each device that asked to be called during attach,
 * giving it a chance to clean up so as to be able to continue.
 */
void
ubareset(struct uba_softc *uh)
{
	struct uba_reset *ur;
	int s;

	s = splvm();
	SIMPLEQ_INIT(&uh->uh_resq);
	printf("%s: reset", uh->uh_dev.dv_xname);
	(*uh->uh_ubainit)(uh);

	ur = SIMPLEQ_FIRST(&uh->uh_resetq);
	if (ur) do {
		printf(" %s", ur->ur_dev->dv_xname);
		(*ur->ur_reset)(ur->ur_dev);
	} while ((ur = SIMPLEQ_NEXT(ur, ur_resetq)));

	printf("\n");
	splx(s);
}

/*
 * The common attach routine:
 *   Calls the scan routine to search for uba devices.
 */
void
uba_attach(struct uba_softc *sc, paddr_t iopagephys)
{

	/*
	 * Set last free interrupt vector for devices with
	 * programmable interrupt vectors.  Use is to decrement
	 * this number and use result as interrupt vector.
	 */
	sc->uh_lastiv = 0x200;
	SIMPLEQ_INIT(&sc->uh_resq);
	SIMPLEQ_INIT(&sc->uh_resetq);

	/*
	 * Allocate place for unibus I/O space in virtual space.
	 */
	if (bus_space_map(sc->uh_iot, iopagephys, UBAIOSIZE, 0, &sc->uh_ioh))
		return;

	if (sc->uh_beforescan)
		(*sc->uh_beforescan)(sc);
	/*
	 * Now start searching for devices.
	 */
	config_search((cfmatch_t)ubasearch,(struct device *)sc, NULL);

	if (sc->uh_afterscan)
		(*sc->uh_afterscan)(sc);
}

int
ubasearch(struct device *parent, struct cfdata *cf, void *aux)
{
	struct	uba_softc *sc = (struct uba_softc *)parent;
	struct	uba_attach_args ua;
	int	i, vec, br;

	ua.ua_ioh = ubdevreg(cf->cf_loc[0]) + sc->uh_ioh;
	ua.ua_iot = sc->uh_iot;
	ua.ua_dmat = sc->uh_dmat;

	if (badaddr((caddr_t)ua.ua_ioh, 2) ||
	    (sc->uh_errchk ? (*sc->uh_errchk)(sc):0))
		goto forgetit;

	scb_vecref(0, 0); /* Clear vector ref */
	i = (*cf->cf_attach->ca_match) (parent, cf, &ua);

	if (sc->uh_errchk)
		if ((*sc->uh_errchk)(sc))
			goto forgetit;
	if (i == 0)
		goto forgetit;

	i = scb_vecref(&vec, &br);
	if (i == 0)
		goto fail;
	if (vec == 0)
		goto fail;

	ua.ua_br = br;
	ua.ua_cvec = vec;
	ua.ua_iaddr = cf->cf_loc[0];

	config_attach(parent, cf, &ua, ubaprint);
	return 0;

fail:
	printf("%s%d at %s csr %lo %s\n",
	    cf->cf_driver->cd_name, cf->cf_unit, parent->dv_xname,
	    cf->cf_loc[0], (i ? "zero vector" : "didn't interrupt"));

forgetit:
	return 0;
}

/*
 * Print out some interesting info common to all unibus devices.
 */
int
ubaprint(void *aux, const char *uba)
{
	struct uba_attach_args *ua = aux;

	printf(" csr %o vec %d ipl %x", ua->ua_iaddr,
	    ua->ua_cvec & 511, ua->ua_br);
	return UNCONF;
}

/*
 * Move to machdep eventually
 */
void
uba_intr_establish(icookie, vec, ifunc, iarg, ev)
	void *icookie;
	int vec;
	void (*ifunc)(void *iarg);
	void *iarg;
	struct evcount *ev;
{
	scb_vecalloc(vec, ifunc, iarg, SCB_ISTACK, ev);
}
@


1.15
log
@Locators are long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.14 2015/02/01 15:27:11 miod Exp $	*/
@


1.14
log
@Gather the scattered (and sometimes duplicated) qbus address and size defines
to a single place. Get rid of the unused defines pertaining to older vax
models we dropped support for years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.13 2010/11/18 21:13:19 miod Exp $	*/
d282 1
a282 1
	printf("%s%d at %s csr %o %s\n",
@


1.13
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.12 2010/06/26 23:24:44 guenther Exp $	*/
d54 1
@


1.12
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.11 2005/11/24 04:52:26 brad Exp $	*/
a43 1
#include <sys/dkstat.h>
@


1.11
log
@splimp -> splvm

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.10 2004/07/07 23:10:46 deraadt Exp $	*/
a42 1
#include <sys/user.h>
@


1.10
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.9 2004/05/04 16:59:31 grange Exp $	*/
d79 1
a79 1
	s = splimp();
d88 1
a88 1
 * This routine must be called at splimp.
d196 1
a196 1
	s = splimp();
@


1.9
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.8 2003/06/02 23:27:58 millert Exp $	*/
d299 1
a299 1
	printf(" csr %o vec %o ipl %x", ua->ua_iaddr,
d313 1
a313 1
	struct evcnt *ev;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.7 2003/02/03 19:43:24 hugh Exp $	*/
d96 1
a96 1
		SIMPLEQ_REMOVE_HEAD(&uh->uh_resq, uu, uu_resq);
@


1.7
log
@From NetBSD: Add functions to allocate mapped-in qbus memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.6 2002/01/16 20:50:17 miod Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 2
a2 2
/*	$OpenBSD: uba.c,v 1.5 2002/01/10 00:11:14 nordin Exp $	*/
/*	$NetBSD: uba.c,v 1.52 2000/06/04 02:14:12 matt Exp $	   */
d125 62
@


1.5
log
@Check result from malloc(9) when using M_NOWAIT. hugh@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.4 2001/11/06 19:53:17 miod Exp $	*/
a44 1
#include <sys/map.h>
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.3 2001/09/11 20:05:25 miod Exp $	*/
d120 2
@


1.4.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.6 2002/01/16 20:50:17 miod Exp $	*/
d45 1
a119 2
	if (ur == NULL)
		panic("uba_reset_establish");
@


1.4.2.2
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uba.c,v 1.57 2001/04/26 19:16:07 ragge Exp $	*/
a124 62
}

/*
 * Allocate a bunch of map registers and map them to the given address.
 */
int
uballoc(struct uba_softc *uh, struct ubinfo *ui, int flags)
{
	int waitok = (flags & UBA_CANTWAIT) == 0;
	int error;

	if ((error = bus_dmamap_create(uh->uh_dmat, ui->ui_size, 1,
	    ui->ui_size, 0, (waitok ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT),
	    &ui->ui_dmam)))
		return error;

	if ((error = bus_dmamap_load(uh->uh_dmat, ui->ui_dmam, ui->ui_vaddr,
	    ui->ui_size, NULL, (waitok ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT)))) {
		bus_dmamap_destroy(uh->uh_dmat, ui->ui_dmam);
		return error;
	}
	ui->ui_baddr = ui->ui_dmam->dm_segs[0].ds_addr;
	return 0;
}

/*
 * Allocate DMA-able memory and map it on the unibus.
 */
int
ubmemalloc(struct uba_softc *uh, struct ubinfo *ui, int flags)
{
	int waitok = (flags & UBA_CANTWAIT ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	int error;

	if ((error = bus_dmamem_alloc(uh->uh_dmat, ui->ui_size, NBPG, 0,
	    &ui->ui_seg, 1, &ui->ui_rseg, waitok)))
		return error;
	if ((error = bus_dmamem_map(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg,
	    ui->ui_size, &ui->ui_vaddr, waitok|BUS_DMA_COHERENT))) {
		bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
		return error;
	}
	if ((error = uballoc(uh, ui, flags))) {
		bus_dmamem_unmap(uh->uh_dmat, ui->ui_vaddr, ui->ui_size);
		bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
	}
	return error;
}

void
ubfree(struct uba_softc *uh, struct ubinfo *ui)
{
	bus_dmamap_unload(uh->uh_dmat, ui->ui_dmam);
	bus_dmamap_destroy(uh->uh_dmat, ui->ui_dmam);
}

void
ubmemfree(struct uba_softc *uh, struct ubinfo *ui)
{
	bus_dmamem_unmap(uh->uh_dmat, ui->ui_vaddr, ui->ui_size);
	bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
	ubfree(uh, ui);
@


1.3
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.2 2001/08/25 13:33:37 hugh Exp $	*/
d55 1
a55 1
#include <vm/vm.h>
@


1.2
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.1 2000/04/27 03:14:49 bjc Exp $	*/
a55 1
#include <vm/vm_kern.h>
@


1.1
log
@sync w/netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uba.c,v 1.49 2000/01/24 02:40:30 matt Exp $	   */
d64 2
a65 2
static	int ubasearch __P((struct device *, struct cfdata *, void *));
static	int ubaprint __P((void *, const char *));
d78 1
a78 2
uba_enqueue(uu)
	struct uba_unit *uu;
d97 1
a97 2
uba_done(uh)
	struct uba_softc *uh;
d111 17
d133 1
a133 2
ubareset(uban)
	int uban;
d135 2
a136 2
	register struct uba_softc *uh = uba_cd.cd_devs[uban];
	int s, i;
d143 6
a148 2
	for (i = 0; i < uh->uh_resno; i++)
		(*uh->uh_reset[i])(uh->uh_resarg[i]);
d158 1
a158 3
uba_attach(sc, iopagephys)
	struct uba_softc *sc;
	paddr_t iopagephys;
d168 1
d188 1
a188 4
ubasearch(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
a196 1
	ua.ua_reset = NULL;
a215 18
		
	if (ua.ua_reset) { /* device wants ubareset */
		if (sc->uh_resno == 0) {
#define	RESETSIXE	128
			sc->uh_reset = malloc(sizeof(void *) * RESETSIXE,
			    M_DEVBUF, M_NOWAIT);
			sc->uh_resarg = malloc(sizeof(void *) * RESETSIXE,
			    M_DEVBUF, M_NOWAIT);
		}
		if (sc->uh_resno < RESETSIXE) {
			sc->uh_resarg[sc->uh_resno] = cf->cf_unit;
			sc->uh_reset[sc->uh_resno++] = ua.ua_reset;
		} else {
			printf("%s: Expand reset table, skipping reset %s%d\n",
			    sc->uh_dev.dv_xname, cf->cf_driver->cd_name,
			    cf->cf_unit);
		}
	}
d237 1
a237 3
ubaprint(aux, uba)
	void *aux;
	const char *uba;
d250 1
a250 1
uba_intr_establish(icookie, vec, ifunc, iarg)
d255 1
d257 1
a257 1
	scb_vecalloc(vec, ifunc, iarg, SCB_ISTACK);
@


1.1.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.1 2000/04/27 03:14:49 bjc Exp $	*/
@


1.1.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: uba.c,v 1.1.8.1 2001/05/14 21:38:29 niklas Exp $	*/
/*	$NetBSD: uba.c,v 1.52 2000/06/04 02:14:12 matt Exp $	   */
d56 1
d64 2
a65 2
static int ubasearch (struct device *, struct cfdata *, void *);
static int ubaprint (void *, const char *);
d78 2
a79 1
uba_enqueue(struct uba_unit *uu)
d98 2
a99 1
uba_done(struct uba_softc *uh)
a112 17
 * Each device that needs some handling if an ubareset occurs must
 * register for reset first through this routine.
 */
void
uba_reset_establish(void (*reset)(struct device *), struct device *dev)
{
	struct uba_softc *uh = (void *)dev->dv_parent;
	struct uba_reset *ur;

	ur = malloc(sizeof(struct uba_reset), M_DEVBUF, M_NOWAIT);
	ur->ur_dev = dev;
	ur->ur_reset = reset;

	SIMPLEQ_INSERT_TAIL(&uh->uh_resetq, ur, ur_resetq);
}

/*
d118 2
a119 1
ubareset(struct uba_softc *uh)
d121 2
a122 2
	struct uba_reset *ur;
	int s;
d129 2
a130 6
	ur = SIMPLEQ_FIRST(&uh->uh_resetq);
	if (ur) do {
		printf(" %s", ur->ur_dev->dv_xname);
		(*ur->ur_reset)(ur->ur_dev);
	} while ((ur = SIMPLEQ_NEXT(ur, ur_resetq)));

d140 3
a142 1
uba_attach(struct uba_softc *sc, paddr_t iopagephys)
a151 1
	SIMPLEQ_INIT(&sc->uh_resetq);
d171 4
a174 1
ubasearch(struct device *parent, struct cfdata *cf, void *aux)
d183 1
d203 18
d242 3
a244 1
ubaprint(void *aux, const char *uba)
d257 1
a257 1
uba_intr_establish(icookie, vec, ifunc, iarg, ev)
a261 1
	struct evcnt *ev;
d263 1
a263 1
	scb_vecalloc(vec, ifunc, iarg, SCB_ISTACK, ev);
@


1.1.8.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
#include <uvm/uvm_extern.h>
@


1.1.8.4
log
@Merge in trunk
@
text
@d45 1
a119 2
	if (ur == NULL)
		panic("uba_reset_establish");
@


1.1.8.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: uba.c,v 1.57 2001/04/26 19:16:07 ragge Exp $	*/
a124 62
}

/*
 * Allocate a bunch of map registers and map them to the given address.
 */
int
uballoc(struct uba_softc *uh, struct ubinfo *ui, int flags)
{
	int waitok = (flags & UBA_CANTWAIT) == 0;
	int error;

	if ((error = bus_dmamap_create(uh->uh_dmat, ui->ui_size, 1,
	    ui->ui_size, 0, (waitok ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT),
	    &ui->ui_dmam)))
		return error;

	if ((error = bus_dmamap_load(uh->uh_dmat, ui->ui_dmam, ui->ui_vaddr,
	    ui->ui_size, NULL, (waitok ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT)))) {
		bus_dmamap_destroy(uh->uh_dmat, ui->ui_dmam);
		return error;
	}
	ui->ui_baddr = ui->ui_dmam->dm_segs[0].ds_addr;
	return 0;
}

/*
 * Allocate DMA-able memory and map it on the unibus.
 */
int
ubmemalloc(struct uba_softc *uh, struct ubinfo *ui, int flags)
{
	int waitok = (flags & UBA_CANTWAIT ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	int error;

	if ((error = bus_dmamem_alloc(uh->uh_dmat, ui->ui_size, NBPG, 0,
	    &ui->ui_seg, 1, &ui->ui_rseg, waitok)))
		return error;
	if ((error = bus_dmamem_map(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg,
	    ui->ui_size, &ui->ui_vaddr, waitok|BUS_DMA_COHERENT))) {
		bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
		return error;
	}
	if ((error = uballoc(uh, ui, flags))) {
		bus_dmamem_unmap(uh->uh_dmat, ui->ui_vaddr, ui->ui_size);
		bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
	}
	return error;
}

void
ubfree(struct uba_softc *uh, struct ubinfo *ui)
{
	bus_dmamap_unload(uh->uh_dmat, ui->ui_dmam);
	bus_dmamap_destroy(uh->uh_dmat, ui->ui_dmam);
}

void
ubmemfree(struct uba_softc *uh, struct ubinfo *ui)
{
	bus_dmamem_unmap(uh->uh_dmat, ui->ui_vaddr, ui->ui_size);
	bus_dmamem_free(uh->uh_dmat, &ui->ui_seg, ui->ui_rseg);
	ubfree(uh, ui);
@


1.1.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uba.c,v 1.1.8.5 2003/03/27 23:52:20 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.8.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 1
a96 1
		SIMPLEQ_REMOVE_HEAD(&uh->uh_resq, uu_resq);
@


