head	1.10;
access;
symbols
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.16
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.14
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.10
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.8
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.4
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.9;
commitid	OSDG2O3Cgeifnf1W;

1.9
date	2015.02.01.15.27.11;	author miod;	state Exp;
branches;
next	1.8;
commitid	vfuvVKDlohAznQIf;

1.8
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.19.20.22.37;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.07.23.10.46;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.23.27.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.03.19.43.24;	author hugh;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.25.13.33.37;	author hugh;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.27.03.14.49;	author bjc;	state Exp;
branches
	1.1.8.1;
next	;

1.1.8.1
date	2001.05.14.21.38.30;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2003.03.27.23.52.20;	author niklas;	state Exp;
branches;
next	1.1.8.5;

1.1.8.5
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: ubavar.h,v 1.9 2015/02/01 15:27:11 miod Exp $	*/
/*	$NetBSD: ubavar.h,v 1.31 2001/04/26 19:16:07 ragge Exp $	*/

/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ubavar.h	7.7 (Berkeley) 6/28/90
 */
#ifndef _QBUS_UBAVAR_H
#define	_QBUS_UBAVAR_H

/*
 * This file contains definitions related to the kernel structures
 * for dealing with the unibus adapters.
 *
 * Each uba has a uba_softc structure.
 * Each unibus controller which is not a device has a uba_ctlr structure.
 * Each unibus device has a uba_device structure.
 */

/*
 * Per-uba structure.
 *
 * This structure holds the interrupt vector for the uba,
 * and its address in physical and virtual space.  At boot time
 * we determine the devices attached to the uba's and their
 * interrupt vectors, filling in uh_vec.  We free the map
 * register and bdp resources of the uba into the structures
 * defined here.
 *
 * During normal operation, resources are allocated and returned
 * to the structures here.  We watch the number of passive releases
 * on each uba, and if the number is excessive may reset the uba.
 * 
 * When uba resources are needed and not available, or if a device
 * which can tolerate no other uba activity (rk07) gets on the bus,
 * then device drivers may have to wait to get to the bus and are
 * queued here.  It is also possible for processes to block in
 * the unibus driver in resource wait (mrwant, bdpwant); these
 * wait states are also recorded here.
 */
struct	uba_softc {
	struct	device uh_dev;		/* Device struct, autoconfig */
	struct	evcount uh_intrcnt;		/* interrupt counting */
	SIMPLEQ_HEAD(, uba_unit) uh_resq;	/* resource wait chain */
	SIMPLEQ_HEAD(, uba_reset) uh_resetq;	/* ubareset queue */
	int	uh_lastiv;		/* last free interrupt vector */
	int	(*uh_errchk)(struct uba_softc *);
	void	(*uh_beforescan)(struct uba_softc *);
	void	(*uh_afterscan)(struct uba_softc *);
	void	(*uh_ubainit)(struct uba_softc *);
	void	(*uh_ubapurge)(struct uba_softc *, int);
	short	uh_nr;			/* Unibus sequential number */
	bus_space_tag_t	uh_iot;		/* Tag for this Unibus */
	bus_space_handle_t uh_ioh;	/* Handle for I/O space */
	bus_dma_tag_t	uh_dmat;
};

/*
 * Per-controller structure.
 * The unit struct is common to both the adapter and the controller
 * to which it belongs. It is only used on controllers that handles
 * BDP's, and calls the adapter queueing subroutines.
 */
struct	uba_unit {
	SIMPLEQ_ENTRY(uba_unit) uu_resq;/* Queue while waiting for resources */
	void	*uu_softc;	/* Pointer to units softc */
	int	uu_bdp;		/* for controllers that hang on to bdp's */
	int    (*uu_ready)(struct uba_unit *);
	void	*uu_ref;	/* Buffer this is related to */
	short   uu_xclu;        /* want exclusive use of bdp's */
};

/*
 * Reset structure. All devices that needs to be reinitialized
 * after an ubareset registers with this struct.
 */
struct	uba_reset {
	SIMPLEQ_ENTRY(uba_reset) ur_resetq;
	void (*ur_reset)(struct device *);
	struct device *ur_dev;
};

/*
 * uba_attach_args is used during autoconfiguration. It is sent
 * from ubascan() to each (possible) device.
 */
struct uba_attach_args {
	bus_space_tag_t	ua_iot;		/* Tag for this bus I/O-space */
	bus_addr_t	ua_ioh;		/* I/O regs addr */
	bus_dma_tag_t	ua_dmat;
	void		*ua_icookie;	/* Cookie for interrupt establish */
	int		ua_iaddr;	/* Full CSR address of device */
	int		ua_br;		/* IPL this dev interrupted on */
	int		ua_cvec;	/* Vector for this device */
};

/*
 * Flags to UBA map/bdp allocation routines
 */
#define	UBA_NEEDBDP	0x01		/* transfer needs a bdp */
#define	UBA_CANTWAIT	0x02		/* don't block me */
#define	UBA_NEED16	0x04		/* need 16 bit addresses only */
#define	UBA_HAVEBDP	0x08		/* use bdp specified in high bits */
#define	UBA_DONTQUE	0x10		/* Do not enqueue xfer */

/*
 * Struct for unibus allocation.
 */
struct ubinfo {
	bus_dmamap_t ui_dmam;
	bus_dma_segment_t ui_seg;
	int ui_rseg;
	caddr_t ui_vaddr;
	bus_addr_t ui_baddr;
	bus_size_t ui_size;
};

/*
 * Some common defines for all subtypes of U/Q-buses/adapters.
 */
#define ubdevreg(addr) ((addr) & 017777)

#ifdef _KERNEL
void uba_intr_establish(void *, int, void (*)(void *), void *, struct evcount *);
void uba_reset_establish(void (*)(struct device *), struct device *);
void uba_attach(struct uba_softc *, unsigned long);
void uba_enqueue(struct uba_unit *);
void uba_done(struct uba_softc *);
void ubareset(struct uba_softc *);
int uballoc(struct uba_softc *, struct ubinfo *, int);
int ubmemalloc(struct uba_softc *, struct ubinfo *, int);
void ubfree(struct uba_softc *, struct ubinfo *);
void ubmemfree(struct uba_softc *, struct ubinfo *);
#endif /* _KERNEL */

#endif /* _QBUS_UBAVAR_H */
@


1.9
log
@Gather the scattered (and sometimes duplicated) qbus address and size defines
to a single place. Get rid of the unused defines pertaining to older vax
models we dropped support for years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.8 2011/07/06 18:32:59 miod Exp $	*/
@


1.8
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.7 2006/07/19 20:22:37 miod Exp $	*/
a146 1
#define	UBAIOSIZE	(8*1024)	/* 8K I/O space */
@


1.7
log
@Remove long dead meat and irrelevant defines. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.6 2004/07/07 23:10:46 deraadt Exp $	*/
a96 1
	short   uu_keepbdp;     /* hang on to bdp's once allocated */
@


1.6
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.5 2003/06/02 23:27:58 millert Exp $	*/
a147 1
#define	MAXUBAXFER	(63*1024)	/* Max transfer size in bytes */
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.4 2003/02/03 19:43:24 hugh Exp $	*/
d69 1
a69 1
	struct	evcnt uh_intrcnt;		/* interrupt counting */
d153 1
a153 1
void uba_intr_establish(void *, int, void (*)(void *), void *, struct evcnt *);
@


1.4
log
@From NetBSD: Add functions to allocate mapped-in qbus memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.3 2002/03/14 01:26:48 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.3
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: ubavar.h,v 1.2 2001/08/25 13:33:37 hugh Exp $	*/
/*	$NetBSD: ubavar.h,v 1.29 2000/06/04 06:17:04 matt Exp $	*/
d138 12
d163 4
@


1.2
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.1 2000/04/27 03:14:49 bjc Exp $	*/
d77 5
a81 5
	int	(*uh_errchk) __P((struct uba_softc *));
	void	(*uh_beforescan) __P((struct uba_softc *));
	void	(*uh_afterscan) __P((struct uba_softc *));
	void	(*uh_ubainit) __P((struct uba_softc *));
	void	(*uh_ubapurge) __P((struct uba_softc *, int));
d98 1
a98 1
	int    (*uu_ready) __P((struct uba_unit *));
@


1.2.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.2 2001/08/25 13:33:37 hugh Exp $	*/
d77 5
a81 5
	int	(*uh_errchk)(struct uba_softc *);
	void	(*uh_beforescan)(struct uba_softc *);
	void	(*uh_afterscan)(struct uba_softc *);
	void	(*uh_ubainit)(struct uba_softc *);
	void	(*uh_ubapurge)(struct uba_softc *, int);
d98 1
a98 1
	int    (*uu_ready)(struct uba_unit *);
@


1.2.4.2
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ubavar.h,v 1.31 2001/04/26 19:16:07 ragge Exp $	*/
a137 12
 * Struct for unibus allocation.
 */
struct ubinfo {
	bus_dmamap_t ui_dmam;
	bus_dma_segment_t ui_seg;
	int ui_rseg;
	caddr_t ui_vaddr;
	bus_addr_t ui_baddr;
	bus_size_t ui_size;
};

/*
a150 4
int uballoc(struct uba_softc *, struct ubinfo *, int);
int ubmemalloc(struct uba_softc *, struct ubinfo *, int);
void ubfree(struct uba_softc *, struct ubinfo *);
void ubmemfree(struct uba_softc *, struct ubinfo *);
@


1.1
log
@sync w/netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ubavar.h,v 1.26 2000/01/24 02:40:30 matt Exp $	*/
d73 1
d75 1
a75 3
	void	(**uh_reset) __P((int));/* UBA reset function array */
	int	*uh_resarg;		/* array of ubareset args */
	int	uh_resno;		/* Number of devices to reset */
d105 10
a122 2
		    /* UBA reset routine, filled in by probe */
	void		(*ua_reset) __P((int));
d145 6
a150 8
#define b_forw  b_hash.le_next	/* Nice to have when handling uba queues */

void	uba_intr_establish __P((void *, int, void (*)(void *), void *));
void	uba_attach __P((struct uba_softc *, unsigned long));
void	uba_enqueue __P((struct uba_unit *));
void	uba_done __P((struct uba_softc *));
void	ubareset __P((int));

@


1.1.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.1 2000/04/27 03:14:49 bjc Exp $	*/
@


1.1.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ubavar.h,v 1.1.8.1 2001/05/14 21:38:30 niklas Exp $	*/
/*	$NetBSD: ubavar.h,v 1.29 2000/06/04 06:17:04 matt Exp $	*/
a72 1
	struct	evcnt uh_intrcnt;		/* interrupt counting */
d74 3
a76 1
	SIMPLEQ_HEAD(, uba_reset) uh_resetq;	/* ubareset queue */
a105 10
 * Reset structure. All devices that needs to be reinitialized
 * after an ubareset registers with this struct.
 */
struct	uba_reset {
	SIMPLEQ_ENTRY(uba_reset) ur_resetq;
	void (*ur_reset)(struct device *);
	struct device *ur_dev;
};

/*
d114 2
d138 8
a145 6
void uba_intr_establish(void *, int, void (*)(void *), void *, struct evcnt *);
void uba_reset_establish(void (*)(struct device *), struct device *);
void uba_attach(struct uba_softc *, unsigned long);
void uba_enqueue(struct uba_unit *);
void uba_done(struct uba_softc *);
void ubareset(struct uba_softc *);
@


1.1.8.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 5
a81 5
	int	(*uh_errchk)(struct uba_softc *);
	void	(*uh_beforescan)(struct uba_softc *);
	void	(*uh_afterscan)(struct uba_softc *);
	void	(*uh_ubainit)(struct uba_softc *);
	void	(*uh_ubapurge)(struct uba_softc *, int);
d98 1
a98 1
	int    (*uu_ready)(struct uba_unit *);
@


1.1.8.4
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: ubavar.h,v 1.31 2001/04/26 19:16:07 ragge Exp $	*/
a137 12
 * Struct for unibus allocation.
 */
struct ubinfo {
	bus_dmamap_t ui_dmam;
	bus_dma_segment_t ui_seg;
	int ui_rseg;
	caddr_t ui_vaddr;
	bus_addr_t ui_baddr;
	bus_size_t ui_size;
};

/*
a150 4
int uballoc(struct uba_softc *, struct ubinfo *, int);
int ubmemalloc(struct uba_softc *, struct ubinfo *, int);
void ubfree(struct uba_softc *, struct ubinfo *);
void ubmemfree(struct uba_softc *, struct ubinfo *);
@


1.1.8.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubavar.h,v 1.1.8.4 2003/03/27 23:52:20 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


