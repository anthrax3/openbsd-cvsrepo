head	1.9;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	UBC_SYNC_A:1.9
	UBC_SYNC_B:1.9
	SMP:1.8.0.8
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2000.04.27.02.26.19;	author bjc;	state dead;
branches;
next	1.8;

1.8
date	98.05.13.07.30.21;	author niklas;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	98.05.11.07.36.27;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.02.03.11.48.25;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.00.04.19;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.24.17;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.09.08.59;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.16.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.03;	author deraadt;	state Exp;
branches;
next	;

1.8.8.1
date	2001.05.14.21.37.39;	author niklas;	state dead;
branches;
next	;


desc
@@


1.9
log
@sync with netbsd -- this involved rearranging things for sanity reasons
and because separate builds of libsa are done.  this is a pretty nice
bootloader.
@
text
@/* $OpenBSD: bootxx.c,v 1.8 1998/05/13 07:30:21 niklas Exp $ */
/* $NetBSD: bootxx.c,v 1.11 1997/06/08 17:49:17 ragge Exp $ */
/*-
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)boot.c	7.15 (Berkeley) 5/4/91
 */

#include "sys/param.h"
#include "sys/reboot.h"
#include "sys/disklabel.h"

#include "lib/libsa/stand.h"
#include "lib/libsa/ufs.h"

#include "../include/pte.h"
#include "../include/sid.h"
#include "../include/mtpr.h"
#include "../include/reg.h"
#include "../include/rpb.h"

#include "../mba/mbareg.h"
#include "../mba/hpreg.h"

#define NRSP 1 /* Kludge */
#define NCMD 1 /* Kludge */

#include "../uba/ubareg.h"
#include "../uba/udareg.h"

#include "../mscp/mscp.h"
#include "../mscp/mscpreg.h"

#include "data.h"
#include "vaxstand.h"

#include <sys/exec.h>

int     romstrategy(), romopen();
int	command(int, int);

/*
 * Boot program... argume passed in r10 and r11 determine whether boot
 * stops to ask for system name and which device boot comes from.
 */

volatile u_int  devtype, bootdev;
unsigned        opendev, boothowto, bootset, memsz;

extern unsigned *bootregs;
extern struct	rpb *rpb;

/*
 * The boot block are used by 11/750, 8200, MicroVAX II/III, VS2000,
 * VS3100/??, VS4000 and VAX6000/???, and only when booting from disk.
 */
Xmain()
{
	int io;
	char *scbb;
	char *new;
	char *hej = "/boot";

        switch (vax_cputype) {

        case VAX_TYP_UV2:
        case VAX_TYP_CVAX:
	case VAX_TYP_RIGEL:
	case VAX_TYP_NVAX:
	case VAX_TYP_SOC:
		/*
		 * now relocate rpb/bqo (which are used by ROM-routines)
		 */
		rpb = (void*)XXRPB;
		bcopy ((void*)bootregs[11], rpb, 512);
		rpb->rpb_base = rpb;
		bqo = (void*)(512+(int)rpb);
		bcopy ((void*)rpb->iovec, bqo, rpb->iovecsz);
		rpb->iovec = (int)bqo;
		bootregs[11] = (int)rpb;
		bootdev = rpb->devtyp;
		memsz = rpb->pfncnt << 9;

                break;
	case VAX_8200:
        case VAX_750:
		bootdev = bootregs[10];
		memsz = 0;

                break;
	default:
		printf("unknown cpu type %d\nRegister dump:\n", vax_cputype);
		for (io = 0; io < 16; io++)
			printf("r%d 0x%x\n", io, bootregs[io]);
		asm("halt");
        }

	bootset = getbootdev();

	printf("\nhowto 0x%x, bdev 0x%x, booting...", boothowto, bootdev);
	io = open(hej, 0);

	if (io >= 0 && io < SOPEN_MAX) {
		copyunix(io);
	} else {
		printf("Boot failed, saerrno %d\n", errno);
	}
}

/* ARGSUSED */
copyunix(aio)
{
	struct exec     x;
	register int    io = aio, i;
	char           *addr;

	i = read(io, (char *) &x, sizeof(x));
	if (i != sizeof(x) || N_BADMAG(x)) {
		printf("Bad format\n");
		return;
	}

	if (N_GETMAGIC(x) == ZMAGIC && lseek(io, N_TXTADDR(x), SEEK_SET) == -1)
		goto shread;
	if (read(io, (char *) 0x10000, x.a_text) != x.a_text)
		goto shread;
	addr = (char *) x.a_text;
	if (N_GETMAGIC(x) == ZMAGIC || N_GETMAGIC(x) == NMAGIC)
		while ((int) addr & CLOFSET)
			*addr++ = 0;

	if (read(io, addr + 0x10000, x.a_data) != x.a_data)
		goto shread;
	addr += x.a_data;
	bcopy((void *) 0x10000, 0, (int) addr);

	for (i = 0; i < x.a_bss; i++)
		*addr++ = 0;
	for (i = 0; i < 128 * 512; i++)	/* slop */
		*addr++ = 0;
	printf("done. (%d+%d)\n", x.a_text + x.a_data, x.a_bss);
	hoppabort(x.a_entry, boothowto, bootset);
	(*((int (*) ()) x.a_entry)) ();
	return;
shread:
	printf("Short read\n");
	return;
}

getbootdev()
{
	int i, adaptor, controller, unit, partition, retval;

	adaptor = controller = unit = partition = 0;

	switch (vax_cputype) {
	case VAX_TYP_UV2:
	case VAX_TYP_CVAX:
		adaptor = 0;
		controller = ((rpb->csrphy & 017777) == 0xDC)?1:0;
		unit = rpb->unit;			/* DUC, DUD? */
		
		break;

	case VAX_TYP_RIGEL:
		unit = rpb->unit;
		if (unit > 99)
			unit /= 100;		/* DKB300 is target 3 */
		break;


	case VAX_TYP_8SS:
	case VAX_TYP_750:
		controller = 0;	/* XXX Actually massbuss can be on 3 ctlr's */
		unit = bootregs[3];
		break;
	}

	switch (B_TYPE(bootdev)) {
	case BDEV_HP:			/* massbuss boot */
		adaptor = (bootregs[1] & 0x6000) >> 17;
		break;

	case BDEV_UDA:		/* UDA50 boot */
		if (vax_cputype == VAX_750)
			adaptor = (bootregs[1] & 0x40000 ? 0 : 1);
		break;

	case BDEV_TK:		/* TK50 boot */
	case BDEV_CNSL:		/* Console storage boot */
	case BDEV_RD:		/* RD/RX on HDC9224 (MV2000) */
		controller = 0; /* They are always on ctlr 0 */
		break;

	case BDEV_ST:		/* SCSI-tape on NCR5380 (MV2000) */
	case BDEV_SD:		/* SCSI-disk on NCR5380 (3100/76) */
		/*
		 * No standalone routines for SCSI support yet.
		 * Use rom-routines instead!
		 */
		break;

	default:
		printf("Unsupported boot device %d, trying anyway.\n", bootdev);
		boothowto |= (RB_SINGLE | RB_ASKNAME);
	}
	return MAKEBOOTDEV(bootdev, adaptor, controller, unit, partition);
}

struct devsw    devsw[] = {
	SADEV("rom", romstrategy,nullsys,nullsys, noioctl),
};

int             ndevs = (sizeof(devsw) / sizeof(devsw[0]));

struct fs_ops   file_system[] = {
	{ufs_open, ufs_close, ufs_read, ufs_write, ufs_seek, ufs_stat}
};

int             nfsys = (sizeof(file_system) / sizeof(struct fs_ops));

struct disklabel lp;
int part_off = 0;		/* offset into partition holding /boot */
volatile struct uda {
	struct  mscp_1ca uda_ca;           /* communications area */
	struct  mscp uda_rsp;     /* response packets */
	struct  mscp uda_cmd;     /* command packets */
} uda;
volatile struct udadevice *csr;

devopen(f, fname, file)
	struct open_file *f;
	const char    *fname;
	char          **file;
{
	char           *msg;
	int		i, err, off;
	char		line[64];

	f->f_dev = &devsw[0];
	*file = (char *)fname;

	/*
	 * On uVAX we need to init [T]MSCP ctlr to be able to use it.
	 */
	if (vax_cputype == VAX_TYP_UV2 || vax_cputype == VAX_TYP_CVAX) {
		switch (bootdev) {
		case BDEV_UDA:	/* MSCP */
		case BDEV_TK:	/* TMSCP */
			csr = (struct udadevice *)rpb->csrphy;

			csr->udaip = 0; /* Start init */
			while((csr->udasa & MP_STEP1) == 0);
			csr->udasa = 0x8000;
			while((csr->udasa & MP_STEP2) == 0);
			csr->udasa = (short)(((u_int)&uda)&0xffff) + 8;
			while((csr->udasa & MP_STEP3) == 0);
			csr->udasa = 0x10;
			while((csr->udasa & MP_STEP4) == 0);
			csr->udasa = 0x0001;

			uda.uda_ca.ca_rspdsc =
			    (int) &uda.uda_rsp.mscp_cmdref;
			uda.uda_ca.ca_cmddsc =
			    (int) &uda.uda_cmd.mscp_cmdref;
			if (bootdev == BDEV_TK)
				uda.uda_cmd.mscp_vcid = 1;
			command(M_OP_SETCTLRC, 0);
			uda.uda_cmd.mscp_unit = rpb->unit;
			command(M_OP_ONLINE, 0);
		}
	}

	/* 
	 * the disklabel _shall_ be at address LABELOFFSET + RELOC in
	 * phys memory now, no need at all to reread it again.
	 * Actually disklabel is only needed when using hp disks,
	 * but it doesn't hurt to always get it.
	 */
	if ((bootdev != BDEV_TK) && (bootdev != BDEV_CNSL)) {
		msg = getdisklabel((void *)LABELOFFSET + RELOC, &lp);
		if (msg)
			printf("getdisklabel: %s\n", msg);
	}
	return 0;
}

command(cmd, arg)
{
	volatile int hej;

	uda.uda_cmd.mscp_opcode = cmd;
	uda.uda_cmd.mscp_modifier = arg;

	uda.uda_cmd.mscp_msglen = MSCP_MSGLEN;
	uda.uda_rsp.mscp_msglen = MSCP_MSGLEN;
	uda.uda_ca.ca_rspdsc |= MSCP_OWN|MSCP_INT;
	uda.uda_ca.ca_cmddsc |= MSCP_OWN|MSCP_INT;
	hej = csr->udaip;
	while (uda.uda_ca.ca_rspdsc < 0);

}

int curblock = 0;

romstrategy(sc, func, dblk, size, buf, rsize)
	void    *sc;
	int     func;
	daddr_t dblk;
	char    *buf;
	int     size, *rsize;
{
	int i;
	int	block = dblk;
	int     nsize = size;

	switch (vax_cputype) {
	/*
	 * case VAX_TYP_UV2:
	 * case VAX_TYP_CVAX:
	 * case VAX_TYP_RIGEL:
	 */
	default:
		switch (bootdev) {

		case BDEV_UDA: /* MSCP */
			uda.uda_cmd.mscp_seq.seq_lbn = dblk;
			uda.uda_cmd.mscp_seq.seq_bytecount = size;
			uda.uda_cmd.mscp_seq.seq_buffer = (int)buf;
			uda.uda_cmd.mscp_unit = rpb->unit;
			command(M_OP_READ, 0);
			break;

		case BDEV_TK: /* TMSCP */
			if (dblk < curblock) {
				uda.uda_cmd.mscp_seq.seq_bytecount =
				    curblock - dblk;
				command(M_OP_POS, 12);
			} else {
				uda.uda_cmd.mscp_seq.seq_bytecount =
				    dblk - curblock;
				command(M_OP_POS, 4);
			}
			curblock = size/512 + dblk;
			for (i = 0 ; i < size/512 ; i++) {
				uda.uda_cmd.mscp_seq.seq_lbn = 1;
				uda.uda_cmd.mscp_seq.seq_bytecount = 512;
				uda.uda_cmd.mscp_seq.seq_buffer =
				    (int)buf + i * 512;
				uda.uda_cmd.mscp_unit = rpb->unit;
				command(M_OP_READ, 0);
			}
			break;
		case BDEV_RD:
		case BDEV_ST:
		case BDEV_SD:

		default:
			romread_uvax(block, size, buf, bootregs);
			break;

		}
		break;

	case VAX_8200:
	case VAX_750:
		if (bootdev != BDEV_HP) {
			while (size > 0) {
				while ((read750(block, bootregs) & 0x01) == 0)
					printf("Retrying read bn# %d\n", block);
				bcopy(0, buf, 512);
				size -= 512;
				buf += 512;
				block++;
			}
		} else
			hpread(block, size, buf);
		break;
	}

	*rsize = nsize;
	return 0;
}

hpread(block, size, buf)
	char           *buf;
{
	volatile struct mba_regs *mr = (void *) bootregs[1];
	volatile struct hp_drv *hd = (void*)&mr->mba_md[bootregs[3]];
	struct disklabel *dp = &lp;
	u_int           pfnum, nsize, mapnr, bn, cn, sn, tn;

	pfnum = (u_int) buf >> PGSHIFT;

	for (mapnr = 0, nsize = size; (nsize + NBPG) > 0; nsize -= NBPG)
		*(int *)&mr->mba_map[mapnr++] = PG_V | pfnum++;
	mr->mba_var = ((u_int) buf & PGOFSET);
	mr->mba_bc = (~size) + 1;
	bn = block;
	cn = bn / dp->d_secpercyl;
	sn = bn % dp->d_secpercyl;
	tn = sn / dp->d_nsectors;
	sn = sn % dp->d_nsectors;
	hd->hp_dc = cn;
	hd->hp_da = (tn << 8) | sn;
	hd->hp_cs1 = HPCS_READ;
	while (mr->mba_sr & MBASR_DTBUSY);
	if (mr->mba_sr & MBACR_ABORT){
		return 1;
	}
	return 0;
}
@


1.8
log
@Use DEV_BSIZE instead of the wasteful MAXBSIZE for buffer size.
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.7 1998/05/11 07:36:27 niklas Exp $ */
@


1.8.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.8 1998/05/13 07:30:21 niklas Exp $ */
@


1.7
log
@Do not use userland headers
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.6 1998/02/03 11:48:25 maja Exp $ */
a252 1
char io_buf[MAXBSIZE];
@


1.6
log
@Sync with NetBSD 970827. Forgot this one last time. -moj
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.5 1997/05/29 00:04:19 niklas Exp $ */
d66 1
a66 1
#include <a.out.h>
@


1.5
log
@RCS tagging
@
text
@d1 2
a2 2
/* $OpenBSD: bootxx.c,v 1.7 1996/08/02 11:21:53 ragge Exp $ */
/* $NetBSD: bootxx.c,v 1.7 1996/08/02 11:21:53 ragge Exp $ */
d77 1
a77 1
unsigned        opendev, boothowto, bootset;
d82 4
d95 5
a99 4
        case VAX_78032:
        case VAX_650:
		bootdev = rpb->devtyp;

d110 2
d117 1
d129 1
a129 1
	printf("\nhowto 0x%x, bdev 0x%x, booting...\n", boothowto, bootdev);
d151 1
a151 1
	printf("%d", x.a_text);
d160 1
a160 1
	printf("+%d", x.a_data);
d165 1
a165 1
	printf("+%d", x.a_bss);
d170 1
a170 1
	printf(" start 0x%x\n", x.a_entry);
d181 1
a181 1
	int	i, major, adaptor, controller, unit, partition;
d183 1
d186 2
a187 2
	case VAX_78032:
	case VAX_650:
d194 9
a202 2
	case VAX_8200:
	case VAX_750:
d208 2
a209 5
	partition = 0;

	switch (bootdev) {
	case BDEV_MBA:			/* massbuss boot */
		major = 0;	/* hp / ...  */
a213 1
		major = 9;	/* ra / mscp  */
d218 4
a221 2
	case BDEV_TK50:		/* TK50 boot */
		major = 15;	/* tms / tmscp  */
d224 6
a229 8
	case 36:		/* VS2000/KA410 ST506 disk */
	case 37:                /* VS2000/KA410 SCSI tape */
	case 42:                /* VS3100/76 SCSI-floppy(?) */
		major = 17;     /* 17 is assigned to the ROM-drivers */
		break;

	case BDEV_CONSOLE:
		major = 8;
d236 1
a236 1
	return MAKEBOOTDEV(major, adaptor, controller, unit, partition);
d276 1
a276 1
	if (vax_cputype == VAX_78032 || vax_cputype == VAX_650) {
d279 1
a279 1
		case BDEV_TK50:	/* TMSCP */
d296 1
a296 1
			if (bootdev == BDEV_TK50)
d310 1
a310 1
	if ((bootdev != BDEV_TK50) && (bootdev != BDEV_CONSOLE)) {
d348 6
a353 3

	case VAX_650:
	case VAX_78032:
d364 1
a364 1
		case BDEV_TK50: /* TMSCP */
d384 4
a387 2
		case 36:
		case 37:
d397 1
a397 1
		if (bootdev != BDEV_MBA) {
@


1.4
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@


1.3
log
@sync w/ 0430
@
text
@d1 1
a1 1
/* $NetBSD: bootxx.c,v 1.5 1996/02/17 18:23:21 ragge Exp $ */
d53 3
a55 2
#define NRSP 0 /* Kludge */
#define NCMD 0 /* Kludge */
d58 3
a60 1
#include "../vax/mscp.h"
d67 1
a67 1
int             romstrategy(), romopen();
a76 4
int             cpu_type, cpunumber;
unsigned *bootregs;
int is_750 = 0, is_mvax = 0, is_tmscp = 0;
struct	rpb *rpb;
d78 4
a81 1
main()
d84 2
d88 1
a88 4
        cpu_type = mfpr(PR_SID);
        cpunumber = (mfpr(PR_SID) >> 24) & 0xFF;

        switch (cpunumber) {
d92 1
a92 2
        {
                int	cpu_sie;        /* sid-extension */
d94 10
a103 5
                is_mvax = 1;
                cpu_sie = *((int *) 0x20040004) >> 24;
                cpu_type |= cpu_sie;
		rpb = (struct rpb *)bootregs[11];
		bootdev = rpb->devtyp;
d106 1
a106 1
        }
a107 1
                is_750 = 1;
d111 5
d126 1
a126 1
		printf("Boot failed. errno %d (%s)\n", errno, strerror(errno));
d139 1
a139 1
		printf("Bad format: errno %s\n", strerror(errno));
d175 1
a175 1
	switch (cpunumber) {
d184 1
d194 1
a194 1
	case 0:			/* massbuss boot */
d199 1
a199 1
	case 17:		/* UDA50 boot */
d201 1
a201 1
		if (is_750)
d205 1
a205 1
	case 18:		/* TK50 boot */
a206 1
		is_tmscp = 1;	/* use tape spec in mscp routines */
d209 7
a215 1
	case 64:
d242 1
a242 1
	struct  uda1ca uda_ca;           /* communications area */
d263 1
a263 1
	if (is_mvax) {
d265 2
a266 2
		case 17:	/* MSCP */
		case 18:	/* TMSCP */
d270 1
a270 1
			while((csr->udasa & UDA_STEP1) == 0);
d272 1
a272 1
			while((csr->udasa & UDA_STEP2) == 0);
d274 1
a274 1
			while((csr->udasa & UDA_STEP3) == 0);
d276 1
a276 1
			while((csr->udasa & UDA_STEP4) == 0);
d283 1
a283 1
			if (is_tmscp)
d297 1
a297 1
	if (!is_tmscp) {
d299 1
a299 1
		if (msg) {
a300 1
		}
d334 1
a334 1
	switch (cpunumber) {
d340 1
a340 1
		case 17: /* MSCP */
d348 1
a348 1
		case 18: /* TMSCP */
d368 5
d377 1
d379 1
a379 1
		if (bootdev) {
d381 2
a382 3
				if ((read750(block, bootregs) & 0x01) == 0)
					return 1;

@


1.2
log
@update from netbsd tree
@
text
@d1 1
a1 1
/* $NetBSD: bootxx.c,v 1.4 1995/10/20 13:35:43 ragge Exp $ */
a43 3
#include "../mba/mbareg.h"
#include "../mba/hpreg.h"

d50 3
d200 4
d243 1
a243 1
	*file = fname;
d389 1
a389 1
		mr->mba_map[mapnr++] = PG_V | pfnum++;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $NetBSD: bootxx.c,v 1.3 1995/09/16 13:01:06 ragge Exp $ */
d51 1
d97 1
a97 1
		rpb = bootregs[11];
d279 1
a279 1
		msg = getdisklabel(LABELOFFSET + RELOC, &lp);
d325 1
a325 1
			uda.uda_cmd.mscp_seq.seq_buffer = buf;
d344 2
a345 1
				uda.uda_cmd.mscp_seq.seq_buffer = buf + i * 512;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
