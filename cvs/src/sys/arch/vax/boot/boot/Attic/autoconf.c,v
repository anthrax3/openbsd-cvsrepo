head	1.14;
access;
symbols
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2011.07.10.17.31.40;	author deraadt;	state dead;
branches;
next	1.13;

1.13
date	2008.08.18.23.20.43;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.12.17.23.21;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.10.18.20.07;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.21.19.42.07;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.15.23.16.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.11.09.36.23;	author hugh;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.09.03.36.33;	author hugh;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.31.17.20.21;	author hugh;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.08.25.13.33.36;	author hugh;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.28.01.21.32;	author hugh;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2000.10.04.04.09.00;	author bjc;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.01.00.12.00;	author bjc;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.02.26.24;	author bjc;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.21.37.43;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.39.18;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Move the vax/boot code to vax/stand.  A cvs 'mv' with de-tagging has been
done behind the scenes to retain history.  Having all the bootblocks in the
same architecture sub-directory satisfies several principles.
ok miod
@
text
@/*	$OpenBSD: autoconf.c,v 1.13 2008/08/18 23:20:43 miod Exp $ */
/*	$NetBSD: autoconf.c,v 1.19 2002/06/01 15:33:22 ragge Exp $ */
/*
 * Copyright (c) 1994, 1998 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

 /* All bugs are subject to removal without further notice */
		


#include <sys/param.h>

#include <lib/libsa/stand.h>

#include <machine/mtpr.h>
#include <machine/sid.h>
#include <machine/intr.h>
#include <machine/rpb.h>
#include <machine/scb.h>
#include <arch/vax/mbus/mbusreg.h>
#include <arch/vax/mbus/fwioreg.h>
#include "vaxstand.h"

void autoconf(void);
void findcpu(void);
void consinit(void);
void scbinit(void);
void clkstart(void);
int getsecs(void);
void scb_stray(void *);
void scb_silent(void *);
void longjmp(int *);
void rtimer(void *);

long *bootregs;

/*
 * Do some initial setup. Also create a fake RPB for net-booted machines
 * that don't have an in-prom VMB.
 */

void
autoconf(void)
{
	int copyrpb = 1;
	int fromnet = (bootregs[12] != -1);

	findcpu(); /* Configures CPU variables */
	scbinit(); /* Setup interrupts */
	consinit(); /* Allow us to print out things */
	clkstart(); /* Fix interval clock etc */

#ifdef DEV_DEBUG
	printf("Register contents:\n");
	for (copyrpb = 0; copyrpb < 13; copyrpb++)
		printf("r%d: %lx\n", copyrpb, bootregs[copyrpb]);
#endif
	switch (vax_boardtype) {

	case VAX_BTYP_780:
	case VAX_BTYP_790:
	case VAX_BTYP_8000:
	case VAX_BTYP_9CC:
	case VAX_BTYP_9RR:
	case VAX_BTYP_1202:
		if (fromnet == 0)
			break;
		copyrpb = 0;
		bootrpb.devtyp = bootregs[0];
		bootrpb.adpphy = bootregs[1];
		bootrpb.csrphy = bootregs[2];
		bootrpb.unit = bootregs[3];
		bootrpb.rpb_bootr5 = bootregs[5];
		bootrpb.pfncnt = 0;
		break;

	case VAX_BTYP_46:
	case VAX_BTYP_48:
		{int *map, i;

		/* Map all 16MB of I/O space to low 16MB of memory */
		map = (int *)0x700000; /* XXX */
		*(int *)0x20080008 = (int)map; /* XXX */
		for (i = 0; i < 0x8000; i++)
			map[i] = 0x80000000 | i;
		}break;

		break;
	}

	if (copyrpb) {
		struct rpb *prpb = (struct rpb *)bootregs[11];
		bcopy((caddr_t)prpb, &bootrpb, sizeof(struct rpb));
		if (prpb->iovec) {
			bootrpb.iovec = (int)alloc(prpb->iovecsz);
			bcopy((caddr_t)prpb->iovec, (caddr_t)bootrpb.iovec,
			    prpb->iovecsz);
		}
	}
}

/*
 * Clock handling routines, needed to do timing in standalone programs.
 */

volatile int tickcnt;

int
getsecs(void)
{
	return tickcnt/100;
}

struct ivec_dsp **scb;
struct ivec_dsp *scb_vec;
extern struct ivec_dsp idsptch;
extern int jbuf[10];
extern int mcheck_silent;

static void
mcheck(void *arg)
{
	int off, *mfp = (int *)&arg;

	if (!mcheck_silent) {
		off = (mfp[7]/4 + 8);
		printf("Machine check, pc=%x, psl=%x\n", mfp[off], mfp[off+1]);
	}
	longjmp(jbuf);
}

/*
 * Init the SCB and set up a handler for all vectors in the lower space,
 * to detect unwanted interrupts.
 */
void
scbinit(void)
{
	int i;

	/*
	 * Allocate space. We need one page for the SCB, and 128*20 == 2.5k
	 * for the vectors. The SCB must be on a page boundary.
	 */
	i = (int)alloc(VAX_NBPG + 128*sizeof(scb_vec[0])) + VAX_PGOFSET;
	i &= ~VAX_PGOFSET;

	mtpr(i, PR_SCBB);
	scb = (void *)i;
	scb_vec = (struct ivec_dsp *)(i + VAX_NBPG);

	for (i = 0; i < 128; i++) {
		scb[i] = &scb_vec[i];
		(int)scb[i] |= SCB_ISTACK;	/* Only interrupt stack */
		scb_vec[i] = idsptch;
		scb_vec[i].hoppaddr = scb_stray;
		scb_vec[i].pushlarg = (void *) (i * 4);
		scb_vec[i].ev = NULL;
	}
	scb_vec[4/4].hoppaddr = mcheck;
	if (vax_boardtype == VAX_BTYP_60)
		scb_vec[0x60/4].hoppaddr = scb_silent;
}

void
clkstart(void)
{
	scb_vec[0xc0/4].hoppaddr = rtimer;
	if (vax_boardtype != VAX_BTYP_VXT)
		mtpr(-10000, PR_NICR);		/* Load in count register */
	mtpr(0x800000d1, PR_ICCS);	/* Start clock and enable interrupt */

	if (vax_boardtype == VAX_BTYP_60) {
		extern int ka60_ioslot;

		/* enable M-Bus clock in IOCSR */
		*(unsigned int *)(MBUS_SLOT_BASE(ka60_ioslot) +
		    FWIO_IOCSR_OFFSET) |= FWIO_IOCSR_CLKIEN;
	}

	mtpr(20, PR_IPL);
}

extern int sluttid, senast, skip;

void
rtimer(void *arg)
{
	mtpr(31, PR_IPL);
	tickcnt++;
	mtpr(0xc1, PR_ICCS);
	if (skip)
		return;
	if ((vax_boardtype == VAX_BTYP_46) ||
	    (vax_boardtype == VAX_BTYP_48) ||
	    (vax_boardtype == VAX_BTYP_49)) {
		int nu = sluttid - getsecs();
		if (senast != nu) {
			mtpr(20, PR_IPL);
			longjmp(jbuf);
		}
	}
}

#ifdef __ELF__
#define	IDSPTCH "idsptch"
#define	EIDSPTCH "eidsptch"
#define	CMN_IDSPTCH "cmn_idsptch"
#else
#define	IDSPTCH "_idsptch"
#define	EIDSPTCH "_eidsptch"
#define	CMN_IDSPTCH "_cmn_idsptch"
#endif

asm("
	.text
	.align	2
	.globl	" IDSPTCH ", " EIDSPTCH "
" IDSPTCH ":
	pushr	$0x3f
	.word	0x9f16
	.long	" CMN_IDSPTCH "
	.long	0
	.long	0
	.long	0
" EIDSPTCH ":

" CMN_IDSPTCH ":
	movl	(sp)+,r0
	pushl	4(r0)
	calls	$1,*(r0)
	popr	$0x3f
	rei
");

/*
 * Stray interrupt handler.
 * This function must _not_ save any registers (in the reg save mask).
 */
void
scb_stray(void *arg)
{
	static int vector, ipl;

	ipl = mfpr(PR_IPL);
	vector = (int) arg;
	printf("stray interrupt: vector 0x%x, ipl %d\n", vector, ipl);
}

void
scb_silent(void *arg)
{
	/* nothing */
}
@


1.13
log
@Now that KA60 support is in, include the proper header files instead of
harcoding defines, and add rpb device type #39 (sii) boot information.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2008/08/12 17:23:21 miod Exp $ */
@


1.12
log
@Figured out where the prom console routines are on KA60 and how to invoke
them, thanks to old ultrix bootblocks lying around.
Also, enable M-Bus clock on the I/O slot IOCSR, this unstucks the cpu
clocks (which really are implemented on the SSC on the I/O module, but
need to be controlled via the cpu's ``internal'' processor registers...)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2008/08/10 18:20:07 miod Exp $ */
d41 7
a47 5
#include "../../include/mtpr.h"
#include "../../include/sid.h"
#include "../../include/intr.h"
#include "../../include/rpb.h"
#include "../../include/scb.h"
d57 1
d187 2
d203 2
a204 2
		*(unsigned int *)(0x30800000 + (ka60_ioslot << 25)) |=
		    0x20000000;	/* CLKIEN */
d274 6
@


1.11
log
@Add support for the VAXstation 3[58][24]0 to the bootblocks, currently
limited to serial console. This is enough for a 3520 to mopboot and download
a kernel over NFS.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2008/05/21 19:42:07 miod Exp $ */
d193 8
@


1.10
log
@ddb expects the kernel longjmp() to only take a single parameter and always
return 1 since 12+ years, it's about time to fix the offending ports.

Reported by Pierre Riteau (firstname.lastname at gmail)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2003/08/15 23:16:30 deraadt Exp $ */
d52 1
d72 1
d74 1
a74 1
	scbinit(); /* Fix interval clock etc */
d141 1
d148 4
a151 2
	off = (mfp[7]/4 + 8);
	printf("Machine check, pc=%x, psl=%x\n", mfp[off], mfp[off+1]);
a182 1
	scb_vec[0xc0/4].hoppaddr = rtimer;
d184 1
d186 4
@


1.9
log
@ansi and proto cleanup.  one unused function goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2002/06/11 09:36:23 hugh Exp $ */
d54 1
a54 1
void longjmp(int *, int);
d147 1
a147 1
	longjmp(jbuf, 1);
d204 1
a204 1
			longjmp(jbuf, 1);
@


1.8
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 2002/03/09 03:36:33 hugh Exp $ */
d65 1
a65 1
autoconf()
d130 1
a130 1
getsecs()
d155 1
a155 1
scbinit()
@


1.7
log
@Add case for BTYP_1305.
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.6 2001/10/31 17:20:21 hugh Exp $ */
/*	$NetBSD: autoconf.c,v 1.5 1999/08/23 19:09:27 ragge Exp $ */
d37 4
a40 1
#include "sys/param.h"
d43 2
d48 8
a55 1
extern  const struct ivec_dsp idsptch;	/* since we are not KERNEL */
d57 1
a57 32
int	nmba=0, nuba=0, nbi=0,nsbi=0,nuda=0;
int	*mbaaddr, *ubaaddr, *biaddr;
int	*udaaddr, *uioaddr, tmsaddr, *bioaddr;

static int mba750[]={0xf28000,0xf2a000,0xf2c000};
static int uba750[]={0xf30000,0xf32000};
static int uio750[]={0xfc0000,0xf80000};
static int uda750[]={0772150};

/* 11/780's only have 4, 8600 have 8 of these. */
/* XXX - all of these should be bound to physical addresses */
static int mba780[]={0x20010000,0x20012000,0x20014000,0x20016000,
	0x22010000,0x22012000,0x22014000,0x22016000};
static int uba780[]={0, 0, 0, 0x20006000,0x20008000,0x2000a000,0x2000c000, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 
		0, 0, 0, 0x22006000,0x22008000,0x2200a000,0x2200c000};
static int uio780[]={0, 0, 0, 0x20100000,0x20140000,0x20180000,0x201c0000, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 
		0, 0, 0, 0x22100000,0x22140000,0x22180000,0x221c0000};
static int bi8200[]={0x20000000, 0x22000000, 0x24000000, 0x26000000,
	0x28000000, 0x2a000000};
static int bio8200[]={0x20400000};

static int uba630[]={0x20087800};
static int uio630[]={0x30000000};
#define qbdev(csr) (((csr) & 017777)-0x10000000)
static int uda630[]={qbdev(0772150),qbdev(0760334)};

static int uba670[]={0x20040000};
static int uio670[]={0x20000000};
static int uda670[]={0x20004030,0x20004230};
#define qb670dev(csr) (((csr) & 017777)+0x20000000)
d60 2
a61 3
 * Autoconf routine is really stupid; but it actually don't
 * need any intelligence. We just assume that all possible
 * devices exists on each cpu. Fast & easy.
d64 1
a66 1
	extern int memsz;
d68 1
d74 5
a80 5
	default:
		printf("\nCPU type %d not supported by boot\n",vax_cputype);
		printf("trying anyway...\n");
		break;

a82 35
		memsz = 0;
		nmba = 8;
		nuba = 32; /* XXX */
		nuda = 1;
		mbaaddr = mba780;
		ubaaddr = uba780;
		udaaddr = uda750;
		uioaddr = uio780;
		tmsaddr = 0774500;
		break;

	case VAX_BTYP_750:
		memsz = 0;
		nmba = 3;
		nuba = 2;
		nuda = 1;
		mbaaddr = mba750;
		ubaaddr = uba750;
		udaaddr = uda750;
		uioaddr = uio750;
		tmsaddr = 0774500;
		break;

	case VAX_BTYP_630:	/* the same for uvaxIII */
	case VAX_BTYP_650:
	case VAX_BTYP_660:
	case VAX_BTYP_670:
		nuba = 1;
		nuda = 2;
		ubaaddr = uba630;
		udaaddr = uda630;
		uioaddr = uio630;
		tmsaddr = qbdev(0774500);
		break;

d84 5
d90 6
a95 4
		memsz = 0;
		nbi = 1;
		biaddr = bi8200;
		bioaddr = bio8200;
a108 7
	case VAX_BTYP_410:
	case VAX_BTYP_420:
	case VAX_BTYP_43:
	case VAX_BTYP_49:
	case VAX_BTYP_1301:
	case VAX_BTYP_1303:
	case VAX_BTYP_1305:
d111 10
d129 1
a131 3
	volatile int loop;
	int todr;

a134 1
void scb_stray(), rtimer();
d137 12
d154 1
a156 1
	extern int timer;
d179 1
d181 2
a182 1
	mtpr(-10000, PR_NICR);		/* Load in count register */
a187 1
extern int jbuf[10];
d191 1
a191 1
rtimer()
d199 2
a200 2
		(vax_boardtype == VAX_BTYP_48) ||
		(vax_boardtype == VAX_BTYP_49)) {
d204 1
a204 1
			longjmp(jbuf);
d209 10
d220 1
d222 2
a223 2
	.globl  _idsptch, _eidsptch
_idsptch:
d226 1
a226 1
	.long	_cmn_idsptch
d230 1
a230 1
_eidsptch:
d232 1
a232 1
_cmn_idsptch:
d245 1
a245 2
scb_stray(arg)
	int arg;
a252 1

@


1.6
log
@Add boardtype 1301.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 2001/08/25 13:33:36 hugh Exp $ */
d162 1
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 2001/10/31 17:20:21 hugh Exp $ */
a161 1
	case VAX_BTYP_1305:
@


1.6.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: autoconf.c,v 1.19 2002/06/01 15:33:22 ragge Exp $ */
d37 1
a37 4
#include <sys/param.h>

#include <lib/libsa/stand.h>

a39 2
#include "../../include/intr.h"
#include "../../include/rpb.h"
d43 1
a43 8
void autoconf(void);
void findcpu(void);
void consinit(void);
void scbinit(void);
int getsecs(void);
void scb_stray(void *);
void longjmp(int *, int);
void rtimer(void *);
d45 32
a76 1
long *bootregs;
d79 3
a81 2
 * Do some initial setup. Also create a fake RPB for net-booted machines
 * that don't have an in-prom VMB.
a83 1
void
d86 1
a87 1
	int fromnet = (bootregs[12] != -1);
a92 5
#ifdef DEV_DEBUG
	printf("Register contents:\n");
	for (copyrpb = 0; copyrpb < 13; copyrpb++)
		printf("r%d: %lx\n", copyrpb, bootregs[copyrpb]);
#endif
d95 5
d102 35
a137 5
	case VAX_BTYP_9CC:
	case VAX_BTYP_9RR:
	case VAX_BTYP_1202:
		if (fromnet == 0)
			break;
d139 4
a142 6
		bootrpb.devtyp = bootregs[0];
		bootrpb.adpphy = bootregs[1];
		bootrpb.csrphy = bootregs[2];
		bootrpb.unit = bootregs[3];
		bootrpb.rpb_bootr5 = bootregs[5];
		bootrpb.pfncnt = 0;
d156 7
a164 10

	if (copyrpb) {
		struct rpb *prpb = (struct rpb *)bootregs[11];
		bcopy((caddr_t)prpb, &bootrpb, sizeof(struct rpb));
		if (prpb->iovec) {
			bootrpb.iovec = (int)alloc(prpb->iovecsz);
			bcopy((caddr_t)prpb->iovec, (caddr_t)bootrpb.iovec,
			    prpb->iovecsz);
		}
	}
a172 1
int
d175 3
d181 1
a183 12
extern struct ivec_dsp idsptch;
extern int jbuf[10];

static void
mcheck(void *arg)
{
	int off, *mfp = (int *)&arg;

	off = (mfp[7]/4 + 8);
	printf("Machine check, pc=%x, psl=%x\n", mfp[off], mfp[off+1]);
	longjmp(jbuf, 1);
}
a188 1
void
d191 1
a213 1
	scb_vec[4/4].hoppaddr = mcheck;
d215 1
a215 2
	if (vax_boardtype != VAX_BTYP_VXT)
		mtpr(-10000, PR_NICR);		/* Load in count register */
d221 1
d225 1
a225 1
rtimer(void *arg)
d233 2
a234 2
	    (vax_boardtype == VAX_BTYP_48) ||
	    (vax_boardtype == VAX_BTYP_49)) {
d238 1
a238 1
			longjmp(jbuf, 1);
a242 10
#ifdef __ELF__
#define	IDSPTCH "idsptch"
#define	EIDSPTCH "eidsptch"
#define	CMN_IDSPTCH "cmn_idsptch"
#else
#define	IDSPTCH "_idsptch"
#define	EIDSPTCH "_eidsptch"
#define	CMN_IDSPTCH "_cmn_idsptch"
#endif

a243 1
	.text
d245 2
a246 2
	.globl	" IDSPTCH ", " EIDSPTCH "
" IDSPTCH ":
d249 1
a249 1
	.long	" CMN_IDSPTCH "
d253 1
a253 1
" EIDSPTCH ":
d255 1
a255 1
" CMN_IDSPTCH ":
d268 2
a269 1
scb_stray(void *arg)
d277 1
@


1.5
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2001/01/28 01:21:32 hugh Exp $ */
d160 1
@


1.4
log
@BTYP_1303 is supported now.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2000/10/04 04:09:00 bjc Exp $ */
d40 1
a40 2
#include "../../include/trap.h"
#include "../../include/frame.h"
d193 1
a193 1
	 * Allocate space. We need one page for the SCB, and 128*16 == 2k
d196 1
a196 1
	i = alloc(VAX_NBPG * 6) + VAX_PGOFSET;
d205 2
a206 2
		(int)scb[i] |= 1;	/* Only interrupt stack */
		memcpy(&scb_vec[i], &idsptch, sizeof(struct ivec_dsp));
d208 2
d242 1
d245 13
a257 9
	pushr   $0x3f
	pushl   $1
	.long   0x9f01fb01
	.long   0x12345678
#
#	gas do not accept this :-/ use hexcode instead
#	nop
#	calls   $1, *$0x12345678
	popr    $0x3f
a258 1
_eidsptch:
d269 1
a269 2
	static struct callsframe *cf;
	static int vector, ipl, *a;
a270 2
	cf = FRAMEOFFSET(arg);
	a = &cf->ca_arg1;
d272 2
a273 3
	vector = ((cf->ca_pc - (u_int)scb_vec)/4) & ~3;
	printf("stray interrupt: pc %x vector 0x%x, ipl %d\n",
	    cf->ca_pc, vector, ipl);
@


1.4.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2001/01/28 01:21:32 hugh Exp $ */
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4.4.1 2001/05/14 21:37:43 niklas Exp $ */
d40 2
a41 1
#include "../../include/scb.h"
d194 1
a194 1
	 * Allocate space. We need one page for the SCB, and 128*20 == 2.5k
d197 1
a197 1
	i = (int)alloc(VAX_NBPG + 128*sizeof(scb_vec[0])) + VAX_PGOFSET;
d206 2
a207 2
		(int)scb[i] |= SCB_ISTACK;	/* Only interrupt stack */
		scb_vec[i] = idsptch;
a208 2
		scb_vec[i].pushlarg = (void *) (i * 4);
		scb_vec[i].ev = NULL;
a240 1
	.align	2
d243 10
a252 6
	pushr	$0x3f
	.word	0x9f16
	.long	_cmn_idsptch
	.long	0
	.long	0
	.long	0
a253 7

_cmn_idsptch:
	movl	(sp)+,r0
	pushl	4(r0)
	calls	$1,*(r0)
	popr	$0x3f
	rei
d264 2
a265 1
	static int vector, ipl;
d267 2
d270 3
a272 2
	vector = (int) arg;
	printf("stray interrupt: vector 0x%x, ipl %d\n", vector, ipl);
@


1.4.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a159 1
	case VAX_BTYP_1301:
@


1.4.4.4
log
@Merge in -current from about a week ago
@
text
@a161 1
	case VAX_BTYP_1305:
@


1.4.4.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: autoconf.c,v 1.19 2002/06/01 15:33:22 ragge Exp $ */
d37 1
a37 4
#include <sys/param.h>

#include <lib/libsa/stand.h>

a39 2
#include "../../include/intr.h"
#include "../../include/rpb.h"
d43 1
a43 8
void autoconf(void);
void findcpu(void);
void consinit(void);
void scbinit(void);
int getsecs(void);
void scb_stray(void *);
void longjmp(int *, int);
void rtimer(void *);
d45 32
a76 1
long *bootregs;
d79 3
a81 2
 * Do some initial setup. Also create a fake RPB for net-booted machines
 * that don't have an in-prom VMB.
a83 1
void
d86 1
a87 1
	int fromnet = (bootregs[12] != -1);
a92 5
#ifdef DEV_DEBUG
	printf("Register contents:\n");
	for (copyrpb = 0; copyrpb < 13; copyrpb++)
		printf("r%d: %lx\n", copyrpb, bootregs[copyrpb]);
#endif
d95 5
d102 35
a137 5
	case VAX_BTYP_9CC:
	case VAX_BTYP_9RR:
	case VAX_BTYP_1202:
		if (fromnet == 0)
			break;
d139 4
a142 6
		bootrpb.devtyp = bootregs[0];
		bootrpb.adpphy = bootregs[1];
		bootrpb.csrphy = bootregs[2];
		bootrpb.unit = bootregs[3];
		bootrpb.rpb_bootr5 = bootregs[5];
		bootrpb.pfncnt = 0;
d156 7
a164 10

	if (copyrpb) {
		struct rpb *prpb = (struct rpb *)bootregs[11];
		bcopy((caddr_t)prpb, &bootrpb, sizeof(struct rpb));
		if (prpb->iovec) {
			bootrpb.iovec = (int)alloc(prpb->iovecsz);
			bcopy((caddr_t)prpb->iovec, (caddr_t)bootrpb.iovec,
			    prpb->iovecsz);
		}
	}
a172 1
int
d175 3
d181 1
a183 12
extern struct ivec_dsp idsptch;
extern int jbuf[10];

static void
mcheck(void *arg)
{
	int off, *mfp = (int *)&arg;

	off = (mfp[7]/4 + 8);
	printf("Machine check, pc=%x, psl=%x\n", mfp[off], mfp[off+1]);
	longjmp(jbuf, 1);
}
a188 1
void
d191 1
a213 1
	scb_vec[4/4].hoppaddr = mcheck;
d215 1
a215 2
	if (vax_boardtype != VAX_BTYP_VXT)
		mtpr(-10000, PR_NICR);		/* Load in count register */
d221 1
d225 1
a225 1
rtimer(void *arg)
d233 2
a234 2
	    (vax_boardtype == VAX_BTYP_48) ||
	    (vax_boardtype == VAX_BTYP_49)) {
d238 1
a238 1
			longjmp(jbuf, 1);
a242 10
#ifdef __ELF__
#define	IDSPTCH "idsptch"
#define	EIDSPTCH "eidsptch"
#define	CMN_IDSPTCH "cmn_idsptch"
#else
#define	IDSPTCH "_idsptch"
#define	EIDSPTCH "_eidsptch"
#define	CMN_IDSPTCH "_cmn_idsptch"
#endif

a243 1
	.text
d245 2
a246 2
	.globl	" IDSPTCH ", " EIDSPTCH "
" IDSPTCH ":
d249 1
a249 1
	.long	" CMN_IDSPTCH "
d253 1
a253 1
" EIDSPTCH ":
d255 1
a255 1
" CMN_IDSPTCH ":
d268 2
a269 1
scb_stray(void *arg)
d277 1
@


1.4.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d65 1
a65 1
autoconf(void)
d130 1
a130 1
getsecs(void)
d155 1
a155 1
scbinit(void)
@


1.3
log
@eliminate some confusion between rpb and howto -- also make sure that
the "dev()filename" notation is parsed.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 2000/05/01 00:12:00 bjc Exp $ */
d161 1
@


1.2
log
@fix countdown for vs4000{/60,/90,VLC} -- from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1 2000/04/27 02:26:24 bjc Exp $ */
d88 1
d139 1
@


1.1
log
@sync with netbsd -- this involved rearranging things for sanity reasons
and because separate builds of libsa are done.  this is a pretty nice
bootloader.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 1998/02/03 11:48:24 maja Exp $ */
d215 3
d224 11
@

