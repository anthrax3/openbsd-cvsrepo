head	1.11;
access;
symbols
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.5.0.16
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.14
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.12
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.10
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.5
	UBC:1.2.0.10
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	SMP:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2011.07.10.17.31.40;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2008.08.18.23.20.44;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.12.17.23.21;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.10.18.20.07;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.30.20.02.13;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.24.20.29.38;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.09.20.26.45;	author jsyn;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.11.09.36.23;	author hugh;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.04.04.38.08;	author bjc;	state Exp;
branches
	1.2.6.1
	1.2.10.1;
next	1.1;

1.1
date	2000.04.27.02.26.25;	author bjc;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.21.37.44;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	;

1.2.10.1
date	2002.06.11.03.39.18;	author art;	state Exp;
branches;
next	1.2.10.2;

1.2.10.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Move the vax/boot code to vax/stand.  A cvs 'mv' with de-tagging has been
done behind the scenes to retain history.  Having all the bootblocks in the
same architecture sub-directory satisfies several principles.
ok miod
@
text
@/*	$OpenBSD: consio.c,v 1.10 2008/08/18 23:20:44 miod Exp $ */
/*	$NetBSD: consio.c,v 1.13 2002/05/24 21:40:59 ragge Exp $ */
/*
 * Copyright (c) 1994, 1998 Ludd, University of Lule}, Sweden.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed at Ludd, University of Lule}.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

 /* All bugs are subject to removal without further notice */
		
#include <sys/param.h>

#include "../vax/gencons.h"

#include "mtpr.h"
#include "sid.h"
#include "rpb.h"
#include "ka630.h"

#include "data.h"

#include <machine/cvax.h>
#include <arch/vax/mbus/mbusreg.h>

void setup(void);

static void (*put_fp)(int)  = NULL;
static int (*get_fp)(void) = NULL;
static int (*test_fp)(void) = NULL;

/*
 * I/O using mtpr/mfpr
 */

void	pr_putchar(int c);
int	pr_getchar(void);
int	pr_testchar(void);

/*
 * I/O using ROM routines
 */

void	rom_putchar(int c);
int	rom_getchar(void);
int	rom_testchar(void);

int	rom_putc;		/* ROM-address of put-routine */
int	rom_getc;		/* ROM-address of get-routine */

/*
 * I/O using the KA630 ROM console routines
 */

/* Pointer to KA630 console page, initialized by ka630_consinit */
unsigned char	*ka630_conspage;
void	ka630_consinit(void);

void	ka630_rom_putchar(int c);
int	ka630_rom_getchar(void);
int	ka630_rom_testchar(void);

/*
 * I/O using the KA53 ROM console routines
 */

unsigned char  *ka53_conspage;
void	ka53_consinit(void);

void	ka53_rom_putchar(int c);
int	ka53_rom_getchar(void);
int	ka53_rom_testchar(void);

/*
 * I/O using the VXT2000 serial ports
 */

void	vxt_putchar(int c);
int	vxt_getchar(void);
int	vxt_testchar(void);

/*
 * I/O using the KA60 ROM console routines
 */

unsigned char  *ka60_conspage;
void	ka60_consinit(void);

void	ka60_rom_putchar(int c);
int	ka60_rom_getchar(void);
int	ka60_rom_testchar(void);

void	putchar(int);
int	getchar(void);
int	testkey(void);
void	consinit(void);
void	_rtt(void);

void
putchar(int c)
{
	(*put_fp)(c);
	if (c == 10)
		(*put_fp)(13);		/* CR/LF */
}

int
getchar(void) 
{
	int c;

	do
		c = (*get_fp)() & 0177;
	while (c == 17 || c == 19);		/* ignore XON/XOFF */
	if (c < 96 && c > 64)
		c += 32;			/* force lowercase */
	return c;
}

int
testkey(void)
{
	return (*test_fp)();
}

/*
 * setup() is called out of the startup files (start.s, srt0.s) and
 * initializes data which are globally used and is called before main().
 */
void 
consinit(void)
{
	put_fp = pr_putchar; /* Default */
	get_fp = pr_getchar;
	test_fp = pr_testchar;

	/*
	 * According to the vax_boardtype (vax_cputype is not specific
	 * enough to do that) we decide which method/routines to use
	 * for console I/O. 
	 * mtpr/mfpr are restricted to serial consoles, ROM-based routines
	 * support both serial and graphical consoles.
	 * We default to mtpr routines; so that we don't crash if
	 * it isn't a supported system.
	 */
	switch (vax_boardtype) {

	case VAX_BTYP_43:
	case VAX_BTYP_410:	  
	case VAX_BTYP_420:
		put_fp = rom_putchar;
		get_fp = rom_getchar;
		test_fp = rom_testchar;
		rom_putc = 0x20040058;		/* 537133144 */
		rom_getc = 0x20040044;		/* 537133124 */
		break;

	case VAX_BTYP_VXT:
		put_fp = rom_putchar;
		get_fp = vxt_getchar;
		test_fp = vxt_testchar;
		rom_putc = 0x20040058;		/* 537133144 */
		rom_getc = 0x20040044;		/* 537133124 */
		break;

	case VAX_BTYP_630:
		ka630_consinit();
		break;

	case VAX_BTYP_46:
	case VAX_BTYP_48:
	case VAX_BTYP_49:
		put_fp = rom_putchar;
		get_fp = rom_getchar;
		test_fp = rom_testchar;
		rom_putc = 0x20040068;
		rom_getc = 0x20040054;
		break;

	case VAX_BTYP_1303:
		ka53_consinit();
		break;

	case VAX_BTYP_60:
		ka60_consinit();
		break;

#ifdef notdef
	case VAX_BTYP_630:
	case VAX_BTYP_650:
	case VAX_BTYP_9CC:
		put_fp = pr_putchar;
		get_fp = pr_getchar;
		break
#endif
	}
	return;
}

/*
 * putchar() using MTPR
 */
void
pr_putchar(int c)
{
	int	timeout = 1<<15;	/* don't hang the machine! */

	/*
	 * On KA88 we may get C-S/C-Q from the console.
	 * Must obey it.
	 */
	while (mfpr(PR_RXCS) & GC_DON) {
		if ((mfpr(PR_RXDB) & 0x7f) == 19) {
			while (1) {
				while ((mfpr(PR_RXCS) & GC_DON) == 0)
					;
				if ((mfpr(PR_RXDB) & 0x7f) == 17)
					break;
			}
		}
	}

	while ((mfpr(PR_TXCS) & GC_RDY) == 0)  /* Wait until xmit ready */
		if (--timeout < 0)
			break;
	mtpr(c, PR_TXDB);		/* xmit character */
}

/*
 * getchar() using MFPR
 */
int
pr_getchar(void)
{
	while ((mfpr(PR_RXCS) & GC_DON) == 0)
		;	/* wait for char */
	return (mfpr(PR_RXDB));			/* now get it */
}

int
pr_testchar(void)
{
	if (mfpr(PR_RXCS) & GC_DON)
		return mfpr(PR_RXDB);
	else
		return 0;
}

/*
 * void ka630_consinit (void)  ==> initialize KA630 ROM console I/O
 */
void ka630_consinit(void)
{
	short *NVR;
	int i;

	/* Find the console page */
	NVR = (short *) KA630_NVR_ADRS;
   
	i = *NVR++ & 0xFF;
	i |= (*NVR++ & 0xFF) << 8;
	i |= (*NVR++ & 0xFF) << 16;
	i |= (*NVR++ & 0xFF) << 24;

	ka630_conspage = (char *) i;

	/* Go to last row to minimize confusion */
	ka630_conspage[KA630_ROW] = ka630_conspage[KA630_MAXROW];
	ka630_conspage[KA630_COL] = ka630_conspage[KA630_MINCOL];

	/* Use KA630 ROM console I/O routines */
	put_fp = ka630_rom_putchar;
	get_fp = ka630_rom_getchar;
	test_fp = ka630_rom_testchar;
}


/*
 * void ka53_consinit (void)  ==> initialize KA53 ROM console I/O
 */
void ka53_consinit(void)
{
	ka53_conspage = (char *) 0x2014044b;

	put_fp = ka53_rom_putchar;
	get_fp = ka53_rom_getchar;
	test_fp = ka53_rom_testchar;
}

/*
 * VXT2000 console routines.
 *
 * While we can use the rom putchar routine, the rom getchar routine
 * will happily return the last key pressed, even if it is not pressed
 * anymore.
 *
 * To guard against this, we monitor the keyboard serial port and will
 * only invoke the rom function (which will do the keyboard layout
 * translation for us) if there is indeed a new keyboard event (we still
 * need to guard against dead keys, hence the while() condition in
 * vxt_getchar). This still unfortunately causes phantom characters to
 * appear when playing with the shift keys, but nothing backspace can't
 * erase, so this will be a minor annoyance.
 *
 * If console is on the serial port, we do not use the prom routines at
 * all.
 */
static volatile int *vxtregs = (int *)0x200A0000;

#define	CH_SRA		0x01
#define	CH_CRA		0x02
#define	CH_DATA		0x03
#define	CH_SRC		0x11
#define	CH_CRC		0x12
#define	CH_DATC		0x13

#define	CR_RX_ENA	0x01
#define	CR_TX_ENA	0x04
#define SR_RX_RDY	0x01
#define SR_TX_RDY	0x04

int
vxt_getchar(void)
{
	if (vax_confdata & 2) {
		vxtregs[CH_CRC] = CR_RX_ENA;
		while ((vxtregs[CH_SRC] & SR_RX_RDY) == 0 ||
		    rom_testchar() == 0)
			;
		return rom_getchar();
	} else {
		vxtregs[CH_CRA] = CR_RX_ENA;
		while ((vxtregs[CH_SRA] & SR_RX_RDY) == 0)
			;
		return vxtregs[CH_DATA];
	}
}

int
vxt_testchar(void)
{
	if (vax_confdata & 2) {
		vxtregs[CH_CRC] = CR_RX_ENA;
		if ((vxtregs[CH_SRC] & SR_RX_RDY) == 0)
			return 0;
		return rom_testchar();
	} else {
		vxtregs[CH_CRA] = CR_RX_ENA;
		if ((vxtregs[CH_SRA] & SR_RX_RDY) == 0)
			return 0;
		return vxtregs[CH_DATA];
	}
}

int ka60_ioslot = -1;

/*
 * void ka60_consinit (void)  ==> initialize KA60 ROM console I/O
 */
void ka60_consinit(void)
{
	extern int jbuf[10];
	extern int mcheck_silent;
	extern int setjmp(int *);

	int mid, fbicaddr;
	uint32_t modtype, fbicrange;

	for (mid = 0; mid < MBUS_SLOT_MAX; mid++) {
		fbicaddr = MBUS_SLOT_BASE(mid) + FBIC_BASE;

		if (setjmp(jbuf)) {
			/* this slot is empty */
			continue;
		}
		mcheck_silent = 1;
		modtype = *(uint32_t *)(fbicaddr + FBIC_MODTYPE);
		mcheck_silent = 0;

		if ((modtype & MODTYPE_CLASS_MASK) >> MODTYPE_CLASS_SHIFT !=
		    CLASS_IO)
			continue;

		ka60_ioslot = mid;

		fbicrange = *(uint32_t *)(fbicaddr + FBIC_RANGE);
		if (fbicrange ==
		    ((HOST_TO_MBUS(CVAX_SSC) & RANGE_MATCH) | RANGE_ENABLE))
			break;
	}
	mcheck_silent = 0;

	if (ka60_ioslot < 0) {
		/*
		 * This shouldn't happen. Try mid #5 (enclosure slot #4) as a
		 * supposedly sane default.
		 */
		ka60_ioslot = 5;
	}

	ka60_conspage = (char *) *(unsigned int *)0x20140514;
	put_fp = ka60_rom_putchar;
	get_fp = ka60_rom_getchar;
	test_fp = ka60_rom_testchar;
}
@


1.10
log
@Now that KA60 support is in, include the proper header files instead of
harcoding defines, and add rpb device type #39 (sii) boot information.
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.9 2008/08/12 17:23:21 miod Exp $ */
@


1.9
log
@Figured out where the prom console routines are on KA60 and how to invoke
them, thanks to old ultrix bootblocks lying around.
Also, enable M-Bus clock on the I/O slot IOCSR, this unstucks the cpu
clocks (which really are implemented on the SSC on the I/O module, but
need to be controlled via the cpu's ``internal'' processor registers...)
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.8 2008/08/10 18:20:07 miod Exp $ */
d46 3
d389 5
a393 1
	int mid, modaddr, modtype;
a394 3
	mcheck_silent = 1;
	for (mid = 0; mid < 8; mid++) {
		modaddr = 0x31fffffc + (mid << 25);
d399 13
a411 3
		modtype = *(int *)modaddr;
		if ((modtype & 0xff) == 0x04) {
			ka60_ioslot = mid;
a412 1
		}
d418 1
a418 1
		 * This shouldn't happen. Try mid #5 (slot #4) as a
@


1.8
log
@Add support for the VAXstation 3[58][24]0 to the bootblocks, currently
limited to serial console. This is enough for a 3520 to mopboot and download
a kernel over NFS.
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.7 2006/08/30 20:02:13 miod Exp $ */
d103 1
a103 1
 * I/O using the VS3[58][24]0 serial ports
d106 6
a111 4
void	ff_consinit(void);
void	ff_putchar(int c);
int	ff_getchar(void);
int	ff_testchar(void);
d205 1
a205 4
		put_fp = ff_putchar;
		get_fp = ff_getchar;
		test_fp = ff_testchar;
		ff_consinit();
d270 1
a270 1
 * void ka630_rom_getchar (void)  ==> initialize KA630 ROM console I/O
d375 2
d378 3
a380 31
 * VaxStation 3[58][24]0 console routines.
 *
 * We do not know what the proper ROM entry points are, so these routines
 * drive the serial ports directly.
 *
 * Unfortunately the address of the serial ports depend on the position
 * of the L2003 I/O board in the system, which requires us to check all
 * slots for their ID.  Of course, empty slots will cause a machine check,
 * and the suggested method of looking at the BUSCTL register to know
 * which slots are populated is not usable, since we are way too late in
 * the boot process.
 */

struct ff_dzregs {
	volatile unsigned short csr;
	volatile unsigned short unused;
	volatile unsigned short rbuf;
	volatile unsigned short unused2;
	volatile unsigned short tcr;
	volatile unsigned short unused3;
	volatile unsigned short tdr;
};

#define	DZ_CSR_TX_READY	0100000
#define	DZ_CSR_RX_DONE	0000200

int ff_ioslot = -1;
static struct ff_dzregs *ff_dz;

void
ff_consinit()
a385 1
	int line = 3;	/* printer port */
d397 1
a397 1
			ff_ioslot = mid;
d403 1
a403 1
	if (ff_ioslot < 0) {
d408 1
a408 30
		ff_ioslot = 5;
	}

	ff_dz = (struct ff_dzregs *)
	    (0x30000000 + (ff_ioslot << 25) + 0x00600000);
	ff_dz->tcr = 1 << line;
}

void
ff_putchar(int c)
{
	while ((ff_dz->csr & DZ_CSR_TX_READY) == 0)
		;
	ff_dz->tdr = c;
	while ((ff_dz->csr & DZ_CSR_TX_READY) == 0)
		;
}

int
ff_getchar()
{
	int line = 3;	/* printer port */
	unsigned short rbuf;

	for(;;) {
		while ((ff_dz->csr & DZ_CSR_RX_DONE) == 0)
			;
		rbuf = ff_dz->rbuf;
		if (((rbuf >> 8) & 3) == line)
			break;
d411 4
a414 24
	rbuf &= 0x7f;
	if (rbuf == 13)
		rbuf = 10;

	return (int)rbuf;
}

int
ff_testchar()
{
	int line = 3;	/* printer port */
	unsigned short rbuf;

	if ((ff_dz->csr & DZ_CSR_RX_DONE) == 0)
		return 0;
	rbuf = ff_dz->rbuf;
	if (((rbuf >> 8) & 3) != line)
		return 0;

	rbuf &= 0x7f;
	if (rbuf == 13)
		rbuf = 10;

	return (int)rbuf;
@


1.7
log
@Horrible code to work around stupid VXT2000 rom getchar() behaviour, but
at least this allows our boot blocks to work with glass console on these
machines now.

Caution: reading this code will hurt your eyes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.6 2006/08/24 20:29:38 miod Exp $ */
d35 1
a35 3


#include "sys/param.h"
d52 15
a66 7
void pr_putchar(int c);	/* putchar() using mtpr/mfpr */
int pr_getchar(void);
int pr_testchar(void);

void rom_putchar(int c);	/* putchar() using ROM routines */
int rom_getchar(void);
int rom_testchar(void);
d68 6
a73 2
int rom_putc;		/* ROM-address of put-routine */
int rom_getc;		/* ROM-address of get-routine */
d77 1
d79 3
a81 2
/* Function that initializes things for KA630 ROM console I/O */
void ka630_consinit(void);
d83 3
a85 4
/* Functions that use KA630 ROM for console I/O */
void ka630_rom_putchar(int c);
int ka630_rom_getchar(void);
int ka630_rom_testchar(void);
a86 1
/* Also added such a thing for KA53 - MK-991208 */
d88 17
a104 1
void ka53_consinit(void);
d106 10
a115 13
void ka53_rom_putchar(int c);
int ka53_rom_getchar(void);
int ka53_rom_testchar(void);

void vxt_putchar(int c);
int vxt_getchar(void);
int vxt_testchar(void);

void putchar(int);
int getchar(void);
int testkey(void);
void consinit(void);
void _rtt(void);
d134 1
a134 1
		c += 32;
d202 7
a212 1
	case VAX_BTYP_60:
d374 118
@


1.6
log
@Enable the appropriate serial transmitters in VXT2000 serial routines, this
makes output work when the VXT2000 is not configured for serial console.
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.5 2002/08/09 20:26:45 jsyn Exp $ */
d154 1
a154 1
		put_fp = vxt_putchar;
d157 2
d282 18
d302 7
a308 3
#define	CH_SR		1
#define	CH_CR		2
#define	CH_DAT		3
a313 9
void
vxt_putchar(int c)
{
	vxtregs[CH_CR] = CR_TX_ENA;
	while ((vxtregs[CH_SR] & SR_TX_RDY) == 0)
		;
	vxtregs[CH_DAT] = c;
}

d317 12
a328 4
	vxtregs[CH_CR] = CR_RX_ENA;
	while ((vxtregs[CH_SR] & SR_RX_RDY) == 0)
		;
	return vxtregs[CH_DAT];
d334 11
a344 4
	vxtregs[CH_CR] = CR_RX_ENA;
	if ((vxtregs[CH_SR] & SR_RX_RDY) == 0)
		return 0;
	return vxtregs[CH_DAT];
@


1.5
log
@Get rid of remaining __P usage (except for imported code);
ok millert@@, rogue ok pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.4 2002/06/11 09:36:23 hugh Exp $ */
d283 1
d285 3
a288 1
#define SR_RX_RDY	0x01
d293 1
d302 1
d311 1
@


1.4
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.3 2002/03/14 01:26:47 millert Exp $ */
d69 1
a69 1
void ka630_consinit __P((void));
d72 3
a74 3
void ka630_rom_putchar __P((int c));
int ka630_rom_getchar __P((void));
int ka630_rom_testchar __P((void));
@


1.3
log
@First round of __P removal in sys
@
text
@d1 2
a2 2
/*	$OpenBSD: consio.c,v 1.2 2000/10/04 04:38:08 bjc Exp $ */
/*	$NetBSD: consio.c,v 1.11 2000/07/19 00:58:24 matt Exp $ */
d44 1
d50 1
a50 5
unsigned       *bootregs;
extern struct rpb     *rpb;
struct bqo     *bqo;

static int (*put_fp)(int)  = NULL;
d54 1
a54 9
/* Also added such a thing for KA53 - MK-991208 */
unsigned char  *ka53_conspage;
void ka53_consinit(void);

int ka53_rom_putchar(int c);
int ka53_rom_getchar(void);
int ka53_rom_testchar(void);

int pr_putchar(int c);	/* putchar() using mtpr/mfpr */
d58 1
a58 1
int rom_putchar(int c);	/* putchar() using ROM routines */
d62 2
a63 2
static int rom_putc;		/* ROM-address of put-routine */
static int rom_getc;		/* ROM-address of get-routine */
a64 12
/* Location of address of KA630 console page */
#define NVR_ADRS        0x200B8024
/* Definitions for various locations in the KA630 console page */
#define KA630_PUTC_POLL 0x20
#define KA630_PUTC      0x24
#define KA630_GETC      0x1C
#define KA630_ROW	0x4C
#define KA630_MINROW	0x4D
#define KA630_MAXROW	0x4E
#define KA630_COL	0x50
#define KA630_MINCOL    0x51
#define KA630_MAXCOL	0x52
d66 2
a67 1
unsigned char  *ka630_conspage; 
d69 2
a70 1
void ka630_consinit(void);
d72 11
a82 3
int ka630_rom_putchar(int c);
int ka630_rom_getchar(void);
int ka630_rom_testchar(void);
d84 12
a95 2
putchar(c)
	int c;
d102 2
a103 1
getchar() 
d115 2
a116 1
testkey()
d126 1
a126 1
consinit()
a142 8
	case VAX_BTYP_690:
		put_fp = rom_putchar;
		get_fp = rom_getchar;
		test_fp = rom_testchar;
		rom_putc = 0x20040058;		/* 537133144 */
		rom_getc = 0x20040008;		/* 537133064 */
		break;

d153 6
d160 2
a161 2
	        ka630_consinit();
	        break;
d193 2
a194 2
pr_putchar(c)
        int     c;
d196 18
a213 2
	int     timeout = 1<<15;	/* don't hang the machine! */
        while ((mfpr(PR_TXCS) & GC_RDY) == 0)  /* Wait until xmit ready */
d216 1
a216 1
        mtpr(c, PR_TXDB);		/* xmit character */
d222 2
a223 1
pr_getchar()
d225 2
a226 1
	while ((mfpr(PR_RXCS) & GC_DON) == 0);	/* wait for char */
d230 2
a231 1
pr_testchar()
a237 43
/*
 * int rom_putchar (int c)	==> putchar() using ROM-routines
 */
asm("
	.globl _rom_putchar
	_rom_putchar:
		.word 0x04		# save-mask: R2
		movl	4(ap), r2	# move argument to R2
		jsb	*_rom_putc	# write it
		ret			# that's all
");


/*
 * int rom_getchar (void)	==> getchar() using ROM-routines
 */
asm("
	.globl _rom_getchar
	_rom_getchar:
		.word 0x02		# save-mask: R1
	loop:				# do {
		jsb	*_rom_getc	#   call the getc-routine
		tstl	r0		#   check if char ready
		beql	loop		# } while (R0 == 0)
		movl	r1, r0		# R1 holds char
		ret			# we're done

	_rom_testchar:
		.word	0
		mnegl	$1,r0
		jsb	*_rom_getc
		tstl	r0
		beql	1f
		movl	r1,r0
	1:	ret
");

_rtt()
{
	asm("halt");
}


d242 1
a242 1
void ka630_consinit()
d244 2
a245 2
        register short *NVR;
        register int i;
d247 2
a248 2
        /* Find the console page */
        NVR = (short *) NVR_ADRS;
d250 4
a253 4
        i = *NVR++ & 0xFF;
        i |= (*NVR++ & 0xFF) << 8;
        i |= (*NVR++ & 0xFF) << 16;
        i |= (*NVR++ & 0xFF) << 24;
d255 1
a255 1
        ka630_conspage = (char *) i;
d257 1
a257 1
        /* Go to last row to minimize confusion */
d261 1
a261 1
        /* Use KA630 ROM console I/O routines */
a265 1
   	
a266 22
/*
 * int ka630_rom_getchar (void)	==> getchar() using ROM-routines on KA630
 */
asm("
	.globl _ka630_rom_getchar
	_ka630_rom_getchar:
		.word 0x802		# save-mask: R1, R11
		movl    _ka630_conspage,r11  # load location of console page
        loop630g:		       	# do {
		jsb	*0x1C(r11)	#   call the getc-routine (KA630_GETC)
	        blbc    r0, loop630g    # } while (R0 == 0)
		movl	r1, r0		# R1 holds char
		ret			# we're done

	_ka630_rom_testchar:
		.word	0
		movl	_ka630_conspage,r3
		jsb	*0x1C(r3)
		blbc	r0,1f
		movl	r1,r0
	1:	ret
");
a268 15
 * int ka630_rom_putchar (int c) ==> putchar() using ROM-routines on KA630
 */
asm("
	.globl _ka630_rom_putchar
	_ka630_rom_putchar:
		.word 0x802		# save-mask: R1, R11
		movl    _ka630_conspage,r11  # load location of console page
        loop630p:		       	# do {
		jsb	*0x20(r11)	#   is rom ready? (KA630_PUTC_POLL)
	        blbc    r0, loop630p    # } while (R0 == 0)
		movl	4(ap), r1	# R1 holds char
		jsb     *0x24(r11)      # output character (KA630_PUTC)
		ret			# we're done
");
/*
d280 1
a280 3
/*
 * int ka53_rom_getchar (void)	==> getchar() using ROM-routines
 */
d282 4
a285 25
asm("
	.globl _ka53_rom_getchar
	_ka53_rom_getchar:
		.word 0x0802	# r1, r11
		movl _ka53_conspage, r11	 # load location of console page
1:		jsb *0x64(r11) 	# test for char
		blbc r0, 1b		# while r0 is 0
		jsb *0x6c(r11)	# get char
		ret
");

asm("
	.globl _ka53_rom_testchar
	_ka53_rom_testchar:
		.word	0x8		# r3
		movl	_ka53_conspage, r3
		jsb *0x64(r3)
		blbc r0, 1f
		jsb *0x6c(r3)	# get it
1:		ret
");
		
/*
 * int ka53_rom_putchar (int c) ==> putchar() using ROM-routines 
 */
d287 7
a293 11
asm("
	.globl _ka53_rom_putchar
	_ka53_rom_putchar:
		.word 0x0802	# r1, r11
		movl _ka53_conspage, r11
1:		jsb *0x20(r11)	# ready to write?
		blbc r0, 1b		# keep going if r0 == 0
		movl 4(ap), r1	# char is in r1
		jsb *0x24(r11)	# output char
		ret
");
d295 7
d303 7
@


1.2
log
@- don't reassign rpb here, it is done elsewhere
- add code for VAX_BTYP_1303 systems, tested so far on hugh@@'s ka53
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.1 2000/04/27 02:26:25 bjc Exp $ */
d47 1
a47 1
void setup __P((void));
d53 3
a55 3
static int (*put_fp) __P((int))  = NULL;
static int (*get_fp) __P((void)) = NULL;
static int (*test_fp) __P((void)) = NULL;
d59 1
a59 1
void ka53_consinit __P((void));
d61 11
a71 11
int ka53_rom_putchar __P((int c));
int ka53_rom_getchar __P((void));
int ka53_rom_testchar __P((void));

int pr_putchar __P((int c));	/* putchar() using mtpr/mfpr */
int pr_getchar __P((void));
int pr_testchar __P((void));

int rom_putchar __P((int c));	/* putchar() using ROM routines */
int rom_getchar __P((void));
int rom_testchar __P((void));
d91 1
a91 1
void ka630_consinit __P((void));
d93 3
a95 3
int ka630_rom_putchar __P((int c));
int ka630_rom_getchar __P((void));
int ka630_rom_testchar __P((void));
@


1.2.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.2 2000/10/04 04:38:08 bjc Exp $ */
d47 1
a47 1
void setup(void);
d53 3
a55 3
static int (*put_fp)(int)  = NULL;
static int (*get_fp)(void) = NULL;
static int (*test_fp)(void) = NULL;
d59 1
a59 1
void ka53_consinit(void);
d61 11
a71 11
int ka53_rom_putchar(int c);
int ka53_rom_getchar(void);
int ka53_rom_testchar(void);

int pr_putchar(int c);	/* putchar() using mtpr/mfpr */
int pr_getchar(void);
int pr_testchar(void);

int rom_putchar(int c);	/* putchar() using ROM routines */
int rom_getchar(void);
int rom_testchar(void);
d91 1
a91 1
void ka630_consinit(void);
d93 3
a95 3
int ka630_rom_putchar(int c);
int ka630_rom_getchar(void);
int ka630_rom_testchar(void);
@


1.2.10.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: consio.c,v 1.13 2002/05/24 21:40:59 ragge Exp $ */
a43 1
#include "ka630.h"
d49 5
a53 1
static void (*put_fp)(int)  = NULL;
d57 9
a65 1
void pr_putchar(int c);	/* putchar() using mtpr/mfpr */
d69 1
a69 1
void rom_putchar(int c);	/* putchar() using ROM routines */
d73 2
a74 2
int rom_putc;		/* ROM-address of put-routine */
int rom_getc;		/* ROM-address of get-routine */
d76 12
d89 1
a89 2
unsigned char	*ka630_conspage;

a91 1

d93 1
a93 1
void ka630_rom_putchar(int c);
d97 2
a98 20
/* Also added such a thing for KA53 - MK-991208 */
unsigned char  *ka53_conspage;
void ka53_consinit(void);

void ka53_rom_putchar(int c);
int ka53_rom_getchar(void);
int ka53_rom_testchar(void);

void vxt_putchar(int c);
int vxt_getchar(void);
int vxt_testchar(void);

void putchar(int);
int getchar(void);
int testkey(void);
void consinit(void);
void _rtt(void);

void
putchar(int c)
d105 1
a105 2
int
getchar(void) 
d117 1
a117 2
int
testkey(void)
d127 1
a127 1
consinit(void)
d144 8
a161 6
	case VAX_BTYP_VXT:
		put_fp = vxt_putchar;
		get_fp = vxt_getchar;
		test_fp = vxt_testchar;
		break;

d163 2
a164 2
		ka630_consinit();
		break;
d196 2
a197 2
void
pr_putchar(int c)
d199 2
a200 18
	int	timeout = 1<<15;	/* don't hang the machine! */

	/*
	 * On KA88 we may get C-S/C-Q from the console.
	 * Must obey it.
	 */
	while (mfpr(PR_RXCS) & GC_DON) {
		if ((mfpr(PR_RXDB) & 0x7f) == 19) {
			while (1) {
				while ((mfpr(PR_RXCS) & GC_DON) == 0)
					;
				if ((mfpr(PR_RXDB) & 0x7f) == 17)
					break;
			}
		}
	}

	while ((mfpr(PR_TXCS) & GC_RDY) == 0)  /* Wait until xmit ready */
d203 1
a203 1
	mtpr(c, PR_TXDB);		/* xmit character */
d209 1
a209 2
int
pr_getchar(void)
d211 1
a211 2
	while ((mfpr(PR_RXCS) & GC_DON) == 0)
		;	/* wait for char */
d215 1
a215 2
int
pr_testchar(void)
d222 43
d269 1
a269 1
void ka630_consinit(void)
d271 2
a272 2
	short *NVR;
	int i;
d274 2
a275 2
	/* Find the console page */
	NVR = (short *) KA630_NVR_ADRS;
d277 4
a280 4
	i = *NVR++ & 0xFF;
	i |= (*NVR++ & 0xFF) << 8;
	i |= (*NVR++ & 0xFF) << 16;
	i |= (*NVR++ & 0xFF) << 24;
d282 1
a282 1
	ka630_conspage = (char *) i;
d284 1
a284 1
	/* Go to last row to minimize confusion */
d288 1
a288 1
	/* Use KA630 ROM console I/O routines */
d293 1
d295 22
d319 15
d345 3
a347 1
static volatile int *vxtregs = (int *)0x200A0000;
d349 25
a373 4
#define	CH_SR		1
#define	CH_DAT		3
#define SR_TX_RDY	0x04
#define SR_RX_RDY	0x01
d375 11
a385 7
void
vxt_putchar(int c)
{
	while ((vxtregs[CH_SR] & SR_TX_RDY) == 0)
		;
	vxtregs[CH_DAT] = c;
}
a386 7
int
vxt_getchar(void)
{
	while ((vxtregs[CH_SR] & SR_RX_RDY) == 0)
		;
	return vxtregs[CH_DAT];
}
a387 7
int
vxt_testchar(void)
{
	if ((vxtregs[CH_SR] & SR_RX_RDY) == 0)
		return 0;
	return vxtregs[CH_DAT];
}
@


1.2.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: consio.c,v 1.2 2000/10/04 04:38:08 bjc Exp $ */
@


1.2.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d47 1
a47 1
void setup(void);
d53 3
a55 3
static int (*put_fp)(int)  = NULL;
static int (*get_fp)(void) = NULL;
static int (*test_fp)(void) = NULL;
d59 1
a59 1
void ka53_consinit(void);
d61 11
a71 11
int ka53_rom_putchar(int c);
int ka53_rom_getchar(void);
int ka53_rom_testchar(void);

int pr_putchar(int c);	/* putchar() using mtpr/mfpr */
int pr_getchar(void);
int pr_testchar(void);

int rom_putchar(int c);	/* putchar() using ROM routines */
int rom_getchar(void);
int rom_testchar(void);
d91 1
a91 1
void ka630_consinit(void);
d93 3
a95 3
int ka630_rom_putchar(int c);
int ka630_rom_getchar(void);
int ka630_rom_testchar(void);
@


1.2.6.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: consio.c,v 1.13 2002/05/24 21:40:59 ragge Exp $ */
a43 1
#include "ka630.h"
d49 5
a53 1
static void (*put_fp)(int)  = NULL;
d57 9
a65 1
void pr_putchar(int c);	/* putchar() using mtpr/mfpr */
d69 1
a69 1
void rom_putchar(int c);	/* putchar() using ROM routines */
d73 2
a74 2
int rom_putc;		/* ROM-address of put-routine */
int rom_getc;		/* ROM-address of get-routine */
d76 12
d89 1
a89 2
unsigned char	*ka630_conspage;

a91 1

d93 1
a93 1
void ka630_rom_putchar(int c);
d97 2
a98 20
/* Also added such a thing for KA53 - MK-991208 */
unsigned char  *ka53_conspage;
void ka53_consinit(void);

void ka53_rom_putchar(int c);
int ka53_rom_getchar(void);
int ka53_rom_testchar(void);

void vxt_putchar(int c);
int vxt_getchar(void);
int vxt_testchar(void);

void putchar(int);
int getchar(void);
int testkey(void);
void consinit(void);
void _rtt(void);

void
putchar(int c)
d105 1
a105 2
int
getchar(void) 
d117 1
a117 2
int
testkey(void)
d127 1
a127 1
consinit(void)
d144 8
a161 6
	case VAX_BTYP_VXT:
		put_fp = vxt_putchar;
		get_fp = vxt_getchar;
		test_fp = vxt_testchar;
		break;

d163 2
a164 2
		ka630_consinit();
		break;
d196 2
a197 2
void
pr_putchar(int c)
d199 2
a200 18
	int	timeout = 1<<15;	/* don't hang the machine! */

	/*
	 * On KA88 we may get C-S/C-Q from the console.
	 * Must obey it.
	 */
	while (mfpr(PR_RXCS) & GC_DON) {
		if ((mfpr(PR_RXDB) & 0x7f) == 19) {
			while (1) {
				while ((mfpr(PR_RXCS) & GC_DON) == 0)
					;
				if ((mfpr(PR_RXDB) & 0x7f) == 17)
					break;
			}
		}
	}

	while ((mfpr(PR_TXCS) & GC_RDY) == 0)  /* Wait until xmit ready */
d203 1
a203 1
	mtpr(c, PR_TXDB);		/* xmit character */
d209 1
a209 2
int
pr_getchar(void)
d211 1
a211 2
	while ((mfpr(PR_RXCS) & GC_DON) == 0)
		;	/* wait for char */
d215 1
a215 2
int
pr_testchar(void)
d222 43
d269 1
a269 1
void ka630_consinit(void)
d271 2
a272 2
	short *NVR;
	int i;
d274 2
a275 2
	/* Find the console page */
	NVR = (short *) KA630_NVR_ADRS;
d277 4
a280 4
	i = *NVR++ & 0xFF;
	i |= (*NVR++ & 0xFF) << 8;
	i |= (*NVR++ & 0xFF) << 16;
	i |= (*NVR++ & 0xFF) << 24;
d282 1
a282 1
	ka630_conspage = (char *) i;
d284 1
a284 1
	/* Go to last row to minimize confusion */
d288 1
a288 1
	/* Use KA630 ROM console I/O routines */
d293 1
d295 22
d319 15
d345 3
a347 1
static volatile int *vxtregs = (int *)0x200A0000;
d349 25
a373 4
#define	CH_SR		1
#define	CH_DAT		3
#define SR_TX_RDY	0x04
#define SR_RX_RDY	0x01
d375 11
a385 7
void
vxt_putchar(int c)
{
	while ((vxtregs[CH_SR] & SR_TX_RDY) == 0)
		;
	vxtregs[CH_DAT] = c;
}
a386 7
int
vxt_getchar(void)
{
	while ((vxtregs[CH_SR] & SR_RX_RDY) == 0)
		;
	return vxtregs[CH_DAT];
}
a387 7
int
vxt_testchar(void)
{
	if ((vxtregs[CH_SR] & SR_RX_RDY) == 0)
		return 0;
	return vxtregs[CH_DAT];
}
@


1.1
log
@sync with netbsd -- this involved rearranging things for sanity reasons
and because separate builds of libsa are done.  this is a pretty nice
bootloader.
@
text
@d1 2
a2 2
/*	$OpenBSD: consio.c,v 1.4 1998/02/03 11:48:26 maja Exp $ */
/*	$NetBSD: consio.c,v 1.6 1999/08/23 19:09:27 ragge Exp $ */
d50 1
a50 1
struct rpb     *rpb;
d57 8
a132 2
	rpb = (struct rpb *)bootregs[11];	/* bertram: ??? */

a144 1
	case VAX_BTYP_1303:
d176 4
d333 55
@

