head	1.4;
access;
symbols
	OPENBSD_5_9:1.3.0.28
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.30
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.22
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.26
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.24
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.20
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.18
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.16
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.14
	OPENBSD_5_0:1.3.0.12
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.10
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.4
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.3;
commitid	OSDG2O3Cgeifnf1W;

1.3
date	2008.08.30.20.13.03;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.20.18.52.07;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.18.23.19.22;	author miod;	state Exp;
branches;
next	;


desc
@@


1.4
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: siivar.h,v 1.3 2008/08/30 20:13:03 miod Exp $	*/
/*	$NetBSD: siivar.h,v 1.6 2000/06/02 20:16:51 mhitch Exp $	*/

#ifndef _SIIVAR_H
#define _SIIVAR_H

typedef struct scsi_state {
	int	statusByte;	/* status byte returned during STATUS_PHASE */
	int	dmaDataPhase;	/* which data phase to expect */
	int	dmaCurPhase;	/* SCSI phase if DMA is in progress */
	int	dmaPrevPhase;	/* SCSI phase of DMA suspended by disconnect */
	u_int	dmaAddr[2];	/* DMA buffer memory offsets */
	int	dmaBufIndex;	/* which of the above is currently in use */
	int	dmalen;		/* amount to transfer in this chunk */
	int	cmdlen;		/* total remaining amount of cmd to transfer */
	u_char	*cmd;		/* current pointer within scsicmd->cmd */
	int	buflen;		/* total remaining amount of data to transfer */
	char	*buf;		/* current pointer within scsicmd->buf */
	u_short	flags;		/* see below */
	u_int8_t nextCmd;	/* next command to send if PENDING_CMD set */
	u_short	prevComm;	/* command reg before disconnect */
	u_short	dmaCtrl;	/* DMA control register if disconnect */
	u_short	dmaAddrL;	/* DMA address register if disconnect */
	u_short	dmaAddrH;	/* DMA address register if disconnect */
	u_short	dmaCnt;		/* DMA count if disconnect */
	u_short	dmaByte;	/* DMA byte if disconnect on odd boundary */
	u_short	dmaReqAck;	/* DMA synchronous xfer offset or 0 if async */
} State;

/* state flags */
#define FIRST_DMA	0x01	/* true if no data DMA started yet */
#define	PENDING_CMD	0x02	/* need to send a particular command */

#define SII_NCMD	8
struct sii_softc {
	struct device sc_dev;		/* us as a device */
	struct scsi_link sc_link;	/* scsi link struct */
	SIIRegs	*sc_regs;		/* HW address of SII controller chip */
	int	sc_flags;
	int	sc_target;		/* target SCSI ID if connected */
	int	sc_hostid;
	void	(*sii_copytobuf)(void *, u_char *, u_int, int);
 	void	(*sii_copyfrombuf)(void *, u_int, u_char *, int);

	struct scsi_xfer *sc_xs[SII_NCMD]; /* currently executing requests */
	State	sc_st[SII_NCMD];	/* state info for each active command */

	u_char	sc_buf[258];		/* used for extended messages */
};

/* Machine-independent back-end attach entry point */
void	sii_attach(struct sii_softc *sc);
int	sii_intr(void *sc);

#endif	/* _SIIVAR_H */
@


1.3
log
@Code refactorization and state structure changes in preparation of asynchronous
abort commands, needed to eventually support command timeouts for non-polled
commands... no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: siivar.h,v 1.2 2008/08/20 18:52:07 miod Exp $	*/
@


1.2
log
@Don't copy interesting parts of struct scsi_xfer to a read only internal
ScsiCmd structure. Since we keep a pointer to the scsi_xfer nevertheless,
we can get the information from it directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: siivar.h,v 1.1 2008/08/18 23:19:22 miod Exp $	*/
d20 1
d32 1
a32 1
#define PARITY_ERR	0x02	/* true if parity error seen */
@


1.1
log
@Add support for the ``Firefox'' VAXstation 3520/3540/3820/3840 workstations,
currently limited to serial console and a single processor working.

All ``on-board'' devices, including the Q-bus adapter, but except for
the frame buffer, are supported. The machine will boot over the network
or from SCSI devices.

Lots of thanks to Al Kossow for www.bitsavers.org, on which I found the
technical documentation allowing me to complete this port (which was
lacking at the time I got that machine...).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a6 15
/*
 * This structure contains information that a SCSI interface controller
 * needs to execute a SCSI command.
 */
typedef struct ScsiCmd {
	int	unit;		/* unit number passed to device done routine */
	int	flags;		/* control flags for this command (see below) */
	int	buflen;		/* length of the data buffer in bytes */
	char	*buf;		/* pointer to data buffer for this command */
	int	cmdlen;		/* length of data in cmdbuf */
	u_char	*cmd;		/* buffer for the SCSI command */
	int	error;		/* compatibility hack for new scsi */
	int	lun;		/* LUN for MI SCSI */
} ScsiCmd;

d36 1
a36 3
	struct scsi_link sc_link;		/* scsi link struct */
	ScsiCmd sc_cmd_fake[SII_NCMD];		/* XXX - hack!!! */
	struct scsi_xfer *sc_xs[SII_NCMD];	/* XXX - hack!!! */
a40 1
	ScsiCmd	*sc_cmd[SII_NCMD];	/* active command indexed by ID */
d44 1
d47 1
a47 1
	u_char	sc_buf[258];	/* used for extended messages */
@

