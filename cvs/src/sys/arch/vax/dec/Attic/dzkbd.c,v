head	1.16;
access;
symbols
	OPENBSD_5_9:1.15.0.8
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.10
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.20
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.18
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.16
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.14
	OPENBSD_5_0:1.14.0.12
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.10
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.15;
commitid	OSDG2O3Cgeifnf1W;

1.15
date	2014.01.26.17.48.07;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.08.20.16.31.41;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2008.08.18.23.04.28;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.27.16.50.43;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.05.22.05.55;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.03.20.19.29;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.31.21.57.05;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.31.06.47.25;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.30.18.35.10;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.29.17.06.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.17.20.26.16;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.10.00.11.14;	author nordin;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.16.22.15.17;	author hugh;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	;

1.1.6.1
date	2002.01.31.22.55.26;	author niklas;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: dzkbd.c,v 1.15 2014/01/26 17:48:07 miod Exp $	*/
/*	$NetBSD: dzkbd.c,v 1.1 2000/12/02 17:03:55 ragge Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kbd.c	8.2 (Berkeley) 10/30/93
 */

/*
 * LK200/LK400 keyboard attached to line 0 of the DZ*-11
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/timeout.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>
#include <vax/dec/wskbdmap_lk201.h>

#include <machine/bus.h> 

#include <vax/qbus/dzreg.h>
#include <vax/qbus/dzvar.h>

#include <vax/dec/dzkbdvar.h>
#include <vax/dec/lk201reg.h>
#include <vax/dec/lk201var.h>

struct dzkbd_internal {
	struct dz_linestate *dzi_ls;
	struct lk201_state dzi_ks;
};

struct dzkbd_internal dzkbd_console_internal;

struct dzkbd_softc {
	struct device dzkbd_dev;	/* required first: base device */

	struct dzkbd_internal *sc_itl;
	int sc_enabled;
	struct device *sc_wskbddev;
};

int	dzkbd_match(struct device *, struct cfdata *, void *);
void	dzkbd_attach(struct device *, struct device *, void *);

struct cfattach dzkbd_ca = {
	sizeof(struct dzkbd_softc), (cfmatch_t)dzkbd_match, dzkbd_attach,
};

int	dzkbd_enable(void *, int);
void	dzkbd_set_leds(void *, int);
int	dzkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);

const struct wskbd_accessops dzkbd_accessops = {
	dzkbd_enable,
	dzkbd_set_leds,
	dzkbd_ioctl,
};

void	dzkbd_cngetc(void *, u_int *, int *);
void	dzkbd_cnpollc(void *, int);

const struct wskbd_consops dzkbd_consops = {
	dzkbd_cngetc,
	dzkbd_cnpollc,
};

const struct wskbd_mapdata dzkbd_keymapdata = {
	lkkbd_keydesctab,
#ifdef LKKBD_LAYOUT
	LKKBD_LAYOUT,
#else
	KB_US | KB_DEFAULT,
#endif
};

int	dzkbd_input(void *, int);
int	dzkbd_sendchar(void *, int);

/*
 * kbd_match: how is this dz line configured?
 */
int
dzkbd_match(struct device *parent, struct cfdata *cf, void *aux)
{
	struct dzkm_attach_args *daa = aux;

#define DZCF_LINE 0
#define DZCF_LINE_DEFAULT 0

	/* Exact match is better than wildcard. */
	if (cf->cf_loc[DZCF_LINE] == daa->daa_line)
		return 2;

	/* This driver accepts wildcard. */
	if (cf->cf_loc[DZCF_LINE] == DZCF_LINE_DEFAULT)
		return 1;

	return 0;
}

void
dzkbd_attach(struct device *parent, struct device *self, void *aux)
{
	struct dz_softc *dz = (void *)parent;
	struct dzkbd_softc *dzkbd = (void *)self;
	struct dzkm_attach_args *daa = aux;
	struct dz_linestate *ls;
	struct dzkbd_internal *dzi;
	struct wskbddev_attach_args a;
	int isconsole;

	dz->sc_dz[daa->daa_line].dz_catch = dzkbd_input;
	dz->sc_dz[daa->daa_line].dz_private = dzkbd;
	ls = &dz->sc_dz[daa->daa_line];

	isconsole = (daa->daa_flags & DZKBD_CONSOLE);

	if (isconsole) {
		dzi = &dzkbd_console_internal;
		dzkbd->sc_enabled = 1;
	} else {
		dzi = malloc(sizeof(struct dzkbd_internal), M_DEVBUF, M_NOWAIT);
		if (dzi == NULL) {
			printf(": out of memory\n");
			return;
		}
		dzi->dzi_ks.attmt.sendchar = dzkbd_sendchar;
		dzi->dzi_ks.attmt.cookie = ls;
	}
	dzi->dzi_ks.device = self;
	dzi->dzi_ls = ls;
	dzkbd->sc_itl = dzi;

	printf("\n");

	if (!isconsole)
		lk201_init(&dzi->dzi_ks);

	a.console = dzi == &dzkbd_console_internal;
	a.keymap = &dzkbd_keymapdata;
	a.accessops = &dzkbd_accessops;
	a.accesscookie = dzkbd;

	dzkbd->sc_wskbddev = config_found(self, &a, wskbddevprint);
}

int
dzkbd_cnattach()
{
	/*
	 * Early operation (especially keyboard initialization)
	 * requires the help of the serial console routines, which
	 * need to be initialized to work with the keyboard line.
	 */
	dzcninit_internal(0, 1);

	dzkbd_console_internal.dzi_ks.attmt.sendchar = dzkbd_sendchar;
	dzkbd_console_internal.dzi_ks.attmt.cookie = NULL;
	lk201_init(&dzkbd_console_internal.dzi_ks);
	dzkbd_console_internal.dzi_ls = NULL;

	wskbd_cnattach(&dzkbd_consops, &dzkbd_console_internal,
	    &dzkbd_keymapdata);

	return 0;
}

int
dzkbd_enable(void *v, int on)
{
	struct dzkbd_softc *sc = v;

	sc->sc_enabled = on;
	return 0;
}

void
dzkbd_cngetc(void *v, u_int *type, int *data)
{
	struct dzkbd_internal *dzi = v;
#if 0
	int line = dzi->dzi_ls != NULL ? dzi->dzi_ls->dz_line : 0;
#else
	int line = 0;	/* keyboard */
#endif
	int c, s;

	do {
		s = spltty();
		c = dzcngetc_internal(line);
		splx(s);
	} while (lk201_decode(&dzi->dzi_ks, 1, 0, c, type, data) == LKD_NODATA);
}

void
dzkbd_cnpollc(void *v, int on)
{
#if 0
	struct dzkbd_internal *dzi = v;
#endif
}

void
dzkbd_set_leds(void *v, int leds)
{
	struct dzkbd_softc *sc = (struct dzkbd_softc *)v;

	lk201_set_leds(&sc->sc_itl->dzi_ks, leds);
}

int
dzkbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct dzkbd_softc *sc = (struct dzkbd_softc *)v;

	switch (cmd) {
	case WSKBDIO_GTYPE:
		*(int *)data = lk201_get_type(&sc->sc_itl->dzi_ks);
		return 0;
	case WSKBDIO_SETLEDS:
		lk201_set_leds(&sc->sc_itl->dzi_ks, *(int *)data);
		return 0;
	case WSKBDIO_GETLEDS:
		*(int *)data = lk201_get_leds(&sc->sc_itl->dzi_ks);
		return 0;
	case WSKBDIO_COMPLEXBELL:
		lk201_bell(&sc->sc_itl->dzi_ks,
			   (struct wskbd_bell_data *)data);
		return 0;
	}
	return -1;
}

int
dzkbd_input(void *v, int data)
{
	struct dzkbd_softc *sc = (struct dzkbd_softc *)v;
	u_int type;
	int val;
	int decode;

	/*
	 * We want to run through lk201_decode always, so that a late plugged
	 * keyboard will get configured correctly.
	 */
	do {
		decode = lk201_decode(&sc->sc_itl->dzi_ks, sc->sc_enabled, 1,
		    data, &type, &val);
		if (decode != LKD_NODATA)
			wskbd_input(sc->sc_wskbddev, type, val);
	} while (decode == LKD_MORE);

	return(1);
}

int
dzkbd_sendchar(void *v, int c)
{
	dzputc((struct dz_linestate *)v, c);
	return (0);
}
@


1.15
log
@Attempt to make user changes of keyboard layout a bit more `sticky' on wsmux
kernels:
- keyboard drivers will now tell wskbd if the keyboard layout they ask
  for is a default value, or a value they are 100% sure of (either
  because your kernel has a XXXKBD_LAYOUT option, or because the
  driver can tell the keyboard layout, e.g. by the country code on USB
  keyboards which provide it, such as Sun's)
- when attaching a keyboard with a non-default layout, the layout will
  become the default layout of the mux for new keyboard attachments if
  the mux doesn't have a layout set already.
- when changing the keyboard layout of a particular keyboard with an
  ioctl (i.e. using kbd(8) or wsconsctl(8)), the layout will become the
  default layout of the mux for new keyboard attachments.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.14 2008/08/20 16:31:41 miod Exp $	*/
@


1.14
log
@Oops, previous console changes would initialize serial console on lines 0
(e.g. on microVAXes) at 4800 bps as if they were keyboard lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.13 2008/08/18 23:04:28 miod Exp $	*/
d116 1
a116 1
	KB_US,
@


1.13
log
@Shuffle the dz console code (both serial and keyboard) to be more independent
of the console device attachment, and to be able to work on system where there
are more than one dz device of the same type, one of it being the console one.

This also allows a different register layout than the dz@@ibus one to be used
for the dz console device.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.12 2006/08/27 16:50:43 miod Exp $	*/
d199 1
a199 1
	dzcninit_internal(0);
@


1.12
log
@Move cfdriver structs to better places, in preparation for new attachments.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.11 2006/08/05 22:05:55 miod Exp $	*/
d192 1
a192 1
dzkbd_cnattach(struct dz_linestate *ls)
d194 6
d202 1
a202 1
	dzkbd_console_internal.dzi_ks.attmt.cookie = ls;
d204 1
a204 1
	dzkbd_console_internal.dzi_ls = ls;
d225 6
a230 1
	int c;
d233 3
a235 1
		c = dzgetc(dzi->dzi_ls);
@


1.11
log
@Ugly hack to avoid sending the ``all keys up'' event to userland, replacing
it with as many key release events as necessary. Necessary for X until it
knows how to handle this event properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.10 2006/08/03 20:19:29 miod Exp $	*/
a90 4
};

struct	cfdriver lkkbd_cd = {
	NULL, "lkkbd", DV_DULL
@


1.10
log
@LK-401 french layout, tested on actual keyboard (I even have two of them
in the closet, does anyone want them?)
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.9 2006/07/31 21:57:05 miod Exp $	*/
d227 1
a227 1
	} while (!lk201_decode(&dzi->dzi_ks, 1, c, type, data));
d275 1
d281 6
a286 3
	if (lk201_decode(&sc->sc_itl->dzi_ks, sc->sc_enabled, data,
	    &type, &val))
		wskbd_input(sc->sc_wskbddev, type, val);
@


1.9
log
@Since we now know which keyboard type we are connected to:
- report the proper type to WSKBDIO_GTYPE.
- merge the LK201 and LK401 keymaps.
- if the keyboard is LK201, handle the compose key as the left alt key,
  unless shifted, so that you can have both an alt and a compose key.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.8 2006/07/31 06:47:25 miod Exp $	*/
d117 2
a118 2
#ifdef DZKBD_LAYOUT
	DZKBD_LAYOUT,
@


1.8
log
@On startup, and when a keyboard change is detected, probe for the keyboard
type. For now it is only reported to the user, but we'll use this very soon
to alter keycodes depending upon the keyboard type (so that we do not have
the compose and alt keys swapped on LK401 keyboards).
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.7 2006/07/30 18:35:10 miod Exp $	*/
d120 1
a120 1
	KB_US | KB_LK401,
d253 1
a253 1
		*(int *)data = WSKBD_TYPE_LK201;
d259 1
a259 2
		/* XXX don't dig in kbd internals */
		*(int *)data = sc->sc_itl->dzi_ks.leds_state;
@


1.7
log
@Always invoke the lk201 input handler, even when the wskbd device is disabled,
so that the keyboard gets configured correctly if plugged late.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.6 2006/07/29 17:06:25 miod Exp $	*/
d54 1
d178 1
d187 1
a187 4
	/* XXX should identify keyboard ID here XXX */
	/* XXX layout and the number of LED is varying XXX */

	a.console = isconsole;
d205 1
a205 1
		       &dzkbd_keymapdata);
@


1.6
log
@Sync dz and lk{kbd,ms} code with NetBSD, this allows keyboards to work when
initialized by the PROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.5 2006/01/17 20:26:16 miod Exp $	*/
a80 1

a81 1
    
d85 2
a86 4
static int	dzkbd_input(void *, int);

static int	dzkbd_match(struct device *, struct cfdata *, void *);
static void	dzkbd_attach(struct device *, struct device *, void *);
d96 3
a98 3
static int	dzkbd_enable(void *, int);
static void	dzkbd_set_leds(void *, int);
static int	dzkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d106 2
a107 2
static void	dzkbd_cngetc(void *, u_int *, int *);
static void	dzkbd_cnpollc(void *, int);
a113 2
static int dzkbd_sendchar(void *, u_char);

d123 3
d129 1
a129 1
static int
d148 1
a148 1
static void
d197 1
a197 2
dzkbd_cnattach(ls)
	struct dz_linestate *ls;
d211 2
a212 4
static int
dzkbd_enable(v, on)
	void *v;
	int on;
d220 2
a221 19
static int
dzkbd_sendchar(v, c)
	void *v;
	u_char c;
{
	struct dz_linestate *ls = v;
	int s;

	s = spltty();
	dzputc(ls, c);
	splx(s);
	return (0);
}

static void
dzkbd_cngetc(v, type, data)
	void *v;
	u_int *type;
	int *data;
d228 1
a228 1
	} while (!lk201_decode(&dzi->dzi_ks, c, type, data));
d231 2
a232 4
static void
dzkbd_cnpollc(v, on)
	void *v;
        int on;
d239 2
a240 4
static void
dzkbd_set_leds(v, leds)
	void *v;
	int leds;
d247 2
a248 7
static int
dzkbd_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d271 2
a272 4
static int
dzkbd_input(v, data)
	void *v;
	int data;
d278 7
a284 2
	if (sc->sc_enabled == 0)
		return(0);
a285 2
	if (lk201_decode(&sc->sc_itl->dzi_ks, data, &type, &val))
		wskbd_input(sc->sc_wskbddev, type, val);
d289 6
@


1.5
log
@Use angle bracket and no relative paths for all include files which are not
created by config(8); no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.4 2003/06/02 23:27:57 millert Exp $	*/
a82 1
	int kbd_type;
d121 1
a121 1
	zskbd_keydesctab,
d170 1
d172 5
a176 4
		dzi = malloc(sizeof(struct dzkbd_internal),
				       M_DEVBUF, M_NOWAIT);
		if (dzi == NULL)
			panic("dzkbd_attach");
a178 1
		dzi->dzi_ls = ls;
d180 1
a190 4
	dzkbd->kbd_type = WSKBD_TYPE_LK201;

	dzkbd->sc_enabled = 1;

a270 1
//printf("dzkbd_set_leds\n");
d286 1
a286 1
		*(int *)data = sc->kbd_type;
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.3 2002/03/14 01:26:47 millert Exp $	*/
d59 1
a59 1
#include "../dec/wskbdmap_lk201.h"
d63 2
a64 2
#include "../qbus/dzreg.h"
#include "../qbus/dzvar.h"
d66 3
a68 3
#include "../dec/dzkbdvar.h"
#include "../dec/lk201reg.h"
#include "../dec/lk201var.h"
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.2 2002/01/10 00:11:14 nordin Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@Check result from malloc(9) when using M_NOWAIT. hugh@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.1 2001/05/16 22:15:17 hugh Exp $	*/
d92 1
a92 1
static int	dzkbd_input __P((void *, int));
d94 2
a95 2
static int	dzkbd_match __P((struct device *, struct cfdata *, void *));
static void	dzkbd_attach __P((struct device *, struct device *, void *));
d105 3
a107 3
static int	dzkbd_enable __P((void *, int));
static void	dzkbd_set_leds __P((void *, int));
static int	dzkbd_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
d123 1
a123 1
static int dzkbd_sendchar __P((void *, u_char));
@


1.1
log
@Blind merge of wscons support from NetBSD/vax. Perhaps someone with a
supported framebuffer (simple monochrome) can finish this off.
If anyone has run across docs for LCG or SPGFX, please get in touch.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d178 2
@


1.1.2.1
log
@Merge in trunk
@
text
@a177 2
		if (dzi == NULL)
			panic("dzkbd_attach");
@


1.1.2.2
log
@Merge in -current from about a week ago
@
text
@d92 1
a92 1
static int	dzkbd_input(void *, int);
d94 2
a95 2
static int	dzkbd_match(struct device *, struct cfdata *, void *);
static void	dzkbd_attach(struct device *, struct device *, void *);
d105 3
a107 3
static int	dzkbd_enable(void *, int);
static void	dzkbd_set_leds(void *, int);
static int	dzkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d123 1
a123 1
static int dzkbd_sendchar(void *, u_char);
@


1.1.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.1.2.2 2002/03/28 11:26:46 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.2 2002/01/10 00:11:14 nordin Exp $	*/
a177 2
		if (dzi == NULL)
			panic("dzkbd_attach");
@


1.1.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dzkbd.c,v 1.1.6.1 2002/01/31 22:55:26 niklas Exp $	*/
d92 1
a92 1
static int	dzkbd_input(void *, int);
d94 2
a95 2
static int	dzkbd_match(struct device *, struct cfdata *, void *);
static void	dzkbd_attach(struct device *, struct device *, void *);
d105 3
a107 3
static int	dzkbd_enable(void *, int);
static void	dzkbd_set_leds(void *, int);
static int	dzkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d123 1
a123 1
static int dzkbd_sendchar(void *, u_char);
@


