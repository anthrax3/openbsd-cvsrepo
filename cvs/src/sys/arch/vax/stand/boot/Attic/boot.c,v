head	1.27;
access;
symbols
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.10
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.6
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.4
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20;
locks; strict;
comment	@ * @;


1.27
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.26;
commitid	OSDG2O3Cgeifnf1W;

1.26
date	2015.11.16.19.33.52;	author miod;	state Exp;
branches;
next	1.25;
commitid	5gnqUR6VheSiU9SF;

1.25
date	2014.02.19.22.13.53;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.04.10.49.21;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2013.08.15.13.00.48;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2013.07.05.21.13.06;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2011.09.19.21.53.02;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.26.18.36.21;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.10.18.20.07;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.30.19.54.05;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.30.20.02.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.24.20.29.38;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.05.12.24.28;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.12.18.16.13;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.15.23.16.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.11.09.36.23;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.13.02.42.20;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.04.00.21.09;	author miod;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.09.10.04.28.52;	author bjc;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.25.13.46.36;	author hugh;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.25.21.51.39;	author hugh;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.10.04.04.09.01;	author bjc;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.01.00.03.17;	author bjc;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.01.00.12.01;	author bjc;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.02.26.24;	author bjc;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.21.37.44;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.06.07.11.14.46;	author ho;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.39.18;	author art;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: boot.c,v 1.26 2015/11/16 19:33:52 miod Exp $ */
/*	$NetBSD: boot.c,v 1.18 2002/05/31 15:58:26 ragge Exp $ */
/*-
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)boot.c	7.15 (Berkeley) 5/4/91
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#define _KERNEL
#include <sys/fcntl.h>
#undef _KERNEL

#include <lib/libkern/libkern.h>
#include <lib/libsa/stand.h>
#include <lib/libsa/loadfile.h>

#include "machine/rpb.h"
#include "machine/sid.h"

#include "vaxstand.h"

/*
 * Boot program... arguments passed in r10 and r11 determine
 * whether boot stops to ask for system name and which device
 * boot comes from.
 */

char line[100];
int	bootdev, debug;
extern	unsigned opendev;

char   rnddata[BOOTRANDOM_MAX];

void	usage(char *), boot(char *), halt(char *);
void	Xmain(void);
void	autoconf(void);
time_t	getsecs(void);
int	loadrandom(const char *, char *, size_t);
int	setjmp(int *);
int	testkey(void);

const struct vals {
	char	*namn;
	void	(*func)(char *);
	char	*info;
} val[] = {
	{"?", usage, "Show this help menu"},
	{"help", usage, "Same as '?'"},
	{"boot", boot, "Load and execute file"},
	{"halt", halt, "Halts the system"},
	{0, 0},
};

int jbuf[10];
int sluttid, senast, skip, askname;
int mcheck_silent;
struct rpb bootrpb;

void
Xmain(void)
{
	int io;
	int j, nu;
	char transition = '\010';
	u_long marks[MARK_MAX];

	io = 0;
	skip = 1;
	autoconf();

	/*
	 * Some VAXstation 4000 PROMs slowly erase the whole screen with \010
	 * if running with glass console - at least VS4000/60 and VS4000/VLC;
	 * this is probably the LCG PROM at fault. Use a different transition
	 * pattern, it's not as nice but it does not take 3(!) seconds to
	 * display...
	 */
	if (((vax_boardtype == VAX_BTYP_46 &&
	      (vax_siedata & 0xff) == VAX_VTYP_46) ||
	     (vax_boardtype == VAX_BTYP_48 &&
	      vax_cpustype == VAX_STYP_48)) &&
	    (vax_confdata & 0x100) == 0)
		transition = ' ';

	askname = bootrpb.rpb_bootr5 & RB_ASKNAME;
	printf("\n\r>> OpenBSD/vax boot [%s] <<\n", "1.18");
	printf(">> Press enter to autoboot now, or any other key to abort:  ");
	sluttid = getsecs() + 5;
	senast = 0;
	skip = 0;
	setjmp(jbuf);
	for (;;) {
		nu = sluttid - getsecs();
		if (senast != nu)
			printf("%c%d", transition, nu);
		if (nu <= 0)
			break;
		senast = nu;
		if ((j = (testkey() & 0177))) {
			skip = 1;
			if (j != 10 && j != 13) {
				printf("\nPress '?' for help");
				askname = 1;
			}
			break;
		}
	}
	skip = 1;
	printf("\n");

	if (setjmp(jbuf))
		askname = 1;

	/* First try to autoboot */
	if (askname == 0) {
		int err;

		errno = 0;
		printf("> boot bsd\n");
		boot(NULL);
	}

	/* If any key pressed, or autoboot failed, go to conversational boot */
	for (;;) {
		const struct vals *v = &val[0];
		char *c, *d;

		printf("> ");
		getln(line, sizeof line);

		c = line;
		while (*c == ' ')
			c++;

		if (c[0] == 0)
			continue;

		if ((d = strchr(c, ' ')))
			*d++ = 0;

		while (v->namn) {
			if (strcmp(v->namn, c) == 0)
				break;
			v++;
		}
		if (v->namn)
			(*v->func)(d);
		else
			printf("Unknown command: %s\n", c);
	}
}

void
halt(char *hej)
{
	asm("halt");
}

void
boot(char *arg)
{
	char *fn = "bsd";
	int howto, err;
	u_long marks[MARK_MAX];
	static int rnd_loaded = 0;

	if (arg) {
		while (*arg == ' ')
			arg++;

		if (*arg != '-') {
			fn = arg;
			if ((arg = strchr(arg, ' '))) {
				*arg++ = 0;
				while (*arg == ' ')
					arg++;
			} else
				goto load;
		}
		if (*arg != '-') {
fail:			printf("usage: boot [filename] [-acsd]\n");
			return;
		}

		howto = 0;

		while (*++arg) {
			if (*arg == 'a')
				howto |= RB_ASKNAME;
			else if (*arg == 'c')
				howto |= RB_CONFIG;
			else if (*arg == 'd')
				howto |= RB_KDB;
			else if (*arg == 's')
				howto |= RB_SINGLE;
			else
				goto fail;
		}
		bootrpb.rpb_bootr5 = howto;
	}
load:  
	/*
	 * Attempt to load /etc/random.seed if loading from a disk.
	 */
	switch (bootrpb.devtyp) {
	default:
		break;
	case BDEV_UDA:
	case BDEV_RD:
	case BDEV_SD:
	case BDEV_SDN:
	case BDEV_SDS:
		if (rnd_loaded == 0)
			rnd_loaded = loadrandom(BOOTRANDOM, rnddata,
			    sizeof(rnddata));
		break;
	}

	marks[MARK_START] = 0;
	err = loadfile(fn, marks, LOAD_KERNEL|COUNT_KERNEL);
	if (err == 0) {
		machdep_start((char *)marks[MARK_ENTRY],
				      marks[MARK_NSYM],
			      (void *)marks[MARK_START],
			      (void *)marks[MARK_SYM],
			      (void *)marks[MARK_END]);
	}
	printf("%s: boot failed: %s\n", fn, strerror(errno));
}

void
usage(char *hej)
{
	const struct vals *v = &val[0];
	int i;

	printf("Commands:\n");
	while (v->namn) {
		printf("%s ", v->namn);
		for (i = 1 + strlen(v->namn); (i & 7) != 0; i++)
			printf(" ");
		printf("%s\n", v->info);
		v++;
	}
}

int
loadrandom(const char *name, char *buf, size_t buflen)
{
	struct stat sb;
	int fd;
	int rc = 0;

	fd = open(name, O_RDONLY);
	if (fd == -1) {
		if (errno != EPERM)
			printf("cannot open %s: %s\n", name, strerror(errno));
		return 0;
	}
	if (fstat(fd, &sb) == -1 || sb.st_uid != 0 || !S_ISREG(sb.st_mode) ||
	    (sb.st_mode & (S_IWOTH|S_IROTH)))
		goto fail;
	(void) read(fd, buf, buflen);
	rc = 1;
fail:
	close(fd);
	return rc;
}
@


1.26
log
@Replace unbounded gets() in libsa with getln() which takes a buffer size,
and convert all gets() users.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.25 2014/02/19 22:13:53 miod Exp $ */
@


1.25
log
@/etc/random.seed support (only loaded from disk devices).
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.24 2014/01/04 10:49:21 miod Exp $ */
d157 1
a157 1
		gets(line);
@


1.24
log
@Add rnddata[] placeholders to make these boot blocks build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.23 2013/08/15 13:00:48 otto Exp $ */
d36 4
d60 1
a60 1
char   rnddata[BOOTRANDOM_MAX];		/* XXX dummy */
d66 1
d114 1
a114 1
	printf("\n\r>> OpenBSD/vax boot [%s] <<\n", "1.16");
d193 1
d230 17
d273 23
@


1.23
log
@fix getsecs() prototypes, vax still boots with 64-bit time_t; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.22 2013/07/05 21:13:06 miod Exp $ */
d55 2
@


1.22
log
@VAX ELF boot block bits, and version crank.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.21 2011/09/19 21:53:02 miod Exp $ */
d59 1
a59 1
int	getsecs(void);
@


1.21
log
@Try and clean system type constants a bit:
- save the second byte of vax_siedata into a new variable, vax_cpustype,
  and use it instead of (vax_siedata >> 8) & 0xff or other similar
  constructs.
- the VAX_SIE_KAxxx constants are duplicates of the VAX_STYP_xx constants.
  Standardize on the latter and kill the former.
- only keep VAX_VTYP_xx constants for KA46 and KA47, those are the only
  systems which use these constants and are told apart by a different
  SIE byte.

No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.20 2011/07/06 18:32:59 miod Exp $ */
d141 1
a141 11
		marks[MARK_START] = 0;
		err = loadfile("bsd", marks,
		    LOAD_KERNEL|COUNT_KERNEL);
		if (err == 0) {
			machdep_start((char *)marks[MARK_ENTRY],
					      marks[MARK_NSYM],
				      (void *)marks[MARK_START],
				      (void *)marks[MARK_SYM],
				      (void *)marks[MARK_END]);
		}
		printf("bsd: boot failed: %s\n", strerror(errno));
d231 1
a231 1
	printf("Boot failed: %s\n", strerror(errno));
@


1.20
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.19 2008/08/26 18:36:21 miod Exp $ */
d102 1
a102 1
	      ((vax_siedata >> 8) & 0xff) == VAX_STYP_48)) &&
@


1.19
log
@When using the not-documented-but-ought-to 'boot sd(...)file' syntax (e.g.
when mopbooting the bootblocks because one trashed the ones on disk by
accident), be sure to use the proper BDEV_SDx rpb device type value,
depending on the type of onboard controller. Crank version.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.18 2008/08/10 18:20:07 miod Exp $ */
a40 2
#define V750UCODE(x)    ((x>>8)&255)

a61 3
#if 0
void	loadpcs(void);
#endif
d107 1
a107 1
	printf("\n\r>> OpenBSD/vax boot [%s] <<\n", "1.15");
d194 1
a194 1
	int howto, fl, err;
a242 98

#if 0

/* 750 Patchable Control Store magic */

#include "../include/mtpr.h"
#include "../include/cpu.h"
#include "../include/sid.h"
#define	PCS_BITCNT	0x2000		/* number of patchbits */
#define	PCS_MICRONUM	0x400		/* number of ucode locs */
#define	PCS_PATCHADDR	0xf00000	/* start addr of patchbits */
#define	PCS_PCSADDR	(PCS_PATCHADDR+0x8000)	/* start addr of pcs */
#define	PCS_PATCHBIT	(PCS_PATCHADDR+0xc000)	/* patchbits enable reg */
#define	PCS_ENABLE	0xfff00000	/* enable bits for pcs */

#define	extzv(one, two, three,four)	\
({			\
	asm __volatile (" extzv %0,%3,(%1),(%2)+"	\
			:			\
			: "g"(one),"g"(two),"g"(three),"g"(four));	\
})


void
loadpcs(void)
{
	static int pcsdone = 0;
	int mid = mfpr(PR_SID);
	int i, j, *ip, *jp;
	char pcs[100];
	char *cp;

	if ((mid >> 24) != VAX_750 || ((mid >> 8) & 255) < 95 || pcsdone)
		return;
	printf("Updating 11/750 microcode: ");
	for (cp = line; *cp; cp++)
		if (*cp == ')' || *cp == ':')
			break;
	if (*cp) {
		bcopy(line, pcs, 99);
		pcs[99] = 0;
		i = cp - line + 1;
	} else
		i = 0;
	strncpy(pcs + i, "pcs750.bin", sizeof(pcs) - i - 1);
	pcs[sizeof(pcs)-1] = '\0';
	i = open(pcs, 0);
	if (i < 0) {
		printf("bad luck - missing pcs750.bin :-(\n");
		return;
	}
	/*
	 * We ask for more than we need to be sure we get only what we expect.
	 * After read:
	 *	locs 0 - 1023	packed patchbits
	 *	 1024 - 11264	packed microcode
	 */
	if (read(i, (char *)0, 23*512) != 22*512) {
		printf("Error reading %s\n", pcs);
		close(i);
		return;
	}
	close(i);

	/*
	 * Enable patchbit loading and load the bits one at a time.
	 */
	*((int *)PCS_PATCHBIT) = 1;
	ip = (int *)PCS_PATCHADDR;
	jp = (int *)0;
	for (i=0; i < PCS_BITCNT; i++) {
		extzv(i,jp,ip,1);
	}
	*((int *)PCS_PATCHBIT) = 0;

	/*
	 * Load PCS microcode 20 bits at a time.
	 */
	ip = (int *)PCS_PCSADDR;
	jp = (int *)1024;
	for (i=j=0; j < PCS_MICRONUM * 4; i+=20, j++) {
		extzv(i,jp,ip,20);
	}

	/*
	 * Enable PCS.
	 */
	i = *jp;		/* get 1st 20 bits of microcode again */
	i &= 0xfffff;
	i |= PCS_ENABLE;	/* reload these bits with PCS enable set */
	*((int *)PCS_PCSADDR) = i;

	mid = mfpr(PR_SID);
	printf("new rev level=%d\n", V750UCODE(mid));
	pcsdone = 1;
}

#endif
@


1.18
log
@Add support for the VAXstation 3[58][24]0 to the bootblocks, currently
limited to serial console. This is enough for a 3520 to mopboot and download
a kernel over NFS.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.17 2008/03/30 19:54:05 miod Exp $ */
d112 1
a112 1
	printf("\n\r>> OpenBSD/vax boot [%s] <<\n", "1.14");
@


1.17
log
@Switch bootloader code to loadfile, and enable a.out and ELF loaders within.
Crank the second stage boot blocks version.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.16 2006/08/30 20:02:13 miod Exp $ */
d82 1
d112 1
a112 1
	printf("\n\r>> OpenBSD/vax boot [%s] [%s] <<\n", "1.13", __DATE__);
@


1.16
log
@Horrible code to work around stupid VXT2000 rom getchar() behaviour, but
at least this allows our boot blocks to work with glass console on these
machines now.

Caution: reading this code will hurt your eyes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.15 2006/08/24 20:29:38 miod Exp $ */
d36 4
a39 5
#include "lib/libsa/stand.h"
#ifdef notyet
#include "lib/libsa/loadfile.h"
#include "lib/libkern/libkern.h"
#endif
a89 1
#ifdef noyet
a90 1
#endif
d111 1
a111 1
	printf("\n\r>> OpenBSD/vax boot [%s] [%s] <<\n", "1.12", __DATE__);
a140 1
#ifdef notyet
d142 1
a142 1
#endif
a144 2
		exec("bsd", 0, 0);
#ifdef notyet
a154 1
#endif
a198 1
#ifdef notyet
a199 1
#endif
a235 2
	exec(fn, 0, 0);
#ifdef notyet
d240 1
a240 1
				       marks[MARK_NSYM],
d242 2
a243 2
				(void *)marks[MARK_SYM],
				(void *)marks[MARK_END]);
a244 1
#endif
@


1.15
log
@Enable the appropriate serial transmitters in VXT2000 serial routines, this
makes output work when the VXT2000 is not configured for serial console.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.14 2006/08/05 12:24:28 miod Exp $ */
d114 1
a114 1
	printf("\n\r>> OpenBSD/vax boot [%s] [%s] <<\n", "1.11", __DATE__);
@


1.14
log
@A potpourri of unrelated changes:
- remove the 11/750 pcs code, it is never called.
- remove the list of kernels to try to boot in order; it is a good idea only
  if you can interrupt the process, which you can't due to quirks on some
  models, so enter interactive boot immediately if booting /bsd fails.
- work around some PROM bugs in graphics mode which cause \h and \t not
  to behave as expected.

Crank version to 1.10.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 2005/06/12 18:16:13 xsa Exp $ */
d114 1
a114 1
	printf("\n\r>> OpenBSD/vax boot [%s] [%s] <<\n", "1.10", __DATE__);
@


1.13
log
@index() function is deprecated and shouldn't be used in new code,
replace it with strchr(). tested and ok martin@@, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2003/08/15 23:16:30 deraadt Exp $ */
d45 1
d65 1
d67 1
a80 11
static struct {
	char name[12];
	int quiet;
} filelist[] = {
	{ "bsd", 0 },
	{ "bsd.old", 0 },
	{ "bsd.vax", 1 },
	{ "bsd.gz", 0 },
	{ "", 0 },
};

d90 1
a93 1
	extern const char bootprog_rev[], bootprog_date[];
d99 14
d114 1
a114 1
	printf("\n\r>> OpenBSD/vax boot [%s] [%s] <<\n", "1.9", __DATE__);
d123 1
a123 1
			printf("%c%d", 8, nu);
a143 3
		int fileindex;
		for (fileindex = 0; filelist[fileindex].name[0] != '\0';
		    fileindex++) {
d145 1
a145 1
			int err;
d147 3
a149 4
			errno = 0;
			if (!filelist[fileindex].quiet)
				printf("> boot %s\n", filelist[fileindex].name);
			exec(filelist[fileindex].name, 0, 0);
d151 10
a160 17
			marks[MARK_START] = 0;
			err = loadfile(filelist[fileindex].name, marks,
			    LOAD_KERNEL|COUNT_KERNEL);
			if (err == 0) {
				machdep_start((char *)marks[MARK_ENTRY],
						      marks[MARK_NSYM],
					      (void *)marks[MARK_START],
					      (void *)marks[MARK_SYM],
					      (void *)marks[MARK_END]);
			}
#endif
			if (!filelist[fileindex].quiet)
				printf("%s: boot failed: %s\n", 
				    filelist[fileindex].name, strerror(errno));
#if 0 /* Will hang VAX 4000 machines */
			if (testkey())
				break;
d162 1
a162 1
		}
d165 1
a165 1
	/* If any key pressed, go to conversational boot */
d260 2
d356 2
d362 1
d366 4
a369 1
		printf("%s\t%s\n", v->namn, v->info);
@


1.12
log
@ansi and proto cleanup.  one unused function goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 2003/06/02 23:27:57 millert Exp $ */
d185 1
a185 1
		if ((d = index(c, ' ')))
d221 1
a221 1
			if ((arg = index(arg, ' '))) {
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 2002/06/11 09:36:23 hugh Exp $ */
d286 1
a286 1
loadpcs()
@


1.10
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 2002/02/13 02:42:20 deraadt Exp $ */
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@use strncpy instead of strcpy (no strcpy in libsa); hugh ok
@
text
@d1 2
a2 2
/*	$OpenBSD: boot.c,v 1.8 2001/10/04 00:21:09 miod Exp $ */
/*	$NetBSD: boot.c,v 1.4 1999/10/23 14:42:22 ragge Exp $ */
d38 2
a39 3
#include "sys/param.h"
#include "sys/reboot.h"
#include "rpb.h"
d41 4
d48 2
d59 1
a59 1
int	devtype, bootdev, howto, debug;
a60 2
extern  unsigned *bootregs;
struct	rpb *rpb;
d62 7
a68 1
void	usage(), boot(), halt();
d70 1
a70 1
struct vals {
d72 1
a72 1
	void	(*func)();
d82 9
a90 5
char *filer[] = {
	"bsd",
	"bsd.gz",
	"bsd.old",
	0,
d94 2
a95 1
int sluttid, senast, skip;
d97 2
a98 1
Xmain()
d100 1
a100 1
	int io, type, filindex = 0;
d102 4
a105 1
	volatile int askname;
d107 1
a107 7
	/* make sure the rpb is out of the way so it does not get trampled;
	 * this will be the case if booting from net
	 */

	rpb = (struct rpb *)bootregs[11];
	bootdev = rpb->devtyp;
	io=0;
d111 2
a112 2
	askname = howto & RB_ASKNAME;
	printf("\n\r>> OpenBSD/vax boot [%s %s] <<\n", __DATE__, __TIME__);
d137 3
d142 5
a146 10
		type = (devtype >> B_TYPESHIFT) & B_TYPEMASK;
		if ((unsigned)type < ndevs && devsw[type].dv_name)
			while (filer[filindex]) {
				errno = 0;
				printf("> boot %s\n", filer[filindex]);
				exec(filer[filindex++], 0, 0);
				printf("boot failed: %s\n", strerror(errno));
#if 0
				if (testkey())
					break;
d148 14
d163 9
d176 1
a176 1
		struct vals *v = &val[0];
a200 1
			
d205 1
a205 1
halt()
d211 1
a211 2
boot(arg)
	char *arg;
d214 4
d233 1
a233 1
fail:			printf("usage: boot [filename] [-asd]\n");
d237 2
d251 13
d265 1
a265 1
load:	exec(fn, 0, 0);
d283 1
a283 1
	asm __volatile (" extzv %0,%3,%1,(%2)+"	\
d285 1
a285 1
			: "g"(one),"g"(two),"r"(three),"g"(four));	\
d289 1
d364 1
a364 1
usage()
d366 1
a366 1
	struct vals *v = &val[0];
@


1.8
log
@UKC on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.7 2001/09/10 04:28:52 bjc Exp $ */
d259 2
a260 1
	strcpy(pcs + i, "pcs750.bin");
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 2001/10/04 00:21:09 miod Exp $ */
d259 1
a259 2
	strncpy(pcs + i, "pcs750.bin", sizeof(pcs) - i - 1);
	pcs[sizeof(pcs)-1] = '\0';
@


1.8.4.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: boot.c,v 1.18 2002/05/31 15:58:26 ragge Exp $ */
d38 3
a40 2
#include <sys/param.h>
#include <sys/reboot.h>
a41 4
#ifdef notyet
#include "lib/libsa/loadfile.h"
#include "lib/libkern/libkern.h"
#endif
a44 2
#include "machine/rpb.h"

d54 1
a54 1
int	bootdev, debug;
d56 2
d59 1
a59 7
void	usage(char *), boot(char *), halt(char *);
void	Xmain(void);
void	autoconf(void);
int	getsecs(void);
int	setjmp(int *);
int	testkey(void);
void	loadpcs(void);
d61 1
a61 1
const struct vals {
d63 1
a63 1
	void	(*func)(char *);
d73 5
a77 9
static struct {
	char name[12];
	int quiet;
} filelist[] = {
	{ "bsd", 0 },
	{ "bsd.old", 0 },
	{ "bsd.vax", 1 },
	{ "bsd.gz", 0 },
	{ "", 0 },
d81 1
a81 2
int sluttid, senast, skip, askname;
struct rpb bootrpb;
d83 1
a83 2
void
Xmain(void)
d85 1
a85 1
	int io;
d87 5
a91 4
#ifdef noyet
	u_long marks[MARK_MAX];
#endif
	extern const char bootprog_rev[], bootprog_date[];
d93 3
a95 1
	io = 0;
d99 2
a100 2
	askname = bootrpb.rpb_bootr5 & RB_ASKNAME;
	printf("\n\r>> OpenBSD/vax boot [%s] [%s] <<\n", "1.9", __DATE__);
a124 3
	if (setjmp(jbuf))
		askname = 1;

d127 10
a136 5
		int fileindex;
		for (fileindex = 0; filelist[fileindex].name[0] != '\0';
		    fileindex++) {
#ifdef notyet
			int err;
a137 14
			errno = 0;
			if (!filelist[fileindex].quiet)
				printf("> boot %s\n", filelist[fileindex].name);
			exec(filelist[fileindex].name, 0, 0);
#ifdef notyet
			marks[MARK_START] = 0;
			err = loadfile(filelist[fileindex].name, marks,
			    LOAD_KERNEL|COUNT_KERNEL);
			if (err == 0) {
				machdep_start((char *)marks[MARK_ENTRY],
						      marks[MARK_NSYM],
					      (void *)marks[MARK_START],
					      (void *)marks[MARK_SYM],
					      (void *)marks[MARK_END]);
a138 9
#endif
			if (!filelist[fileindex].quiet)
				printf("%s: boot failed: %s\n", 
				    filelist[fileindex].name, strerror(errno));
#if 0 /* Will hang VAX 4000 machines */
			if (testkey())
				break;
#endif
		}
d143 1
a143 1
		const struct vals *v = &val[0];
d168 1
d173 1
a173 1
halt(char *hej)
d179 2
a180 1
boot(char *arg)
a182 4
	int howto, fl, err;
#ifdef notyet
	u_long marks[MARK_MAX];
#endif
d198 1
a198 1
fail:			printf("usage: boot [filename] [-acsd]\n");
a201 2
		howto = 0;

a213 13
		bootrpb.rpb_bootr5 = howto;
	}
load:  
	exec(fn, 0, 0);
#ifdef notyet
	marks[MARK_START] = 0;
	err = loadfile(fn, marks, LOAD_KERNEL|COUNT_KERNEL);
	if (err == 0) {
		machdep_start((char *)marks[MARK_ENTRY],
				       marks[MARK_NSYM],
			      (void *)marks[MARK_START],
				(void *)marks[MARK_SYM],
				(void *)marks[MARK_END]);
d215 1
a215 1
#endif
d233 1
a233 1
	asm __volatile (" extzv %0,%3,(%1),(%2)+"	\
d235 1
a235 1
			: "g"(one),"g"(two),"g"(three),"g"(four));	\
a238 1
void
d313 1
a313 1
usage(char *hej)
d315 1
a315 1
	const struct vals *v = &val[0];
@


1.7
log
@Change askname to volatile; this prevents it from being trashed by
the setjmp/longjmp hack in place for VAX_BTYP_4[689].  This solves
the /boot problem which prevented automatic boots from happening
when the timer ran down.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 2001/08/25 13:46:36 hugh Exp $ */
d205 2
@


1.6
log
@Playing with string.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 2000/11/25 21:51:39 hugh Exp $ */
d85 1
a85 1
	int io, type, askname, filindex = 0;
d87 1
@


1.5
log
@Everyone seems to hit the wrong key first time. Change the abort banner
wording to something unambiguous.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 2000/10/04 04:09:01 bjc Exp $ */
d100 1
a100 1
	printf(">> Press enter to autoboot, or any other key to abort:  ");
@


1.5.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 2000/11/25 21:51:39 hugh Exp $ */
@


1.5.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5.4.1 2001/05/14 21:37:44 niklas Exp $ */
d85 1
a85 1
	int io, type, filindex = 0;
a86 1
	volatile int askname;
d100 1
a100 1
	printf(">> Press enter to autoboot now, or any other key to abort:  ");
a203 2
			else if (*arg == 'c')
				howto |= RB_CONFIG;
@


1.5.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d259 1
a259 2
	strncpy(pcs + i, "pcs750.bin", sizeof(pcs) - i - 1);
	pcs[sizeof(pcs)-1] = '\0';
@


1.5.4.4
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: boot.c,v 1.18 2002/05/31 15:58:26 ragge Exp $ */
d38 3
a40 2
#include <sys/param.h>
#include <sys/reboot.h>
a41 4
#ifdef notyet
#include "lib/libsa/loadfile.h"
#include "lib/libkern/libkern.h"
#endif
a44 2
#include "machine/rpb.h"

d54 1
a54 1
int	bootdev, debug;
d56 2
d59 1
a59 7
void	usage(char *), boot(char *), halt(char *);
void	Xmain(void);
void	autoconf(void);
int	getsecs(void);
int	setjmp(int *);
int	testkey(void);
void	loadpcs(void);
d61 1
a61 1
const struct vals {
d63 1
a63 1
	void	(*func)(char *);
d73 5
a77 9
static struct {
	char name[12];
	int quiet;
} filelist[] = {
	{ "bsd", 0 },
	{ "bsd.old", 0 },
	{ "bsd.vax", 1 },
	{ "bsd.gz", 0 },
	{ "", 0 },
d81 1
a81 2
int sluttid, senast, skip, askname;
struct rpb bootrpb;
d83 1
a83 2
void
Xmain(void)
d85 1
a85 1
	int io;
d87 5
a91 4
#ifdef noyet
	u_long marks[MARK_MAX];
#endif
	extern const char bootprog_rev[], bootprog_date[];
d93 3
a95 1
	io = 0;
d99 2
a100 2
	askname = bootrpb.rpb_bootr5 & RB_ASKNAME;
	printf("\n\r>> OpenBSD/vax boot [%s] [%s] <<\n", "1.9", __DATE__);
a124 3
	if (setjmp(jbuf))
		askname = 1;

d127 10
a136 5
		int fileindex;
		for (fileindex = 0; filelist[fileindex].name[0] != '\0';
		    fileindex++) {
#ifdef notyet
			int err;
a137 14
			errno = 0;
			if (!filelist[fileindex].quiet)
				printf("> boot %s\n", filelist[fileindex].name);
			exec(filelist[fileindex].name, 0, 0);
#ifdef notyet
			marks[MARK_START] = 0;
			err = loadfile(filelist[fileindex].name, marks,
			    LOAD_KERNEL|COUNT_KERNEL);
			if (err == 0) {
				machdep_start((char *)marks[MARK_ENTRY],
						      marks[MARK_NSYM],
					      (void *)marks[MARK_START],
					      (void *)marks[MARK_SYM],
					      (void *)marks[MARK_END]);
a138 9
#endif
			if (!filelist[fileindex].quiet)
				printf("%s: boot failed: %s\n", 
				    filelist[fileindex].name, strerror(errno));
#if 0 /* Will hang VAX 4000 machines */
			if (testkey())
				break;
#endif
		}
d143 1
a143 1
		const struct vals *v = &val[0];
d168 1
d173 1
a173 1
halt(char *hej)
d179 2
a180 1
boot(char *arg)
a182 4
	int howto, fl, err;
#ifdef notyet
	u_long marks[MARK_MAX];
#endif
d198 1
a198 1
fail:			printf("usage: boot [filename] [-acsd]\n");
a201 2
		howto = 0;

a213 13
		bootrpb.rpb_bootr5 = howto;
	}
load:  
	exec(fn, 0, 0);
#ifdef notyet
	marks[MARK_START] = 0;
	err = loadfile(fn, marks, LOAD_KERNEL|COUNT_KERNEL);
	if (err == 0) {
		machdep_start((char *)marks[MARK_ENTRY],
				       marks[MARK_NSYM],
			      (void *)marks[MARK_START],
				(void *)marks[MARK_SYM],
				(void *)marks[MARK_END]);
d215 1
a215 1
#endif
d233 1
a233 1
	asm __volatile (" extzv %0,%3,(%1),(%2)+"	\
d235 1
a235 1
			: "g"(one),"g"(two),"g"(three),"g"(four));	\
a238 1
void
d313 1
a313 1
usage(char *hej)
d315 1
a315 1
	const struct vals *v = &val[0];
@


1.5.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5.4.4 2003/03/27 23:52:19 niklas Exp $ */
d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d286 1
a286 1
loadpcs(void)
@


1.4
log
@eliminate some confusion between rpb and howto -- also make sure that
the "dev()filename" notation is parsed.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.3 2000/06/01 00:03:17 bjc Exp $ */
d100 1
a100 1
	printf(">> Press any key to abort autoboot  ");
@


1.3
log
@gcc might use something like autoincremented registers here, which will
not work, so change the constraint for an argument
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.2 2000/05/01 00:12:01 bjc Exp $ */
d40 1
d57 1
d88 6
d133 1
d136 1
@


1.2
log
@fix countdown for vs4000{/60,/90,VLC} -- from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.1 2000/04/27 02:26:24 bjc Exp $ */
d220 1
a220 1
	asm __volatile (" extzv %0,%3,(%1),(%2)+"	\
d222 1
a222 1
			: "g"(one),"g"(two),"g"(three),"g"(four));	\
@


1.1
log
@sync with netbsd -- this involved rearranging things for sanity reasons
and because separate builds of libsa are done.  this is a pretty nice
bootloader.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 1998/05/11 07:36:26 niklas Exp $ */
d78 3
d83 2
a84 2
	int io, type, sluttid, askname, filindex = 0;
	int j, senast = 0, nu;
d87 1
d94 3
d105 1
d113 1
@

