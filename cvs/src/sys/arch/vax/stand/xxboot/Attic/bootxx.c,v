head	1.14;
access;
symbols
	OPENBSD_5_9:1.13.0.10
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.12
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.8
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.14
date	2016.03.09.16.28.49;	author deraadt;	state dead;
branches;
next	1.13;
commitid	OSDG2O3Cgeifnf1W;

1.13
date	2013.07.05.21.13.07;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.06.18.32.59;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.15.23.16.30;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.11.20.02.06;	author hugh;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.31.18.36.12;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.11.13.10.03;	author hugh;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.11.09.36.24;	author hugh;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.16.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.04.04.16.40;	author bjc;	state Exp;
branches
	1.2.6.1
	1.2.10.1;
next	1.1;

1.1
date	2000.04.27.02.26.27;	author bjc;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.21.37.50;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2003.06.07.11.14.46;	author ho;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	;

1.2.10.1
date	2002.06.11.03.39.18;	author art;	state Exp;
branches;
next	1.2.10.2;

1.2.10.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: bootxx.c,v 1.13 2013/07/05 21:13:07 miod Exp $ */
/* $NetBSD: bootxx.c,v 1.16 2002/03/29 05:45:08 matt Exp $ */

/*-
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)boot.c	7.15 (Berkeley) 5/4/91
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>

#include <lib/libsa/stand.h>
#include <lib/libsa/ufs.h>
#include <lib/libsa/cd9660.h>

#include <machine/pte.h>
#include <machine/sid.h>
#include <machine/mtpr.h>
#include <machine/reg.h>
#include <machine/rpb.h>
#include <arch/vax/vax/gencons.h>

#define NRSP 1 /* Kludge */
#define NCMD 1 /* Kludge */
#define LIBSA_TOO_OLD

#include <arch/vax/mscp/mscp.h>
#include <arch/vax/mscp/mscpreg.h>

#include "../boot/data.h"

#define	RF_PROTECTED_SECTORS	64	/* XXX refer to <.../rf_optnames.h> */

void	Xmain(void);
void	hoppabort(int);
void	romread_uvax(int lbn, int size, void *buf, struct rpb *rpb);
int	unit_init(int, struct rpb *, int);

struct open_file file;

unsigned *bootregs;
struct	rpb *rpb;
struct	bqo *bqo;
int	vax_cputype;
int	vax_load_failure;
struct udadevice {u_short udaip;u_short udasa;};
volatile struct udadevice *csr;
static int moved;

extern int from;
#define	FROMMV	2
#define	FROMVMB	4

/*
 * The boot blocks are used by MicroVAX II/III, VS2000,
 * VS3100, VS4000, and only when booting from disk.
 */
void
Xmain(void)
{
	union {
		struct exec aout;
		Elf32_Ehdr elf;
	} hdr;
	int io;
	u_long entry;

	vax_cputype = (mfpr(PR_SID) >> 24) & 0xFF;
	moved = 0;
	/*
	 */ 
	rpb = (void *)0xf0000; /* Safe address right now */
	bqo = (void *)0xf1000;
        if (from == FROMMV) {
		/*
		 * now relocate rpb/bqo (which are used by ROM-routines)
		 */
		bcopy ((void *)bootregs[11], rpb, sizeof(struct rpb));
		bcopy ((void*)rpb->iovec, bqo, rpb->iovecsz);
#if 0
		if (rpb->devtyp == BDEV_SDN)
			rpb->devtyp = BDEV_SD;	/* XXX until driver fixed */
#endif
	} else {
		bzero(rpb, sizeof(struct rpb));
		rpb->devtyp = bootregs[0];
		rpb->unit = bootregs[3];
		rpb->rpb_bootr5 = bootregs[5];
		rpb->csrphy = bootregs[2];
		rpb->adpphy = bootregs[1];	/* BI node on 8200 */
        }
	rpb->rpb_base = rpb;
	rpb->iovec = (int)bqo;

	io = open("/boot.vax", 0);
	if (io < 0)
		io = open("/boot", 0);
	if (io < 0)
		asm("movl $0xbeef1, %r0; halt");

	read(io, (void *)&hdr.aout, sizeof(hdr.aout));
	if (N_GETMAGIC(hdr.aout) == OMAGIC && N_GETMID(hdr.aout) == MID_VAX) {
		vax_load_failure++;
		entry = hdr.aout.a_entry;
		if (entry < sizeof(hdr.aout))
			entry = sizeof(hdr.aout);
		read(io, (void *) entry, hdr.aout.a_text + hdr.aout.a_data);
		memset((void *) (entry + hdr.aout.a_text + hdr.aout.a_data),
		       0, hdr.aout.a_bss);
	} else if (memcmp(hdr.elf.e_ident, ELFMAG, SELFMAG) == 0) {
		Elf32_Phdr ph;
		size_t off = sizeof(hdr.elf);
		vax_load_failure += 2;
		read(io, (caddr_t)(&hdr.elf) + sizeof(hdr.aout),
		     sizeof(hdr.elf) - sizeof(hdr.aout));
		if (hdr.elf.e_machine != EM_VAX || hdr.elf.e_type != ET_EXEC
		    || hdr.elf.e_phnum != 1)
			goto die;
		vax_load_failure++;
		entry = hdr.elf.e_entry;
		if (hdr.elf.e_phoff != sizeof(hdr.elf)) 
			goto die;
		vax_load_failure++;
		read(io, &ph, sizeof(ph));
		off += sizeof(ph);
		if (ph.p_type != PT_LOAD)
			goto die;
		vax_load_failure++;
		while (off < ph.p_offset) {
			u_int32_t tmp;
			read(io, &tmp, sizeof(tmp));
			off += sizeof(tmp);
		}
		read(io, (void *) ph.p_paddr, ph.p_filesz);
		memset((void *) (ph.p_paddr + ph.p_filesz), 0,
		       ph.p_memsz - ph.p_filesz);
	} else {
		goto die;
	}
	hoppabort(entry);
die:
	asm("movl $0xbeef2, %r0; halt");
}

/*
 * Write an extremely limited version of a (us)tar filesystem, suitable
 * for loading secondary-stage boot loader.
 * - Can only load file "boot".
 * - Must be the first file on tape.
 */
struct fs_ops file_system[] = {
#ifdef NEED_UFS
	{ ufs_open, 0, ufs_read, 0, 0, ufs_stat },
#endif
#ifdef NEED_CD9660
	{ cd9660_open, 0, cd9660_read, 0, 0, cd9660_stat },
#endif
#ifdef NEED_USTARFS
	{ ustarfs_open, 0, ustarfs_read, 0, 0, ustarfs_stat },
#endif
};

int nfsys = (sizeof(file_system) / sizeof(struct fs_ops));

#ifdef LIBSA_TOO_OLD
#include "../boot/vaxstand.h"

struct rom_softc {
       int part;
       int unit;
} rom_softc;

int    romstrategy(void *, int, daddr32_t, size_t, void *, size_t *);
int romopen(struct open_file *, int, int, int, int);
struct devsw   devsw[] = {
       SADEV("rom", romstrategy, romopen, nullsys, noioctl),
};
int    ndevs = (sizeof(devsw)/sizeof(devsw[0]));

int
romopen(struct open_file *f, int adapt, int ctlr, int unit, int part)
{
       rom_softc.unit = unit;
       rom_softc.part = part;
       
       f->f_devdata = (void *)&rom_softc;
       
       return 0;
}

#endif

int
devopen(struct open_file *f, const char *fname, char **file)
{

#ifdef LIBSA_TOO_OLD
	f->f_dev = &devsw[0];
#endif
	*file = (char *)fname;

	/*
	 * Reinit the VMB boot device.
	 */
	if (bqo->unit_init && (moved++ == 0)) {
		int initfn;

		initfn = rpb->iovec + bqo->unit_init;
		if (rpb->devtyp == BDEV_UDA || rpb->devtyp == BDEV_TK) {
			/*
			 * This reset do not seem to be done in the 
			 * ROM routines, so we have to do it manually.
			 */
			csr = (struct udadevice *)rpb->csrphy;
			csr->udaip = 0;
			while ((csr->udasa & MP_STEP1) == 0)
				;
		}
		/*
		 * AP (R12) have a pointer to the VMB argument list,
		 * wanted by bqo->unit_init.
		 */
		unit_init(initfn, rpb, bootregs[12]);
	}
	return 0;
}

extern struct disklabel romlabel;

int
romstrategy(sc, func, dblk, size, buf, rsize)
	void    *sc;
	int     func;
	daddr32_t dblk;
	size_t	size;
	void    *buf;
	size_t	*rsize;
{
	int	block = dblk;
	int     nsize = size;

	if (romlabel.d_magic == DISKMAGIC && romlabel.d_magic2 == DISKMAGIC) {
		if (romlabel.d_npartitions > 1) {
			block += romlabel.d_partitions[0].p_offset;
			if (romlabel.d_partitions[0].p_fstype == FS_RAID) {
				block += RF_PROTECTED_SECTORS;
			}
		}
	}

	romread_uvax(block, size, buf, rpb);

	if (rsize)
		*rsize = nsize;
	return 0;
}

extern char end[];
static char *top = (char*)end;

void *
alloc(unsigned int size)
{
	void *ut = top;
	top += size;
	return ut;
}

void
free(void *ptr, unsigned int size)
{
}

#ifdef USE_PRINTF
void
putchar(int ch)
{
	/*
	 * On KA88 we may get C-S/C-Q from the console.
	 * Must obey it.
	 */
	while (mfpr(PR_RXCS) & GC_DON) {
		if ((mfpr(PR_RXDB) & 0x7f) == 19) {
			while (1) {
				while ((mfpr(PR_RXCS) & GC_DON) == 0)
					;
				if ((mfpr(PR_RXDB) & 0x7f) == 17)
					break;
			}
		}
	}

	while ((mfpr(PR_TXCS) & GC_RDY) == 0)
		;
	mtpr(0, PR_TXCS);
	mtpr(ch & 0377, PR_TXDB);
	if (ch == 10)
		putchar(13);
}
#endif
@


1.13
log
@VAX ELF boot block bits, and version crank.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.12 2011/07/06 18:32:59 miod Exp $ */
@


1.12
log
@Remove support for non-microVAX, non-VAXstation, non-VXT hardware in the
VAX port. This means, 11/7xx, VAX6000 and VAX8x00 systems, as well as SBI,
CMI, BI, XMI and MASSBUS drivers.
Most of these files were not being compiled or kept in compilable state over
the years anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.11 2011/03/13 00:13:53 deraadt Exp $ */
d35 16
a50 16
#include "sys/param.h"
#include "sys/reboot.h"
#include "sys/disklabel.h"
#include "sys/exec.h"
#include "sys/exec_elf.h"

#include "lib/libsa/stand.h"
#include "lib/libsa/ufs.h"
#include "lib/libsa/cd9660.h"

#include "machine/pte.h"
#include "machine/sid.h"
#include "machine/mtpr.h"
#include "machine/reg.h"
#include "machine/rpb.h"
#include "../vax/gencons.h"
d56 2
a57 2
#include "arch/vax/mscp/mscp.h"
#include "arch/vax/mscp/mscpreg.h"
d128 1
a128 1
		asm("movl $0xbeef1, r0; halt");
d171 1
a171 1
	asm("movl $0xbeef2, r0; halt");
@


1.11
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.10 2003/08/15 23:16:30 deraadt Exp $ */
a51 3
#include "../mba/mbareg.h"
#include "../mba/hpreg.h"

a65 2
void	hpread(int block);
int	read750(int block, int *regs);
a79 1
#define	FROM750	1
d84 2
a85 2
 * The boot block are used by 11/750, 8200, MicroVAX II/III, VS2000,
 * VS3100/??, VS4000 and VAX6000/???, and only when booting from disk.
a119 3
		if (rpb->devtyp != BDEV_HP && vax_cputype == VAX_TYP_750)
			rpb->adpphy =
			    (bootregs[1] == 0xffe000 ? 0xf30000 : 0xf32000);
a226 2
	int i;
	struct devsw	*dp;
a230 2
	if (from == FROM750)
		return 0;
d280 1
a280 14
	if (from == FROMMV) {
		romread_uvax(block, size, buf, rpb);
	} else /* if (from == FROM750) */ {
		while (size > 0) {
			if (rpb->devtyp == BDEV_HP)
				hpread(block);
			else
				read750(block, bootregs);
			bcopy(0, buf, 512);
			size -= 512;
			(char *)buf += 512;
			block++;
		}
	}
a284 58
}

/*
 * The 11/750 boot ROM for Massbus disks doesn't seen to have layout info
 * for all RP disks (not RP07 at least) so therefore a very small and dumb
 * device driver is used. It assumes that there is a label on the disk
 * already that has valid layout info. If there is no label, we can't boot
 * anyway.
 */

#define MBA_WCSR(reg, val) \
	((void)(*(volatile u_int32_t *)((adpadr) + (reg)) = (val)));
#define MBA_RCSR(reg) \
	(*(volatile u_int32_t *)((adpadr) + (reg)))
#define HP_WCSR(reg, val) \
	((void)(*(volatile u_int32_t *)((unitadr) + (reg)) = (val)));
#define HP_RCSR(reg) \
	(*(volatile u_int32_t *)((unitadr) + (reg)))

void
hpread(int bn)
{
	int adpadr = bootregs[1];
	int unitadr = adpadr + MUREG(bootregs[3], 0);
	u_int cn, sn, tn;
	struct disklabel *dp;
	extern char start;

	dp = (struct disklabel *)(LABELOFFSET + &start);
	MBA_WCSR(MAPREG(0), PG_V);

	MBA_WCSR(MBA_VAR, 0);
	MBA_WCSR(MBA_BC, (~512) + 1);
#ifdef __GNUC__
	/*
	 * Avoid four subroutine calls by using hardware division.
	 */
	asm("clrl %r1;"
	    "movl %3,%r0;"
	    "ediv %4,%r0,%0,%1;"
	    "movl %1,%r0;"
	    "ediv %5,%r0,%2,%1"
	    : "=g"(cn),"=g"(sn),"=g"(tn)
	    : "g"(bn),"g"(dp->d_secpercyl),"g"(dp->d_nsectors)
	    : "r0","r1","cc");
#else
	cn = bn / dp->d_secpercyl;
	sn = bn % dp->d_secpercyl;
	tn = sn / dp->d_nsectors;
	sn = sn % dp->d_nsectors;
#endif
	HP_WCSR(HP_DC, cn);
	HP_WCSR(HP_DA, (tn << 8) | sn);
	HP_WCSR(HP_CS1, HPCS_READ);

	while (MBA_RCSR(MBA_SR) & MBASR_DTBUSY)
		;
	return;
@


1.10
log
@ansi and proto cleanup.  one unused function goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.9 2003/06/02 23:27:57 millert Exp $ */
d211 1
a211 1
int    romstrategy(void *, int, daddr_t, size_t, void *, size_t *);
d276 1
a276 1
	daddr_t dblk;
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.8 2002/08/11 20:02:06 hugh Exp $ */
d94 1
a94 1
Xmain()
d219 1
a219 3
romopen(f, adapt, ctlr, unit, part)
       struct open_file *f;
       int adapt, ctlr, unit, part;
a230 32
#if 0
int tar_open(char *path, struct open_file *f);
ssize_t tar_read(struct open_file *f, void *buf, size_t size, size_t *resid);

int
tar_open(path, f)
	char *path;
	struct open_file *f;
{
	char *buf = alloc(512);

	bzero(buf, 512);
	romstrategy(0, 0, 8192, 512, buf, 0);
	if (bcmp(buf, "boot", 5) || bcmp(&buf[257], "ustar", 5))
		return EINVAL; /* Not a ustarfs with "boot" first */
	return 0;
}

ssize_t
tar_read(f, buf, size, resid)
	struct open_file *f;
	void *buf;
	size_t size;
	size_t *resid;
{
	romstrategy(0, 0, (8192+512), size, buf, 0);
	*resid = size;
	return 0; /* XXX */
}
#endif


d232 1
a232 4
devopen(f, fname, file)
	struct open_file *f;
	const char    *fname;
	char          **file;
d375 1
a375 2
alloc(size)
        unsigned size;
d383 1
a383 3
free(ptr, size)
        void *ptr;
        unsigned size;
a384 7
}

int
romclose(f)
	struct open_file *f;
{
	return 0;
@


1.8
log
@Restore support for loading elf boot:
  - compiles again
  - already tested
  - less to upgrade later
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.6 2002/06/11 13:10:03 hugh Exp $ */
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@Temporarily comment ELF support in the bootblocks, until this port is
really ELF; necessary for this to compile after the recent <sys/exec_elf.h>
changes. ok deraadt@@
@
text
@a42 1
#ifdef notyet
a43 1
#endif
a101 1
#ifdef notyet
a102 1
#endif
a151 1
#ifdef notyet
a178 1
#endif
@


1.6
log
@Prune some more dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.5 2002/06/11 09:36:24 hugh Exp $ */
d43 1
d45 1
d104 1
d106 1
d156 1
d184 1
@


1.5
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a307 11
#ifdef LIBSA_TOO_OLD_FOO
        /* currently only one dev in devsw; this must change if we add more */
        dp = devsw;
        i = 0;
        if(dp != NULL && dp->dv_open != NULL) {
                i = (*dp->dv_open)(f, B_ADAPTOR(bootdev), B_CONTROLLER(bootdev), 
                                B_UNIT(bootdev), B_PARTITION(bootdev));
        }

        return i;
#else
a308 1
#endif
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 3
a3 2
/* $OpenBSD: bootxx.c,v 1.3 2002/03/14 01:26:47 millert Exp $ */
/* $NetBSD: bootxx.c,v 1.2 1999/10/23 14:40:38 ragge Exp $ */
d42 2
d47 1
d49 6
a54 5
#include "../include/pte.h"
#include "../include/sid.h"
#include "../include/mtpr.h"
#include "../include/reg.h"
#include "../include/rpb.h"
d61 1
d63 2
a64 4
#include "../mscp/mscp.h"
#include "../mscp/mscpreg.h"

#include "vaxstand.h"
d66 1
a66 4
struct rom_softc {
	int part;
	int unit;
} rom_softc;
d68 1
a68 19
int	romstrategy(void *, int, daddr_t, size_t, void *, size_t *);
int romopen(struct open_file *, int, int, int, int);

struct fs_ops	file_system[] = {
	{ ufs_open, ufs_close, ufs_read, ufs_write, ufs_seek, ufs_stat }
};
int	nfsys = (sizeof(file_system) / sizeof(struct fs_ops));

struct devsw	devsw[] = {
	SADEV("rom", romstrategy, romopen, nullsys, noioctl),
};
int	ndevs = (sizeof(devsw)/sizeof(devsw[0]));

int	command(int cmd, int arg);

/*
 * Boot program... argume passed in r10 and r11 determine whether boot
 * stops to ask for system name and which device boot comes from.
 */
d70 6
a75 2
volatile dev_t	devtype, bootdev;
unsigned        opendev, boothowto, bootset, memsz;
d81 1
d83 9
d97 1
d100 4
d105 1
a105 3
	char *scbb;
	char *new, *bqo;
	char *hej = "/boot";
d108 1
a108 1

d111 3
a113 7
	switch (vax_cputype) {
	case VAX_TYP_UV2:
	case VAX_TYP_CVAX:
	case VAX_TYP_RIGEL:
	case VAX_TYP_NVAX:
	case VAX_TYP_MARIAH:
	case VAX_TYP_SOC:
d117 58
a174 45
		rpb = (void *)XXRPB;
		bcopy ((void *)bootregs[11], rpb, 512);
		rpb->rpb_base = rpb;
		bqo = (void *)(512+(int)rpb);
		bcopy ((void *)rpb->iovec, bqo, rpb->iovecsz);
		rpb->iovec = (int)bqo;
		bootregs[11] = (int)rpb;
		bootdev = rpb->devtyp;
		memsz = rpb->pfncnt << 9;
		break;
	case VAX_8200:
        case VAX_750:
		bootdev = bootregs[10];
		memsz = 0;
		break;
	default:
		asm("halt");
	}

	bootset = getbootdev();
	io = open(hej, 0);

	read(io, (void *)0x10000, 0x10000);
	bcopy((void *) 0x10000, 0, 0xffff);
	hoppabort(32, XXRPB, bootset);
	asm("halt");
}

getbootdev()
{
	int i, adaptor, controller, unit, partition, retval;

	adaptor = controller = unit = partition = 0;

	switch (vax_cputype) {
	case VAX_TYP_UV2:
	case VAX_TYP_CVAX:
	case VAX_TYP_MARIAH:
	case VAX_TYP_RIGEL:
		if (rpb->devtyp == BDEV_SD || rpb->devtyp == BDEV_SDN) {
			unit = rpb->unit / 100;
			controller = (rpb->csrphy & 0x100 ? 1 : 0);
		} else {
			controller = ((rpb->csrphy & 017777) == 0xDC)?1:0;
			unit = rpb->unit;			/* DUC, DUD? */
d176 5
a180 33
		break;

	case VAX_TYP_8SS:
	case VAX_TYP_750:
		controller = bootregs[1];
		unit = bootregs[3];
		break;
	}

	switch (B_TYPE(bootdev)) {
	case BDEV_HP:			/* massbuss boot */
		adaptor = (bootregs[1] & 0x6000) >> 17;
		break;

	case BDEV_UDA:		/* UDA50 boot */
		if (vax_cputype == VAX_750)
			adaptor = (bootregs[1] & 0x40000 ? 0 : 1);
		break;

	case BDEV_TK:		/* TK50 boot */
	case BDEV_CNSL:		/* Console storage boot */
	case BDEV_RD:		/* RD/RX on HDC9224 (MV2000) */
	case BDEV_ST:		/* SCSI-tape on NCR5380 (MV2000) */
	case BDEV_SD:		/* SCSI-disk on NCR5380 (3100/76) */
	case BDEV_SDN:		/* SCSI disk on NCR53C94 */	
		break;

	case BDEV_KDB:		/* DSA disk on KDB50 (VAXBI VAXen) */
		bootdev = (bootdev & ~B_TYPEMASK) | BDEV_UDA;
		break;

	default:
		boothowto |= (RB_SINGLE | RB_ASKNAME);
d182 3
a184 1
	return MAKEBOOTDEV(bootdev, adaptor, controller, unit, partition);
d193 45
d264 1
d266 1
a267 10
struct disklabel lp;
int part_off = 0;		/* offset into partition holding /boot */
char io_buf[DEV_BSIZE];
volatile struct uda {
	struct  mscp_1ca uda_ca;           /* communications area */
	struct  mscp uda_rsp;     /* response packets */
	struct  mscp uda_cmd;     /* command packets */
} uda;
struct udadevice {u_short udaip;u_short udasa;};
volatile struct udadevice *csr;
d269 1
d275 3
a277 4
	extern char	start;
	char           *msg;
	int		i, err, off;
	char		line[64];
a278 1

d280 1
d283 2
d286 1
a286 1
	 * On uVAX we need to init [T]MSCP ctlr to be able to use it.
d288 9
a296 4
	if (vax_cputype == VAX_TYP_UV2 || vax_cputype == VAX_TYP_CVAX) {
		switch (bootdev) {
		case BDEV_UDA:	/* MSCP */
		case BDEV_TK:	/* TMSCP */
d298 3
a300 20

			csr->udaip = 0; /* Start init */
			while((csr->udasa & MP_STEP1) == 0);
			csr->udasa = 0x8000;
			while((csr->udasa & MP_STEP2) == 0);
			csr->udasa = (short)(((u_int)&uda)&0xffff) + 8;
			while((csr->udasa & MP_STEP3) == 0);
			csr->udasa = 0x10;
			while((csr->udasa & MP_STEP4) == 0);
			csr->udasa = 0x0001;

			uda.uda_ca.ca_rspdsc =
			    (int) &uda.uda_rsp.mscp_cmdref;
			uda.uda_ca.ca_cmddsc =
			    (int) &uda.uda_cmd.mscp_cmdref;
			if (bootdev == BDEV_TK)
				uda.uda_cmd.mscp_vcid = 1;
			command(M_OP_SETCTLRC, 0);
			uda.uda_cmd.mscp_unit = rpb->unit;
			command(M_OP_ONLINE, 0);
d302 5
d308 8
d317 4
a320 17
	/* 
	 * the disklabel _shall_ be at address LABELOFFSET + RELOC in
	 * phys memory now, no need at all to reread it again.
	 * Actually disklabel is only needed when using hp disks,
	 * but it doesn't hurt to always get it.
	 */
	getdisklabel(LABELOFFSET + &start, &lp);

	/* currently only one dev in devsw; this must change if we add more */
	dp = devsw;
	i = 0;
	if(dp != NULL && dp->dv_open != NULL) {
		i = (*dp->dv_open)(f, B_ADAPTOR(bootdev), B_CONTROLLER(bootdev), 
				B_UNIT(bootdev), B_PARTITION(bootdev));
	}

	return i;
d323 1
a323 17
command(cmd, arg)
{
	volatile int hej;

	uda.uda_cmd.mscp_opcode = cmd;
	uda.uda_cmd.mscp_modifier = arg;

	uda.uda_cmd.mscp_msglen = MSCP_MSGLEN;
	uda.uda_rsp.mscp_msglen = MSCP_MSGLEN;
	uda.uda_ca.ca_rspdsc |= MSCP_OWN|MSCP_INT;
	uda.uda_ca.ca_cmddsc |= MSCP_OWN|MSCP_INT;
	hej = csr->udaip;
	while (uda.uda_ca.ca_rspdsc < 0);

}

int curblock = 0;
d325 1
a333 2
	struct rom_softc *romsc = sc;
	int i;
d337 5
a341 26
	switch (vax_cputype) {
	/*
	 * case VAX_TYP_UV2:
	 * case VAX_TYP_CVAX:
	 * case VAX_TYP_RIGEL:
	 */
	default:
		switch (B_TYPE(bootdev)) {

		case BDEV_UDA: /* MSCP */
			uda.uda_cmd.mscp_seq.seq_lbn = dblk;
			uda.uda_cmd.mscp_seq.seq_bytecount = size;
			uda.uda_cmd.mscp_seq.seq_buffer = (int)buf;
			uda.uda_cmd.mscp_unit = rpb->unit;
			command(M_OP_READ, 0);
			break;

		case BDEV_TK: /* TMSCP */
			if (dblk < curblock) {
				uda.uda_cmd.mscp_seq.seq_bytecount =
				    curblock - dblk;
				command(M_OP_POS, 12);
			} else {
				uda.uda_cmd.mscp_seq.seq_bytecount =
				    dblk - curblock;
				command(M_OP_POS, 4);
d343 2
a344 21
			curblock = size/512 + dblk;
			for (i = 0 ; i < size/512 ; i++) {
				uda.uda_cmd.mscp_seq.seq_lbn = 1;
				uda.uda_cmd.mscp_seq.seq_bytecount = 512;
				uda.uda_cmd.mscp_seq.seq_buffer =
				    (int)buf + i * 512;
				uda.uda_cmd.mscp_unit = rpb->unit;
				command(M_OP_READ, 0);
			}
			break;

		case BDEV_SDN:		/* XXX others too eventually */
		case BDEV_SD:		/* XXX others too eventually */
			if(romsc != NULL) 
				block += lp.d_partitions[romsc->part].p_offset;
		case BDEV_RD:
		case BDEV_ST:

		default:
			romread_uvax(block, size, buf, bootregs);
			break;
d346 12
a358 16
		break;

	case VAX_8200:
	case VAX_750:
		if (bootdev != BDEV_HP) {
			while (size > 0) {
				while ((read750(block, bootregs) & 0x01) == 0){
				}
				bcopy(0, buf, 512);
				size -= 512;
				buf += 512;
				block++;
			}
		} else
			hpread(block, size, buf);
		break;
d366 16
a381 12
int
romopen(f, adapt, ctlr, unit, part)
	struct open_file *f;
	int adapt, ctlr, unit, part;
{
	rom_softc.unit = unit;
	rom_softc.part = part;
	
	f->f_devdata = (void *)&rom_softc;
	
	return 0;
}
d383 2
a384 2
hpread(block, size, buf)
	char           *buf;
d386 24
a409 12
	volatile struct mba_regs *mr = (void *) bootregs[1];
	volatile struct hp_drv *hd = (void *)&mr->mba_md[bootregs[3]];
	struct disklabel *dp = &lp;
	u_int           pfnum, nsize, mapnr, bn, cn, sn, tn;

	pfnum = (u_int) buf >> PGSHIFT;

	for (mapnr = 0, nsize = size; (nsize + NBPG) > 0; nsize -= NBPG)
		*(int *)&mr->mba_map[mapnr++] = PG_V | pfnum++;
	mr->mba_var = ((u_int) buf & PGOFSET);
	mr->mba_bc = (~size) + 1;
	bn = block;
d414 8
a421 8
	hd->hp_dc = cn;
	hd->hp_da = (tn << 8) | sn;
	hd->hp_cs1 = HPCS_READ;
	while (mr->mba_sr & MBASR_DTBUSY);
	if (mr->mba_sr & MBACR_ABORT){
		return 1;
	}
	return 0;
d425 1
a425 1
static char *top = (char *)end;
d449 28
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.2 2000/10/04 04:16:40 bjc Exp $ */
d121 2
a122 2
		rpb = (void*)XXRPB;
		bcopy ((void*)bootregs[11], rpb, 512);
d124 2
a125 2
		bqo = (void*)(512+(int)rpb);
		bcopy ((void*)rpb->iovec, bqo, rpb->iovecsz);
d434 1
a434 1
	volatile struct hp_drv *hd = (void*)&mr->mba_md[bootregs[3]];
d460 1
a460 1
static char *top = (char*)end;
@


1.2
log
@- add a romopen() here (just initializes rom_softc and devdata)
- check for VAX_TYP_MARIAH and BDEV_SDN (53C94 scsi)
- use XXRPB instead of boothowto
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.1 2000/04/27 02:26:27 bjc Exp $ */
d67 2
a68 2
int	romstrategy __P((void *, int, daddr_t, size_t, void *, size_t *));
int romopen __P((struct open_file *, int, int, int, int));
d80 1
a80 1
int	command __P((int cmd, int arg));
@


1.2.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.2 2000/10/04 04:16:40 bjc Exp $ */
d67 2
a68 2
int	romstrategy(void *, int, daddr_t, size_t, void *, size_t *);
int romopen(struct open_file *, int, int, int, int);
d80 1
a80 1
int	command(int cmd, int arg);
d121 2
a122 2
		rpb = (void *)XXRPB;
		bcopy ((void *)bootregs[11], rpb, 512);
d124 2
a125 2
		bqo = (void *)(512+(int)rpb);
		bcopy ((void *)rpb->iovec, bqo, rpb->iovecsz);
d434 1
a434 1
	volatile struct hp_drv *hd = (void *)&mr->mba_md[bootregs[3]];
d460 1
a460 1
static char *top = (char *)end;
@


1.2.10.2
log
@sync to -current
@
text
@d1 2
a2 3
/*	$OpenBSD$ */
/* $NetBSD: bootxx.c,v 1.16 2002/03/29 05:45:08 matt Exp $ */

a40 2
#include "sys/exec.h"
#include "sys/exec_elf.h"
a43 1
#include "lib/libsa/cd9660.h"
d45 5
a49 6
#include "machine/pte.h"
#include "machine/sid.h"
#include "machine/mtpr.h"
#include "machine/reg.h"
#include "machine/rpb.h"
#include "../vax/gencons.h"
a55 1
#define LIBSA_TOO_OLD
d57 4
a60 2
#include "arch/vax/mscp/mscp.h"
#include "arch/vax/mscp/mscpreg.h"
d62 4
a65 1
#include "../boot/data.h"
d67 19
a85 1
#define	RF_PROTECTED_SECTORS	64	/* XXX refer to <.../rf_optnames.h> */
d87 2
a88 6
void	Xmain(void);
void	hoppabort(int);
void	romread_uvax(int lbn, int size, void *buf, struct rpb *rpb);
void	hpread(int block);
int	read750(int block, int *regs);
int	unit_init(int, struct rpb *, int);
a93 1
struct	bqo *bqo;
a94 9
int	vax_load_failure;
struct udadevice {u_short udaip;u_short udasa;};
volatile struct udadevice *csr;
static int moved;

extern int from;
#define	FROM750	1
#define	FROMMV	2
#define	FROMVMB	4
a99 1
void
a101 4
	union {
		struct exec aout;
		Elf32_Ehdr elf;
	} hdr;
d103 3
a105 1
	u_long entry;
d108 1
a108 1
	moved = 0;
d111 7
a117 3
	rpb = (void *)0xf0000; /* Safe address right now */
	bqo = (void *)0xf1000;
        if (from == FROMMV) {
d121 45
a165 58
		bcopy ((void *)bootregs[11], rpb, sizeof(struct rpb));
		bcopy ((void*)rpb->iovec, bqo, rpb->iovecsz);
#if 0
		if (rpb->devtyp == BDEV_SDN)
			rpb->devtyp = BDEV_SD;	/* XXX until driver fixed */
#endif
	} else {
		bzero(rpb, sizeof(struct rpb));
		rpb->devtyp = bootregs[0];
		rpb->unit = bootregs[3];
		rpb->rpb_bootr5 = bootregs[5];
		rpb->csrphy = bootregs[2];
		rpb->adpphy = bootregs[1];	/* BI node on 8200 */
		if (rpb->devtyp != BDEV_HP && vax_cputype == VAX_TYP_750)
			rpb->adpphy =
			    (bootregs[1] == 0xffe000 ? 0xf30000 : 0xf32000);
        }
	rpb->rpb_base = rpb;
	rpb->iovec = (int)bqo;

	io = open("/boot.vax", 0);
	if (io < 0)
		io = open("/boot", 0);
	if (io < 0)
		asm("movl $0xbeef1, r0; halt");

	read(io, (void *)&hdr.aout, sizeof(hdr.aout));
	if (N_GETMAGIC(hdr.aout) == OMAGIC && N_GETMID(hdr.aout) == MID_VAX) {
		vax_load_failure++;
		entry = hdr.aout.a_entry;
		if (entry < sizeof(hdr.aout))
			entry = sizeof(hdr.aout);
		read(io, (void *) entry, hdr.aout.a_text + hdr.aout.a_data);
		memset((void *) (entry + hdr.aout.a_text + hdr.aout.a_data),
		       0, hdr.aout.a_bss);
	} else if (memcmp(hdr.elf.e_ident, ELFMAG, SELFMAG) == 0) {
		Elf32_Phdr ph;
		size_t off = sizeof(hdr.elf);
		vax_load_failure += 2;
		read(io, (caddr_t)(&hdr.elf) + sizeof(hdr.aout),
		     sizeof(hdr.elf) - sizeof(hdr.aout));
		if (hdr.elf.e_machine != EM_VAX || hdr.elf.e_type != ET_EXEC
		    || hdr.elf.e_phnum != 1)
			goto die;
		vax_load_failure++;
		entry = hdr.elf.e_entry;
		if (hdr.elf.e_phoff != sizeof(hdr.elf)) 
			goto die;
		vax_load_failure++;
		read(io, &ph, sizeof(ph));
		off += sizeof(ph);
		if (ph.p_type != PT_LOAD)
			goto die;
		vax_load_failure++;
		while (off < ph.p_offset) {
			u_int32_t tmp;
			read(io, &tmp, sizeof(tmp));
			off += sizeof(tmp);
d167 33
a199 5
		read(io, (void *) ph.p_paddr, ph.p_filesz);
		memset((void *) (ph.p_paddr + ph.p_filesz), 0,
		       ph.p_memsz - ph.p_filesz);
	} else {
		goto die;
d201 1
a201 3
	hoppabort(entry);
die:
	asm("movl $0xbeef2, r0; halt");
a209 45
struct fs_ops file_system[] = {
#ifdef NEED_UFS
	{ ufs_open, 0, ufs_read, 0, 0, ufs_stat },
#endif
#ifdef NEED_CD9660
	{ cd9660_open, 0, cd9660_read, 0, 0, cd9660_stat },
#endif
#ifdef NEED_USTARFS
	{ ustarfs_open, 0, ustarfs_read, 0, 0, ustarfs_stat },
#endif
};

int nfsys = (sizeof(file_system) / sizeof(struct fs_ops));

#ifdef LIBSA_TOO_OLD
#include "../boot/vaxstand.h"

struct rom_softc {
       int part;
       int unit;
} rom_softc;

int    romstrategy(void *, int, daddr_t, size_t, void *, size_t *);
int romopen(struct open_file *, int, int, int, int);
struct devsw   devsw[] = {
       SADEV("rom", romstrategy, romopen, nullsys, noioctl),
};
int    ndevs = (sizeof(devsw)/sizeof(devsw[0]));

int
romopen(f, adapt, ctlr, unit, part)
       struct open_file *f;
       int adapt, ctlr, unit, part;
{
       rom_softc.unit = unit;
       rom_softc.part = part;
       
       f->f_devdata = (void *)&rom_softc;
       
       return 0;
}

#endif

#if 0
a235 1
	return 0; /* XXX */
a236 1
#endif
d238 10
a248 1
int
d254 5
a259 3
#ifdef LIBSA_TOO_OLD
	int i;
	struct devsw	*dp;
a260 1
#endif
a262 2
	if (from == FROM750)
		return 0;
d264 1
a264 1
	 * Reinit the VMB boot device.
d266 5
a270 2
	if (bqo->unit_init && (moved++ == 0)) {
		int initfn;
d272 19
a290 10
		initfn = rpb->iovec + bqo->unit_init;
		if (rpb->devtyp == BDEV_UDA || rpb->devtyp == BDEV_TK) {
			/*
			 * This reset do not seem to be done in the 
			 * ROM routines, so we have to do it manually.
			 */
			csr = (struct udadevice *)rpb->csrphy;
			csr->udaip = 0;
			while ((csr->udasa & MP_STEP1) == 0)
				;
a291 5
		/*
		 * AP (R12) have a pointer to the VMB argument list,
		 * wanted by bqo->unit_init.
		 */
		unit_init(initfn, rpb, bootregs[12]);
d293 34
a326 1
	return 0;
d329 1
a329 1
extern struct disklabel romlabel;
a330 1
int
d339 2
d344 26
a369 5
	if (romlabel.d_magic == DISKMAGIC && romlabel.d_magic2 == DISKMAGIC) {
		if (romlabel.d_npartitions > 1) {
			block += romlabel.d_partitions[0].p_offset;
			if (romlabel.d_partitions[0].p_fstype == FS_RAID) {
				block += RF_PROTECTED_SECTORS;
d371 22
d394 1
a394 1
	}
d396 14
a409 13
	if (from == FROMMV) {
		romread_uvax(block, size, buf, rpb);
	} else /* if (from == FROM750) */ {
		while (size > 0) {
			if (rpb->devtyp == BDEV_HP)
				hpread(block);
			else
				read750(block, bootregs);
			bcopy(0, buf, 512);
			size -= 512;
			(char *)buf += 512;
			block++;
		}
d417 12
a428 16
/*
 * The 11/750 boot ROM for Massbus disks doesn't seen to have layout info
 * for all RP disks (not RP07 at least) so therefore a very small and dumb
 * device driver is used. It assumes that there is a label on the disk
 * already that has valid layout info. If there is no label, we can't boot
 * anyway.
 */

#define MBA_WCSR(reg, val) \
	((void)(*(volatile u_int32_t *)((adpadr) + (reg)) = (val)));
#define MBA_RCSR(reg) \
	(*(volatile u_int32_t *)((adpadr) + (reg)))
#define HP_WCSR(reg, val) \
	((void)(*(volatile u_int32_t *)((unitadr) + (reg)) = (val)));
#define HP_RCSR(reg) \
	(*(volatile u_int32_t *)((unitadr) + (reg)))
d430 2
a431 2
void
hpread(int bn)
d433 12
a444 24
	int adpadr = bootregs[1];
	int unitadr = adpadr + MUREG(bootregs[3], 0);
	u_int cn, sn, tn;
	struct disklabel *dp;
	extern char start;

	dp = (struct disklabel *)(LABELOFFSET + &start);
	MBA_WCSR(MAPREG(0), PG_V);

	MBA_WCSR(MBA_VAR, 0);
	MBA_WCSR(MBA_BC, (~512) + 1);
#ifdef __GNUC__
	/*
	 * Avoid four subroutine calls by using hardware division.
	 */
	asm("clrl %r1;"
	    "movl %3,%r0;"
	    "ediv %4,%r0,%0,%1;"
	    "movl %1,%r0;"
	    "ediv %5,%r0,%2,%1"
	    : "=g"(cn),"=g"(sn),"=g"(tn)
	    : "g"(bn),"g"(dp->d_secpercyl),"g"(dp->d_nsectors)
	    : "r0","r1","cc");
#else
d449 8
a456 8
#endif
	HP_WCSR(HP_DC, cn);
	HP_WCSR(HP_DA, (tn << 8) | sn);
	HP_WCSR(HP_CS1, HPCS_READ);

	while (MBA_RCSR(MBA_SR) & MBASR_DTBUSY)
		;
	return;
d460 1
a460 1
static char *top = (char*)end;
a483 28

#ifdef USE_PRINTF
void
putchar(int ch)
{
	/*
	 * On KA88 we may get C-S/C-Q from the console.
	 * Must obey it.
	 */
	while (mfpr(PR_RXCS) & GC_DON) {
		if ((mfpr(PR_RXDB) & 0x7f) == 19) {
			while (1) {
				while ((mfpr(PR_RXCS) & GC_DON) == 0)
					;
				if ((mfpr(PR_RXDB) & 0x7f) == 17)
					break;
			}
		}
	}

	while ((mfpr(PR_TXCS) & GC_RDY) == 0)
		;
	mtpr(0, PR_TXCS);
	mtpr(ch & 0377, PR_TXDB);
	if (ch == 10)
		putchar(13);
}
#endif
@


1.2.6.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.2 2000/10/04 04:16:40 bjc Exp $ */
@


1.2.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d67 2
a68 2
int	romstrategy(void *, int, daddr_t, size_t, void *, size_t *);
int romopen(struct open_file *, int, int, int, int);
d80 1
a80 1
int	command(int cmd, int arg);
d121 2
a122 2
		rpb = (void *)XXRPB;
		bcopy ((void *)bootregs[11], rpb, 512);
d124 2
a125 2
		bqo = (void *)(512+(int)rpb);
		bcopy ((void *)rpb->iovec, bqo, rpb->iovecsz);
d434 1
a434 1
	volatile struct hp_drv *hd = (void *)&mr->mba_md[bootregs[3]];
d460 1
a460 1
static char *top = (char *)end;
@


1.2.6.3
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 3
/*	$OpenBSD$ */
/* $NetBSD: bootxx.c,v 1.16 2002/03/29 05:45:08 matt Exp $ */

a40 2
#include "sys/exec.h"
#include "sys/exec_elf.h"
a43 1
#include "lib/libsa/cd9660.h"
d45 5
a49 6
#include "machine/pte.h"
#include "machine/sid.h"
#include "machine/mtpr.h"
#include "machine/reg.h"
#include "machine/rpb.h"
#include "../vax/gencons.h"
a55 1
#define LIBSA_TOO_OLD
d57 4
a60 2
#include "arch/vax/mscp/mscp.h"
#include "arch/vax/mscp/mscpreg.h"
d62 4
a65 1
#include "../boot/data.h"
d67 19
a85 1
#define	RF_PROTECTED_SECTORS	64	/* XXX refer to <.../rf_optnames.h> */
d87 2
a88 6
void	Xmain(void);
void	hoppabort(int);
void	romread_uvax(int lbn, int size, void *buf, struct rpb *rpb);
void	hpread(int block);
int	read750(int block, int *regs);
int	unit_init(int, struct rpb *, int);
a93 1
struct	bqo *bqo;
a94 9
int	vax_load_failure;
struct udadevice {u_short udaip;u_short udasa;};
volatile struct udadevice *csr;
static int moved;

extern int from;
#define	FROM750	1
#define	FROMMV	2
#define	FROMVMB	4
a99 1
void
a101 4
	union {
		struct exec aout;
		Elf32_Ehdr elf;
	} hdr;
d103 3
a105 1
	u_long entry;
d108 1
a108 1
	moved = 0;
d111 7
a117 3
	rpb = (void *)0xf0000; /* Safe address right now */
	bqo = (void *)0xf1000;
        if (from == FROMMV) {
d121 45
a165 58
		bcopy ((void *)bootregs[11], rpb, sizeof(struct rpb));
		bcopy ((void*)rpb->iovec, bqo, rpb->iovecsz);
#if 0
		if (rpb->devtyp == BDEV_SDN)
			rpb->devtyp = BDEV_SD;	/* XXX until driver fixed */
#endif
	} else {
		bzero(rpb, sizeof(struct rpb));
		rpb->devtyp = bootregs[0];
		rpb->unit = bootregs[3];
		rpb->rpb_bootr5 = bootregs[5];
		rpb->csrphy = bootregs[2];
		rpb->adpphy = bootregs[1];	/* BI node on 8200 */
		if (rpb->devtyp != BDEV_HP && vax_cputype == VAX_TYP_750)
			rpb->adpphy =
			    (bootregs[1] == 0xffe000 ? 0xf30000 : 0xf32000);
        }
	rpb->rpb_base = rpb;
	rpb->iovec = (int)bqo;

	io = open("/boot.vax", 0);
	if (io < 0)
		io = open("/boot", 0);
	if (io < 0)
		asm("movl $0xbeef1, r0; halt");

	read(io, (void *)&hdr.aout, sizeof(hdr.aout));
	if (N_GETMAGIC(hdr.aout) == OMAGIC && N_GETMID(hdr.aout) == MID_VAX) {
		vax_load_failure++;
		entry = hdr.aout.a_entry;
		if (entry < sizeof(hdr.aout))
			entry = sizeof(hdr.aout);
		read(io, (void *) entry, hdr.aout.a_text + hdr.aout.a_data);
		memset((void *) (entry + hdr.aout.a_text + hdr.aout.a_data),
		       0, hdr.aout.a_bss);
	} else if (memcmp(hdr.elf.e_ident, ELFMAG, SELFMAG) == 0) {
		Elf32_Phdr ph;
		size_t off = sizeof(hdr.elf);
		vax_load_failure += 2;
		read(io, (caddr_t)(&hdr.elf) + sizeof(hdr.aout),
		     sizeof(hdr.elf) - sizeof(hdr.aout));
		if (hdr.elf.e_machine != EM_VAX || hdr.elf.e_type != ET_EXEC
		    || hdr.elf.e_phnum != 1)
			goto die;
		vax_load_failure++;
		entry = hdr.elf.e_entry;
		if (hdr.elf.e_phoff != sizeof(hdr.elf)) 
			goto die;
		vax_load_failure++;
		read(io, &ph, sizeof(ph));
		off += sizeof(ph);
		if (ph.p_type != PT_LOAD)
			goto die;
		vax_load_failure++;
		while (off < ph.p_offset) {
			u_int32_t tmp;
			read(io, &tmp, sizeof(tmp));
			off += sizeof(tmp);
d167 33
a199 5
		read(io, (void *) ph.p_paddr, ph.p_filesz);
		memset((void *) (ph.p_paddr + ph.p_filesz), 0,
		       ph.p_memsz - ph.p_filesz);
	} else {
		goto die;
d201 1
a201 3
	hoppabort(entry);
die:
	asm("movl $0xbeef2, r0; halt");
a209 45
struct fs_ops file_system[] = {
#ifdef NEED_UFS
	{ ufs_open, 0, ufs_read, 0, 0, ufs_stat },
#endif
#ifdef NEED_CD9660
	{ cd9660_open, 0, cd9660_read, 0, 0, cd9660_stat },
#endif
#ifdef NEED_USTARFS
	{ ustarfs_open, 0, ustarfs_read, 0, 0, ustarfs_stat },
#endif
};

int nfsys = (sizeof(file_system) / sizeof(struct fs_ops));

#ifdef LIBSA_TOO_OLD
#include "../boot/vaxstand.h"

struct rom_softc {
       int part;
       int unit;
} rom_softc;

int    romstrategy(void *, int, daddr_t, size_t, void *, size_t *);
int romopen(struct open_file *, int, int, int, int);
struct devsw   devsw[] = {
       SADEV("rom", romstrategy, romopen, nullsys, noioctl),
};
int    ndevs = (sizeof(devsw)/sizeof(devsw[0]));

int
romopen(f, adapt, ctlr, unit, part)
       struct open_file *f;
       int adapt, ctlr, unit, part;
{
       rom_softc.unit = unit;
       rom_softc.part = part;
       
       f->f_devdata = (void *)&rom_softc;
       
       return 0;
}

#endif

#if 0
a235 1
	return 0; /* XXX */
a236 1
#endif
d238 10
a248 1
int
d254 5
a259 3
#ifdef LIBSA_TOO_OLD
	int i;
	struct devsw	*dp;
a260 1
#endif
a262 2
	if (from == FROM750)
		return 0;
d264 1
a264 1
	 * Reinit the VMB boot device.
d266 5
a270 2
	if (bqo->unit_init && (moved++ == 0)) {
		int initfn;
d272 19
a290 10
		initfn = rpb->iovec + bqo->unit_init;
		if (rpb->devtyp == BDEV_UDA || rpb->devtyp == BDEV_TK) {
			/*
			 * This reset do not seem to be done in the 
			 * ROM routines, so we have to do it manually.
			 */
			csr = (struct udadevice *)rpb->csrphy;
			csr->udaip = 0;
			while ((csr->udasa & MP_STEP1) == 0)
				;
a291 5
		/*
		 * AP (R12) have a pointer to the VMB argument list,
		 * wanted by bqo->unit_init.
		 */
		unit_init(initfn, rpb, bootregs[12]);
d293 34
a326 1
	return 0;
d329 1
a329 1
extern struct disklabel romlabel;
a330 1
int
d339 2
d344 26
a369 5
	if (romlabel.d_magic == DISKMAGIC && romlabel.d_magic2 == DISKMAGIC) {
		if (romlabel.d_npartitions > 1) {
			block += romlabel.d_partitions[0].p_offset;
			if (romlabel.d_partitions[0].p_fstype == FS_RAID) {
				block += RF_PROTECTED_SECTORS;
d371 22
d394 1
a394 1
	}
d396 14
a409 13
	if (from == FROMMV) {
		romread_uvax(block, size, buf, rpb);
	} else /* if (from == FROM750) */ {
		while (size > 0) {
			if (rpb->devtyp == BDEV_HP)
				hpread(block);
			else
				read750(block, bootregs);
			bcopy(0, buf, 512);
			size -= 512;
			(char *)buf += 512;
			block++;
		}
d417 12
a428 16
/*
 * The 11/750 boot ROM for Massbus disks doesn't seen to have layout info
 * for all RP disks (not RP07 at least) so therefore a very small and dumb
 * device driver is used. It assumes that there is a label on the disk
 * already that has valid layout info. If there is no label, we can't boot
 * anyway.
 */

#define MBA_WCSR(reg, val) \
	((void)(*(volatile u_int32_t *)((adpadr) + (reg)) = (val)));
#define MBA_RCSR(reg) \
	(*(volatile u_int32_t *)((adpadr) + (reg)))
#define HP_WCSR(reg, val) \
	((void)(*(volatile u_int32_t *)((unitadr) + (reg)) = (val)));
#define HP_RCSR(reg) \
	(*(volatile u_int32_t *)((unitadr) + (reg)))
d430 2
a431 2
void
hpread(int bn)
d433 12
a444 24
	int adpadr = bootregs[1];
	int unitadr = adpadr + MUREG(bootregs[3], 0);
	u_int cn, sn, tn;
	struct disklabel *dp;
	extern char start;

	dp = (struct disklabel *)(LABELOFFSET + &start);
	MBA_WCSR(MAPREG(0), PG_V);

	MBA_WCSR(MBA_VAR, 0);
	MBA_WCSR(MBA_BC, (~512) + 1);
#ifdef __GNUC__
	/*
	 * Avoid four subroutine calls by using hardware division.
	 */
	asm("clrl %r1;"
	    "movl %3,%r0;"
	    "ediv %4,%r0,%0,%1;"
	    "movl %1,%r0;"
	    "ediv %5,%r0,%2,%1"
	    : "=g"(cn),"=g"(sn),"=g"(tn)
	    : "g"(bn),"g"(dp->d_secpercyl),"g"(dp->d_nsectors)
	    : "r0","r1","cc");
#else
d449 8
a456 8
#endif
	HP_WCSR(HP_DC, cn);
	HP_WCSR(HP_DA, (tn << 8) | sn);
	HP_WCSR(HP_CS1, HPCS_READ);

	while (MBA_RCSR(MBA_SR) & MBASR_DTBUSY)
		;
	return;
d460 1
a460 1
static char *top = (char*)end;
a483 28

#ifdef USE_PRINTF
void
putchar(int ch)
{
	/*
	 * On KA88 we may get C-S/C-Q from the console.
	 * Must obey it.
	 */
	while (mfpr(PR_RXCS) & GC_DON) {
		if ((mfpr(PR_RXDB) & 0x7f) == 19) {
			while (1) {
				while ((mfpr(PR_RXCS) & GC_DON) == 0)
					;
				if ((mfpr(PR_RXDB) & 0x7f) == 17)
					break;
			}
		}
	}

	while ((mfpr(PR_TXCS) & GC_RDY) == 0)
		;
	mtpr(0, PR_TXCS);
	mtpr(ch & 0377, PR_TXDB);
	if (ch == 10)
		putchar(13);
}
#endif
@


1.2.6.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bootxx.c,v 1.2.6.3 2003/03/27 23:52:19 niklas Exp $ */
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.6.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d94 1
a94 1
Xmain(void)
d219 3
a221 1
romopen(struct open_file *f, int adapt, int ctlr, int unit, int part)
d233 32
d266 4
a269 1
devopen(struct open_file *f, const char *fname, char **file)
d412 2
a413 1
alloc(unsigned int size)
d421 3
a423 1
free(void *ptr, unsigned int size)
d425 7
@


1.1
log
@sync with netbsd -- this involved rearranging things for sanity reasons
and because separate builds of libsa are done.  this is a pretty nice
bootloader.
@
text
@d1 1
a1 1
/* $OpenBSD: bootxx.c,v 1.8 1998/05/13 07:30:21 niklas Exp $ */
d62 4
d68 1
d73 1
d76 1
a76 1
	SADEV("rom", romstrategy, nullsys, nullsys, noioctl),
d78 1
a78 2

int	nfsys = (sizeof(file_system) / sizeof(struct fs_ops));
d116 1
a140 1

d145 1
a145 1
	hoppabort(32, boothowto, bootset);
d158 1
d160 1
a160 1
		if (rpb->devtyp == BDEV_SD) {
d191 1
d258 1
d301 10
a310 1
	return 0;
d339 1
d351 1
a351 1
		switch (bootdev) {
d381 5
a387 1
		case BDEV_SD:
d414 13
@

