head	1.36;
access;
symbols
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.8
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.6
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.4
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.12
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.10
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.8
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.4
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.35;
commitid	OSDG2O3Cgeifnf1W;

1.35
date	2016.01.25.00.18.55;	author dlg;	state Exp;
branches;
next	1.34;
commitid	EgODt4ORIyjjhVEB;

1.34
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.33;
commitid	B0kwmVGiD5DVx4kv;

1.33
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.32;
commitid	5gdEnqVoJuTuwdTu;

1.32
date	2015.11.14.17.26.40;	author mpi;	state Exp;
branches;
next	1.31;
commitid	BU9j1tIQLqhcXEX9;

1.31
date	2015.11.07.12.01.22;	author dlg;	state Exp;
branches;
next	1.30;
commitid	NaeT3Ab7HVmaKESE;

1.30
date	2015.10.27.15.20.13;	author mpi;	state Exp;
branches;
next	1.29;
commitid	iTpqmkP6HKjkg92B;

1.29
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.28;
commitid	MVWrtktB46JRxFWT;

1.28
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.27;
commitid	hN5bFCE56DrAjl99;

1.27
date	2015.05.02.14.33.19;	author jsg;	state Exp;
branches;
next	1.26;
commitid	KFUSxRkAiP0GdiBd;

1.26
date	2015.03.28.11.24.25;	author mpi;	state Exp;
branches;
next	1.25;
commitid	JZ9BWa3j0lZYQyAh;

1.25
date	2014.12.22.02.26.54;	author tedu;	state Exp;
branches;
next	1.24;
commitid	2Ez9mHW0jDzojG4V;

1.24
date	2014.08.14.17.49.50;	author miod;	state Exp;
branches;
next	1.23;
commitid	tqSANB7Y1VK5xH2R;

1.23
date	2014.08.06.15.40.40;	author jsg;	state Exp;
branches;
next	1.22;
commitid	CyMTRXwZURUEjr2F;

1.22
date	2014.06.13.21.06.24;	author miod;	state Exp;
branches;
next	1.21;
commitid	QQvA4907g3G84mpd;

1.21
date	2013.11.27.08.56.31;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2011.09.26.21.44.04;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.09.00.17.54;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.22.17.09.06;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.31.22.10.57;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.30.19.28.11;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.27.16.50.44;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.24.20.45.26;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.16.00.46.32;	author pascoe;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.24.04.49.25;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.07.23.10.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.25.13.33.36;	author hugh;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.02.20.19.39.35;	author mickey;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.04.27.03.14.44;	author bjc;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.21.37.56;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.05.13.19.41.10;	author ho;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.05.19.21.46.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: sgec.c,v 1.35 2016/01/25 00:18:55 dlg Exp $	*/
/*      $NetBSD: sgec.c,v 1.5 2000/06/04 02:14:14 matt Exp $ */
/*
 * Copyright (c) 1999 Ludd, University of Lule}, Sweden. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed at Ludd, University of 
 *      Lule}, Sweden and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the SGEC (Second Generation Ethernet Controller), sitting
 * on for example the VAX 4000/300 (KA670). 
 *
 * The SGEC looks like a mixture of the DEQNA and the TULIP. Fun toy.
 *
 * Even though the chip is capable to use virtual addresses (read the
 * System Page Table directly) this driver doesn't do so, and there
 * is no benefit in doing it either in NetBSD of today.
 *
 * Things that is still to do:
 *	Collect statistics.
 *	Use imperfect filtering when many multicast addresses.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/sockio.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <vax/if/sgecreg.h>
#include <vax/if/sgecvar.h>

void	sgec_rxintr(struct ze_softc *);
void	sgec_txintr(struct ze_softc *);
void	zeinit(struct ze_softc *);
int	zeioctl(struct ifnet *, u_long, caddr_t);
int	ze_ifmedia_change(struct ifnet *const);
void	ze_ifmedia_status(struct ifnet *const, struct ifmediareq *);
void	zekick(struct ze_softc *);
int	zereset(struct ze_softc *);
void	zestart(struct ifnet *);
void	zetimeout(struct ifnet *);
int	ze_add_rxbuf(struct ze_softc *, int);
void	ze_setup(struct ze_softc *);

struct	cfdriver ze_cd = {
	NULL, "ze", DV_IFNET
};

#define	ZE_WCSR(csr, val) \
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, csr, val)
#define	ZE_RCSR(csr) \
	bus_space_read_4(sc->sc_iot, sc->sc_ioh, csr)

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
void
sgec_attach(sc)
	struct ze_softc *sc;
{
	struct	ifnet *ifp = (struct ifnet *)&sc->sc_if;
	struct	ze_tdes *tp;
	struct	ze_rdes *rp;
	bus_dma_segment_t seg;
	int i, s, rseg, error;

        /*
         * Allocate DMA safe memory for descriptors and setup memory.
         */
	if ((error = bus_dmamem_alloc(sc->sc_dmat,
	    sizeof(struct ze_cdata), NBPG, 0, &seg, 1, &rseg,
	    BUS_DMA_NOWAIT)) != 0) {
		printf(": unable to allocate control data, error = %d\n",
		    error);
		goto fail_0;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
	    sizeof(struct ze_cdata), (caddr_t *)&sc->sc_zedata,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf(": unable to map control data, error = %d\n", error);
		goto fail_1;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat,
	    sizeof(struct ze_cdata), 1,
	    sizeof(struct ze_cdata), 0, BUS_DMA_NOWAIT,
	    &sc->sc_cmap)) != 0) {
		printf(": unable to create control data DMA map, error = %d\n",
		    error);
		goto fail_2;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_cmap,
	    sc->sc_zedata, sizeof(struct ze_cdata), NULL,
	    BUS_DMA_NOWAIT)) != 0) {
		printf(": unable to load control data DMA map, error = %d\n",
		    error);
		goto fail_3;
	}

	/*
	 * Zero the newly allocated memory.
	 */
	bzero(sc->sc_zedata, sizeof(struct ze_cdata));
	/*
	 * Create the transmit descriptor DMA maps.
	 */
	for (i = 0; i < TXDESCS; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    1, MCLBYTES, 0, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW,
		    &sc->sc_xmtmap[i]))) {
			printf(": unable to create tx DMA map %d, error = %d\n",
			    i, error);
			goto fail_4;
		}
	}

	/*
	 * Create receive buffer DMA maps.
	 */
	for (i = 0; i < RXDESCS; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->sc_rcvmap[i]))) {
			printf(": unable to create rx DMA map %d, error = %d\n",
			    i, error);
			goto fail_5;
		}
	}
	/*
	 * Pre-allocate the receive buffers.
	 */
	s = splnet();
	for (i = 0; i < RXDESCS; i++) {
		if ((error = ze_add_rxbuf(sc, i)) != 0) {
			printf(": unable to allocate or map rx buffer %d\n,"
			    " error = %d\n", i, error);
			goto fail_6;
		}
	}
	splx(s);

	/*
	 * Create ring loops of the buffer chains.
	 * This is only done once.
	 */
	sc->sc_pzedata = (struct ze_cdata *)sc->sc_cmap->dm_segs[0].ds_addr;

	rp = sc->sc_zedata->zc_recv;
	rp[RXDESCS].ze_framelen = ZE_FRAMELEN_OW;
	rp[RXDESCS].ze_rdes1 = ZE_RDES1_CA;
	rp[RXDESCS].ze_bufaddr = (char *)sc->sc_pzedata->zc_recv;

	tp = sc->sc_zedata->zc_xmit;
	tp[TXDESCS].ze_tdr = ZE_TDR_OW;
	tp[TXDESCS].ze_tdes1 = ZE_TDES1_CA;
	tp[TXDESCS].ze_bufaddr = (char *)sc->sc_pzedata->zc_xmit;

	if (zereset(sc))
		return;

	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = zestart;
	ifp->if_ioctl = zeioctl;
	ifp->if_watchdog = zetimeout;

	/*
	 * Attach the interface.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	printf(": address %s\n", ether_sprintf(sc->sc_ac.ac_enaddr));

	ifmedia_init(&sc->sc_ifmedia, 0, ze_ifmedia_change,
	    ze_ifmedia_status);
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER | IFM_10_5, 0, 0);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER | IFM_10_5);
	/* supposedly connected, and the first Tx attempt will let us know */
	sc->sc_flags |= SGECF_LINKUP;
	return;

	/*
	 * Free any resources we've allocated during the failed attach
	 * attempt.  Do this in reverse order and fall through.
	 */
 fail_6:
	for (i = 0; i < RXDESCS; i++) {
		if (sc->sc_rxmbuf[i] != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->sc_rcvmap[i]);
			m_freem(sc->sc_rxmbuf[i]);
		}
	}
 fail_5:
	for (i = 0; i < RXDESCS; i++) {
		if (sc->sc_rcvmap[i] != NULL)
			bus_dmamap_destroy(sc->sc_dmat, sc->sc_rcvmap[i]);
	}
 fail_4:
	for (i = 0; i < TXDESCS; i++) {
		if (sc->sc_xmtmap[i] != NULL)
			bus_dmamap_destroy(sc->sc_dmat, sc->sc_xmtmap[i]);
	}
	bus_dmamap_unload(sc->sc_dmat, sc->sc_cmap);
 fail_3:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_cmap);
 fail_2:
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_zedata,
	    sizeof(struct ze_cdata));
 fail_1:
	bus_dmamem_free(sc->sc_dmat, &seg, rseg);
 fail_0:
	return;
}

int
ze_ifmedia_change(struct ifnet *const ifp)
{
	return (0);
}

void
ze_ifmedia_status(struct ifnet *const ifp, struct ifmediareq *req)
{
	struct ze_softc *sc = ifp->if_softc;

	req->ifm_status = IFM_AVALID;
	if (sc->sc_flags & SGECF_LINKUP)
		req->ifm_status |= IFM_ACTIVE;
	req->ifm_active = IFM_10_5 | IFM_ETHER;
}

/*
 * Initialization of interface.
 */
void
zeinit(sc)
	struct ze_softc *sc;
{
	struct ifnet *ifp = (struct ifnet *)&sc->sc_if;
	struct ze_cdata *zc = sc->sc_zedata;
	int i;

	/*
	 * Reset the interface.
	 */
	if (zereset(sc))
		return;

	sc->sc_nexttx = sc->sc_inq = sc->sc_lastack = 0;
	/*
	 * Release and init transmit descriptors.
	 */
	for (i = 0; i < TXDESCS; i++) {
		if (sc->sc_txmbuf[i]) {
			bus_dmamap_unload(sc->sc_dmat, sc->sc_xmtmap[i]);
			m_freem(sc->sc_txmbuf[i]);
			sc->sc_txmbuf[i] = 0;
		}
		zc->zc_xmit[i].ze_tdr = 0; /* Clear valid bit */
	}


	/*
	 * Init receive descriptors.
	 */
	for (i = 0; i < RXDESCS; i++)
		zc->zc_recv[i].ze_framelen = ZE_FRAMELEN_OW;
	sc->sc_nextrx = 0;

	ZE_WCSR(ZE_CSR6, ZE_NICSR6_IE | ZE_NICSR6_BL_8 | ZE_NICSR6_ST |
	    ZE_NICSR6_SR | ZE_NICSR6_DC);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/*
	 * Send a setup frame.
	 * This will start the transmit machinery as well.
	 */
	ze_setup(sc);

}

/*
 * Kick off the transmit logic, if it is stopped.
 * On the VXT2000 we need to always reprogram CSR4,
 * so stop it unconditionnaly.
 */
void
zekick(struct ze_softc *sc)
{
	u_int csr5;

	csr5 = ZE_RCSR(ZE_CSR5);
	if (ISSET(sc->sc_flags, SGECF_VXTQUIRKS)) {
		if ((csr5 & ZE_NICSR5_TS) == ZE_NICSR5_TS_RUN) {
			ZE_WCSR(ZE_CSR6, ZE_RCSR(ZE_CSR6) & ~ZE_NICSR6_ST);
			while ((ZE_RCSR(ZE_CSR5) & ZE_NICSR5_TS) !=
			    ZE_NICSR5_TS_STOP)
				DELAY(10);
		}
		ZE_WCSR(ZE_CSR4,
		    (vaddr_t)&sc->sc_pzedata->zc_xmit[sc->sc_nexttx]);
		ZE_WCSR(ZE_CSR1, ZE_NICSR1_TXPD);
		if ((csr5 & ZE_NICSR5_TS) == ZE_NICSR5_TS_RUN) {
			ZE_WCSR(ZE_CSR6, ZE_RCSR(ZE_CSR6) | ZE_NICSR6_ST);
			while ((ZE_RCSR(ZE_CSR5) & ZE_NICSR5_TS) ==
			    ZE_NICSR5_TS_STOP)
				DELAY(10);
		}
	} else {
		if ((csr5 & ZE_NICSR5_TS) != ZE_NICSR5_TS_RUN)
			ZE_WCSR(ZE_CSR1, ZE_NICSR1_TXPD);
	}
}

/*
 * Start output on interface.
 */
void
zestart(ifp)
	struct ifnet *ifp;
{
	struct ze_softc *sc = ifp->if_softc;
	struct ze_cdata *zc = sc->sc_zedata;
	paddr_t	buffer;
	struct mbuf *m, *m0;
	int idx, len, s, i, totlen, error;
	int old_inq = sc->sc_inq;
	short orword;

	s = splnet();
	while (sc->sc_inq < (TXDESCS - 1)) {
		if (ISSET(sc->sc_flags, SGECF_SETUP)) {
			ze_setup(sc);
			continue;
		}
		idx = sc->sc_nexttx;
		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL)
			goto out;
		/*
		 * Count number of mbufs in chain.
		 * Always do DMA directly from mbufs, therefore the transmit
		 * ring is really big.
		 */
		for (m0 = m, i = 0; m0; m0 = m0->m_next)
			if (m0->m_len)
				i++;
		if (i >= TXDESCS)
			panic("zestart"); /* XXX */

		if ((i + sc->sc_inq) >= (TXDESCS - 1)) {
			ifq_set_oactive(&ifp->if_snd);
			ifq_deq_rollback(&ifp->if_snd, m);
			goto out;
		}
		ifq_deq_commit(&ifp->if_snd, m);
		
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		/*
		 * m now points to a mbuf chain that can be loaded.
		 * Loop around and set it.
		 */
		totlen = 0;
		orword = ZE_TDES1_FS;
		for (m0 = m; m0; m0 = m0->m_next) {
			error = bus_dmamap_load(sc->sc_dmat, sc->sc_xmtmap[idx],
			    mtod(m0, void *), m0->m_len, 0, 0);
			buffer = sc->sc_xmtmap[idx]->dm_segs[0].ds_addr;
			len = m0->m_len;
			if (len == 0)
				continue;

			totlen += len;
			/* Word alignment calc */
			if (totlen == m->m_pkthdr.len) {
				if (totlen < ETHER_ADDR_LEN)
					len += (ETHER_ADDR_LEN - totlen);
				orword |= ZE_TDES1_LS;
				sc->sc_txmbuf[idx] = m;
			}
			zc->zc_xmit[idx].ze_bufsize = len;
			zc->zc_xmit[idx].ze_bufaddr = (char *)buffer;
			zc->zc_xmit[idx].ze_tdes1 = orword | ZE_TDES1_IC;
			zc->zc_xmit[idx].ze_tdr = ZE_TDR_OW;

			if (++idx == TXDESCS)
				idx = 0;
			sc->sc_inq++;
			orword = 0;
		}
#ifdef DIAGNOSTIC
		if (totlen != m->m_pkthdr.len)
			panic("zestart: len fault");
#endif

		/*
		 * Kick off the transmit logic, if it is stopped.
		 */
		zekick(sc);
		sc->sc_nexttx = idx;
	}
	if (sc->sc_inq == (TXDESCS - 1))
		ifq_set_oactive(&ifp->if_snd);

out:	if (old_inq < sc->sc_inq)
		ifp->if_timer = 5; /* If transmit logic dies */
	splx(s);
}

void
sgec_rxintr(struct ze_softc *sc)
{
	struct ze_cdata *zc = sc->sc_zedata;
	struct ifnet *ifp = &sc->sc_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	u_short rdes0;
	int len;

	while ((zc->zc_recv[sc->sc_nextrx].ze_framelen &
	    ZE_FRAMELEN_OW) == 0) {
		rdes0 = zc->zc_recv[sc->sc_nextrx].ze_rdes0;
		if (rdes0 & ZE_RDES0_ES) {
			rdes0 &= ~ZE_RDES0_TL;	/* not really an error */
			if ((rdes0 & (ZE_RDES0_OF | ZE_RDES0_CE | ZE_RDES0_CS |
			    ZE_RDES0_LE | ZE_RDES0_RF)) == 0)
				rdes0 &= ~ZE_RDES0_ES;
		}
		if (rdes0 & ZE_RDES0_ES) {
			ifp->if_ierrors++;
			if (rdes0 & ZE_RDES0_CS)
				ifp->if_collisions++;
			m = NULL;
		} else {
			m = sc->sc_rxmbuf[sc->sc_nextrx];
			len = zc->zc_recv[sc->sc_nextrx].ze_framelen;
		}
		ze_add_rxbuf(sc, sc->sc_nextrx);
		if (m != NULL) {
			m->m_pkthdr.len = m->m_len = len;
			ml_enqueue(&ml, m);
		}
		if (++sc->sc_nextrx == RXDESCS)
			sc->sc_nextrx = 0;
	}
	if_input(ifp, &ml);
}

void
sgec_txintr(struct ze_softc *sc)
{
	struct ze_cdata *zc = sc->sc_zedata;
	struct ifnet *ifp = &sc->sc_if;
	int oldlink = sc->sc_flags & SGECF_LINKUP;
	u_short tdes0;

	while ((zc->zc_xmit[sc->sc_lastack].ze_tdr & ZE_TDR_OW) == 0) {
		int idx = sc->sc_lastack;

		if (sc->sc_lastack == sc->sc_nexttx)
			break;
		sc->sc_inq--;
		if (++sc->sc_lastack == TXDESCS)
			sc->sc_lastack = 0;

		if ((zc->zc_xmit[idx].ze_tdes1 & ZE_TDES1_DT) ==
		    ZE_TDES1_DT_SETUP) {
			continue;
		}

		tdes0 = zc->zc_xmit[idx].ze_tdes0;
		if (tdes0 & ZE_TDES0_ES) {
			if (tdes0 & ZE_TDES0_TO)
				printf("%s: transmit watchdog timeout\n",
				    sc->sc_dev.dv_xname);
			if (tdes0 & (ZE_TDES0_LO | ZE_TDES0_NC))
				sc->sc_flags &= ~SGECF_LINKUP;
			else
				sc->sc_flags |= SGECF_LINKUP;
			if (tdes0 & ZE_TDES0_EC) {
				printf("%s: excessive collisions, tdr %d\n",
				    sc->sc_dev.dv_xname,
				    zc->zc_xmit[idx].ze_tdr & ~ZE_TDR_OW);
				ifp->if_collisions += 16;
			} else if (tdes0 & ZE_TDES0_LC)
				ifp->if_collisions +=
				    (tdes0 & ZE_TDES0_CC) >> 3;
			if (tdes0 & ZE_TDES0_UF)
				printf("%s: underflow\n", sc->sc_dev.dv_xname);
			ifp->if_oerrors++;
			if (tdes0 & (ZE_TDES0_TO | ZE_TDES0_UF))
				zeinit(sc);
		} else {
			sc->sc_flags |= SGECF_LINKUP;
			if (zc->zc_xmit[idx].ze_tdes1 & ZE_TDES1_LS)
				ifp->if_opackets++;
			bus_dmamap_unload(sc->sc_dmat, sc->sc_xmtmap[idx]);
			if (sc->sc_txmbuf[idx]) {
				m_freem(sc->sc_txmbuf[idx]);
				sc->sc_txmbuf[idx] = 0;
			}
		}
	}

	/* Notify link status change */
	if ((sc->sc_flags & SGECF_LINKUP) != oldlink) {
		if (oldlink != 0) {
			ifp->if_link_state = LINK_STATE_DOWN;
			ifp->if_baudrate = 0;
		} else {
			ifp->if_link_state = LINK_STATE_UP;
			ifp->if_baudrate = IF_Mbps(10);
		}
		if_link_state_change(ifp);
	}

	if (sc->sc_inq == 0)
		ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	zestart(ifp); /* Put in more in queue */
}

int
sgec_intr(sc)
	struct ze_softc *sc;
{
	int s, csr;

	csr = ZE_RCSR(ZE_CSR5);
	if ((csr & ZE_NICSR5_IS) == 0) /* Wasn't we */
		return 0;

	/*
	 * On some systems, interrupts are handled at spl4, this can end up
	 * in pool corruption.
	 */
	s = splnet();

	ZE_WCSR(ZE_CSR5, csr);

	if (csr & ZE_NICSR5_ME) {
		printf("%s: memory error, resetting\n", sc->sc_dev.dv_xname);
		zeinit(sc);
		splx(s);
		return (1);
	}

	if (csr & ZE_NICSR5_RI)
		sgec_rxintr(sc);

	if (csr & ZE_NICSR5_TI)
		sgec_txintr(sc);

	splx(s);

	return 1;
}

/*
 * Process an ioctl request.
 */
int
zeioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ze_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		zeinit(sc);
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running,
			 * stop it. (by disabling receive mechanism).
			 */
			ZE_WCSR(ZE_CSR6, ZE_RCSR(ZE_CSR6) &
			    ~(ZE_NICSR6_ST|ZE_NICSR6_SR));
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface it marked up and it is stopped, then
			 * start it.
			 */
			zeinit(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0) {
			/*
			 * Send a new setup packet to match any new changes.
			 * (Like IFF_PROMISC etc)
			 */
			ze_setup(sc);
		}
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			ze_setup(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

/*
 * Add a receive buffer to the indicated descriptor.
 */
int
ze_add_rxbuf(sc, i)
	struct ze_softc *sc;
	int i;
{
	struct mbuf *m;
	struct ze_rdes *rp;
	int error;

	splassert(IPL_NET);

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}

	if (sc->sc_rxmbuf[i] != NULL)
		bus_dmamap_unload(sc->sc_dmat, sc->sc_rcvmap[i]);

	error = bus_dmamap_load(sc->sc_dmat, sc->sc_rcvmap[i],
	    m->m_ext.ext_buf, m->m_ext.ext_size, NULL, BUS_DMA_NOWAIT);
	if (error)
		panic("%s: can't load rx DMA map %d, error = %d",
		    sc->sc_dev.dv_xname, i, error);
	sc->sc_rxmbuf[i] = m;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_rcvmap[i], 0,
	    sc->sc_rcvmap[i]->dm_mapsize, BUS_DMASYNC_PREREAD);

	/*
	 * We know that the mbuf cluster is page aligned. Also, be sure
	 * that the IP header will be longword aligned.
	 */
	m->m_data += 2;
	rp = &sc->sc_zedata->zc_recv[i];
	rp->ze_bufsize = (m->m_ext.ext_size - 2);
	rp->ze_bufaddr = (char *)sc->sc_rcvmap[i]->dm_segs[0].ds_addr + 2;
	rp->ze_framelen = ZE_FRAMELEN_OW;

	return (0);
}

/*
 * Create a setup packet and put in queue for sending.
 */
void
ze_setup(sc)
	struct ze_softc *sc;
{
	struct ether_multi *enm;
	struct ether_multistep step;
	struct ze_cdata *zc = sc->sc_zedata;
	struct ifnet *ifp = &sc->sc_if;
	struct arpcom *ac = &sc->sc_ac;
	u_int8_t *enaddr = ac->ac_enaddr;
	int j, idx, s, reg;

	s = splnet();
	if (sc->sc_inq == (TXDESCS - 1)) {
		SET(sc->sc_flags, SGECF_SETUP);
		splx(s);
		return;
	}
	CLR(sc->sc_flags, SGECF_SETUP);

	/*
	 * Init the setup packet with valid info.
	 */
	memset(zc->zc_setup, 0xff, sizeof(zc->zc_setup)); /* Broadcast */
	bcopy(enaddr, zc->zc_setup, ETHER_ADDR_LEN);

	/*
	 * Multicast handling. The SGEC can handle up to 16 direct 
	 * ethernet addresses.
	 */
	j = 16;
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		goto setit;
	}

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		bcopy(enm->enm_addrlo, &zc->zc_setup[j], ETHER_ADDR_LEN);
		j += 8;
		ETHER_NEXT_MULTI(step, enm);
		if (enm != NULL && j == sizeof(zc->zc_setup)) {
			ifp->if_flags |= IFF_ALLMULTI;
			break;
		}
	}

setit:
	/*
	 * Fiddle with the receive logic.
	 */
	reg = ZE_RCSR(ZE_CSR6);
	DELAY(10);
	ZE_WCSR(ZE_CSR6, reg & ~ZE_NICSR6_SR); /* Stop rx */
	while ((ZE_RCSR(ZE_CSR5) & ZE_NICSR5_RS) != ZE_NICSR5_RS_STOP)
		DELAY(10);
	reg &= ~ZE_NICSR6_AF;
	if (ifp->if_flags & IFF_PROMISC)
		reg |= ZE_NICSR6_AF_PROM;
	else if (ifp->if_flags & IFF_ALLMULTI)
		reg |= ZE_NICSR6_AF_ALLM;
	DELAY(10);
	ZE_WCSR(ZE_CSR6, reg);
	while ((ZE_RCSR(ZE_CSR5) & ZE_NICSR5_RS) == ZE_NICSR5_RS_STOP)
		DELAY(10);
	/*
	 * Only send a setup packet if needed.
	 */
	if ((ifp->if_flags & (IFF_PROMISC|IFF_ALLMULTI)) == 0) {
		idx = sc->sc_nexttx;
		zc->zc_xmit[idx].ze_tdes1 = ZE_TDES1_DT_SETUP;
		zc->zc_xmit[idx].ze_bufsize = 128;
		zc->zc_xmit[idx].ze_bufaddr = sc->sc_pzedata->zc_setup;
		zc->zc_xmit[idx].ze_tdr = ZE_TDR_OW;

		zekick(sc);

		sc->sc_inq++;
		if (++sc->sc_nexttx == TXDESCS)
			sc->sc_nexttx = 0;
	}
	splx(s);
}

/*
 * Check for dead transmit logic.
 */
void
zetimeout(ifp)
	struct ifnet *ifp;
{
	struct ze_softc *sc = ifp->if_softc;

	if (sc->sc_inq == 0)
		return;

	printf("%s: xmit logic died, resetting...\n", sc->sc_dev.dv_xname);
	/*
	 * Do a reset of interface, to get it going again.
	 * Will it work by just restart the transmit logic?
	 */
	zeinit(sc);
}

/*
 * Reset chip:
 * Set/reset the reset flag.
 *  Write interrupt vector.
 *  Write ring buffer addresses.
 *  Write SBR.
 */
int
zereset(sc)
	struct ze_softc *sc;
{
	int reg, i, s;

	ZE_WCSR(ZE_CSR6, ZE_NICSR6_RE);
	DELAY(50000);
	if (ZE_RCSR(ZE_CSR5) & ZE_NICSR5_SF) {
		printf("%s: selftest failed\n", sc->sc_dev.dv_xname);
		return 1;
	}

	/*
	 * Get the vector that were set at match time, and remember it.
	 * WHICH VECTOR TO USE? Take one unused. XXX
	 * Funny way to set vector described in the programmers manual.
	 */
	reg = ZE_NICSR0_IPL14 | sc->sc_intvec | ZE_NICSR0_MBO; /* SYNC/ASYNC??? */
	i = 10;
	s = splnet();
	do {
		if (i-- == 0) {
			printf("Failing SGEC CSR0 init\n");
			splx(s);
			return 1;
		}
		ZE_WCSR(ZE_CSR0, reg);
	} while (ZE_RCSR(ZE_CSR0) != reg);
	splx(s);

	ZE_WCSR(ZE_CSR3, (vaddr_t)sc->sc_pzedata->zc_recv);
	ZE_WCSR(ZE_CSR4, (vaddr_t)sc->sc_pzedata->zc_xmit);
	return 0;
}
@


1.35
log
@fix some fallout from the IFQ rototilling.

from the ghost of architectures past
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.34 2015/11/25 03:09:58 dlg Exp $	*/
@


1.34
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.33 2015/11/24 17:11:38 mpi Exp $	*/
d385 1
a385 1
		IF_POLL(&sc->sc_if.if_snd, m);
d401 1
d404 1
a404 1
		IFQ_DEQUEUE(&sc->sc_if.if_snd, m);
@


1.33
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.32 2015/11/14 17:26:40 mpi Exp $	*/
d320 1
a320 1
	ifp->if_flags &= ~IFF_OACTIVE;
d400 1
a400 1
			ifp->if_flags |= IFF_OACTIVE;
d453 1
a453 1
		ifp->if_flags |= IFF_OACTIVE;
d569 1
a569 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.32
log
@No need to include <net/bpfdesc.h>

Now that "struct bpf_d" depends on <sys/srp.h> this is one of the offender
for removing the header from <sys/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.31 2015/11/07 12:01:22 dlg Exp $	*/
a57 1
#include <net/if_dl.h>
@


1.31
log
@get rid of IF_PREPEND by switching to IFQ_POLL/IFQ_DEQUEUE.

IF_PREPEND only checks priq state, so it wont work out well if
you're using hfsc.

tested by miod@@
ok mpi@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.30 2015/10/27 15:20:13 mpi Exp $	*/
a65 1
#include <net/bpfdesc.h>
@


1.30
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.29 2015/06/24 09:40:54 mpi Exp $	*/
d387 1
a387 1
		IF_DEQUEUE(&sc->sc_if.if_snd, m);
a401 1
			IF_PREPEND(&sc->sc_if.if_snd, m);
d405 1
@


1.29
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.28 2015/05/13 10:42:46 jsg Exp $	*/
a620 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d629 1
a629 6
		switch(ifa->ifa_addr->sa_family) {
		case AF_INET:
			zeinit(sc);
			arp_ifinit(&sc->sc_ac, ifa);
			break;
		}
@


1.28
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.27 2015/05/02 14:33:19 jsg Exp $	*/
a486 1
			ifp->if_ipackets++;
@


1.27
log
@add missing splx calls
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.26 2015/03/28 11:24:25 mpi Exp $	*/
d388 1
a388 1
		if (m == 0)
@


1.26
log
@Convert to if_input(), tested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.25 2014/12/22 02:26:54 tedu Exp $	*/
d597 1
@


1.25
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.24 2014/08/14 17:49:50 miod Exp $	*/
d467 1
a492 1
			m->m_pkthdr.rcvif = ifp;
d494 1
a494 5
#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
			ether_input_mbuf(ifp, m);
d499 1
@


1.24
log
@Unused variable, and more fixes in the attach failure path.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.23 2014/08/06 15:40:40 jsg Exp $	*/
a633 1
#ifdef INET
a637 1
#endif
@


1.23
log
@Correct some dma cleanup error paths.

While the index variables were correct the arrays of
dma handles they indexed were swapped for rx and tx.

As there are a mismatched number of rx and tx descriptors
we'd walk off the end of the rx handle array by 30 items.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.22 2014/06/13 21:06:24 miod Exp $	*/
d237 1
a237 1
			bus_dmamap_unload(sc->sc_dmat, sc->sc_xmtmap[i]);
a466 1
	struct ether_header *eh;
a493 1
			eh = mtod(m, struct ether_header *);
@


1.22
log
@Fix broken logic in sgec_rxintr() poorly duplicating some of ether_input()
checks, causing the rx ring pointer to stall as soon as an irrelevant
frame is received when the intergace is in bpf+promiscuous or `all multicast'
mode.

Problem spotted and tracked down to the use of bpf by sebastia@@. Hair pulling
by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.21 2013/11/27 08:56:31 mpi Exp $	*/
d243 2
a244 2
		if (sc->sc_xmtmap[i] != NULL)
			bus_dmamap_destroy(sc->sc_dmat, sc->sc_xmtmap[i]);
d248 2
a249 2
		if (sc->sc_rcvmap[i] != NULL)
			bus_dmamap_destroy(sc->sc_dmat, sc->sc_rcvmap[i]);
@


1.21
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.20 2011/09/26 21:44:04 miod Exp $	*/
d416 1
a426 3
			orword = 0;
			if (totlen == len)
				orword = ZE_TDES1_FS;
d441 1
d497 1
a497 1
			if (ifp->if_bpf) {
a498 8
				if ((ifp->if_flags & IFF_PROMISC) != 0 &&
				    ((eh->ether_dhost[0] & 1) == 0) &&
				    bcmp(sc->sc_ac.ac_enaddr, eh->ether_dhost,
				    ETHER_ADDR_LEN) != 0) {
					m_freem(m);
					continue;
				}
			}
a499 10
			/*
			 * ALLMULTI means PROMISC in this driver.
			 */
			if ((ifp->if_flags & IFF_ALLMULTI) &&
			    ((eh->ether_dhost[0] & 1) == 0) &&
			    bcmp(sc->sc_ac.ac_enaddr, eh->ether_dhost,
			    ETHER_ADDR_LEN)) {
				m_freem(m);
				continue;
			}
d786 1
a786 1
		if ((enm != NULL)&& (j == 128)) {
@


1.20
log
@Notify ifmedia layer of loss of link on SGEC interfaces (which only gets
detected upon failure to transmit if it is indeed lost), so that `ifconfig ze0'
reports the correct state of the link instead of always pretending it is up.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.19 2008/11/28 02:44:17 brad Exp $	*/
d770 2
a771 1
	u_int8_t *enaddr = sc->sc_ac.ac_enaddr;
d794 7
a800 1
	ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);
a801 4
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6)) {
			ifp->if_flags |= IFF_ALLMULTI;
			break;
		}
d811 1
@


1.19
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.18 2008/10/09 00:17:54 brad Exp $	*/
d226 1
d531 1
a533 1
	sc->sc_flags |= SGECF_LINKUP;
d555 2
d571 1
d581 13
@


1.18
log
@cosmetic change for ioctl funtions.. move splnet out from variable declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.17 2008/10/02 20:21:13 brad Exp $	*/
d628 1
a629 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d649 1
a649 2
		error = ifmedia_ioctl(ifp, (struct ifreq *)data,
		    &sc->sc_ifmedia, cmd);
a677 20
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/*
		 * Update our multicast list.
		 */
		error = (cmd == SIOCADDMULTI) ?
			ether_addmulti(ifr, &sc->sc_ac):
			ether_delmulti(ifr, &sc->sc_ac);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				ze_setup(sc);
			error = 0;
		}
		break;

d680 6
@


1.17
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.16 2008/08/22 17:09:06 deraadt Exp $	*/
d630 3
a632 1
	int s = splnet(), error = 0;
@


1.16
log
@Instead of spewing error messages about link status, support link status
like all drivers should
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.15 2006/08/31 22:10:57 miod Exp $	*/
a632 1

d698 2
a699 1
		error = EINVAL;
a700 1
	}
@


1.15
log
@Make sure we do mbuf operations at splnet(), for some models have ze
interrupting at spl4 (i.e. below splnet) and this can cause pool corruption;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.14 2006/08/30 19:28:11 miod Exp $	*/
d59 1
d78 2
d221 6
d262 17
d532 1
d553 1
a553 2
				printf("%s: no carrier\n",
				    sc->sc_dev.dv_xname);
d644 6
@


1.14
log
@Teach the SGEC driver about the Real World:
- check for error bits in descriptors, and count and report errors
  accordingly; make sure we do not pass up known-to-be-bad packets up the
  receive path.
- check for various error conditions which would cause the transmit process
  to go to suspended state, and recover from them, before the timeout expires.
- finally, on the VXT2000, the transmit process for some reason will reset
  its ring position to the beginning of the ring every time it completes a
  transmission burst, while we don't, so play with the head of ring register
  behind its back. This makes my VXT2000+ (net)boot multiuser.

Tested on VXT2000 (ze@@vxtbus), KA49 (ze@@vsbus) and KA53 (ze@@ibus); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.13 2006/08/27 16:50:44 miod Exp $	*/
d106 1
a106 1
	int i, rseg, error;
d175 1
d183 1
d561 1
a561 1
	int csr;
d566 7
d587 2
d685 2
@


1.13
log
@Move cfdriver structs to better places, in preparation for new attachments.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.12 2006/08/24 20:45:26 miod Exp $	*/
d73 10
a82 7
static	void	zeinit(struct ze_softc *);
static	void	zestart(struct ifnet *);
static	int	zeioctl(struct ifnet *, u_long, caddr_t);
static	int	ze_add_rxbuf(struct ze_softc *, int);
static	void	ze_setup(struct ze_softc *);
static	void	zetimeout(struct ifnet *);
static	int	zereset(struct ze_softc *);
a182 5
	/* For vmstat -i
	 */
	evcount_attach(&sc->sc_intrcnt, sc->sc_dev.dv_xname,
	    (void *)&sc->sc_intvec, &evcount_intr);

d289 2
a290 2
	ZE_WCSR(ZE_CSR6, ZE_NICSR6_IE|ZE_NICSR6_BL_8|ZE_NICSR6_ST|
	    ZE_NICSR6_SR|ZE_NICSR6_DC);
d304 33
d353 1
a353 2

		if (sc->sc_setup) {
d423 1
a423 2
		if ((ZE_RCSR(ZE_CSR5) & ZE_NICSR5_TS) != ZE_NICSR5_TS_RUN)
			ZE_WCSR(ZE_CSR1, ZE_NICSR1_TXPD);
d434 2
a435 3
int
sgec_intr(sc)
	struct ze_softc *sc;
d441 2
a442 10
	int csr, len;

	csr = ZE_RCSR(ZE_CSR5);
	if ((csr & ZE_NICSR5_IS) == 0) /* Wasn't we */
		return 0;
	ZE_WCSR(ZE_CSR5, csr);

	if (csr & ZE_NICSR5_RI)
		while ((zc->zc_recv[sc->sc_nextrx].ze_framelen &
		    ZE_FRAMELEN_OW) == 0) {
d444 15
d462 3
a464 1
			ze_add_rxbuf(sc, sc->sc_nextrx);
a466 2
			if (++sc->sc_nextrx == RXDESCS)
				sc->sc_nextrx = 0;
a489 1

d492 4
d497 9
a505 9
	if (csr & ZE_NICSR5_TI) {
		while ((zc->zc_xmit[sc->sc_lastack].ze_tdr & ZE_TDR_OW) == 0) {
			int idx = sc->sc_lastack;

			if (sc->sc_lastack == sc->sc_nexttx)
				break;
			sc->sc_inq--;
			if (++sc->sc_lastack == TXDESCS)
				sc->sc_lastack = 0;
d507 33
a539 4
			if ((zc->zc_xmit[idx].ze_tdes1 & ZE_TDES1_DT) ==
			    ZE_TDES1_DT_SETUP)
				continue;
			/* XXX collect statistics */
a547 4
		if (sc->sc_inq == 0)
			ifp->if_timer = 0;
		ifp->if_flags &= ~IFF_OACTIVE;
		zestart(ifp); /* Put in more in queue */
d549 29
d727 1
a727 1
		sc->sc_setup = 1;
d731 2
a732 1
	sc->sc_setup = 0;
d766 2
d775 2
d787 1
a787 2
		if ((ZE_RCSR(ZE_CSR5) & ZE_NICSR5_TS) != ZE_NICSR5_TS_RUN)
			ZE_WCSR(ZE_CSR1, -1);
@


1.12
log
@Check for a selftest failure after reset in the correct register.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.11 2006/04/16 00:46:32 pascoe Exp $	*/
d81 4
d394 1
a394 1
			ZE_WCSR(ZE_CSR1, -1);
@


1.11
log
@Convert the last remaining net-driver users of ether_input to ether_input_mbuf.

sgec ok martin@@
if_ie ok miod@@
if_de, if_hp not in GENERIC
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.10 2006/03/25 22:41:42 djm Exp $	*/
d731 1
a731 1
	if (ZE_RCSR(ZE_CSR6) & ZE_NICSR5_SF) {
d741 1
a741 1
	reg = ZE_NICSR0_IPL14 | sc->sc_intvec | 0x1fff0003; /* SYNC/ASYNC??? */
@


1.10
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.9 2005/11/24 04:49:25 brad Exp $	*/
d452 1
a452 3
			/* m_adj() the ethernet header out of the way and pass up */
			m_adj(m, sizeof(struct ether_header));
			ether_input(ifp, eh, m);
@


1.9
log
@splimp -> splnet

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.8 2005/01/15 05:24:10 brad Exp $	*/
d346 1
a346 1
			bpf_mtap(ifp->if_bpf, m);
d431 1
a431 1
				bpf_mtap(ifp->if_bpf, m);
@


1.8
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.7 2004/07/07 23:10:45 deraadt Exp $	*/
d316 1
a316 1
	s = splimp();
d631 1
a631 1
	s = splimp();
d745 1
a745 1
	s = splimp();
@


1.7
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.6 2003/05/11 19:41:12 deraadt Exp $	*/
d555 2
a556 1
			ze_setup(sc);
@


1.6
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.5 2002/10/12 01:09:44 krw Exp $	*/
d178 2
a179 1
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d213 1
a213 2
	printf("\n%s: hardware address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_ac.ac_enaddr));
@


1.5
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.4 2002/03/14 01:26:48 millert Exp $	*/
d199 1
a199 1
	strcpy(ifp->if_xname, sc->sc_dev.dv_xname);
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.3 2001/08/25 13:33:36 hugh Exp $	*/
d596 1
a596 1
		panic("%s: can't load rx DMA map %d, error = %d\n",
@


1.3
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.2 2001/02/20 19:39:35 mickey Exp $	*/
d73 7
a79 7
static	void	zeinit __P((struct ze_softc *));
static	void	zestart __P((struct ifnet *));
static	int	zeioctl __P((struct ifnet *, u_long, caddr_t));
static	int	ze_add_rxbuf __P((struct ze_softc *, int));
static	void	ze_setup __P((struct ze_softc *));
static	void	zetimeout __P((struct ifnet *));
static	int	zereset __P((struct ze_softc *));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.3 2001/08/25 13:33:36 hugh Exp $	*/
d73 7
a79 7
static	void	zeinit(struct ze_softc *);
static	void	zestart(struct ifnet *);
static	int	zeioctl(struct ifnet *, u_long, caddr_t);
static	int	ze_add_rxbuf(struct ze_softc *, int);
static	void	ze_setup(struct ze_softc *);
static	void	zetimeout(struct ifnet *);
static	int	zereset(struct ze_softc *);
@


1.3.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.3.4.1 2002/06/11 03:39:19 art Exp $	*/
d596 1
a596 1
		panic("%s: can't load rx DMA map %d, error = %d",
@


1.3.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d199 1
a199 1
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
@


1.2
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: sgec.c,v 1.1 2000/04/27 03:14:44 bjc Exp $	*/
/*      $NetBSD: sgec.c,v 1.1 1999/08/08 11:41:29 ragge Exp $ */
d176 4
d313 1
d396 1
a396 1
out:	if (sc->sc_inq)
d420 1
d433 1
d435 1
a435 2
				    ETHER_ADDR_LEN) != 0 &&
				    ((eh->ether_dhost[0] & 1) == 0)) {
a466 1
			/* XXX collect statistics */
d470 3
d479 2
a480 1
		ifp->if_timer = 0;
d492 1
a492 1
	register struct ifnet *ifp;
@


1.2.4.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.2 2001/02/20 19:39:35 mickey Exp $	*/
@


1.2.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: sgec.c,v 1.2.4.1 2001/05/14 21:37:56 niklas Exp $	*/
/*      $NetBSD: sgec.c,v 1.5 2000/06/04 02:14:14 matt Exp $ */
a175 4
	/* For vmstat -i
	 */
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);

a308 1
	int old_inq = sc->sc_inq;
d391 1
a391 1
out:	if (old_inq < sc->sc_inq)
a414 1
			ifp->if_ipackets++;
a426 1
				    ((eh->ether_dhost[0] & 1) == 0) &&
d428 2
a429 1
				    ETHER_ADDR_LEN) != 0) {
d461 1
a464 3
			/* XXX collect statistics */
			if (zc->zc_xmit[idx].ze_tdes1 & ZE_TDES1_LS)
				ifp->if_opackets++;
d471 1
a471 2
		if (sc->sc_inq == 0)
			ifp->if_timer = 0;
d483 1
a483 1
	struct ifnet *ifp;
@


1.2.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 7
a79 7
static	void	zeinit(struct ze_softc *);
static	void	zestart(struct ifnet *);
static	int	zeioctl(struct ifnet *, u_long, caddr_t);
static	int	ze_add_rxbuf(struct ze_softc *, int);
static	void	ze_setup(struct ze_softc *);
static	void	zetimeout(struct ifnet *);
static	int	zereset(struct ze_softc *);
@


1.2.4.4
log
@Sync the SMP branch with 3.3
@
text
@d596 1
a596 1
		panic("%s: can't load rx DMA map %d, error = %d",
@


1.2.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: sgec.c,v 1.2.4.4 2003/03/27 23:52:19 niklas Exp $	*/
d199 1
a199 1
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
@


1.1
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a207 3
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@

