head	1.36;
access;
symbols
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.22.0.20
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.18
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.16
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.14
	OPENBSD_5_0:1.22.0.12
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.10
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.8
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.4
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.10
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.10
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.8
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.6
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.12
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.10
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.8
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.35;
commitid	OSDG2O3Cgeifnf1W;

1.35
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.34;
commitid	J9apD0jq2AjFmqZc;

1.34
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.33;
commitid	B0kwmVGiD5DVx4kv;

1.33
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.32;
commitid	5gdEnqVoJuTuwdTu;

1.32
date	2015.11.06.07.08.42;	author dlg;	state Exp;
branches;
next	1.31;
commitid	1dS3633Z7gbTbRJy;

1.31
date	2015.10.27.15.20.13;	author mpi;	state Exp;
branches;
next	1.30;
commitid	iTpqmkP6HKjkg92B;

1.30
date	2015.07.04.17.32.20;	author miod;	state Exp;
branches;
next	1.29;
commitid	IhzI79xZ3gBmyKy1;

1.29
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.28;
commitid	MVWrtktB46JRxFWT;

1.28
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.27;
commitid	hN5bFCE56DrAjl99;

1.27
date	2015.02.01.15.27.11;	author miod;	state Exp;
branches;
next	1.26;
commitid	vfuvVKDlohAznQIf;

1.26
date	2014.12.22.02.26.54;	author tedu;	state Exp;
branches;
next	1.25;
commitid	2Ez9mHW0jDzojG4V;

1.25
date	2014.08.21.14.24.08;	author mpi;	state Exp;
branches;
next	1.24;
commitid	5eFitDmQJIvEdtoI;

1.24
date	2014.02.13.09.20.07;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2013.08.08.19.51.18;	author bluhm;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.09.00.43.48;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.09.00.17.54;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.14.11.41.30;	author martin;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.16.00.46.32;	author pascoe;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.10.11.45.43;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.15.17.46.43;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.07.23.10.45;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.27.03.14.42;	author bjc;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	97.09.10.08.28.39;	author maja;	state Exp;
branches
	1.10.12.1;
next	1.9;

1.9
date	97.05.28.23.10.59;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.01.15.23.24.32;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	96.06.12.08.20.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.05.13.38.01;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.03.09.09.30;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.05.13.39.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.32.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.27.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.05;	author deraadt;	state Exp;
branches;
next	;

1.10.12.1
date	2001.05.14.21.37.53;	author niklas;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	;

1.11.10.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: if_de.c,v 1.35 2015/12/08 13:34:22 tedu Exp $	*/
/*	$NetBSD: if_de.c,v 1.27 1997/04/19 15:02:29 ragge Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_de.c	7.12 (Berkeley) 12/16/90
 */

/*
 * DEC DEUNA interface
 *
 *	Lou Salkind
 *	New York University
 *
 * TODO:
 *	timeout routine (get statistics)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/buf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <machine/pte.h>
#include <machine/sid.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>

#include <machine/cpu.h>
#include <machine/mtpr.h>

#include <vax/if/if_dereg.h>
#include <vax/if/if_uba.h>
#include <vax/uba/ubavar.h>

#define NXMT	3	/* number of transmit buffers */
#define NRCV	7	/* number of receive buffers (must be > 1) */

int	dedebug = 0;

/*
 * Ethernet software status per interface.
 *
 * Each interface is referenced by a network interface structure,
 * ds_if, which the routing code uses to locate the interface.
 * This structure contains the output queue for the interface, its address, ...
 * We also have, for each interface, a UBA interface structure, which
 * contains information about the UNIBUS resources held by the interface:
 * map registers, buffered data paths, etc.  Information is cached in this
 * structure for use by the if_uba.c routines in running the interface
 * efficiently.
 */
struct	de_softc {
	struct	device ds_dev;		/* Configuration common part */
	struct	arpcom ds_ac;		/* Ethernet common part */
	struct	dedevice *ds_vaddr;	/* Virtual address of this interface */
#define 	ds_if	ds_ac.ac_if	/* network-visible interface */
	int	ds_flags;
#define	DSF_RUNNING	2		/* board is enabled */
#define	DSF_SETADDR	4		/* physical address is changed */
	int	ds_ubaddr;		/* map info for incore structs */
	struct	ifubinfo ds_deuba;	/* unibus resource structure */
	struct	ifrw ds_ifr[NRCV];	/* unibus receive maps */
	struct	ifxmt ds_ifw[NXMT];	/* unibus xmt maps */
	/* the following structures are always mapped in */
	struct	de_pcbb ds_pcbb;	/* port control block */
	struct	de_ring ds_xrent[NXMT];	/* transmit ring entries */
	struct	de_ring ds_rrent[NRCV];	/* receive ring entries */
	struct	de_udbbuf ds_udbbuf;	/* UNIBUS data buffer */
	/* end mapped area */
#define	INCORE_BASE(p)	((char *)&(p)->ds_pcbb)
#define	RVAL_OFF(s,n)	((char *)&(s)->n - INCORE_BASE(s))
#define	LVAL_OFF(s,n)	((char *)(s)->n - INCORE_BASE(s))
#define	PCBB_OFFSET(s)	RVAL_OFF(s,ds_pcbb)
#define	XRENT_OFFSET(s)	LVAL_OFF(s,ds_xrent)
#define	RRENT_OFFSET(s)	LVAL_OFF(s,ds_rrent)
#define	UDBBUF_OFFSET(s)	RVAL_OFF(s,ds_udbbuf)
#define	INCORE_SIZE(s)	RVAL_OFF(s, ds_xindex)
	int	ds_xindex;		/* UNA index into transmit chain */
	int	ds_rindex;		/* UNA index into receive chain */
	int	ds_xfree;		/* index for next transmit buffer */
	int	ds_nxmit;		/* # of transmits in progress */
};

int	dematch(struct device *, void *, void *);
void	deattach(struct device *, struct device *, void *);
int	dewait(struct de_softc *, char *);
void	deinit(struct de_softc *);
int	deioctl(struct ifnet *, u_long, caddr_t);
void	dereset(int);
void	destart(struct ifnet *);
void	deread(struct de_softc *, struct ifrw *, int);
void	derecv(int);
void	de_setaddr(u_char *, struct de_softc *);
void	deintr(int);


struct	cfdriver de_cd = {
	NULL, "de", DV_IFNET
};

struct	cfattach de_ca = {
	sizeof(struct de_softc), dematch, deattach
};
/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.  We get the ethernet address here.
 */
void
deattach(parent, self, aux)
	struct	device *parent, *self;
	void	*aux;
{
	struct uba_attach_args *ua = aux;
	struct de_softc *ds = (struct de_softc *)self;
	struct ifnet *ifp = &ds->ds_if;
	struct dedevice *addr;
	char *c;
	int csr1;
	u_int8_t myaddr[ETHER_ADDR_LEN];

	addr = (struct dedevice *)ua->ua_addr;
	ds->ds_vaddr = addr;
	bcopy(ds->ds_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = ds;
	ifp->if_flags = IFF_BROADCAST;

	/*
	 * What kind of a board is this?
	 * The error bits 4-6 in pcsr1 are a device id as long as
	 * the high byte is zero.
	 */
	csr1 = addr->pcsr1;
	if (csr1 & 0xff60)
		c = "broken";
	else if (csr1 & 0x10)
		c = "delua";
	else
		c = "deuna";

	printf("\n%s: %s\n", ds->ds_dev.dv_xname, c);
	/*
	 * Reset the board and temporarily map
	 * the pcbb buffer onto the Unibus.
	 */
	addr->pcsr0 = 0;		/* reset INTE */
	DELAY(100);
	addr->pcsr0 = PCSR0_RSET;
	(void)dewait(ds, "reset");

	ds->ds_ubaddr = uballoc((void *)ds->ds_dev.dv_parent,
	    (char *)&ds->ds_pcbb, sizeof (struct de_pcbb), 0);
	addr->pcsr2 = ds->ds_ubaddr & 0xffff;
	addr->pcsr3 = (ds->ds_ubaddr >> 16) & 0x3;
	addr->pclow = CMD_GETPCBB;
	(void)dewait(ds, "pcbb");

	ds->ds_pcbb.pcbb0 = FC_RDPHYAD;
	addr->pclow = CMD_GETCMD;
	(void)dewait(ds, "read addr ");

	ubarelse((void *)ds->ds_dev.dv_parent, &ds->ds_ubaddr);
	bcopy((caddr_t)&ds->ds_pcbb.pcbb2, myaddr, sizeof (myaddr));
	printf("%s: address %s\n", ds->ds_dev.dv_xname,
	    ether_sprintf(myaddr));
	ifp->if_ioctl = deioctl;
	ifp->if_start = destart;
	ds->ds_deuba.iff_flags = UBA_CANTWAIT;
#ifdef notdef
	/* CAN WE USE BDP's ??? */
	ds->ds_deuba.iff_flags |= UBA_NEEDBDP;
#endif
	if_attach(ifp);
	ether_ifattach(ifp);
}

/*
 * Reset of interface after UNIBUS reset.
 */
void
dereset(unit)
	int unit;
{
	struct	de_softc *sc = de_cd.cd_devs[unit];
	volatile struct dedevice *addr = sc->ds_vaddr;

	printf(" de%d", unit);
	sc->ds_if.if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&sc->ds_if.if_snd);
	sc->ds_flags &= ~DSF_RUNNING;
	addr->pcsr0 = PCSR0_RSET;
	(void)dewait(sc, "reset");
	deinit(sc);
}

/*
 * Initialization of interface; clear recorded pending
 * operations, and reinitialize UNIBUS usage.
 */
void
deinit(ds)
	struct de_softc *ds;
{
	volatile struct dedevice *addr;
	struct ifnet *ifp = &ds->ds_if;
	struct ifrw *ifrw;
	struct ifxmt *ifxp;
	struct de_ring *rp;
	int s,incaddr;

	if (ds->ds_flags & DSF_RUNNING)
		return;
	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		if (if_ubaminit(&ds->ds_deuba, (void *)ds->ds_dev.dv_parent,
		    sizeof (struct ether_header), (int)vax_atop(ETHERMTU),
		    ds->ds_ifr, NRCV, ds->ds_ifw, NXMT) == 0) { 
			printf("%s: can't initialize\n", ds->ds_dev.dv_xname);
			ds->ds_if.if_flags &= ~IFF_UP;
			return;
		}
		ds->ds_ubaddr = uballoc((void *)ds->ds_dev.dv_parent,
		    INCORE_BASE(ds), INCORE_SIZE(ds), 0);
	}
	addr = ds->ds_vaddr;

	/* set the pcbb block address */
	incaddr = ds->ds_ubaddr + PCBB_OFFSET(ds);
	addr->pcsr2 = incaddr & 0xffff;
	addr->pcsr3 = (incaddr >> 16) & 0x3;
	addr->pclow = 0;	/* reset INTE */
	DELAY(500);
	addr->pclow = CMD_GETPCBB;
	(void)dewait(ds, "pcbb");

	/* set the transmit and receive ring header addresses */
	incaddr = ds->ds_ubaddr + UDBBUF_OFFSET(ds);
	ds->ds_pcbb.pcbb0 = FC_WTRING;
	ds->ds_pcbb.pcbb2 = incaddr & 0xffff;
	ds->ds_pcbb.pcbb4 = (incaddr >> 16) & 0x3;

	incaddr = ds->ds_ubaddr + XRENT_OFFSET(ds);
	ds->ds_udbbuf.b_tdrbl = incaddr & 0xffff;
	ds->ds_udbbuf.b_tdrbh = (incaddr >> 16) & 0x3;
	ds->ds_udbbuf.b_telen = sizeof (struct de_ring) / sizeof (short);
	ds->ds_udbbuf.b_trlen = NXMT;
	incaddr = ds->ds_ubaddr + RRENT_OFFSET(ds);
	ds->ds_udbbuf.b_rdrbl = incaddr & 0xffff;
	ds->ds_udbbuf.b_rdrbh = (incaddr >> 16) & 0x3;
	ds->ds_udbbuf.b_relen = sizeof (struct de_ring) / sizeof (short);
	ds->ds_udbbuf.b_rrlen = NRCV;

	addr->pclow = CMD_GETCMD;
	(void)dewait(ds, "wtring");

	/* initialize the mode - enable hardware padding */
	ds->ds_pcbb.pcbb0 = FC_WTMODE;
	/* let hardware do padding - set MTCH bit on broadcast */
	ds->ds_pcbb.pcbb2 = MOD_TPAD|MOD_HDX;
	addr->pclow = CMD_GETCMD;
	(void)dewait(ds, "wtmode");

	/* set up the receive and transmit ring entries */
	ifxp = &ds->ds_ifw[0];
	for (rp = &ds->ds_xrent[0]; rp < &ds->ds_xrent[NXMT]; rp++) {
		rp->r_segbl = ifxp->ifw_info & 0xffff;
		rp->r_segbh = (ifxp->ifw_info >> 16) & 0x3;
		rp->r_flags = 0;
		ifxp++;
	}
	ifrw = &ds->ds_ifr[0];
	for (rp = &ds->ds_rrent[0]; rp < &ds->ds_rrent[NRCV]; rp++) {
		rp->r_slen = sizeof (struct de_buf);
		rp->r_segbl = ifrw->ifrw_info & 0xffff;
		rp->r_segbh = (ifrw->ifrw_info >> 16) & 0x3;
		rp->r_flags = RFLG_OWN;		/* hang receive */
		ifrw++;
	}

	/* start up the board (rah rah) */
	s = splnet();
	ds->ds_rindex = ds->ds_xindex = ds->ds_xfree = ds->ds_nxmit = 0;
	ds->ds_if.if_flags |= IFF_RUNNING;
	addr->pclow = PCSR0_INTE;		/* avoid interlock */
	destart(&ds->ds_if);		/* queue output packets */
	ds->ds_flags |= DSF_RUNNING;		/* need before de_setaddr */
	if (ds->ds_flags & DSF_SETADDR)
		de_setaddr(ds->ds_ac.ac_enaddr, ds);
	addr->pclow = CMD_START | PCSR0_INTE;
	splx(s);
}

/*
 * Setup output on interface.
 * Get another datagram to send off of the interface queue,
 * and map it to the interface before starting the output.
 * Must be called from ipl >= our interrupt level.
 */
void
destart(ifp)
	struct ifnet *ifp;
{
	int len;
	register struct de_softc *ds = ifp->if_softc;
	volatile struct dedevice *addr = ds->ds_vaddr;
	register struct de_ring *rp;
	struct mbuf *m;
	register int nxmit;

	/*
	 * the following test is necessary, since
	 * the code is not reentrant and we have
	 * multiple transmission buffers.
	 */
	if (ifq_is_oactive(&ds->ds_if.if_snd))
		return;
	for (nxmit = ds->ds_nxmit; nxmit < NXMT; nxmit++) {
		IFQ_DEQUEUE(&ds->ds_if.if_snd, m);
		if (m == NULL)
			break;
		rp = &ds->ds_xrent[ds->ds_xfree];
		if (rp->r_flags & XFLG_OWN)
			panic("deuna xmit in progress");
		len = if_ubaput(&ds->ds_deuba, &ds->ds_ifw[ds->ds_xfree], m);
		if (ds->ds_deuba.iff_flags & UBA_NEEDBDP) {
			struct uba_softc *uh = (void *)ds->ds_dev.dv_parent;

			if (uh->uh_ubapurge)
				(*uh->uh_ubapurge)
					(uh, ds->ds_ifw[ds->ds_xfree].ifw_bdp);
		}
		rp->r_slen = len;
		rp->r_tdrerr = 0;
		rp->r_flags = XFLG_STP|XFLG_ENP|XFLG_OWN;

		ds->ds_xfree++;
		if (ds->ds_xfree == NXMT)
			ds->ds_xfree = 0;
	}
	if (ds->ds_nxmit != nxmit) {
		ds->ds_nxmit = nxmit;
		if (ds->ds_flags & DSF_RUNNING)
			addr->pclow = PCSR0_INTE|CMD_PDMD;
	}
}

/*
 * Command done interrupt.
 */
void
deintr(unit)
	int	unit;
{
	volatile struct dedevice *addr;
	register struct de_softc *ds;
	register struct de_ring *rp;
	register struct ifxmt *ifxp;
	short csr0;

	ds = de_cd.cd_devs[unit];
	addr = ds->ds_vaddr;


	/* save flags right away - clear out interrupt bits */
	csr0 = addr->pcsr0;
	addr->pchigh = csr0 >> 8;


	ifq_set_oactive(&ds->ds_if.if_snd); /* prevent entering destart */
	/*
	 * if receive, put receive buffer on mbuf
	 * and hang the request again
	 */
	derecv(unit);

	/*
	 * Poll transmit ring and check status.
	 * Be careful about loopback requests.
	 * Then free buffer space and check for
	 * more transmit requests.
	 */
	for ( ; ds->ds_nxmit > 0; ds->ds_nxmit--) {
		rp = &ds->ds_xrent[ds->ds_xindex];
		if (rp->r_flags & XFLG_OWN)
			break;
		ds->ds_if.if_opackets++;
		ifxp = &ds->ds_ifw[ds->ds_xindex];
		/* check for unusual conditions */
		if (rp->r_flags & (XFLG_ERRS|XFLG_MTCH|XFLG_ONE|XFLG_MORE)) {
			if (rp->r_flags & XFLG_ERRS) {
				/* output error */
				ds->ds_if.if_oerrors++;
				if (dedebug) {
					printf("de%d: oerror, flags=%b ",
					    unit, rp->r_flags, XFLG_BITS);
					printf("tdrerr=%b\n",
					    rp->r_tdrerr, XERR_BITS);
				}
			} else if (rp->r_flags & XFLG_ONE) {
				/* one collision */
				ds->ds_if.if_collisions++;
			} else if (rp->r_flags & XFLG_MORE) {
				/* more than one collision */
				ds->ds_if.if_collisions += 2;	/* guess */
			} else if (rp->r_flags & XFLG_MTCH) {
				/* received our own packet */
				deread(ds, &ifxp->ifrw,
				    rp->r_slen - sizeof (struct ether_header));
			}
		}
		if (ifxp->ifw_xtofree) {
			m_freem(ifxp->ifw_xtofree);
			ifxp->ifw_xtofree = 0;
		}
		/* check if next transmit buffer also finished */
		ds->ds_xindex++;
		if (ds->ds_xindex == NXMT)
			ds->ds_xindex = 0;
	}
	ifq_clr_oactive(&ds->ds_if.if_snd);
	destart(&ds->ds_if);

	if (csr0 & PCSR0_RCBI) {
		if (dedebug)
			log(LOG_WARNING, "de%d: buffer unavailable\n", unit);
		addr->pclow = PCSR0_INTE|CMD_PDMD;
	}
}

/*
 * Ethernet interface receiver interface.
 * If input error just drop packet.
 * Otherwise purge input buffered data path and examine 
 * packet to determine type.  If can't determine length
 * from type, then have to drop packet.	 Othewise decapsulate
 * packet based on type and pass to type specific higher-level
 * input routine.
 */
void
derecv(unit)
	int unit;
{
	register struct de_softc *ds = de_cd.cd_devs[unit];
	register struct de_ring *rp;
	int len;

	rp = &ds->ds_rrent[ds->ds_rindex];
	while ((rp->r_flags & RFLG_OWN) == 0) {
		if (ds->ds_deuba.iff_flags & UBA_NEEDBDP) {
			struct uba_softc *uh = (void *)ds->ds_dev.dv_parent;

			if (uh->uh_ubapurge)
				(*uh->uh_ubapurge)
					(uh,ds->ds_ifr[ds->ds_rindex].ifrw_bdp);
		}
		len = (rp->r_lenerr&RERR_MLEN) - sizeof (struct ether_header)
			- 4;	/* don't forget checksum! */
		/* check for errors */
		if ((rp->r_flags & (RFLG_ERRS|RFLG_FRAM|RFLG_OFLO|RFLG_CRC)) ||
		    (rp->r_flags&(RFLG_STP|RFLG_ENP)) != (RFLG_STP|RFLG_ENP) ||
		    (rp->r_lenerr & (RERR_BUFL|RERR_UBTO|RERR_NCHN)) ||
		    len < ETHERMIN || len > ETHERMTU) {
			ds->ds_if.if_ierrors++;
			if (dedebug) {
				printf("de%d: ierror, flags=%b ",
				    unit, rp->r_flags, RFLG_BITS);
				printf("lenerr=%b (len=%d)\n",
				    rp->r_lenerr, RERR_BITS, len);
			}
		} else
			deread(ds, &ds->ds_ifr[ds->ds_rindex], len);

		/* hang the receive buffer again */
		rp->r_lenerr = 0;
		rp->r_flags = RFLG_OWN;

		/* check next receive buffer */
		ds->ds_rindex++;
		if (ds->ds_rindex == NRCV)
			ds->ds_rindex = 0;
		rp = &ds->ds_rrent[ds->ds_rindex];
	}
}

/*
 * Pass a packet to the higher levels.
 * We deal with the trailer protocol here.
 */
void
deread(ds, ifrw, len)
	register struct de_softc *ds;
	struct ifrw *ifrw;
	int len;
{
	struct ether_header *eh;
	struct mbuf *m;

	eh = (struct ether_header *)ifrw->ifrw_addr;
	if (len == 0)
		return;

	/*
	 * Pull packet off interface.  Off is nonzero if packet
	 * has trailing header; if_ubaget will then force this header
	 * information to be at the front.
	 */
	m = if_ubaget(&ds->ds_deuba, ifrw, len, &ds->ds_if);
	if (m) {
		/*
		 * XXX not exactly sure what if_ubaget does.  Manually 
		 * add the ethernet header to the start of the mbuf chain.
		 */
		M_PREPEND(m, sizeof(*eh), M_DONTWAIT);
		if (m) {
			*mtod(m, struct ether_header *) = *eh;
			ether_input_mbuf(&ds->ds_if, m);
		}
	}
}
/*
 * Process an ioctl request.
 */
int
deioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long	cmd;
	caddr_t data;
{
	register struct de_softc *ds = ifp->if_softc;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		deinit(ds);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    ds->ds_flags & DSF_RUNNING) {
			ds->ds_vaddr->pclow = 0;
			DELAY(5000);
			ds->ds_vaddr->pclow = PCSR0_RSET;
			ds->ds_flags &= ~DSF_RUNNING;
			ifq_clr_oactive(&ds->ds_if.if_snd);
		} else if (ifp->if_flags & IFF_UP &&
		    (ds->ds_flags & DSF_RUNNING) == 0)
			deinit(ds);
		break;

	default:
		error = ether_ioctl(ifp, &ds->ds_ac, cmd, data);
	}

	splx(s);
	return (error);
}

/*
 * set ethernet address for unit
 */
void
de_setaddr(physaddr, ds)
	u_char	*physaddr;
	struct de_softc *ds;
{
	volatile struct dedevice *addr= ds->ds_vaddr;
	
	if (! (ds->ds_flags & DSF_RUNNING))
		return;
		
	bcopy((caddr_t) physaddr, (caddr_t) &ds->ds_pcbb.pcbb2, 6);
	ds->ds_pcbb.pcbb0 = FC_WTPHYAD;
	addr->pclow = PCSR0_INTE|CMD_GETCMD;
	if (dewait(ds, "address change") == 0) {
		ds->ds_flags |= DSF_SETADDR;
		bcopy((caddr_t) physaddr, ds->ds_ac.ac_enaddr, 6);
	}
}

/*
 * Await completion of the named function
 * and check for errors.
 */
int
dewait(ds, fn)
	register struct de_softc *ds;
	char *fn;
{
	volatile struct dedevice *addr = ds->ds_vaddr;
	register int csr0;

	while ((addr->pcsr0 & PCSR0_INTR) == 0)
		;
	csr0 = addr->pcsr0;
	addr->pchigh = csr0 >> 8;
	if (csr0 & PCSR0_PCEI) {
		printf("de%d: %s failed, csr0=%b ", ds->ds_dev.dv_unit, fn,
		    csr0, PCSR0_BITS);
		printf("csr1=%b\n", addr->pcsr1, PCSR1_BITS);
	}
	return (csr0 & PCSR0_PCEI);
}

int
dematch(parent, cf, aux)
	struct	device *parent;
	void	*cf, *aux;
{
	struct	uba_attach_args *ua = aux;
	volatile struct dedevice *addr = (struct dedevice *)ua->ua_addr;
	int	i;

	/*
	 * Make sure self-test is finished before we screw with the board.
	 * Self-test on a DELUA can take 15 seconds (argh).
	 */
	for (i = 0;
	     i < 160 &&
	     (addr->pcsr0 & PCSR0_FATI) == 0 &&
	     (addr->pcsr1 & PCSR1_STMASK) == STAT_RESET;
	     ++i)
		DELAY(50000);
	if (((addr->pcsr0 & PCSR0_FATI) != 0) ||
	    (((addr->pcsr1 & PCSR1_STMASK) != STAT_READY) &&
		((addr->pcsr1 & PCSR1_STMASK) != STAT_RUN)))
		return(0);

	addr->pcsr0 = 0;
	DELAY(5000);
	addr->pcsr0 = PCSR0_RSET;
	while ((addr->pcsr0 & PCSR0_INTR) == 0)
		;
	/* make board interrupt by executing a GETPCBB command */
	addr->pcsr0 = PCSR0_INTE;
	addr->pcsr2 = 0;
	addr->pcsr3 = 0;
	addr->pcsr0 = PCSR0_INTE|CMD_GETPCBB;
	DELAY(50000);

	ua->ua_ivec = deintr;
	ua->ua_reset = dereset; /* Wish to be called after ubareset */

	return 1;
}
@


1.35
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.34 2015/11/25 03:09:58 dlg Exp $	*/
@


1.34
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.33 2015/11/24 17:11:38 mpi Exp $	*/
d163 1
a163 1
	ifp->if_flags = IFF_BROADCAST | IFF_NOTRAILERS;
@


1.33
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.32 2015/11/06 07:08:42 dlg Exp $	*/
d225 2
a226 1
	sc->ds_if.if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d351 1
a351 1
	if (ds->ds_if.if_flags & IFF_OACTIVE)
d405 1
a405 1
	ds->ds_if.if_flags |= IFF_OACTIVE;	/* prevent entering destart */
d456 1
a456 1
	ds->ds_if.if_flags &= ~IFF_OACTIVE;
d583 1
a583 1
			ds->ds_if.if_flags &= ~IFF_OACTIVE;
@


1.32
log
@use IFQ_DEQUEUE, not IF_DEQUEUE, to pull off the send queue.

this is more correct, as it supports hfsc use on these interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.31 2015/10/27 15:20:13 mpi Exp $	*/
a59 1
#include <net/if_dl.h>
@


1.31
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.30 2015/07/04 17:32:20 miod Exp $	*/
d354 1
a354 1
		IF_DEQUEUE(&ds->ds_if.if_snd, m);
@


1.30
log
@Fix misleading indent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.29 2015/06/24 09:40:54 mpi Exp $	*/
a564 1
	register struct ifaddr *ifa = (struct ifaddr *)data;
a573 6

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			arp_ifinit(&ds->ds_ac, ifa);
			break;
		}
@


1.29
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.28 2015/05/13 10:42:46 jsg Exp $	*/
d91 1
a91 1
	struct	device ds_dev;	/* Configuration common part */
d426 1
a426 1
		if (rp->r_flags & XFLG_ERRS) {
@


1.28
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.27 2015/02/01 15:27:11 miod Exp $	*/
a442 1
				ds->ds_if.if_ipackets++;
a484 1
		ds->ds_if.if_ipackets++;
@


1.27
log
@Gather the scattered (and sometimes duplicated) qbus address and size defines
to a single place. Get rid of the unused defines pertaining to older vax
models we dropped support for years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.26 2014/12/22 02:26:54 tedu Exp $	*/
d355 1
a355 1
		if (m == 0)
@


1.26
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.25 2014/08/21 14:24:08 mpi Exp $	*/
a70 1
#include <vax/uba/ubareg.h>
@


1.25
log
@Kill the remaining <netinet/in_systm.h> inclusion!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.24 2014/02/13 09:20:07 mpi Exp $	*/
a61 1
#ifdef INET
a64 1
#endif
a579 1
#ifdef INET
a582 1
#endif
@


1.24
log
@Checking if the per-interface address list is empty when configuring
the chip is always false, so remove this no-op.  In fact this list
contains the link-layer address as soon as the device attachs.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.23 2013/08/08 19:51:18 bluhm Exp $	*/
a63 1
#include <netinet/in_systm.h>
@


1.23
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from vax drivers.
test lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.22 2008/10/09 00:43:48 brad Exp $	*/
a250 4

	/* not yet, if address still unknown */
	if (TAILQ_EMPTY(&ifp->if_addrlist))
		return;
@


1.22
log
@Use ether_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.21 2008/10/09 00:17:54 brad Exp $	*/
a64 1
#include <netinet/in_var.h>
@


1.21
log
@cosmetic change for ioctl funtions.. move splnet out from variable declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.20 2008/08/14 11:41:30 martin Exp $	*/
d610 1
a610 1
		error = EINVAL;
d612 1
@


1.20
log
@convert the last traces of btoc/ctob macros

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.19 2006/04/16 00:46:32 pascoe Exp $	*/
d578 3
a580 1
	int s = splnet(), error = 0;
a582 1

@


1.19
log
@Convert the last remaining net-driver users of ether_input to ether_input_mbuf.

sgec ok martin@@
if_ie ok miod@@
if_de, if_hp not in GENERIC
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.18 2005/12/10 11:45:43 miod Exp $	*/
d261 1
a261 1
		    sizeof (struct ether_header), (int)vax_btoc(ETHERMTU),
@


1.18
log
@{en,re}trys -> {en,re}tries; eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.17 2005/06/08 17:03:02 henning Exp $	*/
a544 5
	/*
	 * Deal with trailer protocol: if type is trailer type
	 * get true type from first 16-bit word past data.
	 * Remember that type was trailer by setting off.
	 */
d555 11
a565 2
	if (m)
		ether_input(&ds->ds_if, eh, m);
@


1.17
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.16 2004/12/25 23:02:25 miod Exp $	*/
d109 2
a110 2
	struct	de_ring ds_xrent[NXMT];	/* transmit ring entrys */
	struct	de_ring ds_rrent[NRCV];	/* receive ring entrys */
@


1.16
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.15 2004/09/15 17:46:43 grange Exp $	*/
a69 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a586 13
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);
			
			if (ns_nullhost(*ina))
				ina->x_host = 
					*(union ns_host *)ds->ds_ac.ac_enaddr;
			else
				de_setaddr(ina->x_host.c_host, ds);
			break;
		    }
@


1.15
log
@Kill more netiso ghosts.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.14 2004/07/07 23:10:45 deraadt Exp $	*/
d259 1
a259 1
	if (ifp->if_addrlist.tqh_first == (struct ifaddr *)0)
@


1.14
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.13 2003/06/02 23:27:57 millert Exp $	*/
a72 6
#endif

#ifdef ISO
#include <netiso/iso.h>
#include <netiso/iso_var.h>
extern char all_es_snpa[], all_is_snpa[];
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.12 2002/03/14 01:26:47 millert Exp $	*/
d218 2
a219 2
	printf("%s: hardware address %s\n", ds->ds_dev.dv_xname,
		ether_sprintf(myaddr));
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.11 2000/04/27 03:14:42 bjc Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.10 1997/09/10 08:28:39 maja Exp $	*/
d142 11
a152 11
int	dematch __P((struct device *, void *, void *));
void	deattach __P((struct device *, struct device *, void *));
int	dewait __P((struct de_softc *, char *));
void	deinit __P((struct de_softc *));
int	deioctl __P((struct ifnet *, u_long, caddr_t));
void	dereset __P((int));
void	destart __P((struct ifnet *));
void	deread __P((struct de_softc *, struct ifrw *, int));
void	derecv __P((int));
void	de_setaddr __P((u_char *, struct de_softc *));
void	deintr __P((int));
@


1.11.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.11 2000/04/27 03:14:42 bjc Exp $	*/
d142 11
a152 11
int	dematch(struct device *, void *, void *);
void	deattach(struct device *, struct device *, void *);
int	dewait(struct de_softc *, char *);
void	deinit(struct de_softc *);
int	deioctl(struct ifnet *, u_long, caddr_t);
void	dereset(int);
void	destart(struct ifnet *);
void	deread(struct de_softc *, struct ifrw *, int);
void	derecv(int);
void	de_setaddr(u_char *, struct de_softc *);
void	deintr(int);
@


1.10
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.9 1997/05/28 23:10:59 niklas Exp $	*/
d64 1
a64 2
#include <net/netisr.h>
#include <net/route.h>
d114 1
a114 2
#define	ds_if	ds_ac.ac_if		/* network-visible interface */
#define	ds_addr	ds_ac.ac_enaddr		/* hardware Ethernet address */
d178 1
d221 1
a221 2
 	bcopy((caddr_t)&ds->ds_pcbb.pcbb2, (caddr_t)ds->ds_addr,
	    sizeof (ds->ds_addr));
d223 1
a223 1
		ether_sprintf(ds->ds_addr));
d276 1
a276 1
		    sizeof (struct ether_header), (int)btoc(ETHERMTU),
d348 1
a348 1
		de_setaddr(ds->ds_addr, ds);
d609 2
a610 1
				ina->x_host = *(union ns_host *)(ds->ds_addr);
d657 1
a657 1
		bcopy((caddr_t) physaddr, (caddr_t) ds->ds_addr, 6);
d671 1
a671 1
	register csr0;
d686 1
a686 1
dematch(parent, match, aux)
d688 1
a688 1
	void	*match, *aux;
@


1.10.12.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.11 2000/04/27 03:14:42 bjc Exp $	*/
d64 2
a65 1
#include <net/if_dl.h>
d115 2
a116 1
#define 	ds_if	ds_ac.ac_if	/* network-visible interface */
a179 1
	u_int8_t myaddr[ETHER_ADDR_LEN];
d222 2
a223 1
	bcopy((caddr_t)&ds->ds_pcbb.pcbb2, myaddr, sizeof (myaddr));
d225 1
a225 1
		ether_sprintf(myaddr));
d278 1
a278 1
		    sizeof (struct ether_header), (int)vax_btoc(ETHERMTU),
d350 1
a350 1
		de_setaddr(ds->ds_ac.ac_enaddr, ds);
d611 1
a611 2
				ina->x_host = 
					*(union ns_host *)ds->ds_ac.ac_enaddr;
d658 1
a658 1
		bcopy((caddr_t) physaddr, ds->ds_ac.ac_enaddr, 6);
d672 1
a672 1
	register int csr0;
d687 1
a687 1
dematch(parent, cf, aux)
d689 1
a689 1
	void	*cf, *aux;
@


1.10.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d142 11
a152 11
int	dematch(struct device *, void *, void *);
void	deattach(struct device *, struct device *, void *);
int	dewait(struct de_softc *, char *);
void	deinit(struct de_softc *);
int	deioctl(struct ifnet *, u_long, caddr_t);
void	dereset(int);
void	destart(struct ifnet *);
void	deread(struct de_softc *, struct ifrw *, int);
void	derecv(int);
void	de_setaddr(u_char *, struct de_softc *);
void	deintr(int);
@


1.10.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.10.12.2 2002/03/28 11:26:46 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9
log
@remove bitmask_snprintf
@
text
@d1 2
a2 2
/*	$OpenBSD: if_de.c,v 1.25 1996/11/15 03:11:19 thorpej Exp $	*/
/*	$NetBSD: if_de.c,v 1.25 1996/11/15 03:11:19 thorpej Exp $	*/
d94 2
a95 2
#define	NXMT	3	/* number of transmit buffers */
#define	NRCV	7	/* number of receive buffers (must be > 1) */
d148 1
a148 1
int     deioctl __P((struct ifnet *, u_long, caddr_t));
d150 1
a150 1
void    destart __P((struct ifnet *));
d152 1
a152 1
void    derecv __P((int));
d157 1
a157 1
struct  cfdriver de_cd = {
d365 1
a365 1
        int len;
d498 1
a498 1
 * from type, then have to drop packet.  Othewise decapsulate
d560 1
a560 1
    	struct mbuf *m;
d692 1
a692 1
	volatile struct	dedevice *addr = (struct dedevice *)ua->ua_addr;
d723 1
a723 1
	ua->ua_reset = dereset;	/* Wish to be called after ubareset */
@


1.8
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
d452 1
a452 1
			if (rp->r_flags & XFLG_ERRS) {
d456 4
a459 7
					char bits[64];
					printf("de%d: oerror, flags=%s ",
					    unit, bitmask_snprintf(rp->r_flags,
					    XFLG_BITS, bits, sizeof(bits)));
					printf("tdrerr%s (len=%d)\n",
					    rp->r_tdrerr, XERR_BITS,
					    bits, sizeof(bits));
d529 4
a532 8
				char bits[64];
				printf("de%d: ierror, flags=%s ",
				    unit, bitmask_snprintf(rp->r_flags,
				    RFLG_BITS, bits, sizeof(bits)));
				printf("lenerr=%s (len=%d)\n",
				    bitmask_snprintf(rp->r_lenerr,
				    RERR_BITS, bits, sizeof(bits)),
				    len);
d679 3
a681 5
		char bits[64];
		printf("de%d: %s failed, csr0=%s ", ds->ds_dev.dv_unit, fn,
		    bitmask_snprintf(csr0, PCSR0_BITS, bits, sizeof(bits)));
		printf("csr1=%s\n", bitmask_snprintf(addr->pcsr1, PCSR1_BITS,
		    bits, sizeof(bits)));
@


1.7
log
@sync to 0611
@
text
@d1 1
a1 1
/*	$NetBSD: if_de.c,v 1.21 1996/05/19 16:43:02 ragge Exp $	*/
d209 1
a209 1
	ds->ds_ubaddr = uballoc(ds->ds_dev.dv_parent->dv_unit,
d220 1
a220 1
	ubarelse(ds->ds_dev.dv_parent->dv_unit, &ds->ds_ubaddr);
d276 1
a276 1
		if (if_ubaminit(&ds->ds_deuba, ds->ds_dev.dv_parent->dv_unit,
d283 1
a283 1
		ds->ds_ubaddr = uballoc(ds->ds_dev.dv_parent->dv_unit,
d386 7
a392 3
		if (ds->ds_deuba.iff_flags & UBA_NEEDBDP)
			UBAPURGE(ds->ds_deuba.iff_uba,
			ds->ds_ifw[ds->ds_xfree].ifw_bdp);
d454 9
a462 4
				if (dedebug)
			printf("de%d: oerror, flags=%b tdrerr=%b (len=%d)\n",
				    unit, rp->r_flags, XFLG_BITS,
				    rp->r_tdrerr, XERR_BITS, rp->r_slen);
d515 7
a521 3
		if (ds->ds_deuba.iff_flags & UBA_NEEDBDP)
			UBAPURGE(ds->ds_deuba.iff_uba,
			ds->ds_ifr[ds->ds_rindex].ifrw_bdp);
d530 10
a539 4
			if (dedebug)
			printf("de%d: ierror, flags=%b lenerr=%b (len=%d)\n",
				unit, rp->r_flags, RFLG_BITS, rp->r_lenerr,
				RERR_BITS, len);
d684 7
a690 4
	if (csr0 & PCSR0_PCEI)
		printf("de%d: %s failed, csr0=%b csr1=%b\n", 
		    ds->ds_dev.dv_unit, fn, csr0, PCSR0_BITS, 
		    addr->pcsr1, PCSR1_BITS);
@


1.6
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d1 1
a1 1
/*	$NetBSD: if_de.c,v 1.19 1996/04/08 18:34:54 ragge Exp $	*/
d74 5
d111 1
a111 1
	struct	device ds_device;	/* Configuration common part */
d146 1
a146 1
void	deinit __P((int));
d152 1
a152 1
void	de_setaddr __P((u_char *, int));
d173 1
a173 1
	struct	uba_attach_args *ua = aux;
d177 1
a179 1
	printf("\n");
d182 2
a183 2
	ifp->if_unit = ds->ds_device.dv_unit;
	ifp->if_name = "de";
d193 1
a193 1
		printf("de%d: broken\n", ds->ds_device.dv_unit);
d195 1
a195 1
		printf("de%d: delua\n", ds->ds_device.dv_unit);
d197 1
a197 1
		printf("de%d: deuna\n", ds->ds_device.dv_unit);
d199 1
d209 1
a209 1
	ds->ds_ubaddr = uballoc(ds->ds_device.dv_parent->dv_unit,
d220 1
a220 1
	ubarelse(ds->ds_device.dv_parent->dv_unit, &ds->ds_ubaddr);
d223 1
a223 1
	printf("de%d: hardware address %s\n", ds->ds_device.dv_unit,
d251 1
a251 1
	deinit(unit);
d259 2
a260 2
deinit(unit)
	int unit;
a261 1
	struct de_softc *ds;
d263 1
a265 1
	struct ifnet *ifp;
a268 3
	ds = (struct de_softc *)de_cd.cd_devs[unit];
	ifp = &ds->ds_if;

d276 1
a276 1
		if (if_ubaminit(&ds->ds_deuba, ds->ds_device.dv_parent->dv_unit,
d279 1
a279 1
			printf("de%d: can't initialize\n", unit);
d283 1
a283 1
		ds->ds_ubaddr = uballoc(ds->ds_device.dv_parent->dv_unit,
d349 1
a349 1
		de_setaddr(ds->ds_addr, unit);
d365 1
a365 1
	register struct de_softc *ds = de_cd.cd_devs[ifp->if_unit];
d577 1
a577 1
	register struct de_softc *ds = de_cd.cd_devs[ifp->if_unit];
a579 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

d584 1
a584 1
		deinit(ifp->if_unit);
d592 12
d617 1
a617 1
			deinit(ifp->if_unit);
d631 1
a631 1
de_setaddr(physaddr, unit)
d633 1
a633 1
	int	unit;
a634 1
	register struct de_softc *ds = de_cd.cd_devs[unit];
d667 1
a667 1
		    ds->ds_device.dv_unit, fn, csr0, PCSR0_BITS, 
@


1.5
log
@sync w/ 0430
@
text
@a73 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d578 5
a593 12
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);
			
			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)(ds->ds_addr);
			else
				de_setaddr(ina->x_host.c_host,ifp->if_unit);
			break;
		    }
@


1.4
log
@from ragge: Don't include de.h; it doesn't exist anymore
@
text
@d1 1
a1 1
/*	$NetBSD: if_de.c,v 1.12 1995/12/30 19:42:16 ragge Exp $	*/
d48 17
a64 17
#include "sys/param.h"
#include "sys/systm.h"
#include "sys/mbuf.h"
#include "sys/buf.h"
#include "sys/protosw.h"
#include "sys/socket.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "sys/syslog.h"
#include "sys/device.h"

#include "machine/pte.h"
#include "machine/sid.h"

#include "net/if.h"
#include "net/netisr.h"
#include "net/route.h"
d67 5
a71 5
#include "netinet/in.h"
#include "netinet/in_systm.h"
#include "netinet/in_var.h"
#include "netinet/ip.h"
#include "netinet/if_ether.h"
d75 2
a76 2
#include "netns/ns.h"
#include "netns/ns_if.h"
d80 2
a81 2
#include "netiso/iso.h"
#include "netiso/iso_var.h"
d85 7
a91 6
#include "../include/cpu.h"
#include "../include/mtpr.h"
#include "if_dereg.h"
#include "if_uba.h"
#include "../uba/ubareg.h"
#include "../uba/ubavar.h"
d148 1
a148 1
int	dereset __P((int));
d153 1
d156 3
a158 2
struct  cfdriver decd =
	{ 0,"de",dematch, deattach, DV_IFNET, sizeof(struct de_softc) };
d160 3
d204 1
a204 1
	DELAY(5000);
a224 1
	ifp->if_reset = dereset;
a236 1
 * If interface is on specified uba, reset its state.
d238 1
a238 1
int
d242 2
a243 2
#if 0
	register struct uba_device *ui;
a244 3
	if (unit >= NDE || (ui = deinfo[unit]) == 0 || ui->ui_alive == 0 ||
	    ui->ui_ubanum != uban)
		return;
d246 4
a249 4
	de_softc[unit].ds_if.if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	de_softc[unit].ds_flags &= ~DSF_RUNNING;
	((struct dedevice *)ui->ui_addr)->pcsr0 = PCSR0_RSET;
	(void)dewait(ui, "reset");
a250 2
#endif
	return 0;
d269 1
a269 1
	ds = (struct de_softc *)decd.cd_devs[unit];
d296 1
a296 1
	DELAY(5000);
d368 1
a368 2
	int unit = ifp->if_unit;
	register struct de_softc *ds = decd.cd_devs[ifp->if_unit];
d420 1
a420 1
	ds = decd.cd_devs[unit];
d502 1
a502 1
	register struct de_softc *ds = decd.cd_devs[unit];
a550 2
	int s;
	register struct ifqueue *inq;
d580 1
a580 1
	register struct de_softc *ds = decd.cd_devs[ifp->if_unit];
d638 1
a638 1
	register struct de_softc *ds = decd.cd_devs[unit];
a680 1
	struct	de_softc *sc = match;
d695 3
a697 3
	if ((addr->pcsr0 & PCSR0_FATI) != 0 ||
	    (addr->pcsr1 & PCSR1_STMASK) != STAT_READY &&
		(addr->pcsr1 & PCSR1_STMASK) != STAT_RUN)
d711 1
d713 2
a714 1
	ua->ua_iarg = sc->ds_device.dv_unit;
@


1.3
log
@from netbsd:
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d1 1
a1 1
/*	$NetBSD: if_de.c,v 1.11 1995/12/24 02:30:52 mycroft Exp $	*/
a36 2

#include "de.h"
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: if_de.c,v 1.10 1995/12/01 19:37:55 ragge Exp $	*/
d348 1
a348 1
	s = splimp();
d587 1
a587 1
	int s = splimp(), error = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_de.c,v 1.7.2.1 1995/10/15 13:56:24 ragge Exp $	*/
a38 1
#if NDE > 0
a55 1
/* #include "sys/vmmac.h" */
d61 2
a62 2
#include "vax/include/pte.h"
#include "vax/include/sid.h"
a98 10

int	deprobe(), deattach(), deintr();
struct	uba_device *deinfo[NDE];
u_short destd[] = { 0 };
struct	uba_driver dedriver =
	{ deprobe, 0, deattach, 0, destd, "de", deinfo };
int	deinit(),deioctl(),dereset();
void	destart();


d112 1
d114 1
d131 7
a137 7
#define	RVAL_OFF(n)	((char *)&de_softc[0].n - INCORE_BASE(&de_softc[0]))
#define	LVAL_OFF(n)	((char *)de_softc[0].n - INCORE_BASE(&de_softc[0]))
#define	PCBB_OFFSET	RVAL_OFF(ds_pcbb)
#define	XRENT_OFFSET	LVAL_OFF(ds_xrent)
#define	RRENT_OFFSET	LVAL_OFF(ds_rrent)
#define	UDBBUF_OFFSET	RVAL_OFF(ds_udbbuf)
#define	INCORE_SIZE	RVAL_OFF(ds_xindex)
d142 1
a142 1
} de_softc[NDE];
d144 10
a153 11
deprobe(reg)
	caddr_t reg;
{
	register int br, cvec;		/* r11, r10 value-result */
	volatile struct dedevice *addr = (struct dedevice *)reg;
	register i;

#ifdef lint
	br = 0; cvec = br; br = cvec;
	i = 0; derint(i); deintr(i);
#endif
a154 14
	/*
	 * Make sure self-test is finished before we screw with the board.
	 * Self-test on a DELUA can take 15 seconds (argh).
	 */
	for (i = 0;
	     i < 160 &&
	     (addr->pcsr0 & PCSR0_FATI) == 0 &&
	     (addr->pcsr1 & PCSR1_STMASK) == STAT_RESET;
	     ++i)
		waitabit(10);
	if ((addr->pcsr0 & PCSR0_FATI) != 0 ||
	    (addr->pcsr1 & PCSR1_STMASK) != STAT_READY &&
		(addr->pcsr1 & PCSR1_STMASK) != STAT_RUN)
		return(0);
d156 2
a157 13
	addr->pcsr0 = 0;
	waitabit(1);
	addr->pcsr0 = PCSR0_RSET;
	while ((addr->pcsr0 & PCSR0_INTR) == 0)
		;
	/* make board interrupt by executing a GETPCBB command */
	addr->pcsr0 = PCSR0_INTE;
	addr->pcsr2 = 0;
	addr->pcsr3 = 0;
	addr->pcsr0 = PCSR0_INTE|CMD_GETPCBB;
	waitabit(10);
	return(1);
}
d164 9
a172 6
deattach(ui)
	struct uba_device *ui;
{
	register struct de_softc *ds = &de_softc[ui->ui_unit];
	register struct ifnet *ifp = &ds->ds_if;
	volatile struct dedevice *addr = (struct dedevice *)ui->ui_addr;
d175 4
a178 1
	ifp->if_unit = ui->ui_unit;
d189 1
a189 1
		printf("de%d: broken\n", ui->ui_unit);
d191 1
a191 1
		printf("de%d: delua\n", ui->ui_unit);
d193 1
a193 1
		printf("de%d: deuna\n", ui->ui_unit);
d200 1
a200 1
	waitabit(1);
d202 1
a202 1
	(void)dewait(ui, "reset");
d204 2
a205 2
	ds->ds_ubaddr = uballoc(ui->ui_ubanum, (char *)&ds->ds_pcbb,
		sizeof (struct de_pcbb), 0);
d209 1
a209 1
	(void)dewait(ui, "pcbb");
d213 1
a213 1
	(void)dewait(ui, "read addr ");
d215 1
a215 1
	ubarelse(ui->ui_ubanum, &ds->ds_ubaddr);
d218 1
a218 1
	printf("de%d: hardware address %s\n", ui->ui_unit,
d236 3
a238 2
dereset(unit, uban)
	int unit, uban;
d240 1
d252 2
d260 1
a264 1
	struct uba_device *ui;
d272 1
a272 2
	ds = &de_softc[unit];
	ui = deinfo[unit];
d282 1
a282 1
		if (if_ubaminit(&ds->ds_deuba, ui->ui_ubanum,
d289 2
a290 2
		ds->ds_ubaddr = uballoc(ui->ui_ubanum, INCORE_BASE(ds),
			INCORE_SIZE, 0);
d292 1
a292 1
	addr = (struct dedevice *)ui->ui_addr;
d295 1
a295 1
	incaddr = ds->ds_ubaddr + PCBB_OFFSET;
d299 1
a299 1
	waitabit(1);
d301 1
a301 1
	(void)dewait(ui, "pcbb");
d304 1
a304 1
	incaddr = ds->ds_ubaddr + UDBBUF_OFFSET;
d309 1
a309 1
	incaddr = ds->ds_ubaddr + XRENT_OFFSET;
d314 1
a314 1
	incaddr = ds->ds_ubaddr + RRENT_OFFSET;
d321 1
a321 1
	(void)dewait(ui, "wtring");
d328 1
a328 1
	(void)dewait(ui, "wtmode");
d372 2
a373 3
	struct uba_device *ui = deinfo[unit];
	volatile struct dedevice *addr = (struct dedevice *)ui->ui_addr;
	register struct de_softc *ds = &de_softc[unit];
d414 3
a416 1
deintr(uba,vector,level,unit)
a417 1
	struct uba_device *ui;
d424 2
a425 3
	ui = deinfo[unit];
	addr = (struct dedevice *)ui->ui_addr;
	ds = &de_softc[unit];
d502 1
d506 1
a506 1
	register struct de_softc *ds = &de_softc[unit];
d547 1
a563 1
/*	eh->ether_type = ntohs((u_short)eh->ether_type); */
d579 1
d582 1
a582 1
	int cmd;
d586 1
a586 1
	register struct de_softc *ds = &de_softc[ifp->if_unit];
d619 3
a621 5
			((struct dedevice *)
			   (deinfo[ifp->if_unit]->ui_addr))->pclow = 0;
			waitabit(1);
			((struct dedevice *)
			   (deinfo[ifp->if_unit]->ui_addr))->pclow = PCSR0_RSET;
d639 1
d641 2
a642 2
	u_char *physaddr;
	int unit;
d644 2
a645 3
	register struct de_softc *ds = &de_softc[unit];
	struct uba_device *ui = deinfo[unit];
	volatile struct dedevice *addr= (struct dedevice *)ui->ui_addr;
d653 1
a653 1
	if (dewait(ui, "address change") == 0) {
d663 3
a665 2
dewait(ui, fn)
	register struct uba_device *ui;
d668 1
a668 1
	volatile struct dedevice *addr = (struct dedevice *)ui->ui_addr;
d677 1
a677 1
		    ui->ui_unit, fn, csr0, PCSR0_BITS, 
d682 24
a705 4
de_match(){
	printf("de_match\n");
	return 0;
}
d707 14
a720 3
void
de_attach(){
	printf("de_attach\n");
a721 6

struct  cfdriver decd =
        { NULL,"de",de_match, de_attach, DV_IFNET, sizeof(struct uba_driver) };


#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
