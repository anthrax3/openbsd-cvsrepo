head	1.20;
access;
symbols
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.8
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.8
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.03.09.16.28.48;	author deraadt;	state dead;
branches;
next	1.19;
commitid	OSDG2O3Cgeifnf1W;

1.19
date	2014.12.22.02.26.54;	author tedu;	state Exp;
branches;
next	1.18;
commitid	2Ez9mHW0jDzojG4V;

1.18
date	2013.09.24.20.10.51;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.22.23.04.45;	author mpf;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.01.12.45.40;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.02.09.28.40;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.07.23.10.45;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.11.09.36.24;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.48;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.25.13.33.36;	author hugh;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.27.03.14.43;	author bjc;	state Exp;
branches;
next	1.4;

1.4
date	98.09.16.22.41.19;	author jason;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	97.09.10.08.28.40;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	97.05.29.00.04.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.01.15.23.24.33;	author maja;	state Exp;
branches;
next	;

1.4.8.1
date	2001.05.14.21.37.54;	author niklas;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2001.10.31.03.08.01;	author nate;	state Exp;
branches;
next	1.4.8.3;

1.4.8.3
date	2001.11.13.21.04.18;	author niklas;	state Exp;
branches;
next	1.4.8.4;

1.4.8.4
date	2002.03.28.11.26.46;	author niklas;	state Exp;
branches;
next	1.4.8.5;

1.4.8.5
date	2003.03.27.23.52.19;	author niklas;	state Exp;
branches;
next	1.4.8.6;

1.4.8.6
date	2003.06.07.11.14.47;	author ho;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.39.19;	author art;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.10.29.00.28.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: if_le.c,v 1.19 2014/12/22 02:26:54 tedu Exp $	*/
/*	$NetBSD: if_le.c,v 1.14 1999/08/14 18:40:23 ragge Exp $	*/

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Jason R. Thorpe of the Numerical Aerospace
 * Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <uvm/uvm_extern.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/cpu.h>
#include <machine/nexus.h>
#include <machine/scb.h>

#include <dev/ic/lancereg.h>
#include <dev/ic/lancevar.h>
#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>

#define ETHER_MIN_LEN   64      /* minimum frame length, including CRC */
#define	LEVEC	0xd4	/* Interrupt vector on 3300/3400 */

struct le_softc {
	struct	am7990_softc sc_am7990; /* Must be first */
	struct  evcount sc_intrcnt;
	int	sc_vec;
	volatile uint16_t *sc_rap;
	volatile uint16_t *sc_rdp;
};

int	le_ibus_match(struct device *, void *, void *);
void	le_ibus_attach(struct device *, struct device *, void *);
void	lewrcsr(struct lance_softc *, uint16_t, uint16_t);
uint16_t lerdcsr(struct lance_softc *, uint16_t);
void	lance_copytobuf_gap2(struct lance_softc *, void *, int, int);
void	lance_copyfrombuf_gap2(struct lance_softc *, void *, int, int);
void	lance_zerobuf_gap2(struct lance_softc *, int, int);

struct cfattach le_ibus_ca = {
	sizeof(struct le_softc), le_ibus_match, le_ibus_attach
};

void
lewrcsr(struct lance_softc *ls, uint16_t port, uint16_t val)
{
	struct le_softc *sc = (void *)ls;

	*sc->sc_rap = port;
	*sc->sc_rdp = val;
}

uint16_t
lerdcsr(struct lance_softc *ls, uint16_t port)
{
	struct le_softc *sc = (void *)ls;

	*sc->sc_rap = port;
	return *sc->sc_rdp;
}

int
le_ibus_match(struct device *parent, void *cf, void *aux)
{
	struct bp_conf *bp = aux;

	if (strcmp("lance", bp->type))
		return 0;
	return 1;
}

void
le_ibus_attach(struct device *parent, struct device *self, void *aux)
{
	struct le_softc *lesc = (void *)self;
	struct lance_softc *sc = &lesc->sc_am7990.lsc;
	int *lance_addr;
	int i, br;

	lesc->sc_rdp = (short *)vax_map_physmem(0x20084400, 1);
	lesc->sc_rap = lesc->sc_rdp + 2;

	/*
	 * Set interrupt vector, by forcing an interrupt.
	 */
	scb_vecref(0, 0); /* Clear vector ref */
	*lesc->sc_rap = LE_CSR0;
	*lesc->sc_rdp = LE_C0_STOP;
	DELAY(100);
	*lesc->sc_rdp = LE_C0_INIT|LE_C0_INEA;
	DELAY(100000);
	i = scb_vecref(&lesc->sc_vec, &br);
	if (i == 0 || lesc->sc_vec == 0)
		return;
	scb_vecalloc(lesc->sc_vec, (void *)am7990_intr, sc,
	     SCB_ISTACK, &lesc->sc_intrcnt);
	evcount_attach(&lesc->sc_intrcnt, self->dv_xname, &lesc->sc_vec);

	printf(": vec %d ipl %x\n%s", lesc->sc_vec, br, self->dv_xname);
	/*
	 * MD functions.
	 */
	sc->sc_rdcsr = lerdcsr;
	sc->sc_wrcsr = lewrcsr;
	sc->sc_nocarrier = NULL;

	sc->sc_mem = (void *)uvm_km_valloc(kernel_map, (128 * 1024));
	if (sc->sc_mem == 0)
		return;

	ioaccess((vaddr_t)sc->sc_mem, 0x20120000, (128 * 1024) >> VAX_PGSHIFT);

	sc->sc_addr = 0;
	sc->sc_memsize = (64 * 1024);

	sc->sc_copytodesc = lance_copytobuf_gap2;
	sc->sc_copyfromdesc = lance_copyfrombuf_gap2;
	sc->sc_copytobuf = lance_copytobuf_gap2;
	sc->sc_copyfrombuf = lance_copyfrombuf_gap2;
	sc->sc_zerobuf = lance_zerobuf_gap2;

	/*
	 * Get the ethernet address out of rom
	 */
	lance_addr = (int *)vax_map_physmem(0x20084200, 1);
	for (i = 0; i < 6; i++)
		sc->sc_arpcom.ac_enaddr[i] = (u_char)lance_addr[i];
	vax_unmap_physmem((vaddr_t)lance_addr, 1);

	am7990_config(&lesc->sc_am7990);
}

/*
 * gap2: two bytes of data followed by two bytes of pad.
 *
 * Buffers must be 4-byte aligned.  The code doesn't worry about
 * doing an extra byte.
 */

void
lance_copytobuf_gap2(struct lance_softc *sc, void *fromv, int boff, int len)
{
	volatile caddr_t buf = sc->sc_mem;
	caddr_t from = fromv;
	volatile uint16_t *bptr;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile uint16_t *)buf) + (boff - 1);
		*bptr = (*from++ << 8) | (*bptr & 0xff);
		bptr += 2;
		len--;
	} else
		bptr = ((volatile uint16_t *)buf) + boff;
	while (len > 1) {
		*bptr = (from[1] << 8) | (from[0] & 0xff);
		bptr += 2;
		from += 2;
		len -= 2;
	}
	if (len == 1)
		*bptr = (uint16_t)*from;
}

void
lance_copyfrombuf_gap2(struct lance_softc *sc, void *tov, int boff, int len)
{
	volatile caddr_t buf = sc->sc_mem;
	caddr_t to = tov;
	volatile uint16_t *bptr;
	uint16_t tmp;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile uint16_t *)buf) + (boff - 1);
		*to++ = (*bptr >> 8) & 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile uint16_t *)buf) + boff;
	while (len > 1) {
		tmp = *bptr;
		*to++ = tmp & 0xff;
		*to++ = (tmp >> 8) & 0xff;
		bptr += 2;
		len -= 2;
	}
	if (len == 1)
		*to = *bptr & 0xff;
}

void
lance_zerobuf_gap2(struct lance_softc *sc, int boff, int len)
{
	volatile caddr_t buf = sc->sc_mem;
	volatile uint16_t *bptr;

	if ((unsigned)boff & 0x1) {
		bptr = ((volatile uint16_t *)buf) + (boff - 1);
		*bptr &= 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile uint16_t *)buf) + boff;
	while (len > 0) {
		*bptr = 0;
		bptr += 2;
		len -= 2;
	}
}
@


1.19
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.18 2013/09/24 20:10:51 miod Exp $	*/
@


1.18
log
@Sync the MI LANCE code ( le(4) ) with NetBSD, except for the following:
- the am7990_get() - now lance_get() - is unchanged.
- the interrupt acknowledge logic is unchanged, and will disable interrupts,
  then acknowledge all interrupt conditions.

Add ILACC (79900) support (from NetBSD).

Both LANCE (am7990.c) and ILACC (am79900.c) code share as much common code
(lance.c) as possible. This affects all le(4) attachments, but the changes
are mostly mechanical, to split am7990-specific parts from lance-agnostic
parts.

Compile tested on all affected platforms. Tested on alpha, hp300, luna88k,
mvme88k, sparc, sparc64 and vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.17 2010/09/20 06:33:47 matthew Exp $	*/
a80 1
#ifdef INET
a81 1
#endif
@


1.17
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.16 2008/10/22 23:04:45 mpf Exp $	*/
d90 2
d102 2
a103 2
	volatile u_short *sc_rap;
	volatile u_short *sc_rdp;
d108 5
a112 5
void	lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
void	lance_copytobuf_gap2(struct am7990_softc *, void *, int, int);
void	lance_copyfrombuf_gap2(struct am7990_softc *, void *, int, int);
void	lance_zerobuf_gap2(struct am7990_softc *, int, int);
d119 1
a119 3
lewrcsr(ls, port, val)
	struct am7990_softc *ls;
	u_int16_t port, val;
d127 2
a128 4
u_int16_t
lerdcsr(ls, port)
	struct am7990_softc *ls;
	u_int16_t port;
d137 1
a137 4
le_ibus_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d147 1
a147 3
le_ibus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d149 2
a150 1
	struct le_softc *sc = (void *)self;
d154 2
a155 2
	sc->sc_rdp = (short *)vax_map_physmem(0x20084400, 1);
	sc->sc_rap = sc->sc_rdp + 2;
d161 2
a162 2
	*sc->sc_rap = LE_CSR0;
	*sc->sc_rdp = LE_C0_STOP;
d164 1
a164 1
	*sc->sc_rdp = LE_C0_INIT|LE_C0_INEA;
d166 2
a167 2
	i = scb_vecref(&sc->sc_vec, &br);
	if (i == 0 || sc->sc_vec == 0)
d169 3
a171 3
	scb_vecalloc(sc->sc_vec, (void *)am7990_intr, sc,
	     SCB_ISTACK, &sc->sc_intrcnt);
	evcount_attach(&sc->sc_intrcnt, self->dv_xname, &sc->sc_vec);
d173 1
a173 1
	printf(": vec %d ipl %x\n%s", sc->sc_vec, br, self->dv_xname);
d177 6
a182 7
	sc->sc_am7990.sc_rdcsr = lerdcsr;
	sc->sc_am7990.sc_wrcsr = lewrcsr;
	sc->sc_am7990.sc_nocarrier = NULL;

	sc->sc_am7990.sc_mem =
	    (void *)uvm_km_valloc(kernel_map, (128 * 1024));
	if (sc->sc_am7990.sc_mem == 0)
d185 4
a188 2
	ioaccess((vaddr_t)sc->sc_am7990.sc_mem, 0x20120000,
	    (128 * 1024) >> VAX_PGSHIFT);
d190 5
a194 9
	
	sc->sc_am7990.sc_addr = 0;
	sc->sc_am7990.sc_memsize = (64 * 1024);

	sc->sc_am7990.sc_copytodesc = lance_copytobuf_gap2;
	sc->sc_am7990.sc_copyfromdesc = lance_copyfrombuf_gap2;
	sc->sc_am7990.sc_copytobuf = lance_copytobuf_gap2;
	sc->sc_am7990.sc_copyfrombuf = lance_copyfrombuf_gap2;
	sc->sc_am7990.sc_zerobuf = lance_zerobuf_gap2;
d201 1
a201 1
		sc->sc_am7990.sc_arpcom.ac_enaddr[i] = (u_char)lance_addr[i];
d204 1
a204 3
	bcopy(self->dv_xname, sc->sc_am7990.sc_arpcom.ac_if.if_xname,
	    IFNAMSIZ);
	am7990_config(&sc->sc_am7990);
d215 1
a215 5
lance_copytobuf_gap2(sc, fromv, boff, len)
	struct am7990_softc *sc;
	void *fromv;
	int boff;
	register int len;
d218 2
a219 2
	register caddr_t from = fromv;
	register volatile u_int16_t *bptr;
d223 1
a223 1
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
d228 1
a228 1
		bptr = ((volatile u_int16_t *)buf) + boff;
d236 1
a236 1
		*bptr = (u_int16_t)*from;
d240 1
a240 4
lance_copyfrombuf_gap2(sc, tov, boff, len)
	struct am7990_softc *sc;
	void *tov;
	int boff, len;
d243 3
a245 3
	register caddr_t to = tov;
	register volatile u_int16_t *bptr;
	register u_int16_t tmp;
d249 1
a249 1
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
d254 1
a254 1
		bptr = ((volatile u_int16_t *)buf) + boff;
d267 1
a267 3
lance_zerobuf_gap2(sc, boff, len)
	struct am7990_softc *sc;
	int boff, len;
d270 1
a270 1
	register volatile u_int16_t *bptr;
d273 1
a273 1
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
d278 1
a278 1
		bptr = ((volatile u_int16_t *)buf) + boff;
@


1.16
log
@#if INET  => #ifdef INET
#if INET6 => #ifdef INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.15 2008/06/26 05:42:13 ray Exp $	*/
d177 1
a177 2
	evcount_attach(&sc->sc_intrcnt, self->dv_xname,
	    (void *)&sc->sc_vec, &evcount_intr);
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.14 2007/09/01 12:45:40 miod Exp $	*/
d81 1
a81 1
#if INET
@


1.14
log
@Do not include <machine/rpb.h> unless necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.13 2005/07/02 09:28:40 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	  This product includes software developed by the NetBSD
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@Remove dead code; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 2004/07/07 23:10:45 deraadt Exp $	*/
a94 1
#include <machine/rpb.h>
@


1.12
log
@new-style interrupt counters.  based on initial work by hugh.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.11 2003/06/02 23:27:57 millert Exp $	*/
a118 1
void	leintr(void *);
a312 8
}

void
leintr(arg)
	void *arg;
{
	int unit = (int)arg;
	am7990_intr(le_cd.cd_devs[unit]);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.10 2002/06/11 09:36:24 hugh Exp $	*/
d106 2
a107 1
	struct  evcnt sc_intrcnt;
d167 1
a167 1
	int i, vec, br;
d181 2
a182 2
	i = scb_vecref(&vec, &br);
	if (i == 0 || vec == 0)
d184 1
a184 1
	scb_vecalloc(vec, (void *)am7990_intr, sc,
d186 2
a187 1
	evcnt_attach(self, "intr", &sc->sc_intrcnt);
d189 1
a189 1
	printf(": vec %o ipl %x\n%s", vec, br, self->dv_xname);
@


1.10
log
@New boot code, mostly from ragge's work in NetBSD.
Some header syncing and a couple network drivers came along for the ride.
Assembly files have been renamed from .s to .S to facilitate diffs.
Kernel is backwards compat - with manual interaction.
OpenBSD features have been preserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.9 2002/03/14 01:26:48 millert Exp $	*/
d56 1
a56 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.8 2001/11/06 19:53:17 miod Exp $	*/
a227 8

	/*
	 * Register this device as boot device if we booted from it.
	 * This will fail if there are more than one le in a machine,
	 * fortunately there may be only one.
	 */
	if (B_TYPE(bootdev) == BDEV_LE)
		booted_from = self;
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.7 2001/09/19 20:50:57 mickey Exp $	*/
d115 8
a122 8
int	le_ibus_match __P((struct device *, void *, void *));
void	le_ibus_attach __P((struct device *, struct device *, void *));
void	lewrcsr __P((struct am7990_softc *, u_int16_t, u_int16_t));
u_int16_t lerdcsr __P((struct am7990_softc *, u_int16_t));
void	lance_copytobuf_gap2 __P((struct am7990_softc *, void *, int, int));
void	lance_copyfrombuf_gap2 __P((struct am7990_softc *, void *, int, int));
void	lance_zerobuf_gap2 __P((struct am7990_softc *, int, int));
void	leintr __P((void *));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.8 2001/11/06 19:53:17 miod Exp $	*/
d115 8
a122 8
int	le_ibus_match(struct device *, void *, void *);
void	le_ibus_attach(struct device *, struct device *, void *);
void	lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
void	lance_copytobuf_gap2(struct am7990_softc *, void *, int, int);
void	lance_copyfrombuf_gap2(struct am7990_softc *, void *, int, int);
void	lance_zerobuf_gap2(struct am7990_softc *, int, int);
void	leintr(void *);
@


1.8.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.8.2.1 2002/06/11 03:39:19 art Exp $	*/
d228 8
@


1.7
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.6 2001/08/25 13:33:36 hugh Exp $	*/
a86 1
#include <vm/vm.h>
@


1.6
log
@Bring in some useful stuff from NetBSD. Mostly work by Matt Thomas,
and concerned with intvec counting. Also some ANSIfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.5 2000/04/27 03:14:43 bjc Exp $	*/
d88 1
a88 1
#include <vm/vm_kern.h>
@


1.5
log
@sync w/netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.4 1998/09/16 22:41:19 jason Exp $	*/
d111 1
d188 3
a190 1
	scb_vecalloc(vec, (void *)am7990_intr, sc, SCB_ISTACK);
@


1.4
log
@o if_media'fied am7990
o if_media'fied sun4m le.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_le.c,v 1.3 1997/09/10 08:28:40 maja Exp $	*/
/*	$NetBSD: if_le.c,v 1.8 1997/04/21 22:04:23 ragge Exp $	*/
d4 36
a39 1
/* #define LE_CHIP_IS_POKEY	/* does VS2000 need this ??? */
a41 1
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
d87 3
d91 1
d95 1
a96 3
#endif

#include <net/if_media.h>
a97 7
/*
 * This would be nice, but it's not yet there...
 *
 * #include <machine/autoconf.h>
 */

#include <machine/pte.h>
d99 1
a99 4
#include <machine/mtpr.h>
#include <machine/uvax.h>
#include <machine/ka410.h>
#include <machine/vsbus.h>
d101 1
a103 1
#define LE_NEED_BUF_CONTIG
d106 2
a107 1
#include <dev/tc/if_levar.h>
d109 5
a113 18
#define xdebug(x)

#ifdef LE_CHIP_IS_POKEY
/* 
 * access LANCE registers and double-check their contents
 */
#define wbflush()	/* do nothing */
void lewritereg();
#define LERDWR(cntl, src, dst)	{ (dst) = (src); wbflush(); }
#define LEWREG(src, dst)	lewritereg(&(dst), (src))
#endif

#define LE_IOSIZE 64*1024	/* 64K of real-mem are reserved and already */
extern void *le_iomem;		/* mapped into virt-mem by cpu_steal_pages */
extern u_long le_ioaddr;	/* le_iomem is virt, le_ioaddr is phys */

#define LE_SOFTC(unit)	le_cd.cd_devs[unit]
#define LE_DELAY(x)	DELAY(x)
d115 8
a122 2
int lematch __P((struct device *, void *, void *));
void leattach __P((struct device *, struct device *, void *));
d124 2
a125 4
int leintr __P((void *sc));

struct cfattach le_ca = {
	sizeof(struct le_softc), lematch, leattach
d128 3
a130 6
hide void lewrcsr __P ((struct am7990_softc *, u_int16_t, u_int16_t));
hide u_int16_t lerdcsr __P ((struct am7990_softc *, u_int16_t));

hide void
lewrcsr(sc, port, val)
	struct am7990_softc *sc;
d133 1
a133 1
	struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
d135 2
a136 7
#ifdef LE_CHIP_IS_POKEY
	LEWREG(port, ler1->ler1_rap);
	LERDWR(port, val, ler1->ler1_rdp);
#else
	ler1->ler1_rap = port;
	ler1->ler1_rdp = val;
#endif
d139 3
a141 3
hide u_int16_t
lerdcsr(sc, port)
	struct am7990_softc *sc;
d144 1
a144 2
	struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
	u_int16_t val;
d146 2
a147 14
#ifdef LE_CHIP_IS_POKEY
	LEWREG(port, ler1->ler1_rap);
	LERDWR(0, ler1->ler1_rdp, val);
#else
	ler1->ler1_rap = port;
	val = ler1->ler1_rdp;
#endif
	return (val);
}

integrate void
lehwinit(sc)
	struct am7990_softc *sc;
{
d151 1
a151 1
lematch(parent, match, aux)
d153 2
a154 1
	void *match, *aux;
d156 1
a156 10
	struct cfdata *cf = match;
	struct confargs *ca = aux;

	/*
	 * There could/should be more checks, but for now...
	 */
	if (strcmp(ca->ca_name, "le") &&
	    strcmp(ca->ca_name, "am7990") &&
	    strcmp(ca->ca_name, "AM7990"))
		return (0);
d158 3
a160 1
	return (1);
a162 3
/*
 *
 */
d164 1
a164 1
leattach(parent, self, aux)
d168 26
a193 11
	register struct le_softc *sc = (void *)self;
	struct confargs *ca = aux;
	u_char *cp;	/* pointer to MAC address */
	int i;

	sc->sc_r1  = (void*)uvax_phys2virt(ca->ca_ioaddr);

	sc->sc_am7990.sc_conf3 = 0;
	sc->sc_am7990.sc_mem = le_iomem;
	sc->sc_am7990.sc_addr = le_ioaddr;
	sc->sc_am7990.sc_memsize = LE_IOSIZE;
a194 2
	sc->sc_am7990.sc_rdcsr = lerdcsr;
	sc->sc_am7990.sc_hwinit = lehwinit;
d197 17
a213 9
	xdebug(("leattach: mem=%x, addr=%x, size=%x (%d)\n",
	    sc->sc_am7990.sc_mem, sc->sc_am7990.sc_addr,
	    sc->sc_am7990.sc_memsize, sc->sc_am7990.sc_memsize));

	sc->sc_am7990.sc_copytodesc = am7990_copytobuf_contig;
	sc->sc_am7990.sc_copyfromdesc = am7990_copyfrombuf_contig;
	sc->sc_am7990.sc_copytobuf = am7990_copytobuf_contig;
	sc->sc_am7990.sc_copyfrombuf = am7990_copyfrombuf_contig;
	sc->sc_am7990.sc_zerobuf = am7990_zerobuf_contig;
d218 4
a221 4
	for (i = 0; i < sizeof(sc->sc_am7990.sc_arpcom.ac_enaddr); i++) {
		int *eaddr = (void*)uvax_phys2virt(ca->ca_enaddr);
		sc->sc_am7990.sc_arpcom.ac_enaddr[i] = (u_char)eaddr[i];
	}
d223 2
a224 1
	bcopy(self->dv_xname, sc->sc_am7990.sc_arpcom.ac_if.if_xname, IFNAMSIZ);
a226 7
#ifdef LEDEBUG
	sc->sc_am7990.sc_debug = LEDEBUG;
#endif

	vsbus_intr_register(ca, am7990_intr, &sc->sc_am7990);
	vsbus_intr_enable(ca);

a235 1
#ifdef LE_CHIP_IS_POKEY
d237 4
a240 3
 * Write a lance register port, reading it back to ensure success. This seems
 * to be necessary during initialization, since the chip appears to be a bit
 * pokey sometimes.
d242 60
d303 3
a305 3
lewritereg(regptr, val)
	register volatile u_short *regptr;
	register u_short val;
d307 2
a308 1
	register int i = 0;
d310 11
a320 9
	while (*regptr != val) {
		*regptr = val;
		wbflush();
		if (++i > 10000) {
			printf("le: Reg did not settle (to x%x): x%x\n", val,
			    *regptr);
			return;
		}
		DELAY(100);
d323 8
a330 1
#endif
@


1.4.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 2
a2 2
/*	$OpenBSD: if_le.c,v 1.5 2000/04/27 03:14:43 bjc Exp $	*/
/*	$NetBSD: if_le.c,v 1.14 1999/08/14 18:40:23 ragge Exp $	*/
d4 1
a4 36
/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Jason R. Thorpe of the Numerical Aerospace
 * Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	  This product includes software developed by the NetBSD
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d7 1
a52 3
#include <vm/vm.h>
#include <vm/vm_kern.h>

a53 1
#include <net/if_media.h>
d57 1
a58 1
#include <netinet/if_ether.h>
d60 9
d70 4
a73 1
#include <machine/nexus.h>
a74 1
#include <machine/scb.h>
d77 1
d80 20
a99 2
#define ETHER_MIN_LEN   64      /* minimum frame length, including CRC */
#define	LEVEC	0xd4	/* Interrupt vector on 3300/3400 */
d101 2
a102 5
struct le_softc {
	struct	am7990_softc sc_am7990; /* Must be first */
	volatile u_short *sc_rap;
	volatile u_short *sc_rdp;
};
d104 1
a104 8
int	le_ibus_match __P((struct device *, void *, void *));
void	le_ibus_attach __P((struct device *, struct device *, void *));
void	lewrcsr __P((struct am7990_softc *, u_int16_t, u_int16_t));
u_int16_t lerdcsr __P((struct am7990_softc *, u_int16_t));
void	lance_copytobuf_gap2 __P((struct am7990_softc *, void *, int, int));
void	lance_copyfrombuf_gap2 __P((struct am7990_softc *, void *, int, int));
void	lance_zerobuf_gap2 __P((struct am7990_softc *, int, int));
void	leintr __P((void *));
d106 2
a107 2
struct cfattach le_ibus_ca = {
	sizeof(struct le_softc), le_ibus_match, le_ibus_attach
d110 6
a115 3
void
lewrcsr(ls, port, val)
	struct am7990_softc *ls;
d118 1
a118 1
	struct le_softc *sc = (void *)ls;
d120 7
a126 2
	*sc->sc_rap = port;
	*sc->sc_rdp = val;
d129 3
a131 3
u_int16_t
lerdcsr(ls, port)
	struct am7990_softc *ls;
d134 2
a135 1
	struct le_softc *sc = (void *)ls;
d137 14
a150 2
	*sc->sc_rap = port;
	return *sc->sc_rdp;
d154 1
a154 1
le_ibus_match(parent, cf, aux)
d156 1
a156 2
	void *cf;
	void *aux;
d158 10
a167 1
	struct bp_conf *bp = aux;
d169 1
a169 3
	if (strcmp("lance", bp->type))
		return 0;
	return 1;
d172 3
d176 1
a176 1
le_ibus_attach(parent, self, aux)
d180 12
a191 25
	struct le_softc *sc = (void *)self;
	int *lance_addr;
	int i, vec, br;

	sc->sc_rdp = (short *)vax_map_physmem(0x20084400, 1);
	sc->sc_rap = sc->sc_rdp + 2;

	/*
	 * Set interrupt vector, by forcing an interrupt.
	 */
	scb_vecref(0, 0); /* Clear vector ref */
	*sc->sc_rap = LE_CSR0;
	*sc->sc_rdp = LE_C0_STOP;
	DELAY(100);
	*sc->sc_rdp = LE_C0_INIT|LE_C0_INEA;
	DELAY(100000);
	i = scb_vecref(&vec, &br);
	if (i == 0 || vec == 0)
		return;
	scb_vecalloc(vec, (void *)am7990_intr, sc, SCB_ISTACK);

	printf(": vec %o ipl %x\n%s", vec, br, self->dv_xname);
	/*
	 * MD functions.
	 */
d193 1
a193 1
	sc->sc_am7990.sc_wrcsr = lewrcsr;
d196 9
a204 17
	sc->sc_am7990.sc_mem =
	    (void *)uvm_km_valloc(kernel_map, (128 * 1024));
	if (sc->sc_am7990.sc_mem == 0)
		return;

	ioaccess((vaddr_t)sc->sc_am7990.sc_mem, 0x20120000,
	    (128 * 1024) >> VAX_PGSHIFT);

	
	sc->sc_am7990.sc_addr = 0;
	sc->sc_am7990.sc_memsize = (64 * 1024);

	sc->sc_am7990.sc_copytodesc = lance_copytobuf_gap2;
	sc->sc_am7990.sc_copyfromdesc = lance_copyfrombuf_gap2;
	sc->sc_am7990.sc_copytobuf = lance_copytobuf_gap2;
	sc->sc_am7990.sc_copyfrombuf = lance_copyfrombuf_gap2;
	sc->sc_am7990.sc_zerobuf = lance_zerobuf_gap2;
d209 4
a212 4
	lance_addr = (int *)vax_map_physmem(0x20084200, 1);
	for (i = 0; i < 6; i++)
		sc->sc_am7990.sc_arpcom.ac_enaddr[i] = (u_char)lance_addr[i];
	vax_unmap_physmem((vaddr_t)lance_addr, 1);
d214 1
a214 2
	bcopy(self->dv_xname, sc->sc_am7990.sc_arpcom.ac_if.if_xname,
	    IFNAMSIZ);
d217 7
d233 1
d235 3
a237 4
 * gap2: two bytes of data followed by two bytes of pad.
 *
 * Buffers must be 4-byte aligned.  The code doesn't worry about
 * doing an extra byte.
a238 1

d240 3
a242 5
lance_copytobuf_gap2(sc, fromv, boff, len)
	struct am7990_softc *sc;
	void *fromv;
	int boff;
	register int len;
d244 1
a244 21
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t from = fromv;
	register volatile u_int16_t *bptr;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*bptr = (*from++ << 8) | (*bptr & 0xff);
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 1) {
		*bptr = (from[1] << 8) | (from[0] & 0xff);
		bptr += 2;
		from += 2;
		len -= 2;
	}
	if (len == 1)
		*bptr = (u_int16_t)*from;
}
d246 9
a254 25
void
lance_copyfrombuf_gap2(sc, tov, boff, len)
	struct am7990_softc *sc;
	void *tov;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t to = tov;
	register volatile u_int16_t *bptr;
	register u_int16_t tmp;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*to++ = (*bptr >> 8) & 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 1) {
		tmp = *bptr;
		*to++ = tmp & 0xff;
		*to++ = (tmp >> 8) & 0xff;
		bptr += 2;
		len -= 2;
a255 32
	if (len == 1)
		*to = *bptr & 0xff;
}

void
lance_zerobuf_gap2(sc, boff, len)
	struct am7990_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register volatile u_int16_t *bptr;

	if ((unsigned)boff & 0x1) {
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*bptr &= 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 0) {
		*bptr = 0;
		bptr += 2;
		len -= 2;
	}
}

void
leintr(arg)
	void *arg;
{
	int unit = (int)arg;
	am7990_intr(le_cd.cd_devs[unit]);
d257 1
@


1.4.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.4.8.1 2001/05/14 21:37:54 niklas Exp $	*/
d88 1
a88 1
#include <uvm/uvm_extern.h>
a110 1
	struct  evcnt sc_intrcnt;
d187 1
a187 3
	scb_vecalloc(vec, (void *)am7990_intr, sc,
	     SCB_ISTACK, &sc->sc_intrcnt);
	evcnt_attach(self, "intr", &sc->sc_intrcnt);
@


1.4.8.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
@


1.4.8.4
log
@Merge in -current from about a week ago
@
text
@d115 8
a122 8
int	le_ibus_match(struct device *, void *, void *);
void	le_ibus_attach(struct device *, struct device *, void *);
void	lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
void	lance_copytobuf_gap2(struct am7990_softc *, void *, int, int);
void	lance_copyfrombuf_gap2(struct am7990_softc *, void *, int, int);
void	lance_zerobuf_gap2(struct am7990_softc *, int, int);
void	leintr(void *);
@


1.4.8.5
log
@Sync the SMP branch with 3.3
@
text
@d228 8
@


1.4.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.4.8.5 2003/03/27 23:52:19 niklas Exp $	*/
d56 5
a60 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3
log
@Sync with NetBSD 970516. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.2 1997/05/29 00:04:32 niklas Exp $	*/
d59 2
@


1.2
log
@RCS tagging
@
text
@d1 2
a2 2
/*	$OpenBSD: if_le.c,v 1.3 1996/10/13 03:34:53 christos Exp $	*/
/*	$NetBSD: if_le.c,v 1.3 1996/10/13 03:34:53 christos Exp $	*/
a3 1
#define LEDEBUG	 1		/* debug-level: 0 or 1 */
d51 1
d72 1
d108 4
a111 1
integrate void
d113 1
a113 1
	struct le_softc *sc;
d116 1
a116 1
	struct lereg1 *ler1 = sc->sc_r1;
d127 1
a127 1
integrate u_int16_t
d129 1
a129 1
	struct le_softc *sc;
d132 1
a132 1
	struct lereg1 *ler1 = sc->sc_r1;
d145 6
d189 4
a220 1
}
d222 7
a228 4
integrate void
lehwinit(sc)
	struct le_softc *sc;
{
@


1.1
log
@sync with NetBSD 970112 -moj
@
text
@d1 1
@
