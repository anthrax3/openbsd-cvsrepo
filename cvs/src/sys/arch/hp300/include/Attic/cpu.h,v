head	1.40;
access;
symbols
	OPENBSD_5_5:1.39.0.14
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.10
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.8
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.6
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.20
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.9.0.16
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.10
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.39;

1.39
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.24.12.18.58;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.30.17.10.42;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.24.13.20.19;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.11.20.48.11;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.02.18.09.23;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.17.23.56.46;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.01.11.54.22;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.14.22.39.29;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.08.22.13.54;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.13.21.49.13;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.20.09.20.41;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.11.19.20.26;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.07.21.33.43;	author nordin;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.10.21.10.46;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.20.19.02.27;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.30.20.58.18;	author miod;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.08.25.11.37.26;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.20.19.49.03;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.08.02.37.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.25.22.07.17;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.11.23.24.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.04.22.49.00;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	98.03.01.00.37.31;	author niklas;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	97.07.06.08.02.11;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.04.17.10.28.40;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.04.16.11.56.34;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.12.15.13.33;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.11.47.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.21.14.40.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.29.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.24;	author deraadt;	state Exp;
branches;
next	;

1.9.10.1
date	2001.07.04.10.15.52;	author niklas;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.9.10.3;

1.9.10.3
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.9.10.4;

1.9.10.4
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.9.10.5;

1.9.10.5
date	2003.03.27.23.19.21;	author niklas;	state Exp;
branches;
next	1.9.10.6;

1.9.10.6
date	2003.06.07.11.11.35;	author ho;	state Exp;
branches;
next	1.9.10.7;

1.9.10.7
date	2004.06.05.23.10.46;	author niklas;	state Exp;
branches;
next	1.9.10.8;

1.9.10.8
date	2004.06.06.05.23.39;	author tedu;	state Exp;
branches;
next	;

1.16.2.1
date	2002.01.31.22.55.08;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: cpu.h,v 1.39 2011/03/23 16:54:34 pirofti Exp $	*/
/*	$NetBSD: cpu.h,v 1.28 1998/02/13 07:41:51 scottr Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: cpu.h 1.16 91/03/25$
 *
 *	@@(#)cpu.h	8.4 (Berkeley) 1/5/94
 */

#ifndef _MACHINE_CPU_H_
#define	_MACHINE_CPU_H_

/*
 * Exported definitions unique to hp300/68k cpu support.
 */

/*
 * Get common m68k CPU definitions.
 */
#include <m68k/cpu.h>

#ifdef _KERNEL

/*
 * Get interrupt glue.
 */
#include <machine/intr.h>

/*
 * Arguments to hardclock and gatherstats encapsulate the previous
 * machine state in an opaque clockframe.  On the hp300, we use
 * what the hardware pushes on an interrupt (frame format 0).
 */
struct clockframe {
	u_short	sr;		/* sr at time of interrupt */
	u_long	pc;		/* pc at time of interrupt */
	u_short	vo;		/* vector offset (4-word frame) */
};

#define	CLKF_USERMODE(framep)	(((framep)->sr & PSL_S) == 0)
#define	CLKF_PC(framep)		((framep)->pc)
#if 0
/* We would like to do it this way... */
#define	CLKF_INTR(framep)	(((framep)->sr & PSL_M) == 0)
#else
/* but until we start using PSL_M, we have to do this instead */
#define	CLKF_INTR(framep)	(0)	/* XXX */
#endif


/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern int want_resched;	/* resched() was called */
#define	need_resched(ci)	{ want_resched = 1; aston(); }
#define clear_resched(ci) 	want_resched = 0

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the hp300, request an ast to send us
 * through trap, marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	aston()

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#define	signotify(p)	aston()

extern int astpending;		/* need to trap before returning to user mode */
#define aston() (astpending = 1)

#endif	/* _KERNEL */

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_CPUSPEED		2	/* CPU speed in MHz */
#define	CPU_MACHINEID		3	/* machine id (HP_XXX) */
#define	CPU_MMUID		4	/* mmu id (MMUID_*) */
#define	CPU_MAXID		5	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ "cpuspeed", CTLTYPE_INT }, \
	{ "machineid", CTLTYPE_INT }, \
	{ "mmuid", CTLTYPE_INT }, \
}

/*
 * The rest of this should probably be moved to <machine/hp300spu.h>,
 * although some of it could probably be put into generic 68k headers.
 */

#ifdef _KERNEL
extern	char *intiobase, *intiolimit;
extern	void (*vectab[])(void);

struct frame;
struct fpframe;
struct pcb;

/* locore.s functions */
void	PCIA(void);
__dead void	doboot(void);
void	ecacheon(void);
void	ecacheoff(void);

/* clock.c functions */
void	hp300_calibrate_delay(void);

/* machdep.c functions */
int	badaddr(caddr_t);
int	badbaddr(caddr_t);
void	dumpconf(void);

#endif /* _KERNEL */

/* physical memory sections */
#define	ROMBASE		(0x00000000)
#define	INTIOBASE	(0x00400000)
#define	INTIOTOP	(0x00600000)
#define	MAXADDR		(0xFFFFF000)

/*
 * Internal IO space:
 *
 * Ranges from 0x400000 to 0x600000 (IIOMAPSIZE).
 *
 * Internal IO space is mapped in the kernel from ``intiobase'' to
 * ``intiolimit'' (defined in locore.s).  Since it is always mapped,
 * conversion between physical and kernel virtual addresses is easy.
 */
#define	ISIIOVA(va) \
	((char *)(va) >= intiobase && (char *)(va) < intiolimit)
#define	IIOV(pa)	((int)(pa)-INTIOBASE+(int)intiobase)
#define	IIOP(va)	((int)(va)-(int)intiobase+INTIOBASE)
#define	IIOPOFF(pa)	((int)(pa)-INTIOBASE)
#define	IIOMAPSIZE	atop(INTIOTOP-INTIOBASE)	/* 2mb */

/*
 * HP MMU
 */
#define	MMUBASE		IIOPOFF(0x5F4000)
#define	MMUSSTP		0x0
#define	MMUUSTP		0x4
#define	MMUTBINVAL	0x8
#define	MMUSTAT		0xC
#define	MMUCMD		MMUSTAT

#define	MMU_UMEN	0x0001	/* enable user mapping */
#define	MMU_SMEN	0x0002	/* enable supervisor mapping */
#define	MMU_CEN		0x0004	/* enable data cache */
#define	MMU_BERR	0x0008	/* bus error */
#define	MMU_IEN		0x0020	/* enable instruction cache */
#define	MMU_FPE		0x0040	/* enable 68881 FP coprocessor */
#define	MMU_WPF		0x2000	/* write protect fault */
#define	MMU_PF		0x4000	/* page fault */
#define	MMU_PTF		0x8000	/* page table fault */

#define	MMU_FAULT	(MMU_PTF|MMU_PF|MMU_WPF|MMU_BERR)
#define	MMU_ENAB	(MMU_UMEN|MMU_SMEN|MMU_IEN|MMU_FPE)

#endif /* _MACHINE_CPU_H_ */
@


1.39
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.38 2010/07/24 12:18:58 miod Exp $	*/
@


1.38
log
@One the -> On the
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.37 2009/03/26 17:24:33 oga Exp $	*/
d42 2
a43 2
#ifndef _HP300_CPU_H_
#define	_HP300_CPU_H_
d200 1
a200 1
#endif /* _HP300_CPU_H_ */
@


1.37
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.36 2008/07/18 23:43:31 art Exp $	*/
d63 1
a63 1
 * machine state in an opaque clockframe.  One the hp300, we use
@


1.36
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2007/11/02 19:18:54 martin Exp $	*/
a59 6

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_wait(p)			/* nothing */
@


1.35
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2007/05/30 17:10:42 miod Exp $	*/
d95 1
@


1.34
log
@More cpuinfo vs _KERNEL fallback.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2007/03/15 10:22:29 art Exp $	*/
d180 1
a180 1
#define	IIOMAPSIZE	btoc(INTIOTOP-INTIOBASE)	/* 2mb */
@


1.33
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2006/11/29 12:26:13 miod Exp $	*/
d54 2
d111 2
@


1.32
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2006/06/24 13:20:19 miod Exp $	*/
d99 1
a99 1
#define	need_proftick(p)	{ (p)->p_flag |= P_OWEUPC; aston(); }
@


1.31
log
@Use pmap_kenter_cache() for device memory mapping, instead of physacc(0
which bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2006/06/11 20:48:11 miod Exp $	*/
a62 1
#define	cpu_swapin(p)			/* nothing */
a63 1
#define	cpu_swapout(p)			/* nothing */
@


1.30
log
@Move common prototypes to <m68k/{cpu,param}.h> instead of incomplete
declarations in <machine/{cpu,param}.h> and elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2006/01/02 18:09:23 miod Exp $	*/
a154 4

/* vm_machdep.c functions */
void	physaccess(caddr_t, caddr_t, int, int);
void	physunaccess(caddr_t, int);
@


1.29
log
@Kill enablertclock.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2005/11/17 23:56:46 miod Exp $	*/
d94 1
a94 1
#define	need_resched(ci)	{ want_resched++; aston(); }
d110 1
a110 1
#define aston() (astpending++)
a142 7
void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
void	DCIA(void);
void	DCIS(void);
void	DCIU(void);
void	ICIA(void);
void	ICPA(void);
a143 19
void	TBIA(void);
void	TBIS(vaddr_t);
void	TBIAS(void);
void	TBIAU(void);
#if defined(M68040)
void	DCFA(void);
void	DCFP(paddr_t);
void	DCFL(paddr_t);
void	DCPL(paddr_t);
void	DCPP(paddr_t);
void	ICPL(paddr_t);
void	ICPP(paddr_t);
#endif
int	suline(caddr_t, caddr_t);
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
void	proc_trampoline(void);
void	loadustp(int);

@


1.28
log
@kvtop() is not used anymore. Thanks for the fish.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2005/08/01 11:54:22 miod Exp $	*/
a184 3

/* what is this supposed to do? i.e. how is it different than startrtclock? */
#define	enablertclock()
@


1.27
log
@Factorize cachectl() accross m68k platforms, and make the CC_ constants
public.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2005/01/14 22:39:29 miod Exp $	*/
a184 1
int	kvtop(caddr_t);
@


1.26
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2005/01/08 22:13:54 miod Exp $	*/
a180 3

/* sys_machdep.c functions */
int	cachectl(struct proc *, int, vaddr_t, int);
@


1.25
log
@Only use one set of DIO size and address defines, from <dev/dioreg.h>
rather than <include/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2004/06/13 21:49:13 niklas Exp $	*/
a198 2
#define	EXTIOBASE	(0x00600000)
#define	EXTIOTOP	(0x20000000)
@


1.24
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a217 25

/*
 * External IO space:
 *
 * DIO ranges from select codes 0-63 at physical addresses given by:
 *	0x600000 + (sc - 32) * 0x10000
 * DIO cards are addressed in the range 0-31 [0x600000-0x800000) for
 * their control space and the remaining areas, [0x200000-0x400000) and
 * [0x800000-0x1000000), are for additional space required by a card;
 * e.g. a display framebuffer.
 *
 * DIO-II ranges from select codes 132-255 at physical addresses given by:
 *	0x1000000 + (sc - 132) * 0x400000
 * The address range of DIO-II space is thus [0x1000000-0x20000000).
 *
 * DIO/DIO-II space is too large to map in its entirety, instead devices
 * are mapped into kernel virtual address space allocated from a range
 * of EIOMAPSIZE pages (vmparam.h) starting at ``extiobase''.
 */
#define	DIOBASE		(0x600000)
#define	DIOTOP		(0x1000000)
#define	DIOCSIZE	(0x10000)
#define	DIOIIBASE	(0x01000000)
#define	DIOIITOP	(0x20000000)
#define	DIOIICSIZE	(0x00400000)
@


1.23
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2003/06/02 23:27:45 millert Exp $	*/
d94 1
a94 1
#define	need_resched()	{ want_resched++; aston(); }
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2003/02/11 19:20:26 mickey Exp $	*/
d183 1
a183 1
int	cachectl(int, vaddr_t, int);
@


1.21
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2002/06/07 21:33:43 nordin Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@Remove obsolete CLKF_BASEPRI(). ok niklas@@, miod@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2002/03/14 01:26:31 millert Exp $	*/
d120 1
a120 1
#define	CPU_CPUSPEED		2	/* CPU speed in Mhz */
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2002/01/10 21:10:46 miod Exp $	*/
a82 1
#define	CLKF_BASEPRI(framep)	(((framep)->sr & PSL_IPL) == 0)
@


1.18
log
@Switch m68k arches that do not exist in 68060 models back to pmap_motorola.
Others will be switched after more 060 tests.

This time: hp300
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2001/12/20 19:02:27 miod Exp $	*/
d141 1
a141 1
extern	void (*vectab[]) __P((void));
d148 12
a159 12
void	m68881_save __P((struct fpframe *));
void	m68881_restore __P((struct fpframe *));
void	DCIA __P((void));
void	DCIS __P((void));
void	DCIU __P((void));
void	ICIA __P((void));
void	ICPA __P((void));
void	PCIA __P((void));
void	TBIA __P((void));
void	TBIS __P((vaddr_t));
void	TBIAS __P((void));
void	TBIAU __P((void));
d161 7
a167 7
void	DCFA __P((void));
void	DCFP __P((paddr_t));
void	DCFL __P((paddr_t));
void	DCPL __P((paddr_t));
void	DCPP __P((paddr_t));
void	ICPL __P((paddr_t));
void	ICPP __P((paddr_t));
d169 9
a177 9
int	suline __P((caddr_t, caddr_t));
void	savectx __P((struct pcb *));
void	switch_exit __P((struct proc *));
void	proc_trampoline __P((void));
void	loadustp __P((int));

__dead void	doboot __P((void));
void	ecacheon __P((void));
void	ecacheoff __P((void));
d180 1
a180 1
void	hp300_calibrate_delay __P((void));
d183 3
a185 3
int	badaddr __P((caddr_t));
int	badbaddr __P((caddr_t));
void	dumpconf __P((void));
d188 1
a188 1
int	cachectl __P((int, vaddr_t, int));
d191 3
a193 3
void	physaccess __P((caddr_t, caddr_t, int, int));
void	physunaccess __P((caddr_t, int));
int	kvtop __P((caddr_t));
@


1.17
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2001/11/30 20:58:18 miod Exp $	*/
a185 3

/* pmap.c functions */
vaddr_t pmap_map __P((vaddr_t, paddr_t, paddr_t, int));
@


1.16
log
@Switch to pmap_motorola.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2001/08/25 11:37:26 espie Exp $	*/
d186 3
@


1.16.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2002/01/10 21:10:46 miod Exp $	*/
@


1.16.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16.2.1 2002/01/31 22:55:08 niklas Exp $	*/
d83 1
d141 1
a141 1
extern	void (*vectab[])(void);
d148 12
a159 12
void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
void	DCIA(void);
void	DCIS(void);
void	DCIU(void);
void	ICIA(void);
void	ICPA(void);
void	PCIA(void);
void	TBIA(void);
void	TBIS(vaddr_t);
void	TBIAS(void);
void	TBIAU(void);
d161 7
a167 7
void	DCFA(void);
void	DCFP(paddr_t);
void	DCFL(paddr_t);
void	DCPL(paddr_t);
void	DCPP(paddr_t);
void	ICPL(paddr_t);
void	ICPP(paddr_t);
d169 9
a177 9
int	suline(caddr_t, caddr_t);
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
void	proc_trampoline(void);
void	loadustp(int);

__dead void	doboot(void);
void	ecacheon(void);
void	ecacheoff(void);
d180 1
a180 1
void	hp300_calibrate_delay(void);
d183 3
a185 3
int	badaddr(caddr_t);
int	badbaddr(caddr_t);
void	dumpconf(void);
d188 1
a188 1
int	cachectl(int, vaddr_t, int);
d191 3
a193 3
void	physaccess(caddr_t, caddr_t, int, int);
void	physunaccess(caddr_t, int);
int	kvtop(caddr_t);
@


1.16.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 1
a120 1
#define	CPU_CPUSPEED		2	/* CPU speed in MHz */
@


1.15
log
@One regdump to dump them all...

(moid@@ wants that commit, because it interferes with stuff he's cleaning,
and he's prepared to clean up stuff I may have forgotten, even though this
was tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2001/08/20 19:49:03 miod Exp $	*/
a185 3

/* pmap.c functions */
vaddr_t pmap_map __P((vaddr_t, paddr_t, paddr_t, int));
@


1.14
log
@Bring get[sd]fc() prototypes to <m68k/cpu.h>, this will be needed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2001/08/08 02:37:40 millert Exp $	*/
a184 1
void	regdump __P((struct frame *, int));
@


1.13
log
@__dead not __noreturn__
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2001/05/25 22:07:17 millert Exp $	*/
a149 2
u_long	getdfc __P((void));
u_long	getsfc __P((void));
@


1.12
log
@Add 3 sysctl machdep variables: cpuspeed, machineid, and mmuid.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2001/05/11 23:24:57 millert Exp $	*/
d177 1
a177 2
void	doboot __P((void))
	__attribute__((__noreturn__));
@


1.11
log
@Kill remaining vm_offset_t and vm_size_t; NetBSD used as a guide
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2001/05/04 22:49:00 aaron Exp $	*/
d121 4
a124 1
#define	CPU_MAXID		2	/* number of valid machdep ids */
d129 3
@


1.10
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 1998/03/01 00:37:31 niklas Exp $	*/
d153 1
a153 1
void	TBIS __P((vm_offset_t));
d158 6
a163 6
void	DCFP __P((vm_offset_t));
void	DCFL __P((vm_offset_t));
void	DCPL __P((vm_offset_t));
void	DCPP __P((vm_offset_t));
void	ICPL __P((vm_offset_t));
void	ICPP __P((vm_offset_t));
d186 1
a186 1
vm_offset_t pmap_map __P((vm_offset_t, vm_offset_t, vm_offset_t, int));
d189 1
a189 1
int	cachectl __P((int, caddr_t, int));
@


1.9
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 2
a2 2
/*	$OpenBSD: cpu.h,v 1.8 1997/07/06 08:02:11 downsj Exp $	*/
/*	$NetBSD: cpu.h,v 1.25 1997/04/27 20:37:07 thorpej Exp $	*/
d98 1
d114 1
a116 3
int	astpending;		/* need to trap before returning to user mode */
int	want_resched;		/* resched() was called */

d175 3
@


1.9.10.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: cpu.h,v 1.28 1998/02/13 07:41:51 scottr Exp $	*/
a97 1
extern int want_resched;	/* resched() was called */
a112 1
extern int astpending;		/* need to trap before returning to user mode */
d115 3
d122 1
a122 4
#define	CPU_CPUSPEED		2	/* CPU speed in Mhz */
#define	CPU_MACHINEID		3	/* machine id (HP_XXX) */
#define	CPU_MMUID		4	/* mmu id (MMUID_*) */
#define	CPU_MAXID		5	/* number of valid machdep ids */
a126 3
	{ "cpuspeed", CTLTYPE_INT }, \
	{ "machineid", CTLTYPE_INT }, \
	{ "mmuid", CTLTYPE_INT }, \
d154 1
a154 1
void	TBIS __P((vaddr_t));
d159 6
a164 6
void	DCFP __P((paddr_t));
void	DCFL __P((paddr_t));
void	DCPL __P((paddr_t));
void	DCPP __P((paddr_t));
void	ICPL __P((paddr_t));
void	ICPP __P((paddr_t));
a176 3
/* clock.c functions */
void	hp300_calibrate_delay __P((void));

d184 1
a184 1
vaddr_t pmap_map __P((vaddr_t, paddr_t, paddr_t, int));
d187 1
a187 1
int	cachectl __P((int, vaddr_t, int));
@


1.9.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9.10.1 2001/07/04 10:15:52 niklas Exp $	*/
d150 2
d177 2
a178 1
__dead void	doboot __P((void));
d188 1
@


1.9.10.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9.10.2 2001/10/31 02:52:46 nate Exp $	*/
d186 3
@


1.9.10.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 1
a141 1
extern	void (*vectab[])(void);
d148 12
a159 12
void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
void	DCIA(void);
void	DCIS(void);
void	DCIU(void);
void	ICIA(void);
void	ICPA(void);
void	PCIA(void);
void	TBIA(void);
void	TBIS(vaddr_t);
void	TBIAS(void);
void	TBIAU(void);
d161 7
a167 7
void	DCFA(void);
void	DCFP(paddr_t);
void	DCFL(paddr_t);
void	DCPL(paddr_t);
void	DCPP(paddr_t);
void	ICPL(paddr_t);
void	ICPP(paddr_t);
d169 9
a177 9
int	suline(caddr_t, caddr_t);
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
void	proc_trampoline(void);
void	loadustp(int);

__dead void	doboot(void);
void	ecacheon(void);
void	ecacheoff(void);
d180 1
a180 1
void	hp300_calibrate_delay(void);
d183 3
a185 3
int	badaddr(caddr_t);
int	badbaddr(caddr_t);
void	dumpconf(void);
d188 1
a188 1
int	cachectl(int, vaddr_t, int);
d191 3
a193 3
void	physaccess(caddr_t, caddr_t, int, int);
void	physunaccess(caddr_t, int);
int	kvtop(caddr_t);
@


1.9.10.5
log
@Sync the SMP branch with 3.3
@
text
@d83 1
d121 1
a121 1
#define	CPU_CPUSPEED		2	/* CPU speed in MHz */
@


1.9.10.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9.10.5 2003/03/27 23:19:21 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.10.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d183 1
a183 1
int	cachectl(struct proc *, int, vaddr_t, int);
@


1.9.10.8
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9.10.7 2004/06/05 23:10:46 niklas Exp $	*/
d94 1
a94 1
#define	need_resched(ci)	{ want_resched++; aston(); }
@


1.8
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 1997/04/17 10:28:40 downsj Exp $	*/
d183 3
d197 1
a197 1
#endif
@


1.7
log
@Better machine type identification from Mike Smith
(<miff@@spam.frisbee.net.au>).
@
text
@d1 2
a2 2
/*	$OpenBSD: cpu.h,v 1.6 1997/04/16 11:56:34 downsj Exp $	*/
/*	$NetBSD: cpu.h,v 1.24 1997/04/14 02:28:50 thorpej Exp $	*/
a128 23
#ifdef _KERNEL
/*
 * Associate HP 9000/300 models with CPU/MMU combinations.
 */

/*
 * HP 68020-based computers.  HP320 and HP350 have an HP MMU.
 * HP330 has a Motorola MMU.
 */
#if (defined(HP320) || defined(HP330) || defined(HP350))
#ifndef M68020
#define	M68020
#endif /* ! M68020 */

#if defined(HP330) && !defined(M68K_MMU_MOTOROLA)
#define	M68K_MMU_MOTOROLA
#endif /* HP330 && ! M68K_MMU_MOTOROLA */

#if (defined(HP320) || defined(HP350)) && !defined(M68K_MMU_HP)
#define M68K_MMU_HP		/* include cheezy VAC support */
#endif /* (HP320 || HP350) && ! M68K_MMU_HP */
#endif /* HP320 || HP330 || HP350 */

d130 1
a130 30
 * HP 68030-based computers.  HP375 includes support for the
 * 345, 400t, and 400s.
 */
#if (defined(HP340) || defined(HP360) || defined(HP370) || defined(HP375))
#ifndef M68030
#define	M68030
#endif /* ! M68030 */

#ifndef M68K_MMU_MOTOROLA
#define	M68K_MMU_MOTOROLA
#endif /* ! M68K_MMU_MOTOROLA */
#endif /* HP340 || HP360 || HP370 || HP375 */

/*
 * HP 68040-based computers.  HP380 includes support for the
 * 425t, 425s, and 433s.
 */
#if defined(HP380)
#ifndef M68040
#define	M68040
#endif /* ! M68040 */

#ifndef M68K_MMU_MOTOROLA
#define	M68K_MMU_MOTOROLA
#endif /* ! M68K_MMU_MOTOROLA */
#endif /* HP380 */
#endif /* _KERNEL */

/*
 * The rest of this should probably be moved to ../hp300/hp300cpu.h,
a133 12
/* values for machineid */
#define	HP_320		0	/* 16Mhz 68020+HP MMU+16K external cache */
#define	HP_330		1	/* 16Mhz 68020+68851 MMU */
#define	HP_350		2	/* 25Mhz 68020+HP MMU+32K external cache */
#define	HP_360		3	/* 25Mhz 68030 */
#define	HP_370		4	/* 33Mhz 68030+64K external cache */
#define	HP_340		5	/* 16Mhz 68030 */
#define	HP_375		6	/* 50Mhz 68030+32K external cache */
#define	HP_380		7	/* 25Mhz 68040 */
#define HP_425		8	/* 25/33Mhz 68040 */
#define HP_433		9	/* 33Mhz 68040 (maybe also 25MHz?) */

a134 4
extern	int machineid;		/* CPU model */
extern	int mmuid;		/* MMU model */
extern	int cpuspeed;		/* CPU speed, in MHz */

@


1.6
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 1997/01/12 15:13:33 downsj Exp $	*/
d195 2
a196 1
#define HP_433		8	/* 33Mhz 68040 */
d200 1
@


1.5
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: cpu.h,v 1.21 1996/10/07 06:29:30 thorpej Exp $	*/
d59 5
a117 13

/*
 * simulated software interrupt register
 */
extern unsigned char ssir;

#define SIR_NET		0x1
#define SIR_CLOCK	0x2

#define siroff(x)	ssir &= ~(x)
#define setsoftnet()	ssir |= SIR_NET
#define setsoftclock()	ssir |= SIR_CLOCK

d204 3
a206 1
struct	frame;
d209 29
d247 9
@


1.4
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: cpu.h,v 1.19 1996/05/17 15:37:07 thorpej Exp $	*/
d54 5
a204 11
/* values for mmutype (assigned for quick testing) */
#define	MMU_68040	-2	/* 68040 on-chip MMU */
#define	MMU_68030	-1	/* 68030 on-chip subset of 68851 */
#define	MMU_HP		0	/* HP proprietary */
#define	MMU_68851	1	/* Motorola 68851 */

/* values for ectype */
#define	EC_PHYS		-1	/* external physical address cache */
#define	EC_NONE		0	/* no external cache */
#define	EC_VIRT		1	/* external virtual address cache */

a206 2
extern	int mmutype;		/* MMU on this host */
extern	int ectype;		/* External cache type */
d212 3
d217 7
a300 62

/*
 * 68851 and 68030 MMU
 */
#define	PMMU_LVLMASK	0x0007
#define	PMMU_INV	0x0400
#define	PMMU_WP		0x0800
#define	PMMU_ALV	0x1000
#define	PMMU_SO		0x2000
#define	PMMU_LV		0x4000
#define	PMMU_BE		0x8000
#define	PMMU_FAULT	(PMMU_WP|PMMU_INV)

/*
 * 68040 MMU
 */
#define	MMU4_RES	0x001
#define	MMU4_TTR	0x002
#define	MMU4_WP		0x004
#define	MMU4_MOD	0x010
#define	MMU4_CMMASK	0x060
#define	MMU4_SUP	0x080
#define	MMU4_U0		0x100
#define	MMU4_U1		0x200
#define	MMU4_GLB	0x400
#define	MMU4_BE		0x800

/* 680X0 function codes */
#define	FC_USERD	1	/* user data space */
#define	FC_USERP	2	/* user program space */
#define	FC_PURGE	3	/* HPMMU: clear TLB entries */
#define	FC_SUPERD	5	/* supervisor data space */
#define	FC_SUPERP	6	/* supervisor program space */
#define	FC_CPU		7	/* CPU space */

/* fields in the 68020 cache control register */
#define	IC_ENABLE	0x0001	/* enable instruction cache */
#define	IC_FREEZE	0x0002	/* freeze instruction cache */
#define	IC_CE		0x0004	/* clear instruction cache entry */
#define	IC_CLR		0x0008	/* clear entire instruction cache */

/* additional fields in the 68030 cache control register */
#define	IC_BE		0x0010	/* instruction burst enable */
#define	DC_ENABLE	0x0100	/* data cache enable */
#define	DC_FREEZE	0x0200	/* data cache freeze */
#define	DC_CE		0x0400	/* clear data cache entry */
#define	DC_CLR		0x0800	/* clear entire data cache */
#define	DC_BE		0x1000	/* data burst enable */
#define	DC_WA		0x2000	/* write allocate */

#define	CACHE_ON	(DC_WA|DC_BE|DC_CLR|DC_ENABLE|IC_BE|IC_CLR|IC_ENABLE)
#define	CACHE_OFF	(DC_CLR|IC_CLR)
#define	CACHE_CLR	(CACHE_ON)
#define	IC_CLEAR	(DC_WA|DC_BE|DC_ENABLE|IC_BE|IC_CLR|IC_ENABLE)
#define	DC_CLEAR	(DC_WA|DC_BE|DC_CLR|DC_ENABLE|IC_BE|IC_ENABLE)

/* 68040 cache control register */
#define	IC4_ENABLE	0x8000		/* instruction cache enable bit */
#define	DC4_ENABLE	0x80000000	/* data cache enable bit */

#define	CACHE4_ON	(IC4_ENABLE|DC4_ENABLE)
#define	CACHE4_OFF	(0)
@


1.3
log
@from netbsd; cpu_setstack() is depricated
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.16 1995/12/21 05:01:57 mycroft Exp $	*/
d210 5
a214 6
/* values for cpuspeed (not really related to clock speed due to caches) */
#define	MHZ_8		1
#define	MHZ_16		2
#define	MHZ_25		3
#define	MHZ_33		4
#define	MHZ_50		6
a215 2
#ifdef _KERNEL
extern	int machineid, mmutype, ectype;
d217 4
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.15 1995/12/11 17:09:22 thorpej Exp $	*/
a57 1
#define cpu_setstack(p, ap)		(p)->p_md.md_regs[SP] = ap
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.14 1995/06/28 02:55:45 cgd Exp $	*/
d45 3
d132 52
d360 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

