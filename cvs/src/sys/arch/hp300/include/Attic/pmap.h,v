head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.34
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.30
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.28
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.26
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.24
	OPENBSD_5_0:1.16.0.22
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.20
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.18
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.14
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.16
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.12
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.10
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.8
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.18
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.16
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.14
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.12
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.12
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2006.08.22.21.03.54;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.09.19.41.23;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.10.21.10.47;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.20.19.02.27;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.30.20.58.18;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.22.05.32;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.18.20.50.18;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.11.23.24.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.04.22.49.00;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	97.07.06.08.02.13;	author downsj;	state Exp;
branches
	1.5.12.1;
next	1.4;

1.4
date	97.03.26.08.32.46;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.01.12.15.13.39;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.29.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.25;	author deraadt;	state Exp;
branches;
next	;

1.5.12.1
date	2001.07.04.10.15.53;	author niklas;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.5.12.3;

1.5.12.3
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.5.12.4;

1.5.12.4
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.01.31.22.55.08;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: pmap.h,v 1.16 2006/08/22 21:03:54 miod Exp $	*/

#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_

#include <m68k/pmap_motorola.h>

#if !defined(M68020)
#define	pmap_map_direct(pg)	((vaddr_t)VM_PAGE_TO_PHYS(pg))
#define	pmap_unmap_direct(va)	PHYS_TO_VM_PAGE((paddr_t)va)
#define	__HAVE_PMAP_DIRECT
#define	PMAP_STEAL_MEMORY
#endif

#ifdef	_KERNEL
void pmap_init_md(void);
#define	PMAP_INIT_MD()	pmap_init_md()
#endif

#endif	/* _MACHINE_PMAP_H_ */
@


1.16
log
@Implement pmap_steal_memory() if HAVE_PMAP_DIRECT; no change except for
faster uvm initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.15 2006/07/09 19:41:23 miod Exp $	*/
@


1.15
log
@If running on a 68030 or 68040 system, use the transparent translation
registers to program an 1GB untranslated window over the physical memory,
and use it to define __HAVE_PMAP_DIRECT for faster pool operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.14 2002/03/14 01:26:31 millert Exp $	*/
d12 1
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.13 2002/01/10 21:10:47 miod Exp $	*/
d7 6
@


1.13
log
@Switch m68k arches that do not exist in 68060 models back to pmap_motorola.
Others will be switched after more 060 tests.

This time: hp300
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.12 2001/12/20 19:02:27 miod Exp $	*/
d9 1
a9 1
void pmap_init_md __P((void));
@


1.12
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d1 1
a1 2
/*	$OpenBSD: pmap.h,v 1.11 2001/11/30 20:58:18 miod Exp $	*/
/*	$NetBSD: pmap.h,v 1.13 1997/06/10 18:58:19 veego Exp $	*/
d3 2
a4 39
/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	8.1 (Berkeley) 6/10/93
 */
d6 1
a6 2
#ifndef	_HP300_PMAP_H_
#define	_HP300_PMAP_H_
d8 3
a10 113
#include <machine/cpu.h>
#include <machine/pte.h>

#if defined(M68040)
#define HP_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
#else
#define HP_SEG_SIZE	NBSEG
#endif

#define hp300_trunc_seg(x)	(((unsigned)(x)) & ~(HP_SEG_SIZE-1))
#define hp300_round_seg(x)	hp300_trunc_seg((unsigned)(x) + HP_SEG_SIZE-1)

/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stchanged;	/* ST changed */
	int			pm_stfree;	/* 040: free lev2 blocks */
	st_entry_t		*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	long			pm_ptpages;	/* more stats: PT pages */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  8 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	8
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define PMAP_ACTIVATE(pmap, loadhw)					\
{									\
        if ((loadhw))							\
                loadustp(m68k_btop((paddr_t)(pmap)->pm_stpa));		\
}
#define PMAP_DEACTIVATE(pmapp, pcbp)

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry, the list is pv_table.
 */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
};

#define	PV_CI		0x01	/* header: all entries are cache inhibited */
#define PV_PTPAGE	0x02	/* header: entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	170

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};

extern struct pmap	kernel_pmap_store;

#define pmap_kernel()	(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define	active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

extern struct pv_entry	*pv_table;	/* array of entries, one per page */

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)

#define	pmap_update(pmap)		/* empty */

extern pt_entry_t	*Sysmap;
extern char		*vmmap;		/* map for mem, dumps, etc. */

#ifdef M68K_MMU_HP
void	pmap_prefer __P((vaddr_t, vaddr_t *));
#define	PMAP_PREFER(foff, vap)	pmap_prefer((foff), (vap))
d13 1
a13 1
#endif /* !_HP300_PMAP_H_ */
@


1.11
log
@Switch to pmap_motorola.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 39
a42 2
#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_
d44 2
a45 1
#include <m68k/pmap_motorola.h>
d47 113
a159 3
#ifdef	_KERNEL
void pmap_init_md __P((void));
#define	PMAP_INIT_MD()	pmap_init_md()
d162 1
a162 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.11.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.13 2002/01/10 21:10:47 miod Exp $	*/
@


1.11.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.11.2.1 2002/01/31 22:55:08 niklas Exp $	*/
d9 1
a9 1
void pmap_init_md(void);
@


1.10
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 2
/*	$OpenBSD: pmap.h,v 1.9 2001/11/27 22:05:32 miod Exp $	*/
/*	$NetBSD: pmap.h,v 1.13 1997/06/10 18:58:19 veego Exp $	*/
d3 2
a4 39
/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	8.1 (Berkeley) 6/10/93
 */
d6 1
a6 2
#ifndef	_HP300_PMAP_H_
#define	_HP300_PMAP_H_
d8 3
a10 113
#include <machine/cpu.h>
#include <machine/pte.h>

#if defined(M68040)
#define HP_SEG_SIZE	(mmutype == MMU_68040 ? 0x40000 : NBSEG)
#else
#define HP_SEG_SIZE	NBSEG
#endif

#define hp300_trunc_seg(x)	(((unsigned)(x)) & ~(HP_SEG_SIZE-1))
#define hp300_round_seg(x)	hp300_trunc_seg((unsigned)(x) + HP_SEG_SIZE-1)

/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stchanged;	/* ST changed */
	int			pm_stfree;	/* 040: free lev2 blocks */
	st_entry_t		*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	long			pm_ptpages;	/* more stats: PT pages */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  8 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	8
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define PMAP_ACTIVATE(pmap, loadhw)					\
{									\
        if ((loadhw))							\
                loadustp(m68k_btop((paddr_t)(pmap)->pm_stpa));		\
}
#define PMAP_DEACTIVATE(pmapp, pcbp)

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry, the list is pv_table.
 */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
};

#define	PV_CI		0x01	/* header: all entries are cache inhibited */
#define PV_PTPAGE	0x02	/* header: entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	170

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};

extern struct pmap	kernel_pmap_store;

#define pmap_kernel()	(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define	active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

extern struct pv_entry	*pv_table;	/* array of entries, one per page */

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)

#define	pmap_update()		/* empty */

extern pt_entry_t	*Sysmap;
extern char		*vmmap;		/* map for mem, dumps, etc. */

#ifdef M68K_MMU_HP
void	pmap_prefer __P((vaddr_t, vaddr_t *));
#define	PMAP_PREFER(foff, vap)	pmap_prefer((foff), (vap))
d13 1
a13 1
#endif /* !_HP300_PMAP_H_ */
@


1.9
log
@Various pmap_k* optimizations, as well as uvm interface updates,
from NetBSD.
Soon to be found in other m68k pmap, this one is just a teaser to please art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.8 2001/08/18 20:50:18 art Exp $	*/
d70 1
a70 1
	simple_lock_data_t	pm_lock;	/* lock on pmap */
@


1.8
log
@Move pmap_{de,}activate to vm/pmap.h, it's same on all archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.7 2001/05/11 23:24:57 millert Exp $	*/
d151 2
@


1.7
log
@Kill remaining vm_offset_t and vm_size_t; NetBSD used as a guide
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2001/05/04 22:49:00 aaron Exp $	*/
a150 4

struct proc;
void	pmap_activate __P((struct proc *));
void	pmap_deactivate __P((struct proc *));
@


1.6
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 1997/07/06 08:02:13 downsj Exp $	*/
d110 1
a110 1
	vm_offset_t	pv_va;		/* virtual address for mapping */
@


1.5
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 1997/03/26 08:32:46 downsj Exp $	*/
d96 5
a100 7
#define PMAP_ACTIVATE(pmapp, pcbp, iscurproc) \
	if ((pmapp)->pm_stchanged) { \
		(pcbp)->pcb_ustp = m68k_btop((vm_offset_t)(pmapp)->pm_stpa); \
		if (iscurproc) \
			loadustp((pcbp)->pcb_ustp); \
		(pmapp)->pm_stchanged = FALSE; \
	}
a148 3
#define pmap_page_index(pa)		atop(pa - vm_first_phys)
#define pa_to_pvh(pa)			(&pv_table[pmap_page_index(pa)])

d152 4
d158 5
@


1.5.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 1997/07/06 08:02:13 downsj Exp $	*/
d96 7
a102 5
#define PMAP_ACTIVATE(pmap, loadhw)					\
{									\
        if ((loadhw))							\
                loadustp(m68k_btop((paddr_t)(pmap)->pm_stpa));		\
}
d112 1
a112 1
	vaddr_t		pv_va;		/* virtual address for mapping */
d151 3
a156 4
struct proc;
void	pmap_activate __P((struct proc *));
void	pmap_deactivate __P((struct proc *));

a158 5

#ifdef M68K_MMU_HP
void	pmap_prefer __P((vaddr_t, vaddr_t *));
#define	PMAP_PREFER(foff, vap)	pmap_prefer((foff), (vap))
#endif
@


1.5.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5.12.1 2001/07/04 10:15:53 niklas Exp $	*/
d151 4
@


1.5.12.3
log
@Merge in -current
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 39
a42 2
#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_
d44 2
a45 1
#include <m68k/pmap_motorola.h>
d47 111
a157 3
#ifdef	_KERNEL
void pmap_init_md __P((void));
#define	PMAP_INIT_MD()	pmap_init_md()
d160 1
a160 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.5.12.4
log
@Merge in -current from about a week ago
@
text
@d9 1
a9 1
void pmap_init_md(void);
@


1.4
log
@Merge changes from NetBSD, up to 3/19/97; undoes some local changes.
Changed to match new arch/m68k code.
genassym.cf is currently just a place holder.
@
text
@d1 2
a2 2
/*	$OpenBSD: pmap.h,v 1.3 1997/01/12 15:13:39 downsj Exp $	*/
/*	$NetBSD: pmap.h,v 1.12 1997/03/18 16:39:30 mycroft Exp $	*/
d98 1
a98 1
		(pcbp)->pcb_ustp = hp300_btop((vm_offset_t)(pmapp)->pm_stpa); \
@


1.3
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pmap.h,v 1.10 1995/12/11 17:09:23 thorpej Exp $	*/
d145 3
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pmap.h,v 1.9 1995/05/11 16:53:03 jtc Exp $	*/
d46 1
d49 1
a49 1
#if defined(HP380)
a138 5
#ifdef	_KERNEL
#if defined(HP320) || defined(HP350)
#define	HAVEVAC				/* include cheezy VAC support */
#endif

a154 1
#endif /* _KERNEL */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
