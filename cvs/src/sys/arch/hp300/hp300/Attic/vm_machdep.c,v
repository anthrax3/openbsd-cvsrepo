head	1.47;
access;
symbols
	OPENBSD_5_5:1.46.0.8
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.4
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.45.0.20
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.18
	OPENBSD_5_0:1.45.0.16
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.14
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.12
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.8
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.10
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.6
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.4
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.41.0.4
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.37.0.4
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.35.0.6
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.4
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.34
	OPENBSD_3_3:1.34.0.8
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.34.0.6
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.34.0.4
	OPENBSD_3_1_BASE:1.34
	UBC_SYNC_B:1.34
	UBC:1.34.0.2
	UBC_BASE:1.34
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.14.0.6
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.46;

1.46
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.13.07.17.59;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.13.19.38.19;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.24.13.20.17;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2006.06.23.13.46.05;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.17.23.56.44;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.25.22.26.10;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.15.21.13.09;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.28.14.04.22;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.06.18.52.38;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.21.02.11.57;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.25.13.25.31;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.18.10.47.04;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.27.04.05.45;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.10.01.44.43;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.08.13.32.55;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.08.08.08.46;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.28.21.08.36;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.15.02.00.09;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.11.23.24.57;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.06.21.39.00;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.06.00.45.48;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.05.20.56.35;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.04.22.48.59;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.08.22.25.18;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.05.11.02.57;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.09.03.18.00.44;	author art;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.08.17.10.32.16;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.01.10.13.34.17;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.07.28.00.13.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.06.08.02.10;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.04.16.11.56.32;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.03.26.08.32.45;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.02.10.11.13.34;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.12.15.13.29;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.11.47.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.04.21.27.34;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.37.09;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.29.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.24;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.04.18.16.05.42;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.07.04.10.15.49;	author niklas;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.14.4.6;

1.14.4.6
date	2003.06.07.11.11.35;	author ho;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.46 2013/01/16 19:04:43 miod Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.60 2001/07/06 05:53:35 chs Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: vm_machdep.c 1.21 91/04/06$
 *
 *	@@(#)vm_machdep.c	8.6 (Berkeley) 1/12/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/core.h>
#include <sys/exec.h>
#include <sys/ptrace.h>

#include <machine/frame.h>
#include <machine/cpu.h>
#include <machine/pte.h>
#include <machine/reg.h>

#include <uvm/uvm_extern.h>

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the pcb and trap frame, making the child ready to run.
 *
 * Rig the child's kernel stack so that it will start out in
 * proc_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
 *
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path and argument are specified with
 * `func' and `arg'.
 *
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
 * accordingly.
 */
void
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
{
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;
	extern struct pcb *curpcb;

	p2->p_md.md_flags = p1->p_md.md_flags;

	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
	*pcb = p1->p_addr->u_pcb;

	/*
	 * Copy the trap frame.
	 */
	tf = (struct trapframe *)((u_int)p2->p_addr + USPACE) - 1;
	p2->p_md.md_regs = (int *)tf;
	*tf = *(struct trapframe *)p1->p_md.md_regs;

	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL)
		tf->tf_regs[15] = (u_int)stack + stacksize;

	sf = (struct switchframe *)tf - 1;
	sf->sf_pc = (u_int)proc_trampoline;
	pcb->pcb_regs[6] = (int)func;		/* A2 */
	pcb->pcb_regs[7] = (int)arg;		/* A3 */
	pcb->pcb_regs[11] = (int)sf;		/* SSP */
	pcb->pcb_ps = PSL_LOWIPL;		/* start kthreads at IPL 0 */
}

/*
 * cpu_exit is called as the last action during exit.
 *
 * Call switch_exit() which will switch to another process thus we never return.
 */
void
cpu_exit(p)
	struct proc *p;
{
	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Dump the machine specific header information at the start of a core dump.
 */
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	struct md_core md_core;
	struct coreseg cseg;
	int error;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

	if (fputype) {
		/* Save floating point registers. */
		error = process_read_fpregs(p, &md_core.freg);
		if (error)
			return error;
	} else {
		/* Make sure these are clear. */
		bzero((caddr_t)&md_core.freg, sizeof(md_core.freg));
	}

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
}

/*
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().
 */
void
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	struct pmap *upmap, *kpmap;
	vaddr_t uva;		/* User VA (map from) */
	vaddr_t kva;		/* Kernel VA (new to) */
	paddr_t pa; 		/* physical address */
	vsize_t off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");

	uva = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - uva;
	len = round_page(off + len);
	kva = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(kva + off);

	upmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	kpmap = vm_map_pmap(phys_map);
	do {
		if (pmap_extract(upmap, uva, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
		uva += PAGE_SIZE;
		kva += PAGE_SIZE;
		len -= PAGE_SIZE;
	} while (len);
	pmap_update(pmap_kernel());
}

/*
 * Unmap a previously-mapped user I/O request.
 */
void
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	vaddr_t kva;
	vsize_t off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");

	kva = trunc_page((vaddr_t)(bp->b_data));
	off = (vaddr_t)bp->b_data - kva;
	len = round_page(off + len);

	pmap_remove(vm_map_pmap(phys_map), kva, kva + len);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, kva, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}
@


1.46
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.45 2007/10/13 07:17:59 miod Exp $	*/
@


1.45
log
@Do not splhigh() before invoking sched_exit(), sched_exit() will do it better.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.44 2007/10/10 15:53:51 art Exp $	*/
d182 1
a182 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
	    NULL, p);
d188 1
a188 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.44
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.43 2007/05/27 20:59:25 miod Exp $	*/
d129 1
a129 2
 * Block context switches and then call switch_exit() which will
 * switch to another process thus we never return.
a134 2
	(void)splhigh();

@


1.43
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.42 2007/03/13 19:38:19 miod Exp $	*/
d136 1
d138 2
a139 3
	(void) splhigh();
	switch_exit(p);
	/* NOTREACHED */
@


1.42
log
@Reset psl to spl0 in cpu_fork(), so that kthreads start at spl0 and not
splhigh(); from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.41 2006/06/24 13:20:17 miod Exp $	*/
a197 34
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of PAGE_SIZE.
 */
void
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
{
	paddr_t pa;
	boolean_t rv;

#ifdef DEBUG
	if ((size & PAGE_MASK) != 0)
		panic("pagemove");
#endif
	while (size > 0) {
		rv = pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
#ifdef DEBUG
		if (rv == FALSE)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vaddr_t)to, NULL) == TRUE)
			panic("pagemove 3");
#endif
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ | VM_PROT_WRITE);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
@


1.41
log
@Use pmap_kenter_cache() for device memory mapping, instead of physacc(0
which bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.40 2006/06/23 13:46:05 mickey Exp $	*/
d123 1
@


1.40
log
@consistantly count context switches on exit; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.39 2005/11/17 23:56:44 miod Exp $	*/
a230 35
}

/*
 * Map `size' bytes of physical memory starting at `paddr' into
 * kernel VA space at `vaddr'.  Read/write and cache-inhibit status
 * are specified by `prot'.
 */
void
physaccess(vaddr, paddr, size, prot)
	caddr_t vaddr, paddr;
	int size, prot;
{
	pt_entry_t *pte;
	u_int page;

	pte = kvtopte(vaddr);
	page = (u_int)paddr & PG_FRAME;
	for (size = btoc(size); size; size--) {
		*pte++ = PG_V | prot | page;
		page += NBPG;
	}
	TBIAS();
}

void
physunaccess(vaddr, size)
	caddr_t vaddr;
	int size;
{
	pt_entry_t *pte;

	pte = kvtopte(vaddr);
	for (size = btoc(size); size; size--)
		*pte++ = PG_NV;
	TBIAS();
@


1.39
log
@kvtop() is not used anymore. Thanks for the fish.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.38 2005/09/25 22:26:10 miod Exp $	*/
a136 1
	uvmexp.swtch++;
@


1.38
log
@Define the symbolic register indexes in trapframe in <m68k/reg.h> only
#ifdef _KERNEL; also remove duplicate prototypes with <sys/ptrace.h>.
Helped by martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.37 2005/01/15 21:13:09 miod Exp $	*/
a266 14
}

/*
 * Convert kernel VA to physical address
 */
int
kvtop(addr)
	caddr_t addr;
{
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa) == FALSE)
		panic("kvtop: zero page frame");
	return((int)pa);
@


1.37
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.36 2004/11/28 14:04:22 miod Exp $	*/
d52 1
@


1.36
log
@Correct pmap_enter() flags usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.35 2003/06/02 23:27:45 millert Exp $	*/
d63 1
a63 1
 * 
d237 1
a237 1
 */ 
d285 1
a285 1
 * do not need to pass an access_type to pmap_enter().   
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2001/12/06 18:52:38 millert Exp $	*/
d313 1
a313 1
		    PMAP_WIRED);
@


1.34
log
@Sync with NetBSD:
 o Add missing pmap_remove() before uvm_km_free_wakeup()
 o sprinkle pmap_update
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2001/11/06 19:53:14 miod Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.33
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.32 2001/11/06 18:41:09 art Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.47 1999/03/26 23:41:29 mycroft Exp $	*/
d66 15
a80 6
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.  Returns 1 in the child process, 0 in the parent.
 * We currently double-map the user area so that the stack is at the same
 * address in each process; in the future we will probably relocate
 * the frame pointers on the stack after copying.
d109 1
a109 2
	 * Copy the trap frame, and arrange for the child to return directly
	 * through child_return().
d130 3
a132 5
 * We release the address space and machine-dependent resources,
 * including the memory for the user structure and kernel stack.
 * Once finished, we call switch_exit, which switches to a temporary
 * pcb and stack and never returns.  We block memory allocation
 * until switch_exit has made things safe again.
d205 2
a206 1
 * Both addresses are assumed to reside in the Sysmap.
d229 1
a229 1
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
d234 1
d287 3
a289 6
 * Map an IO request into kernel virtual address space.
 *
 * XXX we allocate KVA space by using kmem_alloc_wait which we know
 * allocates space without backing physical memory.  This implementation
 * is a total crock, the multiple mappings of these physical pages should
 * be reflected in the higher-level VM structures to avoid problems.
d299 1
a299 1
	paddr_t pa;		/* physical address */
d316 2
a317 1
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
d322 1
d326 1
a326 1
 * Free the io map PTEs associated with this IO operation.
d339 1
a339 1
	kva = trunc_page((vaddr_t)bp->b_data);
d343 2
a344 4
	/*
	 * pmap_remove() is unnecessary here, as kmem_free_wakeup()
	 * will do it for us.
	 */
@


1.32
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2001/09/21 02:11:57 miod Exp $	*/
a61 1
#include <vm/vm.h>
@


1.31
log
@phys_map declaration comes from <vm/vm.h>, no need to declare it locally.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2001/09/19 20:50:56 mickey Exp $	*/
d75 1
a75 1
cpu_fork(p1, p2, stack, stacksize)
d79 2
a81 1
	void child_return __P((struct proc *, struct frame));
d102 1
a102 1
	 * through child_return().  Note the in-line cpu_set_kpc().
d116 2
a117 2
	pcb->pcb_regs[6] = (int)child_return;	/* A2 */
	pcb->pcb_regs[7] = (int)p2;		/* A3 */
a118 18
}

/*
 * Arrange for in-kernel execution of a process to continue at the
 * named pc, as if the code at that address were called as a function
 * with the supplied argument.
 *
 * Note that it's assumed that when the named process returns, rei()
 * should be invoked, to return to user code.
 */
void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	p->p_addr->u_pcb.pcb_regs[6] = (int)pc;		/* A2 */
	p->p_addr->u_pcb.pcb_regs[7] = (int)arg;	/* A3 */
@


1.30
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2001/07/25 13:25:31 art Exp $	*/
a294 2

extern vm_map_t phys_map;
@


1.29
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/07/18 10:47:04 art Exp $	*/
a62 2
#include <vm/vm_kern.h>

@


1.28
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2001/06/27 04:05:45 art Exp $	*/
d333 1
a333 1
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
@


1.27
log
@no more old VM
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2001/06/10 01:44:43 deraadt Exp $	*/
a240 1
#ifdef PMAP_NEW
a242 7
#else
		pmap_remove(pmap_kernel(),
			    (vaddr_t)from, (vaddr_t)from + PAGE_SIZE);
		pmap_enter(pmap_kernel(),
			   (vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1,
			   VM_PROT_READ|VM_PROT_WRITE);
#endif
@


1.26
log
@Art error #1
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2001/06/08 13:32:55 millert Exp $	*/
a64 1
#if defined(UVM)
a65 1
#endif
a153 1
#if defined(UVM)
a154 3
#else
	cnt.v_swtch++;
#endif
a332 1
#if defined(UVM)
a333 3
#else
	kva = kmem_alloc_wait(phys_map, len);
#endif
a369 1
#if defined(UVM)
a370 3
#else
	kmem_free_wakeup(phys_map, kva, len);
#endif
@


1.25
log
@Fix the XXX #debug bits in vm_machdep().
Makes the pmap_extract() accept a NULL argument for pap; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2001/06/08 08:08:46 art Exp $	*/
a245 1
#endif
@


1.24
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/05/28 21:08:36 millert Exp $	*/
d233 1
d240 1
a240 1
		pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
d242 1
a242 2
#if 0
		if (pa == 0)
d244 1
a244 1
		if (pmap_extract(pmap_kernel(), (vaddr_t)to, XXX) != FALSE)
@


1.23
log
@#ifdef PMAP_NEW we should call pmap_kremove/pmap_kenter_pa instead of
pmap_remove/pmap_enter.  This is needed for when hp300 has true
pmap_kremove/pmap_kenter_pa instead of just wrapper functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/05/15 02:00:09 millert Exp $	*/
d239 1
a239 1
		pa = pmap_extract(pmap_kernel(), (vaddr_t)from);
d241 1
d244 1
a244 1
		if (pmap_extract(pmap_kernel(), (vaddr_t)to) != 0)
d247 1
d308 1
a308 2
	pa = pmap_extract(pmap_kernel(), (vaddr_t)addr);
	if (pa == 0)
d350 1
a350 2
		pa = pmap_extract(upmap, uva);
		if (pa == 0)
@


1.22
log
@Change splimp -> splhigh in cpu_exit() to match NetBSD and some of
our other ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/05/11 23:24:57 millert Exp $	*/
d246 4
d255 1
@


1.21
log
@Kill remaining vm_offset_t and vm_size_t; NetBSD used as a guide
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/05/06 21:39:00 millert Exp $	*/
d155 1
a155 1
	(void) splimp();
@


1.20
log
@Add casts to vaddr_t to round_page() and trunc_page() calls since
those macros no longer have an explicit cast inline.  Needed because
you can't do bitwise ops on a void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/05/06 00:45:48 art Exp $	*/
d326 1
a326 1
	vm_size_t off;
@


1.19
log
@Update some comments wrt. the CLSIZE changes.
And remove that memory price comment from 1981. It is amusing, but also
confusing because the math in there is only correct on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2001/05/05 20:56:35 art Exp $	*/
d331 1
a331 1
	uva = trunc_page(bp->b_saveaddr = bp->b_data);
d368 1
a368 1
	kva = trunc_page(bp->b_data);
@


1.18
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2001/05/04 22:48:59 aaron Exp $	*/
d225 1
a225 2
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of CLSIZE.
@


1.17
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2000/06/08 22:25:18 niklas Exp $	*/
d236 1
a236 1
	if (size & CLOFSET)
@


1.16
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.16 2000/06/08 21:11:57 niklas Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.37 1997/05/26 00:27:43 thorpej Exp $	*/
d65 4
d92 9
a100 2
	/* Sync curpcb (which is presumably p1's PCB) and copy it to p2. */
	savectx(curpcb);
a102 2
	PMAP_ACTIVATE(p2->p_vmspace->vm_map.pmap, pcb, 0);

d105 1
a105 1
	 * through return_to_user().  Note the inline cpu_set_kpc().
d124 8
d156 3
d160 1
d183 1
a183 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_M68K, 0);
d203 1
a203 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_M68K, CORE_CPU);
d233 1
a233 1
	vm_offset_t pa;
d240 1
a240 1
		pa = pmap_extract(pmap_kernel(), (vm_offset_t)from);
d244 1
a244 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to) != 0)
d248 1
a248 1
			    (vm_offset_t)from, (vm_offset_t)from + PAGE_SIZE);
d250 1
a250 1
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1,
d300 1
a300 1
	vm_offset_t va;
d302 2
a303 2
	va = pmap_extract(pmap_kernel(), (vm_offset_t)addr);
	if (va == 0)
d305 1
a305 1
	return((int)va);
a317 1
/*ARGSUSED*/
d319 1
a319 1
vmapbuf(bp, sz)
d321 1
a321 1
	vm_size_t sz;
d323 5
a327 7
	int npf;
	caddr_t addr;
	long flags = bp->b_flags;
	struct proc *p;
	int off;
	vm_offset_t kva;
	vm_offset_t pa;
d329 1
a329 1
	if ((flags & B_PHYS) == 0)
d331 9
a339 5
	addr = bp->b_saveaddr = bp->b_data;
	off = (int)addr & PGOFSET;
	p = bp->b_proc;
	npf = btoc(round_page(bp->b_bcount + off));
	kva = kmem_alloc_wait(phys_map, ctob(npf));
d341 5
a345 3
	while (npf--) {
		pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    (vm_offset_t)addr);
d348 2
a349 3
		pmap_enter(vm_map_pmap(phys_map), kva, trunc_page(pa),
			   VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
		addr += PAGE_SIZE;
d351 2
a352 1
	}
a357 1
/*ARGSUSED*/
d359 1
a359 1
vunmapbuf(bp, sz)
d361 1
a361 1
	vm_size_t sz;
d363 2
a364 3
	caddr_t addr;
	int npf;
	vm_offset_t kva;
d368 14
a381 4
	addr = bp->b_data;
	npf = btoc(round_page(bp->b_bcount + ((int)addr & PGOFSET)));
	kva = (vm_offset_t)((int)addr & ~PGOFSET);
	kmem_free_wakeup(phys_map, kva, ctob(npf));
d383 1
a383 1
	bp->b_saveaddr = NULL;
@


1.15
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 1999/09/03 18:00:44 art Exp $	*/
d49 1
@


1.14
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 1999/08/17 10:32:16 niklas Exp $	*/
a135 2

	vmspace_free(p->p_vmspace);
@


1.14.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2000/06/08 22:25:18 niklas Exp $	*/
a48 1
#include <sys/signalvar.h>
d136 2
@


1.14.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vm_machdep.c,v 1.47 1999/03/26 23:41:29 mycroft Exp $	*/
a64 2
#include <uvm/uvm_extern.h>

d88 2
a89 9
	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
d92 2
d96 1
a96 1
	 * through child_return().  Note the in-line cpu_set_kpc().
a114 8
/*
 * Arrange for in-kernel execution of a process to continue at the
 * named pc, as if the code at that address were called as a function
 * with the supplied argument.
 *
 * Note that it's assumed that when the named process returns, rei()
 * should be invoked, to return to user code.
 */
d138 2
a139 2
	(void) splhigh();
	uvmexp.swtch++;
d162 1
a162 1
	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
d182 1
a182 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
d204 2
a205 1
 * Both addresses are assumed to reside in the Sysmap.
d212 1
a212 2
	paddr_t pa;
	boolean_t rv;
d215 1
a215 1
	if ((size & PAGE_MASK) != 0)
d219 1
a219 1
		rv = pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
d221 1
a221 1
		if (rv == FALSE)
d223 1
a223 1
		if (pmap_extract(pmap_kernel(), (vaddr_t)to, NULL) == TRUE)
a225 4
#ifdef PMAP_NEW
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
#else
d227 1
a227 1
			    (vaddr_t)from, (vaddr_t)from + PAGE_SIZE);
d229 1
a229 1
			   (vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1,
a230 1
#endif
d279 1
a279 1
	paddr_t pa;
d281 2
a282 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa) == FALSE)
d284 1
a284 1
	return((int)pa);
d297 1
d299 1
a299 1
vmapbuf(bp, len)
d301 1
a301 1
	vsize_t len;
d303 7
a309 5
	struct pmap *upmap, *kpmap;
	vaddr_t uva;		/* User VA (map from) */
	vaddr_t kva;		/* Kernel VA (new to) */
	paddr_t pa;		/* physical address */
	vsize_t off;
d311 1
a311 1
	if ((bp->b_flags & B_PHYS) == 0)
d313 5
a317 5

	uva = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - uva;
	len = round_page(off + len);
	kva = uvm_km_valloc_wait(phys_map, len);
d319 4
a322 5

	upmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	kpmap = vm_map_pmap(phys_map);
	do {
		if (pmap_extract(upmap, uva, &pa) == FALSE)
d324 3
a326 2
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
		uva += PAGE_SIZE;
d328 1
a328 2
		len -= PAGE_SIZE;
	} while (len);
d334 1
d336 1
a336 1
vunmapbuf(bp, len)
d338 1
a338 1
	vsize_t len;
d340 3
a342 2
	vaddr_t kva;
	vsize_t off;
d346 4
a349 10

	kva = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - kva;
	len = round_page(off + len);

	/*
	 * pmap_remove() is unnecessary here, as kmem_free_wakeup()
	 * will do it for us.
	 */
	uvm_km_free_wakeup(phys_map, kva, len);
d351 1
a351 1
	bp->b_saveaddr = 0;
@


1.14.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14.4.2 2001/07/04 10:15:49 niklas Exp $	*/
d63 2
d241 1
d244 7
d306 2
d341 1
a341 1
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
@


1.14.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
d75 1
a75 1
cpu_fork(p1, p2, stack, stacksize, func, arg)
a78 2
	void (*func)(void *);
	void *arg;
d80 1
d101 1
a101 1
	 * through child_return().
d115 2
a116 2
	pcb->pcb_regs[6] = (int)func;		/* A2 */
	pcb->pcb_regs[7] = (int)arg;		/* A3 */
d118 18
@


1.14.4.5
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: vm_machdep.c,v 1.60 2001/07/06 05:53:35 chs Exp $	*/
d66 6
a71 15
 * Copy and update the pcb and trap frame, making the child ready to run.
 * 
 * Rig the child's kernel stack so that it will start out in
 * proc_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
 *
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path and argument are specified with
 * `func' and `arg'.
 *
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
 * accordingly.
d100 2
a101 1
	 * Copy the trap frame.
d122 5
a126 3
 *
 * Block context switches and then call switch_exit() which will
 * switch to another process thus we never return.
d199 1
a199 2
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of PAGE_SIZE.
d222 1
a222 1
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ | VM_PROT_WRITE);
a226 1
	pmap_update(pmap_kernel());
d279 6
a284 3
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().   
d294 1
a294 1
	paddr_t pa; 		/* physical address */
d311 1
a311 2
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE,
		    PMAP_WIRED);
a315 1
	pmap_update(pmap_kernel());
d319 1
a319 1
 * Unmap a previously-mapped user I/O request.
d332 1
a332 1
	kva = trunc_page((vaddr_t)(bp->b_data));
d336 4
a339 2
	pmap_remove(vm_map_pmap(phys_map), kva, kva + len);
	pmap_update(pmap_kernel());
@


1.14.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14.4.5 2002/03/06 00:57:22 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.13
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 1999/01/10 13:34:17 niklas Exp $	*/
d230 2
a231 1
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1);
d326 1
a326 1
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
@


1.12
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 1998/07/28 00:13:34 millert Exp $	*/
d74 1
a74 1
cpu_fork(p1, p2)
d76 2
d100 7
@


1.11
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 1997/07/06 08:02:10 downsj Exp $	*/
d93 1
a93 1
	 * through return_to_user().
d106 1
a106 1
cpu_set_kpc(p, pc)
d108 2
a109 1
	void (*pc) __P((struct proc *));
d111 2
a112 2

	p->p_addr->u_pcb.pcb_regs[6] = (int) pc;	/* A2 */
@


1.10
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1997/04/16 11:56:32 downsj Exp $	*/
d179 1
a179 1
	    (int *)0, p);
d185 1
a185 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)0, p);
@


1.9
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.8 1997/03/26 08:32:45 downsj Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.35 1997/04/01 03:12:33 scottr Exp $	*/
a63 2
void	setredzone __P((pt_entry_t *, caddr_t));

d89 1
a89 1
	PMAP_ACTIVATE(&p2->p_vmspace->vm_pmap, pcb, 0);
a259 19
}

/*
 * Set a red zone in the kernel stack after the u. area.
 * We don't support a redzone right now.  It really isn't clear
 * that it is a good idea since, if the kernel stack were to roll
 * into a write protected page, the processor would lock up (since
 * it cannot create an exception frame) and we would get no useful
 * post-mortem info.  Currently, under the DEBUG option, we just
 * check at every clock interrupt to see if the current k-stack has
 * gone too far (i.e. into the "redzone" page) and if so, panic.
 * Look at _lev6intr in locore.s for more details.
 */
/*ARGSUSED*/
void
setredzone(pte, vaddr)
	pt_entry_t *pte;
	caddr_t vaddr;
{
@


1.8
log
@Merge changes from NetBSD, up to 3/19/97; undoes some local changes.
Changed to match new arch/m68k code.
genassym.cf is currently just a place holder.
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.7 1997/02/10 11:13:34 downsj Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.34 1997/03/16 09:59:40 thorpej Exp $	*/
d56 5
d64 1
a64 3
#include <machine/cpu.h>
#include <machine/pte.h>
#include <machine/reg.h>
d77 1
a77 1
	register struct proc *p1, *p2;
d79 4
a82 3
	register struct pcb *pcb = &p2->p_addr->u_pcb;
	register struct trapframe *tf;
	register struct switchframe *sf;
a83 1
	extern void proc_trampoline(), child_return();
d202 1
a202 1
	register caddr_t from, to;
d205 1
a205 1
	register vm_offset_t pa;
d234 1
d237 1
a237 1
	register int size, prot;
d239 2
a240 2
	register pt_entry_t *pte;
	register u_int page;
d251 1
d254 1
a254 1
	register int size;
d256 1
a256 1
	register pt_entry_t *pte;
d276 1
d286 1
d288 1
a288 1
	register caddr_t addr;
d311 1
a311 1
	register struct buf *bp;
d314 3
a316 3
	register int npf;
	register caddr_t addr;
	register long flags = bp->b_flags;
d320 1
a320 1
	register vm_offset_t pa;
d348 1
a348 1
	register struct buf *bp;
d351 2
a352 2
	register caddr_t addr;
	register int npf;
@


1.7
log
@hp300 portion of the copypage/zeropage/mappedcopy changes from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.6 1997/01/12 15:13:29 downsj Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.31 1997/02/02 08:03:06 thorpej Exp $	*/
d82 1
a82 1
	p2->p_md.md_flags = p1->p_md.md_flags & ~MDP_HPUXTRACE;
a151 12
#ifdef COMPAT_HPUX
	extern struct emul emul_hpux;

	/*
	 * If we loaded from an HP-UX format binary file we dump enough
	 * of an HP-UX style user struct so that the HP-UX debuggers can
	 * grok it.
	 */
	if (p->p_emul == &emul_hpux)
		return (hpux_dumpu(vp, cred));
#endif

d162 9
a170 4
	/* Save floating point registers. */
	error = process_read_fpregs(p, &md_core.freg);
	if (error)
		return error;
@


1.6
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vm_machdep.c,v 1.30 1996/05/09 21:26:08 scottr Exp $	*/
a363 89

#ifdef MAPPEDCOPY
u_int mappedcopysize = 4096;

mappedcopyin(fromp, top, count)
	register char *fromp, *top;
	register int count;
{
	register vm_offset_t kva, upa;
	register int off, len;
	int alignable;
	pmap_t upmap;
	extern caddr_t CADDR1;

	kva = (vm_offset_t) CADDR1;
	off = (vm_offset_t)fromp & PAGE_MASK;
	alignable = (off == ((vm_offset_t)top & PAGE_MASK));
	upmap = vm_map_pmap(&curproc->p_vmspace->vm_map);
	while (count > 0) {
		/*
		 * First access of a page, use fubyte to make sure
		 * page is faulted in and read access allowed.
		 */
		if (fubyte(fromp) == -1)
			return (EFAULT);
		/*
		 * Map in the page and bcopy data in from it
		 */
		upa = pmap_extract(upmap, trunc_page(fromp));
		if (upa == 0)
			panic("mappedcopyin");
		len = min(count, PAGE_SIZE-off);
		pmap_enter(pmap_kernel(), kva, upa, VM_PROT_READ, TRUE);
		if (len == PAGE_SIZE && alignable && off == 0)
			copypage(kva, top);
		else
			bcopy((caddr_t)(kva+off), top, len);
		fromp += len;
		top += len;
		count -= len;
		off = 0;
	}
	pmap_remove(pmap_kernel(), kva, kva+PAGE_SIZE);
	return (0);
}

mappedcopyout(fromp, top, count)
	register char *fromp, *top;
	register int count;
{
	register vm_offset_t kva, upa;
	register int off, len;
	int alignable;
	pmap_t upmap;
	extern caddr_t CADDR2;

	kva = (vm_offset_t) CADDR2;
	off = (vm_offset_t)top & PAGE_MASK;
	alignable = (off == ((vm_offset_t)fromp & PAGE_MASK));
	upmap = vm_map_pmap(&curproc->p_vmspace->vm_map);
	while (count > 0) {
		/*
		 * First access of a page, use subyte to make sure
		 * page is faulted in and write access allowed.
		 */
		if (subyte(top, *fromp) == -1)
			return (EFAULT);
		/*
		 * Map in the page and bcopy data out to it
		 */
		upa = pmap_extract(upmap, trunc_page(top));
		if (upa == 0)
			panic("mappedcopyout");
		len = min(count, PAGE_SIZE-off);
		pmap_enter(pmap_kernel(), kva, upa,
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
		if (len == PAGE_SIZE && alignable && off == 0)
			copypage(fromp, kva);
		else
			bcopy(fromp, (caddr_t)(kva+off), len);
		fromp += len;
		top += len;
		count -= len;
		off = 0;
	}
	pmap_remove(pmap_kernel(), kva, kva+PAGE_SIZE);
	return (0);
}
#endif
@


1.5
log
@sync to 0622
@
text
@d1 1
@


1.4
log
@it compiles now.
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.28 1996/02/09 16:58:40 scottr Exp $	*/
d106 1
a106 1
	void (*pc)(struct proc *);
d109 1
a109 1
	p->p_addr->u_pcb.pcb_regs[6] = (u_long)pc;	/* A2 */
@


1.3
log
@sync w/ Net 960424
@
text
@d106 1
a106 1
	u_long pc;
d109 1
a109 1
	p->p_addr->u_pcb.pcb_regs[6] = pc;	/* A2 */
d203 1
d206 1
a206 1
	int size;
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.26 1995/12/09 04:37:38 mycroft Exp $	*/
d306 3
a308 1
vmapbuf(bp)
d310 1
d343 3
a345 1
vunmapbuf(bp)
d347 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.25 1995/08/07 06:13:57 mycroft Exp $	*/
d71 1
a71 1
int
a100 2

	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
