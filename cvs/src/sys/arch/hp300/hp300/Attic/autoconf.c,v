head	1.50;
access;
symbols
	OPENBSD_5_5:1.49.0.18
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.14
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.49.0.12
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.10
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.8
	OPENBSD_5_0:1.49.0.6
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.4
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.46.0.4
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.45.0.4
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.33.0.4
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.6
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.4
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.23
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.17.0.10
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.17.0.8
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.6
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.4
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.8
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.6
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.16.0.4
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.49;

1.49
date	2010.06.09.15.44.17;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.15.20.38.11;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.26.20.04.06;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.03.15.20.40.23;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.08.09.28.49;	author martin;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.01.19.25.09;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.04.19.30.54;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.07.15.14.32;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.24.13.20.17;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.31.18.13.44;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.30.18.14.12;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.30.18.03.36;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.27.18.31.08;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.27.22.08.41;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.02.22.22.11.45;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.16.17.43.04;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.14.22.39.27;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.01.09.00.09.51;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.30.21.26.14;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.08.03.21.46.58;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.10.21.11.12;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.04.19.38.18;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.16.20.51.45;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.10.00.58.02;	author miod;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.09.19.21.32.19;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.05.22.33.33;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.05.25.08.37.49;	author downsj;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	97.07.06.08.01.57;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.04.16.11.56.20;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.02.20.18.13.37;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.02.16.17.54.40;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	97.02.16.14.37.10;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.02.03.08.11.59;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.02.03.04.47.54;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.01.18.06.43.05;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.01.13.18.03.55;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.01.12.15.13.10;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.06.23.11.47.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.25.06.37.01;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.05.13.34.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.30.09.24.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.22;	author deraadt;	state Exp;
branches;
next	;

1.17.4.1
date	2001.07.04.10.15.36;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.17.4.5;

1.17.4.5
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.17.4.6;

1.17.4.6
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	;

1.20.2.1
date	2002.01.31.22.55.08;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: autoconf.c,v 1.49 2010/06/09 15:44:17 miod Exp $	*/
/*	$NetBSD: autoconf.c,v 1.45 1999/04/10 17:31:02 kleink Exp $	*/

/*
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: autoconf.c 1.36 92/12/20$
 *
 *	@@(#)autoconf.c	8.2 (Berkeley) 1/12/94
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/malloc.h>
#include <sys/extent.h>
#include <sys/mount.h>
#include <sys/queue.h>
#include <sys/reboot.h>
#include <sys/tty.h>

#include <dev/cons.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/vmparam.h>
#include <machine/cpu.h>
#include <machine/hp300spu.h>
#include <machine/intr.h>
#include <machine/pte.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>

#include <hp300/dev/dmavar.h>

#include <hp300/dev/hpibvar.h>
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <uvm/uvm_extern.h>

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */

struct	extent *extio;

extern	caddr_t internalhpib;
extern	char *extiobase;

/* The boot device. */
struct	device *bootdv;

/* The device we mount as root. */
struct	device *root_device;

/* How we were booted. */
u_int	bootdev;

/*
 * This information is built during the autoconfig process.
 * A little explanation about the way this works is in order.
 *
 *	device_register() links all devices into dev_data_list.
 *	If the device is an hpib controller, it is also linked
 *	into dev_data_list_hpib.  If the device is a scsi controller,
 *	it is also linked into dev_data_list_scsi.
 *
 *	dev_data_list_hpib and dev_data_list_scsi are sorted
 *	by select code, from lowest to highest.
 *
 *	After autoconfiguration is complete, we need to determine
 *	which device was the boot device.  The boot block assigns
 *	controller unit numbers in order of select code.  Thus,
 *	providing the controller is configured in the kernel, we
 *	can determine our version of controller unit number from
 *	the sorted hpib/scsi list.
 *
 *	At this point, we know the controller (device type
 *	encoded in bootdev tells us "scsi disk", or "hpib tape",
 *	etc.).  The next step is to find the device which
 *	has the following properties:
 *
 *		- A child of the boot controller.
 *		- Same slave as encoded in bootdev.
 *		- Same physical unit as encoded in bootdev.
 *
 *	Later, after we've set the root device in stone, we
 *	reverse the process to re-encode bootdev so it can be
 *	passed back to the boot block.
 */
struct dev_data {
	LIST_ENTRY(dev_data)	dd_list;  /* dev_data_list */
	LIST_ENTRY(dev_data)	dd_clist; /* ctlr list */
	struct device		*dd_dev;  /* device described by this entry */
	int			dd_scode; /* select code of device */
	int			dd_slave; /* ...or slave */
	int			dd_punit; /* and punit... */
};
typedef LIST_HEAD(, dev_data) ddlist_t;
ddlist_t	dev_data_list;	  	/* all dev_datas */
ddlist_t	dev_data_list_hpib;	/* hpib controller dev_datas */
ddlist_t	dev_data_list_scsi;	/* scsi controller dev_datas */

void	findbootdev(void);
void	findbootdev_slave(ddlist_t *, int, int, int);
void	setbootdev(void);

static	struct dev_data *dev_data_lookup(struct device *);
static	void dev_data_insert(struct dev_data *, ddlist_t *);

static	int device_match(struct device *, const char *);

int	mainbusmatch(struct device *, void *, void *);
void	mainbusattach(struct device *, struct device *, void *);
int	mainbussearch(struct device *, void *, void *);

struct cfattach mainbus_ca = {
	sizeof(struct device), mainbusmatch, mainbusattach
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

int
mainbusmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	static int mainbus_matched = 0;

	/* Allow only one instance. */
	if (mainbus_matched)
		return (0);

	mainbus_matched = 1;
	return (1);
}

void
mainbusattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{

	printf("\n");

	/* Search for and attach children. */
	config_search(mainbussearch, self, NULL);
}

int
mainbussearch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;

	if ((*cf->cf_attach->ca_match)(parent, cf, NULL) > 0)
		config_attach(parent, cf, NULL, NULL);
	return (0);
}

/*
 * Determine the device configuration for the running system.
 */
void
cpu_configure()
{
	/* this couldn't be done in intr_init() because this uses malloc() */
	softintr_init();

	/*
	 * Initialize the dev_data_lists.
	 */
	LIST_INIT(&dev_data_list);
	LIST_INIT(&dev_data_list_hpib);
	LIST_INIT(&dev_data_list_scsi);

	(void)splhigh();
	if (config_rootfound("mainbus", "mainbus") == NULL)
		panic("no mainbus found");
	(void)spl0();

	intr_printlevels();

	/*
	 * Find boot device.
	 */
	if ((bootdev & B_MAGICMASK) != B_DEVMAGIC) {
		printf("WARNING: boot program didn't supply boot device.\n");
		printf("Please update your boot program.\n");
	} else {
		findbootdev();
		if (bootdv == NULL) {
			printf("WARNING: can't find match for bootdev:\n");
			printf(
		    "type = %d, ctlr = %d, slave = %d, punit = %d, part = %d\n",
			    B_TYPE(bootdev), B_ADAPTOR(bootdev),
			    B_CONTROLLER(bootdev), B_UNIT(bootdev),
			    B_PARTITION(bootdev));
			bootdev = 0;		/* invalidate bootdev */
		} else {
			printf("boot device: %s\n", bootdv->dv_xname);
		}
	}
	cold = 0;
}

void
diskconf(void)
{
	int bootpartition = 0;

	/*
	 * If bootdev is bogus, ask the user anyhow.
	 */
	if (bootdev == 0)
		boothowto |= RB_ASKNAME;
	else
		bootpartition = B_PARTITION(bootdev);

	/*
	 * If we booted from tape, ask the user.
	 */
	if (bootdv != NULL && bootdv->dv_class == DV_TAPE)
		boothowto |= RB_ASKNAME;

	setroot(bootdv, bootpartition, RB_USERREQ);
	dumpconf();

	/*
	 * Set bootdev based on the device we booted from.
	 * This is given to the boot program when we reboot.
	 */
	setbootdev();
}

/**********************************************************************
 * Code to find and set the boot device
 **********************************************************************/

static int
device_match(struct device *dv, const char *template)
{
	return strcmp(dv->dv_cfdata->cf_driver->cd_name, template);
}

/*
 * Register a device.  We're passed the device and the arguments
 * used to attach it.  This is used to find the boot device.
 */
void
device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	struct dev_data *dd;
	static int seen_netdevice = 0;

	/*
	 * Allocate a dev_data structure and fill it in.
	 * This means making some tests twice, but we don't
	 * care; this doesn't really have to be fast.
	 *
	 * Note that we only really care about devices that
	 * we can mount as root.
	 */
	dd = (struct dev_data *)malloc(sizeof(struct dev_data),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (dd == NULL)
		panic("device_register: can't allocate dev_data");

	dd->dd_dev = dev;

	/*
	 * BOOTROM and boot program can really only understand
	 * using the lowest select code network interface,
	 * so we ignore all but the first.
	 */
	if (dev->dv_class == DV_IFNET && seen_netdevice == 0) {
		struct dio_attach_args *da = aux;

		seen_netdevice = 1;
		dd->dd_scode = da->da_scode;
		goto linkup;
	}

	if (device_match(dev, "fhpib") == 0 ||
	    device_match(dev, "nhpib") == 0 ||
	    device_match(dev, "spc") == 0) {
		struct dio_attach_args *da = aux;

		dd->dd_scode = da->da_scode;
		goto linkup;
	}

	if (device_match(dev, "hd") == 0) {
		struct hpibbus_attach_args *ha = aux;

		dd->dd_slave = ha->ha_slave;
		dd->dd_punit = ha->ha_punit;
		goto linkup;
	}

	if (device_match(dev, "cd") == 0 ||
	    device_match(dev, "sd") == 0 ||
	    device_match(dev, "st") == 0) {
		struct scsi_attach_args *sa = aux;

		dd->dd_slave = sa->sa_sc_link->target;
		dd->dd_punit = sa->sa_sc_link->lun;
		goto linkup;
	}

	/*
	 * Didn't need the dev_data.
	 */
	free(dd, M_DEVBUF);
	return;

 linkup:
	LIST_INSERT_HEAD(&dev_data_list, dd, dd_list);

	if (device_match(dev, "fhpib") == 0 ||
	    device_match(dev, "nhpib") == 0) {
		dev_data_insert(dd, &dev_data_list_hpib);
		return;
	}

	if (device_match(dev, "spc") == 0) {
		dev_data_insert(dd, &dev_data_list_scsi);
		return;
	}
}

void
findbootdev()
{
	int type, ctlr, slave, punit;
	int scsiboot, hpibboot, netboot;
	struct dev_data *dd;

	bootdv = NULL;

	if ((bootdev & B_MAGICMASK) != B_DEVMAGIC)
		return;

	type  = B_TYPE(bootdev);
	ctlr  = B_ADAPTOR(bootdev);
	slave = B_CONTROLLER(bootdev);
	punit = B_UNIT(bootdev);

	scsiboot = (type == 4);			/* sd major */
	hpibboot = (type == 0 || type == 2);	/* ct/hd major */
	netboot  = (type == 6);			/* le - special */

	/*
	 * Check for network boot first, since it's a little
	 * different.  The BOOTROM/boot program can only boot
	 * off of the first (lowest select code) ethernet
	 * device.  device_register() knows this and only
	 * registers one DV_IFNET.  This is a safe assumption
	 * since the code that finds devices on the DIO bus
	 * always starts at scode 0 and works its way up.
	 */
	if (netboot) {
		LIST_FOREACH(dd, &dev_data_list, dd_list) {
			if (dd->dd_dev->dv_class == DV_IFNET) {
				/*
				 * Found it!
				 */
				bootdv = dd->dd_dev;
				break;
			}
		}
		return;
	}

	/*
	 * Check for HP-IB boots next.
	 */
	if (hpibboot) {
		findbootdev_slave(&dev_data_list_hpib, ctlr,
		    slave, punit);
		if (bootdv == NULL)
			return;

#ifdef DIAGNOSTIC
		/*
		 * Sanity check.
		 */
		if ((type == 0 &&
		     device_match(bootdv, "ct")) ||
		    (type == 2 &&
		     device_match(bootdv, "hd"))) {
			printf("WARNING: boot device/type mismatch!\n");
			printf("device = %s, type = %d\n",
			    bootdv->dv_xname, type);
			bootdv = NULL;
		}
#endif
		return;
	}

	/*
	 * Check for SCSI boots last.
	 */
	if (scsiboot) {
		findbootdev_slave(&dev_data_list_scsi, ctlr,
		     slave, punit);
		if (bootdv == NULL)
			return;

#ifdef DIAGNOSTIC
		/*
		 * Sanity check.
		 */
		if (device_match(bootdv, "cd") != 0 &&
		    device_match(bootdv, "sd") != 0 &&
		    device_match(bootdv, "st") != 0) {
			printf("WARNING: boot device/type mismatch!\n");
			printf("device = %s, type = %d\n",
			    bootdv->dv_xname, type);
			bootdv = NULL;
		}
#endif
		return;
	}

	/* Oof! */
	printf("WARNING: UNKNOWN BOOT DEVICE TYPE = %d\n", type);
}

void
findbootdev_slave(ddlist, ctlr, slave, punit)
	ddlist_t *ddlist;
	int ctlr, slave, punit;
{
	struct dev_data *cdd, *dd;

	/*
	 * Find the booted controller.
	 */
	for (cdd = LIST_FIRST(ddlist); ctlr != 0 && cdd != LIST_END(ddlist);
	    cdd = LIST_NEXT(cdd, dd_clist))
		ctlr--;
	if (cdd == NULL) {
		/*
		 * Oof, couldn't find it...
		 */
		return;
	}

	/*
	 * Now find the device with the right slave/punit
	 * that's a child of the controller.
	 */
	LIST_FOREACH(dd, &dev_data_list, dd_list) {
		/*
		 * "sd" / "st" / "cd" -> "scsibus" -> "spc"
		 * "hd" -> "hpibbus" -> "fhpib"
		 */
		if (dd->dd_dev->dv_parent->dv_parent != cdd->dd_dev)
			continue;

		if (dd->dd_slave == slave &&
		    dd->dd_punit == punit) {
			/*
			 * Found it!
			 */
			bootdv = dd->dd_dev;
			break;
		}
	}
}

void
setbootdev()
{
	struct dev_data *cdd, *dd;
	int type, ctlr;

	/*
	 * Note our magic numbers for type:
	 *
	 *	0 == ct
	 *	2 == hd
	 *	4 == scsi
	 *	6 == le
	 *
	 * All are bdevsw major numbers, except for le, which
	 * is just special. SCSI needs specific care since the
	 * ROM wants to see 4, but depending upon the real device
	 * we booted from, we might have a different major value.
	 */

	/*
	 * Start with a clean slate.
	 */
	bootdev = 0;

	/*
	 * If we don't have a saveable root_device, just punt.
	 */
	if (root_device == NULL)
		goto out;

	dd = dev_data_lookup(root_device);

	/*
	 * If the root device is network, we're done
	 * early.
	 */
	if (root_device->dv_class == DV_IFNET) {
		bootdev = MAKEBOOTDEV(6, 0, 0, 0, 0);
		goto out;
	}

	/*
	 * Determine device type.
	 */
	if (device_match(root_device, "hd") == 0)
		type = 2;
	else if (device_match(root_device, "cd") == 0 ||
	    device_match(root_device, "sd") == 0 ||
	    device_match(root_device, "st") == 0)
		/* force scsi disk regardless of the actual device */
		type = 4;
	else {
		printf("WARNING: strange root device!\n");
		goto out;
	}

	/*
	 * Get parent's info.
	 *
	 * "hd" -> "hpibbus" -> "fhpib"
	 * "sd" / "cd" / "st" -> "scsibus" -> "spc"
	 */
	for (cdd = LIST_FIRST(&dev_data_list_hpib), ctlr = 0;
	    cdd != LIST_END(&dev_data_list_hpib);
	    cdd = LIST_NEXT(cdd, dd_clist), ctlr++) {
		if (cdd->dd_dev == root_device->dv_parent->dv_parent) {
			/*
			 * Found it!
			 */
			bootdev = MAKEBOOTDEV(type, ctlr, dd->dd_slave,
			    dd->dd_punit, DISKPART(rootdev));
			break;
		}
	}

 out:
	/* Don't need this anymore. */
	for (dd = LIST_FIRST(&dev_data_list);
	    dd != LIST_END(&dev_data_list); ) {
		cdd = dd;
		dd = LIST_NEXT(dd, dd_list);
		free(cdd, M_DEVBUF);
	}
}

/*
 * Return the dev_data corresponding to the given device.
 */
static struct dev_data *
dev_data_lookup(dev)
	struct device *dev;
{
	struct dev_data *dd;

	LIST_FOREACH(dd, &dev_data_list, dd_list)
		if (dd->dd_dev == dev)
			return (dd);

	panic("dev_data_lookup");
}

/*
 * Insert a dev_data into the provided list, sorted by select code.
 */
static void
dev_data_insert(dd, ddlist)
	struct dev_data *dd;
	ddlist_t *ddlist;
{
	struct dev_data *de;

#ifdef DIAGNOSTIC
	if (dd->dd_scode < 0 || dd->dd_scode > 255) {
		panic("bogus select code for %s", dd->dd_dev->dv_xname);
	}
#endif

	/*
	 * Just insert at head if list is empty.
	 */
	if (LIST_EMPTY(ddlist)) {
		LIST_INSERT_HEAD(ddlist, dd, dd_clist);
		return;
	}

	/*
	 * Traverse the list looking for a device who's select code
	 * is greater than ours.  When we find it, insert ourselves
	 * into the list before it.
	 */
	for (de = LIST_FIRST(ddlist);
	    LIST_NEXT(de, dd_clist) != LIST_END(ddlist);
	    de = LIST_NEXT(de, dd_clist)) {
		if (de->dd_scode > dd->dd_scode) {
			LIST_INSERT_BEFORE(de, dd, dd_clist);
			return;
		}
	}

	/*
	 * Our select code is greater than everyone else's.  We go
	 * onto the end.
	 */
	LIST_INSERT_AFTER(de, dd, dd_clist);
}

/**********************************************************************
 * Code to find and initialize the console
 **********************************************************************/

/*
 * Scan all select codes, passing the corresponding VA to (*func)().
 * (*func)() is a driver-specific routine that looks for the console
 * hardware.
 */
void
console_scan(func, arg)
	int (*func)(int, caddr_t, void *);
	void *arg;
{
	int size, scode, sctop, sctmp;
	caddr_t pa, va;

	/*
	 * Scan all select codes.  Check each location for some
	 * hardware.  If there's something there, call (*func)().
	 */
	sctop = DIO_SCMAX(machineid);
	for (scode = 0; scode < sctop; scode++) {
		/*
		 * Skip over the select code hole and
		 * the internal HP-IB controller.
		 */
		if ((sctmp = dio_inhole(scode)) != 0) {
			scode = sctmp - 1;
			continue;
		}
		if (scode == 7 && internalhpib)
			continue;

		/* Map current PA. */
		pa = dio_scodetopa(scode);
		va = iomap(pa, PAGE_SIZE);
		if (va == NULL)
			continue;

		/* Check to see if hardware exists. */
		if (badaddr(va)) {
			iounmap(va, PAGE_SIZE);
			continue;
		}

		/*
		 * Hardware present, call callback.  Driver returns
		 * size of region to map if console probe successful
		 * and worthwhile.
		 */
		size = (*func)(scode, va, arg);
		iounmap(va, PAGE_SIZE);
		if (size != 0 && conscode == scode) {
			/* Free last mapping. */
			if (convasize)
				iounmap(conaddr, convasize);
			convasize = 0;

			/* Remap to correct size. */
			va = iomap(pa, size);
			if (va == NULL)
				continue;

			/* Save this state for next time. */
			conaddr = va;
			convasize = size;
		}
	}
}

int consolepass = -1;
struct consdev *cn_tab;

/*
 * Special version of cninit().  Actually, crippled somewhat.
 * This version lets the drivers assign cn_tab.
 */
void
hp300_cninit(void)
{
	struct consdev *cp;
	extern struct consdev constab[];

	if (++consolepass == 0) {
		cn_tab = NULL;

		/*
		 * Call all of the console probe functions.
		 */
		for (cp = constab; cp->cn_probe; cp++)
			(*cp->cn_probe)(cp);
	}

	/*
	 * No console, we can handle it.
	 */
	if (cn_tab == NULL)
		return;

	/*
	 * Turn on the console.
	 *
	 * Note that we need to check for cn_init because DIO frame buffers
	 * will cause cn_tab to switch to wsdisplaycons, which does not
	 * have an cn_init function.
	 */
	if (cn_tab->cn_init != NULL) {
		(*cn_tab->cn_init)(cn_tab);
	}
}

/**********************************************************************
 * Mapping functions
 **********************************************************************/

/*
 * Allocate/deallocate a cache-inhibited range of kernel virtual address
 * space mapping the indicated physical address range [pa - pa+size)
 */
caddr_t
iomap(pa, size)
	caddr_t pa;
	int size;
{
	vaddr_t iova, tva, off;
	paddr_t ppa;
	int error;

	if (size <= 0)
		return NULL;

	ppa = trunc_page((paddr_t)pa);
	off = (paddr_t)pa & PAGE_MASK;
	size = round_page(off + size);

	error = extent_alloc(extio, size, PAGE_SIZE, 0, EX_NOBOUNDARY,
	    EX_NOWAIT | EX_MALLOCOK, &iova);

	if (error != 0)
		return (NULL);

	tva = iova;
	while (size != 0) {
		pmap_kenter_cache(tva, ppa, PG_RW | PG_CI);
		size -= PAGE_SIZE;
		tva += PAGE_SIZE;
		ppa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
	return ((void *)(iova + off));
}

/*
 * Unmap a previously mapped device.
 */
void
iounmap(va, size)
	caddr_t va;
	int size;
{
	vaddr_t kva, off;
	int error;

	off = (vaddr_t)va & PAGE_MASK;
	kva = trunc_page((vaddr_t)va);
	size = round_page(off + size);

	pmap_kremove(kva, size);
	pmap_update(pmap_kernel());

	error = extent_free(extio, kva, size, EX_NOWAIT);
#ifdef DIAGNOSTIC
	if (error != 0)
		printf("iounmap: extent_free failed\n");
#endif
}

struct nam2blk nam2blk[] = {
	{ "ct",		0 },
	{ "hd",		2 },
	{ "sd",		4 },
	{ "st",		7 },
	{ "rd",		8 },
	{ "cd",		9 },
	{ "vnd",	6 },
	{ NULL,		-1 }
};
@


1.49
log
@Move declaration of cn_tab from dev/cons.c to dev/cninit.c, or appropriate
md files for ports which do not use dev/cninit.c. This gets rid of a common
at kernel link time.
feedback drahn@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.48 2010/04/15 20:38:11 miod Exp $	*/
@


1.48
log
@Turn DIO_INHOLE() into a function, returning the next select code to probe at;
and skip function codes 132 to 135, inclusive, on models 362 and 382 - this
is a fake DIO device probably intended to let non-SGC aware (i.e. legacy)
HP-UX lowlevel code be able to ``detect'' a frame buffer.

This change (as well as letting sgc attach) is untested due to the lack of any
3x2 hardware, but shouldn't make things worse.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.47 2009/10/26 20:04:06 miod Exp $	*/
d756 1
@


1.47
log
@In device_match(), match on exact device name (as obtained from struct cfdriver)
instead of `first N chars of dv_xname and checking the next char is a digit'.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46 2009/03/15 20:40:23 miod Exp $	*/
d698 1
a698 1
	int size, scode, sctop;
d706 1
a706 1
	for (scode = 0; scode < sctop; ++scode) {
d711 5
a715 2
		if (DIO_INHOLE(scode) ||
		    ((scode == 7) && internalhpib))
@


1.46
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2008/07/21 04:35:54 todd Exp $	*/
d170 1
a170 1
static	int device_match(const char *, const char *);
d303 1
a303 1
device_match(const char *dvname, const char *template)
d305 1
a305 12
	size_t len = strlen(template);
	char unit;

	if (strncmp(dvname, template, len) != 0)
		return (1);

	/* Check that we are immediately followed by an unit number. */
	unit = dvname[len];
	if (unit < '0' || unit > '9')
		return (1);

	return (0);
d348 3
a350 3
	if (device_match(dev->dv_xname, "fhpib") == 0 ||
	    device_match(dev->dv_xname, "nhpib") == 0 ||
	    device_match(dev->dv_xname, "spc") == 0) {
d357 1
a357 1
	if (device_match(dev->dv_xname, "hd") == 0) {
d365 3
a367 3
	if (device_match(dev->dv_xname, "cd") == 0 ||
	    device_match(dev->dv_xname, "sd") == 0 ||
	    device_match(dev->dv_xname, "st") == 0) {
d384 2
a385 2
	if (device_match(dev->dv_xname, "fhpib") == 0 ||
	    device_match(dev->dv_xname, "nhpib") == 0) {
d390 1
a390 1
	if (device_match(dev->dv_xname, "spc") == 0) {
d453 1
a453 1
		     device_match(bootdv->dv_xname, "ct")) ||
d455 1
a455 1
		     device_match(bootdv->dv_xname, "hd"))) {
d478 3
a480 3
		if (device_match(bootdv->dv_xname, "cd") != 0 &&
		    device_match(bootdv->dv_xname, "sd") != 0 &&
		    device_match(bootdv->dv_xname, "st") != 0) {
d582 1
a582 1
	if (device_match(root_device->dv_xname, "hd") == 0)
d584 3
a586 3
	else if (device_match(root_device->dv_xname, "cd") == 0 ||
	    device_match(root_device->dv_xname, "sd") == 0 ||
	    device_match(root_device->dv_xname, "st") == 0)
@


1.45
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.44 2007/09/08 09:28:49 martin Exp $	*/
d229 3
@


1.44
log
@use M_ZERO.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2007/06/01 19:25:09 deraadt Exp $	*/
d873 1
@


1.43
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2007/06/01 19:20:46 deraadt Exp $	*/
d337 1
a337 1
	    M_DEVBUF, M_NOWAIT);
a339 1
	bzero(dd, sizeof(struct dev_data));
@


1.42
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2007/05/04 03:44:44 deraadt Exp $	*/
a162 1
void	diskconf(void);
a262 3

	md_diskconf = diskconf;

d267 1
a267 1
diskconf()
@


1.41
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2007/01/07 15:14:32 miod Exp $	*/
d871 1
a871 4
struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
d878 1
a879 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	register int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.40
log
@Trim include files list.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2006/11/28 16:56:50 dlg Exp $	*/
d110 1
a110 1
struct	device *booted_device;
a163 1
void	setroot(void);
a170 7
static	struct device *parsedisk(char *str, int len, int defpart,
	    dev_t *devp);
static	struct device *getdisk(char *str, int len, int defpart,
	    dev_t *devp);
static	int findblkmajor(struct device *dv);
static	char *findblkname(int);
static	int getstr(char *cp, int size);
d252 1
a252 1
		if (booted_device == NULL) {
d261 1
a261 1
			printf("boot device: %s\n", booted_device->dv_xname);
d273 15
d289 1
a289 1
	setroot();
a408 396
struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "ct",		0 },
	{ "hd",		2 },
	{ "sd",		4 },
	{ "st",		7 },
	{ "rd",		8 },
	{ "cd",		9 },
};

static int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	register int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name))
		    == 0)
			return (nam2blk[i].maj);
	return (-1);
}

static char *
findblkname(maj)
	int maj;
{
	register int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}

static struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf(" halt\n");
	}
	return (dv);
}

static struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);

	if (len == 4 && !strcmp(str, "halt"))
		boot(RB_HALT);

	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && c <= ('a' + MAXPARTITIONS - 1)) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot()
{
	struct swdevt *swp;
	struct device *dv;
	register int len;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128], *rootdevname;
	dev_t temp;
	struct device *bootdv, *rootdv, *swapdv;
	int bootpartition = 0;
#ifdef NFSCLIENT
	extern char *nfsbootdevname;
#endif

	bootdv = booted_device;

	/*
	 * If 'swap generic' and we couldn't determine root device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	/*
	 * If bootdev is bogus, ask the user anyhow.
	 */
	if (bootdev == 0)
		boothowto |= RB_ASKNAME;
	else
		bootpartition = B_PARTITION(bootdev);

	/*
	 * If we booted from tape, ask the user.
	 */
	if (bootdv != NULL && bootdv->dv_class == DV_TAPE)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device");
			if (bootdv != NULL) {
				printf(" (default %s", bootdv->dv_xname);
				if (bootdv->dv_class == DV_DISK)
					printf("%c", bootpartition + 'a');
				printf(")");
			}
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					rootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, bootpartition, &nrootdev);
			if (dv != NULL) {
				rootdv = dv;
				break;
			}
		}

		/*
		 * Because swap must be on the same device type as root,
		 * for network devices this is easy.
		 */
		if (rootdv->dv_class == DV_IFNET) {
			swapdv = NULL;
			goto gotswap;
		}
		for (;;) {
			printf("swap device");
			printf(" (default %s", rootdv->dv_xname);
			if (rootdv->dv_class == DV_DISK)
				printf("b");
			printf(")");
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				switch (rootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				swapdv = rootdv;
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				swapdv = dv;
				break;
			}
		}
 gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {
		int majdev;

		/*
		 * "swap generic"
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 */
			rootdv = swapdv = bootdv;
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit,
			    bootpartition);
			nswapdev = dumpdev =
			    MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			rootdv = swapdv = bootdv;
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honor rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */

#ifdef NFSCLIENT
		if (mountroot == nfs_mountroot) {
			struct dev_data *dd;
			/*
			 * `root on nfs'.  Find the first network
			 * interface.
			 */
			LIST_FOREACH(dd, &dev_data_list, dd_list) {
				if (dd->dd_dev->dv_class == DV_IFNET) {
					/* Got it! */
					break;
				}
			}
			if (dd == NULL) {
				printf("no network interface for NFS root");
				panic("setroot");
			}
			root_device = dd->dd_dev;
			return;
		}
#endif
		rootdevname = findblkname(major(rootdev));
		if (rootdevname == NULL) {
			root_device = NULL;	/* no device */
			return;
		}
		bzero(buf, sizeof(buf));
		snprintf(buf, sizeof buf, "%s%d", rootdevname,
		    DISKUNIT(rootdev));

		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (strcmp(buf, dv->dv_xname) == 0) {
				root_device = dv;
				break;
			}
		}
		root_device = dv;	/* NULL is fine. */
		return;
	}

	root_device = rootdv;
	switch (rootdv->dv_class) {
#ifdef NFSCLIENT
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = rootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		printf("root on %s%c", rootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		if (nswapdev != NODEV)
		    printf(" swap on %s%c", swapdv->dv_xname,
			DISKPART(nswapdev) + 'a');
		printf("\n");
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (major(rootdev) == major(swp->sw_dev) &&
		    DISKUNIT(rootdev) == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;

}

static int
getstr(cp, size)
	register char *cp;
	register int size;
{
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}

d416 1
a416 1
	booted_device = NULL;
d445 1
a445 1
				booted_device = dd->dd_dev;
d458 1
a458 1
		if (booted_device == NULL)
d466 1
a466 1
		     device_match(booted_device->dv_xname, "ct")) ||
d468 1
a468 1
		     device_match(booted_device->dv_xname, "hd"))) {
d471 2
a472 2
			    booted_device->dv_xname, type);
			booted_device = NULL;
d484 1
a484 1
		if (booted_device == NULL)
d491 3
a493 3
		if (device_match(booted_device->dv_xname, "cd") != 0 &&
		    device_match(booted_device->dv_xname, "sd") != 0 &&
		    device_match(booted_device->dv_xname, "st") != 0) {
d496 2
a497 2
			    booted_device->dv_xname, type);
			booted_device = NULL;
d544 1
a544 1
			booted_device = dd->dd_dev;
d869 35
@


1.39
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2006/06/24 13:20:17 miod Exp $	*/
a96 7

#include "sgc.h"

#if NSGC > 0
#include <hp300/dev/sgcreg.h>
#include <hp300/dev/sgcvar.h>
#endif
@


1.38
log
@Use pmap_kenter_cache() for device memory mapping, instead of physacc(0
which bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2005/12/31 18:13:44 miod Exp $	*/
d381 1
a381 1
		struct scsibus_attach_args *sa = aux;
@


1.37
log
@Rework (once again) the console code, in order to match the PROM's logic better.
When not running on serial console, the PROM will pick the ``internal''
graphics device, and if it does not exist, the DIO device with the lowest
select code, and will resort to SGC devices if no internal or DIO device
was found.

However, the current logic would search for a certain frame buffer type first,
then for its best hardware location, following the order they are listed
in conf.c.

By replacing gazillions of almost-exactly-duplicated frame buffer code with
one single instance, which is device type-agnostic, we can match the PROM
(and the bootblocks) logic again. Plus this saves a few KB of code!
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2005/12/30 18:14:12 miod Exp $	*/
d96 2
d1214 2
a1216 1
	caddr_t kva;
d1218 1
a1218 1
	if (size == 0)
d1221 4
a1224 4
#ifdef DEBUG
	if (((int)pa & PGOFSET) || (size & PGOFSET))
		panic("iomap: unaligned");
#endif
d1226 1
a1226 1
	    EX_NOWAIT | EX_MALLOCOK, (u_long *)&kva);
d1229 1
a1229 1
		return NULL;
d1231 9
a1239 2
	physaccess(kva, pa, size, PG_RW | PG_CI);
	return (kva);
d1246 2
a1247 2
iounmap(kva, size)
	caddr_t kva;
d1250 1
d1253 3
a1255 2
#ifdef DEBUG
	extern int eiomapsize;
d1257 2
a1258 9
	if (((int)kva & PGOFSET) || (size & PGOFSET))
		panic("iounmap: unaligned");
	if (kva < extiobase || kva >= extiobase + ctob(eiomapsize))
		panic("iounmap: bad address");
#endif

	physunaccess(kva, size);

	error = extent_free(extio, (u_long)kva, size, EX_NOWAIT);
d1260 2
d1264 1
@


1.36
log
@Kill conforced, and have console devices use CN_FORCED priority instead.
This means we are no longer aborting the console scans even if the final
console has been found, but on the other hand makes some logic simpler;
plus it will be necessary for upcoming scode vs device loop order reversal.
No user-visible change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2005/12/30 18:03:36 miod Exp $	*/
d1101 1
a1101 1
console_scan(func, arg, bus)
a1103 1
	int bus;
d1108 6
a1113 2
	switch (bus) {
	case HP300_BUS_DIO:
d1115 2
a1116 2
		 * Scan all select codes.  Check each location for some
		 * hardware.  If there's something there, call (*func)().
d1118 3
a1120 9
		sctop = DIO_SCMAX(machineid);
		for (scode = 0; scode < sctop; ++scode) {
			/*
			 * Skip over the select code hole and
			 * the internal HP-IB controller.
			 */
			if (DIO_INHOLE(scode) ||
			    ((scode == 7) && internalhpib))
				continue;
d1122 5
a1126 5
			/* Map current PA. */
			pa = dio_scodetopa(scode);
			va = iomap(pa, PAGE_SIZE);
			if (va == NULL)
				continue;
d1128 2
a1129 12
			/* Check to see if hardware exists. */
			if (badaddr(va)) {
				iounmap(va, PAGE_SIZE);
				continue;
			}

			/*
			 * Hardware present, call callback.  Driver returns
			 * size of region to map if console probe successful
			 * and worthwhile.
			 */
			size = (*func)(scode, va, arg);
d1131 1
a1131 15
			if (size != 0 && conscode == scode) {
				/* Free last mapping. */
				if (convasize)
					iounmap(conaddr, convasize);
				convasize = 0;

				/* Remap to correct size. */
				va = iomap(pa, size);
				if (va == NULL)
					continue;

				/* Save this state for next time. */
				conaddr = va;
				convasize = size;
			}
d1133 1
a1133 3
		break;
#if NSGC > 0
	case HP300_BUS_SGC:
d1135 3
a1137 2
		 * Scan all slots.  Check each location for some
		 * hardware.  If there's something there, call (*func)().
d1139 7
a1145 2
		for (scode = 0; scode < SGC_NSLOTS; ++scode) {
			int rv;
d1147 2
a1148 3
			/* Map current PA. */
			pa = sgc_slottopa(scode);
			va = iomap(pa, PAGE_SIZE);
d1152 3
a1154 21
			/* Check for hardware. */
			rv = badaddr(va);
			iounmap(va, PAGE_SIZE);
			if (rv != 0)
				continue;

			/*
			 * Invoke the callback. Driver will return
			 * non-zero if console probe successfull
			 * and worthwhile.
			 */
			if ((*func)(scode, NULL, arg) != 0 &&
			    conscode == SGC_SLOT_TO_CONSCODE(scode)) {
				/* Free last mapping. */
				if (convasize)
					iounmap(conaddr, convasize);

				/* Save this state for next time. */
				conaddr = NULL;
				convasize = 0;
			}
a1155 2
		break;
#endif
@


1.35
log
@When a driver claims console, let it set conscode to itself, instead of
letting the bus walkers do this for it. This is necessary since apci does
not use the bus walkers, now that we do not force console probes to stop
when apci claims console.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2005/12/27 18:31:08 miod Exp $	*/
a1117 6
			 * Abort mission if console has been forced.
			 */
			if (conforced)
				return;

			/*
a1168 6

			/*
			 * Abort mission if console has been forced.
			 */
			if (conforced)
				return;
@


1.34
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2005/02/27 22:08:41 miod Exp $	*/
d1150 1
a1150 1
			if (size != 0) {
a1161 1
				conscode = scode;
d1199 2
a1200 1
			if ((*func)(scode, NULL, arg) != 0) {
a1205 1
				conscode = SGC_SLOT_TO_CONSCODE(scode);
@


1.33
log
@Invoke hp300_cninit() twice, with a global variable letting the
console-dependent routines know which pass they are being invoked in.

The first pass is the usual console detection code. The second pass runs
after uvm is initialized, and will allow devices which need VM services to
run to claim the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2005/02/22 22:11:45 miod Exp $	*/
a169 1
void	swapconf(void);
d288 1
a288 1
	swapconf();
a404 24
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	int nblks, maj;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		maj = major(swp->sw_dev);
		if (maj > nblkdev)
			break;
		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
	dumpconf();
@


1.32
log
@Be sure to attach the console keyboard, if any, before prompting for an
alternate root device if boot -a.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2005/01/16 17:43:04 millert Exp $	*/
d1225 1
a1225 2
			size = (*func)(scode, NULL, arg);
			if (size) {
d1241 2
d1248 1
a1248 1
hp300_cninit()
d1253 2
a1254 1
	cn_tab = NULL;
d1256 6
a1261 5
	/*
	 * Call all of the console probe functions.
	 */
	for (cp = constab; cp->cn_probe; cp++)
		(*cp->cn_probe)(cp);
d1271 4
d1276 3
a1278 1
	(*cn_tab->cn_init)(cn_tab);
@


1.31
log
@Allow this to build w/o SGC; OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2005/01/14 22:39:27 miod Exp $	*/
d168 1
d279 9
d292 1
a292 1
	 * Set bootdev based on how we mounted root.
a295 2

	cold = 0;
@


1.30
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2005/01/09 00:09:51 miod Exp $	*/
d1123 1
a1123 1
	int rv, size, scode, sctop;
d1192 2
@


1.29
log
@When checking device names, make sure we look for a device name immediately
followed by an unit number. Otherwise we will match sti0 as an scsi tape drive.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2004/12/30 21:26:14 miod Exp $	*/
d79 1
a90 4
#include <hp300/dev/grfreg.h>
#include <hp300/dev/hilreg.h>
#include <hp300/dev/hilioctl.h>
#include <hp300/dev/hilvar.h>
d96 7
d183 1
a183 1
static	int getstr(char *cp, int size);  
a249 13
	/*
	 * XXX In order for the HIL to configure, interrupts need to be
	 * XXX enabled.  However, we need to initialize the HIL driver's
	 * XXX software state prior to that, since a pending interrupt
	 * XXX might cause the HIL's interrupt handler to be run in an
	 * XXX uninitialized environment otherwise.
	 *
	 * XXX These should be consolidated into some kind of table.
	 */
	hilsoftinit(0, HILADDR);
	(void)spl0();
	hilinit(0, HILADDR);

d716 1
a716 1
		
d775 1
a775 1
getstr(cp, size) 
d780 1
a780 1
	register int c; 
d783 1
a783 1
	lp = cp;         
d895 2
a896 2
		if (booted_device == NULL)  
			return; 
d908 1
a908 1
			booted_device = NULL; 
d1118 1
a1118 1
console_scan(func, arg)
d1121 1
d1123 1
a1123 1
	int size, scode, sctop;
d1126 2
a1127 6
	/*
	 * Scan all select codes.  Check each location for some
	 * hardware.  If there's something there, call (*func)().
	 */
	sctop = DIO_SCMAX(machineid);
	for (scode = 0; scode < sctop; ++scode) {
d1129 2
a1130 1
		 * Abort mission if console has been forced.
d1132 15
a1146 2
		if (conforced)
			return;
d1148 5
a1152 7
		/*
		 * Skip over the select code hole and
		 * the internal HP-IB controller.
		 */
		if (((scode >= 32) && (scode < 132)) ||
		    ((scode == 7) && internalhpib))
			continue;
d1154 5
a1158 5
		/* Map current PA. */
		pa = dio_scodetopa(scode);
		va = iomap(pa, NBPG);
		if (va == 0)
			continue;
d1160 23
a1182 4
		/* Check to see if hardware exists. */
		if (badaddr(va)) {
			iounmap(va, NBPG);
			continue;
d1184 3
a1186 1

d1188 2
a1189 3
		 * Hardware present, call callback.  Driver returns
		 * size of region to map if console probe successful
		 * and worthwhile.
d1191 17
a1207 11
		size = (*func)(scode, va, arg);
		iounmap(va, NBPG);
		if (size) {
			/* Free last mapping. */
			if (convasize)
				iounmap(conaddr, convasize);
			convasize = 0;

			/* Remap to correct size. */
			va = iomap(pa, size);
			if (va == 0)
d1210 16
a1225 4
			/* Save this state for next time. */
			conscode = scode;
			conaddr = va;
			convasize = size;
d1227 2
d1291 2
a1292 2
	physaccess(kva, pa, size, PG_RW|PG_CI);
	return(kva);
@


1.28
log
@Kill the EIOMAPSIZE and instead, dynamically size the external I/O map,
based on the DIO-II space probing results.

This does not win much for now, but this will be very useful for SGC bus
support (coming soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2004/12/25 23:02:24 miod Exp $	*/
d180 1
d303 17
d361 3
a363 3
	if (strncmp(dev->dv_xname, "fhpib", 5) == 0 ||
	    strncmp(dev->dv_xname, "nhpib", 5) == 0 ||
	    strncmp(dev->dv_xname, "spc", 3) == 0) {
d370 1
a370 1
	if (strncmp(dev->dv_xname, "hd", 2) == 0) {
d378 3
a380 3
	if (strncmp(dev->dv_xname, "cd", 2) == 0 ||
	    strncmp(dev->dv_xname, "sd", 2) == 0 ||
	    strncmp(dev->dv_xname, "st", 2) == 0) {
d397 2
a398 2
	if (strncmp(dev->dv_xname, "fhpib", 5) == 0 ||
	    strncmp(dev->dv_xname, "nhpib", 5) == 0) {
d403 1
a403 1
	if (strncmp(dev->dv_xname, "spc", 3) == 0) {
d885 4
a888 2
		if ((type == 0 && strncmp(booted_device->dv_xname, "ct", 2)) ||
		    (type == 2 && strncmp(booted_device->dv_xname, "hd", 2))) {
d911 3
a913 3
		if (strncmp(booted_device->dv_xname, "cd", 2) != 0 &&
		    strncmp(booted_device->dv_xname, "sd", 2) != 0 &&
		    strncmp(booted_device->dv_xname, "st", 2) != 0) {
d1015 1
a1015 1
	if (strncmp(root_device->dv_xname, "hd", 2) == 0)
d1017 3
a1019 3
	else if (strncmp(root_device->dv_xname, "cd", 2) == 0 ||
	    strncmp(root_device->dv_xname, "sd", 2) == 0 ||
	    strncmp(root_device->dv_xname, "st", 2) == 0)
@


1.27
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2004/08/03 21:46:58 miod Exp $	*/
d1246 2
d1250 1
a1250 1
	if (kva < extiobase || kva >= extiobase + ctob(EIOMAPSIZE))
@


1.26
log
@Replace the old 4.4BSD scsi code used on hp300 with a ``real'' driver
interfaced with the MI scsi code.

Adapted from NetBSD with some changes (especially to get tape and old
cd-rom drives to not cause the driver to spin during probe).

Tested by millert@@ and I, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2003/06/02 23:27:45 millert Exp $	*/
d463 1
a463 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d500 1
a500 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d685 1
a685 2
			for (dd = dev_data_list.lh_first;
			    dd != NULL; dd = dd->dd_list.le_next) {
d708 1
a708 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d842 1
a842 2
		for (dd = dev_data_list.lh_first; dd != NULL;
		    dd = dd->dd_list.le_next) {
d917 2
a918 2
	for (cdd = ddlist->lh_first; ctlr != 0 && cdd != NULL;
	    cdd = cdd->dd_clist.le_next)
d931 1
a931 2
	for (dd = dev_data_list.lh_first; dd != NULL;
	    dd = dd->dd_list.le_next) {
d1013 3
a1015 2
	for (cdd = dev_data_list_hpib.lh_first, ctlr = 0;
	    cdd != NULL; cdd = cdd->dd_clist.le_next, ctlr++) {
d1028 2
a1029 1
	for (dd = dev_data_list.lh_first; dd != NULL; ) {
d1031 1
a1031 1
		dd = dd->dd_list.le_next;
d1045 1
a1045 1
	for (dd = dev_data_list.lh_first; dd != NULL; dd = dd->dd_list.le_next)
a1067 2
	de = ddlist->lh_first;

d1071 1
a1071 1
	if (de == NULL) {
d1081 3
a1083 1
	for (; de->dd_clist.le_next != NULL; de = de->dd_clist.le_next) {
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2003/05/10 21:11:12 deraadt Exp $	*/
d96 2
a97 1
#include <hp300/dev/scsivar.h>
a103 1
int	cold;		    /* if 1, still working on cold-start */
d343 3
a345 3
	if (bcmp(dev->dv_xname, "fhpib", 5) == 0 ||
	    bcmp(dev->dv_xname, "nhpib", 5) == 0 ||
	    bcmp(dev->dv_xname, "oscsi", 5) == 0) {
d352 1
a352 1
	if (bcmp(dev->dv_xname, "hd", 2) == 0) {
d360 4
a363 2
	if (bcmp(dev->dv_xname, "sd", 2) == 0) {
		struct oscsi_attach_args *osa = aux;
d365 2
a366 2
		dd->dd_slave = osa->osa_target;
		dd->dd_punit = osa->osa_lun;
d379 2
a380 2
	if (bcmp(dev->dv_xname, "fhpib", 5) == 0 ||
	    bcmp(dev->dv_xname, "nhpib", 5) == 0) {
d385 1
a385 1
	if (bcmp(dev->dv_xname, "oscsi", 5) == 0) {
d422 1
d424 1
d867 1
d871 2
a872 2
		if ((type == 0 && bcmp(booted_device->dv_xname, "ct", 2)) ||
		    (type == 2 && bcmp(booted_device->dv_xname, "hd", 2))) {
d878 1
d891 1
d895 3
a897 1
		if ((type == 4 && bcmp(booted_device->dv_xname, "sd", 2))) {
d903 1
d938 2
a939 3
		 * XXX We don't yet have the extra bus indirection
		 * XXX for SCSI, so we have to do a little bit of
		 * XXX extra work.
d941 2
a942 13
		if (bcmp(dd->dd_dev->dv_xname, "sd", 2) == 0) {
			/*
			 * "sd" -> "oscsi"
			 */
			if (dd->dd_dev->dv_parent != cdd->dd_dev)
				continue;
		} else {
			/*
			 * "hd" -> "hpibbus" -> "fhpib"
			 */
			if (dd->dd_dev->dv_parent->dv_parent != cdd->dd_dev)
				continue;
		}
d966 1
a966 1
	 *	4 == sd
d969 4
a972 4
	 * Allare bdevsw major numbers, except for le, which
	 * is just special.
	 *
	 * We can't mount root on a tape, so we ignore those.
d1000 1
a1000 1
	if (bcmp(root_device->dv_xname, "hd", 2) == 0)
d1002 4
a1005 1
	else if (bcmp(root_device->dv_xname, "sd", 2) == 0)
d1014 3
d1018 9
a1026 16
	switch (type) {
	case 2:
		/*
		 * "hd" -> "hpibbus" -> "fhpib"
		 */
		for (cdd = dev_data_list_hpib.lh_first, ctlr = 0;
		    cdd != NULL; cdd = cdd->dd_clist.le_next, ctlr++) {
			if (cdd->dd_dev == root_device->dv_parent->dv_parent) {
				/*
				 * Found it!
				 */
				bootdev = MAKEBOOTDEV(type,
				    ctlr, dd->dd_slave, dd->dd_punit,
				    DISKPART(rootdev));
				break;
			}
a1027 19
		break;

	case 4:
		/*
		 * "sd" -> "oscsi"
		 */
		for (cdd = dev_data_list_scsi.lh_first, ctlr = 0;
		    cdd != NULL; cdd = cdd->dd_clist.le_next, ctlr++) { 
			if (cdd->dd_dev == root_device->dv_parent) {
				/*
				 * Found it!
				 */
				bootdev = MAKEBOOTDEV(type,
				    ctlr, dd->dd_slave, dd->dd_punit,
				    DISKPART(rootdev));
				break;
			}
		}
		break;
d1067 1
a1067 2
		printf("bogus select code for %s\n", dd->dd_dev->dv_xname);
		panic("dev_data_insert");
@


1.24
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2002/03/14 01:26:30 millert Exp $	*/
d34 1
a34 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2002/02/04 19:38:18 miod Exp $	*/
d582 1
a582 1
				strcpy(buf, bootdv->dv_xname);
d707 2
a708 1
		sprintf(buf, "%s%d", rootdevname, DISKUNIT(rootdev));
@


1.22
log
@Cleanup mountroot-related definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2002/01/16 20:51:45 miod Exp $	*/
d168 20
a187 20
void	setroot __P((void));
void	swapconf __P((void));
void	findbootdev __P((void));
void	findbootdev_slave __P((ddlist_t *, int, int, int));
void	setbootdev __P((void));

static	struct dev_data *dev_data_lookup __P((struct device *));
static	void dev_data_insert __P((struct dev_data *, ddlist_t *));

static	struct device *parsedisk __P((char *str, int len, int defpart,
	    dev_t *devp));
static	struct device *getdisk __P((char *str, int len, int defpart,
	    dev_t *devp));
static	int findblkmajor __P((struct device *dv));
static	char *findblkname __P((int));
static	int getstr __P((char *cp, int size));  

int	mainbusmatch __P((struct device *, void *, void *));
void	mainbusattach __P((struct device *, struct device *, void *));
int	mainbussearch __P((struct device *, void *, void *));
d1137 1
a1137 1
	int (*func) __P((int, caddr_t, void *));
@


1.21
log
@Replace resource maps with extents.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2001/12/10 00:58:02 miod Exp $	*/
a539 1
	extern int (*mountroot) __P((void));
a544 1
	extern int nfs_mountroot __P((void));
a545 1
	extern int dk_mountroot __P((void));
@


1.20
log
@No need to include <sys/dmap.h> and define related variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2001/09/19 21:32:19 miod Exp $	*/
d74 1
a74 1
#include <sys/map.h>
d109 1
a109 2
/* XXX must be allocated statically because of early console init */
struct	map extiomap[EIOMAPSIZE/16];
d1247 1
a1247 1
	int ix, npf;
d1250 3
d1257 6
a1262 5
	npf = btoc(size);
	ix = rmalloc(extiomap, npf);
	if (ix == 0)
		return(0);
	kva = extiobase + ctob(ix-1);
d1275 1
a1275 1
	int ix;
d1283 1
d1285 5
a1289 2
	ix = btoc(kva - extiobase) + 1;
	rmfree(extiomap, btoc(size), ix);
@


1.20.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2002/01/16 20:51:45 miod Exp $	*/
d74 1
a74 1
#include <sys/extent.h>
d109 2
a110 1
struct	extent *extio;
d1248 1
a1248 1
	int error;
a1250 3
	if (size == 0)
		return NULL;

d1255 5
a1259 6
	error = extent_alloc(extio, size, PAGE_SIZE, 0, EX_NOBOUNDARY,
	    EX_NOWAIT | EX_MALLOCOK, (u_long *)&kva);

	if (error != 0)
		return NULL;

d1272 1
a1272 1
	int error;
a1279 1

d1281 2
a1282 5

	error = extent_free(extio, (u_long)kva, size, EX_NOWAIT);

	if (error != 0)
		printf("iounmap: extent_free failed\n");
@


1.20.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20.2.1 2002/01/31 22:55:08 niklas Exp $	*/
d168 20
a187 20
void	setroot(void);
void	swapconf(void);
void	findbootdev(void);
void	findbootdev_slave(ddlist_t *, int, int, int);
void	setbootdev(void);

static	struct dev_data *dev_data_lookup(struct device *);
static	void dev_data_insert(struct dev_data *, ddlist_t *);

static	struct device *parsedisk(char *str, int len, int defpart,
	    dev_t *devp);
static	struct device *getdisk(char *str, int len, int defpart,
	    dev_t *devp);
static	int findblkmajor(struct device *dv);
static	char *findblkname(int);
static	int getstr(char *cp, int size);  

int	mainbusmatch(struct device *, void *, void *);
void	mainbusattach(struct device *, struct device *, void *);
int	mainbussearch(struct device *, void *, void *);
d540 1
d546 1
d548 1
d1140 1
a1140 1
	int (*func)(int, caddr_t, void *);
@


1.20.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d582 1
a582 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d707 1
a707 2
		snprintf(buf, sizeof buf, "%s%d", rootdevname,
		    DISKUNIT(rootdev));
@


1.19
log
@Now is a good time to commit this cosmetic maxpartition-related change...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2001/05/05 22:33:33 art Exp $	*/
a72 1
#include <sys/dmap.h>
@


1.18
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 1999/05/25 08:37:49 downsj Exp $	*/
d468 1
a468 1
				printf(" %s[a-h]", dv->dv_xname);
@


1.17
log
@Move hilsoftinit() call to before interrupts are enabled, from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 1997/07/06 08:01:57 downsj Exp $	*/
d62 1
a62 1
 * Configure() is called at boot time.  Available
d242 1
a242 1
configure()
@


1.17.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 1999/05/25 08:37:49 downsj Exp $	*/
d62 1
a62 1
 * cpu_configure() is called at boot time.  Available
d242 1
a242 1
cpu_configure()
@


1.17.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17.4.1 2001/07/04 10:15:36 niklas Exp $	*/
d468 1
a468 1
				printf(" %s[a-p]", dv->dv_xname);
@


1.17.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 1
d75 1
a75 1
#include <sys/extent.h>
d110 2
a111 1
struct	extent *extio;
d542 1
d548 1
d550 1
d1249 1
a1249 1
	int error;
a1251 3
	if (size == 0)
		return NULL;

d1256 5
a1260 6
	error = extent_alloc(extio, size, PAGE_SIZE, 0, EX_NOBOUNDARY,
	    EX_NOWAIT | EX_MALLOCOK, (u_long *)&kva);

	if (error != 0)
		return NULL;

d1273 1
a1273 1
	int error;
a1280 1

d1282 2
a1283 5

	error = extent_free(extio, (u_long)kva, size, EX_NOWAIT);

	if (error != 0)
		printf("iounmap: extent_free failed\n");
@


1.17.4.4
log
@Merge in -current from about a week ago
@
text
@d168 20
a187 20
void	setroot(void);
void	swapconf(void);
void	findbootdev(void);
void	findbootdev_slave(ddlist_t *, int, int, int);
void	setbootdev(void);

static	struct dev_data *dev_data_lookup(struct device *);
static	void dev_data_insert(struct dev_data *, ddlist_t *);

static	struct device *parsedisk(char *str, int len, int defpart,
	    dev_t *devp);
static	struct device *getdisk(char *str, int len, int defpart,
	    dev_t *devp);
static	int findblkmajor(struct device *dv);
static	char *findblkname(int);
static	int getstr(char *cp, int size);  

int	mainbusmatch(struct device *, void *, void *);
void	mainbusattach(struct device *, struct device *, void *);
int	mainbussearch(struct device *, void *, void *);
d1137 1
a1137 1
	int (*func)(int, caddr_t, void *);
@


1.17.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17.4.4 2002/03/28 10:07:18 niklas Exp $	*/
d582 1
a582 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d707 1
a707 2
		snprintf(buf, sizeof buf, "%s%d", rootdevname,
		    DISKUNIT(rootdev));
@


1.17.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17.4.5 2003/05/13 19:41:02 ho Exp $	*/
d34 5
a38 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.15 1997/04/16 11:56:20 downsj Exp $	*/
/*	$NetBSD: autoconf.c,v 1.38 1997/05/05 21:11:59 thorpej Exp $	*/
d252 7
a258 2
	 * XXX Enable interrupts.  We have to do this now so that the
	 * XXX HIL configures.
d260 1
a261 5

	/*
	 * XXX: these should be consolidated into some kind of table
	 */
	hilsoftinit(0, HILADDR);
d318 1
a318 1
	static int seen_netdevice;
@


1.15
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.14 1997/02/20 18:13:37 downsj Exp $	*/
/*	$NetBSD: autoconf.c,v 1.36 1997/04/14 02:28:43 thorpej Exp $	*/
d86 1
a261 1
	dmainit();
@


1.14
log
@Fix for NetBSD's bug from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.13 1997/02/16 17:54:40 downsj Exp $	*/
/*	$NetBSD: autoconf.c,v 1.33 1997/02/05 20:56:29 thorpej Exp $	*/
a68 2
#include <sys/map.h>
#include <sys/malloc.h>
d70 2
a72 2
#include <sys/device.h>
#include <sys/conf.h>
d74 2
a75 2
#include <sys/reboot.h>
#include <sys/device.h>
d78 2
d86 1
a88 2
#include <hp300/hp300/isr.h>

d93 1
d96 2
a249 3
	/* Initialize the interrupt system. */
	isrinit();

d268 1
a268 1
	isrprintlevels();
@


1.13
log
@Fix autoconfiguration code, so that it can actually boot from pdevs.
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.12 1997/02/16 14:37:10 downsj Exp $	*/
/*	$NetBSD: autoconf.c,v 1.31 1997/01/31 01:49:41 thorpej Exp $	*/
a1021 1
	cdd = dev_data_lookup(root_device->dv_parent);
@


1.12
log
@More rd changes that were missed...  Still not working.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 1997/02/03 08:11:59 downsj Exp $	*/
d708 2
a709 2
			printf("unknown root device major 0x%x\n", rootdev);
			panic("setroot");
d721 1
a721 6
		if (dv == NULL) {
			printf("device %s (0x%x) not configured\n",
			    buf, rootdev);
			panic("setroot");
		}

a725 1

d989 6
@


1.11
log
@rd -> hd
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 1997/02/03 04:47:54 downsj Exp $	*/
d426 1
@


1.10
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 1997/01/18 06:43:05 downsj Exp $	*/
d358 1
a358 1
	if (bcmp(dev->dv_xname, "rd", 2) == 0) {
d424 1
a424 1
	{ "rd",		2 },
d841 1
a841 1
	hpibboot = (type == 0 || type == 2);	/* ct/rd major */
d880 1
a880 1
		    (type == 2 && bcmp(booted_device->dv_xname, "rd", 2))) {
d953 1
a953 1
			 * "rd" -> "hpibbus" -> "fhpib"
d980 1
a980 1
	 *	2 == rd
d1009 1
a1009 1
	if (bcmp(root_device->dv_xname, "rd", 2) == 0)
d1025 1
a1025 1
		 * "rd" -> "hpibbus" -> "fhpib"
@


1.9
log
@dk_mountroot(), hp300 style.
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.8 1997/01/13 18:03:55 downsj Exp $	*/
/*	$NetBSD: autoconf.c,v 1.29 1996/12/17 08:41:19 thorpej Exp $	*/
d78 1
a93 1
#include <hp300/dev/device.h>
d97 3
a166 32
#if 1			/* XXX for now */
struct scsi_link {
	int	target;
	int	lun;
};

struct scsibus_attach_args {
	struct	scsi_link *sa_scsi_link;
};

struct hpib_attach_args {
	int	ha_slave;
	int	ha_punit;
};
#endif /* XXX */

#ifndef NEWCONFIG	/* XXX */
struct	hp_hw sc_table[MAXCTLRS];

#ifdef DEBUG
int	acdebug = 0;
#endif

struct	devicelist alldevs;
struct	evcntlist allevents;

struct	dio_attach_args hp300_dio_attach_args;
struct	scsi_link hp300_scsi_link;
struct	scsibus_attach_args hp300_scsibus_attach_args;
struct	hpib_attach_args hp300_hpib_attach_args;
#endif /* ! NEWCONFIG */

d184 1
a184 2
#ifdef NEWCONFIG
int	mainbusmatch __P((struct device *, struct cfdata *, void *));
d186 1
a186 1
int	mainbussearch __P((struct device *, struct cfdata *, void *));
d199 1
a199 2
	struct cfdata *match;
	void *aux;
d224 1
a224 1
mainbussearch(parent, cf, aux)
d226 1
a226 2
	struct cfdata *cf;
	void *aux;
d228 1
a233 1
#endif /* NEWCONFIG */
a240 3
	register struct hp_hw *hw;
	int found;

a263 1
#ifdef NEWCONFIG
a267 37
#else
	/*
	 * Find out what hardware is attached to the machine.
	 */
	find_devs();

	/*
	 * Look over each hardware device actually found and attempt
	 * to match it with an ioconf.c table entry.
	 */
	for (hw = sc_table; hw->hw_type; hw++) {
		if (HW_ISCTLR(hw))
			found = find_controller(hw);
		else
			found = find_device(hw);

		if (!found) {
			extern char *dio_devinfo __P((struct dio_attach_args *,
			    char *, size_t));
			int sc = hw->hw_sc;
			char descbuf[80];

			bzero(&hp300_dio_attach_args,
			    sizeof(hp300_dio_attach_args));
			hp300_dio_attach_args.da_scode = sc;
			hp300_dio_attach_args.da_id = hw->hw_id;
			hp300_dio_attach_args.da_secid = hw->hw_secid;
			printf("%s", dio_devinfo(&hp300_dio_attach_args,
			    descbuf, sizeof(descbuf)));
			if (sc >= 0 && sc < 256)
				printf(" at scode %d", sc);
			else
				printf(" csr at 0x%lx", (u_long)hw->hw_pa);
			printf(" not configured\n");
		}
	}
#endif /* NEWCONFIG */
d349 3
a351 2
	if (bcmp(dev->dv_xname, "hpib", 4) == 0 ||
	    bcmp(dev->dv_xname, "scsi", 4) == 0) {
d359 1
a359 1
		struct hpib_attach_args *ha = aux;
d367 1
a367 1
		struct scsibus_attach_args *sa = aux;
d369 2
a370 2
		dd->dd_slave = sa->sa_scsi_link->target;
		dd->dd_punit = sa->sa_scsi_link->lun;
d383 2
a384 1
	if (bcmp(dev->dv_xname, "hpib", 4) == 0) {
d389 1
a389 1
	if (bcmp(dev->dv_xname, "scsi", 4) == 0) {
d940 20
a959 2
		if (dd->dd_dev->dv_parent == cdd->dd_dev &&
		    dd->dd_slave == slave &&
d1024 3
d1029 1
a1029 1
			if (cdd->dd_dev == root_device->dv_parent) {
d1042 3
a1284 792

/**********************************************************************
 * Old-style device configuration code
 **********************************************************************/

#ifndef NEWCONFIG

/*
 * Duplicate of the same in subr_autoconf.c
 */
void
config_init()
{

	TAILQ_INIT(&alldevs);
	TAILQ_INIT(&allevents);
}

#define dr_type(d, s)	\
	(strcmp((d)->d_name, (s)) == 0)

#define same_hw_ctlr(hw, hc) \
	(HW_ISHPIB(hw) && dr_type((hc)->hp_driver, "hpib") || \
	 HW_ISSCSI(hw) && dr_type((hc)->hp_driver, "scsi"))

find_controller(hw)
	register struct hp_hw *hw;
{
	register struct hp_ctlr *hc;
	struct hp_ctlr *match_c;
	caddr_t oaddr;
	int sc;

#ifdef DEBUG
	if (acdebug)
		printf("find_controller: hw: id%x at sc%d (%x), type %x...",
		       hw->hw_id, hw->hw_sc, hw->hw_kva, hw->hw_type);
#endif
	sc = hw->hw_sc;
	match_c = NULL;
	for (hc = hp_cinit; hc->hp_driver; hc++) {
		if (hc->hp_alive)
			continue;
		/*
		 * Make sure we are looking at the right
		 * controller type.
		 */
		if (!same_hw_ctlr(hw, hc))
			continue;
		/*
		 * Exact match; all done
		 */
		if ((int)hc->hp_addr == sc) {
			match_c = hc;
			break;
		}
		/*
		 * Wildcard; possible match so remember first instance
		 * but continue looking for exact match.
		 */
		if (hc->hp_addr == NULL && match_c == NULL)
			match_c = hc;
	}
#ifdef DEBUG
	if (acdebug) {
		if (match_c)
			printf("found %s%d\n",
			       match_c->hp_driver->d_name,
			       match_c->hp_unit);
		else
			printf("not found\n");
	}
#endif
	/*
	 * Didn't find an ioconf entry for this piece of hardware,
	 * just ignore it.
	 */
	if (match_c == NULL)
		return(0);
	/*
	 * Found a configuration match, now let's see if the hardware
	 * agrees with us.  If it does, attach it.
	 */
	hc = match_c;
	oaddr = hc->hp_addr;
	hc->hp_addr = hw->hw_kva;
	hc->hp_args = hw;
	if ((*hc->hp_driver->d_match)(hc)) {
		hc->hp_alive = 1;

		/*
		 * Fill in fake device structure.
		 */
		bzero(&hc->hp_dev, sizeof(hc->hp_dev));
		hc->hp_dev.dv_unit = hc->hp_unit;
		sprintf(hc->hp_dev.dv_xname, "%s%d", hc->hp_driver->d_name,
		    hc->hp_unit);
		hc->hp_dev.dv_class = DV_DULL;	/* all controllers are dull */
		TAILQ_INSERT_TAIL(&alldevs, &hc->hp_dev, dv_list);

		/* Print what we've found. */
		printf("%s at ", hc->hp_xname);
		sc = hw->hw_sc;
		if (sc >= 0 && sc < 256)
			printf("scode %d", sc);
		else
			printf("addr 0x%lx,", (u_long)hw->hw_pa);
		printf(" ipl %d", hc->hp_ipl);
		if (hc->hp_flags)
			printf(" flags 0x%x", hc->hp_flags);

		/*
		 * Call device "attach" routine.  It will print the
		 * newline for us.
		 */
		(*hc->hp_driver->d_attach)(hc);

		/*
		 * Register device.  Do this after attach because
		 * we need dv_class.
		 */
		hp300_dio_attach_args.da_scode = sc;
		device_register(&hc->hp_dev, &hp300_dio_attach_args);

		find_slaves(hc);	/* XXX do this in attach? */
	} else
		hc->hp_addr = oaddr;
	return(1);
}

find_device(hw)
	register struct hp_hw *hw;
{
	register struct hp_device *hd;
	struct hp_device *match_d;
	caddr_t oaddr;
	int sc;

#ifdef DEBUG
	if (acdebug)
		printf("find_device: hw: id%x at sc%d (%x), type %x...",
		       hw->hw_id, hw->hw_sc, hw->hw_kva, hw->hw_type);
#endif
	match_d = NULL;
	for (hd = hp_dinit; hd->hp_driver; hd++) {
		if (hd->hp_alive)
			continue;
		/* Must not be a slave */
		if (hd->hp_cdriver)
			continue;
		/*
		 * XXX: A graphics device that was found as part of the
		 * console init will have the hp_addr field already set
		 * (i.e. no longer the select code).  Gotta perform a
		 * slightly different check for an exact match.
		 */
		if (HW_ISDEV(hw, D_BITMAP) && hd->hp_addr >= intiobase) {
			/* must be an exact match */
			if (hd->hp_addr == hw->hw_kva) {
				match_d = hd;
				break;
			}
			continue;
		}
		sc = (int) hd->hp_addr;
		/*
		 * Exact match; all done.
		 */
		if (sc > 0 && sc == hw->hw_sc) {
			match_d = hd;
			break;
		}
		/*
		 * Wildcard; possible match so remember first instance
		 * but continue looking for exact match.
		 */
		if (sc == 0 && same_hw_device(hw, hd) && match_d == NULL)
			match_d = hd;
	}
#ifdef DEBUG
	if (acdebug) {
		if (match_d)
			printf("found %s%d\n",
			       match_d->hp_driver->d_name,
			       match_d->hp_unit);
		else
			printf("not found\n");
	}
#endif
	/*
	 * Didn't find an ioconf entry for this piece
	 * of hardware, just ignore it.
	 */
	if (match_d == NULL)
		return(0);
	/*
	 * Found a configuration match, now let's see if the hardware
	 * agrees with us.  If it does, attach it.
	 */
	hd = match_d;
	oaddr = hd->hp_addr;
	hd->hp_addr = hw->hw_kva;
	hd->hp_args = hw;
	if ((*hd->hp_driver->d_match)(hd)) {
		hd->hp_alive = 1;

		/*
		 * Fill in fake device structure.
		 */
		bzero(&hd->hp_dev, sizeof(sizeof hd->hp_dev));
		hd->hp_dev.dv_unit = hd->hp_unit;
		sprintf(hd->hp_dev.dv_xname, "%s%d", hd->hp_driver->d_name,
		    hd->hp_unit);
		/*
		 * Default to dull, driver attach will override if
		 * necessary.
		 */
		hd->hp_dev.dv_class = DV_DULL;
		TAILQ_INSERT_TAIL(&alldevs, &hd->hp_dev, dv_list);

		/* Print what we've found. */
		printf("%s at ", hd->hp_xname);
		sc = hw->hw_sc;
		if (sc >= 0 && sc < 256)
			printf("scode %d", sc);
		else
			printf("addr 0x%lx", (u_long)hw->hw_pa);
		if (hd->hp_ipl)
			printf(" ipl %d", hd->hp_ipl);
		if (hd->hp_flags)
			printf(" flags 0x%x", hd->hp_flags);

		/*
		 * Call device "attach" routine.  It will print the
		 * newline for us.
		 */
		(*hd->hp_driver->d_attach)(hd);

		/*
		 * Register device.  Do this after attach because we
		 * need dv_class.
		 */
		hp300_dio_attach_args.da_scode = sc;
		device_register(&hd->hp_dev, &hp300_dio_attach_args);
	} else
		hd->hp_addr = oaddr;
	return(1);
}

find_slaves(hc)
	struct hp_ctlr *hc;
{
	/*
	 * The SCSI bus is structured very much like the HP-IB 
	 * except that the host adaptor is slave 7 so we only want
	 * to look at the first 6 slaves.
	 */
	if (dr_type(hc->hp_driver, "hpib"))
		find_busslaves(hc, 0, MAXSLAVES-1);
	else if (dr_type(hc->hp_driver, "scsi"))
#ifdef SCSI_REVPRI
		/*
		 * Later releases of the HP boot ROM start searching for
		 * boot devices starting with slave 6 and working down.
		 * This is apparently the order in which priority is given
		 * to slaves on the host adaptor.
		 */
		find_busslaves(hc, MAXSLAVES-2, 0);
#else
		find_busslaves(hc, 0, MAXSLAVES-2);
#endif
}

/*
 * Search each BUS controller found for slaves attached to it.
 * The bad news is that we don't know how to uniquely identify all slaves
 * (e.g. PPI devices on HP-IB).  The good news is that we can at least
 * differentiate those from slaves we can identify.  At worst (a totally
 * wildcarded entry) this will cause us to locate such a slave at the first
 * unused position instead of where it really is.  To save grief, non-
 * identifing devices should always be fully qualified.
 */
find_busslaves(hc, startslave, endslave)
	register struct hp_ctlr *hc;
	int startslave, endslave;
{
	register int s;
	register struct hp_device *hd;
	struct hp_device *match_s;
	int new_s, new_c, old_s, old_c;
	int rescan;
	
#define NEXTSLAVE(s) (startslave < endslave ? (s)++ : (s)--)
#define LASTSLAVE(s) (startslave < endslave ? (s)-- : (s)++)
#ifdef DEBUG
	if (acdebug)
		printf("find_busslaves: for %s\n", hc->hp_xname);
#endif
	NEXTSLAVE(endslave);
	for (s = startslave; s != endslave; NEXTSLAVE(s)) {
		rescan = 1;
		match_s = NULL;
		for (hd = hp_dinit; hd->hp_driver; hd++) {
			/*
			 * Rule out the easy ones:
			 * 1. slave already assigned or not a slave
			 * 2. not of the proper type
			 * 3. controller specified but not this one
			 * 4. slave specified but not this one
			 */
			if (hd->hp_alive || hd->hp_cdriver == NULL)
				continue;
			if (!dr_type(hc->hp_driver, hd->hp_cdriver->d_name))
				continue;
			if (hd->hp_ctlr >= 0 && hd->hp_ctlr != hc->hp_unit)
				continue;
			if (hd->hp_slave >= 0 && hd->hp_slave != s)
				continue;
			/*
			 * Case 0: first possible match.
			 * Remember it and keep looking for better.
			 */
			if (match_s == NULL) {
				match_s = hd;
				new_c = hc->hp_unit;
				new_s = s;
				continue;
			}
			/*
			 * Case 1: exact match.
			 * All done.  Note that we do not attempt any other
			 * matches if this one fails.  This allows us to
			 * "reserve" locations for dynamic addition of
			 * disk/tape drives by fully qualifing the location.
			 */
			if (hd->hp_slave == s && hd->hp_ctlr == hc->hp_unit) {
				match_s = hd;
				rescan = 0;
				break;
			}
			/*
			 * Case 2: right controller, wildcarded slave.
			 * Remember first and keep looking for an exact match.
			 */
			if (hd->hp_ctlr == hc->hp_unit &&
			    match_s->hp_ctlr < 0) {
				match_s = hd;
				new_s = s;
				continue;
			}
			/*
			 * Case 3: right slave, wildcarded controller.
			 * Remember and keep looking for a better match.
			 */
			if (hd->hp_slave == s &&
			    match_s->hp_ctlr < 0 && match_s->hp_slave < 0) {
				match_s = hd;
				new_c = hc->hp_unit;
				continue;
			}
			/*
			 * OW: we had a totally wildcarded spec.
			 * If we got this far, we have found a possible
			 * match already (match_s != NULL) so there is no
			 * reason to remember this one.
			 */
			continue;
		}
		/*
		 * Found a match.  We need to set hp_ctlr/hp_slave properly
		 * for the init routines but we also need to remember all
		 * the old values in case this doesn't pan out.
		 */
		if (match_s) {
			hd = match_s;
			old_c = hd->hp_ctlr;
			old_s = hd->hp_slave;
			if (hd->hp_ctlr < 0)
				hd->hp_ctlr = new_c;
			if (hd->hp_slave < 0)
				hd->hp_slave = new_s;
#ifdef DEBUG
			if (acdebug)
				printf("looking for %s%d at slave %d...",
				       hd->hp_driver->d_name,
				       hd->hp_unit, hd->hp_slave);
#endif

			if ((*hd->hp_driver->d_match)(hd)) {
#ifdef DEBUG
				if (acdebug)
					printf("found\n");
#endif
				/*
				 * Fill in fake device strcuture.
				 */
				bzero(&hd->hp_dev, sizeof(hd->hp_dev));
				hd->hp_dev.dv_unit = hd->hp_unit;
				sprintf(hd->hp_dev.dv_xname, "%s%d",
				    hd->hp_driver->d_name,
				    hd->hp_unit);
				/*
				 * Default to dull, driver attach will
				 * override if necessary.
				 */
				hd->hp_dev.dv_class = DV_DULL;
				hd->hp_dev.dv_parent = &hc->hp_dev;
				TAILQ_INSERT_TAIL(&alldevs, &hd->hp_dev,
				    dv_list);

				/*
				 * Print what we've found.  Note that
				 * for `slave' devices, the flags are
				 * overloaded with the phys. unit
				 * locator.  They aren't used for anything
				 * else, so we always treat them as
				 * such.  This is a hack to make things
				 * a little more clear to folks configuring
				 * kernels and reading boot messages.
				 */
				printf("%s at %s slave %d punit %d",
				       hd->hp_xname, hc->hp_xname,
				       hd->hp_slave, hd->hp_flags);
				hd->hp_alive = 1;
				rescan = 1;

				/*
				 * Call the device "attach" routine.
				 * It will print the newline for us.
				 */
				 (*hd->hp_driver->d_attach)(hd);

				/*
				 * Register device.  Do this after attach
				 * because we need dv_class.
				 */
				if (dr_type(hc->hp_driver, "scsi")) {
					hp300_scsi_link.target = hd->hp_slave;
					hp300_scsi_link.lun = hd->hp_flags;
					hp300_scsibus_attach_args.sa_scsi_link=
					    &hp300_scsi_link;
					device_register(&hd->hp_dev,
					    &hp300_scsibus_attach_args);
				} else {
					hp300_hpib_attach_args.ha_slave =
					    hd->hp_slave;
					hp300_hpib_attach_args.ha_punit =
					    hd->hp_flags;
					device_register(&hd->hp_dev,
					    &hp300_hpib_attach_args);
				}
			} else {
#ifdef DEBUG
				if (acdebug)
					printf("not found\n");
#endif
				hd->hp_ctlr = old_c;
				hd->hp_slave = old_s;
			}
			/*
			 * XXX: This should be handled better.
			 * Re-scan a slave.  There are two reasons to do this.
			 * 1. It is possible to have both a tape and disk
			 *    (e.g. 7946) or two disks (e.g. 9122) at the
			 *    same slave address.  Here we need to rescan
			 *    looking only at entries with a different
			 *    physical unit number (hp_flags).
			 * 2. It is possible that an init failed because the
			 *    slave was there but of the wrong type.  In this
			 *    case it may still be possible to match the slave
			 *    to another ioconf entry of a different type.
			 *    Here we need to rescan looking only at entries
			 *    of different types.
			 * In both cases we avoid looking at undesirable
			 * ioconf entries of the same type by setting their
			 * alive fields to -1.
			 */
			if (rescan) {
				for (hd = hp_dinit; hd->hp_driver; hd++) {
					if (hd->hp_alive)
						continue;
					if (match_s->hp_alive == 1) {	/* 1 */
						if (hd->hp_flags == match_s->hp_flags)
							hd->hp_alive = -1;
					} else {			/* 2 */
						if (hd->hp_driver == match_s->hp_driver)
							hd->hp_alive = -1;
					}
				}
				LASTSLAVE(s);
				continue;
			}
		}
		/*
		 * Reset bogon alive fields prior to attempting next slave
		 */
		for (hd = hp_dinit; hd->hp_driver; hd++)
			if (hd->hp_alive == -1)
				hd->hp_alive = 0;
	}
#undef NEXTSLAVE
#undef LASTSLAVE
}

same_hw_device(hw, hd)
	struct hp_hw *hw;
	struct hp_device *hd;
{
	int found = 0;

	switch (hw->hw_type & ~B_MASK) {
	case C_HPIB:
		found = dr_type(hd->hp_driver, "hpib");
		break;
	case C_SCSI:
		found = dr_type(hd->hp_driver, "scsi");
		break;
	case D_BITMAP:
		found = dr_type(hd->hp_driver, "grf");
		break;
	case D_LAN:
		found = dr_type(hd->hp_driver, "le");
		break;
	case D_COMMDCA:
		found = dr_type(hd->hp_driver, "dca");
		break;
	case D_COMMDCL:
		found = dr_type(hd->hp_driver, "dcl");
		break;
	case D_COMMDCM:
		found = dr_type(hd->hp_driver, "dcm");
		break;
	default:
		break;
	}
	return(found);
}

char notmappedmsg[] = "WARNING: no space to map IO card, ignored\n";

/*
 * Scan the IO space looking for devices.
 */
find_devs()
{
	short sc;
	u_char *id_reg;
	register caddr_t addr;
	register struct hp_hw *hw = sc_table;
	int didmap, sctop;

	/*
	 * Probe all select codes + internal display addr
	 */
	sctop = DIO_SCMAX(machineid);
	for (sc = -1; sc < sctop; sc++) {
		/*
		 * Invalid select codes
		 */
		if (sc >= 32 && sc < 132)
			continue;

		if (sc == -1) {
			hw->hw_pa = (caddr_t) GRFIADDR;
			addr = (caddr_t) IIOV(hw->hw_pa);
			didmap = 0;
		} else if (sc == 7 && internalhpib) {
			hw->hw_pa = (caddr_t)DIO_IHPIBADDR;
			addr = internalhpib = (caddr_t) IIOV(hw->hw_pa);
			didmap = 0;
		} else if (sc == conscode) {
			/*
			 * If this is the console, it's already been
			 * mapped, and the address is known.
			 */
			hw->hw_pa = dio_scodetopa(sc);
			addr = conaddr;
			didmap = 0;
		} else {
			hw->hw_pa = dio_scodetopa(sc);
			addr = iomap(hw->hw_pa, NBPG);
			if (addr == 0) {
				printf(notmappedmsg);
				continue;
			}
			didmap = 1;
		}
		if (badaddr(addr)) {
			if (didmap)
				iounmap(addr, NBPG);
			continue;
		}

		hw->hw_size = DIO_SIZE(sc, addr);
		hw->hw_kva = addr;
		hw->hw_id = DIO_ID(addr);
		if (DIO_ISFRAMEBUFFER(hw->hw_id))
			hw->hw_secid = DIO_SECID(addr);
		hw->hw_sc = sc;

		/*
		 * Internal HP-IB on some machines (345/375) doesn't return
		 * consistant id info so we use the info gleaned from the
		 * boot ROMs SYSFLAG.
		 */
		if (sc == 7 && internalhpib) {
			hw->hw_type = C_HPIB;
			hw++;
			continue;
		}
		/*
		 * XXX: the following could be in a big static table
		 */
		switch (hw->hw_id) {
		/* Null device? */
		case 0:
			break;
		/* 98644A */
		case 2:
		case 2+128:
			hw->hw_type = D_COMMDCA;
			break;
		/* 98622A */
		case 3:
			hw->hw_type = D_MISC;
			break;
		/* 98623A */
		case 4:
			hw->hw_type = D_MISC;
			break;
		/* 98642A */
		case 5:
		case 5+128:
			hw->hw_type = D_COMMDCM;
			break;
		/* 345/375 builtin parallel port */
		case 6:
			hw->hw_type = D_PPORT;
			break;
		/* 98625A */
		case 7:
		case 7+32:
		case 7+64:
		case 7+96:
			hw->hw_type = C_SCSI;
			break;
		/* 98625B */
		case 8:
			hw->hw_type = C_HPIB;
			break;
		/* 98287A */
		case 9:
			hw->hw_type = D_KEYBOARD;
			break;
		/* 98635A */
		case 10:
			hw->hw_type = D_FPA;
			break;
		/* timer */
		case 11:
			hw->hw_type = D_MISC;
			break;
		/* 98640A */
		case 18:
			hw->hw_type = D_MISC;
			break;
		/* 98643A */
		case 21:
			hw->hw_type = D_LAN;
			break;
		/* 98659A */
		case 22:
			hw->hw_type = D_MISC;
			break;
		/* 237 display */
		case 25:
			hw->hw_type = D_BITMAP;
			break;
		/* quad-wide card */
		case 26:
			hw->hw_type = D_MISC;
			hw->hw_size *= 4;
			sc += 3;
			break;
		/* 98253A */
		case 27:
			hw->hw_type = D_MISC;
			break;
		/* 98627A */
		case 28:
			hw->hw_type = D_BITMAP;
			break;
		/* 98633A */
		case 29:
			hw->hw_type = D_BITMAP;
			break;
		/* 98259A */
		case 30:
			hw->hw_type = D_MISC;
			break;
		/* 8741 */
		case 31:
			hw->hw_type = D_MISC;
			break;
		/* 98577A */
		case 49:
			hw->hw_type = C_VME;
			if (sc < 132) {
				hw->hw_size *= 2;
				sc++;
			}
			break;
		/* 98628A */
		case 52:
		case 52+128:
			hw->hw_type = D_COMMDCL;
			break;
		/* bitmap display */
		case 57:
			hw->hw_type = D_BITMAP;
			hw->hw_secid = id_reg[0x15];
			switch (hw->hw_secid) {
			/* 98700/98710 */
			case 1:
				break;
			/* 98544-547 topcat */
			case 2:
				break;
			/* 98720/721 renassiance */
			case 4:
				if (sc < 132) {
					hw->hw_size *= 2;
					sc++;
				}
				break;
			/* 98548-98556 catseye */
			case 5:
			case 6:
			case 7:
			case 9:
				break;
			/* 98730/731 davinci */
			case 8:
				if (sc < 132) {
					hw->hw_size *= 2;
					sc++;
				}
				break;
			/* A1096A hyperion */
			case 14:
				break;
			/* 987xx */
			default:
				break;
			}
			break;
		/* 98644A */
		case 66:
		case 66+128:
			hw->hw_type = D_COMMDCA;
			break;
		/* 98624A */
		case 128:
			hw->hw_type = C_HPIB;
			break;
		default:
			hw->hw_type = D_MISC;
			break;
		}
		/*
		 * Re-map to proper size
		 */
		if (didmap) {
			iounmap(addr, NBPG);
			addr = iomap(hw->hw_pa, hw->hw_size);
			if (addr == 0) {
				printf(notmappedmsg);
				continue;
			}
			hw->hw_kva = addr;
		}
		/*
		 * Encode bus type
		 */
		if (sc >= 132)
			hw->hw_type |= B_DIOII;
		else
			hw->hw_type |= B_DIO;
		hw++;
	}
}
#endif /* ! NEWCONFIG */
@


1.8
log
@fix DIO-II mappings, NetBSD PR#3097.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 1997/01/12 15:13:10 downsj Exp $	*/
d620 1
a620 3
#ifdef FFS
	extern int ffs_mountroot __P((void));
#endif
a808 1
#ifdef FFS
d810 1
a810 1
		mountroot = ffs_mountroot;
a817 1
#endif
@


1.7
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1895 1
a1895 1
		if ((sc >= 32 && sc < 132) || sc > 187)	/* XXX */
@


1.6
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: autoconf.c,v 1.20 1996/05/18 01:39:57 thorpej Exp $	*/
d14 12
d29 1093
a1121 28
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: autoconf.c 1.36 92/12/20$
 *
 *	@@(#)autoconf.c	8.2 (Berkeley) 1/12/94
d1123 12
d1137 1
a1137 5
 * Setup the system to run on the current machine.
 *
 * Configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
d1139 13
d1153 1
a1153 9
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/map.h>
#include <sys/buf.h>
#include <sys/dkstat.h>
#include <sys/conf.h>
#include <sys/dmap.h>
#include <sys/reboot.h>
#include <sys/device.h>
d1155 7
a1161 1
#include <dev/cons.h>
d1163 11
a1173 4
#include <machine/autoconf.h>
#include <machine/vmparam.h>
#include <machine/cpu.h>
#include <machine/pte.h>
d1175 6
a1180 1
#include <hp300/hp300/isr.h>
d1182 3
a1184 3
#include <hp300/dev/device.h>
#include <hp300/dev/grfreg.h>
#include <hp300/dev/hilreg.h>
d1187 3
a1189 3
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
d1191 33
a1223 2
int	cold;		    /* if 1, still working on cold-start */
struct	hp_hw sc_table[MAXCTLRS];
d1225 5
a1229 2
/* XXX must be allocated statically because of early console init */
struct	map extiomap[EIOMAPSIZE/16];
d1231 12
a1242 2
extern	caddr_t internalhpib;
extern	char *extiobase;
d1244 4
a1247 3
#ifdef DEBUG
int	acdebug = 0;
#endif
d1249 7
a1255 4
#ifndef NEWCONFIG	/* XXX */
struct	devicelist alldevs;
struct	evcntlist allevents;
#endif
d1258 2
a1259 1
 * Determine mass storage and memory configuration for a machine.
d1261 2
a1262 1
configure()
d1264 4
a1267 2
	register struct hp_hw *hw;
	int found;
d1270 1
a1270 2
	 * Find out what hardware is attached to the machine.
	 * XXX goes away with new config.
d1272 2
a1273 1
	find_devs();
d1276 1
a1276 1
	 * XXX: these should be consolidated into some kind of table
d1278 2
a1279 4
	hilsoftinit(0, HILADDR);
	hilinit(0, HILADDR);
	isrinit();
	dmainit();
d1282 1
a1282 2
	 * Look over each hardware device actually found and attempt
	 * to match it with an ioconf.c table entry.
d1284 18
a1301 5
	for (hw = sc_table; hw->hw_type; hw++) {
		if (HW_ISCTLR(hw))
			found = find_controller(hw);
		else
			found = find_device(hw);
d1303 12
a1314 2
		if (!found) {
			int sc = patosc(hw->hw_pa);
d1316 9
a1324 7
			printf("unconfigured card id %x ", hw->hw_id);
			if (sc < 256)
				printf("at sc%d\n", sc);
			else
				printf("csr at %x\n", sc);
		}
	}
d1326 5
a1330 6
#if GENERIC
	if ((boothowto & RB_ASKNAME) == 0)
		setroot();
	setconf();
#else
	setroot();
d1332 20
a1351 2
	swapconf();
	cold = 0;
d1426 6
a1431 3
		/* Set up external name. */
		bzero(hc->hp_xname, sizeof(hc->hp_xname));
		sprintf(hc->hp_xname, "%s%d", hc->hp_driver->d_name,
d1433 2
d1438 3
a1440 3
		sc = patosc(hw->hw_pa);
		if (sc < 256)
			printf("scode%d", sc);
d1442 1
a1442 1
			printf("addr 0x%x,", sc);
d1452 8
d1542 6
a1547 3
		/* Set up external name. */
		bzero(hd->hp_xname, sizeof(hd->hp_xname));
		sprintf(hd->hp_xname, "%s%d", hd->hp_driver->d_name,
d1549 6
d1558 3
a1560 3
		sc = patosc(hw->hw_pa);
		if (sc < 256)
			printf("scode%d", sc);
d1562 1
a1562 1
			printf("addr 0x%x", sc);
d1573 7
d1729 6
a1734 3
				/* Set up external name. */
				bzero(hd->hp_xname, sizeof(hd->hp_xname));
				sprintf(hd->hp_xname, "%s%d",
d1737 8
d1746 11
a1756 2
				/* Print what we've found. */
				printf("%s at %s slave %d",
d1758 1
a1758 3
				       hd->hp_slave);
				if (hd->hp_flags)
					printf(" flags 0x%x", hd->hp_flags);
a1759 4
				if (hd->hp_dk && dkn < DK_NDRIVE)
					hd->hp_dk = dkn++;
				else
					hd->hp_dk = -1;
d1767 20
a1839 52
caddr_t
sctopa(sc)
	register int sc;
{
	register caddr_t addr;

	if (sc == 7 && internalhpib)
		addr = internalhpib;
	else if (sc < 32)
		addr = (caddr_t) (DIOBASE + sc * DIOCSIZE);
	else if (sc >= 132)
		addr = (caddr_t) (DIOIIBASE + (sc - 132) * DIOIICSIZE);
	else
		addr = 0;
	return(addr);
}

patosc(addr)
	register caddr_t addr;
{
	if (addr == (caddr_t)0x478000)
		return(7);
	if (addr >= (caddr_t)DIOBASE && addr < (caddr_t)DIOTOP)
		return(((unsigned)addr - DIOBASE) / DIOCSIZE);
	if (addr >= (caddr_t)DIOIIBASE && addr < (caddr_t)DIOIITOP)
		return(((unsigned)addr - DIOIIBASE) / DIOIICSIZE + 132);
	return((int)addr);
}

caddr_t
sctova(sc)
	register int sc;
{
	register struct hp_hw *hw;

	for (hw = sc_table; hw->hw_type; hw++)
		if (sc == hw->hw_sc)
			return(hw->hw_kva);
	return((caddr_t)sc);
}

vatosc(addr)
	register caddr_t addr;
{
	register struct hp_hw *hw;

	for (hw = sc_table; hw->hw_type; hw++)
		if (addr == hw->hw_kva)
			return(hw->hw_sc);
	return((int)addr);
}

a1876 101
 * Scan all select codes, passing the corresponding VA to (*func)().
 * (*func)() is a driver-specific routine that looks for the console
 * hardware.
 */
void
console_scan(func, arg)
	int (*func) __P((int, caddr_t, void *));
	void *arg;
{
	int size, scode, sctop;
	caddr_t pa, va;

	/*
	 * Scan all select codes.  Check each location for some
	 * hardware.  If there's something there, call (*func)().
	 */
	sctop = (machineid == HP_320) ? 32 : 256;
	for (scode = 0; scode < sctop; ++scode) {
		/*
		 * Abort mission if console has been forced.
		 */
		if (conforced)
			return;

		/*
		 * Skip over the select code hole and
		 * the internal HP-IB controller.
		 */
		if (((scode >= 32) && (scode < 132)) ||
		    ((scode == 7) && internalhpib))
			continue;

		/* Map current PA. */
		pa = sctopa(scode);
		va = iomap(pa, NBPG);
		if (va == 0)
			continue;

		/* Check to see if hardware exists. */
		if (badaddr(va)) {
			iounmap(va, NBPG);
			continue;
		}

		/*
		 * Hardware present, call callback.  Driver returns
		 * size of region to map if console probe successful
		 * and worthwhile.
		 */
		size = (*func)(scode, va, arg);
		iounmap(va, NBPG);
		if (size) {
			/* Free last mapping. */
			if (convasize)
				iounmap(conaddr, convasize);
			convasize = 0;

			/* Remap to correct size. */
			va = iomap(pa, size);
			if (va == 0)
				continue;

			/* Save this state for next time. */
			conscode = scode;
			conaddr = va;
			convasize = size;
		}
	}
}

/*
 * Special version of cninit().  Actually, crippled somewhat.
 * This version lets the drivers assign cn_tab.
 */
void
hp300_cninit()
{
	struct consdev *cp;
	extern struct consdev constab[];

	cn_tab = NULL;

	/*
	 * Call all of the console probe functions.
	 */
	for (cp = constab; cp->cn_probe; cp++)
		(*cp->cn_probe)(cp);

	/*
	 * No console, we can handle it.
	 */
	if (cn_tab == NULL)
		return;

	/*
	 * Turn on the console.
	 */
	(*cn_tab->cn_init)(cn_tab);
}

/*
d1890 1
a1890 1
	sctop = machineid == HP_320 ? 32 : 256;
d1895 1
a1895 1
		if (sc >= 32 && sc < 132)
d1903 1
a1903 1
			hw->hw_pa = (caddr_t) 0x478000;
d1911 1
a1911 1
			hw->hw_pa = sctopa(sc);
d1915 1
a1915 1
			hw->hw_pa = sctopa(sc);
d1928 2
a1929 5
		id_reg = (u_char *) addr;
		if (sc >= 132)
			hw->hw_size = (id_reg[0x101] + 1) * 0x100000;
		else
			hw->hw_size = DIOCSIZE;
d1931 3
a1933 1
		hw->hw_id = id_reg[1];
d1935 1
d2127 1
a2127 191

/*
 * Allocate/deallocate a cache-inhibited range of kernel virtual address
 * space mapping the indicated physical address range [pa - pa+size)
 */
caddr_t
iomap(pa, size)
	caddr_t pa;
	int size;
{
	int ix, npf;
	caddr_t kva;

#ifdef DEBUG
	if (((int)pa & PGOFSET) || (size & PGOFSET))
		panic("iomap: unaligned");
#endif
	npf = btoc(size);
	ix = rmalloc(extiomap, npf);
	if (ix == 0)
		return(0);
	kva = extiobase + ctob(ix-1);
	physaccess(kva, pa, size, PG_RW|PG_CI);
	return(kva);
}

void
iounmap(kva, size)
	caddr_t kva;
	int size;
{
	int ix;

#ifdef DEBUG
	if (((int)kva & PGOFSET) || (size & PGOFSET))
		panic("iounmap: unaligned");
	if (kva < extiobase || kva >= extiobase + ctob(EIOMAPSIZE))
		panic("iounmap: bad address");
#endif
	physunaccess(kva, size);
	ix = btoc(kva - extiobase) + 1;
	rmfree(extiomap, btoc(size), ix);
}

/*
 * Configure swap space and related parameters.
 */
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
		}
	dumpconf();
}

#define	DOSWAP			/* Change swdevt and dumpdev too */
u_long	bootdev;		/* should be dev_t, but not until 32 bits */

static	char devname[][2] = {
	0,0,		/* 0 = ct */
	0,0,		/* 1 = xx */
	'r','d',	/* 2 = rd */
	0,0,		/* 3 = sw */
	's','d',	/* 4 = rd */
};

#define	PARTITIONMASK	0x7
#define	PARTITIONSHIFT	3

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
setroot()
{
	register struct hp_ctlr *hc;
	register struct hp_device *hd;
	int  majdev, mindev, unit, part, controller, adaptor;
	dev_t temp, orootdev;
	struct swdevt *swp;

	if (boothowto & RB_DFLTROOT || (bootdev == 0) ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
		return;
	majdev = B_TYPE(bootdev);
	if (majdev >= sizeof(devname) / sizeof(devname[0]))
		return;
	adaptor = B_ADAPTOR(bootdev);
	controller = B_CONTROLLER(bootdev);
	part = B_PARTITION(bootdev);
	unit = B_UNIT(bootdev);
	/*
	 * First, find the controller type which supports this device.
	 */
	for (hd = hp_dinit; hd->hp_driver; hd++)
		if (hd->hp_driver->d_name[0] == devname[majdev][0] &&
		    hd->hp_driver->d_name[1] == devname[majdev][1])
			break;
	if (hd->hp_driver == 0)
		return;
	/*
	 * Next, find the "controller" (bus adaptor) of that type
	 * corresponding to the adaptor number.
	 */
	for (hc = hp_cinit; hc->hp_driver; hc++)
		if (hc->hp_alive && hc->hp_unit == adaptor &&
		    hc->hp_driver == hd->hp_cdriver)
			break;
	if (hc->hp_driver == 0)
		return;
	/*
	 * Finally, find the "device" (controller or slave) in question
	 * attached to that "controller".
	 */
	for (hd = hp_dinit; hd->hp_driver; hd++)
		if (hd->hp_alive && hd->hp_slave == controller &&
		    hd->hp_cdriver == hc->hp_driver &&
		    hd->hp_ctlr == hc->hp_unit)
			break;
	if (hd->hp_driver == 0)
		return;
	/*
	 * XXX note that we are missing one level, the unit, here.
	 * Most HP drives come with one controller per disk.  There
	 * are some older drives (e.g. 7946) which have two units
	 * on the same controller but those are typically a disk as
	 * unit 0 and a tape as unit 1.  This would have to be
	 * rethought if you ever wanted to boot from other than unit 0.
	 */
	if (unit != 0)
		printf("WARNING: using device at unit 0 of controller\n");

	mindev = hd->hp_unit;
	/*
	 * Form a new rootdev
	 */
	mindev = (mindev << PARTITIONSHIFT) + part;
	orootdev = rootdev;
	rootdev = makedev(majdev, mindev);
	/*
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
	 */
	if (rootdev == orootdev)
		return;

	printf("Changing root device to %c%c%d%c\n",
		devname[majdev][0], devname[majdev][1],
		mindev >> PARTITIONSHIFT, part + 'a');

#ifdef DOSWAP
	mindev &= ~PARTITIONMASK;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap
	 * device, move it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
#endif
}

#ifndef NEWCONFIG	/* XXX */
void
config_init()
{

	TAILQ_INIT(&alldevs);
	TAILQ_INIT(&allevents);
}
#endif
@


1.5
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.18 1996/04/07 18:21:08 thorpej Exp $	*/
d62 1
a82 1
int	cpuspeed = 0;	    /* relative cpu speed -- can be patched */	
d95 5
d1203 3
a1205 1
	/* Stub, so kernel will link. */
@


1.4
log
@from netbsd: Print unconfigured card id and select code regardless of -DDEBUG
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.14 1995/12/30 18:25:25 thorpej Exp $	*/
d4 1
d63 3
d69 1
d71 1
a82 1
struct	isr isrqueue[NISR];
d104 6
d661 101
d769 1
a769 1
	register struct hp_hw *hw;
a772 5
	 * Initialize IO resource map for iomap().
	 */
	rminit(extiomap, (long)EIOMAPSIZE, (long)1, "extio", EIOMAPSIZE/16);
	hw = sc_table;
	/*
d791 8
d1038 1
a1055 21
isrinit()
{
	register int i;

	for (i = 0; i < NISR; i++)
		isrqueue[i].isr_forw = isrqueue[i].isr_back = &isrqueue[i];
}

void
isrlink(isr)
	register struct isr *isr;
{
	int i = ISRIPL(isr->isr_ipl);

	if (i < 0 || i >= NISR) {
		printf("bad IPL %d\n", i);
		panic("configure");
	}
	insque(isr, isrqueue[i].isr_back);
}

d1193 8
@


1.3
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.13 1995/12/28 19:16:45 thorpej Exp $	*/
d115 1
a115 1
#ifdef DEBUG
a124 1
#endif
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.12 1995/12/02 18:11:21 thorpej Exp $	*/
a75 1
int	dkn;		    /* number of iostat dk numbers assigned so far */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.11 1995/09/02 23:36:09 thorpej Exp $	*/
d202 2
a203 2
	 * Found a match, attempt to initialize and configure all attached
	 * slaves.  Note, we can still fail if HW won't initialize.
d208 2
a209 1
	if ((*hc->hp_driver->d_init)(hc)) {
d211 8
a218 1
		printf("%s%d", hc->hp_driver->d_name, hc->hp_unit);
d221 1
a221 1
			printf(" at sc%d,", sc);
d223 1
a223 1
			printf(" csr 0x%x,", sc);
d227 7
a233 2
		printf("\n");
		find_slaves(hc);
d305 2
a306 2
	 * Found a match, attempt to initialize.
	 * Note, we can still fail if HW won't initialize.
d311 2
a312 1
	if ((*hd->hp_driver->d_init)(hd)) {
d314 8
a321 1
		printf("%s%d", hd->hp_driver->d_name, hd->hp_unit);
d324 1
a324 1
			printf(" at sc%d", sc);
d326 1
a326 1
			printf(" csr 0x%x", sc);
d328 1
a328 1
			printf(", ipl %d", hd->hp_ipl);
d330 7
a336 2
			printf(", flags 0x%x", hd->hp_flags);
		printf("\n");
d389 1
a389 2
		printf("find_busslaves: for %s%d\n",
		       hc->hp_driver->d_name, hc->hp_unit);
d481 1
a481 1
			if ((*hd->hp_driver->d_init)(hd)) {
d486 9
a494 3
				printf("%s%d at %s%d, slave %d",
				       hd->hp_driver->d_name, hd->hp_unit,
				       hc->hp_driver->d_name, hd->hp_ctlr,
a497 1
				printf("\n");
d504 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
