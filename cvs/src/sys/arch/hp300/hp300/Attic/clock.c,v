head	1.16;
access;
symbols
	OPENBSD_5_5:1.15.0.8
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.20
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.16
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.18
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.14
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.12
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.10
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.8
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.6
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.12
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.10
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.15;

1.15
date	2012.09.08.19.24.28;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.03.21.36.17;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.14.22.39.27;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.02.21.28.54;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.29.07.35.54;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.11.19.20.25;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.14.09.09.47;	author downsj;	state Exp;
branches
	1.6.2.1
	1.6.12.1;
next	1.5;

1.5
date	97.07.06.08.01.58;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.04.16.11.56.21;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.01.12.15.13.11;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.11.47.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.22;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.03.27.23.19.21;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.06.07.11.11.35;	author ho;	state Exp;
branches;
next	;

1.6.12.1
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: clock.c,v 1.15 2012/09/08 19:24:28 miod Exp $	*/
/*	$NetBSD: clock.c,v 1.20 1997/04/27 20:43:38 thorpej Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: clock.c 1.18 91/01/21$
 *
 *	@@(#)clock.c	8.2 (Berkeley) 1/12/94
 */

/*
 * HPs use the MC6840 PTM with the following arrangement:
 *	Timers 1 and 3 are externally driver from a 25MHz source.
 *	Output from timer 3 is tied to the input of timer 2.
 * The latter makes it possible to use timers 3 and 2 together to get
 * a 32-bit countdown timer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/evcount.h>
#include <sys/timetc.h>

#include <machine/psl.h>
#include <machine/cpu.h>
#include <machine/hp300spu.h>

#include <dev/hil/hilreg.h>	/* for BBC */
#include <hp300/hp300/clockreg.h>

#ifdef GPROF
#include <sys/gmon.h>
#endif

int	 clkstd[1];
int	 clkint;	/* clock interval, as loaded */
uint32_t clkcounter;	/* for timecounter */

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 1024 would
 * give us offsets in [0..1023].  Instead, we take offsets in [1..1023].
 * This is symmetric about the point 512, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
static int statvar = 1024 / 4;	/* {stat,prof}clock variance */
static int statmin;		/* statclock interval - variance/2 */
static int profmin;		/* profclock interval - variance/2 */
static int timer3min;		/* current, from above choices */
static int statprev;		/* previous value in stat timer */

static int month_days[12] = {
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
u_char bbc_registers[13];
volatile u_int8_t *bbcaddr = NULL;

void	clockintr(struct clockframe *);
void	statintr(struct clockframe *);
u_int	mc6840_counter(struct timecounter *);

void	hp300_calibrate_delay(void);
struct bbc_tm *gmt_to_bbc(long);
int	bbc_to_gmt(u_long *);
void	read_bbc(void);
u_char	read_bbc_reg(int);
void	send_clock_cmd(volatile u_int8_t *, u_int8_t, u_int8_t *,
    u_int8_t, u_int8_t *);
u_char	write_bbc_reg(int, u_int);

static int clock_ipl = IPL_CLOCK;
static int stat_ipl = IPL_STATCLOCK;
struct evcount clockcnt;
struct evcount statcnt;

/*
 * Machine-dependent clock routines.
 *
 * A note on the real-time clock:
 * We actually load the clock with interval-1 instead of interval.
 * This is because the counter decrements to zero after N+1 enabled clock
 * periods where N is the value loaded into the counter.
 *
 * The frequencies of the HP300 clocks must be a multiple of four
 * microseconds (since the clock counts in 4 us units).
 */
#define	COUNTS_PER_SEC	(1000000 / CLK_RESOLUTION)

struct timecounter mc6840_tc = {
	mc6840_counter, NULL, ~0, COUNTS_PER_SEC, "mc6840", 100, NULL
};

/*
 * Calibrate the delay constant, based on Chuck Cranor's
 * mvme68k delay calibration algorithm.
 */
void
hp300_calibrate_delay()
{
	extern int delay_divisor;
	volatile struct clkreg *clk;
	volatile u_char csr;
	int intvl;

	clkstd[0] = IIOV(0x5F8000);		/* XXX yuck */
	clk = (volatile struct clkreg *)clkstd[0];

	/*
	 * Calibrate delay() using the 4 usec counter.
	 * We adjust delay_divisor until we get the result we want.
	 * We assume we've been called at splhigh().
	 */
	for (delay_divisor = 140; delay_divisor > 1; delay_divisor--) {
		/* Reset clock chip */
		clk->clk_cr2 = CLK_CR1;
		clk->clk_cr1 = CLK_RESET;

		/*
		 * Prime the timer.  We're looking for
		 * 10,000 usec (10ms).  See interval comment
		 * above.
		 */
		intvl = (10000 / CLK_RESOLUTION) - 1;
		asm volatile(" movpw %0,%1@@(5)" : : "d" (intvl), "a" (clk));

		/* Enable the timer */
		clk->clk_cr2 = CLK_CR1;
		clk->clk_cr1 = CLK_IENAB;

		delay(10000);

		/* Timer1 interrupt flag high? */
		csr = clk->clk_sr;
		if (csr & CLK_INT1) {
			/*
			 * Got it.  Clear interrupt and get outta here.
			 */
			asm volatile(" movpw %0@@(5),%1" : :
			    "a" (clk), "d" (intvl));
			break;
		}

		/*
		 * Nope.  Poll for completion of the interval,
		 * clear interrupt, and try again.
		 */
		do {
			csr = clk->clk_sr;
		} while ((csr & CLK_INT1) == 0);

		asm volatile(" movpw %0@@(5),%1" : : "a" (clk), "d" (intvl));
	}

	/*
	 * Make sure the clock interrupt is disabled.  Otherwise,
	 * we can end up calling hardclock() before proc0 is set up,
	 * causing a bad pointer deref.
	 */
	clk->clk_cr2 = CLK_CR1;
	clk->clk_cr1 = CLK_RESET;

	/*
	 * Sanity check the delay_divisor value.  If we totally lost,
	 * assume a 50MHz CPU;
	 */
	if (delay_divisor == 0)
		delay_divisor = 2048 / 50;

	/* Calculate CPU speed. */
	cpuspeed = 2048 / delay_divisor;
}

/*
 * Set up the real-time and statistics clocks.  Leave stathz 0 only if
 * no alternative timer is available.
 */
void
cpu_initclocks()
{
	volatile struct clkreg *clk;
	int intvl, statint, profint, minint;

	clkstd[0] = IIOV(0x5F8000);		/* XXX grot */
	clk = (volatile struct clkreg *)clkstd[0];

	if (COUNTS_PER_SEC % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
	}
	/*
	 * Clock has several counters, so we can always use separate
	 * statclock.
	 */
	if (stathz == 0)		/* XXX should be set in param.c */
		stathz = hz;
	else if (COUNTS_PER_SEC % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	if (profhz == 0)		/* XXX should be set in param.c */
		profhz = stathz * 5;
	else if (profhz < stathz || COUNTS_PER_SEC % profhz) {
		printf("cannot get %d Hz profclock; using %d Hz\n",
		    profhz, stathz);
		profhz = stathz;
	}

	intvl = COUNTS_PER_SEC / hz;
	statint = COUNTS_PER_SEC / stathz;
	profint = COUNTS_PER_SEC / profhz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	tick = intvl * CLK_RESOLUTION;

	/* adjust interval counts, per note above */
	intvl--;
	statint--;
	profint--;

	/* calculate base reload values */
	clkint = intvl;
	statmin = statint - (statvar >> 1);
	profmin = profint - (statvar >> 1);
	timer3min = statmin;
	statprev = statint;

	evcount_attach(&statcnt, "stat", &stat_ipl);
	evcount_attach(&clockcnt, "clock", &clock_ipl);

	/* finally, load hardware */
	clk->clk_cr2 = CLK_CR1;
	clk->clk_cr1 = CLK_RESET;
	asm volatile(" movpw %0,%1@@(5)" : : "d" (intvl), "a" (clk));
	asm volatile(" movpw %0,%1@@(9)" : : "d" (0), "a" (clk));
	asm volatile(" movpw %0,%1@@(13)" : : "d" (statint), "a" (clk));
	clk->clk_cr2 = CLK_CR1;
	clk->clk_cr1 = CLK_IENAB;
	clk->clk_cr2 = CLK_CR3;
	clk->clk_cr3 = CLK_IENAB;

	tc_init(&mc6840_tc);
}

/*
 * We assume newhz is either stathz or profhz, and that neither will
 * change after being set up above.  Could recalculate intervals here
 * but that would be a drag.
 */
void
setstatclockrate(newhz)
	int newhz;
{

	if (newhz == stathz)
		timer3min = statmin;
	else
		timer3min = profmin;
}

/*
 * Timer clock interrupt.
 */
void
clockintr(fp)
	struct clockframe *fp;
{
	clockcnt.ec_count++;
	hardclock(fp);
}

/*
 * Statistics/profiling clock interrupt.  Compute a new interval.
 * Interrupt has already been cleared.
 */
void
statintr(fp)
	struct clockframe *fp;
{
	volatile struct clkreg *clk;
	int newint, r, var;

	clk = (volatile struct clkreg *)clkstd[0];
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = timer3min + r;

	/*
	 * The timer was automatically reloaded with the previous latch
	 * value at the time of the interrupt.  Compensate now for the
	 * amount of time that has run off since then (minimum of 2-12
	 * timer ticks depending on CPU type) plus one tick roundoff.
	 * This should keep us closer to the mean.
	 */
	asm volatile(" clrl %0; movpw %1@@(13),%0" : "=d" (r) : "a" (clk));
	newint -= (statprev - r + 1);

	asm volatile(" movpw %0,%1@@(13)" : : "d" (newint), "a" (clk));
	statprev = newint;
	statcnt.ec_count++;
	statclock(fp);
}

u_int
mc6840_counter(struct timecounter *tc)
{
	volatile struct clkreg *clk;
	uint32_t ccounter, count;
	static uint32_t lastcount;
	int s;

	clk = (volatile struct clkreg *)clkstd[0];

	s = splclock();
	ccounter = clkcounter;
	/* XXX reading counter clears interrupt flag?? */
	__asm__ __volatile__
	    ("clrl %0; movpw %1@@(5),%0" : "=d" (count) : "a" (clk));
	splx(s);

	count = ccounter + (clkint - count);
	if ((int32_t)(count - lastcount) < 0) {
		/* XXX wrapped; maybe hardclock() is blocked more than 1/hz */
		count = lastcount + 1;
	}
	lastcount = count;

	return count;
}

/*
 * Initialize the time of day register, based on the time base which is, e.g.
 * from a filesystem.
 */
void
inittodr(base)
	time_t base;
{
	u_long timbuf = base;	/* assume no battery clock exists */
	static int bbcinited = 0;
	int badbase = 0, waszero = base == 0;
	struct timespec ts;

	if (base < (2012 - 1970) * SECYR) {
		/*
		 * If base is 0, assume filesystem time is just unknown
		 * instead of preposterous. Don't bark.
		 */
		if (base != 0)
			printf("WARNING: preposterous time in file system\n");
		/* not going to use it anyway, if the chip is readable */
		base = (2012 - 1970) * SECYR;
		badbase = 1;
	}

	/* XXX */
	if (!bbcinited) {
		if (machineid == HP_425 && mmuid == MMUID_425_E)
			bbcaddr = NULL;
		else {
			if (badbaddr((caddr_t)(BBCADDR + HILP_STAT)))
				printf("WARNING: no battery clock\n");
			else
				bbcaddr = BBCADDR;
		}
		bbcinited = 1;
	}

	/*
	 * bbc_to_gmt converts and stores the gmt in timbuf.
	 * If an error is detected in bbc_to_gmt, or if the filesystem
	 * time is more recent than the gmt time in the clock,
	 * then use the filesystem time and warn the user.
 	 */
	if (bbcaddr != NULL) {
		if (!bbc_to_gmt(&timbuf) || timbuf < base) {
			printf("WARNING: bad date in battery clock\n");
			timbuf = base;
		}
	}

	if (timbuf != base) {
		int deltat = timbuf - base;

		if (deltat < 0)
			deltat = -deltat;
		if (!waszero && deltat >= 2 * SECDAY)
			printf("WARNING: clock %s %d days"
			    " -- CHECK AND RESET THE DATE!\n",
			    timbuf < base ? "lost" : "gained", deltat / SECDAY);
	}

	/* Battery clock does not store usec's, so forget about it. */
	ts.tv_sec = timbuf;
	ts.tv_nsec = 0;

	tc_setclock(&ts);
}

/*
 * Restore the time of day hardware after a time change.
 */
void
resettodr()
{
	int i;
	struct bbc_tm *tmptr;

	if (bbcaddr == NULL)
		return;

	tmptr = gmt_to_bbc(time_second);

	decimal_to_bbc(0, 1,  tmptr->tm_sec);
	decimal_to_bbc(2, 3,  tmptr->tm_min);
	decimal_to_bbc(4, 5,  tmptr->tm_hour);
	decimal_to_bbc(7, 8,  tmptr->tm_mday);
	decimal_to_bbc(9, 10, tmptr->tm_mon);
	decimal_to_bbc(11, 12, tmptr->tm_year);

	/* Some bogusness to deal with seemingly broken hardware. Nonsense */
	bbc_registers[5] = ((tmptr->tm_hour / 10) & 0x03) + 8;

	write_bbc_reg(15, 13);	/* reset prescalar */

	for (i = 0; i <= NUM_BBC_REGS; i++)
	  	if (bbc_registers[i] != write_bbc_reg(i, bbc_registers[i])) {
			printf("Cannot set battery backed clock\n");
			break;
		}
}

struct bbc_tm *
gmt_to_bbc(tim)
	long tim;
{
	int i;
	long hms, day;
	static struct bbc_tm rt;

	day = tim / SECDAY;
	hms = tim % SECDAY;

	/* Hours, minutes, seconds are easy */
	rt.tm_hour = hms / 3600;
	rt.tm_min  = (hms % 3600) / 60;
	rt.tm_sec  = (hms % 3600) % 60;

	/* Number of years in days */
	for (i = STARTOFTIME - 1900; day >= days_in_year(i); i++)
	  	day -= days_in_year(i);
	rt.tm_year = i;

	/* Number of months in days left */
	if (leapyear(rt.tm_year))
		days_in_month(FEBRUARY) = 29;
	for (i = 1; day >= days_in_month(i); i++)
		day -= days_in_month(i);
	days_in_month(FEBRUARY) = 28;
	rt.tm_mon = i;

	/* Days are what is left over (+1) from all that. */
	rt.tm_mday = day + 1;

	return(&rt);
}

int
bbc_to_gmt(timbuf)
	u_long *timbuf;
{
	int i;
	u_long tmp;
	int year, month, day, hour, min, sec;

	read_bbc();

	sec = bbc_to_decimal(1, 0);
	min = bbc_to_decimal(3, 2);

	/*
	 * Hours are different for some reason. Makes no sense really.
	 */
	hour  = ((bbc_registers[5] & 0x03) * 10) + bbc_registers[4];
	day   = bbc_to_decimal(8, 7);
	month = bbc_to_decimal(10, 9);
	year  = bbc_to_decimal(12, 11) + 1900;

	range_test(hour, 0, 23);
	range_test(day, 1, 31);
	range_test(month, 1, 12);
	range_test(year, STARTOFTIME, 2038);	/* 2038 is the end of time. */

	tmp = 0;

	for (i = STARTOFTIME; i < year; i++)
		tmp += days_in_year(i);
	if (leapyear(year) && month > FEBRUARY)
		tmp++;

	for (i = 1; i < month; i++)
	  	tmp += days_in_month(i);

	tmp += (day - 1);
	tmp = ((tmp * 24 + hour) * 60 + min) * 60 + sec;

	*timbuf = tmp;
	return(1);
}

void
read_bbc()
{
  	int i, read_okay;

	read_okay = 0;
	while (!read_okay) {
		read_okay = 1;
		for (i = 0; i <= NUM_BBC_REGS; i++)
			bbc_registers[i] = read_bbc_reg(i);
		for (i = 0; i <= NUM_BBC_REGS; i++)
			if (bbc_registers[i] != read_bbc_reg(i))
				read_okay = 0;
	}
}

u_char
read_bbc_reg(reg)
	int reg;
{
	u_char data = reg;

	if (bbcaddr != NULL) {
		send_clock_cmd(bbcaddr, BBC_SET_REG, &data, 1, NULL);
		send_clock_cmd(bbcaddr, BBC_READ_REG, NULL, 0, &data);
	}
	return(data);
}

u_char
write_bbc_reg(reg, data)
	int reg;
	u_int data;
{
	u_char tmp;

	tmp = (u_char) ((data << HIL_SSHIFT) | reg);

	if (bbcaddr != NULL) {
		send_clock_cmd(bbcaddr, BBC_SET_REG, &tmp, 1, NULL);
		send_clock_cmd(bbcaddr, BBC_WRITE_REG, NULL, 0, NULL);
		send_clock_cmd(bbcaddr, BBC_READ_REG, NULL, 0, &tmp);
	}
	return(tmp);
}

/*
 * Battery-backed clock command interface.
 * The BBC appears to have an HIL-like command interface, but can not attach
 * as a complete HIL device to an HIL controller driver.
 * The following routine is a simplified command loop.
 */
void
send_clock_cmd(volatile u_int8_t *address, u_int8_t cmd, u_int8_t *data,
    u_int8_t dlen, u_int8_t *rdata)
{
	u_int8_t status;
	int s;

	s = splvm();

	while ((address[HILP_STAT] & HIL_BUSY) != 0)
		DELAY(1);
	address[HILP_CMD] = cmd;
	while (dlen--) {
		while ((address[HILP_STAT] & HIL_BUSY) != 0)
			DELAY(1);
		address[HILP_DATA] = *data++;
		DELAY(1);
	}
	if (rdata != NULL) {
		do {
			while ((address[HILP_STAT] & HIL_DATA_RDY) == 0)
				DELAY(1);
			status = address[HILP_STAT];
			*rdata = address[HILP_DATA];
			DELAY(1);
		} while (((status >> HIL_SSHIFT) & HIL_SMASK) != HIL_68K);
	}

	splx(s);
}
@


1.15
log
@Switch hp300 to timecounters. From NetBSD via martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2010/09/20 06:33:47 matthew Exp $	*/
@


1.14
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2005/12/03 21:36:17 brad Exp $	*/
a52 1
#include <sys/tty.h>
d54 1
d67 3
a69 1
int    clkstd[1];
a70 1
static int clkint;		/* clock interval, as loaded */
d93 1
d122 4
d275 2
d340 2
a341 6
/*
 * Return the best possible estimate of the current time.
 */
void
microtime(tvp)
	struct timeval *tvp;
d344 3
a346 1
	int s, u, t, u2, s2;
a347 10
	/*
	 * Read registers from slowest-changing to fastest-changing,
	 * then re-read out to slowest.  If the values read before the
	 * innermost match those read after, the innermost value is
	 * consistent with the outer values.  If not, it may not be and
	 * we must retry.  Typically this loop runs only once; occasionally
	 * it runs twice, and only rarely does it run longer.
	 *
	 * (Using this loop avoids the need to block interrupts.)
	 */
d349 12
a360 13
	do {
		s = time.tv_sec;
		u = time.tv_usec;
		asm volatile (" clrl %0; movpw %1@@(5),%0"
			      : "=d" (t) : "a" (clk));
		u2 = time.tv_usec;
		s2 = time.tv_sec;
	} while (u != u2 || s != s2);

	u += (clkint - t) * CLK_RESOLUTION;
	if (u >= 1000000) {		/* normalize */
		s++;
		u -= 1000000;
d362 3
a364 2
	tvp->tv_sec = s;
	tvp->tv_usec = u;
d377 14
d417 10
a426 4
	if (base < 5*SECYR) {
		printf("WARNING: preposterous time in file system");
		timbuf = 6*SECYR + 186*SECDAY + SECDAY/2;
		printf(" -- CHECK AND RESET THE DATE!\n");
d430 4
a433 1
	time.tv_sec = timbuf;
d448 1
a448 1
	tmptr = gmt_to_bbc(time.tv_sec);
@


1.13
log
@splimp -> splvm

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2005/01/14 22:39:27 miod Exp $	*/
d256 2
a257 2
	evcount_attach(&statcnt, "stat", &stat_ipl, &evcount_intr);
	evcount_attach(&clockcnt, "clock", &clock_ipl, &evcount_intr);
@


1.12
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2004/10/02 21:28:54 miod Exp $	*/
d587 1
a587 1
	s = splimp();
@


1.11
log
@Associate ipl levels to clock and statclock coconuts.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2004/09/29 07:35:54 miod Exp $	*/
d60 1
a60 3
#include <hp300/dev/hilreg.h>
#include <hp300/dev/hilioctl.h>
#include <hp300/dev/hilvar.h>
d88 1
a88 1
struct hil_dev *bbcaddr = NULL;
d98 2
d156 1
a156 1
		
d384 8
a391 4
		if (badbaddr((caddr_t)&BBCADDR->hil_stat))
			printf("WARNING: no battery clock\n");
		else
			bbcaddr = BBCADDR;
d401 5
a405 3
	if (!bbc_to_gmt(&timbuf) || timbuf < base) {
		printf("WARNING: bad date in battery clock\n");
		timbuf = base;
d412 1
a412 1
	
d426 3
d470 1
a470 1
	
d480 2
a481 2
	rt.tm_mday = day + 1;  
	
d520 1
a520 1
	
d550 3
a552 3
	if (bbcaddr) {
		send_hil_cmd(bbcaddr, BBC_SET_REG, &data, 1, NULL);
		send_hil_cmd(bbcaddr, BBC_READ_REG, NULL, 0, &data);
d566 4
a569 4
	if (bbcaddr) {
		send_hil_cmd(bbcaddr, BBC_SET_REG, &tmp, 1, NULL);
		send_hil_cmd(bbcaddr, BBC_WRITE_REG, NULL, 0, NULL);
		send_hil_cmd(bbcaddr, BBC_READ_REG, NULL, 0, &tmp);
d572 38
a609 1
}	
@


1.10
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2003/06/02 23:27:45 millert Exp $	*/
d102 2
d256 2
a257 2
	evcount_attach(&statcnt, "stat", NULL, &evcount_intr);
	evcount_attach(&clockcnt, "clock", NULL, &evcount_intr);
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2003/02/11 19:20:25 mickey Exp $	*/
d54 1
d92 1
d102 3
d254 3
d286 11
a298 2
 *
 * DO THIS INLINE IN locore.s?
d326 1
@


1.8
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2002/03/14 01:26:30 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 2000/01/14 09:09:47 downsj Exp $	*/
d48 1
a48 1
 *	Timers 1 and 3 are externally driver from a 25Mhz source.
@


1.6
log
@I could be wrong, but I doubt the world is going to end this year.  Let's
give us at least through 2038 (which is the end of time, anyway).  :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 1997/07/06 08:01:58 downsj Exp $	*/
d95 1
a95 1
void	statintr __P((struct clockframe *));
d97 6
a102 6
void	hp300_calibrate_delay __P((void));
struct bbc_tm *gmt_to_bbc __P((long));
int	bbc_to_gmt __P((u_long *));
void	read_bbc __P((void));
u_char	read_bbc_reg __P((int));
u_char	write_bbc_reg __P((int, u_int));
@


1.6.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 2000/01/14 09:09:47 downsj Exp $	*/
d95 1
a95 1
void	statintr(struct clockframe *);
d97 6
a102 6
void	hp300_calibrate_delay(void);
struct bbc_tm *gmt_to_bbc(long);
int	bbc_to_gmt(u_long *);
void	read_bbc(void);
u_char	read_bbc_reg(int);
u_char	write_bbc_reg(int, u_int);
@


1.6.12.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
 *	Timers 1 and 3 are externally driver from a 25MHz source.
@


1.6.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 1
a95 1
void	statintr(struct clockframe *);
d97 6
a102 6
void	hp300_calibrate_delay(void);
struct bbc_tm *gmt_to_bbc(long);
int	bbc_to_gmt(u_long *);
void	read_bbc(void);
u_char	read_bbc_reg(int);
u_char	write_bbc_reg(int, u_int);
@


1.6.2.2
log
@Sync the SMP branch with 3.3
@
text
@d48 1
a48 1
 *	Timers 1 and 3 are externally driver from a 25MHz source.
@


1.6.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6.2.2 2003/03/27 23:19:21 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 1997/04/16 11:56:21 downsj Exp $	*/
d484 1
a484 1
	range_test(year, STARTOFTIME, 2000);
@


1.4
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.3 1997/01/12 15:13:11 downsj Exp $	*/
/*	$NetBSD: clock.c,v 1.19 1997/04/01 03:12:09 scottr Exp $	*/
d61 1
@


1.3
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: clock.c,v 1.18 1996/10/13 03:14:27 christos Exp $	*/
d55 1
d57 1
d63 2
a90 1
struct bbc_tm *gmt_to_bbc();
a91 1
u_char write_bbc_reg(), read_bbc_reg();
d94 2
d97 5
d200 1
d203 2
a204 2
	register volatile struct clkreg *clk;
	register int intvl, statint, profint, minint;
d290 2
a291 2
	register volatile struct clkreg *clk;
	register int newint, r, var;
d320 1
a320 1
	register struct timeval *tvp;
d322 2
a323 2
	register volatile struct clkreg *clk;
	register int s, u, t, u2, s2;
d358 1
d397 1
d400 2
a401 2
	register int i;
	register struct bbc_tm *tmptr;
d428 2
a429 2
	register int i;
	register long hms, day;
d459 1
d463 2
a464 2
	register int i;
	register u_long tmp;
d502 1
d505 1
a505 1
  	register int i, read_okay;
@


1.2
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: clock.c,v 1.14 1996/05/18 23:30:12 thorpej Exp $	*/
d169 8
d356 1
a356 1
		if (badbaddr(&BBCADDR->hil_stat))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.13 1994/12/29 03:48:38 mycroft Exp $	*/
a54 2
#include <hp300/dev/hilreg.h>
#include <hp300/hp300/clockreg.h>
d59 3
d91 2
d107 72
a180 1
 *
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
