head	1.25;
access;
symbols
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.8
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.6
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.14
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.7.0.18
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.16
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.14
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2010.06.29.20.30.31;	author guenther;	state dead;
branches;
next	1.24;

1.24
date	2009.12.28.16.40.44;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.25.22.42.58;	author weingart;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.01.15.30.29;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.06.17.23.39;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.06.12.10.28;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.01.18.37.26;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.04.22.08.14;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.09.22.27.08;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.02.16.11.11;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.20.19.24.55;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.08.11.23.21.13;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.27.04.05.45;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.04.22.48.59;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	97.07.06.08.01.59;	author downsj;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.04.17.10.28.36;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.04.16.11.56.23;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.03.26.08.32.41;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.01.12.15.13.16;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.04.25.06.37.04;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.13.55.28;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.07.04.10.15.40;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2003.03.27.23.19.21;	author niklas;	state Exp;
branches;
next	1.7.12.5;

1.7.12.5
date	2003.06.07.11.11.35;	author ho;	state Exp;
branches;
next	1.7.12.6;

1.7.12.6
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@/*	$OpenBSD: hpux_machdep.c,v 1.24 2009/12/28 16:40:44 miod Exp $	*/
/*	$NetBSD: hpux_machdep.c,v 1.19 1998/02/16 20:58:30 thorpej Exp $	*/

/*
 * Copyright (c) 1995, 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Machine-dependent bits for HP-UX binary compatibility.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/exec.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/poll.h>
#include <sys/proc.h>
#include <sys/ptrace.h>
#include <sys/signalvar.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/tty.h>
#include <sys/user.h>
#include <sys/vnode.h>
#include <sys/wait.h>

#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/vmparam.h>

#include <uvm/uvm_extern.h>

#include <sys/syscallargs.h>

#include <compat/hpux/hpux.h>
#include <compat/hpux/hpux_sig.h>
#include <compat/hpux/hpux_util.h>
#include <compat/hpux/hpux_syscall.h>
#include <compat/hpux/hpux_syscallargs.h>

#include <machine/hpux_machdep.h>

extern	short exframesize[];

struct valtostr {
	int	val;
	const char *str;
};

/*
 * 6.0 and later context.
 * XXX what are the HP-UX "localroot" semantics?  Should we handle
 * XXX diskless systems here?
 */
static const char context_040[] =
    "standalone HP-MC68040 HP-MC68881 HP-MC68020 HP-MC68010 localroot default";

static const char context_fpu[] =
    "standalone HP-MC68881 HP-MC68020 HP-MC68010 localroot default";

static const char context_nofpu[] =
    "standalone HP-MC68020 HP-MC68010 localroot default";

static struct valtostr context_table[] = {
	{ FPU_68060,	&context_040[0] },
	{ FPU_68040,	&context_040[0] },
	{ FPU_68882,	&context_fpu[0] },
	{ FPU_68881,	&context_fpu[0] },
	{ 0, NULL },
};

#define UOFF(f)		((int)&((struct user *)0)->f)
#define HPUOFF(f)	((int)&((struct hpux_user *)0)->f)

/* simplified FP structure */
struct bsdfp {
	int save[54];
	int reg[24];
	int ctrl[3];
};

/*
 * m68k-specific setup for HP-UX executables.
 */
int
hpux_cpu_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	/* struct hpux_exec *hpux_ep = epp->ep_hdr; */

	/* set up command for exec header */
	NEW_VMCMD(&epp->ep_vmcmds, hpux_cpu_vmcmd,
	    sizeof(struct hpux_exec), (long)epp->ep_hdr, NULLVP, 0, 0);
	return (0);
}

/*
 * We need to setup pcb cacheability information correctly, so we define
 * this vmcmd to do it for us, since vmcmds are executed once
 * we're committed to the exec (i.e. the old program has been unmapped).
 */
int
hpux_cpu_vmcmd(p, ev)
	struct proc *p;
	struct exec_vmcmd *ev;
{
	struct hpux_exec *execp = (struct hpux_exec *)ev->ev_addr;

	/* Deal with misc. HP-UX process attributes. */
	if (execp->ha_trsize & HPUXM_VALID) {
		if (execp->ha_trsize & HPUXM_DATAWT)
			p->p_md.md_flags &= ~MDP_CCBDATA;

		if (execp->ha_trsize & HPUXM_STKWT)
			p->p_md.md_flags &= ~MDP_CCBSTACK;
	}

	return (0);
}

/*
 * Return arch-type for hpux_sys_sysconf()
 */
int
hpux_cpu_sysconf_arch()
{

	switch (cputype) {
	case CPU_68020:
		return (HPUX_SYSCONF_CPUM020);

	case CPU_68030:
		return (HPUX_SYSCONF_CPUM030);

	default:
		return (HPUX_SYSCONF_CPUM040);
	}
	/* NOTREACHED */
}

/*
 * HP-UX advise(2) system call.
 */
int
hpux_sys_advise(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_advise_args *uap = v;
	int error = 0;

	switch (SCARG(uap, arg)) {
	case 0:
		p->p_md.md_flags |= MDP_HPUXMMAP;
		break;

	case 1:
		ICIA();
		break;

	case 2:
		DCIA();
		break;

	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * HP-UX getcontext(2) system call.
 * Man page lies, behaviour here is based on observed behaviour.
 */
int
hpux_sys_getcontext(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_getcontext_args *uap = v;
	const char *str;
	int l, i, error = 0;
	int len;

	if (SCARG(uap, len) <= 0)
		return (EINVAL);

	for (i = 0; context_table[i].str != NULL; i++)
		if (context_table[i].val == fputype)
			break;
	if (context_table[i].str == NULL)
		str = &context_nofpu[0];
	else
		str = context_table[i].str;

	/* + 1 ... count the terminating \0. */
	l = strlen(str) + 1;
	len = min(SCARG(uap, len), l);

	if (len)
		error = copyout(str, SCARG(uap, buf), len);
	if (error == 0)
		*retval = l;
	return (0);
}

/*
 * Brutal hack!  Map HP-UX u-area offsets into BSD k-stack offsets.
 * XXX This probably doesn't work anymore, BTW.  --thorpej
 */
int
hpux_to_bsd_uoff(off, isps, p)
	int *off, *isps;
	struct proc *p;
{
	int *ar0 = p->p_md.md_regs;
	struct hpux_fp *hp;
	struct bsdfp *bp;
	u_int raddr;

	*isps = 0;

	/* u_ar0 field; procxmt puts in U_ar0 */
	if ((int)off == HPUOFF(hpuxu_ar0))
		return(UOFF(U_ar0));

	if (fputype) {
		/* FP registers from PCB */
		hp = (struct hpux_fp *)HPUOFF(hpuxu_fp);
		bp = (struct bsdfp *)UOFF(u_pcb.pcb_fpregs);

		if (off >= hp->hpfp_ctrl && off < &hp->hpfp_ctrl[3])
			return((int)&bp->ctrl[off - hp->hpfp_ctrl]);

		if (off >= hp->hpfp_reg && off < &hp->hpfp_reg[24])
			return((int)&bp->reg[off - hp->hpfp_reg]);
	}

	/*
	 * Everything else we recognize comes from the kernel stack,
	 * so we convert off to an absolute address (if not already)
	 * for simplicity.
	 */
	if (off < (int *)ptoa(UPAGES))
		off = (int *)((u_int)off + (u_int)p->p_addr);	/* XXX */

	/*
	 * General registers.
	 * We know that the HP-UX registers are in the same order as ours.
	 * The only difference is that their PS is 2 bytes instead of a
	 * padded 4 like ours throwing the alignment off.
	 */
	if (off >= ar0 && off < &ar0[18]) {
		/*
		 * PS: return low word and high word of PC as HP-UX would
		 * (e.g. &u.u_ar0[16.5]).
		 *
		 * XXX we don't do this since HP-UX adb doesn't rely on
		 * it and passing such an offset to procxmt will cause
		 * it to fail anyway.  Instead, we just set the offset
		 * to PS and let hpux_ptrace() shift up the value returned.
		 */
		if (off == &ar0[PS]) {
#if 0
			raddr = (u_int) &((short *)ar0)[PS*2+1];
#else
			raddr = (u_int) &ar0[(int)(off - ar0)];
#endif
			*isps = 1;
		}
		/*
		 * PC: off will be &u.u_ar0[16.5] since HP-UX saved PS
		 * is only 16 bits.
		 */
		else if (off == (int *)&(((short *)ar0)[PS*2+1]))
			raddr = (u_int) &ar0[PC];
		/*
		 * D0-D7, A0-A7: easy
		 */
		else
			raddr = (u_int) &ar0[(int)(off - ar0)];
		return((int)(raddr - (u_int)p->p_addr));	/* XXX */
	}

	/* everything else */
	return (-1);
}

#define	HSS_RTEFRAME	0x01
#define	HSS_FPSTATE	0x02
#define	HSS_USERREGS	0x04

struct hpuxsigstate {
	int	hss_flags;		/* which of the following are valid */
	struct	frame hss_frame;	/* original exception frame */
	struct	fpframe hss_fpstate;	/* 68881/68882 state info */
};

/*
 * WARNING: code in locore.s assumes the layout shown here for hsf_signum
 * thru hsf_handler so... don't screw with them!
 */
struct hpuxsigframe {
	int	hsf_signum;		   /* signo for handler */
	int	hsf_code;		   /* additional info for handler */
	struct	hpuxsigcontext *hsf_scp;   /* context ptr for handler */
	sig_t	hsf_handler;		   /* handler addr for u_sigc */
	struct	hpuxsigstate hsf_sigstate; /* state of the hardware */
	struct	hpuxsigcontext hsf_sc;	   /* actual context */
};

#ifdef DEBUG
int hpuxsigdebug = 0;
int hpuxsigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
/* ARGSUSED */
void
hpux_sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	struct proc *p = curproc;
	struct hpuxsigframe *kfp, *fp;
	struct frame *frame;
	struct sigacts *psp = p->p_sigacts;
	short ft;
	int oonstack, fsize;

	frame = (struct frame *)p->p_md.md_regs;
	ft = frame->f_format;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct hpuxsigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct hpuxsigframe *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct hpuxsigframe *)(frame->f_regs[SP] - fsize);
	if ((unsigned)fp <= USRSTACK - ptoa(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, (unsigned)fp);

#ifdef DEBUG
	if ((hpuxsigdebug & SDB_KSTACK) && p->p_pid == hpuxsigpid)
		printf("hpux_sendsig(%d): sig %d ssp %p usp %p scp %p ft %d\n",
		       p->p_pid, sig, &oonstack, fp, &fp->hsf_sc, ft);
#endif

	kfp = (struct hpuxsigframe *)malloc((u_long)fsize, M_TEMP,
	    M_WAITOK | M_CANFAIL);
	if (kfp == NULL) {
		/* Better halt the process in its track than panicing */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/*
	 * Build the argument list for the signal handler.
	 */
	kfp->hsf_signum = bsdtohpuxsig(sig);
	kfp->hsf_code = code;
	kfp->hsf_scp = &fp->hsf_sc;
	kfp->hsf_handler = catcher;

	/*
	 * Save necessary hardware state.  Currently this includes:
	 *	- general registers
	 *	- original exception frame (if not a "normal" frame)
	 *	- FP coprocessor state
	 */
	kfp->hsf_sigstate.hss_flags = HSS_USERREGS;
	bcopy((caddr_t)frame->f_regs,
	    (caddr_t)kfp->hsf_sigstate.hss_frame.f_regs, sizeof frame->f_regs);
	if (ft >= FMT7) {
#ifdef DEBUG
		if (ft > 15 || exframesize[ft] < 0)
			panic("hpux_sendsig: bogus frame type");
#endif
		kfp->hsf_sigstate.hss_flags |= HSS_RTEFRAME;
		kfp->hsf_sigstate.hss_frame.f_format = frame->f_format;
		kfp->hsf_sigstate.hss_frame.f_vector = frame->f_vector;
		bcopy((caddr_t)&frame->F_u,
		    (caddr_t)&kfp->hsf_sigstate.hss_frame.F_u, exframesize[ft]);

		/*
		 * Leave an indicator that we need to clean up the kernel
		 * stack.  We do this by setting the "pad word" above the
		 * hardware stack frame to the amount the stack must be
		 * adjusted by.
		 *
		 * N.B. we increment rather than just set f_stackadj in
		 * case we are called from syscall when processing a
		 * sigreturn.  In that case, f_stackadj may be non-zero.
		 */
		frame->f_stackadj += exframesize[ft];
		frame->f_format = frame->f_vector = 0;
#ifdef DEBUG
		if (hpuxsigdebug & SDB_FOLLOW)
			printf("hpux_sendsig(%d): copy out %d of frame %d\n",
			       p->p_pid, exframesize[ft], ft);
#endif
	}
	if (fputype) {
		kfp->hsf_sigstate.hss_flags |= HSS_FPSTATE;
		m68881_save(&kfp->hsf_sigstate.hss_fpstate);
	}

#ifdef DEBUG
	if ((hpuxsigdebug & SDB_FPSTATE) &&
	    *(char *)&kfp->hsf_sigstate.hss_fpstate)
		printf("hpux_sendsig(%d): copy out FP state (%x) to %p\n",
		       p->p_pid, *(u_int *)&kfp->hsf_sigstate.hss_fpstate,
		       &kfp->hsf_sigstate.hss_fpstate);
#endif

	/*
	 * Build the signal context to be used by hpux_sigreturn.
	 */
	kfp->hsf_sc.hsc_syscall	= 0;		/* XXX */
	kfp->hsf_sc.hsc_action	= 0;		/* XXX */
	kfp->hsf_sc.hsc_pad1	= kfp->hsf_sc.hsc_pad2 = 0;
	kfp->hsf_sc.hsc_onstack	= oonstack;
	kfp->hsf_sc.hsc_mask	= mask;
	kfp->hsf_sc.hsc_sp	= frame->f_regs[SP];
	kfp->hsf_sc.hsc_ps	= frame->f_sr;
	kfp->hsf_sc.hsc_pc	= frame->f_pc;

	/* How amazingly convenient! */
	kfp->hsf_sc._hsc_pad	= 0;
	kfp->hsf_sc._hsc_ap	= (int)&fp->hsf_sigstate;

	if (copyout((caddr_t)kfp, (caddr_t)fp, fsize) != 0) {
#ifdef DEBUG
		if ((hpuxsigdebug & SDB_KSTACK) && p->p_pid == hpuxsigpid)
			printf("hpux_sendsig(%d): copyout failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		free((caddr_t)kfp, M_TEMP);
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}
	frame->f_regs[SP] = (int)fp;

#ifdef DEBUG
	if (hpuxsigdebug & SDB_FOLLOW) {
		printf(
		  "hpux_sendsig(%d): sig %d scp %p fp %p sc_sp %x sc_ap %x\n",
		   p->p_pid, sig, kfp->hsf_scp, fp,
		   kfp->hsf_sc.hsc_sp, kfp->hsf_sc._hsc_ap);
	}
#endif

	/*
	 * Signal trampoline code is at base of user stack.
	 */
	frame->f_pc = p->p_sigcode;
#ifdef DEBUG
	if ((hpuxsigdebug & SDB_KSTACK) && p->p_pid == hpuxsigpid)
		printf("hpux_sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
	free((caddr_t)kfp, M_TEMP);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
hpux_sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigreturn_args /* {
		syscallarg(struct hpuxsigcontext *) sigcntxp;
	} */ *uap = v;
	struct hpuxsigcontext *scp;
	struct frame *frame;
	int rf;
	struct hpuxsigcontext tsigc;
	struct hpuxsigstate tstate;
	int flags;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (hpuxsigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
	if ((int)scp & 1)
		return (EINVAL);

	/*
	 * Fetch and test the HP-UX context structure.
	 * We grab it all at once for speed.
	 */
	if (copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
		return (EINVAL);
	scp = &tsigc;
	if ((scp->hsc_ps & PSL_USERCLR) != 0 ||
	    (scp->hsc_ps & PSL_USERSET) != PSL_USERSET)
		return (EINVAL);

	/*
	 * Restore the user supplied information
	 */
	if (scp->hsc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->hsc_mask &~ sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->hsc_sp;
	frame->f_pc = scp->hsc_pc;
	frame->f_sr = scp->hsc_ps;

	/*
	 * Grab a pointer to the hpuxsigstate.
	 * If zero, the user is probably doing a longjmp.
	 * (This will never happen, really, since HP-UX doesn't
	 * know/care about the state pointer.)
	 */
	if ((rf = scp->_hsc_ap) == 0)
		return (EJUSTRETURN);

	/*
	 * See if there is anything to do before we go to the
	 * expense of copying in close to 1/2K of data
	 */
	if (copyin((caddr_t)rf, &flags, sizeof(int)) != 0)
		return (EINVAL);
#ifdef DEBUG
	if (hpuxsigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): sc_ap %x flags %x\n",
		       p->p_pid, rf, flags);
#endif
	if (flags == 0 || copyin((caddr_t)rf, (caddr_t)&tstate, sizeof tstate))
		return (EJUSTRETURN);
#ifdef DEBUG
	if ((hpuxsigdebug & SDB_KSTACK) && p->p_pid == hpuxsigpid)
		printf("sigreturn(%d): ssp %p usp %x scp %p ft %d\n",
		       p->p_pid, &flags, scp->hsc_sp, SCARG(uap, sigcntxp),
		       (flags & HSS_RTEFRAME) ? tstate.hss_frame.f_format : -1);
#endif
	/*
	 * Restore most of the users registers except for A6 and SP
	 * which were handled above.
	 */
	if (flags & HSS_USERREGS)
		bcopy((caddr_t)tstate.hss_frame.f_regs,
		    (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*sizeof(int));

	/*
	 * Restore long stack frames.  Note that we do not copy
	 * back the saved SR or PC, they were picked up above from
	 * the sigcontext structure.
	 */
	if (flags & HSS_RTEFRAME) {
		int sz;

		/* grab frame type and validate */
		sz = tstate.hss_frame.f_format;
		if (sz > 15 || (sz = exframesize[sz]) < 0)
			return (EINVAL);
		frame->f_stackadj -= sz;
		frame->f_format = tstate.hss_frame.f_format;
		frame->f_vector = tstate.hss_frame.f_vector;
		bcopy((caddr_t)&tstate.hss_frame.F_u,
		    (caddr_t)&frame->F_u, sz);
#ifdef DEBUG
		if (hpuxsigdebug & SDB_FOLLOW)
			printf("sigreturn(%d): copy in %d of frame type %d\n",
			       p->p_pid, sz, tstate.hss_frame.f_format);
#endif
	}

	/*
	 * Finally we restore the original FP context
	 */
	if (flags & HSS_FPSTATE)
		m68881_restore(&tstate.hss_fpstate);

#ifdef DEBUG
	if ((hpuxsigdebug & SDB_FPSTATE) && *(char *)&tstate.hss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %p\n",
		       p->p_pid, *(u_int *)&tstate.hss_fpstate,
		       &tstate.hss_fpstate);

	if ((hpuxsigdebug & SDB_FOLLOW) ||
	    ((hpuxsigdebug & SDB_KSTACK) && p->p_pid == hpuxsigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
}

/*
 * Set registers on exec.
 * XXX Should clear registers except sp, pc.
 */
void
hpux_setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct frame *frame = (struct frame *)p->p_md.md_regs;

	frame->f_pc = pack->ep_entry & ~1;
	frame->f_regs[SP] = stack;
	frame->f_regs[A2] = (int)PS_STRINGS;

	/* restore a null state frame */
	p->p_addr->u_pcb.pcb_fpregs.fpf_null = 0;
	if (fputype)
		m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);

	p->p_md.md_flags &= ~MDP_HPUXMMAP;
	frame->f_regs[A0] = 0;	/* not 68010 (bit 31), no FPA (30) */
	retval[0] = 0;		/* no float card */
	if (fputype)
		retval[1] = 1;	/* yes 68881 */
	else
		retval[1] = 0;	/* no 68881 */
}
@


1.24
log
@We do not need to store a copy of the HP-UX exec structure in the pcb since
we don't put HP-UX bits in the coredumps and hpux_dumpu() has bitten the dust
twelve years ago. Notice by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.23 2009/03/25 22:42:58 weingart Exp $	*/
@


1.23
log
@Nuke old useless define.  Miod was ok with the idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.22 2008/05/01 15:30:29 miod Exp $	*/
d141 1
a141 1
 * We need to stash the exec header in the pcb, so we define
a143 3
 *
 * The address of the header is in ev->ev_addr and the length is
 * in ev->ev_len.
a150 5

	/* Make sure we have room. */
	if (ev->ev_len <= sizeof(p->p_addr->u_md.md_exec))
		bcopy((caddr_t)ev->ev_addr, p->p_addr->u_md.md_exec,
		    ev->ev_len);
@


1.22
log
@Sync hpux_sendsig() behaviour with native sendsig(): let malloc fail and
sigexit the process in this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.21 2007/11/02 19:18:54 martin Exp $	*/
d635 1
a635 1
		    (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
@


1.21
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.20 2005/11/06 17:23:39 miod Exp $	*/
d422 7
a428 1
	kfp = (struct hpuxsigframe *)malloc((u_long)fsize, M_TEMP, M_WAITOK);
@


1.20
log
@Homogeneize all PSR field tests in user-provided structures. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.19 2005/08/06 12:10:28 miod Exp $	*/
d299 1
a299 1
	if (off < (int *)ctob(UPAGES))
d413 1
a413 1
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
@


1.19
log
@If a process has trashed its stack, use sigexit() instead of psignal() to
terminate it with prejudice, as done in native sendsig().
Plus you get a memory leak in COMPAT_HPUX on m68k fixed for free.

review art@@ test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.18 2005/01/15 21:13:08 miod Exp $	*/
d578 2
a579 1
	if ((scp->hsc_ps & (PSL_MBZ|PSL_IPL|PSL_S)) != 0)
@


1.18
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.17 2003/08/01 18:37:26 miod Exp $	*/
d39 1
a39 1
 * Machinde-dependent bits for HP-UX binary compatibility.
d509 3
a511 7
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
@


1.17
log
@Nuke calls to uvm_useracc() and instead check copyin() and copyout() for
failure, since the former is not reliable; requested by art@@ long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.16 2003/06/04 22:08:14 deraadt Exp $	*/
d57 2
a58 2
#include <sys/poll.h> 
#include <sys/proc.h> 
d66 1
a66 1
#include <sys/wait.h> 
d206 1
a206 1
		p->p_md.md_flags |= MDP_HPUXMMAP; 
d231 1
a231 1
	struct proc *p; 
d233 1
a233 1
	register_t *retval; 
d238 1
a238 1
	int len; 
d268 1
a268 1
	int *off, *isps; 
d272 1
a272 1
	struct hpux_fp *hp; 
d280 1
a280 1
		return(UOFF(U_ar0)); 
d413 1
a413 1
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
d424 1
a424 1
	/* 
d641 1
a641 1
		
@


1.16
log
@Delete UCB term 3.  When there are other copyright owners, we affirm
that we can see no legal situation under which they could require that
term to remain (ie. This is equivelant to us taking the old UCB file,
removing term 3 as specified by UCB, then re-applying each diff
afterwards from the various authors)
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.15 2003/01/09 22:27:08 miod Exp $	*/
a421 18
	if (uvm_useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#ifdef DEBUG
		if ((hpuxsigdebug & SDB_KSTACK) && p->p_pid == hpuxsigpid)
			printf("hpux_sendsig(%d): useracc failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
d499 18
a516 1
	(void) copyout((caddr_t)kfp, (caddr_t)fp, fsize);
d579 1
a579 2
	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
@


1.15
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.14 2002/08/02 16:11:11 millert Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. The name of the author may not be used to endorse or promote products
@


1.14
log
@In hpux_sys_getcontext(), check for len <= 0 and return EINVAL.
Noted by Silvio Cesare
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.13 2002/07/20 19:24:55 art Exp $	*/
d617 2
a618 1
	flags = fuword((caddr_t)rf);
a623 5
	/*
	 * fuword failed (bogus _hsc_ap value).
	 */
	if (flags == -1)
		return (EINVAL);
@


1.13
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.12 2002/06/04 00:09:08 deraadt Exp $	*/
d243 3
@


1.12
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.11 2001/11/06 19:53:14 miod Exp $	*/
a393 1
	extern char sigcode[], esigcode[];
d533 1
a533 1
	frame->f_pc = (int)PS_STRINGS - (esigcode - sigcode);
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.10 2001/08/11 23:21:13 art Exp $	*/
d550 1
a550 1
 * psl to gain improper priviledges or to cause
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.11 2001/11/06 19:53:14 miod Exp $	*/
d550 1
a550 1
 * psl to gain improper privileges or to cause
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.11.2.1 2002/06/11 03:35:20 art Exp $	*/
a243 3
	if (SCARG(uap, len) <= 0)
		return (EINVAL);

d394 1
d534 1
a534 1
	frame->f_pc = p->p_sigcode;
@


1.11.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d617 1
a617 2
	if (copyin((caddr_t)rf, &flags, sizeof(int)) != 0)
		return (EINVAL);
d623 5
@


1.10
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.9 2001/06/27 04:05:45 art Exp $	*/
a75 2

#include <vm/vm.h>
@


1.9
log
@no more old VM
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.8 2001/05/04 22:48:59 aaron Exp $	*/
a77 2
#include <vm/vm_param.h>
#include <vm/vm_map.h> 
@


1.8
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.7 1997/07/06 08:01:59 downsj Exp $	*/
a80 1
#if defined(UVM)
a81 1
#endif
a418 1
#if defined(UVM)
a420 4
#else
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#endif
a427 1
#if defined(UVM)
a428 3
#else
	if (useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#endif
a585 1
#if defined(UVM)
a586 3
#else
	if (useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
#endif
@


1.7
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_machdep.c,v 1.6 1997/04/17 10:28:36 downsj Exp $	*/
/*	$NetBSD: hpux_machdep.c,v 1.13 1997/04/27 21:38:57 thorpej Exp $	*/
d81 4
d421 4
d427 1
d435 3
d439 1
d597 3
d601 1
@


1.7.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: hpux_machdep.c,v 1.19 1998/02/16 20:58:30 thorpej Exp $	*/
a80 2
#include <uvm/uvm_extern.h>

d418 1
a418 1
		(void)uvm_grow(p, (unsigned)fp);
d426 1
a426 1
	if (uvm_useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
d584 1
a584 1
	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
@


1.7.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.7.12.1 2001/07/04 10:15:40 niklas Exp $	*/
d78 2
@


1.7.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 2
@


1.7.12.4
log
@Sync the SMP branch with 3.3
@
text
@a243 3
	if (SCARG(uap, len) <= 0)
		return (EINVAL);

d394 1
d534 1
a534 1
	frame->f_pc = p->p_sigcode;
d550 1
a550 1
 * psl to gain improper privileges or to cause
d615 1
a615 2
	if (copyin((caddr_t)rf, &flags, sizeof(int)) != 0)
		return (EINVAL);
d621 5
@


1.7.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.7.12.4 2003/03/27 23:19:21 niklas Exp $	*/
d22 5
a26 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.7.12.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d422 18
d517 1
a517 18
	if (copyout((caddr_t)kfp, (caddr_t)fp, fsize) != 0) {
#ifdef DEBUG
		if ((hpuxsigdebug & SDB_KSTACK) && p->p_pid == hpuxsigpid)
			printf("hpux_sendsig(%d): copyout failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
d580 2
a581 1
	if (copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
@


1.6
log
@Better machine type identification from Mike Smith
(<miff@@spam.frisbee.net.au>).
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_machdep.c,v 1.5 1997/04/16 11:56:23 downsj Exp $	*/
/*	$NetBSD: hpux_machdep.c,v 1.12 1997/04/02 22:41:34 scottr Exp $	*/
a60 1
#include <sys/namei.h>
a80 7
#include <arch/hp300/dev/grfreg.h>
#include <arch/hp300/dev/grfioctl.h>
#include <arch/hp300/dev/grfvar.h>
#include <arch/hp300/dev/hilreg.h>
#include <arch/hp300/dev/hilioctl.h>
#include <arch/hp300/dev/hilvar.h>

a92 11
#define NHIL	1	/* XXX */
#include "grf.h"

#if NGRF > 0
extern	int grfopen __P((dev_t dev, int oflags, int devtype, struct proc *p));
#endif

#if NHIL > 0
extern	int hilopen __P((dev_t dev, int oflags, int devtype, struct proc *p));
#endif

a97 14
static struct valtostr machine_table[] = {
	{ HP_320,	"320" },
	{ HP_330,	"330" },	/* includes 318 and 319 */
	{ HP_340,	"340" },
	{ HP_350,	"350" },
	{ HP_360,	"360" },
	{ HP_370,	"370" },
	{ HP_375,	"375" },	/* includes 345 and 400 */
	{ HP_380,	"380" },
	{ HP_425,	"425" },
	{ HP_433,	"433" },
	{     -1,	"3?0" },	/* unknown system (???) */
};

d103 9
d113 4
a116 9
	{ FPU_68040,
    "standalone HP-MC68040 HP-MC68881 HP-MC68020 HP-MC68010 localroot default"
	},
	{ FPU_68881,
    "standalone HP-MC68881 HP-MC68020 HP-MC68010 localroot default"
	},
	{ FPU_NONE,
    "standalone HP-MC68020 HP-MC68010 localroot default"
	},
a131 1
 * XXX m68k/m68k/hpux_machdep.c?
a178 44
 * Machine-dependent stat structure conversion.
 */
void
hpux_cpu_bsd_to_hpux_stat(sb, hsb)
	struct stat *sb;
	struct hpux_stat *hsb;
{

	/* XXX I don't want to talk about it... */
	if ((sb->st_mode & S_IFMT) == S_IFCHR) {
#if NGRF > 0
		if (cdevsw[major(sb->st_rdev)].d_open == grfopen)
			hsb->hst_rdev = grfdevno(sb->st_rdev);
#endif
#if NHIL > 0
		if (cdevsw[major(sb->st_rdev)].d_open == hilopen)
			hsb->hst_rdev = hildevno(sb->st_rdev);
#endif
	}
}

/*
 * Machine-dependent uname information.
 */
void
hpux_cpu_uname(ut)
	struct hpux_utsname *ut;
{
	int i;

	bzero(ut->machine, sizeof(ut->machine));

	/*
	 * Find the current machine-ID in the table and
	 * copy the string into the uname.
	 */
	for (i = 0; machine_table[i].val != -1; ++i)
		if (machine_table[i].val == machineid)
			break;

	sprintf(ut->machine, "9000/%s", machine_table[i].str);
}

/*
d185 2
a186 4
	switch (machineid) {
	case HP_320:
	case HP_330:
	case HP_350:
d189 1
a189 4
	case HP_340:
	case HP_360:
	case HP_370:
	case HP_375:
d192 1
a192 3
	case HP_380:
	case HP_425:
	case HP_433:
a193 3

	default:
		return (HPUX_SYSCONF_CPUM020);	/* ??? */
d242 1
d249 4
a252 6
	if (context_table[i].str == NULL) {
		/*
		 * XXX What else?  It's not like this can happen...
		 */
		return (EINVAL);
	}
d255 1
a255 1
	l = strlen(context_table[i].str) + 1;
d259 1
a259 1
		error = copyout(context_table[i].str, SCARG(uap, buf), len);
@


1.5
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_machdep.c,v 1.4 1997/03/26 08:32:41 downsj Exp $	*/
d125 2
a126 1
	{ HP_380,	"380" },	/* includes 425 */
d272 1
@


1.4
log
@Merge changes from NetBSD, up to 3/19/97; undoes some local changes.
Changed to match new arch/m68k code.
genassym.cf is currently just a place holder.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_machdep.c,v 1.3 1997/01/12 15:13:16 downsj Exp $	*/
/*	$NetBSD: hpux_machdep.c,v 1.9 1997/03/16 10:00:45 thorpej Exp $	*/
a47 4
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/filedesc.h>
#include <sys/proc.h> 
d49 3
a51 1
#include <sys/wait.h> 
d53 8
a60 1
#include <sys/exec.h>
d62 2
a63 2
#include <sys/vnode.h>
#include <sys/ioctl.h>
d65 1
d68 1
a68 4
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/ipc.h>
#include <sys/namei.h>
d70 2
a71 2
#include <sys/mman.h>
#include <sys/conf.h>
d82 6
a87 2
#include <machine/cpu.h> 
#include <machine/reg.h>
d92 1
d167 1
a167 1
	struct hpux_exec *hpux_ep = epp->ep_hdr;
d172 1
d201 1
a201 1
			p->p_md.md_flags & ~MDP_CCBSTACK;
d325 1
a325 1
	register int len; 
d357 1
a357 1
	register int *ar0 = p->p_md.md_regs;
d360 1
a360 1
	register u_int raddr;
d473 5
a477 5
	register struct proc *p = curproc;
	register struct hpuxsigframe *kfp, *fp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short ft;
d505 2
a506 2
		printf("hpux_sendsig(%d): sig %d ssp %x usp %x scp %x ft %d\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
d581 5
a585 4
	if ((hpuxsigdebug & SDB_FPSTATE) && *(char *)&kfp->sf_state.ss_fpstate)
		printf("hpux_sendsig(%d): copy out FP state (%x) to %x\n",
		       p->p_pid, *(u_int *)&kfp->sf_state.ss_fpstate,
		       &kfp->sf_state.ss_fpstate);
d610 3
a612 3
		  "hpux_sendsig(%d): sig %d scp %x fp %x sc_sp %x sc_ap %x\n",
		   p->p_pid, sig, kfp->sf_scp, fp,
		   kfp->sf_sc.sc_sp, kfp->sf_sc.sc_ap);
d648 3
a650 3
	register struct hpuxsigcontext *scp;
	register struct frame *frame;
	register int rf;
d658 1
a658 1
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d715 3
a717 3
		printf("sigreturn(%d): ssp %x usp %x scp %x ft %d\n",
		       p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		       (flags & HSS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
d733 1
a733 1
		register int sz;
d747 1
a747 1
			       p->p_pid, sz, tstate.ss_frame.f_format);
d758 4
a761 4
	if ((hpuxsigdebug & SDB_FPSTATE) && *(char *)&tstate.ss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %x\n",
		       p->p_pid, *(u_int *)&tstate.ss_fpstate,
		       &tstate.ss_fpstate);
d776 1
a776 1
	register struct proc *p;
@


1.3
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: hpux_machdep.c,v 1.5 1996/10/14 06:51:50 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995, 1996 Jason R. Thorpe.  All rights reserved.
d91 2
d104 6
a109 4
static	struct {
	int	machine_id;
	char	*machine_str;
} machine_table[] = {
d122 17
a138 12
/* 6.0 and later style context */
#ifdef M68040
static char hpux_040context[] =
    "standalone HP-MC68040 HP-MC68881 HP-MC68020 HP-MC68010 localroot default";
#endif
#ifdef FPCOPROC
static char hpux_context[] =
    "standalone HP-MC68881 HP-MC68020 HP-MC68010 localroot default";
#else
static char hpux_context[] =
    "standalone HP-MC68020 HP-MC68010 localroot default";
#endif
d235 2
a236 2
	for (i = 0; machine_table[i].machine_id != -1; ++i)
		if (machine_table[i].machine_id == machineid)
d239 1
a239 1
	sprintf(ut->machine, "9000/%s", machine_table[i].machine_str);
d315 1
a315 1
	int error = 0;
d318 8
a325 8
#ifdef M68040
	if ((machineid == HP_380) || (machineid == HP_433)) {
		len = min(SCARG(uap, len), sizeof(hpux_040context));
		if (len)
			error = copyout(hpux_040context, SCARG(uap, buf), len);
		if (error == 0)
			*retval = sizeof(hpux_040context);
		return (error);
d327 5
a331 2
#endif
	len = min(SCARG(uap, len), sizeof(hpux_context));
d333 1
a333 1
		error = copyout(hpux_context, SCARG(uap, buf), (u_int)len);
d335 2
a336 2
		*retval = sizeof(hpux_context);
	return (error);
d359 4
d364 2
a365 4
#ifdef FPCOPROC
	/* FP registers from PCB */
	hp = (struct hpux_fp *)HPUOFF(hpuxu_fp);
	bp = (struct bsdfp *)UOFF(u_pcb.pcb_fpregs);
d367 3
a369 6
	if (off >= hp->hpfp_ctrl && off < &hp->hpfp_ctrl[3])
		return((int)&bp->ctrl[off - hp->hpfp_ctrl]);

	if (off >= hp->hpfp_reg && off < &hp->hpfp_reg[24])
		return((int)&bp->reg[off - hp->hpfp_reg]);
#endif
d421 31
d453 1
a453 3
 * Kludge up a uarea dump so that HP-UX debuggers can find out
 * what they need.  IMPORTANT NOTE: we do not EVEN attempt to
 * convert the entire user struct.
d455 8
a462 4
int
hpux_dumpu(vp, cred)
	struct vnode *vp;
	struct ucred *cred;
d464 11
a474 5
	int error = 0;
	struct proc *p = curproc;
	struct hpux_user *faku;
	struct bsdfp *bp;
	short *foop;
d477 5
a481 2
	 * Make sure there is no mistake about this being a real
	 * user structure.
d483 36
a518 2
	faku = (struct hpux_user *)malloc((u_long)ctob(1), M_TEMP, M_WAITOK);
	bzero((caddr_t)faku, ctob(1));
d520 7
a526 4
	/* Fill in the process sizes. */
	faku->hpuxu_tsize = p->p_vmspace->vm_tsize;
	faku->hpuxu_dsize = p->p_vmspace->vm_dsize;
	faku->hpuxu_ssize = p->p_vmspace->vm_ssize;
d529 4
a532 4
	 * Fill in the exec header for CDB.
	 * This was saved back in exec().  As far as I can tell CDB
	 * only uses this information to verify that a particular
	 * core file goes with a particular binary.
d534 43
a576 2
	bcopy((caddr_t)p->p_addr->u_md.md_exec,
	    (caddr_t)&faku->hpuxu_exdata, sizeof (struct hpux_exec));
d579 1
a579 3
	 * Adjust user's saved registers (on kernel stack) to reflect
	 * HP-UX order.  Note that HP-UX saves the SR as 2 bytes not 4
	 * so we have to move it up.
d581 24
a604 5
	faku->hpuxu_ar0 = p->p_md.md_regs;
	foop = (short *) p->p_md.md_regs;
	foop[32] = foop[33];
	foop[33] = foop[34];
	foop[34] = foop[35];
a605 1
#ifdef FPCOPROC
d607 1
a607 1
	 * Copy 68881 registers from our PCB format to HP-UX format
d609 40
a648 7
	bp = (struct bsdfp *) &p->p_addr->u_pcb.pcb_fpregs;
	bcopy((caddr_t)bp->save, (caddr_t)faku->hpuxu_fp.hpfp_save,
	    sizeof(bp->save));
	bcopy((caddr_t)bp->ctrl, (caddr_t)faku->hpuxu_fp.hpfp_ctrl,
	    sizeof(bp->ctrl));
	bcopy((caddr_t)bp->reg, (caddr_t)faku->hpuxu_fp.hpfp_reg,
	    sizeof(bp->reg));
d650 2
d654 2
a655 1
	 * Slay the dragon
d657 6
a662 1
	faku->hpuxu_dragon = -1;
d665 1
a665 2
	 * Dump this artfully constructed page in place of the
	 * user struct page.
d667 9
a675 2
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)faku, ctob(1), (off_t)0,
	    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
d678 20
a697 2
	 * Dump the remaining UPAGES-1 pages normally
	 * XXX Spot the wild guess.
d699 60
a758 4
	if (error == 0)
		error = vn_rdwr(UIO_WRITE, vp, (caddr_t)p->p_addr + ctob(1),
		    ctob(UPAGES-1), (off_t)ctob(1), UIO_SYSSPACE,
		    IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
d760 12
a771 1
	free((caddr_t)faku, M_TEMP);
d773 16
a788 1
	return (error);
@


1.2
log
@sync w/ Net 960424
@
text
@d1 2
a2 1
/*	$NetBSD: hpux_machdep.c,v 1.2 1996/02/14 02:56:45 thorpej Exp $	*/
d55 1
@


1.1
log
@from netbsd:
Move the obviously machine-dependent HP-UX compat code to hpux_machdep.{c,h}.
A fair bit of this, the m68k core dump and exec goo, can probably be
made into a generic m68k hpux module, eventually.
@
text
@d1 1
a1 1
/*	$NetBSD: hpux_machdep.c,v 1.1 1996/01/06 12:44:06 thorpej Exp $	*/
@
