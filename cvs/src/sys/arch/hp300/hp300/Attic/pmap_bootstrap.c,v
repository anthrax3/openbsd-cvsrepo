head	1.27;
access;
symbols
	OPENBSD_5_5:1.26.0.28
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.24
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.22
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.20
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.18
	OPENBSD_5_0:1.26.0.16
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.14
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.12
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.8
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.10
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.6
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.17
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.10
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.26;

1.26
date	2008.02.13.21.19.54;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.04.19.05.30;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.19.22.51.07;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.28.09.07.48;	author martin;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.03.18.45.47;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.30.21.26.15;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.30.21.22.19;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.23.04.58.25;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.10.21.10.45;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.20.19.02.27;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.14.21.44.04;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.11.30.20.58.18;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.19.21.32.57;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.05.16.13.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.11.23.24.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.22.19.27.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.03.07.12.41.33;	author deraadt;	state Exp;
branches
	1.6.10.1;
next	1.5;

1.5
date	97.07.06.08.02.08;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.04.16.11.56.31;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.01.12.15.13.26;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.29.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.24;	author deraadt;	state Exp;
branches;
next	;

1.6.10.1
date	2000.03.02.07.04.27;	author niklas;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2001.07.04.10.15.48;	author niklas;	state Exp;
branches;
next	1.6.10.3;

1.6.10.3
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.6.10.4;

1.6.10.4
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.6.10.5;

1.6.10.5
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.6.10.6;

1.6.10.6
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.6.10.7;

1.6.10.7
date	2003.03.27.23.19.21;	author niklas;	state Exp;
branches;
next	1.6.10.8;

1.6.10.8
date	2003.06.07.11.11.35;	author ho;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.08;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: pmap_bootstrap.c,v 1.26 2008/02/13 21:19:54 miod Exp $	*/
/*	$NetBSD: pmap_bootstrap.c,v 1.13 1997/06/10 18:56:50 veego Exp $	*/

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap_bootstrap.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/msgbuf.h>

#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/pte.h>
#include <machine/vmparam.h>

#include <machine/hp300spu.h>
#include <hp300/hp300/clockreg.h>

#include <uvm/uvm_extern.h>

caddr_t ledbase;	/* SPU LEDs mapping */

extern vaddr_t CLKbase, MMUbase;
extern char *extiobase;
extern int eiomapsize;

#define	RELOC(v, t)	*((t*)((u_int)&(v) + firstpa))
#define	PA2VA(v, t)	*((t*)((u_int)&(v)))

#define	MACHINE_IIOMAPSIZE	IIOMAPSIZE
#define	MACHINE_INTIOBASE	INTIOBASE
#define	MACHINE_EIOMAPSIZE	RELOC(eiomapsize, int)

#define	PMAP_MD_LOCALS		/* nothing */

#define	PMAP_MD_RELOC1()	/* nothing */

#define PMAP_MD_MAPIOSPACE()	/* nothing */

	/*
	 * intiobase, intiolimit: base and end of internal (DIO) IO space.
	 * MACHINE_IIOMAPSIZE pages prior to external IO space at end of
	 * static kernel page table.
	 * extiobase: base of external (DIO-II) IO space.
	 * MACHINE_EIOMAPSIZE pages at the end of the static kernel page table.
	 * CLKbase, MMUbase: important registers in internal IO space
	 * accessed from locore.
	 */
#define	PMAP_MD_RELOC2() \
do { \
	RELOC(intiobase, char *) = (char *)iiobase; \
	RELOC(intiolimit, char *) = (char *)eiobase; \
	RELOC(extiobase, char *) = (char *)eiobase; \
	RELOC(CLKbase, vaddr_t) = iiobase + CLKBASE; \
	RELOC(MMUbase, vaddr_t) = iiobase + MMUBASE; \
} while (0)

#define	PMAP_MD_MEMSIZE() \
do { \
	RELOC(avail_end, paddr_t) = MAXADDR - PAGE_SIZE - \
	    round_page(MSGBUFSIZE); \
} while (0)

	/*
	 * Allocate some fixed, special purpose kernel virtual addresses
	 */
#define	PMAP_MD_RELOC3() \
do { \
		RELOC(ledbase, caddr_t) = (caddr_t)va; \
		va += NBPG; \
} while (0)

#include <m68k/m68k/pmap_bootstrap.c>

void
pmap_init_md()
{
	vaddr_t		addr;

	/*
	 * mark as unavailable the regions which we have mapped in
	 * pmap_bootstrap().
	 */
	addr = (vaddr_t) intiobase;
	if (uvm_map(kernel_map, &addr,
		    ptoa(IIOMAPSIZE + eiomapsize),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
				UVM_INH_NONE, UVM_ADV_RANDOM,
				UVM_FLAG_FIXED)))
		panic("pmap_init: bogons in the VM system!");
}
@


1.26
log
@Offset the kernel message buffer down one page again, for the PROM scribbles
to the upper *two* pages actually.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.25 2008/01/04 19:05:30 miod Exp $	*/
@


1.25
log
@Do not leave a page unused after the kernel message buffer on m68k platforms.
While there, compute the physical memory size in a much simpler way on mac68k.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.24 2006/05/19 22:51:07 miod Exp $	*/
d91 2
a92 1
	RELOC(avail_end, paddr_t) = MAXADDR - round_page(MSGBUFSIZE); \
@


1.24
log
@Get rid of ``maxmem'' and fix the descriptive comment for ``physmem''.
Either maxmem is not used (mac68k), or the position of the physical memory
is set in stone so we don't need to know the top of the memory (MAXADDR
on hp300, physmem on mvme68k) it was pointing to.

Plus this gets rid of unused lowram on mvme68k - all the m68k world is not an
hp300, after all.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.23 2005/10/28 09:07:48 martin Exp $	*/
d91 1
a91 2
	RELOC(avail_end, paddr_t) = MAXADDR - \
	    (round_page(MSGBUFSIZE) + ptoa(1)); \
@


1.23
log
@convert the last m68k_btop() and m68k_ptob() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.22 2005/01/15 21:13:08 miod Exp $	*/
a55 1
extern int maxmem;
d91 1
a91 1
	RELOC(avail_end, paddr_t) = ptoa(RELOC(maxmem, int)) - \
@


1.22
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.21 2005/01/03 18:45:47 miod Exp $	*/
d92 2
a93 2
	RELOC(avail_end, paddr_t) = m68k_ptob(RELOC(maxmem, int)) - \
	    (round_page(MSGBUFSIZE) + m68k_ptob(1)); \
d118 1
a118 1
		    m68k_ptob(IIOMAPSIZE + eiomapsize),
@


1.21
log
@Left out one EIOMAPSIZE -> eiomapsize chunk by accident; millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.20 2004/12/30 21:26:15 miod Exp $	*/
d4 1
a4 1
/* 
@


1.20
log
@Kill the EIOMAPSIZE and instead, dynamically size the external I/O map,
based on the DIO-II space probing results.

This does not win much for now, but this will be very useful for SGC bus
support (coming soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.19 2004/12/30 21:22:19 miod Exp $	*/
d118 1
a118 1
		    m68k_ptob(IIOMAPSIZE+EIOMAPSIZE),
@


1.19
log
@Rework pmap_bootstrap() computations of I/O maps. Makes the MD part of
this much simpler.

Also, make sure an userland process can fill its UPT as expected.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.18 2003/06/02 23:27:45 millert Exp $	*/
d57 1
d64 1
a64 1
#define	MACHINE_EIOMAPSIZE	EIOMAPSIZE
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.17 2002/10/12 01:09:43 krw Exp $	*/
d82 5
a86 11
	RELOC(intiobase, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - \
	        (MACHINE_IIOMAPSIZE + MACHINE_EIOMAPSIZE)); \
	RELOC(intiolimit, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - MACHINE_EIOMAPSIZE); \
	RELOC(extiobase, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - MACHINE_EIOMAPSIZE); \
	RELOC(CLKbase, vaddr_t) = \
	    (vaddr_t)RELOC(intiobase, char *) + CLKBASE; \
	RELOC(MMUbase, vaddr_t) = \
	    (vaddr_t)RELOC(intiobase, char *) + MMUBASE; \
@


1.17
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.16 2002/02/23 04:58:25 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@Factorize most of the pmap_bootstrap() guts used by pmap_motorola users,
with a few hooks to cope with each architecture's specifics.

The new arch/m68k/m68k/pmap_bootstrap.c is not a standalone file, but will
be #included by the existing pmap_bootstrap.c code.

Tested on hp300 and mvme68k, mac68k coming soon. amiga will be left out
for now because it is a bit too different.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.15 2002/01/10 21:10:45 miod Exp $	*/
d132 1
a132 1
		panic("pmap_init: bogons in the VM system!\n");
@


1.15
log
@Switch m68k arches that do not exist in 68060 models back to pmap_motorola.
Others will be switched after more 060 tests.

This time: hp300
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.14 2001/12/20 19:02:27 miod Exp $	*/
a44 1
#include <sys/proc.h>
d46 1
d48 1
a48 2
#include <machine/cpu.h>
#include <machine/hp300spu.h>
a49 1
#include <machine/pte.h>
d51 1
a54 1
#include <uvm/uvm_pmap.h>
d56 1
a56 1
#define RELOC(v, t)	*((t*)((u_int)&(v) + firstpa))
a57 5
extern char *etext;
extern int Sysptsize;
extern char *extiobase, *proc0paddr;
extern st_entry_t *Sysseg;
extern pt_entry_t *Sysptmap, *Sysmap;
d59 2
d62 2
a63 20
extern int maxmem, physmem;
extern paddr_t avail_start, avail_end;
extern vaddr_t virtual_avail, virtual_end;
extern vsize_t mem_size;
#ifdef M68K_MMU_HP
extern int pmap_aliasmask;
#endif

void	pmap_bootstrap __P((paddr_t, paddr_t));

/*
 * Special purpose kernel virtual addresses, used for mapping
 * physical pages for a variety of temporary or permanent purposes:
 *
 *	CADDR1, CADDR2:	pmap zero/copy operations
 *	vmmap:		/dev/mem, crash dumps, parity error checking
 *	ledbase:	SPU LEDs
 *	msgbufp:	kernel message buffer
 */
caddr_t		CADDR1, CADDR2, vmmap, ledbase;
d65 3
a67 20
/*
 * Bootstrap the VM system.
 *
 * Called with MMU off so we must relocate all global references by `firstpa'
 * (don't call any functions here!)  `nextpa' is the first available physical
 * memory address.  Returns an updated first PA reflecting the memory we
 * have allocated.  MMU is still off when we return.
 *
 * XXX assumes sizeof(u_int) == sizeof(pt_entry_t)
 * XXX a PIC compiler would make this much easier.
 */
void
pmap_bootstrap(nextpa, firstpa)
	paddr_t nextpa;
	paddr_t firstpa;
{
	paddr_t kstpa, kptpa, iiopa, eiopa, kptmpa, lkptpa, p0upa;
	u_int nptpages, kstsize;
	st_entry_t protoste, *ste;
	pt_entry_t protopte, *pte, *epte;
d69 1
a69 46
	/*
	 * Calculate important physical addresses:
	 *
	 *	kstpa		kernel segment table	1 page (!040)
	 *						N pages (040)
	 *
	 *	kptpa		statically allocated
	 *			kernel PT pages		Sysptsize+ pages
	 *
	 *	iiopa		internal IO space
	 *			PT pages		IIOMAPSIZE pages
	 *
	 *	eiopa		external IO space
	 *			PT pages		EIOMAPSIZE pages
	 *
	 * [ Sysptsize is the number of pages of PT, IIOMAPSIZE and
	 *   EIOMAPSIZE are the number of PTEs, hence we need to round
	 *   the total to a page boundary with IO maps at the end. ]
	 *
	 *	kptmpa		kernel PT map		1 page
	 *
	 *	lkptpa		last kernel PT page	1 page
	 *
	 *	p0upa		proc 0 u-area		UPAGES pages
	 *
	 * The KVA corresponding to any of these PAs is:
	 *	(PA - firstpa + KERNBASE).
	 */
	if (RELOC(mmutype, int) == MMU_68040)
		kstsize = MAXKL2SIZE / (NPTEPG/SG4_LEV2SIZE);
	else
		kstsize = 1;
	kstpa = nextpa;
	nextpa += kstsize * NBPG;
	kptpa = nextpa;
	nptpages = RELOC(Sysptsize, int) +
		(IIOMAPSIZE + EIOMAPSIZE + NPTEPG - 1) / NPTEPG;
	nextpa += nptpages * NBPG;
	eiopa = nextpa - EIOMAPSIZE * sizeof(pt_entry_t);
	iiopa = eiopa - IIOMAPSIZE * sizeof(pt_entry_t);
	kptmpa = nextpa;
	nextpa += NBPG;
	lkptpa = nextpa;
	nextpa += NBPG;
	p0upa = nextpa;
	nextpa += USPACE;
d71 1
a71 30
	/*
	 * Initialize segment table and kernel page table map.
	 *
	 * On 68030s and earlier MMUs the two are identical except for
	 * the valid bits so both are initialized with essentially the
	 * same values.  On the 68040, which has a mandatory 3-level
	 * structure, the segment table holds the level 1 table and part
	 * (or all) of the level 2 table and hence is considerably
	 * different.  Here the first level consists of 128 descriptors
	 * (512 bytes) each mapping 32mb of address space.  Each of these
	 * points to blocks of 128 second level descriptors (512 bytes)
	 * each mapping 256kb.  Note that there may be additional "segment
	 * table" pages depending on how large MAXKL2SIZE is.
	 *
	 * Portions of the last segment of KVA space (0xFFF00000 -
	 * 0xFFFFFFFF) are mapped for a couple of purposes.  0xFFF00000
	 * for UPAGES is used for mapping the current process u-area
	 * (u + kernel stack).  The very last page (0xFFFFF000) is mapped
	 * to the last physical page of RAM to give us a region in which
	 * PA == VA.  We use the first part of this page for enabling
	 * and disabling mapping.  The last part of this page also contains
	 * info left by the boot ROM.
	 *
	 * XXX cramming two levels of mapping into the single "segment"
	 * table on the 68040 is intended as a temporary hack to get things
	 * working.  The 224mb of address space that this allows will most
	 * likely be insufficient in the future (at least for the kernel).
	 */
	if (RELOC(mmutype, int) == MMU_68040) {
		int num;
d73 1
a73 168
		/*
		 * First invalidate the entire "segment table" pages
		 * (levels 1 and 2 have the same "invalid" value).
		 */
		pte = (u_int *)kstpa;
		epte = &pte[kstsize * NPTEPG];
		while (pte < epte)
			*pte++ = SG_NV;
		/*
		 * Initialize level 2 descriptors (which immediately
		 * follow the level 1 table).  We need:
		 *	NPTEPG / SG4_LEV3SIZE
		 * level 2 descriptors to map each of the nptpages+1
		 * pages of PTEs.  Note that we set the "used" bit
		 * now to save the HW the expense of doing it.
		 */
		num = (nptpages + 1) * (NPTEPG / SG4_LEV3SIZE);
		pte = &((u_int *)kstpa)[SG4_LEV1SIZE];
		epte = &pte[num];
		protoste = kptpa | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV3SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize level 1 descriptors.  We need:
		 *	roundup(num, SG4_LEV2SIZE) / SG4_LEV2SIZE
		 * level 1 descriptors to map the `num' level 2's.
		 */
		pte = (u_int *)kstpa;
		epte = &pte[roundup(num, SG4_LEV2SIZE) / SG4_LEV2SIZE];
		protoste = (u_int)&pte[SG4_LEV1SIZE] | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV2SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize the final level 1 descriptor to map the last
		 * block of level 2 descriptors.
		 */
		ste = &((u_int *)kstpa)[SG4_LEV1SIZE-1];
		pte = &((u_int *)kstpa)[kstsize*NPTEPG - SG4_LEV2SIZE];
		*ste = (u_int)pte | SG_U | SG_RW | SG_V;
		/*
		 * Now initialize the final portion of that block of
		 * descriptors to map the "last PT page".
		 */
		pte = &((u_int *)kstpa)[kstsize*NPTEPG - NPTEPG/SG4_LEV3SIZE];
		epte = &pte[NPTEPG/SG4_LEV3SIZE];
		protoste = lkptpa | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV3SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize Sysptmap
		 */
		pte = (u_int *)kptmpa;
		epte = &pte[nptpages+1];
		protopte = kptpa | PG_RW | PG_CI | PG_V;
		while (pte < epte) {
			*pte++ = protopte;
			protopte += NBPG;
		}
		/*
		 * Invalidate all but the last remaining entry.
		 */
		epte = &((u_int *)kptmpa)[NPTEPG-1];
		while (pte < epte) {
			*pte++ = PG_NV;
		}
		/*
		 * Initialize the last to point to the page
		 * table page allocated earlier.
		 */
		*pte = lkptpa | PG_RW | PG_CI | PG_V;
	} else {
		/*
		 * Map the page table pages in both the HW segment table
		 * and the software Sysptmap.  Note that Sysptmap is also
		 * considered a PT page hence the +1.
		 */
		ste = (u_int *)kstpa;
		pte = (u_int *)kptmpa;
		epte = &pte[nptpages+1];
		protoste = kptpa | SG_RW | SG_V;
		protopte = kptpa | PG_RW | PG_CI | PG_V;
		while (pte < epte) {
			*ste++ = protoste;
			*pte++ = protopte;
			protoste += NBPG;
			protopte += NBPG;
		}
		/*
		 * Invalidate all but the last remaining entries in both.
		 */
		epte = &((u_int *)kptmpa)[NPTEPG-1];
		while (pte < epte) {
			*ste++ = SG_NV;
			*pte++ = PG_NV;
		}
		/*
		 * Initialize the last to point to point to the page
		 * table page allocated earlier.
		 */
		*ste = lkptpa | SG_RW | SG_V;
		*pte = lkptpa | PG_RW | PG_CI | PG_V;
	}
	/*
	 * Invalidate all but the final entry in the last kernel PT page
	 * (u-area PTEs will be validated later).  The final entry maps
	 * the last page of physical memory.
	 */
	pte = (u_int *)lkptpa;
	epte = &pte[NPTEPG-1];
	while (pte < epte)
		*pte++ = PG_NV;
	*pte = MAXADDR | PG_RW | PG_CI | PG_V;
	/*
	 * Initialize kernel page table.
	 * Start by invalidating the `nptpages' that we have allocated.
	 */
	pte = (u_int *)kptpa;
	epte = &pte[nptpages * NPTEPG];
	while (pte < epte)
		*pte++ = PG_NV;

	/*
	 * Validate PTEs for kernel text (RO).  The first page
	 * of kernel text remains invalid; see locore.s
	 */
	pte = &((u_int *)kptpa)[m68k_btop(KERNBASE + NBPG)];
	epte = &pte[m68k_btop(trunc_page((vaddr_t)&etext))];
	protopte = (firstpa + NBPG) | PG_RO | PG_V;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}
	/*
	 * Validate PTEs for kernel data/bss, dynamic data allocated
	 * by us so far (nextpa - firstpa bytes), and pages for proc0
	 * u-area and page table allocated below (RW).
	 */
	epte = &((u_int *)kptpa)[m68k_btop(nextpa - firstpa)];
	protopte = (protopte & ~PG_PROT) | PG_RW;
	/*
	 * Enable copy-back caching of data pages
	 */
	if (RELOC(mmutype, int) == MMU_68040)
		protopte |= PG_CCB;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}
	/*
	 * Finally, validate the internal IO space PTEs (RW+CI).
	 * We do this here since the 320/350 MMU registers (also
	 * used, but to a lesser extent, on other models) are mapped
	 * in this range and it would be nice to be able to access
	 * them after the MMU is turned on.
	 */
	pte = (u_int *)iiopa;
	epte = (u_int *)eiopa;
	protopte = INTIOBASE | PG_RW | PG_CI | PG_V;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}
a75 19
	 * Calculate important exported kernel virtual addresses
	 */
	/*
	 * Sysseg: base of kernel segment table
	 */
	RELOC(Sysseg, st_entry_t *) =
		(st_entry_t *)(kstpa - firstpa);
	/*
	 * Sysptmap: base of kernel page table map
	 */
	RELOC(Sysptmap, pt_entry_t *) =
		(pt_entry_t *)(kptmpa - firstpa);
	/*
	 * Sysmap: kernel page table (as mapped through Sysptmap)
	 * Immediately follows `nptpages' of static kernel page table.
	 */
	RELOC(Sysmap, pt_entry_t *) =
		(pt_entry_t *)m68k_ptob(nptpages * NPTEPG);
	/*
d77 2
a78 8
	 * IIOMAPSIZE pages prior to external IO space at end of static
	 * kernel page table.
	 */
	RELOC(intiobase, char *) =
		(char *)m68k_ptob(nptpages*NPTEPG - (IIOMAPSIZE+EIOMAPSIZE));
	RELOC(intiolimit, char *) =
		(char *)m68k_ptob(nptpages*NPTEPG - EIOMAPSIZE);
	/*
d80 1
a80 5
	 * EIOMAPSIZE pages at the end of the static kernel page table.
	 */
	RELOC(extiobase, char *) =
		(char *)m68k_ptob(nptpages*NPTEPG - EIOMAPSIZE);
	/*
d82 1
a82 9
	 * accessed from assembly language.
	 */
	RELOC(CLKbase, vaddr_t) =
		(vaddr_t)RELOC(intiobase, char *) + CLKBASE;
	RELOC(MMUbase, vaddr_t) =
		(vaddr_t)RELOC(intiobase, char *) + MMUBASE;

	/*
	 * Setup u-area for process 0.
d84 20
a103 81
	/*
	 * Zero the u-area.
	 * NOTE: `pte' and `epte' aren't PTEs here.
	 */
	pte = (u_int *)p0upa;
	epte = (u_int *)(p0upa + USPACE);
	while (pte < epte)
		*pte++ = 0;
	/*
	 * Remember the u-area address so it can be loaded in the
	 * proc struct p_addr field later.
	 */
	RELOC(proc0paddr, char *) = (char *)(p0upa - firstpa);

	/*
	 * VM data structures are now initialized, set up data for
	 * the pmap module.
	 *
	 * Note about avail_end: msgbuf is initialized just after
	 * avail_end in machdep.c.  Since the last page is used
	 * for rebooting the system (code is copied there and
	 * excution continues from copied code before the MMU
	 * is disabled), the msgbuf will get trounced between
	 * reboots if it's placed in the last physical page.
	 * To work around this, we move avail_end back one more
	 * page so the msgbuf can be preserved.
	 */
	RELOC(avail_start, paddr_t) = nextpa;
	RELOC(avail_end, paddr_t) = m68k_ptob(RELOC(maxmem, int)) -
	    (round_page(MSGBUFSIZE) + m68k_ptob(1));
	RELOC(mem_size, vsize_t) = m68k_ptob(RELOC(physmem, int));
	RELOC(virtual_avail, vaddr_t) =
		VM_MIN_KERNEL_ADDRESS + (nextpa - firstpa);
	RELOC(virtual_end, vaddr_t) = VM_MAX_KERNEL_ADDRESS;

#ifdef M68K_MMU_HP
	/*
	 * Determine VA aliasing distance if any
	 */
	if (RELOC(ectype, int) == EC_VIRT) {
		if (RELOC(machineid, int) == HP_320)
			RELOC(pmap_aliasmask, int) = 0x3fff;	/* 16k */
		else if (RELOC(machineid, int) == HP_350)
			RELOC(pmap_aliasmask, int) = 0x7fff;	/* 32k */
	}
#endif

	/*
	 * Kernel page/segment table allocated in locore,
	 * just initialize pointers.
	 */
	{
		struct pmap *kpm = &RELOC(kernel_pmap_store, struct pmap);

		kpm->pm_stab = RELOC(Sysseg, st_entry_t *);
		kpm->pm_ptab = RELOC(Sysmap, pt_entry_t *);
		simple_lock_init(&kpm->pm_lock);
		kpm->pm_count = 1;
		kpm->pm_stpa = (st_entry_t *)kstpa;
		/*
		 * For the 040 we also initialize the free level 2
		 * descriptor mask noting that we have used:
		 *	0:		level 1 table
		 *	1 to `num':	map page tables
		 *	MAXKL2SIZE-1:	maps last-page page table
		 */
		if (RELOC(mmutype, int) == MMU_68040) {
			int num;
			
			kpm->pm_stfree = ~l2tobm(0);
			num = roundup((nptpages + 1) * (NPTEPG / SG4_LEV3SIZE),
				      SG4_LEV2SIZE) / SG4_LEV2SIZE;
			while (num)
				kpm->pm_stfree &= ~l2tobm(num--);
			kpm->pm_stfree &= ~l2tobm(MAXKL2SIZE-1);
			for (num = MAXKL2SIZE;
			     num < sizeof(kpm->pm_stfree)*NBBY;
			     num++)
				kpm->pm_stfree &= ~l2tobm(num);
		}
	}
d108 5
a112 2
	{
		vaddr_t va = RELOC(virtual_avail, vaddr_t);
d114 1
a114 13
		RELOC(CADDR1, caddr_t) = (caddr_t)va;
		va += NBPG;
		RELOC(CADDR2, caddr_t) = (caddr_t)va;
		va += NBPG;
		RELOC(vmmap, caddr_t) = (caddr_t)va;
		va += NBPG;
		RELOC(ledbase, caddr_t) = (caddr_t)va;
		va += NBPG;
		RELOC(msgbufp, struct msgbuf *) = (struct msgbuf *)va;
		va += MSGBUFSIZE;
		RELOC(virtual_avail, vaddr_t) = va;
	}
}
@


1.14
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.13 2001/12/14 21:44:04 miod Exp $	*/
a70 1
extern int protection_codes[];
a449 19
	 * Initialize protection array.
	 * XXX don't use a switch statement, it might produce an
	 * absolute "jmp" table.
	 */
	{
		int *kp;

		kp = &RELOC(protection_codes, int);
		kp[VM_PROT_NONE|VM_PROT_NONE|VM_PROT_NONE] = 0;
		kp[VM_PROT_READ|VM_PROT_NONE|VM_PROT_NONE] = PG_RO;
		kp[VM_PROT_READ|VM_PROT_NONE|VM_PROT_EXECUTE] = PG_RO;
		kp[VM_PROT_NONE|VM_PROT_NONE|VM_PROT_EXECUTE] = PG_RO;
		kp[VM_PROT_NONE|VM_PROT_WRITE|VM_PROT_NONE] = PG_RW;
		kp[VM_PROT_NONE|VM_PROT_WRITE|VM_PROT_EXECUTE] = PG_RW;
		kp[VM_PROT_READ|VM_PROT_WRITE|VM_PROT_NONE] = PG_RW;
		kp[VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE] = PG_RW;
	}

	/*
d502 19
@


1.13
log
@Remove the ugly protection_codes[] array, only used by the pte_prot()
macro, by a different version of the aforementioned macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.12 2001/11/30 20:58:18 miod Exp $	*/
d71 1
d451 19
a521 19
}

void
pmap_init_md()
{
	vaddr_t		addr;

	/*
	 * mark as unavailable the regions which we have mapped in
	 * pmap_bootstrap().
	 */
	addr = (vaddr_t) intiobase;
	if (uvm_map(kernel_map, &addr,
		    m68k_ptob(IIOMAPSIZE+EIOMAPSIZE),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
				UVM_INH_NONE, UVM_ADV_RANDOM,
				UVM_FLAG_FIXED)))
		panic("pmap_init: bogons in the VM system!\n");
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.15 2002/01/10 21:10:45 miod Exp $	*/
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.13.2.1 2002/01/31 22:55:08 niklas Exp $	*/
d45 1
d47 1
d49 2
a50 1
#include <machine/frame.h>
a51 1
#include <machine/vmparam.h>
a52 1
#include <machine/hp300spu.h>
d56 1
d58 1
a58 1
caddr_t ledbase;	/* SPU LEDs mapping */
d60 5
a65 2
extern char *extiobase;
extern int maxmem;
d67 20
a86 2
#define	RELOC(v, t)	*((t*)((u_int)&(v) + firstpa))
#define	PA2VA(v, t)	*((t*)((u_int)&(v)))
d88 20
a107 3
#define	MACHINE_IIOMAPSIZE	IIOMAPSIZE
#define	MACHINE_INTIOBASE	INTIOBASE
#define	MACHINE_EIOMAPSIZE	EIOMAPSIZE
d109 46
a154 1
#define	PMAP_MD_LOCALS		/* nothing */
d156 30
a185 1
#define	PMAP_MD_RELOC1()	/* nothing */
d187 168
a354 1
#define PMAP_MD_MAPIOSPACE()	/* nothing */
d357 19
d377 8
a384 2
	 * MACHINE_IIOMAPSIZE pages prior to external IO space at end of
	 * static kernel page table.
d386 5
a390 1
	 * MACHINE_EIOMAPSIZE pages at the end of the static kernel page table.
d392 9
a400 1
	 * accessed from locore.
d402 81
a482 20
#define	PMAP_MD_RELOC2() \
do { \
	RELOC(intiobase, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - \
	        (MACHINE_IIOMAPSIZE + MACHINE_EIOMAPSIZE)); \
	RELOC(intiolimit, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - MACHINE_EIOMAPSIZE); \
	RELOC(extiobase, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - MACHINE_EIOMAPSIZE); \
	RELOC(CLKbase, vaddr_t) = \
	    (vaddr_t)RELOC(intiobase, char *) + CLKBASE; \
	RELOC(MMUbase, vaddr_t) = \
	    (vaddr_t)RELOC(intiobase, char *) + MMUBASE; \
} while (0)

#define	PMAP_MD_MEMSIZE() \
do { \
	RELOC(avail_end, paddr_t) = m68k_ptob(RELOC(maxmem, int)) - \
	    (round_page(MSGBUFSIZE) + m68k_ptob(1)); \
} while (0)
d487 2
a488 5
#define	PMAP_MD_RELOC3() \
do { \
		RELOC(ledbase, caddr_t) = (caddr_t)va; \
		va += NBPG; \
} while (0)
d490 13
a502 1
#include <m68k/m68k/pmap_bootstrap.c>
@


1.13.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.13.2.2 2002/06/11 03:35:20 art Exp $	*/
d132 1
a132 1
		panic("pmap_init: bogons in the VM system!");
@


1.12
log
@Switch to pmap_motorola.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.11 2001/11/06 19:53:14 miod Exp $	*/
a70 1
extern int protection_codes[];
a447 19

	/*
	 * Initialize protection array.
	 * XXX don't use a switch statement, it might produce an
	 * absolute "jmp" table.
	 */
	{
		int *kp;

		kp = &RELOC(protection_codes, int);
		kp[VM_PROT_NONE|VM_PROT_NONE|VM_PROT_NONE] = 0;
		kp[VM_PROT_READ|VM_PROT_NONE|VM_PROT_NONE] = PG_RO;
		kp[VM_PROT_READ|VM_PROT_NONE|VM_PROT_EXECUTE] = PG_RO;
		kp[VM_PROT_NONE|VM_PROT_NONE|VM_PROT_EXECUTE] = PG_RO;
		kp[VM_PROT_NONE|VM_PROT_WRITE|VM_PROT_NONE] = PG_RW;
		kp[VM_PROT_NONE|VM_PROT_WRITE|VM_PROT_EXECUTE] = PG_RW;
		kp[VM_PROT_READ|VM_PROT_WRITE|VM_PROT_NONE] = PG_RW;
		kp[VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE] = PG_RW;
	}
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.10 2001/09/19 21:32:57 miod Exp $	*/
d522 19
@


1.10
log
@Get rid of unused pagezero variable. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.9 2001/06/05 16:13:16 millert Exp $	*/
d55 2
a56 2
#include <vm/vm.h>
#include <vm/pmap.h>
@


1.9
log
@Use mi round_page() and trunc_page() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.8 2001/05/11 23:24:57 millert Exp $	*/
a65 1
extern paddr_t pagezero;
a313 8

	/*
	 * Save the physical address of `page zero'.  This is
	 * a page of memory at the beginning of kernel text
	 * not mapped at VA 0.  But, we might want to use it
	 * for something later.
	 */
	RELOC(pagezero, paddr_t) = firstpa;
@


1.8
log
@Kill remaining vm_offset_t and vm_size_t; NetBSD used as a guide
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.7 2000/02/22 19:27:46 deraadt Exp $	*/
d329 1
a329 1
	epte = &pte[m68k_btop(m68k_trunc_page(&etext))];
d441 1
a441 1
	    (m68k_round_page(MSGBUFSIZE) + m68k_ptob(1));
@


1.7
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.6 1998/03/07 12:41:33 deraadt Exp $	*/
d65 2
a66 2
extern vm_offset_t CLKbase, MMUbase;
extern vm_offset_t pagezero;
d69 3
a71 2
extern vm_offset_t avail_start, avail_end, virtual_avail, virtual_end;
extern vm_size_t mem_size;
d77 1
a77 1
void	pmap_bootstrap __P((vm_offset_t, vm_offset_t));
d103 2
a104 2
	vm_offset_t nextpa;
	vm_offset_t firstpa;
d106 1
a106 1
	vm_offset_t kstpa, kptpa, iiopa, eiopa, kptmpa, lkptpa, p0upa;
d322 1
a322 1
	RELOC(pagezero, vm_offset_t) = firstpa;
d404 4
a407 4
	RELOC(CLKbase, vm_offset_t) =
		(vm_offset_t)RELOC(intiobase, char *) + CLKBASE;
	RELOC(MMUbase, vm_offset_t) =
		(vm_offset_t)RELOC(intiobase, char *) + MMUBASE;
d439 2
a440 2
	RELOC(avail_start, vm_offset_t) = nextpa;
	RELOC(avail_end, vm_offset_t) = m68k_ptob(RELOC(maxmem, int)) -
d442 2
a443 2
	RELOC(mem_size, vm_size_t) = m68k_ptob(RELOC(physmem, int));
	RELOC(virtual_avail, vm_offset_t) =
d445 1
a445 1
	RELOC(virtual_end, vm_offset_t) = VM_MAX_KERNEL_ADDRESS;
d517 1
a517 1
		vm_offset_t va = RELOC(virtual_avail, vm_offset_t);
d529 1
a529 1
		RELOC(virtual_avail, vm_offset_t) = va;
@


1.6
log
@please the anal compiler
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.5 1997/07/06 08:02:08 downsj Exp $	*/
a87 1
struct msgbuf	*msgbufp;
d440 1
a440 1
	    (m68k_round_page(sizeof(struct msgbuf)) + m68k_ptob(1));
d527 1
a527 1
		va += NBPG;
@


1.6.10.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
d441 1
a441 1
	    (m68k_round_page(MSGBUFSIZE) + m68k_ptob(1));
d528 1
a528 1
		va += MSGBUFSIZE;
@


1.6.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.6.10.1 2000/03/02 07:04:27 niklas Exp $	*/
d65 2
a66 2
extern vaddr_t CLKbase, MMUbase;
extern paddr_t pagezero;
d69 2
a70 3
extern paddr_t avail_start, avail_end;
extern vaddr_t virtual_avail, virtual_end;
extern vsize_t mem_size;
d76 1
a76 1
void	pmap_bootstrap __P((paddr_t, paddr_t));
d102 2
a103 2
	paddr_t nextpa;
	paddr_t firstpa;
d105 1
a105 1
	paddr_t kstpa, kptpa, iiopa, eiopa, kptmpa, lkptpa, p0upa;
d321 1
a321 1
	RELOC(pagezero, paddr_t) = firstpa;
d328 1
a328 1
	epte = &pte[m68k_btop(trunc_page((vaddr_t)&etext))];
d403 4
a406 4
	RELOC(CLKbase, vaddr_t) =
		(vaddr_t)RELOC(intiobase, char *) + CLKBASE;
	RELOC(MMUbase, vaddr_t) =
		(vaddr_t)RELOC(intiobase, char *) + MMUBASE;
d438 5
a442 5
	RELOC(avail_start, paddr_t) = nextpa;
	RELOC(avail_end, paddr_t) = m68k_ptob(RELOC(maxmem, int)) -
	    (round_page(MSGBUFSIZE) + m68k_ptob(1));
	RELOC(mem_size, vsize_t) = m68k_ptob(RELOC(physmem, int));
	RELOC(virtual_avail, vaddr_t) =
d444 1
a444 1
	RELOC(virtual_end, vaddr_t) = VM_MAX_KERNEL_ADDRESS;
d516 1
a516 1
		vaddr_t va = RELOC(virtual_avail, vaddr_t);
d528 1
a528 1
		RELOC(virtual_avail, vaddr_t) = va;
@


1.6.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.6.10.2 2001/07/04 10:15:48 niklas Exp $	*/
d66 1
d315 8
@


1.6.10.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 2
a56 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>
@


1.6.10.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.6.10.4 2001/11/13 21:00:51 niklas Exp $	*/
a521 19
}

void
pmap_init_md()
{
	vaddr_t		addr;

	/*
	 * mark as unavailable the regions which we have mapped in
	 * pmap_bootstrap().
	 */
	addr = (vaddr_t) intiobase;
	if (uvm_map(kernel_map, &addr,
		    m68k_ptob(IIOMAPSIZE+EIOMAPSIZE),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
				UVM_INH_NONE, UVM_ADV_RANDOM,
				UVM_FLAG_FIXED)))
		panic("pmap_init: bogons in the VM system!\n");
@


1.6.10.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
d47 1
d49 2
a50 1
#include <machine/frame.h>
a51 1
#include <machine/vmparam.h>
a52 1
#include <machine/hp300spu.h>
d56 1
d58 1
a58 1
caddr_t ledbase;	/* SPU LEDs mapping */
d60 5
a65 2
extern char *extiobase;
extern int maxmem;
d67 21
a87 2
#define	RELOC(v, t)	*((t*)((u_int)&(v) + firstpa))
#define	PA2VA(v, t)	*((t*)((u_int)&(v)))
d89 20
a108 3
#define	MACHINE_IIOMAPSIZE	IIOMAPSIZE
#define	MACHINE_INTIOBASE	INTIOBASE
#define	MACHINE_EIOMAPSIZE	EIOMAPSIZE
d110 46
a155 1
#define	PMAP_MD_LOCALS		/* nothing */
d157 30
a186 1
#define	PMAP_MD_RELOC1()	/* nothing */
d188 126
a313 1
#define PMAP_MD_MAPIOSPACE()	/* nothing */
d316 61
d378 8
a385 2
	 * MACHINE_IIOMAPSIZE pages prior to external IO space at end of
	 * static kernel page table.
d387 5
a391 1
	 * MACHINE_EIOMAPSIZE pages at the end of the static kernel page table.
d393 36
a428 1
	 * accessed from locore.
d430 73
a502 20
#define	PMAP_MD_RELOC2() \
do { \
	RELOC(intiobase, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - \
	        (MACHINE_IIOMAPSIZE + MACHINE_EIOMAPSIZE)); \
	RELOC(intiolimit, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - MACHINE_EIOMAPSIZE); \
	RELOC(extiobase, char *) = \
	    (char *)m68k_ptob(nptpages * NPTEPG - MACHINE_EIOMAPSIZE); \
	RELOC(CLKbase, vaddr_t) = \
	    (vaddr_t)RELOC(intiobase, char *) + CLKBASE; \
	RELOC(MMUbase, vaddr_t) = \
	    (vaddr_t)RELOC(intiobase, char *) + MMUBASE; \
} while (0)

#define	PMAP_MD_MEMSIZE() \
do { \
	RELOC(avail_end, paddr_t) = m68k_ptob(RELOC(maxmem, int)) - \
	    (round_page(MSGBUFSIZE) + m68k_ptob(1)); \
} while (0)
d507 2
a508 5
#define	PMAP_MD_RELOC3() \
do { \
		RELOC(ledbase, caddr_t) = (caddr_t)va; \
		va += NBPG; \
} while (0)
d510 13
a522 1
#include <m68k/m68k/pmap_bootstrap.c>
@


1.6.10.7
log
@Sync the SMP branch with 3.3
@
text
@d132 1
a132 1
		panic("pmap_init: bogons in the VM system!");
@


1.6.10.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.6.10.7 2003/03/27 23:19:21 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.4 1997/04/16 11:56:31 downsj Exp $	*/
d451 1
a451 1
	if (RELOC(ectype, int) == EC_VIRT)
d456 1
@


1.4
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: pmap_bootstrap.c,v 1.3 1997/01/12 15:13:26 downsj Exp $	*/
/*	$NetBSD: pmap_bootstrap.c,v 1.11 1997/04/01 03:12:29 scottr Exp $	*/
d49 1
d328 2
a329 2
	pte = &((u_int *)kptpa)[hp300_btop(KERNBASE + NBPG)];
	epte = &pte[hp300_btop(hp300_trunc_page(&etext))];
d340 1
a340 1
	epte = &((u_int *)kptpa)[hp300_btop(nextpa - firstpa)];
d384 1
a384 1
		(pt_entry_t *)hp300_ptob(nptpages * NPTEPG);
d391 1
a391 1
		(char *)hp300_ptob(nptpages*NPTEPG - (IIOMAPSIZE+EIOMAPSIZE));
d393 1
a393 1
		(char *)hp300_ptob(nptpages*NPTEPG - EIOMAPSIZE);
d399 1
a399 1
		(char *)hp300_ptob(nptpages*NPTEPG - EIOMAPSIZE);
d440 3
a442 3
	RELOC(avail_end, vm_offset_t) = hp300_ptob(RELOC(maxmem, int)) -
	    (hp300_round_page(sizeof(struct msgbuf)) + hp300_ptob(1));
	RELOC(mem_size, vm_size_t) = hp300_ptob(RELOC(physmem, int));
@


1.3
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pmap_bootstrap.c,v 1.10 1996/10/14 08:05:37 thorpej Exp $	*/
d45 5
d51 1
a52 2
#include <machine/vmparam.h>
#include <machine/cpu.h>
d55 1
d75 2
d103 1
a103 1
	register vm_offset_t firstpa;
d107 2
a108 2
	register st_entry_t protoste, *ste;
	register pt_entry_t protopte, *pte, *epte;
d186 1
a186 1
		register int num;
d463 1
a463 1
		register int *kp;
d496 1
a496 1
			register int num;
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 2
a2 1
/*	$NetBSD: pmap_bootstrap.c,v 1.9 1995/12/11 17:09:16 thorpej Exp $	*/
d60 1
d252 2
a253 2
                /*
		 * Initialize the last to point to point to the page
d307 1
d309 4
a312 1
	 * Validate PTEs for kernel text (RO)
d314 7
a320 1
	pte = &((u_int *)kptpa)[hp300_btop(KERNBASE)];
d322 1
a322 5
#if defined(KGDB) || defined(DDB)
	protopte = firstpa | PG_RW | PG_V;	/* XXX RW for now */
#else
	protopte = firstpa | PG_RO | PG_V;
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pmap_bootstrap.c,v 1.7 1995/10/05 06:54:12 thorpej Exp $	*/
d64 1
a64 1
#ifdef HAVEVAC
d413 9
d424 2
a425 4
	RELOC(avail_end, vm_offset_t) =
		hp300_ptob(RELOC(maxmem, int))
			/* XXX allow for msgbuf */
			- hp300_round_page(sizeof(struct msgbuf));
d431 1
a431 1
#ifdef HAVEVAC
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

