head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.10
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.8;

1.8
date	2013.02.02.13.34.29;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.06.20.11.01;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.24.13.20.17;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.15.18.52.44;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.23.16.55.17;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.22.39.27;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: bus_space.c,v 1.8 2013/02/02 13:34:29 miod Exp $	*/
/*	$NetBSD: bus_space.c,v 1.6 2002/09/27 15:36:02 provos Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Implementation of bus_space mapping for the hp300.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/extent.h>

#include <machine/autoconf.h>
#include <machine/bus.h>

#include <uvm/uvm_extern.h>

#ifdef DIAGNOSTIC
extern char *extiobase;
#endif
extern struct extent *extio;

/*
 * Memory mapped devices (intio, dio and sgc)
 */

int	hp300_mem_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	hp300_mem_unmap(bus_space_handle_t, bus_size_t);
int	hp300_mem_subregion(bus_space_handle_t, bus_size_t, bus_size_t,
	    bus_space_handle_t *);
void *	hp300_mem_vaddr(bus_space_handle_t);

u_int8_t hp300_mem_bsr1(bus_space_handle_t, bus_size_t);
u_int16_t hp300_mem_bsr2(bus_space_handle_t, bus_size_t);
u_int32_t hp300_mem_bsr4(bus_space_handle_t, bus_size_t);
void	hp300_mem_bsrm1(bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
void	hp300_mem_bsrm2(bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
void	hp300_mem_bsrm4(bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
void	hp300_mem_bsrrm2(bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
void	hp300_mem_bsrrm4(bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
void	hp300_mem_bsrr1(bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
void	hp300_mem_bsrr2(bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
void	hp300_mem_bsrr4(bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
void	hp300_mem_bsrrr2(bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
void	hp300_mem_bsrrr4(bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
void	hp300_mem_bsw1(bus_space_handle_t, bus_size_t, u_int8_t);
void	hp300_mem_bsw2(bus_space_handle_t, bus_size_t, u_int16_t);
void	hp300_mem_bsw4(bus_space_handle_t, bus_size_t, u_int32_t);
void	hp300_mem_bswm1(bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
void	hp300_mem_bswm2(bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
void	hp300_mem_bswm4(bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
void	hp300_mem_bswrm2(bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
void	hp300_mem_bswrm4(bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
void	hp300_mem_bswr1(bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
void	hp300_mem_bswr2(bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
void	hp300_mem_bswr4(bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
void	hp300_mem_bswrr2(bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
void	hp300_mem_bswrr4(bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
void	hp300_mem_bssm1(bus_space_handle_t, bus_size_t, u_int8_t, size_t);
void	hp300_mem_bssm2(bus_space_handle_t, bus_size_t, u_int16_t, size_t);
void	hp300_mem_bssm4(bus_space_handle_t, bus_size_t, u_int32_t, size_t);
void	hp300_mem_bssr1(bus_space_handle_t, bus_size_t, u_int8_t, size_t);
void	hp300_mem_bssr2(bus_space_handle_t, bus_size_t, u_int16_t, size_t);
void	hp300_mem_bssr4(bus_space_handle_t, bus_size_t, u_int32_t, size_t);

struct hp300_bus_space_tag hp300_mem_tag = {
	hp300_mem_map,
	hp300_mem_unmap,
	hp300_mem_subregion,
	hp300_mem_vaddr,

	hp300_mem_bsr1,
	hp300_mem_bsr2,
	hp300_mem_bsr4,
	hp300_mem_bsrm1,
	hp300_mem_bsrm2,
	hp300_mem_bsrm4,
	hp300_mem_bsrrm2,
	hp300_mem_bsrrm4,
	hp300_mem_bsrr1,
	hp300_mem_bsrr2,
	hp300_mem_bsrr4,
	hp300_mem_bsrrr2,
	hp300_mem_bsrrr4,
	hp300_mem_bsw1,
	hp300_mem_bsw2,
	hp300_mem_bsw4,
	hp300_mem_bswm1,
	hp300_mem_bswm2,
	hp300_mem_bswm4,
	hp300_mem_bswrm2,
	hp300_mem_bswrm4,
	hp300_mem_bswr1,
	hp300_mem_bswr2,
	hp300_mem_bswr4,
	hp300_mem_bswrr2,
	hp300_mem_bswrr4,
	hp300_mem_bssm1,
	hp300_mem_bssm2,
	hp300_mem_bssm4,
	hp300_mem_bssr1,
	hp300_mem_bssr2,
	hp300_mem_bssr4
};

int
hp300_mem_map(bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	u_long kva;
	pt_entry_t template;
	int error;

	/*
	 * intio space is direct-mapped in pmap_bootstrap(); just do the
	 * translation in this case.
	 */
	if (bpa >= INTIOBASE && bpa < INTIOTOP) {
		*bshp = IIOV(bpa);
		return (0);
	}

	/*
	 * Allocate virtual address space from the extio extent map.
	 */
	size = round_page(bpa + size) - trunc_page(bpa);
	error = extent_alloc(extio, size, PAGE_SIZE, 0, EX_NOBOUNDARY,
	    EX_NOWAIT | EX_MALLOCOK, &kva);
	if (error)
		return (error);

	*bshp = (bus_space_handle_t)kva + (bpa & PAGE_MASK);
	bpa = trunc_page(bpa);

	/*
	 * Map the range.
	 */
	if (flags & BUS_SPACE_MAP_CACHEABLE)
		template = PG_RW;
	else
		template = PG_RW | PG_CI;
	while (size != 0) {
		pmap_kenter_cache(kva, bpa, template);
		size -= PAGE_SIZE;
		kva += PAGE_SIZE;
		bpa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());

	/*
	 * All done.
	 */
	return (0);
}

void
hp300_mem_unmap(bus_space_handle_t bsh, bus_size_t size)
{
#ifdef DIAGNOSTIC
	extern int eiomapsize;
#endif
	int error;

	/*
	 * intio space is direct-mapped in pmap_bootstrap(); nothing
	 * to do.
	 */
	if (IIOP(bsh) >= INTIOBASE && IIOP(bsh) < INTIOTOP)
		return;

#ifdef DIAGNOSTIC
	if ((caddr_t)bsh < extiobase ||
	    (caddr_t)bsh >= extiobase + ptoa(eiomapsize)) {
		printf("bus_space_unmap: bad bus space handle %x\n", bsh);
		return;
	}
#endif

	size = round_page(bsh + size) - trunc_page(bsh);
	bsh = trunc_page(bsh);

	/*
	 * Unmap the range.
	 */
	pmap_kremove(bsh, size);
	pmap_update(pmap_kernel());

	/*
	 * Free it from the extio extent map.
	 */
	error = extent_free(extio, (u_long)bsh, size, EX_NOWAIT | EX_MALLOCOK);
#ifdef DIAGNOSTIC
	if (error != 0) {
		printf("bus_space_unmap: kva 0x%lx size 0x%lx: "
		    "can't free region (%d)\n", (vaddr_t)bsh, size, error);
	}
#endif
}

/* ARGSUSED */
int
hp300_mem_subregion(bus_space_handle_t bsh, bus_size_t offset, bus_size_t size,
    bus_space_handle_t *nbshp)
{
	*nbshp = bsh + offset;
	return (0);
}

#if 0
/* ARGSUSED */
paddr_t
hp300_mem_mmap(bus_addr_t addr, off_t offset, int prot, int flags)
{
	return (((paddr_t)addr + offset) >> PAGE_SHIFT);
}
#endif

void *
hp300_mem_vaddr(bus_space_handle_t h)
{
	return ((void *)h);
}

u_int8_t
hp300_mem_bsr1(bus_space_handle_t bsh, bus_size_t offset)
{
	return (*(volatile u_int8_t *) (bsh + offset));
}

u_int16_t
hp300_mem_bsr2(bus_space_handle_t bsh, bus_size_t offset)
{
	return (*(volatile u_int16_t *) (bsh + offset));
}

u_int32_t
hp300_mem_bsr4(bus_space_handle_t bsh, bus_size_t offset)
{
	return (*(volatile u_int32_t *) (bsh + offset));
}

void
hp300_mem_bsrm1(bus_space_handle_t h, bus_size_t offset,
	     u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movb	%%a0@@,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrm2(bus_space_handle_t h, bus_size_t offset,
	     u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%a0@@,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrm4(bus_space_handle_t h, bus_size_t offset,
	     u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%a0@@,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrrm2(bus_space_handle_t h, bus_size_t offset,
	     u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%a0@@,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrrm4(bus_space_handle_t h, bus_size_t offset,
	     u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%a0@@,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrr1(bus_space_handle_t h, bus_size_t offset,
	     u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movb	%%a0@@+,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrr2(bus_space_handle_t h, bus_size_t offset,
	     u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%a0@@+,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrr4(bus_space_handle_t h, bus_size_t offset,
	     u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%a0@@+,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrrr2(bus_space_handle_t h, bus_size_t offset,
	     u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%a0@@+,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c / 2)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsrrr4(bus_space_handle_t h, bus_size_t offset,
	     u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%a0@@+,%%a1@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c / 4)	:
		    "a0","a1","d0");
}

void
hp300_mem_bsw1(bus_space_handle_t h, bus_size_t offset,
	    u_int8_t v)
{
	(*(volatile u_int8_t *)(h + offset)) = v;
}

void
hp300_mem_bsw2(bus_space_handle_t h, bus_size_t offset,
	    u_int16_t v)
{
	(*(volatile u_int16_t *)(h + offset)) = v;
}

void
hp300_mem_bsw4(bus_space_handle_t h, bus_size_t offset,
	    u_int32_t v)
{
	(*(volatile u_int32_t *)(h + offset)) = v;
}

void
hp300_mem_bswm1(bus_space_handle_t h, bus_size_t offset,
	     const u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movb	%%a1@@+,%%a0@@	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswm2(bus_space_handle_t h, bus_size_t offset,
	     const u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%a1@@+,%%a0@@	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswm4(bus_space_handle_t h, bus_size_t offset,
	     const u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%a1@@+,%%a0@@	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswrm2(bus_space_handle_t h, bus_size_t offset,
	     const u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%a1@@+,%%a0@@	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswrm4(bus_space_handle_t h, bus_size_t offset,
	     const u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%a1@@+,%%a0@@	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswr1(bus_space_handle_t h, bus_size_t offset,
	     const u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movb	%%a1@@+,%%a0@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswr2(bus_space_handle_t h, bus_size_t offset,
	     const u_int16_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%a1@@+,%%a0@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswr4(bus_space_handle_t h, bus_size_t offset,
	     const u_int32_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%a1@@+,%%a0@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswrr2(bus_space_handle_t h, bus_size_t offset,
	     const u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%a1@@+,%%a0@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c / 2)	:
		    "a0","a1","d0");
}

void
hp300_mem_bswrr4(bus_space_handle_t h, bus_size_t offset,
	     const u_int8_t *a, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%a1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%a1@@+,%%a0@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"					:
								:
		    "r" (h + offset), "g" (a), "g" (c / 4)	:
		    "a0","a1","d0");
}

void
hp300_mem_bssm1(bus_space_handle_t h, bus_size_t offset,
	     u_int8_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%d1		;"
	"	movl	%2,%%d0		;"
	"1:	movb	%%d1,%%a0@@	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"						:
									:
		    "r" (h + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
hp300_mem_bssm2(bus_space_handle_t h, bus_size_t offset,
	     u_int16_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%d1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%d1,%%a0@@	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"						:
									:
		    "r" (h + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
hp300_mem_bssm4(bus_space_handle_t h, bus_size_t offset,
	     u_int32_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%d1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%d1,%%a0@@	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"						:
									:
		    "r" (h + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
hp300_mem_bssr1(bus_space_handle_t h, bus_size_t offset,
	     u_int8_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%d1		;"
	"	movl	%2,%%d0		;"
	"1:	movb	%%d1,%%a0@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"						:
									:
		    "r" (h + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
hp300_mem_bssr2(bus_space_handle_t h, bus_size_t offset,
	     u_int16_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%d1		;"
	"	movl	%2,%%d0		;"
	"1:	movw	%%d1,%%a0@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"						:
									:
		    "r" (h + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

void
hp300_mem_bssr4(bus_space_handle_t h, bus_size_t offset,
	     u_int32_t v, size_t c)
{
	__asm __volatile (
	"	movl	%0,%%a0		;"
	"	movl	%1,%%d1		;"
	"	movl	%2,%%d0		;"
	"1:	movl	%%d1,%%a0@@+	;"
	"	subql	#1,%%d0		;"
	"	jne	1b"						:
									:
		    "r" (h + offset), "g" ((u_long)v), "g" (c)	:
		    "a0","d0","d1");
}

#if 0
paddr_t
bus_space_mmap(bus_space_tag_t t, bus_addr_t addr, off_t offset, int prot,
    int flags)
{
	return ((paddr_t)addr + offset);
}
#endif
@


1.8
log
@hp300 ELF bits. Requires many device and prom related structs to now be declared
as packed due to them containing 32-bit types at 16-bit but not 32-bit aligned
offsets. The boot block updates (especially mkboot) come straight from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.7 2010/12/26 15:40:59 miod Exp $	*/
@


1.7
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.6 2008/06/26 05:42:10 ray Exp $	*/
d275 5
a279 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movb	a0@@,a1@@+	;"
	"	subql	#1,d0		;"
d291 5
a295 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a0@@,a1@@+	;"
	"	subql	#1,d0		;"
d307 5
a311 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,%d0		;"
	"1:	movl	a0@@,a1@@+	;"
	"	subql	#1,d0		;"
d323 5
a327 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a0@@,a1@@+	;"
	"	subql	#1,d0		;"
d339 5
a343 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,%d0		;"
	"1:	movl	a0@@,a1@@+	;"
	"	subql	#1,d0		;"
d355 5
a359 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movb	a0@@+,a1@@+	;"
	"	subql	#1,d0		;"
d371 5
a375 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a0@@+,a1@@+	;"
	"	subql	#1,d0		;"
d387 5
a391 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a0@@+,a1@@+	;"
	"	subql	#1,d0		;"
d403 5
a407 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a0@@+,a1@@+	;"
	"	subql	#1,d0		;"
d419 5
a423 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a0@@+,a1@@+	;"
	"	subql	#1,d0		;"
d456 5
a460 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movb	a1@@+,a0@@	;"
	"	subql	#1,d0		;"
d472 5
a476 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a1@@+,a0@@	;"
	"	subql	#1,d0		;"
d488 5
a492 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a1@@+,a0@@	;"
	"	subql	#1,d0		;"
d504 5
a508 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a1@@+,a0@@	;"
	"	subql	#1,d0		;"
d520 5
a524 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a1@@+,a0@@	;"
	"	subql	#1,d0		;"
d536 5
a540 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movb	a1@@+,a0@@+	;"
	"	subql	#1,d0		;"
d552 5
a556 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a1@@+,a0@@+	;"
	"	subql	#1,d0		;"
d568 5
a572 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a1@@+,a0@@+	;"
	"	subql	#1,d0		;"
d584 5
a588 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movw	a1@@+,a0@@+	;"
	"	subql	#1,d0		;"
d600 5
a604 5
	"	movl	%0,a0		;"
	"	movl	%1,a1		;"
	"	movl	%2,d0		;"
	"1:	movl	a1@@+,a0@@+	;"
	"	subql	#1,d0		;"
d616 5
a620 5
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movb	d1,a0@@	;"
	"	subql	#1,d0		;"
d632 5
a636 5
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movw	d1,a0@@	;"
	"	subql	#1,d0		;"
d648 5
a652 5
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movl	d1,a0@@	;"
	"	subql	#1,d0		;"
d664 5
a668 5
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movb	d1,a0@@+	;"
	"	subql	#1,d0		;"
d680 5
a684 5
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movw	d1,a0@@+	;"
	"	subql	#1,d0		;"
d696 5
a700 5
	"	movl	%0,a0		;"
	"	movl	%1,d1		;"
	"	movl	%2,d0		;"
	"1:	movl	d1,a0@@+	;"
	"	subql	#1,d0		;"
@


1.6
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.5 2007/01/06 20:11:01 miod Exp $	*/
d712 1
a712 1
	return (((paddr_t)addr + offset) >> PAGE_SHIFT);
@


1.5
log
@Turn bus_space_tag_t into real structures containing a bunch of function
pointers, to be used for the various bus_space operations.

intio devices no longer need to pass an intiobase-relative address to
bus_space_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.4 2006/06/24 13:20:17 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.4
log
@Use pmap_kenter_cache() for device memory mapping, instead of physacc(0
which bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.3 2005/09/15 18:52:44 martin Exp $	*/
a56 1
extern int *nofault;
d61 80
d142 2
a143 6
bus_space_map(t, bpa, size, flags, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int flags;
	bus_space_handle_t *bshp;
d149 6
a154 7
	switch (HP300_TAG_BUS(t)) {
	case HP300_BUS_INTIO:
		/*
		 * intio space is direct-mapped in pmap_bootstrap(); just
		 * do the translation in this case.
		 */
		*bshp = IIOV(INTIOBASE + bpa);
a155 2
	default:
		break;
d192 1
a192 4
bus_space_unmap(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
d199 5
a203 6
	switch (HP300_TAG_BUS(t)) {
	case HP300_BUS_INTIO:
		/*
		 * intio space is direct-mapped in pmap_bootstrap(); nothing
		 * to do.
		 */
a204 3
	default:
		break;
	}
d237 2
a238 5
bus_space_subregion(t, bsh, offset, size, nbshp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset, size;
	bus_space_handle_t *nbshp;
a239 1

d243 479
@


1.3
log
@get rid of MD m68k_trunc_page and m68k_round_page and replace by MI
trunc_page and round_page

go go go! miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.2 2005/01/23 16:55:17 miod Exp $	*/
d53 1
a53 4
#include <hp300/dev/sgcvar.h>

#include "sgc.h"

d55 1
d59 3
a61 1
/* ARGSUSED */
d71 1
a72 1
	pt_entry_t ptemask;
d77 2
a78 2
		 * Intio space is direct-mapped in pmap_bootstrap(); just
		 * do the translation.
d80 1
a80 1
		*bshp = (bus_space_handle_t)IIOV(INTIOBASE + bpa);
d82 1
a82 7
	case HP300_BUS_DIO:
		break;
#if NSGC > 0
	case HP300_BUS_SGC:
#if 0
		bpa += (bus_addr_t)sgc_slottopa(HP300_TAG_CODE(t));
#endif
a83 3
#endif
	default:
		panic("bus_space_map: bad space tag");
d89 1
a89 1
	size = round_page(size);
d95 3
d102 1
a102 1
		ptemask = PG_RW;
d104 8
a111 2
		ptemask = PG_RW | PG_CI;
	physaccess((caddr_t)kva, (caddr_t)bpa, size, ptemask);
a115 1
	*bshp = (bus_space_handle_t)kva;
a118 32
/* ARGSUSED */
int
bus_space_alloc(t, rstart, rend, size, alignment, boundary, flags,
    bpap, bshp)
	bus_space_tag_t t;
	bus_addr_t rstart, rend;
	bus_size_t size, alignment, boundary;
	int flags;
	bus_addr_t *bpap;
	bus_space_handle_t *bshp;
{

	/*
	 * Not meaningful on any currently-supported hp300 bus.
	 */
	return (EINVAL);
}

/* ARGSUSED */
void
bus_space_free(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{

	/*
	 * Not meaningful on any currently-supported hp300 bus.
	 */
	panic("bus_space_free: shouldn't be here");
}

d128 1
d133 1
a133 1
		 * Intio space is direct-mapped in pmap_bootstrap(); nothing
d137 1
a137 9
	case HP300_BUS_DIO:
#if NSGC > 0
	case HP300_BUS_SGC:
#endif
#ifdef DIAGNOSTIC
		if ((caddr_t)bsh < extiobase ||
		    (caddr_t)bsh >= (extiobase + ptoa(eiomapsize)))
			panic("bus_space_unmap: bad bus space handle");
#endif
a138 2
	default:
		panic("bus_space_unmap: bad space tag");
a140 2
	size = round_page(size);

d142 5
a146 2
	if (bsh & PGOFSET)
		panic("bus_space_unmap: unaligned");
d149 3
d155 2
a156 1
	physunaccess((caddr_t)bsh, size);
d161 3
a163 2
	if (extent_free(extio, (u_long)bsh, size,
	    EX_NOWAIT | EX_MALLOCOK))
d165 3
a167 1
		    "can't free region\n", (u_long) bsh, size);
a180 39
}

/* ARGSUSED */
int
hp300_bus_space_probe(t, bsh, offset, sz)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset;
	int sz;
{
	label_t faultbuf;
	int i;

	nofault = (int *)&faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = NULL;
		return (0);
	}

	switch (sz) {
	case 1:
		i = bus_space_read_1(t, bsh, offset);
		break;

	case 2:
		i = bus_space_read_2(t, bsh, offset);
		break;

	case 4:
		i = bus_space_read_4(t, bsh, offset);
		break;

	default:
		panic("bus_space_probe: unupported data size %d", sz);
		/* NOTREACHED */
	}

	nofault = NULL;
	return (1);
@


1.2
log
@bus_space_map() sti regions with BUS_SPACE_MAP_CACHEABLE if they have the
cache bit set in the region descriptor.  Halves sti processing time on hp300.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.1 2005/01/14 22:39:27 miod Exp $	*/
d98 1
a98 1
	size = m68k_round_page(size);
d183 1
a183 1
	size = m68k_round_page(size);
@


1.1
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
d105 1
a105 1
	 * Map the range.  The range is always cache-inhibited on the hp300.
d107 5
a111 1
	physaccess((caddr_t)kva, (caddr_t)bpa, size, PG_RW | PG_CI);
@

