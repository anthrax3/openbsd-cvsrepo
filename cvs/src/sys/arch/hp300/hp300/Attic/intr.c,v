head	1.27;
access;
symbols
	OPENBSD_5_5:1.26.0.8
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.4
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.25.0.4
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.23.0.6
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.6.0.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.26;

1.26
date	2013.02.02.13.34.29;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.21.22.39.10;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.15.20.40.23;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.18.21.39.14;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.09.17.46.01;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.09.17.32.27;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.09.17.30.53;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.29.18.10.42;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.13.19.39.52;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.24.22.50.29;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.29.07.35.54;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.06.21.09.34;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.28.15.15.32;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.06.27.04.05.45;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.04.22.48.59;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.12.08.06.50.15;	author itojun;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.05.24.23.09.00;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.11.20;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.01.07.23.15.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.07.06.08.02.00;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.04.16.11.56.24;	author downsj;	state Exp;
branches;
next	;

1.6.2.1
date	2001.07.04.10.15.42;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.27.23.19.21;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: intr.c,v 1.26 2013/02/02 13:34:29 miod Exp $	*/
/*	$NetBSD: intr.c,v 1.5 1998/02/16 20:58:30 thorpej Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass, Gordon W. Ross, and Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Link and dispatch interrupts.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/vmmeter.h>

#include <uvm/uvm_extern.h>

#include "ppp.h"
#include "bridge.h"

#include <machine/cpu.h>
#include <machine/intr.h>

/*
 * The location and size of the autovectored interrupt portion
 * of the vector table.
 */
#define ISRLOC		0x18

typedef LIST_HEAD(, isr) isr_list_t;
isr_list_t isr_list[NISR];

/*
 * Default interrupt priorities.
 * IPL_BIO, IPL_NET and IPL_TTY will be adjusted when devices attach.
 */
u_short	hp300_varpsl[NISR] = {
	PSL_S | PSL_IPL0,	/* IPL_NONE */
	PSL_S | PSL_IPL1,	/* IPL_SOFT */
	PSL_S | PSL_IPL3,	/* IPL_BIO */
	PSL_S | PSL_IPL3,	/* IPL_NET */
	PSL_S | PSL_IPL3,	/* IPL_TTY */
	PSL_S | PSL_IPL5,	/* IPL_VM */
	PSL_S | PSL_IPL6,	/* IPL_AUDIO, IPL_CLOCK */
	PSL_S | PSL_IPL7	/* IPL_HIGH */
};

void	intr_computeipl(void);

void
intr_init()
{
	int i;

	/* Initialize the ISR lists. */
	for (i = 0; i < NISR; ++i)
		LIST_INIT(&isr_list[i]);
}

/*
 * Scan all of the ISRs, recomputing the interrupt levels for the spl*()
 * calls.  This doesn't have to be fast.
 */
void
intr_computeipl()
{
	struct isr *isr;
	int ipl;

	/* Start with low values. */
	hp300_varpsl[IPL_BIO] = hp300_varpsl[IPL_NET] =
	    hp300_varpsl[IPL_TTY] = PSL_S | PSL_IPL3;

	for (ipl = 0; ipl < NISR; ipl++) {
		LIST_FOREACH(isr, &isr_list[ipl], isr_link) {
			/*
			 * Bump up the level for a given priority,
			 * if necessary.
			 */
			switch (isr->isr_priority) {
			case IPL_BIO:
				if (ipl > PSLTOIPL(hp300_varpsl[IPL_BIO]))
					hp300_varpsl[IPL_BIO] = IPLTOPSL(ipl);
				break;

			case IPL_NET:
				if (ipl > PSLTOIPL(hp300_varpsl[IPL_NET]))
					hp300_varpsl[IPL_NET] = IPLTOPSL(ipl);
				break;

			case IPL_TTY:
				if (ipl > PSLTOIPL(hp300_varpsl[IPL_TTY]))
					hp300_varpsl[IPL_TTY] = IPLTOPSL(ipl);
				break;

			case IPL_AUDIO:
				/* audio is always at level 6 */
				break;

			default:
				panic("intr_computeipl: bad priority %d",
				    isr->isr_priority);
			}
		}
	}

	/*
	 * Enforce `bio <= net <= tty <= vm'
	 */

	if (hp300_varpsl[IPL_NET] < hp300_varpsl[IPL_BIO])
		hp300_varpsl[IPL_NET] = hp300_varpsl[IPL_BIO];

	if (hp300_varpsl[IPL_TTY] < hp300_varpsl[IPL_NET])
		hp300_varpsl[IPL_TTY] = hp300_varpsl[IPL_NET];
}

void
intr_printlevels()
{

#ifdef DEBUG
	printf("psl: bio = 0x%x, net = 0x%x, tty = 0x%x\n",
	    hp300_varpsl[IPL_BIO], hp300_varpsl[IPL_NET],
	    hp300_varpsl[IPL_TTY]);
#endif

	printf("interrupt levels: bio = %d, net = %d, tty = %d\n",
	    PSLTOIPL(hp300_varpsl[IPL_BIO]), PSLTOIPL(hp300_varpsl[IPL_NET]),
	    PSLTOIPL(hp300_varpsl[IPL_TTY]));
}

/*
 * Establish an interrupt handler.
 * Called by driver attach functions.
 */
void
intr_establish(struct isr *isr, const char *name)
{
	struct isr *curisr;
	isr_list_t *list;

#ifdef DIAGNOSTIC
	if (isr->isr_ipl < 0 || isr->isr_ipl >= NISR)
		panic("intr_establish: bad ipl %d", isr->isr_ipl);
#endif

	evcount_attach(&isr->isr_count, name, &isr->isr_ipl);

	/*
	 * Some devices are particularly sensitive to interrupt
	 * handling latency.  The DCA, for example, can lose many
	 * characters if its interrupt isn't handled with reasonable
	 * speed.  For this reason, we sort ISRs by IPL_* priority,
	 * inserting higher priority interrupts before lower priority
	 * interrupts.
	 */

	/*
	 * Get the appropriate ISR list.  If the list is empty, no
	 * additional work is necessary; we simply insert ourselves
	 * at the head of the list.
	 */
	list = &isr_list[isr->isr_ipl];
	if (LIST_EMPTY(list)) {
		LIST_INSERT_HEAD(list, isr, isr_link);
		goto compute;
	}

	/*
	 * A little extra work is required.  We traverse the list
	 * and place ourselves after any ISRs with our current (or
	 * higher) priority.
	 */
	for (curisr = LIST_FIRST(list);
	    LIST_NEXT(curisr, isr_link) != LIST_END(list);
	    curisr = LIST_NEXT(curisr, isr_link)) {
		if (isr->isr_priority > curisr->isr_priority) {
			LIST_INSERT_BEFORE(curisr, isr, isr_link);
			goto compute;
		}
	}

	/*
	 * We're the least important entry, it seems.  We just go
	 * on the end.
	 */
	LIST_INSERT_AFTER(curisr, isr, isr_link);

 compute:
	/* Compute new interrupt levels. */
	intr_computeipl();
}

/*
 * Disestablish an interrupt handler.
 */
void
intr_disestablish(struct isr *isr)
{
	evcount_detach(&isr->isr_count);
	LIST_REMOVE(isr, isr_link);
	intr_computeipl();
}

/*
 * This is the dispatcher called by the low-level
 * assembly language interrupt routine.
 */
void
intr_dispatch(evec)
	int evec;		/* format | vector offset */
{
	struct isr *isr;
	isr_list_t *list;
	int handled, rc, ipl, vec;
	static int straycount, unexpected;

	vec = (evec & 0xfff) >> 2;
#ifdef DIAGNOSTIC
	if (vec < ISRLOC || vec >= (ISRLOC + NISR))
		panic("isrdispatch: bad vec 0x%x", vec);
#endif
	ipl = vec - ISRLOC;

	uvmexp.intrs++;

	list = &isr_list[ipl];
	if (LIST_EMPTY(list)) {
		if (ipl != IPL_CLOCK) {
			printf("intr_dispatch: ipl %d unexpected\n", ipl);
			if (++unexpected > 10)
				panic("intr_dispatch:"
				    " too many unexpected interrupts");
		}
		return;
	}

	handled = 0;
	/* Give all the handlers a chance. */
	LIST_FOREACH(isr, list, isr_link) {
		rc = (*isr->isr_func)(isr->isr_arg);
		if (rc > 0)
			isr->isr_count.ec_count++;
		handled |= rc;
	}

	if (ipl != IPL_CLOCK) {
		if (handled)
			straycount = 0;
		else if (++straycount > 50)
			panic("intr_dispatch: too many stray interrupts");
		else
			printf("intr_dispatch: stray level %d interrupt\n", ipl);
	}
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl, realwantipl;

	__asm __volatile ("movew %%sr,%0" : "=&d" (oldipl));

	realwantipl = PSLTOIPL(hp300_varpsl[wantipl]);
	oldipl = PSLTOIPL(oldipl);

	if (oldipl < realwantipl) {
		splassert_fail(realwantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		_spl(hp300_varpsl[wantipl]);
	}
}
#endif
@


1.26
log
@hp300 ELF bits. Requires many device and prom related structs to now be declared
as packed due to them containing 32-bit types at 16-bit but not 32-bit aligned
offsets. The boot block updates (especially mkboot) come straight from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.25 2011/12/21 22:39:10 miod Exp $	*/
@


1.25
log
@Allow intr_dispatch() on hp300 to be used on the clock interrupt level
(level 6). Will be used shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.24 2010/09/20 06:33:47 matthew Exp $	*/
d290 1
a290 1
	__asm __volatile ("movew sr,%0" : "=&d" (oldipl));
@


1.24
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.23 2009/03/15 20:40:23 miod Exp $	*/
d70 1
a70 1
	PSL_S | PSL_IPL6,	/* IPL_CLOCK */
d122 4
d256 6
a261 3
		printf("intr_dispatch: ipl %d unexpected\n", ipl);
		if (++unexpected > 10)
			panic("intr_dispatch: too many unexpected interrupts");
d274 8
a281 6
	if (handled)
		straycount = 0;
	else if (++straycount > 50)
		panic("intr_dispatch: too many stray interrupts");
	else
		printf("intr_dispatch: stray level %d interrupt\n", ipl);
@


1.23
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.22 2008/07/18 21:39:14 miod Exp $	*/
d170 1
a170 2
	evcount_attach(&isr->isr_count, name, &isr->isr_ipl,
	    &evcount_intr);
@


1.22
log
@Make IPL_VM level 5, which is guaranteed to be above bio tty and net, instead
of making it dynamic and the smallest value above the former three. Idea
from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.21 2008/06/26 05:42:10 ray Exp $	*/
a43 1
#include <net/netisr.h>
a46 3
void	netintr(void);

#include <machine/atomic.h>
a273 22
}

int netisr;

void
netintr()
{
	int n;

	while ((n = netisr) != 0) {
		atomic_clearbits_int(&netisr, n);

#define	DONETISR(bit, fn)						\
		do {							\
			if (n & (1 << (bit)))				\
				(fn)();					\
		} while (0)

#include <net/netisr_dispatch.h>

#undef	DONETISR
	}
@


1.21
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.20 2007/11/09 17:46:01 miod Exp $	*/
d65 1
a65 1
 * IPL_BIO, IPL_NET, IPL_TTY and IPL_VM will be adjusted when devices attach.
d73 1
a73 1
	PSL_S | PSL_IPL3,	/* IPL_VM */
d102 1
a102 1
	    hp300_varpsl[IPL_TTY] = hp300_varpsl[IPL_VM] = PSL_S | PSL_IPL3;
a141 3

	if (hp300_varpsl[IPL_VM] < hp300_varpsl[IPL_TTY])
		hp300_varpsl[IPL_VM] = hp300_varpsl[IPL_TTY];
d149 1
a149 1
	printf("psl: bio = 0x%x, net = 0x%x, tty = 0x%x, vm = 0x%x\n",
d151 1
a151 1
	    hp300_varpsl[IPL_TTY], hp300_varpsl[IPL_VM]);
@


1.20
log
@IPL_xxx values on hp300 are logical values (although some of them happen to
match the real hardware level used for them).

So instead of keeping a few loose variables to store the runtime computed
psr bits to use for the logical IPL levels, just keep a complete array of
all psr values. Thus we can have a correct splassert_check().
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.19 2007/11/09 17:32:27 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.19
log
@Get rid of IPL_TTYNOBUF, it was handled exactly like IPL_TTY for years.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.18 2007/11/09 17:30:53 miod Exp $	*/
a65 1
#define NISR		8
d70 14
a83 1
u_short	hp300_bioipl, hp300_netipl, hp300_ttyipl, hp300_vmipl;
a94 4

	/* Default interrupt priorities. */
	hp300_bioipl = hp300_netipl = hp300_ttyipl = hp300_vmipl =
	    (PSL_S|PSL_IPL3);
d108 2
a109 2
	hp300_bioipl = hp300_netipl = hp300_ttyipl = hp300_vmipl =
	    (PSL_S|PSL_IPL3);
d119 2
a120 2
				if (ipl > PSLTOIPL(hp300_bioipl))
					hp300_bioipl = IPLTOPSL(ipl);
d124 2
a125 2
				if (ipl > PSLTOIPL(hp300_netipl))
					hp300_netipl = IPLTOPSL(ipl);
d129 2
a130 2
				if (ipl > PSLTOIPL(hp300_ttyipl))
					hp300_ttyipl = IPLTOPSL(ipl);
d134 2
a135 2
				printf("priority = %d\n", isr->isr_priority);
				panic("intr_computeipl: bad priority");
d144 2
a145 2
	if (hp300_netipl < hp300_bioipl)
		hp300_netipl = hp300_bioipl;
d147 2
a148 2
	if (hp300_ttyipl < hp300_netipl)
		hp300_ttyipl = hp300_netipl;
d150 2
a151 2
	if (hp300_vmipl < hp300_ttyipl)
		hp300_vmipl = hp300_ttyipl;
d160 2
a161 1
	    hp300_bioipl, hp300_netipl, hp300_ttyipl, hp300_vmipl);
d165 2
a166 2
	    PSLTOIPL(hp300_bioipl), PSLTOIPL(hp300_netipl),
	    PSLTOIPL(hp300_ttyipl));
d316 1
a316 1
	int oldipl;
d320 1
d323 2
a324 2
	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
d329 1
a329 1
		_spl(PSL_S | IPLTOPSL(wantipl));
@


1.18
log
@Move splassert_check() from common m68k code to each m68k-based architecture,
as its implementation may vary accross platforms (and will very soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.17 2007/05/29 18:10:42 miod Exp $	*/
a120 1
			case IPL_TTYNOBUF:
@


1.17
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.16 2006/03/13 19:39:52 brad Exp $	*/
d303 21
@


1.16
log
@remove splimp.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.15 2004/12/25 23:02:24 miod Exp $	*/
d57 1
d287 11
a297 7
#define	DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << (bit))) { \
			netisr &= ~(1 << (bit)); \
			(fn)(); \
		} \
	} while (0)
d299 1
d301 1
@


1.15
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.14 2004/12/24 22:50:29 miod Exp $	*/
d70 1
a70 1
u_short	hp300_bioipl, hp300_netipl, hp300_ttyipl, hp300_impipl;
d84 1
a84 1
	hp300_bioipl = hp300_netipl = hp300_ttyipl = hp300_impipl =
d99 1
a99 1
	hp300_bioipl = hp300_netipl = hp300_ttyipl = hp300_impipl =
d133 1
a133 1
	 * Enforce `bio <= net <= tty <= imp'
d142 2
a143 2
	if (hp300_impipl < hp300_ttyipl)
		hp300_impipl = hp300_ttyipl;
d151 2
a152 2
	printf("psl: bio = 0x%x, net = 0x%x, tty = 0x%x, imp = 0x%x\n",
	    hp300_bioipl, hp300_netipl, hp300_ttyipl, hp300_impipl);
@


1.14
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.13 2004/09/29 07:35:54 miod Exp $	*/
d103 1
a103 2
		for (isr = isr_list[ipl].lh_first; isr != NULL;
		    isr = isr->isr_link.le_next) {
d193 1
a193 1
	if (list->lh_first == NULL) {
d203 3
a205 2
	for (curisr = list->lh_first; curisr->isr_link.le_next != NULL;
	    curisr = curisr->isr_link.le_next) {
d257 1
a257 1
	if (list->lh_first == NULL) {
d266 1
a266 1
	for (isr = list->lh_first ; isr != NULL; isr = isr->isr_link.le_next) {
@


1.13
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.12 2003/11/06 21:09:34 mickey Exp $	*/
a71 2
extern	int intrcnt[];		/* from locore.s */

a253 1
	intrcnt[ipl]++;
@


1.12
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.11 2002/04/28 15:15:32 miod Exp $	*/
a43 2
#define _HP300_INTR_H_PRIVATE

d60 7
d167 2
a168 6
void *
intr_establish(func, arg, ipl, priority)
	int (*func)(void *);
	void *arg;
	int ipl;
	int priority;
d170 1
a170 1
	struct isr *newisr, *curisr;
d173 4
a176 2
	if ((ipl < 0) || (ipl >= NISR))
		panic("intr_establish: bad ipl %d", ipl);
d178 2
a179 9
	newisr = (struct isr *)malloc(sizeof(struct isr), M_DEVBUF, M_NOWAIT);
	if (newisr == NULL)
		panic("intr_establish: can't allocate space for isr");

	/* Fill in the new entry. */
	newisr->isr_func = func;
	newisr->isr_arg = arg;
	newisr->isr_ipl = ipl;
	newisr->isr_priority = priority;
d195 1
a195 1
	list = &isr_list[ipl];
d197 1
a197 1
		LIST_INSERT_HEAD(list, newisr, isr_link);
d208 2
a209 2
		if (newisr->isr_priority > curisr->isr_priority) {
			LIST_INSERT_BEFORE(curisr, newisr, isr_link);
d218 1
a218 1
	LIST_INSERT_AFTER(curisr, newisr, isr_link);
a222 1
	return (newisr);
d229 1
a229 2
intr_disestablish(arg)
	void *arg;
d231 1
a231 2
	struct isr *isr = arg;

a232 1
	free(isr, M_DEVBUF);
d246 1
a246 1
	int handled, ipl, vec;
d250 2
a251 1
	if ((vec < ISRLOC) || (vec >= (ISRLOC + NISR)))
d253 1
d269 6
a274 2
	for (isr = list->lh_first ; isr != NULL; isr = isr->isr_link.le_next)
		handled |= (*isr->isr_func)(isr->isr_arg);
@


1.11
log
@Use netisr_dispatch
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.10 2002/03/14 01:26:30 millert Exp $	*/
d285 2
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.9 2001/11/06 19:53:14 miod Exp $	*/
d289 9
a297 52
#ifdef INET
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
#endif
#ifdef INET6
	if (netisr & (1 << NETISR_IPV6)) {
		netisr &= ~(1 << NETISR_IPV6);
		ip6intr();
	}
#endif
#ifdef NETATALK
	if (netisr & (1 << NETISR_ATALK)) {
		netisr &= ~(1 << NETISR_ATALK);
		atintr();
	}
#endif
#ifdef NS
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
#endif
#ifdef ISO
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
#endif
#ifdef CCITT
	if (netisr & (1 << NETISR_CCITT)) {
		netisr &= ~(1 << NETISR_CCITT);
		ccittintr();
	}
#endif
#if NPPP > 0
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
#endif
#if NBRIDGE > 0
	if (netisr & (1 << NETISR_BRIDGE)) {
		netisr &= ~(1 << NETISR_BRIDGE);
		bridgeintr();
	}
#endif
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.8 2001/06/27 04:05:45 art Exp $	*/
d57 1
a57 1
void	netintr __P((void));
d69 1
a69 1
void	intr_computeipl __P((void));
d164 1
a164 1
	int (*func) __P((void *));
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.9 2001/11/06 19:53:14 miod Exp $	*/
d57 1
a57 1
void	netintr(void);
d69 1
a69 1
void	intr_computeipl(void);
d164 1
a164 1
	int (*func)(void *);
d289 52
a340 9
#define	DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << (bit))) { \
			netisr &= ~(1 << (bit)); \
			(fn)(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef	DONETISR
@


1.8
log
@no more old VM
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.7 2001/05/04 22:48:59 aaron Exp $	*/
a50 1
#include <vm/vm.h>
@


1.7
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6 1999/12/08 06:50:15 itojun Exp $	*/
a50 1
#if defined(UVM)
a52 1
#endif
a263 1
#if defined(UVM)
a264 3
#else
	cnt.v_intr++;
#endif
@


1.6
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 2
a2 2
/*	$OpenBSD: intr.c,v 1.5 1999/05/24 23:09:00 jason Exp $	*/
/*	$NetBSD: intr.c,v 1.2 1997/05/01 16:24:26 thorpej Exp $	*/
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d51 5
d266 3
d270 1
@


1.6.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: intr.c,v 1.5 1998/02/16 20:58:30 thorpej Exp $	*/
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
a50 3
#include <vm/vm.h>
#include <uvm/uvm_extern.h>

d261 1
a261 1
	uvmexp.intrs++;
@


1.6.2.2
log
@Merge in -current
@
text
@d51 1
@


1.6.2.3
log
@Merge in -current from about a week ago
@
text
@d57 1
a57 1
void	netintr(void);
d69 1
a69 1
void	intr_computeipl(void);
d164 1
a164 1
	int (*func)(void *);
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d289 52
a340 9
#define	DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << (bit))) { \
			netisr &= ~(1 << (bit)); \
			(fn)(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef	DONETISR
@


1.6.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a285 2
int netisr;

@


1.5
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.4 1999/01/11 05:11:20 millert Exp $	*/
d300 1
a300 1
		ipv6intr();
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.3 1999/01/07 23:15:57 deraadt Exp $	*/
d53 1
d331 6
@


1.3
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.2 1997/07/06 08:02:00 downsj Exp $	*/
d256 1
a256 1
		panic("isrdispatch: bad vec 0x%x\n", vec);
@


1.2
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.1 1997/04/16 11:56:24 downsj Exp $	*/
d52 3
a282 12
/*
 * XXX Why on earth isn't this in a common file?!
 */
void	netintr __P((void));
void	arpintr __P((void));
void	atintr __P((void));
void	ipintr __P((void));
void	nsintr __P((void));
void	clnintr __P((void));
void	ccittintr __P((void));
void	pppintr __P((void));

d296 6
a325 1
#include "ppp.h"
@


1.1
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: intr.c,v 1.1 1997/04/14 02:28:44 thorpej Exp $	*/
d183 3
a185 12
	 * speed.
	 *
	 * To work around this problem, each device can give itself a
	 * "priority".  An unbuffered DCA would give itself a higher
	 * priority than a SCSI device, for example.
	 *
	 * This is necessary because of the flat spl scheme employed by
	 * the hp300.  Each device can be set from ipl 3 to ipl 5, which
	 * in turn means that splbio, splnet, and spltty must all be at
	 * spl5.
	 *
	 * Don't blame me...I just work here.
@
