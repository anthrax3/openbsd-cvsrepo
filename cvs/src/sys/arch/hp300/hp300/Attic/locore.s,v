head	1.74;
access;
symbols
	OPENBSD_5_5:1.73.0.6
	OPENBSD_5_5_BASE:1.73
	OPENBSD_5_4:1.73.0.2
	OPENBSD_5_4_BASE:1.73
	OPENBSD_5_3:1.71.0.2
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.69.0.4
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.2
	OPENBSD_5_0:1.65.0.6
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.65.0.4
	OPENBSD_4_9_BASE:1.65
	OPENBSD_4_8:1.65.0.2
	OPENBSD_4_8_BASE:1.65
	OPENBSD_4_7:1.64.0.2
	OPENBSD_4_7_BASE:1.64
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.63.0.6
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.63.0.4
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.63.0.2
	OPENBSD_4_3_BASE:1.63
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.59.0.4
	OPENBSD_4_1_BASE:1.59
	OPENBSD_4_0:1.59.0.2
	OPENBSD_4_0_BASE:1.59
	OPENBSD_3_9:1.52.0.2
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.49.0.2
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.48.0.2
	OPENBSD_3_7_BASE:1.48
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.35.0.4
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.34.0.2
	OPENBSD_3_1_BASE:1.34
	UBC_SYNC_B:1.35
	UBC:1.33.0.2
	UBC_BASE:1.33
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9:1.22.0.4
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.21.0.10
	OPENBSD_2_7_BASE:1.21
	SMP:1.21.0.8
	SMP_BASE:1.21
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.6
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.21.0.4
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.17.0.2
	OPENBSD_2_1_BASE:1.17
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.74
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.73;

1.73
date	2013.06.30.23.47.07;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2013.06.23.20.15.52;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2013.02.02.13.34.29;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2012.09.08.19.24.28;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2012.01.22.13.13.06;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2011.12.21.22.39.10;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2011.11.01.21.20.55;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2011.08.18.19.54.18;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.29.20.30.31;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2009.03.15.20.40.23;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.04.19.10.31;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2007.12.30.14.45.24;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.15.13.46.22;	author martin;	state Exp;
branches;
next	1.59;

1.59
date	2006.08.17.06.33.59;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2006.07.09.19.41.21;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.24.13.20.17;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2006.06.11.20.57.41;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.11.20.44.18;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.20.14.54.52;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.19.22.51.07;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.21.12.27.56;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.13.23.14.33;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.27.22.05.37;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2005.08.05.03.36.28;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.18.13.32.56;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2005.01.14.22.39.27;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.14.19.11.56;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.30.21.28.47;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.30.21.26.14;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.24.22.50.29;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.09.29.07.35.54;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.22.19.36.38;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.02.17.33.42;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.20.09.20.41;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.09.00.08.13;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.02.18.47.58;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.25.22.32.51;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.10.23.15.05;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.06.21.13.28;	author millert;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2001.12.06.19.27.44;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.19.21.32.56;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.26.00.15.37;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.25.16.16.03;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.27.04.05.45;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.13.17.27.24;	author aaron;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.13.17.19.56;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.13.16.55.35;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.10.01.32.58;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.04.22.48.59;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.05.11.02.57;	author art;	state Exp;
branches;
next	1.21;

1.21
date	98.09.06.20.09.59;	author millert;	state Exp;
branches
	1.21.8.1;
next	1.20;

1.20
date	97.11.06.19.42.34;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.09.23.07.09.54;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	97.07.06.08.02.04;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	97.04.17.12.02.32;	author downsj;	state Exp;
branches;
next	1.16;

1.16
date	97.04.17.11.40.37;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.04.17.10.28.38;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.04.16.11.56.27;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.03.26.08.32.41;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	97.02.23.21.42.54;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.02.10.11.13.28;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.02.05.17.30.23;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.02.03.15.54.43;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.03.04.47.56;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.01.12.15.13.22;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.23.19.35;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.11.47.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.25.06.37.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.31.06.42.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.29.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.23;	author deraadt;	state Exp;
branches;
next	;

1.21.8.1
date	2001.04.18.16.05.39;	author niklas;	state Exp;
branches;
next	1.21.8.2;

1.21.8.2
date	2001.07.04.10.15.43;	author niklas;	state Exp;
branches;
next	1.21.8.3;

1.21.8.3
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.21.8.4;

1.21.8.4
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.21.8.5;

1.21.8.5
date	2003.03.27.23.19.21;	author niklas;	state Exp;
branches;
next	1.21.8.6;

1.21.8.6
date	2003.06.07.11.11.35;	author ho;	state Exp;
branches;
next	1.21.8.7;

1.21.8.7
date	2004.06.05.23.10.46;	author niklas;	state Exp;
branches;
next	;

1.33.2.1
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: locore.s,v 1.73 2013/06/30 23:47:07 miod Exp $	*/
/*	$NetBSD: locore.s,v 1.91 1998/11/11 06:41:25 thorpej Exp $	*/

/*
 * Copyright (c) 1997 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1994, 1995 Gordon W. Ross
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1980, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: locore.s 1.66 92/12/22$
 *
 *	@@(#)locore.s	8.6 (Berkeley) 5/27/94
 */

#include "assym.h"
#include <machine/asm.h>
#include <machine/trap.h>

#include "audio.h"
#include "ksyms.h"
#ifdef USELEDS
#include <hp300/hp300/leds.h>
#endif
#include <hp300/dev/dioreg.h>
#include <hp300/dev/diofbreg.h>

#include "sgc.h"
#if NSGC > 0
#include <hp300/dev/sgcreg.h>
#endif

#define	SYSFLAG		0xfffffed2

#define MMUADDR(ar)	movl	_C_LABEL(MMUbase),ar
#define CLKADDR(ar)	movl	_C_LABEL(CLKbase),ar

/*
 * This is for kvm_mkdb, and should be the address of the beginning
 * of the kernel text segment (not necessarily the same as kernbase).
 */
	.chip	68020
	.text
GLOBAL(kernel_text)

/*
 * Clear and skip the first page of text; it will not be mapped.
 */
	.fill	NBPG/4,4,0

/*
 * Temporary stack for a variety of purposes.
 * Try and make this the first thing in the data segment so it
 * is page aligned.  Note that if we overflow here, we run into
 * our text segment.
 */
	.data
	.space	NBPG
ASLOCAL(tmpstk)

#include <hp300/hp300/vectors.s>

/*
 * Macro to relocate a symbol, used before MMU is enabled.
 */
#ifdef __STDC__
#define	RELOC(var, ar)			\
	moveal	#_C_LABEL(var),ar;	\
	addl	%a5,ar
#define	ASRELOC(var, ar)		\
	moveal	#_ASM_LABEL(var),ar;	\
	addl	%a5,ar
#else
#define	_RELOC(var, ar)			\
	movel	#var,ar;		\
	addl	%a5,ar
#define	RELOC(var, ar)		_RELOC(_C_LABEL(var), ar)
#define	ASRELOC(var, ar)	_RELOC(_ASM_LABEL(var), ar)
#endif

/*
 * Final bits of grunt work required to reboot the system.  The MMU
 * must be disabled when this is invoked.
 */
#define DOREBOOT						\
	/* Reset Vector Base Register to what PROM expects. */	\
	movl	#0,%d0;						\
	movc	%d0,%vbr;					\
	/* Jump to REQ_REBOOT */				\
	jmp	0x1A4;

/*
 * Initialization
 *
 * A4 contains the address of the end of the symtab
 * A5 contains physical load point from boot
 * VBR contains zero from ROM.  Exceptions will continue to vector
 * through ROM until MMU is turned on at which time they will vector
 * through our table (vectors.s).
 */

BSS(lowram,4)
BSS(esym,4)

ASENTRY_NOPROFILE(start)
	movw	#PSL_HIGHIPL,%sr	| no interrupts
	ASRELOC(tmpstk, %a0)
	movl	%a0,%sp			| give ourselves a temporary stack
	RELOC(esym, %a0)
	movl	%a4,%a0@@		| store end of symbol table
	RELOC(lowram, %a0)
	movl	%a5,%a0@@		| store start of physical memory
	movl	#CACHE_OFF,%d0
	movc	%d0,%cacr		| clear and disable on-chip cache(s)

	/* check for internal HP-IB in SYSFLAG */
	btst	#5,SYSFLAG		| internal HP-IB?
	jeq	Lhaveihpib		| yes, have HP-IB just continue
	RELOC(internalhpib, %a0)
	movl	#0,%a0@@			| no, clear associated address
Lhaveihpib:

	RELOC(boothowto, %a0)		| save reboot flags
	movl	%d7,%a0@@
	RELOC(bootdev, %a0)		|   and boot device
	movl	%d6,%a0@@

	/*
	 * All data registers are now free.  All address registers
	 * except a5 are free.  a5 is used by the RELOC() macro,
	 * and cannot be used until after the MMU is enabled.
	 */

/* determine our CPU/MMU combo - check for all regardless of kernel config */
	movl	#INTIOBASE+MMUBASE,%a1
	movl	#0x200,%d0		| data freeze bit
	movc	%d0,%cacr		|   only exists on 68030
	movc	%cacr,%d0		| read it back
	tstl	%d0			| zero?
	jeq	Lnot68030		| yes, we have 68020/68040

	/*
	 * 68030 models
	 */

	RELOC(mmutype, %a0)		| no, we have 68030
	movl	#MMU_68030,%a0@@		| set to reflect 68030 PMMU
	RELOC(cputype, %a0)
	movl	#CPU_68030,%a0@@		| and 68030 CPU
	RELOC(machineid, %a0)
	movl	#0x80,%a1@@(MMUCMD)	| set magic cookie
	movl	%a1@@(MMUCMD),%d0	| read it back
	btst	#7,%d0			| cookie still on?
	jeq	Lnot370			| no, 360 or 375
	movl	#0,%a1@@(MMUCMD)		| clear magic cookie
	movl	%a1@@(MMUCMD),%d0	| read it back
	btst	#7,%d0			| still on?
	jeq	Lisa370			| no, must be a 370
	movl	#HP_340,%a0@@		| yes, must be a 340
	jra	Lstart1
Lnot370:
	movl	#HP_36X,%a0@@		| type is at least a 360
	movl	#0,%a1@@(MMUCMD)		| clear magic cookie2
	movl	%a1@@(MMUCMD),%d0	| read it back
	btst	#16,%d0			| still on?
	jeq	Lisa36x			| no, must be a 360 or a 362
	RELOC(mmuid, %a0)		| save MMU ID
	lsrl	#MMUID_SHIFT,%d0
	andl	#MMUID_MASK,%d0
	movl	%d0,%a0@@
	RELOC(machineid, %a0)
	cmpb	#MMUID_345,%d0		| are we a 345?
	beq	Lisa345
	cmpb	#MMUID_375,%d0		| how about a 375?
	beq	Lisa375
	movl	#HP_400,%a0@@		| must be a 400
	jra	Lhaspac
Lisa345:
	movl	#HP_345,%a0@@
	jra	Lhaspac
Lisa375:
	movl	#HP_375,%a0@@
	jra	Lhaspac
Lisa370:
	movl	#HP_370,%a0@@		| set to 370
Lhaspac:
	RELOC(ectype, %a0)
	movl	#EC_PHYS,%a0@@		| also has a physical address cache
	jra	Lstart1

	/*
	 * End of 68030 section
	 */

Lnot68030:
	bset	#31,%d0			| data cache enable bit
	movc	%d0,%cacr		|   only exists on 68040
	movc	%cacr,%d0		| read it back
	tstl	%d0			| zero?
	beq	Lis68020		| yes, we have 68020
	moveq	#CACHE40_OFF,%d0	| now turn it back off
	movc	%d0,%cacr		|   before we access any data

	/*
	 * 68040 models
	 */

	RELOC(mmutype, %a0)
	movl	#MMU_68040,%a0@@		| with a 68040 MMU
	RELOC(cputype, %a0)
	movl	#CPU_68040,%a0@@		| and a 68040 CPU
	RELOC(fputype, %a0)
	movl	#FPU_68040,%a0@@		| ...and FPU
	RELOC(ectype, %a0)
	movl	#EC_NONE,%a0@@		| and no cache (for now XXX)
	RELOC(mmuid, %a0)
	movl	%a1@@(MMUCMD),%d0	| read MMU register
	lsrl	#MMUID_SHIFT,%d0
	andl	#MMUID_MASK,%d0
	movl	%d0,%a0@@		| save MMU ID
	RELOC(machineid, %a0)
	cmpb	#MMUID_425_T,%d0	| are we a 425t?
	jeq	Lisa425
	cmpb	#MMUID_425_S,%d0	| how about 425s?
	jeq	Lisa425
	cmpb	#MMUID_425_E,%d0	| or maybe a 425e?
	jeq	Lisa425
	cmpb	#MMUID_433_T,%d0	| or a 433t?
	jeq	Lisa433
	cmpb	#MMUID_433_S,%d0	| maybe a 433s?
	jeq	Lisa433
	cmpb	#MMUID_385,%d0		| then a 385?
	jeq	Lisa385
	cmpb	#MMUID_382,%d0		| last chance...
	jeq	Lisa382
	movl	#HP_380,%a0@@		| guess we're a 380
	jra	Lstart1
Lisa425:
	movl	#HP_425,%a0@@
	jra	Lstart1
Lisa433:
	movl	#HP_433,%a0@@
	jra	Lstart1
Lisa385:
	movl	#HP_385,%a0@@
	jra	Lstart1
Lisa382:
	movl	#HP_382,%a0@@
	jra	Lstart1

	/*
	 * End of 68040 section
	 */

	/*
	 * 68020 models
	 */

Lis68020:
	RELOC(fputype, %a0)		| all of the 68020 systems
	movl	#FPU_68881,%a0@@		|   have a 68881 FPU
	movl	#1,%a1@@(MMUCMD)		| a 68020, write HP MMU location
	movl	%a1@@(MMUCMD),%d0	| read it back
	btst	#0,%d0			| non-zero?
	jne	Lunsupp			| yes, we have HP MMU
	RELOC(mmutype, %a0)
	movl	#MMU_68851,%a0@@		| no, we have PMMU
	RELOC(machineid, %a0)
	movl	#HP_330,%a0@@		| and 330 CPU
	jra	Lstart1

	/*
	 * End of 68020 section
	 */

Lisa36x:
	/*
	 * There is currently no easy way of telling a 362 and a 360
	 * apart, except perhaps checking for the 362 frame buffer if
	 * it isn't disabled.
	 */
	/* FALLTHROUGH */

Lstart1:
	/*
	 * Now we need to know how much space the external I/O map has to be.
	 * This has to be done before pmap_bootstrap() is invoked, but since
	 * we are not running in virtual mode and will cause several bus
	 * errors while probing, it is easier to do this before setting up
	 * our own vectors table.
	 */
	clrl	%d3

	/*
	 * Don't probe the DIO-I space, simply assume the whole 0-31
	 * select code range is taken, i.e. 32 boards.
	 */
	addl	#(DIO_DEVSIZE * 32), %d3

	/*
	 * Check the ``internal'' frame buffer address. If there is one,
	 * assume an extra 2MB of frame buffer memory at 0x200000.
	 */
	movl	#GRFIADDR, %a0
	ASRELOC(phys_badaddr, %a3)
	jbsr	%a3@@
	tstl	%d0			| success?
	jne	dioiicheck		| no, skip
	movl	#0x200000, %d1		| yes, add the 200000-400000 range
	addl	%d1, %d3

	/*
	 * Probe for DIO-II devices, select codes 132 to 255.
	 */
dioiicheck:
	RELOC(machineid,%a0)
	cmpl	#HP_320,%a0@@
	jeq	eiodone			| HP 320 has nothing more

	movl	#DIOII_SCBASE, %d2	| our select code...
	movl	#DIOII_BASE, %a0	| and first address
dioloop:
	ASRELOC(phys_badaddr, %a3)
	jbsr	%a3@@			| probe address (read ID)
	movl	#DIOII_DEVSIZE, %d1
	tstl	%d0			| success?
	jne	1f			| no, skip
	addl	%d1, %d3		| yes, count it
1:
	addl	%d1, %a0		| next slot address...
	addql	#1, %d2			| and slot number
	cmpl	#256, %d2
	jne	dioloop

#if NSGC > 0
	/*
	 * Probe for SGC devices, slots 0 to 3.
	 * Only do the probe on machines which might have an SGC bus.
	 */
	RELOC(machineid,%a0)
	cmpl	#HP_400,%a0@@
	jeq	sgcprobe
	cmpl	#HP_425,%a0@@
	jeq	sgcprobe
	cmpl	#HP_433,%a0@@
	jne	eiodone
sgcprobe:
	clrl	%d2			| first slot...
	movl	#SGC_BASE, %a0		| and first address
sgcloop:
	ASRELOC(phys_badaddr, %a3)
	jbsr	%a3@@			| probe address
	movl	#SGC_DEVSIZE, %d1
	tstl	%d0			| success?
	jne	2f			| no, skip
	addl	%d1, %d3		| yes, count it
2:
	addl	%d1, %a0		| next slot address...
	addql	#1, %d2			| and slot number
	cmpl	#SGC_NSLOTS, %d2
	jne	sgcloop
#endif

eiodone:
	moveq	#PGSHIFT, %d2
	lsrl	%d2, %d3		| convert from bytes to pages
	RELOC(eiomapsize,%a2)
	addql	#1, %d3			| add an extra page for device probes
	movl	%d3,%a2@@

	/*
	 * Now that we know what CPU we have, initialize the address error
	 * and bus error handlers in the vector table:
	 *
	 *	vectab+8	bus error
	 *	vectab+12	address error
	 */
	RELOC(cputype, %a0)
	RELOC(vectab, %a2)
#if defined(M68040)
	cmpl	#CPU_68040,%a0@@		| 68040?
	jne	1f			| no, skip
	movl	#_C_LABEL(buserr40),%a2@@(8)
	movl	#_C_LABEL(addrerr4060),%a2@@(12)
	jra	Lstart2
1:
#endif
#if defined(M68020) || defined(M68030)
	cmpl	#CPU_68040,%a0@@		| 68040?
	jeq	1f			| yes, skip
	movl	#_C_LABEL(busaddrerr2030),%a2@@(8)
	movl	#_C_LABEL(busaddrerr2030),%a2@@(12)
	jra	Lstart2
1:
#endif
Lunsupp:
	/* Config botch; no hope. */
	DOREBOOT

Lstart2:
/* initialize source/destination control registers for movs */
	moveq	#FC_USERD,%d0		| user space
	movc	%d0,%sfc		|   as source
	movc	%d0,%dfc		|   and destination of transfers
/* initialize memory size (for pmap_bootstrap) */
	movl	#MAXADDR,%d1		| last page
	movl	%a5,%d0			| lowram value from ROM via boot
	moveq	#PGSHIFT,%d2
	subl	%d0,%d1			| compute amount of RAM present
	lsrl	%d2,%d1			| convert to pages
	addl	#3,%d1			| restore the 3 pages lost (2 from
					| the bootloader and the MAXADDR one)
	RELOC(physmem, %a0)
	movl	%d1,%a0@@		| save as physmem

/* configure kernel and proc0 VA space so we can get going */
#if defined(DDB) || NKSYMS > 0
	RELOC(esym,%a0)			| end of static kernel test/data/syms
	movl	%a0@@,%d5
	jne	Lstart3
#endif
	movl	#_C_LABEL(end),%d5	| end of static kernel text/data
Lstart3:
	addl	#NBPG-1,%d5
	andl	#PG_FRAME,%d5		| round to a page
	movl	%d5,%a4
	addl	%a5,%a4			| convert to PA
	pea	%a5@@			| firstpa
	pea	%a4@@			| nextpa
	RELOC(pmap_bootstrap,%a0)
	jbsr	%a0@@			| pmap_bootstrap(firstpa, nextpa)
	addql	#8,%sp

/*
 * While still running physical, override copypage() with the 68040
 * optimized version, copypage040(), if possible.
 * This relies upon the fact that copypage() immediately follows
 * copypage040() in memory.
 */
	RELOC(mmutype, %a0)
	cmpl	#MMU_68040,%a0@@
	jgt	Lmmu_enable
	RELOC(copypage040, %a0)
	RELOC(copypage, %a1)
	movl	%a1, %a2
1:
	movw	%a0@@+, %a2@@+
	cmpl	%a0, %a1
	jgt	1b

/*
 * Prepare to enable MMU.
 * Since the kernel is not mapped logical == physical we must insure
 * that when the MMU is turned on, all prefetched addresses (including
 * the PC) are valid.  In order to guarantee that, we use the last physical
 * page (which is conveniently mapped == VA) and load it up with enough
 * code to defeat the prefetch, then we execute the jump back to here.
 *
 * Is this all really necessary, or am I paranoid??
 */
Lmmu_enable:
	RELOC(Sysseg, %a0)		| system segment table addr
	movl	%a0@@,%d1		| read value (a KVA)
	addl	%a5,%d1			| convert to PA
	RELOC(mmutype, %a0)
	cmpl	#MMU_68040,%a0@@		| 68040?
	jne	Lmotommu1		| no, skip
	.chip	68040
	movc	%d1,%srp
	.chip	68020
	jra	Lstploaddone
Lmotommu1:
	ASRELOC(protorp, %a0)
	movl	#0x80000202,%a0@@	| nolimit + share global + 4 byte PTEs
	movl	%d1,%a0@@(4)		| + segtable address
	pmove	%a0@@,%srp		| load the supervisor root pointer
	movl	#0x80000002,%a0@@	| reinit upper half for CRP loads

Lstploaddone:
	lea	MAXADDR,%a2		| PA of last RAM page
	ASRELOC(Lhighcode, %a1)		| addr of high code
	ASRELOC(Lehighcode, %a3)	| end addr
Lcodecopy:
	movw	%a1@@+,%a2@@+		| copy a word
	cmpl	%a3,%a1			| done yet?
	jcs	Lcodecopy		| no, keep going
	jmp	MAXADDR			| go for it!

	/*
	 * BEGIN MMU TRAMPOLINE.  This section of code is not
	 * executed in-place.  It's copied to the last page
	 * of RAM (mapped va == pa) and executed there.
	 */

Lhighcode:
	/*
	 * Set up the vector table, and race to get the MMU
	 * enabled.
	 */
	movl	#_C_LABEL(vectab),%d0	| set Vector Base Register
	movc	%d0,%vbr

	RELOC(mmutype, %a0)
	cmpl	#MMU_68040,%a0@@		| 68040?
	jne	Lmotommu2		| no, skip
	.chip	68040
	movw	#0,INTIOBASE+MMUBASE+MMUCMD+2
	movw	#MMU_IEN+MMU_CEN+MMU_FPE,INTIOBASE+MMUBASE+MMUCMD+2
					| enable FPU and caches
	moveq	#0,%d0			| ensure TT regs are disabled
	movc	%d0,%itt0
	movc	%d0,%itt1
	movc	%d0,%dtt1

	/*
	 * Set up transparent translation for supervisor data access.
	 * The range 0xc0000000-0xffffffff will not be translated, and
	 * thus yields a 1:1 mapping of the physical memory in the top
	 * of the address space (as long as we don't have more than
	 * 1GB of memory, which will be very unlikely...)
	 */
	movl	#0xc03fa020,%d0
	movc	%d0,%dtt0

	cinva	%bc
	pflusha
	movl	#0x8000,%d0
	movc	%d0,%tc
	movl	#CACHE40_ON,%d0
	movc	%d0,%cacr		| turn on both caches
	jmp	Lenab1:l		| forced to not be pc-relative
	.chip	68020
Lmotommu2:
	cmpl	#MMU_68030,%a0@@		| 68030?
	jne	Lmotommu2b		| no, skip
	.chip	68030
	/*
	 * Set up transparent translation for supervisor data access
	 * (FC == 5), similar to the 68040 logic above.
	 */
	ASRELOC(mmuscratch, %a2)
	movl	#0xc03f8150,%a2@@	| build our TT0 value
	pmove	%a2@@,%tt0
	.chip	68020
Lmotommu2b:
	movl	#MMU_IEN+MMU_FPE,INTIOBASE+MMUBASE+MMUCMD
					| enable MMU and i-cache
	ASRELOC(mmuscratch, %a2)
	movl	#0x82c0aa00,%a2@@	| value to load TC with
	pmove	%a2@@,%tc		| load it
	jmp	Lenab1:l		| forced to not be pc-relative
Lehighcode:

	/*
	 * END MMU TRAMPOLINE.  Address register a5 is now free.
	 */

/*
 * Should be running mapped from this point on
 */
Lenab1:
/* select the software page size now */
	lea	_ASM_LABEL(tmpstk),%sp	| temporary stack
	jbsr	_C_LABEL(uvm_setpagesize) | select software page size
/* set kernel stack, user SP, and initial pcb */
	movl	_C_LABEL(proc0paddr),%a1 | get proc0 pcb addr
	lea	%a1@@(USPACE-4),%sp	| set kernel stack to end of area
	lea	_C_LABEL(proc0),%a2	| initialize proc0.p_addr so that
	movl	%a1,%a2@@(P_ADDR)	|   we don't deref NULL in trap()
	movl	#USRSTACK-4,%a2
	movl	%a2,%usp		| init user SP
	movl	%a1,_C_LABEL(curpcb)	| proc0 is running

	tstl	_C_LABEL(fputype)	| Have an FPU?
	jeq	Lenab2			| No, skip.
	clrl	%a1@@(PCB_FPCTX)		| ensure null FP context
	movl	%a1,%sp@@-
	jbsr	_C_LABEL(m68881_restore) | restore it (does not kill a1)
	addql	#4,%sp
Lenab2:
/* flush TLB and turn on caches */
	jbsr	_ASM_LABEL(TBIA)	| invalidate TLB
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jeq	Lnocache0		| yes, cache already on
	movl	#CACHE_ON,%d0
	movc	%d0,%cacr		| clear cache(s)
	tstl	_C_LABEL(ectype)
	jeq	Lnocache0
	MMUADDR(%a0)
	orl	#MMU_CEN,%a0@@(MMUCMD)	| turn on external cache
Lnocache0:
/* Final setup for call to main(). */
	jbsr	_C_LABEL(hp300_init)

/*
 * Create a fake exception frame so that cpu_fork() can copy it.
 * main() never returns; we exit to user mode from a forked process
 * later on.
 */
	clrw	%sp@@-			| vector offset/frame type
	clrl	%sp@@-			| PC - filled in by "execve"
	movw	#PSL_USER,%sp@@-		| in user mode
	clrl	%sp@@-			| stack adjust count and padding
	lea	%sp@@(-64),%sp		| construct space for D0-D7/A0-A7
	lea	_C_LABEL(proc0),%a0	| save pointer to frame
	movl	%sp,%a0@@(P_MD_REGS)	|   in proc0.p_md.md_regs

	jra	_C_LABEL(main)		| main()
	PANIC("main() returned")
	/* NOTREACHED */

/*
 * proc_trampoline: call function in register a2 with a3 as an arg
 * and then rei.
 */
GLOBAL(proc_trampoline)
	movl	%a3,%sp@@-		| push function arg
	jbsr	%a2@@			| call function
	addql	#4,%sp			| pop arg
	movl	%sp@@(FR_SP),%a0		| grab and load
	movl	%a0,%usp		|   user SP
	moveml	%sp@@+,#0x7FFF		| restore most user regs
	addql	#8,%sp			| toss SP and stack adjust
	jra	_ASM_LABEL(rei)		| and return


/*
 * Trap/interrupt vector routines
 */
#include <m68k/m68k/trap_subr.s>

	.data
GLOBAL(m68k_fault_addr)
	.long	0

#if defined(M68040)
ENTRY_NOPROFILE(addrerr4060)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	movl	%sp@@(FR_HW+8),%sp@@-
	clrl	%sp@@-			| dummy code
	movl	#T_ADDRERR,%sp@@-	| mark address error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it

ENTRY_NOPROFILE(buserr40)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	movl	%sp@@(FR_HW+20),%d1	| get fault address
	moveq	#0,%d0
	movw	%sp@@(FR_HW+12),%d0	| get SSW
	btst	#11,%d0			| check for mis-aligned
	jeq	Lbe1stpg		| no skip
	addl	#3,%d1			| get into next page
	andl	#PG_FRAME,%d1		| and truncate
Lbe1stpg:
	movl	%d1,%sp@@-		| pass fault address.
	movl	%d0,%sp@@-		| pass SSW as code
	btst	#10,%d0			| test ATC
	jeq	Lberr40			| it is a bus error
	movl	#T_MMUFLT,%sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lberr40:
	tstl	_C_LABEL(nofault)	| catch bus error?
	jeq	Lisberr			| no, handle as usual
	movl	%sp@@(FR_HW+8+20),_C_LABEL(m68k_fault_addr) | save fault addr
	movl	_C_LABEL(nofault),%sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
#endif

#if defined(M68020) || defined(M68030)
ENTRY_NOPROFILE(busaddrerr2030)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	moveq	#0,%d0
	movw	%sp@@(FR_HW+10),%d0	| grab SSW for fault processing
	btst	#12,%d0			| RB set?
	jeq	LbeX0			| no, test RC
	bset	#14,%d0			| yes, must set FB
	movw	%d0,%sp@@(FR_HW+10)	| for hardware too
LbeX0:
	btst	#13,%d0			| RC set?
	jeq	LbeX1			| no, skip
	bset	#15,%d0			| yes, must set FC
	movw	%d0,%sp@@(FR_HW+10)	| for hardware too
LbeX1:
	btst	#8,%d0			| data fault?
	jeq	Lbe0			| no, check for hard cases
	movl	%sp@@(FR_HW+16),%d1	| fault address is as given in frame
	jra	Lbe10			| thats it
Lbe0:
	btst	#4,%sp@@(FR_HW+6)	| long (type B) stack frame?
	jne	Lbe4			| yes, go handle
	movl	%sp@@(FR_HW+2),%d1	| no, can use save PC
	btst	#14,%d0			| FB set?
	jeq	Lbe3			| no, try FC
	addql	#4,%d1			| yes, adjust address
	jra	Lbe10			| done
Lbe3:
	btst	#15,%d0			| FC set?
	jeq	Lbe10			| no, done
	addql	#2,%d1			| yes, adjust address
	jra	Lbe10			| done
Lbe4:
	movl	%sp@@(FR_HW+36),%d1	| long format, use stage B address
	btst	#15,%d0			| FC set?
	jeq	Lbe10			| no, all done
	subql	#2,%d1			| yes, adjust address
Lbe10:
	movl	%d1,%sp@@-		| push fault VA
	movl	%d0,%sp@@-		| and padded SSW
	movw	%sp@@(FR_HW+8+6),%d0	| get frame format/vector offset
	andw	#0x0FFF,%d0		| clear out frame format
	cmpw	#12,%d0			| address error vector?
	jeq	Lisaerr			| yes, go to it
	movl	%d1,%a0			| fault address
	movl	%sp@@,%d0		| function code from ssw
	btst	#8,%d0			| data fault?
	jne	Lbe10a
	movql	#1,%d0			| user program access FC
					| (we dont separate data/program)
	btst	#5,%sp@@(FR_HW+8)	| supervisor mode?
	jeq	Lbe10a			| if no, done
	movql	#5,%d0			| else supervisor program access
Lbe10a:
	ptestr	%d0,%a0@@,#7		| do a table search
	pmove	%psr,%sp@@		| save result
	movb	%sp@@,%d1
	btst	#2,%d1			| invalid (incl. limit viol. and berr)?
	jeq	Lmightnotbemerr		| no -> wp check
	btst	#7,%d1			| is it MMU table berr?
	jne	Lisberr1		| yes, needs not be fast.
Lismerr:
	movl	#T_MMUFLT,%sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lmightnotbemerr:
	btst	#3,%d1			| write protect bit set?
	jeq	Lisberr1		| no: must be bus error
	movl	%sp@@,%d0		| ssw into low word of d0
	andw	#0xc0,%d0		| Write protect is set on page:
	cmpw	#0x40,%d0		| was it read cycle?
	jne	Lismerr			| no, was not WPE, must be MMU fault
	jra	Lisberr1		| real bus err needs not be fast.
Lisaerr:
	movl	#T_ADDRERR,%sp@@-	| mark address error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lisberr1:
	clrw	%sp@@			| re-clear pad word
	tstl	_C_LABEL(nofault)	| catch bus error?
	jeq	Lisberr			| no, handle as usual
	movl	%sp@@(FR_HW+8+16),_C_LABEL(m68k_fault_addr) | save fault addr
	movl	_C_LABEL(nofault),%sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
#endif /* M68020 || M68030 */

Lisberr:				| also used by M68040/60
	movl	#T_BUSERR,%sp@@-		| mark bus error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it

/*
 * FP exceptions.
 */
ENTRY_NOPROFILE(fpfline)
#if defined(M68040)
	cmpl	#FPU_68040,_C_LABEL(fputype) | 68040 FPU?
	jne	Lfp_unimp		| no, skip FPSP
	cmpw	#0x202c,%sp@@(6)		| format type 2?
	jne	_C_LABEL(illinst)	| no, not an FP emulation
Ldofp_unimp:
#ifdef FPSP
	jmp	_ASM_LABEL(fpsp_unimp)	| yes, go handle it
#endif
Lfp_unimp:
#endif /* M68040 */
#ifdef FPU_EMULATE
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save registers
	moveq	#T_FPEMULI,%d0		| denote as FP emulation trap
	jra	_ASM_LABEL(fault)	| do it
#else
	jra	_C_LABEL(illinst)
#endif

ENTRY_NOPROFILE(fpunsupp)
#if defined(M68040)
	cmpl	#FPU_68040,_C_LABEL(fputype) | 68040 FPU?
	jne	_C_LABEL(illinst)	| no, treat as illinst
#ifdef FPSP
	jmp	_ASM_LABEL(fpsp_unsupp)	| yes, go handle it
#endif
Lfp_unsupp:
#endif /* M68040 */
#ifdef FPU_EMULATE
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save registers
	moveq	#T_FPEMULD,%d0		| denote as FP emulation trap
	jra	_ASM_LABEL(fault)	| do it
#else
	jra	_C_LABEL(illinst)
#endif

/*
 * Handles all other FP coprocessor exceptions.
 * Note that since some FP exceptions generate mid-instruction frames
 * and may cause signal delivery, we need to test for stack adjustment
 * after the trap call.
 */
ENTRY_NOPROFILE(fpfault)
	clrl	%sp@@-		| stack adjust count
	moveml	#0xFFFF,%sp@@-	| save user registers
	movl	%usp,%a0	| and save
	movl	%a0,%sp@@(FR_SP)	|   the user stack pointer
	clrl	%sp@@-		| no VA arg
	movl	_C_LABEL(curpcb),%a0 | current pcb
	lea	%a0@@(PCB_FPCTX),%a0 | address of FP savearea
	fsave	%a0@@		| save state
#if defined(M68040) || defined(M68060)
	/* always null state frame on 68040, 68060 */
	cmpl	#FPU_68040,_C_LABEL(fputype)
	jge	Lfptnull
#endif
	tstb	%a0@@		| null state frame?
	jeq	Lfptnull	| yes, safe
	clrw	%d0		| no, need to tweak BIU
	movb	%a0@@(1),%d0	| get frame size
	bset	#3,%a0@@(0,%d0:w) | set exc_pend bit of BIU
Lfptnull:
	fmovem	%fpsr,%sp@@-	| push fpsr as code argument
	frestore %a0@@		| restore state
	movl	#T_FPERR,%sp@@-	| push type arg
	jra	_ASM_LABEL(faultstkadj) | call trap and deal with stack cleanup

/*
 * Other exceptions only cause four and six word stack frame and require
 * no post-trap stack adjustment.
 */

ENTRY_NOPROFILE(badtrap)
	moveml	#0xC0C0,%sp@@-		| save scratch regs
	movw	%sp@@(22),%sp@@-		| push exception vector info
	clrw	%sp@@-
	movl	%sp@@(22),%sp@@-		| and PC
	jbsr	_C_LABEL(straytrap)	| report
	addql	#8,%sp			| pop args
	moveml	%sp@@+,#0x0303		| restore regs
	jra	_ASM_LABEL(rei)		| all done

ENTRY_NOPROFILE(trap0)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-		| save user registers
	movl	%usp,%a0		| save the user SP
	movl	%a0,%sp@@(FR_SP)		|   in the savearea
	movl	%d0,%sp@@-		| push syscall number
	jbsr	_C_LABEL(syscall)	| handle it
	addql	#4,%sp			| pop syscall arg
	tstl	_C_LABEL(astpending)
	jne	Lrei2
	tstl	_C_LABEL(softpending)
	jeq	Ltrap1
	movw	#SPL1,%sr
	tstl	_C_LABEL(softpending)
	jne	Lsir1
Ltrap1:
	movl	%sp@@(FR_SP),%a0		| grab and restore
	movl	%a0,%usp		|   user SP
	moveml	%sp@@+,#0x7FFF		| restore most registers
	addql	#8,%sp			| pop SP and stack adjust
	rte

/*
 * Trap 1 - sigreturn
 */
ENTRY_NOPROFILE(trap1)
	jra	_ASM_LABEL(sigreturn)

/*
 * Trap 2 - trace trap
 */
ENTRY_NOPROFILE(trap2)
	jra	_C_LABEL(trace)

/*
 * Trap 12 is the entry point for the cachectl "syscall"
 *	cachectl(command, addr, length)
 * command in d0, addr in a1, length in d1
 */
ENTRY_NOPROFILE(trap12)
	movl	%d1,%sp@@-		| push length
	movl	%a1,%sp@@-		| push addr
	movl	%d0,%sp@@-		| push command
	movl	CURPROC,%sp@@-		| push proc pointer
	jbsr	_C_LABEL(cachectl)	| do it
	lea	%sp@@(16),%sp		| pop args
	jra	_ASM_LABEL(rei)		| all done

/*
 * Trace (single-step) trap.  Kernel-mode is special.
 * User mode traps are simply passed on to trap().
 */
ENTRY_NOPROFILE(trace)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-
	moveq	#T_TRACE,%d0

	| Check PSW and see what happened.
	|   T=0 S=0	(should not happen)
	|   T=1 S=0	trace trap from user mode
	|   T=0 S=1	trace trap on a trap instruction
	|   T=1 S=1	trace trap from system mode (kernel breakpoint)

	movw	%sp@@(FR_HW),%d1		| get PSW
	notw	%d1			| XXX no support for T0 on 680[234]0
	andw	#PSL_TS,%d1		| from system mode (T=1, S=1)?
	jeq	Lkbrkpt			| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault

/*
 * Trap 15 is used for:
 *	- GDB breakpoints (in user programs)
 *	- KGDB breakpoints (in the kernel)
 *	- trace traps for SUN binaries (not fully supported yet)
 * User mode traps are simply passed to trap().
 */
ENTRY_NOPROFILE(trap15)
	clrl	%sp@@-			| stack adjust count
	moveml	#0xFFFF,%sp@@-
	moveq	#T_TRAP15,%d0
	movw	%sp@@(FR_HW),%d1		| get PSW
	andw	#PSL_S,%d1		| from system mode?
	jne	Lkbrkpt			| yes, kernel breakpoint
	jra	_ASM_LABEL(fault)	| no, user-mode fault

Lkbrkpt: | Kernel-mode breakpoint or trace trap. (d0=trap_type)
	| Save the system sp rather than the user sp.
	movw	#PSL_HIGHIPL,%sr	| lock out interrupts
	lea	%sp@@(FR_SIZE),%a6	| Save stack pointer
	movl	%a6,%sp@@(FR_SP)		|  from before trap

	| If we are not on tmpstk switch to it.
	| (so debugger can change the stack pointer)
	movl	%a6,%d1
	cmpl	#_ASM_LABEL(tmpstk),%d1
	jls	Lbrkpt2			| already on tmpstk
	| Copy frame to the temporary stack
	movl	%sp,%a0			| a0=src
	lea	_ASM_LABEL(tmpstk)-96,%a1 | a1=dst
	movl	%a1,%sp			| sp=new frame
	moveq	#FR_SIZE,%d1
Lbrkpt1:
	movl	%a0@@+,%a1@@+
	subql	#4,%d1
	bgt	Lbrkpt1

Lbrkpt2:
	| Call the trap handler for the kernel debugger.
	| Do not call trap() to do it, so that we can
	| set breakpoints in trap() if we want.  We know
	| the trap type is either T_TRACE or T_BREAKPOINT.
	| If we have both DDB and KGDB, let KGDB see it first,
	| because KGDB will just return 0 if not connected.
	| Save args in d2, a2
	movl	%d0,%d2			| trap type
	movl	%sp,%a2			| frame ptr
#ifdef KGDB
	| Let KGDB handle it (if connected)
	movl	%a2,%sp@@-		| push frame ptr
	movl	%d2,%sp@@-		| push trap type
	jbsr	_C_LABEL(kgdb_trap)	| handle the trap
	addql	#8,%sp			| pop args
	cmpl	#0,%d0			| did kgdb handle it?
	jne	Lbrkpt3			| yes, done
#endif
#ifdef DDB
	| Let DDB handle it
	movl	%a2,%sp@@-		| push frame ptr
	movl	%d2,%sp@@-		| push trap type
	jbsr	_C_LABEL(kdb_trap)	| handle the trap
	addql	#8,%sp			| pop args
#if 0	/* not needed on hp300 */
	cmpl	#0,%d0			| did ddb handle it?
	jne	Lbrkpt3			| yes, done
#endif
#endif
	/* Sun 3 drops into PROM here. */
Lbrkpt3:
	| The stack pointer may have been modified, or
	| data below it modified (by kgdb push call),
	| so push the hardware frame at the current sp
	| before restoring registers and returning.

	movl	%sp@@(FR_SP),%a0		| modified sp
	lea	%sp@@(FR_SIZE),%a1	| end of our frame
	movl	%a1@@-,%a0@@-		| copy 2 longs with
	movl	%a1@@-,%a0@@-		| ... predecrement
	movl	%a0,%sp@@(FR_SP)		| sp = h/w frame
	moveml	%sp@@+,#0x7FFF		| restore all but sp
	movl	%sp@@,%sp		| ... and sp
	rte				| all done

/*
 * Use common m68k sigreturn.
 */
#include <m68k/m68k/sigreturn.s>

/*
 * Interrupt handlers.
 * All device interrupts are auto-vectored.  The CPU provides
 * the vector 0x18+level.  Note we count spurious interrupts, but
 * we don't do anything else with them.
 */

#define INTERRUPT_SAVEREG	moveml	#0xC0C0,%sp@@-
#define INTERRUPT_RESTOREREG	moveml	%sp@@+,#0x0303

ENTRY_NOPROFILE(spurintr)	/* level 0 */
	addql	#1,_C_LABEL(uvmexp)+UVMEXP_INTRS
	jra	_ASM_LABEL(rei)

ENTRY_NOPROFILE(intrhand)	/* levels 2 through 5 */
	INTERRUPT_SAVEREG
	movw	%sp@@(22),%sp@@-		| push exception vector info
	clrw	%sp@@-
	jbsr	_C_LABEL(intr_dispatch)	| call dispatch routine
	addql	#4,%sp
	INTERRUPT_RESTOREREG
	jra	_ASM_LABEL(rei)		| all done

ENTRY_NOPROFILE(lev6intr)	/* level 6: clock */
	INTERRUPT_SAVEREG
	CLKADDR(%a0)
	movb	%a0@@(CLKSR),%d0		| read clock status
Lclkagain:
	btst	#0,%d0			| clear timer1 int immediately to
	jeq	Lnotim1			|  minimize chance of losing another
	movpw	%a0@@(CLKMSB1),%d1	|  due to statintr processing delay
	movl	_C_LABEL(clkint),%d1	| clkcounter += clkint
	addl	%d1,_C_LABEL(clkcounter)
Lnotim1:
	btst	#2,%d0			| timer3 interrupt?
	jeq	Lnotim3			| no, skip statclock
	movpw	%a0@@(CLKMSB3),%d1	| clear timer3 interrupt
	lea	%sp@@(16),%a1		| a1 = &clockframe
	movl	%d0,%sp@@-		| save status
	movl	%a1,%sp@@-
	jbsr	_C_LABEL(statintr)	| statintr(&frame)
	addql	#4,%sp
	movl	%sp@@+,%d0		| restore pre-statintr status
	CLKADDR(%a0)
Lnotim3:
	btst	#0,%d0			| timer1 interrupt?
	jeq	Lrecheck		| no, skip hardclock
	lea	%sp@@(16),%a1		| a1 = &clockframe
	movl	%a1,%sp@@-
#ifdef USELEDS
	tstl	_C_LABEL(ledaddr)	| using LEDs?
	jeq	Lnoleds0		| no, skip this code
	movl	_ASM_LABEL(heartbeat),%d0 | get tick count
	addql	#1,%d0			|  increment
	movl	_C_LABEL(hz),%d1
	addl	#50,%d1			| get the timing a little closer
	cmpl	#0,_ASM_LABEL(beatstatus) | time to slow down?
	jeq	Lslowthrob		  | yes, slow down
	lsrl	#3,%d1			| no, fast throb
Lslowthrob:
	lsrl	#1,%d1			| slow throb
	cmpl	%d0,%d1			| are we there yet?
	jne	Lnoleds1		| no, nothing to do
	addl	#1,_ASM_LABEL(beatstatus) | incr beat status
	cmpl	#3,_ASM_LABEL(beatstatus) | time to reset?
	ble	Ltwinkle		  | no, twinkle the lights
	movl	#0,_ASM_LABEL(beatstatus) | reset the status indicator
Ltwinkle:
	movl	#LED_PULSE,%sp@@-
	movl	#LED_DISK+LED_LANRCV+LED_LANXMT,%sp@@-
	clrl	%sp@@-
	jbsr	_C_LABEL(ledcontrol)	| toggle pulse, turn all others off
	lea	%sp@@(12),%sp
	movql	#0,%d0
Lnoleds1:
	movl	%d0,_ASM_LABEL(heartbeat)
Lnoleds0:
#endif /* USELEDS */
	jbsr	_C_LABEL(clockintr)	| clockintr(&frame)
	addql	#4,%sp
	CLKADDR(%a0)
Lrecheck:
	addql	#1,_C_LABEL(uvmexp)+UVMEXP_INTRS | chalk up another interrupt
	movb	%a0@@(CLKSR),%d0		| see if anything happened
	jmi	Lclkagain		|  while we were in clockintr/statintr
#if NAUDIO >0
	movw	%sp@@(22),%sp@@-		| push exception vector info
	clrw	%sp@@-
	jbsr	_C_LABEL(intr_dispatch)	| call dispatch routine
	addql	#4,%sp
#endif
	INTERRUPT_RESTOREREG
	jra	_ASM_LABEL(rei)		| all done

ENTRY_NOPROFILE(lev7intr)	/* level 7: parity errors, reset key */
	clrl	%sp@@-
	moveml	#0xFFFF,%sp@@-		| save registers
	movl	%usp,%a0		| and save
	movl	%a0,%sp@@(FR_SP)		|   the user stack pointer
	jbsr	_C_LABEL(nmihand)	| call handler
	movl	%sp@@(FR_SP),%a0		| restore
	movl	%a0,%usp		|   user SP
	moveml	%sp@@+,#0x7FFF		| and remaining registers
	addql	#8,%sp			| pop SP and stack adjust
	jra	_ASM_LABEL(rei)		| all done

/*
 * Emulation of VAX REI instruction.
 *
 * This code deals with checking for and servicing ASTs
 * (profiling, scheduling) and software interrupts (network, softclock).
 * We check for ASTs first, just like the VAX.  To avoid excess overhead
 * the T_ASTFLT handling code will also check for software interrupts so we
 * do not have to do it here.  After identifing that we need an AST we
 * drop the IPL to allow device interrupts.
 *
 * This code is complicated by the fact that sendsig may have been called
 * necessitating a stack cleanup.
 */

BSS(softpending,4)

ASENTRY_NOPROFILE(rei)
	tstl	_C_LABEL(astpending)	| AST pending?
	jeq	Lchksir			| no, go check for SIR
Lrei1:
	btst	#5,%sp@@			| yes, are we returning to user mode?
	jne	Lchksir			| no, go check for SIR
	movw	#PSL_LOWIPL,%sr		| lower SPL
	clrl	%sp@@-			| stack adjust
	moveml	#0xFFFF,%sp@@-		| save all registers
	movl	%usp,%a1		| including
	movl	%a1,%sp@@(FR_SP)		|    the users SP
Lrei2:
	clrl	%sp@@-			| VA == none
	clrl	%sp@@-			| code == none
	movl	#T_ASTFLT,%sp@@-		| type == async system trap
	jbsr	_C_LABEL(trap)		| go handle it
	lea	%sp@@(12),%sp		| pop value args
	movl	%sp@@(FR_SP),%a0		| restore user SP
	movl	%a0,%usp		|   from save area
	movw	%sp@@(FR_ADJ),%d0	| need to adjust stack?
	jne	Laststkadj		| yes, go to it
	moveml	%sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,%sp			| toss SP and stack adjust
	rte				| and do real RTE
Laststkadj:
	lea	%sp@@(FR_HW),%a1		| pointer to HW frame
	addql	#8,%a1			| source pointer
	movl	%a1,%a0			| source
	addw	%d0,%a0			|  + hole size = dest pointer
	movl	%a1@@-,%a0@@-		| copy
	movl	%a1@@-,%a0@@-		|  8 bytes
	movl	%a0,%sp@@(FR_SP)		| new SSP
	moveml	%sp@@+,#0x7FFF		| restore user registers
	movl	%sp@@,%sp		| and our SP
	rte				| and do real RTE
Lchksir:
	tstl	_C_LABEL(softpending)	| SIR pending?
	jeq	Ldorte			| no, all done
	movl	%d0,%sp@@-		| need a scratch register
	movw	%sp@@(4),%d0		| get SR
	andw	#PSL_IPL7,%d0		| mask all but IPL
	jne	Lnosir			| came from interrupt, no can do
	movl	%sp@@+,%d0		| restore scratch register
Lgotsir:
	movw	#SPL1,%sr		| prevent others from servicing int
	tstl	_C_LABEL(softpending)	| too late?
	jeq	Ldorte			| yes, oh well...
	clrl	%sp@@-			| stack adjust
	moveml	#0xFFFF,%sp@@-		| save all registers
	movl	%usp,%a1		| including
	movl	%a1,%sp@@(FR_SP)		|    the users SP
Lsir1:
	clrl	%sp@@-			| VA == none
	clrl	%sp@@-			| code == none
	movl	#T_SSIR,%sp@@-		| type == software interrupt
	jbsr	_C_LABEL(trap)		| go handle it
	lea	%sp@@(12),%sp		| pop value args
	movl	%sp@@(FR_SP),%a0		| restore
	movl	%a0,%usp		|   user SP
	moveml	%sp@@+,#0x7FFF		| and all remaining registers
	addql	#8,%sp			| pop SP and stack adjust
	rte
Lnosir:
	movl	%sp@@+,%d0		| restore scratch register
Ldorte:
	rte				| real return

/*
 * Use common m68k signal trampoline.
 */
#include <m68k/m68k/sigcode.s>

/*
 * Primitives
 */

/*
 * Use common m68k support routines.
 */
#include <m68k/m68k/support.s>

	.data
	.p2align 2
GLOBAL(curpcb)
	.long	0

ASBSS(nullpcb,SIZEOF_PCB)

ENTRY_NOPROFILE(cpu_idle_cycle)
	stop	#PSL_LOWIPL
	rts

/*
 * cpu_switchto(struct proc *oldproc, struct proc *newproc)
 *
 * NOTE: On the mc68851 (318/319/330) we attempt to avoid flushing the
 * entire ATC.  The effort involved in selective flushing may not be
 * worth it, maybe we should just flush the whole thing?
 *
 * NOTE 2: With the new VM layout we now no longer know if an inactive
 * user's PTEs have been changed (formerly denoted by the SPTECHG p_flag
 * bit).  For now, we just always flush the full ATC.
 */
ENTRY(cpu_switchto)
	movl	%sp@@(4), %d0		| oldproc
	beq	Lswnofpsave		| is NULL, don't save anything

	/*
	 * Save state of previous process in its pcb.
	 */
	movl	_C_LABEL(curpcb),%a1
	movw	%sr, %a1@@(PCB_PS)	| save sr before switching context
	moveml	#0xFCFC,%a1@@(PCB_REGS)	| save non-scratch registers
	movl	%usp,%a2		| grab USP (a2 has been saved)
	movl	%a2,%a1@@(PCB_USP)	| and save it

	tstl	_C_LABEL(fputype)	| Do we have an FPU?
	jeq	Lswnofpsave		| No  Then don't attempt save.
	lea	%a1@@(PCB_FPCTX),%a2	| pointer to FP save area
	fsave	%a2@@			| save FP state
	tstb	%a2@@			| null state frame?
	jeq	Lswnofpsave		| yes, all done
	fmovem	%fp0-%fp7,%a2@@(FPF_REGS)	| save FP general registers
	fmovem	%fpcr/%fpsr/%fpi,%a2@@(FPF_FPCR)	| save FP control registers

Lswnofpsave:
	movl	%sp@@(8), %a0		| newproc

	movl	%a0, CURPROC
	movb	#SONPROC,%a0@@(P_STAT)
	movl	%a0@@(P_ADDR),%a1	| get p_addr
	movl	%a1,_C_LABEL(curpcb)

	/*
	 * Activate process's address space.
	 * XXX Should remember the last USTP value loaded, and call this
	 * XXX only if it has changed.
	 */
	pea	%a0@@			| push proc
	jbsr	_C_LABEL(pmap_activate)	| pmap_activate(p)
	addql	#4,%sp
	movl	_C_LABEL(curpcb),%a1	| restore p_addr

	lea	_ASM_LABEL(tmpstk),%sp	| now goto a tmp stack for NMI

	moveml	%a1@@(PCB_REGS),#0xFCFC	| and registers
	movl	%a1@@(PCB_USP),%a0
	movl	%a0,%usp		| and USP

	tstl	_C_LABEL(fputype)	| If we don't have an FPU,
	jeq	Lnofprest		|  don't try to restore it.
	lea	%a1@@(PCB_FPCTX),%a0	| pointer to FP save area
	tstb	%a0@@			| null state frame?
	jeq	Lresfprest		| yes, easy
#if defined(M68040)
#if defined(M68020) || defined(M68030)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	Lresnot040		| no, skip
#endif
	clrl	%sp@@-			| yes...
	frestore %sp@@+			| ...magic!
Lresnot040:
#endif
	fmovem	%a0@@(FPF_FPCR),%fpcr/%fpsr/%fpi	| restore FP control registers
	fmovem	%a0@@(FPF_REGS),%fp0-%fp7	| restore FP general registers
Lresfprest:
	frestore %a0@@			| restore state

Lnofprest:
	movw	%a1@@(PCB_PS),%sr	| no, restore PS
	moveq	#1,%d0			| return 1 (for alternate returns)
	rts

/*
 * savectx(pcb)
 * Update pcb, saving current processor state.
 */
ENTRY(savectx)
	movl	%sp@@(4),%a1
	movw	%sr,%a1@@(PCB_PS)
	movl	%usp,%a0		| grab USP
	movl	%a0,%a1@@(PCB_USP)	| and save it
	moveml	#0xFCFC,%a1@@(PCB_REGS)	| save non-scratch registers

	tstl	_C_LABEL(fputype)	| Do we have FPU?
	jeq	Lsvnofpsave		| No?  Then don't save state.
	lea	%a1@@(PCB_FPCTX),%a0	| pointer to FP save area
	fsave	%a0@@			| save FP state
	tstb	%a0@@			| null state frame?
	jeq	Lsvnofpsave		| yes, all done
	fmovem	%fp0-%fp7,%a0@@(FPF_REGS)	| save FP general registers
	fmovem	%fpcr/%fpsr/%fpi,%a0@@(FPF_FPCR)	| save FP control registers
Lsvnofpsave:
	moveq	#0,%d0			| return 0
	rts

#if defined(M68040)
ENTRY(suline)
	movl	%sp@@(4),%a0		| address to write
	movl	_C_LABEL(curpcb),%a1	| current pcb
	movl	#Lslerr,%a1@@(PCB_ONFAULT) | where to return to on a fault
	movl	%sp@@(8),%a1		| address of line
	movl	%a1@@+,%d0		| get lword
	movsl	%d0,%a0@@+		| put lword
	nop				| sync
	movl	%a1@@+,%d0		| get lword
	movsl	%d0,%a0@@+		| put lword
	nop				| sync
	movl	%a1@@+,%d0		| get lword
	movsl	%d0,%a0@@+		| put lword
	nop				| sync
	movl	%a1@@+,%d0		| get lword
	movsl	%d0,%a0@@+		| put lword
	nop				| sync
	moveq	#0,%d0			| indicate no fault
	jra	Lsldone
Lslerr:
	moveq	#-1,%d0
Lsldone:
	movl	_C_LABEL(curpcb),%a1	| current pcb
	clrl	%a1@@(PCB_ONFAULT) 	| clear fault address
	rts
#endif

/*
 * Invalidate entire TLB.
 */
ASENTRY_NOPROFILE(TBIA)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	Lmotommu3		| no, skip
	.chip	68040
	pflusha
	rts
Lmotommu3:
	.chip	68020
#endif
	pflusha				| flush entire TLB
	tstl	_C_LABEL(mmutype)
	jpl	Lmc68851a		| 68851 implies no d-cache
	movl	#DC_CLEAR,%d0
	movc	%d0,%cacr		| invalidate on-chip d-cache
Lmc68851a:
	rts

/*
 * Invalidate any TLB entry for given VA (TB Invalidate Single)
 */
ENTRY(TBIS)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	Lmotommu4		| no, skip
	.chip	68040
	movl	%sp@@(4),%a0
	movc	%dfc,%d1
	moveq	#FC_USERD,%d0		| user space
	movc	%d0,%dfc
	pflush	%a0@@
	moveq	#FC_SUPERD,%d0		| super space
	movc	%d0,%dfc
	pflush	%a0@@
	movc	%d1,%dfc
	rts
	.chip	68020
Lmotommu4:
#endif
	movl	%sp@@(4),%a0		| get addr to flush
	tstl	_C_LABEL(mmutype)
	jpl	Lmc68851b		| is 68851?
	pflush	#0,#0,%a0@@		| flush address from both sides
	movl	#DC_CLEAR,%d0
	movc	%d0,%cacr		| invalidate on-chip data cache
	rts
Lmc68851b:
	pflushs	#0,#0,%a0@@		| flush address from both sides
	rts

/*
 * Invalidate instruction cache
 */
ENTRY(ICIA)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jne	Lmotommu7		| no, skip
	.chip	68040
	cinva	%ic
	rts
	.chip	68020
Lmotommu7:
#endif
	movl	#IC_CLEAR,%d0
	movc	%d0,%cacr		| invalidate i-cache
	rts

/*
 * Invalidate data cache.
 * HP external cache allows for invalidation of user/supervisor portions.
 * NOTE: we do not flush 68030 on-chip cache as there are no aliasing
 * problems with DC_WA.  The only cases we have to worry about are context
 * switch and TLB changes, both of which are handled "in-line" in resume
 * and TBI*.
 */
ENTRY(DCIA)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jne	Lmotommu8		| no, skip
	.chip	68040
	cpusha	%dc
	rts
	.chip	68020
Lmotommu8:
#endif
	rts

ENTRY(DCIS)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jne	Lmotommu9		| no, skip
	.chip	68040
	cpusha	%dc
	rts
	.chip	68020
Lmotommu9:
#endif
	rts

ENTRY(DCIU)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jne	LmotommuA		| no, skip
	.chip	68040
	cpusha	%dc
	rts
	.chip	68020
LmotommuA:
#endif
	rts

#if defined(M68040) || defined(CACHE_HAVE_PAC)
ENTRY(PCIA)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jne	LmotommuB		| no, skip
	.chip	68040
	cpusha	%dc
	rts
	.chip	68020
LmotommuB:
#endif
#if defined(CACHE_HAVE_PAC)
	/*
	 * On non-68040 machines, PCIA() will only get invoked if
	 * ectype == EC_PHYS, thus we do not need to test anything.
	 */
	movl	#DC_CLEAR,%d0
	movc	%d0,%cacr		| invalidate on-chip d-cache
	MMUADDR(%a0)
	andl	#~MMU_CEN,%a0@@(MMUCMD)	| disable cache in MMU control reg
	orl	#MMU_CEN,%a0@@(MMUCMD)	| reenable cache in MMU control reg
	rts
#endif
#endif

#if defined(M68040)
	.chip	68040
ENTRY(ICPA)
	cinva	%ic
	rts
ENTRY(DCFA)
	cpusha	%dc
	rts
ENTRY(ICPL)
	movl	%sp@@(4),%a0		| address
	cinvl	%ic,%a0@@
	rts
ENTRY(ICPP)
	movl	%sp@@(4),%a0		| address
	cinvp	%ic,%a0@@
	rts
ENTRY(DCPL)
	movl	%sp@@(4),%a0		| address
	cinvl	%dc,%a0@@
	rts
ENTRY(DCPP)
	movl	%sp@@(4),%a0		| address
	cinvp	%dc,%a0@@
	rts
ENTRY(DCFL)
	movl	%sp@@(4),%a0		| address
	cpushl	%dc,%a0@@
	rts
ENTRY(DCFP)
	movl	%sp@@(4),%a0		| address
	cpushp	%dc,%a0@@
	rts
	.chip	68020
#endif

ENTRY(ecacheon)
	tstl	_C_LABEL(ectype)
	jeq	Lnocache7
	MMUADDR(%a0)
	orl	#MMU_CEN,%a0@@(MMUCMD)
Lnocache7:
	rts

ENTRY(ecacheoff)
	tstl	_C_LABEL(ectype)
	jeq	Lnocache8
	MMUADDR(%a0)
	andl	#~MMU_CEN,%a0@@(MMUCMD)
Lnocache8:
	rts

ENTRY_NOPROFILE(getsfc)
	movc	%sfc,%d0
	rts

ENTRY_NOPROFILE(getdfc)
	movc	%dfc,%d0
	rts

/*
 * Load a new user segment table pointer.
 */
ENTRY(loadustp)
	movl	%sp@@(4),%d0		| new USTP
	moveq	#PGSHIFT,%d1
	lsll	%d1,%d0			| convert to addr
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	LmotommuC		| no, skip
	.chip	68040
	pflusha
	movc	%d0,%urp
	rts
	.chip	68020
LmotommuC:
#endif
	pflusha				| flush entire TLB
	lea	_ASM_LABEL(protorp),%a0	| CRP prototype
	movl	%d0,%a0@@(4)		| stash USTP
	pmove	%a0@@,%crp		| load root pointer
	movl	#CACHE_CLR,%d0
	movc	%d0,%cacr		| invalidate cache(s)
	rts

/*
 * Set processor priority level calls.  Most are implemented with
 * inline asm expansions.  However, spl0 requires special handling
 * as we need to check for our emulated software interrupts.
 */

ENTRY(spl0)
	moveq	#0,%d0
	movw	%sr,%d0			| get old SR for return
	movw	#PSL_LOWIPL,%sr		| restore new SR
	tstl	_C_LABEL(softpending)	| software interrupt pending?
	jeq	Lspldone		| no, all done
	subql	#4,%sp			| make room for RTE frame
	movl	%sp@@(4),%sp@@(2)		| position return address
	clrw	%sp@@(6)			| set frame type 0
	movw	#PSL_LOWIPL,%sp@@	| and new SR
	jra	Lgotsir			| go handle it
Lspldone:
	rts

/*
 * _delay(u_int N)
 *
 * Delay for at least (N/256) microseconds.
 * This routine depends on the variable:  delay_divisor
 * which should be set based on the CPU clock rate.
 */
ENTRY_NOPROFILE(_delay)
	| d0 = arg = (usecs << 8)
	movl	%sp@@(4),%d0
	| d1 = delay_divisor
	movl	_C_LABEL(delay_divisor),%d1
	jra	L_delay			/* Jump into the loop! */

	/*
	 * Align the branch target of the loop to a half-line (8-byte)
	 * boundary to minimize cache effects.  This guarantees both
	 * that there will be no prefetch stalls due to cache line burst
	 * operations and that the loop will run from a single cache
	 * half-line.
	 */
	.balign	8
L_delay:
	subl	%d1,%d0
	jgt	L_delay
	rts

/*
 * Save and restore 68881 state.
 */
ENTRY(m68881_save)
	movl	%sp@@(4),%a0		| save area pointer
	fsave	%a0@@			| save state
	tstb	%a0@@			| null state frame?
	jeq	Lm68881sdone		| yes, all done
	fmovem	%fp0-%fp7,%a0@@(FPF_REGS)	| save FP general registers
	fmovem	%fpcr/%fpsr/%fpi,%a0@@(FPF_FPCR)	| save FP control registers
Lm68881sdone:
	rts

ENTRY(m68881_restore)
	movl	%sp@@(4),%a0		| save area pointer
	tstb	%a0@@			| null state frame?
	jeq	Lm68881rdone		| yes, easy
	fmovem	%a0@@(FPF_FPCR),%fpcr/%fpsr/%fpi	| restore FP control registers
	fmovem	%a0@@(FPF_REGS),%fp0-%fp7	| restore FP general registers
Lm68881rdone:
	frestore %a0@@			| restore state
	rts

/*
 * Probe a memory address, and see if it causes a bus error.
 * This function is only to be used in physical mode, and before our
 * trap vectors are initialized.
 * Invoke with address to probe in a0.
 * Alters: a3 d0 d1
 */
#define	BUSERR	0xfffffffc
ASLOCAL(phys_badaddr)
	ASRELOC(_bsave,%a3)
	movl	BUSERR,%a3@@		| save ROM bus errror handler
	ASRELOC(_ssave,%a3)
	movl	%sp,%a3@@		| and current stack pointer
	ASRELOC(catchbad,%a3)
	movl	%a3,BUSERR		| plug in our handler
	movw	%a0@@,%d1		| access address
	ASRELOC(_bsave,%a3)		| no fault!
	movl	%a3@@,BUSERR
	clrl	%d0			| return success
	rts
ASLOCAL(catchbad)
	ASRELOC(_bsave,%a3)		| got a bus error, so restore handler
	movl	%a3@@,BUSERR
	ASRELOC(_ssave,%a3)
	movl	%a3@@,%sp		| and stack
	moveq	#1,%d0			| return fault
	rts
#undef	BUSERR

	.data
	.p2align 2
ASLOCAL(_bsave)
	.long	0
ASLOCAL(_ssave)
	.long	0
	.text

/*
 * Handle the nitty-gritty of rebooting the machine.
 * Basically we just turn off the MMU and jump to the appropriate ROM routine.
 * Note that we must be running in an address range that is mapped one-to-one
 * logical to physical so that the PC is still valid immediately after the MMU
 * is turned off.  We have conveniently mapped the last page of physical
 * memory this way.
 */
ENTRY_NOPROFILE(doboot)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jeq	Lnocache5		| yes, skip
#endif
	movl	#CACHE_OFF,%d0
	movc	%d0,%cacr		| disable on-chip cache(s)
	tstl	_C_LABEL(ectype)	| external cache?
	jeq	Lnocache5		| no, skip
	MMUADDR(%a0)
	andl	#~MMU_CEN,%a0@@(MMUCMD)	| disable external cache
Lnocache5:
	lea	MAXADDR,%a0		| last page of physical memory
	movl	_C_LABEL(boothowto),%a0@@+ | store howto
	movl	_C_LABEL(bootdev),%a0@@+	| and devtype
	lea	Lbootcode,%a1		| start of boot code
	lea	Lebootcode,%a3		| end of boot code
Lbootcopy:
	movw	%a1@@+,%a0@@+		| copy a word
	cmpl	%a3,%a1			| done yet?
	jcs	Lbootcopy		| no, keep going
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	LmotommuE		| no, skip
	.chip	68040
	cpusha	%bc
LmotommuE:
	.chip	68020
#endif
	jmp	MAXADDR+8		| jump to last page

Lbootcode:
	lea	MAXADDR+0x800,%sp	| physical SP in case of NMI
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	LmotommuF		| no, skip
	.chip	68040
	movl	#0,%d0
	movc	%d0,%cacr		| caches off
	movc	%d0,%tc
	movl	%d2,MAXADDR+NBPG-4	| restore old high page contents
	DOREBOOT
	.chip	68020
LmotommuF:
#endif
	movl	#0,%a0@@			| value for pmove to TC (turn off MMU)
	pmove	%a0@@,%tc		| disable MMU
	DOREBOOT
Lebootcode:

/*
 * Misc. global variables.
 */
	.data
	.p2align 2
GLOBAL(machineid)
	.long	-1		| default to unknown

GLOBAL(mmuid)
	.long	0		| default to nothing

GLOBAL(mmutype)
	.long	0		| default to unknown

GLOBAL(cputype)
	.long	CPU_68020	| default to 68020 CPU

GLOBAL(ectype)
	.long	EC_NONE		| external cache type, default to none

GLOBAL(fputype)
	.long	FPU_68882	| default to 68882 FPU

ASLOCAL(protorp)
	.long	0,0		| prototype root pointer

ASLOCAL(mmuscratch)
	.long	0		| scratch space for 68851/68030 MMU operation

GLOBAL(internalhpib)
	.long	1		| has internal HP-IB, default to yes

GLOBAL(cold)
	.long	1		| cold start flag

GLOBAL(want_resched)
	.long	0

GLOBAL(proc0paddr)
	.long	0		| KVA of proc0 u-area

GLOBAL(intiobase)
	.long	0		| KVA of base of internal IO space

GLOBAL(intiolimit)
	.long	0		| KVA of end of internal IO space

GLOBAL(extiobase)
	.long	0		| KVA of base of external IO space

GLOBAL(eiomapsize)
	.long	0		| size of external IO space in pages

GLOBAL(CLKbase)
	.long	0		| KVA of base of clock registers

GLOBAL(MMUbase)
	.long	0		| KVA of base of HP MMU registers

#ifdef USELEDS
ASLOCAL(heartbeat)
	.long	0		| clock ticks since last pulse of heartbeat

ASLOCAL(beatstatus)
	.long	0		| for determining a fast or slow throb
#endif
@


1.73
log
@Fix non-traditional cpp mode for real.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.72 2013/06/23 20:15:52 miod Exp $	*/
@


1.72
log
@Fix RELOC() in the __STDC__ case.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.71 2013/02/02 13:34:29 miod Exp $	*/
d117 5
a121 2
#define	_RELOC(var, ar)			\
	movel	var,ar;		\
a126 2
#endif

d129 1
@


1.71
log
@hp300 ELF bits. Requires many device and prom related structs to now be declared
as packed due to them containing 32-bit types at 16-bit but not 32-bit aligned
offsets. The boot block updates (especially mkboot) come straight from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.70 2012/09/08 19:24:28 miod Exp $	*/
d118 1
a118 1
	movel	# var,ar;		\
@


1.70
log
@Switch hp300 to timecounters. From NetBSD via martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.69 2012/01/22 13:13:06 miod Exp $	*/
d92 1
d116 9
a124 3
#define	_RELOC(var, ar)		\
	lea	var,ar;		\
	addl	a5,ar
d135 2
a136 2
	movl	#0,d0;						\
	movc	d0,vbr;						\
d154 9
a162 13
	movw	#PSL_HIGHIPL,sr		| no interrupts
	ASRELOC(tmpstk, a0)
	movl	a0,sp			| give ourselves a temporary stack
	RELOC(esym, a0)
#if 1
	movl	a4,a0@@			| store end of symbol table
#else
	clrl	a0@@			| no symbol table, yet
#endif
	RELOC(lowram, a0)
	movl	a5,a0@@			| store start of physical memory
	movl	#CACHE_OFF,d0
	movc	d0,cacr			| clear and disable on-chip cache(s)
d165 1
a165 1
	btst	#5,SYSFLAG			| internal HP-IB?
d167 2
a168 2
	RELOC(internalhpib, a0)
	movl	#0,a0@@			| no, clear associated address
d171 4
a174 4
	RELOC(boothowto, a0)		| save reboot flags
	movl	d7,a0@@
	RELOC(bootdev, a0)		|   and boot device
	movl	d6,a0@@
d183 5
a187 5
	movl	#INTIOBASE+MMUBASE,a1
	movl	#0x200,d0		| data freeze bit
	movc	d0,cacr			|   only exists on 68030
	movc	cacr,d0			| read it back
	tstl	d0			| zero?
d194 8
a201 8
	RELOC(mmutype, a0)		| no, we have 68030
	movl	#MMU_68030,a0@@		| set to reflect 68030 PMMU
	RELOC(cputype, a0)
	movl	#CPU_68030,a0@@		| and 68030 CPU
	RELOC(machineid, a0)
	movl	#0x80,a1@@(MMUCMD)	| set magic cookie
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#7,d0			| cookie still on?
d203 3
a205 3
	movl	#0,a1@@(MMUCMD)		| clear magic cookie
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#7,d0			| still on?
d207 1
a207 1
	movl	#HP_340,a0@@		| yes, must be a 340
d210 4
a213 4
	movl	#HP_36X,a0@@		| type is at least a 360
	movl	#0,a1@@(MMUCMD)		| clear magic cookie2
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#16,d0			| still on?
d215 6
a220 6
	RELOC(mmuid, a0)		| save MMU ID
	lsrl	#MMUID_SHIFT,d0
	andl	#MMUID_MASK,d0
	movl	d0,a0@@
	RELOC(machineid, a0)
	cmpb	#MMUID_345,d0		| are we a 345?
d222 1
a222 1
	cmpb	#MMUID_375,d0		| how about a 375?
d224 1
a224 1
	movl	#HP_400,a0@@		| must be a 400
d227 1
a227 1
	movl	#HP_345,a0@@
d230 1
a230 1
	movl	#HP_375,a0@@
d233 1
a233 1
	movl	#HP_370,a0@@		| set to 370
d235 2
a236 2
	RELOC(ectype, a0)
	movl	#EC_PHYS,a0@@		| also has a physical address cache
d244 4
a247 4
	bset	#31,d0			| data cache enable bit
	movc	d0,cacr			|   only exists on 68040
	movc	cacr,d0			| read it back
	tstl	d0			| zero?
d249 2
a250 2
	moveq	#CACHE40_OFF,d0		| now turn it back off
	movec	d0,cacr			|   before we access any data
d256 15
a270 15
	RELOC(mmutype, a0)
	movl	#MMU_68040,a0@@		| with a 68040 MMU
	RELOC(cputype, a0)
	movl	#CPU_68040,a0@@		| and a 68040 CPU
	RELOC(fputype, a0)
	movl	#FPU_68040,a0@@		| ...and FPU
	RELOC(ectype, a0)
	movl	#EC_NONE,a0@@		| and no cache (for now XXX)
	RELOC(mmuid, a0)
	movl	a1@@(MMUCMD),d0		| read MMU register
	lsrl	#MMUID_SHIFT,d0
	andl	#MMUID_MASK,d0
	movl	d0,a0@@			| save MMU ID
	RELOC(machineid, a0)
	cmpb	#MMUID_425_T,d0		| are we a 425t?
d272 1
a272 1
	cmpb	#MMUID_425_S,d0		| how about 425s?
d274 1
a274 1
	cmpb	#MMUID_425_E,d0		| or maybe a 425e?
d276 1
a276 1
	cmpb	#MMUID_433_T,d0		| or a 433t?
d278 1
a278 1
	cmpb	#MMUID_433_S,d0		| maybe a 433s?
d280 1
a280 1
	cmpb	#MMUID_385,d0		| then a 385?
d282 1
a282 1
	cmpb	#MMUID_382,d0		| last chance...
d284 1
a284 1
	movl	#HP_380,a0@@		| guess we're a 380
d287 1
a287 1
	movl	#HP_425,a0@@
d290 1
a290 1
	movl	#HP_433,a0@@
d293 1
a293 1
	movl	#HP_385,a0@@
d296 1
a296 1
	movl	#HP_382,a0@@
d308 5
a312 5
	RELOC(fputype, a0)		| all of the 68020 systems
	movl	#FPU_68881,a0@@		|   have a 68881 FPU
	movl	#1,a1@@(MMUCMD)		| a 68020, write HP MMU location
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#0,d0			| non-zero?
d314 4
a317 4
	RELOC(mmutype, a0)
	movl	#MMU_68851,a0@@		| no, we have PMMU
	RELOC(machineid, a0)
	movl	#HP_330,a0@@		| and 330 CPU
d340 1
a340 1
	clrl	d3
d346 1
a346 1
	addl	#(DIO_DEVSIZE * 32), d3
d352 4
a355 4
	movl	#GRFIADDR, a0
	ASRELOC(phys_badaddr, a3)
	jbsr	a3@@
	tstl	d0			| success?
d357 2
a358 2
	movl	#0x200000, d1		| yes, add the 200000-400000 range
	addl	d1, d3
d364 2
a365 2
	RELOC(machineid,a0)
	cmpl	#HP_320,a0@@
d368 2
a369 2
	movl	#DIOII_SCBASE, d2	| our select code...
	movl	#DIOII_BASE, a0		| and first address
d371 4
a374 4
	ASRELOC(phys_badaddr, a3)
	jbsr	a3@@			| probe address (read ID)
	movl	#DIOII_DEVSIZE, d1
	tstl	d0			| success?
d376 1
a376 1
	addl	d1, d3			| yes, count it
d378 3
a380 3
	addl	d1, a0			| next slot address...
	addql	#1, d2			| and slot number
	cmpl	#256, d2
d388 2
a389 2
	RELOC(machineid,a0)
	cmpl	#HP_400,a0@@
d391 1
a391 1
	cmpl	#HP_425,a0@@
d393 1
a393 1
	cmpl	#HP_433,a0@@
d396 2
a397 2
	clrl	d2			| first slot...
	movl	#SGC_BASE, a0		| and first address
d399 4
a402 4
	ASRELOC(phys_badaddr, a3)
	jbsr	a3@@			| probe address
	movl	#SGC_DEVSIZE, d1
	tstl	d0			| success?
d404 1
a404 1
	addl	d1, d3			| yes, count it
d406 3
a408 3
	addl	d1, a0			| next slot address...
	addql	#1, d2			| and slot number
	cmpl	#SGC_NSLOTS, d2
d413 5
a417 5
	moveq	#PGSHIFT, d2
	lsrl	d2, d3			| convert from bytes to pages
	RELOC(eiomapsize,a2)
	addql	#1, d3			| add an extra page for device probes
	movl	d3,a2@@
d426 2
a427 8
	RELOC(cputype, a0)
#if 0
	/* XXX assembler/linker feature/bug */
	RELOC(vectab, a2)
#else
	movl	#_C_LABEL(vectab),a2
	addl	a5,a2
#endif
d429 1
a429 1
	cmpl	#CPU_68040,a0@@		| 68040?
d431 2
a432 2
	movl	#_C_LABEL(buserr40),a2@@(8)
	movl	#_C_LABEL(addrerr4060),a2@@(12)
d437 1
a437 1
	cmpl	#CPU_68040,a0@@		| 68040?
d439 2
a440 2
	movl	#_C_LABEL(busaddrerr2030),a2@@(8)
	movl	#_C_LABEL(busaddrerr2030),a2@@(12)
d450 3
a452 3
	moveq	#FC_USERD,d0		| user space
	movc	d0,sfc			|   as source
	movc	d0,dfc			|   and destination of transfers
d454 6
a459 6
	movl	#MAXADDR,d1		| last page
	movl	a5,d0			| lowram value from ROM via boot
	moveq	#PGSHIFT,d2
	subl	d0,d1			| compute amount of RAM present
	lsrl	d2,d1			| convert to pages
	addl	#3,d1			| restore the 3 pages lost (2 from
d461 2
a462 2
	RELOC(physmem, a0)
	movl	d1,a0@@			| save as physmem
d466 2
a467 2
	RELOC(esym,a0)			| end of static kernel test/data/syms
	movl	a0@@,d5
d470 1
a470 1
	movl	#_C_LABEL(end),d5	| end of static kernel text/data
d472 9
a480 9
	addl	#NBPG-1,d5
	andl	#PG_FRAME,d5		| round to a page
	movl	d5,a4
	addl	a5,a4			| convert to PA
	pea	a5@@			| firstpa
	pea	a4@@			| nextpa
	RELOC(pmap_bootstrap,a0)
	jbsr	a0@@			| pmap_bootstrap(firstpa, nextpa)
	addql	#8,sp
d488 2
a489 2
	RELOC(mmutype, a0)
	cmpl	#MMU_68040,a0@@
d491 3
a493 3
	RELOC(copypage040, a0)
	RELOC(copypage, a1)
	movl	a1, a2
d495 2
a496 2
	movw	a0@@+, a2@@+
	cmpl	a0, a1
d510 5
a514 5
	RELOC(Sysseg, a0)		| system segment table addr
	movl	a0@@,d1			| read value (a KVA)
	addl	a5,d1			| convert to PA
	RELOC(mmutype, a0)
	cmpl	#MMU_68040,a0@@		| 68040?
d516 3
a518 1
	.long	0x4e7b1807		| movc d1,srp
d521 5
a525 5
	ASRELOC(protorp, a0)
	movl	#0x80000202,a0@@		| nolimit + share global + 4 byte PTEs
	movl	d1,a0@@(4)		| + segtable address
	pmove	a0@@,srp			| load the supervisor root pointer
	movl	#0x80000002,a0@@		| reinit upper half for CRP loads
d528 3
a530 3
	lea	MAXADDR,a2		| PA of last RAM page
	ASRELOC(Lhighcode, a1)		| addr of high code
	ASRELOC(Lehighcode, a3)		| end addr
d532 2
a533 2
	movw	a1@@+,a2@@+		| copy a word
	cmpl	a3,a1			| done yet?
d548 2
a549 2
	movl	#_C_LABEL(vectab),d0	| set Vector Base Register
	movc	d0,vbr
d551 2
a552 2
	RELOC(mmutype, a0)
	cmpl	#MMU_68040,a0@@		| 68040?
d554 1
d558 4
a561 4
	moveq	#0,d0			| ensure TT regs are disabled
	.long	0x4e7b0004		| movc d0,itt0
	.long	0x4e7b0005		| movc d0,itt1
	.long	0x4e7b0007		| movc d0,dtt1
d570 2
a571 2
	movl	#0xc03fa020,d0
	.long	0x4e7b0006		| movc d0,dtt0
d573 8
a580 7
	.word	0xf4d8			| cinva bc
	.word	0xf518			| pflusha
	movl	#0x8000,d0
	.long	0x4e7b0003		| movc d0,tc
	movl	#CACHE40_ON,d0
	movc	d0,cacr			| turn on both caches
	jmp	Lenab1
d582 1
a582 1
	cmpl	#MMU_68030,a0@@		| 68030?
d584 1
d589 4
a592 3
	ASRELOC(mmuscratch, a2)
	movl	#0xc03f8150,a2@@		| build our TT0 value
	.long	0xf0120800		| pmove a2@@,tt0
d596 4
a599 4
	ASRELOC(mmuscratch, a2)
	movl	#0x82c0aa00,a2@@		| value to load TC with
	pmove	a2@@,tc			| load it
	jmp	Lenab1
d611 2
a612 2
	lea	_ASM_LABEL(tmpstk),sp	| temporary stack
	jbsr	_C_LABEL(uvm_setpagesize)  | select software page size
d614 7
a620 7
	movl	_C_LABEL(proc0paddr),a1	| get proc0 pcb addr
	lea	a1@@(USPACE-4),sp	| set kernel stack to end of area
	lea	_C_LABEL(proc0),a2	| initialize proc0.p_addr so that
	movl	a1,a2@@(P_ADDR)		|   we don't deref NULL in trap()
	movl	#USRSTACK-4,a2
	movl	a2,usp			| init user SP
	movl	a1,_C_LABEL(curpcb)	| proc0 is running
d624 2
a625 2
	clrl	a1@@(PCB_FPCTX)		| ensure null FP context
	movl	a1,sp@@-
d627 1
a627 1
	addql	#4,sp
d633 2
a634 2
	movl	#CACHE_ON,d0
	movc	d0,cacr			| clear cache(s)
d637 2
a638 2
	MMUADDR(a0)
	orl	#MMU_CEN,a0@@(MMUCMD)	| turn on external cache
d648 7
a654 7
	clrw	sp@@-			| vector offset/frame type
	clrl	sp@@-			| PC - filled in by "execve"
	movw	#PSL_USER,sp@@-		| in user mode
	clrl	sp@@-			| stack adjust count and padding
	lea	sp@@(-64),sp		| construct space for D0-D7/A0-A7
	lea	_C_LABEL(proc0),a0	| save pointer to frame
	movl	sp,a0@@(P_MD_REGS)	|   in proc0.p_md.md_regs
d665 7
a671 7
	movl	a3,sp@@-			| push function arg
	jbsr	a2@@			| call function
	addql	#4,sp			| pop arg
	movl	sp@@(FR_SP),a0		| grab and load
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most user regs
	addql	#8,sp			| toss SP and stack adjust
d684 1
a684 1
#if defined(M68040) || defined(M68060)
d686 7
a692 7
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	sp@@(FR_HW+8),sp@@-
	clrl	sp@@-			| dummy code
	movl	#T_ADDRERR,sp@@-		| mark address error
a693 1
#endif
a694 41
#if defined(M68060)
ENTRY_NOPROFILE(buserr60)
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movel	sp@@(FR_HW+12),d0	| FSLW
	btst	#2,d0			| branch prediction error?
	jeq	Lnobpe
	movc	cacr,d2
	orl	#IC60_CABC,d2		| clear all branch cache entries
	movc	d2,cacr
	movl	d0,d1
	addql	#1,L60bpe
	andl	#0x7ffd,d1
	jeq	_ASM_LABEL(faultstkadjnotrap2)
Lnobpe:
| we need to adjust for misaligned addresses
	movl	sp@@(FR_HW+8),d1		| grab VA
	btst	#27,d0			| check for mis-aligned access
	jeq	Lberr3			| no, skip
	addl	#28,d1			| yes, get into next page
					| operand case: 3,
					| instruction case: 4+12+12
	andl	#PG_FRAME,d1            | and truncate
Lberr3:
	movl	d1,sp@@-
	movl	d0,sp@@-			| code is FSLW now.
	andw	#0x1f80,d0
	jeq	Lberr60			| it is a bus error
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lberr60:
	tstl	_C_LABEL(nofault)	| catch bus error?
	jeq	Lisberr			| no, handle as usual
	movl	sp@@(FR_HW+8+8),_C_LABEL(m68k_fault_addr) | save fault addr
	movl	_C_LABEL(nofault),sp@@-	| yes,
	jbsr	_C_LABEL(longjmp)	|  longjmp(nofault)
	/* NOTREACHED */
#endif
#if defined(M68040)
d696 8
a703 8
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	sp@@(FR_HW+20),d1	| get fault address
	moveq	#0,d0
	movw	sp@@(FR_HW+12),d0	| get SSW
	btst	#11,d0			| check for mis-aligned
d705 2
a706 2
	addl	#3,d1			| get into next page
	andl	#PG_FRAME,d1		| and truncate
d708 3
a710 3
	movl	d1,sp@@-			| pass fault address.
	movl	d0,sp@@-			| pass SSW as code
	btst	#10,d0			| test ATC
d712 1
a712 1
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
d717 2
a718 2
	movl	sp@@(FR_HW+8+20),_C_LABEL(m68k_fault_addr) | save fault addr
	movl	_C_LABEL(nofault),sp@@-	| yes,
d725 7
a731 7
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	moveq	#0,d0
	movw	sp@@(FR_HW+10),d0	| grab SSW for fault processing
	btst	#12,d0			| RB set?
d733 2
a734 2
	bset	#14,d0			| yes, must set FB
	movw	d0,sp@@(FR_HW+10)	| for hardware too
d736 1
a736 1
	btst	#13,d0			| RC set?
d738 2
a739 2
	bset	#15,d0			| yes, must set FC
	movw	d0,sp@@(FR_HW+10)	| for hardware too
d741 1
a741 1
	btst	#8,d0			| data fault?
d743 1
a743 1
	movl	sp@@(FR_HW+16),d1	| fault address is as given in frame
d746 1
a746 1
	btst	#4,sp@@(FR_HW+6)		| long (type B) stack frame?
d748 2
a749 2
	movl	sp@@(FR_HW+2),d1		| no, can use save PC
	btst	#14,d0			| FB set?
d751 1
a751 1
	addql	#4,d1			| yes, adjust address
d754 1
a754 1
	btst	#15,d0			| FC set?
d756 1
a756 1
	addql	#2,d1			| yes, adjust address
d759 2
a760 2
	movl	sp@@(FR_HW+36),d1	| long format, use stage B address
	btst	#15,d0			| FC set?
d762 1
a762 1
	subql	#2,d1			| yes, adjust address
d764 5
a768 5
	movl	d1,sp@@-			| push fault VA
	movl	d0,sp@@-			| and padded SSW
	movw	sp@@(FR_HW+8+6),d0	| get frame format/vector offset
	andw	#0x0FFF,d0		| clear out frame format
	cmpw	#12,d0			| address error vector?
d770 3
a772 3
	movl	d1,a0			| fault address
	movl	sp@@,d0			| function code from ssw
	btst	#8,d0			| data fault?
d774 1
a774 1
	movql	#1,d0			| user program access FC
d776 1
a776 1
	btst	#5,sp@@(FR_HW+8)		| supervisor mode?
d778 1
a778 1
	movql	#5,d0			| else supervisor program access
d780 4
a783 4
	ptestr	d0,a0@@,#7		| do a table search
	pmove	psr,sp@@			| save result
	movb	sp@@,d1
	btst	#2,d1			| invalid (incl. limit viol. and berr)?
d785 1
a785 1
	btst	#7,d1			| is it MMU table berr?
d788 1
a788 1
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
d791 1
a791 1
	btst	#3,d1			| write protect bit set?
d793 3
a795 3
	movl	sp@@,d0			| ssw into low word of d0
	andw	#0xc0,d0		| Write protect is set on page:
	cmpw	#0x40,d0		| was it read cycle?
d799 1
a799 1
	movl	#T_ADDRERR,sp@@-		| mark address error
d802 1
a802 1
	clrw	sp@@			| re-clear pad word
d805 2
a806 2
	movl	sp@@(FR_HW+8+16),_C_LABEL(m68k_fault_addr) | save fault addr
	movl	_C_LABEL(nofault),sp@@-	| yes,
d812 1
a812 1
	movl	#T_BUSERR,sp@@-		| mark bus error
d822 1
a822 1
	cmpw	#0x202c,sp@@(6)		| format type 2?
d831 3
a833 3
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save registers
	moveq	#T_FPEMULI,d0		| denote as FP emulation trap
d849 3
a851 3
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save registers
	moveq	#T_FPEMULD,d0		| denote as FP emulation trap
d864 8
a871 8
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-	| save user registers
	movl	usp,a0		| and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	movl	_C_LABEL(curpcb),a0 | current pcb
	lea	a0@@(PCB_FPCTX),a0 | address of FP savearea
	fsave	a0@@		| save state
d877 1
a877 1
	tstb	a0@@		| null state frame?
d879 3
a881 3
	clrw	d0		| no, need to tweak BIU
	movb	a0@@(1),d0	| get frame size
	bset	#3,a0@@(0,d0:w)	| set exc_pend bit of BIU
d883 3
a885 3
	fmovem	fpsr,sp@@-	| push fpsr as code argument
	frestore a0@@		| restore state
	movl	#T_FPERR,sp@@-	| push type arg
d894 4
a897 4
	moveml	#0xC0C0,sp@@-		| save scratch regs
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
	movl	sp@@(22),sp@@-		| and PC
d899 2
a900 2
	addql	#8,sp			| pop args
	moveml	sp@@+,#0x0303		| restore regs
d904 5
a908 5
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	d0,sp@@-			| push syscall number
d910 1
a910 1
	addql	#4,sp			| pop syscall arg
d915 1
a915 1
	movw	#SPL1,sr
d919 4
a922 4
	movl	sp@@(FR_SP),a0		| grab and restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most registers
	addql	#8,sp			| pop SP and stack adjust
d943 4
a946 4
	movl	d1,sp@@-			| push length
	movl	a1,sp@@-			| push addr
	movl	d0,sp@@-			| push command
	movl	CURPROC,sp@@-		| push proc pointer
d948 1
a948 1
	lea	sp@@(16),sp		| pop args
d956 3
a958 3
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRACE,d0
d966 3
a968 3
	movw	sp@@(FR_HW),d1		| get PSW
	notw	d1			| XXX no support for T0 on 680[234]0
	andw	#PSL_TS,d1		| from system mode (T=1, S=1)?
d980 5
a984 5
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRAP15,d0
	movw	sp@@(FR_HW),d1		| get PSW
	andw	#PSL_S,d1		| from system mode?
d990 3
a992 3
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	lea	sp@@(FR_SIZE),a6		| Save stack pointer
	movl	a6,sp@@(FR_SP)		|  from before trap
d996 2
a997 2
	movl	a6,d1
	cmpl	#_ASM_LABEL(tmpstk),d1
d1000 4
a1003 4
	movl	sp,a0			| a0=src
	lea	_ASM_LABEL(tmpstk)-96,a1 | a1=dst
	movl	a1,sp			| sp=new frame
	moveq	#FR_SIZE,d1
d1005 2
a1006 2
	movl	a0@@+,a1@@+
	subql	#4,d1
d1017 2
a1018 2
	movl	d0,d2			| trap type
	movl	sp,a2			| frame ptr
d1021 2
a1022 2
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
d1024 2
a1025 2
	addql	#8,sp			| pop args
	cmpl	#0,d0			| did kgdb handle it?
d1030 2
a1031 2
	movl	a2,sp@@-			| push frame ptr
	movl	d2,sp@@-			| push trap type
d1033 1
a1033 1
	addql	#8,sp			| pop args
d1035 1
a1035 1
	cmpl	#0,d0			| did ddb handle it?
d1046 7
a1052 7
	movl	sp@@(FR_SP),a0		| modified sp
	lea	sp@@(FR_SIZE),a1		| end of our frame
	movl	a1@@-,a0@@-		| copy 2 longs with
	movl	a1@@-,a0@@-		| ... predecrement
	movl	a0,sp@@(FR_SP)		| sp = h/w frame
	moveml	sp@@+,#0x7FFF		| restore all but sp
	movl	sp@@,sp			| ... and sp
d1067 2
a1068 2
#define INTERRUPT_SAVEREG	moveml	#0xC0C0,sp@@-
#define INTERRUPT_RESTOREREG	moveml	sp@@+,#0x0303
d1076 2
a1077 2
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
d1079 1
a1079 1
	addql	#4,sp
d1085 2
a1086 2
	CLKADDR(a0)
	movb	a0@@(CLKSR),d0		| read clock status
d1088 1
a1088 1
	btst	#0,d0			| clear timer1 int immediately to
d1090 3
a1092 3
	movpw	a0@@(CLKMSB1),d1		|  due to statintr processing delay
	movl	_C_LABEL(clkint),d1	| clkcounter += clkint
	addl	d1,_C_LABEL(clkcounter)
d1094 1
a1094 1
	btst	#2,d0			| timer3 interrupt?
d1096 4
a1099 4
	movpw	a0@@(CLKMSB3),d1		| clear timer3 interrupt
	lea	sp@@(16),a1		| a1 = &clockframe
	movl	d0,sp@@-			| save status
	movl	a1,sp@@-
d1101 3
a1103 3
	addql	#4,sp
	movl	sp@@+,d0			| restore pre-statintr status
	CLKADDR(a0)
d1105 1
a1105 1
	btst	#0,d0			| timer1 interrupt?
d1107 2
a1108 2
	lea	sp@@(16),a1		| a1 = &clockframe
	movl	a1,sp@@-
d1112 4
a1115 4
	movl	_ASM_LABEL(heartbeat),d0 | get tick count
	addql	#1,d0			|  increment
	movl	_C_LABEL(hz),d1
	addl	#50,d1			| get the timing a little closer
d1118 1
a1118 1
	lsrl	#3,d1			| no, fast throb
d1120 2
a1121 2
	lsrl	#1,d1			| slow throb
	cmpl	d0,d1			| are we there yet?
d1128 3
a1130 3
	movl	#LED_PULSE,sp@@-
	movl	#LED_DISK+LED_LANRCV+LED_LANXMT,sp@@-
	clrl	sp@@-
d1132 2
a1133 2
	lea	sp@@(12),sp
	movql	#0,d0
d1135 1
a1135 1
	movl	d0,_ASM_LABEL(heartbeat)
d1139 2
a1140 2
	addql	#4,sp
	CLKADDR(a0)
d1143 1
a1143 1
	movb	a0@@(CLKSR),d0		| see if anything happened
d1146 2
a1147 2
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
d1149 1
a1149 1
	addql	#4,sp
d1155 4
a1158 4
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-		| save registers
	movl	usp,a0			| and save
	movl	a0,sp@@(FR_SP)		|   the user stack pointer
d1160 4
a1163 4
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| and remaining registers
	addql	#8,sp			| pop SP and stack adjust
d1186 1
a1186 1
	btst	#5,sp@@			| yes, are we returning to user mode?
d1188 5
a1192 5
	movw	#PSL_LOWIPL,sr		| lower SPL
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
d1194 3
a1196 3
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_ASTFLT,sp@@-		| type == async system trap
d1198 4
a1201 4
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
d1203 2
a1204 2
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SP and stack adjust
d1207 9
a1215 9
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
d1220 3
a1222 3
	movl	d0,sp@@-			| need a scratch register
	movw	sp@@(4),d0		| get SR
	andw	#PSL_IPL7,d0		| mask all but IPL
d1224 1
a1224 1
	movl	sp@@+,d0			| restore scratch register
d1226 1
a1226 1
	movw	#SPL1,sr		| prevent others from servicing int
d1229 4
a1232 4
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
d1234 3
a1236 3
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_SSIR,sp@@-		| type == software interrupt
d1238 5
a1242 5
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| and all remaining registers
	addql	#8,sp			| pop SP and stack adjust
d1245 1
a1245 1
	movl	sp@@+,d0			| restore scratch register
d1264 1
d1286 1
a1286 1
	movl	sp@@(4), d0		| oldproc
d1292 5
a1296 5
	movl	_C_LABEL(curpcb),a1
	movw	sr, a1@@(PCB_PS)		| save sr before switching context
	moveml	#0xFCFC,a1@@(PCB_REGS)	| save non-scratch registers
	movl	usp,a2			| grab USP (a2 has been saved)
	movl	a2,a1@@(PCB_USP)		| and save it
d1300 3
a1302 3
	lea	a1@@(PCB_FPCTX),a2	| pointer to FP save area
	fsave	a2@@			| save FP state
	tstb	a2@@			| null state frame?
d1304 2
a1305 2
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(FPF_FPCR)	| save FP control registers
d1308 1
a1308 1
	movl	sp@@(8), a0		| newproc
d1310 4
a1313 4
	movl	a0, CURPROC
	movb	#SONPROC,a0@@(P_STAT)
	movl	a0@@(P_ADDR),a1		| get p_addr
	movl	a1,_C_LABEL(curpcb)
d1320 1
a1320 1
	pea	a0@@			| push proc
d1322 2
a1323 2
	addql	#4,sp
	movl	_C_LABEL(curpcb),a1	| restore p_addr
d1325 1
a1325 1
	lea	_ASM_LABEL(tmpstk),sp	| now goto a tmp stack for NMI
d1327 3
a1329 3
	moveml	a1@@(PCB_REGS),#0xFCFC	| and registers
	movl	a1@@(PCB_USP),a0
	movl	a0,usp			| and USP
d1333 2
a1334 2
	lea	a1@@(PCB_FPCTX),a0	| pointer to FP save area
	tstb	a0@@			| null state frame?
d1341 2
a1342 2
	clrl	sp@@-			| yes...
	frestore sp@@+			| ...magic!
d1345 2
a1346 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1348 1
a1348 1
	frestore a0@@			| restore state
d1351 2
a1352 2
	movw	a1@@(PCB_PS),sr		| no, restore PS
	moveq	#1,d0			| return 1 (for alternate returns)
d1360 5
a1364 5
	movl	sp@@(4),a1
	movw	sr,a1@@(PCB_PS)
	movl	usp,a0			| grab USP
	movl	a0,a1@@(PCB_USP)		| and save it
	moveml	#0xFCFC,a1@@(PCB_REGS)	| save non-scratch registers
d1368 3
a1370 3
	lea	a1@@(PCB_FPCTX),a0	| pointer to FP save area
	fsave	a0@@			| save FP state
	tstb	a0@@			| null state frame?
d1372 2
a1373 2
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1375 1
a1375 1
	moveq	#0,d0			| return 0
d1380 6
a1385 6
	movl	sp@@(4),a0		| address to write
	movl	_C_LABEL(curpcb),a1	| current pcb
	movl	#Lslerr,a1@@(PCB_ONFAULT) | where to return to on a fault
	movl	sp@@(8),a1		| address of line
	movl	a1@@+,d0			| get lword
	movsl	d0,a0@@+			| put lword
d1387 2
a1388 2
	movl	a1@@+,d0			| get lword
	movsl	d0,a0@@+			| put lword
d1390 2
a1391 2
	movl	a1@@+,d0			| get lword
	movsl	d0,a0@@+			| put lword
d1393 2
a1394 2
	movl	a1@@+,d0			| get lword
	movsl	d0,a0@@+			| put lword
d1396 1
a1396 1
	moveq	#0,d0			| indicate no fault
d1399 1
a1399 1
	moveq	#-1,d0
d1401 2
a1402 2
	movl	_C_LABEL(curpcb),a1	| current pcb
	clrl	a1@@(PCB_ONFAULT) 	| clear fault address
d1413 2
a1414 1
	.word	0xf518			| yes, pflusha
d1417 1
d1422 2
a1423 2
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
d1434 10
a1443 9
	movl	sp@@(4),a0
	movc	dfc,d1
	moveq	#FC_USERD,d0		| user space
	movc	d0,dfc
	.word	0xf508			| pflush a0@@
	moveq	#FC_SUPERD,d0		| super space
	movc	d0,dfc
	.word	0xf508			| pflush a0@@
	movc	d1,dfc
d1445 1
d1448 1
a1448 1
	movl	sp@@(4),a0		| get addr to flush
d1451 3
a1453 3
	pflush	#0,#0,a0@@		| flush address from both sides
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip data cache
d1456 1
a1456 1
	pflushs	#0,#0,a0@@		| flush address from both sides
d1466 2
a1467 1
	.word	0xf498			| cinva ic
d1469 1
d1472 2
a1473 2
	movl	#IC_CLEAR,d0
	movc	d0,cacr			| invalidate i-cache
d1488 2
a1489 1
	.word	0xf478			| cpusha dc
d1491 1
d1500 2
a1501 1
	.word	0xf478			| cpusha dc
d1503 1
d1512 2
a1513 1
	.word	0xf478			| cpusha dc
d1515 1
d1525 2
a1526 1
	.word	0xf478			| cpusha dc
d1528 1
d1536 5
a1540 5
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	MMUADDR(a0)
	andl	#~MMU_CEN,a0@@(MMUCMD)	| disable cache in MMU control reg
	orl	#MMU_CEN,a0@@(MMUCMD)	| reenable cache in MMU control reg
d1546 1
d1548 1
a1548 1
	.word	0xf498			| cinva ic
d1551 1
a1551 1
	.word	0xf478			| cpusha dc
d1554 2
a1555 2
	movl	sp@@(4),a0		| address
	.word	0xf488			| cinvl ic,a0@@
d1558 2
a1559 2
	movl	sp@@(4),a0		| address
	.word	0xf490			| cinvp ic,a0@@
d1562 2
a1563 2
	movl	sp@@(4),a0		| address
	.word	0xf448			| cinvl dc,a0@@
d1566 2
a1567 2
	movl	sp@@(4),a0		| address
	.word	0xf450			| cinvp dc,a0@@
d1570 2
a1571 2
	movl	sp@@(4),a0		| address
	.word	0xf468			| cpushl dc,a0@@
d1574 2
a1575 2
	movl	sp@@(4),a0		| address
	.word	0xf470			| cpushp dc,a0@@
d1577 1
d1583 2
a1584 2
	MMUADDR(a0)
	orl	#MMU_CEN,a0@@(MMUCMD)
d1591 2
a1592 2
	MMUADDR(a0)
	andl	#~MMU_CEN,a0@@(MMUCMD)
d1597 1
a1597 1
	movc	sfc,d0
d1601 1
a1601 1
	movc	dfc,d0
d1608 3
a1610 3
	movl	sp@@(4),d0		| new USTP
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to addr
d1614 3
a1616 2
	.word	0xf518			| yes, pflusha
	.long	0x4e7b0806		| movc d0,urp
d1618 1
d1622 5
a1626 5
	lea	_ASM_LABEL(protorp),a0	| CRP prototype
	movl	d0,a0@@(4)		| stash USTP
	pmove	a0@@,crp			| load root pointer
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
d1636 3
a1638 3
	moveq	#0,d0
	movw	sr,d0			| get old SR for return
	movw	#PSL_LOWIPL,sr		| restore new SR
d1641 4
a1644 4
	subql	#4,sp			| make room for RTE frame
	movl	sp@@(4),sp@@(2)		| position return address
	clrw	sp@@(6)			| set frame type 0
	movw	#PSL_LOWIPL,sp@@		| and new SR
d1658 1
a1658 1
	movl	sp@@(4),d0
d1660 1
a1660 1
	movl	_C_LABEL(delay_divisor),d1
d1672 1
a1672 1
	subl	d1,d0
d1680 3
a1682 3
	movl	sp@@(4),a0		| save area pointer
	fsave	a0@@			| save state
	tstb	a0@@			| null state frame?
d1684 2
a1685 2
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1690 2
a1691 2
	movl	sp@@(4),a0		| save area pointer
	tstb	a0@@			| null state frame?
d1693 2
a1694 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1696 1
a1696 1
	frestore a0@@			| restore state
d1708 10
a1717 10
	ASRELOC(_bsave,a3)
	movl	BUSERR,a3@@		| save ROM bus errror handler
	ASRELOC(_ssave,a3)
	movl	sp,a3@@			| and current stack pointer
	ASRELOC(catchbad,a3)
	movl	a3,BUSERR		| plug in our handler
	movw	a0@@,d1			| access address
	ASRELOC(_bsave,a3)		| no fault!
	movl	a3@@,BUSERR
	clrl	d0			| return success
d1720 5
a1724 5
	ASRELOC(_bsave,a3)		| got a bus error, so restore handler
	movl	a3@@,BUSERR
	ASRELOC(_ssave,a3)
	movl	a3@@,sp			| and stack
	moveq	#1,d0			| return fault
d1729 1
d1749 2
a1750 2
	movl	#CACHE_OFF,d0
	movc	d0,cacr			| disable on-chip cache(s)
d1753 2
a1754 2
	MMUADDR(a0)
	andl	#~MMU_CEN,a0@@(MMUCMD)	| disable external cache
d1756 5
a1760 5
	lea	MAXADDR,a0		| last page of physical memory
	movl	_C_LABEL(boothowto),a0@@+ | store howto
	movl	_C_LABEL(bootdev),a0@@+	| and devtype
	lea	Lbootcode,a1		| start of boot code
	lea	Lebootcode,a3		| end of boot code
d1762 2
a1763 2
	movw	a1@@+,a0@@+		| copy a word
	cmpl	a3,a1			| done yet?
d1768 2
a1769 1
	.word	0xf4f8			| cpusha bc
d1771 1
d1776 1
a1776 1
	lea	MAXADDR+0x800,sp	| physical SP in case of NMI
d1780 5
a1784 4
	movl	#0,d0
	movc	d0,cacr			| caches off
	.long	0x4e7b0003		| movc d0,tc
	movl	d2,MAXADDR+NBPG-4	| restore old high page contents
d1786 1
d1789 2
a1790 2
	movl	#0,a0@@			| value for pmove to TC (turn off MMU)
	pmove	a0@@,tc			| disable MMU
d1798 1
@


1.69
log
@Repair 68030 support, broken by mistake in 1.67. Found the hard way and
fix confirmed to work by Tobias Ulmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.68 2011/12/21 22:39:10 miod Exp $	*/
d1130 2
@


1.68
log
@Allow intr_dispatch() on hp300 to be used on the clock interrupt level
(level 6). Will be used shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.67 2011/11/01 21:20:55 miod Exp $	*/
d246 1
a246 1
	moveq	#CACHE40_OFF,d0			| now turn it back off
d1454 1
d1481 1
@


1.67
log
@Drop support for the HP MMU. It was only found on two hp300 systems (models
320 and 350), which have been unsupported since a bunch of release already,
because this annoying MMU does not have TT registers (or if it does, it is
not documented) and thus went in the way of PMAP_DIRECT for hp300.
In other words: remove a bunch of code which was either #ifdef'ed out or
had no chance to run in real life.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.66 2011/08/18 19:54:18 miod Exp $	*/
d70 1
d1182 6
@


1.66
log
@Because model 362 does not have an SGC bus (or a blind, deaf and mute one),
there is no way we can tell models 360 and 362 apart by probing for an SGC
bus, or for a frodo(4) chip since of the `lil' black swan' 3x2 models, only
model 382 has frodo. So don't bother trying to tell models 360 and 362
apart, and use a common 36X symbol. No functional change except for useless
code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.65 2010/06/29 20:30:31 guenther Exp $	*/
d309 1
a309 1
	jne	Lishpmmu		| yes, we have HP MMU
a314 20
Lishpmmu:
	RELOC(ectype, a0)		| 320 or 350
	movl	#EC_VIRT,a0@@		| both have a virtual address cache
	movl	#0x80,a1@@(MMUCMD)	| set magic cookie
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#7,d0			| cookie still on?
	jeq	Lis320			| no, just a 320
	RELOC(machineid, a0)
	movl	#HP_350,a0@@		| yes, a 350
	movl	#0,a1@@(MMUCMD)		| clear out MMU again
	RELOC(pmap_aliasmask, a0)
	movl	#0x7fff, a0@@		| 32KB
	jra	Lstart1
Lis320:
	RELOC(machineid, a0)
	movl	#HP_320,a0@@
	movl	#0,a1@@(MMUCMD)		| clear out MMU again
	RELOC(pmap_aliasmask, a0)
	movl	#0x3fff, a0@@		| 16KB
	jra	Lstart1
d446 1
a515 2
	tstl	a0@@			| HP MMU?
	jeq	Lhpmmu2			| yes, skip
d526 1
a526 5
	jra	Lstploaddone		| done
Lhpmmu2:
	moveq	#PGSHIFT,d2
	lsrl	d2,d1			| convert to page frame
	movl	d1,INTIOBASE+MMUBASE+MMUSSTP | load in sysseg table register
a551 2
	tstl	a0@@			| HP MMU?
	jeq	Lhpmmu3			| yes, skip
a595 4
Lhpmmu3:
	movl	#0,INTIOBASE+MMUBASE+MMUCMD	| clear external cache
	movl	#MMU_ENAB,INTIOBASE+MMUBASE+MMUCMD | turn on MMU
	jmp	Lenab1				| jmp to mapped code
a807 5
#if defined(M68K_MMU_MOTOROLA)
#if defined(M68K_MMU_HP)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	Lbehpmmu		| yes, different MMU fault handler
#endif
a824 1
#endif /* M68K_MMU_MOTOROLA */
a827 1
#if defined(M68K_MMU_MOTOROLA)
a835 11
#endif /* M68K_MMU_MOTOROLA */
#if defined(M68K_MMU_HP)
Lbehpmmu:
	MMUADDR(a0)
	movl	a0@@(MMUSTAT),d0		| read MMU status
	btst	#3,d0			| MMU fault?
	jeq	Lisberr1		| no, just a non-MMU bus error
	andl	#~MMU_FAULT,a0@@(MMUSTAT)| yes, clear fault bits
	movw	d0,sp@@			| pass MMU stat in upper half of code
	jra	Lismerr			| and handle it
#endif
a1445 3
#if defined(M68K_MMU_MOTOROLA)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	Lhpmmu6			| yes, skip
a1451 8
Lhpmmu6:
#endif
#if defined(M68K_MMU_HP)
	MMUADDR(a0)
	movl	a0@@(MMUTBINVAL),sp@@-	| do not ask me, this
	addql	#4,sp			|   is how HP-UX does it
#endif
	rts
a1471 3
#if defined(M68K_MMU_MOTOROLA)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	Lhpmmu5			| yes, skip
a1480 17
Lhpmmu5:
#endif
#if defined(M68K_MMU_HP)
	movl	sp@@(4),d0		| VA to invalidate
	bclr	#0,d0			| ensure even
	movl	d0,a0
	movw	sr,d1			| go critical
	movw	#PSL_HIGHIPL,sr		|   while in purge space
	moveq	#FC_PURGE,d0		| change address space
	movc	d0,dfc			|   for destination
	moveq	#0,d0			| zero to invalidate?
	movsl	d0,a0@@			| hit it
	moveq	#FC_USERD,d0		| back to old
	movc	d0,dfc			|   address space
	movw	d1,sr			| restore IPL
#endif
	rts
a1512 8
#if defined(M68K_MMU_HP)
	tstl	_C_LABEL(ectype)	| got external VAC?
	jle	Lnocache2		| no, all done
	MMUADDR(a0)
	andl	#~MMU_CEN,a0@@(MMUCMD)	| disable cache in MMU control reg
	orl	#MMU_CEN,a0@@(MMUCMD)	| reenable cache in MMU control reg
Lnocache2:
#endif
a1522 8
#if defined(M68K_MMU_HP)
	tstl	_C_LABEL(ectype)	| got external VAC?
	jle	Lnocache3		| no, all done
	MMUADDR(a0)
	movl	a0@@(MMUSSTP),d0		| read the supervisor STP
	movl	d0,a0@@(MMUSSTP)		| write it back
Lnocache3:
#endif
a1532 8
#if defined(M68K_MMU_HP)
	tstl	_C_LABEL(ectype)	| got external VAC?
	jle	Lnocache4		| no, all done
	MMUADDR(a0)
	movl	a0@@(MMUUSTP),d0		| read the user STP
	movl	d0,a0@@(MMUUSTP)		| write it back
Lnocache4:
#endif
a1618 3
#if defined(M68K_MMU_MOTOROLA)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	Lhpmmu9			| yes, skip
a1636 15
Lhpmmu9:
#endif
#if defined(M68K_MMU_HP)
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
	MMUADDR(a0)
	movl	a0@@(MMUTBINVAL),d1	| invalid TLB
	tstl	_C_LABEL(ectype)	| have external VAC?
	jle	1f
	andl	#~MMU_CEN,a0@@(MMUCMD)	| toggle cache enable
	orl	#MMU_CEN,a0@@(MMUCMD)	| to clear data cache
1:
	movl	sp@@(4),a0@@(MMUUSTP)	| load a new USTP
#endif
	rts
a1792 3
#if defined(M68K_MMU_MOTOROLA)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	LhpmmuB			| yes, skip
a1795 8
LhpmmuB:
#endif
#if defined(M68K_MMU_HP)
	MMUADDR(a0)
	movl	#0xFFFF0000,a0@@(MMUCMD)	| totally disable MMU
	movl	d2,MAXADDR+NBPG-4	| restore old high page contents
	DOREBOOT
#endif
d1803 1
a1803 1
	.long	HP_320		| default to 320
d1809 1
a1809 1
	.long	MMU_HP		| default to HP MMU
a1818 3

GLOBAL(pmap_aliasmask)
	.long	0
@


1.65
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.64 2009/03/15 20:40:23 miod Exp $	*/
d206 1
a206 1
	movl	#HP_360,a0@@		| type is at least a 360
a340 1
#if defined(HP362)
d342 3
a344 3
	 * If we found a 360, we need to check for a 362 (neither the 360
	 * nor the 362 have a nonzero mmuid). Since the 362 has a frodo
	 * utility chip in the DIO hole, check for it.
d346 1
a346 8
	movl	#FRODO_BASE, a0
	ASRELOC(phys_badaddr, a3)
	jbsr	a3@@
	tstl	d0			| found a frodo?
	jne	Lstart1			| no, really a 360 or a 380
	RELOC(machineid,a0)
	movl	#HP_362,a0@@
#endif
@


1.64
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.63 2008/01/04 19:10:31 miod Exp $	*/
d1033 1
a1033 1
 * Trap 12 is the entry point for the cachectl "syscall" (both HPUX & BSD)
a1568 33

#if defined(COMPAT_HPUX)
/*
 * Invalidate user side of TLB
 */
ENTRY(TBIAU)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	Lmotommu6		| no, skip
	.word	0xf518			| yes, pflusha (for now) XXX
	rts
Lmotommu6:
#endif
#if defined(M68K_MMU_MOTOROLA)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	Lhpmmu8			| yes, skip
	jpl	Lmc68851d		| 68851?
	pflush	#0,#4			| flush user TLB entries
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts
Lmc68851d:
	pflushs	#0,#4			| flush user TLB entries
	rts
Lhpmmu8:
#endif
#if defined(M68K_MMU_HP)
	MMUADDR(a0)
	moveq	#0,d0			| more
	movl	d0,a0@@(MMUTBINVAL)	|   HP magic
#endif
	rts
#endif	/* COMPAT_HPUX */
@


1.63
log
@Compute physmem as the real physical memory size, not the physical memory
size minus two pages at the start and one page at the end. This gives us
even MB sizes in dmesg (-:
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.62 2007/12/30 14:45:24 miod Exp $	*/
d1008 1
a1008 1
	tstb	_C_LABEL(ssir)
d1011 1
a1011 1
	tstb	_C_LABEL(ssir)
d1267 1
a1267 1
BSS(ssir,1)
d1305 1
a1305 1
	tstb	_C_LABEL(ssir)		| SIR pending?
d1314 1
a1314 1
	tstb	_C_LABEL(ssir)		| too late?
d1811 1
a1811 1
	tstb	_C_LABEL(ssir)		| software interrupt pending?
@


1.62
log
@Correctly handle non-null state frames on 68020 and 68030 in fpfault.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.61 2007/10/10 15:53:51 art Exp $	*/
d488 2
@


1.61
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.60 2007/05/15 13:46:22 martin Exp $	*/
d968 1
a968 1
	jle	Lfptnull
@


1.60
log
@switch m68k to __HAVE_CPUINFO

help miod@@, art@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.59 2006/08/17 06:33:59 miod Exp $	*/
a1347 5
/*
 * Use common m68k process manipulation routines.
 */
#include <m68k/m68k/proc_subr.s>

d1354 1
a1354 22
/*
 * At exit of a process, do a switch for the last time.
 * Switch to a safe stack and PCB, and deallocate the process's resources.
 */
ENTRY(switch_exit)
	movl	sp@@(4),a0
	/* save state into garbage pcb */
	movl	#_ASM_LABEL(nullpcb),_C_LABEL(curpcb)
	lea	_ASM_LABEL(tmpstk),sp	| goto a tmp stack

        /* Schedule the vmspace and stack to be freed. */
	movl    a0,sp@@-                 | exit2(p)
	jbsr    _C_LABEL(exit2)
	lea     sp@@(4),sp               | pop args

	jra	_C_LABEL(cpu_switch)

/*
 * When no processes are on the runq, Swtch branches to Idle
 * to wait for something to come ready.
 */
ASENTRY_NOPROFILE(Idle)
d1356 1
a1356 8
	movw	#PSL_HIGHIPL,sr
	movl	_C_LABEL(whichqs),d0
	jeq	_ASM_LABEL(Idle)
	jra	Lsw1

Lbadsw:
	PANIC("switch")
	/*NOTREACHED*/
d1359 1
a1359 1
 * cpu_switch()
d1369 3
a1371 7
ENTRY(cpu_switch)
	movl	_C_LABEL(curpcb),a0	| current pcb
	movw	sr,a0@@(PCB_PS)		| save sr before changing ipl
#ifdef notyet
	movl	CURPROC,sp@@-		| remember last proc running
#endif
	clrl	CURPROC
a1373 37
	 * Find the highest-priority queue that isn't empty,
	 * then take the first proc from that queue.
	 */
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	movl	_C_LABEL(whichqs),d0
	jeq	_ASM_LABEL(Idle)
Lsw1:
	movl	d0,d1
	negl	d0
	andl	d1,d0
	bfffo	d0{#0:#32},d1
	eorib	#31,d1

	movl	d1,d0
	lslb	#3,d1			| convert queue number to index
	addl	#_C_LABEL(qs),d1	| locate queue (q)
	movl	d1,a1
	movl	a1@@(P_FORW),a0		| p = q->p_forw
	cmpal	d1,a0			| anyone on queue?
	jeq	Lbadsw			| no, panic
	movl	a0@@(P_FORW),a1@@(P_FORW)	| q->p_forw = p->p_forw
	movl	a0@@(P_FORW),a1		| n = p->p_forw
	movl	d1,a1@@(P_BACK)		| n->p_back = q
	cmpal	d1,a1			| anyone left on queue?
	jne	Lsw2			| yes, skip
	movl	_C_LABEL(whichqs),d1
	bclr	d0,d1			| no, clear bit
	movl	d1,_C_LABEL(whichqs)
Lsw2:
	movl	a0,CURPROC
	clrl	_C_LABEL(want_resched)
#ifdef notyet
	movl	sp@@+,a1
	cmpl	a0,a1			| switching to same proc?
	jeq	Lswdone			| yes, skip save and restore
#endif
	/*
d1377 1
d1390 1
d1392 1
d1394 1
a1394 6
#ifdef DIAGNOSTIC
	tstl	a0@@(P_WCHAN)
	jne	Lbadsw
	cmpb	#SRUN,a0@@(P_STAT)
	jne	Lbadsw
#endif
a1395 1
	clrl	a0@@(P_BACK)		| clear back link
@


1.59
log
@Setup the transparent translation with writeback cache instead of
writethrough on 68040.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.58 2006/07/09 19:41:21 miod Exp $	*/
d1039 1
a1039 1
	movl	_C_LABEL(curproc),sp@@-	| push proc pointer
d1406 1
a1406 1
	movl	_C_LABEL(curproc),sp@@-	| remember last proc running
d1408 1
a1408 1
	clrl	_C_LABEL(curproc)
d1440 1
a1440 1
	movl	a0,_C_LABEL(curproc)
@


1.58
log
@If running on a 68030 or 68040 system, use the transparent translation
registers to program an 1GB untranslated window over the physical memory,
and use it to define __HAVE_PMAP_DIRECT for faster pool operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.57 2006/06/24 13:20:17 miod Exp $	*/
d602 1
a602 1
	movl	#0xc03fa000,d0
@


1.57
log
@Use pmap_kenter_cache() for device memory mapping, instead of physacc(0
which bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.56 2006/06/11 20:57:41 miod Exp $	*/
d548 1
a548 1
	RELOC(protorp, a0)
d593 10
d604 1
a604 1
	.long	0x4e7b0007		| movc d0,dtt1
d613 10
d624 2
a625 2
					| enable 68881 and i-cache
	RELOC(prototc, a2)
d1854 1
a1854 1
	lea	_C_LABEL(protorp),a0	| CRP prototype
a2068 1
#if defined(M68K_MMU_HP)
a2070 1
#endif
d2072 1
a2072 1
GLOBAL(protorp)
d2075 2
a2076 2
GLOBAL(prototc)
	.long	0		| prototype translation control
@


1.56
log
@Clean the various cache and TLB invalidation function, arch by arch:
- [DI]C{FL,PL,PP} and DCFA are only called on 680[46]0 systems and are
  identical on these platforms, so don't bother checking for the MMU type.
- TBIAS is on 68060 codepath only.
- DCIAS, PCIA and TBIA are specific to some platforms and do not need to be
  implemented everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.55 2006/06/11 20:44:18 miod Exp $	*/
a1621 31
#endif
	rts

/*
 * Invalidate supervisor side of TLB
 */
ENTRY(TBIAS)
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	Lmotommu5		| no, skip
	.word	0xf518			| yes, pflusha (for now) XXX
	rts
Lmotommu5:
#endif
#if defined(M68K_MMU_MOTOROLA)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	Lhpmmu7			| yes, skip
	jpl	Lmc68851c		| 68851?
	pflush #4,#4			| flush supervisor TLB entries
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts
Lmc68851c:
	pflushs #4,#4			| flush supervisor TLB entries
	rts
Lhpmmu7:
#endif
#if defined(M68K_MMU_HP)
	MMUADDR(a0)
	movl	#0x8000,d0		| more
	movl	d0,a0@@(MMUTBINVAL)	|   HP magic
@


1.55
log
@Move pmap_aliasmask declaration and initialization to MD code. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.54 2006/05/20 14:54:52 miod Exp $	*/
d643 1
a643 1
	jbsr	_C_LABEL(TBIA)		| invalidate TLB
d1128 3
a1130 1
/* Use common m68k sigreturn */
d1550 1
a1550 2
ENTRY(TBIA)
_C_LABEL(_TBIA):
d1572 1
a1572 5
	addql	#4,sp			|   is how hpux does it
#ifdef DEBUG
	tstl	_ASM_LABEL(fullcflush)
	jne	_C_LABEL(_DCIA)		| XXX: invalidate entire cache
#endif
a1579 4
#ifdef DEBUG
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush entire TLB
#endif
a1628 4
#ifdef DEBUG
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush everything
#endif
a1652 4
#ifdef DEBUG
	tstl	_ASM_LABEL(fullcflush)
	jne	_C_LABEL(_DCIS)		| XXX: invalidate entire sup. cache
#endif
d1656 1
a1660 4
#ifdef DEBUG
	tstl	_ASM_LABEL(fulltflush)	| being conservative?
	jne	_C_LABEL(_TBIA)		| yes, flush everything
#endif
a1684 4
#ifdef DEBUG
	tstl	_ASM_LABEL(fullcflush)
	jne	_C_LABEL(_DCIU)		| XXX: invalidate entire user cache
#endif
d1687 1
a1693 1
ENTRY(ICPA)
a1712 1
_C_LABEL(_DCIA):
a1730 1
_C_LABEL(_DCIS):
a1748 1
_C_LABEL(_DCIU):
d1766 23
d1790 6
a1811 3
ENTRY(DCPA)
	.word	0xf458			| cinva dc
	rts
a1821 21
ENTRY(PCIA)
#if defined(M68040)
ENTRY(DCFA)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040
	jne	LmotommuB		| no, skip
	.word	0xf478			| cpusha dc
	rts
LmotommuB:
#endif
#if defined(M68K_MMU_MOTOROLA)
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	tstl	_C_LABEL(ectype)	| got external PAC?
	jge	Lnocache6		| no, all done
	MMUADDR(a0)
	andl	#~MMU_CEN,a0@@(MMUCMD)	| disable cache in MMU control reg
	orl	#MMU_CEN,a0@@(MMUCMD)	| reenable cache in MMU control reg
Lnocache6:
#endif
	rts

a1886 16
ENTRY(ploadw)
#if defined(M68K_MMU_MOTOROLA)
	movl	sp@@(4),a0		| address to load
#if defined(M68K_MMU_HP)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	Lploadwskp		| yes, skip
#endif
#if defined(M68040)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jeq	Lploadwskp		| yes, skip
#endif
	ploadw	#1,a0@@			| pre-load translation
Lploadwskp:
#endif
	rts

a2126 8
#endif

#ifdef DEBUG
ASGLOBAL(fulltflush)
	.long	0

ASGLOBAL(fullcflush)
	.long	0
@


1.54
log
@Do not wait until Lstart2 to reset the HP MMU command register on models
which need it. This allows up to free a1 for general use much earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.53 2006/05/19 22:51:07 miod Exp $	*/
d325 2
d332 2
d2115 5
@


1.53
log
@Get rid of ``maxmem'' and fix the descriptive comment for ``physmem''.
Either maxmem is not used (mac68k), or the position of the physical memory
is set in stone so we don't need to know the top of the memory (MAXADDR
on hp300, physmem on mvme68k) it was pointing to.

Plus this gets rid of unused lowram on mvme68k - all the m68k world is not an
hp300, after all.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.52 2006/01/21 12:27:56 miod Exp $	*/
d324 1
d329 1
a358 1
	 * Be careful, a1 is reserved at this point.
a473 1
	movl	#0,a1@@(MMUCMD)		| clear out MMU again
@


1.52
log
@Remove old mdpflag debug help.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.51 2005/11/13 23:14:33 miod Exp $	*/
d478 1
a478 1
/* initialize memory sizes (for pmap_bootstrap) */
d480 1
a481 5
	lsrl	d2,d1			| convert to page (click) number
	RELOC(maxmem, a0)
	movl	d1,a0@@			| save as maxmem
	movl	a5,d0			| lowram value from ROM via boot
	lsrl	d2,d0			| convert to page number
d483 1
d485 1
a485 1
	movl	d1,a0@@			| and physmem
@


1.51
log
@Align _delay() on 8 bytes, not 2^8 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.50 2005/09/27 22:05:37 miod Exp $	*/
a1331 1
GLOBAL(masterpaddr)		| XXX compatibility (debuggers)
a1333 4
ASLOCAL(mdpflag)
	.byte	0		| copy of proc md_flags low byte
	.align	2

a1449 1
	movb	a0@@(P_MD_FLAGS+3),mdpflag | low byte of p_md.md_flags
@


1.50
log
@Identify HP 9000/362 and HP 9000/382 models, and attach frodo on them.
Model 382 can be identified with a unique MMUID value; model 362 is told
from model 360 by probing for the frodo chip. Their built-in frame buffer
is not supported at the moment.

Matching information derived from messages to the NetBSD mailing lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.49 2005/08/05 03:36:28 deraadt Exp $	*/
d1969 1
a1969 1
	.align	8
@


1.49
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48 2005/01/18 13:32:56 miod Exp $	*/
d210 1
a210 1
	jeq	Lstart1			| no, must be a 360
d276 1
a276 1
	cmpb	#MMUID_385,d0		| last chance...
d278 2
d291 3
d328 1
d333 16
@


1.48
log
@In phys_badaddr() when probe fails, restore the correct PROM bus error
handle callback (i.e. fix a typo).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.47 2005/01/14 22:39:27 miod Exp $	*/
d1929 1
a1929 1
 * Delay for at least (N/256) microsecends.
@


1.47
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.46 2005/01/14 19:11:56 miod Exp $	*/
d1998 1
a1998 1
	movl	a1@@,BUSERR
@


1.46
log
@If we have a frame buffer configured as ``internal'', be sure to account for
its out-of-DIO-range memory when sizing the external iomap.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.45 2004/12/30 21:28:47 miod Exp $	*/
d6 1
a6 1
 * 
d75 8
a82 1
#include <hp300/dev/grfreg.h>
d160 2
a161 2
/* check for internal HP-IB in SYSFLAG */
	btst	#5,0xfffffed2		| internal HP-IB?
d380 29
d667 1
a667 1
 */ 
d694 1
a694 1
	jeq	Lnobpe			
d714 1
a714 1
	andw	#0x1f80,d0 
d968 1
a968 1
Ltrap1:	
a1121 7
ENTRY_NOPROFILE(lev1intr)	/* level 1: HIL XXX this needs to go away */
	INTERRUPT_SAVEREG
	jbsr	_C_LABEL(hilint)
	INTERRUPT_RESTOREREG
	addql	#1,_C_LABEL(uvmexp)+UVMEXP_INTRS
	jra	_ASM_LABEL(rei)

d1273 1
a1273 1
Lsir1:	
d1296 1
a1296 1
 */ 
d2011 1
a2011 1
	
@


1.45
log
@If we are running on a 68040 or a 68060 processor, overwrite the copypage()
code with the faster copypage040() before the kernel text is mapped read-only.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.44 2004/12/30 21:26:14 miod Exp $	*/
d75 1
d333 1
a333 2
	 * Don't probe the DIO-I space. Since cards may claim memory outside
	 * their range (frame buffers, for example), assume the whole 0-31
d339 12
d353 1
d358 1
a358 1
	movl	#132, d2		| our select code...
d377 1
@


1.44
log
@Kill the EIOMAPSIZE and instead, dynamically size the external I/O map,
based on the DIO-II space probing results.

This does not win much for now, but this will be very useful for SGC bus
support (coming soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.43 2004/12/24 22:50:29 miod Exp $	*/
d437 17
d463 1
@


1.43
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.42 2004/09/29 07:35:54 miod Exp $	*/
d74 1
d322 45
d1916 36
d2064 3
@


1.42
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.41 2004/07/22 19:36:38 miod Exp $	*/
a1004 1
	addql	#1,_C_LABEL(intrcnt)+0
a1011 1
	addql	#1,_C_LABEL(intrcnt)+4
a1035 1
	addql	#1,_C_LABEL(intrcnt)+28	| count clock interrupts
a1045 1
	addql	#1,_C_LABEL(intrcnt)+24	| count hardclock interrupts
a1087 1
	addql	#1,_C_LABEL(intrcnt)+32
a2003 18

/* interrupt counters */
GLOBAL(intrnames)
	.asciz	"spur"
	.asciz	"hil"
	.asciz	"lev2"
	.asciz	"lev3"
	.asciz	"lev4"
	.asciz	"lev5"
	.asciz	"clock"
	.asciz  "statclock"
	.asciz	"nmi"
GLOBAL(eintrnames)
	.even

GLOBAL(intrcnt)
	.long	0,0,0,0,0,0,0,0,0
GLOBAL(eintrcnt)
@


1.41
log
@Grammar.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.40 2004/07/02 17:33:42 miod Exp $	*/
d1081 1
a1081 1
	jbsr	_C_LABEL(hardclock)	| hardclock(&frame)
d1087 1
a1087 1
	jmi	Lclkagain		|  while we were in hardclock/statintr
@


1.40
log
@Cope with SONPROC scheduler changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.39 2004/05/20 09:20:41 kettenis Exp $	*/
d394 1
a394 1
 * the PC) are valid.  In order guarentee that, we use the last physical
@


1.39
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.38 2004/03/09 00:08:13 xsa Exp $	*/
d1329 1
@


1.38
log
@
same typo as in mac68k/mac68k/locore.s
ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.37 2003/06/02 23:27:45 millert Exp $	*/
d882 1
d884 1
a884 1
	lea	sp@@(12),sp		| pop args
@


1.37
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.36 2003/06/02 18:47:58 deraadt Exp $	*/
d521 1
a521 1
 * main() nevers returns; we exit to user mode from a forked process
@


1.36
log
@remove terms 3 (and 4 in some places) where i am the author
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.35 2002/04/25 22:32:51 miod Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.35
log
@Use more symbolic constants rather than magic values...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.34 2002/02/10 23:15:05 deraadt Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.34
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.33 2001/12/06 21:13:28 millert Exp $	*/
d246 1
a246 1
	moveq	#0,d0			| now turn it back off
d472 1
a472 1
	movl	#0x80008000,d0
d1481 1
a1481 1
	moveq	#1,d0			| user space
d1484 1
a1484 1
	moveq	#5,d0			| super space
@


1.33
log
@Define proper macros for FP frame offsets rather than magic numbers.
From NetBSD (tsutsui).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.32 2001/12/06 19:27:44 millert Exp $	*/
d708 1
a708 1
					| (we dont seperate data/program)
@


1.33.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.33 2001/12/06 21:13:28 millert Exp $	*/
d246 1
a246 1
	moveq	#CACHE40_OFF,d0			| now turn it back off
d472 1
a472 1
	movl	#CACHE40_ON,d0
d708 1
a708 1
					| (we dont separate data/program)
d1481 1
a1481 1
	moveq	#FC_USERD,d0		| user space
d1484 1
a1484 1
	moveq	#FC_SUPERD,d0		| super space
@


1.32
log
@fix typo I introduced during ksyms addition
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.31 2001/09/19 21:32:56 miod Exp $	*/
d1328 2
a1329 2
	fmovem	fp0-fp7,a2@@(216)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(312)	| save FP control registers
d1373 2
a1374 2
	fmovem	a0@@(312),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
d1400 2
a1401 2
	fmovem	fp0-fp7,a0@@(216)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(312)	| save FP control registers
d1867 2
a1868 2
	fmovem	fp0-fp7,a0@@(216)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(312)	| save FP control registers
d1876 2
a1877 2
	fmovem	a0@@(312),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
@


1.31
log
@Get rid of unused pagezero variable. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.30 2001/08/26 00:15:37 miod Exp $	*/
d383 1
a383 1
#if defined(DDB) || NSYMS > 0
@


1.30
log
@Nuke annoying defopt, by popular demand. Plus you get two typos fixed
for free.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.29 2001/08/25 16:16:03 miod Exp $	*/
a2000 3

GLOBAL(pagezero)
	.long	0		| PA of first page of kernel text
@


1.29
log
@Implement the data cache invalidation functions for 040, and fix a typo
as well.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.28 2001/06/27 04:05:45 art Exp $	*/
a80 1
#include "opt_useleds.h"
d102 1
a102 1
 * Try and make this the first thing is the data segment so it
@


1.28
log
@no more old VM
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.27 2001/05/13 17:27:24 aaron Exp $	*/
d940 1
a940 1
	| If were are not on tmpstk switch to it.
d1625 1
a1625 1
__DCIA:
d1629 1
a1629 1
	/* XXX implement */
d1648 1
a1648 1
	/* XXX implement */
d1667 1
a1667 1
	/* XXX implement */
@


1.27
log
@Remove an unused label.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.26 2001/05/13 17:19:56 millert Exp $	*/
a498 1
#if defined(UVM)
a499 3
#else
	jbsr	_C_LABEL(vm_set_page_size) | select software page size
#endif
a1015 1
#if defined(UVM)
a1016 3
#else
	addql	#1,_C_LABEL(cnt)+V_INTR
#endif
a1023 1
#if defined(UVM)
a1024 3
#else
	addql	#1,_C_LABEL(cnt)+V_INTR
#endif
a1094 1
#if defined(UVM)
a1095 3
#else
	addql	#1,_C_LABEL(cnt)+V_INTR	| chalk up another interrupt
#endif
@


1.26
log
@Fix the problem that single-step tracing of a trap instruction
drops the system into kernel debugger; itohy@@netbsd.org
Other m68k ports require similar changes
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.25 2001/05/13 16:55:35 millert Exp $	*/
a1370 1
Lcxswdone:
@


1.25
log
@Make sure the branch target of the delay loop is aligned to a cache
half-line (8-byte) boundary; thorpej@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.24 2001/05/10 01:32:58 millert Exp $	*/
d909 7
d917 3
a919 2
	andw	#PSL_S,d1		| from system mode?
	jne	Lkbrkpt			| yes, kernel breakpoint
@


1.24
log
@Add 425e detection based on what is in stand/uboot/srt0.S
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.23 2001/05/04 22:48:59 aaron Exp $	*/
d1854 10
@


1.23
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.22 2000/06/05 11:02:57 art Exp $	*/
d271 2
@


1.22
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.21 1998/09/06 20:09:59 millert Exp $	*/
/*	$NetBSD: locore.s,v 1.79 1997/09/12 08:41:55 mycroft Exp $	*/
d497 3
d501 1
d530 1
a530 2
	jbsr	_C_LABEL(intr_init)	| initialize interrupt handlers
	jbsr	_C_LABEL(hp300_calibrate_delay) | calibrate delay() loop
d549 4
d554 3
a556 3
	movl	a3,sp@@-
	jbsr	a2@@
	addql	#4,sp
d1010 3
d1014 1
d1022 3
d1026 1
d1097 3
d1101 1
d1350 8
a1357 13
	/* see if pmap_activate needs to be called; should remove this */
	movl	a0@@(P_VMSPACE),a0	| vmspace = p->p_vmspace
#ifdef DIAGNOSTIC
	tstl	a0			| map == VM_MAP_NULL?
	jeq	Lbadsw			| panic
#endif
	movl	a0@@(VM_PMAP),a0		| pmap = vmspace->vm_map.pmap
	tstl	a0@@(PM_STCHG)		| pmap->st_changed?
	jeq	Lswnochg		| no, skip
	pea	a1@@			| push pcb (at p_addr)
	pea	a0@@			| push pmap
	jbsr	_C_LABEL(pmap_activate)	| pmap_activate(pmap, pcb)
	addql	#8,sp
a1358 1
Lswnochg:
a1360 40
#if defined(M68040)
#if defined(M68020) || defined(M68030)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	Lres1a			| no, skip
#endif
	.word	0xf518			| yes, pflusha
	movl	a1@@(PCB_USTP),d0	| get USTP
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to addr
	.long	0x4e7b0806		| movc d0,urp
	jra	Lcxswdone
Lres1a:
#endif
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
#if defined(M68K_MMU_MOTOROLA)
#if defined(M68K_MMU_HP)
	tstl	_C_LABEL(mmutype)	| HP MMU?
	jeq	Lhpmmu4			| yes, skip
#endif
	pflusha				| flush entire TLB
	movl	a1@@(PCB_USTP),d0	| get USTP
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to addr
	lea	_C_LABEL(protorp),a0	| CRP prototype
	movl	d0,a0@@(4)		| stash USTP
	pmove	a0@@,crp			| load new user root pointer
	jra	Lcxswdone		| thats it
Lhpmmu4:	
#endif
#if defined(M68K_MMU_HP)
	MMUADDR(a0)
	movl	a0@@(MMUTBINVAL),d1	| invalidate TLB
	tstl	_C_LABEL(ectype)	| got external VAC?
	jle	Lnocache1		| no, skip
	andl	#~MMU_CEN,a0@@(MMUCMD)	| toggle cache enable
	orl	#MMU_CEN,a0@@(MMUCMD)	| to clear data cache
Lnocache1:
	movl	a1@@(PCB_USTP),a0@@(MMUUSTP) | context switch
#endif
d1362 1
d1776 1
d1781 1
d1785 3
a1787 3
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts				|   since pmove flushes TLB
d1791 2
d1794 6
@


1.21
log
@Preserve symbol table if ksyms is in the kernel but DDB is not.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.20 1997/11/06 19:42:34 millert Exp $	*/
d1224 4
a1227 6
	/* Free old process's resources. */
	movl	#USPACE,sp@@-		| size of u-area
	movl	a0@@(P_ADDR),sp@@-	| address of process's u-area
	movl	_C_LABEL(kernel_map),sp@@- | map it was allocated in
	jbsr	_C_LABEL(kmem_free)	| deallocate it
	lea	sp@@(12),sp		| pop args
@


1.21.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.22 2000/06/05 11:02:57 art Exp $	*/
d1224 6
a1229 4
        /* Schedule the vmspace and stack to be freed. */
	movl    a0,sp@@-                 | exit2(p)
	jbsr    _C_LABEL(exit2)
	lea     sp@@(4),sp               | pop args
@


1.21.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: locore.s,v 1.91 1998/11/11 06:41:25 thorpej Exp $	*/
a271 2
	cmpb	#MMUID_425_E,d0		| or maybe a 425e?
	jeq	Lisa425
d497 1
a497 1
	jbsr	_C_LABEL(uvm_setpagesize)  | select software page size
d526 2
a527 1
	jbsr	_C_LABEL(hp300_init)
a545 4
/*
 * proc_trampoline: call function in register a2 with a3 as an arg
 * and then rei.
 */
d547 3
a549 3
	movl	a3,sp@@-			| push function arg
	jbsr	a2@@			| call function
	addql	#4,sp			| pop arg
a899 7

	| Check PSW and see what happened.
	|   T=0 S=0	(should not happen)
	|   T=1 S=0	trace trap from user mode
	|   T=0 S=1	trace trap on a trap instruction
	|   T=1 S=1	trace trap from system mode (kernel breakpoint)

d901 2
a902 3
	notw	d1			| XXX no support for T0 on 680[234]0
	andw	#PSL_TS,d1		| from system mode (T=1, S=1)?
	jeq	Lkbrkpt			| yes, kernel breakpoint
d1003 1
a1003 1
	addql	#1,_C_LABEL(uvmexp)+UVMEXP_INTRS
d1011 1
a1011 1
	addql	#1,_C_LABEL(uvmexp)+UVMEXP_INTRS
d1082 1
a1082 1
	addql	#1,_C_LABEL(uvmexp)+UVMEXP_INTRS | chalk up another interrupt
d1331 13
a1343 8
	/*
	 * Activate process's address space.
	 * XXX Should remember the last USTP value loaded, and call this
	 * XXX only if it has changed.
	 */
	pea	a0@@			| push proc
	jbsr	_C_LABEL(pmap_activate)	| pmap_activate(p)
	addql	#4,sp
d1345 1
d1348 41
a1388 1

a1801 1
	.word	0xf518			| yes, pflusha
a1805 1
	pflusha				| flush entire TLB
d1809 3
a1811 3
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
	rts
a1814 2
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
a1815 6
	movl	a0@@(MMUTBINVAL),d1	| invalid TLB
	tstl	_C_LABEL(ectype)	| have external VAC?
	jle	1f
	andl	#~MMU_CEN,a0@@(MMUCMD)	| toggle cache enable
	orl	#MMU_CEN,a0@@(MMUCMD)	| to clear data cache
1:
a1867 10
	jra	L_delay			/* Jump into the loop! */

	/*
	 * Align the branch target of the loop to a half-line (8-byte)
	 * boundary to minimize cache effects.  This guarantees both
	 * that there will be no prefetch stalls due to cache line burst
	 * operations and that the loop will run from a single cache
	 * half-line.
	 */
	.align	8
@


1.21.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.21.8.2 2001/07/04 10:15:43 niklas Exp $	*/
d81 1
d103 1
a103 1
 * Try and make this the first thing in the data segment so it
d940 1
a940 1
	| If we are not on tmpstk switch to it.
d1625 1
a1625 1
_C_LABEL(_DCIA):
d1629 1
a1629 1
	.word	0xf478			| cpusha dc
d1648 1
a1648 1
	.word	0xf478			| cpusha dc
d1667 1
a1667 1
	.word	0xf478			| cpusha dc
d2002 3
@


1.21.8.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d383 1
a383 1
#if defined(DDB) || NKSYMS > 0
d708 1
a708 1
					| (we dont separate data/program)
d1328 2
a1329 2
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(FPF_FPCR)	| save FP control registers
d1373 2
a1374 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1400 2
a1401 2
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1867 2
a1868 2
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1876 2
a1877 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
@


1.21.8.5
log
@Sync the SMP branch with 3.3
@
text
@d246 1
a246 1
	moveq	#CACHE40_OFF,d0			| now turn it back off
d472 1
a472 1
	movl	#CACHE40_ON,d0
d1481 1
a1481 1
	moveq	#FC_USERD,d0		| user space
d1484 1
a1484 1
	moveq	#FC_SUPERD,d0		| super space
@


1.21.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.21.8.5 2003/03/27 23:19:21 niklas Exp $	*/
d15 6
d51 5
a55 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.21.8.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d521 1
a521 1
 * main() never returns; we exit to user mode from a forked process
a881 1
	movl	_C_LABEL(curproc),sp@@-	| push proc pointer
d883 1
a883 1
	lea	sp@@(16),sp		| pop args
@


1.20
log
@Idnetify/support hp385 (33Mhz 68040)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.19 1997/09/23 07:09:54 downsj Exp $	*/
d80 1
d382 1
a382 1
#ifdef DDB
@


1.19
log
@Some NetBSD changes, up to NETBSD_CURRENT_970921.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.18 1997/07/06 08:02:04 downsj Exp $	*/
d273 1
a273 1
	cmpb	#MMUID_433_S,d0		| last chance...
d275 2
d284 3
@


1.18
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.17 1997/04/17 12:02:32 downsj Exp $	*/
/*	$NetBSD: locore.s,v 1.74 1997/05/13 18:01:03 gwr Exp $		*/
d123 11
d323 35
d379 1
a379 1
	jne	Lstart2
d382 1
a382 1
Lstart2:
d556 52
a607 8
ENTRY_NOPROFILE(buserr)
	/*
	 * XXX TODO: look at the mac68k _buserr and generalize
	 * XXX the saving of the fault address so this routine
	 * XXX can be shared.
	 */
	tstl	_C_LABEL(nofault)	| device probe?
	jeq	Lberr			| no, handle as usual
d610 2
a611 1
Lberr:
d613 1
a613 4
#if defined(M68020) || defined(M68030)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	_C_LABEL(addrerr)	| no, skip
#endif
d618 1
a618 1
	lea	sp@@(FR_HW),a1		| grab base of HW berr frame
d620 4
a623 5
	movw	a1@@(12),d0		| grab SSW
	movl	a1@@(20),d1		| and fault VA
	btst	#11,d0			| check for mis-aligned access
	jeq	Lberr2			| no, skip
	addl	#3,d1			| yes, get into next page
d625 14
a638 13
Lberr2:
	movl	d1,sp@@-			| push fault VA
	movl	d0,sp@@-			| and padded SSW
	btst	#10,d0			| ATC bit set?
	jeq	Lisberr			| no, must be a real bus error
	movc	dfc,d1			| yes, get MMU fault
	movc	d0,dfc			| store faulting function code
	movl	sp@@(4),a0		| get faulting address
	.word	0xf568			| ptestr a0@@
	movc	d1,dfc
	.long	0x4e7a0805		| movc mmusr,d0
	movw	d0,sp@@			| save (ONLY LOW 16 BITS!)
	jra	Lismerr
d641 2
a642 1
ENTRY_NOPROFILE(addrerr)
a646 11
	lea	sp@@(FR_HW),a1		| grab base of HW berr frame
#if defined(M68040)
#if defined(M68020) || defined(M68030)
	cmpl	#MMU_68040,_C_LABEL(mmutype) | 68040?
	jne	Lbenot040		| no, skip
#endif
	movl	a1@@(8),sp@@-		| yes, push fault address
	clrl	sp@@-			| no SSW for address fault
	jra	Lisaerr			| go deal with it
Lbenot040:
#endif
d648 1
a648 1
	movw	a1@@(10),d0		| grab SSW for fault processing
d652 1
a652 1
	movw	d0,a1@@(10)		| for hardware too
d657 1
a657 1
	movw	d0,a1@@(10)		| for hardware too
d661 1
a661 1
	movl	a1@@(16),d1		| fault address is as given in frame
d664 1
a664 1
	btst	#4,a1@@(6)		| long (type B) stack frame?
d666 1
a666 1
	movl	a1@@(2),d1		| no, can use save PC
d677 1
a677 1
	movl	a1@@(36),d1		| long format, use stage B address
d684 1
a684 1
	movw	a1@@(6),d0		| get frame format/vector offset
d691 1
a691 1
	jeq	Lbehpmmu		| yes, skip
d698 2
a699 2
					| (we dont separate data/program)
	btst	#5,a1@@			| supervisor mode?
d706 1
a706 1
	btst	#2,d1			| invalid? (incl. limit viol and berr)
d709 6
a714 2
	jeq	Lismerr			| no, must be fast
	jra	Lisberr1		| real bus err needs not be fast
d717 1
a717 1
	jeq	Lisberr1		| no, must be bus error
d719 1
a719 1
	andw	#0xc0,d0		| write protect is set on page:
d721 4
a724 2
	jeq	Lisberr1		| yes, was not WPE, must be bus err
	jra	Lismerr			| no, must be mem err
a725 2
#endif
#if defined(M68K_MMU_HP)
d727 1
a727 1
	movl	a0@@(MMUSTAT),d0		| read status
d729 1
a729 1
	jeq	Lisberr			| no, just a non-MMU bus error so skip
d732 1
a733 3
Lismerr:
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
d739 9
a747 1
Lisberr:
d810 1
a810 1
	cmpl	#CPU_68040,_C_LABEL(cputype)
a1870 2
 * Pretty awful looking since our assembler does not
 * recognize FP mnemonics.
d1877 2
a1878 2
	fmovem fp0-fp7,a0@@(216)		| save FP general registers
	fmovem fpcr/fpsr/fpi,a0@@(312)	| save FP control registers
a1928 7
#define DOREBOOT						\
	/* Reset Vector Base Register to what PROM expects. */	\
	movl	#0,d0;						\
	movc	d0,vbr;						\
	/* Jump to REQ_REBOOT */				\
	jmp	0x1A4;

a1955 2

#undef DOREBOOT
@


1.17
log
@Latest code from Mike + slight fixes.
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.16 1997/04/17 11:40:37 downsj Exp $	*/
/*	$NetBSD: locore.s,v 1.67 1997/03/16 10:49:43 thorpej Exp $	*/
d77 1
d80 7
a86 2
#define MMUADDR(ar)	movl	_MMUbase,ar
#define CLKADDR(ar)	movl	_CLKbase,ar
d93 1
a93 2
	.globl  _kernel_text
_kernel_text:
d108 1
a108 1
tmpstk:
a111 2
	.text

d115 1
a115 1
#define	RELOC(var, ar)		\
d119 3
a130 2
	.comm	_lowram,4
	.comm	_esym,4
d132 4
a135 5
	.text
	.globl	_edata
	.globl	_etext,_end
	.globl	start
start:
d137 1
a137 1
	RELOC(tmpstk, a0)
d139 1
a139 1
	RELOC(_esym, a0)
d145 1
a145 1
	RELOC(_lowram, a0)
d153 1
a153 1
	RELOC(_internalhpib, a0)
d157 1
a157 1
	RELOC(_boothowto, a0)		| save reboot flags
d159 1
a159 1
	RELOC(_bootdev, a0)		|   and boot device
d175 6
a180 1
	RELOC(_mmutype, a0)		| no, we have 68030
d182 1
a182 1
	RELOC(_cputype, a0)
d184 1
a184 1
	RELOC(_machineid, a0)
d201 16
a216 4
	movl	#HP_375,a0@@		| yes, must be a 345/375
	RELOC(_mmuid, a0)
	lsrl	#8,d0			| get apparent ID
	movl	d0,a0@@			| save MMU ID
d221 1
a221 1
	RELOC(_ectype, a0)
d224 5
d237 6
a242 1
	RELOC(_mmutype, a0)
d244 1
a244 1
	RELOC(_cputype, a0)
d246 1
a246 1
	RELOC(_fputype, a0)
d248 1
a248 1
	RELOC(_ectype, a0)
d250 1
a250 1
	RELOC(_mmuid, a0)
d252 2
a253 1
	lsrl	#8,d0			| get apparent ID
d255 10
a264 10
	RELOC(_machineid, a0)
	cmpb	#4,d0			| id == 4?
	jeq	Lis33mhz		| yes, a 33MHz Strider (433t)
	cmpb	#6,d0			| id == 6?
	jeq	Lis33mhz		| yes, a 33MHz Trailways (433s)
	cmpb	#5,d0			| id == 5?
	jeq	Lis25mhz		| yes, a 25MHz Strider (425t)
	cmpb	#7,d0			| id == 7?
	jeq	Lis25mhz		| yes, a 25MHz Trailways (425s)
	movl	#HP_380,a0@@		| no, we have a 380
d266 2
a267 2
Lis25mhz:
	movl	#HP_425,a0@@		| 425 of some sort
d269 2
a270 2
Lis33mhz:
	movl	#HP_433,a0@@		| 433 of some sort
d272 9
d282 2
d288 1
a288 1
	RELOC(_mmutype, a0)
d290 1
a290 1
	RELOC(_machineid, a0)
d294 1
a294 1
	RELOC(_ectype, a0)		| 320 or 350
d300 1
a300 1
	RELOC(_machineid, a0)
d304 1
a304 1
	RELOC(_machineid, a0)
d307 4
d321 1
a321 1
	RELOC(_maxmem, a0)
d326 1
a326 1
	RELOC(_physmem, a0)
d328 1
a329 1
	.globl	_Sysseg, _pmap_bootstrap, _avail_start
d331 1
a331 1
	RELOC(_esym,a0)			| end of static kernel test/data/syms
d335 1
a335 1
	movl	#_end,d5		| end of static kernel text/data
d343 1
a343 1
	RELOC(_pmap_bootstrap,a0)
d357 1
a357 1
	RELOC(_Sysseg, a0)		| system segment table addr
d360 1
a360 1
	RELOC(_mmutype, a0)
d368 1
a368 1
	RELOC(_protorp, a0)
d380 2
a381 2
	RELOC(Lhighcode, a1)		| addr of high code
	RELOC(Lehighcode, a3)		| end addr
d399 1
a399 1
	movl	#_vectab,d0		| set Vector Base Register
d402 1
a402 1
	RELOC(_mmutype, a0)
d425 1
a425 1
	RELOC(_prototc, a2)
d444 2
a445 2
	lea	tmpstk,sp		| temporary stack
	jbsr	_vm_set_page_size	| select software page size
d447 1
a447 1
	movl	_proc0paddr,a1		| get proc0 pcb addr
d449 1
a449 1
	lea	_proc0,a2		| initialize proc0.p_addr so that
d453 1
a453 1
	movl	a1,_curpcb		| proc0 is running
d455 1
a455 1
	tstl	_fputype		| Have an FPU?
d459 1
a459 1
	jbsr	_m68881_restore		| restore it (does not kill a1)
d463 2
a464 2
	jbsr	_TBIA			| invalidate TLB
	cmpl	#MMU_68040,_mmutype	| 68040?
d468 1
a468 1
	tstl	_ectype
d474 2
a475 2
	jbsr	_intr_init		| initialize interrupt handlers
	jbsr	_hp300_calibrate_delay	| calibrate delay() loop
d487 1
a487 1
	lea	_proc0,a0		| save pointer to frame
d490 2
a491 4
	jra	_main			| main()

	pea	Lmainreturned		| Yow!  Main returned!
	jbsr	_panic
a492 3
Lmainreturned:
	.asciz	"main() returned"
	.even
d494 1
a494 2
	.globl	_proc_trampoline
_proc_trampoline:
d502 1
a502 1
	jra	rei			| and return
d508 1
d510 1
a510 2
	.globl	_trap, _nofault, _longjmp
_buserr:
d516 1
a516 1
	tstl	_nofault		| device probe?
d518 2
a519 2
	movl	_nofault,sp@@-		| yes,
	jbsr	_longjmp		|  longjmp(nofault)
d523 2
a524 2
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	_addrerr		| no, skip
d552 2
a553 1
_addrerr:
d561 1
a561 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d612 1
a612 1
	tstl	_mmutype		| HP MMU?
d653 1
a653 1
	jra	Ltrapnstkadj		| and deal with it
d656 1
a656 1
	jra	Ltrapnstkadj		| and deal with it
d661 1
a661 21
Ltrapnstkadj:
	jbsr	_trap			| handle the error
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
	jne	Lstkadj			| yes, go to it
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SSP and stkadj
	jra	rei			| all done
Lstkadj:
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	jra	rei			| all done
d666 1
a666 1
_fpfline:		/* XXXthorpej - candidate for vector patch */
d668 1
a668 1
	cmpl	#FPU_68040,_fputype	| 68040 FPU?
d671 1
a671 1
	jne	_illinst		| no, not an FP emulation
d674 1
a674 2
	.globl fpsp_unimp
	jmp	fpsp_unimp		| yes, go handle it
d682 1
a682 1
	jra	fault			| do it
d684 1
a684 1
	jra	_illinst
d687 1
a687 1
_fpunsupp:		/* XXXthorpej - candidate for vector patch */
d689 2
a690 2
	cmpl	#FPU_68040,_fputype	| 68040 FPU?
	jne	_illinst		| no, treat as illinst
d692 1
a692 2
	.globl	fpsp_unsupp
	jmp	fpsp_unsupp		| yes, go handle it
d700 1
a700 1
	jra	fault			| do it
d702 1
a702 1
	jra	_illinst
d711 1
a711 2
	.globl	_fpfault
_fpfault:
d717 1
a717 1
	movl	_curpcb,a0	| current pcb
d722 1
a722 1
	cmpl	#CPU_68040,_cputype
d734 1
a734 26
	jra	Ltrapnstkadj	| call trap and deal with stack cleanup

/*
 * Coprocessor and format errors can generate mid-instruction stack
 * frames and cause signal delivery hence we need to check for potential
 * stack adjustment.
 */
_coperr:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-
	movl	usp,a0		| get and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	clrl	sp@@-		| or code arg
	movl	#T_COPERR,sp@@-	| push trap type
	jra	Ltrapnstkadj	| call trap and deal with stack adjustments

_fmterr:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-
	movl	usp,a0		| get and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	clrl	sp@@-		| or code arg
	movl	#T_FMTERR,sp@@-	| push trap type
	jra	Ltrapnstkadj	| call trap and deal with stack adjustments
a739 23
_illinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_ILLINST,d0
	jra	fault

_zerodiv:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_ZERODIV,d0
	jra	fault

_chkinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_CHKINST,d0
	jra	fault

_trapvinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRAPVINST,d0
	jra	fault
d741 1
a741 23
_privinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_PRIVINST,d0
	jra	fault

	.globl	fault
fault:
	movl	usp,a0			| get and save
	movl	a0,sp@@(FR_SP)		|   the user stack pointer
	clrl	sp@@-			| no VA arg
	clrl	sp@@-			| or code arg
	movl	d0,sp@@-			| push trap type
	jbsr	_trap			| handle trap
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most user regs
	addql	#8,sp			| pop SP and stack adjust
	jra	rei			| all done

	.globl	_straytrap
_badtrap:
d746 1
a746 1
	jbsr	_straytrap		| report
d749 1
a749 1
	jra	rei			| all done
d751 1
a751 2
	.globl	_syscall
_trap0:
d757 1
a757 1
	jbsr	_syscall		| handle it
d759 1
a759 1
	tstl	_astpending
d761 1
a761 1
	tstb	_ssir
d764 1
a764 1
	tstb	_ssir
d776 2
a777 2
_trap1:
	jra	sigreturn
d782 2
a783 2
_trap2:
	jra	_trace
d790 1
a790 2
	.globl	_cachectl
_trap12:
d794 1
a794 1
	jbsr	_cachectl		| do it
d796 1
a796 1
	jra	rei			| all done
d802 1
a802 1
_trace:
d808 2
a809 2
	jne	kbrkpt			| yes, kernel breakpoint
	jra	fault			| no, user-mode fault
d818 1
a818 1
_trap15:
d824 2
a825 2
	jne	kbrkpt			| yes, kernel breakpoint
	jra	fault			| no, user-mode fault
d827 1
a827 1
kbrkpt:	| Kernel-mode breakpoint or trace trap. (d0=trap_type)
d836 1
a836 1
	cmpl	#tmpstk,d1
d840 1
a840 1
	lea	tmpstk-96,a1		| a1=dst
d862 1
a862 1
	jbsr	_kgdb_trap		| handle the trap
d871 1
a871 1
	jbsr	_kdb_trap		| handle the trap
d907 4
a910 8
	/* Externs. */
	.globl	_hilint, _intr_dispatch, _nmihand
	.globl	_hardclock, _statintr

_spurintr:	/* Level 0 */
	addql	#1,_intrcnt+0
	addql	#1,_cnt+V_INTR
	jra	rei
d912 1
a912 1
_lev1intr:	/* Level 1: HIL XXX this needs to go away */
d914 1
a914 1
	jbsr	_hilint
d916 3
a918 3
	addql	#1,_intrcnt+4
	addql	#1,_cnt+V_INTR
	jra	rei
d920 1
a920 1
_intrhand:	/* Levels 2 through 5 */
d924 1
a924 1
	jbsr	_intr_dispatch		| call dispatch routine
d927 1
a927 1
	jra	rei			| all done
d929 1
a929 1
_lev6intr:	/* Level 6: clock */
d941 1
a941 1
	addql	#1,_intrcnt+28		| count clock interrupts
d945 1
a945 1
	jbsr	_statintr		| statintr(&frame)
d952 1
a952 1
	addql	#1,_intrcnt+24		| count hardclock interrupts
d956 3
a958 4
	.globl	_ledaddr, _inledcontrol, _ledcontrol, _hz
	tstl	_ledaddr		| using LEDs?
	jeq	Lnoled0			| no, skip this code
	movl	heartbeat,d0		| get tick count
d960 1
a960 1
	movl	_hz,d1
d962 4
a965 4
	cmpl	#0,beatstatus		| time to slow down?
	jeq	SlowThrob
	lsrl	#3,d1			| fast throb
SlowThrob:
d968 6
a973 8
	jne	Lnoled1			| no, nothing to do
	tstl	_inledcontrol		| already updating LEDs?
	jne	Lnoled2			| yes, skip it
	addl	#1,beatstatus		| incr beat status
	cmpl	#3,beatstatus		| time to reset?
	ble	SkipReset
	movl	#0,beatstatus		| reset the status indicator
SkipReset:
d977 1
a977 1
	jbsr	_ledcontrol		| toggle pulse, turn all others off
a978 1
Lnoled2:
d980 5
a984 5
Lnoled1:
	movl	d0,heartbeat
Lnoled0:
#endif
	jbsr	_hardclock		| hardclock(&frame)
d988 1
a988 1
	addql	#1,_cnt+V_INTR		| chalk up another interrupt
d992 1
a992 1
	jra	rei			| all done
d994 2
a995 2
_lev7intr:	/* Level 7: Parity errors, reset key */
	addql	#1,_intrcnt+32
d1000 1
a1000 1
	jbsr	_nmihand		| call handler
d1005 1
a1005 1
	jra	rei			| all done
d1020 5
a1024 5
	.comm	_ssir,1
	.globl	_astpending
	.globl	rei
rei:
	tstl	_astpending		| AST pending?
d1038 1
a1038 1
	jbsr	_trap			| go handle it
d1059 1
a1059 1
	tstb	_ssir			| SIR pending?
d1068 1
a1068 1
	tstb	_ssir			| too late?
d1078 1
a1078 1
	jbsr	_trap			| go handle it
d1091 1
a1091 12
 * Signal "trampoline" code (18 bytes).  Invoked from RTE setup by sendsig().
 * 
 * Stack looks like:
 *
 *	sp+0 ->	signal number
 *	sp+4	pointer to siginfo (sip)
 *	sp+8	pointer to signal context frame (scp)
 *	sp+12	address of handler
 *	sp+16	saved hardware state
 *			.
 *			.
 *	scp+0->	beginning of signal context frame
d1093 1
a1093 12
	.globl	_sigcode, _esigcode
	.data
_sigcode:
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
	jsr	a0@@			| call signal handler	(2 bytes)
	addql	#4,sp			| pop signo		(2 bytes)
	trap	#1			| special syscall entry	(2 bytes)
	movl	d0,sp@@(4)		| save errno		(4 bytes)
	moveq	#1,d0			| syscall == exit	(2 bytes)
	trap	#0			| exit(errno)		(2 bytes)
	.align	2
_esigcode:
a1098 2
#include <machine/asm.h>

d1105 1
a1105 54
 * The following primitives manipulate the run queues.  _whichqs tells which
 * of the 32 queues _qs have processes in them.  Setrunqueue puts processes
 * into queues, remrunqueue removes them from queues.  The running process is
 * on no queue, other processes are on a queue related to p->p_priority,
 * divided by 4 actually to shrink the 0-127 range of priorities into the 32
 * available queues.
 */

	.globl	_whichqs,_qs,_cnt,_panic
	.globl	_curproc,_want_resched

/*
 * Setrunqueue(p)
 *
 * Call should be made at spl6(), and p->p_stat should be SRUN
 */
ENTRY(setrunqueue)
	movl	sp@@(4),a0
#ifdef DIAGNOSTIC
	tstl	a0@@(P_BACK)
	jne	Lset1
	tstl	a0@@(P_WCHAN)
	jne	Lset1
	cmpb	#SRUN,a0@@(P_STAT)
	jne	Lset1
#endif
	clrl	d0
	movb	a0@@(P_PRIORITY),d0
	lsrb	#2,d0
	movl	_whichqs,d1
	bset	d0,d1
	movl	d1,_whichqs
	lslb	#3,d0
	addl	#_qs,d0
	movl	d0,a0@@(P_FORW)
	movl	d0,a1
	movl	a1@@(P_BACK),a0@@(P_BACK)
	movl	a0,a1@@(P_BACK)
	movl	a0@@(P_BACK),a1
	movl	a0,a1@@(P_FORW)
	rts
#ifdef DIAGNOSTIC
Lset1:
	movl	#Lset2,sp@@-
	jbsr	_panic
Lset2:
	.asciz	"setrunqueue"
	.even
#endif

/*
 * Remrq(p)
 *
 * Call should be made at spl6().
d1107 1
a1107 36
ENTRY(remrunqueue)
	movl	sp@@(4),a0
	movb	a0@@(P_PRIORITY),d0
#ifdef DIAGNOSTIC
	lsrb	#2,d0
	movl	_whichqs,d1
	btst	d0,d1
	jeq	Lrem2
#endif
	movl	a0@@(P_BACK),a1
	clrl	a0@@(P_BACK)
	movl	a0@@(P_FORW),a0
	movl	a0,a1@@(P_FORW)
	movl	a1,a0@@(P_BACK)
	cmpal	a0,a1
	jne	Lrem1
#ifndef DIAGNOSTIC
	lsrb	#2,d0
	movl	_whichqs,d1
#endif
	bclr	d0,d1
	movl	d1,_whichqs
Lrem1:
	rts
#ifdef DIAGNOSTIC
Lrem2:
	movl	#Lrem3,sp@@-
	jbsr	_panic
Lrem3:
	.asciz	"remrunqueue"
	.even
#endif

Lsw0:
	.asciz	"switch"
	.even
a1108 2
	.globl	_curpcb
	.globl	_masterpaddr	| XXX compatibility (debuggers)
d1110 2
a1111 2
_masterpaddr:			| XXX compatibility (debuggers)
_curpcb:
d1113 2
a1114 1
mdpflag:
d1117 2
a1118 2
	.comm	nullpcb,SIZEOF_PCB
	.text
d1126 3
a1128 2
	movl	#nullpcb,_curpcb	| save state into garbage pcb
	lea	tmpstk,sp		| goto a tmp stack
d1133 2
a1134 2
	movl	_kernel_map,sp@@-	| map it was allocated in
	jbsr	_kmem_free		| deallocate it
d1137 1
a1137 1
	jra	_cpu_switch
d1143 1
a1143 2
	.globl	Idle
Idle:
d1146 2
a1147 2
	movl	_whichqs,d0
	jeq	Idle
d1151 1
a1151 2
	movl	#Lsw0,sp@@-
	jbsr	_panic
d1166 1
a1166 1
	movl	_curpcb,a0		| current pcb
d1169 1
a1169 1
	movl	_curproc,sp@@-		| remember last proc running
d1171 1
a1171 1
	clrl	_curproc
d1178 2
a1179 2
	movl	_whichqs,d0
	jeq	Idle
d1189 1
a1189 1
	addl	#_qs,d1			| locate queue (q)
d1199 1
a1199 1
	movl	_whichqs,d1
d1201 1
a1201 1
	movl	d1,_whichqs
d1203 2
a1204 2
	movl	a0,_curproc
	clrl	_want_resched
d1213 1
a1213 1
	movl	_curpcb,a1
d1218 1
a1218 1
	tstl	_fputype		| Do we have an FPU?
d1237 1
a1237 1
	movl	a1,_curpcb
d1245 1
a1245 1
	lea	a0@@(VM_PMAP),a0		| pmap = &vmspace.vm_pmap
d1250 1
a1250 1
	jbsr	_pmap_activate		| pmap_activate(pmap, pcb)
d1252 1
a1252 1
	movl	_curpcb,a1		| restore p_addr
d1255 1
a1255 1
	lea	tmpstk,sp		| now goto a tmp stack for NMI
d1258 1
a1258 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1273 1
a1273 1
	tstl	_mmutype		| HP MMU?
d1280 1
a1280 1
	lea	_protorp,a0		| CRP prototype
d1289 1
a1289 1
	tstl	_ectype			| got external VAC?
d1301 1
a1301 1
	tstl	_fputype		| If we don't have an FPU,
d1308 1
a1308 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1336 1
a1336 1
	tstl	_fputype		| Do we have FPU?
d1351 1
a1351 1
	movl	_curpcb,a1		| current pcb
d1371 1
a1371 1
	movl	_curpcb,a1		| current pcb
d1380 1
a1380 1
__TBIA:
d1382 1
a1382 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1389 1
a1389 1
	tstl	_mmutype		| HP MMU?
d1404 2
a1405 2
	tstl	fullcflush
	jne	__DCIA			| XXX: invalidate entire cache
d1415 2
a1416 2
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush entire TLB
d1419 1
a1419 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1434 1
a1434 1
	tstl	_mmutype		| HP MMU?
d1468 2
a1469 2
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush everything
d1472 1
a1472 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1479 1
a1479 1
	tstl	_mmutype		| HP MMU?
d1496 2
a1497 2
	tstl	fullcflush
	jne	__DCIS			| XXX: invalidate entire sup. cache
d1507 2
a1508 2
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush everything
d1511 1
a1511 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1518 1
a1518 1
	tstl	_mmutype		| HP MMU?
d1535 2
a1536 2
	tstl	fullcflush
	jne	__DCIU			| XXX: invalidate entire user cache
d1547 1
a1547 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1568 1
a1568 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1575 1
a1575 1
	tstl	_ectype			| got external VAC?
d1585 1
a1585 1
__DCIS:
d1587 1
a1587 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1594 1
a1594 1
	tstl	_ectype			| got external VAC?
d1604 1
a1604 1
__DCIU:
d1606 1
a1606 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1613 1
a1613 1
	tstl	_ectype			| got external VAC?
d1655 1
a1655 1
	cmpl	#MMU_68040,_mmutype	| 68040
d1664 1
a1664 1
	tstl	_ectype			| got external PAC?
d1674 1
a1674 1
	tstl	_ectype
d1682 1
a1682 1
	tstl	_ectype
d1689 1
a1689 2
	.globl	_getsfc, _getdfc
_getsfc:
d1692 2
a1693 1
_getdfc:
d1702 1
a1702 1
	tstl	_mmutype		| HP MMU?
d1708 1
a1708 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1714 1
a1714 1
	lea	_protorp,a0		| CRP prototype
d1732 1
a1732 1
	tstl	_mmutype		| HP MMU?
d1736 1
a1736 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1754 1
a1754 1
	tstb	_ssir			| software interrupt pending?
d1771 1
a1771 2
	.globl	__delay
__delay:
d1775 1
a1775 1
	movl	_delay_divisor,d1
d1814 1
a1814 2
	.globl	_doboot
_doboot:
d1816 1
a1816 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1821 1
a1821 1
	tstl	_ectype			| external cache?
d1827 2
a1828 2
	movl	_boothowto,a0@@+		| store howto
	movl	_bootdev,a0@@+		| and devtype
d1836 1
a1836 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1853 1
a1853 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d1863 1
a1863 1
	tstl	_mmutype		| HP MMU?
d1880 3
d1884 1
a1884 3
	.globl	_machineid,_mmuid,_mmutype,_cputype,_ectype,_fputype
	.globl	_protorp,_prototc
_machineid:
d1886 2
a1887 1
_mmuid:
d1889 2
a1890 1
_mmutype:
d1892 2
a1893 1
_cputype:
d1895 2
a1896 1
_ectype:
d1898 5
a1902 3
_fputype:
	.long	FPU_68881	| default to 68881 FPU
_protorp:
d1904 2
a1905 1
_prototc:
d1907 2
a1908 2
	.globl	_internalhpib
_internalhpib:
d1910 2
a1911 2
	.globl	_cold
_cold:
d1913 2
a1914 2
	.globl	_want_resched
_want_resched:
d1916 2
a1917 3
	.globl	_intiobase, _intiolimit, _extiobase, _CLKbase, _MMUbase
	.globl	_proc0paddr, _pagezero
_proc0paddr:
d1919 2
a1920 1
_intiobase:
d1922 2
a1923 1
_intiolimit:
d1925 2
a1926 1
_extiobase:
d1928 2
a1929 1
_CLKbase:
d1931 2
a1932 1
_MMUbase:
d1934 2
a1935 1
_pagezero:
d1937 1
d1939 1
a1939 1
heartbeat:
d1941 2
a1942 1
beatstatus:
d1945 1
d1947 1
a1947 2
	.globl	fulltflush, fullcflush
fulltflush:
d1949 2
a1950 1
fullcflush:
d1953 1
d1955 1
a1955 2
	.globl	_intrcnt,_eintrcnt,_intrnames,_eintrnames
_intrnames:
d1965 1
a1965 1
_eintrnames:
d1967 2
a1968 1
_intrcnt:
d1970 1
a1970 1
_eintrcnt:
@


1.16
log
@Use HP_425 for id 7, and fix tests in machdep.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.15 1997/04/17 10:28:38 downsj Exp $	*/
d225 2
a226 2
	cmpb	#7,d0			| id == 7?
	jeq	Lis425			| yes, we have a 425s
d228 1
a228 1
	jeq	Lis433			| yes, we have a 433s
d230 3
a232 3
	jeq	Lis425			| yes, we have a 425t
	cmpb	#4,d0			| id == 4?
	jeq	Lis425			| Heh, 425t overclocked
d235 2
a236 2
Lis425:
	movl	#HP_425,a0@@		| 425t
d238 2
a239 2
Lis433:
	movl	#HP_433,a0@@		| 433s
@


1.15
log
@Better machine type identification from Mike Smith
(<miff@@spam.frisbee.net.au>).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.14 1997/04/16 11:56:27 downsj Exp $	*/
d226 1
a226 1
	jeq	Lis433			| XXX 433 underclocked?
d239 1
a239 1
	movl	#HP_433,a0@@		| 433s (XXX 425s returns same ID, ugh!)
@


1.14
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.13 1997/03/26 08:32:41 downsj Exp $	*/
d194 3
d220 1
a220 1
	RELOC(_machineid, a0)
d223 4
d228 9
a236 2
	jeq	Lis33mhz		| yes, we have a 433s
	movl	#HP_380,a0@@		| no, we have a 380/425t
d238 1
a238 1
Lis33mhz:
d2059 1
a2059 1
	.globl	_machineid,_mmutype,_cputype,_ectype,_fputype
d2063 2
@


1.13
log
@Merge changes from NetBSD, up to 3/19/97; undoes some local changes.
Changed to match new arch/m68k code.
genassym.cf is currently just a place holder.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.12 1997/02/23 21:42:54 downsj Exp $	*/
d414 1
a414 1
	jbsr	_isrinit		| initialize interrupt handlers
d948 1
a948 1
	.globl	_hilint, _isrdispatch, _nmihand
d968 1
a968 1
	jbsr	_isrdispatch		| call dispatch routine
@


1.12
log
@Give HPUX it's own signal trampoline and stop modifying the real one.
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.11 1997/02/10 11:13:28 downsj Exp $	*/
/*	$NetBSD: locore.s,v 1.63 1997/02/02 07:55:52 thorpej Exp $	*/
d77 1
d110 14
a123 2
 * Do a dump.
 * Called by auto-restart.
d125 325
a449 6
	.globl	_dumpsys
	.globl	_doadump
_doadump:
	jbsr	_dumpsys
	jbsr	_doboot
	/*NOTREACHED*/
d633 2
d637 1
d641 4
a644 1
#else
a648 1
#endif
d655 1
a655 1
	cmpl	#MMU_68040,_mmutype	| 68040?
d660 4
a663 1
#else
a667 1
#endif
a679 1
#ifdef FPCOPROC
d690 1
a690 1
	cmpl	#MMU_68040,_mmutype
a702 3
#else
	jra	_badtrap	| treat as an unexpected trap
#endif
d813 1
a813 5
 * Routines for traps 1 and 2.  The meaning of the two traps depends
 * on whether we are an HPUX compatible process or a native 4.3 process.
 * Our native 4.3 implementation uses trap 1 as sigreturn() and trap 2
 * as a breakpoint trap.  HPUX uses trap 1 for a breakpoint, so we have
 * to make adjustments so that trap 2 is used for sigreturn.
d816 1
a816 3
	btst	#MDP_TRCB,mdpflag	| being traced by an HPUX process?
	jeq	sigreturn		| no, trap1 is sigreturn
	jra	_trace			| yes, trap1 is breakpoint
d818 3
d822 1
a822 3
	btst	#MDP_TRCB,mdpflag	| being traced by an HPUX process?
	jeq	_trace			| no, trap2 is breakpoint
	jra	sigreturn		| yes, trap2 is sigreturn
d918 6
a923 257
	/* Sun 3 drops into PROM here. */
Lbrkpt3:
	| The stack pointer may have been modified, or
	| data below it modified (by kgdb push call),
	| so push the hardware frame at the current sp
	| before restoring registers and returning.

	movl	sp@@(FR_SP),a0		| modified sp
	lea	sp@@(FR_SIZE),a1		| end of our frame
	movl	a1@@-,a0@@-		| copy 2 longs with
	movl	a1@@-,a0@@-		| ... predecrement
	movl	a0,sp@@(FR_SP)		| sp = h/w frame
	moveml	sp@@+,#0x7FFF		| restore all but sp
	movl	sp@@,sp			| ... and sp
	rte				| all done

/* Use common m68k sigreturn */
#include <m68k/m68k/sigreturn.s>

/*
 * Interrupt handlers.
 * All device interrupts are auto-vectored.  The CPU provides
 * the vector 0x18+level.  Note we count spurious interrupts, but
 * we don't do anything else with them.
 */

#define INTERRUPT_SAVEREG	moveml	#0xC0C0,sp@@-
#define INTERRUPT_RESTOREREG	moveml	sp@@+,#0x0303

	/* Externs. */
	.globl	_hilint, _isrdispatch, _nmihand
	.globl	_hardclock, _statintr

_spurintr:	/* Level 0 */
	addql	#1,_intrcnt+0
	addql	#1,_cnt+V_INTR
	jra	rei

_lev1intr:	/* Level 1: HIL XXX this needs to go away */
	INTERRUPT_SAVEREG
	jbsr	_hilint
	INTERRUPT_RESTOREREG
	addql	#1,_intrcnt+4
	addql	#1,_cnt+V_INTR
	jra	rei

_intrhand:	/* Levels 2 through 5 */
	INTERRUPT_SAVEREG
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
	jbsr	_isrdispatch		| call dispatch routine
	addql	#4,sp
	INTERRUPT_RESTOREREG
	jra	rei			| all done

_lev6intr:	/* Level 6: clock */
	INTERRUPT_SAVEREG
	CLKADDR(a0)
	movb	a0@@(CLKSR),d0		| read clock status
Lclkagain:
	btst	#0,d0			| clear timer1 int immediately to
	jeq	Lnotim1			|  minimize chance of losing another
	movpw	a0@@(CLKMSB1),d1		|  due to statintr processing delay
Lnotim1:
	btst	#2,d0			| timer3 interrupt?
	jeq	Lnotim3			| no, skip statclock
	movpw	a0@@(CLKMSB3),d1		| clear timer3 interrupt
	addql	#1,_intrcnt+28		| count clock interrupts
	lea	sp@@(16),a1		| a1 = &clockframe
	movl	d0,sp@@-			| save status
	movl	a1,sp@@-
	jbsr	_statintr		| statintr(&frame)
	addql	#4,sp
	movl	sp@@+,d0			| restore pre-statintr status
	CLKADDR(a0)
Lnotim3:
	btst	#0,d0			| timer1 interrupt?
	jeq	Lrecheck		| no, skip hardclock
	addql	#1,_intrcnt+24		| count hardclock interrupts
	lea	sp@@(16),a1		| a1 = &clockframe
	movl	a1,sp@@-
#ifdef USELEDS
	.globl	_ledaddr, _inledcontrol, _ledcontrol, _hz
	tstl	_ledaddr		| using LEDs?
	jeq	Lnoled0			| no, skip this code
	movl	heartbeat,d0		| get tick count
	addql	#1,d0			|  increment
	movl	_hz,d1
	addl	#50,d1			| get the timing a little closer
	cmpl	#0,beatstatus		| time to slow down?
	jeq	SlowThrob
	lsrl	#3,d1			| fast throb
SlowThrob:
	lsrl	#1,d1			| slow throb
	cmpl	d0,d1			| are we there yet?
	jne	Lnoled1			| no, nothing to do
	tstl	_inledcontrol		| already updating LEDs?
	jne	Lnoled2			| yes, skip it
	addl	#1,beatstatus		| incr beat status
	cmpl	#3,beatstatus		| time to reset?
	ble	SkipReset
	movl	#0,beatstatus		| reset the status indicator
SkipReset:
	movl	#LED_PULSE,sp@@-
	movl	#LED_DISK+LED_LANRCV+LED_LANXMT,sp@@-
	clrl	sp@@-
	jbsr	_ledcontrol		| toggle pulse, turn all others off
	lea	sp@@(12),sp
Lnoled2:
	movql	#0,d0
Lnoled1:
	movl	d0,heartbeat
Lnoled0:
#endif
	jbsr	_hardclock		| hardclock(&frame)
	addql	#4,sp
	CLKADDR(a0)
Lrecheck:
	addql	#1,_cnt+V_INTR		| chalk up another interrupt
	movb	a0@@(CLKSR),d0		| see if anything happened
	jmi	Lclkagain		|  while we were in hardclock/statintr
	INTERRUPT_RESTOREREG
	jra	rei			| all done

_lev7intr:	/* Level 7: Parity errors, reset key */
	addql	#1,_intrcnt+32
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-		| save registers
	movl	usp,a0			| and save
	movl	a0,sp@@(FR_SP)		|   the user stack pointer
	jbsr	_nmihand		| call handler
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| and remaining registers
	addql	#8,sp			| pop SP and stack adjust
	jra	rei			| all done

/*
 * Emulation of VAX REI instruction.
 *
 * This code deals with checking for and servicing ASTs
 * (profiling, scheduling) and software interrupts (network, softclock).
 * We check for ASTs first, just like the VAX.  To avoid excess overhead
 * the T_ASTFLT handling code will also check for software interrupts so we
 * do not have to do it here.  After identifing that we need an AST we
 * drop the IPL to allow device interrupts.
 *
 * This code is complicated by the fact that sendsig may have been called
 * necessitating a stack cleanup.
 */
	.comm	_ssir,1
	.globl	_astpending
	.globl	rei
rei:
	tstl	_astpending		| AST pending?
	jeq	Lchksir			| no, go check for SIR
Lrei1:
	btst	#5,sp@@			| yes, are we returning to user mode?
	jne	Lchksir			| no, go check for SIR
	movw	#PSL_LOWIPL,sr		| lower SPL
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
Lrei2:
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_ASTFLT,sp@@-		| type == async system trap
	jbsr	_trap			| go handle it
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
	jne	Laststkadj		| yes, go to it
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SP and stack adjust
	rte				| and do real RTE
Laststkadj:
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	rte				| and do real RTE
Lchksir:
	tstb	_ssir			| SIR pending?
	jeq	Ldorte			| no, all done
	movl	d0,sp@@-			| need a scratch register
	movw	sp@@(4),d0		| get SR
	andw	#PSL_IPL7,d0		| mask all but IPL
	jne	Lnosir			| came from interrupt, no can do
	movl	sp@@+,d0			| restore scratch register
Lgotsir:
	movw	#SPL1,sr		| prevent others from servicing int
	tstb	_ssir			| too late?
	jeq	Ldorte			| yes, oh well...
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
Lsir1:	
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_SSIR,sp@@-		| type == software interrupt
	jbsr	_trap			| go handle it
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| and all remaining registers
	addql	#8,sp			| pop SP and stack adjust
	rte
Lnosir:
	movl	sp@@+,d0			| restore scratch register
Ldorte:
	rte				| real return

/*
 * Macro to relocate a symbol, used before MMU is enabled.
 */
#define	RELOC(var, ar)		\
	lea	var,ar;		\
	addl	a5,ar

/*
 * Initialization
 *
 * A4 contains the address of the end of the symtab
 * A5 contains physical load point from boot
 * VBR contains zero from ROM.  Exceptions will continue to vector
 * through ROM until MMU is turned on at which time they will vector
 * through our table (vectors.s).
 */
	.comm	_lowram,4
	.comm	_esym,4

	.text
	.globl	_edata
	.globl	_etext,_end
	.globl	start
start:
	movw	#PSL_HIGHIPL,sr		| no interrupts
	RELOC(tmpstk, a0)
	movl	a0,sp			| give ourselves a temporary stack
	RELOC(_esym, a0)
#if 1
	movl	a4,a0@@			| store end of symbol table
#else
	clrl	a0@@			| no symbol table, yet
#endif
	RELOC(_lowram, a0)
	movl	a5,a0@@			| store start of physical memory
	movl	#CACHE_OFF,d0
	movc	d0,cacr			| clear and disable on-chip cache(s)
d925 8
a932 6
/* check for internal HP-IB in SYSFLAG */
	btst	#5,0xfffffed2		| internal HP-IB?
	jeq	Lhaveihpib		| yes, have HP-IB just continue
	RELOC(_internalhpib, a0)
	movl	#0,a0@@			| no, clear associated address
Lhaveihpib:
d934 2
a935 130
	RELOC(_boothowto, a0)		| save reboot flags
	movl	d7,a0@@
	RELOC(_bootdev, a0)		|   and boot device
	movl	d6,a0@@

	/*
	 * All data registers are now free.  All address registers
	 * except a5 are free.  a5 is used by the RELOC() macro,
	 * and cannot be used until after the MMU is enabled.
	 */

/* determine our CPU/MMU combo - check for all regardless of kernel config */
	movl	#INTIOBASE+MMUBASE,a1
	movl	#0x200,d0		| data freeze bit
	movc	d0,cacr			|   only exists on 68030
	movc	cacr,d0			| read it back
	tstl	d0			| zero?
	jeq	Lnot68030		| yes, we have 68020/68040
	RELOC(_mmutype, a0)		| no, we have 68030
	movl	#MMU_68030,a0@@		| set to reflect 68030 PMMU
	RELOC(_cputype, a0)
	movl	#CPU_68030,a0@@		| and 68030 CPU
	RELOC(_machineid, a0)
	movl	#0x80,a1@@(MMUCMD)	| set magic cookie
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#7,d0			| cookie still on?
	jeq	Lnot370			| no, 360 or 375
	movl	#0,a1@@(MMUCMD)		| clear magic cookie
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#7,d0			| still on?
	jeq	Lisa370			| no, must be a 370
	movl	#HP_340,a0@@		| yes, must be a 340
	jra	Lstart1
Lnot370:
	movl	#HP_360,a0@@		| type is at least a 360
	movl	#0,a1@@(MMUCMD)		| clear magic cookie2
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#16,d0			| still on?
	jeq	Lstart1			| no, must be a 360
	movl	#HP_375,a0@@		| yes, must be a 345/375
	jra	Lhaspac
Lisa370:
	movl	#HP_370,a0@@		| set to 370
Lhaspac:
	RELOC(_ectype, a0)
	movl	#EC_PHYS,a0@@		| also has a physical address cache
	jra	Lstart1
Lnot68030:
	bset	#31,d0			| data cache enable bit
	movc	d0,cacr			|   only exists on 68040
	movc	cacr,d0			| read it back
	tstl	d0			| zero?
	beq	Lis68020		| yes, we have 68020
	moveq	#0,d0			| now turn it back off
	movec	d0,cacr			|   before we access any data
	RELOC(_mmutype, a0)
	movl	#MMU_68040,a0@@		| with a 68040 MMU
	RELOC(_cputype, a0)
	movl	#CPU_68040,a0@@		| and a 68040 CPU
	RELOC(_ectype, a0)
	movl	#EC_NONE,a0@@		| and no cache (for now XXX)
	RELOC(_machineid, a0)
	movl	a1@@(MMUCMD),d0		| read MMU register
	lsrl	#8,d0			| get apparent ID
	cmpb	#6,d0			| id == 6?
	jeq	Lis33mhz		| yes, we have a 433s
	movl	#HP_380,a0@@		| no, we have a 380/425t
	jra	Lstart1
Lis33mhz:
	movl	#HP_433,a0@@		| 433s (XXX 425s returns same ID, ugh!)
	jra	Lstart1
Lis68020:
	movl	#1,a1@@(MMUCMD)		| a 68020, write HP MMU location
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#0,d0			| non-zero?
	jne	Lishpmmu		| yes, we have HP MMU
	RELOC(_mmutype, a0)
	movl	#MMU_68851,a0@@		| no, we have PMMU
	RELOC(_machineid, a0)
	movl	#HP_330,a0@@		| and 330 CPU
	jra	Lstart1
Lishpmmu:
	RELOC(_ectype, a0)		| 320 or 350
	movl	#EC_VIRT,a0@@		| both have a virtual address cache
	movl	#0x80,a1@@(MMUCMD)	| set magic cookie
	movl	a1@@(MMUCMD),d0		| read it back
	btst	#7,d0			| cookie still on?
	jeq	Lis320			| no, just a 320
	RELOC(_machineid, a0)
	movl	#HP_350,a0@@		| yes, a 350
	jra	Lstart1
Lis320:
	RELOC(_machineid, a0)
	movl	#HP_320,a0@@

Lstart1:
	movl	#0,a1@@(MMUCMD)		| clear out MMU again
/* initialize source/destination control registers for movs */
	moveq	#FC_USERD,d0		| user space
	movc	d0,sfc			|   as source
	movc	d0,dfc			|   and destination of transfers
/* initialize memory sizes (for pmap_bootstrap) */
	movl	#MAXADDR,d1		| last page
	moveq	#PGSHIFT,d2
	lsrl	d2,d1			| convert to page (click) number
	RELOC(_maxmem, a0)
	movl	d1,a0@@			| save as maxmem
	movl	a5,d0			| lowram value from ROM via boot
	lsrl	d2,d0			| convert to page number
	subl	d0,d1			| compute amount of RAM present
	RELOC(_physmem, a0)
	movl	d1,a0@@			| and physmem
/* configure kernel and proc0 VA space so we can get going */
	.globl	_Sysseg, _pmap_bootstrap, _avail_start
#ifdef DDB
	RELOC(_esym,a0)			| end of static kernel test/data/syms
	movl	a0@@,d5
	jne	Lstart2
#endif
	movl	#_end,d5		| end of static kernel text/data
Lstart2:
	addl	#NBPG-1,d5
	andl	#PG_FRAME,d5		| round to a page
	movl	d5,a4
	addl	a5,a4			| convert to PA
	pea	a5@@			| firstpa
	pea	a4@@			| nextpa
	RELOC(_pmap_bootstrap,a0)
	jbsr	a0@@			| pmap_bootstrap(firstpa, nextpa)
	addql	#8,sp
d938 4
a941 8
 * Prepare to enable MMU.
 * Since the kernel is not mapped logical == physical we must insure
 * that when the MMU is turned on, all prefetched addresses (including
 * the PC) are valid.  In order guarentee that, we use the last physical
 * page (which is conveniently mapped == VA) and load it up with enough
 * code to defeat the prefetch, then we execute the jump back to here.
 *
 * Is this all really necessary, or am I paranoid??
a942 30
	RELOC(_Sysseg, a0)		| system segment table addr
	movl	a0@@,d1			| read value (a KVA)
	addl	a5,d1			| convert to PA
	RELOC(_mmutype, a0)
	tstl	a0@@			| HP MMU?
	jeq	Lhpmmu2			| yes, skip
	cmpl	#MMU_68040,a0@@		| 68040?
	jne	Lmotommu1		| no, skip
	.long	0x4e7b1807		| movc d1,srp
	jra	Lstploaddone
Lmotommu1:
	RELOC(_protorp, a0)
	movl	#0x80000202,a0@@		| nolimit + share global + 4 byte PTEs
	movl	d1,a0@@(4)		| + segtable address
	pmove	a0@@,srp			| load the supervisor root pointer
	movl	#0x80000002,a0@@		| reinit upper half for CRP loads
	jra	Lstploaddone		| done
Lhpmmu2:
	moveq	#PGSHIFT,d2
	lsrl	d2,d1			| convert to page frame
	movl	d1,INTIOBASE+MMUBASE+MMUSSTP | load in sysseg table register
Lstploaddone:
	lea	MAXADDR,a2		| PA of last RAM page
	RELOC(Lhighcode, a1)		| addr of high code
	RELOC(Lehighcode, a3)		| end addr
Lcodecopy:
	movw	a1@@+,a2@@+		| copy a word
	cmpl	a3,a1			| done yet?
	jcs	Lcodecopy		| no, keep going
	jmp	MAXADDR			| go for it!
d944 6
a949 5
	/*
	 * BEGIN MMU TRAMPOLINE.  This section of code is not
	 * executed in-place.  It's copied to the last page
	 * of RAM (mapped va == pa) and executed there.
	 */
d951 4
a954 7
Lhighcode:
	/*
	 * Set up the vector table, and race to get the MMU
	 * enabled.
	 */
	movl	#_vectab,d0		| set Vector Base Register
	movc	d0,vbr
d956 7
a962 32
	RELOC(_mmutype, a0)
	tstl	a0@@			| HP MMU?
	jeq	Lhpmmu3			| yes, skip
	cmpl	#MMU_68040,a0@@		| 68040?
	jne	Lmotommu2		| no, skip
	movw	#0,INTIOBASE+MMUBASE+MMUCMD+2
	movw	#MMU_IEN+MMU_CEN+MMU_FPE,INTIOBASE+MMUBASE+MMUCMD+2
					| enable FPU and caches
	moveq	#0,d0			| ensure TT regs are disabled
	.long	0x4e7b0004		| movc d0,itt0
	.long	0x4e7b0005		| movc d0,itt1
	.long	0x4e7b0006		| movc d0,dtt0
	.long	0x4e7b0007		| movc d0,dtt1
	.word	0xf4d8			| cinva bc
	.word	0xf518			| pflusha
	movl	#0x8000,d0
	.long	0x4e7b0003		| movc d0,tc
	movl	#0x80008000,d0
	movc	d0,cacr			| turn on both caches
	jmp	Lenab1
Lmotommu2:
	movl	#MMU_IEN+MMU_FPE,INTIOBASE+MMUBASE+MMUCMD
					| enable 68881 and i-cache
	RELOC(_prototc, a2)
	movl	#0x82c0aa00,a2@@		| value to load TC with
	pmove	a2@@,tc			| load it
	jmp	Lenab1
Lhpmmu3:
	movl	#0,INTIOBASE+MMUBASE+MMUCMD	| clear external cache
	movl	#MMU_ENAB,INTIOBASE+MMUBASE+MMUCMD | turn on MMU
	jmp	Lenab1				| jmp to mapped code
Lehighcode:
d964 8
a971 3
	/*
	 * END MMU TRAMPOLINE.  Address register a5 is now free.
	 */
d973 15
a987 17
/*
 * Should be running mapped from this point on
 */
Lenab1:
/* select the software page size now */
	lea	tmpstk,sp		| temporary stack
	jbsr	_vm_set_page_size	| select software page size
/* set kernel stack, user SP, and initial pcb */
	movl	_proc0paddr,a1		| get proc0 pcb addr
	lea	a1@@(USPACE-4),sp	| set kernel stack to end of area
	lea	_proc0,a2		| initialize proc0.p_addr so that
	movl	a1,a2@@(P_ADDR)		|   we don't deref NULL in trap()
	movl	#USRSTACK-4,a2
	movl	a2,usp			| init user SP
	movl	a1,_curpcb		| proc0 is running
#ifdef FPCOPROC
	clrl	a1@@(PCB_FPCTX)		| ensure null FP context
d989 1
a989 1
	jbsr	_m68881_restore		| restore it (does not kill a1)
d991 40
d1032 22
a1053 14
/* flush TLB and turn on caches */
	jbsr	_TBIA			| invalidate TLB
	cmpl	#MMU_68040,_mmutype	| 68040?
	jeq	Lnocache0		| yes, cache already on
	movl	#CACHE_ON,d0
	movc	d0,cacr			| clear cache(s)
	tstl	_ectype
	jeq	Lnocache0
	MMUADDR(a0)
	orl	#MMU_CEN,a0@@(MMUCMD)	| turn on external cache
Lnocache0:
/* Final setup for call to main(). */
	jbsr	_isrinit		| initialize interrupt handlers
	jbsr	_hp300_calibrate_delay	| calibrate delay() loop
d1056 11
a1066 3
 * Create a fake exception frame so that cpu_fork() can copy it.
 * main() nevers returns; we exit to user mode from a forked process
 * later on.
d1068 61
a1128 23
	clrw	sp@@-			| vector offset/frame type
	clrl	sp@@-			| PC - filled in by "execve"
	movw	#PSL_USER,sp@@-		| in user mode
	clrl	sp@@-			| stack adjust count and padding
	lea	sp@@(-64),sp		| construct space for D0-D7/A0-A7
	lea	_proc0,a0		| save pointer to frame
	movl	sp,a0@@(P_MD_REGS)	|   in proc0.p_md.md_regs

	jra	_main			| main()

	pea	Lmainreturned		| Yow!  Main returned!
	jbsr	_panic
	/* NOTREACHED */
Lmainreturned:
	.asciz	"main() returned"
	.even

	.globl	_proc_trampoline
_proc_trampoline:
	movl	a3,sp@@-
	jbsr	a2@@
	addql	#4,sp
	movl	sp@@(FR_SP),a0		| grab and load
d1130 7
a1136 3
	moveml	sp@@+,#0x7FFF		| restore most user regs
	addql	#8,sp			| toss SP and stack adjust
	jra	rei			| and return
a1165 16
 * ..And HPUX versions of the above.  Hardcoded to use trap 2.
 */
	.globl	_hpux_sigcode, _hpux_esigcode
	.data
_hpux_sigcode:
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
	jsr	a0@@			| call signal handler	(2 bytes)
	addql	#4,sp			| pop signo		(2 bytes)
	trap	#2			| special syscall entry	(2 bytes)
	movl	d0,sp@@(4)		| save errno		(4 bytes)
	moveq	#1,d0			| syscall == exit	(2 bytes)
	trap	#0			| exit(errno)		(2 bytes)
	.align	2
_hpux_esigcode:

/*
d1172 1
a1172 1
 * non-local gotos
d1174 1
a1174 13
ENTRY(setjmp)
	movl	sp@@(4),a0	| savearea pointer
	moveml	#0xFCFC,a0@@	| save d2-d7/a2-a7
	movl	sp@@,a0@@(48)	| and return address
	moveq	#0,d0		| return 0
	rts

ENTRY(longjmp)
	movl	sp@@(4),a0
	moveml	a0@@+,#0xFCFC
	movl	a0@@,sp@@
	moveq	#1,d0
	rts
d1379 3
a1381 1
#ifdef FPCOPROC
a1388 1
#endif
d1462 3
a1464 1
#ifdef FPCOPROC
d1481 2
a1482 1
#endif
d1497 3
a1499 1
#ifdef FPCOPROC
a1506 1
#endif
a1925 24
ENTRY(_insque)
	movw	sr,d0
	movw	#PSL_HIGHIPL,sr		| atomic
	movl	sp@@(8),a0		| where to insert (after)
	movl	sp@@(4),a1		| element to insert (e)
	movl	a0@@,a1@@			| e->next = after->next
	movl	a0,a1@@(4)		| e->prev = after
	movl	a1,a0@@			| after->next = e
	movl	a1@@,a0
	movl	a1,a0@@(4)		| e->next->prev = e
	movw	d0,sr
	rts

ENTRY(_remque)
	movw	sr,d0
	movw	#PSL_HIGHIPL,sr		| atomic
	movl	sp@@(4),a0		| element to remove (e)
	movl	a0@@,a1
	movl	a0@@(4),a0
	movl	a0,a1@@(4)		| e->next->prev = e->prev
	movl	a1,a0@@			| e->prev->next = e->next
	movw	d0,sr
	rts

a1943 1
#ifdef FPCOPROC
a1967 1
#endif
d2045 2
a2046 1
	.globl	_machineid,_mmutype,_cputype,_ectype,_protorp,_prototc
d2055 2
@


1.11
log
@hp300 portion of the copypage/zeropage/mappedcopy changes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.10 1997/02/05 17:30:23 downsj Exp $	*/
d1159 1
a1159 1
	.globl	_sigcode, _esigcode, _sigcodetrap
a1164 1
_sigcodetrap:
d1171 16
@


1.10
log
@Pull in some of the changes from NetBSD's revision 1.63:
thorpej
Sat Feb  1 23:55:54 PST 1997
...
- Eliminate some unnecessary cpu/mmu checks, based on what CPUs
  the kernel was compiled for.
- Add some comments about possible further optimization.
...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.9 1997/02/03 15:54:43 deraadt Exp $	*/
a1177 32

/*
 * copypage(fromaddr, toaddr)
 *
 * Optimized version of bcopy for a single page-aligned NBPG byte copy.
 */
ENTRY(copypage)
	movl	sp@@(4),a0		| source address
	movl	sp@@(8),a1		| destination address
	movl	#NBPG/32,d0		| number of 32 byte chunks
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jne	Lmlloop			| no, use movl
Lm16loop:
	.long	0xf6209000		| move16 a0@@+,a1@@+
	.long	0xf6209000		| move16 a0@@+,a1@@+
	subql	#1,d0
	jne	Lm16loop
	rts
#endif
Lmlloop:
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	subql	#1,d0
	jne	Lmlloop
	rts
@


1.9
log
@mv siginfo_t * to the proper place
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.8 1997/02/03 04:47:56 downsj Exp $	*/
/*	$NetBSD: locore.s,v 1.62 1996/11/06 20:19:30 cgd Exp $	*/
d136 1
d139 1
d173 1
d176 1
d224 1
d227 1
d299 1
a299 1
_fpfline:
d316 1
a316 1
_fpunsupp:
d1470 1
d1473 1
d1485 1
d1488 1
d1518 1
d1521 1
@


1.8
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.7 1997/01/12 15:13:22 downsj Exp $	*/
d1145 1
a1145 1
 *	sp+4	signal specific code
d1147 2
a1148 3
 *	sp+12	pointer to siginfo (sip)
 *	sp+16	address of handler
 *	sp+20	saved hardware state
d1156 1
a1156 1
	movl	sp@@(16),a0		| signal handler addr	(4 bytes)
@


1.7
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 29
d1147 3
a1149 2
 *	sp+12	address of handler
 *	sp+16	saved hardware state
d1157 1
a1157 1
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
@


1.6
log
@remrq -> remrunqueue
@
text
@d1 2
a2 1
/*	$NetBSD: locore.s,v 1.53 1996/05/17 16:32:28 thorpej Exp $	*/
d5 1
d61 5
a77 12
/*
 * This is where we wind up if the kernel jumps to location 0.
 * (i.e. a bogus PC)  This is known to immediately follow the vector
 * table and is hence at 0x400 (see reset vector in vectors.s).
 */
	.globl	_panic
	pea	Ljmp0panic
	jbsr	_panic
	/* NOTREACHED */
Ljmp0panic:
	.asciz	"kernel jump to zero"
	.even
d96 5
d194 10
a203 1
	ptestr	#1,a0@@,#7		| do a table search
d205 14
a218 4
	btst	#7,sp@@			| bus error bit set?
	jeq	Lismerr			| no, must be MMU fault
	clrw	sp@@			| yes, re-clear pad word
	jra	Lisberr			| and process as normal bus error
d235 2
d315 5
d474 13
d488 2
a489 1
 *	- KGDB traps
d491 1
a491 1
 * We just pass it on and let trap() sort it all out
d494 1
a494 1
	clrl	sp@@-
a495 1
#ifdef KGDB
d498 24
a521 9
	andw	#PSL_S,d1		| from user mode?
	jeq	fault			| yes, just a regular fault
	movl	d0,sp@@-
	.globl	_kgdb_trap_glue
	jbsr	_kgdb_trap_glue		| returns if no debugger
	addl	#4,sp
#endif
	moveq	#T_TRAP15,d0
	jra	fault
d523 10
a532 7
/*
 * Hit a breakpoint (trap 1 or 2) instruction.
 * Push the code and treat as a normal fault.
 */
_trace:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
d534 7
a540 7
	moveq	#T_TRACE,d0
	movw	sp@@(FR_HW),d1		| get SSW
	andw	#PSL_S,d1		| from user mode?
	jeq	fault			| no, regular fault
	movl	d0,sp@@-
	jbsr	_kgdb_trap_glue		| returns if no debugger
	addl	#4,sp
d542 26
a567 2
	moveq	#T_TRACE,d0
	jra	fault
d773 5
a777 2
#define	RELOC(var, ar)	\
	lea	var,ar;	\
d811 18
d838 2
d875 2
d990 6
d997 7
d1027 1
d1037 4
a1044 5
/* check for internal HP-IB in SYSFLAG */
	btst	#5,0xfffffed2		| internal HP-IB?
	jeq	Lfinish			| yes, have HP-IB just continue
	clrl	_internalhpib		| no, clear associated address
Lfinish:
d1051 2
d1073 3
a1075 8
/* final setup for C code */
	movl	#_vectab,d0		| set Vector Base Register
	movc	d0,vbr
	jbsr	_isrinit		| be ready for stray ints
	jbsr	_hp300_calibrate_delay	| calibrate delay
	movw	#PSL_LOWIPL,sr		| lower SPL
	movl	d7,_boothowto		| save reboot flags
	movl	d6,_bootdev		|   and boot device
d1092 7
d1196 4
a1199 4
 * into queues, Remrq removes them from queues.  The running process is on
 * no queue, other processes are on a queue related to p->p_priority, divided
 * by 4 actually to shrink the 0-127 range of priorities into the 32 available
 * queues.
d2039 7
d2055 1
a2055 1
	jmp	0x1A4			| goto REQ_REBOOT
d2063 1
a2063 1
	jmp	0x1A4			| goto REQ_REBOOT
d2070 1
a2070 1
	jmp	0x1A4			| goto REQ_REBOOT
d2074 2
d2077 1
a2077 1
	.globl	_machineid
d2079 1
a2079 2
	.long	0		| default to 320
	.globl	_mmutype,_protorp
d2081 5
a2085 1
	.long	0		| default to HP MMU
d2088 2
a2089 3
	.globl	_ectype
_ectype:
	.long	0		| external cache type, default to none
d2100 1
a2100 1
	.globl	_proc0paddr
d2113 2
@


1.5
log
@sync to 0622
@
text
@d1126 1
a1126 1
ENTRY(remrq)
d1155 1
a1155 1
	.asciz	"remrq"
@


1.4
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.50 1996/02/14 02:56:56 thorpej Exp $	*/
d45 1
a45 2
#include "assym.s"
#include <hp300/hp300/vectors.s>
d51 8
d68 2
d488 2
a489 36
/*
 * The sigreturn() syscall comes here.  It requires special handling
 * because we must open a hole in the stack to fill in the (possibly much
 * larger) original stack frame.
 */
sigreturn:
	lea	sp@@(-84),sp		| leave enough space for largest frame
	movl	sp@@(84),sp@@		| move up current 8 byte frame
	movl	sp@@(88),sp@@(4)
	movl	#84,sp@@-		| default: adjust by 84 bytes
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	#SYS_sigreturn,sp@@-	| push syscall number
	jbsr	_syscall		| handle it
	addql	#4,sp			| pop syscall#
	movl	sp@@(FR_SP),a0		| grab and restore
	movl	a0,usp			|   user SP
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	movw	sp@@(FR_ADJ),d0		| do we need to adjust the stack?
	jeq	Lsigr1			| no, just continue
	moveq	#92,d1			| total size
	subw	d0,d1			|  - hole size = frame size
	lea	a1@@(92),a0		| destination
	addw	d1,a1			| source
	lsrw	#1,d1			| convert to word count
	subqw	#1,d1			| minus 1 for dbf
Lsigrlp:
	movw	a1@@-,a0@@-		| copy a word
	dbf	d1,Lsigrlp		| continue
	movl	a0,a1			| new HW frame base
Lsigr1:
	movl	a1,sp@@(FR_SP)		| new SP value
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	jra	rei			| all done
d745 1
a745 1
	movl	#5,a0@@			| yes, must be a 340
d748 1
a748 1
	movl	#3,a0@@			| type is at least a 360
d753 1
a753 1
	movl	#6,a0@@			| yes, must be a 345/375
d756 1
a756 1
	movl	#4,a0@@			| set to 370
d759 1
a759 1
	movl	#-1,a0@@			| also has a physical address cache
d772 1
a772 1
	movl	#0,a0@@			| and no cache (for now XXX)
d778 1
a778 1
	movl	#7,a0@@			| no, we have a 380/425t
d781 1
a781 1
	movl	#8,a0@@			| 433s (XXX 425s returns same ID, ugh!)
d791 1
a791 1
	movl	#1,a0@@			| and 330 CPU
d795 1
a795 1
	movl	#1,a0@@			| both have a virtual address cache
d799 1
a799 1
	jeq	Lstart1			| no, just a 320
d801 5
a805 1
	movl	#2,a0@@			| yes, a 350
d953 2
d956 1
d1831 18
@


1.3
log
@sync with netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.47 1996/01/16 22:24:28 thorpej Exp $	*/
d518 3
a520 11
 * All DIO device interrupts are auto-vectored.  Most can be configured
 * to interrupt in the range IPL3 to IPL5.  Here are our assignments:
 *
 *	Level 0:	Spurious: ignored.
 *	Level 1:	HIL
 *	Level 2:
 *	Level 3:	Internal HP-IB, DCM
 *	Level 4:	"Fast" HP-IBs, SCSI
 *	Level 5:	DMA, Ethernet, Built-in RS232 (DCA)
 *	Level 6:	Clock
 *	Level 7:	Non-maskable: parity errors, RESET key
a521 2
	.globl	_hilint, _intrhand, _hardclock, _nmihand, _dmaintr
	.globl	_dcafastservice
d523 8
a530 1
_spurintr:
d535 2
a536 2
_lev1intr:
	moveml	#0xC0C0,sp@@-
d538 1
a538 1
	moveml	sp@@+,#0x0303
d543 5
a547 11
/*
 * Check for unbuffered serial port (DCA) interrupts first in an attempt
 * to minimize received character lossage.  Then we check for DMA activity
 * to reduce overhead there.
 */
_lev5intr:
	moveml	#0xC0C0,sp@@-
	tstl	_dcafastservice		| unbuffered port active?
	jeq	Ltrydma			| no, check DMA
	clrl	sp@@-			| yes, check DCA port 0
	jbsr	_dcaintr		|    first to avoid overflow
d549 2
a550 31
	tstl	d0			| did it belong to DCA?
	jeq	Ltrydma			| no, go try DMA
	moveml	sp@@+,#0x0303
	addql	#1,_intrcnt+20
	addql	#1,_cnt+V_INTR
	jra	rei
Ltrydma:
	jbsr	_dmaintr		| check DMA channels
	tstl	d0 			| was it ours?
	jeq	Lnotdma			| no, go poll other devices
	moveml	sp@@+,#0x0303
	addql	#1,_intrcnt+24
	addql	#1,_cnt+V_INTR
	jra	rei

_lev2intr:
_lev3intr:
_lev4intr:
	moveml	#0xC0C0,sp@@-
Lnotdma:
	lea	_intrcnt,a0
	movw	sp@@(22),d0		| use vector offset
	andw	#0xfff,d0		|   sans frame type
	addql	#1,a0@@(-0x60,d0:w)	|     to increment apropos counter
	movw	sr,sp@@-			| push current SR value
	clrw	sp@@-			|    padded to longword
	jbsr	_intrhand		| handle interrupt
	addql	#4,sp			| pop SR
	moveml	sp@@+,#0x0303
	addql	#1,_cnt+V_INTR
	jra	rei
d552 2
a553 2
_lev6intr:
	moveml	#0xC0C0,sp@@-		| save scratch registers
d564 1
a564 1
	addql	#1,_intrcnt+32		| count clock interrupts
d575 1
a575 1
	addql	#1,_intrcnt+28		| count hardclock interrupts
d618 1
a618 1
	moveml	sp@@+,#0x0303		| restore scratch registers
d621 2
a622 2
_lev7intr:
	addql	#1,_intrcnt+36
a2000 1
	.asciz	"dma"
d2007 1
a2007 1
	.long	0,0,0,0,0,0,0,0,0,0
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 3
/*	$NetBSD: locore.s,v 1.46 1995/12/11 17:09:11 thorpej Exp $	*/

#undef STACKCHECK	/* doesn't work any more */
a44 13
/*
 * STACKCHECK enables two types of kernel stack checking:
 *	1. stack "overflow".  On every clock interrupt we ensure that
 *	   the current kernel stack has not grown into the user struct
 *	   page, i.e. size exceeded UPAGES-1 pages.
 *	2. stack "underflow".  Before every rte to user mode we ensure
 *	   that we will be exactly at the base of the stack after the
 *	   exception frame has been popped.
 * Both checks are performed at splclock since they operate on the
 * global temporary stack.
 */
/* #define	STACKCHECK */

a404 3
#ifdef STACKCHECK
	jra	Ldorte
#else
a405 1
#endif
a590 20
#ifdef STACKCHECK
	.globl	_panicstr,_badkstack
	cmpl	#_kstack+NBPG,sp	| are we still in stack page?
	jcc	Lstackok		| yes, continue normally
	tstl	_curproc		| if !curproc could have switch_exited,
	jeq	Lstackok		|     might be on tmpstk
	tstl	_panicstr		| have we paniced?
	jne	Lstackok		| yes, do not re-panic
	movl	sp@@(4),tmpstk-4		| no, copy common
	movl	sp@@,tmpstk-8		|  frame info
	movl	sp,tmpstk-16		| no, save original SP
	lea	tmpstk-16,sp		| switch to tmpstk
	moveml	#0xFFFE,sp@@-		| push remaining registers
	movl	#1,sp@@-			| is an overflow
	jbsr	_badkstack		| badkstack(1, frame)
	addql	#4,sp
	moveml	sp@@+,#0x7FFF		| restore most registers
	movl	sp@@,sp			| and SP
Lstackok:
#endif
a688 4
#ifdef STACKCHECK
	tstl	_panicstr		| have we paniced?
	jne	Ldorte1			| yes, do not make matters worse
#endif
a710 3
#ifdef STACKCHECK
	jra	Ldorte
#else
a711 1
#endif
a721 3
#ifdef STACKCHECK
	jra	Ldorte
#else
a722 1
#endif
a748 3
#ifdef STACKCHECK
	jra	Ldorte
#else
a749 1
#endif
a752 36
#ifdef STACKCHECK
	movw	#SPL6,sr		| avoid trouble
	btst	#5,sp@@			| are we returning to user mode?
	jne	Ldorte1			| no, skip it
	movl	a6,tmpstk-20
	movl	d0,tmpstk-76
	moveq	#0,d0
	movb	sp@@(6),d0		| get format/vector
	lsrl	#3,d0			| convert to index
	lea	_exframesize,a6		|  into exframesize
	addl	d0,a6			|  to get pointer to correct entry
	movw	a6@@,d0			| get size for this frame
	addql	#8,d0			| adjust for unaccounted for bytes
	lea	_kstackatbase,a6	| desired stack base
	subl	d0,a6			|   - frame size == our stack
	cmpl	a6,sp			| are we where we think?
	jeq	Ldorte2			| yes, skip it
	lea	tmpstk,a6		| will be using tmpstk
	movl	sp@@(4),a6@@-		| copy common
	movl	sp@@,a6@@-		|   frame info
	clrl	a6@@-
	movl	sp,a6@@-			| save sp
	subql	#4,a6			| skip over already saved a6
	moveml	#0x7FFC,a6@@-		| push remaining regs (d0/a6/a7 done)
	lea	a6@@(-4),sp		| switch to tmpstk (skip saved d0)
	clrl	sp@@-			| is an underflow
	jbsr	_badkstack		| badkstack(0, frame)
	addql	#4,sp
	moveml	sp@@+,#0x7FFF		| restore most registers
	movl	sp@@,sp			| and SP
	rte
Ldorte2:
	movl	tmpstk-76,d0
	movl	tmpstk-20,a6
Ldorte1:
#endif
a753 12

#ifdef STACKCHECK
/*
 * Kernel access to the current processes kernel stack is via a fixed
 * virtual address.  It is at the same address as in the users VA space.
 */
	.data
	.set	_kstack,USRSTACK
	.set	_kstackatbase,USRSTACK+USPACE-4
	.globl	_kstackatbase
	.globl	_kstack
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.44 1995/10/08 20:19:22 thorpej Exp $	*/
d112 2
a113 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d147 2
a148 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d196 1
a196 1
#if defined(HP330) || defined(HP360) || defined(HP370)
d208 1
a208 1
#if defined(HP320) || defined(HP350)
d250 1
a250 1
#if defined(HP380)
d267 2
a268 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d901 1
a901 1
	movl	#-1,a0@@			| set to reflect 68030 PMMU
d936 1
a936 1
	movl	#-2,a0@@			| with a 68040 MMU
d955 1
a955 1
	movl	#1,a0@@			| no, we have PMMU
d1021 1
a1021 1
	cmpl	#-2,a0@@			| 68040?
d1050 1
a1050 1
	cmpl	#-2,a0@@			| 68040?
d1105 1
a1105 1
	cmpl	#-2,_mmutype		| 68040?
d1189 2
a1190 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d1470 2
a1471 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d1483 1
a1483 1
#if defined(HP330) || defined(HP360) || defined(HP370)
d1496 1
a1496 1
#if defined(HP320) || defined(HP350)
d1514 2
a1515 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d1552 1
a1552 1
#if defined(HP380)
d1585 2
a1586 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d1592 1
a1592 1
#if defined(HP330) || defined(HP360) || defined(HP370)
a1595 1
#if defined(HP360) || defined(HP370)
a1599 1
#endif
d1603 1
a1603 1
#if defined(HP320) || defined(HP350)
d1622 2
a1623 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d1637 1
a1637 1
#if defined(HP330) || defined(HP360) || defined(HP370)
a1640 1
#if defined(HP360) || defined(HP370)
a1646 1
#endif
d1651 1
a1651 1
#if defined(HP320) || defined(HP350)
d1675 2
a1676 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d1682 1
a1682 1
#if defined(HP330) || defined(HP360) || defined(HP370)
a1684 1
#if defined(HP360) || defined(HP370)
a1690 1
#endif
d1695 1
a1695 1
#if defined(HP320) || defined(HP350)
d1714 2
a1715 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d1721 1
a1721 1
#if defined(HP330) || defined(HP360) || defined(HP370)
a1723 1
#if defined(HP360) || defined(HP370)
a1729 1
#endif
d1734 1
a1734 1
#if defined(HP320) || defined(HP350)
d1749 1
a1749 1
#if defined(HP380)
d1751 1
a1751 1
	cmpl	#-2,_mmutype		| 68040
d1771 2
a1772 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040
d1778 1
a1778 1
#if defined(HP320) || defined(HP350)
d1790 2
a1791 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040
d1797 1
a1797 1
#if defined(HP320) || defined(HP350)
d1809 2
a1810 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040
d1816 1
a1816 1
#if defined(HP320) || defined(HP350)
d1826 1
a1826 1
#if defined(HP380)
d1857 1
a1857 1
#if defined(HP380)
d1859 1
a1859 1
	cmpl	#-2,_mmutype		| 68040
d1865 1
a1865 1
#if defined(HP360) || defined(HP370)
d1905 1
a1905 1
#if defined(HP330) || defined(HP360) || defined(HP370) || defined(HP380)
d1911 2
a1912 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d1926 1
a1926 1
#if defined(HP320) || defined(HP350)
d1933 1
a1933 1
#if defined(HP330) || defined(HP360) || defined(HP370)
d1935 8
d1944 1
a1991 76
/*
 * {ov}bcopy(from, to, len)
 * memcpy(to, from len)
 *
 * Works for counts up to 128K.
 */
ENTRY(memcpy)
	movl	sp@@(12),d0		| get count
	jeq	Lcpyexit		| if zero, return
	movl	sp@@(8), a0		| src address
	movl	sp@@(4), a1		| dest address
	jra	Ldocopy			| jump into bcopy
ALTENTRY(ovbcopy, _bcopy)
ENTRY(bcopy)
	movl	sp@@(12),d0		| get count
	jeq	Lcpyexit		| if zero, return
	movl	sp@@(4),a0		| src address
	movl	sp@@(8),a1		| dest address
Ldocopy:
	cmpl	a1,a0			| src before dest?
	jlt	Lcpyback		| yes, copy backwards (avoids overlap)
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lcfeven			| no, go check dest
	movb	a0@@+,a1@@+		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lcpyexit		| exit if done
Lcfeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lcfbyte			| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lcfbyte			| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lcflloop:
	movl	a0@@+,a1@@+		| copy longwords
	dbf	d1,Lcflloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lcpyexit		| done if none
Lcfbyte:
	subql	#1,d0			| set up for dbf
Lcfbloop:
	movb	a0@@+,a1@@+		| copy bytes
	dbf	d0,Lcfbloop		| til done
Lcpyexit:
	rts
Lcpyback:
	addl	d0,a0			| add count to src
	addl	d0,a1			| add count to dest
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lcbeven			| no, go check dest
	movb	a0@@-,a1@@-		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lcpyexit		| exit if done
Lcbeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lcbbyte			| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lcbbyte			| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lcblloop:
	movl	a0@@-,a1@@-		| copy longwords
	dbf	d1,Lcblloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lcpyexit		| done if none
Lcbbyte:
	subql	#1,d0			| set up for dbf
Lcbbloop:
	movb	a0@@-,a1@@-		| copy bytes
	dbf	d0,Lcbbloop		| til done
	rts

d2029 2
a2030 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d2035 2
a2036 3
#if defined(HP320) || defined(HP350) || defined(HP370)
	tstl	_ectype
	jeq	Lnocache5
a2038 1
#endif
d2049 2
a2050 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d2059 2
a2060 2
#if defined(HP380)
	cmpl	#-2,_mmutype		| 68040?
d2069 1
a2069 1
#if defined(HP330) || defined(HP360) || defined(HP370)
d2077 1
a2077 1
#if defined(HP320) || defined(HP350)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
