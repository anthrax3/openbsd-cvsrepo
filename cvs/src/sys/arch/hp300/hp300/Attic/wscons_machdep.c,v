head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.12
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.8
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.6
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.8
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.12;

1.12
date	2011.08.18.20.02.58;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.15.20.38.11;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2006.12.18.18.57.26;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.14.21.05.44;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.01.11.59.39;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.31.18.13.44;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.13.23.13.45;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.27.22.10.57;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.24.21.36.39;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.22.39.28;	author miod;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: wscons_machdep.c,v 1.12 2011/08/18 20:02:58 miod Exp $	*/

/*
 * Copyright (c) 2005, 2011, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 2002 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/hp300spu.h>

#include <dev/cons.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include "wsdisplay.h"
#include "wskbd.h"
#if NWSKBD > 0
#include <dev/wscons/wskbdvar.h>
#endif

#include "dvbox.h"
#include "gbox.h"
#include "hyper.h"
#include "rbox.h"
#include "sti.h"
#include "topcat.h"
#include "tvrx.h"

#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NSTI_DIO > 0 || NTOPCAT > 0 || NTVRX > 0
#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diofbreg.h>
#include <hp300/dev/diofbvar.h>
struct diofb diofb_cn;
#endif

#if NSTI > 0
#include <hp300/dev/sgcreg.h>
#include <hp300/dev/sgcvar.h>
#include <dev/ic/stireg.h>
#include <dev/ic/stivar.h>
#include <hp300/dev/sti_machdep.h>
#endif

extern struct hp300_bus_space_tag hp300_mem_tag;
extern caddr_t internalhpib;

cons_decl(ws);

void (*wsfbcninit)(void) = NULL;

#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NSTI_DIO > 0 || NTOPCAT > 0 || NTVRX > 0
int	dio_fbidentify(int, struct diofbreg *);

/*
 * Identify a DIO frame buffer and set up wsfbcninit accordingly.
 */
int
dio_fbidentify(int scode, struct diofbreg *fbr)
{
	if (fbr->id == GRFHWID)
		switch (fbr->fbid) {
#if NDVBOX > 0
		case GID_DAVINCI:
			wsfbcninit = dvboxcninit;
			return (1);
#endif
#if NGBOX > 0
		case GID_GATORBOX:
			wsfbcninit = gboxcninit;
			return (1);
#endif
#if NHYPER > 0
		case GID_HYPERION:
			wsfbcninit = hypercninit;
			return (1);
#endif
#if NRBOX > 0
		case GID_RENAISSANCE:
			wsfbcninit = rboxcninit;
			return (1);
#endif
#if NSTI_DIO > 0
		case GID_FB3X2_A:
		case GID_FB3X2_B:
			if (scode >= 0 && sti_dio_probe(scode) != 0) {
				wsfbcninit = sticninit;
				return (1);
			}
			break;
#endif
#if NTOPCAT > 0
		case GID_TOPCAT:
		case GID_LRCATSEYE:
		case GID_HRCCATSEYE:
		case GID_HRMCATSEYE:
			wsfbcninit = topcatcninit;
			return (1);
#endif
#if NTVRX > 0
		case GID_TIGER:
			wsfbcninit = tvrxcninit;
			return (1);
#endif
		default:
			break;
		}

	return (0);
}
#endif

/*
 * This routine handles the dirty work of picking the best frame buffer
 * suitable for the console.
 * We try to behave as close as possible to the PROM's logic, by preferring
 * devices for which we have drivers, in that order:
 * - internal video.
 * - lowest select code on DIO bus.
 * - lowest slot on SGC bus.
 */
void
wscnprobe(struct consdev *cp)
{
	int maj, tmpconscode;
	vsize_t mapsize;
	vaddr_t va;
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NSTI_DIO > 0 || NTOPCAT > 0 || NTVRX > 0
	paddr_t pa;
	u_int scode, sctop, sctmp;
	struct diofbreg *fbr;
#endif

	for (maj = 0; maj < nchrdev; maj++) {
		if (cdevsw[maj].d_open == wsdisplayopen)
			break;
	}

	cp->cn_dev = makedev(maj, 0);
	wsfbcninit = NULL;

#if NDVBOX > 0 || NGBOX > 0 || NRBOX > 0 || NTOPCAT > 0
	/*
	 * Look for an ``internal'' frame buffer.
	 */
	va = IIOV(GRFIADDR);
	fbr = (struct diofbreg *)va;
	if (!badaddr((caddr_t)va)) {
		if (dio_fbidentify(-1, fbr)) {
			tmpconscode = CONSCODE_INTERNAL;
			mapsize = 0;
			goto found;
		}
	}
#endif

#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NSTI_DIO > 0 || NTOPCAT > 0 || NTVRX > 0
	/*
	 * Scan the DIO bus.
	 */
	sctop = DIO_SCMAX(machineid);
	for (scode = 0; scode < sctop; scode++) {
		/*
		 * Skip over the select code hole and the internal
		 * HP-IB controller.
		 */
		if ((sctmp = dio_inhole(scode)) != 0) {
			scode = sctmp - 1;
			continue;
		}
		if (scode == 7 && internalhpib)
			continue;

		/* Map current PA. */
		pa = (paddr_t)dio_scodetopa(scode);
		va = (vaddr_t)iomap((caddr_t)pa, PAGE_SIZE);
		if (va == 0)
			continue;

		/* Check to see if hardware exists. */
		if (badaddr((caddr_t)va)) {
			iounmap((caddr_t)va, PAGE_SIZE);
			continue;
		}

		/* Check hardware. */
		fbr = (struct diofbreg *)va;
		if (dio_fbidentify(scode, fbr)) {
			tmpconscode = scode;
			mapsize = DIO_SIZE(scode, va);
			iounmap((caddr_t)va, PAGE_SIZE);

#if NSTI_DIO > 0
			if (wsfbcninit == sticninit) {
				mapsize = 0;
				va = 0;
			} else
#endif
			       {
				va = (vaddr_t)iomap((caddr_t)pa, mapsize);
				if (va == 0)
					continue;
			}
			goto found;
		} else
			iounmap((caddr_t)va, PAGE_SIZE);
	}
#endif

#if NSTI_SGC > 0
	/*
	 * Scan the SGC bus.
	 */
	for (scode = 0; scode < SGC_NSLOTS; scode++) {
		int rv;

		/* Map current PA. */
		pa = (paddr_t)sgc_slottopa(scode);
		va = (vaddr_t)iomap((caddr_t)pa, PAGE_SIZE);
		if (va == 0)
			continue;

		/* Check to see if hardware exists. */
		rv = badaddr((caddr_t)va);
		iounmap((caddr_t)va, PAGE_SIZE);
		if (rv != 0)
			continue;

		/* Check hardware. */
		if (sti_sgc_probe(&hp300_mem_tag, scode) != 0) {
			wsfbcninit = sticninit;
			tmpconscode = SGC_SLOT_TO_CONSCODE(scode);
			mapsize = 0;
			va = 0;
			goto found;
		}
	}
#endif

	return;

found:
	cp->cn_pri = CN_MIDPRI;
#ifdef CONSCODE
	if (CONSCODE == tmpconscode)
		cp->cn_pri = CN_FORCED;
#endif

	/*
	 * If our priority is higher than the currently remembered console,
	 * install ourselves, and unmap whichever device might be currently
	 * mapped.
	 */
	if (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri) {
		cn_tab = cp;
		/* Free last mapping. */
		if (convasize)
			iounmap(conaddr, convasize);
		conscode = tmpconscode;
		conaddr = (caddr_t)va;
		convasize = mapsize;
	}
}

void
wscninit(struct consdev *cp)
{
	/*
	 * Note that this relies on the fact that DIO frame buffers (except
	 * for sti@@dio) will cause cn_tab to switch to wsdisplaycons, so
	 * their cninit function will never get invoked a second time during
	 * the second console pass.
	 */
	if (wsfbcninit != NULL)
		(*wsfbcninit)();
}

void
wscnputc(dev_t dev, int i)
{
#if NWSDISPLAY > 0
	wsdisplay_cnputc(dev, i);
#endif
}

int
wscngetc(dev_t dev)
{
#if NWSKBD > 0
	return (wskbd_cngetc(dev));
#else
	return (0);
#endif
}

void
wscnpollc(dev_t dev, int on)
{
#if NWSKBD > 0
	wskbd_cnpollc(dev, on);
#endif
}
@


1.12
log
@So, it turns out that models 362 and 382 built-in frame buffer only shows up
in DIO-II space, as a fat device spanning four select codes (i.e. 16MB of
memory). This is way too much for an at-most 2 Mpixel 8bit frame buffer, and
it turns out that this is because the device provides both a regular DIO-II
frame buffer (spanning two select codes) and a regular STI frame buffer
(spanning the other two select codes).
This commit introduces a straightforward sti@@dio attachment to get a working
sti(4) and wsdisplay(4) in a ridiculously small number of lines; however
the console code needs some changes to avoid duplicating globals.

While there, add sti@@dio support for the bootblocks, and I couldn't help
myself but clean the most rotten parts of them, and try to have them reuse
various files in sys/arch/hp300/dev instead of rolling their outdated ones.

Tested on a real 382 with the low-resolution frame buffer:
sti0 at dio0 scode 132: rev 8.02;129, ID 0x27134CB440A00499
sti0: 382V, 2048x512 frame buffer, 640x480x8 display
sti0: 8x16 font type 1, 16 bpc, charset 0-255
wsdisplay0 at sti0 mux 1: console (std, vt100 emulation)

Boot blocks updates tested on DIO-II 425t (serial/glass console), SGC 425e
(serial/glass console) and 382 (serial/glass console). And will be tested
on SGC 425t soon as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.11 2011/04/07 15:30:15 miod Exp $	*/
@


1.11
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.10 2010/04/15 20:38:11 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005, Miodrag Vallat
d62 1
d82 1
d85 2
a86 1
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NTOPCAT > 0 || NTVRX > 0
a93 1
#include "sti.h"
a94 1
#include <machine/bus.h>
d99 1
a99 2
extern	int sti_console_scan(int);
extern	void sticninit(void);
d102 1
d109 2
a110 2
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NTOPCAT > 0 || NTVRX > 0
int	dio_fbidentify(struct diofbreg *);
d116 1
a116 1
dio_fbidentify(struct diofbreg *fbr)
d140 9
d185 1
a185 1
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NTOPCAT > 0 || NTVRX > 0
d206 1
a206 1
		if (dio_fbidentify(fbr)) {
d214 1
a214 1
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NTOPCAT > 0 || NTVRX > 0
d245 1
a245 1
		if (dio_fbidentify(fbr)) {
d249 12
a260 3
			va = (vaddr_t)iomap((caddr_t)pa, mapsize);
			if (va == 0)
				continue;
d267 1
a267 1
#if NSTI > 0
d287 1
a287 1
		if (sti_console_scan(scode) != 0) {
d326 4
a329 3
	 * Note that this relies on the fact that DIO frame buffers will cause
	 * cn_tab to switch to wsdisplaycons, so their cninit function will
	 * never get invoked a second time during the second console pass.
@


1.10
log
@Turn DIO_INHOLE() into a function, returning the next select code to probe at;
and skip function codes 132 to 135, inclusive, on models 362 and 382 - this
is a fake DIO device probably intended to let non-SGC aware (i.e. legacy)
HP-UX lowlevel code be able to ``detect'' a frame buffer.

This change (as well as letting sgc attach) is untested due to the lack of any
3x2 hardware, but shouldn't make things worse.
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.9 2008/01/23 16:37:56 jsing Exp $	*/
d224 1
a224 1
		if (va == NULL)
d240 1
a240 1
			if (va == NULL)
d258 1
a258 1
		if (va == NULL)
@


1.9
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.8 2006/12/18 18:57:26 miod Exp $	*/
d177 1
a177 1
	u_int scode, sctop;
d214 5
a218 1
		if (DIO_INHOLE(scode) || (scode == 7 && internalhpib))
@


1.8
log
@Change sti attachment to pass an array of base addresses for the sti regions,
instead of using the rom mapping for region #0 and the device mapping for
region #1. This will allow sti devices on which regions may be relative to
different origins to attach (to be used very soon).

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.7 2006/04/14 21:05:44 miod Exp $	*/
d277 1
a277 1
	cp->cn_pri = CN_INTERNAL;
a295 1
		
@


1.7
log
@Minimal support for the HP98705 ``Tigershark'' TurboVRX frame buffer
(using an overlay plane only for now). Bootblocks, text console and X11
are supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.6 2006/01/01 11:59:39 miod Exp $	*/
a99 1
struct sti_screen stifb_cn;
@


1.6
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.5 2005/12/31 18:13:44 miod Exp $	*/
d82 2
a83 1
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NTOPCAT > 0
d109 1
a109 1
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NTOPCAT > 0
d148 5
d176 1
a176 1
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NTOPCAT > 0
d205 1
a205 1
#if NDVBOX > 0 || NGBOX > 0 || NHYPER > 0 || NRBOX > 0 || NTOPCAT > 0
@


1.5
log
@Rework (once again) the console code, in order to match the PROM's logic better.
When not running on serial console, the PROM will pick the ``internal''
graphics device, and if it does not exist, the DIO device with the lowest
select code, and will resort to SGC devices if no internal or DIO device
was found.

However, the current logic would search for a certain frame buffer type first,
then for its best hardware location, following the order they are listed
in conf.c.

By replacing gazillions of almost-exactly-duplicated frame buffer code with
one single instance, which is device type-agnostic, we can match the PROM
(and the bootblocks) logic again. Plus this saves a few KB of code!
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.4 2005/12/13 23:13:45 mickey Exp $	*/
a181 1
	cp->cn_pri = CN_DEAD;
@


1.4
log
@remove ad clause that got copied from older versions of the files; pto by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.3 2005/02/27 22:10:57 miod Exp $	*/
d4 24
d61 4
d77 8
d87 2
d93 2
d97 141
a239 1
struct diofb diofb_cn;
d241 36
a276 1
struct sti_screen stifb_cn;
d279 28
a306 1
cons_decl(ws);
@


1.3
log
@Split sti softc in two structures, one device-related for regular device
attachment and interface, one screen-attached for the real work.

The attachment code is now required to decide whether sti_end_attach() is
run immediately, or as a startuphook.

This allows hp300 to initialize sti early, and use it as a console; hppa
is functionally unchanged, as it uses the PROM console until the root device
is mounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.2 2005/01/24 21:36:39 miod Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
@


1.2
log
@Switch hp300 wscons code to rasops, for DIO frame buffers.
Features:
- coloured kernel messages
- color support in console (use TERM=wsvt25)
- pretty Gallant wsfont, rather than the acceptable or ugly (depending upon
  the frame buffer) ROM font
- colormap ioctl support for Gatorbox and Topcat; DaVinci and Renaissance
  not done due to lack of hardware and/or documentation
- even more code factorization

tested on hyperion, and 4/6/8bpp catseye/topcat/kathmandu hardware, by
millert@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: wscons_machdep.c,v 1.1 2005/01/14 22:39:28 miod Exp $	*/
d55 7
d63 3
@


1.1
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 2
#include "wsdisplay.h"
#if NWSDISPLAY > 0
d44 1
a44 1
#endif
d46 1
@

