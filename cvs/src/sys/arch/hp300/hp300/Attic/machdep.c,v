head	1.142;
access;
symbols
	OPENBSD_5_5:1.140.0.4
	OPENBSD_5_5_BASE:1.140
	OPENBSD_5_4:1.137.0.2
	OPENBSD_5_4_BASE:1.137
	OPENBSD_5_3:1.136.0.2
	OPENBSD_5_3_BASE:1.136
	OPENBSD_5_2:1.135.0.4
	OPENBSD_5_2_BASE:1.135
	OPENBSD_5_1_BASE:1.135
	OPENBSD_5_1:1.135.0.2
	OPENBSD_5_0:1.132.0.2
	OPENBSD_5_0_BASE:1.132
	OPENBSD_4_9:1.129.0.4
	OPENBSD_4_9_BASE:1.129
	OPENBSD_4_8:1.129.0.2
	OPENBSD_4_8_BASE:1.129
	OPENBSD_4_7:1.126.0.2
	OPENBSD_4_7_BASE:1.126
	OPENBSD_4_6:1.122.0.4
	OPENBSD_4_6_BASE:1.122
	OPENBSD_4_5:1.120.0.4
	OPENBSD_4_5_BASE:1.120
	OPENBSD_4_4:1.120.0.2
	OPENBSD_4_4_BASE:1.120
	OPENBSD_4_3:1.117.0.2
	OPENBSD_4_3_BASE:1.117
	OPENBSD_4_2:1.115.0.2
	OPENBSD_4_2_BASE:1.115
	OPENBSD_4_1:1.110.0.4
	OPENBSD_4_1_BASE:1.110
	OPENBSD_4_0:1.110.0.2
	OPENBSD_4_0_BASE:1.110
	OPENBSD_3_9:1.107.0.2
	OPENBSD_3_9_BASE:1.107
	OPENBSD_3_8:1.101.0.4
	OPENBSD_3_8_BASE:1.101
	OPENBSD_3_7:1.101.0.2
	OPENBSD_3_7_BASE:1.101
	OPENBSD_3_6:1.91.0.4
	OPENBSD_3_6_BASE:1.91
	SMP_SYNC_A:1.91
	SMP_SYNC_B:1.91
	OPENBSD_3_5:1.91.0.2
	OPENBSD_3_5_BASE:1.91
	OPENBSD_3_4:1.87.0.2
	OPENBSD_3_4_BASE:1.87
	UBC_SYNC_A:1.86
	OPENBSD_3_3:1.84.0.2
	OPENBSD_3_3_BASE:1.84
	OPENBSD_3_2:1.81.0.4
	OPENBSD_3_2_BASE:1.81
	OPENBSD_3_1:1.81.0.2
	OPENBSD_3_1_BASE:1.81
	UBC_SYNC_B:1.81
	UBC:1.74.0.2
	UBC_BASE:1.74
	OPENBSD_3_0:1.65.0.2
	OPENBSD_3_0_BASE:1.65
	OPENBSD_2_9:1.40.0.6
	OPENBSD_2_9_BASE:1.40
	OPENBSD_2_8:1.40.0.4
	OPENBSD_2_8_BASE:1.40
	OPENBSD_2_7:1.40.0.2
	OPENBSD_2_7_BASE:1.40
	SMP:1.38.0.4
	SMP_BASE:1.38
	kame_19991208:1.38
	OPENBSD_2_6:1.38.0.2
	OPENBSD_2_6_BASE:1.38
	OPENBSD_2_5:1.35.0.2
	OPENBSD_2_5_BASE:1.35
	OPENBSD_2_4:1.34.0.2
	OPENBSD_2_4_BASE:1.34
	OPENBSD_2_3:1.31.0.2
	OPENBSD_2_3_BASE:1.31
	OPENBSD_2_2:1.27.0.2
	OPENBSD_2_2_BASE:1.27
	OPENBSD_2_1:1.26.0.2
	OPENBSD_2_1_BASE:1.26
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.142
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.141;

1.141
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.140;

1.140
date	2013.11.20.23.57.07;	author miod;	state Exp;
branches;
next	1.139;

1.139
date	2013.09.28.12.40.29;	author miod;	state Exp;
branches;
next	1.138;

1.138
date	2013.08.04.07.21.13;	author martin;	state Exp;
branches;
next	1.137;

1.137
date	2013.06.11.16.42.08;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2012.10.08.21.47.47;	author deraadt;	state Exp;
branches;
next	1.135;

1.135
date	2011.11.01.21.20.55;	author miod;	state Exp;
branches;
next	1.134;

1.134
date	2011.09.20.09.49.38;	author miod;	state Exp;
branches;
next	1.133;

1.133
date	2011.08.18.19.54.18;	author miod;	state Exp;
branches;
next	1.132;

1.132
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2011.06.05.19.41.06;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.129;

1.129
date	2010.07.02.19.57.14;	author tedu;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.29.20.30.31;	author guenther;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.126;

1.126
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.125;

1.125
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.124;

1.124
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.123;

1.123
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.122;

1.122
date	2009.06.15.17.01.25;	author beck;	state Exp;
branches;
next	1.121;

1.121
date	2009.06.03.21.30.19;	author beck;	state Exp;
branches;
next	1.120;

1.120
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2008.06.08.20.57.16;	author miod;	state Exp;
branches;
next	1.118;

1.118
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2008.01.04.19.10.31;	author miod;	state Exp;
branches;
next	1.116;

1.116
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.115;

1.115
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.27.17.31.56;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.23.20.33.46;	author pvalchev;	state Exp;
branches;
next	1.110;

1.110
date	2006.06.16.20.48.49;	author miod;	state Exp;
branches;
next	1.109;

1.109
date	2006.06.07.22.02.00;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2006.05.19.22.51.07;	author miod;	state Exp;
branches;
next	1.107;

1.107
date	2005.12.30.18.14.12;	author miod;	state Exp;
branches;
next	1.106;

1.106
date	2005.12.30.18.00.23;	author miod;	state Exp;
branches;
next	1.105;

1.105
date	2005.12.22.22.56.28;	author miod;	state Exp;
branches;
next	1.104;

1.104
date	2005.11.06.17.59.52;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2005.09.27.22.05.37;	author miod;	state Exp;
branches;
next	1.102;

1.102
date	2005.09.27.21.50.36;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2005.02.27.22.08.41;	author miod;	state Exp;
branches;
next	1.100;

1.100
date	2005.02.12.18.00.51;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2005.01.14.22.49.24;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2005.01.14.22.39.27;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2005.01.14.19.11.56;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2005.01.10.21.23.52;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2005.01.08.22.13.54;	author miod;	state Exp;
branches;
next	1.94;

1.94
date	2004.12.30.21.26.14;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2004.12.23.15.32.09;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2004.12.02.19.37.22;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2004.03.10.23.02.53;	author tom;	state Exp;
branches;
next	1.90;

1.90
date	2004.02.19.18.46.18;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2004.01.27.16.16.22;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2003.12.20.20.08.16;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.86;

1.86
date	2003.05.09.23.10.21;	author art;	state Exp;
branches;
next	1.85;

1.85
date	2003.04.06.18.54.18;	author ho;	state Exp;
branches;
next	1.84;

1.84
date	2003.01.04.22.11.44;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2002.12.17.23.11.31;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2002.12.10.23.34.36;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2002.03.23.13.28.33;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2002.03.14.20.31.30;	author mickey;	state Exp;
branches;
next	1.79;

1.79
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.78;

1.78
date	2002.02.24.23.33.47;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2002.01.16.20.51.45;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2001.12.06.18.53.01;	author millert;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2001.12.06.01.03.43;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2001.11.29.22.50.03;	author millert;	state Exp;
branches;
next	1.71;

1.71
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.70;

1.70
date	2001.11.28.13.57.18;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.68;

1.68
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.06.00.30.38;	author art;	state Exp;
branches;
next	1.65;

1.65
date	2001.09.20.17.02.30;	author mpech;	state Exp;
branches;
next	1.64;

1.64
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	2001.09.11.20.09.56;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2001.08.26.00.15.37;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2001.08.25.16.15.15;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.25.11.37.26;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.19.17.06.25;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.18.20.21.10;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.25.13.25.31;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.18.10.47.04;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.05.10.12.06;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.27.04.05.45;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.25.00.43.09;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.05.16.13.15;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.25.22.07.18;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.23.15.12.06;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.17.18.41.48;	author provos;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.15.01.57.49;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.10.17.02.34;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.10.01.34.54;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.05.22.33.34;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.05.20.56.34;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.04.22.48.59;	author aaron;	state Exp;
branches;
next	1.40;

1.40
date	2000.03.23.09.59.54;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2000.02.22.19.27.46;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	99.09.03.18.00.41;	author art;	state Exp;
branches
	1.38.4.1;
next	1.37;

1.37
date	99.05.22.21.22.22;	author weingart;	state Exp;
branches;
next	1.36;

1.36
date	99.04.23.03.11.55;	author downsj;	state Exp;
branches;
next	1.35;

1.35
date	99.02.04.23.00.24;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	98.05.04.06.29.03;	author downsj;	state Exp;
branches;
next	1.33;

1.33
date	98.04.25.22.19.48;	author downsj;	state Exp;
branches;
next	1.32;

1.32
date	98.04.25.08.27.23;	author downsj;	state Exp;
branches;
next	1.31;

1.31
date	98.03.06.17.33.32;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	98.02.09.06.26.19;	author dima;	state Exp;
branches;
next	1.29;

1.29
date	98.02.05.16.48.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	97.11.06.19.42.37;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	97.07.06.08.02.05;	author downsj;	state Exp;
branches;
next	1.26;

1.26
date	97.04.20.07.01.13;	author downsj;	state Exp;
branches;
next	1.25;

1.25
date	97.04.17.12.02.34;	author downsj;	state Exp;
branches;
next	1.24;

1.24
date	97.04.17.11.40.40;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	97.04.17.10.28.39;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	97.04.16.11.56.28;	author downsj;	state Exp;
branches;
next	1.21;

1.21
date	97.03.26.08.32.43;	author downsj;	state Exp;
branches;
next	1.20;

1.20
date	97.02.24.01.16.09;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	97.02.23.21.42.55;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	97.02.10.11.13.30;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	97.02.05.17.33.00;	author downsj;	state Exp;
branches;
next	1.16;

1.16
date	97.02.04.07.15.28;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.02.04.06.21.30;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.02.03.15.54.45;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.02.03.12.48.46;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.02.03.04.47.58;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.01.16.20.43.33;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.01.15.04.54.45;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.01.12.15.13.23;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.06.25.20.56.18;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.23.11.47.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.08.01.43.18;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.04.25.06.37.07;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.31.06.42.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.16.17.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.29.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.23;	author deraadt;	state Exp;
branches;
next	;

1.38.4.1
date	2000.03.02.07.04.27;	author niklas;	state Exp;
branches;
next	1.38.4.2;

1.38.4.2
date	2000.03.24.09.07.25;	author niklas;	state Exp;
branches;
next	1.38.4.3;

1.38.4.3
date	2001.07.04.10.15.46;	author niklas;	state Exp;
branches;
next	1.38.4.4;

1.38.4.4
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.38.4.5;

1.38.4.5
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.38.4.6;

1.38.4.6
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.38.4.7;

1.38.4.7
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.38.4.8;

1.38.4.8
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.38.4.9;

1.38.4.9
date	2003.03.27.23.19.21;	author niklas;	state Exp;
branches;
next	1.38.4.10;

1.38.4.10
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.38.4.11;

1.38.4.11
date	2003.06.07.11.11.35;	author ho;	state Exp;
branches;
next	1.38.4.12;

1.38.4.12
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.38.4.13;

1.38.4.13
date	2004.06.05.23.10.46;	author niklas;	state Exp;
branches;
next	;

1.74.2.1
date	2002.01.31.22.55.08;	author niklas;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	1.74.2.3;

1.74.2.3
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.142
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: machdep.c,v 1.141 2014/03/13 03:52:55 dlg Exp $	*/
/*	$NetBSD: machdep.c,v 1.121 1999/03/26 23:41:29 mycroft Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: machdep.c 1.74 92/12/20$
 *
 *	@@(#)machdep.c	8.10 (Berkeley) 4/20/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/exec.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/extent.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/signalvar.h>
#include <sys/tty.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/vnode.h>
#include <sys/sysctl.h>
#include <sys/syscallargs.h>
#include <sys/syslog.h>

#include <machine/db_machdep.h>
#ifdef DDB
#include <ddb/db_var.h>
#endif
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/hp300spu.h>
#include <machine/kcore.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/pte.h>

#include <dev/cons.h>

#include <net/if.h>
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>

#ifdef USELEDS
#include <hp300/hp300/leds.h>
#endif

/* the following is used externally (sysctl_hw) */
char	machine[] = MACHINE;	/* from <machine/param.h> */

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

extern paddr_t avail_start, avail_end;

int	physmem;		/* size of physical memory, in pages */

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = PSL_LOWIPL;

extern	u_int lowram;
extern	short exframesize[];

/*
 * Some storage space must be allocated statically because of the
 * early console initialization.
 */
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(8)];
extern int eiomapsize;

/* prototypes for local functions */
void	parityenable(void);
int	parityerror(struct frame *);
int	parityerrorfind(void);
void    identifycpu(void);
void    initcpu(void);
void	dumpmem(int *, int, int);
char	*hexstr(int, int);

/* functions called from locore.s */
void    dumpsys(void);
void	hp300_init(void);
void    straytrap(int, u_short);
void	nmihand(struct frame);

/*
 * Select code of console.  Set to CONSCODE_INTERNAL if console is on
 * "internal" framebuffer.
 */
int	conscode;
caddr_t	conaddr;		/* for drivers in cn_init() */
int	convasize;		/* size of mapped console device */

/*
 * Note that the value of delay_divisor is roughly
 * 2048 / cpuspeed (where cpuspeed is in MHz) on 68020
 * and 68030 systems.  See clock.c for the delay
 * calibration algorithm.
 */
int	cpuspeed;		/* relative cpu speed */
int	delay_divisor;		/* delay constant */

 /*
 * Early initialization, before main() is called.
 */
void
hp300_init()
{
	/*
	 * Tell the VM system about available physical memory.  The
	 * hp300 only has one segment.
	 */
	uvm_page_physload(atop(avail_start), atop(avail_end),
	    atop(avail_start), atop(avail_end), 0);

	/* Initialize the interrupt handlers. */
	intr_init();

	/* Calibrate the delay loop. */
	hp300_calibrate_delay();
}

/*
 * Console initialization: called early on from main,
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
 */
void
consinit()
{
	extern struct extent *extio;
	extern char *extiobase;

	/*
	 * Initialize some variables for sanity.
	 */
	convasize = 0;
	conscode = CONSCODE_INVALID;

	/*
	 * Initialize the bus extent.
	 */
	extio = extent_create("extio",
	    (u_long)extiobase, (u_long)extiobase + ptoa(eiomapsize),
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);

	/*
	 * Initialize the console before we print anything out.
	 */
	hp300_cninit();

#ifdef DDB
	ddb_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif
}

/*
 * cpu_startup: allocate memory for variable-sized tables,
 * initialize cpu, and do autoconfiguration.
 */
void
cpu_startup()
{
	extern char *etext;
	unsigned i;
	vaddr_t minaddr, maxaddr;
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;

	pmapdebug = 0;
#endif

	/*
	 * Now that VM services are available, give another chance at
	 * console devices to initialize, if they could not before.
	 */
	hp300_cninit();

	/*
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in pmap_bootstrap to compensate.
	 */
	for (i = 0; i < atop(MSGBUFSIZE); i++)
		pmap_enter(pmap_kernel(), (vaddr_t)msgbufp + i * NBPG,
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	identifycpu();
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);

#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);

	/*
	 * Tell the VM system that page 0 isn't mapped.
	 *
	 * XXX This is bogus; should just fix KERNBASE and
	 * XXX VM_MIN_KERNEL_ADDRESS, but not right now.
	 */
	if (uvm_map_protect(kernel_map, 0, NBPG, UVM_PROT_NONE, TRUE))
		panic("can't mark page 0 off-limits");

	/*
	 * Tell the VM system that writing to kernel text isn't allowed.
	 * If we don't, we might end up COW'ing the text segment!
	 *
	 * XXX Should be trunc_page(&kernel_text) instead
	 * XXX of NBPG.
	 */
	if (uvm_map_protect(kernel_map, NBPG, round_page((vaddr_t)&etext),
	    UVM_PROT_READ|UVM_PROT_EXEC, TRUE))
		panic("can't protect kernel text");

	/*
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * Info for CTL_HW
 */
char	cpu_model[120];

/*
 * Text description of models we support, indexed by machineid.
 */
const char *hp300_models[] = {
	"320",		/* HP_320 */
	"318/319/330",	/* HP_330 */
	"350",		/* HP_350 */
	"360",		/* HP_36X */
	"370",		/* HP_370 */
	"340",		/* HP_340 */
	"345",		/* HP_345 */
	"375",		/* HP_375 */
	"400",		/* HP_400 */
	"380",		/* HP_380 */
	"425",		/* HP_425 */
	"433",		/* HP_433 */
	"385",		/* HP_385 */
	"382",		/* HP_382 */
};

/* Map mmuid to single letter designation in 4xx models (e.g. 425s, 425t) */
char hp300_designations[] = "    ttss e";

void
identifycpu()
{
	const char *t;
	char mc, *td;
	int len;
#ifdef FPSP
	extern u_long fpvect_tab, fpvect_end, fpsp_tab;
#endif

	/*
	 * Map machineid to model name.
	 */
	if (machineid >= sizeof(hp300_models) / sizeof(char *)) {
		printf("\nunknown machineid %d\n", machineid);
		goto lose;
	}
	t = hp300_models[machineid];

	/*
	 * Look up special designation (425s, 425t, etc) by mmuid.
	 */
	if (mmuid < strlen(hp300_designations) &&
	    hp300_designations[mmuid] != ' ') {
		td = &hp300_designations[mmuid];
		td[1] = '\0';
	} else
		td = "";

	/*
	 * ...and the CPU type
	 */
	switch (cputype) {
	case CPU_68040:
		mc = '4';
		/* adjust cpuspeed by 3/8 on '040 boxes */
		cpuspeed *= 3;
		cpuspeed /= 8;
		break;
	case CPU_68030:
		mc = '3';
		break;
	case CPU_68020:
		mc = '2';
		break;
	default:
		printf("\nunknown cputype %d\n", cputype);
		goto lose;
	}
	snprintf(cpu_model, sizeof cpu_model,
	    "HP 9000/%s%s (%dMHz MC680%c0 CPU", t, td, cpuspeed, mc);

	/*
	 * ...and the MMU type.
	 */
	switch (mmutype) {
	case MMU_68040:
	case MMU_68030:
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
		break;
	case MMU_68851:
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
		break;
	default:
		printf("%s\nunknown MMU type %d\n", cpu_model, mmutype);
		panic("startup");
	}

	/*
	 * ...and the FPU type.
	 */
	switch (fputype) {
	case FPU_68040:
		strlcat(cpu_model, "+FPU", sizeof cpu_model);
		break;
	case FPU_68882:
		len = strlen(cpu_model);
		snprintf(cpu_model + len, sizeof cpu_model - len,
		    ", %dMHz MC68882 FPU", cpuspeed);
		break;
	case FPU_68881:
		len = strlen(cpu_model);
		snprintf(cpu_model + len, sizeof cpu_model - len,
		    ", %dMHz MC68881 FPU", machineid == HP_350 ? 20 : 16);
		break;
	default:
		strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
	}

	/*
	 * ...and finally, the cache type.
	 */
	if (cputype == CPU_68040)
		strlcat(cpu_model, ", 4k on-chip physical I/D caches",
		    sizeof cpu_model);
	else {
		len = strlen(cpu_model);
		switch (ectype) {
		case EC_VIRT:
			snprintf(cpu_model + len, sizeof cpu_model - len,
			    ", %dK virtual-address cache",
			    machineid == HP_320 ? 16 : 32);
			break;
		case EC_PHYS:
			snprintf(cpu_model + len, sizeof cpu_model - len,
			    ", %dK physical-address cache",
			    machineid == HP_370 ? 64 : 32);
			break;
		}
	}

	printf("%s)\n", cpu_model);
#ifdef DEBUG
	printf("cpu: delay divisor %d", delay_divisor);
	if (mmuid)
		printf(", mmuid %d", mmuid);
	printf("\n");
#endif

	/*
	 * Now that we have told the user what they have,
	 * let them know if that machine type isn't configured.
	 */
	switch (machineid) {
	case -1:		/* keep compilers happy */
#if !defined(HP320)
	case HP_320:
#endif
#if !defined(HP330)
	case HP_330:
#endif
#if !defined(HP340)
	case HP_340:
#endif
#if !defined(HP345)
	case HP_345:
#endif
#if !defined(HP350)
	case HP_350:
#endif
#if !defined(HP360) && !defined(HP_362)
	case HP_36X:
#endif
#if !defined(HP370)
	case HP_370:
#endif
#if !defined(HP375)
	case HP_375:
#endif
#if !defined(HP380)
	case HP_380:
#endif
#if !defined(HP382)
	case HP_382:
#endif
#if !defined(HP385)
	case HP_385:
#endif
#if !defined(HP400)
	case HP_400:
#endif
#if !defined(HP425)
	case HP_425:
#endif
#if !defined(HP433)
	case HP_433:
#endif
		panic("SPU type not configured for machineid %d", machineid);
	default:
		break;
	}

#ifdef FPSP
	if (cputype == CPU_68040) {
		bcopy(&fpsp_tab, &fpvect_tab,
		    (&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
	}
#endif

	return;
lose:
	panic("startup");
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	case CPU_CPUSPEED:
		return (sysctl_rdint(oldp, oldlenp, newp, cpuspeed));
	case CPU_MACHINEID:
		return (sysctl_rdint(oldp, oldlenp, newp, machineid));
	case CPU_MMUID:
		return (sysctl_rdint(oldp, oldlenp, newp, mmuid));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

int	waittime = -1;

void
boot(howto)
	int howto;
{
	struct device *mainbus;

	/* take a snap shot before clobbering any registers */
	if (curproc && curproc->p_addr)
		savectx(&curproc->p_addr->u_pcb);

	/*
	 * Prevent mi code from spinning disks off, in case the operator
	 * changes his mind and prefers to reboot - we can't power down
	 * the machine, and it will not send a spin up command to the
	 * disks.
	 */
	howto &= ~RB_POWERDOWN;

	/* If system is cold, just halt. */
	if (cold) {
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();		/* Disable interrupts. */

	/* If rebooting and a dump is requested do it. */
	if (howto & RB_DUMP)
		dumpsys();

haltsys:
	doshutdownhooks();
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);

	/* Finally, halt/reboot the system. */
	if (howto & RB_HALT) {
		printf("System halted.  Hit any key to reboot.\n\n");
		cnpollc(1);
		while (cngetc() == 0);
		cnpollc(0);
	}

	printf("rebooting...\n");
	DELAY(1000000);
	doboot();
	/*NOTREACHED*/
}

/*
 * These variables are needed by /sbin/savecore
 */
u_long	dumpmag = 0x8fca0101;	/* magic number */
int	dumpsize = 0;		/* pages */
long	dumplo = 0;		/* blocks */
cpu_kcore_hdr_t cpu_kcore_hdr;

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	int nblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	/*
	 * Since lowram starts two pages after the beginning of memory,
	 * we're not dumping exactly all the memory.
	 */
	dumpsize = physmem - 2;

	/* hp300 only uses a single segment. */
	cpu_kcore_hdr.ram_segs[0].start = lowram;
	cpu_kcore_hdr.ram_segs[0].size = ptoa(dumpsize);
	cpu_kcore_hdr.mmutype = mmutype;
	cpu_kcore_hdr.kernel_pa = lowram;
	cpu_kcore_hdr.sysseg_pa = pmap_kernel()->pm_stpa;

	/* Always skip the first block, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
}

/*
 * Dump physical memory onto the dump device.  Called by doadump()
 * in locore.s or by boot() here in machdep.c
 */
void
dumpsys()
{
	daddr_t blkno;	/* current block to write */
				/* dump routine */
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int pg;			/* page being dumped */
	paddr_t maddr;		/* PA being dumped */
	int error;		/* error code from (*dump)() */
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */
	extern int msgbufmapped;

	/* XXX initialized here because of gcc lossage */
	maddr = lowram;
	pg = 0;

	/* Don't put dump messages in msgbuf. */
	msgbufmapped = 0;

	/* Make sure dump device is valid. */
	if (dumpdev == NODEV)
		return;
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	if (dumplo <= 0) {
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[major(dumpdev)].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif

	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	/*
	 * Generate a segment header
	 */
	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));

	/*
	 * Add the md header
	 */

	*chdr_p = cpu_kcore_hdr;

	printf("dump ");
	maddr = cpu_kcore_hdr.ram_segs[0].start;
	/* Dump the header. */
	error = (*dump) (dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	switch (error) {
	case 0:
		break;

	case ENXIO:
		printf("device bad\n");
		return;

	case EFAULT:
		printf("device not ready\n");
		return;

	case EINVAL:
		printf("area improper\n");
		return;

	case EIO:
		printf("i/o error\n");
		return;

	case EINTR:
		printf("aborted from console\n");
			return;

		default:
			printf("error %d\n", error);
			return;
	}
	for (pg = 0; pg < dumpsize; pg++) {
#define NPGMB	(1024*1024/NBPG)
		/* print out how many MBs we have dumped */
		if (pg && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);

		pmap_update(pmap_kernel());
		error = (*dump)(dumpdev, blkno, vmmap, NBPG);
		switch (error) {
		case 0:
			maddr += NBPG;
			blkno += btodb(NBPG);
			break;

		case ENXIO:
			printf("device bad\n");
			return;

		case EFAULT:
			printf("device not ready\n");
			return;

		case EINVAL:
			printf("area improper\n");
			return;

		case EIO:
			printf("i/o error\n");
			return;

		case EINTR:
			printf("aborted from console\n");
			return;

		default:
			printf("error %d\n", error);
			return;
		}
	}
	printf("succeeded\n");
}

void
initcpu()
{

	parityenable();
#ifdef USELEDS
	ledinit();
#endif
}

void
straytrap(pc, evec)
	int pc;
	u_short evec;
{
	printf("unexpected trap (vector offset %x) from %x\n",
	       evec & 0xFFF, pc);
}

/* XXX should change the interface, and make one badaddr() function */

int	*nofault;

int
badaddr(addr)
	caddr_t addr;
{
	int i;
	label_t	faultbuf;

	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *) 0;
		return(1);
	}
	i = *(volatile short *)addr;
	nofault = (int *) 0;
	return(0);
}

int
badbaddr(addr)
	caddr_t addr;
{
	int i;
	label_t	faultbuf;

	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *) 0;
		return(1);
	}
	i = *(volatile char *)addr;
	nofault = (int *) 0;
	return(0);
}

static int innmihand;	/* simple mutex */

/*
 * Level 7 interrupts can be caused by HIL keyboards (in cooked mode only,
 * but we run them in raw mode) or parity errors.
 */
void
nmihand(frame)
	struct frame frame;
{

	/* Prevent unwanted recursion. */
	if (innmihand)
		return;
	innmihand = 1;

	if (parityerror(&frame)) {
		innmihand = 0;
		return;
	}

	/* panic?? */
	printf("unexpected level 7 interrupt ignored\n");

	innmihand = 0;
}

/*
 * Parity error section.  Contains magic.
 */
#define PARREG		((volatile short *)IIOV(0x5B0000))
static int gotparmem = 0;
#ifdef DEBUG
int ignorekperr = 0;	/* ignore kernel parity errors */
#endif

/*
 * Enable parity detection
 */
void
parityenable()
{
	label_t	faultbuf;

	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *) 0;
		printf("No parity memory\n");
		return;
	}
	*PARREG = 1;
	nofault = (int *) 0;
	gotparmem = 1;
	printf("Parity detection enabled\n");
}

/*
 * Determine if level 7 interrupt was caused by a parity error
 * and deal with it if it was.  Returns 1 if it was a parity error.
 */
int
parityerror(fp)
	struct frame *fp;
{
	if (!gotparmem)
		return(0);
	*PARREG = 0;
	DELAY(10);
	*PARREG = 1;
	if (panicstr) {
		printf("parity error after panic ignored\n");
		return (1);
	}
	if (!parityerrorfind())
		printf("WARNING: transient parity error ignored\n");
	else if (USERMODE(fp->f_sr)) {
		log(LOG_ERR, "pid %d was killed: memory parity error\n",
		    curproc->p_pid);
		uprintf("sorry, pid %d killed: memory parity error\n",
		    curproc->p_pid);
		psignal(curproc, SIGKILL);
#ifdef DEBUG
	} else if (ignorekperr) {
		printf("WARNING: kernel parity error ignored\n");
#endif
	} else {
		regdump(&(fp->F_t), 128);
		panic("kernel parity error");
	}
	return (1);
}

/*
 * Yuck!  There has got to be a better way to do this!
 * Searching all of memory with interrupts blocked can lead to disaster.
 */
int
parityerrorfind()
{
	static label_t parcatch;
	static int looking = 0;
	volatile int pg, o, s;
	volatile int *ip;
	int i;
	int found;

	/*
	 * If looking is true we are searching for a known parity error
	 * and it has just occurred.  All we do is return to the higher
	 * level invocation.
	 */
	if (looking)
		longjmp(&parcatch);
	s = splhigh();
	/*
	 * If setjmp returns true, the parity error we were searching
	 * for has just occurred (longjmp above) at the current pg+o
	 */
	if (setjmp(&parcatch)) {
		printf("Parity error at 0x%x\n", ptoa(pg)|o);
		found = 1;
		goto done;
	}
	/*
	 * If we get here, a parity error has occurred for the first time
	 * and we need to find it.  We turn off any external caches and
	 * loop thru memory, testing every longword til a fault occurs and
	 * we regain control at setjmp above.  Note that because of the
	 * setjmp, pg and o need to be volatile or their values will be lost.
	 */
	looking = 1;
	ecacheoff();
	for (pg = atop(lowram); pg < atop(lowram)+physmem; pg++) {
		pmap_kenter_pa((vaddr_t)vmmap, ptoa(pg), VM_PROT_READ);
		pmap_update(pmap_kernel());
		ip = (int *)vmmap;
		for (o = 0; o < PAGE_SIZE; o += sizeof(int))
			i = *ip++;
	}
	/*
	 * Getting here implies no fault was found.  Should never happen.
	 */
	printf("Couldn't locate parity error\n");
	found = 0;
done:
	looking = 0;
	ecacheon();	/* pmap_kremove() may cause a cache flush */
	pmap_kremove((vaddr_t)vmmap, PAGE_SIZE);
	pmap_update(pmap_kernel());
	splx(s);
	return(found);
}
@


1.141
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.140 2013/11/20 23:57:07 miod Exp $	*/
@


1.140
log
@Update comments mentioning `resource maps' to mention `extents' instead.
Resource maps have been removed more than 10 years ago, it's about time to
update comments to better match reality.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2013/09/28 12:40:29 miod Exp $	*/
d573 2
d621 3
a623 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.139
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2013/08/04 07:21:13 martin Exp $	*/
d194 1
a194 1
	 * Initialize the bus resource map.
@


1.138
log
@de-lint hp300

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2013/06/11 16:42:08 deraadt Exp $	*/
d619 2
a620 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.137
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2012/10/08 21:47:47 deraadt Exp $	*/
a988 3
#ifdef lint
	i = o = pg = 0; if (i) return(0);
#endif
@


1.136
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2011/11/01 21:20:55 miod Exp $	*/
d692 1
a692 1
	daddr64_t blkno;	/* current block to write */
d694 1
a694 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.135
log
@Drop support for the HP MMU. It was only found on two hp300 systems (models
320 and 350), which have been unsupported since a bunch of release already,
because this annoying MMU does not have TT registers (or if it does, it is
not documented) and thus went in the way of PMAP_DIRECT for hp300.
In other words: remove a bunch of code which was either #ifdef'ed out or
had no chance to run in real life.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2011/09/20 09:49:38 miod Exp $	*/
a617 1
	/* Run any shutdown hooks. */
d619 1
@


1.134
log
@Clear RB_POWERDOWN early in boot() on systems which can not powerdown and
which firmware does not send spin up commands to the disks, in case the
operator changes his mind and reboots instead of manually powering down
after the system has halted.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.133 2011/08/18 19:54:18 miod Exp $	*/
a405 3
		break;
	case MMU_HP:
		strlcat(cpu_model, ", HP MMU", sizeof cpu_model);
@


1.133
log
@Because model 362 does not have an SGC bus (or a blind, deaf and mute one),
there is no way we can tell models 360 and 362 apart by probing for an SGC
bus, or for a frodo(4) chip since of the `lil' black swan' 3x2 models, only
model 382 has frodo. So don't bother trying to tell models 360 and 362
apart, and use a common 36X symbol. No functional change except for useless
code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2011/06/26 22:39:59 deraadt Exp $	*/
d579 8
@


1.132
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2011/06/05 19:41:06 deraadt Exp $	*/
d328 1
a328 1
	"360",		/* HP_360 */
a337 1
	"362",		/* HP_362 */
d487 2
a488 5
#if !defined(HP360)
	case HP_360:
#endif
#if !defined(HP362)
	case HP_362:
@


1.131
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2011/05/30 22:25:21 oga Exp $	*/
d87 1
d607 1
@


1.130
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2010/07/02 19:57:14 tedu Exp $	*/
a100 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef	BUFCACHEPERCENT
#define	BUFCACHEPERCENT	5
#endif

#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.129
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2010/06/29 20:30:31 guenther Exp $	*/
d180 1
a180 1
	    atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
@


1.128
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2010/06/27 03:03:48 thib Exp $	*/
a129 4
#ifdef COMPAT_SUNOS
extern struct emul emul_sunos;
#endif

a1047 48
}

/*
 * cpu_exec_aout_makecmds():
 *	cpu-dependent a.out format hook for execve().
 *
 * Determine of the given exec package refers to something which we
 * understand and, if so, set up the vmcmds for it.
 */
int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
#if defined(COMPAT_44) || defined(COMPAT_SUNOS)
	u_long midmag, magic;
	u_short mid;
	int error;
	struct exec *execp = epp->ep_hdr;
#ifdef COMPAT_SUNOS
	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
#endif

	midmag = ntohl(execp->a_midmag);
	mid = (midmag >> 16) & 0xffff;
	magic = midmag & 0xffff;

	midmag = mid << 16 | magic;

	switch (midmag) {
#ifdef COMPAT_44
	case (MID_HP300 << 16) | ZMAGIC:
		error = exec_aout_prep_oldzmagic(p, epp);
		break;
#endif
	default:
#ifdef COMPAT_SUNOS
		/* Hand it over to the SunOS emulation package. */
		error = sunos_exec_aout_makecmds(p, epp);
#else
		error = ENOEXEC;
#endif
	}

	return error;
#else /* !(defined(COMPAT_44) || defined(COMPAT_SUNOS)) */
	return ENOEXEC;
#endif
@


1.127
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2009/08/11 18:46:32 miod Exp $	*/
a129 3
#ifdef COMPAT_HPUX
extern struct emul emul_hpux;
#endif
@


1.126
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d117 4
@


1.125
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2009/08/09 10:40:17 blambert Exp $	*/
a268 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.124
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2009/08/02 16:28:39 beck Exp $	*/
a140 1
caddr_t	allocsys(caddr_t);
a236 1
	caddr_t v;
a237 1
	vsize_t size;
a270 10
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	size = (vsize_t)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(size))) == 0)
		panic("startup: no room for tables");
	if ((allocsys(v) - v) != size)
		panic("startup: table size inconsistency");

	/*
a336 22
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num)	\
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))

	return (v);
@


1.123
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2009/06/15 17:01:25 beck Exp $	*/
a68 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a369 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.122
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2009/06/03 21:30:19 beck Exp $	*/
a291 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.121
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2008/06/27 17:22:14 miod Exp $	*/
d292 6
@


1.120
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2008/06/08 20:57:16 miod Exp $	*/
a291 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.119
log
@Make sure to cnpollc(1)/cnpollc(0) around cngetc() or getsn() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2008/04/09 16:58:10 deraadt Exp $	*/
d91 1
d800 4
@


1.118
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2008/04/09 16:50:27 deraadt Exp $	*/
d695 1
d697 1
@


1.117
log
@Compute physmem as the real physical memory size, not the physical memory
size minus two pages at the start and one page at the end. This gives us
even MB sizes in dmesg (-:
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2007/11/02 19:18:54 martin Exp $	*/
d681 2
a682 2
	/* Disable interrupts. */
	splhigh();
@


1.116
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2007/06/06 17:15:11 deraadt Exp $	*/
d731 2
a732 1
	 * XXX include the final RAM page which is not included in physmem.
d734 1
a734 1
	dumpsize = physmem;
@


1.115
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2007/05/29 20:36:47 deraadt Exp $	*/
d216 1
a216 1
	    (u_long)extiobase, (u_long)extiobase + ctob(eiomapsize),
d260 1
a260 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d272 2
a273 2
	printf("real mem = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
d737 1
a737 1
	cpu_kcore_hdr.ram_segs[0].size = ctob(dumpsize);
d1069 1
a1069 1
		printf("Parity error at 0x%x\n", ctob(pg)|o);
d1082 1
a1082 1
	for (pg = btoc(lowram); pg < btoc(lowram)+physmem; pg++) {
@


1.114
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2007/05/27 17:31:56 miod Exp $	*/
d760 1
a760 1
	daddr_t blkno;		/* current block to write */
d762 1
a762 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.113
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2007/05/26 20:26:50 pedro Exp $	*/
d720 1
a720 1
dumpconf()
a722 1
	int maj;
d724 2
a725 1
	if (dumpdev == NODEV)
a726 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
@


1.112
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2007/05/23 20:33:46 pvalchev Exp $	*/
d302 1
@


1.111
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2006/06/16 20:48:49 miod Exp $	*/
a106 6
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a240 1
	int base, residual;
d286 2
a287 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d289 8
a296 36
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
		panic("startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				    "buffer cache");

			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a315 2
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
		nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
a384 23
	/*
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless. */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.110
log
@If we are configured for glass console but no keyboard is plugged, we run
with the dummy wscons cngetc() which immediately returns zero. Since
a cngetc() call is the only difference between halt and reboot, this caused
the former to behave as the later. Fix this by spinning until cngetc() returns
a non-zero value.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2006/06/07 22:02:00 miod Exp $	*/
d279 2
a280 1
	printf("real mem  = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);
d349 2
a350 2
	printf("avail mem = %lu (%luK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
@


1.109
log
@- when killing a process due to parity error, notify syslog.
- when checking for the parity error itself:
  + use pmap_kenter_pa() and pmap_kremove() for the temporary mapping.
  + reenable external cache before invoking pmap_kremove() [which can cause
    a cache flush on some models].
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2006/05/19 22:51:07 miod Exp $	*/
a749 8
#if defined(PANICWAIT) && !defined(DDB)
	if ((howto & RB_HALT) == 0 && panicstr) {
		printf("hit any key to reboot...\n");
		(void)cngetc();
		printf("\n");
	}
#endif

d753 1
a753 1
		(void)cngetc();
@


1.108
log
@Get rid of ``maxmem'' and fix the descriptive comment for ``physmem''.
Either maxmem is not used (mac68k), or the position of the physical memory
is set in stone so we don't need to know the top of the memory (MAXADDR
on hp300, physmem on mvme68k) it was pointing to.

Plus this gets rid of unused lowram on mvme68k - all the m68k world is not an
hp300, after all.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2005/12/30 18:14:12 miod Exp $	*/
d68 1
d1090 1
a1090 1
		return(1);
d1095 4
a1098 3
		printf("pid %d: parity error\n", curproc->p_pid);
		uprintf("sorry, pid %d killed due to memory parity error\n",
			curproc->p_pid);
d1108 1
a1108 1
	return(1);
d1112 1
a1112 1
 * Yuk!  There has got to be a better way to do this!
d1155 1
a1155 2
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, ctob(pg),
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);
d1158 1
a1158 1
		for (o = 0; o < NBPG; o += sizeof(int))
d1168 2
a1169 1
	pmap_remove(pmap_kernel(), (vaddr_t)vmmap, (vaddr_t)&vmmap[NBPG]);
a1170 1
	ecacheon();
@


1.107
log
@Kill conforced, and have console devices use CN_FORCED priority instead.
This means we are no longer aborting the console scans even if the final
console has been found, but on the other hand makes some logic simpler;
plus it will be necessary for upcoming scode vs device loop order reversal.
No user-visible change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.106 2005/12/30 18:00:23 miod Exp $	*/
d123 1
a123 2
int	maxmem;			/* max memory per process */
int	physmem;		/* max supported memory, changes to actual */
@


1.106
log
@Introduce symbolic constants for the magic conscode values.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2005/12/22 22:56:28 miod Exp $	*/
a170 1
int	conforced;		/* console has been forced */
a215 1
	conforced = 0;
@


1.105
log
@More reasonable size for fixed extent storage.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2005/11/06 17:59:52 miod Exp $	*/
d165 1
a165 1
 * Select code of console.  Set to -1 if console is on
d218 1
a218 1
	conscode = 1024;		/* invalid */
@


1.104
log
@Factorize setregs() code to m68k-common location.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.103 2005/09/27 22:05:37 miod Exp $	*/
d145 1
a145 1
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(16)];
@


1.103
log
@Identify HP 9000/362 and HP 9000/382 models, and attach frodo on them.
Model 382 can be identified with a unique MMUID value; model 362 is told
from model 360 by probing for the frodo chip. Their built-in frame buffer
is not supported at the moment.

Matching information derived from messages to the NetBSD mailing lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2005/09/27 21:50:36 miod Exp $	*/
a446 49
}

/*
 * Set registers on exec.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct frame *frame = (struct frame *)p->p_md.md_regs;

	frame->f_sr = PSL_USERSET;
	frame->f_pc = pack->ep_entry & ~1;
	frame->f_regs[D0] = 0;
	frame->f_regs[D1] = 0;
	frame->f_regs[D2] = 0;
	frame->f_regs[D3] = 0;
	frame->f_regs[D4] = 0;
	frame->f_regs[D5] = 0;
	frame->f_regs[D6] = 0;
	frame->f_regs[D7] = 0;
	frame->f_regs[A0] = 0;
	frame->f_regs[A1] = 0;
	frame->f_regs[A2] = (int)PS_STRINGS;
	frame->f_regs[A3] = 0;
	frame->f_regs[A4] = 0;
	frame->f_regs[A5] = 0;
	frame->f_regs[A6] = 0;
	frame->f_regs[SP] = stack;

	/* restore a null state frame */
	p->p_addr->u_pcb.pcb_fpregs.fpf_null = 0;
	if (fputype)
		m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);

#ifdef COMPAT_SUNOS
	/*
	 * SunOS' ld.so does self-modifying code without knowing
	 * about the 040's cache purging needs.  So we need to uncache
	 * writeable executable pages.
	 */
	if (p->p_emul == &emul_sunos)
		p->p_md.md_flags |= MDP_UNCACHE_WX;
	else
		p->p_md.md_flags &= ~MDP_UNCACHE_WX;
#endif
@


1.102
log
@Do not initialize physmem to a magic value at compile time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2005/02/27 22:08:41 miod Exp $	*/
d519 3
a521 1
	"385"		/* HP_385 */
d673 3
d684 3
@


1.101
log
@Invoke hp300_cninit() twice, with a global variable letting the
console-dependent routines know which pass they are being invoked in.

The first pass is the usual console detection code. The second pass runs
after uvm is initialized, and will allow devices which need VM services to
run to claim the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2005/02/12 18:00:51 miod Exp $	*/
a88 1
#define	MAXMEM	64*1024	/* XXX - from cmap.h */
d124 1
a124 1
int	physmem = MAXMEM;	/* max supported memory, changes to actual */
@


1.100
log
@consinit_active is not used anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2005/01/14 22:49:24 miod Exp $	*/
d259 6
@


1.99
log
@Since we run keyboards in raw mode now, NMIs can only be parity errors now;
simplify nmihand() accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2005/01/14 22:39:27 miod Exp $	*/
a169 1
int	consinit_active;	/* flag for driver init routines */
a216 1
	consinit_active = 1;
a231 2

	consinit_active = 0;
@


1.98
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2005/01/14 19:11:56 miod Exp $	*/
d1064 2
a1065 1
 * Level 7 interrupts can be caused by the keyboard or parity errors.
d1077 3
a1079 9
#if 0	/* XXX */
	/* Check for keyboard <CRTL>+<SHIFT>+<RESET>. */
	if (kbdnmi()) {
#ifdef DDB
		if (db_console) {
			Debugger();
		}
#endif /* DDB */
		goto nmihand_out;	/* no more work to do */
a1080 1
#endif
a1081 2
	if (parityerror(&frame))
		return;
a1084 3
#if 0
nmihand_out:
#endif
@


1.97
log
@If we have a frame buffer configured as ``internal'', be sure to account for
its out-of-DIO-range memory when sizing the external iomap.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2005/01/10 21:23:52 miod Exp $	*/
a91 3
#include <hp300/dev/hilreg.h>
#include <hp300/dev/hilioctl.h>
#include <hp300/dev/hilvar.h>
d99 1
a99 1
struct vm_map *exec_map = NULL;  
d224 1
a224 1
	 * Initialize the DIO resource map.
d229 1
a229 1
	    
d321 1
a321 1
			if (pg == NULL) 
d1076 1
d1086 1
d1093 1
d1095 1
d1231 1
a1231 1
 * 
@


1.96
log
@It turns out the extiospace static storage shrinkage was too much for large
frame buffers; go back to a larger, yet reasonable, size.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2005/01/08 22:13:54 miod Exp $	*/
a91 1
#include <hp300/dev/dioreg.h>
a147 2
 * We know that console initialization will not try to map more than
 * DIOII_DEVSIZE bytes. Play safe and allow for twice this size.
d149 1
a149 1
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(2 * DIOII_DEVSIZE / PAGE_SIZE)];
@


1.95
log
@Only use one set of DIO size and address defines, from <dev/dioreg.h>
rather than <include/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2004/12/30 21:26:14 miod Exp $	*/
d150 1
a150 1
 * DIO_DEVSIZE bytes. Play safe and allow for twice this size.
d152 1
a152 1
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(2 * DIO_DEVSIZE / PAGE_SIZE)];
@


1.94
log
@Kill the EIOMAPSIZE and instead, dynamically size the external I/O map,
based on the DIO-II space probing results.

This does not win much for now, but this will be very useful for SGC bus
support (coming soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2004/12/23 15:32:09 miod Exp $	*/
d92 4
a95 3
#include <arch/hp300/dev/hilreg.h>
#include <arch/hp300/dev/hilioctl.h>
#include <arch/hp300/dev/hilvar.h>
d97 1
a97 1
#include <arch/hp300/hp300/leds.h>
d150 1
a150 1
 * DIOCSIZE bytes. Play safe and allow for twice this size.
d152 1
a152 1
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(2 * DIOCSIZE / PAGE_SIZE)];
@


1.93
log
@Use a shorter, more realistic initial memory storage for extio.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2004/12/02 19:37:22 miod Exp $	*/
d152 1
d232 1
a232 1
	    (u_long)extiobase, (u_long)extiobase + ctob(EIOMAPSIZE),
@


1.92
log
@Make BUFCACHEPERCENT adjustable through UKC, like all other arches do.

(This means twice as less buffers on hp300 with unmodified GENERIC kernels
now)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2004/03/10 23:02:53 tom Exp $	*/
d146 4
a149 2
 * XXX some storage space must be allocated statically because of
 * early console init
d151 1
a151 1
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16)];
@


1.91
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2004/02/19 18:46:18 miod Exp $	*/
d115 5
d125 2
d425 3
a427 5
	 * Determine how many buffers to allocate.  Since HPs tend
	 * to be long on memory and short on disk speed, we allocate
	 * more buffer space than the BSD standard of 10% of memory
	 * for the first 2 Meg, 5% of the remaining.  We just allocate
	 * a flag 10%.  Insure a minimum of 16 buffers.
d430 1
a430 1
		bufpages = physmem / 10;
d436 10
@


1.90
log
@Kill <sys/clist.h> - nothing uses it since years.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2004/01/27 16:16:22 miod Exp $	*/
d746 3
a748 1
		howto |= RB_HALT;
@


1.89
log
@Only install the fpsp exception vectors if the cpu is a 68040.
Thus, it becomes unnecessary to check for the cpu type in the exception
handlers, saving a few cycles and a few bytes.

Tested by various people on hp300, mac68k, mvme68k, 68040 and non-68040.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2003/12/20 20:08:16 miod Exp $	*/
a45 1
#include <sys/clist.h>
@


1.88
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2003/06/02 23:27:45 millert Exp $	*/
d518 3
d683 7
@


1.87
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2003/05/09 23:10:21 art Exp $	*/
d345 2
a346 2
	printf("avail mem = %lu (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
@


1.86
log
@No need to map the message buffer executable.

fries@@ niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2003/04/06 18:54:18 ho Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.85
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2003/01/04 22:11:44 miod Exp $	*/
d270 2
a271 1
		    avail_end + i * NBPG, VM_PROT_ALL, VM_PROT_ALL|PMAP_WIRED);
@


1.84
log
@Remove COMPAT_NOMID. It was deprecated since a long time, the man page wass
misleading, and it was never used anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2002/12/17 23:11:31 millert Exp $	*/
d561 2
a562 2
	sprintf(cpu_model, "HP 9000/%s%s (%dMHz MC680%c0 CPU", t, td, cpuspeed,
	    mc);
d570 1
a570 1
		strcat(cpu_model, "+MMU");
d573 1
a573 1
		strcat(cpu_model, ", MC68851 MMU");
d576 1
a576 1
		strcat(cpu_model, ", HP MMU");
a582 2
	len = strlen(cpu_model);

d588 1
a588 1
		len += sprintf(cpu_model + len, "+FPU");
d591 3
a593 1
		len += sprintf(cpu_model + len, ", %dMHz MC68882 FPU", cpuspeed);
d596 3
a598 2
		len += sprintf(cpu_model + len, ", %dMHz MC68881 FPU",
		    machineid == HP_350 ? 20 : 16);
d601 1
a601 1
		len += sprintf(cpu_model + len, ", unknown FPU");
d608 2
a609 1
		sprintf(cpu_model + len, ", 4k on-chip physical I/D caches");
d611 1
d614 1
a614 1
			sprintf(cpu_model + len,
d619 1
a619 1
			sprintf(cpu_model + len,
@


1.83
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2002/12/10 23:34:36 miod Exp $	*/
a1205 5
 *
 * XXX what are the special cases for the hp300?
 * XXX why is this COMPAT_NOMID?  was something generating
 *	hp300 binaries with an a_mid of 0?  i thought that was only
 *	done on little-endian machines...  -- cgd
d1212 1
a1212 1
#if defined(COMPAT_NOMID) || defined(COMPAT_44) || defined(COMPAT_SUNOS)
a1227 5
#ifdef COMPAT_NOMID
	case (MID_ZERO << 16) | ZMAGIC:
		error = exec_aout_prep_oldzmagic(p, epp);
		break;
#endif
d1243 1
a1243 1
#else /* !(defined(COMPAT_NOMID) || defined(COMPAT_44)) */
@


1.82
log
@Typos, and fix a comment's content.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2002/03/23 13:28:33 espie Exp $	*/
a75 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a413 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM 
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns); 
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.81
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2002/03/14 20:31:30 mickey Exp $	*/
d289 1
a289 1
	 * and the give everything true virtual addresses.
d407 1
a407 1
 * allocate that much and fill it with zeroes, and the call
d444 1
a444 2
	 * a flag 10%.  Insure a minimum of 16 buffers.  We allocate
	 * 1/2 as many swap buffer headers as file i/o buffers.
@


1.80
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2002/03/14 01:26:31 millert Exp $	*/
d421 3
@


1.79
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2002/02/24 23:33:47 miod Exp $	*/
a507 1
extern	char version[];
@


1.78
log
@Don't generate noise before entering DDB from keyboard.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2002/01/23 17:51:52 art Exp $	*/
d156 8
a163 8
caddr_t	allocsys __P((caddr_t));
void	parityenable __P((void));
int	parityerror __P((struct frame *));
int	parityerrorfind __P((void));
void    identifycpu __P((void));
void    initcpu __P((void));
void	dumpmem __P((int *, int, int));
char	*hexstr __P((int, int));
d166 4
a169 4
void    dumpsys __P((void));
void	hp300_init __P((void));
void    straytrap __P((int, u_short));
void	nmihand __P((struct frame));
d869 1
a869 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d1240 1
a1240 2
	extern int sunos_exec_aout_makecmds
		__P((struct proc *, struct exec_package *));
@


1.77
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2002/01/23 17:35:56 art Exp $	*/
a1070 11
		printf("Got a keyboard NMI");

		/*
		 * We can:
		 *
		 *	- enter DDB
		 *
		 *	- Start the crashandburn sequence
		 *
		 *	- Ignore it.
		 */
a1072 1
			printf(": entering debugger\n");
d1074 1
a1074 4
		} else
			printf("\n");
#else
			printf(": ignoring\n");
a1075 1

@


1.76
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2002/01/16 20:51:45 miod Exp $	*/
a349 3

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.75
log
@Replace resource maps with extents.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2001/12/06 18:53:01 millert Exp $	*/
a113 1
struct vm_map *mb_map = NULL;
@


1.74
log
@Sprinkle pmap_update() calls (based on NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2001/12/06 01:03:43 miod Exp $	*/
d58 1
a58 1
#include <sys/map.h>
d150 6
d219 2
a220 1
	extern struct map extiomap[];
d233 4
a236 2
	rminit(extiomap, (long)EIOMAPSIZE, (long)1, "extio", EIOMAPSIZE/16);

@


1.74.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2002/01/23 17:51:52 art Exp $	*/
d58 1
a58 1
#include <sys/extent.h>
d114 1
a149 6
/*
 * XXX some storage space must be allocated statically because of
 * early console init
 */
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16)];

d213 1
a213 2
	extern struct extent *extio;
	extern char *extiobase;
d226 2
a227 4
	extio = extent_create("extio",
	    (u_long)extiobase, (u_long)extiobase + ctob(EIOMAPSIZE),
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);
	    
d342 3
@


1.74.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74.2.1 2002/01/31 22:55:08 niklas Exp $	*/
d156 8
a163 8
caddr_t	allocsys(caddr_t);
void	parityenable(void);
int	parityerror(struct frame *);
int	parityerrorfind(void);
void    identifycpu(void);
void    initcpu(void);
void	dumpmem(int *, int, int);
char	*hexstr(int, int);
d166 4
a169 4
void    dumpsys(void);
void	hp300_init(void);
void    straytrap(int, u_short);
void	nmihand(struct frame);
a420 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d508 1
d869 1
a869 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1071 11
d1084 1
d1086 4
a1089 1
		}
d1091 1
d1256 2
a1257 1
	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
@


1.74.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 6
d276 1
a276 2
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d289 1
a289 1
	 * and then give everything true virtual addresses.
d407 1
a407 1
 * allocate that much and fill it with zeroes, and then call
d420 12
d444 2
a445 1
	 * a flag 10%.  Insure a minimum of 16 buffers.
d580 2
a581 2
	snprintf(cpu_model, sizeof cpu_model,
	    "HP 9000/%s%s (%dMHz MC680%c0 CPU", t, td, cpuspeed, mc);
d589 1
a589 1
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
d592 1
a592 1
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
d595 1
a595 1
		strlcat(cpu_model, ", HP MMU", sizeof cpu_model);
d602 2
d609 1
a609 1
		strlcat(cpu_model, "+FPU", sizeof cpu_model);
d612 1
a612 3
		len = strlen(cpu_model);
		snprintf(cpu_model + len, sizeof cpu_model - len,
		    ", %dMHz MC68882 FPU", cpuspeed);
d615 2
a616 3
		len = strlen(cpu_model);
		snprintf(cpu_model + len, sizeof cpu_model - len,
		    ", %dMHz MC68881 FPU", machineid == HP_350 ? 20 : 16);
d619 1
a619 1
		strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
d626 1
a626 2
		strlcat(cpu_model, ", 4k on-chip physical I/D caches",
		    sizeof cpu_model);
a627 1
		len = strlen(cpu_model);
d630 1
a630 1
			snprintf(cpu_model + len, sizeof cpu_model - len,
d635 1
a635 1
			snprintf(cpu_model + len, sizeof cpu_model - len,
d1225 5
d1236 1
a1236 1
#if defined(COMPAT_44) || defined(COMPAT_SUNOS)
d1252 5
d1272 1
a1272 1
#else /* !(defined(COMPAT_44) || defined(COMPAT_SUNOS)) */
@


1.73
log
@MAPPEDCOPY no more.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2001/11/29 22:50:03 millert Exp $	*/
d269 1
d328 1
d956 1
d1209 1
d1222 1
@


1.72
log
@fix pasto so this compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2001/11/28 16:13:28 art Exp $	*/
a992 11
#ifdef MAPPEDCOPY
	/*
	 * Initialize lower bound for doing copyin/copyout using
	 * page mapping (if not already set).  We don't do this on
	 * VAC machines as it loses big time.
	 */
	if (ectype == EC_VIRT)
		mappedcopysize = -1;	/* in case it was patched */
	else
		mappedcopysize = NBPG;
#endif
@


1.71
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2001/11/28 13:57:18 art Exp $	*/
d321 1
a321 1
			pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
@


1.70
log
@pmap_kenter_pgs(.., 1) is pointless. pmap_kenter_pa instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2001/11/28 13:47:38 art Exp $	*/
d113 3
a115 3
vm_map_t exec_map = NULL;  
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.69
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2001/11/09 15:25:55 art Exp $	*/
d320 3
a322 1
			pmap_kenter_pgs(curbuf, &pg, 1);
@


1.68
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2001/11/07 01:18:00 art Exp $	*/
d296 1
a296 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
d356 1
a356 2
	if (uvm_map_protect(kernel_map, 0, NBPG, UVM_PROT_NONE, TRUE)
	    != KERN_SUCCESS)
d367 1
a367 1
	    UVM_PROT_READ|UVM_PROT_EXEC, TRUE) != KERN_SUCCESS)
@


1.67
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2001/11/06 00:30:38 art Exp $	*/
a121 1
int	nswbuf = 0;
a441 5
	}
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
@


1.66
log
@Kill vm/vm_param.h, move it to uvm/uvm_param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2001/09/20 17:02:30 mpech Exp $	*/
d295 1
a295 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.65
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2001/09/19 20:50:56 mickey Exp $	*/
a100 1
#include <vm/vm_param.h>
@


1.64
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2001/09/11 20:09:56 miod Exp $	*/
d1196 1
a1196 1
	 * and it has just occured.  All we do is return to the higher
d1204 1
a1204 1
	 * for has just occured (longjmp above) at the current pg+o
d1212 1
a1212 1
	 * If we get here, a parity error has occured for the first time
@


1.63
log
@Fix uvm_km_suballoc() usage flags. ok art@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2001/08/26 00:15:37 miod Exp $	*/
a100 1
#include <vm/vm_kern.h>
a101 1

@


1.62
log
@Nuke annoying defopt, by popular demand. Plus you get two typos fixed
for free.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2001/08/25 16:15:15 miod Exp $	*/
d335 1
a335 1
				   16*NCARGS, TRUE, FALSE, NULL);
d341 1
a341 1
				   VM_PHYS_SIZE, TRUE, FALSE, NULL);
@


1.61
log
@Remove workarounds for old compiler bugs, and fix a few style issues.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2001/08/25 11:37:26 espie Exp $	*/
a104 2

#include "opt_useleds.h"
@


1.60
log
@One regdump to dump them all...

(moid@@ wants that commit, because it interferes with stuff he's cleaning,
and he's prepared to clean up stuff I may have forgotten, even though this
was tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2001/08/23 14:01:03 art Exp $	*/
a750 3
#if __GNUC__	/* XXX work around lame compiler problem (gcc 2.7.2) */
	(void)&howto;
#endif
d784 1
a784 1
 haltsys:
@


1.59
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2001/08/23 12:02:04 art Exp $	*/
d1178 1
a1178 1
		regdump(fp, 128);
a1244 91
}

void
regdump(fp, sbytes)
	struct frame *fp; /* must not be register */
	int sbytes;
{
	static int doingdump = 0;
	register int i;
	int s;

	if (doingdump)
		return;
	s = splhigh();
	doingdump = 1;
	printf("pid = %d, pc = %s, ",
	       curproc ? curproc->p_pid : -1, hexstr(fp->f_pc, 8));
	printf("ps = %s, ", hexstr(fp->f_sr, 4));
	printf("sfc = %s, ", hexstr(getsfc(), 4));
	printf("dfc = %s\n", hexstr(getdfc(), 4));
	printf("Registers:\n     ");
	for (i = 0; i < 8; i++)
		printf("        %d", i);
	printf("\ndreg:");
	for (i = 0; i < 8; i++)
		printf(" %s", hexstr(fp->f_regs[i], 8));
	printf("\nareg:");
	for (i = 0; i < 8; i++)
		printf(" %s", hexstr(fp->f_regs[i+8], 8));
	if (sbytes > 0) {
		if (fp->f_sr & PSL_S) {
			printf("\n\nKernel stack (%s):",
			       hexstr((int)(((int *)&fp)-1), 8));
			dumpmem(((int *)&fp)-1, sbytes, 0);
		} else {
			printf("\n\nUser stack (%s):", hexstr(fp->f_regs[SP], 8));
			dumpmem((int *)fp->f_regs[SP], sbytes, 1);
		}
	}
	doingdump = 0;
	splx(s);
}

#define KSADDR	((int *)((u_int)curproc->p_addr + USPACE - NBPG))

void
dumpmem(ptr, sz, ustack)
	register int *ptr;
	int sz, ustack;
{
	register int i, val;

	for (i = 0; i < sz; i++) {
		if ((i & 7) == 0)
			printf("\n%s: ", hexstr((int)ptr, 6));
		else
			printf(" ");
		if (ustack == 1) {
			if ((val = fuword(ptr++)) == -1)
				break;
		} else {
			if (ustack == 0 &&
			    (ptr < KSADDR || ptr > KSADDR+(NBPG/4-1)))
				break;
			val = *ptr++;
		}
		printf("%s", hexstr(val, 8));
	}
	printf("\n");
}

char *
hexstr(val, len)
	register int val;
	int len;
{
	static char nbuf[9];
	register int x, i;

	if (len > 8)
		return("");
	nbuf[len] = '\0';
	for (i = len-1; i >= 0; --i) {
		x = val & 0xF;
		if (x > 9)
			nbuf[i] = x - 10 + 'A';
		else
			nbuf[i] = x + '0';
		val >>= 4;
	}
	return(nbuf);
@


1.58
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2001/08/19 17:06:25 miod Exp $	*/
a346 5

	/*
	 * Initialize timeouts
	 */
	timeout_init();
@


1.57
log
@Remove PANICBUTTON code, as it is incompatible with DDB and DDB is
much more appreciated. millert@@ agrees.
While there, make HP300_NEWKVM permanent.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2001/08/18 20:21:10 miod Exp $	*/
a422 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.56
log
@Correct mapping of the kernel message buffer. From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2001/07/25 13:25:31 art Exp $	*/
a45 2
#define HP300_NEWKVM		/* Write generic m68k format kcore dumps. */

a92 1
#ifdef HP300_NEWKVM
a93 1
#endif	/* HP300_NEWKVM */
a822 1
#ifdef HP300_NEWKVM
a823 1
#endif	/* HP300_NEWKVM */
a853 1
#ifdef HP300_NEWKVM
a859 1
#endif	/* HP300_NEWKVM */
a884 1
#ifdef HP300_NEWKVM
a887 1
#endif	/* HP300_NEWKVM */
a915 1
#ifdef HP300_NEWKVM
a930 1
#endif	/* HP300_NEWKVM */
a932 1
#ifdef HP300_NEWKVM
a963 3
#else
	maddr = lowram;
#endif	/* HP300_NEWKVM */
a1075 20
#ifdef PANICBUTTON
/*
 * Declare these so they can be patched.
 */
int panicbutton = 1;	/* non-zero if panic buttons are enabled */
int candbdiv = 2;	/* give em half a second (hz / candbdiv) */

void	candbtimer __P((void *));

int crashandburn;

void
candbtimer(arg)
	void *arg;
{

	crashandburn = 0;
}
#endif /* PANICBUTTON */

a1110 14
#ifdef PANICBUTTON
		if (panicbutton) {
			if (crashandburn) {
				crashandburn = 0;
				printf(": CRASH AND BURN!\n");
				panic("forced crash");
			} else {
				/* Start the crashandburn sequence */
				printf("\n");
				crashandburn = 1;
				timeout(candbtimer, NULL, hz / candbdiv);
			}
		} else
#endif /* PANICBUTTON */
d1122 1
a1122 1
 nmihand_out:
@


1.55
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2001/07/18 10:47:04 art Exp $	*/
d277 1
a277 1
		pmap_enter(pmap_kernel(), (vaddr_t)msgbufp,
@


1.54
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2001/07/05 10:12:06 art Exp $	*/
d278 1
a278 1
		    avail_end + i * NBPG, VM_PROT_ALL, TRUE, VM_PROT_ALL);
d987 1
a987 1
		    VM_PROT_READ, TRUE, VM_PROT_READ);
d1285 1
a1285 1
		    VM_PROT_READ, TRUE, VM_PROT_READ);
@


1.53
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2001/06/27 04:05:45 art Exp $	*/
a329 1
#if defined(PMAP_NEW)
a330 5
#else
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE,
			    TRUE, VM_PROT_READ|VM_PROT_WRITE);
#endif
@


1.52
log
@no more old VM
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2001/06/25 00:43:09 mickey Exp $	*/
a432 3
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
@


1.51
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2001/06/05 16:13:15 millert Exp $	*/
a107 1
#if defined(UVM)
a108 1
#endif
a121 1
#if defined(UVM)
a124 3
#else
vm_map_t buffer_map;
#endif
a204 1
#if defined(UVM)
a206 4
#else
	vm_page_physload(atop(avail_start), atop(avail_end),
	    atop(avail_start), atop(avail_end));
#endif /* UVM */
a292 1
#if defined(UVM)
a294 4
#else
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(size))) == 0)
		panic("startup: no room for tables");
#endif
a302 1
#if defined(UVM)
a308 8
#else
	buffer_map = kmem_suballoc(kernel_map, (vaddr_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vaddr_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vaddr_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif /* UVM */
a311 1
#if defined(UVM)
a339 16
#else /* ! UVM */
		vsize_t curbufsize;
		vaddr_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vaddr_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base+1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif /* UVM */
a345 1
#if defined(UVM)
a347 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
#endif
a351 1
#if defined(UVM)
a353 4
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);
#endif
a354 1
#if defined(UVM)
a356 4
#else
	mb_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
#endif
a365 1
#if defined(UVM)
a367 4
#else
	printf("avail mem = %lu (%uK)\n", ptoa(cnt.v_free_count),
	    ptoa(cnt.v_free_count)/1024);
#endif
a376 1
#if defined(UVM)
a379 5
#else
	if (vm_map_protect(kernel_map, 0, NBPG, VM_PROT_NONE, TRUE)
	    != KERN_SUCCESS)
		panic("can't mark page 0 off-limits");
#endif
a387 1
#if defined(UVM)
a390 5
#else
	if (vm_map_protect(kernel_map, NBPG, round_page((vaddr_t)&etext),
	    VM_PROT_READ|VM_PROT_EXECUTE, TRUE) != KERN_SUCCESS)
		panic("can't protect kernel text");
#endif
a472 3
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
@


1.50
log
@Use mi round_page() and trunc_page() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2001/05/25 22:07:18 millert Exp $	*/
a846 2
	extern int cold;

@


1.49
log
@Add 3 sysctl machdep variables: cpuspeed, machineid, and mmuid.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2001/05/23 15:12:06 millert Exp $	*/
d453 1
a453 1
	 * XXX Should be m68k_trunc_page(&kernel_text) instead
d457 1
a457 1
	if (uvm_map_protect(kernel_map, NBPG, m68k_round_page(&etext),
d461 1
a461 1
	if (vm_map_protect(kernel_map, NBPG, m68k_round_page(&etext),
@


1.48
log
@Adjust computed cpuspeed by 3/8 on 68040 machines to correspond to
reality.  Convert hp300_models into an array of char *'s, indexed
by machineid--we can use the computed cpuspeed instead of hard
coding values in a table.  Also save a few bytes by storing the cpu
type in a single char, not a 2 character string.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2001/05/17 18:41:48 provos Exp $	*/
d792 1
a792 1
		panic("SPU type not configured");
d829 6
@


1.47
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2001/05/15 01:57:49 millert Exp $	*/
d198 1
a198 1
int	cpuspeed;		/* relative cpu speed; XXX skewed on 68040 */
a608 6
struct hp300_model {
	int id;
	const char *name;
	const char *speed;
};

d610 16
a625 19
 * Note that we examine the cpuspeed variable instead of using the speed
 * in this table for 68040-based models since the CPU and/or oscillator
 * may have been replaced.  The table below lists the default values.
 */
struct hp300_model hp300_models[] = {
	{ HP_320,	"320",		"16.67"	},
	{ HP_330,	"318/319/330",	"16.67"	},
	{ HP_340,	"340",		"16.67"	},
	{ HP_345,	"345",		"50"	},
	{ HP_350,	"350",		"25"	},
	{ HP_360,	"360",		"25"	},
	{ HP_370,	"370",		"33.33"	},
	{ HP_375,	"375",		"50"	},
	{ HP_380,	"380",		"25"	},
	{ HP_385,	"385",		"33"	},
	{ HP_400,	"400",		"50"	},
	{ HP_425,	"425",		"25"	},
	{ HP_433,	"433",		"33"	},
	{ 0,		NULL,		NULL	},
d634 3
a636 3
	const char *t, *mc, *s;
	char *td;
	int i, len;
d639 3
a641 10
	 * Find the model number.
	 */
	for (t = s = NULL, i = 0; hp300_models[i].name != NULL; i++) {
		if (hp300_models[i].id == machineid) {
			t = hp300_models[i].name;
			s = hp300_models[i].speed;
			break;
		}
	}
	if (t == NULL) {
d645 1
d658 1
a658 1
	 * ...and the CPU type (XXX - not used for 68040).
d662 4
a665 1
		mc = "40";
d668 1
a668 1
		mc = "30";
d671 1
a671 1
		mc = "20";
d677 2
a678 11

	/*
	 * On the 68040 we need to multiply cpuspeed by 3/8.
	 * We do this rather than use hard-coded strings since
	 * the CPU and/or oscillator may have been upgraded.
	 */
	if (cputype == CPU_68040)
		sprintf(cpu_model, "HP 9000/%s%s (%dMHz MC68040 CPU", t, td,
		    cpuspeed * 3 / 8);
	else
		sprintf(cpu_model, "HP 9000/%s (%sMHz MC680%s CPU", t, s, mc);
d709 1
a709 1
		len += sprintf(cpu_model + len, ", %sMHz MC68882 FPU", s);
d712 2
a713 2
		len += sprintf(cpu_model + len, ", %sMHz MC68881 FPU",
		    machineid == HP_350 ? "20" : "16.67");
@


1.46
log
@Remove an extra space in avail mem printf
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2001/05/10 17:02:34 millert Exp $	*/
a406 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.45
log
@fix typo introduced in non-UVM case yesterday
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2001/05/10 01:34:54 millert Exp $	*/
d434 1
a434 1
	printf("avail mem = %lu  (%uK)\n", ptoa(cnt.v_free_count),
@


1.44
log
@o Print memory sizes in KB in addition to bytes like i386 port
o Move model designation info out of hp300_models.
  Since it is non-overlapping we only need a single array to store this.
o For 68040 CPUs use cpuspeed * 3/8 for the CPU speed (in Mhz) that we
  print in the boot message.  That way we get accurate info for upclocked
  systems w/o hard-coding things.  Don't bother doing this with the
  '020 and '030 systems for the moment since they are less likely to have
  been "upgraded".
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2001/05/05 22:33:34 art Exp $	*/
d435 1
a435 1
	    ptoa(cnt.v_free_count)/1024));
@


1.43
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2001/05/05 20:56:34 art Exp $	*/
d297 1
a297 1
	printf("real mem  = %d\n", ctob(physmem));
d431 2
a432 1
	printf("avail mem = %ld\n", ptoa(uvmexp.free));
d434 2
a435 1
	printf("avail mem = %ld\n", ptoa(cnt.v_free_count));
d437 2
a438 2
	printf("using %d buffers containing %d bytes of memory\n",
		nbuf, bufpages * PAGE_SIZE);
a618 1
	const char *designation;
d622 5
d628 14
a641 14
	{ HP_320,	"320",		"        ", "16.67"	},
	{ HP_330,	"318/319/330",	"        ", "16.67"	},
	{ HP_340,	"340",		"        ", "16.67"	},
	{ HP_345,	"345",		"        ", "50"	},
	{ HP_350,	"350",		"        ", "25"	},
	{ HP_360,	"360",		"        ", "25"	},
	{ HP_370,	"370",		"        ", "33.33"	},
	{ HP_375,	"375",		"	 ", "50"	},
	{ HP_380,	"380",		"        ", "25"	},
	{ HP_385,	"385",		"        ", "33"	},
	{ HP_400,	"400",		"        ", "50"	},
	{ HP_425,	"425",		"     t s", "25"	},
	{ HP_433,	"433",		"    t s ", "33"	},
	{ 0,		NULL,		NULL,	    NULL	},
d644 3
d651 1
a651 1
	char td;
d661 1
a661 21

			if (mmuid < strlen(hp300_models[i].designation)) {
				td = (hp300_models[i].designation)[mmuid];
			} else {
				td = (hp300_models[i].designation)[0];
			}

			/*
			 * Adjust speed if the machine appears to be
			 * running at a different clock rate.  Dividing
			 * cpuspeed by 2.67 and truncating it works on my
			 * systems, but I don't want to use floating point.
			 */
			if (cputype == CPU_68040) {
				if (cpuspeed > 100)
					s = "40";
				else if (cpuspeed > 80)
					s = "33";
				else
					s = "25";
			}
d670 11
a680 1
	 * ...and the CPU type.
d697 8
a704 3
	if (td != ' ')
		sprintf(cpu_model, "HP 9000/%s%c (%sMHz MC680%s CPU", t, td,
		    s, mc);
d767 2
a768 3
	strcat(cpu_model, ")");
	printf("%s\n", cpu_model);
#if 0
@


1.42
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2001/05/04 22:48:59 aaron Exp $	*/
a490 1
	configure();
@


1.41
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2000/03/23 09:59:54 art Exp $	*/
d104 1
a104 1
#define	MAXMEM	64*1024*CLSIZE	/* XXX - from cmap.h */
d349 1
a349 1
		curbufsize = CLBYTES * ((i < residual) ? (base+1) : base);
d378 1
a378 1
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
d411 1
a411 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d413 1
a413 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d436 1
a436 1
		nbuf, bufpages * CLBYTES);
d542 1
a542 1
		bufpages = physmem / 10 / CLSIZE;
d941 1
a941 1
 * Dumps always skip the first CLBYTES of disk space
d977 1
a977 1
	/* Always skip the first CLBYTES, in case there is a label there. */
@


1.40
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.39 2000/02/22 19:27:46 deraadt Exp $	*/
/*	$NetBSD: machdep.c,v 1.94 1997/06/12 15:46:29 mrg Exp $	*/
d58 1
d108 4
d124 5
d130 3
a132 1
extern vm_offset_t avail_end;
d178 1
d201 25
d274 2
a275 2
	vm_offset_t minaddr, maxaddr;
	vm_size_t size;
d288 2
a289 3
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);
d303 5
a307 1
	size = (vm_size_t)allocsys((caddr_t)0);
d310 1
d312 1
a312 1
		panic("startup: talbe size inconsistency");
d319 9
a327 1
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
d329 2
a330 2
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
d333 1
d337 32
a368 2
		vm_size_t curbufsize;
		vm_offset_t curbuf;
d377 1
a377 1
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
d381 1
d383 1
d388 4
d394 2
d399 4
d405 1
d414 5
a418 1
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
d420 2
d430 3
d434 1
d444 5
d452 1
d461 5
d469 1
d553 1
d555 1
d966 1
a966 1
	dumpsize = physmem + 1;
d999 1
a999 1
	vm_offset_t maddr;	/* PA being dumped */
d1023 3
a1025 1
	if (dumplo < 0)
d1027 1
d1031 2
a1032 1
	printf("\ndumping to dev 0x%x, offset %ld\n", dumpdev, dumplo);
d1094 2
a1095 2
		pmap_enter(pmap_kernel(), (vm_offset_t)vmmap, maddr,
		    VM_PROT_READ, TRUE, 0);
d1392 1
a1392 1
		pmap_enter(pmap_kernel(), (vm_offset_t)vmmap, ctob(pg),
d1405 1
a1405 1
	pmap_remove(pmap_kernel(), (vm_offset_t)vmmap, (vm_offset_t)&vmmap[NBPG]);
@


1.39
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 1999/09/03 18:00:41 art Exp $	*/
d51 1
a51 1
#include <sys/callout.h>
d323 1
a323 1
	 * Initialize callouts
d325 1
a325 4
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;
d400 1
a400 1
	valloc(callout, struct callout, ncallout);
@


1.38
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 1999/05/22 21:22:22 weingart Exp $	*/
a135 1
int	msgbufmapped;		/* set when safe to use msgbuf */
d249 1
a249 1
	for (i = 0; i < btoc(sizeof (struct msgbuf)); i++)
d253 1
a253 1
	msgbufmapped = 1;
d891 1
@


1.38.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d136 1
d250 1
a250 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d254 1
a254 1
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
a891 1
	extern int msgbufmapped;
@


1.38.4.2
log
@Sync with -current
@
text
@d51 1
a51 1
#include <sys/timeout.h>
d323 1
a323 1
	 * Initialize timeouts
d325 4
a328 1
	timeout_init();
d403 1
a403 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.38.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d2 1
a2 1
/*	$NetBSD: machdep.c,v 1.121 1999/03/26 23:41:29 mycroft Exp $	*/
a57 1
#include <sys/device.h>
d103 1
a103 1
#define	MAXMEM	64*1024	/* XXX - from cmap.h */
a106 2
#include <uvm/uvm_extern.h>

d119 2
a120 5
vm_map_t exec_map = NULL;  
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;

extern paddr_t avail_start, avail_end;
a165 1
void	hp300_init __P((void));
d185 1
a185 1
int	cpuspeed;		/* relative cpu speed */
a187 20
 /*
 * Early initialization, before main() is called.
 */
void
hp300_init()
{
	/*
	 * Tell the VM system about available physical memory.  The
	 * hp300 only has one segment.
	 */
	uvm_page_physload(atop(avail_start), atop(avail_end),
	    atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);

	/* Initialize the interrupt handlers. */
	intr_init();

	/* Calibrate the delay loop. */
	hp300_calibrate_delay();
}

d236 2
a237 2
	vaddr_t minaddr, maxaddr;
	vsize_t size;
d250 3
a252 2
		pmap_enter(pmap_kernel(), (vaddr_t)msgbufp,
		    avail_end + i * NBPG, VM_PROT_ALL, TRUE, VM_PROT_ALL);
d260 1
a260 1
	printf("real mem  = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);
d266 2
a267 2
	size = (vsize_t)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(size))) == 0)
d270 1
a270 1
		panic("startup: table size inconsistency");
d277 6
a282 6
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;
d286 2
a287 3
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;
d290 5
a294 4
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
d296 4
a299 18
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL) 
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
#if defined(PMAP_NEW)
			pmap_kenter_pgs(curbuf, &pg, 1);
#else
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE,
			    TRUE, VM_PROT_READ|VM_PROT_WRITE);
#endif
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
a300 1

d305 2
a306 3
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, TRUE, FALSE, NULL);

d310 2
a311 5
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, TRUE, FALSE, NULL);

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
d313 9
d330 3
a332 4
	printf("avail mem = %lu (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
		nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
d340 1
a340 1
	if (uvm_map_protect(kernel_map, 0, NBPG, UVM_PROT_NONE, TRUE)
d348 1
a348 1
	 * XXX Should be trunc_page(&kernel_text) instead
d351 2
a352 2
	if (uvm_map_protect(kernel_map, NBPG, round_page((vaddr_t)&etext),
	    UVM_PROT_READ|UVM_PROT_EXEC, TRUE) != KERN_SUCCESS)
d375 1
d426 1
a426 1
		bufpages = physmem / 10;
d437 1
d497 5
a501 17
/*
 * Text description of models we support, indexed by machineid.
 */
const char *hp300_models[] = {
	"320",		/* HP_320 */
	"318/319/330",	/* HP_330 */
	"350",		/* HP_350 */
	"360",		/* HP_360 */
	"370",		/* HP_370 */
	"340",		/* HP_340 */
	"345",		/* HP_345 */
	"375",		/* HP_375 */
	"400",		/* HP_400 */
	"380",		/* HP_380 */
	"425",		/* HP_425 */
	"433",		/* HP_433 */
	"385"		/* HP_385 */
d504 16
a519 2
/* Map mmuid to single letter designation in 4xx models (e.g. 425s, 425t) */
char hp300_designations[] = "    ttss e";
d524 3
a526 3
	const char *t;
	char mc, *td;
	int len;
d529 1
a529 1
	 * Map machineid to model name.
d531 28
a558 1
	if (machineid >= sizeof(hp300_models) / sizeof(char *)) {
a561 1
	t = hp300_models[machineid];
d564 1
a564 11
	 * Look up special designation (425s, 425t, etc) by mmuid.
	 */
	if (mmuid < strlen(hp300_designations) &&
	    hp300_designations[mmuid] != ' ') {
		td = &hp300_designations[mmuid];
		td[1] = '\0';
	} else
		td = "";

	/*
	 * ...and the CPU type
d568 1
a568 4
		mc = '4';
		/* adjust cpuspeed by 3/8 on '040 boxes */
		cpuspeed *= 3;
		cpuspeed /= 8;
d571 1
a571 1
		mc = '3';
d574 1
a574 1
		mc = '2';
d580 6
a585 2
	sprintf(cpu_model, "HP 9000/%s%s (%dMHz MC680%c0 CPU", t, td, cpuspeed,
	    mc);
d616 1
a616 1
		len += sprintf(cpu_model + len, ", %dMHz MC68882 FPU", cpuspeed);
d619 2
a620 2
		len += sprintf(cpu_model + len, ", %dMHz MC68881 FPU",
		    machineid == HP_350 ? 20 : 16);
d646 3
a648 2
	printf("%s)\n", cpu_model);
#ifdef DEBUG
d700 1
a700 1
		panic("SPU type not configured for machineid %d", machineid);
a736 6
	case CPU_CPUSPEED:
		return (sysctl_rdint(oldp, oldlenp, newp, cpuspeed));
	case CPU_MACHINEID:
		return (sysctl_rdint(oldp, oldlenp, newp, machineid));
	case CPU_MMUID:
		return (sysctl_rdint(oldp, oldlenp, newp, mmuid));
d749 2
d823 1
a823 1
 * Dumps always skip the first PAGE_SIZE of disk space
d848 1
a848 1
	dumpsize = physmem;
d859 1
a859 1
	/* Always skip the first block, in case there is a label there. */
d881 1
a881 1
	paddr_t maddr;		/* PA being dumped */
d905 1
a905 3
	if (dumplo <= 0) {
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
		    minor(dumpdev));
a906 1
	}
d910 1
a910 2
	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);
d972 2
a973 2
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
		    VM_PROT_READ, TRUE, VM_PROT_READ);
d1270 1
a1270 1
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, ctob(pg),
d1283 1
a1283 1
	pmap_remove(pmap_kernel(), (vaddr_t)vmmap, (vaddr_t)&vmmap[NBPG]);
@


1.38.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38.4.3 2001/07/04 10:15:46 niklas Exp $	*/
d46 2
d95 1
d97 1
d105 1
d107 1
d110 2
d277 2
a278 2
		pmap_enter(pmap_kernel(), (vaddr_t)msgbufp + i * NBPG,
		    avail_end + i * NBPG, VM_PROT_ALL, VM_PROT_ALL|PMAP_WIRED);
d330 1
d332 5
d347 1
a347 1
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d353 1
a353 1
				   VM_PHYS_SIZE, 0, FALSE, NULL);
d358 5
d433 4
d770 3
d806 1
a806 1
haltsys:
d836 1
d838 1
d869 1
d876 1
d902 1
d906 1
d935 1
d951 1
d954 1
d986 3
d996 1
a996 1
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);
d1101 20
d1156 14
d1181 1
a1181 1
nmihand_out:
d1243 1
a1243 1
		regdump(&(fp->F_t), 128);
d1268 1
a1268 1
	 * and it has just occurred.  All we do is return to the higher
d1276 1
a1276 1
	 * for has just occurred (longjmp above) at the current pg+o
d1284 1
a1284 1
	 * If we get here, a parity error has occurred for the first time
d1294 1
a1294 1
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);
d1310 91
@


1.38.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 1
d123 1
d296 1
a296 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
d444 5
@


1.38.4.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38.4.5 2001/11/13 21:00:50 niklas Exp $	*/
d113 3
a115 3
struct vm_map *exec_map = NULL;  
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d296 1
a296 1
				UVM_ADV_NORMAL, 0)))
d320 1
a320 3

			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
d356 2
a357 1
	if (uvm_map_protect(kernel_map, 0, NBPG, UVM_PROT_NONE, TRUE))
d368 1
a368 1
	    UVM_PROT_READ|UVM_PROT_EXEC, TRUE))
@


1.38.4.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
#include <sys/extent.h>
d114 1
a149 6
/*
 * XXX some storage space must be allocated statically because of
 * early console init
 */
char	extiospace[EXTENT_FIXED_STORAGE_SIZE(EIOMAPSIZE / 16)];

d213 1
a213 2
	extern struct extent *extio;
	extern char *extiobase;
d226 2
a227 4
	extio = extent_create("extio",
	    (u_long)extiobase, (u_long)extiobase + ctob(EIOMAPSIZE),
	    M_DEVBUF, extiospace, sizeof(extiospace), EX_NOWAIT);
	    
a268 1
	pmap_update(pmap_kernel());
a326 1
	pmap_update(pmap_kernel());
d341 3
a953 1
		pmap_update(pmap_kernel());
d993 11
d1074 11
d1087 1
d1089 4
a1092 1
		}
d1094 1
a1216 1
		pmap_update(pmap_kernel());
a1228 1
	pmap_update(pmap_kernel());
@


1.38.4.8
log
@Merge in -current from about a week ago
@
text
@d156 8
a163 8
caddr_t	allocsys(caddr_t);
void	parityenable(void);
int	parityerror(struct frame *);
int	parityerrorfind(void);
void    identifycpu(void);
void    initcpu(void);
void	dumpmem(int *, int, int);
char	*hexstr(int, int);
d166 4
a169 4
void    dumpsys(void);
void	hp300_init(void);
void    straytrap(int, u_short);
void	nmihand(struct frame);
d508 1
d869 1
a869 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1240 2
a1241 1
	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
@


1.38.4.9
log
@Sync the SMP branch with 3.3
@
text
@d76 6
d289 1
a289 1
	 * and then give everything true virtual addresses.
d407 1
a407 1
 * allocate that much and fill it with zeroes, and then call
d420 9
d441 2
a442 1
	 * a flag 10%.  Insure a minimum of 16 buffers.
d1222 5
d1233 1
a1233 1
#if defined(COMPAT_44) || defined(COMPAT_SUNOS)
d1249 5
d1269 1
a1269 1
#else /* !(defined(COMPAT_44) || defined(COMPAT_SUNOS)) */
@


1.38.4.10
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38.4.9 2003/03/27 23:19:21 niklas Exp $	*/
d270 1
a270 2
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d561 2
a562 2
	snprintf(cpu_model, sizeof cpu_model,
	    "HP 9000/%s%s (%dMHz MC680%c0 CPU", t, td, cpuspeed, mc);
d570 1
a570 1
		strlcat(cpu_model, "+MMU", sizeof cpu_model);
d573 1
a573 1
		strlcat(cpu_model, ", MC68851 MMU", sizeof cpu_model);
d576 1
a576 1
		strlcat(cpu_model, ", HP MMU", sizeof cpu_model);
d583 2
d590 1
a590 1
		strlcat(cpu_model, "+FPU", sizeof cpu_model);
d593 1
a593 3
		len = strlen(cpu_model);
		snprintf(cpu_model + len, sizeof cpu_model - len,
		    ", %dMHz MC68882 FPU", cpuspeed);
d596 2
a597 3
		len = strlen(cpu_model);
		snprintf(cpu_model + len, sizeof cpu_model - len,
		    ", %dMHz MC68881 FPU", machineid == HP_350 ? 20 : 16);
d600 1
a600 1
		strlcat(cpu_model, ", unknown FPU", sizeof cpu_model);
d607 1
a607 2
		strlcat(cpu_model, ", 4k on-chip physical I/D caches",
		    sizeof cpu_model);
a608 1
		len = strlen(cpu_model);
d611 1
a611 1
			snprintf(cpu_model + len, sizeof cpu_model - len,
d616 1
a616 1
			snprintf(cpu_model + len, sizeof cpu_model - len,
@


1.38.4.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38.4.10 2003/05/13 19:41:03 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.38.4.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d345 2
a346 2
	printf("avail mem = %lu (%luK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
a517 3
#ifdef FPSP
	extern u_long fpvect_tab, fpvect_end, fpsp_tab;
#endif
a679 7

#ifdef FPSP
	if (cputype == CPU_68040) {
		bcopy(&fpsp_tab, &fpvect_tab,
		    (&fpvect_end - &fpvect_tab) * sizeof (fpvect_tab));
	}
#endif
@


1.38.4.13
log
@Merge with the trunk
@
text
@d46 1
d747 1
a747 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
@


1.37
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 1999/04/23 03:11:55 downsj Exp $	*/
d252 2
a253 1
		    avail_end + i * NBPG, VM_PROT_ALL, TRUE);
d976 1
a976 1
		    VM_PROT_READ, TRUE);
d1274 1
a1274 1
		    VM_PROT_READ, TRUE);
@


1.36
log
@Fix kcore initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 1999/02/04 23:00:24 niklas Exp $	*/
a403 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.35
log
@Deterministic register initalization on process startup
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 1998/05/04 06:29:03 downsj Exp $	*/
d860 1
a860 1
	cpu_kcore_hdr.sysseg_pa = 0; /* XXX */
@


1.34
log
@Use cpuspeed (and hard coded values) to print clock speed on '040 models.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 1998/04/25 22:19:48 downsj Exp $	*/
a447 2
 * XXX Should clear registers except sp, pc,
 * but would break init; should be fixed soon.
d458 1
d460 15
a475 1
	frame->f_regs[A2] = (int)PS_STRINGS;
@


1.33
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 1998/04/25 08:27:23 downsj Exp $	*/
d532 15
d639 1
d644 1
@


1.32
log
@Use generic m68k format kcore by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 1998/03/06 17:33:32 millert Exp $	*/
d860 1
a860 1
	char    dump_hdr[dbtob(1)];     /* XXX assume hdr fits in 1 block */
@


1.31
log
@Please gcc 2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 1998/02/09 06:26:19 dima Exp $	*/
d46 2
d94 3
a100 4
#ifdef notyet
#include <machine/kcore.h>	/* XXX should be pulled in by sys/kcore.h */
#endif

d791 3
d824 9
d857 5
d885 18
d904 33
d938 1
@


1.30
log
@Include <ddb/db_var.h> if DDB is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 1998/02/05 16:48:22 deraadt Exp $	*/
d1306 1
a1306 1
	extern sunos_exec_aout_makecmds
@


1.29
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1997/11/06 19:42:37 millert Exp $	*/
d83 3
@


1.28
log
@Idnetify/support hp385 (33Mhz 68040)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 1997/07/06 08:02:05 downsj Exp $	*/
d1027 5
a1031 2
		printf(": entering debugger\n");
		Debugger();
@


1.27
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 1997/04/20 07:01:13 downsj Exp $	*/
d501 1
d657 3
@


1.26
log
@Make -Wall work.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.25 1997/04/17 12:02:34 downsj Exp $	*/
/*	$NetBSD: machdep.c,v 1.89 1997/04/09 20:05:20 thorpej Exp $	*/
d88 1
d103 2
d109 2
a110 2
#include <arch/hp300/hp300/led.h>
#endif /* USELEDS */
d113 1
a113 1
char machine[] = "hp300";		/* cpu "architecture" */
a157 1
void    ledinit __P((void));
d347 1
a347 1
	 * XXX Should be hp300_trunc_page(&kernel_text) instead
d350 1
a350 1
	if (vm_map_protect(kernel_map, NBPG, hp300_round_page(&etext),
d484 23
d510 23
a532 2
	char *t, *mc;
	int len;
d534 6
a539 3
	switch (machineid) {
	case HP_320:
		t = "320 (16.67MHz";
d541 2
a542 8
	case HP_330:
		t = "318/319/330 (16.67MHz";
		break;
	case HP_340:
		t = "340 (16.67MHz";
		break;
	case HP_350:
		t = "350 (25MHz";
d544 2
a545 25
	case HP_360:
		t = "360 (25MHz";
		break;
	case HP_370:
		t = "370 (33.33MHz";
		break;
	case HP_375:
		t = "345/375 (50MHz";
		break;
	case HP_380:
		t = "380 (25MHz";
		break;
	case HP_425:
	        if ((mmuid & 0xff) == 5) {
		    t = "425t (25MHz";
		} else {	/* == 7 */
		    t = "425s (25MHz";
		}
		break;
	case HP_433:
	        if ((mmuid & 0xff) == 4) {
		    t = "433t (33MHz";
		} else {	/* == 6 */
		    t = "433s (33MHz";
		}
d548 2
a549 2
		printf("\nunknown machine type %d\n", machineid);
		panic("startup");
d551 10
a560 3
	mc = (mmutype == MMU_68040 ? "40" :
	       (mmutype == MMU_68030 ? "30" : "20"));
	sprintf(cpu_model, "HP9000/%s MC680%s CPU", t, mc);
d576 1
d578 12
a589 9
	if (mmutype == MMU_68040)
		len += sprintf(cpu_model + len,
		    "+FPU, 4k on-chip physical I/D caches");
	else if (mmutype == MMU_68030)
		len += sprintf(cpu_model + len, ", %sMHz MC68882 FPU",
		       machineid == HP_340 ? "16.67" :
		       (machineid == HP_360 ? "25" :
			(machineid == HP_370 ? "33.33" : "50")));
	else
d591 1
a591 9
		       machineid == HP_350 ? "20" : "16.67");
	switch (ectype) {
	case EC_VIRT:
		sprintf(cpu_model + len, ", %dK virtual-address cache",
		       machineid == HP_320 ? 16 : 32);
		break;
	case EC_PHYS:
		sprintf(cpu_model + len, ", %dK physical-address cache",
		       machineid == HP_370 ? 64 : 32);
d593 22
d616 1
d619 5
a623 2
	printf("delay constant for this cpu: %d  MMU ID: %d\n", 
	       delay_divisor, mmuid & 0xff);
d630 1
a630 1
#if !defined(HP320) && !defined(HP350)
a631 1
	case HP_350:
d633 1
a633 1
#ifndef HP330
d636 1
a636 1
#if !defined(HP340) && !defined(HP360) && !defined(HP370) && !defined(HP375)
d638 8
d647 2
d650 2
d656 5
d662 2
d666 1
a666 1
		panic("CPU type not configured");
d670 4
a707 47

#ifdef USELEDS
int inledcontrol = 0;	/* 1 if we are in ledcontrol already, cheap mutex */
char *ledaddr;

/*
 * Map the LED page and setup the KVA to access it.
 */
void
ledinit()
{
	extern caddr_t ledbase;

	pmap_enter(pmap_kernel(), (vm_offset_t)ledbase, (vm_offset_t)LED_ADDR,
		   VM_PROT_READ|VM_PROT_WRITE, TRUE);
	ledaddr = (char *) ((int)ledbase | (LED_ADDR & PGOFSET));
}

/*
 * Do lights:
 *	`ons' is a mask of LEDs to turn on,
 *	`offs' is a mask of LEDs to turn off,
 *	`togs' is a mask of LEDs to toggle.
 * Note we don't use splclock/splx for mutual exclusion.
 * They are expensive and we really don't need to be that precise.
 * Besides we would like to be able to profile this routine.
 */
void
ledcontrol(ons, offs, togs)
	int ons, offs, togs;
{
	static char currentleds;
	char leds;

	inledcontrol = 1;
	leds = currentleds;
	if (ons)
		leds |= ons;
	if (offs)
		leds &= ~offs;
	if (togs)
		leds ^= togs;
	currentleds = leds;
	*ledaddr = ~leds;
	inledcontrol = 0;
}
#endif
@


1.25
log
@Latest code from Mike + slight fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1997/04/17 11:40:40 downsj Exp $	*/
d230 1
a230 1
	int base, residual, sz;
@


1.24
log
@Use HP_425 for id 7, and fix tests in machdep.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1997/04/17 10:28:39 downsj Exp $	*/
d514 4
a517 4
	        if ((mmuid & 0xff) == 5 || (mmuid & 0xff) == 7) {
		    t = "425 (25MHz";
		} else {	/* == 4 */
		    t = "425 (33MHz";
d521 4
a524 4
	        if ((mmuid & 0xff) == 6) {
		    t = "433 (33MHz";
		} else {	/* == 7 ??? what is this? */
		    t = "433 (25MHz";
@


1.23
log
@Better machine type identification from Mike Smith
(<miff@@spam.frisbee.net.au>).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1997/04/16 11:56:28 downsj Exp $	*/
d514 1
a514 1
	        if (mmuid == 5) {
d521 1
a521 1
	        if (mmuid == 6) {
@


1.22
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1997/03/26 08:32:43 downsj Exp $	*/
d511 8
a518 1
		t = "380/425 (25MHz";
d521 5
a525 1
		t = "433 (33MHz";
d573 2
a574 1
	printf("delay constant for this cpu: %d\n", delay_divisor);
d596 1
@


1.21
log
@Merge changes from NetBSD, up to 3/19/97; undoes some local changes.
Changed to match new arch/m68k code.
genassym.cf is currently just a place holder.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.20 1997/02/24 01:16:09 downsj Exp $	*/
/*	$NetBSD: machdep.c,v 1.83 1997/03/16 09:12:13 thorpej Exp $	*/
a47 4
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/map.h>
#include <sys/proc.h>
d49 2
a50 1
#include <sys/reboot.h>
d52 1
d54 2
a55 2
#include <sys/clist.h>
#include <sys/callout.h>
d57 1
d59 1
d61 3
a63 1
#include <sys/ioctl.h>
a64 1
#include <sys/mount.h>
d67 2
d82 4
d92 4
d102 7
d228 2
a229 2
	register unsigned i;
	register caddr_t v;
d327 1
a327 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
d386 1
a386 1
	register caddr_t v;
d447 1
a447 1
	register struct proc *p;
d576 1
a576 1
#if !defined(HP340) && !defined(HP360) && !defined(HP370)
d580 1
a625 2
#include <hp300/hp300/led.h>

d653 1
a653 1
	register int ons, offs, togs;
d656 1
a656 1
	register char leds;
d676 1
a676 1
	register int howto;
d680 3
d685 1
a685 1
		savectx(curproc->p_addr);
d801 4
d821 1
a821 1
	printf("\ndumping to dev 0x%x, offset %d\n", dumpdev, dumplo);
d905 1
a905 1
	register caddr_t addr;
d907 1
a907 1
	register int i;
d922 1
a922 1
	register caddr_t addr;
d924 1
a924 1
	register int i;
d1092 2
a1093 2
	register volatile int *ip;
	register int i;
@


1.20
log
@Add support for COMPAT_SUNOS and enable it.

hp300 now runs sun3 SunOS executables!
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.19 1997/02/23 21:42:55 downsj Exp $	*/
/*	$NetBSD: machdep.c,v 1.80 1997/02/02 07:58:49 thorpej Exp $	*/
a4 29
 * Copyright (c) 1997 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d439 1
a439 1
#ifdef FPCOPROC
d442 3
a444 2
	m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);
#endif
a455 18
#ifdef COMPAT_HPUX
	p->p_md.md_flags &= ~MDP_HPUXMMAP;
	if (p->p_emul == &emul_hpux) {
		frame->f_regs[A0] = 0; /* not 68010 (bit 31), no FPA (30) */
		retval[0] = 0;		/* no float card */
#ifdef FPCOPROC
		retval[1] = 1;		/* yes 68881 */
#else
		retval[1] = 0;		/* no 68881 */
#endif

		/* Make sure the trace bit is correct.  Doesn't belong here. */
		if (p->p_flag & P_TRACED)
			p->p_md.md_flags |= MDP_HPUXTRACE;
		else
			p->p_md.md_flags &= ~MDP_HPUXTRACE;
	}
#endif
a653 439

#define SS_RTEFRAME	1
#define SS_FPSTATE	2
#define SS_USERREGS	4

struct sigstate {
	int	ss_flags;		/* which of the following are valid */
	struct	frame ss_frame;		/* original exception frame */
	struct	fpframe ss_fpstate;	/* 68881/68882 state info */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;		/* pointer to siginfo_t */
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigstate sf_state;	/* state of the hardware */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
};

#ifdef COMPAT_HPUX
struct	hpuxsigcontext {
	int	hsc_syscall;
	char	hsc_action;
	char	hsc_pad1;
	char	hsc_pad2;
	char	hsc_onstack;
	int	hsc_mask;
	int	hsc_sp;
	short	hsc_ps;
	int	hsc_pc;
/* the rest aren't part of the context but are included for our convenience */
	short	hsc_pad;
	u_int	hsc_magic;		/* XXX sigreturn: cookie */
	struct	sigcontext *hsc_realsc;	/* XXX sigreturn: ptr to BSD context */
};

/*
 * For an HP-UX process, a partial hpuxsigframe follows the normal sigframe.
 * Tremendous waste of space, but some HP-UX applications (e.g. LCL) need it.
 */
struct hpuxsigframe {
	int	hsf_signum;
	struct	sigcontext *hsf_scp;
	int	hsf_nothing;
	struct	hpuxsigcontext hsf_sc;
	int	hsf_regs[15];
};
#endif

#ifdef DEBUG
int sigdebug = 0;
int sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct sigframe *fp, *kfp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short ft;
	int oonstack, fsize;
	extern char sigcode[], esigcode[];
#ifdef COMPAT_HPUX
	extern char hpux_sigcode[], hpux_esigcode[];
#endif

	frame = (struct frame *)p->p_md.md_regs;
	ft = frame->f_format;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
#ifdef COMPAT_HPUX
	if (p->p_emul == &emul_hpux)
		fsize = sizeof(struct sigframe) + sizeof(struct hpuxsigframe);
	else
#endif
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)(frame->f_regs[SP] - fsize);
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x ft %d\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
#endif
	if (useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): useracc failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	kfp = (struct sigframe *)malloc((u_long)fsize, M_TEMP, M_WAITOK);
	/* 
	 * Build the argument list for the signal handler.
	 */
	kfp->sf_signum = sig;
	kfp->sf_sip = NULL;
	kfp->sf_scp = &fp->sf_sc;
	kfp->sf_handler = catcher;

	/*
	 * Save necessary hardware state.  Currently this includes:
	 *	- general registers
	 *	- original exception frame (if not a "normal" frame)
	 *	- FP coprocessor state
	 */
	kfp->sf_state.ss_flags = SS_USERREGS;
	bcopy((caddr_t)frame->f_regs,
	      (caddr_t)kfp->sf_state.ss_frame.f_regs, sizeof frame->f_regs);
	if (ft >= FMT7) {
#ifdef DEBUG
		if (ft > 15 || exframesize[ft] < 0)
			panic("sendsig: bogus frame type");
#endif
		kfp->sf_state.ss_flags |= SS_RTEFRAME;
		kfp->sf_state.ss_frame.f_format = frame->f_format;
		kfp->sf_state.ss_frame.f_vector = frame->f_vector;
		bcopy((caddr_t)&frame->F_u,
		      (caddr_t)&kfp->sf_state.ss_frame.F_u, exframesize[ft]);
		/*
		 * Leave an indicator that we need to clean up the kernel
		 * stack.  We do this by setting the "pad word" above the
		 * hardware stack frame to the amount the stack must be
		 * adjusted by.
		 *
		 * N.B. we increment rather than just set f_stackadj in
		 * case we are called from syscall when processing a
		 * sigreturn.  In that case, f_stackadj may be non-zero.
		 */
		frame->f_stackadj += exframesize[ft];
		frame->f_format = frame->f_vector = 0;
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sendsig(%d): copy out %d of frame %d\n",
			       p->p_pid, exframesize[ft], ft);
#endif
	}
#ifdef FPCOPROC
	kfp->sf_state.ss_flags |= SS_FPSTATE;
	m68881_save(&kfp->sf_state.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&kfp->sf_state.ss_fpstate)
		printf("sendsig(%d): copy out FP state (%x) to %x\n",
		       p->p_pid, *(u_int *)&kfp->sf_state.ss_fpstate,
		       &kfp->sf_state.ss_fpstate);
#endif
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	kfp->sf_sc.sc_onstack = oonstack;
	kfp->sf_sc.sc_mask = mask;
	kfp->sf_sc.sc_sp = frame->f_regs[SP];
	kfp->sf_sc.sc_fp = frame->f_regs[A6];
	kfp->sf_sc.sc_ap = (int)&fp->sf_state;
	kfp->sf_sc.sc_pc = frame->f_pc;
	kfp->sf_sc.sc_ps = frame->f_sr;

	if (psp->ps_siginfo & sigmask(sig)) {
		kfp->sf_sip = &fp->sf_si;
		initsiginfo(&kfp->sf_si, sig, code, type, val);
	}

#ifdef COMPAT_HPUX
	/*
	 * Create an HP-UX style sigcontext structure and associated goo
	 */
	if (p->p_emul == &emul_hpux) {
		register struct hpuxsigframe *hkfp;

		hkfp = (struct hpuxsigframe *)&kfp[1];
		hkfp->hsf_signum = bsdtohpuxsig(kfp->sf_signum);
		hkfp->hsf_scp = (struct sigcontext *)
			&((struct hpuxsigframe *)(&fp[1]))->hsf_sc;
		hkfp->hsf_sc.hsc_syscall = 0;		/* XXX */
		hkfp->hsf_sc.hsc_action = 0;		/* XXX */
		hkfp->hsf_sc.hsc_pad1 = hkfp->hsf_sc.hsc_pad2 = 0;
		hkfp->hsf_sc.hsc_onstack = kfp->sf_sc.sc_onstack;
		hkfp->hsf_sc.hsc_mask = kfp->sf_sc.sc_mask;
		hkfp->hsf_sc.hsc_sp = kfp->sf_sc.sc_sp;
		hkfp->hsf_sc.hsc_ps = kfp->sf_sc.sc_ps;
		hkfp->hsf_sc.hsc_pc = kfp->sf_sc.sc_pc;
		hkfp->hsf_sc.hsc_pad = 0;
		hkfp->hsf_sc.hsc_magic = 0xdeadbeef;
		hkfp->hsf_sc.hsc_realsc = kfp->sf_scp;
		bcopy((caddr_t)frame->f_regs, (caddr_t)hkfp->hsf_regs,
		      sizeof (hkfp->hsf_regs));

		kfp->sf_signum = hkfp->hsf_signum;
		kfp->sf_scp = hkfp->hsf_scp;
	}
#endif
	/* XXX do not copy out siginfo if not needed */
	(void) copyout((caddr_t)kfp, (caddr_t)fp, fsize);
	frame->f_regs[SP] = (int)fp;
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): sig %d scp %x fp %x sc_sp %x sc_ap %x\n",
		       p->p_pid, sig, kfp->sf_scp, fp,
		       kfp->sf_sc.sc_sp, kfp->sf_sc.sc_ap);
#endif
	/*
	 * Signal trampoline code is at base of user stack.
	 */
#ifdef COMPAT_HPUX
	if (p->p_emul == &emul_hpux)
		frame->f_pc = (int)PS_STRINGS - (hpux_esigcode - hpux_sigcode);
	else
#endif
	frame->f_pc = (int)PS_STRINGS - (esigcode - sigcode);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
	free((caddr_t)kfp, M_TEMP);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper priviledges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	register struct sigcontext *scp;
	register struct frame *frame;
	register int rf;
	struct sigcontext tsigc;
	struct sigstate tstate;
	int flags;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
#endif
	if ((int)scp & 1)
		return (EINVAL);
#ifdef COMPAT_HPUX
	/*
	 * Grab context as an HP-UX style context and determine if it
	 * was one that we contructed in sendsig.
	 */
	if (p->p_emul == &emul_hpux) {
		struct hpuxsigcontext *hscp = (struct hpuxsigcontext *)scp;
		struct hpuxsigcontext htsigc;

		if (useracc((caddr_t)hscp, sizeof (*hscp), B_WRITE) == 0 ||
		    copyin((caddr_t)hscp, (caddr_t)&htsigc, sizeof htsigc))
			return (EINVAL);
		/*
		 * If not generated by sendsig or we cannot restore the
		 * BSD-style sigcontext, just restore what we can -- state
		 * will be lost, but them's the breaks.
		 */
		hscp = &htsigc;
		if (hscp->hsc_magic != 0xdeadbeef ||
		    (scp = hscp->hsc_realsc) == 0 ||
		    useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
		    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc)) {
			if (hscp->hsc_onstack & 01)
				p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
			else
				p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
			p->p_sigmask = hscp->hsc_mask &~ sigcantmask;
			frame = (struct frame *) p->p_md.md_regs;
			frame->f_regs[SP] = hscp->hsc_sp;
			frame->f_pc = hscp->hsc_pc;
			frame->f_sr = hscp->hsc_ps &~ PSL_USERCLR;
			return (EJUSTRETURN);
		}
		/*
		 * Otherwise, overlay BSD context with possibly modified
		 * HP-UX values.
		 */
		tsigc.sc_onstack = hscp->hsc_onstack;
		tsigc.sc_mask = hscp->hsc_mask;
		tsigc.sc_sp = hscp->hsc_sp;
		tsigc.sc_ps = hscp->hsc_ps;
		tsigc.sc_pc = hscp->hsc_pc;
	} else
#endif
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	if (useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
		return (EINVAL);
	scp = &tsigc;
	if ((scp->sc_ps & (PSL_MBZ|PSL_IPL|PSL_S)) != 0)
		return (EINVAL);
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->sc_sp;
	frame->f_regs[A6] = scp->sc_fp;
	frame->f_pc = scp->sc_pc;
	frame->f_sr = scp->sc_ps;
	/*
	 * Grab pointer to hardware state information.
	 * If zero, the user is probably doing a longjmp.
	 */
	if ((rf = scp->sc_ap) == 0)
		return (EJUSTRETURN);
	/*
	 * See if there is anything to do before we go to the
	 * expense of copying in close to 1/2K of data
	 */
	flags = fuword((caddr_t)rf);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): sc_ap %x flags %x\n",
		       p->p_pid, rf, flags);
#endif
	/*
	 * fuword failed (bogus sc_ap value).
	 */
	if (flags == -1)
		return (EINVAL);
	if (flags == 0 || copyin((caddr_t)rf, (caddr_t)&tstate, sizeof tstate))
		return (EJUSTRETURN);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sigreturn(%d): ssp %x usp %x scp %x ft %d\n",
		       p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		       (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
#endif
	/*
	 * Restore most of the users registers except for A6 and SP
	 * which were handled above.
	 */
	if (flags & SS_USERREGS)
		bcopy((caddr_t)tstate.ss_frame.f_regs,
		      (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
	/*
	 * Restore long stack frames.  Note that we do not copy
	 * back the saved SR or PC, they were picked up above from
	 * the sigcontext structure.
	 */
	if (flags & SS_RTEFRAME) {
		register int sz;
		
		/* grab frame type and validate */
		sz = tstate.ss_frame.f_format;
		if (sz > 15 || (sz = exframesize[sz]) < 0)
			return (EINVAL);
		frame->f_stackadj -= sz;
		frame->f_format = tstate.ss_frame.f_format;
		frame->f_vector = tstate.ss_frame.f_vector;
		bcopy((caddr_t)&tstate.ss_frame.F_u, (caddr_t)&frame->F_u, sz);
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sigreturn(%d): copy in %d of frame type %d\n",
			       p->p_pid, sz, tstate.ss_frame.f_format);
#endif
	}
#ifdef FPCOPROC
	/*
	 * Finally we restore the original FP context
	 */
	if (flags & SS_FPSTATE)
		m68881_restore(&tstate.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&tstate.ss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %x\n",
		       p->p_pid, *(u_int *)&tstate.ss_fpstate,
		       &tstate.ss_fpstate);
#endif
#endif
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
}
@


1.19
log
@Give HPUX it's own signal trampoline and stop modifying the real one.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 1997/02/10 11:13:30 downsj Exp $	*/
d155 3
d473 11
d1714 1
a1714 1
#if defined(COMPAT_NOMID) || defined(COMPAT_44)
d1719 4
d1742 4
d1747 1
@


1.18
log
@hp300 portion of the copypage/zeropage/mappedcopy changes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1997/02/05 17:33:00 downsj Exp $	*/
a479 26
	}
	/*
	 * XXX This doesn't have much to do with setting registers but
	 * I didn't want to muck up kern_exec.c with this code, so I
	 * stuck it here.
	 *
	 * Ensure we perform the right action on traps type 1 and 2:
	 * If our parent is an HPUX process and we are being traced, turn
	 * on HPUX style interpretation.  Else if we were using the HPUX
	 * style interpretation, revert to the BSD interpretation.
	 *
	 * Note that we do this by changing the trap instruction in the
	 * global "sigcode" array which then gets copied out to the user's
	 * sigcode in the stack.  Since we are changing it in the global
	 * array we must always reset it, even for non-HPUX processes.
	 *
	 * Note also that implementing it in this way creates a potential
	 * race where we could have tweaked it for process A which then
	 * blocks in the copyout to the stack and process B comes along
	 * and untweaks it causing A to wind up with the wrong setting
	 * when the copyout continues.  However, since we have already
	 * copied something out to this user stack page (thereby faulting
	 * it in), this scenerio is extremely unlikely.
	 */
	{
		extern short sigcodetrap[];
d481 2
a482 2
		if ((p->p_pptr->p_emul == &emul_hpux) &&
		    (p->p_flag & P_TRACED)) {
d484 1
a484 2
			*sigcodetrap = 0x4E42;
		} else {
a485 2
			*sigcodetrap = 0x4E41;
		}
d767 3
d932 5
@


1.17
log
@latest siginfo changes from theo
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.16 1997/02/04 07:15:28 downsj Exp $	*/
/*	$NetBSD: machdep.c,v 1.77 1996/12/11 16:49:23 thorpej Exp $	*/
d1340 1
a1341 2
	extern u_int mappedcopysize;

d1347 4
a1350 6
	if (mappedcopysize == 0) {
		if (ectype == EC_VIRT)
			mappedcopysize = (u_int) -1;
		else
			mappedcopysize = NBPG;
	}
@


1.16
log
@More changes of carrel@@netbsd.org's that I missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 1997/02/04 06:21:30 downsj Exp $	*/
d946 1
@


1.15
log
@checkpoint:  pull in spl() changes from NetBSD, and more siginfo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 1997/02/03 15:54:45 deraadt Exp $	*/
d619 1
a619 1
#if !defined(HP360) && !defined(HP370)
@


1.14
log
@mv siginfo_t * to the proper place
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 1997/02/03 12:48:46 deraadt Exp $	*/
a762 1
	int	hsf_code;
a925 1
		hkfp->hsf_code = kfp->sf_code;
@


1.13
log
@repair confusion over kv/uv addr for siginfo_t storage
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1997/02/03 04:47:58 downsj Exp $	*/
d732 1
a732 1
	int	sf_code;		/* additional info for handler */
a733 1
	siginfo_t *sf_sip;
d851 1
a851 1
	kfp->sf_code = code;
a853 1
	kfp->sf_sip = NULL;
@


1.12
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 1997/01/16 20:43:33 kstailey Exp $	*/
d916 2
a917 2
		kfp->sf_sip = &kfp->sf_si;
		initsiginfo(kfp->sf_sip, sig, code, type, val);
@


1.11
log
@do not call resettodr() if RB_TIMEBAD is set due to being in ddb with clock updates suspended
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 1997/01/15 04:54:45 downsj Exp $	*/
d5 29
d373 7
d734 1
d738 1
d766 1
d784 1
a784 1
sendsig(catcher, sig, mask, code)
d788 2
d855 2
d914 6
d1205 2
a1206 3
		printf("System halted.\n\n");
		asm("	stop	#0x2700");
		/* NOTREACHED */
@


1.10
log
@Don't need this, /sys/compat/m68k4k works better.

OpenBSD/hp300 is now 8k!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 1997/01/12 15:13:23 downsj Exp $	*/
d1125 2
a1126 1
		 * will be out of synch; adjust it now.
d1128 5
a1132 1
		resettodr();
@


1.9
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1686 5
#if defined(COMPAT_M68K4K)
	case (MID_M68K4K << 16) | ZMAGIC:
		error = cpu_exec_aout_prep_m68k4k(p, epp);
		break;
#endif
a1705 47

#if defined(COMPAT_M68K4K)
int
cpu_exec_aout_prep_m68k4k(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	struct exec *execp = epp->ep_hdr;

	epp->ep_taddr = 4096;
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = epp->ep_taddr + execp->a_text;
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

	/*
	 * check if vnode is in open for writing, because we want to
	 * demand-page out of it.  if it is, don't do it, for various
	 * reasons
	 */
	if ((execp->a_text != 0 || execp->a_data != 0) &&
	    epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0\n");
#endif
		return ETXTBSY;
	}
	epp->ep_vp->v_flag |= VTEXT;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_text,
	    epp->ep_taddr, epp->ep_vp, 0, VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_data,
	    epp->ep_daddr, epp->ep_vp, execp->a_text,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, execp->a_bss,
	    epp->ep_daddr + execp->a_data, NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return exec_setup_stack(p, epp);
}
#endif /* COMPAT_M68K4K */
@


1.8
log
@MID_M68K is the default now (with backwards compat for MID_M68K4K
@
text
@d1 2
a2 1
/*	$NetBSD: machdep.c,v 1.66 1996/05/18 23:30:09 thorpej Exp $	*/
d127 16
d206 1
d208 2
a209 2
	register caddr_t v, firstaddr;
	int base, residual;
a211 5
#ifdef BUFFERS_UNMANAGED
	vm_offset_t bufmemp;
	caddr_t buffermem;
	int ix;
#endif
d233 1
a233 1
	printf("real mem = %d\n", ctob(physmem));
d236 2
a237 13
	 * Allocate space for system data structures.
	 * The first available real memory address is in "firstaddr".
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
	 * As pages of memory are allocated and cleared,
	 * "firstaddr" is incremented.
	 * An index into the kernel page table corresponding to the
	 * virtual memory address maintained in "v" is kept in "mapaddr".
	 */
	/*
	 * Make two passes.  The first pass calculates how much memory is
	 * needed and allocates it.  The second pass assigns virtual
	 * addresses to the various data structures.
d239 5
a243 3
	firstaddr = 0;
again:
	v = (caddr_t)firstaddr;
a244 67
#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
	valloc(callout, struct callout, ncallout);
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
#ifdef SYSVSHM
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
	
	/*
	 * Determine how many buffers to allocate.
	 * Since HPs tend to be long on memory and short on disk speed,
	 * we allocate more buffer space than the BSD standard of
	 * use 10% of memory for the first 2 Meg, 5% of remaining.
	 * We just allocate a flat 10%.  Insure a minimum of 16 buffers.
	 * We allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = physmem / 10 / CLSIZE;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
	valloc(swbuf, struct buf, nswbuf);
	valloc(buf, struct buf, nbuf);
	/*
	 * End of first pass, size has been calculated so allocate memory
	 */
	if (firstaddr == 0) {
		size = (vm_size_t)(v - firstaddr);
		firstaddr = (caddr_t) kmem_alloc(kernel_map, round_page(size));
		if (firstaddr == 0)
			panic("startup: no room for tables");
#ifdef BUFFERS_UNMANAGED
		buffermem = (caddr_t) kmem_alloc(kernel_map, bufpages*CLBYTES);
		if (buffermem == 0)
			panic("startup: no room for buffers");
#endif
		goto again;
	}
	/*
	 * End of second pass, addresses have been assigned
	 */
	if ((vm_size_t)(v - firstaddr) != size)
		panic("startup: table size inconsistency");
a257 3
#ifdef BUFFERS_UNMANAGED
	bufmemp = (vm_offset_t) buffermem;
#endif
a270 17
#ifdef BUFFERS_UNMANAGED
		/*
		 * Move the physical pages over from buffermem.
		 */
		for (ix = 0; ix < curbufsize/CLBYTES; ix++) {
			vm_offset_t pa;

			pa = pmap_extract(pmap_kernel(), bufmemp);
			if (pa == 0)
				panic("startup: unmapped buffer");
			pmap_remove(pmap_kernel(), bufmemp, bufmemp+CLBYTES);
			pmap_enter(pmap_kernel(),
				   (vm_offset_t)(curbuf + ix * CLBYTES),
				   pa, VM_PROT_READ|VM_PROT_WRITE, TRUE);
			bufmemp += CLBYTES;
		}
#else
a272 1
#endif
a273 9
#ifdef BUFFERS_UNMANAGED
#if 0
	/*
	 * We would like to free the (now empty) original address range
	 * but too many bad things will happen if we try.
	 */
	kmem_free(kernel_map, (vm_offset_t)buffermem, bufpages*CLBYTES);
#endif
#endif
d309 22
d348 65
d489 1
d601 1
d640 1
d659 1
d1210 2
a1211 3
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
d1213 1
d1216 6
d1223 1
d1225 2
d1234 6
a1239 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d1242 9
a1250 1
	switch ((*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {
d1252 10
a1261 3
	case ENXIO:
		printf("device bad\n");
		break;
d1263 3
a1265 3
	case EFAULT:
		printf("device not ready\n");
		break;
d1267 3
a1269 3
	case EINVAL:
		printf("area improper\n");
		break;
d1271 3
a1273 3
	case EIO:
		printf("i/o error\n");
		break;
d1275 3
a1277 3
	case EINTR:
		printf("aborted from console\n");
		break;
d1279 4
a1282 3
	default:
		printf("succeeded\n");
		break;
d1284 1
d1287 1
d1311 1
d1320 2
d1324 1
a1330 3
#ifdef lint
	i = *addr; if (i) return(0);
#endif
d1341 1
a1347 3
#ifdef lint
	i = *addr; if (i) return(0);
#endif
a1357 4
#if (defined(DDB) || defined(DEBUG)) && !defined(PANICBUTTON)
#define PANICBUTTON
#endif

d1359 3
d1363 5
a1367 2
int crashandburn = 0;
int candbdelay = 50;	/* give em half a second */
d1376 3
a1378 1
#endif
d1383 1
d1387 7
d1395 1
a1395 2
#ifdef PANICBUTTON
		static int innmihand = 0;
d1398 7
a1404 2
		 * Attempt to reduce the window of vulnerability for recursive
		 * NMIs (e.g. someone holding down the keyboard reset button).
a1405 5
		if (innmihand == 0) {
			innmihand = 1;
			printf("Got a keyboard NMI\n");
			innmihand = 0;
		}
d1407 1
d1410 1
d1414 7
a1420 2
				panic(panicstr ?
				      "forced crash, nosync" : "forced crash");
d1422 3
a1424 3
			crashandburn++;
			timeout(candbtimer, (void *)0, candbdelay);
		}
d1426 2
a1427 2
#endif /* PANICBUTTON */
		return;
d1429 1
d1434 3
d1451 1
a1458 1
#ifdef DEBUG
a1459 1
#endif
a1464 1
#ifdef DEBUG
a1465 1
#endif
d1472 1
d1485 1
a1485 1
	if (!findparerror())
d1507 2
a1508 1
findparerror()
d1566 1
a1573 1
	extern char *hexstr();
d1609 1
a1614 1
	extern char *hexstr();
d1755 1
a1755 1
	return exec_aout_setup_stack(p, epp);
@


1.7
log
@sync to 0622
@
text
@d1637 5
d1661 47
@


1.6
log
@fix the panic at reboot.
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.62 1996/03/13 23:42:45 scottr Exp $	*/
d137 9
d150 1
a163 32
	 * Set cpuspeed immediately since hp300_cninit() called routines
	 * might use delay.  Note that we only set it if a custom value
	 * has not already been specified.
	 */
	if (cpuspeed == 0) {
		switch (machineid) {
		case HP_320:
		case HP_330:
		case HP_340:
			cpuspeed = MHZ_16;
			break;
		case HP_350:
		case HP_360:
		case HP_380:
			cpuspeed = MHZ_25;
			break;
		case HP_370:
		case HP_433:
			cpuspeed = MHZ_33;
			break;
		case HP_375:
			cpuspeed = MHZ_50;
			break;
		default:	/* assume the fastest */
			cpuspeed = MHZ_50;
			break;
		}
		if (mmutype == MMU_68040)
			cpuspeed *= 2;	/* XXX */
	}

	/*
d574 1
a1122 4
		extern struct proc proc0;
		/* make panic at reboot go away */
		if (curproc == NULL)
			curproc = &proc0;
d1639 1
a1639 1
		error = cpu_exec_aout_prep_oldzmagic(p, epp);
d1644 1
a1644 1
		error = cpu_exec_aout_prep_oldzmagic(p, epp);
a1655 56

#if defined(COMPAT_NOMID) || defined(COMPAT_44)
/*
 * cpu_exec_aout_prep_oldzmagic():
 *	Prepare the vmcmds to build a vmspace for an old
 *	(i.e. USRTEXT == 0) binary.
 *
 * Cloned from exec_aout_prep_zmagic() in kern/exec_aout.c; a more verbose
 * description of operation is there.
 */
int
cpu_exec_aout_prep_oldzmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	struct exec *execp = epp->ep_hdr;

	epp->ep_taddr = 0;
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = epp->ep_taddr + execp->a_text;
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

	/*
	 * check if vnode is in open for writing, because we want to			 * demand-page out of it.  if it is, don't do it, for various
	 * reasons
	 */
	if ((execp->a_text != 0 || execp->a_data != 0) &&
	    epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0\n");
#endif
		return ETXTBSY;
	}
	epp->ep_vp->v_flag |= VTEXT;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_text,
	    epp->ep_taddr, epp->ep_vp, NBPG, /* XXX - should NBPG be CLBYTES? */
	    VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_data,
	    epp->ep_daddr, epp->ep_vp,
	    execp->a_text + NBPG, /* XXX - should NBPG be CLBYTES? */
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, execp->a_bss,
	    epp->ep_daddr + execp->a_data, NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return exec_aout_setup_stack(p, epp);
}
#endif /* COMPAT_NOMID */
@


1.5
log
@sync w/ Net 960424
@
text
@d1144 4
@


1.4
log
@sync with netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.56 1996/01/16 22:24:33 thorpej Exp $	*/
d78 1
d83 1
a84 2
#include <hp300/hp300/isr.h>
#include <net/netisr.h>
d88 1
d127 10
d143 1
d146 9
a154 1
	 * Set cpuspeed immediately since cninit() called routines
d184 1
d186 3
a188 3
         * Find what hardware is attached to this machine.
         */
	find_devs();
d193 3
a195 1
	cninit();
d1164 3
a1166 3
#ifdef PANICWAIT
	if ((howto & RB_HALT) == 0) {
		printf("hit any hey to reboot...\n");
a1347 83
}

netintr()
{
#ifdef INET
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
#endif
#ifdef NS
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
#endif
#ifdef ISO
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
#endif
#ifdef CCITT
	if (netisr & (1 << NETISR_CCITT)) {
		netisr &= ~(1 << NETISR_CCITT);
		ccittintr();
	}
#endif
#include "ppp.h"
#if NPPP > 0
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
#endif
}

intrhand(sr)
	int sr;
{
	register struct isr *isr;
	register int found = 0;
	register int ipl;
	extern struct isr isrqueue[];
	static int straycount;

	ipl = (sr >> 8) & 7;
	switch (ipl) {

	case 3:
	case 4:
	case 5:
		ipl = ISRIPL(ipl);
		isr = isrqueue[ipl].isr_forw;
		for (; isr != &isrqueue[ipl]; isr = isr->isr_forw) {
			if ((isr->isr_intr)(isr->isr_arg)) {
				found++;
				break;
			}
		}
		if (found)
			straycount = 0;
		else if (++straycount > 50)
			panic("intrhand: stray interrupt");
		else
			printf("stray interrupt, sr 0x%x\n", sr);
		break;

	case 0:
	case 1:
	case 2:
	case 6:
	case 7:
		if (++straycount > 50)
			panic("intrhand: unexpected sr");
		else
			printf("intrhand: unexpected sr 0x%x\n", sr);
		break;
	}
@


1.3
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.55 1996/01/04 22:21:51 jtc Exp $	*/
a1686 18

#ifdef STACKCHECK
char oflowmsg[] = "k-stack overflow";
char uflowmsg[] = "k-stack underflow";

badkstack(oflow, fr)
	int oflow;
	struct frame fr;
{
	extern char kstackatbase[];

	printf("%s: sp should be %x\n", 
	       oflow ? oflowmsg : uflowmsg,
	       kstackatbase - (exframesize[fr.f_format] + 8));
	regdump(&fr, 0);
	panic(oflow ? oflowmsg : uflowmsg);
}
#endif
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.54 1995/11/20 00:58:54 thorpej Exp $	*/
d776 1
a776 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_base +
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.52 1995/10/07 06:25:31 mycroft Exp $	*/
d1107 2
d1113 6
d1120 1
a1120 1
	if ((howto&RB_NOSYNC) == 0 && waittime < 0) {
d1129 23
a1151 3
	splhigh();			/* extreme priority */
	if (howto&RB_HALT) {
		printf("halted\n\n");
d1153 1
a1153 5
	} else {
		if (howto & RB_DUMP)
			dumpsys();
		doboot();
		/*NOTREACHED*/
d1155 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

