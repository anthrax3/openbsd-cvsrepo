head	1.64;
access;
symbols
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.62.0.4
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.2
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.60.0.4
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.2
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.56.0.4
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.56.0.2
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.53.0.4
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.2
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.52.0.4
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.48.0.4
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.48.0.2
	OPENBSD_3_9_BASE:1.48
	OPENBSD_3_8:1.47.0.2
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.46.0.2
	OPENBSD_3_7_BASE:1.46
	OPENBSD_3_6:1.44.0.4
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.44
	SMP_SYNC_B:1.44
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.40.0.2
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.36.0.2
	OPENBSD_3_1_BASE:1.36
	UBC_SYNC_B:1.38
	UBC:1.35.0.2
	UBC_BASE:1.35
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.16.0.8
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.6
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.4
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.64
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.63;

1.63
date	2013.11.02.13.49.22;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2012.12.31.06.46.13;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2011.11.16.20.50.18;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2010.07.02.19.57.14;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2010.06.29.20.30.31;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.15.20.40.23;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.08.20.57.16;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.15.13.46.22;	author martin;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.01.09.29.27;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.28.16.38.45;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.12.23.14.00;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.01.09.55.47;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.06.20.12.23;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.15.17.22.25;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.20.20.08.16;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.02.18.47.58;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.09.22.27.08;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.09.00.45.37;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.23.03.03.15;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.16.21.11.13;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.06.18.53.01;	author millert;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.25.17.15.19;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.04.02.58.54;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.14.06.04.58;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.25.16.15.15;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.25.11.37.26;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.25.13.25.31;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.27.04.05.45;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.08.08.08.45;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.13.17.19.56;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.11.23.24.57;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.05.21.26.35;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.05.20.56.34;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.04.22.48.59;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.10.18.15.38;	author art;	state Exp;
branches;
next	1.16;

1.16
date	99.09.18.21.41.41;	author downsj;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	99.09.03.18.00.43;	author art;	state Exp;
branches;
next	1.14;

1.14
date	98.05.27.05.40.18;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.03.07.12.41.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.07.13.09.48.01;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.07.06.08.02.09;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.04.16.11.56.32;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.03.26.08.32.45;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.02.21.06.07.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.02.05.17.33.02;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.04.06.21.32;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.02.03.04.47.59;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.12.15.13.28;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.16.45.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.29.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.24;	author deraadt;	state Exp;
branches;
next	;

1.16.4.1
date	2001.04.18.16.05.42;	author niklas;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2001.07.04.10.15.49;	author niklas;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.16.4.4;

1.16.4.4
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.16.4.5;

1.16.4.5
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.16.4.6;

1.16.4.6
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.16.4.7;

1.16.4.7
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.16.4.8;

1.16.4.8
date	2003.03.27.23.19.21;	author niklas;	state Exp;
branches;
next	1.16.4.9;

1.16.4.9
date	2003.06.07.11.11.35;	author ho;	state Exp;
branches;
next	1.16.4.10;

1.16.4.10
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	;

1.35.2.1
date	2002.06.11.03.35.20;	author art;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: trap.c,v 1.63 2013/11/02 13:49:22 miod Exp $	*/
/*	$NetBSD: trap.c,v 1.57 1998/02/16 20:58:31 thorpej Exp $	*/

/*
 * Copyright (c) 1997 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: trap.c 1.37 92/12/20$
 *
 *	@@(#)trap.c	8.5 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/acct.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/resourcevar.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
#include <sys/syslog.h>
#include <sys/user.h>

#include <m68k/frame.h>

#include <machine/db_machdep.h>
#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/intr.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>

#include <dev/cons.h>

int	writeback(struct frame *);
void	trap(int type, u_int code, u_int v, struct frame frame);
void	syscall(register_t code, struct frame frame);
void	wb_userret(struct proc *, struct frame *);

#ifdef DEBUG
void	dumpssw(u_short);
void	dumpwb(int, u_short, u_int, u_int);
#endif

int	astpending;

char	*trap_type[] = {
	"Bus error",
	"Address error",
	"Illegal instruction",
	"Zero divide",
	"CHK instruction",
	"TRAPV instruction",
	"Privilege violation",
	"Trace trap",
	"MMU fault",
	"SSIR trap",
	"Format error",
	"68881 exception",
	"Coprocessor violation",
	"Async system trap"
};
int	trap_types = sizeof trap_type / sizeof trap_type[0];

/*
 * Size of various exception stack frames (minus the standard 8 bytes)
 */
short	exframesize[] = {
	FMT0SIZE,	/* type 0 - normal (68020/030/040/060) */
	FMT1SIZE,	/* type 1 - throwaway (68020/030/040) */
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040/060) */
	FMT3SIZE,	/* type 3 - FP post-instruction (68040/060) */
	FMT4SIZE,	/* type 4 - access error/fp disabled (68060) */
	-1, -1,		/* type 5-6 - undefined */
	FMT7SIZE,	/* type 7 - access error (68040) */
	58,		/* type 8 - bus fault (68010) */
	FMT9SIZE,	/* type 9 - coprocessor mid-instruction (68020/030) */
	FMTASIZE,	/* type A - short bus fault (68020/030) */
	FMTBSIZE,	/* type B - long bus fault (68020/030) */
	-1, -1, -1, -1	/* type C-F - undefined */
};

#ifdef M68060
#define	KDFAULT_060(c)	(cputype == CPU_68060 && ((c) & FSLW_TM_SV))
#define	WRFAULT_060(c)	(cputype == CPU_68060 && ((c) & FSLW_RW_W))
#else
#define	KDFAULT_060(c)	0
#define	WRFAULT_060(c)	0
#endif

#ifdef M68040
#define	KDFAULT_040(c)	(cputype == CPU_68040 && \
			 ((c) & SSW4_TMMASK) == SSW4_TMKD)
#define	WRFAULT_040(c)	(cputype == CPU_68040 && \
			 ((c) & SSW4_RW) == 0)
#else
#define	KDFAULT_040(c)	0
#define	WRFAULT_040(c)	0
#endif

#if defined(M68030) || defined(M68020)
#define	KDFAULT_OTH(c)	(cputype <= CPU_68030 && \
			 ((c) & (SSW_DF|SSW_FCMASK)) == (SSW_DF|FC_SUPERD))
#define	WRFAULT_OTH(c)	(cputype <= CPU_68030 && \
			 ((c) & (SSW_DF|SSW_RW)) == SSW_DF)
#else
#define	KDFAULT_OTH(c)	0
#define	WRFAULT_OTH(c)	0
#endif

#define	KDFAULT(c)	(KDFAULT_060(c) || KDFAULT_040(c) || KDFAULT_OTH(c))
#define	WRFAULT(c)	(WRFAULT_060(c) || WRFAULT_040(c) || WRFAULT_OTH(c))

#ifdef DEBUG
int mmudebug = 0;
int mmupid = -1;
#define MDB_FOLLOW	1
#define MDB_WBFOLLOW	2
#define MDB_WBFAILED	4
#define MDB_ISPID(p)	((p) == mmupid)
#endif

#ifdef M68040
/*
 * Handle writeback completion on 68040.
 */
void
wb_userret(struct proc *p, struct frame *fp)
{
	/*
	 * Deal with user mode writebacks (from trap, or from sigreturn).
	 * If any writeback fails, go back and attempt signal delivery.
	 * unless we have already been here and attempted the writeback
	 * (e.g. bad address with user ignoring SIGSEGV).  In that case
	 * we just return to the user without successfully completing
	 * the writebacks.  Maybe we should just drop the sucker?
	 */
	if (cputype == CPU_68040 && fp->f_format == FMT7) {
		int sig;
		union sigval sv;

		if ((sig = writeback(fp)) != 0) {
			sv.sival_ptr = (caddr_t)fp->f_fmt7.f_fa;
			trapsignal(p, sig, T_MMUFLT, SEGV_MAPERR, sv);

			userret(p);
		}
	}
}
#endif

/*
 * Trap is called from locore to handle most types of processor traps,
 * including events such as simulated software interrupts/AST's.
 * System calls are broken out for efficiency.
 */
/*ARGSUSED*/
void
trap(type, code, v, frame)
	int type;
	unsigned code;
	unsigned v;
	struct frame frame;
{
	struct proc *p;
	int i, s;
	u_int ucode;
	int typ = 0;
	union sigval sv;

	uvmexp.traps++;
	p = curproc;
	ucode = 0;

	/* I have verified that this DOES happen! -gwr */
	if (p == NULL)
		p = &proc0;
#ifdef DIAGNOSTIC
	if (p->p_addr == NULL)
		panic("trap: no pcb");
#endif

	if (USERMODE(frame.f_sr)) {
		type |= T_USER;
		p->p_md.md_regs = frame.f_regs;
	}
	switch (type) {

	default:
dopanic:
		printf("trap type %d, code = 0x%x, v = 0x%x\n", type, code, v);
		printf("%s program counter = 0x%x\n",
		    (type & T_USER) ? "user" : "kernel", frame.f_pc);
		/*
		 * Let the kernel debugger see the trap frame that
		 * caused us to panic.  This is a convenience so
		 * one can see registers at the point of failure.
		 */
		s = splhigh();
#ifdef KGDB
		/* If connected, step or cont returns 1 */
		if (kgdb_trap(type, &frame))
			goto kgdb_cont;
#endif
#ifdef DDB
		(void)kdb_trap(type, (db_regs_t *)&frame);
#endif
#ifdef KGDB
	kgdb_cont:
#endif
		splx(s);
		if (panicstr) {
			printf("trap during panic!\n");
#ifdef DEBUG
			/* XXX should be a machine-dependent hook */
			printf("(press a key)\n");
			cnpollc(1); (void)cngetc(); cnpollc(0);
#endif
		}
		regdump(&(frame.F_t), 128);
		type &= ~T_USER;
		if ((u_int)type < trap_types)
			panic(trap_type[type]);
		panic("trap");

	case T_BUSERR:		/* kernel bus error */
		if (p->p_addr->u_pcb.pcb_onfault == 0)
			goto dopanic;
		/* FALLTHROUGH */

	copyfault:
		/*
		 * If we have arranged to catch this fault in any of the
		 * copy to/from user space routines, set PC to return to
		 * indicated location and set flag informing buserror code
		 * that it may need to clean up stack frame.
		 */
		frame.f_stackadj = exframesize[frame.f_format];
		frame.f_format = frame.f_vector = 0;
		frame.f_pc = (int) p->p_addr->u_pcb.pcb_onfault;
		return;

	case T_BUSERR|T_USER:	/* bus error */
		typ = BUS_OBJERR;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;
	case T_ADDRERR|T_USER:	/* address error */
		typ = BUS_ADRALN;
		ucode = code & ~T_USER;
		i = SIGBUS;
		break;

	case T_COPERR:		/* kernel coprocessor violation */
	case T_FMTERR|T_USER:	/* do all RTE errors come in as T_USER? */
	case T_FMTERR:		/* ...just in case... */
	/*
	 * The user has most likely trashed the RTE or FP state info
	 * in the stack frame of a signal handler.
	 */
		printf("pid %d: kernel %s exception\n", p->p_pid,
		       type==T_COPERR ? "coprocessor" : "format");
		sigexit(p, SIGILL);
		/* NOTREACHED */
		break;

	case T_COPERR|T_USER:	/* user coprocessor violation */
	/* What is a proper response here? */
		typ = FPE_FLTINV;
		ucode = 0;
		i = SIGFPE;
		break;

	case T_FPERR|T_USER:	/* 68881 exceptions */
	/*
	 * We pass along the 68881 status which locore stashed
	 * in code for us.  Note that there is a possibility that the
	 * bit pattern of this will conflict with one of the
	 * FPE_* codes defined in signal.h.  Fortunately for us, the
	 * only such codes we use are all in the range 1-7 and the low
	 * 3 bits of the status are defined as 0 so there is
	 * no clash.
	 */
		typ = FPE_FLTRES;
		ucode = code;
		i = SIGFPE;
		v = frame.f_pc;
		break;

#ifdef M68040
	case T_FPEMULI|T_USER:	/* unimplemented FP instruction */
	case T_FPEMULD|T_USER:	/* unimplemented FP data type */
		/* XXX need to FSAVE */
		printf("pid %d(%s): unimplemented FP %s at %x (EA %x)\n",
		       p->p_pid, p->p_comm,
		       frame.f_format == 2 ? "instruction" : "data type",
		       frame.f_pc, frame.f_fmt2.f_iaddr);
		/* XXX need to FRESTORE */
		typ = FPE_FLTINV;
		i = SIGFPE;
		v = frame.f_pc;
		break;
#endif

	case T_ILLINST|T_USER:	/* illegal instruction fault */
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_ILLOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;

	case T_PRIVINST|T_USER:	/* privileged instruction fault */
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_PRVOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;

	case T_ZERODIV|T_USER:	/* Divide by zero */
		ucode = frame.f_format;	/* XXX was FPE_INTDIV_TRAP */
		typ = FPE_INTDIV;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	case T_CHKINST|T_USER:	/* CHK instruction trap */
		ucode = frame.f_format;	/* XXX was FPE_SUBRNG_TRAP */
		typ = FPE_FLTSUB;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	case T_TRAPVINST|T_USER:	/* TRAPV instruction trap */
		ucode = frame.f_format;	/* XXX was FPE_INTOVF_TRAP */
		typ = ILL_ILLTRP;
		i = SIGILL;
		v = frame.f_pc;
		break;

	/*
	 * XXX: Trace traps are a nightmare.
	 *
	 *	HP-UX uses trap #1 for breakpoints,
	 *	OpenBSD/m68k uses trap #2,
	 *	SUN 3.x uses trap #15,
	 *	DDB and KGDB uses trap #15 (for kernel breakpoints;
	 *	handled elsewhere).
	 *
	 * OpenBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
	 * SUN 3.x traps get passed through as T_TRAP15 and are not really
	 * supported yet.
	 *
	 * XXX: We should never get kernel-mode T_TRAP15
	 * XXX: because locore.s now gives them special treatment.
	 */
	case T_TRAP15:		/* kernel breakpoint */
#ifdef DEBUG
		printf("unexpected kernel trace trap, type = %d\n", type);
		printf("program counter = 0x%x\n", frame.f_pc);
#endif
		frame.f_sr &= ~PSL_T;
		return;

	case T_TRACE|T_USER:	/* user trace trap */
	case T_TRACE:		/* tracing a trap instruction */
	case T_TRAP15|T_USER:	/* SUN user trace trap */
		frame.f_sr &= ~PSL_T;
		i = SIGTRAP;
		typ = TRAP_TRACE;
		break;

	case T_ASTFLT:		/* system async trap, cannot happen */
		goto dopanic;

	case T_ASTFLT|T_USER:	/* user async trap */
		astpending = 0;
		/*
		 * We check for software interrupts first.  This is because
		 * they are at a higher level than ASTs, and on a VAX would
		 * interrupt the AST.  We assume that if we are processing
		 * an AST that we must be at IPL0 so we don't bother to
		 * check.  Note that we ensure that we are at least at SIR
		 * IPL while processing the SIR.
		 */
		splsoft();
		/* FALLTHROUGH */

	case T_SSIR:		/* software interrupt */
	case T_SSIR|T_USER:
	    {
		int sir, q, mask;

		while ((sir = softpending) != 0) {
			atomic_clearbits_int(&softpending, sir);

			for (q = SI_NQUEUES - 1, mask = 1 << (SI_NQUEUES - 1);
			    mask != 0; q--, mask >>= 1)
				if (mask & sir)
					softintr_dispatch(q);
		}
	    }

		/*
		 * If this was not an AST trap, we are all done.
		 */
		if (type != (T_ASTFLT|T_USER)) {
			uvmexp.traps--;
			return;
		}
		spl0();
		if (p->p_flag & P_OWEUPC) {
			ADDUPROF(p);
		}
		if (type == (T_ASTFLT | T_USER) && want_resched) {
			preempt(NULL);
		}
		goto out;

	case T_MMUFLT:		/* kernel mode page fault */
	case T_MMUFLT|T_USER:	/* page fault */
	    {
		vaddr_t va;
		struct vmspace *vm = p->p_vmspace;
		struct vm_map *map;
		int rv;
		vm_prot_t ftype, vftype;
		extern struct vm_map *kernel_map;

#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
		printf("trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n",
		       p->p_pid, code, v, frame.f_pc, frame.f_sr);
#endif
		/*
		 * It is only a kernel address space fault iff:
		 * 	1. (type & T_USER) == 0  and
		 * 	2. pcb_onfault not set or
		 *	3. pcb_onfault set but supervisor space data fault
		 * The last can occur during an exec() copyin where the
		 * argument space is lazy-allocated.
		 */
		if ((type & T_USER) == 0 &&
		    ((p->p_addr->u_pcb.pcb_onfault == 0) || KDFAULT(code)))
			map = kernel_map;
		else
			map = vm ? &vm->vm_map : kernel_map;

		if (WRFAULT(code)) {
			vftype = VM_PROT_WRITE;
			ftype = VM_PROT_READ | VM_PROT_WRITE;
		} else
			vftype = ftype = VM_PROT_READ;

		va = trunc_page((vaddr_t)v);

		if (map == kernel_map && va == 0) {
			printf("trap: bad kernel %s access at 0x%x\n",
			    (ftype & VM_PROT_WRITE) ? "read/write" :
			    "read", v);
			goto dopanic;
		}

		rv = uvm_fault(map, va, 0, ftype);
#ifdef DEBUG
		if (rv && MDB_ISPID(p->p_pid))
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x) -> 0x%x\n",
			    map, va, ftype, rv);
#endif
		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if ((vm != NULL && (caddr_t)va >= vm->vm_maxsaddr)
		    && map != kernel_map) {
			if (rv == 0) {
				uvm_grow(p, va);
			} else if (rv == EACCES)
				rv = EFAULT;
		}
		if (rv == 0) {
			if (type == T_MMUFLT) {
#ifdef M68040
				if (cputype == CPU_68040)
					(void)writeback(&frame);
#endif
				return;
			}
			goto out;
		}
		if (type == T_MMUFLT) {
			if (p->p_addr->u_pcb.pcb_onfault)
				goto copyfault;
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x) -> 0x%x\n",
			    map, va, ftype, rv);
			printf("  type %x, code [mmu,,ssw]: %x\n",
			       type, code);
			goto dopanic;
		}
		frame.f_pad = code & 0xffff;
		ucode = vftype;
		typ = SEGV_MAPERR;
		i = SIGSEGV;
		break;
	    }
	}
	sv.sival_ptr = (caddr_t)v;
	trapsignal(p, i, ucode, typ, sv);
out:
	if ((type & T_USER) == 0)
		return;
	userret(p);
#ifdef M68040
	wb_userret(p, &frame);
#endif
}

#ifdef M68040
#ifdef DEBUG
struct writebackstats {
	int calls;
	int cpushes;
	int move16s;
	int wb1s, wb2s, wb3s;
	int wbsize[4];
} wbstats;

char *f7sz[] = { "longword", "byte", "word", "line" };
char *f7tt[] = { "normal", "MOVE16", "AFC", "ACK" };
char *f7tm[] = { "d-push", "u-data", "u-code", "M-data",
		 "M-code", "k-data", "k-code", "RES" };
char wberrstr[] =
    "WARNING: pid %d(%s) writeback [%s] failed, pc=%x fa=%x wba=%x wbd=%x\n";
#endif

int
writeback(struct frame *fp)
{
	struct fmt7 *f = &fp->f_fmt7;
	struct proc *p = curproc;
	int err = 0;
	u_int fa;
	paddr_t pa;
	caddr_t oonfault = p->p_addr->u_pcb.pcb_onfault;

#ifdef DEBUG
	if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid)) {
		printf(" pid=%d, fa=%x,", p->p_pid, f->f_fa);
		dumpssw(f->f_ssw);
	}
	wbstats.calls++;
#endif
	/*
	 * Deal with special cases first.
	 */
	if ((f->f_ssw & SSW4_TMMASK) == SSW4_TMDCP) {
		/*
		 * Dcache push fault.
		 * Line-align the address and write out the push data to
		 * the indicated physical address.
		 */
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid)) {
			printf(" pushing %s to PA %x, data %x",
			       f7sz[(f->f_ssw & SSW4_SZMASK) >> 5],
			       f->f_fa, f->f_pd0);
			if ((f->f_ssw & SSW4_SZMASK) == SSW4_SZLN)
				printf("/%x/%x/%x",
				       f->f_pd1, f->f_pd2, f->f_pd3);
			printf("\n");
		}
		if (f->f_wb1s & SSW4_WBSV)
			panic("writeback: cache push with WB1S valid");
		wbstats.cpushes++;
#endif
		/*
		 * XXX there are security problems if we attempt to do a
		 * cache push after a signal handler has been called.
		 */
		pmap_kenter_pa((vaddr_t)vmmap,
		    trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE);
		pmap_update(pmap_kernel());
		fa = (u_int)&vmmap[(f->f_fa & PGOFSET) & ~0x000f];
		bcopy((caddr_t)&f->f_pd0, (caddr_t)fa, 16);
		pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa);
		DCFL(pa);
		pmap_kremove((vaddr_t)vmmap, PAGE_SIZE);
		pmap_update(pmap_kernel());
	} else if ((f->f_ssw & (SSW4_RW|SSW4_TTMASK)) == SSW4_TTM16) {
		/*
		 * MOVE16 fault.
		 * Line-align the address and write out the push data to
		 * the indicated virtual address.
		 */
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			printf(" MOVE16 to VA %x(%x), data %x/%x/%x/%x\n",
			       f->f_fa, f->f_fa & ~0xF, f->f_pd0, f->f_pd1,
			       f->f_pd2, f->f_pd3);
		if (f->f_wb1s & SSW4_WBSV)
			panic("writeback: MOVE16 with WB1S valid");
		wbstats.move16s++;
#endif
		if (KDFAULT(f->f_wb1s))
			bcopy((caddr_t)&f->f_pd0, (caddr_t)(f->f_fa & ~0xF), 16);
		else
			err = suline((caddr_t)(f->f_fa & ~0xF), (caddr_t)&f->f_pd0);
		if (err) {
			fa = f->f_fa & ~0xF;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
				       "MOVE16", fp->f_pc, f->f_fa,
				       f->f_fa & ~0xF, f->f_pd0);
#endif
		}
	} else if (f->f_wb1s & SSW4_WBSV) {
		/*
		 * Writeback #1.
		 * Position the "memory-aligned" data and write it out.
		 */
		u_int wb1d = f->f_wb1d;
		int off;

#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(1, f->f_wb1s, f->f_wb1a, f->f_wb1d);
		wbstats.wb1s++;
		wbstats.wbsize[(f->f_wb2s&SSW4_SZMASK)>>5]++;
#endif
		off = (f->f_wb1a & 3) * 8;
		switch (f->f_wb1s & SSW4_SZMASK) {
		case SSW4_SZLW:
			if (off)
				wb1d = (wb1d >> (32 - off)) | (wb1d << off);
			if (KDFAULT(f->f_wb1s))
				*(long *)f->f_wb1a = wb1d;
			else
				err = copyout(&wb1d, (caddr_t)f->f_wb1a,
						sizeof(int));
			break;
		case SSW4_SZB:
			off = 24 - off;
			if (off)
				wb1d >>= off;
			if (KDFAULT(f->f_wb1s))
				*(char *)f->f_wb1a = wb1d;
			else {
				char tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(char));
			}
			break;
		case SSW4_SZW:
			off = (off + 16) % 32;
			if (off)
				wb1d = (wb1d >> (32 - off)) | (wb1d << off);
			if (KDFAULT(f->f_wb1s))
				*(short *)f->f_wb1a = wb1d;
			else {
				short tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(short));
			}
			break;
		}
		if (err) {
			fa = f->f_wb1a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
				       "#1", fp->f_pc, f->f_fa,
				       f->f_wb1a, f->f_wb1d);
#endif
		}
	}
	/*
	 * Deal with the "normal" writebacks.
	 *
	 * XXX writeback2 is known to reflect a LINE size writeback after
	 * a MOVE16 was already dealt with above.  Ignore it.
	 */
	if (err == 0 && (f->f_wb2s & SSW4_WBSV) &&
	    (f->f_wb2s & SSW4_SZMASK) != SSW4_SZLN) {
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(2, f->f_wb2s, f->f_wb2a, f->f_wb2d);
		wbstats.wb2s++;
		wbstats.wbsize[(f->f_wb2s&SSW4_SZMASK)>>5]++;
#endif
		switch (f->f_wb2s & SSW4_SZMASK) {
		case SSW4_SZLW:
			if (KDFAULT(f->f_wb2s))
				*(long *)f->f_wb2a = f->f_wb2d;
			else
				err = copyout(&f->f_wb2d, (caddr_t)f->f_wb2a,
						sizeof(int));
			break;
		case SSW4_SZB:
			if (KDFAULT(f->f_wb2s))
				*(char *)f->f_wb2a = f->f_wb2d;
			else {
				char tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(char));
			}
			break;
		case SSW4_SZW:
			if (KDFAULT(f->f_wb2s))
				*(short *)f->f_wb2a = f->f_wb2d;
			else {
				short tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(short));
			}
			break;
		}
		if (err) {
			fa = f->f_wb2a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED) {
				printf(wberrstr, p->p_pid, p->p_comm,
				       "#2", fp->f_pc, f->f_fa,
				       f->f_wb2a, f->f_wb2d);
				dumpssw(f->f_ssw);
				dumpwb(2, f->f_wb2s, f->f_wb2a, f->f_wb2d);
			}
#endif
		}
	}
	if (err == 0 && (f->f_wb3s & SSW4_WBSV)) {
#ifdef DEBUG
		if ((mmudebug & MDB_WBFOLLOW) || MDB_ISPID(p->p_pid))
			dumpwb(3, f->f_wb3s, f->f_wb3a, f->f_wb3d);
		wbstats.wb3s++;
		wbstats.wbsize[(f->f_wb3s&SSW4_SZMASK)>>5]++;
#endif
		switch (f->f_wb3s & SSW4_SZMASK) {
		case SSW4_SZLW:
			if (KDFAULT(f->f_wb3s))
				*(long *)f->f_wb3a = f->f_wb3d;
			else
				err = copyout(&f->f_wb3d, (caddr_t)f->f_wb3a,
						sizeof(int));
			break;
		case SSW4_SZB:
			if (KDFAULT(f->f_wb3s))
				*(char *)f->f_wb3a = f->f_wb3d;
			else {
				char tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(char));
			}
			break;
		case SSW4_SZW:
			if (KDFAULT(f->f_wb3s))
				*(short *)f->f_wb3a = f->f_wb3d;
			else {
				short tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(short));
			}
			break;
#ifdef DEBUG
		case SSW4_SZLN:
			panic("writeback: wb3s indicates LINE write");
#endif
		}
		if (err) {
			fa = f->f_wb3a;
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(wberrstr, p->p_pid, p->p_comm,
				       "#3", fp->f_pc, f->f_fa,
				       f->f_wb3a, f->f_wb3d);
#endif
		}
	}
	p->p_addr->u_pcb.pcb_onfault = oonfault;
	/*
	 * Any problems are SIGSEGV's
	 */
	if (err)
		err = SIGSEGV;
	return(err);
}

#ifdef DEBUG
void
dumpssw(ssw)
	u_short ssw;
{
	printf(" SSW: %x: ", ssw);
	if (ssw & SSW4_CP)
		printf("CP,");
	if (ssw & SSW4_CU)
		printf("CU,");
	if (ssw & SSW4_CT)
		printf("CT,");
	if (ssw & SSW4_CM)
		printf("CM,");
	if (ssw & SSW4_MA)
		printf("MA,");
	if (ssw & SSW4_ATC)
		printf("ATC,");
	if (ssw & SSW4_LK)
		printf("LK,");
	if (ssw & SSW4_RW)
		printf("RW,");
	printf(" SZ=%s, TT=%s, TM=%s\n",
	       f7sz[(ssw & SSW4_SZMASK) >> 5],
	       f7tt[(ssw & SSW4_TTMASK) >> 3],
	       f7tm[ssw & SSW4_TMMASK]);
}

void
dumpwb(num, s, a, d)
	int num;
	u_short s;
	u_int a, d;
{
	struct proc *p = curproc;
	paddr_t pa;
	int tmp;

	printf(" writeback #%d: VA %x, data %x, SZ=%s, TT=%s, TM=%s\n",
	       num, a, d, f7sz[(s & SSW4_SZMASK) >> 5],
	       f7tt[(s & SSW4_TTMASK) >> 3], f7tm[s & SSW4_TMMASK]);
	printf("               PA ");
	if (pmap_extract(p->p_vmspace->vm_map.pmap, (vaddr_t)a, &pa) == FALSE)
		printf("<invalid address>");
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
	printf("\n");
}
#endif
#endif

/*
 * Process a system call.
 */
void
syscall(code, frame)
	register_t code;
	struct frame frame;
{
	caddr_t params;
	struct sysent *callp;
	struct proc *p;
	int error, opc, nsys;
	size_t argsize;
	register_t args[8], rval[2];

	uvmexp.syscalls++;
	if (!USERMODE(frame.f_sr))
		panic("syscall");
	p = curproc;
	p->p_md.md_regs = frame.f_regs;
	opc = frame.f_pc;

	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;

	params = (caddr_t)frame.f_regs[SP] + sizeof(int);

	switch (code) {
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		if ((error = copyin(params, &code, sizeof(register_t))))
			goto bad;
		params += sizeof(int);
		/*
		 * XXX sigreturn requires special stack manipulation
		 * that is only done if entered via the sigreturn
		 * trap.  Cannot allow it here so make sure we fail.
		 */
		if (code == SYS_sigreturn)
			code = nsys;
		break;
	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
			break;
		if ((error = copyin(params + _QUAD_LOWWORD * sizeof(int),
		    &code, sizeof(register_t))))
			goto bad;
		params += sizeof(quad_t);
		break;
	default:
		break;
	}
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;		/* illegal */
	else
		callp += code;
	argsize = callp->sy_argsize;
	if (argsize && (error = copyin(params, args, argsize)))
		goto bad;

	rval[0] = 0;
	rval[1] = frame.f_regs[D1];

	error = mi_syscall(p, code, callp, args, rval);

	switch (error) {
	case 0:
		frame.f_regs[D0] = rval[0];
		frame.f_regs[D1] = rval[1];
		frame.f_sr &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/*
		 * We always enter through a `trap' instruction, which is 2
		 * bytes, so adjust the pc by that amount.
		 */
		frame.f_pc = opc - 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		frame.f_regs[D0] = error;
		frame.f_sr |= PSL_C;	/* carry bit */
		break;
	}

	mi_syscall_return(p, code, error, rval);
}
@


1.63
log
@Use sigexit() instead of rolling our own version.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2012/12/31 06:46:13 guenther Exp $	*/
@


1.62
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2012/08/07 05:16:53 guenther Exp $	*/
d319 2
a320 10
		type |= T_USER;
		p->p_sigacts->ps_sigact[SIGILL] = SIG_DFL;
		i = sigmask(SIGILL);
		p->p_sigacts->ps_sigignore &= ~i;
		p->p_sigacts->ps_sigcatch &= ~i;
		p->p_sigmask &= ~i;
		i = SIGILL;
		ucode = frame.f_format;	/* XXX was ILL_RESAD_FAULT */
		typ = ILL_COPROC;
		v = frame.f_pc;
@


1.61
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2011/11/16 20:50:18 deraadt Exp $	*/
a1003 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
@


1.60
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2011/07/05 04:48:01 guenther Exp $	*/
d73 1
a75 3
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
a85 3
#include "systrace.h"
#include <dev/systrace.h>

d947 2
a948 2
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
d965 3
a967 3
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
d978 1
a978 12
	if (argsize)
		error = copyin(params, (caddr_t)args, argsize);
	else
		error = 0;
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, argsize, args);
#endif
	if (error)
d980 1
d983 3
a985 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
d1003 1
a1003 1
bad:
d1011 1
a1011 8
#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
@


1.59
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2011/04/18 21:44:55 guenther Exp $	*/
a183 15
/*
 * trap and syscall both need the following work done before returning
 * to user mode.
 */
void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	curcpu()->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}

d186 1
a186 1
 * Same as above, but also handles writeback completion on 68040.
a190 8
	int sig;
	union sigval sv;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;

d200 3
d207 1
a207 3
			while ((sig = CURSIG(p)) != 0)
				postsig(sig);
			p->p_priority = p->p_usrpri;
a209 1
	curcpu()->ci_schedstate.spc_curpriority = p->p_priority;
d583 1
a585 2
#else
	userret(p);
@


1.58
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2010/07/02 19:57:14 tedu Exp $	*/
d350 2
a351 2
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
@


1.57
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d350 2
a351 2
		p->p_sigacts->ps_sigignore &= ~i;
		p->p_sigacts->ps_sigcatch &= ~i;
@


1.56
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2010/06/29 20:30:31 guenther Exp $	*/
d350 2
a351 2
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
@


1.55
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2009/03/15 20:40:23 miod Exp $	*/
a95 5
#ifdef COMPAT_SUNOS
#include <compat/sunos/sunos_syscall.h>
extern struct emul emul_sunos;
#endif

a456 12
#ifdef COMPAT_SUNOS
		/*
		 * SunOS uses Trap #2 for a "CPU cache flush".
		 * Just flush the on-chip caches and return.
		 */
		if (p->p_emul == &emul_sunos) {
			ICIA();
			DCIU();
			return;
		}
#endif
		/* FALLTHROUGH */
a968 32
#ifdef COMPAT_SUNOS
	if (p->p_emul == &emul_sunos) {
		/*
		 * SunOS passes the syscall-number on the stack, whereas
		 * BSD passes it in D0. So, we have to get the real "code"
		 * from the stack, and clean up the stack, as SunOS glue
		 * code assumes the kernel pops the syscall argument the
		 * glue pushed on the stack. Sigh...
		 */
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		   sizeof(register_t)) != 0)
			code = -1;

		/*
		 * XXX
		 * Don't do this for sunos_sigreturn, as there's no stored pc
		 * on the stack to skip, the argument follows the syscall
		 * number without a gap.
		 */
		if (code != SUNOS_SYS_sigreturn) {
			frame.f_regs[SP] += sizeof (int);
			/*
			 * remember that we adjusted the SP,
			 * might have to undo this if the system call
			 * returns ERESTART.
			 */
			p->p_md.md_flags |= MDP_STACKADJ;
		} else
			p->p_md.md_flags &= ~MDP_STACKADJ;
	}
#endif

a1054 5
#endif
#ifdef COMPAT_SUNOS
	/* need new p-value for this */
	if (error == ERESTART && (p->p_md.md_flags & MDP_STACKADJ))
		frame.f_regs[SP] -= sizeof (int);
@


1.54
log
@Generic softinterrupt code for m68k platforms, now copied from m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2008/06/08 20:57:16 miod Exp $	*/
a95 5
#ifdef COMPAT_HPUX
#include <compat/hpux/hpux.h>
extern struct emul emul_hpux;
#endif

a402 8
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux) {
			typ = 0;
			ucode = HPUX_ILL_ILLINST_TRAP;
			i = SIGILL;
			break;
		}
#endif
a409 5
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux)
			ucode = HPUX_ILL_PRIV_TRAP;
		else
#endif
a416 5
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux)
			ucode = HPUX_FPE_INTDIV_TRAP;
		else
#endif
a423 8
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux) {
			/* handled differently under hp-ux */
			i = SIGILL;
			ucode = HPUX_ILL_CHK_TRAP;
			break;
		}
#endif
a430 8
#ifdef COMPAT_HPUX
		if (p->p_emul == &emul_hpux) {
			/* handled differently under hp-ux */
			i = SIGILL;
			ucode = HPUX_ILL_TRAPV_TRAP;
			break;
		}
#endif
a571 14
#ifdef COMPAT_HPUX
		if (ISHPMMADDR(p, va)) {
			int pmap_mapmulti(pmap_t, vaddr_t);
			vaddr_t bva;

			rv = pmap_mapmulti(map->pmap, va);
			if (rv) {
				bva = HPMMBASEADDR(va);
				rv = uvm_fault(map, bva, 0, ftype);
				if (rv == 0)
					(void)pmap_mapmulti(map->pmap, va);
			}
		} else
#endif
@


1.53
log
@Make sure to cnpollc(1)/cnpollc(0) around cngetc() or getsn() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2007/05/15 13:46:22 martin Exp $	*/
d538 10
a547 10
		if (ssir & SIR_NET) {
			void netintr(void);
			siroff(SIR_NET);
			uvmexp.softs++;
			netintr();
		}
		if (ssir & SIR_CLOCK) {
			siroff(SIR_CLOCK);
			uvmexp.softs++;
			softclock();
d549 2
@


1.52
log
@switch m68k to __HAVE_CPUINFO

help miod@@, art@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2007/04/01 09:29:27 art Exp $	*/
d310 2
a311 1
			printf("(press a key)\n"); (void)cngetc();
@


1.51
log
@Remove some leftovers from the userret cleanups.
No need to save sticks anymore.
miod@@ ok and test
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2007/03/15 10:22:29 art Exp $	*/
d206 1
a206 1
	curpriority = p->p_priority = p->p_usrpri;
d242 1
a242 1
	curpriority = p->p_priority;
@


1.50
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2007/01/28 16:38:45 miod Exp $	*/
a261 1
	u_quad_t sticks;
a278 1
		sticks = p->p_sticks;
a1024 1
	u_quad_t sticks;
a1029 1
	sticks = p->p_sticks;
@


1.49
log
@optimize m68k writeback():
- it can really only be invoked from trap(), not from other userret() callers,
  so it is safe to hardcode its docachepush parameter to 1.
- use pmap_kenter_pa()/pmap_kremove() for the temporary mapping instead of
  pmap_enter()/pmap_remove().

optimize m68k userret():
- define PROC_PC for m68k systems.
- only check want_resched when processing T_ASTFLT traps.
- provide two version of userret(), one which will also invoke writeback()
  on 68040 if required, which is only invoked from trap(), and regular
  userret(). This speeds up system call returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2005/11/12 23:14:00 miod Exp $	*/
a558 1
			p->p_flag &= ~P_OWEUPC;
@


1.48
log
@Pass a struct proc * to ISHPMMADDR instead of abusing curproc in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2005/05/01 09:55:47 miod Exp $	*/
d106 1
a106 1
int	writeback(struct frame *fp, int docachepush);
d109 1
d199 1
a199 6
userret(p, fp, oticks, faultaddr, fromtrap)
	struct proc *p;
	struct frame *fp;
	u_quad_t oticks;
	u_int faultaddr;
	int fromtrap;
d202 7
d210 7
a217 1
	int beenhere = 0;
a218 2
again:
#endif
a222 8
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
a224 10
	 * If profiling, charge system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, fp->f_pc,
			    (int)(p->p_sticks - oticks) * psratio);
	}
#ifdef M68040
	/*
d233 2
a234 12
		if (beenhere) {
#ifdef DEBUG
			if (mmudebug & MDB_WBFAILED)
				printf(fromtrap ?
		"pid %d(%s): writeback aborted, pc=%x, fa=%x\n" :
		"pid %d(%s): writeback aborted in sigreturn, pc=%x\n",
				    p->p_pid, p->p_comm, fp->f_pc, faultaddr);
#endif
		} else if ((sig = writeback(fp, fromtrap))) {
			beenhere = 1;
			oticks = p->p_sticks;
			sv.sival_ptr = (caddr_t)faultaddr;
d236 4
a239 1
			goto again;
a241 1
#endif
d244 1
d562 3
d649 1
a649 1
					(void) writeback(&frame, 1);
d676 5
a680 1
	userret(p, &frame, sticks, v, 1);
d702 1
a702 3
writeback(fp, docachepush)
	struct frame *fp;
	int docachepush;
d708 1
d745 9
a753 17
		if (docachepush) {
			paddr_t pa;

			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
				   trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE,
				   VM_PROT_WRITE|PMAP_WIRED);
			pmap_update(pmap_kernel());
			fa = (u_int)&vmmap[(f->f_fa & PGOFSET) & ~0xF];
			bcopy((caddr_t)&f->f_pd0, (caddr_t)fa, 16);
			pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa);
			DCFL(pa);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
				    (vaddr_t)&vmmap[NBPG]);
			pmap_update(pmap_kernel());
		} else
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
			       p->p_pid, p->p_comm, p->p_ucred->cr_uid);
d1165 1
a1165 1
	userret(p, &frame, sticks, 0, 0);
@


1.47
log
@Bring raise-only semantics to splsoft* on m68k and m88k, as done elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2005/01/15 21:13:08 miod Exp $	*/
d627 1
a627 1
		if (ISHPMMADDR(va)) {
d636 1
a636 1
					(void) pmap_mapmulti(map->pmap, va);
@


1.46
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2004/12/06 20:12:23 miod Exp $	*/
d552 1
a552 1
		spl1();
@


1.45
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2004/01/15 17:22:25 miod Exp $	*/
d6 1
a6 1
 * 
d1083 1
a1083 1
			 * remember that we adjusted the SP, 
@


1.44
log
@instuction -> instruction
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2003/12/20 20:08:16 miod Exp $	*/
d656 1
a656 5
				unsigned nss;

				nss = btoc(USRSTACK-(unsigned)va);
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
@


1.43
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2003/06/02 23:27:45 millert Exp $	*/
d412 1
a412 1
	case T_FPEMULI|T_USER:	/* unimplemented FP instuction */
@


1.42
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2003/06/02 18:47:58 deraadt Exp $	*/
d692 1
a694 1
out:
@


1.41
log
@remove terms 3 (and 4 in some places) where i am the author
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2003/01/09 22:27:08 miod Exp $	*/
d44 1
a44 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.40
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2002/12/09 00:45:37 millert Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.39
log
@From Andrushock, s/sucess/success/g
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2002/06/23 03:03:15 deraadt Exp $	*/
a286 1
	extern char fubail[], subail[];
a592 9
		/*
		 * If we were doing profiling ticks or other user mode
		 * stuff from interrupt code, Just Say No.
		 */
		if (p->p_addr->u_pcb.pcb_onfault == fubail ||
		    p->p_addr->u_pcb.pcb_onfault == subail)
			goto copyfault;
		/* FALLTHROUGH */

d838 2
a839 1
				err = suword((caddr_t)f->f_wb1a, wb1d);
d847 6
a852 2
			else
				err = subyte((caddr_t)f->f_wb1a, wb1d);
d860 6
a865 2
			else
				err = susword((caddr_t)f->f_wb1a, wb1d);
d897 2
a898 1
				err = suword((caddr_t)f->f_wb2a, f->f_wb2d);
d903 6
a908 2
			else
				err = subyte((caddr_t)f->f_wb2a, f->f_wb2d);
d913 6
a918 2
			else
				err = susword((caddr_t)f->f_wb2a, f->f_wb2d);
d946 2
a947 1
				err = suword((caddr_t)f->f_wb3a, f->f_wb3d);
d952 6
a957 2
			else
				err = subyte((caddr_t)f->f_wb3a, f->f_wb3d);
d962 6
a967 2
			else
				err = susword((caddr_t)f->f_wb3a, f->f_wb3d);
d1029 1
d1037 6
a1042 2
	else
		printf("%lx, current value %lx", pa, fuword((caddr_t)a));
d1084 3
a1086 1
		code = fuword((caddr_t)frame.f_regs[SP]);
d1114 2
a1115 1
		code = fuword(params);
d1132 3
a1134 1
		code = fuword(params + _QUAD_LOWWORD * sizeof(int));
@


1.38
log
@uid_t is unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2002/05/16 21:11:13 miod Exp $	*/
d250 1
a250 1
	 * we just return to the user without sucessfully completing
@


1.37
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2002/03/14 01:26:31 millert Exp $	*/
d796 1
a796 1
			printf("WARNING: pid %d(%s) uid %d: CPUSH not done\n",
@


1.36
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2001/12/06 18:53:01 millert Exp $	*/
d98 3
d1133 6
a1138 1
	error = (*callp->sy_call)(p, args, rval);
@


1.35
log
@Sprinkle pmap_update() calls (based on NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2001/11/28 16:13:28 art Exp $	*/
d113 3
a115 3
int	writeback __P((struct frame *fp, int docachepush));
void	trap __P((int type, u_int code, u_int v, struct frame frame));
void	syscall __P((register_t code, struct frame frame));
d118 2
a119 2
void	dumpssw __P((u_short));
void	dumpwb __P((int, u_short, u_int, u_int));
d566 1
a566 1
			void netintr __P((void));
d645 1
a645 1
			int pmap_mapmulti __P((pmap_t, vaddr_t));
@


1.35.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2001/12/06 18:53:01 millert Exp $	*/
a97 3
#include "systrace.h"
#include <dev/systrace.h>

d113 3
a115 3
int	writeback(struct frame *fp, int docachepush);
void	trap(int type, u_int code, u_int v, struct frame frame);
void	syscall(register_t code, struct frame frame);
d118 2
a119 2
void	dumpssw(u_short);
void	dumpwb(int, u_short, u_int, u_int);
d566 1
a566 1
			void netintr(void);
d645 1
a645 1
			int pmap_mapmulti(pmap_t, vaddr_t);
d1130 1
a1130 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
@


1.35.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35.2.1 2002/06/11 03:35:20 art Exp $	*/
d796 1
a796 1
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
@


1.35.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d250 1
a250 1
	 * we just return to the user without successfully completing
d287 1
d594 9
d848 1
a848 2
				err = copyout(&wb1d, (caddr_t)f->f_wb1a,
						sizeof(int));
d856 2
a857 6
			else {
				char tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(char));
			}
d865 2
a866 6
			else {
				short tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(short));
			}
d898 1
a898 2
				err = copyout(&f->f_wb2d, (caddr_t)f->f_wb2a,
						sizeof(int));
d903 2
a904 6
			else {
				char tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(char));
			}
d909 2
a910 6
			else {
				short tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(short));
			}
d938 1
a938 2
				err = copyout(&f->f_wb3d, (caddr_t)f->f_wb3a,
						sizeof(int));
d943 2
a944 6
			else {
				char tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(char));
			}
d949 2
a950 6
			else {
				short tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(short));
			}
a1011 1
	int tmp;
d1019 2
a1020 6
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
d1062 1
a1062 3
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		   sizeof(register_t)) != 0)
			code = -1;
d1090 1
a1090 2
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
d1107 1
a1107 3
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
@


1.34
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/11/28 13:47:38 art Exp $	*/
d784 1
d791 1
@


1.33
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2001/11/25 17:15:19 miod Exp $	*/
d604 1
a604 1
		vm_map_t map;
d607 1
a607 1
		extern vm_map_t kernel_map;
@


1.32
log
@Harmonize userret() prototypes across m68k arches.
XXX The userret() code is not factorized out yet, as this will require
XXX insane amiga cleaning work.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/11/06 19:53:14 miod Exp $	*/
d649 1
a649 1
			if (rv != KERN_SUCCESS) {
d652 1
a652 1
				if (rv == KERN_SUCCESS)
d672 1
a672 1
			if (rv == KERN_SUCCESS) {
d678 2
a679 2
			} else if (rv == KERN_PROTECTION_FAILURE)
				rv = KERN_INVALID_ADDRESS;
d681 1
a681 1
		if (rv == KERN_SUCCESS) {
@


1.31
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/11/06 18:41:09 art Exp $	*/
a121 3
void userret __P((struct proc *p, struct frame *fp,
	    u_quad_t oticks, u_int faultaddr, int fromtrap));

d1162 1
a1162 1
	userret(p, &frame, sticks, (u_int)0, 0);
@


1.30
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/11/04 02:58:54 miod Exp $	*/
a97 3
#include <vm/vm.h>
#include <vm/pmap.h>

d99 1
@


1.29
log
@hp300spu.h information not needed anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2001/09/14 06:04:58 art Exp $	*/
a117 1
void	child_return __P((struct proc *, struct frame));
d124 1
a124 1
static inline void userret __P((struct proc *p, struct frame *fp,
d209 1
a209 1
static inline void
a1170 17
#endif
}

void
child_return(p, frame)
	struct proc *p;
	struct frame frame;
{

	frame.f_regs[D0] = 0;
	frame.f_sr &= ~PSL_C;
	frame.f_format = FMT0;

	userret(p, &frame, 0, (u_int)0, 0);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
@


1.28
log
@Simplify userret.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/08/25 16:15:15 miod Exp $	*/
a73 2

#include <machine/hp300spu.h>	/* XXX param.h includes cpu.h */
@


1.27
log
@Remove workarounds for old compiler bugs, and fix a few style issues.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2001/08/25 11:37:26 espie Exp $	*/
d220 1
a220 1
	int sig, s;
d233 1
a233 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we mi_switch()'ed, we might not be on the queue
		 * indicated by our priority.
d235 1
a235 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.26
log
@One regdump to dump them all...

(moid@@ wants that commit, because it interferes with stuff he's cleaning,
and he's prepared to clean up stuff I may have forgotten, even though this
was tested)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2001/07/25 13:25:31 art Exp $	*/
d305 1
a305 1
	u_quad_t sticks = 0 /* XXX initializer works around compiler bug */;
d329 1
a329 1
	dopanic:
d524 1
a524 1
	 *	NetBSD/m68k uses trap #2,
d529 1
a529 1
	 * NetBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
d578 1
a578 1
		/* fall into... */
d615 1
a615 1
		/* fall into ... */
d1163 1
a1163 1
	bad:
@


1.25
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2001/06/27 04:05:45 art Exp $	*/
d358 1
a358 1
		regdump(&frame, 128);
@


1.24
log
@no more old VM
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2001/06/08 08:08:45 art Exp $	*/
d800 1
a800 1
				   TRUE, VM_PROT_WRITE);
@


1.23
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2001/05/13 17:19:56 millert Exp $	*/
a102 1
#if defined(UVM)
a103 1
#endif
a308 1
#if defined(UVM)
a309 3
#else
	cnt.v_trap++;
#endif
a584 1
#if defined(UVM)
a585 3
#else
			cnt.v_soft++;
#endif
a589 1
#if defined(UVM)
a590 3
#else
			cnt.v_soft++;
#endif
a596 1
#if defined(UVM)
a597 3
#else
			cnt.v_trap--;
#endif
a667 1
#if defined(UVM)
a668 3
#else
				rv = vm_fault(map, bva, ftype, FALSE);
#endif
a673 1
#if defined(UVM)
a679 8
#else /* ! UVM */
		rv = vm_fault(map, va, ftype, FALSE);
#ifdef DEBUG
		if (rv && MDB_ISPID(p->p_pid))
			printf("vm_fault(%p, %lx, %x, 0) -> %x\n",
			       map, va, ftype, rv);
#endif
#endif /* UVM */
a710 1
#if defined(UVM)
a712 4
#else
			printf("vm_fault(%p, %lx, %x, 0) -> %x\n",
			       map, va, ftype, rv);
#endif
a1053 1
#if defined(UVM)
a1054 3
#else
	cnt.v_syscall++;
#endif
@


1.22
log
@Fix the problem that single-step tracing of a trap instruction
drops the system into kernel debugger; itohy@@netbsd.org
Other m68k ports require similar changes
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2001/05/11 23:24:57 millert Exp $	*/
d832 2
d839 2
a840 1
			DCFL(pmap_extract(pmap_kernel(), (vaddr_t)fa));
d1065 1
a1065 2
	pa = pmap_extract(p->p_vmspace->vm_map.pmap, (vaddr_t)a);
	if (pa == 0)
@


1.21
log
@Kill remaining vm_offset_t and vm_size_t; NetBSD used as a guide
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2001/05/05 21:26:35 art Exp $	*/
d539 1
a539 1
	 * XXX: We should never get kernel-mode T_TRACE or T_TRAP15
a541 1
	case T_TRACE:		/* kernel trace trap */
a550 1
	case T_TRAP15|T_USER:	/* SUN user trace trap */
d562 3
@


1.20
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2001/05/05 20:56:34 art Exp $	*/
d636 1
a636 1
		vm_offset_t va;
d668 1
a668 1
		va = trunc_page((vm_offset_t)v);
d679 2
a680 2
			int pmap_mapmulti __P((pmap_t, vm_offset_t));
			vm_offset_t bva;
d742 1
a742 1
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x\n) -> 0x%x\n",
d831 3
a833 3
			pmap_enter(pmap_kernel(), (vm_offset_t)vmmap,
				   trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE, TRUE,
				   VM_PROT_WRITE);
d836 3
a838 3
			DCFL(pmap_extract(pmap_kernel(), (vm_offset_t)fa));
			pmap_remove(pmap_kernel(), (vm_offset_t)vmmap,
				    (vm_offset_t)&vmmap[NBPG]);
d1055 1
a1055 1
	vm_offset_t pa;
d1061 1
a1061 1
	pa = pmap_extract(p->p_vmspace->vm_map.pmap, (vm_offset_t)a);
@


1.19
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2001/05/04 22:48:59 aaron Exp $	*/
d832 1
a832 1
				   trunc_page(f->f_fa), VM_PROT_WRITE, TRUE,
@


1.18
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2000/11/10 18:15:38 art Exp $	*/
d722 1
a722 1
				nss = clrnd(btoc(USRSTACK-(unsigned)va));
@


1.17
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.16 1999/09/18 21:41:41 downsj Exp $	*/
/*	$NetBSD: trap.c,v 1.55 1997/07/08 16:56:36 kleink Exp $	*/
d103 4
d132 2
d311 3
d315 1
d590 3
d594 1
d599 3
d603 1
d610 3
d614 1
d685 3
d689 1
d695 8
d709 1
d741 4
d747 1
d1087 3
d1091 1
@


1.16
log
@Fix art's typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1999/09/03 18:00:43 art Exp $	*/
d1132 1
a1132 1
		ktrsyscall(p->p_tracep, code, argsize, args);
d1175 1
a1175 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d1192 1
a1192 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.16.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2000/11/10 18:15:38 art Exp $	*/
d1132 1
a1132 1
		ktrsyscall(p, code, argsize, args);
d1175 1
a1175 1
		ktrsysret(p, code, error, rval[0]);
d1192 1
a1192 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.16.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: trap.c,v 1.57 1998/02/16 20:58:31 thorpej Exp $	*/
a102 2
#include <uvm/uvm_extern.h>

a127 2
int	astpending;

d305 1
a305 1
	uvmexp.traps++;
d529 1
a529 1
	 * XXX: We should never get kernel-mode T_TRAP15
d532 1
d542 1
a553 3
		/* FALLTHROUGH */
	case T_TRACE:		/* tracing a trap instruction */
	case T_TRAP15|T_USER:	/* SUN user trace trap */
d580 1
a580 1
			uvmexp.softs++;
d585 1
a585 1
			uvmexp.softs++;
d592 1
a592 1
			uvmexp.traps--;
d614 1
a614 1
		vaddr_t va;
d646 1
a646 1
		va = trunc_page((vaddr_t)v);
d657 2
a658 2
			int pmap_mapmulti __P((pmap_t, vaddr_t));
			vaddr_t bva;
d663 1
a663 1
				rv = uvm_fault(map, bva, 0, ftype);
d669 1
a669 1
		rv = uvm_fault(map, va, 0, ftype);
d672 2
a673 2
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x) -> 0x%x\n",
			    map, va, ftype, rv);
d687 1
a687 1
				nss = btoc(USRSTACK-(unsigned)va);
d706 2
a707 2
			printf("uvm_fault(%p, 0x%lx, 0, 0x%x) -> 0x%x\n",
			    map, va, ftype, rv);
d791 3
a793 5
			paddr_t pa;

			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
				   trunc_page((vaddr_t)f->f_fa), VM_PROT_WRITE,
				   TRUE, VM_PROT_WRITE);
d796 3
a798 4
			pmap_extract(pmap_kernel(), (vaddr_t)fa, &pa);
			DCFL(pa);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
				    (vaddr_t)&vmmap[NBPG]);
d1015 1
a1015 1
	paddr_t pa;
d1021 2
a1022 1
	if (pmap_extract(p->p_vmspace->vm_map.pmap, (vaddr_t)a, &pa) == FALSE)
d1047 1
a1047 1
	uvmexp.syscalls++;
@


1.16.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.4.2 2001/07/04 10:15:49 niklas Exp $	*/
d220 1
a220 1
	int sig;
d233 6
a238 1
		 * We're being preempted.
d240 5
a244 1
		preempt(NULL);
d305 1
a305 1
	u_quad_t sticks;
d329 1
a329 1
dopanic:
d358 1
a358 1
		regdump(&(frame.F_t), 128);
d524 1
a524 1
	 *	OpenBSD/m68k uses trap #2,
d529 1
a529 1
	 * OpenBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
d578 1
a578 1
		/* FALLTHROUGH */
d615 1
a615 1
		/* FALLTHROUGH */
d800 1
a800 1
				   VM_PROT_WRITE|PMAP_WIRED);
d1163 1
a1163 1
bad:
@


1.16.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 2
d100 3
a103 1
#include <uvm/uvm_pmap.h>
d120 1
d127 1
a127 1
void userret __P((struct proc *p, struct frame *fp,
d212 1
a212 1
void
d1174 17
@


1.16.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.4.4 2001/11/13 21:00:51 niklas Exp $	*/
d122 3
d607 1
a607 1
		struct vm_map *map;
d610 1
a610 1
		extern struct vm_map *kernel_map;
d652 1
a652 1
			if (rv) {
d655 1
a655 1
				if (rv == 0)
d675 1
a675 1
			if (rv == 0) {
d681 2
a682 2
			} else if (rv == EACCES)
				rv = EFAULT;
d684 1
a684 1
		if (rv == 0) {
d1165 1
a1165 1
	userret(p, &frame, sticks, 0, 0);
@


1.16.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a783 1
			pmap_update(pmap_kernel());
a789 1
			pmap_update(pmap_kernel());
@


1.16.4.7
log
@Merge in -current from about a week ago
@
text
@d113 3
a115 3
int	writeback(struct frame *fp, int docachepush);
void	trap(int type, u_int code, u_int v, struct frame frame);
void	syscall(register_t code, struct frame frame);
d118 2
a119 2
void	dumpssw(u_short);
void	dumpwb(int, u_short, u_int, u_int);
d566 1
a566 1
			void netintr(void);
d645 1
a645 1
			int pmap_mapmulti(pmap_t, vaddr_t);
@


1.16.4.8
log
@Sync the SMP branch with 3.3
@
text
@a97 3
#include "systrace.h"
#include <dev/systrace.h>

d247 1
a247 1
	 * we just return to the user without successfully completing
d284 1
d591 9
d793 1
a793 1
			printf("WARNING: pid %d(%s) uid %u: CPUSH not done\n",
d845 1
a845 2
				err = copyout(&wb1d, (caddr_t)f->f_wb1a,
						sizeof(int));
d853 2
a854 6
			else {
				char tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(char));
			}
d862 2
a863 6
			else {
				short tmp = wb1d;

				err = copyout(&tmp, (caddr_t)f->f_wb1a,
						sizeof(short));
			}
d895 1
a895 2
				err = copyout(&f->f_wb2d, (caddr_t)f->f_wb2a,
						sizeof(int));
d900 2
a901 6
			else {
				char tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(char));
			}
d906 2
a907 6
			else {
				short tmp = f->f_wb2d;

				err = copyout(&tmp, (caddr_t)f->f_wb2a,
						sizeof(short));
			}
d935 1
a935 2
				err = copyout(&f->f_wb3d, (caddr_t)f->f_wb3a,
						sizeof(int));
d940 2
a941 6
			else {
				char tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(char));
			}
d946 2
a947 6
			else {
				short tmp = f->f_wb3d;

				err = copyout(&tmp, (caddr_t)f->f_wb3a,
						sizeof(short));
			}
a1008 1
	int tmp;
d1016 2
a1017 6
	else {
		if (copyin((caddr_t)a, &tmp, sizeof(int)) == 0)
			printf("%lx, current value %lx", pa, tmp);
		else
			printf("%lx, current value inaccessible", pa);
	}
d1059 1
a1059 3
		if (copyin((caddr_t)frame.f_regs[SP], &code,
		   sizeof(register_t)) != 0)
			code = -1;
d1087 1
a1087 2
		if (copyin(params, &code, sizeof(register_t)) != 0)
			code = -1;
d1104 1
a1104 3
		if (copyin(params + _QUAD_LOWWORD * sizeof(int), &code,
		    sizeof(register_t)) != 0)
			code = -1;
d1130 1
a1130 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
@


1.16.4.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16.4.8 2003/03/27 23:19:21 niklas Exp $	*/
d15 6
d50 5
a54 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d412 1
a412 1
	case T_FPEMULI|T_USER:	/* unimplemented FP instruction */
a691 1
out:
d694 1
@


1.15
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1998/05/27 05:40:18 millert Exp $	*/
d792 1
a792 1
				   trunc_page(f->f_fa), VM_PROT_WRITE, TRUE, 0
@


1.14
log
@Fix warning in non-68040 case; jason@@couch.com
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1998/03/07 12:41:34 deraadt Exp $	*/
d792 2
a793 1
				   trunc_page(f->f_fa), VM_PROT_WRITE, TRUE);
@


1.13
log
@please the anal compiler
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1997/07/13 09:48:01 downsj Exp $	*/
d217 1
a218 1
#ifdef M68040
@


1.12
log
@sync to NETBSD_CURRENT_970711.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1997/07/06 08:02:09 downsj Exp $	*/
d217 1
d275 2
a276 2
			trapsignal(p, sig, T_MMUFLT, SEGV_MAPERR,
			    (caddr_t)faultaddr);
d303 1
d719 2
a720 1
	trapsignal(p, i, ucode, typ, (caddr_t)v);
@


1.11
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.10 1997/04/16 11:56:32 downsj Exp $	*/
/*	$NetBSD: trap.c,v 1.54 1997/05/19 10:15:01 veego Exp $	*/
d543 2
a544 4
		 * XXX This comment/code is not consistent XXX
		 * SunOS seems to use Trap #2 for some obscure 
		 * fpu operations.  So far, just ignore it, but
		 * DONT trap on it.. 
d546 5
a550 2
		if (p->p_emul == &emul_sunos)
			goto out;
@


1.10
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.9 1997/03/26 08:32:45 downsj Exp $	*/
/*	$NetBSD: trap.c,v 1.52 1997/04/14 02:28:48 thorpej Exp $	*/
d75 2
d1016 1
a1016 1
	pa = pmap_extract(&p->p_vmspace->vm_pmap, (vm_offset_t)a);
@


1.9
log
@Merge changes from NetBSD, up to 3/19/97; undoes some local changes.
Changed to match new arch/m68k code.
genassym.cf is currently just a place holder.
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.8 1997/02/21 06:07:25 deraadt Exp $	*/
/*	$NetBSD: trap.c,v 1.48 1997/03/15 23:34:32 thorpej Exp $	*/
d89 3
d96 1
a96 1
#include <machine/mtpr.h>
d101 2
d116 1
d208 2
a209 2
	register struct proc *p;
	register struct frame *fp;
d269 1
a269 1
		} else if (sig = writeback(fp, fromtrap)) {
d291 1
a291 1
	register unsigned v;
d295 2
a296 2
	register struct proc *p;
	register int i, s;
d298 1
a298 1
	u_quad_t sticks;
d337 1
a337 1
		(void) kdb_trap(type, &frame);
d339 1
d341 1
d414 1
a414 1
	 * We pass along the 68881 status register which locore stashed
d416 1
a416 1
	 * bit pattern of this register will conflict with one of the
d419 1
a419 1
	 * 3 bits of the status register are defined as 0 so there is
d573 1
d609 3
a611 3
		register vm_offset_t va;
		register struct vmspace *vm = p->p_vmspace;
		register vm_map_t map;
d652 1
d667 1
a667 1
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
d701 1
a701 1
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
d744 2
a745 2
	register struct fmt7 *f = &fp->f_fmt7;
	register struct proc *p = curproc;
d828 2
a829 2
		register u_int wb1d = f->f_wb1d;
		register int off;
d976 1
a976 1
	register u_short ssw;
d1007 1
a1007 1
	register struct proc *p = curproc;
d1018 1
a1018 1
		printf("%x, current value %x", pa, fuword((caddr_t)a));
d1032 3
a1034 3
	register caddr_t params;
	register struct sysent *callp;
	register struct proc *p;
@


1.8
log
@do not pass up un-init vftype
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.7 1997/02/05 17:33:02 downsj Exp $	*/
/*	$NetBSD: trap.c,v 1.47 1996/10/14 20:06:31 thorpej Exp $	*/
a375 1
#ifdef FPCOPROC
a376 1
#endif
a396 1
#ifdef FPCOPROC
a418 1
#endif
@


1.7
log
@latest siginfo changes from theo
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1997/02/04 06:21:32 downsj Exp $	*/
d634 1
a634 1
			ftype = VM_PROT_READ;
@


1.6
log
@checkpoint:  pull in spl() changes from NetBSD, and more siginfo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 1997/02/03 04:47:59 downsj Exp $	*/
d266 2
a267 1
			trapsignal(p, sig, T_MMUFLT, SEGV_MAPERR, (caddr_t)faultaddr);
d608 1
a608 1
		vm_prot_t ftype;
d630 2
a631 1
		if (WRFAULT(code))
d633 1
a633 1
		else
d702 1
a702 1
		ucode = T_MMUFLT;
@


1.5
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 1997/01/12 15:13:28 downsj Exp $	*/
d395 1
d419 1
d434 1
d450 1
d452 1
d462 1
d474 1
d489 1
d502 3
a504 2
		typ = FPE_FLTOVF;
		i = SIGFPE;
@


1.4
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 29
d266 1
a266 1
			trapsignal(p, sig, faultaddr);
d292 1
d365 4
d370 2
a371 1
		ucode = v;
d394 1
d400 1
d415 1
d430 1
d438 1
a442 1
		/* fall through */
d444 4
d455 1
d466 1
d480 1
d494 1
d537 1
d690 3
a692 1
		ucode = v;
d697 1
a697 1
	trapsignal(p, i, ucode);
@


1.3
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 2
a2 1
/*	$NetBSD: trap.c,v 1.40 1995/12/11 17:09:18 thorpej Exp $	*/
d71 1
d74 17
d113 1
a113 1
	FMT0SIZE,	/* type 0 - normal (68020/030/040) */
d115 4
a118 3
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040) */
	FMT3SIZE,	/* type 3 - FP post-instruction (68040) */
	-1, -1, -1,	/* type 4-6 - undefined */
d127 8
d136 4
a139 6
#define KDFAULT(c)	(mmutype == MMU_68040 ? \
			    ((c) & SSW4_TMMASK) == SSW4_TMKD : \
			    ((c) & (SSW_DF|FC_SUPERD)) == (SSW_DF|FC_SUPERD))
#define WRFAULT(c) 	(mmutype == MMU_68040 ? \
			    ((c) & SSW4_RW) == 0 : \
			    ((c) & (SSW_DF|SSW_RW)) == SSW_DF)
d141 2
a142 2
#define KDFAULT(c)	(((c) & (SSW_DF|SSW_FCMASK)) == (SSW_DF|FC_SUPERD))
#define WRFAULT(c)	(((c) & (SSW_DF|SSW_RW)) == SSW_DF)
d145 13
d164 1
a164 1
#define MDB_ISPID(p)	(p) == mmupid
d225 1
a225 1
	if (mmutype == MMU_68040 && fp->f_format == FMT7) {
d251 1
a258 3
#ifdef DDB
	extern char trap0[], trap1[], trap2[], trap12[], trap15[], illinst[];
#endif
d260 1
a260 1
	register int i;
a262 3
#ifdef COMPAT_HPUX
	extern struct emul emul_hpux;
#endif
d267 9
d284 15
a298 2
dopanic:
		printf("trap type %d, code = %x, v = %x\n", type, code, v);
d300 9
a308 2
		if (kdb_trap(type, &frame))
			return;
d310 1
d313 1
a313 1
		if ((unsigned)type < trap_types)
d318 1
a318 1
		if (!p->p_addr->u_pcb.pcb_onfault)
d320 3
a328 1
copyfault:
d455 1
a455 1
	 *	HPBSD uses trap #2,
d457 2
a458 1
	 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere).
d460 1
a460 1
	 * HPBSD and HP-UX traps both get mapped by locore.s into T_TRACE.
d463 3
d468 4
a471 12
	case T_TRAP15:		/* SUN trace trap */
#ifdef DDB
		if (type == T_TRAP15 ||
		    ((caddr_t)frame.f_pc != trap0 &&
		     (caddr_t)frame.f_pc != trap1 &&
		     (caddr_t)frame.f_pc != trap2 &&
		     (caddr_t)frame.f_pc != trap12 &&
		     (caddr_t)frame.f_pc != trap15 &&
		     (caddr_t)frame.f_pc != illinst)) {
			if (kdb_trap(type, &frame))
				return;
		}
d474 1
a474 2
		i = SIGTRAP;
		break;
d478 10
d566 2
a567 2
		if (type == T_MMUFLT &&
		    (!p->p_addr->u_pcb.pcb_onfault || KDFAULT(code)))
d570 2
a571 1
			map = &vm->vm_map;
d576 1
d578 1
a578 1
#ifdef DEBUG
d580 3
a582 1
			printf("trap: bad kernel access at %x\n", v);
d585 1
a585 1
#endif
d612 2
a613 1
		if ((caddr_t)va >= vm->vm_maxsaddr && map != kernel_map) {
d626 1
a626 1
				if (mmutype == MMU_68040)
d672 1
d907 1
d934 1
d960 1
a971 3
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
@


1.2
log
@update from netbsd (verbatim)
@
text
@d567 1
a567 1
		i = (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV;
d822 1
a822 4
	 * Determine the cause of the failure if any translating to
	 * a signal.  If the corresponding VA is valid and RO it is
	 * a protection fault (SIGBUS) otherwise consider it an
	 * illegal reference (SIGSEGV).
d824 2
a825 11
	if (err) {
		if (vm_map_check_protection(&p->p_vmspace->vm_map,	
					    trunc_page(fa), round_page(fa),
					    VM_PROT_READ) &&
		    !vm_map_check_protection(&p->p_vmspace->vm_map,
					     trunc_page(fa), round_page(fa),
					     VM_PROT_WRITE))
			err = SIGBUS;
		else
			err = SIGSEGV;
	}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.38 1995/09/03 00:44:43 thorpej Exp $	*/
d69 1
a69 1
#include <hp300/hpux/hpux.h>
d107 1
a107 1
#ifdef HP380
d141 1
a141 1
#ifdef HP380
d177 1
a177 1
#ifdef HP380
d317 1
a317 1
#ifdef HP380
d549 1
a549 1
#ifdef HP380
d578 1
a578 1
#ifdef HP380
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

