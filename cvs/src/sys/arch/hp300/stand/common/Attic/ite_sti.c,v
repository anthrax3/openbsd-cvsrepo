head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.12
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.0.22
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.20
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.18
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.14
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.16
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.12
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.10
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.8
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.6
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.4
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.2;

1.2
date	2011.08.18.20.02.58;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.17.06.31.10;	author miod;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: ite_sti.c,v 1.2 2011/08/18 20:02:58 miod Exp $	*/
/*
 * Copyright (c) 2006, 2011, Miodrag Vallat
 * Copyright (c) 2000-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef ITECONSOLE
#include <sys/param.h>

#include <lib/libsa/stand.h>

#include "samachdep.h"
#include "consdefs.h"
#include "itevar.h"

#include <hp300/dev/dioreg.h>
#include <hp300/dev/sgcreg.h>
#include <hp300/dev/sti_machdep.h>
#include <dev/ic/stireg.h>

/*
 * sti-specific data not available in the ite_data structure.
 * Since we will only configure one sti display, it is ok to use a global.
 */
static struct {
	u_int32_t	codeptr[STI_CODECNT];
	u_int8_t	*code;
	u_int32_t	fontbase;
	u_int		firstchar, lastchar;
	struct sti_cfg	cfg;
	struct sti_ecfg	ecfg;
} sti;

#define parseshort1(addr, ofs) \
	(((addr)[(ofs) +  3] << 8) | ((addr)[(ofs) +  7]))
#define parseword1(addr, ofs) \
	(((addr)[(ofs) +  3] << 24) | ((addr)[(ofs) +  7] << 16) | \
	 ((addr)[(ofs) + 11] <<  8) | ((addr)[(ofs) + 15]))

void	sti_do_cursor(struct ite_data *);
void	sti_fontinfo(struct ite_data *);
void	sti_init(int);
void	sti_inqcfg(struct sti_inqconfout *);
void	sti_iteinit_common(struct ite_data *);

/* kinda similar to sti_dio_probe() */
int
sti_dio_probe(struct ite_data *ip)
{
	int scode = ip->scode;
	uint8_t *id_reg;

	id_reg = (uint8_t *)sctoaddr(scode);
	if (id_reg[DIOII_SIZEOFF] < STI_DIO_SIZE - 1)
		return ENODEV;

	id_reg = (uint8_t *)sctoaddr(scode + STI_DIO_SCODE_OFFSET);
	if (id_reg[3] != STI_DEVTYPE1)
		return ENODEV;

	return 0;
}

void
sti_iteinit_dio(struct ite_data *ip)
{
	ip->fbbase = (caddr_t)sctoaddr(ip->scode + STI_DIO_SCODE_OFFSET);
	sti_iteinit_common(ip);
}

void
sti_iteinit_sgc(struct ite_data *ip)
{
	ip->fbbase = (caddr_t)IIOV(SGC_BASE + (ip->scode * SGC_DEVSIZE));
	sti_iteinit_common(ip);
}

/*
 * Initialize the sti device for ite's needs.
 * We don't bother to check for failures since
 * - we are in tight space already
 * - since romputchar() does not work with sti devices, there is no way we
 *   can report errors (although we could switch to serial...)
 */
void
sti_iteinit_common(struct ite_data *ip)
{
	int i;
	size_t codesize, memsize;
	u_int8_t *va, *code;
	u_int addr, eaddr, reglist, tmp;
	struct sti_inqconfout cfg;
	struct sti_einqconfout ecfg;

	bzero(&sti, sizeof sti);
	va = (u_int8_t *)ip->fbbase;

	/*
	 * Read the microcode.
	 */

	for (i = 0; i < STI_CODECNT; i++)
		sti.codeptr[i] =
		    parseword1(va, (STI_CODEBASE_M68K << 2) + i * 0x10);

	for (i = STI_END; sti.codeptr[i] == 0; i--);
	codesize = sti.codeptr[i] - sti.codeptr[STI_BEGIN];
	codesize = (codesize + 3) / 4;

	sti.code = (u_int8_t *)alloc(codesize);
	code = sti.code;
	addr = (u_int)va + sti.codeptr[STI_BEGIN];
	eaddr = addr + codesize * 4;
	for (; addr < eaddr; addr += 4)
		*code++ = *(u_int8_t *)addr;

	for (i = STI_CODECNT - 1; i != 0; i--)
		if (sti.codeptr[i] != 0) {
			sti.codeptr[i] -= sti.codeptr[0];
			sti.codeptr[i] /= 4;
		}

	sti.codeptr[0] = 0;
	for (i = STI_END; sti.codeptr[i] == 0; i--);
	sti.codeptr[i] = 0;

	/*
	 * Read the regions list.
	 */

	reglist = parseword1(va, 0x60);
	for (i = 0; i < STI_REGION_MAX; i++) {
		tmp = parseword1(va, (reglist & ~3) + i * 0x10);
		sti.cfg.regions[i] = (u_int)va + ((tmp >> 18) << 12);
		if (tmp & 0x4000)
			break;
	}

	/*
	 * Allocate scratch memory for the microcode if it needs it.
	 */

	sti.cfg.ext_cfg = &sti.ecfg;
	memsize = parseword1(va, 0xa0);
	if (memsize != 0)
		sti.ecfg.addr = alloc(memsize);

	/*
	 * Initialize the display, and get geometry information.
	 */

	sti_init(0);

	bzero(&cfg, sizeof cfg);
	bzero(&ecfg, sizeof ecfg);
	cfg.ext = &ecfg;
	sti_inqcfg(&cfg);

	if (cfg.owidth == cfg.width && cfg.oheight == cfg.height) {
		sti.cfg.oscr_width = cfg.owidth = cfg.fbwidth - cfg.width;
		sti.cfg.oscr_height = cfg.oheight = cfg.fbheight - cfg.height;
	}

	ip->dheight = cfg.height;
	ip->dwidth = cfg.width;
	ip->fbheight = cfg.fbheight;
	ip->fbwidth = cfg.fbwidth;

	/*
	 * Get ready for ite operation!
	 */

	sti_init(1);
	sti_fontinfo(ip);
	sti_clear(ip, 0, 0, ip->rows, ip->cols);	/* necessary? */
}

void
sti_putc(struct ite_data *ip, int c, int dy, int dx)
{
	sti_unpmv_t unpmv;
	struct {
		struct sti_unpmvflags flags;
		struct sti_unpmvin in;
		struct sti_unpmvout out;
	} a;

	bzero(&a, sizeof a);
	a.flags.flags = STI_UNPMVF_WAIT;
	a.in.bg_colour = STI_COLOUR_BLACK;
	a.in.fg_colour = STI_COLOUR_WHITE;
	a.in.x = dx * ip->ftwidth;
	a.in.y = dy * ip->ftheight;
	a.in.font_addr = (u_int32_t *)(ip->fbbase + sti.fontbase);
	a.in.index = c;

	unpmv = (sti_unpmv_t)(sti.code + sti.codeptr[STI_FONT_UNPMV]);
	(*unpmv)(&a.flags, &a.in, &a.out, &sti.cfg);
}

void
sti_cursor(struct ite_data *ip, int flag)
{
	switch (flag) {
	case MOVE_CURSOR:
		sti_do_cursor(ip);
		/* FALLTHROUGH */
	case DRAW_CURSOR:
		ip->cursorx = ip->curx;
		ip->cursory = ip->cury;
		/* FALLTHROUGH */
	default:
		sti_do_cursor(ip);
		break;
	}
}

void
sti_do_cursor(struct ite_data *ip)
{
	sti_blkmv_t blkmv;
	struct {
		struct sti_blkmvflags flags;
		struct sti_blkmvin in;
		struct sti_blkmvout out;
	} a;

	bzero(&a, sizeof a);
	a.flags.flags = STI_BLKMVF_WAIT | STI_BLKMVF_COLR;
	a.in.fg_colour = STI_COLOUR_BLACK;
	a.in.bg_colour = STI_COLOUR_WHITE;
	a.in.dstx = a.in.srcx = ip->cursorx * ip->ftwidth;
	a.in.dsty = a.in.srcy = ip->cursory * ip->ftheight;
	a.in.width = ip->ftwidth;
	a.in.height = ip->ftheight;

	blkmv = (sti_blkmv_t)(sti.code + sti.codeptr[STI_BLOCK_MOVE]);
	(*blkmv)(&a.flags, &a.in, &a.out, &sti.cfg);
}

void
sti_clear(struct ite_data *ip, int sy, int sx, int h, int w)
{
	sti_blkmv_t blkmv;
	struct {
		struct sti_blkmvflags flags;
		struct sti_blkmvin in;
		struct sti_blkmvout out;
	} a;

	bzero(&a, sizeof a);
	a.flags.flags = STI_BLKMVF_WAIT | STI_BLKMVF_CLR;
	a.in.bg_colour = STI_COLOUR_BLACK;
	a.in.dstx = a.in.srcx = sx * ip->ftwidth;
	a.in.dsty = a.in.srcy = sy * ip->ftheight;
	a.in.width = w * ip->ftwidth;
	a.in.height = h * ip->ftheight;

	blkmv = (sti_blkmv_t)(sti.code + sti.codeptr[STI_BLOCK_MOVE]);
	(*blkmv)(&a.flags, &a.in, &a.out, &sti.cfg);
}

void
sti_scroll(struct ite_data *ip)
{
	sti_blkmv_t blkmv;
	struct {
		struct sti_blkmvflags flags;
		struct sti_blkmvin in;
		struct sti_blkmvout out;
	} a;

	bzero(&a, sizeof a);
	a.flags.flags = STI_BLKMVF_WAIT;
	a.in.bg_colour = STI_COLOUR_BLACK;
	a.in.fg_colour = STI_COLOUR_WHITE;
	a.in.dstx = a.in.srcx = 0;
	a.in.dsty = 0;
	a.in.srcy = ip->ftheight;
	a.in.width = ip->dwidth;
	a.in.height = (ip->rows - 1) * ip->ftheight;

	blkmv = (sti_blkmv_t)(sti.code + sti.codeptr[STI_BLOCK_MOVE]);
	(*blkmv)(&a.flags, &a.in, &a.out, &sti.cfg);
}

void
sti_fontinfo(struct ite_data *ip)
{
	u_int32_t fontbase;

	fontbase = sti.fontbase = parseword1((u_int8_t *)ip->fbbase, 0x30) & ~3;
	ip->ftwidth = (u_int8_t)ip->fbbase[fontbase + 0x13];
	ip->ftheight = (u_int8_t)ip->fbbase[fontbase + 0x17];
	ip->rows = ip->dheight / ip->ftheight;
	ip->cols = ip->dwidth / ip->ftwidth;
}

void
sti_init(int full)
{
	sti_init_t init;
	struct {
		struct sti_initflags flags;
		struct sti_initin in;
		struct sti_initout out;
	} a;

	bzero(&a, sizeof a);
	a.flags.flags = STI_INITF_WAIT | STI_INITF_CMB | STI_INITF_EBET;
	if (full)
		a.flags.flags |= STI_INITF_TEXT | STI_INITF_PBET |
		    STI_INITF_PBETI | STI_INITF_ICMT;
	a.in.text_planes = 1;

	init = (sti_init_t)(sti.code + sti.codeptr[STI_INIT_GRAPH]);
	(*init)(&a.flags, &a.in, &a.out, &sti.cfg);
}

void
sti_inqcfg(struct sti_inqconfout *ico)
{
	sti_inqconf_t inqconf;
	struct {
		struct sti_inqconfflags flags;
		struct sti_inqconfin in;
	} a;

	bzero(&a, sizeof a);
	a.flags.flags = STI_INQCONFF_WAIT;

	inqconf = (sti_inqconf_t)(sti.code + sti.codeptr[STI_INQ_CONF]);
	(*inqconf)(&a.flags, &a.in, ico, &sti.cfg);
}

#endif
@


1.2
log
@So, it turns out that models 362 and 382 built-in frame buffer only shows up
in DIO-II space, as a fat device spanning four select codes (i.e. 16MB of
memory). This is way too much for an at-most 2 Mpixel 8bit frame buffer, and
it turns out that this is because the device provides both a regular DIO-II
frame buffer (spanning two select codes) and a regular STI frame buffer
(spanning the other two select codes).
This commit introduces a straightforward sti@@dio attachment to get a working
sti(4) and wsdisplay(4) in a ridiculously small number of lines; however
the console code needs some changes to avoid duplicating globals.

While there, add sti@@dio support for the bootblocks, and I couldn't help
myself but clean the most rotten parts of them, and try to have them reuse
various files in sys/arch/hp300/dev instead of rolling their outdated ones.

Tested on a real 382 with the low-resolution frame buffer:
sti0 at dio0 scode 132: rev 8.02;129, ID 0x27134CB440A00499
sti0: 382V, 2048x512 frame buffer, 640x480x8 display
sti0: 8x16 font type 1, 16 bpc, charset 0-255
wsdisplay0 at sti0 mux 1: console (std, vt100 emulation)

Boot blocks updates tested on DIO-II 425t (serial/glass console), SGC 425e
(serial/glass console) and 382 (serial/glass console). And will be tested
on SGC 425t soon as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite_sti.c,v 1.1 2006/08/17 06:31:10 miod Exp $	*/
@


1.1
log
@Large cleanup of the bootblocks, including ansi protos and de-register,
removal of unused hil stuff, oversimplification of the stand ite code
(including dio frame buffer common code factorization), and sgc frame
buffer console support, at last.

This shaves ~1800 bytes off SYS_UBOOT and ~500 bytes of SYS_CDBOOT
despite the addition of the sgc code.

Tested on dca, hyper, topcat and sti.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 1
 * Copyright (c) 2006, Miodrag Vallat
d38 1
d40 1
d66 33
d108 1
a108 1
sti_iteinit(struct ite_data *ip)
d110 1
a110 1
	int slotno, i;
d118 1
a118 2
	slotno = (int)ip->fbbase;
	ip->fbbase = va = (u_int8_t *)IIOV(SGC_BASE + (slotno * SGC_DEVSIZE));
@

