head	1.24;
access;
symbols
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.10
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.6
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.24
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.22
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.20
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.18
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.16
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.14
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.03.18.22.36.31;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2013.06.11.16.42.07;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.12.06.58.33;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.11.12.35.40;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.10.20.50.22;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.13.19.44.53;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.20.23.27.25;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.27.18.34.58;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.18.00.16.48;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.18.00.09.15;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.16.21.23.55;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.23.15.31.57;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.04.16.11.55.57;	author downsj;	state Exp;
branches
	1.7.14.1
	1.7.24.1;
next	1.6;

1.6
date	97.02.03.04.47.12;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.12.15.12.19;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.04.25.06.36.24;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.31.06.42.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.17;	author deraadt;	state Exp;
branches;
next	;

1.7.14.1
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.7.14.2;

1.7.14.2
date	2003.03.27.23.19.19;	author niklas;	state Exp;
branches;
next	1.7.14.3;

1.7.14.3
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	;

1.7.24.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: ct.c,v 1.23 2013/06/11 16:42:07 deraadt Exp $	*/
/*	$NetBSD: ct.c,v 1.21 1997/04/02 22:37:23 scottr Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ct.c	8.2 (Berkeley) 1/12/94
 */

/*
 * CS80 cartridge tape driver (9144, 88140, 9145)
 *
 * Reminder:
 *	C_CC bit (character count option) when used in the CS/80 command
 *	'set options' will cause the tape not to stream.
 *
 * TODO:
 *	make filesystem compatible
 *	make block mode work according to mtio(4) spec. (if possible)
 *	merge with cs80 disk driver
 *	finish support of 9145
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/mtio.h>
#include <sys/proc.h>

#include <hp300/dev/hpibvar.h>

#include <hp300/dev/ctreg.h>

/* number of eof marks to remember */
#define EOFS	128

struct	ct_softc {
	struct	device sc_dev;
	int	sc_slave;		/* HP-IB slave ID */
	int	sc_punit;		/* physical unit */
	struct	ct_iocmd sc_ioc;
	struct	ct_rscmd sc_rsc;
	struct	ct_stat sc_stat;
	struct	ct_ssmcmd sc_ssmc;
	struct	ct_srcmd sc_src;
	struct	ct_soptcmd sc_soptc;
	struct	ct_ulcmd sc_ul;
	struct	ct_wfmcmd sc_wfm;
	struct	ct_clearcmd sc_clear;
	struct	buf sc_tab;
	struct	buf *sc_bp;
	struct	buf sc_bufstore;	/* XXX */
	int	sc_blkno;
	int	sc_cmd;
	int	sc_resid;
	char	*sc_addr;
	int	sc_flags;
	short	sc_type;
	struct	hpibqueue sc_hq;	/* entry on hpib job queue */
	int	sc_eofp;
	int	sc_eofs[EOFS];
};

/* flags */
#define	CTF_OPEN	0x01
#define	CTF_ALIVE	0x02
#define	CTF_WRT		0x04
#define	CTF_CMD		0x08
#define	CTF_IO		0x10
#define	CTF_BEOF	0x20
#define	CTF_AEOF	0x40
#define	CTF_EOT		0x80
#define	CTF_STATWAIT	0x100
#define CTF_CANSTREAM	0x200
#define	CTF_WRTTN	0x400

int	ctmatch(struct device *, void *, void *);
void	ctattach(struct device *, struct device *, void *);

struct cfattach ct_ca = {
	sizeof(struct ct_softc), ctmatch, ctattach
};

struct cfdriver ct_cd = {
	NULL, "ct", DV_TAPE
};

int	ctident(struct device *, struct ct_softc *,
	    struct hpibbus_attach_args *);

void	ctreset(struct ct_softc *);
void	ctaddeof(struct ct_softc *);
void	ctustart(struct ct_softc *);
void	cteof(struct ct_softc *, struct buf *);
void	ctdone(struct ct_softc *, struct buf *);

void	ctstart(void *);
void	ctgo(void *);
void	ctintr(void *);

void	ctcommand(dev_t, int, int);

cdev_decl(ct);
bdev_decl(ct);

const struct	ctinfo {
	short	hwid;
	short	punit;
	char	*desc;
} ctinfo[] = {
	{ CT7946ID,	1,	"7946A"	},
	{ CT7912PID,	1,	"7912P"	},
	{ CT7914PID,	1,	"7914P"	},
	{ CT9144ID,	0,	"9144"	},
	{ CT9145ID,	0,	"9145"	},
};
int	nctinfo = sizeof(ctinfo) / sizeof(ctinfo[0]);

#define	CT_NOREW	4
#define	CT_STREAM	8
#define	UNIT(x)		(minor(x) & 3)
#define	ctpunit(x)	((x) & 7)

#ifdef DEBUG
int ctdebug = 0;
#define CDB_FILES	0x01
#define CT_BSF		0x02
#endif

int
ctmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct hpibbus_attach_args *ha = aux;

	return (ctident(parent, NULL, ha));
}

void
ctattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ct_softc *sc = (struct ct_softc *)self;
	struct hpibbus_attach_args *ha = aux;

	if (ctident(parent, sc, ha) == 0) {
		/* can't happen */
		printf("\n%s: didn't respond to describe command!\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	sc->sc_slave = ha->ha_slave;
	sc->sc_punit = ha->ha_punit;

	sc->sc_tab.b_actb = &sc->sc_tab.b_actf;

	/* Initialize hpib job queue entry. */
	sc->sc_hq.hq_softc = sc;
	sc->sc_hq.hq_slave = sc->sc_slave;
	sc->sc_hq.hq_start = ctstart;
	sc->sc_hq.hq_go = ctgo;
	sc->sc_hq.hq_intr = ctintr;

	ctreset(sc);
	sc->sc_flags |= CTF_ALIVE;
}

int
ctident(parent, sc, ha)
	struct device *parent;
	struct ct_softc *sc;
	struct hpibbus_attach_args *ha;
{
	struct cs80_describe desc;
	u_char stat, cmd[3];
	char name[7];
	int i, id, n, type, canstream;

	type = canstream = 0;

	/* Verify that we have a CS80 device. */
	if ((ha->ha_id & 0x200) == 0)
		return (0);

	/* Is it one of the tapes we support? */
	for (id = 0; id < nctinfo; id++)
		if (ha->ha_id == ctinfo[id].hwid &&
		    ha->ha_punit == ctinfo[id].punit)
			break;
	if (id == nctinfo)
		return (0);

	/*
	 * So far, so good.  Get drive parameters.  Note command
	 * is always issued to unit 0.
	 */
	bzero(&desc, sizeof(desc));
	stat = 0;
	cmd[0] = C_SUNIT(0);
	cmd[1] = C_SVOL(0);
	cmd[2] = C_DESC;
	hpibsend(parent->dv_unit, ha->ha_slave, C_CMD, cmd, sizeof(cmd));
	hpibrecv(parent->dv_unit, ha->ha_slave, C_EXEC, &desc, sizeof(desc));
	hpibrecv(parent->dv_unit, ha->ha_slave, C_QSTAT, &stat, sizeof(stat));

	if (desc.d_name == 0 && stat != 0)
		return (0);

	bzero(name, sizeof(name));
	n = desc.d_name;
	for (i = 5; i >= 0; i--) {
		name[i] = (n & 0xf) + '0';
		n >>= 4;
	}

	switch (ha->ha_id) {
	case CT7946ID:
		if (bcmp(name, "079450", 6) == 0)
			return (0);		/* not really a 7946 */
		/* FALLTHROUGH */
	case CT9144ID:
	case CT9145ID:
		type = CT9144;
		canstream = 1;
		break;

	case CT7912PID:
	case CT7914PID:
		type = CT88140;
		break;
	}

	if (sc != NULL) {
		sc->sc_type = type;
		sc->sc_flags = canstream ? CTF_CANSTREAM : 0;
		printf(": %s %stape\n", ctinfo[id].desc,
		    canstream ? "streaming " : "");
	}

	return (1);
}

void
ctreset(sc)
	struct ct_softc *sc;
{
	int ctlr, slave;
	u_char stat;

	ctlr = sc->sc_dev.dv_parent->dv_unit;
	slave = sc->sc_slave;

	sc->sc_clear.unit = C_SUNIT(sc->sc_punit);
	sc->sc_clear.cmd = C_CLEAR;
	hpibsend(ctlr, slave, C_TCMD, &sc->sc_clear, sizeof(sc->sc_clear));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));

	sc->sc_src.unit = C_SUNIT(CTCTLR);
	sc->sc_src.nop = C_NOP;
	sc->sc_src.cmd = C_SREL;
	sc->sc_src.param = C_REL;
	hpibsend(ctlr, slave, C_CMD, &sc->sc_src, sizeof(sc->sc_src));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));

	sc->sc_ssmc.unit = C_SUNIT(sc->sc_punit);
	sc->sc_ssmc.cmd = C_SSM;
	sc->sc_ssmc.refm = REF_MASK;
	sc->sc_ssmc.fefm = FEF_MASK;
	sc->sc_ssmc.aefm = AEF_MASK;
	sc->sc_ssmc.iefm = IEF_MASK;
	hpibsend(ctlr, slave, C_CMD, &sc->sc_ssmc, sizeof(sc->sc_ssmc));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));

	sc->sc_soptc.unit = C_SUNIT(sc->sc_punit);
	sc->sc_soptc.nop = C_NOP;
	sc->sc_soptc.cmd = C_SOPT;
	sc->sc_soptc.opt = C_SPAR;
	hpibsend(ctlr, slave, C_CMD, &sc->sc_soptc, sizeof(sc->sc_soptc));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));
}

/*ARGSUSED*/
int
ctopen(dev, flag, type, p)
	dev_t dev;
	int flag, type;
	struct proc *p;
{
	struct ct_softc *sc;
	u_char stat;
	int cc, ctlr, slave;

	if (UNIT(dev) >= ct_cd.cd_ndevs ||
	    (sc = ct_cd.cd_devs[UNIT(dev)]) == NULL ||
	    (sc->sc_flags & CTF_ALIVE) == 0)
		return (ENXIO);

	if (sc->sc_flags & CTF_OPEN)
		return (EBUSY);

	ctlr = sc->sc_dev.dv_parent->dv_unit;
	slave = sc->sc_slave;

	sc->sc_soptc.unit = C_SUNIT(sc->sc_punit);
	sc->sc_soptc.nop = C_NOP;
	sc->sc_soptc.cmd = C_SOPT;
	if ((dev & CT_STREAM) && (sc->sc_flags & CTF_CANSTREAM))
		sc->sc_soptc.opt = C_SPAR | C_IMRPT;
	else
		sc->sc_soptc.opt = C_SPAR;

	/*
	 * Check the return of hpibsend() and hpibswait().
	 * Drive could be loading/unloading a tape. If not checked,
	 * driver hangs.
	 */
	cc = hpibsend(ctlr, slave, C_CMD, &sc->sc_soptc, sizeof(sc->sc_soptc));
	if (cc != sizeof(sc->sc_soptc))
		return (EBUSY);

	hpibswait(ctlr, slave);
	cc = hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));
	if (cc != sizeof(stat))
		return(EBUSY);

	sc->sc_flags |= CTF_OPEN;
	return(0);
}

/*ARGSUSED*/
int
ctclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	struct ct_softc *sc = ct_cd.cd_devs[UNIT(dev)];

	if ((sc->sc_flags & (CTF_WRT|CTF_WRTTN)) == (CTF_WRT|CTF_WRTTN) &&
	    (sc->sc_flags & CTF_EOT) == 0 ) { /* XXX return error if EOT ?? */
		ctcommand(dev, MTWEOF, 2);
		ctcommand(dev, MTBSR, 1);
		if (sc->sc_eofp == EOFS - 1)
			sc->sc_eofs[EOFS - 1]--;
		else
			sc->sc_eofp--;
#ifdef DEBUG
		if(ctdebug & CT_BSF)
			printf("%s: ctclose backup eofs prt %d blk %d\n",
			       sc->sc_dev.dv_xname, sc->sc_eofp,
			       sc->sc_eofs[sc->sc_eofp]);
#endif
	}
	if ((minor(dev) & CT_NOREW) == 0)
		ctcommand(dev, MTREW, 1);
	sc->sc_flags &= ~(CTF_OPEN | CTF_WRT | CTF_WRTTN);
#ifdef DEBUG
	if (ctdebug & CDB_FILES)
		printf("ctclose: flags %x\n", sc->sc_flags);
#endif
	return(0);	/* XXX */
}

void
ctcommand(dev, cmd, cnt)
	dev_t dev;
	int cmd;
	int cnt;
{
	struct ct_softc *sc = ct_cd.cd_devs[UNIT(dev)];
	struct buf *bp = &sc->sc_bufstore;
	struct buf *nbp = 0;

	if (cmd == MTBSF && sc->sc_eofp == EOFS - 1) {
		cnt = sc->sc_eofs[EOFS - 1] - cnt;
		ctcommand(dev, MTREW, 1);
		ctcommand(dev, MTFSF, cnt);
		cnt = 2;
		cmd = MTBSR;
	}

	if (cmd == MTBSF && sc->sc_eofp - cnt < 0) {
		cnt = 1;
		cmd = MTREW;
	}

	sc->sc_flags |= CTF_CMD;
	sc->sc_bp = bp;
	sc->sc_cmd = cmd;
	bp->b_dev = dev;
	if (cmd == MTFSF) {
		nbp = (struct buf *)geteblk(MAXBSIZE);
		bp->b_data = nbp->b_data;
		bp->b_bcount = MAXBSIZE;
	}

	while (cnt-- > 0) {
		bp->b_flags = B_BUSY | B_RAW;
		if (cmd == MTBSF) {
			sc->sc_blkno = sc->sc_eofs[sc->sc_eofp];
			sc->sc_eofp--;
#ifdef DEBUG
			if (ctdebug & CT_BSF)
				printf("%s: backup eof pos %d blk %d\n",
				    sc->sc_dev.dv_xname, sc->sc_eofp,
				    sc->sc_eofs[sc->sc_eofp]);
#endif
		}
		ctstrategy(bp);
		biowait(bp);
	}
	bp->b_flags = 0;
	sc->sc_flags &= ~CTF_CMD;
	if (nbp)
		brelse(nbp);
}

void
ctstrategy(bp)
	struct buf *bp;
{
	struct buf *dp;
	int s, unit;
	struct ct_softc *sc;

	unit = UNIT(bp->b_dev);
	sc = ct_cd.cd_devs[unit];

	dp = &sc->sc_tab;
	bp->b_actf = NULL;
	s = splbio();
	bp->b_actb = dp->b_actb;
	*(dp->b_actb) = bp;
	dp->b_actb = &bp->b_actf;
	if (dp->b_active == 0) {
		dp->b_active = 1;
		ctustart(sc);
	}
	splx(s);
}

void
ctustart(sc)
	struct ct_softc *sc;
{
	struct buf *bp;

	bp = sc->sc_tab.b_actf;
	sc->sc_addr = bp->b_data;
	sc->sc_resid = bp->b_bcount;
	if (hpibreq(sc->sc_dev.dv_parent, &sc->sc_hq))
		ctstart(sc);
}

void
ctstart(arg)
	void *arg;
{
	struct ct_softc *sc = arg;
	struct buf *bp;
	int i, ctlr, slave;

	ctlr = sc->sc_dev.dv_parent->dv_unit;
	slave = sc->sc_slave;

	bp = sc->sc_tab.b_actf;
	if ((sc->sc_flags & CTF_CMD) && sc->sc_bp == bp) {
		switch(sc->sc_cmd) {
		case MTFSF:
			bp->b_flags |= B_READ;
			goto mustio;

		case MTBSF:
			goto gotaddr;

		case MTOFFL:
			sc->sc_blkno = 0;
			sc->sc_ul.unit = C_SUNIT(sc->sc_punit);
			sc->sc_ul.cmd = C_UNLOAD;
			hpibsend(ctlr, slave, C_CMD, &sc->sc_ul,
			    sizeof(sc->sc_ul));
			break;

		case MTWEOF:
			sc->sc_blkno++;
			sc->sc_flags |= CTF_WRT;
			sc->sc_wfm.unit = C_SUNIT(sc->sc_punit);
			sc->sc_wfm.cmd = C_WFM;
			hpibsend(ctlr, slave, C_CMD, &sc->sc_wfm,
			    sizeof(sc->sc_wfm));
			ctaddeof(sc);
			break;

		case MTBSR:
			sc->sc_blkno--;
			goto gotaddr;

		case MTFSR:
			sc->sc_blkno++;
			goto gotaddr;

		case MTREW:
			sc->sc_blkno = 0;
#ifdef DEBUG
			if(ctdebug & CT_BSF)
				printf("%s: clearing eofs\n",
				    sc->sc_dev.dv_xname);
#endif
			for (i=0; i<EOFS; i++)
				sc->sc_eofs[i] = 0;
			sc->sc_eofp = 0;

gotaddr:
			sc->sc_ioc.saddr = C_SADDR;
			sc->sc_ioc.addr0 = 0;
			sc->sc_ioc.addr = sc->sc_blkno;
			sc->sc_ioc.unit = C_SUNIT(sc->sc_punit);
			sc->sc_ioc.nop2 = C_NOP;
			sc->sc_ioc.slen = C_SLEN;
			sc->sc_ioc.len = 0;
			sc->sc_ioc.nop3 = C_NOP;
			sc->sc_ioc.cmd = C_READ;
			hpibsend(ctlr, slave, C_CMD, &sc->sc_ioc,
			    sizeof(sc->sc_ioc));
			break;
		}
	} else {
mustio:
		if ((bp->b_flags & B_READ) &&
		    sc->sc_flags & (CTF_BEOF|CTF_EOT)) {
#ifdef DEBUG
			if (ctdebug & CDB_FILES)
				printf("ctstart: before flags %x\n",
				    sc->sc_flags);
#endif
			if (sc->sc_flags & CTF_BEOF) {
				sc->sc_flags &= ~CTF_BEOF;
				sc->sc_flags |= CTF_AEOF;
#ifdef DEBUG
				if (ctdebug & CDB_FILES)
					printf("ctstart: after flags %x\n",
					    sc->sc_flags);
#endif
			}
			bp->b_resid = bp->b_bcount;
			ctdone(sc, bp);
			return;
		}
		sc->sc_flags |= CTF_IO;
		sc->sc_ioc.unit = C_SUNIT(sc->sc_punit);
		sc->sc_ioc.saddr = C_SADDR;
		sc->sc_ioc.addr0 = 0;
		sc->sc_ioc.addr = sc->sc_blkno;
		sc->sc_ioc.nop2 = C_NOP;
		sc->sc_ioc.slen = C_SLEN;
		sc->sc_ioc.len = sc->sc_resid;
		sc->sc_ioc.nop3 = C_NOP;
		if (bp->b_flags & B_READ)
			sc->sc_ioc.cmd = C_READ;
		else {
			sc->sc_ioc.cmd = C_WRITE;
			sc->sc_flags |= (CTF_WRT | CTF_WRTTN);
		}
		hpibsend(ctlr, slave, C_CMD, &sc->sc_ioc, sizeof(sc->sc_ioc));
	}
	hpibawait(ctlr);
}

void
ctgo(arg)
	void *arg;
{
	struct ct_softc *sc = arg;
	struct buf *bp;
	int rw;

	bp = sc->sc_tab.b_actf;
	rw = bp->b_flags & B_READ;
	hpibgo(sc->sc_dev.dv_parent->dv_unit, sc->sc_slave, C_EXEC,
	    sc->sc_addr, sc->sc_resid, rw, rw != 0);
}

/*
 * Hideous grue to handle EOF/EOT (mostly for reads)
 */
void
cteof(sc, bp)
	struct ct_softc *sc;
	struct buf *bp;
{
	long blks;

	/*
	 * EOT on a write is an error.
	 */
	if ((bp->b_flags & B_READ) == 0) {
		bp->b_resid = bp->b_bcount;
		bp->b_flags |= B_ERROR;
		bp->b_error = ENOSPC;
		sc->sc_flags |= CTF_EOT;
		return;
	}
	/*
	 * Use returned block position to determine how many blocks
	 * we really read and update b_resid.
	 */
	blks = sc->sc_stat.c_blk - sc->sc_blkno - 1;
#ifdef DEBUG
	if (ctdebug & CDB_FILES)
		printf("cteof: bc %ld oblk %d nblk %ld read %ld, resid %ld\n",
		       bp->b_bcount, sc->sc_blkno, sc->sc_stat.c_blk,
		       blks, bp->b_bcount - CTKTOB(blks));
#endif
	if (blks == -1) { /* 9145 on EOF does not change sc_stat.c_blk */
		blks = 0;
		sc->sc_blkno++;
	}
	else {
		sc->sc_blkno = sc->sc_stat.c_blk;
	}
	bp->b_resid = bp->b_bcount - CTKTOB(blks);
	/*
	 * If we are at physical EOV or were after an EOF,
	 * we are now at logical EOT.
	 */
	if ((sc->sc_stat.c_aef & AEF_EOV) ||
	    (sc->sc_flags & CTF_AEOF)) {
		sc->sc_flags |= CTF_EOT;
		sc->sc_flags &= ~(CTF_AEOF|CTF_BEOF);
	}
	/*
	 * If we were before an EOF or we have just completed a FSF,
	 * we are now after EOF.
	 */
	else if ((sc->sc_flags & CTF_BEOF) ||
		 ((sc->sc_flags & CTF_CMD) && sc->sc_cmd == MTFSF)) {
		sc->sc_flags |= CTF_AEOF;
		sc->sc_flags &= ~CTF_BEOF;
	}
	/*
	 * Otherwise if we read something we are now before EOF
	 * (and no longer after EOF).
	 */
	else if (blks) {
		sc->sc_flags |= CTF_BEOF;
		sc->sc_flags &= ~CTF_AEOF;
	}
	/*
	 * Finally, if we didn't read anything we just passed an EOF
	 */
	else
		sc->sc_flags |= CTF_AEOF;
#ifdef DEBUG
	if (ctdebug & CDB_FILES)
		printf("cteof: leaving flags %x\n", sc->sc_flags);
#endif
}

/* ARGSUSED */
void
ctintr(arg)
	void *arg;
{
	struct ct_softc *sc = arg;
	struct buf *bp;
	u_char stat;
	int ctlr, slave, unit;

	ctlr = sc->sc_dev.dv_parent->dv_unit;
	slave = sc->sc_slave;
	unit = sc->sc_dev.dv_unit;

	bp = sc->sc_tab.b_actf;
	if (bp == NULL) {
		printf("%s: bp == NULL\n", sc->sc_dev.dv_xname);
		return;
	}
	if (sc->sc_flags & CTF_IO) {
		sc->sc_flags &= ~CTF_IO;
		if (hpibustart(ctlr))
			ctgo(sc);
		return;
	}
	if ((sc->sc_flags & CTF_STATWAIT) == 0) {
		if (hpibpptest(ctlr, slave) == 0) {
			sc->sc_flags |= CTF_STATWAIT;
			hpibawait(ctlr);
			return;
		}
	} else
		sc->sc_flags &= ~CTF_STATWAIT;
	hpibrecv(ctlr, slave, C_QSTAT, &stat, 1);
#ifdef DEBUG
	if (ctdebug & CDB_FILES)
		printf("ctintr: before flags %x\n", sc->sc_flags);
#endif
	if (stat) {
		sc->sc_rsc.unit = C_SUNIT(sc->sc_punit);
		sc->sc_rsc.cmd = C_STATUS;
		hpibsend(ctlr, slave, C_CMD, &sc->sc_rsc, sizeof(sc->sc_rsc));
		hpibrecv(ctlr, slave, C_EXEC, &sc->sc_stat,
		    sizeof(sc->sc_stat));
		hpibrecv(ctlr, slave, C_QSTAT, &stat, 1);
#ifdef DEBUG
		if (ctdebug & CDB_FILES)
			printf("ctintr: return stat 0x%x, A%x F%x blk %ld\n",
			       stat, sc->sc_stat.c_aef,
			       sc->sc_stat.c_fef, sc->sc_stat.c_blk);
#endif
		if (stat == 0) {
			if (sc->sc_stat.c_aef & (AEF_EOF | AEF_EOV)) {
				cteof(sc, bp);
				ctaddeof(sc);
				goto done;
			}
			if (sc->sc_stat.c_fef & FEF_PF) {
				ctreset(sc);
				ctstart(sc);
				return;
			}
			if (sc->sc_stat.c_fef & FEF_REXMT) {
				ctstart(sc);
				return;
			}
			if (sc->sc_stat.c_aef & 0x5800) {
				if (sc->sc_stat.c_aef & 0x4000)
					printf("%s: uninitialized media\n",
						sc->sc_dev.dv_xname);
				if (sc->sc_stat.c_aef & 0x1000)
					printf("%s: not ready\n",
						sc->sc_dev.dv_xname);
				if (sc->sc_stat.c_aef & 0x0800)
					printf("%s: write protect\n",
						sc->sc_dev.dv_xname);
			} else {
				printf("%s err: v%d u%d ru%d bn%ld, ",
				       sc->sc_dev.dv_xname,
				       (sc->sc_stat.c_vu>>4)&0xF,
				       sc->sc_stat.c_vu&0xF,
				       sc->sc_stat.c_pend,
				       sc->sc_stat.c_blk);
				printf("R0x%x F0x%x A0x%x I0x%x\n",
				       sc->sc_stat.c_ref,
				       sc->sc_stat.c_fef,
				       sc->sc_stat.c_aef,
				       sc->sc_stat.c_ief);
			}
		} else
			printf("%s: request status failed\n",
			    sc->sc_dev.dv_xname);
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
		goto done;
	} else
		bp->b_resid = 0;
	if (sc->sc_flags & CTF_CMD) {
		switch (sc->sc_cmd) {
		case MTFSF:
			sc->sc_flags &= ~(CTF_BEOF|CTF_AEOF);
			sc->sc_blkno += CTBTOK(sc->sc_resid);
			ctstart(sc);
			return;
		case MTBSF:
			sc->sc_flags &= ~(CTF_AEOF|CTF_BEOF|CTF_EOT);
			break;
		case MTBSR:
			sc->sc_flags &= ~CTF_BEOF;
			if (sc->sc_flags & CTF_EOT) {
				sc->sc_flags |= CTF_AEOF;
				sc->sc_flags &= ~CTF_EOT;
			} else if (sc->sc_flags & CTF_AEOF) {
				sc->sc_flags |= CTF_BEOF;
				sc->sc_flags &= ~CTF_AEOF;
			}
			break;
		case MTWEOF:
			sc->sc_flags &= ~CTF_BEOF;
			if (sc->sc_flags & (CTF_AEOF|CTF_EOT)) {
				sc->sc_flags |= CTF_EOT;
				sc->sc_flags &= ~CTF_AEOF;
			} else
				sc->sc_flags |= CTF_AEOF;
			break;
		case MTREW:
		case MTOFFL:
			sc->sc_flags &= ~(CTF_BEOF|CTF_AEOF|CTF_EOT);
			break;
		}
	} else {
		sc->sc_flags &= ~CTF_AEOF;
		sc->sc_blkno += CTBTOK(sc->sc_resid);
	}
done:
#ifdef DEBUG
	if (ctdebug & CDB_FILES)
		printf("ctintr: after flags %x\n", sc->sc_flags);
#endif
	ctdone(sc, bp);
}

void
ctdone(sc, bp)
	struct ct_softc *sc;
	struct buf *bp;
{
	struct buf *dp;
	int s;

	if ((dp = bp->b_actf) != NULL)
		dp->b_actb = bp->b_actb;
	else
		sc->sc_tab.b_actb = bp->b_actb;
	*bp->b_actb = dp;
	s = splbio();
	biodone(bp);
	splx(s);
	hpibfree(sc->sc_dev.dv_parent, &sc->sc_hq);
	if (sc->sc_tab.b_actf == NULL) {
		sc->sc_tab.b_active = 0;
		return;
	}
	ctustart(sc);
}

int
ctread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	return (physio(ctstrategy, dev, B_READ, minphys, uio));
}

int
ctwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	/* XXX: check for hardware write-protect? */
	return (physio(ctstrategy, dev, B_WRITE, minphys, uio));
}

/*ARGSUSED*/
int
ctioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	int flag;
	caddr_t data;
	struct proc *p;
{
	struct mtop *op;
	int cnt;

	switch (cmd) {

	case MTIOCTOP:
		op = (struct mtop *)data;
		switch(op->mt_op) {

		case MTWEOF:
		case MTFSF:
		case MTBSR:
		case MTBSF:
		case MTFSR:
			cnt = op->mt_count;
			break;

		case MTREW:
		case MTOFFL:
			cnt = 1;
			break;

		default:
			return(EINVAL);
		}
		ctcommand(dev, op->mt_op, cnt);
		break;

	case MTIOCGET:
		break;

	default:
		return(EINVAL);
	}
	return(0);
}

/* ARGSUSED */
int
ctdump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{

	return (ENODEV);
}

void
ctaddeof(sc)
	struct ct_softc *sc;
{

	if (sc->sc_eofp == EOFS - 1)
		sc->sc_eofs[EOFS - 1]++;
	else {
		sc->sc_eofp++;
		if (sc->sc_eofp == EOFS - 1)
			sc->sc_eofs[EOFS - 1] = EOFS;
		else
			/* save blkno */
			sc->sc_eofs[sc->sc_eofp] = sc->sc_blkno - 1;
	}
#ifdef DEBUG
	if (ctdebug & CT_BSF)
		printf("%s: add eof pos %d blk %d\n",
		       sc->sc_dev.dv_xname, sc->sc_eofp,
		       sc->sc_eofs[sc->sc_eofp]);
#endif
}
@


1.23
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.22 2010/09/22 01:18:57 matthew Exp $	*/
@


1.22
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.21 2008/06/12 06:58:33 deraadt Exp $	*/
d930 1
a930 1
	daddr64_t blkno;
@


1.21
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.19 2008/06/10 20:50:22 beck Exp $	*/
d867 1
a867 1
	return (physio(ctstrategy, NULL, dev, B_READ, minphys, uio));
d877 1
a877 1
	return (physio(ctstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.20
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.18 2007/06/06 17:15:11 deraadt Exp $	*/
d434 1
a434 1
		bp->b_flags = B_BUSY;
@


1.19
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d434 1
a434 1
		bp->b_flags = B_BUSY | B_RAW;
@


1.18
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.17 2007/03/13 19:44:53 miod Exp $	*/
d434 1
a434 1
		bp->b_flags = B_BUSY;
@


1.17
log
@Be more strict during probe, consider failures to get device description
and device status code fatal, and do not attach in these cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.16 2006/01/20 23:27:25 miod Exp $	*/
d930 1
a930 1
	daddr_t blkno;
@


1.16
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.15 2005/12/27 18:34:58 miod Exp $	*/
d178 1
d229 2
d238 3
d242 4
a245 6
	if (stat == 0) {
		n = desc.d_name;
		for (i = 5; i >= 0; i--) {
			name[i] = (n & 0xf) + '0';
			n >>= 4;
		}
d252 1
a252 1
		/* fall into... */
@


1.15
log
@Do not tprintf() information, use printf() instead like all other tape
drivers do.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.14 2005/11/18 00:16:48 miod Exp $	*/
d425 1
a425 1
		bp->b_un.b_addr = nbp->b_un.b_addr;
d481 1
a481 1
	sc->sc_addr = bp->b_un.b_addr;
@


1.14
log
@Protect biodone() with splbio().
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.13 2005/11/18 00:09:15 miod Exp $	*/
a57 1
#include <sys/tprintf.h>
a87 1
	tpr_t	sc_tpr;
a357 1
	sc->sc_tpr = tprintf_open(p);
a388 1
	tprintf_close(sc->sc_tpr);
d759 1
a759 2
					tprintf(sc->sc_tpr,
						"%s: uninitialized media\n",
d762 1
a762 2
					tprintf(sc->sc_tpr,
						"%s: not ready\n",
d765 1
a765 2
					tprintf(sc->sc_tpr,
						"%s: write protect\n",
@


1.13
log
@Define the CS/80 identify structure only once and correctly, instead of
duplicating it in every CS/80 driver and using an hardcoded number for its size.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.12 2005/11/16 21:23:55 miod Exp $	*/
d846 1
d853 1
d855 1
@


1.12
log
@Overhaul the way HP-IB devices are probed. We will now do an exhaustive
probe of the (slave, punit) tuple space, since this is the only way we
can get a dual disk or dual tape enclosure to attach two devices of the
same kind.

This allows us to get rid of the hpibbus resource map and related
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.11 2005/01/15 21:13:08 miod Exp $	*/
d207 1
a207 1
	struct ct_describe desc;
d234 1
a234 1
	hpibrecv(parent->dv_unit, ha->ha_slave, C_EXEC, &desc, 37);
@


1.11
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.10 2003/06/02 23:27:44 millert Exp $	*/
d137 1
a137 1
struct	ctinfo {
d220 2
a221 1
		if (ha->ha_id == ctinfo[id].hwid)
a224 2

	ha->ha_punit = ctinfo[id].punit;
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.9 2002/05/23 15:31:57 art Exp $	*/
d347 1
a347 1
	/* 
d350 1
a350 1
	 * driver hangs. 
d442 1
a442 1
				    sc->sc_dev.dv_xname, sc->sc_eofp, 
d585 1
a585 1
		}			
@


1.9
log
@remove the defines for iodone -> biodone and iowait -> biowait.
Use the correct functions everywhere instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.8 2002/03/14 01:26:30 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.7 1997/04/16 11:55:57 downsj Exp $	*/
d451 1
a451 1
		iowait(bp);
@


1.7
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.6 1997/02/03 04:47:12 downsj Exp $	*/
d112 2
a113 2
int	ctmatch __P((struct device *, void *, void *));
void	ctattach __P((struct device *, struct device *, void *));
d123 2
a124 2
int	ctident __P((struct device *, struct ct_softc *,
	    struct hpibbus_attach_args *));
d126 9
a134 9
void	ctreset __P((struct ct_softc *));
void	ctaddeof __P((struct ct_softc *));
void	ctustart __P((struct ct_softc *));
void	cteof __P((struct ct_softc *, struct buf *));
void	ctdone __P((struct ct_softc *, struct buf *));

void	ctstart __P((void *));
void	ctgo __P((void *));
void	ctintr __P((void *));
d136 1
a136 1
void	ctcommand __P((dev_t, int, int));
@


1.7.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.7 1997/04/16 11:55:57 downsj Exp $	*/
d112 2
a113 2
int	ctmatch(struct device *, void *, void *);
void	ctattach(struct device *, struct device *, void *);
d123 2
a124 2
int	ctident(struct device *, struct ct_softc *,
	    struct hpibbus_attach_args *);
d126 9
a134 9
void	ctreset(struct ct_softc *);
void	ctaddeof(struct ct_softc *);
void	ctustart(struct ct_softc *);
void	cteof(struct ct_softc *, struct buf *);
void	ctdone(struct ct_softc *, struct buf *);

void	ctstart(void *);
void	ctgo(void *);
void	ctintr(void *);
d136 1
a136 1
void	ctcommand(dev_t, int, int);
d451 1
a451 1
		biowait(bp);
@


1.7.14.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 2
a113 2
int	ctmatch(struct device *, void *, void *);
void	ctattach(struct device *, struct device *, void *);
d123 2
a124 2
int	ctident(struct device *, struct ct_softc *,
	    struct hpibbus_attach_args *);
d126 9
a134 9
void	ctreset(struct ct_softc *);
void	ctaddeof(struct ct_softc *);
void	ctustart(struct ct_softc *);
void	cteof(struct ct_softc *, struct buf *);
void	ctdone(struct ct_softc *, struct buf *);

void	ctstart(void *);
void	ctgo(void *);
void	ctintr(void *);
d136 1
a136 1
void	ctcommand(dev_t, int, int);
@


1.7.14.2
log
@Sync the SMP branch with 3.3
@
text
@d451 1
a451 1
		biowait(bp);
@


1.7.14.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ct.c,v 1.7.14.2 2003/03/27 23:19:19 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ct.c,v 1.5 1997/01/12 15:12:19 downsj Exp $	*/
/*	$NetBSD: ct.c,v 1.19 1997/01/30 09:14:12 thorpej Exp $	*/
d55 1
d57 2
d61 1
a62 3
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
d146 5
a150 5
	CT7946ID,	1,	"7946A",
	CT7912PID,	1,	"7912P",
	CT7914PID,	1,	"7914P",
	CT9144ID,	0,	"9144",
	CT9145ID,	0,	"9145",
d409 1
a409 1
	register int cnt;
d412 2
a413 2
	register struct buf *bp = &sc->sc_bufstore;
	register struct buf *nbp = 0;
d461 1
a461 1
	register struct buf *bp;
d463 2
a464 2
	register struct buf *dp;
	register int s, unit;
d487 1
a487 1
	register struct buf *bp;
d501 1
a501 1
	struct buf *bp, *dp;
d615 1
a615 1
	register struct buf *bp;
d629 2
a630 2
	register struct ct_softc *sc;
	register struct buf *bp;
d651 1
a651 1
		printf("cteof: bc %d oblk %d nblk %d read %d, resid %d\n",
d677 1
a677 1
		 (sc->sc_flags & CTF_CMD) && sc->sc_cmd == MTFSF) {
d705 2
a706 2
	register struct ct_softc *sc = arg;
	register struct buf *bp;
d747 1
a747 1
			printf("ctintr: return stat 0x%x, A%x F%x blk %d\n",
d780 1
a780 1
				printf("%s err: v%d u%d ru%d bn%d, ",
d848 1
a848 1
	register struct buf *bp;
d850 1
a850 1
	register struct buf *dp;
d894 2
a895 2
	register struct mtop *op;
	register int cnt;
@


1.5
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ct.c,v 1.18 1996/10/14 07:14:11 thorpej Exp $	*/
d5 1
a39 2
#include "ct.h"
#if NCT > 0
d60 4
a64 1
#include <hp300/dev/device.h>
a69 6
int	ctmatch(), ctstart(), ctgo(), ctintr();
void	ctattach(), ctstrategy(), ctdone();
struct	driver ctdriver = {
	ctmatch, ctattach, "ct", ctstart, ctgo, ctintr,
};

d71 3
a73 1
	struct	hp_device *sc_hd;
d83 1
d85 1
a91 1
	short	sc_punit;
d93 1
a93 1
	struct	devqueue sc_dq;
d96 1
a96 1
} ct_softc[NCT];
d111 29
a152 3
struct	buf cttab[NCT];
struct	buf ctbuf[NCT];

d165 3
a167 2
ctmatch(hd)
	register struct hp_device *hd;
d169 1
a169 9
	register struct ct_softc *sc = &ct_softc[hd->hp_unit];
	register struct buf *bp;

	for (bp = cttab; bp < &cttab[NCT]; bp++)
		bp->b_actb = &bp->b_actf;
	sc->sc_hd = hd;
	sc->sc_punit = ctpunit(hd->hp_flags);
	if (ctident(sc, hd, 0) < 0)
		return (0);
d171 1
a171 1
	return (1);
d175 17
a191 4
ctattach(hd)
	register struct hp_device *hd;
{
	struct ct_softc *sc = &ct_softc[hd->hp_unit];
d193 6
a198 1
	(void)ctident(sc, hd, 1);	/* XXX Ick. */
d200 1
a200 6
	ctreset(sc, hd);
	sc->sc_dq.dq_softc = sc;
	sc->sc_dq.dq_ctlr = hd->hp_ctlr;
	sc->sc_dq.dq_unit = hd->hp_unit;
	sc->sc_dq.dq_slave = hd->hp_slave;
	sc->sc_dq.dq_driver = &ctdriver;
a201 3

	/* XXX Set device class. */
	hd->hp_dev.dv_class = DV_TAPE;
d205 4
a208 4
ctident(sc, hd, verbose)
	register struct ct_softc *sc;
	register struct hp_device *hd;
	int verbose;
d213 3
a215 1
	int id, i;
d217 7
a223 11
	/*
	 * Read device id and verify that:
	 * 1. It is a CS80 device
	 * 2. It is one of our recognized tape devices
	 * 3. It has the proper physical unit number
	 */
	id = hpibid(hd->hp_ctlr, hd->hp_slave);
	if ((id & 0x200) == 0)
		return(-1);
	for (i = 0; i < nctinfo; i++)
		if (id == ctinfo[i].hwid)
d225 4
a228 3
	if (i == nctinfo || sc->sc_punit != ctinfo[i].punit)
		return(-1);
	id = i;
d231 2
a232 3
	 * Collect device description.
	 * Right now we only need this to differentiate 7945 from 7946.
	 * Note that we always issue the describe command to unit 0.
d237 4
a240 3
	hpibsend(hd->hp_ctlr, hd->hp_slave, C_CMD, cmd, sizeof(cmd));
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_EXEC, &desc, 37);
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_QSTAT, &stat, sizeof(stat));
d242 2
a243 2
	if (!stat) {
		register int n = desc.d_name;
d249 2
a250 1
	switch (ctinfo[id].hwid) {
d253 1
a253 1
			return(-1);		/* not really a 7946 */
d257 2
a258 2
		sc->sc_type = CT9144;
		sc->sc_flags |= CTF_CANSTREAM;
d263 1
a263 1
		sc->sc_type = CT88140;
d266 4
a269 1
	if (verbose)
d271 4
a274 2
		    (sc->sc_flags & CTF_CANSTREAM) ? "streaming " : " ");
	return(id);
d277 3
a279 3
ctreset(sc, hd)
	register struct ct_softc *sc;
	register struct hp_device *hd;
d281 1
d284 3
d289 4
a292 4
	hpibsend(hd->hp_ctlr, hd->hp_slave, C_TCMD, &sc->sc_clear,
		sizeof(sc->sc_clear));
	hpibswait(hd->hp_ctlr, hd->hp_slave);
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_QSTAT, &stat, sizeof(stat));
d297 4
a300 4
	hpibsend(hd->hp_ctlr, hd->hp_slave, C_CMD, &sc->sc_src,
		sizeof(sc->sc_src));
	hpibswait(hd->hp_ctlr, hd->hp_slave);
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_QSTAT, &stat, sizeof(stat));
d307 4
a310 4
	hpibsend(hd->hp_ctlr, hd->hp_slave, C_CMD, &sc->sc_ssmc,
		sizeof(sc->sc_ssmc));
	hpibswait(hd->hp_ctlr, hd->hp_slave);
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_QSTAT, &stat, sizeof(stat));
d315 3
a317 4
	hpibsend(hd->hp_ctlr, hd->hp_slave, C_CMD, &sc->sc_soptc,
		sizeof(sc->sc_soptc));
	hpibswait(hd->hp_ctlr, hd->hp_slave);
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_QSTAT, &stat, sizeof(stat));
d321 1
d327 1
a327 1
	register struct ct_softc *sc = &ct_softc[UNIT(dev)];
d329 6
a334 1
	int cc;
a335 2
	if (UNIT(dev) >= NCT || (sc->sc_flags & CTF_ALIVE) == 0)
		return(ENXIO);
d337 5
a341 1
		return(EBUSY);
d349 1
d355 1
a355 2
	cc = hpibsend(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave,
	              C_CMD, &sc->sc_soptc, sizeof(sc->sc_soptc));
d357 4
a360 4
		return(EBUSY);
	hpibswait(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave);
	cc = hpibrecv(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave, C_QSTAT, 
	              &stat, sizeof(stat));
d363 1
d370 2
a371 1
ctclose(dev, flag)
d373 2
a374 1
	int flag;
d376 1
a376 1
	register struct ct_softc *sc = &ct_softc[UNIT(dev)];
d389 1
a389 1
			       sc->sc_hd->hp_xname, sc->sc_eofp,
d404 1
d410 2
a411 2
	register struct ct_softc *sc = &ct_softc[UNIT(dev)];
	register struct buf *bp = &ctbuf[UNIT(dev)];
d445 1
a445 1
				    sc->sc_hd->hp_xname, sc->sc_eofp, 
d464 1
d467 3
a469 1
	dp = &cttab[unit];
d473 1
a473 1
	*dp->b_actb = bp;
d477 1
a477 1
		ctustart(unit);
d482 3
a484 2
ctustart(unit)
	register int unit;
a485 1
	register struct ct_softc *sc = &ct_softc[unit];
d488 1
a488 1
	bp = cttab[unit].b_actf;
d491 2
a492 2
	if (hpibreq(&sc->sc_dq))
		ctstart(unit);
d495 3
a497 2
ctstart(unit)
	register int unit;
d499 3
a501 3
	register struct ct_softc *sc = &ct_softc[unit];
	register struct buf *bp, *dp;
	register int i;
d503 4
a506 1
	bp = cttab[unit].b_actf;
a508 1

d520 2
a521 2
			hpibsend(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave,
				C_CMD, &sc->sc_ul, sizeof(sc->sc_ul));
d529 3
a531 3
			hpibsend(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave,
				C_CMD, &sc->sc_wfm, sizeof(sc->sc_wfm));
			ctaddeof(unit);
d547 1
a547 1
				    sc->sc_hd->hp_xname);
d563 2
a564 2
			hpibsend(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave,
				C_CMD, &sc->sc_ioc, sizeof(sc->sc_ioc));
d567 1
a567 2
	}
	else {
d573 2
a574 1
				printf("ctstart: before flags %x\n", sc->sc_flags);
d581 2
a582 1
					printf("ctstart: after flags %x\n", sc->sc_flags);
d586 1
a586 1
			ctdone(unit, bp);
d604 1
a604 2
		hpibsend(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave, C_CMD,
			&sc->sc_ioc, sizeof(sc->sc_ioc));
d606 1
a606 1
	hpibawait(sc->sc_hd->hp_ctlr);
d609 3
a611 2
ctgo(unit)
	register int unit;
d613 1
a613 1
	register struct ct_softc *sc = &ct_softc[unit];
d617 1
a617 1
	bp = cttab[unit].b_actf;
d619 2
a620 2
	hpibgo(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave, C_EXEC,
		sc->sc_addr, sc->sc_resid, rw, rw != 0);
d626 1
d699 2
a700 1
int
d705 1
a705 1
	register struct buf *bp, *dp;
d707 5
a711 1
	int unit = sc->sc_hd->hp_unit;
d713 1
a713 1
	bp = cttab[unit].b_actf;
d715 1
a715 1
		printf("%s: bp == NULL\n", sc->sc_hd->hp_xname);
d720 2
a721 2
		if (hpibustart(sc->sc_hd->hp_ctlr))
			ctgo(unit);
d725 1
a725 1
		if (hpibpptest(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave) == 0) {
d727 1
a727 1
			hpibawait(sc->sc_hd->hp_ctlr);
d732 1
a732 1
	hpibrecv(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave, C_QSTAT, &stat, 1);
d740 4
a743 6
		hpibsend(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave, C_CMD,
			&sc->sc_rsc, sizeof(sc->sc_rsc));
		hpibrecv(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave, C_EXEC,
			&sc->sc_stat, sizeof(sc->sc_stat));
		hpibrecv(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave, C_QSTAT,
			&stat, 1);
d753 1
a753 1
				ctaddeof(unit);
d757 2
a758 2
				ctreset(sc, sc->sc_hd);
				ctstart(unit);
d762 1
a762 1
				ctstart(unit);
d769 1
a769 1
						sc->sc_hd->hp_xname);
d773 1
a773 1
						sc->sc_hd->hp_xname);
d777 1
a777 1
						sc->sc_hd->hp_xname);
d780 1
a780 1
				       sc->sc_hd->hp_xname,
d793 1
a793 1
			    sc->sc_hd->hp_xname);
d804 1
a804 1
			ctstart(unit);
d841 1
a841 1
	ctdone(unit, bp);
d845 2
a846 2
ctdone(unit, bp)
	int unit;
a848 1
	register struct ct_softc *sc = &ct_softc[unit];
d851 1
a851 1
	if (dp = bp->b_actf)
d854 1
a854 1
		cttab[unit].b_actb = bp->b_actb;
d857 3
a859 3
	hpibfree(&sc->sc_dq);
	if (cttab[unit].b_actf == NULL) {
		cttab[unit].b_active = 0;
d862 1
a862 1
	ctustart(unit);
d885 1
d888 2
a889 1
	int cmd, flag;
d930 3
a932 2
/*ARGSUSED*/
ctdump(dev)
d934 3
d938 2
a939 1
	return(ENXIO);
d942 3
a944 2
ctaddeof(unit)
	int unit;
d946 1
a946 2
	register struct ct_softc *sc = &ct_softc[unit];
	
d960 1
a960 1
		       sc->sc_hd->hp_xname, sc->sc_eofp,
a963 1
#endif
@


1.4
log
@sync w/ Net 960424
@
text
@d1 2
a2 1
/*	$NetBSD: ct.c,v 1.15 1996/02/14 02:44:02 thorpej Exp $	*/
d171 3
@


1.3
log
@sync with netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: ct.c,v 1.14 1996/01/23 00:28:09 scottr Exp $	*/
d164 1
d639 3
a641 2
ctintr(unit)
	register int unit;
d643 1
a643 1
	register struct ct_softc *sc = &ct_softc[unit];
d646 1
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: ct.c,v 1.13 1995/12/02 18:21:52 thorpej Exp $	*/
d383 11
a393 10
again:
	bp->b_flags = B_BUSY;
	if (cmd == MTBSF) {
		sc->sc_blkno = sc->sc_eofs[sc->sc_eofp];
		sc->sc_eofp--;
#ifdef DEBUG
		if (ctdebug & CT_BSF)
			printf("%s: backup eof pos %d blk %d\n",
			       sc->sc_hd->hp_xname, sc->sc_eofp, 
			       sc->sc_eofs[sc->sc_eofp]);
d395 3
a398 4
	ctstrategy(bp);
	iowait(bp);
	if (--cnt > 0)
		goto again;
a446 1
again:
a805 1

a814 1

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ct.c,v 1.12 1995/10/09 07:57:43 thorpej Exp $	*/
d67 2
a68 2
int	ctinit(), ctstart(), ctgo(), ctintr();
void	ctstrategy(), ctdone();
d70 1
a70 1
	ctinit, "ct", ctstart, ctgo, ctintr,
d138 2
a139 1
ctinit(hd)
d149 14
a162 2
	if (ctident(sc, hd) < 0)
		return(0);
a168 1
	return(1);
d171 2
a172 1
ctident(sc, hd)
d175 1
d233 3
a235 2
	printf("ct%d: %s %stape\n", hd->hp_unit, ctinfo[id].desc,
	       (sc->sc_flags & CTF_CANSTREAM) ? "streaming " : " ");
d336 3
a338 2
			printf("ct%d: ctclose backup eofs prt %d blk %d\n",
			       UNIT(dev), sc->sc_eofp, sc->sc_eofs[sc->sc_eofp]);
d390 2
a391 2
			printf("ct%d: backup eof pos %d blk %d\n",
			       UNIT(dev), sc->sc_eofp, 
d488 2
a489 1
				printf("ct%d: clearing eofs\n", unit);
d648 1
a648 1
		printf("ct%d: bp == NULL\n", unit);
d703 2
a704 2
						"ct%d: uninitialized media\n",
						unit);
d707 2
a708 1
						"ct%d: not ready\n", unit);
d711 2
a712 1
						"ct%d: write protect\n", unit);
d714 2
a715 2
				printf("ct%d err: v%d u%d ru%d bn%d, ",
				       unit,
d727 2
a728 1
			printf("ct%d: request status failed\n", unit);
d890 2
a891 2
		printf("ct%d: add eof pos %d blk %d\n",
		       unit, sc->sc_eofp,
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
