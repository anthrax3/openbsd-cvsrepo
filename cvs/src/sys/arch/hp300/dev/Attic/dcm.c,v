head	1.37;
access;
symbols
	OPENBSD_5_5:1.36.0.8
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.35.0.10
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.8
	OPENBSD_5_0:1.35.0.6
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.4
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.8
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.6
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.24.0.4
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.11.0.22
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.20
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.18
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.16
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.14
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.12
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.10
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.8
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.6
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2014.03.18.22.36.31;	author miod;	state dead;
branches;
next	1.36;

1.36
date	2012.09.08.19.24.28;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.28.14.13.27;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.12.12.57.51;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.09.17.53.38;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.31.12.00.05;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.01.11.59.37;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.31.18.13.41;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.30.18.14.09;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.30.18.03.33;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.27.22.08.39;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.12.18.01.08;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.15.21.08.36;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.14.22.39.25;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.08.22.13.53;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.19.21.34.42;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.22.20.38.07;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.15.20.32.13;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.11;

1.11
date	97.09.14.03.43.03;	author downsj;	state Exp;
branches
	1.11.12.1
	1.11.22.1;
next	1.10;

1.10
date	97.07.14.04.25.13;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.07.06.08.01.47;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.04.16.11.55.59;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.02.03.04.47.15;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.12.15.12.22;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.11.47.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.25.06.36.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.13.35.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.17;	author deraadt;	state Exp;
branches;
next	;

1.11.12.1
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.11.12.2;

1.11.12.2
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.11.12.3;

1.11.12.3
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.11.12.4;

1.11.12.4
date	2004.02.19.10.48.38;	author niklas;	state Exp;
branches;
next	;

1.11.22.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: dcm.c,v 1.36 2012/09/08 19:24:28 miod Exp $	*/
/*	$NetBSD: dcm.c,v 1.41 1997/05/05 20:59:16 thorpej Exp $	*/

/*
 * Copyright (c) 1995, 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from Utah: $Hdr: dcm.c 1.29 92/01/21$
 *
 *	@@(#)dcm.c	8.4 (Berkeley) 1/12/94
 */

/*
 * TODO:
 *	Timeouts
 *	Test console support.
 */

/*
 *  98642/MUX
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/time.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/cons.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>
#include <hp300/dev/dcmreg.h>

#ifndef DEFAULT_BAUD_RATE
#define DEFAULT_BAUD_RATE 9600
#endif

const struct speedtab dcmspeedtab[] = {
	{	0,	BR_0		},
	{	50,	BR_50		},
	{	75,	BR_75		},
	{	110,	BR_110		},
	{	134,	BR_134		},
	{	150,	BR_150		},
	{	300,	BR_300		},
	{	600,	BR_600		},
	{	1200,	BR_1200		},
	{	1800,	BR_1800		},
	{	2400,	BR_2400		},
	{	4800,	BR_4800		},
	{	9600,	BR_9600		},
	{	19200,	BR_19200	},
	{	38400,	BR_38400	},
	{	-1,	-1		},
};

/* u-sec per character based on baudrate (assumes 1 start/8 data/1 stop bit) */
#define	DCM_USPERCH(s)	(10000000 / (s))

/*
 * Per board interrupt scheme.  16.7ms is the polling interrupt rate
 * (16.7ms is about 550 baud, 38.4k is 72 chars in 16.7ms).
 */
#define DIS_TIMER	0
#define DIS_PERCHAR	1
#define DIS_RESET	2

int	dcmistype = -1;		/* -1 == dynamic, 0 == timer, 1 == perchar */
int     dcminterval = 5;	/* interval (secs) between checks */
struct	dcmischeme {
	int	dis_perchar;	/* non-zero if interrupting per char */
	long	dis_time;	/* last time examined */
	int	dis_intr;	/* recv interrupts during last interval */
	int	dis_char;	/* characters read during last interval */
};

/*
 * Stuff for DCM console support.  This could probably be done a little
 * better.
 */
static	struct dcmdevice *dcm_cn = NULL;	/* pointer to hardware */
static	int dcmconsinit;			/* has been initialized */

int	dcmdefaultrate = DEFAULT_BAUD_RATE;
int	dcmconbrdbusy = 0;
int	dcmmajor;

#ifdef KGDB
/*
 * Kernel GDB support
 */
#include <machine/remote-sl.h>

extern dev_t kgdb_dev;
extern int kgdb_rate;
extern int kgdb_debug_init;
#endif

/* #define DCMSTATS */

#ifdef DEBUG
int	dcmdebug = 0x0;
#define DDB_SIOERR	0x01
#define DDB_PARAM	0x02
#define DDB_INPUT	0x04
#define DDB_OUTPUT	0x08
#define DDB_INTR	0x10
#define DDB_IOCTL	0x20
#define DDB_INTSCHM	0x40
#define DDB_MODEM	0x80
#define DDB_OPENCLOSE	0x100
#endif

#ifdef DCMSTATS
#define	DCMRBSIZE	94
#define DCMXBSIZE	24

struct	dcmstats {
	long	xints;		    /* # of xmit ints */
	long	xchars;		    /* # of xmit chars */
	long	xempty;		    /* times outq is empty in dcmstart */
	long	xrestarts;	    /* times completed while xmitting */
	long	rints;		    /* # of recv ints */
	long	rchars;		    /* # of recv chars */
	long	xsilo[DCMXBSIZE+2]; /* times this many chars xmit on one int */
	long	rsilo[DCMRBSIZE+2]; /* times this many chars read on one int */
};
#endif

#define DCMUNIT(x)		(minor(x) & 0x7f)
#define DCMCUA(x)		(minor(x) & 0x80)
#define	DCMBOARD(x)		(((x) >> 2) & 0x3f)
#define DCMPORT(x)		((x) & 3)

/*
 * Conversion from "HP DCE" to almost-normal DCE: on the 638 8-port mux,
 * the distribution panel uses "HP DCE" conventions.  If requested via
 * the device flags, we swap the inputs to something closer to normal DCE,
 * allowing a straight-through cable to a DTE or a reversed cable
 * to a DCE (reversing 2-3, 4-5, 8-20 and leaving 6 unconnected;
 * this gets "DCD" on pin 20 and "CTS" on 4, but doesn't connect
 * DSR or make RTS work, though).  The following gives the full
 * details of a cable from this mux panel to a modem:
 *
 *		     HP		    modem
 *		name	pin	pin	name
 * HP inputs:
 *		"Rx"	 2	 3	Tx
 *		CTS	 4	 5	CTS	(only needed for CCTS_OFLOW)
 *		DCD	20	 8	DCD
 *		"DSR"	 9	 6	DSR	(unneeded)
 *		RI	22	22	RI	(unneeded)
 *
 * HP outputs:
 *		"Tx"	 3	 2	Rx
 *		"DTR"	 6	not connected
 *		"RTS"	 8	20	DTR
 *		"SR"	23	 4	RTS	(often not needed)
 */
#define hp2dce_in(ibits)	(iconv[(ibits) & 0xf])
static char iconv[16] = {
	0,		MI_DM,		MI_CTS,		MI_CTS|MI_DM,
	MI_CD,		MI_CD|MI_DM,	MI_CD|MI_CTS,	MI_CD|MI_CTS|MI_DM,
	MI_RI,		MI_RI|MI_DM,	MI_RI|MI_CTS,	MI_RI|MI_CTS|MI_DM,
	MI_RI|MI_CD,	MI_RI|MI_CD|MI_DM, MI_RI|MI_CD|MI_CTS,
	MI_RI|MI_CD|MI_CTS|MI_DM
};

/*
 * Note that 8-port boards appear as 2 4-port boards at consecutive
 * select codes.
 */
#define	NDCMPORT	4

struct	dcm_softc {
	struct	device sc_dev;		/* generic device glue */
	struct	isr sc_isr;
	struct	dcmdevice *sc_dcm;	/* pointer to hardware */
	struct	tty *sc_tty[NDCMPORT];	/* our tty instances */
	struct	modemreg *sc_modem[NDCMPORT]; /* modem control */
	char	sc_mcndlast[NDCMPORT];	/* XXX last modem status for port */
	short	sc_softCAR;		/* mask of ports with soft-carrier */
	struct	dcmischeme sc_scheme;	/* interrupt scheme for board */
	u_char	sc_cua;			/* callout mode */

	/*
	 * Mask of soft-carrier bits in config flags.
	 */
#define	DCM_SOFTCAR	0x0000000f

	int	sc_flags;		/* misc. configuration info */

	/*
	 * Bits for sc_flags
	 */
#define	DCM_ACTIVE	0x00000001	/* indicates board is alive */
#define	DCM_ISCONSOLE	0x00000002	/* indicates board is console */
#define	DCM_STDDCE	0x00000010	/* re-map DCE to standard */
#define	DCM_FLAGMASK	(DCM_STDDCE)	/* mask of valid bits in config flags */

#ifdef DCMSTATS
	struct	dcmstats sc_stats;	/* metrics gathering */
#endif
};

cdev_decl(dcm);

int	dcmintr(void *);
void	dcmpint(struct dcm_softc *, int, int);
void	dcmrint(struct dcm_softc *);
void	dcmreadbuf(struct dcm_softc *, int);
void	dcmxint(struct dcm_softc *, int);
void	dcmmint(struct dcm_softc *, int, int);

int	dcmparam(struct tty *, struct termios *);
void	dcmstart(struct tty *);
int	dcmstop(struct tty *, int);
int	dcmmctl(dev_t, int, int);
void	dcmsetischeme(int, int);
void	dcminit(struct dcmdevice *, int, int);

int	dcmselftest(struct dcm_softc *);

int	dcm_console_scan(int, caddr_t, void *);
cons_decl(dcm);

int	dcmmatch(struct device *, void *, void *);
void	dcmattach(struct device *, struct device *, void *);

struct cfattach dcm_ca = {
	sizeof(struct dcm_softc), dcmmatch, dcmattach
};

struct cfdriver dcm_cd = {
	NULL, "dcm", DV_TTY
};

int
dcmmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct dio_attach_args *da = aux;

	switch (da->da_id) {
	case DIO_DEVICE_ID_DCM:
	case DIO_DEVICE_ID_DCMREM:
		return (1);
	}

	return (0);
}

void
dcmattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct dcm_softc *sc = (struct dcm_softc *)self;
	struct dio_attach_args *da = aux;
	struct dcmdevice *dcm;
	int brd = self->dv_unit;
	int scode = da->da_scode;
	int i, mbits, code, ipl;

	sc->sc_flags = 0;

	if (scode == conscode) {
		dcm = (struct dcmdevice *)conaddr;
		sc->sc_flags |= DCM_ISCONSOLE;

		/*
		 * We didn't know which unit this would be during
		 * the console probe, so we have to fixup cn_dev here.
		 * Note that we always assume port 1 on the board.
		 */
		cn_tab->cn_dev = makedev(dcmmajor, (brd << 2) | DCMCONSPORT);
	} else {
		dcm = (struct dcmdevice *)iomap(dio_scodetopa(da->da_scode),
		    da->da_size);
		if (dcm == NULL) {
			printf("\n%s: can't map registers\n",
			    sc->sc_dev.dv_xname);
			return;
		}
	}

	sc->sc_dcm = dcm;

	ipl = DIO_IPL(dcm);
	printf(" ipl %d", ipl);

	/*
	 * XXX someone _should_ fix this; the self test screws
	 * autoconfig messages.
	 */
	if ((sc->sc_flags & DCM_ISCONSOLE) && dcmselftest(sc)) {
		printf("\n%s: self-test failed\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Extract configuration info from flags. */
	sc->sc_softCAR = self->dv_cfdata->cf_flags & DCM_SOFTCAR;
	sc->sc_flags |= self->dv_cfdata->cf_flags & DCM_FLAGMASK;

	/* Mark our unit as configured. */
	sc->sc_flags |= DCM_ACTIVE;

	/* Establish the interrupt handler. */
	sc->sc_isr.isr_func = dcmintr;
	sc->sc_isr.isr_arg = sc;
	sc->sc_isr.isr_ipl = ipl;
	sc->sc_isr.isr_priority = IPL_TTY;
	dio_intr_establish(&sc->sc_isr, self->dv_xname);

	if (dcmistype == DIS_TIMER)
		dcmsetischeme(brd, DIS_RESET|DIS_TIMER);
	else
		dcmsetischeme(brd, DIS_RESET|DIS_PERCHAR);

	/* load pointers to modem control */
	sc->sc_modem[0] = &dcm->dcm_modem0;
	sc->sc_modem[1] = &dcm->dcm_modem1;
	sc->sc_modem[2] = &dcm->dcm_modem2;
	sc->sc_modem[3] = &dcm->dcm_modem3;

	/* set DCD (modem) and CTS (flow control) on all ports */
	if (sc->sc_flags & DCM_STDDCE)
		mbits = hp2dce_in(MI_CD|MI_CTS);
	else
		mbits = MI_CD|MI_CTS;

	for (i = 0; i < NDCMPORT; i++)
		sc->sc_modem[i]->mdmmsk = mbits;

	/*
	 * Get current state of mdmin register on all ports, so that
	 * deltas will work properly.
	 */
	for (i = 0; i < NDCMPORT; i++) {
		code = sc->sc_modem[i]->mdmin;
		if (sc->sc_flags & DCM_STDDCE)
			code = hp2dce_in(code);
		sc->sc_mcndlast[i] = code;
	}

	dcm->dcm_ic = IC_IE;		/* turn all interrupts on */

	/*
	 * Need to reset baud rate, etc. of next print so reset dcmconsinit.
	 * Also make sure console is always "hardwired"
	 */
	if (sc->sc_flags & DCM_ISCONSOLE) {
		dcmconsinit = 0;
		sc->sc_softCAR |= (1 << DCMCONSPORT);
		printf(": console on port %d\n", DCMCONSPORT);
	} else
		printf("\n");

#ifdef KGDB
	if (major(kgdb_dev) == dcmmajor &&
	    DCMBOARD(DCMUNIT(kgdb_dev)) == brd) {
		if (dcmconsole == DCMUNIT(kgdb_dev))	/* XXX fixme */
			kgdb_dev = NODEV; /* can't debug over console port */
#ifndef KGDB_CHEAT
		/*
		 * The following could potentially be replaced
		 * by the corresponding code in dcmcnprobe.
		 */
		else {
			dcminit(dcm, DCMPORT(DCMUNIT(kgdb_dev)),
			    kgdb_rate);
			if (kgdb_debug_init) {
				printf("%s port %d: ", sc->sc_dev.dv_xname,
				    DCMPORT(DCMUNIT(kgdb_dev)));
				kgdb_connect(1);
			} else
				printf("%s port %d: kgdb enabled\n",
				    sc->sc_dev.dv_xname,
				    DCMPORT(DCMUNIT(kgdb_dev)));
		}
		/* end could be replaced */
#endif /* KGDB_CHEAT */
	}
#endif /* KGDB */
}

/* ARGSUSED */
int
dcmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct dcm_softc *sc;
	struct tty *tp;
	int unit, brd, port;
	int error = 0, mbits, s;

	unit = DCMUNIT(dev);
	brd = DCMBOARD(unit);
	port = DCMPORT(unit);

	if (brd >= dcm_cd.cd_ndevs || port >= NDCMPORT ||
	    (sc = dcm_cd.cd_devs[brd]) == NULL)
		return (ENXIO);

	if ((sc->sc_flags & DCM_ACTIVE) == 0)
		return (ENXIO);

	s = spltty();
	if (sc->sc_tty[port] == NULL) {
		tp = sc->sc_tty[port] = ttymalloc(0);
	} else
		tp = sc->sc_tty[port];
	splx(s);

	tp->t_oproc = dcmstart;
	tp->t_param = dcmparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		/*
		 * Sanity clause: reset the card on first open.
		 * The card might be left in an inconsistent state
		 * if the card memory is read inadvertently.
		 */
		dcminit(sc->sc_dcm, port, dcmdefaultrate);

		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;

		s = spltty();

		(void) dcmparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0)
		return (EBUSY);
	else
		s = spltty();

	/* Set modem control state. */
	mbits = MO_ON;
	if (sc->sc_flags & DCM_STDDCE)
		mbits |= MO_SR;		/* pin 23, could be used as RTS */

	(void) dcmmctl(dev, mbits, DMSET);	/* enable port */

	/* Set soft-carrier if so configured. */
	if ((sc->sc_softCAR & (1 << port)) || DCMCUA(dev) ||
	    (dcmmctl(dev, MO_OFF, DMGET) & MI_CD))
		tp->t_state |= TS_CARR_ON;

	if (DCMCUA(dev)) {
		if (tp->t_state & TS_ISOPEN) {
			/* Ah, but someone already is dialed in... */
			splx(s);
			return (EBUSY);
		}
		sc->sc_cua = 1;		/* We go into CUA mode */
	}

#ifdef DEBUG
	if (dcmdebug & DDB_MODEM)
		printf("%s: dcmopen port %d softcarr %c\n",
		       sc->sc_dev.dv_xname, port,
		       (tp->t_state & TS_CARR_ON) ? '1' : '0');
#endif

	/* Wait for carrier if necessary. */
	if (flag & O_NONBLOCK) {
		if (!DCMCUA(dev) && sc->sc_cua) {
			/* Opening TTY non-blocking... but the CUA is busy */
			splx(s);
			return (EBUSY);
		}
	} else {
		while (sc->sc_cua ||
		    ((tp->t_cflag & CLOCAL) == 0 &&
		    (tp->t_state & TS_CARR_ON) == 0)) {
			tp->t_state |= TS_WOPEN;
			error = ttysleep(tp, (caddr_t)&tp->t_rawq,
			    TTIPRI | PCATCH, ttopen, 0);
			if (!DCMCUA(dev) && sc->sc_cua && error == EINTR)
				continue;
			if (error) {
				if (DCMCUA(dev))
					sc->sc_cua = 0;
				splx(s);
				return (error);
			}
			if (!DCMCUA(dev) && sc->sc_cua)
				continue;
		}
	}
	splx(s);

#ifdef DEBUG
	if (dcmdebug & DDB_OPENCLOSE)
		printf("%s port %d: dcmopen: st %x fl %x\n",
			sc->sc_dev.dv_xname, port, tp->t_state, tp->t_flags);
#endif
	if (error == 0)
		error = (*linesw[tp->t_line].l_open)(dev, tp, p);

	return (error);
}

/*ARGSUSED*/
int
dcmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int s, unit, board, port;
	struct dcm_softc *sc;
	struct tty *tp;

	unit = DCMUNIT(dev);
	board = DCMBOARD(unit);
	port = DCMPORT(unit);

	sc = dcm_cd.cd_devs[board];
	tp = sc->sc_tty[port];

	(*linesw[tp->t_line].l_close)(tp, flag, p);

	s = spltty();

	if (tp->t_cflag & HUPCL || tp->t_state & TS_WOPEN ||
	    (tp->t_state & TS_ISOPEN) == 0)
		(void) dcmmctl(dev, MO_OFF, DMSET);
#ifdef DEBUG
	if (dcmdebug & DDB_OPENCLOSE)
		printf("%s port %d: dcmclose: st %x fl %x\n",
			sc->sc_dev.dv_xname, port, tp->t_state, tp->t_flags);
#endif
	sc->sc_cua = 0;
	splx(s);
	ttyclose(tp);
#if 0
	ttyfree(tp);
	sc->sc_tty[port] == NULL;
#endif
	return (0);
}

int
dcmread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, board, port;
	struct dcm_softc *sc;
	struct tty *tp;

	unit = DCMUNIT(dev);
	board = DCMBOARD(unit);
	port = DCMPORT(unit);

	sc = dcm_cd.cd_devs[board];
	tp = sc->sc_tty[port];

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
dcmwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, board, port;
	struct dcm_softc *sc;
	struct tty *tp;

	unit = DCMUNIT(dev);
	board = DCMBOARD(unit);
	port = DCMPORT(unit);

	sc = dcm_cd.cd_devs[board];
	tp = sc->sc_tty[port];

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
dcmtty(dev)
	dev_t dev;
{
	int unit, board, port;
	struct dcm_softc *sc;

	unit = DCMUNIT(dev);
	board = DCMBOARD(unit);
	port = DCMPORT(unit);

	sc = dcm_cd.cd_devs[board];

	return (sc->sc_tty[port]);
}

int
dcmintr(arg)
	void *arg;
{
	struct dcm_softc *sc = arg;
	struct dcmdevice *dcm = sc->sc_dcm;
	struct dcmischeme *dis = &sc->sc_scheme;
	int brd = sc->sc_dev.dv_unit;
	int code, i;
	int pcnd[4], mcode, mcnd[4];

	/*
	 * Do all guarded accesses right off to minimize
	 * block out of hardware.
	 */
	SEM_LOCK(dcm);
	if ((dcm->dcm_ic & IC_IR) == 0) {
		SEM_UNLOCK(dcm);
		return (0);
	}

	for (i = 0; i < 4; i++) {
		pcnd[i] = dcm->dcm_icrtab[i].dcm_data;
		dcm->dcm_icrtab[i].dcm_data = 0;
		code = sc->sc_modem[i]->mdmin;
		if (sc->sc_flags & DCM_STDDCE)
			code = hp2dce_in(code);
		mcnd[i] = code;
	}
	code = dcm->dcm_iir & IIR_MASK;
	dcm->dcm_iir = 0;	/* XXX doc claims read clears interrupt?! */
	mcode = dcm->dcm_modemintr;
	dcm->dcm_modemintr = 0;
	SEM_UNLOCK(dcm);

#ifdef DEBUG
	if (dcmdebug & DDB_INTR) {
		printf("%s: dcmintr: iir %x pc %x/%x/%x/%x ",
		       sc->sc_dev.dv_xname, code, pcnd[0], pcnd[1],
		       pcnd[2], pcnd[3]);
		printf("miir %x mc %x/%x/%x/%x\n",
		       mcode, mcnd[0], mcnd[1], mcnd[2], mcnd[3]);
	}
#endif
	if (code & IIR_TIMEO)
		dcmrint(sc);
	if (code & IIR_PORT0)
		dcmpint(sc, 0, pcnd[0]);
	if (code & IIR_PORT1)
		dcmpint(sc, 1, pcnd[1]);
	if (code & IIR_PORT2)
		dcmpint(sc, 2, pcnd[2]);
	if (code & IIR_PORT3)
		dcmpint(sc, 3, pcnd[3]);
	if (code & IIR_MODM) {
		if (mcode == 0 || mcode & 0x1)	/* mcode==0 -> 98642 board */
			dcmmint(sc, 0, mcnd[0]);
		if (mcode & 0x2)
			dcmmint(sc, 1, mcnd[1]);
		if (mcode & 0x4)
			dcmmint(sc, 2, mcnd[2]);
		if (mcode & 0x8)
			dcmmint(sc, 3, mcnd[3]);
	}

	/*
	 * Chalk up a receiver interrupt if the timer running or one of
	 * the ports reports a special character interrupt.
	 */
	if ((code & IIR_TIMEO) ||
	    ((pcnd[0]|pcnd[1]|pcnd[2]|pcnd[3]) & IT_SPEC))
		dis->dis_intr++;
	/*
	 * See if it is time to check/change the interrupt rate.
	 */
	if (dcmistype < 0 &&
	    (i = time_second - dis->dis_time) >= dcminterval) {
		/*
		 * If currently per-character and averaged over 70 interrupts
		 * per-second (66 is threshold of 600 baud) in last interval,
		 * switch to timer mode.
		 *
		 * XXX decay counts ala load average to avoid spikes?
		 */
		if (dis->dis_perchar && dis->dis_intr > 70 * i)
			dcmsetischeme(brd, DIS_TIMER);
		/*
		 * If currently using timer and had more interrupts than
		 * received characters in the last interval, switch back
		 * to per-character.  Note that after changing to per-char
		 * we must process any characters already in the queue
		 * since they may have arrived before the bitmap was setup.
		 *
		 * XXX decay counts?
		 */
		else if (!dis->dis_perchar && dis->dis_intr > dis->dis_char) {
			dcmsetischeme(brd, DIS_PERCHAR);
			dcmrint(sc);
		}
		dis->dis_intr = dis->dis_char = 0;
		dis->dis_time = time_second;
	}
	return (1);
}

/*
 *  Port interrupt.  Can be two things:
 *	First, it might be a special character (exception interrupt);
 *	Second, it may be a buffer empty (transmit interrupt);
 */
void
dcmpint(sc, port, code)
	struct dcm_softc *sc;
	int port, code;
{

	if (code & IT_SPEC)
		dcmreadbuf(sc, port);
	if (code & IT_TX)
		dcmxint(sc, port);
}

void
dcmrint(sc)
	struct dcm_softc *sc;
{
	int port;

	for (port = 0; port < NDCMPORT; port++)
		dcmreadbuf(sc, port);
}

void
dcmreadbuf(sc, port)
	struct dcm_softc *sc;
	int port;
{
	struct dcmdevice *dcm = sc->sc_dcm;
	struct dcmpreg *pp = dcm_preg(dcm, port);
	struct dcmrfifo *fifo;
	struct tty *tp;
	int c, stat;
	u_int head;
	int nch = 0;
#ifdef DCMSTATS
	struct dcmstats *dsp = &sc->sc_stats;

	dsp->rints++;
#endif
	tp = sc->sc_tty[port];
	if (tp == NULL)
		return;

	if ((tp->t_state & TS_ISOPEN) == 0) {
#ifdef KGDB
		if ((makedev(dcmmajor, minor(tp->t_dev)) == kgdb_dev) &&
		    (head = pp->r_head & RX_MASK) != (pp->r_tail & RX_MASK) &&
		    dcm->dcm_rfifos[3-port][head>>1].data_char == FRAME_START) {
			pp->r_head = (head + 2) & RX_MASK;
			kgdb_connect(0);	/* trap into kgdb */
			return;
		}
#endif /* KGDB */
		pp->r_head = pp->r_tail & RX_MASK;
		return;
	}

	head = pp->r_head & RX_MASK;
	fifo = &dcm->dcm_rfifos[3-port][head>>1];
	/*
	 * XXX upper bound on how many chars we will take in one swallow?
	 */
	while (head != (pp->r_tail & RX_MASK)) {
		/*
		 * Get character/status and update head pointer as fast
		 * as possible to make room for more characters.
		 */
		c = fifo->data_char;
		stat = fifo->data_stat;
		head = (head + 2) & RX_MASK;
		pp->r_head = head;
		fifo = head ? fifo+1 : &dcm->dcm_rfifos[3-port][0];
		nch++;

#ifdef DEBUG
		if (dcmdebug & DDB_INPUT)
			printf("%s port %d: dcmreadbuf: c%x('%c') s%x f%x h%x t%x\n",
			       sc->sc_dev.dv_xname, port,
			       c&0xFF, c, stat&0xFF,
			       tp->t_flags, head, pp->r_tail);
#endif
		/*
		 * Check for and handle errors
		 */
		if (stat & RD_MASK) {
#ifdef DEBUG
			if (dcmdebug & (DDB_INPUT|DDB_SIOERR))
				printf("%s port %d: dcmreadbuf: err: c%x('%c') s%x\n",
				       sc->sc_dev.dv_xname, port,
				       stat, c&0xFF, c);
#endif
			if (stat & (RD_BD | RD_FE))
				c |= TTY_FE;
			else if (stat & RD_PE)
				c |= TTY_PE;
			else if (stat & RD_OVF)
				log(LOG_WARNING,
				    "%s port %d: silo overflow\n",
				    sc->sc_dev.dv_xname, port);
			else if (stat & RD_OE)
				log(LOG_WARNING,
				    "%s port %d: uart overflow\n",
				    sc->sc_dev.dv_xname, port);
		}
		(*linesw[tp->t_line].l_rint)(c, tp);
	}
	sc->sc_scheme.dis_char += nch;

#ifdef DCMSTATS
	dsp->rchars += nch;
	if (nch <= DCMRBSIZE)
		dsp->rsilo[nch]++;
	else
		dsp->rsilo[DCMRBSIZE+1]++;
#endif
}

void
dcmxint(sc, port)
	struct dcm_softc *sc;
	int port;
{
	struct tty *tp;

	tp = sc->sc_tty[port];
	if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0)
		return;

	tp->t_state &= ~TS_BUSY;
	if (tp->t_state & TS_FLUSH)
		tp->t_state &= ~TS_FLUSH;
	(*linesw[tp->t_line].l_start)(tp);
}

void
dcmmint(sc, port, mcnd)
	struct dcm_softc *sc;
	int port, mcnd;
{
	int delta;
	struct tty *tp;
	struct dcmdevice *dcm = sc->sc_dcm;

	tp = sc->sc_tty[port];
	if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0)
		return;

#ifdef DEBUG
	if (dcmdebug & DDB_MODEM)
		printf("%s port %d: dcmmint: mcnd %x mcndlast %x\n",
		       sc->sc_dev.dv_xname, port, mcnd, sc->sc_mcndlast[port]);
#endif
	delta = mcnd ^ sc->sc_mcndlast[port];
	sc->sc_mcndlast[port] = mcnd;
	if ((delta & MI_CTS) && (tp->t_state & TS_ISOPEN) &&
	    (tp->t_flags & CCTS_OFLOW)) {
		if (mcnd & MI_CTS) {
			tp->t_state &= ~TS_TTSTOP;
			ttstart(tp);
		} else
			tp->t_state |= TS_TTSTOP;	/* inline dcmstop */
	}
	if (delta & MI_CD) {
		if (mcnd & MI_CD)
			(void)(*linesw[tp->t_line].l_modem)(tp, 1);
		else if ((sc->sc_softCAR & (1 << port)) == 0 &&
		    (*linesw[tp->t_line].l_modem)(tp, 0) == 0) {
			sc->sc_modem[port]->mdmout = MO_OFF;
			SEM_LOCK(dcm);
			dcm->dcm_modemchng |= (1 << port);
			dcm->dcm_cr |= CR_MODM;
			SEM_UNLOCK(dcm);
			DELAY(10); /* time to change lines */
		}
	}
}

int
dcmioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct dcm_softc *sc;
	struct tty *tp;
	struct dcmdevice *dcm;
	int board, port, unit = DCMUNIT(dev);
	int error, s;

	port = DCMPORT(unit);
	board = DCMBOARD(unit);

	sc = dcm_cd.cd_devs[board];
	dcm = sc->sc_dcm;
	tp = sc->sc_tty[port];

#ifdef DEBUG
	if (dcmdebug & DDB_IOCTL)
		printf("%s port %d: dcmioctl: cmd %lx data %x flag %x\n",
		       sc->sc_dev.dv_xname, port, cmd, *data, flag);
#endif
	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		/*
		 * Wait for transmitter buffer to empty
		 */
		s = spltty();
		while (dcm->dcm_thead[port].ptr != dcm->dcm_ttail[port].ptr)
			DELAY(DCM_USPERCH(tp->t_ospeed));
		SEM_LOCK(dcm);
		dcm->dcm_cmdtab[port].dcm_data |= CT_BRK;
		dcm->dcm_cr |= (1 << port);	/* start break */
		SEM_UNLOCK(dcm);
		splx(s);
		break;

	case TIOCCBRK:
		SEM_LOCK(dcm);
		dcm->dcm_cmdtab[port].dcm_data |= CT_BRK;
		dcm->dcm_cr |= (1 << port);	/* end break */
		SEM_UNLOCK(dcm);
		break;

	case TIOCSDTR:
		(void) dcmmctl(dev, MO_ON, DMBIS);
		break;

	case TIOCCDTR:
		(void) dcmmctl(dev, MO_ON, DMBIC);
		break;

	case TIOCMSET:
		(void) dcmmctl(dev, *(int *)data, DMSET);
		break;

	case TIOCMBIS:
		(void) dcmmctl(dev, *(int *)data, DMBIS);
		break;

	case TIOCMBIC:
		(void) dcmmctl(dev, *(int *)data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = dcmmctl(dev, 0, DMGET);
		break;

	case TIOCGFLAGS: {
		int bits = 0;

		if ((sc->sc_softCAR & (1 << port)))
			bits |= TIOCFLAG_SOFTCAR;

		if (tp->t_cflag & CLOCAL)
			bits |= TIOCFLAG_CLOCAL;

		*(int *)data = bits;
		break;
	}

	case TIOCSFLAGS: {
		int userbits;

		error = suser(p, 0);
		if (error)
			return (EPERM);

		userbits = *(int *)data;

		if ((userbits & TIOCFLAG_SOFTCAR) ||
		    ((sc->sc_flags & DCM_ISCONSOLE) &&
		    (port == DCMCONSPORT)))
			sc->sc_softCAR |= (1 << port);

		if (userbits & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;

		break;
	}

	default:
		return (ENOTTY);
	}
	return (0);
}

int
dcmparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct dcm_softc *sc;
	struct dcmdevice *dcm;
	int unit, board, port, mode, cflag = t->c_cflag;
	int ospeed = ttspeedtab(t->c_ospeed, dcmspeedtab);

	unit = DCMUNIT(tp->t_dev);
	board = DCMBOARD(unit);
	port = DCMPORT(unit);

	sc = dcm_cd.cd_devs[board];
	dcm = sc->sc_dcm;

	/* check requested parameters */
        if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed))
                return (EINVAL);
        /* and copy to tty */
        tp->t_ispeed = t->c_ispeed;
        tp->t_ospeed = t->c_ospeed;
        tp->t_cflag = cflag;
	if (ospeed == 0) {
		(void) dcmmctl(DCMUNIT(tp->t_dev), MO_OFF, DMSET);
		return (0);
	}

	mode = 0;
	switch (cflag&CSIZE) {
	case CS5:
		mode = LC_5BITS; break;
	case CS6:
		mode = LC_6BITS; break;
	case CS7:
		mode = LC_7BITS; break;
	case CS8:
		mode = LC_8BITS; break;
	}
	if (cflag&PARENB) {
		if (cflag&PARODD)
			mode |= LC_PODD;
		else
			mode |= LC_PEVEN;
	}
	if (cflag&CSTOPB)
		mode |= LC_2STOP;
	else
		mode |= LC_1STOP;
#ifdef DEBUG
	if (dcmdebug & DDB_PARAM)
		printf("%s port %d: dcmparam: cflag %x mode %x speed %d uperch %d\n",
		       sc->sc_dev.dv_xname, port, cflag, mode, tp->t_ospeed,
		       DCM_USPERCH(tp->t_ospeed));
#endif

	/*
	 * Wait for transmitter buffer to empty.
	 */
	while (dcm->dcm_thead[port].ptr != dcm->dcm_ttail[port].ptr)
		DELAY(DCM_USPERCH(tp->t_ospeed));
	/*
	 * Make changes known to hardware.
	 */
	dcm->dcm_data[port].dcm_baud = ospeed;
	dcm->dcm_data[port].dcm_conf = mode;
	SEM_LOCK(dcm);
	dcm->dcm_cmdtab[port].dcm_data |= CT_CON;
	dcm->dcm_cr |= (1 << port);
	SEM_UNLOCK(dcm);
	/*
	 * Delay for config change to take place. Weighted by baud.
	 * XXX why do we do this?
	 */
	DELAY(16 * DCM_USPERCH(tp->t_ospeed));
	return (0);
}

void
dcmstart(tp)
	struct tty *tp;
{
	struct dcm_softc *sc;
	struct dcmdevice *dcm;
	struct dcmpreg *pp;
	struct dcmtfifo *fifo;
	char *bp;
	u_int head, tail, next;
	int unit, board, port, nch;
	char buf[16];
	int s;
#ifdef DCMSTATS
	struct dcmstats *dsp = &sc->sc_stats;
	int tch = 0;
#endif

	unit = DCMUNIT(tp->t_dev);
	board = DCMBOARD(unit);
	port = DCMPORT(unit);

	sc = dcm_cd.cd_devs[board];
	dcm = sc->sc_dcm;

	s = spltty();
#ifdef DCMSTATS
	dsp->xints++;
#endif
#ifdef DEBUG
	if (dcmdebug & DDB_OUTPUT)
		printf("%s port %d: dcmstart: state %x flags %x outcc %d\n",
		       sc->sc_dev.dv_xname, port, tp->t_state, tp->t_flags,
		       tp->t_outq.c_cc);
#endif
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
		goto out;
	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0) {
#ifdef DCMSTATS
		dsp->xempty++;
#endif
		goto out;
	}

	pp = dcm_preg(dcm, port);
	tail = pp->t_tail & TX_MASK;
	next = (tail + 1) & TX_MASK;
	head = pp->t_head & TX_MASK;
	if (head == next)
		goto out;
	fifo = &dcm->dcm_tfifos[3-port][tail];
again:
	nch = q_to_b(&tp->t_outq, buf, (head - next) & TX_MASK);
#ifdef DCMSTATS
	tch += nch;
#endif
#ifdef DEBUG
	if (dcmdebug & DDB_OUTPUT)
		printf("\thead %x tail %x nch %d\n", head, tail, nch);
#endif
	/*
	 * Loop transmitting all the characters we can.
	 */
	for (bp = buf; --nch >= 0; bp++) {
		fifo->data_char = *bp;
		pp->t_tail = next;
		/*
		 * If this is the first character,
		 * get the hardware moving right now.
		 */
		if (bp == buf) {
			tp->t_state |= TS_BUSY;
			SEM_LOCK(dcm);
			dcm->dcm_cmdtab[port].dcm_data |= CT_TX;
			dcm->dcm_cr |= (1 << port);
			SEM_UNLOCK(dcm);
		}
		tail = next;
		fifo = tail ? fifo+1 : &dcm->dcm_tfifos[3-port][0];
		next = (next + 1) & TX_MASK;
	}
	/*
	 * Head changed while we were loading the buffer,
	 * go back and load some more if we can.
	 */
	if (tp->t_outq.c_cc && head != (pp->t_head & TX_MASK)) {
#ifdef DCMSTATS
		dsp->xrestarts++;
#endif
		head = pp->t_head & TX_MASK;
		goto again;
	}

	/*
	 * Kick it one last time in case it finished while we were
	 * loading the last bunch.
	 */
	if (bp > &buf[1]) {
		tp->t_state |= TS_BUSY;
		SEM_LOCK(dcm);
		dcm->dcm_cmdtab[port].dcm_data |= CT_TX;
		dcm->dcm_cr |= (1 << port);
		SEM_UNLOCK(dcm);
	}
#ifdef DEBUG
	if (dcmdebug & DDB_INTR)
		printf("%s port %d: dcmstart: head %x tail %x outqcc %d\n",
		    sc->sc_dev.dv_xname, port, head, tail, tp->t_outq.c_cc);
#endif
out:
#ifdef DCMSTATS
	dsp->xchars += tch;
	if (tch <= DCMXBSIZE)
		dsp->xsilo[tch]++;
	else
		dsp->xsilo[DCMXBSIZE+1]++;
#endif
	splx(s);
}

/*
 * Stop output on a line.
 */
int
dcmstop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY) {
		/* XXX is there some way to safely stop transmission? */
		if ((tp->t_state&TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return (0);
}

/*
 * Modem control
 */
int
dcmmctl(dev, bits, how)
	dev_t dev;
	int bits, how;
{
	struct dcm_softc *sc;
	struct dcmdevice *dcm;
	int s, unit, brd, port, hit = 0;

	unit = DCMUNIT(dev);
	brd = DCMBOARD(unit);
	port = DCMPORT(unit);

	sc = dcm_cd.cd_devs[brd];
	dcm = sc->sc_dcm;

#ifdef DEBUG
	if (dcmdebug & DDB_MODEM)
		printf("%s port %d: dcmmctl: bits 0x%x how %x\n",
		       sc->sc_dev.dv_xname, port, bits, how);
#endif

	s = spltty();

	switch (how) {
	case DMSET:
		sc->sc_modem[port]->mdmout = bits;
		hit++;
		break;

	case DMBIS:
		sc->sc_modem[port]->mdmout |= bits;
		hit++;
		break;

	case DMBIC:
		sc->sc_modem[port]->mdmout &= ~bits;
		hit++;
		break;

	case DMGET:
		bits = sc->sc_modem[port]->mdmin;
		if (sc->sc_flags & DCM_STDDCE)
			bits = hp2dce_in(bits);
		break;
	}
	if (hit) {
		SEM_LOCK(dcm);
		dcm->dcm_modemchng |= 1<<(unit & 3);
		dcm->dcm_cr |= CR_MODM;
		SEM_UNLOCK(dcm);
		DELAY(10); /* delay until done */
		splx(s);
	}
	return (bits);
}

/*
 * Set board to either interrupt per-character or at a fixed interval.
 */
void
dcmsetischeme(brd, flags)
	int brd, flags;
{
	struct dcm_softc *sc = dcm_cd.cd_devs[brd];
	struct dcmdevice *dcm = sc->sc_dcm;
	struct dcmischeme *dis = &sc->sc_scheme;
	int i;
	u_char mask;
	int perchar = flags & DIS_PERCHAR;

#ifdef DEBUG
	if (dcmdebug & DDB_INTSCHM)
		printf("%s: dcmsetischeme(%d): cur %d, ints %d, chars %d\n",
		       sc->sc_dev.dv_xname, perchar, dis->dis_perchar,
		       dis->dis_intr, dis->dis_char);
	if ((flags & DIS_RESET) == 0 && perchar == dis->dis_perchar) {
		printf("%s: dcmsetischeme: redundant request %d\n",
		       sc->sc_dev.dv_xname, perchar);
		return;
	}
#endif
	/*
	 * If perchar is non-zero, we enable interrupts on all characters
	 * otherwise we disable perchar interrupts and use periodic
	 * polling interrupts.
	 */
	dis->dis_perchar = perchar;
	mask = perchar ? 0xf : 0x0;
	for (i = 0; i < 256; i++)
		dcm->dcm_bmap[i].data_data = mask;
	/*
	 * Don't slow down tandem mode, interrupt on flow control
	 * chars for any port on the board.
	 */
	if (!perchar) {
		struct tty *tp;
		int c;

		for (i = 0; i < NDCMPORT; i++) {
			tp = sc->sc_tty[i];

			if ((c = tp->t_cc[VSTART]) != _POSIX_VDISABLE)
				dcm->dcm_bmap[c].data_data |= (1 << i);
			if ((c = tp->t_cc[VSTOP]) != _POSIX_VDISABLE)
				dcm->dcm_bmap[c].data_data |= (1 << i);
		}
	}
	/*
	 * Board starts with timer disabled so if first call is to
	 * set perchar mode then we don't want to toggle the timer.
	 */
	if (flags == (DIS_RESET|DIS_PERCHAR))
		return;
	/*
	 * Toggle card 16.7ms interrupts (we first make sure that card
	 * has cleared the bit so it will see the toggle).
	 */
	while (dcm->dcm_cr & CR_TIMER)
		;
	SEM_LOCK(dcm);
	dcm->dcm_cr |= CR_TIMER;
	SEM_UNLOCK(dcm);
}

void
dcminit(dcm, port, rate)
	struct dcmdevice *dcm;
	int port, rate;
{
	int s, mode;

	mode = LC_8BITS | LC_1STOP;

	s = splhigh();

	/*
	 * Wait for transmitter buffer to empty.
	 */
	while (dcm->dcm_thead[port].ptr != dcm->dcm_ttail[port].ptr)
		DELAY(DCM_USPERCH(rate));

	/*
	 * Make changes known to hardware.
	 */
	dcm->dcm_data[port].dcm_baud = ttspeedtab(rate, dcmspeedtab);
	dcm->dcm_data[port].dcm_conf = mode;
	SEM_LOCK(dcm);
	dcm->dcm_cmdtab[port].dcm_data |= CT_CON;
	dcm->dcm_cr |= (1 << port);
	SEM_UNLOCK(dcm);

	/*
	 * Delay for config change to take place. Weighted by baud.
	 * XXX why do we do this?
	 */
	DELAY(16 * DCM_USPERCH(rate));
	splx(s);
}

/*
 * Empirically derived self-test magic
 */
int
dcmselftest(sc)
	struct dcm_softc *sc;
{
	struct dcmdevice *dcm = sc->sc_dcm;
	int timo = 0;
	int s, rv;

	rv = 1;

	s = splhigh();
	dcm->dcm_rsid = DCMRS;
	DELAY(50000);	/* 5000 is not long enough */
	dcm->dcm_rsid = 0;
	dcm->dcm_ic = IC_IE;
	dcm->dcm_cr = CR_SELFT;
	while ((dcm->dcm_ic & IC_IR) == 0) {
		if (++timo == 20000)
			goto out;
		DELAY(1);
	}
	DELAY(50000);	/* XXX why is this needed ???? */
	while ((dcm->dcm_iir & IIR_SELFT) == 0) {
		if (++timo == 400000)
			goto out;
		DELAY(1);
	}
	DELAY(50000);	/* XXX why is this needed ???? */
	if (dcm->dcm_stcon != ST_OK) {
#if 0
		if (hd->hp_args->hw_sc != conscode)
			printf("dcm%d: self test failed: %x\n",
			       brd, dcm->dcm_stcon);
#endif
		goto out;
	}
	dcm->dcm_ic = IC_ID;
	rv = 0;

 out:
	splx(s);
	return (rv);
}

/*
 * Following are all routines needed for DCM to act as console
 */

int
dcm_console_scan(scode, va, arg)
	int scode;
	caddr_t va;
	void *arg;
{
	struct dcmdevice *dcm = (struct dcmdevice *)va;
	struct consdev *cp = arg;
	u_int pri;

	switch (dcm->dcm_rsid) {
	case DCMID:
		pri = CN_LOWPRI;
		break;

	case DCMID|DCMCON:
		pri = CN_HIGHPRI;
		break;

	default:
		return (0);
	}

#ifdef CONSCODE
	/*
	 * Raise our priority, if appropriate.
	 */
	if (scode == CONSCODE)
		pri = CN_FORCED;
#endif

	/* Only raise priority. */
	if (pri > cp->cn_pri)
		cp->cn_pri = pri;

	/*
	 * If our priority is higher than the currently-remembered
	 * console, stash our priority, for the benefit of dcmcninit().
	 */
	if (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri) {
		cn_tab = cp;
		conscode = scode;
		return (DIO_SIZE(scode, va));
	}
	return (0);
}

void
dcmcnprobe(cp)
	struct consdev *cp;
{

	/* locate the major number */
	for (dcmmajor = 0; dcmmajor < nchrdev; dcmmajor++)
		if (cdevsw[dcmmajor].d_open == dcmopen)
			break;

	/* initialize required fields */
	cp->cn_dev = makedev(dcmmajor, 0);	/* XXX */

	console_scan(dcm_console_scan, cp);

#ifdef KGDB_CHEAT
	/* XXX this needs to be fixed. */
	/*
	 * This doesn't currently work, at least not with ite consoles;
	 * the console hasn't been initialized yet.
	 */
	if (major(kgdb_dev) == dcmmajor &&
	    DCMBOARD(DCMUNIT(kgdb_dev)) == DCMBOARD(unit)) {
		dcminit(dcm_cn, DCMPORT(DCMUNIT(kgdb_dev)), kgdb_rate);
		if (kgdb_debug_init) {
			/*
			 * We assume that console is ready for us...
			 * this assumes that a dca or ite console
			 * has been selected already and will init
			 * on the first putc.
			 */
			printf("dcm%d: ", DCMUNIT(kgdb_dev));
			kgdb_connect(1);
		}
	}
#endif
}

/* ARGSUSED */
void
dcmcninit(cp)
	struct consdev *cp;
{

	/*
	 * We are not interested by the second console pass.
	 */
	if (consolepass != 0)
		return;

	dcm_cn = (struct dcmdevice *)conaddr;
	dcminit(dcm_cn, DCMCONSPORT, dcmdefaultrate);
	dcmconsinit = 1;
}

/* ARGSUSED */
int
dcmcngetc(dev)
	dev_t dev;
{
	struct dcmrfifo *fifo;
	struct dcmpreg *pp;
	u_int head;
	int s, c, stat;

	pp = dcm_preg(dcm_cn, DCMCONSPORT);

	s = splhigh();
	head = pp->r_head & RX_MASK;
	fifo = &dcm_cn->dcm_rfifos[3-DCMCONSPORT][head>>1];
	while (head == (pp->r_tail & RX_MASK))
		;
	/*
	 * If board interrupts are enabled, just let our received char
	 * interrupt through in case some other port on the board was
	 * busy.  Otherwise we must clear the interrupt.
	 */
	SEM_LOCK(dcm_cn);
	if ((dcm_cn->dcm_ic & IC_IE) == 0)
		stat = dcm_cn->dcm_iir;
	SEM_UNLOCK(dcm_cn);
	c = fifo->data_char;
	stat = fifo->data_stat;
	pp->r_head = (head + 2) & RX_MASK;
	splx(s);
	return (c);
}

/*
 * Console kernel output character routine.
 */
/* ARGSUSED */
void
dcmcnputc(dev, c)
	dev_t dev;
	int c;
{
	struct dcmpreg *pp;
	unsigned tail;
	int s, stat;

	pp = dcm_preg(dcm_cn, DCMCONSPORT);

	s = splhigh();
#ifdef KGDB
	if (dev != kgdb_dev)
#endif
	if (dcmconsinit == 0) {
		dcminit(dcm_cn, DCMCONSPORT, dcmdefaultrate);
		dcmconsinit = 1;
	}
	tail = pp->t_tail & TX_MASK;
	while (tail != (pp->t_head & TX_MASK))
		;
	dcm_cn->dcm_tfifos[3-DCMCONSPORT][tail].data_char = c;
	pp->t_tail = tail = (tail + 1) & TX_MASK;
	SEM_LOCK(dcm_cn);
	dcm_cn->dcm_cmdtab[DCMCONSPORT].dcm_data |= CT_TX;
	dcm_cn->dcm_cr |= (1 << DCMCONSPORT);
	SEM_UNLOCK(dcm_cn);
	while (tail != (pp->t_head & TX_MASK))
		;
	/*
	 * If board interrupts are enabled, just let our completion
	 * interrupt through in case some other port on the board
	 * was busy.  Otherwise we must clear the interrupt.
	 */
	if ((dcm_cn->dcm_ic & IC_IE) == 0) {
		SEM_LOCK(dcm_cn);
		stat = dcm_cn->dcm_iir;
		SEM_UNLOCK(dcm_cn);
	}
	splx(s);
}
@


1.36
log
@Switch hp300 to timecounters. From NetBSD via martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.35 2010/07/02 17:27:01 nicm Exp $	*/
@


1.35
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.34 2010/06/28 14:13:27 deraadt Exp $	*/
d729 1
a729 1
	    (i = time.tv_sec - dis->dis_time) >= dcminterval) {
d753 1
a753 1
		dis->dis_time = time.tv_sec;
@


1.34
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.33 2010/04/12 12:57:51 tedu Exp $	*/
d1174 1
a1174 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state&TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.33
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.32 2009/11/09 17:53:38 nicm Exp $	*/
d456 1
a456 1
		tp = sc->sc_tty[port] = ttymalloc();
@


1.32
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.31 2009/10/31 12:00:05 fgsch Exp $	*/
d552 1
a552 1
		error = (*linesw[tp->t_line].l_open)(dev, tp);
d575 1
a575 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.31
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.30 2009/10/31 06:40:16 deraadt Exp $	*/
a1179 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.30
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.29 2008/01/23 16:37:56 jsing Exp $	*/
d485 1
a485 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
@


1.29
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.28 2006/01/01 11:59:37 miod Exp $	*/
d1180 1
@


1.28
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.27 2005/12/31 18:13:41 miod Exp $	*/
d1510 1
a1510 1
		pri = CN_NORMAL;
d1514 1
a1514 1
		pri = CN_REMOTE;
@


1.27
log
@Rework (once again) the console code, in order to match the PROM's logic better.
When not running on serial console, the PROM will pick the ``internal''
graphics device, and if it does not exist, the DIO device with the lowest
select code, and will resort to SGC devices if no internal or DIO device
was found.

However, the current logic would search for a certain frame buffer type first,
then for its best hardware location, following the order they are listed
in conf.c.

By replacing gazillions of almost-exactly-duplicated frame buffer code with
one single instance, which is device type-agnostic, we can match the PROM
(and the bootblocks) logic again. Plus this saves a few KB of code!
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.26 2005/12/30 18:14:09 miod Exp $	*/
a125 1
/* static	int dcm_lastcnpri = CN_DEAD; */	/* XXX last priority */
a1556 1
	cp->cn_pri = CN_DEAD;
@


1.26
log
@Kill conforced, and have console devices use CN_FORCED priority instead.
This means we are no longer aborting the console scans even if the final
console has been found, but on the other hand makes some logic simpler;
plus it will be necessary for upcoming scode vs device loop order reversal.
No user-visible change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.25 2005/12/30 18:03:33 miod Exp $	*/
d1560 1
a1560 1
	console_scan(dcm_console_scan, cp, HP300_BUS_DIO);
@


1.25
log
@When a driver claims console, let it set conscode to itself, instead of
letting the bus walkers do this for it. This is necessary since apci does
not use the bus walkers, now that we do not force console probes to stop
when apci claims console.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.24 2005/02/27 22:08:39 miod Exp $	*/
d1507 1
a1507 1
	int force = 0, pri;
d1526 2
a1527 4
	if (scode == CONSCODE) {
		pri = CN_REMOTE;
		force = conforced = 1;
	}
d1538 1
a1538 1
	if (((cn_tab == NULL) || (cp->cn_pri > cn_tab->cn_pri)) || force) {
a1558 4

	/* Abort early if console already forced. */
	if (conforced)
		return;
@


1.24
log
@Invoke hp300_cninit() twice, with a global variable letting the
console-dependent routines know which pass they are being invoked in.

The first pass is the usual console detection code. The second pass runs
after uvm is initialized, and will allow devices which need VM services to
run to claim the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.23 2005/02/12 18:01:08 miod Exp $	*/
d1542 1
@


1.23
log
@Use cons_decl() instead of rolling our own prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.22 2005/01/15 21:08:36 miod Exp $	*/
d1595 6
@


1.22
log
@Use DIO_SIZE() macro instead of rolling our own implementation of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.21 2005/01/14 22:39:25 miod Exp $	*/
d269 1
a269 4
void	dcmcnprobe(struct consdev *);
void	dcmcninit(struct consdev *);
int	dcmcngetc(dev_t);
void	dcmcnputc(dev_t, int);
@


1.21
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.20 2005/01/08 22:13:53 miod Exp $	*/
a1509 1
	u_char *dioiidev;
d1545 1
a1545 5
		if (scode >= 132) {
			dioiidev = (u_char *)va;
			return ((dioiidev[0x101] + 1) * 0x100000);
		}
		return (DIO_DEVSIZE);
@


1.20
log
@Only use one set of DIO size and address defines, from <dev/dioreg.h>
rather than <include/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.19 2004/09/29 07:35:52 miod Exp $	*/
d66 1
d560 1
a560 1
 
d571 1
a571 1
 
d600 1
a600 1
 
d620 1
a620 1
 
d656 1
a656 1
 
d696 1
a696 1
		       pcnd[2], pcnd[3]); 
d964 1
a964 1
 
d1140 1
a1140 1
 
d1267 1
a1267 1
 
d1287 1
a1287 1
 
d1467 1
a1467 1
	dcm->dcm_rsid = 0; 
d1573 1
a1573 1
	console_scan(dcm_console_scan, cp);
@


1.19
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.18 2004/09/19 21:34:42 mickey Exp $	*/
d1549 1
a1549 1
		return (DIOCSIZE);
@


1.18
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.17 2003/12/22 20:38:07 jmc Exp $	*/
d220 1
d356 5
a360 1
	(void) dio_intr_establish(dcmintr, sc, ipl, IPL_TTY);
d676 1
@


1.17
log
@typos from Jared Yanovich;
plus one more s/bufferd/buffered;
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.16 2003/10/03 16:44:49 miod Exp $	*/
d80 1
a80 1
struct speedtab dcmspeedtab[] = {
@


1.16
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.15 2003/08/15 20:32:13 tedu Exp $	*/
d1361 1
a1361 1
		printf("%s: dcmsetischeme: redundent request %d\n",
@


1.15
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.14 2003/06/02 23:27:44 millert Exp $	*/
a454 1
		tty_attach(tp);
a588 1
	tty_detach(tp);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.13 2002/03/14 01:26:30 millert Exp $	*/
d1034 1
a1034 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.12 2002/02/15 20:45:30 nordin Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.11 1997/09/14 03:43:03 downsj Exp $	*/
d254 21
a274 21
int	dcmintr __P((void *));
void	dcmpint __P((struct dcm_softc *, int, int));
void	dcmrint __P((struct dcm_softc *));
void	dcmreadbuf __P((struct dcm_softc *, int));
void	dcmxint __P((struct dcm_softc *, int));
void	dcmmint __P((struct dcm_softc *, int, int));

int	dcmparam __P((struct tty *, struct termios *));
void	dcmstart __P((struct tty *));
int	dcmstop __P((struct tty *, int));
int	dcmmctl __P((dev_t, int, int));
void	dcmsetischeme __P((int, int));
void	dcminit __P((struct dcmdevice *, int, int));

int	dcmselftest __P((struct dcm_softc *));

int	dcm_console_scan __P((int, caddr_t, void *));
void	dcmcnprobe __P((struct consdev *));
void	dcmcninit __P((struct consdev *));
int	dcmcngetc __P((dev_t));
void	dcmcnputc __P((dev_t, int));
d276 2
a277 2
int	dcmmatch __P((struct device *, void *, void *));
void	dcmattach __P((struct device *, struct device *, void *));
@


1.11
log
@callout support sync, from Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.10 1997/07/14 04:25:13 downsj Exp $	*/
d1342 1
a1342 1
		(void) splx(s);
@


1.11.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.11 1997/09/14 03:43:03 downsj Exp $	*/
d254 21
a274 21
int	dcmintr(void *);
void	dcmpint(struct dcm_softc *, int, int);
void	dcmrint(struct dcm_softc *);
void	dcmreadbuf(struct dcm_softc *, int);
void	dcmxint(struct dcm_softc *, int);
void	dcmmint(struct dcm_softc *, int, int);

int	dcmparam(struct tty *, struct termios *);
void	dcmstart(struct tty *);
int	dcmstop(struct tty *, int);
int	dcmmctl(dev_t, int, int);
void	dcmsetischeme(int, int);
void	dcminit(struct dcmdevice *, int, int);

int	dcmselftest(struct dcm_softc *);

int	dcm_console_scan(int, caddr_t, void *);
void	dcmcnprobe(struct consdev *);
void	dcmcninit(struct consdev *);
int	dcmcngetc(dev_t);
void	dcmcnputc(dev_t, int);
d276 2
a277 2
int	dcmmatch(struct device *, void *, void *);
void	dcmattach(struct device *, struct device *, void *);
d1342 1
a1342 1
		splx(s);
@


1.11.12.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1342 1
a1342 1
		splx(s);
@


1.11.12.2
log
@Merge in -current from about a week ago
@
text
@d254 6
a259 6
int	dcmintr(void *);
void	dcmpint(struct dcm_softc *, int, int);
void	dcmrint(struct dcm_softc *);
void	dcmreadbuf(struct dcm_softc *, int);
void	dcmxint(struct dcm_softc *, int);
void	dcmmint(struct dcm_softc *, int, int);
d261 6
a266 6
int	dcmparam(struct tty *, struct termios *);
void	dcmstart(struct tty *);
int	dcmstop(struct tty *, int);
int	dcmmctl(dev_t, int, int);
void	dcmsetischeme(int, int);
void	dcminit(struct dcmdevice *, int, int);
d268 1
a268 1
int	dcmselftest(struct dcm_softc *);
d270 5
a274 5
int	dcm_console_scan(int, caddr_t, void *);
void	dcmcnprobe(struct consdev *);
void	dcmcninit(struct consdev *);
int	dcmcngetc(dev_t);
void	dcmcnputc(dev_t, int);
d276 2
a277 2
int	dcmmatch(struct device *, void *, void *);
void	dcmattach(struct device *, struct device *, void *);
@


1.11.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.11.12.2 2002/03/28 10:07:18 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.12.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d455 1
d590 1
d1034 1
a1034 1
		error = suser(p, 0);
d1363 1
a1363 1
		printf("%s: dcmsetischeme: redundant request %d\n",
@


1.10
log
@cua devices for all!
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.9 1997/07/06 08:01:47 downsj Exp $	*/
d529 3
a531 3
		while (!(DCMCUA(dev) && sc->sc_cua) &&
		    (tp->t_cflag & CLOCAL) == 0 &&
		    (tp->t_state & TS_CARR_ON) == 0) {
d535 2
d543 2
@


1.9
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcm.c,v 1.8 1997/04/16 11:55:59 downsj Exp $	*/
d177 2
a178 1
#define DCMUNIT(x)		minor(x)
d230 1
d456 1
d462 1
d501 1
a501 1
	if ((sc->sc_softCAR & (1 << port)) ||
d505 9
d522 9
a530 2
	if ((flag & O_NONBLOCK) == 0)
		while ((tp->t_cflag & CLOCAL) == 0 &&
d536 2
d542 1
a542 1
	
d586 1
@


1.8
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: dcm.c,v 1.7 1997/02/03 04:47:15 downsj Exp $	*/
/*	$NetBSD: dcm.c,v 1.39 1997/04/14 02:33:17 thorpej Exp $	*/
d357 1
a357 1
	(void) intr_establish(dcmintr, sc, ipl, IPL_TTY);
d779 1
a779 1
	if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0)
@


1.7
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: dcm.c,v 1.6 1997/01/12 15:12:22 downsj Exp $	*/
/*	$NetBSD: dcm.c,v 1.35 1997/01/30 09:11:24 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995, 1996 Jason R. Thorpe.  All rights reserved.
d71 1
a78 1
#include <hp300/hp300/isr.h>
d85 16
a100 16
	0,	BR_0,
	50,	BR_50,
	75,	BR_75,
	110,	BR_110,
	134,	BR_134,
	150,	BR_150,
	300,	BR_300,
	600,	BR_600,
	1200,	BR_1200,
	1800,	BR_1800,
	2400,	BR_2400,
	4800,	BR_4800,
	9600,	BR_9600,
	19200,	BR_19200,
	38400,	BR_38400,
	-1,	-1
a127 1
static	int dcm_lastcnpri = CN_DEAD;		/* XXX last priority */
d129 1
d250 24
a284 8
int	dcmparam();
void	dcmstart();

void	dcminit __P((struct dcmdevice *, int, int));
int	dcmintr __P((void *));

int	dcmselftest __P((struct dcm_softc *));

d311 3
a313 1
	int i, mbits, ipl;
d340 5
a344 1
	if (dcmselftest(sc)) {
d351 1
a351 1
	sc->sc_flags = self->dv_cfdata->cf_flags & DCM_FLAGMASK;
d357 1
a357 1
	(void) isrlink(dcmintr, sc, ipl, ISRPRI_TTY);
d379 11
d582 1
a582 1
	register struct tty *tp;
d602 1
a602 1
	register struct tty *tp;
d642 1
a642 1
	 * Do all guarded register accesses right off to minimize
d739 1
d751 1
d761 1
a766 1
	struct tty *tp = sc->sc_tty[port];
d769 1
d778 4
d856 1
d861 5
a865 1
	struct tty *tp = sc->sc_tty[port];
d873 1
d883 2
d919 1
a919 1
	int cmd;
d939 1
a939 1
		printf("%s port %d: dcmioctl: cmd %x data %x flag %x\n",
d1036 2
a1037 2
	register struct tty *tp;
	register struct termios *t;
d1115 1
a1115 1
	register struct tty *tp;
d1226 1
a1226 1
		printf("%s port %d: dcmstart(%d): head %x tail %x outqcc %d\n",
d1243 1
a1243 1
void
d1245 1
a1245 1
	register struct tty *tp;
d1257 1
d1263 1
d1323 1
d1359 1
a1359 1
		register struct tty *tp;
d1431 2
a1432 2
	int i, timo = 0;
	int s, brd, mbits, rv;
d1625 1
a1625 1
	int s, unit, stat;
@


1.6
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: dcm.c,v 1.34 1996/12/17 08:41:01 thorpej Exp $	*/
a73 4
#ifndef NEWCONFIG
#include <hp300/dev/device.h>
#endif

a222 3
#ifndef NEWCONFIG
	struct	hp_device *sc_hd;	/* device info */
#endif
d250 1
a250 2
#ifdef NEWCONFIG
int	dcmmatch __P((struct device *, struct cfdata *, void *));
a259 11
#else /* ! NEWCONFIG */
int dcmmatch();
void dcmattach();

struct	driver dcmdriver = {
	dcmmatch, dcmattach, "dcm",
};

#include "dcm.h"
struct dcm_softc dcm_softc[NDCM];
#endif /* NEWCONFIG */
a268 1
#ifdef NEWCONFIG
d272 1
a272 2
	struct cfdata *match;
	void *aux;
a283 15
#else /* ! NEWCONFIG */
int
dcmmatch(hd)
	register struct hp_device *hd;
{
	struct dcm_softc *sc = &dcm_softc[hd->hp_unit];
	struct dcmdevice *dcm = (struct dcmdevice *)hd->hp_addr;

	if ((dcm->dcm_rsid & 0x1f) != DCMID)
		return (0);

	sc->sc_hd = hd;
	hd->hp_ipl = DCMIPL(dcm->dcm_ic);
}
#endif /* NEWCONFIG */
a284 1
#ifdef NEWCONFIG
a295 11
#else /* ! NEWCONFIG */
void
dcmattach(hd)
	register struct hp_device *hd;
{
	struct dcm_softc *sc = &dcm_softc[hd->hp_unit];
	struct dcmdevice *dcm = (struct dcmdevice *)hd->hp_addr;
	int brd = hd->hp_unit;
	int scode = hd->hp_args->hw_sc;
	int i, mbits, ipl = hd->hp_ipl;
#endif /* NEWCONFIG */
a307 1
#ifdef NEWCONFIG
a314 1
#endif
a318 1
#ifdef NEWCONFIG
a320 5
#else /* ! NEWCONFIG */
	/* XXX Set the device class. */
	hd->hp_dev.dv_class = DV_TTY;
	bcopy(&hd->hp_dev, &sc->sc_dev, sizeof(struct device));
#endif /* NEWCONFIG */
a327 1
#ifdef NEWCONFIG
a329 4
#else
	sc->sc_softCAR = (hd->hp_flags & DCM_SOFTCAR);
	sc->sc_flags = (hd->hp_flags & DCM_FLAGMASK);
#endif /* NEWCONFIG */
a413 1
#ifdef NEWCONFIG
a416 5
#else /* ! NEWCONFIG */
	if ((brd >= NDCM) || (port >= NDCMPORT))
		return (ENXIO);
	sc = &dcm_softc[brd];
#endif /* NEWCONFIG */
a515 1
#ifdef NEWCONFIG
a516 3
#else
	sc = &dcm_softc[board];
#endif
a554 1
#ifdef NEWCONFIG
a555 3
#else
	sc = &dcm_softc[board];
#endif
a574 1
#ifdef NEWCONFIG
a575 3
#else
	sc = &dcm_softc[board];
#endif
a591 1
#ifdef NEWCONFIG
a592 3
#else
	sc = &dcm_softc[board];
#endif
a884 1
#ifdef NEWCONFIG
a885 3
#else
	sc = &dcm_softc[board];
#endif
a999 1
#ifdef NEWCONFIG
a1000 3
#else
	sc = &dcm_softc[board];
#endif
a1086 1
#ifdef NEWCONFIG
a1087 3
#else
	sc = &dcm_softc[board];
#endif
a1225 1
#ifdef NEWCONFIG
a1226 3
#else
	sc = &dcm_softc[brd];
#endif
a1275 1
#ifdef NEWCONFIG
a1276 3
#else
	struct dcm_softc *sc = &dcm_softc[brd];
#endif
d1381 3
a1383 1
	int s, brd, mbits;
d1385 1
a1385 1
	s = spltty();
d1391 1
a1391 1
	while ((dcm->dcm_ic & IC_IR) == 0)
d1393 3
a1395 1
			return (1);
d1397 1
a1397 1
	while ((dcm->dcm_iir & IIR_SELFT) == 0)
d1399 3
a1401 1
			return (1);
d1409 1
a1409 1
		return (1);
d1412 3
d1416 1
a1416 2

	return (0);
@


1.5
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: dcm.c,v 1.27.4.1 1996/06/06 15:39:11 thorpej Exp $	*/
a52 2
#include "dcm.h"
#if NDCM > 0
d67 1
d74 1
d76 5
a87 6
int	dcmmatch(), dcmparam();
void	dcmattach(), dcmstart();
struct	driver dcmdriver = {
	dcmmatch, dcmattach, "dcm",
};

d226 2
d229 1
d255 27
a281 1
} dcm_softc[NDCM];
d286 20
d311 1
a311 3
	struct dcmdevice *dcm;
	int i, timo = 0;
	int s, brd, mbits;
a312 1
	dcm = (struct dcmdevice *)hd->hp_addr;
a315 2
	brd = hd->hp_unit;

a317 28

	/*
	 * Empirically derived self-test magic
	 */
	s = spltty();
	dcm->dcm_rsid = DCMRS;
	DELAY(50000);	/* 5000 is not long enough */
	dcm->dcm_rsid = 0; 
	dcm->dcm_ic = IC_IE;
	dcm->dcm_cr = CR_SELFT;
	while ((dcm->dcm_ic & IC_IR) == 0)
		if (++timo == 20000)
			return (0);
	DELAY(50000);	/* XXX why is this needed ???? */
	while ((dcm->dcm_iir & IIR_SELFT) == 0)
		if (++timo == 400000)
			return (0);
	DELAY(50000);	/* XXX why is this needed ???? */
	if (dcm->dcm_stcon != ST_OK) {
		if (hd->hp_args->hw_sc != conscode)
			printf("dcm%d: self test failed: %x\n",
			       brd, dcm->dcm_stcon);
		return (0);
	}
	dcm->dcm_ic = IC_ID;
	splx(s);

	return (1);
d319 1
d321 13
d339 5
a343 3
	struct dcmdevice *dcm;
	int i, timo = 0;
	int s, brd, mbits;
d345 2
a346 4
	dcm = sc->sc_dcm = (struct dcmdevice *)hd->hp_addr;

	brd = hd->hp_unit;
	if (hd->hp_args->hw_sc == conscode) {
d355 26
d384 4
d390 1
d396 1
a396 1
	isrlink(dcmintr, sc, hd->hp_ipl, ISRPRI_TTY);
d445 1
a445 1
				printf("%s port %d: ", sc->sc_hd->hp_xname,
d450 1
a450 1
				    sc->sc_hd->hp_xname,
d454 1
a454 1
#endif
d456 1
a456 1
#endif
d475 5
d482 2
a484 1
	sc = &dcm_softc[brd];
d538 1
a538 1
		       sc->sc_hd->hp_xname, port,
d560 1
a560 1
			sc->sc_hd->hp_xname, port, tp->t_state, tp->t_flags);
d583 3
d587 1
d600 1
a600 1
			sc->sc_hd->hp_xname, port, tp->t_state, tp->t_flags);
d626 3
d630 1
d650 3
d654 1
d671 3
d675 1
d687 1
a687 1
	int brd = sc->sc_hd->hp_unit;
d717 1
a717 1
		       sc->sc_hd->hp_xname, code, pcnd[0], pcnd[1],
d859 1
a859 1
			       sc->sc_hd->hp_xname, port,
d870 1
a870 1
				       sc->sc_hd->hp_xname, port,
d880 1
a880 1
				    sc->sc_hd->hp_xname, port);
d884 1
a884 1
				    sc->sc_hd->hp_xname, port);
d924 1
a924 1
		       sc->sc_hd->hp_xname, port, mcnd, sc->sc_mcndlast[port]);
d968 3
d972 1
d979 1
a979 1
		       sc->sc_hd->hp_xname, port, cmd, *data, flag);
d1087 3
d1091 1
d1130 1
a1130 1
		       sc->sc_hd->hp_xname, port, cflag, mode, tp->t_ospeed,
d1178 3
d1182 1
d1192 1
a1192 1
		       sc->sc_hd->hp_xname, port, tp->t_state, tp->t_flags,
d1274 1
a1274 1
		    sc->sc_hd->hp_xname, port, head, tail, tp->t_outq.c_cc);
d1290 1
a1290 1
int
d1320 4
d1325 1
d1331 1
a1331 1
		       sc->sc_hd->hp_xname, port, bits, how);
d1375 3
d1379 1
d1389 1
a1389 1
		       sc->sc_hd->hp_xname, perchar, dis->dis_perchar,
d1393 1
a1393 1
		       sc->sc_hd->hp_xname, perchar);
d1476 39
a1703 1
#endif /* NDCM > 0 */
@


1.4
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: dcm.c,v 1.26 1996/03/03 16:48:54 thorpej Exp $	*/
d287 1
a287 1
	DELAY(50000)	/* XXX why is this needed ???? */
d291 1
a291 1
	DELAY(50000)	/* XXX why is this needed ???? */
d421 1
a421 1
	if (sc->sc_tty[port] == NULL)
d423 2
a424 1
	else
d534 1
@


1.3
log
@from netbsd:
Re-work the serial console support a bit; it doesn't depend on statically
allocated softc's now.
@
text
@d1 1
a1 1
/*	$NetBSD: dcm.c,v 1.22 1995/12/31 00:27:21 thorpej Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Jason R. Thorpe.  All rights reserved.
d69 1
d82 1
a82 1
int	dcmmatch(), dcmintr(), dcmparam();
a133 5
#ifdef DCMCONSOLE
static	int dcmconsole = DCMCONSOLE;
#else
static	int dcmconsole = -1;
#endif
a230 1
	struct	isr sc_isr;		/* interrupt handler */
d245 1
d255 1
d264 1
a264 1
	int s, brd, isconsole, mbits;
a270 10
	isconsole = (brd == DCMBOARD(dcmconsole));

	/*
	 * XXX selected console device (CONSUNIT) as determined by
	 * dcmcnprobe does not agree with logical numbering imposed
	 * by the config file (i.e. lowest address DCM is not unit
	 * CONSUNIT).  Don't recognize this card.
	 */
	if (isconsole && (dcm != sc->sc_dcm))
		return (0);
d293 1
a293 1
		if (!isconsole)
d311 1
a311 1
	int s, brd, isconsole, mbits;
d316 10
a325 1
	isconsole = (brd == DCMBOARD(dcmconsole));
d335 1
a335 4
	sc->sc_isr.isr_ipl = hd->hp_ipl;
	sc->sc_isr.isr_arg = brd;
	sc->sc_isr.isr_intr = dcmintr;
	isrlink(&sc->sc_isr);
d360 1
a360 1
	 * Need to reset baud rate, etc. of next print so reset dcmconsole.
d363 1
a363 1
	if (isconsole) {
d365 2
a366 2
		sc->sc_softCAR |= (1 << DCMPORT(dcmconsole));
		printf(": console on port %d\n", DCMPORT(dcmconsole));
d373 1
a373 1
		if (dcmconsole == DCMUNIT(kgdb_dev))
d596 2
a597 2
dcmintr(brd)
	register int brd;
d599 1
a599 1
	struct dcm_softc *sc = &dcm_softc[brd];
d602 1
d968 2
a969 2
		    ((board == DCMBOARD(dcmconsole)) &&
		    (port == DCMPORT(dcmconsole))))
d1373 10
a1382 13
void
dcmcnprobe(cp)
	struct consdev *cp;
{
	struct dcm_softc *sc;	/* XXX thorpej */
	struct dcmdevice *dcm;
	struct hp_hw *hw;
	int unit;

	/* locate the major number */
	for (dcmmajor = 0; dcmmajor < nchrdev; dcmmajor++)
		if (cdevsw[dcmmajor].d_open == dcmopen)
			break;
a1383 19
	/*
	 * XXX FIX ME!
	 * Implicitly assigns the lowest select code DCM card found to be
	 * logical unit 0 (actually CONUNIT).  If your config file does
	 * anything different, you're screwed.
	 */
	for (hw = sc_table; hw->hw_type; hw++)
		if (HW_ISDEV(hw, D_COMMDCM) && !badaddr((short *)hw->hw_kva))
			break;
	if (!HW_ISDEV(hw, D_COMMDCM)) {
		cp->cn_pri = CN_DEAD;
		return;
	}

	unit = CONUNIT;
	dcm = (struct dcmdevice *)hw->hw_kva;

	/* initialize required fields */
	cp->cn_dev = makedev(dcmmajor, unit);
d1386 1
a1386 1
		cp->cn_pri = CN_NORMAL;
d1390 1
a1390 1
		cp->cn_pri = CN_REMOTE;
d1394 1
a1394 2
		cp->cn_pri = CN_DEAD;
		return;
d1397 1
d1399 1
a1399 1
	 * If dcmconsole is initialized, raise our priority.
d1401 9
a1409 2
	if (dcmconsole == unit)
		cp->cn_pri = CN_REMOTE;
d1413 1
a1413 2
	 * DCM, stash our priority and address, for the benefit of
	 * dcmcninit().
d1415 7
a1421 3
	if (cp->cn_pri > dcm_lastcnpri) {
		dcm_lastcnpri = cp->cn_pri;
		dcm_cn = dcm;
d1423 22
d1447 1
d1469 1
a1473 2
	int unit = DCMUNIT(cp->cn_dev);
	int port = DCMPORT(unit);
d1475 2
a1476 1
	dcminit(dcm_cn, port, dcmdefaultrate);
a1477 1
	dcmconsole = DCMUNIT(cp->cn_dev);
d1480 1
d1488 1
a1488 10
	int s, c, stat, unit, port;

	unit = DCMUNIT(dev);
	port = DCMPORT(unit);

	/*
	 * NOTE: This assumes that unit == dcmconsole.  If it doesn't,
	 * well, you lose.  (It's also extremely unlikely that will ever
	 * not be the case.)
	 */
d1490 1
a1490 1
	pp = dcm_preg(dcm_cn, port);
d1494 1
a1494 1
	fifo = &dcm_cn->dcm_rfifos[3-port][head>>1];
d1516 1
d1524 1
a1524 10
	int s, unit, port, stat;

	unit = DCMUNIT(dev);
	port = DCMPORT(unit);

	/*
	 * NOTE: This assumes that unit == dcmconsole.  If it doesn't,
	 * well, you lose.  (It's also extremely unlikely that will ever
	 * not be the case.)
	 */
d1526 1
a1526 1
	pp = dcm_preg(dcm_cn, port);
d1533 1
a1533 1
		dcminit(dcm_cn, port, dcmdefaultrate);
d1539 1
a1539 1
	dcm_cn->dcm_tfifos[3-port][tail].data_char = c;
d1542 2
a1543 2
	dcm_cn->dcm_cmdtab[port].dcm_data |= CT_TX;
	dcm_cn->dcm_cr |= (1 << port);
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: dcm.c,v 1.20 1995/12/02 18:18:50 thorpej Exp $	*/
d71 2
d127 2
a128 1
 * Console support
d130 3
d134 1
a134 1
int	dcmconsole = DCMCONSOLE;
d136 1
a136 1
int	dcmconsole = -1;
d138 1
a138 1
int	dcmconsinit;
d223 5
a227 1
#define	NDCMPORT	4	/* XXX what about 8-port cards? */
a240 1
	 * XXX What about 8-port cards?
d258 2
d388 2
a389 1
			(void) dcminit(kgdb_dev, kgdb_rate);
d443 1
a443 1
		dcminit(dev, dcmdefaultrate);
d1340 35
a1377 1
#include <dev/cons.h>
d1383 1
a1383 1
	struct dcm_softc *sc;
d1394 1
d1408 1
a1408 2
	sc = &dcm_softc[DCMBOARD(CONUNIT)];
	dcm = sc->sc_dcm = (struct dcmdevice *)hw->hw_kva;
d1431 11
d1449 1
a1449 1
		(void) dcminit(kgdb_dev, kgdb_rate);
d1468 2
d1471 1
a1471 1
	dcminit(cp->cn_dev, dcmdefaultrate);
a1475 43
dcminit(dev, rate)
	dev_t dev;
	int rate;
{
	struct dcm_softc *sc;
	struct dcmdevice *dcm;
	int s, mode, unit, board, port;

	unit = DCMUNIT(dev);
	board = DCMBOARD(unit);
	port = DCMPORT(unit);

	sc = &dcm_softc[board];
	dcm = sc->sc_dcm;

	mode = LC_8BITS | LC_1STOP;

	s = splhigh();

	/*
	 * Wait for transmitter buffer to empty.
	 */
	while (dcm->dcm_thead[port].ptr != dcm->dcm_ttail[port].ptr)
		DELAY(DCM_USPERCH(rate));

	/*
	 * Make changes known to hardware.
	 */
	dcm->dcm_data[port].dcm_baud = ttspeedtab(rate, dcmspeedtab);
	dcm->dcm_data[port].dcm_conf = mode;
	SEM_LOCK(dcm);
	dcm->dcm_cmdtab[port].dcm_data |= CT_CON;
	dcm->dcm_cr |= (1 << port);
	SEM_UNLOCK(dcm);

	/*
	 * Delay for config change to take place. Weighted by baud.
	 * XXX why do we do this?
	 */
	DELAY(16 * DCM_USPERCH(rate));
	splx(s);
}

a1479 2
	struct dcm_softc *sc;
	struct dcmdevice *dcm;
d1483 1
a1483 1
	int s, c, stat, unit, board, port;
a1485 1
	board = DCMBOARD(unit);
d1488 7
a1494 3
	sc = &dcm_softc[board];
	dcm = sc->sc_dcm;
	pp = dcm_preg(dcm, port);
d1498 1
a1498 1
	fifo = &dcm->dcm_rfifos[3-port][head>>1];
d1506 4
a1509 4
	SEM_LOCK(dcm);
	if ((dcm->dcm_ic & IC_IE) == 0)
		stat = dcm->dcm_iir;
	SEM_UNLOCK(dcm);
a1524 2
	struct dcm_softc *sc;
	struct dcmdevice *dcm;
d1527 1
a1527 1
	int s, unit, board, port, stat;
a1529 1
	board = DCMBOARD(unit);
d1532 7
a1538 3
	sc = &dcm_softc[board];
	dcm = sc->sc_dcm;
	pp = dcm_preg(dcm, port);
d1545 1
a1545 1
		(void) dcminit(dev, dcmdefaultrate);
d1551 1
a1551 1
	dcm->dcm_tfifos[3-port][tail].data_char = c;
d1553 4
a1556 4
	SEM_LOCK(dcm);
	dcm->dcm_cmdtab[port].dcm_data |= CT_TX;
	dcm->dcm_cr |= (1 << port);
	SEM_UNLOCK(dcm);
d1564 4
a1567 4
	if ((dcm->dcm_ic & IC_IE) == 0) {
		SEM_LOCK(dcm);
		stat = dcm->dcm_iir;
		SEM_UNLOCK(dcm);
d1571 1
a1571 1
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dcm.c,v 1.19 1995/10/04 08:39:14 thorpej Exp $	*/
d4 1
d79 2
a80 2
int	dcmprobe(), dcmintr(), dcmparam();
void	dcmstart();
d82 1
a82 1
	dcmprobe, "dcm",
a84 12
#define NDCMLINE (NDCM*4)

struct	tty *dcm_tty[NDCMLINE];
struct	modemreg *dcm_modem[NDCMLINE];
char	mcndlast[NDCMLINE];	/* XXX last modem status for line */
int	ndcm = NDCMLINE;

int	dcm_active;
int	dcmsoftCAR[NDCM];
struct	dcmdevice *dcm_addr[NDCM];
struct	isr dcmisr[NDCM];

d122 1
a122 1
} dcmischeme[NDCM];
d176 1
a176 1
} dcmstats[NDCM];
d179 3
a181 4
#define UNIT(x)		minor(x)
#define	BOARD(x)	(((x) >> 2) & 0x3f)
#define PORT(x)		((x) & 3)
#define MKUNIT(b,p)	(((b) << 2) | (p))
a207 1
#define	FLAG_STDDCE	0x10	/* map inputs if this bit is set in flags */
d217 34
a250 1
dcmprobe(hd)
d253 3
a255 3
	register struct dcmdevice *dcm;
	register int i;
	register int timo = 0;
d261 1
d263 2
a264 1
	isconsole = (brd == BOARD(dcmconsole));
d271 1
a271 1
	if (isconsole && dcm != dcm_addr[BOARD(dcmconsole)])
d274 3
d303 30
a332 29
	hd->hp_ipl = DCMIPL(dcm->dcm_ic);
	dcm_addr[brd] = dcm;
	dcm_active |= 1 << brd;
	dcmsoftCAR[brd] = hd->hp_flags;
	dcmisr[brd].isr_ipl = hd->hp_ipl;
	dcmisr[brd].isr_arg = brd;
	dcmisr[brd].isr_intr = dcmintr;
	isrlink(&dcmisr[brd]);
#ifdef KGDB
	if (major(kgdb_dev) == dcmmajor && BOARD(kgdb_dev) == brd) {
		if (dcmconsole == UNIT(kgdb_dev))
			kgdb_dev = NODEV; /* can't debug over console port */
#ifndef KGDB_CHEAT
		/*
		 * The following could potentially be replaced
		 * by the corresponding code in dcmcnprobe.
		 */
		else {
			(void) dcminit(kgdb_dev, kgdb_rate);
			if (kgdb_debug_init) {
				printf("dcm%d: ", UNIT(kgdb_dev));
				kgdb_connect(1);
			} else
				printf("dcm%d: kgdb enabled\n", UNIT(kgdb_dev));
		}
		/* end could be replaced */
#endif
	}
#endif
d339 5
a343 4
	dcm_modem[MKUNIT(brd, 0)] = &dcm->dcm_modem0;
	dcm_modem[MKUNIT(brd, 1)] = &dcm->dcm_modem1;
	dcm_modem[MKUNIT(brd, 2)] = &dcm->dcm_modem2;
	dcm_modem[MKUNIT(brd, 3)] = &dcm->dcm_modem3;
d345 1
a345 1
	if (dcmsoftCAR[brd] & FLAG_STDDCE)
d349 3
a351 2
	for (i = 0; i < 4; i++)
		dcm_modem[MKUNIT(brd, i)]->mdmmsk = mbits;
d354 1
d361 28
a388 2
		dcmsoftCAR[brd] |= (1 << PORT(dcmconsole));
		printf("dcm%d: console on port %d\n", brd, PORT(dcmconsole));
d390 1
a390 1
	return (1);
d400 3
a402 2
	register struct tty *tp;
	register int unit, brd;
d405 5
a409 3
	unit = UNIT(dev);
	brd = BOARD(unit);
	if (unit >= NDCMLINE || (dcm_active & (1 << brd)) == 0)
d411 7
a417 2
	if (!dcm_tty[unit])
		tp = dcm_tty[unit] = ttymalloc();
d419 2
a420 1
		tp = dcm_tty[unit];
d452 1
a452 1
	if (dcmsoftCAR[brd] & FLAG_STDDCE)
d454 1
d458 1
a458 1
	if ((dcmsoftCAR[brd] & (1 << PORT(unit))) ||
d464 3
a466 2
		printf("dcm%d: dcmopen port %d softcarr %c\n",
		       brd, unit, (tp->t_state & TS_CARR_ON) ? '1' : '0');
d486 2
a487 2
		printf("dcmopen: u %x st %x fl %x\n",
			unit, tp->t_state, tp->t_flags);
d502 3
a504 2
	register struct tty *tp;
	int s, unit;
d506 7
a512 2
	unit = UNIT(dev);
	tp = dcm_tty[unit];
d522 2
a523 2
		printf("dcmclose: u %x st %x fl %x\n",
			unit, tp->t_state, tp->t_flags);
d529 1
a529 1
	dcm_tty[unit] = (struct tty *)0;
d540 10
a549 1
	register struct tty *tp = dcm_tty[UNIT(dev)];
d560 10
a569 1
	register struct tty *tp = dcm_tty[UNIT(dev)];
d578 2
d581 7
a587 1
	return (dcm_tty[UNIT(dev)]);
d594 4
a597 4
	register struct dcmdevice *dcm = dcm_addr[brd];
	register struct dcmischeme *dis;
	register int unit = MKUNIT(brd, 0);
	register int code, i;
d612 2
a613 2
		code = dcm_modem[unit+i]->mdmin;
		if (dcmsoftCAR[brd] & FLAG_STDDCE)
d625 3
a627 2
		printf("dcmintr(%d): iir %x pc %x/%x/%x/%x ",
		       brd, code, pcnd[0], pcnd[1], pcnd[2], pcnd[3]); 
d633 1
a633 1
		dcmrint(brd, dcm);
d635 1
a635 1
		dcmpint(unit+0, pcnd[0], dcm);
d637 1
a637 1
		dcmpint(unit+1, pcnd[1], dcm);
d639 1
a639 1
		dcmpint(unit+2, pcnd[2], dcm);
d641 1
a641 1
		dcmpint(unit+3, pcnd[3], dcm);
d644 1
a644 1
			dcmmint(unit+0, mcnd[0], dcm);
d646 1
a646 1
			dcmmint(unit+1, mcnd[1], dcm);
d648 1
a648 1
			dcmmint(unit+2, mcnd[2], dcm);
d650 1
a650 1
			dcmmint(unit+3, mcnd[3], dcm);
a652 1
	dis = &dcmischeme[brd];
d685 1
a685 1
			dcmrint(brd, dcm);
d698 3
a700 3
dcmpint(unit, code, dcm)
	int unit, code;
	struct dcmdevice *dcm;
a701 1
	struct tty *tp = dcm_tty[unit];
d704 1
a704 1
		dcmreadbuf(unit, dcm, tp);
d706 1
a706 1
		dcmxint(unit, dcm, tp);
d709 2
a710 3
dcmrint(brd, dcm)
	int brd;
	register struct dcmdevice *dcm;
d712 1
a712 2
	register int i, unit;
	register struct tty *tp;
d714 2
a715 4
	unit = MKUNIT(brd, 0);
	tp = dcm_tty[unit];
	for (i = 0; i < 4; i++, tp++, unit++)
		dcmreadbuf(unit, dcm, tp);
d718 3
a720 4
dcmreadbuf(unit, dcm, tp)
	int unit;
	register struct dcmdevice *dcm;
	register struct tty *tp;
d722 6
a727 5
	int port = PORT(unit);
	register struct dcmpreg *pp = dcm_preg(dcm, port);
	register struct dcmrfifo *fifo;
	register int c, stat;
	register unsigned head;
d730 1
a730 1
	struct dcmstats *dsp = &dcmstats[BOARD(unit)];
d736 1
a736 1
		if ((makedev(dcmmajor, unit) == kgdb_dev) &&
d767 3
a769 2
			printf("dcmreadbuf(%d): c%x('%c') s%x f%x h%x t%x\n",
			       unit, c&0xFF, c, stat&0xFF,
d778 3
a780 2
				printf("dcmreadbuf(%d): err: c%x('%c') s%x\n",
				       unit, stat, c&0xFF, c);
d788 2
a789 1
				    "dcm%d: silo overflow\n", unit);
d792 2
a793 1
				    "dcm%d: uart overflow\n", unit);
d797 2
a798 1
	dcmischeme[BOARD(unit)].dis_char += nch;
d808 3
a810 4
dcmxint(unit, dcm, tp)
	int unit;
	struct dcmdevice *dcm;
	register struct tty *tp;
d812 2
d820 3
a822 4
dcmmint(unit, mcnd, dcm)
	register int unit;
	register struct dcmdevice *dcm;
        int mcnd;
a823 1
	register struct tty *tp;
d825 4
d832 2
a833 2
		printf("dcmmint: port %d mcnd %x mcndlast %x\n",
		       unit, mcnd, mcndlast[unit]);
d835 2
a836 3
	tp = dcm_tty[unit];
	delta = mcnd ^ mcndlast[unit];
	mcndlast[unit] = mcnd;
d848 1
a848 1
		else if ((dcmsoftCAR[BOARD(unit)] & (1 << PORT(unit))) == 0 &&
d850 1
a850 1
			dcm_modem[unit]->mdmout = MO_OFF;
d852 1
a852 1
			dcm->dcm_modemchng |= 1<<(unit & 3);
d868 4
a871 4
	register struct tty *tp;
	register int unit = UNIT(dev);
	register struct dcmdevice *dcm;
	register int board, port;
d873 7
d883 2
a884 2
		printf("dcmioctl: unit %d cmd %x data %x flag %x\n",
		       unit, cmd, *data, flag);
a885 1
	tp = dcm_tty[unit];
a892 3
	port = PORT(unit);
	board = BOARD(unit);
	dcm = dcm_addr[board];
d942 1
a942 1
		if ((dcmsoftCAR[board] & (1 << port)))
d962 3
a964 3
		    ((board == BOARD(dcmconsole)) &&
		    (port == PORT(dcmconsole))))
			dcmsoftCAR[board] |= (1 << port);
d983 3
a985 2
	register struct dcmdevice *dcm;
	register int port, mode, cflag = t->c_cflag;
d988 7
d1003 1
a1003 1
		(void) dcmmctl(UNIT(tp->t_dev), MO_OFF, DMSET);
d1030 2
a1031 2
		printf("dcmparam(%d): cflag %x mode %x speed %d uperch %d\n",
		       UNIT(tp->t_dev), cflag, mode, tp->t_ospeed,
a1034 2
	port = PORT(tp->t_dev);
	dcm = dcm_addr[BOARD(tp->t_dev)];
d1061 7
a1067 7
	register struct dcmdevice *dcm;
	register struct dcmpreg *pp;
	register struct dcmtfifo *fifo;
	register char *bp;
	register unsigned tail, next;
	register int port, nch;
	unsigned head;
d1071 1
a1071 1
	struct dcmstats *dsp = &dcmstats[BOARD(tp->t_dev)];
d1075 7
d1088 2
a1089 2
		printf("dcmstart(%d): state %x flags %x outcc %d\n",
		       UNIT(tp->t_dev), tp->t_state, tp->t_flags,
a1107 2
	dcm = dcm_addr[BOARD(tp->t_dev)];
	port = PORT(tp->t_dev);
d1170 2
a1171 2
		printf("dcmstart(%d): head %x tail %x outqcc %d\n",
		       UNIT(tp->t_dev), head, tail, tp->t_outq.c_cc);
d1210 9
a1218 2
	register struct dcmdevice *dcm;
	int s, unit, brd, hit = 0;
a1219 1
	unit = UNIT(dev);
d1222 2
a1223 2
		printf("dcmmctl(%d) unit %d  bits 0x%x how %x\n",
		       BOARD(unit), unit, bits, how);
a1225 2
	brd = BOARD(unit);
	dcm = dcm_addr[brd];
d1227 1
a1228 1

d1230 1
a1230 1
		dcm_modem[unit]->mdmout = bits;
d1235 1
a1235 1
		dcm_modem[unit]->mdmout |= bits;
d1240 1
a1240 1
		dcm_modem[unit]->mdmout &= ~bits;
d1245 2
a1246 2
		bits = dcm_modem[unit]->mdmin;
		if (dcmsoftCAR[brd] & FLAG_STDDCE)
d1267 4
a1270 3
	register struct dcmdevice *dcm = dcm_addr[brd];
	register struct dcmischeme *dis = &dcmischeme[brd];
	register int i;
d1276 2
a1277 2
		printf("dcmsetischeme(%d, %d): cur %d, ints %d, chars %d\n",
		       brd, perchar, dis->dis_perchar,
d1280 2
a1281 2
		printf("dcmsetischeme(%d):  redundent request %d\n",
		       brd, perchar);
d1299 1
a1299 1
		register struct tty *tp = dcm_tty[MKUNIT(brd, 0)];
d1302 3
a1304 1
		for (i = 0; i < 4; i++, tp++) {
d1337 3
a1339 1
	register struct hp_hw *hw;
d1359 1
d1361 2
a1362 1
	dcm_addr[BOARD(CONUNIT)] = (struct dcmdevice *)hw->hw_kva;
d1366 1
a1366 1
	switch (dcm_addr[BOARD(unit)]->dcm_rsid) {
d1370 1
d1374 1
d1379 1
d1383 1
a1383 1
	if (dcmconsole == UNIT(unit))
d1390 2
a1391 1
	if (major(kgdb_dev) == dcmmajor && BOARD(kgdb_dev) == BOARD(unit)) {
d1400 1
a1400 1
			printf("dcm%d: ", UNIT(kgdb_dev));
d1411 1
d1414 1
a1414 1
	dcmconsole = UNIT(cp->cn_dev);
d1421 10
a1430 2
	register struct dcmdevice *dcm = dcm_addr[BOARD(dev)];
	int s, mode, port;
a1431 1
	port = PORT(dev);
d1433 1
d1435 1
d1441 1
d1451 1
d1464 10
a1473 5
	register struct dcmdevice *dcm = dcm_addr[BOARD(dev)];
	register struct dcmrfifo *fifo;
	register struct dcmpreg *pp;
	register unsigned head;
	int s, c, stat, port;
d1475 2
a1476 1
	port = PORT(dev);
d1478 1
d1508 3
a1510 2
	register struct dcmdevice *dcm = dcm_addr[BOARD(dev)];
	register struct dcmpreg *pp;
d1512 1
a1512 1
	int s, port, stat;
d1514 6
a1519 1
	port = PORT(dev);
d1521 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
