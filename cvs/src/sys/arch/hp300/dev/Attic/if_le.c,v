head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.36
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.34
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.32
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.30
	OPENBSD_5_0:1.17.0.28
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.26
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.24
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.20
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.22
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.18
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.16
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.14
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.12
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.12.0.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.12
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.10
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.8
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.18;

1.18
date	2013.09.24.20.10.44;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.26.00.15.37;	author miod;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	98.09.16.22.41.17;	author jason;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	97.08.08.08.26.31;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.07.06.08.01.54;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.04.16.11.56.10;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.03.07.23.44.40;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.02.03.04.47.35;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.12.15.12.46;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.11.47.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.25.06.36.42;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.15.50.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.20;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: if_le.c,v 1.18 2013/09/24 20:10:44 miod Exp $	*/
/*	$NetBSD: if_le.c,v 1.43 1997/05/05 21:05:32 thorpej Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <net/if_media.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/ic/lancereg.h>
#include <dev/ic/lancevar.h>
#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>
#include <hp300/dev/if_lereg.h>
#include <hp300/dev/if_levar.h>

#ifdef USELEDS
#include <hp300/hp300/leds.h>
#endif

int	lematch(struct device *, void *, void *);
void	leattach(struct device *, struct device *, void *);

struct cfattach le_ca = {
	sizeof(struct le_softc), lematch, leattach
};

int	leintr(void *);

/* offsets for:	   ID,   REGS,    MEM,  NVRAM */
const int lestd[] = { 0, 0x4000, 0x8000, 0xC008 };

void lewrcsr(struct lance_softc *, uint16_t, uint16_t);
uint16_t lerdcsr(struct lance_softc *, uint16_t);

void
lewrcsr(struct lance_softc *sc, uint16_t port, uint16_t val)
{
	struct lereg0 *ler0 = ((struct le_softc *)sc)->sc_r0;
	struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;

	do {
		ler1->ler1_rap = port;
	} while ((ler0->ler0_status & LE_ACK) == 0);
	do {
		ler1->ler1_rdp = val;
	} while ((ler0->ler0_status & LE_ACK) == 0);
}

uint16_t
lerdcsr(struct lance_softc *sc, uint16_t port)
{
	struct lereg0 *ler0 = ((struct le_softc *)sc)->sc_r0;
	struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
	uint16_t val;

	do {
		ler1->ler1_rap = port;
	} while ((ler0->ler0_status & LE_ACK) == 0);
	do {
		val = ler1->ler1_rdp;
	} while ((ler0->ler0_status & LE_ACK) == 0);
	return (val);
}

int
lematch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct dio_attach_args *da = aux;

	if ((da->da_id == DIO_DEVICE_ID_LAN) ||
	    (da->da_id == DIO_DEVICE_ID_LANREM))
		return (1);
	return (0);
}

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
void
leattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct lereg0 *ler0;
	struct dio_attach_args *da = aux;
	struct le_softc *lesc = (struct le_softc *)self;
	caddr_t addr;
	struct lance_softc *sc = &lesc->sc_am7990.lsc;
	char *cp;
	int i, ipl;

	addr = iomap(dio_scodetopa(da->da_scode), da->da_size);
	if (addr == 0) {
		printf("\n%s: can't map LANCE registers\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	ler0 = lesc->sc_r0 = (struct lereg0 *)(lestd[0] + (int)addr);
	ler0->ler0_id = 0xFF;
	DELAY(100);

	ipl = DIO_IPL(addr);
	printf(" ipl %d", ipl);

	lesc->sc_r1 = (struct lereg1 *)(lestd[1] + (int)addr);
	sc->sc_mem = (void *)(lestd[2] + (int)addr);
	sc->sc_conf3 = LE_C3_BSWP;
	sc->sc_addr = 0;
	sc->sc_memsize = 16384;

	/*
	 * Read the ethernet address off the board, one nibble at a time.
	 */
	cp = (char *)(lestd[3] + (int)addr);
	for (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++) {
		sc->sc_arpcom.ac_enaddr[i] = (*++cp & 0xF) << 4;
		cp++;
		sc->sc_arpcom.ac_enaddr[i] |= *++cp & 0xF;
		cp++;
	}

	sc->sc_copytodesc = lance_copytobuf_contig;
	sc->sc_copyfromdesc = lance_copyfrombuf_contig;
	sc->sc_copytobuf = lance_copytobuf_contig;
	sc->sc_copyfrombuf = lance_copyfrombuf_contig;
	sc->sc_zerobuf = lance_zerobuf_contig;

	sc->sc_rdcsr = lerdcsr;
	sc->sc_wrcsr = lewrcsr;
	sc->sc_hwreset = NULL;
	sc->sc_hwinit = NULL;

	am7990_config(&lesc->sc_am7990);

	/* Establish the interrupt handler. */
	lesc->sc_isr.isr_func = leintr;
	lesc->sc_isr.isr_arg = lesc;
	lesc->sc_isr.isr_ipl = ipl;
	lesc->sc_isr.isr_priority = IPL_NET;
	dio_intr_establish(&lesc->sc_isr, self->dv_xname);
	ler0->ler0_status = LE_IE;
}

int
leintr(arg)
	void *arg;
{
	struct le_softc *lesc = (struct le_softc *)arg;
	struct lance_softc *sc = &lesc->sc_am7990.lsc;
#ifdef USELEDS
	uint16_t isr;

	isr = lerdcsr(sc, LE_CSR0);

	if ((isr & LE_C0_INTR) == 0)
		return (0);

	if (isr & LE_C0_RINT)
		ledcontrol(0, 0, LED_LANRCV);

	if (isr & LE_C0_TINT)
		ledcontrol(0, 0, LED_LANXMT);
#endif /* USELEDS */

	return am7990_intr(sc);
}
@


1.18
log
@Sync the MI LANCE code ( le(4) ) with NetBSD, except for the following:
- the am7990_get() - now lance_get() - is unchanged.
- the interrupt acknowledge logic is unchanged, and will disable interrupts,
  then acknowledge all interrupt conditions.

Add ILACC (79900) support (from NetBSD).

Both LANCE (am7990.c) and ILACC (am79900.c) code share as much common code
(lance.c) as possible. This affects all le(4) attachments, but the changes
are mostly mechanical, to split am7990-specific parts from lance-agnostic
parts.

Compile tested on all affected platforms. Tested on alpha, hp300, luna88k,
mvme88k, sparc, sparc64 and vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.17 2005/01/15 21:13:08 miod Exp $	*/
@


1.17
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.16 2004/09/29 07:35:52 miod Exp $	*/
d61 2
d86 1
a86 1
int	lestd[] = { 0, 0x4000, 0x8000, 0xC008 };
d88 2
a89 2
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);
d91 2
a92 4
hide void
lewrcsr(sc, port, val)
	struct am7990_softc *sc;
	u_int16_t port, val;
d105 2
a106 4
hide u_int16_t
lerdcsr(sc, port)
	struct am7990_softc *sc;
	u_int16_t port;
d110 1
a110 1
	u_int16_t val;
d148 1
a148 1
	struct am7990_softc *sc = &lesc->sc_am7990;
d183 5
a187 5
	sc->sc_copytodesc = am7990_copytobuf_contig;
	sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
	sc->sc_copytobuf = am7990_copytobuf_contig;
	sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
	sc->sc_zerobuf = am7990_zerobuf_contig;
d194 1
a194 1
	am7990_config(sc);
d210 1
a210 1
	struct am7990_softc *sc = &lesc->sc_am7990;
d212 1
a212 1
	u_int16_t isr;
@


1.16
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.15 2003/06/02 23:27:45 millert Exp $	*/
d87 1
a87 1
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);  
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.14 2002/03/14 01:26:30 millert Exp $	*/
d199 5
a203 1
	(void) dio_intr_establish(leintr, sc, ipl, IPL_NET);
d211 2
a212 1
	struct am7990_softc *sc = arg;
d228 1
a228 1
	return (am7990_intr(sc));
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.13 2001/08/26 00:15:37 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@Nuke annoying defopt, by popular demand. Plus you get two typos fixed
for free.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 1998/09/16 22:41:17 jason Exp $	*/
d78 2
a79 2
int	lematch __P((struct device *, void *, void *));
void	leattach __P((struct device *, struct device *, void *));
d85 1
a85 1
int	leintr __P((void *));
d90 2
a91 2
hide void lewrcsr __P((struct am7990_softc *, u_int16_t, u_int16_t));
hide u_int16_t lerdcsr __P((struct am7990_softc *, u_int16_t));  
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.13 2001/08/26 00:15:37 miod Exp $	*/
d78 2
a79 2
int	lematch(struct device *, void *, void *);
void	leattach(struct device *, struct device *, void *);
d85 1
a85 1
int	leintr(void *);
d90 2
a91 2
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);  
@


1.12
log
@o if_media'fied am7990
o if_media'fied sun4m le.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.11 1997/08/08 08:26:31 downsj Exp $	*/
a73 1
#include "opt_useleds.h"
@


1.12.8.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 1998/09/16 22:41:17 jason Exp $	*/
d74 1
@


1.12.8.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 2
a79 2
int	lematch(struct device *, void *, void *);
void	leattach(struct device *, struct device *, void *);
d85 1
a85 1
int	leintr(void *);
d90 2
a91 2
hide void lewrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
hide u_int16_t lerdcsr(struct am7990_softc *, u_int16_t);  
@


1.12.8.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12.8.2 2002/03/28 10:07:18 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11
log
@Initialize hwreset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.10 1997/07/06 08:01:54 downsj Exp $	*/
d58 2
@


1.10
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.9 1997/04/16 11:56:10 downsj Exp $	*/
d196 1
@


1.9
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_le.c,v 1.8 1997/03/07 23:44:40 downsj Exp $	*/
/*	$NetBSD: if_le.c,v 1.41 1997/04/14 02:33:20 thorpej Exp $	*/
a62 4
#ifdef USELEDS
#include <hp300/hp300/led.h>
#endif

d72 5
d201 1
a201 1
	(void) intr_establish(leintr, sc, ipl, IPL_NET);
d210 1
a212 1
#ifdef USELEDS
d219 1
a219 2
		if (inledcontrol == 0)
			ledcontrol(0, 0, LED_LANRCV);
d222 1
a222 2
		if (inledcontrol == 0)
			ledcontrol(0, 0, LED_LANXMT);
@


1.8
log
@Support LAN cards with the REM bit set.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_le.c,v 1.7 1997/02/03 04:47:35 downsj Exp $	*/
/*	$NetBSD: if_le.c,v 1.37 1997/01/30 09:18:53 thorpej Exp $	*/
d61 1
a61 3
#include <machine/mtpr.h>

#include <hp300/hp300/isr.h>
d96 2
a97 2
	register struct lereg0 *ler0 = ((struct le_softc *)sc)->sc_r0;
	register struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
d112 2
a113 2
	register struct lereg0 *ler0 = ((struct le_softc *)sc)->sc_r0;
	register struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
d148 1
a148 1
	register struct lereg0 *ler0;
d200 1
a200 1
	(void) isrlink(leintr, sc, ipl, ISRPRI_NET);
@


1.7
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.6 1997/01/12 15:12:46 downsj Exp $	*/
d134 2
a135 1
	if (da->da_id == DIO_DEVICE_ID_LAN)
@


1.6
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: if_le.c,v 1.36 1996/12/17 08:41:13 thorpej Exp $	*/
a68 4
#ifndef NEWCONFIG
#include <hp300/dev/device.h>
#endif

d78 1
a78 2
#ifdef NEWCONFIG
int	lematch __P((struct device *, struct cfdata *, void *));
a83 11
#else /* ! NEWCONFIG */
#include "le.h"
struct	le_softc le_softc[NLE];

int	lematch __P((struct hp_device *));
void	leattach __P((struct hp_device *));

struct	driver ledriver = {
	lematch, leattach, "le",
};
#endif /* NEWCONFIG */
a126 1
#ifdef NEWCONFIG
d130 1
a130 2
	struct cfdata *match;
	void *aux;
a137 18
#else /* ! NEWCONFIG */
int
lematch(hd)
	struct hp_device *hd;
{
	register struct lereg0 *ler0;
	struct le_softc *lesc = &le_softc[hd->hp_unit];

	ler0 = (struct lereg0 *)(lestd[0] + (int)hd->hp_addr);
	if (ler0->ler0_id != LEID)
		return (0);

	hd->hp_ipl = LE_IPL(ler0->ler0_status);
	lesc->sc_hd = hd;

	return (1);
}
#endif /* NEWCONFIG */
a143 1
#ifdef NEWCONFIG
a147 5
#else /* ! NEWCONFIG */
void
leattach(hd)
	struct hp_device *hd;
#endif /* NEWCONFIG */
a149 1
#ifdef NEWCONFIG
a152 4
#else
	struct le_softc *lesc = &le_softc[hd->hp_unit];
	caddr_t addr = hd->hp_addr;
#endif /* NEWCONFIG */
a156 1
#ifdef NEWCONFIG
a162 1
#endif /* NEWCONFIG */
a167 1
#ifdef NEWCONFIG
a169 6
#else /* ! NEWCONFIG */
	/* XXXX kluge for now */
	hd->hp_dev.dv_class = DV_IFNET;
	bcopy(&hd->hp_dev, &sc->sc_dev, sizeof(struct device));
	ipl = hd->hp_ipl;
#endif /* NEWCONFIG */
@


1.5
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: if_le.c,v 1.31 1996/05/09 21:11:47 thorpej Exp $	*/
d59 1
d69 1
d71 1
d76 3
d82 8
a94 1
int	leintr __P((void *));
d99 3
d143 14
d173 1
d180 6
d189 1
d192 5
d198 2
d202 10
a211 1
	int i;
d213 1
a213 1
	ler0 = lesc->sc_r0 = (struct lereg0 *)(lestd[0] + (int)hd->hp_addr);
d217 4
d222 4
a225 2
	sc->sc_dev.dv_unit = hd->hp_unit;
	sprintf(sc->sc_dev.dv_xname, "%s%d", le_cd.cd_name, hd->hp_unit);
d227 2
a228 2
	lesc->sc_r1 = (struct lereg1 *)(lestd[1] + (int)hd->hp_addr);
	sc->sc_mem = (void *)(lestd[2] + (int)hd->hp_addr);
d236 1
a236 1
	cp = (char *)(lestd[3] + (int)hd->hp_addr);
d257 1
a257 1
	isrlink(leintr, sc, hd->hp_ipl, ISRPRI_NET);
@


1.4
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.29 1996/04/22 02:30:45 christos Exp $	*/
d68 4
a73 3
#include <dev/ic/am7990reg.h>
#define	LE_NEED_BUF_CONTIG
#include <dev/ic/am7990var.h>
a77 3
#define	LE_SOFTC(unit)	&le_softc[unit]
#define	LE_DELAY(x)	DELAY(x)

a80 1
static	int hp300_leintr __P((void *));	/* machine-dependent wrapper */
d89 2
a90 5
integrate void
lehwinit(sc)
	struct le_softc *sc;
{
}
d92 1
a92 1
integrate void
d94 1
a94 1
	struct le_softc *sc;
d97 2
a98 2
	register struct lereg0 *ler0 = sc->sc_r0;
	register struct lereg1 *ler1 = sc->sc_r1;
d108 1
a108 1
integrate u_int16_t
d110 1
a110 1
	struct le_softc *sc;
d113 2
a114 2
	register struct lereg0 *ler0 = sc->sc_r0;
	register struct lereg1 *ler1 = sc->sc_r1;
d131 1
a131 1
	struct le_softc *sc = LE_SOFTC(hd->hp_unit);
d138 1
a138 1
	sc->sc_hd = hd;
d153 2
a154 1
	struct le_softc *sc = LE_SOFTC(hd->hp_unit);
d158 1
a158 1
	ler0 = sc->sc_r0 = (struct lereg0 *)(lestd[0] + (int)hd->hp_addr);
d164 1
a164 1
	sprintf(sc->sc_dev.dv_xname, "%s%d", ledriver.d_name, hd->hp_unit);
d166 1
a166 1
	sc->sc_r1 = (struct lereg1 *)(lestd[1] + (int)hd->hp_addr);
d189 5
a193 2
	sc->sc_arpcom.ac_if.if_name = ledriver.d_name;
	leconfig(sc);
d196 1
a196 1
	isrlink(hp300_leintr, sc, hd->hp_ipl, ISRPRI_NET);
d200 2
a201 2
static int
hp300_leintr(arg)
d204 1
a204 1
	struct le_softc *sc = arg;
d222 1
a222 1
	return (leintr(sc));
a223 2
		
#include <dev/ic/am7990.c>
@


1.3
log
@from netbsd; wrap leintr() to support fake LAN lights
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.26 1996/01/02 21:56:21 thorpej Exp $	*/
d83 1
a83 1
static	int hp300_leintr __P((int));	/* machine-dependent wrapper */
d93 6
d188 5
a192 5
	sc->sc_copytodesc = copytobuf_contig;
	sc->sc_copyfromdesc = copyfrombuf_contig;
	sc->sc_copytobuf = copytobuf_contig;
	sc->sc_copyfrombuf = copyfrombuf_contig;
	sc->sc_zerobuf = zerobuf_contig;
d197 2
a198 4
	sc->sc_isr.isr_intr = hp300_leintr;
	sc->sc_isr.isr_arg = hd->hp_unit;
	sc->sc_isr.isr_ipl = hd->hp_ipl;
	isrlink(&sc->sc_isr);
d203 2
a204 2
hp300_leintr(unit)
	int unit;
d206 1
a206 1
	struct le_softc *sc = LE_SOFTC(unit);
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.24 1995/12/10 00:49:33 mycroft Exp $	*/
d62 1
a78 1
#define	LEINTR_UNIT
d82 2
a83 1
int	leintr __P((int));
d191 1
a191 1
	sc->sc_isr.isr_intr = leintr;
d198 25
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.22 1995/08/04 08:08:41 thorpej Exp $	*/
d3 7
a9 3
/*
 * Copyright (c) 1982, 1990 The Regents of the University of California.
 * All rights reserved.
d39 1
a39 1
 *	@@(#)if_le.c	7.6 (Berkeley) 5/8/91
a41 3
#include "le.h"
#if NLE > 0

a43 3
/*
 * AMD 7990 LANCE
 */
a45 1
#include <sys/kernel.h>
d47 1
a47 1
#include <sys/buf.h>
d49 1
a49 4
#include <sys/syslog.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/errno.h>
a51 6
#include <net/netisr.h>
#include <net/route.h>
#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif
a54 3
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
a57 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d60 1
d68 4
d73 2
d76 7
a82 3
#define	ETHER_MIN_LEN	64
#define	ETHER_MAX_LEN	1518
#define	ETHER_ADDR_LEN	6
d84 3
d91 1
a91 51
struct	isr le_isr[NLE];

/*
 * Ethernet software status per interface.
 *
 * Each interface is referenced by a network interface structure,
 * arpcom.ac_if, which the routing code uses to locate the interface.
 * This structure contains the output queue for the interface, its address, ...
 */
struct	le_softc {
	struct	arpcom sc_arpcom;	/* common Ethernet structures */
	struct	lereg0 *sc_r0;		/* DIO registers */
	struct	lereg1 *sc_r1;		/* LANCE registers */
	void	*sc_mem;
	struct	init_block *sc_init;
	struct	mds *sc_rd, *sc_td;
	u_char	*sc_rbuf, *sc_tbuf;
	int	sc_last_rd, sc_last_td;
	int	sc_no_td;
#ifdef LEDEBUG
	int	sc_debug;
#endif
} le_softc[NLE];

int leintr __P((int));
int leioctl __P((struct ifnet *, u_long, caddr_t));
void lestart __P((struct ifnet *));
void lewatchdog __P((int));
static inline void lewrcsr __P((/* struct le_softc *, u_short, u_short */));
static inline u_short lerdcsr __P((/* struct le_softc *, u_short */));
void leinit __P((struct le_softc *));
void lememinit __P((struct le_softc *));
void lereset __P((struct le_softc *));
void lestop __P((struct le_softc *));
void letint __P((int));
void lerint __P((int));
void leread __P((struct le_softc *, u_char *, int));
struct mbuf *leget __P((u_char *, int, struct ifnet *));
#ifdef LEDEBUG
void recv_print __P((struct le_softc *, int));
void xmit_print __P((struct le_softc *, int));
#endif
void lesetladrf __P((struct arpcom *, u_long *));

int leattach __P((struct hp_device *));

struct	driver ledriver = {
	leattach, "le",
};

static inline void
d94 1
a94 2
	register u_short port;
	register u_short val;
d107 1
a107 1
static inline u_short
d110 1
a110 1
	register u_short port;
d114 1
a114 1
	register u_short val;
d125 17
d147 1
a147 1
int
d152 1
a152 2
	struct le_softc *sc = &le_softc[hd->hp_unit];
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d157 7
a163 2
	if (ler0->ler0_id != LEID)
		return(0);
d166 3
a168 5
	le_isr[hd->hp_unit].isr_intr = leintr;
	hd->hp_ipl = le_isr[hd->hp_unit].isr_ipl = LE_IPL(ler0->ler0_status);
	le_isr[hd->hp_unit].isr_arg = hd->hp_unit;
	ler0->ler0_id = 0xFF;
	DELAY(100);
a179 2
	printf("le%d: hardware address %s\n", hd->hp_unit,
		ether_sprintf(sc->sc_arpcom.ac_enaddr));
d181 13
a193 1
	isrlink(&le_isr[hd->hp_unit]);
a194 832

	ifp->if_unit = hd->hp_unit;
	ifp->if_name = "le";
	ifp->if_output = ether_output;
	ifp->if_start = lestart;
	ifp->if_ioctl = leioctl;
	ifp->if_watchdog = lewatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;

	if_attach(ifp);
	ether_ifattach(ifp);

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
	return (1);
}

void
lereset(sc)
	struct le_softc *sc;
{

	leinit(sc);
}

void
lewatchdog(unit)
	int unit;
{
	struct le_softc *sc = &le_softc[unit];

	log(LOG_ERR, "le%d: device timeout\n", unit);
	++sc->sc_arpcom.ac_if.if_oerrors;

	lereset(sc);
}

#define	LANCE_ADDR(sc, a) \
	((u_long)(a) - (u_long)sc->sc_mem)

/* LANCE initialization block set up. */
void
lememinit(sc)
	register struct le_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int i;
	void *mem;
	u_long a;

	/*
	 * At this point we assume that the memory allocated to the Lance is
	 * quadword aligned.  If it isn't then the initialisation is going
	 * fail later on.
	 */
	mem = sc->sc_mem;

	sc->sc_init = mem;
#if NBPFILTER > 0
	if (ifp->if_flags & IFF_PROMISC)
		sc->sc_init->mode = LE_NORMAL | LE_PROM;
	else
#endif
		sc->sc_init->mode = LE_NORMAL;
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc->sc_init->padr[i] = sc->sc_arpcom.ac_enaddr[i^1];
	lesetladrf(&sc->sc_arpcom, sc->sc_init->ladrf);
	mem += sizeof(struct init_block);

	sc->sc_rd = mem;
	a = LANCE_ADDR(sc, mem);
	sc->sc_init->rdra = a;
	sc->sc_init->rlen = ((a >> 16) & 0xff) | (RLEN << 13);
	mem += NRBUF * sizeof(struct mds);

	sc->sc_td = mem;
	a = LANCE_ADDR(sc, mem);
	sc->sc_init->tdra = a;
	sc->sc_init->tlen = ((a >> 16) & 0xff) | (TLEN << 13);
	mem += NTBUF * sizeof(struct mds);

	/* 
	 * Set up receive ring descriptors.
	 */
	sc->sc_rbuf = mem;
	for (i = 0; i < NRBUF; i++) {
		a = LANCE_ADDR(sc, mem);
		sc->sc_rd[i].addr = a;
		sc->sc_rd[i].flags = ((a >> 16) & 0xff) | LE_OWN;
		sc->sc_rd[i].bcnt = -BUFSIZE;
		sc->sc_rd[i].mcnt = 0;
		mem += BUFSIZE;
	}

	/* 
	 * Set up transmit ring descriptors.
	 */
	sc->sc_tbuf = mem;
	for (i = 0; i < NTBUF; i++) {
		a = LANCE_ADDR(sc, mem);
		sc->sc_td[i].addr = a;
		sc->sc_td[i].flags= ((a >> 16) & 0xff);
		sc->sc_td[i].bcnt = 0xf000;
		sc->sc_td[i].mcnt = 0;
		mem += BUFSIZE;
	}
}

void
lestop(sc)
	struct le_softc *sc;
{

	lewrcsr(sc, 0, LE_STOP);
}

/*
 * Initialization of interface; set up initialization block
 * and transmit/receive descriptor rings.
 */
void
leinit(sc)
	register struct le_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s;
	register int timo;
	u_long a;

	s = splimp();

	/* Don't want to get in a weird state. */
	lewrcsr(sc, 0, LE_STOP);
	DELAY(100);

	sc->sc_last_rd = sc->sc_last_td = sc->sc_no_td = 0;

	/* Set up LANCE init block. */
	lememinit(sc);

	/* Turn on byte swapping. */
	lewrcsr(sc, 3, LE_BSWP);

	/* Give LANCE the physical address of its init block. */
	a = LANCE_ADDR(sc, sc->sc_init);
	lewrcsr(sc, 1, a);
	lewrcsr(sc, 2, (a >> 16) & 0xff);

	/* Try to initialize the LANCE. */
	DELAY(100);
	lewrcsr(sc, 0, LE_INIT);

	/* Wait for initialization to finish. */
	for (timo = 100000; timo; timo--)
		if (lerdcsr(sc, 0) & LE_IDON)
			break;

	if (lerdcsr(sc, 0) & LE_IDON) {
		/* Start the LANCE. */
		lewrcsr(sc, 0, LE_INEA | LE_STRT | LE_IDON);
		ifp->if_flags |= IFF_RUNNING;
		ifp->if_flags &= ~IFF_OACTIVE;
		lestart(ifp);
	} else
		printf("le%d: card failed to initialize\n", ifp->if_unit);

	(void) splx(s);
}

/*
 * Controller interrupt.
 */
int
leintr(unit)
	int unit;
{
	register struct le_softc *sc = &le_softc[unit];
	register u_short isr;

	isr = lerdcsr(sc, 0);
#ifdef LEDEBUG
	if (sc->sc_debug)
		printf("le%d: leintr entering with isr=%04x\n",
		    unit, isr);
#endif
	if ((isr & LE_INTR) == 0)
		return 0;

	do {
		lewrcsr(sc, 0,
		    isr & (LE_INEA | LE_BABL | LE_MISS | LE_MERR |
			   LE_RINT | LE_TINT | LE_IDON));
		if (isr & (LE_BABL | LE_CERR | LE_MISS | LE_MERR)) {
			if (isr & LE_BABL) {
				printf("le%d: BABL\n", unit);
				sc->sc_arpcom.ac_if.if_oerrors++;
			}
#if 0
			if (isr & LE_CERR) {
				printf("le%d: CERR\n", unit);
				sc->sc_arpcom.ac_if.if_collisions++;
			}
#endif
			if (isr & LE_MISS) {
#if 0
				printf("le%d: MISS\n", unit);
#endif
				sc->sc_arpcom.ac_if.if_ierrors++;
			}
			if (isr & LE_MERR) {
				printf("le%d: MERR\n", unit);
				lereset(sc);
				goto out;
			}
		}

		if ((isr & LE_RXON) == 0) {
			printf("le%d: receiver disabled\n", unit);
			sc->sc_arpcom.ac_if.if_ierrors++;
			lereset(sc);
			goto out;
		}
		if ((isr & LE_TXON) == 0) {
			printf("le%d: transmitter disabled\n", unit);
			sc->sc_arpcom.ac_if.if_oerrors++;
			lereset(sc);
			goto out;
		}

		if (isr & LE_RINT) {
			/* Reset watchdog timer. */
			sc->sc_arpcom.ac_if.if_timer = 0;
			lerint(unit);
		}
		if (isr & LE_TINT) {
			/* Reset watchdog timer. */
			sc->sc_arpcom.ac_if.if_timer = 0;
			letint(unit);
		}

		isr = lerdcsr(sc, 0);
	} while ((isr & LE_INTR) != 0);

#ifdef LEDEBUG
	if (sc->sc_debug)
		printf("le%d: leintr returning with isr=%04x\n",
		    unit, isr);
#endif

out:
	return 1;
}

#define NEXTTDS \
	if (++tmd == NTBUF) tmd=0, cdm=sc->sc_td; else ++cdm
	
/*
 * Setup output on interface.
 * Get another datagram to send off of the interface queue, and map it to the
 * interface before starting the output.
 * Called only at splimp or interrupt level.
 */
void
lestart(ifp)
	struct ifnet *ifp;
{
	register struct le_softc *sc = &le_softc[ifp->if_unit];
	register int tmd;
	struct mds *cdm;
	struct mbuf *m0, *m;
	u_char *buffer;
	int len;

	if ((sc->sc_arpcom.ac_if.if_flags & (IFF_RUNNING | IFF_OACTIVE)) !=
	    IFF_RUNNING)
		return;

	tmd = sc->sc_last_td;
	cdm = &sc->sc_td[tmd];

	for (;;) {
		if (sc->sc_no_td >= NTBUF) {
			sc->sc_arpcom.ac_if.if_flags |= IFF_OACTIVE;
#ifdef LEDEBUG
			if (sc->sc_debug)
				printf("no_td = %d, last_td = %d\n", sc->sc_no_td,
				    sc->sc_last_td);
#endif
			break;
		}

#ifdef LEDEBUG
		if (cdm->flags & LE_OWN) {
			sc->sc_arpcom.ac_if.if_flags |= IFF_OACTIVE;
			printf("missing buffer, no_td = %d, last_td = %d\n",
			    sc->sc_no_td, sc->sc_last_td);
		}
#endif

		IF_DEQUEUE(&sc->sc_arpcom.ac_if.if_snd, m);
		if (!m)
			break;

		++sc->sc_no_td;

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		buffer = sc->sc_tbuf + (BUFSIZE * sc->sc_last_td);
		len = 0;
		for (m0 = m; m; m = m->m_next) {
			bcopy(mtod(m, caddr_t), buffer, m->m_len);
			buffer += m->m_len;
			len += m->m_len;
		}

#ifdef LEDEBUG
		if (len > ETHER_MAX_LEN)
			printf("packet length %d\n", len);
#endif

#if NBPFILTER > 0
		if (sc->sc_arpcom.ac_if.if_bpf)
			bpf_mtap(sc->sc_arpcom.ac_if.if_bpf, m0);
#endif

		m_freem(m0);
		len = max(len, ETHER_MIN_LEN);

		/*
		 * Init transmit registers, and set transmit start flag.
		 */
		cdm->bcnt = -len;
		cdm->mcnt = 0;
		cdm->flags |= LE_OWN | LE_STP | LE_ENP;

#ifdef LEDEBUG
		if (sc->sc_debug)
			xmit_print(sc, sc->sc_last_td);
#endif
		
		lewrcsr(sc, 0, LE_INEA | LE_TDMD);

		NEXTTDS;
	}

	sc->sc_last_td = tmd;
}

void
letint(unit)
	int unit;
{
	register struct le_softc *sc = &le_softc[unit];
	register int tmd = (sc->sc_last_td - sc->sc_no_td + NTBUF) % NTBUF;
	struct mds *cdm = &sc->sc_td[tmd];

#ifdef USELEDS
	if (inledcontrol == 0)
		ledcontrol(0, 0, LED_LANXMT);
#endif

	if (cdm->flags & LE_OWN) {
		/* Race condition with loop below. */
#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("le%d: extra tint\n", unit);
#endif
		return;
	}

	sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;

	do {
		if (sc->sc_no_td <= 0)
			break;
#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("trans cdm = %x\n", cdm);
#endif
		sc->sc_arpcom.ac_if.if_opackets++;
		--sc->sc_no_td;
		if (cdm->mcnt & (LE_TBUFF | LE_UFLO | LE_LCOL | LE_LCAR | LE_RTRY)) {
			if (cdm->mcnt & LE_TBUFF)
				printf("le%d: TBUFF\n", unit);
			if ((cdm->mcnt & (LE_TBUFF | LE_UFLO)) == LE_UFLO)
				printf("le%d: UFLO\n", unit);
			if (cdm->mcnt & LE_UFLO) {
				lereset(sc);
				return;
			}
#if 0
			if (cdm->mcnt & LE_LCOL) {
				printf("le%d: late collision\n", unit);
				sc->sc_arpcom.ac_if.if_collisions++;
			}
			if (cdm->mcnt & LE_LCAR)
				printf("le%d: lost carrier\n", unit);
			if (cdm->mcnt & LE_RTRY) {
				printf("le%d: excessive collisions, tdr %d\n",
				    unit, cdm->mcnt & 0x1ff);
				sc->sc_arpcom.ac_if.if_collisions += 16;
			}
#endif
		} else if (cdm->flags & LE_ONE)
			sc->sc_arpcom.ac_if.if_collisions++;
		else if (cdm->flags & LE_MORE)
			/* Real number is unknown. */
			sc->sc_arpcom.ac_if.if_collisions += 2;
		NEXTTDS;
	} while ((cdm->flags & LE_OWN) == 0);

	lestart(&sc->sc_arpcom.ac_if);
}

#define NEXTRDS \
	if (++rmd == NRBUF) rmd=0, cdm=sc->sc_rd; else ++cdm
	
/* only called from one place, so may as well integrate */
void
lerint(unit)
	int unit;
{
	register struct le_softc *sc = &le_softc[unit];
	register int rmd = sc->sc_last_rd;
	struct mds *cdm = &sc->sc_rd[rmd];

#ifdef USELEDS
	if (inledcontrol == 0)
		ledcontrol(0, 0, LED_LANRCV);
#endif

	if (cdm->flags & LE_OWN) {
		/* Race condition with loop below. */
#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("le%d: extra rint\n", unit);
#endif
		return;
	}

	/* Process all buffers with valid data. */
	do {
		if (cdm->flags & (LE_FRAM | LE_OFLO | LE_CRC | LE_RBUFF)) {
			if ((cdm->flags & (LE_FRAM | LE_OFLO | LE_ENP)) == (LE_FRAM | LE_ENP))
				printf("le%d: FRAM\n", unit);
			if ((cdm->flags & (LE_OFLO | LE_ENP)) == LE_OFLO)
				printf("le%d: OFLO\n", unit);
			if ((cdm->flags & (LE_CRC | LE_OFLO | LE_ENP)) == (LE_CRC | LE_ENP))
				printf("le%d: CRC\n", unit);
			if (cdm->flags & LE_RBUFF)
				printf("le%d: RBUFF\n", unit);
		} else if (cdm->flags & (LE_STP | LE_ENP) != (LE_STP | LE_ENP)) {
			do {
				cdm->mcnt = 0;
				cdm->flags |= LE_OWN;
				NEXTRDS;
			} while ((cdm->flags & (LE_OWN | LE_ERR | LE_STP | LE_ENP)) == 0);
			sc->sc_last_rd = rmd;
			printf("le%d: chained buffer\n", unit);
			if ((cdm->flags & (LE_OWN | LE_ERR | LE_STP | LE_ENP)) != LE_ENP) {
				lereset(sc);
				return;
			}
		} else {
#ifdef LEDEBUG
			if (sc->sc_debug)
				recv_print(sc, sc->sc_last_rd);
#endif
			leread(sc, sc->sc_rbuf + (BUFSIZE * rmd),
			    (int)cdm->mcnt);
			sc->sc_arpcom.ac_if.if_ipackets++;
		}
			
		cdm->mcnt = 0;
		cdm->flags |= LE_OWN;
		NEXTRDS;
#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("sc->sc_last_rd = %x, cdm = %x\n",
			    sc->sc_last_rd, cdm);
#endif
	} while ((cdm->flags & LE_OWN) == 0);

	sc->sc_last_rd = rmd;
}

/*
 * Pass a packet to the higher levels.
 */
void
leread(sc, buf, len)
	register struct le_softc *sc;
	u_char *buf;
	int len;
{
	struct ifnet *ifp;
	struct mbuf *m;
	struct ether_header *eh;

	len -= 4;
	if (len <= 0)
		return;

	/* Pull packet off interface. */
	ifp = &sc->sc_arpcom.ac_if;
	m = leget(buf, len, ifp);
	if (m == 0)
		return;

	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf) {
		bpf_mtap(ifp->if_bpf, m);

		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
			    sizeof(eh->ether_dhost)) != 0) {
			m_freem(m);
			return;
		}
	}
#endif

	/* We assume that the header fit entirely in one mbuf. */
	m->m_pkthdr.len -= sizeof(*eh);
	m->m_len -= sizeof(*eh);
	m->m_data += sizeof(*eh);

	ether_input(ifp, eh, m);
}

/*
 * Supporting routines
 */

/*
 * Pull data off an interface.
 * Len is length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present
 * we copy into clusters.
 */
struct mbuf *
leget(buf, totlen, ifp)
	u_char *buf;
	int totlen;
	struct ifnet *ifp;
{
	struct mbuf *top, **mp, *m;
	int len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return 0;
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	len = MHLEN;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return 0;
			}
			len = MLEN;
		}
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy((caddr_t)buf, mtod(m, caddr_t), len);
		buf += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return top;
}

/*
 * Process an ioctl request.
 */
int
leioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct le_softc *sc = &le_softc[ifp->if_unit];
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splimp();

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			leinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif
#ifdef NS
		/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			leinit(sc);
			break;
		    }
#endif
		default:
			leinit(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		/*
		 * If interface is marked down and it is running, then stop it
		 */
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			lestop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			leinit(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			/*lestop(sc);*/
			leinit(sc);
		}
#ifdef LEDEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = 1;
		else
			sc->sc_debug = 0;
#endif
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom):
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			leinit(sc);
			error = 0;
		}
		break;

	default:
		error = EINVAL;
	}
	(void) splx(s);
	return error;
}

#ifdef LEDEBUG
void
recv_print(sc, no)
	struct le_softc *sc;
	int no;
{
	struct mds *rmd;
	int i, printed = 0;
	u_short len;
	
	rmd = &sc->sc_rd[no];
	len = rmd->mcnt;
	printf("%s: receive buffer %d, len = %d\n", sc->sc_dev.dv_xname, no,
	    len);
	printf("%s: status %x\n", sc->sc_dev.dv_xname, lerdcsr(sc, 0));
	for (i = 0; i < len; i++) {
		if (!printed) {
			printed = 1;
			printf("%s: data: ", sc->sc_dev.dv_xname);
		}
		printf("%x ", *(sc->sc_rbuf + (BUFSIZE*no) + i));
	}
	if (printed)
		printf("\n");
}
		
void
xmit_print(sc, no)
	struct le_softc *sc;
	int no;
{
	struct mds *rmd;
	int i, printed=0;
	u_short len;
	
	rmd = &sc->sc_td[no];
	len = -rmd->bcnt;
	printf("%s: transmit buffer %d, len = %d\n", sc->sc_dev.dv_xname, no,
	    len);
	printf("%s: status %x\n", sc->sc_dev.dv_xname, lerdcsr(sc, 0));
	printf("%s: addr %x, flags %x, bcnt %x, mcnt %x\n",
	    sc->sc_dev.dv_xname, rmd->addr, rmd->flags, rmd->bcnt, rmd->mcnt);
	for (i = 0; i < len; i++)  {
		if (!printed) {
			printed = 1;
			printf("%s: data: ", sc->sc_dev.dv_xname);
		}
		printf("%x ", *(sc->sc_tbuf + (BUFSIZE*no) + i));
	}
	if (printed)
		printf("\n");
}
#endif /* LEDEBUG */

/*
 * Set up the logical address filter.
 */
void
lesetladrf(ac, af)
	struct arpcom *ac;
	u_long *af;
{
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	register u_char *cp, c;
	register u_long crc;
	register int i, len;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		af[0] = af[1] = 0xffffffff;
		return;
	}

	af[0] = af[1] = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    sizeof(enm->enm_addrlo)) != 0) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			af[0] = af[1] = 0xffffffff;
			return;
		}

		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			c = *cp++;
			for (i = 8; --i >= 0;) {
				if ((crc & 0x01) ^ (c & 0x01)) {
					crc >>= 1;
					crc ^= 0x6db88320 | 0x80000000;
				} else
					crc >>= 1;
				c >>= 1;
			}
		}
		/* Just want the 6 most significant bits. */
		crc >>= 26;

		/* Turn on the corresponding bit in the filter. */
		af[crc >> 5] |= 1 << ((crc & 0x1f) ^ 16);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
d197 1
a197 1
#endif /* NLE > 0 */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
