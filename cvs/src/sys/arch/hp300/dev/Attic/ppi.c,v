head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.20
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.16
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.12
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.10
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.8
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.16
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.14
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.17;

1.17
date	2009.07.30.20.32.44;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.13.20.08.12;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.19.23.54.41;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.14.19.23.40;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.13.23.13.25;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.05.23.26;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.01.16.51.10;	author millert;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2000.07.06.15.42.48;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	97.04.16.11.56.14;	author downsj;	state Exp;
branches
	1.6.14.1;
next	1.5;

1.5
date	97.02.03.04.47.41;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.12.15.12.57;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.51;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.21;	author deraadt;	state Exp;
branches;
next	;

1.6.14.1
date	2001.04.18.16.05.36;	author niklas;	state Exp;
branches;
next	1.6.14.2;

1.6.14.2
date	2001.07.04.10.15.32;	author niklas;	state Exp;
branches;
next	1.6.14.3;

1.6.14.3
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.6.14.4;

1.6.14.4
date	2003.03.27.23.19.20;	author niklas;	state Exp;
branches;
next	1.6.14.5;

1.6.14.5
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: ppi.c,v 1.17 2009/07/30 20:32:44 blambert Exp $	*/
/*	$NetBSD: ppi.c,v 1.13 1997/04/02 22:37:33 scottr Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ppi.c	8.1 (Berkeley) 6/16/93
 */

/*
 * Printer/Plotter HPIB interface
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/timeout.h>
#include <sys/uio.h>

#include <hp300/dev/hpibvar.h>

#include <hp300/dev/ppiioctl.h>

struct	ppi_softc {
	struct device sc_dev;
	int	sc_flags;
	struct	hpibqueue sc_hq;	/* HP-IB job queue entry */
	struct	ppiparam sc_param;
#define sc_burst sc_param.burst
#define sc_timo  sc_param.timo
#define sc_delay sc_param.delay
	int	sc_sec;
	int	sc_slave;		/* HP-IB slave address */
	struct timeout sc_to;		/* ppitimo timeout */
	struct timeout sc_start_to;	/* ppistart timeout */
};

/* sc_flags values */
#define	PPIF_ALIVE	0x01
#define	PPIF_OPEN	0x02
#define PPIF_UIO	0x04
#define PPIF_TIMO	0x08
#define PPIF_DELAY	0x10

int	ppimatch(struct device *, void *, void *);
void	ppiattach(struct device *, struct device *, void *);

struct cfattach ppi_ca = {
	sizeof(struct ppi_softc), ppimatch, ppiattach
};

struct cfdriver ppi_cd = {
	NULL, "ppi", DV_DULL
};

void	ppistart(void *);
void	ppinoop(void *);

void	ppitimo(void *);
int	ppirw(dev_t, struct uio *);

cdev_decl(ppi);

#define UNIT(x)		minor(x)

#ifdef DEBUG
int	ppidebug = 0x80;
#define PDB_FOLLOW	0x01
#define PDB_IO		0x02
#define PDB_NOCHECK	0x80
#endif

int
ppimatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct hpibbus_attach_args *ha = aux;

	/*
	 * The printer/plotter doesn't return an ID tag.
	 * The check below prevents us from matching a CS80
	 * device by mistake.
	 */
	if (ha->ha_id & 0x200)
		return (0);

	/*
	 * To prevent matching all unused slots on the bus, we
	 * don't allow wildcarded locators.
	 */
	if (cf->hpibbuscf_slave == HPIBBUS_SLAVE_UNK ||
	    cf->hpibbuscf_punit == HPIBBUS_PUNIT_UNK)
		return (0);

	return (1);
}

void
ppiattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ppi_softc *sc = (struct ppi_softc *)self;
	struct hpibbus_attach_args *ha = aux;

	printf("\n");

	sc->sc_slave = ha->ha_slave;

	/* Initialize the hpib queue entry. */
	sc->sc_hq.hq_softc = sc;
	sc->sc_hq.hq_slave = sc->sc_slave;
	sc->sc_hq.hq_start = ppistart;
	sc->sc_hq.hq_go = ppinoop;
	sc->sc_hq.hq_intr = ppinoop;

	sc->sc_flags = PPIF_ALIVE;

	/* Initialize timeout structures */
	timeout_set(&sc->sc_to, ppitimo, sc);
	timeout_set(&sc->sc_start_to, ppistart, sc);
}

void
ppinoop(arg)
	void *arg;
{
	/* Noop! */
}

int
ppiopen(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
{
	int unit = UNIT(dev);
	struct ppi_softc *sc;

	if (unit >= ppi_cd.cd_ndevs ||
	    (sc = ppi_cd.cd_devs[unit]) == NULL ||
	    (sc->sc_flags & PPIF_ALIVE) == 0)
		return (ENXIO);

#ifdef DEBUG
	if (ppidebug & PDB_FOLLOW)
		printf("ppiopen(%x, %x): flags %x\n",
		       dev, flags, sc->sc_flags);
#endif
	if (sc->sc_flags & PPIF_OPEN)
		return (EBUSY);
	sc->sc_flags |= PPIF_OPEN;
	sc->sc_burst = PPI_BURST;
	sc->sc_timo = PPI_TIMO;
	sc->sc_delay = PPI_DELAY;
	sc->sc_sec = -1;
	return(0);
}

int
ppiclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
{
	int unit = UNIT(dev);
	struct ppi_softc *sc = ppi_cd.cd_devs[unit];

#ifdef DEBUG
	if (ppidebug & PDB_FOLLOW)
		printf("ppiclose(%x, %x): flags %x\n",
		       dev, flags, sc->sc_flags);
#endif
	sc->sc_flags &= ~PPIF_OPEN;
	return(0);
}

void
ppistart(arg)
	void *arg;
{
	struct ppi_softc *sc = arg;

#ifdef DEBUG
	if (ppidebug & PDB_FOLLOW)
		printf("ppistart(%x)\n", sc->sc_dev.dv_unit);
#endif
	sc->sc_flags &= ~PPIF_DELAY;
	wakeup(sc);
}

void
ppitimo(arg)
	void *arg;
{
	struct ppi_softc *sc = arg;

#ifdef DEBUG
	if (ppidebug & PDB_FOLLOW)
		printf("ppitimo(%x)\n", sc->sc_dev.dv_unit);
#endif
	sc->sc_flags &= ~(PPIF_UIO|PPIF_TIMO);
	wakeup(sc);
}

int
ppiread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

#ifdef DEBUG
	if (ppidebug & PDB_FOLLOW)
		printf("ppiread(%x, %p)\n", dev, uio);
#endif
	return (ppirw(dev, uio));
}

int
ppiwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

#ifdef DEBUG
	if (ppidebug & PDB_FOLLOW)
		printf("ppiwrite(%x, %p)\n", dev, uio);
#endif
	return (ppirw(dev, uio));
}

int
ppirw(dev, uio)
	dev_t dev;
	struct uio *uio;
{
	int unit = UNIT(dev);
	struct ppi_softc *sc = ppi_cd.cd_devs[unit];
	int s, len, cnt;
	char *cp;
	int error = 0, gotdata = 0;
	int buflen, ctlr, slave;
	char *buf;

	if (uio->uio_resid == 0)
		return(0);

	ctlr = sc->sc_dev.dv_parent->dv_unit;
	slave = sc->sc_slave;

#ifdef DEBUG
	if (ppidebug & (PDB_FOLLOW|PDB_IO))
		printf("ppirw(%x, %p, %c): burst %d, timo %d, resid %x\n",
		       dev, uio, uio->uio_rw == UIO_READ ? 'R' : 'W',
		       sc->sc_burst, sc->sc_timo, uio->uio_resid);
#endif
	buflen = min(sc->sc_burst, uio->uio_resid);
	buf = (char *)malloc(buflen, M_DEVBUF, M_WAITOK);
	sc->sc_flags |= PPIF_UIO;
	if (sc->sc_timo > 0) {
		sc->sc_flags |= PPIF_TIMO;
		timeout_add_msec(&sc->sc_to, sc->sc_timo);
	}
	len = cnt = 0;
	while (uio->uio_resid > 0) {
		len = min(buflen, uio->uio_resid);
		cp = buf;
		if (uio->uio_rw == UIO_WRITE) {
			error = uiomove(cp, len, uio);
			if (error)
				break;
		}
again:
		s = splbio();
		if ((sc->sc_flags & PPIF_UIO) &&
		    hpibreq(sc->sc_dev.dv_parent, &sc->sc_hq) == 0)
			tsleep(sc, PRIBIO+1, "ppirw", 0);
		/*
		 * Check if we timed out during sleep or uiomove
		 */
		if ((sc->sc_flags & PPIF_UIO) == 0) {
#ifdef DEBUG
			if (ppidebug & PDB_IO)
				printf("ppirw: uiomove/sleep timo, flags %x\n",
				       sc->sc_flags);
#endif
			if (sc->sc_flags & PPIF_TIMO) {
				timeout_del(&sc->sc_to);
				sc->sc_flags &= ~PPIF_TIMO;
			}
			splx(s);
			break;
		}
		/*
		 * Perform the operation
		 */
		if (uio->uio_rw == UIO_WRITE)
			cnt = hpibsend(ctlr, slave, sc->sc_sec, cp, len);
		else
			cnt = hpibrecv(ctlr, slave, sc->sc_sec, cp, len);
		hpibfree(sc->sc_dev.dv_parent, &sc->sc_hq);
#ifdef DEBUG
		if (ppidebug & PDB_IO)
			printf("ppirw: %s(%d, %d, %x, %p, %d) -> %d\n",
			       uio->uio_rw == UIO_READ ? "recv" : "send",
			       ctlr, slave, sc->sc_sec, cp, len, cnt);
#endif
		if (uio->uio_rw == UIO_READ) {
			if (cnt) {
				error = uiomove(cp, cnt, uio);
				if (error) {
					splx(s);
					break;
				}
				gotdata++;
			}
			/*
			 * Didn't get anything this time, but did in the past.
			 * Consider us done.
			 */
			else if (gotdata) {
				splx(s);
				break;
			}
		}
		/*
		 * Operation timeout (or non-blocking), quit now.
		 */
		if ((sc->sc_flags & PPIF_UIO) == 0) {
#ifdef DEBUG
			if (ppidebug & PDB_IO)
				printf("ppirw: timeout/done\n");
#endif
			splx(s);
			break;
		}
		/*
		 * Implement inter-read delay
		 */
		if (sc->sc_delay > 0) {
			sc->sc_flags |= PPIF_DELAY;
			timeout_add_msec(&sc->sc_start_to, sc->sc_delay);
			error = tsleep(sc, (PCATCH|PZERO) + 1, "hpib", 0);
			if (error) {
				splx(s);
				break;
			}
		}
		/*
		 * Must not call uiomove again til we've used all data
		 * that we already grabbed.
		 */
		if (uio->uio_rw == UIO_WRITE && cnt != len) {
			cp += cnt;
			len -= cnt;
			cnt = 0;
			splx(s);
			goto again;
		}
		splx(s);
	}
	if (sc->sc_flags & PPIF_TIMO) {
		timeout_del(&sc->sc_to);
		sc->sc_flags &= ~PPIF_TIMO;
	}
	if (sc->sc_flags & PPIF_DELAY) {
		timeout_del(&sc->sc_start_to);
		sc->sc_flags &= ~PPIF_DELAY;
	}
	/*
	 * Adjust for those chars that we uiomove'ed but never wrote
	 */
	if (uio->uio_rw == UIO_WRITE && cnt != len) {
		uio->uio_resid += (len - cnt);
#ifdef DEBUG
		if (ppidebug & PDB_IO)
			printf("ppirw: short write, adjust by %d\n",
			       len-cnt);
#endif
	}
	free(buf, M_DEVBUF);
#ifdef DEBUG
	if (ppidebug & (PDB_FOLLOW|PDB_IO))
		printf("ppirw: return %d, resid %d\n", error, uio->uio_resid);
#endif
	return (error);
}

int
ppiioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct ppi_softc *sc = ppi_cd.cd_devs[UNIT(dev)];
	struct ppiparam *pp, *upp;
	int tmp;
	int error = 0;

	switch (cmd) {
	case PPIIOCGPARAM:
		pp = &sc->sc_param;
		upp = (struct ppiparam *)data;
		upp->burst = pp->burst;
		upp->timo = pp->timo;
		upp->delay = pp->delay;
		break;
	case PPIIOCSPARAM:
		pp = &sc->sc_param;
		upp = (struct ppiparam *)data;
		if (upp->burst < PPI_BURST_MIN || upp->burst > PPI_BURST_MAX ||
		    upp->delay < PPI_DELAY_MIN || upp->delay > PPI_DELAY_MAX)
			return(EINVAL);
		pp->burst = upp->burst;
		pp->timo = upp->timo;
		pp->delay = upp->delay;
		break;
	case PPIIOCSSEC:
		tmp = *(int *)data;
		if (tmp == -1 || (tmp >= 0 && tmp <= 0x1f))
			sc->sc_sec = tmp;
		else
			error = EINVAL;
		break;
	default:
		return (ENOTTY);
	}
	return (error);
}
@


1.17
log
@timeout_add -> timeout_add_msec + associated cleanup

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.16 2006/04/13 20:08:12 miod Exp $	*/
@


1.16
log
@Fix timeout initialization bug introduced in rev 1.8.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.15 2006/01/19 23:54:41 miod Exp $	*/
a91 2
int	ppihztoms(int);
int	ppimstohz(int);
d187 2
a188 2
	sc->sc_timo = ppimstohz(PPI_TIMO);
	sc->sc_delay = ppimstohz(PPI_DELAY);
d297 1
a297 1
		timeout_add(&sc->sc_to, sc->sc_timo);
d377 1
a377 1
			timeout_add(&sc->sc_start_to, sc->sc_delay);
d442 2
a443 2
		upp->timo = ppihztoms(pp->timo);
		upp->delay = ppihztoms(pp->delay);
d452 2
a453 2
		pp->timo = ppimstohz(upp->timo);
		pp->delay = ppimstohz(upp->delay);
a465 25
}

int
ppihztoms(h)
	int h;
{
	int m = h;

	if (m > 0)
		m = m * 1000 / hz;
	return(m);
}

int
ppimstohz(m)
	int m;
{
	int h = m;

	if (h > 0) {
		h = h * hz / 1000;
		if (h == 0)
			h = 1000 / hz;
	}
	return(h);
@


1.15
log
@Bounds check PPIIOCSSEC argument, for a carefully choosen invalid value
could cause any ppi transfer to freeze the bus.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.14 2005/11/14 19:23:40 miod Exp $	*/
a94 1
bdev_decl(ppi);
d156 1
a156 1
	timeout_set(&sc->sc_to, ppistart, sc);
@


1.14
log
@hz is defined in <sys/kernel.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.13 2005/02/13 23:13:25 mickey Exp $	*/
d437 1
d459 5
a463 1
		sc->sc_sec = *(int *)data;
d466 1
a466 1
		return(EINVAL);
@


1.13
log
@remove race w/ improper spllowersoftclock() use; miod@@ ok; not tested due to lack of hw
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.12 2005/01/15 21:13:08 miod Exp $	*/
d45 1
a469 1
	extern int hz;
a480 1
	extern int hz;
@


1.12
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.11 2003/06/02 23:27:45 millert Exp $	*/
a317 1
		(void) spllowersoftclock();
a330 1
		splx(s);
a337 1
		s = splbio();
a344 1
		splx(s);
d348 2
a349 1
				if (error)
d351 1
d358 2
a359 1
			else if (gotdata)
d361 1
a362 1
		s = splsoftclock();
a385 1
		splx(s);
d394 1
d397 1
a398 1
	s = splsoftclock();
a406 1
	splx(s);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.10 2002/06/09 05:23:26 miod Exp $	*/
d69 2
a70 2
#define	PPIF_ALIVE	0x01	
#define	PPIF_OPEN	0x02	
@


1.10
log
@convert sleep() calls to tsleep().
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.9 2002/03/14 01:26:30 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.8 2001/05/01 16:51:10 millert Exp $	*/
d318 1
a318 1
			sleep(sc, PRIBIO+1);
@


1.8
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.7 2000/07/06 15:42:48 ho Exp $	*/
d79 2
a80 2
int	ppimatch __P((struct device *, void *, void *));
void	ppiattach __P((struct device *, struct device *, void *));
d90 2
a91 2
void	ppistart __P((void *));
void	ppinoop __P((void *));
d93 4
a96 4
void	ppitimo __P((void *));
int	ppirw __P((dev_t, struct uio *));
int	ppihztoms __P((int));
int	ppimstohz __P((int));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.8 2001/05/01 16:51:10 millert Exp $	*/
d79 2
a80 2
int	ppimatch(struct device *, void *, void *);
void	ppiattach(struct device *, struct device *, void *);
d90 2
a91 2
void	ppistart(void *);
void	ppinoop(void *);
d93 4
a96 4
void	ppitimo(void *);
int	ppirw(dev_t, struct uio *);
int	ppihztoms(int);
int	ppimstohz(int);
d318 1
a318 1
			tsleep(sc, PRIBIO+1, "ppirw", 0);
@


1.7
log
@Change splsoftclock() call to spllowersoftclock() to conform with other
code and keep old behaviour. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.6 1997/04/16 11:56:14 downsj Exp $	*/
d51 1
d68 2
d157 4
d303 1
a303 1
		timeout(ppitimo, sc, sc->sc_timo);
d330 1
a330 1
				untimeout(ppitimo, sc);
d384 1
a384 1
			timeout(ppistart, sc, sc->sc_delay);
d405 1
a405 1
		untimeout(ppitimo, sc);
d409 1
a409 1
		untimeout(ppistart, sc);
@


1.6
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.5 1997/02/03 04:47:41 downsj Exp $	*/
d315 1
a315 1
		(void) splsoftclock();
@


1.6.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.7 2000/07/06 15:42:48 ho Exp $	*/
d315 1
a315 1
		(void) spllowersoftclock();
@


1.6.14.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.6.14.1 2001/04/18 16:05:36 niklas Exp $	*/
a50 1
#include <sys/timeout.h>
a66 2
	struct timeout sc_to;		/* ppitimo timeout */
	struct timeout sc_start_to;	/* ppistart timeout */
a153 4

	/* Initialize timeout structures */
	timeout_set(&sc->sc_to, ppitimo, sc);
	timeout_set(&sc->sc_to, ppistart, sc);
d296 1
a296 1
		timeout_add(&sc->sc_to, sc->sc_timo);
d323 1
a323 1
				timeout_del(&sc->sc_to);
d377 1
a377 1
			timeout_add(&sc->sc_start_to, sc->sc_delay);
d398 1
a398 1
		timeout_del(&sc->sc_to);
d402 1
a402 1
		timeout_del(&sc->sc_start_to);
@


1.6.14.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 2
a80 2
int	ppimatch(struct device *, void *, void *);
void	ppiattach(struct device *, struct device *, void *);
d90 2
a91 2
void	ppistart(void *);
void	ppinoop(void *);
d93 4
a96 4
void	ppitimo(void *);
int	ppirw(dev_t, struct uio *);
int	ppihztoms(int);
int	ppimstohz(int);
@


1.6.14.4
log
@Sync the SMP branch with 3.3
@
text
@d318 1
a318 1
			tsleep(sc, PRIBIO+1, "ppirw", 0);
@


1.6.14.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppi.c,v 1.6.14.4 2003/03/27 23:19:20 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ppi.c,v 1.4 1997/01/12 15:12:57 downsj Exp $	*/
/*	$NetBSD: ppi.c,v 1.11 1997/01/30 09:14:16 thorpej Exp $	*/
d46 2
d49 2
a51 3
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
d169 1
a169 1
	register int unit = UNIT(dev);
d198 1
a198 1
	register int unit = UNIT(dev);
d218 1
a218 1
		printf("ppistart(%x)\n", unit);
d247 1
a247 1
		printf("ppiread(%x, %x)\n", dev, uio);
d261 1
a261 1
		printf("ppiwrite(%x, %x)\n", dev, uio);
d269 1
a269 1
	register struct uio *uio;
d273 2
a274 2
	register int s, len, cnt;
	register char *cp;
d287 1
a287 1
		printf("ppirw(%x, %x, %c): burst %d, timo %d, resid %x\n",
d298 1
d341 1
a341 1
			printf("ppirw: %s(%d, %d, %x, %x, %d) -> %d\n",
d378 1
a378 1
			error = tsleep(sc, PCATCH|PZERO+1, "hpib", 0);
d469 1
a469 1
	register int m = h;
d481 1
a481 1
	register int h = m;
@


1.4
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ppi.c,v 1.10 1996/10/13 03:14:20 christos Exp $	*/
d5 1
a43 3
#include "ppi.h"
#if NPPI > 0

d49 4
a53 1
#include <hp300/dev/device.h>
a55 6
int	ppimatch(), ppistart();
void	ppiattach(), ppitimo();
struct	driver ppidriver = {
	ppimatch, ppiattach, "ppi", ppistart,
};

d57 1
d59 1
a59 2
	struct	devqueue sc_dq;
	struct	hp_device *sc_hd;
d65 2
a66 1
} ppi_softc[NPPI];
d75 22
d107 3
a109 2
ppimatch(hd)
	register struct hp_device *hd;
d111 10
a120 1
	register struct ppi_softc *sc = &ppi_softc[hd->hp_unit];
a121 3
#ifdef DEBUG
	if ((ppidebug & PDB_NOCHECK) == 0)
#endif
d123 2
a124 3
	 * XXX: the printer/plotter doesn't seem to really return
	 * an ID but this will at least prevent us from mistaking
	 * a cs80 disk or tape for a ppi device.
d126 2
a127 1
	if (hpibid(hd->hp_ctlr, hd->hp_slave) & 0x200)
a129 1
	sc->sc_hd = hd;
d134 3
a136 2
ppiattach(hd)
	register struct hp_device *hd;
d138 2
a139 1
	struct ppi_softc *sc = &ppi_softc[hd->hp_unit];
d143 9
a152 5
	sc->sc_dq.dq_softc = sc;
	sc->sc_dq.dq_ctlr = hd->hp_ctlr;
	sc->sc_dq.dq_unit = hd->hp_unit;
	sc->sc_dq.dq_slave = hd->hp_slave;
	sc->sc_dq.dq_driver = &ppidriver;
d155 9
a163 1
ppiopen(dev, flags)
d165 2
d169 6
a174 1
	register struct ppi_softc *sc = &ppi_softc[unit];
a175 2
	if (unit >= NPPI || (sc->sc_flags & PPIF_ALIVE) == 0)
		return(ENXIO);
d182 1
a182 1
		return(EBUSY);
d191 2
a192 1
ppiclose(dev, flags)
d194 2
d198 1
a198 1
	register struct ppi_softc *sc = &ppi_softc[unit];
d209 3
a211 2
ppistart(unit)
	int unit;
d213 2
d219 2
a220 3
	ppi_softc[unit].sc_flags &= ~PPIF_DELAY;
	wakeup(&ppi_softc[unit]);
	return (0);
d224 2
a225 2
ppitimo(unit)
	int unit;
d227 2
d231 1
a231 1
		printf("ppitimo(%x)\n", unit);
d233 2
a234 2
	ppi_softc[unit].sc_flags &= ~(PPIF_UIO|PPIF_TIMO);
	wakeup(&ppi_softc[unit]);
d237 2
a238 1
ppiread(dev, uio)
d241 1
d251 2
a252 1
ppiwrite(dev, uio)
d255 1
d265 1
d271 1
a271 1
	register struct ppi_softc *sc = &ppi_softc[unit];
d275 1
a275 1
	int buflen;
d281 3
d295 1
a295 1
		timeout(ppitimo, (void *)unit, sc->sc_timo);
d307 2
a308 1
		if ((sc->sc_flags & PPIF_UIO) && hpibreq(&sc->sc_dq) == 0)
d321 1
a321 1
				untimeout(ppitimo, (void *)unit);
d332 1
a332 2
			cnt = hpibsend(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave,
				       sc->sc_sec, cp, len);
d334 1
a334 2
			cnt = hpibrecv(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave,
				       sc->sc_sec, cp, len);
d336 1
a336 1
		hpibfree(&sc->sc_dq);
d341 1
a341 2
			       sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave,
			       sc->sc_sec, cp, len, cnt);
d375 1
a375 2
			timeout((void (*)__P((void *)))ppistart, (void *)unit,
			    sc->sc_delay);
d396 1
a396 1
		untimeout(ppitimo, (void *)unit);
d400 1
a400 1
		untimeout((void (*)__P((void *)))ppistart, (void *)unit);
d423 1
d426 1
a426 1
	int cmd;
d431 1
a431 1
	struct ppi_softc *sc = &ppi_softc[UNIT(dev)];
d462 1
d474 1
a487 1
#endif
@


1.3
log
@sync w/ Net 960424
@
text
@d1 2
a2 1
/*	$NetBSD: ppi.c,v 1.8 1996/02/14 02:44:49 thorpej Exp $	*/
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: ppi.c,v 1.7 1995/12/02 18:22:08 thorpej Exp $	*/
d117 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ppi.c,v 1.6 1994/10/26 07:24:46 cgd Exp $	*/
d54 2
a55 2
int	ppiattach(), ppistart();
void	ppitimo();
d57 1
a57 1
	ppiattach, "ppi", ppistart,
d87 2
a88 1
ppiattach(hd)
d102 14
a115 1
		return(0);
a120 2
	sc->sc_hd = hd;
	return(1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
