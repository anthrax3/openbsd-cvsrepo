head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.24
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.20
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.18
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.16
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.14
	OPENBSD_5_0:1.20.0.12
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.10
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.8.0.18
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.16
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.14
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.12
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.18.22.36.31;	author miod;	state dead;
branches;
next	1.20;

1.20
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.18.21.39.52;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.09.17.46.00;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.17.23.56.02;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.25.23.02.23;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.16.16.48.44;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.04.02.58.51;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.05.11.23.24.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.01.16.51.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.06.08.01.49;	author downsj;	state Exp;
branches
	1.8.12.1;
next	1.7;

1.7
date	97.04.16.11.56.00;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.04.07.15.24;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.02.03.04.47.22;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.12.15.12.28;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.30;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.18;	author deraadt;	state Exp;
branches;
next	;

1.8.12.1
date	2001.07.04.10.15.26;	author niklas;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.8.12.4;

1.8.12.4
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: dma.c,v 1.20 2008/10/15 19:12:19 blambert Exp $	*/
/*	$NetBSD: dma.c,v 1.19 1997/05/05 21:02:39 thorpej Exp $	*/

/*
 * Copyright (c) 1995, 1996, 1997
 *	Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)dma.c	8.1 (Berkeley) 6/10/93
 */

/*
 * DMA driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <machine/frame.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <hp300/dev/dmareg.h>
#include <hp300/dev/dmavar.h>

#include <uvm/uvm_extern.h>

/*
 * The largest single request will be MAXPHYS bytes which will require
 * at most MAXPHYS/NBPG+1 chain elements to describe, i.e. if none of
 * the buffer pages are physically contiguous (MAXPHYS/NBPG) and the
 * buffer is not page aligned (+1).
 */
#define	DMAMAXIO	(MAXPHYS/NBPG+1)

struct dma_chain {
	u_int	dc_count;
	paddr_t	dc_addr;
};

struct dma_channel {
	struct	dmaqueue *dm_job;		/* current job */
	struct	dmadevice *dm_hwaddr;		/* registers if DMA_C */
	struct	dmaBdevice *dm_Bhwaddr;		/* registers if not DMA_C */
	char	dm_flags;			/* misc. flags */
	u_short	dm_cmd;				/* DMA controller command */
	u_int	dm_cur;				/* current segment */
	u_int	dm_last;			/* last segment */
	struct	dma_chain dm_chain[DMAMAXIO];	/* all segments */
};

struct dma_softc {
	struct	dmareg *sc_dmareg;		/* pointer to our hardware */
	struct	isr sc_isr;
	struct	dma_channel sc_chan[NDMACHAN];	/* 2 channels */
#ifdef DEBUG
	struct	timeout sc_timeout;		/* DMA timeout */
#endif
	TAILQ_HEAD(, dmaqueue) sc_queue;	/* job queue */
	char	sc_type;			/* A, B, or C */
} dma_softc;

/* types */
#define	DMA_B	0
#define DMA_C	1

/* flags */
#define DMAF_PCFLUSH	0x01
#define DMAF_VCFLUSH	0x02
#define DMAF_NOINTR	0x04

void	dmacflush(struct dma_channel *);
int	dmaintr(void *);

#ifdef DEBUG
int	dmadebug = 0;
#define DDB_WORD	0x01	/* same as DMAGO_WORD */
#define DDB_LWORD	0x02	/* same as DMAGO_LWORD */
#define	DDB_FOLLOW	0x04
#define DDB_IO		0x08

void	dmatimeout(void *);
int	dmatimo[NDMACHAN];

long	dmahits[NDMACHAN];
long	dmamisses[NDMACHAN];
long	dmabyte[NDMACHAN];
long	dmaword[NDMACHAN];
long	dmalword[NDMACHAN];
#endif

/*
 * Initialize the DMA engine, called by dioattach()
 */
void
dmainit()
{
	struct dma_softc *sc = &dma_softc;
	struct dmareg *dma;
	struct dma_channel *dc;
	int i;
	char rev;

	/* There's just one. */
	sc->sc_dmareg = (struct dmareg *)DMA_BASE;
	dma = sc->sc_dmareg;

	/*
	 * Determine the DMA type.  A DMA_A or DMA_B will fail the
	 * following probe.
	 *
	 * XXX Don't know how to easily differentiate the A and B cards,
	 * so we just hope nobody has an A card (A cards will work if
	 * splbio works out to ipl 3).
	 */
	if (badbaddr((char *)&dma->dma_id[2])) {
		rev = 'B';
#if !defined(HP320)
		panic("dmainit: DMA card requires hp320 support");
#endif
	} else
		rev = dma->dma_id[2];

	sc->sc_type = (rev == 'B') ? DMA_B : DMA_C;

	TAILQ_INIT(&sc->sc_queue);

	for (i = 0; i < NDMACHAN; i++) {
		dc = &sc->sc_chan[i];
		dc->dm_job = NULL;
		switch (i) {
		case 0:
			dc->dm_hwaddr = &dma->dma_chan0;
			dc->dm_Bhwaddr = &dma->dma_Bchan0;
			break;

		case 1:
			dc->dm_hwaddr = &dma->dma_chan1;
			dc->dm_Bhwaddr = &dma->dma_Bchan1;
			break;

		default:
			panic("dmainit: more than 2 channels?");
			/* NOTREACHED */
		}
	}

#ifdef DEBUG
	/* make sure timeout is really not needed */
	timeout_set(&sc->sc_timeout, dmatimeout, sc);
	timeout_add_sec(&sc->sc_timeout, 30);
#endif

	printf("98620%c, 2 channels, %d bit DMA\n",
	    rev, (rev == 'B') ? 16 : 32);

	/*
	 * Defer hooking up our interrupt until the first
	 * DMA-using controller has hooked up theirs.
	 */
	sc->sc_isr.isr_func = NULL;
	sc->sc_isr.isr_arg = sc;
	sc->sc_isr.isr_priority = IPL_BIO;
}

/*
 * Compute the ipl and (re)establish the interrupt handler
 * for the DMA controller.
 */
void
dmacomputeipl()
{
	struct dma_softc *sc = &dma_softc;

	if (sc->sc_isr.isr_func != NULL)
		intr_disestablish(&sc->sc_isr);

	/*
	 * Our interrupt level must be as high as the highest
	 * device using DMA (i.e. splbio).
	 */
	sc->sc_isr.isr_ipl = PSLTOIPL(hp300_varpsl[IPL_BIO]);

	sc->sc_isr.isr_func = dmaintr;
	intr_establish(&sc->sc_isr, "dma");
}

int
dmareq(struct dmaqueue *dq)
{
	struct dma_softc *sc = &dma_softc;
	int i, chan, s;

	s = splvm();

	chan = dq->dq_chan;
	for (i = NDMACHAN - 1; i >= 0; i--) {
		/*
		 * Can we use this channel?
		 */
		if ((chan & (1 << i)) == 0)
			continue;

		/*
		 * We can use it; is it busy?
		 */
		if (sc->sc_chan[i].dm_job != NULL)
			continue;

		/*
		 * Not busy; give the caller this channel.
		 */
		sc->sc_chan[i].dm_job = dq;
		dq->dq_chan = i;
		splx(s);
		return (1);
	}

	/*
	 * Couldn't get a channel now; put this in the queue.
	 */
	TAILQ_INSERT_TAIL(&sc->sc_queue, dq, dq_list);
	splx(s);
	return (0);
}

void
dmacflush(struct dma_channel *dc)
{
#if defined(CACHE_HAVE_PAC) || defined(M68040)
	if (dc->dm_flags & DMAF_PCFLUSH) {
		PCIA();
		dc->dm_flags &= ~DMAF_PCFLUSH;
	}
#endif

#if defined(CACHE_HAVE_VAC)
	if (dc->dm_flags & DMAF_VCFLUSH) {
		/*
		 * 320/350s have VACs that may also need flushing.
		 * In our case we only flush the supervisor side
		 * because we know that if we are DMAing to user
		 * space, the physical pages will also be mapped
		 * in kernel space (via vmapbuf) and hence cache-
		 * inhibited by the pmap module due to the multiple
		 * mapping.
		 */
		DCIS();
		dc->dm_flags &= ~DMAF_VCFLUSH;
	}
#endif
}

void
dmafree(struct dmaqueue *dq)
{
	int unit = dq->dq_chan;
	struct dma_softc *sc = &dma_softc;
	struct dma_channel *dc = &sc->sc_chan[unit];
	struct dmaqueue *dn;
	int chan, s;

	s = splvm();

#ifdef DEBUG
	dmatimo[unit] = 0;
#endif

	DMA_CLEAR(dc);

	/*
	 * XXX we may not always go through the flush code in dmastop()
	 */
	dmacflush(dc);

	/*
	 * Channel is now free.  Look for another job to run on this
	 * channel.
	 */
	dc->dm_job = NULL;
	chan = 1 << unit;
	TAILQ_FOREACH(dn, &sc->sc_queue, dq_list) {
		if (dn->dq_chan & chan) {
			/* Found one... */
			TAILQ_REMOVE(&sc->sc_queue, dn, dq_list);
			dc->dm_job = dn;
			dn->dq_chan = dq->dq_chan;
			splx(s);

			/* Start the initiator. */
			(*dn->dq_start)(dn->dq_softc);
			return;
		}
	}
	splx(s);
}

void
dmago(int unit, char *addr, u_int count, int flags)
{
	struct dma_softc *sc = &dma_softc;
	struct dma_channel *dc = &sc->sc_chan[unit];
	paddr_t dmaend = 0;
	u_int seg, tcount;

#ifdef DIAGNOSTIC
	if (count > MAXPHYS)
		panic("dmago: count > MAXPHYS");
#endif

#if defined(HP320)
	if (sc->sc_type == DMA_B && (flags & DMAGO_LWORD))
		panic("dmago: no can do 32-bit DMA");
#endif

#ifdef DEBUG
	if (dmadebug & DDB_FOLLOW)
		printf("dmago(%d, %p, %x, %x)\n",
		       unit, addr, count, flags);
	if (flags & DMAGO_LWORD)
		dmalword[unit]++;
	else if (flags & DMAGO_WORD)
		dmaword[unit]++;
	else
		dmabyte[unit]++;
#endif
	/*
	 * Build the DMA chain
	 */
	for (seg = 0; count > 0; seg++) {
		if (pmap_extract(pmap_kernel(), (vaddr_t)addr,
		    &dc->dm_chain[seg].dc_addr) == FALSE)
			panic("dmago: pmap_extract(%x) failed", addr);
#if defined(M68040)
		/*
		 * Push back dirty cache lines
		 */
		if (mmutype == MMU_68040)
			DCFP(dc->dm_chain[seg].dc_addr);
#endif
		if (count < (tcount = PAGE_SIZE - ((int)addr & PAGE_MASK)))
			tcount = count;
		dc->dm_chain[seg].dc_count = tcount;
		addr += tcount;
		count -= tcount;
		if (flags & DMAGO_LWORD)
			tcount >>= 2;
		else if (flags & DMAGO_WORD)
			tcount >>= 1;

		/*
		 * Try to compact the DMA transfer if the pages are adjacent.
		 * Note: this will never happen on the first iteration.
		 */
		if (dc->dm_chain[seg].dc_addr == dmaend
#if defined(HP320)
		    /* only 16-bit count on 98620B */
		    && (sc->sc_type != DMA_B ||
			dc->dm_chain[seg - 1].dc_count + tcount <= 65536)
#endif
		) {
#ifdef DEBUG
			dmahits[unit]++;
#endif
			dmaend += dc->dm_chain[seg].dc_count;
			dc->dm_chain[--seg].dc_count += tcount;
		} else {
#ifdef DEBUG
			dmamisses[unit]++;
#endif
			dmaend = dc->dm_chain[seg].dc_addr +
			    dc->dm_chain[seg].dc_count;
			dc->dm_chain[seg].dc_count = tcount;
		}
	}
	dc->dm_cur = 0;
	dc->dm_last = --seg;
	dc->dm_flags = 0;
	/*
	 * Set up the command word based on flags
	 */
	dc->dm_cmd = DMA_ENAB | DMA_IPL(sc->sc_isr.isr_ipl) | DMA_START;
	if ((flags & DMAGO_READ) == 0)
		dc->dm_cmd |= DMA_WRT;
	if (flags & DMAGO_LWORD)
		dc->dm_cmd |= DMA_LWORD;
	else if (flags & DMAGO_WORD)
		dc->dm_cmd |= DMA_WORD;
	if (flags & DMAGO_PRI)
		dc->dm_cmd |= DMA_PRI;

	if (flags & DMAGO_READ) {
#if defined(M68040)
		/*
		 * On the 68040 we need to flush (push) the data cache before a
		 * DMA (already done above) and flush again after DMA completes.
		 * In theory we should only need to flush prior to a write DMA
		 * and purge after a read DMA but if the entire page is not
		 * involved in the DMA we might purge some valid data.
		 */
		if (mmutype == MMU_68040)
			dc->dm_flags |= DMAF_PCFLUSH;
#endif

#if defined(CACHE_HAVE_PAC)
		/*
		 * Remember if we need to flush external physical cache when
		 * DMA is done.  We only do this if we are reading
		 * (writing memory).
		 */
		if (ectype == EC_PHYS)
			dc->dm_flags |= DMAF_PCFLUSH;
#endif

#if defined(CACHE_HAVE_VAC)
		if (ectype == EC_VIRT)
			dc->dm_flags |= DMAF_VCFLUSH;
#endif
	}

	/*
	 * Remember if we can skip the dma completion interrupt on
	 * the last segment in the chain.
	 */
	if (flags & DMAGO_NOINT) {
		if (dc->dm_cur == dc->dm_last)
			dc->dm_cmd &= ~DMA_ENAB;
		else
			dc->dm_flags |= DMAF_NOINTR;
	}
#ifdef DEBUG
	if (dmadebug & DDB_IO) {
		if (((dmadebug&DDB_WORD) && (dc->dm_cmd&DMA_WORD)) ||
		    ((dmadebug&DDB_LWORD) && (dc->dm_cmd&DMA_LWORD))) {
			printf("dmago: cmd %x, flags %x\n",
			       dc->dm_cmd, dc->dm_flags);
			for (seg = 0; seg <= dc->dm_last; seg++)
				printf("  %d: %d@@%p\n", seg,
				    dc->dm_chain[seg].dc_count,
				    dc->dm_chain[seg].dc_addr);
		}
	}
	dmatimo[unit] = 1;
#endif
	DMA_ARM(sc, dc);
}

void
dmastop(int unit)
{
	struct dma_softc *sc = &dma_softc;
	struct dma_channel *dc = &sc->sc_chan[unit];

#ifdef DEBUG
	if (dmadebug & DDB_FOLLOW)
		printf("dmastop(%d)\n", unit);
	dmatimo[unit] = 0;
#endif
	DMA_CLEAR(dc);

	dmacflush(dc);

	/*
	 * We may get this interrupt after a device service routine
	 * has freed the dma channel.  So, ignore the intr if there's
	 * nothing on the queue.
	 */
	if (dc->dm_job != NULL)
		(*dc->dm_job->dq_done)(dc->dm_job->dq_softc);
}

int
dmaintr(void *arg)
{
	struct dma_softc *sc = arg;
	struct dma_channel *dc;
	int i, stat;
	int found = 0;

#ifdef DEBUG
	if (dmadebug & DDB_FOLLOW)
		printf("dmaintr\n");
#endif
	for (i = 0; i < NDMACHAN; i++) {
		dc = &sc->sc_chan[i];
		stat = DMA_STAT(dc);
		if ((stat & DMA_INTR) == 0)
			continue;
		found++;
#ifdef DEBUG
		if (dmadebug & DDB_IO) {
			if (((dmadebug&DDB_WORD) && (dc->dm_cmd&DMA_WORD)) ||
			    ((dmadebug&DDB_LWORD) && (dc->dm_cmd&DMA_LWORD)))
			  printf("dmaintr: flags %x unit %d stat %x next %d\n",
			   dc->dm_flags, i, stat, dc->dm_cur + 1);
		}
		if (stat & DMA_ARMED)
			printf("dma channel %d: intr when armed\n", i);
#endif
		/*
		 * Load the next segment, or finish up if we're done.
		 */
		dc->dm_cur++;
		if (dc->dm_cur <= dc->dm_last) {
#ifdef DEBUG
			dmatimo[i] = 1;
#endif
			/*
			 * If we're the last segment, disable the
			 * completion interrupt, if necessary.
			 */
			if (dc->dm_cur == dc->dm_last &&
			    (dc->dm_flags & DMAF_NOINTR))
				dc->dm_cmd &= ~DMA_ENAB;
			DMA_CLEAR(dc);
			DMA_ARM(sc, dc);
		} else
			dmastop(i);
	}
	return(found);
}

#ifdef DEBUG
void
dmatimeout(void *arg)
{
	int i, s;
	struct dma_softc *sc = arg;

	for (i = 0; i < NDMACHAN; i++) {
		s = splvm();
		if (dmatimo[i]) {
			if (dmatimo[i] > 1)
				printf("dma channel %d timeout #%d\n",
				    i, dmatimo[i]-1);
			dmatimo[i]++;
		}
		splx(s);
	}
	timeout_add_sec(&sc->sc_timeout, 30);
}
#endif
@


1.20
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.19 2008/07/18 21:39:52 miod Exp $	*/
@


1.19
log
@Protect dma operations with splvm instead of splhigh, that's faster than
splbio and won't delay clock interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.18 2007/11/09 17:46:00 miod Exp $	*/
d181 1
a181 1
	timeout_add(&sc->sc_timeout, 30 * hz);
d570 1
a570 1
	timeout_add(&sc->sc_timeout, 30 * hz);
@


1.18
log
@IPL_xxx values on hp300 are logical values (although some of them happen to
match the real hardware level used for them).

So instead of keeping a few loose variables to store the runtime computed
psr bits to use for the logical IPL levels, just keep a complete array of
all psr values. Thus we can have a correct splassert_check().
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.17 2005/11/17 23:56:02 miod Exp $	*/
d224 1
a224 5
#if 1
	s = splhigh();	/* XXXthorpej */
#else
	s = splbio();
#endif
d293 1
a293 5
#if 1
	s = splhigh();	/* XXXthorpej */
#else
	s = splbio();
#endif
d561 1
a561 1
		s = splbio();
@


1.17
log
@Factorize DMA cache flush code, use modern types and constants, ansify.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.16 2004/12/25 23:02:23 miod Exp $	*/
d212 1
a212 1
	sc->sc_isr.isr_ipl = PSLTOIPL(hp300_bioipl);
@


1.16
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.15 2004/12/16 16:48:44 miod Exp $	*/
d56 2
d67 2
a68 2
	int	dc_count;
	char	*dc_addr;
d77 2
a78 2
	int	dm_cur;				/* current segment */
	int	dm_last;			/* last segment */
d102 1
d219 1
a219 2
dmareq(dq)
	struct dmaqueue *dq;
d262 1
a262 2
dmafree(dq)
	struct dmaqueue *dq;
a263 18
	int unit = dq->dq_chan;
	struct dma_softc *sc = &dma_softc;
	struct dma_channel *dc = &sc->sc_chan[unit];
	struct dmaqueue *dn;
	int chan, s;

#if 1
	s = splhigh();	/* XXXthorpej */
#else
	s = splbio();
#endif

#ifdef DEBUG
	dmatimo[unit] = 0;
#endif

	DMA_CLEAR(dc);

a264 3
	/*
	 * XXX we may not always go thru the flush code in dmastop()
	 */
d286 27
d337 1
a337 5
dmago(unit, addr, count, flags)
	int unit;
	char *addr;
	int count;
	int flags;
d341 2
a342 2
	char *dmaend = NULL;
	int seg, tcount;
d369 3
a371 1
		dc->dm_chain[seg].dc_addr = (char *) kvtop(addr);
d377 1
a377 1
			DCFP((paddr_t)dc->dm_chain[seg].dc_addr);
d379 1
a379 1
		if (count < (tcount = NBPG - ((int)addr & PGOFSET)))
d430 1
d432 9
a440 9
	/*
	 * On the 68040 we need to flush (push) the data cache before a
	 * DMA (already done above) and flush again after DMA completes.
	 * In theory we should only need to flush prior to a write DMA
	 * and purge after a read DMA but if the entire page is not
	 * involved in the DMA we might purge some valid data.
	 */
	if (mmutype == MMU_68040 && (flags & DMAGO_READ))
		dc->dm_flags |= DMAF_PCFLUSH;
d444 7
a450 6
	/*
	 * Remember if we need to flush external physical cache when
	 * DMA is done.  We only do this if we are reading (writing memory).
	 */
	if (ectype == EC_PHYS && (flags & DMAGO_READ))
		dc->dm_flags |= DMAF_PCFLUSH;
d454 2
a455 2
	if (ectype == EC_VIRT && (flags & DMAGO_READ))
		dc->dm_flags |= DMAF_VCFLUSH;
d457 1
d487 1
a487 2
dmastop(unit)
	int unit;
d499 1
a499 22
#if defined(CACHE_HAVE_PAC) || defined(M68040)
	if (dc->dm_flags & DMAF_PCFLUSH) {
		PCIA();
		dc->dm_flags &= ~DMAF_PCFLUSH;
	}
#endif

#if defined(CACHE_HAVE_VAC)
	if (dc->dm_flags & DMAF_VCFLUSH) {
		/*
		 * 320/350s have VACs that may also need flushing.
		 * In our case we only flush the supervisor side
		 * because we know that if we are DMAing to user
		 * space, the physical pages will also be mapped
		 * in kernel space (via vmapbuf) and hence cache-
		 * inhibited by the pmap module due to the multiple
		 * mapping.
		 */
		DCIS();
		dc->dm_flags &= ~DMAF_VCFLUSH;
	}
#endif
d511 1
a511 2
dmaintr(arg)
	void *arg;
d563 1
a563 2
dmatimeout(arg)
	void *arg;
@


1.15
log
@Fix logic botch in dmacomputeipl() introduced in rev 1.14.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.14 2004/09/29 07:35:52 miod Exp $	*/
d313 1
a313 2
	for (dn = sc->sc_queue.tqh_first; dn != NULL;
	    dn = dn->dq_list.tqe_next) {
@


1.14
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.13 2003/06/02 23:27:44 millert Exp $	*/
a184 6
	 * Our interrupt level must be as high as the highest
	 * device using DMA (i.e. splbio).
	 */
	sc->sc_isr.isr_ipl = PSLTOIPL(hp300_bioipl);

	/*
d204 6
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.12 2002/03/14 01:26:30 millert Exp $	*/
d82 1
a88 2
	int	sc_ipl;				/* our interrupt level */
	void	*sc_ih;				/* interrupt cookie */
d185 6
d194 3
a196 1
	sc->sc_ih = NULL;
d208 2
a209 2
	if (sc->sc_ih != NULL)
		intr_disestablish(sc->sc_ih);
d211 2
a212 6
	/*
	 * Our interrupt level must be as high as the highest
	 * device using DMA (i.e. splbio).
	 */
	sc->sc_ipl = PSLTOIPL(hp300_bioipl);
	sc->sc_ih = intr_establish(dmaintr, sc, sc->sc_ipl, IPL_BIO);
d342 1
d345 1
d416 1
a416 1
	dc->dm_cmd = DMA_ENAB | DMA_IPL(sc->sc_ipl) | DMA_START;
d555 1
a555 1
		 * Load the next segemnt, or finish up if we're done.
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.11 2001/11/04 02:58:51 miod Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@hp300spu.h information not needed anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.10 2001/05/11 23:24:56 millert Exp $	*/
d105 1
a105 1
int	dmaintr __P((void *));
d114 1
a114 1
void	dmatimeout __P((void *));
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.11 2001/11/04 02:58:51 miod Exp $	*/
d105 1
a105 1
int	dmaintr(void *);
d114 1
a114 1
void	dmatimeout(void *);
@


1.10
log
@Kill remaining vm_offset_t and vm_size_t; NetBSD used as a guide
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.9 2001/05/01 16:51:08 millert Exp $	*/
a43 2

#include <machine/hp300spu.h>	/* XXX param.h includes cpu.h */
@


1.9
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.8 1997/07/06 08:01:49 downsj Exp $	*/
d374 1
a374 1
			DCFP((vm_offset_t)dc->dm_chain[seg].dc_addr);
@


1.8
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.7 1997/04/16 11:56:00 downsj Exp $	*/
d53 1
d89 3
d184 2
a185 1
	timeout(dmatimeout, sc, 30 * hz);
d596 1
a596 1
	timeout(dmatimeout, sc, 30 * hz);
@


1.8.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.8 1997/07/06 08:01:49 downsj Exp $	*/
a52 1
#include <sys/timeout.h>
a87 3
#ifdef DEBUG
	struct	timeout sc_timeout;		/* DMA timeout */
#endif
d180 1
a180 2
	timeout_set(&sc->sc_timeout, dmatimeout, sc);
	timeout_add(&sc->sc_timeout, 30 * hz);
d369 1
a369 1
			DCFP((paddr_t)dc->dm_chain[seg].dc_addr);
d591 1
a591 1
	timeout_add(&sc->sc_timeout, 30 * hz);
@


1.8.12.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 2
@


1.8.12.3
log
@Merge in -current from about a week ago
@
text
@d105 1
a105 1
int	dmaintr(void *);
d114 1
a114 1
void	dmatimeout(void *);
@


1.8.12.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dma.c,v 1.8.12.3 2002/03/28 10:07:18 niklas Exp $	*/
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: dma.c,v 1.6 1997/02/04 07:15:24 downsj Exp $	*/
/*	$NetBSD: dma.c,v 1.17 1997/04/14 02:33:18 thorpej Exp $	*/
d45 2
d69 1
a69 1
struct	dma_chain {
d74 1
a74 1
struct	dma_channel {
a75 1
	struct	dma_softc *dm_softc;		/* pointer back to softc */
d85 1
a85 2
struct	dma_softc {
	char	*sc_xname;			/* XXX external name */
d92 1
a92 1
} Dma_softc;
d122 3
d128 1
a128 1
	struct dma_softc *sc = &Dma_softc;
a136 1
	sc->sc_xname = "dma0";
a159 1
		dc->dm_softc = sc;
d183 2
a184 2
	printf("%s: 98620%c, 2 channels, %d bit\n", sc->sc_xname,
	       rev, (rev == 'B') ? 16 : 32);
d200 1
a200 1
	struct dma_softc *sc = &Dma_softc;
d217 1
a217 1
	struct dma_softc *sc = &Dma_softc;
d262 1
a262 1
	struct dma_softc *sc = &Dma_softc;
d278 2
a279 1
#if defined(HP340) || defined(HP360) || defined(HP370) || defined(HP375) || defined(HP380)
d288 2
a289 1
#if defined(HP320) || defined(HP350)
d304 1
d335 1
a335 1
	struct dma_softc *sc = &Dma_softc;
d342 1
d347 1
d364 1
a364 1
#if defined(HP380)
d421 2
a422 1
#if defined(HP380)
d433 2
a434 1
#if defined(HP340) || defined(HP360) || defined(HP370) || defined(HP375)
d442 2
a443 1
#if defined(HP320) || defined(HP350)
d447 1
d472 1
a472 1
	DMA_ARM(dc);
d479 1
a479 1
	struct dma_softc *sc = &Dma_softc;
d488 2
a489 1
#if defined(HP340) || defined(HP360) || defined(HP370) || defined(HP375) || defined(HP380)
d495 2
a496 1
#if defined(HP320) || defined(HP350)
d511 1
d548 1
a548 2
			printf("%s, chan %d: intr when armed\n",
			    sc->sc_xname, i);
d566 1
a566 1
			DMA_ARM(dc);
d585 2
a586 2
				printf("%s: chan %d timeout #%d\n",
				    sc->sc_xname, i, dmatimo[i]-1);
@


1.6
log
@More changes of carrel@@netbsd.org's that I missed.
@
text
@d1 2
a2 2
/*	$OpenBSD: dma.c,v 1.5 1997/02/03 04:47:22 downsj Exp $	*/
/*	$NetBSD: dma.c,v 1.12 1997/01/31 23:01:25 carrel Exp $	*/
d52 1
d54 1
a58 5
#include <hp300/hp300/isr.h>

extern u_int kvtop();
extern void PCIA();

d202 1
a202 1
		isrunlink(sc->sc_ih);
d209 1
a209 1
	sc->sc_ih = isrlink(dmaintr, sc, sc->sc_ipl, ISRPRI_BIO);
d277 1
a277 1
#if defined(HP340) || defined(HP360) || defined(HP370) || defined(HP380)
d327 3
a329 3
	register char *addr;
	register int count;
	register int flags;
d332 3
a334 3
	register struct dma_channel *dc = &sc->sc_chan[unit];
	register char *dmaend = NULL;
	register int seg, tcount;
d344 1
a344 1
		printf("dmago(%d, %x, %x, %x)\n",
d363 1
a363 1
			DCFP(dc->dm_chain[seg].dc_addr);
d426 1
a426 1
#if defined(HP340) || defined(HP360) || defined(HP370)
d450 2
a451 2
		if ((dmadebug&DDB_WORD) && (dc->dm_cmd&DMA_WORD) ||
		    (dmadebug&DDB_LWORD) && (dc->dm_cmd&DMA_LWORD)) {
d455 1
a455 1
				printf("  %d: %d@@%x\n", seg,
d467 1
a467 1
	register int unit;
d470 1
a470 2
	register struct dma_channel *dc = &sc->sc_chan[unit];
	struct dmaqueue *dq;
d478 1
a478 1
#if defined(HP340) || defined(HP360) || defined(HP370) || defined(HP380)
d513 2
a514 2
	register struct dma_channel *dc;
	register int i, stat;
d529 2
a530 2
			if ((dmadebug&DDB_WORD) && (dc->dm_cmd&DMA_WORD) ||
			    (dmadebug&DDB_LWORD) && (dc->dm_cmd&DMA_LWORD))
d566 1
a566 1
	register int i, s;
@


1.5
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: dma.c,v 1.4 1997/01/12 15:12:28 downsj Exp $	*/
/*	$NetBSD: dma.c,v 1.11 1997/01/30 09:04:33 thorpej Exp $	*/
d280 1
a280 1
#if defined(HP360) || defined(HP370) || defined(HP380)
d429 1
a429 1
#if defined(HP360) || defined(HP370)
d482 1
a482 1
#if defined(HP360) || defined(HP370) || defined(HP380)
@


1.4
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: dma.c,v 1.10 1996/12/09 03:09:51 thorpej Exp $	*/
d5 2
a6 1
 * Copyright (c) 1995, 1996 Jason R. Thorpe.  All rights reserved.
d50 1
a53 1
#include <hp300/dev/device.h>
a58 2
extern void _insque();
extern void _remque();
d76 1
d82 2
a83 2
	struct	dma_chain *dm_cur;		/* current segment */
	struct	dma_chain *dm_last;		/* last segment */
d91 1
a105 1
struct	devqueue dmachan[NDMACHAN + 1];
d157 2
d162 1
a177 1
		dmachan[i].dq_forw = dmachan[i].dq_back = &dmachan[i];
d179 1
a179 1
	dmachan[i].dq_forw = dmachan[i].dq_back = &dmachan[i];
d217 1
a217 1
	register struct devqueue *dq;
d219 14
a232 7
	register int i;
	register int chan;
	register int s = splbio();

	chan = dq->dq_ctlr;
	i = NDMACHAN;
	while (--i >= 0) {
d235 5
a239 1
		if (dmachan[i].dq_forw != &dmachan[i])
d241 6
a246 2
		insque(dq, &dmachan[i]);
		dq->dq_ctlr = i;
d248 1
a248 1
		return(1);
d250 5
a254 1
	insque(dq, dmachan[NDMACHAN].dq_back);
d256 1
a256 1
	return(0);
d261 1
a261 1
	register struct devqueue *dq;
d263 1
a263 1
	int unit = dq->dq_ctlr;
d265 9
a273 3
	register struct dma_channel *dc = &sc->sc_chan[unit];
	register struct devqueue *dn;
	register int chan, s;
a274 1
	s = splbio();
d278 1
d304 5
a308 1
	remque(dq);
d310 7
a316 5
	for (dn = dmachan[NDMACHAN].dq_forw;
	     dn != &dmachan[NDMACHAN]; dn = dn->dq_forw) {
		if (dn->dq_ctlr & chan) {
			remque((caddr_t)dn);
			insque((caddr_t)dn, (caddr_t)dq->dq_back);
d318 3
a320 2
			dn->dq_ctlr = dq->dq_ctlr;
			(dn->dq_driver->d_start)(dn->dq_unit);
a335 1
	register struct dma_chain *dcp;
d337 1
a337 1
	register int tcount;
d359 2
a360 2
	for (dcp = dc->dm_chain; count > 0; dcp++) {
		dcp->dc_addr = (char *) kvtop(addr);
d366 1
a366 1
			DCFP(dcp->dc_addr);
d370 1
a370 1
		dcp->dc_count = tcount;
d377 6
a382 1
		if (dcp->dc_addr == dmaend
d386 1
a386 1
			(dcp-1)->dc_count + tcount <= 65536)
d392 2
a393 2
			dmaend += dcp->dc_count;
			(--dcp)->dc_count += tcount;
d398 3
a400 2
			dmaend = dcp->dc_addr + dcp->dc_count;
			dcp->dc_count = tcount;
d403 2
a404 2
	dc->dm_cur = dc->dm_chain;
	dc->dm_last = --dcp;
d452 1
a452 1
	if (dmadebug & DDB_IO)
d457 4
a460 3
			for (dcp = dc->dm_chain; dcp <= dc->dm_last; dcp++)
				printf("  %d: %d@@%x\n", dcp-dc->dm_chain,
				       dcp->dc_count, dcp->dc_addr);
d462 1
d474 1
a474 1
	register struct devqueue *dq;
d508 2
a509 3
	dq = dmachan[unit].dq_forw;
	if (dq != &dmachan[unit])
		(dq->dq_driver->d_done)(dq->dq_unit);
d535 2
a536 2
				printf("dmaintr: unit %d stat %x next %d\n",
				       i, stat, (dc->dm_cur-dc->dm_chain)+1);
d542 5
a546 1
		if (++dc->dm_cur <= dc->dm_last) {
d551 2
a552 1
			 * Last chain segment, disable DMA interrupt.
d577 2
a578 2
				printf("%s: timeout #%d\n", sc->sc_xname,
				       i, dmatimo[i]-1);
@


1.3
log
@sync w/ Net 960424
@
text
@d1 2
a2 1
/*	$NetBSD: dma.c,v 1.7 1996/02/14 02:44:17 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995 Jason R. Thorpe.
a57 1
extern void isrlink();
d92 2
d145 1
a145 1
	 * DMAINTLVL is set to 3).
d186 25
a210 2
	/* Establish the interrupt handler */
	isrlink(dmaintr, sc, DMAINTLVL, ISRPRI_BIO);
d370 1
a370 1
	dc->dm_cmd = DMA_ENAB | DMA_IPL(DMAINTLVL) | DMA_START;
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: dma.c,v 1.6 1995/12/02 02:46:45 thorpej Exp $	*/
d104 1
a104 1
int	dmaintr();
d183 3
d448 2
a449 1
dmaintr()
d451 1
a451 1
	struct dma_softc *sc = &Dma_softc;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dma.c,v 1.5 1994/10/26 07:23:40 cgd Exp $	*/
d4 1
d76 11
d88 5
a92 9
	struct	dmadevice *sc_hwaddr;
	struct	dmaBdevice *sc_Bhwaddr;
	char	sc_type;
	char	sc_flags;
	u_short	sc_cmd;
	struct	dma_chain *sc_cur;
	struct	dma_chain *sc_last;
	struct	dma_chain sc_chain[DMAMAXIO];
} dma_softc[NDMA];
d103 1
a103 1
struct	devqueue dmachan[NDMA + 1];
d114 1
a114 1
int	dmatimo[NDMA];
d116 5
a120 5
long	dmahits[NDMA];
long	dmamisses[NDMA];
long	dmabyte[NDMA];
long	dmaword[NDMA];
long	dmalword[NDMA];
d126 4
a129 3
	register struct dmareg *dma = (struct dmareg *)DMA_BASE;
	register struct dma_softc *dc;
	register int i;
d132 5
d138 4
a141 2
	 * Determine the DMA type.
	 * Don't know how to easily differentiate the A and B cards,
d145 1
a145 3
	if (!badbaddr((char *)&dma->dma_id[2]))
		rev = dma->dma_id[2];
	else {
d150 4
a153 1
	}
d155 18
a172 6
	dc = &dma_softc[0];
	for (i = 0; i < NDMA; i++) {
		dc->sc_hwaddr = (i & 1) ? &dma->dma_chan1 : &dma->dma_chan0;
		dc->sc_Bhwaddr = (i & 1) ? &dma->dma_Bchan1 : &dma->dma_Bchan0;
		dc->sc_type = rev == 'B' ? DMA_B : DMA_C;
		dc++;
d178 1
a178 1
	timeout(dmatimeout, (void *)0, 30 * hz);
d181 2
a182 2
	printf("dma: 98620%c with 2 channels, %d bit DMA\n",
	       rev, rev == 'B' ? 16 : 32);
d194 1
a194 1
	i = NDMA;
d205 1
a205 1
	insque(dq, dmachan[NDMA].dq_back);
d215 2
a216 1
	register struct dma_softc *dc = &dma_softc[unit];
d229 1
a229 1
	if (dc->sc_flags & DMAF_PCFLUSH) {
d231 1
a231 1
		dc->sc_flags &= ~DMAF_PCFLUSH;
d235 1
a235 1
	if (dc->sc_flags & DMAF_VCFLUSH) {
d246 1
a246 1
		dc->sc_flags &= ~DMAF_VCFLUSH;
d251 2
a252 2
	for (dn = dmachan[NDMA].dq_forw;
	     dn != &dmachan[NDMA]; dn = dn->dq_forw) {
d272 2
a273 1
	register struct dma_softc *dc = &dma_softc[unit];
d281 1
a281 1
	if (dc->sc_type == DMA_B && (flags & DMAGO_LWORD))
d298 1
a298 1
	for (dcp = dc->sc_chain; count > 0; dcp++) {
d319 1
a319 1
		    && (dc->sc_type != DMA_B ||
d336 3
a338 3
	dc->sc_cur = dc->sc_chain;
	dc->sc_last = --dcp;
	dc->sc_flags = 0;
d342 1
a342 1
	dc->sc_cmd = DMA_ENAB | DMA_IPL(DMAINTLVL) | DMA_START;
d344 1
a344 1
		dc->sc_cmd |= DMA_WRT;
d346 1
a346 1
		dc->sc_cmd |= DMA_LWORD;
d348 1
a348 1
		dc->sc_cmd |= DMA_WORD;
d350 1
a350 1
		dc->sc_cmd |= DMA_PRI;
d360 1
a360 1
		dc->sc_flags |= DMAF_PCFLUSH;
d368 1
a368 1
		dc->sc_flags |= DMAF_PCFLUSH;
d372 1
a372 1
		dc->sc_flags |= DMAF_VCFLUSH;
d379 2
a380 2
		if (dc->sc_cur == dc->sc_last)
			dc->sc_cmd &= ~DMA_ENAB;
d382 1
a382 1
			dc->sc_flags |= DMAF_NOINTR;
d386 2
a387 2
		if ((dmadebug&DDB_WORD) && (dc->sc_cmd&DMA_WORD) ||
		    (dmadebug&DDB_LWORD) && (dc->sc_cmd&DMA_LWORD)) {
d389 3
a391 3
			       dc->sc_cmd, dc->sc_flags);
			for (dcp = dc->sc_chain; dcp <= dc->sc_last; dcp++)
				printf("  %d: %d@@%x\n", dcp-dc->sc_chain,
d403 2
a404 1
	register struct dma_softc *dc = &dma_softc[unit];
d414 1
a414 1
	if (dc->sc_flags & DMAF_PCFLUSH) {
d416 1
a416 1
		dc->sc_flags &= ~DMAF_PCFLUSH;
d420 1
a420 1
	if (dc->sc_flags & DMAF_VCFLUSH) {
d431 1
a431 1
		dc->sc_flags &= ~DMAF_VCFLUSH;
d447 2
a448 1
	register struct dma_softc *dc;
d456 2
a457 1
	for (i = 0, dc = dma_softc; i < NDMA; i++, dc++) {
d464 2
a465 2
			if ((dmadebug&DDB_WORD) && (dc->sc_cmd&DMA_WORD) ||
			    (dmadebug&DDB_LWORD) && (dc->sc_cmd&DMA_LWORD))
d467 1
a467 1
				       i, stat, (dc->sc_cur-dc->sc_chain)+1);
d470 2
a471 1
			printf("dma%d: intr when armed\n", i);
d473 1
a473 1
		if (++dc->sc_cur <= dc->sc_last) {
d480 3
a482 3
			if (dc->sc_cur == dc->sc_last &&
			    (dc->sc_flags & DMAF_NOINTR))
				dc->sc_cmd &= ~DMA_ENAB;
d497 1
d499 1
a499 1
	for (i = 0; i < NDMA; i++) {
d503 1
a503 1
				printf("dma%d: timeout #%d\n",
d509 1
a509 1
	timeout(dmatimeout, (void *)0, 30 * hz);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
