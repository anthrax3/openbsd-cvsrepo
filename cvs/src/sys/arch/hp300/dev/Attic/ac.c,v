head	1.14;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.20
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.18
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.16
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.14
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2004.08.03.21.46.56;	author miod;	state dead;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.25.20.40.36;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.29.20.15.43;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.30.11.03.52;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.31.10.21.01;	author art;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	97.04.20.07.01.11;	author downsj;	state Exp;
branches
	1.7.14.1;
next	1.6;

1.6
date	97.04.16.11.55.56;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.02.03.04.47.11;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.12.15.12.17;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.23;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.17;	author deraadt;	state Exp;
branches;
next	;

1.7.14.1
date	2001.07.04.10.15.24;	author niklas;	state Exp;
branches;
next	1.7.14.2;

1.7.14.2
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.7.14.3;

1.7.14.3
date	2003.03.27.23.19.19;	author niklas;	state Exp;
branches;
next	1.7.14.4;

1.7.14.4
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Replace the old 4.4BSD scsi code used on hp300 with a ``real'' driver
interfaced with the MI scsi code.

Adapted from NetBSD with some changes (especially to get tape and old
cd-rom drives to not cause the driver to spin during probe).

Tested by millert@@ and I, ok millert@@
@
text
@/*	$OpenBSD: ac.c,v 1.13 2003/06/02 23:27:44 millert Exp $	*/
/*	$NetBSD: ac.c,v 1.9 1997/04/02 22:37:21 scottr Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1991 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: ac.c 1.5 92/01/21$
 *
 *	@@(#)ac.c	8.2 (Berkeley) 1/12/94
 */

/*
 * SCSI driver for MO autochanger.
 *
 * Very crude.  Because of the lack of connect/disconnect support in the
 * scsi driver, this driver can tie up the SCSI bus for a long time.  It
 * also grabs a DMA channel and holds it for the duration even though it
 * never uses it.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>

#include <sys/conf.h>

#include <hp300/dev/scsireg.h>
#include <hp300/dev/scsivar.h>
#include <hp300/dev/acioctl.h>
#include <hp300/dev/acvar.h>

bdev_decl(ac);
cdev_decl(ac);

static int	acmatch(struct device *, void *, void *);
static void	acattach(struct device *, struct device *, void *);

struct cfattach ac_ca = {
	sizeof(struct ac_softc), acmatch, acattach
};

struct cfdriver ac_cd = {
	NULL, "ac", DV_DULL
};

void	acstart(void *);
void	acgo(void *);
void	acintr(void *, int);

#ifdef DEBUG
int ac_debug = 0x0000;
#define ACD_FOLLOW	0x0001
#define ACD_OPEN	0x0002
#endif

static int
acmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct oscsi_attach_args *osa = aux;

	if (osa->osa_inqbuf->type != 8 || osa->osa_inqbuf->qual != 0x80 ||
	    osa->osa_inqbuf->version != 2)
		return (0);

	return (1);
}

static void
acattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ac_softc *sc = (struct ac_softc *)self;
	struct oscsi_attach_args *osa = aux;

	printf("\n");

	sc->sc_target = osa->osa_target;
	sc->sc_lun = osa->osa_lun;

	/* Initialize SCSI queue entry. */
	sc->sc_sq.sq_softc = sc;
	sc->sc_sq.sq_target = sc->sc_target;
	sc->sc_sq.sq_lun = sc->sc_lun;
	sc->sc_sq.sq_start = acstart;
	sc->sc_sq.sq_go = acgo;
	sc->sc_sq.sq_intr = acintr;

	sc->sc_bp = (struct buf *)malloc(sizeof(struct buf),
	    M_DEVBUF, M_NOWAIT);
	sc->sc_cmd = (struct scsi_fmt_cdb *)malloc(sizeof(struct scsi_fmt_cdb),
	    M_DEVBUF, M_NOWAIT);

	if (sc->sc_bp == NULL || sc->sc_cmd == NULL) {
		printf("%s: memory allocation failed\n", sc->sc_dev.dv_xname);
		return;
	}

	sc->sc_flags = ACF_ALIVE;
}

/*ARGSUSED*/
int
acopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = minor(dev);
	struct ac_softc *sc;

	if (unit >= ac_cd.cd_ndevs ||
	    (sc = ac_cd.cd_devs[unit]) == NULL ||
	    (sc->sc_flags & ACF_ALIVE) == 0)
		return (ENXIO);

	if (sc->sc_flags & ACF_OPEN)
		return (EBUSY);

	/*
	 * Since acgeteinfo can block we mark the changer open now.
	 */
	sc->sc_flags |= ACF_OPEN;
	if (acgeteinfo(dev)) {
		sc->sc_flags &= ~ACF_OPEN;
		return(EIO);
	}
	return (0);
}

/*ARGSUSED*/
int
acclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct ac_softc *sc = ac_cd.cd_devs[minor(dev)];

	sc->sc_flags &= ~ACF_OPEN;
	return (0);
}

#define ACRESLEN(ep)	\
	(8 + (ep)->nmte*12 + (ep)->nse*12 + (ep)->niee*12 + (ep)->ndte*20)

/*ARGSUSED*/
int
acioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data; 
	int flag;
	struct proc *p;
{
	struct ac_softc *sc = ac_cd.cd_devs[minor(dev)];
	char *dp;
	int dlen, error = 0;

	switch (cmd) {

	default:
		return (EINVAL);

	/* perform an init element status and mode sense to reset state */
	case ACIOCINIT:
		error = accommand(dev, ACCMD_INITES, (caddr_t)0, 0);
		if (!error)
			error = acgeteinfo(dev);
		break;

	/* copy internal element information */
	case ACIOCGINFO:
		*(struct acinfo *)data = sc->sc_einfo;
		break;

	case ACIOCRAWES:
	{
		struct acbuffer *acbp = (struct acbuffer *)data;

		dlen = ACRESLEN(&sc->sc_einfo);
		dp = (char *) malloc(dlen, M_DEVBUF, M_WAITOK);
		error = accommand(dev, ACCMD_READES, dp, dlen);
		if (!error) {
			dlen = *(int *)&dp[4] + 8;
			if (dlen > acbp->buflen)
				dlen = acbp->buflen;
			error = copyout(dp, acbp->bufptr, dlen);
		}
		break;
	}

	case ACIOCGSTAT:
	{
		struct acbuffer *acbp = (struct acbuffer *)data;

		dlen = ACRESLEN(&sc->sc_einfo);
		dp = (char *) malloc(dlen, M_DEVBUF, M_WAITOK);
		error = accommand(dev, ACCMD_READES, dp, dlen);
		if (!error) {
			int ne;
			char *tbuf;

			ne = sc->sc_einfo.nmte + sc->sc_einfo.nse +
				sc->sc_einfo.niee + sc->sc_einfo.ndte;
			dlen = ne * sizeof(struct aceltstat);
			tbuf = (char *) malloc(dlen, M_DEVBUF, M_WAITOK);
			acconvert(dp, tbuf, ne);
			if (dlen > acbp->buflen)
				dlen = acbp->buflen;
			error = copyout(tbuf, acbp->bufptr, dlen);
			free(tbuf, M_DEVBUF);
		}
		free(dp, M_DEVBUF);
		break;
	}

	case ACIOCMOVE:
		error = accommand(dev, ACCMD_MOVEM, data,
				  sizeof(struct acmove));
		break;
	}
	return(error);
}

int
accommand(dev, command, bufp, buflen)
	dev_t dev;
	int command;
	char *bufp;
	int buflen;
{
	int unit = minor(dev);
	struct ac_softc *sc = ac_cd.cd_devs[unit];
	struct buf *bp = sc->sc_bp;
	struct scsi_fmt_cdb *cmd = sc->sc_cmd;
	int error;

#ifdef DEBUG
	if (ac_debug & ACD_FOLLOW)
		printf("accommand(dev=%x, cmd=%x, buf=%p, buflen=%x)\n",
		       dev, command, bufp, buflen);
#endif
	if (sc->sc_flags & ACF_ACTIVE)
		panic("accommand: active!");

	sc->sc_flags |= ACF_ACTIVE;
	bzero((caddr_t)cmd->cdb, sizeof(cmd->cdb));
	cmd->cdb[0] = command;

	switch (command) {
	case ACCMD_INITES:
		cmd->len = 6;
		break;
	case ACCMD_READES:
		cmd->len = 12;
		*(short *)&cmd->cdb[2] = 0;
		*(short *)&cmd->cdb[4] =
			sc->sc_einfo.nmte + sc->sc_einfo.nse +
			sc->sc_einfo.niee + sc->sc_einfo.ndte;
		cmd->cdb[7] = buflen >> 16;
		cmd->cdb[8] = buflen >> 8;
		cmd->cdb[9] = buflen;
		break;
	case ACCMD_MODESENSE:
		cmd->len = 6;
		cmd->cdb[2] = 0x3F;	/* all pages */
		cmd->cdb[4] = buflen;
		break;
	case ACCMD_MOVEM:
		cmd->len = 12;
		*(short *)&cmd->cdb[2] = sc->sc_picker;
		*(short *)&cmd->cdb[4] = *(short *)&bufp[0];
		*(short *)&cmd->cdb[6] = *(short *)&bufp[2];
		if (*(short *)&bufp[4] & AC_INVERT)
			cmd->cdb[10] = 1;
		bufp = 0;
		buflen = 0;
		break;
	default:
		panic("accommand: bad command");
	}
	bp->b_flags = B_BUSY|B_READ;
	bp->b_dev = dev;
	bp->b_un.b_addr = bufp;
	bp->b_bcount = buflen;
	bp->b_resid = 0;
	bp->b_blkno = 0;
	bp->b_error = 0;
	LIST_INIT(&bp->b_dep);
	if (scsireq(sc->sc_dev.dv_parent, &sc->sc_sq))
		acstart(sc);
	error = biowait(bp);
	sc->sc_flags &= ~ACF_ACTIVE;
	return (error);
}

void
acstart(arg)
	void *arg;
{
	struct ac_softc *sc = arg;

#ifdef DEBUG
	if (ac_debug & ACD_FOLLOW)
		printf("acstart(unit=%x)\n", sc->sc_dev.dv_unit);
#endif
	if (scsiustart(sc->sc_dev.dv_parent->dv_unit))
		acgo(arg);
}

void
acgo(arg)
	void *arg;
{
	struct ac_softc *sc = arg;
	struct buf *bp = sc->sc_bp;
	int stat;
	int s;

#ifdef DEBUG
	if (ac_debug & ACD_FOLLOW)
		printf("acgo(unit=%x): ", sc->sc_dev.dv_unit);
#endif
	stat = scsigo(sc->sc_dev.dv_parent->dv_unit, sc->sc_target,
	    sc->sc_lun, bp, sc->sc_cmd, 0);
#ifdef DEBUG
	if (ac_debug & ACD_FOLLOW)
		printf("scsigo returns %x\n", stat);
#endif
	if (stat) {
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(bp);
		splx(s);
		scsifree(sc->sc_dev.dv_parent, &sc->sc_sq);
	}
}

void
acintr(arg, stat)
	void *arg;
	int stat;
{
	struct ac_softc *sc = arg;
	struct buf *bp = sc->sc_bp;
	u_char sensebuf[78];
	struct scsi_xsense *sp;

#ifdef DEBUG
	if (ac_debug & ACD_FOLLOW)
		printf("acintr(unit=%x, stat=%x)\n", sc->sc_dev.dv_unit, stat);
#endif
	switch (stat) {
	case 0:
		bp->b_resid = 0;
		break;
	case STS_CHECKCOND:
		scsi_request_sense(sc->sc_dev.dv_parent->dv_unit,
		    sc->sc_target, sc->sc_lun, sensebuf, sizeof sensebuf);
		sp = (struct scsi_xsense *)sensebuf;
		printf("%s: acintr sense key=%x, ac=%x, acq=%x\n",
		       sc->sc_dev.dv_xname, sp->key, sp->info4, sp->len);
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
		break;
	default:
		printf("%s: acintr unknown status 0x%x\n", sc->sc_dev.dv_xname,
		    stat);
		break;
	}
	biodone(sc->sc_bp);
	scsifree(sc->sc_dev.dv_parent, &sc->sc_sq);
}

int
acgeteinfo(dev)
	dev_t dev;
{
	struct ac_softc *sc = ac_cd.cd_devs[minor(dev)];
	char *bp;
	char msbuf[48];
	int error;

	bzero(msbuf, sizeof msbuf);
	error = accommand(dev, ACCMD_MODESENSE, msbuf, sizeof msbuf);
	if (error)
		return(error);
	bp = &msbuf[4];
	while (bp < &msbuf[48]) {
		switch (bp[0] & 0x3F) {
		case 0x1D:
			sc->sc_einfo = *(struct acinfo *)&bp[2];
			sc->sc_picker = sc->sc_einfo.fmte;	/* XXX */
			return(0);
		case 0x1E:
			bp += 4;
			break;
		case 0x1F:
			bp += 20;
			break;
		default:
			printf("acgeteinfo: bad page type %x\n", bp[0]);
			return(EIO);
		}
	}
	return(EIO);
}

void
acconvert(sbuf, dbuf, ne)
	char *sbuf, *dbuf;
	int ne;
{
	struct aceltstat *ep = (struct aceltstat *)dbuf;
	struct ac_restatphdr *phdr;
	struct ac_restatdb *dbp;
	struct ac_restathdr *hdr;
#ifdef DEBUG
	int bcount;
#endif

	hdr = (struct ac_restathdr *)&sbuf[0];
	sbuf += sizeof *hdr;
#ifdef DEBUG
	if (ac_debug & ACD_FOLLOW)
		printf("element status: first=%d, num=%d, len=%ld\n",
		       hdr->ac_felt, hdr->ac_nelt, hdr->ac_bcount);
	if (hdr->ac_nelt != ne) {
		printf("acconvert: # of elements, %d != %d\n",
		       hdr->ac_nelt, ne);
		if (hdr->ac_nelt < ne)
			ne = hdr->ac_nelt;
	}
	bcount = hdr->ac_bcount;
#endif
	while (ne) {
		phdr = (struct ac_restatphdr *)sbuf;
		sbuf += sizeof *phdr;
#ifdef DEBUG
		bcount -= sizeof *phdr;
#endif
		dbp = (struct ac_restatdb *)sbuf;
		sbuf += phdr->ac_bcount;
#ifdef DEBUG
		bcount -= phdr->ac_bcount;
#endif
		while (dbp < (struct ac_restatdb *)sbuf) {
			ep->type = phdr->ac_type;
			ep->eaddr = dbp->ac_eaddr;
			ep->flags = 0;
			if (dbp->ac_full)
				ep->flags |= AC_FULL;
			if (dbp->ac_exc)
				ep->flags |= AC_ERROR;
			if (dbp->ac_acc)
				ep->flags |= AC_ACCESS;
			dbp = (struct ac_restatdb *)
				((char *)dbp + phdr->ac_dlen);
			ep++;
			ne--;
		}
#ifdef DEBUG
		if (ne < 0 || bcount < 0)
			panic("acconvert: inconsistent");
#endif
	}
}
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.12 2002/12/25 20:40:36 miod Exp $	*/
@


1.12
log
@Get prototypes from *dev_decl() macros rather than running our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.11 2002/11/29 20:15:43 deraadt Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@inconsistant spelling; torh@@bogus.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.10 2002/05/30 11:03:52 art Exp $	*/
d65 2
d72 2
a73 5
/* cdev_decl(ac); */
/* XXX we should use macros to do these... */
int	acopen(dev_t, int, int, struct proc *);
int	acclose(dev_t, int, int, struct proc *);
int	acioctl(dev_t, u_long, caddr_t, int, struct proc *);
@


1.10
log
@protect biodone with splbio.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.9 2002/03/14 01:26:30 millert Exp $	*/
d509 1
a509 1
			panic("acconvert: inconsistant");
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.8 2001/05/31 10:21:01 art Exp $	*/
d362 1
d377 3
a379 1
		(void) biodone(bp);
d416 1
a416 1
	(void) biodone(sc->sc_bp);
@


1.8
log
@Initialize bp->b_dep if we malloc our own struct buf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.7 1997/04/20 07:01:11 downsj Exp $	*/
d72 3
a74 3
int	acopen __P((dev_t, int, int, struct proc *));
int	acclose __P((dev_t, int, int, struct proc *));
int	acioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
d76 2
a77 2
static int	acmatch __P((struct device *, void *, void *));
static void	acattach __P((struct device *, struct device *, void *));
d87 3
a89 3
void	acstart __P((void *));
void	acgo __P((void *));
void	acintr __P((void *, int));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.8 2001/05/31 10:21:01 art Exp $	*/
d72 3
a74 3
int	acopen(dev_t, int, int, struct proc *);
int	acclose(dev_t, int, int, struct proc *);
int	acioctl(dev_t, u_long, caddr_t, int, struct proc *);
d76 2
a77 2
static int	acmatch(struct device *, void *, void *);
static void	acattach(struct device *, struct device *, void *);
d87 3
a89 3
void	acstart(void *);
void	acgo(void *);
void	acintr(void *, int);
a361 1
	int s;
d376 1
a376 3
		s = splbio();
		biodone(bp);
		splx(s);
d413 1
a413 1
	biodone(sc->sc_bp);
@


1.8.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a64 2
#include <sys/conf.h>

d70 5
a74 2
bdev_decl(ac);
cdev_decl(ac);
d509 1
a509 1
			panic("acconvert: inconsistent");
@


1.7
log
@Make -Wall work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.6 1997/04/16 11:55:56 downsj Exp $	*/
d333 1
@


1.7.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.7 1997/04/20 07:01:11 downsj Exp $	*/
a332 1
	LIST_INIT(&bp->b_dep);
@


1.7.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 3
a74 3
int	acopen(dev_t, int, int, struct proc *);
int	acclose(dev_t, int, int, struct proc *);
int	acioctl(dev_t, u_long, caddr_t, int, struct proc *);
d76 2
a77 2
static int	acmatch(struct device *, void *, void *);
static void	acattach(struct device *, struct device *, void *);
d87 3
a89 3
void	acstart(void *);
void	acgo(void *);
void	acintr(void *, int);
@


1.7.14.3
log
@Sync the SMP branch with 3.3
@
text
@a64 2
#include <sys/conf.h>

d70 5
a74 2
bdev_decl(ac);
cdev_decl(ac);
a361 1
	int s;
d376 1
a376 3
		s = splbio();
		biodone(bp);
		splx(s);
d413 1
a413 1
	biodone(sc->sc_bp);
d506 1
a506 1
			panic("acconvert: inconsistent");
@


1.7.14.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.7.14.3 2003/03/27 23:19:19 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ac.c,v 1.5 1997/02/03 04:47:11 downsj Exp $
@


1.5
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ac.c,v 1.4 1997/01/12 15:12:17 downsj Exp $
/*	$NetBSD: ac.c,v 1.7 1997/01/30 09:14:10 thorpej Exp $	*/
d57 1
d59 1
a63 1
#include <sys/device.h>
a66 1

d70 8
a77 2
int	acmatch __P((struct device *, void *, void *));
void	acattach __P((struct device *, struct device *, void *));
d97 1
a97 1
int
d111 1
a111 1
void
d146 1
d152 1
a152 1
	register int unit = minor(dev);
a153 1
	int error = 0;
d175 1
d191 1
d194 1
a194 1
	int cmd;
d269 1
d278 2
a279 2
	register struct buf *bp = sc->sc_bp;
	register struct scsi_fmt_cdb *cmd = sc->sc_cmd;
d284 1
a284 1
		printf("accommand(dev=%x, cmd=%x, buf=%x, buflen=%x)\n",
d348 1
a348 1
		printf("acstart(unit=%x)\n", unit);
d359 1
a359 1
	register struct buf *bp = sc->sc_bp;
d364 1
a364 1
		printf("acgo(unit=%x): ", unit);
d385 2
a386 2
	register struct ac_softc *sc = arg;
	register struct buf *bp = sc->sc_bp;
a388 1
	int unit = sc->sc_dev.dv_unit;
d392 1
a392 1
		printf("acintr(unit=%x, stat=%x)\n", unit, stat);
d416 1
d421 1
a421 1
	register char *bp;
d450 1
d455 3
a457 3
	register struct aceltstat *ep = (struct aceltstat *)dbuf;
	register struct ac_restatphdr *phdr;
	register struct ac_restatdb *dbp;
d460 1
a460 1
	register int bcount;
d467 1
a467 1
		printf("element status: first=%d, num=%d, len=%d\n",
@


1.4
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$
/*	$NetBSD: ac.c,v 1.6 1996/10/13 03:14:05 christos Exp $	*/
d5 1
a55 3
#include "ac.h"
#if NAC > 0

d62 1
a63 1
#include <hp300/dev/device.h>
d65 2
d70 2
a71 8
extern int scsi_test_unit_rdy();
extern int scsi_request_sense();
extern int scsiustart();
extern int scsigo();
extern void scsifree();
extern void scsireset();
extern void scsi_delay();
extern void scsi_str __P((char *, char *, size_t));
d73 3
a75 4
extern int scsi_immed_command();

int	acmatch(), acstart(), acgo(), acintr();
void	acattach();
d77 2
a78 2
struct	driver acdriver = {
	acmatch, acattach, "ac", acstart, acgo, acintr,
d81 3
a83 3
struct	ac_softc ac_softc[NAC];
static	struct buf acbuf[NAC];
static	struct scsi_fmt_cdb accmd[NAC];
d92 3
a94 2
acmatch(hd)
	register struct hp_device *hd;
d96 1
a96 2
	int unit = hd->hp_unit;
	register struct ac_softc *sc = &ac_softc[unit];
d98 2
a99 3
	sc->sc_hd = hd;
	sc->sc_punit = hd->hp_flags & 7;
	if (acident(sc, hd, 0) < 0)
d106 29
a134 5
acattach(hd)
	register struct hp_device *hd;
{
	int unit = hd->hp_unit;
	register struct ac_softc *sc = &ac_softc[unit];
a135 9
	(void)acident(sc, hd, 1);	/* XXX Ick. */

	sc->sc_dq.dq_softc = sc;
	sc->sc_dq.dq_unit = unit;
	sc->sc_dq.dq_ctlr = hd->hp_ctlr;
	sc->sc_dq.dq_slave = hd->hp_slave;
	sc->sc_dq.dq_driver = &acdriver;
	sc->sc_bp = &acbuf[unit];
	sc->sc_cmd = &accmd[unit];
a138 71
acident(sc, hd, verbose)
	register struct ac_softc *sc;
	register struct hp_device *hd;
	int verbose;
{
	int unit;
	register int ctlr, slave;
	int i, stat;
	int tries = 5;
	struct scsi_inquiry inqbuf;
	char vendor[9], product[17], revision[5];
	static struct scsi_fmt_cdb inq = {
		6,
		CMD_INQUIRY, 0, 0, 0, sizeof(inqbuf), 0
	};

	ctlr = hd->hp_ctlr;
	slave = hd->hp_slave;
	unit = sc->sc_punit;
	scsi_delay(-1);

	/*
	 * See if device is ready
	 */
	while ((i = scsi_test_unit_rdy(ctlr, slave, unit)) != 0) {
		if (i == -1 || --tries < 0)
			/* doesn't exist or not a CCS device */
			goto failed;
		if (i == STS_CHECKCOND) {
			u_char sensebuf[128];
			struct scsi_xsense *sp;

			scsi_request_sense(ctlr, slave, unit,
					   sensebuf, sizeof(sensebuf));
			sp = (struct scsi_xsense *) sensebuf;
			if (sp->class == 7 && sp->key == 6)
				/* drive doing an RTZ -- give it a while */
				DELAY(1000000);
		}
		DELAY(1000);
	}
	/*
	 * Find out if it is an autochanger
	 */
	if (scsi_immed_command(ctlr, slave, unit, &inq,
			       (u_char *)&inqbuf, sizeof(inqbuf), B_READ))
		goto failed;

	if (inqbuf.type != 8 || inqbuf.qual != 0x80 || inqbuf.version != 2)
		goto failed;

	/*
	 * Get a usable id string
	 */
	bzero(vendor, sizeof(vendor));
	bzero(product, sizeof(product));
	bzero(revision, sizeof(revision));
	scsi_str(inqbuf.vendor_id, vendor, sizeof(inqbuf.vendor_id));
	scsi_str(inqbuf.product_id, product, sizeof(inqbuf.product_id));
	scsi_str(inqbuf.rev, revision, sizeof(inqbuf.rev));

	if (verbose)
		printf(": <%s, %s, %s>\n", vendor, product, revision);

	scsi_delay(0);
	return(inqbuf.type);
failed:
	scsi_delay(0);
	return(-1);
}

d146 1
a146 1
	register struct ac_softc *sc = &ac_softc[unit];
d149 5
a153 2
	if (unit >= NAC || (sc->sc_flags & ACF_ALIVE) == 0)
		return(ENXIO);
d155 2
a156 1
		return(EBUSY);
d165 1
a165 1
	return(0);
d174 1
a174 1
	struct ac_softc *sc = &ac_softc[minor(dev)];
d177 1
d191 1
a191 1
	register struct ac_softc *sc = &ac_softc[minor(dev)];
d268 1
a268 1
	register struct ac_softc *sc = &ac_softc[unit];
d324 2
a325 2
	if (scsireq(&sc->sc_dq))
		acstart(unit);
d331 3
a333 2
acstart(unit)
	int unit;
d335 2
d341 2
a342 2
	if (scsiustart(ac_softc[unit].sc_hd->hp_ctlr))
		acgo(unit);
d345 3
a347 2
acgo(unit)
	int unit;
d349 1
a349 1
	register struct ac_softc *sc = &ac_softc[unit];
a350 1
	struct hp_device *hp = sc->sc_hd;
d357 2
a358 2
	stat = scsigo(hp->hp_ctlr, hp->hp_slave, sc->sc_punit,
		      bp, sc->sc_cmd, 0);
d367 1
a367 1
		scsifree(&sc->sc_dq);
d371 1
d380 1
a380 1
	int unit = sc->sc_hd->hp_unit;
d391 2
a392 2
		scsi_request_sense(sc->sc_hd->hp_ctlr, sc->sc_hd->hp_slave,
				   sc->sc_punit, sensebuf, sizeof sensebuf);
d395 1
a395 1
		       sc->sc_hd->hp_xname, sp->key, sp->info4, sp->len);
d400 1
a400 1
		printf("%s: acintr unknown status 0x%x\n", sc->sc_hd->hp_xname,
d405 1
a405 1
	scsifree(&sc->sc_dq);
d411 1
a411 1
	register struct ac_softc *sc = &ac_softc[minor(dev)];
a498 1
#endif
@


1.3
log
@sync w/ Net 960424
@
text
@d1 2
a2 1
/*	$NetBSD: ac.c,v 1.4 1996/02/14 02:43:54 thorpej Exp $	*/
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: ac.c,v 1.3 1995/12/02 18:21:49 thorpej Exp $	*/
d121 1
d426 3
a428 2
acintr(unit, stat)
	int unit, stat;
d430 1
a430 1
	register struct ac_softc *sc = &ac_softc[unit];
d434 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ac.c,v 1.2 1994/10/26 07:23:23 cgd Exp $	*/
d76 1
d80 2
a81 1
int	acinit(), acstart(), acgo(), acintr();
d84 1
a84 1
	acinit, "ac", acstart, acgo, acintr,
d97 2
a98 1
acinit(hd)
d106 15
a120 2
	if (acident(sc, hd) < 0)
		return(0);
a127 1
	return(1);
d130 1
a130 1
acident(sc, hd)
d133 1
a138 1
	char idstr[32];
d140 1
d181 12
a192 15
	bcopy((caddr_t)&inqbuf.vendor_id, (caddr_t)idstr, 28);
	for (i = 27; i > 23; --i)
		if (idstr[i] != ' ')
			break;
	idstr[i+1] = 0;
	for (i = 23; i > 7; --i)
		if (idstr[i] != ' ')
			break;
	idstr[i+1] = 0;
	for (i = 7; i >= 0; --i)
		if (idstr[i] != ' ')
			break;
	idstr[i+1] = 0;
	printf("ac%d: %s %s rev %s\n", hd->hp_unit,
	       &idstr[0], &idstr[8], &idstr[24]);
d445 2
a446 2
		printf("ac%d: acintr sense key=%x, ac=%x, acq=%x\n",
		       unit, sp->key, sp->info4, sp->len);
d451 2
a452 1
		printf("ac%d: acintr unknown status 0x%x\n", unit, stat);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
