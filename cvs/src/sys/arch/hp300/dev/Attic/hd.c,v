head	1.76;
access;
symbols
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.71.0.2
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.69.0.8
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.69.0.6
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.4
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.57.0.4
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.55.0.2
	OPENBSD_4_5_BASE:1.55
	OPENBSD_4_4:1.53.0.6
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.53.0.4
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.53.0.2
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.18
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.11.0.14
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.12
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.10
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.8
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.6
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.76
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.75;

1.75
date	2013.11.20.05.19.29;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2013.11.20.00.12.37;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2013.10.14.23.26.22;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2013.06.28.18.17.12;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2013.06.11.16.42.07;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.06.04.49.35;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.19.21.20.04;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2011.06.19.04.55.34;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2011.06.19.04.35.06;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.08.14.47.10;	author jsing;	state Exp;
branches;
next	1.61;

1.61
date	2010.05.23.10.49.19;	author dlg;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.23.15.25.20;	author jsing;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.24.08.52.13;	author jasper;	state Exp;
branches;
next	1.58;

1.58
date	2009.08.16.12.17.35;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.13.21.35.58;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.04.05.57.27;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2009.01.25.14.29.29;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.15.19.12.20;	author blambert;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.21.20.23.07;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.20.20.13.40;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.20.18.15.47;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.05.00.38.14;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.30.00.17.48;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.28.20.19.05;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.22.17.20.17;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.21.22.32.05;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.21.11.01.10;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.12.13.53.44;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.15.20.20.39;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.22.00.40.01;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.20.23.27.25;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.18.00.16.48;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.18.00.09.15;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.16.21.23.55;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.15.21.09.44;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.15.07.02.36;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.14.20.20.30;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.14.19.54.08;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.14.19.23.40;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.13.19.25.09;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.12.23.10.04;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.12.23.08.41;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.06.19.01.00;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.15.02.56.13;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.06.15.28.25;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.06.03.02.43;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.25.20.56.59;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.10.23.33.08;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.09.05.23.26;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.09.02.11.47;	author jsyn;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.30.11.03.52;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.20.17.02.30;	author mpech;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.08.26.00.15.36;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.01.16.51.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.10.04.01.02.26;	author millert;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	98.10.03.21.18.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.05.07.05.19.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.04.25.00.38.16;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.03.27.08.37.06;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.13.09.47.59;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.07.06.08.01.52;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.04.16.11.56.06;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.02.10.06.43.32;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.02.07.03.22.16;	author dima;	state Exp;
branches;
next	1.1;

1.1
date	97.02.03.08.11.54;	author downsj;	state Exp;
branches;
next	;

1.11.8.1
date	2001.07.04.10.15.29;	author niklas;	state Exp;
branches;
next	1.11.8.2;

1.11.8.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.11.8.3;

1.11.8.3
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.11.8.4;

1.11.8.4
date	2003.03.27.23.19.19;	author niklas;	state Exp;
branches;
next	1.11.8.5;

1.11.8.5
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.11.8.6;

1.11.8.6
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.11.8.7;

1.11.8.7
date	2004.06.05.23.10.46;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: hd.c,v 1.75 2013/11/20 05:19:29 miod Exp $	*/
/*	$NetBSD: rd.c,v 1.33 1997/07/10 18:14:08 kleink Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: rd.c 1.44 92/12/26$
 *
 *	@@(#)rd.c	8.2 (Berkeley) 5/19/94
 */

/*
 * CS80/SS80 disk driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/dkio.h>

#include <ufs/ffs/fs.h>			/* for BBSIZE and SBSIZE */

#include <hp300/dev/hpibvar.h>

#include <hp300/dev/hdreg.h>
#include <hp300/dev/hdvar.h>

#ifdef USELEDS
#include <hp300/hp300/leds.h>
#endif

#ifndef	HDRETRY
#define	HDRETRY		5
#endif

#ifndef	HDWAITC
#define HDWAITC		1	/* min time for timeout in seconds */
#endif

int	hderrthresh = HDRETRY - 1;	/* when to start reporting errors */

#ifdef DEBUG
/* error message tables */
const char *err_reject[16] = {
	NULL,
	NULL,
	"channel parity error",		/* 0x2000 */
	NULL,
	NULL,
	"illegal opcode",		/* 0x0400 */
	"module addressing",		/* 0x0200 */
	"address bounds",		/* 0x0100 */
	"parameter bounds",		/* 0x0080 */
	"illegal parameter",		/* 0x0040 */
	"message sequence",		/* 0x0020 */
	NULL,
	"message length",		/* 0x0008 */
	NULL,
	NULL,
	NULL
};

const char *err_fault[16] = {
	NULL,
	"cross unit",			/* 0x4000 */
	NULL,
	"controller fault",		/* 0x1000 */
	NULL,
	NULL,
	"unit fault",			/* 0x0200 */
	NULL,
	"diagnostic result",		/* 0x0080 */
	NULL,
	"operator release request",	/* 0x0020 */
	"diagnostic release request",	/* 0x0010 */
	"internal maintenance release request",	/* 0x0008 */
	NULL,
	"power fail",			/* 0x0002 */
	"retransmit"			/* 0x0001 */
};

const char *err_access[16] = {
	"illegal parallel operation",	/* 0x8000 */
	"uninitialized media",		/* 0x4000 */
	"no spares available",		/* 0x2000 */
	"not ready",			/* 0x1000 */
	"write protect",		/* 0x0800 */
	"no data found",		/* 0x0400 */
	NULL,
	NULL,
	"unrecoverable data overflow",	/* 0x0080 */
	"unrecoverable data",		/* 0x0040 */
	NULL,
	"end of file",			/* 0x0010 */
	"end of volume",		/* 0x0008 */
	NULL,
	NULL,
	NULL
};

const char *err_info[16] = {
	"operator release request",	/* 0x8000 */
	"diagnostic release request",	/* 0x4000 */
	"internal maintenance release request",	/* 0x2000 */
	"media wear",			/* 0x1000 */
	"latency induced",		/* 0x0800 */
	NULL,
	NULL,
	"auto sparing invoked",		/* 0x0100 */
	NULL,
	"recoverable data overflow",	/* 0x0040 */
	"marginal data",		/* 0x0020 */
	"recoverable data",		/* 0x0010 */
	NULL,
	"maintenance track overflow",	/* 0x0004 */
	NULL,
	NULL
};

#define HDB_FOLLOW	0x01
#define HDB_STATUS	0x02
#define HDB_IDENT	0x04
#define HDB_IO		0x08
#define HDB_ASYNC	0x10
#define HDB_ERROR	0x80
int	hddebug = HDB_ERROR | HDB_IDENT;
#endif

/*
 * Misc. HW description, indexed by sc_type.
 * Nothing really critical here, could do without it.
 */
const struct hdidentinfo hdidentinfo[] = {
	{ HD7946AID,	0,	"7945A",	NHD7945ABPT,
	  NHD7945ATRK,	968,	 108416 },

	{ HD9134DID,	1,	"9134D",	NHD9134DBPT,
	  NHD9134DTRK,	303,	  29088 },

	{ HD9134LID,	1,	"9122S",	NHD9122SBPT,
	  NHD9122STRK,	77,	   1232 },

	{ HD7912PID,	0,	"7912P",	NHD7912PBPT,
	  NHD7912PTRK,	572,	 128128 },

	{ HD7914PID,	0,	"7914P",	NHD7914PBPT,
	  NHD7914PTRK,	1152,	 258048 },

	{ HD7958AID,	0,	"7958A",	NHD7958ABPT,
	  NHD7958ATRK,	1013,	 255276 },

	{ HD7957AID,	0,	"7957A",	NHD7957ABPT,
	  NHD7957ATRK,	1036,	 159544 },

	{ HD7933HID,	0,	"7933H",	NHD7933HBPT,
	  NHD7933HTRK,	1321,	 789958 },

	{ HD9134LID,	1,	"9134L",	NHD9134LBPT,
	  NHD9134LTRK,	973,	  77840 },

	{ HD7936HID,	0,	"7936H",	NHD7936HBPT,
	  NHD7936HTRK,	698,	 600978 },

	{ HD7937HID,	0,	"7937H",	NHD7937HBPT,
	  NHD7937HTRK,	698,	1116102 },

	{ HD7914CTID,	0,	"7914CT",	NHD7914PBPT,
	  NHD7914PTRK,	1152,	 258048 },

	{ HD7946AID,	0,	"7946A",	NHD7945ABPT,
	  NHD7945ATRK,	968,	 108416 },

	{ HD9134LID,	1,	"9122D",	NHD9122SBPT,
	  NHD9122STRK,	77,	   1232 },

	{ HD7957BID,	0,	"7957B",	NHD7957BBPT,
	  NHD7957BTRK,	1269,	 159894 },

	{ HD7958BID,	0,	"7958B",	NHD7958BBPT,
	  NHD7958BTRK,	786,	 297108 },

	{ HD7959BID,	0,	"7959B",	NHD7959BBPT,
	  NHD7959BTRK,	1572,	 594216 },

	{ HD2200AID,	0,	"2200A",	NHD2200ABPT,
	  NHD2200ATRK,	1449,	 654948 },

	{ HD2203AID,	0,	"2203A",	NHD2203ABPT,
	  NHD2203ATRK,	1449,	1309896 }
};
const int numhdidentinfo = sizeof(hdidentinfo) / sizeof(hdidentinfo[0]);

bdev_decl(hd);
cdev_decl(hd);

int	hdident(struct device *, struct hd_softc *,
	    struct hpibbus_attach_args *);
void	hdreset(int, int, int);
void	hdustart(struct hd_softc *);
int	hdgetdisklabel(dev_t, struct hd_softc *, struct disklabel *, int);
void	hdrestart(void *);
struct buf *hdfinish(struct hd_softc *, struct buf *);

void	hdstart(void *);
void	hdinterrupt(void *);
void	hdgo(void *);
int	hdstatus(struct hd_softc *);
int	hderror(int);
#ifdef DEBUG
void	hdprinterr(const char *, short, const char **);
#endif

int	hdmatch(struct device *, void *, void *);
void	hdattach(struct device *, struct device *, void *);

struct cfattach hd_ca = {
	sizeof(struct hd_softc), hdmatch, hdattach
};

struct cfdriver hd_cd = {
	NULL, "hd", DV_DISK
};

#define	hdlookup(unit)	(struct hd_softc *)device_lookup(&hd_cd, (unit))

int
hdmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct hpibbus_attach_args *ha = aux;

	return (hdident(parent, NULL, ha));
}

void
hdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct hd_softc *sc = (struct hd_softc *)self;
	struct hpibbus_attach_args *ha = aux;

	if (hdident(parent, sc, ha) == 0) {
		printf("\n%s: didn't respond to describe command!\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Initialize and attach the disk structure.
	 */
	sc->sc_dkdev.dk_name = sc->sc_dev.dv_xname;
	disk_attach(&sc->sc_dev, &sc->sc_dkdev);
	bufq_init(&sc->sc_bufq, BUFQ_DEFAULT);

	sc->sc_slave = ha->ha_slave;
	sc->sc_punit = ha->ha_punit;

	/* Initialize the hpib job queue entry */
	sc->sc_hq.hq_softc = sc;
	sc->sc_hq.hq_slave = sc->sc_slave;
	sc->sc_hq.hq_start = hdstart;
	sc->sc_hq.hq_go = hdgo;
	sc->sc_hq.hq_intr = hdinterrupt;

#ifdef DEBUG
	/* always report errors */
	if (hddebug & HDB_ERROR)
		hderrthresh = 0;
#endif

	/* Initialize timeout structure */
	timeout_set(&sc->sc_timeout, hdrestart, sc);
}

int
hdident(parent, sc, ha)
	struct device *parent;
	struct hd_softc *sc;
	struct hpibbus_attach_args *ha;
{
	struct cs80_describe desc;
	u_char stat, cmd[3];
	char name[7];
	int i, id, n, ctlr, slave;

	ctlr = parent->dv_unit;
	slave = ha->ha_slave;

	/* Verify that we have a CS80 device. */
	if ((ha->ha_id & 0x200) == 0)
		return (0);

	/* Is it one of the disks we support? */
	for (id = 0; id < numhdidentinfo; id++)
		if (ha->ha_id == hdidentinfo[id].ri_hwid &&
		    ha->ha_punit <= hdidentinfo[id].ri_maxunum)
			break;
	if (id == numhdidentinfo)
		return (0);

	/*
	 * Reset device and collect description
	 */
	bzero(&desc, sizeof(desc));
	stat = 0;
	hdreset(ctlr, slave, ha->ha_punit);
	cmd[0] = C_SUNIT(ha->ha_punit);
	cmd[1] = C_SVOL(0);
	cmd[2] = C_DESC;
	hpibsend(ctlr, slave, C_CMD, cmd, sizeof(cmd));
	hpibrecv(ctlr, slave, C_EXEC, &desc, sizeof(desc));
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));

	if (desc.d_name == 0 && stat != 0)
		return (0);

	/*
	 * If we're just probing for the device, that's all the
	 * work we need to do.
	 */
	if (sc == NULL)
		return (1);

	bzero(name, sizeof(name));
	n = desc.d_name;
	for (i = 5; i >= 0; i--) {
		name[i] = (n & 0xf) + '0';
		n >>= 4;
	}

#ifdef DEBUG
	if (hddebug & HDB_IDENT) {
		printf(": stat %d name: %x ('%s')\n", stat, desc.d_name, name);
		printf("  iuw %x, maxxfr %d, ctype %d\n",
		    desc.d_iuw, desc.d_cmaxxfr, desc.d_ctype);
		printf("  utype %d, bps %d, blkbuf %d, burst %d, blktime %d\n",
		    desc.d_utype, desc.d_sectsize,
		    desc.d_blkbuf, desc.d_burstsize, desc.d_blocktime);
		printf("  avxfr %d, ort %d, atp %d, maxint %d, fv %x, rv %x\n",
		    desc.d_uavexfr, desc.d_retry, desc.d_access,
		    desc.d_maxint, desc.d_fvbyte, desc.d_rvbyte);
		printf("  maxcyl/head/sect %d/%d/%d, maxvsect %d, inter %d\n",
		    desc.d_maxcyl, desc.d_maxhead, desc.d_maxsect,
		    desc.d_maxvsectl, desc.d_interleave);
		printf("%s:", sc->sc_dev.dv_xname);
	}
#endif

	/*
	 * Take care of a couple of anomalies:
	 * 1. 7945A and 7946A both return same HW id
	 * 2. 9122S and 9134D both return same HW id
	 * 3. 9122D and 9134L both return same HW id
	 */
	switch (ha->ha_id) {
	case HD7946AID:
		if (bcmp(name, "079450", 6) == 0)
			id = HD7945A;
		else
			id = HD7946A;
		break;

	case HD9134LID:
		if (bcmp(name, "091340", 6) == 0)
			id = HD9134L;
		else
			id = HD9122D;
		break;

	case HD9134DID:
		if (bcmp(name, "091220", 6) == 0)
			id = HD9122S;
		else
			id = HD9134D;
		break;
	}

	sc->sc_type = id;

	/*
	 * XXX We use DEV_BSIZE instead of the sector size value pulled
	 * XXX off the driver because all of this code assumes 512 byte
	 * XXX blocks.  ICK!
	 */
	printf(": %s\n", hdidentinfo[id].ri_desc);
	printf("%s: %luMB, %lu cyl, %lu head, %lu sec, %lu bytes/sec, %lu sec total\n",
	    sc->sc_dev.dv_xname,
	    hdidentinfo[id].ri_nblocks / (1048576 / DEV_BSIZE),
	    hdidentinfo[id].ri_ncyl, hdidentinfo[id].ri_ntpc,
	    hdidentinfo[id].ri_nbpt, DEV_BSIZE, hdidentinfo[id].ri_nblocks);

	return (1);
}

void
hdreset(ctlr, slave, punit)
	int ctlr, slave, punit;
{
	struct	hd_ssmcmd ssmc;
	struct	hd_srcmd src;
	struct	hd_clearcmd clear;
	u_char stat;

	bzero(&clear, sizeof(clear));
	clear.c_unit = C_SUNIT(punit);
	clear.c_cmd = C_CLEAR;
	hpibsend(ctlr, slave, C_TCMD, &clear, sizeof(clear));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));

	bzero(&src, sizeof(src));
	src.c_unit = C_SUNIT(HDCTLR);
	src.c_nop = C_NOP;
	src.c_cmd = C_SREL;
	src.c_param = C_REL;
	hpibsend(ctlr, slave, C_CMD, &src, sizeof(src));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));

	bzero(&ssmc, sizeof(ssmc));
	ssmc.c_unit = C_SUNIT(punit);
	ssmc.c_cmd = C_SSM;
	ssmc.c_refm = REF_MASK;
	ssmc.c_fefm = FEF_MASK;
	ssmc.c_aefm = AEF_MASK;
	ssmc.c_iefm = IEF_MASK;
	hpibsend(ctlr, slave, C_CMD, &ssmc, sizeof(ssmc));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));
}

/*
 * Read or construct a disklabel
 */
int
hdgetdisklabel(dev, rs, lp, spoofonly)
	dev_t dev;
	struct hd_softc *rs;
	struct disklabel *lp;
	int spoofonly;
{
	bzero(lp, sizeof(struct disklabel));

	/*
	 * Create a default disk label based on geometry.
	 * This will get overridden if there is a real label on the disk.
	 */
	lp->d_secsize = DEV_BSIZE;
	lp->d_ntracks = hdidentinfo[rs->sc_type].ri_ntpc;
	lp->d_nsectors = hdidentinfo[rs->sc_type].ri_nbpt;
	lp->d_ncylinders = hdidentinfo[rs->sc_type].ri_ncyl;
	lp->d_secpercyl = lp->d_nsectors * lp->d_ntracks;
	if (lp->d_secpercyl == 0) {
		lp->d_secpercyl = 100;
		/* as long as it's not 0 - readdisklabel divides by it */
	}

	lp->d_type = DTYPE_HPIB;
	strncpy(lp->d_typename, hdidentinfo[rs->sc_type].ri_desc,
	    sizeof(lp->d_typename));
	strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);

	DL_SETDSIZE(lp, hdidentinfo[rs->sc_type].ri_nblocks);
	lp->d_flags = 0;
	lp->d_version = 1;

	/* XXX - these values for BBSIZE and SBSIZE assume ffs */
	lp->d_bbsize = BBSIZE;
	lp->d_sbsize = SBSIZE;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	/*
	 * Now try to read the disklabel
	 */
	return readdisklabel(DISKLABELDEV(dev), hdstrategy, lp, spoofonly);
}

int
hdopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = DISKUNIT(dev);
	struct hd_softc *rs;
	int mask, part;
	int error;

	rs = hdlookup(unit);
	if (rs == NULL)
		return (ENXIO);

	/*
	 * Fail open if we tried to attach but the disk did not answer.
	 */
	if (!ISSET(rs->sc_dkdev.dk_flags, DKF_CONSTRUCTED)) {
		device_unref(&rs->sc_dev);
		return (ENXIO);
	}

	if ((error = disk_lock(&rs->sc_dkdev)) != 0) {
		device_unref(&rs->sc_dev);
		return (error);
	}

	/*
	 * On first open, get label and partition info.
	 * We may block reading the label, so be careful
	 * to stop any other opens.
	 */
	if (rs->sc_dkdev.dk_openmask == 0) {
		rs->sc_flags |= HDF_OPENING;
		error = hdgetdisklabel(dev, rs, rs->sc_dkdev.dk_label, 0);
		rs->sc_flags &= ~HDF_OPENING;
		if (error == EIO)
			goto out;
	}

	part = DISKPART(dev);
	mask = 1 << part;

	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part > rs->sc_dkdev.dk_label->d_npartitions ||
	     rs->sc_dkdev.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
		goto out;
	}

	/* Ensure only one open at a time. */
	switch (mode) {
	case S_IFCHR:
		rs->sc_dkdev.dk_copenmask |= mask;
		break;
	case S_IFBLK:
		rs->sc_dkdev.dk_bopenmask |= mask;
		break;
	}
	rs->sc_dkdev.dk_openmask =
	    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;

	error = 0;
out:
	disk_unlock(&rs->sc_dkdev);
	device_unref(&rs->sc_dev);
	return (error);
}

int
hdclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = DISKUNIT(dev);
	struct hd_softc *rs;
	struct disk *dk;
	int mask, s;

	rs = hdlookup(unit);
	if (rs == NULL)
		return (ENXIO);

	disk_lock_nointr(&rs->sc_dkdev);

	mask = 1 << DISKPART(dev);
 	dk = &rs->sc_dkdev;
	switch (mode) {
	case S_IFCHR:
		dk->dk_copenmask &= ~mask;
		break;
	case S_IFBLK:
		dk->dk_bopenmask &= ~mask;
		break;
	}
	dk->dk_openmask = dk->dk_copenmask | dk->dk_bopenmask;

	/*
	 * On last close, we wait for all activity to cease since
	 * the label/parition info will become invalid.
	 * Note we don't have to about other closes since we know
	 * we are the last one.
	 */
	if (dk->dk_openmask == 0) {
		rs->sc_flags |= HDF_CLOSING;
		s = splbio();
		while (rs->sc_bp == NULL) {
			rs->sc_flags |= HDF_WANTED;
			tsleep((caddr_t)&rs->sc_bp, PRIBIO, "hdclose", 0);
		}
		splx(s);
		rs->sc_flags &= ~(HDF_CLOSING);
	}

	disk_unlock(&rs->sc_dkdev);
	device_unref(&rs->sc_dev);
	return (0);
}

void
hdstrategy(bp)
	struct buf *bp;
{
	int unit = DISKUNIT(bp->b_dev);
	struct hd_softc *rs;
	int s;

	rs = hdlookup(unit);
	if (rs == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

#ifdef DEBUG
	if (hddebug & HDB_FOLLOW)
		printf("hdstrategy(%x): dev %x, bn %x, bcount %lx, %c\n",
		       bp, bp->b_dev, bp->b_blkno, bp->b_bcount,
		       (bp->b_flags & B_READ) ? 'R' : 'W');
#endif

	/* Validate the request. */
	if (bounds_check_with_label(bp, rs->sc_dkdev.dk_label) == -1)
		goto done;

	bufq_queue(&rs->sc_bufq, bp);

	s = splbio();
	if (rs->sc_bp == NULL) {
		rs->sc_bp = bufq_dequeue(&rs->sc_bufq);
		hdustart(rs);
	}
	splx(s);

	device_unref(&rs->sc_dev);
	return;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
	if (rs != NULL)
		device_unref(&rs->sc_dev);
}

/*
 * Called via timeout(9) when handling maintenance releases
 */
void
hdrestart(arg)
	void *arg;
{
	int s = splbio();
	hdustart((struct hd_softc *)arg);
	splx(s);
}

void
hdustart(rs)
	struct hd_softc *rs;
{
	struct buf *bp;

	bp = rs->sc_bp;
	rs->sc_addr = bp->b_data;
	rs->sc_resid = bp->b_bcount;
	if (hpibreq(rs->sc_dev.dv_parent, &rs->sc_hq))
		hdstart(rs);
}

struct buf *
hdfinish(rs, bp)
	struct hd_softc *rs;
	struct buf *bp;
{
	int s;

	rs->sc_errcnt = 0;
	bp->b_resid = 0;
	s = splbio();
	biodone(bp);
	splx(s);

	hpibfree(rs->sc_dev.dv_parent, &rs->sc_hq);
	rs->sc_bp = bufq_dequeue(&rs->sc_bufq);

	if (rs->sc_bp == NULL && rs->sc_flags & HDF_WANTED) {
		rs->sc_flags &= ~HDF_WANTED;
		wakeup((caddr_t)&rs->sc_bp);
	}

	return (rs->sc_bp);
}

void
hdstart(arg)
	void *arg;
{
	struct hd_softc *rs = arg;
	struct disklabel *lp;
	struct buf *bp = rs->sc_bp;
	int ctlr, slave;
	daddr_t bn;

	ctlr = rs->sc_dev.dv_parent->dv_unit;
	slave = rs->sc_slave;

again:
#ifdef DEBUG
	if (hddebug & HDB_FOLLOW)
		printf("hdstart(%s): bp %p, %c\n", rs->sc_dev.dv_xname, bp,
		       (bp->b_flags & B_READ) ? 'R' : 'W');
#endif
	lp = rs->sc_dkdev.dk_label;
	bn = bp->b_blkno +
	    DL_GETPOFFSET(&lp->d_partitions[DISKPART(bp->b_dev)]);

	rs->sc_flags |= HDF_SEEK;
	rs->sc_ioc.c_unit = C_SUNIT(rs->sc_punit);
	rs->sc_ioc.c_volume = C_SVOL(0);
	rs->sc_ioc.c_saddr = C_SADDR;
	rs->sc_ioc.c_hiaddr = 0;
	rs->sc_ioc.c_addr = HDBTOS(bn);
	rs->sc_ioc.c_nop2 = C_NOP;
	rs->sc_ioc.c_slen = C_SLEN;
	rs->sc_ioc.c_len = rs->sc_resid;
	rs->sc_ioc.c_cmd = bp->b_flags & B_READ ? C_READ : C_WRITE;
#ifdef DEBUG
	if (hddebug & HDB_IO)
		printf("hdstart: hpibsend(%x, %x, %x, %p, %x)\n",
		       ctlr, slave, C_CMD,
		       &rs->sc_ioc.c_unit, sizeof(rs->sc_ioc)-2);
#endif
	if (hpibsend(ctlr, slave, C_CMD, &rs->sc_ioc.c_unit,
		     sizeof(rs->sc_ioc)-2) == sizeof(rs->sc_ioc)-2) {

		/* Instrumentation. */
		disk_busy(&rs->sc_dkdev);
		rs->sc_dkdev.dk_seek++;

#ifdef DEBUG
		if (hddebug & HDB_IO)
			printf("hdstart: hpibawait(%x)\n", ctlr);
#endif
		hpibawait(ctlr);
		return;
	}
	/*
	 * Experience has shown that the hpibwait in this hpibsend will
	 * occasionally timeout.  It appears to occur mostly on old 7914
	 * drives with full maintenance tracks.  We should probably
	 * integrate this with the backoff code in hderror.
	 */
#ifdef DEBUG
	if (hddebug & HDB_ERROR)
		printf("%s: hdstart: cmd %x adr %lx blk %d len %d ecnt %ld\n",
		       rs->sc_dev.dv_xname, rs->sc_ioc.c_cmd, rs->sc_ioc.c_addr,
		       bp->b_blkno, rs->sc_resid, rs->sc_errcnt);
	rs->sc_stats.hdretries++;
#endif
	rs->sc_flags &= ~HDF_SEEK;
	hdreset(rs->sc_dev.dv_parent->dv_unit, rs->sc_slave, rs->sc_punit);
	if (rs->sc_errcnt++ < HDRETRY)
		goto again;
	printf("%s: hdstart err: err: cmd 0x%x sect %ld blk %d len %d\n",
	       rs->sc_dev.dv_xname, rs->sc_ioc.c_cmd, rs->sc_ioc.c_addr,
	       bp->b_blkno, rs->sc_resid);
	bp->b_flags |= B_ERROR;
	bp->b_error = EIO;
	bp = hdfinish(rs, bp);
	if (bp) {
		rs->sc_addr = bp->b_data;
		rs->sc_resid = bp->b_bcount;
		if (hpibreq(rs->sc_dev.dv_parent, &rs->sc_hq))
			goto again;
	}
}

void
hdgo(arg)
	void *arg;
{
	struct hd_softc *rs = arg;
	struct buf *bp = rs->sc_bp;
	int rw, ctlr, slave;

	ctlr = rs->sc_dev.dv_parent->dv_unit;
	slave = rs->sc_slave;

	rw = bp->b_flags & B_READ;

	/* Instrumentation. */
	disk_busy(&rs->sc_dkdev);

#ifdef USELEDS
	ledcontrol(0, 0, LED_DISK);
#endif
	hpibgo(ctlr, slave, C_EXEC, rs->sc_addr, rs->sc_resid, rw, rw != 0);
}

/* ARGSUSED */
void
hdinterrupt(arg)
	void *arg;
{
	struct hd_softc *rs = arg;
	int unit = rs->sc_dev.dv_unit;
	struct buf *bp = rs->sc_bp;
	u_char stat = 13;	/* in case hpibrecv fails */
	int rv, restart, ctlr, slave;

	ctlr = rs->sc_dev.dv_parent->dv_unit;
	slave = rs->sc_slave;

#ifdef DEBUG
	if (hddebug & HDB_FOLLOW)
		printf("hdinterrupt(%d): bp %p, %c, flags %x\n", unit, bp,
		       (bp->b_flags & B_READ) ? 'R' : 'W', rs->sc_flags);
	if (bp == NULL) {
		printf("%s: bp == NULL\n", rs->sc_dev.dv_xname);
		return;
	}
#endif
	disk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));

	if (rs->sc_flags & HDF_SEEK) {
		rs->sc_flags &= ~HDF_SEEK;
		if (hpibustart(ctlr))
			hdgo(rs);
		return;
	}
	if ((rs->sc_flags & HDF_SWAIT) == 0) {
#ifdef DEBUG
		rs->sc_stats.hdpolltries++;
#endif
		if (hpibpptest(ctlr, slave) == 0) {
#ifdef DEBUG
			rs->sc_stats.hdpollwaits++;
#endif

			/* Instrumentation. */
			disk_busy(&rs->sc_dkdev);
			rs->sc_flags |= HDF_SWAIT;
			hpibawait(ctlr);
			return;
		}
	} else
		rs->sc_flags &= ~HDF_SWAIT;
	rv = hpibrecv(ctlr, slave, C_QSTAT, &stat, 1);
	if (rv != 1 || stat) {
#ifdef DEBUG
		if (hddebug & HDB_ERROR)
			printf("hdinterrupt: recv failed or bad stat %d\n", stat);
#endif
		restart = hderror(unit);
#ifdef DEBUG
		rs->sc_stats.hdretries++;
#endif
		if (rs->sc_errcnt++ < HDRETRY) {
			if (restart)
				hdstart(rs);
			return;
		}
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
	}
	if (hdfinish(rs, bp))
		hdustart(rs);
}

int
hdstatus(rs)
	struct hd_softc *rs;
{
	int c, s;
	u_char stat;
	int rv;

	c = rs->sc_dev.dv_parent->dv_unit;
	s = rs->sc_slave;
	rs->sc_rsc.c_unit = C_SUNIT(rs->sc_punit);
	rs->sc_rsc.c_sram = C_SRAM;
	rs->sc_rsc.c_ram = C_RAM;
	rs->sc_rsc.c_cmd = C_STATUS;
	bzero((caddr_t)&rs->sc_stat, sizeof(rs->sc_stat));
	rv = hpibsend(c, s, C_CMD, &rs->sc_rsc, sizeof(rs->sc_rsc));
	if (rv != sizeof(rs->sc_rsc)) {
#ifdef DEBUG
		if (hddebug & HDB_STATUS)
			printf("hdstatus: send C_CMD failed %d != %d\n",
			       rv, sizeof(rs->sc_rsc));
#endif
		return(1);
	}
	rv = hpibrecv(c, s, C_EXEC, &rs->sc_stat, sizeof(rs->sc_stat));
	if (rv != sizeof(rs->sc_stat)) {
#ifdef DEBUG
		if (hddebug & HDB_STATUS)
			printf("hdstatus: send C_EXEC failed %d != %d\n",
			       rv, sizeof(rs->sc_stat));
#endif
		return(1);
	}
	rv = hpibrecv(c, s, C_QSTAT, &stat, 1);
	if (rv != 1 || stat) {
#ifdef DEBUG
		if (hddebug & HDB_STATUS)
			printf("hdstatus: recv failed %d or bad stat %d\n",
			       rv, stat);
#endif
		return(1);
	}
	return(0);
}

/*
 * Deal with errors.
 * Returns 1 if request should be restarted,
 * 0 if we should just quietly give up.
 */
int
hderror(unit)
	int unit;
{
	struct hd_softc *rs = hd_cd.cd_devs[unit];
	struct hd_stat *sp;
	struct buf *bp;
	daddr_t hwbn, pbn;

	if (hdstatus(rs)) {
#ifdef DEBUG
		printf("%s: couldn't get status\n", rs->sc_dev.dv_xname);
#endif
		hdreset(rs->sc_dev.dv_parent->dv_unit,
		    rs->sc_slave, rs->sc_punit);
		return(1);
	}
	sp = &rs->sc_stat;
	if (sp->c_fef & FEF_REXMT)
		return(1);
	if (sp->c_fef & FEF_PF) {
		hdreset(rs->sc_dev.dv_parent->dv_unit,
		    rs->sc_slave, rs->sc_punit);
		return(1);
	}
	/*
	 * Unit requests release for internal maintenance.
	 * We just delay a while and try again later.  Use exponentially
	 * increasing backoff a la ethernet drivers since we don't really
	 * know how long the maintenance will take.  With HDWAITC and
	 * HDRETRY as defined, the range is 1 to 32 seconds.
	 */
	if (sp->c_fef & FEF_IMR) {
		int hdtimo = HDWAITC << rs->sc_errcnt;
#ifdef DEBUG
		printf("%s: internal maintenance, %d second timeout\n",
		       rs->sc_dev.dv_xname, hdtimo);
		rs->sc_stats.hdtimeouts++;
#endif
		hpibfree(rs->sc_dev.dv_parent, &rs->sc_hq);
		timeout_add_sec(&rs->sc_timeout, hdtimo);
		return(0);
	}
	/*
	 * Only report error if we have reached the error reporting
	 * threshold.  By default, this will only report after the
	 * retry limit has been exceeded.
	 */
	if (rs->sc_errcnt < hderrthresh)
		return(1);

	/*
	 * First conjure up the block number at which the error occurred.
	 * Note that not all errors report a block number, in that case
	 * we just use b_blkno.
 	 */
	bp = rs->sc_bp;
	pbn = DL_GETPOFFSET(&rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)]);
	if ((sp->c_fef & FEF_CU) || (sp->c_fef & FEF_DR) ||
	    (sp->c_ief & IEF_RRMASK)) {
		hwbn = HDBTOS(pbn + bp->b_blkno);
		pbn = bp->b_blkno;
	} else {
		hwbn = sp->c_blk;
		pbn = HDSTOB(hwbn) - pbn;
	}

	diskerr(bp, hd_cd.cd_name, "hard error", LOG_PRINTF,
	    pbn - bp->b_blkno, rs->sc_dkdev.dk_label);
	printf("\n%s%c: ", rs->sc_dev.dv_xname, 'a' + DISKPART(bp->b_dev));
	
#ifdef DEBUG
	if (hddebug & HDB_ERROR) {
		/* status info */
		printf("volume: %d, unit: %d\n",
		       (sp->c_vu>>4)&0xF, sp->c_vu&0xF);
		hdprinterr("reject", sp->c_ref, err_reject);
		hdprinterr("fault", sp->c_fef, err_fault);
		hdprinterr("access", sp->c_aef, err_access);
		hdprinterr("info", sp->c_ief, err_info);
		printf("    block: %lld, P1-P10: ", (long long)hwbn);
		printf("0x%04x", *(u_int *)&sp->c_raw[0]);
		printf("%04x", *(u_int *)&sp->c_raw[4]);
		printf("%02x\n", *(u_short *)&sp->c_raw[8]);
		/* command */
		printf("    ioc: ");
		printf("0x%x", *(u_int *)&rs->sc_ioc.c_pad);
		printf("0x%x", *(u_short *)&rs->sc_ioc.c_hiaddr);
		printf("0x%x", *(u_int *)&rs->sc_ioc.c_addr);
		printf("0x%x", *(u_short *)&rs->sc_ioc.c_nop2);
		printf("0x%x", *(u_int *)&rs->sc_ioc.c_len);
		printf("0x%x\n", *(u_short *)&rs->sc_ioc.c_cmd);
	} else
#endif
	{
		printf("v%d u%d, R0x%x F0x%x A0x%x I0x%x",
		    (sp->c_vu>>4)&0xF, sp->c_vu&0xF,
		    sp->c_ref, sp->c_fef, sp->c_aef, sp->c_ief);
		printf(" P1-P10: 0x%04x%04x%02x\n",
		    *(u_int *)&sp->c_raw[0], *(u_int *)&sp->c_raw[4],
		    *(u_short *)&sp->c_raw[8]);
	}
	return (1);
}

int
hdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (physio(hdstrategy, dev, B_READ, minphys, uio));
}

int
hdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (physio(hdstrategy, dev, B_WRITE, minphys, uio));
}

int
hdioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = DISKUNIT(dev);
	struct disklabel *lp;
	struct hd_softc *sc;
	int error = 0;

	sc = hdlookup(unit);
	if (sc == NULL)
		return (ENXIO);

	switch (cmd) {
	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		hdgetdisklabel(dev, sc, lp, 0);
		*(sc->sc_dkdev.dk_label) = *lp;
		free(lp, M_TEMP);
		return 0;

	case DIOCGPDINFO:
		hdgetdisklabel(dev, sc, (struct disklabel *)data, 1);
		goto exit;

	case DIOCGDINFO:
		*(struct disklabel *)data = *sc->sc_dkdev.dk_label;
		goto exit;

	case DIOCGPART:
		((struct partinfo *)data)->disklab = sc->sc_dkdev.dk_label;
		((struct partinfo *)data)->part =
			&sc->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];
		goto exit;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}

		if ((error = disk_lock(&sc->sc_dkdev)) != 0)
			goto exit;

		error = setdisklabel(sc->sc_dkdev.dk_label,
		    (struct disklabel *)data, /* sc->sc_dkdev.dk_openmask */ 0);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    hdstrategy, sc->sc_dkdev.dk_label);
		}

		disk_unlock(&sc->sc_dkdev);
		goto exit;

	default:
		error = EINVAL;
		break;
	}

exit:
	device_unref(&sc->sc_dev);
	return (error);
}

daddr_t
hdsize(dev)
	dev_t dev;
{
	struct hd_softc *rs;
	int unit = DISKUNIT(dev);
	int part, omask;
	daddr_t size;

	rs = hdlookup(unit);
	if (rs == NULL)
		return (-1);

	part = DISKPART(dev);
	omask = rs->sc_dkdev.dk_openmask & (1 << part);

	/*
	 * We get called very early on (via swapconf)
	 * without the device being open so we may need
	 * to handle it here.
	 */
	if (omask == 0 && hdopen(dev, FREAD | FWRITE, S_IFBLK, NULL) != 0) {
		size = -1;
		goto out;
	}

	if (rs->sc_dkdev.dk_label->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;
	else
		size = DL_GETPSIZE(&rs->sc_dkdev.dk_label->d_partitions[part]) *
		    (rs->sc_dkdev.dk_label->d_secsize / DEV_BSIZE);

	if (hdclose(dev, FREAD | FWRITE, S_IFBLK, NULL) != 0)
		size = -1;

out:
	device_unref(&rs->sc_dev);
	return (size);
}

#ifdef DEBUG
void
hdprinterr(str, err, tab)
	const char *str;
	short err;
	const char **tab;
{
	int i;
	int printed;

	if (err == 0)
		return;
	printf("    %s error %d field:", str, err);
	printed = 0;
	for (i = 0; i < 16; i++)
		if (err & (0x8000 >> i))
			printf("%s%s", printed++ ? " + " : " ", tab[i]);
	printf("\n");
}
#endif

static int hddoingadump;	/* simple mutex */

/*
 * Non-interrupt driven, non-dma dump routine.
 */
int
hddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{
	int sectorsize;		/* size of a disk sector */
	daddr_t nsects;	/* number of sectors in partition */
	daddr_t sectoff;	/* sector offset of partition */
	int totwrt;		/* total number of sectors left to write */
	int nwrt;		/* current number of sectors to write */
	int unit, part;
	int ctlr, slave;
	struct hd_softc *rs;
	struct disklabel *lp;
	char stat;

	/* Check for recursive dump; if so, punt. */
	if (hddoingadump)
		return (EFAULT);
	hddoingadump = 1;

	/* Decompose unit and partition. */
	unit = DISKUNIT(dev);
	part = DISKPART(dev);

	/* Make sure dump device is ok. */
	rs = hdlookup(unit);
	if (rs == NULL)
		return (ENXIO);
	device_unref(&rs->sc_dev);

	ctlr = rs->sc_dev.dv_parent->dv_unit;
	slave = rs->sc_slave;

	/*
	 * Convert to disk sectors.  Request must be a multiple of size.
	 */
	lp = rs->sc_dkdev.dk_label;
	sectorsize = lp->d_secsize;
	if ((size % sectorsize) != 0)
		return (EFAULT);
	totwrt = size / sectorsize;
	blkno = dbtob(blkno) / sectorsize;	/* blkno in DEV_BSIZE units */

	nsects = DL_GETPSIZE(&lp->d_partitions[part]);
	sectoff = DL_GETPOFFSET(&lp->d_partitions[part]);

	/* Check transfer bounds against partition size. */
	if ((blkno < 0) || (blkno + totwrt) > nsects)
		return (EINVAL);

	/* Offset block number to start of partition. */
	blkno += sectoff;

	while (totwrt > 0) {
		nwrt = totwrt;		/* XXX */
#ifndef HD_DUMP_NOT_TRUSTED
		/*
		 * Fill out and send HPIB command.
		 */
		rs->sc_ioc.c_unit = C_SUNIT(rs->sc_punit);
		rs->sc_ioc.c_volume = C_SVOL(0);
		rs->sc_ioc.c_saddr = C_SADDR;
		rs->sc_ioc.c_hiaddr = 0;
		rs->sc_ioc.c_addr = HDBTOS(blkno);
		rs->sc_ioc.c_nop2 = C_NOP;
		rs->sc_ioc.c_slen = C_SLEN;
		rs->sc_ioc.c_len = nwrt * sectorsize;
		rs->sc_ioc.c_cmd = C_WRITE;
		hpibsend(ctlr, slave, C_CMD, &rs->sc_ioc.c_unit,
		    sizeof(rs->sc_ioc)-2);
		if (hpibswait(ctlr, slave))
			return (EIO);

		/*
		 * Send the data.
		 */
		hpibsend(ctlr, slave, C_EXEC, va, nwrt * sectorsize);
		(void) hpibswait(ctlr, slave);
		hpibrecv(ctlr, slave, C_QSTAT, &stat, 1);
		if (stat)
			return (EIO);
#else /* HD_DUMP_NOT_TRUSTED */
		/* Let's just talk about this first... */
		printf("%s: dump addr %p, blk %d\n", sc->sc_dev.dv_xname,
		    va, blkno);
		delay(500 * 1000);	/* half a second */
#endif /* HD_DUMP_NOT_TRUSTED */

		/* update block count */
		totwrt -= nwrt;
		blkno += nwrt;
		va += sectorsize * nwrt;
	}
	hddoingadump = 0;
	return (0);
}
@


1.75
log
@give this a real chance to compile
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.74 2013/11/20 00:12:37 dlg Exp $	*/
@


1.74
log
@replace bare use of disksort with bufqs.

uebayashi@@ made sure it compiled
go ahead miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.73 2013/11/01 17:36:19 krw Exp $	*/
a652 1
	struct buf *dp;
d675 2
a676 2
	if (rs->b_bp == NULL) {
		rs->sc_bp = bufq_dequeue(rs->sc_bufq);
@


1.73
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.72 2013/10/14 23:26:22 krw Exp $	*/
d297 1
d634 1
a634 1
		while (rs->sc_tab.b_active) {
d636 1
a636 1
			tsleep((caddr_t)&rs->sc_tab, PRIBIO, "hdclose", 0);
d673 2
d676 2
a677 4
 	dp = &rs->sc_tab;
	disksort(dp, bp);
	if (dp->b_active == 0) {
		dp->b_active = 1;
d714 1
a714 1
	bp = rs->sc_tab.b_actf;
a725 1
	struct buf *dp = &rs->sc_tab;
a728 1
	dp->b_actf = bp->b_actf;
d733 1
d735 3
a737 4
	if (dp->b_actf)
		return (dp->b_actf);
	dp->b_active = 0;
	if (rs->sc_flags & HDF_WANTED) {
d739 1
a739 1
		wakeup((caddr_t)dp);
d741 2
a742 1
	return (NULL);
d751 1
a751 1
	struct buf *bp = rs->sc_tab.b_actf;
d834 1
a834 1
	struct buf *bp = rs->sc_tab.b_actf;
d858 1
a858 1
	struct buf *bp = rs->sc_tab.b_actf;
d1028 1
a1028 1
	bp = rs->sc_tab.b_actf;
@


1.72
log
@XXsize() returns daddr_t, so calculate the return value in a daddr_t
variable and not (usually) an int.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.71 2013/06/28 18:17:12 miod Exp $	*/
d1052 1
a1052 1
		printf("    block: %lld, P1-P10: ", hwbn);
@


1.71
log
@Uninitialized variable; Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.70 2013/06/11 16:42:07 deraadt Exp $	*/
d1174 1
a1174 1
	int size;
@


1.70
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.69 2011/07/06 04:49:35 matthew Exp $	*/
d544 1
a544 1
		return (error);
@


1.69
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.68 2011/06/19 21:20:04 miod Exp $	*/
d753 1
a753 1
	daddr64_t bn;
d979 1
a979 1
	daddr64_t hwbn, pbn;
d1167 1
a1167 1
daddr64_t
d1236 1
a1236 1
	daddr64_t blkno;
d1241 2
a1242 2
	daddr64_t nsects;	/* number of sectors in partition */
	daddr64_t sectoff;	/* sector offset of partition */
@


1.68
log
@Unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.67 2011/06/19 04:55:34 deraadt Exp $	*/
a652 1
	struct disklabel *lp;
d668 2
a669 21
	lp = rs->sc_dkdev.dk_label;

	/*
	 * If it's a null transfer, return immediately
	 */
	if (bp->b_bcount == 0)
		goto done;

	/*
	 * The transfer must be a whole number of blocks.
	 */
	if ((bp->b_bcount % lp->d_secsize) != 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/*
	 * Do bounds checking, adjust transfer. if error, process;
	 * If end of partition, just return.
	 */
	if (bounds_check_with_label(bp, lp) <= 0)
d683 2
a684 1
bad:
a685 4
done:
	/*
	 * Correctly set the buf to indicate a completed xfer
	 */
d687 1
@


1.67
log
@Use disk_lock_nointr() in the xxclose() routines so that they cannot
be interrupted.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.66 2011/06/19 04:35:06 deraadt Exp $	*/
d1165 1
a1165 1
		if ((error = hdlock(sc)) != 0)
d1176 1
a1176 1
		hdunlock(sc);
@


1.66
log
@Use disk_lock/disk_unlock directly and in the same way in these drivers,
rather than using various wrappings.  Convert vnd to using the sc_dk
rwlock instead of using one of its own.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.65 2011/06/05 18:40:33 matthew Exp $	*/
a604 1
	int error;
d610 1
a610 4
	if ((error = disk_lock(&rs->sc_dkdev)) != 0) {
		device_unref(&rs->sc_dev);
		return (error);
	}
@


1.65
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.64 2011/06/03 21:14:11 matthew Exp $	*/
a265 2
#define	hdlock(rs)	disk_lock(&(rs)->sc_dkdev)
#define	hdunlock(rs)	disk_unlock(&(rs)->sc_dkdev)
d547 1
a547 1
	if ((error = hdlock(rs)) != 0) {
d590 1
a590 1
	hdunlock(rs);
d611 1
a611 1
	if ((error = hdlock(rs)) != 0) {
d645 1
a645 1
	hdunlock(rs);
@


1.64
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.63 2010/09/22 01:18:57 matthew Exp $	*/
a1163 11
	case DIOCWLABEL:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
		if (*(int *)data)
			sc->sc_flags |= HDF_WLABEL;
		else
			sc->sc_flags &= ~HDF_WLABEL;
		goto exit;

a1172 1
		sc->sc_flags |= HDF_WLABEL;
a1181 1
		sc->sc_flags &= ~HDF_WLABEL;
@


1.63
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.62 2010/09/08 14:47:10 jsing Exp $	*/
d695 2
a696 3
	if (bounds_check_with_label(bp, lp,
	    (rs->sc_flags & HDF_WLABEL) != 0) <= 0)
			goto done;
@


1.62
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.60 2010/04/23 15:25:20 jsing Exp $	*/
d1113 1
a1113 1
	return (physio(hdstrategy, NULL, dev, B_READ, minphys, uio));
d1123 1
a1123 1
	return (physio(hdstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.61
log
@add dkio.h to the last of the disk ioctl users i can find.

requested by deraadt@@ who was rightly disparaging of my grep skillz.
@
text
@d298 1
a298 1
	disk_attach(&sc->sc_dkdev);
@


1.60
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.58 2009/08/16 12:17:35 miod Exp $	*/
d61 1
@


1.59
log
@- fix format strings for values that are daddr64_t

ok otto@@, agreed by deraadt@@
@
text
@a507 2
	lp->d_rpm = 3600;
	lp->d_interleave = 1;
@


1.58
log
@Update to cope with new readdisklabel() return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.57 2009/06/13 21:35:58 miod Exp $	*/
d1082 1
a1082 1
		printf("    block: %d, P1-P10: ", hwbn);
@


1.57
log
@Needs <sys/malloc.h> now
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.56 2009/06/04 05:57:27 krw Exp $	*/
d241 1
a241 1
void	hdgetdisklabel(dev_t, struct hd_softc *, struct disklabel *, int);
d479 1
a479 1
void
a485 2
	char *errstring;

d524 1
a524 6
	errstring = readdisklabel(DISKLABELDEV(dev), hdstrategy, lp,
	    spoofonly);
	if (errstring) {
		/* printf("%s: %s\n", rs->sc_dev.dv_xname, errstring); */
		return;
	}
d562 1
a562 1
		hdgetdisklabel(dev, rs, rs->sc_dkdev.dk_label, 0);
d564 2
@


1.56
log
@Add DIOCRLDINFO to those drivers previously deprived.

Noticed by & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.55 2009/01/25 14:29:29 miod Exp $	*/
d57 1
@


1.55
log
@If hdattach() aborts early because the disk is not in good shape, always
fail hdopen().
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.54 2008/10/15 19:12:20 blambert Exp $	*/
d1140 1
d1149 7
@


1.54
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.53 2007/06/21 20:23:07 miod Exp $	*/
a294 1
	bzero(&sc->sc_dkdev, sizeof(sc->sc_dkdev));
d547 8
@


1.53
log
@Brace got lost in rev 1.51.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.52 2007/06/20 20:13:40 miod Exp $	*/
d1039 1
a1039 1
		timeout_add(&rs->sc_timeout, hdtimo * hz);
@


1.52
log
@These drivers were abusing b_cylinder to store device-specific information
in strategy(), and were reusing it in start().
I first considered introducing a b_rawblkno field in struct buf, as has been
done in NetBSD, to stop this abuse.
However, it does not cost more to simply move the device-specific
``was-b_cylinder'' computation to the start() routine. Plus we get type fixes
(daddr64_t) for free, although this does not really matter for these
pedro-sized devices. Thus we do not need to grow struct buf for these
devices which really ought to live in your Attic (and my machineroom, of
course).

hp300 HP-IB tested, vax mfm not, but the logic is the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.51 2007/06/20 18:15:47 deraadt Exp $	*/
d1140 1
a1140 1
	switch (cmd)
@


1.51
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.50 2007/06/08 05:27:58 deraadt Exp $	*/
d657 1
a658 1
	struct partition *pinfo;
d673 2
d684 1
a684 1
	if ((bp->b_bcount % rs->sc_dkdev.dk_label->d_secsize) != 0) {
d693 2
a694 9

 	dp = &rs->sc_tab;

	if (DISKPART(bp->b_dev) == RAW_PART) {
		/* valid regardless of the disklabel */
		bp->b_cylinder = bp->b_blkno;
	} else {
		if (bounds_check_with_label(bp, rs->sc_dkdev.dk_label,
		    (rs->sc_flags & HDF_WLABEL) != 0) <= 0)
a696 9
		/*
		 * XXX Note that since b_cylinder is stored over b_resid, this  
		 * XXX destroys the disksort ordering hint
		 * XXX bounds_check_with_label() has put in there.
		*/
		pinfo = &rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];
		bp->b_cylinder = bp->b_blkno + DL_GETPOFFSET(pinfo);
	}

d698 1
d777 1
d779 2
a780 1
	int part, ctlr, slave;
d791 4
a794 1
	part = DISKPART(bp->b_dev);
d800 1
a800 1
	rs->sc_ioc.c_addr = HDBTOS(bp->b_cylinder);
@


1.50
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.49 2007/06/06 17:15:11 deraadt Exp $	*/
d240 1
a240 2
void	hdgetdisklabel(dev_t, struct hd_softc *, struct disklabel *,
	    struct cpu_disklabel *, int);
d480 1
a480 1
hdgetdisklabel(dev, rs, lp, clp, spoofonly)
a483 1
	struct cpu_disklabel *clp;
a488 1
	bzero(clp, sizeof(struct cpu_disklabel));
d526 1
a526 1
	errstring = readdisklabel(DISKLABELDEV(dev), hdstrategy, lp, clp,
d561 1
a561 2
		hdgetdisklabel(dev, rs, rs->sc_dkdev.dk_label,
		    rs->sc_dkdev.dk_cpulabel, 0);
a698 1
		    rs->sc_dkdev.dk_cpulabel,
d1148 1
a1148 1
	switch (cmd) {
d1150 1
a1150 5
	    {
		struct cpu_disklabel osdep;

		hdgetdisklabel(dev, sc, (struct disklabel *)data, &osdep, 1);
	    }
d1186 1
a1186 2
		    (struct disklabel *)data, /* sc->sc_dkdev.dk_openmask */ 0,
		    sc->sc_dkdev.dk_cpulabel);
d1190 1
a1190 2
				    hdstrategy, sc->sc_dkdev.dk_label,
				    sc->sc_dkdev.dk_cpulabel);
@


1.49
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.48 2007/06/05 00:38:14 deraadt Exp $	*/
d516 1
@


1.48
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.47 2007/06/01 00:07:48 krw Exp $	*/
d1018 1
a1018 1
	daddr_t hwbn, pbn;
d1217 1
a1217 1
int
d1286 1
a1286 1
	daddr_t blkno;
d1291 2
a1292 2
	int nsects;		/* number of sectors in partition */
	int sectoff;		/* sector offset of partition */
@


1.47
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.46 2007/04/30 00:17:48 krw Exp $	*/
d512 1
a512 1
	lp->d_secperunit = hdidentinfo[rs->sc_type].ri_nblocks;
d712 1
a712 1
		bp->b_cylinder = bp->b_blkno + pinfo->p_offset;
d1068 1
a1068 1
	pbn = rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)].p_offset;
d1246 1
a1246 1
		size = rs->sc_dkdev.dk_label->d_partitions[part].p_size *
d1329 2
a1330 2
	nsects = lp->d_partitions[part].p_size;
	sectoff = lp->d_partitions[part].p_offset;
@


1.46
log
@HDUNIT/etc -> DISKUNIT/etc. No functional change.

"Looks right" millert@@ "toss 'em in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.45 2007/02/28 20:19:05 miod Exp $	*/
a519 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.45
log
@Use diskerr() to print error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.44 2007/02/22 17:20:17 miod Exp $	*/
a71 4
#define	HDUNIT(x)	DISKUNIT(x)
#define HDPART(x)	DISKPART(x)
#define HDLABELDEV(d)	MAKEDISKDEV(major(d), HDUNIT(d), RAW_PART)

d533 1
a533 1
	errstring = readdisklabel(HDLABELDEV(dev), hdstrategy, lp, clp,
d547 1
a547 1
	int unit = HDUNIT(dev);
d573 1
a573 1
	part = HDPART(dev);
d609 1
a609 1
	int unit = HDUNIT(dev);
d624 1
a624 1
	mask = 1 << HDPART(dev);
d662 1
a662 1
	int unit = HDUNIT(bp->b_dev);
d702 1
a702 1
	if (HDPART(bp->b_dev) == RAW_PART) {
d716 1
a716 1
		pinfo = &rs->sc_dkdev.dk_label->d_partitions[HDPART(bp->b_dev)];
d811 1
a811 1
	part = HDPART(bp->b_dev);
d1073 1
a1073 1
	pbn = rs->sc_dkdev.dk_label->d_partitions[HDPART(bp->b_dev)].p_offset;
d1085 1
a1085 1
	printf("\n%s%c: ", rs->sc_dev.dv_xname, 'a' + HDPART(bp->b_dev));
d1149 1
a1149 1
	int unit = HDUNIT(dev);
d1173 1
a1173 1
			&sc->sc_dkdev.dk_label->d_partitions[HDPART(dev)];
d1203 1
a1203 1
				error = writedisklabel(HDLABELDEV(dev),
d1227 1
a1227 1
	int unit = HDUNIT(dev);
d1235 1
a1235 1
	part = HDPART(dev);
d1312 2
a1313 2
	unit = HDUNIT(dev);
	part = HDPART(dev);
@


1.44
log
@Comment out the errmsg printf in hdgetdisklabel() again.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.43 2007/02/21 22:32:05 miod Exp $	*/
d59 1
d1086 5
a1090 14
	/*
	 * Now output a generic message suitable for badsect.
	 * Note that we don't use harderr because it just prints
	 * out b_blkno which is just the beginning block number
	 * of the transfer, not necessarily where the error occurred.
	 */
	printf("%s%c: hard error sn%d\n", rs->sc_dev.dv_xname,
	    'a' + HDPART(bp->b_dev), pbn);
	/*
	 * Now report the status as returned by the hardware with
	 * no attempt at interpretation (unless debugging).
	 */
	printf("%s: %s error:", rs->sc_dev.dv_xname,
	    (bp->b_flags & B_READ) ? "read" : "write");
d1094 1
a1094 1
		printf("\n    volume: %d, unit: %d\n",
d1112 9
a1120 1
		return (1);
a1121 7
#endif
	printf(" v%d u%d, R0x%x F0x%x A0x%x I0x%x",
	       (sp->c_vu>>4)&0xF, sp->c_vu&0xF,
	       sp->c_ref, sp->c_fef, sp->c_aef, sp->c_ief);
	printf(" P1-P10: 0x%04x%04x%02x\n",
	    *(u_int *)&sp->c_raw[0], *(u_int *)&sp->c_raw[4],
	    *(u_short *)&sp->c_raw[8]);
@


1.43
log
@Long awaiting modernization:
- reset the drive and fetch its identification strings during probe, and do
  not attach if they don't look good.
- do not store synchronous command blocks (used by hdreset) in the softc,
  since they are not processed asynchronously. The stack will do.
- cleanup the disklabel retrieval code.
- use disk_{,un}lock instead of rolling our own equivalent.
- use bounds_check_with_label() in hdstrategy() instead of a stripped-down
  inline version of it.
Tested on 7957A.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.42 2007/02/21 11:01:10 mickey Exp $	*/
d539 1
a539 1
		printf("%s: %s\n", rs->sc_dev.dv_xname, errstring);
@


1.42
log
@remove part of buf abuse and store errcnt in softc (instead of b_errcnt); more work can be done to lower buf abuse even more; miod@@ testing and ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.41 2006/08/12 13:53:44 krw Exp $	*/
d241 1
a241 1
void	hdreset(struct hd_softc *);
d243 2
a244 1
int	hdgetinfo(dev_t, struct hd_softc *, struct disklabel *, int);
d268 4
a312 1
	sc->sc_flags = HDF_ALIVE;
a349 7
	 * If we're just probing for the device, that's all the
	 * work we need to do.
	 */
	if (sc == NULL)
		return (1);

	/*
d352 3
a354 1
	hdreset(sc);
d362 10
d373 4
a376 6
	if (stat == 0) {
		n = desc.d_name;
		for (i = 5; i >= 0; i--) {
			name[i] = (n & 0xf) + '0';
			n >>= 4;
		}
d381 1
a381 2
		printf("\n%s: name: %x ('%s')\n",
		    sc->sc_dev.dv_xname, desc.d_name, name);
d393 1
a393 1
		printf("%s", sc->sc_dev.dv_xname);
d444 2
a445 2
hdreset(rs)
	struct hd_softc *rs;
d447 3
a449 2
	int ctlr = rs->sc_dev.dv_parent->dv_unit;
	int slave = rs->sc_slave;
d452 4
a455 3
	rs->sc_clear.c_unit = C_SUNIT(rs->sc_punit);
	rs->sc_clear.c_cmd = C_CLEAR;
	hpibsend(ctlr, slave, C_TCMD, &rs->sc_clear, sizeof(rs->sc_clear));
d459 6
a464 5
	rs->sc_src.c_unit = C_SUNIT(HDCTLR);
	rs->sc_src.c_nop = C_NOP;
	rs->sc_src.c_cmd = C_SREL;
	rs->sc_src.c_param = C_REL;
	hpibsend(ctlr, slave, C_CMD, &rs->sc_src, sizeof(rs->sc_src));
d468 8
a475 7
	rs->sc_ssmc.c_unit = C_SUNIT(rs->sc_punit);
	rs->sc_ssmc.c_cmd = C_SSM;
	rs->sc_ssmc.c_refm = REF_MASK;
	rs->sc_ssmc.c_fefm = FEF_MASK;
	rs->sc_ssmc.c_aefm = AEF_MASK;
	rs->sc_ssmc.c_iefm = IEF_MASK;
	hpibsend(ctlr, slave, C_CMD, &rs->sc_ssmc, sizeof(rs->sc_ssmc));
a477 3
#ifdef DEBUG
	rs->sc_stats.hdresets++;
#endif
d483 2
a484 2
int
hdgetinfo(dev, rs, lp, spoofonly)
d488 1
d493 3
d500 10
a509 1
	bzero((caddr_t)lp, sizeof *lp);
d514 2
a515 1
	lp->d_secsize = DEV_BSIZE;
d518 1
a518 6

	lp->d_nsectors = hdidentinfo[rs->sc_type].ri_nbpt;
	lp->d_ntracks = hdidentinfo[rs->sc_type].ri_ntpc;
	lp->d_ncylinders = hdidentinfo[rs->sc_type].ri_ncyl;
	lp->d_secperunit = hdidentinfo[rs->sc_type].ri_nblocks;
	lp->d_secpercyl = lp->d_nsectors * lp->d_ntracks;
d536 1
a536 1
	errstring = readdisklabel(HDLABELDEV(dev), hdstrategy, lp, NULL,
d539 2
a540 7
		/* XXX reset partition info as readdisklabel screws with it */
		lp->d_partitions[0].p_size = 0;
		lp->d_partitions[RAW_PART].p_offset = 0;
		lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
		lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
		lp->d_npartitions = RAW_PART + 1;
		lp->d_checksum = dkcksum(lp);
a541 2

	return(0);
d552 2
a553 1
	int error, mask, part;
d555 2
a556 3
	if (unit >= hd_cd.cd_ndevs ||
	    (rs = hd_cd.cd_devs[unit]) == NULL ||
	    (rs->sc_flags & HDF_ALIVE) == 0)
d559 4
a562 5
	/*
	 * Wait for any pending opens/closes to complete
	 */
	while (rs->sc_flags & (HDF_OPENING|HDF_CLOSING))
		tsleep((caddr_t)rs, PRIBIO, "hdopen", 0);
d571 2
a572 1
		error = hdgetinfo(dev, rs, rs->sc_dkdev.dk_label, 0);
a573 3
		wakeup((caddr_t)rs);
		if (error)
			return(error);
d582 4
a585 2
	     rs->sc_dkdev.dk_label->d_partitions[part].p_fstype == FS_UNUSED))
		return (ENXIO);
d599 5
a603 1
	return(0);
d613 2
a614 2
	struct hd_softc *rs = hd_cd.cd_devs[unit];
	struct disk *dk = &rs->sc_dkdev;
d616 10
d628 3
a630 1
	if (mode == S_IFCHR)
d632 2
a633 1
	else
d635 2
d638 1
d641 1
a641 2
	 * the label/parition info will become invalid.  Since we
	 * might sleep, we must block any opens while we are here.
a653 1
		wakeup((caddr_t)rs);
d655 4
a658 1
	return(0);
d666 3
a668 2
	struct hd_softc *rs = hd_cd.cd_devs[unit];
	struct buf *dp = &rs->sc_tab;
d670 6
a675 3
	daddr_t bn;
	int sz, s;
	int offset;
a682 3
	bn = bp->b_blkno;
	sz = howmany(bp->b_bcount, DEV_BSIZE);
	pinfo = &rs->sc_dkdev.dk_label->d_partitions[HDPART(bp->b_dev)];
d684 29
a712 2
	/* Don't perform partition translation on RAW_PART. */
	offset = (HDPART(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;
a713 18
	if (HDPART(bp->b_dev) != RAW_PART) {
		/*
		 * XXX This block of code belongs in
		 * XXX bounds_check_with_label()
		 */

		if (bn < 0 || bn + sz > pinfo->p_size) {
			sz = pinfo->p_size - bn;
			if (sz == 0) {
				bp->b_resid = bp->b_bcount;
				goto done;
			}
			if (sz < 0) {
				bp->b_error = EINVAL;
				goto bad;
			}
			bp->b_bcount = dbtob(sz);
		}
d715 6
a720 10
		 * Check for write to write protected label
		 */
		if (bn + offset <= LABELSECTOR &&
#if LABELSECTOR != 0
		    bn + offset + sz > LABELSECTOR &&
#endif
		    !(bp->b_flags & B_READ) && !(rs->sc_flags & HDF_WLABEL)) {
			bp->b_error = EROFS;
			goto bad;
		}
d722 1
a722 1
	bp->b_cylinder = bn + offset;
d730 2
d736 4
d743 2
d859 1
a859 1
	hdreset(rs);
d1032 2
a1033 1
		hdreset(rs);
d1040 2
a1041 1
		hdreset(rs);
d1161 6
a1166 3
	struct hd_softc *sc = hd_cd.cd_devs[unit];
	struct disklabel *lp = sc->sc_dkdev.dk_label;
	int error, flags;
d1170 6
a1175 2
		error = hdgetinfo(dev, sc, (struct disklabel *)data, 1);
		return (error);
d1178 2
a1179 2
		*(struct disklabel *)data = *lp;
		return (0);
d1182 1
a1182 1
		((struct partinfo *)data)->disklab = lp;
d1184 2
a1185 2
			&lp->d_partitions[HDPART(dev)];
		return (0);
d1188 4
a1191 2
		if ((flag & FWRITE) == 0)
			return (EBADF);
d1196 1
a1196 1
		return (0);
d1198 1
d1200 18
a1217 6
		if ((flag & FWRITE) == 0)
			return (EBADF);
		return (setdisklabel(lp, (struct disklabel *)data,
				     (sc->sc_flags & HDF_WLABEL) ? 0
				     : sc->sc_dkdev.dk_openmask,
				     (struct cpu_disklabel *)0));
d1219 7
a1225 15
	case DIOCWDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);
		error = setdisklabel(lp, (struct disklabel *)data,
				     (sc->sc_flags & HDF_WLABEL) ? 0
				     : sc->sc_dkdev.dk_openmask,
				     (struct cpu_disklabel *)0);
		if (error)
			return (error);
		flags = sc->sc_flags;
		sc->sc_flags = HDF_ALIVE | HDF_WLABEL;
		error = writedisklabel(HDLABELDEV(dev), hdstrategy, lp,
				       (struct cpu_disklabel *)0);
		sc->sc_flags = flags;
		return (error);
d1227 4
a1230 1
	return(EINVAL);
d1237 1
d1239 2
a1240 2
	struct hd_softc *rs;
	int psize, didopen = 0;
d1242 2
a1243 3
	if (unit >= hd_cd.cd_ndevs ||
	    (rs = hd_cd.cd_devs[unit]) == NULL ||
	    (rs->sc_flags & HDF_ALIVE) == 0)
d1246 3
d1254 17
a1270 10
	if (rs->sc_dkdev.dk_openmask == 0) {
		if (hdopen(dev, FREAD|FWRITE, S_IFBLK, NULL))
			return(-1);
		didopen = 1;
	}
	psize = rs->sc_dkdev.dk_label->d_partitions[HDPART(dev)].p_size *
	    (rs->sc_dkdev.dk_label->d_secsize / DEV_BSIZE);
	if (didopen)
		(void) hdclose(dev, FREAD|FWRITE, S_IFBLK, NULL);
	return (psize);
d1327 2
a1328 3
	if (unit >= hd_cd.cd_ndevs ||
	    (rs = hd_cd.cd_devs[unit]) == NULL ||
	    (rs->sc_flags & HDF_ALIVE) == 0)
d1330 1
@


1.41
log
@Setting d_secsize to DEV_BSIZE (or 1 << DEV_BSHIFT, or 512) and then
setting RAW_PART's p_size to d_secperunit * (d_secsize / DEV_BSIZE) is
a waste of a few ops. And p_size should be in sectors anyway.

Just set RAW_PART's p_size to d_secperunit to make usage consistant
across the tree.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.40 2006/03/15 20:20:39 miod Exp $	*/
d737 1
a737 1
	dp->b_errcnt = 0;
d812 1
a812 1
		       bp->b_blkno, rs->sc_resid, rs->sc_tab.b_errcnt);
d817 1
a817 1
	if (rs->sc_tab.b_errcnt++ < HDRETRY)
d914 1
a914 1
		if (rs->sc_tab.b_errcnt++ < HDRETRY) {
d1007 1
a1007 1
		int hdtimo = HDWAITC << rs->sc_tab.b_errcnt;
d1022 1
a1022 1
	if (rs->sc_tab.b_errcnt < hderrthresh)
@


1.40
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.39 2006/01/22 00:40:01 miod Exp $	*/
d509 1
a509 2
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
d526 1
a526 2
		lp->d_partitions[RAW_PART].p_size =
		    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.39
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.38 2006/01/20 23:27:25 miod Exp $	*/
a316 2

	dk_establish(&sc->sc_dkdev, &sc->sc_dev);	/* XXX */
@


1.38
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.37 2005/11/18 00:16:48 miod Exp $	*/
a74 2
#define	b_cylin		b_resid

d691 1
a691 1
	bp->b_cylin = bn + offset;
d781 1
a781 1
	rs->sc_ioc.c_addr = HDBTOS(bp->b_cylin);
@


1.37
log
@Protect biodone() with splbio().
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.36 2005/11/18 00:09:15 miod Exp $	*/
d729 1
a729 1
	rs->sc_addr = bp->b_un.b_addr;
d832 1
a832 1
		rs->sc_addr = bp->b_un.b_addr;
@


1.36
log
@Define the CS/80 identify structure only once and correctly, instead of
duplicating it in every CS/80 driver and using an hardcoded number for its size.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.35 2005/11/16 21:23:55 miod Exp $	*/
d741 1
d746 1
d748 1
@


1.35
log
@Overhaul the way HP-IB devices are probed. We will now do an exhaustive
probe of the (slave, punit) tuple space, since this is the only way we
can get a dual disk or dual tape enclosure to attach two devices of the
same kind.

This allows us to get rid of the hpibbus resource map and related
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.34 2005/11/15 21:09:44 miod Exp $	*/
d329 1
a329 1
	struct hd_describe *desc = sc != NULL ? &sc->sc_hddesc : NULL;
d364 1
a364 1
	hpibrecv(ctlr, slave, C_EXEC, desc, 37);
d366 1
d369 1
a369 1
		n = desc->d_name;
d379 1
a379 1
		    sc->sc_dev.dv_xname, desc->d_name, name);
d381 1
a381 1
		    desc->d_iuw, desc->d_cmaxxfr, desc->d_ctype);
d383 2
a384 2
		    desc->d_utype, desc->d_sectsize,
		    desc->d_blkbuf, desc->d_burstsize, desc->d_blocktime);
d386 2
a387 2
		    desc->d_uavexfr, desc->d_retry, desc->d_access,
		    desc->d_maxint, desc->d_fvbyte, desc->d_rvbyte);
d389 2
a390 2
		    desc->d_maxcyl, desc->d_maxhead, desc->d_maxsect,
		    desc->d_maxvsectl, desc->d_interleave);
@


1.34
log
@Only two `h' in threshold.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.33 2005/11/15 07:02:36 miod Exp $	*/
a164 1
int	hddebug = 0x80;
d171 1
a273 1
	struct cfdata *cf = match;
d276 1
a276 19
	/*
	 * Set punit if operator specified one in the kernel
	 * configuration file.
	 */
	if (cf->hpibbuscf_punit != HPIBBUS_PUNIT_UNK &&
	    cf->hpibbuscf_punit < HPIB_NPUNITS)
		ha->ha_punit = cf->hpibbuscf_punit;

	if (hdident(parent, NULL, ha) == 0) {
		/*
		 * XXX Some aging HP-IB drives are slow to
		 * XXX respond; give them a chance to catch
		 * XXX up and probe them again.
		 */
		delay(10000);
		ha->ha_id = hpibid(parent->dv_unit, ha->ha_slave);
		return (hdident(parent, NULL, ha));
	}
	return (1);
d343 2
a344 1
		if (ha->ha_id == hdidentinfo[id].ri_hwid)
d346 1
a346 1
	if (id == numhdidentinfo || ha->ha_punit > hdidentinfo[id].ri_maxunum)
@


1.33
log
@More typos (especially indicies -> indices), checked with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.32 2005/11/14 20:20:30 miod Exp $	*/
d1039 1
a1039 1
	 * threshhold.  By default, this will only report after the
@


1.32
log
@Make HDWAITC and HDRETRY overridable in the kernel configuration file;
while there, constify option DEBUG message tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.31 2005/11/14 19:54:08 miod Exp $	*/
d1021 2
a1022 2
	 * We just delay awhile and try again later.  Use expontially
	 * increasing backoff ala ethernet drivers since we don't really
d1064 1
a1064 1
	 * of the transfer, not necessary where the error occurred.
d1070 1
a1070 1
	 * attempt at interpretation (unless debugging).
@


1.31
log
@constuct -> construct
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.30 2005/11/14 19:23:40 miod Exp $	*/
d71 15
a85 1
int	hderrthresh = HDRETRY-1;	/* when to start reporting errors */
d89 3
a91 2
char *err_reject[] = {
	0, 0,
d93 2
a94 1
	0, 0,
d101 1
a101 1
	0,
d103 3
a105 1
	0, 0, 0
d108 2
a109 2
char *err_fault[] = {
	0,
d111 1
a111 1
	0,
d113 2
a114 1
	0, 0,
d116 1
a116 1
	0,
d118 1
a118 1
	0,
d122 1
a122 1
	0,
d127 1
a127 1
char *err_access[] = {
d134 2
a135 1
	0, 0,
d138 1
a138 1
	0,
d141 3
a143 1
	0, 0, 0
d146 1
a146 1
char *err_info[] = {
d152 2
a153 1
	0, 0,
d155 1
a155 1
	0,
d159 1
a159 1
	0,
d161 2
a162 1
	0, 0
d255 1
a255 1
void	hdprinterr(char *, short, char **);
d1224 1
a1224 1
	char *str;
d1226 1
a1226 1
	char **tab;
@


1.30
log
@hz is defined in <sys/kernel.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.29 2005/11/13 19:25:09 miod Exp $	*/
d471 1
a471 1
 * Read or constuct a disklabel
@


1.29
log
@Better error message layout.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.28 2005/11/12 23:10:04 miod Exp $	*/
d56 1
a1002 1
		extern int hz;
@


1.28
log
@Constify, and simplify hdgetinfo() which only gets called for known disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.27 2005/11/12 23:08:41 miod Exp $	*/
a519 2
		printf("%s: WARNING: %s, defining `c' partition as entire disk\n",
		    rs->sc_dev.dv_xname, errstring);
d1043 1
a1043 1
	    'a'+HDPART(bp->b_dev), pbn);
d1048 1
a1048 1
	printf("%s %s error:", rs->sc_dev.dv_xname,
d1060 3
a1062 3
		printf("0x%x", *(u_int *)&sp->c_raw[0]);
		printf("0x%x", *(u_int *)&sp->c_raw[4]);
		printf("0x%x\n", *(u_short *)&sp->c_raw[8]);
d1074 1
a1074 1
	printf(" v%d u%d, R0x%x F0x%x A0x%x I0x%x\n",
d1077 3
a1079 4
	printf("P1-P10: ");
	printf("0x%x", *(u_int *)&sp->c_raw[0]);
	printf("0x%x", *(u_int *)&sp->c_raw[4]);
	printf("0x%x\n", *(u_short *)&sp->c_raw[8]);
@


1.27
log
@Print HP-IB disk geometry the same way we print SCSI disk geometries
(especially, with the size in MB).
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.26 2005/09/06 19:01:00 miod Exp $	*/
d153 1
a153 1
struct hdidentinfo hdidentinfo[] = {
d211 1
a211 1
int numhdidentinfo = sizeof(hdidentinfo) / sizeof(hdidentinfo[0]);
d494 4
a497 10
	if (rs->sc_type > -1) {
		lp->d_nsectors = hdidentinfo[rs->sc_type].ri_nbpt;
		lp->d_ntracks = hdidentinfo[rs->sc_type].ri_ntpc;
		lp->d_ncylinders = hdidentinfo[rs->sc_type].ri_ncyl;
		lp->d_secperunit = hdidentinfo[rs->sc_type].ri_nblocks;
	} else {
		lp->d_nsectors = 32;
		lp->d_ntracks = 20;
		lp->d_ncylinders = 1;
	}
@


1.26
log
@anomoly -> anomaly
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.25 2005/01/15 21:13:08 miod Exp $	*/
d424 5
a428 4
	printf("%s: %d cylinders, %d heads, %d blocks, %d bytes/block\n",
	    sc->sc_dev.dv_xname, hdidentinfo[id].ri_ncyl,
	    hdidentinfo[id].ri_ntpc, hdidentinfo[id].ri_nblocks,
	    DEV_BSIZE);
@


1.25
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.24 2004/02/15 02:56:13 tedu Exp $	*/
d388 1
a388 1
	 * Take care of a couple of anomolies:
@


1.24
log
@sneaky disk_unbusy()'s tried to hide
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.23 2003/06/02 23:27:44 millert Exp $	*/
d359 1
a359 1
	bzero(name, sizeof(name)); 
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.22 2003/04/06 15:28:25 krw Exp $	*/
d880 2
a881 1
	disk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid));
@


1.22
log
@Some easy strcpy elimination.

a) strcpy -> strncpy for copies into disklabel fields d_packname and
d_typename.

b) '16' -> 'sizeof d_packname' or 'sizeof d_typename' in existing
strncpy's.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.21 2003/04/06 03:02:43 krw Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@The disklabel fields d_packname and d_typename are not null terminated strings
and should not be created or used as such.

This fixes some instances of both behaviours, and sets the stage for some
strcpy -> strncpy fixup.

ok tdeval@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.20 2002/12/25 20:56:59 miod Exp $	*/
d492 1
a492 1
	strcpy(lp->d_packname, "fictitious");
@


1.20
log
@Turn xxUNIT, xxPARt, xxLABELDEV macro names into uppercase.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.19 2002/12/10 23:33:08 miod Exp $	*/
d491 1
a491 1
	    sizeof(lp->d_typename) - 1);
@


1.19
log
@interupt->interrupt
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.18 2002/06/09 05:23:26 miod Exp $	*/
d526 1
a526 1
	errstring = readdisklabel(hdlabdev(dev), hdstrategy, lp, NULL,
d550 1
a550 1
	int unit = hdunit(dev);
d579 1
a579 1
	part = hdpart(dev);
d609 1
a609 1
	int unit = hdunit(dev);
d614 1
a614 1
	mask = 1 << hdpart(dev);
d645 1
a645 1
	int unit = hdunit(bp->b_dev);
d661 1
a661 1
	pinfo = &rs->sc_dkdev.dk_label->d_partitions[hdpart(bp->b_dev)];
d664 1
a664 1
	offset = (hdpart(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;
d666 1
a666 1
	if (hdpart(bp->b_dev) != RAW_PART) {
d777 1
a777 1
	part = hdpart(bp->b_dev);
d1037 1
a1037 1
	pbn = rs->sc_dkdev.dk_label->d_partitions[hdpart(bp->b_dev)].p_offset;
d1053 1
a1053 1
	    'a'+hdpart(bp->b_dev), pbn);
d1122 1
a1122 1
	int unit = hdunit(dev);
d1139 1
a1139 1
			&lp->d_partitions[hdpart(dev)];
d1170 1
a1170 1
		error = writedisklabel(hdlabdev(dev), hdstrategy, lp,
d1182 1
a1182 1
	int unit = hdunit(dev);
d1201 1
a1201 1
	psize = rs->sc_dkdev.dk_label->d_partitions[hdpart(dev)].p_size *
d1258 2
a1259 2
	unit = hdunit(dev);
	part = hdpart(dev);
@


1.18
log
@convert sleep() calls to tsleep().
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.17 2002/06/09 02:11:47 jsyn Exp $	*/
d229 1
a229 1
void	hdinterupt(void *);
d306 1
a306 1
	sc->sc_hq.hq_intr = hdinterupt;
d863 1
a863 1
hdinterupt(arg)
d877 1
a877 1
		printf("hdinterupt(%d): bp %p, %c, flags %x\n", unit, bp,
d913 1
a913 1
			printf("hdinterupt: recv failed or bad stat %d\n", stat);
@


1.17
log
@fix the use of "cuz" in the tree; these are all in comments

noticed by aaron@@, recommended by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.16 2002/05/30 11:03:52 art Exp $	*/
d563 1
a563 1
		sleep((caddr_t)rs, PRIBIO);
d632 1
a632 1
			sleep((caddr_t)&rs->sc_tab, PRIBIO);
@


1.16
log
@protect biodone with splbio.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.15 2002/03/14 01:26:30 millert Exp $	*/
d1048 1
a1048 1
	 * Note that we don't use harderr cuz it just prints
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.14 2001/09/20 17:02:30 mpech Exp $	*/
d708 1
d710 1
@


1.14
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.13 2001/08/26 00:15:36 miod Exp $	*/
d220 13
a232 13
int	hdident __P((struct device *, struct hd_softc *,
	    struct hpibbus_attach_args *));
void	hdreset __P((struct hd_softc *));
void	hdustart __P((struct hd_softc *));
int	hdgetinfo __P((dev_t, struct hd_softc *, struct disklabel *, int));
void	hdrestart __P((void *));
struct buf *hdfinish __P((struct hd_softc *, struct buf *));

void	hdstart __P((void *));
void	hdinterupt __P((void *));
void	hdgo __P((void *));
int	hdstatus __P((struct hd_softc *));
int	hderror __P((int));
d234 1
a234 1
void	hdprinterr __P((char *, short, char **));
d237 2
a238 2
int	hdmatch __P((struct device *, void *, void *));
void	hdattach __P((struct device *, struct device *, void *));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.14 2001/09/20 17:02:30 mpech Exp $	*/
d220 13
a232 13
int	hdident(struct device *, struct hd_softc *,
	    struct hpibbus_attach_args *);
void	hdreset(struct hd_softc *);
void	hdustart(struct hd_softc *);
int	hdgetinfo(dev_t, struct hd_softc *, struct disklabel *, int);
void	hdrestart(void *);
struct buf *hdfinish(struct hd_softc *, struct buf *);

void	hdstart(void *);
void	hdinterupt(void *);
void	hdgo(void *);
int	hdstatus(struct hd_softc *);
int	hderror(int);
d234 1
a234 1
void	hdprinterr(char *, short, char **);
d237 2
a238 2
int	hdmatch(struct device *, void *, void *);
void	hdattach(struct device *, struct device *, void *);
d563 1
a563 1
		tsleep((caddr_t)rs, PRIBIO, "hdopen", 0);
d632 1
a632 1
			tsleep((caddr_t)&rs->sc_tab, PRIBIO, "hdclose", 0);
a707 1
	s = splbio();
a708 1
	splx(s);
d1046 1
a1046 1
	 * Note that we don't use harderr because it just prints
@


1.14.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d229 1
a229 1
void	hdinterrupt(void *);
d306 1
a306 1
	sc->sc_hq.hq_intr = hdinterrupt;
d491 2
a492 2
	    sizeof(lp->d_typename));
	strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
d526 1
a526 1
	errstring = readdisklabel(HDLABELDEV(dev), hdstrategy, lp, NULL,
d550 1
a550 1
	int unit = HDUNIT(dev);
d579 1
a579 1
	part = HDPART(dev);
d609 1
a609 1
	int unit = HDUNIT(dev);
d614 1
a614 1
	mask = 1 << HDPART(dev);
d645 1
a645 1
	int unit = HDUNIT(bp->b_dev);
d661 1
a661 1
	pinfo = &rs->sc_dkdev.dk_label->d_partitions[HDPART(bp->b_dev)];
d664 1
a664 1
	offset = (HDPART(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;
d666 1
a666 1
	if (HDPART(bp->b_dev) != RAW_PART) {
d777 1
a777 1
	part = HDPART(bp->b_dev);
d863 1
a863 1
hdinterrupt(arg)
d877 1
a877 1
		printf("hdinterrupt(%d): bp %p, %c, flags %x\n", unit, bp,
d913 1
a913 1
			printf("hdinterrupt: recv failed or bad stat %d\n", stat);
d1037 1
a1037 1
	pbn = rs->sc_dkdev.dk_label->d_partitions[HDPART(bp->b_dev)].p_offset;
d1053 1
a1053 1
	    'a'+HDPART(bp->b_dev), pbn);
d1122 1
a1122 1
	int unit = HDUNIT(dev);
d1139 1
a1139 1
			&lp->d_partitions[HDPART(dev)];
d1170 1
a1170 1
		error = writedisklabel(HDLABELDEV(dev), hdstrategy, lp,
d1182 1
a1182 1
	int unit = HDUNIT(dev);
d1201 1
a1201 1
	psize = rs->sc_dkdev.dk_label->d_partitions[HDPART(dev)].p_size *
d1258 2
a1259 2
	unit = HDUNIT(dev);
	part = HDPART(dev);
@


1.13
log
@Nuke annoying defopt, by popular demand. Plus you get two typos fixed
for free.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.12 2001/05/01 16:51:09 millert Exp $	*/
d1030 1
a1030 1
	 * First conjure up the block number at which the error occured.
d1048 1
a1048 1
	 * of the transfer, not necessary where the error occured.
@


1.12
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.11 1998/10/04 01:02:26 millert Exp $	*/
a68 2

#include "opt_useleds.h"
@


1.11
log
@Add DIOCGPDINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.10 1998/10/03 21:18:57 millert Exp $	*/
d317 3
d714 1
a714 1
 * Called from timeout() when handling maintenance releases
d1020 1
a1020 1
		timeout(hdrestart, rs, hdtimo * hz);
@


1.11.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.11 1998/10/04 01:02:26 millert Exp $	*/
a316 3
	/* Initialize timeout structure */
	timeout_set(&sc->sc_timeout, hdrestart, sc);

d711 1
a711 1
 * Called via timeout(9) when handling maintenance releases
d1017 1
a1017 1
		timeout_add(&rs->sc_timeout, hdtimo * hz);
@


1.11.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.11.8.1 2001/07/04 10:15:29 niklas Exp $	*/
d70 2
d1032 1
a1032 1
	 * First conjure up the block number at which the error occurred.
d1050 1
a1050 1
	 * of the transfer, not necessary where the error occurred.
@


1.11.8.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d220 13
a232 13
int	hdident(struct device *, struct hd_softc *,
	    struct hpibbus_attach_args *);
void	hdreset(struct hd_softc *);
void	hdustart(struct hd_softc *);
int	hdgetinfo(dev_t, struct hd_softc *, struct disklabel *, int);
void	hdrestart(void *);
struct buf *hdfinish(struct hd_softc *, struct buf *);

void	hdstart(void *);
void	hdinterupt(void *);
void	hdgo(void *);
int	hdstatus(struct hd_softc *);
int	hderror(int);
d234 1
a234 1
void	hdprinterr(char *, short, char **);
d237 2
a238 2
int	hdmatch(struct device *, void *, void *);
void	hdattach(struct device *, struct device *, void *);
@


1.11.8.4
log
@Sync the SMP branch with 3.3
@
text
@d229 1
a229 1
void	hdinterrupt(void *);
d306 1
a306 1
	sc->sc_hq.hq_intr = hdinterrupt;
d526 1
a526 1
	errstring = readdisklabel(HDLABELDEV(dev), hdstrategy, lp, NULL,
d550 1
a550 1
	int unit = HDUNIT(dev);
d563 1
a563 1
		tsleep((caddr_t)rs, PRIBIO, "hdopen", 0);
d579 1
a579 1
	part = HDPART(dev);
d609 1
a609 1
	int unit = HDUNIT(dev);
d614 1
a614 1
	mask = 1 << HDPART(dev);
d632 1
a632 1
			tsleep((caddr_t)&rs->sc_tab, PRIBIO, "hdclose", 0);
d645 1
a645 1
	int unit = HDUNIT(bp->b_dev);
d661 1
a661 1
	pinfo = &rs->sc_dkdev.dk_label->d_partitions[HDPART(bp->b_dev)];
d664 1
a664 1
	offset = (HDPART(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;
d666 1
a666 1
	if (HDPART(bp->b_dev) != RAW_PART) {
a707 1
	s = splbio();
a708 1
	splx(s);
d775 1
a775 1
	part = HDPART(bp->b_dev);
d861 1
a861 1
hdinterrupt(arg)
d875 1
a875 1
		printf("hdinterrupt(%d): bp %p, %c, flags %x\n", unit, bp,
d911 1
a911 1
			printf("hdinterrupt: recv failed or bad stat %d\n", stat);
d1035 1
a1035 1
	pbn = rs->sc_dkdev.dk_label->d_partitions[HDPART(bp->b_dev)].p_offset;
d1046 1
a1046 1
	 * Note that we don't use harderr because it just prints
d1051 1
a1051 1
	    'a'+HDPART(bp->b_dev), pbn);
d1120 1
a1120 1
	int unit = HDUNIT(dev);
d1137 1
a1137 1
			&lp->d_partitions[HDPART(dev)];
d1168 1
a1168 1
		error = writedisklabel(HDLABELDEV(dev), hdstrategy, lp,
d1180 1
a1180 1
	int unit = HDUNIT(dev);
d1199 1
a1199 1
	psize = rs->sc_dkdev.dk_label->d_partitions[HDPART(dev)].p_size *
d1256 2
a1257 2
	unit = HDUNIT(dev);
	part = HDPART(dev);
@


1.11.8.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.11.8.4 2003/03/27 23:19:19 niklas Exp $	*/
d491 2
a492 2
	    sizeof(lp->d_typename));
	strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
@


1.11.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.11.8.5 2003/05/13 19:41:02 ho Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.8.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d880 1
a880 2
	disk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
@


1.10
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.9 1998/05/07 05:19:34 millert Exp $	*/
d226 1
a226 1
int	hdgetinfo __P((dev_t));
d475 1
a475 1
hdgetinfo(dev)
d477 3
a480 3
	int unit = hdunit(dev);
	struct hd_softc *rs = hd_cd.cd_devs[unit];
	struct disklabel *lp = rs->sc_dkdev.dk_label;
d525 2
a526 1
	errstring = readdisklabel(hdlabdev(dev), hdstrategy, lp, NULL, 0);
d571 1
a571 1
		error = hdgetinfo(dev);
d1125 4
@


1.9
log
@don't clear *_WLABEL on close so 'disklabel -W' is persistent like in the generic scsi system
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.8 1998/04/25 00:38:16 millert Exp $	*/
d525 1
a525 1
	errstring = readdisklabel(hdlabdev(dev), hdstrategy, lp, NULL);
@


1.8
log
@set d_bbsize and d_sbsize in spoofed label to values correct for ffs
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.7 1998/03/27 08:37:06 millert Exp $	*/
d633 1
a633 1
		rs->sc_flags &= ~(HDF_CLOSING|HDF_WLABEL);
@


1.7
log
@fictious disklabels for hpib disks we have in the table.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.6 1997/07/13 09:47:59 downsj Exp $	*/
d63 2
d507 4
@


1.6
log
@sync to NETBSD_CURRENT_970711.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.5 1997/07/06 08:01:52 downsj Exp $	*/
d479 1
a479 2
	struct partition *pi;
	char *msg;
d482 2
a483 2
	 * Set some default values to use while reading the label
	 * or to use if there isn't a label.
d487 3
d491 24
a514 7
	lp->d_nsectors = 32;
	lp->d_ntracks = 20;
	lp->d_ncylinders = 1;
	lp->d_secpercyl = 32*20;
	lp->d_npartitions = 3;
	lp->d_partitions[2].p_offset = 0;
	lp->d_partitions[2].p_size = LABELSECTOR+1;
d519 13
a531 3
	msg = readdisklabel(hdlabdev(dev), hdstrategy, lp, NULL);
	if (msg == NULL)
		return (0);
a532 7
	pi = lp->d_partitions;
	printf("%s: WARNING: %s, defining `c' partition as entire disk\n",
	    rs->sc_dev.dv_xname, msg);
	pi[2].p_size = hdidentinfo[rs->sc_type].ri_nblocks;
	/* XXX reset other info since readdisklabel screws with it */
	lp->d_npartitions = 3;
	pi[0].p_size = 0;
@


1.5
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 2
a2 2
/*	$OpenBSD: hd.c,v 1.4 1997/04/16 11:56:06 downsj Exp $	*/
/*	$NetBSD: rd.c,v 1.32 1997/06/24 00:44:03 thorpej Exp $	*/
a66 5

#include <vm/vm_param.h>
#include <vm/lock.h>
#include <vm/vm_prot.h>
#include <vm/pmap.h>
@


1.4
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: hd.c,v 1.3 1997/02/10 06:43:32 downsj Exp $	*/
/*	$NetBSD: rd.c,v 1.30 1997/04/09 20:01:04 thorpej Exp $	*/
a67 4
#ifdef USELEDS
#include <hp300/hp300/led.h>
#endif

d73 6
d829 1
a829 2
	if (inledcontrol == 0)
		ledcontrol(0, 0, LED_DISK);
d1170 2
a1171 1
	psize = rs->sc_dkdev.dk_label->d_partitions[hdpart(dev)].p_size;
@


1.3
log
@Kill COMPAT_NOLABEL.  It is not appropiate in the modern world.
@
text
@d1 2
a2 2
/*	$OpenBSD: hd.c,v 1.2 1997/02/07 03:22:16 dima Exp $	*/
/*	$NetBSD: rd.c,v 1.27 1997/01/30 09:14:17 thorpej Exp $	*/
d54 3
a56 1
#include <sys/stat.h>
d58 1
a58 1
#include <sys/disk.h>
d60 2
a61 3
#include <sys/fcntl.h>
#include <sys/device.h>
#include <sys/conf.h>
a76 26
int	hdmatch __P((struct device *, void *, void *));
void	hdattach __P((struct device *, struct device *, void *));

struct cfattach hd_ca = {
	sizeof(struct hd_softc), hdmatch, hdattach
};

struct cfdriver hd_cd = {
	NULL, "hd", DV_DISK
};

int	hdident __P((struct device *, struct hd_softc *,
	    struct hpibbus_attach_args *));
void	hdreset __P((struct hd_softc *));
void	hdustart __P((struct hd_softc *));
int	hdgetinfo __P((dev_t));
void	hdrestart __P((void *));
struct buf *hdfinish __P((struct hd_softc *, struct buf *));

void	hdstart __P((void *));
void	hdinterupt __P((void *));
void	hdgo __P((void *));

bdev_decl(hd);
cdev_decl(hd);

d220 31
a326 1
	struct hd_softc rsc;
d438 1
a438 1
	register struct hd_softc *rs;
d481 3
a483 3
	register struct disklabel *lp = rs->sc_dkdev.dk_label;
	register struct partition *pi;
	char *msg, *readdisklabel();
d505 1
a505 1
		return(0);
d523 2
a524 2
	register int unit = hdunit(dev);
	register struct hd_softc *rs;
d584 1
a584 1
	register struct disk *dk = &rs->sc_dkdev;
d616 1
a616 1
	register struct buf *bp;
d620 4
a623 4
	register struct buf *dp = &rs->sc_tab;
	register struct partition *pinfo;
	register daddr_t bn;
	register int sz, s;
d628 1
a628 1
		printf("hdstrategy(%x): dev %x, bn %x, bcount %x, %c\n",
d700 1
a700 1
	register struct buf *bp;
d711 2
a712 2
	register struct hd_softc *rs;
	register struct buf *bp;
d714 1
a714 1
	register struct buf *dp = &rs->sc_tab;
d736 2
a737 2
	register struct buf *bp = rs->sc_tab.b_actf;
	register int part, ctlr, slave;
d745 1
a745 1
		printf("hdstart(%s): bp %x, %c\n", sc->sc_dev.dv_xname, bp,
d761 1
a761 1
		printf("hdstart: hpibsend(%x, %x, %x, %x, %x)\n",
d787 1
a787 1
		printf("%s: hdstart: cmd %x adr %d blk %d len %d ecnt %d\n",
d796 1
a796 1
	printf("%s: hdstart err: cmd 0x%x sect %d blk %d len %d\n",
d838 1
a838 1
	register struct hd_softc *rs = arg;
d840 1
a840 1
	register struct buf *bp = rs->sc_tab.b_actf;
d849 1
a849 1
		printf("hdinterupt(%d): bp %x, %c, flags %x\n", unit, bp,
d905 1
a905 1
	register struct hd_softc *rs;
d907 1
a907 1
	register int c, s;
d958 1
a958 1
	register struct hd_stat *sp;
d1042 3
a1044 3
		printf("%s", hexstr(*(u_int *)&sp->c_raw[0], 8));
		printf("%s", hexstr(*(u_int *)&sp->c_raw[4], 8));
		printf("%s\n", hexstr(*(u_short *)&sp->c_raw[8], 4));
d1047 7
a1053 7
		printf("%s", hexstr(*(u_int *)&rs->sc_ioc.c_pad, 8));
		printf("%s", hexstr(*(u_short *)&rs->sc_ioc.c_hiaddr, 4));
		printf("%s", hexstr(*(u_int *)&rs->sc_ioc.c_addr, 8));
		printf("%s", hexstr(*(u_short *)&rs->sc_ioc.c_nop2, 4));
		printf("%s", hexstr(*(u_int *)&rs->sc_ioc.c_len, 8));
		printf("%s\n", hexstr(*(u_short *)&rs->sc_ioc.c_cmd, 4));
		return(1);
d1060 4
a1063 4
	printf("%s", hexstr(*(u_int *)&sp->c_raw[0], 8));
	printf("%s", hexstr(*(u_int *)&sp->c_raw[4], 8));
	printf("%s\n", hexstr(*(u_short *)&sp->c_raw[8], 4));
	return(1);
d1096 1
a1096 1
	register struct disklabel *lp = sc->sc_dkdev.dk_label;
d1150 1
a1150 1
	register int unit = hdunit(dev);
d1176 1
d1180 1
a1180 1
	char *tab[];
d1182 1
a1182 1
	register int i;
d1187 1
a1187 1
	printf("    %s error field:", str, err);
@


1.2
log
@Changed hdintr() to hdinterupt() so it won't interfere
with HDLC stuff we have.
@
text
@d1 1
a1 1
/*	$OpenBSD: hd.c,v 1.1 1997/02/03 08:11:54 downsj Exp $	*/
d503 2
a504 6
	printf("%s: WARNING: %s, ", rs->sc_dev.dv_xname, msg);
#ifdef COMPAT_NOLABEL
	printf("using old default partitioning\n");
	hdmakedisklabel(unit, lp);
#else
	printf("defining `c' partition as entire disk\n");
a508 1
#endif
@


1.1
log
@rd -> hd
@
text
@d1 1
a1 1
/*	$OpenBSD: rd.c,v 1.8 1997/02/03 04:47:42 downsj Exp $	*/
d96 1
a96 1
void	hdintr __P((void *));
d303 1
a303 1
	sc->sc_hq.hq_intr = hdintr;
d835 1
a835 1
hdintr(arg)
d849 1
a849 1
		printf("hdintr(%d): bp %x, %c, flags %x\n", unit, bp,
d885 1
a885 1
			printf("hdintr: recv failed or bad stat %d\n", stat);
@
