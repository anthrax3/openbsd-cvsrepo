head	1.45;
access;
symbols
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.42.0.14
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.12
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.10
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.8
	OPENBSD_5_0:1.42.0.6
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.4
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.31.0.8
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.26.0.4
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.18
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.16
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.14
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.12
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.10
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.8
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.6
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2014.03.18.22.36.31;	author miod;	state dead;
branches;
next	1.44;

1.44
date	2014.03.11.19.45.27;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2013.08.04.07.21.12;	author martin;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.30.18.10.47;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.28.14.13.27;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.12.12.57.51;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.09.17.53.38;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.01.20.29.00;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.31.12.00.05;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.25.13.49.49;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.09.17.32.25;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.01.11.59.37;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.31.18.13.41;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.30.18.14.09;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.30.18.03.33;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.28.21.13.40;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.27.22.08.39;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.14.00.52.09;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.12.18.01.08;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.15.21.08.36;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.14.22.39.25;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.08.22.13.53;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.19.21.34.42;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.15.20.32.12;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.23.07.05.06;	author millert;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.06.27.05.44.46;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	97.09.14.03.43.02;	author downsj;	state Exp;
branches
	1.11.12.1;
next	1.10;

1.10
date	97.07.14.04.25.13;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.07.06.08.01.46;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.04.16.11.55.58;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.02.03.04.47.13;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.12.15.12.21;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.11.47.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.25.06.36.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.13.35.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.17;	author deraadt;	state Exp;
branches;
next	;

1.11.12.1
date	2001.07.04.10.15.26;	author niklas;	state Exp;
branches;
next	1.11.12.2;

1.11.12.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.11.12.3;

1.11.12.3
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.11.12.4;

1.11.12.4
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.11.12.5;

1.11.12.5
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.11.12.6;

1.11.12.6
date	2004.02.19.10.48.38;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: dca.c,v 1.44 2014/03/11 19:45:27 guenther Exp $	*/
/*	$NetBSD: dca.c,v 1.35 1997/05/05 20:58:18 thorpej Exp $	*/

/*
 * Copyright (c) 1995, 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)dca.c	8.2 (Berkeley) 1/12/94
 */

/*
 *  Driver for the 98626/98644/internal serial interface on hp300/hp400,
 *  based on the National Semiconductor INS8250/NS16550AF/WD16C552 UARTs.
 *
 *  N.B. On the hp700 and some hp300s, there is a "secret bit" with
 *  undocumented behavior.  The third bit of the Modem Control Register
 *  (MCR_IEN == 0x08) must be set to enable interrupts.  Failure to do
 *  so can result in deadlock on those machines, whereas the don't seem to
 *  be any harmful side-effects from setting this bit on non-affected
 *  machines.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/cons.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>
#include <hp300/dev/dcareg.h>

#ifdef DDB
#include <ddb/db_var.h>
#endif

struct	dca_softc {
	struct device		sc_dev;		/* generic device glue */
	struct isr		sc_isr;
	struct dcadevice	*sc_dca;	/* pointer to hardware */
	struct tty		*sc_tty;	/* our tty instance */
	int			sc_oflows;	/* overflow counter */
	short			sc_flags;	/* state flags */
	u_char			sc_cua;		/* callout mode */

	/*
	 * Bits for sc_flags.
	 */
#define	DCA_ACTIVE	0x0001	/* indicates live unit */
#define	DCA_SOFTCAR	0x0002	/* indicates soft-carrier */
#define	DCA_HASFIFO	0x0004	/* indicates unit has FIFO */
#define DCA_ISCONSOLE	0x0008	/* indicates unit is console */

};

int	dcamatch(struct device *, void *, void *);
void	dcaattach(struct device *, struct device *, void *);

struct cfattach dca_ca = {
	sizeof(struct dca_softc), dcamatch, dcaattach
};

struct cfdriver dca_cd = {
	NULL, "dca", DV_TTY
};

int	dcadefaultrate = TTYDEF_SPEED;
int	dcamajor;

cdev_decl(dca);

int	dcaintr(void *);
void	dcaeint(struct dca_softc *, int);
void	dcamint(struct dca_softc *);

int	dcaparam(struct tty *, struct termios *);
void	dcastart(struct tty *);
int	dcastop(struct tty *, int);
int	dcamctl(struct dca_softc *, int, int);
void	dcainit(struct dcadevice *, int);

int	dca_console_scan(int, caddr_t, void *);
cons_decl(dca);

/*
 * Stuff for DCA console support.
 */
static	struct dcadevice *dca_cn = NULL;	/* pointer to hardware */
static	int dcaconsinit;			/* has been initialized */

const struct speedtab dcaspeedtab[] = {
	{	0,	0		},
	{	50,	DCABRD(50)	},
	{	75,	DCABRD(75)	},
	{	110,	DCABRD(110)	},
	{	134,	DCABRD(134)	},
	{	150,	DCABRD(150)	},
	{	200,	DCABRD(200)	},
	{	300,	DCABRD(300)	},
	{	600,	DCABRD(600)	},
	{	1200,	DCABRD(1200)	},
	{	1800,	DCABRD(1800)	},
	{	2400,	DCABRD(2400)	},
	{	4800,	DCABRD(4800)	},
	{	9600,	DCABRD(9600)	},
	{	19200,	DCABRD(19200)	},
	{	38400,	DCABRD(38400)	},
	{	-1,	-1		},
};

#ifdef KGDB
#include <machine/remote-sl.h>

extern dev_t kgdb_dev;
extern int kgdb_rate;
extern int kgdb_debug_init;
#endif

#define	DCAUNIT(x)		(minor(x) & 0x7f)
#define DCACUA(x)		(minor(x) & 0x80)

#ifdef DEBUG
long	fifoin[17];
long	fifoout[17];
long	dcaintrcount[16];
long	dcamintcount[16];
#endif

void	dcainit(struct dcadevice *, int);

int
dcamatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct dio_attach_args *da = aux;

	switch (da->da_id) {
	case DIO_DEVICE_ID_DCA0:
	case DIO_DEVICE_ID_DCA0REM:
	case DIO_DEVICE_ID_DCA1:
	case DIO_DEVICE_ID_DCA1REM:
		return (1);
	}

	return (0);
}

void
dcaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct dca_softc *sc = (struct dca_softc *)self;
	struct dio_attach_args *da = aux;
	struct dcadevice *dca;
	int unit = self->dv_unit;
	int scode = da->da_scode;
	int ipl;

	if (scode == conscode) {
		dca = (struct dcadevice *)conaddr;
		sc->sc_flags |= DCA_ISCONSOLE;
		DELAY(100000);

		/*
		 * We didn't know which unit this would be during
		 * the console probe, so we have to fixup cn_dev here.
		 */
		cn_tab->cn_dev = makedev(dcamajor, unit);
	} else {
		dca = (struct dcadevice *)iomap(dio_scodetopa(da->da_scode),
		    da->da_size);
		if (dca == NULL) {
			printf("\n%s: can't map registers\n",
			    sc->sc_dev.dv_xname);
			return;
		}
	}

	sc->sc_dca = dca;

	ipl = DIO_IPL(dca);
	printf(" ipl %d", ipl);

	dca->dca_reset = 0xFF;
	DELAY(100);

	/* look for a NS 16550AF UART with FIFOs */
	dca->dca_fifo = FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_14;
	DELAY(100);
	if ((dca->dca_iir & IIR_FIFO_MASK) == IIR_FIFO_MASK)
		sc->sc_flags |= DCA_HASFIFO;

	/* Establish interrupt handler. */
	sc->sc_isr.isr_func = dcaintr;
	sc->sc_isr.isr_arg = sc;
	sc->sc_isr.isr_ipl = ipl;
	sc->sc_isr.isr_priority = IPL_TTY;
	dio_intr_establish(&sc->sc_isr, self->dv_xname);

	sc->sc_flags |= DCA_ACTIVE;
	if (self->dv_cfdata->cf_flags)
		sc->sc_flags |= DCA_SOFTCAR;

	/* Enable interrupts. */
	dca->dca_ic = IC_IE;

	/*
	 * Need to reset baud rate, etc. of next print so reset dcaconsinit.
	 * Also make sure console is always "hardwired."
	 */
	if (sc->sc_flags & DCA_ISCONSOLE) {
		dcaconsinit = 0;
		sc->sc_flags |= DCA_SOFTCAR;
		printf(": console, ");
	} else
		printf(": ");

	if (sc->sc_flags & DCA_HASFIFO)
		printf("working fifo\n");
	else
		printf("no fifo\n");

#ifdef KGDB
	if (kgdb_dev == makedev(dcamajor, unit)) {
		if (sc->sc_flags & DCA_ISCONSOLE)
			kgdb_dev = NODEV; /* can't debug over console port */
		else {
			dcainit(dca, kgdb_rate);
			dcaconsinit = 1;	/* don't re-init in dcaputc */
			if (kgdb_debug_init) {
				/*
				 * Print prefix of device name,
				 * let kgdb_connect print the rest.
				 */
				printf("%s: ", sc->sc_dev.dv_xname);
				kgdb_connect(1);
			} else
				printf("%s: kgdb enabled\n",
				    sc->sc_dev.dv_xname);
		}
	}
#endif
}

/* ARGSUSED */
int
dcaopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = DCAUNIT(dev);
	struct dca_softc *sc;
	struct tty *tp;
	struct dcadevice *dca;
	u_char code;
	int s, error = 0;

	if (unit >= dca_cd.cd_ndevs ||
	    (sc = dca_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if ((sc->sc_flags & DCA_ACTIVE) == 0)
		return (ENXIO);

	dca = sc->sc_dca;

	s = spltty();
	if (sc->sc_tty == NULL) {
		tp = sc->sc_tty = ttymalloc(0);
	} else
		tp = sc->sc_tty;
	splx(s);

	tp->t_oproc = dcastart;
	tp->t_param = dcaparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		/*
		 * Sanity clause: reset the card on first open.
		 * The card might be left in an inconsistent state
		 * if card memory is read inadvertently.
		 */
		dcainit(dca, dcadefaultrate);

		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = dcadefaultrate;

		s = spltty();

		dcaparam(tp, &tp->t_termios);
		ttsetwater(tp);

		/* Set the FIFO threshold based on the receive speed. */
		if (sc->sc_flags & DCA_HASFIFO)
                        dca->dca_fifo = FIFO_ENABLE | FIFO_RCV_RST |
                            FIFO_XMT_RST |
			    (tp->t_ispeed <= 1200 ? FIFO_TRIGGER_1 :
			    FIFO_TRIGGER_14);

		/* Flush any pending I/O */
		while ((dca->dca_iir & IIR_IMASK) == IIR_RXRDY)
			code = dca->dca_data;

	} else if (tp->t_state&TS_XCLUDE && suser(p, 0) != 0)
		return (EBUSY);
	else
		s = spltty();

	/* Set modem control state. */
	(void) dcamctl(sc, MCR_DTR | MCR_RTS, DMSET);

	/* Set soft-carrier if so configured. */
	if ((sc->sc_flags & DCA_SOFTCAR) || DCACUA(dev) ||
	    (dcamctl(sc, 0, DMGET) & MSR_DCD))
		tp->t_state |= TS_CARR_ON;

	if (DCACUA(dev)) {
		if (tp->t_state & TS_ISOPEN) {
			/* Ah, but someone already is dialed in... */
			splx(s);
			return (EBUSY);
		}
		sc->sc_cua = 1;		/* We go into CUA mode */
	}

	/* Wait for carrier if necessary. */
	if (flag & O_NONBLOCK) {
		if (!DCACUA(dev) && sc->sc_cua) {
			/* Opening TTY non-blocking... but the CUA is busy */
			splx(s);
			return (EBUSY);
		}
	} else {
		while (sc->sc_cua ||
		    ((tp->t_cflag & CLOCAL) == 0 &&
		    (tp->t_state & TS_CARR_ON) == 0)) {
			tp->t_state |= TS_WOPEN;
			error = ttysleep(tp, (caddr_t)&tp->t_rawq,
			    TTIPRI | PCATCH, ttopen, 0);
			if (!DCACUA(dev) && sc->sc_cua && error == EINTR)
				continue;
			if (error) {
				if (DCACUA(dev))
					sc->sc_cua = 0;
				splx(s);
				return (error);
			}
			if (!DCACUA(dev) && sc->sc_cua)
				continue;
		}
	}
	splx(s);

	if (error == 0)
		error = (*linesw[tp->t_line].l_open)(dev, tp, p);

	return (error);
}

/*ARGSUSED*/
int
dcaclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct dca_softc *sc;
	struct tty *tp;
	struct dcadevice *dca;
	int unit;
	int s;

	unit = DCAUNIT(dev);

	sc = dca_cd.cd_devs[unit];

	dca = sc->sc_dca;
	tp = sc->sc_tty;
	(*linesw[tp->t_line].l_close)(tp, flag, p);

	s = spltty();

	dca->dca_cfcr &= ~CFCR_SBREAK;
#ifdef KGDB
	/* do not disable interrupts if debugging */
	if (dev != kgdb_dev)
#endif
	dca->dca_ier = 0;
	if (tp->t_cflag & HUPCL && (sc->sc_flags & DCA_SOFTCAR) == 0) {
		/* XXX perhaps only clear DTR */
		(void) dcamctl(sc, 0, DMSET);
	}
	tp->t_state &= ~(TS_BUSY | TS_FLUSH);
	sc->sc_cua = 0;
	splx(s);
	ttyclose(tp);
#if 0
	ttyfree(tp);
	sc->sc_tty = NULL;
#endif
	return (0);
}

int
dcaread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit = DCAUNIT(dev);
	struct dca_softc *sc;
	struct tty *tp;
	int error, of;

	sc = dca_cd.cd_devs[unit];

	tp = sc->sc_tty;
	of = sc->sc_oflows;
	error = (*linesw[tp->t_line].l_read)(tp, uio, flag);
	/*
	 * XXX hardly a reasonable thing to do, but reporting overflows
	 * at interrupt time just exacerbates the problem.
	 */
	if (sc->sc_oflows != of)
		log(LOG_WARNING, "%s: silo overflow\n", sc->sc_dev.dv_xname);
	return (error);
}

int
dcawrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct dca_softc *sc = dca_cd.cd_devs[DCAUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
dcatty(dev)
	dev_t dev;
{
	struct dca_softc *sc = dca_cd.cd_devs[DCAUNIT(dev)];

	return (sc->sc_tty);
}

int
dcaintr(arg)
	void *arg;
{
	struct dca_softc *sc = arg;
#ifdef KGDB
	int unit = sc->sc_dev.dv_unit;
#endif
	struct dcadevice *dca = sc->sc_dca;
	struct tty *tp = sc->sc_tty;
	u_char code;
	int iflowdone = 0;

	/*
	 * If interrupts aren't enabled, then the interrupt can't
	 * be for us.
	 */
	if ((dca->dca_ic & (IC_IR|IC_IE)) != (IC_IR|IC_IE))
		return (0);

	for (;;) {
		code = dca->dca_iir;
#ifdef DEBUG
		dcaintrcount[code & IIR_IMASK]++;
#endif

		switch (code & IIR_IMASK) {
		case IIR_NOPEND:
			return (1);
		case IIR_RXTOUT:
		case IIR_RXRDY:
			/* do time-critical read in-line */
/*
 * Process a received byte.  Inline for speed...
 */
#ifdef KGDB
#define	RCVBYTE() \
			code = dca->dca_data; \
			if (tp != NULL) { \
				if ((tp->t_state & TS_ISOPEN) == 0) { \
					if (code == FRAME_END && \
					    kgdb_dev == makedev(dcamajor, unit)) \
						kgdb_connect(0); /* trap into kgdb */ \
				} else \
					(*linesw[tp->t_line].l_rint)(code, tp) \
			}
#else
#define	RCVBYTE() \
			code = dca->dca_data; \
			if (tp != NULL && (tp->t_state & TS_ISOPEN) != 0) \
				(*linesw[tp->t_line].l_rint)(code, tp)
#endif
			RCVBYTE();
			if (sc->sc_flags & DCA_HASFIFO) {
#ifdef DEBUG
				int fifocnt = 1;
#endif
				while ((code = dca->dca_lsr) & LSR_RCV_MASK) {
					if (code == LSR_RXRDY) {
						RCVBYTE();
					} else
						dcaeint(sc, code);
#ifdef DEBUG
					fifocnt++;
#endif
				}
#ifdef DEBUG
				if (fifocnt > 16)
					fifoin[0]++;
				else
					fifoin[fifocnt]++;
#endif
			}
			if (iflowdone == 0 && tp != NULL &&
			    (tp->t_cflag & CRTS_IFLOW) &&
			    tp->t_rawq.c_cc > (TTYHOG(tp) / 2)) {
				dca->dca_mcr &= ~MCR_RTS;
				iflowdone = 1;
			}
			break;
		case IIR_TXRDY:
			if (tp != NULL) {
				tp->t_state &=~ (TS_BUSY|TS_FLUSH);
				if (tp->t_line)
					(*linesw[tp->t_line].l_start)(tp);
				else
					dcastart(tp);
			}
			break;
		case IIR_RLS:
			dcaeint(sc, dca->dca_lsr);
			break;
		default:
			if (code & IIR_NOPEND)
				return (1);
			log(LOG_WARNING, "%s: weird interrupt: 0x%x\n",
			    sc->sc_dev.dv_xname, code);
			/* FALLTHROUGH */
		case IIR_MLSC:
			dcamint(sc);
			break;
		}
	}
}

void
dcaeint(sc, stat)
	struct dca_softc *sc;
	int stat;
{
	struct tty *tp = sc->sc_tty;
	struct dcadevice *dca = sc->sc_dca;
	int c;

	c = dca->dca_data;

#if defined(DDB) && !defined(KGDB)
	if ((sc->sc_flags & DCA_ISCONSOLE) && db_console && (stat & LSR_BI)) {
		Debugger();
		return;
	}
#endif

	if (tp == NULL)
		return;

	if ((tp->t_state & TS_ISOPEN) == 0) {
#ifdef KGDB
		/* we don't care about parity errors */
		if (((stat & (LSR_BI|LSR_FE|LSR_PE)) == LSR_PE) &&
		    kgdb_dev == makedev(dcamajor, sc->sc_hd->hp_unit) &&
		    c == FRAME_END)
			kgdb_connect(0); /* trap into kgdb */
#endif
		return;
	}

	if (stat & (LSR_BI | LSR_FE))
		c |= TTY_FE;
	else if (stat & LSR_PE)
		c |= TTY_PE;
	else if (stat & LSR_OE)
		sc->sc_oflows++;
	(*linesw[tp->t_line].l_rint)(c, tp);
}

void
dcamint(sc)
	struct dca_softc *sc;
{
	struct tty *tp = sc->sc_tty;
	struct dcadevice *dca = sc->sc_dca;
	u_char stat;

	stat = dca->dca_msr;
#ifdef DEBUG
	dcamintcount[stat & 0xf]++;
#endif

	if (tp == NULL)
		return;

	if ((stat & MSR_DDCD) &&
	    (sc->sc_flags & DCA_SOFTCAR) == 0) {
		if (stat & MSR_DCD)
			(void)(*linesw[tp->t_line].l_modem)(tp, 1);
		else if ((*linesw[tp->t_line].l_modem)(tp, 0) == 0)
			dca->dca_mcr &= ~(MCR_DTR | MCR_RTS);
	}
	/*
	 * CTS change.
	 * If doing HW output flow control start/stop output as appropriate.
	 */
	if ((stat & MSR_DCTS) &&
	    (tp->t_state & TS_ISOPEN) && (tp->t_cflag & CCTS_OFLOW)) {
		if (stat & MSR_CTS) {
			tp->t_state &=~ TS_TTSTOP;
			dcastart(tp);
		} else {
			tp->t_state |= TS_TTSTOP;
		}
	}
}

int
dcaioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = DCAUNIT(dev);
	struct dca_softc *sc = dca_cd.cd_devs[unit];
	struct tty *tp = sc->sc_tty;
	struct dcadevice *dca = sc->sc_dca;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		dca->dca_cfcr |= CFCR_SBREAK;
		break;

	case TIOCCBRK:
		dca->dca_cfcr &= ~CFCR_SBREAK;
		break;

	case TIOCSDTR:
		(void) dcamctl(sc, MCR_DTR | MCR_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) dcamctl(sc, MCR_DTR | MCR_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) dcamctl(sc, *(int *)data, DMSET);
		break;

	case TIOCMBIS:
		(void) dcamctl(sc, *(int *)data, DMBIS);
		break;

	case TIOCMBIC:
		(void) dcamctl(sc, *(int *)data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = dcamctl(sc, 0, DMGET);
		break;

	case TIOCGFLAGS: {
		int bits = 0;

		if (sc->sc_flags & DCA_SOFTCAR)
			bits |= TIOCFLAG_SOFTCAR;

		if (tp->t_cflag & CLOCAL)
			bits |= TIOCFLAG_CLOCAL;

		*(int *)data = bits;
		break;
	}

	case TIOCSFLAGS: {
		int userbits;

		error = suser(p, 0);
		if (error)
			return (EPERM);

		userbits = *(int *)data;

		if ((userbits & TIOCFLAG_SOFTCAR) ||
		    (sc->sc_flags & DCA_ISCONSOLE))
			sc->sc_flags |= DCA_SOFTCAR;

		if (userbits & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;

		break;
	}

	default:
		return (ENOTTY);
	}
	return (0);
}

int
dcaparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	int unit = DCAUNIT(tp->t_dev);
	struct dca_softc *sc = dca_cd.cd_devs[unit];
	struct dcadevice *dca = sc->sc_dca;
	int cfcr, cflag = t->c_cflag;
	int ospeed = ttspeedtab(t->c_ospeed, dcaspeedtab);
	int s;

	/* check requested parameters */
        if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed))
                return (EINVAL);

	switch (cflag & CSIZE) {
	case CS5:
		cfcr = CFCR_5BITS;
		break;

	case CS6:
		cfcr = CFCR_6BITS;
		break;

	case CS7:
		cfcr = CFCR_7BITS;
		break;

	case CS8:
	default:	/* XXX gcc whines about cfcr being unitialized... */
		cfcr = CFCR_8BITS;
		break;
	}
	if (cflag & PARENB) {
		cfcr |= CFCR_PENAB;
		if ((cflag & PARODD) == 0)
			cfcr |= CFCR_PEVEN;
	}
	if (cflag & CSTOPB)
		cfcr |= CFCR_STOPB;

	s = spltty();

	if (ospeed == 0)
		(void) dcamctl(sc, 0, DMSET);	/* hang up line */

	/*
	 * Set the FIFO threshold based on the receive speed, if we
	 * are changing it.
	 */
	if (tp->t_ispeed != t->c_ispeed) {
		if (sc->sc_flags & DCA_HASFIFO)
			dca->dca_fifo = FIFO_ENABLE |
			    (t->c_ispeed <= 1200 ? FIFO_TRIGGER_1 :
			    FIFO_TRIGGER_14);
	}

	if (ospeed != 0) {
		dca->dca_cfcr |= CFCR_DLAB;
		dca->dca_data = ospeed & 0xFF;
		dca->dca_ier = ospeed >> 8;
		dca->dca_cfcr = cfcr;
	} else
		dca->dca_cfcr = cfcr;

	/* and copy to tty */
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = cflag;

	dca->dca_ier = IER_ERXRDY | IER_ETXRDY | IER_ERLS | IER_EMSC;
	dca->dca_mcr |= MCR_IEN;

	splx(s);
	return (0);
}

void
dcastart(tp)
	struct tty *tp;
{
	int s, c, unit = DCAUNIT(tp->t_dev);
	struct dca_softc *sc = dca_cd.cd_devs[unit];
	struct dcadevice *dca = sc->sc_dca;

	s = spltty();

	if (tp->t_state & (TS_TIMEOUT|TS_TTSTOP))
		goto out;
	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto out;
	if (dca->dca_lsr & LSR_TXRDY) {
		tp->t_state |= TS_BUSY;
		if (sc->sc_flags & DCA_HASFIFO) {
			for (c = 0; c < 16 && tp->t_outq.c_cc; ++c)
				dca->dca_data = getc(&tp->t_outq);
#ifdef DEBUG
			if (c > 16)
				fifoout[0]++;
			else
				fifoout[c]++;
#endif
		} else
			dca->dca_data = getc(&tp->t_outq);
	}

out:
	splx(s);
}

/*
 * Stop output on a line.
 */
/*ARGSUSED*/
int
dcastop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY)
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	splx(s);
	return (0);
}

int
dcamctl(sc, bits, how)
	struct dca_softc *sc;
	int bits, how;
{
	struct dcadevice *dca = sc->sc_dca;
	int s;

	/*
	 * Always make sure MCR_IEN is set (unless setting to 0)
	 */
#ifdef KGDB
	if (how == DMSET && kgdb_dev == makedev(dcamajor, sc->sc_hd->hp_unit))
		bits |= MCR_IEN;
	else
#endif
	if (how == DMBIS || (how == DMSET && bits))
		bits |= MCR_IEN;
	else if (how == DMBIC)
		bits &= ~MCR_IEN;
	s = spltty();

	switch (how) {
	case DMSET:
		dca->dca_mcr = bits;
		break;

	case DMBIS:
		dca->dca_mcr |= bits;
		break;

	case DMBIC:
		dca->dca_mcr &= ~bits;
		break;

	case DMGET:
		bits = dca->dca_msr;
		break;
	}
	splx(s);
	return (bits);
}

void
dcainit(dca, rate)
	struct dcadevice *dca;
	int rate;
{
	int s;
	short stat;

	s = splhigh();

	dca->dca_reset = 0xFF;
	DELAY(100);
	dca->dca_ic = IC_IE;

	dca->dca_cfcr = CFCR_DLAB;
	rate = ttspeedtab(rate, dcaspeedtab);
	dca->dca_data = rate & 0xFF;
	dca->dca_ier = rate >> 8;
	dca->dca_cfcr = CFCR_8BITS;
	dca->dca_ier = IER_ERXRDY | IER_ETXRDY;
	dca->dca_fifo =
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_1;
	dca->dca_mcr = MCR_DTR | MCR_RTS;
	DELAY(100);
	stat = dca->dca_iir;
	splx(s);
}

/*
 * Following are all routines needed for DCA to act as console
 */

int
dca_console_scan(scode, va, arg)
	int scode;
	caddr_t va;
	void *arg;
{
	struct dcadevice *dca = (struct dcadevice *)va;
	struct consdev *cp = arg;
	u_int pri;

	switch (dca->dca_id) {
	case DCAID0:
	case DCAID1:
		pri = CN_LOWPRI;
		break;

	case DCAID0 | DCACON:
	case DCAID1 | DCACON:
		pri = CN_HIGHPRI;
		break;

	default:
		return (0);
	}

#ifdef CONSCODE
	/*
	 * Raise our priority, if appropriate.
	 */
	if (scode == CONSCODE)
		pri = CN_FORCED;
#endif

	/* Only raise priority. */
	if (pri > cp->cn_pri)
		cp->cn_pri = pri;

	/*
	 * If our priority is higher than the currently-remembered
	 * console, stash our priority, for the benefit of dcacninit().
	 */
	if (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri) {
		cn_tab = cp;
		conscode = scode;
		return (DIO_SIZE(scode, va));
	}
	return (0);
}

void
dcacnprobe(cp)
	struct consdev *cp;
{

	/* locate the major number */
	for (dcamajor = 0; dcamajor < nchrdev; dcamajor++)
		if (cdevsw[dcamajor].d_open == dcaopen)
			break;

	/* initialize required fields */
	cp->cn_dev = makedev(dcamajor, 0);	/* XXX */

	console_scan(dca_console_scan, cp);

#ifdef KGDB
	/* XXX this needs to be fixed. */
	if (major(kgdb_dev) == 1)			/* XXX */
		kgdb_dev = makedev(dcamajor, minor(kgdb_dev));
#endif
}

/* ARGSUSED */
void
dcacninit(cp)
	struct consdev *cp;
{

	/*
	 * We are not interested by the second console pass.
	 */
	if (consolepass != 0)
		return;

	dca_cn = (struct dcadevice *)conaddr;
	dcainit(dca_cn, dcadefaultrate);
	dcaconsinit = 1;
}

/* ARGSUSED */
int
dcacngetc(dev)
	dev_t dev;
{
	u_char stat;
	int c, s;

	s = splhigh();
	while (((stat = dca_cn->dca_lsr) & LSR_RXRDY) == 0)
		;
	c = dca_cn->dca_data;
	stat = dca_cn->dca_iir;
	splx(s);
	return (c);
}

/*
 * Console kernel output character routine.
 */
/* ARGSUSED */
void
dcacnputc(dev, c)
	dev_t dev;
	int c;
{
	int timo;
	u_char stat;
	int s = splhigh();

	if (dcaconsinit == 0) {
		dcainit(dca_cn, dcadefaultrate);
		dcaconsinit = 1;
	}
	/* wait for any pending transmission to finish */
	timo = 50000;
	while (((stat = dca_cn->dca_lsr) & LSR_TXRDY) == 0 && --timo)
		;
	dca_cn->dca_data = c;
	/* wait for this transmission to complete */
	timo = 1500000;
	while (((stat = dca_cn->dca_lsr) & LSR_TXRDY) == 0 && --timo)
		;
	/* clear any interrupts generated by this transmission */
	stat = dca_cn->dca_iir;
	splx(s);
}
@


1.44
log
@lint is gone, and the 'lint' conditional was never in the implementation
namespace, so stop changing behavior when it's #defined

ok beck@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.43 2013/08/04 07:21:12 martin Exp $	*/
@


1.43
log
@de-lint hp300

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.42 2010/07/02 17:27:01 nicm Exp $	*/
a1096 4

#ifdef lint
	stat = dev; if (stat) return;
#endif
@


1.42
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.41 2010/06/30 18:10:47 miod Exp $	*/
a1074 4

#ifdef lint
	stat = dev; if (stat) return (0);
#endif
@


1.41
log
@Make this compile after TTYHOG definition change (but the logic should be fixed
to not depend on it).
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.40 2010/06/28 14:13:27 deraadt Exp $	*/
d864 3
a866 9
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
		if (tp->t_outq.c_cc == 0)
			goto out;
	}
@


1.40
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.39 2010/04/12 12:57:51 tedu Exp $	*/
d573 1
a573 1
			    tp->t_rawq.c_cc > (TTYHOG / 2)) {
@


1.39
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.38 2009/11/09 17:53:38 nicm Exp $	*/
d311 1
a311 1
		tp = sc->sc_tty = ttymalloc();
@


1.38
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.37 2009/11/01 20:29:00 nicm Exp $	*/
d403 1
a403 1
		error = (*linesw[tp->t_line].l_open)(dev, tp);
d427 1
a427 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.37
log
@Call selwakeup()/KNOTE() even if the queue has emptied completely.

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.36 2009/10/31 12:00:05 fgsch Exp $	*/
a869 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.36
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.35 2009/10/31 06:40:16 deraadt Exp $	*/
d869 2
a872 2
		selwakeup(&tp->t_wsel);
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.35
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.34 2009/01/25 13:49:49 miod Exp $	*/
d352 1
a352 1
	} else if (tp->t_state&TS_XCLUDE && p->p_ucred->cr_uid != 0)
@


1.34
log
@Behave correctly in interrupt handlers if no tty has been allocated yet
(this was supposed to have been fixed in r1.25, but there was still a
missing check).
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.33 2008/01/23 16:37:56 jsing Exp $	*/
d872 1
@


1.33
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.32 2007/11/09 17:32:25 miod Exp $	*/
d571 3
a573 2
			if (!iflowdone && (tp->t_cflag&CRTS_IFLOW) &&
			    tp->t_rawq.c_cc > TTYHOG/2) {
@


1.32
log
@Get rid of IPL_TTYNOBUF, it was handled exactly like IPL_TTY for years.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.31 2006/01/01 11:59:37 miod Exp $	*/
d998 1
a998 1
		pri = CN_NORMAL;
d1003 1
a1003 1
		pri = CN_REMOTE;
@


1.31
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.30 2005/12/31 18:13:41 miod Exp $	*/
d238 1
a238 2
	sc->sc_isr.isr_priority =
	    (sc->sc_flags & DCA_HASFIFO) ? IPL_TTY : IPL_TTYNOBUF;
@


1.30
log
@Rework (once again) the console code, in order to match the PROM's logic better.
When not running on serial console, the PROM will pick the ``internal''
graphics device, and if it does not exist, the DIO device with the lowest
select code, and will resort to SGC devices if no internal or DIO device
was found.

However, the current logic would search for a certain frame buffer type first,
then for its best hardware location, following the order they are listed
in conf.c.

By replacing gazillions of almost-exactly-duplicated frame buffer code with
one single instance, which is device type-agnostic, we can match the PROM
(and the bootblocks) logic again. Plus this saves a few KB of code!
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.29 2005/12/30 18:14:09 miod Exp $	*/
a1046 1
	cp->cn_pri = CN_DEAD;
@


1.29
log
@Kill conforced, and have console devices use CN_FORCED priority instead.
This means we are no longer aborting the console scans even if the final
console has been found, but on the other hand makes some logic simpler;
plus it will be necessary for upcoming scode vs device loop order reversal.
No user-visible change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.28 2005/12/30 18:03:33 miod Exp $	*/
d1049 1
a1049 1
	console_scan(dca_console_scan, cp, HP300_BUS_DIO);
@


1.28
log
@When a driver claims console, let it set conscode to itself, instead of
letting the bus walkers do this for it. This is necessary since apci does
not use the bus walkers, now that we do not force console probes to stop
when apci claims console.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.27 2005/12/28 21:13:40 miod Exp $	*/
d994 1
a994 1
	int force = 0, pri;
d1015 2
a1016 4
	if (scode == CONSCODE) {
		pri = CN_REMOTE;
		force = conforced = 1;
	}
d1027 1
a1027 1
	if (((cn_tab == NULL) || (cp->cn_pri > cn_tab->cn_pri)) || force) {
a1047 4

	/* Abort early if console is already forced. */
	if (conforced)
		return;
@


1.27
log
@Define dca remote console identifiers as regular identifier with the bit 7
set, like dcm does. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.26 2005/02/27 22:08:39 miod Exp $	*/
d1031 1
@


1.26
log
@Invoke hp300_cninit() twice, with a global variable letting the
console-dependent routines know which pass they are being invoked in.

The first pass is the usual console detection code. The second pass runs
after uvm is initialized, and will allow devices which need VM services to
run to claim the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.25 2005/02/14 00:52:09 miod Exp $	*/
d1002 2
a1003 2
	case DCAREMID0:
	case DCAREMID1:
@


1.25
log
@Behave correctly in interrupt handlers if no tty has been allocated yet.
Prevents monkeys pounding on your serial terminal from panicing your kernel
before getty gets spawned on the serial ports.

dcm(4) looks safe from this problem from code inspection.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.24 2005/02/12 18:01:08 miod Exp $	*/
d1068 6
@


1.24
log
@Use cons_decl() instead of rolling our own prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.23 2005/01/15 21:08:36 miod Exp $	*/
d524 1
d537 8
a544 6
			if ((tp->t_state & TS_ISOPEN) == 0) { \
				if (code == FRAME_END && \
				    kgdb_dev == makedev(dcamajor, unit)) \
					kgdb_connect(0); /* trap into kgdb */ \
			} else \
				(*linesw[tp->t_line].l_rint)(code, tp)
d548 1
a548 1
			if ((tp->t_state & TS_ISOPEN) != 0) \
d579 7
a585 5
			tp->t_state &=~ (TS_BUSY|TS_FLUSH);
			if (tp->t_line)
				(*linesw[tp->t_line].l_start)(tp);
			else
				dcastart(tp);
d595 1
a595 1
			/* fall through */
d613 11
d628 2
a629 2
		    kgdb_dev == makedev(dcamajor, sc->sc_hd->hp_unit)
		    && c == FRAME_END)
d634 1
a634 6
#if defined(DDB) && !defined(KGDB)
	if ((sc->sc_flags & DCA_ISCONSOLE) && db_console && (stat & LSR_BI)) {
		Debugger();
		return;
	}
#endif
d656 4
@


1.23
log
@Use DIO_SIZE() macro instead of rolling our own implementation of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.22 2005/01/14 22:39:25 miod Exp $	*/
d122 1
a122 4
void	dcacnprobe(struct consdev *);
void	dcacninit(struct consdev *);
int	dcacngetc(dev_t);
void	dcacnputc(dev_t, int);
@


1.22
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.21 2005/01/08 22:13:53 miod Exp $	*/
a981 1
	u_char *dioiidev;
d1019 1
a1019 5
		if (scode >= 132) {
			dioiidev = (u_char *)va;
			return ((dioiidev[0x101] + 1) * 0x100000);
		}
		return (DIO_DEVSIZE);
@


1.21
log
@Only use one set of DIO size and address defines, from <dev/dioreg.h>
rather than <include/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.20 2004/09/29 07:35:52 miod Exp $	*/
d61 1
d303 1
a303 1
 
d350 1
a350 1
			    FIFO_TRIGGER_14);   
d389 1
a389 1
			tp->t_state |= TS_WOPEN; 
d411 1
a411 1
 
d424 1
a424 1
 
d455 1
a455 1
 
d468 1
a468 1
 
d480 1
a480 1
 
d489 1
a489 1
 
d501 1
a501 1
 
d683 1
a683 1
 
d773 1
a773 1
 
d839 1
a839 1
 
d847 1
a847 1
 
d873 1
a873 1
			dca->dca_data = getc(&tp->t_outq); 
d898 1
a898 1
 
d1047 1
a1047 1
	console_scan(dca_console_scan, cp);
@


1.20
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.19 2004/09/19 21:34:42 mickey Exp $	*/
d1023 1
a1023 1
		return (DIOCSIZE);
@


1.19
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.18 2003/10/03 16:44:49 miod Exp $	*/
d77 1
d237 6
a242 2
	(void) dio_intr_establish(dcaintr, sc, ipl,
	    (sc->sc_flags & DCA_HASFIFO) ? IPL_TTY : IPL_TTYNOBUF);
@


1.18
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.17 2003/08/15 20:32:12 tedu Exp $	*/
d131 1
a131 1
struct speedtab dcaspeedtab[] = {
@


1.17
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.16 2003/06/02 23:27:44 millert Exp $	*/
a309 1
		tty_attach(tp);
a443 1
	tty_detach(tp);
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.15 2002/03/14 01:26:30 millert Exp $	*/
d736 1
a736 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.14 2002/02/15 20:45:30 nordin Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.13 2001/09/23 07:05:06 millert Exp $	*/
d97 2
a98 2
int	dcamatch __P((struct device *, void *, void *));
void	dcaattach __P((struct device *, struct device *, void *));
d113 15
a127 15
int	dcaintr __P((void *));
void	dcaeint __P((struct dca_softc *, int));
void	dcamint __P((struct dca_softc *));

int	dcaparam __P((struct tty *, struct termios *));
void	dcastart __P((struct tty *));
int	dcastop __P((struct tty *, int));
int	dcamctl __P((struct dca_softc *, int, int));
void	dcainit __P((struct dcadevice *, int));

int	dca_console_scan __P((int, caddr_t, void *));
void	dcacnprobe __P((struct consdev *));
void	dcacninit __P((struct consdev *));
int	dcacngetc __P((dev_t));
void	dcacnputc __P((dev_t, int));
d173 1
a173 1
void	dcainit __P((struct dcadevice *, int));
@


1.13
log
@For serial console, drop into ddb on <break> if ddb.console is nonzero
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.12 2001/06/27 05:44:46 nate Exp $	*/
d938 1
a938 1
	(void) splx(s);
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.13 2001/09/23 07:05:06 millert Exp $	*/
d97 2
a98 2
int	dcamatch(struct device *, void *, void *);
void	dcaattach(struct device *, struct device *, void *);
d113 15
a127 15
int	dcaintr(void *);
void	dcaeint(struct dca_softc *, int);
void	dcamint(struct dca_softc *);

int	dcaparam(struct tty *, struct termios *);
void	dcastart(struct tty *);
int	dcastop(struct tty *, int);
int	dcamctl(struct dca_softc *, int, int);
void	dcainit(struct dcadevice *, int);

int	dca_console_scan(int, caddr_t, void *);
void	dcacnprobe(struct consdev *);
void	dcacninit(struct consdev *);
int	dcacngetc(dev_t);
void	dcacnputc(dev_t, int);
d173 1
a173 1
void	dcainit(struct dcadevice *, int);
d938 1
a938 1
	splx(s);
@


1.12
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.11 1997/09/14 03:43:02 downsj Exp $	*/
d75 4
d621 6
@


1.11
log
@callout support sync, from Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.10 1997/07/14 04:25:13 downsj Exp $	*/
d800 1
a800 1
	 * Set the FIFO threshold based on the recieve speed, if we
@


1.11.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.11 1997/09/14 03:43:02 downsj Exp $	*/
d800 1
a800 1
	 * Set the FIFO threshold based on the receive speed, if we
@


1.11.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.11.12.1 2001/07/04 10:15:26 niklas Exp $	*/
a74 4
#ifdef DDB
#include <ddb/db_var.h>
#endif

a616 6
#if defined(DDB) && !defined(KGDB)
	if ((sc->sc_flags & DCA_ISCONSOLE) && db_console && (stat & LSR_BI)) {
		Debugger();
		return;
	}
#endif
@


1.11.12.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d938 1
a938 1
	splx(s);
@


1.11.12.4
log
@Merge in -current from about a week ago
@
text
@d97 2
a98 2
int	dcamatch(struct device *, void *, void *);
void	dcaattach(struct device *, struct device *, void *);
d113 15
a127 15
int	dcaintr(void *);
void	dcaeint(struct dca_softc *, int);
void	dcamint(struct dca_softc *);

int	dcaparam(struct tty *, struct termios *);
void	dcastart(struct tty *);
int	dcastop(struct tty *, int);
int	dcamctl(struct dca_softc *, int, int);
void	dcainit(struct dcadevice *, int);

int	dca_console_scan(int, caddr_t, void *);
void	dcacnprobe(struct consdev *);
void	dcacninit(struct consdev *);
int	dcacngetc(dev_t);
void	dcacnputc(dev_t, int);
d173 1
a173 1
void	dcainit(struct dcadevice *, int);
@


1.11.12.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.11.12.4 2002/03/28 10:07:18 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.12.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d310 1
d445 1
d736 1
a736 1
		error = suser(p, 0);
@


1.10
log
@cua devices for all!
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.9 1997/07/06 08:01:46 downsj Exp $	*/
d381 3
a383 3
		while (!(DCACUA(dev) && sc->sc_cua) &&
		    (tp->t_cflag & CLOCAL) == 0 &&
		    (tp->t_state & TS_CARR_ON) == 0) {
d387 2
d395 2
@


1.9
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: dca.c,v 1.8 1997/04/16 11:55:58 downsj Exp $	*/
d81 1
d159 2
a160 1
#define	DCAUNIT(x)		minor(x)
d307 1
d313 2
d360 2
a361 1
	if ((sc->sc_flags & DCA_SOFTCAR) || (dcamctl(sc, 0, DMGET) & MSR_DCD))
d364 9
d374 9
a382 2
	if ((flag & O_NONBLOCK) == 0)
		while ((tp->t_cflag & CLOCAL) == 0 &&
d388 2
d394 1
d437 1
@


1.8
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: dca.c,v 1.7 1997/02/03 04:47:13 downsj Exp $	*/
/*	$NetBSD: dca.c,v 1.34 1997/04/14 02:33:16 thorpej Exp $	*/
d234 1
a234 1
	(void) intr_establish(dcaintr, sc, ipl,
@


1.7
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: dca.c,v 1.6 1997/01/12 15:12:21 downsj Exp $	*/
/*	$NetBSD: dca.c,v 1.32 1997/01/30 09:18:34 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995, 1996 Jason R. Thorpe.  All rights reserved.
d66 1
a73 1
#include <hp300/hp300/isr.h>
a102 3
void	dcastart();
int	dcaparam();
int	dcaintr __P((void *));
d106 18
d131 17
a147 17
	0,	0,
	50,	DCABRD(50),
	75,	DCABRD(75),
	110,	DCABRD(110),
	134,	DCABRD(134),
	150,	DCABRD(150),
	200,	DCABRD(200),
	300,	DCABRD(300),
	600,	DCABRD(600),
	1200,	DCABRD(1200),
	1800,	DCABRD(1800),
	2400,	DCABRD(2400),
	4800,	DCABRD(4800),
	9600,	DCABRD(9600),
	19200,	DCABRD(19200),
	38400,	DCABRD(38400),
	-1,	-1
d234 2
a235 2
	(void) isrlink(dcaintr, sc, ipl,
	    (sc->sc_flags & DCA_HASFIFO) ? ISRPRI_TTY : ISRPRI_TTYNOBUF);
d386 3
a388 3
	register struct tty *tp;
	register struct dcadevice *dca;
	register int unit;
d473 1
d475 4
a478 3
	register struct dcadevice *dca = sc->sc_dca;
	register struct tty *tp = sc->sc_tty;
	register u_char code;
d520 1
a520 1
				register int fifocnt = 1;
d567 1
d596 1
d633 1
a633 1
	int cmd;
d724 2
a725 2
	register struct tty *tp;
	register struct termios *t;
d752 1
d802 1
a802 1
	register struct tty *tp;
d844 1
a844 1
void
d846 1
a846 1
	register struct tty *tp;
d849 1
a849 1
	register int s;
d856 1
d859 1
d1055 1
a1055 1
	register int c;
@


1.6
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: dca.c,v 1.31 1996/12/17 08:41:00 thorpej Exp $	*/
a68 4
#ifndef NEWCONFIG
#include <hp300/dev/device.h>
#endif

a76 3
#ifndef NEWCONFIG
	struct hp_device	*sc_hd;		/* device info */
#endif
d92 1
a92 2
#ifdef NEWCONFIG
int	dcamatch __P((struct device *, struct cfdata *, void *));
a101 10
#else /* ! NEWCONFIG */
int	dcamatch();
void	dcaattach();
struct	driver dcadriver = {
	dcamatch, dcaattach, "dca",
};

#include "dca.h"
struct dca_softc dca_softc[NDCA];
#endif /* NEWCONFIG */
a153 1
#ifdef NEWCONFIG
d157 1
a157 2
	struct cfdata *match;
	void *aux;
a170 7
#else /* ! NEWCONFIG */
int
dcamatch(hd)
	register struct hp_device *hd;
{
	struct dcadevice *dca = (struct dcadevice *)hd->hp_addr;
	struct dca_softc *sc = &dca_softc[hd->hp_unit];
a171 14
	if (dca->dca_id != DCAID0 &&
	    dca->dca_id != DCAREMID0 &&
	    dca->dca_id != DCAID1 &&
	    dca->dca_id != DCAREMID1)
		return (0);

	hd->hp_ipl = DCAIPL(dca->dca_ic);
	sc->sc_hd = hd;

	return (1);
}
#endif /* NEWCONFIG */

#ifdef NEWCONFIG
a182 11
#else /* ! NEWCONFIG */
void
dcaattach(hd)
	register struct hp_device *hd;
{
	int unit = hd->hp_unit;
	struct dcadevice *dca = (struct dcadevice *)hd->hp_addr;
	struct dca_softc *sc = &dca_softc[unit];
	int scode = hd->hp_args->hw_sc;
	int ipl = hd->hp_ipl;
#endif /* NEWCONFIG */
a194 1
#ifdef NEWCONFIG
a201 1
#endif /* NEWCONFIG */
a205 1
#ifdef NEWCONFIG
a207 5
#else /* ! NEWCONFIG */
	/* XXX Set the device class. */
	hd->hp_dev.dv_class = DV_TTY;
	bcopy(&hd->hp_dev, &sc->sc_dev, sizeof(struct device));
#endif /* NEWCONFIG */
a222 1
#ifdef NEWCONFIG
a223 3
#else
	if (hd->hp_flags)
#endif
a280 1
#ifdef NEWCONFIG
a283 5
#else
	if (unit >= NDCA)
		return (ENXIO);
	sc = &dca_softc[unit];
#endif /* NEWCONFIG */
a377 1
#ifdef NEWCONFIG
a378 3
#else
	sc = &dca_softc[unit];
#endif
a417 1
#ifdef NEWCONFIG
a418 3
#else
	sc = &dca_softc[unit];
#endif
a437 1
#ifdef NEWCONFIG
a439 3
#else
	struct tty *tp = dca_softc[DCAUNIT(dev)].sc_tty;
#endif
a447 1
#ifdef NEWCONFIG
a448 3
#else
	struct dca_softc *sc = &dca_softc[DCAUNIT(dev)];
#endif
a619 1
#ifdef NEWCONFIG
a620 3
#else
	struct dca_softc *sc = &dca_softc[unit];
#endif
a708 1
#ifdef NEWCONFIG
a709 3
#else
	struct dca_softc *sc = &dca_softc[unit];
#endif
a784 1
#ifdef NEWCONFIG
a785 3
#else
	struct dca_softc *sc = &dca_softc[unit];
#endif
@


1.5
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: dca.c,v 1.23.4.1 1996/06/06 15:39:09 thorpej Exp $	*/
a39 3
#include "dca.h"
#if NDCA > 0

d62 1
d69 1
d71 5
a78 6
int	dcamatch();
void	dcaattach();
struct	driver dcadriver = {
	dcamatch, dcaattach, "dca",
};

d80 2
d83 1
d97 23
a119 1
} dca_softc[NDCA];
a123 1
int	ndca = NDCA;
d172 20
d210 1
d212 13
d232 3
d236 2
a237 1
	if (hd->hp_args->hw_sc == conscode) {
d246 10
d258 11
a277 2
	sc->sc_dca = dca;

d279 1
a279 1
	isrlink(dcaintr, sc, hd->hp_ipl,
d283 3
d287 1
d321 1
a321 1
				printf("%s: ", sc->sc_hd->hp_xname);
d325 1
a325 1
				    sc->sc_hd->hp_xname);
d345 5
d352 2
a354 1
	sc = &dca_softc[unit];
d448 3
d452 2
d488 2
a489 2
	struct dca_softc *sc = &dca_softc[unit];
	struct tty *tp = sc->sc_tty;
d491 6
d498 1
d506 1
a506 1
		log(LOG_WARNING, "%s: silo overflow\n", sc->sc_hd->hp_xname);
d516 4
d521 1
d530 5
d536 1
a536 1
	return (dca_softc[DCAUNIT(dev)].sc_tty);
d544 1
a544 1
	int unit = sc->sc_hd->hp_unit;
d627 1
a627 1
			    sc->sc_hd->hp_xname, code);
d706 3
d710 1
d799 3
d803 1
d879 3
d883 1
d922 1
a922 1
int
d998 3
a1000 2
	dca->dca_fifo = FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_14;
	dca->dca_mcr |= MCR_IEN;
a1157 1
#endif /* NDCA > 0 */
@


1.4
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: dca.c,v 1.23 1996/03/03 16:48:52 thorpej Exp $	*/
d270 1
a270 1
	if (sc->sc_tty == NULL)
d272 2
a273 1
	else
d379 1
@


1.3
log
@from netbsd:
Re-work the serial console support a bit; it doesn't depend on statically
allocated softc's now.
@
text
@d1 1
a1 1
/*	$NetBSD: dca.c,v 1.19 1995/12/31 00:27:16 thorpej Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Jason R. Thorpe.  All rights reserved.
d65 1
a83 1
	struct isr		sc_isr;		/* interrupt handler */
d93 1
d98 2
a99 1
int	dcaparam(), dcaintr();
a102 1
int	dcafastservice;
d105 1
a105 2
 * Stuff for DCA console support.  This could probably be done a little
 * better.
a107 1
static	int dca_lastcnpri = CN_DEAD;		/* XXX last priority */
a108 5
#ifdef DCACONSOLE
static	int dcaconsole = DCACONSOLE;
#else
static	int dcaconsole = -1;
#endif
d176 2
a177 1
	if (unit == dcaconsole)
d180 7
d199 2
a200 4
	sc->sc_isr.isr_ipl = hd->hp_ipl;
	sc->sc_isr.isr_arg = unit;
	sc->sc_isr.isr_intr = dcaintr;
	isrlink(&sc->sc_isr);
d213 1
a213 1
	if (unit == dcaconsole) {
d227 1
a227 1
		if (dcaconsole == unit)
a337 7
	/*
	 * XXX hack to speed up unbuffered builtin port.
	 * If dca_fastservice is set, a level 5 interrupt
	 * will be directed to dcaintr first.
	 */
	if (error == 0 && unit == 0 && (sc->sc_flags & DCA_HASFIFO) == 0)
		dcafastservice = 1;
a356 3
	if (unit == 0)
		dcafastservice = 0;

d426 2
a427 2
dcaintr(unit)
	register int unit;
d429 2
a430 1
	struct dca_softc *sc = &dca_softc[unit];
d659 2
a660 1
		if ((userbits & TIOCFLAG_SOFTCAR) || (unit == dcaconsole))
d883 10
a892 25
void
dcacnprobe(cp)
	struct consdev *cp;
{
	struct dcadevice *dca;
	int unit;

	/* locate the major number */
	for (dcamajor = 0; dcamajor < nchrdev; dcamajor++)
		if (cdevsw[dcamajor].d_open == dcaopen)
			break;

	/* XXX: ick */
	unit = CONUNIT;

	dca = (struct dcadevice *)sctova(CONSCODE);

	/* make sure hardware exists */
	if (badaddr((short *)dca)) {
		cp->cn_pri = CN_DEAD;
		return;
	}

	/* initialize required fields */
	cp->cn_dev = makedev(dcamajor, unit);
d897 1
a897 1
		cp->cn_pri = CN_NORMAL;
d899 1
d902 1
a902 1
		cp->cn_pri = CN_REMOTE;
d904 1
d906 1
a906 2
		cp->cn_pri = CN_DEAD;
		break;
d909 1
d911 1
a911 1
	 * If dcaconsole is initialized, raise our priority.
d913 9
a921 2
	if (dcaconsole == unit)
		cp->cn_pri = CN_REMOTE;
d925 1
a925 2
	 * DCA, stash our priority and address, for the benefit of
	 * dcacninit().
d927 7
a933 3
	if (cp->cn_pri > dca_lastcnpri) {
		dca_lastcnpri = cp->cn_pri;
		dca_cn = dca;
d935 22
d959 1
d965 1
a969 1
	int unit = DCAUNIT(cp->cn_dev);
d971 1
a972 1
	dcaconsole = unit;
a987 6
	/*
	 * NOTE: This assumes that DCAUNIT(dev) == dcaconsole.  If
	 * it doesn't, well, you lose.  (It's also extremely unlikely
	 * that will ever not be the case.)
	 */

a1012 6

	/*
	 * NOTE: This assumes that DCAUNIT(dev) == dcaconsole.  If
	 * it doesn't, well, you lose.  (It's also extremely unlikely
	 * that will ever not be the case.)
	 */
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: dca.c,v 1.18 1995/12/02 18:15:50 thorpej Exp $	*/
d65 4
a70 2

#include <machine/cpu.h>
d99 11
d111 1
a111 1
int	dcaconsole = DCACONSOLE;
d113 1
a113 1
int	dcaconsole = -1;
a114 4
int	dcaconsinit;
int	dcadefaultrate = TTYDEF_SPEED;
int	dcamajor;
int	dcafastservice;
d153 2
d230 1
a230 1
			(void) dcainit(sc, kgdb_rate);
d284 1
a284 1
		dcainit(sc, dcadefaultrate);
d860 27
a889 1
#include <dev/cons.h>
d895 1
a895 1
	struct dca_softc *sc;
a904 1
	sc = &dca_softc[unit];
d906 1
a906 1
	sc->sc_dca = (struct dcadevice *) sctova(CONSCODE);
d909 1
a909 1
	if (badaddr((short *)sc->sc_dca)) {
d917 1
a917 1
	switch (sc->sc_dca->dca_id) {
d936 11
a957 1
	struct dca_softc *sc = &dca_softc[unit];
d959 1
a959 1
	dcainit(sc, dcadefaultrate);
d964 1
a964 31
dcainit(sc, rate)
	struct dca_softc *sc;
	int rate;
{
	struct dcadevice *dca = sc->sc_dca;
	int s;
	short stat;

#ifdef lint
	stat = sc->sc_hd->hp_unit; if (stat) return;
#endif

	s = splhigh();

	dca->dca_reset = 0xFF;
	DELAY(100);
	dca->dca_ic = IC_IE;

	dca->dca_cfcr = CFCR_DLAB;
	rate = ttspeedtab(rate, dcaspeedtab);
	dca->dca_data = rate & 0xFF;
	dca->dca_ier = rate >> 8;
	dca->dca_cfcr = CFCR_8BITS;
	dca->dca_ier = IER_ERXRDY | IER_ETXRDY;
	dca->dca_fifo = FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_14;
	dca->dca_mcr |= MCR_IEN;
	DELAY(100);
	stat = dca->dca_iir;
	splx(s);
}

a968 2
	struct dca_softc *sc = &dca_softc[DCAUNIT(dev)];
	struct dcadevice *dca = sc->sc_dca;
d975 7
d983 1
a983 1
	while (((stat = dca->dca_lsr) & LSR_RXRDY) == 0)
d985 2
a986 2
	c = dca->dca_data;
	stat = dca->dca_iir;
d994 1
a999 2
	struct dca_softc *sc = &dca_softc[DCAUNIT(dev)];
	struct dcadevice *dca = sc->sc_dca;
d1007 7
d1015 1
a1015 1
		(void) dcainit(sc, dcadefaultrate);
d1020 1
a1020 1
	while (((stat = dca->dca_lsr) & LSR_TXRDY) == 0 && --timo)
d1022 1
a1022 1
	dca->dca_data = c;
d1025 1
a1025 1
	while (((stat = dca->dca_lsr) & LSR_TXRDY) == 0 && --timo)
d1027 2
a1028 7
	/*
	 * If the "normal" interface was busy transfering a character
	 * we must let our interrupt through to keep things moving.
	 * Otherwise, we clear the interrupt that we have caused.
	 */
	if ((sc->sc_tty->t_state & TS_BUSY) == 0)
		stat = dca->dca_iir;
d1031 1
a1031 1
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dca.c,v 1.17 1995/10/04 17:46:08 thorpej Exp $	*/
d4 1
d41 1
d43 2
a44 4
 *  Driver for National Semiconductor INS8250/NS16550AF/WD16C552 UARTs.
 *  Includes:
 *	98626/98644/internal serial interface on hp300/hp400
 *	internal serial ports on hp700
d53 1
a68 1
#ifdef hp300
a69 4
#endif
#ifdef hp700
#include <machine/asp.h>
#endif
d71 2
a72 1
int	dcaprobe();
d74 1
a74 1
	dcaprobe, "dca",
d77 17
a95 3
int	dcasoftCAR;
int	dca_active;
int	dca_hasfifo;
a104 4
struct	dcadevice *dca_addr[NDCA];
struct	tty *dca_tty[NDCA];
#ifdef hp300
struct	isr dcaisr[NDCA];
a105 2
#endif
int	dcaoflows[NDCA];
d135 1
a135 1
#define	UNIT(x)		minor(x)
d144 2
a145 1
dcaprobe(hd)
d148 2
a149 2
	register struct dcadevice *dca;
	register int unit;
a150 2
	dca = (struct dcadevice *)hd->hp_addr;
#ifdef hp300
d156 14
a169 2
#endif
	unit = hd->hp_unit;
a173 1
#ifdef hp300
a175 1
#endif
d181 1
a181 1
		dca_hasfifo |= 1 << unit;
d183 9
a191 9
	dca_addr[unit] = dca;
#ifdef hp300
	hd->hp_ipl = DCAIPL(dca->dca_ic);
	dcaisr[unit].isr_ipl = hd->hp_ipl;
	dcaisr[unit].isr_arg = unit;
	dcaisr[unit].isr_intr = dcaintr;
	isrlink(&dcaisr[unit]);
#endif
	dca_active |= 1 << unit;
d193 21
a213 1
		dcasoftCAR |= (1 << unit);
d219 1
a219 1
			(void) dcainit(unit, kgdb_rate);
d226 1
a226 1
				printf("dca%d: ", unit);
d229 2
a230 1
				printf("dca%d: kgdb enabled\n", unit);
a233 21
#ifdef hp300
	dca->dca_ic = IC_IE;
#endif

	/*
	 * Need to reset baud rate, etc. of next print so reset dcaconsinit.
	 * Also make sure console is always "hardwired."
	 */
	if (unit == dcaconsole) {
		dcaconsinit = 0;
		dcasoftCAR |= (1 << unit);
		printf("dca%d: console, ", unit);
	} else
		printf("dca%d: ", unit);

	if (dca_hasfifo & (1 << unit))
		printf("working fifo\n");
	else
		printf("no fifo\n");

	return (1);
d243 3
a245 2
	register struct tty *tp;
	register int unit;
d250 5
a254 2
	unit = UNIT(dev);
	if (unit >= NDCA || (dca_active & (1 << unit)) == 0)
d256 5
a260 2
	if (!dca_tty[unit])
		tp = dca_tty[unit] = ttymalloc();
d262 1
a262 1
		tp = dca_tty[unit];
a266 2
	dca = dca_addr[unit];

d273 1
a273 1
		dcainit(unit, dcadefaultrate);
d289 1
a289 1
		if (dca_hasfifo & (1 << unit))
d305 1
a305 1
	(void) dcamctl(dev, MCR_DTR | MCR_RTS, DMSET);
d308 1
a308 1
	if ((dcasoftCAR & (1 << unit)) || (dcamctl(dev, 0, DMGET) & MSR_DCD))
a326 1
#ifdef hp300
d332 1
a332 1
	if (error == 0 && unit == 0 && (dca_hasfifo & 1) == 0)
d334 1
a334 1
#endif
d345 1
d351 2
a352 2
	unit = UNIT(dev);
#ifdef hp300
d355 4
a358 3
#endif
	dca = dca_addr[unit];
	tp = dca_tty[unit];
d369 1
a369 1
	if (tp->t_cflag & HUPCL && (dcasoftCAR & (1 << unit)) == 0) {
d371 1
a371 1
		(void) dcamctl(dev, 0, DMSET);
d378 1
a378 1
	dca_tty[unit] = (struct tty *)0;
d389 3
a391 2
	int unit = UNIT(dev);
	register struct tty *tp = dca_tty[unit];
d394 1
a394 1
	of = dcaoflows[unit];
d400 2
a401 2
	if (dcaoflows[unit] != of)
		log(LOG_WARNING, "dca%d: silo overflow\n", unit);
d411 1
a411 1
	register struct tty *tp = dca_tty[UNIT(dev)];
d421 1
a421 1
	return (dca_tty[UNIT(dev)]);
d428 3
a430 1
	register struct dcadevice *dca;
a431 1
	register struct tty *tp;
d434 4
a437 2
	dca = dca_addr[unit];
#ifdef hp300
d440 1
a440 2
#endif
	tp = dca_tty[unit];
d471 1
a471 1
			if (dca_hasfifo & (1 << unit)) {
d479 1
a479 1
						dcaeint(unit, code, dca);
d505 1
a505 1
			dcaeint(unit, dca->dca_lsr, dca);
d510 2
a511 2
			log(LOG_WARNING, "dca%d: weird interrupt: 0x%x\n",
			    unit, code);
d514 1
a514 1
			dcamint(unit, dca);
d520 7
a526 6
dcaeint(unit, stat, dca)
	register int unit, stat;
	register struct dcadevice *dca;
{
	register struct tty *tp;
	register int c;
a527 1
	tp = dca_tty[unit];
d533 2
a534 1
		    kgdb_dev == makedev(dcamajor, unit) && c == FRAME_END)
d544 1
a544 1
		dcaoflows[unit]++;
d548 2
a549 3
dcamint(unit, dca)
	register int unit;
	register struct dcadevice *dca;
d551 3
a553 2
	register struct tty *tp;
	register u_char stat;
a554 1
	tp = dca_tty[unit];
d560 1
a560 1
	    (dcasoftCAR & (1 << unit)) == 0) {
d589 5
a593 4
	register struct tty *tp;
	register int unit = UNIT(dev);
	register struct dcadevice *dca;
	register int error;
a594 1
	tp = dca_tty[unit];
a601 2
	dca = dca_addr[unit];

d612 1
a612 1
		(void) dcamctl(dev, MCR_DTR | MCR_RTS, DMBIS);
d616 1
a616 1
		(void) dcamctl(dev, MCR_DTR | MCR_RTS, DMBIC);
d620 1
a620 1
		(void) dcamctl(dev, *(int *)data, DMSET);
d624 1
a624 1
		(void) dcamctl(dev, *(int *)data, DMBIS);
d628 1
a628 1
		(void) dcamctl(dev, *(int *)data, DMBIC);
d632 1
a632 1
		*(int *)data = dcamctl(dev, 0, DMGET);
d638 1
a638 1
		if (dcasoftCAR & (1 << unit))
d658 1
a658 1
			dcasoftCAR |= (1 << unit);
d677 4
a680 3
	register struct dcadevice *dca;
	register int cfcr, cflag = t->c_cflag;
	int unit = UNIT(tp->t_dev);
a687 2
	dca = dca_addr[unit];

d716 1
a716 1
		(void) dcamctl(unit, 0, DMSET);	/* hang up line */
d723 1
a723 1
		if (dca_hasfifo & (1 << unit))
d753 3
a755 2
	register struct dcadevice *dca;
	int s, unit, c;
a756 3
	unit = UNIT(tp->t_dev);
	dca = dca_addr[unit];

d772 1
a772 1
		if (dca_hasfifo & (1 << unit)) {
d807 2
a808 2
dcamctl(dev, bits, how)
	dev_t dev;
d811 1
a811 2
	register struct dcadevice *dca;
	register int unit;
a813 2
	unit = UNIT(dev);
	dca = dca_addr[unit];
d818 1
a818 1
	if (how == DMSET && kgdb_dev == makedev(dcamajor, unit))
d827 1
a828 1

d858 1
d868 3
a870 2
#ifdef hp300
	dca_addr[CONUNIT] = (struct dcadevice *) sctova(CONSCODE);
d873 1
a873 1
	if (badaddr((short *)dca_addr[unit])) {
a876 4
#endif
#ifdef hp700
	dca_addr[CONUNIT] = CONPORT;
#endif
d880 2
a881 2
#ifdef hp300
	switch (dca_addr[unit]->dca_id) {
d894 1
a894 4
#endif
#ifdef hp700
	cp->cn_pri = CN_NORMAL;
#endif
d910 2
a911 1
	int unit = UNIT(cp->cn_dev);
d913 1
a913 1
	dcainit(unit, dcadefaultrate);
d918 3
a920 2
dcainit(unit, rate)
	int unit, rate;
d922 1
a922 1
	register struct dcadevice *dca;
d927 1
a927 1
	stat = unit; if (stat) return;
a929 1
	dca = dca_addr[unit];
a931 1
#ifdef hp300
a934 1
#endif
d953 3
a955 2
	register struct dcadevice *dca = dca_addr[UNIT(dev)];
	register u_char stat;
d978 4
a981 3
	register struct dcadevice *dca = dca_addr[UNIT(dev)];
	register int timo;
	register u_char stat;
d988 1
a988 1
		(void) dcainit(UNIT(dev), dcadefaultrate);
d1005 1
a1005 1
	if ((dca_tty[UNIT(dev)]->t_state & TS_BUSY) == 0)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
