head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.18
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.14
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.12
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.10
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.8.0.18
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.16
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.14
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.12
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.18;

1.18
date	2013.08.04.07.21.13;	author martin;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.26.13.43.38;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.13.18.52.15;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.00.43.08;	author mickey;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2001.05.01.16.51.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.06.08.01.54;	author downsj;	state Exp;
branches
	1.8.12.1;
next	1.7;

1.7
date	97.04.16.11.56.13;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.03.04.47.40;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.12.15.12.56;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.11.47.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.50;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.20;	author deraadt;	state Exp;
branches;
next	;

1.8.12.1
date	2001.07.04.10.15.32;	author niklas;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	;

1.10.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: nhpib.c,v 1.18 2013/08/04 07:21:13 martin Exp $	*/
/*	$NetBSD: nhpib.c,v 1.17 1997/05/05 21:06:41 thorpej Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nhpib.c	8.2 (Berkeley) 1/12/94
 */

/*
 * Internal/98624 HPIB driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <machine/autoconf.h>
#include <machine/intr.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>

#include <hp300/dev/dmavar.h>

#include <hp300/dev/nhpibreg.h>
#include <hp300/dev/hpibvar.h>

/*
 * ODD parity table for listen and talk addresses and secondary commands.
 * The TI9914A doesn't produce the parity bit.
 */
static const u_char listnr_par[] = {
	0040,0241,0242,0043,0244,0045,0046,0247,
	0250,0051,0052,0253,0054,0255,0256,0057,
	0260,0061,0062,0263,0064,0265,0266,0067,
	0070,0271,0272,0073,0274,0075,0076,0277,
};
static const u_char talker_par[] = {
	0100,0301,0302,0103,0304,0105,0106,0307,
	0310,0111,0112,0313,0114,0315,0316,0117,
	0320,0121,0122,0323,0124,0325,0326,0127,
	0130,0331,0332,0133,0334,0135,0136,0337,
};
static const u_char sec_par[] = {
	0340,0141,0142,0343,0144,0345,0346,0147,
	0150,0351,0352,0153,0354,0155,0156,0357,
	0160,0361,0362,0163,0364,0165,0166,0367,
	0370,0171,0172,0373,0174,0375,0376,0177
};

void	nhpibifc(struct nhpibdevice *);
void	nhpibreadtimo(void *);
int	nhpibwait(struct nhpibdevice *, int);

void	nhpibreset(struct hpibbus_softc *);
int	nhpibsend(struct hpibbus_softc *, int, int, void *, int);
int	nhpibrecv(struct hpibbus_softc *, int, int, void *, int);
int	nhpibppoll(struct hpibbus_softc *);
void	nhpibppwatch(void *);
void	nhpibgo(struct hpibbus_softc *, int, int, void *, int, int, int);
void	nhpibdone(struct hpibbus_softc *);
int	nhpibintr(void *);

/*
 * Our controller ops structure.
 */
struct	hpib_controller nhpib_controller = {
	nhpibreset,
	nhpibsend,
	nhpibrecv,
	nhpibppoll,
	nhpibppwatch,
	nhpibgo,
	nhpibdone,
	nhpibintr
};

struct nhpib_softc {
	struct device sc_dev;		/* generic device glue */
	struct isr sc_isr;
	struct nhpibdevice *sc_regs;	/* device registers */
	struct hpibbus_softc *sc_hpibbus; /* XXX */
	struct timeout sc_read_to;	/* nhpibreadtimo timeout */
	struct timeout sc_watch_to;	/* nhpibppwatch timeout */
};

int	nhpibmatch(struct device *, void *, void *);
void	nhpibattach(struct device *, struct device *, void *);

struct cfattach nhpib_ca = {
	sizeof(struct nhpib_softc), nhpibmatch, nhpibattach
};

struct cfdriver nhpib_cd = {
	NULL, "nhpib", DV_DULL
};

int
nhpibmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct dio_attach_args *da = aux;

	/*
	 * Internal HP-IB doesn't always return a device ID,
	 * so we rely on the sysflags.
	 */
	if (da->da_scode == 7 && internalhpib)
		return (1);

	if (da->da_id == DIO_DEVICE_ID_NHPIB)
		return (1);

	return (0);
}

void
nhpibattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct nhpib_softc *sc = (struct nhpib_softc *)self;
	struct dio_attach_args *da = aux;
	struct hpibdev_attach_args ha;
	const char *desc;
	int ipl, type = HPIBA;

	sc->sc_regs = (struct nhpibdevice *)iomap(dio_scodetopa(da->da_scode),
	    da->da_size);
	if (sc->sc_regs == NULL) {
		printf("\n%s: can't map registers\n", self->dv_xname);
		return;
	}

	ipl = DIO_IPL(sc->sc_regs);

	if (da->da_scode == 7 && internalhpib)
		desc = DIO_DEVICE_DESC_IHPIB;
	else if (da->da_id == DIO_DEVICE_ID_NHPIB) {
		type = HPIBB;
		desc = DIO_DEVICE_DESC_NHPIB;
	} else
		desc = "unknown HP-IB!";

	printf(" ipl %d: %s\n", ipl, desc);

	/* Establish the interrupt handler. */
	sc->sc_isr.isr_func = nhpibintr;
	sc->sc_isr.isr_arg = sc;
	sc->sc_isr.isr_ipl = ipl;
	sc->sc_isr.isr_priority = IPL_BIO;
	dio_intr_establish(&sc->sc_isr, self->dv_xname);

	/* Initialize timeout structures */
	timeout_set(&sc->sc_read_to, nhpibreadtimo, sc);

	ha.ha_ops = &nhpib_controller;
	ha.ha_type = type;			/* XXX */
	ha.ha_ba = (type == HPIBA) ? HPIBA_BA :
	    (sc->sc_regs->hpib_csa & CSA_BA);
	ha.ha_softcpp = &sc->sc_hpibbus;	/* XXX */
	(void)config_found(self, &ha, hpibdevprint);
}

void
nhpibreset(hs)
	struct hpibbus_softc *hs;
{
	struct nhpib_softc *sc = (struct nhpib_softc *)hs->sc_dev.dv_parent;
	struct nhpibdevice *hd = sc->sc_regs;

	hd->hpib_acr = AUX_SSWRST;
	hd->hpib_ar = hs->sc_ba;
	hd->hpib_lim = LIS_ERR;
	hd->hpib_mim = 0;
	hd->hpib_acr = AUX_CDAI;
	hd->hpib_acr = AUX_CSHDW;
	hd->hpib_acr = AUX_SSTD1;
	hd->hpib_acr = AUX_SVSTD1;
	hd->hpib_acr = AUX_CPP;
	hd->hpib_acr = AUX_CHDFA;
	hd->hpib_acr = AUX_CHDFE;
	hd->hpib_acr = AUX_RHDF;
	hd->hpib_acr = AUX_CSWRST;
	nhpibifc(hd);
	hd->hpib_ie = IDS_IE;
	hd->hpib_data = C_DCL_P;
	DELAY(100000);
}

void
nhpibifc(hd)
	struct nhpibdevice *hd;
{
	hd->hpib_acr = AUX_TCA;
	hd->hpib_acr = AUX_CSRE;
	hd->hpib_acr = AUX_SSIC;
	DELAY(100);
	hd->hpib_acr = AUX_CSIC;
	hd->hpib_acr = AUX_SSRE;
}

int
nhpibsend(hs, slave, sec, ptr, origcnt)
	struct hpibbus_softc *hs;
	int slave, sec, origcnt;
	void *ptr;
{
	struct nhpib_softc *sc = (struct nhpib_softc *)hs->sc_dev.dv_parent;
	struct nhpibdevice *hd = sc->sc_regs;
	int cnt = origcnt;
	char *addr = ptr;

	hd->hpib_acr = AUX_TCA;
	hd->hpib_data = C_UNL_P;
	if (nhpibwait(hd, MIS_BO))
		goto senderror;
	hd->hpib_data = talker_par[hs->sc_ba];
	hd->hpib_acr = AUX_STON;
	if (nhpibwait(hd, MIS_BO))
		goto senderror;
	hd->hpib_data = listnr_par[slave];
	if (nhpibwait(hd, MIS_BO))
		goto senderror;
	if (sec >= 0 || sec == -2) {
		if (sec == -2)		/* selected device clear KLUDGE */
			hd->hpib_data = C_SDC_P;
		else
			hd->hpib_data = sec_par[sec];
		if (nhpibwait(hd, MIS_BO))
			goto senderror;
	}
	hd->hpib_acr = AUX_GTS;
	if (cnt) {
		while (--cnt > 0) {
			hd->hpib_data = *addr++;
			if (nhpibwait(hd, MIS_BO))
				goto senderror;
		}
		hd->hpib_acr = AUX_EOI;
		hd->hpib_data = *addr;
		if (nhpibwait(hd, MIS_BO))
			goto senderror;
		hd->hpib_acr = AUX_TCA;
#if 0
		/*
		 * May be causing 345 disks to hang due to interference
		 * with PPOLL mechanism.
		 */
		hd->hpib_data = C_UNL_P;
		(void) nhpibwait(hd, MIS_BO);
#endif
	}
	return(origcnt);

senderror:
	nhpibifc(hd);
	return(origcnt - cnt - 1);
}

int
nhpibrecv(hs, slave, sec, ptr, origcnt)
	struct hpibbus_softc *hs;
	int slave, sec, origcnt;
	void *ptr;
{
	struct nhpib_softc *sc = (struct nhpib_softc *)hs->sc_dev.dv_parent;
	struct nhpibdevice *hd = sc->sc_regs;
	int cnt = origcnt;
	char *addr = ptr;

	/*
	 * Slave < 0 implies continuation of a previous receive
	 * that probably timed out.
	 */
	if (slave >= 0) {
		hd->hpib_acr = AUX_TCA;
		hd->hpib_data = C_UNL_P;
		if (nhpibwait(hd, MIS_BO))
			goto recverror;
		hd->hpib_data = listnr_par[hs->sc_ba];
		hd->hpib_acr = AUX_SLON;
		if (nhpibwait(hd, MIS_BO))
			goto recverror;
		hd->hpib_data = talker_par[slave];
		if (nhpibwait(hd, MIS_BO))
			goto recverror;
		if (sec >= 0) {
			hd->hpib_data = sec_par[sec];
			if (nhpibwait(hd, MIS_BO))
				goto recverror;
		}
		hd->hpib_acr = AUX_RHDF;
		hd->hpib_acr = AUX_GTS;
	}
	if (cnt) {
		while (--cnt >= 0) {
			if (nhpibwait(hd, MIS_BI))
				goto recvbyteserror;
			*addr++ = hd->hpib_data;
		}
		hd->hpib_acr = AUX_TCA;
		hd->hpib_data = (slave == 31) ? C_UNA_P : C_UNT_P;
		(void) nhpibwait(hd, MIS_BO);
	}
	return(origcnt);

recverror:
	nhpibifc(hd);
recvbyteserror:
	return(origcnt - cnt - 1);
}

void
nhpibgo(hs, slave, sec, ptr, count, rw, timo)
	struct hpibbus_softc *hs;
	int slave, sec, count, rw, timo;
	void *ptr;
{
	struct nhpib_softc *sc = (struct nhpib_softc *)hs->sc_dev.dv_parent;
	struct nhpibdevice *hd = sc->sc_regs;
	char *addr = ptr;

	hs->sc_flags |= HPIBF_IO;
	if (timo)
		hs->sc_flags |= HPIBF_TIMO;
	if (rw == B_READ)
		hs->sc_flags |= HPIBF_READ;
#ifdef DEBUG
	else if (hs->sc_flags & HPIBF_READ) {
		printf("nhpibgo: HPIBF_READ still set\n");
		hs->sc_flags &= ~HPIBF_READ;
	}
#endif
	hs->sc_count = count;
	hs->sc_addr = addr;
	if (hs->sc_flags & HPIBF_READ) {
		hs->sc_curcnt = count;
		dmago(hs->sc_dq->dq_chan, addr, count, DMAGO_BYTE|DMAGO_READ);
		nhpibrecv(hs, slave, sec, 0, 0);
		hd->hpib_mim = MIS_END;
	} else {
		hd->hpib_mim = 0;
		if (count < hpibdmathresh) {
			hs->sc_curcnt = count;
			nhpibsend(hs, slave, sec, addr, count);
			nhpibdone(hs);
			return;
		}
		hs->sc_curcnt = --count;
		dmago(hs->sc_dq->dq_chan, addr, count, DMAGO_BYTE);
		nhpibsend(hs, slave, sec, 0, 0);
	}
	hd->hpib_ie = IDS_IE | IDS_DMA(hs->sc_dq->dq_chan);
}

/*
 * This timeout can only happen if a DMA read finishes DMAing with the read
 * still pending (more data in read transaction than the driver was prepared
 * to accept).  At the moment, variable-record tape drives are the only things
 * capabale of doing this.  We repeat the necessary code from nhpibintr() -
 * easier and quicker than calling nhpibintr() for this special case.
 */
void
nhpibreadtimo(arg)
	void *arg;
{
	struct nhpib_softc *sc = arg;
	struct hpibbus_softc *hs = sc->sc_hpibbus;
	int s;

	s = splbio();
	if (hs->sc_flags & HPIBF_IO) {
		struct nhpibdevice *hd = sc->sc_regs;
		struct hpibqueue *hq;

		hd->hpib_mim = 0;
		hd->hpib_acr = AUX_TCA;
		hs->sc_flags &= ~(HPIBF_DONE|HPIBF_IO|HPIBF_READ|HPIBF_TIMO);
		dmafree(hs->sc_dq);

		hq = TAILQ_FIRST(&hs->sc_queue);
		(hq->hq_intr)(hq->hq_softc);
	}
	splx(s);
}

void
nhpibdone(hs)
	struct hpibbus_softc *hs;
{
	struct nhpib_softc *sc = (struct nhpib_softc *)hs->sc_dev.dv_parent;
	struct nhpibdevice *hd = sc->sc_regs;
	int cnt;

	cnt = hs->sc_curcnt;
	hs->sc_addr += cnt;
	hs->sc_count -= cnt;
	hs->sc_flags |= HPIBF_DONE;
	hd->hpib_ie = IDS_IE;
	if (hs->sc_flags & HPIBF_READ) {
		if ((hs->sc_flags & HPIBF_TIMO) &&
		    (hd->hpib_ids & IDS_IR) == 0)
			timeout_add_msec(&sc->sc_read_to, 1000 >> 2);
	} else {
		if (hs->sc_count == 1) {
			(void) nhpibwait(hd, MIS_BO);
			hd->hpib_acr = AUX_EOI;
			hd->hpib_data = *hs->sc_addr;
			hd->hpib_mim = MIS_BO;
		}
#ifdef DEBUG
		else if (hs->sc_count)
			panic("nhpibdone");
#endif
	}
}

int
nhpibintr(arg)
	void *arg;
{
	struct nhpib_softc *sc = arg;
	struct hpibbus_softc *hs = sc->sc_hpibbus;
	struct nhpibdevice *hd = sc->sc_regs;
	struct hpibqueue *hq;
	int stat0;
	int stat1;

	if ((hd->hpib_ids & IDS_IR) == 0)
		return(0);
	stat0 = hd->hpib_mis;
	stat1 = hd->hpib_lis;

	hq = TAILQ_FIRST(&hs->sc_queue);

	if (hs->sc_flags & HPIBF_IO) {
		hd->hpib_mim = 0;
		if ((hs->sc_flags & HPIBF_DONE) == 0) {
			hs->sc_flags &= ~HPIBF_TIMO;
			dmastop(hs->sc_dq->dq_chan);
		} else if (hs->sc_flags & HPIBF_TIMO)
			timeout_del(&sc->sc_read_to);
		hd->hpib_acr = AUX_TCA;
		hs->sc_flags &= ~(HPIBF_DONE|HPIBF_IO|HPIBF_READ|HPIBF_TIMO);

		dmafree(hs->sc_dq);
		(hq->hq_intr)(hq->hq_softc);
	} else if (hs->sc_flags & HPIBF_PPOLL) {
		hd->hpib_mim = 0;
		stat0 = nhpibppoll(hs);
		if (stat0 & (0x80 >> hq->hq_slave)) {
			hs->sc_flags &= ~HPIBF_PPOLL;
			(hq->hq_intr)(hq->hq_softc);
		}
#ifdef DEBUG
		else
			printf("%s: PPOLL intr bad status %x\n",
			       hs->sc_dev.dv_xname, stat0);
#endif
	}
	return(1);
}

int
nhpibppoll(hs)
	struct hpibbus_softc *hs;
{
	struct nhpib_softc *sc = (struct nhpib_softc *)hs->sc_dev.dv_parent;
	struct nhpibdevice *hd = sc->sc_regs;
	int ppoll;

	hd->hpib_acr = AUX_SPP;
	DELAY(25);
	ppoll = hd->hpib_cpt;
	hd->hpib_acr = AUX_CPP;
	return(ppoll);
}

#ifdef DEBUG
int nhpibreporttimo = 0;
#endif

int
nhpibwait(hd, x)
	struct nhpibdevice *hd;
	int x;
{
	int timo = hpibtimeout;

	while ((hd->hpib_mis & x) == 0 && --timo)
		DELAY(1);
	if (timo == 0) {
#ifdef DEBUG
		if (nhpibreporttimo)
			printf("hpib0: %s timo\n", x==MIS_BO?"OUT":"IN");
#endif
		return(-1);
	}
	return(0);
}

void
nhpibppwatch(arg)
	void *arg;
{
	struct hpibbus_softc *hs = arg;
	struct nhpib_softc *sc = (struct nhpib_softc *)hs->sc_dev.dv_parent;

	if ((hs->sc_flags & HPIBF_PPOLL) == 0)
		return;

again:
	if (nhpibppoll(hs) & (0x80 >> TAILQ_FIRST(&hs->sc_queue)->hq_slave))
       		sc->sc_regs->hpib_mim = MIS_BO;
	else if (cold)
		/* timeouts not working yet */
		goto again;
	else {
		timeout_set(&sc->sc_watch_to, nhpibppwatch, hs);
		timeout_add(&sc->sc_watch_to, 1);
	}
}
@


1.18
log
@de-lint hp300

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.17 2009/07/26 13:43:38 blambert Exp $	*/
@


1.17
log
@timeout_add -> timeout_add_msec

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.16 2005/11/13 18:52:15 miod Exp $	*/
a461 3
#ifdef lint
	if (stat1 = unit) return(1);
#endif
@


1.16
log
@Fix timeout usage introduced during the timeout API change (better late
than never), allows slower disks on nhpib to work again.
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.15 2005/01/15 21:13:08 miod Exp $	*/
d436 1
a436 1
			timeout_add(&sc->sc_read_to, hz >> 2);
@


1.15
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.14 2004/12/25 23:02:24 miod Exp $	*/
d63 1
a63 1
static u_char listnr_par[] = {
d69 1
a69 1
static u_char talker_par[] = {
d75 1
a75 1
static u_char sec_par[] = {
d187 1
a187 2
	timeout_set(&sc->sc_read_to, nhpibreadtimo, &sc->sc_hpibbus);
	timeout_set(&sc->sc_watch_to, nhpibppwatch, &sc->sc_hpibbus);
d400 3
a402 3
	struct hpibbus_softc *hs = arg;
	struct nhpib_softc *sc = (struct nhpib_softc *)hs->sc_dev.dv_parent;
	int s = splbio();
d404 1
d547 1
d554 2
a555 1
	else
d557 1
@


1.14
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.13 2004/09/29 07:35:52 miod Exp $	*/
d86 1
a86 1
void	nhpibreset(struct hpibbus_softc *); 
d156 1
a156 1
	struct hpibdev_attach_args ha; 
@


1.13
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.12 2003/06/02 23:27:45 millert Exp $	*/
d414 1
a414 1
		hq = hs->sc_queue.tqh_first;
d470 1
a470 1
	hq = hs->sc_queue.tqh_first;
d548 1
a548 1
	if (nhpibppoll(hs) & (0x80 >> hs->sc_queue.tqh_first->hq_slave))
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.11 2002/03/14 01:26:30 millert Exp $	*/
d111 1
d180 5
a184 1
	(void) dio_intr_establish(nhpibintr, sc, ipl, IPL_BIO);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.10 2001/06/25 00:43:08 mickey Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.9 2001/05/01 16:51:10 millert Exp $	*/
d86 12
a97 12
void	nhpibifc __P((struct nhpibdevice *));
void	nhpibreadtimo __P((void *));
int	nhpibwait __P((struct nhpibdevice *, int));

void	nhpibreset __P((struct hpibbus_softc *)); 
int	nhpibsend __P((struct hpibbus_softc *, int, int, void *, int));
int	nhpibrecv __P((struct hpibbus_softc *, int, int, void *, int));
int	nhpibppoll __P((struct hpibbus_softc *));
void	nhpibppwatch __P((void *));
void	nhpibgo __P((struct hpibbus_softc *, int, int, void *, int, int, int));
void	nhpibdone __P((struct hpibbus_softc *));
int	nhpibintr __P((void *));
d121 2
a122 2
int	nhpibmatch __P((struct device *, void *, void *));
void	nhpibattach __P((struct device *, struct device *, void *));
@


1.10.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.10 2001/06/25 00:43:08 mickey Exp $	*/
d86 12
a97 12
void	nhpibifc(struct nhpibdevice *);
void	nhpibreadtimo(void *);
int	nhpibwait(struct nhpibdevice *, int);

void	nhpibreset(struct hpibbus_softc *); 
int	nhpibsend(struct hpibbus_softc *, int, int, void *, int);
int	nhpibrecv(struct hpibbus_softc *, int, int, void *, int);
int	nhpibppoll(struct hpibbus_softc *);
void	nhpibppwatch(void *);
void	nhpibgo(struct hpibbus_softc *, int, int, void *, int, int, int);
void	nhpibdone(struct hpibbus_softc *);
int	nhpibintr(void *);
d121 2
a122 2
int	nhpibmatch(struct device *, void *, void *);
void	nhpibattach(struct device *, struct device *, void *);
@


1.9
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.8 1997/07/06 08:01:54 downsj Exp $	*/
a542 1
	extern int cold;
@


1.8
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.7 1997/04/16 11:56:13 downsj Exp $	*/
d49 1
d117 2
d185 4
d435 1
a435 1
			timeout(nhpibreadtimo, hs, hz >> 2);
d477 1
a477 1
			untimeout(nhpibreadtimo, hs);
d554 1
a554 1
		timeout(nhpibppwatch, hs, 1);
@


1.8.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.8 1997/07/06 08:01:54 downsj Exp $	*/
a48 1
#include <sys/timeout.h>
a115 2
	struct timeout sc_read_to;	/* nhpibreadtimo timeout */
	struct timeout sc_watch_to;	/* nhpibppwatch timeout */
a181 4
	/* Initialize timeout structures */
	timeout_set(&sc->sc_read_to, nhpibreadtimo, &sc->sc_hpibbus);
	timeout_set(&sc->sc_watch_to, nhpibppwatch, &sc->sc_hpibbus);

d428 1
a428 1
			timeout_add(&sc->sc_read_to, hz >> 2);
d470 1
a470 1
			timeout_del(&sc->sc_read_to);
d536 1
d547 1
a547 1
		timeout_add(&sc->sc_watch_to, 1);
@


1.8.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 12
a97 12
void	nhpibifc(struct nhpibdevice *);
void	nhpibreadtimo(void *);
int	nhpibwait(struct nhpibdevice *, int);

void	nhpibreset(struct hpibbus_softc *); 
int	nhpibsend(struct hpibbus_softc *, int, int, void *, int);
int	nhpibrecv(struct hpibbus_softc *, int, int, void *, int);
int	nhpibppoll(struct hpibbus_softc *);
void	nhpibppwatch(void *);
void	nhpibgo(struct hpibbus_softc *, int, int, void *, int, int, int);
void	nhpibdone(struct hpibbus_softc *);
int	nhpibintr(void *);
d121 2
a122 2
int	nhpibmatch(struct device *, void *, void *);
void	nhpibattach(struct device *, struct device *, void *);
@


1.8.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nhpib.c,v 1.8.12.2 2002/03/28 10:07:18 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: nhpib.c,v 1.6 1997/02/03 04:47:40 downsj Exp $	*/
/*	$NetBSD: nhpib.c,v 1.16 1997/04/14 02:33:21 thorpej Exp $	*/
d180 1
a180 2
	(void) intr_establish(nhpibintr, sc, ipl, IPL_BIO);
	dmacomputeipl();
@


1.6
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: nhpib.c,v 1.5 1997/01/12 15:12:56 downsj Exp $	*/
/*	$NetBSD: nhpib.c,v 1.14 1997/01/30 09:06:54 thorpej Exp $	*/
d51 1
a51 2

#include <hp300/hp300/isr.h>
d180 1
a180 1
	(void) isrlink(nhpibintr, sc, ipl, ISRPRI_BIO);
d219 1
a219 1
	register struct nhpibdevice *hd;
d399 2
a400 2
		register struct nhpibdevice *hd = sc->sc_regs;
		register struct hpibqueue *hq;
d514 1
a514 1
	register struct nhpibdevice *hd;
d517 1
a517 1
	register int timo = hpibtimeout;
@


1.5
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nhpib.c,v 1.13 1996/10/13 03:14:19 christos Exp $	*/
d5 1
a42 2
#include "hpib.h"
#if NHPIB > 0
d48 11
a59 1
#include <hp300/dev/device.h>
a61 1
#include <hp300/dev/dmavar.h>
d86 8
a93 4
void	nhpibreset __P((int)); 
int	nhpibsend __P((int, int, int, void *, int));
int	nhpibrecv __P((int, int, int, void *, int));
int	nhpibppoll __P((int));
d95 2
a96 2
void	nhpibgo __P((int, int, int, void *, int, int, int));
void	nhpibdone __P((int));
d113 17
d131 3
a133 2
nhpibtype(hc)
	register struct hp_ctlr *hc;
d135 1
a135 2
	register struct hpib_softc *hs = &hpib_softc[hc->hp_unit];
	register struct nhpibdevice *hd = (struct nhpibdevice *)hc->hp_addr;
d137 5
a141 3
	if (hc->hp_addr == internalhpib) {
		hs->sc_type = HPIBA;
		hc->hp_ipl = HPIBA_IPL;
d143 2
a144 3
	} else if (hd->hpib_cid == HPIBB) {
		hs->sc_type = HPIBB;
		hc->hp_ipl = HPIB_IPL(hd->hpib_ids);
a145 1
	}
d147 1
a147 1
	return(0);
d151 16
a166 5
nhpibattach(hc)
	register struct hp_ctlr *hc;
{
	struct hpib_softc *hs = &hpib_softc[hc->hp_unit];
	register struct nhpibdevice *hd = (struct nhpibdevice *)hc->hp_addr;
d168 1
a168 5
	switch (hs->sc_type) {
	case HPIBA:
		hs->sc_ba = HPIBA_BA;
		hs->sc_descrip = "Internal HP-IB";
		break;
d170 20
a189 11
	case HPIBB:
		hs->sc_ba = hd->hpib_csa & CSA_BA;
		hs->sc_descrip = "98624 HP-IB";
		break;

	default:
		panic("nhpibattach: unknown type 0x%x", hs->sc_type);
		/* NOTREACHED */
	}

	hs->sc_controller = &nhpib_controller;
d193 2
a194 2
nhpibreset(unit)
	int unit;
d196 2
a197 2
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct nhpibdevice *hd;
a198 1
	hd = (struct nhpibdevice *)hs->sc_hc->hp_addr;
d218 1
d231 3
a233 2
nhpibsend(unit, slave, sec, ptr, origcnt)
	int unit, slave, sec, origcnt;
d236 3
a238 3
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct nhpibdevice *hd;
	register int cnt = origcnt;
a240 1
	hd = (struct nhpibdevice *)hs->sc_hc->hp_addr;
d289 3
a291 2
nhpibrecv(unit, slave, sec, ptr, origcnt)
	int unit, slave, sec, origcnt;
d294 3
a296 3
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct nhpibdevice *hd;
	register int cnt = origcnt;
a298 1
	hd = (struct nhpibdevice *)hs->sc_hc->hp_addr;
d342 3
a344 2
nhpibgo(unit, slave, sec, ptr, count, rw, timo)
	int unit, slave, sec, count, rw, timo;
d347 2
a348 2
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct nhpibdevice *hd;
a350 1
	hd = (struct nhpibdevice *)hs->sc_hc->hp_addr;
d366 2
a367 2
		dmago(hs->sc_dq.dq_ctlr, addr, count, DMAGO_BYTE|DMAGO_READ);
		nhpibrecv(unit, slave, sec, 0, 0);
d373 2
a374 2
			nhpibsend(unit, slave, sec, addr, count);
			nhpibdone(unit);
d378 2
a379 2
		dmago(hs->sc_dq.dq_ctlr, addr, count, DMAGO_BYTE);
		nhpibsend(unit, slave, sec, 0, 0);
d381 1
a381 1
	hd->hpib_ie = IDS_IE | IDS_DMA(hs->sc_dq.dq_ctlr);
d395 2
a396 2
	int unit;
	register struct hpib_softc *hs;
a398 2
	unit = (int)arg;
	hs = &hpib_softc[unit];
d400 2
a401 2
		register struct nhpibdevice *hd;
		register struct devqueue *dq;
a402 1
		hd = (struct nhpibdevice *)hs->sc_hc->hp_addr;
d406 4
a409 3
		dmafree(&hs->sc_dq);
		dq = hs->sc_sq.dq_forw;
		(dq->dq_driver->d_intr)(dq->dq_softc);
d411 1
a411 1
	(void) splx(s);
d415 2
a416 2
nhpibdone(unit)
	register int unit;
d418 3
a420 3
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct nhpibdevice *hd;
	register int cnt;
a421 1
	hd = (struct nhpibdevice *)hs->sc_hc->hp_addr;
d430 1
a430 1
			timeout(nhpibreadtimo, (void *)unit, hz >> 2);
d449 6
a454 5
	register struct hpib_softc *hs = arg;
	register struct nhpibdevice *hd;
	register struct devqueue *dq;
	register int stat0;
	int stat1, unit = hs->sc_hc->hp_unit;
a458 1
	hd = (struct nhpibdevice *)hs->sc_hc->hp_addr;
d463 3
a465 1
	dq = hs->sc_sq.dq_forw;
d470 1
a470 1
			dmastop(hs->sc_dq.dq_ctlr);
d472 1
a472 1
			untimeout(nhpibreadtimo, (void *)unit);
d475 3
a477 2
		dmafree(&hs->sc_dq);
		(dq->dq_driver->d_intr)(dq->dq_softc);
d480 2
a481 2
		stat0 = nhpibppoll(unit);
		if (stat0 & (0x80 >> dq->dq_slave)) {
d483 1
a483 1
			(dq->dq_driver->d_intr)(dq->dq_softc);
d488 1
a488 1
			       hs->sc_hc->hp_xname, stat0);
d495 2
a496 2
nhpibppoll(unit)
	int unit;
d498 3
a500 2
	register struct nhpibdevice *hd;
	register int ppoll;
a501 1
	hd = (struct nhpibdevice *)hpib_softc[unit].sc_hc->hp_addr;
d536 2
a537 2
	register struct hpib_softc *hs;
	register int unit;
a539 2
	unit = (int)arg;
	hs = &hpib_softc[unit];
d543 2
a544 2
	if (nhpibppoll(unit) & (0x80 >> hs->sc_sq.dq_forw->dq_slave))
       		((struct nhpibdevice *)hs->sc_hc->hp_addr)->hpib_mim = MIS_BO;
d549 1
a549 1
		timeout(nhpibppwatch, (void *)unit, 1);
a550 1
#endif /* NHPIB > 0 */
@


1.4
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: nhpib.c,v 1.11 1996/05/18 23:57:01 thorpej Exp $	*/
@


1.3
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: nhpib.c,v 1.9 1996/02/14 02:44:45 thorpej Exp $	*/
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: nhpib.c,v 1.8 1995/12/02 18:22:06 thorpej Exp $	*/
d84 1
a84 1
int	nhpibintr __P((int));
d365 1
a365 1
		(dq->dq_driver->d_intr)(dq->dq_unit);
d403 2
a404 2
nhpibintr(unit)
	register int unit;
d406 1
a406 1
	register struct hpib_softc *hs = &hpib_softc[unit];
d410 1
a410 1
	int stat1;
d431 1
a431 1
		(dq->dq_driver->d_intr)(dq->dq_unit);
d437 1
a437 1
			(dq->dq_driver->d_intr)(dq->dq_unit);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nhpib.c,v 1.6 1995/01/07 10:30:14 mycroft Exp $	*/
d77 24
a108 1
		hs->sc_ba = HPIBA_BA;
d110 5
d116 18
a133 2
	else if (hd->hpib_cid == HPIBB) {
		hs->sc_type = HPIBB;
d135 6
a140 1
		hc->hp_ipl = HPIB_IPL(hd->hpib_ids);
d142 2
a143 3
	else
		return(0);
	return(1);
d146 1
d184 2
a185 1
nhpibsend(unit, slave, sec, addr, origcnt)
d187 1
a187 1
	register char *addr;
d192 1
d242 2
a243 1
nhpibrecv(unit, slave, sec, addr, origcnt)
d245 1
a245 1
	register char *addr;
d250 1
d295 4
a298 4
nhpibgo(unit, slave, sec, addr, count, rw, timo)
	register int unit, slave;
	int sec, count, rw;
	char *addr;
d302 1
d370 1
d402 1
d441 2
a442 2
			printf("hpib%d: PPOLL intr bad status %x\n",
			       unit, stat0);
d448 1
d467 1
d507 1
a507 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
