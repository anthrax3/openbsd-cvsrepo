head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.21
date	2014.03.18.22.36.31;	author miod;	state dead;
branches;
next	1.20;

1.20
date	2013.10.21.10.36.11;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2013.09.28.21.10.58;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.29.19.08.19;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.11.18.33.13;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.09.21.23.51;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.05.09.57.24;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.30.15.15.20;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.12.22.52.59;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.12.22.22.39;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.14.18.46.17;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.08.01.51.45;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.24.21.36.39;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.18.21.53.23;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.18.19.17.03;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.18.10.48.19;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.16.16.14.09;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.22.39.25;	author miod;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: diofb.c,v 1.20 2013/10/21 10:36:11 miod Exp $	*/

/*
 * Copyright (c) 2005, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <hp300/dev/diofbreg.h>
#include <hp300/dev/diofbvar.h>

extern int rasops_alloc_cattr(void *, int, int, int, long *);

int	diofb_alloc_attr(void *, int, int, int, long *);
int	diofb_copycols(void *, int, int, int, int);
int	diofb_erasecols(void *, int, int, int, long);
int	diofb_copyrows(void *, int, int, int);
int	diofb_eraserows(void *, int, int, long);
int	diofb_do_cursor(struct rasops_info *);

/*
 * Frame buffer geometry initialization
 */

int
diofb_fbinquire(struct diofb *fb, int scode, struct diofbreg *fbr)
{
	int fboff, regsize;

	if (ISIIOVA(fbr))
		fb->regaddr = (caddr_t)IIOP(fbr);
	else
		fb->regaddr = dio_scodetopa(scode);

	if (fb->fbwidth == 0 || fb->fbheight == 0) {
		fb->fbwidth = (fbr->fbwmsb << 8) | fbr->fbwlsb;
		fb->fbheight = (fbr->fbhmsb << 8) | fbr->fbhlsb;
	}
	fb->fbsize = fb->fbwidth * fb->fbheight;

	fb->regkva = (caddr_t)fbr;
	fboff = (fbr->fbomsb << 8) | fbr->fbolsb;
	fb->fbaddr = (caddr_t) (*((u_char *)fbr + fboff) << 16);

	if (fb->regaddr >= (caddr_t)DIOII_BASE) {
		/*
		 * For DIO-II space the fbaddr just computed is
		 * the offset from the select code base (regaddr)
		 * of the framebuffer.  Hence it is also implicitly
		 * the size of the set.
		 */
		regsize = (int)fb->fbaddr;
		fb->fbaddr += (int)fb->regaddr;
		fb->fbkva = (caddr_t)fbr + regsize;
	} else {
		/*
		 * For internal or DIO-I space we need to map the separate
		 * framebuffer.
		 */
		fb->fbkva = iomap(fb->fbaddr, fb->fbsize);
		if (fb->fbkva == NULL)
			return (ENOMEM);
	}
	if (fb->dwidth == 0 || fb->dheight == 0) {
		fb->dwidth = (fbr->dwmsb << 8) | fbr->dwlsb;
		fb->dheight = (fbr->dhmsb << 8) | fbr->dhlsb;
	}

	/*
	 * Some displays, such as the DaVinci, appear to return a display
	 * height larger than the frame buffer height.
	 */
	if (fb->dwidth > fb->fbwidth)
		fb->dwidth = fb->fbwidth;
	if (fb->dheight > fb->fbheight)
		fb->dheight = fb->fbheight;

	/*
	 * Some monochrome displays, such as the HP332 internal video
	 * appear to return a display width of 1024 instead of 512.
	 */
	if (fbr->num_planes == 1 && fb->dheight == 400)
		if (fb->dwidth == 1024)
			fb->dwidth = 512;

	fb->planes = fbr->num_planes;
	if (fb->planes > 8)
		fb->planes = 8;
	fb->planemask = (1 << fb->planes) - 1;

	fb->mapmode = WSDISPLAYIO_MODE_DUMBFB;

	return (0);
}

/*
 * Frame buffer rasops and colormap setup
 */

void
diofb_fbsetup(struct diofb *fb)
{
	struct rasops_info *ri = &fb->ri;

	/*
	 * Pretend we are an 8bpp frame buffer, unless ri_depth is already
	 * initialized, since this is how it is supposed to be addressed.
	 * (Hyperion forces 1bpp because it is really 1bpp addressed).
	 */
	if (ri->ri_depth == 0)
		ri->ri_depth = 8;
	ri->ri_stride = (fb->fbwidth * ri->ri_depth) / 8;

	ri->ri_flg = RI_CENTER | RI_FULLCLEAR;
	/* We don't really support colors on less than 4bpp frame buffers */
	if (fb->planes < 4)
		ri->ri_flg |= RI_FORCEMONO;
	ri->ri_bits = fb->fbkva;
	ri->ri_width = fb->dwidth;
	ri->ri_height = fb->dheight;
	ri->ri_hw = fb;

	/*
	 * Ask for an unholy big display, rasops will trim this to more
	 * reasonable values.
	 */
	rasops_init(ri, 160, 160);

	diofb_resetcmap(fb);

	/*
	 * For low depth frame buffers, since we have faked a 8bpp frame buffer
	 * to rasops, we actually have to remove capabilities.
	 */
	if (fb->planes == 4) {
		ri->ri_ops.alloc_attr = diofb_alloc_attr;
		ri->ri_caps &= ~WSSCREEN_HILIT;
	}
		
	ri->ri_ops.copycols = diofb_copycols;
	ri->ri_ops.erasecols = diofb_erasecols;
	if (ri->ri_depth != 1) {
		ri->ri_ops.copyrows = diofb_copyrows;
		ri->ri_ops.eraserows = diofb_eraserows;
		ri->ri_do_cursor = diofb_do_cursor;
	}

	/* Clear entire display, including non visible areas */
	(*fb->bmv)(fb, 0, 0, 0, 0, fb->fbwidth, fb->fbheight, RR_CLEAR, 0xff);

	strlcpy(fb->wsd.name, "std", sizeof(fb->wsd.name));
	fb->wsd.ncols = ri->ri_cols;
	fb->wsd.nrows = ri->ri_rows;
	fb->wsd.textops = &ri->ri_ops;
	fb->wsd.fontwidth = ri->ri_font->fontwidth;
	fb->wsd.fontheight = ri->ri_font->fontheight;
	fb->wsd.capabilities = ri->ri_caps;
}

/*
 * Setup default emulation mode colormap
 */
void
diofb_resetcmap(struct diofb *fb)
{
	const u_char *color;
	u_int i;

	/* start with the rasops colormap */
	color = (const u_char *)rasops_cmap;
	for (i = 0; i < 256; i++) {
		fb->cmap.r[i] = *color++;
		fb->cmap.g[i] = *color++;
		fb->cmap.b[i] = *color++;
	}

	/*
	 * Tweak colormap
	 *
	 * Due to the way rasops cursor work, we need to provide
	 * copies of the 8 or 16 basic colors at extra locations
	 * in 4bpp and 6bpp mode. This is because missing planes
	 * accept writes but read back as zero.
	 *
	 * So, in 6bpp mode:
	 *   00 gets inverted to ff, read back as 3f
	 *   3f gets inverted to c0, read back as 00
	 * and in 4bpp mode:
	 *   00 gets inverted to ff, read back as 0f
	 *   0f gets inverted to f0, read back as 00
	 */

	switch (fb->planes) {
	case 6:
		/*
		 * 00-0f normal colors
		 * 30-3f inverted colors
		 * c0-cf normal colors
		 * f0-ff inverted colors
		 */
		bcopy(fb->cmap.r + 0x00, fb->cmap.r + 0xc0, 0x10);
		bcopy(fb->cmap.g + 0x00, fb->cmap.g + 0xc0, 0x10);
		bcopy(fb->cmap.b + 0x00, fb->cmap.b + 0xc0, 0x10);
		bcopy(fb->cmap.r + 0xf0, fb->cmap.r + 0x30, 0x10);
		bcopy(fb->cmap.g + 0xf0, fb->cmap.g + 0x30, 0x10);
		bcopy(fb->cmap.b + 0xf0, fb->cmap.b + 0x30, 0x10);
		break;
	case 4:
		/*
		 * 00-07 normal colors
		 * 08-0f inverted colors
		 * highlighted colors are not available.
		 */
		bcopy(fb->cmap.r + 0xf8, fb->cmap.r + 0x08, 0x08);
		bcopy(fb->cmap.g + 0xf8, fb->cmap.g + 0x08, 0x08);
		bcopy(fb->cmap.b + 0xf8, fb->cmap.b + 0x08, 0x08);
		break;
	}
}

/*
 * Attachment helpers
 */

void
diofb_cnattach(struct diofb *fb)
{
	long defattr;
	struct rasops_info *ri;

	ri = &fb->ri;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&fb->wsd, ri, 0, 0, defattr);
}

void
diofb_end_attach(void *sc, struct wsdisplay_accessops *accessops,
    struct diofb *fb, int console, const char *descr)
{
	struct wsemuldisplaydev_attach_args waa;

	printf(": %dx%d", fb->dwidth, fb->dheight);

	if (fb->planes == 1)
		printf(" monochrome");
	else
		printf("x%d", fb->planes);

	if (descr != NULL)
		printf(" %s", descr);
	printf(" frame buffer\n");

	fb->scrlist[0] = &fb->wsd;
	fb->wsl.nscreens = 1;
	fb->wsl.screens = (const struct wsscreen_descr **)fb->scrlist;

	waa.console = console;
	waa.scrdata = &fb->wsl;
	waa.accessops = accessops;
	waa.accesscookie = fb;
	waa.defaultscreens = 0;

	config_found((struct device *)sc, &waa, wsemuldisplaydevprint);
}

/*
 * Common wsdisplay emulops for DIO frame buffers
 */

int
diofb_alloc_attr(void *cookie, int fg, int bg, int flg, long *attr)
{
	if ((flg & (WSATTR_BLINK | WSATTR_HILIT)) != 0)
		return (EINVAL);

	return (rasops_alloc_cattr(cookie, fg, bg, flg, attr));
}

int
diofb_copycols(void *cookie, int row, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct diofb *fb = ri->ri_hw;

	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	(*fb->bmv)(fb, ri->ri_xorigin + src, ri->ri_yorigin + row,
	    ri->ri_xorigin + dst, ri->ri_yorigin + row,
	    n, ri->ri_font->fontheight, RR_COPY, 0xff);

	return 0;
}

int
diofb_copyrows(void *cookie, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct diofb *fb = ri->ri_hw;

	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	(*fb->bmv)(fb, ri->ri_xorigin, ri->ri_yorigin + src,
	    ri->ri_xorigin, ri->ri_yorigin + dst,
	    ri->ri_emuwidth, n, RR_COPY, 0xff);

	return 0;
}

int
diofb_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct diofb *fb = ri->ri_hw;
	int fg, bg;
	int snum, scol, srow;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	snum = num * ri->ri_font->fontwidth;
	scol = col * ri->ri_font->fontwidth + ri->ri_xorigin;
	srow = row * ri->ri_font->fontheight + ri->ri_yorigin;

	/*
	 * If this is too tricky for the simple raster ops engine,
	 * pass the fun to rasops.
	 */
	if ((*fb->bmv)(fb, scol, srow, scol, srow, snum,
	    ri->ri_font->fontheight, RR_CLEAR, 0xff ^ bg) != 0)
		rasops_erasecols(cookie, row, col, num, attr);

	return 0;
}

int
diofb_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct diofb *fb = ri->ri_hw;
	int fg, bg;
	int srow, snum;
	int rc;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	bg ^= 0xff;

	if (num == ri->ri_rows && (ri->ri_flg & RI_FULLCLEAR)) {
		rc = (*fb->bmv)(fb, 0, 0, 0, 0, ri->ri_width, ri->ri_height,
		    RR_CLEAR, bg);
	} else {
		srow = row * ri->ri_font->fontheight + ri->ri_yorigin;
		snum = num * ri->ri_font->fontheight;
		rc = (*fb->bmv)(fb, ri->ri_xorigin, srow, ri->ri_xorigin,
		    srow, ri->ri_emuwidth, snum, RR_CLEAR, bg);
	}
	if (rc != 0)
		rasops_eraserows(cookie, row, num, attr);

	return 0;
}

int
diofb_do_cursor(struct rasops_info *ri)
{
	struct diofb *fb = ri->ri_hw;
	int x, y;

	x = ri->ri_ccol * ri->ri_font->fontwidth + ri->ri_xorigin;
	y = ri->ri_crow * ri->ri_font->fontheight + ri->ri_yorigin;
	(*fb->bmv)(fb, x, y, x, y, ri->ri_font->fontwidth,
	    ri->ri_font->fontheight, RR_INVERT, 0xff);

	return 0;
}

/*
 * Common wsdisplay accessops for DIO frame buffers
 */

int
diofb_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct diofb *fb = v;
	struct rasops_info *ri = &fb->ri;

	if (fb->nscreens > 0)
		return (ENOMEM);

	*cookiep = ri;
	*curxp = *curyp = 0;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);
	fb->nscreens++;

	return (0);
}

void
diofb_free_screen(void *v, void *cookie)
{
	struct diofb *fb = v;

	fb->nscreens--;
}

int
diofb_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

paddr_t
diofb_mmap(void *v, off_t offset, int prot)
{
	struct diofb *fb = v;

	if ((offset & PAGE_MASK) != 0)
		return (-1);

	switch (fb->mapmode) {
	case WSDISPLAYIO_MODE_MAPPED:
		if (offset >= 0 && offset < DIOFB_REGSPACE)
			return ((paddr_t)fb->regaddr + offset);
		offset -= DIOFB_REGSPACE;
		/* FALLTHROUGH */
	case WSDISPLAYIO_MODE_DUMBFB:
		if (offset >= 0 && offset < fb->fbsize)
			return ((paddr_t)fb->fbaddr + offset);
		break;
	}

	return (-1);
}

int
diofb_getcmap(struct diofb *fb, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index, count = cm->count;
	u_int colcount = 1 << fb->planes;
	int error;

	if (index >= colcount || count > colcount - index)
		return (EINVAL);

	if ((error = copyout(fb->cmap.r + index, cm->red, count)) != 0)
		return (error);
	if ((error = copyout(fb->cmap.g + index, cm->green, count)) != 0)
		return (error);
	if ((error = copyout(fb->cmap.b + index, cm->blue, count)) != 0)
		return (error);

	return (0);
}

int
diofb_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct diofb *fb = v;
	struct rasops_info *ri = &fb->ri;

	return rasops_load_font(ri, emulcookie, font);
}

int
diofb_list_font(void *v, struct wsdisplay_font *font)
{
	struct diofb *fb = v;
	struct rasops_info *ri = &fb->ri;

	return rasops_list_font(ri, font);
}
@


1.20
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.19 2013/09/28 21:10:58 miod Exp $	*/
@


1.19
log
@Model 332 has a monochrome 98542 on-board, instead of the expected 98544;
that particular model lacks the colormap chips (likely due to physical space
constraints) and lies about its visible geometry, in pure old HP frame buffer
style (before HP engineers realized the usefulness of providing correct data
to the operating system).

Work done by Andrew Gillham (last name on gmail), with unsignificant tweaks
by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.18 2010/12/26 15:40:59 miod Exp $	*/
d488 1
a488 1
diofb_mmap(void * v, off_t offset, int prot)
d528 18
@


1.18
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.17 2009/09/05 14:09:35 miod Exp $	*/
d147 8
@


1.17
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.16 2006/11/29 19:08:19 miod Exp $	*/
d490 1
a490 1
			return (((paddr_t)fb->regaddr + offset) >> PGSHIFT);
d495 1
a495 1
			return (((paddr_t)fb->fbaddr + offset) >> PGSHIFT);
@


1.16
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.15 2006/11/29 12:13:54 miod Exp $	*/
d85 5
a89 5
void	diofb_copycols(void *, int, int, int, int);
void	diofb_erasecols(void *, int, int, int, long);
void	diofb_copyrows(void *, int, int, int);
void	diofb_eraserows(void *, int, int, long);
void	diofb_do_cursor(struct rasops_info *);
d341 1
a341 1
void
d355 2
d359 1
a359 1
void
d372 2
d376 1
a376 1
void
d397 2
d401 1
a401 1
void
d424 2
d428 1
a428 1
void
d438 2
@


1.15
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.14 2006/08/11 18:33:13 miod Exp $	*/
d380 1
a380 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
d404 1
a404 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
@


1.14
log
@Let the windowmove() callbacks return whether they could perform the operation
or not, so that we can always feed them the complex operations before falling
back to rasops; and then topcat can perform coloured solid fills in
erase{cols,rows}.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.13 2006/08/09 21:23:51 miod Exp $	*/
d323 1
@


1.13
log
@Use the blitter again for the cursor on non-mono frame buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.12 2006/08/05 09:57:24 miod Exp $	*/
d211 1
a211 1
	(*fb->bmv)(fb, 0, 0, 0, 0, fb->fbwidth, fb->fbheight, RR_CLEAR);
d353 1
a353 1
	    n, ri->ri_font->fontheight, RR_COPY);
d368 1
a368 1
	    ri->ri_emuwidth, n, RR_COPY);
d377 1
d381 4
d386 2
a387 2
	 * If the background color is not black, this is a bit too tricky
	 * for the simple raster ops engine, so pass the fun to rasops.
d389 2
a390 1
	if (ri->ri_devcmap[bg] != 0) {
a391 10
		return;
	}

	num *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	(*fb->bmv)(fb, ri->ri_xorigin + col, ri->ri_yorigin + row,
	    ri->ri_xorigin + col, ri->ri_yorigin + row,
	    num, ri->ri_font->fontheight, RR_CLEAR);
d400 2
d404 1
a405 10
	/*
	 * If the background color is not black, this is a bit too tricky
	 * for the simple raster ops engine, so pass the fun to rasops.
	 */
	if (ri->ri_devcmap[bg] != 0) {
		rasops_eraserows(cookie, row, num, attr);
		return;
	}

	/* As an exception, hunt the mouse all over the screen if necessary */
d407 2
a408 2
		(*fb->bmv)(fb, 0, 0, 0, 0,
		    ri->ri_width, ri->ri_height, RR_CLEAR);
d410 4
a413 5
		row *= ri->ri_font->fontheight;
		num *= ri->ri_font->fontheight;
		(*fb->bmv)(fb, ri->ri_xorigin, ri->ri_yorigin + row,
		    ri->ri_xorigin, ri->ri_yorigin + row,
		    ri->ri_emuwidth, num, RR_CLEAR);
d415 2
d428 1
a428 1
	    ri->ri_font->fontheight, RR_INVERT);
@


1.12
log
@Prefer rasops {copy,erase}rows routines for non-accelerated 1bpp frame buffers,
as they are slightly faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.11 2006/06/30 15:15:20 miod Exp $	*/
d89 1
d207 1
d376 1
a376 1
	int fg, bg, uline;
d378 1
a378 1
	rasops_unpack_attr(attr, &fg, &bg, &uline);
d403 1
a403 1
	int fg, bg, uline;
d405 1
a405 1
	rasops_unpack_attr(attr, &fg, &bg, &uline);
d427 12
@


1.11
log
@When allocating the default rasops attribute, it is not necessary to use
non-zero parameters on a color display as long as we want white on black;
this was inherited from sparc but this is not necessary on these platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.10 2006/03/12 22:52:59 miod Exp $	*/
a201 1
	ri->ri_ops.copyrows = diofb_copyrows;
d203 4
a206 1
	ri->ri_ops.eraserows = diofb_eraserows;
@


1.10
log
@Previous fix was half-done, move the wsscreen_list array into the softc
as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.8 2006/02/14 18:46:17 miod Exp $	*/
d290 1
a290 5
	if (ri->ri_caps & WSSCREEN_WSCOLORS)
		ri->ri_ops.alloc_attr(ri, WSCOL_WHITE, WSCOL_BLACK,
		    WSATTR_WSCOLORS, &defattr);
	else
		ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
d441 1
a441 5
	if (ri->ri_caps & WSSCREEN_WSCOLORS)
		ri->ri_ops.alloc_attr(ri, WSCOL_WHITE, WSCOL_BLACK,
		    WSATTR_WSCOLORS, attrp);
	else
		ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);
@


1.9
log
@Move struct wsscreen_list out of the stack as on sparc.
@
text
@a302 1
	struct wsscreen_descr *scrlist[1];
d315 1
a315 1
	scrlist[0] = &fb->wsd;
d317 1
a317 1
	fb->wsl.screens = (const struct wsscreen_descr **)scrlist;
@


1.8
log
@Fix <=4bpp buglet introduced in previous commit; non-hyperion frame buffers
are addressed as if they were 8bpp, which is what we pretend we are to rasops,
so we actually have to remove capabilities after rasops_init() again.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.7 2005/05/08 01:51:45 miod Exp $	*/
a303 1
	struct wsscreen_list screenlist;
d317 2
a318 2
	screenlist.nscreens = 1;
	screenlist.screens = (const struct wsscreen_descr **)scrlist;
d321 1
a321 1
	waa.scrdata = &screenlist;
@


1.7
log
@For 4bpp and 6bpp frame buffers, advertize highligting and colors capabilities
back after rasops has initialized, as it will treat anything < 8bpp as mono.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.6 2005/01/24 21:36:39 miod Exp $	*/
d176 3
d193 2
a194 3
	 * Rasops is too conservative here, and will constrain
	 * less-than-8bpp frame buffers to mono mode.
	 * We know better and override here.
d196 1
a196 1
	if (fb->planes >= 4) {
d198 1
a198 5
		ri->ri_caps |= WSSCREEN_WSCOLORS;
	}
	if (fb->planes > 4) {
		ri->ri_ops.alloc_attr = rasops_alloc_cattr;
		ri->ri_caps |= WSSCREEN_HILIT;
@


1.6
log
@Switch hp300 wscons code to rasops, for DIO frame buffers.
Features:
- coloured kernel messages
- color support in console (use TERM=wsvt25)
- pretty Gallant wsfont, rather than the acceptable or ugly (depending upon
  the frame buffer) ROM font
- colormap ioctl support for Gatorbox and Topcat; DaVinci and Renaissance
  not done due to lack of hardware and/or documentation
- even more code factorization

tested on hyperion, and 4/6/8bpp catseye/topcat/kathmandu hardware, by
millert@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.5 2005/01/18 21:53:23 miod Exp $	*/
d82 3
d189 13
a201 4
	if (fb->planes <= 4)
		ri->ri_caps &= ~WSSCREEN_HILIT;
	if (fb->planes < 4)
		ri->ri_caps &= ~WSSCREEN_WSCOLORS;
d334 9
@


1.5
log
@Better colormap recovery after X11 exits.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.4 2005/01/18 19:17:03 miod Exp $	*/
d75 1
d77 1
a81 13
/*
 * X and Y location of character 'c' in the framebuffer, in pixels.
 */
#define	charX(fb,c)	\
	(((c) % (fb)->cpl) * (fb)->ftscale + (fb)->fontx)
#define	charY(fb,c)	\
	(((c) / (fb)->cpl) * (fb)->ftheight + (fb)->fonty)

void diofb_fontcopy(struct diofb *, char *, char *);

int	diofb_mapchar(void *, int, unsigned int *);
void	diofb_cursor(void *, int, int, int);
void	diofb_putchar(void *, int, int, u_int, long);
a86 11
const struct wsdisplay_emulops	diofb_emulops = {
	diofb_cursor,
	diofb_mapchar,
	diofb_putchar,
	diofb_copycols,
	diofb_erasecols,
	diofb_copyrows,
	diofb_eraserows,
	diofb_alloc_attr
};

d107 1
d113 1
a113 1
		 * For DIO II space the fbaddr just computed is
a119 1
		fb->regkva = (caddr_t)fbr;
d123 1
a123 1
		 * For DIO space we need to map the separate
a125 1
		fb->regkva = (caddr_t)fbr;
d144 7
d155 1
a155 1
 * PROM font setup
d161 1
a161 1
	u_long fontaddr = getword(fb, getword(fb, FONTROM) + FONTADDR);
d164 3
a166 1
	 * Get font metrics.
d168 9
a176 5
	fb->ftheight = getbyte(fb, fontaddr + FONTHEIGHT);
	fb->ftwidth = getbyte(fb, fontaddr + FONTWIDTH);
	fb->ftscale = fb->ftwidth;
	fb->rows = fb->dheight / fb->ftheight;
	fb->cols = fb->dwidth / fb->ftwidth;
d179 2
a180 1
	 * Decide where to put the font in off-screen memory.
d182 1
a182 14
	if (fb->fbwidth > fb->dwidth) {
		/* Unpacked font will be to the right of the display */
		fb->fontx = fb->dwidth;
		fb->fonty = 0;
		fb->cpl = (fb->fbwidth - fb->dwidth) / fb->ftwidth;
		fb->cblankx = fb->dwidth;
	} else {
		/* Unpacked font will be below the display */
		fb->fontx = 0;
		fb->fonty = fb->dheight;
		fb->cpl = fb->fbwidth / fb->ftwidth;
		fb->cblankx = 0;
	}
	fb->cblanky = fb->fonty + ((FONTMAXCHAR / fb->cpl) + 1) * fb->ftheight;
d184 1
a184 5
	/*
	 * Clear display
	 */
	(*fb->bmv)(fb, 0, 0, 0, 0, fb->fbwidth, fb->fbheight, RR_CLEAR);
	fb->curvisible = 0;
d186 9
a194 6
	/*
	 * Setup inverted cursor.
	 */
	(*fb->bmv)(fb, charX(fb, ' '), charY(fb, ' '),
	    fb->cblankx, fb->cblanky, fb->ftwidth, fb->ftheight,
	    RR_COPYINVERTED);
d196 2
a197 10
	/*
	 * Default colormap
	 */
	bzero(&fb->cmap, sizeof(fb->cmap));
	fb->cmap.r[1] = 0xff;
	fb->cmap.g[1] = 0xff;
	fb->cmap.b[1] = 0xff;
	fb->cmap.r[(1 << fb->planes) - 1] = 0xff;
	fb->cmap.g[(1 << fb->planes) - 1] = 0xff;
	fb->cmap.b[(1 << fb->planes) - 1] = 0xff;
d200 6
a205 6
	fb->wsd.ncols = fb->cols;
	fb->wsd.nrows = fb->rows;
	fb->wsd.textops = &diofb_emulops;
	fb->wsd.fontwidth = fb->ftwidth;
	fb->wsd.fontheight = fb->ftheight;
	fb->wsd.capabilities = WSSCREEN_REVERSE;
d208 3
d212 1
a212 1
diofb_fontunpack(struct diofb *fb)
d214 10
a223 4
	char fontbuf[500];		/* XXX malloc not initialized yet */
	char *dp, *fbmem;
	int bytewidth, glyphsize;
	int c, i, romp;
d226 13
a238 1
	 * Unpack PROM font to the off-screen location.
d240 26
a265 13
	bytewidth = (((fb->ftwidth - 1) / 8) + 1);
	glyphsize = bytewidth * fb->ftheight;
	romp = getword(fb, getword(fb, FONTROM) + FONTADDR) + FONTDATA;
	for (c = 0; c < FONTMAXCHAR; c++) {
		fbmem = (char *)(FBBASE(fb) +
		     (fb->fonty + (c / fb->cpl) * fb->ftheight) * fb->fbwidth +
		     (fb->fontx + (c % fb->cpl) * fb->ftwidth));
		dp = fontbuf;
		for (i = 0; i < glyphsize; i++) {
			*dp++ = getbyte(fb, romp);
			romp += 2;
		}
		diofb_fontcopy(fb, fbmem, fontbuf);
d269 4
d274 1
a274 1
diofb_fontcopy(struct diofb *fb, char *fbmem, char *glyphp)
d276 2
a277 2
	int bn;
	int l, b;
d279 7
a285 17
	for (l = 0; l < fb->ftheight; l++) {
		bn = 7;
		for (b = 0; b < fb->ftwidth; b++) {
			if ((1 << bn) & *glyphp)
				*fbmem++ = 1;
			else
				*fbmem++ = 0;
			if (--bn < 0) {
				bn = 7;
				glyphp++;
			}
		}
		if (bn < 7)
			glyphp++;
		fbmem -= fb->ftwidth;
		fbmem += fb->fbwidth;
	}
a287 3
/*
 * Attachment helper
 */
d290 1
a290 1
    struct diofb *fb, int console, int planes, const char *descr)
d298 1
a298 3
	if (planes == 0)
		planes = fb->planes;
	if (planes == 1)
d301 1
a301 1
		printf("x%d", planes);
a322 28
/* the cursor is just an inverted space */
#define flip_cursor(fb)							\
do {									\
	(*fb->bmv)((fb), (fb)->cblankx, (fb)->cblanky,			\
	    (fb)->cursorx * (fb)->ftwidth,				\
	    (fb)->cursory * (fb)->ftheight,				\
	    (fb)->ftwidth, (fb)->ftheight, RR_XOR);			\
} while (0)

int
diofb_alloc_attr(void *cookie, int fg, int bg, int flag, long *attrp)
{
	*attrp = flag & WSATTR_REVERSE;
	return (0);
}

int
diofb_mapchar(void *cookie, int c, unsigned int *cp)
{
	if (c < (int)' ' || c >= FONTMAXCHAR) {
		*cp = ' ';
		return (0);
	}

	*cp = c;
	return (5);
}

d324 1
a324 1
diofb_cursor(void *cookie, int on, int row, int col)
d326 2
a327 5
	struct diofb *fb = cookie;

	/* Turn old cursor off if necessary */
	if (fb->curvisible != 0)
		flip_cursor(fb);
d329 8
a336 5
	fb->cursorx = col;
	fb->cursory = row;

	if ((fb->curvisible = on) != 0)
		flip_cursor(fb);
d340 1
a340 1
diofb_putchar(void *cookie, int row, int col, u_int uc, long attr)
d342 2
a343 4
	struct diofb *fb = cookie;
	int wmrr;

	wmrr = (attr & WSATTR_REVERSE) ? RR_COPYINVERTED : RR_COPY;
d345 7
a351 3
	(*fb->bmv)(fb, charX(fb, uc), charY(fb, uc),
	    col * fb->ftwidth, row * fb->ftheight,
	    fb->ftwidth, fb->ftheight, wmrr);
d355 1
a355 1
diofb_copycols(void *cookie, int row, int src, int dst, int n)
d357 3
a359 1
	struct diofb *fb = cookie;
d361 1
a361 4
	n *= fb->ftwidth;
	src *= fb->ftwidth;
	dst *= fb->ftwidth;
	row *= fb->ftheight;
d363 8
a370 7
	(*fb->bmv)(fb, src, row, dst, row, n, fb->ftheight, RR_COPY);
}

void
diofb_copyrows(void *cookie, int src, int dst, int n)
{
	struct diofb *fb = cookie;
d372 7
a378 5
	n *= fb->ftheight;
	src *= fb->ftheight;
	dst *= fb->ftheight;

	(*fb->bmv)(fb, 0, src, 0, dst, fb->dwidth, n, RR_COPY);
d382 1
a382 1
diofb_erasecols(void *cookie, int row, int col, int num, long attr)
d384 3
a386 1
	struct diofb *fb = cookie;
d388 1
a388 5
	num *= fb->ftwidth;
	col *= fb->ftwidth;
	row *= fb->ftheight;
	(*fb->bmv)(fb, col, row, col, row, num, fb->ftheight, RR_CLEAR);
}
d390 8
a397 4
void
diofb_eraserows(void *cookie, int row, int num, long attr)
{
	struct diofb *fb = cookie;
d399 11
a409 3
	row *= fb->ftheight;
	num *= fb->ftheight;
	(*fb->bmv)(fb, 0, row, 0, row, fb->dwidth, num, RR_CLEAR);
d421 1
d426 1
a426 1
	*cookiep = fb;
d428 5
a432 1
	diofb_alloc_attr(fb, 0, 0, 0, attrp);
d458 1
a458 1
	if (offset & PGOFSET)
d461 31
a491 2
	if (offset < 0 || offset >= fb->fbsize)
		return (-1);
d493 1
a493 1
	return (((paddr_t)fb->fbaddr + offset) >> PGSHIFT);
@


1.4
log
@Colormap handling for topcat; Xwsfb now runs.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.3 2005/01/18 10:48:19 miod Exp $	*/
d226 3
@


1.3
log
@Correct mmap() bounds check.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.2 2005/01/16 16:14:09 miod Exp $	*/
d209 17
a225 1
	(*fb->bmv)(fb, 0, 0, 0, 0, fb->dwidth, fb->dheight, RR_CLEAR);
a442 7

	/*
	 * Setup inverted cursor.
	 */
	(*fb->bmv)(fb, charX(fb, ' '), charY(fb, ' '),
	    fb->cblankx, fb->cblanky, fb->ftwidth, fb->ftheight,
	    RR_COPYINVERTED);
@


1.2
log
@Simplify diofb_fbinquire(), since in the only case where we need to know
the video registers size, this value can easily be computed from the standard
fb registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: diofb.c,v 1.1 2005/01/14 22:39:25 miod Exp $	*/
d466 1
a466 1
	if (offset < 0 || offset > fb->fbsize)
@


1.1
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 1
a114 1
diofb_fbinquire(struct diofb *fb, int scode, struct diofbreg *fbr, int regsize)
d116 1
a116 1
	int fboff;
a121 1
	fb->regsize = regsize;
d139 1
a139 1
		fb->regsize = (int)fb->fbaddr;
d142 1
a142 1
		fb->fbkva = (caddr_t)fbr + fb->regsize;
@

