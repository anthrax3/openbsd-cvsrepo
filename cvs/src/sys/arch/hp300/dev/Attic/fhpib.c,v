head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.18
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.14
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.12
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.10
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.8
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.6
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.18
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.16
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.14
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.12
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2009.07.23.21.26.20;	author blambert;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.13.18.52.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.25.23.02.23;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.03.05.34.43;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.01.16.51.09;	author millert;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	97.07.06.08.01.50;	author downsj;	state Exp;
branches
	1.8.12.1;
next	1.7;

1.7
date	97.04.16.11.56.01;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.03.04.47.24;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.12.15.12.29;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.11.47.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.31;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.18;	author deraadt;	state Exp;
branches;
next	;

1.8.12.1
date	2001.07.04.10.15.27;	author niklas;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.8.12.4;

1.8.12.4
date	2004.02.19.10.48.38;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: fhpib.c,v 1.16 2009/07/23 21:26:20 blambert Exp $	*/
/*	$NetBSD: fhpib.c,v 1.18 1997/05/05 21:04:16 thorpej Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fhpib.c	8.2 (Berkeley) 1/12/94
 */

/*
 * 98625A/B HPIB driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <machine/autoconf.h>
#include <machine/intr.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>

#include <hp300/dev/dmavar.h>

#include <hp300/dev/fhpibreg.h>
#include <hp300/dev/hpibvar.h>

/*
 * Inline version of fhpibwait to be used in places where
 * we don't worry about getting hung.
 */
#define	FHPIBWAIT(hd, m)	while (((hd)->hpib_intr & (m)) == 0) DELAY(1)

#ifdef DEBUG
int	fhpibdebugunit = -1;
int	fhpibdebug = 0;
#define FDB_FAIL	0x01
#define FDB_DMA		0x02
#define FDB_WAIT	0x04
#define FDB_PPOLL	0x08

int	dopriodma = 0;	/* use high priority DMA */
int	doworddma = 1;	/* non-zero if we should attempt word dma */
int	doppollint = 1;	/* use ppoll interrupts instead of watchdog */
int	fhpibppolldelay = 50;
#endif

void	fhpibifc(struct fhpibdevice *);
void	fhpibdmadone(void *);
int	fhpibwait(struct fhpibdevice *, int);

void	fhpibreset(struct hpibbus_softc *);
int	fhpibsend(struct hpibbus_softc *, int, int, void *, int);
int	fhpibrecv(struct hpibbus_softc *, int, int, void *, int);
int	fhpibppoll(struct hpibbus_softc *);
void	fhpibppwatch(void *);
void	fhpibgo(struct hpibbus_softc *, int, int, void *, int, int, int);
void	fhpibdone(struct hpibbus_softc *);
int	fhpibintr(void *);

/*
 * Our controller ops structure.
 */
struct	hpib_controller fhpib_controller = {
	fhpibreset,
	fhpibsend,
	fhpibrecv,
	fhpibppoll,
	fhpibppwatch,
	fhpibgo,
	fhpibdone,
	fhpibintr
};

struct fhpib_softc {
	struct device sc_dev;		/* generic device glue */
	struct isr sc_isr;
	struct fhpibdevice *sc_regs;	/* device registers */
	struct timeout sc_dma_to;	/* DMA done timeout */
#ifdef DEBUG
	struct timeout sc_watch_to;	/* fhpibppwatch timeout */
#endif
	int	sc_cmd;
	struct hpibbus_softc *sc_hpibbus; /* XXX */
};

int	fhpibmatch(struct device *, void *, void *);
void	fhpibattach(struct device *, struct device *, void *);

struct cfattach fhpib_ca = {
	sizeof(struct fhpib_softc), fhpibmatch, fhpibattach
};

struct cfdriver fhpib_cd = {
	NULL, "fhpib", DV_DULL
};

int
fhpibmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct dio_attach_args *da = aux;

	if (da->da_id == DIO_DEVICE_ID_FHPIB)
		return (1);

	return (0);
}

void
fhpibattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct fhpib_softc *sc = (struct fhpib_softc *)self;
	struct dio_attach_args *da = aux;
	struct hpibdev_attach_args ha;
	int ipl;

	sc->sc_regs = (struct fhpibdevice *)iomap(dio_scodetopa(da->da_scode),
	    da->da_size);
	if (sc->sc_regs == NULL) {
		printf("\n%s: can't map registers\n", self->dv_xname);
		return;
	}

	ipl = DIO_IPL(sc->sc_regs);
	printf(" ipl %d: %s\n", ipl, DIO_DEVICE_DESC_FHPIB);

	/* Initialize timeout structures */
	timeout_set(&sc->sc_dma_to, fhpibdmadone, sc);

	/* Establish the interrupt handler. */
	sc->sc_isr.isr_func = fhpibintr;
	sc->sc_isr.isr_arg = sc;
	sc->sc_isr.isr_ipl = ipl;
	sc->sc_isr.isr_priority = IPL_BIO;
	dio_intr_establish(&sc->sc_isr, self->dv_xname);

	ha.ha_ops = &fhpib_controller;
	ha.ha_type = HPIBC;			/* XXX */
	ha.ha_ba = HPIBC_BA;
	ha.ha_softcpp = &sc->sc_hpibbus;	/* XXX */
	(void)config_found(self, &ha, hpibdevprint);
}

void
fhpibreset(hs)
	struct hpibbus_softc *hs;
{
	struct fhpib_softc *sc = (struct fhpib_softc *)hs->sc_dev.dv_parent;
	struct fhpibdevice *hd = sc->sc_regs;

	hd->hpib_cid = 0xFF;
	DELAY(100);
	hd->hpib_cmd = CT_8BIT;
	hd->hpib_ar = AR_ARONC;
	fhpibifc(hd);
	hd->hpib_ie = IDS_IE;
	hd->hpib_data = C_DCL;
	DELAY(100000);
	/*
	 * See if we can do word dma.
	 * If so, we should be able to write and read back the apropos bit.
	 */
	hd->hpib_ie |= IDS_WDMA;
	if (hd->hpib_ie & IDS_WDMA) {
		hd->hpib_ie &= ~IDS_WDMA;
		hs->sc_flags |= HPIBF_DMA16;
#ifdef DEBUG
		if (fhpibdebug & FDB_DMA)
			printf("fhpibtype: %s has word dma\n",
			    sc->sc_dev.dv_xname);

#endif
	}
}

void
fhpibifc(hd)
	struct fhpibdevice *hd;
{
	hd->hpib_cmd |= CT_IFC;
	hd->hpib_cmd |= CT_INITFIFO;
	DELAY(100);
	hd->hpib_cmd &= ~CT_IFC;
	hd->hpib_cmd |= CT_REN;
	hd->hpib_stat = ST_ATN;
}

int
fhpibsend(hs, slave, sec, ptr, origcnt)
	struct hpibbus_softc *hs;
	int slave, sec, origcnt;
	void *ptr;
{
	struct fhpib_softc *sc = (struct fhpib_softc *)hs->sc_dev.dv_parent;
	struct fhpibdevice *hd = sc->sc_regs;
	int cnt = origcnt;
	int timo;
	char *addr = ptr;

	hd->hpib_stat = 0;
	hd->hpib_imask = IM_IDLE | IM_ROOM;
	if (fhpibwait(hd, IM_IDLE) < 0)
		goto senderr;
	hd->hpib_stat = ST_ATN;
	hd->hpib_data = C_UNL;
	hd->hpib_data = C_TAG + hs->sc_ba;
	hd->hpib_data = C_LAG + slave;
	if (sec < 0) {
		if (sec == -2)		/* selected device clear KLUDGE */
			hd->hpib_data = C_SDC;
	} else
		hd->hpib_data = C_SCG + sec;
	if (fhpibwait(hd, IM_IDLE) < 0)
		goto senderr;
	if (cnt) {
		hd->hpib_stat = ST_WRITE;
		while (--cnt) {
			hd->hpib_data = *addr++;
			timo = hpibtimeout;
			while ((hd->hpib_intr & IM_ROOM) == 0) {
				if (--timo <= 0)
					goto senderr;
				DELAY(1);
			}
		}
		hd->hpib_stat = ST_EOI;
		hd->hpib_data = *addr;
		FHPIBWAIT(hd, IM_ROOM);
		hd->hpib_stat = ST_ATN;
		/* XXX: HP-UX claims bug with CS80 transparent messages */
		if (sec == 0x12)
			DELAY(150);
		hd->hpib_data = C_UNL;
		(void) fhpibwait(hd, IM_IDLE);
	}
	hd->hpib_imask = 0;
	return (origcnt);

senderr:
	hd->hpib_imask = 0;
	fhpibifc(hd);
#ifdef DEBUG
	if (fhpibdebug & FDB_FAIL) {
		printf("%s: fhpibsend failed: slave %d, sec %x, ",
		    sc->sc_dev.dv_xname, slave, sec);
		printf("sent %d of %d bytes\n", origcnt-cnt-1, origcnt);
	}
#endif
	return (origcnt - cnt - 1);
}

int
fhpibrecv(hs, slave, sec, ptr, origcnt)
	struct hpibbus_softc *hs;
	int slave, sec, origcnt;
	void *ptr;
{
	struct fhpib_softc *sc = (struct fhpib_softc *)hs->sc_dev.dv_parent;
	struct fhpibdevice *hd = sc->sc_regs;
	int cnt = origcnt;
	int timo;
	char *addr = ptr;

	/*
	 * Slave < 0 implies continuation of a previous receive
	 * that probably timed out.
	 */
	if (slave >= 0) {
		hd->hpib_stat = 0;
		hd->hpib_imask = IM_IDLE | IM_ROOM | IM_BYTE;
		if (fhpibwait(hd, IM_IDLE) < 0)
			goto recverror;
		hd->hpib_stat = ST_ATN;
		hd->hpib_data = C_UNL;
		hd->hpib_data = C_LAG + hs->sc_ba;
		hd->hpib_data = C_TAG + slave;
		if (sec != -1)
			hd->hpib_data = C_SCG + sec;
		if (fhpibwait(hd, IM_IDLE) < 0)
			goto recverror;
		hd->hpib_stat = ST_READ0;
		hd->hpib_data = 0;
	}
	if (cnt) {
		while (--cnt >= 0) {
			timo = hpibtimeout;
			while ((hd->hpib_intr & IM_BYTE) == 0) {
				if (--timo == 0)
					goto recvbyteserror;
				DELAY(1);
			}
			*addr++ = hd->hpib_data;
		}
		FHPIBWAIT(hd, IM_ROOM);
		hd->hpib_stat = ST_ATN;
		hd->hpib_data = (slave == 31) ? C_UNA : C_UNT;
		(void) fhpibwait(hd, IM_IDLE);
	}
	hd->hpib_imask = 0;
	return (origcnt);

recverror:
	fhpibifc(hd);
recvbyteserror:
	hd->hpib_imask = 0;
#ifdef DEBUG
	if (fhpibdebug & FDB_FAIL) {
		printf("%s: fhpibrecv failed: slave %d, sec %x, ",
		    sc->sc_dev.dv_xname, slave, sec);
		printf("got %d of %d bytes\n", origcnt-cnt-1, origcnt);
	}
#endif
	return (origcnt - cnt - 1);
}

void
fhpibgo(hs, slave, sec, ptr, count, rw, timo)
	struct hpibbus_softc *hs;
	int slave, sec, count, rw, timo;
	void *ptr;
{
	struct fhpib_softc *sc = (struct fhpib_softc *)hs->sc_dev.dv_parent;
	struct fhpibdevice *hd = sc->sc_regs;
	int i;
	char *addr = ptr;
	int flags = 0;

	hs->sc_flags |= HPIBF_IO;
	if (timo)
		hs->sc_flags |= HPIBF_TIMO;
	if (rw == B_READ)
		hs->sc_flags |= HPIBF_READ;
#ifdef DEBUG
	else if (hs->sc_flags & HPIBF_READ) {
		printf("fhpibgo: HPIBF_READ still set\n");
		hs->sc_flags &= ~HPIBF_READ;
	}
#endif
	hs->sc_count = count;
	hs->sc_addr = addr;
#ifdef DEBUG
	/* fhpibtransfer[unit]++;			XXX */
#endif
	if ((hs->sc_flags & HPIBF_DMA16) &&
	    ((int)addr & 1) == 0 && count && (count & 1) == 0
#ifdef DEBUG
	    && doworddma
#endif
	    ) {
#ifdef DEBUG
		/* fhpibworddma[unit]++;		XXX */
#endif
		flags |= DMAGO_WORD;
		hd->hpib_latch = 0;
	}
#ifdef DEBUG
	if (dopriodma)
		flags |= DMAGO_PRI;
#endif
	if (hs->sc_flags & HPIBF_READ) {
		sc->sc_cmd = CT_REN | CT_8BIT;
		hs->sc_curcnt = count;
		dmago(hs->sc_dq->dq_chan, addr, count, flags|DMAGO_READ);
		if (fhpibrecv(hs, slave, sec, 0, 0) < 0) {
#ifdef DEBUG
			printf("fhpibgo: recv failed, retrying...\n");
#endif
			(void) fhpibrecv(hs, slave, sec, 0, 0);
		}
		i = hd->hpib_cmd;
		hd->hpib_cmd = sc->sc_cmd;
		hd->hpib_ie = IDS_DMA(hs->sc_dq->dq_chan) |
			((flags & DMAGO_WORD) ? IDS_WDMA : 0);
		return;
	}
	sc->sc_cmd = CT_REN | CT_8BIT | CT_FIFOSEL;
	if (count < hpibdmathresh) {
#ifdef DEBUG
		/* fhpibnondma[unit]++;			XXX */
		if (flags & DMAGO_WORD)
			/* fhpibworddma[unit]--;	XXX */ ;
#endif
		hs->sc_curcnt = count;
		(void) fhpibsend(hs, slave, sec, addr, count);
		fhpibdone(hs);
		return;
	}
	count -= (flags & DMAGO_WORD) ? 2 : 1;
	hs->sc_curcnt = count;
	dmago(hs->sc_dq->dq_chan, addr, count, flags);
	if (fhpibsend(hs, slave, sec, 0, 0) < 0) {
#ifdef DEBUG
		printf("fhpibgo: send failed, retrying...\n");
#endif
		(void) fhpibsend(hs, slave, sec, 0, 0);
	}
	i = hd->hpib_cmd;
	hd->hpib_cmd = sc->sc_cmd;
	hd->hpib_ie = IDS_DMA(hs->sc_dq->dq_chan) | IDS_WRITE |
		((flags & DMAGO_WORD) ? IDS_WDMA : 0);
}

/*
 * A DMA read can finish but the device can still be waiting (MAG-tape
 * with more data than we're waiting for).  This timeout routine
 * takes care of that.  Somehow, the thing gets hosed.  For now, since
 * this should be a very rare occurrence, we RESET it.
 */
void
fhpibdmadone(arg)
	void *arg;
{
	struct fhpib_softc *sc = arg;
	struct hpibbus_softc *hs = sc->sc_hpibbus;
	int s;

	s  = splbio();
	if (hs->sc_flags & HPIBF_IO) {
		struct fhpibdevice *hd = sc->sc_regs;
		struct hpibqueue *hq;

		hd->hpib_imask = 0;
		hd->hpib_cid = 0xFF;
		DELAY(100);
		hd->hpib_cmd = CT_8BIT;
		hd->hpib_ar = AR_ARONC;
		fhpibifc(hd);
		hd->hpib_ie = IDS_IE;
		hs->sc_flags &= ~(HPIBF_DONE|HPIBF_IO|HPIBF_READ|HPIBF_TIMO);
		dmafree(hs->sc_dq);

		hq = TAILQ_FIRST(&hs->sc_queue);
		(hq->hq_intr)(hq->hq_softc);
	}
	splx(s);
}

void
fhpibdone(hs)
	struct hpibbus_softc *hs;
{
	struct fhpib_softc *sc = (struct fhpib_softc *)hs->sc_dev.dv_parent;
	struct fhpibdevice *hd = sc->sc_regs;
	char *addr;
	int cnt;

	cnt = hs->sc_curcnt;
	hs->sc_addr += cnt;
	hs->sc_count -= cnt;
#ifdef DEBUG
	if ((fhpibdebug & FDB_DMA) && fhpibdebugunit == sc->sc_dev.dv_unit)
		printf("fhpibdone: addr %p cnt %d\n",
		       hs->sc_addr, hs->sc_count);
#endif
	if (hs->sc_flags & HPIBF_READ) {
		hd->hpib_imask = IM_IDLE | IM_BYTE;
		if (hs->sc_flags & HPIBF_TIMO)
			timeout_add_msec(&sc->sc_dma_to, 250);
	} else {
		cnt = hs->sc_count;
		if (cnt) {
			addr = hs->sc_addr;
			hd->hpib_imask = IM_IDLE | IM_ROOM;
			FHPIBWAIT(hd, IM_IDLE);
			hd->hpib_stat = ST_WRITE;
			while (--cnt) {
				hd->hpib_data = *addr++;
				FHPIBWAIT(hd, IM_ROOM);
			}
			hd->hpib_stat = ST_EOI;
			hd->hpib_data = *addr;
		}
		hd->hpib_imask = IM_IDLE;
	}
	hs->sc_flags |= HPIBF_DONE;
	hd->hpib_stat = ST_IENAB;
	hd->hpib_ie = IDS_IE;
}

int
fhpibintr(arg)
	void *arg;
{
	struct fhpib_softc *sc = arg;
	struct hpibbus_softc *hs = sc->sc_hpibbus;
	struct fhpibdevice *hd = sc->sc_regs;
	struct hpibqueue *hq;
	int stat0;

	stat0 = hd->hpib_ids;
	if ((stat0 & (IDS_IE|IDS_IR)) != (IDS_IE|IDS_IR)) {
#ifdef DEBUG
		if ((fhpibdebug & FDB_FAIL) && (stat0 & IDS_IR) &&
		    (hs->sc_flags & (HPIBF_IO|HPIBF_DONE)) != HPIBF_IO)
			printf("%s: fhpibintr: bad status %x\n",
			sc->sc_dev.dv_xname, stat0);
		/* fhpibbadint[0]++;			XXX */
#endif
		return(0);
	}
	if ((hs->sc_flags & (HPIBF_IO|HPIBF_DONE)) == HPIBF_IO) {
#ifdef DEBUG
		/* fhpibbadint[1]++;			XXX */
#endif
		return(0);
	}

#ifdef DEBUG
	if ((fhpibdebug & FDB_DMA) && fhpibdebugunit == sc->sc_dev.dv_unit)
		printf("fhpibintr: flags %x\n", hs->sc_flags);
#endif
	hq = TAILQ_FIRST(&hs->sc_queue);
	if (hs->sc_flags & HPIBF_IO) {
		if (hs->sc_flags & HPIBF_TIMO)
			timeout_del(&sc->sc_dma_to);
		stat0 = hd->hpib_cmd;
		hd->hpib_cmd = sc->sc_cmd & ~CT_8BIT;
		hd->hpib_stat = 0;
		hd->hpib_cmd = CT_REN | CT_8BIT;
		stat0 = hd->hpib_intr;
		hd->hpib_imask = 0;
		hs->sc_flags &= ~(HPIBF_DONE|HPIBF_IO|HPIBF_READ|HPIBF_TIMO);
		dmafree(hs->sc_dq);
		(hq->hq_intr)(hq->hq_softc);
	} else if (hs->sc_flags & HPIBF_PPOLL) {
		stat0 = hd->hpib_intr;
#ifdef DEBUG
		if ((fhpibdebug & FDB_FAIL) &&
		    doppollint && (stat0 & IM_PPRESP) == 0)
			printf("%s: fhpibintr: bad intr reg %x\n",
			    sc->sc_dev.dv_xname, stat0);
#endif
		hd->hpib_stat = 0;
		hd->hpib_imask = 0;
#ifdef DEBUG
		stat0 = fhpibppoll(hs);
		if ((fhpibdebug & FDB_PPOLL) &&
		    fhpibdebugunit == sc->sc_dev.dv_unit)
			printf("fhpibintr: got PPOLL status %x\n", stat0);
		if ((stat0 & (0x80 >> hq->hq_slave)) == 0) {
			/*
			 * XXX give it another shot (68040)
			 */
			/* fhpibppollfail[unit]++;	XXX */
			DELAY(fhpibppolldelay);
			stat0 = fhpibppoll(hs);
			if ((stat0 & (0x80 >> hq->hq_slave)) == 0 &&
			    (fhpibdebug & FDB_PPOLL) &&
			    fhpibdebugunit == sc->sc_dev.dv_unit)
				printf("fhpibintr: PPOLL: unit %d slave %d stat %x\n",
				       sc->sc_dev.dv_unit, hq->hq_slave, stat0);
		}
#endif
		hs->sc_flags &= ~HPIBF_PPOLL;
		(hq->hq_intr)(hq->hq_softc);
	}
	return(1);
}

int
fhpibppoll(hs)
	struct hpibbus_softc *hs;
{
	struct fhpib_softc *sc = (struct fhpib_softc *)hs->sc_dev.dv_parent;
	struct fhpibdevice *hd = sc->sc_regs;
	int ppoll;

	hd->hpib_stat = 0;
	hd->hpib_psense = 0;
	hd->hpib_pmask = 0xFF;
	hd->hpib_imask = IM_PPRESP | IM_PABORT;
	DELAY(25);
	hd->hpib_intr = IM_PABORT;
	ppoll = hd->hpib_data;
	if (hd->hpib_intr & IM_PABORT)
		ppoll = 0;
	hd->hpib_imask = 0;
	hd->hpib_pmask = 0;
	hd->hpib_stat = ST_IENAB;
	return(ppoll);
}

int
fhpibwait(hd, x)
	struct fhpibdevice *hd;
	int x;
{
	int timo = hpibtimeout;

	while ((hd->hpib_intr & x) == 0 && --timo)
		DELAY(1);
	if (timo == 0) {
#ifdef DEBUG
		if (fhpibdebug & FDB_FAIL)
			printf("fhpibwait(%p, %x) timeout\n", hd, x);
#endif
		return(-1);
	}
	return(0);
}

/*
 * XXX: this will have to change if we ever allow more than one
 * pending operation per HP-IB.
 */
void
fhpibppwatch(arg)
	void *arg;
{
	struct hpibbus_softc *hs = arg;
	struct fhpib_softc *sc = (struct fhpib_softc *)hs->sc_dev.dv_parent;
	struct fhpibdevice *hd = sc->sc_regs;
	int slave;

	if ((hs->sc_flags & HPIBF_PPOLL) == 0)
		return;
	slave = (0x80 >> TAILQ_FIRST(&hs->sc_queue)->hq_slave);
#ifdef DEBUG
	if (!doppollint) {
		if (fhpibppoll(hs) & slave) {
			hd->hpib_stat = ST_IENAB;
			hd->hpib_imask = IM_IDLE | IM_ROOM;
		} else {
			timeout_set(&sc->sc_watch_to, fhpibppwatch, hs);
			timeout_add(&sc->sc_watch_to, 1);
		}
		return;
	}
	if ((fhpibdebug & FDB_PPOLL) && sc->sc_dev.dv_unit == fhpibdebugunit)
		printf("fhpibppwatch: sense request on %s\n",
		    sc->sc_dev.dv_xname);
#endif
	hd->hpib_psense = ~slave;
	hd->hpib_pmask = slave;
	hd->hpib_stat = ST_IENAB;
	hd->hpib_imask = IM_PPRESP | IM_PABORT;
	hd->hpib_ie = IDS_IE;
}
@


1.16
log
@timeout_add -> timeout_add_msec

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.15 2005/11/13 18:52:15 miod Exp $	*/
@


1.15
log
@Fix timeout usage introduced during the timeout API change (better late
than never), allows slower disks on nhpib to work again.
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.14 2004/12/25 23:02:23 miod Exp $	*/
d493 1
a493 1
			timeout_add(&sc->sc_dma_to, hz >> 2);
@


1.14
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.13 2004/09/29 07:35:52 miod Exp $	*/
a163 3
#ifdef DEBUG
	timeout_set(&sc->sc_watch_to, fhpibppwatch, sc);
#endif
d448 3
a450 3
	struct hpibbus_softc *hs = arg;
	struct fhpib_softc *sc = (struct fhpib_softc *)hs->sc_dev.dv_parent;
	int s = splbio();
d452 1
d658 2
a659 1
		} else
d661 1
@


1.13
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.12 2003/11/03 05:34:43 david Exp $	*/
d469 1
a469 1
		hq = hs->sc_queue.tqh_first;
d549 1
a549 1
	hq = hs->sc_queue.tqh_first;
d654 1
a654 1
	slave = (0x80 >> hs->sc_queue.tqh_first->hq_slave);
@


1.12
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.11 2003/06/02 23:27:44 millert Exp $	*/
d108 1
d169 5
a173 1
	(void) dio_intr_establish(fhpibintr, sc, ipl, IPL_BIO);
d199 1
a199 1
	 * If so, we should be able to write and read back the appropos bit.
d544 1
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.10 2002/03/14 01:26:30 millert Exp $	*/
d440 1
a440 1
 * this should be a very rare occurence, we RESET it.
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.9 2001/05/01 16:51:09 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.8 1997/07/06 08:01:50 downsj Exp $	*/
d83 12
a94 12
void	fhpibifc __P((struct fhpibdevice *));
void	fhpibdmadone __P((void *));
int	fhpibwait __P((struct fhpibdevice *, int));

void	fhpibreset __P((struct hpibbus_softc *));
int	fhpibsend __P((struct hpibbus_softc *, int, int, void *, int));
int	fhpibrecv __P((struct hpibbus_softc *, int, int, void *, int));
int	fhpibppoll __P((struct hpibbus_softc *));
void	fhpibppwatch __P((void *));
void	fhpibgo __P((struct hpibbus_softc *, int, int, void *, int, int, int));
void	fhpibdone __P((struct hpibbus_softc *));
int	fhpibintr __P((void *));
d121 2
a122 2
int	fhpibmatch __P((struct device *, void *, void *));
void	fhpibattach __P((struct device *, struct device *, void *));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.9 2001/05/01 16:51:09 millert Exp $	*/
d83 12
a94 12
void	fhpibifc(struct fhpibdevice *);
void	fhpibdmadone(void *);
int	fhpibwait(struct fhpibdevice *, int);

void	fhpibreset(struct hpibbus_softc *);
int	fhpibsend(struct hpibbus_softc *, int, int, void *, int);
int	fhpibrecv(struct hpibbus_softc *, int, int, void *, int);
int	fhpibppoll(struct hpibbus_softc *);
void	fhpibppwatch(void *);
void	fhpibgo(struct hpibbus_softc *, int, int, void *, int, int, int);
void	fhpibdone(struct hpibbus_softc *);
int	fhpibintr(void *);
d121 2
a122 2
int	fhpibmatch(struct device *, void *, void *);
void	fhpibattach(struct device *, struct device *, void *);
@


1.8
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.7 1997/04/16 11:56:01 downsj Exp $	*/
d49 1
d113 4
d165 6
d494 1
a494 1
			timeout(fhpibdmadone, hs, hz >> 2);
d550 1
a550 1
			untimeout(fhpibdmadone, hs);
d659 1
a659 1
			timeout(fhpibppwatch, sc, 1);
@


1.8.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.8 1997/07/06 08:01:50 downsj Exp $	*/
a48 1
#include <sys/timeout.h>
a111 4
	struct timeout sc_dma_to;	/* DMA done timeout */
#ifdef DEBUG
	struct timeout sc_watch_to;	/* fhpibppwatch timeout */
#endif
a159 6
	/* Initialize timeout structures */
	timeout_set(&sc->sc_dma_to, fhpibdmadone, sc);
#ifdef DEBUG
	timeout_set(&sc->sc_watch_to, fhpibppwatch, sc);
#endif

d483 1
a483 1
			timeout_add(&sc->sc_dma_to, hz >> 2);
d539 1
a539 1
			timeout_del(&sc->sc_dma_to);
d648 1
a648 1
			timeout_add(&sc->sc_watch_to, 1);
@


1.8.12.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 12
a94 12
void	fhpibifc(struct fhpibdevice *);
void	fhpibdmadone(void *);
int	fhpibwait(struct fhpibdevice *, int);

void	fhpibreset(struct hpibbus_softc *);
int	fhpibsend(struct hpibbus_softc *, int, int, void *, int);
int	fhpibrecv(struct hpibbus_softc *, int, int, void *, int);
int	fhpibppoll(struct hpibbus_softc *);
void	fhpibppwatch(void *);
void	fhpibgo(struct hpibbus_softc *, int, int, void *, int, int, int);
void	fhpibdone(struct hpibbus_softc *);
int	fhpibintr(void *);
d121 2
a122 2
int	fhpibmatch(struct device *, void *, void *);
void	fhpibattach(struct device *, struct device *, void *);
@


1.8.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fhpib.c,v 1.8.12.2 2002/03/28 10:07:18 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.12.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d440 1
a440 1
 * this should be a very rare occurrence, we RESET it.
@


1.7
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: fhpib.c,v 1.6 1997/02/03 04:47:24 downsj Exp $	*/
/*	$NetBSD: fhpib.c,v 1.17 1997/04/14 02:33:19 thorpej Exp $	*/
d161 1
a161 2
	(void) intr_establish(fhpibintr, sc, ipl, IPL_BIO);
	dmacomputeipl();
@


1.6
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: fhpib.c,v 1.5 1997/01/12 15:12:29 downsj Exp $	*/
/*	$NetBSD: fhpib.c,v 1.14 1997/01/30 09:06:53 thorpej Exp $	*/
d51 1
a51 2

#include <hp300/hp300/isr.h>
d161 1
a161 1
	(void) isrlink(fhpibintr, sc, ipl, ISRPRI_BIO);
d205 1
a205 1
	register struct fhpibdevice *hd;
d223 2
a224 2
	register int cnt = origcnt;
	register int timo;
d287 2
a288 2
	register int cnt = origcnt;
	register int timo;
d350 2
a351 2
	register struct fhpibdevice *hd = sc->sc_regs;
	register int i;
d440 1
a440 1
	register struct hpibbus_softc *hs = arg;
d445 2
a446 2
		register struct fhpibdevice *hd = sc->sc_regs;
		register struct hpibqueue *hq;
d469 3
a471 3
	register struct fhpibdevice *hd = sc->sc_regs;
	register char *addr;
	register int cnt;
d477 2
a478 2
	if ((fhpibdebug & FDB_DMA) && fhpibdebugunit == unit)
		printf("fhpibdone: addr %x cnt %d\n",
d511 4
a514 4
	register struct hpibbus_softc *hs = sc->sc_hpibbus;
	register struct fhpibdevice *hd = sc->sc_regs;
	register struct hpibqueue *hq;
	register int stat0, unit = sc->sc_dev.dv_unit;
d534 1
a534 1
	if ((fhpibdebug & FDB_DMA) && fhpibdebugunit == unit)
d562 2
a563 1
		if ((fhpibdebug & FDB_PPOLL) && unit == fhpibdebugunit)
d573 2
a574 1
			    (fhpibdebug & FDB_PPOLL) && unit == fhpibdebugunit)
d576 1
a576 1
				       unit, dq->dq_slave, stat0);
d590 2
a591 2
	register struct fhpibdevice *hd = sc->sc_regs;
	register int ppoll;
d610 1
a610 1
	register struct fhpibdevice *hd;
d613 1
a613 1
	register int timo = hpibtimeout;
d620 1
a620 1
			printf("fhpibwait(%x, %x) timeout\n", hd, x);
d635 1
a635 1
	register struct hpibbus_softc *hs = arg;
d637 2
a638 2
	register struct fhpibdevice *hd = sc->sc_regs;
	register int slave;
@


1.5
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: fhpib.c,v 1.13 1996/10/13 03:14:10 christos Exp $	*/
d5 1
a42 2
#include "hpib.h"
#if NHPIB > 0
d48 11
a59 1
#include <hp300/dev/device.h>
a61 1
#include <hp300/dev/dmavar.h>
a80 6

long	fhpibbadint[2] = { 0 };
long	fhpibtransfer[NHPIB] = { 0 };
long	fhpibnondma[NHPIB] = { 0 };
long	fhpibworddma[NHPIB] = { 0 };
long	fhpibppollfail[NHPIB] = { 0 };
d83 8
a90 6
int	fhpibcmd[NHPIB];

void	fhpibreset __P((int));
int	fhpibsend __P((int, int, int, void *, int));
int	fhpibrecv __P((int, int, int, void *, int));
int	fhpibppoll __P((int));
d92 2
a93 2
void	fhpibgo __P((int, int, int, void *, int, int, int));
void	fhpibdone __P((int));
d110 18
d129 3
a131 2
fhpibtype(hc)
	register struct hp_ctlr *hc;
d133 1
a133 5
	register struct hpib_softc *hs = &hpib_softc[hc->hp_unit];
	register struct fhpibdevice *hd = (struct fhpibdevice *)hc->hp_addr;

	if (hd->hpib_cid != HPIBC)
		return (0);
d135 2
a136 2
	hs->sc_type = HPIBC;
	hc->hp_ipl = HPIB_IPL(hd->hpib_ids);
d138 1
a138 1
	return (1);
d142 18
a159 4
fhpibattach(hc)
	struct hp_ctlr *hc;
{
	register struct hpib_softc *hs = &hpib_softc[hc->hp_unit];
d161 9
a169 7
	if (hs->sc_type != HPIBC)
		panic("fhpibattach: unknown type 0x%x", hs->sc_type);
		/* NOTREACHED */

	hs->sc_ba = HPIBC_BA;
	hs->sc_descrip = "98625A or 98625B fast HP-IB";
	hs->sc_controller = &fhpib_controller;
d173 2
a174 2
fhpibreset(unit)
	int unit;
d176 2
a177 2
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct fhpibdevice *hd;
a178 1
	hd = (struct fhpibdevice *)hs->sc_hc->hp_addr;
d197 2
a198 1
			printf("fhpibtype: unit %d has word dma\n", unit);
d204 1
d217 3
a219 2
fhpibsend(unit, slave, sec, ptr, origcnt)
	int unit, slave, sec, origcnt;
d222 2
a223 2
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct fhpibdevice *hd;
a227 1
	hd = (struct fhpibdevice *)hs->sc_hc->hp_addr;
d273 1
a273 1
		    hs->sc_hc->hp_xname, slave, sec);
d281 3
a283 2
fhpibrecv(unit, slave, sec, ptr, origcnt)
	int unit, slave, sec, origcnt;
d286 2
a287 2
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct fhpibdevice *hd;
a291 1
	hd = (struct fhpibdevice *)hs->sc_hc->hp_addr;
d337 1
a337 1
		    hs->sc_hc->hp_xname, slave, sec);
d345 3
a347 2
fhpibgo(unit, slave, sec, ptr, count, rw, timo)
	int unit, slave, sec, count, rw, timo;
d350 2
a351 2
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct fhpibdevice *hd;
a355 1
	hd = (struct fhpibdevice *)hs->sc_hc->hp_addr;
d370 1
a370 1
	fhpibtransfer[unit]++;
d379 1
a379 1
		fhpibworddma[unit]++;
d389 1
a389 1
		fhpibcmd[unit] = CT_REN | CT_8BIT;
d391 2
a392 2
		dmago(hs->sc_dq.dq_ctlr, addr, count, flags|DMAGO_READ);
		if (fhpibrecv(unit, slave, sec, 0, 0) < 0) {
d396 1
a396 1
			(void) fhpibrecv(unit, slave, sec, 0, 0);
d399 2
a400 2
		hd->hpib_cmd = fhpibcmd[unit];
		hd->hpib_ie = IDS_DMA(hs->sc_dq.dq_ctlr) |
d404 1
a404 1
	fhpibcmd[unit] = CT_REN | CT_8BIT | CT_FIFOSEL;
d407 1
a407 1
		fhpibnondma[unit]++;
d409 1
a409 1
			fhpibworddma[unit]--;
d412 2
a413 2
		(void) fhpibsend(unit, slave, sec, addr, count);
		fhpibdone(unit);
d418 2
a419 2
	dmago(hs->sc_dq.dq_ctlr, addr, count, flags);
	if (fhpibsend(unit, slave, sec, 0, 0) < 0) {
d423 1
a423 1
		(void) fhpibsend(unit, slave, sec, 0, 0);
d426 2
a427 2
	hd->hpib_cmd = fhpibcmd[unit];
	hd->hpib_ie = IDS_DMA(hs->sc_dq.dq_ctlr) | IDS_WRITE |
d441 2
a442 2
	register int unit;
	register struct hpib_softc *hs;
a444 2
	unit = (int)arg;
	hs = &hpib_softc[unit];
d446 2
a447 2
		register struct fhpibdevice *hd;
		register struct devqueue *dq;
a448 1
		hd = (struct fhpibdevice *)hs->sc_hc->hp_addr;
d457 4
a460 3
		dmafree(&hs->sc_dq);
		dq = hs->sc_sq.dq_forw;
		(dq->dq_driver->d_intr)(dq->dq_softc);
d462 1
a462 1
	(void) splx(s);
d466 2
a467 2
fhpibdone(unit)
	int unit;
d469 2
a470 2
	register struct hpib_softc *hs = &hpib_softc[unit];
	register struct fhpibdevice *hd;
a473 1
	hd = (struct fhpibdevice *)hs->sc_hc->hp_addr;
d485 1
a485 1
			timeout(fhpibdmadone, (void *)unit, hz >> 2);
d511 5
a515 4
	register struct hpib_softc *hs = arg;
	register struct fhpibdevice *hd;
	register struct devqueue *dq;
	register int stat0, unit = hs->sc_hc->hp_unit;
a516 1
	hd = (struct fhpibdevice *)hs->sc_hc->hp_addr;
d523 2
a524 2
			hs->sc_hc->hp_xname, stat0);
		fhpibbadint[0]++;
d530 1
a530 1
		fhpibbadint[1]++;
d538 1
a538 1
	dq = hs->sc_sq.dq_forw;
d541 1
a541 1
			untimeout(fhpibdmadone, (void *)unit);
d543 1
a543 1
		hd->hpib_cmd = fhpibcmd[unit] & ~CT_8BIT;
d549 2
a550 2
		dmafree(&hs->sc_dq);
		(dq->dq_driver->d_intr)(dq->dq_softc);
d557 1
a557 1
			    hs->sc_hc->hp_xname, stat0);
d562 1
a562 1
		stat0 = fhpibppoll(unit);
d565 1
a565 1
		if ((stat0 & (0x80 >> dq->dq_slave)) == 0) {
d569 1
a569 1
			fhpibppollfail[unit]++;
d571 2
a572 2
			stat0 = fhpibppoll(unit);
			if ((stat0 & (0x80 >> dq->dq_slave)) == 0 &&
d579 1
a579 1
		(dq->dq_driver->d_intr)(dq->dq_softc);
d585 2
a586 2
fhpibppoll(unit)
	int unit;
d588 2
a589 1
	register struct fhpibdevice *hd;
a591 1
	hd = (struct fhpibdevice *)hpib_softc[unit].sc_hc->hp_addr;
d634 3
a636 3
	register int unit;
	register struct hpib_softc *hs;
	register struct fhpibdevice *hd;
a638 2
	unit = (int)arg;
	hs = &hpib_softc[unit];
d641 1
a641 2
	hd = (struct fhpibdevice *)hs->sc_hc->hp_addr;
	slave = (0x80 >> hs->sc_sq.dq_forw->dq_slave);
d644 1
a644 1
		if (fhpibppoll(unit) & slave) {
d648 1
a648 1
			timeout(fhpibppwatch, (void *)unit, 1);
d651 3
a653 2
	if ((fhpibdebug & FDB_PPOLL) && unit == fhpibdebugunit)
		printf("fhpibppwatch: sense request on %d\n", unit);
a660 1
#endif /* NHPIB > 0 */
@


1.4
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: fhpib.c,v 1.11 1996/05/18 23:56:59 thorpej Exp $	*/
@


1.3
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: fhpib.c,v 1.9 1996/02/14 02:44:20 thorpej Exp $	*/
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: fhpib.c,v 1.8 1995/12/02 18:21:56 thorpej Exp $	*/
d89 1
a89 1
int	fhpibintr __P((int));
d425 1
a425 1
		(dq->dq_driver->d_intr)(dq->dq_unit);
d474 2
a475 2
fhpibintr(unit)
	register int unit;
d477 1
a477 1
	register struct hpib_softc *hs = &hpib_softc[unit];
d480 1
a480 1
	register int stat0;
d516 1
a516 1
		(dq->dq_driver->d_intr)(dq->dq_unit);
d545 1
a545 1
		(dq->dq_driver->d_intr)(dq->dq_unit);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: fhpib.c,v 1.6 1995/01/07 10:30:10 mycroft Exp $	*/
d82 24
d113 2
a114 1
		return(0);
d116 15
d132 2
a133 2
	hc->hp_ipl = HPIB_IPL(hd->hpib_ids);
	return(1);
d136 1
d179 2
a180 1
fhpibsend(unit, slave, sec, addr, origcnt)
d182 1
a182 1
	register char *addr;
d188 1
d235 2
a236 2
		printf("hpib%d: fhpibsend failed: slave %d, sec %x, ",
			unit, slave, sec);
d243 2
a244 1
fhpibrecv(unit, slave, sec, addr, origcnt)
d246 1
a246 1
	register char *addr;
d252 1
d299 2
a300 2
		printf("hpib%d: fhpibrecv failed: slave %d, sec %x, ",
		       unit, slave, sec);
d307 4
a310 4
fhpibgo(unit, slave, sec, addr, count, rw, timo)
	register int unit;
	int slave, sec, count, rw;
	char *addr;
d315 1
d430 1
d473 1
d488 2
a489 2
			printf("hpib%d: fhpibintr: bad status %x\n",
			       unit, stat0);
d522 2
a523 2
			printf("hpib%d: fhpibintr: bad intr reg %x\n",
			       unit, stat0);
d550 1
d573 1
d629 1
a629 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
