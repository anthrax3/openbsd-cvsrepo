head	1.17;
access;
symbols
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.10.0.22
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.20
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.18
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.16
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.14
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.12
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.10
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.8
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2004.08.03.21.46.56;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2003.10.26.15.07.25;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.03.17.01.29;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.25.20.05.35;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.10.20.30.14;	author jsyn;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.06.08.01.55;	author downsj;	state Exp;
branches
	1.10.12.1
	1.10.22.1;
next	1.9;

1.9
date	97.07.02.12.21.46;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.04.16.11.56.14;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.03.11.09.54.09;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.03.04.47.44;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.12.15.13.01;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.11.47.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.54;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.21;	author deraadt;	state Exp;
branches;
next	;

1.10.12.1
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2003.03.27.23.19.20;	author niklas;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.10.12.4;

1.10.12.4
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.10.12.5;

1.10.12.5
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	;

1.10.22.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	1.10.22.2;

1.10.22.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.10.22.3;

1.10.22.3
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Replace the old 4.4BSD scsi code used on hp300 with a ``real'' driver
interfaced with the MI scsi code.

Adapted from NetBSD with some changes (especially to get tape and old
cd-rom drives to not cause the driver to spin during probe).

Tested by millert@@ and I, ok millert@@
@
text
@/*	$OpenBSD: scsi.c,v 1.16 2003/10/26 15:07:25 jmc Exp $	*/
/*	$NetBSD: scsi.c,v 1.21 1997/05/05 21:08:26 thorpej Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson of Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)scsi.c	8.2 (Berkeley) 1/12/94
 */

/*
 * HP 9000/3xx 98658 SCSI host adaptor driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/hp300spu.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>

#include <hp300/dev/dmavar.h>

#include <hp300/dev/scsireg.h>
#include <hp300/dev/scsivar.h>

struct scsi_softc {
	struct	device sc_dev;		/* generic device glue */
	volatile struct scsidevice *sc_regs;	/* card registers */
	struct	dmaqueue sc_dq;		/* our entry in DMA job queue */
	TAILQ_HEAD(, scsiqueue) sc_queue;	/* job queue */
	u_char	sc_flags;
	u_char	sc_sync;
	u_char	sc_scsi_addr;
	u_char	sc_scsiid;	/* XXX unencoded copy of sc_scsi_addr */
	u_char	sc_stat[2];
	u_char	sc_msg[7];
};

/* sc_flags */
#define	SCSI_IO		0x80	/* DMA I/O in progress */
#define	SCSI_DMA32	0x40	/* 32-bit DMA should be used */
#define	SCSI_HAVEDMA	0x04	/* controller has DMA channel */
#ifdef DEBUG
#define	SCSI_PAD	0x02	/* 'padded' transfer in progress */
#endif
#define	SCSI_ALIVE	0x01	/* controller initialized */

/*
 * SCSI delays
 * In u-seconds, primarily for state changes on the SPC.
 */
#define	SCSI_CMD_WAIT	10000	/* wait per step of 'immediate' cmds */
#define	SCSI_DATA_WAIT	10000	/* wait per data in/out step */
#define	SCSI_INIT_WAIT	50000	/* wait per step (both) during init */

static void	scsiabort(int, struct scsi_softc *,
				volatile struct scsidevice *, char *);
static void	scsierror(struct scsi_softc *,
				volatile struct scsidevice *, u_char);
static int	issue_select(volatile struct scsidevice *,
				u_char, u_char);
static int	wait_for_select(volatile struct scsidevice *);
static int	ixfer_start(volatile struct scsidevice *,
				int, u_char, int);
static int	ixfer_out(volatile struct scsidevice *, int, u_char *);
static void	ixfer_in(volatile struct scsidevice *, int, u_char *);
static int	mxfer_in(volatile struct scsidevice *,
				int, u_char *, u_char);
static int	scsiicmd(struct scsi_softc *, int, u_char *, int,
				u_char *, int, u_char);
static void	finishxfer(struct scsi_softc *,
				volatile struct scsidevice *, int);

int	scsimatch(struct device *, void *, void *);
void	scsiattach(struct device *, struct device *, void *);
void	scsi_attach_children(struct scsi_softc *);
int	scsisubmatch(struct device *, void *, void *);

struct cfattach oscsi_ca = {
	sizeof(struct scsi_softc), scsimatch, scsiattach
};

struct cfdriver oscsi_cd = {
	NULL, "oscsi", DV_DULL
};

int scsi_cmd_wait = SCSI_CMD_WAIT;
int scsi_data_wait = SCSI_DATA_WAIT;
int scsi_init_wait = SCSI_INIT_WAIT;

int scsi_nosync = 1;		/* inhibit sync xfers if 1 */
int scsi_pridma = 0;		/* use "priority" dma */

#ifdef DEBUG
int	scsi_debug = 0;
#define WAITHIST
#endif

#ifdef WAITHIST
#define MAXWAIT	1022
u_int	ixstart_wait[MAXWAIT+2];
u_int	ixin_wait[MAXWAIT+2];
u_int	ixout_wait[MAXWAIT+2];
u_int	mxin_wait[MAXWAIT+2];
u_int	mxin2_wait[MAXWAIT+2];
u_int	cxin_wait[MAXWAIT+2];
u_int	fxfr_wait[MAXWAIT+2];
u_int	sgo_wait[MAXWAIT+2];
#define HIST(h,w) (++h[((w)>MAXWAIT? MAXWAIT : ((w) < 0 ? -1 : (w))) + 1]);
#else
#define HIST(h,w)
#endif

#define	b_cylin		b_resid

static void
scsiabort(target, hs, hd, where)
	int target;
	struct scsi_softc *hs;
	volatile struct scsidevice *hd;
	char *where;
{
	int len;
	int maxtries;	/* XXX - kludge till I understand whats *supposed* to happen */
	int startlen;	/* XXX - kludge till I understand whats *supposed* to happen */
	u_char junk;

	printf("%s: ", hs->sc_dev.dv_xname);
	if (target != -1)
		printf("targ %d ", target);
	printf("abort from %s: phase=0x%x, ssts=0x%x, ints=0x%x\n",
		where, hd->scsi_psns, hd->scsi_ssts, hd->scsi_ints);

	hd->scsi_ints = hd->scsi_ints;
	hd->scsi_csr = 0;
	if (hd->scsi_psns == 0 || (hd->scsi_ssts & SSTS_INITIATOR) == 0)
		/* no longer connected to scsi target */
		return;

	/* get the number of bytes remaining in current xfer + fudge */
	len = (hd->scsi_tch << 16) | (hd->scsi_tcm << 8) | hd->scsi_tcl;

	/* for that many bus cycles, try to send an abort msg */
	for (startlen = (len += 1024); (hd->scsi_ssts & SSTS_INITIATOR) && --len >= 0; ) {
		hd->scsi_scmd = SCMD_SET_ATN;
		maxtries = 1000;
		while ((hd->scsi_psns & PSNS_REQ) == 0) {
			if (! (hd->scsi_ssts & SSTS_INITIATOR))
				goto out;
			DELAY(1);
			if (--maxtries == 0) {
				printf("-- scsiabort gave up after 1000 tries (startlen = %d len = %d)\n",
					startlen, len);
				goto out2;
			}

		}
out2:
		if ((hd->scsi_psns & PHASE) == MESG_OUT_PHASE)
			hd->scsi_scmd = SCMD_RST_ATN;
		hd->scsi_pctl = hd->scsi_psns & PHASE;
		if (hd->scsi_psns & PHASE_IO) {
			/* one of the input phases - read & discard a byte */
			hd->scsi_scmd = SCMD_SET_ACK;
			if (hd->scsi_tmod == 0)
				while (hd->scsi_psns & PSNS_REQ)
					DELAY(1);
			junk = hd->scsi_temp;
		} else {
			/* one of the output phases - send an abort msg */
			hd->scsi_temp = MSG_ABORT;
			hd->scsi_scmd = SCMD_SET_ACK;
			if (hd->scsi_tmod == 0)
				while (hd->scsi_psns & PSNS_REQ)
					DELAY(1);
		}
		hd->scsi_scmd = SCMD_RST_ACK;
	}
out:
	/*
	 * Either the abort was successful & the bus is disconnected or
	 * the device didn't listen.  If the latter, announce the problem.
	 * Either way, reset the card & the SPC.
	 */
	if (len < 0 && hs)
		printf("%s: abort failed.  phase=0x%x, ssts=0x%x\n",
			hs->sc_dev.dv_xname, hd->scsi_psns, hd->scsi_ssts);

	if (! ((junk = hd->scsi_ints) & INTS_RESEL)) {
		hd->scsi_sctl |= SCTL_CTRLRST;
		DELAY(2);
		hd->scsi_sctl &=~ SCTL_CTRLRST;
		hd->scsi_hconf = 0;
		hd->scsi_ints = hd->scsi_ints;
	}
}

/*
 * XXX Set/reset long delays.
 *
 * if delay == 0, reset default delays
 * if delay < 0,  set both delays to default long initialization values
 * if delay > 0,  set both delays to this value
 *
 * Used when a devices is expected to respond slowly (e.g. during
 * initialization).
 */
void
scsi_delay(delay)
	int delay;
{
	static int saved_cmd_wait, saved_data_wait;

	if (delay) {
		saved_cmd_wait = scsi_cmd_wait;
		saved_data_wait = scsi_data_wait;
		if (delay > 0)
			scsi_cmd_wait = scsi_data_wait = delay;
		else
			scsi_cmd_wait = scsi_data_wait = scsi_init_wait;
	} else {
		scsi_cmd_wait = saved_cmd_wait;
		scsi_data_wait = saved_data_wait;
	}
}

int
scsimatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct dio_attach_args *da = aux;

	switch (da->da_id) {
	case DIO_DEVICE_ID_SCSI0:
	case DIO_DEVICE_ID_SCSI1:
	case DIO_DEVICE_ID_SCSI2:
	case DIO_DEVICE_ID_SCSI3:
		return (1);
	}

	return (0);
}

void
scsiattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct scsi_softc *hs = (struct scsi_softc *)self;
	struct dio_attach_args *da = aux;
	struct scsidevice *hd;
	int ipl, unit = self->dv_unit;

	/*
	 * Set up DMA job queue entry.
	 */
	hs->sc_dq.dq_softc = hs;
	hs->sc_dq.dq_start = scsistart;
	hs->sc_dq.dq_done = scsidone;

	/* Initialize request queue. */
	TAILQ_INIT(&hs->sc_queue);

	/* Map the device. */
	hd = (struct scsidevice *)iomap(dio_scodetopa(da->da_scode),
	    da->da_size);
	if (hd == NULL) {
		printf("\n%s: can't map registers\n", self->dv_xname);
		return;
	}
	ipl = DIO_IPL(hd);

	printf(" ipl %d", ipl);

	hs->sc_regs = hd;

	/* Establish the interrupt handler. */
	(void) dio_intr_establish(scsiintr, hs, ipl, IPL_BIO);

	/* Reset the controller. */
	scsireset(unit);

	/*
	 * Print information about what we've found.
	 */
	printf(":");
	if (hs->sc_flags & SCSI_DMA32)
		printf(" 32 bit dma, ");

	switch (hs->sc_sync) {
	case 0:
		printf("async");
		break;

	case (TMOD_SYNC | 0x3e):
		printf("250ns sync");
		break;

	case (TMOD_SYNC | 0x5e):
		printf("375ns sync");
		break;

	case (TMOD_SYNC | 0x7d):
		printf("500ns sync");
		break;

	default:
		panic("scsiattach: unknown sync param 0x%x", hs->sc_sync);
	}

	if ((hd->scsi_hconf & HCONF_PARITY) == 0)
		printf(", no parity");

	printf(", scsi id %d\n", hs->sc_scsiid);

	/*
	 * XXX scale initialization wait according to CPU speed.
	 * Should we do this for all wait?  Should we do this at all?
	 */
	scsi_init_wait *= (cpuspeed / 8);

	/*
	 * Find and attach devices on the SCSI bus.
	 */
	scsi_attach_children(hs);
}

void
scsi_attach_children(sc)
	struct scsi_softc *sc;
{
	struct oscsi_attach_args osa;
	struct scsi_inquiry inqbuf;
	int target, lun;

	/*
	 * Look for devices on the SCSI bus.
	 */

	for (target = 0; target < 8; target++) {
		/* Skip target used by controller. */
		if (target == sc->sc_scsiid)
			continue;

		for (lun = 0; lun < 1 /* XXX */; lun++) {
			bzero(&inqbuf, sizeof(inqbuf));
			if (scsi_probe_device(sc->sc_dev.dv_unit,
			    target, lun, &inqbuf, sizeof(inqbuf))) {
				/*
				 * XXX First command on some tapes
				 * XXX always fails.  (Or, at least,
				 * XXX that's what the old Utah "st"
				 * XXX driver claimed.)
				 */
				bzero(&inqbuf, sizeof(inqbuf));
				if (scsi_probe_device(sc->sc_dev.dv_unit,
				    target, lun, &inqbuf, sizeof(inqbuf)))
					continue;
			}
			
			/*
			 * There is a device here; find a driver
			 * to match it.
			 */
			osa.osa_target = target;
			osa.osa_lun = lun;
			osa.osa_inqbuf = &inqbuf;
			(void)config_found_sm(&sc->sc_dev, &osa,
			    scsi_print, scsisubmatch);
		}
	}
}

int
scsisubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct oscsi_attach_args *osa = aux;

	if (cf->cf_loc[0] != -1 &&
	    cf->cf_loc[0] != osa->osa_target)
		return (0);

	if (cf->cf_loc[1] != -1 &&
	    cf->cf_loc[1] != osa->osa_lun)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, match, aux));
}

int
scsi_print(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct oscsi_attach_args *osa = aux;
	struct scsi_inquiry *inqbuf = osa->osa_inqbuf;
	char vendor[9], product[17], revision[5];

	if (pnp == NULL)
		printf(" targ %d lun %d: ", osa->osa_target, osa->osa_lun);

	bzero(vendor, sizeof(vendor));
	bzero(product, sizeof(product));
	bzero(revision, sizeof(revision));
	switch (inqbuf->version) {
	case 1:
	case 2:
		scsi_str(inqbuf->vendor_id, vendor, sizeof(inqbuf->vendor_id));
		scsi_str(inqbuf->product_id, product,
		    sizeof(inqbuf->product_id));
		scsi_str(inqbuf->rev, revision, sizeof(inqbuf->rev));
		printf("<%s, %s, %s>", vendor, product, revision);
		if (inqbuf->version == 2)
			printf(" (SCSI-2)");
		break;
	default:
		printf("type 0x%x, qual 0x%x, ver %d",
		    inqbuf->type, inqbuf->qual, inqbuf->version);
	}
	if (pnp != NULL)
		printf(" at %s targ %d lun %d",
		    pnp, osa->osa_target, osa->osa_lun);

	return (UNCONF);
}

void
scsireset(unit)
	int unit;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[unit];
	volatile struct scsidevice *hd = hs->sc_regs;
	u_int i;

	if (hs->sc_flags & SCSI_ALIVE)
		scsiabort(-1, hs, hd, "reset");
		
	hd->scsi_id = 0xFF;
	DELAY(100);
	/*
	 * Disable interrupts then reset the FUJI chip.
	 */
	hd->scsi_csr  = 0;
	hd->scsi_sctl = SCTL_DISABLE | SCTL_CTRLRST;
	hd->scsi_scmd = 0;
	hd->scsi_tmod = 0;
	hd->scsi_pctl = 0;
	hd->scsi_temp = 0;
	hd->scsi_tch  = 0;
	hd->scsi_tcm  = 0;
	hd->scsi_tcl  = 0;
	hd->scsi_ints = 0;

	if ((hd->scsi_id & ID_WORD_DMA) == 0)
		hs->sc_flags |= SCSI_DMA32;

	/* Determine Max Synchronous Transfer Rate */
	if (scsi_nosync)
		i = 3;
	else
		i = SCSI_SYNC_XFER(hd->scsi_hconf);
	switch (i) {
		case 0:
			hs->sc_sync = TMOD_SYNC | 0x3e; /* 250 nsecs */
			break;
		case 1:
			hs->sc_sync = TMOD_SYNC | 0x5e; /* 375 nsecs */
			break;
		case 2:
			hs->sc_sync = TMOD_SYNC | 0x7d; /* 500 nsecs */
			break;
		case 3:
			hs->sc_sync = 0;
			break;
		}

	/*
	 * Configure the FUJI chip with its SCSI address, all
	 * interrupts enabled & appropriate parity.
	 */
	i = (~hd->scsi_hconf) & 0x7;
	hs->sc_scsi_addr = 1 << i;
	hd->scsi_bdid = i;
	hs->sc_scsiid = i;
	if (hd->scsi_hconf & HCONF_PARITY)
		hd->scsi_sctl = SCTL_DISABLE | SCTL_ABRT_ENAB |
				SCTL_SEL_ENAB | SCTL_RESEL_ENAB |
				SCTL_INTR_ENAB | SCTL_PARITY_ENAB;
	else
		hd->scsi_sctl = SCTL_DISABLE | SCTL_ABRT_ENAB |
				SCTL_SEL_ENAB | SCTL_RESEL_ENAB |
				SCTL_INTR_ENAB;

	hd->scsi_sctl &=~ SCTL_DISABLE;
	hs->sc_flags |= SCSI_ALIVE;
}

static void
scsierror(hs, hd, ints)
	struct scsi_softc *hs;
	volatile struct scsidevice *hd;
	u_char ints;
{
	char *sep = "";

	printf("%s: ", hs->sc_dev.dv_xname);
	if (ints & INTS_RST) {
		DELAY(100);
		if (hd->scsi_hconf & HCONF_SD)
			printf("spurious RST interrupt");
		else
			printf("hardware error - check fuse");
		sep = ", ";
	}
	if ((ints & INTS_HARD_ERR) || hd->scsi_serr) {
		if (hd->scsi_serr & SERR_SCSI_PAR) {
			printf("%sparity err", sep);
			sep = ", ";
		}
		if (hd->scsi_serr & SERR_SPC_PAR) {
			printf("%sSPC parity err", sep);
			sep = ", ";
		}
		if (hd->scsi_serr & SERR_TC_PAR) {
			printf("%sTC parity err", sep);
			sep = ", ";
		}
		if (hd->scsi_serr & SERR_PHASE_ERR) {
			printf("%sphase err", sep);
			sep = ", ";
		}
		if (hd->scsi_serr & SERR_SHORT_XFR) {
			printf("%ssync short transfer err", sep);
			sep = ", ";
		}
		if (hd->scsi_serr & SERR_OFFSET) {
			printf("%ssync offset error", sep);
			sep = ", ";
		}
	}
	if (ints & INTS_TIMEOUT)
		printf("%sSPC select timeout error", sep);
	if (ints & INTS_SRV_REQ)
		printf("%sspurious SRV_REQ interrupt", sep);
	if (ints & INTS_CMD_DONE)
		printf("%sspurious CMD_DONE interrupt", sep);
	if (ints & INTS_DISCON)
		printf("%sspurious disconnect interrupt", sep);
	if (ints & INTS_RESEL)
		printf("%sspurious reselect interrupt", sep);
	if (ints & INTS_SEL)
		printf("%sspurious select interrupt", sep);
	printf("\n");
}

static int
issue_select(hd, target, our_addr)
	volatile struct scsidevice *hd;
	u_char target, our_addr;
{
	if (hd->scsi_ssts & (SSTS_INITIATOR|SSTS_TARGET|SSTS_BUSY))
		return (1);

	if (hd->scsi_ints & INTS_DISCON)
		hd->scsi_ints = INTS_DISCON;

	hd->scsi_pctl = 0;
	hd->scsi_temp = (1 << target) | our_addr;
	/* select timeout is hardcoded to 2ms */
	hd->scsi_tch = 15;
	hd->scsi_tcm = 32;
	hd->scsi_tcl = 4;

	hd->scsi_scmd = SCMD_SELECT;
	return (0);
}

static int
wait_for_select(hd)
	volatile struct scsidevice *hd;
{
	u_char ints;

	while ((ints = hd->scsi_ints) == 0)
		DELAY(1);
	hd->scsi_ints = ints;
	return (!(hd->scsi_ssts & SSTS_INITIATOR));
}

static int
ixfer_start(hd, len, phase, wait)
	volatile struct scsidevice *hd;
	int len;
	u_char phase;
	int wait;
{

	hd->scsi_tch = len >> 16;
	hd->scsi_tcm = len >> 8;
	hd->scsi_tcl = len;
	hd->scsi_pctl = phase;
	hd->scsi_tmod = 0; /*XXX*/
	hd->scsi_scmd = SCMD_XFR | SCMD_PROG_XFR;

	/* wait for xfer to start or svc_req interrupt */
	while ((hd->scsi_ssts & SSTS_BUSY) == 0) {
		if (hd->scsi_ints || --wait < 0) {
#ifdef DEBUG
			if (scsi_debug)
				printf("ixfer_start fail: i%x, w%d\n",
				       hd->scsi_ints, wait);
#endif
			HIST(ixstart_wait, wait)
			return (0);
		}
		DELAY(1);
	}
	HIST(ixstart_wait, wait)
	return (1);
}

static int
ixfer_out(hd, len, buf)
	volatile struct scsidevice *hd;
	int len;
	u_char *buf;
{
	int wait = scsi_data_wait;

	for (; len > 0; --len) {
		while (hd->scsi_ssts & SSTS_DREG_FULL) {
			if (hd->scsi_ints || --wait < 0) {
#ifdef DEBUG
				if (scsi_debug)
					printf("ixfer_out fail: l%d i%x w%d\n",
					       len, hd->scsi_ints, wait);
#endif
				HIST(ixout_wait, wait)
				return (len);
			}
			DELAY(1);
		}
		hd->scsi_dreg = *buf++;
	}
	HIST(ixout_wait, wait)
	return (0);
}

static void
ixfer_in(hd, len, buf)
	volatile struct scsidevice *hd;
	int len;
	u_char *buf;
{
	int wait = scsi_data_wait;

	for (; len > 0; --len) {
		while (hd->scsi_ssts & SSTS_DREG_EMPTY) {
			if (hd->scsi_ints || --wait < 0) {
				while (! (hd->scsi_ssts & SSTS_DREG_EMPTY)) {
					*buf++ = hd->scsi_dreg;
					--len;
				}
#ifdef DEBUG
				if (scsi_debug)
					printf("ixfer_in fail: l%d i%x w%d\n",
					       len, hd->scsi_ints, wait);
#endif
				HIST(ixin_wait, wait)
				return;
			}
			DELAY(1);
		}
		*buf++ = hd->scsi_dreg;
	}
	HIST(ixin_wait, wait)
}

static int
mxfer_in(hd, len, buf, phase)
	volatile struct scsidevice *hd;
	int len;
	u_char *buf;
	u_char phase;
{
	int wait = scsi_cmd_wait;
	int i;

	hd->scsi_tmod = 0;
	for (i = 0; i < len; ++i) {
		/*
		 * manual says: reset ATN before ACK is sent.
		 */
		if (hd->scsi_psns & PSNS_ATN)
			hd->scsi_scmd = SCMD_RST_ATN;
		/*
		 * wait for the request line (which says the target
		 * wants to give us data).  If the phase changes while
		 * we're waiting, we're done.
		 */
		while ((hd->scsi_psns & PSNS_REQ) == 0) {
			if (--wait < 0) {
				HIST(mxin_wait, wait)
				return (-1);
			}
			if ((hd->scsi_psns & PHASE) != phase ||
			    (hd->scsi_ssts & SSTS_INITIATOR) == 0)
				goto out;

			DELAY(1);
		}
		/*
		 * set ack (which says we're ready for the data, wait for
		 * req to go away (target says data is available), grab the
		 * data, then reset ack (say we've got the data).
		 */
		hd->scsi_pctl = phase;
		hd->scsi_scmd = SCMD_SET_ACK;
		while (hd->scsi_psns & PSNS_REQ) {
			if (--wait < 0) {
				HIST(mxin_wait, wait)
				return (-2);
			}
			DELAY(1);
		}
		*buf++ = hd->scsi_temp;
		hd->scsi_scmd = SCMD_RST_ACK;
	}
out:
	HIST(mxin_wait, wait)
	/*
	 * Wait for manual transfer to finish.
	 * Avoids occasional "unexpected phase" errors in finishxfer
	 * formerly addressed by per-slave delays.
	 */
	wait = scsi_cmd_wait;
	while ((hd->scsi_ssts & SSTS_ACTIVE) == SSTS_INITIATOR) {
		if (--wait < 0)
			break;
		DELAY(1);
	}
	HIST(mxin2_wait, wait)
	return (i);
}

/*
 * SCSI 'immediate' command:  issue a command to some SCSI device
 * and get back an 'immediate' response (i.e., do programmed xfer
 * to get the response data).  'cbuf' is a buffer containing a scsi
 * command of length clen bytes.  'buf' is a buffer of length 'len'
 * bytes for data.  The transfer direction is determined by the device
 * (i.e., by the scsi bus data xfer phase).  If 'len' is zero, the
 * command must supply no data.  'xferphase' is the bus phase the
 * caller expects to happen after the command is issued.  It should
 * be one of DATA_IN_PHASE, DATA_OUT_PHASE or STATUS_PHASE.
 */
static int
scsiicmd(hs, target, cbuf, clen, buf, len, xferphase)
	struct scsi_softc *hs;
	int target;
	u_char *cbuf;
	int clen;
	u_char *buf;
	int len;
	u_char xferphase;
{
	volatile struct scsidevice *hd = hs->sc_regs;
	u_char phase, ints;
	int wait;

	/* select the SCSI bus (it's an error if bus isn't free) */
	if (issue_select(hd, target, hs->sc_scsi_addr))
		return (-1);
	if (wait_for_select(hd))
		return (-1);
	/*
	 * Wait for a phase change (or error) then let the device
	 * sequence us through the various SCSI phases.
	 */
	hs->sc_stat[0] = 0xff;
	hs->sc_msg[0] = 0xff;
	phase = CMD_PHASE;
	while (1) {
		wait = scsi_cmd_wait;
		switch (phase) {

		case CMD_PHASE:
			if (ixfer_start(hd, clen, phase, wait))
				if (ixfer_out(hd, clen, cbuf))
					goto abort;
			phase = xferphase;
			break;

		case DATA_IN_PHASE:
			if (len <= 0)
				goto abort;
			wait = scsi_data_wait;
			if (ixfer_start(hd, len, phase, wait) ||
			    !(hd->scsi_ssts & SSTS_DREG_EMPTY))
				ixfer_in(hd, len, buf);
			phase = STATUS_PHASE;
			break;

		case DATA_OUT_PHASE:
			if (len <= 0)
				goto abort;
			wait = scsi_data_wait;
			if (ixfer_start(hd, len, phase, wait)) {
				if (ixfer_out(hd, len, buf))
					goto abort;
			}
			phase = STATUS_PHASE;
			break;

		case STATUS_PHASE:
			wait = scsi_data_wait;
			if (ixfer_start(hd, sizeof(hs->sc_stat), phase, wait) ||
			    !(hd->scsi_ssts & SSTS_DREG_EMPTY))
				ixfer_in(hd, sizeof(hs->sc_stat), hs->sc_stat);
			phase = MESG_IN_PHASE;
			break;

		case MESG_IN_PHASE:
			if (ixfer_start(hd, sizeof(hs->sc_msg), phase, wait) ||
			    !(hd->scsi_ssts & SSTS_DREG_EMPTY)) {
				ixfer_in(hd, sizeof(hs->sc_msg), hs->sc_msg);
				hd->scsi_scmd = SCMD_RST_ACK;
			}
			phase = BUS_FREE_PHASE;
			break;

		case BUS_FREE_PHASE:
			goto out;

		default:
			printf("%s: unexpected phase %d in icmd from %d\n",
				hs->sc_dev.dv_xname, phase, target);
			goto abort;
		}
		/* wait for last command to complete */
		while ((ints = hd->scsi_ints) == 0) {
			if (--wait < 0) {
				HIST(cxin_wait, wait)
				goto abort;
			}
			DELAY(1);
		}
		HIST(cxin_wait, wait)
		hd->scsi_ints = ints;
		if (ints & INTS_SRV_REQ)
			phase = hd->scsi_psns & PHASE;
		else if (ints & INTS_DISCON)
			goto out;
		else if ((ints & INTS_CMD_DONE) == 0) {
			scsierror(hs, hd, ints);
			goto abort;
		}
	}
abort:
	scsiabort(target, hs, hd, "icmd");
out:
	return (hs->sc_stat[0]);
}

/*
 * Finish SCSI xfer command:  After the completion interrupt from
 * a read/write operation, sequence through the final phases in
 * programmed i/o.  This routine is a lot like scsiicmd except we
 * skip (and don't allow) the select, cmd out and data in/out phases.
 */
static void
finishxfer(hs, hd, target)
	struct scsi_softc *hs;
	volatile struct scsidevice *hd;
	int target;
{
	u_char phase, ints;

	/*
	 * We specified padding xfer so we ended with either a phase
	 * change interrupt (normal case) or an error interrupt (handled
	 * elsewhere).  Reset the board dma logic then try to get the
	 * completion status & command done msg.  The reset confuses
	 * the SPC REQ/ACK logic so we have to do any status/msg input
	 * operations via 'manual xfer'.
	 */
	if (hd->scsi_ssts & SSTS_BUSY) {
		int wait = scsi_cmd_wait;

		/* wait for dma operation to finish */
		while (hd->scsi_ssts & SSTS_BUSY) {
			if (--wait < 0) {
#ifdef DEBUG
				if (scsi_debug)
					printf("finishxfer fail: ssts %x\n",
					       hd->scsi_ssts);
#endif
				HIST(fxfr_wait, wait)
				goto abort;
			}
		}
		HIST(fxfr_wait, wait)
	}
	hd->scsi_scmd |= SCMD_PROG_XFR;
	hd->scsi_sctl |= SCTL_CTRLRST;
	DELAY(2);
	hd->scsi_sctl &=~ SCTL_CTRLRST;
	hd->scsi_hconf = 0;
	/*
	 * The following delay is definitely needed when trying to
	 * write on a write protected disk (in the optical jukebox anyways),
	 * but we shall see if other unexplained machine freezeups
	 * also stop occurring...  A value of 5 seems to work but
	 * 10 seems safer considering the potential consequences.
	 */
	DELAY(10);
	hs->sc_stat[0] = 0xff;
	hs->sc_msg[0] = 0xff;
	hd->scsi_csr = 0;
	hd->scsi_ints = ints = hd->scsi_ints;
	while (1) {
		phase = hd->scsi_psns & PHASE;
		switch (phase) {

		case STATUS_PHASE:
			if (mxfer_in(hd, sizeof(hs->sc_stat),
			    (u_char *)hs->sc_stat, phase) <= 0)
				goto abort;
			break;

		case MESG_IN_PHASE:
			if (mxfer_in(hd, sizeof(hs->sc_msg),
			    (u_char *)hs->sc_msg, phase) < 0)
				goto abort;
			break;

		case BUS_FREE_PHASE:
			return;

		default:
			printf("%s: unexpected phase %d in finishxfer from %d\n",
				hs->sc_dev.dv_xname, phase, target);
			goto abort;
		}
		if ((ints = hd->scsi_ints)) {
			hd->scsi_ints = ints;
			if (ints & INTS_DISCON)
				return;
			else if (ints & ~(INTS_SRV_REQ|INTS_CMD_DONE)) {
				scsierror(hs, hd, ints);
				break;
			}
		}
		if ((hd->scsi_ssts & SSTS_INITIATOR) == 0)
			return;
	}
abort:
	scsiabort(target, hs, hd, "finishxfer");
	hs->sc_stat[0] = 0xfe;
}

int
scsi_test_unit_rdy(ctlr, slave, unit)
	int ctlr, slave, unit;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[ctlr];
	static struct scsi_cdb6 cdb = { CMD_TEST_UNIT_READY };

	cdb.lun = unit;
	return (scsiicmd(hs, slave, (u_char *)&cdb, sizeof(cdb),
	    (u_char *)0, 0, STATUS_PHASE));
}

int
scsi_request_sense(ctlr, slave, unit, buf, len)
	int ctlr, slave, unit;
	u_char *buf;
	u_int len;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[ctlr];
	static struct scsi_cdb6 cdb = { CMD_REQUEST_SENSE };

	cdb.lun = unit;
	cdb.len = len;
	return (scsiicmd(hs, slave, (u_char *)&cdb, sizeof(cdb),
	    buf, len, DATA_IN_PHASE));
}

int
scsi_immed_command(ctlr, slave, unit, cdb, buf, len, rd)
	int ctlr, slave, unit, rd;
	struct scsi_fmt_cdb *cdb;
	u_char *buf;
	u_int len;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[ctlr];

	cdb->cdb[1] |= unit << 5;
	return (scsiicmd(hs, slave, cdb->cdb, cdb->len, buf, len,
			 rd != 0? DATA_IN_PHASE : DATA_OUT_PHASE));
}

/*
 * The following routines are test-and-transfer i/o versions of read/write
 * for things like reading disk labels and writing core dumps.  The
 * routine scsigo should be used for normal data transfers, NOT these
 * routines.
 */
int
scsi_tt_read(ctlr, slave, unit, buf, len, blk, bshift)
	int ctlr, slave, unit;
	u_char *buf;
	u_int len;
	daddr_t blk;
	int bshift;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[ctlr];
	struct scsi_cdb10 cdb;
	int stat;
	int old_wait = scsi_data_wait;

	scsi_data_wait = 300000;
	bzero(&cdb, sizeof(cdb));
	cdb.cmd = CMD_READ_EXT;
	cdb.lun = unit;
	blk >>= bshift;
	cdb.lbah = blk >> 24;
	cdb.lbahm = blk >> 16;
	cdb.lbalm = blk >> 8;
	cdb.lbal = blk;
	cdb.lenh = len >> (8 + DEV_BSHIFT + bshift);
	cdb.lenl = len >> (DEV_BSHIFT + bshift);
	stat = scsiicmd(hs, slave, (u_char *)&cdb, sizeof(cdb),
	    buf, len, DATA_IN_PHASE);
	scsi_data_wait = old_wait;
	return (stat);
}

int
scsi_tt_write(ctlr, slave, unit, buf, len, blk, bshift)
	int ctlr, slave, unit;
	u_char *buf;
	u_int len;
	daddr_t blk;
	int bshift;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[ctlr];
	struct scsi_cdb10 cdb;
	int stat;
	int old_wait = scsi_data_wait;

	scsi_data_wait = 300000;

	bzero(&cdb, sizeof(cdb));
	cdb.cmd = CMD_WRITE_EXT;
	cdb.lun = unit;
	blk >>= bshift;
	cdb.lbah = blk >> 24;
	cdb.lbahm = blk >> 16;
	cdb.lbalm = blk >> 8;
	cdb.lbal = blk;
	cdb.lenh = len >> (8 + DEV_BSHIFT + bshift);
	cdb.lenl = len >> (DEV_BSHIFT + bshift);
	stat = scsiicmd(hs, slave, (u_char *)&cdb, sizeof(cdb),
	    buf, len, DATA_OUT_PHASE);
	scsi_data_wait = old_wait;
	return (stat);
}

int
scsireq(pdev, sq)
	struct device *pdev;
	struct scsiqueue *sq;
{
	struct scsi_softc *hs = (struct scsi_softc *)pdev;
	int s;

	s = splhigh();	/* XXXthorpej */
	TAILQ_INSERT_TAIL(&hs->sc_queue, sq, sq_list);
	splx(s);

	if (hs->sc_queue.tqh_first == sq)
		return (1);

	return (0);
}

int
scsiustart(unit)
	int unit;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[unit];

	hs->sc_dq.dq_chan = DMA0 | DMA1;
	hs->sc_flags |= SCSI_HAVEDMA;
	if (dmareq(&hs->sc_dq))
		return(1);
	return(0);
}

void
scsistart(arg)
	void *arg;
{
	struct scsi_softc *hs = arg;
	struct scsiqueue *sq;

	sq = hs->sc_queue.tqh_first;
	(sq->sq_go)(sq->sq_softc);
}

int
scsigo(ctlr, slave, unit, bp, cdb, pad)
	int ctlr, slave, unit;
	struct buf *bp;
	struct scsi_fmt_cdb *cdb;
	int pad;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[ctlr];
	volatile struct scsidevice *hd = hs->sc_regs;
	int i, dmaflags;
	u_char phase, ints, cmd;

	cdb->cdb[1] |= unit << 5;

	/* select the SCSI bus (it's an error if bus isn't free) */
	if (issue_select(hd, slave, hs->sc_scsi_addr) || wait_for_select(hd)) {
		if (hs->sc_flags & SCSI_HAVEDMA) {
			hs->sc_flags &=~ SCSI_HAVEDMA;
			dmafree(&hs->sc_dq);
		}
		return (1);
	}
	/*
	 * Wait for a phase change (or error) then let the device
	 * sequence us through command phase (we may have to take
	 * a msg in/out before doing the command).  If the disk has
	 * to do a seek, it may be a long time until we get a change
	 * to data phase so, in the absense of an explicit phase
	 * change, we assume data phase will be coming up and tell
	 * the SPC to start a transfer whenever it does.  We'll get
	 * a service required interrupt later if this assumption is
	 * wrong.  Otherwise we'll get a service required int when
	 * the transfer changes to status phase.
	 */
	phase = CMD_PHASE;
	while (1) {
		int wait = scsi_cmd_wait;

		switch (phase) {

		case CMD_PHASE:
			if (ixfer_start(hd, cdb->len, phase, wait))
				if (ixfer_out(hd, cdb->len, cdb->cdb))
					goto abort;
			break;

		case MESG_IN_PHASE:
			if (ixfer_start(hd, sizeof(hs->sc_msg), phase, wait)||
			    !(hd->scsi_ssts & SSTS_DREG_EMPTY)) {
				ixfer_in(hd, sizeof(hs->sc_msg), hs->sc_msg);
				hd->scsi_scmd = SCMD_RST_ACK;
			}
			phase = BUS_FREE_PHASE;
			break;

		case DATA_IN_PHASE:
		case DATA_OUT_PHASE:
			goto out;

		default:
			printf("%s: unexpected phase %d in go from %d\n",
				hs->sc_dev.dv_xname, phase, slave);
			goto abort;
		}
		while ((ints = hd->scsi_ints) == 0) {
			if (--wait < 0) {
				HIST(sgo_wait, wait)
				goto abort;
			}
			DELAY(1);
		}
		HIST(sgo_wait, wait)
		hd->scsi_ints = ints;
		if (ints & INTS_SRV_REQ)
			phase = hd->scsi_psns & PHASE;
		else if (ints & INTS_CMD_DONE)
			goto out;
		else {
			scsierror(hs, hd, ints);
			goto abort;
		}
	}
out:
	/*
	 * Reset the card dma logic, setup the dma channel then
	 * get the dio part of the card set for a dma xfer.
	 */
	hd->scsi_hconf = 0;
	cmd = CSR_IE;
	dmaflags = DMAGO_NOINT;
	if (scsi_pridma)
		dmaflags |= DMAGO_PRI;
	if (bp->b_flags & B_READ)
		dmaflags |= DMAGO_READ;
	if ((hs->sc_flags & SCSI_DMA32) &&
	    ((int)bp->b_un.b_addr & 3) == 0 && (bp->b_bcount & 3) == 0) {
		cmd |= CSR_DMA32;
		dmaflags |= DMAGO_LWORD;
	} else
		dmaflags |= DMAGO_WORD;
	dmago(hs->sc_dq.dq_chan, bp->b_un.b_addr, bp->b_bcount, dmaflags);

	if (bp->b_flags & B_READ) {
		cmd |= CSR_DMAIN;
		phase = DATA_IN_PHASE;
	} else
		phase = DATA_OUT_PHASE;
	/*
	 * DMA enable bits must be set after size and direction bits.
	 */
	hd->scsi_csr = cmd;
	hd->scsi_csr |= (CSR_DE0 << hs->sc_dq.dq_chan);
	/*
	 * Setup the SPC for the transfer.  We don't want to take
	 * first a command complete then a service required interrupt
	 * at the end of the transfer so we try to disable the cmd
	 * complete by setting the transfer counter to more bytes
	 * than we expect.  (XXX - This strategy may have to be
	 * modified to deal with devices that return variable length
	 * blocks, e.g., some tape drives.)
	 */
	cmd = SCMD_XFR;
	i = (unsigned)bp->b_bcount;
	if (pad) {
		cmd |= SCMD_PAD;
		/*
		 * XXX - If we don't do this, the last 2 or 4 bytes
		 * (depending on word/lword DMA) of a read get trashed.
		 * It looks like it is necessary for the DMA to complete
		 * before the SPC goes into "pad mode"???  Note: if we
		 * also do this on a write, the request never completes.
		 */
		if (bp->b_flags & B_READ)
			i += 2;
#ifdef DEBUG
		hs->sc_flags |= SCSI_PAD;
		if (i & 1)
			printf("%s: odd byte count: %d bytes @@ %ld\n",
				hs->sc_dev.dv_xname, i, bp->b_cylin);
#endif
	} else
		i += 4;
	hd->scsi_tch = i >> 16;
	hd->scsi_tcm = i >> 8;
	hd->scsi_tcl = i;
	hd->scsi_pctl = phase;
	hd->scsi_tmod = 0;
	hd->scsi_scmd = cmd;
	hs->sc_flags |= SCSI_IO;
	return (0);
abort:
	scsiabort(slave, hs, hd, "go");
	hs->sc_flags &=~ SCSI_HAVEDMA;
	dmafree(&hs->sc_dq);
	return (1);
}

void
scsidone(arg)
	void *arg;
{
	struct scsi_softc *hs = arg;
	volatile struct scsidevice *hd = hs->sc_regs;

#ifdef DEBUG
	if (scsi_debug)
		printf("%s: done called!\n", hs->sc_dev.dv_xname);
#endif
	/* dma operation is done -- turn off card dma */
	hd->scsi_csr &=~ (CSR_DE1|CSR_DE0);
}

int
scsiintr(arg)
	void *arg;
{
	struct scsi_softc *hs = arg;
	volatile struct scsidevice *hd = hs->sc_regs;
	u_char ints;
	struct scsiqueue *sq;

	if ((hd->scsi_csr & (CSR_IE|CSR_IR)) != (CSR_IE|CSR_IR))
		return (0);

	sq = hs->sc_queue.tqh_first;

	ints = hd->scsi_ints;
	if ((ints & INTS_SRV_REQ) && (hs->sc_flags & SCSI_IO)) {
		/*
		 * this should be the normal i/o completion case.
		 * get the status & cmd complete msg then let the
		 * device driver look at what happened.
		 */
#ifdef DEBUG
		int len = (hd->scsi_tch << 16) | (hd->scsi_tcm << 8) |
			  hd->scsi_tcl;
		if (!(hs->sc_flags & SCSI_PAD))
			len -= 4;
		hs->sc_flags &=~ SCSI_PAD;
#endif
		finishxfer(hs, hd, sq->sq_target);
		hs->sc_flags &=~ (SCSI_IO|SCSI_HAVEDMA);
		dmafree(&hs->sc_dq);
		(sq->sq_intr)(sq->sq_softc, hs->sc_stat[0]);
	} else {
		/* Something unexpected happened -- deal with it. */
		hd->scsi_ints = ints;
		hd->scsi_csr = 0;
		scsierror(hs, hd, ints);
		scsiabort(sq->sq_target, hs, hd, "intr");
		if (hs->sc_flags & SCSI_IO) {
			hs->sc_flags &=~ (SCSI_IO|SCSI_HAVEDMA);
			dmafree(&hs->sc_dq);
			(sq->sq_intr)(sq->sq_softc, -1);
		}
	}
	return(1);
}

void
scsifree(pdev, sq)
	struct device *pdev;
	struct scsiqueue *sq;
{
	struct scsi_softc *hs = (struct scsi_softc *)pdev;
	int s;

	s = splhigh();	/* XXXthorpej */
	TAILQ_REMOVE(&hs->sc_queue, sq, sq_list);
	splx(s);

	if ((sq = hs->sc_queue.tqh_first) != NULL)
		(*sq->sq_start)(sq->sq_softc);
}

/*
 * (XXX) The following routine is needed for the SCSI tape driver
 * to read odd-size records.
 */

#include "st.h"
#if NST > 0
int
scsi_tt_oddio(ctlr, slave, unit, buf, len, b_flags, freedma)
	int ctlr, slave, unit, b_flags, freedma;
	u_char *buf;
	u_int len;
{
	struct scsi_softc *hs = oscsi_cd.cd_devs[ctlr];
	struct scsi_cdb6 cdb;
	u_char iphase;
	int stat;

#ifdef DEBUG
	if ((freedma && (hs->sc_flags & SCSI_HAVEDMA) == 0) ||
	    (!freedma && (hs->sc_flags & SCSI_HAVEDMA)))
		printf("oddio: freedma (%d) inconsistency (flags=%x)\n",
		       freedma, hs->sc_flags);
#endif
	/*
	 * First free any DMA channel that was allocated.
	 * We can't use DMA to do this transfer.
	 */
	if (freedma) {
		hs->sc_flags &=~ SCSI_HAVEDMA;
		dmafree(&hs->sc_dq);
	}
	/*
	 * Initialize command block
	 */
	bzero(&cdb, sizeof(cdb));
	cdb.lun = unit;
	cdb.lbam = (len >> 16) & 0xff;
	cdb.lbal = (len >> 8) & 0xff;
	cdb.len = len & 0xff;
	if (buf == 0) {
		cdb.cmd = CMD_SPACE;
		cdb.lun |= 0x00;
		len = 0;
		iphase = MESG_IN_PHASE;
	} else if (b_flags & B_READ) {
		cdb.cmd = CMD_READ;
		iphase = DATA_IN_PHASE;
	} else {
		cdb.cmd = CMD_WRITE;
		iphase = DATA_OUT_PHASE;
	}
	/*
	 * Perform command (with very long delays)
	 */
	scsi_delay(30000000);
	stat = scsiicmd(hs, slave, (u_char *)&cdb, sizeof(cdb),
	    buf, len, iphase);
	scsi_delay(0);
	return (stat);
}
#endif

/*
 * Copy a counted string, trimming the trailing space, and turn
 * the result into a C-style string.
 */
void    
scsi_str(src, dst, len)
	char *src, *dst;
	size_t len;
{

	while (src[len - 1] == ' ') {
		if (--len == 0) {
			*dst = '\0';
			return;
		}
	}
	bcopy(src, dst, len);
	dst[len] = '\0';
}

/*
 * Probe for a device at the given ctlr/target/lun, and fill in the inqbuf.
 */
int
scsi_probe_device(ctlr, targ, lun, inqbuf, inqlen)
	int ctlr, targ, lun;
	struct scsi_inquiry *inqbuf;
	int inqlen;
{
	static struct scsi_fmt_cdb inq = {
		6, { CMD_INQUIRY, 0, 0, 0, 0, 0 }
	};
	int i, tries = 10, isrm = 0;

	inq.cdb[4] = inqlen & 0xff;

	scsi_delay(-1);

	/*
	 * See if the unit exists.
	 */
	while ((i = scsi_test_unit_rdy(ctlr, targ, lun)) != 0) {
		if (i == -1 || --tries < 0) {
			if (isrm)
				break;
			/* doesn't exist or not a CCS device */
			goto failed;
		}
		if (i == STS_CHECKCOND) {
			u_char sensebuf[128];
			struct scsi_xsense *sp =
			    (struct scsi_xsense *)sensebuf;

			scsi_request_sense(ctlr, targ, lun, (u_char *)sensebuf,
			    sizeof(sensebuf));
			if (sp->class == 7) {
				switch (sp->key) {
				/*
				 * Not ready -- might be removable media
				 * device with no media.  Assume as much,
				 * if it really isn't, the inquiry command
				 * below will fail.
				 */
				case 2:
					isrm = 1;
					break;
				/* drive doing an RTZ -- give it a while */
				case 6:
					delay(1000000);
					break;
				default:
					break;
				}
			}
		}
		delay(1000);
	}

	/*
	 * Find out about the device.
	 */
	if (scsi_immed_command(ctlr, targ, lun, &inq, (u_char *)inqbuf,
	    inqlen, B_READ))
		goto failed;

	scsi_delay(0);
	return (0);

 failed:
	scsi_delay(0);
	return (-1);
}
@


1.16
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.15 2003/06/02 23:27:45 millert Exp $	*/
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.14 2003/04/03 17:01:29 millert Exp $	*/
d953 1
a953 1
	 * also stop occuring...  A value of 5 seems to work but
@


1.14
log
@HP 9000/xxx not HP9000/xxx; from Paul Weissmann
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.13 2002/12/25 20:05:35 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@Do not force DEBUG to be defined here. hp300 is already slow enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.12 2002/07/10 20:30:14 jsyn Exp $	*/
d44 1
a44 1
 * HP9000/3xx 98658 SCSI host adaptor driver.
@


1.12
log
@'sez' is not an english word; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.11 2002/03/14 01:26:30 millert Exp $	*/
a42 3
#ifndef DEBUG
#define DEBUG
#endif
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.10 1997/07/06 08:01:55 downsj Exp $	*/
d739 1
a739 1
		 * manual sez: reset ATN before ACK is sent.
@


1.10
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.9 1997/07/02 12:21:46 downsj Exp $	*/
d99 22
a120 22
static void	scsiabort __P((int, struct scsi_softc *,
				volatile struct scsidevice *, char *));
static void	scsierror __P((struct scsi_softc *,
				volatile struct scsidevice *, u_char));
static int	issue_select __P((volatile struct scsidevice *,
				u_char, u_char));
static int	wait_for_select __P((volatile struct scsidevice *));
static int	ixfer_start __P((volatile struct scsidevice *,
				int, u_char, int));
static int	ixfer_out __P((volatile struct scsidevice *, int, u_char *));
static void	ixfer_in __P((volatile struct scsidevice *, int, u_char *));
static int	mxfer_in __P((volatile struct scsidevice *,
				int, u_char *, u_char));
static int	scsiicmd __P((struct scsi_softc *, int, u_char *, int,
				u_char *, int, u_char));
static void	finishxfer __P((struct scsi_softc *,
				volatile struct scsidevice *, int));

int	scsimatch __P((struct device *, void *, void *));
void	scsiattach __P((struct device *, struct device *, void *));
void	scsi_attach_children __P((struct scsi_softc *));
int	scsisubmatch __P((struct device *, void *, void *));
@


1.10.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.10 1997/07/06 08:01:55 downsj Exp $	*/
d99 22
a120 22
static void	scsiabort(int, struct scsi_softc *,
				volatile struct scsidevice *, char *);
static void	scsierror(struct scsi_softc *,
				volatile struct scsidevice *, u_char);
static int	issue_select(volatile struct scsidevice *,
				u_char, u_char);
static int	wait_for_select(volatile struct scsidevice *);
static int	ixfer_start(volatile struct scsidevice *,
				int, u_char, int);
static int	ixfer_out(volatile struct scsidevice *, int, u_char *);
static void	ixfer_in(volatile struct scsidevice *, int, u_char *);
static int	mxfer_in(volatile struct scsidevice *,
				int, u_char *, u_char);
static int	scsiicmd(struct scsi_softc *, int, u_char *, int,
				u_char *, int, u_char);
static void	finishxfer(struct scsi_softc *,
				volatile struct scsidevice *, int);

int	scsimatch(struct device *, void *, void *);
void	scsiattach(struct device *, struct device *, void *);
void	scsi_attach_children(struct scsi_softc *);
int	scsisubmatch(struct device *, void *, void *);
@


1.10.22.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.10.22.1 2002/06/11 03:35:19 art Exp $	*/
d739 1
a739 1
		 * manual says: reset ATN before ACK is sent.
@


1.10.22.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 3
d47 1
a47 1
 * HP 9000/3xx 98658 SCSI host adaptor driver.
@


1.10.12.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 22
a120 22
static void	scsiabort(int, struct scsi_softc *,
				volatile struct scsidevice *, char *);
static void	scsierror(struct scsi_softc *,
				volatile struct scsidevice *, u_char);
static int	issue_select(volatile struct scsidevice *,
				u_char, u_char);
static int	wait_for_select(volatile struct scsidevice *);
static int	ixfer_start(volatile struct scsidevice *,
				int, u_char, int);
static int	ixfer_out(volatile struct scsidevice *, int, u_char *);
static void	ixfer_in(volatile struct scsidevice *, int, u_char *);
static int	mxfer_in(volatile struct scsidevice *,
				int, u_char *, u_char);
static int	scsiicmd(struct scsi_softc *, int, u_char *, int,
				u_char *, int, u_char);
static void	finishxfer(struct scsi_softc *,
				volatile struct scsidevice *, int);

int	scsimatch(struct device *, void *, void *);
void	scsiattach(struct device *, struct device *, void *);
void	scsi_attach_children(struct scsi_softc *);
int	scsisubmatch(struct device *, void *, void *);
@


1.10.12.2
log
@Sync the SMP branch with 3.3
@
text
@d43 3
d739 1
a739 1
		 * manual says: reset ATN before ACK is sent.
@


1.10.12.3
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.10.12.2 2003/03/27 23:19:20 niklas Exp $	*/
d44 1
a44 1
 * HP 9000/3xx 98658 SCSI host adaptor driver.
@


1.10.12.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.10.12.3 2003/05/13 19:41:02 ho Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.12.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d953 1
a953 1
	 * also stop occurring...  A value of 5 seems to work but
@


1.9
log
@Adjust selection time out (all of my devices still work, does everyone elses?)
@
text
@d1 2
a2 2
/*	$OpenBSD: scsi.c,v 1.8 1997/04/16 11:56:14 downsj Exp $	*/
/*	$NetBSD: scsi.c,v 1.19 1997/04/14 02:33:22 thorpej Exp $	*/
d58 1
d322 1
a322 2
	(void) intr_establish(scsiintr, hs, ipl, IPL_BIO);
	dmacomputeipl();
@


1.8
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi.c,v 1.7 1997/03/11 09:54:09 downsj Exp $	*/
d617 1
a617 1
	hd->scsi_tch = 0;
@


1.7
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD: scsi.c,v 1.6 1997/02/03 04:47:44 downsj Exp $	*/
/*	$NetBSD: scsi.c,v 1.16 1997/03/10 08:37:31 thorpej Exp $	*/
d55 1
d57 1
d65 1
a66 3
#include <hp300/dev/scsireg.h>

#include <hp300/hp300/isr.h>
d98 17
a114 3
void	scsidone __P((void *));
void	scsistart __P((void *));
int	scsiintr __P((void *));
d118 2
a128 3
int	scsisubmatch __P((struct device *, void *, void *));
void	scsi_attach_children __P((struct scsi_softc *));

d161 2
a162 2
	register struct scsi_softc *hs;
	volatile register struct scsidevice *hd;
d321 1
a321 1
	(void) isrlink(scsiintr, hs, ipl, ISRPRI_BIO);
d479 1
a479 1
	volatile register struct scsidevice *hd = hs->sc_regs;
d547 2
a548 2
	register struct scsi_softc *hs;
	volatile register struct scsidevice *hd;
a550 1
	int unit = hs->sc_dev.dv_unit;
d605 1
a605 1
	volatile register struct scsidevice *hd;
d627 1
a627 1
	volatile register struct scsidevice *hd;
d639 1
a639 1
	volatile register struct scsidevice *hd;
d642 1
a642 1
	register int wait;
d671 1
a671 1
	volatile register struct scsidevice *hd;
d673 1
a673 1
	register u_char *buf;
d675 1
a675 1
	register int wait = scsi_data_wait;
d698 1
a698 1
	volatile register struct scsidevice *hd;
d700 1
a700 1
	register u_char *buf;
d702 1
a702 1
	register int wait = scsi_data_wait;
d728 4
a731 4
	volatile register struct scsidevice *hd;
	register int len;
	register u_char *buf;
	register u_char phase;
d733 2
a734 2
	register int wait = scsi_cmd_wait;
	register int i;
d814 1
a814 1
	volatile register struct scsidevice *hd = hs->sc_regs;
d816 1
a816 1
	register int wait;
d921 1
a921 1
	volatile register struct scsidevice *hd;
d973 2
a974 2
			if (mxfer_in(hd, sizeof(hs->sc_stat), hs->sc_stat,
				     phase) <= 0)
d979 2
a980 2
			if (mxfer_in(hd, sizeof(hs->sc_msg), hs->sc_msg,
				     phase) < 0)
d992 1
a992 1
		if (ints = hd->scsi_ints) {
d1017 2
a1018 2
	return (scsiicmd(hs, slave, &cdb, sizeof(cdb), (u_char *)0, 0,
			 STATUS_PHASE));
d1025 1
a1025 1
	unsigned len;
d1032 2
a1033 1
	return (scsiicmd(hs, slave, &cdb, sizeof(cdb), buf, len, DATA_IN_PHASE));
d1080 2
a1081 1
	stat = scsiicmd(hs, slave, &cdb, sizeof(cdb), buf, len, DATA_IN_PHASE);
d1111 2
a1112 1
	stat = scsiicmd(hs, slave, &cdb, sizeof(cdb), buf, len, DATA_OUT_PHASE);
d1167 1
a1167 1
	volatile register struct scsidevice *hd = hs->sc_regs;
d1195 1
a1195 1
		register int wait = scsi_cmd_wait;
d1296 1
a1296 1
			printf("%s: odd byte count: %d bytes @@ %d\n",
d1321 1
a1321 1
	volatile register struct scsidevice *hd = hs->sc_regs;
d1335 4
a1338 5
	register struct scsi_softc *hs = arg;
	volatile register struct scsidevice *hd = hs->sc_regs;
	register u_char ints;
	register struct scsiqueue *sq;
	int unit = hs->sc_dev.dv_unit;
d1413 2
a1414 2
	if (freedma && (hs->sc_flags & SCSI_HAVEDMA) == 0 ||
	    !freedma && (hs->sc_flags & SCSI_HAVEDMA))
d1424 1
a1424 1
		dmafree(hs->sc_dq);
d1450 2
a1451 1
	stat = scsiicmd(hs, slave, &cdb, sizeof(cdb), buf, len, iphase);
d1487 1
a1487 1
		6, CMD_INQUIRY, 0, 0, 0, 0, 0
d1510 1
a1510 1
			scsi_request_sense(ctlr, targ, lun, sensebuf,
@


1.6
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: scsi.c,v 1.5 1997/01/12 15:13:01 downsj Exp $	*/
/*	$NetBSD: scsi.c,v 1.15 1997/01/30 09:08:55 thorpej Exp $	*/
d302 2
@


1.5
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: scsi.c,v 1.13 1996/12/09 03:16:26 thorpej Exp $	*/
d5 1
a48 2
#include "scsi.h"
#if NSCSI > 0
d53 1
d57 6
a62 1
#include <hp300/dev/device.h>
a64 1
#include <hp300/dev/dmavar.h>
d68 22
d98 6
a103 2
extern void _insque();
extern void _remque();
d105 6
a110 6
int	scsimatch(), scsigo(), scsixfer();
void	scsiattach(), scsistart(), scsidone(), scsifree(), scsireset();
int	scsiintr __P((void *));
struct	driver scsidriver = {
	scsimatch, scsiattach, "scsi", (int (*)())scsistart, scsigo, scsiintr,
	(int (*)())scsidone,
d113 2
a114 1
struct	scsi_softc scsi_softc[NSCSI];
d157 1
a157 1
	printf("%s: ", hs->sc_hc->hp_xname);
d216 1
a216 1
			hs->sc_hc->hp_xname, hd->scsi_psns, hd->scsi_ssts);
d257 11
a267 19
scsimatch(hc)
	register struct hp_ctlr *hc;
{
	register struct scsi_softc *hs = &scsi_softc[hc->hp_unit];
	register struct scsidevice *hd = (struct scsidevice *)hc->hp_addr;
	struct hp_hw *hw = hc->hp_args;

	/*
	 * This is probably a little redundant, but what the heck.
	 */
	switch (hw->hw_id) {
	case 7:
	case 7+32:
	case 7+64:
	case 7+96:
		if ((hd->scsi_id & ID_MASK) != SCSI_ID)
			return (0);

		hc->hp_ipl = SCSI_IPL(hd->scsi_csr);
a268 1
		/* NOTREACHED */
d275 27
a301 5
scsiattach(hc)
	struct hp_ctlr *hc;
{
	register struct scsi_softc *hs = &scsi_softc[hc->hp_unit];
	register struct scsidevice *hd = (struct scsidevice *)hc->hp_addr;
d303 1
a303 4
	hs->sc_hc = hc;
	hs->sc_dq.dq_unit = hc->hp_unit;
	hs->sc_dq.dq_driver = &scsidriver;
	hs->sc_sq.dq_forw = hs->sc_sq.dq_back = &hs->sc_sq;
d306 1
a306 1
	(void) isrlink(scsiintr, hs, hc->hp_ipl, ISRPRI_BIO);
d310 1
a310 1
	scsireset(hc->hp_unit);
d350 107
d461 1
a461 1
	register int unit;
d463 2
a464 3
	register struct scsi_softc *hs = &scsi_softc[unit];
	volatile register struct scsidevice *hd =
				(struct scsidevice *)hs->sc_hc->hp_addr;
d536 1
a536 1
	int unit = hs->sc_hc->hp_unit;
d539 1
a539 1
	printf("%s: ", hs->sc_hc->hp_xname);
d800 1
a800 2
	volatile register struct scsidevice *hd =
				(struct scsidevice *)hs->sc_hc->hp_addr;
d870 1
a870 1
				hs->sc_hc->hp_xname, phase, target);
d975 1
a975 1
				hs->sc_hc->hp_xname, phase, target);
d999 1
a999 1
	register struct scsi_softc *hs = &scsi_softc[ctlr];
d1013 1
a1013 1
	register struct scsi_softc *hs = &scsi_softc[ctlr];
d1028 1
a1028 1
	register struct scsi_softc *hs = &scsi_softc[ctlr];
d1049 1
a1049 1
	register struct scsi_softc *hs = &scsi_softc[ctlr];
d1078 1
a1078 1
	register struct scsi_softc *hs = &scsi_softc[ctlr];
d1101 13
a1113 4
scsireq(dq)
	register struct devqueue *dq;
{
	register struct devqueue *hq;
d1115 1
a1115 5
	hq = &scsi_softc[dq->dq_ctlr].sc_sq;
	insque(dq, hq->dq_back);
	if (dq->dq_back == hq)
		return(1);
	return(0);
d1122 1
a1122 1
	register struct scsi_softc *hs = &scsi_softc[unit];
d1124 1
a1124 1
	hs->sc_dq.dq_ctlr = DMA0 | DMA1;
d1132 2
a1133 2
scsistart(unit)
	int unit;
d1135 5
a1139 4
	register struct devqueue *dq;
	
	dq = scsi_softc[unit].sc_sq.dq_forw;
	(dq->dq_driver->d_go)(dq->dq_unit);
d1149 2
a1150 3
	register struct scsi_softc *hs = &scsi_softc[ctlr];
	volatile register struct scsidevice *hd =
				(struct scsidevice *)hs->sc_hc->hp_addr;
d1203 1
a1203 1
				hs->sc_hc->hp_xname, phase, slave);
d1242 1
a1242 1
	dmago(hs->sc_dq.dq_ctlr, bp->b_un.b_addr, bp->b_bcount, dmaflags);
d1253 1
a1253 1
	hd->scsi_csr |= (CSR_DE0 << hs->sc_dq.dq_ctlr);
d1280 1
a1280 1
				hs->sc_hc->hp_xname, i, bp->b_cylin);
d1300 2
a1301 2
scsidone(unit)
	register int unit;
d1303 2
a1304 2
	volatile register struct scsidevice *hd =
			(struct scsidevice *)scsi_softc[unit].sc_hc->hp_addr;
d1308 1
a1308 1
		printf("%s: done called!\n", scsi_softc[unit].sc_hc->hp_xname);
d1319 1
a1319 2
	volatile register struct scsidevice *hd =
				(struct scsidevice *)hs->sc_hc->hp_addr;
d1321 2
a1322 2
	register struct devqueue *dq;
	int unit = hs->sc_hc->hp_unit;
d1327 2
d1343 1
a1343 2
		dq = hs->sc_sq.dq_forw;
		finishxfer(hs, hd, dq->dq_slave);
d1346 1
a1346 1
		(dq->dq_driver->d_intr)(dq->dq_softc, hs->sc_stat[0]);
d1352 1
a1352 1
		scsiabort(dq->dq_slave, hs, hd, "intr");
d1356 1
a1356 2
			dq = hs->sc_sq.dq_forw;
			(dq->dq_driver->d_intr)(dq->dq_softc, -1);
d1363 10
a1372 4
scsifree(dq)
	register struct devqueue *dq;
{
	register struct devqueue *hq;
d1374 2
a1375 4
	hq = &scsi_softc[dq->dq_ctlr].sc_sq;
	remque(dq);
	if ((dq = hq->dq_forw) != hq)
		(dq->dq_driver->d_start)(dq->dq_unit);
d1391 1
a1391 1
	register struct scsi_softc *hs = &scsi_softc[ctlr];
d1459 73
a1531 1
#endif
@


1.4
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: scsi.c,v 1.10 1996/05/18 23:57:03 thorpej Exp $	*/
a71 1
extern void isrlink();
d265 2
a266 1
	isrlink(scsiintr, hs, hc->hp_ipl, ISRPRI_BIO);
@


1.3
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: scsi.c,v 1.8 1996/02/14 02:44:59 thorpej Exp $	*/
d67 2
a68 2
#define	SCSI_CMD_WAIT	1000	/* wait per step of 'immediate' cmds */
#define	SCSI_DATA_WAIT	1000	/* wait per data in/out step */
d115 2
a116 1
scsiabort(hs, hd, where)
d126 5
a130 3
	printf("%s: abort from %s: phase=0x%x, ssts=0x%x, ints=0x%x\n",
		hs->sc_hc->hp_xname, where, hd->scsi_psns, hd->scsi_ssts,
		hd->scsi_ints);
d189 1
a189 1
		DELAY(1);
d307 1
a307 1
	scsi_init_wait *= cpuspeed;
d320 1
a320 1
		scsiabort(hs, hd, "reset");
d746 1
a746 1
	scsiabort(hs, hd, "icmd");
d792 1
a792 1
	DELAY(1);
d844 1
a844 1
	scsiabort(hs, hd, "finishxfer");
d1141 1
a1141 1
	scsiabort(hs, hd, "go");
d1200 1
a1200 1
		scsiabort(hs, hd, "intr");
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: scsi.c,v 1.7 1995/12/02 18:22:12 thorpej Exp $	*/
d75 1
a75 1
int	scsimatch(), scsigo(), scsiintr(), scsixfer();
d77 1
a83 1
struct	isr scsi_isr[NSCSI];
d260 5
a264 4
	scsi_isr[hc->hp_unit].isr_intr = scsiintr;
	scsi_isr[hc->hp_unit].isr_ipl = hc->hp_ipl;
	scsi_isr[hc->hp_unit].isr_arg = hc->hp_unit;
	isrlink(&scsi_isr[hc->hp_unit]);
d1160 2
a1161 2
scsiintr(unit)
	register int unit;
d1163 1
a1163 1
	register struct scsi_softc *hs = &scsi_softc[unit];
d1168 1
d1191 1
a1191 1
		(dq->dq_driver->d_intr)(dq->dq_unit, hs->sc_stat[0]);
d1202 1
a1202 1
			(dq->dq_driver->d_intr)(dq->dq_unit, -1);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: scsi.c,v 1.5.2.1 1995/10/16 09:01:39 thorpej Exp $	*/
d75 2
a76 2
int	scsiinit(), scsigo(), scsiintr(), scsixfer();
void	scsistart(), scsidone(), scsifree(), scsireset();
d78 1
a78 1
	scsiinit, "scsi", (int (*)())scsistart, scsigo, scsiintr,
d125 2
a126 2
	printf("scsi%d: abort from %s: phase=0x%x, ssts=0x%x, ints=0x%x\n",
		hs->sc_hc->hp_unit, where, hd->scsi_psns, hd->scsi_ssts,
d181 2
a182 2
		printf("scsi%d: abort failed.  phase=0x%x, ssts=0x%x\n",
			hs->sc_hc->hp_unit, hd->scsi_psns, hd->scsi_ssts);
d223 1
a223 1
scsiinit(hc)
d228 28
a255 4
	
	if ((hd->scsi_id & ID_MASK) != SCSI_ID)
		return(0);
	hc->hp_ipl = SCSI_IPL(hd->scsi_csr);
d265 34
a303 1
	return(1);
a317 2
	printf("scsi%d: ", unit);

d334 1
a334 1
	if ((hd->scsi_id & ID_WORD_DMA) == 0) {
a335 2
		printf("32 bit dma, ");
	}
a344 1
			printf("250ns sync");
a347 1
			printf("375ns sync");
a350 1
			printf("500ns sync");
a353 1
			printf("async");
d364 1
d369 1
a369 1
	else {
d373 1
a373 2
		printf(", no parity");
	}
a374 2

	printf(", scsi id %d\n", i);
d387 1
a387 1
	printf("scsi%d: ", unit);
d718 2
a719 2
			printf("scsi%d: unexpected phase %d in icmd from %d\n",
				hs->sc_hc->hp_unit, phase, target);
d823 2
a824 2
			printf("scsi%d: unexpected phase %d in finishxfer from %d\n",
				hs->sc_hc->hp_unit, phase, target);
d1046 2
a1047 2
			printf("scsi%d: unexpected phase %d in go from %d\n",
				hs->sc_hc->hp_unit, phase, slave);
d1123 2
a1124 2
			printf("scsi%d: odd byte count: %d bytes @@ %d\n",
				ctlr, i, bp->b_cylin);
d1152 1
a1152 1
		printf("scsi%d: done called!\n", unit);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
