head	1.9;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	UBC_SYNC_A:1.9
	UBC_SYNC_B:1.9
	SMP:1.9.0.2
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	97.02.03.08.11.56;	author downsj;	state dead;
branches;
next	1.8;

1.8
date	97.02.03.04.47.42;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.01.12.15.12.58;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.06.23.11.47.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.25.06.36.52;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.21.13.41;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.20.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@rd -> hd
@
text
@/*	$OpenBSD: rd.c,v 1.8 1997/02/03 04:47:42 downsj Exp $	*/
/*	$NetBSD: rd.c,v 1.27 1997/01/30 09:14:17 thorpej Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: rd.c 1.44 92/12/26$
 *
 *	@@(#)rd.c	8.2 (Berkeley) 5/19/94
 */

/*
 * CS80/SS80 disk driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/device.h>
#include <sys/conf.h>

#include <hp300/dev/hpibvar.h>

#include <hp300/dev/rdreg.h>
#include <hp300/dev/rdvar.h>

#ifdef USELEDS
#include <hp300/hp300/led.h>
#endif

#include <vm/vm_param.h>
#include <vm/lock.h>
#include <vm/vm_prot.h>
#include <vm/pmap.h>

int	rdmatch __P((struct device *, void *, void *));
void	rdattach __P((struct device *, struct device *, void *));

struct cfattach rd_ca = {
	sizeof(struct rd_softc), rdmatch, rdattach
};

struct cfdriver rd_cd = {
	NULL, "rd", DV_DISK
};

int	rdident __P((struct device *, struct rd_softc *,
	    struct hpibbus_attach_args *));
void	rdreset __P((struct rd_softc *));
void	rdustart __P((struct rd_softc *));
int	rdgetinfo __P((dev_t));
void	rdrestart __P((void *));
struct buf *rdfinish __P((struct rd_softc *, struct buf *));

void	rdstart __P((void *));
void	rdintr __P((void *));
void	rdgo __P((void *));

bdev_decl(rd);
cdev_decl(rd);

int	rderrthresh = RDRETRY-1;	/* when to start reporting errors */

#ifdef DEBUG
/* error message tables */
char *err_reject[] = {
	0, 0,
	"channel parity error",		/* 0x2000 */
	0, 0,
	"illegal opcode",		/* 0x0400 */
	"module addressing",		/* 0x0200 */
	"address bounds",		/* 0x0100 */
	"parameter bounds",		/* 0x0080 */
	"illegal parameter",		/* 0x0040 */
	"message sequence",		/* 0x0020 */
	0,
	"message length",		/* 0x0008 */
	0, 0, 0
};

char *err_fault[] = {
	0,
	"cross unit",			/* 0x4000 */
	0,
	"controller fault",		/* 0x1000 */
	0, 0,
	"unit fault",			/* 0x0200 */
	0,
	"diagnostic result",		/* 0x0080 */
	0,
	"operator release request",	/* 0x0020 */
	"diagnostic release request",	/* 0x0010 */
	"internal maintenance release request",	/* 0x0008 */
	0,
	"power fail",			/* 0x0002 */
	"retransmit"			/* 0x0001 */
};

char *err_access[] = {
	"illegal parallel operation",	/* 0x8000 */
	"uninitialized media",		/* 0x4000 */
	"no spares available",		/* 0x2000 */
	"not ready",			/* 0x1000 */
	"write protect",		/* 0x0800 */
	"no data found",		/* 0x0400 */
	0, 0,
	"unrecoverable data overflow",	/* 0x0080 */
	"unrecoverable data",		/* 0x0040 */
	0,
	"end of file",			/* 0x0010 */
	"end of volume",		/* 0x0008 */
	0, 0, 0
};

char *err_info[] = {
	"operator release request",	/* 0x8000 */
	"diagnostic release request",	/* 0x4000 */
	"internal maintenance release request",	/* 0x2000 */
	"media wear",			/* 0x1000 */
	"latency induced",		/* 0x0800 */
	0, 0,
	"auto sparing invoked",		/* 0x0100 */
	0,
	"recoverable data overflow",	/* 0x0040 */
	"marginal data",		/* 0x0020 */
	"recoverable data",		/* 0x0010 */
	0,
	"maintenance track overflow",	/* 0x0004 */
	0, 0
};

int	rddebug = 0x80;
#define RDB_FOLLOW	0x01
#define RDB_STATUS	0x02
#define RDB_IDENT	0x04
#define RDB_IO		0x08
#define RDB_ASYNC	0x10
#define RDB_ERROR	0x80
#endif

/*
 * Misc. HW description, indexed by sc_type.
 * Nothing really critical here, could do without it.
 */
struct rdidentinfo rdidentinfo[] = {
	{ RD7946AID,	0,	"7945A",	NRD7945ABPT,
	  NRD7945ATRK,	968,	 108416 },

	{ RD9134DID,	1,	"9134D",	NRD9134DBPT,
	  NRD9134DTRK,	303,	  29088 },

	{ RD9134LID,	1,	"9122S",	NRD9122SBPT,
	  NRD9122STRK,	77,	   1232 },

	{ RD7912PID,	0,	"7912P",	NRD7912PBPT,
	  NRD7912PTRK,	572,	 128128 },

	{ RD7914PID,	0,	"7914P",	NRD7914PBPT,
	  NRD7914PTRK,	1152,	 258048 },

	{ RD7958AID,	0,	"7958A",	NRD7958ABPT,
	  NRD7958ATRK,	1013,	 255276 },

	{ RD7957AID,	0,	"7957A",	NRD7957ABPT,
	  NRD7957ATRK,	1036,	 159544 },

	{ RD7933HID,	0,	"7933H",	NRD7933HBPT,
	  NRD7933HTRK,	1321,	 789958 },

	{ RD9134LID,	1,	"9134L",	NRD9134LBPT,
	  NRD9134LTRK,	973,	  77840 },

	{ RD7936HID,	0,	"7936H",	NRD7936HBPT,
	  NRD7936HTRK,	698,	 600978 },

	{ RD7937HID,	0,	"7937H",	NRD7937HBPT,
	  NRD7937HTRK,	698,	1116102 },

	{ RD7914CTID,	0,	"7914CT",	NRD7914PBPT,
	  NRD7914PTRK,	1152,	 258048 },

	{ RD7946AID,	0,	"7946A",	NRD7945ABPT,
	  NRD7945ATRK,	968,	 108416 },

	{ RD9134LID,	1,	"9122D",	NRD9122SBPT,
	  NRD9122STRK,	77,	   1232 },

	{ RD7957BID,	0,	"7957B",	NRD7957BBPT,
	  NRD7957BTRK,	1269,	 159894 },

	{ RD7958BID,	0,	"7958B",	NRD7958BBPT,
	  NRD7958BTRK,	786,	 297108 },

	{ RD7959BID,	0,	"7959B",	NRD7959BBPT,
	  NRD7959BTRK,	1572,	 594216 },

	{ RD2200AID,	0,	"2200A",	NRD2200ABPT,
	  NRD2200ATRK,	1449,	 654948 },

	{ RD2203AID,	0,	"2203A",	NRD2203ABPT,
	  NRD2203ATRK,	1449,	1309896 }
};
int numrdidentinfo = sizeof(rdidentinfo) / sizeof(rdidentinfo[0]);

int
rdmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct hpibbus_attach_args *ha = aux;

	/*
	 * Set punit if operator specified one in the kernel
	 * configuration file.
	 */
	if (cf->hpibbuscf_punit != HPIBBUS_PUNIT_UNK &&
	    cf->hpibbuscf_punit < HPIB_NPUNITS)
		ha->ha_punit = cf->hpibbuscf_punit;

	if (rdident(parent, NULL, ha) == 0) {
		/*
		 * XXX Some aging HP-IB drives are slow to
		 * XXX respond; give them a chance to catch
		 * XXX up and probe them again.
		 */
		delay(10000);
		ha->ha_id = hpibid(parent->dv_unit, ha->ha_slave);
		return (rdident(parent, NULL, ha));
	}
	return (1);
}

void
rdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct rd_softc *sc = (struct rd_softc *)self;
	struct hpibbus_attach_args *ha = aux;

	if (rdident(parent, sc, ha) == 0) {
		printf("\n%s: didn't respond to describe command!\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Initialize and attach the disk structure.
	 */
	bzero(&sc->sc_dkdev, sizeof(sc->sc_dkdev));
	sc->sc_dkdev.dk_name = sc->sc_dev.dv_xname;
	disk_attach(&sc->sc_dkdev);

	sc->sc_slave = ha->ha_slave;
	sc->sc_punit = ha->ha_punit;

	/* Initialize the hpib job queue entry */
	sc->sc_hq.hq_softc = sc;
	sc->sc_hq.hq_slave = sc->sc_slave;
	sc->sc_hq.hq_start = rdstart;
	sc->sc_hq.hq_go = rdgo;
	sc->sc_hq.hq_intr = rdintr;

	sc->sc_flags = RDF_ALIVE;
#ifdef DEBUG
	/* always report errors */
	if (rddebug & RDB_ERROR)
		rderrthresh = 0;
#endif

	dk_establish(&sc->sc_dkdev, &sc->sc_dev);	/* XXX */
}

int
rdident(parent, sc, ha)
	struct device *parent;
	struct rd_softc *sc;
	struct hpibbus_attach_args *ha;
{
	struct rd_softc rsc;
	struct rd_describe *desc = sc != NULL ? &sc->sc_rddesc : NULL;
	u_char stat, cmd[3];
	char name[7];
	int i, id, n, ctlr, slave;

	ctlr = parent->dv_unit;
	slave = ha->ha_slave;

	/* Verify that we have a CS80 device. */
	if ((ha->ha_id & 0x200) == 0)
		return (0);

	/* Is it one of the disks we support? */
	for (id = 0; id < numrdidentinfo; id++)
		if (ha->ha_id == rdidentinfo[id].ri_hwid)
			break;
	if (id == numrdidentinfo || ha->ha_punit > rdidentinfo[id].ri_maxunum)
		return (0);

	/*
	 * If we're just probing for the device, that's all the
	 * work we need to do.
	 */
	if (sc == NULL)
		return (1);

	/*
	 * Reset device and collect description
	 */
	rdreset(sc);
	cmd[0] = C_SUNIT(ha->ha_punit);
	cmd[1] = C_SVOL(0);
	cmd[2] = C_DESC;
	hpibsend(ctlr, slave, C_CMD, cmd, sizeof(cmd));
	hpibrecv(ctlr, slave, C_EXEC, desc, 37);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));
	bzero(name, sizeof(name)); 
	if (stat == 0) {
		n = desc->d_name;
		for (i = 5; i >= 0; i--) {
			name[i] = (n & 0xf) + '0';
			n >>= 4;
		}
	}

#ifdef DEBUG
	if (rddebug & RDB_IDENT) {
		printf("\n%s: name: %x ('%s')\n",
		    sc->sc_dev.dv_xname, desc->d_name, name);
		printf("  iuw %x, maxxfr %d, ctype %d\n",
		    desc->d_iuw, desc->d_cmaxxfr, desc->d_ctype);
		printf("  utype %d, bps %d, blkbuf %d, burst %d, blktime %d\n",
		    desc->d_utype, desc->d_sectsize,
		    desc->d_blkbuf, desc->d_burstsize, desc->d_blocktime);
		printf("  avxfr %d, ort %d, atp %d, maxint %d, fv %x, rv %x\n",
		    desc->d_uavexfr, desc->d_retry, desc->d_access,
		    desc->d_maxint, desc->d_fvbyte, desc->d_rvbyte);
		printf("  maxcyl/head/sect %d/%d/%d, maxvsect %d, inter %d\n",
		    desc->d_maxcyl, desc->d_maxhead, desc->d_maxsect,
		    desc->d_maxvsectl, desc->d_interleave);
		printf("%s", sc->sc_dev.dv_xname);
	}
#endif

	/*
	 * Take care of a couple of anomolies:
	 * 1. 7945A and 7946A both return same HW id
	 * 2. 9122S and 9134D both return same HW id
	 * 3. 9122D and 9134L both return same HW id
	 */
	switch (ha->ha_id) {
	case RD7946AID:
		if (bcmp(name, "079450", 6) == 0)
			id = RD7945A;
		else
			id = RD7946A;
		break;

	case RD9134LID:
		if (bcmp(name, "091340", 6) == 0)
			id = RD9134L;
		else
			id = RD9122D;
		break;

	case RD9134DID:
		if (bcmp(name, "091220", 6) == 0)
			id = RD9122S;
		else
			id = RD9134D;
		break;
	}

	sc->sc_type = id;

	/*
	 * XXX We use DEV_BSIZE instead of the sector size value pulled
	 * XXX off the driver because all of this code assumes 512 byte
	 * XXX blocks.  ICK!
	 */
	printf(": %s\n", rdidentinfo[id].ri_desc);
	printf("%s: %d cylinders, %d heads, %d blocks, %d bytes/block\n",
	    sc->sc_dev.dv_xname, rdidentinfo[id].ri_ncyl,
	    rdidentinfo[id].ri_ntpc, rdidentinfo[id].ri_nblocks,
	    DEV_BSIZE);

	return (1);
}

void
rdreset(rs)
	register struct rd_softc *rs;
{
	int ctlr = rs->sc_dev.dv_parent->dv_unit;
	int slave = rs->sc_slave;
	u_char stat;

	rs->sc_clear.c_unit = C_SUNIT(rs->sc_punit);
	rs->sc_clear.c_cmd = C_CLEAR;
	hpibsend(ctlr, slave, C_TCMD, &rs->sc_clear, sizeof(rs->sc_clear));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));

	rs->sc_src.c_unit = C_SUNIT(RDCTLR);
	rs->sc_src.c_nop = C_NOP;
	rs->sc_src.c_cmd = C_SREL;
	rs->sc_src.c_param = C_REL;
	hpibsend(ctlr, slave, C_CMD, &rs->sc_src, sizeof(rs->sc_src));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));

	rs->sc_ssmc.c_unit = C_SUNIT(rs->sc_punit);
	rs->sc_ssmc.c_cmd = C_SSM;
	rs->sc_ssmc.c_refm = REF_MASK;
	rs->sc_ssmc.c_fefm = FEF_MASK;
	rs->sc_ssmc.c_aefm = AEF_MASK;
	rs->sc_ssmc.c_iefm = IEF_MASK;
	hpibsend(ctlr, slave, C_CMD, &rs->sc_ssmc, sizeof(rs->sc_ssmc));
	hpibswait(ctlr, slave);
	hpibrecv(ctlr, slave, C_QSTAT, &stat, sizeof(stat));
#ifdef DEBUG
	rs->sc_stats.rdresets++;
#endif
}

/*
 * Read or constuct a disklabel
 */
int
rdgetinfo(dev)
	dev_t dev;
{
	int unit = rdunit(dev);
	struct rd_softc *rs = rd_cd.cd_devs[unit];
	register struct disklabel *lp = rs->sc_dkdev.dk_label;
	register struct partition *pi;
	char *msg, *readdisklabel();

	/*
	 * Set some default values to use while reading the label
	 * or to use if there isn't a label.
	 */
	bzero((caddr_t)lp, sizeof *lp);
	lp->d_type = DTYPE_HPIB;
	lp->d_secsize = DEV_BSIZE;
	lp->d_nsectors = 32;
	lp->d_ntracks = 20;
	lp->d_ncylinders = 1;
	lp->d_secpercyl = 32*20;
	lp->d_npartitions = 3;
	lp->d_partitions[2].p_offset = 0;
	lp->d_partitions[2].p_size = LABELSECTOR+1;

	/*
	 * Now try to read the disklabel
	 */
	msg = readdisklabel(rdlabdev(dev), rdstrategy, lp, NULL);
	if (msg == NULL)
		return(0);

	pi = lp->d_partitions;
	printf("%s: WARNING: %s, ", rs->sc_dev.dv_xname, msg);
#ifdef COMPAT_NOLABEL
	printf("using old default partitioning\n");
	rdmakedisklabel(unit, lp);
#else
	printf("defining `c' partition as entire disk\n");
	pi[2].p_size = rdidentinfo[rs->sc_type].ri_nblocks;
	/* XXX reset other info since readdisklabel screws with it */
	lp->d_npartitions = 3;
	pi[0].p_size = 0;
#endif
	return(0);
}

int
rdopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	register int unit = rdunit(dev);
	register struct rd_softc *rs;
	int error, mask, part;

	if (unit >= rd_cd.cd_ndevs ||
	    (rs = rd_cd.cd_devs[unit]) == NULL ||
	    (rs->sc_flags & RDF_ALIVE) == 0)
		return (ENXIO);

	/*
	 * Wait for any pending opens/closes to complete
	 */
	while (rs->sc_flags & (RDF_OPENING|RDF_CLOSING))
		sleep((caddr_t)rs, PRIBIO);

	/*
	 * On first open, get label and partition info.
	 * We may block reading the label, so be careful
	 * to stop any other opens.
	 */
	if (rs->sc_dkdev.dk_openmask == 0) {
		rs->sc_flags |= RDF_OPENING;
		error = rdgetinfo(dev);
		rs->sc_flags &= ~RDF_OPENING;
		wakeup((caddr_t)rs);
		if (error)
			return(error);
	}

	part = rdpart(dev);
	mask = 1 << part;

	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part > rs->sc_dkdev.dk_label->d_npartitions ||
	     rs->sc_dkdev.dk_label->d_partitions[part].p_fstype == FS_UNUSED))
		return (ENXIO);

	/* Ensure only one open at a time. */
	switch (mode) {
	case S_IFCHR:
		rs->sc_dkdev.dk_copenmask |= mask;
		break;
	case S_IFBLK:
		rs->sc_dkdev.dk_bopenmask |= mask;
		break;
	}
	rs->sc_dkdev.dk_openmask =
	    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;

	return(0);
}

int
rdclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = rdunit(dev);
	struct rd_softc *rs = rd_cd.cd_devs[unit];
	register struct disk *dk = &rs->sc_dkdev;
	int mask, s;

	mask = 1 << rdpart(dev);
	if (mode == S_IFCHR)
		dk->dk_copenmask &= ~mask;
	else
		dk->dk_bopenmask &= ~mask;
	dk->dk_openmask = dk->dk_copenmask | dk->dk_bopenmask;
	/*
	 * On last close, we wait for all activity to cease since
	 * the label/parition info will become invalid.  Since we
	 * might sleep, we must block any opens while we are here.
	 * Note we don't have to about other closes since we know
	 * we are the last one.
	 */
	if (dk->dk_openmask == 0) {
		rs->sc_flags |= RDF_CLOSING;
		s = splbio();
		while (rs->sc_tab.b_active) {
			rs->sc_flags |= RDF_WANTED;
			sleep((caddr_t)&rs->sc_tab, PRIBIO);
		}
		splx(s);
		rs->sc_flags &= ~(RDF_CLOSING|RDF_WLABEL);
		wakeup((caddr_t)rs);
	}
	return(0);
}

void
rdstrategy(bp)
	register struct buf *bp;
{
	int unit = rdunit(bp->b_dev);
	struct rd_softc *rs = rd_cd.cd_devs[unit];
	register struct buf *dp = &rs->sc_tab;
	register struct partition *pinfo;
	register daddr_t bn;
	register int sz, s;
	int offset;

#ifdef DEBUG
	if (rddebug & RDB_FOLLOW)
		printf("rdstrategy(%x): dev %x, bn %x, bcount %x, %c\n",
		       bp, bp->b_dev, bp->b_blkno, bp->b_bcount,
		       (bp->b_flags & B_READ) ? 'R' : 'W');
#endif
	bn = bp->b_blkno;
	sz = howmany(bp->b_bcount, DEV_BSIZE);
	pinfo = &rs->sc_dkdev.dk_label->d_partitions[rdpart(bp->b_dev)];

	/* Don't perform partition translation on RAW_PART. */
	offset = (rdpart(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;

	if (rdpart(bp->b_dev) != RAW_PART) {
		/*
		 * XXX This block of code belongs in
		 * XXX bounds_check_with_label()
		 */

		if (bn < 0 || bn + sz > pinfo->p_size) {
			sz = pinfo->p_size - bn;
			if (sz == 0) {
				bp->b_resid = bp->b_bcount;
				goto done;
			}
			if (sz < 0) {
				bp->b_error = EINVAL;
				goto bad;
			}
			bp->b_bcount = dbtob(sz);
		}
		/*
		 * Check for write to write protected label
		 */
		if (bn + offset <= LABELSECTOR &&
#if LABELSECTOR != 0
		    bn + offset + sz > LABELSECTOR &&
#endif
		    !(bp->b_flags & B_READ) && !(rs->sc_flags & RDF_WLABEL)) {
			bp->b_error = EROFS;
			goto bad;
		}
	}
	bp->b_cylin = bn + offset;
	s = splbio();
	disksort(dp, bp);
	if (dp->b_active == 0) {
		dp->b_active = 1;
		rdustart(rs);
	}
	splx(s);
	return;
bad:
	bp->b_flags |= B_ERROR;
done:
	biodone(bp);
}

/*
 * Called from timeout() when handling maintenance releases
 */
void
rdrestart(arg)
	void *arg;
{
	int s = splbio();
	rdustart((struct rd_softc *)arg);
	splx(s);
}

void
rdustart(rs)
	struct rd_softc *rs;
{
	register struct buf *bp;

	bp = rs->sc_tab.b_actf;
	rs->sc_addr = bp->b_un.b_addr;
	rs->sc_resid = bp->b_bcount;
	if (hpibreq(rs->sc_dev.dv_parent, &rs->sc_hq))
		rdstart(rs);
}

struct buf *
rdfinish(rs, bp)
	register struct rd_softc *rs;
	register struct buf *bp;
{
	register struct buf *dp = &rs->sc_tab;

	dp->b_errcnt = 0;
	dp->b_actf = bp->b_actf;
	bp->b_resid = 0;
	biodone(bp);
	hpibfree(rs->sc_dev.dv_parent, &rs->sc_hq);
	if (dp->b_actf)
		return (dp->b_actf);
	dp->b_active = 0;
	if (rs->sc_flags & RDF_WANTED) {
		rs->sc_flags &= ~RDF_WANTED;
		wakeup((caddr_t)dp);
	}
	return (NULL);
}

void
rdstart(arg)
	void *arg;
{
	struct rd_softc *rs = arg;
	register struct buf *bp = rs->sc_tab.b_actf;
	register int part, ctlr, slave;

	ctlr = rs->sc_dev.dv_parent->dv_unit;
	slave = rs->sc_slave;

again:
#ifdef DEBUG
	if (rddebug & RDB_FOLLOW)
		printf("rdstart(%s): bp %x, %c\n", sc->sc_dev.dv_xname, bp,
		       (bp->b_flags & B_READ) ? 'R' : 'W');
#endif
	part = rdpart(bp->b_dev);
	rs->sc_flags |= RDF_SEEK;
	rs->sc_ioc.c_unit = C_SUNIT(rs->sc_punit);
	rs->sc_ioc.c_volume = C_SVOL(0);
	rs->sc_ioc.c_saddr = C_SADDR;
	rs->sc_ioc.c_hiaddr = 0;
	rs->sc_ioc.c_addr = RDBTOS(bp->b_cylin);
	rs->sc_ioc.c_nop2 = C_NOP;
	rs->sc_ioc.c_slen = C_SLEN;
	rs->sc_ioc.c_len = rs->sc_resid;
	rs->sc_ioc.c_cmd = bp->b_flags & B_READ ? C_READ : C_WRITE;
#ifdef DEBUG
	if (rddebug & RDB_IO)
		printf("rdstart: hpibsend(%x, %x, %x, %x, %x)\n",
		       ctlr, slave, C_CMD,
		       &rs->sc_ioc.c_unit, sizeof(rs->sc_ioc)-2);
#endif
	if (hpibsend(ctlr, slave, C_CMD, &rs->sc_ioc.c_unit,
		     sizeof(rs->sc_ioc)-2) == sizeof(rs->sc_ioc)-2) {

		/* Instrumentation. */
		disk_busy(&rs->sc_dkdev);
		rs->sc_dkdev.dk_seek++;

#ifdef DEBUG
		if (rddebug & RDB_IO)
			printf("rdstart: hpibawait(%x)\n", ctlr);
#endif
		hpibawait(ctlr);
		return;
	}
	/*
	 * Experience has shown that the hpibwait in this hpibsend will
	 * occasionally timeout.  It appears to occur mostly on old 7914
	 * drives with full maintenance tracks.  We should probably
	 * integrate this with the backoff code in rderror.
	 */
#ifdef DEBUG
	if (rddebug & RDB_ERROR)
		printf("%s: rdstart: cmd %x adr %d blk %d len %d ecnt %d\n",
		       rs->sc_dev.dv_xname, rs->sc_ioc.c_cmd, rs->sc_ioc.c_addr,
		       bp->b_blkno, rs->sc_resid, rs->sc_tab.b_errcnt);
	rs->sc_stats.rdretries++;
#endif
	rs->sc_flags &= ~RDF_SEEK;
	rdreset(rs);
	if (rs->sc_tab.b_errcnt++ < RDRETRY)
		goto again;
	printf("%s: rdstart err: cmd 0x%x sect %d blk %d len %d\n",
	       rs->sc_dev.dv_xname, rs->sc_ioc.c_cmd, rs->sc_ioc.c_addr,
	       bp->b_blkno, rs->sc_resid);
	bp->b_flags |= B_ERROR;
	bp->b_error = EIO;
	bp = rdfinish(rs, bp);
	if (bp) {
		rs->sc_addr = bp->b_un.b_addr;
		rs->sc_resid = bp->b_bcount;
		if (hpibreq(rs->sc_dev.dv_parent, &rs->sc_hq))
			goto again;
	}
}

void
rdgo(arg)
	void *arg;
{
	struct rd_softc *rs = arg;
	struct buf *bp = rs->sc_tab.b_actf;
	int rw, ctlr, slave;

	ctlr = rs->sc_dev.dv_parent->dv_unit;
	slave = rs->sc_slave;

	rw = bp->b_flags & B_READ;

	/* Instrumentation. */
	disk_busy(&rs->sc_dkdev);

#ifdef USELEDS
	if (inledcontrol == 0)
		ledcontrol(0, 0, LED_DISK);
#endif
	hpibgo(ctlr, slave, C_EXEC, rs->sc_addr, rs->sc_resid, rw, rw != 0);
}

/* ARGSUSED */
void
rdintr(arg)
	void *arg;
{
	register struct rd_softc *rs = arg;
	int unit = rs->sc_dev.dv_unit;
	register struct buf *bp = rs->sc_tab.b_actf;
	u_char stat = 13;	/* in case hpibrecv fails */
	int rv, restart, ctlr, slave;

	ctlr = rs->sc_dev.dv_parent->dv_unit;
	slave = rs->sc_slave;

#ifdef DEBUG
	if (rddebug & RDB_FOLLOW)
		printf("rdintr(%d): bp %x, %c, flags %x\n", unit, bp,
		       (bp->b_flags & B_READ) ? 'R' : 'W', rs->sc_flags);
	if (bp == NULL) {
		printf("%s: bp == NULL\n", rs->sc_dev.dv_xname);
		return;
	}
#endif
	disk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid));

	if (rs->sc_flags & RDF_SEEK) {
		rs->sc_flags &= ~RDF_SEEK;
		if (hpibustart(ctlr))
			rdgo(rs);
		return;
	}
	if ((rs->sc_flags & RDF_SWAIT) == 0) {
#ifdef DEBUG
		rs->sc_stats.rdpolltries++;
#endif
		if (hpibpptest(ctlr, slave) == 0) {
#ifdef DEBUG
			rs->sc_stats.rdpollwaits++;
#endif

			/* Instrumentation. */
			disk_busy(&rs->sc_dkdev);
			rs->sc_flags |= RDF_SWAIT;
			hpibawait(ctlr);
			return;
		}
	} else
		rs->sc_flags &= ~RDF_SWAIT;
	rv = hpibrecv(ctlr, slave, C_QSTAT, &stat, 1);
	if (rv != 1 || stat) {
#ifdef DEBUG
		if (rddebug & RDB_ERROR)
			printf("rdintr: recv failed or bad stat %d\n", stat);
#endif
		restart = rderror(unit);
#ifdef DEBUG
		rs->sc_stats.rdretries++;
#endif
		if (rs->sc_tab.b_errcnt++ < RDRETRY) {
			if (restart)
				rdstart(rs);
			return;
		}
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
	}
	if (rdfinish(rs, bp))
		rdustart(rs);
}

int
rdstatus(rs)
	register struct rd_softc *rs;
{
	register int c, s;
	u_char stat;
	int rv;

	c = rs->sc_dev.dv_parent->dv_unit;
	s = rs->sc_slave;
	rs->sc_rsc.c_unit = C_SUNIT(rs->sc_punit);
	rs->sc_rsc.c_sram = C_SRAM;
	rs->sc_rsc.c_ram = C_RAM;
	rs->sc_rsc.c_cmd = C_STATUS;
	bzero((caddr_t)&rs->sc_stat, sizeof(rs->sc_stat));
	rv = hpibsend(c, s, C_CMD, &rs->sc_rsc, sizeof(rs->sc_rsc));
	if (rv != sizeof(rs->sc_rsc)) {
#ifdef DEBUG
		if (rddebug & RDB_STATUS)
			printf("rdstatus: send C_CMD failed %d != %d\n",
			       rv, sizeof(rs->sc_rsc));
#endif
		return(1);
	}
	rv = hpibrecv(c, s, C_EXEC, &rs->sc_stat, sizeof(rs->sc_stat));
	if (rv != sizeof(rs->sc_stat)) {
#ifdef DEBUG
		if (rddebug & RDB_STATUS)
			printf("rdstatus: send C_EXEC failed %d != %d\n",
			       rv, sizeof(rs->sc_stat));
#endif
		return(1);
	}
	rv = hpibrecv(c, s, C_QSTAT, &stat, 1);
	if (rv != 1 || stat) {
#ifdef DEBUG
		if (rddebug & RDB_STATUS)
			printf("rdstatus: recv failed %d or bad stat %d\n",
			       rv, stat);
#endif
		return(1);
	}
	return(0);
}

/*
 * Deal with errors.
 * Returns 1 if request should be restarted,
 * 0 if we should just quietly give up.
 */
int
rderror(unit)
	int unit;
{
	struct rd_softc *rs = rd_cd.cd_devs[unit];
	register struct rd_stat *sp;
	struct buf *bp;
	daddr_t hwbn, pbn;

	if (rdstatus(rs)) {
#ifdef DEBUG
		printf("%s: couldn't get status\n", rs->sc_dev.dv_xname);
#endif
		rdreset(rs);
		return(1);
	}
	sp = &rs->sc_stat;
	if (sp->c_fef & FEF_REXMT)
		return(1);
	if (sp->c_fef & FEF_PF) {
		rdreset(rs);
		return(1);
	}
	/*
	 * Unit requests release for internal maintenance.
	 * We just delay awhile and try again later.  Use expontially
	 * increasing backoff ala ethernet drivers since we don't really
	 * know how long the maintenance will take.  With RDWAITC and
	 * RDRETRY as defined, the range is 1 to 32 seconds.
	 */
	if (sp->c_fef & FEF_IMR) {
		extern int hz;
		int rdtimo = RDWAITC << rs->sc_tab.b_errcnt;
#ifdef DEBUG
		printf("%s: internal maintenance, %d second timeout\n",
		       rs->sc_dev.dv_xname, rdtimo);
		rs->sc_stats.rdtimeouts++;
#endif
		hpibfree(rs->sc_dev.dv_parent, &rs->sc_hq);
		timeout(rdrestart, rs, rdtimo * hz);
		return(0);
	}
	/*
	 * Only report error if we have reached the error reporting
	 * threshhold.  By default, this will only report after the
	 * retry limit has been exceeded.
	 */
	if (rs->sc_tab.b_errcnt < rderrthresh)
		return(1);

	/*
	 * First conjure up the block number at which the error occured.
	 * Note that not all errors report a block number, in that case
	 * we just use b_blkno.
 	 */
	bp = rs->sc_tab.b_actf;
	pbn = rs->sc_dkdev.dk_label->d_partitions[rdpart(bp->b_dev)].p_offset;
	if ((sp->c_fef & FEF_CU) || (sp->c_fef & FEF_DR) ||
	    (sp->c_ief & IEF_RRMASK)) {
		hwbn = RDBTOS(pbn + bp->b_blkno);
		pbn = bp->b_blkno;
	} else {
		hwbn = sp->c_blk;
		pbn = RDSTOB(hwbn) - pbn;
	}
	/*
	 * Now output a generic message suitable for badsect.
	 * Note that we don't use harderr cuz it just prints
	 * out b_blkno which is just the beginning block number
	 * of the transfer, not necessary where the error occured.
	 */
	printf("%s%c: hard error sn%d\n", rs->sc_dev.dv_xname,
	    'a'+rdpart(bp->b_dev), pbn);
	/*
	 * Now report the status as returned by the hardware with
	 * attempt at interpretation (unless debugging).
	 */
	printf("%s %s error:", rs->sc_dev.dv_xname,
	    (bp->b_flags & B_READ) ? "read" : "write");
#ifdef DEBUG
	if (rddebug & RDB_ERROR) {
		/* status info */
		printf("\n    volume: %d, unit: %d\n",
		       (sp->c_vu>>4)&0xF, sp->c_vu&0xF);
		rdprinterr("reject", sp->c_ref, err_reject);
		rdprinterr("fault", sp->c_fef, err_fault);
		rdprinterr("access", sp->c_aef, err_access);
		rdprinterr("info", sp->c_ief, err_info);
		printf("    block: %d, P1-P10: ", hwbn);
		printf("%s", hexstr(*(u_int *)&sp->c_raw[0], 8));
		printf("%s", hexstr(*(u_int *)&sp->c_raw[4], 8));
		printf("%s\n", hexstr(*(u_short *)&sp->c_raw[8], 4));
		/* command */
		printf("    ioc: ");
		printf("%s", hexstr(*(u_int *)&rs->sc_ioc.c_pad, 8));
		printf("%s", hexstr(*(u_short *)&rs->sc_ioc.c_hiaddr, 4));
		printf("%s", hexstr(*(u_int *)&rs->sc_ioc.c_addr, 8));
		printf("%s", hexstr(*(u_short *)&rs->sc_ioc.c_nop2, 4));
		printf("%s", hexstr(*(u_int *)&rs->sc_ioc.c_len, 8));
		printf("%s\n", hexstr(*(u_short *)&rs->sc_ioc.c_cmd, 4));
		return(1);
	}
#endif
	printf(" v%d u%d, R0x%x F0x%x A0x%x I0x%x\n",
	       (sp->c_vu>>4)&0xF, sp->c_vu&0xF,
	       sp->c_ref, sp->c_fef, sp->c_aef, sp->c_ief);
	printf("P1-P10: ");
	printf("%s", hexstr(*(u_int *)&sp->c_raw[0], 8));
	printf("%s", hexstr(*(u_int *)&sp->c_raw[4], 8));
	printf("%s\n", hexstr(*(u_short *)&sp->c_raw[8], 4));
	return(1);
}

int
rdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (physio(rdstrategy, NULL, dev, B_READ, minphys, uio));
}

int
rdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (physio(rdstrategy, NULL, dev, B_WRITE, minphys, uio));
}

int
rdioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = rdunit(dev);
	struct rd_softc *sc = rd_cd.cd_devs[unit];
	register struct disklabel *lp = sc->sc_dkdev.dk_label;
	int error, flags;

	switch (cmd) {
	case DIOCGDINFO:
		*(struct disklabel *)data = *lp;
		return (0);

	case DIOCGPART:
		((struct partinfo *)data)->disklab = lp;
		((struct partinfo *)data)->part =
			&lp->d_partitions[rdpart(dev)];
		return (0);

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return (EBADF);
		if (*(int *)data)
			sc->sc_flags |= RDF_WLABEL;
		else
			sc->sc_flags &= ~RDF_WLABEL;
		return (0);

	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);
		return (setdisklabel(lp, (struct disklabel *)data,
				     (sc->sc_flags & RDF_WLABEL) ? 0
				     : sc->sc_dkdev.dk_openmask,
				     (struct cpu_disklabel *)0));

	case DIOCWDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);
		error = setdisklabel(lp, (struct disklabel *)data,
				     (sc->sc_flags & RDF_WLABEL) ? 0
				     : sc->sc_dkdev.dk_openmask,
				     (struct cpu_disklabel *)0);
		if (error)
			return (error);
		flags = sc->sc_flags;
		sc->sc_flags = RDF_ALIVE | RDF_WLABEL;
		error = writedisklabel(rdlabdev(dev), rdstrategy, lp,
				       (struct cpu_disklabel *)0);
		sc->sc_flags = flags;
		return (error);
	}
	return(EINVAL);
}

int
rdsize(dev)
	dev_t dev;
{
	register int unit = rdunit(dev);
	struct rd_softc *rs;
	int psize, didopen = 0;

	if (unit >= rd_cd.cd_ndevs ||
	    (rs = rd_cd.cd_devs[unit]) == NULL ||
	    (rs->sc_flags & RDF_ALIVE) == 0)
		return (-1);

	/*
	 * We get called very early on (via swapconf)
	 * without the device being open so we may need
	 * to handle it here.
	 */
	if (rs->sc_dkdev.dk_openmask == 0) {
		if (rdopen(dev, FREAD|FWRITE, S_IFBLK, NULL))
			return(-1);
		didopen = 1;
	}
	psize = rs->sc_dkdev.dk_label->d_partitions[rdpart(dev)].p_size;
	if (didopen)
		(void) rdclose(dev, FREAD|FWRITE, S_IFBLK, NULL);
	return (psize);
}

#ifdef DEBUG
rdprinterr(str, err, tab)
	char *str;
	short err;
	char *tab[];
{
	register int i;
	int printed;

	if (err == 0)
		return;
	printf("    %s error field:", str, err);
	printed = 0;
	for (i = 0; i < 16; i++)
		if (err & (0x8000 >> i))
			printf("%s%s", printed++ ? " + " : " ", tab[i]);
	printf("\n");
}
#endif

static int rddoingadump;	/* simple mutex */

/*
 * Non-interrupt driven, non-dma dump routine.
 */
int
rddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{
	int sectorsize;		/* size of a disk sector */
	int nsects;		/* number of sectors in partition */
	int sectoff;		/* sector offset of partition */
	int totwrt;		/* total number of sectors left to write */
	int nwrt;		/* current number of sectors to write */
	int unit, part;
	int ctlr, slave;
	struct rd_softc *rs;
	struct disklabel *lp;
	char stat;

	/* Check for recursive dump; if so, punt. */
	if (rddoingadump)
		return (EFAULT);
	rddoingadump = 1;

	/* Decompose unit and partition. */
	unit = rdunit(dev);
	part = rdpart(dev);

	/* Make sure dump device is ok. */
	if (unit >= rd_cd.cd_ndevs ||
	    (rs = rd_cd.cd_devs[unit]) == NULL ||
	    (rs->sc_flags & RDF_ALIVE) == 0)
		return (ENXIO);

	ctlr = rs->sc_dev.dv_parent->dv_unit;
	slave = rs->sc_slave;

	/*
	 * Convert to disk sectors.  Request must be a multiple of size.
	 */
	lp = rs->sc_dkdev.dk_label;
	sectorsize = lp->d_secsize;
	if ((size % sectorsize) != 0)
		return (EFAULT);
	totwrt = size / sectorsize;
	blkno = dbtob(blkno) / sectorsize;	/* blkno in DEV_BSIZE units */

	nsects = lp->d_partitions[part].p_size;
	sectoff = lp->d_partitions[part].p_offset;

	/* Check transfer bounds against partition size. */
	if ((blkno < 0) || (blkno + totwrt) > nsects)
		return (EINVAL);

	/* Offset block number to start of partition. */
	blkno += sectoff;

	while (totwrt > 0) {
		nwrt = totwrt;		/* XXX */
#ifndef RD_DUMP_NOT_TRUSTED
		/*
		 * Fill out and send HPIB command.
		 */
		rs->sc_ioc.c_unit = C_SUNIT(rs->sc_punit);
		rs->sc_ioc.c_volume = C_SVOL(0);
		rs->sc_ioc.c_saddr = C_SADDR;
		rs->sc_ioc.c_hiaddr = 0;
		rs->sc_ioc.c_addr = RDBTOS(blkno);
		rs->sc_ioc.c_nop2 = C_NOP;
		rs->sc_ioc.c_slen = C_SLEN;
		rs->sc_ioc.c_len = nwrt * sectorsize;
		rs->sc_ioc.c_cmd = C_WRITE;
		hpibsend(ctlr, slave, C_CMD, &rs->sc_ioc.c_unit,
		    sizeof(rs->sc_ioc)-2);
		if (hpibswait(ctlr, slave))
			return (EIO);

		/*
		 * Send the data.
		 */
		hpibsend(ctlr, slave, C_EXEC, va, nwrt * sectorsize);
		(void) hpibswait(ctlr, slave);
		hpibrecv(ctlr, slave, C_QSTAT, &stat, 1);
		if (stat)
			return (EIO);
#else /* RD_DUMP_NOT_TRUSTED */
		/* Let's just talk about this first... */
		printf("%s: dump addr %p, blk %d\n", sc->sc_dev.dv_xname,
		    va, blkno);
		delay(500 * 1000);	/* half a second */
#endif /* RD_DUMP_NOT_TRUSTED */

		/* update block count */
		totwrt -= nwrt;
		blkno += nwrt;
		va += sectorsize * nwrt;
	}
	rddoingadump = 0;
	return (0);
}
@


1.8
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rd.c,v 1.7 1997/01/12 15:12:58 downsj Exp $	*/
@


1.7
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: rd.c,v 1.26 1997/01/07 09:29:32 thorpej Exp $	*/
d5 1
a49 2
#include "rd.h"
#if NRD > 0
d59 4
a63 1
#include <hp300/dev/device.h>
d66 1
d76 9
a84 4
int	rdmatch(), rdstart(), rdgo(), rdintr();
void	rdattach(), rdstrategy();
struct	driver rddriver = {
	rdmatch, rdattach, "rd", rdstart, rdgo, rdintr,
d87 15
a101 2
struct	rd_softc rd_softc[NRD];
struct	buf rdtab[NRD];
a171 1
struct	rdstats rdstats[NRD];
d246 3
a248 2
rdmatch(hd)
	register struct hp_device *hd;
d250 10
a259 1
	register struct rd_softc *rs = &rd_softc[hd->hp_unit];
d261 1
a261 4
	rs->sc_hd = hd;
	rs->sc_punit = rdpunit(hd->hp_flags);
	rs->sc_type = rdident(rs, hd, 0);
	if (rs->sc_type < 0) {
d263 3
a265 2
		 * XXX Some ancient drives may be slow to respond, so
		 * probe them again.
d267 3
a269 4
		DELAY(10000);
		rs->sc_type = rdident(rs, hd, 0);
		if (rs->sc_type < 0)
			return (0);
d271 2
d274 13
a286 3
	/* XXX set up the external name */
	bzero(rs->sc_xname, sizeof(rs->sc_xname));
	sprintf(rs->sc_xname, "rd%d", hd->hp_unit);
d291 13
a303 14
	bzero(&rs->sc_dkdev, sizeof(rs->sc_dkdev));
	rs->sc_dkdev.dk_name = rs->sc_xname;
	disk_attach(&rs->sc_dkdev);

	return (1);
}

void
rdattach(hd)
	register struct hp_device *hd;
{
	register struct rd_softc *rs = &rd_softc[hd->hp_unit];

	(void)rdident(rs, hd, 1);	/* XXX Ick. */
d305 1
a305 6
	rs->sc_dq.dq_softc = rs;
	rs->sc_dq.dq_ctlr = hd->hp_ctlr;
	rs->sc_dq.dq_unit = hd->hp_unit;
	rs->sc_dq.dq_slave = hd->hp_slave;
	rs->sc_dq.dq_driver = &rddriver;
	rs->sc_flags = RDF_ALIVE;
d312 1
a312 2
	/* XXX Set device class. */
	hd->hp_dev.dv_class = DV_DISK;
d316 4
a319 4
rdident(rs, hd, verbose)
	struct rd_softc *rs;
	struct hp_device *hd;
	int verbose;
d321 2
a322 1
	struct rd_describe *desc = &rs->sc_rddesc;
a323 1
	int unit, lunit;
d325 4
a328 1
	register int ctlr, slave, id, i;
d330 10
a339 4
	ctlr = hd->hp_ctlr;
	slave = hd->hp_slave;
	unit = rs->sc_punit;
	lunit = hd->hp_unit;
d342 2
a343 4
	 * Grab device id and make sure:
	 * 1. It is a CS80 device.
	 * 2. It is one of the types we support.
	 * 3. If it is a 7946, we are accessing the disk unit (0)
d345 2
a346 13
	id = hpibid(ctlr, slave);
#ifdef DEBUG
	if (rddebug & RDB_IDENT)
		printf("hpibid(%d, %d) -> %x\n", ctlr, slave, id);
#endif
	if ((id & 0x200) == 0)
		return(-1);
	for (i = 0; i < numrdidentinfo; i++)
		if (id == rdidentinfo[i].ri_hwid)
			break;
	if (i == numrdidentinfo || unit > rdidentinfo[i].ri_maxunum)
		return(-1);
	id = i;
d349 1
a349 3
	 * Reset drive and collect device description.
	 * Don't really use the description info right now but
	 * might come in handy in the future (for disk labels).
d351 2
a352 2
	rdreset(rs, hd);
	cmd[0] = C_SUNIT(unit);
d358 3
a360 3
	bzero(name, sizeof(name));
	if (!stat) {
		register int n = desc->d_name;
d366 1
d369 2
a370 2
		printf("rd%d: name: %x ('%s')\n",
		       lunit, desc->d_name, name);
d372 1
a372 1
		       desc->d_iuw, desc->d_cmaxxfr, desc->d_ctype);
d374 2
a375 2
		       desc->d_utype, desc->d_sectsize,
		       desc->d_blkbuf, desc->d_burstsize, desc->d_blocktime);
d377 2
a378 2
		       desc->d_uavexfr, desc->d_retry, desc->d_access,
		       desc->d_maxint, desc->d_fvbyte, desc->d_rvbyte);
d380 3
a382 2
		       desc->d_maxcyl, desc->d_maxhead, desc->d_maxsect,
		       desc->d_maxvsectl, desc->d_interleave);
d385 1
d392 1
a392 1
	switch (rdidentinfo[id].ri_hwid) {
d414 3
d419 2
a420 2
	 * off the driver because all of this code assumes 512 byte
	 * blocks.  ICK!
d422 7
a428 8
	if (verbose) {
		printf(": %s\n", rdidentinfo[id].ri_desc);
		printf("%s: %d cylinders, %d heads, %d blocks, %d bytes/block\n",
		    rs->sc_hd->hp_xname, rdidentinfo[id].ri_ncyl,
		    rdidentinfo[id].ri_ntpc, rdidentinfo[id].ri_nblocks,
		    DEV_BSIZE);
	}
	return(id);
d431 2
a432 1
rdreset(rs, hd)
a433 1
	register struct hp_device *hd;
d435 2
d441 4
a444 4
	hpibsend(hd->hp_ctlr, hd->hp_slave, C_TCMD, &rs->sc_clear,
		sizeof(rs->sc_clear));
	hpibswait(hd->hp_ctlr, hd->hp_slave);
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_QSTAT, &stat, sizeof(stat));
d449 4
a452 4
	hpibsend(hd->hp_ctlr, hd->hp_slave, C_CMD, &rs->sc_src,
		sizeof(rs->sc_src));
	hpibswait(hd->hp_ctlr, hd->hp_slave);
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_QSTAT, &stat, sizeof(stat));
d459 3
a461 4
	hpibsend(hd->hp_ctlr, hd->hp_slave, C_CMD, &rs->sc_ssmc,
		sizeof(rs->sc_ssmc));
	hpibswait(hd->hp_ctlr, hd->hp_slave);
	hpibrecv(hd->hp_ctlr, hd->hp_slave, C_QSTAT, &stat, sizeof(stat));
d463 1
a463 1
	rdstats[hd->hp_unit].rdresets++;
d475 1
a475 1
	register struct rd_softc *rs = &rd_softc[unit];
d503 1
a503 1
	printf("%s: WARNING: %s, ", rs->sc_hd->hp_xname, msg);
d524 1
a524 1
	register struct rd_softc *rs = &rd_softc[unit];
d527 4
a530 2
	if (unit >= NRD || (rs->sc_flags & RDF_ALIVE) == 0)
		return(ENXIO);
d583 1
a583 1
	register struct rd_softc *rs = &rd_softc[unit];
d603 1
a603 1
		while (rdtab[unit].b_active) {
d605 1
a605 1
			sleep((caddr_t)&rdtab[unit], PRIBIO);
d619 2
a620 2
	register struct rd_softc *rs = &rd_softc[unit];
	register struct buf *dp = &rdtab[unit];
d674 1
a674 1
		rdustart(unit);
d692 1
a692 1
	rdustart((int)arg);
d696 3
a698 2
rdustart(unit)
	register int unit;
a700 1
	register struct rd_softc *rs = &rd_softc[unit];
d702 1
a702 1
	bp = rdtab[unit].b_actf;
d705 2
a706 2
	if (hpibreq(&rs->sc_dq))
		rdstart(unit);
d710 1
a710 2
rdfinish(unit, rs, bp)
	int unit;
d714 1
a714 1
	register struct buf *dp = &rdtab[unit];
d720 1
a720 1
	hpibfree(&rs->sc_dq);
d722 1
a722 1
		return(dp->b_actf);
d728 1
a728 1
	return(NULL);
d731 3
a733 2
rdstart(unit)
	register int unit;
d735 6
a740 4
	register struct rd_softc *rs = &rd_softc[unit];
	register struct buf *bp = rdtab[unit].b_actf;
	register struct hp_device *hp = rs->sc_hd;
	register int part;
d745 1
a745 1
		printf("rdstart(%d): bp %x, %c\n", unit, bp,
d762 1
a762 1
		       hp->hp_ctlr, hp->hp_slave, C_CMD,
d765 1
a765 1
	if (hpibsend(hp->hp_ctlr, hp->hp_slave, C_CMD, &rs->sc_ioc.c_unit,
d774 1
a774 1
			printf("rdstart: hpibawait(%x)\n", hp->hp_ctlr);
d776 1
a776 1
		hpibawait(hp->hp_ctlr);
d788 3
a790 3
		       rs->sc_hd->hp_xname, rs->sc_ioc.c_cmd, rs->sc_ioc.c_addr,
		       bp->b_blkno, rs->sc_resid, rdtab[unit].b_errcnt);
	rdstats[unit].rdretries++;
d793 2
a794 2
	rdreset(rs, hp);
	if (rdtab[unit].b_errcnt++ < RDRETRY)
d797 1
a797 1
	       rs->sc_hd->hp_xname, rs->sc_ioc.c_cmd, rs->sc_ioc.c_addr,
d801 1
a801 1
	bp = rdfinish(unit, rs, bp);
d805 1
a805 1
		if (hpibreq(&rs->sc_dq))
d810 3
a812 2
rdgo(unit)
	register int unit;
d814 6
a819 4
	register struct rd_softc *rs = &rd_softc[unit];
	register struct hp_device *hp = rs->sc_hd;
	struct buf *bp = rdtab[unit].b_actf;
	int rw;
d830 1
a830 2
	hpibgo(hp->hp_ctlr, hp->hp_slave, C_EXEC,
	       rs->sc_addr, rs->sc_resid, rw, rw != 0);
d833 2
d839 2
a840 3
	int unit = rs->sc_hd->hp_unit;
	register struct buf *bp = rdtab[unit].b_actf;
	register struct hp_device *hp = rs->sc_hd;
d842 5
a846 2
	int rv, restart;
	
d852 1
a852 1
		printf("%s: bp == NULL\n", rs->sc_hd->hp_xname);
d860 2
a861 2
		if (hpibustart(hp->hp_ctlr))
			rdgo(unit);
d866 1
a866 1
		rdstats[unit].rdpolltries++;
d868 1
a868 1
		if (hpibpptest(hp->hp_ctlr, hp->hp_slave) == 0) {
d870 1
a870 1
			rdstats[unit].rdpollwaits++;
d876 1
a876 1
			hpibawait(hp->hp_ctlr);
d881 1
a881 1
	rv = hpibrecv(hp->hp_ctlr, hp->hp_slave, C_QSTAT, &stat, 1);
d889 1
a889 1
		rdstats[unit].rdretries++;
d891 1
a891 1
		if (rdtab[unit].b_errcnt++ < RDRETRY) {
d893 1
a893 1
				rdstart(unit);
d899 2
a900 2
	if (rdfinish(unit, rs, bp))
		rdustart(unit);
d903 1
d911 2
a912 2
	c = rs->sc_hd->hp_ctlr;
	s = rs->sc_hd->hp_slave;
d953 1
d957 1
a957 1
	struct rd_softc *rs = &rd_softc[unit];
d964 1
a964 1
		printf("%s: couldn't get status\n", rs->sc_hd->hp_xname);
d966 1
a966 1
		rdreset(rs, rs->sc_hd);
d973 1
a973 1
		rdreset(rs, rs->sc_hd);
d985 1
a985 1
		int rdtimo = RDWAITC << rdtab[unit].b_errcnt;
d988 2
a989 2
		       rs->sc_hd->hp_xname, rdtimo);
		rdstats[unit].rdtimeouts++;
d991 2
a992 2
		hpibfree(&rs->sc_dq);
		timeout(rdrestart, (void *)unit, rdtimo * hz);
d1000 1
a1000 1
	if (rdtab[unit].b_errcnt < rderrthresh)
d1008 1
a1008 1
	bp = rdtab[unit].b_actf;
d1024 2
a1025 2
	printf("rd%d%c: hard error sn%d\n",
	       rdunit(bp->b_dev), 'a'+rdpart(bp->b_dev), pbn);
d1030 2
a1031 2
	printf("rd%d %s error:",
	       unit, (bp->b_flags & B_READ) ? "read" : "write");
d1089 1
a1089 1
	int cmd;
d1095 1
a1095 1
	register struct rd_softc *sc = &rd_softc[unit];
d1151 1
a1151 1
	register struct rd_softc *rs = &rd_softc[unit];
d1154 4
a1157 2
	if (unit >= NRD || (rs->sc_flags & RDF_ALIVE) == 0)
		return(-1);
d1213 1
a1214 1
	struct hp_device *hp;
d1228 3
a1230 1
	if (unit >= NRD)
d1232 3
a1234 4
	rs = &rd_softc[unit];
	if ((rs->sc_flags & RDF_ALIVE) == 0)
		return (ENXIO);
	hp = rs->sc_hd;
d1271 3
a1273 3
		hpibsend(hp->hp_ctlr, hp->hp_slave, C_CMD,
			 &rs->sc_ioc.c_unit, sizeof(rs->sc_ioc)-2);
		if (hpibswait(hp->hp_ctlr, hp->hp_slave))
d1279 3
a1281 4
		hpibsend(hp->hp_ctlr, hp->hp_slave, C_EXEC, va,
		    nwrt * sectorsize);
		(void) hpibswait(hp->hp_ctlr, hp->hp_slave);
		hpibrecv(hp->hp_ctlr, hp->hp_slave, C_QSTAT, &stat, 1);
d1286 1
a1286 1
		printf("%s: dump addr %p, blk %d\n", hp->hp_xname,
a1298 1
#endif
@


1.6
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: rd.c,v 1.20.4.1 1996/06/06 16:22:01 thorpej Exp $	*/
d278 3
d493 1
a493 1
	int error, mask;
d518 12
a529 2
	mask = 1 << rdpart(dev);
	if (mode == S_IFCHR)
d531 2
a532 1
	else
d534 5
a538 1
	rs->sc_dkdev.dk_openmask |= mask;
d590 1
d601 21
a621 5
	if (bn < 0 || bn + sz > pinfo->p_size) {
		sz = pinfo->p_size - bn;
		if (sz == 0) {
			bp->b_resid = bp->b_bcount;
			goto done;
d623 9
a631 2
		if (sz < 0) {
			bp->b_error = EINVAL;
a633 1
		bp->b_bcount = dbtob(sz);
d635 1
a635 12
	/*
	 * Check for write to write protected label
	 */
	if (bn + pinfo->p_offset <= LABELSECTOR &&
#if LABELSECTOR != 0
	    bn + pinfo->p_offset + sz > LABELSECTOR &&
#endif
	    !(bp->b_flags & B_READ) && !(rs->sc_flags & RDF_WLABEL)) {
		bp->b_error = EROFS;
		goto bad;
	}
	bp->b_cylin = bn + pinfo->p_offset;
d1149 2
d1155 1
a1155 1
rddump(dev)
d1157 13
a1169 8
{
	int part = rdpart(dev);
	int unit = rdunit(dev);
	register struct rd_softc *rs = &rd_softc[unit];
	register struct hp_device *hp = rs->sc_hd;
	register struct partition *pinfo;
	register daddr_t baddr;
	register int maddr, pages, i;
a1170 5
	extern int lowram, dumpsize;
#ifdef DEBUG
	extern int pmapdebug;
	pmapdebug = 0;
#endif
d1172 14
a1185 2
	/* is drive ok? */
	if (unit >= NRD || (rs->sc_flags & RDF_ALIVE) == 0)
d1187 17
a1203 4
	pinfo = &rs->sc_dkdev.dk_label->d_partitions[part];
	/* dump parameters in range? */
	if (dumplo < 0 || dumplo >= pinfo->p_size ||
	    pinfo->p_fstype != FS_SWAP)
d1205 10
a1214 17
	pages = dumpsize;
	if (dumplo + ctod(pages) > pinfo->p_size)
		pages = dtoc(pinfo->p_size - dumplo);
	maddr = lowram;
	baddr = dumplo + pinfo->p_offset;
	/* HPIB idle? */
	if (!hpibreq(&rs->sc_dq)) {
		hpibreset(hp->hp_ctlr);
		rdreset(rs, rs->sc_hd);
		printf("[ drive %d reset ] ", unit);
	}
	for (i = 0; i < pages; i++) {
#define NPGMB	(1024*1024/NBPG)
		/* print out how many Mbs we have dumped */
		if (i && (i % NPGMB) == 0)
			printf("%d ", i / NPGMB);
#undef NPBMG
d1219 1
a1219 1
		rs->sc_ioc.c_addr = RDBTOS(baddr);
d1222 1
a1222 1
		rs->sc_ioc.c_len = NBPG;
d1228 6
a1233 3
		pmap_enter(pmap_kernel(), (vm_offset_t)vmmap, maddr,
		    VM_PROT_READ, TRUE);
		hpibsend(hp->hp_ctlr, hp->hp_slave, C_EXEC, vmmap, NBPG);
d1238 11
a1248 2
		maddr += NBPG;
		baddr += ctod(1);
d1250 1
@


1.5
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: rd.c,v 1.20 1996/02/14 02:44:54 thorpej Exp $	*/
a54 1
#include <sys/dkstat.h>		/* XXX */
a334 3
		/* use drive characteristics to calculate xfer rate */
		rs->sc_wpms = 1000000 * (desc->d_sectsize/2) /
		    desc->d_blocktime;
a512 9
	if (rs->sc_hd->hp_dk >= 0) {
		/* guess at xfer rate based on 3600 rpm (60 rps) */
		if (rs->sc_wpms == 0)
			rs->sc_wpms = 60 * rs->sc_dkdev.dk_label->d_nsectors
				* DEV_BSIZE / 2;

		/* XXX Support old-style instrumentation for now. */
		dk_wpms[rs->sc_hd->hp_dk] = rs->sc_wpms;
	}
a700 6
		/* XXX Support old-style instrumentation for now. */
		if (hp->hp_dk >= 0) {
			 dk_busy |= 1 << hp->hp_dk;
			 dk_seek[hp->hp_dk]++;
		}

a752 7
	/* XXX Support old-style instrumentation for now. */
	if (hp->hp_dk >= 0) {
		dk_busy |= 1 << hp->hp_dk;
		dk_xfer[hp->hp_dk]++;
		dk_wds[hp->hp_dk] += rs->sc_resid >> 6;
	}

a782 4
	/* XXX Support old-style instrumentation for now. */
	if (hp->hp_dk >= 0)
		dk_busy &= ~(1 << hp->hp_dk);

a798 4

			/* XXX Support old-style instrumentation for now. */
			if (hp->hp_dk >= 0)
				dk_busy |= 1 << hp->hp_dk;
@


1.4
log
@from netbsd:
Kludge around a case where a flaky HP-IB disk might be slow to respond
to the identification request in rdmatch().  Similar in spirit to a
patch from Jason Downs (written eons ago), but limited to the broken
device we're trying to reach.  My patch tested (and fixed :-) by
Herb Peyerl.
@
text
@d1 1
a1 1
/*	$NetBSD: rd.c,v 1.18 1996/01/10 20:54:29 thorpej Exp $	*/
a255 2
		return (0);

d267 1
d790 2
a791 2
rdintr(unit)
	register int unit;
d793 2
a794 1
	register struct rd_softc *rs = &rd_softc[unit];
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
a1 1
/*	$NetBSD: rd.c,v 1.17 1996/01/07 22:02:12 thorpej Exp $	*/
d234 10
a243 2
	if (rs->sc_type < 0)
		return(0);
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: rd.c,v 1.16 1995/12/09 07:31:07 thorpej Exp $	*/
d55 1
a55 1
#include <sys/dkstat.h>
d57 1
d235 13
d437 1
a437 1
	register struct disklabel *lp = &rs->sc_info.ri_label;
d502 1
a502 1
	if (rs->sc_info.ri_open == 0) {
d513 1
a513 1
			rs->sc_wpms = 60 * rs->sc_info.ri_label.d_nsectors
d515 2
d522 1
a522 1
		rs->sc_info.ri_copen |= mask;
d524 2
a525 2
		rs->sc_info.ri_bopen |= mask;
	rs->sc_info.ri_open |= mask;
d537 1
a537 1
	register struct rdinfo *ri = &rs->sc_info;
d542 1
a542 1
		ri->ri_copen &= ~mask;
d544 2
a545 2
		ri->ri_bopen &= ~mask;
	ri->ri_open = ri->ri_bopen | ri->ri_copen;
d553 1
a553 1
	if (ri->ri_open == 0) {
d586 1
a586 1
	pinfo = &rs->sc_info.ri_label.d_partitions[rdpart(bp->b_dev)];
d706 2
d709 2
a710 2
			dk_busy |= 1 << hp->hp_dk;
			dk_seek[hp->hp_dk]++;
d712 5
d765 1
d771 4
d801 1
d804 3
d821 2
d825 3
d960 1
a960 1
	pbn = rs->sc_info.ri_label.d_partitions[rdpart(bp->b_dev)].p_offset;
d1047 1
a1047 1
	register struct disklabel *lp = &sc->sc_info.ri_label;
d1075 1
a1075 1
				     : sc->sc_info.ri_open,
d1083 1
a1083 1
				     : sc->sc_info.ri_open,
d1113 1
a1113 1
	if (rs->sc_info.ri_open == 0) {
d1118 1
a1118 1
	psize = rs->sc_info.ri_label.d_partitions[rdpart(dev)].p_size;
d1168 1
a1168 1
	pinfo = &rs->sc_info.ri_label.d_partitions[part];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: rd.c,v 1.13 1995/10/09 07:57:46 thorpej Exp $	*/
d72 2
a73 2
int	rdinit(), rdstart(), rdgo(), rdintr();
void	rdstrategy();
d75 1
a75 1
	rdinit, "rd", rdstart, rdgo, rdintr,
d165 56
a220 19
	{ RD7946AID,	0,	"7945A",	 108416 },
	{ RD9134DID,	1,	"9134D",	  29088 },
	{ RD9134LID,	1,	"9122S",	   1232 },
	{ RD7912PID,	0,	"7912P",	 128128 },
	{ RD7914PID,	0,	"7914P",	 258048 },
	{ RD7958AID,	0,	"7958A",	 255276 },
	{ RD7957AID,	0,	"7957A",	 159544 },
	{ RD7933HID,	0,	"7933H",	 789958 },
	{ RD9134LID,	1,	"9134L",	  77840 },
	{ RD7936HID,	0,	"7936H",	 600978 },
	{ RD7937HID,	0,	"7937H",	1116102 },
	{ RD7914CTID,	0,	"7914CT",	 258048 },
	{ RD7946AID,	0,	"7946A",	 108416 },
	{ RD9134LID,	1,	"9122D",	   1232 },
	{ RD7957BID,	0,	"7957B",	 159894 },
	{ RD7958BID,	0,	"7958B",	 297108 },
	{ RD7959BID,	0,	"7959B",	 594216 },
	{ RD2200AID,	0,	"2200A",	 654948 },
	{ RD2203AID,	0,	"2203A",	1309896 }
d224 2
a225 1
rdinit(hd)
d232 1
a232 1
	rs->sc_type = rdident(rs, hd);
d234 13
a246 1
		return(0);
a256 1
	return(1);
d259 2
a260 1
rdident(rs, hd)
d263 1
d265 1
a265 1
	struct rd_describe desc;
d306 1
a306 1
	hpibrecv(ctlr, slave, C_EXEC, &desc, 37);
d310 1
a310 1
		register int n = desc.d_name;
d316 2
a317 1
		rs->sc_wpms = 1000000 * (desc.d_sectsize/2) / desc.d_blocktime;
d322 1
a322 1
		       lunit, desc.d_name, name);
d324 1
a324 1
		       desc.d_iuw, desc.d_cmaxxfr, desc.d_ctype);
d326 2
a327 2
		       desc.d_utype, desc.d_sectsize,
		       desc.d_blkbuf, desc.d_burstsize, desc.d_blocktime);
d329 2
a330 2
		       desc.d_uavexfr, desc.d_retry, desc.d_access,
		       desc.d_maxint, desc.d_fvbyte, desc.d_rvbyte);
d332 2
a333 2
		       desc.d_maxcyl, desc.d_maxhead, desc.d_maxsect,
		       desc.d_maxvsectl, desc.d_interleave);
d364 12
a375 1
	printf("rd%d: %s\n", lunit, rdidentinfo[id].ri_desc);
d445 1
a445 1
	msg = readdisklabel(rdlabdev(dev), rdstrategy, lp);
d450 1
a450 1
	printf("rd%d: WARNING: %s, ", unit, msg);
d709 2
a710 2
		printf("rd%d: rdstart: cmd %x adr %d blk %d len %d ecnt %d\n",
		       unit, rs->sc_ioc.c_cmd, rs->sc_ioc.c_addr,
d718 2
a719 2
	printf("rd%d: rdstart err: cmd 0x%x sect %d blk %d len %d\n",
	       unit, rs->sc_ioc.c_cmd, rs->sc_ioc.c_addr,
d769 1
a769 1
		printf("rd%d: bp == NULL\n", unit);
d878 1
a878 1
		printf("rd%d: couldn't get status\n", unit);
d901 2
a902 2
		printf("rd%d: internal maintenance, %d second timeout\n",
		       unit, rdtimo);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
