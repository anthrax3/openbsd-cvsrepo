head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.12
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.15.0.12
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.10
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.17
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2011.08.18.20.02.57;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.06.22.51.03;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.11.21.58.04;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.06.20.10.57;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.06.20.09.12;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.18.18.57.24;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.22.21.04.31;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.20.20.26.52;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.16.21.03.43;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.31.18.13.41;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.30.18.14.09;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.30.18.03.33;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.27.22.10.55;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.17.22.31.34;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.22.39.26;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: sti_sgc.c,v 1.16 2011/08/18 20:02:57 miod Exp $	*/

/*
 * Copyright (c) 2005, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>

#include <hp300/dev/sgcreg.h>
#include <hp300/dev/sgcvar.h>

#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsconsio.h>

#include <dev/ic/stireg.h>
#include <dev/ic/stivar.h>
#include <hp300/dev/sti_machdep.h>

#include <uvm/uvm_extern.h>

void	sti_sgc_attach(struct device *, struct device *, void *);
int	sti_sgc_match(struct device *, void *, void *);

struct cfattach sti_sgc_ca = {
	sizeof(struct sti_softc), sti_sgc_match, sti_sgc_attach
};

int
sti_sgc_match(struct device *parent, void *match, void *aux)
{
	struct sgc_attach_args *saa = aux;

	/*
	 * If we already probed it successfully as a console device, go ahead,
	 * since we will not be able to bus_space_map() again.
	 */
	if (SGC_SLOT_TO_CONSCODE(saa->saa_slot) == conscode)
		return (1);

	return (sti_sgc_probe(saa->saa_iot, saa->saa_slot));
}

void
sti_sgc_attach(struct device *parent, struct device *self, void *aux)
{
	struct sti_softc *sc = (void *)self;
	struct sgc_attach_args *saa = aux;
	bus_addr_t base;
	bus_space_handle_t romh;
	u_int romend;
	int i;

	/*
	 * If we already probed it successfully as a console device, go ahead,
	 * since we will not be able to bus_space_map() again.
	 */
	if (SGC_SLOT_TO_CONSCODE(saa->saa_slot) == conscode) {
		sc->sc_flags |= STI_CONSOLE | STI_ATTACHED;
		sc->sc_rom = &sticn_rom;
		sc->sc_scr = &sticn_scr;
		bcopy(sticn_bases, sc->bases, sizeof(sc->bases));

		sti_describe(sc);
	} else {
		base = (bus_addr_t)sgc_slottopa(saa->saa_slot);

		if (bus_space_map(saa->saa_iot, base, PAGE_SIZE, 0, &romh)) {
			printf(": can't map frame buffer");
			return;
		}

		/*
		 * Compute real PROM size
		 */
		romend = sti_rom_size(saa->saa_iot, romh);

		bus_space_unmap(saa->saa_iot, romh, PAGE_SIZE);

		if (bus_space_map(saa->saa_iot, base, romend, 0, &romh)) {
			printf(": can't map frame buffer");
			return;
		}

		sc->bases[0] = romh;
		for (i = 1; i < STI_REGION_MAX; i++)
			sc->bases[i] = base;

		if (sti_attach_common(sc, saa->saa_iot, saa->saa_iot, romh,
		    STI_CODEBASE_M68K) != 0)
			return;
	}

	sti_end_attach(sc);
}

int
sti_sgc_probe(bus_space_tag_t iot, int slot)
{
	bus_space_handle_t ioh;
	int devtype;

	if (bus_space_map(iot, (bus_addr_t)sgc_slottopa(slot),
	    PAGE_SIZE, 0, &ioh))
		return (0);

	devtype = bus_space_read_1(iot, ioh, 3);

	bus_space_unmap(iot, ioh, PAGE_SIZE);

	/*
	 * This might not be reliable enough. On the other hand, non-STI
	 * SGC cards will apparently not initialize in an hp300, to the
	 * point of not even answering bus probes (checked with an
	 * Harmony/FDDI SGC card).
	 */
	if (devtype != STI_DEVTYPE1 && devtype != STI_DEVTYPE4)
		return (0);

	return (1);
}
@


1.16
log
@So, it turns out that models 362 and 382 built-in frame buffer only shows up
in DIO-II space, as a fat device spanning four select codes (i.e. 16MB of
memory). This is way too much for an at-most 2 Mpixel 8bit frame buffer, and
it turns out that this is because the device provides both a regular DIO-II
frame buffer (spanning two select codes) and a regular STI frame buffer
(spanning the other two select codes).
This commit introduces a straightforward sti@@dio attachment to get a working
sti(4) and wsdisplay(4) in a ridiculously small number of lines; however
the console code needs some changes to avoid duplicating globals.

While there, add sti@@dio support for the bootblocks, and I couldn't help
myself but clean the most rotten parts of them, and try to have them reuse
various files in sys/arch/hp300/dev instead of rolling their outdated ones.

Tested on a real 382 with the low-resolution frame buffer:
sti0 at dio0 scode 132: rev 8.02;129, ID 0x27134CB440A00499
sti0: 382V, 2048x512 frame buffer, 640x480x8 display
sti0: 8x16 font type 1, 16 bpc, charset 0-255
wsdisplay0 at sti0 mux 1: console (std, vt100 emulation)

Boot blocks updates tested on DIO-II 425t (serial/glass console), SGC 425e
(serial/glass console) and 382 (serial/glass console). And will be tested
on SGC 425t soon as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.15 2009/02/06 22:51:03 miod Exp $	*/
@


1.15
log
@Split sti structures into rom-related information and screen-related
information. This is preliminary work to help eventually supporting the
dual-head ELK model.

Also split the initialization code in several routines, this makes the
code easier to read, and makes it easier to release resources upon failure.

Finally, don't forget to clear the text planes on non-console displays
when initializing.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.14 2007/05/26 00:36:03 krw Exp $	*/
d46 1
a51 1
int	sti_sgc_probe(bus_space_tag_t, int);
a56 5
/* Console data */
struct sti_rom sticn_rom;
struct sti_screen sticn_scr;
bus_addr_t sticn_bases[STI_REGION_MAX];

a148 48
}

/*
 * Console code
 */

int	sti_console_scan(int);
void	sticninit(void);

int
sti_console_scan(int slot)
{
	extern struct hp300_bus_space_tag hp300_mem_tag;
	bus_space_tag_t iot;

	iot = &hp300_mem_tag;
	return (sti_sgc_probe(iot, slot));
}

void
sticninit()
{
	extern struct hp300_bus_space_tag hp300_mem_tag;
	bus_space_tag_t iot;
	bus_addr_t base;
	int i;

	/*
	 * We are not interested by the *first* console pass.
	 */
	if (consolepass == 0)
		return;

	iot = &hp300_mem_tag;
	base = (bus_addr_t)sgc_slottopa(CONSCODE_TO_SGC_SLOT(conscode));

	/* sticn_bases[0] will be fixed in sti_cnattach() */
	for (i = 0; i < STI_REGION_MAX; i++)
		sticn_bases[i] = base;

	sti_cnattach(&sticn_rom, &sticn_scr, iot, sticn_bases,
	    STI_CODEBASE_M68K);

	/*
	 * Since the copyright notice could not be displayed before,
	 * display it again now.
	 */
	printf("%s\n", copyright);
@


1.14
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.13 2007/01/11 21:58:04 miod Exp $	*/
d58 3
a60 2
struct sti_screen stifb_cn;
bus_addr_t stifb_cn_bases[STI_REGION_MAX];
d83 1
a83 1
	bus_space_handle_t ioh;
d93 3
a95 2
		sc->sc_scr = &stifb_cn;
		bcopy(stifb_cn_bases, sc->bases, sizeof(sc->bases));
d101 1
a101 1
		if (bus_space_map(saa->saa_iot, base, PAGE_SIZE, 0, &ioh)) {
d109 1
a109 1
		romend = sti_rom_size(saa->saa_iot, ioh);
d111 1
a111 1
		bus_space_unmap(saa->saa_iot, ioh, PAGE_SIZE);
d113 1
a113 1
		if (bus_space_map(saa->saa_iot, base, romend, 0, &ioh)) {
d118 1
a118 3
		sc->memt = sc->iot = saa->saa_iot;
		sc->romh = ioh;
		sc->bases[0] = sc->romh;
d122 2
a123 1
		if (sti_attach_common(sc, STI_CODEBASE_M68K) != 0)
d190 1
a190 1
	/* stifb_cn_bases[0] will be fixed in sti_cnattach() */
d192 1
a192 1
		stifb_cn_bases[i] = base;
d194 2
a195 2
	sti_cnattach(&stifb_cn, iot, stifb_cn_bases, STI_CODEBASE_M68K);
	sti_clear(&stifb_cn);
@


1.13
log
@Allow sti_attach_common() to return an error code, and do not fall into
sti_end_attach() if an error has occured.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.12 2007/01/06 20:10:57 miod Exp $	*/
d67 1
a67 1
	 * If we already probed it succesfully as a console device, go ahead,
d87 1
a87 1
	 * If we already probed it succesfully as a console device, go ahead,
@


1.12
log
@Turn bus_space_tag_t into real structures containing a bunch of function
pointers, to be used for the various bus_space operations.

intio devices no longer need to pass an intiobase-relative address to
bus_space_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.11 2007/01/06 20:09:12 miod Exp $	*/
d122 2
a123 1
		sti_attach_common(sc, STI_CODEBASE_M68K);
@


1.11
log
@Propagate bus_space_tag_t through device attachment args structures, rather
than having them build their own. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.10 2006/12/18 18:57:24 miod Exp $	*/
d164 1
d167 1
a167 2
	iot = HP300_BUS_TAG(HP300_BUS_SGC, slot);

d174 1
d185 1
a185 1
	iot = HP300_BUS_TAG(HP300_BUS_SGC, CONSCODE_TO_SGC_SLOT(conscode));
@


1.10
log
@Change sti attachment to pass an array of base addresses for the sti regions,
instead of using the rom mapping for region #0 and the device mapping for
region #1. This will allow sti devices on which regions may be relative to
different origins to attach (to be used very soon).

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.9 2006/08/22 21:04:31 miod Exp $	*/
a64 1
	bus_space_tag_t iot;
d73 1
a73 3
	iot = HP300_BUS_TAG(HP300_BUS_SGC, saa->saa_slot);

	return (sti_sgc_probe(iot, saa->saa_slot));
a81 1
	bus_space_tag_t iot;
a96 1
		iot = HP300_BUS_TAG(HP300_BUS_SGC, saa->saa_slot);
d99 1
a99 1
		if (bus_space_map(iot, base, PAGE_SIZE, 0, &ioh)) {
d107 1
a107 1
		romend = sti_rom_size(iot, ioh);
d109 1
a109 1
		bus_space_unmap(iot, ioh, PAGE_SIZE);
d111 1
a111 1
		if (bus_space_map(iot, base, romend, 0, &ioh)) {
d116 1
a116 1
		sc->memt = sc->iot = iot;
@


1.9
log
@Clear sti display on console attach, now that the bootloader leaves us
with scribbles around; ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.8 2006/04/20 20:26:52 deraadt Exp $	*/
d57 4
d84 1
d88 1
a94 2
		extern struct sti_screen stifb_cn;

d97 1
d102 1
a102 1
		sc->base = (bus_addr_t)sgc_slottopa(saa->saa_slot);
d104 1
a104 1
		if (bus_space_map(iot, sc->base, PAGE_SIZE, 0, &ioh)) {
d116 1
a116 1
		if (bus_space_map(iot, sc->base, romend, 0, &ioh)) {
d123 3
a178 1
	extern struct sti_screen stifb_cn;
d181 1
d192 5
a196 1
	sti_cnattach(&stifb_cn, iot, base, STI_CODEBASE_M68K);
@


1.8
log
@no longer failure care; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.7 2006/04/16 21:03:43 miod Exp $	*/
d185 1
@


1.7
log
@Introduce sti_rom_size() which will compute the size of a card's rom, and
use it instead of duplicating the same logic in 3 places.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.6 2005/12/31 18:13:41 miod Exp $	*/
d119 1
a119 2
		if (sti_attach_common(sc, STI_CODEBASE_M68K) != 0)
			return;
@


1.6
log
@Rework (once again) the console code, in order to match the PROM's logic better.
When not running on serial console, the PROM will pick the ``internal''
graphics device, and if it does not exist, the DIO device with the lowest
select code, and will resort to SGC devices if no internal or DIO device
was found.

However, the current logic would search for a certain frame buffer type first,
then for its best hardware location, following the order they are listed
in conf.c.

By replacing gazillions of almost-exactly-duplicated frame buffer code with
one single instance, which is device type-agnostic, we can match the PROM
(and the bootblocks) logic again. Plus this saves a few KB of code!
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.5 2005/12/30 18:14:09 miod Exp $	*/
d82 1
a82 2
	int devtype;
	u_int32_t romend;
d107 1
a107 10
		devtype = bus_space_read_1(iot, ioh, 3);
		if (devtype == STI_DEVTYPE4) {
			romend = bus_space_read_4(iot, ioh, 0x18);
		} else {
			romend =
			    (bus_space_read_1(iot, ioh, 0x50 +  3) << 24) |
			    (bus_space_read_1(iot, ioh, 0x50 +  7) << 16) |
			    (bus_space_read_1(iot, ioh, 0x50 + 11) <<  8) |
			    (bus_space_read_1(iot, ioh, 0x50 + 15));
		}
d111 1
a111 2
		if (bus_space_map(iot, sc->base, round_page(romend), 0,
		    &ioh)) {
d119 2
a120 1
		sti_attach_common(sc, STI_CODEBASE_M68K);
@


1.5
log
@Kill conforced, and have console devices use CN_FORCED priority instead.
This means we are no longer aborting the console scans even if the final
console has been found, but on the other hand makes some logic simpler;
plus it will be necessary for upcoming scode vs device loop order reversal.
No user-visible change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.4 2005/12/30 18:03:33 miod Exp $	*/
a37 2
#include <dev/cons.h>

d49 3
a51 2
int  sti_sgc_match(struct device *, void *, void *);
void sti_sgc_attach(struct device *, struct device *, void *);
a61 2
	bus_space_handle_t ioh;
	int devtype;
d72 1
a72 18
	if (bus_space_map(iot, (bus_addr_t)sgc_slottopa(saa->saa_slot),
	    PAGE_SIZE, 0, &ioh))
		return (0);

	devtype = bus_space_read_1(iot, ioh, 3);

	bus_space_unmap(iot, ioh, PAGE_SIZE);

	/*
	 * This might not be reliable enough. On the other hand, non-STI
	 * SGC cards will apparently not initialize in an hp300, to the
	 * point of not even answering bus probes (checked with an
	 * Harmony/FDDI SGC card).
	 */
	if (devtype != STI_DEVTYPE1 && devtype != STI_DEVTYPE4)
		return (0);

	return (1);
a135 7
/*
 * Console code
 */

int sti_console_scan(int, caddr_t, void *);
cons_decl(sti);

d137 1
a137 1
sti_console_scan(int slot, caddr_t va, void *arg)
a138 2
	struct consdev *cp = arg;
	bus_space_tag_t iot;
a140 1
	u_int pri;
d142 2
a143 4
	iot = HP300_BUS_TAG(HP300_BUS_SGC, slot);

	if (bus_space_map(iot, (bus_addr_t)sgc_slottopa(slot), PAGE_SIZE, 0,
	    &ioh))
d150 6
a155 1
	/* XXX this is not reliable enough */
d159 2
a160 1
	pri = CN_INTERNAL;
d162 3
a164 11
#ifdef	CONSCODE
	/*
	 * Raise our priority, if appropriate.
	 */
	if (SGC_SLOT_TO_CONSCODE(slot) == CONSCODE)
		pri = CN_FORCED;
#endif

	/* Only raise priority. */
	if (pri > cp->cn_pri)
		cp->cn_pri = pri;
d166 2
a167 9
	/*
	 * If our priority is higher than the currently-remembered
	 * console, stash our priority.
	 */
	if (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri) {
		cn_tab = cp;
		conscode = SGC_SLOT_TO_CONSCODE(slot);
		return (1);
	}
d169 2
a170 5
	return (0);
}

void
sticnprobe(struct consdev *cp)
d172 1
a172 1
	int maj;
d174 1
a174 10
	for (maj = 0; maj < nchrdev; maj++) {
		if (cdevsw[maj].d_open == wsdisplayopen)
			break;
	}

	if (maj == nchrdev)
		return;

	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_DEAD;
d176 1
a176 2
	/* Search for an sti device */
	console_scan(sti_console_scan, cp, HP300_BUS_SGC);
d180 1
a180 1
sticninit(struct consdev *cp)
@


1.4
log
@When a driver claims console, let it set conscode to itself, instead of
letting the bus walkers do this for it. This is necessary since apci does
not use the bus walkers, now that we do not force console probes to stop
when apci claims console.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.3 2005/02/27 22:10:55 miod Exp $	*/
a168 1
	int force = 0, pri;
d170 1
d192 2
a193 4
	if (SGC_SLOT_TO_CONSCODE(slot) == CONSCODE) {
		pri = CN_REMOTE;
		force = conforced = 1;
	}
d204 1
a204 1
	if (((cn_tab == NULL) || (cp->cn_pri > cn_tab->cn_pri)) || force) {
a216 4

	/* Abort early if the console is already forced. */
	if (conforced)
		return;
@


1.3
log
@Split sti softc in two structures, one device-related for regular device
attachment and interface, one screen-attached for the real work.

The attachment code is now required to decide whether sti_end_attach() is
run immediately, or as a startuphook.

This allows hp300 to initialize sti early, and use it as a console; hppa
is functionally unchanged, as it uses the PROM console until the root device
is mounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.2 2005/01/17 22:31:34 miod Exp $	*/
d208 1
@


1.2
log
@Compute sti ROM size and map it exactly, rather than using a supposedly
large enough constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.1 2005/01/14 22:39:26 miod Exp $	*/
a65 1
#ifdef SGC_CONSOLE
a71 1
#endif
d105 6
a110 2
	iot = HP300_BUS_TAG(HP300_BUS_SGC, saa->saa_slot);
	sc->base = (bus_addr_t)sgc_slottopa(saa->saa_slot);
d112 2
a113 4
	if (bus_space_map(iot, sc->base, PAGE_SIZE, 0, &ioh)) {
		printf(": can't map frame buffer");
		return;
	}
d115 1
a115 6
	/*
	 * Compute real PROM size
	 */
	devtype = bus_space_read_1(iot, ioh, 3);
	if (devtype == STI_DEVTYPE4) {
		romend = bus_space_read_4(iot, ioh, 0x18);
d117 29
a145 6
		romend =
		    (bus_space_read_1(iot, ioh, 0x50 +  3) << 24) |
		    (bus_space_read_1(iot, ioh, 0x50 +  7) << 16) |
		    (bus_space_read_1(iot, ioh, 0x50 + 11) <<  8) |
		    (bus_space_read_1(iot, ioh, 0x50 + 15));
	}
d147 2
a148 1
	bus_space_unmap(iot, ioh, PAGE_SIZE);
d150 1
a150 3
	if (bus_space_map(iot, sc->base, round_page(romend), 0, &ioh)) {
		printf(": can't map frame buffer");
		return;
d153 1
a153 7
	sc->memt = sc->iot = iot;
	sc->romh = ioh;

	if (SGC_SLOT_TO_CONSCODE(saa->saa_slot) == conscode)
		sc->sc_flags |= STI_CONSOLE;

	sti_attach_common(sc, STI_CODEBASE_M68K);
a165 1
#ifdef SGC_CONSOLE
a211 4
#else
	/* Do not allow console to be on an SGC device (yet). */
	return (0);
#endif
d241 15
d257 2
a258 6
	 * We should theoretically initialize the sti driver here.
	 * However, since it relies upon the vm system being initialized,
	 * which is not the case at this point, postpone the initialization.
	 *
	 * We can't even use the PROM output services, since they are not
	 * available AT ALL when we are running virtual.
d260 1
@


1.1
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 7
#include "wsdisplay.h"

/*
 * This is a safe upper bound of the amount of memory we will need to
 * bus_space_map() for sti frame buffers.
 */
#define	STI_MEMSIZE		0x0003f000	/* XXX */
d102 4
d107 1
a107 1
	sc->memt = sc->iot = HP300_BUS_TAG(HP300_BUS_SGC, saa->saa_slot);
d110 22
a131 1
	if (bus_space_map(sc->iot, sc->base, STI_MEMSIZE, 0, &sc->romh)) {
d136 3
d164 1
a164 1
	if (bus_space_map(iot, (bus_addr_t)sgc_slottopa(slot), STI_MEMSIZE, 0,
d170 1
a170 1
	bus_space_unmap(iot, ioh, STI_MEMSIZE);
@

