head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.12
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.8
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.6
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.10
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.6
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.12
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.4
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.1.0.18
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.16
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.14
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.12
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.10
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.14;

1.14
date	2011.08.18.19.54.18;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.14.17.54.45;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.06.20.17.43;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.06.20.09.12;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.16.20.44.23;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.16.21.37.02;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.12.23.09.14;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.27.22.05.36;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.10.20.17.54;	author millert;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	97.07.06.08.01.50;	author downsj;	state Exp;
branches
	1.1.12.1;
next	;

1.1.12.1
date	2001.07.04.10.15.27;	author niklas;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: frodo.c,v 1.14 2011/08/18 19:54:18 miod Exp $	*/
/*	$NetBSD: frodo.c,v 1.5 1999/07/31 21:15:20 thorpej Exp $	*/

/*-
 * Copyright (c) 1997, 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997 Michael Smith.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Support for the "Frodo" (a.k.a. "Apollo Utility") chip found
 * in HP Apollo 9000/4xx workstations, as well as HP 9000/382.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/hp300spu.h>

#include <hp300/dev/intiovar.h>

#include <hp300/dev/frodoreg.h>
#include <hp300/dev/frodovar.h>

#include "isabr.h"

#if NISABR > 0
#include <uvm/uvm_extern.h>

#include <dev/isa/isareg.h>
#include <hp300/dev/isabrreg.h>
#endif

struct frodo_softc {
	struct device	sc_dev;		/* generic device glue */
	volatile u_int8_t *sc_regs;	/* register base */
	struct isr	*sc_intr[FRODO_NINTR]; /* interrupt handlers */
	struct isr	sc_isr;		/* main interrupt handler */
	u_int		sc_refcnt;	/* number of interrupt refs */
};

int	frodomatch(struct device *, void *, void *);
void	frodoattach(struct device *, struct device *, void *);

int	frodoprint(void *, const char *);
int	frodosubmatch(struct device *, void *, void *);

int	frodointr(void *);
void	frodo_imask(struct frodo_softc *, u_int16_t, u_int16_t);
int	frodo_isa_exists(void);
void	frodo_state(struct frodo_softc *);

struct cfattach frodo_ca = {
	sizeof(struct frodo_softc), frodomatch, frodoattach
};

struct cfdriver frodo_cd = {
	NULL, "frodo", DV_DULL
};

struct frodo_attach_args frodo_subdevs[] = {
	{ "dnkbd",	NULL,	FRODO_APCI_OFFSET(0),	FRODO_INTR_APCI0 },
	{ "apci",	NULL,	FRODO_APCI_OFFSET(1),	FRODO_INTR_APCI1 },
	{ "apci",	NULL,	FRODO_APCI_OFFSET(2),	FRODO_INTR_APCI2 },
	{ "apci",	NULL,	FRODO_APCI_OFFSET(3),	FRODO_INTR_APCI3 },
	{ NULL,		NULL,	0,			0 },
};

#define	FRODO_IPL	5

int
frodomatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct intio_attach_args *ia = aux;
	caddr_t va;
	static int frodo_matched = 0;

	/* only allow one instance */
	if (frodo_matched)
		return (0);

	/* only specific workstations can have this */
	switch (machineid) {
	case HP_382:
	case HP_400:
	case HP_425:
	case HP_433:
		break;

	default:
		return (0);
	}

	/* make sure the hardware is there in any case */
	va = (caddr_t)IIOV(FRODO_BASE);
	if (badaddr(va))
		return (0);

	frodo_matched = 1;
	ia->ia_addr = (caddr_t)FRODO_BASE;
	return (1);
}

void
frodoattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct frodo_softc *sc = (struct frodo_softc *)self;
	struct intio_attach_args *ia = aux;
	int i;

	sc->sc_regs = (volatile u_int8_t *)IIOV(ia->ia_addr);

	printf(" ipl %d", FRODO_IPL);
	if ((FRODO_READ(sc, FRODO_IISR) & FRODO_IISR_SERVICE) == 0)
		printf(": service mode enabled");
	printf("\n");

	/* Clear all of the interrupt handlers. */
	bzero(sc->sc_intr, sizeof(sc->sc_intr));

	/*
	 * Disable all of the interrupt lines; we reenable them
	 * as subdevices attach.
	 */
	frodo_imask(sc, 0, 0xffff);

	/* Clear any pending interrupts. */
	FRODO_WRITE(sc, FRODO_PIC_PU, 0xff);
	FRODO_WRITE(sc, FRODO_PIC_PL, 0xff);

	/* Set interrupt polarities... */
	FRODO_WRITE(sc, FRODO_PIO_IPR, 0x10);

	/* ...and configure 1-5 for edge triggering. */
	FRODO_WRITE(sc, FRODO_PIO_IELR, 0xc1);

	/* Initialize IVR high half to zero so we don't need to mask it later */
	FRODO_WRITE(sc, FRODO_PIC_IVR, 0x00);

	/* Mask ISA interrupts until an ISA interrupt handler is registered. */
	FRODO_WRITE(sc, FRODO_PIO_ISA_CONTROL, 0x80);

	/*
	 * We defer hooking up our interrupt handler until
	 * a subdevice hooks up theirs.
	 */
	sc->sc_refcnt = 0;

	/* ... and attach subdevices. */
	for (i = 0; frodo_subdevs[i].fa_name != NULL; i++) {
		/*
		 * Skip the first serial port if we're not a 425e;
		 * it's mapped to the DCA at select code 9 on all
		 * other models.
		 */
		if (frodo_subdevs[i].fa_offset == FRODO_APCI_OFFSET(1) &&
		    mmuid != MMUID_425_E)
			continue;
		frodo_subdevs[i].fa_tag = ia->ia_tag;
		config_found_sm(self, &frodo_subdevs[i],
		    frodoprint, frodosubmatch);
	}

#if NISABR > 0
	/*
	 * Only attempt to attach the isa bridge if it exists on this
	 * machine.
	 */
	if (frodo_isa_exists()) {
		struct frodo_attach_args fa;

		fa.fa_name = "isabr";
		fa.fa_tag = ia->ia_tag;
		fa.fa_offset = fa.fa_line = 0;
		config_found_sm(self, &fa, frodoprint, frodosubmatch);
	}
#endif
}

int
frodosubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct frodo_attach_args *fa = aux;

	if (cf->frodocf_offset != FRODO_UNKNOWN_OFFSET &&
	    cf->frodocf_offset != fa->fa_offset)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

int
frodoprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct frodo_attach_args *fa = aux;

	if (pnp)
		printf("%s at %s", fa->fa_name, pnp);
	printf(" offset 0x%x", fa->fa_offset);
	return (UNCONF);
}

int
frodo_intr_establish(struct device *frdev, int line, struct isr *isr,
    const char *name)
{
	struct frodo_softc *sc = (struct frodo_softc *)frdev;
	int priority = isr->isr_priority;

	if (line <= 0 || line >= FRODO_NINTR) {
		panic("%s: bad interrupt line %d",
		    sc->sc_dev.dv_xname, line);
	}
	if (sc->sc_intr[line] != NULL) {
#ifdef DEBUG
		printf("%s: interrupt line %d already used\n",
		    sc->sc_dev.dv_xname, line);
#endif
		return (EPERM);
	}

	/*
	 * If this is the first one, establish the frodo
	 * interrupt handler.  If not, reestablish at a
	 * higher priority if necessary.
	 */
	if (sc->sc_isr.isr_priority < priority) {
		if (sc->sc_refcnt != 0)
			intr_disestablish(&sc->sc_isr);
		sc->sc_isr.isr_func = frodointr;
		sc->sc_isr.isr_arg = sc;
		sc->sc_isr.isr_ipl = FRODO_IPL;
		sc->sc_isr.isr_priority = priority;
		intr_establish(&sc->sc_isr, sc->sc_dev.dv_xname);
	}

	sc->sc_refcnt++;

	/* Install the handler. */
	isr->isr_ipl = sc->sc_isr.isr_ipl;
	evcount_attach(&isr->isr_count, name, &isr->isr_ipl);
	sc->sc_intr[line] = isr;

	/* Enable the interrupt line. */
	frodo_imask(sc, FRODO_INTR_BIT(line), 0);

#if NISABR > 0
	/* Unmask ISA interrupts if necessary. */
	if (FRODO_INTR_ISA(line))
		FRODO_WRITE(sc, FRODO_PIO_ISA_CONTROL, 0x00);
#endif

	return (0);
}

void
frodo_intr_disestablish(frdev, line)
	struct device *frdev;
	int line;
{
	struct frodo_softc *sc = (struct frodo_softc *)frdev;
	int newpri;

#ifdef DIAGNOSTIC
	if (sc->sc_intr[line] == NULL) {
		printf("%s(%s): no handler for line %d",
		    sc->sc_dev.dv_xname, __func__, line);
		return;
	}
#endif

	sc->sc_intr[line] = NULL;
	frodo_imask(sc, 0, FRODO_INTR_BIT(line));

#if NISABR > 0
	/* Mask ISA interrupts if necessary. */
	if (FRODO_INTR_ISA(line)) {
		if (sc->sc_intr[FRODO_INTR_ILOW] == NULL &&
		    sc->sc_intr[FRODO_INTR_IMID] == NULL &&
		    sc->sc_intr[FRODO_INTR_IHI] == NULL)
			FRODO_WRITE(sc, FRODO_PIO_ISA_CONTROL, 0x80);
	}
#endif

	/* If this was the last, unhook ourselves. */
	if (sc->sc_refcnt-- == 1) {
		intr_disestablish(&sc->sc_isr);
		return;
	}

	/* Lower our priority, if appropriate. */
	for (newpri = 0, line = 0; line < FRODO_NINTR; line++)
		if (sc->sc_intr[line] != NULL &&
		    sc->sc_intr[line]->isr_priority > newpri)
			newpri = sc->sc_intr[line]->isr_priority;

	if (newpri != sc->sc_isr.isr_priority) {
		intr_disestablish(&sc->sc_isr);
		sc->sc_isr.isr_func = frodointr;
		sc->sc_isr.isr_arg = sc;
		sc->sc_isr.isr_ipl = FRODO_IPL;
		sc->sc_isr.isr_priority = newpri;
		intr_establish(&sc->sc_isr, sc->sc_dev.dv_xname);
	}
}

int
frodointr(arg)
	void *arg;
{
	struct frodo_softc *sc = arg;
	struct isr *fisr;
	int pending, line, rc = 0;

#ifdef DEBUG
	frodo_state(sc);
#endif

	/* Any interrupts pending? */
	while ((pending = FRODO_GETPEND(sc)) != 0) {
		rc++;

		/*
		 * Get pending interrupt; this also clears it for us.
		 */
		line = FRODO_READ(sc, FRODO_PIC_ACK) /* & 0x0f */;

		fisr = sc->sc_intr[line];
		if (fisr == NULL) {
			printf("%s: unhandled interrupt on line %d\n",
			    sc->sc_dev.dv_xname, line);
#ifdef DEBUG
			/* Disable interrupt source */
			frodo_imask(sc, 0, FRODO_INTR_BIT(line));
#endif
		} else {
			if ((*fisr->isr_func)(fisr->isr_arg) != 0) {
				fisr->isr_count.ec_count++;
			} else {
				printf("%s: spurious interrupt on line %d\n",
				    sc->sc_dev.dv_xname, line);
			}
		}

		if (rc > 100)
			panic("frodointr: looping, pending %x line %d fisr %p",
			    pending, line, fisr);

#ifdef DEBUG
		frodo_state(sc);
#endif
	}

	return (rc);
}

void
frodo_imask(sc, set, clear)
	struct frodo_softc *sc;
	u_int16_t set, clear;
{
	u_int16_t imask;

	imask = FRODO_GETMASK(sc);

	imask |= set;
	imask &= ~clear;

	FRODO_SETMASK(sc, imask);
}

#ifdef DEBUG
void
frodo_state(struct frodo_softc *sc)
{
	int i;

	printf("%s state:", sc->sc_dev.dv_xname);
	for (i = 0xc0; i < 0x100; i += 4) {
		printf(" %02x", FRODO_READ(sc, i));
		if (i == 0xcc || i == 0xdc || i == 0xec)
			printf(" /");
	}
	printf("\n");
}
#endif

#if NISABR > 0
int
frodo_isa_exists()
{
	vaddr_t va;
	int rv;

	va = uvm_km_valloc(kernel_map, PAGE_SIZE);
	if (va == NULL)
		return (0);

	/*
	 * Check that the iomem space answers probes
	 */
	pmap_kenter_cache(va, ISABR_IOMEM_BASE, PG_RW | PG_CI);
	pmap_update(pmap_kernel());
	rv = badbaddr((caddr_t)va);
	pmap_kremove(va, PAGE_SIZE);
	pmap_update(pmap_kernel());

	/*
	 * Check that the ioport space answers probes
	 */
	pmap_kenter_cache(va, ISABR_IOPORT_BASE, PG_RW | PG_CI);
	pmap_update(pmap_kernel());
	rv |= badbaddr((caddr_t)va);
	pmap_kremove(va, PAGE_SIZE);
	pmap_update(pmap_kernel());

	uvm_km_free(kernel_map, va, PAGE_SIZE);

	return (!rv);
}
#endif
@


1.14
log
@Because model 362 does not have an SGC bus (or a blind, deaf and mute one),
there is no way we can tell models 360 and 362 apart by probing for an SGC
bus, or for a frodo(4) chip since of the `lil' black swan' 3x2 models, only
model 382 has frodo. So don't bother trying to tell models 360 and 362
apart, and use a common 36X symbol. No functional change except for useless
code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.13 2010/09/20 06:33:47 matthew Exp $	*/
@


1.13
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.12 2008/06/26 05:42:10 ray Exp $	*/
d60 1
a60 1
 * in HP Apollo 9000/4xx workstations, as well as HP 9000/362 and 9000/382.
a139 1
	case HP_362:
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.11 2007/01/14 17:54:45 miod Exp $	*/
d305 1
a305 1
	evcount_attach(&isr->isr_count, name, &isr->isr_ipl, &evcount_intr);
@


1.11
log
@Move the isa bridge probe from isabr to frodo, so that frodo only attempts
to attach isabr if it really exists. This gets rid of ``isabr0 not configured''
messages on 425e.
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.10 2007/01/06 20:17:43 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@Preliminary support for the hp300 single ISA slot found in 4xx `t' models.
Everything works well but interrupts, where no two devices causes the frodo
chip to behave in the same way... (polling will work nicely)
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.9 2007/01/06 20:09:12 miod Exp $	*/
d88 7
d110 2
a113 2
void	frodo_imask(struct frodo_softc *, u_int16_t, u_int16_t);

a126 1
	{ "isabr",	NULL,	0,			0 },
d229 15
d351 1
a351 1
		    sc->sc_intr[FRODO_INTR_IHIGH] == NULL)
d456 35
@


1.9
log
@Propagate bus_space_tag_t through device attachment args structures, rather
than having them build their own. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.8 2006/06/16 20:44:23 miod Exp $	*/
d86 2
d93 1
a93 1
	int		sc_refcnt;	/* number of interrupt refs */
d103 1
d120 1
d191 1
a191 1
	/* Set interrupt polarities. */
d194 8
a201 2
	/* ...and configure for edge triggering. */
	FRODO_WRITE(sc, FRODO_PIO_IELR, 0xcf);
d253 1
a253 1
void
d265 2
a266 1
		panic("%s: interrupt line %d already used",
d268 2
d295 9
a303 1
	frodo_imask(sc, (1 << line), 0);
d314 1
d316 3
a318 2
		panic("%s: no handler for line %d",
		    sc->sc_dev.dv_xname, line);
d320 1
d323 11
a333 1
	frodo_imask(sc, 0, (1 << line));
d363 5
a367 1
	int line, taken = 0;
d370 2
a371 2
	if (FRODO_GETPEND(sc) == 0)
		return (0);
a372 1
	do {
d376 2
a377 1
		line = FRODO_IPEND(sc);
d382 4
a393 3
		if (taken++ > 100)
			panic("frodointr: looping, line %d fisr %p", line, fisr);
	} while (FRODO_GETPEND(sc) != 0);
d395 10
a404 1
	return (1);
d421 16
@


1.8
log
@Line 0 is not wired, thus illegal for use in frodo_intr_establish().
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.7 2005/11/16 21:37:02 miod Exp $	*/
d76 1
d113 5
a117 5
	{ "dnkbd",	FRODO_APCI_OFFSET(0),	FRODO_INTR_APCI0 },
	{ "apci",	FRODO_APCI_OFFSET(1),	FRODO_INTR_APCI1 },
	{ "apci",	FRODO_APCI_OFFSET(2),	FRODO_INTR_APCI2 },
	{ "apci",	FRODO_APCI_OFFSET(3),	FRODO_INTR_APCI3 },
	{ NULL,		0,			0 },
d135 1
a135 1
	/* only 4xx workstations can have this */
d209 1
@


1.7
log
@Mention ipl in dmesg, for consistency with other devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.6 2005/11/12 23:09:14 miod Exp $	*/
d248 1
a248 1
	if (line < 0 || line >= FRODO_NINTR) {
@


1.6
log
@Provide useful information if we panic due to looping interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.5 2005/09/27 22:05:36 miod Exp $	*/
d119 2
d168 1
d267 1
a267 1
		sc->sc_isr.isr_ipl = 5;
d315 1
a315 1
		sc->sc_isr.isr_ipl = 5;
@


1.5
log
@Identify HP 9000/362 and HP 9000/382 models, and attach frodo on them.
Model 382 can be identified with a unique MMUID value; model 362 is told
from model 360 by probing for the frodo chip. Their built-in frame buffer
is not supported at the moment.

Matching information derived from messages to the NetBSD mailing lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.4 2004/09/29 07:35:52 miod Exp $	*/
d348 1
a348 1
			panic("frodointr: looping!");
@


1.4
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.3 2002/03/14 01:26:30 millert Exp $	*/
d67 1
a67 1
 * in HP Apollo 9000/4xx workstations.
d134 2
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.2 2001/05/10 20:17:54 millert Exp $	*/
a69 2
#define	_HP300_INTR_H_PRIVATE

a84 9
/*
 * Description of a Frodo interrupt handler.
 */
struct frodo_isr {
	int	(*isr_func)(void *);
	void	*isr_arg;
	int	isr_priority;
};

d88 2
a89 2
	struct frodo_isr sc_intr[FRODO_NINTR]; /* interrupt handlers */
	void		*sc_ih;		/* out interrupt cookie */
a169 1
	sc->sc_refcnt = 0;
d191 1
a191 1
	sc->sc_ih = NULL;
d237 2
a238 6
frodo_intr_establish(frdev, func, arg, line, priority)
	struct device *frdev;
	int (*func)(void *);
	void *arg;
	int line;
	int priority;
d241 1
a241 1
	struct isr *isr = sc->sc_ih;
d244 1
a244 1
		printf("%s: bad interrupt line %d\n",
a245 1
		goto lose;
d247 2
a248 2
	if (sc->sc_intr[line].isr_func != NULL) {
		printf("%s: interrupt line %d already used\n",
a249 1
		goto lose;
a251 5
	/* Install the handler. */
	sc->sc_intr[line].isr_func = func;
	sc->sc_intr[line].isr_arg = arg;
	sc->sc_intr[line].isr_priority = priority;

d257 8
a264 4
	if (isr == NULL || isr->isr_priority < priority) {
		if (isr != NULL)
			intr_disestablish(isr);
		sc->sc_ih = intr_establish(frodointr, sc, 5, priority);
d269 5
a275 3
	return;
 lose:
	panic("frodo_intr_establish");
a283 1
	struct isr *isr = sc->sc_ih;
d286 2
a287 2
	if (sc->sc_intr[line].isr_func == NULL) {
		printf("%s: no handler for line %d\n",
a288 1
		panic("frodo_intr_disestablish");
d291 1
a291 1
	sc->sc_intr[line].isr_func = NULL;
d296 1
a296 1
		intr_disestablish(isr);
d302 11
a312 7
		if (sc->sc_intr[line].isr_func != NULL &&
		    sc->sc_intr[line].isr_priority > newpri)
			newpri = sc->sc_intr[line].isr_priority;

	if (newpri != isr->isr_priority) {
		intr_disestablish(isr);
		sc->sc_ih = intr_establish(frodointr, sc, 5, newpri);
d321 1
a321 1
	struct frodo_isr *fisr;
d333 3
a335 4
		fisr = &sc->sc_intr[line];
		if (fisr->isr_func == NULL ||
		    (*fisr->isr_func)(fisr->isr_arg) == 0)
			printf("%s: spurious interrupt on line %d\n",
d337 8
@


1.2
log
@Skip "serial 1" on non-425e models.  It's mapped to DCA at 9 on every
other 4xx model, and the "not configured" could be pretty annoying.
This means we can nuke apcicheckdca() and just key off being a 425e.
Also, ia->ia_addr is a physical address, not a kernel virtual address;
thorpej@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.1 1997/07/06 08:01:50 downsj Exp $	*/
d91 1
a91 1
	int	(*isr_func) __P((void *));
d104 2
a105 2
int	frodomatch __P((struct device *, void *, void *));
void	frodoattach __P((struct device *, struct device *, void *));
d107 2
a108 2
int	frodoprint __P((void *, const char *));
int	frodosubmatch __P((struct device *, void *, void *));
d110 1
a110 1
int	frodointr __P((void *));
d112 1
a112 1
void	frodo_imask __P((struct frodo_softc *, u_int16_t, u_int16_t));
d251 1
a251 1
	int (*func) __P((void *));
@


1.2.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: frodo.c,v 1.2 2001/05/10 20:17:54 millert Exp $	*/
d91 1
a91 1
	int	(*isr_func)(void *);
d104 2
a105 2
int	frodomatch(struct device *, void *, void *);
void	frodoattach(struct device *, struct device *, void *);
d107 2
a108 2
int	frodoprint(void *, const char *);
int	frodosubmatch(struct device *, void *, void *);
d110 1
a110 1
int	frodointr(void *);
d112 1
a112 1
void	frodo_imask(struct frodo_softc *, u_int16_t, u_int16_t);
d251 1
a251 1
	int (*func)(void *);
@


1.1
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 38
a38 2
/*	$OpenBSD$	*/
/*	$NetBSD: frodo.c,v 1.1 1997/05/12 08:03:48 thorpej Exp $	*/
a40 1
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
d160 1
a160 1
	ia->ia_addr = va;
d173 1
a173 1
	sc->sc_regs = (volatile u_int8_t *)ia->ia_addr;
d206 9
a214 1
	for (i = 0; frodo_subdevs[i].fa_name != NULL; i++)
d217 1
@


1.1.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d2 1
a2 37
/*	$NetBSD: frodo.c,v 1.5 1999/07/31 21:15:20 thorpej Exp $	*/

/*-
 * Copyright (c) 1997, 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d5 1
d125 1
a125 1
	ia->ia_addr = (caddr_t)FRODO_BASE;
d138 1
a138 1
	sc->sc_regs = (volatile u_int8_t *)IIOV(ia->ia_addr);
d171 1
a171 9
	for (i = 0; frodo_subdevs[i].fa_name != NULL; i++) {
		/*
		 * Skip the first serial port if we're not a 425e;
		 * it's mapped to the DCA at select code 9 on all
		 * other models.
		 */
		if (frodo_subdevs[i].fa_offset == FRODO_APCI_OFFSET(1) &&
		    mmuid != MMUID_425_E)
			continue;
a173 1
	}
@


1.1.12.2
log
@Merge in -current from about a week ago
@
text
@d91 1
a91 1
	int	(*isr_func)(void *);
d104 2
a105 2
int	frodomatch(struct device *, void *, void *);
void	frodoattach(struct device *, struct device *, void *);
d107 2
a108 2
int	frodoprint(void *, const char *);
int	frodosubmatch(struct device *, void *, void *);
d110 1
a110 1
int	frodointr(void *);
d112 1
a112 1
void	frodo_imask(struct frodo_softc *, u_int16_t, u_int16_t);
d251 1
a251 1
	int (*func)(void *);
@


