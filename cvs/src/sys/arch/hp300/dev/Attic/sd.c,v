head	1.34;
access;
symbols
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.26
	UBC:1.23.0.4
	UBC_BASE:1.23
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9:1.21.0.14
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.21.0.12
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.21.0.10
	OPENBSD_2_7_BASE:1.21
	SMP:1.21.0.8
	SMP_BASE:1.21
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.6
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.21.0.4
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2004.08.03.21.46.56;	author miod;	state dead;
branches;
next	1.33;

1.33
date	2004.02.15.02.56.13;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.03.05.34.43;	author david;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.15.20.32.13;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.06.15.28.25;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2002.12.25.20.56.59;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.25.20.40.36;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.09.05.23.26;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.30.11.03.52;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.26.00.15.37;	author miod;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2001.05.31.10.22.35;	author art;	state Exp;
branches;
next	1.21;

1.21
date	98.10.04.01.02.25;	author millert;	state Exp;
branches
	1.21.8.1;
next	1.20;

1.20
date	98.10.03.21.18.57;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.05.07.05.19.33;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.05.02.05.36.58;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.05.02.05.04.44;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.04.30.04.55.46;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.04.25.00.38.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.03.27.07.47.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.03.06.22.52.42;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.07.13.09.48.00;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.07.06.08.01.56;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.04.16.11.56.15;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.02.10.06.43.34;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.02.10.01.33.57;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.02.03.04.47.47;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.12.15.13.03;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.11.47.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.25.06.36.55;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.20.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.21;	author deraadt;	state Exp;
branches;
next	;

1.21.8.1
date	2001.07.04.10.15.35;	author niklas;	state Exp;
branches;
next	1.21.8.2;

1.21.8.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.21.8.3;

1.21.8.3
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.21.8.4;

1.21.8.4
date	2003.03.27.23.19.20;	author niklas;	state Exp;
branches;
next	1.21.8.5;

1.21.8.5
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.21.8.6;

1.21.8.6
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.21.8.7;

1.21.8.7
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.21.8.8;

1.21.8.8
date	2004.06.05.23.10.46;	author niklas;	state Exp;
branches;
next	;

1.23.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Replace the old 4.4BSD scsi code used on hp300 with a ``real'' driver
interfaced with the MI scsi code.

Adapted from NetBSD with some changes (especially to get tape and old
cd-rom drives to not cause the driver to spin during probe).

Tested by millert@@ and I, ok millert@@
@
text
@/*	$OpenBSD: sd.c,v 1.33 2004/02/15 02:56:13 tedu Exp $	*/
/*	$NetBSD: sd.c,v 1.34 1997/07/10 18:14:10 kleink Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson of Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sd.c	8.5 (Berkeley) 5/19/94
 */

/*
 * SCSI CCS (Command Command Set) disk driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/stat.h>

#include <ufs/ffs/fs.h>			/* for BBSIZE and SBSIZE */

#include <sys/conf.h>

#include <hp300/dev/scsireg.h>
#include <hp300/dev/scsivar.h>
#include <hp300/dev/sdvar.h>

#ifdef USELEDS
#include <hp300/hp300/leds.h>
#endif

int	sdmatch(struct device *, void *, void *);
void	sdattach(struct device *, struct device *, void *);

struct cfattach sd_ca = {
	sizeof(struct sd_softc), sdmatch, sdattach
};

struct cfdriver sd_cd = {
	NULL, "sd", DV_DISK
};

#ifdef DEBUG
int sddebug = 1;
#define SDB_ERROR	0x01
#define SDB_PARTIAL	0x02
#define SDB_CAPACITY	0x04
#endif

static struct scsi_fmt_cdb sd_read_cmd = { 10, { CMD_READ_EXT } };
static struct scsi_fmt_cdb sd_write_cmd = { 10, { CMD_WRITE_EXT } };

/*
 * Table of scsi commands users are allowed to access via "format"
 * mode.  0 means not legal.  1 means "immediate" (doesn't need dma).
 * -1 means needs dma and/or wait for intr.
 */
static char legal_cmds[256] = {
/*****  0   1   2   3   4   5   6   7     8   9   A   B   C   D   E   F */
/*00*/	0,  0,  0,  0, -1,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*10*/	0,  0,  1,  0,  0,  1,  0,  0,    0,  0,  1,  0,  0,  0,  0,  0,
/*20*/	0,  0,  0,  0,  0,  1,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*30*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*40*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*50*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*60*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*70*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*80*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*90*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*a0*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*b0*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*c0*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*d0*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*e0*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
/*f0*/	0,  0,  0,  0,  0,  0,  0,  0,    0,  0,  0,  0,  0,  0,  0,  0,
};

bdev_decl(sd);
cdev_decl(sd);

void	sdreset(struct sd_softc *);

static void 	sdgetgeom(struct sd_softc *);
static void	sdlblkstrat(struct buf *, int);
static int	sderror(struct sd_softc *, int);
static void	sdfinish(struct sd_softc *, struct buf *);

/*
 * Perform a mode-sense on page 0x04 (rigid geometry).
 */
static void
sdgetgeom(sc)
	struct sd_softc *sc;
{
	struct scsi_mode_sense_geom {
		struct scsi_modesense_hdr	header;
		struct scsi_geometry		geom;
	} sensebuf;
	struct scsi_fmt_cdb modesense_geom;
	int ctlr, slave, unit;

	/* XXX - if we try to do this in the declaration gcc uses memset() */
	bzero(&modesense_geom, sizeof(modesense_geom));
	modesense_geom.len = 6;
	modesense_geom.cdb[0] = CMD_MODE_SENSE;
	modesense_geom.cdb[2] = 0x04;
	modesense_geom.cdb[4] = sizeof(sensebuf);

	ctlr = sc->sc_dev.dv_parent->dv_unit;
	slave = sc->sc_target;
	unit = sc->sc_lun;

	scsi_delay(-1);		/* XXX */
	(void)scsi_immed_command(ctlr, slave, unit, &modesense_geom,
	    (u_char *)&sensebuf, sizeof(sensebuf), B_READ);
	scsi_delay(0);		/* XXX */

	sc->sc_heads = sensebuf.geom.heads;
	sc->sc_cyls = (sensebuf.geom.cyl_ub << 16) |
	    (sensebuf.geom.cyl_mb << 8) | sensebuf.geom.cyl_lb;
}

int
sdmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct oscsi_attach_args *osa = aux;

	switch (osa->osa_inqbuf->type) {
	case 0:		/* disk */
	case 4:		/* WORM */
	case 5:		/* CD-ROM */
	case 7:		/* Magneto-optical */
		break;
	default:	/* not a disk */
		return 0;
	}

	return (1);
}

void
sdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct sd_softc *sc = (struct sd_softc *)self;
	struct oscsi_attach_args *osa = aux;

	/*
	 * XXX formerly 0 meant unused but now pid 0 can legitimately
	 * use this interface (sdgetcapacity).
	 */
	sc->sc_format_pid = -1;
	sc->sc_flags = 0;

	sc->sc_target = osa->osa_target;
	sc->sc_lun = osa->osa_lun;
	sc->sc_type = osa->osa_inqbuf->type;

	if (osa->osa_inqbuf->qual & 0x80)
		sc->sc_flags |= SDF_RMEDIA;

	printf("\n");

	/* Initialize the SCSI queue entry. */
	sc->sc_sq.sq_softc = sc;
	sc->sc_sq.sq_target = sc->sc_target;
	sc->sc_sq.sq_lun = sc->sc_lun;
	sc->sc_sq.sq_start = sdstart;
	sc->sc_sq.sq_go = sdgo;
	sc->sc_sq.sq_intr = sdintr;

	if (sdgetcapacity(sc, NODEV) < 0) {
		printf("%s: getcapacity failed!\n", sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Print out some additional information.
	 */
	printf("%s: ", sc->sc_dev.dv_xname);
	switch (sc->sc_type) {
	case 4:	
		printf("WORM, ");
		break;

	case 5:
		printf("CD-ROM, ");
		break;

	case 7:
		printf("Magneto-optical, ");
		break;

	default:
		printf("%d cylinders, %d heads, ",
		    sc->sc_cyls, sc->sc_heads);
	}
	if (sc->sc_blks)
		printf("%d blocks, %d bytes/block\n",
		    sc->sc_blks >> sc->sc_bshift, sc->sc_blksize);
	else
		printf("drive empty\n");

	/* Initialize the disk structure. */
	sc->sc_dkdev.dk_name = sc->sc_dev.dv_xname;

	/* Attach the disk. */
	disk_attach(&sc->sc_dkdev);

	dk_establish(&sc->sc_dkdev, &sc->sc_dev);	/* XXX */

	sc->sc_flags |= SDF_ALIVE;
}

void
sdreset(sc)
	struct sd_softc *sc;
{
	sc->sc_stats.sdresets++;
}

/*
 * Determine capacity of a drive.
 * Returns -1 on a failure, 0 on success, 1 on a failure that is probably
 * due to missing media.
 */
int
sdgetcapacity(sc, dev)
	struct sd_softc *sc;
	dev_t dev;
{
	static struct scsi_fmt_cdb cap = {
		10,
		{ CMD_READ_CAPACITY, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
	};
	u_char *capbuf;
	int i, capbufsize;

	/*
	 * Cannot use stack space for this buffer since stack KVA may not
	 * be valid (i.e. in context of this process) when the operation
	 * actually starts.
	 */
	capbufsize = 8;
	capbuf = malloc(capbufsize, M_DEVBUF, M_WAITOK);

	if (dev == NODEV) {
		scsi_delay(-1);		/* XXX */
		i = scsi_immed_command(sc->sc_dev.dv_parent->dv_unit,
		    sc->sc_target, sc->sc_lun, &cap, capbuf,
		    capbufsize, B_READ);
		scsi_delay(0);		/* XXX */
	} else {
		struct buf *bp;

		/*
		 * XXX this is horrible
		 */
		if (sc->sc_format_pid >= 0)
			panic("sdgetcapacity");
		bp = malloc(sizeof *bp, M_DEVBUF, M_WAITOK);
		sc->sc_format_pid = curproc->p_pid;
		bcopy(&cap, &sc->sc_cmdstore, sizeof cap);
		bp->b_dev = dev;
		bp->b_flags = B_READ | B_BUSY;
		bp->b_un.b_addr = (caddr_t)capbuf;
		bp->b_bcount = capbufsize;
		LIST_INIT(&bp->b_dep);
		sdstrategy(bp);
		i = biowait(bp) ? sc->sc_sensestore.status : 0;
		free(bp, M_DEVBUF);
		sc->sc_format_pid = -1;
	}
	if (i) {
		if (i != STS_CHECKCOND || (sc->sc_flags & SDF_RMEDIA) == 0) {
#ifdef DEBUG
			if (sddebug & SDB_CAPACITY)
				printf("%s: read_capacity returns %d\n",
				       sc->sc_dev.dv_xname, i);
#endif
			free(capbuf, M_DEVBUF);
			return (-1);
		}
		/*
		 * XXX assume unformatted or non-existent media
		 */
		sc->sc_blks = 0;
		sc->sc_blksize = DEV_BSIZE;
		sc->sc_bshift = 0;
#ifdef DEBUG
		if (sddebug & SDB_CAPACITY)
			printf("%s: removable media not present\n",
			       sc->sc_dev.dv_xname);
#endif
		free(capbuf, M_DEVBUF);
		return (1);
	}
	sc->sc_blks = *(u_int *)&capbuf[0];
	sc->sc_blksize = *(int *)&capbuf[4];
	free(capbuf, M_DEVBUF);
	sc->sc_bshift = 0;

	/* return value of read capacity is last valid block number */
	sc->sc_blks++;

	if (sc->sc_blksize != DEV_BSIZE) {
		if (sc->sc_blksize < DEV_BSIZE) {
			printf("%s: need at least %d byte blocks - %s\n",
			    sc->sc_dev.dv_xname, DEV_BSIZE, "drive ignored");
			return (-1);
		}
		for (i = sc->sc_blksize; i > DEV_BSIZE; i >>= 1)
			++sc->sc_bshift;
		sc->sc_blks <<= sc->sc_bshift;
	}
#ifdef DEBUG
	if (sddebug & SDB_CAPACITY)
		printf("%s: blks=%d, blksize=%d, bshift=%d\n",
		    sc->sc_dev.dv_xname, sc->sc_blks, sc->sc_blksize,
		    sc->sc_bshift);
#endif
	sc->sc_heads = sc->sc_cyls = 0;
	sdgetgeom(sc);
	return (0);
}

/*
 * Read or constuct a disklabel
 */
int
sdgetinfo(dev, sc, lp, spoofonly)
	dev_t dev;
	struct sd_softc *sc;
	struct disklabel *lp;
	int spoofonly;
{
	char *errstring;

	bzero((caddr_t)lp, sizeof *lp);
	errstring = NULL;

	/*
	 * If removable media or the size unavailable at boot time
	 * (i.e. unformatted hard disk), attempt to set the capacity
	 * now.
	 */
	if ((sc->sc_flags & SDF_RMEDIA) || sc->sc_blks == 0) {
		switch (sdgetcapacity(sc, dev)) {
		case 0:
			break;
		case -1:
			/*
			 * Hard error, just return (open will fail).
			 */
			return (EIO);
		case 1:
			/*
			 * XXX return 0 so open can continue just in case
			 * the media is unformatted and we want to format it.
			 * We set the error flag so they cannot do much else.
			 */
			sc->sc_flags |= SDF_ERROR;
			/* XXX set magic here or it will never be set */
			lp->d_magic = DISKMAGIC;
			lp->d_magic2 = DISKMAGIC;
			errstring = "unformatted/missing media";
			break;
		}
	}

	/*
	 * Create a default disk label based on scsi info.
	 * This will get overridden if there is a real label on the disk.
	 */
	if (errstring == NULL) {
		/* XXX we can open a device even without SDF_ALIVE */
		if (sc->sc_blksize == 0)
			sc->sc_blksize = DEV_BSIZE;

		/* Fill in info from disk geometry if it exists. */
		lp->d_secperunit = sc->sc_blks >> sc->sc_bshift;
		if (lp->d_secperunit > 0 && sc->sc_heads > 0 && sc->sc_cyls > 0) {
			lp->d_ntracks = sc->sc_heads;
			lp->d_ncylinders = sc->sc_cyls;
			lp->d_nsectors = lp->d_secperunit /
			    (lp->d_ntracks * lp->d_ncylinders);
			/*
			 * We must make sure d_nsectors is a sane value.
			 * Adjust d_ncylinders to be reasonable if we 
			 * monkey with d_nsectors.
			 */
			if (lp->d_nsectors < 1) {
				lp->d_nsectors = 32;
				lp->d_ncylinders = lp->d_secperunit /
				    ( lp->d_ntracks * lp->d_nsectors);
				if (lp->d_ncylinders == 0)
					lp->d_ncylinders = sc->sc_cyls;
			}
		} else {
			lp->d_ntracks = 20;
			lp->d_ncylinders = 1;
			lp->d_nsectors = 32;
		}

		switch (sc->sc_type) {
		case 4:	
			strncpy(lp->d_typename, "SCSI WORM", sizeof lp->d_typename);
			break;
		case 5:
			strncpy(lp->d_typename, "SCSI CD-ROM", sizeof lp->d_typename);
			break;
		case 7:
			strncpy(lp->d_typename, "SCSI optical", sizeof lp->d_typename);
			break;
		default:
			strncpy(lp->d_typename, "SCSI disk", sizeof lp->d_typename);
			break;
		}
		lp->d_type = DTYPE_SCSI;
		strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
		lp->d_secsize = sc->sc_blksize;
		lp->d_secpercyl = lp->d_nsectors * lp->d_ntracks;
		lp->d_rpm = 3600;
		lp->d_interleave = 1;

		/* XXX - these values for BBSIZE and SBSIZE assume ffs */
		lp->d_bbsize = BBSIZE;
		lp->d_sbsize = SBSIZE;

		lp->d_partitions[RAW_PART].p_offset = 0;
		if (lp->d_secperunit > 0)
			lp->d_partitions[RAW_PART].p_size =
			    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
		else
			lp->d_partitions[RAW_PART].p_size =
			    roundup(LABELSECTOR+1, btodb(sc->sc_blksize));
		lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
		lp->d_npartitions = RAW_PART + 1;

		lp->d_magic = DISKMAGIC;
		lp->d_magic2 = DISKMAGIC;
		lp->d_checksum = dkcksum(lp);

		errstring = readdisklabel(SDLABELDEV(dev), sdstrategy, lp, NULL,
		    spoofonly);
	}

	if (errstring) {
		printf("%s: WARNING: %s, defining `c' partition as entire disk\n",
		    sc->sc_dev.dv_xname, errstring);
		/* XXX reset partition info as readdisklabel screws with it */
		lp->d_partitions[0].p_size = 0;
		lp->d_partitions[RAW_PART].p_offset = 0;
		lp->d_partitions[RAW_PART].p_size =
		    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
		lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
		lp->d_npartitions = RAW_PART + 1;
		lp->d_checksum = dkcksum(lp);
	}

	return(0);
}

int
sdopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = SDUNIT(dev);
	struct sd_softc *sc;
	int error, mask, part;

	if (unit >= sd_cd.cd_ndevs ||
	    (sc = sd_cd.cd_devs[unit]) == NULL ||
	    (sc->sc_flags & SDF_ALIVE) == 0)
		return (ENXIO);

	/*
	 * Wait for any pending opens/closes to complete
	 */
	while (sc->sc_flags & (SDF_OPENING|SDF_CLOSING))
		tsleep((caddr_t)sc, PRIBIO, "sdopen", 0);

	/*
	 * On first open, get label and partition info.
	 * We may block reading the label, so be careful
	 * to stop any other opens.
	 */
	if (sc->sc_dkdev.dk_openmask == 0) {
		sc->sc_flags |= SDF_OPENING;
		error = sdgetinfo(dev, sc, sc->sc_dkdev.dk_label, 0);
		sc->sc_flags &= ~SDF_OPENING;
		wakeup((caddr_t)sc);
		if (error)
			return(error);
	}

	part = SDPART(dev);
	mask = 1 << part;

	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part >= sc->sc_dkdev.dk_label->d_npartitions ||
	     sc->sc_dkdev.dk_label->d_partitions[part].p_fstype == FS_UNUSED))
		return (ENXIO);

	/* Ensure only one open at a time. */
	switch (mode) {
	case S_IFCHR:
		sc->sc_dkdev.dk_copenmask |= mask;
		break;
	case S_IFBLK:
		sc->sc_dkdev.dk_bopenmask |= mask;
		break;
	}
	sc->sc_dkdev.dk_openmask =
	    sc->sc_dkdev.dk_copenmask | sc->sc_dkdev.dk_bopenmask;

	return(0);
}

int
sdclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = SDUNIT(dev);
	struct sd_softc *sc = sd_cd.cd_devs[unit];
	struct disk *dk = &sc->sc_dkdev;
	int mask, s;

	mask = 1 << SDPART(dev);
	if (mode == S_IFCHR)
		dk->dk_copenmask &= ~mask;
	else
		dk->dk_bopenmask &= ~mask;
	dk->dk_openmask = dk->dk_copenmask | dk->dk_bopenmask;
	/*
	 * On last close, we wait for all activity to cease since
	 * the label/parition info will become invalid.  Since we
	 * might sleep, we must block any opens while we are here.
	 * Note we don't have to about other closes since we know
	 * we are the last one.
	 */
	if (dk->dk_openmask == 0) {
		sc->sc_flags |= SDF_CLOSING;
		s = splbio();
		while (sc->sc_tab.b_active) {
			sc->sc_flags |= SDF_WANTED;
			tsleep((caddr_t)&sc->sc_tab, PRIBIO, "sdclose", 0);
		}
		splx(s);
		sc->sc_flags &= ~(SDF_CLOSING|SDF_ERROR);
		wakeup((caddr_t)sc);
	}
	sc->sc_format_pid = -1;
	return(0);
}

/*
 * This routine is called for partial block transfers and non-aligned
 * transfers (the latter only being possible on devices with a block size
 * larger than DEV_BSIZE).  The operation is performed in three steps
 * using a locally allocated buffer:
 *	1. transfer any initial partial block
 *	2. transfer full blocks
 *	3. transfer any final partial block
 */
static void
sdlblkstrat(bp, bsize)
	struct buf *bp;
	int bsize;
{
	struct sd_softc *sc = sd_cd.cd_devs[SDUNIT(bp->b_dev)];
	struct buf *cbp = (struct buf *)malloc(sizeof(struct buf),
							M_DEVBUF, M_WAITOK);
	caddr_t cbuf = (caddr_t)malloc(bsize, M_DEVBUF, M_WAITOK);
	int bn, resid;
	caddr_t addr;

	bzero((caddr_t)cbp, sizeof(*cbp));
	cbp->b_proc = curproc;		/* XXX */
	cbp->b_dev = bp->b_dev;
	LIST_INIT(&cbp->b_dep);
	bn = bp->b_blkno;
	resid = bp->b_bcount;
	addr = bp->b_un.b_addr;
#ifdef DEBUG
	if (sddebug & SDB_PARTIAL)
		printf("sdlblkstrat: bp %p flags %lx bn %x resid %x addr %p\n",
		       bp, bp->b_flags, bn, resid, addr);
#endif

	while (resid > 0) {
		int boff = dbtob(bn) & (bsize - 1);
		int count;

		if (boff || resid < bsize) {
			sc->sc_stats.sdpartials++;
			count = min(resid, bsize - boff);
			cbp->b_flags = B_BUSY | B_PHYS | B_READ;
			cbp->b_blkno = bn - btodb(boff);
			cbp->b_un.b_addr = cbuf;
			cbp->b_bcount = bsize;
#ifdef DEBUG
			if (sddebug & SDB_PARTIAL)
				printf(" readahead: bn %x cnt %x off %x addr %p\n",
				       cbp->b_blkno, count, boff, addr);
#endif
			sdstrategy(cbp);
			biowait(cbp);
			if (cbp->b_flags & B_ERROR) {
				bp->b_flags |= B_ERROR;
				bp->b_error = cbp->b_error;
				break;
			}
			if (bp->b_flags & B_READ) {
				bcopy(&cbuf[boff], addr, count);
				goto done;
			}
			bcopy(addr, &cbuf[boff], count);
#ifdef DEBUG
			if (sddebug & SDB_PARTIAL)
				printf(" writeback: bn %x cnt %x off %x addr %p\n",
				       cbp->b_blkno, count, boff, addr);
#endif
		} else {
			count = resid & ~(bsize - 1);
			cbp->b_blkno = bn;
			cbp->b_un.b_addr = addr;
			cbp->b_bcount = count;
#ifdef DEBUG
			if (sddebug & SDB_PARTIAL)
				printf(" fulltrans: bn %x cnt %x addr %p\n",
				       cbp->b_blkno, count, addr);
#endif
		}
		cbp->b_flags = B_BUSY | B_PHYS | (bp->b_flags & B_READ);
		sdstrategy(cbp);
		biowait(cbp);
		if (cbp->b_flags & B_ERROR) {
			bp->b_flags |= B_ERROR;
			bp->b_error = cbp->b_error;
			break;
		}
done:
		bn += btodb(count);
		resid -= count;
		addr += count;
#ifdef DEBUG
		if (sddebug & SDB_PARTIAL)
			printf(" done: bn %x resid %x addr %p\n",
			       bn, resid, addr);
#endif
	}
	free(cbuf, M_DEVBUF);
	free(cbp, M_DEVBUF);
}

void
sdstrategy(bp)
	struct buf *bp;
{
	int unit = SDUNIT(bp->b_dev);
	struct sd_softc *sc = sd_cd.cd_devs[unit];
	struct buf *dp = &sc->sc_tab;
	struct partition *pinfo;
	daddr_t bn;
	int sz, s;
	int offset;

	if (sc->sc_format_pid >= 0) {
		if (sc->sc_format_pid != curproc->p_pid) {	/* XXX */
			bp->b_error = EPERM;
			goto bad;
		}
		bp->b_cylin = 0;
	} else {
		if (sc->sc_flags & SDF_ERROR) {
			bp->b_error = EIO;
			goto bad;
		}
		bn = bp->b_blkno;
		sz = howmany(bp->b_bcount, DEV_BSIZE);
		pinfo = &sc->sc_dkdev.dk_label->d_partitions[SDPART(bp->b_dev)];

		/* Don't perform partition translation on RAW_PART. */
		offset = (SDPART(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;

		if (SDPART(bp->b_dev) != RAW_PART) {
			/*
			 * XXX This block of code belongs in
			 * XXX bounds_check_with_label()
			 */

			if (bn < 0 || bn + sz > pinfo->p_size) {
				sz = pinfo->p_size - bn;
				if (sz == 0) {
					bp->b_resid = bp->b_bcount;
					goto done;
				}
				if (sz < 0) {
					bp->b_error = EINVAL;
					goto bad;
				}
				bp->b_bcount = dbtob(sz);
			}
			/*
			 * Check for write to write protected label
			 */
			if (bn + offset <= LABELSECTOR &&
#if LABELSECTOR != 0
			    bn + offset + sz > LABELSECTOR &&
#endif
			    !(bp->b_flags & B_READ) &&
			    !(sc->sc_flags & SDF_WLABEL)) {
				bp->b_error = EROFS;
				goto bad;
			}
		}
		/*
		 * Non-aligned or partial-block transfers handled specially.
		 */
		s = sc->sc_blksize - 1;
		if ((dbtob(bn) & s) || (bp->b_bcount & s)) {
			sdlblkstrat(bp, sc->sc_blksize);
			goto done;
		}
		bp->b_cylin = (bn + offset) >> sc->sc_bshift;
	}
	s = splbio();
	disksort(dp, bp);
	if (dp->b_active == 0) {
		dp->b_active = 1;
		sdustart(unit);
	}
	splx(s);
	return;
bad:
	bp->b_flags |= B_ERROR;
done:
	s = splbio();
	biodone(bp);
	splx(s);
}

void
sdustart(unit)
	int unit;
{
	struct sd_softc *sc = sd_cd.cd_devs[unit];

	if (scsireq(sc->sc_dev.dv_parent, &sc->sc_sq))
		sdstart(sc);
}

/*
 * Return:
 *	0	if not really an error
 *	<0	if we should do a retry
 *	>0	if a fatal error
 */
static int
sderror(sc, stat)
	struct sd_softc *sc;
	int stat;
{
	int cond = 1;

	sc->sc_sensestore.status = stat;
	if (stat & STS_CHECKCOND) {
		struct scsi_xsense *sp;

		scsi_request_sense(sc->sc_dev.dv_parent->dv_unit,
		    sc->sc_target, sc->sc_lun, sc->sc_sensestore.sense,
		    sizeof(sc->sc_sensestore.sense));
		sp = (struct scsi_xsense *)(sc->sc_sensestore.sense);
		printf("%s: scsi sense class %d, code %d", sc->sc_dev.dv_xname,
			sp->class, sp->code);
		if (sp->class == 7) {
			printf(", key %d", sp->key);
			if (sp->valid)
				printf(", blk %d", *(int *)&sp->info1);
			switch (sp->key) {
			/* no sense, try again */
			case 0:
				cond = -1;
				break;
			/* recovered error, not a problem */
			case 1:
				cond = 0;
				break;
			/* possible media change */
			case 6:
				/*
				 * For removable media, if we are doing the
				 * first open (i.e. reading the label) go
				 * ahead and retry, otherwise someone has
				 * changed the media out from under us and
				 * we should abort any further operations
				 * until a close is done.
				 */
				if (sc->sc_flags & SDF_RMEDIA) {
					if (sc->sc_flags & SDF_OPENING)
						cond = -1;
					else
						sc->sc_flags |= SDF_ERROR;
				}
				break;
			}
		}
		printf("\n");
	}
	return(cond);
}

static void
sdfinish(sc, bp)
	struct sd_softc *sc;
	struct buf *bp;
{
	struct buf *dp = &sc->sc_tab;

	dp->b_errcnt = 0;
	dp->b_actf = bp->b_actf;
	bp->b_resid = 0;
	biodone(bp);
	scsifree(sc->sc_dev.dv_parent, &sc->sc_sq);
	if (dp->b_actf)
		sdustart(sc->sc_dev.dv_unit);
	else {
		dp->b_active = 0;
		if (sc->sc_flags & SDF_WANTED) {
			sc->sc_flags &= ~SDF_WANTED;
			wakeup((caddr_t)dp);
		}
	}
}

void
sdstart(arg)
	void *arg;
{
	struct sd_softc *sc = arg;

	/*
	 * we have the SCSI bus -- in format mode, we may or may not need dma
	 * so check now.
	 */
	if (sc->sc_format_pid >= 0 && legal_cmds[sc->sc_cmdstore.cdb[0]] > 0) {
		struct buf *bp = sc->sc_tab.b_actf;
		int sts;

		sc->sc_tab.b_errcnt = 0;
		while (1) {
			sts = scsi_immed_command(sc->sc_dev.dv_parent->dv_unit,
			    sc->sc_target, sc->sc_lun, &sc->sc_cmdstore,
			    bp->b_un.b_addr, bp->b_bcount,
			    bp->b_flags & B_READ);
			sc->sc_sensestore.status = sts;
			if ((sts & 0xfe) == 0 ||
			    (sts = sderror(sc, sts)) == 0)
				break;
			if (sts > 0 || sc->sc_tab.b_errcnt++ >= SDRETRY) {
				bp->b_flags |= B_ERROR;
				bp->b_error = EIO;
				break;
			}
		}
		sdfinish(sc, bp);

	} else if (scsiustart(sc->sc_dev.dv_parent->dv_unit))
		sdgo(sc);
}

void
sdgo(arg)
	void *arg;
{
	struct sd_softc *sc = arg;
	struct buf *bp = sc->sc_tab.b_actf;
	int pad;
	struct scsi_fmt_cdb *cmd;

	if (sc->sc_format_pid >= 0) {
		cmd = &sc->sc_cmdstore;
		pad = 0;
	} else {
		/*
		 * Drive is in an error state, abort all operations
		 */
		if (sc->sc_flags & SDF_ERROR) {
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
			sdfinish(sc, bp);
			return;
		}
		cmd = bp->b_flags & B_READ? &sd_read_cmd : &sd_write_cmd;
		*(int *)(&cmd->cdb[2]) = bp->b_cylin;
		pad = howmany(bp->b_bcount, sc->sc_blksize);
		*(u_short *)(&cmd->cdb[7]) = pad;
		pad = (bp->b_bcount & (sc->sc_blksize - 1)) != 0;
#ifdef DEBUG
		if (pad)
			printf("%s: partial block xfer -- %lx bytes\n",
			       sc->sc_dev.dv_xname, bp->b_bcount);
#endif
		sc->sc_stats.sdtransfers++;
	}
#ifdef USELEDS
	ledcontrol(0, 0, LED_DISK);
#endif
	if (scsigo(sc->sc_dev.dv_parent->dv_unit, sc->sc_target, sc->sc_lun,
	    bp, cmd, pad) == 0) {
		/* Instrumentation. */
		disk_busy(&sc->sc_dkdev);
		sc->sc_dkdev.dk_seek++;		/* XXX */
		return;
	}
#ifdef DEBUG
	if (sddebug & SDB_ERROR)
		printf("%s: sdstart: %s adr %p blk %ld len %ld ecnt %ld\n",
		       sc->sc_dev.dv_xname,
		       bp->b_flags & B_READ? "read" : "write",
		       bp->b_un.b_addr, bp->b_cylin, bp->b_bcount,
		       sc->sc_tab.b_errcnt);
#endif
	bp->b_flags |= B_ERROR;
	bp->b_error = EIO;
	sdfinish(sc, bp);
}

void
sdintr(arg, stat)
	void *arg;
	int stat;
{
	struct sd_softc *sc = arg;
	struct buf *bp = sc->sc_tab.b_actf;
	int cond;
	
	if (bp == NULL) {
		printf("%s: bp == NULL\n", sc->sc_dev.dv_xname);
		return;
	}

	disk_unbusy(&sc->sc_dkdev, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));

	if (stat) {
#ifdef DEBUG
		if (sddebug & SDB_ERROR)
			printf("%s: sdintr: bad scsi status 0x%x\n",
				sc->sc_dev.dv_xname, stat);
#endif
		cond = sderror(sc, stat);
		if (cond) {
			if (cond < 0 && sc->sc_tab.b_errcnt++ < SDRETRY) {
#ifdef DEBUG
				if (sddebug & SDB_ERROR)
					printf("%s: retry #%ld\n",
					    sc->sc_dev.dv_xname,
					    sc->sc_tab.b_errcnt);
#endif
				sdstart(sc);
				return;
			}
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
		}
	}
	sdfinish(sc, bp);
}

int
sdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = SDUNIT(dev);
	struct sd_softc *sc = sd_cd.cd_devs[unit];
	int pid;

	if ((pid = sc->sc_format_pid) >= 0 &&
	    pid != uio->uio_procp->p_pid)
		return (EPERM);
		
	return (physio(sdstrategy, NULL, dev, B_READ, minphys, uio));
}

int
sdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = SDUNIT(dev);
	struct sd_softc *sc = sd_cd.cd_devs[unit];
	int pid;

	if ((pid = sc->sc_format_pid) >= 0 &&
	    pid != uio->uio_procp->p_pid)
		return (EPERM);
		
	return (physio(sdstrategy, NULL, dev, B_WRITE, minphys, uio));
}

int
sdioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = SDUNIT(dev);
	struct sd_softc *sc = sd_cd.cd_devs[unit];
	struct disklabel *lp = sc->sc_dkdev.dk_label;
	int error, flags;

	switch (cmd) {
	case DIOCGPDINFO:
		error = sdgetinfo(dev, sc, (struct disklabel *)data, 1);
		return (error);

	case DIOCGDINFO:
		*(struct disklabel *)data = *lp;
		return (0);

	case DIOCGPART:
		((struct partinfo *)data)->disklab = lp;
		((struct partinfo *)data)->part =
			&lp->d_partitions[SDPART(dev)];
		return (0);

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return (EBADF);
		if (*(int *)data)
			sc->sc_flags |= SDF_WLABEL;
		else
			sc->sc_flags &= ~SDF_WLABEL;
		return (0);

	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);
		error = setdisklabel(lp, (struct disklabel *)data,
				     (sc->sc_flags & SDF_WLABEL) ? 0
				     : sc->sc_dkdev.dk_openmask,
				     (struct cpu_disklabel *)0);
		return (error);

	case DIOCWDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);
		error = setdisklabel(lp, (struct disklabel *)data,
				     (sc->sc_flags & SDF_WLABEL) ? 0
				     : sc->sc_dkdev.dk_openmask,
				     (struct cpu_disklabel *)0);
		if (error)
			return (error);
		flags = sc->sc_flags;
		sc->sc_flags = SDF_ALIVE | SDF_WLABEL;
		error = writedisklabel(SDLABELDEV(dev), sdstrategy, lp,
				      (struct cpu_disklabel *)0);
		sc->sc_flags = flags;
		return (error);

	case SDIOCSFORMAT:
		/* take this device into or out of "format" mode */
		if (suser(p, 0))
			return(EPERM);

		if (*(int *)data) {
			if (sc->sc_format_pid >= 0)
				return (EPERM);
			sc->sc_format_pid = p->p_pid;
		} else
			sc->sc_format_pid = -1;
		return (0);

	case SDIOCGFORMAT:
		/* find out who has the device in format mode */
		*(int *)data = sc->sc_format_pid;
		return (0);

	case SDIOCSCSICOMMAND:
		/*
		 * Save what user gave us as SCSI cdb to use with next
		 * read or write to the char device.
		 */
		if (sc->sc_format_pid != p->p_pid)
			return (EPERM);
		if (legal_cmds[((struct scsi_fmt_cdb *)data)->cdb[0]] == 0)
			return (EINVAL);
		bcopy(data, &sc->sc_cmdstore, sizeof(struct scsi_fmt_cdb));
		return (0);

	case SDIOCSENSE:
		/*
		 * return the SCSI sense data saved after the last
		 * operation that completed with "check condition" status.
		 */
		bcopy(&sc->sc_sensestore, data, sizeof(sc->sc_sensestore));
		return (0);

	default:
		return (EINVAL);
		
	}
	/*NOTREACHED*/
}

int
sdsize(dev)
	dev_t dev;
{
	int unit = SDUNIT(dev);
	struct sd_softc *sc = sd_cd.cd_devs[unit];
	int psize, didopen = 0;

	if (unit >= sd_cd.cd_ndevs ||
	    (sc = sd_cd.cd_devs[unit]) == NULL ||
	    (sc->sc_flags & SDF_ALIVE) == 0)
		return (-1);

	/*
	 * We get called very early on (via swapconf)
	 * without the device being open so we may need
	 * to handle it here.
	 */
	if (sc->sc_dkdev.dk_openmask == 0) {
		if (sdopen(dev, FREAD|FWRITE, S_IFBLK, NULL))
			return(-1);
		didopen = 1;
	}
	psize = sc->sc_dkdev.dk_label->d_partitions[SDPART(dev)].p_size *
	    (sc->sc_dkdev.dk_label->d_secsize / DEV_BSIZE);
	if (didopen)
		(void) sdclose(dev, FREAD|FWRITE, S_IFBLK, NULL);
	return (psize);
}

static int sddoingadump;	/* simple mutex */

/*
 * Non-interrupt driven, non-dma dump routine.
 */
int
sddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{
	int sectorsize;		/* size of a disk sector */
	int nsects;		/* number of sectors in partition */
	int sectoff;		/* sector offset of partition */
	int totwrt;		/* total number of sectors left to write */
	int nwrt;		/* current number of sectors to write */
	int unit, part;
	struct sd_softc *sc;
	struct disklabel *lp;
	char stat;

	/* Check for recursive dump; if so, punt. */
	if (sddoingadump)
		return (EFAULT);
	sddoingadump = 1;

	/* Decompose unit and partition. */
	unit = SDUNIT(dev);
	part = SDPART(dev);

	/* Make sure device is ok. */
	if (unit >= sd_cd.cd_ndevs ||
	    (sc = sd_cd.cd_devs[unit]) == NULL ||
	    (sc->sc_flags & SDF_ALIVE) == 0)
		return (ENXIO);

	/*
	 * Convert to disk sectors.  Request must be a multiple of size.
	 */
	lp = sc->sc_dkdev.dk_label;
	sectorsize = lp->d_secsize;
	if ((size % sectorsize) != 0)
		return (EFAULT);
	totwrt = size / sectorsize;
	blkno = dbtob(blkno) / sectorsize;	/* blkno in DEV_BSIZE units */

	nsects = lp->d_partitions[part].p_size;
	sectoff = lp->d_partitions[part].p_offset;

	/* Check transfer bounds against partition size. */
	if ((blkno < 0) || (blkno + totwrt) > nsects)
		return (EINVAL);

	/* Offset block number to start of partition. */
	blkno += sectoff;

	while (totwrt > 0) {
		nwrt = totwrt;		/* XXX */
#ifndef SD_DUMP_NOT_TRUSTED
		/*
		 * Send the data.  Note the `0' argument for bshift;
		 * we've done the necessary conversion above.
		 */
		stat = scsi_tt_write(sc->sc_dev.dv_parent->dv_unit,
		    sc->sc_target, sc->sc_lun, va, nwrt * sectorsize,
		    blkno, 0);
		if (stat) {
			printf("\nsddump: scsi write error 0x%x\n", stat);
			return (EIO);
		}
#else /* SD_DUMP_NOT_TRUSTED */
		/* Lets just talk about it first. */
		printf("%s: dump addr %p, blk %d\n", sc->sc_dev.dv_xname,
		    va, blkno);
		delay(500 * 1000);	/* half a second */
#endif /* SD_DUMP_NOT_TRUSTED */

		/* update block count */
		totwrt -= nwrt;
		blkno += nwrt;
		va += sectorsize * nwrt;
	}
	sddoingadump = 0;
	return (0);
}
@


1.33
log
@sneaky disk_unbusy()'s tried to hide
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.32 2003/11/03 05:34:43 david Exp $	*/
@


1.32
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.31 2003/08/15 20:32:13 tedu Exp $	*/
d987 2
a988 1
	disk_unbusy(&sc->sc_dkdev, (bp->b_bcount - bp->b_resid));
@


1.31
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.30 2003/06/02 23:27:45 millert Exp $	*/
d323 1
a323 1
		 * XXX assume unformatted or non-existant media
@


1.30
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.29 2003/04/06 15:28:25 krw Exp $	*/
d1112 1
a1112 1
		if (suser(p->p_ucred, &p->p_acflag))
@


1.29
log
@Some easy strcpy elimination.

a) strcpy -> strncpy for copies into disklabel fields d_packname and
d_typename.

b) '16' -> 'sizeof d_packname' or 'sizeof d_typename' in existing
strncpy's.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.28 2002/12/25 20:56:59 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.28
log
@Turn xxUNIT, xxPARt, xxLABELDEV macro names into uppercase.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.27 2002/12/25 20:40:36 miod Exp $	*/
d449 1
a449 1
			strcpy(lp->d_typename, "SCSI WORM");
d452 1
a452 1
			strcpy(lp->d_typename, "SCSI CD-ROM");
d455 1
a455 1
			strcpy(lp->d_typename, "SCSI optical");
d458 1
a458 1
			strcpy(lp->d_typename, "SCSI disk");
d462 1
a462 1
		strcpy(lp->d_packname, "fictitious");
@


1.27
log
@Get prototypes from *dev_decl() macros rather than running our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.26 2002/06/09 05:23:26 miod Exp $	*/
d486 1
a486 1
		errstring = readdisklabel(sdlabdev(dev), sdstrategy, lp, NULL,
d512 1
a512 1
	int unit = sdunit(dev);
d541 1
a541 1
	part = sdpart(dev);
d571 1
a571 1
	int unit = sdunit(dev);
d576 1
a576 1
	mask = 1 << sdpart(dev);
d618 1
a618 1
	struct sd_softc *sc = sd_cd.cd_devs[sdunit(bp->b_dev)];
d708 1
a708 1
	int unit = sdunit(bp->b_dev);
d729 1
a729 1
		pinfo = &sc->sc_dkdev.dk_label->d_partitions[sdpart(bp->b_dev)];
d732 1
a732 1
		offset = (sdpart(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;
d734 1
a734 1
		if (sdpart(bp->b_dev) != RAW_PART) {
d1024 1
a1024 1
	int unit = sdunit(dev);
d1041 1
a1041 1
	int unit = sdunit(dev);
d1060 1
a1060 1
	int unit = sdunit(dev);
d1077 1
a1077 1
			&lp->d_partitions[sdpart(dev)];
d1109 1
a1109 1
		error = writedisklabel(sdlabdev(dev), sdstrategy, lp,
d1163 1
a1163 1
	int unit = sdunit(dev);
d1182 1
a1182 1
	psize = sc->sc_dkdev.dk_label->d_partitions[sdpart(dev)].p_size *
d1217 2
a1218 2
	unit = sdunit(dev);
	part = sdpart(dev);
@


1.26
log
@convert sleep() calls to tsleep().
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.25 2002/05/30 11:03:52 art Exp $	*/
d61 2
a70 7
/*
extern void disksort();
extern void biodone();
extern int physio();
extern void TBIS();
*/

d117 2
a118 5
/* bdev_decl(sd); */
/* cdev_decl(sd); */
/* XXX we should use macros to do these... */
int	sdopen(dev_t, int, int, struct proc *);
int	sdclose(dev_t, int, int, struct proc *);
a119 2
int	sdioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	sdread(dev_t, struct uio *, int);
a120 5
int	sdwrite(dev_t, struct uio *, int);

void	sdstrategy(struct buf *);
int	sddump(dev_t, daddr_t, caddr_t, size_t);
int	sdsize(dev_t);
@


1.25
log
@protect biodone with splbio.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.24 2002/03/14 01:26:30 millert Exp $	*/
d540 1
a540 1
		sleep((caddr_t)sc, PRIBIO);
d609 1
a609 1
			sleep((caddr_t)&sc->sc_tab, PRIBIO);
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.23 2001/08/26 00:15:37 miod Exp $	*/
d801 1
d803 1
@


1.23
log
@Nuke annoying defopt, by popular demand. Plus you get two typos fixed
for free.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.22 2001/05/31 10:22:35 art Exp $	*/
d76 2
a77 2
int	sdmatch __P((struct device *, void *, void *));
void	sdattach __P((struct device *, struct device *, void *));
d125 2
a126 2
int	sdopen __P((dev_t, int, int, struct proc *));
int	sdclose __P((dev_t, int, int, struct proc *));
d128 13
a140 13
int	sdioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	sdread __P((dev_t, struct uio *, int));
void	sdreset __P((struct sd_softc *));
int	sdwrite __P((dev_t, struct uio *, int));

void	sdstrategy __P((struct buf *));
int	sddump __P((dev_t, daddr_t, caddr_t, size_t));
int	sdsize __P((dev_t));

static void 	sdgetgeom __P((struct sd_softc *));
static void	sdlblkstrat __P((struct buf *, int));
static int	sderror __P((struct sd_softc *, int));
static void	sdfinish __P((struct sd_softc *, struct buf *));
@


1.23.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.23 2001/08/26 00:15:37 miod Exp $	*/
d76 2
a77 2
int	sdmatch(struct device *, void *, void *);
void	sdattach(struct device *, struct device *, void *);
d125 2
a126 2
int	sdopen(dev_t, int, int, struct proc *);
int	sdclose(dev_t, int, int, struct proc *);
d128 13
a140 13
int	sdioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	sdread(dev_t, struct uio *, int);
void	sdreset(struct sd_softc *);
int	sdwrite(dev_t, struct uio *, int);

void	sdstrategy(struct buf *);
int	sddump(dev_t, daddr_t, caddr_t, size_t);
int	sdsize(dev_t);

static void 	sdgetgeom(struct sd_softc *);
static void	sdlblkstrat(struct buf *, int);
static int	sderror(struct sd_softc *, int);
static void	sdfinish(struct sd_softc *, struct buf *);
d540 1
a540 1
		tsleep((caddr_t)sc, PRIBIO, "sdopen", 0);
d609 1
a609 1
			tsleep((caddr_t)&sc->sc_tab, PRIBIO, "sdclose", 0);
a800 1
	s = splbio();
a801 1
	splx(s);
@


1.23.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a60 2
#include <sys/conf.h>

d69 7
d122 5
a126 2
bdev_decl(sd);
cdev_decl(sd);
d128 2
d131 5
d464 1
a464 1
			strncpy(lp->d_typename, "SCSI WORM", sizeof lp->d_typename);
d467 1
a467 1
			strncpy(lp->d_typename, "SCSI CD-ROM", sizeof lp->d_typename);
d470 1
a470 1
			strncpy(lp->d_typename, "SCSI optical", sizeof lp->d_typename);
d473 1
a473 1
			strncpy(lp->d_typename, "SCSI disk", sizeof lp->d_typename);
d477 1
a477 1
		strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
d501 1
a501 1
		errstring = readdisklabel(SDLABELDEV(dev), sdstrategy, lp, NULL,
d527 1
a527 1
	int unit = SDUNIT(dev);
d556 1
a556 1
	part = SDPART(dev);
d586 1
a586 1
	int unit = SDUNIT(dev);
d591 1
a591 1
	mask = 1 << SDPART(dev);
d633 1
a633 1
	struct sd_softc *sc = sd_cd.cd_devs[SDUNIT(bp->b_dev)];
d723 1
a723 1
	int unit = SDUNIT(bp->b_dev);
d744 1
a744 1
		pinfo = &sc->sc_dkdev.dk_label->d_partitions[SDPART(bp->b_dev)];
d747 1
a747 1
		offset = (SDPART(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;
d749 1
a749 1
		if (SDPART(bp->b_dev) != RAW_PART) {
d1039 1
a1039 1
	int unit = SDUNIT(dev);
d1056 1
a1056 1
	int unit = SDUNIT(dev);
d1075 1
a1075 1
	int unit = SDUNIT(dev);
d1092 1
a1092 1
			&lp->d_partitions[SDPART(dev)];
d1124 1
a1124 1
		error = writedisklabel(SDLABELDEV(dev), sdstrategy, lp,
d1178 1
a1178 1
	int unit = SDUNIT(dev);
d1197 1
a1197 1
	psize = sc->sc_dkdev.dk_label->d_partitions[SDPART(dev)].p_size *
d1232 2
a1233 2
	unit = SDUNIT(dev);
	part = SDPART(dev);
@


1.22
log
@Initialize b_dep if we malloc our own struct buf.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.21 1998/10/04 01:02:25 millert Exp $	*/
a63 2

#include "opt_useleds.h"
@


1.21
log
@Add DIOCGPDINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.20 1998/10/03 21:18:57 millert Exp $	*/
d327 1
d645 1
@


1.21.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.21 1998/10/04 01:02:25 millert Exp $	*/
a326 1
		LIST_INIT(&bp->b_dep);
a643 1
	LIST_INIT(&cbp->b_dep);
@


1.21.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.21.8.1 2001/07/04 10:15:35 niklas Exp $	*/
d64 2
@


1.21.8.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 2
a77 2
int	sdmatch(struct device *, void *, void *);
void	sdattach(struct device *, struct device *, void *);
d125 2
a126 2
int	sdopen(dev_t, int, int, struct proc *);
int	sdclose(dev_t, int, int, struct proc *);
d128 13
a140 13
int	sdioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	sdread(dev_t, struct uio *, int);
void	sdreset(struct sd_softc *);
int	sdwrite(dev_t, struct uio *, int);

void	sdstrategy(struct buf *);
int	sddump(dev_t, daddr_t, caddr_t, size_t);
int	sdsize(dev_t);

static void 	sdgetgeom(struct sd_softc *);
static void	sdlblkstrat(struct buf *, int);
static int	sderror(struct sd_softc *, int);
static void	sdfinish(struct sd_softc *, struct buf *);
@


1.21.8.4
log
@Sync the SMP branch with 3.3
@
text
@a60 2
#include <sys/conf.h>

d69 7
d122 5
a126 2
bdev_decl(sd);
cdev_decl(sd);
d128 2
d131 5
d501 1
a501 1
		errstring = readdisklabel(SDLABELDEV(dev), sdstrategy, lp, NULL,
d527 1
a527 1
	int unit = SDUNIT(dev);
d540 1
a540 1
		tsleep((caddr_t)sc, PRIBIO, "sdopen", 0);
d556 1
a556 1
	part = SDPART(dev);
d586 1
a586 1
	int unit = SDUNIT(dev);
d591 1
a591 1
	mask = 1 << SDPART(dev);
d609 1
a609 1
			tsleep((caddr_t)&sc->sc_tab, PRIBIO, "sdclose", 0);
d633 1
a633 1
	struct sd_softc *sc = sd_cd.cd_devs[SDUNIT(bp->b_dev)];
d723 1
a723 1
	int unit = SDUNIT(bp->b_dev);
d744 1
a744 1
		pinfo = &sc->sc_dkdev.dk_label->d_partitions[SDPART(bp->b_dev)];
d747 1
a747 1
		offset = (SDPART(bp->b_dev) == RAW_PART) ? 0 : pinfo->p_offset;
d749 1
a749 1
		if (SDPART(bp->b_dev) != RAW_PART) {
a800 1
	s = splbio();
a801 1
	splx(s);
d1037 1
a1037 1
	int unit = SDUNIT(dev);
d1054 1
a1054 1
	int unit = SDUNIT(dev);
d1073 1
a1073 1
	int unit = SDUNIT(dev);
d1090 1
a1090 1
			&lp->d_partitions[SDPART(dev)];
d1122 1
a1122 1
		error = writedisklabel(SDLABELDEV(dev), sdstrategy, lp,
d1176 1
a1176 1
	int unit = SDUNIT(dev);
d1195 1
a1195 1
	psize = sc->sc_dkdev.dk_label->d_partitions[SDPART(dev)].p_size *
d1230 2
a1231 2
	unit = SDUNIT(dev);
	part = SDPART(dev);
@


1.21.8.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.21.8.4 2003/03/27 23:19:20 niklas Exp $	*/
d449 1
a449 1
			strncpy(lp->d_typename, "SCSI WORM", sizeof lp->d_typename);
d452 1
a452 1
			strncpy(lp->d_typename, "SCSI CD-ROM", sizeof lp->d_typename);
d455 1
a455 1
			strncpy(lp->d_typename, "SCSI optical", sizeof lp->d_typename);
d458 1
a458 1
			strncpy(lp->d_typename, "SCSI disk", sizeof lp->d_typename);
d462 1
a462 1
		strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
@


1.21.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.21.8.5 2003/05/13 19:41:02 ho Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.21.8.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d323 1
a323 1
		 * XXX assume unformatted or non-existent media
d1112 1
a1112 1
		if (suser(p, 0))
@


1.21.8.8
log
@Merge with the trunk
@
text
@d987 1
a987 2
	disk_unbusy(&sc->sc_dkdev, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
@


1.20
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.19 1998/05/07 05:19:33 millert Exp $	*/
d389 1
a389 1
sdgetinfo(dev)
d391 3
a394 3
	int unit = sdunit(dev);
	struct sd_softc *sc = sd_cd.cd_devs[unit];
	struct disklabel *lp = sc->sc_dkdev.dk_label;
d502 2
a503 1
		errstring = readdisklabel(sdlabdev(dev), sdstrategy, lp, NULL, 0);
d550 1
a550 1
		error = sdgetinfo(dev);
d1079 4
@


1.19
log
@don't clear *_WLABEL on close so 'disklabel -W' is persistent like in the generic scsi system
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.18 1998/05/02 05:36:58 millert Exp $	*/
d502 1
a502 1
		errstring = readdisklabel(sdlabdev(dev), sdstrategy, lp, NULL);
@


1.18
log
@If computed value for d_nsectors truncated to 0, set it to 32 and
adjust d_ncylinders instead of just setting d_nsectors to 1 (which
is not useful for putting a filesystem on a device).
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.17 1998/05/02 05:04:44 millert Exp $	*/
d612 1
a612 1
		sc->sc_flags &= ~(SDF_CLOSING|SDF_WLABEL|SDF_ERROR);
@


1.17
log
@Fix problem with zip drive correctly this time.  The real deal is
that the hp300 scsi subsystem does not glean d_secpercyl from the
device so we have to calculate a reasonable value.  In the case of
a zip drive, the calculated value gets truncated to zero.  This change
adds a sanity check and forces the calculated d_secpercyl to be >= 1.
Also includes some minor code reorg.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.16 1998/04/30 04:55:46 millert Exp $	*/
d445 12
a456 2
			if (lp->d_nsectors < 1)
				lp->d_nsectors = 1;	/* must be >= 1 */
@


1.16
log
@Only use scsi geometry to fake up a label if we were able to get
the capacity.  Fixes a panic with fictitious labels on zip drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.15 1998/04/25 00:38:15 millert Exp $	*/
d380 1
d439 2
a440 3
		if (sc->sc_format_pid >= 0 && sc->sc_blks > 0 &&
		    sc->sc_heads > 0 && sc->sc_cyls > 0) {
			lp->d_secperunit = sc->sc_blks >> sc->sc_bshift;
d443 4
a446 1
			lp->d_nsectors = lp->d_secperunit / (lp->d_ntracks * lp->d_ncylinders);
d479 6
a484 2
		lp->d_partitions[RAW_PART].p_size =
		    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.15
log
@set d_bbsize and d_sbsize in spoofed label to values correct for ffs
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.14 1998/03/27 07:47:54 millert Exp $	*/
d438 2
a439 1
		if (sc->sc_blks != 0 && sc->sc_heads != 0 && sc->sc_cyls != 0) {
@


1.14
log
@fictitious disklabels for scsi disks
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.13 1998/03/06 22:52:42 millert Exp $	*/
d59 2
d469 4
@


1.13
log
@Keep gcc from addint an implicit memset() behind our back.  Thanks
to Niklas and Theo for help in tracking down what was going on.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.12 1997/07/13 09:48:00 downsj Exp $	*/
d392 1
a392 2
	struct partition *pi;
	char *msg;
d395 1
a395 1
	msg = NULL;
d418 4
a421 1
			msg = "unformatted/missing media";
d427 2
a428 2
	 * Set some default values to use while reading the label
	 * (or to use if there isn't a label) and try reading it.
d430 1
a430 9
	if (msg == NULL) {
		lp->d_type = DTYPE_SCSI;
		lp->d_secsize = DEV_BSIZE;
		lp->d_nsectors = 32;
		lp->d_ntracks = 20;
		lp->d_ncylinders = 1;
		lp->d_secpercyl = 32*20;
		lp->d_npartitions = 3;
		lp->d_partitions[2].p_offset = 0;
d434 58
a491 6
		/* XXX ensure size is at least one device block */
		lp->d_partitions[2].p_size =
			roundup(LABELSECTOR+1, btodb(sc->sc_blksize));
		msg = readdisklabel(sdlabdev(dev), sdstrategy, lp, NULL);
		if (msg == NULL)
			return (0);
a493 7
	pi = lp->d_partitions;
	printf("%s: WARNING: %s, defining `c' partition as entire disk\n",
	    sc->sc_dev.dv_xname, msg);
	pi[2].p_size = sc->sc_blks;
	/* XXX reset other info since readdisklabel screws with it */
	lp->d_npartitions = 3;
	pi[0].p_size = 0;
@


1.12
log
@sync to NETBSD_CURRENT_970711.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.11 1997/07/06 08:01:56 downsj Exp $	*/
d153 1
a153 4
	struct scsi_fmt_cdb modesense_geom = {
		6,
		{ CMD_MODE_SENSE, 0, 0x04, 0, sizeof(sensebuf), 0 }
	};
d155 7
@


1.11
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 2
a2 2
/*	$OpenBSD: sd.c,v 1.10 1997/04/16 11:56:15 downsj Exp $	*/
/*	$NetBSD: sd.c,v 1.33 1997/06/24 00:44:05 thorpej Exp $	*/
a61 5

#include <vm/vm_param.h>
#include <vm/lock.h>
#include <vm/vm_prot.h>
#include <vm/pmap.h>
@


1.10
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: sd.c,v 1.9 1997/02/10 06:43:34 downsj Exp $	*/
/*	$NetBSD: sd.c,v 1.31 1997/04/02 22:37:36 scottr Exp $	*/
a61 3
#ifdef USELEDS
#include <hp300/hp300/led.h>
#endif
d68 6
d905 1
a905 2
	if (inledcontrol == 0)
		ledcontrol(0, 0, LED_DISK);
d1128 2
a1129 1
	psize = sc->sc_dkdev.dk_label->d_partitions[sdpart(dev)].p_size;
@


1.9
log
@Kill COMPAT_NOLABEL.  It is not appropiate in the modern world.
@
text
@d1 2
a2 2
/*	$OpenBSD: sd.c,v 1.8 1997/02/10 01:33:57 downsj Exp $	*/
/*	$NetBSD: sd.c,v 1.29 1997/01/30 09:14:20 thorpej Exp $	*/
d50 2
a51 1
#include <sys/stat.h>
d53 2
a54 1
#include <sys/disk.h>
d57 1
a57 3
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/device.h>
a60 1

a61 1

d71 1
d76 1
a88 11
void	sdstrategy __P((struct buf *));
void	sdustart __P((int));

void	sdstart __P((void *));
void	sdgo __P((void *));
void	sdintr __P((void *, int));

int	sdgetcapacity __P((struct sd_softc *, dev_t));

static void sdgetgeom __P((struct sd_softc *));

d96 2
a97 2
static struct scsi_fmt_cdb sd_read_cmd = { 10, CMD_READ_EXT };
static struct scsi_fmt_cdb sd_write_cmd = { 10, CMD_WRITE_EXT };
d124 20
d157 1
a157 1
		CMD_MODE_SENSE, 0, 0x04, 0, sizeof(sensebuf), 0
d272 1
a272 1
	register struct sd_softc *sc;
d289 1
a289 1
		CMD_READ_CAPACITY, 0, 0, 0, 0, 0, 0, 0, 0, 0
d389 3
a391 3
	register struct disklabel *lp = sc->sc_dkdev.dk_label;
	register struct partition *pi;
	char *msg, *readdisklabel();
d462 1
a462 1
	register int unit = sdunit(dev);
d523 1
a523 1
	register struct disk *dk = &sc->sc_dkdev;
d565 2
a566 2
	register struct buf *bp;
	register int bsize;
d569 1
a569 1
	register struct buf *cbp = (struct buf *)malloc(sizeof(struct buf),
d572 2
a573 2
	register int bn, resid;
	register caddr_t addr;
d583 1
a583 1
		printf("sdlblkstrat: bp %x flags %x bn %x resid %x addr %x\n",
d588 2
a589 2
		register int boff = dbtob(bn) & (bsize - 1);
		register int count;
d600 1
a600 1
				printf(" readahead: bn %x cnt %x off %x addr %x\n",
d617 1
a617 1
				printf(" writeback: bn %x cnt %x off %x addr %x\n",
d627 1
a627 1
				printf(" fulltrans: bn %x cnt %x addr %x\n",
d645 1
a645 1
			printf(" done: bn %x resid %x addr %x\n",
d655 1
a655 1
	register struct buf *bp;
d659 4
a662 4
	register struct buf *dp = &sc->sc_tab;
	register struct partition *pinfo;
	register daddr_t bn;
	register int sz, s;
d740 1
a740 1
	register int unit;
d813 1
a813 1
	register struct buf *dp = &sc->sc_tab;
d842 2
a843 2
		register struct buf *bp = sc->sc_tab.b_actf;
		register int sts;
d872 3
a874 3
	register struct buf *bp = sc->sc_tab.b_actf;
	register int pad;
	register struct scsi_fmt_cdb *cmd;
d896 1
a896 1
			printf("%s: partial block xfer -- %x bytes\n",
d914 1
a914 1
		printf("%s: sdstart: %s adr %d blk %d len %d ecnt %d\n",
d930 2
a931 3
	register struct sd_softc *sc = arg;
	int unit = sc->sc_dev.dv_unit;
	register struct buf *bp = sc->sc_tab.b_actf;
d952 1
a952 1
					printf("%s: retry #%d\n",
d972 1
a972 1
	register int unit = sdunit(dev);
d974 1
a974 1
	register int pid;
d989 1
a989 1
	register int unit = sdunit(dev);
d991 1
a991 1
	register int pid;
d1003 1
a1003 1
	int cmd;
d1010 1
a1010 1
	register struct disklabel *lp = sc->sc_dkdev.dk_label;
d1107 1
a1107 1
	register int unit = sdunit(dev);
a1151 1
	daddr_t baddr;
@


1.8
log
@Support 16 partitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.7 1997/02/03 04:47:47 downsj Exp $	*/
a382 9
#ifdef COMPAT_NOLABEL
	int usedefault = 1;

	/*
	 * For CD-ROM just define a single partition
	 */
	if (sc->sc_type == 5)
		usedefault = 0;
#endif
a408 3
#ifdef COMPAT_NOLABEL
			usedefault = 0;
#endif
d438 2
a439 9
	printf("%s: WARNING: %s, ", sc->sc_dev.dv_xname, msg);
#ifdef COMPAT_NOLABEL
	if (usedefault) {
		printf("using old default partitioning\n");
		sdmakedisklabel(unit, lp);
		return(0);
	}
#endif
	printf("defining `c' partition as entire disk\n");
@


1.7
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.6 1997/01/12 15:13:03 downsj Exp $	*/
a1024 3
	default:
		return (EINVAL);

d1106 3
@


1.6
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sd.c,v 1.28 1997/01/07 09:29:30 thorpej Exp $	*/
d5 1
a45 2
#include "sd.h"
#if NSD > 0
d57 1
a58 1
#include <hp300/dev/device.h>
d60 2
d63 1
a72 13
extern int scsi_test_unit_rdy();
extern int scsi_request_sense();
extern int scsi_inquiry();
extern int scsi_read_capacity();
extern int scsi_tt_write();
extern int scsireq();
extern int scsiustart();
extern int scsigo();
extern void scsifree();
extern void scsireset();
extern void scsi_delay();
extern void scsi_str __P((char *, char *, size_t));

d78 2
a79 2
int	sdmatch();
void	sdattach(), sdstrategy(), sdstart(), sdustart(), sdgo(), sdintr();
d81 2
a82 3
struct	driver sddriver = {
	sdmatch, sdattach, "sd", (int (*)())sdstart,
	(int (*)())sdgo, (int (*)())sdintr,
d85 15
a106 6
struct	sd_softc sd_softc[NSD];
struct	sdstats sdstats[NSD];
struct	buf sdtab[NSD];
struct	scsi_fmt_cdb sdcmd[NSD];
struct	scsi_fmt_sense sdsense[NSD];

a134 6
static struct scsi_inquiry inqbuf;
static struct scsi_fmt_cdb inq = {
	6,
	CMD_INQUIRY, 0, 0, 0, sizeof(inqbuf), 0
};

d139 1
a139 1
sdgetgeom(sc, hd)
a140 1
	struct hp_device *hd;
d152 3
a154 3
	ctlr = hd->hp_ctlr;
	slave = hd->hp_slave;
	unit = sc->sc_punit;
d156 1
d159 1
d166 4
a169 5
static int
sdident(sc, hd, verbose)
	struct sd_softc *sc;
	struct hp_device *hd;
	int verbose;
d171 1
a171 11
	int unit;
	register int ctlr, slave;
	register int i;
	register int tries = 10;
	char vendor[9], product[17], revision[5];
	int isrm = 0;

	ctlr = hd->hp_ctlr;
	slave = hd->hp_slave;
	unit = sc->sc_punit;
	scsi_delay(-1);
d173 1
a173 44
	/*
	 * See if unit exists and is a disk then read block size & nblocks.
	 */
	while ((i = scsi_test_unit_rdy(ctlr, slave, unit)) != 0) {
		if (i == -1 || --tries < 0) {
			if (isrm)
				break;
			/* doesn't exist or not a CCS device */
			goto failed;
		}
		if (i == STS_CHECKCOND) {
			u_char sensebuf[128];
			struct scsi_xsense *sp = (struct scsi_xsense *)sensebuf;

			scsi_request_sense(ctlr, slave, unit, sensebuf,
					   sizeof(sensebuf));
			if (sp->class == 7)
				switch (sp->key) {
				/*
				 * Not ready -- might be removable media
				 * device with no media.  Assume as much,
				 * if it really isn't, the inquiry commmand
				 * below will fail.
				 */
				case 2:
					isrm = 1;
					break;
				/* drive doing an RTZ -- give it a while */
				case 6:
					DELAY(1000000);
					break;
				default:
					break;
				}
		}
		DELAY(1000);
	}
	/*
	 * Find out about device
	 */
	if (scsi_immed_command(ctlr, slave, unit, &inq,
			       (u_char *)&inqbuf, sizeof(inqbuf), B_READ))
		goto failed;
	switch (inqbuf.type) {
d180 1
a180 1
		goto failed;
d182 12
d195 2
a196 1
	 * Get a usable id string
d198 2
a199 17
	bzero(vendor, sizeof(vendor));
	bzero(product, sizeof(product));
	bzero(revision, sizeof(revision));
	switch (inqbuf.version) {
	case 1:
	case 2:
		scsi_str(inqbuf.vendor_id, vendor, sizeof(inqbuf.vendor_id));
		scsi_str(inqbuf.product_id, product,
		    sizeof(inqbuf.product_id));
		scsi_str(inqbuf.rev, revision, sizeof(inqbuf.rev));
		break;
	default:
		bcopy("UNKNOWN", vendor, 8);
		bcopy("DRIVE TYPE", product, 11);
	}
	if (inqbuf.qual & 0x80)
		sc->sc_flags |= SDF_RMEDIA;
d201 3
a203 2
	if (sdgetcapacity(sc, hd, NODEV) < 0)
		goto failed;
d205 2
a206 27
	switch (inqbuf.version) {
	case 1:
	case 2:
		if (verbose) {
			printf(": <%s, %s, %s>", vendor, product, revision);
			if (inqbuf.version == 2)
				printf(" (SCSI-2)");
		}
		break;
	default:
		if (verbose)
			printf(": type 0x%x, qual 0x%x, ver %d",
			       inqbuf.type, inqbuf.qual, inqbuf.version);
		break;
	}
	if (verbose)
		printf("\n");

	if (verbose) {
		/*
		 * Print out some additional information.
		 */
		printf("%s: ", hd->hp_xname);
		switch (inqbuf.type) {
		case 4:	
			printf("WORM, ");
			break;
d208 1
a208 3
		case 5:
			printf("CD-ROM, ");
			break;
d210 7
a216 3
		case 7:
			printf("Magneto-optical, ");
			break;
d218 3
a220 10
		default:
			printf("%d cylinders, %d heads, ",
			    sc->sc_cyls, sc->sc_heads);
		}

		if (sc->sc_blks)
			printf("%d blocks, %d bytes/block\n",
			    sc->sc_blks >> sc->sc_bshift, sc->sc_blksize);
		else
			printf("drive empty\n");
a222 23
	scsi_delay(0);
	return(inqbuf.type);
failed:
	scsi_delay(0);
	return(-1);
}

int
sdmatch(hd)
	register struct hp_device *hd;
{
	register struct sd_softc *sc = &sd_softc[hd->hp_unit];

	/* XXX set up external name */
	bzero(sc->sc_xname, sizeof(sc->sc_xname));
	sprintf(sc->sc_xname, "sd%d", hd->hp_unit);

	/* Initialize the disk structure. */
	bzero(&sc->sc_dkdev, sizeof(sc->sc_dkdev));
	sc->sc_dkdev.dk_name = sc->sc_xname;

	sc->sc_hd = hd;
	sc->sc_flags = 0;
d224 1
a224 2
	 * XXX formerly 0 meant unused but now pid 0 can legitimately
	 * use this interface (sdgetcapacity).
d226 5
a230 5
	sc->sc_format_pid = -1;
	sc->sc_punit = sdpunit(hd->hp_flags);
	sc->sc_type = sdident(sc, hd, 0);
	if (sc->sc_type < 0)
		return (0);
d232 3
a234 2
	return (1);
}
d236 3
a238 5
void
sdattach(hd)
	register struct hp_device *hd;
{
	struct sd_softc *sc = &sd_softc[hd->hp_unit];
d240 9
a248 1
	(void)sdident(sc, hd, 1);	/* XXX Ick. */
d250 2
a251 5
	sc->sc_dq.dq_softc = sc;
	sc->sc_dq.dq_ctlr = hd->hp_ctlr;
	sc->sc_dq.dq_unit = hd->hp_unit;
	sc->sc_dq.dq_slave = hd->hp_slave;
	sc->sc_dq.dq_driver = &sddriver;
d256 2
a258 3

	/* XXX Set device class. */
	hd->hp_dev.dv_class = DV_DISK;
d262 1
a262 1
sdreset(sc, hd)
a263 1
	register struct hp_device *hd;
d265 1
a265 1
	sdstats[hd->hp_unit].sdresets++;
d274 1
a274 1
sdgetcapacity(sc, hd, dev)
a275 1
	struct hp_device *hd;
d294 5
a298 2
		i = scsi_immed_command(hd->hp_ctlr, hd->hp_slave, sc->sc_punit,
				       &cap, capbuf, capbufsize, B_READ);
d309 1
a309 1
		bcopy((caddr_t)&cap, (caddr_t)&sdcmd[hd->hp_unit], sizeof cap);
d315 1
a315 1
		i = biowait(bp) ? sdsense[hd->hp_unit].status : 0;
d324 1
a324 1
				       hd->hp_xname, i);
d338 1
a338 1
			       hd->hp_xname);
d354 1
a354 1
			    hd->hp_xname, DEV_BSIZE, "drive ignored");
d363 3
a365 2
		printf("%s: blks=%d, blksize=%d, bshift=%d\n", hd->hp_xname,
		       sc->sc_blks, sc->sc_blksize, sc->sc_bshift);
d367 1
a367 1
	sdgetgeom(sc, hd);
d379 1
a379 1
	register struct sd_softc *sc = &sd_softc[unit];
d402 1
a402 1
		switch (sdgetcapacity(sc, sc->sc_hd, dev)) {
d450 1
a450 1
	printf("%s: WARNING: %s, ", sc->sc_hd->hp_xname, msg);
d473 1
a473 1
	register struct sd_softc *sc = &sd_softc[unit];
d476 4
a479 2
	if (unit >= NSD || (sc->sc_flags & SDF_ALIVE) == 0)
		return(ENXIO);
d532 1
a532 1
	register struct sd_softc *sc = &sd_softc[unit];
d552 1
a552 1
		while (sdtab[unit].b_active) {
d554 1
a554 1
			sleep((caddr_t)&sdtab[unit], PRIBIO);
d578 1
d602 1
a602 1
			sdstats[sdunit(bp->b_dev)].sdpartials++;
d668 2
a669 2
	register struct sd_softc *sc = &sd_softc[unit];
	register struct buf *dp = &sdtab[unit];
d752 4
a755 2
	if (scsireq(&sd_softc[unit].sc_dq))
		sdstart(unit);
d765 3
a767 4
sderror(unit, sc, hp, stat)
	int unit, stat;
	register struct sd_softc *sc;
	register struct hp_device *hp;
d771 1
a771 1
	sdsense[unit].status = stat;
d775 5
a779 5
		scsi_request_sense(hp->hp_ctlr, hp->hp_slave,
				   sc->sc_punit, sdsense[unit].sense,
				   sizeof(sdsense[unit].sense));
		sp = (struct scsi_xsense *)sdsense[unit].sense;
		printf("%s: scsi sense class %d, code %d", hp->hp_xname,
d819 3
a821 4
sdfinish(unit, sc, bp)
	int unit;
	register struct sd_softc *sc;
	register struct buf *bp;
d823 1
a823 1
	register struct buf *dp = &sdtab[unit];
d829 1
a829 1
	scsifree(&sc->sc_dq);
d831 1
a831 1
		sdustart(unit);
d842 2
a843 2
sdstart(unit)
	register int unit;
d845 1
a845 2
	register struct sd_softc *sc = &sd_softc[unit];
	register struct hp_device *hp = sc->sc_hd;
d851 2
a852 2
	if (sc->sc_format_pid >= 0 && legal_cmds[sdcmd[unit].cdb[0]] > 0) {
		register struct buf *bp = sdtab[unit].b_actf;
d855 1
a855 1
		sdtab[unit].b_errcnt = 0;
d857 5
a861 5
			sts = scsi_immed_command(hp->hp_ctlr, hp->hp_slave,
						 sc->sc_punit, &sdcmd[unit],
						 bp->b_un.b_addr, bp->b_bcount,
						 bp->b_flags & B_READ);
			sdsense[unit].status = sts;
d863 1
a863 1
			    (sts = sderror(unit, sc, hp, sts)) == 0)
d865 1
a865 1
			if (sts > 0 || sdtab[unit].b_errcnt++ >= SDRETRY) {
d871 1
a871 1
		sdfinish(unit, sc, bp);
d873 2
a874 2
	} else if (scsiustart(hp->hp_ctlr))
		sdgo(unit);
d878 2
a879 2
sdgo(unit)
	register int unit;
d881 2
a882 3
	register struct sd_softc *sc = &sd_softc[unit];
	register struct hp_device *hp = sc->sc_hd;
	register struct buf *bp = sdtab[unit].b_actf;
d887 1
a887 1
		cmd = &sdcmd[unit];
d896 1
a896 1
			sdfinish(unit, sc, bp);
d907 1
a907 1
			       sc->sc_hd->hp_xname, bp->b_bcount);
d909 1
a909 1
		sdstats[unit].sdtransfers++;
d915 1
a915 1
	if (scsigo(hp->hp_ctlr, hp->hp_slave, sc->sc_punit,
d925 1
a925 1
		       sc->sc_hd->hp_xname,
d928 1
a928 1
		       sdtab[unit].b_errcnt);
d932 1
a932 1
	sdfinish(unit, sc, bp);
d941 2
a942 3
	int unit = sc->sc_hd->hp_unit;
	register struct buf *bp = sdtab[unit].b_actf;
	register struct hp_device *hp = sc->sc_hd;
d946 1
a946 1
		printf("%s: bp == NULL\n", sc->sc_hd->hp_xname);
d956 1
a956 1
				sc->sc_hd->hp_xname, stat);
d958 1
a958 1
		cond = sderror(unit, sc, hp, stat);
d960 1
a960 1
			if (cond < 0 && sdtab[unit].b_errcnt++ < SDRETRY) {
d964 2
a965 2
					    sc->sc_hd->hp_xname,
					    sdtab[unit].b_errcnt);
d967 1
a967 1
				sdstart(unit);
d974 1
a974 1
	sdfinish(unit, sc, bp);
d984 1
d987 1
a987 1
	if ((pid = sd_softc[unit].sc_format_pid) >= 0 &&
d1001 1
d1004 1
a1004 1
	if ((pid = sd_softc[unit].sc_format_pid) >= 0 &&
d1020 1
a1020 1
	register struct sd_softc *sc = &sd_softc[unit];
d1099 1
a1099 1
		bcopy(data, (caddr_t)&sdcmd[unit], sizeof(sdcmd[0]));
d1107 1
a1107 1
		bcopy((caddr_t)&sdsense[unit], data, sizeof(sdsense[0]));
d1119 1
a1119 1
	register struct sd_softc *sc = &sd_softc[unit];
d1122 4
a1125 2
	if (unit >= NSD || (sc->sc_flags & SDF_ALIVE) == 0)
		return(-1);
a1161 1
	struct hp_device *hp;
d1176 3
a1178 4
	if (unit >= NSD)
		return (ENXIO);
	sc = &sd_softc[unit];
	if ((sc->sc_flags & SDF_ALIVE) == 0)
a1179 1
	hp = sc->sc_hd;
d1208 3
a1210 2
		stat = scsi_tt_write(hp->hp_ctlr, hp->hp_slave, sc->sc_punit,
		    va, nwrt * sectorsize, blkno, 0);
d1217 1
a1217 1
		printf("%s: dump addr %p, blk %d\n", hp->hp_xname,
a1229 1
#endif
@


1.5
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: sd.c,v 1.22.4.1 1996/06/06 16:22:04 thorpej Exp $	*/
d370 3
d586 1
a586 1
	int error, mask;
d611 12
a622 2
	mask = 1 << sdpart(dev);
	if (mode == S_IFCHR)
d624 2
a625 1
	else
d627 5
a631 1
	sc->sc_dkdev.dk_openmask |= mask;
d782 1
d798 21
a818 5
		if (bn < 0 || bn + sz > pinfo->p_size) {
			sz = pinfo->p_size - bn;
			if (sz == 0) {
				bp->b_resid = bp->b_bcount;
				goto done;
d820 10
a829 2
			if (sz < 0) {
				bp->b_error = EINVAL;
a831 12
			bp->b_bcount = dbtob(sz);
		}
		/*
		 * Check for write to write protected label
		 */
		if (bn + pinfo->p_offset <= LABELSECTOR &&
#if LABELSECTOR != 0
		    bn + pinfo->p_offset + sz > LABELSECTOR &&
#endif
		    !(bp->b_flags & B_READ) && !(sc->sc_flags & SDF_WLABEL)) {
			bp->b_error = EROFS;
			goto bad;
d841 1
a841 1
		bp->b_cylin = (bn + pinfo->p_offset) >> sc->sc_bshift;
d1251 2
d1257 1
a1257 1
sddump(dev)
d1259 24
a1282 11
{
	int part = sdpart(dev);
	int unit = sdunit(dev);
	register struct sd_softc *sc = &sd_softc[unit];
	register struct hp_device *hp = sc->sc_hd;
	register struct partition *pinfo;
	register daddr_t baddr;
	register int maddr;
	register int pages, i;
	int stat;
	extern int lowram, dumpsize;
d1284 5
a1288 2
	/* is drive ok? */
	if (unit >= NSD || (sc->sc_flags & SDF_ALIVE) == 0)
d1290 17
a1306 4
	pinfo = &sc->sc_dkdev.dk_label->d_partitions[part];
	/* dump parameters in range? */
	if (dumplo < 0 || dumplo >= pinfo->p_size ||
	    pinfo->p_fstype != FS_SWAP)
d1308 11
a1318 19
	pages = dumpsize;
	if (dumplo + ctod(pages) > pinfo->p_size)
		pages = dtoc(pinfo->p_size - dumplo);
	maddr = lowram;
	baddr = dumplo + pinfo->p_offset;
	/* scsi bus idle? */
	if (!scsireq(&sc->sc_dq)) {
		scsireset(hp->hp_ctlr);
		sdreset(sc, sc->sc_hd);
		printf("[ drive %d reset ] ", unit);
	}
	for (i = 0; i < pages; i++) {
#define NPGMB	(1024*1024/NBPG)
		/* print out how many Mbs we have dumped */
		if (i && (i % NPGMB) == 0)
			printf("%d ", i / NPGMB);
#undef NPBMG
		pmap_enter(pmap_kernel(), (vm_offset_t)vmmap, maddr,
		    VM_PROT_READ, TRUE);
d1320 1
a1320 1
				     vmmap, NBPG, baddr, sc->sc_bshift);
d1322 1
a1322 1
			printf("sddump: scsi write error 0x%x\n", stat);
d1325 11
a1335 2
		maddr += NBPG;
		baddr += ctod(1);
d1337 1
@


1.4
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: sd.c,v 1.22 1996/02/14 02:45:05 thorpej Exp $	*/
a50 1
#include <sys/dkstat.h>		/* XXX */
a314 1
	sc->sc_wpms = 32 * (60 * DEV_BSIZE / 2);	/* XXX */
a606 4
	/* XXX Support old-style instrumentation for now. */
	if (sc->sc_hd->hp_dk >= 0)
		dk_wpms[sc->sc_hd->hp_dk] = sc->sc_wpms;

a995 8
		/* XXX Support old-style instrumentation for now. */
		if (hp->hp_dk >= 0) {
			dk_busy |= 1 << hp->hp_dk;
			++dk_seek[hp->hp_dk];
			++dk_xfer[hp->hp_dk];
			dk_wds[hp->hp_dk] += bp->b_bcount >> 6;
		}

a1028 4

	/* XXX Support old-style instrumentation for now. */
	if (hp->hp_dk >= 0)
		dk_busy &=~ (1 << hp->hp_dk);
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
a1 1
/*	$NetBSD: sd.c,v 1.21 1996/01/07 22:02:18 thorpej Exp $	*/
d361 1
d1029 2
a1030 2
sdintr(unit, stat)
	register int unit;
d1033 2
a1034 1
	register struct sd_softc *sc = &sd_softc[unit];
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: sd.c,v 1.20 1995/12/09 07:31:03 thorpej Exp $	*/
d51 1
a51 1
#include <sys/dkstat.h>
d53 1
d330 8
d366 3
d489 1
a489 1
	register struct disklabel *lp = &sc->sc_info.si_label;
d599 1
a599 1
	if (sc->sc_info.si_open == 0) {
d607 2
d614 1
a614 1
		sc->sc_info.si_copen |= mask;
d616 2
a617 2
		sc->sc_info.si_bopen |= mask;
	sc->sc_info.si_open |= mask;
d629 1
a629 1
	register struct sdinfo *si = &sc->sc_info;
d634 1
a634 1
		si->si_copen &= ~mask;
d636 2
a637 2
		si->si_bopen &= ~mask;
	si->si_open = si->si_bopen | si->si_copen;
d645 1
a645 1
	if (si->si_open == 0) {
d782 1
a782 1
		pinfo = &sc->sc_info.si_label.d_partitions[sdpart(bp->b_dev)];
d999 3
a1001 1
	if (scsigo(hp->hp_ctlr, hp->hp_slave, sc->sc_punit, bp, cmd, pad) == 0) {
d1008 4
d1041 2
d1045 3
d1115 1
a1115 1
	register struct disklabel *lp = &sc->sc_info.si_label;
d1146 1
a1146 1
				     : sc->sc_info.si_open,
d1155 1
a1155 1
				     : sc->sc_info.si_open,
d1224 1
a1224 1
	if (sc->sc_info.si_open == 0) {
d1229 1
a1229 1
	psize = sc->sc_info.si_label.d_partitions[sdpart(dev)].p_size;
d1256 1
a1256 1
	pinfo = &sc->sc_info.si_label.d_partitions[part];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sd.c,v 1.16.2.2 1995/10/16 09:01:36 thorpej Exp $	*/
d88 2
a89 2
int	sdinit();
void	sdstrategy(), sdstart(), sdustart(), sdgo(), sdintr();
d92 2
a93 1
	sdinit, "sd", (int (*)())sdstart, (int (*)())sdgo, (int (*)())sdintr,
d174 1
a174 1
sdident(sc, hd)
d177 1
d270 5
a274 5
		printf("sd%d: %s %s", hd->hp_unit, vendor, product);
		if (revision[0] != '\0')
			printf(" rev %s", revision);
		if (inqbuf.version == 2)
			printf(" (SCSI-2)");
d277 3
a279 2
		printf("sd%d: type 0x%x, qual 0x%x, ver %d", hd->hp_unit,
		       inqbuf.type, inqbuf.qual, inqbuf.version);
d282 2
a283 1
	printf("\n");
d285 13
a297 8
	/*
	 * Print out some additional information.
	 */
	printf("sd%d: ", hd->hp_unit);
	switch (inqbuf.type) {
	case 4:	
		printf("WORM, ");
		break;
d299 3
a301 3
	case 5:
		printf("CD-ROM, ");
		break;
d303 4
a306 3
	case 7:
		printf("Magneto-optical, ");
		break;
d308 5
a312 2
	default:
		printf("%d cylinders, %d heads, ", sc->sc_cyls, sc->sc_heads);
a314 6
	if (sc->sc_blks)
		printf("%d blocks, %d bytes/block\n",
		    sc->sc_blks >> sc->sc_bshift, sc->sc_blksize);
	else
		printf("drive empty\n");

d324 1
a324 1
sdinit(hd)
d337 1
a337 1
	sc->sc_type = sdident(sc, hd);
d339 13
a351 1
		return(0);
a357 1
	return(1);
d421 2
a422 2
				printf("sd%d: read_capacity returns %d\n",
				       hd->hp_unit, i);
d435 2
a436 2
			printf("sd%d: removable media not present\n",
			       hd->hp_unit);
d451 2
a452 2
			printf("sd%d: need at least %d byte blocks - %s\n",
				hd->hp_unit, DEV_BSIZE, "drive ignored");
d461 1
a461 1
		printf("sd%d: blks=%d, blksize=%d, bshift=%d\n", hd->hp_unit,
d541 1
a541 1
		msg = readdisklabel(sdlabdev(dev), sdstrategy, lp);
d547 1
a547 1
	printf("sd%d: WARNING: %s, ", unit, msg);
d846 1
a846 1
		printf("sd%d: scsi sense class %d, code %d", unit,
d976 2
a977 2
			printf("sd%d: partial block xfer -- %x bytes\n",
			       unit, bp->b_bcount);
d996 3
a998 2
		printf("sd%d: sdstart: %s adr %d blk %d len %d ecnt %d\n",
		       unit, bp->b_flags & B_READ? "read" : "write",
d1018 1
a1018 1
		printf("sd%d: bp == NULL\n", unit);
d1026 2
a1027 2
			printf("sd%d: sdintr: bad scsi status 0x%x\n",
				unit, stat);
d1034 3
a1036 2
					printf("sd%d: retry #%d\n",
					       unit, sdtab[unit].b_errcnt);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

