head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.24
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.20
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.18
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.16
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.14
	OPENBSD_5_0:1.14.0.12
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.10
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.12
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.10
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.8
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.6
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.22
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.20
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.18
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.16
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.14
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.12
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.14;

1.14
date	2009.01.25.14.57.44;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.16.21.23.55;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.14.20.21.42;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.06.08.01.53;	author downsj;	state Exp;
branches
	1.8.12.1
	1.8.22.1;
next	1.7;

1.7
date	97.04.16.11.56.09;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.03.04.47.33;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.12.15.12.45;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.11.47.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.41;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.19;	author deraadt;	state Exp;
branches;
next	;

1.8.12.1
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	;

1.8.22.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: hpib.c,v 1.14 2009/01/25 14:57:44 miod Exp $	*/
/*	$NetBSD: hpib.c,v 1.16 1997/04/27 20:58:57 thorpej Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)hpib.c	8.2 (Berkeley) 1/12/94
 */

/*
 * HP-IB bus driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <hp300/dev/dmavar.h>

#include <hp300/dev/hpibvar.h>

#include <machine/cpu.h>
#include <machine/hp300spu.h>

int	hpibbusmatch(struct device *, void *, void *);
void	hpibbusattach(struct device *, struct device *, void *);

struct cfattach hpibbus_ca = {
	sizeof(struct hpibbus_softc), hpibbusmatch, hpibbusattach
};

struct cfdriver hpibbus_cd = {
	NULL, "hpibbus", DV_DULL
};

void	hpibbus_attach_children(struct hpibbus_softc *);
int	hpibbussubmatch(struct device *, void *, void *);
int	hpibbusprint(void *, const char *);

void	hpibstart(void *);
void	hpibdone(void *);

int	hpibtimeout = 100000;	/* # of status tests before we give up */
int	hpibidtimeout = 10000;	/* # of status tests for hpibid() calls */
int	hpibdmathresh = 3;	/* byte count beyond which to attempt dma */

/*
 * HP-IB is essentially an IEEE 488 bus, with an HP command
 * set (CS/80 on `newer' devices, Amigo on before-you-were-born
 * devices) thrown on top.  Devices that respond to CS/80 (and
 * probably Amigo, too) are tagged with a 16-bit ID.
 *
 * HP-IB has a 2-level addressing scheme; slave, the analog
 * of a SCSI ID, and punit, the analog of a SCSI LUN.  Unfortunately,
 * IDs are on a per-slave basis; punits are often used for disk
 * drives that have an accompanying tape drive on the second punit.
 *
 * In addition, not all HP-IB devices speak CS/80 or Amigo.
 * Examples of such devices are HP-IB plotters, which simply
 * take raw plotter commands over 488.  These devices do not
 * have ID tags, and often the host cannot even tell if such
 * a device is attached to the system!
 *
 * We nevertheless probe the whole (slave, punit) tuple space, since
 * drivers for devices with a unique ID know exactly where to attach; 
 * and we disallow ``star'' locators for other drivers.
 */

int
hpibbusmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{

	return (1);
}

void
hpibbusattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct hpibbus_softc *sc = (struct hpibbus_softc *)self;
	struct hpibdev_attach_args *ha = aux;

	printf("\n");

	/* Get the operations vector for the controller. */
	sc->sc_ops = ha->ha_ops;
	sc->sc_type = ha->ha_type;		/* XXX */
	sc->sc_ba = ha->ha_ba;
	*(ha->ha_softcpp) = sc;			/* XXX */

	hpibreset(self->dv_unit);		/* XXX souldn't be here */

	/*
	 * Initialize the DMA queue entry.
	 */
	sc->sc_dq = (struct dmaqueue *)malloc(sizeof(struct dmaqueue),
	    M_DEVBUF, M_NOWAIT);
	if (sc->sc_dq == NULL) {
		printf("%s: can't allocate DMA queue entry\n", self->dv_xname);
		return;
	}
	sc->sc_dq->dq_softc = sc;
	sc->sc_dq->dq_start = hpibstart;
	sc->sc_dq->dq_done = hpibdone;

	/* Initialize the slave request queue. */
	TAILQ_INIT(&sc->sc_queue);

	/* Attach any devices on the bus. */
	hpibbus_attach_children(sc);
}

void
hpibbus_attach_children(sc)
	struct hpibbus_softc *sc;
{
	struct hpibbus_attach_args ha;
	int id, slave, punit;
	int i;

	for (slave = 0; slave < HPIB_NSLAVES; slave++) {
		/*
		 * Get the ID tag for the device, if any.
		 * Plotters won't identify themselves, and
		 * get the same value as non-existent devices.
		 * However, aging HP-IB drives are slow to respond; try up
		 * to three times to get a valid ID.
		 */
		for (i = 0; i < 3; i++) {
			id = hpibid(sc->sc_dev.dv_unit, slave);
			if ((id & 0x200) != 0)
				break;
			delay(10000);
		}

		for (punit = 0; punit < HPIB_NPUNITS; punit++) {
			/*
			 * Search through all configured children for this bus.
			 */
			ha.ha_id = id;
			ha.ha_slave = slave;
			ha.ha_punit = punit;
			(void)config_found_sm(&sc->sc_dev, &ha, hpibbusprint,
			    hpibbussubmatch);
		}
	}
}

int
hpibbussubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct hpibbus_attach_args *ha = aux;

	if (cf->hpibbuscf_slave != HPIBBUS_SLAVE_UNK &&
	    cf->hpibbuscf_slave != ha->ha_slave)
		return (0);
	if (cf->hpibbuscf_punit != HPIBBUS_PUNIT_UNK &&
	    cf->hpibbuscf_punit != ha->ha_punit)
		return (0);
	return ((*cf->cf_attach->ca_match)(parent, match, aux));
}

int
hpibbusprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct hpibbus_attach_args *ha = aux;

	if (pnp != NULL) {
		if (ha->ha_id == 0 || ha->ha_punit != 0 /* XXX */)
			return (QUIET);
		printf("HP-IB device (id %04X) at %s", ha->ha_id, pnp);
	}
	printf(" slave %d punit %d", ha->ha_slave, ha->ha_punit);
	return (UNCONF);
}

int
hpibdevprint(aux, pnp)
	void *aux;
	const char *pnp;
{

	/* only hpibbus's can attach to hpibdev's -- easy. */
	if (pnp != NULL)
		printf("hpibbus at %s", pnp);
	return (UNCONF);
}

void
hpibreset(unit)
	int unit;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];

	(*sc->sc_ops->hpib_reset)(sc);
}

int
hpibreq(pdev, hq)
	struct device *pdev;
	struct hpibqueue *hq;
{
	struct hpibbus_softc *sc = (struct hpibbus_softc *)pdev;
	int s;

	s = splhigh();	/* XXXthorpej */
	TAILQ_INSERT_TAIL(&sc->sc_queue, hq, hq_list);
	splx(s);

	if (TAILQ_FIRST(&sc->sc_queue) == hq)
		return (1);

	return (0);
}

void
hpibfree(pdev, hq)
	struct device *pdev;
	struct hpibqueue *hq;
{
	struct hpibbus_softc *sc = (struct hpibbus_softc *)pdev;
	int s;

	s = splhigh();	/* XXXthorpej */
	TAILQ_REMOVE(&sc->sc_queue, hq, hq_list);
	splx(s);

	if ((hq = TAILQ_FIRST(&sc->sc_queue)) != NULL)
		(*hq->hq_start)(hq->hq_softc);
}

int
hpibid(unit, slave)
	int unit, slave;
{
	short id;
	int ohpibtimeout;

	/*
	 * XXX shorten timeout value so autoconfig doesn't
	 * take forever on slow CPUs.
	 */
	ohpibtimeout = hpibtimeout;
	if (cputype == CPU_68040)
		hpibtimeout = hpibidtimeout * (cpuspeed / 3);
	else
		hpibtimeout = hpibidtimeout * (cpuspeed / 8);
	if (hpibrecv(unit, 31, slave, &id, 2) != 2)
		id = 0;
	hpibtimeout = ohpibtimeout;
	return(id);
}

int
hpibsend(unit, slave, sec, addr, cnt)
	int unit, slave, sec, cnt;
	void *addr;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];

	return ((*sc->sc_ops->hpib_send)(sc, slave, sec, addr, cnt));
}

int
hpibrecv(unit, slave, sec, addr, cnt)
	int unit, slave, sec, cnt;
	void *addr;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];

	return ((*sc->sc_ops->hpib_recv)(sc, slave, sec, addr, cnt));
}

int
hpibpptest(unit, slave)
	int unit;
	int slave;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];

	return ((*sc->sc_ops->hpib_ppoll)(sc) & (0x80 >> slave));
}

void
hpibppclear(unit)
	int unit;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];

	sc->sc_flags &= ~HPIBF_PPOLL;
}

void
hpibawait(unit)
	int unit;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];

	sc->sc_flags |= HPIBF_PPOLL;
	(*sc->sc_ops->hpib_ppwatch)(sc);
}

int
hpibswait(unit, slave)
	int unit;
	int slave;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];
	int timo = hpibtimeout;
	int mask, (*ppoll)(struct hpibbus_softc *);

	ppoll = sc->sc_ops->hpib_ppoll;
	mask = 0x80 >> slave;
	while (((*ppoll)(sc) & mask) == 0) {
		if (--timo == 0) {
			printf("%s: swait timeout\n", sc->sc_dev.dv_xname);
			return(-1);
		}
	}
	return(0);
}

int
hpibustart(unit)
	int unit;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];

	if (sc->sc_type == HPIBA)
		sc->sc_dq->dq_chan = DMA0;
	else
		sc->sc_dq->dq_chan = DMA0 | DMA1;
	if (dmareq(sc->sc_dq))
		return(1);
	return(0);
}

void
hpibstart(arg)
	void *arg;
{
	struct hpibbus_softc *sc = arg;
	struct hpibqueue *hq;

	hq = TAILQ_FIRST(&sc->sc_queue);
	(*hq->hq_go)(hq->hq_softc);
}

void
hpibgo(unit, slave, sec, vbuf, count, rw, timo)
	int unit, slave, sec;
	void *vbuf;
	int count, rw, timo;
{
	struct hpibbus_softc *sc = hpibbus_cd.cd_devs[unit];

	(*sc->sc_ops->hpib_go)(sc, slave, sec, vbuf, count, rw, timo);
}

void
hpibdone(arg)
	void *arg;
{
	struct hpibbus_softc *sc = arg;

	(*sc->sc_ops->hpib_done)(sc);
}

int
hpibintr(arg)
	void *arg;
{
	struct hpibbus_softc *sc = arg;

	return ((sc->sc_ops->hpib_intr)(arg));
}
@


1.14
log
@In hpibid(), when computing timeouts from the cpuspeed variable, account for
68040 systems where cpuspeed is only 3/8 of the intended value.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.13 2005/11/16 21:23:55 miod Exp $	*/
@


1.13
log
@Overhaul the way HP-IB devices are probed. We will now do an exhaustive
probe of the (slave, punit) tuple space, since this is the only way we
can get a dual disk or dual tape enclosure to attach two devices of the
same kind.

This allows us to get rid of the hpibbus resource map and related
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.12 2005/11/14 20:21:42 miod Exp $	*/
d280 4
a283 1
	hpibtimeout = hpibidtimeout * (cpuspeed / 8);
@


1.12
log
@Use config_found_sm() in the probe machinery. This is simpler and allows us
to report HP-IB devices found for which no driver attached.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.11 2004/12/25 23:02:24 miod Exp $	*/
d65 1
a65 1
int	hpibbussearch(struct device *, void *, void *);
a67 3
int	hpibbus_alloc(struct hpibbus_softc *, int, int);
void	hpibbus_free(struct hpibbus_softc *, int, int);

d82 1
a82 1
 * of a SCSI ID, and punit, the analog of a SCSI LUN.  Unforunately,
d92 3
a94 11
 * These two nasty bits mean that we have to treat HP-IB as
 * an indirect bus.  However, since we are given some ID
 * information, it is unreasonable to disallow cloning of
 * CS/80 devices.
 *
 * To deal with all of this, we use the semi-twisted scheme
 * in hpibbus_attach_children().  For each HP-IB slave, we loop
 * through all of the possibly-configured children, allowing
 * them to modify the punit parameter (but NOT the slave!).
 *
 * This is evil, but what can you do?
d149 2
a150 1
	int slave;
d152 1
a152 1
	for (slave = 0; slave < 8; slave++) {
d157 2
d160 6
a165 1
		ha.ha_id = hpibid(sc->sc_dev.dv_unit, slave);
d167 10
a176 8
		ha.ha_slave = slave;	/* not to be modified by children */
		ha.ha_punit = 0;	/* children modify this */

		/*
		 * Search though all configured children for this bus.
		 */
		(void)config_found_sm(&sc->sc_dev, &ha, hpibbusprint,
		    hpibbussearch);
d181 1
a181 1
hpibbussearch(parent, match, aux)
a185 1
	struct hpibbus_softc *sc = (struct hpibbus_softc *)parent;
a186 1
	int pri;
d188 7
a194 26
	/* Make sure this is in a consistent state. */
	ha->ha_punit = 0;

	pri = (*cf->cf_attach->ca_match)(parent, cf, ha);
	if (pri > 0) {
		/*
		 * The device probe has succeeded, and filled in
		 * the punit information.  Make sure the configuration
		 * allows for this slave/punit combination.
		 */
		if (cf->hpibbuscf_slave != HPIBBUS_SLAVE_UNK &&
		    cf->hpibbuscf_slave != ha->ha_slave)
			return (0);
		if (cf->hpibbuscf_punit != HPIBBUS_PUNIT_UNK &&
		    cf->hpibbuscf_punit != ha->ha_punit)
			return (0);

		/*
		 * Allocate the device's address from the bus's
		 * resource map.
		 */
		if (hpibbus_alloc(sc, ha->ha_slave, ha->ha_punit))
			return (0);
	}

	return (pri);
d205 1
a205 1
		if (ha->ha_id == 0)
a408 35
}

int
hpibbus_alloc(sc, slave, punit)
	struct hpibbus_softc *sc;
	int slave, punit;
{

	if (slave >= HPIB_NSLAVES ||
	    punit >= HPIB_NPUNITS)
		panic("hpibbus_alloc: device address out of range");

	if (sc->sc_rmap[slave][punit] == 0) {
		sc->sc_rmap[slave][punit] = 1;
		return (0);
	}
	return (1);
}

void
hpibbus_free(sc, slave, punit)
	struct hpibbus_softc *sc;
	int slave, punit;
{

	if (slave >= HPIB_NSLAVES ||
	    punit >= HPIB_NPUNITS)
		panic("hpibbus_free: device address out of range");

#ifdef DIAGNOSTIC
	if (sc->sc_rmap[slave][punit] == 0)
		panic("hpibbus_free: not allocated");
#endif

	sc->sc_rmap[slave][punit] = 0;
@


1.11
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.10 2003/06/02 23:27:44 millert Exp $	*/
d176 2
a177 1
		(void)config_search(hpibbussearch, &sc->sc_dev, &ha);
d189 1
d194 2
a195 1
	if ((*cf->cf_attach->ca_match)(parent, cf, ha) > 0) {
d203 1
a203 1
			goto out;
d206 1
a206 1
			goto out;
d213 2
a214 1
			goto out;
d216 1
a216 7
		/*
		 * This device is allowed; attach it.
		 */
		config_attach(parent, cf, ha, hpibbusprint);
	}
 out:
	return (0);
d226 5
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.9 2002/03/14 01:26:30 millert Exp $	*/
d265 1
a265 1
	if (sc->sc_queue.tqh_first == hq)
d283 1
a283 1
	if ((hq = sc->sc_queue.tqh_first) != NULL)
d397 1
a397 1
	hq = sc->sc_queue.tqh_first;
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.8 1997/07/06 08:01:53 downsj Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.7 1997/04/16 11:56:09 downsj Exp $	*/
d57 2
a58 2
int	hpibbusmatch __P((struct device *, void *, void *));
void	hpibbusattach __P((struct device *, struct device *, void *));
d68 3
a70 3
void	hpibbus_attach_children __P((struct hpibbus_softc *));
int	hpibbussearch __P((struct device *, void *, void *));
int	hpibbusprint __P((void *, const char *));
d72 2
a73 2
int	hpibbus_alloc __P((struct hpibbus_softc *, int, int));
void	hpibbus_free __P((struct hpibbus_softc *, int, int));
d75 2
a76 2
void	hpibstart __P((void *));
void	hpibdone __P((void *));
d366 1
a366 1
	int mask, (*ppoll) __P((struct hpibbus_softc *));
@


1.8.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.8 1997/07/06 08:01:53 downsj Exp $	*/
d57 2
a58 2
int	hpibbusmatch(struct device *, void *, void *);
void	hpibbusattach(struct device *, struct device *, void *);
d68 3
a70 3
void	hpibbus_attach_children(struct hpibbus_softc *);
int	hpibbussearch(struct device *, void *, void *);
int	hpibbusprint(void *, const char *);
d72 2
a73 2
int	hpibbus_alloc(struct hpibbus_softc *, int, int);
void	hpibbus_free(struct hpibbus_softc *, int, int);
d75 2
a76 2
void	hpibstart(void *);
void	hpibdone(void *);
d366 1
a366 1
	int mask, (*ppoll)(struct hpibbus_softc *);
@


1.8.12.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 2
a58 2
int	hpibbusmatch(struct device *, void *, void *);
void	hpibbusattach(struct device *, struct device *, void *);
d68 3
a70 3
void	hpibbus_attach_children(struct hpibbus_softc *);
int	hpibbussearch(struct device *, void *, void *);
int	hpibbusprint(void *, const char *);
d72 2
a73 2
int	hpibbus_alloc(struct hpibbus_softc *, int, int);
void	hpibbus_free(struct hpibbus_softc *, int, int);
d75 2
a76 2
void	hpibstart(void *);
void	hpibdone(void *);
d366 1
a366 1
	int mask, (*ppoll)(struct hpibbus_softc *);
@


1.8.12.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpib.c,v 1.8.12.1 2002/03/28 10:07:18 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpib.c,v 1.6 1997/02/03 04:47:33 downsj Exp $	*/
/*	$NetBSD: hpib.c,v 1.15 1997/04/14 02:31:33 thorpej Exp $	*/
d55 1
@


1.6
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpib.c,v 1.5 1997/01/12 15:12:45 downsj Exp $	*/
/*	$NetBSD: hpib.c,v 1.13 1997/01/30 09:06:51 thorpej Exp $	*/
a54 1
#include <hp300/hp300/isr.h>
d249 1
a249 1
	register int unit;
d331 1
a331 1
	register int unit;
d348 1
d360 1
a360 1
	register int unit;
d364 2
a365 2
	register int timo = hpibtimeout;
	register int mask, (*ppoll) __P((struct hpibbus_softc *));
d398 1
a398 1
	register struct hpibqueue *hq;
@


1.5
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: hpib.c,v 1.12 1996/12/09 03:16:27 thorpej Exp $	*/
d5 1
d41 1
a41 1
 * HPIB driver
a42 2
#include "hpib.h"
#if NHPIB > 0
d47 4
a51 1
#include <hp300/dev/device.h>
a52 1
#include <hp300/dev/dmavar.h>
d57 5
a61 15
int	hpibmatch __P((struct hp_ctlr *));
void	hpibattach __P((struct hp_ctlr *));
void	hpibstart __P((int));
void	hpibgo __P((int, int, int, void *, int, int, int));
void	hpibdone __P((int));
int	hpibintr __P((void *));

struct	driver hpibdriver = {
	hpibmatch,
	hpibattach,
	"hpib",
	(int(*)())hpibstart,			/* XXX */
	(int(*)())hpibgo,			/* XXX */
	hpibintr,
	(int(*)())hpibdone,			/* XXX */
d64 3
a66 1
struct	hpib_softc hpib_softc[NHPIB];
d68 9
a76 4
extern	int nhpibtype __P((struct hp_ctlr *));	/* XXX */
extern	int fhpibtype __P((struct hp_ctlr *));	/* XXX */
extern	void nhpibattach __P((struct hp_ctlr *));	/* XXX */
extern	void fhpibattach __P((struct hp_ctlr *));	/* XXX */
d82 30
d113 3
a115 2
hpibmatch(hc)
	register struct hp_ctlr *hc;
a116 2
	struct hp_hw *hw = hc->hp_args;
	extern caddr_t internalhpib;
d118 29
a146 10
	/* Special case for internal HP-IB. */
	if ((hw->hw_sc == 7) && internalhpib)
		goto hwid_ok;

	switch (hw->hw_id) {
	case 8:			/* 98625B */
	case 128:		/* 98624A */
 hwid_ok:
		if (nhpibtype(hc) || fhpibtype(hc))
			return (1);
d148 3
d152 5
a156 1
	return (0);
d160 2
a161 2
hpibattach(hc)
	struct hp_ctlr *hc;
d163 2
a164 1
	struct hpib_softc *hs = &hpib_softc[hc->hp_unit];
d166 54
a219 19
	/*
	 * Call the appropriate "attach" routine for this controller.
	 * The type is set in the "type" routine.
	 *
	 * XXX This is, by the way, exactly backwards.
	 */
	switch (hs->sc_type) {
	case HPIBA:
	case HPIBB:
		nhpibattach(hc);
		break;

	case HPIBC:
		fhpibattach(hc);
		break;

	default:
		panic("hpibattach: unknown type 0x%x", hs->sc_type);
		/* NOTREACHED */
d221 10
d232 14
a245 12
	hs->sc_hc = hc;
	hs->sc_dq.dq_unit = hc->hp_unit;
	hs->sc_dq.dq_driver = &hpibdriver;
	hs->sc_sq.dq_forw = hs->sc_sq.dq_back = &hs->sc_sq;

	/* Establish the interrupt handler. */
	(void) isrlink(hpibintr, hs, hc->hp_ipl, ISRPRI_BIO);
	dmacomputeipl();

	/* Reset the controller, display what we've seen, and we're done. */
	hpibreset(hc->hp_unit);
	printf(": %s\n", hs->sc_descrip);
d252 1
d254 1
a254 1
	(hpib_softc[unit].sc_controller->hpib_reset)(unit);
d258 13
a270 4
hpibreq(dq)
	register struct devqueue *dq;
{
	register struct devqueue *hq;
d272 1
a272 5
	hq = &hpib_softc[dq->dq_ctlr].sc_sq;
	insque(dq, hq->dq_back);
	if (dq->dq_back == hq)
		return(1);
	return(0);
d276 10
a285 4
hpibfree(dq)
	register struct devqueue *dq;
{
	register struct devqueue *hq;
d287 2
a288 4
	hq = &hpib_softc[dq->dq_ctlr].sc_sq;
	remque(dq);
	if ((dq = hq->dq_forw) != hq)
		(dq->dq_driver->d_start)(dq->dq_unit);
d315 1
d317 1
a317 2
	return ((hpib_softc[unit].sc_controller->hpib_send)(unit, slave,
	    sec, addr, cnt));
d325 1
d327 1
a327 2
	return ((hpib_softc[unit].sc_controller->hpib_recv)(unit, slave,
	    sec, addr, cnt));
d335 1
d337 1
a337 2
	return ((hpib_softc[unit].sc_controller->hpib_ppoll)(unit) &
	    (0x80 >> slave));
d344 3
a346 1
	hpib_softc[unit].sc_flags &= ~HPIBF_PPOLL;
d352 1
a352 1
	register struct hpib_softc *hs = &hpib_softc[unit];
d354 2
a355 2
	hs->sc_flags |= HPIBF_PPOLL;
	(hs->sc_controller->hpib_ppwatch)((void *)unit);
d363 1
d365 1
a365 1
	register int mask, (*ppoll) __P((int));
d367 1
a367 1
	ppoll = hpib_softc[unit].sc_controller->hpib_ppoll;
d369 1
a369 1
	while (((ppoll)(unit) & mask) == 0)
d371 1
a371 2
			printf("%s: swait timeout\n",
			    hpib_softc[unit].sc_hc->hp_xname);
d374 1
d382 1
a382 1
	register struct hpib_softc *hs = &hpib_softc[unit];
d384 2
a385 2
	if (hs->sc_type == HPIBA)
		hs->sc_dq.dq_ctlr = DMA0;
d387 2
a388 2
		hs->sc_dq.dq_ctlr = DMA0 | DMA1;
	if (dmareq(&hs->sc_dq))
d394 2
a395 2
hpibstart(unit)
	int unit;
d397 5
a401 4
	register struct devqueue *dq;
	
	dq = hpib_softc[unit].sc_sq.dq_forw;
	(dq->dq_driver->d_go)(dq->dq_unit);
d405 4
a408 3
hpibgo(unit, slave, sec, addr, count, rw, timo)
	int unit, slave, sec, count, rw, timo;
	void *addr;
d410 1
d412 1
a412 2
	(hpib_softc[unit].sc_controller->hpib_go)(unit, slave, sec,
	    addr, count, rw, timo);
d416 2
a417 2
hpibdone(unit)
	register int unit;
d419 1
d421 1
a421 1
	(hpib_softc[unit].sc_controller->hpib_done)(unit);
d428 36
a463 1
	struct hpib_softc *hs = arg;
d465 1
a465 1
	return ((hs->sc_controller->hpib_intr)(arg));
a466 1
#endif /* NHPIB > 0 */
@


1.4
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: hpib.c,v 1.9 1996/05/17 15:09:39 thorpej Exp $	*/
d139 2
a140 1
	isrlink(hpibintr, hs, hc->hp_ipl, ISRPRI_BIO);
@


1.3
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: hpib.c,v 1.8 1996/02/14 02:44:28 thorpej Exp $	*/
d190 1
a190 1
	hpibtimeout = hpibidtimeout * cpuspeed;
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: hpib.c,v 1.7 1995/12/02 18:22:01 thorpej Exp $	*/
d60 1
a60 1
int	hpibintr __P((int));
a72 1
struct	isr hpib_isr[NHPIB];
d114 2
d138 1
a138 4
	hpib_isr[hc->hp_unit].isr_intr = hpibintr;
	hpib_isr[hc->hp_unit].isr_ipl = hc->hp_ipl;
	hpib_isr[hc->hp_unit].isr_arg = hc->hp_unit;
	isrlink(&hpib_isr[hc->hp_unit]);
d306 2
a307 2
hpibintr(unit)
	register int unit;
d309 1
d311 1
a311 1
	return ((hpib_softc[unit].sc_controller->hpib_intr)(unit));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: hpib.c,v 1.5 1995/01/07 10:30:12 mycroft Exp $	*/
d55 7
a61 1
int	hpibinit(), hpibstart(), hpibgo(), hpibintr(), hpibdone();
d63 7
a69 1
	hpibinit, "hpib", hpibstart, hpibgo, hpibintr, hpibdone,
d74 5
a78 1
int	nhpibppoll(), fhpibppoll();
d84 2
a85 1
hpibinit(hc)
d88 43
a130 4
	register struct hpib_softc *hs = &hpib_softc[hc->hp_unit];
	
	if (!nhpibtype(hc) && !fhpibtype(hc))
		return(0);
d135 2
d141 2
d144 1
a144 1
	return(1);
d147 1
d151 2
a152 4
	if (hpib_softc[unit].sc_type == HPIBC)
		fhpibreset(unit);
	else
		nhpibreset(unit);
d155 1
d168 1
d180 1
d199 1
d201 2
a202 2
	register int unit;
	int slave, sec, addr, cnt;
d204 3
a206 4
	if (hpib_softc[unit].sc_type == HPIBC)
		return(fhpibsend(unit, slave, sec, addr, cnt));
	else
		return(nhpibsend(unit, slave, sec, addr, cnt));
d209 1
d211 2
a212 2
	register int unit;
	int slave, sec, addr, cnt;
d214 3
a216 4
	if (hpib_softc[unit].sc_type == HPIBC)
		return(fhpibrecv(unit, slave, sec, addr, cnt));
	else
		return(nhpibrecv(unit, slave, sec, addr, cnt));
d219 1
a223 1
	int (*ppoll)();
d225 2
a226 2
	ppoll = (hpib_softc[unit].sc_type == HPIBC) ? fhpibppoll : nhpibppoll;
	return((*ppoll)(unit) & (0x80 >> slave));
d229 1
d242 1
a242 4
	if (hs->sc_type == HPIBC)
		fhpibppwatch((void *)unit);
	else
		nhpibppwatch((void *)unit);
d245 1
d251 1
a251 1
	register int mask, (*ppoll)();
d253 1
a253 1
	ppoll = (hpib_softc[unit].sc_type == HPIBC) ? fhpibppoll : nhpibppoll;
d257 2
a258 1
			printf("hpib%d: swait timeout\n", unit);
d264 1
d279 1
d289 1
d291 2
a292 2
	register int unit;
	int slave, sec, addr, count, rw;
d294 3
a296 4
	if (hpib_softc[unit].sc_type == HPIBC)
		fhpibgo(unit, slave, sec, addr, count, rw, timo);
	else
		nhpibgo(unit, slave, sec, addr, count, rw, timo);
d299 1
d303 2
a304 4
	if (hpib_softc[unit].sc_type == HPIBC)
		fhpibdone(unit);
	else
		nhpibdone(unit);
d307 1
a310 1
	int found;
d312 1
a312 5
	if (hpib_softc[unit].sc_type == HPIBC)
		found = fhpibintr(unit);
	else
		found = nhpibintr(unit);
	return(found);
d314 1
a314 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
