head	1.17;
access;
symbols
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.11.0.16
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.14
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.12
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.10
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2005.01.14.22.39.25;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.27.45;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.25.23.23.01;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.05.01.16.51.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.03.06.17.24.12;	author millert;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	97.04.16.11.56.10;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.02.05.16.01.19;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.02.04.06.21.26;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.02.03.04.47.38;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.12.15.12.49;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.11.47.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.25.06.36.43;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.05.28.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.22.10.31.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.20;	author deraadt;	state Exp;
branches;
next	;

1.11.10.1
date	2001.07.04.10.15.29;	author niklas;	state Exp;
branches;
next	1.11.10.2;

1.11.10.2
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.11.10.3;

1.11.10.3
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.11.10.4;

1.11.10.4
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.11.10.5;

1.11.10.5
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@/*	$OpenBSD: ite.c,v 1.16 2003/10/03 16:44:49 miod Exp $	*/
/*	$NetBSD: ite.c,v 1.38 1997/03/31 07:37:25 scottr Exp $	*/

/*
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: ite.c 1.28 92/12/20$
 *
 *	@@(#)ite.c	8.2 (Berkeley) 1/12/94
 */

/*
 * Bit-mapped display terminal emulator machine independent code.
 * This is a very rudimentary.  Much more can be abstracted out of
 * the hardware dependent routines.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <machine/autoconf.h>

#include <dev/cons.h>

#include <hp300/dev/grfioctl.h>
#include <hp300/dev/grfvar.h>
#include <hp300/dev/hilioctl.h>
#include <hp300/dev/hilvar.h>
#include <hp300/dev/itevar.h>
#include <hp300/dev/kbdmap.h>

/* prototypes for devsw entry points */
cdev_decl(ite);

#define set_attr(ip, attr)	((ip)->attribute |= (attr))
#define clr_attr(ip, attr)	((ip)->attribute &= ~(attr))

/*
 * # of chars are output in a single itestart() call.
 * If this is too big, user processes will be blocked out for
 * long periods of time while we are emptying the queue in itestart().
 * If it is too small, console output will be very ragged.
 */
int	iteburst = 64;

struct  ite_data *kbd_ite = NULL;

int	itematch(struct device *, void *, void *);
void	iteattach(struct device *, struct device *, void *);

struct cfattach ite_ca = {
	sizeof(struct ite_softc), itematch, iteattach
};

struct cfdriver ite_cd = {
	NULL, "ite", DV_TTY
};

/*
 * Terminal emulator state information, statically allocated
 * for the benefit of the console.
 */
struct	ite_data ite_cn;

void	iteinit(struct ite_data *);
void	iteputchar(int, struct ite_data *);
void	itecheckwrap(struct ite_data *, struct itesw *);
void	ite_dchar(struct ite_data *, struct itesw *);
void	ite_ichar(struct ite_data *, struct itesw *);
void	ite_dline(struct ite_data *, struct itesw *);
void	ite_iline(struct ite_data *, struct itesw *);
void	ite_clrtoeol(struct ite_data *, struct itesw *, int, int);
void	ite_clrtoeos(struct ite_data *, struct itesw *);
void	itestart(struct tty *);

/*
 * Primary attribute buffer to be used by the first bitmapped console
 * found. Secondary displays alloc the attribute buffer as needed.
 * Size is based on a 68x128 display, which is currently our largest.
 */
u_char  ite_console_attributes[0x2200];

#define ite_erasecursor(ip, sp)	{ \
	if ((ip)->flags & ITE_CURSORON) \
		(*(sp)->ite_cursor)((ip), ERASE_CURSOR); \
}
#define ite_drawcursor(ip, sp) { \
	if ((ip)->flags & ITE_CURSORON) \
		(*(sp)->ite_cursor)((ip), DRAW_CURSOR); \
}
#define ite_movecursor(ip, sp) { \
	if ((ip)->flags & ITE_CURSORON) \
		(*(sp)->ite_cursor)((ip), MOVE_CURSOR); \
}

int
itematch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{

	return (1);
}

void
iteattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ite_softc *ite = (struct ite_softc *)self;
	struct grf_softc *grf = (struct grf_softc *)parent;
	struct grfdev_attach_args *ga = aux;

	/* Allocate the ite_data. */
	if (ga->ga_isconsole) {
		ite->sc_data = &ite_cn;
		printf(": console");

		/*
		 * We didn't know which unit this would be during
		 * the console probe, so we have to fixup cn_dev here.
		 */
		cn_tab->cn_dev = makedev(ite_major(), self->dv_unit);
	} else {
		ite->sc_data =
		    (struct ite_data *)malloc(sizeof(struct ite_data),
		    M_DEVBUF, M_NOWAIT);
		if (ite->sc_data == NULL) {
			printf("\n%s: malloc for ite_data failed\n",
			    ite->sc_dev.dv_xname);
			return;
		}
		bzero(ite->sc_data, sizeof(struct ite_data));
		ite->sc_data->isw = (struct itesw *)ga->ga_ite;
		ite->sc_data->grf = (struct grf_data *)ga->ga_data;
		ite->sc_data->flags = ITE_ALIVE;
	}

	/*
	 * Cross-reference the ite and the grf.
	 */
	ite->sc_grf = grf;
	grf->sc_ite = ite;

	printf("\n");
}

/*
 * Perform functions necessary to setup device as a terminal emulator.
 */
int
iteon(ip, flag)
	struct ite_data *ip;
	int flag;
{

	if ((ip->flags & ITE_ALIVE) == 0)
		return(ENXIO);

	/* force ite active, overriding graphics mode */
	if (flag & 1) {
		ip->flags |= ITE_ACTIVE;
		ip->flags &= ~(ITE_INGRF|ITE_INITED);
	}

	/* leave graphics mode */
	if (flag & 2) {
		ip->flags &= ~ITE_INGRF;
		if ((ip->flags & ITE_ACTIVE) == 0)
			return(0);
	}

	ip->flags |= ITE_ACTIVE;
	if (ip->flags & ITE_INGRF)
		return(0);

	if (kbd_ite == NULL || kbd_ite == ip) {
		kbd_ite = ip;
		kbdenable(0);		/* XXX */
	}

	iteinit(ip);
	return(0);
}

void
iteinit(ip)
	struct ite_data *ip;
{

	if (ip->flags & ITE_INITED)
		return;
	
	ip->curx = 0;
	ip->cury = 0;
	ip->cursorx = 0;
	ip->cursory = 0;

	(*ip->isw->ite_init)(ip);
	ip->flags |= ITE_CURSORON;
	ite_drawcursor(ip, ip->isw);

	ip->attribute = 0;
	if (ip->attrbuf == NULL)
		ip->attrbuf = (u_char *)
			malloc(ip->rows * ip->cols, M_DEVBUF, M_WAITOK);
	bzero(ip->attrbuf, (ip->rows * ip->cols));

	ip->imode = 0;
	ip->flags |= ITE_INITED;
}

/*
 * "Shut down" device as terminal emulator.
 * Note that we do not deinit the console device unless forced.
 * Deinit'ing the console every time leads to a very active
 * screen when processing /etc/rc.
 */
void
iteoff(ip, flag)
	struct ite_data *ip;
	int flag;
{

	if (flag & 2) {
		ip->flags |= ITE_INGRF;
		ip->flags &= ~ITE_CURSORON;
	}
	if ((ip->flags & ITE_ACTIVE) == 0)
		return;
	if ((flag & 1) ||
	    (ip->flags & (ITE_INGRF|ITE_ISCONS|ITE_INITED)) == ITE_INITED)
		(*ip->isw->ite_deinit)(ip);

	/*
	 * XXX When the system is rebooted with "reboot", init(8)
	 * kills the last process to have the console open.
	 * If we don't prevent the ITE_ACTIVE bit from being
	 * cleared, we will never see messages printed during
	 * the process of rebooting.
	 */
	if ((flag & 2) == 0 && (ip->flags & ITE_ISCONS) == 0)
		ip->flags &= ~ITE_ACTIVE;
}

/* ARGSUSED */
int
iteopen(dev, mode, devtype, p)
	dev_t dev;
	int mode, devtype;
	struct proc *p;
{
	int unit = ITEUNIT(dev);
	struct tty *tp;
	struct ite_softc *sc;
	struct ite_data *ip;
	int error;
	int first = 0;

	if (unit >= ite_cd.cd_ndevs ||
	    (sc = ite_cd.cd_devs[unit]) == NULL)
		return (ENXIO);
	ip = sc->sc_data;

	if (ip->tty == NULL) {
	 	tp = ip->tty = ttymalloc();
	} else
		tp = ip->tty;
	if ((tp->t_state&(TS_ISOPEN|TS_XCLUDE)) == (TS_ISOPEN|TS_XCLUDE)
	    && p->p_ucred->cr_uid != 0)
		return (EBUSY);
	if ((ip->flags & ITE_ACTIVE) == 0) {
		error = iteon(ip, 0);
		if (error)
			return (error);
		first = 1;
	}
	tp->t_oproc = itestart;
	tp->t_param = NULL;
	tp->t_dev = dev;
	if ((tp->t_state&TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = CS8|CREAD;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		tp->t_state = TS_ISOPEN|TS_CARR_ON;
		ttsetwater(tp);
	}
	error = (*linesw[tp->t_line].l_open)(dev, tp);
	if (error == 0) {
		tp->t_winsize.ws_row = ip->rows;
		tp->t_winsize.ws_col = ip->cols;
	} else if (first)
		iteoff(ip, 0);
	return (error);
}

/*ARGSUSED*/
int
iteclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct ite_softc *sc = ite_cd.cd_devs[ITEUNIT(dev)];
	struct ite_data *ip = sc->sc_data;
	struct tty *tp = ip->tty;

	(*linesw[tp->t_line].l_close)(tp, flag);
	ttyclose(tp);
	iteoff(ip, 0);
#if 0
	ttyfree(tp);
	ip->tty = (struct tty *)0;
#endif
	return(0);
}

int
iteread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct ite_softc *sc = ite_cd.cd_devs[ITEUNIT(dev)];
	struct tty *tp = sc->sc_data->tty;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
itewrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct ite_softc *sc = ite_cd.cd_devs[ITEUNIT(dev)];
	struct tty *tp = sc->sc_data->tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
itetty(dev)
	dev_t dev;
{
	struct ite_softc *sc = ite_cd.cd_devs[ITEUNIT(dev)];

	return (sc->sc_data->tty);
}

int
iteioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct ite_softc *sc = ite_cd.cd_devs[ITEUNIT(dev)];
	struct ite_data *ip = sc->sc_data;
	struct tty *tp = ip->tty;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, addr, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, addr, flag, p);
	if (error >= 0)
		return (error);
	return (ENOTTY);
}

void
itestart(tp)
	struct tty *tp;
{
	int cc, s;
	int hiwat = 0, hadcursor = 0;
	struct ite_softc *sc;
	struct ite_data *ip;

	sc = ite_cd.cd_devs[ITEUNIT(tp->t_dev)];
	ip = sc->sc_data;

	s = splkbd();
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP)) {
		splx(s);
		return;
	}
	tp->t_state |= TS_BUSY;
	cc = tp->t_outq.c_cc;
	if (cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
	/*
	 * Handle common (?) case
	 */
	if (cc == 1) {
		iteputchar(getc(&tp->t_outq), ip);
	} else if (cc) {
		/*
		 * Limit the amount of output we do in one burst
		 * to prevent hogging the CPU.
		 */
		if (cc > iteburst) {
			hiwat++;
			cc = iteburst;
		}
		/*
		 * Turn off cursor while we output multiple characters.
		 * Saves a lot of expensive window move operations.
		 */
		if (ip->flags & ITE_CURSORON) {
			ite_erasecursor(ip, ip->isw);
			ip->flags &= ~ITE_CURSORON;
			hadcursor = 1;
		}
		while (--cc >= 0)
			iteputchar(getc(&tp->t_outq), ip);
		if (hadcursor) {
			ip->flags |= ITE_CURSORON;
			ite_drawcursor(ip, ip->isw);
		}
		if (hiwat) {
			tp->t_state |= TS_TIMEOUT;
			timeout_add(&tp->t_rstrt_to, 1);
		}
	}
	tp->t_state &= ~TS_BUSY;
	splx(s);
}

int
itestop(tp, flag)
	struct tty *tp;
	int flag;
{
	return (0);
}

void
itefilter(stat, c)
	char stat, c;
{
	static int capsmode = 0;
	static int metamode = 0;
	char code, *str;
	struct tty *kbd_tty = kbd_ite->tty;

	if (kbd_tty == NULL)
		return;

	switch (c & 0xFF) {
	case KBD_CAPSLOCK:
		capsmode = !capsmode;
		return;

	case KBD_EXT_LEFT_DOWN:
	case KBD_EXT_RIGHT_DOWN:
		metamode = 1;
		return;
		
	case KBD_EXT_LEFT_UP:
	case KBD_EXT_RIGHT_UP:
		metamode = 0;
		return;
	}

	c &= KBD_CHARMASK;
	switch ((stat>>KBD_SSHIFT) & KBD_SMASK) {
	default:
	case KBD_KEY:
	        if (!capsmode) {
			code = kbd_keymap[(int)c];
			break;
		}
		/* FALLTHROUGH */

	case KBD_SHIFT:
		code = kbd_shiftmap[(int)c];
		break;

	case KBD_CTRL:
		code = kbd_ctrlmap[(int)c];
		break;
		
	case KBD_CTRLSHIFT:	
		code = kbd_ctrlshiftmap[(int)c];
		break;
        }

	if (code == '\0' && (str = kbd_stringmap[(int)c]) != '\0') {
		while (*str)
			(*linesw[kbd_tty->t_line].l_rint)(*str++, kbd_tty);
	} else {
		if (metamode)
			code |= 0x80;
		(*linesw[kbd_tty->t_line].l_rint)(code, kbd_tty);
	}
}

void
iteputchar(c, ip)
	int c;
	struct ite_data *ip;
{
	struct itesw *sp = ip->isw;
	int n;

	if ((ip->flags & (ITE_ACTIVE|ITE_INGRF)) != ITE_ACTIVE)
	  	return;

	if (ip->escape) {
doesc:
		switch (ip->escape) {

		case '&':			/* Next can be a,d, or s */
			if (ip->fpd++) {
				ip->escape = c;
				ip->fpd = 0;
			}
			return;

		case 'a':				/* cursor change */
			switch (c) {

			case 'Y':			/* Only y coord. */
				ip->cury = min(ip->pos, ip->rows-1);
				ip->pos = 0;
				ip->escape = 0;
				ite_movecursor(ip, sp);
				clr_attr(ip, ATTR_INV);
				break;

			case 'y':			/* y coord first */
				ip->cury = min(ip->pos, ip->rows-1);
				ip->pos = 0;
				ip->fpd = 0;
				break;

			case 'C':			/* x coord */
				ip->curx = min(ip->pos, ip->cols-1);
				ip->pos = 0;
				ip->escape = 0;
				ite_movecursor(ip, sp);
				clr_attr(ip, ATTR_INV);
				break;

			default:	     /* Possibly a 3 digit number. */
				if (c >= '0' && c <= '9' && ip->fpd < 3) {
					ip->pos = ip->pos * 10 + (c - '0');
					ip->fpd++;
				} else {
					ip->pos = 0;
					ip->escape = 0;
				}
				break;
			}
			return;

		case 'd':				/* attribute change */
			switch (c) {

			case 'B':
				set_attr(ip, ATTR_INV);
				break;
		        case 'D':
				/* XXX: we don't do anything for underline */
				set_attr(ip, ATTR_UL);
				break;
		        case '@@':
				clr_attr(ip, ATTR_ALL);
				break;
			}
			ip->escape = 0;
			return;

		case 's':				/* keypad control */
			switch (ip->fpd) {

			case 0:
				ip->hold = c;
				ip->fpd++;
				return;

			case 1:
				if (c == 'A') {
					switch (ip->hold) {
	
					case '0':
						clr_attr(ip, ATTR_KPAD);
						break;
					case '1':
						set_attr(ip, ATTR_KPAD);
						break;
					}
				}
				ip->hold = 0;
			}
			ip->escape = 0;
			return;

		case 'i':			/* back tab */
			if (ip->curx > TABSIZE) {
				n = ip->curx - (ip->curx & (TABSIZE - 1));
				ip->curx -= n;
			} else
				ip->curx = 0;
			ite_movecursor(ip, sp);
			ip->escape = 0;
			return;

		case '3':			/* clear all tabs */
			goto ignore;

		case 'K':			/* clear_eol */
			ite_clrtoeol(ip, sp, ip->cury, ip->curx);
			ip->escape = 0;
			return;

		case 'J':			/* clear_eos */
			ite_clrtoeos(ip, sp);
			ip->escape = 0;
			return;

		case 'B':			/* cursor down 1 line */
			if (++ip->cury == ip->rows) {
				--ip->cury;
				ite_erasecursor(ip, sp);
				(*sp->ite_scroll)(ip, 1, 0, 1, SCROLL_UP);
				ite_clrtoeol(ip, sp, ip->cury, 0);
			}
			else
				ite_movecursor(ip, sp);
			clr_attr(ip, ATTR_INV);
			ip->escape = 0;
			return;

		case 'C':			/* cursor forward 1 char */
			ip->escape = 0;
			itecheckwrap(ip, sp);
			return;

		case 'A':			/* cursor up 1 line */
			if (ip->cury > 0) {
				ip->cury--;
				ite_movecursor(ip, sp);
			}
			ip->escape = 0;
			clr_attr(ip, ATTR_INV);
			return;

		case 'P':			/* delete character */
			ite_dchar(ip, sp);
			ip->escape = 0;
			return;

		case 'M':			/* delete line */
			ite_dline(ip, sp);
			ip->escape = 0;
			return;

		case 'Q':			/* enter insert mode */
			ip->imode = 1;
			ip->escape = 0;
			return;

		case 'R':			/* exit insert mode */
			ip->imode = 0;
			ip->escape = 0;
			return;

		case 'L':			/* insert blank line */
			ite_iline(ip, sp);
			ip->escape = 0;
			return;

		case 'h':			/* home key */
			ip->cury = ip->curx = 0;
			ite_movecursor(ip, sp);
			ip->escape = 0;
			return;

		case 'D':			/* left arrow key */
			if (ip->curx > 0) {
				ip->curx--;
				ite_movecursor(ip, sp);
			}
			ip->escape = 0;
			return;

		case '1':			/* set tab in all rows */
			goto ignore;

		case ESC:
			if ((ip->escape = c) == ESC)
				break;
			ip->fpd = 0;
			goto doesc;

		default:
ignore:
			ip->escape = 0;
			return;

		}
	}

	switch (c &= 0x7F) {

	case '\n':

		if (++ip->cury == ip->rows) {
			--ip->cury;
			ite_erasecursor(ip, sp);
			(*sp->ite_scroll)(ip, 1, 0, 1, SCROLL_UP);
			ite_clrtoeol(ip, sp, ip->cury, 0);
		} else
			ite_movecursor(ip, sp);
		clr_attr(ip, ATTR_INV);
		break;

	case '\r':
		if (ip->curx) {
			ip->curx = 0;
			ite_movecursor(ip, sp);
		}
		break;
	
	case '\b':
		if (--ip->curx < 0)
			ip->curx = 0;
		else
			ite_movecursor(ip, sp);
		break;

	case '\t':
		if (ip->curx < TABEND(ip)) {
			n = TABSIZE - (ip->curx & (TABSIZE - 1));
			ip->curx += n;
			ite_movecursor(ip, sp);
		} else
			itecheckwrap(ip, sp);
		break;

	case CTRL('G'):
		if (ip == kbd_ite)
			kbdbell(0);	/* XXX */
		break;

	case ESC:
		ip->escape = ESC;
		break;

	default:
		if (c < ' ' || c == DEL)
			break;
		if (ip->imode)
			ite_ichar(ip, sp);
		if ((ip->attribute & ATTR_INV) || attrtest(ip, ATTR_INV)) {
			attrset(ip, ATTR_INV);
			(*sp->ite_putc)(ip, c, ip->cury, ip->curx, ATTR_INV);
		} else
			(*sp->ite_putc)(ip, c, ip->cury, ip->curx, ATTR_NOR);
		ite_drawcursor(ip, sp);
		itecheckwrap(ip, sp);
		break;
	}
}

void
itecheckwrap(ip, sp)
     struct ite_data *ip;
     struct itesw *sp;
{
	if (++ip->curx == ip->cols) {
		ip->curx = 0;
		clr_attr(ip, ATTR_INV);
		if (++ip->cury == ip->rows) {
			--ip->cury;
			ite_erasecursor(ip, sp);
			(*sp->ite_scroll)(ip, 1, 0, 1, SCROLL_UP);
			ite_clrtoeol(ip, sp, ip->cury, 0);
			return;
		}
	}
	ite_movecursor(ip, sp);
}

void
ite_dchar(ip, sp)
     struct ite_data *ip;
     struct itesw *sp;
{
	if (ip->curx < ip->cols - 1) {
		ite_erasecursor(ip, sp);
		(*sp->ite_scroll)(ip, ip->cury, ip->curx + 1, 1, SCROLL_LEFT);
		attrmov(ip, ip->cury, ip->curx + 1, ip->cury, ip->curx,
			1, ip->cols - ip->curx - 1);
	}
	attrclr(ip, ip->cury, ip->cols - 1, 1, 1);
	(*sp->ite_putc)(ip, ' ', ip->cury, ip->cols - 1, ATTR_NOR);
	ite_drawcursor(ip, sp);
}

void
ite_ichar(ip, sp)
     struct ite_data *ip;
     struct itesw *sp;
{
	if (ip->curx < ip->cols - 1) {
		ite_erasecursor(ip, sp);
		(*sp->ite_scroll)(ip, ip->cury, ip->curx, 1, SCROLL_RIGHT);
		attrmov(ip, ip->cury, ip->curx, ip->cury, ip->curx + 1,
			1, ip->cols - ip->curx - 1);
	}
	attrclr(ip, ip->cury, ip->curx, 1, 1);
	(*sp->ite_putc)(ip, ' ', ip->cury, ip->curx, ATTR_NOR);
	ite_drawcursor(ip, sp);
}

void
ite_dline(ip, sp)
     struct ite_data *ip;
     struct itesw *sp;
{
	if (ip->cury < ip->rows - 1) {
		ite_erasecursor(ip, sp);
		(*sp->ite_scroll)(ip, ip->cury + 1, 0, 1, SCROLL_UP);
		attrmov(ip, ip->cury + 1, 0, ip->cury, 0,
			ip->rows - ip->cury - 1, ip->cols);
	}
	ite_clrtoeol(ip, sp, ip->rows - 1, 0);
}

void
ite_iline(ip, sp)
     struct ite_data *ip;
     struct itesw *sp;
{
	if (ip->cury < ip->rows - 1) {
		ite_erasecursor(ip, sp);
		(*sp->ite_scroll)(ip, ip->cury, 0, 1, SCROLL_DOWN);
		attrmov(ip, ip->cury, 0, ip->cury + 1, 0,
			ip->rows - ip->cury - 1, ip->cols);
	}
	ite_clrtoeol(ip, sp, ip->cury, 0);
}

void
ite_clrtoeol(ip, sp, y, x)
     struct ite_data *ip;
     struct itesw *sp;
     int y, x;
{
	(*sp->ite_clear)(ip, y, x, 1, ip->cols - x);
	attrclr(ip, y, x, 1, ip->cols - x);
	ite_drawcursor(ip, sp);
}

void
ite_clrtoeos(ip, sp)
     struct ite_data *ip;
     struct itesw *sp;
{
	(*sp->ite_clear)(ip, ip->cury, 0, ip->rows - ip->cury, ip->cols);
	attrclr(ip, ip->cury, 0, ip->rows - ip->cury, ip->cols);
	ite_drawcursor(ip, sp);
}

int
ite_major()
{
	static int itemaj, initialized;

	/* Only compute once. */
	if (initialized)
		return (itemaj);
	initialized = 1;

	/* locate the major number */
	for (itemaj = 0; itemaj < nchrdev; itemaj++)
		if (cdevsw[itemaj].d_open == iteopen)
			break;

	return (itemaj);
}

/*
 * Console functions.  Console probes are done by the individual
 * framebuffer drivers.
 */

void
itecninit(gp, isw)
	struct grf_data *gp;
	struct itesw *isw;
{
	struct ite_data *ip = &ite_cn;

	/*
	 * Set up required ite data and initialize ite.
	 */
	ip->isw = isw;
	ip->grf = gp;
	ip->flags = ITE_ALIVE|ITE_CONSOLE|ITE_ACTIVE|ITE_ISCONS;
	ip->attrbuf = ite_console_attributes;
	iteinit(ip);

	/*
	 * Initialize the console keyboard.
	 */
	kbdcninit();

	kbd_ite = ip;		/* XXX */
}

/*ARGSUSED*/
int
itecngetc(dev)
	dev_t dev;
{
	int c;
	int stat;

	c = kbdgetc(&stat);
	switch ((stat >> KBD_SSHIFT) & KBD_SMASK) {
	case KBD_SHIFT:
		c = kbd_cn_shiftmap[c & KBD_CHARMASK];
		break;
	case KBD_CTRL:
		c = kbd_cn_ctrlmap[c & KBD_CHARMASK];
		break;
	case KBD_KEY:
		c = kbd_cn_keymap[c & KBD_CHARMASK];
		break;
	default:
		c = 0;
		break;
	}
	return(c);
}

/* ARGSUSED */
void
itecnputc(dev, c)
	dev_t dev;
	int c;
{
	static int paniced = 0;
	struct ite_data *ip = &ite_cn;

	if (panicstr && !paniced &&
	    (ip->flags & (ITE_ACTIVE|ITE_INGRF)) != ITE_ACTIVE) {
		(void) iteon(ip, 3);
		paniced = 1;
	}
	iteputchar(c, ip);
}
@


1.16
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.15 2003/06/02 23:27:45 millert Exp $	*/
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.14 2002/03/14 01:26:30 millert Exp $	*/
a303 1
		tty_attach(tp);
a351 1
	tty_detach(tp);
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.13 2001/11/25 23:23:01 miod Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@Typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.12 2001/05/01 16:51:09 millert Exp $	*/
d89 2
a90 2
int	itematch __P((struct device *, void *, void *));
void	iteattach __P((struct device *, struct device *, void *));
d106 10
a115 10
void	iteinit __P((struct ite_data *));
void	iteputchar __P((int, struct ite_data *));
void	itecheckwrap __P((struct ite_data *, struct itesw *));
void	ite_dchar __P((struct ite_data *, struct itesw *));
void	ite_ichar __P((struct ite_data *, struct itesw *));
void	ite_dline __P((struct ite_data *, struct itesw *));
void	ite_iline __P((struct ite_data *, struct itesw *));
void	ite_clrtoeol __P((struct ite_data *, struct itesw *, int, int));
void	ite_clrtoeos __P((struct ite_data *, struct itesw *));
void	itestart __P((struct tty *));
@


1.13.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.13 2001/11/25 23:23:01 miod Exp $	*/
d89 2
a90 2
int	itematch(struct device *, void *, void *);
void	iteattach(struct device *, struct device *, void *);
d106 10
a115 10
void	iteinit(struct ite_data *);
void	iteputchar(int, struct ite_data *);
void	itecheckwrap(struct ite_data *, struct itesw *);
void	ite_dchar(struct ite_data *, struct itesw *);
void	ite_ichar(struct ite_data *, struct itesw *);
void	ite_dline(struct ite_data *, struct itesw *);
void	ite_iline(struct ite_data *, struct itesw *);
void	ite_clrtoeol(struct ite_data *, struct itesw *, int, int);
void	ite_clrtoeos(struct ite_data *, struct itesw *);
void	itestart(struct tty *);
@


1.12
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.11 1998/03/06 17:24:12 millert Exp $	*/
d279 1
a279 1
	 * If we don't revent the the ITE_ACTIVE bit from being
@


1.11
log
@please gcc 2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.10 1997/04/16 11:56:10 downsj Exp $	*/
d476 1
a476 1
			timeout(ttrstrt, tp, 1);
@


1.11.10.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.11 1998/03/06 17:24:12 millert Exp $	*/
d476 1
a476 1
			timeout_add(&tp->t_rstrt_to, 1);
@


1.11.10.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.11.10.1 2001/07/04 10:15:29 niklas Exp $	*/
d279 1
a279 1
	 * If we don't prevent the ITE_ACTIVE bit from being
@


1.11.10.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 2
a90 2
int	itematch(struct device *, void *, void *);
void	iteattach(struct device *, struct device *, void *);
d106 10
a115 10
void	iteinit(struct ite_data *);
void	iteputchar(int, struct ite_data *);
void	itecheckwrap(struct ite_data *, struct itesw *);
void	ite_dchar(struct ite_data *, struct itesw *);
void	ite_ichar(struct ite_data *, struct itesw *);
void	ite_dline(struct ite_data *, struct itesw *);
void	ite_iline(struct ite_data *, struct itesw *);
void	ite_clrtoeol(struct ite_data *, struct itesw *, int, int);
void	ite_clrtoeos(struct ite_data *, struct itesw *);
void	itestart(struct tty *);
@


1.11.10.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.11.10.3 2002/03/28 10:07:18 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.10.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d304 1
d353 1
@


1.10
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.9 1997/02/05 16:01:19 downsj Exp $	*/
d524 1
a524 1
			code = kbd_keymap[c];
d530 1
a530 1
		code = kbd_shiftmap[c];
d534 1
a534 1
		code = kbd_ctrlmap[c];
d538 1
a538 1
		code = kbd_ctrlshiftmap[c];
d542 1
a542 1
	if (code == '\0' && (str = kbd_stringmap[c]) != '\0') {
@


1.9
log
@Non-console ITE devices need to be initialized properly, too, ya know.

Add enough glue to the aux attach structure to do so, and teach all the
device drivers how to set it.

This fixes the last ITE panic I know of...
@
text
@d1 2
a2 2
/*	$OpenBSD: ite.c,v 1.8 1997/02/04 06:21:26 downsj Exp $	*/
/*	$NetBSD: ite.c,v 1.37 1997/02/02 09:40:31 thorpej Exp $	*/
d68 2
d73 3
d400 1
a400 1
	int cmd;
d421 1
a421 1
	register struct tty *tp;
d423 1
a423 1
	register int cc, s;
d483 1
a483 1
void
d488 1
a488 1

d497 1
a497 1
  	register char code, *str;
d521 1
a521 1

d542 1
a542 1
	if (code == NULL && (str = kbd_stringmap[c]) != NULL) {
d934 1
a948 1
	extern void kbdcninit __P((void));	/* XXX */
d973 1
a973 1
	register int c;
@


1.8
log
@checkpoint:  pull in spl() changes from NetBSD, and more siginfo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ite.c,v 1.7 1997/02/03 04:47:38 downsj Exp $	*/
d170 2
@


1.7
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ite.c,v 1.6 1997/01/12 15:12:49 downsj Exp $	*/
/*	$NetBSD: ite.c,v 1.35 1997/01/30 09:18:56 thorpej Exp $	*/
a74 7
 * No need to raise SPL above the HIL (the only thing that can
 * affect our state.
 */
#include <hp300/dev/hilreg.h>
#define splite()		splhil()

/*
d170 1
d424 1
a424 6
	/*
	 * (Potentially) lower priority.  We only need to protect ourselves
	 * from keyboard interrupts since that is all that can affect the
	 * state of our tty (kernel printf doesn't go through this routine).
	 */
	s = splite();
@


1.6
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ite.c,v 1.34 1996/12/17 08:41:16 thorpej Exp $	*/
d91 1
a91 2
#ifdef NEWCONFIG
int	itematch __P((struct device *, struct cfdata *, void *));
a100 4
#else /* ! NEWCONFIG */
#include "grf.h"
struct  ite_softc ite_softc[NGRF];
#endif /* NEWCONFIG */
a138 1
#ifdef NEWCONFIG
d142 1
a142 2
	struct cfdata *match;
	void *aux;
a186 53
#else /* ! NEWCONFIG */
/*
 * Dummy for pseudo-device config.
 */
/*ARGSUSED*/
void
iteattach(n)
	int n;
{
}

/*
 * Allocate storage for ite data structures.
 * XXX This is a kludge and will go away with new config.
 */
void
ite_attach_grf(unit, isconsole)
	int unit, isconsole;
{
	struct ite_softc *ite = &ite_softc[unit];
	struct grf_softc *grf = &grf_softc[unit];

	/*
	 * Check to see if our structure is pre-allocated.
	 */
	if (isconsole) {
		ite->sc_data = &ite_cn;

		/*
		 * We didn't know which unit this would be during
		 * the console probe, so we have to fixup cn_dev here.
		 */
		cn_tab->cn_dev = makedev(ite_major(), unit);
	} else {
		ite->sc_data =
		    (struct ite_data *)malloc(sizeof(struct ite_data),
		    M_DEVBUF, M_NOWAIT);
		if (ite->sc_data == NULL) {
			printf("ite_attach_grf: malloc for ite_data failed\n");
			return;
		}
		bzero(ite->sc_data, sizeof(struct ite_data));
	}
	
	/*
	 * Cross-reference the ite and the grf.
	 */
	ite->sc_grf = grf;
	grf->sc_ite = ite;

	printf("ite%d at grf%d: attached\n", unit, unit);
}
#endif /* NEWCONFIG */
a299 1
#ifdef NEWCONFIG
a302 5
#else
	if (unit >= NGRF)
		return (ENXIO);
	sc = &ite_softc[unit];
#endif
a347 1
#ifdef NEWCONFIG
a348 3
#else
	struct ite_softc *sc = &ite_softc[ITEUNIT(dev)];
#endif
a368 1
#ifdef NEWCONFIG
a369 3
#else
	struct ite_softc *sc = &ite_softc[ITEUNIT(dev)];
#endif
a380 1
#ifdef NEWCONFIG
a381 3
#else
	struct ite_softc *sc = &ite_softc[ITEUNIT(dev)];
#endif
a390 1
#ifdef NEWCONFIG
a391 3
#else
	struct ite_softc *sc = &ite_softc[ITEUNIT(dev)];
#endif
a403 1
#ifdef NEWCONFIG
a404 3
#else
	struct ite_softc *sc = &ite_softc[ITEUNIT(dev)];
#endif
a426 1
#ifdef NEWCONFIG
a427 3
#else
	sc = &ite_softc[ITEUNIT(tp->t_dev)];
#endif
@


1.5
log
@sync to 0622
@
text
@d1 2
a2 1
/*	$NetBSD: ite.c,v 1.29.4.1 1996/06/06 15:39:12 thorpej Exp $	*/
a51 6
#include "ite.h"
#if NITE > 0

#include "grf.h"
#undef NITE
#define NITE	NGRF
d60 1
a88 1
int	nite = NITE;
d90 16
a105 1
struct  ite_softc ite_softc[NITE];
d129 1
a129 1
u_char  console_attributes[0x2200];
d144 51
d246 1
d355 2
a356 2
	struct ite_softc *sc = &ite_softc[unit];
	struct ite_data *ip = sc->sc_data;
d360 11
d414 3
d418 1
d439 3
d443 1
d455 3
d459 1
d469 3
d473 1
d486 3
d490 1
d513 3
d517 1
d1037 25
d1070 1
a1070 1
	c = kbdgetc(0, &stat);	/* XXX always read from keyboard 0 for now */
d1073 1
a1073 1
		c = kbd_shiftmap[c & KBD_CHARMASK];
d1076 1
a1076 1
		c = kbd_ctrlmap[c & KBD_CHARMASK];
d1079 1
a1079 1
		c = kbd_keymap[c & KBD_CHARMASK];
a1103 1
#endif
@


1.4
log
@sync w/ Net 960424
@
text
@d1 1
a1 1
/*	$NetBSD: ite.c,v 1.29 1996/02/24 00:55:20 thorpej Exp $	*/
d298 4
a301 3
	if (ip->tty == NULL)
		tp = ip->tty = ttymalloc();
	else
d349 1
@


1.3
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: ite.c,v 1.28 1995/11/19 23:14:22 thorpej Exp $	*/
d4 1
d66 4
d94 1
a94 2
struct	tty *ite_tty[NITE];
struct  ite_softc *kbd_ite = NULL;
d97 16
a112 1
void	itestart();
d138 1
d145 42
d189 3
a191 2
iteon(dev, flag)
	dev_t dev;
a193 3
	int unit = ITEUNIT(dev);
	struct tty *tp = ite_tty[unit];
	struct ite_softc *ip = &ite_softc[unit];
d195 1
a195 1
	if (unit < 0 || unit >= NITE || (ip->flags&ITE_ALIVE) == 0)
d197 1
d203 1
d210 1
d214 1
d217 1
a217 1
		kbdenable(unit);
d219 2
a220 1
	iteinit(dev);
d224 3
a226 2
iteinit(dev)
     dev_t dev;
a227 2
	int unit = ITEUNIT(dev);
	struct ite_softc *ip = &ite_softc[unit];
d257 3
a259 2
iteoff(dev, flag)
	dev_t dev;
a261 1
	register struct ite_softc *ip = &ite_softc[ITEUNIT(dev)];
d292 4
a295 3
	register struct tty *tp;
	register struct ite_softc *ip = &ite_softc[unit];
	register int error;
d298 2
a299 2
	if (!ite_tty[unit])
		tp = ite_tty[unit] = ttymalloc();
d301 1
a301 1
		tp = ite_tty[unit];
d306 1
a306 1
		error = iteon(dev, 0);
d329 1
a329 1
		iteoff(dev, 0);
d340 3
a342 1
	register struct tty *tp = ite_tty[ITEUNIT(dev)];
d346 1
a346 1
	iteoff(dev, 0);
d349 1
a349 1
	ite_tty[ITEUNIT(dev)] = (struct tty *)0;
d360 2
a361 1
	register struct tty *tp = ite_tty[ITEUNIT(dev)];
d372 2
a373 1
	register struct tty *tp = ite_tty[ITEUNIT(dev)];
d382 1
d384 1
a384 1
	return (ite_tty[ITEUNIT(dev)]);
d395 3
a397 1
	register struct tty *tp = ite_tty[ITEUNIT(dev)];
d415 5
a419 1
	struct ite_softc *ip;
d444 1
a444 1
		iteputchar(getc(&tp->t_outq), tp->t_dev);
a457 1
		ip = &ite_softc[ITEUNIT(tp->t_dev)];
d464 1
a464 1
			iteputchar(getc(&tp->t_outq), tp->t_dev);
d486 1
d488 1
a488 1
	register char stat, c;
d493 1
a493 1
	struct tty *kbd_tty = ite_tty[kbd_ite - ite_softc];
d547 4
a550 3
iteputchar(c, dev)
	register int c;
	dev_t dev;  
d552 2
a553 4
	int unit = ITEUNIT(dev);
	register struct ite_softc *ip = &ite_softc[unit];
	register struct itesw *sp = ip->isw;
	register int n;
d783 1
a783 1
		if (ip->curx < TABEND(unit)) {
d793 1
a793 1
			kbdbell(unit);
d816 1
d818 2
a819 2
     register struct ite_softc *ip;
     register struct itesw *sp;
d835 1
d837 2
a838 2
     register struct ite_softc *ip;
     register struct itesw *sp;
d851 1
d853 2
a854 2
     register struct ite_softc *ip;
     register struct itesw *sp;
d867 1
d869 2
a870 2
     register struct ite_softc *ip;
     register struct itesw *sp;
d881 1
d883 2
a884 2
     register struct ite_softc *ip;
     register struct itesw *sp;
d895 1
d897 3
a899 3
     register struct ite_softc *ip;
     register struct itesw *sp;
     register int y, x;
d906 1
d908 2
a909 2
     register struct ite_softc *ip;
     register struct itesw *sp;
d916 4
a919 7
/*
 * Console functions
 */
#include <dev/cons.h>
#ifdef hp300
#include <hp300/dev/grfreg.h>
#endif
d921 4
a924 15
#ifdef DEBUG
/*
 * Minimum ITE number at which to start looking for a console.
 * Setting to 0 will do normal search, 1 will skip first ITE device,
 * NITE will skip ITEs and use serial port.
 */
int	whichconsole = 0;
#endif

void
itecnprobe(cp)
	struct consdev *cp;
{
	register struct ite_softc *ip;
	int i, sw, maj, unit, pri;
d927 2
a928 6
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == iteopen)
			break;

	/* urk! */
	grfconfig();
d930 1
a930 45
	/* check all the individual displays and find the best */
	unit = -1;
	pri = CN_DEAD;
	for (i = 0; i < NITE; i++) {
		struct grf_softc *gp = &grf_softc[i];

		ip = &ite_softc[i];
		if ((gp->g_flags & GF_ALIVE) == 0)
			continue;
		ip->flags = (ITE_ALIVE|ITE_CONSOLE);

		/* locate the proper switch table. */
		for (sw = 0; sw < nitesw; sw++)
			if (itesw[sw].ite_hwid == gp->g_sw->gd_hwid)
				break;

		if (sw == nitesw)
			continue;
#ifdef DEBUG
		if (i < whichconsole)
			continue;
#endif
		ip->isw = &itesw[sw];
		ip->grf = gp;
#ifdef hp300
		if ((int)gp->g_display.gd_regaddr == GRFIADDR) {
			pri = CN_INTERNAL;
			unit = i;
		} else if (unit < 0) {
			pri = CN_NORMAL;
			unit = i;
		}
#endif
#ifdef hp800
		/* XXX use the first one for now */
		if (unit < 0) {
			pri = CN_INTERNAL;
			unit = i;
		}
#endif
	}

	/* initialize required fields */
	cp->cn_dev = makedev(maj, unit);
	cp->cn_pri = pri;
d933 4
a936 12
void
itecninit(cp)
	struct consdev *cp;
{
	int unit = ITEUNIT(cp->cn_dev);
	struct ite_softc *ip = &ite_softc[unit];

	ip->attrbuf = console_attributes;
	iteinit(cp->cn_dev);
	ip->flags |= (ITE_ACTIVE | ITE_ISCONS);
	kbd_ite = ip;
}
d964 1
d971 1
a971 1
	struct ite_softc *ip = &ite_softc[ITEUNIT(dev)];
d975 1
a975 1
		(void) iteon(dev, 3);
d978 1
a978 1
	iteputchar(c, dev);
@


1.2
log
@from netbsd:
Prevent the ITE_ACTIVE bit from being cleared in iteoff() if the ITE_ISCONS
bit is set.  Works around the fact that the last process to have the
console open exits, the bit is cleared, and "syncing disks...", etc. is
not seen if the system is rebooted with reboot(8).  Fixes PR #1455.
@
text
@d1 1
a1 1
/*	$NetBSD: ite.c,v 1.27.2.1 1995/11/19 23:18:27 thorpej Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ite.c,v 1.27 1995/04/19 19:15:51 mycroft Exp $	*/
d131 1
a131 1
	int unit = UNIT(dev);
d162 1
a162 1
	int unit = UNIT(dev);
d197 1
a197 1
	register struct ite_softc *ip = &ite_softc[UNIT(dev)];
d208 9
a216 1
	if ((flag & 2) == 0)
d227 1
a227 1
	int unit = UNIT(dev);
d275 1
a275 1
	register struct tty *tp = ite_tty[UNIT(dev)];
d282 1
a282 1
	ite_tty[UNIT(dev)] = (struct tty *)0;
d293 1
a293 1
	register struct tty *tp = ite_tty[UNIT(dev)];
d304 1
a304 1
	register struct tty *tp = ite_tty[UNIT(dev)];
d314 1
a314 1
	return (ite_tty[UNIT(dev)]);
d325 1
a325 1
	register struct tty *tp = ite_tty[UNIT(dev)];
d382 1
a382 1
		ip = &ite_softc[UNIT(tp->t_dev)];
d475 1
a475 1
	int unit = UNIT(dev);
d917 1
a917 1
	int unit = UNIT(cp->cn_dev);
d922 1
a922 1
	ip->flags |= (ITE_ACTIVE|ITE_ISCONS);
d958 1
a958 1
	struct ite_softc *ip = &ite_softc[UNIT(dev)];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

