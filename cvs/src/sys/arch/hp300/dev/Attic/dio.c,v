head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.12
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.22
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.20
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.18
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.17
date	2014.03.18.22.36.31;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2011.08.18.20.02.57;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.08.18.19.52.08;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.15.20.38.09;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.15.23.37.45;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.15.22.02.00;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.26.21.41.32;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.10.21.11.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.06.44.49;	author millert;	state Exp;
branches
	1.6.12.1
	1.6.22.1;
next	1.5;

1.5
date	97.07.06.08.01.48;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.04.16.11.55.59;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.02.03.04.47.17;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.01.13.18.03.53;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.01.12.15.12.25;	author downsj;	state Exp;
branches;
next	;

1.6.12.1
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	;

1.6.22.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	1.6.22.2;

1.6.22.2
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: dio.c,v 1.16 2011/08/18 20:02:57 miod Exp $	*/
/*	$NetBSD: dio.c,v 1.7 1997/05/05 21:00:32 thorpej Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Autoconfiguration and mapping support for the DIO bus.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/hp300spu.h>

#include <hp300/dev/dmavar.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>

#include <hp300/dev/diodevs.h>
#include <hp300/dev/diodevs_data.h>

extern	caddr_t internalhpib;

int	dio_scodesize(struct dio_attach_args *);
char	*dio_devinfo(struct dio_attach_args *, char *, size_t);

int	diomatch(struct device *, void *, void *);
void	dioattach(struct device *, struct device *, void *);
int	dioprint(void *, const char *);
int	diosubmatch(struct device *, void *, void *);

struct cfattach dio_ca = {
	sizeof(struct device), diomatch, dioattach
};

struct cfdriver dio_cd = {
	NULL, "dio", DV_DULL
};

int
diomatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	static int dio_matched = 0;

	/* Allow only one instance. */
	if (dio_matched)
		return (0);

	dio_matched = 1;
	return (1);
}

void
dioattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct dio_attach_args da;
	caddr_t pa, va;
	int scode, sctmp, scmax, didmap, scodesize;

	scmax = DIO_SCMAX(machineid);
	printf(": ");
	dmainit();

	for (scode = 0; scode < scmax; ) {
		if ((sctmp = dio_inhole(scode)) != 0) {
			scode = sctmp;
			continue;
		}

		didmap = 0;

		/*
		 * Temporarily map the space corresponding to
		 * the current select code unless:
		 *	- this is the internal hpib select code,
		 *	- this is the console select code, and
		 *	  the console driver actually has a mapping
		 *	  of the beginning of the select code space
		 *	  (sti@@dio doesn't).
		 */
		pa = dio_scodetopa(scode);
		if (scode == conscode && conaddr != 0)
			va = conaddr;
		else if ((scode == 7) && internalhpib)
			va = internalhpib = (caddr_t)IIOV(pa);
		else {
			va = iomap(pa, NBPG);
			if (va == NULL) {
				printf("%s: can't map scode %d\n",
				    self->dv_xname, scode);
				scode++;
				continue;
			}
			didmap = 1;
		}

		/* Check for hardware. */
		if (badaddr(va)) {
			if (didmap)
				iounmap(va, NBPG);
			scode++;
			continue;
		}

		/* Fill out attach args. */
		bzero(&da, sizeof(da));
		da.da_scode = scode;
		if (scode == 7 && internalhpib)
			da.da_id = DIO_DEVICE_ID_IHPIB;
		else {
			da.da_id = DIO_ID(va);
			/*
			 * If we probe an unknown device, we do not necessarily
			 * know how many scodes it will span.
			 * Extra scodes will usually report an id of zero,
			 * which would match ihpib!
			 * Check for this, warn the user, and skip that scode.
			 */
			if (da.da_id == 0) {
				if (didmap)
					iounmap(va, NBPG);
				printf("%s: warning: select code %d is likely "
				    "a span of a previous unsupported device\n",
				    self->dv_xname, scode);
				scode++;
				continue;
			}
		}

		if (DIO_ISFRAMEBUFFER(da.da_id))
			da.da_secid = DIO_SECID(va);

		da.da_size = DIO_SIZE(scode, va);
		scodesize = dio_scodesize(&da);
		if (DIO_ISDIO(scode))
			da.da_size *= scodesize;

		/* No longer need the device to be mapped. */
		if (didmap)
			iounmap(va, NBPG);

		/* Attach matching device. */
		config_found_sm(self, &da, dioprint, diosubmatch);
		scode += scodesize;
	}
}

int
diosubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct dio_attach_args *da = aux;

	if (cf->diocf_scode != DIO_UNKNOWN_SCODE &&
	    cf->diocf_scode != da->da_scode)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

int
dioprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct dio_attach_args *da = aux;
	char buf[128];

	if (pnp)
		printf("%s at %s", dio_devinfo(da, buf, sizeof(buf)), pnp);
	printf(" scode %d", da->da_scode);
	return (UNCONF);
}

/*
 * Convert a select code to a system physical address.
 */
void *
dio_scodetopa(scode)
	int scode;
{
	u_long rval;

	if (scode == 7 && internalhpib)
		rval = DIO_IHPIBADDR;
	else if (DIO_ISDIO(scode))
		rval = DIO_BASE + (scode * DIO_DEVSIZE);
	else if (DIO_ISDIOII(scode))
		rval = DIOII_BASE + ((scode - DIOII_SCBASE) * DIOII_DEVSIZE);
	else
		rval = 0;

	return ((void *)rval);
}

/*
 * Return the select code size for this device, defaulting to 1
 * if we don't know what kind of device we have.
 */
int
dio_scodesize(da)
	struct dio_attach_args *da;
{
	int i;

	/*
	 * Deal with lame internal HP-IB controllers which don't have
	 * consistent/reliable device ids.
	 */
	if (da->da_scode == 7 && internalhpib)
		return (1);

	/*
	 * Find the dio_devdata matching the primary id.
	 * If we're a framebuffer, we also check the secondary id.
	 */
	for (i = 0; i < DIO_NDEVICES; i++) {
		if (da->da_id == dio_devdatas[i].dd_id) {
			if (DIO_ISFRAMEBUFFER(da->da_id)) {
				if (da->da_secid == dio_devdatas[i].dd_secid) {
					goto foundit;
				}
			} else {
			foundit:
				return (dio_devdatas[i].dd_nscode);
			}
		}
	}

	/*
	 * Device is unknown.  Print a warning and assume a default.
	 */
	printf("WARNING: select code size unknown for id = 0x%x secid = 0x%x\n",
	    da->da_id, da->da_secid);
	return (1);
}

/*
 * Return a reasonable description of a DIO device.
 */
char *
dio_devinfo(da, buf, buflen)
	struct dio_attach_args *da;
	char *buf;
	size_t buflen;
{
#ifdef DIOVERBOSE
	int i;
#endif

	bzero(buf, buflen);

	/*
	 * Deal with lame internal HP-IB controllers which don't have
	 * consistent/reliable device ids.
	 */
	if (da->da_scode == 7 && internalhpib) {
		snprintf(buf, buflen, DIO_DEVICE_DESC_IHPIB);
		return (buf);
	}

#ifdef DIOVERBOSE
	/*
	 * Find the description matching our primary id.
	 * If we're a framebuffer, we also check the secondary id.
	 */
	for (i = 0; i < DIO_NDEVICES; i++) {
		if (da->da_id == dio_devdescs[i].dd_id) {
			if (DIO_ISFRAMEBUFFER(da->da_id)) {
				if (da->da_secid == dio_devdescs[i].dd_secid) {
					goto foundit;
				}
			} else {
			foundit:
				snprintf(buf, buflen, "%s",
				    dio_devdescs[i].dd_desc);
				return (buf);
			}
		}
	}
#endif /* DIOVERBOSE */

	/*
	 * Device is unknown.  Construct something reasonable.
	 */
	snprintf(buf, buflen, "device id = 0x%x secid = 0x%x",
	    da->da_id, da->da_secid);
	return (buf);
}

/*
 * Establish an interrupt handler for a DIO device.
 */
void
dio_intr_establish(struct isr *isr, const char *name)
{
	intr_establish(isr, name);

	if (isr->isr_priority == IPL_BIO)
		dmacomputeipl();
}

/*
 * Remove an interrupt handler for a DIO device.
 */
void
dio_intr_disestablish(struct isr *isr)
{
	intr_disestablish(isr);

	if (isr->isr_priority == IPL_BIO)
		dmacomputeipl();
}

/*
 * Return the next select code if the given select code lies within a hole,
 * zero otherwise.
 */
int
dio_inhole(int scode)
{
	/* unconditionnaly skip the DIO-II hole */
	if (scode >= 32 && scode < DIOII_SCBASE)
		return DIOII_SCBASE;

	return 0;
}
@


1.16
log
@So, it turns out that models 362 and 382 built-in frame buffer only shows up
in DIO-II space, as a fat device spanning four select codes (i.e. 16MB of
memory). This is way too much for an at-most 2 Mpixel 8bit frame buffer, and
it turns out that this is because the device provides both a regular DIO-II
frame buffer (spanning two select codes) and a regular STI frame buffer
(spanning the other two select codes).
This commit introduces a straightforward sti@@dio attachment to get a working
sti(4) and wsdisplay(4) in a ridiculously small number of lines; however
the console code needs some changes to avoid duplicating globals.

While there, add sti@@dio support for the bootblocks, and I couldn't help
myself but clean the most rotten parts of them, and try to have them reuse
various files in sys/arch/hp300/dev instead of rolling their outdated ones.

Tested on a real 382 with the low-resolution frame buffer:
sti0 at dio0 scode 132: rev 8.02;129, ID 0x27134CB440A00499
sti0: 382V, 2048x512 frame buffer, 640x480x8 display
sti0: 8x16 font type 1, 16 bpc, charset 0-255
wsdisplay0 at sti0 mux 1: console (std, vt100 emulation)

Boot blocks updates tested on DIO-II 425t (serial/glass console), SGC 425e
(serial/glass console) and 382 (serial/glass console). And will be tested
on SGC 425t soon as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.15 2011/08/18 19:52:08 miod Exp $	*/
@


1.15
log
@Do not skip 362 and 382 DIO frame buffer select codes; this was written
back when I thought that these devices were showing both in DIO-II and SGC
spaces; but, as researched by tsutsui@@netbsd, there is nothing in the SGC
bus address space (assuming there is SGC bus logic at all) on 3x2.
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.14 2010/04/15 20:38:09 miod Exp $	*/
d113 4
a116 1
		 *	- this is the console select code.
d119 1
a119 1
		if (scode == conscode)
@


1.14
log
@Turn DIO_INHOLE() into a function, returning the next select code to probe at;
and skip function codes 132 to 135, inclusive, on models 362 and 382 - this
is a fake DIO device probably intended to let non-SGC aware (i.e. legacy)
HP-UX lowlevel code be able to ``detect'' a frame buffer.

This change (as well as letting sgc attach) is untested due to the lack of any
3x2 hardware, but shouldn't make things worse.
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.13 2008/06/26 05:42:10 ray Exp $	*/
a360 10

	/* skip the frame buffer memory on 3x2 systems */
	switch (machineid) {
	case HP_362:
	case HP_382:
		if (scode >= DIOII_SCBASE && scode < DIOII_SCBASE + 4)
			return DIOII_SCBASE + 4;
	default:
		break;
	}
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.12 2005/01/15 23:37:45 miod Exp $	*/
d95 1
a95 1
	int scode, scmax, didmap, scodesize;
d102 2
a103 2
		if (DIO_INHOLE(scode)) {
			scode++;
d349 24
@


1.12
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.11 2005/01/15 22:02:00 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@A better diagnostic when we encounter extra scodes used by an unsupported
devices for which diodevs has the wrong span value.

Before this, we would get:
tiger display at dio0 scode 157 not configured
internal HP-IB at dio0 scode 158 not configured
internal HP-IB at dio0 scode 159 not configured

Now, we will get:
tiger display at dio0 scode 157 not configured
dio0: warning: select code 158 is likely a span of a previous unsupported device
dio0: warning: select code 159 is likely a span of a previous unsupported device
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.10 2004/12/26 21:41:32 miod Exp $	*/
d257 1
a257 1
	 * Find the dio_devdata matchind the primary id.
@


1.10
log
@_HP300_INTR_H_PRIVATE is long dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.9 2004/09/29 07:35:52 miod Exp $	*/
d151 1
a151 1
		else
d153 17
@


1.9
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.8 2003/05/10 21:11:12 deraadt Exp $	*/
a42 2

#define	_HP300_INTR_H_PRIVATE
@


1.8
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.7 2002/03/14 01:26:30 millert Exp $	*/
d322 2
a323 6
void *
dio_intr_establish(func, arg, ipl, priority)
	int (*func)(void *);
	void *arg;
	int ipl;
	int priority;
d325 1
a325 3
	void *ih;

	ih = intr_establish(func, arg, ipl, priority);
d327 1
a327 1
	if (priority == IPL_BIO)
a328 2

	return (ih);
d335 1
a335 2
dio_intr_disestablish(arg)
	void *arg;
d337 1
a337 4
	struct isr *isr = arg;
	int priority = isr->isr_priority;

	intr_disestablish(arg);
d339 1
a339 1
	if (priority == IPL_BIO)
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.6 1997/10/06 06:44:49 millert Exp $	*/
d286 1
a286 1
		sprintf(buf, DIO_DEVICE_DESC_IHPIB);
d303 2
a304 1
				sprintf(buf, "%s", dio_devdescs[i].dd_desc);
d314 1
a314 1
	sprintf(buf, "device id = 0x%x secid = 0x%x",
@


1.6
log
@Set da_id to DIO_DEVICE_ID_IHPIB if this is an internal hpib controller.
Prevents nhpib0 from getting probed as dca1 on an hp400.
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.5 1997/07/06 08:01:48 downsj Exp $	*/
d66 2
a67 2
int	dio_scodesize __P((struct dio_attach_args *));
char	*dio_devinfo __P((struct dio_attach_args *, char *, size_t));
d69 4
a72 4
int	diomatch __P((struct device *, void *, void *));
void	dioattach __P((struct device *, struct device *, void *));
int	dioprint __P((void *, const char *));
int	diosubmatch __P((struct device *, void *, void *));
d323 1
a323 1
	int (*func) __P((void *));
@


1.6.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.6 1997/10/06 06:44:49 millert Exp $	*/
d66 2
a67 2
int	dio_scodesize(struct dio_attach_args *);
char	*dio_devinfo(struct dio_attach_args *, char *, size_t);
d69 4
a72 4
int	diomatch(struct device *, void *, void *);
void	dioattach(struct device *, struct device *, void *);
int	dioprint(void *, const char *);
int	diosubmatch(struct device *, void *, void *);
d323 1
a323 1
	int (*func)(void *);
@


1.6.22.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d286 1
a286 1
		snprintf(buf, buflen, DIO_DEVICE_DESC_IHPIB);
d303 1
a303 2
				snprintf(buf, buflen, "%s",
				    dio_devdescs[i].dd_desc);
d313 1
a313 1
	snprintf(buf, buflen, "device id = 0x%x secid = 0x%x",
@


1.6.12.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
a67 2
int	dio_scodesize(struct dio_attach_args *);
char	*dio_devinfo(struct dio_attach_args *, char *, size_t);
d69 4
a72 4
int	diomatch(struct device *, void *, void *);
void	dioattach(struct device *, struct device *, void *);
int	dioprint(void *, const char *);
int	diosubmatch(struct device *, void *, void *);
d323 1
a323 1
	int (*func)(void *);
@


1.6.12.2
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.6.12.1 2002/03/28 10:07:18 niklas Exp $	*/
d286 1
a286 1
		snprintf(buf, buflen, DIO_DEVICE_DESC_IHPIB);
d303 1
a303 2
				snprintf(buf, buflen, "%s",
				    dio_devdescs[i].dd_desc);
d313 1
a313 1
	snprintf(buf, buflen, "device id = 0x%x secid = 0x%x",
@


1.5
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: dio.c,v 1.4 1997/04/16 11:55:59 downsj Exp $	*/
d151 4
a154 1
		da.da_id = DIO_ID(va);
@


1.4
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: dio.c,v 1.3 1997/02/03 04:47:17 downsj Exp $	*/
/*	$NetBSD: dio.c,v 1.5 1997/04/04 09:53:43 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
d44 2
d54 3
d107 2
a108 1
	printf("\n");
d313 36
@


1.3
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: dio.c,v 1.2 1997/01/13 18:03:53 downsj Exp $	*/
/*	$NetBSD: dio.c,v 1.3 1997/01/30 09:18:37 thorpej Exp $	*/
d126 2
a127 1
				printf("%s: can't map scode %d\n", scode);
d266 1
d268 1
@


1.2
log
@fix DIO-II mappings, NetBSD PR#3097.
@
text
@d1 2
a2 2
/*	$OpenBSD: dio.c,v 1.1 1997/01/12 15:12:25 downsj Exp $	*/
/*	$NetBSD: dio.c,v 1.1 1996/12/17 08:41:02 thorpej Exp $	*/
d64 1
a64 2
#ifdef NEWCONFIG
int	diomatch __P((struct device *, struct cfdata *, void *));
d67 1
a67 1
int	diosubmatch __P((struct device *, struct cfdata *, void *));
d80 1
a80 2
	struct cfdata *match;
	void *aux;
d165 1
a165 1
diosubmatch(parent, cf, aux)
d167 1
a167 2
	struct cfdata *cf;
	void *aux;
d169 1
a191 1
#endif /* NEWCONFIG */
d207 1
a207 1
		rval = DIOII_BASE + ((scode - 132) * DIOII_DEVSIZE);
@


1.1
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d210 1
a210 1
		rval = DIOII_BASE + (scode * DIOII_DEVSIZE);
@
