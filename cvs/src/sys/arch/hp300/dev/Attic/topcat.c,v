head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.15.0.30
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.28
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.26
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.24
	OPENBSD_5_0:1.15.0.22
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.20
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.18
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9;
locks; strict;
comment	@ * @;


1.19
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.18;

1.18
date	2013.10.21.10.36.13;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.20.20.07.23;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2013.09.28.21.10.58;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.11.18.33.13;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.31.18.13.41;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.30.18.14.09;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.30.18.03.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.30.18.00.21;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.28.21.19.27;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.24.21.36.39;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.21.16.24.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.21.16.22.34;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.19.10.51.24;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.18.21.53.23;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.18.19.17.03;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.16.16.14.10;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.15.21.08.37;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.22.39.26;	author miod;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: topcat.c,v 1.18 2013/10/21 10:36:13 miod Exp $	*/

/*
 * Copyright (c) 2005, Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: grf_tc.c 1.20 93/08/13$
 *
 *	@@(#)grf_tc.c	8.4 (Berkeley) 1/12/94
 */

/*
 * Graphics routines for TOPCAT, CATSEYE and KATHMANDU frame buffers
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/ioctl.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>

#include <hp300/dev/dioreg.h>
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>
#include <hp300/dev/intiovar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <hp300/dev/diofbreg.h>
#include <hp300/dev/diofbvar.h>
#include <hp300/dev/topcatreg.h>

struct	topcat_softc {
	struct device	sc_dev;
	struct diofb	*sc_fb;
	struct diofb	sc_fb_store;
	int		sc_scode;
};

int	topcat_dio_match(struct device *, void *, void *);
void	topcat_dio_attach(struct device *, struct device *, void *);
int	topcat_intio_match(struct device *, void *, void *);
void	topcat_intio_attach(struct device *, struct device *, void *);

struct cfattach topcat_dio_ca = {
	sizeof(struct topcat_softc), topcat_dio_match, topcat_dio_attach
};

struct cfattach topcat_intio_ca = {
	sizeof(struct topcat_softc), topcat_intio_match, topcat_intio_attach
};

struct cfdriver topcat_cd = {
	NULL, "topcat", DV_DULL
};

void	topcat_end_attach(struct topcat_softc *, u_int8_t);
int	topcat_reset(struct diofb *, int, struct diofbreg *);
void	topcat_restore(struct diofb *);
int	topcat_setcmap(struct diofb *, struct wsdisplay_cmap *);
void	topcat_setcolor(struct diofb *, u_int);
int	topcat_windowmove(struct diofb *, u_int16_t, u_int16_t, u_int16_t,
	    u_int16_t, u_int16_t, u_int16_t, int16_t, int16_t);

int	topcat_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	topcat_burner(void *, u_int, u_int);

struct	wsdisplay_accessops	topcat_accessops = {
	.ioctl = topcat_ioctl,
	.mmap = diofb_mmap,
	.alloc_screen = diofb_alloc_screen,
	.free_screen = diofb_free_screen,
	.show_screen = diofb_show_screen,
	.load_font = diofb_load_font,
	.list_font = diofb_list_font,
	.burn_screen = topcat_burner
};

/*
 * Attachment glue
 */

int
topcat_intio_match(struct device *parent, void *match, void *aux)
{
	struct intio_attach_args *ia = aux;
	struct diofbreg *fbr;

	fbr = (struct diofbreg *)IIOV(GRFIADDR);

	if (badaddr((caddr_t)fbr))
		return (0);

	if (fbr->id == GRFHWID) {
		switch (fbr->fbid) {
		case GID_TOPCAT:
		case GID_LRCATSEYE:
		case GID_HRCCATSEYE:
		case GID_HRMCATSEYE:
#if 0
		case GID_XXXCATSEYE:
#endif
			ia->ia_addr = (caddr_t)GRFIADDR;
			return (1);
		}
	}

	return (0);
}

void
topcat_intio_attach(struct device *parent, struct device *self, void *aux)
{
	struct topcat_softc *sc = (struct topcat_softc *)self;
	struct diofbreg *fbr;

	fbr = (struct diofbreg *)IIOV(GRFIADDR);
	sc->sc_scode = CONSCODE_INTERNAL;

	if (sc->sc_scode == conscode) {
		sc->sc_fb = &diofb_cn;
	} else {
		sc->sc_fb = &sc->sc_fb_store;
		topcat_reset(sc->sc_fb, sc->sc_scode, fbr);
	}

	topcat_end_attach(sc, fbr->fbid);
}

int
topcat_dio_match(struct device *parent, void *match, void *aux)
{
	struct dio_attach_args *da = aux;

	if (da->da_id == DIO_DEVICE_ID_FRAMEBUFFER) {
		switch (da->da_secid) {
		case DIO_DEVICE_SECID_TOPCAT:
		case DIO_DEVICE_SECID_LRCATSEYE:
		case DIO_DEVICE_SECID_HRCCATSEYE:
		case DIO_DEVICE_SECID_HRMCATSEYE:
#if 0
		case DIO_DEVICE_SECID_XXXCATSEYE:
#endif
			return (1);
		}
	}

	return (0);
}

void
topcat_dio_attach(struct device *parent, struct device *self, void *aux)
{
	struct topcat_softc *sc = (struct topcat_softc *)self;
	struct dio_attach_args *da = aux;
	struct diofbreg *fbr;

	sc->sc_scode = da->da_scode;
	if (sc->sc_scode == conscode) {
		fbr = (struct diofbreg *)conaddr;	/* already mapped */
		sc->sc_fb = &diofb_cn;
	} else {
		sc->sc_fb = &sc->sc_fb_store;
		fbr = (struct diofbreg *)
		    iomap(dio_scodetopa(sc->sc_scode), da->da_size);
		if (fbr == NULL ||
		    topcat_reset(sc->sc_fb, sc->sc_scode, fbr) != 0) {
			printf(": can't map framebuffer\n");
			return;
		}
	}

	topcat_end_attach(sc, fbr->fbid);
}

void
topcat_end_attach(struct topcat_softc *sc, u_int8_t id)
{
	const char *fbname = "unknown";

	switch (id) {
	case GID_TOPCAT:
		switch (sc->sc_fb->planes) {
		case 1:
			if (sc->sc_fb->dheight == 400)
				fbname = "HP98542 topcat";
			else
				fbname = "HP98544 topcat";
			break;
		case 4:
			if (sc->sc_fb->dheight == 400)
				fbname = "HP98543 topcat";
			else
				fbname = "HP98545 topcat";
			break;
		case 6:
			fbname = "HP98547 topcat";
			break;
		}
		break;
	case GID_HRCCATSEYE:
		fbname = "HP98550 catseye";	/* also A1416 kathmandu */
		break;
	case GID_LRCATSEYE:
		fbname = "HP98549 catseye";
		break;
	case GID_HRMCATSEYE:
		fbname = "HP98548 catseye";
		break;
	}

	diofb_end_attach(sc, &topcat_accessops, sc->sc_fb,
	    sc->sc_scode == conscode, fbname);
}

/*
 * Initialize hardware and display routines.
 */
int
topcat_reset(struct diofb *fb, int scode, struct diofbreg *fbr)
{
	volatile struct tcboxfb *tc = (struct tcboxfb *)fbr;
	int rc;
	u_int i;

	if ((rc = diofb_fbinquire(fb, scode, fbr)) != 0)
		return (rc);

	/*
	 * If we could not get a valid number of planes, determine it
	 * by writing to the first frame buffer display location,
	 * then reading it back.
	 */
	if (fb->planes == 0) {
		volatile u_int8_t *fbp;
		u_int8_t save;

		fbp = (u_int8_t *)fb->fbkva;
		tc->fben = ~0;
		tc->wen = ~0;
		tc->ren = ~0;
		tc->prr = RR_COPY;
		save = *fbp;
		*fbp = 0xff;
		fb->planemask = *fbp;
		*fbp = save;

		for (fb->planes = 1; fb->planemask >= (1 << fb->planes);
		    fb->planes++);
		if (fb->planes > 8)
			fb->planes = 8;
		fb->planemask = (1 << fb->planes) - 1;
	}

	fb->bmv = topcat_windowmove;
	topcat_restore(fb);
	diofb_fbsetup(fb);
	for (i = 0; i <= fb->planemask; i++)
		topcat_setcolor(fb, i);

	return (0);
}

void
topcat_restore(struct diofb *fb)
{
	volatile struct tcboxfb *tc = (struct tcboxfb *)fb->regkva;

	/*
	 * Catseye looks a lot like a topcat, but not completely.
	 * So, we set some bits to make it work.
	 */
	if (tc->regs.fbid != GID_TOPCAT) {
		while ((tc->catseye_status & 1))
			;
		tc->catseye_status = 0x0;
		tc->vb_select = 0x0;
		tc->tcntrl = 0x0;
		tc->acntrl = 0x0;
		tc->pncntrl = 0x0;
		tc->rug_cmdstat = 0x90;
	}

	/*
	 * Enable reading/writing of all the planes.
	 */
	tc->fben = fb->planemask;
	tc->wen  = fb->planemask;
	tc->ren  = fb->planemask;
	tc->prr  = RR_COPY;

	/* Enable display */
	tc->nblank = 0xff;
}

int
topcat_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct diofb *fb = v;
	struct wsdisplay_fbinfo *wdf;
	u_int i;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_TOPCAT;
		break;
	case WSDISPLAYIO_SMODE:
		fb->mapmode = *(u_int *)data;
		if (fb->mapmode == WSDISPLAYIO_MODE_EMUL) {
			topcat_restore(fb);
			for (i = 0; i <= fb->planemask; i++)
				topcat_setcolor(fb, i);
		}
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (void *)data;
		wdf->width = fb->ri.ri_width;
		wdf->height = fb->ri.ri_height;
		wdf->depth = fb->ri.ri_depth;
		wdf->cmsize = 1 << fb->planes;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = fb->ri.ri_stride;
		break;
	case WSDISPLAYIO_GETCMAP:
		return (diofb_getcmap(fb, (struct wsdisplay_cmap *)data));
	case WSDISPLAYIO_PUTCMAP:
		return (topcat_setcmap(fb, (struct wsdisplay_cmap *)data));
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		break;
	default:
		return (-1);
	}

	return (0);
}

void
topcat_burner(void *v, u_int on, u_int flags)
{
	struct diofb *fb = v;
	volatile struct tcboxfb *tc = (struct tcboxfb *)fb->regkva;

	if (on) {
		tc->nblank = 0xff;
	} else {
		tc->nblank = 0;
	}
}

void
topcat_setcolor(struct diofb *fb, u_int index)
{
	volatile struct tcboxfb *tc = (struct tcboxfb *)fb->regkva;

	/* Monochrome topcat may not have the colormap logic present */
	if (fb->planes <= 1)
		return;

	if (tc->regs.fbid != GID_TOPCAT) {
		tccm_waitbusy(tc);
		tc->plane_mask = 0xff;
		tc->cindex = ~index;
		tc->rdata  = fb->cmap.r[index];
		tc->gdata  = fb->cmap.g[index];
		tc->bdata  = fb->cmap.b[index];
		tc->strobe = 0xff;

		tccm_waitbusy(tc);
		tc->cindex = 0;
	} else {
		tccm_waitbusy(tc);
		tc->plane_mask = 0xff;
		tc->rdata  = fb->cmap.r[index];
		tc->gdata  = fb->cmap.g[index];
		tc->bdata  = fb->cmap.b[index];
		tc->cindex = ~index;
		tc->strobe = 0xff;

		tccm_waitbusy(tc);
		tc->rdata  = 0;
		tc->gdata  = 0;
		tc->bdata  = 0;
		tc->cindex = 0;
	}
}

int
topcat_setcmap(struct diofb *fb, struct wsdisplay_cmap *cm)
{
	u_int8_t r[256], g[256], b[256];
	u_int index = cm->index, count = cm->count;
	u_int colcount = 1 << fb->planes;
	int error;

	if (index >= colcount || count > colcount - index)
		return (EINVAL);

	if ((error = copyin(cm->red, r, count)) != 0)
		return (error);
	if ((error = copyin(cm->green, g, count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, b, count)) != 0)
		return (error);

	bcopy(r, fb->cmap.r + index, count);
	bcopy(g, fb->cmap.g + index, count);
	bcopy(b, fb->cmap.b + index, count);

	while (count-- != 0)
		topcat_setcolor(fb, index++);

	return (0);
}

/*
 * Accelerated routines
 */

int
topcat_windowmove(struct diofb *fb, u_int16_t sx, u_int16_t sy,
    u_int16_t dx, u_int16_t dy, u_int16_t cx, u_int16_t cy, int16_t rop,
    int16_t planemask)
{
	volatile struct tcboxfb *tc = (struct tcboxfb *)fb->regkva;

	tc_waitbusy(tc, fb->planemask);

	tc->wen = planemask;
	tc->wmrr = rop;
	if (planemask != 0xff) {
		tc->wen = planemask ^ 0xff;
		tc->wmrr = rop ^ 0x0f;
		tc->wen = fb->planemask;
	}
	tc->source_y = sy;
	tc->source_x = sx;
	tc->dest_y = dy;
	tc->dest_x = dx;
	tc->wheight = cy;
	tc->wwidth = cx;
	tc->wmove = fb->planemask;

	tc_waitbusy(tc, fb->planemask);

	return (0);
}

/*
 * Topcat/catseye console support
 */

void
topcatcninit()
{
	topcat_reset(&diofb_cn, conscode, (struct diofbreg *)conaddr);
	diofb_cnattach(&diofb_cn);
}
@


1.18
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.17 2013/10/20 20:07:23 miod Exp $	*/
@


1.17
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.16 2013/09/28 21:10:58 miod Exp $	*/
d137 2
@


1.16
log
@Model 332 has a monochrome 98542 on-board, instead of the expected 98544;
that particular model lacks the colormap chips (likely due to physical space
constraints) and lies about its visible geometry, in pure old HP frame buffer
style (before HP engineers realized the usefulness of providing correct data
to the operating system).

Work done by Andrew Gillham (last name on gmail), with unsignificant tweaks
by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.15 2006/08/11 18:33:13 miod Exp $	*/
d132 6
a137 9
	topcat_ioctl,
	diofb_mmap,
	diofb_alloc_screen,
	diofb_free_screen,
	diofb_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	topcat_burner
@


1.15
log
@Let the windowmove() callbacks return whether they could perform the operation
or not, so that we can always feed them the complex operations before falling
back to rasops; and then topcat can perform coloured solid fills in
erase{cols,rows}.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.14 2005/12/31 18:13:41 miod Exp $	*/
d249 4
a252 1
			fbname = "HP98544 topcat";
d420 4
@


1.14
log
@Rework (once again) the console code, in order to match the PROM's logic better.
When not running on serial console, the PROM will pick the ``internal''
graphics device, and if it does not exist, the DIO device with the lowest
select code, and will resort to SGC devices if no internal or DIO device
was found.

However, the current logic would search for a certain frame buffer type first,
then for its best hardware location, following the order they are listed
in conf.c.

By replacing gazillions of almost-exactly-duplicated frame buffer code with
one single instance, which is device type-agnostic, we can match the PROM
(and the bootblocks) logic again. Plus this saves a few KB of code!
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.13 2005/12/30 18:14:09 miod Exp $	*/
d125 2
a126 2
void	topcat_windowmove(struct diofb *, u_int16_t, u_int16_t,
	    u_int16_t, u_int16_t, u_int16_t, u_int16_t, int);
d478 1
a478 1
void
d480 2
a481 1
    u_int16_t dx, u_int16_t dy, u_int16_t cx, u_int16_t cy, int rop)
d487 1
d489 5
d503 2
@


1.13
log
@Kill conforced, and have console devices use CN_FORCED priority instead.
This means we are no longer aborting the console scans even if the final
console has been found, but on the other hand makes some logic simpler;
plus it will be necessary for upcoming scode vs device loop order reversal.
No user-visible change.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.12 2005/12/30 18:03:33 miod Exp $	*/
a87 2
#include <dev/cons.h>

a501 105
int topcat_console_scan(int, caddr_t, void *);
cons_decl(topcat);

int
topcat_console_scan(int scode, caddr_t va, void *arg)
{
	struct diofbreg *fbr = (struct diofbreg *)va;
	struct consdev *cp = arg;
	u_int pri;

	if (fbr->id != GRFHWID)
		return (0);

	switch (fbr->fbid) {
	case GID_TOPCAT:
	case GID_LRCATSEYE:
	case GID_HRCCATSEYE:
	case GID_HRMCATSEYE:
		break;

	default:
		return (0);
	}

	pri = CN_NORMAL;

#ifdef CONSCODE
	/*
	 * Raise our priority, if appropriate.
	 */
	if (scode == CONSCODE)
		pri = CN_FORCED;
#endif

	/* Only raise priority. */
	if (pri > cp->cn_pri)
		cp->cn_pri = pri;

	/*
	 * If our priority is higher than the currently-remembered
	 * console, stash our priority.
	 */
	if (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri) {
		cn_tab = cp;
		conscode = scode;
		return (DIO_SIZE(scode, va));
	}
	return (0);
}

void
topcatcnprobe(struct consdev *cp)
{
	int maj;
	caddr_t va;
	struct diofbreg *fbr;

	for (maj = 0; maj < nchrdev; maj++) {
		if (cdevsw[maj].d_open == wsdisplayopen)
			break;
	}

	if (maj == nchrdev)
		return;

	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_DEAD;

	/* Look for "internal" framebuffer. */
	va = (caddr_t)IIOV(GRFIADDR);
	fbr = (struct diofbreg *)va;
	if (!badaddr(va) && (fbr->id == GRFHWID)) {
		switch (fbr->fbid) {
		case GID_TOPCAT:
		case GID_LRCATSEYE:
		case GID_HRCCATSEYE:
		case GID_HRMCATSEYE:
			cp->cn_pri = CN_INTERNAL;

#ifdef CONSCODE
			if (CONSCODE == CONSCODE_INTERNAL)
				cp->cn_pri = CN_FORCED;
#endif

			/*
			 * If our priority is higher than the currently
			 * remembered console, stash our priority, and unmap
			 * whichever device might be currently mapped.
			 * Since we're internal, we set the saved size to 0
			 * so they don't attempt to unmap our fixed VA later.
			 */
			if (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri) {
				cn_tab = cp;
				if (convasize)
					iounmap(conaddr, convasize);
				conscode = CONSCODE_INTERNAL;
				conaddr = va;
				convasize = 0;
			}
		}
	}

	console_scan(topcat_console_scan, cp, HP300_BUS_DIO);
}

d503 1
a503 1
topcatcninit(struct consdev *cp)
@


1.12
log
@When a driver claims console, let it set conscode to itself, instead of
letting the bus walkers do this for it. This is necessary since apci does
not use the bus walkers, now that we do not force console probes to stop
when apci claims console.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.11 2005/12/30 18:00:21 miod Exp $	*/
d512 1
a512 1
	int force = 0, pri;
d534 2
a535 4
	if (scode == CONSCODE) {
		pri = CN_REMOTE;
		force = conforced = 1;
	}
d546 1
a546 1
	if (((cn_tab == NULL) || (cp->cn_pri > cn_tab->cn_pri)) || force) {
a559 5
	int force = 0;

	/* Abort early if the console is already forced. */
	if (conforced)
		return;
d584 2
a585 3
			if (CONSCODE == CONSCODE_INTERNAL) {
				force = conforced = 1;
			}
d595 1
a595 2
			if (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri ||
			    force) {
@


1.11
log
@Introduce symbolic constants for the magic conscode values.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.10 2005/12/28 21:19:27 miod Exp $	*/
d550 1
@


1.10
log
@hyper, rbox and topcat not in intio space are CN_NORMAL priority, not
CN_INTERNAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.9 2005/01/24 21:36:39 miod Exp $	*/
d184 1
a184 1
	sc->sc_scode = -1;	/* XXX internal i/o */
d590 1
a590 1
			if (CONSCODE == -1) {
d607 1
a607 1
				conscode = -1;
@


1.9
log
@Switch hp300 wscons code to rasops, for DIO frame buffers.
Features:
- coloured kernel messages
- color support in console (use TERM=wsvt25)
- pretty Gallant wsfont, rather than the acceptable or ugly (depending upon
  the frame buffer) ROM font
- colormap ioctl support for Gatorbox and Topcat; DaVinci and Renaissance
  not done due to lack of hardware and/or documentation
- even more code factorization

tested on hyperion, and 4/6/8bpp catseye/topcat/kathmandu hardware, by
millert@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.8 2005/01/21 16:24:12 miod Exp $	*/
d528 1
a528 1
	pri = CN_INTERNAL;
@


1.8
log
@Oops, revert changes not intended to be commited in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.6 2005/01/19 10:51:24 miod Exp $	*/
d92 1
a122 1
int	topcat_getcmap(struct diofb *, struct wsdisplay_cmap *);
d161 1
a161 1
		switch (fbr->id2) {
d193 1
a193 1
	topcat_end_attach(sc, fbr->id2);
d239 1
a239 1
	topcat_end_attach(sc, fbr->id2);
d265 1
a265 1
		fbname = "HP98550 catseye";	/* A1416 kathmandu */
d276 1
a276 1
	    sc->sc_scode == conscode, 0, fbname);
d287 1
a291 3
	fb->planes = tc->num_planes;
	fb->planemask = (1 << fb->planes) - 1;

d297 1
a297 1
	if (fb->planes == 0) {	/* gee, no planes reported above */
d312 4
a315 1
			fb->planes++);
a317 3
	if (fb->planes > 8)
		fb->planes = 8;

d320 3
d336 1
a336 1
	if (tc->fbid != GID_TOPCAT) {
d355 1
a355 15
	diofb_fbsetup(fb);
	diofb_fontunpack(fb);

	/*
	 * Initialize color map for color displays
	 */
	if (fb->planes > 1) {
		topcat_setcolor(fb, 0);
		topcat_setcolor(fb, 1);
		topcat_setcolor(fb, (1 << fb->planes) - 1);
	}

	/*
	 * Enable display.
	 */
d364 1
d370 8
d380 3
a382 3
		wdf->height = fb->dheight;
		wdf->width = fb->dwidth;
		wdf->depth = fb->planes;
d386 1
a386 1
		*(u_int *)data = (fb->fbwidth * fb->planes) >> 3;
d389 1
a389 1
		return (topcat_getcmap(fb, (struct wsdisplay_cmap *)data));
d420 8
a427 13
	tccm_waitbusy(tc);
	tc->rdata  = fb->cmap.r[index];
	tc->gdata  = fb->cmap.g[index];
	tc->bdata  = fb->cmap.b[index];
	tc->cindex = 255 - index;
	tc->strobe = 0xff;

	tccm_waitbusy(tc);
	tc->rdata  = 0;
	tc->gdata  = 0;
	tc->bdata  = 0;
	tc->cindex = 0;
}
d429 17
a445 18
int
topcat_getcmap(struct diofb *fb, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index, count = cm->count;
	u_int colcount = 1 << fb->planes;
	int error;

	if (index >= colcount || count > colcount - index)
		return (EINVAL);

	if ((error = copyout(fb->cmap.r + index, cm->red, count)) != 0)
		return (error);
	if ((error = copyout(fb->cmap.g + index, cm->green, count)) != 0)
		return (error);
	if ((error = copyout(fb->cmap.b + index, cm->blue, count)) != 0)
		return (error);

	return (0);
d496 2
d517 1
a517 1
	switch (fbr->id2) {
d582 1
a582 1
		switch (fbr->id2) {
a619 2
	long defattr;

d621 1
a621 2
	diofb_alloc_attr(NULL, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&diofb_cn.wsd, &diofb_cn, 0, 0, defattr);
@


1.7
log
@Overhaul of the pxa2x0_lcd code, to allow early (before autoconf) attachment,
and collateral changes.

Because this driver requires us_dma (and as such, vm services) to work, it
can not be selected in consinit(). Instead, add a hook to the arm
cpu_startup() which will, on zaurus, switch console from serial (selected
in consinit()) to lcd.

This also makes the zaurus-specific early pxa2x0_clkman() substitute code
cleaner.

While there, move boot -c handling later, after the glass console is set up.

Tested by drahn@@ and uwe@@
@
text
@d390 1
a390 1
		*(u_int *)data = fb->fbwidth;
@


1.6
log
@Report the appropriate wsdisplay types to WSDISPLAYIO_GTYPE.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.5 2005/01/18 21:53:23 miod Exp $	*/
d390 1
a390 1
		*(u_int *)data = (fb->fbwidth * fb->planes) >> 3;
@


1.5
log
@Better colormap recovery after X11 exits.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.4 2005/01/18 19:17:03 miod Exp $	*/
d380 1
a380 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.4
log
@Colormap handling for topcat; Xwsfb now runs.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.3 2005/01/16 16:14:10 miod Exp $	*/
d320 1
a353 1
	fb->bmv = topcat_windowmove;
d363 1
@


1.3
log
@Simplify diofb_fbinquire(), since in the only case where we need to know
the video registers size, this value can easily be computed from the standard
fb registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.2 2005/01/15 21:08:37 miod Exp $	*/
d122 1
d124 3
a126 2
void	topcat_setcolor(struct diofb *, u_int,
	    u_int8_t, u_int8_t, u_int8_t);
d265 1
a265 1
		fbname = "HP98550 catseye";
d317 13
d361 2
a362 2
		topcat_setcolor(fb, 0, 0, 0, 0);
		topcat_setcolor(fb, 1, 255, 255, 255);
a368 2

	return (0);
d392 1
d394 1
a394 2
		/* XXX TBD */
		break;
d419 1
a419 2
topcat_setcolor(struct diofb *fb, u_int index,
    u_int8_t r, u_int8_t g, u_int8_t b)
d424 3
a426 3
	tc->rdata  = r;
	tc->gdata  = g;
	tc->bdata  = b;
d435 48
@


1.2
log
@Use DIO_SIZE() macro instead of rolling our own implementation of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: topcat.c,v 1.1 2005/01/14 22:39:26 miod Exp $	*/
d286 1
a286 1
	if ((rc = diofb_fbinquire(fb, scode, fbr, 0x10000)) != 0)
@


1.1
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a458 1
	u_char *dioiidev;
d497 1
a497 5
		if (scode >= DIOII_SCBASE) {
			dioiidev = (u_char *)va;
			return ((dioiidev[0x101] + 1) * 0x100000);
		}
		return (DIO_DEVSIZE);
@

