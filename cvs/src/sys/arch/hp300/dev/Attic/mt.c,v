head	1.27;
access;
symbols
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.10
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.8
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.6
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.20
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.18
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.16
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.14
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2014.03.18.22.36.32;	author miod;	state dead;
branches;
next	1.26;

1.26
date	2013.06.11.16.42.07;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.10.03.06.51;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.26.13.43.38;	author blambert;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.11.16.54.59;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.12.06.58.33;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.11.12.35.41;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.10.20.50.22;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.20.23.27.25;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.27.18.34.58;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.18.00.16.48;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.16.21.23.55;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.20.20.08.13;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.30.11.03.52;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.23.15.31.57;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.01.16.51.10;	author millert;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	97.04.16.11.56.13;	author downsj;	state Exp;
branches
	1.6.14.1;
next	1.5;

1.5
date	97.02.03.04.47.39;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.12.15.12.54;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.49;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.20;	author deraadt;	state Exp;
branches;
next	;

1.6.14.1
date	2001.07.04.10.15.30;	author niklas;	state Exp;
branches;
next	1.6.14.2;

1.6.14.2
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.6.14.3;

1.6.14.3
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.6.14.4;

1.6.14.4
date	2003.03.27.23.19.20;	author niklas;	state Exp;
branches;
next	1.6.14.5;

1.6.14.5
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: mt.c,v 1.26 2013/06/11 16:42:07 deraadt Exp $	*/
/*	$NetBSD: mt.c,v 1.8 1997/03/31 07:37:29 scottr Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1992, The University of Utah and
 * the Computer Systems Laboratory at the University of Utah (CSL).
 * All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *	Utah $Hdr: mt.c 1.8 95/09/12$
 */
/*	@@(#)mt.c	3.9	90/07/10	mt Xinu
 *
 * Magnetic tape driver (7974a, 7978a/b, 7979a, 7980a, 7980xc)
 * Original version contributed by Mt. Xinu.
 * Modified for 4.4BSD by Mark Davies and Andrew Vignaux, Department of
 * Computer Science, Victoria University of Wellington
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/ioctl.h>
#include <sys/mtio.h>
#include <sys/file.h>
#include <sys/proc.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/tty.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>

#include <hp300/dev/hpibvar.h>

#include <hp300/dev/mtreg.h>

struct	mtinfo {
	u_short	hwid;
	char	*desc;
} mtinfo[] = {
	{ MT7978ID,	"7978"	},
	{ MT7979AID,	"7979A"	},
	{ MT7980ID,	"7980"	},
	{ MT7974AID,	"7974A"	},
};
int	nmtinfo = sizeof(mtinfo) / sizeof(mtinfo[0]);

struct	mt_softc {
	struct	device sc_dev;
	int	sc_hpibno;	/* logical HPIB this slave it attached to */
	int	sc_slave;	/* HPIB slave address (0-6) */
	short	sc_flags;	/* see below */
	u_char	sc_lastdsj;	/* place for DSJ in mtreaddsj() */
	u_char	sc_lastecmd;	/* place for End Command in mtreaddsj() */
	short	sc_recvtimeo;	/* count of hpibsend timeouts to prevent hang */
	short	sc_statindex;	/* index for next sc_stat when MTF_STATTIMEO */
	struct	mt_stat sc_stat;/* status bytes last read from device */
	short	sc_density;	/* current density of tape (mtio.h format) */
	short	sc_type;	/* tape drive model (hardware IDs) */
	struct	hpibqueue sc_hq; /* HPIB device queue member */
	struct buf sc_tab;	/* buf queue */
	struct timeout sc_start_to; /* spl_mtstart timeout */
	struct timeout sc_intr_to; /* spl_mtintr timeout */
};

#ifdef DEBUG
int	mtdebug = 0;
#define	dlog	if (mtdebug) log
#else
#define	dlog	if (0) log
#endif

#define	UNIT(x)		(minor(x) & 3)

#define B_CMD		B_XXX		/* command buf instead of data */
#define	b_cmd		b_blkno		/* blkno holds cmd when B_CMD */

int	mtmatch(struct device *, void *, void *);
void	mtattach(struct device *, struct device *, void *);

struct cfattach mt_ca = {
	sizeof(struct mt_softc), mtmatch, mtattach
};

struct cfdriver mt_cd = {
	NULL, "mt", DV_TAPE
};

int	mtident(struct mt_softc *, struct hpibbus_attach_args *);
void	mtustart(struct mt_softc *);
int	mtreaddsj(struct mt_softc *, int);
int	mtcommand(dev_t, int, int);
void	spl_mtintr(void *);
void	spl_mtstart(void *);

void	mtstart(void *);
void	mtgo(void *);
void	mtintr(void *);

bdev_decl(mt);
cdev_decl(mt);

int
mtmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct hpibbus_attach_args *ha = aux;

	return (mtident(NULL, ha));
}

void
mtattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct mt_softc *sc = (struct mt_softc *)self;
	struct hpibbus_attach_args *ha = aux;
	int unit, hpibno, slave;

	if (mtident(sc, ha) == 0) {
		printf("\n%s: impossible!\n", sc->sc_dev.dv_xname);
		return;
	}

	unit = self->dv_unit;
	hpibno = parent->dv_unit;
	slave = ha->ha_slave;

	sc->sc_tab.b_actb = &sc->sc_tab.b_actf;

	sc->sc_hpibno = hpibno;
	sc->sc_slave = slave;
	sc->sc_flags = MTF_EXISTS;

	/* Initialize hpib job queue entry. */
	sc->sc_hq.hq_softc = sc;
	sc->sc_hq.hq_slave = sc->sc_slave;
	sc->sc_hq.hq_start = mtstart;
	sc->sc_hq.hq_go = mtgo;
	sc->sc_hq.hq_intr = mtintr;

	/* Initialize timeout structures */
	timeout_set(&sc->sc_start_to, spl_mtstart, sc);
	timeout_set(&sc->sc_intr_to, spl_mtintr, sc);
}

int
mtident(sc, ha)
	struct mt_softc *sc;
	struct hpibbus_attach_args *ha;
{
	int i;

	for (i = 0; i < nmtinfo; i++) {
		if (ha->ha_id == mtinfo[i].hwid &&
		    ha->ha_punit == 0) {
			if (sc != NULL) {
				sc->sc_type = mtinfo[i].hwid;
				printf(": %s tape\n", mtinfo[i].desc);
			}
			return (1);
		}
	}
	return (0);
}

/*
 * Perform a read of "Device Status Jump" register and update the
 * status if necessary.  If status is read, the given "ecmd" is also
 * performed, unless "ecmd" is zero.  Returns DSJ value, -1 on failure
 * and -2 on "temporary" failure.
 */
int
mtreaddsj(sc, ecmd)
	struct mt_softc *sc;
	int ecmd;
{
	int retval;

	if (sc->sc_flags & MTF_STATTIMEO)
		goto getstats;
	retval = hpibrecv(sc->sc_hpibno,
	    (sc->sc_flags & MTF_DSJTIMEO) ? -1 : sc->sc_slave,
	    MTT_DSJ, &(sc->sc_lastdsj), 1);
	sc->sc_flags &= ~MTF_DSJTIMEO;
	if (retval != 1) {
		dlog(LOG_DEBUG, "%s can't hpibrecv DSJ",
		    sc->sc_dev.dv_xname);
		if (sc->sc_recvtimeo == 0)
			sc->sc_recvtimeo = hz;
		if (--sc->sc_recvtimeo == 0)
			return (-1);
		if (retval == 0)
			sc->sc_flags |= MTF_DSJTIMEO;
		return (-2);
	}
	sc->sc_recvtimeo = 0;
	sc->sc_statindex = 0;
	dlog(LOG_DEBUG, "%s readdsj: 0x%x", sc->sc_dev.dv_xname,
	    sc->sc_lastdsj);
	sc->sc_lastecmd = ecmd;
	switch (sc->sc_lastdsj) {
	    case 0:
		if (ecmd & MTE_DSJ_FORCE)
			break;
		return (0);

	    case 2:
		sc->sc_lastecmd = MTE_COMPLETE;
	    case 1:
		break;

	    default:
		log(LOG_ERR, "%s readdsj: DSJ 0x%x\n", sc->sc_dev.dv_xname,
		    sc->sc_lastdsj);
		return (-1);
	}
    getstats:
	retval = hpibrecv(sc->sc_hpibno,
	    (sc->sc_flags & MTF_STATCONT) ? -1 : sc->sc_slave,
	    MTT_STAT, ((char *)&(sc->sc_stat)) + sc->sc_statindex,
	    sizeof(sc->sc_stat) - sc->sc_statindex);
	sc->sc_flags &= ~(MTF_STATTIMEO | MTF_STATCONT);
	if (retval != sizeof(sc->sc_stat) - sc->sc_statindex) {
		if (sc->sc_recvtimeo == 0)
			sc->sc_recvtimeo = hz;
		if (--sc->sc_recvtimeo != 0) {
			if (retval >= 0) {
				sc->sc_statindex += retval;
				sc->sc_flags |= MTF_STATCONT;
			}
			sc->sc_flags |= MTF_STATTIMEO;
			return (-2);
		}
		log(LOG_ERR, "%s readdsj: can't read status",
		    sc->sc_dev.dv_xname);
		return (-1);
	}
	sc->sc_recvtimeo = 0;
	sc->sc_statindex = 0;
	dlog(LOG_DEBUG, "%s readdsj: status is %x %x %x %x %x %x",
	    sc->sc_dev.dv_xname,
	    sc->sc_stat1, sc->sc_stat2, sc->sc_stat3,
	    sc->sc_stat4, sc->sc_stat5, sc->sc_stat6);
	if (sc->sc_lastecmd)
		(void) hpibsend(sc->sc_hpibno, sc->sc_slave,
		    MTL_ECMD, &(sc->sc_lastecmd), 1);
	return ((int) sc->sc_lastdsj);
}

int
mtopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = UNIT(dev);
	struct mt_softc *sc;
	int req_den;
	int error;

	if (unit >= mt_cd.cd_ndevs ||
	    (sc = mt_cd.cd_devs[unit]) == NULL ||
	    (sc->sc_flags & MTF_EXISTS) == 0)
		return (ENXIO);

	dlog(LOG_DEBUG, "%s open: flags 0x%x", sc->sc_dev.dv_xname,
	    sc->sc_flags);
	if (sc->sc_flags & MTF_OPEN)
		return (EBUSY);
	sc->sc_flags |= MTF_OPEN;
	if ((sc->sc_flags & MTF_ALIVE) == 0) {
		error = mtcommand(dev, MTRESET, 0);
		if (error != 0 || (sc->sc_flags & MTF_ALIVE) == 0)
			goto errout;
		if ((sc->sc_stat1 & (SR1_BOT | SR1_ONLINE)) == SR1_ONLINE)
			(void) mtcommand(dev, MTREW, 0);
	}
	for (;;) {
		if ((error = mtcommand(dev, MTNOP, 0)) != 0)
			goto errout;
		if (!(sc->sc_flags & MTF_REW))
			break;
		if (tsleep((caddr_t) &lbolt, PCATCH | (PZERO + 1),
		    "mt", 0) != 0) {
			error = EINTR;
			goto errout;
		}
	}
	if ((flag & FWRITE) && (sc->sc_stat1 & SR1_RO)) {
		error = EROFS;
		goto errout;
	}
	if (!(sc->sc_stat1 & SR1_ONLINE)) {
		uprintf("%s: not online\n", sc->sc_dev.dv_xname);
		error = EIO;
		goto errout;
	}
	/*
	 * Select density:
	 *  - find out what density the drive is set to
	 *	(i.e. the density of the current tape)
	 *  - if we are going to write
	 *    - if we're not at the beginning of the tape
	 *      - complain if we want to change densities
	 *    - otherwise, select the mtcommand to set the density
	 *
	 * If the drive doesn't support it then don't change the recorded
	 * density.
	 *
	 * The original MOREbsd code had these additional conditions
	 * for the mid-tape change
	 *
	 *	req_den != T_BADBPI &&
	 *	sc->sc_density != T_6250BPI
	 *
	 * which suggests that it would be possible to write multiple
	 * densities if req_den == T_BAD_BPI or the current tape
	 * density was 6250.  Testing of our 7980 suggests that the
	 * device cannot change densities mid-tape.
	 *
	 * ajv@@comp.vuw.ac.nz
	 */
	sc->sc_density = (sc->sc_stat2 & SR2_6250) ? T_6250BPI : (
			 (sc->sc_stat3 & SR3_1600) ? T_1600BPI : (
			 (sc->sc_stat3 & SR3_800) ? T_800BPI : -1));
	req_den = (dev & T_DENSEL);

	if (flag & FWRITE) {
		if (!(sc->sc_stat1 & SR1_BOT)) {
			if (sc->sc_density != req_den) {
				uprintf("%s: can't change density mid-tape\n",
				    sc->sc_dev.dv_xname);
				error = EIO;
				goto errout;
			}
		}
		else {
			int mtset_density =
			    (req_den == T_800BPI  ? MTSET800BPI : (
			     req_den == T_1600BPI ? MTSET1600BPI : (
			     req_den == T_6250BPI ? MTSET6250BPI : (
			     sc->sc_type == MT7980ID
						  ? MTSET6250DC
						  : MTSET6250BPI))));
			if (mtcommand(dev, mtset_density, 0) == 0)
				sc->sc_density = req_den;
		}
	}
	return (0);
errout:
	sc->sc_flags &= ~MTF_OPEN;
	return (error);
}

int
mtclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	struct mt_softc *sc = mt_cd.cd_devs[UNIT(dev)];

	if (sc->sc_flags & MTF_WRT) {
		(void) mtcommand(dev, MTWEOF, 2);
		(void) mtcommand(dev, MTBSF, 0);
	}
	if ((minor(dev) & T_NOREWIND) == 0)
		(void) mtcommand(dev, MTREW, 0);
	sc->sc_flags &= ~MTF_OPEN;
	return (0);
}

int
mtcommand(dev, cmd, cnt)
	dev_t dev;
	int cmd;
	int cnt;
{
	struct buf b;
	int error = 0;

	bzero(&b, sizeof(b));
	b.b_cmd = cmd;
	b.b_dev = dev;
	do {
		b.b_flags = B_BUSY | B_CMD | B_RAW;
		mtstrategy(&b);
		biowait(&b);
		if (b.b_flags & B_ERROR) {
			error = (int) (unsigned) b.b_error;
			break;
		}
	} while (--cnt > 0);

	return (error);
}

/*
 * Only thing to check here is for legal record lengths (writes only).
 */
void
mtstrategy(bp)
	struct buf *bp;
{
	struct mt_softc *sc;
	struct buf *dp;
	int unit;
	int s;

	unit = UNIT(bp->b_dev);
	sc = mt_cd.cd_devs[unit];
	dlog(LOG_DEBUG, "%s strategy", sc->sc_dev.dv_xname);
	if ((bp->b_flags & (B_CMD | B_READ)) == 0) {
#define WRITE_BITS_IGNORED	8
#if 0
		if (bp->b_bcount & ((1 << WRITE_BITS_IGNORED) - 1)) {
			printf("%s: write record must be multiple of %d\n",
				sc->sc_dev.dv_xname, 1 << WRITE_BITS_IGNORED);
			goto error;
		}
#endif
		s = 16 * 1024;
		if (sc->sc_stat2 & SR2_LONGREC) {
			switch (sc->sc_density) {
			    case T_1600BPI:
				s = 32 * 1024;
				break;

			    case T_6250BPI:
			    case T_BADBPI:
				s = 60 * 1024;
				break;
			}
		}
		if (bp->b_bcount > s) {
			printf("%s: write record (%ld) too big: limit (%d)\n",
				sc->sc_dev.dv_xname, bp->b_bcount, s);
#if 0 /* XXX see above */
	    error:
#endif
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
			s = splbio();
			biodone(bp);
			splx(s);
			return;
		}
	}
	dp = &sc->sc_tab;
	bp->b_actf = NULL;
	s = splbio();
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;
	if (dp->b_active == 0) {
		dp->b_active = 1;
		mtustart(sc);
	}
	splx(s);
}

void
mtustart(sc)
	struct mt_softc *sc;
{

	dlog(LOG_DEBUG, "%s ustart", sc->sc_dev.dv_xname);
	if (hpibreq(sc->sc_dev.dv_parent, &sc->sc_hq))
		mtstart(sc);
}

void
spl_mtintr(arg)
	void *arg;
{
	struct mt_softc *sc = arg;
	int s = splbio();

	hpibppclear(sc->sc_hpibno);
	mtintr(sc);
	splx(s);
}

void
spl_mtstart(arg)
	void *arg;
{
	int s = splbio();

	mtstart(arg);
	splx(s);
}

void
mtstart(arg)
	void *arg;
{
	struct mt_softc *sc = arg;
	struct buf *bp, *dp;
	short	cmdcount = 1;
	u_char	cmdbuf[2];
	int s;

	dlog(LOG_DEBUG, "%s start", sc->sc_dev.dv_xname);
	sc->sc_flags &= ~MTF_WRT;
	bp = sc->sc_tab.b_actf;
	if ((sc->sc_flags & MTF_ALIVE) == 0 &&
	    ((bp->b_flags & B_CMD) == 0 || bp->b_cmd != MTRESET))
		goto fatalerror;

	if (sc->sc_flags & MTF_REW) {
		if (!hpibpptest(sc->sc_hpibno, sc->sc_slave))
			goto stillrew;
		switch (mtreaddsj(sc, MTE_DSJ_FORCE|MTE_COMPLETE|MTE_IDLE)) {
		    case 0:
		    case 1:
		stillrew:
			if ((sc->sc_stat1 & SR1_BOT) ||
			    !(sc->sc_stat1 & SR1_ONLINE)) {
				sc->sc_flags &= ~MTF_REW;
				break;
			}
		    case -2:
			/*
			 * -2 means "timeout" reading DSJ, which is probably
			 * temporary.  This is considered OK when doing a NOP,
			 * but not otherwise.
			 */
			if (sc->sc_flags & (MTF_DSJTIMEO | MTF_STATTIMEO)) {
				timeout_add_msec(&sc->sc_start_to, 1000 >> 5);
				return;
			}
		    case 2:
			if (bp->b_cmd != MTNOP || !(bp->b_flags & B_CMD)) {
				bp->b_error = EBUSY;
				goto errdone;
			}
			goto done;

		    default:
			goto fatalerror;
		}
	}
	if (bp->b_flags & B_CMD) {
		if (sc->sc_flags & MTF_PASTEOT) {
			switch(bp->b_cmd) {
			    case MTFSF:
			    case MTWEOF:
			    case MTFSR:
				bp->b_error = ENOSPC;
				goto errdone;

			    case MTBSF:
			    case MTOFFL:
			    case MTBSR:
			    case MTREW:
				sc->sc_flags &= ~(MTF_PASTEOT | MTF_ATEOT);
				break;
			}
		}
		switch(bp->b_cmd) {
		    case MTFSF:
			if (sc->sc_flags & MTF_HITEOF)
				goto done;
			cmdbuf[0] = MTTC_FSF;
			break;

		    case MTBSF:
			if (sc->sc_flags & MTF_HITBOF)
				goto done;
			cmdbuf[0] = MTTC_BSF;
			break;

		    case MTOFFL:
			sc->sc_flags |= MTF_REW;
			cmdbuf[0] = MTTC_REWOFF;
			break;

		    case MTWEOF:
			cmdbuf[0] = MTTC_WFM;
			break;

		    case MTBSR:
			cmdbuf[0] = MTTC_BSR;
			break;

		    case MTFSR:
			cmdbuf[0] = MTTC_FSR;
			break;

		    case MTREW:
			sc->sc_flags |= MTF_REW;
			cmdbuf[0] = MTTC_REW;
			break;

		    case MTNOP:
			/*
			 * NOP is supposed to set status bits.
			 * Force readdsj to do it.
			 */
			switch (mtreaddsj(sc,
			  MTE_DSJ_FORCE | MTE_COMPLETE | MTE_IDLE)) {
			    default:
				goto done;

			    case -1:
				/*
				 * If this fails, perform a device clear
				 * to fix any protocol problems and (most
				 * likely) get the status.
				 */
				bp->b_cmd = MTRESET;
				break;

			    case -2:
				timeout_add_msec(&sc->sc_start_to, 1000 >> 5);
				return;
			}

		    case MTRESET:
			/*
			 * 1) selected device clear (send with "-2" secondary)
			 * 2) set timeout, then wait for "service request"
			 * 3) interrupt will read DSJ (and END COMPLETE-IDLE)
			 */
			if (hpibsend(sc->sc_hpibno, sc->sc_slave, -2, NULL, 0)){
				log(LOG_ERR, "%s can't reset",
				    sc->sc_dev.dv_xname);
				goto fatalerror;
			}
			timeout_add_sec(&sc->sc_intr_to, 4);
			hpibawait(sc->sc_hpibno);
			return;

		    case MTSET800BPI:
			cmdbuf[0] = MTTC_800;
			break;

		    case MTSET1600BPI:
			cmdbuf[0] = MTTC_1600;
			break;

		    case MTSET6250BPI:
			cmdbuf[0] = MTTC_6250;
			break;

		    case MTSET6250DC:
			cmdbuf[0] = MTTC_DC6250;
			break;
		}
	} else {
		if (sc->sc_flags & MTF_PASTEOT) {
			bp->b_error = ENOSPC;
			goto errdone;
		}
		if (bp->b_flags & B_READ) {
			sc->sc_flags |= MTF_IO;
			cmdbuf[0] = MTTC_READ;
		} else {
			sc->sc_flags |= MTF_WRT | MTF_IO;
			cmdbuf[0] = MTTC_WRITE;
			cmdbuf[1] = (bp->b_bcount + ((1 << WRITE_BITS_IGNORED) - 1)) >> WRITE_BITS_IGNORED;
			cmdcount = 2;
		}
	}
	if (hpibsend(sc->sc_hpibno, sc->sc_slave, MTL_TCMD, cmdbuf, cmdcount)
	    == cmdcount) {
		if (sc->sc_flags & MTF_REW)
			goto done;
		hpibawait(sc->sc_hpibno);
		return;
	}
fatalerror:
	/*
	 * If anything fails, the drive is probably hosed, so mark it not
	 * "ALIVE" (but it EXISTS and is OPEN or we wouldn't be here, and
	 * if, last we heard, it was REWinding, remember that).
	 */
	sc->sc_flags &= MTF_EXISTS | MTF_OPEN | MTF_REW;
	bp->b_error = EIO;
errdone:
	bp->b_flags |= B_ERROR;
done:
	sc->sc_flags &= ~(MTF_HITEOF | MTF_HITBOF);
	s = splbio();
	biodone(bp);
	splx(s);
	if ((dp = bp->b_actf))
		dp->b_actb = bp->b_actb;
	else
		sc->sc_tab.b_actb = bp->b_actb;
	*bp->b_actb = dp;
	hpibfree(sc->sc_dev.dv_parent, &sc->sc_hq);
	if ((bp = dp) == NULL)
		sc->sc_tab.b_active = 0;
	else
		mtustart(sc);
}

/*
 * The Utah code had a bug which meant that the driver was unable to read.
 * "rw" was initialized to bp->b_flags & B_READ before "bp" was initialized.
 *   -- ajv@@comp.vuw.ac.nz
 */
void
mtgo(arg)
	void *arg;
{
	struct mt_softc *sc = arg;
	struct buf *bp;
	int rw;

	dlog(LOG_DEBUG, "%s go", sc->sc_dev.dv_xname);
	bp = sc->sc_tab.b_actf;
	rw = bp->b_flags & B_READ;
	hpibgo(sc->sc_hpibno, sc->sc_slave, rw ? MTT_READ : MTL_WRITE,
	    bp->b_data, bp->b_bcount, rw, rw != 0);
}

void
mtintr(arg)
	void *arg;
{
	struct mt_softc *sc = arg;
	struct buf *bp, *dp;
	int i;
	u_char cmdbuf[4];

	bp = sc->sc_tab.b_actf;
	if (bp == NULL) {
		log(LOG_ERR, "%s intr: bp == NULL", sc->sc_dev.dv_xname);
		return;
	}

	dlog(LOG_DEBUG, "%s intr", sc->sc_dev.dv_xname);

	/*
	 * Some operation completed.  Read status bytes and report errors.
	 * Clear EOF flags here `cause they're set once on specific conditions
	 * below when a command succeeds.
	 * A DSJ of 2 always means keep waiting.  If the command was READ
	 * (and we're in data DMA phase) stop data transfer first.
	 */
	sc->sc_flags &= ~(MTF_HITEOF | MTF_HITBOF);
	if ((bp->b_flags & (B_CMD|B_READ)) == B_READ &&
	    !(sc->sc_flags & (MTF_IO | MTF_STATTIMEO | MTF_DSJTIMEO))){
		cmdbuf[0] = MTE_STOP;
		(void) hpibsend(sc->sc_hpibno, sc->sc_slave, MTL_ECMD,cmdbuf,1);
	}
	switch (mtreaddsj(sc, 0)) {
	    case 0:
		break;

	    case 1:
		/*
		 * If we're in the middle of a READ/WRITE and have yet to
		 * start the data transfer, a DSJ of one should terminate it.
		 */
		sc->sc_flags &= ~MTF_IO;
		break;

	    case 2:
		(void) hpibawait(sc->sc_hpibno);
		return;

	    case -2:
		/*
		 * -2 means that the drive failed to respond quickly enough
		 * to the request for DSJ.  It's probably just "busy" figuring
		 * it out and will know in a little bit...
		 */
		timeout_add_msec(&sc->sc_intr_to, 1000 >> 5);
		return;

	    default:
		log(LOG_ERR, "%s intr: can't get drive stat",
		    sc->sc_dev.dv_xname);
		goto error;
	}
	if (sc->sc_stat1 & (SR1_ERR | SR1_REJECT)) {
		i = sc->sc_stat4 & SR4_ERCLMASK;
		log(LOG_ERR, "%s: %s error, retry %d, SR2/3 %x/%x, code %d",
			sc->sc_dev.dv_xname, i == SR4_DEVICE ? "device" :
			(i == SR4_PROTOCOL ? "protocol" :
			(i == SR4_SELFTEST ? "selftest" : "unknown")),
			sc->sc_stat4 & SR4_RETRYMASK, sc->sc_stat2,
			sc->sc_stat3, sc->sc_stat5);

		if ((bp->b_flags & B_CMD) && bp->b_cmd == MTRESET)
			timeout_del(&sc->sc_intr_to);
		if (sc->sc_stat3 & SR3_POWERUP)
			sc->sc_flags &= MTF_OPEN | MTF_EXISTS;
		goto error;
	}
	/*
	 * Report and clear any soft errors.
	 */
	if (sc->sc_stat1 & SR1_SOFTERR) {
		log(LOG_WARNING, "%s: soft error, retry %d\n",
			sc->sc_dev.dv_xname, sc->sc_stat4 & SR4_RETRYMASK);
		sc->sc_stat1 &= ~SR1_SOFTERR;
	}
	/*
	 * We've initiated a read or write, but haven't actually started to
	 * DMA the data yet.  At this point, the drive's ready.
	 */
	if (sc->sc_flags & MTF_IO) {
		sc->sc_flags &= ~MTF_IO;
		if (hpibustart(sc->sc_hpibno))
			mtgo(sc);
		return;
	}
	/*
	 * Check for End Of Tape - we're allowed to hit EOT and then write (or
	 * read) one more record.  If we get here and have not already hit EOT,
	 * return ENOSPC to inform the process that it's hit it.  If we get
	 * here and HAVE already hit EOT, don't allow any more operations that
	 * move the tape forward.
	 */
	if (sc->sc_stat1 & SR1_EOT) {
		if (sc->sc_flags & MTF_ATEOT)
			sc->sc_flags |= MTF_PASTEOT;
		else {
			bp->b_flags |= B_ERROR;
			bp->b_error = ENOSPC;
			sc->sc_flags |= MTF_ATEOT;
		}
	}
	/*
	 * If a motion command was being executed, check for Tape Marks.
	 * If we were doing data, make sure we got the right amount, and
	 * check for hitting tape marks on reads.
	 */
	if (bp->b_flags & B_CMD) {
		if (sc->sc_stat1 & SR1_EOF) {
			if (bp->b_cmd == MTFSR)
				sc->sc_flags |= MTF_HITEOF;
			if (bp->b_cmd == MTBSR)
				sc->sc_flags |= MTF_HITBOF;
		}
		if (bp->b_cmd == MTRESET) {
			timeout_del(&sc->sc_intr_to);
			sc->sc_flags |= MTF_ALIVE;
		}
	} else {
		i = hpibrecv(sc->sc_hpibno, sc->sc_slave, MTT_BCNT, cmdbuf, 2);
		if (i != 2) {
			log(LOG_ERR, "%s intr: can't get xfer length\n",
			    sc->sc_dev.dv_xname);
			goto error;
		}
		i = (int) *((u_short *) cmdbuf);
		if (i <= bp->b_bcount) {
			if (i == 0)
				sc->sc_flags |= MTF_HITEOF;
			bp->b_resid = bp->b_bcount - i;
			dlog(LOG_DEBUG, "%s intr: bcount %ld, resid %d",
			    sc->sc_dev.dv_xname, bp->b_bcount, bp->b_resid);
		} else {
			printf("%s: record (%d) larger than wanted (%ld)\n",
				sc->sc_dev.dv_xname, i, bp->b_bcount);
    error:
			sc->sc_flags &= ~MTF_IO;
			bp->b_error = EIO;
			bp->b_flags |= B_ERROR;
		}
	}
	/*
	 * The operation is completely done.
	 * Let the drive know with an END command.
	 */
	cmdbuf[0] = MTE_COMPLETE | MTE_IDLE;
	(void) hpibsend(sc->sc_hpibno, sc->sc_slave, MTL_ECMD, cmdbuf, 1);
	bp->b_flags &= ~B_CMD;
	biodone(bp);
	if ((dp = bp->b_actf))
		dp->b_actb = bp->b_actb;
	else
		sc->sc_tab.b_actb = bp->b_actb;
	*bp->b_actb = dp;
	hpibfree(sc->sc_dev.dv_parent, &sc->sc_hq);
#if 0
	if (bp /*sc->sc_tab.b_actf*/ == NULL)
#else
	if (sc->sc_tab.b_actf == NULL)
#endif
		sc->sc_tab.b_active = 0;
	else
		mtustart(sc);
}

int
mtread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	return (physio(mtstrategy, dev, B_READ, minphys, uio));
}

int
mtwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	return (physio(mtstrategy, dev, B_WRITE, minphys, uio));
}

int
mtioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct mtop *op;
	int cnt;

	switch (cmd) {
	    case MTIOCTOP:
		op = (struct mtop *)data;
		switch(op->mt_op) {
		    case MTWEOF:
		    case MTFSF:
		    case MTBSR:
		    case MTBSF:
		    case MTFSR:
			cnt = op->mt_count;
			break;

		    case MTOFFL:
		    case MTREW:
		    case MTNOP:
			cnt = 0;
			break;

		    default:
			return (EINVAL);
		}
		return (mtcommand(dev, op->mt_op, cnt));

	    case MTIOCGET:
		break;

	    default:
		return (EINVAL);
	}
	return (0);
}

/*ARGSUSED*/
int
mtdump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{
	return (ENODEV);
}
@


1.26
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.25 2010/09/22 01:18:57 matthew Exp $	*/
@


1.25
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.24 2010/07/10 03:06:51 matthew Exp $	*/
d976 1
a976 1
	daddr64_t blkno;
@


1.24
log
@Eliminate two of the remaining three instances of drivers passing
their own buf to physio(9).

compiler tested by nick@@ and miod@@; ok miod@@
general approval thib@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.23 2009/07/26 13:43:38 blambert Exp $	*/
d917 1
a917 1
	return (physio(mtstrategy, NULL, dev, B_READ, minphys, uio));
d926 1
a926 1
	return (physio(mtstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.23
log
@timeout_add -> timeout_add_msec

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.22 2009/01/11 16:54:59 blambert Exp $	*/
a77 1
	struct buf sc_bufstore;	/* XXX buffer storage */
d398 1
a398 2
	struct mt_softc *sc = mt_cd.cd_devs[UNIT(dev)];
	struct buf *bp = &sc->sc_bufstore;
d401 3
a403 6
#if 1
	if (bp->b_flags & B_BUSY)
		return (EBUSY);
#endif
	bp->b_cmd = cmd;
	bp->b_dev = dev;
d405 5
a409 5
		bp->b_flags = B_BUSY | B_CMD | B_RAW;
		mtstrategy(bp);
		biowait(bp);
		if (bp->b_flags & B_ERROR) {
			error = (int) (unsigned) bp->b_error;
d413 1
a413 5
#if 0
	bp->b_flags = 0 /*&= ~B_BUSY*/;
#else
	bp->b_flags &= ~B_BUSY;
#endif
d917 1
a917 4
	struct mt_softc *sc = mt_cd.cd_devs[UNIT(dev)];

	return(physio(mtstrategy, &sc->sc_bufstore,
	    dev, B_READ, minphys, uio));
d926 1
a926 4
	struct mt_softc *sc = mt_cd.cd_devs[UNIT(dev)];

	return(physio(mtstrategy, &sc->sc_bufstore,
	    dev, B_WRITE, minphys, uio));
@


1.22
log
@Actual final round of timeout_add(to, n * hz) -> timeout_add_sec(to, n)
conversions.

ok kettenis@@
ok krw@@ (possibly for the second time :)
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.21 2008/06/12 06:58:33 deraadt Exp $	*/
d558 1
a558 1
				timeout_add(&sc->sc_start_to, hz >> 5);
d644 1
a644 1
				timeout_add(&sc->sc_start_to, hz >> 5);
d800 1
a800 1
		timeout_add(&sc->sc_intr_to, hz >> 5);
@


1.21
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.19 2008/06/10 20:50:22 beck Exp $	*/
d659 1
a659 1
			timeout_add(&sc->sc_intr_to, 4 * hz);
@


1.20
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.18 2007/06/06 17:15:11 deraadt Exp $	*/
d410 1
a410 1
		bp->b_flags = B_BUSY | B_CMD;
@


1.19
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d410 1
a410 1
		bp->b_flags = B_BUSY | B_CMD | B_RAW;
@


1.18
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.17 2006/01/20 23:27:25 miod Exp $	*/
d410 1
a410 1
		bp->b_flags = B_BUSY | B_CMD;
@


1.17
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.16 2005/12/27 18:34:58 miod Exp $	*/
d991 1
a991 1
	daddr_t blkno;
@


1.16
log
@Do not tprintf() information, use printf() instead like all other tape
drivers do.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.15 2005/11/18 00:16:48 miod Exp $	*/
d745 1
a745 1
	    bp->b_un.b_addr, bp->b_bcount, rw, rw != 0);
@


1.15
log
@Protect biodone() with splbio().
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.14 2005/11/16 21:23:55 miod Exp $	*/
a45 1
#include <sys/tprintf.h>
a76 1
	tpr_t	sc_ttyp;
a290 1
	sc->sc_ttyp = tprintf_open(p);
a389 1
	tprintf_close(sc->sc_ttyp);
d445 1
a445 2
			tprintf(sc->sc_ttyp,
				"%s: write record must be multiple of %d\n",
d464 1
a464 2
			tprintf(sc->sc_ttyp,
				"%s: write record (%ld) too big: limit (%d)\n",
d888 1
a888 2
			tprintf(sc->sc_ttyp,
				"%s: record (%d) larger than wanted (%ld)\n",
@


1.14
log
@Overhaul the way HP-IB devices are probed. We will now do an exhaustive
probe of the (slave, punit) tuple space, since this is the only way we
can get a dual disk or dual tape enclosure to attach two devices of the
same kind.

This allows us to get rid of the hpibbus resource map and related
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.13 2005/01/15 21:13:08 miod Exp $	*/
d536 1
d719 1
d721 1
@


1.13
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.12 2003/12/20 20:08:13 miod Exp $	*/
d176 2
a177 1
		if (ha->ha_id == mtinfo[i].hwid) {
@


1.12
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.11 2002/05/30 11:03:52 art Exp $	*/
d4 1
a4 1
/* 
@


1.11
log
@protect biodone with splbio.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.10 2002/05/23 15:31:57 art Exp $	*/
d887 1
a887 1
			dlog(LOG_DEBUG, "%s intr: bcount %ld, resid %ld",
@


1.10
log
@remove the defines for iodone -> biodone and iowait -> biowait.
Use the correct functions everywhere instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.9 2002/03/14 01:26:30 millert Exp $	*/
d476 1
d478 1
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.8 2002/02/15 20:45:30 nordin Exp $	*/
d415 1
a415 1
		iowait(bp);
d476 1
a476 1
			iodone(bp);
d715 1
a715 1
	iodone(bp);
d904 1
a904 1
	iodone(bp);
@


1.8
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.7 2001/05/01 16:51:10 millert Exp $	*/
d97 2
a98 2
int	mtmatch __P((struct device *, void *, void *));
void	mtattach __P((struct device *, struct device *, void *));
d108 10
a117 10
int	mtident __P((struct mt_softc *, struct hpibbus_attach_args *));
void	mtustart __P((struct mt_softc *));
int	mtreaddsj __P((struct mt_softc *, int));
int	mtcommand __P((dev_t, int, int));
void	spl_mtintr __P((void *));
void	spl_mtstart __P((void *));

void	mtstart __P((void *));
void	mtgo __P((void *));
void	mtintr __P((void *));
@


1.7
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.6 1997/04/16 11:56:13 downsj Exp $	*/
d512 1
a512 1
	(void) splx(s);
d522 1
a522 1
	(void) splx(s);
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.7 2001/05/01 16:51:10 millert Exp $	*/
d97 2
a98 2
int	mtmatch(struct device *, void *, void *);
void	mtattach(struct device *, struct device *, void *);
d108 10
a117 10
int	mtident(struct mt_softc *, struct hpibbus_attach_args *);
void	mtustart(struct mt_softc *);
int	mtreaddsj(struct mt_softc *, int);
int	mtcommand(dev_t, int, int);
void	spl_mtintr(void *);
void	spl_mtstart(void *);

void	mtstart(void *);
void	mtgo(void *);
void	mtintr(void *);
d415 1
a415 1
		biowait(bp);
d476 1
a476 3
			s = splbio();
			biodone(bp);
			splx(s);
d512 1
a512 1
	splx(s);
d522 1
a522 1
	splx(s);
d715 1
a715 1
	biodone(bp);
d904 1
a904 1
	biodone(bp);
@


1.6
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.5 1997/02/03 04:47:39 downsj Exp $	*/
d81 2
d162 4
d560 1
a560 1
				timeout(spl_mtstart, sc, hz >> 5);
d646 1
a646 1
				timeout(spl_mtstart, sc, hz >> 5);
d661 1
a661 1
			timeout(spl_mtintr, sc, 4 * hz);
d800 1
a800 1
		timeout(spl_mtintr, sc, hz >> 5);
d818 1
a818 1
			untimeout(spl_mtintr, sc);
d870 1
a870 1
			untimeout(spl_mtintr, sc);
@


1.6.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.6 1997/04/16 11:56:13 downsj Exp $	*/
a80 2
	struct timeout sc_start_to; /* spl_mtstart timeout */
	struct timeout sc_intr_to; /* spl_mtintr timeout */
a159 4

	/* Initialize timeout structures */
	timeout_set(&sc->sc_start_to, spl_mtstart, sc);
	timeout_set(&sc->sc_intr_to, spl_mtintr, sc);
d554 1
a554 1
				timeout_add(&sc->sc_start_to, hz >> 5);
d640 1
a640 1
				timeout_add(&sc->sc_start_to, hz >> 5);
d655 1
a655 1
			timeout_add(&sc->sc_intr_to, 4 * hz);
d794 1
a794 1
		timeout_add(&sc->sc_intr_to, hz >> 5);
d812 1
a812 1
			timeout_del(&sc->sc_intr_to);
d864 1
a864 1
			timeout_del(&sc->sc_intr_to);
@


1.6.14.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d512 1
a512 1
	splx(s);
d522 1
a522 1
	splx(s);
@


1.6.14.3
log
@Merge in -current from about a week ago
@
text
@d97 2
a98 2
int	mtmatch(struct device *, void *, void *);
void	mtattach(struct device *, struct device *, void *);
d108 6
a113 6
int	mtident(struct mt_softc *, struct hpibbus_attach_args *);
void	mtustart(struct mt_softc *);
int	mtreaddsj(struct mt_softc *, int);
int	mtcommand(dev_t, int, int);
void	spl_mtintr(void *);
void	spl_mtstart(void *);
d115 3
a117 3
void	mtstart(void *);
void	mtgo(void *);
void	mtintr(void *);
@


1.6.14.4
log
@Sync the SMP branch with 3.3
@
text
@d415 1
a415 1
		biowait(bp);
d476 1
a476 3
			s = splbio();
			biodone(bp);
			splx(s);
d715 1
a715 1
	biodone(bp);
d904 1
a904 1
	biodone(bp);
@


1.6.14.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d887 1
a887 1
			dlog(LOG_DEBUG, "%s intr: bcount %ld, resid %d",
@


1.5
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: mt.c,v 1.4 1997/01/12 15:12:54 downsj Exp $	*/
/*	$NetBSD: mt.c,v 1.7 1997/01/30 09:14:14 thorpej Exp $	*/
d58 4
a61 4
	MT7978ID,	"7978",
	MT7979AID,	"7979A",
	MT7980ID,	"7980",
	MT7974AID,	"7974A",
d271 1
a271 1
	register int unit = UNIT(dev);
d273 1
a273 1
	register int req_den;
d428 1
a428 1
	register struct buf *bp;
d430 4
a433 4
	register struct mt_softc *sc;
	register struct buf *dp;
	register int unit;
	register int s;
d463 1
a463 1
				"%s: write record (%d) too big: limit (%d)\n",
d465 1
d467 1
d524 1
a524 1
	register struct buf *bp, *dp;
d656 1
a656 1
			hpibawait(sc->sc_hpibno, sc->sc_slave);
d710 1
a710 1
	if (dp = bp->b_actf)
d870 2
a871 1
			log(LOG_ERR, "mt%d intr: can't get xfer length\n");
d879 1
a879 1
			dlog(LOG_DEBUG, "%s intr: bcount %d, resid %d",
d883 1
a883 1
				"%s: record (%d) larger than wanted (%d)\n",
d899 1
a899 1
	if (dp = bp->b_actf)
d947 1
a947 1
	register struct mtop *op;
@


1.4
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mt.c,v 1.6 1996/10/14 07:14:18 thorpej Exp $	*/
d5 1
a33 2
#include "mt.h"
#if NMT > 0
d47 2
a49 1
#include <hp300/dev/device.h>
d51 1
a53 1

d66 3
a68 3
	struct	hp_device *sc_hd;
	short	sc_hpibno;	/* logical HPIB this slave it attached to */
	short	sc_slave;	/* HPIB slave address (0-6) */
d77 1
a77 1
	struct	devqueue sc_dq;	/* HPIB device queue member */
d79 3
a81 3
} mt_softc[NMT];
struct	buf mttab[NMT];
struct  buf mtbuf[NMT];
d95 5
a99 4
int	mtmatch(), mtintr();
void	mtattach(), mtustart(), mtstart(), mtgo(), mtstrategy();
struct	driver mtdriver = {
	mtmatch, mtattach, "mt", (int (*)()) mtstart, (int (*)()) mtgo, mtintr,
d102 18
d121 3
a123 2
mtmatch(hd)
	register struct hp_device *hd;
d125 1
a125 6
	register int unit;
	register int hpibno = hd->hp_ctlr;
	register int slave = hd->hp_slave;
	register struct mt_softc *sc = &mt_softc[hd->hp_unit];
	register int id;
	register struct buf *bp;
d127 1
a127 9
	sc->sc_hd = hd;

	for (bp = mttab; bp < &mttab[NMT]; bp++)
		bp->b_actb = &bp->b_actf;
	unit = hpibid(hpibno, slave);
	for (id = 0; id < nmtinfo; id++)
		if (unit == mtinfo[id].hwid)
			return (1);
	return (0);			/* not a known HP magtape */
d131 12
a142 9
mtattach(hd)
	register struct hp_device *hd;
{
	register int unit;
	register int hpibno = hd->hp_ctlr;
	register int slave = hd->hp_slave;
	register struct mt_softc *sc;
	register int id;
	register struct buf *bp;
d144 3
a146 5
	/* XXX Ick. */
	unit = hpibid(hpibno, slave);
	for (id = 0; id < nmtinfo; id++)
		if (unit == mtinfo[id].hwid)
			break;
d148 1
a148 4
	unit = hd->hp_unit;
	sc = &mt_softc[unit];
	sc->sc_type = mtinfo[id].hwid;
	printf(": %s tape\n", mtinfo[id].desc);
a152 5
	sc->sc_dq.dq_softc = sc;
	sc->sc_dq.dq_ctlr = hpibno;
	sc->sc_dq.dq_unit = unit;
	sc->sc_dq.dq_slave = slave;
	sc->sc_dq.dq_driver = &mtdriver;
d154 25
a178 2
	/* XXX Set device class. */
	hd->hp_dev.dv_class = DV_TAPE;
d187 3
a189 2
mtreaddsj(unit, ecmd)
	register int unit;
a191 1
	register struct mt_softc *sc = &mt_softc[unit];
d197 2
a198 2
			  (sc->sc_flags & MTF_DSJTIMEO) ? -1 : sc->sc_slave,
			  MTT_DSJ, &(sc->sc_lastdsj), 1);
d201 2
a202 1
		dlog(LOG_DEBUG, "mt%d can't hpibrecv DSJ\n", unit);
d213 2
a214 1
	dlog(LOG_DEBUG, "mt%d readdsj: 0x%x\n", unit, sc->sc_lastdsj);
d228 2
a229 1
		log(LOG_ERR, "mt%d readdsj: DSJ 0x%x\n", unit, sc->sc_lastdsj);
d234 3
a236 3
			  (sc->sc_flags & MTF_STATCONT) ? -1 : sc->sc_slave,
			  MTT_STAT, ((char *)&(sc->sc_stat)) + sc->sc_statindex,
			  sizeof(sc->sc_stat) - sc->sc_statindex);
d249 2
a250 1
		log(LOG_ERR, "mt%d readdsj: can't read status\n", unit);
d255 4
a258 3
	dlog(LOG_DEBUG, "mt%d readdsj: status is %x %x %x %x %x %x\n", unit,
		sc->sc_stat1, sc->sc_stat2, sc->sc_stat3,
		sc->sc_stat4, sc->sc_stat5, sc->sc_stat6);
d261 1
a261 1
				MTL_ECMD, &(sc->sc_lastecmd), 1);
d265 1
d272 1
a272 1
	register struct mt_softc *sc = &mt_softc[unit];
d276 3
a278 2
	dlog(LOG_DEBUG, "mt%d open: flags 0x%x\n", unit, sc->sc_flags);
	if (unit >= NMT || (sc->sc_flags & MTF_EXISTS) == 0)
d280 3
d299 2
a300 1
		if (tsleep((caddr_t) &lbolt, PCATCH | (PZERO + 1), "mt", 0) != 0) {
d310 1
a310 1
		uprintf("%s: not online\n", sc->sc_hd->hp_xname);
d348 1
a348 1
				    sc->sc_hd->hp_xname);
d371 2
a372 1
mtclose(dev, flag)
d374 2
a375 1
	int flag;
d377 1
a377 1
	register struct mt_softc *sc = &mt_softc[UNIT(dev)];
d390 1
d396 2
a397 1
	register struct buf *bp = &mtbuf[UNIT(dev)];
d436 2
a437 2
	sc = &mt_softc[unit];
	dlog(LOG_DEBUG, "mt%d strategy\n", unit);
d444 1
a444 1
				sc->sc_hd->hp_xname, 1 << WRITE_BITS_IGNORED);
d464 1
a464 1
				sc->sc_hd->hp_xname, bp->b_bcount, s);
d472 1
a472 1
	dp = &mttab[unit];
d480 1
a480 1
		mtustart(unit);
d486 2
a487 2
mtustart(unit)
	register int unit;
d490 3
a492 3
	dlog(LOG_DEBUG, "mt%d ustart\n", unit);
	if (hpibreq(&(mt_softc[unit].sc_dq)))
		mtstart(unit);
a494 3
#define hpibppclear(unit) \
        { hpib_softc[unit].sc_flags &= ~HPIBF_PPOLL; }

d508 2
a509 2
spl_mtstart(unit)
	int unit;
d513 1
a513 1
	mtstart(unit);
d518 2
a519 2
mtstart(unit)
	register int unit;
d521 1
a521 1
	register struct mt_softc *sc = &mt_softc[unit];
d526 1
a526 1
	dlog(LOG_DEBUG, "mt%d start\n", unit);
d528 1
a528 1
	bp = mttab[unit].b_actf;
d536 1
a536 1
		switch (mtreaddsj(unit, MTE_DSJ_FORCE|MTE_COMPLETE|MTE_IDLE)) {
d552 1
a552 1
				timeout(spl_mtstart, (void *)unit, hz >> 5);
d623 2
a624 2
			switch (mtreaddsj(unit,
				    MTE_DSJ_FORCE | MTE_COMPLETE | MTE_IDLE)) {
d638 1
a638 1
				timeout(spl_mtstart, (void *)unit, hz >> 5);
d649 2
a650 1
				log(LOG_ERR, "mt%d can't reset\n", unit);
d653 1
a653 1
			timeout(spl_mtintr, (void *)sc, 4 * hz);
d711 1
a711 1
		mttab[unit].b_actb = bp->b_actb;
d713 1
a713 1
	hpibfree(&(sc->sc_dq));
d715 1
a715 1
		mttab[unit].b_active = 0;
d717 1
a717 1
		mtustart(unit);
d726 2
a727 2
mtgo(unit)
	register int unit;
d729 2
a730 2
	register struct mt_softc *sc = &mt_softc[unit];
	register struct buf *bp;
d733 2
a734 2
	dlog(LOG_DEBUG, "mt%d go\n", unit);
	bp = mttab[unit].b_actf;
d737 1
a737 1
	       bp->b_un.b_addr, bp->b_bcount, rw, rw != 0);
d740 1
a740 1
int
d744 4
a747 5
	register struct mt_softc *sc = arg;
	register struct buf *bp, *dp;
	register int i;
	int unit = sc->sc_hd->hp_unit;
	u_char	cmdbuf[4];
d749 1
a749 1
	bp = mttab[unit].b_actf;
d751 1
a751 1
		log(LOG_ERR, "mt%d intr: bp == NULL\n", unit);
d754 3
a756 1
	dlog(LOG_DEBUG, "mt%d intr\n", unit);
d770 1
a770 1
	switch (mtreaddsj(unit, 0)) {
d792 1
a792 1
		timeout(spl_mtintr, (void *)sc, hz >> 5);
d796 2
a797 1
		log(LOG_ERR, "mt%d intr: can't get drive stat\n", unit);
d802 2
a803 2
		log(LOG_ERR, "%s: %s error, retry %d, SR2/3 %x/%x, code %d\n",
			sc->sc_hd->hp_xname, i == SR4_DEVICE ? "device" :
d810 1
a810 1
			untimeout(spl_mtintr, (void *)sc);
d820 1
a820 1
			sc->sc_hd->hp_xname, sc->sc_stat4 & SR4_RETRYMASK);
d830 1
a830 1
			mtgo(unit);
d862 1
a862 1
			untimeout(spl_mtintr, (void *)sc);
d876 2
a877 2
			dlog(LOG_DEBUG, "mt%d intr: bcount %d, resid %d\n",
				unit, bp->b_bcount, bp->b_resid);
d881 1
a881 1
				sc->sc_hd->hp_xname, i, bp->b_bcount);
d899 1
a899 1
		mttab[unit].b_actb = bp->b_actb;
d901 1
a901 1
	hpibfree(&(sc->sc_dq));
d903 1
a903 1
	if (bp /*mttab[unit].b_actf*/ == NULL)
d905 1
a905 1
	if (mttab[unit].b_actf == NULL)
d907 1
a907 1
		mttab[unit].b_active = 0;
d909 1
a909 1
		mtustart(unit);
d912 2
a913 1
mtread(dev, uio)
d916 1
d918 4
a921 1
	return(physio(mtstrategy, &mtbuf[UNIT(dev)], dev, B_READ, minphys, uio));
d924 2
a925 1
mtwrite(dev, uio)
d928 1
d930 4
a933 1
	return(physio(mtstrategy, &mtbuf[UNIT(dev)], dev, B_WRITE, minphys, uio));
d936 2
a937 1
mtioctl(dev, cmd, data, flag)
d942 1
d980 2
a981 1
mtdump(dev)
d983 3
d987 1
a987 1
	return(ENXIO);
a988 2

#endif /* NMT > 0 */
@


1.3
log
@sync w/ Net 960424
@
text
@d1 2
a2 1
/*	$NetBSD: mt.c,v 1.3 1996/02/14 02:44:40 thorpej Exp $	*/
d153 3
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: mt.c,v 1.2 1995/12/02 18:22:04 thorpej Exp $	*/
d147 1
d457 2
a458 2
spl_mtintr(unit)
	int unit;
d460 1
d463 2
a464 2
	hpibppclear(mt_softc[unit].sc_hpibno);
	mtintr(unit);
d613 1
a613 1
			timeout(spl_mtintr, (void *)unit, 4 * hz);
d700 3
a702 2
mtintr(unit)
	register int unit;
d704 1
a704 1
	register struct mt_softc *sc = &mt_softc[unit];
d707 1
d751 1
a751 1
		timeout(spl_mtintr, (void *)unit, hz >> 5);
d768 1
a768 1
			untimeout(spl_mtintr, (void *)unit);
d820 1
a820 1
			untimeout(spl_mtintr, (void *)unit);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mt.c,v 1.1 1995/10/02 00:28:20 thorpej Exp $	*/
d65 1
d94 2
a95 2
int	mtinit(), mtintr();
void	mtustart(), mtstart(), mtgo(), mtstrategy();
d97 1
a97 1
	mtinit, "mt", (int (*)()) mtstart, (int (*)()) mtgo, mtintr,
d100 2
a101 1
mtinit(hd)
d107 1
a107 1
	register struct mt_softc *sc;
d110 3
a112 1
  
d118 1
a118 1
			goto gottype;
d120 18
a138 1
    gottype:
d142 1
a142 1
	printf("mt%d: %s tape\n", unit, mtinfo[id].desc);
a150 1
	return (1);
d271 1
a271 1
		uprintf("mt%d: not online\n", unit);
d308 2
a309 1
				uprintf("mt%d: can't change density mid-tape\n", unit);
d400 2
a401 2
				"mt%d: write record must be multiple of %d\n",
				unit, 1 << WRITE_BITS_IGNORED);
d420 2
a421 2
				"mt%d: write record (%d) too big: limit (%d)\n",
				unit, bp->b_bcount, s);
d756 2
a757 2
		log(LOG_ERR, "mt%d: %s error, retry %d, SR2/3 %x/%x, code %d\n",
			unit, i == SR4_DEVICE ? "device" :
d773 2
a774 2
		log(LOG_WARNING, "mt%d: soft error, retry %d\n",
			unit, sc->sc_stat4 & SR4_RETRYMASK);
d834 2
a835 2
				"mt%d: record (%d) larger than wanted (%d)\n",
				unit, i, bp->b_bcount);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
