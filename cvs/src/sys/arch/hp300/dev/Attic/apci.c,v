head	1.42;
access;
symbols
	OPENBSD_5_5:1.41.0.18
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.14
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.12
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.10
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.8
	OPENBSD_5_0:1.41.0.6
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.4
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.42
date	2014.03.18.22.36.31;	author miod;	state dead;
branches;
next	1.41;

1.41
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.30.18.10.47;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.28.14.13.27;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.12.12.57.51;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.09.17.53.38;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.01.20.29.00;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.31.12.00.05;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.09.17.32.25;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.06.20.09.12;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.01.11.59.37;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.30.18.14.09;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.30.18.03.33;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.28.21.37.34;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.28.21.12.37;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.22.11.59.11;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.27.22.08.39;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.27.22.05.15;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.14.00.52.09;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.12.18.01.08;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.15.21.13.08;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.29.07.35.52;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.19.21.34.42;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.15.20.32.12;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.04.22.08.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.23.07.05.06;	author millert;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.06.27.05.44.45;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.10.22.29.38;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.10.20.18.46;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.10.20.17.54;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.10.01.57.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.10.01.43.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.01.16.51.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.09.14.03.43.01;	author downsj;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	97.07.14.04.25.12;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.07.06.08.01.44;	author downsj;	state Exp;
branches;
next	;

1.3.12.1
date	2001.07.04.10.15.25;	author niklas;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.3.12.4;

1.3.12.4
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.3.12.5;

1.3.12.5
date	2004.02.19.10.48.38;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: apci.c,v 1.41 2010/07/02 17:27:01 nicm Exp $	*/
/*	$NetBSD: apci.c,v 1.9 2000/11/02 00:35:05 eeh Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997 Michael Smith.  All rights reserved.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)dca.c       8.2 (Berkeley) 1/12/94
 */

/*
 * Device driver for the APCI 8250-like UARTs found on the Apollo
 * Utility Chip on HP 9000/400-series workstations.
 *
 * There are 4 APCI UARTs on the Frodo ASIC.  The first one
 * is used to communicate with the Domain keyboard.  The second
 * one is the serial console port when the firmware is in Domain/OS
 * mode, and is mapped to select code 9 by the HP-UX firmware (except
 * on 425e models).
 *
 * We don't bother attaching a tty to the first UART; it lacks modem/flow
 * control, and is directly connected to the keyboard connector anyhow.
 */

/*
 * XXX This driver is very similar to the dca driver, and much
 * XXX more code could be shared.  (Currently, no code is shared.)
 * XXX FIXME!
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/hp300spu.h>

#include <dev/cons.h>

#include <hp300/dev/dioreg.h>		/* to check for dca at 9 */
#include <hp300/dev/diovar.h>
#include <hp300/dev/diodevs.h>

#include <hp300/dev/frodoreg.h>
#include <hp300/dev/frodovar.h>
#include <hp300/dev/apcireg.h>
#include <hp300/dev/apcivar.h>
#include <hp300/dev/dcareg.h>		/* register bit definitions */

#ifdef DDB
#include <ddb/db_var.h>
#endif

struct apci_softc {
	struct	device sc_dev;		/* generic device glue */
	struct	isr sc_isr;
	struct	apciregs *sc_apci;	/* device registers */
	struct	tty *sc_tty;		/* tty glue */
	struct	timeout sc_timeout;	/* timeout */
	int	sc_ferr,
		sc_perr,
		sc_oflow,
		sc_toterr;		/* stats */
	int	sc_flags;
	u_char	sc_cua;			/* callout mode */
};

/* sc_flags */
#define	APCI_HASFIFO	0x01		/* unit has a fifo */
#define	APCI_ISCONSOLE	0x02		/* unit is console */
#define	APCI_SOFTCAR	0x04		/* soft carrier */

int	apcimatch(struct device *, void *, void *);
void	apciattach(struct device *, struct device *, void *);

struct cfattach apci_ca = {
	sizeof(struct apci_softc), apcimatch, apciattach
};

struct cfdriver apci_cd = {
	NULL, "apci", DV_TTY
};

int	apciintr(void *);
void	apcieint(struct apci_softc *, int);
void	apcimint(struct apci_softc *, u_char);
int	apciparam(struct tty *, struct termios *);
void	apcistart(struct tty *);
int	apcimctl(struct apci_softc *, int, int);
void	apcitimeout(void *);

cdev_decl(apci);

#define	APCIUNIT(x)	(minor(x) & 0x7f)
#define APCICUA(x)	(minor(x) & 0x80)

int	apcidefaultrate = TTYDEF_SPEED;

/*
 * Console support.
 */
struct apciregs *apci_cn = NULL;	/* console hardware */
int	apciconsinit;			/* has been initialized */
int	apcimajor;			/* our major number */

cons_decl(apci);

int
apcimatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct frodo_attach_args *fa = aux;

	/* Looking for an apci? */
	if (strcmp(fa->fa_name, apci_cd.cd_name) != 0)
		return (0);

	/* Are we checking a valid APCI offset? */
	switch (fa->fa_offset) {
	case FRODO_APCI_OFFSET(1):
	case FRODO_APCI_OFFSET(2):
	case FRODO_APCI_OFFSET(3):
		/* Yup, we exist! */
		return (1);
	}

	return (0);
}

void
apciattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct apci_softc *sc = (struct apci_softc *)self;
	struct apciregs *apci;
	struct frodo_attach_args *fa = aux;

	sc->sc_apci = apci =
	    (struct apciregs *)IIOV(FRODO_BASE + fa->fa_offset);
	sc->sc_flags = 0;

	/* Initialize timeout structure */
	timeout_set(&sc->sc_timeout, apcitimeout, sc);

	/* Are we the console? */
	if (apci == apci_cn) {
		sc->sc_flags |= APCI_ISCONSOLE;
		delay(100000);

		/*
		 * We didn't know which unit this would be during
		 * the console probe, so we have to fixup cn_dev here.
		 */
		cn_tab->cn_dev = makedev(apcimajor, self->dv_unit);
	}

	/* Look for a FIFO. */
	apci->ap_fifo = FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_14;
	delay(100);
	if ((apci->ap_iir & IIR_FIFO_MASK) == IIR_FIFO_MASK)
		sc->sc_flags |= APCI_HASFIFO;

	/* Establish our interrupt handler. */
	sc->sc_isr.isr_func = apciintr;
	sc->sc_isr.isr_arg = sc;
	sc->sc_isr.isr_priority = IPL_TTY;
	frodo_intr_establish(parent, fa->fa_line, &sc->sc_isr, self->dv_xname);

	/* Set soft carrier if requested by operator. */
	if (self->dv_cfdata->cf_flags)
		sc->sc_flags |= APCI_SOFTCAR;

	/*
	 * Need to reset baud rate, etc. of next print, so reset apciconsinit.
	 * Also make sure console is always "hardwired".
	 */
	if (sc->sc_flags & APCI_ISCONSOLE) {
		apciconsinit = 0;
		sc->sc_flags |= APCI_SOFTCAR;
		printf(": console, ");
	} else
		printf(": ");

	if (sc->sc_flags & APCI_HASFIFO)
		printf("working fifo\n");
	else
		printf("no fifo\n");
}

/* ARGSUSED */
int
apciopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = APCIUNIT(dev);
	struct apci_softc *sc;
	struct tty *tp;
	struct apciregs *apci;
	u_char code;
	int s, error = 0;

	if (unit >= apci_cd.cd_ndevs ||
	    (sc = apci_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	apci = sc->sc_apci;

	s = spltty();
	if (sc->sc_tty == NULL) {
		tp = sc->sc_tty = ttymalloc(0);
	} else
		tp = sc->sc_tty;
	splx(s);

	tp->t_oproc = apcistart;
	tp->t_param = apciparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		/*
		 * Sanity clause: reset the chip on first open.
		 * The chip might be left in an inconsistent state
		 * if it is read inadventently.
		 */
		apciinit(apci, apcidefaultrate, CFCR_8BITS);

		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = apcidefaultrate;

		s = spltty();

		apciparam(tp, &tp->t_termios);
		ttsetwater(tp);

		/* Set the FIFO threshold based on the receive speed. */
		if (sc->sc_flags & APCI_HASFIFO)
			apci->ap_fifo = FIFO_ENABLE | FIFO_RCV_RST |
			    FIFO_XMT_RST |
			    (tp->t_ispeed <= 1200 ? FIFO_TRIGGER_1 :
			    FIFO_TRIGGER_14);

		/* Flush any pending I/O. */
		while ((apci->ap_iir & IIR_IMASK) == IIR_RXRDY)
			code = apci->ap_data;
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0)
		return (EBUSY);
	else
		s = spltty();

	/* Set the modem control state. */
	(void) apcimctl(sc, MCR_DTR | MCR_RTS, DMSET);

	/* Set soft-carrier if so configured. */
	if ((sc->sc_flags & APCI_SOFTCAR) || APCICUA(dev) ||
	    (apcimctl(sc, 0, DMGET) & MSR_DCD))
		tp->t_state |= TS_CARR_ON;

	if (APCICUA(dev)) {
		if (tp->t_state & TS_ISOPEN) {
			/* Ah, but someone already is dialed in... */
			splx(s);
			return (EBUSY);
		}
		sc->sc_cua = 1;		/* We go into CUA mode */
	}

	/* Wait for carrier if necessary. */
	if (flag & O_NONBLOCK) {
		if (!APCICUA(dev) && sc->sc_cua) {
			/* Opening TTY non-blocking... but the CUA is busy */
			splx(s);
			return (EBUSY);
		}
	} else {
		while (sc->sc_cua ||
		    ((tp->t_cflag & CLOCAL) == 0 &&
		    (tp->t_state & TS_CARR_ON) == 0)) {
			tp->t_state |= TS_WOPEN;
			error = ttysleep(tp, (caddr_t)&tp->t_rawq,
			    TTIPRI | PCATCH, ttopen, 0);
			if (!APCICUA(dev) && sc->sc_cua && error == EINTR)
				continue;
			if (error) {
				if (APCICUA(dev))
					sc->sc_cua = 0;
				splx(s);
				return (error);
			}
			if (!APCICUA(dev) && sc->sc_cua)
				continue;
		}
	}

	splx(s);

	if (error == 0)
		error = (*linesw[tp->t_line].l_open)(dev, tp, p);

	if (error == 0) {
		/* clear errors, start timeout */
		sc->sc_ferr = sc->sc_perr = sc->sc_oflow = sc->sc_toterr = 0;
		timeout_add_sec(&sc->sc_timeout, 1);
	}

	return (error);
}

/* ARGSUSED */
int
apciclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct apci_softc *sc;
	struct tty *tp;
	struct apciregs *apci;
	int unit = APCIUNIT(dev);
	int s;

	sc = apci_cd.cd_devs[unit];
	apci = sc->sc_apci;
	tp = sc->sc_tty;

	(*linesw[tp->t_line].l_close)(tp, flag, p);

	s = spltty();

	apci->ap_cfcr &= ~CFCR_SBREAK;
	apci->ap_ier = 0;
	if (tp->t_cflag & HUPCL && (sc->sc_flags & APCI_SOFTCAR) == 0) {
		/* XXX perhaps only clear DTR */
		(void) apcimctl(sc, 0, DMSET);
	}
	tp->t_state &= ~(TS_BUSY | TS_FLUSH);
	sc->sc_cua = 0;
	splx(s);
	ttyclose(tp);
#if 0
	ttyfree(tp);
	sc->sc_tty = NULL;
#endif
	return (0);
}

int
apciread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct apci_softc *sc = apci_cd.cd_devs[APCIUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
apciwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct apci_softc *sc = apci_cd.cd_devs[APCIUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
apcitty(dev)
	dev_t dev;
{
	struct apci_softc *sc = apci_cd.cd_devs[APCIUNIT(dev)];

	return (sc->sc_tty);
}

int
apciintr(arg)
	void *arg;
{
	struct apci_softc *sc = arg;
	struct apciregs *apci = sc->sc_apci;
	struct tty *tp = sc->sc_tty;
	u_char iir, lsr, c;
	int iflowdone = 0, claimed = 0;

#define	RCVBYTE() \
	c = apci->ap_data; \
	if (tp != NULL && (tp->t_state & TS_ISOPEN) != 0) \
		(*linesw[tp->t_line].l_rint)(c, tp)

	for (;;) {
		iir = apci->ap_iir;	/* get UART status */

		switch (iir & IIR_IMASK) {
		case IIR_RLS:
			apcieint(sc, apci->ap_lsr);
			break;

		case IIR_RXRDY:
		case IIR_RXTOUT:
			RCVBYTE();
			if (sc->sc_flags & APCI_HASFIFO) {
				while ((lsr = apci->ap_lsr) & LSR_RCV_MASK) {
					if (lsr == LSR_RXRDY) {
						RCVBYTE();
					} else
						apcieint(sc, lsr);
				}
			}
			if (iflowdone == 0 && tp != NULL &&
			    (tp->t_cflag & CRTS_IFLOW) &&
			    tp->t_rawq.c_cc > (TTYHOG(tp) / 2)) {
				apci->ap_mcr &= ~MCR_RTS;
				iflowdone = 1;
			}
			break;

		case IIR_TXRDY:
			if (tp != NULL) {
				tp->t_state &=~ (TS_BUSY|TS_FLUSH);
				if (tp->t_line)
					(*linesw[tp->t_line].l_start)(tp);
				else
					apcistart(tp);
			}
			break;

		default:
			if (iir & IIR_NOPEND)
				return (claimed);
			log(LOG_WARNING, "%s: weird interrupt: 0x%x\n",
			    sc->sc_dev.dv_xname, iir);
			/* FALLTHROUGH */

		case IIR_MLSC:
			apcimint(sc, apci->ap_msr);
			break;
		}

		claimed = 1;
	}
}

void
apcieint(sc, stat)
	struct apci_softc *sc;
	int stat;
{
	struct tty *tp = sc->sc_tty;
	struct apciregs *apci = sc->sc_apci;
	int c;

	c = apci->ap_data;

#ifdef DDB
	if ((sc->sc_flags & APCI_ISCONSOLE) && db_console && (stat & LSR_BI)) {
		Debugger();
		return;
	}
#endif

	if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0)
		return;

	if (stat & (LSR_BI | LSR_FE)) {
		c |= TTY_FE;
		sc->sc_ferr++;
	} else if (stat & LSR_PE) {
		c |= TTY_PE;
		sc->sc_perr++;
	} else if (stat & LSR_OE)
		sc->sc_oflow++;
	(*linesw[tp->t_line].l_rint)(c, tp);
}

void
apcimint(sc, stat)
	struct apci_softc *sc;
	u_char stat;
{
	struct tty *tp = sc->sc_tty;
	struct apciregs *apci = sc->sc_apci;

	if (tp == NULL)
		return;

	if ((stat & MSR_DDCD) &&
	    (sc->sc_flags & APCI_SOFTCAR) == 0) {
		if (stat & MSR_DCD)
			(void)(*linesw[tp->t_line].l_modem)(tp, 1);
		else if ((*linesw[tp->t_line].l_modem)(tp, 0) == 0)
			apci->ap_mcr &= ~(MCR_DTR | MCR_RTS);
	}

	/*
	 * CTS change.
	 * If doing HW output flow control, start/stop output as appropriate.
	 */
	if ((stat & MSR_DCTS) &&
	    (tp->t_state & TS_ISOPEN) && (tp->t_cflag & CCTS_OFLOW)) {
		if (stat & MSR_CTS) {
			tp->t_state &=~ TS_TTSTOP;
			apcistart(tp);
		} else
			tp->t_state |= TS_TTSTOP;
	}
}

int
apciioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct apci_softc *sc = apci_cd.cd_devs[APCIUNIT(dev)];
	struct tty *tp = sc->sc_tty;
	struct apciregs *apci = sc->sc_apci;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		apci->ap_cfcr |= CFCR_SBREAK;
		break;

	case TIOCCBRK:
		apci->ap_cfcr &= ~CFCR_SBREAK;
		break;

	case TIOCSDTR:
		(void) apcimctl(sc, MCR_DTR | MCR_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) apcimctl(sc, MCR_DTR | MCR_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) apcimctl(sc, *(int *)data, DMSET);
		break;

	case TIOCMBIS:
		(void) apcimctl(sc, *(int *)data, DMBIS);
		break;

	case TIOCMBIC:
		(void) apcimctl(sc, *(int *)data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = apcimctl(sc, 0, DMGET);
		break;

	case TIOCGFLAGS: {
		int bits = 0;

		if (sc->sc_flags & APCI_SOFTCAR)
			bits |= TIOCFLAG_SOFTCAR;

		if (tp->t_cflag & CLOCAL)
			bits |= TIOCFLAG_CLOCAL;

		*(int *)data = bits;
		break;
	}

	case TIOCSFLAGS: {
		int userbits;

		error = suser(p, 0);
		if (error)
			return (EPERM);

		userbits = *(int *)data;

		if ((userbits & TIOCFLAG_SOFTCAR) ||
		    (sc->sc_flags & APCI_ISCONSOLE))
			sc->sc_flags |= APCI_SOFTCAR;

		if (userbits & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;

		break;
	}

	default:
		return (ENOTTY);
	}
	return (0);
}

int
apciparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct apci_softc *sc = apci_cd.cd_devs[APCIUNIT(tp->t_dev)];
	struct apciregs *apci = sc->sc_apci;
	int cfcr, cflag = t->c_cflag;
	int ospeed = ttspeedtab(t->c_ospeed, apcispeedtab);
	int s;

	/* check requested parameters */
	if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed))
		return (EINVAL);

	switch (cflag & CSIZE) {
	case CS5:
		cfcr = CFCR_5BITS;
		break;

	case CS6:
		cfcr = CFCR_6BITS;
		break;

	case CS7:
		cfcr = CFCR_7BITS;
		break;

	case CS8:
	default:	/* XXX gcc whines about cfcr being uninitialized... */
		cfcr = CFCR_8BITS;
		break;
	}
	if (cflag & PARENB) {
		cfcr |= CFCR_PENAB;
		if ((cflag & PARODD) == 0)
			cfcr |= CFCR_PEVEN;
	}
	if (cflag & CSTOPB)
		cfcr |= CFCR_STOPB;

	s = spltty();

	if (ospeed == 0)
		(void) apcimctl(sc, 0, DMSET);	/* hang up line */

	/*
	 * Set the FIFO threshold based on the receive speed, if we
	 * are changing it.
	 */
	if (tp->t_ispeed != t->c_ispeed) {
		if (sc->sc_flags & APCI_HASFIFO)
			apci->ap_fifo = FIFO_ENABLE |
			    (t->c_ispeed <= 1200 ? FIFO_TRIGGER_1 :
			    FIFO_TRIGGER_14);
	}

	if (ospeed != 0) {
		apci->ap_cfcr |= CFCR_DLAB;
		apci->ap_data = ospeed & 0xff;
		apci->ap_ier = (ospeed >> 8) & 0xff;
		apci->ap_cfcr = cfcr;
	} else
		apci->ap_cfcr = cfcr;

	/* and copy to tty */
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = cflag;

	apci->ap_ier = IER_ERXRDY | IER_ETXRDY | IER_ERLS | IER_EMSC;

	splx(s);
	return (0);
}

void
apcistart(tp)
	struct tty *tp;
{
	struct apci_softc *sc = apci_cd.cd_devs[APCIUNIT(tp->t_dev)];
	struct apciregs *apci = sc->sc_apci;
	int s, c;

	s = spltty();

	if (tp->t_state & (TS_TIMEOUT|TS_TTSTOP))
		goto out;
	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto out;
	if (apci->ap_lsr & LSR_TXRDY) {
		tp->t_state |= TS_BUSY;
		if (sc->sc_flags & APCI_HASFIFO) {
			for (c = 0; c < 16 && tp->t_outq.c_cc; ++c)
				apci->ap_data = getc(&tp->t_outq);
		} else
			apci->ap_data = getc(&tp->t_outq);
	}

 out:
	splx(s);
}

/*
 * Stop output on a line.
 */
/* ARGSUSED */
int
apcistop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY)
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	splx(s);
	return (0);
}

int
apcimctl(sc, bits, how)
	struct apci_softc *sc;
	int bits, how;
{
	struct apciregs *apci = sc->sc_apci;
	int s;

	s = spltty();

	switch (how) {
	case DMSET:
		apci->ap_mcr = bits;
		break;

	case DMBIS:
		apci->ap_mcr |= bits;
		break;

	case DMBIC:
		apci->ap_mcr &= ~bits;
		break;

	case DMGET:
		bits = apci->ap_msr;
		break;
	}

	splx(s);
	return (bits);
}

void
apcitimeout(arg)
	void *arg;
{
	struct apci_softc *sc = arg;
	int ferr, perr, oflow, s;

	if (sc->sc_tty == NULL ||
	    (sc->sc_tty->t_state & TS_ISOPEN) == 0)
		return;

	/* Log any errors. */
	if (sc->sc_ferr || sc->sc_perr || sc->sc_oflow) {
		s = spltty();	/* XXX necessary? */
		ferr = sc->sc_ferr;
		perr = sc->sc_perr;
		oflow = sc->sc_oflow;
		sc->sc_ferr = sc->sc_perr = sc->sc_oflow = 0;
		splx(s);
		sc->sc_toterr += ferr + perr + oflow;
		log(LOG_WARNING,
		    "%s: %d frame, %d parity, %d overflow, %d total errors\n",
		    sc->sc_dev.dv_xname, ferr, perr, oflow, sc->sc_toterr);
	}

	timeout_add_sec(&sc->sc_timeout, 1);
}

/*
 * The following routines are required for the APCI to act as the console.
 */

void
apcicnprobe(cp)
	struct consdev *cp;
{
	volatile u_int8_t *frodoregs;

	/* locate the major number */
	for (apcimajor = 0; apcimajor < nchrdev; apcimajor++)
		if (cdevsw[apcimajor].d_open == apciopen)
			break;

	/* initialize the required fields */
	cp->cn_dev = makedev(apcimajor, 0);	/* XXX */

	/*
	 * The APCI can only be a console on a 425e; on other 4xx
	 * models, the "first" serial port is mapped to the DCA
	 * at select code 9.  See frodo.c for the autoconfiguration
	 * version of this check.
	 */
	if (machineid != HP_425 || mmuid != MMUID_425_E)
		return;

	/*
	 * Check the service switch. On the 425e, this is a physical
	 * switch, unlike other frodo-based machines, so we can use it
	 * as a serial vs internal video selector, since the PROM can not
	 * be configured for serial console.
	 */
	frodoregs = (volatile u_int8_t *)IIOV(FRODO_BASE);
	if (badaddr((caddr_t)frodoregs) == 0 &&
	    !ISSET(frodoregs[FRODO_IISR], FRODO_IISR_SERVICE))
		cp->cn_pri = CN_HIGHPRI;
	else
		cp->cn_pri = CN_LOWPRI;

	/*
	 * If our priority is higher than the currently-remembered
	 * console, install ourselves.
	 */
	if (cn_tab == NULL || cp->cn_pri > cn_tab->cn_pri) {
		cn_tab = cp;
		conscode = CONSCODE_INVALID;
	}
}

/* ARGSUSED */
void
apcicninit(cp)
	struct consdev *cp;
{

	/*
	 * We are not interested by the second console pass.
	 */
	if (consolepass != 0)
		return;

	apci_cn = (struct apciregs *)IIOV(FRODO_BASE + FRODO_APCI_OFFSET(1));
	apciinit(apci_cn, apcidefaultrate, CFCR_8BITS);
	apciconsinit = 1;
}

/* ARGSUSED */
int
apcicngetc(dev)
	dev_t dev;
{
	u_char stat;
	int c, s;

	s = splhigh();
	while (((stat = apci_cn->ap_lsr) & LSR_RXRDY) == 0)
		;
	c = apci_cn->ap_data;

	/* clear any interrupts generated by this transmission */
	stat = apci_cn->ap_iir;
	splx(s);
	return (c);
}

/* ARGSUSED */
void
apcicnputc(dev, c)
	dev_t dev;
	int c;
{
	int timo;
	u_char stat;
	int s;

	s = splhigh();

	if (apciconsinit == 0) {
		apciinit(apci_cn, apcidefaultrate, CFCR_8BITS);
		apciconsinit = 1;
	}

	/* wait for any pending transmission to finish */
	timo = 50000;
	while (((stat = apci_cn->ap_lsr) & LSR_TXRDY) == 0 && --timo)
		;

	apci_cn->ap_data = c & 0xff;

	/* wait for this transmission to complete */
	timo = 1500000;
	while (((stat = apci_cn->ap_lsr) & LSR_TXRDY) == 0 && --timo)
		;

	/* clear any interrupts generated by this transmission */
	stat = apci_cn->ap_iir;
	splx(s);
}
@


1.41
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.40 2010/06/30 18:10:47 miod Exp $	*/
@


1.40
log
@Make this compile after TTYHOG definition change (but the logic should be fixed
to not depend on it).
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.39 2010/06/28 14:13:27 deraadt Exp $	*/
d765 3
a767 9
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
		if (tp->t_outq.c_cc == 0)
			goto out;
	}
@


1.39
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.38 2010/04/12 12:57:51 tedu Exp $	*/
d489 1
a489 1
			    tp->t_rawq.c_cc > (TTYHOG / 2)) {
@


1.38
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.37 2009/11/09 17:53:38 nicm Exp $	*/
d279 1
a279 1
		tp = sc->sc_tty = ttymalloc();
@


1.37
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.36 2009/11/01 20:29:00 nicm Exp $	*/
d371 1
a371 1
		error = (*linesw[tp->t_line].l_open)(dev, tp);
d399 1
a399 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.36
log
@Call selwakeup()/KNOTE() even if the queue has emptied completely.

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.35 2009/10/31 12:00:05 fgsch Exp $	*/
a770 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.35
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.34 2009/10/31 06:40:16 deraadt Exp $	*/
d770 2
a773 2
		selwakeup(&tp->t_wsel);
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.34
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.33 2008/10/15 19:12:19 blambert Exp $	*/
d319 1
a319 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
@


1.33
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.32 2008/06/26 05:42:10 ray Exp $	*/
d773 1
@


1.32
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.31 2008/01/23 16:37:56 jsing Exp $	*/
d376 1
a376 1
		timeout_add(&sc->sc_timeout, hz);
d863 1
a863 1
	timeout_add(&sc->sc_timeout, hz);
@


1.31
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.30 2007/11/09 17:32:25 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.30
log
@Get rid of IPL_TTYNOBUF, it was handled exactly like IPL_TTY for years.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.29 2007/01/06 20:09:12 miod Exp $	*/
d909 1
a909 1
		cp->cn_pri = CN_REMOTE;
d911 1
a911 1
		cp->cn_pri = CN_NORMAL;
@


1.29
log
@Propagate bus_space_tag_t through device attachment args structures, rather
than having them build their own. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.28 2006/01/01 11:59:37 miod Exp $	*/
d240 1
a240 2
	sc->sc_isr.isr_priority =
	    (sc->sc_flags & APCI_HASFIFO) ? IPL_TTY : IPL_TTYNOBUF;
@


1.28
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.27 2005/12/30 18:14:09 miod Exp $	*/
d106 1
@


1.27
log
@Kill conforced, and have console devices use CN_FORCED priority instead.
This means we are no longer aborting the console scans even if the final
console has been found, but on the other hand makes some logic simpler;
plus it will be necessary for upcoming scode vs device loop order reversal.
No user-visible change.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.26 2005/12/30 18:03:33 miod Exp $	*/
a889 1
	cp->cn_pri = CN_DEAD;
@


1.26
log
@When a driver claims console, let it set conscode to itself, instead of
letting the bus walkers do this for it. This is necessary since apci does
not use the bus walkers, now that we do not force console probes to stop
when apci claims console.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.25 2005/12/28 21:37:34 miod Exp $	*/
a890 4

	/* Abort early if console is already forced. */
	if (conforced)
		return;
@


1.25
log
@...thus no need to override conscode if we are configured as console, so that
kernels with hardcoded CONSCODE value can run as advertized regardless of the
service switch position.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.24 2005/12/28 21:12:37 miod Exp $	*/
d922 1
a922 1
	if (((cn_tab == NULL) || (cp->cn_pri > cn_tab->cn_pri)))
d924 2
@


1.24
log
@Setting the service switch on 425e to select serial console shall not be
considered as forcing the console, but as a normal remote console selection.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.23 2005/04/22 11:59:11 miod Exp $	*/
d913 1
a913 1
	    !ISSET(frodoregs[FRODO_IISR], FRODO_IISR_SERVICE)) {
d915 1
a915 2
		conscode = -2;			/* XXX */
	} else {
a916 1
	}
@


1.23
log
@Driver for the Apollo Domain keyboard and mouse, for the HP 9000/4xx series.

Claims the console keyboard if a keyboard is detected at boot time,
otherwise HIL is preferred (but due to wsmux both can be used simultaneously).
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.22 2005/02/27 22:08:39 miod Exp $	*/
a914 1
		conforced = 1;
d924 1
a924 1
	if (((cn_tab == NULL) || (cp->cn_pri > cn_tab->cn_pri)) || conforced)
@


1.22
log
@Invoke hp300_cninit() twice, with a global variable letting the
console-dependent routines know which pass they are being invoked in.

The first pass is the usual console detection code. The second pass runs
after uvm is initialized, and will allow devices which need VM services to
run to claim the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.20 2005/02/14 00:52:09 miod Exp $	*/
d118 1
a160 1
void	apciinit(struct apciregs *, int);
a169 20
const struct speedtab apcispeedtab[] = {
	{ 0,		0		},
	{ 50,		APCIBRD(50)	},
	{ 75,		APCIBRD(75)	},
	{ 110,		APCIBRD(110)	},
	{ 134,		APCIBRD(134)	},
	{ 150,		APCIBRD(150)	},
	{ 200,		APCIBRD(200)	},
	{ 300,		APCIBRD(300)	},
	{ 600,		APCIBRD(600)	},
	{ 1200,		APCIBRD(1200)	},
	{ 1800,		APCIBRD(1800)	},
	{ 2400,		APCIBRD(2400)	},
	{ 4800,		APCIBRD(4800)	},
	{ 9600,		APCIBRD(9600)	},
	{ 19200,	APCIBRD(19200)	},
	{ 38400,	APCIBRD(38400)	},
	{ -1,		-1		},
};

d301 1
a301 1
		apciinit(apci, apcidefaultrate);
a845 25
apciinit(apci, rate)
	struct apciregs *apci;
	int rate;
{
	int s;
	short stat;

	s = splhigh();

	rate = ttspeedtab(rate, apcispeedtab);

	apci->ap_cfcr = CFCR_DLAB;
	apci->ap_data = rate & 0xff;
	apci->ap_ier = (rate >> 8) & 0xff;
	apci->ap_cfcr = CFCR_8BITS;
	apci->ap_ier = IER_ERXRDY | IER_ETXRDY;
	apci->ap_fifo =
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_1;
	apci->ap_mcr = MCR_DTR | MCR_RTS;
	delay(100);
	stat = apci->ap_iir;
	splx(s);
}

void
d942 1
a942 1
	apciinit(apci_cn, apcidefaultrate);
d978 1
a978 1
		apciinit(apci_cn, apcidefaultrate);
@


1.21
log
@Decide whether to force serial console on the 425e based upon the service
switch, which is a physical switch on this model, unlike other frodo-based
hp300.

Service mode will now select serial console, while normal mode will select
graphics console.
@
text
@d980 6
@


1.20
log
@Behave correctly in interrupt handlers if no tty has been allocated yet.
Prevents monkeys pounding on your serial terminal from panicing your kernel
before getty gets spawned on the serial ports.

dcm(4) looks safe from this problem from code inspection.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.19 2005/02/12 18:01:08 miod Exp $	*/
d926 1
d950 15
a964 7
#ifdef APCI_FORCE_CONSOLE
	cp->cn_pri = CN_REMOTE;
	conforced = 1;
	conscode = -2;			/* XXX */
#else
	cp->cn_pri = CN_NORMAL;
#endif
@


1.19
log
@Use cons_decl() instead of rolling our own prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.18 2005/01/15 21:13:08 miod Exp $	*/
d492 1
a492 1
	if ((tp->t_state & TS_ISOPEN) != 0) \
d514 2
a515 1
			if (iflowdone == 0 && (tp->t_cflag & CRTS_IFLOW) &&
d523 7
a529 5
			tp->t_state &=~ (TS_BUSY|TS_FLUSH);
			if (tp->t_line)
				(*linesw[tp->t_line].l_start)(tp);
			else
				apcistart(tp);
d537 1
a537 1
			/* fall through */
a557 2
	if ((tp->t_state & TS_ISOPEN) == 0)
		return;
d566 3
d587 3
@


1.18
log
@Kill whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.17 2004/09/29 07:35:52 miod Exp $	*/
d197 1
a197 5
void	apcicnprobe(struct consdev *);
void	apcicninit(struct consdev *);
int	apcicngetc(dev_t);
void	apcicnputc(dev_t, int);

@


1.17
log
@Switch hp300 to evcount.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.16 2004/09/19 21:34:42 mickey Exp $	*/
d40 1
a40 1
/*      
d45 1
a45 1
 * Redistribution and use in source and binary forms, with or without  
d56 1
a56 1
 *      
d102 3
a104 3
#include <sys/device.h>       
#include <sys/timeout.h>       
    
d371 1
a371 1
		
@


1.16
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.15 2003/10/03 16:44:49 miod Exp $	*/
d126 1
d261 5
a265 2
	frodo_intr_establish(parent, apciintr, sc, fa->fa_line,
	    (sc->sc_flags & APCI_HASFIFO) ? IPL_TTY : IPL_TTYNOBUF);
@


1.15
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.14 2003/08/15 20:32:12 tedu Exp $	*/
d169 1
a169 1
struct speedtab apcispeedtab[] = {
@


1.14
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.13 2003/06/04 22:08:12 deraadt Exp $	*/
a306 1
		tty_attach(tp);
a440 1
	tty_detach(tp);
@


1.13
log
@Delete UCB term 3.  When there are other copyright owners, we affirm
that we can see no legal situation under which they could require that
term to remain (ie. This is equivelant to us taking the old UCB file,
removing term 3 as specified by UCB, then re-applying each diff
afterwards from the various authors)
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.12 2002/03/14 01:26:30 millert Exp $	*/
d677 1
a677 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.11 2001/09/23 07:05:06 millert Exp $	*/
d53 1
a53 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@For serial console, drop into ddb on <break> if ddb.console is nonzero
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.10 2001/06/27 05:44:45 nate Exp $	*/
d146 2
a147 2
int	apcimatch __P((struct device *, void *, void *));
void	apciattach __P((struct device *, struct device *, void *));
d157 8
a164 8
int	apciintr __P((void *));
void	apcieint __P((struct apci_softc *, int));
void	apcimint __P((struct apci_softc *, u_char));
int	apciparam __P((struct tty *, struct termios *));
void	apcistart __P((struct tty *));
int	apcimctl __P((struct apci_softc *, int, int));
void	apciinit __P((struct apciregs *, int));
void	apcitimeout __P((void *));
d200 4
a203 4
void	apcicnprobe __P((struct consdev *));
void	apcicninit __P((struct consdev *));
int	apcicngetc __P((dev_t));
void	apcicnputc __P((dev_t, int));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.11 2001/09/23 07:05:06 millert Exp $	*/
d146 2
a147 2
int	apcimatch(struct device *, void *, void *);
void	apciattach(struct device *, struct device *, void *);
d157 8
a164 8
int	apciintr(void *);
void	apcieint(struct apci_softc *, int);
void	apcimint(struct apci_softc *, u_char);
int	apciparam(struct tty *, struct termios *);
void	apcistart(struct tty *);
int	apcimctl(struct apci_softc *, int, int);
void	apciinit(struct apciregs *, int);
void	apcitimeout(void *);
d200 4
a203 4
void	apcicnprobe(struct consdev *);
void	apcicninit(struct consdev *);
int	apcicngetc(dev_t);
void	apcicnputc(dev_t, int);
@


1.10
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.9 2001/05/10 22:29:38 millert Exp $	*/
d124 4
d563 7
@


1.9
log
@Don't play with MCR_IEN, it breaks serial console input on the 425e.
If it turns out that this causes problems on other 4xx models this
can be added back for the non-425e models.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.8 2001/05/10 20:18:46 millert Exp $	*/
d739 1
a739 1
	 * Set the FIFO threshold based on the recieve speed, if we
@


1.8
log
@In apciparam() in the ospeed == 0 case, actually set the cfcr to the new
value; bad@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.4 2001/05/01 16:51:08 millert Exp $	*/
a762 1
	apci->ap_mcr |= MCR_IEN;
a828 8
	/*
	 * Always make sure MCR_IEN is set (unless setting to 0)
	 */
	if (how == DMBIS || (how == DMSET && bits))
		bits |= MCR_IEN;
	else if (how == DMBIC)
		bits &= ~MCR_IEN;

d976 2
@


1.7
log
@Skip "serial 1" on non-425e models.  It's mapped to DCA at 9 on every
other 4xx model, and the "not configured" could be pretty annoying.
This means we can nuke apcicheckdca() and just key off being a 425e.
Also, ia->ia_addr is a physical address, not a kernel virtual address;
thorpej@@netbsd.org
@
text
@d755 1
a755 1
		apci->ap_cfcr;
@


1.6
log
@When acpi is used as the console, set cn_tab appropriately so that a
serial console on the 425e gets attached properly.
The hp300 port should really be changed such that drivers don't
touch cn_tab themselves but this turns out to be a bit tricky so
I'm going to punt on that for now.
@
text
@d1 38
a38 2
/*	$OpenBSD: apci.c,v 1.5 2001/05/10 01:43:31 millert Exp $	*/
/*	$NetBSD: apci.c,v 1.1 1997/05/12 08:12:36 thorpej Exp $	*/
a41 1
 * Copyright (c) 1995, 1996, 1997 Jason R. Thorpe.  All rights reserved.
a161 2
int	apcicheckdca __P((void));

d218 2
a219 3
		break;
	default:
		return (0);
d222 1
a222 5
	/* Make sure there's not a DCA in the way. */
	if (fa->fa_offset == FRODO_APCI_OFFSET(1) && apcicheckdca())
		return (0);

	return (1);
d259 1
a259 1
	/* Establish out interrupt handler. */
a914 39
int
apcicheckdca()
{
	caddr_t va;
	int rv = 0;

	/*
	 * On systems that also have a dca at select code 9, we
	 * cannot use the second UART, as it is mapped to select
	 * code 9 by the firmware.  We check for this by mapping
	 * select code 9 and checking for a dca.  Yuck.
	 */
	va = iomap(dio_scodetopa(9), NBPG);
	if (va == NULL) {
		printf("apcicheckdca: can't map scode 9!\n");
		return (1);	/* Safety. */
	}

	/* Check for hardware. */
	if (badaddr(va)) {
		/* Nothing there, assume APCI. */
		goto unmap;
	}

	/* Check DIO ID against DCA IDs. */
	switch (DIO_ID(va)) {
	case DIO_DEVICE_ID_DCA0:
	case DIO_DEVICE_ID_DCA0REM:
	case DIO_DEVICE_ID_DCA1:
	case DIO_DEVICE_ID_DCA1REM:
		rv = 1;
	}
 unmap:
	iounmap(va, NBPG);

	return (rv);
}


d937 7
a943 8
	/* These can only exist on 400-series machines. */
	switch (machineid) {
	case HP_400:
	case HP_425:
	case HP_433:
		break;

	default:
a944 1
	}
a945 2
	/* Make sure a DCA isn't in the way. */
	if (apcicheckdca() == 0) {
d947 3
a949 3
		cp->cn_pri = CN_REMOTE;
		conforced = 1;
		conscode = -2;			/* XXX */
d951 1
a951 1
		cp->cn_pri = CN_NORMAL;
d953 7
a959 8
		/*
		 * If our priority is higher than the currently-remembered
		 * console, install ourselves.
		 */
		if (((cn_tab == NULL) || (cp->cn_pri > cn_tab->cn_pri)) ||
		    conforced)
			cn_tab = cp;
	}
@


1.5
log
@Move the timeout_set() call up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.4 2001/05/01 16:51:08 millert Exp $	*/
d968 7
@


1.4
log
@convert to new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.3 1997/09/14 03:43:01 downsj Exp $	*/
d210 3
a233 3

	/* Initialize timeout structure */
	timeout_set(&sc->sc_timeout, apcitimeout, sc);
@


1.3
log
@callout support sync, from Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.2 1997/07/14 04:25:12 downsj Exp $	*/
d72 1
d93 1
d232 3
d376 1
a376 1
		timeout(apcitimeout, sc, hz);
d884 1
a884 1
	timeout(apcitimeout, sc, hz);
@


1.3.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 38
/*	$OpenBSD$	*/
/*	$NetBSD: apci.c,v 1.9 2000/11/02 00:35:05 eeh Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d6 1
a71 1
#include <sys/timeout.h>       
a91 1
	struct	timeout sc_timeout;	/* timeout */
d125 2
d183 3
a185 2
		/* Yup, we exist! */
		return (1);
d188 5
a192 1
	return (0);
a207 3
	/* Initialize timeout structure */
	timeout_set(&sc->sc_timeout, apcitimeout, sc);

d226 1
a226 1
	/* Establish our interrupt handler. */
d371 1
a371 1
		timeout_add(&sc->sc_timeout, hz);
d706 1
a706 1
	 * Set the FIFO threshold based on the receive speed, if we
d722 1
a722 1
		apci->ap_cfcr = cfcr;
d730 1
d797 8
d879 39
a917 1
	timeout_add(&sc->sc_timeout, hz);
d920 1
d943 8
a950 7
	/*
	 * The APCI can only be a console on a 425e; on other 4xx
	 * models, the "first" serial port is mapped to the DCA
	 * at select code 9.  See frodo.c for the autoconfiguration
	 * version of this check.
	 */
	if (machineid != HP_425 || mmuid != MMUID_425_E)
d952 1
d954 2
d957 3
a959 3
	cp->cn_pri = CN_REMOTE;
	conforced = 1;
	conscode = -2;			/* XXX */
d961 1
a961 1
	cp->cn_pri = CN_NORMAL;
d963 1
a963 7

	/*
	 * If our priority is higher than the currently-remembered
	 * console, install ourselves.
	 */
	if (((cn_tab == NULL) || (cp->cn_pri > cn_tab->cn_pri)) || conforced)
		cn_tab = cp;
a988 2

	/* clear any interrupts generated by this transmission */
@


1.3.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.3.12.1 2001/07/04 10:15:25 niklas Exp $	*/
a123 4
#ifdef DDB
#include <ddb/db_var.h>
#endif

a558 7

#ifdef DDB
	if ((sc->sc_flags & APCI_ISCONSOLE) && db_console && (stat & LSR_BI)) {
		Debugger();
		return;
	}
#endif
@


1.3.12.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 2
a147 2
int	apcimatch(struct device *, void *, void *);
void	apciattach(struct device *, struct device *, void *);
d157 8
a164 8
int	apciintr(void *);
void	apcieint(struct apci_softc *, int);
void	apcimint(struct apci_softc *, u_char);
int	apciparam(struct tty *, struct termios *);
void	apcistart(struct tty *);
int	apcimctl(struct apci_softc *, int, int);
void	apciinit(struct apciregs *, int);
void	apcitimeout(void *);
d200 4
a203 4
void	apcicnprobe(struct consdev *);
void	apcicninit(struct consdev *);
int	apcicngetc(dev_t);
void	apcicnputc(dev_t, int);
@


1.3.12.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.3.12.3 2002/03/28 10:07:18 niklas Exp $	*/
d53 5
a57 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.12.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d307 1
d442 1
d677 1
a677 1
		error = suser(p, 0);
@


1.2
log
@cua devices for all!
@
text
@d1 1
a1 1
/*	$OpenBSD: apci.c,v 1.1 1997/07/06 08:01:44 downsj Exp $	*/
d344 3
a346 3
		while (!(APCICUA(dev) && sc->sc_cua) &&
		    (tp->t_cflag & CLOCAL) == 0 &&
		    (tp->t_state & TS_CARR_ON) == 0) {
d350 2
d358 2
@


1.1
log
@Sync with changes from NetBSD, up to 970705.

This includes all of the new frodo drivers, from Michael Smith, hacked up
by Jason R. Thorpe; other changes, mostly configuration and/or m68k
abstraction related, from Thorpe.  A few others of my own.

This compiles and runs, have not yet tested Domain kbd or apci ports.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 1
d129 2
a130 1
#define	APCIUNIT(x)	minor(x)
d271 1
d277 2
d323 1
a323 1
	if ((sc->sc_flags & APCI_SOFTCAR) ||
d326 10
a335 1
	
d337 9
a345 2
	if ((flag & O_NONBLOCK) == 0) {
		while ((tp->t_cflag & CLOCAL) == 0 &&
d351 2
d401 1
@
