head	1.24;
access;
symbols
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.10
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2005.01.14.22.39.25;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2003.09.23.16.51.11;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.27.44;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.09.23.09.20;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.29.18.30.21;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.28.13.47.38;	author art;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.11.23.07.11;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.04.05.44;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.10.21.08.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.10.07.59.05;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.04.22.48.58;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.31.22.39.41;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	98.03.06.17.24.11;	author millert;	state Exp;
branches
	1.7.10.1
	1.7.14.1;
next	1.6;

1.6
date	97.04.16.11.56.02;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.02.03.04.47.25;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.12.15.12.31;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.04.25.06.36.31;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.28.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.18;	author deraadt;	state Exp;
branches;
next	;

1.7.10.1
date	2001.04.18.16.05.33;	author niklas;	state Exp;
branches;
next	1.7.10.2;

1.7.10.2
date	2001.07.04.10.15.28;	author niklas;	state Exp;
branches;
next	1.7.10.3;

1.7.10.3
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.7.10.4;

1.7.10.4
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.7.10.5;

1.7.10.5
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.7.10.6;

1.7.10.6
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.7.10.7;

1.7.10.7
date	2002.03.28.10.07.18;	author niklas;	state Exp;
branches;
next	1.7.10.8;

1.7.10.8
date	2003.03.27.23.19.19;	author niklas;	state Exp;
branches;
next	1.7.10.9;

1.7.10.9
date	2003.05.13.19.41.02;	author ho;	state Exp;
branches;
next	1.7.10.10;

1.7.10.10
date	2003.06.07.11.11.34;	author ho;	state Exp;
branches;
next	1.7.10.11;

1.7.10.11
date	2004.02.19.10.48.38;	author niklas;	state Exp;
branches;
next	;

1.7.14.1
date	2001.01.31.22.48.13;	author jason;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.35.19;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2003.05.19.21.39.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@/*	$OpenBSD: grf.c,v 1.23 2003/09/23 16:51:11 millert Exp $	*/
/*	$NetBSD: grf.c,v 1.30 1998/08/20 08:33:41 kleink Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: grf.c 1.36 93/08/13$
 *
 *	@@(#)grf.c	8.4 (Berkeley) 1/12/94
 */

/*
 * Graphics display driver for HP 300/400/700/800 machines.
 * This is the hardware-independent portion of the driver.
 * Hardware access is through the machine dependent grf switch routines.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/poll.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/vnode.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <hp300/dev/grfioctl.h>
#include <hp300/dev/grfvar.h>
#include <hp300/dev/grfreg.h>

#ifdef COMPAT_HPUX
#include <compat/hpux/hpux.h>
extern struct emul emul_hpux;
#endif

#include <uvm/uvm.h>

#include <miscfs/specfs/specdev.h>

#include "ite.h"
#if NITE > 0
#include <hp300/dev/itevar.h>
#else
#define	iteon(u,f)		0	/* noramlly returns int */
#define	iteoff(u,f)
#endif /* NITE > 0 */

/* prototypes for the devsw entry points */
cdev_decl(grf);

int	grfmatch(struct device *, void *, void *);
void	grfattach(struct device *, struct device *, void *);

struct cfattach grf_ca = {
	sizeof(struct grf_softc), grfmatch, grfattach
};

struct cfdriver grf_cd = {
	NULL, "grf", DV_DULL
};

int	grfprint(void *, const char *);

/*
 * Frambuffer state information, statically allocated for benefit
 * of the console.
 */
struct	grf_data grf_cn;

#ifdef DEBUG
int grfdebug = 0;
#define GDB_DEVNO	0x01
#define GDB_MMAP	0x02
#define GDB_IOMAP	0x04
#define GDB_LOCK	0x08
#endif

int
grfmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{

	return (1);
}

void
grfattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct grf_softc *sc = (struct grf_softc *)self;
	struct grfdev_attach_args *ga = aux;

	printf("\n");

	sc->sc_data = ga->ga_data;
	sc->sc_scode = ga->ga_scode;	/* XXX */

	/* Attach an ITE. */
	(void)config_found(self, aux, grfprint);
}

int
grfprint(aux, pnp)
	void *aux;
	const char *pnp;
{

	/* Only ITEs can attach to GRFs, easy... */
	if (pnp)
		printf("ite at %s", pnp);

	return (UNCONF);
}

/*ARGSUSED*/
int
grfopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = GRFUNIT(dev);
	struct grf_softc *sc;
	struct grf_data *gp;
	int error = 0;

	if (unit >= grf_cd.cd_ndevs ||
	    (sc = grf_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	gp = sc->sc_data;

	if ((gp->g_flags & GF_ALIVE) == 0)
		return (ENXIO);

	if ((gp->g_flags & (GF_OPEN|GF_EXCLUDE)) == (GF_OPEN|GF_EXCLUDE))
		return(EBUSY);
#ifdef COMPAT_HPUX
	/*
	 * XXX: cannot handle both HPUX and BSD processes at the same time
	 */
	if (p->p_emul == &emul_hpux) {
		if (gp->g_flags & GF_BSDOPEN)
			return(EBUSY);
		else
			gp->g_flags |= GF_HPUXOPEN;
	} else {
		if (gp->g_flags & GF_HPUXOPEN)
			return(EBUSY);
		else
			gp->g_flags |= GF_BSDOPEN;
	}
#endif
	/*
	 * First open.
	 * XXX: always put in graphics mode.
	 */
	error = 0;
	if ((gp->g_flags & GF_OPEN) == 0) {
		gp->g_flags |= GF_OPEN;
		error = grfon(dev);
	}
	return(error);
}

/*ARGSUSED*/
int
grfclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	int unit = GRFUNIT(dev);
	struct grf_softc *sc;
	struct grf_data *gp;

	sc = grf_cd.cd_devs[unit];

	gp = sc->sc_data;

	if ((gp->g_flags & GF_ALIVE) == 0)
		return (ENXIO);

	(void) grfoff(dev);
#ifdef COMPAT_HPUX
	(void) grfunlock(gp);
#endif
	gp->g_flags &= GF_ALIVE;
	return(0);
}

/*ARGSUSED*/
int
grfioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	int flag;
	caddr_t data;
	struct proc *p;
{
	struct grf_softc *sc;
	struct grf_data *gp;
	int error, unit = GRFUNIT(dev);

	sc = grf_cd.cd_devs[unit];

	gp = sc->sc_data;

	if ((gp->g_flags & GF_ALIVE) == 0)
		return (ENXIO);

#ifdef COMPAT_HPUX
	if (p->p_emul == &emul_hpux)
		return(hpuxgrfioctl(dev, cmd, data, flag, p));
#endif
	error = 0;
	switch (cmd) {

	case GRFIOCGINFO:
		bcopy((caddr_t)&gp->g_display, data, sizeof(struct grfinfo));
		break;

	case GRFIOCON:
		error = grfon(dev);
		break;

	case GRFIOCOFF:
		error = grfoff(dev);
		break;

	case GRFIOCMAP:
		error = grfmap(dev, (caddr_t *)data, p);
		break;

	case GRFIOCUNMAP:
		error = grfunmap(dev, *(caddr_t *)data, p);
		break;

	default:
		error = EINVAL;
		break;

	}
	return(error);
}

/*ARGSUSED*/
int
grfpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	return (events & (POLLOUT | POLLWRNORM));
}

/*ARGSUSED*/
paddr_t
grfmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	struct grf_softc *sc = grf_cd.cd_devs[GRFUNIT(dev)];

	return (grfaddr(sc, off));
}

int
grfon(dev)
	dev_t dev;	/* XXX */
{
	int unit = GRFUNIT(dev);
	struct grf_softc *sc;
	struct grf_data *gp;

	sc = grf_cd.cd_devs[unit];
	gp = sc->sc_data;

	/*
	 * XXX: iteoff call relies on devices being in same order
	 * as ITEs and the fact that iteoff only uses the minor part
	 * of the dev arg.
	 */
	iteoff(sc->sc_ite->sc_data, 3);
	return((*gp->g_sw->gd_mode)(gp,
				    (dev&GRFOVDEV) ? GM_GRFOVON : GM_GRFON,
				    (caddr_t)0));
}

int
grfoff(dev)
	dev_t dev;	/* XXX */
{
	int unit = GRFUNIT(dev);
	struct grf_softc *sc;
	struct grf_data *gp;
	int error;

	sc = grf_cd.cd_devs[unit];
	gp = sc->sc_data;

	(void) grfunmap(dev, (caddr_t)0, curproc);
	error = (*gp->g_sw->gd_mode)(gp,
				     (dev&GRFOVDEV) ? GM_GRFOVOFF : GM_GRFOFF,
				     (caddr_t)0);
	/* XXX: see comment for iteoff above */
	(void) iteon(sc->sc_ite->sc_data, 2);
	return(error);
}

int
grfaddr(sc, off)
	struct grf_softc *sc;
	int off;
{
	struct grf_data *gp= sc->sc_data;
	struct grfinfo *gi = &gp->g_display;

	/* control registers */
	if (off >= 0 && off < gi->gd_regsize)
		return(((u_int)gi->gd_regaddr + off) >> PGSHIFT);

	/* frame buffer */
	if (off >= gi->gd_regsize && off < gi->gd_regsize+gi->gd_fbsize) {
		off -= gi->gd_regsize;
		return(((u_int)gi->gd_fbaddr + off) >> PGSHIFT);
	}
	/* bogus */
	return(-1);
}

/*
 * HP-UX compatibility routines
 */
#ifdef COMPAT_HPUX

/*ARGSUSED*/
int
hpuxgrfioctl(dev, cmd, data, flag, p)
	dev_t dev;
	int cmd, flag;
	caddr_t data;
	struct proc *p;
{
	struct grf_softc *sc = grf_cd.cd_devs[GRFUNIT(dev)];
	struct grf_data *gp = sc->sc_data;
	int error;

	error = 0;
	switch (cmd) {

	case GCID:
		*(int *)data = gp->g_display.gd_id;
		break;

	case GCON:
		error = grfon(dev);
		break;

	case GCOFF:
		error = grfoff(dev);
		break;

	case GCLOCK:
		error = grflock(gp, 1);
		break;

	case GCUNLOCK:
		error = grfunlock(gp);
		break;

	case GCAON:
	case GCAOFF:
		break;

	/* GCSTATIC is implied by our implementation */
	case GCSTATIC_CMAP:
	case GCVARIABLE_CMAP:
		break;

	/* map in control regs and frame buffer */
	case GCMAP:
		error = grfmap(dev, (caddr_t *)data, p);
		break;

	case GCUNMAP:
		error = grfunmap(dev, *(caddr_t *)data, p);
		/* XXX: HP-UX uses GCUNMAP to get rid of GCSLOT memory */
		if (error)
			error = grflckunmmap(dev, *(caddr_t *)data);
		break;

	case GCSLOT:
	{
		struct grf_slot *sp = (struct grf_slot *)data;

		sp->slot = grffindpid(gp);
		if (sp->slot) {
			error = grflckmmap(dev, (caddr_t *)&sp->addr);
			if (error && gp->g_pid) {
				free((caddr_t)gp->g_pid, M_DEVBUF);
				gp->g_pid = NULL;
			}
		} else
			error = EINVAL;		/* XXX */
		break;
	}

	case GCDESCRIBE:
		error = (*gp->g_sw->gd_mode)(gp, GM_DESCRIBE, data);
		break;

	/*
	 * XXX: only used right now to map in rbox control registers
	 * Will be replaced in the future with a real IOMAP interface.
	 */
	case IOMAPMAP:
		error = iommap(dev, (caddr_t *)data);
#if 0
		/*
		 * It may not be worth kludging this (using p_devtmp) to
		 * make this work.  It was an undocumented side-effect
		 * in HP-UX that the mapped address was the return value
		 * of the ioctl.  The only thing I remember that counted
		 * on this behavior was the rbox X10 server.
		 */
		if (!error)
			u.u_r.r_val1 = *(int *)data;	/* XXX: this sux */
#endif
		break;

	case IOMAPUNMAP:
		error = iounmmap(dev, *(caddr_t *)data);
		break;

	default:
		error = EINVAL;
		break;
	}
	return(error);
}

int
grflock(gp, block)
	struct grf_data *gp;
	int block;
{
	struct proc *p = curproc;		/* XXX */
	int error;

#ifdef DEBUG
	if (grfdebug & GDB_LOCK)
		printf("grflock(%d): flags %x lockpid %x\n",
		       p->p_pid, gp->g_flags,
		       gp->g_lockp ? gp->g_lockp->p_pid : -1);
#endif
	if (gp->g_pid) {
#ifdef DEBUG
		if (grfdebug & GDB_LOCK)
			printf(" lockpslot %d lockslot %d lock[lockslot] %d\n",
			       gp->g_lock->gl_lockslot, gp->g_lockpslot,
			       gp->g_lock->gl_locks[gp->g_lockpslot]);
#endif
		gp->g_lock->gl_lockslot = 0;
		if (gp->g_lock->gl_locks[gp->g_lockpslot] == 0) {
			gp->g_lockp = NULL;
			gp->g_lockpslot = 0;
		}
	}
	if (gp->g_lockp) {
		if (gp->g_lockp == p)
			return(EBUSY);
		if (!block)
			return(OEAGAIN);
		do {
			gp->g_flags |= GF_WANTED;
			if ((error = tsleep((caddr_t)&gp->g_flags,
					   (PZERO+1) | PCATCH, devioc, 0)))
				return (error);
		} while (gp->g_lockp);
	}
	gp->g_lockp = p;
	if (gp->g_pid) {
		int slot = grffindpid(gp);

#ifdef DEBUG
		if (grfdebug & GDB_LOCK)
			printf("  slot %d\n", slot);
#endif
		gp->g_lockpslot = gp->g_lock->gl_lockslot = slot;
		gp->g_lock->gl_locks[slot] = 1;
	}
	return(0);
}

int
grfunlock(gp)
	struct grf_data *gp;
{
#ifdef DEBUG
	if (grfdebug & GDB_LOCK)
		printf("grfunlock(%d): flags %x lockpid %d\n",
		       curproc->p_pid, gp->g_flags,
		       gp->g_lockp ? gp->g_lockp->p_pid : -1);
#endif
	if (gp->g_lockp != curproc)
		return(EBUSY);
	if (gp->g_pid) {
#ifdef DEBUG
		if (grfdebug & GDB_LOCK)
			printf(" lockpslot %d lockslot %d lock[lockslot] %d\n",
			       gp->g_lock->gl_lockslot, gp->g_lockpslot,
			       gp->g_lock->gl_locks[gp->g_lockpslot]);
#endif
		gp->g_lock->gl_locks[gp->g_lockpslot] = 0;
		gp->g_lockpslot = gp->g_lock->gl_lockslot = 0;
	}
	if (gp->g_flags & GF_WANTED) {
		wakeup((caddr_t)&gp->g_flags); 
		gp->g_flags &= ~GF_WANTED;
	}
	gp->g_lockp = NULL;
	return(0);
}

/*
 * Convert a BSD style minor devno to HPUX style.
 * We cannot just create HPUX style nodes as they require 24 bits
 * of minor device number and we only have 8.
 * XXX: This may give the wrong result for remote stats of other
 * machines where device 10 exists.
 */
int
grfdevno(dev)
	dev_t dev;
{
	int unit = GRFUNIT(dev);
	struct grf_softc *sc;
	struct grf_data *gp;
	int newdev;

	if (unit >= grf_cd.cd_ndevs ||
	    (sc = grf_cd.cd_devs[unit]) == NULL)
		return (bsdtohpuxdev(dev));

	gp = sc->sc_data;
	if ((gp->g_flags & GF_ALIVE) == 0)
		return (bsdtohpuxdev(dev));

	/* magic major number */
	newdev = 12 << 24;
	/* now construct minor number */
	if (gp->g_display.gd_regaddr != (caddr_t)GRFIADDR)
		newdev |= (sc->sc_scode << 16) | 0x200;
	if (dev & GRFIMDEV)
		newdev |= 0x02;
	else if (dev & GRFOVDEV)
		newdev |= 0x01;
#ifdef DEBUG
	if (grfdebug & GDB_DEVNO)
		printf("grfdevno: dev %x newdev %x\n", dev, newdev);
#endif
	return(newdev);
}

#endif	/* COMPAT_HPUX */

int
grfmap(dev, addrp, p)
	dev_t dev;
	caddr_t *addrp;
	struct proc *p;
{
	struct grf_softc *sc = grf_cd.cd_devs[GRFUNIT(dev)];
	struct grf_data *gp = sc->sc_data;
	int len, error;
	struct vnode vn;
	struct specinfo si;
	int flags;

#ifdef DEBUG
	if (grfdebug & GDB_MMAP)
		printf("grfmap(%d): addr %p\n", p->p_pid, *addrp);
#endif
	len = gp->g_display.gd_regsize + gp->g_display.gd_fbsize;
	flags = MAP_SHARED;
	if (*addrp)
		flags |= MAP_FIXED;
	else
		*addrp = (caddr_t)0x1000000;	/* XXX */
	vn.v_type = VCHR;			/* XXX */
	vn.v_specinfo = &si;			/* XXX */
	vn.v_rdev = dev;			/* XXX */
	error = uvm_mmap(&p->p_vmspace->vm_map, (vaddr_t *)addrp,
			 (vsize_t)len, UVM_PROT_RW, UVM_PROT_RW,
			 flags, (caddr_t)&vn, 0,
			 p->p_rlimit[RLIMIT_MEMLOCK].rlim_cur);
	if (error == 0)
		(void) (*gp->g_sw->gd_mode)(gp, GM_MAP, *addrp);
	return(error);
}

int
grfunmap(dev, addr, p)
	dev_t dev;
	caddr_t addr;
	struct proc *p;
{
	struct grf_softc *sc = grf_cd.cd_devs[GRFUNIT(dev)];
	struct grf_data *gp = sc->sc_data;
	vsize_t size;

#ifdef DEBUG
	if (grfdebug & GDB_MMAP)
		printf("grfunmap(%d): dev %x addr %p\n", p->p_pid, dev, addr);
#endif
	if (addr == 0)
		return(EINVAL);		/* XXX: how do we deal with this? */
	(void) (*gp->g_sw->gd_mode)(gp, GM_UNMAP, 0);
	size = round_page(gp->g_display.gd_regsize + gp->g_display.gd_fbsize);
	uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr,
	    (vaddr_t)addr + size);
	return (0);
}

#ifdef COMPAT_HPUX
int
iommap(dev, addrp)
	dev_t dev;
	caddr_t *addrp;
{

#ifdef DEBUG
	if (grfdebug & (GDB_MMAP|GDB_IOMAP))
		printf("iommap(%d): addr %p\n", curproc->p_pid, *addrp);
#endif
	return(-1);
}

int
iounmmap(dev, addr)
	dev_t dev;
	caddr_t addr;
{
#ifdef DEBUG
	int unit = minor(dev);

	if (grfdebug & (GDB_MMAP|GDB_IOMAP))
		printf("iounmmap(%d): id %d addr %p\n",
		       curproc->p_pid, unit, addr);
#endif
	return(0);
}

/*
 * Processes involved in framebuffer mapping via GCSLOT are recorded in
 * an array of pids.  The first element is used to record the last slot used
 * (for faster lookups).  The remaining elements record up to GRFMAXLCK-1
 * process ids.  Returns a slot number between 1 and GRFMAXLCK or 0 if no
 * slot is available. 
 */
int
grffindpid(gp)
	struct grf_data *gp;
{
	short pid, *sp;
	int i, limit;
	int ni;

	if (gp->g_pid == NULL) {
		gp->g_pid = (short *)
			malloc(GRFMAXLCK * sizeof(short), M_DEVBUF, M_WAITOK);
		bzero((caddr_t)gp->g_pid, GRFMAXLCK * sizeof(short));
	}
	pid = curproc->p_pid;
	ni = limit = gp->g_pid[0];
	for (i = 1, sp = &gp->g_pid[1]; i <= limit; i++, sp++) {
		if (*sp == pid)
			goto done;
		if (*sp == 0)
			ni = i;
	}
	i = ni;
	if (i < limit) {
		gp->g_pid[i] = pid;
		goto done;
	}
	if (++i == GRFMAXLCK)
		return(0);
	gp->g_pid[0] = i;
	gp->g_pid[i] = pid;
done:
#ifdef DEBUG
	if (grfdebug & GDB_LOCK)
		printf("grffindpid(%d): slot %d of %d\n",
		       pid, i, gp->g_pid[0]);
#endif
	return(i);
}

void
grfrmpid(gp)
	struct grf_data *gp;
{
	short pid, *sp;
	int limit, i;
	int mi;

	if (gp->g_pid == NULL || (limit = gp->g_pid[0]) == 0)
		return;
	pid = curproc->p_pid;
	limit = gp->g_pid[0];
	mi = 0;
	for (i = 1, sp = &gp->g_pid[1]; i <= limit; i++, sp++) {
		if (*sp == pid)
			*sp = 0;
		else if (*sp)
			mi = i;
	}
	i = mi;
	if (i < limit)
		gp->g_pid[0] = i;
#ifdef DEBUG
	if (grfdebug & GDB_LOCK)
		printf("grfrmpid(%d): slot %d of %d\n",
		       pid, sp-gp->g_pid, gp->g_pid[0]);
#endif
}

int
grflckmmap(dev, addrp)
	dev_t dev;
	caddr_t *addrp;
{
#ifdef DEBUG
	struct proc *p = curproc;		/* XXX */

	if (grfdebug & (GDB_MMAP|GDB_LOCK))
		printf("grflckmmap(%d): addr %p\n",
		       p->p_pid, *addrp);
#endif
	return(-1);
}

int
grflckunmmap(dev, addr)
	dev_t dev;
	caddr_t addr;
{
#ifdef DEBUG
	int unit = minor(dev);

	if (grfdebug & (GDB_MMAP|GDB_LOCK))
		printf("grflckunmmap(%d): id %d addr %p\n",
		       curproc->p_pid, unit, addr);
#endif
	return(EINVAL);
}
#endif	/* COMPAT_HPUX */
@


1.23
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.22 2003/06/02 23:27:44 millert Exp $	*/
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.21 2003/05/09 23:09:20 art Exp $	*/
d56 1
d288 1
a288 1
grfselect(dev, rw, p)
d290 1
a290 1
	int rw;
d293 1
a293 3
	if (rw == FREAD)
		return(0);
	return(1);
@


1.21
log
@No need to map framebuffers executable. Really.

fries@@ niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.20 2002/10/29 18:30:21 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@Since memory deallocation can't fail, remove the error return from
uvm_unmap, uvm_deallocate and a few other functions.
Simplifies some code and reduces diff to the UBC branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.19 2002/03/14 01:26:30 millert Exp $	*/
d640 1
a640 1
			 (vsize_t)len, VM_PROT_ALL, VM_PROT_ALL,
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.18 2001/12/19 08:58:05 art Exp $	*/
a656 1
	int rv;
d666 1
a666 1
	rv = uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr,
d668 1
a668 1
	return(rv == KERN_SUCCESS ? 0 : EINVAL);
@


1.18
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.16 2001/11/06 19:53:14 miod Exp $	*/
d91 2
a92 2
int	grfmatch __P((struct device *, void *, void *));
void	grfattach __P((struct device *, struct device *, void *));
d102 1
a102 1
int	grfprint __P((void *, const char *));
@


1.17
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d657 1
d667 3
a669 2
	uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr, (vaddr_t)addr + size);
	return (0);
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.17 2001/11/28 13:47:38 art Exp $	*/
d91 2
a92 2
int	grfmatch(struct device *, void *, void *);
void	grfattach(struct device *, struct device *, void *);
d102 1
a102 1
int	grfprint(void *, const char *);
@


1.17.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d640 1
a640 1
			 (vsize_t)len, UVM_PROT_RW, UVM_PROT_RW,
d666 1
a666 2
	uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr,
	    (vaddr_t)addr + size);
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.15 2001/11/01 12:13:46 art Exp $	*/
a656 1
	int rv;
d666 2
a667 3
	rv = uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr,
	    (vaddr_t)addr + size);
	return(rv == KERN_SUCCESS ? 0 : EINVAL);
@


1.15
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.14 2001/09/11 20:05:24 miod Exp $	*/
a74 2

#include <vm/vm.h>
@


1.14
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.13 2001/08/11 23:07:11 art Exp $	*/
d304 1
a304 1
int
d307 2
a308 1
	int off, prot;
@


1.13
log
@redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.12 2001/06/27 04:05:44 art Exp $	*/
a76 1
#include <vm/vm_kern.h>
@


1.12
log
@no more old VM
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.11 2001/05/10 21:08:48 millert Exp $	*/
a77 2
#include <vm/vm_page.h>
#include <vm/vm_pager.h>
@


1.11
log
@Add missing #include <sys/resourcevar.h> so these can compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.10 2001/05/10 07:59:05 art Exp $	*/
a80 1
#if defined(UVM)
a81 1
#endif
a642 1
#if defined(UVM)
a646 5
#else
	error = vm_mmap(&p->p_vmspace->vm_map, (vaddr_t *)addrp,
			(vsize_t)len, VM_PROT_ALL, VM_PROT_ALL,
			flags, (caddr_t)&vn, 0);
#endif
a670 1
#if defined(UVM)
a672 3
#else
	rv = vm_deallocate(&p->p_vmspace->vm_map, (vaddr_t)addr, size);
#endif
@


1.10
log
@Some locking protocol fixes and better enforcement of wiring limits.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.9 2001/05/04 22:48:58 aaron Exp $	*/
d61 1
@


1.9
log
@Substantial update from NetBSD, most notably gives us UVM support; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.8 2001/01/31 22:39:41 jason Exp $	*/
d647 2
a648 1
			 flags, (caddr_t)&vn, 0);
@


1.8
log
@based on art's sparc patch:
mmap should return -1 on failure, not EOPNOTSUPP.
As it was now, an mmap of /dev/mem always returned page 45.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf.c,v 1.7 1998/03/06 17:24:11 millert Exp $	*/
/*	$NetBSD: grf.c,v 1.25 1997/04/02 22:37:30 scottr Exp $	*/
d80 4
a499 1
	extern char devioc[];
d644 7
a650 2
	error = vm_mmap(&p->p_vmspace->vm_map, (vm_offset_t *)addrp,
			(vm_size_t)len, VM_PROT_ALL, VM_PROT_ALL,
d652 1
d666 1
a666 1
	vm_size_t size;
d677 6
a682 1
	rv = vm_deallocate(&p->p_vmspace->vm_map, (vm_offset_t)addr, size);
@


1.7
log
@please gcc 2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.6 1997/04/16 11:56:02 downsj Exp $	*/
d683 1
a683 1
	return(EINVAL);
d788 1
a788 1
	return(EINVAL);
@


1.7.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.8 2001/01/31 22:39:41 jason Exp $	*/
d683 1
a683 1
	return(-1);
d788 1
a788 1
	return(-1);
@


1.7.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: grf.c,v 1.30 1998/08/20 08:33:41 kleink Exp $	*/
a60 1
#include <sys/resourcevar.h>
a79 2
#include <uvm/uvm.h>

d496 1
d641 3
a643 4
	error = uvm_mmap(&p->p_vmspace->vm_map, (vaddr_t *)addrp,
			 (vsize_t)len, VM_PROT_ALL, VM_PROT_ALL,
			 flags, (caddr_t)&vn, 0,
			 p->p_rlimit[RLIMIT_MEMLOCK].rlim_cur);
d657 1
a657 1
	vsize_t size;
d668 1
a668 2
	rv = uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr,
	    (vaddr_t)addr + size);
@


1.7.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.7.10.2 2001/07/04 10:15:28 niklas Exp $	*/
d77 3
@


1.7.10.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 2
d304 1
a304 1
paddr_t
d307 1
a307 2
	off_t off;
	int prot;
@


1.7.10.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.7.10.4 2001/11/13 21:00:50 niklas Exp $	*/
d657 1
d667 3
a669 2
	uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr, (vaddr_t)addr + size);
	return (0);
@


1.7.10.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a656 1
	int rv;
d666 2
a667 3
	rv = uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr,
	    (vaddr_t)addr + size);
	return(rv == KERN_SUCCESS ? 0 : EINVAL);
@


1.7.10.7
log
@Merge in -current from about a week ago
@
text
@d91 2
a92 2
int	grfmatch(struct device *, void *, void *);
void	grfattach(struct device *, struct device *, void *);
d102 1
a102 1
int	grfprint(void *, const char *);
@


1.7.10.8
log
@Sync the SMP branch with 3.3
@
text
@d657 1
d667 1
a667 1
	uvm_unmap(&p->p_vmspace->vm_map, (vaddr_t)addr,
d669 1
a669 1
	return (0);
@


1.7.10.9
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.7.10.8 2003/03/27 23:19:19 niklas Exp $	*/
d640 1
a640 1
			 (vsize_t)len, UVM_PROT_RW, UVM_PROT_RW,
@


1.7.10.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.7.10.9 2003/05/13 19:41:02 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.10.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a55 1
#include <sys/poll.h>
d287 1
a287 1
grfpoll(dev, events, p)
d289 1
a289 1
	int events;
d292 3
a294 1
	return (events & (POLLOUT | POLLWRNORM));
@


1.7.14.1
log
@Pull in patches from current:
Fix (art,jason):
mmap should return -1 on failure, not EOPNOTSUPP.
As it was now, an mmap of /dev/mem always returned page 45.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.7 1998/03/06 17:24:11 millert Exp $	*/
d683 1
a683 1
	return(-1);
d788 1
a788 1
	return(-1);
@


1.6
log
@Merge portions of NetBSD up to 970415.

This includes:
	* All of the prototyping and KNF changes.
	* The new interrupt system.
	* Portions of the Domain Keyboard support from Mike Smith.

This does not include:
	* m68k changes, namely generic dumps.

Various sundry changes and fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.5 1997/02/03 04:47:25 downsj Exp $	*/
d186 1
a186 1
	if (p->p_emul == &emul_hpux)
d191 1
a191 1
	else
d196 1
@


1.5
log
@Merge new config(8) support from NetBSD, by Jason Thorpe.
Also add siginfo glue, BOOT_CONFIG, and various other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: grf.c,v 1.4 1997/01/12 15:12:31 downsj Exp $	*/
/*	$NetBSD: grf.c,v 1.23 1997/01/30 09:18:42 thorpej Exp $	*/
d53 4
a56 1
#include <sys/proc.h>
a57 1
#include <sys/file.h>
d59 2
a61 3
#include <sys/mman.h>
#include <sys/conf.h>
#include <sys/device.h>
d359 1
a359 1
	register int off;
d523 2
a524 2
			if (error = tsleep((caddr_t)&gp->g_flags,
					   (PZERO+1) | PCATCH, devioc, 0))
d629 1
a629 1
		printf("grfmap(%d): addr %x\n", p->p_pid, *addrp);
d648 1
d661 1
a661 1
		printf("grfunmap(%d): dev %x addr %x\n", p->p_pid, dev, addr);
d680 1
a680 1
		printf("iommap(%d): addr %x\n", curproc->p_pid, *addrp);
d690 1
a692 1
#ifdef DEBUG
d694 1
a694 1
		printf("iounmmap(%d): id %d addr %x\n",
d707 1
d711 2
a712 2
	register short pid, *sp;
	register int i, limit;
d746 1
d750 2
a751 2
	register short pid, *sp;
	register int limit, i;
d775 1
d784 1
a784 1
		printf("grflckmmap(%d): addr %x\n",
d790 1
d799 1
a799 1
		printf("grflckunmmap(%d): id %d addr %x\n",
@


1.4
log
@Mostly sync to NetBSD-current of 011196.  Compiles, links, boots to single
user.

KNOWN NOT WORKING:
	* DIO-II devices
	* Dynamic executables

NOT EVEN TRIED:
	* New config support
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: grf.c,v 1.22 1997/01/10 00:07:27 scottr Exp $	*/
d85 1
a85 1
#define	iteon(u,f)	0	/* normally returns int */
d92 1
a92 2
#ifdef NEWCONFIG
int	grfmatch __P((struct device *, struct cfdata *, void *));
a103 4
#else /* ! NEWCONFIG */
#include "grf.h"
struct	grf_softc grf_softc[NGRF];
#endif /* NEWCONFIG */
a118 1
#ifdef NEWCONFIG
d122 1
a122 2
	struct cfdata *match;
	void *aux;
a156 1
#endif /* NEWCONFIG */
a169 1
#ifdef NEWCONFIG
a172 5
#else
	if (unit >= NGRF)
		return(ENXIO);
	sc = &grf_softc[unit];
#endif
a218 1
#ifdef NEWCONFIG
a219 3
#else
	sc = &grf_softc[unit];
#endif
a246 1
#ifdef NEWCONFIG
a247 3
#else
	sc = &grf_softc[unit];
#endif
a306 1
#ifdef NEWCONFIG
a307 3
#else
	struct grf_softc *sc = &grf_softc[GRFUNIT(dev)];
#endif
a319 1
#ifdef NEWCONFIG
a320 3
#else
	sc = &grf_softc[unit];
#endif
a342 1
#ifdef NEWCONFIG
a343 3
#else
	sc = &grf_softc[unit];
#endif
d351 1
a351 1
	iteon(sc->sc_ite->sc_data, 2);
a388 1
#ifdef NEWCONFIG
a389 3
#else
	struct grf_softc *sc = &grf_softc[GRFUNIT(dev)];
#endif
a586 1
#ifdef NEWCONFIG
a589 5
#else
	if (unit >= NGRF)
		return (bsdtohpuxdev(dev));
	sc = &grf_softc[unit];
#endif
a618 1
#ifdef NEWCONFIG
a619 3
#else
	struct grf_softc *sc = &grf_softc[GRFUNIT(dev)];
#endif
a651 1
#ifdef NEWCONFIG
a652 3
#else
	struct grf_softc *sc = &grf_softc[GRFUNIT(dev)];
#endif
@


1.3
log
@sync w/ Net 960424
@
text
@d1 2
a2 1
/*	$NetBSD: grf.c,v 1.17 1996/02/24 00:55:07 thorpej Exp $	*/
a51 3
#include "grf.h"
#if NGRF > 0

d59 2
d85 1
a85 1
#define	iteon(u,f)
d89 18
d108 1
d124 42
d167 1
d178 5
d185 2
a187 1
	sc = &grf_softc[unit];
d223 1
d233 5
a237 2
	if (unit >= NGRF)
		return(ENXIO);
a238 1
	sc = &grf_softc[unit];
d253 1
d256 2
a257 1
	int cmd, flag;
d265 5
a269 2
	if (unit >= NGRF)
		return(ENXIO);
a270 1
	sc = &grf_softc[unit];
d312 2
a313 1
grfselect(dev, rw)
d316 1
d324 1
d329 7
a335 1
	return(grfaddr(&grf_softc[GRFUNIT(dev)], off));
d346 3
d350 1
d373 3
d377 1
d385 1
a385 1
	(void) iteon(sc->sc_ite->sc_data, 2);
d416 1
d423 3
d427 1
d579 1
d616 1
d621 2
a622 2
	struct grf_softc *sc = &grf_softc[unit];
	struct grf_data *gp = sc->sc_data;
d625 14
a638 2
	if (unit >= NGRF || (gp->g_flags&GF_ALIVE) == 0)
		return(bsdtohpuxdev(dev));
d642 2
a643 4
	if (gp->g_display.gd_regaddr != (caddr_t)GRFIADDR) {
		int sc = patosc(gp->g_display.gd_regaddr);
		newdev |= (sc << 16) | 0x200;
	}
d657 1
d663 3
d667 1
d700 3
d704 1
d722 1
d735 1
a850 2

#endif	/* NGRF > 0 */
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: grf.c,v 1.16 1995/11/28 08:14:30 thorpej Exp $	*/
d62 3
a68 2
#include <machine/cpu.h>

d82 3
a84 1
#if NITE == 0
d87 1
a87 1
#endif
d91 6
d106 1
a106 1
grfopen(dev, flags)
d108 2
a109 1
	int flags;
d112 2
a113 1
	register struct grf_softc *gp = &grf_softc[unit];
d116 1
a116 1
	if (unit >= NGRF || (gp->g_flags & GF_ALIVE) == 0)
d118 7
d131 1
a131 1
	if (curproc->p_emul == &emul_hpux)
d155 1
a155 1
grfclose(dev, flags)
d157 2
a158 1
	int flags;
d160 12
a171 1
	register struct grf_softc *gp = &grf_softc[GRFUNIT(dev)];
d188 12
a199 2
	register struct grf_softc *gp = &grf_softc[GRFUNIT(dev)];
	int error;
d254 1
d256 1
a256 1
	dev_t dev;
d259 5
a263 1
	struct grf_softc *gp = &grf_softc[unit];
d270 1
a270 1
	iteoff(unit, 3);
d276 1
d278 1
a278 1
	dev_t dev;
d281 2
a282 1
	struct grf_softc *gp = &grf_softc[unit];
d285 3
d293 1
a293 1
	iteon(unit, 2);
d297 3
a299 2
grfaddr(gp, off)
	struct grf_softc *gp;
d302 2
a303 1
	register struct grfinfo *gi = &gp->g_display;
d330 2
a331 1
	register struct grf_softc *gp = &grf_softc[GRFUNIT(dev)];
d428 1
d430 1
a430 1
	register struct grf_softc *gp;
d439 2
a440 2
		printf("grflock(%d): dev %x flags %x lockpid %x\n",
		       p->p_pid, gp-grf_softc, gp->g_flags,
d483 1
a483 1
	register struct grf_softc *gp;
d487 2
a488 2
		printf("grfunlock(%d): dev %x flags %x lockpid %d\n",
		       curproc->p_pid, gp-grf_softc, gp->g_flags,
d522 2
a523 1
	struct grf_softc *gp = &grf_softc[unit];
d553 2
a554 1
	struct grf_softc *gp = &grf_softc[GRFUNIT(dev)];
d586 2
a587 1
	struct grf_softc *gp = &grf_softc[GRFUNIT(dev)];
d638 1
a638 1
	struct grf_softc *gp;
d676 1
a676 1
	struct grf_softc *gp;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: grf.c,v 1.14 1995/04/22 20:25:42 christos Exp $	*/
d69 1
a69 1
#include <hp300/hpux/hpux.h>
d80 1
a80 1
#include <ite.h>
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

