head	1.6;
access;
symbols
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	UBC_SYNC_A:1.6
	UBC_SYNC_B:1.6
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.12
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2001.02.07.07.45.41;	author art;	state dead;
branches;
next	1.5;

1.5
date	97.08.08.21.46.40;	author niklas;	state Exp;
branches
	1.5.12.1;
next	1.4;

1.4
date	95.12.14.05.27.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.23.16.28.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.07.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.07;	author deraadt;	state Exp;
branches;
next	;

1.5.12.1
date	2001.04.18.16.04.35;	author niklas;	state dead;
branches;
next	;


desc
@@


1.6
log
@We need to loose some weight.
If someone feels very opposed to this, the code is left in the Attic.
Just revive and _make_it_work_.
@
text
@/*	$NetBSD: disksubr.c,v 1.5 1995/11/30 00:57:35 jtc Exp $	*/

/*
 * Copyright (c) 1995 Leo Weppelman.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Leo Weppelman.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <machine/tospart.h>

/*
 * This is ugly, but as long as disklabel(8) uses
 * BBSIZE from ufs/ffs/fs.h, there's no alternative.
 */
#include <ufs/ffs/fs.h>
#if BBSIZE < 8192
#error BBSIZE in /sys/ufs/ffs/fs.h must be at least 8192 bytes
#endif

#if 0
#define MACHDSBR_DEBUG(x)	printf x
#else
#define MACHDSBR_DEBUG(x)
#endif

static int  real_label __P((dev_t, void (*)(), u_int32_t, struct disklabel *));
static void chck_label __P((struct disklabel *, struct cpu_disklabel *));
static void fake_label __P((struct disklabel *, struct tos_table *));
static int  rd_rootparts __P((dev_t, void (*)(), u_int32_t, u_int32_t,
                                                        struct tos_table *));
static int  rd_extparts  __P((dev_t, void (*)(), u_int32_t, u_int32_t,
                                             u_int32_t, struct tos_table *));
static int  add_tospart  __P((struct tos_part *, struct tos_table *));

/*
 * XXX unknown function but needed for /sys/scsi to link
 */
int
dk_establish()
{
	return(-1);
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf		*bp;
	struct disklabel	*lp;
	struct cpu_disklabel	*osdep;
	int			wlabel;
{
	struct partition	*pp;
	u_int32_t		maxsz, sz;

	pp = &lp->d_partitions[DISKPART(bp->b_dev)];
	if (bp->b_flags & B_RAW) {
		if (bp->b_bcount & (lp->d_secsize - 1)) {
			bp->b_error = EINVAL;
			bp->b_flags |= B_ERROR;
			return (-1);
		}
		maxsz = pp->p_size * (lp->d_secsize / DEV_BSIZE);
		sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
	} else {
		maxsz = pp->p_size;
		sz = (bp->b_bcount + lp->d_secsize - 1) / lp->d_secsize;
	}

	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		if (bp->b_blkno == maxsz) {
			/* 
			 * trying to get one block beyond return EOF.
			 */
			bp->b_resid = bp->b_bcount;
			return(0);
		}
		sz = maxsz - bp->b_blkno;
		if (sz <= 0 || bp->b_blkno < 0) {
			bp->b_error = EINVAL;
			bp->b_flags |= B_ERROR;
			return(-1);
		}
		/* 
		 * adjust count down
		 */
		if (bp->b_flags & B_RAW)
			bp->b_bcount = sz << DEV_BSHIFT;
		else bp->b_bcount = sz * lp->d_secsize;
	}

	/*
	 * calc cylinder for disksort to order transfers with
	 */
	bp->b_cylinder = (bp->b_blkno + pp->p_offset) / lp->d_secpercyl;
	return(1);
}

/*
 * Attempt to read a disk label from a device using the
 * indicated strategy routine. The label must be partly
 * set up before this:
 * secpercyl and anything required in the strategy routine
 * (e.g. sector size) must be filled in before calling us.
 * Returns NULL on success and an error string on failure.
 */
char *
readdisklabel(dev, strat, lp, clp)
dev_t			dev;
void			(*strat)();
struct disklabel	*lp;
struct cpu_disklabel	*clp;
{
	struct tos_table	tt;
	int			i;

	bzero(clp, sizeof *clp);

	/*
	 * Give some guaranteed validity to the disk label.
	 */
	if (lp->d_secsize == 0)
		lp->d_secsize = DEV_BSIZE;
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
	if (lp->d_secpercyl == 0)
		return("Zero secpercyl");
	for (i = 0; i < MAXPARTITIONS; ++i) {
		lp->d_partitions[i].p_size   = 0;
		lp->d_partitions[i].p_offset = 0;
		lp->d_partitions[i].p_fstype = FS_UNUSED;
	}
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_npartitions                 = RAW_PART + 1;
	lp->d_bbsize                      = BBSIZE;
	lp->d_sbsize                      = SBSIZE;

	MACHDSBR_DEBUG(("unit: %lu secsize: %lu secperunit: %lu\n",
	(u_long)DISKUNIT(dev), (u_long)lp->d_secsize,
	(u_long)lp->d_secperunit));

	/*
	 * Try the simple case (boot block at sector 0) first.
	 */
	if(real_label(dev, strat, LABELSECTOR, lp)) {
		MACHDSBR_DEBUG(("Normal volume: boot block at sector 0\n"));
		return(NULL);
	}
	/*
	 * The vendor specific (TOS) partition layout requires a 512
	 * byte sector size.
	 */
	tt.tt_cdl    = clp;
	tt.tt_nroots = tt.tt_nparts = 0;
	if (lp->d_secsize != TOS_BSIZE || (i = rd_rootparts(dev, strat,
			lp->d_secpercyl, lp->d_secperunit, &tt)) == 2) {
		MACHDSBR_DEBUG(("Uninitialised volume\n"));
		lp->d_partitions[RAW_PART+1].p_size
				= lp->d_partitions[RAW_PART].p_size;
		lp->d_partitions[RAW_PART+1].p_offset
				= lp->d_partitions[RAW_PART].p_offset;
		lp->d_partitions[RAW_PART+1].p_fstype = FS_BSDFFS;
		lp->d_npartitions = RAW_PART + 2;
		goto done;
	}
	if (!i)
		return("Invalid TOS partition table");
	/*
	 * TOS format, search for a partition with id NBD or RAW, which
	 * contains a NetBSD boot block with a valid disk label in it.
	 */
	MACHDSBR_DEBUG(("AHDI partition table: "));
	clp->cd_bblock = NO_BOOT_BLOCK;
	for (i = 0; i < tt.tt_nparts; ++i) {
		struct tos_part	*tp = &tt.tt_parts[i];
		u_int32_t	id = *((u_int32_t *)&tp->tp_flg);
		if (id != PID_NBD && id != PID_RAW)
			continue;
		if (!real_label(dev, strat, tp->tp_st, lp)) {
			/*
			 * No disk label, but if this is the first NBD partition
			 * on this volume, we'll mark it anyway as a possible
			 * destination for future writedisklabel() calls, just
			 * in case there is no valid disk label on any of the
			 * other AHDI partitions.
			 */
			if (id == PID_NBD
			  && clp->cd_bblock == NO_BOOT_BLOCK)
				clp->cd_bblock = tp->tp_st;
			continue;
		}
		/*
		 * Found a valid disk label, mark this TOS partition for
		 * writedisklabel(), and check for possibly dangerous
		 * overlap between TOS and NetBSD partition layout.
		 */
		MACHDSBR_DEBUG(("found real disklabel\n"));
		clp->cd_bblock = tp->tp_st;
		chck_label(lp, clp);
		return(NULL);
	}
	/*
	 * No disk label on this volume, use the TOS partition
	 * layout to create a fake disk label. If there is no
	 * NBD partition on this volume either, subsequent
	 * writedisklabel() calls will fail.
	 */
	MACHDSBR_DEBUG(("creating fake disklabel\n"));
	fake_label(lp, &tt);

	/*
	 * Calulate new checksum.
	 */
done:
	lp->d_magic = lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);

	return(NULL);
}

/*
 * Check new disk label for sensibility before setting it.
 */
int
setdisklabel(olp, nlp, openmask, clp)
struct disklabel	*olp, *nlp;
u_long			openmask;
struct cpu_disklabel	*clp;
{
	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return(0);
	}

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0
	  || (nlp->d_secsize % DEV_BSIZE) != 0 || dkcksum(nlp) != 0
	  || nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC)
		return(EINVAL);

	if (clp->cd_bblock)
		chck_label(nlp, clp);

	while (openmask) {
		struct partition *op, *np;
		int i = ffs(openmask) - 1;
		openmask &= ~(1 << i);
		if (i >= nlp->d_npartitions)
			return(EBUSY);
		op = &olp->d_partitions[i];
		np = &nlp->d_partitions[i];
		if (np->p_offset != op->p_offset || np->p_size < op->p_size)
			return(EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (np->p_fstype == FS_UNUSED && op->p_fstype != FS_UNUSED) {
			np->p_fstype = op->p_fstype;
			np->p_fsize  = op->p_fsize;
			np->p_frag   = op->p_frag;
			np->p_cpg    = op->p_cpg;
		}
	}
 	nlp->d_checksum = 0;
 	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return(0);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev, strat, lp, clp)
dev_t			dev;
void			(*strat)();
struct disklabel	*lp;
struct cpu_disklabel	*clp;
{
	struct buf	*bp;
	u_int32_t	bbo;
	int		rv;

	bbo = clp->cd_bblock;
	if (bbo == NO_BOOT_BLOCK)
		return(ENXIO);

	bp = geteblk(BBSIZE);
	bp->b_dev      = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);
	bp->b_flags    = B_BUSY | B_READ;
	bp->b_bcount   = BBSIZE;
	bp->b_blkno    = bbo;
	bp->b_cylinder = bbo / lp->d_secpercyl;
	(*strat)(bp);
	rv = biowait(bp);
	if (!rv) {
		struct disklabel *nlp = (struct disklabel *)
				((char *)bp->b_data + LABELOFFSET);
		*nlp = *lp;
		bp->b_flags    = B_BUSY | B_WRITE;
		bp->b_bcount   = BBSIZE;
		bp->b_blkno    = bbo;
		bp->b_cylinder = bbo / lp->d_secpercyl;
		(*strat)(bp);
		rv = biowait(bp);
	}
	bp->b_flags |= B_INVAL | B_AGE;
	brelse(bp);
	return(rv);
}

/*
 * Read bootblock at block `offset' and check
 * if it contains a valid disklabel.
 * Returns 0 if an error occured, 1 if successfull.
 */
static int
real_label(dev, strat, offset, lp)
dev_t			dev;
void			(*strat)();
u_int32_t		offset;
struct disklabel	*lp;
{
	struct buf		*bp;
	int			rv = 0;

	bp = geteblk(BBSIZE);
	bp->b_dev      = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);
	bp->b_flags    = B_BUSY | B_READ;
	bp->b_bcount   = BBSIZE;
	bp->b_blkno    = offset;
	bp->b_cylinder = offset / lp->d_secpercyl;
	(*strat)(bp);
	if (!biowait(bp)) {
		struct disklabel *nlp = (struct disklabel *)
				((char *)bp->b_data + LABELOFFSET);
		if (nlp->d_magic == DISKMAGIC && nlp->d_magic2 == DISKMAGIC
	  	  && dkcksum(nlp) == 0 && nlp->d_npartitions <= MAXPARTITIONS) {
			*lp = *nlp;
			rv  = 1;
		}
	}
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
	return(rv);
}

/*
 * Check for consistency between the NetBSD partition table
 * and the TOS auxilary root sectors. There's no good reason
 * to force such consistency, but issueing a warning may help
 * an inexperienced sysadmin to prevent corruption of TOS
 * partitions.
 */
static void
chck_label(lp, clp)
struct disklabel	*lp;
struct cpu_disklabel	*clp;
{
	u_int32_t	*rp;
	int		i;

	for (i = 0; i < lp->d_npartitions; ++i) {
		struct partition *p = &lp->d_partitions[i];
		if (p->p_size == 0 || i == RAW_PART)
			continue;
		if ( (p->p_offset <= clp->cd_bslst
		   && p->p_offset + p->p_size > clp->cd_bslst)
		  || (p->p_offset > clp->cd_bslst
		   && clp->cd_bslst + clp->cd_bslsize > p->p_offset)) {
			uprintf("Warning: NetBSD partition %c includes"
				" AHDI bad sector list\n", 'a'+i);
		}
		for (rp = &clp->cd_roots[0]; *rp; ++rp) {
			if (*rp >= p->p_offset
			  && *rp < p->p_offset + p->p_size) {
				uprintf("Warning: NetBSD partition %c"
				" includes AHDI auxilary root\n", 'a'+i);
			}
		}
	}
}

/*
 * Map the partition table from TOS to the NetBSD table.
 *
 * This means:
 *  Part 0   : Root
 *  Part 1   : Swap
 *  Part 2   : Whole disk
 *  Part 3.. : User partitions
 *
 * When more than one root partition is found, only the first one will
 * be recognized as such. The others are mapped as user partitions.
 */
static void
fake_label(lp, tt)
struct disklabel	*lp;
struct tos_table	*tt;
{
	int		i, have_root, user_part;

	user_part = RAW_PART;
	have_root = (tt->tt_bblock != NO_BOOT_BLOCK);

	for (i = 0; i < tt->tt_nparts; ++i) {
		struct tos_part	*tp = &tt->tt_parts[i];
		int		fst, pno = -1;

		switch (*((u_int32_t *)&tp->tp_flg)) {
			case PID_NBD:
				/*
				 * If this partition has been marked as the
				 * first NBD partition, it will be the root
				 * partition.
				 */
				if (tp->tp_st == tt->tt_bblock)
					pno = 0;
				/* FALL THROUGH */
			case PID_NBR:
				/*
				 * If there is no NBD partition and this is
				 * the first NBR partition, it will be the
				 * root partition.
				 */
				if (!have_root) {
					have_root = 1;
					pno = 0;
				}
				/* FALL THROUGH */
			case PID_NBU:
				fst = FS_BSDFFS;
				break;
			case PID_NBS:
			case PID_SWP:
				if (lp->d_partitions[1].p_size == 0)
					pno = 1;
				fst = FS_SWAP;
				break;
			case PID_BGM:
			case PID_GEM:
				fst = FS_MSDOS;
				break;
			default:
				fst = FS_OTHER;
				break;
		}
		if (pno < 0) {
			if((pno = user_part + 1) >= MAXPARTITIONS)
				continue;
			user_part = pno;
		}
		lp->d_partitions[pno].p_size   = tp->tp_size;
		lp->d_partitions[pno].p_offset = tp->tp_st;
		lp->d_partitions[pno].p_fstype = fst;
	}
	lp->d_npartitions = user_part + 1;
}

/*
 * Create a list of TOS partitions in tos_table `tt'.
 * Returns 0 if an error occured, 1 if successfull,
 * or 2 if no TOS partition table exists.
 */
static int
rd_rootparts(dev, strat, spc, spu, tt)
dev_t			dev;
void			(*strat)();
u_int32_t		spc, spu;
struct tos_table	*tt;
{
	struct tos_root	*root;
	struct buf	*bp;
	int		i, j, rv = 0;

	bp = geteblk(TOS_BSIZE);
	bp->b_dev      = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);
	bp->b_flags    = B_BUSY | B_READ;
	bp->b_bcount   = TOS_BSIZE;
	bp->b_blkno    = TOS_BBLOCK;
	bp->b_cylinder = TOS_BBLOCK / spc;
	(*strat)(bp);
	if (biowait(bp))
		goto done;
	root = (struct tos_root *)bp->b_data;

	MACHDSBR_DEBUG(("hdsize: %lu bsl-start: %lu bsl-size: %lu\n",
	(u_long)root->tr_hdsize, (u_long)root->tr_bslst,
	(u_long)root->tr_bslsize));

	if (!root->tr_hdsize || (!root->tr_bslsize && root->tr_bslst)) {
		rv = 2; goto done;
	}
	for (i = 0; i < NTOS_PARTS; ++i) {
		struct tos_part	*part = &root->tr_parts[i];
		if (!(part->tp_flg & 1)) /* skip invalid entries */
			continue;
		MACHDSBR_DEBUG(("  %c%c%c %9lu %9lu\n",
		  part->tp_id[0], part->tp_id[1], part->tp_id[2],
		    (u_long)part->tp_st, (u_long)part->tp_size));
		if (part->tp_st == 0 || part->tp_st >= spu
		  || part->tp_size == 0 || part->tp_size >= spu
		  || part->tp_st + part->tp_size > spu)
			goto done;
		if ( (part->tp_st <= root->tr_bslst
		   && part->tp_st + part->tp_size > root->tr_bslst)
		  || (part->tp_st >  root->tr_bslst
		   && root->tr_bslst + root->tr_bslsize > part->tp_st))
			goto done;
		if (add_tospart(part, tt) && !rd_extparts(dev, strat,
					spc, part->tp_st, part->tp_size, tt))
			goto done;
	}
	if (tt->tt_nparts > MAX_TOS_PARTS)
		goto done;	/* too many partitions for us */
	/*
	 * Allthough the AHDI 3.0 specifications do not prohibit
	 * a root sector with only invalid partition entries in
	 * it, this situation would be most unlikely.
	 */
	if (!tt->tt_nparts) {
		rv = 2; goto done;
	}
	for (i = 0; i < tt->tt_nparts; ++i) {
		struct tos_part	*p1 = &tt->tt_parts[i];
		for (j = 0; j < i; ++j) {
			struct tos_part	*p2 = &tt->tt_parts[j];
			if ( (p1->tp_st <= p2->tp_st
			   && p1->tp_st + p1->tp_size > p2->tp_st)
			  || (p1->tp_st >  p2->tp_st
			   && p2->tp_st + p2->tp_size > p1->tp_st))
				goto done;
		}
	}
	tt->tt_bslsize = root->tr_bslsize;
	tt->tt_bslst   = root->tr_bslst;
	rv = 1;
done:
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
	return(rv);
}

/*
 * Add all subpartitions within an extended
 * partition to tos_table `tt'.
 * Returns 0 if an error occured, 1 if successfull.
 */
static int
rd_extparts(dev, strat, spc, extst, extsize, tt)
dev_t			dev;
void			(*strat)();
u_int32_t		spc, extst, extsize;
struct tos_table	*tt;
{
	struct buf	*bp;
	u_int32_t	subst = extst, subsize = extsize;
	int		rv = 0;

	bp = geteblk(TOS_BSIZE);
	bp->b_dev = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);

	for (;;) {
		struct tos_root	*root = (struct tos_root *)bp->b_data;
		struct tos_part	*part = root->tr_parts;

		MACHDSBR_DEBUG(("auxilary root at sector %lu\n",(u_long)subst));
		bp->b_flags    = B_BUSY | B_READ;
		bp->b_bcount   = TOS_BSIZE;
		bp->b_blkno    = subst;
		bp->b_cylinder = subst / spc;
		(*strat)(bp);
		if (biowait(bp))
			goto done;
		/*
		 * The first entry in an auxilary root sector must be
		 * marked as valid. The entry must describe a normal
		 * partition. The partition must not extend beyond
		 * the boundaries of the subpartition that it's
		 * part of.
		 */
		MACHDSBR_DEBUG(("  %c%c%c %9lu %9lu\n",
		  part->tp_id[0], part->tp_id[1], part->tp_id[2],
		    (u_long)part->tp_st, (u_long)part->tp_size));
		if (!(part->tp_flg & 1)
#if 0 /* LWP: Temporary hack */
		  || part->tp_st == 0 || part->tp_st >= subsize
		  || part->tp_size == 0 || part->tp_size >= subsize
		  || part->tp_st + part->tp_size > subsize) {
#else
		  || part->tp_st == 0
		  || part->tp_size == 0
		  || part->tp_size >= extsize) {
#endif
			MACHDSBR_DEBUG(("first entry exceeds parent\n"));
			goto done;
		}
		part->tp_st += subst;
		if (add_tospart(part++, tt)) {
			MACHDSBR_DEBUG(("first entry is XGM\n"));
			goto done;
		}
		/*
		 * If the second entry in an auxilary rootsector is
		 * marked as invalid, we've reached the end of the
		 * linked list of subpartitions.
		 */
		if (!(part->tp_flg & 1)) {
			rv = 1;
			goto done;
		}
		/*
		 * If marked valid, the second entry in an auxilary
		 * rootsector must describe a subpartition (id XGM).
		 * The subpartition must not extend beyond the
		 * boundaries of the extended partition that
		 * it's part of.
		 */
		MACHDSBR_DEBUG(("  %c%c%c %9lu %9lu\n",
		  part->tp_id[0], part->tp_id[1], part->tp_id[2],
		    (u_long)part->tp_st, (u_long)part->tp_size));
#if 0 /* LWP: Temporary hack */
		if (part->tp_st == 0 || part->tp_st >= extsize
		  || part->tp_size == 0 || part->tp_size >= extsize
		  || part->tp_st + part->tp_size > extsize) {
#else
		if (part->tp_st == 0
		  || part->tp_st >= extsize
		  || part->tp_size == 0) {
#endif
			MACHDSBR_DEBUG(("second entry exceeds parent\n"));
			goto done;
		}
		part->tp_st += extst;
		if (!add_tospart(part, tt)) {
			MACHDSBR_DEBUG(("second entry is not XGM\n"));
			goto done;
		}
		subst   = part->tp_st;
		subsize = part->tp_size;
	}
done:
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
	return(rv);
}

/*
 * Add a TOS partition or an auxilary root sector
 * to the appropriate list in tos_table `tt'.
 * Returns 1 if `tp' is an XGM partition, otherwise 0.
 */
static int
add_tospart (tp, tt)
struct tos_part		*tp;
struct tos_table	*tt;
{
	u_int32_t	i;

	tp->tp_flg = 0;
	i = *((u_int32_t *)&tp->tp_flg);
	if (i == PID_XGM) {
		i = tt->tt_nroots++;
		if (i < MAX_TOS_ROOTS)
			tt->tt_roots[i] = tp->tp_st;
		return 1;
	}
	i = tt->tt_nparts++;
	if (i < MAX_TOS_PARTS)
		tt->tt_parts[i] = *tp;
	return 0;
}
@


1.5
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@@


1.5.12.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@@


1.4
log
@update from netbsd (verbatim)
@
text
@d77 5
a81 4
bounds_check_with_label(bp, lp, wlabel)
struct buf		*bp;
struct disklabel	*lp;
int			wlabel;
@


1.3
log
@from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.3.2.3 1995/11/21 11:30:22 leo Exp $	*/
@


1.2
log
@update from netbsd tree
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.3.2.1 1995/10/21 21:34:19 leo Exp $	*/
a34 1
#include <sys/malloc.h>
a52 2
static void check_label __P((struct disklabel *, struct cpu_disklabel *));
static void fake_label __P((struct disklabel *, struct cpu_disklabel *));
d54 7
a60 5
static int  rd_rootparts __P((dev_t, void (*)(), u_int32_t,
						struct cpu_disklabel *));
static int  rd_extparts __P((dev_t, void (*)(), u_int32_t, u_int32_t,
				u_int32_t, struct cpu_disklabel *));
static int  add_tospart __P((struct cpu_disklabel *, struct tos_part *));
d87 1
a87 1
		if (bp->b_bcount & (DEV_BSIZE - 1)) {
d143 4
a146 1
	int		i;
d151 2
a154 4
	if (lp->d_secsize == 0)
		lp->d_secsize = DEV_BSIZE;
	else if ((lp->d_secsize % DEV_BSIZE) != 0)
		return("Illegal secsize");
d157 1
a157 1
	for (i = 0; i < MAXPARTITIONS; i++) {
d168 2
a169 3
	 					(u_long)DISKUNIT(dev),
						(u_long)lp->d_secsize,
						(u_long)lp->d_secperunit));
d172 9
a180 4
	 * The `native' TOS (actually AHDI) partition layout requires
	 * a 512 byte sector size, therefore we can safely assume that
	 * a device with a different sector size is not `infected' by
	 * HDX cs.
d182 27
a208 28
	bzero(clp, sizeof *clp);
	if (lp->d_secsize == TOS_BSIZE
	  && rd_rootparts(dev, strat, lp->d_secpercyl, clp)) {
		/*
		 * This volume carries an AHDI compatible partition layout.
		 * Search for a partition with id NBD or RAW, which contains
		 * a NetBSD boot block with a valid disk label in it.
		 */
		MACHDSBR_DEBUG(("AHDI partition table: "));
		for (i = 0; i < clp->cd_npartitions; i++) {
			struct cpu_partition	*cp = &clp->cd_partitions[i];
			u_int32_t		id = cp->cp_id;
			if (id != CPU_PID_NBD && id != CPU_PID_RAW)
				continue;
			if (!real_label(dev, strat, cp->cp_st, lp)) {
				/*
				 * No disk label, but if this is the first NBD
				 * partition on this volume, we'll mark it
				 * anyway as a possible destination for future
				 * writedisklabel() calls, just in case there
				 * is no valid disk label on any of the
				 * other AHDI partitions.
				 */
				if (id == CPU_PID_NBD
					&& clp->cd_labelpart == NULL)
					clp->cd_labelpart = cp;
				continue;
			}
d210 5
a214 3
			 * Found a valid disk label, mark this TOS partition for
			 * writedisklabel(), and check for possibly dangerous
			 * overlap between TOS and NetBSD partition layout.
d216 4
a219 14
			MACHDSBR_DEBUG(("found real disklabel\n"));
			clp->cd_labelpart = cp;
			check_label(lp, clp);
			break;
		}
		if (i == clp->cd_npartitions) {
			/*
			 * No disk label on this volume, use the TOS partition
			 * layout to create a fake disk label. If there is no
			 * NBD partition on this volume either, subsequent
			 * writedisklabel() calls will fail.
			 */
			MACHDSBR_DEBUG(("creating fake disklabel\n"));
			fake_label(lp, clp);
a220 1
	} else {
d222 3
a224 6
		 * This volume carries no AHDI compatible partition layout,
		 * therefor the boot block must be located at the start of the
		 * volume. If the boot block does not contain a valid disk
		 * label, chances are this volume has never been used before,
		 * so the best we can do is to pretend that there's only one
		 * partition.
d226 4
a229 11
		MACHDSBR_DEBUG(("No AHDI partition table: "));
		if (!real_label(dev, strat, LABELSECTOR, lp)) {
			MACHDSBR_DEBUG(("unpartitioned unit\n"));
			lp->d_partitions[RAW_PART+1].p_size
					= lp->d_partitions[RAW_PART].p_size;
			lp->d_partitions[RAW_PART+1].p_offset
					= lp->d_partitions[RAW_PART].p_offset;
			lp->d_partitions[RAW_PART+1].p_fstype = FS_BSDFFS;
			lp->d_npartitions = RAW_PART + 2;
		}
		else MACHDSBR_DEBUG(("disklabel OK\n"));
d231 8
d243 1
d266 1
a266 1
	/* sanity checks */
d272 2
a273 6
	/* 
	 * If a TOS partition table exists, do an advisory check
	 * for consistency between NetBSD and TOS partition table.
	 */
	if (clp->cd_partitions != NULL)
		check_label(nlp, clp);
a277 1

d313 1
a313 1
	u_int32_t	bbo = LABELSECTOR;
d316 4
a319 5
	if (clp->cd_partitions != NULL) {
		if (clp->cd_labelpart == NULL)
			return(ENXIO);
		bbo = clp->cd_labelpart->cp_st;
	}
d345 41
a385 5
 * Check for consistency between the NetBSD partition table in
 * disklabel `lp' and the TOS partition table in cpu_disklabel
 * `clp'. There's no good reason to force such consistency, but
 * issueing a warning may help an inexperienced sysadmin to
 * prevent corruption of TOS partitions.
d388 1
a388 1
check_label(lp, clp)
d392 2
a393 1
	int			i, j;
d395 1
a395 1
	for (i = 0; i < lp->d_npartitions; i++) {
d403 2
a404 2
			printf("Warning: NetBSD partition `%c' contains "
				"the AHDI bad sector list\n", 'a'+i);
d406 5
a410 11

		for (j = 0; j < clp->cd_npartitions; j++) {
			struct cpu_partition *cp = &clp->cd_partitions[i];
			if (cp->cp_id != CPU_PID_XGM)
				continue;
			if (cp->cp_st >= p->p_offset
			  && cp->cp_st < p->p_offset + p->p_size) {
				printf("Warning: NetBSD partition `%c' "
					"contains an AHDI auxilary root "
					"sector\n", 'a'+i);
				break;
d429 1
a429 1
fake_label(lp, clp)
d431 1
a431 1
struct cpu_disklabel	*clp;
d433 1
a433 1
	int	i, have_root, user_part;
d436 1
a436 1
	have_root = (clp->cd_labelpart != NULL);
d438 3
a440 3
	for (i = 0; i < clp->cd_npartitions; i++) {
		struct cpu_partition	*cp = &clp->cd_partitions[i];
		int			fst, pno = -1;
d442 2
a443 4
		switch (cp->cp_id) {
			case CPU_PID_XGM:
				continue;
			case CPU_PID_NBD:
d449 1
a449 1
				if (cp == clp->cd_labelpart)
d452 1
a452 1
			case CPU_PID_NBR:
d463 1
a463 1
			case CPU_PID_NBU:
d466 2
a467 2
			case CPU_PID_NBS:
			case CPU_PID_SWP:
d472 2
a473 2
			case CPU_PID_BGM:
			case CPU_PID_GEM:
d481 3
a483 3
			pno = ++user_part;
			if(pno >= MAXPARTITIONS)
				break;	/* XXX */
d485 2
a486 2
		lp->d_partitions[pno].p_size   = cp->cp_size;
		lp->d_partitions[pno].p_offset = cp->cp_st;
d493 3
a495 3
 * Read bootblock at block `offset' and check
 * if it contains a valid disklabel.
 * Returns 0 if an error occured, 1 if successfull.
d498 1
a498 1
real_label(dev, strat, offset, lp)
d501 2
a502 37
u_int32_t		offset;
struct disklabel	*lp;
{
	struct buf		*bp;
	int			rv = 0;

	bp = geteblk(BBSIZE);
	bp->b_dev      = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);
	bp->b_flags    = B_BUSY | B_READ;
	bp->b_bcount   = BBSIZE;
	bp->b_blkno    = offset;
	bp->b_cylinder = offset / lp->d_secpercyl;
	(*strat)(bp);
	if (!biowait(bp)) {
		struct disklabel *nlp = (struct disklabel *)
				((char *)bp->b_data + LABELOFFSET);
		if (nlp->d_magic == DISKMAGIC && nlp->d_magic2 == DISKMAGIC
	  	  && dkcksum(nlp) == 0 && nlp->d_npartitions <= MAXPARTITIONS) {
			*lp = *nlp;
			rv  = 1;
		}
	}
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
	return(rv);
}

/*
 * Create a list of TOS partitions in cpu_disklabel `clp'.
 * Returns 0 if an error occured, 1 if successfull.
 */
static int
rd_rootparts(dev, strat, spc, clp)
dev_t			dev;
void			(*strat)();
u_int32_t		spc;
struct cpu_disklabel	*clp;
a506 1
	int		ntospart  = 0;
d517 1
a518 1
	root = (struct tos_root *)bp->b_data;
d520 2
a521 2
	 		(u_long)root->tr_hdsize, (u_long)root->tr_bslst,
			(u_long)root->tr_bslsize));
d523 3
a529 1
		ntospart++;
d533 5
a537 8
		/*
		 * a primary partition (normal or extended) must
		 * have a size >= 1 and must not interfere with
		 * the bad sector list, nor with any of the
		 * other primary partitions.
		 */
		if (part->tp_st == 0 || part->tp_size == 0
		  || (part->tp_st <= root->tr_bslst
d542 16
d559 5
a563 5
			struct tos_part	*p = &root->tr_parts[j];
			if ( (p->tp_st <= part->tp_st
			   && p->tp_st + p->tp_size > part->tp_st)
			  || (p->tp_st >  part->tp_st
			   && part->tp_st + part->tp_size > p->tp_st))
a565 3
		if (add_tospart(clp, part)
		  && !rd_extparts(dev,strat,spc,part->tp_st,part->tp_size,clp))
			goto done;
d567 3
a569 3
	rv = ntospart ? 1 : 0;
	clp->cd_bslst   = root->tr_bslst;
	clp->cd_bslsize = root->tr_bslsize;
a570 5
	if (!rv && clp->cd_partitions != NULL) {
		FREE(clp->cd_partitions, M_DEVBUF);
		clp->cd_partitions  = NULL;
		clp->cd_npartitions = 0;
	}
d578 1
a578 1
 * partition to cpu_disklabel `clp'.
d582 1
a582 1
rd_extparts(dev, strat, spc, extst, extsize, clp)
d586 1
a586 1
struct cpu_disklabel	*clp;
d590 1
a590 1
	int		i, rv = 0, pno = clp->cd_npartitions;
d593 1
a593 1
	bp->b_dev    = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);
d618 1
d622 5
d631 1
a631 1
		if (add_tospart(clp, part++)) {
d648 2
a649 4
		 * boundaries of the extended partition that it's
		 * part of. The subpartition must not share any
		 * sectors with any other subpartition on this
		 * extended partition.
d654 1
d658 5
d667 1
a667 14
		for (i = pno; i < clp->cd_npartitions; ++i) {
			struct cpu_partition *cp = &clp->cd_partitions[i];
			if (cp->cp_id != CPU_PID_XGM)
				continue; /* skip normal partitions */
			if ( (cp->cp_st <= part->tp_st
			   && cp->cp_st + cp->cp_size > part->tp_st)
			  || (cp->cp_st >  part->tp_st
			   && part->tp_st + part->tp_size > cp->cp_st)) {
				MACHDSBR_DEBUG(("second entry not "
				  "consistent with subpartition %u\n", i));
				goto done;
			}
		}
		if (!add_tospart(clp, part)) {
d671 1
a672 1
		subst   = part->tp_st;
d681 2
a682 2
 * Add a TOS partition to the list of TOS partitions
 * in cpu_disklabel `clp'.
d686 1
a686 2
add_tospart (clp, tp)
struct cpu_disklabel	*clp;
d688 1
d690 1
a690 2
	struct cpu_partition	*cp;
	int			i;
d692 12
a703 18
	i = clp->cd_npartitions;
	if ((i & 15) == 0) {
		MALLOC(cp, struct cpu_partition *, (i + 16)
				* sizeof *cp, M_DEVBUF, M_WAITOK);
		if (i) {
			bcopy(clp->cd_partitions, cp, i * sizeof *cp);
			FREE(clp->cd_partitions, M_DEVBUF);
		}
		clp->cd_partitions = cp;
	}
	clp->cd_npartitions += 1;
	cp = clp->cd_partitions + i;
	cp->cp_st   = tp->tp_st;
	cp->cp_size = tp->tp_size;
	cp->cp_id   = (u_int32_t)tp->tp_id[2];
	cp->cp_id  |= (u_int32_t)tp->tp_id[1] << 8;
	cp->cp_id  |= (u_int32_t)tp->tp_id[0] << 16;
	return(cp->cp_id == CPU_PID_XGM);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.3 1995/08/05 20:24:16 leo Exp $	*/
d88 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
