head	1.61;
access;
symbols
	OPENBSD_6_0:1.59.0.6
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.51.0.4
	OPENBSD_5_6_BASE:1.51
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.4
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.38.0.4
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.2
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11;
locks; strict;
comment	@ * @;


1.61
date	2016.08.14.13.29.22;	author jsg;	state Exp;
branches;
next	1.60;
commitid	2piU8645mnYocQLk;

1.60
date	2016.08.08.19.27.12;	author kettenis;	state Exp;
branches;
next	1.59;
commitid	9cxQ5QuyMM8g8ZRp;

1.59
date	2015.05.10.15.56.28;	author jsg;	state Exp;
branches;
next	1.58;
commitid	MKYLBBkRhYmhiqiC;

1.58
date	2015.05.08.22.56.53;	author miod;	state Exp;
branches;
next	1.57;
commitid	fFmwBnB0cqyL2Ewy;

1.57
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.56;
commitid	dNPv28CJI5BxtRGW;

1.56
date	2015.01.18.10.17.42;	author jsg;	state Exp;
branches;
next	1.55;
commitid	EinLpFIBT92msrml;

1.55
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.54;
commitid	qHQiR2HLROzvZr7B;

1.54
date	2014.12.03.20.09.32;	author krw;	state Exp;
branches;
next	1.53;
commitid	rapVfhq63upxHrrZ;

1.53
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	yv0ECmCdICvq576h;

1.52
date	2014.09.20.09.28.25;	author kettenis;	state Exp;
branches;
next	1.51;
commitid	IFRB8AkvBMXMTAKW;

1.51
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.50;
commitid	7QO4UJr3EKVAMc8t;

1.50
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.49;
commitid	wsdp3qtXGjMj98oD;

1.49
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.48;
commitid	qYPOd6Qi4aRBKldK;

1.48
date	2014.07.11.10.10.44;	author uebayasi;	state Exp;
branches;
next	1.47;
commitid	FTpUOFPNW9IfQUG9;

1.47
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.46;
commitid	iYq3Z1ZWDKR3sS9G;

1.46
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.45;
commitid	YzvTa4t6mddz7Mh4;

1.45
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.44;
commitid	aofvn6ceiucgjg4N;

1.44
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.43;
commitid	eA4Y0YE1IUzj6hpW;

1.43
date	2014.05.30.13.46.17;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2014.03.13.03.52.56;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2013.09.28.14.16.42;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2012.08.30.15.51.13;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2011.10.19.20.18.31;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2011.05.30.22.25.23;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2010.10.02.23.31.34;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.27.06.21.44;	author beck;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.26.01.29.00;	author kevlo;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.25.14.55.44;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.08.20.56.33;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.23.17.05.42;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.19.15.49.06;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.10.16.43.37;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.20.18.24.04;	author todd;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.02.20.50.00;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.17.20.30.12;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.17.07.31.27;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.14.15.08.51;	author uwe;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.14.14.39.38;	author uwe;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.11.23.50.03;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.01.23.56.47;	author uwe;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.27.18.42.15;	author uwe;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.24.20.32.43;	author uwe;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.09.15.32.19;	author uwe;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.02.02.45.29;	author uwe;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.11.03.22.59;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.26.16.46.19;	author uwe;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.23.00.01.09;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.13.22.20.03;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.31.17.33.58;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.24.22.20.32;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.21.16.22.34;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.17.22.59.57;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.14.18.44.08;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.14.01.17.03;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.12.17.14.37;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.04.05.33.24;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.31.00.04.35;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.61
log
@remove uneeded sa1111_reg.h include
ok kettenis@@
@
text
@/*	$OpenBSD: zaurus_machdep.c,v 1.60 2016/08/08 19:27:12 kettenis Exp $	*/
/*	$NetBSD: lubbock_machdep.c,v 1.2 2003/07/15 00:25:06 lukem Exp $ */

/*
 * Copyright (c) 2002, 2003  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Genetec Corporation may not be used to endorse or 
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Machine dependant functions for kernel setup for 
 * Intel DBPXA250 evaluation board (a.k.a. Lubbock).
 * Based on iq80310_machhdep.c
 */
/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997,1998 Mark Brinicombe.
 * Copyright (c) 1997,1998 Causality Limited.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mark Brinicombe
 *	for the NetBSD Project.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Machine dependant functions for kernel setup for Intel IQ80310 evaluation
 * boards using RedBoot firmware.
 */

/*
 * DIP switches:
 *
 * S19: no-dot: set RB_KDB.  enter kgdb session.
 * S20: no-dot: set RB_SINGLE. don't go multi user mode.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/exec.h>
#include <sys/proc.h>
#include <sys/msgbuf.h>
#include <sys/reboot.h>
#include <sys/termios.h>
#include <sys/kcore.h>

#include <uvm/uvm_extern.h>

#include <sys/conf.h>
#include <sys/queue.h>
#include <dev/cons.h>
#include <sys/socket.h>

#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#ifdef KGDB
#include <sys/kgdb.h>
#endif

#include <net/if.h>

#include <machine/bootconfig.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/frame.h>
#include <arm/kcore.h>
#include <arm/undefined.h>
#include <arm/machdep.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0_gpio.h>
#include <machine/machine_reg.h>
#include <machine/zaurus_var.h>

#include <zaurus/dev/zaurus_scoopreg.h>

#include "apm.h"
#if NAPM > 0
#include <zaurus/dev/zaurus_apm.h>
#endif

#include "wsdisplay.h"

/* Kernel text starts 2MB in from the bottom of the kernel address space. */
#define	KERNEL_TEXT_BASE	(KERNEL_BASE + 0x00200000)
#define	KERNEL_VM_BASE		(KERNEL_BASE + 0x04000000)
#define KERNEL_VM_SIZE		VM_KERNEL_SPACE_SIZE

/*
 * Address to call from cpu_reset() to reset the machine.
 * This is machine architecture dependant as it varies depending
 * on where the ROM appears when you turn the MMU off.
 */

u_int cpu_reset_address = 0;

/* Define various stack sizes in pages */
#define IRQ_STACK_SIZE	1
#define ABT_STACK_SIZE	1
#define UND_STACK_SIZE	1

int zaurusmod;

BootConfig bootconfig;		/* Boot config storage */
char *boot_args = NULL;
char *boot_file = NULL;

paddr_t physical_start;
paddr_t physical_freestart;
paddr_t physical_freeend;
paddr_t physical_end;
u_int free_pages;
int physmem = 0;

/*int debug_flags;*/
#ifndef PMAP_STATIC_L1S
int max_processes = 64;			/* Default number */
#endif	/* !PMAP_STATIC_L1S */

/* Physical and virtual addresses for some global pages */
pv_addr_t systempage;
pv_addr_t irqstack;
pv_addr_t undstack;
pv_addr_t abtstack;
extern pv_addr_t kernelstack;
pv_addr_t minidataclean;

paddr_t msgbufphys;

extern u_int data_abort_handler_address;
extern u_int prefetch_abort_handler_address;
extern u_int undefined_handler_address;

#ifdef PMAP_DEBUG
extern int pmap_debug_level;
#endif

#define KERNEL_PT_SYS		0	/* Page table for mapping proc0 zero page */
#define KERNEL_PT_KERNEL	1	/* Page table for mapping kernel */
#define	KERNEL_PT_KERNEL_NUM	32
#define KERNEL_PT_VMDATA	(KERNEL_PT_KERNEL+KERNEL_PT_KERNEL_NUM)
				        /* Page tables for mapping kernel VM */
#define	KERNEL_PT_VMDATA_NUM	8	/* start with 32MB of KVM */
#define NUM_KERNEL_PTS		(KERNEL_PT_VMDATA + KERNEL_PT_VMDATA_NUM)

pv_addr_t kernel_pt_table[NUM_KERNEL_PTS];

extern struct user *proc0paddr;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

/* Prototypes */

#define	BOOT_STRING_MAGIC 0x4f425344

char	bootargs[MAX_BOOT_STRING];
void	process_kernel_args(char *);

void	consinit(void);
void	early_clkman(u_int, int);
void	kgdb_port_init(void);
void	change_clock(uint32_t v);

bs_protos(bs_notimpl);

#include "com.h"
#if NCOM > 0
#include <dev/ic/comvar.h>
#include <dev/ic/comreg.h>
#endif

#ifndef CONSPEED
#define CONSPEED B9600	/* What RedBoot uses */
#endif
#ifndef CONMODE
#define CONMODE ((TTYDEF_CFLAG & ~(CSIZE | CSTOPB | PARENB)) | CS8) /* 8N1 */
#endif

int comcnspeed = CONSPEED;
int comcnmode = CONMODE;


/*
 * void boot(int howto)
 *
 * Reboots the system
 *
 * Deal with any syncing, unmounting, dumping and shutdown hooks,
 * then reset the CPU.
 */
__dead void
boot(int howto)
{
	extern int lid_suspend;

	if ((howto & RB_POWERDOWN) != 0)
		lid_suspend = 0;

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	/*
	 * If RB_NOSYNC was not specified sync the discs.
	 * Note: Unless cold is set to 1 here, syslogd will die during the
	 * unmount.  It looks like syslogd is getting woken up only to find
	 * that it cannot page part of the binary in as the filesystem has
	 * been unmounted.
	 */
	if ((howto & RB_NOSYNC) == 0)
		bootsync(howto);

	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	/* Make sure IRQ's are disabled */
	IRQdisable;

	if ((howto & RB_HALT) != 0) {
#if NAPM > 0
		if ((howto & RB_POWERDOWN) != 0) {

			printf("\nAttempting to power down...\n");
			delay(6000000);
			zapm_poweroff();
		}
#endif

		printf("The operating system has halted.\n");
		printf("Please press any key to reboot.\n\n");
		cnpollc(1);
		cngetc();
		cnpollc(0);
	}

	printf("rebooting...\n");
	delay(6000000);
#if NAPM > 0
	zapm_restart();
#endif
	printf("reboot failed; spinning\n");
	for (;;) ;
	/* NOTREACHED */
}

static __inline
pd_entry_t *
read_ttb(void)
{
  long ttb;

  __asm volatile("mrc	p15, 0, %0, c2, c0, 0" : "=r" (ttb));


  return (pd_entry_t *)(ttb & ~((1<<14)-1));
}

/*
 * Mapping table for core kernel memory. These areas are mapped in
 * init time at fixed virtual address with section mappings. 
 */
struct l1_sec_map {
	vaddr_t	va;
	vaddr_t	pa;
	vsize_t	size;
	int flags;
} l1_sec_table[] = {
    {
	    ZAURUS_GPIO_VBASE,
	    PXA2X0_GPIO_BASE,
	    PXA2X0_GPIO_SIZE,
	    PTE_NOCACHE,
    },
    {
	    ZAURUS_CLKMAN_VBASE,
	    PXA2X0_CLKMAN_BASE,
	    PXA2X0_CLKMAN_SIZE,
	    PTE_NOCACHE,
    },
    {
	    ZAURUS_INTCTL_VBASE,
	    PXA2X0_INTCTL_BASE,
	    PXA2X0_INTCTL_SIZE,
	    PTE_NOCACHE,
    },
    {
	    ZAURUS_SCOOP0_VBASE,
	    C3000_SCOOP0_BASE,
	    SCOOP_SIZE,
	    PTE_NOCACHE,
    },
    {
	    ZAURUS_SCOOP1_VBASE,
	    trunc_page(C3000_SCOOP1_BASE),
	    round_page(SCOOP_SIZE),
	    PTE_NOCACHE,
    },
    {0, 0, 0, 0,}
};

static void
map_io_area(paddr_t pagedir)
{
	int loop;

	/*
	 * Map devices we can map w/ section mappings.
	 */
	loop = 0;
	while (l1_sec_table[loop].size) {
		vsize_t sz;

#define VERBOSE_INIT_ARM
#ifdef VERBOSE_INIT_ARM
		printf("%08lx -> %08lx @@ %08lx\n", l1_sec_table[loop].pa,
		    l1_sec_table[loop].pa + l1_sec_table[loop].size - 1,
		    l1_sec_table[loop].va);
#endif
		for (sz = 0; sz < l1_sec_table[loop].size; sz += L1_S_SIZE)
			pmap_map_section(pagedir, l1_sec_table[loop].va + sz,
			    l1_sec_table[loop].pa + sz,
			    PROT_READ | PROT_WRITE,
			    l1_sec_table[loop].flags);
		++loop;
	}
}

/*
 * simple memory mapping function used in early bootstrap stage
 * before pmap is initialized.
 * size and cacheability are ignored and map one section with nocache.
 */
static vaddr_t section_free = ZAURUS_VBASE_FREE;

static int
bootstrap_bs_map(void *t, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	u_long startpa;
	vaddr_t va;
	pd_entry_t *pagedir = read_ttb();
	/* This assumes PA==VA for page directory */

	va = section_free;
	section_free += L1_S_SIZE;

	startpa = trunc_page(bpa);
	pmap_map_section((vaddr_t)pagedir, va, startpa, 
	    PROT_READ | PROT_WRITE, PTE_NOCACHE);
	cpu_tlb_flushD();

	*bshp = (bus_space_handle_t)(va + (bpa - startpa));

	return(0);
}

static void
copy_io_area_map(pd_entry_t *new_pd)
{
	pd_entry_t *cur_pd = read_ttb();
	vaddr_t va;

	for (va = ZAURUS_IO_AREA_VBASE;
	     (cur_pd[va>>L1_S_SHIFT] & L1_TYPE_MASK) == L1_TYPE_S;
	     va += L1_S_SIZE) {

		new_pd[va>>L1_S_SHIFT] = cur_pd[va>>L1_S_SHIFT];
		if (va == (0 - L1_S_SIZE))
			break; /* STUPID */

	}
}

/* XXX tidy up! */
void green_on(int virt);
void
green_on(int virt)
{
	/* clobber green led p */
	volatile u_int16_t *p;
	if (virt)
		p = (u_int16_t *)(ZAURUS_SCOOP0_VBASE+SCOOP_GPWR);
	else
		p = (u_int16_t *)(C3000_SCOOP0_BASE+SCOOP_GPWR);

	*p = *p | (1<<SCOOP0_LED_GREEN);
}
void irda_on(int virt);
void
irda_on(int virt)
{
	/* clobber IrDA led p */
	volatile u_int16_t *p;
	/* XXX scoop1 registers are not page-aligned! */
	int ofs = C3000_SCOOP1_BASE - trunc_page(C3000_SCOOP1_BASE);

	if (virt)
		p = (u_int16_t *)(ZAURUS_SCOOP1_VBASE+ofs+SCOOP_GPWR);
	else
		p = (u_int16_t *)(C3000_SCOOP1_BASE+SCOOP_GPWR);

	*p = *p & ~(1<<SCOOP1_IR_ON);
}

#if 0
void sysprobe(void);
void
sysprobe(void)
{
	u_int32_t *p;

	p = (void *)0x48000014; /* MECR */
	printf("MECR %x\n", *p);

	p = (void *)0x48000028; /* MCMEM0 */
	printf("MCMEM0 %x\n", *p); 
	p = (void *)0x4800002C; /* MCMEM1 */
	printf("MCMEM1 %x\n", *p); 

	p = (void *)0x48000030; /* MCATTx */
	printf("MCATT0 %x\n", *p); 
	p = (void *)0x48000034; /* MCATTx */
	printf("MCATT1 %x\n", *p); 

	p = (void *)0x48000038; /* MCIOx */
	printf("MCIO0 %x\n", *p); 
	p = (void *)0x4800003C; /* MCIOx */
	printf("MCIO1 %x\n", *p); 
}
#endif

/*
 * u_int initarm(...)
 *
 * Initial entry point on startup. This gets called before main() is
 * entered.
 * It should be responsible for setting up everything that must be
 * in place when main is called.
 * This includes
 *   Taking a copy of the boot configuration structure.
 *   Initialising the physical console so characters can be printed.
 *   Setting up page tables for the kernel
 *   Relocating the kernel to the bottom of physical memory
 */
u_int
initarm(void *arg0, void *arg1, void *arg2)
{
	extern vaddr_t xscale_cache_clean_addr;
	extern cpu_kcore_hdr_t cpu_kcore_hdr;
	int loop;
	int loop1;
	u_int l1pagetable;
	pv_addr_t kernel_l1pt;
	paddr_t memstart;
	psize_t memsize;
	extern u_int32_t esym;	/* &_end if no symbols are loaded */

#if 0
	int led_data = 0;
#endif
#ifdef DIAGNOSTIC
	extern vsize_t xscale_minidata_clean_size; /* used in KASSERT */
#endif
	/* early bus_space_map support */
	struct bus_space tmp_bs_tag;
	int	(*map_func_save)(void *, bus_addr_t, bus_size_t, int, 
	    bus_space_handle_t *);


#if 0
	/* XXX */
	/* start 32.768KHz OSC */
	ioreg_write(PXA2X0_CLKMAN_BASE + 0x08, 2);
#endif

	/*
	 * Heads up ... Setup the CPU / MMU / TLB functions
	 */
	if (set_cpufuncs())
		panic("cpu not recognized!");

	/* Get ready for splfoo() */
	pxa2x0_intr_bootstrap(PXA2X0_INTCTL_BASE);

#if 0
	/* Calibrate the delay loop. */
#endif

	/*
	 * Okay, RedBoot has provided us with the following memory map:
	 *
	 * Physical Address Range     Description 
	 * -----------------------    ---------------------------------- 
	 * 0x00000000 - 0x01ffffff    flash Memory   (32MB)
	 * 0x04000000 - 0x05ffffff    Application flash Memory  (32MB)
	 * 0x08000000 - 0x080000ff    I/O baseboard registers
	 * 0x0a000000 - 0x0a0fffff    SRAM (1MB)
	 * 0x0c000000 - 0x0c0fffff    Ethernet Controller
	 * 0x0e000000 - 0x0e0fffff    Ethernet Controller (Attribute)
	 * 0x10000000 - 0x103fffff    SA-1111 Companion Chip
	 * 0x14000000 - 0x17ffffff    Expansion Card (64MB)
	 * 0x40000000 - 0x480fffff    Processor Registers
	 * 0xa0000000 - 0xa3ffffff    SDRAM Bank 0 (64MB)
	 *
	 *
	 * Virtual Address Range    X C B  Description 
	 * -----------------------  - - -  ---------------------------------- 
	 * 0x00000000 - 0x00003fff  N Y Y  SDRAM 
	 * 0x00004000 - 0x000fffff  N Y N  Boot ROM
	 * 0x00100000 - 0x01ffffff  N N N  Application Flash
	 * 0x04000000 - 0x05ffffff  N N N  Exp Application Flash
	 * 0x08000000 - 0x080fffff  N N N  I/O baseboard registers
	 * 0x0a000000 - 0x0a0fffff  N N N  SRAM
	 * 0x40000000 - 0x480fffff  N N N  Processor Registers
	 * 0xa0000000 - 0xa000ffff  N Y N  RedBoot SDRAM 
	 * 0xa0017000 - 0xa3ffffff  Y Y Y  SDRAM
	 * 0xc0000000 - 0xcfffffff  Y Y Y  Cache Flush Region 
	 * (done by this routine)
	 * 0xfd000000 - 0xfd0000ff  N N N  I/O baseboard registers
	 * 0xfd100000 - 0xfd2fffff  N N N  Processor Registers.
	 * 0xfd200000 - 0xfd2fffff  N N N  0x10800000 registers
	 *
	 * The first level page table is at 0xa0004000.  There are also
	 * 2 second-level tables at 0xa0008000 and 0xa0008400.
	 *
	 */

	{
		/*
		 * Tweak RedBoot's pagetable so that we can access to
		 * some registers at same VA before and after installing 
		 * our page table. 
		 */
		paddr_t ttb = (paddr_t)read_ttb();

		map_io_area(ttb);
		cpu_tlb_flushD();
	}

	/*
	 * Examine the boot args string for options we need to know about
	 * now.
	 */
	/* XXX should really be done after setting up the console, but we
	 * XXX need to parse the console selection flags right now. */
	process_kernel_args((char *)0xa0200000 - MAX_BOOT_STRING - 1);

	/*
	 * This test will work for now but has to be revised when support
	 * for other models is added.
	 */
	if ((cputype & ~CPU_ID_XSCALE_COREREV_MASK) == CPU_ID_PXA27X)
		zaurusmod = ZAURUS_C3000;
	else
		zaurusmod = ZAURUS_C860;

	/* setup GPIO for BTUART, in case bootloader doesn't take care of it */
	pxa2x0_gpio_bootstrap(ZAURUS_GPIO_VBASE);
#if 0
	pxa2x0_gpio_set_function(42, GPIO_ALT_FN_1_IN);
	pxa2x0_gpio_set_function(43, GPIO_ALT_FN_2_OUT);
	pxa2x0_gpio_set_function(44, GPIO_ALT_FN_1_IN);
	pxa2x0_gpio_set_function(45, GPIO_ALT_FN_2_OUT);

	/* FFUART */
	pxa2x0_gpio_set_function(34, GPIO_ALT_FN_1_IN);
	pxa2x0_gpio_set_function(39, GPIO_ALT_FN_2_OUT);
	pxa2x0_gpio_set_function(35, GPIO_ALT_FN_1_IN);
	pxa2x0_gpio_set_function(40, GPIO_ALT_FN_2_OUT);
	pxa2x0_gpio_set_function(41, GPIO_ALT_FN_2_OUT);

	/* STUART */
	pxa2x0_gpio_set_function(46, GPIO_ALT_FN_2_IN);
	pxa2x0_gpio_set_function(47, GPIO_ALT_FN_1_OUT);
#endif

	/* tell com to drive STUART in slow infrared mode */
	comsiraddr = (bus_addr_t)PXA2X0_STUART_BASE;

#if 1
	/* turn on clock to UART block.
	   XXX this should not be necessary, consinit() will do it */
	early_clkman(CKEN_FFUART | CKEN_BTUART | CKEN_STUART, 1);
#endif

	green_on(0);

	/*
	 * Temporarily replace bus_space_map() functions so that
	 * console devices can get mapped.
	 *
	 * Note that this relies upon the fact that both regular
	 * and a4x bus_space tags use the same map function.
	 */
	tmp_bs_tag = pxa2x0_bs_tag;
	tmp_bs_tag.bs_map = bootstrap_bs_map;
	map_func_save = pxa2x0_bs_tag.bs_map;
	pxa2x0_a4x_bs_tag.bs_map = pxa2x0_bs_tag.bs_map = bootstrap_bs_map;

	/* setup a serial console for very early boot */
	consinit();
#ifdef KGDB
	kgdb_port_init();
#endif

	/* Talk to the user */
	printf("\nOpenBSD/zaurus booting ...\n");

	{
		/* XXX - all Zaurus have this for now, fix memory sizing */
		memstart = 0xa0000000;
		memsize =  0x04000000; /* 64MB */
	}

#if 0
	{
		volatile int *p;
		char *membase;
		char *memmax;
		int  chunksize = 0x02000000;
		printf("probing memory");

		membase = (char *)0xa0000000;
		memmax  = (char *)0xc0000000;
		for (p = (int *)membase;
		    p < (int *)memmax;
		    p = (int *) (((char *)p) + chunksize)) {
			printf ("cbase %p\n", p);
			p[0] = 0x12345678;
			p[1] = 0x12345678;
			if ((p[0] != 0x12345678) || (p[1] != 0x12345678))
				break;
		}
			memsize = ((char *)p) - membase;

		printf("probing memory done found memsize %d\n", memsize);
	}
#else
#endif

#define DEBUG
#ifdef DEBUG
	printf("initarm: Configuring system ...\n");
#endif

	/* Fake bootconfig structure for the benefit of pmap.c */
	/* XXX must make the memory description h/w independant */
	bootconfig.dramblocks = 1;
	bootconfig.dram[0].address = memstart;
	bootconfig.dram[0].pages = memsize / PAGE_SIZE;

	/*
	 * Set up the variables that define the availablilty of
	 * physical memory.  For now, we're going to set
	 * physical_freestart to 0xa0200000 (where the kernel
	 * was loaded), and allocate the memory we need downwards.
	 * If we get too close to the page tables that RedBoot
	 * set up, we will panic.  We will update physical_freestart
	 * and physical_freeend later to reflect what pmap_bootstrap()
	 * wants to see.
	 *
	 * XXX pmap_bootstrap() needs an enema.
	 */
	physical_start = bootconfig.dram[0].address;
	physical_end = physical_start + (bootconfig.dram[0].pages * PAGE_SIZE);

	physical_freestart = 0xa0009000UL;
	physical_freeend = 0xa0200000UL;

	physmem = (physical_end - physical_start) / PAGE_SIZE;

#ifdef DEBUG
	/* Tell the user about the memory */
	printf("physmemory: %d pages at 0x%08lx -> 0x%08lx\n", physmem,
	    physical_start, physical_end - 1);
#endif

	/*
	 * Okay, the kernel starts 2MB in from the bottom of physical
	 * memory.  We are going to allocate our bootstrap pages downwards
	 * from there.
	 *
	 * We need to allocate some fixed page tables to get the kernel
	 * going.  We allocate one page directory and a number of page
	 * tables and store the physical addresses in the kernel_pt_table
	 * array.
	 *
	 * The kernel page directory must be on a 16K boundary.  The page
	 * tables must be on 4K bounaries.  What we do is allocate the
	 * page directory on the first 16K boundary that we encounter, and
	 * the page tables on 4K boundaries otherwise.  Since we allocate
	 * at least 3 L2 page tables, we are guaranteed to encounter at
	 * least one 16K aligned region.
	 */

#ifdef VERBOSE_INIT_ARM
	printf("Allocating page tables\n");
#endif

	free_pages = (physical_freeend - physical_freestart) / PAGE_SIZE;

#ifdef VERBOSE_INIT_ARM
	printf("freestart = 0x%08lx, free_pages = %d (0x%08x)\n",
	       physical_freestart, free_pages, free_pages);
#endif

	/* Define a macro to simplify memory allocation */
#define	valloc_pages(var, np)				\
	alloc_pages((var).pv_pa, (np));			\
	(var).pv_va = KERNEL_BASE + (var).pv_pa - physical_start;

#define alloc_pages(var, np)				\
	physical_freeend -= ((np) * PAGE_SIZE);		\
	if (physical_freeend < physical_freestart)	\
		panic("initarm: out of memory");	\
	(var) = physical_freeend;			\
	free_pages -= (np);				\
	memset((char *)(var), 0, ((np) * PAGE_SIZE));

	loop1 = 0;
	kernel_l1pt.pv_pa = 0;
	for (loop = 0; loop <= NUM_KERNEL_PTS; ++loop) {
		/* Are we 16KB aligned for an L1 ? */
		if (((physical_freeend - L1_TABLE_SIZE) & (L1_TABLE_SIZE - 1)) == 0
		    && kernel_l1pt.pv_pa == 0) {
			valloc_pages(kernel_l1pt, L1_TABLE_SIZE / PAGE_SIZE);
		} else {
			valloc_pages(kernel_pt_table[loop1],
			    L2_TABLE_SIZE / PAGE_SIZE);
			++loop1;
		}
	}

	/* This should never be able to happen but better confirm that. */
	if (!kernel_l1pt.pv_pa || (kernel_l1pt.pv_pa & (L1_TABLE_SIZE-1)) != 0)
		panic("initarm: Failed to align the kernel page directory");

	/*
	 * Allocate a page for the system page mapped to V0x00000000
	 * This page will just contain the system vectors and can be
	 * shared by all processes.
	 */
	alloc_pages(systempage.pv_pa, 1);

	/* Allocate stacks for all modes */
	valloc_pages(irqstack, IRQ_STACK_SIZE);
	valloc_pages(abtstack, ABT_STACK_SIZE);
	valloc_pages(undstack, UND_STACK_SIZE);
	valloc_pages(kernelstack, UPAGES);

	/* Allocate enough pages for cleaning the Mini-Data cache. */
	KASSERT(xscale_minidata_clean_size <= PAGE_SIZE);
	valloc_pages(minidataclean, 1);

#ifdef VERBOSE_INIT_ARM
	printf("IRQ stack: p0x%08lx v0x%08lx\n", irqstack.pv_pa,
	    irqstack.pv_va); 
	printf("ABT stack: p0x%08lx v0x%08lx\n", abtstack.pv_pa,
	    abtstack.pv_va); 
	printf("UND stack: p0x%08lx v0x%08lx\n", undstack.pv_pa,
	    undstack.pv_va); 
	printf("SVC stack: p0x%08lx v0x%08lx\n", kernelstack.pv_pa,
	    kernelstack.pv_va); 
#endif

	/*
	 * XXX Defer this to later so that we can reclaim the memory
	 * XXX used by the RedBoot page tables.
	 */
	alloc_pages(msgbufphys, round_page(MSGBUFSIZE) / PAGE_SIZE);

	/*
	 * Ok we have allocated physical pages for the primary kernel
	 * page tables
	 */

#ifdef VERBOSE_INIT_ARM
	printf("Creating L1 page table at 0x%08lx\n", kernel_l1pt.pv_pa);
#endif

	/*
	 * Now we start construction of the L1 page table
	 * We start by mapping the L2 page tables into the L1.
	 * This means that we can replace L1 mappings later on if necessary
	 */
	l1pagetable = kernel_l1pt.pv_pa;

	/* Map the L2 pages tables in the L1 page table */
	pmap_link_l2pt(l1pagetable, 0x00000000,
	    &kernel_pt_table[KERNEL_PT_SYS]);

	for (loop = 0; loop < KERNEL_PT_KERNEL_NUM; loop++)
		pmap_link_l2pt(l1pagetable, KERNEL_BASE + loop * 0x00400000,
		    &kernel_pt_table[KERNEL_PT_KERNEL + loop]);

	for (loop = 0; loop < KERNEL_PT_VMDATA_NUM; loop++)
		pmap_link_l2pt(l1pagetable, KERNEL_VM_BASE + loop * 0x00400000,
		    &kernel_pt_table[KERNEL_PT_VMDATA + loop]);

	/* update the top of the kernel VM */
	pmap_curmaxkvaddr =
	    KERNEL_VM_BASE + (KERNEL_PT_VMDATA_NUM * 0x00400000);

#ifdef VERBOSE_INIT_ARM
	printf("Mapping kernel\n");
#endif

	/* Now we fill in the L2 pagetable for the kernel static code/data
	 * and the symbol table. */
	{
		extern char etext[];
		size_t textsize = (u_int32_t) etext - KERNEL_TEXT_BASE;
		size_t totalsize = esym - KERNEL_TEXT_BASE;
		u_int logical;

		textsize = (textsize + PGOFSET) & ~PGOFSET;
		totalsize = (totalsize + PGOFSET) & ~PGOFSET;
		
		logical = 0x00200000;	/* offset of kernel in RAM */

		/* Update dump information */
		cpu_kcore_hdr.kernelbase = KERNEL_BASE;
		cpu_kcore_hdr.kerneloffs = logical;
		cpu_kcore_hdr.staticsize = totalsize;

		logical += pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
		    physical_start + logical, textsize,
		    PROT_READ | PROT_WRITE, PTE_CACHE);
		pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
		    physical_start + logical, totalsize - textsize,
		    PROT_READ | PROT_WRITE, PTE_CACHE);
	}

#ifdef VERBOSE_INIT_ARM
	printf("Constructing L2 page tables\n");
#endif

	/* Map the stack pages */
	pmap_map_chunk(l1pagetable, irqstack.pv_va, irqstack.pv_pa,
	    IRQ_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, abtstack.pv_va, abtstack.pv_pa,
	    ABT_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, undstack.pv_va, undstack.pv_pa,
	    UND_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, kernelstack.pv_va, kernelstack.pv_pa,
	    UPAGES * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);

	pmap_map_chunk(l1pagetable, kernel_l1pt.pv_va, kernel_l1pt.pv_pa,
	    L1_TABLE_SIZE, PROT_READ | PROT_WRITE, PTE_PAGETABLE);

	for (loop = 0; loop < NUM_KERNEL_PTS; ++loop) {
		pmap_map_chunk(l1pagetable, kernel_pt_table[loop].pv_va,
		    kernel_pt_table[loop].pv_pa, L2_TABLE_SIZE,
		    PROT_READ | PROT_WRITE, PTE_PAGETABLE);
	}

	/* Map the Mini-Data cache clean area. */
	xscale_setup_minidata(l1pagetable, minidataclean.pv_va,
	    minidataclean.pv_pa);

	/* Map the vector page. */
#if 1
	/* MULTI-ICE requires that page 0 is NC/NB so that it can download the
	 * cache-clean code there.  */
	pmap_map_entry(l1pagetable, vector_page, systempage.pv_pa,
	    PROT_READ | PROT_WRITE, PTE_NOCACHE);
#else
	pmap_map_entry(l1pagetable, vector_page, systempage.pv_pa,
	    PROT_READ | PROT_WRITE, PTE_CACHE);
#endif

	/*
	 * map integrated peripherals at same address in l1pagetable
	 * so that we can continue to use console.
	 */
	copy_io_area_map((pd_entry_t *)l1pagetable);

	/*
	 * Give the XScale global cache clean code an appropriately
	 * sized chunk of unmapped VA space starting at 0xff000000
	 * (our device mappings end before this address).
	 */
	xscale_cache_clean_addr = 0xff000000U;

	/*
	 * Now we have the real page tables in place so we can switch to them.
	 * Once this is done we will be running with the REAL kernel page
	 * tables.
	 */

	/*
	 * Update the physical_freestart/physical_freeend/free_pages
	 * variables.
	 */
	{
		physical_freestart = physical_start +
		    (((esym + PGOFSET) & ~PGOFSET) - KERNEL_BASE);
		physical_freeend = physical_end;
		free_pages =
		    (physical_freeend - physical_freestart) / PAGE_SIZE;
	}

	/* be a client to all domains */
	cpu_domains(0x55555555);
	/* Switch tables */
#ifdef VERBOSE_INIT_ARM
	printf("freestart = 0x%08lx, free_pages = %d (0x%x)\n",
	       physical_freestart, free_pages, free_pages);
	printf("switching to new L1 page table  @@%#lx...", kernel_l1pt.pv_pa);
#endif

	/* set new intc register address so that splfoo() doesn't
	   touch illegal address.  */
	pxa2x0_intr_bootstrap(ZAURUS_INTCTL_VBASE);

	cpu_domains((DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2)) | DOMAIN_CLIENT);
	setttb(kernel_l1pt.pv_pa);
	cpu_tlb_flushID();
	cpu_domains(DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2));

	/*
	 * Moved from cpu_startup() as data_abort_handler() references
	 * this during uvm init
	 */
	proc0paddr = (struct user *)kernelstack.pv_va;
	proc0.p_addr = proc0paddr;

#ifdef VERBOSE_INIT_ARM
	printf("bootstrap done.\n");
#endif

	arm32_vector_init(ARM_VECTORS_LOW, ARM_VEC_ALL);

	/*
	 * Pages were allocated during the secondary bootstrap for the
	 * stacks for different CPU modes.
	 * We must now set the r13 registers in the different CPU modes to
	 * point to these stacks.
	 * Since the ARM stacks use STMFD etc. we must set r13 to the top end
	 * of the stack memory.
	 */
#ifdef VERBOSE_INIT_ARM
	printf("init subsystems: stacks ");
#endif

	set_stackptr(PSR_IRQ32_MODE,
	    irqstack.pv_va + IRQ_STACK_SIZE * PAGE_SIZE);
	set_stackptr(PSR_ABT32_MODE,
	    abtstack.pv_va + ABT_STACK_SIZE * PAGE_SIZE);
	set_stackptr(PSR_UND32_MODE,
	    undstack.pv_va + UND_STACK_SIZE * PAGE_SIZE);

	/*
	 * Well we should set a data abort handler.
	 * Once things get going this will change as we will need a proper
	 * handler.
	 * Until then we will use a handler that just panics but tells us
	 * why.
	 * Initialisation of the vectors will just panic on a data abort.
	 * This just fills in a slightly better one.
	 */
#ifdef VERBOSE_INIT_ARM
	printf("vectors ");
#endif
	data_abort_handler_address = (u_int)data_abort_handler;
	prefetch_abort_handler_address = (u_int)prefetch_abort_handler;
	undefined_handler_address = (u_int)undefinedinstruction_bounce;

	/* Initialise the undefined instruction handlers */
#ifdef VERBOSE_INIT_ARM
	printf("undefined ");
#endif
	undefined_init();

	/* Load memory into UVM. */
#ifdef VERBOSE_INIT_ARM
	printf("page ");
#endif
	uvm_setpagesize();        /* initialize PAGE_SIZE-dependent variables */
	uvm_page_physload(atop(physical_freestart), atop(physical_freeend),
	    atop(physical_freestart), atop(physical_freeend), 0);

	/* Boot strap pmap telling it where the kernel page table is */
#ifdef VERBOSE_INIT_ARM
	printf("pmap ");
#endif
	pmap_bootstrap((pd_entry_t *)kernel_l1pt.pv_va, KERNEL_VM_BASE,
	    KERNEL_VM_BASE + KERNEL_VM_SIZE);

	/* Update dump information */
	cpu_kcore_hdr.pmap_kernel_l1 = (u_int32_t)pmap_kernel()->pm_l1;
	cpu_kcore_hdr.pmap_kernel_l2 = (u_int32_t)&(pmap_kernel()->pm_l2);

#ifdef KGDB
	if (boothowto & RB_KDB) {
		kgdb_debug_init = 1;
		kgdb_connect(1);
	}
#endif

	/*
	 * Restore proper bus_space operation, now that pmap is initialized.
	 */
	pxa2x0_a4x_bs_tag.bs_map = pxa2x0_bs_tag.bs_map = map_func_save;

#ifdef DDB
	db_machine_init();

	/* Firmware doesn't load symbols. */
	ddb_init();

	if (boothowto & RB_KDB)
		Debugger();
#endif

	cpu_setup();

	/* We return the new stack pointer address */
	return(kernelstack.pv_va + USPACE_SVC_STACK_TOP);
}

const char *console = "glass";

void
process_kernel_args(char *args)
{
	char *cp = args;

	if (cp == NULL || *(int *)cp != BOOT_STRING_MAGIC) {
		boothowto = RB_AUTOBOOT;
		return;
	}

	/* Eat the cookie */
	*(int *)cp = 0;
	cp += sizeof(int);

	boothowto = 0;

	/* Make a local copy of the bootargs */
	strncpy(bootargs, cp, MAX_BOOT_STRING - sizeof(int));

	cp = bootargs;
	boot_file = bootargs;

	/* Skip the kernel image filename */
	while (*cp != ' ' && *cp != 0)
		++cp;

	if (*cp != 0)
		*cp++ = 0;

	while (*cp == ' ')
		++cp;

	boot_args = cp;

	printf("bootfile: %s\n", boot_file);
	printf("bootargs: %s\n", boot_args);

	/* Setup pointer to boot flags */
	while (*cp != '-')
		if (*cp++ == '\0')
			return;

	for (;*++cp;) {
		int fl;

		fl = 0;
		switch(*cp) {
		case 'a':
			fl |= RB_ASKNAME;
			break;
		case 'c':
			fl |= RB_CONFIG;
			break;
		case 'd':
			fl |= RB_KDB;
			break;
		case 's':
			fl |= RB_SINGLE;
			break;
		/* XXX undocumented console switching flags */
		case '0':
			console = "ffuart";
			break;
		case '1':
			console = "btuart";
			break;
		case '2':
			console = "stuart";
			break;
		default:
			printf("unknown option `%c'\n", *cp);
			break;
		}
		boothowto |= fl;
	}
}

#ifdef KGDB
#ifndef KGDB_DEVNAME
#define KGDB_DEVNAME "ffuart"
#endif
const char kgdb_devname[] = KGDB_DEVNAME;

#if (NCOM > 0)
#ifndef KGDB_DEVMODE
#define KGDB_DEVMODE ((TTYDEF_CFLAG & ~(CSIZE | CSTOPB | PARENB)) | CS8) /* 8N1 */
#endif
int comkgdbmode = KGDB_DEVMODE;
#endif /* NCOM */

#endif /* KGDB */

void
consinit(void)
{
#if NCOM > 0
	static int consinit_called = 0;
	paddr_t paddr;
	u_int cken = 0;

	if (consinit_called != 0)
		return;

	consinit_called = 1;

#ifdef KGDB
	if (strcmp(kgdb_devname, console) == 0) {
		/* port is reserved for kgdb */
	} else
#endif
	if (strcmp(console, "ffuart") == 0) {
		paddr = PXA2X0_FFUART_BASE;
		cken = CKEN_FFUART;
	} else if (strcmp(console, "btuart") == 0) {
		paddr = PXA2X0_BTUART_BASE;
		cken = CKEN_BTUART;
	} else if (strcmp(console, "stuart") == 0) {
		paddr = PXA2X0_STUART_BASE;
		cken = CKEN_STUART;
		irda_on(0);
	}
	if (cken != 0 && comcnattach(&pxa2x0_a4x_bs_tag, paddr, comcnspeed,
	    PXA2X0_COM_FREQ, comcnmode) == 0) {
		early_clkman(cken, 1);
	}
#endif /* NCOM */
}

#ifdef KGDB
void
kgdb_port_init(void)
{
#if (NCOM > 0) && defined(COM_PXA2X0)
	paddr_t paddr;
	u_int cken;

	if (strcmp(kgdb_devname, "ffuart") == 0) {
		paddr = PXA2X0_FFUART_BASE;
		cken = CKEN_FFUART;
	} else if (strcmp(kgdb_devname, "btuart") == 0) {
		paddr = PXA2X0_BTUART_BASE;
		cken = CKEN_BTUART;
	} else if (strcmp(kgdb_devname, "stuart") == 0) {
		paddr = PXA2X0_STUART_BASE;
		cken = CKEN_STUART;
		irda_on(0);
	} else
		return;

	if (com_kgdb_attach_pxa2x0(&pxa2x0_a4x_bs_tag, paddr,
	    kgdb_rate, PXA2X0_COM_FREQ, COM_TYPE_PXA2x0, comkgdbmode) == 0) {
		early_clkman(cken, 1);
	}
#endif
}
#endif

/* same as pxa2x0_clkman, but before autoconf */
void
early_clkman(u_int clk, int enable)
{
	u_int32_t rv;

	rv = ioreg_read(ZAURUS_CLKMAN_VBASE + CLKMAN_CKEN);
	if (enable)
		rv |= clk;
	else
		rv &= ~clk;
	ioreg_write(ZAURUS_CLKMAN_VBASE + CLKMAN_CKEN, rv);
}

int glass_console = 0;

void
board_startup(void)
{
	extern int lcd_cnattach(void (*)(u_int, int));
	extern bus_addr_t comconsaddr;

#if NWSDISPLAY > 0
	/*
	 * Try to attach the display console now that VM services
	 * are available.
	 */

	if ((cputype & ~CPU_ID_XSCALE_COREREV_MASK) == CPU_ID_PXA27X) {
		if (strcmp(console, "glass") == 0) {
			printf("attempting to switch console to lcd screen\n");
			glass_console = 1;
		}
		if (glass_console == 1 && lcd_cnattach(early_clkman) == 0) {
			/*
			 * Kill the existing serial console.
			 * XXX need to bus_space_unmap resources and disable
			 *     clocks...
			 */
			comconsaddr = 0;

			/*
			 * Display the copyright notice again on the new console
			 */
			extern const char copyright[];
			printf("%s\n", copyright);
		}
	}
#endif

        if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}
@


1.60
log
@Move the cpu_setup() call to the end of initarm().  On Cortex-A53 processors
atomic instructions don't work unless the data cache is enabled.  This happens
in cpu_setup(), but that gets currently called from cpu_startup() which runs
after a number of kernel subsystems have been initialized.  Since some of
these subsystems use locks, which need atomic instructions, we fault on
Cortex-A53.  Since at the end of initarm() we're done setting up the pmap
and initializing other low-level sense, calling cpu_setup() here makes much
more sense.

Remove setting up proc0paddr as well from cpu_startup(), since that already
happens in initarm().

Tested on zaurus by deraadt@@.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.59 2015/05/10 15:56:28 jsg Exp $	*/
a152 1
#include <arm/sa11x0/sa1111_reg.h>
@


1.59
log
@VM_MAX_KERNEL_ADDRESS is the end of the kva range not the end of
addressable virtual memory space but arm ports were using a value of
0xffffffff for this.

Instead of using a shared VM_MAX_KERNEL_ADDRESS define add md
VM_KERNEL_SPACE_SIZE defines based on the KERNEL_VM_SIZE values
from the respective machdep.c files.

djm's novena was hitting "panic: bufinit: can't reserve VM for buffers"
without a similiar change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.58 2015/05/08 22:56:53 miod Exp $	*/
d1112 2
@


1.58
log
@Need explicit <sys/kcore.h> include now.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.57 2015/05/05 02:13:47 guenther Exp $	*/
d169 1
a169 10

/*
 * The range 0xc1000000 - 0xccffffff is available for kernel VM space
 * Core-logic registers and I/O mappings occupy 0xfd000000 - 0xffffffff
 */
/*
#define KERNEL_VM_SIZE		0x0C000000
*/
#define KERNEL_VM_SIZE		0x10000000

@


1.57
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.56 2015/01/18 10:17:42 jsg Exp $	*/
d124 1
a130 1
#include <dev/ic/smc91cxxreg.h>
@


1.56
log
@unifdef IPKDB.  These codepaths are holdouts from NetBSD code and are
not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.55 2014/12/10 15:29:53 mikeb Exp $	*/
a123 1
#include <sys/kcore.h>
@


1.55
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.54 2014/12/03 20:09:32 krw Exp $	*/
a191 3
#ifdef IPKDB
#define UND_STACK_SIZE	2
#else
a192 1
#endif
a712 1

a1099 7

#ifdef IPKDB
	/* Initialise ipkdb */
	ipkdb_init();
	if (boothowto & RB_KDB)
		ipkdb_connect(0);
#endif
@


1.54
log
@More duplicate #include cleanout.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.53 2014/11/16 12:30:59 deraadt Exp $	*/
d323 1
a323 1
	
a324 1
	doshutdownhooks();
@


1.53
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.52 2014/09/20 09:28:25 kettenis Exp $	*/
a129 1
#include <sys/device.h>
@


1.52
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.51 2014/07/21 17:25:47 uebayasi Exp $	*/
d435 1
a435 1
			    VM_PROT_READ|VM_PROT_WRITE,
d462 1
a462 1
	    VM_PROT_READ | VM_PROT_WRITE, PTE_NOCACHE);
d942 1
a942 1
		    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d945 1
a945 1
		    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d954 1
a954 1
	    IRQ_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d956 1
a956 1
	    ABT_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d958 1
a958 1
	    UND_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d960 1
a960 1
	    UPAGES * PAGE_SIZE, VM_PROT_READ | VM_PROT_WRITE, PTE_CACHE);
d963 1
a963 1
	    L1_TABLE_SIZE, VM_PROT_READ | VM_PROT_WRITE, PTE_PAGETABLE);
d968 1
a968 1
		    VM_PROT_READ|VM_PROT_WRITE, PTE_PAGETABLE);
d980 1
a980 1
	    VM_PROT_READ|VM_PROT_WRITE, PTE_NOCACHE);
d983 1
a983 1
	    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
@


1.51
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a294 1
	struct device *mainbus;
d327 1
a327 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.50
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d298 1
a298 1
	if (howto & RB_POWERDOWN)
d314 1
a314 1
	if (!(howto & RB_NOSYNC))
d335 1
a335 1
	if (howto & RB_HALT) {
d337 1
a337 1
		if (howto & RB_POWERDOWN) {
@


1.49
log
@Cosmetic changes to reduce diffs.
@
text
@d358 2
a359 2
	while(1);
	/*NOTREACHED*/
@


1.48
log
@boot(9): Missing if_downall() on zaurus

zaurus's boot(9) is the only boot(9) which doesn't call if_downall().  Include
sys/socket.h + net/if.h and call it.

OK miod@@
@
text
@d320 1
a320 1
	splhigh();		/* Disable interrupts. */
a322 1
	/* Do a dump if requested. */
@


1.47
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.46 2014/07/10 20:15:27 uebayasi Exp $	*/
d133 1
d142 2
d316 2
@


1.46
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d314 3
a316 2
	/* Say NO to interrupts */
	splhigh();
@


1.45
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a298 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitely asked for reboot.
		 */
@


1.44
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.43 2014/05/30 13:46:17 mpi Exp $	*/
d289 1
a289 1
void
@


1.43
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.42 2014/03/29 18:09:30 guenther Exp $	*/
d318 2
a319 3
	uvm_shutdown();
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.42
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.41 2014/03/13 03:52:56 dlg Exp $	*/
d318 3
a320 2
	/* Say NO to interrupts */
	splhigh();
@


1.41
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.40 2013/09/28 14:16:42 miod Exp $	*/
d367 1
a367 1
  __asm __volatile("mrc	p15, 0, %0, c2, c0, 0" : "=r" (ttb));
@


1.40
log
@A few missing config_suspend(, DVACT_POWERDOWN) constructs after
doshutdownhooks() calls.
XXX arm-based ports ought to really share their reboot code.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.39 2012/08/30 15:51:13 deraadt Exp $	*/
d292 1
d327 3
a329 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.39
log
@no md_root_setconf
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.38 2011/10/19 20:18:31 drahn Exp $	*/
d326 2
@


1.38
log
@API change to initarm to pass arguments from the bootloader thru to MD
C code. Will be used on beagle to process machine id and atags.
Looked at by uwe@@, tested on beagle/armish/zaurus.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.37 2011/05/30 22:25:23 oga Exp $	*/
a1104 4

#ifdef __HAVE_MEMORY_DISK__
	md_root_setconf(memory_disk, sizeof memory_disk);
#endif
@


1.37
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.36 2010/10/02 23:31:34 deraadt Exp $	*/
d557 1
a557 1
initarm(void *arg)
@


1.36
log
@turn off lid suspend if we doing halt -p
ok kettenis marco miod
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.35 2010/06/27 06:21:44 beck Exp $	*/
d1093 1
a1093 2
	    atop(physical_freestart), atop(physical_freeend),
	    VM_FREELIST_DEFAULT);
@


1.35
log
@make zaurus kernel link again after viking raiders sprinkled duplicate declarations
everywhere

this will probably also need to be done on other arm arch'es

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.34 2010/06/27 03:03:48 thib Exp $	*/
d292 5
@


1.34
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.32 2009/07/26 18:48:55 miod Exp $	*/
a125 1
#include <uvm/uvm.h>
a222 3

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };
@


1.33
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d126 1
d224 3
@


1.32
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.31 2008/11/26 01:29:00 kevlo Exp $	*/
d243 6
@


1.31
log
@fix boot() function comment

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.30 2008/11/25 14:55:44 drahn Exp $	*/
d437 1
a437 1
    int cacheable, bus_space_handle_t *bshp)
@


1.30
log
@rename zaurus_reg.h to machine_reg and rename some of the internal fields
so that arm/xscale/... is not referring to zaurus specific defines.
ok miod kevlo, with some suggested changes from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.29 2008/06/08 20:56:33 miod Exp $	*/
d276 1
a276 1
 * void boot(int howto, char *bootstr)
@


1.29
log
@Change boot() logic, to match what other platforms do and avoid duplicating
code in the cold case.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.28 2008/03/23 17:05:42 deraadt Exp $	*/
d153 1
a153 1
#include <machine/zaurus_reg.h>
@


1.28
log
@setroot() is supposed to be safe in all cases, so kill the special cases
for RB_DFLTROOT; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.27 2007/05/19 15:49:06 miod Exp $	*/
a285 4
	/*
	 * If we are still cold then hit the air brakes
	 * and crash to earth fast
	 */
d287 7
a293 14
		doshutdownhooks();
		if ((howto & (RB_HALT | RB_USERREQ)) != RB_USERREQ) {
			printf("The operating system has halted.\n");
			printf("Please press any key to reboot.\n\n");
			cngetc();
		}
		printf("rebooting...\n");
		delay(6000000);
#if NAPM > 0
		zapm_restart();
#endif
		printf("reboot failed; spinning\n");
		while(1);
		/*NOTREACHED*/
a295 3
	/* Disable console buffering */
/*	cnpollc(1);*/

d313 1
a313 1
	/* Run any shutdown hooks */
d331 1
d333 1
@


1.27
log
@Kernel crash dump support for arm-based platform, with minimal support in
libkvm, but all the necessary information for a complete _kvm_kvatop() is
available in the crash dump.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.26 2007/04/10 16:43:37 miod Exp $	*/
a658 3
#ifdef RAMDISK_HOOKS
        boothowto |= RB_DFLTROOT;
#endif /* RAMDISK_HOOKS */
@


1.26
log
@slighly -> slightly
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.25 2006/06/20 18:24:04 todd Exp $	*/
d124 1
d145 1
d561 1
d937 5
d1106 4
@


1.25
log
@revert the interrupt vector diff, this fixes zaurus suspend; ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.23 2006/01/17 20:30:12 miod Exp $	*/
d1068 1
a1068 1
	 * This just fills in a slighly better one.
@


1.24
log
@Map the vector page cacheable during startup.
@
text
@d970 6
d978 1
@


1.23
log
@Upon halt, invoke resettodr() on arm platforms, unless we have been sitting
in DDB; tested at least by aanriot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.22 2005/12/17 07:31:27 miod Exp $	*/
a969 6
#if 1
	/* MULTI-ICE requires that page 0 is NC/NB so that it can download the
	 * cache-clean code there.  */
	pmap_map_entry(l1pagetable, vector_page, systempage.pv_pa,
	    VM_PROT_READ|VM_PROT_WRITE, PTE_NOCACHE);
#else
a971 1
#endif
@


1.22
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.21 2005/12/14 15:08:51 uwe Exp $	*/
d316 1
a316 1
		bootsync();
@


1.21
log
@Don't hard-code card present and number of socket bits in the PCMCIA bus
configuration register, but control these bits from PCMCIA code.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.20 2005/12/14 14:39:38 uwe Exp $	*/
d200 4
a203 4
vm_offset_t physical_start;
vm_offset_t physical_freestart;
vm_offset_t physical_freeend;
vm_offset_t physical_end;
a204 1
vm_offset_t pagetables_start;
d220 1
a220 1
vm_offset_t msgbufphys;
d421 1
a421 1
		vm_size_t sz;
@


1.20
log
@Remove useless crap that was there from the beginning.  One particular
tweak only prevented access to the flash controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.19 2005/11/11 23:50:03 deraadt Exp $	*/
a721 12

	/* Initialize for PCMCIA/CF sockets */
	{
		/* Activate two sockets.
		   XXX: This code segment should be moved to
		        pcmcia MD attach routine.
		   XXX: These bits should be toggled based on
		        existene of PCMCIA/CF cards
		*/
		ioreg_write(PXA2X0_MEMCTL_BASE+MEMCTL_MECR,
			     MECR_NOS|MECR_CIT);
	}
@


1.19
log
@remove old debug code in boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.18 2005/07/01 23:56:47 uwe Exp $	*/
d236 1
a236 1
#define	KERNEL_PT_VMDATA_NUM	8	/* start with 16MB of KVM */
a397 6
	    ZAURUS_INTCTL_VBASE,
	    PXA2X0_INTCTL_BASE,
	    PXA2X0_INTCTL_SIZE,
	    PTE_NOCACHE,
    },
    {
a722 14
	/* Tweak memory controller */
	{
		/* Modify access timing for CS3 (91c96) */

		uint32_t tmp = 
			ioreg_read(PXA2X0_MEMCTL_BASE+MEMCTL_MSC1);
		ioreg_write(PXA2X0_MEMCTL_BASE+MEMCTL_MSC1,
			     (tmp & 0xffff) | (0x3881<<16));
		/* RRR=3, RDN=8, RDF=8
		 * XXX: can be faster?
		 */
	}


a724 2
		uint32_t tmp;

a732 4

		tmp = ioreg_read(ZAURUS_SACC_PBASE+SACCSBI_SKCR);
		ioreg_write(ZAURUS_SACC_PBASE+SACCSBI_SKCR,
			     (tmp & ~(1<<4)) | (1<<0));
a733 1

@


1.18
log
@- New macros to identify the zaurus model.
- Updated constants in zaurus_reg.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.17 2005/05/27 18:42:15 uwe Exp $	*/
a284 5
#ifdef DIAGNOSTIC
	/* info */
	printf("boot: howto=%08x curproc=%p\n", howto, curproc);
#endif

@


1.17
log
@- Merge changes from pxacom back into the common com driver.

Changes to the common com driver (partly from NetBSD):
- Multiply before divide in comspeed() to avoid overflow (from NetBSD).
- Don't call getc() and send -1 if the output queue is empty.
- Take UART clock frequency as a parameter instead of using COM_FREQ.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.16 2005/05/24 20:32:43 uwe Exp $	*/
d194 2
d410 1
a410 1
	    SCOOP0_BASE,
d416 1
a416 1
	    trunc_page(SCOOP1_BASE),
d506 1
a506 1
		p = (u_int16_t *)(SCOOP0_BASE+SCOOP_GPWR);
d517 1
a517 1
	int ofs = SCOOP1_BASE - trunc_page(SCOOP1_BASE);
d522 1
a522 1
		p = (u_int16_t *)(SCOOP1_BASE+SCOOP_GPWR);
d671 9
@


1.16
log
@serial console support
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.15 2005/05/09 15:32:19 uwe Exp $	*/
a256 4
#if defined(COM_PXA2X0)
#include <arm/xscale/pxacomreg.h>
#include <arm/xscale/pxacomvar.h>
#else
a258 1
#endif
@


1.15
log
@Enable clock to STUART unit, and enable com2 in GENERIC and RAMDISK
configurations.  The STUARTCONSOLE option doesn't work yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.14 2005/05/02 02:45:29 uwe Exp $	*/
d154 2
d412 9
a420 3
	    ZAURUS_AGPIO_VBASE,
	    0x10800000,
	    0x00010000, /* XXX */
d499 1
d507 1
a507 1
		p = (u_int16_t *)(ZAURUS_AGPIO_VBASE+0x24);
d509 1
a509 1
		p = (u_int16_t *)0x10800024;
d511 17
a527 1
	*p = *p | 2;
d664 11
a759 9
	/*
	 * Examine the boot args string for options we need to know about
	 * now.
	 */
	process_kernel_args((char *)0xa0200000 - MAX_BOOT_STRING - 1);
#ifdef RAMDISK_HOOKS
        boothowto |= RB_DFLTROOT;
#endif /* RAMDISK_HOOKS */

d1175 1
a1175 7
#if defined(FFUARTCONSOLE)
const char *console = "ffuart";
#elif defined(BTUARTCONSOLE)
const char *console = "btuart";
#elif defined(STUARTCONSOLE)
const char *console = "stuart";
#endif
d1236 10
a1293 3
#if 0
		/* XXX enable the infrared transmitter LED. */
#endif
d1296 1
d1322 1
d1348 2
d1362 19
a1380 11
	printf("attempting to switch console to lcd screen\n");
	if (lcd_cnattach(early_clkman) == 0) {
		/*
		 * Kill the existing serial console.
		 * XXX need to bus_space_unmap resources and disable
		 *     clocks...
		 */
		comconsaddr = 0;

		/* Display the copyright notice again on the new console */
		printf("%s\n", copyright);
@


1.14
log
@Load the symbol table to the end of data/bss, and account for it when
setting up the kernel page table.  Makes ddb more usable (when used
together with an unrotated console :)
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.14 2005/05/02 02:34:00 uwe Exp $	*/
d255 5
d261 1
a261 1
#include <dev/ic/comvar.h>
d653 4
d659 3
d665 1
a665 1
	early_clkman(CKEN_FFUART | CKEN_BTUART, 1);
d1148 8
d1241 1
d1243 2
a1244 3
#if 0
	char *console = CONSDEVNAME;
#endif
a1250 3
#if NCOM > 0

#ifdef FFUARTCONSOLE
d1252 1
a1252 1
	if (strcmp(kgdb_devname, "ffuart") == 0) {
d1256 12
a1267 4
	if (comcnattach(&pxa2x0_a4x_bs_tag, PXA2X0_FFUART_BASE, comcnspeed,
	    PXA2X0_COM_FREQ, comcnmode) == 0) {
		early_clkman(CKEN_FFUART, 1);
		return;
d1269 1
a1269 9
#endif /* FFUARTCONSOLE */

#ifdef BTUARTCONSOLE
#ifdef KGDB
	if (strcmp(kgdb_devname, "btuart") == 0) {
		/* port is reserved for kgdb */
	} else
#endif
	if (comcnattach(&pxa2x0_a4x_bs_tag, PXA2X0_BTUART_BASE, comcnspeed,
d1271 1
a1271 2
		early_clkman(CKEN_BTUART, 1);
		return;
a1272 2
#endif /* BTUARTCONSOLE */

d1290 3
@


1.13
log
@use zapm functions to power down or restart
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.12 2005/03/26 16:46:19 uwe Exp $	*/
d550 1
d921 2
a922 1
	/* Now we fill in the L2 pagetable for the kernel static code/data */
d924 1
a924 1
		extern char etext[], _end[];
d926 1
a926 1
		size_t totalsize = (u_int32_t) _end - KERNEL_TEXT_BASE;
d937 1
a937 1
		logical += pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
a1003 2
		extern char _end[];

d1005 1
a1005 2
		    (((((u_int32_t) _end) + PGOFSET) & ~PGOFSET) -
		     KERNEL_BASE);
@


1.12
log
@- Parse boot arguments like on other platforms and handle common flags.
- Delay much longer before rebooting to give the internal disk in the
  C3000 enough time to stop itself.
"go ahead" drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.11 2005/02/23 00:01:09 drahn Exp $	*/
d154 5
a240 3
void	zaurus_reset(void);
void	zaurus_powerdown(void);

a270 48
 *
 */
void
zaurus_reset(void)
{
	bus_space_tag_t bust = &pxa2x0_bs_tag;
	bus_space_handle_t bush_pow;
	bus_space_handle_t bush_mc;
	int rv;

	if (bus_space_map(bust, PXA2X0_POWMAN_BASE, PXA2X0_POWMAN_SIZE, 0,
	    &bush_pow))
		panic("pxa2x0_gpio_boot: failed to map POWMAN");

	if (bus_space_map(bust, PXA2X0_MEMCTL_BASE, PXA2X0_MEMCTL_SIZE, 0,
	    &bush_mc))
		panic("zaurus_reset: failed to map MEMCTL");

	bus_space_write_4(bust, bush_pow, POWMAN_RCSR,
	    RCSR_GPR | RCSR_SMR | RCSR_WDR | RCSR_HWR);

	rv = bus_space_read_4(bust, bush_mc, MEMCTL_MSC0);
        if ((rv & 0xffff0000) == 0x7ff00000)
		bus_space_write_4(bust, bush_mc, MEMCTL_MSC0,
		    (rv & 0xffff) | 0x7ee00000);

	pxa2x0_gpio_set_function(89, GPIO_OUT | GPIO_SET);

	/* Wait for the external reset circuit to kick the CPU. */
	delay(1000000);
}

/*
 *
 */
void
zaurus_powerdown(void)
{

	/*
	 * XXX most of the time this does the right thing, but
	 * XXX sometimes the zaurus can't be turned on by pressing
	 * XXX the power button until the battery is replaced.
	 */
	pxa2x0_watchdog_boot();
}

/*
d299 3
a301 1
		zaurus_reset();
d334 1
d339 1
a339 1
			zaurus_powerdown();
d341 1
d350 3
a352 1
	zaurus_reset();
@


1.11
log
@Move code from zaurus machdep to arm/xscale to live with the interrupt
handler where it belongs code had been de-inlined to the wrong file.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.10 2005/02/13 22:20:03 miod Exp $	*/
d344 1
a344 1
		delay(500000);
d381 1
a381 1
			delay(500000);
d391 1
a391 1
	delay(500000);
d1180 1
d1182 1
a1182 1
	if (*(int *)args != BOOT_STRING_MAGIC) {
d1187 3
a1189 2
	*(int *)args = 0;
	args += sizeof(int);
d1194 1
a1194 1
	strncpy(bootargs, args, MAX_BOOT_STRING - sizeof(int));
d1196 1
a1196 1
	args = bootargs;
d1200 2
a1201 2
	while (*args != ' ' && *args != 0)
		++args;
d1203 2
a1204 2
	if (*args != 0)
		*args++ = 0;
d1206 2
a1207 2
	while (*args == ' ')
		++args;
d1209 1
a1209 1
	boot_args = args;
d1214 28
a1241 3
#if 1
	parse_mi_bootargs(boot_args);
#endif
@


1.10
log
@Remove duplicate prototype with <sys/systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.9 2005/01/31 17:33:58 drahn Exp $	*/
a1347 69
}

/*
 * Cotulla's integrated ICU doesn't have IRQ0..7, so
 * we map software interrupts to bit 0..3
 */
#define SI_TO_IRQBIT(si)  (1U<<(si))

void
pxa2x0_setipl(int new)
{
	current_spl_level = new;
	intr_mask = pxa2x0_imask[current_spl_level];
	write_icu( SAIPIC_MR, intr_mask );
}


void
pxa2x0_splx(int new)
{
	int psw;

	psw = disable_interrupts(I32_bit);
	pxa2x0_setipl(new);
	restore_interrupts(psw);

	/* If there are software interrupts to process, do it. */
	if (softint_pending & intr_mask)
		pxa2x0_do_pending();
}


int
pxa2x0_splraise(int ipl)
{
	int	old, psw;

	old = current_spl_level;
	if( ipl > current_spl_level ){
		psw = disable_interrupts(I32_bit);
		pxa2x0_setipl(ipl);
		restore_interrupts(psw);
	}

	return (old);
}

int
pxa2x0_spllower(int ipl)
{
	int old = current_spl_level;
	int psw = disable_interrupts(I32_bit);
	pxa2x0_splx(ipl);
	restore_interrupts(psw);
	return(old);
}

void
pxa2x0_setsoftintr(int si)
{
#if 0
	atomic_set_bit( (u_int *)&softint_pending, SI_TO_IRQBIT(si) );
#else
	softint_pending |=  SI_TO_IRQBIT(si);
#endif

	/* Process unmasked pending soft interrupts. */
	if ( softint_pending & intr_mask )
		pxa2x0_do_pending();
@


1.9
log
@fix botched tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1336 1
		extern const char copyright[];
@


1.8
log
@Pass boot arguments from zboot/zbsdmod to the loaded kernel, and cope
with 32-bit lseek() in zboot (make 'boot' and 'ls' work above 2G).
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
@


1.7
log
@Overhaul of the pxa2x0_lcd code, to allow early (before autoconf) attachment,
and collateral changes.

Because this driver requires us_dma (and as such, vm services) to work, it
can not be selected in consinit(). Instead, add a hook to the arm
cpu_startup() which will, on zaurus, switch console from serial (selected
in consinit()) to lcd.

This also makes the zaurus-specific early pxa2x0_clkman() substitute code
cleaner.

While there, move boot -c handling later, after the glass console is set up.

Tested by drahn@@ and uwe@@
@
text
@d239 3
a241 1
#if 0
a242 2
void	parse_mi_bootargs(char *args);
#endif
a750 1
#if 0
d755 1
a755 4
	process_kernel_args((char *)nwbootinfo.bt_args);
#else
	boothowto = RB_AUTOBOOT;
#endif
a1176 1
#if 0
d1181 8
d1192 1
a1192 1
	strncpy(bootargs, args, MAX_BOOT_STRING);
d1212 1
d1214 1
a1215 1
#endif
@


1.6
log
@Wait for disk to spin down before reboot.  Should avoid unexpected fscks.
ok drahn@@
@
text
@a114 4
#include <sys/cdefs.h>
#include "rd.h"
#include "lcd.h"

d154 2
d245 1
d501 1
a501 1
	    VM_PROT_READ|VM_PROT_WRITE, PTE_NOCACHE);
d597 1
a602 1

d691 2
a692 3
	   XXX: this should not be done here. */
	ioreg_write(ZAURUS_CLKMAN_VBASE+CLKMAN_CKEN, CKEN_FFUART|CKEN_BTUART |
	    ioreg_read(ZAURUS_CLKMAN_VBASE+CLKMAN_CKEN));
d697 7
d706 2
a707 2
	map_func_save = pxa2x0_a4x_bs_tag.bs_map;
	pxa2x0_a4x_bs_tag.bs_map = bootstrap_bs_map;
d709 1
a1084 9
        if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
							}


d1162 5
a1176 2
	pxa2x0_a4x_bs_tag.bs_map = map_func_save ;

a1227 1

a1231 1
	uint32_t ckenreg = ioreg_read(ZAURUS_CLKMAN_VBASE+CLKMAN_CKEN);
a1243 3
	if (0) {
		/* We don't use FF serial when S17=no-dot position */
	}
d1245 1
a1245 1
	else if (0 == strcmp(kgdb_devname, "ffuart")) {
d1247 1
a1247 1
	}
d1249 3
a1251 10
	else if (0 == comcnattach(&pxa2x0_a4x_bs_tag, PXA2X0_FFUART_BASE, 
		     comcnspeed, PXA2X0_COM_FREQ, comcnmode)) {
#if 0
		/* XXX: can't call pxa2x0_clkman_config yet */
		pxa2x0_clkman_config(CKEN_FFUART, 1);
#else
		ioreg_write(ZAURUS_CLKMAN_VBASE+CLKMAN_CKEN,
		    ckenreg|CKEN_FFUART);
#endif

d1258 1
a1258 1
	if (0 == strcmp(kgdb_devname, "btuart")) {
d1262 3
a1264 4
	if (0 == comcnattach(&pxa2x0_a4x_bs_tag, PXA2X0_BTUART_BASE,
		comcnspeed, PXA2X0_COM_FREQ, comcnmode)) {
		ioreg_write(ZAURUS_CLKMAN_VBASE+CLKMAN_CKEN,
		    ckenreg|CKEN_BTUART);
a1268 1

a1269 1

d1277 2
a1278 3
	paddr_t paddr = 0;
	enum pxa2x0_uart_id uart_id;
	uint32_t ckenreg = ioreg_read(ZAURUS_CLKMAN_VBASE+CLKMAN_CKEN);
d1280 1
a1280 1
	if (0 == strcmp(kgdb_devname, "ffuart")) {
d1282 2
a1283 3
		clenreg |= CKEN_FFUART;
	}
	else if (0 == strcmp(kgdb_devname, "btuart")) {
d1285 7
a1291 1
		clenreg |= CKEN_BTUART;
d1293 9
d1303 19
a1321 3
	if (paddr &&
	    0 == com_kgdb_attach_pxa2x0(&pxa2x0_a4x_bs_tag, paddr,
		kgdb_rate, PXA2X0_COM_FREQ, COM_TYPE_PXA2x0, comkgdbmode)) {
d1323 12
a1334 1
		ioreg_write(ZAURUS_CLKMAN_VBASE+CLKMAN_CKEN, ckenreg);
d1337 8
a1345 1
#endif
d1405 1
a1405 1
	#if 0
d1407 3
a1409 3
	#else
		softint_pending |=  SI_TO_IRQBIT(si);
	#endif
@


1.5
log
@Lubbock scrubbing.
@
text
@d345 1
d392 1
@


1.4
log
@Support reboot and powerdown.
ok drahn@@
@
text
@d420 1
a420 7
	    LUBBOCK_OBIO_VBASE,
	    LUBBOCK_OBIO_PBASE,
	    LUBBOCK_OBIO_SIZE,
	    PTE_NOCACHE,
    },
    {
	    LUBBOCK_GPIO_VBASE,
d426 1
a426 1
	    LUBBOCK_CLKMAN_VBASE,
d432 1
a432 1
	    LUBBOCK_INTCTL_VBASE,
d438 1
a438 1
	    LUBBOCK_INTCTL_VBASE,
d444 1
a444 1
	    LUBBOCK_AGPIO_VBASE,
d484 1
a484 1
static vaddr_t section_free = LUBBOCK_VBASE_FREE;
d514 1
a514 1
	for (va = LUBBOCK_IO_AREA_VBASE;
d532 1
a532 1
		p = (u_int16_t *)(LUBBOCK_AGPIO_VBASE+0x24);
a598 8
#if 0
#define LEDSTEP_P() 	ioreg_write(LUBBOCK_OBIO_PBASE+LUBBOCK_HEXLED, led_data++)
#define LEDSTEP() hex_led(led_data++)
#else
#define LEDSTEP_P() 	
#define LEDSTEP()
#endif

a600 2
	/* use physical address until pagetable is set */
	LEDSTEP_P();
a612 1
	LEDSTEP_P();
d673 1
a673 1
	pxa2x0_gpio_bootstrap(LUBBOCK_GPIO_VBASE);
d691 2
a692 2
	ioreg_write(LUBBOCK_CLKMAN_VBASE+CLKMAN_CKEN, CKEN_FFUART|CKEN_BTUART |
	    ioreg_read(LUBBOCK_CLKMAN_VBASE+CLKMAN_CKEN));
a696 2
	LEDSTEP();

a701 3
	LEDSTEP();


a702 1
	LEDSTEP();
a704 1
	LEDSTEP();
d738 2
a739 2
		tmp = ioreg_read(LUBBOCK_SACC_PBASE+SACCSBI_SKCR);
		ioreg_write(LUBBOCK_SACC_PBASE+SACCSBI_SKCR,
d758 3
a760 21
		int processor_card_id;

		processor_card_id = 0x000f & 
			ioreg_read(LUBBOCK_OBIO_VBASE+LUBBOCK_MISCRD);
		switch(processor_card_id){
		case 0:
			/* Cotulla */
			memstart = 0xa0000000;
			memsize =  0x02000000; /* 32MB -phone */ 
			memsize =  0x04000000; /* 64MB */
			break;
		case 1:
			/* XXX: Sabiani */
			memstart = 0xa0000000;
			memsize = 0x04000000; /* 64MB */
			break;
		default:
			/* XXX: Unknown  */
			memstart = 0xa0000000;
			memsize = 0x04000000; /* 64MB */
		}
a885 2
	LEDSTEP();

a1056 2
	LEDSTEP();

d1059 1
a1059 3
	pxa2x0_intr_bootstrap(LUBBOCK_INTCTL_VBASE);

	LEDSTEP();
a1064 1
	LEDSTEP();
a1141 1
	LEDSTEP();
a1143 1
	LEDSTEP();
a1148 14
#if 0
	/* XXX - drahn */
	{
		uint16_t sw = ioreg16_read(LUBBOCK_OBIO_VBASE+LUBBOCK_USERSW);

		if (0 == (sw & (1<<13))) /* check S19 */
			boothowto |= RB_KDB;
		if (0 == (sw & (1<<12))) /* S20 */
			boothowto |= RB_SINGLE;
	}
#endif

	LEDSTEP();

d1231 1
a1231 1
	uint32_t ckenreg = ioreg_read(LUBBOCK_CLKMAN_VBASE+CLKMAN_CKEN);
a1243 4
	/* Check switch. */
	/*
	if (0 == (ioreg_read(LUBBOCK_OBIO_VBASE+LUBBOCK_USERSW) & (1<<15))) {
	*/
d1258 1
a1258 1
		ioreg_write(LUBBOCK_CLKMAN_VBASE+CLKMAN_CKEN,
d1274 1
a1274 1
		ioreg_write(LUBBOCK_CLKMAN_VBASE+CLKMAN_CKEN,
d1292 1
a1292 1
	uint32_t ckenreg = ioreg_read(LUBBOCK_CLKMAN_VBASE+CLKMAN_CKEN);
d1307 1
a1307 1
		ioreg_write(LUBBOCK_CLKMAN_VBASE+CLKMAN_CKEN, ckenreg);
a1309 20
}
#endif

#if 0
/*
 * display a number in hex LED.
 * a digit is blank when the corresponding bit in arg blank is 1
 */
unsigned short led_control_value = 0;

void
hex_led_blank(uint32_t value, int blank)
{
	int save = disable_interrupts(I32_bit);

	ioreg_write(LUBBOCK_OBIO_VBASE+0x10, value);
	led_control_value = (led_control_value & 0xff)
		| ((blank & 0xff)<<8);
	ioreg_write(LUBBOCK_OBIO_VBASE+0x40, led_control_value);
	restore_interrupts(save);
@


1.3
log
@Try a watchdog reset (that powers off the zaurus) before cpu_reset().
ok drahn@@
@
text
@d1 1
d238 3
d268 49
d345 3
a347 2
		pxa2x0_watchdog_boot();
		cpu_reset();
d378 7
d391 3
a393 2
	pxa2x0_watchdog_boot();
	cpu_reset();
@


1.2
log
@Fix a hex/decimal bug pointed out by uwe, quiet the boot a bit.
@
text
@d292 1
d330 1
@


1.1
log
@Port of OpenBSD to the Zaurus, currently running on C860, soon C3000.
@
text
@d474 1
a474 1
		p = (u_int16_t *)(LUBBOCK_AGPIO_VBASE+24);
d481 1
d506 1
a660 1
	sysprobe();
@

