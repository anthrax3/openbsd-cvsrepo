head	1.29;
access;
symbols
	OPENBSD_6_0:1.28.0.12
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.8
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.10
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.10
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.8
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.6
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.21.0.16
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.12
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.14
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.10
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.8
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.6
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13;
locks; strict;
comment	@ * @;


1.29
date	2016.09.03.13.37.44;	author guenther;	state dead;
branches;
next	1.28;
commitid	6T3r4QcMFKe3Fo5T;

1.28
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.21.10.36.22;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.20.20.07.28;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.07.16.21.41;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.30.21.35.57;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.27.05.04.11;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.02.20.50.14;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.02.04.02.59;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.22.18.47.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.15.20.23.10;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.01.23.57.28;	author uwe;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.24.20.32.43;	author uwe;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.11.03.32.48;	author uwe;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.22.22.19.12;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.31.02.22.17;	author uwe;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.21.16.22.34;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.13.17.44.43;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.13.17.43.31;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.06.23.47.22;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.06.16.50.45;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.05.23.28.54;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.05.19.12.48;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.05.18.11.57;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.03.04.50.22;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.02.19.43.07;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.31.00.04.35;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Retire zaurus, as it hasn't made the EABI jump and will be permanently broken
shortly when we use the hardware thread register in userland
@
text
@/*	$OpenBSD: zaurus_lcd.c,v 1.28 2013/12/06 21:03:05 deraadt Exp $	*/
/* $NetBSD: lubbock_lcd.c,v 1.1 2003/08/09 19:38:53 bsh Exp $ */

/*
 * Copyright (c) 2002, 2003  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Genetec Corporation may not be used to endorse or
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * LCD driver for Sharp Zaurus (based on the Intel Lubbock driver).
 *
 * Controlling LCD is almost completely done through PXA2X0's
 * integrated LCD controller.  Codes for it is arm/xscale/pxa2x0_lcd.c.
 *
 * Codes in this file provide platform specific things including:
 *   LCD on/off switch and backlight brightness
 *   LCD panel geometry
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/uio.h>
#include <sys/malloc.h>

#include <dev/cons.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_callbacks.h>

#include <machine/bus.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0_lcd.h>

#include <zaurus/dev/zaurus_scoopvar.h>
#include <zaurus/dev/zaurus_sspvar.h>

#include <dev/rasops/rasops.h>

int	lcd_match(struct device *, void *, void *);
void	lcd_attach(struct device *, struct device *, void *);
int	lcd_activate(struct device *, int);
int	lcd_cnattach(void (*)(u_int, int));

/*
 * wsdisplay glue
 */
struct pxa2x0_wsscreen_descr
lcd_bpp16_screen = {
	{
		"std"
	},
	16,				/* bits per pixel */
	RI_ROTATE_CW			/* quarter clockwise rotation */
};

static const struct wsscreen_descr *lcd_scr_descr[] = {
	&lcd_bpp16_screen.c
};

const struct wsscreen_list lcd_screen_list = {
	sizeof lcd_scr_descr / sizeof lcd_scr_descr[0], lcd_scr_descr
};

int	lcd_ioctl(void *, u_long, caddr_t, int, struct proc *);
int	lcd_show_screen(void *, void *, int,
	    void (*)(void *, int, int), void *);
void	lcd_burner(void *, u_int, u_int);

int	lcd_param(struct pxa2x0_lcd_softc *, u_long, struct wsdisplay_param *);

const struct wsdisplay_accessops lcd_accessops = {
	.ioctl = lcd_ioctl,
	.mmap = pxa2x0_lcd_mmap,
	.alloc_screen = pxa2x0_lcd_alloc_screen,
	.free_screen = pxa2x0_lcd_free_screen,
	.show_screen = lcd_show_screen,
	.load_font = pxa2x0_lcd_load_font,
	.list_font = pxa2x0_lcd_list_font,
	.burn_screen = lcd_burner
};

struct cfattach lcd_pxaip_ca = {
	sizeof (struct pxa2x0_lcd_softc), lcd_match, lcd_attach, NULL,
	lcd_activate
};

struct cfdriver lcd_cd = {
	NULL, "lcd", DV_DULL
};

#define CURRENT_DISPLAY &sharp_zaurus_C3000

const struct lcd_panel_geometry sharp_zaurus_C3000 =
{
	480,			/* Width */
	640,			/* Height */
	0,			/* No extra lines */

	LCDPANEL_ACTIVE | LCDPANEL_VSP | LCDPANEL_HSP,
	1,			/* clock divider */
	0,			/* AC bias pin freq */

	0x28,			/* horizontal sync pulse width */
	0x2e,			/* BLW */
	0x7d,			/* ELW */

	2,			/* vertical sync pulse width */
	1,			/* BFW */
	0,			/* EFW */
};

struct sharp_lcd_backlight {
	int	duty;		/* LZ9JG18 DAC value */
	int	cont;		/* BACKLIGHT_CONT signal */
	int	on;		/* BACKLIGHT_ON signal */
};

#define CURRENT_BACKLIGHT sharp_zaurus_C3000_bl

const struct sharp_lcd_backlight sharp_zaurus_C3000_bl[] = {
	{ 0x00, 0, 0 },		/* 0:     Off */
	{ 0x00, 0, 1 },		/* 1:      0% */
	{ 0x01, 0, 1 },		/* 2:     20% */
	{ 0x07, 0, 1 },		/* 3:     40% */
	{ 0x01, 1, 1 },		/* 4:     60% */
	{ 0x07, 1, 1 },		/* 5:     80% */
	{ 0x11, 1, 1 },		/* 6:    100% */
	{ -1, -1, -1 }		/* 7: Invalid */
};

int	lcd_max_brightness(void);
int	lcd_get_brightness(void);
void	lcd_set_brightness(int);
void	lcd_set_brightness_internal(int);
int	lcd_get_backlight(void);
void	lcd_set_backlight(int);
void	lcd_blank(int);

int
lcd_match(struct device *parent, void *cf, void *aux)
{
	return 1;
}

void
lcd_attach(struct device *parent, struct device *self, void *aux)
{
	struct pxa2x0_lcd_softc *sc = (struct pxa2x0_lcd_softc *)self;
	struct wsemuldisplaydev_attach_args aa;
	extern int glass_console;

	printf("\n");

	pxa2x0_lcd_attach_sub(sc, aux, &lcd_bpp16_screen, CURRENT_DISPLAY,
	    glass_console);

	aa.console = glass_console;
	aa.scrdata = &lcd_screen_list;
	aa.accessops = &lcd_accessops;
	aa.accesscookie = sc;
	aa.defaultscreens = 0;

	(void)config_found(self, &aa, wsemuldisplaydevprint);

	/* Start with approximately 40% of full brightness. */
	lcd_set_brightness(3);
}

int
lcd_cnattach(void (*clkman)(u_int, int))
{
	return
	    (pxa2x0_lcd_cnattach(&lcd_bpp16_screen, CURRENT_DISPLAY, clkman));
}

/*
 * wsdisplay accessops overrides
 */

int
lcd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct pxa2x0_lcd_softc *sc = v;
	int res = EINVAL;

	switch (cmd) {
	case WSDISPLAYIO_GETPARAM:
	case WSDISPLAYIO_SETPARAM:
		res = lcd_param(sc, cmd, (struct wsdisplay_param *)data);
		break;
	}

	if (res == EINVAL)
		res = pxa2x0_lcd_ioctl(v, cmd, data, flag, p);

	return res;
}

void
lcd_burner(void *v, u_int on, u_int flags)
{

	lcd_set_brightness(on ? lcd_get_brightness() : 0);
}

int
lcd_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	int rc;

	if ((rc = pxa2x0_lcd_show_screen(v, cookie, waitok, cb, cbarg)) != 0)
		return (rc);

	/* Turn on LCD */
	lcd_burner(v, 1, 0);

	return (0);
}

/*
 * wsdisplay I/O controls
 */

int
lcd_param(struct pxa2x0_lcd_softc *sc, u_long cmd,
    struct wsdisplay_param *dp)
{
	int res = EINVAL;

	switch (dp->param) {
	case WSDISPLAYIO_PARAM_BACKLIGHT:
		if (cmd == WSDISPLAYIO_GETPARAM) {
			dp->min = 0;
			dp->max = 1;
			dp->curval = lcd_get_backlight();
			res = 0;
		} else if (cmd == WSDISPLAYIO_SETPARAM) {
			lcd_set_backlight(dp->curval);
			res = 0;
		}
		break;

	case WSDISPLAYIO_PARAM_CONTRAST:
		/* unsupported */
		res = ENOTTY;
		break;

	case WSDISPLAYIO_PARAM_BRIGHTNESS:
		if (cmd == WSDISPLAYIO_GETPARAM) {
			dp->min = 1;
			dp->max = lcd_max_brightness();
			dp->curval = lcd_get_brightness();
			res = 0;
		} else if (cmd == WSDISPLAYIO_SETPARAM) {
			lcd_set_brightness(dp->curval);
			res = 0;
		}
		break;
	}

	return res;
}

/*
 * LCD backlight
 */

static	int lcdbrightnesscurval = 1;
static	int lcdislit = 1;
static	int lcdisblank = 0;

int
lcd_max_brightness(void)
{
	int i;

	for (i = 0; CURRENT_BACKLIGHT[i].duty != -1; i++)
		;
	return i - 1;
}

int
lcd_get_brightness(void)
{

	return lcdbrightnesscurval;
}

void
lcd_set_brightness(int newval)
{
	int max;

	max = lcd_max_brightness();
	if (newval < 0)
		newval = 0;
	else if (newval > max)
		newval = max;

	if (lcd_get_backlight() && !lcdisblank)
		lcd_set_brightness_internal(newval);

	if (newval > 0)
		lcdbrightnesscurval = newval;
}

void
lcd_set_brightness_internal(int newval)
{
	static int curval = 1;
	int i;

	/*
	 * It appears that the C3000 backlight can draw too much power if we
	 * switch it from a low to a high brightness.  Increasing brightness
	 * in steps avoids this issue.
	 */
	if (newval > curval) {
		for (i = curval + 1; i <= newval; i++) {
			(void)zssp_ic_send(ZSSP_IC_LZ9JG18,
			    CURRENT_BACKLIGHT[i].duty);
			scoop_set_backlight(CURRENT_BACKLIGHT[i].on,
			    CURRENT_BACKLIGHT[i].cont);
			delay(5000);
		}
	} else {
		(void)zssp_ic_send(ZSSP_IC_LZ9JG18,
		    CURRENT_BACKLIGHT[newval].duty);
		scoop_set_backlight(CURRENT_BACKLIGHT[newval].on,
		    CURRENT_BACKLIGHT[newval].cont);
	}

	curval = newval;
}

int
lcd_get_backlight(void)
{

	return lcdislit;
}

void
lcd_set_backlight(int on)
{

	if (!on) {
		lcd_set_brightness(0);
		lcdislit = 0;
	} else {
		lcdislit = 1;
		lcd_set_brightness(lcd_get_brightness());
	}
}

void
lcd_blank(int blank)
{

	if (blank) {
		lcd_set_brightness(0);
		lcdisblank = 1;
	} else {
		lcdisblank = 0;
		lcd_set_brightness(lcd_get_brightness());
	}
}

int
lcd_activate(struct device *self, int act)
{
	struct pxa2x0_lcd_softc *sc = (struct pxa2x0_lcd_softc *)self;
	int ret = 0;

	switch (act) {
	case DVACT_SUSPEND:
		lcd_set_brightness(0);
		pxa2x0_lcd_suspend(sc);
		break;
	case DVACT_RESUME:
		pxa2x0_lcd_resume(sc);
		lcd_set_brightness(lcd_get_brightness());
		break;
	default:
		ret = config_activate_children(self, act);
		break;
	}
	return (ret);
}
@


1.28
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.27 2013/10/21 10:36:22 miod Exp $	*/
@


1.27
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.26 2013/10/20 20:07:28 miod Exp $	*/
d411 1
a411 1
	case DVACT_POWERDOWN:
@


1.26
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.25 2013/05/30 16:15:01 deraadt Exp $	*/
a90 1
void	lcd_burner(void *, u_int, u_int);
d93 1
d95 1
a95 2
int	lcd_param(struct pxa2x0_lcd_softc *, u_long,
    struct wsdisplay_param *);
d103 2
@


1.25
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.24 2010/09/07 16:21:41 deraadt Exp $	*/
d99 6
a104 9
	lcd_ioctl,
	pxa2x0_lcd_mmap,
	pxa2x0_lcd_alloc_screen,
	pxa2x0_lcd_free_screen,
	lcd_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	lcd_burner
@


1.24
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.23 2010/08/30 21:35:57 deraadt Exp $	*/
d402 1
d413 3
d417 1
a417 1
	return 0;
@


1.23
log
@Convert all powerhooks to activate functions, and provide powerhook stubs.
Of note:  lcd stubs get pulled up to the parent; zts has to keep track of
whether it is in use or not
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.22 2010/08/27 05:04:11 deraadt Exp $	*/
a165 1
void	lcd_powerhook(int, void *);
a194 2

	(void)powerhook_establish(lcd_powerhook, sc);
a414 7

void
lcd_powerhook(int why, void *v)
{
	lcd_activate(v, why);
}

@


1.22
log
@More killing of PWR_STANDBY.  cvs skipped these files
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.21 2006/11/29 12:13:54 miod Exp $	*/
d65 1
d67 1
a67 1
int	lcd_match(struct device *, void *, void *);
d111 2
a112 1
	sizeof (struct pxa2x0_lcd_softc), lcd_match, lcd_attach
d166 1
a166 1
void	lcd_power(int, void *);
d197 1
a197 1
	(void)powerhook_establish(lcd_power, sc);
d401 2
a402 2
void
lcd_power(int why, void *v)
d404 1
d406 2
a407 2
	switch (why) {
	case PWR_SUSPEND:
d409 1
a409 1
		pxa2x0_lcd_power(why, v);
d411 2
a412 3

	case PWR_RESUME:
		pxa2x0_lcd_power(why, v);
d416 1
d418 7
@


1.21
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.20 2006/06/02 20:50:14 miod Exp $	*/
a404 1
	case PWR_STANDBY:
@


1.20
log
@Fix name of lcd(4) in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.19 2006/02/02 04:02:59 drahn Exp $	*/
d188 1
@


1.19
log
@Backout lcd_suspend on lid close, found to cause crashes.
requested by jolan, prodded by bob.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.18 2005/12/22 18:47:25 deraadt Exp $	*/
d114 1
a114 1
	NULL, "lcd_pxaip", DV_DULL
@


1.18
log
@disable lcd (dma) when screen is closed.  in theory this should speed
up the memory subsystem performance making the processor run faster.
but in tests i do not see this.  maybe we also need to tweak the system
bus arbiter ARB_CNTRL to grant more bus cycles to the cpu?
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.17 2005/09/15 20:23:10 miod Exp $	*/
a171 2
struct pxa2x0_lcd_softc *lcd_softc;

a193 1
	lcd_softc = sc;
a391 1
		pxa2x0_lcd_suspend(lcd_softc);
a393 1
		pxa2x0_lcd_resume(lcd_softc);
@


1.17
log
@Stop compiling the texte console rotation code #ifdef __zaurus__, but use
a flag in the rasops_info structure; drivers which may use it shall declare
a specific attribute for the config(8) machinery, so that the necessary code
is compiled in.

In addition to this, rotated font computation is now done on-demand, and a
list of unrotated-rotated font cookie pairs is kept, rather than rotating all
built-in wsfonts at initialization time.

No user-perceptible functional change.

Tested matthieu@@ uwe@@, ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.16 2005/07/01 23:57:28 uwe Exp $	*/
d16 1
a16 1
 * 3. The name of Genetec Corporation may not be used to endorse or 
d50 1
a50 1
#include <dev/cons.h> 
d52 1
a52 1
#include <dev/wscons/wsdisplayvar.h> 
d112 1
a112 1
	 
d172 2
d196 1
d245 1
a245 1
	
d309 2
a310 1
	for (i = 0; CURRENT_BACKLIGHT[i].duty != -1; i++);
d395 1
d398 1
@


1.16
log
@relax header dependencies
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.15 2005/05/24 20:32:43 uwe Exp $	*/
d63 2
d77 2
a78 1
	16				/* bits per pixel */
@


1.15
log
@serial console support
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.14 2005/04/11 03:32:48 uwe Exp $	*/
a58 3

#include <machine/zaurus_reg.h>
#include <machine/zaurus_var.h>
@


1.14
log
@- eliminate extra powerhook in pxalcd, inspired by ohci changes
- update file comment for zaurus_lcd.c
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.13 2005/02/22 22:19:12 uwe Exp $	*/
d177 1
a177 3
	int console;

	console = 1;		/* XXX allow user configuration? */
d182 1
a182 1
	    console);
d184 1
a184 1
	aa.console = console;
@


1.13
log
@- Shift the brightness scale so that 0% still keeps the backlight on.
- Separate wsconsctl display.backlight from display.brightness parameter.
- Set brightness to approximately 40% on startup, since we cannot read
  the current brightness level yet.
- Restore the current brightness on resume.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.12 2005/01/31 02:22:17 uwe Exp $	*/
d34 1
a34 1
 * LCD driver for Intel Lubbock.
d40 1
a40 1
 *   LCD on/off switch in on-board PLD register.
d164 1
a164 1
void	lcd_powerhook(int, void *);
d196 1
a196 1
	(void)powerhook_establish(lcd_powerhook, sc);
d350 2
a351 1
			zssp_write_lz9jg18(CURRENT_BACKLIGHT[i].duty);
d357 2
a358 1
		zssp_write_lz9jg18(CURRENT_BACKLIGHT[newval].duty);
d400 1
a400 1
lcd_powerhook(int why, void *v)
d407 1
d411 1
@


1.12
log
@Make LCD brightness adjustable by wsconsctl(1), and fix the base address
of scoop1 to make it work.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.11 2005/01/21 16:22:34 miod Exp $	*/
d139 3
a141 3
	int	duty;
	int	vr;
	int	on;
d147 8
a154 8
	{ 0x00, 0, 0 },		/* Light Off */
	{ 0x00, 0, 1 },
	{ 0x01, 0, 1 },
	{ 0x07, 0, 1 },
	{ 0x01, 1, 1 },
	{ 0x07, 1, 1 },
	{ 0x11, 1, 1 },
	{ -1, -1, -1 }		/* End of table */
d160 3
a162 1

d193 2
a194 1
	lcd_set_brightness(1);
d233 1
a233 4
	if (on && lcd_get_brightness() == 0)
		lcd_set_brightness(1);
	else if (!on && lcd_get_brightness() > 0)
		lcd_set_brightness(0);
d263 11
d281 1
a281 1
			dp->min = 0; /* XXX or 1? */
d300 1
a300 1
static	int lcdbrightnessaltval = 1;
d316 1
a316 4
	if (lcdisblank)
		return lcdbrightnessaltval;
	else
		return lcdbrightnesscurval;
a322 6
	int i;

	if (lcdisblank) {
		lcdbrightnessaltval = newval;
		return;
	}
d330 13
d348 2
a349 2
	if (newval > lcdbrightnesscurval) {
		for (i = lcdbrightnesscurval + 1; i <= newval; i++) {
d352 1
a352 1
			    CURRENT_BACKLIGHT[i].vr);
d358 1
a358 1
		    CURRENT_BACKLIGHT[newval].vr);
d361 21
a381 1
	lcdbrightnesscurval = newval;
d388 1
a388 2
	if (blank && !lcdisblank) {
		lcdbrightnessaltval = lcdbrightnesscurval;
d391 1
a391 1
	} else if (!blank && lcdisblank) {
d393 1
a393 1
		lcd_set_brightness(lcdbrightnessaltval);
a399 1
	static int lcdwasblank = 0;
d404 1
a404 2
		lcdwasblank = lcdisblank;
		lcd_blank(1);
d408 1
a408 1
		lcd_blank(lcdwasblank);
@


1.11
log
@Overhaul of the pxa2x0_lcd code, to allow early (before autoconf) attachment,
and collateral changes.

Because this driver requires us_dma (and as such, vm services) to work, it
can not be selected in consinit(). Instead, add a hook to the arm
cpu_startup() which will, on zaurus, switch console from serial (selected
in consinit()) to lcd.

This also makes the zaurus-specific early pxa2x0_clkman() substitute code
cleaner.

While there, move boot -c handling later, after the glass console is set up.

Tested by drahn@@ and uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.10 2005/01/13 17:44:43 drahn Exp $	*/
d63 3
d89 1
d94 3
d98 1
a98 1
	pxa2x0_lcd_ioctl,
d138 26
d190 4
d207 19
d229 5
a233 14
#if 0
	struct obio_softc *osc = 
	    (struct obio_softc *)((struct device *)v)->dv_parent;
	uint16_t reg;

	reg = bus_space_read_2(osc->sc_iot, osc->sc_obioreg_ioh,
	    LUBBOCK_MISCWR);
	if (on)
		reg |= MISCWR_LCDDISP;
	else
		reg &= ~MISCWR_LCDDISP;
	bus_space_write_2(osc->sc_iot, osc->sc_obioreg_ioh,
	    LUBBOCK_MISCWR, reg);
#endif
d249 130
@


1.10
log
@do not keep references to obio in this.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.9 2005/01/13 17:43:31 drahn Exp $	*/
d63 1
d65 1
a65 2
void	lcd_attach(struct device *, struct device *, void *);
int	lcdintr(void *);
d73 1
a73 1
		"std" /* "bpp16" */
a75 12
#ifdef notyet
}, lcd_bpp8_screen = {
	{
		"bpp8"
	},
	8				/* bits per pixel */
}, lcd_bpp4_screen = {
	{
		"bpp4"
	},
	4				/* bits per pixel */
#endif
a77 1

d79 1
a79 6
#ifdef notyet
	/* bpp4 needs a patch to rasops4 */
	&lcd_bpp4_screen.c,
	&lcd_bpp8_screen.c,
#endif
	&lcd_bpp16_screen.c,
d110 21
a136 21
#define CURRENT_DISPLAY &sharp_zaurus_C3000

static const struct lcd_panel_geometry sharp_zaurus_C3000 =
{
    480,			/* Width */
    640,			/* Height */
    0,				/* No extra lines */

    LCDPANEL_ACTIVE | LCDPANEL_VSP | LCDPANEL_HSP,
    1,				/* clock divider */
    0,				/* AC bias pin freq */

    0x28,			/* horizontal sync pulse width */
    0x2e,			/* BLW */
    0x7d,			/* ELW */

    2,				/* vertical sync pulse width */
    1,				/* BFW */
    0,				/* EFW */
};

d142 1
a142 1
	long defattr;
d144 1
a144 8
	pxa2x0_lcd_attach_sub(sc, aux, CURRENT_DISPLAY);

	/* make wsdisplay screen list */
	pxa2x0_lcd_setup_wsscreen(sc, &lcd_bpp16_screen, CURRENT_DISPLAY, NULL);
#ifdef notyet
	pxa2x0_lcd_setup_wsscreen(sc, &lcd_bpp8_screen, CURRENT_DISPLAY, NULL);
	pxa2x0_lcd_setup_wsscreen(sc, &lcd_bpp4_screen, CURRENT_DISPLAY, NULL);
#endif
d148 2
a149 16
	aa.console = 1;		/* XXX allow user configuration? */

	if (aa.console != 0) {
		if (pxa2x0_lcd_setup_console(sc, &lcd_bpp16_screen) == 0) {
			/* assumes 16bpp */
			sc->sc_ro.ri_ops.alloc_attr(&sc->sc_ro, 0, 0, 0,
			    &defattr);

			wsdisplay_cnattach(&lcd_bpp16_screen.c, &sc->sc_ro,
			    sc->sc_ro.ri_ccol, sc->sc_ro.ri_crow, defattr);
		} else {
			printf("%s: failed to initialize console!\n",
			    sc->dev.dv_xname);
			aa.console = 0;	/* better than panicing... */
		}
	}
d151 1
d158 11
@


1.9
log
@dont play with obio, this was very likely always wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.8 2005/01/06 23:47:22 miod Exp $	*/
d120 1
a120 1
struct cfattach lcd_obio_ca = {
d125 1
a125 1
	NULL, "lcd_obio", DV_DULL
@


1.8
log
@Lazy man's display console on Zaurus: allow the display to be attached as a
console when it is probed. Earlier boot messages are still being sent to the
serial port for now.

While there, swap blue and red in 16bpp mode to get the expected display
colours.

Tested and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.7 2005/01/06 16:50:45 miod Exp $	*/
d200 1
d213 1
@


1.7
log
@Bring back the code simplifications after debug and testing by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.6 2005/01/05 23:28:54 drahn Exp $	*/
d160 1
d171 19
a189 1
	aa.console = 0;			/* XXX */
a192 2

	printf("\n");
@


1.6
log
@Correct value here allows cleaner screen display.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.5 2005/01/05 19:12:48 miod Exp $	*/
d73 1
a73 2
		"std" /* "bpp16" */, 0, 0,
		&pxa2x0_lcd_emulops,
d79 1
a79 2
		"bpp8", 0, 0,
		&pxa2x0_lcd_emulops,
d84 1
a84 2
		"bpp4", 0, 0,
		&pxa2x0_lcd_emulops,
d134 1
a134 1
#define CURRENT_DISPLAY sharp_zaurus_C3000
d161 1
a161 1
	pxa2x0_lcd_attach_sub(sc, aux, &CURRENT_DISPLAY);
d164 1
a164 1
	pxa2x0_lcd_setup_wsscreen(&lcd_bpp16_screen, &CURRENT_DISPLAY, NULL);
d166 2
a167 2
	pxa2x0_lcd_setup_wsscreen(&lcd_bpp8_screen, &CURRENT_DISPLAY, NULL);
	pxa2x0_lcd_setup_wsscreen(&lcd_bpp4_screen, &CURRENT_DISPLAY, NULL);
@


1.5
log
@Partially revert some of these changes - misunderstanding between drahn@@ and I
about which diff he had tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.4 2005/01/05 18:11:57 miod Exp $	*/
d149 1
a149 1
    0x27,			/* horizontal sync pulse width */
@


1.4
log
@First steps in cleaning the Zaurus display code:
- kill the non-wscons code. Really.
- KNF, and english fixes.
- do not handle WSDISPLAYIO_[GS]VIDEO in the driver - the wsdisplay layer
  can do this, as long as we provide a burner accessop, so provide one.
- kill the emulops indirection.
- when setting the color palette in 8 or 4bpp mode, match the values used
  in the rasops color table (only affects normal white value).

test and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.3 2005/01/03 04:50:22 drahn Exp $	*/
d73 2
a74 1
		"std" /* "bpp16" */
d80 2
a81 1
		"bpp8"
d86 2
a87 1
		"bpp4"
d137 1
a137 1
#define CURRENT_DISPLAY &sharp_zaurus_C3000
d164 1
a164 1
	pxa2x0_lcd_attach_sub(sc, aux, CURRENT_DISPLAY);
d167 1
a167 1
	pxa2x0_lcd_setup_wsscreen(sc, &lcd_bpp16_screen, CURRENT_DISPLAY, NULL);
d169 2
a170 2
	pxa2x0_lcd_setup_wsscreen(sc, &lcd_bpp8_screen, CURRENT_DISPLAY, NULL);
	pxa2x0_lcd_setup_wsscreen(sc, &lcd_bpp4_screen, CURRENT_DISPLAY, NULL);
@


1.3
log
@Close to working display, just rotated 90 degrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_lcd.c,v 1.2 2005/01/02 19:43:07 drahn Exp $	*/
a42 4
#include <sys/cdefs.h>
/*
__KERNEL_RCSID(0, "$NetBSD: lubbock_lcd.c,v 1.1 2003/08/09 19:38:53 bsh Exp $");
*/
d63 2
a64 4
#include "wsdisplay.h"

int	lcd_match( struct device *, void *, void *);
void	lcd_attach( struct device *, struct device *, void *);
a66 2
#if NWSDISPLAY > 0

d70 2
a71 1
struct pxa2x0_wsscreen_descr lcd_bpp16_screen = {
d73 1
a73 4
		"bpp16", 0, 0,
		&pxa2x0_lcd_emulops,
		0, 0,
		WSSCREEN_WSCOLORS,
d76 1
d79 1
a79 4
		"bpp8", 0, 0,
		&pxa2x0_lcd_emulops,
		0, 0,
		WSSCREEN_WSCOLORS,
d84 1
a84 4
		"bpp4", 0, 0,
		&pxa2x0_lcd_emulops,
		0, 0,
		WSSCREEN_WSCOLORS,
d87 1
d92 1
a92 1
#if 0
d101 1
a101 2
	sizeof lcd_scr_descr / sizeof lcd_scr_descr[0],
	lcd_scr_descr
d104 1
a104 2
int	lcd_ioctl(void *, u_long, caddr_t, int, struct proc *);

d109 1
a109 1
	lcd_ioctl,
d114 4
a117 14
	NULL, /* load_font */
};

#else
/*
 * Interface to LCD framebuffer without wscons
 */
dev_type_open(lcdopen);
dev_type_close(lcdclose);
dev_type_ioctl(lcdioctl);
dev_type_mmap(lcdmmap);
const struct cdevsw lcd_cdevsw = {
	lcdopen, lcdclose, noread, nowrite,
	lcdioctl, nostop, notty, nopoll, lcdmmap, D_TTY
a119 6
#endif

#if 0
CFATTACH_DECL(lcd_obio, sizeof (struct pxa2x0_lcd_softc),  lcd_match,
    lcd_attach, NULL, NULL);
#endif
d121 1
a121 1
        sizeof (struct pxa2x0_lcd_softc), lcd_match, lcd_attach
d129 1
a129 1
lcd_match( struct device *parent, void *cf, void *aux )
d134 1
a134 4
/*
#define CURRENT_DISPLAY opus
*/
#define CURRENT_DISPLAY sharp_zaurus_C3000
d142 1
a142 1
    LCDPANEL_ACTIVE|LCDPANEL_VSP|LCDPANEL_HSP,
d155 2
a156 21
static const struct lcd_panel_geometry opus =
{
    240,			/* Width */
    320,			/* Height */
    0,				/* No extra lines */

    LCDPANEL_PASSIVE|LCDPANEL_PCP,
    10,				/* clock divider */
    0xff,			/* AC bias pin freq */

    2,				/* horizontal sync pulse width */
    3,				/* BLW */
    3,				/* ELW */

    1,				/* vertical sync pulse width */
    0,				/* BFW */
    0,				/* EFW */

};

void lcd_attach( struct device *parent, struct device *self, void *aux )
d159 1
d161 1
a161 1
	pxa2x0_lcd_attach_sub(sc, aux, &CURRENT_DISPLAY);
d163 6
d170 4
a173 24
#if NWSDISPLAY > 0

	{
		struct wsemuldisplaydev_attach_args aa;

		/* make wsdisplay screen list */
		pxa2x0_lcd_setup_wsscreen( &lcd_bpp16_screen, &CURRENT_DISPLAY, NULL );
		/*
		pxa2x0_lcd_setup_wsscreen( &lcd_bpp8_screen, &CURRENT_DISPLAY, NULL );
		pxa2x0_lcd_setup_wsscreen( &lcd_bpp4_screen, &CURRENT_DISPLAY, NULL );
		*/

		aa.console = 0;
		aa.scrdata = &lcd_screen_list;
		aa.accessops = &lcd_accessops;
		aa.accesscookie = sc;

		printf( "\n" );

		(void) config_found(self, &aa, wsemuldisplaydevprint);
	}
#else
	{
		struct pxa2x0_lcd_screen *screen = pxa2x0_lcd_new_screen( sc, 8 );
d175 1
a175 8
		if( screen ){
			sc->active = screen;
			pxa2x0_lcd_start_dma( sc, screen );
		}

		printf( "\n" );
	}
#endif
d177 1
d180 2
a181 4
#if NWSDISPLAY > 0

int
lcd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
d187 8
a194 14
	switch (cmd) {
	case WSDISPLAYIO_SVIDEO:
		reg = bus_space_read_2( osc->sc_iot, osc->sc_obioreg_ioh,
		    LUBBOCK_MISCWR );
		if( *(int *)data == WSDISPLAYIO_VIDEO_ON )
			reg |= MISCWR_LCDDISP;
		else
			reg &= ~MISCWR_LCDDISP;
		bus_space_write_2( osc->sc_iot, osc->sc_obioreg_ioh,
			LUBBOCK_MISCWR, reg );
		break;			/* turn on/off LCD controller */
	}

	return pxa2x0_lcd_ioctl( v, cmd, data, flag, p );
d201 1
a201 2
	struct obio_softc *osc = 
	    (struct obio_softc *)((struct device *)v)->dv_parent;
d203 2
a204 1
	pxa2x0_lcd_show_screen(v,cookie,waitok,cb,cbarg);
d207 1
a207 3
	bus_space_write_4( osc->sc_iot, osc->sc_obioreg_ioh, LUBBOCK_MISCWR,
	    MISCWR_LCDDISP |
	    bus_space_read_4( osc->sc_iot, osc->sc_obioreg_ioh, LUBBOCK_MISCWR ) );
a210 35



#else  /* NWSDISPLAY==0 */

int
lcdopen( dev_t dev, int oflags, int devtype, struct proc *p )
{
	return 0;
}

int
lcdclose( dev_t dev, int fflag, int devtype, struct proc *p )
{
	return 0;
}

paddr_t
lcdmmap( dev_t dev, off_t offset, int size )
{
	struct pxa2x0_lcd_softc *sc = device_lookup(&lcd_cd, minor(dev));
	struct pxa2x0_lcd_screen *scr = sc->active;

	return bus_dmamem_mmap( &pxa2x0_bus_dma_tag, scr->segs, scr->nsegs,
	    offset, 0, BUS_DMA_WAITOK|BUS_DMA_COHERENT );
}

int
lcdioctl( dev_t dev, u_long cmd, caddr_t data,
	    int fflag, struct proc *p )
{
	return EOPNOTSUPP;
}

#endif /* NWSDISPLAY>0 */
@


1.2
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d169 1
a169 1
#define CURRENT_DISPLAY sharp_LM8V31
d171 1
a171 1
static const struct lcd_panel_geometry sharp_LM8V31 =
d173 2
a174 2
    640,			/* Width */
    480,			/* Height */
d177 7
a183 7
    LCDPANEL_PASSIVE|LCDPANEL_PCP,
    10,				/* clock divider */
    0xff,			/* AC bias pin freq */

    2,				/* horizontal sync pulse width */
    3,				/* BLW */
    3,				/* ELW */
d185 2
a186 2
    1,				/* vertical sync pulse width */
    0,				/* BFW */
a187 1

@


1.1
log
@Port of OpenBSD to the Zaurus, currently running on C860, soon C3000.
@
text
@d1 1
@

