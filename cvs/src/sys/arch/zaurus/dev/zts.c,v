head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.6
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.14
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.10
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.11.0.14
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.10
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.17
date	2016.06.05.20.15.54;	author bru;	state Exp;
branches;
next	1.16;
commitid	liGGvUBP6Bv7by7V;

1.16
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.03.21.48.49;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.07.16.21.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.30.21.35.57;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.27.05.04.11;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.29.21.09.43;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.24.18.55.49;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.19.21.54.48;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.08.22.12.14;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.15.00.35.11;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.16.22.25.18;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.16.20.09.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.30.21.55.50;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.23.26.54;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.17.14.31;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Use the new input functions of wsmouse in mouse and touchscreen drivers.

ok stsp@@ kettenis@@
@
text
@/* $OpenBSD: zts.c,v 1.16 2014/03/29 18:09:30 guenther Exp $ */
/*
 * Copyright (c) 2005 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/kernel.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0_gpio.h>

#include <zaurus/dev/zaurus_sspvar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#include <dev/wscons/wsdisplayvar.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0_lcd.h>

#ifdef ZTS_DEBUG
#define DPRINTF(x)	do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

/*
 * ADS784x touch screen controller
 */
#define ADSCTRL_PD0_SH          0       /* PD0 bit */
#define ADSCTRL_PD1_SH          1       /* PD1 bit */
#define ADSCTRL_DFR_SH          2       /* SER/DFR bit */
#define ADSCTRL_MOD_SH          3       /* Mode bit */
#define ADSCTRL_ADR_SH          4       /* Address setting */
#define ADSCTRL_STS_SH          7       /* Start bit */

#define GPIO_TP_INT_C3K		11
#define GPIO_HSYNC_C3K		22

#define POLL_TIMEOUT_RATE0	((hz * 150)/1000)
#define POLL_TIMEOUT_RATE1	(hz / 100) /* XXX every tick */

#define CCNT_HS_400_VGA_C3K 6250	/* 15.024us */

struct tsscale {
	int minx, maxx;
	int miny, maxy;
	int swapxy;
	int resx, resy;
} zts_scale = {
	/* C3000 */
	209, 3620, 312, 3780, 0, 640, 480
};

int	zts_match(struct device *, void *, void *);
void	zts_attach(struct device *, struct device *, void *);
int	zts_activate(struct device *, int);
int	zts_enable(void *);
void	zts_disable(void *);
void	zts_poll(void *);
int	zts_irq(void *);
int	zts_ioctl(void *, u_long, caddr_t, int, struct proc *);

struct zts_softc {
	struct device sc_dev;
	struct timeout sc_ts_poll;
	void *sc_gh;
	int sc_enabled;
	int sc_running;
	int sc_buttons; /* button emulation ? */
	struct device *sc_wsmousedev;
	int sc_oldx;
	int sc_oldy;
	int sc_rawmode;
	
	struct tsscale sc_tsscale;
};

struct cfattach zts_ca = {
	sizeof(struct zts_softc), zts_match, zts_attach, NULL,
	zts_activate
};

struct cfdriver zts_cd = {
	NULL, "zts", DV_DULL
};

int
zts_match(struct device *parent, void *cf, void *aux)
{
	return 1;
}

const struct wsmouse_accessops zts_accessops = {
        zts_enable,
	zts_ioctl,
	zts_disable
};

void
zts_attach(struct device *parent, struct device *self, void *aux)
{
	struct zts_softc *sc = (struct zts_softc *)self;
	struct wsmousedev_attach_args a;  

	timeout_set(&sc->sc_ts_poll, zts_poll, sc);

	/* Initialize ADS7846 Difference Reference mode */
	(void)zssp_ic_send(ZSSP_IC_ADS7846,
	    (1<<ADSCTRL_ADR_SH) | (1<<ADSCTRL_STS_SH));
	delay(5000);
	(void)zssp_ic_send(ZSSP_IC_ADS7846,
	    (3<<ADSCTRL_ADR_SH) | (1<<ADSCTRL_STS_SH));
	delay(5000);
	(void)zssp_ic_send(ZSSP_IC_ADS7846,
	    (4<<ADSCTRL_ADR_SH) | (1<<ADSCTRL_STS_SH));
	delay(5000);
	(void)zssp_ic_send(ZSSP_IC_ADS7846,
	    (5<<ADSCTRL_ADR_SH) | (1<<ADSCTRL_STS_SH));
	delay(5000);

	a.accessops = &zts_accessops;
	a.accesscookie = sc;
	printf("\n");

	/* Copy the default scalue values to each softc */
	bcopy(&zts_scale, &sc->sc_tsscale, sizeof(sc->sc_tsscale));
		
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
}

int
zts_enable(void *v)
{
	struct zts_softc *sc = v;

	if (sc->sc_enabled)
		return EBUSY;

	timeout_del(&sc->sc_ts_poll);

	pxa2x0_gpio_set_function(GPIO_TP_INT_C3K, GPIO_IN);

	/* XXX */
	if (sc->sc_gh == NULL)
		sc->sc_gh = pxa2x0_gpio_intr_establish(GPIO_TP_INT_C3K,
		    IST_EDGE_FALLING, IPL_TTY, zts_irq, sc,
		    sc->sc_dev.dv_xname);
	else
		pxa2x0_gpio_intr_unmask(sc->sc_gh);

	/* enable interrupts */
	sc->sc_enabled = 1;
	sc->sc_running = 1;
	sc->sc_buttons = 0;

	return 0;
}

void
zts_disable(void *v)
{
	struct zts_softc *sc = v;

	timeout_del(&sc->sc_ts_poll);

	if (sc->sc_gh != NULL) {
#if 0
		pxa2x0_gpio_intr_disestablish(sc->sc_gh);
		sc->sc_gh = NULL;
#endif
	}

	/* disable interrupts */
	sc->sc_enabled = 0;
	sc->sc_running = 0;
}

int
zts_activate(struct device *self, int act)
{
	struct zts_softc *sc = (struct zts_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		if (sc->sc_enabled == 0)
			break;
		sc->sc_running = 0;
#if 0
		pxa2x0_gpio_intr_disestablish(sc->sc_gh);
#endif
		timeout_del(&sc->sc_ts_poll);

		pxa2x0_gpio_intr_mask(sc->sc_gh);

		/* Turn off reference voltage but leave ADC on. */
		(void)zssp_ic_send(ZSSP_IC_ADS7846, (1 << ADSCTRL_PD1_SH) |
		    (1 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH));

		pxa2x0_gpio_set_function(GPIO_TP_INT_C3K,
		    GPIO_OUT | GPIO_SET);
		break;

	case DVACT_RESUME:
		if (sc->sc_enabled == 0)
			break;
		pxa2x0_gpio_set_function(GPIO_TP_INT_C3K, GPIO_IN);
		pxa2x0_gpio_intr_mask(sc->sc_gh);

		/* Enable automatic low power mode. */
		(void)zssp_ic_send(ZSSP_IC_ADS7846,
		    (4 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH));

#if 0
		sc->sc_gh = pxa2x0_gpio_intr_establish(GPIO_TP_INT_C3K,
		    IST_EDGE_FALLING, IPL_TTY, zts_irq, sc,
		    sc->sc_dev.dv_xname);
#else
		pxa2x0_gpio_intr_unmask(sc->sc_gh);
#endif
		sc->sc_running = 1;
		break;
	}
	return 0;
}

struct zts_pos {
	int x;
	int y;
	int z;			/* touch pressure */
};

#define NSAMPLES 3
struct zts_pos zts_samples[NSAMPLES];
int	ztsavgloaded = 0;

int	zts_readpos(struct zts_pos *);
void	zts_avgpos(struct zts_pos *);

#define HSYNC()							\
	do {								\
		while (pxa2x0_gpio_get_bit(GPIO_HSYNC_C3K) == 0);	\
		while (pxa2x0_gpio_get_bit(GPIO_HSYNC_C3K) != 0);	\
	} while (0)

int	  pxa2x0_ccnt_enable(int);
u_int32_t pxa2x0_read_ccnt(void);
u_int32_t zts_sync_ads784x(int, int, u_int32_t);
void	  zts_sync_send(u_int32_t);

int
pxa2x0_ccnt_enable(int on)
{
	u_int32_t rv;

	on = on ? 0x1 : 0x0;
	__asm volatile("mrc p14, 0, %0, c0, c1, 0" : "=r" (rv));
	__asm volatile("mcr p14, 0, %0, c0, c1, 0" : : "r" (on));
	return ((int)(rv & 0x1));
}

u_int32_t
pxa2x0_read_ccnt(void)
{
	u_int32_t rv;

	__asm volatile("mrc p14, 0, %0, c1, c1, 0" : "=r" (rv));
	return (rv);
}

/*
 * Communicate synchronously with the ADS784x touch screen controller.
 */
u_int32_t
zts_sync_ads784x(int dorecv/* XXX */, int dosend/* XXX */, u_int32_t cmd)
{
	int	ccen;
	u_int32_t rv;

	/* XXX poll hsync only if LCD is enabled */

	/* start clock counter */
	ccen = pxa2x0_ccnt_enable(1);

	HSYNC();

	if (dorecv)
		/* read SSDR and disable ADS784x */
		rv = zssp_ic_stop(ZSSP_IC_ADS7846);
	else
		rv = 0;

	if (dosend)
		zts_sync_send(cmd);

	/* stop clock counter */
	pxa2x0_ccnt_enable(ccen);

	return (rv);
}

void
zts_sync_send(u_int32_t cmd)
{
	u_int32_t tck;
	u_int32_t a, b;

	/* XXX */
	tck = CCNT_HS_400_VGA_C3K - 151;

	/* send dummy command; discard SSDR */
	(void)zssp_ic_send(ZSSP_IC_ADS7846, cmd);
	
	/* wait for refresh */
	HSYNC();

	/* wait after refresh */
	a = pxa2x0_read_ccnt();
	b = pxa2x0_read_ccnt();
	while ((b - a) < tck)
		b = pxa2x0_read_ccnt();

	/* send the actual command; keep ADS784x enabled */
	zssp_ic_start(ZSSP_IC_ADS7846, cmd);
}

int
zts_readpos(struct zts_pos *pos)
{
	int cmd;
	int t0, t1;
	int down;

	/* XXX */
	pxa2x0_gpio_set_function(GPIO_HSYNC_C3K, GPIO_IN);

	/* check that pen is down */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (3 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);

	t0 = zssp_ic_send(ZSSP_IC_ADS7846, cmd);
	down = !(t0 < 10);
	if (down == 0)
		goto out;

	/* Y */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (1 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);

	(void)zts_sync_ads784x(0, 1, cmd);

	/* Y */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (1 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);

	(void)zts_sync_ads784x(1, 1, cmd);

	/* X */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (5 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);

	pos->y = zts_sync_ads784x(1, 1, cmd);

	/* T0 */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (3 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);

	pos->x = zts_sync_ads784x(1, 1, cmd);

	/* T1 */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (4 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);

	t0 = zts_sync_ads784x(1, 1, cmd);
	t1 = zts_sync_ads784x(1, 0, cmd);

	/* check that pen is still down */
	/* XXX pressure sensitivity varies with X or what? */
	if (t0 == 0 || (pos->x * (t1 - t0) / t0) >= 15000)
		down = 0;
	pos->z = down;

out:
	/* Enable automatic low power mode. */
        cmd = (4 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);
	(void)zssp_ic_send(ZSSP_IC_ADS7846, cmd);
	
	return (down);
}

#define NAVGSAMPLES (NSAMPLES < 3 ? NSAMPLES : 3)
void
zts_avgpos(struct zts_pos *pos)
{
	struct zts_pos *tpp = zts_samples;
	int diff[NAVGSAMPLES];
	int mindiff, mindiffv;
	int n;
	int i;
	static int tail;

	if (ztsavgloaded < NAVGSAMPLES) {
		tpp[(tail + ztsavgloaded) % NSAMPLES] = *pos;
		ztsavgloaded++;
		return;
	}

	tpp[tail] = *pos;
	tail = (tail+1) % NSAMPLES;

	/* X */
	i = tail;
	for (n = 0 ; n < NAVGSAMPLES; n++) {
		int alt;
		alt = (i+1) % NSAMPLES;
		diff[n] = tpp[i].x - tpp[alt].x;
		if (diff[n] < 0)
			diff[n] = - diff[n]; /* ABS */
		i = alt;
	}
	mindiffv = diff[0];
	mindiff = 0;
	for (n = 1; n < NAVGSAMPLES; n++) {
		if (diff[n] < mindiffv) {
			mindiffv = diff[n];
			mindiff = n;
		}
	}
	pos->x = (tpp[(tail + mindiff) % NSAMPLES].x +
	    tpp[(tail + mindiff + 1) % NSAMPLES].x) / 2;

	/* Y */
	i = tail;
	for (n = 0 ; n < NAVGSAMPLES; n++) {
		int alt;
		alt = (i+1) % NSAMPLES;
		diff[n] = tpp[i].y - tpp[alt].y;
		if (diff[n] < 0)
			diff[n] = - diff[n]; /* ABS */
		i = alt;
	}
	mindiffv = diff[0];
	mindiff = 0;
	for (n = 1; n < NAVGSAMPLES; n++) {
		if (diff[n] < mindiffv) {
			mindiffv = diff[n];
			mindiff = n;
		}
	}
	pos->y = (tpp[(tail + mindiff) % NSAMPLES].y +
	    tpp[(tail + mindiff + 1) % NSAMPLES].y) / 2;
}

void
zts_poll(void *v)
{
	int s;

	s = spltty();
	(void)zts_irq(v);
	splx(s);
}

#define TS_STABLE 8
int
zts_irq(void *v)
{
	struct zts_softc *sc = v;
	struct zts_pos tp;
	int s;
	int pindown;
	int down;
	extern int zkbd_modstate;

	if (!sc->sc_running)
		return 0;

	s = splhigh();
	pindown = pxa2x0_gpio_get_bit(GPIO_TP_INT_C3K) ? 0 : 1;
	if (pindown) {
		pxa2x0_gpio_intr_mask(sc->sc_gh);
		timeout_add(&sc->sc_ts_poll, POLL_TIMEOUT_RATE1);
	}

	down = zts_readpos(&tp);

	if (!pindown) {
		pxa2x0_gpio_intr_unmask(sc->sc_gh);
		timeout_add(&sc->sc_ts_poll, POLL_TIMEOUT_RATE0);
		ztsavgloaded = 0;
	}
	pxa2x0_gpio_clear_intr(GPIO_TP_INT_C3K);
	splx(s);
	
	if (down) {
		zts_avgpos(&tp);
		if (!sc->sc_rawmode &&
		    (sc->sc_tsscale.maxx - sc->sc_tsscale.minx) != 0 &&
		    (sc->sc_tsscale.maxy - sc->sc_tsscale.miny) != 0) {
			/* Scale down to the screen resolution. */
			tp.x = ((tp.x - sc->sc_tsscale.minx) *
			    sc->sc_tsscale.resx) /
			    (sc->sc_tsscale.maxx - sc->sc_tsscale.minx);
			tp.y = ((tp.y - sc->sc_tsscale.miny) *
			    sc->sc_tsscale.resy) /
			    (sc->sc_tsscale.maxy - sc->sc_tsscale.miny);
		}
	}

	if (zkbd_modstate != 0 && down) {
		if(zkbd_modstate & (1 << 1)) {
			/* Fn */
			down = 2;
		}
		if(zkbd_modstate & (1 << 2)) {
			/* 'Alt' */
			down = 4;
		}
	}
	if (!down) {
		/* x/y values are not reliable when pen is up */
		tp.x = sc->sc_oldx;
		tp.y = sc->sc_oldy;
	}

	if (down || sc->sc_buttons != down) {
		DPRINTF(("%s: tp.z = %d, tp.x = %d, tp.y = %d\n",
		    sc->sc_dev.dv_xname, tp.z, tp.x, tp.y));

		wsmouse_buttons(sc->sc_wsmousedev, down);
		wsmouse_position(sc->sc_wsmousedev, tp.x, tp.y);
		wsmouse_input_sync(sc->sc_wsmousedev);
		sc->sc_buttons = down;
		sc->sc_oldx = tp.x;
		sc->sc_oldy = tp.y;
	}

	return 1;
}

int
zts_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int error = 0;
	struct zts_softc *sc = v;
	struct wsmouse_calibcoords *wsmc = (struct wsmouse_calibcoords *)data;

	DPRINTF(("zts_ioctl(%d, '%c', %d)\n",
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd & 0xff));

	switch (cmd) {
	case WSMOUSEIO_SCALIBCOORDS:
		if (!(wsmc->minx >= 0 && wsmc->maxx >= 0 &&
		    wsmc->miny >= 0 && wsmc->maxy >= 0 &&
		    wsmc->resx >= 0 && wsmc->resy >= 0 &&
		    wsmc->minx < 32768 && wsmc->maxx < 32768 &&
		    wsmc->miny < 32768 && wsmc->maxy < 32768 &&
		    (wsmc->maxx - wsmc->minx) != 0 &&
		    (wsmc->maxy - wsmc->miny) != 0 &&
		    wsmc->resx < 32768 && wsmc->resy < 32768 &&
		    wsmc->swapxy >= 0 && wsmc->swapxy <= 1 &&
		    wsmc->samplelen >= 0 && wsmc->samplelen <= 1))
			return (EINVAL);

		sc->sc_tsscale.minx = wsmc->minx;
		sc->sc_tsscale.maxx = wsmc->maxx;
		sc->sc_tsscale.miny = wsmc->miny;
		sc->sc_tsscale.maxy = wsmc->maxy;
		sc->sc_tsscale.swapxy = wsmc->swapxy;
		sc->sc_tsscale.resx = wsmc->resx;
		sc->sc_tsscale.resy = wsmc->resy;
		sc->sc_rawmode = wsmc->samplelen;
		break;
	case WSMOUSEIO_GCALIBCOORDS:
		wsmc->minx = sc->sc_tsscale.minx;
		wsmc->maxx = sc->sc_tsscale.maxx;
		wsmc->miny = sc->sc_tsscale.miny;
		wsmc->maxy = sc->sc_tsscale.maxy;
		wsmc->swapxy = sc->sc_tsscale.swapxy;
		wsmc->resx = sc->sc_tsscale.resx;
		wsmc->resy = sc->sc_tsscale.resy;
		wsmc->samplelen = sc->sc_rawmode;
		break;
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_TPANEL;
		break;
	default:
		error = ENOTTY;
		break;
	}

	return (error);
}
@


1.16
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.15 2011/03/03 21:48:49 kettenis Exp $ */
d547 3
a549 4
		wsmouse_input(sc->sc_wsmousedev, down, tp.x, tp.y,
		    0 /* z */, 0 /* w */,
		    WSMOUSE_INPUT_ABSOLUTE_X | WSMOUSE_INPUT_ABSOLUTE_Y |
		    WSMOUSE_INPUT_ABSOLUTE_Z);
@


1.15
log
@Prevent division-by-zero when scaling down to the screen resolution.  Make
the WSMOUSEIO_SCALIBCOORDS fail with EINVAL if the settings would cause a
division-by-zero.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.14 2010/09/07 16:21:41 deraadt Exp $ */
d274 2
a275 2
	__asm __volatile("mrc p14, 0, %0, c0, c1, 0" : "=r" (rv));
	__asm __volatile("mcr p14, 0, %0, c0, c1, 0" : : "r" (on));
d284 1
a284 1
	__asm __volatile("mrc p14, 0, %0, c1, c1, 0" : "=r" (rv));
@


1.14
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.13 2010/08/30 21:35:57 deraadt Exp $ */
d514 3
a516 1
		if (!sc->sc_rawmode) {
d576 2
@


1.13
log
@Convert all powerhooks to activate functions, and provide powerhook stubs.
Of note:  lcd stubs get pulled up to the parent; zts has to keep track of
whether it is in use or not
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.12 2010/08/27 05:04:11 deraadt Exp $ */
a76 1
void	zts_powerhook(int, void *);
a84 1
	void *sc_powerhook;
a158 6
	sc->sc_powerhook = powerhook_establish(zts_powerhook, sc);
	if (sc->sc_powerhook == NULL) {
		printf("%s: enable failed\n", sc->sc_dev.dv_xname);
		return ENOMEM;
	}

a183 5
	if (sc->sc_powerhook != NULL) {
		powerhook_disestablish(sc->sc_powerhook);
		sc->sc_powerhook = NULL;
	}

a241 6
}

void
zts_powerhook(int why, void *v)
{
	zts_activate(v, why);
@


1.12
log
@More killing of PWR_STANDBY.  cvs skipped these files
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.11 2007/05/29 21:09:43 robert Exp $ */
d74 1
d77 1
a77 1
void	zts_power(int, void *);
d88 1
d99 2
a100 1
	sizeof(struct zts_softc), zts_match, zts_attach
d161 1
a161 1
	sc->sc_powerhook = powerhook_establish(zts_power, sc);
d179 1
d206 1
d209 2
a210 2
void
zts_power(int why, void *v)
d212 1
a212 1
	struct zts_softc *sc = v;
d214 5
a218 3
	switch (why) {
	case PWR_SUSPEND:
		sc->sc_enabled = 0;
d234 3
a236 1
	case PWR_RESUME:
d251 1
a251 1
		sc->sc_enabled = 1;
d254 7
d511 1
a511 1
	if (!sc->sc_enabled)
@


1.11
log
@Make use of struct wsmouse_calibcoords and add ioctl support
for getting and passing calibration values instead of using
sysctl.
Move the scale struct to uts_softc so that each device can have
it's own values instead of using the global one.
Remove the two MD sysctl (ztsscale and ztsrawmode).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.10 2007/04/10 22:37:17 miod Exp $ */
a209 1
	case PWR_STANDBY:
@


1.10
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.9 2005/04/24 18:55:49 uwe Exp $ */
d38 6
d62 5
a66 11
/* XXX need to ask zaurus_lcd.c for the screen dimension */
#define CURRENT_DISPLAY (&sharp_zaurus_C3000)
extern const struct lcd_panel_geometry sharp_zaurus_C3000;

/* Settable via sysctl. */
int	zts_rawmode;
struct ztsscale {
	int ts_minx;
	int ts_maxx;
	int ts_miny;
	int ts_maxy;
d69 1
a69 1
	209, 3620, 312, 3780
d91 3
a93 2
	int sc_resx;
	int sc_resy;
d141 3
a144 3
	sc->sc_resx = CURRENT_DISPLAY->panel_height;
	sc->sc_resy = CURRENT_DISPLAY->panel_width;

d518 1
a518 3
		if (!zts_rawmode) {
			struct ztsscale *tsp = &zts_scale;

d520 6
a525 4
			tp.x = ((tp.x - tsp->ts_minx) * sc->sc_resx) /
			    (tsp->ts_maxx - tsp->ts_minx);
			tp.y = ((tp.y - tsp->ts_miny) * sc->sc_resy) /
			    (tsp->ts_maxy - tsp->ts_miny);
d546 3
d564 6
d572 30
d604 4
a607 1
		return (0);
d610 1
a610 1
	return (-1);
@


1.9
log
@Do down-sampling of the high-resolution touch pad events in kernel,
and provide sysctls for fine-tuning the touch pad area that covers the
screen.  Reasonable defaults are provided, but each machine can be a
bit different due to the manufacturing process.
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.8 2005/04/19 21:54:48 djm Exp $ */
d545 2
a546 1
		wsmouse_input(sc->sc_wsmousedev, down, tp.x, tp.y, 0 /* z */,
@


1.8
log
@newline after attach; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.7 2005/04/08 22:12:14 uwe Exp $ */
d34 4
d56 16
d91 2
d141 3
d515 1
a515 1
	if (down)
d517 10
@


1.7
log
@Synchronize ADS7846 communication and LCD refresh so as to avoid jitter
in the touch screen data, and enable the existing IRQ handling code
(even though polling is still mandatory).
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.6 2005/03/15 00:35:11 drahn Exp $ */
d117 1
@


1.6
log
@Try harder to prevent spurious touch screen 'down' events.
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.5 2005/02/16 22:25:18 drahn Exp $ */
d29 2
d34 26
a59 10
u_int32_t pxa2x0_ssp_read_val(u_int32_t);

int zts_match(struct device *, void *, void *);
void zts_attach(struct device *, struct device *, void *);
int zts_irq(void *v);
void zts_poll(void *v);

int      zts_enable(void *);
void     zts_disable(void *);
int      zts_ioctl(void *, u_long, caddr_t, int, struct proc *);
a62 1

d64 2
a65 1

a72 8
#define ADSCTRL_PD0_SH          0       // PD0 bit
#define ADSCTRL_PD1_SH          1       // PD1 bit
#define ADSCTRL_DFR_SH          2       // SER/DFR bit
#define ADSCTRL_MOD_SH          3       // Mode bit
#define ADSCTRL_ADR_SH          4       // Address setting
#define ADSCTRL_STS_SH          7       // Start bit


a86 6
#define IRQ_GPIO_TP_INT_C3K 11
#define POLL_TIMEOUT_RATE ((hz * 150)/1000)
/*
#define POLL_TIMEOUT_RATE ((hz * 500)/1000)
*/

a92 1

d99 29
d129 1
a129 1
	timeout_set(&(sc->sc_ts_poll), zts_poll, sc);
d131 18
a148 1
	sc->sc_enabled = 0;
d151 7
a157 2
/*
	pxa2x0_gpio_set_function(IRQ_GPIO_TP_INT_C3K, GPIO_IN);
d159 1
a159 3
	pxa2x0_gpio_intr_establish(IRQ_GPIO_TP_INT_C3K, IST_EDGE_RISING,
	    IPL_TTY, zts_irq, sc, sc->sc_dev.dv_xname);
*/
d161 4
a164 1
	printf ("\n");
d166 6
a171 4
	a.accessops = &zts_accessops;
	a.accesscookie = sc;
		
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
d173 2
d178 1
a178 1
zts_poll(void *v) 
d182 18
a199 1
	timeout_add(&sc->sc_ts_poll, POLL_TIMEOUT_RATE);
d201 18
a218 1
	zts_irq(v);
d221 6
a226 1
#define TS_STABLE 8
d228 93
d322 1
a322 1
zts_irq(void *v)
d324 6
a329 7
	struct zts_softc *sc = v;
	u_int32_t cmd;
	u_int32_t t0, tn[NSAMPLES], xv, x[NSAMPLES], yv, y[NSAMPLES];
	int i, diff[NSAMPLES];
	int down = 1;
	int mindiff, mindiffv;
	extern int zkbd_modstate;
d335 8
a342 2
	t0 = pxa2x0_ssp_read_val(cmd);
	down &= !(t0 < 10);
d344 1
a344 1
	for (i = 0; i < NSAMPLES; i++) {
d346 15
a360 3
		/* X */
		cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
		    (5 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);
d362 1
a362 1
		x[i] = pxa2x0_ssp_read_val(cmd);
d364 3
a366 3
		/* Y */
		cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
		    (1 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);
d368 2
a369 1
		y[i] = pxa2x0_ssp_read_val(cmd);
d371 13
a383 3
		/* check that pen is still down */
		cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
		    (3 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);
d385 15
a399 2
		tn[i] = pxa2x0_ssp_read_val(cmd);
		down &= !(tn[i] < 10);
d402 3
d406 2
a407 1
	for (i = 0 ; i < NSAMPLES; i++) {
d409 5
a413 7
		alt = i+1;
		if (alt == NSAMPLES)
			alt = 0;

		diff[i] = x[i]-x[alt];
		if (diff[i] < 0)
			diff[i] = -diff[i]; /* ABS */
d417 5
a421 17
	if (diff[1] < mindiffv) {
		mindiffv = diff[1];
		mindiff = 1;
	}
	if (diff[2] < mindiffv) {
		mindiff = 2;
	}
	switch (mindiff) {
	case 0:
		xv = (x[0] + x[1]) / 2;
		break;
	case 1:
		xv = (x[1] + x[2]) / 2;
		break;
	case 2:
		xv = (x[2] + x[0]) / 2;
		break;
d423 2
d427 2
a428 1
	for (i = 0 ; i < NSAMPLES; i++) {
d430 5
a434 7
		alt = i+1;
		if (alt == NSAMPLES)
			alt = 0;

		diff[i] = y[i]-y[alt];
		if (diff[i] < 0)
			diff[i] = -diff[i]; /* ABS */
d438 47
a484 17
	if (diff[1] < mindiffv) {
		mindiffv = diff[1];
		mindiff = 1;
	}
	if (diff[2] < mindiffv) {
		mindiff = 2;
	}
	switch (mindiff) {
	case 0:
		yv = (y[0] + y[1]) / 2;
		break;
	case 1:
		yv = (y[1] + y[2]) / 2;
		break;
	case 2:
		yv = (y[2] + y[0]) / 2;
		break;
d486 2
d489 3
d504 2
a505 2
		xv = sc->sc_oldx;
		yv = sc->sc_oldy;
d507 1
d509 1
a509 1
		wsmouse_input(sc->sc_wsmousedev, down, xv, yv, 0 /* z */,
d513 2
a514 2
		sc->sc_oldx = xv;
		sc->sc_oldy = yv;
a516 4
	/*
	pxa2x0_gpio_clear_intr(IRQ_GPIO_TP_INT_C3K);
	*/

a517 28
}

int
zts_enable(void *v)
{
	struct zts_softc *sc = v;

	if (sc->sc_enabled)
		return EBUSY;

	sc->sc_enabled = 1;
	sc->sc_buttons = 0;

	/* enable interrupt, or polling */
	timeout_add(&sc->sc_ts_poll, POLL_TIMEOUT_RATE);

	return 0;
}

void
zts_disable(void *v)
{
	struct zts_softc *sc = v;

	timeout_del(&sc->sc_ts_poll);

	/* disable interrupts/polling */
	sc->sc_enabled = 0;
@


1.5
log
@Touchscreen sample stabilization, do multiple reads, average best two.
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.4 2005/02/16 20:09:18 matthieu Exp $ */
d135 1
a135 1
	u_int32_t t0, t1, xv, x[NSAMPLES], yv, y[NSAMPLES];
d137 1
a137 1
	int down;
d141 7
a148 5
		/* check that pen is down */
		cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
		    (3 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);

		t0 = pxa2x0_ssp_read_val(cmd);
d166 2
a167 1
		t1 = pxa2x0_ssp_read_val(cmd);
a233 1
	down = (t0 > 10 && t1 > 10);
@


1.4
log
@Filter spurious coordinates on pen up in abolute mode,
2nd and 3rd button emulation in absolute mode,
make it the default.
ok drahn@@.
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.3 2005/01/30 21:55:50 drahn Exp $ */
a42 2
#undef DO_RELATIVE

d128 2
a132 1

d135 2
a136 3
	u_int32_t t0, t1;
	u_int32_t x;
	u_int32_t y;
d138 1
d141 4
a144 3
	/* check that pen is down */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (3 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);
d146 1
a146 1
	t0 = pxa2x0_ssp_read_val(cmd);
d148 3
d152 1
a152 3
	/* X */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (5 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);
d154 3
a156 2
		/* XXX - read multiple times so it is stable? */
	x = pxa2x0_ssp_read_val(cmd);
d158 1
d160 3
a162 3
	/* Y */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (1 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);
d164 2
a165 2
		/* XXX - read multiple times so it is stable? */
	y = pxa2x0_ssp_read_val(cmd);
d167 31
d199 31
a229 5
	/* check that pen is still down */
	cmd = (1 << ADSCTRL_PD0_SH) | (1 << ADSCTRL_PD1_SH) |
	    (3 << ADSCTRL_ADR_SH) | (1 << ADSCTRL_STS_SH);

	t1 = pxa2x0_ssp_read_val(cmd);
a230 67
	down = pxa2x0_gpio_get_bit(IRQ_GPIO_TP_INT_C3K);

	if (t0 != 0 && t1 != 0) {
		/*
		printf("zts: t0 %x t1 %x, x %x y %x int %d\n", t0, t1, x, y,
		    down);
		*/
	}

#ifdef DO_RELATIVE
	/*
	 * relative mode here is really just a hack until abs mode
	 * really works in X.
	 */
	if (t0 > 10 && t1 > 10) {
		int dx, dy;
		int skip = 0;

		if ( sc->sc_oldx == -1) {
			if (zkbd_modstate != 0) {
				/*
				 * use motifiers with touchpress to indicate
				 * buttons.
				 */

				if(zkbd_modstate & (1 << 0)) {
					/* shift */
					sc->sc_buttons |= (1 << 0);
				}
				if(zkbd_modstate & (1 << 1)) {
					/* Fn */
					sc->sc_buttons |= (1 << 1);
				}
				if(zkbd_modstate & (1 << 2)) {
					/* 'Alt' */
					sc->sc_buttons |= (1 << 2);
				}
				
			}
			skip = 1;
		}

		dx = x - sc->sc_oldx; /* temp */
		dy = y - sc->sc_oldy;

		/* scale down */
		dx /= 10;
		dy /= 10;

		/* y is inverted */
		dy = - dy;

		sc->sc_oldx = x;
		sc->sc_oldy = y;
		if (!skip)
			wsmouse_input(sc->sc_wsmousedev,  sc->sc_buttons,
			    dx, dy, 0 /* XXX*/, WSMOUSE_INPUT_DELTA);
	} else {
		
		sc->sc_buttons = 0;
		wsmouse_input(sc->sc_wsmousedev, sc->sc_buttons,
		    0, 0, 0 /* XXX*/, WSMOUSE_INPUT_DELTA);

		sc->sc_oldx = -1;
		sc->sc_oldy = -1;
	}
#else
d244 2
a245 2
		x = sc->sc_oldx;
		y = sc->sc_oldy;
d248 1
a248 1
		wsmouse_input(sc->sc_wsmousedev, down, x, y, 0 /* z */,
d252 2
a253 2
		sc->sc_oldx = x;
		sc->sc_oldy = y;
a254 2
#endif

@


1.3
log
@Hack to allow emulation of mouse buttons for now, incorrectly shares
global between zkbd and zts, until a better solution is found.
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.2 2005/01/28 23:26:54 drahn Exp $ */
d43 1
a43 1
#define DO_RELATIVE
a52 1
#ifdef DO_RELATIVE
a54 1
#endif
d140 1
a189 1
			extern int zkbd_modstate;
d238 18
a255 4
	
	if (t0 != 0 && t1 != 0)
		wsmouse_input(sc->sc_wsmousedev, 0/* XXX buttons */, x, y,
		    0 /* XXX*/,
d257 5
a261 1
		    WSMOUSE_INPUT_ABSOLUTE_Z );
a311 1

@


1.2
log
@debug print should not be enabled.
@
text
@d1 1
a1 1
/* $OpenBSD: zts.c,v 1.1 2005/01/28 17:14:31 drahn Exp $ */
d102 3
a104 1
	timeout_add(&sc->sc_ts_poll, POLL_TIMEOUT_RATE);
d186 1
a186 1
	if (t0 != 0 && t1 != 0) {
d191 21
d228 1
a228 1
			wsmouse_input(sc->sc_wsmousedev, 0/* XXX buttons */,
d231 5
@


1.1
log
@Add zts, touch screen driver for zaurus.
Currently in it's early stage,  instead of an absolute pointing device,
it currently does relative, and only in polled mode.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.10 2005/01/18 17:57:13 drahn Exp $ */
d173 1
d176 1
@

