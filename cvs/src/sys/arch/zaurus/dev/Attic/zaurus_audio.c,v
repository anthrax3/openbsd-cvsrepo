head	1.20;
access;
symbols
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.10
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.8
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8;
locks; strict;
comment	@ * @;


1.20
date	2016.09.03.13.37.43;	author guenther;	state dead;
branches;
next	1.19;
commitid	6T3r4QcMFKe3Fo5T;

1.19
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.18;
commitid	RaOGL5SyOGOZylwx;

1.18
date	2014.09.19.16.45.55;	author jsg;	state Exp;
branches;
next	1.17;
commitid	i1wCkqIG8KPNxG9D;

1.17
date	2013.08.30.14.18.38;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2012.03.01.08.17.26;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.07.16.21.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.30.21.35.57;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.27.05.04.11;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.18.13.23.02;	author robert;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.26.03.52.07;	author pascoe;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.26.03.28.43;	author pascoe;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.23.22.53.22;	author pascoe;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.23.22.44.57;	author pascoe;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.21.13.43.48;	author pascoe;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.15.01.17.26;	author pascoe;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.15.01.05.51;	author pascoe;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Retire zaurus, as it hasn't made the EABI jump and will be permanently broken
shortly when we use the hardware thread register in userland
@
text
@/*	$OpenBSD: zaurus_audio.c,v 1.19 2015/05/11 06:46:21 ratchov Exp $	*/

/*
 * Copyright (c) 2005 Christopher Pascoe <pascoe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * TODO:
 *	- record support
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/fcntl.h>
#include <sys/audioio.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0_i2c.h>
#include <arm/xscale/pxa2x0_i2s.h>
#include <arm/xscale/pxa2x0_dmac.h>
#include <arm/xscale/pxa2x0_gpio.h>

#include <zaurus/dev/zaurus_scoopvar.h>
#include <dev/i2c/wm8750reg.h>
#include <dev/audio_if.h>

#define WM8750_ADDRESS  0x1B
#define SPKR_VOLUME	112

#define wm8750_write(sc, reg, val)	pxa2x0_i2c_write_2(&sc->sc_i2c, \
    WM8750_ADDRESS, (((reg) << 9) | ((val) & 0x1ff)))

int	zaudio_match(struct device *, void *, void *);
void	zaudio_attach(struct device *, struct device *, void *);
int	zaudio_detach(struct device *, int);
int	zaudio_activate(struct device *, int);
void    zaudio_pintr(void *);
void    zaudio_rintr(void *);

#define ZAUDIO_OP_SPKR	0
#define ZAUDIO_OP_HP	1

#define ZAUDIO_JACK_STATE_OUT	0
#define ZAUDIO_JACK_STATE_IN	1
#define ZAUDIO_JACK_STATE_INS	2
#define ZAUDIO_JACK_STATE_REM	3

/* GPIO pins */
#define GPIO_HP_IN_C3000	116

struct zaudio_volume {
	u_int8_t		left;
	u_int8_t		right;
};

struct zaudio_softc {
	struct device		sc_dev;

	/* i2s device softc */
	/* NB: pxa2x0_i2s requires this to be the second struct member */
	struct pxa2x0_i2s_softc	sc_i2s;

	/* i2c device softc */
	struct pxa2x0_i2c_softc	sc_i2c;

	int			sc_playing;

	struct zaudio_volume	sc_volume[2];
	char			sc_unmute[2];

	int			sc_state;
	int			sc_icount;
	struct timeout		sc_to; 
	void		      (*sc_pintr)(void *);
	void		       *sc_parg;
};

struct cfattach zaudio_ca = {
	sizeof(struct zaudio_softc), zaudio_match, zaudio_attach,
	zaudio_detach, zaudio_activate
};

struct cfdriver zaudio_cd = {
	NULL, "zaudio", DV_DULL
};

struct audio_device wm8750_device = {
	"WM8750",
	"1.0",
	"wm"
};

void zaudio_init(struct zaudio_softc *);
int zaudio_jack_intr(void *);
void zaudio_jack(void *);
void zaudio_standby(struct zaudio_softc *);
void zaudio_update_volume(struct zaudio_softc *, int);
void zaudio_update_mutes(struct zaudio_softc *);
void zaudio_play_setup(struct zaudio_softc *);
int zaudio_open(void *, int);
void zaudio_close(void *);
int zaudio_query_encoding(void *, struct audio_encoding *);
int zaudio_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int zaudio_halt_output(void *);
int zaudio_halt_input(void *);
int zaudio_getdev(void *, struct audio_device *);
int zaudio_set_port(void *, struct mixer_ctrl *);
int zaudio_get_port(void *, struct mixer_ctrl *);
int zaudio_query_devinfo(void *, struct mixer_devinfo *);
int zaudio_get_props(void *);
int zaudio_start_output(void *, void *, int, void (*)(void *), void *);
int zaudio_start_input(void *, void *, int, void (*)(void *), void *);

struct audio_hw_if wm8750_hw_if = {
	zaudio_open,
	zaudio_close,
	NULL /* zaudio_drain */,
	zaudio_query_encoding,
	zaudio_set_params,
	pxa2x0_i2s_round_blocksize,
	NULL /* zaudio_commit_settings */,
	NULL /* zaudio_init_output */,
	NULL /* zaudio_init_input */,
	zaudio_start_output,
	zaudio_start_input,
	zaudio_halt_output,
	zaudio_halt_input,
	NULL /* zaudio_speaker_ctl */,
	zaudio_getdev,
	NULL /* zaudio_setfd */,
	zaudio_set_port,
	zaudio_get_port,
	zaudio_query_devinfo,
	pxa2x0_i2s_allocm,
	pxa2x0_i2s_freem,
	pxa2x0_i2s_round_buffersize,
	pxa2x0_i2s_mappage,
	zaudio_get_props,
	NULL /* zaudio_trigger_output */,
	NULL /* zaudio_trigger_input */,
	NULL
};

static const unsigned short playback_registers[][2] = {
	/* Unmute DAC */
	{ ADCDACCTL_REG, 0x000 },

	/* 16 bit audio words */
	{ AUDINT_REG, AUDINT_SET_FORMAT(2) },

	/* Enable thermal protection, power */
	{ ADCTL1_REG, ADCTL1_TSDEN | ADCTL1_SET_VSEL(3) },

	/* Enable speaker driver, DAC oversampling */
	{ ADCTL2_REG, ADCTL2_ROUT2INV | ADCTL2_DACOSR },

	/* Set DAC voltage references */
	{ PWRMGMT1_REG, PWRMGMT1_SET_VMIDSEL(1) | PWRMGMT1_VREF },

	/* Direct DACs to output mixers */
	{ LOUTMIX1_REG, LOUTMIX1_LD2LO },
	{ ROUTMIX2_REG, ROUTMIX2_RD2RO },

	/* End of list */
	{ 0xffff, 0xffff }
};

int
zaudio_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
zaudio_attach(struct device *parent, struct device *self, void *aux)
{
	struct zaudio_softc		*sc = (struct zaudio_softc *)self;
	struct pxaip_attach_args	*pxa = aux;
	int err;

	sc->sc_i2s.sc_iot = pxa->pxa_iot;
	sc->sc_i2s.sc_dmat = pxa->pxa_dmat;
	sc->sc_i2s.sc_size = PXA2X0_I2S_SIZE;
	if (pxa2x0_i2s_attach_sub(&sc->sc_i2s)) {
		printf(": unable to attach I2S\n");
		goto fail_i2s;
	}

	sc->sc_i2c.sc_iot = pxa->pxa_iot;
	sc->sc_i2c.sc_size = PXA2X0_I2C_SIZE;
	if (pxa2x0_i2c_attach_sub(&sc->sc_i2c)) {
		printf(": unable to attach I2C\n");
		goto fail_i2c;
	}

	/* Check for an I2C response from the wm8750 */
	pxa2x0_i2c_open(&sc->sc_i2c);
	err = wm8750_write(sc, RESET_REG, 0);
	pxa2x0_i2c_close(&sc->sc_i2c);

	if (err) {
		printf(": codec failed to respond\n");
		goto fail_probe;
	}
	delay(100);

	/* Speaker on, headphones off by default. */
	sc->sc_volume[ZAUDIO_OP_SPKR].left = 240;
	sc->sc_unmute[ZAUDIO_OP_SPKR] = 1;
	sc->sc_volume[ZAUDIO_OP_HP].left = 180;
	sc->sc_volume[ZAUDIO_OP_HP].right = 180;
	sc->sc_unmute[ZAUDIO_OP_HP] = 0;

	/* Configure headphone jack state change handling. */
	timeout_set(&sc->sc_to, zaudio_jack, sc);
	pxa2x0_gpio_set_function(GPIO_HP_IN_C3000, GPIO_IN);
	(void)pxa2x0_gpio_intr_establish(GPIO_HP_IN_C3000,
	    IST_EDGE_BOTH, IPL_BIO, zaudio_jack_intr, sc, "hpjk");

	zaudio_init(sc);

	printf(": I2C, I2S, WM8750 Audio\n");

	audio_attach_mi(&wm8750_hw_if, sc, &sc->sc_dev);

	return;

fail_probe:
	pxa2x0_i2c_detach_sub(&sc->sc_i2c);
fail_i2c:
	pxa2x0_i2s_detach_sub(&sc->sc_i2s);
fail_i2s:
	;
}

int
zaudio_detach(struct device *self, int flags)
{
	struct zaudio_softc *sc = (struct zaudio_softc *)self;

	pxa2x0_i2c_detach_sub(&sc->sc_i2c);
	pxa2x0_i2s_detach_sub(&sc->sc_i2s);

	return (0);
}

int
zaudio_activate(struct device *self, int act)
{
	struct zaudio_softc *sc = (struct zaudio_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		timeout_del(&sc->sc_to);
		zaudio_standby(sc);
		break;
	case DVACT_RESUME:
		pxa2x0_i2s_init(&sc->sc_i2s);
		pxa2x0_i2c_init(&sc->sc_i2c);
		zaudio_init(sc);
		break;
	}
	return 0;
}

void
zaudio_init(struct zaudio_softc *sc)
{
	pxa2x0_i2c_open(&sc->sc_i2c);

	/* Reset the codec */
	wm8750_write(sc, RESET_REG, 0);
	delay(100);

	/* Switch to standby power only */
	wm8750_write(sc, PWRMGMT1_REG, PWRMGMT1_SET_VMIDSEL(2));
	wm8750_write(sc, PWRMGMT2_REG, 0);

	/* Configure digital interface for I2S */
	wm8750_write(sc, AUDINT_REG, AUDINT_SET_FORMAT(2));

	/* Initialise volume levels */
	zaudio_update_volume(sc, ZAUDIO_OP_SPKR);
	zaudio_update_volume(sc, ZAUDIO_OP_HP);
	scoop_set_headphone(0);

	pxa2x0_i2c_close(&sc->sc_i2c);

	/* Assume that the jack state has changed. */ 
	zaudio_jack(sc);

}

int
zaudio_jack_intr(void *v)
{
	struct zaudio_softc *sc = v;

	if (!timeout_triggered(&sc->sc_to))
		zaudio_jack(sc);
	
	return (1);
}

void
zaudio_jack(void *v)
{
	struct zaudio_softc *sc = v;

	switch (sc->sc_state) {
	case ZAUDIO_JACK_STATE_OUT:
		if (pxa2x0_gpio_get_bit(GPIO_HP_IN_C3000)) {
			sc->sc_state = ZAUDIO_JACK_STATE_INS;
			sc->sc_icount = 0;
		}
		break;
	case ZAUDIO_JACK_STATE_INS:
		if (sc->sc_icount++ > 2) {
			if (pxa2x0_gpio_get_bit(GPIO_HP_IN_C3000)) {
				sc->sc_state = ZAUDIO_JACK_STATE_IN;
				sc->sc_unmute[ZAUDIO_OP_SPKR] = 0;
				sc->sc_unmute[ZAUDIO_OP_HP] = 1;
				goto update_mutes;
			} else 
				sc->sc_state = ZAUDIO_JACK_STATE_OUT;
		}
		break;
	case ZAUDIO_JACK_STATE_IN:
		if (!pxa2x0_gpio_get_bit(GPIO_HP_IN_C3000)) {
			sc->sc_state = ZAUDIO_JACK_STATE_REM;
			sc->sc_icount = 0;
		}
		break;
	case ZAUDIO_JACK_STATE_REM: 
		if (sc->sc_icount++ > 2) {
			if (!pxa2x0_gpio_get_bit(GPIO_HP_IN_C3000)) {
				sc->sc_state = ZAUDIO_JACK_STATE_OUT;
				sc->sc_unmute[ZAUDIO_OP_SPKR] = 1;
				sc->sc_unmute[ZAUDIO_OP_HP] = 0;
				goto update_mutes;
			} else
				sc->sc_state = ZAUDIO_JACK_STATE_IN;
		}
		break;
	}
	
	timeout_add(&sc->sc_to, hz/4);
	return;

update_mutes:
	timeout_del(&sc->sc_to);

	if (sc->sc_playing) {
		pxa2x0_i2c_open(&sc->sc_i2c);
		zaudio_update_mutes(sc);
		pxa2x0_i2c_close(&sc->sc_i2c);
	}
}

void
zaudio_standby(struct zaudio_softc *sc)
{
	pxa2x0_i2c_open(&sc->sc_i2c);

	/* Switch codec to standby power only */
	wm8750_write(sc, PWRMGMT1_REG, PWRMGMT1_SET_VMIDSEL(2));
	wm8750_write(sc, PWRMGMT2_REG, 0);

	scoop_set_headphone(0);

	pxa2x0_i2c_close(&sc->sc_i2c);
}

void
zaudio_update_volume(struct zaudio_softc *sc, int output)
{
	switch(output) {
	case ZAUDIO_OP_SPKR:
		wm8750_write(sc, LOUT2VOL_REG, LOUT2VOL_LO2VU | LOUT2VOL_LO2ZC |
		    LOUT2VOL_SET_LOUT2VOL(sc->sc_volume[ZAUDIO_OP_SPKR
		    ].left >> 1));
		wm8750_write(sc, ROUT2VOL_REG, ROUT2VOL_RO2VU | ROUT2VOL_RO2ZC |
		    ROUT2VOL_SET_ROUT2VOL(sc->sc_volume[ZAUDIO_OP_SPKR
		    ].left >> 1));
		break;
	case ZAUDIO_OP_HP:
		wm8750_write(sc, LOUT1VOL_REG, LOUT1VOL_LO1VU | LOUT1VOL_LO1ZC |
		    LOUT1VOL_SET_LOUT1VOL(sc->sc_volume[ZAUDIO_OP_HP
		    ].left >> 1));
		wm8750_write(sc, ROUT1VOL_REG, ROUT1VOL_RO1VU | ROUT1VOL_RO1ZC |
		    ROUT1VOL_SET_ROUT1VOL(sc->sc_volume[ZAUDIO_OP_HP
		    ].right >> 1));
		break;
	}
}

void
zaudio_update_mutes(struct zaudio_softc *sc)
{
	unsigned short val;

	val = PWRMGMT2_DACL | PWRMGMT2_DACR;

	if (sc->sc_unmute[ZAUDIO_OP_SPKR])
		val |= PWRMGMT2_LOUT2 | PWRMGMT2_ROUT2;

	if (sc->sc_unmute[ZAUDIO_OP_HP])
		val |= PWRMGMT2_LOUT1 | PWRMGMT2_ROUT1;

	wm8750_write(sc, PWRMGMT2_REG, val);

	scoop_set_headphone(sc->sc_unmute[ZAUDIO_OP_HP]);
}

void
zaudio_play_setup(struct zaudio_softc *sc)
{
	int i = 0;

	pxa2x0_i2c_open(&sc->sc_i2c);

	/* Program the codec with playback settings */
	while (playback_registers[i][0] != 0xffff) {
		wm8750_write(sc, playback_registers[i][0],
		    playback_registers[i][1]);
		i++;
	}
	zaudio_update_mutes(sc);

	pxa2x0_i2c_close(&sc->sc_i2c);
}

int
zaudio_open(void *hdl, int flags)
{
	struct zaudio_softc *sc = hdl;

	/* can't record yet */
	if (flags & FREAD)
		return (ENXIO);

	/* Power on the I2S bus and codec */
	pxa2x0_i2s_open(&sc->sc_i2s);

	return 0;
}

void
zaudio_close(void *hdl)
{
	struct zaudio_softc *sc = hdl;

	/* Power off the I2S bus and codec */
	pxa2x0_i2s_close(&sc->sc_i2s);
}

int
zaudio_query_encoding(void *hdl, struct audio_encoding *aep)
{
	switch (aep->index) {
	case 0:
		strlcpy(aep->name, AudioEslinear_le, sizeof(aep->name));
		aep->encoding = AUDIO_ENCODING_SLINEAR_LE;
		aep->precision = 16;
		aep->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	aep->bps = AUDIO_BPS(aep->precision);
	aep->msb = 1;
	return (0);
}

int
zaudio_set_params(void *hdl, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct zaudio_softc *sc = hdl;

	if (setmode & AUMODE_PLAY) {
		play->precision = 16;
		play->channels = 2;
		play->encoding = AUDIO_ENCODING_SLINEAR_LE;
		play->bps = AUDIO_BPS(play->precision);
		play->msb = 1;

		pxa2x0_i2s_setspeed(&sc->sc_i2s, &play->sample_rate);
	}

#if RECORD_XXX_NOT_YET
	if (setmode & AUMODE_RECORD) {
		rec->precision = 16;
		rec->channels = 2;
		rec->encoding = AUDIO_ENCODING_SLINEAR_LE;
		rec->bps = AUDIO_BPS(rec->precision);
		rec->msb = 1;

		pxa2x0_i2s_setspeed(sc, &rec->sample_rate);
	}
#endif

	return (0);
}

int
zaudio_halt_output(void *hdl)
{
	struct zaudio_softc *sc = hdl;

	/* XXX forcibly stop output DMA? */

	mtx_enter(&audio_lock);
	zaudio_standby(sc);
	sc->sc_playing = 0;
	mtx_leave(&audio_lock);

	return 0;
}

int
zaudio_halt_input(void *hdl)
{
	/* struct zaudio_softc *sc = hdl; */

	return 0;
}

int
zaudio_getdev(void *hdl, struct audio_device *ret)
{
	/* struct zaudio_softc *sc = hdl; */

	*ret = wm8750_device;
	return 0;
}

#define ZAUDIO_SPKR_LVL		0
#define ZAUDIO_SPKR_MUTE	1
#define ZAUDIO_HP_LVL		2
#define ZAUDIO_HP_MUTE		3
#define ZAUDIO_OUTPUT_CLASS	4

int
zaudio_set_port(void *hdl, struct mixer_ctrl *mc)
{
	struct zaudio_softc *sc = hdl;
	int error = EINVAL, s;

	s = splbio();
	pxa2x0_i2c_open(&sc->sc_i2c);

	switch (mc->dev) {
	case ZAUDIO_SPKR_LVL:
		if (mc->type != AUDIO_MIXER_VALUE)
			break;
		if (mc->un.value.num_channels == 1)
			sc->sc_volume[ZAUDIO_OP_SPKR].left =
			    mc->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		else
			break;
		zaudio_update_volume(sc, ZAUDIO_OP_SPKR);
		error = 0;
		break;
	case ZAUDIO_SPKR_MUTE:
		if (mc->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_unmute[ZAUDIO_OP_SPKR] = mc->un.ord ? 1 : 0;
		zaudio_update_mutes(sc);
		error = 0;
		break;
	case ZAUDIO_HP_LVL:
		if (mc->type != AUDIO_MIXER_VALUE)
			break;
		if (mc->un.value.num_channels == 1) {
			sc->sc_volume[ZAUDIO_OP_HP].left =
			    mc->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			sc->sc_volume[ZAUDIO_OP_HP].right =
			    mc->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		} else if (mc->un.value.num_channels == 2) {
			sc->sc_volume[ZAUDIO_OP_HP].left =
			    mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_volume[ZAUDIO_OP_HP].right =
			    mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		}
		else
			break;
		zaudio_update_volume(sc, ZAUDIO_OP_HP);
		error = 0;
		break;
	case ZAUDIO_HP_MUTE:
		if (mc->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_unmute[ZAUDIO_OP_HP] = mc->un.ord ? 1 : 0;
		zaudio_update_mutes(sc);
		error = 0;
		break;
	}

	pxa2x0_i2c_close(&sc->sc_i2c);
	splx(s);

	return error;
}

int
zaudio_get_port(void *hdl, struct mixer_ctrl *mc)
{
	struct zaudio_softc *sc = hdl;
	int error = EINVAL;

	switch (mc->dev) {
	case ZAUDIO_SPKR_LVL:
		if (mc->type != AUDIO_MIXER_VALUE)
			break;
		if (mc->un.value.num_channels == 1)
			mc->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    sc->sc_volume[ZAUDIO_OP_SPKR].left;
		else
			break;
		error = 0;
		break;
	case ZAUDIO_SPKR_MUTE:
		if (mc->type != AUDIO_MIXER_ENUM)
			break;
		mc->un.ord = sc->sc_unmute[ZAUDIO_OP_SPKR] ? 1 : 0;
		error = 0;
		break;
	case ZAUDIO_HP_LVL:
		if (mc->type != AUDIO_MIXER_VALUE)
			break;
		if (mc->un.value.num_channels == 1)
			mc->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    sc->sc_volume[ZAUDIO_OP_HP].left;
		else if (mc->un.value.num_channels == 2) {
			mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    sc->sc_volume[ZAUDIO_OP_HP].left;
			mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    sc->sc_volume[ZAUDIO_OP_HP].right;
		}
		else
			break;
		error = 0;
		break;
	case ZAUDIO_HP_MUTE:
		if (mc->type != AUDIO_MIXER_ENUM)
			break;
		mc->un.ord = sc->sc_unmute[ZAUDIO_OP_HP] ? 1 : 0;
		error = 0;
		break;
	}

	return error;
}

int
zaudio_query_devinfo(void *hdl, struct mixer_devinfo *di)
{
	/* struct zaudio_softc *sc = hdl; */

	switch (di->index) {
	case ZAUDIO_SPKR_LVL:
		di->type = AUDIO_MIXER_VALUE;
		di->mixer_class = ZAUDIO_OUTPUT_CLASS;
		di->prev = AUDIO_MIXER_LAST;
		di->next = ZAUDIO_SPKR_MUTE;
		strlcpy(di->label.name, AudioNspeaker,
		    sizeof(di->label.name));
		strlcpy(di->un.v.units.name, AudioNvolume,
		    sizeof(di->un.v.units.name));
		di->un.v.num_channels = 1;
		break;
	case ZAUDIO_SPKR_MUTE:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = ZAUDIO_OUTPUT_CLASS;
		di->prev = ZAUDIO_SPKR_LVL;
		di->next = AUDIO_MIXER_LAST;
		goto mute;
	case ZAUDIO_HP_LVL:
		di->type = AUDIO_MIXER_VALUE;
		di->mixer_class = ZAUDIO_OUTPUT_CLASS;
		di->prev = AUDIO_MIXER_LAST;
		di->next = ZAUDIO_HP_MUTE;
		strlcpy(di->label.name, AudioNheadphone,
		    sizeof(di->label.name));
		di->un.v.num_channels = 1;
		strlcpy(di->un.v.units.name, AudioNvolume,
		    sizeof(di->un.v.units.name));
		break;
	case ZAUDIO_HP_MUTE:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = ZAUDIO_OUTPUT_CLASS;
		di->prev = ZAUDIO_HP_LVL;
		di->next = AUDIO_MIXER_LAST;
mute:
		strlcpy(di->label.name, AudioNmute, sizeof(di->label.name));
		di->un.e.num_mem = 2;
		strlcpy(di->un.e.member[0].label.name, AudioNon,
		    sizeof(di->un.e.member[0].label.name));
		di->un.e.member[0].ord = 0;
		strlcpy(di->un.e.member[1].label.name, AudioNoff,
		    sizeof(di->un.e.member[1].label.name));
		di->un.e.member[1].ord = 1;
		break;
	case ZAUDIO_OUTPUT_CLASS:
		di->type = AUDIO_MIXER_CLASS;
		di->mixer_class = ZAUDIO_OUTPUT_CLASS;
		di->prev = AUDIO_MIXER_LAST;
		di->next = AUDIO_MIXER_LAST;
		strlcpy(di->label.name, AudioCoutputs,
		    sizeof(di->label.name));
		break;
	default:
		return ENXIO;
	}

	return 0;
}

int
zaudio_get_props(void *hdl)
{
	return AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX;
}

void
zaudio_pintr(void *hdl)
{
	struct zaudio_softc *sc = hdl;

	mtx_enter(&audio_lock);
	sc->sc_pintr(sc->sc_parg);
	mtx_leave(&audio_lock);
}

/*
 * called by interrupt code-path, don't lock
 */
int
zaudio_start_output(void *hdl, void *block, int bsize, void (*intr)(void *),
    void *intrarg)
{
	struct zaudio_softc *sc = hdl;
	int err;

	/* Power up codec if we are not already playing. */
	if (!sc->sc_playing) {
		sc->sc_playing = 1;
		zaudio_play_setup(sc);
	}

	/* Start DMA via I2S */
	sc->sc_pintr = intr;
	sc->sc_parg = intrarg;
	err = pxa2x0_i2s_start_output(&sc->sc_i2s, block, bsize, zaudio_pintr, sc);
	if (err) {
		zaudio_standby(sc);
		sc->sc_playing = 0;
	}
	return err;
}

/*
 * called by interrupt code-path, don't lock
 */
int
zaudio_start_input(void *hdl, void *block, int bsize, void (*intr)(void *),
    void *intrarg)
{
	return ENXIO;
}
@


1.19
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.18 2014/09/19 16:45:55 jsg Exp $	*/
@


1.18
log
@add missing break statements giving alaw encoding
a chance of working instead of returning EINVAL.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.17 2013/08/30 14:18:38 ratchov Exp $	*/
a44 1

a45 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a482 24
		strlcpy(aep->name, AudioEulinear, sizeof(aep->name));
		aep->encoding = AUDIO_ENCODING_ULINEAR;
		aep->precision = 8;
		aep->flags = 0;
		break;
	case 1:
		strlcpy(aep->name, AudioEmulaw, sizeof(aep->name));
		aep->encoding = AUDIO_ENCODING_ULAW;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(aep->name, AudioEalaw, sizeof(aep->name));
		aep->encoding = AUDIO_ENCODING_ALAW;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(aep->name, AudioEslinear, sizeof(aep->name));
		aep->encoding = AUDIO_ENCODING_SLINEAR;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
a487 18
	case 5:
		strlcpy(aep->name, AudioEulinear_le, sizeof(aep->name));
		aep->encoding = AUDIO_ENCODING_ULINEAR_LE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(aep->name, AudioEslinear_be, sizeof(aep->name));
		aep->encoding = AUDIO_ENCODING_SLINEAR_BE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(aep->name, AudioEulinear_be, sizeof(aep->name));
		aep->encoding = AUDIO_ENCODING_ULINEAR_BE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
d503 3
a505 171
		play->factor = 1;
		play->sw_code = NULL;
		switch(play->encoding) {
		case AUDIO_ENCODING_ULAW:
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = mulaw_to_slinear16_le_mts;
				break;
			case 2:
				play->factor = 2;
				play->sw_code = mulaw_to_slinear16_le;
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = noswap_bytes_mts;
					break;
				case 2:
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code =
					    ulinear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = change_sign16_le_mts;
					break;
				case 2:
					play->sw_code = change_sign16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ALAW:
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = alaw_to_slinear16_le_mts;
				break;
			case 2:
				play->factor = 2;
				play->sw_code = alaw_to_slinear16_le;
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code =
					    linear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = swap_bytes_mts;
					break;
				case 2:
					play->sw_code = swap_bytes;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code =
					    ulinear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code =
					    swap_bytes_change_sign16_le_mts;
					break;
				case 2:
					play->sw_code =
					    swap_bytes_change_sign16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		default:
			return (EINVAL);
		}

d514 3
a516 31
		rec->factor = 1;
		rec->sw_code = NULL;
		switch(rec->encoding) {
		case AUDIO_ENCODING_ULAW:
			rec->sw_code = ulinear8_to_mulaw;
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			if (rec->precision == 8)
				rec->sw_code = change_sign8;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (rec->precision == 16)
				rec->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ALAW:
			rec->sw_code = ulinear8_to_alaw;
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (rec->precision == 16)
				rec->sw_code = swap_bytes;
			else
				rec->sw_code = change_sign8;
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			if (rec->precision == 16)
				rec->sw_code = change_sign16_swap_bytes_le;
			break;
		default:
			return (EINVAL);
		}

@


1.17
log
@Lock the audio mutex before invoking the audio(4) call-back, fixes
panics found by David Krause, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.16 2013/05/15 08:29:24 ratchov Exp $	*/
d636 1
d640 1
@


1.16
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.15 2012/03/01 08:17:26 ratchov Exp $	*/
d60 2
d97 2
d986 10
d1013 3
a1015 1
	err = pxa2x0_i2s_start_output(&sc->sc_i2s, block, bsize, intr, intrarg);
@


1.15
log
@zaudio is play only, so return ENXIO on any attempt to open the device
for recording. Fixes full-duplex apps (including sndiod) unable to fall
back to play-only mode. Found by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.14 2010/09/07 16:21:41 deraadt Exp $	*/
d769 1
d772 1
d982 3
d1007 3
@


1.14
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.13 2010/08/30 21:35:57 deraadt Exp $	*/
d30 1
d457 4
@


1.13
log
@Convert all powerhooks to activate functions, and provide powerhook stubs.
Of note:  lcd stubs get pulled up to the parent; zts has to keep track of
whether it is in use or not
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.12 2010/08/27 05:04:11 deraadt Exp $	*/
a20 1
 *	- powerhooks (currently only works until first suspend)
a58 1
void	zaudio_powerhook(int, void *);
a85 1
	void			*sc_powerhook;
a199 6
	sc->sc_powerhook = powerhook_establish(zaudio_powerhook, sc);
	if (sc->sc_powerhook == NULL) {
		printf(": unable to establish powerhook\n");
		return;
	}

d252 1
a252 1
	powerhook_disestablish(sc->sc_powerhook);
a259 5
	if (sc->sc_powerhook != NULL) {
		powerhook_disestablish(sc->sc_powerhook);
		sc->sc_powerhook = NULL;
	}

a282 6
}

void
zaudio_powerhook(int why, void *arg)
{
	zaudio_activate(arg, why);
@


1.12
log
@More killing of PWR_STANDBY.  cvs skipped these files
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.11 2010/07/15 03:43:11 jakemsr Exp $	*/
d59 2
a60 1
void	zaudio_power(int, void *);
d101 1
a101 1
	zaudio_detach
d203 1
a203 1
	sc->sc_powerhook = powerhook_establish(zaudio_power, sc);
d280 2
a281 2
void
zaudio_power(int why, void *arg)
d283 1
a283 1
	struct zaudio_softc *sc = arg;
d285 2
a286 2
	switch (why) {
	case PWR_SUSPEND:
d290 1
a290 2

	case PWR_RESUME:
d296 7
@


1.11
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.10 2008/04/21 00:32:42 jakemsr Exp $	*/
a284 1
	case PWR_STANDBY:
@


1.10
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.9 2007/11/05 00:17:28 jakemsr Exp $	*/
d495 1
a495 1
		return (0);
d501 1
a501 1
		return (0);
d507 1
a507 1
		return (0);
d513 1
a513 1
		return (0);
d519 1
a519 1
		return (0);
d525 1
a525 1
		return (0);
d531 1
a531 1
		return (0);
d537 1
a537 1
		return (0);
d541 3
d722 3
d760 3
@


1.9
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.8 2005/08/18 13:23:02 robert Exp $	*/
d161 2
a162 1
	NULL /* zaudio_trigger_input */
@


1.8
log
@Make zaudio(4) work like a laptop, so that when you plug your headphones
into the plug it changes the mute values so the speaker will be muted and
the headphones will be unmuted. If you unplug the headphones, it will change
everything back to the default state.

help and ok from uwe@@ pascoe@@; tested by others
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.7 2005/05/26 03:52:07 pascoe Exp $	*/
d556 1
a556 1
				play->sw_code = mulaw_to_slinear16_mts;
d560 1
a560 1
				play->sw_code = mulaw_to_slinear16;
d572 1
a572 1
					play->sw_code = linear8_to_linear16_mts;
d576 1
a576 1
					play->sw_code = linear8_to_linear16;
d605 1
a605 1
					    ulinear8_to_linear16_mts;
d609 1
a609 1
					play->sw_code = ulinear8_to_linear16;
d619 1
a619 1
					play->sw_code = change_sign16_mts;
d622 1
a622 1
					play->sw_code = change_sign16;
d636 1
a636 1
				play->sw_code = alaw_to_slinear16_mts;
d639 1
a639 1
				play->sw_code = alaw_to_slinear16;
d651 1
a651 1
					    linear8_to_linear16_mts;
d655 1
a655 1
					play->sw_code = linear8_to_linear16;
d685 1
a685 1
					    ulinear8_to_linear16_mts;
d689 1
a689 1
					play->sw_code = ulinear8_to_linear16;
d700 1
a700 1
					    change_sign16_swap_bytes_mts;
d704 1
a704 1
					    change_sign16_swap_bytes;
d735 1
a735 1
				rec->sw_code = change_sign16;
d748 1
a748 1
				rec->sw_code = swap_bytes_change_sign16;
@


1.7
log
@Reset the zaurus audio components after resume, so that subsequent opens
can play sound again.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.5 2005/05/23 22:53:22 pascoe Exp $	*/
d27 1
d41 1
d64 8
d92 4
d114 2
d240 6
d286 1
d320 70
d801 1
a801 1
	int error = EINVAL;
d803 1
d854 1
@


1.6
log
@No need to clock i2s during i2c operations, so don't.  Relocate i2c
open/close into init routine.
@
text
@d259 14
a272 2
	/* XXX */
	return;
@


1.5
log
@Cleanup leading and trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.4 2005/05/23 22:44:57 pascoe Exp $	*/
d183 1
a206 1
	pxa2x0_i2s_open(&sc->sc_i2s);	/* supply the codec with a clock */
d208 2
d211 1
a211 1
	if (wm8750_write(sc, RESET_REG, 0)) {
a225 3
	pxa2x0_i2c_close(&sc->sc_i2c);
	pxa2x0_i2s_close(&sc->sc_i2s);

a232 2
	pxa2x0_i2c_close(&sc->sc_i2c);
	pxa2x0_i2s_close(&sc->sc_i2s);
d266 2
d283 2
@


1.4
log
@Headphone output and volume control support.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.3 2005/04/21 13:43:48 pascoe Exp $	*/
d77 1
a77 1
	void 			*sc_powerhook;
d156 1
a156 1
	{ ADCTL1_REG, ADCTL1_TSDEN | ADCTL1_SET_VSEL(3) },	
d166 1
a166 1
	{ ROUTMIX2_REG, ROUTMIX2_RD2RO }, 
d437 1
a437 1
zaudio_set_params(void *hdl, int setmode, int usemode, 
d681 1
a681 1
	*ret = wm8750_device;	
d885 1
a885 1
 	err = pxa2x0_i2s_start_output(&sc->sc_i2s, block, bsize, intr, intrarg);
@


1.3
log
@Move i2c open/close from callers into zaudio_standby.  Fixes an error path.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.2 2005/04/15 01:17:26 pascoe Exp $	*/
a20 1
 *	- zaudio(4)
a21 1
 *	- headphone jack support
a22 1
 *	- mixer support (codec has independent o/p volume, l/r mix, equalizer)
d59 8
d79 3
d101 2
d164 3
a166 11
	/* Power DACs and outputs */
	{ PWRMGMT2_REG, PWRMGMT2_DACL | PWRMGMT2_DACR | PWRMGMT2_LOUT1 |
	    PWRMGMT2_ROUT1 | PWRMGMT2_LOUT2 | PWRMGMT2_ROUT2 },

	/* Set left/right channel mix mixer */
	{ LOUTMIX1_REG, LOUTMIX1_LD2LO | LOUTMIX1_SET_LI2LOVOL(5) }, 
	{ ROUTMIX2_REG, ROUTMIX2_RD2RO | ROUTMIX2_SET_RI2ROVOL(5) },

	/* Set speaker volume */
	{ LOUT2VOL_REG, LOUT2VOL_LO2VU | LOUT2VOL_SET_LOUT2VOL(SPKR_VOLUME) },
	{ ROUT2VOL_REG, ROUT2VOL_RO2VU | ROUT2VOL_SET_ROUT2VOL(0) },
d215 7
d279 5
d295 2
d301 41
d354 1
a365 1
	scoop_audio_set(1);
a376 1
	scoop_audio_set(0);
d685 6
d694 53
a746 1
	/* struct zaudio_softc *sc = hdl; */
d748 1
a748 1
	return 0;
d754 43
a796 1
	/* struct zaudio_softc *sc = hdl; */
d798 1
a798 1
	return 0;
d806 55
a860 1
	di->prev = di->next = AUDIO_MIXER_LAST;
d862 1
a862 1
	return ENXIO;
@


1.2
log
@Add TODO list for zaudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_audio.c,v 1.1 2005/04/15 01:05:51 pascoe Exp $	*/
d275 2
d280 2
a605 2
	pxa2x0_i2c_open(&sc->sc_i2c);

a607 2

	pxa2x0_i2c_close(&sc->sc_i2c);
@


1.1
log
@Add basic audio playback support for the Zaurus SL-C3000.

ok dlg@@ drahn@@ uwe@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d17 9
@

