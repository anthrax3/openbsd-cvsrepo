head	1.35;
access;
symbols
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.35
date	2016.09.03.13.37.43;	author guenther;	state dead;
branches;
next	1.34;
commitid	6T3r4QcMFKe3Fo5T;

1.34
date	2015.09.28.18.36.36;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	sjQx9dlBaND52EhB;

1.33
date	2015.02.11.07.05.39;	author dlg;	state Exp;
branches;
next	1.32;
commitid	JTpbkhDknrIuy9pn;

1.32
date	2015.02.11.05.07.25;	author miod;	state Exp;
branches;
next	1.31;
commitid	lz1LOtkX2rLyqrcj;

1.31
date	2015.02.07.03.58.28;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	cbIQ99BNyq3C6YKo;

1.30
date	2014.12.19.14.23.58;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	AbdU8YT52zsPIsQh;

1.29
date	2014.12.18.20.01.33;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	u02ybufTMYPtvBX4;

1.28
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	IFRB8AkvBMXMTAKW;

1.27
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	EF98ch02VpFassUi;

1.26
date	2014.03.31.12.11.42;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.13.03.52.56;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.17.22.49.27;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.07.16.21.41;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.08.31.17.13.46;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.30.21.37.53;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.29.02.02.26;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.20.12.23.02;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.21.03.11.30;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.30.17.40.55;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.12.23.14.28;	author dim;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.22.00.38.48;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.20.04.24.56;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.31.05.23.33;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.31.04.56.14;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.27.05.14.41;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.27.05.09.42;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.13.05.49.57;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.11.03.21.03;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.30.21.44.08;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.13.05.13.15;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.11.00.18.17;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.26.06.34.54;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Retire zaurus, as it hasn't made the EABI jump and will be permanently broken
shortly when we use the hardware thread register in userland
@
text
@/*	$OpenBSD: zaurus_apm.c,v 1.34 2015/09/28 18:36:36 deraadt Exp $	*/

/*
 * Copyright (c) 2005 Uwe Stuehler <uwe@@bsdx.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/sysctl.h>
#include <sys/mutex.h>
#include <sys/reboot.h>
#include <sys/rwlock.h>
#include <dev/rndvar.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0_apm.h>
#include <arm/xscale/pxa2x0_gpio.h>

#include <zaurus/dev/zaurus_scoopvar.h>
#include <zaurus/dev/zaurus_sspvar.h>
void zssp_init(void);	/* XXX */

#include <zaurus/dev/zaurus_apm.h>

#include <dev/wscons/wsdisplayvar.h>

#include "wsdisplay.h"

#if defined(APMDEBUG)
#define DPRINTF(x)	printf x
#else
#define	DPRINTF(x)	/**/
#endif

struct zapm_softc {
	struct pxa2x0_apm_softc sc;
	struct timeout sc_poll;
	struct timeval sc_lastbattchk;
	int	sc_suspended;
	int	sc_ac_on;
	int	sc_charging;
	int	sc_discharging;
	int	sc_batt_full;
	int	sc_batt_volt;
	u_int	sc_event;
};

int	apm_match(struct device *, void *, void *);
void	apm_attach(struct device *, struct device *, void *);
int	apm_activate(struct device *, int);

struct cfattach apm_pxaip_ca = {
        sizeof (struct zapm_softc), apm_match, apm_attach,
	NULL, apm_activate
};
extern struct cfdriver apm_cd;

/* MAX1111 command word */
#define MAXCTRL_PD0		(1<<0)
#define MAXCTRL_PD1		(1<<1)
#define MAXCTRL_SGL		(1<<2)
#define MAXCTRL_UNI		(1<<3)
#define MAXCTRL_SEL_SHIFT	4
#define MAXCTRL_STR		(1<<7)

/* MAX1111 ADC channels */
#define	BATT_THM		2
#define	BATT_AD			4
#define JK_VAD			6

/* battery-related GPIO pins */
#define GPIO_AC_IN_C3000	115	/* 0=AC connected */
#define GPIO_CHRG_CO_C3000	101	/* 1=battery full */
#define GPIO_BATT_COVER_C3000	90	/* 0=unlocked */

/*
 * Battery-specific information
 */

struct battery_threshold {
	int	bt_volt;
	int	bt_life;
	int	bt_state;
};

struct battery_info {
	int	bi_minutes;		/* 100% life time */
	const	struct battery_threshold *bi_thres;
};

const struct battery_threshold zaurus_battery_life_c3000[] = {
#if 0
	{224,	125,	APM_BATT_HIGH}, /* XXX unverified */
#endif
	{194,	100,	APM_BATT_HIGH},
	{188,	75,	APM_BATT_HIGH},
	{184,	50,	APM_BATT_HIGH},
	{180,	25,	APM_BATT_LOW},
	{178,	5,	APM_BATT_LOW},
	{0,	0,	APM_BATT_CRITICAL},
};

const struct battery_info zaurus_battery_c3000 = {
	180 /* minutes; pessimistic estimate */,
	zaurus_battery_life_c3000
};

const struct battery_info *zaurus_main_battery = &zaurus_battery_c3000;

/* Restart charging this many times before accepting BATT_FULL. */
#define MIN_BATT_FULL 2

/* Discharge 100 ms before reading the voltage if AC is connected. */
#define DISCHARGE_TIMEOUT (hz / 10)

/* Check battery voltage and "kick charging" every minute. */
const	struct timeval zapm_battchkrate = { 60, 0 };

/* Prototypes */

int	zapm_acintr(void *);
int	zapm_bcintr(void *);
int	zapm_ac_on(void);
int	max1111_adc_value(int);
int	max1111_adc_value_avg(int, int);
#if 0
int	zapm_jkvad_voltage(void);
int	zapm_batt_temp(void);
#endif
int	zapm_batt_volt(void);
int	zapm_batt_state(int);
int	zapm_batt_life(int);
int	zapm_batt_minutes(int);
void	zapm_enable_charging(struct zapm_softc *, int);
int	zapm_charge_complete(struct zapm_softc *);
void	zapm_poll(void *);
int	zapm_get_event(struct pxa2x0_apm_softc *, u_int *);
void	zapm_power_info(struct pxa2x0_apm_softc *, struct apm_power_info *);
void	zapm_suspend(struct pxa2x0_apm_softc *);
int	zapm_resume(struct pxa2x0_apm_softc *);
void	pxa2x0_setperf(int);
int	pxa2x0_cpuspeed(int *);


int
apm_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
apm_attach(struct device *parent, struct device *self, void *aux)
{
	struct zapm_softc *sc = (struct zapm_softc *)self;

	pxa2x0_gpio_set_function(GPIO_AC_IN_C3000, GPIO_IN);
	pxa2x0_gpio_set_function(GPIO_CHRG_CO_C3000, GPIO_IN);
	pxa2x0_gpio_set_function(GPIO_BATT_COVER_C3000, GPIO_IN);

	(void)pxa2x0_gpio_intr_establish(GPIO_AC_IN_C3000,
	    IST_EDGE_BOTH, IPL_BIO, zapm_acintr, sc, "apm_ac");
	(void)pxa2x0_gpio_intr_establish(GPIO_BATT_COVER_C3000,
	    IST_EDGE_BOTH, IPL_BIO, zapm_bcintr, sc, "apm_bc");

	sc->sc_event = APM_NOEVENT;
	sc->sc.sc_get_event = zapm_get_event;
	sc->sc.sc_power_info = zapm_power_info;
	sc->sc.sc_suspend = zapm_suspend;
	sc->sc.sc_resume = zapm_resume;

	timeout_set(&sc->sc_poll, &zapm_poll, sc);

	/* Get initial battery voltage. */
	zapm_enable_charging(sc, 0);
	if (zapm_ac_on()) {
		/* C3000: discharge 100 ms when AC is on. */
		scoop_discharge_battery(1);
		delay(100000);
	}
	sc->sc_batt_volt = zapm_batt_volt();
	scoop_discharge_battery(0);

	pxa2x0_apm_attach_sub(&sc->sc);

	cpu_setperf = pxa2x0_setperf;
	cpu_cpuspeed = pxa2x0_cpuspeed;
}

int
apm_activate(struct device *self, int act)
{
	struct zapm_softc *sc = (struct zapm_softc *)self;
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		zapm_enable_charging(sc, 0);
		break;
	}

	return (ret);
}

int
zapm_acintr(void *v)
{
	zapm_poll(v);
	return (1);
}

int
zapm_bcintr(void *v)
{
	zapm_poll(v);
	return (1);
}

int
zapm_ac_on(void)
{
	return (!pxa2x0_gpio_get_bit(GPIO_AC_IN_C3000));
}

int
max1111_adc_value(int chan)
{

	return ((int)zssp_ic_send(ZSSP_IC_MAX1111, MAXCTRL_PD0 |
	    MAXCTRL_PD1 | MAXCTRL_SGL | MAXCTRL_UNI |
	    (chan << MAXCTRL_SEL_SHIFT) | MAXCTRL_STR));
}

/* XXX simplify */
int
max1111_adc_value_avg(int chan, int pause)
{
	int val[5];
	int i, j, k, x;
	int sum = 0;

	for (i = 0; i < 5; i++) {
		val[i] = max1111_adc_value(chan);
		if (i != 4)
			delay(pause * 1000);
	}

	x = val[0];
	j = 0;
	for (i = 1; i < 5; i++) {
		if (x < val[i]) {
			x = val[i];
			j = i;
		}
	}

	x = val[4];
	k = 4;
	for (i = 3; i >= 0; i--) {
		if (x > val[i]) {
			x = val[i];
			k = i;
		}
	}

	for (i = 0; i < 5; i++) {
		if (i == j || i == k)
			continue;
		sum += val[i];
	}

	return (sum / 3);
}

#if 0
/*
 * Return the voltage available for charging.  This will be zero,
 * unless A/C power is connected.
 */
int
zapm_jkvad_voltage(void)
{

	return (max1111_adc_value_avg(JK_VAD, 10));
}

int
zapm_batt_temp(void)
{
	int temp;

	scoop_battery_temp_adc(1);
	delay(10000);
	temp = max1111_adc_value_avg(BATT_THM, 1);
	scoop_battery_temp_adc(0);

	return (temp);
}
#endif

int
zapm_batt_volt(void)
{

	return (max1111_adc_value_avg(BATT_AD, 10));
}

int
zapm_batt_state(int volt)
{
	const struct battery_threshold *bthr;
	int i;

	bthr = zaurus_main_battery->bi_thres;

	for (i = 0; bthr[i].bt_volt > 0; i++)
		if (bthr[i].bt_volt <= volt)
			break;

	return (bthr[i].bt_state);
}

int
zapm_batt_life(int volt)
{
	const struct battery_threshold *bthr;
	int i;

	bthr = zaurus_main_battery->bi_thres;

	for (i = 0; bthr[i].bt_volt > 0; i++)
		if (bthr[i].bt_volt <= volt)
			break;

	if (i == 0)
		return (bthr[i].bt_life);

	return (bthr[i].bt_life +
	    ((volt - bthr[i].bt_volt) * 100) /
	    (bthr[i-1].bt_volt - bthr[i].bt_volt) *
	    (bthr[i-1].bt_life - bthr[i].bt_life) / 100);
}

int
zapm_batt_minutes(int life)
{

	return (zaurus_main_battery->bi_minutes * life / 100);
}

void
zapm_enable_charging(struct zapm_softc *sc, int enable)
{

	scoop_discharge_battery(0);
	scoop_charge_battery(enable, 0);
	scoop_led_set(SCOOP_LED_ORANGE, enable);
}

/*
 * Return non-zero if the charge complete signal indicates that the
 * battery is fully charged.  Restart charging to clear this signal.
 */
int
zapm_charge_complete(struct zapm_softc *sc)
{

	if (sc->sc_charging && sc->sc_batt_full < MIN_BATT_FULL) {
		if (pxa2x0_gpio_get_bit(GPIO_CHRG_CO_C3000) != 0) {
			if (++sc->sc_batt_full < MIN_BATT_FULL) {
				DPRINTF(("battery almost full\n"));
				zapm_enable_charging(sc, 0);
				delay(15000);
				zapm_enable_charging(sc, 1);
			}
		} else if (sc->sc_batt_full > 0) {
			/* false alarm */
			sc->sc_batt_full = 0;
			zapm_enable_charging(sc, 0);
			delay(15000);
			zapm_enable_charging(sc, 1);
		}
	}

	return (sc->sc_batt_full >= MIN_BATT_FULL);
}

/*
 * Poll power-management related GPIO inputs, update battery life
 * in softc, and/or control battery charging.
 */
void
zapm_poll(void *v)
{
	struct zapm_softc *sc = v;
	int ac_on;
	int bc_lock;
	int charging;
	int volt;
	int s;

	s = splhigh();

	/* Check positition of battery compartment lock switch. */
	bc_lock = pxa2x0_gpio_get_bit(GPIO_BATT_COVER_C3000) ? 1 : 0;

	/* Stop discharging. */
	if (sc->sc_discharging) {
		sc->sc_discharging = 0;
		volt = zapm_batt_volt();
		ac_on = zapm_ac_on();
		charging = 0;
		DPRINTF(("zapm_poll: discharge off volt %d\n", volt));
	} else {
		ac_on = zapm_ac_on();
		charging = sc->sc_charging;
		volt = sc->sc_batt_volt;
	}

	/* Start or stop charging as necessary. */
	if (ac_on && bc_lock) {
		if (charging) {
			if (zapm_charge_complete(sc)) {
				DPRINTF(("zapm_poll: batt full\n"));
				charging = 0;
				zapm_enable_charging(sc, 0);
			}
		} else if (!zapm_charge_complete(sc)) {
			charging = 1;
			volt = zapm_batt_volt();
			zapm_enable_charging(sc, 1);
			DPRINTF(("zapm_poll: start charging volt %d\n", volt));
		}
	} else {
		if (charging) {
			charging = 0;
			zapm_enable_charging(sc, 0);
			timerclear(&sc->sc_lastbattchk);
			DPRINTF(("zapm_poll: stop charging\n"));
		}
		sc->sc_batt_full = 0;
	}

	/*
	 * Restart charging once in a while.  Discharge a few milliseconds
	 * before updating the voltage in our softc if A/C is connected.
	 */
	if (bc_lock && ratecheck(&sc->sc_lastbattchk, &zapm_battchkrate)) {
		if (sc->sc_suspended) {
			DPRINTF(("zapm_poll: suspended %lu %lu\n",
			    sc->sc_lastbattchk.tv_sec,
			    pxa2x0_rtc_getsecs()));
			if (charging) {
				zapm_enable_charging(sc, 0);
				delay(15000);
				zapm_enable_charging(sc, 1);
				pxa2x0_rtc_setalarm(pxa2x0_rtc_getsecs() +
				    zapm_battchkrate.tv_sec + 1);
			}
		} else if (ac_on && sc->sc_batt_full == 0) {
			DPRINTF(("zapm_poll: discharge on\n"));
			if (charging)
				zapm_enable_charging(sc, 0);
			sc->sc_discharging = 1;
			scoop_discharge_battery(1);
			timeout_add(&sc->sc_poll, DISCHARGE_TIMEOUT);
		} else if (!ac_on) {
			volt = zapm_batt_volt();
			DPRINTF(("zapm_poll: volt %d\n", volt));
		}
	}

	/* Update the cached power state in our softc. */
	if (ac_on != sc->sc_ac_on || charging != sc->sc_charging ||
	    volt != sc->sc_batt_volt) {
		sc->sc_ac_on = ac_on;
		sc->sc_charging = charging;
		sc->sc_batt_volt = volt;
		if (sc->sc_event == APM_NOEVENT)
			sc->sc_event = APM_POWER_CHANGE;
	}

	/* Detect battery low conditions. */
	if (!ac_on) {
		if (zapm_batt_life(volt) < 5)
			sc->sc_event = APM_BATTERY_LOW;
		if (zapm_batt_state(volt) == APM_BATT_CRITICAL)
			sc->sc_event = APM_CRIT_SUSPEND_REQ;
	}

#ifdef APMDEBUG
	if (sc->sc_event != APM_NOEVENT)
		DPRINTF(("zapm_poll: power event %d\n", sc->sc_event));
#endif
	splx(s);
}

/*
 * apm_thread() calls this routine approximately once per second.
 */
int
zapm_get_event(struct pxa2x0_apm_softc *pxa_sc, u_int *typep)
{
	struct zapm_softc *sc = (struct zapm_softc *)pxa_sc;
	int s;

	s = splsoftclock();

	/* Don't interfere with discharging. */
	if (sc->sc_discharging)
		*typep = sc->sc_event;
	else if (sc->sc_event == APM_NOEVENT) {
		zapm_poll(sc);
		*typep = sc->sc_event;
	}
	sc->sc_event = APM_NOEVENT;

	splx(s);
	return (*typep == APM_NOEVENT);
}

/*
 * Return power status to the generic APM driver.
 */
void
zapm_power_info(struct pxa2x0_apm_softc *pxa_sc, struct apm_power_info *power)
{
	struct zapm_softc *sc = (struct zapm_softc *)pxa_sc;
	int s;
	int ac_on;
	int volt;
	int charging;

	s = splsoftclock();
	ac_on = sc->sc_ac_on;
	volt = sc->sc_batt_volt;
	charging = sc->sc_charging;
	splx(s);

	power->ac_state = ac_on ? APM_AC_ON : APM_AC_OFF;
	if (charging)
		power->battery_state = APM_BATT_CHARGING;
	else
		power->battery_state = zapm_batt_state(volt);

	power->battery_life = zapm_batt_life(volt);
	power->minutes_left = zapm_batt_minutes(power->battery_life);
}

/*
 * Called before suspending when all ca_activate functions are done.
 */
void
zapm_suspend(struct pxa2x0_apm_softc *pxa_sc)
{
	struct zapm_softc *sc = (struct zapm_softc *)pxa_sc;

	config_suspend_all(DVACT_QUIESCE);
	bufq_quiesce();

	/* Poll in suspended mode and forget the discharge timeout. */
	sc->sc_suspended = 1;
	timeout_del(&sc->sc_poll);

	/* Make sure charging is enabled and RTC alarm is set. */
	timerclear(&sc->sc_lastbattchk);

	zapm_poll(sc);

#if 0
	pxa2x0_rtc_setalarm(pxa2x0_rtc_getsecs() + 5);
#endif
	pxa2x0_wakeup_config(PXA2X0_WAKEUP_ALL, 1);
}

/*
 * Called after wake-up from suspend with interrupts still disabled,
 * before any ca_activate functions are done.
 */
int
zapm_resume(struct pxa2x0_apm_softc *pxa_sc)
{
	struct zapm_softc *sc = (struct zapm_softc *)pxa_sc;
	int	a, b;
	u_int	wsrc;
	int	wakeup = 0;

	/* C3000 */
	a = pxa2x0_gpio_get_bit(97) ? 1 : 0;
	b = pxa2x0_gpio_get_bit(96) ? 2 : 0;

	wsrc = pxa2x0_wakeup_status();

	/* Resume only if the lid is not closed. */
	if ((a | b) != 3 && (wsrc & PXA2X0_WAKEUP_POWERON) != 0) {
		int timeout = 100; /* 10 ms */
		/* C3000 */
		while (timeout-- > 0 && pxa2x0_gpio_get_bit(95) != 0) {
			if (timeout == 0) {
				wakeup = 1;
				break;
			}
			delay(100);
		}
	}

	/* Initialize the SSP unit before using the MAX1111 again. */
	zssp_init();

	zapm_poll(sc);

	if (wakeup) {
		/* Resume normal polling. */
		sc->sc_suspended = 0;

		pxa2x0_rtc_setalarm(0);
	} else {
#if 0
		DPRINTF(("zapm_resume: suspended %lu %lu\n",
		    sc->sc_lastbattchk.tv_sec, pxa2x0_rtc_getsecs()));
		pxa2x0_rtc_setalarm(pxa2x0_rtc_getsecs() + 5);
#endif
	}

	return (wakeup);
}

void
zapm_poweroff(void)
{
	struct pxa2x0_apm_softc *sc;
	int s;

	KASSERT(apm_cd.cd_ndevs > 0 && apm_cd.cd_devs[0] != NULL);
	sc = apm_cd.cd_devs[0];

#if NWSDISPLAY > 0
	wsdisplay_suspend();
#endif /* NWSDISPLAY > 0 */

	s = splhigh();
	cold = 2;
	config_suspend_all(DVACT_SUSPEND);

	suspend_randomness();

	/* XXX
	 * Flag to disk drivers that they should "power down" the disk
	 * when we get to DVACT_POWERDOWN.
	 */
	boothowto |= RB_POWERDOWN;
	config_suspend_all(DVACT_POWERDOWN);
	boothowto &= ~RB_POWERDOWN;

	/* XXX enable charging during suspend */

	/* XXX keep power LED state during suspend */

	/* XXX do the same thing for GPIO 43 (BTTXD) */

	/* XXX scoop power down */

	/* XXX set PGSRn and GPDRn */

	pxa2x0_wakeup_config(PXA2X0_WAKEUP_ALL, 1);

	do {
		pxa2x0_apm_sleep(sc);
	} while (!zapm_resume(sc));

	zapm_restart();

	/* NOTREACHED */
	cold = 0;
	config_suspend_all(DVACT_RESUME);
	splx(s);

	resume_randomness(NULL, 0);	/* force RNG upper level reseed */
	bufq_restart();

	config_suspend_all(DVACT_WAKEUP);

#if NWSDISPLAY > 0
	wsdisplay_resume();
#endif /* NWSDISPLAY > 0 */
}

/*
 * Do a GPIO reset, immediately causing the processor to begin the normal
 * boot sequence.  See 2.7 Reset in the PXA27x Developer's Manual for the
 * summary of effects of this kind of reset.
 */
void
zapm_restart(void)
{
	if (apm_cd.cd_ndevs > 0 && apm_cd.cd_devs[0] != NULL) {
		struct pxa2x0_apm_softc *sc = apm_cd.cd_devs[0];
		int rv;

		/*
		 * Reduce the ROM Delay Next Access and ROM Delay First
		 * Access times for synchronous flash connected to nCS1.
		 */
		rv = bus_space_read_4(sc->sc_iot, sc->sc_memctl_ioh,
		    MEMCTL_MSC0);
		if ((rv & 0xffff0000) == 0x7ff00000)
			bus_space_write_4(sc->sc_iot, sc->sc_memctl_ioh,
			    MEMCTL_MSC0, (rv & 0xffff) | 0x7ee00000);
	}

	/* External reset circuit presumably asserts nRESET_GPIO. */
	pxa2x0_gpio_set_function(89, GPIO_OUT | GPIO_SET);
	delay(1000000);
}
@


1.34
log
@In low-level suspend routines, set cold=2.  In tsleep(), use this to
spit out a ddb trace to console.  This should allow us to find suspend
or resume routines which break the rules.  It depends on the console
output function being non-sleeping.... but that's another codepath which
should try to be safe when cold is set.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.33 2015/02/11 07:05:39 dlg Exp $	*/
@


1.33
log
@no md code wants lockmgr locks, so no md code needs to include sys/lock.h

with and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.32 2015/02/11 05:07:25 miod Exp $	*/
d659 1
d691 1
@


1.32
log
@Don't rely in <sys/lock.h> bringing <sys/rwlock.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.31 2015/02/07 03:58:28 deraadt Exp $	*/
a27 1
#include <sys/lock.h>
@


1.31
log
@adapt to resume_randomness() changes
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.30 2014/12/19 14:23:58 deraadt Exp $	*/
d30 1
@


1.30
log
@oops, forgot rndvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.29 2014/12/18 20:01:33 deraadt Exp $	*/
d693 1
a693 1
	resume_randomness();		/* force RNG upper level reseed */
@


1.29
log
@use suspend_randomness() and resume_randomness()
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.28 2014/09/20 09:28:24 kettenis Exp $	*/
d30 1
@


1.28
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.27 2014/07/08 17:19:25 deraadt Exp $	*/
d660 2
d692 1
@


1.27
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.26 2014/03/31 12:11:42 mpi Exp $	*/
d574 1
a574 1
	config_suspend(device_mainbus(), DVACT_QUIESCE);
a646 1
	struct device *mainbus = device_mainbus();
d658 1
a658 1
	config_suspend(mainbus, DVACT_SUSPEND);
d665 1
a665 1
	config_suspend(mainbus, DVACT_POWERDOWN);
d687 1
a687 1
	config_suspend(mainbus, DVACT_RESUME);
d692 1
a692 1
	config_suspend(mainbus, DVACT_WAKEUP);
@


1.26
log
@Change the order of operations during a suspend/resume cycle and
call bufq_quiesce() after executing the DVACT_QUIESCE handlers.

This should be safe since no disk nor controller drivers have such
handler but it will allow us to detach sd(4) devices attached to a
USB bus.

Another benefit pointed out by kettenis@@ is that drivers that need
to read a firmware from the disk should be able to do it at resume
time in a DVACT_WAKEUP handler.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.25 2014/03/13 03:52:56 dlg Exp $	*/
d27 2
@


1.25
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.24 2013/12/06 21:03:05 deraadt Exp $	*/
d572 1
a573 1
	config_suspend(device_mainbus(), DVACT_QUIESCE);
@


1.24
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.23 2013/05/30 16:15:01 deraadt Exp $	*/
d573 1
a573 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_QUIESCE);
d645 1
d657 1
a657 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND);
d664 1
a664 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
d686 1
a686 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_RESUME);
d691 1
a691 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_WAKEUP);
@


1.23
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.22 2012/10/17 22:49:27 deraadt Exp $	*/
d689 3
@


1.22
log
@Document the 'boothowto hack' used to flag to (a few) DVACT_POWERDOWN
handlers how hard they should hit the hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.22 2012/10/17 22:43:50 deraadt Exp $	*/
d65 1
d68 2
a69 1
        sizeof (struct zapm_softc), apm_match, apm_attach
a135 3
#if 0
void	zapm_shutdown(void *);
#endif
a199 4
#if 0
	(void)shutdownhook_establish(zapm_shutdown, NULL);
#endif

d204 2
a205 3
#if 0
void
zapm_shutdown(void *v)
d207 8
a214 1
	struct zapm_softc *sc = v;
d216 1
a216 1
	zapm_enable_charging(sc, 0);
a217 1
#endif
@


1.21
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.20 2010/09/07 16:21:41 deraadt Exp $	*/
d658 4
@


1.20
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.19 2010/08/31 17:13:46 deraadt Exp $	*/
d27 1
d657 4
@


1.19
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.18 2010/08/30 21:37:53 deraadt Exp $	*/
d564 1
a564 1
 * Called before suspending when all powerhooks are done.
d591 1
a591 1
 * before any powerhooks are done.
@


1.18
log
@Hurray!  Zaurus apm can now call the activate functions intead of powerhooks.
We call the activate functions at splhigh; unfortunately we cannot suspend a
zaurus at splhigh because on resume the clock is hosed.  We accept this bug
for now... perhaps someone can find it?
(The powerhooks remain in place in the drivers, and will be roto-tilled once
we all the other powerhook-using architectures have switched over)
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.17 2010/08/29 02:02:26 deraadt Exp $	*/
d572 1
@


1.17
log
@put the bufq_restart() in the right place, so that a 2nd resume works.
how did noone notice for so long?  tsk, tsk, tsk.  of course, I broke it.
tested by jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.16 2010/07/20 12:23:02 deraadt Exp $	*/
d644 1
d653 2
a654 1
	dopowerhooks(PWR_SUSPEND);
d670 1
a670 2
	}
	while (!zapm_resume(sc));
d675 2
a676 1
	dopowerhooks(PWR_RESUME);
d678 1
@


1.16
log
@also use bufq_quiesce() when suspending, and bufq_restart() when resuming,
which will result in more stable filesystems during suspend
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.15 2010/04/21 03:11:30 deraadt Exp $	*/
a636 1
	bufq_restart();
@


1.15
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.14 2010/03/30 17:40:55 oga Exp $	*/
d25 1
d571 2
d637 1
@


1.14
log
@Prevent the apmd/x races for good.

When we hit suspend time, go through all wsdisplays on the system. if
they are in mode MAPPED, but not MODE_DUMBFB then if possible do a full
vt switch to a !mapped vt, and prevent switching back until resume time.
This has to be called from MD code because this involves userland
running so that X can run the vt switch signal handler. This way, any
case where we are using the "poke registers from userland" model, we
will not be on the hardware when we go down, so the kernel can actually
handle thing properly.

Tested on several acpi laptops (by kettenis@@ and ian@@), x40 (me and
beck@@ at LEAST) and zaurus (me). Maybe others, but if so I forgot who at
this time..

Idea from deraadt somewhere over the Faroe Islands (I thought of a
similar thing myself a while ago). Much prompting from him. Ok and
comments miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.13 2006/12/12 23:14:28 dim Exp $	*/
d24 1
@


1.13
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.12 2005/12/22 00:38:48 deraadt Exp $	*/
d37 4
d644 4
d671 4
@


1.12
log
@last change by me was wrong; do not setperf 2x on wakeup
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.10 2005/10/31 05:23:33 deraadt Exp $	*/
d150 1
a150 1
int	pxa2x0_setperf(int);
@


1.11
log
@upon wakeup, take us back to the speed we were at; ok drahn
@
text
@a587 1
	extern int perflevel;
a627 4

	/* restore hw.setperf */
	if (cpu_setperf != NULL)
		cpu_setperf(perflevel);
@


1.10
log
@show the speed status in hw.cpuspeed; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.8 2005/05/27 05:14:41 uwe Exp $	*/
d588 1
d629 4
@


1.9
log
@On suspend/resume save the current time to the RTC earlier and restore it later
so that the very long delay operations do not slow the clock unnecessarily.
Add early support for hw.setperf and hw.cpuspeed for zaurus, it appears
to be able to run at 91MHz and 209MHz as well as the std 416MHz with this
change. Hopefully it is doing the speed changes correctly.
@
text
@d151 1
d199 1
@


1.8
log
@oops! printf -> DPRINTF
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.7 2005/05/27 05:09:42 uwe Exp $	*/
d24 1
d150 1
d196 2
@


1.7
log
@- raise the "critical" battery level a bit to suspend earlier
- stop charging if the battery compartment is unlocked
- control charging while suspended in zapm_poll(), too
- avoid panic when rebooting before the driver is attached
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.6 2005/04/13 05:49:57 uwe Exp $	*/
d451 1
a451 1
			printf("zapm_poll: suspended %lu %lu\n",
d453 1
a453 1
			    pxa2x0_rtc_getsecs());
d494 1
a494 1
		printf("zapm_poll: power event %d\n", sc->sc_event);
@


1.6
log
@Resume only if the lid is open and the power key pressed.  Also fix
peridic discharging in zapm_poll().
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.5 2005/04/11 03:21:03 uwe Exp $	*/
d26 1
d79 1
a79 1
#define GPIO_BATT_COVER_C3000	90	/* ?=open */
d104 1
a104 1
	{176,	5,	APM_BATT_LOW},
d128 1
d130 1
a130 1
#endif
d166 4
a169 4
#if 0
	(void)pxa2x0_gpio_intr_establish(GPIO_AC_IN_C3000, IST_EDGE_BOTH,
	    IPL_BIO, zapm_acintr, sc, "apm_ac");
#endif
d204 1
d209 8
a218 1
#endif
d389 4
d397 5
a401 4
	int	ac_on = sc->sc_ac_on;
	int	charging = sc->sc_charging;
	int	volt = sc->sc_batt_volt;
	int	s;
d405 4
d413 1
a413 2
		charging = ac_on && sc->sc_batt_full < MIN_BATT_FULL;
		zapm_enable_charging(sc, charging);
d415 1
a415 1
	} else
d417 3
d421 2
a422 1
	if (ac_on) {
d435 27
a461 3
		
		if (!sc->sc_suspended && sc->sc_batt_full == 0 &&
		    ratecheck(&sc->sc_lastbattchk, &zapm_battchkrate)) {
d468 1
a468 10
		}
	} else {
		if (sc->sc_ac_on) {
			sc->sc_batt_full = 0;
			charging = 0;
			zapm_enable_charging(sc, 0);
			timerclear(&sc->sc_lastbattchk);
			DPRINTF(("zapm_poll: stop charging\n"));
		} else if (!sc->sc_suspended &&
		    ratecheck(&sc->sc_lastbattchk, &zapm_battchkrate)) {
a471 3

		if (zapm_batt_state(volt) == APM_BATT_CRITICAL)
			sc->sc_event = APM_CRIT_SUSPEND_REQ;
d474 1
d484 8
d559 1
d562 4
d568 3
a570 6
	if (sc->sc_charging) {
		zapm_enable_charging(sc, 0);
		delay(15000);
		zapm_enable_charging(sc, 1);
	}

d609 3
a611 1
	if (wakeup)
d614 9
d667 14
a680 14
	struct pxa2x0_apm_softc *sc;
	int rv;

	KASSERT(apm_cd.cd_ndevs > 0 && apm_cd.cd_devs[0] != NULL);
	sc = apm_cd.cd_devs[0];

	/*
	 * Reduce the ROM Delay Next Access and ROM Delay First Access times
	 * for synchronous flash connected to nCS1.
	 */
	rv = bus_space_read_4(sc->sc_iot, sc->sc_memctl_ioh, MEMCTL_MSC0);
        if ((rv & 0xffff0000) == 0x7ff00000)
		bus_space_write_4(sc->sc_iot, sc->sc_memctl_ioh,
		    MEMCTL_MSC0, (rv & 0xffff) | 0x7ee00000);
@


1.5
log
@- generate power change and battery low events
- GPIO reset moved here, because it's machine-specific
- power-off by suspending and then resetting (best thing the C3000 can do)
- roll our own softc instead of using tons of globals
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.4 2005/03/30 21:44:08 uwe Exp $	*/
d31 1
d45 1
d145 2
d169 1
d172 2
d412 4
a415 2
		} else if (ratecheck(&sc->sc_lastbattchk, &zapm_battchkrate)
		    && !zapm_charge_complete(sc)) {
d430 2
a431 1
		} else if (ratecheck(&sc->sc_lastbattchk, &zapm_battchkrate)) {
d508 62
d578 2
a579 1
#if 0
a587 2
	pxa2x0_wakeup_config(PXA2X0_WAKEUP_ALL, 1);

a588 1
#endif
d590 1
a590 1
	dopowerhooks(PWR_SUSPEND);
d592 4
a595 2
	/* Turn off the status LED to avoid blinking before restart. */
	scoop_led_set(SCOOP_LED_GREEN, 0);
a596 1
	pxa2x0_apm_sleep(sc);
@


1.4
log
@- Enable charging properly, avoiding the stuck "battery full" signal.
- Correctly report battery life estimates falling between thresholds.
- Restart charging every minute (needed on all zaurus machines).
- Report battery life even while battery_state is APM_BATT_CHARGING.
- Be pessimistic about the total battery life time in minutes.
- Use shorter prefix for local symbol names.
The timeouts introduced in this revision can be removed later.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.3 2005/03/13 05:13:15 uwe Exp $	*/
d32 2
d40 12
d56 1
a56 1
        sizeof (struct pxa2x0_apm_softc), apm_match, apm_attach
d58 1
d74 7
a80 3
#define GPIO_AC_IN_C3000	115	/* active low */
#define GPIO_CHRG_FULL_C3000	101
#define GPIO_BATT_COVER_C3000	90	/* active low */
d89 1
a89 1
	int	bi_minutes;	/* minutes left at 100% battery life */
d95 1
a95 1
	{224,	125,	APM_BATT_HIGH},	/* XXX untested */
d112 11
d138 5
a142 1
int	zapm_batt_full(void);
a143 16
int	zapm_curbattvolt;	/* updated periodically when A/C is on */
int	zapm_battcharging;
int	zapm_battfullcount;

struct timeout zapm_charge_off_to;
struct timeout zapm_charge_on_to;

void	zapm_charge_enable(void);
void	zapm_charge_disable(void);
void	zapm_charge_restart(void);
void	zapm_charge_off(void *);
void	zapm_charge_on(void *);

void	zapm_power_check(struct pxa2x0_apm_softc *);
void	zapm_power_info(struct pxa2x0_apm_softc *,
    struct apm_power_info *);
d148 1
a148 1
	return 1;
d154 1
a154 1
	struct pxa2x0_apm_softc *sc = (struct pxa2x0_apm_softc *)self;
d157 1
a157 1
	pxa2x0_gpio_set_function(GPIO_CHRG_FULL_C3000, GPIO_IN);
d165 2
a166 5
	sc->sc_periodic_check = zapm_power_check;
	sc->sc_power_info = zapm_power_info;

	timeout_set(&zapm_charge_off_to, &zapm_charge_off, NULL);
	timeout_set(&zapm_charge_on_to, &zapm_charge_on, NULL);
d168 1
a168 3
	zapm_charge_disable();
	zapm_battcharging = 0;
	zapm_battfullcount = 0;
d170 2
a171 1
	/* C3000: discharge 100 ms when AC is on. */
d173 1
d177 1
a177 2

	zapm_curbattvolt = zapm_batt_volt();
d180 1
a180 3
	zapm_power_check(sc);

	pxa2x0_apm_attach_sub(sc);
d191 3
a193 1
	zapm_charge_disable();
d199 1
a199 1
	return 1;
d213 3
a215 3
	return (zssp_read_max1111(MAXCTRL_PD0 | MAXCTRL_PD1 |
	    MAXCTRL_SGL | MAXCTRL_UNI | (chan << MAXCTRL_SEL_SHIFT) |
	    MAXCTRL_STR));
a334 11
/*
 * Return non-zero if the charge complete signal is set.  This signal
 * becomes valid after charging has been stopped and restarted.
 */
int
zapm_batt_full(void)
{

	return (pxa2x0_gpio_get_bit(GPIO_CHRG_FULL_C3000) ? 1 : 0);
}

d336 1
a336 1
zapm_charge_enable(void)
a338 4
	timeout_del(&zapm_charge_off_to);
	timeout_del(&zapm_charge_on_to);

	scoop_charge_battery(1, 0);
d340 2
a341 4
	scoop_led_set(SCOOP_LED_ORANGE, 1);

	/* Restart charging and updating curbattvolt. */
	timeout_add(&zapm_charge_off_to, hz * 60);
d344 6
a349 2
void
zapm_charge_disable(void)
d352 16
a367 2
	timeout_del(&zapm_charge_off_to);
	timeout_del(&zapm_charge_on_to);
d369 1
a369 3
	scoop_discharge_battery(0);
	scoop_charge_battery(0, 0);
	scoop_led_set(SCOOP_LED_ORANGE, 0);
d373 1
a373 1
zapm_charge_restart(void)
d375 5
d381 1
a381 4
	zapm_charge_disable();
	delay(15000);
	zapm_charge_enable();
}
d383 42
a424 3
void
zapm_charge_off(void *v)
{
d426 2
a427 7
	if (zapm_battcharging)
		zapm_charge_disable();

	/* Discharge 100 ms before updating curbattvolt. */
	if (zapm_ac_on()) {
		scoop_discharge_battery(1);
		timeout_add(&zapm_charge_on_to, hz / 10);
a428 1
}
d430 7
a436 14
void
zapm_charge_on(void *v)
{

	/*
	 * Read battery voltage while the battery is still discharging,
	 * then restart charging or schedule the next curbattvolt update.
	 */
	if (zapm_ac_on()) {
		zapm_curbattvolt = zapm_batt_volt();
		if (zapm_battcharging)
			zapm_charge_enable();
		else
			timeout_add(&zapm_charge_off_to, hz * 60);
d439 5
a443 1
	scoop_discharge_battery(0);
d447 1
a447 2
 * Check A/C power and control battery charging.  This gets called once
 * from apm_attach(), and once per second from the APM kernel thread.
d449 2
a450 2
void
zapm_power_check(struct pxa2x0_apm_softc *sc)
d452 1
d457 6
a462 36
	if (zapm_ac_on()) {
		if (zapm_battcharging) {
			/*
			 * Read BATT_FULL once per second until it
			 * stablizes; restart charging between reads.
			 */
			if (zapm_batt_full()) {
				if (++zapm_battfullcount >= 2) {
					/* battery full; stop charging. */
					DPRINTF(("zapm_power_check: battery full\n"));
					zapm_battcharging = 0;
					zapm_charge_disable();
					zapm_charge_off(NULL);
				} else
					zapm_charge_restart();
			} else if (zapm_battfullcount > 0) {
				/* Ignore BATT_FULL glitch. */
				DPRINTF(("zapm_power_check: battery almost full?\n"));
				zapm_battfullcount = 0;
				zapm_charge_restart();
			}
		} else if (zapm_battfullcount == 0) {
			/* Start charging and updating curbattvolt. */
			DPRINTF(("zapm_power_check: start charging\n"));
			zapm_battcharging = 1;
			zapm_charge_off(NULL);
		}
	} else if (zapm_battcharging || zapm_battfullcount != 0) {
		/* Stop charging and updating curbattvolt. */
		DPRINTF(("zapm_power_check: stop charging\n"));
		zapm_battcharging = 0;
		zapm_battfullcount = 0;
		zapm_charge_disable();
	} else {
		/* Running on battery. */
		/* XXX detect battery low condition and take measures. */
d464 1
d467 1
d471 1
a471 1
 * Report A/C and battery state in response to a request from apmd.
d474 1
a474 2
zapm_power_info(struct pxa2x0_apm_softc *sc,
    struct apm_power_info *power)
d476 1
d478 1
d483 3
a485 2
	volt = zapm_curbattvolt;
	charging = zapm_battcharging;
d488 1
a488 4
	power->ac_state = zapm_ac_on() ? APM_AC_ON : APM_AC_OFF;
	if (power->ac_state == APM_AC_OFF)
		volt = zapm_batt_volt();

d496 62
@


1.3
log
@Read the battery voltage once and pass that value around.  This fixes a
possible contradiction in the battery life estimates returned by apm(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.2 2005/03/11 00:18:17 uwe Exp $	*/
d21 2
d32 6
a62 15
/* battery state */
#define BATT_RESET		0
#define BATT_ABSENT		1
#define BATT_NOT_CHARGING	2
#define BATT_CHARGING		3
#define BATT_FULL		4

#ifdef APMDEBUG
const	char *zaurus_batt_state_names[5] = {
	"reset", "absent", "not charging", "charging", "full"
};
#endif

int	zaurus_batt_state = BATT_RESET;

d87 1
a87 1
	360 /* minutes */,
d94 2
a95 1
void	zaurus_shutdownhook(void *);
d97 1
d101 2
a102 2
int	zaurus_jkvad_voltage(void);
int	zaurus_battery_temp(void);
d104 21
a124 9
int	zaurus_battery_voltage(void);
int	zaurus_battery_state(int);
int	zaurus_battery_life(int);
int	zaurus_minutes_left(int);
int	zaurus_ac_present(void);
int	zaurus_charge_complete(void);
void	zaurus_charge_control(int);
void	zaurus_power_check(struct pxa2x0_apm_softc *);
void	zaurus_power_info(struct pxa2x0_apm_softc *,
d144 1
a144 1
	    IPL_BIO, apm_intr, sc, "apm_ac");
d147 2
a148 2
	sc->sc_periodic_check = zaurus_power_check;
	sc->sc_power_info = zaurus_power_info;
d150 17
a166 2
	/* Initialize the battery status before APM is enabled. */
	zaurus_power_check(sc);
d171 1
a171 1
	(void)shutdownhook_establish(zaurus_shutdownhook, NULL);
d177 1
a177 1
zaurus_shutdownhook(void *v)
d179 7
a185 2
	/* XXX */
	zaurus_charge_control(BATT_NOT_CHARGING);
d190 6
d199 1
a199 1
	return zssp_read_max1111(MAXCTRL_PD0 | MAXCTRL_PD1 |
d201 1
a201 1
	    MAXCTRL_STR);
d251 1
a251 1
zaurus_jkvad_voltage(void)
d254 1
a254 1
	return max1111_adc_value_avg(JK_VAD, 10);
d258 1
a258 1
zaurus_battery_temp(void)
d267 1
a267 1
	return temp;
d272 1
a272 1
zaurus_battery_voltage(void)
d275 1
a275 1
	return max1111_adc_value_avg(BATT_AD, 10);
d279 1
a279 1
zaurus_battery_state(int volt)
d294 1
a294 1
zaurus_battery_life(int volt)
d309 1
a309 1
	    ((bthr[i-1].bt_volt - volt) * 100) /
d315 1
a315 1
zaurus_minutes_left(int life)
d321 4
d326 23
a348 1
zaurus_ac_present(void)
d351 6
a356 1
	return !pxa2x0_gpio_get_bit(GPIO_AC_IN_C3000);
d359 11
a369 6
/*
 * Return non-zero if the charge complete signal is set.  This signal
 * is valid only after charging is restarted.
 */
int
zaurus_charge_complete(void)
d372 8
a379 1
	return pxa2x0_gpio_get_bit(GPIO_CHRG_FULL_C3000);
d383 1
a383 1
zaurus_charge_control(int state)
d386 10
a395 17
	switch (state) {
	case BATT_RESET:
	case BATT_ABSENT:
	case BATT_NOT_CHARGING:
	case BATT_FULL:
		scoop_charge_battery(0, 0);
		scoop_led_set(SCOOP_LED_ORANGE, 0);
		/* Always force a 15 ms delay before charging again. */
		delay(15000);
		break;
	case BATT_CHARGING:
		scoop_charge_battery(1, 0);
		scoop_led_set(SCOOP_LED_ORANGE, 1);
		break;
	default:
		printf("zaurus_charge_control: bad state %d\n", state);
		break;
d397 2
d406 1
a406 1
zaurus_power_check(struct pxa2x0_apm_softc *sc)
d408 3
a410 1
	int state = zaurus_batt_state;
d412 36
a447 27
	switch (state) {
	case BATT_RESET:
		zaurus_charge_control(state);
		/* FALLTHROUGH */
	case BATT_ABSENT:
		state = BATT_NOT_CHARGING;
		/* FALLTHROUGH */
	case BATT_NOT_CHARGING:
		if (zaurus_ac_present())
			state = BATT_CHARGING;
		break;

	case BATT_CHARGING:
		if (!zaurus_ac_present())
			state = BATT_NOT_CHARGING;
		else if (zaurus_charge_complete())
			state = BATT_FULL;
		break;

	case BATT_FULL:
		if (!zaurus_ac_present())
			state = BATT_NOT_CHARGING;
		break;

	default:
		printf("zaurus_power_check: bad state %d\n", state);
		break;
d450 1
a450 11
	if (zaurus_batt_state != state) {
#ifdef APMDEBUG
		printf("%s: battery state %s -> %s volt %d\n",
		    sc->sc_dev.dv_xname,
		    zaurus_batt_state_names[zaurus_batt_state],
		    zaurus_batt_state_names[state],
		    zaurus_battery_voltage());
#endif
		zaurus_charge_control(state);
		zaurus_batt_state = state;
	}
d457 1
a457 1
zaurus_power_info(struct pxa2x0_apm_softc *sc,
d460 1
d462 10
d473 1
a473 2
	if (zaurus_batt_state == BATT_CHARGING) {
		power->ac_state = APM_AC_ON;
d475 5
a479 11
		power->battery_life = 100;
		power->minutes_left = zaurus_main_battery->bi_minutes;
	} else {
		power->ac_state = zaurus_ac_present() ? APM_AC_ON :
		    APM_AC_OFF;
		volt = zaurus_battery_voltage();
		power->battery_state = zaurus_battery_state(volt);
		power->battery_life = zaurus_battery_life(volt);
		power->minutes_left =
		    zaurus_minutes_left(power->battery_life);
	}
@


1.2
log
@- apm(8) can now report the estimated number of minutes left.
- Use linear interpolation between thresholds to get better life estimates.
- Minor changes in control flow, and renamed some constants.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.1 2005/01/26 06:34:54 uwe Exp $	*/
d110 3
a112 3
int	zaurus_battery_life(void);
int	zaurus_battery_state(void);
int	zaurus_minutes_left(void);
d246 1
a246 1
zaurus_battery_state(void)
a248 1
	int volt;
a251 1
	volt = zaurus_battery_voltage();
d261 1
a261 1
zaurus_battery_life(void)
a263 1
	int volt;
a266 1
	volt = zaurus_battery_voltage();
d282 1
a282 1
zaurus_minutes_left(void)
a283 1
	int life;
a284 1
	life = zaurus_battery_life();
d388 1
d398 5
a402 3
		power->battery_state = zaurus_battery_state();
		power->battery_life = zaurus_battery_life();
		power->minutes_left = zaurus_minutes_left();
@


1.1
log
@New device for the dedicated SSP unit, automatic battery charging, and
reporting the remaining battery life to apmd(8).
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_apm.c,v 1.1 2005/01/20 23:34:37 uwe Exp $	*/
d50 1
a50 1
/* Battery-related GPIO pins */
d55 6
a60 6
/* Internal software power states */
#define PS_UNKNOWN		0
#define PS_BATT_ABSENT		1
#define PS_NOT_CHARGING		2
#define PS_CHARGING		3
#define PS_BATT_FULL		4
d63 2
a64 2
const	char *zaurus_power_state_names[5] = {
	"unknown", "absent", "not charging", "charging", "full"
d68 1
a68 1
int	zaurus_power_state = PS_UNKNOWN;
d70 4
a73 4
struct battery_voltage_threshold {
	int	voltage;
	int	life;
	int	state;
d76 9
a84 1
struct battery_voltage_threshold zaurus_battery_c3000[] = {
d93 6
a98 2
struct battery_voltage_threshold *zaurus_main_battery =
    zaurus_battery_c3000;
d100 3
d112 1
d147 4
d153 9
d246 1
a246 1
zaurus_battery_life(void)
d248 2
a250 1
	int voltage;
d252 2
a253 1
	voltage = zaurus_battery_voltage();
d255 2
a256 2
	for (i = 0; zaurus_main_battery[i].voltage > 0; i++) {
		if (voltage >= zaurus_main_battery[i].voltage)
a257 1
	}
d259 1
a259 1
	return zaurus_main_battery[i].life;
d263 1
a263 1
zaurus_battery_state(void)
d265 2
a267 1
	int voltage;
d269 2
a270 1
	voltage = zaurus_battery_voltage();
d272 2
a273 2
	for (i = 0; zaurus_main_battery[i].voltage > 0; i++) {
		if (voltage >= zaurus_main_battery[i].voltage)
a274 1
	}
d276 16
a291 1
	return zaurus_main_battery[i].state;
d317 4
a320 6
	case PS_CHARGING:
		scoop_charge_battery(1, 0);
		scoop_led_set(SCOOP_LED_ORANGE, 1);
		break;
	case PS_NOT_CHARGING:
	case PS_BATT_FULL:
d326 4
a333 2

	zaurus_power_state = state;
d343 1
a343 1
	int state = zaurus_power_state;
d346 1
a346 3
	case PS_UNKNOWN:
	case PS_BATT_ABSENT:
		state = PS_NOT_CHARGING;
d349 4
a352 2

	case PS_NOT_CHARGING:
d354 1
a354 1
			state = PS_CHARGING;
d357 1
a357 1
	case PS_CHARGING:
d359 1
a359 1
			state = PS_NOT_CHARGING;
d361 1
a361 1
			state = PS_BATT_FULL;
d364 1
a364 1
	case PS_BATT_FULL:
d366 1
a366 1
			state = PS_NOT_CHARGING;
d374 1
a374 1
	if (state != zaurus_power_state) {
d376 4
a379 3
		printf("zaurus_power_check: battery state %s -> %s volt %d\n",
		    zaurus_power_state_names[zaurus_power_state],
		    zaurus_power_state_names[state],
d383 1
d395 1
a395 1
	if (zaurus_power_state == PS_CHARGING) {
d399 1
d405 1
@

