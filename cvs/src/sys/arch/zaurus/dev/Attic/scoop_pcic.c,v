head	1.6;
access;
symbols
	OPENBSD_6_0:1.5.0.10
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.6
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.3.0.22
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.18
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.16
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.14
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.12
	OPENBSD_5_0:1.3.0.10
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.8
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.0.14
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.12
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.10
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.8
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.6
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2016.09.03.13.37.43;	author guenther;	state dead;
branches;
next	1.5;
commitid	6T3r4QcMFKe3Fo5T;

1.5
date	2014.05.08.21.17.01;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.03.10.17.34;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.25.14.55.44;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.01.23.51.55;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Retire zaurus, as it hasn't made the EABI jump and will be permanently broken
shortly when we use the hardware thread register in userland
@
text
@/*	$OpenBSD: scoop_pcic.c,v 1.5 2014/05/08 21:17:01 miod Exp $	*/

/*
 * Copyright (c) 2005 Uwe Stuehler <uwe@@bsdx.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <arch/arm/xscale/pxa2x0var.h>
#include <arch/arm/xscale/pxapcicvar.h>

#include <machine/machine_reg.h>
#include <machine/zaurus_var.h>

#include <zaurus/dev/zaurus_scoopreg.h>

int	scoop_pcic_match(struct device *, void *, void *);
void	scoop_pcic_attach(struct device *, struct device *, void *);
void	scoop_pcic_socket_setup(struct pxapcic_socket *);

struct cfattach pxapcic_scoop_ca = {
	sizeof(struct pxapcic_softc), scoop_pcic_match,
	scoop_pcic_attach
};

u_int	scoop_pcic_read(struct pxapcic_socket *, int);
void	scoop_pcic_write(struct pxapcic_socket *, int, u_int);
void	scoop_pcic_set_power(struct pxapcic_socket *, int);
void	scoop_pcic_clear_intr(struct pxapcic_socket *);

struct pxapcic_tag scoop_pcic_functions = {
	scoop_pcic_read,
	scoop_pcic_write,
	scoop_pcic_set_power,
	scoop_pcic_clear_intr,
	0,			/* intr_establish */
	0,			/* intr_disestablish */
	0			/* intr_string */
};

int
scoop_pcic_match(struct device *parent, void *cf, void *aux)
{
	return (ZAURUS_ISC860 || ZAURUS_ISC3000);
}

void
scoop_pcic_attach(struct device *parent, struct device *self, void *aux)
{
	struct pxapcic_softc *sc = (struct pxapcic_softc *)self;
	struct pxaip_attach_args *pxa = aux;

	sc->sc_iot = pxa->pxa_iot;

	if (ZAURUS_ISC860) {
		sc->sc_nslots = 1;
		sc->sc_irqpin[0] = C860_CF0_IRQ;
		sc->sc_irqcfpin[0] = C860_CF0_IRQ_PIN;
	} else if (ZAURUS_ISC3000) {
		sc->sc_nslots = 2;
		sc->sc_irqpin[0] = C3000_CF0_IRQ;
		sc->sc_irqcfpin[0] = C3000_CF0_IRQ_PIN;
		sc->sc_irqpin[1] = C3000_CF1_IRQ;
		sc->sc_irqcfpin[1] = C3000_CF1_IRQ_PIN;
	}

	pxapcic_attach(sc, &scoop_pcic_socket_setup);
}

void
scoop_pcic_socket_setup(struct pxapcic_socket *so)
{
	struct pxapcic_softc *sc;
	bus_addr_t pa;
	bus_size_t size = SCOOP_SIZE;
	bus_space_tag_t iot;
	bus_space_handle_t scooph;
	int error;

	sc = so->sc;
	iot = sc->sc_iot;

	if (so->socket == 0)
		pa = C3000_SCOOP0_BASE;
	else if (so->socket == 1)
		pa = C3000_SCOOP1_BASE;
	else
		panic("%s: invalid CF slot %d", sc->sc_dev.dv_xname,
		    so->socket);
	error = bus_space_map(iot, trunc_page(pa), round_page(size),
	    0, &scooph);
	if (error)
		panic("%s: can't map memory %lx for scoop",
		    sc->sc_dev.dv_xname, pa);
	scooph += pa - trunc_page(pa);
	
	bus_space_write_2(iot, scooph, SCOOP_IMR,
	    SCP_IMR_UNKN0 | SCP_IMR_UNKN1);
	
	/* setup */
	bus_space_write_2(iot, scooph, SCOOP_MCR, 0x0100);
	bus_space_write_2(iot, scooph, SCOOP_CDR, 0x0000);
	bus_space_write_2(iot, scooph, SCOOP_CPR, 0x0000);
	bus_space_write_2(iot, scooph, SCOOP_IMR, 0x0000);
	bus_space_write_2(iot, scooph, SCOOP_IRM, 0x00ff);
	bus_space_write_2(iot, scooph, SCOOP_ISR, 0x0000);
	bus_space_write_2(iot, scooph, SCOOP_IRM, 0x0000);
	
	/* C3000 */
	if (so->socket == 1) {
		bus_space_write_2(iot, scooph, SCOOP_CPR, 0x80c1);
		bus_space_write_2(iot, scooph, SCOOP_IMR, 0x00c4);
		bus_space_write_2(iot, scooph, SCOOP_MCR, 0x0111);
	} else {
		bus_space_write_2(iot, scooph, SCOOP_CPR,
		    SCP_CPR_PWR|SCP_CPR_5V);
	}

	bus_space_write_2(iot, scooph, SCOOP_IMR, 0x00ce);
	bus_space_write_2(iot, scooph, SCOOP_MCR, 0x0111);

	/* C3000 */
	so->power_capability = PXAPCIC_POWER_3V;
	if (so->socket == 0)
		so->power_capability |= PXAPCIC_POWER_5V;

	so->pcictag_cookie = (void *)scooph;
	so->pcictag = &scoop_pcic_functions;
}

u_int
scoop_pcic_read(struct pxapcic_socket *so, int reg)
{
	bus_space_tag_t iot = so->sc->sc_iot;
	bus_space_handle_t ioh = (bus_space_handle_t)so->pcictag_cookie;
	u_int16_t csr;

	csr = bus_space_read_2(iot, ioh, SCOOP_CSR);

	switch (reg) {
	case PXAPCIC_CARD_STATUS:
		if (csr & SCP_CSR_MISSING)
			return (PXAPCIC_CARD_INVALID);
		else
			return (PXAPCIC_CARD_VALID);

	case PXAPCIC_CARD_READY:
		return ((bus_space_read_2(iot, ioh, SCOOP_CSR) &
		    SCP_CSR_READY) != 0);

	default:
		panic("scoop_pcic_read: bogus register");
	}
}

void
scoop_pcic_write(struct pxapcic_socket *so, int reg, u_int val)
{
	bus_space_tag_t iot = so->sc->sc_iot;
	bus_space_handle_t ioh = (bus_space_handle_t)so->pcictag_cookie;
	u_int16_t newval;
	int s;

	s = splhigh();

	switch (reg) {
	case PXAPCIC_CARD_POWER:
		newval = bus_space_read_2(iot, ioh, SCOOP_CPR);
		newval &= ~(SCP_CPR_PWR | SCP_CPR_3V | SCP_CPR_5V);

		if (val == PXAPCIC_POWER_3V)
			newval |= (SCP_CPR_PWR | SCP_CPR_3V);
		else if (val == PXAPCIC_POWER_5V)
			newval |= (SCP_CPR_PWR | SCP_CPR_5V);

		bus_space_write_2(iot, ioh, SCOOP_CPR, newval);
		break;

	case PXAPCIC_CARD_RESET:
		bus_space_write_2(iot, ioh, SCOOP_CCR,
		    val ? SCP_CCR_RESET : 0);
		break;

	default:
		panic("scoop_pcic_write: bogus register");
	}

	splx(s);
}

void
scoop_pcic_set_power(struct pxapcic_socket *so, int pwr)
{
	bus_space_tag_t iot = so->sc->sc_iot;
	bus_space_handle_t ioh = (bus_space_handle_t)so->pcictag_cookie;
	u_int16_t reg;
	int s;

	s = splhigh();

	switch (pwr) {
	case PXAPCIC_POWER_OFF:
#if 0
		/* XXX does this disable power to both sockets? */
		reg = bus_space_read_2(iot, ioh, SCOOP_GPWR);
		bus_space_write_2(iot, ioh, SCOOP_GPWR,
		    reg & ~(1 << SCOOP0_CF_POWER_C3000));
#endif
		break;

	case PXAPCIC_POWER_3V:
	case PXAPCIC_POWER_5V:
		/* XXX */
		if (so->socket == 0) {
			reg = bus_space_read_2(iot, ioh, SCOOP_GPWR);
			bus_space_write_2(iot, ioh, SCOOP_GPWR,
			    reg | (1 << SCOOP0_CF_POWER_C3000));
		}
		break;

	default:
		splx(s);
		panic("scoop_pcic_set_power: bogus power state");
	}

	splx(s);
}

void
scoop_pcic_clear_intr(struct pxapcic_socket *so)
{
	bus_space_tag_t iot = so->sc->sc_iot;
	bus_space_handle_t ioh = (bus_space_handle_t)so->pcictag_cookie;

	bus_space_write_2(iot, ioh, SCOOP_IRM, 0x00ff);
	bus_space_write_2(iot, ioh, SCOOP_ISR, 0x0000);
	bus_space_write_2(iot, ioh, SCOOP_IRM, 0x0000);
}
@


1.5
log
@Format string fixes and removal of -Wno-format for arm kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: scoop_pcic.c,v 1.4 2014/04/03 10:17:34 mpi Exp $	*/
@


1.4
log
@More uvm_extern.h cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: scoop_pcic.c,v 1.3 2009/03/29 21:53:52 sthen Exp $	*/
d108 1
a108 1
		panic("%s: can't map memory %x for scoop",
@


1.3
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: scoop_pcic.c,v 1.2 2008/11/25 14:55:44 drahn Exp $	*/
d21 2
a22 1
#include <uvm/uvm.h>
@


1.2
log
@rename zaurus_reg.h to machine_reg and rename some of the internal fields
so that arm/xscale/... is not referring to zaurus specific defines.
ok miod kevlo, with some suggested changes from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scoop_pcic.c,v 1.1 2005/07/01 23:51:55 uwe Exp $	*/
d107 1
a107 1
		panic("%s: failed to map memory %x for scoop",
@


1.1
log
@Move all zaurus specific code from pxa2x0_pcic.c into scoop_pcic.c
without affecting the way the driver works.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
#include <machine/zaurus_reg.h>
@

