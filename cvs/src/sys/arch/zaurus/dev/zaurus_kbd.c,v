head	1.36;
access;
symbols
	OPENBSD_6_0:1.36.0.10
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.6
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.8
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.8
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.6
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.4
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.29.0.12
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.8
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.8
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.6
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20;
locks; strict;
comment	@ * @;


1.36
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.35;
commitid	zJyOCNTjgsYVGLiw;

1.35
date	2014.07.11.07.47.22;	author guenther;	state Exp;
branches;
next	1.34;
commitid	724MD8pLYVjrlYoe;

1.34
date	2014.01.26.17.48.08;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2011.11.09.14.22.37;	author shadchin;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.07.16.21.41;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.30.21.35.57;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.21.20.36.03;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.20.18.53.09;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.20.04.28.19;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.11.18.17.40;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.11.16.58.46;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.25.07.29.17;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.24.20.32.43;	author uwe;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.29.20.10.14;	author uwe;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.16.21.26.49;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.15.23.48.40;	author uwe;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.15.16.05.17;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.15.00.34.25;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.23.02.19.32;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.22.22.12.10;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.22.21.53.03;	author uwe;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.22.18.13.28;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.30.21.55.50;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.28.14.47.31;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.18.17.57.13;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.18.01.03.15;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.17.18.23.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.15.17.51.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.15.05.58.53;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.14.18.42.31;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.14.16.39.15;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.14.04.35.22;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.13.23.33.37;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.13.20.47.57;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.36
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@/* $OpenBSD: zaurus_kbd.c,v 1.35 2014/07/11 07:47:22 guenther Exp $ */
/*
 * Copyright (c) 2005 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/signalvar.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0_gpio.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>

#include <zaurus/dev/zaurus_kbdmap.h>

#include "apm.h"

const int
gpio_sense_pins_c3000[] = {
	12,
	17,
	91,
	34,
	36,
	38,
	39,
	-1
};

const int
gpio_strobe_pins_c3000[] = {
	88,
	23,
	24,
	25,
	26,
	27,
	52,
	103,
	107,
	-1,
	108,
	114
};

const int stuck_keys[] = {
	7,
	15,
	23,
	31
};


#define REP_DELAY1 400
#define REP_DELAYN 100

struct zkbd_softc {
	struct device sc_dev;

	const int *sc_sense_array;
	const int *sc_strobe_array;
	int sc_nsense;
	int sc_nstrobe;

	short sc_onkey_pin;
	short sc_sync_pin;
	short sc_swa_pin;
	short sc_swb_pin;
	char *sc_okeystate;
	char *sc_keystate;
	char sc_hinge;		/* 0=open, 1=nonsense, 2=backwards, 3=closed */
	char sc_maxkbdcol;

	struct timeout sc_roll_to;

	/* console stuff */
	int sc_polling;
	int sc_pollUD;
	int sc_pollkey;

	/* wskbd bits */
	struct device   *sc_wskbddev;
	int sc_rawkbd;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	const char *sc_xt_keymap;
#define MAXKEYS 20
#endif
};

struct zkbd_softc *zkbd_dev; /* XXX */

int zkbd_match(struct device *, void *, void *);
void zkbd_attach(struct device *, struct device *, void *);
int zkbd_activate(struct device *, int);

int zkbd_irq(void *v);
void zkbd_poll(void *v);
int zkbd_on(void *v);
int zkbd_sync(void *v);
int zkbd_hinge(void *v);

int zkbd_modstate;

struct cfattach zkbd_ca = {
	sizeof(struct zkbd_softc), zkbd_match, zkbd_attach, NULL,
	zkbd_activate
};

struct cfdriver zkbd_cd = {
	NULL, "zkbd", DV_DULL
};

int zkbd_enable(void *, int);
void zkbd_set_leds(void *, int);
int zkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);

struct wskbd_accessops zkbd_accessops = {
	zkbd_enable,
	zkbd_set_leds,
	zkbd_ioctl,
};

void zkbd_cngetc(void *, u_int *, int *);
void zkbd_cnpollc(void *, int);
 
struct wskbd_consops zkbd_consops = {
        zkbd_cngetc,
        zkbd_cnpollc,
};              

struct wskbd_mapdata zkbd_keymapdata = {
        zkbd_keydesctab,   
        KB_US | KB_DEFAULT,
};



int
zkbd_match(struct device *parent, void *cf, void *aux)
{
	return 1;
}


void
zkbd_attach(struct device *parent, struct device *self, void *aux)
{
	struct zkbd_softc *sc = (struct zkbd_softc *)self;
	struct wskbddev_attach_args a;
	int pin, i;
	extern int glass_console;

	zkbd_dev = sc;
	sc->sc_polling = 0;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	sc->sc_rawkbd = 0;
#endif
	/* Determine which system we are - XXX */

	if (1 /* C3000 */) {
		sc->sc_sense_array = gpio_sense_pins_c3000;
		sc->sc_strobe_array = gpio_strobe_pins_c3000;
		sc->sc_nsense = sizeof(gpio_sense_pins_c3000)/sizeof(int);
		sc->sc_nstrobe = sizeof(gpio_strobe_pins_c3000)/sizeof(int);
		sc->sc_maxkbdcol = 10;
		sc->sc_onkey_pin = 95;
		sc->sc_sync_pin = 16;
		sc->sc_swa_pin = 97;
		sc->sc_swb_pin = 96;
#ifdef WSDISPLAY_COMPAT_RAWKBD
		sc->sc_xt_keymap = xt_keymap;
#endif
	} /* XXX */

	sc->sc_okeystate = malloc(sc->sc_nsense * sc->sc_nstrobe,
	    M_DEVBUF, M_NOWAIT | M_ZERO);

	sc->sc_keystate = malloc(sc->sc_nsense * sc->sc_nstrobe,
	    M_DEVBUF, M_NOWAIT | M_ZERO);

	/* set all the strobe bits */
	for (i = 0; i < sc->sc_nstrobe; i++) {
		pin = sc->sc_strobe_array[i];
		if (pin == -1) {
			continue;
		}
		pxa2x0_gpio_set_function(pin, GPIO_SET|GPIO_OUT);
	}
	/* set all the sense bits */
	for (i = 0; i < sc->sc_nsense; i++) {
		pin = sc->sc_sense_array[i];
		if (pin == -1) {
			continue;
		}
		pxa2x0_gpio_set_function(pin, GPIO_IN);
		pxa2x0_gpio_intr_establish(pin, IST_EDGE_BOTH, IPL_TTY,
		    zkbd_irq, sc, sc->sc_dev.dv_xname);
	}
	pxa2x0_gpio_intr_establish(sc->sc_onkey_pin, IST_EDGE_BOTH, IPL_TTY,
	    zkbd_on, sc, sc->sc_dev.dv_xname);
	pxa2x0_gpio_intr_establish(sc->sc_sync_pin, IST_EDGE_RISING, IPL_TTY,
	    zkbd_sync, sc, sc->sc_dev.dv_xname);
	pxa2x0_gpio_intr_establish(sc->sc_swa_pin, IST_EDGE_BOTH, IPL_TTY,
	    zkbd_hinge, sc, sc->sc_dev.dv_xname);
	pxa2x0_gpio_intr_establish(sc->sc_swb_pin, IST_EDGE_BOTH, IPL_TTY,
	    zkbd_hinge, sc, sc->sc_dev.dv_xname);

	if (glass_console) {
		wskbd_cnattach(&zkbd_consops, sc, &zkbd_keymapdata);
		a.console = 1;
	} else {
		a.console = 0;
	}

	a.keymap = &zkbd_keymapdata;
	a.accessops = &zkbd_accessops;
	a.accesscookie = sc;

	printf("\n");

	zkbd_hinge(sc);		/* to initialize sc_hinge */

	sc->sc_wskbddev = config_found(self, &a, wskbddevprint);

	timeout_set(&(sc->sc_roll_to), zkbd_poll, sc);
}

/* XXX only deal with keys that can be pressed when display is open? */
/* XXX are some not in the array? */
/* handle keypress interrupt */
int
zkbd_irq(void *v)
{
	zkbd_poll(v);

	return 1;
}

void
zkbd_poll(void *v)
{
	struct zkbd_softc *sc = v;
	int i, j, col, pin, type, keysdown = 0, s;
	int stuck;
	int keystate;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	int ncbuf = 0, c;
	char cbuf[MAXKEYS * 2];
#endif

	s = spltty();

	/* discharge all */
	for (i = 0; i < sc->sc_nstrobe; i++) {
		pin = sc->sc_strobe_array[i];
		if (pin != -1) {
			pxa2x0_gpio_clear_bit(pin);
			pxa2x0_gpio_set_dir(pin, GPIO_IN);
		}
	}

	delay (10);
	for(col = 0; col < sc->sc_nstrobe; col++) {
		if (sc->sc_strobe_array[i] == -1)
			continue;

		pin = sc->sc_strobe_array[col];

		/* activate_col */
		pxa2x0_gpio_set_bit(pin);
		pxa2x0_gpio_set_dir(pin, GPIO_OUT);

		/* wait activate delay */
		delay(10);

		/* read row */
		for (i = 0; i < sc->sc_nsense; i++) {
			int bit;

			if (sc->sc_sense_array[i] == -1) 
				continue;

			bit = pxa2x0_gpio_get_bit(sc->sc_sense_array[i]);
			if (bit && sc->sc_hinge && col < sc->sc_maxkbdcol)
				continue;
			sc->sc_keystate[i + (col * sc->sc_nsense)] = bit;
		}

		/* reset_col */
		pxa2x0_gpio_set_dir(pin, GPIO_IN);
		/* wait discharge delay */
		delay(10);
	}
	/* charge all */
	for (i = 0; i < sc->sc_nstrobe; i++) {
		pin = sc->sc_strobe_array[i];
		if (pin != -1) {
			pxa2x0_gpio_set_bit(pin);
			pxa2x0_gpio_set_dir(pin, GPIO_OUT);
		}
	}

	/* force the irqs to clear as we have just played with them. */
	for (i = 0; i < sc->sc_nsense; i++)
		if (sc->sc_sense_array[i] != -1)
			pxa2x0_gpio_clear_intr(sc->sc_sense_array[i]);

	/* process after resetting interrupt */

	zkbd_modstate = (
		(sc->sc_keystate[84] ? (1 << 0) : 0) | /* shift */
		(sc->sc_keystate[93] ? (1 << 1) : 0) | /* Fn */
		(sc->sc_keystate[14] ? (1 << 2) : 0)); /* 'alt' */

	for (i = 0; i < (sc->sc_nsense * sc->sc_nstrobe); i++) {
		stuck = 0;
		/* extend  xt_keymap to do this faster. */
		/* ignore 'stuck' keys' */
		for (j = 0; j < sizeof(stuck_keys)/sizeof(stuck_keys[0]); j++) {
			if (stuck_keys[j] == i) {
				stuck = 1 ;
				break;
			}
		}
		if (stuck)
			continue;
		keystate = sc->sc_keystate[i];

		keysdown |= keystate; /* if any keys held */

#ifdef WSDISPLAY_COMPAT_RAWKBD
		if (sc->sc_polling == 0 && sc->sc_rawkbd) {
			if ((keystate) || (sc->sc_okeystate[i] != keystate)) {
				c = sc->sc_xt_keymap[i];
				if (c & 0x80) {
					cbuf[ncbuf++] = 0xe0;
				}
				cbuf[ncbuf] = c & 0x7f;
				if (!keystate)
					cbuf[ncbuf] |= 0x80;
				ncbuf++;
				sc->sc_okeystate[i] = keystate;
			}
		}
#endif

		if ((!sc->sc_rawkbd) && (sc->sc_okeystate[i] != keystate)) {

			type = keystate ? WSCONS_EVENT_KEY_DOWN :
			    WSCONS_EVENT_KEY_UP;

			if (sc->sc_polling) {
				sc->sc_pollkey = i;
				sc->sc_pollUD = type;
			} else {
				wskbd_input(sc->sc_wskbddev, type, i);
			}

			sc->sc_okeystate[i] = keystate;
		}
	}

#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (sc->sc_polling == 0 && sc->sc_rawkbd)
		wskbd_rawinput(sc->sc_wskbddev, cbuf, ncbuf);
#endif
	if (keysdown)
		timeout_add(&(sc->sc_roll_to), hz * REP_DELAYN / 1000 / 2);
	else 
		timeout_del(&(sc->sc_roll_to)); /* always cancel? */

	splx(s);
}

#if NAPM > 0
extern	int allowpowerdown;
extern	int apm_suspends;
static	int zkbdondown;				/* on key is pressed */
static	struct timeval zkbdontv = { 0, 0 };	/* last on key event */
const	struct timeval zkbdhalttv = { 3, 0 };	/*  3s for safe shutdown */
const	struct timeval zkbdsleeptv = { 0, 250000 };	/* .25s for suspend */
extern	int lid_suspend;
#endif

int
zkbd_on(void *v)
{
#if NAPM > 0
	struct zkbd_softc *sc = v;
	int down = pxa2x0_gpio_get_bit(sc->sc_onkey_pin) ? 1 : 0;

	/*
	 * Change run mode depending on how long the key is held down.
	 * Ignore the key if it gets pressed while the lid is closed.
	 *
	 * Keys can bounce and we have to work around missed interrupts.
	 * Only the second edge is detected upon exit from sleep mode.
	 */
	if (down) {
		if (sc->sc_hinge == 3) {
			zkbdondown = 0;
		} else {
			microuptime(&zkbdontv);
			zkbdondown = 1;
		}
	} else if (zkbdondown) {
		if (ratecheck(&zkbdontv, &zkbdhalttv)) {
			if (allowpowerdown == 1) {
				allowpowerdown = 0;
				prsignal(initprocess, SIGUSR2);
			}
		} else if (ratecheck(&zkbdontv, &zkbdsleeptv)) {
			apm_suspends++;
		}
		zkbdondown = 0;
	}
#endif
	return 1;
}

int
zkbd_sync(void *v)
{
	return 1;
}

int
zkbd_hinge(void *v)
{
	struct zkbd_softc *sc = v;
	int a = pxa2x0_gpio_get_bit(sc->sc_swa_pin) ? 1 : 0;
	int b = pxa2x0_gpio_get_bit(sc->sc_swb_pin) ? 2 : 0;
	extern void lcd_blank(int);

	sc->sc_hinge = a | b;

	if (sc->sc_hinge == 3) {
#if NAPM > 0 
		if (lid_suspend)
			apm_suspends++;
#endif
		lcd_blank(1);
	} else
		lcd_blank(0);


	return 1;
}

int
zkbd_enable(void *v, int on)
{
        return 0;
}
        
void
zkbd_set_leds(void *v, int on)
{
}

int
zkbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
#ifdef WSDISPLAY_COMPAT_RAWKBD
	struct zkbd_softc *sc = v;
#endif

	switch (cmd) {

	case WSKBDIO_GTYPE:
		*(int *)data = WSKBD_TYPE_ZAURUS;
		return 0;
	case WSKBDIO_SETLEDS:
		return 0;
	case WSKBDIO_GETLEDS:
		*(int *)data = 0;
		return 0;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	case WSKBDIO_SETMODE:
		sc->sc_rawkbd = *(int *)data == WSKBD_RAW;
		return (0);
#endif
 
	}
	/* kbdioctl(...); */

	return -1;
}

/* implement polling for zaurus_kbd */
void
zkbd_cngetc(void *v, u_int *type, int *data)
{               
	struct zkbd_softc *sc = zkbd_dev;
	sc->sc_pollkey = -1;
	sc->sc_pollUD = -1;
	sc->sc_polling = 1;
	while (sc->sc_pollkey == -1) {
		zkbd_poll(zkbd_dev);
		DELAY(10000);	/* XXX */
	}
	sc->sc_polling = 0;
	*data = sc->sc_pollkey;
	*type = sc->sc_pollUD;
}

void
zkbd_cnpollc(void *v, int on)
{
}

int
zkbd_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_SUSPEND:
		zkbd_hinge(self);
		break;
	case DVACT_RESUME:
		zkbd_hinge(self);
		break;
	}
	return 0;
}
@


1.35
log
@The signal to tell init to power-off the system is SIGUSR2, not USR1

Inconsistency noted by blambert@@, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.34 2014/01/26 17:48:08 miod Exp $ */
d431 1
a431 1
				psignal(initproc, SIGUSR2);
@


1.34
log
@Attempt to make user changes of keyboard layout a bit more `sticky' on wsmux
kernels:
- keyboard drivers will now tell wskbd if the keyboard layout they ask
  for is a default value, or a value they are 100% sure of (either
  because your kernel has a XXXKBD_LAYOUT option, or because the
  driver can tell the keyboard layout, e.g. by the country code on USB
  keyboards which provide it, such as Sun's)
- when attaching a keyboard with a non-default layout, the layout will
  become the default layout of the mux for new keyboard attachments if
  the mux doesn't have a layout set already.
- when changing the keyboard layout of a particular keyboard with an
  ioctl (i.e. using kbd(8) or wsconsctl(8)), the layout will become the
  default layout of the mux for new keyboard attachments.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.33 2011/11/09 14:22:37 shadchin Exp $ */
d431 1
a431 1
				psignal(initproc, SIGUSR1);
@


1.33
log
@Auto-repeat keys in WSKBD_RAW mode is not needed.
WSKBD_RAW mode used in X, but X independently implements auto-repeat keys.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.32 2011/06/24 19:47:49 naddy Exp $ */
d154 1
a154 1
        KB_US,
@


1.32
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.31 2010/09/07 16:21:41 deraadt Exp $ */
a106 1
	struct timeout sc_rawrepeat_ch;
a107 2
	char sc_rep[MAXKEYS];
	int sc_nrep;
a136 1
void zkbd_rawrepeat(void *v);
a246 4
#ifdef WSDISPLAY_COMPAT_RAWKBD
	timeout_set(&sc->sc_rawrepeat_ch, zkbd_rawrepeat, sc);
#endif

a248 14
#ifdef WSDISPLAY_COMPAT_RAWKBD
void
zkbd_rawrepeat(void *v)
{
	struct zkbd_softc *sc = v;
	int s;
		
	s = spltty();
	wskbd_rawinput(sc->sc_wskbddev, sc->sc_rep, sc->sc_nrep);
	splx(s);
	timeout_add(&sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000);
}
#endif

d268 2
a269 2
	int npress = 0, ncbuf = 0, c;
	char cbuf[MAXKEYS *2];
d360 1
a360 7

				if (keystate) {
					if (c & 0x80) {
						sc->sc_rep[npress++] = 0xe0;
					}
					sc->sc_rep[npress++] = c & 0x7f;
				} else {
a361 1
				}
d385 1
a385 1
	if (sc->sc_polling == 0 && sc->sc_rawkbd) {
a386 6
		sc->sc_nrep = npress;
		if (npress != 0)
			timeout_add(&sc->sc_rawrepeat_ch, hz * REP_DELAY1/1000);
		else 
			timeout_del(&sc->sc_rawrepeat_ch);
	}
a501 1
		timeout_del(&sc->sc_rawrepeat_ch);
@


1.31
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.30 2010/08/30 21:35:57 deraadt Exp $ */
d432 1
a432 1
extern	int kbd_reset;
d464 2
a465 2
			if (kbd_reset == 1) {
				kbd_reset = 0;
@


1.30
log
@Convert all powerhooks to activate functions, and provide powerhook stubs.
Of note:  lcd stubs get pulled up to the parent; zts has to keep track of
whether it is in use or not
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.29 2007/09/17 01:33:33 krw Exp $ */
a111 1
	void *sc_powerhook;
a124 1
void zkbd_powerhook(int why, void *arg);
a184 6
	sc->sc_powerhook = powerhook_establish(zkbd_powerhook, sc);
	if (sc->sc_powerhook == NULL) {
		printf(": unable to establish powerhook\n");
		return;
	}

a580 6
}

void
zkbd_powerhook(int why, void *arg)
{
	zkbd_activate(arg, why);
@


1.29
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.28 2005/12/21 20:36:03 deraadt Exp $ */
d119 1
d126 1
a126 1
void zkbd_power(int why, void *arg);
d131 2
a132 1
	sizeof(struct zkbd_softc), zkbd_match, zkbd_attach
d187 1
a187 1
	sc->sc_powerhook = powerhook_establish(zkbd_power, sc);
d577 14
d592 1
a592 1
zkbd_power(int why, void *arg)
d594 1
a594 1
	zkbd_hinge(arg);
@


1.28
log
@sysctl machdep.lidsuspend=1 makes screen closures to cause a suspend.
(opening the screen does not yet wake the machine up, not yet sure if
that is even possible yet)
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.27 2005/12/20 18:53:09 deraadt Exp $ */
d207 1
a207 2
	    M_DEVBUF, M_NOWAIT);
	bzero(sc->sc_okeystate, (sc->sc_nsense * sc->sc_nstrobe));
d210 1
a210 2
	    M_DEVBUF, M_NOWAIT);
	bzero(sc->sc_keystate, (sc->sc_nsense * sc->sc_nstrobe));
@


1.27
log
@remove old #if 0 chunks no longer needed for debug
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.26 2005/12/20 04:28:19 deraadt Exp $ */
d446 1
d501 5
a505 1
	if (sc->sc_hinge == 3)
d507 1
a507 1
	else
d509 1
@


1.26
log
@at power events, call zkbd_hinge() to update the lcd state as well; ok drahn
bug reported in pr 4944
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.25 2005/11/11 18:17:40 deraadt Exp $ */
a409 5
#if 0
			printf("key %d %s\n", i,
			    keystate ? "pressed" : "released");
#endif

a480 3
#if 0
	printf("on key pressed\n");
#endif
a486 3
#if 0
	printf("sync button pressed\n");
#endif
a497 3
#if 0
	printf("hinge event A %d B %d\n", a, b);
#endif
@


1.25
log
@first key is scanned based on interrupt.  but if a key is held down
(ie. shift) then we cound on timeouts to re-scan the keyboard.  8 scans a
second was too slow.  change to 20 scans a second, which makes (hit the
keys repeatedly, do not use auto-repeat) NNNNNN work just like nnnnnn does.
ok drahn, sort of ok-chatter from miod
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.24 2005/11/11 16:58:46 deraadt Exp $ */
d588 1
a588 6
	struct zkbd_softc *sc = arg;
	int a = pxa2x0_gpio_get_bit(sc->sc_swa_pin) ? 1 : 0;
	int b = pxa2x0_gpio_get_bit(sc->sc_swb_pin) ? 2 : 0;

	/* probably should check why */
	sc->sc_hinge = a | b;
@


1.24
log
@make power button cause suspend after .25 seconds (was 3 seconds)
and safe-shutdown after 3 seconds (was 6 seconds)
ok uwe semi-ok drahn
we will see if anyone wants these numbers fudged more in the future
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.23 2005/05/25 07:29:17 drahn Exp $ */
d437 1
a437 1
		timeout_add(&(sc->sc_roll_to), hz / 8); /* how long?*/
@


1.23
log
@Resample the hinge value on wakeup, prevent 'hung' keyboard on return
from suspend.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.22 2005/05/24 20:32:43 uwe Exp $ */
d449 2
a450 2
const	struct timeval zkbdhalttv = { 6, 0 };	/*  6s for shutdown */
const	struct timeval zkbdsleeptv = { 2, 0 };	/*  2s for deep sleep */
@


1.22
log
@serial console support
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.21 2005/03/29 20:10:14 uwe Exp $ */
d112 1
d125 1
d185 6
d583 11
@


1.21
log
@Changed On/Off button behaviour (unless the lid is closed):
- hold for 2 seconds to suspend, or
- hold for 6 seconds to do a nice halt (if machdep.kbdreset=1).
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.20 2005/03/16 21:26:49 deraadt Exp $ */
d174 1
d233 1
a233 1
	if (1) {
@


1.20
log
@permit ramdisks to compile
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.19 2005/03/15 23:48:40 uwe Exp $ */
a17 1
#include <sys/types.h>
d24 2
d223 1
a223 1
	pxa2x0_gpio_intr_establish(sc->sc_onkey_pin, IST_EDGE_RISING, IPL_TTY,
d436 6
a441 2
const	struct timeval zkbdoninterval = { 1, 0 };	/* 1 second */
static	struct timeval zkbdonlasttime = { 0, 0 };
d449 1
a449 1
	extern int apm_suspends;
d451 25
a475 3
	if (sc->sc_hinge != 3 &&
	    ratecheck(&zkbdonlasttime, &zkbdoninterval))
		apm_suspends++;
@


1.19
log
@s/IPL_BIO/IPL_TTY.  ok drahn@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.18 2005/03/15 16:05:17 drahn Exp $ */
d103 1
a105 1
	int sc_rawkbd;
@


1.18
log
@Seperate delay for discharge and charge, otherwise discharge period may not
be long enough. should fix most of the extra keys on rollover.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.17 2005/03/15 00:34:25 drahn Exp $ */
d219 1
a219 1
		pxa2x0_gpio_intr_establish(pin, IST_EDGE_BOTH, IPL_BIO,
@


1.17
log
@Restructure the keyboard code so that the keys in rawkey are always sent
as expected. zero both keystate structures, keystate may not be fully
initialized. worked on with uwe.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.16 2005/02/23 02:19:32 deraadt Exp $ */
d314 1
a314 1
		/* wait activate (and discharge, overlapped) delay */
d332 2
@


1.16
log
@do not permit a suspend if the lid is closed; uwe ok
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.15 2005/02/22 22:12:10 deraadt Exp $ */
d202 1
d371 2
a372 2
		if (keystate) {
			if ((sc->sc_rawkbd) && !( npress >= MAXKEYS-1)) {
d374 15
a388 3
				if (c & 0x80)
					sc->sc_rep[npress++] = 0xe0;
				sc->sc_rep[npress++] = c & 0x7f;
d393 1
a393 1
		if (sc->sc_okeystate[i] != keystate) {
a405 14
#ifdef WSDISPLAY_COMPAT_RAWKBD
			} else if (sc->sc_rawkbd) {

				if (npress < sizeof(cbuf)-2) {
					c = sc->sc_xt_keymap[i];

					if (c & 0x80)
						cbuf[ncbuf++] = 0xe0;
					cbuf[ncbuf] = c & 0x7f;
					if (type == WSCONS_EVENT_KEY_UP)
						cbuf[ncbuf] |= 0x80;
					ncbuf++;
				}
#endif
@


1.15
log
@call zkbd_hinge() at attach time, to init sc_hinge; drahn ok
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.14 2005/02/22 21:53:03 uwe Exp $ */
d442 1
d445 2
a446 1
	if (ratecheck(&zkbdonlasttime, &zkbdoninterval))
@


1.14
log
@Initial suspend/resume code with additional powerhooks.  Enter/exit
suspend mode with power button or zzz.  May not work for everyone yet.
ok drahn@@ and deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.13 2005/02/22 18:13:28 deraadt Exp $ */
d242 2
@


1.13
log
@based on hinge buttons, do screen blanking.  uwe and i agree that
later on we should look at debouncing the buttons, as the current code
may lead to rapid display on/off cycles, which might be hard on the
battery; uwe ok
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.12 2005/01/30 21:55:50 drahn Exp $ */
d36 2
d431 5
d439 6
d466 1
a466 1
	extern int lcd_blank(int);
@


1.12
log
@Hack to allow emulation of mouse buttons for now, incorrectly shares
global between zkbd and zts, until a better solution is found.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.11 2005/01/28 14:47:31 drahn Exp $ */
d453 1
d459 6
@


1.11
log
@Allow zkbd to work in ddb and at the root selection prompt, tested/ok uwe@@
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.10 2005/01/18 17:57:13 drahn Exp $ */
d122 2
d343 5
@


1.10
log
@some cleanup and fix a nasty bug in rawmode.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.9 2005/01/18 01:03:15 drahn Exp $ */
d226 7
a232 1
	a.console = 0;
@


1.9
log
@Nearly working RAWKEY support, needs a lot of cleaning, but getting there.
first portion of poll support. Shouldn't change std key input.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.8 2005/01/17 18:23:34 deraadt Exp $ */
d272 2
d275 1
a275 1
	int npress = 0, ncbuf, c;
d337 1
a337 1
		int stuck = 0;
d348 3
a351 2
		if (sc->sc_keystate[i]) {
			keysdown++;
d353 1
d360 1
a361 1
		}
d363 1
a363 1
		if (sc->sc_okeystate[i] != sc->sc_keystate[i]) {
d365 1
a365 1
			type = sc->sc_keystate[i] ? WSCONS_EVENT_KEY_DOWN :
d370 1
a370 1
			    sc->sc_keystate[i] ? "pressed" : "released");
d379 2
a380 1
				c = sc->sc_xt_keymap[i];
d382 7
a388 6
				if (c & 0x80)
					cbuf[ncbuf++] = 0xe0;
				cbuf[ncbuf] = c & 0x7f;
				if (type == WSCONS_EVENT_KEY_UP)
					cbuf[ncbuf] |= 0x80;
				ncbuf++;
d394 1
a394 1
			sc->sc_okeystate[i] = sc->sc_keystate[i];
d402 1
a402 1
		if (keysdown != 0)
@


1.8
log
@when hinge covers keyboard, ignore key downs; drahn ok
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.7 2005/01/15 17:51:57 deraadt Exp $ */
d64 10
d94 5
d102 1
d105 3
d111 2
d170 5
d187 3
d194 2
d236 4
d242 14
d271 5
a275 1
	int i, col, pin, type, keysdown = 0, s;
d335 13
a347 1
		if (sc->sc_keystate[i])
d349 9
d369 18
a386 1
	                wskbd_input(sc->sc_wskbddev, type, i);
d391 11
d457 1
a457 1
	struct akbd_softc *sc = v;
d487 11
@


1.7
log
@turn off debug stuff for now
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.6 2005/01/15 05:58:53 drahn Exp $ */
d73 4
a76 4
	int sc_onkey_pin;
	int sc_sync_pin;
	int sc_swa_pin;
	int sc_swb_pin;
d79 2
d146 1
a147 1
	struct wskbddev_attach_args a;
d156 1
d163 1
a163 1
	sc->sc_okeystate = malloc((sc->sc_nsense * sc->sc_nstrobe),
d165 1
a165 1
	sc->sc_keystate = malloc((sc->sc_nsense * sc->sc_nstrobe),
d222 1
a222 5
	int i, col;
	int pin;
	int type;
	int keysdown = 0;
	int s;
d251 2
d256 4
a259 2
			sc->sc_keystate [i + (col * sc->sc_nsense)] =
			    pxa2x0_gpio_get_bit(sc->sc_sense_array[i]);
d329 4
d334 1
a334 1
	printf("hinge event pressed\n");
d336 1
@


1.6
log
@_poll can be called from timeout, but needs to be protected from interrupt,
add spltty() protection.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.5 2005/01/14 18:42:31 drahn Exp $ */
d287 4
a290 3
/*
printf("key %d %s\n", i, sc->sc_keystate[i] ? "pressed" : "released");
*/
d308 1
d310 1
d317 1
d319 1
d326 1
d328 1
@


1.5
log
@clean up dmesg: '\n', speed up polling for 'rollover',
add F1-F5 for Cal, Addr, mail Home, Menu
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.4 2005/01/14 16:39:15 miod Exp $ */
d223 3
d300 2
@


1.4
log
@Minor KNF and tweaks, also interrupt at IPL_TTY rather than IPL_BIO.

ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.3 2005/01/14 04:35:22 drahn Exp $ */
d197 2
d294 1
a294 1
		timeout_add(&(sc->sc_roll_to), hz / 4); /* how long?*/
@


1.3
log
@add a 'rollover' timer to detect when a second (inerrupt masked key
is pressed while keys are being held. allows shift to always
work
Timeout on this needs to be adjusted.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.2 2005/01/13 23:33:37 drahn Exp $ */
d36 1
a36 1
int
d48 1
a48 1
int
a64 1

d68 2
a69 2
	int *sc_sense_array;
	int *sc_strobe_array;
a80 1
	struct timeout sc_rawrepeat_ch;
d84 1
d86 2
d102 1
d161 1
a161 1
	    M_MBUF, M_NOWAIT);
d163 1
a163 1
	    M_MBUF, M_NOWAIT);
d183 1
a183 1
	pxa2x0_gpio_intr_establish(sc->sc_onkey_pin, IST_EDGE_RISING, IPL_BIO,
d185 1
a185 1
	pxa2x0_gpio_intr_establish(sc->sc_sync_pin, IST_EDGE_RISING, IPL_BIO,
d187 1
a187 1
	pxa2x0_gpio_intr_establish(sc->sc_swa_pin, IST_EDGE_BOTH, IPL_BIO,
d189 1
a189 1
	pxa2x0_gpio_intr_establish(sc->sc_swb_pin, IST_EDGE_BOTH, IPL_BIO,
d212 1
d243 1
a243 1
		delay (10);
d292 1
a292 1
		timeout_add(&(sc->sc_roll_to), hz/4); /* how long?*/
d339 1
a339 1
		*(int *)data = WSKBD_TYPE_ADB;
a368 1

@


1.2
log
@Stage one of wscons support.
@
text
@d1 1
a1 1
/* $OpenBSD: zaurus_kbd.c,v 1.1 2005/01/13 20:47:57 drahn Exp $ */
d23 2
d81 2
d93 1
d196 2
d206 7
d217 1
d271 3
d288 4
a291 2

	return 1;
d311 1
a311 1
	printf("hing event pressed\n");
@


1.1
log
@keyboard driver for zaurus, needs connect to wscons still.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d27 6
d78 5
d100 24
d138 1
d184 7
d202 1
a238 12

	printf("zkbd_irq\n");
	for (i = 0; i < (sc->sc_nsense * sc->sc_nstrobe); i++) {
		if (sc->sc_okeystate[i] != sc->sc_keystate[i]) {
			if (sc->sc_keystate[i]) 
				printf("key %d pressed\n", i);
			else
				printf("key %d released\n", i);
		}
		sc->sc_okeystate[i] = sc->sc_keystate[i];
	}

d253 18
d294 53
@

