head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.22
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.18
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.20
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.12
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.16
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.14
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.10
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.8
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.4
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.23.21.25.07;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.14.21.11.07;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.06.18.53.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.14.23.51.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.14.21.46.31;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.07.07.29.44;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.02;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@/*	$OpenBSD: stdarg.h,v 1.7 2008/10/23 21:25:07 kettenis Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)stdarg.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _MIPS64_STDARG_H_
#define	_MIPS64_STDARG_H_

#include <sys/cdefs.h>
#include <machine/_types.h>

typedef __va_list	va_list;

#ifndef __GNUC_VA_LIST
#define __GNUC_VA_LIST
#if defined (__mips_eabi) && ! defined (__mips_soft_float) && ! defined (__mips_single_float)

typedef struct {
  /* Pointer to FP regs.  */
  char *__fp_regs;
  /* Number of FP regs remaining.  */
  int __fp_left;
  /* Pointer to GP regs followed by stack parameters.  */
  char *__gp_regs;
} __gnuc_va_list;

#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float) && ! defined (__mips_single_float)) */

typedef char * __gnuc_va_list;

#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float) && ! defined (__mips_single_float)) */
#endif /* not __GNUC_VA_LIST */

/* If this is for internal libc use, don't define anything but __gnuc_va_list */

#ifndef _MIPS64_STDARG_H_
#define _MIPS64_STDARG_H_
enum {
  __no_type_class = -1,
  __void_type_class,
  __integer_type_class,
  __char_type_class,
  __enumeral_type_class,
  __boolean_type_class,
  __pointer_type_class,
  __reference_type_class,
  __offset_type_class,
  __real_type_class,
  __complex_type_class,
  __function_type_class,
  __method_type_class,
  __record_type_class,
  __union_type_class,
  __array_type_class,
  __string_type_class,
  __set_type_class,
  __file_type_class,
  __lang_type_class
};
#endif

#define __va_ellipsis ...

#ifdef __mips64__
#define __va_rounded_size(__TYPE)  \
  (((sizeof (__TYPE) + 8 - 1) / 8) * 8)
#else
#define __va_rounded_size(__TYPE)  \
  (((sizeof (__TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))
#endif

#ifdef __mips64__
#define __va_reg_size 8
#else
#define __va_reg_size 4
#endif

#if defined (__mips_eabi)
#if ! defined (__mips_soft_float) && ! defined (__mips_single_float)
#ifdef __mips64__
#define va_start(__AP, __LASTARG)					\
  (__AP.__gp_regs = ((char *) __builtin_next_arg (__LASTARG)		\
		     - (__builtin_args_info (2) < 8			\
			? (8 - __builtin_args_info (2)) * __va_reg_size	\
			: 0)),						\
   __AP.__fp_left = 8 - __builtin_args_info (3),			\
   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)
#else /* ! defined (__mips64__) */
#define va_start(__AP, __LASTARG)					\
  (__AP.__gp_regs = ((char *) __builtin_next_arg (__LASTARG)		\
		     - (__builtin_args_info (2) < 8			\
			? (8 - __builtin_args_info (2)) * __va_reg_size	\
			: 0)),						\
   __AP.__fp_left = (8 - __builtin_args_info (3)) / 2,			\
   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * 8,		\
   __AP.__fp_regs = (char *) ((int) __AP.__fp_regs & -8))
#endif /* ! defined (__mips64__) */
#else /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float) ) */
#define va_start(__AP, __LASTARG)					\
  (__AP = ((__gnuc_va_list) __builtin_next_arg (__LASTARG)		\
	   - (__builtin_args_info (2) >= 8 ? 0				\
	      : (8 - __builtin_args_info (2)) * __va_reg_size)))
#endif /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float) ) */
#else /* ! defined (__mips_eabi) */
#define va_start(__AP, __LASTARG) \
  (__AP = (__gnuc_va_list) __builtin_next_arg (__LASTARG))
#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float) && ! defined (__mips_single_float)) */

#ifndef va_end
void va_end (__gnuc_va_list);		/* Defined in libgcc.a */
#endif
#define va_end(__AP)	

#if defined (__mips_eabi)

#if ! defined (__mips_soft_float) && ! defined (__mips_single_float)
#ifdef __mips64__
#define __va_next_addr(__AP, __type)					\
  ((__builtin_classify_type (*(__type *) 0) == __real_type_class	\
    && __AP.__fp_left > 0)						\
   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)			\
   : (__AP.__gp_regs += __va_reg_size) - __va_reg_size)
#else
#define __va_next_addr(__AP, __type)					\
  ((__builtin_classify_type (*(__type *) 0) == __real_type_class	\
    && __AP.__fp_left > 0)						\
   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)			\
   : (((__builtin_classify_type (* (__type *) 0) < __record_type_class	\
	&& __alignof__ (__type) > 4)					\
       ? __AP.__gp_regs = (char *) (((int) __AP.__gp_regs + 8 - 1) & -8) \
       : (char *) 0),							\
      (__builtin_classify_type (* (__type *) 0) >= __record_type_class	\
       ? (__AP.__gp_regs += __va_reg_size) - __va_reg_size		\
       : ((__AP.__gp_regs += __va_rounded_size (__type))		\
	  - __va_rounded_size (__type)))))
#endif
#else /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float)) */
#ifdef __mips64__
#define __va_next_addr(__AP, __type)					\
  ((__AP += __va_reg_size) - __va_reg_size)
#else
#define __va_next_addr(__AP, __type)					\
  (((__builtin_classify_type (* (__type *) 0) < __record_type_class	\
     && __alignof__ (__type) > 4)					\
    ? __AP = (char *) (((__PTRDIFF_TYPE__) __AP + 8 - 1) & -8)		\
    : (char *) 0),							\
   (__builtin_classify_type (* (__type *) 0) >= __record_type_class	\
    ? (__AP += __va_reg_size) - __va_reg_size				\
    : ((__AP += __va_rounded_size (__type))				\
       - __va_rounded_size (__type))))
#endif
#endif /* ! (! defined (__mips_soft_float) && ! defined (__mips_single_float)) */

#ifdef __MIPSEB__
#define va_arg(__AP, __type)						\
  ((__va_rounded_size (__type) <= __va_reg_size)			\
   ? *(__type *) (void *) (__va_next_addr (__AP, __type)		\
			   + __va_reg_size				\
			   - sizeof (__type))				\
   : (__builtin_classify_type (*(__type *) 0) >= __record_type_class	\
      ? **(__type **) (void *) (__va_next_addr (__AP, __type)		\
				+ __va_reg_size				\
				- sizeof (char *))			\
      : *(__type *) (void *) __va_next_addr (__AP, __type)))
#else
#define va_arg(__AP, __type)						\
  ((__va_rounded_size (__type) <= __va_reg_size)			\
   ? *(__type *) (void *) __va_next_addr (__AP, __type)		\
   : (__builtin_classify_type (* (__type *) 0) >= __record_type_class	\
      ? **(__type **) (void *) __va_next_addr (__AP, __type)		\
      : *(__type *) (void *) __va_next_addr (__AP, __type)))
#endif

#else /* ! defined (__mips_eabi) */

/* We cast to void * and then to TYPE * because this avoids
   a warning about increasing the alignment requirement.  */
/* The __mips64__ cases are reversed from the 32 bit cases, because the standard
   32 bit calling convention left-aligns all parameters smaller than a word,
   whereas the __mips64__ calling convention does not (and hence they are
   right aligned).  */
#ifdef __mips64__
#ifdef __MIPSEB__
#define va_arg(__AP, __type)                                    \
  ((__type *) (void *) (__AP = (char *)                         \
                       ((((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8) \
			   + __va_rounded_size (__type))))[-1]
#else
#define va_arg(__AP, __type)                                    \
  ((__AP = (char *) ((((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8)	\
		     + __va_rounded_size (__type))),		\
   *(__type *) (void *) (__AP - __va_rounded_size (__type)))
#endif

#else /* not __mips64__ */

#ifdef __MIPSEB__
/* For big-endian machines.  */
#define va_arg(__AP, __type)					\
  ((__AP = (char *) ((__alignof__ (__type) > 4			\
		      ? ((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8	\
		      : ((__PTRDIFF_TYPE__)__AP + 4 - 1) & -4)	\
		     + __va_rounded_size (__type))),		\
   *(__type *) (void *) (__AP - __va_rounded_size (__type)))
#else
/* For little-endian machines.  */
#define va_arg(__AP, __type)						    \
  ((__type *) (void *) (__AP = (char *) ((__alignof__(__type) > 4	    \
				? ((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8	    \
				: ((__PTRDIFF_TYPE__)__AP + 4 - 1) & -4)    \
					 + __va_rounded_size(__type))))[-1]
#endif
#endif
#endif /* ! defined (__mips_eabi)  */

/* Copy __gnuc_va_list into another variable of this type.  */
#define __va_copy(dest, src) (dest) = (src)

#endif /* !_MIPS64_STDARG_H_ */
@


1.7
log
@Move the va_copy define to <sys/stdrag.h> making sure it is uniformaly
protected by __ISO_C_VISIBLE > 1999.  With a little help from miod@@.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdarg.h,v 1.6 2006/05/14 21:11:07 robert Exp $	*/
d34 2
a35 2
#ifndef _MIPS_STDARG_H_
#define	_MIPS_STDARG_H_
d64 2
a65 2
#ifndef _VA_MIPS_H_ENUM
#define _VA_MIPS_H_ENUM
d247 1
a247 1
#endif /* !_MIPS_STDARG_H_ */
@


1.6
log
@use __mips64__
@
text
@d1 1
a1 1
/*	$OpenBSD: stdarg.h,v 1.5 2006/01/06 18:53:05 millert Exp $	*/
a245 3
#if __ISO_C_VISIBLE >= 1999
#define va_copy __va_copy
#endif
@


1.5
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: stdarg.h,v 1.4 2005/12/14 23:51:33 deraadt Exp $	*/
d92 1
a92 1
#ifdef __mips64
d100 1
a100 1
#ifdef __mips64
d108 1
a108 1
#ifdef __mips64
d116 1
a116 1
#else /* ! defined (__mips64) */
d125 1
a125 1
#endif /* ! defined (__mips64) */
d145 1
a145 1
#ifdef __mips64
d166 1
a166 1
#ifdef __mips64
d206 1
a206 1
/* The __mips64 cases are reversed from the 32 bit cases, because the standard
d208 1
a208 1
   whereas the __mips64 calling convention does not (and hence they are
d210 1
a210 1
#ifdef __mips64
d223 1
a223 1
#else /* not __mips64 */
@


1.4
log
@make va_arg() map to nothing; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: stdarg.h,v 1.3 2005/12/14 21:46:31 millert Exp $	*/
d38 1
a38 1
#include <machine/ansi.h>
d40 1
a40 1
typedef _BSD_VA_LIST_	va_list;
@


1.3
log
@convert _FOO_SOURCE -> __FOO_VISIBLE in machine.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdarg.h,v 1.2 2005/08/07 07:29:44 miod Exp $	*/
d140 1
a140 1
#define va_end(__AP)	((void)0)
@


1.2
log
@Remove advertising clause from UCB licenses; ok deraad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stdarg.h,v 1.1 2004/08/06 20:56:02 pefo Exp $	*/
d37 1
d246 1
d248 1
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: stdarg.h,v 1.2 1999/01/27 04:46:06 imp Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@

