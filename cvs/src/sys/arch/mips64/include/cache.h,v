head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.2
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.9
date	2016.12.21.13.59.57;	author visa;	state Exp;
branches;
next	1.8;
commitid	p6zUhTuh4cX1l0nl;

1.8
date	2016.01.05.05.27.54;	author visa;	state Exp;
branches;
next	1.7;
commitid	916i76I5mjNtTg33;

1.7
date	2015.08.15.22.31.38;	author miod;	state Exp;
branches;
next	1.6;
commitid	yF3Npu6AQ8EgYJml;

1.6
date	2014.03.31.20.21.19;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.24.20.20.37;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.21.12.20.30;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.06.20.11.18;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Add a driver for OCTEON MMC host controller.

Tested on EdgeRouter Pro, and Shasta.

OK mpi@@
@
text
@/*	$OpenBSD: cache.h,v 1.8 2016/01/05 05:27:54 visa Exp $	*/

/*
 * Copyright (c) 2012 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef	_MIPS64_CACHE_H_
#define	_MIPS64_CACHE_H_

/*
 * Declare canonical cache functions for a given processor.
 *
 * The following assumptions are made:
 * - only L1 has split instruction and data caches.
 * - L1 I$ is virtually indexed.
 *
 * Processor-specific routines will make extra assumptions.
 */

#define CACHE_PROTOS(chip) \
/* Figure out cache configuration */ \
void	chip##_ConfigCache(struct cpu_info *); \
/* Writeback and invalidate all caches */ \
void  	chip##_SyncCache(struct cpu_info *); \
/* Invalidate all I$ for the given range */ \
void	chip##_InvalidateICache(struct cpu_info *, vaddr_t, size_t); \
/* Register a given page for I$ invalidation */ \
void	chip##_InvalidateICachePage(struct cpu_info *, vaddr_t); \
/* Perform postponed I$ invalidation */ \
void	chip##_SyncICache(struct cpu_info *); \
/* Writeback all D$ for the given page */ \
void	chip##_SyncDCachePage(struct cpu_info *, vaddr_t, paddr_t); \
/* Writeback all D$ for the (currently mapped) given page */ \
void	chip##_HitSyncDCachePage(struct cpu_info *, vaddr_t, paddr_t); \
/* Writeback all D$ for the given range */ \
void	chip##_HitSyncDCache(struct cpu_info *, vaddr_t, size_t); \
/* Invalidate all D$ for the given range */ \
void	chip##_HitInvalidateDCache(struct cpu_info *, vaddr_t, size_t); \
/* Enforce coherency of the given range */ \
void	chip##_IOSyncDCache(struct cpu_info *, vaddr_t, size_t, int);

/*
 * Cavium Octeon.
 */
CACHE_PROTOS(Octeon)

void	Octeon_lock_secondary_cache(struct cpu_info *, paddr_t, size_t);
void	Octeon_unlock_secondary_cache(struct cpu_info *, paddr_t, size_t);

/*
 * STC Loongson 2E and 2F.
 */
CACHE_PROTOS(Loongson2)
 
/*
 * Loongson 3A and 2Gq.
 */
CACHE_PROTOS(Loongson3)
 
/*
 * MIPS R4000 and R4400.
 */
CACHE_PROTOS(Mips4k)

/*
 * IDT/QED/PMC-Sierra R4600, R4700, R5000, RM52xx, RM7xxx, RM9xxx.
 */
CACHE_PROTOS(Mips5k)

/*
 * MIPS (SGI, really) R8000.
 */
CACHE_PROTOS(tfp)

/*
 * MIPS/NEC R10000/R120000/R140000/R16000.
 */
CACHE_PROTOS(Mips10k)

/*
 * mips64r2-compliant processors.
 */
CACHE_PROTOS(mips64r2)

/*
 * Values used by the IOSyncDCache routine [which acts as the backend of
 * bus_dmamap_sync()].
 */
#define	CACHE_SYNC_R	0	/* WB invalidate, WT invalidate */
#define	CACHE_SYNC_W	1	/* WB writeback, WT unaffected */
#define	CACHE_SYNC_X	2	/* WB writeback + invalidate, WT invalidate */

extern vaddr_t cache_valias_mask;

#endif	/* _MIPS64_CACHE_H_ */
@


1.8
log
@Some implementations of HitSyncDCache() call pmap_extract() for va->pa
conversion. Because pmap_extract() acquires the PTE mutex, a "locking
against myself" panic is triggered if the cache routine gets called in
a context where the mutex is already held.

In the pmap, all calls to HitSyncDCache() are for a whole page. Add a
new cache routine, HitSyncDCachePage(), which gets both the va and the
pa of a page. This removes the need of the va->pa conversion. The new
routine has the same signature as SyncDCachePage(), allowing reuse of
the same routine for cache implementations that do not need differences
between "Hit" and non-"Hit" routines.

With the diff, POWER Indigo2 R8000 boots multiuser again. Tested on sgi
GENERIC-IP27.MP and octeon GENERIC.MP, too.

Diff from miod@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.h,v 1.7 2015/08/15 22:31:38 miod Exp $	*/
d58 3
@


1.7
log
@Some bits for Loongson 3A support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.h,v 1.6 2014/03/31 20:21:19 miod Exp $	*/
d45 2
@


1.6
log
@Due the virtually indexed nature of the L1 instruction cache on most mips
processors, every time a new text page is mapped in a pmap, the L1 I$ is
flushed for the va spanned by this page.

Since we map pages of our binaries upon demand, as they get faulted in, but
uvm_fault() tries to map the few neighbour pages, this can end up in a
bunch of pmap_enter() calls in a row, for executable mappings. If the L1
I$ is small enough, this can cause the whole L1 I$ cache to be flushed
several times.

Change pmap_enter() to postpone these flushes by only registering the
pending flushes, and have pmap_update() perform them. The cpu-specific
cache code can then optimize this to avoid unnecessary operations.

Tested on R4000SC, R4600SC, R5000SC, RM7000, R10000 with 4KB and 16KB
page sizes (coherent and non-coherent designs), and Loongson 2F by mikeb@@ and
me. Should not affect anything on Octeon since there is no way to flush a
subset of I$ anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.h,v 1.5 2012/09/29 21:37:03 miod Exp $	*/
d63 5
d86 5
@


1.5
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.h,v 1.4 2012/06/24 20:20:37 miod Exp $	*/
d39 4
@


1.4
log
@Do not output unnecessary semicolons when expanding macros. No functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.h,v 1.3 2012/04/21 12:20:30 miod Exp $	*/
d69 5
d83 1
a83 1
#define	CACHE_SYNC_W	1	/* WB writeback + invalidate, WT unaffected */
@


1.3
log
@Rework the signature of the cache handling routines again. It makes more sense
to pass both the virtual and physical addresses of the page to clean to
SyncDCachePage, which is the only routine using `Index' operations on the data
cache, which might be virtually indexed at some levels but physically indexed
at others. On the other hand, it does not make any sense to pass a physical
address to routines using `Hit' operations (and they were discarding them
anyway).

In addition to making things cleaner, this fixes sporadic userland misbehaviour
(read: SIGSGEV) on RM7000 O2 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.h,v 1.2 2012/04/06 20:11:18 miod Exp $	*/
d51 1
a51 1
CACHE_PROTOS(Octeon);
d56 1
a56 1
CACHE_PROTOS(Loongson2);
d61 1
a61 1
CACHE_PROTOS(Mips4k);
d66 1
a66 1
CACHE_PROTOS(Mips5k);
d71 1
a71 1
CACHE_PROTOS(Mips10k);
@


1.2
log
@Make the logic for PMAP_PREFER() and the logic, inside pmap, to do the
necessary cache coherency work wrt similar virtual indexes of different
physical pages, depending upon two distinct global variables, instead of
a shared one. R4000/R4400 VCE requires a 32KB mask for PMAP_PREFER, which
is otherwise not necessary for pmap coherency (especially since, on these
processors, only L1 uses virtual indexes, and the L1 size is not greater
than the page size, as we are using 16KB pages).
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.h,v 1.1 2012/03/25 13:52:52 miod Exp $	*/
d25 3
a27 7
 * Note that the uint64_t arguments are addresses, which can be either
 * virtual or physical addresses, depending upon the particular processor
 * model.  The high-level functions, invoked from pmap, pass both virtual
 * and physical addresses to the Mips_* cache macros declared in
 * <machine/cpu.h>.  It is the responsibility of a given port, when
 * implementing these macros, to pass either the virtual or the physical
 * address to the final cache routines.
d29 1
a29 2
 * Note that there are no ports where the supported processors use a mix
 * of virtual and physical addresses.
d38 1
a38 1
void	chip##_InvalidateICache(struct cpu_info *, uint64_t, size_t); \
d40 1
a40 1
void	chip##_SyncDCachePage(struct cpu_info *, uint64_t); \
d42 1
a42 1
void	chip##_HitSyncDCache(struct cpu_info *, uint64_t, size_t); \
d44 1
a44 1
void	chip##_HitInvalidateDCache(struct cpu_info *, uint64_t, size_t); \
d46 1
a46 1
void	chip##_IOSyncDCache(struct cpu_info *, uint64_t, size_t, int);
a49 2
 * ICache routines take virtual addresses.
 * DCache routines take physical addresses.
d54 1
a54 3
 * STC Loongson 2e and 2f.
 * ICache routines take virtual addresses.
 * DCache routines take physical addresses.
a59 2
 * ICache routines take virtual addresses.
 * DCache routines take virtual addresses.
d64 1
a64 3
 * IDT/QED/PMC-Sierra R5000, RM52xx, RM7xxx, RM9xxx
 * ICache routines take virtual addresses.
 * DCache routines take virtual addresses.
d69 1
a69 3
 * MIPS/NEC R10000/R120000/R140000/R16000
 * ICache routines take virtual addresses.
 * DCache routines take virtual addresses.
@


1.1
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 2
@

