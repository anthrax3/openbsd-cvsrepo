head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.2
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.27.0.12
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.8
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.10
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.24.0.10
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.29
date	2016.12.23.12.38.16;	author visa;	state Exp;
branches;
next	1.28;
commitid	2zEjAh909elqzG9L;

1.28
date	2016.12.22.15.33.36;	author visa;	state Exp;
branches;
next	1.27;
commitid	sw48d58czeutOmw2;

1.27
date	2014.01.30.18.16.41;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.24.05.21.19;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.23.22.06.29;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.15.05.30.19;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.28.20.28.28;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.08.22.15.47;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.07.19.23.52;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.22.00.07.04;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.22.18.20.21;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.22.10.41.37;	author kurt;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.25.21.25.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.30.20.13.14;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.03.19.34.00;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.27.18.14.11;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.14.14.54.28;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.07.07.29.44;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.11.15.13.01;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.28.01.36.39;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.11.16.12.59;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.21.05.51.13;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.17.19.19.05;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.09.22.21.41;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.09.10.25.50;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.20.28.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.02;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Tweaks suggested by miod@@
@
text
@/*	$OpenBSD: vmparam.h,v 1.28 2016/12/22 15:33:36 visa Exp $	*/
/*	$NetBSD: vmparam.h,v 1.5 1994/10/26 21:10:10 cgd Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Utah Hdr: vmparam.h 1.16 91/01/18
 *	@@(#)vmparam.h	8.2 (Berkeley) 4/22/94
 */

#ifndef _MIPS64_VMPARAM_H_
#define _MIPS64_VMPARAM_H_

/*
 * Machine dependent constants mips processors.
 */

#define	USRSTACK	VM_MAXUSER_ADDRESS	/* Start of user stack */

/*
 * Virtual memory related constants, all in bytes
 */
#ifndef MAXTSIZ
#define	MAXTSIZ		(64*1024*1024)		/* max text size */
#endif
#ifndef DFLDSIZ
#define	DFLDSIZ		(128*1024*1024)		/* initial data size limit */
#endif
#ifndef MAXDSIZ
#define	MAXDSIZ		(16UL*1024*1024*1024)	/* max data size */
#endif
#ifndef BRKSIZ
#define	BRKSIZ		MAXDSIZ			/* heap gap size */
#endif
#ifndef	DFLSSIZ
#define	DFLSSIZ		(2*1024*1024)		/* initial stack size limit */
#endif
#ifndef	MAXSSIZ
#define	MAXSSIZ		(32*1024*1024)		/* max stack size */
#endif

#define STACKGAP_RANDOM	256*1024

/*
 * PTEs for mapping user space into the kernel for physio operations.
 * 16 pte's are enough to cover 8 disks * MAXBSIZE.
 */
#ifndef USRIOSIZE
#define USRIOSIZE	32
#endif

/*
 * PTEs for system V style shared memory.
 * This is basically slop for kmempt which we actually allocate (malloc) from.
 */
#ifndef SHMMAXPGS
#define SHMMAXPGS	8192		/* 8mb */
#endif

#ifndef	VM_PHYSSEG_MAX
#define	VM_PHYSSEG_MAX	8	/* Max number of physical memory segments */
#endif
#ifndef	VM_PHYSSEG_STRAT
#define VM_PHYSSEG_STRAT VM_PSTRAT_BSEARCH
#endif
#define VM_PHYSSEG_NOADD

/* user/kernel map constants */
#define VM_MIN_ADDRESS		((vaddr_t)0x0000000000004000L)
#define VM_MAXUSER_ADDRESS	((vaddr_t)0x0000010000000000L)
#define VM_MAX_ADDRESS		VM_MAXUSER_ADDRESS
#define	VM_MIN_KERNEL_ADDRESS	((vaddr_t)0xc000000000000000L)
#define	VM_MAX_KERNEL_ADDRESS	((vaddr_t)0xc000000040000000L)

/* map PIE into approximately the first quarter of user va space */
#define VM_PIE_MIN_ADDR		PAGE_SIZE
#define VM_PIE_MAX_ADDR		(0x4000000000UL)

/* virtual sizes (bytes) for various kernel submaps */
#define VM_PHYS_SIZE		(USRIOSIZE*PAGE_SIZE)

#endif /* !_MIPS64_VMPARAM_H_ */
@


1.28
log
@Extend the size of user virtual address space from 2GB to 1TB on mips64
by adding another level to page directories. This improves ASLR and
complements W^X added earlier on some systems, giving a notable update
to the architecture's security. Besides, there is now more room for
running tasks that hog memory.

Testing help from deraadt@@ and fcambus@@.
Platforms tested: loongson, octeon, sgi/IP27 and sgi/IP30
(IP30 also with 4KB pages).
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.27 2014/01/30 18:16:41 miod Exp $	*/
d105 1
a105 1
/* map PIE below 256GB (non-pie link address) to avoid mmap pressure */
@


1.27
log
@Move declaration of struct vm_page_md from <machine/vmparam.h> to
<machine/pmap.h> where it belongs, and compensate in <uvm/uvm_extern.h>
by including <uvm/uvm_pmap.h> before <uvm/uvm_page.h>. Tested on all
MACHINE_ARCH but amd64 and i386 (and hppa64).
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.26 2014/01/24 05:21:19 miod Exp $	*/
d60 1
a60 1
#define	MAXDSIZ		(1*1024*1024*1024)	/* max data size */
d100 1
a100 1
#define VM_MAXUSER_ADDRESS	((vaddr_t)0x0000000080000000L)
d105 1
a105 1
/* map PIE below 256MB (non-pie link address) to avoid mmap pressure */
d107 1
a107 1
#define VM_PIE_MAX_ADDR		(0x10000000UL)
@


1.26
log
@Do not protect struct vm_page_md with defined(_KERNEL), for userland uvm
grovellers need to know it to be able to get the right size for struct
vm_page.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.25 2014/01/23 22:06:29 miod Exp $	*/
a110 25

#if !defined(_LOCORE)
/*
 * pmap-specific data
 */

/* XXX - belongs in pmap.h, but put here because of ordering issues */
typedef struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
} *pv_entry_t;

struct vm_page_md {
	struct pv_entry pv_ent;		/* pv list of this seg */
};

#define	VM_MDPAGE_INIT(pg) \
	do { \
		(pg)->mdpage.pv_ent.pv_next = NULL; \
		(pg)->mdpage.pv_ent.pv_pmap = NULL; \
		(pg)->mdpage.pv_ent.pv_va = 0; \
	} while (0)

#endif	/* _KERNEL && !_LOCORE */
@


1.25
log
@unifdef -D__HAVE_VM_PAGE_MD - no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.24 2011/05/30 22:25:21 oga Exp $	*/
d112 1
a112 1
#if defined(_KERNEL) && !defined(_LOCORE)
@


1.24
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.23 2011/03/23 16:54:36 pirofti Exp $	*/
a123 1
#define __HAVE_VM_PAGE_MD
@


1.23
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.22 2010/12/15 05:30:19 tedu Exp $	*/
a107 5

#ifndef VM_NFREELIST
#define	VM_NFREELIST		1
#endif
#define	VM_FREELIST_DEFAULT	0
@


1.22
log
@oops, i forgot to check in the BRKSIZ define in uvm, but deraadt thinks
its better as a per arch MD define anyway.  all default to MAXDSIZ as before.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.21 2010/11/28 20:28:28 miod Exp $	*/
d41 2
a42 2
#ifndef _MIPS_VMPARAM_H_
#define _MIPS_VMPARAM_H_
d143 1
a143 1
#endif /* !_MIPS_VMPARAM_H_ */
@


1.21
log
@Allow mips64-based ports to override the default mips64 VM_PHYSSEG_STRAT
strategy value (BSEARCH); use BIGFIRST on loongson since there are only up
to two memory segments.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.20 2009/12/08 22:15:47 miod Exp $	*/
d61 3
@


1.20
log
@Unconditionnaly move kernel virtual memory space to XKSEG, now that previous
context.S fixes allows these settings to work for kernels linked in CKSEG0.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.19 2009/12/07 19:23:52 miod Exp $	*/
d47 1
a47 5
/*
 * USRTEXT is the start of the user text/data space, while USRSTACK
 * is the top (end) of the user stack.
 */
#define	USRTEXT		0x0000000000400000L
d90 1
d92 1
@


1.19
log
@Sync VM_MIN_ADDRESS with __LDPGSZ again.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.18 2009/11/22 00:07:04 miod Exp $	*/
d52 1
a52 1
#define	USRSTACK	0x0000000080000000L	/* Start of user stack */
d100 3
a102 5
#define VM_MAX_ADDRESS		((vaddr_t)0x0000000080000000L)
#ifndef	VM_MIN_KERNEL_ADDRESS
#define	VM_MIN_KERNEL_ADDRESS	((vaddr_t)0xffffffffc0000000L)
#define	VM_MAX_KERNEL_ADDRESS	((vaddr_t)0xfffffffffffff000L)
#endif
d106 1
a106 1
#define VM_PIE_MAX_ADDR		0x10000000UL
@


1.18
log
@Allow mips ports to override VM_{MIN,MAX}_KERNEL_ADDRESS, and provide the
address as a kernel variable for use by libkvm.

On sgi IP27 and IP30 kernels, use XKSEG instead of CKSSEG; this will allow
kernel KVM size to grow in the future if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.17 2009/10/22 18:20:21 miod Exp $	*/
d98 1
a98 1
#define VM_MIN_ADDRESS		((vaddr_t)0x0000000000001000L)
@


1.17
log
@Crank VM_MIN_ADDRESS to prevent userland from being able to mmap zero,
forgotten long ago and lingering in one of my trees since then...
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.16 2008/08/22 10:41:37 kurt Exp $	*/
d101 2
a102 1
#define VM_MIN_KERNEL_ADDRESS	((vaddr_t)0xffffffffc0000000L)
d104 1
@


1.16
log
@Set PIE address range to avoid or minimize mmap pressure due to limited
address space. The space between PAGE_SIZE and the non-pie fixed link
address creates no mmap pressure so use that space for PIE. However on
hppa the non-pie fixed link address is PAGE_SIZE so just use a small range
for PIE to minimize mmap pressure.

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.15 2008/07/25 21:25:25 miod Exp $	*/
d98 1
a98 1
#define VM_MIN_ADDRESS		((vaddr_t)0x0000000000000000L)
@


1.15
log
@phyio -> physio
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.14 2008/03/30 20:13:14 miod Exp $	*/
d103 4
@


1.14
log
@Allow the machine-specific headers to overwrite the number of memory
segments and the number of freelists.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.13 2007/05/03 19:34:00 miod Exp $	*/
d76 1
a76 1
 * PTEs for mapping user space into the kernel for phyio operations.
@


1.13
log
@Enable support for > 512MB of physical memory on mips64 systems, by using
XKPHYS instead of KSEG[01] for direct mappings.

Then, detect memory above 256MB on O2 by poking at the CRIME registers
(ARCbios will not report memory above 256MB, which is mapped above 1GB
physical, to the system), and add it to the UVM managed memory.

Tested on r5k, rm5200 and r10k with and without more than 256MB, matching
hinv reports in all cases. CRIME memory decoding based on a diff from
kettenis@@ in december 2005.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.12 2007/04/27 18:14:11 miod Exp $	*/
d91 1
d93 1
d104 1
d106 1
@


1.12
log
@More pmap changes from the potpourri pool:
- use wm_page pg_flags pmap-reserved flags to store attributes, instead of
  defining a vm_page_md field.
- use atomic operations to touch the above mentioned flags.
- never create ptes with PG_RO and PG_M set (this was harmless anyway).
- in pmap_clear_modify(), do not flush cache if the page was mapped uncached.

Tested on r5k, rm5200, r10k and r12k.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.11 2007/04/14 14:54:28 miod Exp $	*/
a94 1

a95 1
#ifdef __LP64__
d100 1
a100 7
#else
#define VM_MIN_ADDRESS		((vaddr_t)0x00000000)
#define VM_MAXUSER_ADDRESS	((vaddr_t)0x80000000)
#define VM_MAX_ADDRESS		((vaddr_t)0x80000000)
#define VM_MIN_KERNEL_ADDRESS	((vaddr_t)0xc0000000)
#endif
#define	VM_MAX_KERNEL_ADDRESS	((vaddr_t)-PAGE_SIZE)
@


1.11
log
@Crank KVM from a ridiculous pedro-sized 256MB to 1GB; needed for upcoming MI
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.10 2005/08/07 07:29:44 miod Exp $	*/
a125 1
	int		pv_flags;	/* Some flags for the mapping */
d130 1
a130 1
	struct pv_entry pvent;		/* pv list of this seg */
d135 3
a137 4
		(pg)->mdpage.pvent.pv_next = NULL; \
		(pg)->mdpage.pvent.pv_pmap = NULL; \
		(pg)->mdpage.pvent.pv_va = 0; \
		(pg)->mdpage.pvent.pv_flags = 0; \
@


1.10
log
@Remove advertising clause from UCB licenses; ok deraad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.9 2005/04/11 15:13:01 deraadt Exp $	*/
d108 1
a111 4

/* Kernel page table size is variable. */
extern vaddr_t virtual_end;
#define VM_MAX_KERNEL_ADDRESS	virtual_end
@


1.9
log
@use MD #define to choose stackgap size per-architecture.  on sparc, special
case sun4c/sun4 -- because address space is more constrained
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.8 2004/11/28 01:36:39 mickey Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@MAXSLP is not really an MD-configurable define so move it to param.h; miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.7 2004/11/11 16:12:59 pefo Exp $	*/
d76 2
@


1.7
log
@up default data size so things doesn't blow up to easy
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.6 2004/09/21 05:51:13 miod Exp $	*/
a91 11

/*
 * The time for a process to be blocked before being very swappable.
 * This is a number of seconds which the system takes as being a non-trivial
 * amount of real time.  You probably shouldn't change this;
 * it is used in subtle ways (fractions and multiples of it are, that is, like
 * half of a ``long time'', almost a long time, etc.)
 * It is related to human patience and other factors which don't really
 * change over time.
 */
#define	MAXSLP		20
@


1.6
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.5 2004/09/17 19:19:05 miod Exp $	*/
d65 1
a65 1
#define	DFLDSIZ		(64*1024*1024)		/* initial data size limit */
@


1.5
log
@Long-due mips pmap potpourri:
- un-__P()ee.
- remove splimp() protection.
- allow pmap_extract() to return FALSE, dammit!
  XXX some code under arch/mips64 considers pa == 0 as failure, instead
      of checking the return value of pmap_extract(). Free commits.
- do not peek at uvm vm_page flags for ref/mod accounting, but use real
  MD flags in pv lists, and implement pmap_is_* and pmap_clear_*, so uvm
  (which knows better) does the right thing.
- debug code #ifdef PMAPDEBUG, not #ifdef DIAGNOSTIC.
- merge pmap_init() and pmap_pinit(), pmap_destroy() and pmap_release(),
  and update comments.
- better pmap_enter() logic, from NetBSD.
- do not use IS_VM_PHYSADDR() to know if we can use PHYS_TO_VM_PAGE()
  unchecked. Instead, compute PHYS_TO_VM_PAGE(), and check it against
  NULL. Saves a vm_physseg_find() call each time.
- pass vm_page_t to internal function whenever possible, rather than
  paddr_t, so that PHYS_TO_VM_PAGE() needs not be computed again.
- in the same way, do not compute PHYS_TO_KSEG0(foo) several times in a
  row (though PHYS_TO_KSEG0 is trivial).
- allow userspace address to cross 0x80000000 (may be useful in the
  future).
- implement PMAP_CANFAIL.

As a bonus:
- switch from HAVE_PMAP_PHYSSEG to HAVE_VM_PAGE_MD.
- remove dead (pre-pmap_pv_pool) code.
- KNF fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.4 2004/09/09 22:21:41 pefo Exp $	*/
d126 1
a126 1
vaddr_t virtual_end;
@


1.4
log
@these should have gone in with the other 64 bit changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.3 2004/09/09 10:25:50 miod Exp $	*/
d132 1
d134 1
a134 1
 * pmap-specific data stored in the vm_physmem[] array.
d136 12
a147 4
#define __HAVE_PMAP_PHYSSEG
struct pmap_physseg {
	struct pv_entry *pvent;		/* pv list of this seg */
	char *attrs;
d149 10
@


1.3
log
@Kill mb_map and related defines, we don't need one.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.2 2004/08/10 20:28:13 deraadt Exp $	*/
d110 1
a110 1
#if (_MIPS_SZPTR == 64)
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.1 2004/08/06 20:56:02 pefo Exp $	*/
a129 1
#define VM_MBUF_SIZE		(NMBCLUSTERS*MCLBYTES)
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.2 1998/09/15 10:50:12 pefo Exp $	*/
d102 1
a102 1
#define	MAXSLP 		20
d140 1
a140 1
}; 
@

